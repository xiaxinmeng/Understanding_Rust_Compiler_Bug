{"sha": "91fae2791292c7374143e82814a375a12bfd4e83", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkxZmFlMjc5MTI5MmM3Mzc0MTQzZTgyODE0YTM3NWExMmJmZDRlODM=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-02-17T22:07:51Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-02-18T04:09:20Z"}, "message": "Modernize bitv mut fields and explicit self", "tree": {"sha": "3dfb15c581a44de87b3b87a17417d0a99ddc7f1b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3dfb15c581a44de87b3b87a17417d0a99ddc7f1b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/91fae2791292c7374143e82814a375a12bfd4e83", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/91fae2791292c7374143e82814a375a12bfd4e83", "html_url": "https://github.com/rust-lang/rust/commit/91fae2791292c7374143e82814a375a12bfd4e83", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/91fae2791292c7374143e82814a375a12bfd4e83/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a6945f2a45d56ef692cd8f2955dcef4e4c10d50a", "url": "https://api.github.com/repos/rust-lang/rust/commits/a6945f2a45d56ef692cd8f2955dcef4e4c10d50a", "html_url": "https://github.com/rust-lang/rust/commit/a6945f2a45d56ef692cd8f2955dcef4e4c10d50a"}], "stats": {"total": 286, "additions": 144, "deletions": 142}, "files": [{"sha": "c72f9ec2f98d0a19b03a7889c17c2d35d3aece96", "filename": "src/libstd/bitv.rs", "status": "modified", "additions": 132, "deletions": 134, "changes": 266, "blob_url": "https://github.com/rust-lang/rust/blob/91fae2791292c7374143e82814a375a12bfd4e83/src%2Flibstd%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91fae2791292c7374143e82814a375a12bfd4e83/src%2Flibstd%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbitv.rs?ref=91fae2791292c7374143e82814a375a12bfd4e83", "patch": "@@ -16,11 +16,7 @@ use core::vec;\n \n struct SmallBitv {\n     /// only the lowest nbits of this value are used. the rest is undefined.\n-    mut bits: u32\n-}\n-\n-fn SmallBitv(bits: u32) -> SmallBitv {\n-    SmallBitv {bits: bits}\n+    bits: u32\n }\n \n /// a mask that has a 1 for each defined bit in a small_bitv, assuming n bits\n@@ -30,9 +26,13 @@ fn small_mask(nbits: uint) -> u32 {\n }\n \n impl SmallBitv {\n+    static fn new(bits: u32) -> SmallBitv {\n+        SmallBitv {bits: bits}\n+    }\n \n     #[inline(always)]\n-    fn bits_op(right_bits: u32, nbits: uint, f: fn(u32, u32) -> u32) -> bool {\n+    fn bits_op(&mut self, right_bits: u32, nbits: uint,\n+               f: fn(u32, u32) -> u32) -> bool {\n         let mask = small_mask(nbits);\n         let old_b: u32 = self.bits;\n         let new_b = f(old_b, right_bits);\n@@ -41,32 +41,32 @@ impl SmallBitv {\n     }\n \n     #[inline(always)]\n-    fn union(s: &SmallBitv, nbits: uint) -> bool {\n+    fn union(&mut self, s: &SmallBitv, nbits: uint) -> bool {\n         self.bits_op(s.bits, nbits, |u1, u2| u1 | u2)\n     }\n \n     #[inline(always)]\n-    fn intersect(s: &SmallBitv, nbits: uint) -> bool {\n+    fn intersect(&mut self, s: &SmallBitv, nbits: uint) -> bool {\n         self.bits_op(s.bits, nbits, |u1, u2| u1 & u2)\n     }\n \n     #[inline(always)]\n-    fn become(s: &SmallBitv, nbits: uint) -> bool {\n+    fn become(&mut self, s: &SmallBitv, nbits: uint) -> bool {\n         self.bits_op(s.bits, nbits, |_u1, u2| u2)\n     }\n \n     #[inline(always)]\n-    fn difference(s: &SmallBitv, nbits: uint) -> bool {\n+    fn difference(&mut self, s: &SmallBitv, nbits: uint) -> bool {\n         self.bits_op(s.bits, nbits, |u1, u2| u1 & !u2)\n     }\n \n     #[inline(always)]\n-    pure fn get(i: uint) -> bool {\n+    pure fn get(&self, i: uint) -> bool {\n         (self.bits & (1 << i)) != 0\n     }\n \n     #[inline(always)]\n-    fn set(i: uint, x: bool) {\n+    fn set(&mut self, i: uint, x: bool) {\n         if x {\n             self.bits |= 1<<i;\n         }\n@@ -76,39 +76,34 @@ impl SmallBitv {\n     }\n \n     #[inline(always)]\n-    fn equals(b: &SmallBitv, nbits: uint) -> bool {\n+    fn equals(&self, b: &SmallBitv, nbits: uint) -> bool {\n         let mask = small_mask(nbits);\n         mask & self.bits == mask & b.bits\n     }\n \n     #[inline(always)]\n-    fn clear() { self.bits = 0; }\n+    fn clear(&mut self) { self.bits = 0; }\n \n     #[inline(always)]\n-    fn set_all() { self.bits = !0; }\n+    fn set_all(&mut self) { self.bits = !0; }\n \n     #[inline(always)]\n-    fn is_true(nbits: uint) -> bool {\n+    fn is_true(&self, nbits: uint) -> bool {\n         small_mask(nbits) & !self.bits == 0\n     }\n \n     #[inline(always)]\n-    fn is_false(nbits: uint) -> bool {\n+    fn is_false(&self, nbits: uint) -> bool {\n         small_mask(nbits) & self.bits == 0\n     }\n \n     #[inline(always)]\n-    fn invert() { self.bits = !self.bits; }\n+    fn invert(&mut self) { self.bits = !self.bits; }\n \n }\n \n struct BigBitv {\n-    // only mut b/c of clone and lack of other constructor\n-    mut storage: ~[uint]\n-}\n-\n-fn BigBitv(storage: ~[uint]) -> BigBitv {\n-    BigBitv {storage: storage}\n+    storage: ~[uint]\n }\n \n /**\n@@ -128,9 +123,13 @@ fn big_mask(nbits: uint, elem: uint) -> uint {\n }\n \n impl BigBitv {\n+    static fn new(storage: ~[uint]) -> BigBitv {\n+        BigBitv {storage: storage}\n+    }\n \n     #[inline(always)]\n-    fn process(b: &BigBitv, nbits: uint, op: fn(uint, uint) -> uint) -> bool {\n+    fn process(&mut self, b: &BigBitv, nbits: uint,\n+               op: fn(uint, uint) -> uint) -> bool {\n         let len = b.storage.len();\n         assert (self.storage.len() == len);\n         let mut changed = false;\n@@ -151,7 +150,7 @@ impl BigBitv {\n     }\n \n     #[inline(always)]\n-     fn each_storage(op: fn(v: &mut uint) -> bool) {\n+    fn each_storage(&mut self, op: fn(v: &mut uint) -> bool) {\n         for uint::range(0, self.storage.len()) |i| {\n             let mut w = self.storage[i];\n             let b = op(&mut w);\n@@ -161,47 +160,47 @@ impl BigBitv {\n      }\n \n     #[inline(always)]\n-    fn invert() { for self.each_storage() |w| { *w = !*w } }\n+    fn invert(&mut self) { for self.each_storage |w| { *w = !*w } }\n \n     #[inline(always)]\n-    fn union(b: &BigBitv, nbits: uint) -> bool {\n+    fn union(&mut self, b: &BigBitv, nbits: uint) -> bool {\n         self.process(b, nbits, lor)\n     }\n \n     #[inline(always)]\n-    fn intersect(b: &BigBitv, nbits: uint) -> bool {\n+    fn intersect(&mut self, b: &BigBitv, nbits: uint) -> bool {\n         self.process(b, nbits, land)\n     }\n \n     #[inline(always)]\n-    fn become(b: &BigBitv, nbits: uint) -> bool {\n+    fn become(&mut self, b: &BigBitv, nbits: uint) -> bool {\n         self.process(b, nbits, right)\n     }\n \n     #[inline(always)]\n-    fn difference(b: &BigBitv, nbits: uint) -> bool {\n+    fn difference(&mut self, b: &BigBitv, nbits: uint) -> bool {\n         self.process(b, nbits, difference)\n     }\n \n     #[inline(always)]\n-    pure fn get(i: uint) -> bool {\n+    pure fn get(&self, i: uint) -> bool {\n         let w = i / uint_bits;\n         let b = i % uint_bits;\n         let x = 1 & self.storage[w] >> b;\n         x == 1\n     }\n \n     #[inline(always)]\n-    fn set(i: uint, x: bool) {\n+    fn set(&mut self, i: uint, x: bool) {\n         let w = i / uint_bits;\n         let b = i % uint_bits;\n         let flag = 1 << b;\n         self.storage[w] = if x { self.storage[w] | flag }\n-                 else { self.storage[w] & !flag };\n+                          else { self.storage[w] & !flag };\n     }\n \n     #[inline(always)]\n-    fn equals(b: &BigBitv, nbits: uint) -> bool {\n+    fn equals(&self, b: &BigBitv, nbits: uint) -> bool {\n         let len = b.storage.len();\n         for uint::iterate(0, len) |i| {\n             let mask = big_mask(nbits, i);\n@@ -223,33 +222,19 @@ pub struct Bitv {\n     nbits: uint\n }\n \n-pub fn Bitv (nbits: uint, init: bool) -> Bitv {\n-    let rep = if nbits <= 32 {\n-        Small(~SmallBitv(if init {!0} else {0}))\n-    }\n-    else {\n-        let nelems = nbits/uint_bits +\n-                     if nbits % uint_bits == 0 {0} else {1};\n-        let elem = if init {!0} else {0};\n-        let s = from_elem(nelems, elem);\n-        Big(~BigBitv(s))\n-    };\n-    Bitv {rep: rep, nbits: nbits}\n-}\n-\n priv impl Bitv {\n \n-    fn die() -> ! {\n+    fn die(&self) -> ! {\n         fail!(~\"Tried to do operation on bit vectors with different sizes\");\n     }\n \n     #[inline(always)]\n-    fn do_op(op: Op, other: &Bitv) -> bool {\n+    fn do_op(&mut self, op: Op, other: &Bitv) -> bool {\n         if self.nbits != other.nbits {\n             self.die();\n         }\n         match self.rep {\n-          Small(ref s) => match other.rep {\n+          Small(ref mut s) => match other.rep {\n             Small(ref s1) => match op {\n               Union      => s.union(*s1,      self.nbits),\n               Intersect  => s.intersect(*s1,  self.nbits),\n@@ -258,7 +243,7 @@ priv impl Bitv {\n             },\n             Big(_) => self.die()\n           },\n-          Big(ref s) => match other.rep {\n+          Big(ref mut s) => match other.rep {\n             Small(_) => self.die(),\n             Big(ref s1) => match op {\n               Union      => s.union(*s1,      self.nbits),\n@@ -273,6 +258,19 @@ priv impl Bitv {\n }\n \n impl Bitv {\n+    static fn new(nbits: uint, init: bool) -> Bitv {\n+        let rep = if nbits <= 32 {\n+            Small(~SmallBitv::new(if init {!0} else {0}))\n+        }\n+        else {\n+            let nelems = nbits/uint_bits +\n+                         if nbits % uint_bits == 0 {0} else {1};\n+            let elem = if init {!0} else {0};\n+            let s = from_elem(nelems, elem);\n+            Big(~BigBitv::new(s))\n+        };\n+        Bitv {rep: rep, nbits: nbits}\n+    }\n \n     /**\n      * Calculates the union of two bitvectors\n@@ -281,7 +279,7 @@ impl Bitv {\n      * the same length. Returns 'true' if `self` changed.\n     */\n     #[inline(always)]\n-    fn union(v1: &Bitv) -> bool { self.do_op(Union, v1) }\n+    fn union(&mut self, v1: &Bitv) -> bool { self.do_op(Union, v1) }\n \n     /**\n      * Calculates the intersection of two bitvectors\n@@ -290,7 +288,7 @@ impl Bitv {\n      * must be the same length. Returns 'true' if `self` changed.\n     */\n     #[inline(always)]\n-    fn intersect(v1: &Bitv) -> bool { self.do_op(Intersect, v1) }\n+    fn intersect(&mut self, v1: &Bitv) -> bool { self.do_op(Intersect, v1) }\n \n     /**\n      * Assigns the value of `v1` to `self`\n@@ -299,11 +297,11 @@ impl Bitv {\n      * changed\n      */\n     #[inline(always)]\n-    fn assign(v: &Bitv) -> bool { self.do_op(Assign, v) }\n+    fn assign(&mut self, v: &Bitv) -> bool { self.do_op(Assign, v) }\n \n     /// Retrieve the value at index `i`\n     #[inline(always)]\n-    pure fn get(i: uint) -> bool {\n+    pure fn get(&self, i: uint) -> bool {\n        assert (i < self.nbits);\n        match self.rep {\n          Big(ref b)   => b.get(i),\n@@ -317,11 +315,11 @@ impl Bitv {\n      * `i` must be less than the length of the bitvector.\n      */\n     #[inline(always)]\n-    fn set(i: uint, x: bool) {\n+    fn set(&mut self, i: uint, x: bool) {\n       assert (i < self.nbits);\n       match self.rep {\n-        Big(ref b)   => b.set(i, x),\n-        Small(ref s) => s.set(i, x)\n+        Big(ref mut b)   => b.set(i, x),\n+        Small(ref mut s) => s.set(i, x)\n       }\n     }\n \n@@ -332,7 +330,7 @@ impl Bitv {\n      * bitvectors contain identical elements.\n      */\n     #[inline(always)]\n-    fn equal(v1: &Bitv) -> bool {\n+    fn equal(&self, v1: &Bitv) -> bool {\n       if self.nbits != v1.nbits { return false; }\n       match self.rep {\n         Small(ref b) => match v1.rep {\n@@ -348,27 +346,27 @@ impl Bitv {\n \n     /// Set all bits to 0\n     #[inline(always)]\n-    fn clear() {\n+    fn clear(&mut self) {\n         match self.rep {\n-          Small(ref b) => b.clear(),\n-          Big(ref s) => for s.each_storage() |w| { *w = 0u }\n+          Small(ref mut b) => b.clear(),\n+          Big(ref mut s) => for s.each_storage() |w| { *w = 0u }\n         }\n     }\n \n     /// Set all bits to 1\n     #[inline(always)]\n-    fn set_all() {\n+    fn set_all(&mut self) {\n       match self.rep {\n-        Small(ref b) => b.set_all(),\n-        Big(ref s) => for s.each_storage() |w| { *w = !0u } }\n+        Small(ref mut b) => b.set_all(),\n+        Big(ref mut s) => for s.each_storage() |w| { *w = !0u } }\n     }\n \n     /// Invert all bits\n     #[inline(always)]\n-    fn invert() {\n+    fn invert(&mut self) {\n       match self.rep {\n-        Small(ref b) => b.invert(),\n-        Big(ref s) => for s.each_storage() |w| { *w = !*w } }\n+        Small(ref mut b) => b.invert(),\n+        Big(ref mut s) => for s.each_storage() |w| { *w = !*w } }\n     }\n \n     /**\n@@ -381,11 +379,11 @@ impl Bitv {\n      * Returns `true` if `v0` was changed.\n      */\n     #[inline(always)]\n-    fn difference(v: &Bitv) -> bool { self.do_op(Difference, v) }\n+    fn difference(&mut self, v: &Bitv) -> bool { self.do_op(Difference, v) }\n \n     /// Returns true if all bits are 1\n     #[inline(always)]\n-    fn is_true() -> bool {\n+    fn is_true(&self) -> bool {\n       match self.rep {\n         Small(ref b) => b.is_true(self.nbits),\n         _ => {\n@@ -396,7 +394,7 @@ impl Bitv {\n     }\n \n     #[inline(always)]\n-    fn each(f: fn(bool) -> bool) {\n+    fn each(&self, f: fn(bool) -> bool) {\n         let mut i = 0;\n         while i < self.nbits {\n             if !f(self.get(i)) { break; }\n@@ -405,7 +403,7 @@ impl Bitv {\n     }\n \n     /// Returns true if all bits are 0\n-    fn is_false() -> bool {\n+    fn is_false(&self) -> bool {\n       match self.rep {\n         Small(ref b) => b.is_false(self.nbits),\n         Big(_) => {\n@@ -415,7 +413,7 @@ impl Bitv {\n       }\n     }\n \n-    fn init_to_vec(i: uint) -> uint {\n+    fn init_to_vec(&self, i: uint) -> uint {\n       return if self.get(i) { 1 } else { 0 };\n     }\n \n@@ -424,7 +422,7 @@ impl Bitv {\n      *\n      * Each uint in the resulting vector has either value 0u or 1u.\n      */\n-    fn to_vec() -> ~[uint] {\n+    fn to_vec(&self) -> ~[uint] {\n         vec::from_fn(self.nbits, |x| self.init_to_vec(x))\n     }\n \n@@ -434,7 +432,7 @@ impl Bitv {\n      * size of the bitv is not a multiple of 8 then trailing bits\n      * will be filled-in with false/0\n      */\n-    fn to_bytes() -> ~[u8] {\n+    fn to_bytes(&self) -> ~[u8] {\n \n         fn bit (bitv: &Bitv, byte: uint, bit: uint) -> u8 {\n             let offset = byte * 8 + bit;\n@@ -448,21 +446,21 @@ impl Bitv {\n         let len = self.nbits/8 +\n                   if self.nbits % 8 == 0 { 0 } else { 1 };\n         vec::from_fn(len, |i|\n-            bit(&self, i, 0) |\n-            bit(&self, i, 1) |\n-            bit(&self, i, 2) |\n-            bit(&self, i, 3) |\n-            bit(&self, i, 4) |\n-            bit(&self, i, 5) |\n-            bit(&self, i, 6) |\n-            bit(&self, i, 7)\n+            bit(self, i, 0) |\n+            bit(self, i, 1) |\n+            bit(self, i, 2) |\n+            bit(self, i, 3) |\n+            bit(self, i, 4) |\n+            bit(self, i, 5) |\n+            bit(self, i, 6) |\n+            bit(self, i, 7)\n         )\n     }\n \n     /**\n      * Transform self into a [bool] by turning each bit into a bool\n      */\n-    fn to_bools() -> ~[bool] {\n+    fn to_bools(&self) -> ~[bool] {\n         vec::from_fn(self.nbits, |i| self[i])\n     }\n \n@@ -485,7 +483,7 @@ impl Bitv {\n      * The uint vector is expected to only contain the values 0u and 1u. Both\n      * the bitvector and vector must have the same length\n      */\n-    fn eq_vec(v: ~[uint]) -> bool {\n+    fn eq_vec(&self, v: ~[uint]) -> bool {\n         assert self.nbits == v.len();\n         let mut i = 0;\n         while i < self.nbits {\n@@ -497,7 +495,7 @@ impl Bitv {\n         true\n     }\n \n-    fn ones(f: fn(uint) -> bool) {\n+    fn ones(&self, f: fn(uint) -> bool) {\n         for uint::range(0, self.nbits) |i| {\n             if self.get(i) {\n                 if !f(i) { break }\n@@ -551,7 +549,7 @@ pub fn from_bools(bools: &[bool]) -> Bitv {\n  * index is f(index).\n  */\n pub fn from_fn(len: uint, f: fn(index: uint) -> bool) -> Bitv {\n-    let bitv = Bitv(len, false);\n+    let mut bitv = Bitv::new(len, false);\n     for uint::range(0, len) |i| {\n         bitv.set(i, f(i));\n     }\n@@ -586,34 +584,34 @@ mod tests {\n \n     #[test]\n     pub fn test_to_str() {\n-        let zerolen = Bitv(0u, false);\n+        let zerolen = Bitv::new(0u, false);\n         assert zerolen.to_str() == ~\"\";\n \n-        let eightbits = Bitv(8u, false);\n+        let eightbits = Bitv::new(8u, false);\n         assert eightbits.to_str() == ~\"00000000\";\n     }\n \n     #[test]\n     pub fn test_0_elements() {\n         let mut act;\n         let mut exp;\n-        act = Bitv(0u, false);\n+        act = Bitv::new(0u, false);\n         exp = vec::from_elem::<uint>(0u, 0u);\n         assert act.eq_vec(exp);\n     }\n \n     #[test]\n     pub fn test_1_element() {\n         let mut act;\n-        act = Bitv(1u, false);\n+        act = Bitv::new(1u, false);\n         assert act.eq_vec(~[0u]);\n-        act = Bitv(1u, true);\n+        act = Bitv::new(1u, true);\n         assert act.eq_vec(~[1u]);\n     }\n \n     #[test]\n     pub fn test_2_elements() {\n-        let b = bitv::Bitv(2, false);\n+        let mut b = bitv::Bitv::new(2, false);\n         b.set(0, true);\n         b.set(1, false);\n         assert b.to_str() == ~\"10\";\n@@ -624,15 +622,15 @@ mod tests {\n         let mut act;\n         // all 0\n \n-        act = Bitv(10u, false);\n+        act = Bitv::new(10u, false);\n         assert (act.eq_vec(~[0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u]));\n         // all 1\n \n-        act = Bitv(10u, true);\n+        act = Bitv::new(10u, true);\n         assert (act.eq_vec(~[1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u]));\n         // mixed\n \n-        act = Bitv(10u, false);\n+        act = Bitv::new(10u, false);\n         act.set(0u, true);\n         act.set(1u, true);\n         act.set(2u, true);\n@@ -641,7 +639,7 @@ mod tests {\n         assert (act.eq_vec(~[1u, 1u, 1u, 1u, 1u, 0u, 0u, 0u, 0u, 0u]));\n         // mixed\n \n-        act = Bitv(10u, false);\n+        act = Bitv::new(10u, false);\n         act.set(5u, true);\n         act.set(6u, true);\n         act.set(7u, true);\n@@ -650,7 +648,7 @@ mod tests {\n         assert (act.eq_vec(~[0u, 0u, 0u, 0u, 0u, 1u, 1u, 1u, 1u, 1u]));\n         // mixed\n \n-        act = Bitv(10u, false);\n+        act = Bitv::new(10u, false);\n         act.set(0u, true);\n         act.set(3u, true);\n         act.set(6u, true);\n@@ -663,21 +661,21 @@ mod tests {\n         let mut act;\n         // all 0\n \n-        act = Bitv(31u, false);\n+        act = Bitv::new(31u, false);\n         assert (act.eq_vec(\n                        ~[0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                         0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                         0u, 0u, 0u, 0u, 0u]));\n         // all 1\n \n-        act = Bitv(31u, true);\n+        act = Bitv::new(31u, true);\n         assert (act.eq_vec(\n                        ~[1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u,\n                         1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u,\n                         1u, 1u, 1u, 1u, 1u]));\n         // mixed\n \n-        act = Bitv(31u, false);\n+        act = Bitv::new(31u, false);\n         act.set(0u, true);\n         act.set(1u, true);\n         act.set(2u, true);\n@@ -692,7 +690,7 @@ mod tests {\n                         0u, 0u, 0u, 0u, 0u]));\n         // mixed\n \n-        act = Bitv(31u, false);\n+        act = Bitv::new(31u, false);\n         act.set(16u, true);\n         act.set(17u, true);\n         act.set(18u, true);\n@@ -707,7 +705,7 @@ mod tests {\n                         0u, 0u, 0u, 0u, 0u]));\n         // mixed\n \n-        act = Bitv(31u, false);\n+        act = Bitv::new(31u, false);\n         act.set(24u, true);\n         act.set(25u, true);\n         act.set(26u, true);\n@@ -721,7 +719,7 @@ mod tests {\n                         1u, 1u, 1u, 1u, 1u]));\n         // mixed\n \n-        act = Bitv(31u, false);\n+        act = Bitv::new(31u, false);\n         act.set(3u, true);\n         act.set(17u, true);\n         act.set(30u, true);\n@@ -736,21 +734,21 @@ mod tests {\n         let mut act;\n         // all 0\n \n-        act = Bitv(32u, false);\n+        act = Bitv::new(32u, false);\n         assert (act.eq_vec(\n                        ~[0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                         0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                         0u, 0u, 0u, 0u, 0u, 0u]));\n         // all 1\n \n-        act = Bitv(32u, true);\n+        act = Bitv::new(32u, true);\n         assert (act.eq_vec(\n                        ~[1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u,\n                         1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u,\n                         1u, 1u, 1u, 1u, 1u, 1u]));\n         // mixed\n \n-        act = Bitv(32u, false);\n+        act = Bitv::new(32u, false);\n         act.set(0u, true);\n         act.set(1u, true);\n         act.set(2u, true);\n@@ -765,7 +763,7 @@ mod tests {\n                         0u, 0u, 0u, 0u, 0u, 0u]));\n         // mixed\n \n-        act = Bitv(32u, false);\n+        act = Bitv::new(32u, false);\n         act.set(16u, true);\n         act.set(17u, true);\n         act.set(18u, true);\n@@ -780,7 +778,7 @@ mod tests {\n                         0u, 0u, 0u, 0u, 0u, 0u]));\n         // mixed\n \n-        act = Bitv(32u, false);\n+        act = Bitv::new(32u, false);\n         act.set(24u, true);\n         act.set(25u, true);\n         act.set(26u, true);\n@@ -795,7 +793,7 @@ mod tests {\n                         1u, 1u, 1u, 1u, 1u, 1u]));\n         // mixed\n \n-        act = Bitv(32u, false);\n+        act = Bitv::new(32u, false);\n         act.set(3u, true);\n         act.set(17u, true);\n         act.set(30u, true);\n@@ -811,21 +809,21 @@ mod tests {\n         let mut act;\n         // all 0\n \n-        act = Bitv(33u, false);\n+        act = Bitv::new(33u, false);\n         assert (act.eq_vec(\n                        ~[0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                         0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n                         0u, 0u, 0u, 0u, 0u, 0u, 0u]));\n         // all 1\n \n-        act = Bitv(33u, true);\n+        act = Bitv::new(33u, true);\n         assert (act.eq_vec(\n                        ~[1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u,\n                         1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u,\n                         1u, 1u, 1u, 1u, 1u, 1u, 1u]));\n         // mixed\n \n-        act = Bitv(33u, false);\n+        act = Bitv::new(33u, false);\n         act.set(0u, true);\n         act.set(1u, true);\n         act.set(2u, true);\n@@ -840,7 +838,7 @@ mod tests {\n                         0u, 0u, 0u, 0u, 0u, 0u, 0u]));\n         // mixed\n \n-        act = Bitv(33u, false);\n+        act = Bitv::new(33u, false);\n         act.set(16u, true);\n         act.set(17u, true);\n         act.set(18u, true);\n@@ -855,7 +853,7 @@ mod tests {\n                         0u, 0u, 0u, 0u, 0u, 0u, 0u]));\n         // mixed\n \n-        act = Bitv(33u, false);\n+        act = Bitv::new(33u, false);\n         act.set(24u, true);\n         act.set(25u, true);\n         act.set(26u, true);\n@@ -870,7 +868,7 @@ mod tests {\n                         1u, 1u, 1u, 1u, 1u, 1u, 0u]));\n         // mixed\n \n-        act = Bitv(33u, false);\n+        act = Bitv::new(33u, false);\n         act.set(3u, true);\n         act.set(17u, true);\n         act.set(30u, true);\n@@ -884,37 +882,37 @@ mod tests {\n \n     #[test]\n     pub fn test_equal_differing_sizes() {\n-        let v0 = Bitv(10u, false);\n-        let v1 = Bitv(11u, false);\n+        let v0 = Bitv::new(10u, false);\n+        let v1 = Bitv::new(11u, false);\n         assert !v0.equal(&v1);\n     }\n \n     #[test]\n     pub fn test_equal_greatly_differing_sizes() {\n-        let v0 = Bitv(10u, false);\n-        let v1 = Bitv(110u, false);\n+        let v0 = Bitv::new(10u, false);\n+        let v1 = Bitv::new(110u, false);\n         assert !v0.equal(&v1);\n     }\n \n     #[test]\n     pub fn test_equal_sneaky_small() {\n-        let a = bitv::Bitv(1, false);\n+        let mut a = bitv::Bitv::new(1, false);\n         a.set(0, true);\n \n-        let b = bitv::Bitv(1, true);\n+        let mut b = bitv::Bitv::new(1, true);\n         b.set(0, true);\n \n         assert a.equal(&b);\n     }\n \n     #[test]\n     pub fn test_equal_sneaky_big() {\n-        let a = bitv::Bitv(100, false);\n+        let mut a = bitv::Bitv::new(100, false);\n         for uint::range(0, 100) |i| {\n             a.set(i, true);\n         }\n \n-        let b = bitv::Bitv(100, true);\n+        let mut b = bitv::Bitv::new(100, true);\n         for uint::range(0, 100) |i| {\n             b.set(i, true);\n         }\n@@ -931,11 +929,11 @@ mod tests {\n \n     #[test]\n     pub fn test_to_bytes() {\n-        let bv = Bitv(3, true);\n+        let mut bv = Bitv::new(3, true);\n         bv.set(1, false);\n         assert bv.to_bytes() == ~[0b10100000];\n \n-        let bv = Bitv(9, false);\n+        let mut bv = Bitv::new(9, false);\n         bv.set(2, true);\n         bv.set(8, true);\n         assert bv.to_bytes() == ~[0b00100000, 0b10000000];\n@@ -954,8 +952,8 @@ mod tests {\n \n     #[test]\n     pub fn test_small_difference() {\n-      let b1 = Bitv(3, false);\n-      let b2 = Bitv(3, false);\n+      let mut b1 = Bitv::new(3, false);\n+      let mut b2 = Bitv::new(3, false);\n       b1.set(0, true);\n       b1.set(1, true);\n       b2.set(1, true);\n@@ -968,8 +966,8 @@ mod tests {\n \n     #[test]\n     pub fn test_big_difference() {\n-      let b1 = Bitv(100, false);\n-      let b2 = Bitv(100, false);\n+      let mut b1 = Bitv::new(100, false);\n+      let mut b2 = Bitv::new(100, false);\n       b1.set(0, true);\n       b1.set(40, true);\n       b2.set(40, true);\n@@ -982,7 +980,7 @@ mod tests {\n \n     #[test]\n     pub fn test_small_clear() {\n-      let b = Bitv(14, true);\n+      let mut b = Bitv::new(14, true);\n       b.clear();\n       for b.ones |i| {\n           fail!(fmt!(\"found 1 at %?\", i));\n@@ -991,7 +989,7 @@ mod tests {\n \n     #[test]\n     pub fn test_big_clear() {\n-      let b = Bitv(140, true);\n+      let mut b = Bitv::new(140, true);\n       b.clear();\n       for b.ones |i| {\n           fail!(fmt!(\"found 1 at %?\", i));"}, {"sha": "a7f01d756485984a9b67d8dcd1693e4d1a6b075a", "filename": "src/libsyntax/ext/pipes/liveness.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/91fae2791292c7374143e82814a375a12bfd4e83/src%2Flibsyntax%2Fext%2Fpipes%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91fae2791292c7374143e82814a375a12bfd4e83/src%2Flibsyntax%2Fext%2Fpipes%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fliveness.rs?ref=91fae2791292c7374143e82814a375a12bfd4e83", "patch": "@@ -43,13 +43,13 @@ use ext::base::ext_ctxt;\n use ext::pipes::proto::protocol;\n \n use core::str;\n-use std::bitv::{Bitv};\n+use std::bitv::Bitv;\n \n pub fn analyze(proto: protocol, _cx: ext_ctxt) {\n     debug!(\"initializing colive analysis\");\n     let num_states = proto.num_states();\n-    let colive = do (copy proto.states).map_to_vec |state| {\n-        let bv = ~Bitv(num_states, false);\n+    let mut colive = do (copy proto.states).map_to_vec |state| {\n+        let mut bv = ~Bitv::new(num_states, false);\n         for state.reachable |s| {\n             bv.set(s.id, true);\n         }\n@@ -61,15 +61,19 @@ pub fn analyze(proto: protocol, _cx: ext_ctxt) {\n     while changed {\n         changed = false;\n         debug!(\"colive iteration %?\", i);\n+        let mut new_colive = ~[];\n         for colive.eachi |i, this_colive| {\n+            let mut result = ~this_colive.clone();\n             let this = proto.get_state_by_id(i);\n             for this_colive.ones |j| {\n                 let next = proto.get_state_by_id(j);\n                 if this.dir == next.dir {\n-                    changed = changed || this_colive.union(colive[j]);\n+                    changed = result.union(colive[j]) || changed;\n                 }\n             }\n+            new_colive.push(result)\n         }\n+        colive = new_colive;\n         i += 1;\n     }\n "}, {"sha": "a3a3ef85f45ae5f1899467386e35bad83d89c420", "filename": "src/test/bench/sudoku.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/91fae2791292c7374143e82814a375a12bfd4e83/src%2Ftest%2Fbench%2Fsudoku.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91fae2791292c7374143e82814a375a12bfd4e83/src%2Ftest%2Fbench%2Fsudoku.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fsudoku.rs?ref=91fae2791292c7374143e82814a375a12bfd4e83", "patch": "@@ -58,7 +58,7 @@ pub fn solve_grid(g: grid_t) {\n     fn next_color(mut g: grid, row: u8, col: u8, start_color: u8) -> bool {\n         if start_color < 10u8 {\n             // colors not yet used\n-            let avail = bitv::Bitv(10u, false);\n+            let mut avail = bitv::Bitv::new(10u, false);\n             for u8::range(start_color, 10u8) |color| {\n                 avail.set(color as uint, true);\n             }\n@@ -80,7 +80,7 @@ pub fn solve_grid(g: grid_t) {\n \n     // find colors available in neighbourhood of (row, col)\n     fn drop_colors(g: grid, avail: bitv::Bitv, row: u8, col: u8) {\n-        fn drop_color(g: grid, colors: bitv::Bitv, row: u8, col: u8) {\n+        fn drop_color(g: grid, mut colors: bitv::Bitv, row: u8, col: u8) {\n             let color = g[row][col];\n             if color != 0u8 { colors.set(color as uint, false); }\n         }"}, {"sha": "6cb0cf4e3776d7caad1a67eb88a5e8f48c1d7b24", "filename": "src/test/run-pass/bitv-perf-test.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/91fae2791292c7374143e82814a375a12bfd4e83/src%2Ftest%2Frun-pass%2Fbitv-perf-test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91fae2791292c7374143e82814a375a12bfd4e83/src%2Ftest%2Frun-pass%2Fbitv-perf-test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbitv-perf-test.rs?ref=91fae2791292c7374143e82814a375a12bfd4e83", "patch": "@@ -14,8 +14,8 @@ extern mod std;\n use std::bitv::*;\n \n fn bitv_test() -> bool {\n-    let v1 = ~Bitv(31, false);\n-    let v2 = ~Bitv(31, true);\n+    let mut v1 = ~Bitv::new(31, false);\n+    let v2 = ~Bitv::new(31, true);\n     v1.union(v2);\n     true\n }"}]}