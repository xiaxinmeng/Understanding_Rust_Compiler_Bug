{"sha": "d46246b14adb519a80cf00d36e72a49a26484eee", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ0NjI0NmIxNGFkYjUxOWE4MGNmMDBkMzZlNzJhNDlhMjY0ODRlZWU=", "commit": {"author": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2018-10-25T12:49:51Z"}, "committer": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2018-11-03T13:31:09Z"}, "message": "Move collect_and_partition_mono_items to rustc_mir", "tree": {"sha": "52261176f63b0b12f7411af17dca66af112a8924", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/52261176f63b0b12f7411af17dca66af112a8924"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d46246b14adb519a80cf00d36e72a49a26484eee", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d46246b14adb519a80cf00d36e72a49a26484eee", "html_url": "https://github.com/rust-lang/rust/commit/d46246b14adb519a80cf00d36e72a49a26484eee", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d46246b14adb519a80cf00d36e72a49a26484eee/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "942864a000efd74b73e36bda5606b2cdb55ecf39", "url": "https://api.github.com/repos/rust-lang/rust/commits/942864a000efd74b73e36bda5606b2cdb55ecf39", "html_url": "https://github.com/rust-lang/rust/commit/942864a000efd74b73e36bda5606b2cdb55ecf39"}], "stats": {"total": 325, "additions": 165, "deletions": 160}, "files": [{"sha": "5a77816c9da27df7ceaa67b1b27f4e8e59e4b7c9", "filename": "src/Cargo.lock", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d46246b14adb519a80cf00d36e72a49a26484eee/src%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/d46246b14adb519a80cf00d36e72a49a26484eee/src%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FCargo.lock?ref=d46246b14adb519a80cf00d36e72a49a26484eee", "patch": "@@ -2141,11 +2141,13 @@ dependencies = [\n  \"flate2 1.0.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.4.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc 0.0.0\",\n+ \"rustc_allocator 0.0.0\",\n  \"rustc_data_structures 0.0.0\",\n  \"rustc_incremental 0.0.0\",\n  \"rustc_metadata_utils 0.0.0\",\n  \"rustc_mir 0.0.0\",\n  \"rustc_target 0.0.0\",\n+ \"serialize 0.0.0\",\n  \"syntax 0.0.0\",\n  \"syntax_pos 0.0.0\",\n ]"}, {"sha": "30bf4c33cda6d94d8c3c39b979b2bdcefbd5c488", "filename": "src/librustc_codegen_llvm/base.rs", "status": "modified", "additions": 4, "deletions": 151, "changes": 155, "blob_url": "https://github.com/rust-lang/rust/blob/d46246b14adb519a80cf00d36e72a49a26484eee/src%2Flibrustc_codegen_llvm%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d46246b14adb519a80cf00d36e72a49a26484eee/src%2Flibrustc_codegen_llvm%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fbase.rs?ref=d46246b14adb519a80cf00d36e72a49a26484eee", "patch": "@@ -54,7 +54,6 @@ use attributes;\n use builder::{Builder, MemFlags};\n use callee;\n use common::{C_bool, C_bytes_in_context, C_i32, C_usize};\n-use rustc_mir::monomorphize::collector::{self, MonoItemCollectionMode};\n use rustc_mir::monomorphize::item::DefPathBasedNames;\n use common::{C_struct_in_context, C_array, val_ty};\n use consts;\n@@ -64,13 +63,13 @@ use declare;\n use meth;\n use mir;\n use monomorphize::Instance;\n-use monomorphize::partitioning::{self, PartitioningStrategy, CodegenUnit, CodegenUnitExt};\n+use monomorphize::partitioning::{CodegenUnit, CodegenUnitExt};\n use rustc_codegen_utils::symbol_names_test;\n use time_graph;\n-use mono_item::{MonoItem, BaseMonoItemExt, MonoItemExt};\n+use mono_item::{MonoItem, MonoItemExt};\n use type_::Type;\n use type_of::LayoutLlvmExt;\n-use rustc::util::nodemap::{FxHashMap, DefIdSet};\n+use rustc::util::nodemap::FxHashMap;\n use CrateInfo;\n use rustc_data_structures::small_c_str::SmallCStr;\n use rustc_data_structures::sync::Lrc;\n@@ -80,7 +79,6 @@ use std::cmp;\n use std::ffi::CString;\n use std::i32;\n use std::ops::{Deref, DerefMut};\n-use std::sync::Arc;\n use std::sync::mpsc;\n use std::time::{Instant, Duration};\n use syntax_pos::Span;\n@@ -1011,128 +1009,6 @@ fn assert_and_save_dep_graph<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n          || rustc_incremental::save_dep_graph(tcx));\n }\n \n-fn collect_and_partition_mono_items<'a, 'tcx>(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    cnum: CrateNum,\n-) -> (Arc<DefIdSet>, Arc<Vec<Arc<CodegenUnit<'tcx>>>>)\n-{\n-    assert_eq!(cnum, LOCAL_CRATE);\n-\n-    let collection_mode = match tcx.sess.opts.debugging_opts.print_mono_items {\n-        Some(ref s) => {\n-            let mode_string = s.to_lowercase();\n-            let mode_string = mode_string.trim();\n-            if mode_string == \"eager\" {\n-                MonoItemCollectionMode::Eager\n-            } else {\n-                if mode_string != \"lazy\" {\n-                    let message = format!(\"Unknown codegen-item collection mode '{}'. \\\n-                                           Falling back to 'lazy' mode.\",\n-                                          mode_string);\n-                    tcx.sess.warn(&message);\n-                }\n-\n-                MonoItemCollectionMode::Lazy\n-            }\n-        }\n-        None => {\n-            if tcx.sess.opts.cg.link_dead_code {\n-                MonoItemCollectionMode::Eager\n-            } else {\n-                MonoItemCollectionMode::Lazy\n-            }\n-        }\n-    };\n-\n-    let (items, inlining_map) =\n-        time(tcx.sess, \"monomorphization collection\", || {\n-            collector::collect_crate_mono_items(tcx, collection_mode)\n-    });\n-\n-    tcx.sess.abort_if_errors();\n-\n-    ::rustc_mir::monomorphize::assert_symbols_are_distinct(tcx, items.iter());\n-\n-    let strategy = if tcx.sess.opts.incremental.is_some() {\n-        PartitioningStrategy::PerModule\n-    } else {\n-        PartitioningStrategy::FixedUnitCount(tcx.sess.codegen_units())\n-    };\n-\n-    let codegen_units = time(tcx.sess, \"codegen unit partitioning\", || {\n-        partitioning::partition(tcx,\n-                                items.iter().cloned(),\n-                                strategy,\n-                                &inlining_map)\n-            .into_iter()\n-            .map(Arc::new)\n-            .collect::<Vec<_>>()\n-    });\n-\n-    let mono_items: DefIdSet = items.iter().filter_map(|mono_item| {\n-        match *mono_item {\n-            MonoItem::Fn(ref instance) => Some(instance.def_id()),\n-            MonoItem::Static(def_id) => Some(def_id),\n-            _ => None,\n-        }\n-    }).collect();\n-\n-    if tcx.sess.opts.debugging_opts.print_mono_items.is_some() {\n-        let mut item_to_cgus: FxHashMap<_, Vec<_>> = Default::default();\n-\n-        for cgu in &codegen_units {\n-            for (&mono_item, &linkage) in cgu.items() {\n-                item_to_cgus.entry(mono_item)\n-                            .or_default()\n-                            .push((cgu.name().clone(), linkage));\n-            }\n-        }\n-\n-        let mut item_keys: Vec<_> = items\n-            .iter()\n-            .map(|i| {\n-                let mut output = i.to_string(tcx);\n-                output.push_str(\" @@\");\n-                let mut empty = Vec::new();\n-                let cgus = item_to_cgus.get_mut(i).unwrap_or(&mut empty);\n-                cgus.as_mut_slice().sort_by_key(|&(ref name, _)| name.clone());\n-                cgus.dedup();\n-                for &(ref cgu_name, (linkage, _)) in cgus.iter() {\n-                    output.push_str(\" \");\n-                    output.push_str(&cgu_name.as_str());\n-\n-                    let linkage_abbrev = match linkage {\n-                        Linkage::External => \"External\",\n-                        Linkage::AvailableExternally => \"Available\",\n-                        Linkage::LinkOnceAny => \"OnceAny\",\n-                        Linkage::LinkOnceODR => \"OnceODR\",\n-                        Linkage::WeakAny => \"WeakAny\",\n-                        Linkage::WeakODR => \"WeakODR\",\n-                        Linkage::Appending => \"Appending\",\n-                        Linkage::Internal => \"Internal\",\n-                        Linkage::Private => \"Private\",\n-                        Linkage::ExternalWeak => \"ExternalWeak\",\n-                        Linkage::Common => \"Common\",\n-                    };\n-\n-                    output.push_str(\"[\");\n-                    output.push_str(linkage_abbrev);\n-                    output.push_str(\"]\");\n-                }\n-                output\n-            })\n-            .collect();\n-\n-        item_keys.sort();\n-\n-        for item in item_keys {\n-            println!(\"MONO_ITEM {}\", item);\n-        }\n-    }\n-\n-    (Arc::new(mono_items), Arc::new(codegen_units))\n-}\n-\n impl CrateInfo {\n     pub fn new(tcx: TyCtxt) -> CrateInfo {\n         let mut info = CrateInfo {\n@@ -1222,12 +1098,6 @@ impl CrateInfo {\n     }\n }\n \n-fn is_codegened_item(tcx: TyCtxt, id: DefId) -> bool {\n-    let (all_mono_items, _) =\n-        tcx.collect_and_partition_mono_items(LOCAL_CRATE);\n-    all_mono_items.contains(&id)\n-}\n-\n fn compile_codegen_unit<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                   cgu_name: InternedString)\n                                   -> Stats {\n@@ -1318,24 +1188,7 @@ fn compile_codegen_unit<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     }\n }\n \n-pub fn provide(providers: &mut Providers) {\n-    providers.collect_and_partition_mono_items =\n-        collect_and_partition_mono_items;\n-\n-    providers.is_codegened_item = is_codegened_item;\n-\n-    providers.codegen_unit = |tcx, name| {\n-        let (_, all) = tcx.collect_and_partition_mono_items(LOCAL_CRATE);\n-        all.iter()\n-            .find(|cgu| *cgu.name() == name)\n-            .cloned()\n-            .unwrap_or_else(|| panic!(\"failed to find cgu with name {:?}\", name))\n-    };\n-\n-    provide_extern(providers);\n-}\n-\n-pub fn provide_extern(providers: &mut Providers) {\n+pub fn provide_both(providers: &mut Providers) {\n     providers.dllimport_foreign_items = |tcx, krate| {\n         let module_map = tcx.foreign_modules(krate);\n         let module_map = module_map.iter()"}, {"sha": "5d9bae5412e1a38fbe9db46214311b51355ea81b", "filename": "src/librustc_codegen_llvm/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d46246b14adb519a80cf00d36e72a49a26484eee/src%2Flibrustc_codegen_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d46246b14adb519a80cf00d36e72a49a26484eee/src%2Flibrustc_codegen_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Flib.rs?ref=d46246b14adb519a80cf00d36e72a49a26484eee", "patch": "@@ -192,13 +192,13 @@ impl CodegenBackend for LlvmCodegenBackend {\n     fn provide(&self, providers: &mut ty::query::Providers) {\n         rustc_codegen_utils::symbol_export::provide(providers);\n         rustc_codegen_utils::symbol_names::provide(providers);\n-        base::provide(providers);\n+        base::provide_both(providers);\n         attributes::provide(providers);\n     }\n \n     fn provide_extern(&self, providers: &mut ty::query::Providers) {\n         rustc_codegen_utils::symbol_export::provide_extern(providers);\n-        base::provide_extern(providers);\n+        base::provide_both(providers);\n         attributes::provide_extern(providers);\n     }\n "}, {"sha": "1a35f4da20bf158a1fddab082043edcf30e28cc0", "filename": "src/librustc_mir/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d46246b14adb519a80cf00d36e72a49a26484eee/src%2Flibrustc_mir%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d46246b14adb519a80cf00d36e72a49a26484eee/src%2Flibrustc_mir%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Flib.rs?ref=d46246b14adb519a80cf00d36e72a49a26484eee", "patch": "@@ -93,6 +93,7 @@ pub fn provide(providers: &mut Providers) {\n     borrow_check::provide(providers);\n     shim::provide(providers);\n     transform::provide(providers);\n+    monomorphize::partitioning::provide(providers);\n     providers.const_eval = const_eval::const_eval_provider;\n     providers.const_eval_raw = const_eval::const_eval_raw_provider;\n     providers.check_match = hair::pattern::check_match;"}, {"sha": "dddd64d0ba2b4761623196deb2b6256dccb52844", "filename": "src/librustc_mir/monomorphize/partitioning.rs", "status": "modified", "additions": 156, "deletions": 7, "changes": 163, "blob_url": "https://github.com/rust-lang/rust/blob/d46246b14adb519a80cf00d36e72a49a26484eee/src%2Flibrustc_mir%2Fmonomorphize%2Fpartitioning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d46246b14adb519a80cf00d36e72a49a26484eee/src%2Flibrustc_mir%2Fmonomorphize%2Fpartitioning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fpartitioning.rs?ref=d46246b14adb519a80cf00d36e72a49a26484eee", "patch": "@@ -102,21 +102,27 @@\n //! source-level module, functions from the same module will be available for\n //! inlining, even when they are not marked #[inline].\n \n-use monomorphize::collector::InliningMap;\n+use std::collections::hash_map::Entry;\n+use std::cmp;\n+use std::sync::Arc;\n+\n+use syntax::ast::NodeId;\n+use syntax::symbol::InternedString;\n use rustc::dep_graph::{WorkProductId, WorkProduct, DepNode, DepConstructor};\n use rustc::hir::CodegenFnAttrFlags;\n-use rustc::hir::def_id::{DefId, LOCAL_CRATE, CRATE_DEF_INDEX};\n+use rustc::hir::def_id::{CrateNum, DefId, LOCAL_CRATE, CRATE_DEF_INDEX};\n use rustc::hir::map::DefPathData;\n use rustc::mir::mono::{Linkage, Visibility, CodegenUnitNameBuilder};\n use rustc::middle::exported_symbols::SymbolExportLevel;\n use rustc::ty::{self, TyCtxt, InstanceDef};\n use rustc::ty::item_path::characteristic_def_id_of_type;\n-use rustc::util::nodemap::{FxHashMap, FxHashSet};\n-use std::collections::hash_map::Entry;\n-use std::cmp;\n-use syntax::ast::NodeId;\n-use syntax::symbol::InternedString;\n+use rustc::ty::query::Providers;\n+use rustc::util::common::time;\n+use rustc::util::nodemap::{DefIdSet, FxHashMap, FxHashSet};\n use rustc::mir::mono::MonoItem;\n+\n+use monomorphize::collector::InliningMap;\n+use monomorphize::collector::{self, MonoItemCollectionMode};\n use monomorphize::item::{MonoItemExt, InstantiationMode};\n \n pub use rustc::mir::mono::CodegenUnit;\n@@ -892,3 +898,146 @@ fn debug_dump<'a, 'b, 'tcx, I>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         }\n     }\n }\n+\n+fn collect_and_partition_mono_items<'a, 'tcx>(\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    cnum: CrateNum,\n+) -> (Arc<DefIdSet>, Arc<Vec<Arc<CodegenUnit<'tcx>>>>)\n+{\n+assert_eq!(cnum, LOCAL_CRATE);\n+\n+    let collection_mode = match tcx.sess.opts.debugging_opts.print_mono_items {\n+        Some(ref s) => {\n+            let mode_string = s.to_lowercase();\n+            let mode_string = mode_string.trim();\n+            if mode_string == \"eager\" {\n+                MonoItemCollectionMode::Eager\n+            } else {\n+                if mode_string != \"lazy\" {\n+                    let message = format!(\"Unknown codegen-item collection mode '{}'. \\\n+                                           Falling back to 'lazy' mode.\",\n+                                          mode_string);\n+                    tcx.sess.warn(&message);\n+                }\n+\n+                MonoItemCollectionMode::Lazy\n+            }\n+        }\n+        None => {\n+            if tcx.sess.opts.cg.link_dead_code {\n+                MonoItemCollectionMode::Eager\n+            } else {\n+                MonoItemCollectionMode::Lazy\n+            }\n+        }\n+    };\n+\n+    let (items, inlining_map) =\n+        time(tcx.sess, \"monomorphization collection\", || {\n+            collector::collect_crate_mono_items(tcx, collection_mode)\n+    });\n+\n+    tcx.sess.abort_if_errors();\n+\n+    ::monomorphize::assert_symbols_are_distinct(tcx, items.iter());\n+\n+    let strategy = if tcx.sess.opts.incremental.is_some() {\n+        PartitioningStrategy::PerModule\n+    } else {\n+        PartitioningStrategy::FixedUnitCount(tcx.sess.codegen_units())\n+    };\n+\n+    let codegen_units = time(tcx.sess, \"codegen unit partitioning\", || {\n+        partition(\n+            tcx,\n+            items.iter().cloned(),\n+            strategy,\n+            &inlining_map\n+        )\n+            .into_iter()\n+            .map(Arc::new)\n+            .collect::<Vec<_>>()\n+    });\n+\n+    let mono_items: DefIdSet = items.iter().filter_map(|mono_item| {\n+        match *mono_item {\n+            MonoItem::Fn(ref instance) => Some(instance.def_id()),\n+            MonoItem::Static(def_id) => Some(def_id),\n+            _ => None,\n+        }\n+    }).collect();\n+\n+    if tcx.sess.opts.debugging_opts.print_mono_items.is_some() {\n+        let mut item_to_cgus: FxHashMap<_, Vec<_>> = Default::default();\n+\n+        for cgu in &codegen_units {\n+            for (&mono_item, &linkage) in cgu.items() {\n+                item_to_cgus.entry(mono_item)\n+                            .or_default()\n+                            .push((cgu.name().clone(), linkage));\n+            }\n+        }\n+\n+        let mut item_keys: Vec<_> = items\n+            .iter()\n+            .map(|i| {\n+                let mut output = i.to_string(tcx);\n+                output.push_str(\" @@\");\n+                let mut empty = Vec::new();\n+                let cgus = item_to_cgus.get_mut(i).unwrap_or(&mut empty);\n+                cgus.as_mut_slice().sort_by_key(|&(ref name, _)| name.clone());\n+                cgus.dedup();\n+                for &(ref cgu_name, (linkage, _)) in cgus.iter() {\n+                    output.push_str(\" \");\n+                    output.push_str(&cgu_name.as_str());\n+\n+                    let linkage_abbrev = match linkage {\n+                        Linkage::External => \"External\",\n+                        Linkage::AvailableExternally => \"Available\",\n+                        Linkage::LinkOnceAny => \"OnceAny\",\n+                        Linkage::LinkOnceODR => \"OnceODR\",\n+                        Linkage::WeakAny => \"WeakAny\",\n+                        Linkage::WeakODR => \"WeakODR\",\n+                        Linkage::Appending => \"Appending\",\n+                        Linkage::Internal => \"Internal\",\n+                        Linkage::Private => \"Private\",\n+                        Linkage::ExternalWeak => \"ExternalWeak\",\n+                        Linkage::Common => \"Common\",\n+                    };\n+\n+                    output.push_str(\"[\");\n+                    output.push_str(linkage_abbrev);\n+                    output.push_str(\"]\");\n+                }\n+                output\n+            })\n+            .collect();\n+\n+        item_keys.sort();\n+\n+        for item in item_keys {\n+            println!(\"MONO_ITEM {}\", item);\n+        }\n+    }\n+\n+    (Arc::new(mono_items), Arc::new(codegen_units))\n+}\n+\n+pub fn provide(providers: &mut Providers) {\n+    providers.collect_and_partition_mono_items =\n+        collect_and_partition_mono_items;\n+\n+    providers.is_codegened_item = |tcx, def_id| {\n+        let (all_mono_items, _) =\n+            tcx.collect_and_partition_mono_items(LOCAL_CRATE);\n+        all_mono_items.contains(&def_id)\n+    };\n+\n+    providers.codegen_unit = |tcx, name| {\n+        let (_, all) = tcx.collect_and_partition_mono_items(LOCAL_CRATE);\n+        all.iter()\n+            .find(|cgu| *cgu.name() == name)\n+            .cloned()\n+            .unwrap_or_else(|| panic!(\"failed to find cgu with name {:?}\", name))\n+    };\n+}"}]}