{"sha": "6e909e387d1b71a8b813433ce834384ffb13fedf", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZlOTA5ZTM4N2QxYjcxYThiODEzNDMzY2U4MzQzODRmZmIxM2ZlZGY=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-04-23T23:01:03Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-04-25T01:24:35Z"}, "message": "rustc: Use LLVM named structs for enum types", "tree": {"sha": "faa71bc8c5098d6b69468b39bbbe55362a309148", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/faa71bc8c5098d6b69468b39bbbe55362a309148"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6e909e387d1b71a8b813433ce834384ffb13fedf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6e909e387d1b71a8b813433ce834384ffb13fedf", "html_url": "https://github.com/rust-lang/rust/commit/6e909e387d1b71a8b813433ce834384ffb13fedf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6e909e387d1b71a8b813433ce834384ffb13fedf/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "929c3dd7106fc21938e1406c7a6ee581664b9dfc", "url": "https://api.github.com/repos/rust-lang/rust/commits/929c3dd7106fc21938e1406c7a6ee581664b9dfc", "html_url": "https://github.com/rust-lang/rust/commit/929c3dd7106fc21938e1406c7a6ee581664b9dfc"}], "stats": {"total": 275, "additions": 180, "deletions": 95}, "files": [{"sha": "e7c5e47ffb056ea98b6f78534010635428984f4b", "filename": "src/rustc/middle/trans/base.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6e909e387d1b71a8b813433ce834384ffb13fedf/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e909e387d1b71a8b813433ce834384ffb13fedf/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=6e909e387d1b71a8b813433ce834384ffb13fedf", "patch": "@@ -2243,7 +2243,8 @@ fn trans_var(cx: block, def: ast::def, id: ast::node_id)-> lval_maybe_callee {\n             // Nullary variant.\n             let enum_ty = node_id_type(cx, id);\n             let llenumblob = alloc_ty(cx, enum_ty);\n-            let llenumty = type_of_enum(ccx, tid, enum_ty);\n+            // FIXME: This pointer cast probably isn't necessary\n+            let llenumty = type_of(ccx, enum_ty);\n             let llenumptr = PointerCast(cx, llenumblob, T_ptr(llenumty));\n             let lldiscrimptr = GEPi(cx, llenumptr, [0, 0]);\n             let lldiscrim_gv = lookup_discriminant(ccx, vid);"}, {"sha": "954cefebd7a866462c6c063a3bcd55521dc96542", "filename": "src/rustc/middle/trans/type_of.rs", "status": "modified", "additions": 136, "deletions": 75, "changes": 211, "blob_url": "https://github.com/rust-lang/rust/blob/6e909e387d1b71a8b813433ce834384ffb13fedf/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e909e387d1b71a8b813433ce834384ffb13fedf/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_of.rs?ref=6e909e387d1b71a8b813433ce834384ffb13fedf", "patch": "@@ -7,6 +7,11 @@ import std::map::hashmap;\n \n import ty::*;\n \n+export type_of;\n+export type_of_explicit_args;\n+export type_of_fn_from_ty;\n+export type_of_fn;\n+\n fn type_of_explicit_args(cx: @crate_ctxt, inputs: [ty::arg]) -> [TypeRef] {\n     vec::map(inputs) {|arg|\n         let arg_ty = arg.ty;\n@@ -39,93 +44,149 @@ fn type_of_fn_from_ty(cx: @crate_ctxt, fty: ty::t) -> TypeRef {\n \n fn type_of(cx: @crate_ctxt, t: ty::t) -> TypeRef {\n     assert !ty::type_has_vars(t);\n-    // Check the cache.\n \n+    #debug(\"type_of %?: %?\", t, ty::get(t));\n+\n+    // Check the cache.\n     if cx.lltypes.contains_key(t) { ret cx.lltypes.get(t); }\n-    let llty = alt ty::get(t).struct {\n-      ty::ty_nil | ty::ty_bot { T_nil() }\n-      ty::ty_bool { T_bool() }\n-      ty::ty_int(t) { T_int_ty(cx, t) }\n-      ty::ty_uint(t) { T_uint_ty(cx, t) }\n-      ty::ty_float(t) { T_float_ty(cx, t) }\n-      ty::ty_estr(ty::vstore_uniq) |\n-      ty::ty_str { T_ptr(T_vec(cx, T_i8())) }\n-      ty::ty_enum(did, _) { type_of_enum(cx, did, t) }\n-      ty::ty_estr(ty::vstore_box) { T_ptr(T_box(cx, T_i8())) }\n-      ty::ty_evec(mt, ty::vstore_box) |\n-      ty::ty_box(mt) { T_ptr(T_box(cx, type_of(cx, mt.ty))) }\n-      ty::ty_opaque_box { T_ptr(T_box(cx, T_i8())) }\n-      ty::ty_uniq(mt) { T_ptr(type_of(cx, mt.ty)) }\n-      ty::ty_evec(mt, ty::vstore_uniq) |\n-      ty::ty_vec(mt) { T_ptr(T_vec(cx, type_of(cx, mt.ty))) }\n-      ty::ty_ptr(mt) { T_ptr(type_of(cx, mt.ty)) }\n-      ty::ty_rptr(_, mt) { T_ptr(type_of(cx, mt.ty)) }\n-\n-      ty::ty_evec(mt, ty::vstore_slice(_)) {\n-        T_struct([T_ptr(type_of(cx, mt.ty)),\n-                  T_uint_ty(cx, ast::ty_u)])\n-      }\n \n-      ty::ty_estr(ty::vstore_slice(_)) {\n-        T_struct([T_ptr(T_i8()),\n-                  T_uint_ty(cx, ast::ty_u)])\n-      }\n+    // Replace any typedef'd types with their equivalent non-typedef\n+    // type. This ensures that all LLVM nominal types that contain\n+    // Rust types are defined as the same LLVM types.  If we don't do\n+    // this then, e.g. `option<{myfield: bool}>` would be a different\n+    // type than `option<myrec>`.\n+    let t_norm = ty::normalize_ty(cx.tcx, t);\n+    let llty = if t != t_norm {\n+        type_of(cx, t_norm)\n+    } else {\n+        alt ty::get(t).struct {\n+          ty::ty_nil | ty::ty_bot { T_nil() }\n+          ty::ty_bool { T_bool() }\n+          ty::ty_int(t) { T_int_ty(cx, t) }\n+          ty::ty_uint(t) { T_uint_ty(cx, t) }\n+          ty::ty_float(t) { T_float_ty(cx, t) }\n+          ty::ty_estr(ty::vstore_uniq) |\n+          ty::ty_str { T_ptr(T_vec(cx, T_i8())) }\n+          ty::ty_enum(did, _) { type_of_enum(cx, did, t) }\n+          ty::ty_estr(ty::vstore_box) { T_ptr(T_box(cx, T_i8())) }\n+          ty::ty_evec(mt, ty::vstore_box) |\n+          ty::ty_box(mt) { T_ptr(T_box(cx, type_of(cx, mt.ty))) }\n+          ty::ty_opaque_box { T_ptr(T_box(cx, T_i8())) }\n+          ty::ty_uniq(mt) { T_ptr(type_of(cx, mt.ty)) }\n+          ty::ty_evec(mt, ty::vstore_uniq) |\n+          ty::ty_vec(mt) { T_ptr(T_vec(cx, type_of(cx, mt.ty))) }\n+          ty::ty_ptr(mt) { T_ptr(type_of(cx, mt.ty)) }\n+          ty::ty_rptr(_, mt) { T_ptr(type_of(cx, mt.ty)) }\n \n-      ty::ty_estr(ty::vstore_fixed(n)) {\n-        T_array(T_i8(), n + 1u /* +1 for trailing null */)\n-      }\n+          ty::ty_evec(mt, ty::vstore_slice(_)) {\n+            T_struct([T_ptr(type_of(cx, mt.ty)),\n+                      T_uint_ty(cx, ast::ty_u)])\n+          }\n \n-      ty::ty_evec(mt, ty::vstore_fixed(n)) {\n-        T_array(type_of(cx, mt.ty), n)\n-      }\n+          ty::ty_estr(ty::vstore_slice(_)) {\n+            T_struct([T_ptr(T_i8()),\n+                      T_uint_ty(cx, ast::ty_u)])\n+          }\n \n-      ty::ty_rec(fields) {\n-        let mut tys: [TypeRef] = [];\n-        for vec::each(fields) {|f|\n-            let mt_ty = f.mt.ty;\n-            tys += [type_of(cx, mt_ty)];\n-        }\n-        T_struct(tys)\n-      }\n-      ty::ty_fn(_) { T_fn_pair(cx, type_of_fn_from_ty(cx, t)) }\n-      ty::ty_iface(_, _) { T_opaque_iface(cx) }\n-      ty::ty_res(_, sub, substs) {\n-        let sub1 = ty::subst(cx.tcx, substs, sub);\n-        ret T_struct([T_i8(), type_of(cx, sub1)]);\n-      }\n-      ty::ty_param(_, _) { T_typaram(cx.tn) }\n-      ty::ty_type { T_ptr(cx.tydesc_type) }\n-      ty::ty_tup(elts) {\n-        let mut tys = [];\n-        for vec::each(elts) {|elt|\n-            tys += [type_of(cx, elt)];\n+          ty::ty_estr(ty::vstore_fixed(n)) {\n+            T_array(T_i8(), n + 1u /* +1 for trailing null */)\n+          }\n+\n+          ty::ty_evec(mt, ty::vstore_fixed(n)) {\n+            T_array(type_of(cx, mt.ty), n)\n+          }\n+\n+          ty::ty_rec(fields) {\n+            let mut tys: [TypeRef] = [];\n+            for vec::each(fields) {|f|\n+                let mt_ty = f.mt.ty;\n+                tys += [type_of(cx, mt_ty)];\n+            }\n+            T_struct(tys)\n+          }\n+          ty::ty_fn(_) { T_fn_pair(cx, type_of_fn_from_ty(cx, t)) }\n+          ty::ty_iface(_, _) { T_opaque_iface(cx) }\n+          ty::ty_res(_, sub, substs) {\n+            let sub1 = ty::subst(cx.tcx, substs, sub);\n+            ret T_struct([T_i8(), type_of(cx, sub1)]);\n+          }\n+          ty::ty_param(_, _) { T_typaram(cx.tn) }\n+          ty::ty_type { T_ptr(cx.tydesc_type) }\n+          ty::ty_tup(elts) {\n+            let mut tys = [];\n+            for vec::each(elts) {|elt|\n+                tys += [type_of(cx, elt)];\n+            }\n+            T_struct(tys)\n+          }\n+          ty::ty_opaque_closure_ptr(_) { T_opaque_box_ptr(cx) }\n+          ty::ty_constr(subt,_) { type_of(cx, subt) }\n+          ty::ty_class(did, ts) {\n+            // only instance vars are record fields at runtime\n+            let fields = lookup_class_fields(cx.tcx, did);\n+            let tys = vec::map(fields) {|f|\n+                let t = ty::lookup_field_type(cx.tcx, did, f.id, ts);\n+                type_of(cx, t)\n+            };\n+            T_struct(tys)\n+          }\n+          ty::ty_self(_) { cx.tcx.sess.unimpl(\"type_of: ty_self \\\n+                                               not implemented\"); }\n+          ty::ty_var(_) { cx.tcx.sess.bug(\"type_of shouldn't see a ty_var\"); }\n         }\n-        T_struct(tys)\n-      }\n-      ty::ty_opaque_closure_ptr(_) { T_opaque_box_ptr(cx) }\n-      ty::ty_constr(subt,_) { type_of(cx, subt) }\n-      ty::ty_class(did, ts) {\n-        // only instance vars are record fields at runtime\n-        let fields = lookup_class_fields(cx.tcx, did);\n-        let tys = vec::map(fields) {|f|\n-            let t = ty::lookup_field_type(cx.tcx, did, f.id, ts);\n-            type_of(cx, t)\n-        };\n-        T_struct(tys)\n-      }\n-      ty::ty_self(_) { cx.tcx.sess.unimpl(\"type_of: ty_self \\\n-                         not implemented\"); }\n-      ty::ty_var(_) { cx.tcx.sess.bug(\"type_of shouldn't see a ty_var\"); }\n     };\n     cx.lltypes.insert(t, llty);\n     ret llty;\n }\n \n+// This should only be called from type_of, above, because it\n+// creates new llvm named struct types lazily that are then\n+// cached by type_of\n fn type_of_enum(cx: @crate_ctxt, did: ast::def_id, t: ty::t)\n     -> TypeRef {\n-    let degen = (*ty::enum_variants(cx.tcx, did)).len() == 1u;\n-    let size = shape::static_size_of_enum(cx, t);\n-    if !degen { T_enum(cx, size) }\n-    else if size == 0u { T_struct([T_enum_variant(cx)]) }\n-    else { T_array(T_i8(), size) }\n+\n+    #debug(\"type_of_enum %?: %?\", t, ty::get(t));\n+\n+    // Every enum type has a unique name. When we find our roots\n+    // for GC and unwinding we will use this name to rediscover\n+    // the Rust type\n+    let name = llvm_type_name(cx, t);\n+\n+    let named_llty = common::T_named_struct(name);\n+\n+    let lltys = {\n+        let degen = (*ty::enum_variants(cx.tcx, did)).len() == 1u;\n+        let size = shape::static_size_of_enum(cx, t);\n+        if !degen {\n+            [T_enum_variant(cx), T_array(T_i8(), size)]\n+        }\n+        else if size == 0u {\n+            [T_enum_variant(cx)]\n+        }\n+        else {\n+            [T_array(T_i8(), size)]\n+        }\n+    };\n+\n+    common::set_struct_body(named_llty, lltys);\n+    ret named_llty;\n }\n+\n+fn llvm_type_name(cx: @crate_ctxt, t: ty::t) -> str {\n+    let (name, did, tps) = alt check ty::get(t).struct {\n+      ty::ty_enum(did, substs) {\n+        (\"enum\", did, substs.tps)\n+      }\n+    };\n+    ret #fmt(\n+        \"%s %s[#%d]\",\n+        name,\n+        util::ppaux::parameterized(\n+            cx.tcx,\n+            ty::item_path_str(cx.tcx, did),\n+            none,\n+            tps),\n+        did.crate\n+    );\n+}\n+"}, {"sha": "909370e008f6b9849c9936f40c517d1b882a46d3", "filename": "src/rustc/middle/ty.rs", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/6e909e387d1b71a8b813433ce834384ffb13fedf/src%2Frustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e909e387d1b71a8b813433ce834384ffb13fedf/src%2Frustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fty.rs?ref=6e909e387d1b71a8b813433ce834384ffb13fedf", "patch": "@@ -149,6 +149,7 @@ export ast_ty_to_ty_cache_entry;\n export atttce_unresolved, atttce_resolved;\n export mach_sty;\n export ty_sort_str;\n+export normalize_ty;\n \n // Data types\n \n@@ -2674,6 +2675,27 @@ fn ty_params_to_tys(tcx: ty::ctxt, tps: [ast::ty_param]) -> [t] {\n                 ty::mk_param(tcx, i, ast_util::local_def(tps[i].id))\n         })\n }\n+\n+#[doc = \"\n+Returns an equivalent type with all the typedefs and self regions removed\n+\"]\n+fn normalize_ty(cx: ctxt, t: t) -> t {\n+    let t = alt get(t).struct {\n+        ty_enum(did, r) {\n+            alt r.self_r {\n+              some(_) {\n+                // This enum has a self region. Get rid of it\n+                mk_enum(cx, did, {self_r: none, tps: r.tps })\n+              }\n+              none { t }\n+            }\n+        }\n+        _ { t }\n+    };\n+    let sty = fold_sty(get(t).struct) {|t| normalize_ty(cx, t) };\n+    mk_t(cx, sty)\n+}\n+\n // Local Variables:\n // mode: rust\n // fill-column: 78;"}, {"sha": "1a27bbdff8407f39f1706c2b822ad2ec5a399f6d", "filename": "src/rustc/util/ppaux.rs", "status": "modified", "additions": 20, "deletions": 19, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/6e909e387d1b71a8b813433ce834384ffb13fedf/src%2Frustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e909e387d1b71a8b813433ce834384ffb13fedf/src%2Frustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Futil%2Fppaux.rs?ref=6e909e387d1b71a8b813433ce834384ffb13fedf", "patch": "@@ -128,25 +128,6 @@ fn ty_to_str(cx: ctxt, typ: t) -> str {\n     fn field_to_str(cx: ctxt, f: field) -> str {\n         ret f.ident + \": \" + mt_to_str(cx, f.mt);\n     }\n-    fn parameterized(cx: ctxt,\n-                     base: str,\n-                     self_r: option<ty::region>,\n-                     tps: [ty::t]) -> str {\n-\n-        let r_str = alt self_r {\n-          none { \"\" }\n-          some(r) {\n-            #fmt[\"/%s\", region_to_str(cx, r)]\n-          }\n-        };\n-\n-        if vec::len(tps) > 0u {\n-            let strs = vec::map(tps, {|t| ty_to_str(cx, t)});\n-            #fmt[\"%s%s<%s>\", base, r_str, str::connect(strs, \",\")]\n-        } else {\n-            #fmt[\"%s%s\", base, r_str]\n-        }\n-    }\n \n     // if there is an id, print that instead of the structural type:\n     alt ty::type_def_id(typ) {\n@@ -233,6 +214,26 @@ fn ty_to_str(cx: ctxt, typ: t) -> str {\n     }\n }\n \n+fn parameterized(cx: ctxt,\n+                 base: str,\n+                 self_r: option<ty::region>,\n+                 tps: [ty::t]) -> str {\n+\n+    let r_str = alt self_r {\n+      none { \"\" }\n+      some(r) {\n+        #fmt[\"/%s\", region_to_str(cx, r)]\n+      }\n+    };\n+\n+    if vec::len(tps) > 0u {\n+        let strs = vec::map(tps, {|t| ty_to_str(cx, t)});\n+        #fmt[\"%s%s<%s>\", base, r_str, str::connect(strs, \",\")]\n+    } else {\n+        #fmt[\"%s%s\", base, r_str]\n+    }\n+}\n+\n fn ty_to_short_str(cx: ctxt, typ: t) -> str {\n     let mut s = encoder::encoded_ty(cx, typ);\n     if str::len(s) >= 32u { s = str::slice(s, 0u, 32u); }"}]}