{"sha": "8bee69da25871dc135dd95ac869ecbb17e2a87c0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhiZWU2OWRhMjU4NzFkYzEzNWRkOTVhYzg2OWVjYmIxN2UyYTg3YzA=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-07-01T22:50:32Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-07-06T18:09:06Z"}, "message": "rustc: Change constraints in types to use interior vectors", "tree": {"sha": "c582f7eb7ecf2a7cf564ee128546c04e2fccf96b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c582f7eb7ecf2a7cf564ee128546c04e2fccf96b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8bee69da25871dc135dd95ac869ecbb17e2a87c0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8bee69da25871dc135dd95ac869ecbb17e2a87c0", "html_url": "https://github.com/rust-lang/rust/commit/8bee69da25871dc135dd95ac869ecbb17e2a87c0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8bee69da25871dc135dd95ac869ecbb17e2a87c0/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f391acbd3f34c9ee066a2e9767222061221a1042", "url": "https://api.github.com/repos/rust-lang/rust/commits/f391acbd3f34c9ee066a2e9767222061221a1042", "html_url": "https://github.com/rust-lang/rust/commit/f391acbd3f34c9ee066a2e9767222061221a1042"}], "stats": {"total": 89, "additions": 47, "deletions": 42}, "files": [{"sha": "a2c706610a3f7f8871098a30377922720a541329", "filename": "src/comp/metadata/tydecode.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8bee69da25871dc135dd95ac869ecbb17e2a87c0/src%2Fcomp%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bee69da25871dc135dd95ac869ecbb17e2a87c0/src%2Fcomp%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Ftydecode.rs?ref=8bee69da25871dc135dd95ac869ecbb17e2a87c0", "patch": "@@ -65,13 +65,13 @@ fn parse_ty_or_bang(@pstate st, str_def sd) -> ty_or_bang {\n     }\n }\n \n-fn parse_constrs(@pstate st, str_def sd) -> vec[@ty::constr_def] {\n-    let vec[@ty::constr_def] rslt = [];\n+fn parse_constrs(@pstate st, str_def sd) -> (@ty::constr_def)[] {\n+    let (@ty::constr_def)[] rslt = ~[];\n     alt (peek(st) as char) {\n         case (':') {\n             do  {\n                 next(st);\n-                vec::push(rslt, parse_constr(st, sd));\n+                rslt += ~[parse_constr(st, sd)];\n             } while (peek(st) as char == ';')\n         }\n         case (_) { }\n@@ -333,7 +333,7 @@ fn parse_hex(@pstate st) -> uint {\n }\n \n fn parse_ty_fn(@pstate st, str_def sd) ->\n-   tup(ty::arg[], ty::t, ast::controlflow, vec[@ty::constr_def]) {\n+   tup(ty::arg[], ty::t, ast::controlflow, (@ty::constr_def)[]) {\n     assert (next(st) as char == '[');\n     let ty::arg[] inputs = ~[];\n     while (peek(st) as char != ']') {"}, {"sha": "8cefd90e78fdd7b5d79c3e0386add88a05b3b683", "filename": "src/comp/metadata/tyencode.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8bee69da25871dc135dd95ac869ecbb17e2a87c0/src%2Fcomp%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bee69da25871dc135dd95ac869ecbb17e2a87c0/src%2Fcomp%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Ftyencode.rs?ref=8bee69da25871dc135dd95ac869ecbb17e2a87c0", "patch": "@@ -162,7 +162,7 @@ fn enc_sty(&io::writer w, &@ctxt cx, &ty::sty st) {\n                 case (native_abi_cdecl) { w.write_char('c'); }\n                 case (native_abi_llvm) { w.write_char('l'); }\n             }\n-            enc_ty_fn(w, cx, args, out, return, []);\n+            enc_ty_fn(w, cx, args, out, return, ~[]);\n         }\n         case (ty::ty_obj(?methods)) {\n             w.write_str(\"O[\");\n@@ -205,7 +205,7 @@ fn enc_proto(&io::writer w, proto proto) {\n     }\n }\n fn enc_ty_fn(&io::writer w, &@ctxt cx, &ty::arg[] args, &ty::t out,\n-             &controlflow cf, &vec[@ty::constr_def] constrs) {\n+             &controlflow cf, &(@ty::constr_def)[] constrs) {\n     w.write_char('[');\n     for (ty::arg arg in args) {\n         alt (arg.mode) {"}, {"sha": "04daaff3d4e2af1ea8f37fc9215cfb9caa86409e", "filename": "src/comp/middle/tstate/auxiliary.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8bee69da25871dc135dd95ac869ecbb17e2a87c0/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bee69da25871dc135dd95ac869ecbb17e2a87c0/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs?ref=8bee69da25871dc135dd95ac869ecbb17e2a87c0", "patch": "@@ -453,10 +453,10 @@ fn controlflow_expr(&crate_ctxt ccx, @expr e) -> controlflow {\n     }\n }\n \n-fn constraints_expr(&ty::ctxt cx, @expr e) -> vec[@ty::constr_def] {\n+fn constraints_expr(&ty::ctxt cx, @expr e) -> (@ty::constr_def)[] {\n     alt (ty::struct(cx, ty::node_id_to_type(cx, e.id))) {\n         case (ty::ty_fn(_, _, _, _, ?cs)) { ret cs; }\n-        case (_) { ret []; }\n+        case (_) { ret ~[]; }\n     }\n }\n "}, {"sha": "8be2460f918c37ec7262038aef28d3b94fde71bd", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/8bee69da25871dc135dd95ac869ecbb17e2a87c0/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bee69da25871dc135dd95ac869ecbb17e2a87c0/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=8bee69da25871dc135dd95ac869ecbb17e2a87c0", "patch": "@@ -196,7 +196,7 @@ type method =\n         arg[] inputs,\n         t output,\n         controlflow cf,\n-        vec[@constr_def] constrs);\n+        (@constr_def)[] constrs);\n \n type constr_table = hashmap[ast::node_id, vec[constr_def]]; \n \n@@ -267,9 +267,9 @@ tag sty {\n     ty_task;\n     ty_tup(mt[]);\n     ty_rec(field[]);\n-    ty_fn(ast::proto, arg[], t, controlflow, vec[@constr_def]);\n+    ty_fn(ast::proto, arg[], t, controlflow, (@constr_def)[]);\n     ty_native_fn(ast::native_abi, arg[], t);\n-    ty_obj(method[]);\n+    ty_obj(vec[method]);\n     ty_res(def_id, t, t[]);\n     ty_var(int); // type variable\n     ty_param(uint); // fn/tag type param\n@@ -596,7 +596,7 @@ fn mk_imm_tup(&ctxt cx, &t[] tys) -> t {\n fn mk_rec(&ctxt cx, &field[] fs) -> t { ret gen_ty(cx, ty_rec(fs)); }\n \n fn mk_fn(&ctxt cx, &ast::proto proto, &arg[] args, &t ty, &controlflow cf,\n-         &vec[@constr_def] constrs) -> t {\n+         &(@constr_def)[] constrs) -> t {\n     ret gen_ty(cx, ty_fn(proto, args, ty, cf, constrs));\n }\n \n@@ -1454,8 +1454,8 @@ fn constr_eq(&@constr_def c, &@constr_def d) -> bool {\n             args_eq(eq_int, c.node.args, d.node.args);\n }\n \n-fn constrs_eq(&vec[@constr_def] cs, &vec[@constr_def] ds) -> bool {\n-    if (vec::len(cs) != vec::len(ds)) { ret false; }\n+fn constrs_eq(&(@constr_def)[] cs, &(@constr_def)[] ds) -> bool {\n+    if (ivec::len(cs) != ivec::len(ds)) { ret false; }\n     auto i = 0u;\n     for (@constr_def c in cs) {\n         if (!constr_eq(c, ds.(i))) { ret false; }\n@@ -2139,8 +2139,8 @@ mod unify {\n                 &t expected, &t actual, &arg[] expected_inputs,\n                 &t expected_output, &arg[] actual_inputs, &t actual_output,\n                 &controlflow expected_cf, &controlflow actual_cf,\n-                &vec[@constr_def] expected_constrs,\n-                &vec[@constr_def] actual_constrs) -> result {\n+                &(@constr_def)[] expected_constrs,\n+                &(@constr_def)[] actual_constrs) -> result {\n         if (e_proto != a_proto) { ret ures_err(terr_mismatch); }\n         alt (expected_cf) {\n             case (ast::return) { }"}, {"sha": "2a04d4bfbefe0ac39daebf300e72eeef559e6156", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 28, "deletions": 23, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/8bee69da25871dc135dd95ac869ecbb17e2a87c0/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bee69da25871dc135dd95ac869ecbb17e2a87c0/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=8bee69da25871dc135dd95ac869ecbb17e2a87c0", "patch": "@@ -335,9 +335,10 @@ fn ast_ty_to_ty(&ty::ctxt tcx, &ty_getter getter, &@ast::ty ast_ty) -> ty::t {\n             }\n             auto out_ty = ast_ty_to_ty(tcx, getter, output);\n \n-            let fn(&@ast::constr) -> @ty::constr_def g =\n-                bind ast_constr_to_constr(tcx, _);\n-            let vec[@ty::constr_def] out_constrs = vec::map(g, constrs);\n+            auto out_constrs = ~[];\n+            for (@ast::constr constr in constrs) {\n+                out_constrs += ~[ast_constr_to_constr(tcx, constr)];\n+            }\n             typ = ty::mk_fn(tcx, proto, i, out_ty, cf, out_constrs);\n         }\n         case (ast::ty_path(?path, ?id)) {\n@@ -371,10 +372,10 @@ fn ast_ty_to_ty(&ty::ctxt tcx, &ty_getter getter, &@ast::ty ast_ty) -> ty::t {\n                 }\n                 auto out = ast_ty_to_ty(tcx, getter, m.node.output);\n \n-                let fn(&@ast::constr) -> @ty::constr_def g =\n-                    bind ast_constr_to_constr(tcx, _);\n-                let vec[@ty::constr_def] out_constrs =\n-                       vec::map(g, m.node.constrs);\n+                auto out_constrs = ~[];\n+                for (@ast::constr constr in m.node.constrs) {\n+                    out_constrs += ~[ast_constr_to_constr(tcx, constr)];\n+                }\n                 let ty::method new_m =\n                     rec(proto=m.node.proto,\n                         ident=m.node.ident,\n@@ -490,9 +491,10 @@ mod collect {\n         for (ast::arg a in decl.inputs) { input_tys += ~[ty_of_arg(a)]; }\n         auto output_ty = convert(decl.output);\n \n-        let fn(&@ast::constr) -> @ty::constr_def g =\n-            bind ast_constr_to_constr(cx.tcx, _);\n-        let vec[@ty::constr_def] out_constrs = vec::map(g, decl.constraints);\n+        auto out_constrs = ~[];\n+        for (@ast::constr constr in decl.constraints) {\n+            out_constrs += ~[ast_constr_to_constr(cx.tcx, constr)];\n+        }\n         auto t_fn =\n             ty::mk_fn(cx.tcx, proto, input_tys, output_ty, decl.cf,\n                       out_constrs);\n@@ -568,10 +570,11 @@ mod collect {\n         }\n \n         auto output = convert(m.node.meth.decl.output);\n-        let fn(&@ast::constr) -> @ty::constr_def g =\n-            bind ast_constr_to_constr(cx.tcx, _);\n-        let vec[@ty::constr_def] out_constrs =\n-            vec::map(g, m.node.meth.decl.constraints);\n+\n+        auto out_constrs = ~[];\n+        for (@ast::constr constr in m.node.meth.decl.constraints) {\n+            out_constrs += ~[ast_constr_to_constr(cx.tcx, constr)];\n+        }\n         ret rec(proto=m.node.meth.proto, ident=m.node.ident,\n                 inputs=inputs, output=output, cf=m.node.meth.decl.cf,\n                 constrs=out_constrs);\n@@ -596,7 +599,7 @@ mod collect {\n         }\n \n         auto t_fn = ty::mk_fn(cx.tcx, ast::proto_fn, t_inputs, t_obj._1,\n-                              ast::return, []);\n+                              ast::return, ~[]);\n         auto tpt = tup(t_obj._0, t_fn);\n         cx.tcx.tcache.insert(local_def(ctor_id), tpt);\n         ret tpt;\n@@ -707,7 +710,7 @@ mod collect {\n                 auto tag_t = ty::mk_tag(cx.tcx, tag_id, ty_param_tys);\n                 // FIXME: this will be different for constrained types\n                 result_ty = ty::mk_fn(cx.tcx, ast::proto_fn, args, tag_t,\n-                                      ast::return, []);\n+                                      ast::return, ~[]);\n             }\n             auto tpt = tup(ty_param_count, result_ty);\n             cx.tcx.tcache.insert(local_def(variant.node.id), tpt);\n@@ -778,7 +781,7 @@ mod collect {\n                     case (none) {/* nothing to do */ }\n                     case (some(?m)) {\n                         auto t = ty::mk_fn(cx.tcx, ast::proto_fn, ~[],\n-                                   ty::mk_nil(cx.tcx), ast::return, []);\n+                                   ty::mk_nil(cx.tcx), ast::return, ~[]);\n                         write::ty_only(cx.tcx, m.node.id, t);\n                     }\n                 }\n@@ -788,9 +791,9 @@ mod collect {\n                 auto t_res = ty::mk_res(cx.tcx, local_def(it.id), t_arg.ty,\n                                         mk_ty_params(cx, vec::len(tps)));\n                 auto t_ctor = ty::mk_fn(cx.tcx, ast::proto_fn, ~[t_arg],\n-                                        t_res, ast::return, []);\n+                                        t_res, ast::return, ~[]);\n                 auto t_dtor = ty::mk_fn(cx.tcx, ast::proto_fn, ~[t_arg],\n-                                        ty::mk_nil(cx.tcx), ast::return, []);\n+                                        ty::mk_nil(cx.tcx), ast::return, ~[]);\n                 write::ty_only(cx.tcx, it.id, t_res);\n                 write::ty_only(cx.tcx, ctor_id, t_ctor);\n                 cx.tcx.tcache.insert(local_def(ctor_id),\n@@ -2254,10 +2257,12 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n                 }\n \n                 auto output = convert(m.node.meth.decl.output);\n-                let fn(&@ast::constr) -> @ty::constr_def g =\n-                    bind ast_constr_to_constr(ccx.tcx, _);\n-                let vec[@ty::constr_def] out_constrs =\n-                    vec::map(g, m.node.meth.decl.constraints);\n+\n+                auto out_constrs = ~[];\n+                for (@ast::constr constr in m.node.meth.decl.constraints) {\n+                    out_constrs += ~[ast_constr_to_constr(ccx.tcx, constr)];\n+                }\n+\n                 ret rec(proto=m.node.meth.proto, ident=m.node.ident,\n                         inputs=inputs, output=output, cf=m.node.meth.decl.cf,\n                         constrs=out_constrs);"}, {"sha": "854b1a4adcba9c3bdb624e4b58979370fe80d8ff", "filename": "src/comp/util/ppaux.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8bee69da25871dc135dd95ac869ecbb17e2a87c0/src%2Fcomp%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bee69da25871dc135dd95ac869ecbb17e2a87c0/src%2Fcomp%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Futil%2Fppaux.rs?ref=8bee69da25871dc135dd95ac869ecbb17e2a87c0", "patch": "@@ -47,7 +47,7 @@ fn ty_to_str(&ctxt cx, &t typ) -> str {\n     }\n     fn fn_to_str(&ctxt cx, ast::proto proto, option::t[ast::ident] ident,\n                  &arg[] inputs, t output, ast::controlflow cf,\n-                 &vec[@constr_def] constrs) -> str {\n+                 &(@constr_def)[] constrs) -> str {\n         auto s;\n         alt (proto) {\n             case (ast::proto_iter) { s = \"iter\"; }\n@@ -130,7 +130,7 @@ fn ty_to_str(&ctxt cx, &t typ) -> str {\n         }\n         case (ty_native_fn(_, ?inputs, ?output)) {\n             s += fn_to_str(cx, ast::proto_fn, none, inputs, output,\n-                           ast::return, []);\n+                           ast::return, ~[]);\n         }\n         case (ty_obj(?meths)) {\n             auto f = bind method_to_str(cx, _);\n@@ -162,7 +162,7 @@ fn constr_to_str(&@constr_def c) -> str {\n         pprust::constr_args_to_str(pprust::uint_to_str, c.node.args);\n }\n \n-fn constrs_str(&vec[@constr_def] constrs) -> str {\n+fn constrs_str(&(@constr_def)[] constrs) -> str {\n     auto s = \"\";\n     auto colon = true;\n     for (@constr_def c in constrs) {"}]}