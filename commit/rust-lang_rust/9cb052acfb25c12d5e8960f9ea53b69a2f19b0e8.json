{"sha": "9cb052acfb25c12d5e8960f9ea53b69a2f19b0e8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjljYjA1MmFjZmIyNWMxMmQ1ZTg5NjBmOWVhNTNiNjlhMmYxOWIwZTg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-06-19T09:43:58Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-06-19T09:43:58Z"}, "message": "Auto merge of #58351 - oli-obk:double_check_const_eval, r=RalfJung\n\nRefactor interning to properly mark memory as mutable or immutable\n\nr? @RalfJung\n\nThis implementation is incomplete out of multiple reasons\n\n* [ ] add `-Zunleash_the_miri_inside_of_you` tests\n* [ ] report an error if there's an `UnsafeCell` behind a reference in a constant\n* [ ] make validity checks actually test whether the mutability of their allocations match what they see in the type", "tree": {"sha": "982b766b91ad352b683db1af1e6799a7531b65be", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/982b766b91ad352b683db1af1e6799a7531b65be"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9cb052acfb25c12d5e8960f9ea53b69a2f19b0e8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9cb052acfb25c12d5e8960f9ea53b69a2f19b0e8", "html_url": "https://github.com/rust-lang/rust/commit/9cb052acfb25c12d5e8960f9ea53b69a2f19b0e8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9cb052acfb25c12d5e8960f9ea53b69a2f19b0e8/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a6cbf2d1344418cd2807cc5380ef1247647a1e12", "url": "https://api.github.com/repos/rust-lang/rust/commits/a6cbf2d1344418cd2807cc5380ef1247647a1e12", "html_url": "https://github.com/rust-lang/rust/commit/a6cbf2d1344418cd2807cc5380ef1247647a1e12"}, {"sha": "cd290c7ee9cc00413116f402823475ed5735293a", "url": "https://api.github.com/repos/rust-lang/rust/commits/cd290c7ee9cc00413116f402823475ed5735293a", "html_url": "https://github.com/rust-lang/rust/commit/cd290c7ee9cc00413116f402823475ed5735293a"}], "stats": {"total": 955, "additions": 758, "deletions": 197}, "files": [{"sha": "40e81119973615dd2fbd5f3de6561d2359d77107", "filename": "src/librustc/mir/interpret/value.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9cb052acfb25c12d5e8960f9ea53b69a2f19b0e8/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cb052acfb25c12d5e8960f9ea53b69a2f19b0e8/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs?ref=9cb052acfb25c12d5e8960f9ea53b69a2f19b0e8", "patch": "@@ -2,7 +2,7 @@ use std::fmt;\n use rustc_macros::HashStable;\n use rustc_apfloat::{Float, ieee::{Double, Single}};\n \n-use crate::ty::{Ty, InferConst, ParamConst, layout::{HasDataLayout, Size}, subst::SubstsRef};\n+use crate::ty::{Ty, InferConst, ParamConst, layout::{HasDataLayout, Size, Align}, subst::SubstsRef};\n use crate::ty::PlaceholderConst;\n use crate::hir::def_id::DefId;\n \n@@ -45,7 +45,12 @@ pub enum ConstValue<'tcx> {\n \n     /// An allocation together with a pointer into the allocation.\n     /// Invariant: the pointer's `AllocId` resolves to the allocation.\n-    ByRef(Pointer, &'tcx Allocation),\n+    /// The alignment exists to allow `const_field` to have `ByRef` access to nonprimitive fields\n+    /// of `repr(packed)` structs. The alignment may be lower than the type of this constant.\n+    /// This permits reads with lower alignment than what the type would normally require.\n+    /// FIXME(RalfJ,oli-obk): The alignment checks are part of miri, but const eval doesn't really\n+    /// need them. Disabling them may be too hard though.\n+    ByRef(Pointer, Align, &'tcx Allocation),\n \n     /// Used in the HIR by using `Unevaluated` everywhere and later normalizing to one of the other\n     /// variants when the code is monomorphic enough for that."}, {"sha": "4cd0fd3e824f5d5ddb887da6d1f63f8da4b59894", "filename": "src/librustc/ty/structural_impls.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9cb052acfb25c12d5e8960f9ea53b69a2f19b0e8/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cb052acfb25c12d5e8960f9ea53b69a2f19b0e8/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fstructural_impls.rs?ref=9cb052acfb25c12d5e8960f9ea53b69a2f19b0e8", "patch": "@@ -1335,7 +1335,7 @@ impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::Const<'tcx> {\n impl<'tcx> TypeFoldable<'tcx> for ConstValue<'tcx> {\n     fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n         match *self {\n-            ConstValue::ByRef(ptr, alloc) => ConstValue::ByRef(ptr, alloc),\n+            ConstValue::ByRef(ptr, align, alloc) => ConstValue::ByRef(ptr, align, alloc),\n             ConstValue::Infer(ic) => ConstValue::Infer(ic.fold_with(folder)),\n             ConstValue::Param(p) => ConstValue::Param(p.fold_with(folder)),\n             ConstValue::Placeholder(p) => ConstValue::Placeholder(p),"}, {"sha": "f21f203fcc99f0abea1f89e242014445b3dc37a5", "filename": "src/librustc_codegen_llvm/common.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9cb052acfb25c12d5e8960f9ea53b69a2f19b0e8/src%2Flibrustc_codegen_llvm%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cb052acfb25c12d5e8960f9ea53b69a2f19b0e8/src%2Flibrustc_codegen_llvm%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fcommon.rs?ref=9cb052acfb25c12d5e8960f9ea53b69a2f19b0e8", "patch": "@@ -11,7 +11,7 @@ use crate::value::Value;\n use rustc_codegen_ssa::traits::*;\n \n use crate::consts::const_alloc_to_llvm;\n-use rustc::ty::layout::{HasDataLayout, LayoutOf, self, TyLayout, Size};\n+use rustc::ty::layout::{HasDataLayout, LayoutOf, self, TyLayout, Size, Align};\n use rustc::mir::interpret::{Scalar, GlobalAlloc, Allocation};\n use rustc_codegen_ssa::mir::place::PlaceRef;\n \n@@ -344,19 +344,20 @@ impl ConstMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n     fn from_const_alloc(\n         &self,\n         layout: TyLayout<'tcx>,\n+        align: Align,\n         alloc: &Allocation,\n         offset: Size,\n     ) -> PlaceRef<'tcx, &'ll Value> {\n         let init = const_alloc_to_llvm(self, alloc);\n-        let base_addr = self.static_addr_of(init, layout.align.abi, None);\n+        let base_addr = self.static_addr_of(init, align, None);\n \n         let llval = unsafe { llvm::LLVMConstInBoundsGEP(\n             self.const_bitcast(base_addr, self.type_i8p()),\n             &self.const_usize(offset.bytes()),\n             1,\n         )};\n         let llval = self.const_bitcast(llval, self.type_ptr_to(layout.llvm_type(self)));\n-        PlaceRef::new_sized(llval, layout, alloc.align)\n+        PlaceRef::new_sized(llval, layout, align)\n     }\n \n     fn const_ptrcast(&self, val: &'ll Value, ty: &'ll Type) -> &'ll Value {"}, {"sha": "4bf91bbed60eaeec8c0c64d37ea7ad58504db011", "filename": "src/librustc_codegen_llvm/consts.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9cb052acfb25c12d5e8960f9ea53b69a2f19b0e8/src%2Flibrustc_codegen_llvm%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cb052acfb25c12d5e8960f9ea53b69a2f19b0e8/src%2Flibrustc_codegen_llvm%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fconsts.rs?ref=9cb052acfb25c12d5e8960f9ea53b69a2f19b0e8", "patch": "@@ -71,7 +71,9 @@ pub fn codegen_static_initializer(\n     let static_ = cx.tcx.const_eval(param_env.and(cid))?;\n \n     let alloc = match static_.val {\n-        ConstValue::ByRef(ptr, alloc) if ptr.offset.bytes() == 0 => alloc,\n+        ConstValue::ByRef(ptr, align, alloc) if ptr.offset.bytes() == 0 && align == alloc.align => {\n+            alloc\n+        },\n         _ => bug!(\"static const eval returned {:#?}\", static_),\n     };\n     Ok((const_alloc_to_llvm(cx, alloc), alloc))"}, {"sha": "c1626d31c780182f5adba6de03e9177e902cfd03", "filename": "src/librustc_codegen_ssa/mir/operand.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9cb052acfb25c12d5e8960f9ea53b69a2f19b0e8/src%2Flibrustc_codegen_ssa%2Fmir%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cb052acfb25c12d5e8960f9ea53b69a2f19b0e8/src%2Flibrustc_codegen_ssa%2Fmir%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Foperand.rs?ref=9cb052acfb25c12d5e8960f9ea53b69a2f19b0e8", "patch": "@@ -109,8 +109,8 @@ impl<'a, 'tcx, V: CodegenObject> OperandRef<'tcx, V> {\n                 let b_llval = bx.const_usize((end - start) as u64);\n                 OperandValue::Pair(a_llval, b_llval)\n             },\n-            ConstValue::ByRef(ptr, alloc) => {\n-                return bx.load_operand(bx.from_const_alloc(layout, alloc, ptr.offset));\n+            ConstValue::ByRef(ptr, align, alloc) => {\n+                return bx.load_operand(bx.from_const_alloc(layout, align, alloc, ptr.offset));\n             },\n         };\n "}, {"sha": "72aedb4812a21f4e18a91acfd1c6b41e8eaca449", "filename": "src/librustc_codegen_ssa/mir/place.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9cb052acfb25c12d5e8960f9ea53b69a2f19b0e8/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cb052acfb25c12d5e8960f9ea53b69a2f19b0e8/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs?ref=9cb052acfb25c12d5e8960f9ea53b69a2f19b0e8", "patch": "@@ -424,8 +424,8 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 let layout = cx.layout_of(self.monomorphize(&ty));\n                 match bx.tcx().const_eval(param_env.and(cid)) {\n                     Ok(val) => match val.val {\n-                        mir::interpret::ConstValue::ByRef(ptr, alloc) => {\n-                            bx.cx().from_const_alloc(layout, alloc, ptr.offset)\n+                        mir::interpret::ConstValue::ByRef(ptr, align, alloc) => {\n+                            bx.cx().from_const_alloc(layout, align, alloc, ptr.offset)\n                         }\n                         _ => bug!(\"promoteds should have an allocation: {:?}\", val),\n                     },"}, {"sha": "46286b5329e435d138698698871fe158c006de45", "filename": "src/librustc_codegen_ssa/traits/consts.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9cb052acfb25c12d5e8960f9ea53b69a2f19b0e8/src%2Flibrustc_codegen_ssa%2Ftraits%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cb052acfb25c12d5e8960f9ea53b69a2f19b0e8/src%2Flibrustc_codegen_ssa%2Ftraits%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Fconsts.rs?ref=9cb052acfb25c12d5e8960f9ea53b69a2f19b0e8", "patch": "@@ -34,6 +34,7 @@ pub trait ConstMethods<'tcx>: BackendTypes {\n     fn from_const_alloc(\n         &self,\n         layout: layout::TyLayout<'tcx>,\n+        align: layout::Align,\n         alloc: &Allocation,\n         offset: layout::Size,\n     ) -> PlaceRef<'tcx, Self::Value>;"}, {"sha": "284a8f40e1f35c2d9c964f9979027a5f789a7ee5", "filename": "src/librustc_mir/const_eval.rs", "status": "modified", "additions": 59, "deletions": 44, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/9cb052acfb25c12d5e8960f9ea53b69a2f19b0e8/src%2Flibrustc_mir%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cb052acfb25c12d5e8960f9ea53b69a2f19b0e8/src%2Flibrustc_mir%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval.rs?ref=9cb052acfb25c12d5e8960f9ea53b69a2f19b0e8", "patch": "@@ -9,7 +9,7 @@ use std::convert::TryInto;\n \n use rustc::hir::def::DefKind;\n use rustc::hir::def_id::DefId;\n-use rustc::mir::interpret::{ConstEvalErr, ErrorHandled};\n+use rustc::mir::interpret::{ConstEvalErr, ErrorHandled, ScalarMaybeUndef};\n use rustc::mir;\n use rustc::ty::{self, TyCtxt, query::TyCtxtAt};\n use rustc::ty::layout::{self, LayoutOf, VariantIdx};\n@@ -18,15 +18,14 @@ use rustc::traits::Reveal;\n use rustc::util::common::ErrorReported;\n use rustc_data_structures::fx::FxHashMap;\n \n-use syntax::ast::Mutability;\n use syntax::source_map::{Span, DUMMY_SP};\n \n use crate::interpret::{self,\n-    PlaceTy, MPlaceTy, MemPlace, OpTy, ImmTy, Immediate, Scalar,\n+    PlaceTy, MPlaceTy, OpTy, ImmTy, Immediate, Scalar,\n     RawConst, ConstValue,\n     InterpResult, InterpErrorInfo, InterpError, GlobalId, InterpretCx, StackPopCleanup,\n     Allocation, AllocId, MemoryKind,\n-    snapshot, RefTracking,\n+    snapshot, RefTracking, intern_const_alloc_recursive,\n };\n \n /// Number of steps until the detector even starts doing anything.\n@@ -63,33 +62,19 @@ pub(crate) fn eval_promoted<'mir, 'tcx>(\n     eval_body_using_ecx(&mut ecx, cid, body, param_env)\n }\n \n-fn mplace_to_const<'tcx>(\n-    ecx: &CompileTimeEvalContext<'_, 'tcx>,\n-    mplace: MPlaceTy<'tcx>,\n-) -> &'tcx ty::Const<'tcx> {\n-    let MemPlace { ptr, align, meta } = *mplace;\n-    // extract alloc-offset pair\n-    assert!(meta.is_none());\n-    let ptr = ptr.to_ptr().unwrap();\n-    let alloc = ecx.memory.get(ptr.alloc_id).unwrap();\n-    assert!(alloc.align >= align);\n-    assert!(alloc.bytes.len() as u64 - ptr.offset.bytes() >= mplace.layout.size.bytes());\n-    let mut alloc = alloc.clone();\n-    alloc.align = align;\n-    // FIXME shouldn't it be the case that `mark_static_initialized` has already\n-    // interned this?  I thought that is the entire point of that `FinishStatic` stuff?\n-    let alloc = ecx.tcx.intern_const_alloc(alloc);\n-    let val = ConstValue::ByRef(ptr, alloc);\n-    ecx.tcx.mk_const(ty::Const { val, ty: mplace.layout.ty })\n-}\n-\n fn op_to_const<'tcx>(\n     ecx: &CompileTimeEvalContext<'_, 'tcx>,\n     op: OpTy<'tcx>,\n ) -> &'tcx ty::Const<'tcx> {\n-    // We do not normalize just any data.  Only non-union scalars and slices.\n-    let normalize = match op.layout.abi {\n-        layout::Abi::Scalar(..) => op.layout.ty.ty_adt_def().map_or(true, |adt| !adt.is_union()),\n+    // We do not have value optmizations for everything.\n+    // Only scalars and slices, since they are very common.\n+    // Note that further down we turn scalars of undefined bits back to `ByRef`. These can result\n+    // from scalar unions that are initialized with one of their zero sized variants. We could\n+    // instead allow `ConstValue::Scalar` to store `ScalarMaybeUndef`, but that would affect all\n+    // the usual cases of extracting e.g. a `usize`, without there being a real use case for the\n+    // `Undef` situation.\n+    let try_as_immediate = match op.layout.abi {\n+        layout::Abi::Scalar(..) => true,\n         layout::Abi::ScalarPair(..) => match op.layout.ty.sty {\n             ty::Ref(_, inner, _) => match inner.sty {\n                 ty::Slice(elem) => elem == ecx.tcx.types.u8,\n@@ -100,16 +85,38 @@ fn op_to_const<'tcx>(\n         },\n         _ => false,\n     };\n-    let normalized_op = if normalize {\n-        Err(*ecx.read_immediate(op).expect(\"normalization works on validated constants\"))\n+    let immediate = if try_as_immediate {\n+        Err(ecx.read_immediate(op).expect(\"normalization works on validated constants\"))\n     } else {\n+        // It is guaranteed that any non-slice scalar pair is actually ByRef here.\n+        // When we come back from raw const eval, we are always by-ref. The only way our op here is\n+        // by-val is if we are in const_field, i.e., if this is (a field of) something that we\n+        // \"tried to make immediate\" before. We wouldn't do that for non-slice scalar pairs or\n+        // structs containing such.\n         op.try_as_mplace()\n     };\n-    let val = match normalized_op {\n-        Ok(mplace) => return mplace_to_const(ecx, mplace),\n-        Err(Immediate::Scalar(x)) =>\n-            ConstValue::Scalar(x.not_undef().unwrap()),\n-        Err(Immediate::ScalarPair(a, b)) => {\n+    let val = match immediate {\n+        Ok(mplace) => {\n+            let ptr = mplace.ptr.to_ptr().unwrap();\n+            let alloc = ecx.tcx.alloc_map.lock().unwrap_memory(ptr.alloc_id);\n+            ConstValue::ByRef(ptr, mplace.align, alloc)\n+        },\n+        // see comment on `let try_as_immediate` above\n+        Err(ImmTy { imm: Immediate::Scalar(x), .. }) => match x {\n+            ScalarMaybeUndef::Scalar(s) => ConstValue::Scalar(s),\n+            ScalarMaybeUndef::Undef => {\n+                // When coming out of \"normal CTFE\", we'll always have an `Indirect` operand as\n+                // argument and we will not need this. The only way we can already have an\n+                // `Immediate` is when we are called from `const_field`, and that `Immediate`\n+                // comes from a constant so it can happen have `Undef`, because the indirect\n+                // memory that was read had undefined bytes.\n+                let mplace = op.to_mem_place();\n+                let ptr = mplace.ptr.to_ptr().unwrap();\n+                let alloc = ecx.tcx.alloc_map.lock().unwrap_memory(ptr.alloc_id);\n+                ConstValue::ByRef(ptr, mplace.align, alloc)\n+            },\n+        },\n+        Err(ImmTy { imm: Immediate::ScalarPair(a, b), .. }) => {\n             let (data, start) = match a.not_undef().unwrap() {\n                 Scalar::Ptr(ptr) => (\n                     ecx.tcx.alloc_map.lock().unwrap_memory(ptr.alloc_id),\n@@ -164,13 +171,12 @@ fn eval_body_using_ecx<'mir, 'tcx>(\n     ecx.run()?;\n \n     // Intern the result\n-    let mutability = if tcx.is_mutable_static(cid.instance.def_id()) ||\n-                     !layout.ty.is_freeze(tcx, param_env, body.span) {\n-        Mutability::Mutable\n-    } else {\n-        Mutability::Immutable\n-    };\n-    ecx.memory.intern_static(ret.ptr.to_ptr()?.alloc_id, mutability)?;\n+    intern_const_alloc_recursive(\n+        ecx,\n+        cid.instance.def_id(),\n+        ret,\n+        param_env,\n+    )?;\n \n     debug!(\"eval_body_using_ecx done: {:?}\", *ret);\n     Ok(ret)\n@@ -297,7 +303,7 @@ impl<K: Hash + Eq, V> interpret::AllocMap<K, V> for FxHashMap<K, V> {\n     }\n }\n \n-type CompileTimeEvalContext<'mir, 'tcx> =\n+crate type CompileTimeEvalContext<'mir, 'tcx> =\n     InterpretCx<'mir, 'tcx, CompileTimeInterpreter<'mir, 'tcx>>;\n \n impl interpret::MayLeak for ! {\n@@ -526,13 +532,22 @@ fn validate_and_turn_into_const<'tcx>(\n                 mplace.into(),\n                 path,\n                 Some(&mut ref_tracking),\n-                true, // const mode\n             )?;\n         }\n         // Now that we validated, turn this into a proper constant.\n+        // Statics/promoteds are always `ByRef`, for the rest `op_to_const` decides\n+        // whether they become immediates.\n         let def_id = cid.instance.def.def_id();\n         if tcx.is_static(def_id) || cid.promoted.is_some() {\n-            Ok(mplace_to_const(&ecx, mplace))\n+            let ptr = mplace.ptr.to_ptr()?;\n+            Ok(tcx.mk_const(ty::Const {\n+                val: ConstValue::ByRef(\n+                    ptr,\n+                    mplace.align,\n+                    ecx.tcx.alloc_map.lock().unwrap_memory(ptr.alloc_id),\n+                ),\n+                ty: mplace.layout.ty,\n+            }))\n         } else {\n             Ok(op_to_const(&ecx, mplace.into()))\n         }"}, {"sha": "974c863792eed90d1afde41332a145c004fc476b", "filename": "src/librustc_mir/hair/pattern/_match.rs", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/9cb052acfb25c12d5e8960f9ea53b69a2f19b0e8/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cb052acfb25c12d5e8960f9ea53b69a2f19b0e8/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs?ref=9cb052acfb25c12d5e8960f9ea53b69a2f19b0e8", "patch": "@@ -215,10 +215,15 @@ impl LiteralExpander<'tcx> {\n         debug!(\"fold_const_value_deref {:?} {:?} {:?}\", val, rty, crty);\n         match (val, &crty.sty, &rty.sty) {\n             // the easy case, deref a reference\n-            (ConstValue::Scalar(Scalar::Ptr(p)), x, y) if x == y => ConstValue::ByRef(\n-                p,\n-                self.tcx.alloc_map.lock().unwrap_memory(p.alloc_id),\n-            ),\n+            (ConstValue::Scalar(Scalar::Ptr(p)), x, y) if x == y => {\n+                let alloc = self.tcx.alloc_map.lock().unwrap_memory(p.alloc_id);\n+                ConstValue::ByRef(\n+                    p,\n+                    // FIXME(oli-obk): this should be the type's layout\n+                    alloc.align,\n+                    alloc,\n+                )\n+            },\n             // unsize array to slice if pattern is array but match value or other patterns are slice\n             (ConstValue::Scalar(Scalar::Ptr(p)), ty::Array(t, n), ty::Slice(u)) => {\n                 assert_eq!(t, u);\n@@ -1431,7 +1436,7 @@ fn slice_pat_covered_by_const<'tcx>(\n     suffix: &[Pattern<'tcx>],\n ) -> Result<bool, ErrorReported> {\n     let data: &[u8] = match (const_val.val, &const_val.ty.sty) {\n-        (ConstValue::ByRef(ptr, alloc), ty::Array(t, n)) => {\n+        (ConstValue::ByRef(ptr, _, alloc), ty::Array(t, n)) => {\n             assert_eq!(*t, tcx.types.u8);\n             let n = n.assert_usize(tcx).unwrap();\n             alloc.get_bytes(&tcx, ptr, Size::from_bytes(n)).unwrap()\n@@ -1753,7 +1758,7 @@ fn specialize<'p, 'a: 'p, 'tcx>(\n                     let (alloc, offset, n, ty) = match value.ty.sty {\n                         ty::Array(t, n) => {\n                             match value.val {\n-                                ConstValue::ByRef(ptr, alloc) => (\n+                                ConstValue::ByRef(ptr, _, alloc) => (\n                                     alloc,\n                                     ptr.offset,\n                                     n.unwrap_usize(cx.tcx),"}, {"sha": "4afa4a0cbb3d74bba5810c1b7033fb04dfd21659", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9cb052acfb25c12d5e8960f9ea53b69a2f19b0e8/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cb052acfb25c12d5e8960f9ea53b69a2f19b0e8/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=9cb052acfb25c12d5e8960f9ea53b69a2f19b0e8", "patch": "@@ -576,7 +576,6 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpretCx<'mir, 'tcx, M> {\n                     self.place_to_op(return_place)?,\n                     vec![],\n                     None,\n-                    /*const_mode*/false,\n                 )?;\n             }\n         } else {\n@@ -641,6 +640,9 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpretCx<'mir, 'tcx, M> {\n         &self,\n         gid: GlobalId<'tcx>,\n     ) -> InterpResult<'tcx, MPlaceTy<'tcx, M::PointerTag>> {\n+        // FIXME(oli-obk): make this check an assertion that it's not a static here\n+        // FIXME(RalfJ, oli-obk): document that `Place::Static` can never be anything but a static\n+        // and `ConstValue::Unevaluated` can never be a static\n         let param_env = if self.tcx.is_static(gid.instance.def_id()) {\n             ty::ParamEnv::reveal_all()\n         } else {"}, {"sha": "d998f40c86eccf4665f5b80e7a8ab38fb3b1433c", "filename": "src/librustc_mir/interpret/intern.rs", "status": "added", "additions": 333, "deletions": 0, "changes": 333, "blob_url": "https://github.com/rust-lang/rust/blob/9cb052acfb25c12d5e8960f9ea53b69a2f19b0e8/src%2Flibrustc_mir%2Finterpret%2Fintern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cb052acfb25c12d5e8960f9ea53b69a2f19b0e8/src%2Flibrustc_mir%2Finterpret%2Fintern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintern.rs?ref=9cb052acfb25c12d5e8960f9ea53b69a2f19b0e8", "patch": "@@ -0,0 +1,333 @@\n+//! This module specifies the type based interner for constants.\n+//!\n+//! After a const evaluation has computed a value, before we destroy the const evaluator's session\n+//! memory, we need to extract all memory allocations to the global memory pool so they stay around.\n+\n+use rustc::ty::layout::LayoutOf;\n+use rustc::ty::{Ty, TyCtxt, ParamEnv, self};\n+use rustc::mir::interpret::{\n+    InterpResult, ErrorHandled,\n+};\n+use rustc::hir;\n+use rustc::hir::def_id::DefId;\n+use super::validity::RefTracking;\n+use rustc_data_structures::fx::FxHashSet;\n+\n+use syntax::ast::Mutability;\n+use syntax_pos::Span;\n+\n+use super::{\n+    ValueVisitor, MemoryKind, Pointer, AllocId, MPlaceTy, InterpError, Scalar,\n+};\n+use crate::const_eval::{CompileTimeInterpreter, CompileTimeEvalContext};\n+\n+struct InternVisitor<'rt, 'mir: 'rt, 'tcx: 'rt + 'mir> {\n+    /// previously encountered safe references\n+    ref_tracking: &'rt mut RefTracking<(MPlaceTy<'tcx>, Mutability, InternMode)>,\n+    ecx: &'rt mut CompileTimeEvalContext<'mir, 'tcx>,\n+    param_env: ParamEnv<'tcx>,\n+    /// The root node of the value that we're looking at. This field is never mutated and only used\n+    /// for sanity assertions that will ICE when `const_qualif` screws up.\n+    mode: InternMode,\n+    /// This field stores the mutability of the value *currently* being checked.\n+    /// It is set to mutable when an `UnsafeCell` is encountered\n+    /// When recursing across a reference, we don't recurse but store the\n+    /// value to be checked in `ref_tracking` together with the mutability at which we are checking\n+    /// the value.\n+    /// When encountering an immutable reference, we treat everything as immutable that is behind\n+    /// it.\n+    mutability: Mutability,\n+    /// A list of all encountered relocations. After type-based interning, we traverse this list to\n+    /// also intern allocations that are only referenced by a raw pointer or inside a union.\n+    leftover_relocations: &'rt mut FxHashSet<AllocId>,\n+}\n+\n+#[derive(Copy, Clone, Debug, PartialEq, Hash, Eq)]\n+enum InternMode {\n+    /// Mutable references must in fact be immutable due to their surrounding immutability in a\n+    /// `static`. In a `static mut` we start out as mutable and thus can also contain further `&mut`\n+    /// that will actually be treated as mutable.\n+    Static,\n+    /// UnsafeCell is OK in the value of a constant, but not behind references in a constant\n+    ConstBase,\n+    /// `UnsafeCell` ICEs\n+    Const,\n+}\n+\n+/// Signalling data structure to ensure we don't recurse\n+/// into the memory of other constants or statics\n+struct IsStaticOrFn;\n+\n+impl<'rt, 'mir, 'tcx> InternVisitor<'rt, 'mir, 'tcx> {\n+    /// Intern an allocation without looking at its children\n+    fn intern_shallow(\n+        &mut self,\n+        ptr: Pointer,\n+        mutability: Mutability,\n+    ) -> InterpResult<'tcx, Option<IsStaticOrFn>> {\n+        trace!(\n+            \"InternVisitor::intern {:?} with {:?}\",\n+            ptr, mutability,\n+        );\n+        // remove allocation\n+        let tcx = self.ecx.tcx;\n+        let memory = self.ecx.memory_mut();\n+        let (kind, mut alloc) = match memory.alloc_map.remove(&ptr.alloc_id) {\n+            Some(entry) => entry,\n+            None => {\n+                // if the pointer is dangling (neither in local nor global memory), we leave it\n+                // to validation to error. The `delay_span_bug` ensures that we don't forget such\n+                // a check in validation.\n+                if tcx.alloc_map.lock().get(ptr.alloc_id).is_none() {\n+                    tcx.sess.delay_span_bug(self.ecx.tcx.span, \"tried to intern dangling pointer\");\n+                }\n+                // treat dangling pointers like other statics\n+                // just to stop trying to recurse into them\n+                return Ok(Some(IsStaticOrFn));\n+            },\n+        };\n+        // This match is just a canary for future changes to `MemoryKind`, which most likely need\n+        // changes in this function.\n+        match kind {\n+            MemoryKind::Stack | MemoryKind::Vtable => {},\n+        }\n+        // Ensure llvm knows to only put this into immutable memory if the value is immutable either\n+        // by being behind a reference or by being part of a static or const without interior\n+        // mutability\n+        alloc.mutability = mutability;\n+        // link the alloc id to the actual allocation\n+        let alloc = tcx.intern_const_alloc(alloc);\n+        self.leftover_relocations.extend(alloc.relocations.iter().map(|&(_, ((), reloc))| reloc));\n+        tcx.alloc_map.lock().set_alloc_id_memory(ptr.alloc_id, alloc);\n+        Ok(None)\n+    }\n+}\n+\n+impl<'rt, 'mir, 'tcx>\n+    ValueVisitor<'mir, 'tcx, CompileTimeInterpreter<'mir, 'tcx>>\n+for\n+    InternVisitor<'rt, 'mir, 'tcx>\n+{\n+    type V = MPlaceTy<'tcx>;\n+\n+    #[inline(always)]\n+    fn ecx(&self) -> &CompileTimeEvalContext<'mir, 'tcx> {\n+        &self.ecx\n+    }\n+\n+    fn visit_aggregate(\n+        &mut self,\n+        mplace: MPlaceTy<'tcx>,\n+        fields: impl Iterator<Item=InterpResult<'tcx, Self::V>>,\n+    ) -> InterpResult<'tcx> {\n+        if let Some(def) = mplace.layout.ty.ty_adt_def() {\n+            if Some(def.did) == self.ecx.tcx.lang_items().unsafe_cell_type() {\n+                // We are crossing over an `UnsafeCell`, we can mutate again\n+                let old = std::mem::replace(&mut self.mutability, Mutability::Mutable);\n+                assert_ne!(\n+                    self.mode, InternMode::Const,\n+                    \"UnsafeCells are not allowed behind references in constants. This should have \\\n+                    been prevented statically by const qualification. If this were allowed one \\\n+                    would be able to change a constant at one use site and other use sites may \\\n+                    arbitrarily decide to change, too.\",\n+                );\n+                let walked = self.walk_aggregate(mplace, fields);\n+                self.mutability = old;\n+                return walked;\n+            }\n+        }\n+        self.walk_aggregate(mplace, fields)\n+    }\n+\n+    fn visit_primitive(&mut self, mplace: MPlaceTy<'tcx>) -> InterpResult<'tcx> {\n+        // Handle Reference types, as these are the only relocations supported by const eval.\n+        // Raw pointers (and boxes) are handled by the `leftover_relocations` logic.\n+        let ty = mplace.layout.ty;\n+        if let ty::Ref(_, _, mutability) = ty.sty {\n+            let value = self.ecx.read_immediate(mplace.into())?;\n+            // Handle trait object vtables\n+            if let Ok(meta) = value.to_meta() {\n+                let layout = self.ecx.layout_of(ty.builtin_deref(true).unwrap().ty)?;\n+                if layout.is_unsized() {\n+                    if let ty::Dynamic(..) = self.ecx.tcx.struct_tail(layout.ty).sty {\n+                        if let Ok(vtable) = meta.unwrap().to_ptr() {\n+                            // explitly choose `Immutable` here, since vtables are immutable, even\n+                            // if the reference of the fat pointer is mutable\n+                            self.intern_shallow(vtable, Mutability::Immutable)?;\n+                        }\n+                    }\n+                }\n+            }\n+            let mplace = self.ecx.ref_to_mplace(value)?;\n+            // Check if we have encountered this pointer+layout combination before.\n+            // Only recurse for allocation-backed pointers.\n+            if let Scalar::Ptr(ptr) = mplace.ptr {\n+                // We do not have any `frozen` logic here, because it's essentially equivalent to\n+                // the mutability except for the outermost item. Only `UnsafeCell` can \"unfreeze\",\n+                // and we check that in `visit_aggregate`.\n+                // This is not an inherent limitation, but one that we know to be true, because\n+                // const qualification enforces it. We can lift it in the future.\n+                match (self.mode, mutability) {\n+                    // immutable references are fine everywhere\n+                    (_, hir::Mutability::MutImmutable) => {},\n+                    // all is \"good and well\" in the unsoundness of `static mut`\n+\n+                    // mutable references are ok in `static`. Either they are treated as immutable\n+                    // because they are behind an immutable one, or they are behind an `UnsafeCell`\n+                    // and thus ok.\n+                    (InternMode::Static, hir::Mutability::MutMutable) => {},\n+                    // we statically prevent `&mut T` via `const_qualif` and double check this here\n+                    (InternMode::ConstBase, hir::Mutability::MutMutable) |\n+                    (InternMode::Const, hir::Mutability::MutMutable) =>\n+                        bug!(\"const qualif failed to prevent mutable references\"),\n+                }\n+                // Compute the mutability with which we'll start visiting the allocation. This is\n+                // what gets changed when we encounter an `UnsafeCell`\n+                let mutability = match (self.mutability, mutability) {\n+                    // The only way a mutable reference actually works as a mutable reference is\n+                    // by being in a `static mut` directly or behind another mutable reference.\n+                    // If there's an immutable reference or we are inside a static, then our\n+                    // mutable reference is equivalent to an immutable one. As an example:\n+                    // `&&mut Foo` is semantically equivalent to `&&Foo`\n+                    (Mutability::Mutable, hir::Mutability::MutMutable) => Mutability::Mutable,\n+                    _ => Mutability::Immutable,\n+                };\n+                // Compute the mutability of the allocation\n+                let intern_mutability = intern_mutability(\n+                    self.ecx.tcx.tcx,\n+                    self.param_env,\n+                    mplace.layout.ty,\n+                    self.ecx.tcx.span,\n+                    mutability,\n+                );\n+                // Recursing behind references changes the intern mode for constants in order to\n+                // cause assertions to trigger if we encounter any `UnsafeCell`s.\n+                let mode = match self.mode {\n+                    InternMode::ConstBase => InternMode::Const,\n+                    other => other,\n+                };\n+                match self.intern_shallow(ptr, intern_mutability)? {\n+                    // No need to recurse, these are interned already and statics may have\n+                    // cycles, so we don't want to recurse there\n+                    Some(IsStaticOrFn) => {},\n+                    // intern everything referenced by this value. The mutability is taken from the\n+                    // reference. It is checked above that mutable references only happen in\n+                    // `static mut`\n+                    None => self.ref_tracking.track((mplace, mutability, mode), || ()),\n+                }\n+            }\n+        }\n+        Ok(())\n+    }\n+}\n+\n+/// Figure out the mutability of the allocation.\n+/// Mutable if it has interior mutability *anywhere* in the type.\n+fn intern_mutability<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    param_env: ParamEnv<'tcx>,\n+    ty: Ty<'tcx>,\n+    span: Span,\n+    mutability: Mutability,\n+) -> Mutability {\n+    let has_interior_mutability = !ty.is_freeze(tcx, param_env, span);\n+    if has_interior_mutability {\n+        Mutability::Mutable\n+    } else {\n+        mutability\n+    }\n+}\n+\n+pub fn intern_const_alloc_recursive(\n+    ecx: &mut CompileTimeEvalContext<'mir, 'tcx>,\n+    def_id: DefId,\n+    ret: MPlaceTy<'tcx>,\n+    // FIXME(oli-obk): can we scrap the param env? I think we can, the final value of a const eval\n+    // must always be monomorphic, right?\n+    param_env: ty::ParamEnv<'tcx>,\n+) -> InterpResult<'tcx> {\n+    let tcx = ecx.tcx;\n+    // this `mutability` is the mutability of the place, ignoring the type\n+    let (mutability, base_intern_mode) = match tcx.static_mutability(def_id) {\n+        Some(hir::Mutability::MutImmutable) => (Mutability::Immutable, InternMode::Static),\n+        None => (Mutability::Immutable, InternMode::ConstBase),\n+        // `static mut` doesn't care about interior mutability, it's mutable anyway\n+        Some(hir::Mutability::MutMutable) => (Mutability::Mutable, InternMode::Static),\n+    };\n+\n+    // type based interning\n+    let mut ref_tracking = RefTracking::new((ret, mutability, base_intern_mode));\n+    let leftover_relocations = &mut FxHashSet::default();\n+\n+    // This mutability is the combination of the place mutability and the type mutability. If either\n+    // is mutable, `alloc_mutability` is mutable. This exists because the entire allocation needs\n+    // to be mutable if it contains an `UnsafeCell` anywhere. The other `mutability` exists so that\n+    // the visitor does not treat everything outside the `UnsafeCell` as mutable.\n+    let alloc_mutability = intern_mutability(\n+        tcx.tcx, param_env, ret.layout.ty, tcx.span, mutability,\n+    );\n+\n+    // start with the outermost allocation\n+    InternVisitor {\n+        ref_tracking: &mut ref_tracking,\n+        ecx,\n+        mode: base_intern_mode,\n+        leftover_relocations,\n+        param_env,\n+        mutability,\n+    }.intern_shallow(ret.ptr.to_ptr()?, alloc_mutability)?;\n+\n+    while let Some(((mplace, mutability, mode), _)) = ref_tracking.todo.pop() {\n+        let interned = InternVisitor {\n+            ref_tracking: &mut ref_tracking,\n+            ecx,\n+            mode,\n+            leftover_relocations,\n+            param_env,\n+            mutability,\n+        }.visit_value(mplace);\n+        if let Err(error) = interned {\n+            // This can happen when e.g. the tag of an enum is not a valid discriminant. We do have\n+            // to read enum discriminants in order to find references in enum variant fields.\n+            if let InterpError::ValidationFailure(_) = error.kind {\n+                let err = crate::const_eval::error_to_const_error(&ecx, error);\n+                match err.struct_error(ecx.tcx, \"it is undefined behavior to use this value\") {\n+                    Ok(mut diag) => {\n+                        diag.note(\"The rules on what exactly is undefined behavior aren't clear, \\\n+                            so this check might be overzealous. Please open an issue on the rust \\\n+                            compiler repository if you believe it should not be considered \\\n+                            undefined behavior\",\n+                        );\n+                        diag.emit();\n+                    }\n+                    Err(ErrorHandled::TooGeneric) |\n+                    Err(ErrorHandled::Reported) => {},\n+                }\n+            }\n+        }\n+    }\n+\n+    // Intern the rest of the allocations as mutable. These might be inside unions, padding, raw\n+    // pointers, ... So we can't intern them according to their type rules\n+\n+    let mut todo: Vec<_> = leftover_relocations.iter().cloned().collect();\n+    while let Some(alloc_id) = todo.pop() {\n+        if let Some((_, alloc)) = ecx.memory_mut().alloc_map.remove(&alloc_id) {\n+            // We can't call the `intern` method here, as its logic is tailored to safe references.\n+            // So we hand-roll the interning logic here again\n+            let alloc = tcx.intern_const_alloc(alloc);\n+            tcx.alloc_map.lock().set_alloc_id_memory(alloc_id, alloc);\n+            for &(_, ((), reloc)) in alloc.relocations.iter() {\n+                if leftover_relocations.insert(reloc) {\n+                    todo.push(reloc);\n+                }\n+            }\n+        } else if ecx.memory().dead_alloc_map.contains_key(&alloc_id) {\n+            // dangling pointer\n+            return err!(ValidationFailure(\n+                \"encountered dangling pointer in final constant\".into(),\n+            ))\n+        }\n+    }\n+    Ok(())\n+}"}, {"sha": "f2a115f8f35990b1b3ce4db080234f3e64236d70", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 23, "deletions": 61, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/9cb052acfb25c12d5e8960f9ea53b69a2f19b0e8/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cb052acfb25c12d5e8960f9ea53b69a2f19b0e8/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=9cb052acfb25c12d5e8960f9ea53b69a2f19b0e8", "patch": "@@ -20,6 +20,7 @@ use super::{\n     Pointer, AllocId, Allocation, GlobalId, AllocationExtra,\n     InterpResult, Scalar, InterpError, GlobalAlloc, PointerArithmetic,\n     Machine, AllocMap, MayLeak, ErrorHandled, CheckInAllocMsg, InboundsCheck,\n+    InterpError::ValidationFailure,\n };\n \n #[derive(Debug, PartialEq, Eq, Copy, Clone, Hash)]\n@@ -55,12 +56,13 @@ pub struct Memory<'mir, 'tcx, M: Machine<'mir, 'tcx>> {\n     /// the wrong type), so we let the machine override this type.\n     /// Either way, if the machine allows writing to a static, doing so will\n     /// create a copy of the static allocation here.\n-    alloc_map: M::MemoryMap,\n+    // FIXME: this should not be public, but interning currently needs access to it\n+    pub(super) alloc_map: M::MemoryMap,\n \n     /// To be able to compare pointers with NULL, and to check alignment for accesses\n     /// to ZSTs (where pointers may dangle), we keep track of the size even for allocations\n     /// that do not exist any more.\n-    dead_alloc_map: FxHashMap<AllocId, (Size, Align)>,\n+    pub(super) dead_alloc_map: FxHashMap<AllocId, (Size, Align)>,\n \n     /// Extra data added by the machine.\n     pub extra: M::MemoryExtra,\n@@ -452,9 +454,13 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         if let Ok(alloc) = self.get(id) {\n             return Ok((Size::from_bytes(alloc.bytes.len() as u64), alloc.align));\n         }\n+        // can't do this in the match argument, we may get cycle errors since the lock would get\n+        // dropped after the match.\n+        let alloc = self.tcx.alloc_map.lock().get(id);\n         // Could also be a fn ptr or extern static\n-        match self.tcx.alloc_map.lock().get(id) {\n+        match alloc {\n             Some(GlobalAlloc::Function(..)) => Ok((Size::ZERO, Align::from_bytes(1).unwrap())),\n+            // `self.get` would also work, but can cause cycles if a static refers to itself\n             Some(GlobalAlloc::Static(did)) => {\n                 // The only way `get` couldn't have worked here is if this is an extern static\n                 assert!(self.tcx.is_foreign_item(did));\n@@ -463,14 +469,20 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n                 let layout = self.tcx.layout_of(ParamEnv::empty().and(ty)).unwrap();\n                 Ok((layout.size, layout.align.abi))\n             }\n-            _ => match liveness {\n-                InboundsCheck::MaybeDead => {\n-                    // Must be a deallocated pointer\n-                    Ok(*self.dead_alloc_map.get(&id).expect(\n-                        \"allocation missing in dead_alloc_map\"\n-                    ))\n-                },\n-                InboundsCheck::Live => err!(DanglingPointerDeref),\n+            _ => {\n+                if let Ok(alloc) = self.get(id) {\n+                    return Ok((Size::from_bytes(alloc.bytes.len() as u64), alloc.align));\n+                }\n+                match liveness {\n+                    InboundsCheck::MaybeDead => {\n+                        // Must be a deallocated pointer\n+                        self.dead_alloc_map.get(&id).cloned().ok_or_else(||\n+                            ValidationFailure(\"allocation missing in dead_alloc_map\".to_string())\n+                                .into()\n+                        )\n+                    },\n+                    InboundsCheck::Live => err!(DanglingPointerDeref),\n+                }\n             },\n         }\n     }\n@@ -633,56 +645,6 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n     }\n }\n \n-/// Interning (for CTFE)\n-impl<'mir, 'tcx, M> Memory<'mir, 'tcx, M>\n-where\n-    M: Machine<'mir, 'tcx, PointerTag = (), AllocExtra = (), MemoryExtra = ()>,\n-    // FIXME: Working around https://github.com/rust-lang/rust/issues/24159\n-    M::MemoryMap: AllocMap<AllocId, (MemoryKind<M::MemoryKinds>, Allocation)>,\n-{\n-    /// mark an allocation as static and initialized, either mutable or not\n-    pub fn intern_static(\n-        &mut self,\n-        alloc_id: AllocId,\n-        mutability: Mutability,\n-    ) -> InterpResult<'tcx> {\n-        trace!(\n-            \"mark_static_initialized {:?}, mutability: {:?}\",\n-            alloc_id,\n-            mutability\n-        );\n-        // remove allocation\n-        let (kind, mut alloc) = self.alloc_map.remove(&alloc_id).unwrap();\n-        match kind {\n-            MemoryKind::Machine(_) => bug!(\"Static cannot refer to machine memory\"),\n-            MemoryKind::Stack | MemoryKind::Vtable => {},\n-        }\n-        // ensure llvm knows not to put this into immutable memory\n-        alloc.mutability = mutability;\n-        let alloc = self.tcx.intern_const_alloc(alloc);\n-        self.tcx.alloc_map.lock().set_alloc_id_memory(alloc_id, alloc);\n-        // recurse into inner allocations\n-        for &(_, alloc) in alloc.relocations.values() {\n-            // FIXME: Reusing the mutability here is likely incorrect.  It is originally\n-            // determined via `is_freeze`, and data is considered frozen if there is no\n-            // `UnsafeCell` *immediately* in that data -- however, this search stops\n-            // at references.  So whenever we follow a reference, we should likely\n-            // assume immutability -- and we should make sure that the compiler\n-            // does not permit code that would break this!\n-            if self.alloc_map.contains_key(&alloc) {\n-                // Not yet interned, so proceed recursively\n-                self.intern_static(alloc, mutability)?;\n-            } else if self.dead_alloc_map.contains_key(&alloc) {\n-                // dangling pointer\n-                return err!(ValidationFailure(\n-                    \"encountered dangling pointer in final constant\".into(),\n-                ))\n-            }\n-        }\n-        Ok(())\n-    }\n-}\n-\n /// Reading and writing.\n impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n     pub fn copy("}, {"sha": "0293a8366d0837b6e84d904ca4817d1ac8f2f5ee", "filename": "src/librustc_mir/interpret/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9cb052acfb25c12d5e8960f9ea53b69a2f19b0e8/src%2Flibrustc_mir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cb052acfb25c12d5e8960f9ea53b69a2f19b0e8/src%2Flibrustc_mir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmod.rs?ref=9cb052acfb25c12d5e8960f9ea53b69a2f19b0e8", "patch": "@@ -14,6 +14,7 @@ mod traits;\n mod validity;\n mod intrinsics;\n mod visitor;\n+mod intern;\n \n pub use rustc::mir::interpret::*; // have all the `interpret` symbols in one place: here\n \n@@ -34,3 +35,5 @@ pub use self::visitor::{ValueVisitor, MutValueVisitor};\n pub use self::validity::RefTracking;\n \n pub(super) use self::intrinsics::type_name;\n+\n+pub use self::intern::intern_const_alloc_recursive;"}, {"sha": "1b451e0b8f18f7e5c1cbc25e731d289dd97ad828", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 23, "deletions": 12, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/9cb052acfb25c12d5e8960f9ea53b69a2f19b0e8/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cb052acfb25c12d5e8960f9ea53b69a2f19b0e8/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=9cb052acfb25c12d5e8960f9ea53b69a2f19b0e8", "patch": "@@ -4,7 +4,9 @@\n use std::convert::TryInto;\n \n use rustc::{mir, ty};\n-use rustc::ty::layout::{self, Size, LayoutOf, TyLayout, HasDataLayout, IntegerExt, VariantIdx};\n+use rustc::ty::layout::{\n+    self, Size, LayoutOf, TyLayout, HasDataLayout, IntegerExt, VariantIdx,\n+};\n \n use rustc::mir::interpret::{\n     GlobalId, AllocId, CheckInAllocMsg,\n@@ -217,7 +219,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpretCx<'mir, 'tcx, M> {\n     fn try_read_immediate_from_mplace(\n         &self,\n         mplace: MPlaceTy<'tcx, M::PointerTag>,\n-    ) -> InterpResult<'tcx, Option<Immediate<M::PointerTag>>> {\n+    ) -> InterpResult<'tcx, Option<ImmTy<'tcx, M::PointerTag>>> {\n         if mplace.layout.is_unsized() {\n             // Don't touch unsized\n             return Ok(None);\n@@ -228,7 +230,10 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpretCx<'mir, 'tcx, M> {\n             // Not all ZSTs have a layout we would handle below, so just short-circuit them\n             // all here.\n             self.memory.check_align(ptr, ptr_align)?;\n-            return Ok(Some(Immediate::Scalar(Scalar::zst().into())));\n+            return Ok(Some(ImmTy {\n+                imm: Immediate::Scalar(Scalar::zst().into()),\n+                layout: mplace.layout,\n+            }));\n         }\n \n         // check for integer pointers before alignment to report better errors\n@@ -239,7 +244,10 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpretCx<'mir, 'tcx, M> {\n                 let scalar = self.memory\n                     .get(ptr.alloc_id)?\n                     .read_scalar(self, ptr, mplace.layout.size)?;\n-                Ok(Some(Immediate::Scalar(scalar)))\n+                Ok(Some(ImmTy {\n+                    imm: Immediate::Scalar(scalar),\n+                    layout: mplace.layout,\n+                }))\n             }\n             layout::Abi::ScalarPair(ref a, ref b) => {\n                 let (a, b) = (&a.value, &b.value);\n@@ -256,7 +264,10 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpretCx<'mir, 'tcx, M> {\n                 let b_val = self.memory\n                     .get(ptr.alloc_id)?\n                     .read_scalar(self, b_ptr, b_size)?;\n-                Ok(Some(Immediate::ScalarPair(a_val, b_val)))\n+                Ok(Some(ImmTy {\n+                    imm: Immediate::ScalarPair(a_val, b_val),\n+                    layout: mplace.layout,\n+                }))\n             }\n             _ => Ok(None),\n         }\n@@ -271,13 +282,13 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpretCx<'mir, 'tcx, M> {\n     pub(crate) fn try_read_immediate(\n         &self,\n         src: OpTy<'tcx, M::PointerTag>,\n-    ) -> InterpResult<'tcx, Result<Immediate<M::PointerTag>, MemPlace<M::PointerTag>>> {\n+    ) -> InterpResult<'tcx, Result<ImmTy<'tcx, M::PointerTag>, MPlaceTy<'tcx, M::PointerTag>>> {\n         Ok(match src.try_as_mplace() {\n             Ok(mplace) => {\n                 if let Some(val) = self.try_read_immediate_from_mplace(mplace)? {\n                     Ok(val)\n                 } else {\n-                    Err(*mplace)\n+                    Err(mplace)\n                 }\n             },\n             Err(val) => Ok(val),\n@@ -291,7 +302,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpretCx<'mir, 'tcx, M> {\n         op: OpTy<'tcx, M::PointerTag>\n     ) -> InterpResult<'tcx, ImmTy<'tcx, M::PointerTag>> {\n         if let Ok(imm) = self.try_read_immediate(op)? {\n-            Ok(ImmTy { imm, layout: op.layout })\n+            Ok(imm)\n         } else {\n             bug!(\"primitive read failed for type: {:?}\", op.layout.ty);\n         }\n@@ -339,9 +350,9 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpretCx<'mir, 'tcx, M> {\n             return Ok(OpTy { op: Operand::Immediate(immediate), layout: field_layout });\n         }\n         let offset = op.layout.fields.offset(field);\n-        let immediate = match base {\n+        let immediate = match *base {\n             // the field covers the entire type\n-            _ if offset.bytes() == 0 && field_layout.size == op.layout.size => base,\n+            _ if offset.bytes() == 0 && field_layout.size == op.layout.size => *base,\n             // extract fields from types with `ScalarPair` ABI\n             Immediate::ScalarPair(a, b) => {\n                 let val = if offset.bytes() == 0 { a } else { b };\n@@ -527,11 +538,11 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpretCx<'mir, 'tcx, M> {\n             self.layout_of(self.monomorphize(val.ty)?)\n         })?;\n         let op = match val.val {\n-            ConstValue::ByRef(ptr, _alloc) => {\n+            ConstValue::ByRef(ptr, align, _alloc) => {\n                 // We rely on mutability being set correctly in that allocation to prevent writes\n                 // where none should happen.\n                 let ptr = self.tag_static_base_pointer(ptr);\n-                Operand::Indirect(MemPlace::from_ptr(ptr, layout.align.abi))\n+                Operand::Indirect(MemPlace::from_ptr(ptr, align))\n             },\n             ConstValue::Scalar(x) =>\n                 Operand::Immediate(Immediate::Scalar(tag_scalar(x).into())),"}, {"sha": "1285549015cdd3ff1c0ba8febe3defbebcca0de6", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9cb052acfb25c12d5e8960f9ea53b69a2f19b0e8/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cb052acfb25c12d5e8960f9ea53b69a2f19b0e8/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=9cb052acfb25c12d5e8960f9ea53b69a2f19b0e8", "patch": "@@ -232,10 +232,10 @@ impl<'tcx, Tag> MPlaceTy<'tcx, Tag> {\n \n impl<'tcx, Tag: ::std::fmt::Debug + Copy> OpTy<'tcx, Tag> {\n     #[inline(always)]\n-    pub fn try_as_mplace(self) -> Result<MPlaceTy<'tcx, Tag>, Immediate<Tag>> {\n+    pub fn try_as_mplace(self) -> Result<MPlaceTy<'tcx, Tag>, ImmTy<'tcx, Tag>> {\n         match *self {\n             Operand::Indirect(mplace) => Ok(MPlaceTy { mplace, layout: self.layout }),\n-            Operand::Immediate(imm) => Err(imm),\n+            Operand::Immediate(imm) => Err(ImmTy { imm, layout: self.layout }),\n         }\n     }\n \n@@ -660,7 +660,7 @@ where\n \n         if M::enforce_validity(self) {\n             // Data got changed, better make sure it matches the type!\n-            self.validate_operand(self.place_to_op(dest)?, vec![], None, /*const_mode*/false)?;\n+            self.validate_operand(self.place_to_op(dest)?, vec![], None)?;\n         }\n \n         Ok(())\n@@ -677,7 +677,7 @@ where\n \n         if M::enforce_validity(self) {\n             // Data got changed, better make sure it matches the type!\n-            self.validate_operand(dest.into(), vec![], None, /*const_mode*/ false)?;\n+            self.validate_operand(dest.into(), vec![], None)?;\n         }\n \n         Ok(())\n@@ -809,7 +809,7 @@ where\n \n         if M::enforce_validity(self) {\n             // Data got changed, better make sure it matches the type!\n-            self.validate_operand(self.place_to_op(dest)?, vec![], None, /*const_mode*/false)?;\n+            self.validate_operand(self.place_to_op(dest)?, vec![], None)?;\n         }\n \n         Ok(())\n@@ -836,7 +836,7 @@ where\n                 // Yay, we got a value that we can write directly.\n                 // FIXME: Add a check to make sure that if `src` is indirect,\n                 // it does not overlap with `dest`.\n-                return self.write_immediate_no_validate(src_val, dest);\n+                return self.write_immediate_no_validate(*src_val, dest);\n             }\n             Err(mplace) => mplace,\n         };\n@@ -897,7 +897,7 @@ where\n \n         if M::enforce_validity(self) {\n             // Data got changed, better make sure it matches the type!\n-            self.validate_operand(dest.into(), vec![], None, /*const_mode*/false)?;\n+            self.validate_operand(dest.into(), vec![], None)?;\n         }\n \n         Ok(())"}, {"sha": "d747eddd8d7ba6fe62968a8d28589c9766d83ab1", "filename": "src/librustc_mir/interpret/validity.rs", "status": "modified", "additions": 57, "deletions": 31, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/9cb052acfb25c12d5e8960f9ea53b69a2f19b0e8/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cb052acfb25c12d5e8960f9ea53b69a2f19b0e8/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs?ref=9cb052acfb25c12d5e8960f9ea53b69a2f19b0e8", "patch": "@@ -1,5 +1,4 @@\n use std::fmt::Write;\n-use std::hash::Hash;\n use std::ops::RangeInclusive;\n \n use syntax_pos::symbol::{sym, Symbol};\n@@ -11,6 +10,8 @@ use rustc::mir::interpret::{\n     Scalar, GlobalAlloc, InterpResult, InterpError, CheckInAllocMsg,\n };\n \n+use std::hash::Hash;\n+\n use super::{\n     OpTy, Machine, InterpretCx, ValueVisitor, MPlaceTy,\n };\n@@ -76,19 +77,34 @@ pub enum PathElem {\n }\n \n /// State for tracking recursive validation of references\n-pub struct RefTracking<T> {\n+pub struct RefTracking<T, PATH = ()> {\n     pub seen: FxHashSet<T>,\n-    pub todo: Vec<(T, Vec<PathElem>)>,\n+    pub todo: Vec<(T, PATH)>,\n }\n \n-impl<T: Copy + Eq + Hash> RefTracking<T> {\n+impl<T: Copy + Eq + Hash + std::fmt::Debug, PATH: Default> RefTracking<T, PATH> {\n+    pub fn empty() -> Self {\n+        RefTracking {\n+            seen: FxHashSet::default(),\n+            todo: vec![],\n+        }\n+    }\n     pub fn new(op: T) -> Self {\n-        let mut ref_tracking = RefTracking {\n+        let mut ref_tracking_for_consts = RefTracking {\n             seen: FxHashSet::default(),\n-            todo: vec![(op, Vec::new())],\n+            todo: vec![(op, PATH::default())],\n         };\n-        ref_tracking.seen.insert(op);\n-        ref_tracking\n+        ref_tracking_for_consts.seen.insert(op);\n+        ref_tracking_for_consts\n+    }\n+\n+    pub fn track(&mut self, op: T, path: impl FnOnce() -> PATH) {\n+        if self.seen.insert(op) {\n+            trace!(\"Recursing below ptr {:#?}\", op);\n+            let path = path();\n+            // Remember to come back to this later.\n+            self.todo.push((op, path));\n+        }\n     }\n }\n \n@@ -154,8 +170,10 @@ struct ValidityVisitor<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> {\n     /// starts must not be changed!  `visit_fields` and `visit_array` rely on\n     /// this stack discipline.\n     path: Vec<PathElem>,\n-    ref_tracking: Option<&'rt mut RefTracking<MPlaceTy<'tcx, M::PointerTag>>>,\n-    const_mode: bool,\n+    ref_tracking_for_consts: Option<&'rt mut RefTracking<\n+        MPlaceTy<'tcx, M::PointerTag>,\n+        Vec<PathElem>,\n+    >>,\n     ecx: &'rt InterpretCx<'mir, 'tcx, M>,\n }\n \n@@ -314,7 +332,7 @@ impl<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n                 // types below!\n                 let size = value.layout.size;\n                 let value = value.to_scalar_or_undef();\n-                if self.const_mode {\n+                if self.ref_tracking_for_consts.is_some() {\n                     // Integers/floats in CTFE: Must be scalar bits, pointers are dangerous\n                     try_validation!(value.to_bits(size),\n                         value, self.path, \"initialized plain (non-pointer) bytes\");\n@@ -324,7 +342,7 @@ impl<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n                 }\n             }\n             ty::RawPtr(..) => {\n-                if self.const_mode {\n+                if self.ref_tracking_for_consts.is_some() {\n                     // Integers/floats in CTFE: For consistency with integers, we do not\n                     // accept undef.\n                     let _ptr = try_validation!(value.to_scalar_ptr(),\n@@ -393,9 +411,9 @@ impl<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n                     }\n                 }\n                 // Recursive checking\n-                if let Some(ref mut ref_tracking) = self.ref_tracking {\n-                    assert!(self.const_mode, \"We should only do recursie checking in const mode\");\n+                if let Some(ref mut ref_tracking) = self.ref_tracking_for_consts {\n                     let place = self.ecx.ref_to_mplace(value)?;\n+                    // FIXME(RalfJ): check ZST for inbound pointers\n                     if size != Size::ZERO {\n                         // Non-ZST also have to be dereferencable\n                         let ptr = try_validation!(place.ptr.to_ptr(),\n@@ -423,16 +441,15 @@ impl<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n                     // before.  Proceed recursively even for integer pointers, no\n                     // reason to skip them! They are (recursively) valid for some ZST,\n                     // but not for others (e.g., `!` is a ZST).\n-                    if ref_tracking.seen.insert(place) {\n-                        trace!(\"Recursing below ptr {:#?}\", *place);\n+                    let path = &self.path;\n+                    ref_tracking.track(place, || {\n                         // We need to clone the path anyway, make sure it gets created\n                         // with enough space for the additional `Deref`.\n-                        let mut new_path = Vec::with_capacity(self.path.len()+1);\n-                        new_path.clone_from(&self.path);\n+                        let mut new_path = Vec::with_capacity(path.len() + 1);\n+                        new_path.clone_from(path);\n                         new_path.push(PathElem::Deref);\n-                        // Remember to come back to this later.\n-                        ref_tracking.todo.push((place, new_path));\n-                    }\n+                        new_path\n+                    });\n                 }\n             }\n             ty::FnPtr(_sig) => {\n@@ -488,10 +505,17 @@ impl<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n                     let non_null =\n                         self.ecx.memory.check_align(\n                             Scalar::Ptr(ptr), Align::from_bytes(1).unwrap()\n-                        ).is_ok() ||\n-                        self.ecx.memory.get_fn(ptr).is_ok();\n+                        ).is_ok();\n                     if !non_null {\n-                        // could be NULL\n+                        // These conditions are just here to improve the diagnostics so we can\n+                        // differentiate between null pointers and dangling pointers\n+                        if self.ref_tracking_for_consts.is_some() &&\n+                            self.ecx.memory.get(ptr.alloc_id).is_err() &&\n+                            self.ecx.memory.get_fn(ptr).is_err() {\n+                            return validation_failure!(\n+                                \"encountered dangling pointer\", self.path\n+                            );\n+                        }\n                         return validation_failure!(\"a potentially NULL pointer\", self.path);\n                     }\n                     return Ok(());\n@@ -574,7 +598,7 @@ impl<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n                     self.ecx,\n                     ptr,\n                     size,\n-                    /*allow_ptr_and_undef*/!self.const_mode,\n+                    /*allow_ptr_and_undef*/ self.ref_tracking_for_consts.is_none(),\n                 ) {\n                     // In the happy case, we needn't check anything else.\n                     Ok(()) => {},\n@@ -612,23 +636,25 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpretCx<'mir, 'tcx, M> {\n     /// is an indirect operand.\n     /// It will error if the bits at the destination do not match the ones described by the layout.\n     ///\n-    /// `ref_tracking` can be `None` to avoid recursive checking below references.\n+    /// `ref_tracking_for_consts` can be `None` to avoid recursive checking below references.\n     /// This also toggles between \"run-time\" (no recursion) and \"compile-time\" (with recursion)\n-    /// validation (e.g., pointer values are fine in integers at runtime).\n+    /// validation (e.g., pointer values are fine in integers at runtime) and various other const\n+    /// specific validation checks\n     pub fn validate_operand(\n         &self,\n         op: OpTy<'tcx, M::PointerTag>,\n         path: Vec<PathElem>,\n-        ref_tracking: Option<&mut RefTracking<MPlaceTy<'tcx, M::PointerTag>>>,\n-        const_mode: bool,\n+        ref_tracking_for_consts: Option<&mut RefTracking<\n+            MPlaceTy<'tcx, M::PointerTag>,\n+            Vec<PathElem>,\n+        >>,\n     ) -> InterpResult<'tcx> {\n         trace!(\"validate_operand: {:?}, {:?}\", *op, op.layout.ty);\n \n         // Construct a visitor\n         let mut visitor = ValidityVisitor {\n             path,\n-            ref_tracking,\n-            const_mode,\n+            ref_tracking_for_consts,\n             ecx: self,\n         };\n "}, {"sha": "d04dc3ab37ed3e4b83bbfed8d3b35ad887c82c18", "filename": "src/librustc_mir/interpret/visitor.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9cb052acfb25c12d5e8960f9ea53b69a2f19b0e8/src%2Flibrustc_mir%2Finterpret%2Fvisitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cb052acfb25c12d5e8960f9ea53b69a2f19b0e8/src%2Flibrustc_mir%2Finterpret%2Fvisitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvisitor.rs?ref=9cb052acfb25c12d5e8960f9ea53b69a2f19b0e8", "patch": "@@ -81,6 +81,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Value<'mir, 'tcx, M> for OpTy<'tcx, M::\n         ecx.operand_field(self, field)\n     }\n }\n+\n impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Value<'mir, 'tcx, M> for MPlaceTy<'tcx, M::PointerTag> {\n     #[inline(always)]\n     fn layout(&self) -> TyLayout<'tcx> {"}, {"sha": "c64bb73802dc822cdf834d0441cbdb4dc0a04e44", "filename": "src/librustc_mir/monomorphize/collector.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9cb052acfb25c12d5e8960f9ea53b69a2f19b0e8/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cb052acfb25c12d5e8960f9ea53b69a2f19b0e8/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs?ref=9cb052acfb25c12d5e8960f9ea53b69a2f19b0e8", "patch": "@@ -1262,7 +1262,7 @@ fn collect_const<'tcx>(\n         ConstValue::Scalar(Scalar::Ptr(ptr)) =>\n             collect_miri(tcx, ptr.alloc_id, output),\n         ConstValue::Slice { data: alloc, start: _, end: _ } |\n-        ConstValue::ByRef(_, alloc) => {\n+        ConstValue::ByRef(_, _, alloc) => {\n             for &((), id) in alloc.relocations.values() {\n                 collect_miri(tcx, id, output);\n             }"}, {"sha": "5b567512a7b6fb55143ad80e837903398576cec4", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9cb052acfb25c12d5e8960f9ea53b69a2f19b0e8/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cb052acfb25c12d5e8960f9ea53b69a2f19b0e8/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=9cb052acfb25c12d5e8960f9ea53b69a2f19b0e8", "patch": "@@ -551,7 +551,12 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n         source_info: SourceInfo,\n     ) {\n         trace!(\"attepting to replace {:?} with {:?}\", rval, value);\n-        if let Err(e) = self.ecx.validate_operand(value, vec![], None, true) {\n+        if let Err(e) = self.ecx.validate_operand(\n+            value,\n+            vec![],\n+            // FIXME: is ref tracking too expensive?\n+            Some(&mut interpret::RefTracking::empty()),\n+        ) {\n             trace!(\"validation error, attempt failed: {:?}\", e);\n             return;\n         }\n@@ -562,7 +567,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n         });\n \n         if let Some(Ok(imm)) = imm {\n-            match imm {\n+            match *imm {\n                 interpret::Immediate::Scalar(ScalarMaybeUndef::Scalar(scalar)) => {\n                     *rval = Rvalue::Use(\n                         self.operand_from_scalar(scalar, value.layout.ty, source_info.span));"}, {"sha": "f082b5e5a046cfedd7a0dde7c5cdf93ad9a47cf1", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 22, "deletions": 20, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/9cb052acfb25c12d5e8960f9ea53b69a2f19b0e8/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cb052acfb25c12d5e8960f9ea53b69a2f19b0e8/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=9cb052acfb25c12d5e8960f9ea53b69a2f19b0e8", "patch": "@@ -738,27 +738,29 @@ impl<'a, 'tcx> Checker<'a, 'tcx> {\n                 qualifs[IsNotPromotable] = true;\n \n                 if self.mode.requires_const_checking() {\n-                    if let BorrowKind::Mut { .. } = kind {\n-                        let mut err = struct_span_err!(self.tcx.sess,  self.span, E0017,\n-                                                       \"references in {}s may only refer \\\n-                                                        to immutable values\", self.mode);\n-                        err.span_label(self.span, format!(\"{}s require immutable values\",\n-                                                            self.mode));\n-                        if self.tcx.sess.teach(&err.get_code().unwrap()) {\n-                            err.note(\"References in statics and constants may only refer to \\\n-                                      immutable values.\\n\\n\\\n-                                      Statics are shared everywhere, and if they refer to \\\n-                                      mutable data one might violate memory safety since \\\n-                                      holding multiple mutable references to shared data is \\\n-                                      not allowed.\\n\\n\\\n-                                      If you really want global mutable state, try using \\\n-                                      static mut or a global UnsafeCell.\");\n+                    if !self.tcx.sess.opts.debugging_opts.unleash_the_miri_inside_of_you {\n+                        if let BorrowKind::Mut { .. } = kind {\n+                            let mut err = struct_span_err!(self.tcx.sess,  self.span, E0017,\n+                                                        \"references in {}s may only refer \\\n+                                                            to immutable values\", self.mode);\n+                            err.span_label(self.span, format!(\"{}s require immutable values\",\n+                                                                self.mode));\n+                            if self.tcx.sess.teach(&err.get_code().unwrap()) {\n+                                err.note(\"References in statics and constants may only refer to \\\n+                                        immutable values.\\n\\n\\\n+                                        Statics are shared everywhere, and if they refer to \\\n+                                        mutable data one might violate memory safety since \\\n+                                        holding multiple mutable references to shared data is \\\n+                                        not allowed.\\n\\n\\\n+                                        If you really want global mutable state, try using \\\n+                                        static mut or a global UnsafeCell.\");\n+                            }\n+                            err.emit();\n+                        } else {\n+                            span_err!(self.tcx.sess, self.span, E0492,\n+                                    \"cannot borrow a constant which may contain \\\n+                                    interior mutability, create a static instead\");\n                         }\n-                        err.emit();\n-                    } else {\n-                        span_err!(self.tcx.sess, self.span, E0492,\n-                                  \"cannot borrow a constant which may contain \\\n-                                   interior mutability, create a static instead\");\n                     }\n                 }\n             } else if let BorrowKind::Mut { .. } | BorrowKind::Shared = kind {"}, {"sha": "fe742a74fffec7e49f35590cc07d05bb3a06e297", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9cb052acfb25c12d5e8960f9ea53b69a2f19b0e8/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cb052acfb25c12d5e8960f9ea53b69a2f19b0e8/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=9cb052acfb25c12d5e8960f9ea53b69a2f19b0e8", "patch": "@@ -1448,7 +1448,7 @@ fn maybe_check_static_with_link_section(tcx: TyCtxt<'_>, id: DefId, span: Span)\n     };\n     let param_env = ty::ParamEnv::reveal_all();\n     if let Ok(static_) = tcx.const_eval(param_env.and(cid)) {\n-        let alloc = if let ConstValue::ByRef(_, allocation) = static_.val {\n+        let alloc = if let ConstValue::ByRef(_, _, allocation) = static_.val {\n             allocation\n         } else {\n             bug!(\"Matching on non-ByRef static\")"}, {"sha": "5f9888053a1965e1e0c1b1c753bc59e16588131c", "filename": "src/test/ui/consts/miri_unleashed/mutable_references.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/9cb052acfb25c12d5e8960f9ea53b69a2f19b0e8/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_references.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cb052acfb25c12d5e8960f9ea53b69a2f19b0e8/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_references.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_references.rs?ref=9cb052acfb25c12d5e8960f9ea53b69a2f19b0e8", "patch": "@@ -0,0 +1,35 @@\n+// compile-flags: -Zunleash-the-miri-inside-of-you\n+#![allow(const_err)]\n+\n+use std::cell::UnsafeCell;\n+\n+// a test demonstrating what things we could allow with a smarter const qualification\n+\n+static FOO: &&mut u32 = &&mut 42;\n+\n+static BAR: &mut () = &mut ();\n+\n+struct Foo<T>(T);\n+\n+static BOO: &mut Foo<()> = &mut Foo(());\n+\n+struct Meh {\n+    x: &'static UnsafeCell<i32>,\n+}\n+\n+unsafe impl Sync for Meh {}\n+\n+static MEH: Meh = Meh {\n+    x: &UnsafeCell::new(42),\n+};\n+\n+static OH_YES: &mut i32 = &mut 42;\n+\n+fn main() {\n+    unsafe {\n+        *MEH.x.get() = 99; //~ WARN skipping const checks\n+        //~^ WARN skipping const checks\n+    }\n+    *OH_YES = 99; //~ ERROR cannot assign to `*OH_YES`, as `OH_YES` is an immutable static item\n+    //~^ WARN skipping const checks\n+}"}, {"sha": "b870aca640a0aea7abe6ca8ba8da834961415a3b", "filename": "src/test/ui/consts/miri_unleashed/mutable_references.stderr", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/9cb052acfb25c12d5e8960f9ea53b69a2f19b0e8/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_references.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9cb052acfb25c12d5e8960f9ea53b69a2f19b0e8/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_references.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_references.stderr?ref=9cb052acfb25c12d5e8960f9ea53b69a2f19b0e8", "patch": "@@ -0,0 +1,26 @@\n+warning: skipping const checks\n+  --> $DIR/mutable_references.rs:30:10\n+   |\n+LL |         *MEH.x.get() = 99;\n+   |          ^^^^^\n+\n+warning: skipping const checks\n+  --> $DIR/mutable_references.rs:30:9\n+   |\n+LL |         *MEH.x.get() = 99;\n+   |         ^^^^^^^^^^^^^^^^^\n+\n+warning: skipping const checks\n+  --> $DIR/mutable_references.rs:33:5\n+   |\n+LL |     *OH_YES = 99;\n+   |     ^^^^^^^^^^^^\n+\n+error[E0594]: cannot assign to `*OH_YES`, as `OH_YES` is an immutable static item\n+  --> $DIR/mutable_references.rs:33:5\n+   |\n+LL |     *OH_YES = 99;\n+   |     ^^^^^^^^^^^^ cannot assign\n+\n+error: aborting due to previous error\n+"}, {"sha": "4a77534c6c70ca3182551cd37552440292cf2111", "filename": "src/test/ui/consts/miri_unleashed/mutable_references_ice.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/9cb052acfb25c12d5e8960f9ea53b69a2f19b0e8/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_references_ice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cb052acfb25c12d5e8960f9ea53b69a2f19b0e8/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_references_ice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_references_ice.rs?ref=9cb052acfb25c12d5e8960f9ea53b69a2f19b0e8", "patch": "@@ -0,0 +1,28 @@\n+// compile-flags: -Zunleash-the-miri-inside-of-you\n+// failure-status: 101\n+// rustc-env:RUST_BACKTRACE=0\n+// normalize-stderr-test \"note: rustc 1.* running on .*\" -> \"note: rustc VERSION running on TARGET\"\n+// normalize-stderr-test \"note: compiler flags: .*\" -> \"note: compiler flags: FLAGS\"\n+\n+#![allow(const_err)]\n+\n+use std::cell::UnsafeCell;\n+\n+// this test ICEs to ensure that our mutability story is sound\n+\n+struct Meh {\n+    x: &'static UnsafeCell<i32>,\n+}\n+\n+unsafe impl Sync for Meh {}\n+\n+// the following will never be ok!\n+const MUH: Meh = Meh {\n+    x: &UnsafeCell::new(42),\n+};\n+\n+fn main() {\n+    unsafe {\n+        *MUH.x.get() = 99; //~ WARN skipping const checks\n+    }\n+}"}, {"sha": "ff2351e1fdc50cd2a695bee34de7df0fef36241b", "filename": "src/test/ui/consts/miri_unleashed/mutable_references_ice.stderr", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/9cb052acfb25c12d5e8960f9ea53b69a2f19b0e8/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_references_ice.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9cb052acfb25c12d5e8960f9ea53b69a2f19b0e8/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_references_ice.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_references_ice.stderr?ref=9cb052acfb25c12d5e8960f9ea53b69a2f19b0e8", "patch": "@@ -0,0 +1,21 @@\n+warning: skipping const checks\n+  --> $DIR/mutable_references_ice.rs:26:9\n+   |\n+LL |         *MUH.x.get() = 99;\n+   |         ^^^^^^^^^^^^^^^^^\n+\n+thread 'rustc' panicked at 'assertion failed: `(left != right)`\n+  left: `Const`,\n+ right: `Const`: UnsafeCells are not allowed behind references in constants. This should have been prevented statically by const qualification. If this were allowed one would be able to change a constant at one use site and other use sites may arbitrarily decide to change, too.', src/librustc_mir/interpret/intern.rs:127:17\n+note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace.\n+\n+error: internal compiler error: unexpected panic\n+\n+note: the compiler unexpectedly panicked. this is a bug.\n+\n+note: we would appreciate a bug report: https://github.com/rust-lang/rust/blob/master/CONTRIBUTING.md#bug-reports\n+\n+note: rustc VERSION running on TARGET\n+\n+note: compiler flags: FLAGS\n+"}, {"sha": "37ae45b6df7ea104f887a1bc613758fdef7dced7", "filename": "src/test/ui/consts/packed_pattern.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/9cb052acfb25c12d5e8960f9ea53b69a2f19b0e8/src%2Ftest%2Fui%2Fconsts%2Fpacked_pattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cb052acfb25c12d5e8960f9ea53b69a2f19b0e8/src%2Ftest%2Fui%2Fconsts%2Fpacked_pattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fpacked_pattern.rs?ref=9cb052acfb25c12d5e8960f9ea53b69a2f19b0e8", "patch": "@@ -0,0 +1,19 @@\n+// run-pass\n+\n+#[derive(PartialEq, Eq, Copy, Clone)]\n+#[repr(packed)]\n+struct Foo {\n+    field: (i64, u32, u32, u32),\n+}\n+\n+const FOO: Foo = Foo {\n+    field: (5, 6, 7, 8),\n+};\n+\n+fn main() {\n+    match FOO {\n+        Foo { field: (5, 6, 7, 8) } => {},\n+        FOO => unreachable!(),\n+        _ => unreachable!(),\n+    }\n+}"}, {"sha": "174161fbd9460b8a1b6ca38ff08bf2caa6752545", "filename": "src/test/ui/consts/packed_pattern2.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/9cb052acfb25c12d5e8960f9ea53b69a2f19b0e8/src%2Ftest%2Fui%2Fconsts%2Fpacked_pattern2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cb052acfb25c12d5e8960f9ea53b69a2f19b0e8/src%2Ftest%2Fui%2Fconsts%2Fpacked_pattern2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fpacked_pattern2.rs?ref=9cb052acfb25c12d5e8960f9ea53b69a2f19b0e8", "patch": "@@ -0,0 +1,27 @@\n+// run-pass\n+\n+#[derive(PartialEq, Eq, Copy, Clone)]\n+#[repr(packed)]\n+struct Foo {\n+    field: (u8, u16),\n+}\n+\n+#[derive(PartialEq, Eq, Copy, Clone)]\n+#[repr(align(2))]\n+struct Bar {\n+    a: Foo,\n+}\n+\n+const FOO: Bar = Bar {\n+    a: Foo {\n+        field: (5, 6),\n+    }\n+};\n+\n+fn main() {\n+    match FOO {\n+        Bar { a: Foo { field: (5, 6) } } => {},\n+        FOO => unreachable!(),\n+        _ => unreachable!(),\n+    }\n+}"}, {"sha": "cab60c91e165cc469afb01e7dac2cb050211d507", "filename": "src/test/ui/consts/static-raw-pointer-interning.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/9cb052acfb25c12d5e8960f9ea53b69a2f19b0e8/src%2Ftest%2Fui%2Fconsts%2Fstatic-raw-pointer-interning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cb052acfb25c12d5e8960f9ea53b69a2f19b0e8/src%2Ftest%2Fui%2Fconsts%2Fstatic-raw-pointer-interning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fstatic-raw-pointer-interning.rs?ref=9cb052acfb25c12d5e8960f9ea53b69a2f19b0e8", "patch": "@@ -0,0 +1,15 @@\n+// run-pass\n+\n+static FOO: Foo = Foo {\n+    field: &42 as *const i32,\n+};\n+\n+struct Foo {\n+    field: *const i32,\n+}\n+\n+unsafe impl Sync for Foo {}\n+\n+fn main() {\n+    assert_eq!(unsafe { *FOO.field }, 42);\n+}"}, {"sha": "2b915fd7cb3291c64a9fe316479e4fd78c1e3d83", "filename": "src/test/ui/consts/static-raw-pointer-interning2.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/9cb052acfb25c12d5e8960f9ea53b69a2f19b0e8/src%2Ftest%2Fui%2Fconsts%2Fstatic-raw-pointer-interning2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cb052acfb25c12d5e8960f9ea53b69a2f19b0e8/src%2Ftest%2Fui%2Fconsts%2Fstatic-raw-pointer-interning2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fstatic-raw-pointer-interning2.rs?ref=9cb052acfb25c12d5e8960f9ea53b69a2f19b0e8", "patch": "@@ -0,0 +1,15 @@\n+// run-pass\n+\n+static mut FOO: Foo = Foo {\n+    field: &mut [42] as *mut [i32] as *mut i32,\n+};\n+\n+struct Foo {\n+    field: *mut i32,\n+}\n+\n+unsafe impl Sync for Foo {}\n+\n+fn main() {\n+    assert_eq!(unsafe { *FOO.field = 69; *FOO.field }, 69);\n+}"}, {"sha": "16b05310b9fcb64c8291a09f0be33c64ddbbb708", "filename": "src/test/ui/consts/union_constant.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9cb052acfb25c12d5e8960f9ea53b69a2f19b0e8/src%2Ftest%2Fui%2Fconsts%2Funion_constant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cb052acfb25c12d5e8960f9ea53b69a2f19b0e8/src%2Ftest%2Fui%2Fconsts%2Funion_constant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Funion_constant.rs?ref=9cb052acfb25c12d5e8960f9ea53b69a2f19b0e8", "patch": "@@ -6,5 +6,6 @@ union Uninit {\n }\n \n const UNINIT: Uninit = Uninit { uninit: () };\n+const UNINIT2: (Uninit,) = (Uninit { uninit: () }, );\n \n fn main() {}"}]}