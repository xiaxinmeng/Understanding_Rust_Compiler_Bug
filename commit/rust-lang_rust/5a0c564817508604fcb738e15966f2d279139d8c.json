{"sha": "5a0c564817508604fcb738e15966f2d279139d8c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVhMGM1NjQ4MTc1MDg2MDRmY2I3MzhlMTU5NjZmMmQyNzkxMzlkOGM=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-04-25T03:47:06Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-04-25T03:47:06Z"}, "message": "Revert \"rustc: Use LLVM named structs for enum types\"\n\nThis reverts commit 6e909e387d1b71a8b813433ce834384ffb13fedf.", "tree": {"sha": "029aae38d673898f40fe4c469a3fb392a7b9b65f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/029aae38d673898f40fe4c469a3fb392a7b9b65f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5a0c564817508604fcb738e15966f2d279139d8c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5a0c564817508604fcb738e15966f2d279139d8c", "html_url": "https://github.com/rust-lang/rust/commit/5a0c564817508604fcb738e15966f2d279139d8c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5a0c564817508604fcb738e15966f2d279139d8c/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b88ecec08c9998c08ef8fafe5ac49c17bc99c516", "url": "https://api.github.com/repos/rust-lang/rust/commits/b88ecec08c9998c08ef8fafe5ac49c17bc99c516", "html_url": "https://github.com/rust-lang/rust/commit/b88ecec08c9998c08ef8fafe5ac49c17bc99c516"}], "stats": {"total": 275, "additions": 95, "deletions": 180}, "files": [{"sha": "e61a1e9543a0875895d01ba59eddde2b425a0602", "filename": "src/rustc/middle/trans/base.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5a0c564817508604fcb738e15966f2d279139d8c/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a0c564817508604fcb738e15966f2d279139d8c/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=5a0c564817508604fcb738e15966f2d279139d8c", "patch": "@@ -2243,8 +2243,7 @@ fn trans_var(cx: block, def: ast::def, id: ast::node_id)-> lval_maybe_callee {\n             // Nullary variant.\n             let enum_ty = node_id_type(cx, id);\n             let llenumblob = alloc_ty(cx, enum_ty);\n-            // FIXME: This pointer cast probably isn't necessary\n-            let llenumty = type_of(ccx, enum_ty);\n+            let llenumty = type_of_enum(ccx, tid, enum_ty);\n             let llenumptr = PointerCast(cx, llenumblob, T_ptr(llenumty));\n             let lldiscrimptr = GEPi(cx, llenumptr, [0, 0]);\n             let lldiscrim_gv = lookup_discriminant(ccx, vid);"}, {"sha": "7f11108edde1d0ebf74ed55758e1e57f1782392e", "filename": "src/rustc/middle/trans/type_of.rs", "status": "modified", "additions": 75, "deletions": 136, "changes": 211, "blob_url": "https://github.com/rust-lang/rust/blob/5a0c564817508604fcb738e15966f2d279139d8c/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a0c564817508604fcb738e15966f2d279139d8c/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_of.rs?ref=5a0c564817508604fcb738e15966f2d279139d8c", "patch": "@@ -7,11 +7,6 @@ import std::map::hashmap;\n \n import ty::*;\n \n-export type_of;\n-export type_of_explicit_args;\n-export type_of_fn_from_ty;\n-export type_of_fn;\n-\n fn type_of_explicit_args(cx: @crate_ctxt, inputs: [ty::arg]) -> [TypeRef] {\n     vec::map(inputs) {|arg|\n         let arg_ty = arg.ty;\n@@ -44,149 +39,93 @@ fn type_of_fn_from_ty(cx: @crate_ctxt, fty: ty::t) -> TypeRef {\n \n fn type_of(cx: @crate_ctxt, t: ty::t) -> TypeRef {\n     assert !ty::type_has_vars(t);\n-\n-    #debug(\"type_of %?: %?\", t, ty::get(t));\n-\n     // Check the cache.\n-    if cx.lltypes.contains_key(t) { ret cx.lltypes.get(t); }\n \n-    // Replace any typedef'd types with their equivalent non-typedef\n-    // type. This ensures that all LLVM nominal types that contain\n-    // Rust types are defined as the same LLVM types.  If we don't do\n-    // this then, e.g. `option<{myfield: bool}>` would be a different\n-    // type than `option<myrec>`.\n-    let t_norm = ty::normalize_ty(cx.tcx, t);\n-    let llty = if t != t_norm {\n-        type_of(cx, t_norm)\n-    } else {\n-        alt ty::get(t).struct {\n-          ty::ty_nil | ty::ty_bot { T_nil() }\n-          ty::ty_bool { T_bool() }\n-          ty::ty_int(t) { T_int_ty(cx, t) }\n-          ty::ty_uint(t) { T_uint_ty(cx, t) }\n-          ty::ty_float(t) { T_float_ty(cx, t) }\n-          ty::ty_estr(ty::vstore_uniq) |\n-          ty::ty_str { T_ptr(T_vec(cx, T_i8())) }\n-          ty::ty_enum(did, _) { type_of_enum(cx, did, t) }\n-          ty::ty_estr(ty::vstore_box) { T_ptr(T_box(cx, T_i8())) }\n-          ty::ty_evec(mt, ty::vstore_box) |\n-          ty::ty_box(mt) { T_ptr(T_box(cx, type_of(cx, mt.ty))) }\n-          ty::ty_opaque_box { T_ptr(T_box(cx, T_i8())) }\n-          ty::ty_uniq(mt) { T_ptr(type_of(cx, mt.ty)) }\n-          ty::ty_evec(mt, ty::vstore_uniq) |\n-          ty::ty_vec(mt) { T_ptr(T_vec(cx, type_of(cx, mt.ty))) }\n-          ty::ty_ptr(mt) { T_ptr(type_of(cx, mt.ty)) }\n-          ty::ty_rptr(_, mt) { T_ptr(type_of(cx, mt.ty)) }\n-\n-          ty::ty_evec(mt, ty::vstore_slice(_)) {\n-            T_struct([T_ptr(type_of(cx, mt.ty)),\n-                      T_uint_ty(cx, ast::ty_u)])\n-          }\n+    if cx.lltypes.contains_key(t) { ret cx.lltypes.get(t); }\n+    let llty = alt ty::get(t).struct {\n+      ty::ty_nil | ty::ty_bot { T_nil() }\n+      ty::ty_bool { T_bool() }\n+      ty::ty_int(t) { T_int_ty(cx, t) }\n+      ty::ty_uint(t) { T_uint_ty(cx, t) }\n+      ty::ty_float(t) { T_float_ty(cx, t) }\n+      ty::ty_estr(ty::vstore_uniq) |\n+      ty::ty_str { T_ptr(T_vec(cx, T_i8())) }\n+      ty::ty_enum(did, _) { type_of_enum(cx, did, t) }\n+      ty::ty_estr(ty::vstore_box) { T_ptr(T_box(cx, T_i8())) }\n+      ty::ty_evec(mt, ty::vstore_box) |\n+      ty::ty_box(mt) { T_ptr(T_box(cx, type_of(cx, mt.ty))) }\n+      ty::ty_opaque_box { T_ptr(T_box(cx, T_i8())) }\n+      ty::ty_uniq(mt) { T_ptr(type_of(cx, mt.ty)) }\n+      ty::ty_evec(mt, ty::vstore_uniq) |\n+      ty::ty_vec(mt) { T_ptr(T_vec(cx, type_of(cx, mt.ty))) }\n+      ty::ty_ptr(mt) { T_ptr(type_of(cx, mt.ty)) }\n+      ty::ty_rptr(_, mt) { T_ptr(type_of(cx, mt.ty)) }\n+\n+      ty::ty_evec(mt, ty::vstore_slice(_)) {\n+        T_struct([T_ptr(type_of(cx, mt.ty)),\n+                  T_uint_ty(cx, ast::ty_u)])\n+      }\n \n-          ty::ty_estr(ty::vstore_slice(_)) {\n-            T_struct([T_ptr(T_i8()),\n-                      T_uint_ty(cx, ast::ty_u)])\n-          }\n+      ty::ty_estr(ty::vstore_slice(_)) {\n+        T_struct([T_ptr(T_i8()),\n+                  T_uint_ty(cx, ast::ty_u)])\n+      }\n \n-          ty::ty_estr(ty::vstore_fixed(n)) {\n-            T_array(T_i8(), n + 1u /* +1 for trailing null */)\n-          }\n+      ty::ty_estr(ty::vstore_fixed(n)) {\n+        T_array(T_i8(), n + 1u /* +1 for trailing null */)\n+      }\n \n-          ty::ty_evec(mt, ty::vstore_fixed(n)) {\n-            T_array(type_of(cx, mt.ty), n)\n-          }\n+      ty::ty_evec(mt, ty::vstore_fixed(n)) {\n+        T_array(type_of(cx, mt.ty), n)\n+      }\n \n-          ty::ty_rec(fields) {\n-            let mut tys: [TypeRef] = [];\n-            for vec::each(fields) {|f|\n-                let mt_ty = f.mt.ty;\n-                tys += [type_of(cx, mt_ty)];\n-            }\n-            T_struct(tys)\n-          }\n-          ty::ty_fn(_) { T_fn_pair(cx, type_of_fn_from_ty(cx, t)) }\n-          ty::ty_iface(_, _) { T_opaque_iface(cx) }\n-          ty::ty_res(_, sub, substs) {\n-            let sub1 = ty::subst(cx.tcx, substs, sub);\n-            ret T_struct([T_i8(), type_of(cx, sub1)]);\n-          }\n-          ty::ty_param(_, _) { T_typaram(cx.tn) }\n-          ty::ty_type { T_ptr(cx.tydesc_type) }\n-          ty::ty_tup(elts) {\n-            let mut tys = [];\n-            for vec::each(elts) {|elt|\n-                tys += [type_of(cx, elt)];\n-            }\n-            T_struct(tys)\n-          }\n-          ty::ty_opaque_closure_ptr(_) { T_opaque_box_ptr(cx) }\n-          ty::ty_constr(subt,_) { type_of(cx, subt) }\n-          ty::ty_class(did, ts) {\n-            // only instance vars are record fields at runtime\n-            let fields = lookup_class_fields(cx.tcx, did);\n-            let tys = vec::map(fields) {|f|\n-                let t = ty::lookup_field_type(cx.tcx, did, f.id, ts);\n-                type_of(cx, t)\n-            };\n-            T_struct(tys)\n-          }\n-          ty::ty_self(_) { cx.tcx.sess.unimpl(\"type_of: ty_self \\\n-                                               not implemented\"); }\n-          ty::ty_var(_) { cx.tcx.sess.bug(\"type_of shouldn't see a ty_var\"); }\n+      ty::ty_rec(fields) {\n+        let mut tys: [TypeRef] = [];\n+        for vec::each(fields) {|f|\n+            let mt_ty = f.mt.ty;\n+            tys += [type_of(cx, mt_ty)];\n         }\n+        T_struct(tys)\n+      }\n+      ty::ty_fn(_) { T_fn_pair(cx, type_of_fn_from_ty(cx, t)) }\n+      ty::ty_iface(_, _) { T_opaque_iface(cx) }\n+      ty::ty_res(_, sub, substs) {\n+        let sub1 = ty::subst(cx.tcx, substs, sub);\n+        ret T_struct([T_i8(), type_of(cx, sub1)]);\n+      }\n+      ty::ty_param(_, _) { T_typaram(cx.tn) }\n+      ty::ty_type { T_ptr(cx.tydesc_type) }\n+      ty::ty_tup(elts) {\n+        let mut tys = [];\n+        for vec::each(elts) {|elt|\n+            tys += [type_of(cx, elt)];\n+        }\n+        T_struct(tys)\n+      }\n+      ty::ty_opaque_closure_ptr(_) { T_opaque_box_ptr(cx) }\n+      ty::ty_constr(subt,_) { type_of(cx, subt) }\n+      ty::ty_class(did, ts) {\n+        // only instance vars are record fields at runtime\n+        let fields = lookup_class_fields(cx.tcx, did);\n+        let tys = vec::map(fields) {|f|\n+            let t = ty::lookup_field_type(cx.tcx, did, f.id, ts);\n+            type_of(cx, t)\n+        };\n+        T_struct(tys)\n+      }\n+      ty::ty_self(_) { cx.tcx.sess.unimpl(\"type_of: ty_self \\\n+                         not implemented\"); }\n+      ty::ty_var(_) { cx.tcx.sess.bug(\"type_of shouldn't see a ty_var\"); }\n     };\n     cx.lltypes.insert(t, llty);\n     ret llty;\n }\n \n-// This should only be called from type_of, above, because it\n-// creates new llvm named struct types lazily that are then\n-// cached by type_of\n fn type_of_enum(cx: @crate_ctxt, did: ast::def_id, t: ty::t)\n     -> TypeRef {\n-\n-    #debug(\"type_of_enum %?: %?\", t, ty::get(t));\n-\n-    // Every enum type has a unique name. When we find our roots\n-    // for GC and unwinding we will use this name to rediscover\n-    // the Rust type\n-    let name = llvm_type_name(cx, t);\n-\n-    let named_llty = common::T_named_struct(name);\n-\n-    let lltys = {\n-        let degen = (*ty::enum_variants(cx.tcx, did)).len() == 1u;\n-        let size = shape::static_size_of_enum(cx, t);\n-        if !degen {\n-            [T_enum_variant(cx), T_array(T_i8(), size)]\n-        }\n-        else if size == 0u {\n-            [T_enum_variant(cx)]\n-        }\n-        else {\n-            [T_array(T_i8(), size)]\n-        }\n-    };\n-\n-    common::set_struct_body(named_llty, lltys);\n-    ret named_llty;\n+    let degen = (*ty::enum_variants(cx.tcx, did)).len() == 1u;\n+    let size = shape::static_size_of_enum(cx, t);\n+    if !degen { T_enum(cx, size) }\n+    else if size == 0u { T_struct([T_enum_variant(cx)]) }\n+    else { T_array(T_i8(), size) }\n }\n-\n-fn llvm_type_name(cx: @crate_ctxt, t: ty::t) -> str {\n-    let (name, did, tps) = alt check ty::get(t).struct {\n-      ty::ty_enum(did, substs) {\n-        (\"enum\", did, substs.tps)\n-      }\n-    };\n-    ret #fmt(\n-        \"%s %s[#%d]\",\n-        name,\n-        util::ppaux::parameterized(\n-            cx.tcx,\n-            ty::item_path_str(cx.tcx, did),\n-            none,\n-            tps),\n-        did.crate\n-    );\n-}\n-"}, {"sha": "68da6e6d734f8d6f2146a846a74be4ed2793b430", "filename": "src/rustc/middle/ty.rs", "status": "modified", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/5a0c564817508604fcb738e15966f2d279139d8c/src%2Frustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a0c564817508604fcb738e15966f2d279139d8c/src%2Frustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fty.rs?ref=5a0c564817508604fcb738e15966f2d279139d8c", "patch": "@@ -149,7 +149,6 @@ export ast_ty_to_ty_cache_entry;\n export atttce_unresolved, atttce_resolved;\n export mach_sty;\n export ty_sort_str;\n-export normalize_ty;\n \n // Data types\n \n@@ -2675,27 +2674,6 @@ fn ty_params_to_tys(tcx: ty::ctxt, tps: [ast::ty_param]) -> [t] {\n                 ty::mk_param(tcx, i, ast_util::local_def(tps[i].id))\n         })\n }\n-\n-#[doc = \"\n-Returns an equivalent type with all the typedefs and self regions removed\n-\"]\n-fn normalize_ty(cx: ctxt, t: t) -> t {\n-    let t = alt get(t).struct {\n-        ty_enum(did, r) {\n-            alt r.self_r {\n-              some(_) {\n-                // This enum has a self region. Get rid of it\n-                mk_enum(cx, did, {self_r: none, tps: r.tps })\n-              }\n-              none { t }\n-            }\n-        }\n-        _ { t }\n-    };\n-    let sty = fold_sty(get(t).struct) {|t| normalize_ty(cx, t) };\n-    mk_t(cx, sty)\n-}\n-\n // Local Variables:\n // mode: rust\n // fill-column: 78;"}, {"sha": "30e20883e529a6c21bf56f862ede87ca5bfff3a0", "filename": "src/rustc/util/ppaux.rs", "status": "modified", "additions": 19, "deletions": 20, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/5a0c564817508604fcb738e15966f2d279139d8c/src%2Frustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a0c564817508604fcb738e15966f2d279139d8c/src%2Frustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Futil%2Fppaux.rs?ref=5a0c564817508604fcb738e15966f2d279139d8c", "patch": "@@ -128,6 +128,25 @@ fn ty_to_str(cx: ctxt, typ: t) -> str {\n     fn field_to_str(cx: ctxt, f: field) -> str {\n         ret f.ident + \": \" + mt_to_str(cx, f.mt);\n     }\n+    fn parameterized(cx: ctxt,\n+                     base: str,\n+                     self_r: option<ty::region>,\n+                     tps: [ty::t]) -> str {\n+\n+        let r_str = alt self_r {\n+          none { \"\" }\n+          some(r) {\n+            #fmt[\"/%s\", region_to_str(cx, r)]\n+          }\n+        };\n+\n+        if vec::len(tps) > 0u {\n+            let strs = vec::map(tps, {|t| ty_to_str(cx, t)});\n+            #fmt[\"%s%s<%s>\", base, r_str, str::connect(strs, \",\")]\n+        } else {\n+            #fmt[\"%s%s\", base, r_str]\n+        }\n+    }\n \n     // if there is an id, print that instead of the structural type:\n     alt ty::type_def_id(typ) {\n@@ -214,26 +233,6 @@ fn ty_to_str(cx: ctxt, typ: t) -> str {\n     }\n }\n \n-fn parameterized(cx: ctxt,\n-                 base: str,\n-                 self_r: option<ty::region>,\n-                 tps: [ty::t]) -> str {\n-\n-    let r_str = alt self_r {\n-      none { \"\" }\n-      some(r) {\n-        #fmt[\"/%s\", region_to_str(cx, r)]\n-      }\n-    };\n-\n-    if vec::len(tps) > 0u {\n-        let strs = vec::map(tps, {|t| ty_to_str(cx, t)});\n-        #fmt[\"%s%s<%s>\", base, r_str, str::connect(strs, \",\")]\n-    } else {\n-        #fmt[\"%s%s\", base, r_str]\n-    }\n-}\n-\n fn ty_to_short_str(cx: ctxt, typ: t) -> str {\n     let mut s = encoder::encoded_ty(cx, typ);\n     if str::len(s) >= 32u { s = str::slice(s, 0u, 32u); }"}]}