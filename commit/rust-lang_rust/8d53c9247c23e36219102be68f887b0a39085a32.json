{"sha": "8d53c9247c23e36219102be68f887b0a39085a32", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhkNTNjOTI0N2MyM2UzNjIxOTEwMmJlNjhmODg3YjBhMzkwODVhMzI=", "commit": {"author": {"name": "Denys Zariaiev", "email": "denys.zariaiev@gmail.com", "date": "2019-01-28T00:16:59Z"}, "committer": {"name": "Denys Zariaiev", "email": "denys.zariaiev@gmail.com", "date": "2019-01-28T00:16:59Z"}, "message": "SymbolPathBuffer shallow refactoring", "tree": {"sha": "40e55a8043249067cd47d35720a2f73a7cdb41b4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/40e55a8043249067cd47d35720a2f73a7cdb41b4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8d53c9247c23e36219102be68f887b0a39085a32", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8d53c9247c23e36219102be68f887b0a39085a32", "html_url": "https://github.com/rust-lang/rust/commit/8d53c9247c23e36219102be68f887b0a39085a32", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8d53c9247c23e36219102be68f887b0a39085a32/comments", "author": {"login": "denzp", "id": 747869, "node_id": "MDQ6VXNlcjc0Nzg2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/747869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/denzp", "html_url": "https://github.com/denzp", "followers_url": "https://api.github.com/users/denzp/followers", "following_url": "https://api.github.com/users/denzp/following{/other_user}", "gists_url": "https://api.github.com/users/denzp/gists{/gist_id}", "starred_url": "https://api.github.com/users/denzp/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/denzp/subscriptions", "organizations_url": "https://api.github.com/users/denzp/orgs", "repos_url": "https://api.github.com/users/denzp/repos", "events_url": "https://api.github.com/users/denzp/events{/privacy}", "received_events_url": "https://api.github.com/users/denzp/received_events", "type": "User", "site_admin": false}, "committer": {"login": "denzp", "id": 747869, "node_id": "MDQ6VXNlcjc0Nzg2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/747869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/denzp", "html_url": "https://github.com/denzp", "followers_url": "https://api.github.com/users/denzp/followers", "following_url": "https://api.github.com/users/denzp/following{/other_user}", "gists_url": "https://api.github.com/users/denzp/gists{/gist_id}", "starred_url": "https://api.github.com/users/denzp/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/denzp/subscriptions", "organizations_url": "https://api.github.com/users/denzp/orgs", "repos_url": "https://api.github.com/users/denzp/repos", "events_url": "https://api.github.com/users/denzp/events{/privacy}", "received_events_url": "https://api.github.com/users/denzp/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ceacde31aeac4732a970ba253a99502b5d9f5280", "url": "https://api.github.com/repos/rust-lang/rust/commits/ceacde31aeac4732a970ba253a99502b5d9f5280", "html_url": "https://github.com/rust-lang/rust/commit/ceacde31aeac4732a970ba253a99502b5d9f5280"}], "stats": {"total": 156, "additions": 76, "deletions": 80}, "files": [{"sha": "3238a0b10bfd6d40fcb939f83b989db7e451466e", "filename": "src/librustc_codegen_utils/symbol_names.rs", "status": "modified", "additions": 76, "deletions": 80, "changes": 156, "blob_url": "https://github.com/rust-lang/rust/blob/8d53c9247c23e36219102be68f887b0a39085a32/src%2Flibrustc_codegen_utils%2Fsymbol_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d53c9247c23e36219102be68f887b0a39085a32/src%2Flibrustc_codegen_utils%2Fsymbol_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_utils%2Fsymbol_names.rs?ref=8d53c9247c23e36219102be68f887b0a39085a32", "patch": "@@ -103,7 +103,7 @@ use rustc_mir::monomorphize::Instance;\n \n use syntax_pos::symbol::Symbol;\n \n-use std::fmt::{self, Write};\n+use std::fmt::Write;\n use std::mem::discriminant;\n \n pub fn provide(providers: &mut Providers) {\n@@ -339,28 +339,29 @@ fn compute_symbol_name<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, instance: Instance\n //\n // To be able to work on all platforms and get *some* reasonable output, we\n // use C++ name-mangling.\n-struct SymbolPathBuffer<'a, 'tcx> {\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+#[derive(Debug)]\n+struct SymbolPathBuffer {\n     result: String,\n     temp_buf: String,\n+    strict_naming: bool,\n }\n \n-impl SymbolPathBuffer<'a, 'tcx> {\n-    fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Self {\n+impl SymbolPathBuffer {\n+    fn new(tcx: TyCtxt<'_, '_, '_>) -> Self {\n         let mut result = SymbolPathBuffer {\n             result: String::with_capacity(64),\n             temp_buf: String::with_capacity(16),\n-            tcx,\n+            strict_naming: tcx.has_strict_asm_symbol_naming(),\n         };\n         result.result.push_str(\"_ZN\"); // _Z == Begin name-sequence, N == nested\n         result\n     }\n \n-    fn from_interned(symbol: ty::SymbolName, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Self {\n+    fn from_interned(symbol: ty::SymbolName, tcx: TyCtxt<'_, '_, '_>) -> Self {\n         let mut result = SymbolPathBuffer {\n             result: String::with_capacity(64),\n             temp_buf: String::with_capacity(16),\n-            tcx,\n+            strict_naming: tcx.has_strict_asm_symbol_naming(),\n         };\n         result.result.push_str(&symbol.as_str());\n         result\n@@ -377,93 +378,88 @@ impl SymbolPathBuffer<'a, 'tcx> {\n         let _ = write!(self.result, \"17h{:016x}E\", hash);\n         self.result\n     }\n-}\n \n-impl ItemPathBuffer for SymbolPathBuffer<'a, 'tcx> {\n-    fn root_mode(&self) -> &RootMode {\n-        const ABSOLUTE: &RootMode = &RootMode::Absolute;\n-        ABSOLUTE\n-    }\n-\n-    fn push(&mut self, text: &str) {\n+    // Name sanitation. LLVM will happily accept identifiers with weird names, but\n+    // gas doesn't!\n+    // gas accepts the following characters in symbols: a-z, A-Z, 0-9, ., _, $\n+    // NVPTX assembly has more strict naming rules than gas, so additionally, dots\n+    // are replaced with '$' there.\n+    fn sanitize_and_append(&mut self, s: &str) {\n         self.temp_buf.clear();\n-        let need_underscore = sanitize(&mut self.temp_buf, text, self.tcx);\n+\n+        for c in s.chars() {\n+            match c {\n+                // Escape these with $ sequences\n+                '@' => self.temp_buf.push_str(\"$SP$\"),\n+                '*' => self.temp_buf.push_str(\"$BP$\"),\n+                '&' => self.temp_buf.push_str(\"$RF$\"),\n+                '<' => self.temp_buf.push_str(\"$LT$\"),\n+                '>' => self.temp_buf.push_str(\"$GT$\"),\n+                '(' => self.temp_buf.push_str(\"$LP$\"),\n+                ')' => self.temp_buf.push_str(\"$RP$\"),\n+                ',' => self.temp_buf.push_str(\"$C$\"),\n+\n+                '-' | ':' => if self.strict_naming {\n+                    // NVPTX doesn't support these characters in symbol names.\n+                    self.temp_buf.push('$')\n+                }\n+                else {\n+                    // '.' doesn't occur in types and functions, so reuse it\n+                    // for ':' and '-'\n+                    self.temp_buf.push('.')\n+                },\n+\n+                '.' => if self.strict_naming {\n+                    self.temp_buf.push('$')\n+                }\n+                else {\n+                    self.temp_buf.push('.')\n+                },\n+\n+                // These are legal symbols\n+                'a'..='z' | 'A'..='Z' | '0'..='9' | '_' | '$' => self.temp_buf.push(c),\n+\n+                _ => {\n+                    self.temp_buf.push('$');\n+                    for c in c.escape_unicode().skip(1) {\n+                        match c {\n+                            '{' => {}\n+                            '}' => self.temp_buf.push('$'),\n+                            c => self.temp_buf.push(c),\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        let need_underscore = {\n+            // Underscore-qualify anything that didn't start as an ident.\n+            !self.temp_buf.is_empty()\n+                && self.temp_buf.as_bytes()[0] != '_' as u8\n+                && !(self.temp_buf.as_bytes()[0] as char).is_xid_start()\n+        };\n+\n         let _ = write!(\n             self.result,\n             \"{}\",\n             self.temp_buf.len() + (need_underscore as usize)\n         );\n+\n         if need_underscore {\n             self.result.push('_');\n         }\n+\n         self.result.push_str(&self.temp_buf);\n     }\n }\n \n-// Manual Debug implementation to omit non-Debug `tcx` field.\n-impl fmt::Debug for SymbolPathBuffer<'_, '_> {\n-    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n-        fmt.debug_struct(\"SymbolPathBuffer\")\n-            .field(\"result\", &self.result)\n-            .field(\"temp_buf\", &self.temp_buf)\n-            .finish()\n+impl ItemPathBuffer for SymbolPathBuffer {\n+    fn root_mode(&self) -> &RootMode {\n+        const ABSOLUTE: &RootMode = &RootMode::Absolute;\n+        ABSOLUTE\n     }\n-}\n-\n-// Name sanitation. LLVM will happily accept identifiers with weird names, but\n-// gas doesn't!\n-// gas accepts the following characters in symbols: a-z, A-Z, 0-9, ., _, $\n-// NVPTX assembly has more strict naming rules than gas, so additionally, dots\n-// are replaced with '$' there.\n-//\n-// returns true if an underscore must be added at the start\n-pub fn sanitize(result: &mut String, s: &str, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> bool {\n-    for c in s.chars() {\n-        match c {\n-            // Escape these with $ sequences\n-            '@' => result.push_str(\"$SP$\"),\n-            '*' => result.push_str(\"$BP$\"),\n-            '&' => result.push_str(\"$RF$\"),\n-            '<' => result.push_str(\"$LT$\"),\n-            '>' => result.push_str(\"$GT$\"),\n-            '(' => result.push_str(\"$LP$\"),\n-            ')' => result.push_str(\"$RP$\"),\n-            ',' => result.push_str(\"$C$\"),\n-\n-            '-' | ':' => if tcx.has_strict_asm_symbol_naming() {\n-                // NVPTX doesn't support these characters in symbol names.\n-                result.push('$')\n-            }\n-            else {\n-                // '.' doesn't occur in types and functions, so reuse it\n-                // for ':' and '-'\n-                result.push('.')\n-            },\n-\n-            '.' => if tcx.has_strict_asm_symbol_naming() {\n-                result.push('$')\n-            }\n-            else {\n-                result.push('.')\n-            },\n-\n-            // These are legal symbols\n-            'a'..='z' | 'A'..='Z' | '0'..='9' | '_' | '$' => result.push(c),\n \n-            _ => {\n-                result.push('$');\n-                for c in c.escape_unicode().skip(1) {\n-                    match c {\n-                        '{' => {}\n-                        '}' => result.push('$'),\n-                        c => result.push(c),\n-                    }\n-                }\n-            }\n-        }\n+    fn push(&mut self, text: &str) {\n+        self.sanitize_and_append(text);\n     }\n-\n-    // Underscore-qualify anything that didn't start as an ident.\n-    !result.is_empty() && result.as_bytes()[0] != '_' as u8\n-        && !(result.as_bytes()[0] as char).is_xid_start()\n }"}]}