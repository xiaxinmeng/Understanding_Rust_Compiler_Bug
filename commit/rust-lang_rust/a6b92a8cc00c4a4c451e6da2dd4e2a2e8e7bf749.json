{"sha": "a6b92a8cc00c4a4c451e6da2dd4e2a2e8e7bf749", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE2YjkyYThjYzAwYzRhNGM0NTFlNmRhMmRkNGUyYTJlOGU3YmY3NDk=", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-05-28T18:46:09Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-05-28T18:46:09Z"}, "message": "simplify", "tree": {"sha": "8eb442f48e85cb17258b44d4339c98c51178bb18", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8eb442f48e85cb17258b44d4339c98c51178bb18"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a6b92a8cc00c4a4c451e6da2dd4e2a2e8e7bf749", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a6b92a8cc00c4a4c451e6da2dd4e2a2e8e7bf749", "html_url": "https://github.com/rust-lang/rust/commit/a6b92a8cc00c4a4c451e6da2dd4e2a2e8e7bf749", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a6b92a8cc00c4a4c451e6da2dd4e2a2e8e7bf749/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d5f7b2e52a41a7d3b841f4d0e2225eb703f6a50a", "url": "https://api.github.com/repos/rust-lang/rust/commits/d5f7b2e52a41a7d3b841f4d0e2225eb703f6a50a", "html_url": "https://github.com/rust-lang/rust/commit/d5f7b2e52a41a7d3b841f4d0e2225eb703f6a50a"}], "stats": {"total": 283, "additions": 140, "deletions": 143}, "files": [{"sha": "69ceba735617b9e0eaf93d6b3bd11e4d1f7150ae", "filename": "crates/base_db/src/fixture.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a6b92a8cc00c4a4c451e6da2dd4e2a2e8e7bf749/crates%2Fbase_db%2Fsrc%2Ffixture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6b92a8cc00c4a4c451e6da2dd4e2a2e8e7bf749/crates%2Fbase_db%2Fsrc%2Ffixture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fbase_db%2Fsrc%2Ffixture.rs?ref=a6b92a8cc00c4a4c451e6da2dd4e2a2e8e7bf749", "patch": "@@ -34,19 +34,13 @@ pub trait WithFixture: Default + SourceDatabaseExt + 'static {\n \n     fn with_position(ra_fixture: &str) -> (Self, FilePosition) {\n         let (db, file_id, range_or_offset) = Self::with_range_or_offset(ra_fixture);\n-        let offset = match range_or_offset {\n-            RangeOrOffset::Range(_) => panic!(\"Expected a cursor position, got a range instead\"),\n-            RangeOrOffset::Offset(it) => it,\n-        };\n+        let offset = range_or_offset.expect_offset();\n         (db, FilePosition { file_id, offset })\n     }\n \n     fn with_range(ra_fixture: &str) -> (Self, FileRange) {\n         let (db, file_id, range_or_offset) = Self::with_range_or_offset(ra_fixture);\n-        let range = match range_or_offset {\n-            RangeOrOffset::Range(it) => it,\n-            RangeOrOffset::Offset(_) => panic!(\"Expected a cursor range, got a position instead\"),\n-        };\n+        let range = range_or_offset.expect_range();\n         (db, FileRange { file_id, range })\n     }\n "}, {"sha": "6780af61721a8153abf2fcbe89b69868cd5c50a1", "filename": "crates/ide/src/fixture.rs", "status": "modified", "additions": 4, "deletions": 13, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/a6b92a8cc00c4a4c451e6da2dd4e2a2e8e7bf749/crates%2Fide%2Fsrc%2Ffixture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6b92a8cc00c4a4c451e6da2dd4e2a2e8e7bf749/crates%2Fide%2Fsrc%2Ffixture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Ffixture.rs?ref=a6b92a8cc00c4a4c451e6da2dd4e2a2e8e7bf749", "patch": "@@ -1,7 +1,7 @@\n //! Utilities for creating `Analysis` instances for tests.\n use ide_db::base_db::fixture::ChangeFixture;\n use syntax::{TextRange, TextSize};\n-use test_utils::{extract_annotations, RangeOrOffset};\n+use test_utils::extract_annotations;\n \n use crate::{Analysis, AnalysisHost, FileId, FilePosition, FileRange};\n \n@@ -27,10 +27,7 @@ pub(crate) fn position(ra_fixture: &str) -> (Analysis, FilePosition) {\n     let change_fixture = ChangeFixture::parse(ra_fixture);\n     host.db.apply_change(change_fixture.change);\n     let (file_id, range_or_offset) = change_fixture.file_position.expect(\"expected a marker ($0)\");\n-    let offset = match range_or_offset {\n-        RangeOrOffset::Range(_) => panic!(),\n-        RangeOrOffset::Offset(it) => it,\n-    };\n+    let offset = range_or_offset.expect_offset();\n     (host.analysis(), FilePosition { file_id, offset })\n }\n \n@@ -40,10 +37,7 @@ pub(crate) fn range(ra_fixture: &str) -> (Analysis, FileRange) {\n     let change_fixture = ChangeFixture::parse(ra_fixture);\n     host.db.apply_change(change_fixture.change);\n     let (file_id, range_or_offset) = change_fixture.file_position.expect(\"expected a marker ($0)\");\n-    let range = match range_or_offset {\n-        RangeOrOffset::Range(it) => it,\n-        RangeOrOffset::Offset(_) => panic!(),\n-    };\n+    let range = range_or_offset.expect_range();\n     (host.analysis(), FileRange { file_id, range })\n }\n \n@@ -53,10 +47,7 @@ pub(crate) fn annotations(ra_fixture: &str) -> (Analysis, FilePosition, Vec<(Fil\n     let change_fixture = ChangeFixture::parse(ra_fixture);\n     host.db.apply_change(change_fixture.change);\n     let (file_id, range_or_offset) = change_fixture.file_position.expect(\"expected a marker ($0)\");\n-    let offset = match range_or_offset {\n-        RangeOrOffset::Range(_) => panic!(),\n-        RangeOrOffset::Offset(it) => it,\n-    };\n+    let offset = range_or_offset.expect_offset();\n \n     let annotations = change_fixture\n         .files"}, {"sha": "662c389fe819c3e8abb8c3970730a2e551f4455c", "filename": "crates/ide_completion/src/completions/keyword.rs", "status": "modified", "additions": 95, "deletions": 97, "changes": 192, "blob_url": "https://github.com/rust-lang/rust/blob/a6b92a8cc00c4a4c451e6da2dd4e2a2e8e7bf749/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fkeyword.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6b92a8cc00c4a4c451e6da2dd4e2a2e8e7bf749/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fkeyword.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fkeyword.rs?ref=a6b92a8cc00c4a4c451e6da2dd4e2a2e8e7bf749", "patch": "@@ -39,6 +39,8 @@ pub(crate) fn complete_use_tree_keyword(acc: &mut Completions, ctx: &CompletionC\n     }\n }\n \n+trait Foo {}\n+\n pub(crate) fn complete_expr_keyword(acc: &mut Completions, ctx: &CompletionContext) {\n     if ctx.token.kind() == SyntaxKind::COMMENT {\n         cov_mark::hit!(no_keyword_completion_in_comments);\n@@ -48,91 +50,92 @@ pub(crate) fn complete_expr_keyword(acc: &mut Completions, ctx: &CompletionConte\n         cov_mark::hit!(no_keyword_completion_in_record_lit);\n         return;\n     }\n+    let mut add_keyword = |kw, snippet| add_keyword(ctx, acc, kw, snippet);\n \n     let expects_assoc_item = ctx.expects_assoc_item();\n     let has_block_expr_parent = ctx.has_block_expr_parent();\n     let expects_item = ctx.expects_item();\n+\n     if ctx.has_impl_or_trait_prev_sibling() {\n-        add_keyword(ctx, acc, \"where\", \"where \");\n+        // FIXME this also incorrectly shows up after a complete trait/impl\n+        add_keyword(\"where\", \"where \");\n         return;\n     }\n     if ctx.previous_token_is(T![unsafe]) {\n-        if expects_item || has_block_expr_parent {\n-            add_keyword(ctx, acc, \"fn\", \"fn $1($2) {\\n    $0\\n}\")\n+        if expects_item || expects_assoc_item || has_block_expr_parent {\n+            add_keyword(\"fn\", \"fn $1($2) {\\n    $0\\n}\")\n         }\n \n         if expects_item || has_block_expr_parent {\n-            add_keyword(ctx, acc, \"trait\", \"trait $1 {\\n    $0\\n}\");\n-            add_keyword(ctx, acc, \"impl\", \"impl $1 {\\n    $0\\n}\");\n+            add_keyword(\"trait\", \"trait $1 {\\n    $0\\n}\");\n+            add_keyword(\"impl\", \"impl $1 {\\n    $0\\n}\");\n         }\n \n         return;\n     }\n+\n+    if expects_item || ctx.expects_non_trait_assoc_item() || ctx.expect_record_field() {\n+        add_keyword(\"pub(crate)\", \"pub(crate) \");\n+        add_keyword(\"pub\", \"pub \");\n+    }\n+\n+    if expects_item || expects_assoc_item || has_block_expr_parent || ctx.is_match_arm {\n+        add_keyword(\"unsafe\", \"unsafe \");\n+    }\n+\n     if expects_item || expects_assoc_item || has_block_expr_parent {\n-        add_keyword(ctx, acc, \"fn\", \"fn $1($2) {\\n    $0\\n}\");\n+        add_keyword(\"fn\", \"fn $1($2) {\\n    $0\\n}\");\n+        add_keyword(\"const\", \"const $0\");\n+        add_keyword(\"type\", \"type $0\");\n     }\n+\n     if expects_item || has_block_expr_parent {\n-        add_keyword(ctx, acc, \"use\", \"use \");\n-        add_keyword(ctx, acc, \"impl\", \"impl $1 {\\n    $0\\n}\");\n-        add_keyword(ctx, acc, \"trait\", \"trait $1 {\\n    $0\\n}\");\n+        add_keyword(\"use\", \"use $0\");\n+        add_keyword(\"impl\", \"impl $1 {\\n    $0\\n}\");\n+        add_keyword(\"trait\", \"trait $1 {\\n    $0\\n}\");\n+        add_keyword(\"static\", \"static $0\");\n+        add_keyword(\"extern\", \"extern $0\");\n+        add_keyword(\"mod\", \"mod $0\");\n     }\n \n     if expects_item {\n-        add_keyword(ctx, acc, \"enum\", \"enum $1 {\\n    $0\\n}\");\n-        add_keyword(ctx, acc, \"struct\", \"struct $0\");\n-        add_keyword(ctx, acc, \"union\", \"union $1 {\\n    $0\\n}\");\n+        add_keyword(\"enum\", \"enum $1 {\\n    $0\\n}\");\n+        add_keyword(\"struct\", \"struct $0\");\n+        add_keyword(\"union\", \"union $1 {\\n    $0\\n}\");\n     }\n \n-    if ctx.is_expr {\n-        add_keyword(ctx, acc, \"match\", \"match $1 {\\n    $0\\n}\");\n-        add_keyword(ctx, acc, \"while\", \"while $1 {\\n    $0\\n}\");\n-        add_keyword(ctx, acc, \"while let\", \"while let $1 = $2 {\\n    $0\\n}\");\n-        add_keyword(ctx, acc, \"loop\", \"loop {\\n    $0\\n}\");\n-        add_keyword(ctx, acc, \"if\", \"if $1 {\\n    $0\\n}\");\n-        add_keyword(ctx, acc, \"if let\", \"if let $1 = $2 {\\n    $0\\n}\");\n-        add_keyword(ctx, acc, \"for\", \"for $1 in $2 {\\n    $0\\n}\");\n+    if ctx.expects_expression() {\n+        add_keyword(\"match\", \"match $1 {\\n    $0\\n}\");\n+        add_keyword(\"while\", \"while $1 {\\n    $0\\n}\");\n+        add_keyword(\"while let\", \"while let $1 = $2 {\\n    $0\\n}\");\n+        add_keyword(\"loop\", \"loop {\\n    $0\\n}\");\n+        add_keyword(\"if\", \"if $1 {\\n    $0\\n}\");\n+        add_keyword(\"if let\", \"if let $1 = $2 {\\n    $0\\n}\");\n+        add_keyword(\"for\", \"for $1 in $2 {\\n    $0\\n}\");\n     }\n \n     if ctx.previous_token_is(T![if]) || ctx.previous_token_is(T![while]) || has_block_expr_parent {\n-        add_keyword(ctx, acc, \"let\", \"let \");\n+        add_keyword(\"let\", \"let \");\n     }\n \n     if ctx.after_if {\n-        add_keyword(ctx, acc, \"else\", \"else {\\n    $0\\n}\");\n-        add_keyword(ctx, acc, \"else if\", \"else if $1 {\\n    $0\\n}\");\n-    }\n-    if expects_item || has_block_expr_parent {\n-        add_keyword(ctx, acc, \"mod\", \"mod $0\");\n+        add_keyword(\"else\", \"else {\\n    $0\\n}\");\n+        add_keyword(\"else if\", \"else if $1 {\\n    $0\\n}\");\n     }\n+\n     if ctx.expects_ident_pat_or_ref_expr() {\n-        add_keyword(ctx, acc, \"mut\", \"mut \");\n-    }\n-    if expects_item || expects_assoc_item || has_block_expr_parent {\n-        add_keyword(ctx, acc, \"const\", \"const \");\n-        add_keyword(ctx, acc, \"type\", \"type \");\n-    }\n-    if expects_item || has_block_expr_parent {\n-        add_keyword(ctx, acc, \"static\", \"static \");\n-    };\n-    if expects_item || has_block_expr_parent {\n-        add_keyword(ctx, acc, \"extern\", \"extern \");\n-    }\n-    if expects_item || expects_assoc_item || has_block_expr_parent || ctx.is_match_arm {\n-        add_keyword(ctx, acc, \"unsafe\", \"unsafe \");\n+        add_keyword(\"mut\", \"mut \");\n     }\n+\n     if ctx.in_loop_body {\n         if ctx.can_be_stmt {\n-            add_keyword(ctx, acc, \"continue\", \"continue;\");\n-            add_keyword(ctx, acc, \"break\", \"break;\");\n+            add_keyword(\"continue\", \"continue;\");\n+            add_keyword(\"break\", \"break;\");\n         } else {\n-            add_keyword(ctx, acc, \"continue\", \"continue\");\n-            add_keyword(ctx, acc, \"break\", \"break\");\n+            add_keyword(\"continue\", \"continue\");\n+            add_keyword(\"break\", \"break\");\n         }\n     }\n-    if expects_item || ctx.expects_non_trait_assoc_item() || ctx.expect_record_field() {\n-        add_keyword(ctx, acc, \"pub(crate)\", \"pub(crate) \");\n-        add_keyword(ctx, acc, \"pub\", \"pub \");\n-    }\n \n     if !ctx.is_trivial_path {\n         return;\n@@ -143,8 +146,6 @@ pub(crate) fn complete_expr_keyword(acc: &mut Completions, ctx: &CompletionConte\n     };\n \n     add_keyword(\n-        ctx,\n-        acc,\n         \"return\",\n         match (ctx.can_be_stmt, fn_def.ret_type().is_some()) {\n             (true, true) => \"return $0;\",\n@@ -161,15 +162,12 @@ fn add_keyword(ctx: &CompletionContext, acc: &mut Completions, kw: &str, snippet\n \n     match ctx.config.snippet_cap {\n         Some(cap) => {\n-            let tmp;\n-            let snippet = if snippet.ends_with('}') && ctx.incomplete_let {\n+            if snippet.ends_with('}') && ctx.incomplete_let {\n                 cov_mark::hit!(let_semi);\n-                tmp = format!(\"{};\", snippet);\n-                &tmp\n+                item.insert_snippet(cap, format!(\"{};\", snippet));\n             } else {\n-                snippet\n-            };\n-            item.insert_snippet(cap, snippet);\n+                item.insert_snippet(cap, snippet);\n+            }\n         }\n         None => {\n             item.insert_text(if snippet.contains('$') { kw } else { snippet });\n@@ -232,21 +230,21 @@ mod tests {\n         check(\n             r\"m$0\",\n             expect![[r#\"\n+                kw pub(crate)\n+                kw pub\n+                kw unsafe\n                 kw fn\n+                kw const\n+                kw type\n                 kw use\n                 kw impl\n                 kw trait\n+                kw static\n+                kw extern\n+                kw mod\n                 kw enum\n                 kw struct\n                 kw union\n-                kw mod\n-                kw const\n-                kw type\n-                kw static\n-                kw extern\n-                kw unsafe\n-                kw pub(crate)\n-                kw pub\n             \"#]],\n         );\n     }\n@@ -256,10 +254,16 @@ mod tests {\n         check(\n             r\"fn quux() { $0 }\",\n             expect![[r#\"\n+                kw unsafe\n                 kw fn\n+                kw const\n+                kw type\n                 kw use\n                 kw impl\n                 kw trait\n+                kw static\n+                kw extern\n+                kw mod\n                 kw match\n                 kw while\n                 kw while let\n@@ -268,12 +272,6 @@ mod tests {\n                 kw if let\n                 kw for\n                 kw let\n-                kw mod\n-                kw const\n-                kw type\n-                kw static\n-                kw extern\n-                kw unsafe\n                 kw return\n             \"#]],\n         );\n@@ -284,10 +282,16 @@ mod tests {\n         check(\n             r\"fn quux() { if true { $0 } }\",\n             expect![[r#\"\n+                kw unsafe\n                 kw fn\n+                kw const\n+                kw type\n                 kw use\n                 kw impl\n                 kw trait\n+                kw static\n+                kw extern\n+                kw mod\n                 kw match\n                 kw while\n                 kw while let\n@@ -296,12 +300,6 @@ mod tests {\n                 kw if let\n                 kw for\n                 kw let\n-                kw mod\n-                kw const\n-                kw type\n-                kw static\n-                kw extern\n-                kw unsafe\n                 kw return\n             \"#]],\n         );\n@@ -312,10 +310,16 @@ mod tests {\n         check(\n             r#\"fn quux() { if true { () } $0 }\"#,\n             expect![[r#\"\n+                kw unsafe\n                 kw fn\n+                kw const\n+                kw type\n                 kw use\n                 kw impl\n                 kw trait\n+                kw static\n+                kw extern\n+                kw mod\n                 kw match\n                 kw while\n                 kw while let\n@@ -326,12 +330,6 @@ mod tests {\n                 kw let\n                 kw else\n                 kw else if\n-                kw mod\n-                kw const\n-                kw type\n-                kw static\n-                kw extern\n-                kw unsafe\n                 kw return\n             \"#]],\n         );\n@@ -353,14 +351,14 @@ fn quux() -> i32 {\n }\n \"#,\n             expect![[r#\"\n+                kw unsafe\n                 kw match\n                 kw while\n                 kw while let\n                 kw loop\n                 kw if\n                 kw if let\n                 kw for\n-                kw unsafe\n                 kw return\n             \"#]],\n         );\n@@ -371,10 +369,10 @@ fn quux() -> i32 {\n         check(\n             r\"trait My { $0 }\",\n             expect![[r#\"\n+                kw unsafe\n                 kw fn\n                 kw const\n                 kw type\n-                kw unsafe\n             \"#]],\n         );\n     }\n@@ -384,12 +382,12 @@ fn quux() -> i32 {\n         check(\n             r\"impl My { $0 }\",\n             expect![[r#\"\n+                kw pub(crate)\n+                kw pub\n+                kw unsafe\n                 kw fn\n                 kw const\n                 kw type\n-                kw unsafe\n-                kw pub(crate)\n-                kw pub\n             \"#]],\n         );\n     }\n@@ -399,12 +397,12 @@ fn quux() -> i32 {\n         check(\n             r\"impl My { #[foo] $0 }\",\n             expect![[r#\"\n+                kw pub(crate)\n+                kw pub\n+                kw unsafe\n                 kw fn\n                 kw const\n                 kw type\n-                kw unsafe\n-                kw pub(crate)\n-                kw pub\n             \"#]],\n         );\n     }\n@@ -414,10 +412,16 @@ fn quux() -> i32 {\n         check(\n             r\"fn my() { loop { $0 } }\",\n             expect![[r#\"\n+                kw unsafe\n                 kw fn\n+                kw const\n+                kw type\n                 kw use\n                 kw impl\n                 kw trait\n+                kw static\n+                kw extern\n+                kw mod\n                 kw match\n                 kw while\n                 kw while let\n@@ -426,12 +430,6 @@ fn quux() -> i32 {\n                 kw if let\n                 kw for\n                 kw let\n-                kw mod\n-                kw const\n-                kw type\n-                kw static\n-                kw extern\n-                kw unsafe\n                 kw continue\n                 kw break\n                 kw return"}, {"sha": "faf8469a5eda7bfe7754c170aea1e06c33e9bacf", "filename": "crates/ide_completion/src/context.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a6b92a8cc00c4a4c451e6da2dd4e2a2e8e7bf749/crates%2Fide_completion%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6b92a8cc00c4a4c451e6da2dd4e2a2e8e7bf749/crates%2Fide_completion%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcontext.rs?ref=a6b92a8cc00c4a4c451e6da2dd4e2a2e8e7bf749", "patch": "@@ -288,6 +288,10 @@ impl<'a> CompletionContext<'a> {\n         matches!(self.completion_location, Some(ImmediateLocation::ItemList))\n     }\n \n+    pub(crate) fn expects_expression(&self) -> bool {\n+        self.is_expr\n+    }\n+\n     pub(crate) fn has_block_expr_parent(&self) -> bool {\n         matches!(self.completion_location, Some(ImmediateLocation::BlockExpr))\n     }\n@@ -316,7 +320,7 @@ impl<'a> CompletionContext<'a> {\n \n     fn fill_keyword_patterns(&mut self, file_with_fake_ident: &SyntaxNode, offset: TextSize) {\n         let fake_ident_token = file_with_fake_ident.token_at_offset(offset).right_biased().unwrap();\n-        let syntax_element = NodeOrToken::Token(fake_ident_token.clone());\n+        let syntax_element = NodeOrToken::Token(fake_ident_token);\n         self.previous_token = previous_token(syntax_element.clone());\n         self.in_loop_body = is_in_loop_body(syntax_element.clone());\n         self.is_match_arm = is_match_arm(syntax_element.clone());\n@@ -338,8 +342,6 @@ impl<'a> CompletionContext<'a> {\n         let fn_is_prev = self.previous_token_is(T![fn]);\n         let for_is_prev2 = for_is_prev2(syntax_element.clone());\n         self.no_completion_required = (fn_is_prev && !inside_impl_trait_block) || for_is_prev2;\n-\n-        self.completion_location = determine_location(fake_ident_token);\n     }\n \n     fn fill_impl_def(&mut self) {\n@@ -465,6 +467,7 @@ impl<'a> CompletionContext<'a> {\n             Some(it) => it,\n             None => return,\n         };\n+        self.completion_location = determine_location(&name_like);\n         match name_like {\n             ast::NameLike::Lifetime(lifetime) => {\n                 self.classify_lifetime(original_file, lifetime, offset);"}, {"sha": "f04471b57a821a9c0dc201c85be520e22bd942ee", "filename": "crates/ide_completion/src/patterns.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a6b92a8cc00c4a4c451e6da2dd4e2a2e8e7bf749/crates%2Fide_completion%2Fsrc%2Fpatterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6b92a8cc00c4a4c451e6da2dd4e2a2e8e7bf749/crates%2Fide_completion%2Fsrc%2Fpatterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fpatterns.rs?ref=a6b92a8cc00c4a4c451e6da2dd4e2a2e8e7bf749", "patch": "@@ -24,12 +24,12 @@ pub(crate) enum ImmediateLocation {\n     ItemList,\n }\n \n-pub(crate) fn determine_location(tok: SyntaxToken) -> Option<ImmediateLocation> {\n+pub(crate) fn determine_location(name_like: &ast::NameLike) -> Option<ImmediateLocation> {\n     // First walk the element we are completing up to its highest node that has the same text range\n     // as the element so that we can check in what context it immediately lies. We only do this for\n     // NameRef -> Path as that's the only thing that makes sense to being \"expanded\" semantically.\n     // We only wanna do this if the NameRef is the last segment of the path.\n-    let node = match tok.parent().and_then(ast::NameLike::cast)? {\n+    let node = match name_like {\n         ast::NameLike::NameRef(name_ref) => {\n             if let Some(segment) = name_ref.syntax().parent().and_then(ast::PathSegment::cast) {\n                 let p = segment.parent_path();\n@@ -93,7 +93,8 @@ pub(crate) fn determine_location(tok: SyntaxToken) -> Option<ImmediateLocation>\n #[cfg(test)]\n fn check_location(code: &str, loc: ImmediateLocation) {\n     check_pattern_is_applicable(code, |e| {\n-        assert_eq!(determine_location(e.into_token().expect(\"Expected a token\")), Some(loc));\n+        let name = &e.parent().and_then(ast::NameLike::cast).expect(\"Expected a namelike\");\n+        assert_eq!(determine_location(name), Some(loc));\n         true\n     });\n }\n@@ -199,6 +200,11 @@ fn test_has_impl_as_prev_sibling() {\n     check_pattern_is_applicable(r\"impl A w$0 {}\", |it| has_prev_sibling(it, IMPL));\n }\n \n+#[test]\n+fn test_has_trait_as_prev_sibling() {\n+    check_pattern_is_applicable(r\"trait A w$0 {}\", |it| has_prev_sibling(it, TRAIT));\n+}\n+\n pub(crate) fn is_in_loop_body(element: SyntaxElement) -> bool {\n     element\n         .ancestors()"}, {"sha": "93c7c872ccfdef9eb6d71170a628c57674463a39", "filename": "crates/ide_completion/src/test_utils.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a6b92a8cc00c4a4c451e6da2dd4e2a2e8e7bf749/crates%2Fide_completion%2Fsrc%2Ftest_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6b92a8cc00c4a4c451e6da2dd4e2a2e8e7bf749/crates%2Fide_completion%2Fsrc%2Ftest_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Ftest_utils.rs?ref=a6b92a8cc00c4a4c451e6da2dd4e2a2e8e7bf749", "patch": "@@ -12,7 +12,7 @@ use ide_db::{\n use itertools::Itertools;\n use stdx::{format_to, trim_indent};\n use syntax::{AstNode, NodeOrToken, SyntaxElement};\n-use test_utils::{assert_eq_text, RangeOrOffset};\n+use test_utils::assert_eq_text;\n \n use crate::{item::CompletionKind, CompletionConfig, CompletionItem};\n \n@@ -36,10 +36,7 @@ pub(crate) fn position(ra_fixture: &str) -> (RootDatabase, FilePosition) {\n     let mut database = RootDatabase::default();\n     database.apply_change(change_fixture.change);\n     let (file_id, range_or_offset) = change_fixture.file_position.expect(\"expected a marker ($0)\");\n-    let offset = match range_or_offset {\n-        RangeOrOffset::Range(_) => panic!(),\n-        RangeOrOffset::Offset(it) => it,\n-    };\n+    let offset = range_or_offset.expect_offset();\n     (database, FilePosition { file_id, offset })\n }\n \n@@ -52,10 +49,11 @@ pub(crate) fn do_completion_with_config(\n     code: &str,\n     kind: CompletionKind,\n ) -> Vec<CompletionItem> {\n-    let mut kind_completions: Vec<CompletionItem> =\n-        get_all_items(config, code).into_iter().filter(|c| c.completion_kind == kind).collect();\n-    kind_completions.sort_by(|l, r| l.label().cmp(r.label()));\n-    kind_completions\n+    get_all_items(config, code)\n+        .into_iter()\n+        .filter(|c| c.completion_kind == kind)\n+        .sorted_by(|l, r| l.label().cmp(r.label()))\n+        .collect()\n }\n \n pub(crate) fn completion_list(code: &str, kind: CompletionKind) -> String {"}, {"sha": "b585085f381b6ac486c4be5c9882143f034cbd26", "filename": "crates/ide_db/src/call_info/tests.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a6b92a8cc00c4a4c451e6da2dd4e2a2e8e7bf749/crates%2Fide_db%2Fsrc%2Fcall_info%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6b92a8cc00c4a4c451e6da2dd4e2a2e8e7bf749/crates%2Fide_db%2Fsrc%2Fcall_info%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fcall_info%2Ftests.rs?ref=a6b92a8cc00c4a4c451e6da2dd4e2a2e8e7bf749", "patch": "@@ -1,6 +1,5 @@\n use base_db::{fixture::ChangeFixture, FilePosition};\n use expect_test::{expect, Expect};\n-use test_utils::RangeOrOffset;\n \n use crate::RootDatabase;\n \n@@ -10,10 +9,7 @@ pub(crate) fn position(ra_fixture: &str) -> (RootDatabase, FilePosition) {\n     let mut database = RootDatabase::default();\n     database.apply_change(change_fixture.change);\n     let (file_id, range_or_offset) = change_fixture.file_position.expect(\"expected a marker ($0)\");\n-    let offset = match range_or_offset {\n-        RangeOrOffset::Range(_) => panic!(),\n-        RangeOrOffset::Offset(it) => it,\n-    };\n+    let offset = range_or_offset.expect_offset();\n     (database, FilePosition { file_id, offset })\n }\n "}, {"sha": "de994407c7ca464061eee92c59aa604154ae1b76", "filename": "crates/ide_db/src/traits/tests.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a6b92a8cc00c4a4c451e6da2dd4e2a2e8e7bf749/crates%2Fide_db%2Fsrc%2Ftraits%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6b92a8cc00c4a4c451e6da2dd4e2a2e8e7bf749/crates%2Fide_db%2Fsrc%2Ftraits%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Ftraits%2Ftests.rs?ref=a6b92a8cc00c4a4c451e6da2dd4e2a2e8e7bf749", "patch": "@@ -2,7 +2,6 @@ use base_db::{fixture::ChangeFixture, FilePosition};\n use expect_test::{expect, Expect};\n use hir::Semantics;\n use syntax::ast::{self, AstNode};\n-use test_utils::RangeOrOffset;\n \n use crate::RootDatabase;\n \n@@ -12,10 +11,7 @@ pub(crate) fn position(ra_fixture: &str) -> (RootDatabase, FilePosition) {\n     let mut database = RootDatabase::default();\n     database.apply_change(change_fixture.change);\n     let (file_id, range_or_offset) = change_fixture.file_position.expect(\"expected a marker ($0)\");\n-    let offset = match range_or_offset {\n-        RangeOrOffset::Range(_) => panic!(),\n-        RangeOrOffset::Offset(it) => it,\n-    };\n+    let offset = range_or_offset.expect_offset();\n     (database, FilePosition { file_id, offset })\n }\n "}, {"sha": "bd017567cae53a320d9aa1f763a09d475f707568", "filename": "crates/test_utils/src/lib.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/a6b92a8cc00c4a4c451e6da2dd4e2a2e8e7bf749/crates%2Ftest_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6b92a8cc00c4a4c451e6da2dd4e2a2e8e7bf749/crates%2Ftest_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Ftest_utils%2Fsrc%2Flib.rs?ref=a6b92a8cc00c4a4c451e6da2dd4e2a2e8e7bf749", "patch": "@@ -96,6 +96,21 @@ pub enum RangeOrOffset {\n     Offset(TextSize),\n }\n \n+impl RangeOrOffset {\n+    pub fn expect_offset(self) -> TextSize {\n+        match self {\n+            RangeOrOffset::Offset(it) => it,\n+            RangeOrOffset::Range(_) => panic!(\"expected an offset but got a range instead\"),\n+        }\n+    }\n+    pub fn expect_range(self) -> TextRange {\n+        match self {\n+            RangeOrOffset::Range(it) => it,\n+            RangeOrOffset::Offset(_) => panic!(\"expected a range but got an offset\"),\n+        }\n+    }\n+}\n+\n impl From<RangeOrOffset> for TextRange {\n     fn from(selection: RangeOrOffset) -> Self {\n         match selection {"}]}