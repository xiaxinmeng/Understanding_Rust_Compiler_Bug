{"sha": "336a72a8daea236a89787f16931611310315340c", "node_id": "C_kwDOAAsO6NoAKDMzNmE3MmE4ZGFlYTIzNmE4OTc4N2YxNjkzMTYxMTMxMDMxNTM0MGM", "commit": {"author": {"name": "Xiretza", "email": "xiretza@xiretza.xyz", "date": "2022-09-14T15:19:40Z"}, "committer": {"name": "Xiretza", "email": "xiretza@xiretza.xyz", "date": "2022-09-22T15:25:50Z"}, "message": "Unify subdiagnostic attribute parsing", "tree": {"sha": "2e3dc7939f8a1763f448781089ecccc66f5abf3e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2e3dc7939f8a1763f448781089ecccc66f5abf3e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/336a72a8daea236a89787f16931611310315340c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/336a72a8daea236a89787f16931611310315340c", "html_url": "https://github.com/rust-lang/rust/commit/336a72a8daea236a89787f16931611310315340c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/336a72a8daea236a89787f16931611310315340c/comments", "author": {"login": "Xiretza", "id": 3107142, "node_id": "MDQ6VXNlcjMxMDcxNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3107142?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Xiretza", "html_url": "https://github.com/Xiretza", "followers_url": "https://api.github.com/users/Xiretza/followers", "following_url": "https://api.github.com/users/Xiretza/following{/other_user}", "gists_url": "https://api.github.com/users/Xiretza/gists{/gist_id}", "starred_url": "https://api.github.com/users/Xiretza/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Xiretza/subscriptions", "organizations_url": "https://api.github.com/users/Xiretza/orgs", "repos_url": "https://api.github.com/users/Xiretza/repos", "events_url": "https://api.github.com/users/Xiretza/events{/privacy}", "received_events_url": "https://api.github.com/users/Xiretza/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Xiretza", "id": 3107142, "node_id": "MDQ6VXNlcjMxMDcxNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3107142?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Xiretza", "html_url": "https://github.com/Xiretza", "followers_url": "https://api.github.com/users/Xiretza/followers", "following_url": "https://api.github.com/users/Xiretza/following{/other_user}", "gists_url": "https://api.github.com/users/Xiretza/gists{/gist_id}", "starred_url": "https://api.github.com/users/Xiretza/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Xiretza/subscriptions", "organizations_url": "https://api.github.com/users/Xiretza/orgs", "repos_url": "https://api.github.com/users/Xiretza/repos", "events_url": "https://api.github.com/users/Xiretza/events{/privacy}", "received_events_url": "https://api.github.com/users/Xiretza/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ae56d2a118a780d0ad1de606ad659a95c655b1b2", "url": "https://api.github.com/repos/rust-lang/rust/commits/ae56d2a118a780d0ad1de606ad659a95c655b1b2", "html_url": "https://github.com/rust-lang/rust/commit/ae56d2a118a780d0ad1de606ad659a95c655b1b2"}], "stats": {"total": 720, "additions": 360, "deletions": 360}, "files": [{"sha": "2aa292bbce2b6493b86c23e12d46c0fdecf7696b", "filename": "compiler/rustc_macros/src/diagnostics/diagnostic_builder.rs", "status": "modified", "additions": 139, "deletions": 275, "changes": 414, "blob_url": "https://github.com/rust-lang/rust/blob/336a72a8daea236a89787f16931611310315340c/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fdiagnostic_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/336a72a8daea236a89787f16931611310315340c/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fdiagnostic_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fdiagnostic_builder.rs?ref=336a72a8daea236a89787f16931611310315340c", "patch": "@@ -1,25 +1,23 @@\n #![deny(unused_must_use)]\n \n+use super::error::throw_invalid_nested_attr;\n+use super::utils::{SpannedOption, SubdiagnosticKind};\n use crate::diagnostics::error::{\n-    invalid_nested_attr, span_err, throw_invalid_attr, throw_invalid_nested_attr, throw_span_err,\n-    DiagnosticDeriveError,\n+    invalid_nested_attr, span_err, throw_invalid_attr, throw_span_err, DiagnosticDeriveError,\n };\n use crate::diagnostics::utils::{\n     report_error_if_not_applied_to_span, report_type_error, type_is_unit, type_matches_path,\n-    Applicability, FieldInfo, FieldInnerTy, HasFieldMap, SetOnce,\n+    FieldInfo, FieldInnerTy, HasFieldMap, SetOnce,\n };\n use proc_macro2::{Ident, Span, TokenStream};\n use quote::{format_ident, quote};\n use std::collections::HashMap;\n-use std::str::FromStr;\n use syn::{\n     parse_quote, spanned::Spanned, Attribute, Field, Meta, MetaList, MetaNameValue, NestedMeta,\n     Path, Type,\n };\n use synstructure::{BindingInfo, Structure};\n \n-use super::utils::SpannedOption;\n-\n /// What kind of diagnostic is being derived - a fatal/error/warning or a lint?\n #[derive(Copy, Clone, PartialEq, Eq)]\n pub(crate) enum DiagnosticDeriveKind {\n@@ -45,7 +43,7 @@ pub(crate) struct DiagnosticDeriveBuilder {\n     pub slug: SpannedOption<Path>,\n     /// Error codes are a optional part of the struct attribute - this is only set to detect\n     /// multiple specifications.\n-    pub code: SpannedOption<String>,\n+    pub code: SpannedOption<()>,\n }\n \n impl HasFieldMap for DiagnosticDeriveBuilder {\n@@ -129,6 +127,30 @@ impl DiagnosticDeriveBuilder {\n             || is_subdiagnostic\n     }\n \n+    fn parse_subdiag_attribute(\n+        &self,\n+        attr: &Attribute,\n+    ) -> Result<(SubdiagnosticKind, Path), DiagnosticDeriveError> {\n+        let (subdiag, slug) = SubdiagnosticKind::from_attr(attr, self)?;\n+\n+        if let SubdiagnosticKind::MultipartSuggestion { .. } = subdiag {\n+            let meta = attr.parse_meta()?;\n+            throw_invalid_attr!(attr, &meta, |diag| diag\n+                .help(\"consider creating a `Subdiagnostic` instead\"));\n+        }\n+\n+        let slug = slug.unwrap_or_else(|| match subdiag {\n+            SubdiagnosticKind::Label => parse_quote! { _subdiag::label },\n+            SubdiagnosticKind::Note => parse_quote! { _subdiag::note },\n+            SubdiagnosticKind::Help => parse_quote! { _subdiag::help },\n+            SubdiagnosticKind::Warn => parse_quote! { _subdiag::warn },\n+            SubdiagnosticKind::Suggestion { .. } => parse_quote! { _subdiag::suggestion },\n+            SubdiagnosticKind::MultipartSuggestion { .. } => unreachable!(),\n+        });\n+\n+        Ok((subdiag, slug))\n+    }\n+\n     /// Establishes state in the `DiagnosticDeriveBuilder` resulting from the struct\n     /// attributes like `#[diag(..)]`, such as the slug and error code. Generates\n     /// diagnostic builder calls for setting error code and creating note/help messages.\n@@ -137,111 +159,87 @@ impl DiagnosticDeriveBuilder {\n         attr: &Attribute,\n     ) -> Result<TokenStream, DiagnosticDeriveError> {\n         let diag = &self.diag;\n-        let span = attr.span().unwrap();\n \n         let name = attr.path.segments.last().unwrap().ident.to_string();\n         let name = name.as_str();\n         let meta = attr.parse_meta()?;\n \n-        let is_diag = name == \"diag\";\n-\n-        let nested = match meta {\n-            // Most attributes are lists, like `#[diag(..)]` for most cases or\n-            // `#[help(..)]`/`#[note(..)]` when the user is specifying a alternative slug.\n-            Meta::List(MetaList { ref nested, .. }) => nested,\n-            // Subdiagnostics without spans can be applied to the type too, and these are just\n-            // paths: `#[help]`, `#[note]` and `#[warning]`\n-            Meta::Path(_) if !is_diag => {\n-                let fn_name = if name == \"warning\" {\n-                    Ident::new(\"warn\", attr.span())\n-                } else {\n-                    Ident::new(name, attr.span())\n-                };\n-                return Ok(self.add_subdiagnostic(&fn_name, parse_quote! { _subdiag::#fn_name }));\n-            }\n-            _ => throw_invalid_attr!(attr, &meta),\n-        };\n-\n-        // Check the kind before doing any further processing so that there aren't misleading\n-        // \"no kind specified\" errors if there are failures later.\n-        match name {\n-            \"error\" | \"lint\" => throw_invalid_attr!(attr, &meta, |diag| {\n-                diag.help(\"`error` and `lint` have been replaced by `diag`\")\n-            }),\n-            \"warn_\" => throw_invalid_attr!(attr, &meta, |diag| {\n-                diag.help(\"`warn_` have been replaced by `warning`\")\n-            }),\n-            \"diag\" | \"help\" | \"note\" | \"warning\" => (),\n-            _ => throw_invalid_attr!(attr, &meta, |diag| {\n-                diag.help(\"only `diag`, `help`, `note` and `warning` are valid attributes\")\n-            }),\n-        }\n+        if name == \"diag\" {\n+            let Meta::List(MetaList { ref nested, .. }) = meta else {\n+                throw_invalid_attr!(\n+                    attr,\n+                    &meta\n+                );\n+            };\n \n-        // First nested element should always be the path, e.g. `#[diag(typeck::invalid)]` or\n-        // `#[help(typeck::another_help)]`.\n-        let mut nested_iter = nested.into_iter();\n-        if let Some(nested_attr) = nested_iter.next() {\n-            // Report an error if there are any other list items after the path.\n-            if !is_diag && nested_iter.next().is_some() {\n-                throw_invalid_nested_attr!(attr, &nested_attr, |diag| {\n-                    diag.help(\n-                        \"`help`, `note` and `warning` struct attributes can only have one argument\",\n-                    )\n-                });\n-            }\n+            let mut nested_iter = nested.into_iter().peekable();\n \n-            match nested_attr {\n-                NestedMeta::Meta(Meta::Path(path)) => {\n-                    if is_diag {\n-                        self.slug.set_once(path.clone(), span);\n-                    } else {\n-                        let fn_name = proc_macro2::Ident::new(name, attr.span());\n-                        return Ok(quote! { #diag.#fn_name(rustc_errors::fluent::#path); });\n-                    }\n+            match nested_iter.peek() {\n+                Some(NestedMeta::Meta(Meta::Path(slug))) => {\n+                    self.slug.set_once(slug.clone(), slug.span().unwrap());\n+                    nested_iter.next();\n                 }\n-                NestedMeta::Meta(meta @ Meta::NameValue(_))\n-                    if is_diag && meta.path().segments.last().unwrap().ident == \"code\" =>\n-                {\n-                    // don't error for valid follow-up attributes\n-                }\n-                nested_attr => throw_invalid_nested_attr!(attr, &nested_attr, |diag| {\n-                    diag.help(\"first argument of the attribute should be the diagnostic slug\")\n-                }),\n+                Some(NestedMeta::Meta(Meta::NameValue { .. })) => {}\n+                Some(nested_attr) => throw_invalid_nested_attr!(attr, &nested_attr, |diag| diag\n+                    .help(\"a diagnostic slug is required as the first argument\")),\n+                None => throw_invalid_attr!(attr, &meta, |diag| diag\n+                    .help(\"a diagnostic slug is required as the first argument\")),\n             };\n-        }\n \n-        // Remaining attributes are optional, only `code = \"..\"` at the moment.\n-        let mut tokens = Vec::new();\n-        for nested_attr in nested_iter {\n-            let meta = match nested_attr {\n-                syn::NestedMeta::Meta(meta) => meta,\n-                _ => throw_invalid_nested_attr!(attr, &nested_attr),\n-            };\n+            // Remaining attributes are optional, only `code = \"..\"` at the moment.\n+            let mut tokens = TokenStream::new();\n+            for nested_attr in nested_iter {\n+                let (value, path) = match nested_attr {\n+                    NestedMeta::Meta(Meta::NameValue(MetaNameValue {\n+                        lit: syn::Lit::Str(value),\n+                        path,\n+                        ..\n+                    })) => (value, path),\n+                    NestedMeta::Meta(Meta::Path(_)) => {\n+                        invalid_nested_attr(attr, &nested_attr)\n+                            .help(\"diagnostic slug must be the first argument\")\n+                            .emit();\n+                        continue;\n+                    }\n+                    _ => {\n+                        invalid_nested_attr(attr, &nested_attr).emit();\n+                        continue;\n+                    }\n+                };\n \n-            let path = meta.path();\n-            let nested_name = path.segments.last().unwrap().ident.to_string();\n-            // Struct attributes are only allowed to be applied once, and the diagnostic\n-            // changes will be set in the initialisation code.\n-            if let Meta::NameValue(MetaNameValue { lit: syn::Lit::Str(s), .. }) = &meta {\n-                let span = s.span().unwrap();\n+                let nested_name = path.segments.last().unwrap().ident.to_string();\n+                // Struct attributes are only allowed to be applied once, and the diagnostic\n+                // changes will be set in the initialisation code.\n+                let span = value.span().unwrap();\n                 match nested_name.as_str() {\n                     \"code\" => {\n-                        self.code.set_once(s.value(), span);\n-                        let code = &self.code.value_ref();\n-                        tokens.push(quote! {\n+                        self.code.set_once((), span);\n+\n+                        let code = value.value();\n+                        tokens.extend(quote! {\n                             #diag.code(rustc_errors::DiagnosticId::Error(#code.to_string()));\n                         });\n                     }\n                     _ => invalid_nested_attr(attr, &nested_attr)\n                         .help(\"only `code` is a valid nested attributes following the slug\")\n                         .emit(),\n                 }\n-            } else {\n-                invalid_nested_attr(attr, &nested_attr).emit()\n             }\n+            return Ok(tokens);\n         }\n \n-        Ok(tokens.into_iter().collect())\n+        let (subdiag, slug) = self.parse_subdiag_attribute(attr)?;\n+        let fn_ident = format_ident!(\"{}\", subdiag);\n+        match subdiag {\n+            SubdiagnosticKind::Note | SubdiagnosticKind::Help | SubdiagnosticKind::Warn => {\n+                Ok(self.add_subdiagnostic(&fn_ident, slug))\n+            }\n+            SubdiagnosticKind::Label | SubdiagnosticKind::Suggestion { .. } => {\n+                throw_invalid_attr!(attr, &meta, |diag| diag\n+                    .help(\"`#[label]` and `#[suggestion]` can only be applied to fields\"));\n+            }\n+            SubdiagnosticKind::MultipartSuggestion { .. } => unreachable!(),\n+        }\n     }\n \n     fn generate_field_attrs_code(&mut self, binding_info: &BindingInfo<'_>) -> TokenStream {\n@@ -305,217 +303,83 @@ impl DiagnosticDeriveBuilder {\n         info: FieldInfo<'_>,\n         binding: TokenStream,\n     ) -> Result<TokenStream, DiagnosticDeriveError> {\n-        let meta = attr.parse_meta()?;\n-        match meta {\n-            Meta::Path(_) => self.generate_inner_field_code_path(attr, info, binding),\n-            Meta::List(MetaList { .. }) => self.generate_inner_field_code_list(attr, info, binding),\n-            _ => throw_invalid_attr!(attr, &meta),\n-        }\n-    }\n-\n-    fn generate_inner_field_code_path(\n-        &mut self,\n-        attr: &Attribute,\n-        info: FieldInfo<'_>,\n-        binding: TokenStream,\n-    ) -> Result<TokenStream, DiagnosticDeriveError> {\n-        assert!(matches!(attr.parse_meta()?, Meta::Path(_)));\n         let diag = &self.diag;\n-\n         let meta = attr.parse_meta()?;\n \n-        let ident = &attr.path.segments.last().unwrap().ident;\n-        let name = ident.to_string();\n-        let name = name.as_str();\n-        match name {\n-            \"skip_arg\" => {\n-                // Don't need to do anything - by virtue of the attribute existing, the\n-                // `set_arg` call will not be generated.\n-                Ok(quote! {})\n-            }\n-            \"primary_span\" => {\n-                match self.kind {\n+        if let Meta::Path(_) = meta {\n+            let ident = &attr.path.segments.last().unwrap().ident;\n+            let name = ident.to_string();\n+            let name = name.as_str();\n+            match name {\n+                \"skip_arg\" => {\n+                    // Don't need to do anything - by virtue of the attribute existing, the\n+                    // `set_arg` call will not be generated.\n+                    return Ok(quote! {});\n+                }\n+                \"primary_span\" => match self.kind {\n                     DiagnosticDeriveKind::Diagnostic => {\n                         report_error_if_not_applied_to_span(attr, &info)?;\n \n-                        Ok(quote! {\n+                        return Ok(quote! {\n                             #diag.set_span(#binding);\n-                        })\n+                        });\n                     }\n                     DiagnosticDeriveKind::LintDiagnostic => {\n                         throw_invalid_attr!(attr, &meta, |diag| {\n                             diag.help(\"the `primary_span` field attribute is not valid for lint diagnostics\")\n                         })\n                     }\n-                }\n+                },\n+                \"subdiagnostic\" => return Ok(quote! { #diag.subdiagnostic(#binding); }),\n+                _ => {}\n             }\n-            \"label\" => {\n+        }\n+\n+        let (subdiag, slug) = self.parse_subdiag_attribute(attr)?;\n+\n+        let fn_ident = format_ident!(\"{}\", subdiag);\n+        match subdiag {\n+            SubdiagnosticKind::Label => {\n                 report_error_if_not_applied_to_span(attr, &info)?;\n-                Ok(self.add_spanned_subdiagnostic(binding, ident, parse_quote! { _subdiag::label }))\n+                Ok(self.add_spanned_subdiagnostic(binding, &fn_ident, slug))\n             }\n-            \"note\" | \"help\" | \"warning\" => {\n-                let warn_ident = Ident::new(\"warn\", Span::call_site());\n-                let (ident, path) = match name {\n-                    \"note\" => (ident, parse_quote! { _subdiag::note }),\n-                    \"help\" => (ident, parse_quote! { _subdiag::help }),\n-                    \"warning\" => (&warn_ident, parse_quote! { _subdiag::warn }),\n-                    _ => unreachable!(),\n-                };\n+            SubdiagnosticKind::Note | SubdiagnosticKind::Help | SubdiagnosticKind::Warn => {\n                 if type_matches_path(&info.ty, &[\"rustc_span\", \"Span\"]) {\n-                    Ok(self.add_spanned_subdiagnostic(binding, ident, path))\n+                    Ok(self.add_spanned_subdiagnostic(binding, &fn_ident, slug))\n                 } else if type_is_unit(&info.ty) {\n-                    Ok(self.add_subdiagnostic(ident, path))\n+                    Ok(self.add_subdiagnostic(&fn_ident, slug))\n                 } else {\n                     report_type_error(attr, \"`Span` or `()`\")?\n                 }\n             }\n-            \"subdiagnostic\" => Ok(quote! { #diag.subdiagnostic(#binding); }),\n-            _ => throw_invalid_attr!(attr, &meta, |diag| {\n-                diag.help(\n-                    \"only `skip_arg`, `primary_span`, `label`, `note`, `help` and `subdiagnostic` \\\n-                     are valid field attributes\",\n-                )\n-            }),\n-        }\n-    }\n-\n-    fn generate_inner_field_code_list(\n-        &mut self,\n-        attr: &Attribute,\n-        info: FieldInfo<'_>,\n-        binding: TokenStream,\n-    ) -> Result<TokenStream, DiagnosticDeriveError> {\n-        let meta = attr.parse_meta()?;\n-        let Meta::List(MetaList { ref path, ref nested, .. }) = meta  else { unreachable!() };\n-\n-        let ident = &attr.path.segments.last().unwrap().ident;\n-        let name = path.segments.last().unwrap().ident.to_string();\n-        let name = name.as_ref();\n-        match name {\n-            \"suggestion\" | \"suggestion_short\" | \"suggestion_hidden\" | \"suggestion_verbose\" => {\n-                return self.generate_inner_field_code_suggestion(attr, info);\n-            }\n-            \"label\" | \"help\" | \"note\" | \"warning\" => (),\n-            _ => throw_invalid_attr!(attr, &meta, |diag| {\n-                diag.help(\n-                    \"only `label`, `help`, `note`, `warn` or `suggestion{,_short,_hidden,_verbose}` are \\\n-                     valid field attributes\",\n-                )\n-            }),\n-        }\n-\n-        // For `#[label(..)]`, `#[note(..)]` and `#[help(..)]`, the first nested element must be a\n-        // path, e.g. `#[label(typeck::label)]`.\n-        let mut nested_iter = nested.into_iter();\n-        let msg = match nested_iter.next() {\n-            Some(NestedMeta::Meta(Meta::Path(path))) => path.clone(),\n-            Some(nested_attr) => throw_invalid_nested_attr!(attr, &nested_attr),\n-            None => throw_invalid_attr!(attr, &meta),\n-        };\n-\n-        // None of these attributes should have anything following the slug.\n-        if nested_iter.next().is_some() {\n-            throw_invalid_attr!(attr, &meta);\n-        }\n-\n-        match name {\n-            \"label\" => {\n-                report_error_if_not_applied_to_span(attr, &info)?;\n-                Ok(self.add_spanned_subdiagnostic(binding, ident, msg))\n-            }\n-            \"note\" | \"help\" if type_matches_path(&info.ty, &[\"rustc_span\", \"Span\"]) => {\n-                Ok(self.add_spanned_subdiagnostic(binding, ident, msg))\n-            }\n-            \"note\" | \"help\" if type_is_unit(&info.ty) => Ok(self.add_subdiagnostic(ident, msg)),\n-            // `warning` must be special-cased because the attribute `warn` already has meaning and\n-            // so isn't used, despite the diagnostic API being named `warn`.\n-            \"warning\" if type_matches_path(&info.ty, &[\"rustc_span\", \"Span\"]) => Ok(self\n-                .add_spanned_subdiagnostic(binding, &Ident::new(\"warn\", Span::call_site()), msg)),\n-            \"warning\" if type_is_unit(&info.ty) => {\n-                Ok(self.add_subdiagnostic(&Ident::new(\"warn\", Span::call_site()), msg))\n-            }\n-            \"note\" | \"help\" | \"warning\" => report_type_error(attr, \"`Span` or `()`\")?,\n-            _ => unreachable!(),\n-        }\n-    }\n-\n-    fn generate_inner_field_code_suggestion(\n-        &mut self,\n-        attr: &Attribute,\n-        info: FieldInfo<'_>,\n-    ) -> Result<TokenStream, DiagnosticDeriveError> {\n-        let diag = &self.diag;\n-\n-        let mut meta = attr.parse_meta()?;\n-        let Meta::List(MetaList { ref path, ref mut nested, .. }) = meta  else { unreachable!() };\n-\n-        let (span_field, mut applicability) = self.span_and_applicability_of_ty(info)?;\n-\n-        let mut code = None;\n-\n-        let mut nested_iter = nested.into_iter().peekable();\n-        let msg = if let Some(NestedMeta::Meta(Meta::Path(path))) = nested_iter.peek() {\n-            let path = path.clone();\n-            // Move the iterator forward if a path was found (don't otherwise so that\n-            // code/applicability can be found or an error emitted).\n-            nested_iter.next();\n-            Some(path)\n-        } else {\n-            None\n-        };\n-\n-        for nested_attr in nested_iter {\n-            let meta = match nested_attr {\n-                syn::NestedMeta::Meta(ref meta) => meta,\n-                syn::NestedMeta::Lit(_) => throw_invalid_nested_attr!(attr, &nested_attr),\n-            };\n-\n-            let nested_name = meta.path().segments.last().unwrap().ident.to_string();\n-            let nested_name = nested_name.as_str();\n-            match meta {\n-                Meta::NameValue(MetaNameValue { lit: syn::Lit::Str(s), .. }) => {\n-                    let span = meta.span().unwrap();\n-                    match nested_name {\n-                        \"code\" => {\n-                            let formatted_str = self.build_format(&s.value(), s.span());\n-                            code.set_once(formatted_str, span);\n-                        }\n-                        \"applicability\" => match Applicability::from_str(&s.value()) {\n-                            Ok(v) => applicability.set_once(quote! { #v }, span),\n-                            Err(()) => {\n-                                span_err(span, \"invalid applicability\").emit();\n-                            }\n-                        },\n-                        _ => throw_invalid_nested_attr!(attr, &nested_attr, |diag| {\n-                            diag.help(\n-                                \"only `message`, `code` and `applicability` are valid field \\\n-                                 attributes\",\n-                            )\n-                        }),\n-                    }\n+            SubdiagnosticKind::Suggestion {\n+                suggestion_kind,\n+                applicability: static_applicability,\n+                code,\n+            } => {\n+                let (span_field, mut applicability) = self.span_and_applicability_of_ty(info)?;\n+\n+                if let Some((static_applicability, span)) = static_applicability {\n+                    applicability.set_once(quote! { #static_applicability }, span);\n                 }\n-                _ => throw_invalid_nested_attr!(attr, &nested_attr, |diag| {\n-                    if matches!(meta, Meta::Path(_)) {\n-                        diag.help(\"a diagnostic slug must be the first argument to the attribute\")\n-                    } else {\n-                        diag\n-                    }\n-                }),\n+\n+                let applicability = applicability\n+                    .value()\n+                    .unwrap_or_else(|| quote! { rustc_errors::Applicability::Unspecified });\n+                let style = suggestion_kind.to_suggestion_style();\n+\n+                Ok(quote! {\n+                    #diag.span_suggestion_with_style(\n+                        #span_field,\n+                        rustc_errors::fluent::#slug,\n+                        #code,\n+                        #applicability,\n+                        #style\n+                    );\n+                })\n             }\n+            SubdiagnosticKind::MultipartSuggestion { .. } => unreachable!(),\n         }\n-\n-        let applicability = applicability\n-            .value()\n-            .unwrap_or_else(|| quote!(rustc_errors::Applicability::Unspecified));\n-\n-        let name = path.segments.last().unwrap().ident.to_string();\n-        let method = format_ident!(\"span_{}\", name);\n-\n-        let msg = msg.unwrap_or_else(|| parse_quote! { _subdiag::suggestion });\n-        let msg = quote! { rustc_errors::fluent::#msg };\n-        let code = code.value().unwrap_or_else(|| quote! { String::new() });\n-\n-        Ok(quote! { #diag.#method(#span_field, #msg, #code, #applicability); })\n     }\n \n     /// Adds a spanned subdiagnostic by generating a `diag.span_$kind` call with the current slug"}, {"sha": "ad481c14bab8d9905e4f69fbad4cd74d3fb81881", "filename": "src/test/ui-fulldeps/session-diagnostic/diagnostic-derive.rs", "status": "modified", "additions": 51, "deletions": 5, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/336a72a8daea236a89787f16931611310315340c/src%2Ftest%2Fui-fulldeps%2Fsession-diagnostic%2Fdiagnostic-derive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/336a72a8daea236a89787f16931611310315340c/src%2Ftest%2Fui-fulldeps%2Fsession-diagnostic%2Fdiagnostic-derive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fsession-diagnostic%2Fdiagnostic-derive.rs?ref=336a72a8daea236a89787f16931611310315340c", "patch": "@@ -76,13 +76,15 @@ struct InvalidNestedStructAttr1 {}\n #[derive(Diagnostic)]\n #[diag(nonsense = \"...\", code = \"E0123\", slug = \"foo\")]\n //~^ ERROR `#[diag(nonsense = ...)]` is not a valid attribute\n-//~^^ ERROR diagnostic slug not specified\n+//~| ERROR `#[diag(slug = ...)]` is not a valid attribute\n+//~| ERROR diagnostic slug not specified\n struct InvalidNestedStructAttr2 {}\n \n #[derive(Diagnostic)]\n #[diag(nonsense = 4, code = \"E0123\", slug = \"foo\")]\n //~^ ERROR `#[diag(nonsense = ...)]` is not a valid attribute\n-//~^^ ERROR diagnostic slug not specified\n+//~| ERROR `#[diag(slug = ...)]` is not a valid attribute\n+//~| ERROR diagnostic slug not specified\n struct InvalidNestedStructAttr3 {}\n \n #[derive(Diagnostic)]\n@@ -217,6 +219,7 @@ struct Suggest {\n #[diag(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n struct SuggestWithoutCode {\n     #[suggestion(typeck::suggestion)]\n+    //~^ ERROR suggestion without `code = \"...\"`\n     suggestion: (Span, Applicability),\n }\n \n@@ -225,6 +228,7 @@ struct SuggestWithoutCode {\n struct SuggestWithBadKey {\n     #[suggestion(nonsense = \"bar\")]\n     //~^ ERROR `#[suggestion(nonsense = ...)]` is not a valid attribute\n+    //~| ERROR suggestion without `code = \"...\"`\n     suggestion: (Span, Applicability),\n }\n \n@@ -233,6 +237,7 @@ struct SuggestWithBadKey {\n struct SuggestWithShorthandMsg {\n     #[suggestion(msg = \"bar\")]\n     //~^ ERROR `#[suggestion(msg = ...)]` is not a valid attribute\n+    //~| ERROR suggestion without `code = \"...\"`\n     suggestion: (Span, Applicability),\n }\n \n@@ -507,23 +512,23 @@ struct OptUnitField {\n #[diag(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n struct LabelWithTrailingPath {\n     #[label(typeck::label, foo)]\n-    //~^ ERROR `#[label(...)]` is not a valid attribute\n+    //~^ ERROR `#[label(foo)]` is not a valid attribute\n     span: Span,\n }\n \n #[derive(Diagnostic)]\n #[diag(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n struct LabelWithTrailingNameValue {\n     #[label(typeck::label, foo = \"...\")]\n-    //~^ ERROR `#[label(...)]` is not a valid attribute\n+    //~^ ERROR `#[label(foo = ...)]` is not a valid attribute\n     span: Span,\n }\n \n #[derive(Diagnostic)]\n #[diag(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n struct LabelWithTrailingList {\n     #[label(typeck::label, foo(\"...\"))]\n-    //~^ ERROR `#[label(...)]` is not a valid attribute\n+    //~^ ERROR `#[label(foo(...))]` is not a valid attribute\n     span: Span,\n }\n \n@@ -605,3 +610,44 @@ struct MissingApplicabilityInSuggestionTuple {\n     suggestion: (Span,),\n     //~^ ERROR wrong types for suggestion\n }\n+\n+#[derive(Diagnostic)]\n+#[diag(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n+struct MissingCodeInSuggestion {\n+    #[suggestion(typeck::suggestion)]\n+    //~^ ERROR suggestion without `code = \"...\"`\n+    suggestion: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n+#[multipart_suggestion(typeck::suggestion)]\n+//~^ ERROR `#[multipart_suggestion(...)]` is not a valid attribute\n+//~| ERROR cannot find attribute `multipart_suggestion` in this scope\n+#[multipart_suggestion()]\n+//~^ ERROR `#[multipart_suggestion(...)]` is not a valid attribute\n+//~| ERROR cannot find attribute `multipart_suggestion` in this scope\n+struct MultipartSuggestion {\n+    #[multipart_suggestion(typeck::suggestion)]\n+    //~^ ERROR `#[multipart_suggestion(...)]` is not a valid attribute\n+    //~| ERROR cannot find attribute `multipart_suggestion` in this scope\n+    suggestion: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n+#[suggestion(typeck::suggestion, code = \"...\")]\n+//~^ ERROR `#[suggestion(...)]` is not a valid attribute\n+struct SuggestionOnStruct {\n+    #[primary_span]\n+    suggestion: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n+#[label]\n+//~^ ERROR `#[label]` is not a valid attribute\n+struct LabelOnStruct {\n+    #[primary_span]\n+    suggestion: Span,\n+}"}, {"sha": "9919b12beaf0a54edf0b0f53122900e9583232ff", "filename": "src/test/ui-fulldeps/session-diagnostic/diagnostic-derive.stderr", "status": "modified", "additions": 170, "deletions": 80, "changes": 250, "blob_url": "https://github.com/rust-lang/rust/blob/336a72a8daea236a89787f16931611310315340c/src%2Ftest%2Fui-fulldeps%2Fsession-diagnostic%2Fdiagnostic-derive.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/336a72a8daea236a89787f16931611310315340c/src%2Ftest%2Fui-fulldeps%2Fsession-diagnostic%2Fdiagnostic-derive.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fsession-diagnostic%2Fdiagnostic-derive.stderr?ref=336a72a8daea236a89787f16931611310315340c", "patch": "@@ -20,8 +20,6 @@ error: `#[nonsense(...)]` is not a valid attribute\n    |\n LL | #[nonsense(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = help: only `diag`, `help`, `note` and `warning` are valid attributes\n \n error: diagnostic slug not specified\n   --> $DIR/diagnostic-derive.rs:53:1\n@@ -41,7 +39,7 @@ error: `#[diag(\"...\")]` is not a valid attribute\n LL | #[diag(\"E0123\")]\n    |        ^^^^^^^\n    |\n-   = help: first argument of the attribute should be the diagnostic slug\n+   = help: a diagnostic slug is required as the first argument\n \n error: diagnostic slug not specified\n   --> $DIR/diagnostic-derive.rs:60:1\n@@ -60,7 +58,7 @@ error: `#[diag(nonsense(...))]` is not a valid attribute\n LL | #[diag(nonsense(\"foo\"), code = \"E0123\", slug = \"foo\")]\n    |        ^^^^^^^^^^^^^^^\n    |\n-   = help: first argument of the attribute should be the diagnostic slug\n+   = help: a diagnostic slug is required as the first argument\n \n error: diagnostic slug not specified\n   --> $DIR/diagnostic-derive.rs:71:1\n@@ -79,104 +77,122 @@ error: `#[diag(nonsense = ...)]` is not a valid attribute\n LL | #[diag(nonsense = \"...\", code = \"E0123\", slug = \"foo\")]\n    |        ^^^^^^^^^^^^^^^^\n    |\n-   = help: first argument of the attribute should be the diagnostic slug\n+   = help: only `code` is a valid nested attributes following the slug\n+\n+error: `#[diag(slug = ...)]` is not a valid attribute\n+  --> $DIR/diagnostic-derive.rs:77:42\n+   |\n+LL | #[diag(nonsense = \"...\", code = \"E0123\", slug = \"foo\")]\n+   |                                          ^^^^^^^^^^^^\n+   |\n+   = help: only `code` is a valid nested attributes following the slug\n \n error: diagnostic slug not specified\n   --> $DIR/diagnostic-derive.rs:77:1\n    |\n LL | / #[diag(nonsense = \"...\", code = \"E0123\", slug = \"foo\")]\n LL | |\n LL | |\n+LL | |\n LL | | struct InvalidNestedStructAttr2 {}\n    | |__________________________________^\n    |\n    = help: specify the slug as the first argument to the `#[diag(...)]` attribute, such as `#[diag(typeck::example_error)]`\n \n error: `#[diag(nonsense = ...)]` is not a valid attribute\n-  --> $DIR/diagnostic-derive.rs:83:8\n+  --> $DIR/diagnostic-derive.rs:84:8\n    |\n LL | #[diag(nonsense = 4, code = \"E0123\", slug = \"foo\")]\n    |        ^^^^^^^^^^^^\n+\n+error: `#[diag(slug = ...)]` is not a valid attribute\n+  --> $DIR/diagnostic-derive.rs:84:38\n    |\n-   = help: first argument of the attribute should be the diagnostic slug\n+LL | #[diag(nonsense = 4, code = \"E0123\", slug = \"foo\")]\n+   |                                      ^^^^^^^^^^^^\n+   |\n+   = help: only `code` is a valid nested attributes following the slug\n \n error: diagnostic slug not specified\n-  --> $DIR/diagnostic-derive.rs:83:1\n+  --> $DIR/diagnostic-derive.rs:84:1\n    |\n LL | / #[diag(nonsense = 4, code = \"E0123\", slug = \"foo\")]\n LL | |\n LL | |\n+LL | |\n LL | | struct InvalidNestedStructAttr3 {}\n    | |__________________________________^\n    |\n    = help: specify the slug as the first argument to the `#[diag(...)]` attribute, such as `#[diag(typeck::example_error)]`\n \n error: `#[diag(slug = ...)]` is not a valid attribute\n-  --> $DIR/diagnostic-derive.rs:89:58\n+  --> $DIR/diagnostic-derive.rs:91:58\n    |\n LL | #[diag(typeck::ambiguous_lifetime_bound, code = \"E0123\", slug = \"foo\")]\n    |                                                          ^^^^^^^^^^^^\n    |\n    = help: only `code` is a valid nested attributes following the slug\n \n error: `#[suggestion = ...]` is not a valid attribute\n-  --> $DIR/diagnostic-derive.rs:96:5\n+  --> $DIR/diagnostic-derive.rs:98:5\n    |\n LL |     #[suggestion = \"bar\"]\n    |     ^^^^^^^^^^^^^^^^^^^^^\n \n error: specified multiple times\n-  --> $DIR/diagnostic-derive.rs:103:1\n+  --> $DIR/diagnostic-derive.rs:105:8\n    |\n LL | #[diag(typeck::ambiguous_lifetime_bound, code = \"E0456\")]\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n note: previously specified here\n-  --> $DIR/diagnostic-derive.rs:102:1\n+  --> $DIR/diagnostic-derive.rs:104:8\n    |\n LL | #[diag(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: specified multiple times\n-  --> $DIR/diagnostic-derive.rs:103:49\n+  --> $DIR/diagnostic-derive.rs:105:49\n    |\n LL | #[diag(typeck::ambiguous_lifetime_bound, code = \"E0456\")]\n    |                                                 ^^^^^^^\n    |\n note: previously specified here\n-  --> $DIR/diagnostic-derive.rs:102:49\n+  --> $DIR/diagnostic-derive.rs:104:49\n    |\n LL | #[diag(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n    |                                                 ^^^^^^^\n \n error: specified multiple times\n-  --> $DIR/diagnostic-derive.rs:109:65\n+  --> $DIR/diagnostic-derive.rs:111:65\n    |\n LL | #[diag(typeck::ambiguous_lifetime_bound, code = \"E0456\", code = \"E0457\")]\n    |                                                                 ^^^^^^^\n    |\n note: previously specified here\n-  --> $DIR/diagnostic-derive.rs:109:49\n+  --> $DIR/diagnostic-derive.rs:111:49\n    |\n LL | #[diag(typeck::ambiguous_lifetime_bound, code = \"E0456\", code = \"E0457\")]\n    |                                                 ^^^^^^^\n \n error: `#[diag(typeck::ambiguous_lifetime_bound)]` is not a valid attribute\n-  --> $DIR/diagnostic-derive.rs:114:42\n+  --> $DIR/diagnostic-derive.rs:116:42\n    |\n LL | #[diag(typeck::ambiguous_lifetime_bound, typeck::ambiguous_lifetime_bound, code = \"E0456\")]\n    |                                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: diagnostic slug must be the first argument\n \n error: diagnostic slug not specified\n-  --> $DIR/diagnostic-derive.rs:119:1\n+  --> $DIR/diagnostic-derive.rs:121:1\n    |\n LL | struct KindNotProvided {}\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: specify the slug as the first argument to the `#[diag(...)]` attribute, such as `#[diag(typeck::example_error)]`\n \n error: diagnostic slug not specified\n-  --> $DIR/diagnostic-derive.rs:122:1\n+  --> $DIR/diagnostic-derive.rs:124:1\n    |\n LL | / #[diag(code = \"E0456\")]\n LL | |\n@@ -186,33 +202,31 @@ LL | | struct SlugNotProvided {}\n    = help: specify the slug as the first argument to the `#[diag(...)]` attribute, such as `#[diag(typeck::example_error)]`\n \n error: the `#[primary_span]` attribute can only be applied to fields of type `Span` or `MultiSpan`\n-  --> $DIR/diagnostic-derive.rs:133:5\n+  --> $DIR/diagnostic-derive.rs:135:5\n    |\n LL |     #[primary_span]\n    |     ^^^^^^^^^^^^^^^\n \n error: `#[nonsense]` is not a valid attribute\n-  --> $DIR/diagnostic-derive.rs:141:5\n+  --> $DIR/diagnostic-derive.rs:143:5\n    |\n LL |     #[nonsense]\n    |     ^^^^^^^^^^^\n-   |\n-   = help: only `skip_arg`, `primary_span`, `label`, `note`, `help` and `subdiagnostic` are valid field attributes\n \n error: the `#[label(...)]` attribute can only be applied to fields of type `Span` or `MultiSpan`\n-  --> $DIR/diagnostic-derive.rs:158:5\n+  --> $DIR/diagnostic-derive.rs:160:5\n    |\n LL |     #[label(typeck::label)]\n    |     ^^^^^^^^^^^^^^^^^^^^^^^\n \n error: `name` doesn't refer to a field on this type\n-  --> $DIR/diagnostic-derive.rs:166:45\n+  --> $DIR/diagnostic-derive.rs:168:45\n    |\n LL |     #[suggestion(typeck::suggestion, code = \"{name}\")]\n    |                                             ^^^^^^^^\n \n error: invalid format string: expected `'}'` but string was terminated\n-  --> $DIR/diagnostic-derive.rs:171:16\n+  --> $DIR/diagnostic-derive.rs:173:16\n    |\n LL | #[derive(Diagnostic)]\n    |           -    ^ expected `'}'` in format string\n@@ -223,7 +237,7 @@ LL | #[derive(Diagnostic)]\n    = note: this error originates in the derive macro `Diagnostic` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: invalid format string: unmatched `}` found\n-  --> $DIR/diagnostic-derive.rs:181:15\n+  --> $DIR/diagnostic-derive.rs:183:15\n    |\n LL | #[derive(Diagnostic)]\n    |               ^ unmatched `}` in format string\n@@ -232,29 +246,47 @@ LL | #[derive(Diagnostic)]\n    = note: this error originates in the derive macro `Diagnostic` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: the `#[label(...)]` attribute can only be applied to fields of type `Span` or `MultiSpan`\n-  --> $DIR/diagnostic-derive.rs:201:5\n+  --> $DIR/diagnostic-derive.rs:203:5\n    |\n LL |     #[label(typeck::label)]\n    |     ^^^^^^^^^^^^^^^^^^^^^^^\n \n+error: suggestion without `code = \"...\"`\n+  --> $DIR/diagnostic-derive.rs:221:5\n+   |\n+LL |     #[suggestion(typeck::suggestion)]\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n error: `#[suggestion(nonsense = ...)]` is not a valid attribute\n-  --> $DIR/diagnostic-derive.rs:226:18\n+  --> $DIR/diagnostic-derive.rs:229:18\n    |\n LL |     #[suggestion(nonsense = \"bar\")]\n    |                  ^^^^^^^^^^^^^^^^\n    |\n-   = help: only `message`, `code` and `applicability` are valid field attributes\n+   = help: only `code` and `applicability` are valid nested attributes\n+\n+error: suggestion without `code = \"...\"`\n+  --> $DIR/diagnostic-derive.rs:229:5\n+   |\n+LL |     #[suggestion(nonsense = \"bar\")]\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: `#[suggestion(msg = ...)]` is not a valid attribute\n-  --> $DIR/diagnostic-derive.rs:234:18\n+  --> $DIR/diagnostic-derive.rs:238:18\n    |\n LL |     #[suggestion(msg = \"bar\")]\n    |                  ^^^^^^^^^^^\n    |\n-   = help: only `message`, `code` and `applicability` are valid field attributes\n+   = help: only `code` and `applicability` are valid nested attributes\n+\n+error: suggestion without `code = \"...\"`\n+  --> $DIR/diagnostic-derive.rs:238:5\n+   |\n+LL |     #[suggestion(msg = \"bar\")]\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: wrong field type for suggestion\n-  --> $DIR/diagnostic-derive.rs:256:5\n+  --> $DIR/diagnostic-derive.rs:261:5\n    |\n LL | /     #[suggestion(typeck::suggestion, code = \"This is suggested code\")]\n LL | |\n@@ -264,89 +296,89 @@ LL | |     suggestion: Applicability,\n    = help: `#[suggestion(...)]` should be applied to fields of type `Span` or `(Span, Applicability)`\n \n error: specified multiple times\n-  --> $DIR/diagnostic-derive.rs:272:24\n+  --> $DIR/diagnostic-derive.rs:277:24\n    |\n LL |     suggestion: (Span, Span, Applicability),\n    |                        ^^^^\n    |\n note: previously specified here\n-  --> $DIR/diagnostic-derive.rs:272:18\n+  --> $DIR/diagnostic-derive.rs:277:18\n    |\n LL |     suggestion: (Span, Span, Applicability),\n    |                  ^^^^\n \n error: specified multiple times\n-  --> $DIR/diagnostic-derive.rs:280:33\n+  --> $DIR/diagnostic-derive.rs:285:33\n    |\n LL |     suggestion: (Applicability, Applicability, Span),\n    |                                 ^^^^^^^^^^^^^\n    |\n note: previously specified here\n-  --> $DIR/diagnostic-derive.rs:280:18\n+  --> $DIR/diagnostic-derive.rs:285:18\n    |\n LL |     suggestion: (Applicability, Applicability, Span),\n    |                  ^^^^^^^^^^^^^\n \n error: `#[label = ...]` is not a valid attribute\n-  --> $DIR/diagnostic-derive.rs:287:5\n+  --> $DIR/diagnostic-derive.rs:292:5\n    |\n LL |     #[label = \"bar\"]\n    |     ^^^^^^^^^^^^^^^^\n \n error: specified multiple times\n-  --> $DIR/diagnostic-derive.rs:438:52\n+  --> $DIR/diagnostic-derive.rs:443:52\n    |\n LL |     #[suggestion(typeck::suggestion, code = \"...\", applicability = \"maybe-incorrect\")]\n    |                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n note: previously specified here\n-  --> $DIR/diagnostic-derive.rs:440:24\n+  --> $DIR/diagnostic-derive.rs:445:24\n    |\n LL |     suggestion: (Span, Applicability),\n    |                        ^^^^^^^^^^^^^\n \n error: invalid applicability\n-  --> $DIR/diagnostic-derive.rs:446:52\n+  --> $DIR/diagnostic-derive.rs:451:52\n    |\n LL |     #[suggestion(typeck::suggestion, code = \"...\", applicability = \"batman\")]\n    |                                                    ^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: `#[label(...)]` is not a valid attribute\n-  --> $DIR/diagnostic-derive.rs:509:5\n+error: `#[label(foo)]` is not a valid attribute\n+  --> $DIR/diagnostic-derive.rs:514:28\n    |\n LL |     #[label(typeck::label, foo)]\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                            ^^^\n+   |\n+   = help: a diagnostic slug must be the first argument to the attribute\n \n-error: `#[label(...)]` is not a valid attribute\n-  --> $DIR/diagnostic-derive.rs:517:5\n+error: `#[label(foo = ...)]` is not a valid attribute\n+  --> $DIR/diagnostic-derive.rs:522:28\n    |\n LL |     #[label(typeck::label, foo = \"...\")]\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                            ^^^^^^^^^^^\n \n-error: `#[label(...)]` is not a valid attribute\n-  --> $DIR/diagnostic-derive.rs:525:5\n+error: `#[label(foo(...))]` is not a valid attribute\n+  --> $DIR/diagnostic-derive.rs:530:28\n    |\n LL |     #[label(typeck::label, foo(\"...\"))]\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                            ^^^^^^^^^^\n \n error: `#[primary_span]` is not a valid attribute\n-  --> $DIR/diagnostic-derive.rs:538:5\n+  --> $DIR/diagnostic-derive.rs:543:5\n    |\n LL |     #[primary_span]\n    |     ^^^^^^^^^^^^^^^\n    |\n    = help: the `primary_span` field attribute is not valid for lint diagnostics\n \n error: `#[error(...)]` is not a valid attribute\n-  --> $DIR/diagnostic-derive.rs:558:1\n+  --> $DIR/diagnostic-derive.rs:563:1\n    |\n LL | #[error(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = help: `error` and `lint` have been replaced by `diag`\n \n error: diagnostic slug not specified\n-  --> $DIR/diagnostic-derive.rs:558:1\n+  --> $DIR/diagnostic-derive.rs:563:1\n    |\n LL | / #[error(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n LL | |\n@@ -358,15 +390,13 @@ LL | | struct ErrorAttribute {}\n    = help: specify the slug as the first argument to the `#[diag(...)]` attribute, such as `#[diag(typeck::example_error)]`\n \n error: `#[warn_(...)]` is not a valid attribute\n-  --> $DIR/diagnostic-derive.rs:565:1\n+  --> $DIR/diagnostic-derive.rs:570:1\n    |\n LL | #[warn_(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = help: `warn_` have been replaced by `warning`\n \n error: diagnostic slug not specified\n-  --> $DIR/diagnostic-derive.rs:565:1\n+  --> $DIR/diagnostic-derive.rs:570:1\n    |\n LL | / #[warn_(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n LL | |\n@@ -378,15 +408,13 @@ LL | | struct WarnAttribute {}\n    = help: specify the slug as the first argument to the `#[diag(...)]` attribute, such as `#[diag(typeck::example_error)]`\n \n error: `#[lint(...)]` is not a valid attribute\n-  --> $DIR/diagnostic-derive.rs:572:1\n+  --> $DIR/diagnostic-derive.rs:577:1\n    |\n LL | #[lint(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = help: `error` and `lint` have been replaced by `diag`\n \n error: diagnostic slug not specified\n-  --> $DIR/diagnostic-derive.rs:572:1\n+  --> $DIR/diagnostic-derive.rs:577:1\n    |\n LL | / #[lint(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n LL | |\n@@ -398,15 +426,13 @@ LL | | struct LintAttributeOnSessionDiag {}\n    = help: specify the slug as the first argument to the `#[diag(...)]` attribute, such as `#[diag(typeck::example_error)]`\n \n error: `#[lint(...)]` is not a valid attribute\n-  --> $DIR/diagnostic-derive.rs:579:1\n+  --> $DIR/diagnostic-derive.rs:584:1\n    |\n LL | #[lint(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = help: `error` and `lint` have been replaced by `diag`\n \n error: diagnostic slug not specified\n-  --> $DIR/diagnostic-derive.rs:579:1\n+  --> $DIR/diagnostic-derive.rs:584:1\n    |\n LL | / #[lint(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n LL | |\n@@ -418,77 +444,141 @@ LL | | struct LintAttributeOnLintDiag {}\n    = help: specify the slug as the first argument to the attribute, such as `#[diag(typeck::example_error)]`\n \n error: specified multiple times\n-  --> $DIR/diagnostic-derive.rs:588:52\n+  --> $DIR/diagnostic-derive.rs:593:52\n    |\n LL |     #[suggestion(typeck::suggestion, code = \"...\", code = \",,,\")]\n    |                                                    ^^^^^^^^^^^^\n    |\n note: previously specified here\n-  --> $DIR/diagnostic-derive.rs:588:38\n+  --> $DIR/diagnostic-derive.rs:593:38\n    |\n LL |     #[suggestion(typeck::suggestion, code = \"...\", code = \",,,\")]\n    |                                      ^^^^^^^^^^^^\n \n error: wrong types for suggestion\n-  --> $DIR/diagnostic-derive.rs:597:24\n+  --> $DIR/diagnostic-derive.rs:602:24\n    |\n LL |     suggestion: (Span, usize),\n    |                        ^^^^^\n    |\n    = help: `#[suggestion(...)]` on a tuple field must be applied to fields of type `(Span, Applicability)`\n \n error: wrong types for suggestion\n-  --> $DIR/diagnostic-derive.rs:605:17\n+  --> $DIR/diagnostic-derive.rs:610:17\n    |\n LL |     suggestion: (Span,),\n    |                 ^^^^^^^\n    |\n    = help: `#[suggestion(...)]` on a tuple field must be applied to fields of type `(Span, Applicability)`\n \n+error: suggestion without `code = \"...\"`\n+  --> $DIR/diagnostic-derive.rs:617:5\n+   |\n+LL |     #[suggestion(typeck::suggestion)]\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: `#[multipart_suggestion(...)]` is not a valid attribute\n+  --> $DIR/diagnostic-derive.rs:624:1\n+   |\n+LL | #[multipart_suggestion(typeck::suggestion)]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider creating a `Subdiagnostic` instead\n+\n+error: `#[multipart_suggestion(...)]` is not a valid attribute\n+  --> $DIR/diagnostic-derive.rs:627:1\n+   |\n+LL | #[multipart_suggestion()]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider creating a `Subdiagnostic` instead\n+\n+error: `#[multipart_suggestion(...)]` is not a valid attribute\n+  --> $DIR/diagnostic-derive.rs:631:5\n+   |\n+LL |     #[multipart_suggestion(typeck::suggestion)]\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider creating a `Subdiagnostic` instead\n+\n+error: `#[suggestion(...)]` is not a valid attribute\n+  --> $DIR/diagnostic-derive.rs:639:1\n+   |\n+LL | #[suggestion(typeck::suggestion, code = \"...\")]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: `#[label]` and `#[suggestion]` can only be applied to fields\n+\n+error: `#[label]` is not a valid attribute\n+  --> $DIR/diagnostic-derive.rs:648:1\n+   |\n+LL | #[label]\n+   | ^^^^^^^^\n+   |\n+   = help: `#[label]` and `#[suggestion]` can only be applied to fields\n+\n error: cannot find attribute `nonsense` in this scope\n   --> $DIR/diagnostic-derive.rs:53:3\n    |\n LL | #[nonsense(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n    |   ^^^^^^^^\n \n error: cannot find attribute `nonsense` in this scope\n-  --> $DIR/diagnostic-derive.rs:141:7\n+  --> $DIR/diagnostic-derive.rs:143:7\n    |\n LL |     #[nonsense]\n    |       ^^^^^^^^\n \n error: cannot find attribute `error` in this scope\n-  --> $DIR/diagnostic-derive.rs:558:3\n+  --> $DIR/diagnostic-derive.rs:563:3\n    |\n LL | #[error(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n    |   ^^^^^\n \n error: cannot find attribute `warn_` in this scope\n-  --> $DIR/diagnostic-derive.rs:565:3\n+  --> $DIR/diagnostic-derive.rs:570:3\n    |\n LL | #[warn_(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n    |   ^^^^^ help: a built-in attribute with a similar name exists: `warn`\n \n error: cannot find attribute `lint` in this scope\n-  --> $DIR/diagnostic-derive.rs:572:3\n+  --> $DIR/diagnostic-derive.rs:577:3\n    |\n LL | #[lint(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n    |   ^^^^ help: a built-in attribute with a similar name exists: `link`\n \n error: cannot find attribute `lint` in this scope\n-  --> $DIR/diagnostic-derive.rs:579:3\n+  --> $DIR/diagnostic-derive.rs:584:3\n    |\n LL | #[lint(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n    |   ^^^^ help: a built-in attribute with a similar name exists: `link`\n \n+error: cannot find attribute `multipart_suggestion` in this scope\n+  --> $DIR/diagnostic-derive.rs:624:3\n+   |\n+LL | #[multipart_suggestion(typeck::suggestion)]\n+   |   ^^^^^^^^^^^^^^^^^^^^\n+\n+error: cannot find attribute `multipart_suggestion` in this scope\n+  --> $DIR/diagnostic-derive.rs:627:3\n+   |\n+LL | #[multipart_suggestion()]\n+   |   ^^^^^^^^^^^^^^^^^^^^\n+\n+error: cannot find attribute `multipart_suggestion` in this scope\n+  --> $DIR/diagnostic-derive.rs:631:7\n+   |\n+LL |     #[multipart_suggestion(typeck::suggestion)]\n+   |       ^^^^^^^^^^^^^^^^^^^^\n+\n error[E0425]: cannot find value `nonsense` in module `rustc_errors::fluent`\n   --> $DIR/diagnostic-derive.rs:66:8\n    |\n LL | #[diag(nonsense, code = \"E0123\")]\n    |        ^^^^^^^^ not found in `rustc_errors::fluent`\n \n error[E0277]: the trait bound `Hello: IntoDiagnosticArg` is not satisfied\n-  --> $DIR/diagnostic-derive.rs:331:10\n+  --> $DIR/diagnostic-derive.rs:336:10\n    |\n LL | #[derive(Diagnostic)]\n    |          ^^^^^^^^^^ the trait `IntoDiagnosticArg` is not implemented for `Hello`\n@@ -501,7 +591,7 @@ LL |         arg: impl IntoDiagnosticArg,\n    |                   ^^^^^^^^^^^^^^^^^ required by this bound in `DiagnosticBuilder::<'a, G>::set_arg`\n    = note: this error originates in the derive macro `Diagnostic` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n-error: aborting due to 58 previous errors\n+error: aborting due to 72 previous errors\n \n Some errors have detailed explanations: E0277, E0425.\n For more information about an error, try `rustc --explain E0277`."}]}