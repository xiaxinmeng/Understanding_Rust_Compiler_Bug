{"sha": "14133d33bcc2e6e3939fa4b485294334366bf162", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE0MTMzZDMzYmNjMmU2ZTM5MzlmYTRiNDg1Mjk0MzM0MzY2YmYxNjI=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-05-24T22:34:17Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-05-24T22:34:17Z"}, "message": "trans: move exported_name's logic into symbol_names.", "tree": {"sha": "630bceab2553e473398fe886042f23578d25ba8d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/630bceab2553e473398fe886042f23578d25ba8d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/14133d33bcc2e6e3939fa4b485294334366bf162", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/14133d33bcc2e6e3939fa4b485294334366bf162", "html_url": "https://github.com/rust-lang/rust/commit/14133d33bcc2e6e3939fa4b485294334366bf162", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/14133d33bcc2e6e3939fa4b485294334366bf162/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "39184741bce5087337c3a8ee185b4c0a251d3e24", "url": "https://api.github.com/repos/rust-lang/rust/commits/39184741bce5087337c3a8ee185b4c0a251d3e24", "html_url": "https://github.com/rust-lang/rust/commit/39184741bce5087337c3a8ee185b4c0a251d3e24"}], "stats": {"total": 132, "additions": 62, "deletions": 70}, "files": [{"sha": "dffd0beafe51b78d50921fc629edb63071e837be", "filename": "src/librustc_trans/back/symbol_names.rs", "status": "modified", "additions": 45, "deletions": 19, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/14133d33bcc2e6e3939fa4b485294334366bf162/src%2Flibrustc_trans%2Fback%2Fsymbol_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14133d33bcc2e6e3939fa4b485294334366bf162/src%2Flibrustc_trans%2Fback%2Fsymbol_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fsymbol_names.rs?ref=14133d33bcc2e6e3939fa4b485294334366bf162", "patch": "@@ -97,17 +97,18 @@\n //! virtually impossible. Thus, symbol hash generation exclusively relies on\n //! DefPaths which are much more robust in the face of changes to the code base.\n \n-use common::{CrateContext, gensym_name};\n+use common::{CrateContext, SharedCrateContext, gensym_name};\n use monomorphize::Instance;\n use util::sha2::{Digest, Sha256};\n \n-use rustc::middle::cstore;\n+use rustc::middle::{cstore, weak_lang_items};\n use rustc::hir::def_id::DefId;\n use rustc::ty::{self, TyCtxt, TypeFoldable};\n-use rustc::ty::item_path::{ItemPathBuffer, RootMode};\n+use rustc::ty::item_path::{self, ItemPathBuffer, RootMode};\n use rustc::hir::map::definitions::{DefPath, DefPathData};\n \n use std::fmt::Write;\n+use syntax::attr;\n use syntax::parse::token::{self, InternedString};\n use serialize::hex::ToHex;\n \n@@ -134,7 +135,7 @@ fn def_path_to_string<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_path: &DefPath)\n     s\n }\n \n-fn get_symbol_hash<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+fn get_symbol_hash<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n \n                              // path to the item this name is for\n                              def_path: &DefPath,\n@@ -152,9 +153,9 @@ fn get_symbol_hash<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     debug!(\"get_symbol_hash(def_path={:?}, parameters={:?})\",\n            def_path, parameters);\n \n-    let tcx = ccx.tcx();\n+    let tcx = scx.tcx();\n \n-    let mut hash_state = ccx.symbol_hasher().borrow_mut();\n+    let mut hash_state = scx.symbol_hasher().borrow_mut();\n \n     hash_state.reset();\n \n@@ -187,22 +188,47 @@ fn get_symbol_hash<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     }\n }\n \n-pub fn exported_name<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                               instance: &Instance<'tcx>)\n+pub fn exported_name<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n+                               instance: Instance<'tcx>)\n                                -> String {\n-    let &Instance { def: mut def_id, ref substs } = instance;\n+    let Instance { def: def_id, ref substs } = instance;\n \n     debug!(\"exported_name(def_id={:?}, substs={:?})\",\n            def_id, substs);\n \n-    if let Some(node_id) = ccx.tcx().map.as_local_node_id(def_id) {\n-        if let Some(&src_def_id) = ccx.external_srcs().borrow().get(&node_id) {\n-            def_id = src_def_id;\n+    let node_id = scx.tcx().map.as_local_node_id(instance.def);\n+\n+    if let Some(id) = node_id {\n+        if scx.sess().plugin_registrar_fn.get() == Some(id) {\n+            let svh = &scx.link_meta().crate_hash;\n+            let idx = instance.def.index;\n+            return scx.sess().generate_plugin_registrar_symbol(svh, idx);\n         }\n     }\n \n-    let def_path = ccx.tcx().def_path(def_id);\n-    assert_eq!(def_path.krate, def_id.krate);\n+    // FIXME(eddyb) Precompute a custom symbol name based on attributes.\n+    let attrs;\n+    let attrs = if let Some(id) = node_id {\n+        scx.tcx().map.attrs(id)\n+    } else {\n+        attrs = scx.sess().cstore.item_attrs(def_id);\n+        &attrs[..]\n+    };\n+\n+    if let Some(name) = attr::find_export_name_attr(scx.sess().diagnostic(), attrs) {\n+        // Use provided name\n+        return name.to_string();\n+    }\n+\n+    if attr::contains_name(attrs, \"no_mangle\") {\n+        // Don't mangle\n+        return scx.tcx().item_name(instance.def).as_str().to_string()\n+    }\n+    if let Some(name) = weak_lang_items::link_name(attrs) {\n+        return name.to_string();\n+    }\n+\n+    let def_path = scx.tcx().def_path(def_id);\n \n     // We want to compute the \"type\" of this item. Unfortunately, some\n     // kinds of items (e.g., closures) don't have an entry in the\n@@ -211,11 +237,11 @@ pub fn exported_name<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     let mut ty_def_id = def_id;\n     let instance_ty;\n     loop {\n-        let key = ccx.tcx().def_key(ty_def_id);\n+        let key = scx.tcx().def_key(ty_def_id);\n         match key.disambiguated_data.data {\n             DefPathData::TypeNs(_) |\n             DefPathData::ValueNs(_) => {\n-                instance_ty = ccx.tcx().lookup_item_type(ty_def_id);\n+                instance_ty = scx.tcx().lookup_item_type(ty_def_id);\n                 break;\n             }\n             _ => {\n@@ -232,9 +258,9 @@ pub fn exported_name<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n \n     // Erase regions because they may not be deterministic when hashed\n     // and should not matter anyhow.\n-    let instance_ty = ccx.tcx().erase_regions(&instance_ty.ty);\n+    let instance_ty = scx.tcx().erase_regions(&instance_ty.ty);\n \n-    let hash = get_symbol_hash(ccx, &def_path, instance_ty, substs.types.as_slice());\n+    let hash = get_symbol_hash(scx, &def_path, instance_ty, substs.types.as_slice());\n \n     let mut buffer = SymbolPathBuffer {\n         names: Vec::with_capacity(def_path.data.len())\n@@ -271,7 +297,7 @@ pub fn internal_name_from_type_and_suffix<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>\n         data: vec![],\n         krate: cstore::LOCAL_CRATE,\n     };\n-    let hash = get_symbol_hash(ccx, &def_path, t, &[]);\n+    let hash = get_symbol_hash(ccx.shared(), &def_path, t, &[]);\n     mangle(path.iter().cloned(), Some(&hash[..]))\n }\n "}, {"sha": "f6a2b82fb1668df9fe1e668a87c26614fa8a2454", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 2, "deletions": 42, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/14133d33bcc2e6e3939fa4b485294334366bf162/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14133d33bcc2e6e3939fa4b485294334366bf162/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=14133d33bcc2e6e3939fa4b485294334366bf162", "patch": "@@ -2437,47 +2437,6 @@ pub fn create_entry_wrapper(ccx: &CrateContext, sp: Span, main_llfn: ValueRef) {\n     }\n }\n \n-pub fn exported_name<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                               instance: Instance<'tcx>,\n-                               attrs: &[ast::Attribute])\n-                               -> String {\n-    let id = ccx.tcx().map.as_local_node_id(instance.def).unwrap();\n-\n-    if ccx.sess().plugin_registrar_fn.get() == Some(id) {\n-        let svh = &ccx.link_meta().crate_hash;\n-        let idx = instance.def.index;\n-        return ccx.sess().generate_plugin_registrar_symbol(svh, idx);\n-    }\n-\n-    match ccx.external_srcs().borrow().get(&id) {\n-        Some(&did) => {\n-            let sym = ccx.sess().cstore.item_symbol(did);\n-            debug!(\"found item {} in other crate...\", sym);\n-            return sym;\n-        }\n-        None => {}\n-    }\n-\n-    match attr::find_export_name_attr(ccx.sess().diagnostic(), attrs) {\n-        // Use provided name\n-        Some(name) => name.to_string(),\n-        _ => {\n-            if attr::contains_name(attrs, \"no_mangle\") {\n-                // Don't mangle\n-                ccx.tcx().map.name(id).as_str().to_string()\n-            } else {\n-                match weak_lang_items::link_name(attrs) {\n-                    Some(name) => name.to_string(),\n-                    None => {\n-                        // Usual name mangling\n-                        symbol_names::exported_name(ccx, &instance)\n-                    }\n-                }\n-            }\n-        }\n-    }\n-}\n-\n pub fn imported_name(name: ast::Name, attrs: &[ast::Attribute]) -> InternedString {\n     match attr::first_attr_value_str_by_name(attrs, \"link_name\") {\n         Some(ln) => ln.clone(),\n@@ -2840,7 +2799,8 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         reachable_symbols.extend(syms.into_iter().filter(|did| {\n             sess.cstore.is_extern_item(shared_ccx.tcx(), *did)\n         }).map(|did| {\n-            sess.cstore.item_symbol(did)\n+            let instance = Instance::mono(shared_ccx.tcx(), did);\n+            symbol_names::exported_name(&shared_ccx, instance)\n         }));\n     }\n "}, {"sha": "bdeb1a6270f9550374466030d870e47cf1d73177", "filename": "src/librustc_trans/callee.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/14133d33bcc2e6e3939fa4b485294334366bf162/src%2Flibrustc_trans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14133d33bcc2e6e3939fa4b485294334366bf162/src%2Flibrustc_trans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcallee.rs?ref=14133d33bcc2e6e3939fa4b485294334366bf162", "patch": "@@ -512,7 +512,7 @@ fn get_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         Some(hir_map::NodeImplItem(&hir::ImplItem {\n             ref attrs, id, span, node: hir::ImplItemKind::Method(..), ..\n         })) => {\n-            let sym = exported_name(ccx, instance, attrs);\n+            let sym = symbol_names::exported_name(ccx.shared(), instance);\n \n             if declare::get_defined_value(ccx, &sym).is_some() {\n                 ccx.sess().span_fatal(span,\n@@ -530,7 +530,8 @@ fn get_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n \n         None => {\n             attrs = ccx.sess().cstore.item_attrs(def_id);\n-            (ccx.sess().cstore.item_symbol(def_id), &attrs[..], None)\n+            let sym = symbol_names::exported_name(ccx.shared(), instance);\n+            (sym, &attrs[..], None)\n         }\n \n         ref variant => {"}, {"sha": "8d273dfe1953cf7f60d2ecc54c8baca9fe5ff5d5", "filename": "src/librustc_trans/closure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/14133d33bcc2e6e3939fa4b485294334366bf162/src%2Flibrustc_trans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14133d33bcc2e6e3939fa4b485294334366bf162/src%2Flibrustc_trans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fclosure.rs?ref=14133d33bcc2e6e3939fa4b485294334366bf162", "patch": "@@ -150,7 +150,7 @@ fn get_or_create_closure_declaration<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         return llfn;\n     }\n \n-    let symbol = symbol_names::exported_name(ccx, &instance);\n+    let symbol = symbol_names::exported_name(ccx.shared(), instance);\n \n     // Compute the rust-call form of the closure call method.\n     let sig = &tcx.closure_type(closure_id, substs).sig;"}, {"sha": "6dca7fe5ed92c7810bad6e9c1232a6bdd89ae25f", "filename": "src/librustc_trans/consts.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/14133d33bcc2e6e3939fa4b485294334366bf162/src%2Flibrustc_trans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14133d33bcc2e6e3939fa4b485294334366bf162/src%2Flibrustc_trans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fconsts.rs?ref=14133d33bcc2e6e3939fa4b485294334366bf162", "patch": "@@ -19,7 +19,8 @@ use rustc::hir::def::Def;\n use rustc::hir::def_id::DefId;\n use rustc::hir::map as hir_map;\n use {abi, adt, closure, debuginfo, expr, machine};\n-use base::{self, exported_name, imported_name, push_ctxt};\n+use base::{self, imported_name, push_ctxt};\n+use back::symbol_names;\n use callee::Callee;\n use collector;\n use trans_item::TransItem;\n@@ -1021,13 +1022,13 @@ pub fn get_static<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, def_id: DefId)\n         let llty = type_of::type_of(ccx, ty);\n         match ccx.tcx().map.get(id) {\n             hir_map::NodeItem(&hir::Item {\n-                ref attrs, span, node: hir::ItemStatic(..), ..\n+                span, node: hir::ItemStatic(..), ..\n             }) => {\n                 // If this static came from an external crate, then\n                 // we need to get the symbol from metadata instead of\n                 // using the current crate's name/version\n                 // information in the hash of the symbol\n-                let sym = exported_name(ccx, instance, attrs);\n+                let sym = symbol_names::exported_name(ccx.shared(), instance);\n                 debug!(\"making {}\", sym);\n \n                 // Create the global before evaluating the initializer;\n@@ -1104,7 +1105,7 @@ pub fn get_static<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, def_id: DefId)\n     } else {\n         // FIXME(nagisa): perhaps the map of externs could be offloaded to llvm somehow?\n         // FIXME(nagisa): investigate whether it can be changed into define_global\n-        let name = ccx.sess().cstore.item_symbol(def_id);\n+        let name = symbol_names::exported_name(ccx.shared(), instance);\n         let g = declare::declare_global(ccx, &name, type_of::type_of(ccx, ty));\n         // Thread-local statics in some other crate need to *always* be linked\n         // against in a thread-local fashion, so we need to be sure to apply the"}, {"sha": "95d56432e1e3412cfdccc77ef0da020db5504da6", "filename": "src/librustc_trans/context.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/14133d33bcc2e6e3939fa4b485294334366bf162/src%2Flibrustc_trans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14133d33bcc2e6e3939fa4b485294334366bf162/src%2Flibrustc_trans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcontext.rs?ref=14133d33bcc2e6e3939fa4b485294334366bf162", "patch": "@@ -504,6 +504,10 @@ impl<'b, 'tcx> SharedCrateContext<'b, 'tcx> {\n                         scheme.generics.regions.map(|_| ty::ReStatic)))\n     }\n \n+    pub fn symbol_hasher(&self) -> &RefCell<Sha256> {\n+        &self.symbol_hasher\n+    }\n+\n     pub fn metadata_symbol_name(&self) -> String {\n         format!(\"rust_metadata_{}_{}\",\n                 self.link_meta().crate_name,"}, {"sha": "e781468f96c93920ff76ba6e5b3b6a5825c158cc", "filename": "src/librustc_trans/monomorphize.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/14133d33bcc2e6e3939fa4b485294334366bf162/src%2Flibrustc_trans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14133d33bcc2e6e3939fa4b485294334366bf162/src%2Flibrustc_trans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmonomorphize.rs?ref=14133d33bcc2e6e3939fa4b485294334366bf162", "patch": "@@ -88,7 +88,7 @@ pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         monomorphizing.insert(fn_id, depth + 1);\n     }\n \n-    let symbol = symbol_names::exported_name(ccx, &instance);\n+    let symbol = symbol_names::exported_name(ccx.shared(), instance);\n \n     debug!(\"monomorphize_fn mangled to {}\", symbol);\n     assert!(declare::get_defined_value(ccx, &symbol).is_none());"}, {"sha": "6777e98d4b81ab66e2c58964fe968436c10d3bda", "filename": "src/librustc_trans/symbol_names_test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/14133d33bcc2e6e3939fa4b485294334366bf162/src%2Flibrustc_trans%2Fsymbol_names_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14133d33bcc2e6e3939fa4b485294334366bf162/src%2Flibrustc_trans%2Fsymbol_names_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsymbol_names_test.rs?ref=14133d33bcc2e6e3939fa4b485294334366bf162", "patch": "@@ -53,7 +53,7 @@ impl<'a, 'tcx> SymbolNamesTest<'a, 'tcx> {\n             if attr.check_name(SYMBOL_NAME) {\n                 // for now, can only use on monomorphic names\n                 let instance = Instance::mono(self.ccx.shared(), def_id);\n-                let name = symbol_names::exported_name(self.ccx, &instance);\n+                let name = symbol_names::exported_name(self.ccx.shared(), instance);\n                 tcx.sess.span_err(attr.span, &format!(\"symbol-name({})\", name));\n             } else if attr.check_name(ITEM_PATH) {\n                 let path = tcx.item_path_str(def_id);"}]}