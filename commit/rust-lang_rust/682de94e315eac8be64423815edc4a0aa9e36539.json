{"sha": "682de94e315eac8be64423815edc4a0aa9e36539", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY4MmRlOTRlMzE1ZWFjOGJlNjQ0MjM4MTVlZGM0YTBhYTllMzY1Mzk=", "commit": {"author": {"name": "Jonas Schievink", "email": "jonasschievink@gmail.com", "date": "2020-09-12T18:36:29Z"}, "committer": {"name": "Jonas Schievink", "email": "jonasschievink@gmail.com", "date": "2020-09-18T19:23:01Z"}, "message": "Move inner items outside", "tree": {"sha": "d6c5905ad74213a99a1b847ccad5dea7e28f3cce", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d6c5905ad74213a99a1b847ccad5dea7e28f3cce"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/682de94e315eac8be64423815edc4a0aa9e36539", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/682de94e315eac8be64423815edc4a0aa9e36539", "html_url": "https://github.com/rust-lang/rust/commit/682de94e315eac8be64423815edc4a0aa9e36539", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/682de94e315eac8be64423815edc4a0aa9e36539/comments", "author": {"login": "jonas-schievink", "id": 1786438, "node_id": "MDQ6VXNlcjE3ODY0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1786438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonas-schievink", "html_url": "https://github.com/jonas-schievink", "followers_url": "https://api.github.com/users/jonas-schievink/followers", "following_url": "https://api.github.com/users/jonas-schievink/following{/other_user}", "gists_url": "https://api.github.com/users/jonas-schievink/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonas-schievink/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonas-schievink/subscriptions", "organizations_url": "https://api.github.com/users/jonas-schievink/orgs", "repos_url": "https://api.github.com/users/jonas-schievink/repos", "events_url": "https://api.github.com/users/jonas-schievink/events{/privacy}", "received_events_url": "https://api.github.com/users/jonas-schievink/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jonas-schievink", "id": 1786438, "node_id": "MDQ6VXNlcjE3ODY0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1786438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonas-schievink", "html_url": "https://github.com/jonas-schievink", "followers_url": "https://api.github.com/users/jonas-schievink/followers", "following_url": "https://api.github.com/users/jonas-schievink/following{/other_user}", "gists_url": "https://api.github.com/users/jonas-schievink/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonas-schievink/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonas-schievink/subscriptions", "organizations_url": "https://api.github.com/users/jonas-schievink/orgs", "repos_url": "https://api.github.com/users/jonas-schievink/repos", "events_url": "https://api.github.com/users/jonas-schievink/events{/privacy}", "received_events_url": "https://api.github.com/users/jonas-schievink/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cd5d7201ad1e5bf9d69e9a15e385ba03f678ad87", "url": "https://api.github.com/repos/rust-lang/rust/commits/cd5d7201ad1e5bf9d69e9a15e385ba03f678ad87", "html_url": "https://github.com/rust-lang/rust/commit/cd5d7201ad1e5bf9d69e9a15e385ba03f678ad87"}], "stats": {"total": 288, "additions": 144, "deletions": 144}, "files": [{"sha": "c8e700909d7aeda56ce13663fa945d091f92d118", "filename": "compiler/rustc_mir/src/transform/dest_prop.rs", "status": "modified", "additions": 144, "deletions": 144, "changes": 288, "blob_url": "https://github.com/rust-lang/rust/blob/682de94e315eac8be64423815edc4a0aa9e36539/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fdest_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/682de94e315eac8be64423815edc4a0aa9e36539/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fdest_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fdest_prop.rs?ref=682de94e315eac8be64423815edc4a0aa9e36539", "patch": "@@ -858,98 +858,98 @@ fn find_candidates<'a, 'tcx>(\n     tcx: TyCtxt<'tcx>,\n     body: &'a Body<'tcx>,\n ) -> Vec<CandidateAssignment<'tcx>> {\n-    struct FindAssignments<'a, 'tcx> {\n-        tcx: TyCtxt<'tcx>,\n-        body: &'a Body<'tcx>,\n-        candidates: Vec<CandidateAssignment<'tcx>>,\n-        ever_borrowed_locals: BitSet<Local>,\n-        locals_used_as_array_index: BitSet<Local>,\n-    }\n+    let mut visitor = FindAssignments {\n+        tcx,\n+        body,\n+        candidates: Vec::new(),\n+        ever_borrowed_locals: ever_borrowed_locals(body),\n+        locals_used_as_array_index: locals_used_as_array_index(body),\n+    };\n+    visitor.visit_body(body);\n+    visitor.candidates\n+}\n \n-    impl<'a, 'tcx> Visitor<'tcx> for FindAssignments<'a, 'tcx> {\n-        fn visit_statement(&mut self, statement: &Statement<'tcx>, location: Location) {\n-            if let StatementKind::Assign(box (\n-                dest,\n-                Rvalue::Use(Operand::Copy(src) | Operand::Move(src)),\n-            )) = &statement.kind\n-            {\n-                // `dest` must not have pointer indirection.\n-                if dest.is_indirect() {\n-                    return;\n-                }\n+struct FindAssignments<'a, 'tcx> {\n+    tcx: TyCtxt<'tcx>,\n+    body: &'a Body<'tcx>,\n+    candidates: Vec<CandidateAssignment<'tcx>>,\n+    ever_borrowed_locals: BitSet<Local>,\n+    locals_used_as_array_index: BitSet<Local>,\n+}\n \n-                // `src` must be a plain local.\n-                if !src.projection.is_empty() {\n-                    return;\n-                }\n+impl<'a, 'tcx> Visitor<'tcx> for FindAssignments<'a, 'tcx> {\n+    fn visit_statement(&mut self, statement: &Statement<'tcx>, location: Location) {\n+        if let StatementKind::Assign(box (\n+            dest,\n+            Rvalue::Use(Operand::Copy(src) | Operand::Move(src)),\n+        )) = &statement.kind\n+        {\n+            // `dest` must not have pointer indirection.\n+            if dest.is_indirect() {\n+                return;\n+            }\n \n-                // Since we want to replace `src` with `dest`, `src` must not be required.\n-                if is_local_required(src.local, self.body) {\n-                    return;\n-                }\n+            // `src` must be a plain local.\n+            if !src.projection.is_empty() {\n+                return;\n+            }\n \n-                // Can't optimize if both locals ever have their address taken (can introduce\n-                // aliasing).\n-                // FIXME: This can be smarter and take `StorageDead` into account (which\n-                // invalidates borrows).\n-                if self.ever_borrowed_locals.contains(dest.local)\n-                    && self.ever_borrowed_locals.contains(src.local)\n-                {\n-                    return;\n-                }\n+            // Since we want to replace `src` with `dest`, `src` must not be required.\n+            if is_local_required(src.local, self.body) {\n+                return;\n+            }\n \n-                assert_ne!(dest.local, src.local, \"self-assignments are UB\");\n+            // Can't optimize if both locals ever have their address taken (can introduce\n+            // aliasing).\n+            // FIXME: This can be smarter and take `StorageDead` into account (which\n+            // invalidates borrows).\n+            if self.ever_borrowed_locals.contains(dest.local)\n+                && self.ever_borrowed_locals.contains(src.local)\n+            {\n+                return;\n+            }\n \n-                // We can't replace locals occurring in `PlaceElem::Index` for now.\n-                if self.locals_used_as_array_index.contains(src.local) {\n-                    return;\n-                }\n+            assert_ne!(dest.local, src.local, \"self-assignments are UB\");\n \n-                // Handle the \"subtle case\" described above by rejecting any `dest` that is or\n-                // projects through a union.\n-                let is_union = |ty: Ty<'_>| {\n-                    if let ty::Adt(def, _) = ty.kind() {\n-                        if def.is_union() {\n-                            return true;\n-                        }\n+            // We can't replace locals occurring in `PlaceElem::Index` for now.\n+            if self.locals_used_as_array_index.contains(src.local) {\n+                return;\n+            }\n+\n+            // Handle the \"subtle case\" described above by rejecting any `dest` that is or\n+            // projects through a union.\n+            let is_union = |ty: Ty<'_>| {\n+                if let ty::Adt(def, _) = ty.kind() {\n+                    if def.is_union() {\n+                        return true;\n                     }\n+                }\n \n-                    false\n-                };\n-                let mut place_ty = PlaceTy::from_ty(self.body.local_decls[dest.local].ty);\n-                if is_union(place_ty.ty) {\n+                false\n+            };\n+            let mut place_ty = PlaceTy::from_ty(self.body.local_decls[dest.local].ty);\n+            if is_union(place_ty.ty) {\n+                return;\n+            }\n+            for elem in dest.projection {\n+                if let PlaceElem::Index(_) = elem {\n+                    // `dest` contains an indexing projection.\n                     return;\n                 }\n-                for elem in dest.projection {\n-                    if let PlaceElem::Index(_) = elem {\n-                        // `dest` contains an indexing projection.\n-                        return;\n-                    }\n \n-                    place_ty = place_ty.projection_ty(self.tcx, elem);\n-                    if is_union(place_ty.ty) {\n-                        return;\n-                    }\n+                place_ty = place_ty.projection_ty(self.tcx, elem);\n+                if is_union(place_ty.ty) {\n+                    return;\n                 }\n-\n-                self.candidates.push(CandidateAssignment {\n-                    dest: *dest,\n-                    src: src.local,\n-                    loc: location,\n-                });\n             }\n+\n+            self.candidates.push(CandidateAssignment {\n+                dest: *dest,\n+                src: src.local,\n+                loc: location,\n+            });\n         }\n     }\n-\n-    let mut visitor = FindAssignments {\n-        tcx,\n-        body,\n-        candidates: Vec::new(),\n-        ever_borrowed_locals: ever_borrowed_locals(body),\n-        locals_used_as_array_index: locals_used_as_array_index(body),\n-    };\n-    visitor.visit_body(body);\n-    visitor.candidates\n }\n \n /// Some locals are part of the function's interface and can not be removed.\n@@ -965,92 +965,92 @@ fn is_local_required(local: Local, body: &Body<'_>) -> bool {\n \n /// Walks MIR to find all locals that have their address taken anywhere.\n fn ever_borrowed_locals(body: &Body<'_>) -> BitSet<Local> {\n-    struct BorrowCollector {\n-        locals: BitSet<Local>,\n-    }\n+    let mut visitor = BorrowCollector { locals: BitSet::new_empty(body.local_decls.len()) };\n+    visitor.visit_body(body);\n+    visitor.locals\n+}\n \n-    impl<'tcx> Visitor<'tcx> for BorrowCollector {\n-        fn visit_rvalue(&mut self, rvalue: &Rvalue<'tcx>, location: Location) {\n-            self.super_rvalue(rvalue, location);\n+struct BorrowCollector {\n+    locals: BitSet<Local>,\n+}\n \n-            match rvalue {\n-                Rvalue::AddressOf(_, borrowed_place) | Rvalue::Ref(_, _, borrowed_place) => {\n-                    if !borrowed_place.is_indirect() {\n-                        self.locals.insert(borrowed_place.local);\n-                    }\n-                }\n+impl<'tcx> Visitor<'tcx> for BorrowCollector {\n+    fn visit_rvalue(&mut self, rvalue: &Rvalue<'tcx>, location: Location) {\n+        self.super_rvalue(rvalue, location);\n \n-                Rvalue::Cast(..)\n-                | Rvalue::Use(..)\n-                | Rvalue::Repeat(..)\n-                | Rvalue::Len(..)\n-                | Rvalue::BinaryOp(..)\n-                | Rvalue::CheckedBinaryOp(..)\n-                | Rvalue::NullaryOp(..)\n-                | Rvalue::UnaryOp(..)\n-                | Rvalue::Discriminant(..)\n-                | Rvalue::Aggregate(..)\n-                | Rvalue::ThreadLocalRef(..) => {}\n+        match rvalue {\n+            Rvalue::AddressOf(_, borrowed_place) | Rvalue::Ref(_, _, borrowed_place) => {\n+                if !borrowed_place.is_indirect() {\n+                    self.locals.insert(borrowed_place.local);\n+                }\n             }\n-        }\n \n-        fn visit_terminator(&mut self, terminator: &Terminator<'tcx>, location: Location) {\n-            self.super_terminator(terminator, location);\n+            Rvalue::Cast(..)\n+            | Rvalue::Use(..)\n+            | Rvalue::Repeat(..)\n+            | Rvalue::Len(..)\n+            | Rvalue::BinaryOp(..)\n+            | Rvalue::CheckedBinaryOp(..)\n+            | Rvalue::NullaryOp(..)\n+            | Rvalue::UnaryOp(..)\n+            | Rvalue::Discriminant(..)\n+            | Rvalue::Aggregate(..)\n+            | Rvalue::ThreadLocalRef(..) => {}\n+        }\n+    }\n \n-            match terminator.kind {\n-                TerminatorKind::Drop { place: dropped_place, .. }\n-                | TerminatorKind::DropAndReplace { place: dropped_place, .. } => {\n-                    self.locals.insert(dropped_place.local);\n-                }\n+    fn visit_terminator(&mut self, terminator: &Terminator<'tcx>, location: Location) {\n+        self.super_terminator(terminator, location);\n \n-                TerminatorKind::Abort\n-                | TerminatorKind::Assert { .. }\n-                | TerminatorKind::Call { .. }\n-                | TerminatorKind::FalseEdge { .. }\n-                | TerminatorKind::FalseUnwind { .. }\n-                | TerminatorKind::GeneratorDrop\n-                | TerminatorKind::Goto { .. }\n-                | TerminatorKind::Resume\n-                | TerminatorKind::Return\n-                | TerminatorKind::SwitchInt { .. }\n-                | TerminatorKind::Unreachable\n-                | TerminatorKind::Yield { .. }\n-                | TerminatorKind::InlineAsm { .. } => {}\n+        match terminator.kind {\n+            TerminatorKind::Drop { place: dropped_place, .. }\n+            | TerminatorKind::DropAndReplace { place: dropped_place, .. } => {\n+                self.locals.insert(dropped_place.local);\n             }\n+\n+            TerminatorKind::Abort\n+            | TerminatorKind::Assert { .. }\n+            | TerminatorKind::Call { .. }\n+            | TerminatorKind::FalseEdge { .. }\n+            | TerminatorKind::FalseUnwind { .. }\n+            | TerminatorKind::GeneratorDrop\n+            | TerminatorKind::Goto { .. }\n+            | TerminatorKind::Resume\n+            | TerminatorKind::Return\n+            | TerminatorKind::SwitchInt { .. }\n+            | TerminatorKind::Unreachable\n+            | TerminatorKind::Yield { .. }\n+            | TerminatorKind::InlineAsm { .. } => {}\n         }\n     }\n-\n-    let mut visitor = BorrowCollector { locals: BitSet::new_empty(body.local_decls.len()) };\n-    visitor.visit_body(body);\n-    visitor.locals\n }\n \n /// `PlaceElem::Index` only stores a `Local`, so we can't replace that with a full `Place`.\n ///\n /// Collect locals used as indices so we don't generate candidates that are impossible to apply\n /// later.\n fn locals_used_as_array_index(body: &Body<'_>) -> BitSet<Local> {\n-    struct IndexCollector {\n-        locals: BitSet<Local>,\n-    }\n-\n-    impl<'tcx> Visitor<'tcx> for IndexCollector {\n-        fn visit_projection_elem(\n-            &mut self,\n-            local: Local,\n-            proj_base: &[PlaceElem<'tcx>],\n-            elem: PlaceElem<'tcx>,\n-            context: PlaceContext,\n-            location: Location,\n-        ) {\n-            if let PlaceElem::Index(i) = elem {\n-                self.locals.insert(i);\n-            }\n-            self.super_projection_elem(local, proj_base, elem, context, location);\n-        }\n-    }\n-\n     let mut visitor = IndexCollector { locals: BitSet::new_empty(body.local_decls.len()) };\n     visitor.visit_body(body);\n     visitor.locals\n }\n+\n+struct IndexCollector {\n+    locals: BitSet<Local>,\n+}\n+\n+impl<'tcx> Visitor<'tcx> for IndexCollector {\n+    fn visit_projection_elem(\n+        &mut self,\n+        local: Local,\n+        proj_base: &[PlaceElem<'tcx>],\n+        elem: PlaceElem<'tcx>,\n+        context: PlaceContext,\n+        location: Location,\n+    ) {\n+        if let PlaceElem::Index(i) = elem {\n+            self.locals.insert(i);\n+        }\n+        self.super_projection_elem(local, proj_base, elem, context, location);\n+    }\n+}"}]}