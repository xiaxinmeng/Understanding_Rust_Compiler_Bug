{"sha": "08b1d83a46848dd7bd778aeae67a1e529e95d8cd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA4YjFkODNhNDY4NDhkZDdiZDc3OGFlYWU2N2ExZTUyOWU5NWQ4Y2Q=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2018-08-19T16:34:46Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2018-08-19T16:34:46Z"}, "message": "Merge branch 'master' into feature/core_convert_id", "tree": {"sha": "9153a34f91860b175afb24f904fd50ac09e77c4e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9153a34f91860b175afb24f904fd50ac09e77c4e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/08b1d83a46848dd7bd778aeae67a1e529e95d8cd", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJbeZwnCRBK7hj4Ov3rIwAAdHIIAJwO4oavSYk6yCeTip2Zq6t3\niDqpZUDR5mTCn2XsuqkQLOhdDIjYNgAUgWwekLd2N4pqRDa+719Cc1VDaV8XDmj7\nykIk0+o/HKIVSUvYjpSsp//gPKy5hpExfakYVSAdcLG/xV3KtnBnfAr7hZ0dLozd\nDIcx1qN9RepMOO+nhyY2Bo1v7OFoUrAcnH4BB/1A7062xSAlIjdsSneh92seUkd5\nUilYDZM+sYmNgwhUIqG+2jHJ2lv2QO4HJInjppB/sUISdQYt6FHgwlux8YyXlj5T\nj4tDnnphoGILt4GvEROHkopv9u0OgA1xQhFMCIcCc6AqDPYZ56N4lpMev4a9KVA=\n=xuSh\n-----END PGP SIGNATURE-----\n", "payload": "tree 9153a34f91860b175afb24f904fd50ac09e77c4e\nparent ac64ef33756d05557153e00211cdf8fcf65d4be3\nparent b355906919927ab3c879becd14392f023af883a1\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1534696486 +0200\ncommitter GitHub <noreply@github.com> 1534696486 +0200\n\nMerge branch 'master' into feature/core_convert_id"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/08b1d83a46848dd7bd778aeae67a1e529e95d8cd", "html_url": "https://github.com/rust-lang/rust/commit/08b1d83a46848dd7bd778aeae67a1e529e95d8cd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ac64ef33756d05557153e00211cdf8fcf65d4be3", "url": "https://api.github.com/repos/rust-lang/rust/commits/ac64ef33756d05557153e00211cdf8fcf65d4be3", "html_url": "https://github.com/rust-lang/rust/commit/ac64ef33756d05557153e00211cdf8fcf65d4be3"}, {"sha": "b355906919927ab3c879becd14392f023af883a1", "url": "https://api.github.com/repos/rust-lang/rust/commits/b355906919927ab3c879becd14392f023af883a1", "html_url": "https://github.com/rust-lang/rust/commit/b355906919927ab3c879becd14392f023af883a1"}], "stats": {"total": 546340, "additions": 351596, "deletions": 194744}, "files": [{"sha": "b223c8ac5fb841ed167a8c376eb1b6d5753ac0ec", "filename": ".gitattributes", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/.gitattributes", "raw_url": "https://github.com/rust-lang/rust/raw/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/.gitattributes", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.gitattributes?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd", "patch": "@@ -4,7 +4,8 @@\n *.cpp rust\n *.h rust\n *.rs rust\n+*.fixed linguist-language=Rust\n src/etc/installer/gfx/* binary\n *.woff binary\n src/vendor/** -text\n-Cargo.lock -merge\n+Cargo.lock -merge linguist-generated=false"}, {"sha": "9ffaa82e1c8b5dace88ca77f19aa55047dc4f7cc", "filename": ".gitignore", "status": "modified", "additions": 13, "deletions": 9, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/.gitignore", "raw_url": "https://github.com/rust-lang/rust/raw/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/.gitignore", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.gitignore?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd", "patch": "@@ -74,26 +74,30 @@ __pycache__/\n /obj/\n /rt/\n /rustllvm/\n-/src/libstd_unicode/DerivedCoreProperties.txt\n-/src/libstd_unicode/DerivedNormalizationProps.txt\n-/src/libstd_unicode/PropList.txt\n-/src/libstd_unicode/ReadMe.txt\n-/src/libstd_unicode/Scripts.txt\n-/src/libstd_unicode/SpecialCasing.txt\n-/src/libstd_unicode/UnicodeData.txt\n+/src/libcore/unicode/DerivedCoreProperties.txt\n+/src/libcore/unicode/DerivedNormalizationProps.txt\n+/src/libcore/unicode/PropList.txt\n+/src/libcore/unicode/ReadMe.txt\n+/src/libcore/unicode/Scripts.txt\n+/src/libcore/unicode/SpecialCasing.txt\n+/src/libcore/unicode/UnicodeData.txt\n /stage[0-9]+/\n /target\n+target/\n /test/\n /tmp/\n+tags\n+tags.*\n TAGS\n-TAGS.emacs\n-TAGS.vi\n+TAGS.*\n \\#*\n \\#*\\#\n config.mk\n config.stamp\n keywords.md\n lexer.ml\n+mir_dump\n+Session.vim\n src/etc/dl\n tmp.*.rs\n version.md"}, {"sha": "1631daac76c2ce07b0cc807666e4f2287a9bcfa8", "filename": ".gitmodules", "status": "modified", "additions": 20, "deletions": 7, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/.gitmodules", "raw_url": "https://github.com/rust-lang/rust/raw/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/.gitmodules", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.gitmodules?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd", "patch": "@@ -2,10 +2,6 @@\n \tpath = src/llvm\n \turl = https://github.com/rust-lang/llvm.git\n \tbranch = master\n-[submodule \"src/rt/hoedown\"]\n-\tpath = src/rt/hoedown\n-\turl = https://github.com/rust-lang/hoedown.git\n-\tbranch = rust-2015-09-21-do-not-delete\n [submodule \"src/jemalloc\"]\n \tpath = src/jemalloc\n \turl = https://github.com/rust-lang/jemalloc.git\n@@ -45,9 +41,26 @@\n [submodule \"src/dlmalloc\"]\n \tpath = src/dlmalloc\n \turl = https://github.com/alexcrichton/dlmalloc-rs.git\n-[submodule \"src/binaryen\"]\n-\tpath = src/binaryen\n-\turl = https://github.com/alexcrichton/binaryen.git\n [submodule \"src/doc/rust-by-example\"]\n \tpath = src/doc/rust-by-example\n \turl = https://github.com/rust-lang/rust-by-example\n+[submodule \"src/llvm-emscripten\"]\n+\tpath = src/llvm-emscripten\n+\turl = https://github.com/rust-lang/llvm\n+[submodule \"src/stdsimd\"]\n+\tpath = src/stdsimd\n+\turl = https://github.com/rust-lang-nursery/stdsimd\n+[submodule \"src/tools/lld\"]\n+\tpath = src/tools/lld\n+\turl = https://github.com/rust-lang/lld.git\n+[submodule \"src/libbacktrace\"]\n+\tpath = src/libbacktrace\n+\turl = https://github.com/rust-lang-nursery/libbacktrace\n+[submodule \"src/tools/lldb\"]\n+\tpath = src/tools/lldb\n+\turl = https://github.com/rust-lang-nursery/lldb/\n+\tbranch = rust-release-70\n+[submodule \"src/tools/clang\"]\n+\tpath = src/tools/clang\n+\turl = https://github.com/rust-lang-nursery/clang/\n+\tbranch = release_70"}, {"sha": "8f4287a438580315f099fb20566f3723e0e212af", "filename": ".mailmap", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/.mailmap", "raw_url": "https://github.com/rust-lang/rust/raw/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/.mailmap", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.mailmap?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd", "patch": "@@ -41,15 +41,17 @@ Boris Egorov <jightuse@gmail.com> <egorov@linux.com>\n Brandon Sanderson <singingboyo@gmail.com> Brandon Sanderson <singingboyo@hotmail.com>\n Brett Cannon <brett@python.org> Brett Cannon <brettcannon@users.noreply.github.com>\n Brian Anderson <banderson@mozilla.com> <andersrb@gmail.com>\n+Brian Anderson <banderson@mozilla.com> <banderson@mozilla.org>\n Brian Dawn <brian.t.dawn@gmail.com>\n Brian Leibig <brian@brianleibig.com> Brian Leibig <brian.leibig@gmail.com>\n Carl-Anton Ingmarsson <mail@carlanton.se> <ca.ingmarsson@gmail.com>\n-Carol (Nichols || Goulding) <carol.nichols@gmail.com>\n-Carol (Nichols || Goulding) <cnichols@thinkthroughmath.com>\n+Carol (Nichols || Goulding) <carol.nichols@gmail.com> <cnichols@thinkthroughmath.com>\n+Carol (Nichols || Goulding) <carol.nichols@gmail.com> Carol Nichols <carol.nichols@gmail.com>\n Carol Willing <carolcode@willingconsulting.com>\n Chris C Cerami <chrisccerami@users.noreply.github.com> Chris C Cerami <chrisccerami@gmail.com>\n Chris Pressey <cpressey@gmail.com>\n Chris Thorn <chris@thorn.co> Chris Thorn <thorn@thoughtbot.com>\n+Chris Vittal <christopher.vittal@gmail.com> Christopher Vittal <christopher.vittal@gmail.com>\n Clark Gaebel <cg.wowus.cg@gmail.com> <cgaebel@mozilla.com>\n Clinton Ryan <clint.ryan3@gmail.com>\n Corey Richardson <corey@octayn.net> Elaine \"See More\" Nemo <corey@octayn.net>\n@@ -94,9 +96,9 @@ Herman J. Radtke III <herman@hermanradtke.com> Herman J. Radtke III <hermanradtk\n Ilyong Cho <ilyoan@gmail.com>\n Ivan Ivaschenko <defuz.net@gmail.com>\n J. J. Weber <jjweber@gmail.com>\n-Jakub Bukaj <jakub@jakub.cc>\n-Jakub Bukaj <jakub@jakub.cc> <jakubw@jakubw.net>\n-Jakub Bukaj <jakub@jakub.cc> Jakub Bukaj <jakub.bukaj@yahoo.com>\n+Jakub Adam Wieczorek <jakub.adam.wieczorek@gmail.com> <jakub@jakub.cc>\n+Jakub Adam Wieczorek <jakub.adam.wieczorek@gmail.com> <jakubw@jakubw.net>\n+Jakub Adam Wieczorek <jakub.adam.wieczorek@gmail.com> <jakub.bukaj@yahoo.com>\n James Deng <cnjamesdeng@gmail.com> <cnJamesDeng@gmail.com>\n James Miller <bladeon@gmail.com> <james@aatch.net>\n James Perry <james.austin.perry@gmail.com>"}, {"sha": "b1701e4a65451aa82205f0c1af1211ef3e007ae2", "filename": ".travis.yml", "status": "modified", "additions": 65, "deletions": 47, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/.travis.yml", "raw_url": "https://github.com/rust-lang/rust/raw/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/.travis.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.travis.yml?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd", "patch": "@@ -3,6 +3,10 @@ sudo: required\n dist: trusty\n services:\n   - docker\n+addons:\n+  apt:\n+    packages:\n+      - gdb\n \n git:\n   depth: 2\n@@ -12,7 +16,7 @@ matrix:\n   fast_finish: true\n   include:\n     # Images used in testing PR and try-build should be run first.\n-    - env: IMAGE=x86_64-gnu-llvm-3.9 RUST_BACKTRACE=1\n+    - env: IMAGE=x86_64-gnu-llvm-5.0 RUST_BACKTRACE=1\n       if: type = pull_request OR branch = auto\n \n     - env: IMAGE=dist-x86_64-linux DEPLOY=1\n@@ -21,27 +25,29 @@ matrix:\n     # \"alternate\" deployments, these are \"nightlies\" but have LLVM assertions\n     # turned on, they're deployed to a different location primarily for\n     # additional testing.\n-    - env: IMAGE=dist-x86_64-linux DEPLOY_ALT=1\n+    - env: IMAGE=dist-x86_64-linux DEPLOY_ALT=1 CI_JOB_NAME=dist-x86_64-linux-alt\n       if: branch = try OR branch = auto\n \n     - env: >\n         RUST_CHECK_TARGET=dist\n-        RUST_CONFIGURE_ARGS=\"--enable-extended --enable-profiler\"\n+        RUST_CONFIGURE_ARGS=\"--enable-extended --enable-profiler --enable-lldb\"\n         SRC=.\n         DEPLOY_ALT=1\n         RUSTC_RETRY_LINKER_ON_SEGFAULT=1\n-        SCCACHE_ERROR_LOG=/tmp/sccache.log\n         MACOSX_DEPLOYMENT_TARGET=10.7\n         NO_LLVM_ASSERTIONS=1\n         NO_DEBUG_ASSERTIONS=1\n+        CI_JOB_NAME=dist-x86_64-apple-alt\n       os: osx\n-      osx_image: xcode7.3\n+      osx_image: xcode9.3-moar\n       if: branch = auto\n \n     # macOS builders. These are placed near the beginning because they are very\n     # slow to run.\n \n     # OSX builders running tests, these run the full test suite.\n+    # NO_DEBUG_ASSERTIONS=1 to make them go faster, but also do have some\n+    # runners that run `//ignore-debug` tests.\n     #\n     # Note that the compiler is compiled to target 10.8 here because the Xcode\n     # version that we're using, 8.2, cannot compile LLVM for OSX 10.7.\n@@ -50,27 +56,27 @@ matrix:\n         RUST_CONFIGURE_ARGS=\"--build=x86_64-apple-darwin --enable-sanitizers --enable-profiler\"\n         SRC=.\n         RUSTC_RETRY_LINKER_ON_SEGFAULT=1\n-        SCCACHE_ERROR_LOG=/tmp/sccache.log\n         MACOSX_DEPLOYMENT_TARGET=10.8\n         MACOSX_STD_DEPLOYMENT_TARGET=10.7\n         NO_LLVM_ASSERTIONS=1\n         NO_DEBUG_ASSERTIONS=1\n+        CI_JOB_NAME=x86_64-apple\n       os: osx\n-      osx_image: xcode8.3\n+      osx_image: xcode9.3-moar\n       if: branch = auto\n \n     - env: >\n         RUST_CHECK_TARGET=check\n         RUST_CONFIGURE_ARGS=--build=i686-apple-darwin\n         SRC=.\n         RUSTC_RETRY_LINKER_ON_SEGFAULT=1\n-        SCCACHE_ERROR_LOG=/tmp/sccache.log\n         MACOSX_DEPLOYMENT_TARGET=10.8\n         MACOSX_STD_DEPLOYMENT_TARGET=10.7\n         NO_LLVM_ASSERTIONS=1\n         NO_DEBUG_ASSERTIONS=1\n+        CI_JOB_NAME=i686-apple\n       os: osx\n-      osx_image: xcode8.3\n+      osx_image: xcode9.3-moar\n       if: branch = auto\n \n     # OSX builders producing releases. These do not run the full test suite and\n@@ -81,30 +87,30 @@ matrix:\n     # OSX 10.7 and `xcode7` is the latest Xcode able to compile LLVM for 10.7.\n     - env: >\n         RUST_CHECK_TARGET=dist\n-        RUST_CONFIGURE_ARGS=\"--build=i686-apple-darwin --enable-extended --enable-profiler\"\n+        RUST_CONFIGURE_ARGS=\"--build=i686-apple-darwin --enable-full-tools --enable-profiler --enable-lldb\"\n         SRC=.\n         DEPLOY=1\n         RUSTC_RETRY_LINKER_ON_SEGFAULT=1\n-        SCCACHE_ERROR_LOG=/tmp/sccache.log\n         MACOSX_DEPLOYMENT_TARGET=10.7\n         NO_LLVM_ASSERTIONS=1\n         NO_DEBUG_ASSERTIONS=1\n+        CI_JOB_NAME=dist-i686-apple\n       os: osx\n-      osx_image: xcode7.3\n+      osx_image: xcode9.3-moar\n       if: branch = auto\n \n     - env: >\n         RUST_CHECK_TARGET=dist\n-        RUST_CONFIGURE_ARGS=\"--target=aarch64-apple-ios,armv7-apple-ios,armv7s-apple-ios,i386-apple-ios,x86_64-apple-ios --enable-extended --enable-sanitizers --enable-profiler\"\n+        RUST_CONFIGURE_ARGS=\"--target=aarch64-apple-ios,armv7-apple-ios,armv7s-apple-ios,i386-apple-ios,x86_64-apple-ios --enable-full-tools --enable-sanitizers --enable-profiler --enable-lldb\"\n         SRC=.\n         DEPLOY=1\n         RUSTC_RETRY_LINKER_ON_SEGFAULT=1\n-        SCCACHE_ERROR_LOG=/tmp/sccache.log\n         MACOSX_DEPLOYMENT_TARGET=10.7\n         NO_LLVM_ASSERTIONS=1\n         NO_DEBUG_ASSERTIONS=1\n+        CI_JOB_NAME=dist-x86_64-apple\n       os: osx\n-      osx_image: xcode7.3\n+      osx_image: xcode9.3-moar\n       if: branch = auto\n \n     # Linux builders, remaining docker images\n@@ -169,26 +175,25 @@ matrix:\n     - env: IMAGE=x86_64-gnu-aux\n       if: branch = auto\n     - env: IMAGE=x86_64-gnu-tools\n-      if: branch = auto\n+      if: branch = auto OR (type = pull_request AND commit_message =~ /(?i:^update.*\\b(rls|rustfmt|clippy|miri)\\b)/)\n     - env: IMAGE=x86_64-gnu-debug\n       if: branch = auto\n     - env: IMAGE=x86_64-gnu-nopt\n       if: branch = auto\n     - env: IMAGE=x86_64-gnu-distcheck\n       if: branch = auto\n-    - env: IMAGE=x86_64-gnu-incremental\n-      if: branch = auto\n+    - env: IMAGE=mingw-check\n+      if: type = pull_request OR branch = auto\n \n     - stage: publish toolstate\n       if: branch = master AND type = push\n       before_install: []\n       install: []\n-      cache: false\n       sudo: false\n       script:\n         MESSAGE_FILE=$(mktemp -t msg.XXXXXX);\n         . src/ci/docker/x86_64-gnu-tools/repo.sh;\n-        commit_toolstate_change \"$MESSAGE_FILE\" \"$TRAVIS_BUILD_DIR/src/tools/publish_toolstate.py\" \"$(git rev-parse HEAD)\" \"$(git log --format=%s -n1 HEAD)\" \"$MESSAGE_FILE\"\n+        commit_toolstate_change \"$MESSAGE_FILE\" \"$TRAVIS_BUILD_DIR/src/tools/publish_toolstate.py\" \"$(git rev-parse HEAD)\" \"$(git log --format=%s -n1 HEAD)\" \"$MESSAGE_FILE\" \"$TOOLSTATE_REPO_ACCESS_TOKEN\";\n \n env:\n   global:\n@@ -198,10 +203,15 @@ env:\n     # AWS_SECRET_ACCESS_KEY=...\n     - secure: \"j96XxTVOSUf4s4r4htIxn/fvIa5DWbMgLqWl7r8z2QfgUwscmkMXAwXuFNc7s7bGTpV/+CgDiMFFM6BAFLGKutytIF6oA02s9b+usQYnM0th7YQ2AIgm9GtMTJCJp4AoyfFmh8F2faUICBZlfVLUJ34udHEe35vOklix+0k4WDo=\"\n     # TOOLSTATE_REPO_ACCESS_TOKEN=...\n-    - secure: \"cFh8thThqEJLC98XKI5pfqflUzOlxsYPRW20AWRaYOOgYHPTiGWypTXiPbGSKaeAXTZoOA+DpQtEmefc0U6lt9dHc7a/MIaK6isFurjlnKYiLOeTruzyu1z7PWCeZ/jKXsU2RK/88DBtlNwfMdaMIeuKj14IVfpepPPL71ETbuk=\"\n+    - secure: \"ESfcXqv4N2VMhqi2iIyw6da9VrsA78I4iR1asouCaq4hzTTrkB4WNRrfURy6xg72gQ4nMhtRJbB0/2jmc9Cu1+g2CzXtyiL223aJ5CKrXdcvbitopQSDfp07dMWm+UED+hNFEanpErKAeU/6FM3A+J+60PMk8MCF1h9tqNRISJw=\"\n \n before_install:\n-  - zcat $HOME/docker/rust-ci.tar.gz | docker load || true\n+  # We'll use the AWS cli to download/upload cached docker layers, so install\n+  # that here.\n+  - if [ \"$TRAVIS_OS_NAME\" = linux ]; then\n+      pip install --user awscli;\n+      export PATH=$PATH:$HOME/.local/bin;\n+    fi\n   - mkdir -p $HOME/rustsrc\n   # FIXME(#46924): these two commands are required to enable IPv6,\n   # they shouldn't exist, please revert once more official solutions appeared.\n@@ -221,12 +231,17 @@ install:\n         osx)\n           if [[ \"$RUST_CHECK_TARGET\" == dist ]]; then\n             travis_retry brew update &&\n-            travis_retry brew install xz;\n+            travis_retry brew install xz &&\n+            travis_retry brew install swig;\n           fi &&\n-          travis_retry curl -fo /usr/local/bin/sccache https://s3-us-west-1.amazonaws.com/rust-lang-ci2/rust-ci-mirror/2017-05-12-sccache-x86_64-apple-darwin &&\n+          travis_retry curl -fo /usr/local/bin/sccache https://s3-us-west-1.amazonaws.com/rust-lang-ci2/rust-ci-mirror/2018-04-02-sccache-x86_64-apple-darwin &&\n             chmod +x /usr/local/bin/sccache &&\n           travis_retry curl -fo /usr/local/bin/stamp https://s3-us-west-1.amazonaws.com/rust-lang-ci2/rust-ci-mirror/2017-03-17-stamp-x86_64-apple-darwin &&\n-            chmod +x /usr/local/bin/stamp\n+            chmod +x /usr/local/bin/stamp &&\n+          travis_retry curl -f http://releases.llvm.org/6.0.0/clang+llvm-6.0.0-x86_64-apple-darwin.tar.xz | tar xJf - &&\n+            export CC=`pwd`/clang+llvm-6.0.0-x86_64-apple-darwin/bin/clang &&\n+            export CXX=`pwd`/clang+llvm-6.0.0-x86_64-apple-darwin/bin/clang++ &&\n+            export AR=ar\n           ;;\n     esac\n \n@@ -241,6 +256,8 @@ before_script:\n           export RUN_SCRIPT=\"$RUN_SCRIPT && src/ci/run.sh\";\n       else\n           export RUN_SCRIPT=\"$RUN_SCRIPT && src/ci/docker/run.sh $IMAGE\";\n+          # Enable core dump on Linux.\n+          sudo sh -c 'echo \"/checkout/obj/cores/core.%p.%E\" > /proc/sys/kernel/core_pattern';\n       fi\n \n # Log time information from this machine and an external machine for insight into possible\n@@ -264,44 +281,46 @@ after_failure:\n       df -h;\n       du . | sort -nr | head -n100\n \n-  # One of these is the linux sccache log, one is the OSX sccache log. Instead\n-  # of worrying about what system we are just cat both. One of these commands\n-  # will fail but that's ok, they'll both get executed.\n-  - cat obj/tmp/sccache.log\n-  - cat /tmp/sccache.log\n-\n   # Random attempt at debugging currently. Just poking around in here to see if\n   # anything shows up.\n+\n+  # Dump backtrace for macOS\n   - ls -lat $HOME/Library/Logs/DiagnosticReports/\n   - find $HOME/Library/Logs/DiagnosticReports\n       -type f\n+      -name '*.crash'\n       -not -name '*.stage2-*.crash'\n       -not -name 'com.apple.CoreSimulator.CoreSimulatorService-*.crash'\n       -exec printf travis_fold\":start:crashlog\\n\\033[31;1m%s\\033[0m\\n\" {} \\;\n       -exec head -750 {} \\;\n-      -exec echo travis_fold\":\"end:crashlog \\;\n+      -exec echo travis_fold\":\"end:crashlog \\; || true\n+\n+  # Dump backtrace for Linux\n+  - ln -s . checkout &&\n+    for CORE in obj/cores/core.*; do\n+      EXE=$(echo $CORE | sed 's|obj/cores/core\\.[0-9]*\\.!checkout!\\(.*\\)|\\1|;y|!|/|');\n+      if [ -f \"$EXE\" ]; then\n+        printf travis_fold\":start:crashlog\\n\\033[31;1m%s\\033[0m\\n\" \"$CORE\";\n+        gdb -q -c \"$CORE\" \"$EXE\"\n+          -iex 'set auto-load off'\n+          -iex 'dir src/'\n+          -iex 'set sysroot .'\n+          -ex bt\n+          -ex q;\n+        echo travis_fold\":\"end:crashlog;\n+      fi;\n+    done || true\n+\n+  # see #50887\n+  - cat ./obj/build/x86_64-unknown-linux-gnu/native/asan/build/lib/asan/clang_rt.asan-dynamic-i386.vers || true\n \n   # attempt to debug anything killed by the oom killer on linux, just to see if\n   # it happened\n   - dmesg | grep -i kill\n \n-# Save tagged docker images we created and load them if they're available\n-# Travis saves caches whether the build failed or not, nuke rustsrc if\n-# the failure was while updating it (as it may be in a bad state)\n-# https://github.com/travis-ci/travis-ci/issues/4472\n-before_cache:\n-  - docker history -q rust-ci |\n-    grep -v missing |\n-    xargs docker save |\n-    gzip > $HOME/docker/rust-ci.tar.gz\n-\n notifications:\n   email: false\n \n-cache:\n-  directories:\n-    - $HOME/docker\n-\n before_deploy:\n   - mkdir -p deploy/$TRAVIS_COMMIT\n   - >\n@@ -312,7 +331,6 @@ before_deploy:\n           rm -rf obj/build/dist/doc &&\n           cp -r obj/build/dist/* deploy/$TRAVIS_COMMIT;\n       fi\n-  - travis_retry gem update --system\n   - ls -la deploy/$TRAVIS_COMMIT\n \n deploy:"}, {"sha": "d70b2b52aca1b136d70617a03d04b5c7bccd9969", "filename": "CODE_OF_CONDUCT.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/CODE_OF_CONDUCT.md", "raw_url": "https://github.com/rust-lang/rust/raw/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/CODE_OF_CONDUCT.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CODE_OF_CONDUCT.md?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd", "patch": "@@ -11,9 +11,9 @@ A version of this document [can be found online](https://www.rust-lang.org/condu\n * Please be kind and courteous. There's no need to be mean or rude.\n * Respect that people have differences of opinion and that every design or implementation choice carries a trade-off and numerous costs. There is seldom a right answer.\n * Please keep unstructured critique to a minimum. If you have solid ideas you want to experiment with, make a fork and see how it works.\n-* We will exclude you from interaction if you insult, demean or harass anyone. That is not welcome behaviour. We interpret the term \"harassment\" as including the definition in the <a href=\"http://citizencodeofconduct.org/\">Citizen Code of Conduct</a>; if you have any lack of clarity about what might be included in that concept, please read their definition. In particular, we don't tolerate behavior that excludes people in socially marginalized groups.\n+* We will exclude you from interaction if you insult, demean or harass anyone. That is not welcome behavior. We interpret the term \"harassment\" as including the definition in the <a href=\"http://citizencodeofconduct.org/\">Citizen Code of Conduct</a>; if you have any lack of clarity about what might be included in that concept, please read their definition. In particular, we don't tolerate behavior that excludes people in socially marginalized groups.\n * Private harassment is also unacceptable. No matter who you are, if you feel you have been or are being harassed or made uncomfortable by a community member, please contact one of the channel ops or any of the [Rust moderation team][mod_team] immediately. Whether you're a regular contributor or a newcomer, we care about making this community a safe place for you and we've got your back.\n-* Likewise any spamming, trolling, flaming, baiting or other attention-stealing behaviour is not welcome.\n+* Likewise any spamming, trolling, flaming, baiting or other attention-stealing behavior is not welcome.\n \n ## Moderation\n "}, {"sha": "ea9f2c194300507798ef377ea2f821035d82a5d1", "filename": "CONTRIBUTING.md", "status": "modified", "additions": 18, "deletions": 7, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/CONTRIBUTING.md", "raw_url": "https://github.com/rust-lang/rust/raw/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/CONTRIBUTING.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CONTRIBUTING.md?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd", "patch": "@@ -26,10 +26,10 @@ As a reminder, all contributors are expected to follow our [Code of Conduct][coc\n ## Feature Requests\n [feature-requests]: #feature-requests\n \n-To request a change to the way that the Rust language works, please open an\n-issue in the [RFCs repository](https://github.com/rust-lang/rfcs/issues/new)\n-rather than this one. New features and other significant language changes\n-must go through the RFC process.\n+To request a change to the way the Rust language works, please head over\n+to the [RFCs repository](https://github.com/rust-lang/rfcs) and view the \n+[README](https://github.com/rust-lang/rfcs/blob/master/README.md)\n+for instructions.\n \n ## Bug Reports\n [bug-reports]: #bug-reports\n@@ -47,6 +47,12 @@ as it's possible that someone else has already reported your error. This doesn't\n always work, and sometimes it's hard to know what to search for, so consider this\n extra credit. We won't mind if you accidentally file a duplicate report.\n \n+Similarly, to help others who encountered the bug find your issue,\n+consider filing an issue with a descriptive title, which contains information that might be unique to it.\n+This can be the language or compiler feature used, the conditions that trigger the bug,\n+or part of the error message if there is any.\n+An example could be: **\"impossible case reached\" on lifetime inference for impl Trait in return position**.\n+\n Opening an issue is as easy as following [this\n link](https://github.com/rust-lang/rust/issues/new) and filling out the fields.\n Here's a template that you can use to file a bug, though it's not necessary to\n@@ -121,6 +127,7 @@ configuration used in the build process. Some options to note:\n #### `[rust]`:\n - `debuginfo = true` - Build a compiler with debuginfo. Makes building rustc slower, but then you can use a debugger to debug `rustc`.\n - `debuginfo-lines = true` - An alternative to `debuginfo = true` that doesn't let you use a debugger, but doesn't make building rustc slower and still gives you line numbers in backtraces.\n+- `debuginfo-tools = true` - Build the extended tools with debuginfo.\n - `debug-assertions = true` - Makes the log output of `debug!` work.\n - `optimize = false` - Disable optimizations to speed up compilation of stage1 rust, but makes the stage1 compiler x100 slower.\n \n@@ -135,6 +142,8 @@ file. If you still have a `config.mk` file in your directory - from\n ### Building\n [building]: #building\n \n+A default configuration requires around 3.5 GB of disk space, whereas building a debug configuration may require more than 30 GB.\n+\n Dependencies\n - [build dependencies](README.md#building-from-source)\n - `gdb` 6.2.0 minimum, 7.1 or later recommended for test builds\n@@ -301,12 +310,12 @@ It's absolutely fine to have multiple build directories with different\n [pull-requests]: #pull-requests\n \n Pull requests are the primary mechanism we use to change Rust. GitHub itself\n-has some [great documentation][pull-requests] on using the Pull Request feature.\n+has some [great documentation][about-pull-requests] on using the Pull Request feature.\n We use the \"fork and pull\" model [described here][development-models], where\n contributors push changes to their personal fork and create pull requests to\n bring those changes into the source repository.\n \n-[pull-requests]: https://help.github.com/articles/about-pull-requests/\n+[about-pull-requests]: https://help.github.com/articles/about-pull-requests/\n [development-models]: https://help.github.com/articles/about-collaborative-development-models/\n \n Please make pull requests against the `master` branch.\n@@ -594,7 +603,7 @@ If you're looking for somewhere to start, check out the [E-easy][eeasy] tag.\n [inom]: https://github.com/rust-lang/rust/issues?q=is%3Aopen+is%3Aissue+label%3AI-nominated\n [eeasy]: https://github.com/rust-lang/rust/issues?q=is%3Aopen+is%3Aissue+label%3AE-easy\n [lru]: https://github.com/rust-lang/rust/issues?q=is%3Aissue+is%3Aopen+sort%3Aupdated-asc\n-[rfcbot]: https://github.com/dikaiosune/rust-dashboard/blob/master/RFCBOT.md\n+[rfcbot]: https://github.com/anp/rfcbot-rs/\n \n ## Out-of-tree Contributions\n [out-of-tree-contributions]: #out-of-tree-contributions\n@@ -623,6 +632,7 @@ For people new to Rust, and just starting to contribute, or even for\n more seasoned developers, some useful places to look for information\n are:\n \n+* The [rustc guide] contains information about how various parts of the compiler work\n * [Rust Forge][rustforge] contains additional documentation, including write-ups of how to achieve common tasks\n * The [Rust Internals forum][rif], a place to ask questions and\n   discuss Rust's internals\n@@ -635,6 +645,7 @@ are:\n * **Google!** ([search only in Rust Documentation][gsearchdocs] to find types, traits, etc. quickly)\n * Don't be afraid to ask! The Rust community is friendly and helpful.\n \n+[rustc guide]: https://rust-lang-nursery.github.io/rustc-guide/about-this-guide.html\n [gdfrustc]: http://manishearth.github.io/rust-internals-docs/rustc/\n [gsearchdocs]: https://www.google.com/search?q=site:doc.rust-lang.org+your+query+here\n [rif]: http://internals.rust-lang.org"}, {"sha": "e2d0ed77224e3d8344da35984bf03cf0088cfc1a", "filename": "COPYRIGHT", "status": "modified", "additions": 2, "deletions": 24, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/COPYRIGHT", "raw_url": "https://github.com/rust-lang/rust/raw/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/COPYRIGHT", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/COPYRIGHT?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd", "patch": "@@ -10,8 +10,8 @@ Copyrights in the Rust project are retained by their contributors. No\n copyright assignment is required to contribute to the Rust project.\n \n Some files include explicit copyright notices and/or license notices.\n-For full authorship information, see AUTHORS.txt and the version control\n-history.\n+For full authorship information, see the version control history or\n+https://thanks.rust-lang.org\n \n Except as otherwise noted (below and/or in individual files), Rust is\n licensed under the Apache License, Version 2.0 <LICENSE-APACHE> or\n@@ -192,28 +192,6 @@ their own copyright notices and license terms:\n     USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY\n     OF SUCH DAMAGE.\n \n-* Hoedown, the markdown parser, under src/rt/hoedown, is\n-  licensed as follows.\n-\n-    Copyright (c) 2008, Natacha Port\u00e9\n-    Copyright (c) 2011, Vicent Mart\u00ed\n-    Copyright (c) 2013, Devin Torres and the Hoedown authors\n-\n-    Permission to use, copy, modify, and distribute this\n-    software for any purpose with or without fee is hereby\n-    granted, provided that the above copyright notice and\n-    this permission notice appear in all copies.\n-\n-    THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR\n-    DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE\n-    INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND\n-    FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY\n-    SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR\n-    ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA\n-    OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE\n-    OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN\n-    CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n-\n * libbacktrace, under src/libbacktrace:\n \n     Copyright (C) 2012-2014 Free Software Foundation, Inc."}, {"sha": "a2acfe8b478e28579028b5097644cbb8e759ca8a", "filename": "README.md", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd", "patch": "@@ -38,6 +38,7 @@ Read [\"Installation\"] from [The Book].\n 3. Build and install:\n \n     ```sh\n+    $ git submodule update --init --recursive --progress\n     $ ./x.py build && sudo ./x.py install\n     ```\n \n@@ -119,7 +120,7 @@ shell with:\n > python x.py build\n ```\n \n-Currently building Rust only works with some known versions of Visual Studio. If\n+Currently, building Rust only works with some known versions of Visual Studio. If\n you have a more recent version installed the build system doesn't understand\n then you may need to force rustbuild to use an older version. This can be done\n by manually calling the appropriate vcvars file before running the bootstrap.\n@@ -129,14 +130,11 @@ CALL \"C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\bin\\amd64\\vcvars64.\n python x.py build\n ```\n \n-If you are seeing build failure when compiling `rustc_binaryen`, make sure the path\n-length of the rust folder is not longer than 22 characters.\n-\n #### Specifying an ABI\n [specifying-an-abi]: #specifying-an-abi\n \n Each specific ABI can also be used from either environment (for example, using\n-the GNU ABI in powershell) by using an explicit build triple. The available\n+the GNU ABI in PowerShell) by using an explicit build triple. The available\n Windows build triples are:\n - GNU ABI (using GCC)\n     - `i686-pc-windows-gnu`\n@@ -182,7 +180,7 @@ the ABI used. I.e., if the ABI was `x86_64-pc-windows-msvc`, the directory will\n [notes]: #notes\n \n Since the Rust compiler is written in Rust, it must be built by a\n-precompiled \"snapshot\" version of itself (made in an earlier state of\n+precompiled \"snapshot\" version of itself (made in an earlier stage of\n development). As such, source builds require a connection to the Internet, to\n fetch snapshots, and an OS that can execute the available snapshot binaries.\n \n@@ -227,9 +225,16 @@ variety of channels on Mozilla's IRC network, irc.mozilla.org. The\n most popular channel is [#rust], a venue for general discussion about\n Rust. And a good place to ask for help would be [#rust-beginners].\n \n+The [rustc guide] might be a good place to start if you want to find out how\n+various parts of the compiler work.\n+\n+Also, you may find the [rustdocs for the compiler itself][rustdocs] useful.\n+\n [IRC]: https://en.wikipedia.org/wiki/Internet_Relay_Chat\n [#rust]: irc://irc.mozilla.org/rust\n [#rust-beginners]: irc://irc.mozilla.org/rust-beginners\n+[rustc guide]: https://rust-lang-nursery.github.io/rustc-guide/about-this-guide.html\n+[rustdocs]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc/\n \n ## License\n [license]: #license"}, {"sha": "1f7ffb53d3cadcfcb6811da4cafcc7583b5c276a", "filename": "RELEASES.md", "status": "modified", "additions": 815, "deletions": 4, "changes": 819, "blob_url": "https://github.com/rust-lang/rust/blob/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/RELEASES.md", "raw_url": "https://github.com/rust-lang/rust/raw/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/RELEASES.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/RELEASES.md?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd", "patch": "@@ -1,3 +1,814 @@\n+Version 1.28.0 (2018-08-02)\n+===========================\n+\n+Language\n+--------\n+- [The `#[repr(transparent)]` attribute is now stable.][51562] This attribute\n+  allows a Rust newtype wrapper (`struct NewType<T>(T);`) to be represented as\n+  the inner type across Foreign Function Interface (FFI) boundaries.\n+- [The keywords `pure`, `sizeof`, `alignof`, and `offsetof` have been unreserved\n+  and can now be used as identifiers.][51196]\n+- [The `GlobalAlloc` trait and `#[global_allocator]` attribute are now\n+  stable.][51241] This will allow users to specify a global allocator for\n+  their program.\n+- [Unit test functions marked with the `#[test]` attribute can now return\n+  `Result<(), E: Debug>` in addition to `()`.][51298]\n+- [The `lifetime` specifier for `macro_rules!` is now stable.][50385] This\n+  allows macros to easily target lifetimes.\n+\n+Compiler\n+--------\n+- [The `s` and `z` optimisation levels are now stable.][50265] These optimisations\n+  prioritise making smaller binary sizes. `z` is the same as `s` with the\n+  exception that it does not vectorise loops, which typically results in an even\n+  smaller binary.\n+- [The short error format is now stable.][49546] Specified with\n+  `--error-format=short` this option will provide a more compressed output of\n+  rust error messages.\n+- [Added a lint warning when you have duplicated `macro_export`s.][50143]\n+- [Reduced the number of allocations in the macro parser.][50855] This can\n+  improve compile times of macro heavy crates on average by 5%.\n+\n+Libraries\n+---------\n+- [Implemented `Default` for `&mut str`.][51306]\n+- [Implemented `From<bool>` for all integer and unsigned number types.][50554]\n+- [Implemented `Extend` for `()`.][50234]\n+- [The `Debug` implementation of `time::Duration` should now be more easily\n+  human readable.][50364] Previously a `Duration` of one second would printed as\n+  `Duration { secs: 1, nanos: 0 }` and will now be printed as `1s`.\n+- [Implemented `From<&String>` for `Cow<str>`, `From<&Vec<T>>` for `Cow<[T]>`,\n+  `From<Cow<CStr>>` for `CString`, `From<CString>, From<CStr>, From<&CString>`\n+  for `Cow<CStr>`, `From<OsString>, From<OsStr>, From<&OsString>` for\n+  `Cow<OsStr>`, `From<&PathBuf>` for `Cow<Path>`, and `From<Cow<Path>>`\n+  for `PathBuf`.][50170]\n+- [Implemented `Shl` and `Shr` for `Wrapping<u128>`\n+  and `Wrapping<i128>`.][50465]\n+- [`DirEntry::metadata` now uses `fstatat` instead of `lstat` when\n+  possible.][51050] This can provide up to a 40% speed increase.\n+- [Improved error messages when using `format!`.][50610]\n+\n+Stabilized APIs\n+---------------\n+- [`Iterator::step_by`]\n+- [`Path::ancestors`]\n+- [`SystemTime::UNIX_EPOCH`]\n+- [`alloc::GlobalAlloc`]\n+- [`alloc::Layout`]\n+- [`alloc::LayoutErr`]\n+- [`alloc::System`]\n+- [`alloc::alloc`]\n+- [`alloc::alloc_zeroed`]\n+- [`alloc::dealloc`]\n+- [`alloc::realloc`]\n+- [`alloc::handle_alloc_error`]\n+- [`btree_map::Entry::or_default`]\n+- [`fmt::Alignment`]\n+- [`hash_map::Entry::or_default`]\n+- [`iter::repeat_with`]\n+- [`num::NonZeroUsize`]\n+- [`num::NonZeroU128`]\n+- [`num::NonZeroU16`]\n+- [`num::NonZeroU32`]\n+- [`num::NonZeroU64`]\n+- [`num::NonZeroU8`]\n+- [`ops::RangeBounds`]\n+- [`slice::SliceIndex`]\n+- [`slice::from_mut`]\n+- [`slice::from_ref`]\n+- [`{Any + Send + Sync}::downcast_mut`]\n+- [`{Any + Send + Sync}::downcast_ref`]\n+- [`{Any + Send + Sync}::is`]\n+\n+Cargo\n+-----\n+- [Cargo will now no longer allow you to publish crates with build scripts that\n+  modify the `src` directory.][cargo/5584] The `src` directory in a crate should be\n+  considered to be immutable.\n+\n+Misc\n+----\n+- [The `suggestion_applicability` field in `rustc`'s json output is now\n+  stable.][50486] This will allow dev tools to check whether a code suggestion\n+  would apply to them.\n+\n+Compatibility Notes\n+-------------------\n+- [Rust will consider trait objects with duplicated constraints to be the same\n+  type as without the duplicated constraint.][51276] For example the below code will\n+  now fail to compile.\n+  ```rust\n+  trait Trait {}\n+\n+  impl Trait + Send {\n+      fn test(&self) { println!(\"one\"); } //~ ERROR duplicate definitions with name `test`\n+  }\n+\n+  impl Trait + Send + Send {\n+      fn test(&self) { println!(\"two\"); }\n+  }\n+  ```\n+\n+[49546]: https://github.com/rust-lang/rust/pull/49546/\n+[50143]: https://github.com/rust-lang/rust/pull/50143/\n+[50170]: https://github.com/rust-lang/rust/pull/50170/\n+[50234]: https://github.com/rust-lang/rust/pull/50234/\n+[50265]: https://github.com/rust-lang/rust/pull/50265/\n+[50364]: https://github.com/rust-lang/rust/pull/50364/\n+[50385]: https://github.com/rust-lang/rust/pull/50385/\n+[50465]: https://github.com/rust-lang/rust/pull/50465/\n+[50486]: https://github.com/rust-lang/rust/pull/50486/\n+[50554]: https://github.com/rust-lang/rust/pull/50554/\n+[50610]: https://github.com/rust-lang/rust/pull/50610/\n+[50855]: https://github.com/rust-lang/rust/pull/50855/\n+[51050]: https://github.com/rust-lang/rust/pull/51050/\n+[51196]: https://github.com/rust-lang/rust/pull/51196/\n+[51200]: https://github.com/rust-lang/rust/pull/51200/\n+[51241]: https://github.com/rust-lang/rust/pull/51241/\n+[51276]: https://github.com/rust-lang/rust/pull/51276/\n+[51298]: https://github.com/rust-lang/rust/pull/51298/\n+[51306]: https://github.com/rust-lang/rust/pull/51306/\n+[51562]: https://github.com/rust-lang/rust/pull/51562/\n+[cargo/5584]: https://github.com/rust-lang/cargo/pull/5584/\n+[`Iterator::step_by`]: https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.step_by\n+[`Path::ancestors`]: https://doc.rust-lang.org/std/path/struct.Path.html#method.ancestors\n+[`SystemTime::UNIX_EPOCH`]: https://doc.rust-lang.org/std/time/struct.SystemTime.html#associatedconstant.UNIX_EPOCH\n+[`alloc::GlobalAlloc`]: https://doc.rust-lang.org/std/alloc/trait.GlobalAlloc.html\n+[`alloc::Layout`]: https://doc.rust-lang.org/std/alloc/struct.Layout.html\n+[`alloc::LayoutErr`]: https://doc.rust-lang.org/std/alloc/struct.LayoutErr.html\n+[`alloc::System`]: https://doc.rust-lang.org/std/alloc/struct.System.html\n+[`alloc::alloc`]: https://doc.rust-lang.org/std/alloc/fn.alloc.html\n+[`alloc::alloc_zeroed`]: https://doc.rust-lang.org/std/alloc/fn.alloc_zeroed.html\n+[`alloc::dealloc`]: https://doc.rust-lang.org/std/alloc/fn.dealloc.html\n+[`alloc::realloc`]: https://doc.rust-lang.org/std/alloc/fn.realloc.html\n+[`alloc::handle_alloc_error`]: https://doc.rust-lang.org/std/alloc/fn.handle_alloc_error.html\n+[`btree_map::Entry::or_default`]: https://doc.rust-lang.org/std/collections/btree_map/enum.Entry.html#method.or_default\n+[`fmt::Alignment`]: https://doc.rust-lang.org/std/fmt/enum.Alignment.html\n+[`hash_map::Entry::or_default`]: https://doc.rust-lang.org/std/collections/hash_map/enum.Entry.html#method.or_default\n+[`iter::repeat_with`]: https://doc.rust-lang.org/std/iter/fn.repeat_with.html\n+[`num::NonZeroUsize`]: https://doc.rust-lang.org/std/num/struct.NonZeroUsize.html\n+[`num::NonZeroU128`]: https://doc.rust-lang.org/std/num/struct.NonZeroU128.html\n+[`num::NonZeroU16`]: https://doc.rust-lang.org/std/num/struct.NonZeroU16.html\n+[`num::NonZeroU32`]: https://doc.rust-lang.org/std/num/struct.NonZeroU32.html\n+[`num::NonZeroU64`]: https://doc.rust-lang.org/std/num/struct.NonZeroU64.html\n+[`num::NonZeroU8`]: https://doc.rust-lang.org/std/num/struct.NonZeroU8.html\n+[`ops::RangeBounds`]: https://doc.rust-lang.org/std/ops/trait.RangeBounds.html\n+[`slice::SliceIndex`]: https://doc.rust-lang.org/std/slice/trait.SliceIndex.html\n+[`slice::from_mut`]: https://doc.rust-lang.org/std/slice/fn.from_mut.html\n+[`slice::from_ref`]: https://doc.rust-lang.org/std/slice/fn.from_ref.html\n+[`{Any + Send + Sync}::downcast_mut`]: https://doc.rust-lang.org/std/any/trait.Any.html#method.downcast_mut-2\n+[`{Any + Send + Sync}::downcast_ref`]: https://doc.rust-lang.org/std/any/trait.Any.html#method.downcast_ref-2\n+[`{Any + Send + Sync}::is`]: https://doc.rust-lang.org/std/any/trait.Any.html#method.is-2\n+\n+Version 1.27.2 (2018-07-20)\n+===========================\n+\n+Compatibility Notes\n+-------------------\n+\n+- The borrow checker was fixed to avoid potential unsoundness when using\n+  match ergonomics: [#52213][52213].\n+\n+[52213]: https://github.com/rust-lang/rust/issues/52213\n+\n+Version 1.27.1 (2018-07-10)\n+===========================\n+\n+Security Notes\n+--------------\n+\n+- rustdoc would execute plugins in the /tmp/rustdoc/plugins directory\n+  when running, which enabled executing code as some other user on a\n+  given machine. This release fixes that vulnerability; you can read\n+  more about this on the [blog][rustdoc-sec]. The associated CVE is [CVE-2018-1000622].\n+\n+  Thank you to Red Hat for responsibily disclosing this vulnerability to us.\n+\n+Compatibility Notes\n+-------------------\n+\n+- The borrow checker was fixed to avoid an additional potential unsoundness when using\n+  match ergonomics: [#51415][51415], [#49534][49534].\n+\n+[51415]: https://github.com/rust-lang/rust/issues/51415\n+[49534]: https://github.com/rust-lang/rust/issues/49534\n+[rustdoc-sec]: https://blog.rust-lang.org/2018/07/06/security-advisory-for-rustdoc.html\n+[CVE-2018-1000622]: https://cve.mitre.org/cgi-bin/cvename.cgi?name=%20CVE-2018-1000622\n+\n+Version 1.27.0 (2018-06-21)\n+==========================\n+\n+Language\n+--------\n+- [Removed 'proc' from the reserved keywords list.][49699] This allows `proc` to\n+  be used as an identifier.\n+- [The dyn syntax is now available.][49968] This syntax is equivalent to the\n+  bare `Trait` syntax, and should make it clearer when being used in tandem with\n+  `impl Trait`. Since it is equivalent to the following syntax:\n+  `&Trait == &dyn Trait`, `&mut Trait == &mut dyn Trait`, and\n+  `Box<Trait> == Box<dyn Trait>`.\n+- [Attributes on generic parameters such as types and lifetimes are\n+  now stable.][48851] e.g.\n+  `fn foo<#[lifetime_attr] 'a, #[type_attr] T: 'a>() {}`\n+- [The `#[must_use]` attribute can now also be used on functions as well as\n+  types.][48925] It provides a lint that by default warns users when the\n+  value returned by a function has not been used.\n+\n+Compiler\n+--------\n+- [Added the `armv5te-unknown-linux-musleabi` target.][50423]\n+\n+Libraries\n+---------\n+- [SIMD (Single Instruction Multiple Data) on x86/x86_64 is now stable.][49664]\n+  This includes [`arch::x86`] & [`arch::x86_64`] modules which contain\n+  SIMD intrinsics, a new macro called `is_x86_feature_detected!`, the\n+  `#[target_feature(enable=\"\")]` attribute, and adding `target_feature = \"\"` to\n+  the `cfg` attribute.\n+- [A lot of methods for `[u8]`, `f32`, and `f64` previously only available in\n+  std are now available in core.][49896]\n+- [The generic `Rhs` type parameter on `ops::{Shl, ShlAssign, Shr}` now defaults\n+  to `Self`.][49630]\n+- [`std::str::replace` now has the `#[must_use]` attribute][50177] to clarify\n+  that the operation isn't done in place.\n+- [`Clone::clone`, `Iterator::collect`, and `ToOwned::to_owned` now have\n+  the `#[must_use]` attribute][49533] to warn about unused potentially\n+  expensive allocations.\n+\n+Stabilized APIs\n+---------------\n+- [`DoubleEndedIterator::rfind`]\n+- [`DoubleEndedIterator::rfold`]\n+- [`DoubleEndedIterator::try_rfold`]\n+- [`Duration::from_micros`]\n+- [`Duration::from_nanos`]\n+- [`Duration::subsec_micros`]\n+- [`Duration::subsec_millis`]\n+- [`HashMap::remove_entry`]\n+- [`Iterator::try_fold`]\n+- [`Iterator::try_for_each`]\n+- [`NonNull::cast`]\n+- [`Option::filter`]\n+- [`String::replace_range`]\n+- [`Take::set_limit`]\n+- [`hint::unreachable_unchecked`]\n+- [`os::unix::process::parent_id`]\n+- [`ptr::swap_nonoverlapping`]\n+- [`slice::rsplit_mut`]\n+- [`slice::rsplit`]\n+- [`slice::swap_with_slice`]\n+\n+Cargo\n+-----\n+- [`cargo-metadata` now includes `authors`, `categories`, `keywords`,\n+  `readme`, and `repository` fields.][cargo/5386]\n+- [`cargo-metadata` now includes a package's `metadata` table.][cargo/5360]\n+- [Added the `--target-dir` optional argument.][cargo/5393] This allows you to specify\n+  a different directory than `target` for placing compilation artifacts.\n+- [Cargo will be adding automatic target inference for binaries, benchmarks,\n+  examples, and tests in the Rust 2018 edition.][cargo/5335] If your project specifies\n+  specific targets e.g. using `[[bin]]` and have other binaries in locations\n+  where cargo would infer a binary, Cargo will produce a warning. You can\n+  disable this feature ahead of time by setting any of the following `autobins`,\n+  `autobenches`, `autoexamples`, `autotests` to false.\n+- [Cargo will now cache compiler information.][cargo/5359] This can be disabled by\n+  setting `CARGO_CACHE_RUSTC_INFO=0` in your environment.\n+\n+Misc\n+----\n+- [Added \u201cThe Rustc book\u201d into the official documentation.][49707]\n+  [\u201cThe Rustc book\u201d] documents and teaches how to use the rustc compiler.\n+- [All books available on `doc.rust-lang.org` are now searchable.][49623]\n+\n+Compatibility Notes\n+-------------------\n+- [Calling a `CharExt` or `StrExt` method directly on core will no longer\n+  work.][49896] e.g. `::core::prelude::v1::StrExt::is_empty(\"\")` will not\n+  compile, `\"\".is_empty()` will still compile.\n+- [`Debug` output on `atomic::{AtomicBool, AtomicIsize, AtomicPtr, AtomicUsize}`\n+  will only print the inner type.][48553] e.g.\n+  `print!(\"{:?}\", AtomicBool::new(true))` will print `true`\n+  not `AtomicBool(true)`.\n+- [The maximum number for `repr(align(N))` is now 2\u00b2\u2079.][50378] Previously you\n+  could enter higher numbers but they were not supported by LLVM. Up to 512MB\n+  alignment should cover all use cases.\n+\n+[48553]: https://github.com/rust-lang/rust/pull/48553/\n+[48851]: https://github.com/rust-lang/rust/pull/48851/\n+[48925]: https://github.com/rust-lang/rust/pull/48925/\n+[49533]: https://github.com/rust-lang/rust/pull/49533/\n+[49623]: https://github.com/rust-lang/rust/pull/49623/\n+[49630]: https://github.com/rust-lang/rust/pull/49630/\n+[49664]: https://github.com/rust-lang/rust/pull/49664/\n+[49699]: https://github.com/rust-lang/rust/pull/49699/\n+[49707]: https://github.com/rust-lang/rust/pull/49707/\n+[49719]: https://github.com/rust-lang/rust/pull/49719/\n+[49896]: https://github.com/rust-lang/rust/pull/49896/\n+[49968]: https://github.com/rust-lang/rust/pull/49968/\n+[50177]: https://github.com/rust-lang/rust/pull/50177/\n+[50378]: https://github.com/rust-lang/rust/pull/50378/\n+[50398]: https://github.com/rust-lang/rust/pull/50398/\n+[50423]: https://github.com/rust-lang/rust/pull/50423/\n+[cargo/5203]: https://github.com/rust-lang/cargo/pull/5203/\n+[cargo/5335]: https://github.com/rust-lang/cargo/pull/5335/\n+[cargo/5359]: https://github.com/rust-lang/cargo/pull/5359/\n+[cargo/5360]: https://github.com/rust-lang/cargo/pull/5360/\n+[cargo/5386]: https://github.com/rust-lang/cargo/pull/5386/\n+[cargo/5393]: https://github.com/rust-lang/cargo/pull/5393/\n+[`DoubleEndedIterator::rfind`]: https://doc.rust-lang.org/std/iter/trait.DoubleEndedIterator.html#method.rfind\n+[`DoubleEndedIterator::rfold`]: https://doc.rust-lang.org/std/iter/trait.DoubleEndedIterator.html#method.rfold\n+[`DoubleEndedIterator::try_rfold`]: https://doc.rust-lang.org/std/iter/trait.DoubleEndedIterator.html#method.try_rfold\n+[`Duration::from_micros`]: https://doc.rust-lang.org/std/time/struct.Duration.html#method.from_micros\n+[`Duration::from_nanos`]: https://doc.rust-lang.org/std/time/struct.Duration.html#method.from_nanos\n+[`Duration::subsec_micros`]: https://doc.rust-lang.org/std/time/struct.Duration.html#method.subsec_micros\n+[`Duration::subsec_millis`]: https://doc.rust-lang.org/std/time/struct.Duration.html#method.subsec_millis\n+[`HashMap::remove_entry`]: https://doc.rust-lang.org/std/collections/struct.HashMap.html#method.remove_entry\n+[`Iterator::try_fold`]: https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.try_fold\n+[`Iterator::try_for_each`]: https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.try_for_each\n+[`NonNull::cast`]: https://doc.rust-lang.org/std/ptr/struct.NonNull.html#method.cast\n+[`Option::filter`]: https://doc.rust-lang.org/std/option/enum.Option.html#method.filter\n+[`String::replace_range`]: https://doc.rust-lang.org/std/string/struct.String.html#method.replace_range\n+[`Take::set_limit`]: https://doc.rust-lang.org/std/io/struct.Take.html#method.set_limit\n+[`hint::unreachable_unchecked`]: https://doc.rust-lang.org/std/hint/fn.unreachable_unchecked.html\n+[`os::unix::process::parent_id`]: https://doc.rust-lang.org/std/os/unix/process/fn.parent_id.html\n+[`process::id`]: https://doc.rust-lang.org/std/process/fn.id.html\n+[`ptr::swap_nonoverlapping`]: https://doc.rust-lang.org/std/ptr/fn.swap_nonoverlapping.html\n+[`slice::rsplit_mut`]: https://doc.rust-lang.org/std/primitive.slice.html#method.rsplit_mut\n+[`slice::rsplit`]: https://doc.rust-lang.org/std/primitive.slice.html#method.rsplit\n+[`slice::swap_with_slice`]: https://doc.rust-lang.org/std/primitive.slice.html#method.swap_with_slice\n+[`arch::x86_64`]: https://doc.rust-lang.org/std/arch/x86_64/index.html\n+[`arch::x86`]: https://doc.rust-lang.org/std/arch/x86/index.html\n+[\u201cThe Rustc book\u201d]: https://doc.rust-lang.org/rustc\n+\n+\n+Version 1.26.2 (2018-06-05)\n+==========================\n+\n+Compatibility Notes\n+-------------------\n+\n+- [The borrow checker was fixed to avoid unsoundness when using match ergonomics][51117]\n+\n+[51117]: https://github.com/rust-lang/rust/issues/51117\n+\n+\n+Version 1.26.1 (2018-05-29)\n+==========================\n+\n+Tools\n+-----\n+\n+- [RLS now works on Windows][50646]\n+- [Rustfmt stopped badly formatting text in some cases][rustfmt/2695]\n+\n+\n+Compatibility Notes\n+--------\n+\n+- [`fn main() -> impl Trait` no longer works for non-Termination\n+  trait][50656]\n+  This reverts an accidental stabilization.\n+- [`NaN > NaN` no longer returns true in const-fn contexts][50812]\n+- [Prohibit using turbofish for `impl Trait` in method arguments][50950]\n+\n+[50646]: https://github.com/rust-lang/rust/issues/50646\n+[50656]: https://github.com/rust-lang/rust/pull/50656\n+[50812]: https://github.com/rust-lang/rust/pull/50812\n+[50950]: https://github.com/rust-lang/rust/issues/50950\n+[rustfmt/2695]: https://github.com/rust-lang-nursery/rustfmt/issues/2695\n+\n+Version 1.26.0 (2018-05-10)\n+==========================\n+\n+Language\n+--------\n+- [Closures now implement `Copy` and/or `Clone` if all captured variables\n+  implement either or both traits.][49299]\n+- [The inclusive range syntax e.g. `for x in 0..=10` is now stable.][47813]\n+- [The `'_` lifetime is now stable. The underscore lifetime can be used anywhere where a\n+  lifetime can be elided.][49458]\n+- [`impl Trait` is now stable allowing you to have abstract types in returns\n+   or in function parameters.][49255] e.g. `fn foo() -> impl Iterator<Item=u8>` or\n+  `fn open(path: impl AsRef<Path>)`.\n+- [Pattern matching will now automatically apply dereferences.][49394]\n+- [128-bit integers in the form of `u128` and `i128` are now stable.][49101]\n+- [`main` can now return `Result<(), E: Debug>`][49162] in addition to `()`.\n+- [A lot of operations are now available in a const context.][46882] E.g. You\n+  can now index into constant arrays, reference and dereference into constants,\n+  and use Tuple struct constructors.\n+- [Fixed entry slice patterns are now stable.][48516] e.g.\n+  ```rust\n+  let points = [1, 2, 3, 4];\n+  match points {\n+      [1, 2, 3, 4] => println!(\"All points were sequential.\"),\n+      _ => println!(\"Not all points were sequential.\"),\n+  }\n+  ```\n+\n+\n+Compiler\n+--------\n+- [LLD is now used as the default linker for `wasm32-unknown-unknown`.][48125]\n+- [Fixed exponential projection complexity on nested types.][48296]\n+  This can provide up to a ~12% reduction in compile times for certain crates.\n+- [Added the `--remap-path-prefix` option to rustc.][48359] Allowing you\n+  to remap path prefixes outputted by the compiler.\n+- [Added `powerpc-unknown-netbsd` target.][48281]\n+\n+Libraries\n+---------\n+- [Implemented `From<u16> for usize` & `From<{u8, i16}> for isize`.][49305]\n+- [Added hexadecimal formatting for integers with fmt::Debug][48978]\n+  e.g. `assert!(format!(\"{:02x?}\", b\"Foo\\0\") == \"[46, 6f, 6f, 00]\")`\n+- [Implemented `Default, Hash` for `cmp::Reverse`.][48628]\n+- [Optimized `str::repeat` being 8x faster in large cases.][48657]\n+- [`ascii::escape_default` is now available in libcore.][48735]\n+- [Trailing commas are now supported in std and core macros.][48056]\n+- [Implemented `Copy, Clone` for `cmp::Reverse`][47379]\n+- [Implemented `Clone` for `char::{ToLowercase, ToUppercase}`.][48629]\n+\n+Stabilized APIs\n+---------------\n+- [`*const T::add`]\n+- [`*const T::copy_to_nonoverlapping`]\n+- [`*const T::copy_to`]\n+- [`*const T::read_unaligned`]\n+- [`*const T::read_volatile`]\n+- [`*const T::read`]\n+- [`*const T::sub`]\n+- [`*const T::wrapping_add`]\n+- [`*const T::wrapping_sub`]\n+- [`*mut T::add`]\n+- [`*mut T::copy_to_nonoverlapping`]\n+- [`*mut T::copy_to`]\n+- [`*mut T::read_unaligned`]\n+- [`*mut T::read_volatile`]\n+- [`*mut T::read`]\n+- [`*mut T::replace`]\n+- [`*mut T::sub`]\n+- [`*mut T::swap`]\n+- [`*mut T::wrapping_add`]\n+- [`*mut T::wrapping_sub`]\n+- [`*mut T::write_bytes`]\n+- [`*mut T::write_unaligned`]\n+- [`*mut T::write_volatile`]\n+- [`*mut T::write`]\n+- [`Box::leak`]\n+- [`FromUtf8Error::as_bytes`]\n+- [`LocalKey::try_with`]\n+- [`Option::cloned`]\n+- [`btree_map::Entry::and_modify`]\n+- [`fs::read_to_string`]\n+- [`fs::read`]\n+- [`fs::write`]\n+- [`hash_map::Entry::and_modify`]\n+- [`iter::FusedIterator`]\n+- [`ops::RangeInclusive`]\n+- [`ops::RangeToInclusive`]\n+- [`process::id`]\n+- [`slice::rotate_left`]\n+- [`slice::rotate_right`]\n+- [`String::retain`]\n+\n+\n+Cargo\n+-----\n+- [Cargo will now output path to custom commands when `-v` is\n+  passed with `--list`][cargo/5041]\n+- [The Cargo binary version is now the same as the Rust version][cargo/5083]\n+\n+Misc\n+----\n+- [The second edition of \"The Rust Programming Language\" book is now recommended\n+  over the first.][48404]\n+\n+Compatibility Notes\n+-------------------\n+\n+- [aliasing a `Fn` trait as `dyn` no longer works.][48481] E.g. the following\n+  syntax is now invalid.\n+  ```\n+  use std::ops::Fn as dyn;\n+  fn g(_: Box<dyn(std::fmt::Debug)>) {}\n+  ```\n+- [The result of dereferences are no longer promoted to `'static`.][47408]\n+  e.g.\n+  ```rust\n+  fn main() {\n+      const PAIR: &(i32, i32) = &(0, 1);\n+      let _reversed_pair: &'static _ = &(PAIR.1, PAIR.0); // Doesn't work\n+  }\n+  ```\n+- [Deprecate `AsciiExt` trait in favor of inherent methods.][49109]\n+- [`\".e0\"` will now no longer parse as `0.0` and will instead cause\n+  an error.][48235]\n+- [Removed hoedown from rustdoc.][48274]\n+- [Bounds on higher-kinded lifetimes a hard error.][48326]\n+\n+[46882]: https://github.com/rust-lang/rust/pull/46882\n+[47379]: https://github.com/rust-lang/rust/pull/47379\n+[47408]: https://github.com/rust-lang/rust/pull/47408\n+[47813]: https://github.com/rust-lang/rust/pull/47813\n+[48056]: https://github.com/rust-lang/rust/pull/48056\n+[48125]: https://github.com/rust-lang/rust/pull/48125\n+[48166]: https://github.com/rust-lang/rust/pull/48166\n+[48235]: https://github.com/rust-lang/rust/pull/48235\n+[48274]: https://github.com/rust-lang/rust/pull/48274\n+[48281]: https://github.com/rust-lang/rust/pull/48281\n+[48296]: https://github.com/rust-lang/rust/pull/48296\n+[48326]: https://github.com/rust-lang/rust/pull/48326\n+[48359]: https://github.com/rust-lang/rust/pull/48359\n+[48404]: https://github.com/rust-lang/rust/pull/48404\n+[48481]: https://github.com/rust-lang/rust/pull/48481\n+[48516]: https://github.com/rust-lang/rust/pull/48516\n+[48628]: https://github.com/rust-lang/rust/pull/48628\n+[48629]: https://github.com/rust-lang/rust/pull/48629\n+[48657]: https://github.com/rust-lang/rust/pull/48657\n+[48735]: https://github.com/rust-lang/rust/pull/48735\n+[48978]: https://github.com/rust-lang/rust/pull/48978\n+[49101]: https://github.com/rust-lang/rust/pull/49101\n+[49109]: https://github.com/rust-lang/rust/pull/49109\n+[49121]: https://github.com/rust-lang/rust/pull/49121\n+[49162]: https://github.com/rust-lang/rust/pull/49162\n+[49184]: https://github.com/rust-lang/rust/pull/49184\n+[49234]: https://github.com/rust-lang/rust/pull/49234\n+[49255]: https://github.com/rust-lang/rust/pull/49255\n+[49299]: https://github.com/rust-lang/rust/pull/49299\n+[49305]: https://github.com/rust-lang/rust/pull/49305\n+[49394]: https://github.com/rust-lang/rust/pull/49394\n+[49458]: https://github.com/rust-lang/rust/pull/49458\n+[`*const T::add`]: https://doc.rust-lang.org/std/primitive.pointer.html#method.add\n+[`*const T::copy_to_nonoverlapping`]: https://doc.rust-lang.org/std/primitive.pointer.html#method.copy_to_nonoverlapping\n+[`*const T::copy_to`]: https://doc.rust-lang.org/std/primitive.pointer.html#method.copy_to\n+[`*const T::read_unaligned`]: https://doc.rust-lang.org/std/primitive.pointer.html#method.read_unaligned\n+[`*const T::read_volatile`]: https://doc.rust-lang.org/std/primitive.pointer.html#method.read_volatile\n+[`*const T::read`]: https://doc.rust-lang.org/std/primitive.pointer.html#method.read\n+[`*const T::sub`]: https://doc.rust-lang.org/std/primitive.pointer.html#method.sub\n+[`*const T::wrapping_add`]: https://doc.rust-lang.org/std/primitive.pointer.html#method.wrapping_add\n+[`*const T::wrapping_sub`]: https://doc.rust-lang.org/std/primitive.pointer.html#method.wrapping_sub\n+[`*mut T::add`]: https://doc.rust-lang.org/std/primitive.pointer.html#method.add-1\n+[`*mut T::copy_to_nonoverlapping`]: https://doc.rust-lang.org/std/primitive.pointer.html#method.copy_to_nonoverlapping-1\n+[`*mut T::copy_to`]: https://doc.rust-lang.org/std/primitive.pointer.html#method.copy_to-1\n+[`*mut T::read_unaligned`]: https://doc.rust-lang.org/std/primitive.pointer.html#method.read_unaligned-1\n+[`*mut T::read_volatile`]: https://doc.rust-lang.org/std/primitive.pointer.html#method.read_volatile-1\n+[`*mut T::read`]: https://doc.rust-lang.org/std/primitive.pointer.html#method.read-1\n+[`*mut T::replace`]: https://doc.rust-lang.org/std/primitive.pointer.html#method.replace\n+[`*mut T::sub`]: https://doc.rust-lang.org/std/primitive.pointer.html#method.sub-1\n+[`*mut T::swap`]: https://doc.rust-lang.org/std/primitive.pointer.html#method.swap\n+[`*mut T::wrapping_add`]: https://doc.rust-lang.org/std/primitive.pointer.html#method.wrapping_add-1\n+[`*mut T::wrapping_sub`]: https://doc.rust-lang.org/std/primitive.pointer.html#method.wrapping_sub-1\n+[`*mut T::write_bytes`]: https://doc.rust-lang.org/std/primitive.pointer.html#method.write_bytes\n+[`*mut T::write_unaligned`]: https://doc.rust-lang.org/std/primitive.pointer.html#method.write_unaligned\n+[`*mut T::write_volatile`]: https://doc.rust-lang.org/std/primitive.pointer.html#method.write_volatile\n+[`*mut T::write`]: https://doc.rust-lang.org/std/primitive.pointer.html#method.write\n+[`Box::leak`]: https://doc.rust-lang.org/std/boxed/struct.Box.html#method.leak\n+[`FromUtf8Error::as_bytes`]: https://doc.rust-lang.org/std/string/struct.FromUtf8Error.html#method.as_bytes\n+[`LocalKey::try_with`]: https://doc.rust-lang.org/std/thread/struct.LocalKey.html#method.try_with\n+[`Option::cloned`]: https://doc.rust-lang.org/std/option/enum.Option.html#method.cloned\n+[`btree_map::Entry::and_modify`]: https://doc.rust-lang.org/std/collections/btree_map/enum.Entry.html#method.and_modify\n+[`fs::read_to_string`]: https://doc.rust-lang.org/std/fs/fn.read_to_string.html\n+[`fs::read`]: https://doc.rust-lang.org/std/fs/fn.read.html\n+[`fs::write`]: https://doc.rust-lang.org/std/fs/fn.write.html\n+[`hash_map::Entry::and_modify`]: https://doc.rust-lang.org/std/collections/hash_map/enum.Entry.html#method.and_modify\n+[`iter::FusedIterator`]: https://doc.rust-lang.org/std/iter/trait.FusedIterator.html\n+[`ops::RangeInclusive`]: https://doc.rust-lang.org/std/ops/struct.RangeInclusive.html\n+[`ops::RangeToInclusive`]: https://doc.rust-lang.org/std/ops/struct.RangeToInclusive.html\n+[`process::id`]: https://doc.rust-lang.org/std/process/fn.id.html\n+[`slice::rotate_left`]: https://doc.rust-lang.org/std/primitive.slice.html#method.rotate_left\n+[`slice::rotate_right`]: https://doc.rust-lang.org/std/primitive.slice.html#method.rotate_right\n+[`String::retain`]: https://doc.rust-lang.org/std/string/struct.String.html#method.retain\n+[cargo/5041]: https://github.com/rust-lang/cargo/pull/5041\n+[cargo/5083]: https://github.com/rust-lang/cargo/pull/5083\n+\n+\n+Version 1.25.0 (2018-03-29)\n+==========================\n+\n+Language\n+--------\n+- [The `#[repr(align(x))]` attribute is now stable.][47006] [RFC 1358]\n+- [You can now use nested groups of imports.][47948]\n+  e.g. `use std::{fs::File, io::Read, path::{Path, PathBuf}};`\n+- [You can now have `|` at the start of a match arm.][47947] e.g.\n+```rust\n+enum Foo { A, B, C }\n+\n+fn main() {\n+    let x = Foo::A;\n+    match x {\n+        | Foo::A\n+        | Foo::B => println!(\"AB\"),\n+        | Foo::C => println!(\"C\"),\n+    }\n+}\n+```\n+\n+Compiler\n+--------\n+- [Upgraded to LLVM 6.][47828]\n+- [Added `-C lto=val` option.][47521]\n+- [Added `i586-unknown-linux-musl` target][47282]\n+\n+Libraries\n+---------\n+- [Impl Send for `process::Command` on Unix.][47760]\n+- [Impl PartialEq and Eq for `ParseCharError`.][47790]\n+- [`UnsafeCell::into_inner` is now safe.][47204]\n+- [Implement libstd for CloudABI.][47268]\n+- [`Float::{from_bits, to_bits}` is now available in libcore.][46931]\n+- [Implement `AsRef<Path>` for Component][46985]\n+- [Implemented `Write` for `Cursor<&mut Vec<u8>>`][46830]\n+- [Moved `Duration` to libcore.][46666]\n+\n+Stabilized APIs\n+---------------\n+- [`Location::column`]\n+- [`ptr::NonNull`]\n+\n+The following functions can now be used in a constant expression.\n+eg. `static MINUTE: Duration = Duration::from_secs(60);`\n+- [`Duration::new`][47300]\n+- [`Duration::from_secs`][47300]\n+- [`Duration::from_millis`][47300]\n+\n+Cargo\n+-----\n+- [`cargo new` no longer removes `rust` or `rs` prefixs/suffixs.][cargo/5013]\n+- [`cargo new` now defaults to creating a binary crate, instead of a\n+  library crate.][cargo/5029]\n+\n+Misc\n+----\n+- [Rust by example is now shipped with new releases][46196]\n+\n+Compatibility Notes\n+-------------------\n+- [Deprecated `net::lookup_host`.][47510]\n+- [`rustdoc` has switched to pulldown as the default markdown renderer.][47398]\n+- The borrow checker was sometimes incorrectly permitting overlapping borrows\n+  around indexing operations (see [#47349][47349]). This has been fixed (which also\n+  enabled some correct code that used to cause errors (e.g. [#33903][33903] and [#46095][46095]).\n+- [Removed deprecated unstable attribute `#[simd]`.][47251]\n+\n+[33903]: https://github.com/rust-lang/rust/pull/33903\n+[47947]: https://github.com/rust-lang/rust/pull/47947\n+[47948]: https://github.com/rust-lang/rust/pull/47948\n+[47760]: https://github.com/rust-lang/rust/pull/47760\n+[47790]: https://github.com/rust-lang/rust/pull/47790\n+[47828]: https://github.com/rust-lang/rust/pull/47828\n+[47398]: https://github.com/rust-lang/rust/pull/47398\n+[47510]: https://github.com/rust-lang/rust/pull/47510\n+[47521]: https://github.com/rust-lang/rust/pull/47521\n+[47204]: https://github.com/rust-lang/rust/pull/47204\n+[47251]: https://github.com/rust-lang/rust/pull/47251\n+[47268]: https://github.com/rust-lang/rust/pull/47268\n+[47282]: https://github.com/rust-lang/rust/pull/47282\n+[47300]: https://github.com/rust-lang/rust/pull/47300\n+[47349]: https://github.com/rust-lang/rust/pull/47349\n+[46931]: https://github.com/rust-lang/rust/pull/46931\n+[46985]: https://github.com/rust-lang/rust/pull/46985\n+[47006]: https://github.com/rust-lang/rust/pull/47006\n+[46830]: https://github.com/rust-lang/rust/pull/46830\n+[46095]: https://github.com/rust-lang/rust/pull/46095\n+[46666]: https://github.com/rust-lang/rust/pull/46666\n+[46196]: https://github.com/rust-lang/rust/pull/46196\n+[cargo/5013]: https://github.com/rust-lang/cargo/pull/5013\n+[cargo/5029]: https://github.com/rust-lang/cargo/pull/5029\n+[RFC 1358]: https://github.com/rust-lang/rfcs/pull/1358\n+[`Location::column`]: https://doc.rust-lang.org/std/panic/struct.Location.html#method.column\n+[`ptr::NonNull`]: https://doc.rust-lang.org/std/ptr/struct.NonNull.html\n+\n+\n+Version 1.24.1 (2018-03-01)\n+==========================\n+\n+ - [Do not abort when unwinding through FFI][48251]\n+ - [Emit UTF-16 files for linker arguments on Windows][48318]\n+ - [Make the error index generator work again][48308]\n+ - [Cargo will warn on Windows 7 if an update is needed][cargo/5069].\n+\n+[48251]: https://github.com/rust-lang/rust/issues/48251\n+[48308]: https://github.com/rust-lang/rust/issues/48308\n+[48318]: https://github.com/rust-lang/rust/issues/48318\n+[cargo/5069]: https://github.com/rust-lang/cargo/pull/5069\n+\n+\n+Version 1.24.0 (2018-02-15)\n+==========================\n+\n+Language\n+--------\n+- [External `sysv64` ffi is now available.][46528]\n+  eg. `extern \"sysv64\" fn foo () {}`\n+\n+Compiler\n+--------\n+- [rustc now uses 16 codegen units by default for release builds.][46910]\n+  For the fastest builds, utilize `codegen-units=1`.\n+- [Added `armv4t-unknown-linux-gnueabi` target.][47018]\n+- [Add `aarch64-unknown-openbsd` support][46760]\n+\n+Libraries\n+---------\n+- [`str::find::<char>` now uses memchr.][46735] This should lead to a 10x\n+  improvement in performance in the majority of cases.\n+- [`OsStr`'s `Debug` implementation is now lossless and consistent\n+  with Windows.][46798]\n+- [`time::{SystemTime, Instant}` now implement `Hash`.][46828]\n+- [impl `From<bool>` for `AtomicBool`][46293]\n+- [impl `From<{CString, &CStr}>` for `{Arc<CStr>, Rc<CStr>}`][45990]\n+- [impl `From<{OsString, &OsStr}>` for `{Arc<OsStr>, Rc<OsStr>}`][45990]\n+- [impl `From<{PathBuf, &Path}>` for `{Arc<Path>, Rc<Path>}`][45990]\n+- [float::from_bits now just uses transmute.][46012] This provides\n+  some optimisations from LLVM.\n+- [Copied `AsciiExt` methods onto `char`][46077]\n+- [Remove `T: Sized` requirement on `ptr::is_null()`][46094]\n+- [impl `From<RecvError>` for `{TryRecvError, RecvTimeoutError}`][45506]\n+- [Optimised `f32::{min, max}` to generate more efficient x86 assembly][47080]\n+- [`[u8]::contains` now uses memchr which provides a 3x speed improvement][46713]\n+\n+Stabilized APIs\n+---------------\n+- [`RefCell::replace`]\n+- [`RefCell::swap`]\n+- [`atomic::spin_loop_hint`]\n+\n+The following functions can now be used in a constant expression.\n+eg. `let buffer: [u8; size_of::<usize>()];`, `static COUNTER: AtomicUsize = AtomicUsize::new(1);`\n+\n+- [`AtomicBool::new`][46287]\n+- [`AtomicUsize::new`][46287]\n+- [`AtomicIsize::new`][46287]\n+- [`AtomicPtr::new`][46287]\n+- [`Cell::new`][46287]\n+- [`{integer}::min_value`][46287]\n+- [`{integer}::max_value`][46287]\n+- [`mem::size_of`][46287]\n+- [`mem::align_of`][46287]\n+- [`ptr::null`][46287]\n+- [`ptr::null_mut`][46287]\n+- [`RefCell::new`][46287]\n+- [`UnsafeCell::new`][46287]\n+\n+Cargo\n+-----\n+- [Added a `workspace.default-members` config that\n+  overrides implied `--all` in virtual workspaces.][cargo/4743]\n+- [Enable incremental by default on development builds.][cargo/4817] Also added\n+  configuration keys to `Cargo.toml` and `.cargo/config` to disable on a\n+  per-project or global basis respectively.\n+\n+Misc\n+----\n+\n+Compatibility Notes\n+-------------------\n+- [Floating point types `Debug` impl now always prints a decimal point.][46831]\n+- [`Ipv6Addr` now rejects superfluous `::`'s in IPv6 addresses][46671] This is\n+  in accordance with IETF RFC 4291 \u00a72.2.\n+- [Unwinding will no longer go past FFI boundaries, and will instead abort.][46833]\n+- [`Formatter::flags` method is now deprecated.][46284] The `sign_plus`,\n+  `sign_minus`, `alternate`, and `sign_aware_zero_pad` should be used instead.\n+- [Leading zeros in tuple struct members is now an error][47084]\n+- [`column!()` macro is one-based instead of zero-based][46977]\n+- [`fmt::Arguments` can no longer be shared across threads][45198]\n+- [Access to `#[repr(packed)]` struct fields is now unsafe][44884]\n+- [Cargo sets a different working directory for the compiler][cargo/4788]\n+\n+[44884]: https://github.com/rust-lang/rust/pull/44884\n+[45198]: https://github.com/rust-lang/rust/pull/45198\n+[45506]: https://github.com/rust-lang/rust/pull/45506\n+[45904]: https://github.com/rust-lang/rust/pull/45904\n+[45990]: https://github.com/rust-lang/rust/pull/45990\n+[46012]: https://github.com/rust-lang/rust/pull/46012\n+[46077]: https://github.com/rust-lang/rust/pull/46077\n+[46094]: https://github.com/rust-lang/rust/pull/46094\n+[46284]: https://github.com/rust-lang/rust/pull/46284\n+[46287]: https://github.com/rust-lang/rust/pull/46287\n+[46293]: https://github.com/rust-lang/rust/pull/46293\n+[46528]: https://github.com/rust-lang/rust/pull/46528\n+[46671]: https://github.com/rust-lang/rust/pull/46671\n+[46713]: https://github.com/rust-lang/rust/pull/46713\n+[46735]: https://github.com/rust-lang/rust/pull/46735\n+[46749]: https://github.com/rust-lang/rust/pull/46749\n+[46760]: https://github.com/rust-lang/rust/pull/46760\n+[46798]: https://github.com/rust-lang/rust/pull/46798\n+[46828]: https://github.com/rust-lang/rust/pull/46828\n+[46831]: https://github.com/rust-lang/rust/pull/46831\n+[46833]: https://github.com/rust-lang/rust/pull/46833\n+[46910]: https://github.com/rust-lang/rust/pull/46910\n+[46977]: https://github.com/rust-lang/rust/pull/46977\n+[47018]: https://github.com/rust-lang/rust/pull/47018\n+[47080]: https://github.com/rust-lang/rust/pull/47080\n+[47084]: https://github.com/rust-lang/rust/pull/47084\n+[cargo/4743]: https://github.com/rust-lang/cargo/pull/4743\n+[cargo/4788]: https://github.com/rust-lang/cargo/pull/4788\n+[cargo/4817]: https://github.com/rust-lang/cargo/pull/4817\n+[`RefCell::replace`]: https://doc.rust-lang.org/std/cell/struct.RefCell.html#method.replace\n+[`RefCell::swap`]: https://doc.rust-lang.org/std/cell/struct.RefCell.html#method.swap\n+[`atomic::spin_loop_hint`]: https://doc.rust-lang.org/std/sync/atomic/fn.spin_loop_hint.html\n+\n+\n Version 1.23.0 (2018-01-04)\n ==========================\n \n@@ -2307,7 +3118,7 @@ Language\n   [RFC 1513](https://github.com/rust-lang/rfcs/blob/master/text/1513-less-unwinding.md).\n * [Add a new crate type, 'cdylib'](https://github.com/rust-lang/rust/pull/33553).\n   cdylibs are dynamic libraries suitable for loading by non-Rust hosts.\n-  [RFC 1510](https://github.com/rust-lang/rfcs/blob/master/text/1510-rdylib.md).\n+  [RFC 1510](https://github.com/rust-lang/rfcs/blob/master/text/1510-cdylib.md).\n   Note that Cargo does not yet directly support cdylibs.\n \n Stabilized APIs\n@@ -2382,7 +3193,7 @@ Stabilized APIs\n * [`UnixDatagram::shutdown`](http://doc.rust-lang.org/std/os/unix/net/struct.UnixDatagram.html#method.shutdown)\n * RawFd impls for `UnixDatagram`\n * `{BTree,Hash}Map::values_mut`\n-* [`<[_]>::binary_search_by_key`](http://doc.rust-lang.org/beta/std/primitive.slice.html#method.binary_search_by_key)\n+* [`<[_]>::binary_search_by_key`](http://doc.rust-lang.org/std/primitive.slice.html#method.binary_search_by_key)\n \n Libraries\n ---------\n@@ -3300,7 +4111,7 @@ Compatibility Notes\n [1.6bh]: https://github.com/rust-lang/rust/pull/29811\n [1.6c]: https://github.com/rust-lang/cargo/pull/2192\n [1.6cc]: https://github.com/rust-lang/cargo/pull/2131\n-[1.6co]: http://doc.rust-lang.org/beta/core/index.html\n+[1.6co]: http://doc.rust-lang.org/core/index.html\n [1.6dv]: https://github.com/rust-lang/rust/pull/30000\n [1.6f]: https://github.com/rust-lang/rust/pull/29129\n [1.6m]: https://github.com/rust-lang/rust/pull/29828\n@@ -3995,7 +4806,7 @@ Language\n --------\n \n * Patterns with `ref mut` now correctly invoke [`DerefMut`] when\n-  matching against dereferencable values.\n+  matching against dereferenceable values.\n \n Libraries\n ---------"}, {"sha": "b1e2e1545cf85042f1950274249303a2763f5846", "filename": "appveyor.yml", "status": "modified", "additions": 54, "deletions": 15, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/appveyor.yml", "raw_url": "https://github.com/rust-lang/rust/raw/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/appveyor.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/appveyor.yml?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd", "patch": "@@ -6,7 +6,7 @@ environment:\n     secure: 7Y+JiquYedOAgnUU26uL0DPzrxmTtR+qIwG6rNKSuWDffqU3vVZxbGXim9QpTO80\n   SCCACHE_DIGEST: f808afabb4a4eb1d7112bcb3fa6be03b61e93412890c88e177c667eb37f46353d7ec294e559b16f9f4b5e894f2185fe7670a0df15fd064889ecbd80f0c34166c\n   TOOLSTATE_REPO_ACCESS_TOKEN:\n-    secure: PTZiSxJMVUZ0VnMR5i13E4OagbXfglj7pcskDQiKufVrDm13mLoI0vDJAEM35+bY\n+    secure: gKGlVktr7iuqCoYSxHxDE9ltLOKU0nYDEuQxvWbNxUIW7ri5ppn8L06jQzN0GGzN\n \n   # By default schannel checks revocation of certificates unlike some other SSL\n   # backends, but we've historically had problems on CI where a revocation\n@@ -18,19 +18,31 @@ environment:\n   - MSYS_BITS: 64\n     RUST_CONFIGURE_ARGS: --build=x86_64-pc-windows-msvc --enable-profiler\n     SCRIPT: python x.py test\n+    CI_JOB_NAME: x86_64-msvc\n   - MSYS_BITS: 32\n-    RUST_CONFIGURE_ARGS: --build=i686-pc-windows-msvc --target=i686-pc-windows-msvc\n-    SCRIPT: python x.py test --host i686-pc-windows-msvc --target i686-pc-windows-msvc\n+    RUST_CONFIGURE_ARGS: --build=i686-pc-windows-msvc\n+    SCRIPT: make appveyor-subset-1\n+    CI_JOB_NAME: i686-msvc-1\n+  - MSYS_BITS: 32\n+    RUST_CONFIGURE_ARGS: --build=i686-pc-windows-msvc\n+    SCRIPT: make appveyor-subset-2\n+    CI_JOB_NAME: i686-msvc-2\n \n   # MSVC aux tests\n   - MSYS_BITS: 64\n-    RUST_CHECK_TARGET: check-aux\n+    RUST_CHECK_TARGET: check-aux EXCLUDE_CARGO=1\n+    RUST_CONFIGURE_ARGS: --build=x86_64-pc-windows-msvc\n+    CI_JOB_NAME: x86_64-msvc-aux\n+  - MSYS_BITS: 64\n+    SCRIPT: python x.py test src/tools/cargotest src/tools/cargo\n     RUST_CONFIGURE_ARGS: --build=x86_64-pc-windows-msvc\n+    CI_JOB_NAME: x86_64-msvc-cargo\n \n   # MSVC tools tests\n   - MSYS_BITS: 64\n     SCRIPT: src/ci/docker/x86_64-gnu-tools/checktools.sh x.py /tmp/toolstates.json windows\n     RUST_CONFIGURE_ARGS: --build=x86_64-pc-windows-msvc --save-toolstates=/tmp/toolstates.json --enable-test-miri\n+    CI_JOB_NAME: x86_64-msvc-tools\n \n   # 32/64-bit MinGW builds.\n   #\n@@ -47,51 +59,65 @@ environment:\n   # SourceForge is notoriously flaky, so we mirror it on our own infrastructure.\n   - MSYS_BITS: 32\n     RUST_CONFIGURE_ARGS: --build=i686-pc-windows-gnu\n-    SCRIPT: python x.py test\n+    SCRIPT: make appveyor-subset-1\n     MINGW_URL: https://s3-us-west-1.amazonaws.com/rust-lang-ci2/rust-ci-mirror\n     MINGW_ARCHIVE: i686-6.3.0-release-posix-dwarf-rt_v5-rev2.7z\n     MINGW_DIR: mingw32\n+    CI_JOB_NAME: i686-mingw-1\n+  - MSYS_BITS: 32\n+    RUST_CONFIGURE_ARGS: --build=i686-pc-windows-gnu\n+    SCRIPT: make appveyor-subset-2\n+    MINGW_URL: https://s3-us-west-1.amazonaws.com/rust-lang-ci2/rust-ci-mirror\n+    MINGW_ARCHIVE: i686-6.3.0-release-posix-dwarf-rt_v5-rev2.7z\n+    MINGW_DIR: mingw32\n+    CI_JOB_NAME: i686-mingw-2\n   - MSYS_BITS: 64\n     SCRIPT: python x.py test\n     RUST_CONFIGURE_ARGS: --build=x86_64-pc-windows-gnu\n     MINGW_URL: https://s3-us-west-1.amazonaws.com/rust-lang-ci2/rust-ci-mirror\n     MINGW_ARCHIVE: x86_64-6.3.0-release-posix-seh-rt_v5-rev2.7z\n     MINGW_DIR: mingw64\n+    CI_JOB_NAME: x86_64-mingw\n \n   # 32/64 bit MSVC and GNU deployment\n   - RUST_CONFIGURE_ARGS: >\n       --build=x86_64-pc-windows-msvc\n-      --enable-extended\n+      --enable-full-tools\n       --enable-profiler\n     SCRIPT: python x.py dist\n     DEPLOY: 1\n+    CI_JOB_NAME: dist-x86_64-msvc\n   - RUST_CONFIGURE_ARGS: >\n       --build=i686-pc-windows-msvc\n       --target=i586-pc-windows-msvc\n-      --enable-extended\n+      --enable-full-tools\n       --enable-profiler\n     SCRIPT: python x.py dist\n     DEPLOY: 1\n+    CI_JOB_NAME: dist-i686-msvc\n   - MSYS_BITS: 32\n-    RUST_CONFIGURE_ARGS: --build=i686-pc-windows-gnu --enable-extended\n+    RUST_CONFIGURE_ARGS: --build=i686-pc-windows-gnu --enable-full-tools\n     SCRIPT: python x.py dist\n     MINGW_URL: https://s3-us-west-1.amazonaws.com/rust-lang-ci2/rust-ci-mirror\n     MINGW_ARCHIVE: i686-6.3.0-release-posix-dwarf-rt_v5-rev2.7z\n     MINGW_DIR: mingw32\n     DEPLOY: 1\n+    CI_JOB_NAME: dist-i686-mingw\n   - MSYS_BITS: 64\n     SCRIPT: python x.py dist\n-    RUST_CONFIGURE_ARGS: --build=x86_64-pc-windows-gnu --enable-extended\n+    RUST_CONFIGURE_ARGS: --build=x86_64-pc-windows-gnu --enable-full-tools\n     MINGW_URL: https://s3-us-west-1.amazonaws.com/rust-lang-ci2/rust-ci-mirror\n     MINGW_ARCHIVE: x86_64-6.3.0-release-posix-seh-rt_v5-rev2.7z\n     MINGW_DIR: mingw64\n     DEPLOY: 1\n+    CI_JOB_NAME: dist-x86_64-mingw\n \n   # \"alternate\" deployment, see .travis.yml for more info\n   - MSYS_BITS: 64\n     RUST_CONFIGURE_ARGS: --build=x86_64-pc-windows-msvc --enable-extended --enable-profiler\n     SCRIPT: python x.py dist\n     DEPLOY_ALT: 1\n+    CI_JOB_NAME: dist-x86_64-msvc-alt\n \n matrix:\n   fast_finish: true\n@@ -112,6 +138,20 @@ install:\n   - if defined MINGW_URL 7z x -y %MINGW_ARCHIVE% > nul\n   - if defined MINGW_URL set PATH=%CD%\\%MINGW_DIR%\\bin;C:\\msys64\\usr\\bin;%PATH%\n \n+  # If we're compiling for MSVC then we, like most other distribution builders,\n+  # switch to clang as the compiler. This'll allow us eventually to enable LTO\n+  # amongst LLVM and rustc. Note that we only do this on MSVC as I don't think\n+  # clang has an output mode compatible with MinGW that we need. If it does we\n+  # should switch to clang for MinGW as well!\n+  #\n+  # Note that the LLVM installer is an NSIS installer\n+  #\n+  # Original downloaded here came from\n+  # http://releases.llvm.org/6.0.0/LLVM-6.0.0-win64.exe\n+  - if NOT defined MINGW_URL appveyor-retry appveyor DownloadFile https://s3-us-west-1.amazonaws.com/rust-lang-ci2/rust-ci-mirror/LLVM-6.0.0-win64.exe\n+  - if NOT defined MINGW_URL .\\LLVM-6.0.0-win64.exe /S /NCRC /D=C:\\clang-rust\n+  - if NOT defined MINGW_URL set RUST_CONFIGURE_ARGS=%RUST_CONFIGURE_ARGS% --set llvm.clang-cl=C:\\clang-rust\\bin\\clang-cl.exe\n+\n   # Here we do a pretty heinous thing which is to mangle the MinGW installation\n   # we just had above. Currently, as of this writing, we're using MinGW-w64\n   # builds of gcc, and that's currently at 6.3.0. We use 6.3.0 as it appears to\n@@ -140,8 +180,8 @@ install:\n   - set PATH=C:\\Python27;%PATH%\n \n   # Download and install sccache\n-  - appveyor-retry appveyor DownloadFile https://s3-us-west-1.amazonaws.com/rust-lang-ci2/rust-ci-mirror/2017-05-12-sccache-x86_64-pc-windows-msvc\n-  - mv 2017-05-12-sccache-x86_64-pc-windows-msvc sccache.exe\n+  - appveyor-retry appveyor DownloadFile https://s3-us-west-1.amazonaws.com/rust-lang-ci2/rust-ci-mirror/2018-04-26-sccache-x86_64-pc-windows-msvc\n+  - mv 2018-04-26-sccache-x86_64-pc-windows-msvc sccache.exe\n   - set PATH=%PATH%;%CD%\n \n   # Download and install ninja\n@@ -164,9 +204,6 @@ install:\n   - set PATH=%PATH%;%CD%\\handle\n   - handle.exe -accepteula -help\n \n-  # Attempt to debug sccache failures\n-  - set SCCACHE_ERROR_LOG=%CD%/sccache.log\n-\n test_script:\n   - if not exist C:\\cache\\rustsrc\\NUL mkdir C:\\cache\\rustsrc\n   - sh src/ci/init_repo.sh . /c/cache/rustsrc\n@@ -175,7 +212,9 @@ test_script:\n   - sh src/ci/run.sh\n \n on_failure:\n-  - cat %CD%\\sccache.log || exit 0\n+  # Dump crash log\n+  - set PATH=%PATH%;\"C:\\Program Files (x86)\\Windows Kits\\10\\Debuggers\\X64\"\n+  - if exist %LOCALAPPDATA%\\CrashDumps for %%f in (%LOCALAPPDATA%\\CrashDumps\\*) do cdb -c \"k;q\" -G -z \"%%f\"\n \n branches:\n   only:"}, {"sha": "107375ac5cc3a3fa0ce254f11adde571d29d6e60", "filename": "config.toml.example", "status": "modified", "additions": 69, "deletions": 7, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/config.toml.example", "raw_url": "https://github.com/rust-lang/rust/raw/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/config.toml.example", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/config.toml.example?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd", "patch": "@@ -61,8 +61,8 @@\n # the same format as above, but since these targets are experimental, they are\n # not built by default and the experimental Rust compilation targets that depend\n # on them will not work unless the user opts in to building them. By default the\n-# `WebAssembly` target is enabled when compiling LLVM from scratch.\n-#experimental-targets = \"WebAssembly\"\n+# `WebAssembly` and `RISCV` targets are enabled when compiling LLVM from scratch.\n+#experimental-targets = \"WebAssembly;RISCV\"\n \n # Cap the number of parallel linker invocations when compiling LLVM.\n # This can be useful when building LLVM with debug info, which significantly\n@@ -76,6 +76,10 @@\n # passed to prefer linking to shared libraries.\n #link-shared = false\n \n+# On MSVC you can compile LLVM with clang-cl, but the test suite doesn't pass\n+# with clang-cl, so this is special in that it only compiles LLVM with clang-cl\n+#clang-cl = '/path/to/clang-cl.exe'\n+\n # =============================================================================\n # General build configuration options\n # =============================================================================\n@@ -118,6 +122,10 @@\n # Indicate whether submodules are managed and updated automatically.\n #submodules = true\n \n+# Update submodules only when the checked out commit in the submodules differs\n+# from what is committed in the main rustc repo.\n+#fast-submodules = true\n+\n # The path to (or name of) the GDB executable to use. This is only used for\n # executing the debuginfo test suite.\n #gdb = \"gdb\"\n@@ -151,6 +159,10 @@\n # default.\n #extended = false\n \n+# Installs chosen set of extended tools if enables. By default builds all.\n+# If chosen tool failed to build the installation fails.\n+#tools = [\"cargo\", \"rls\", \"rustfmt\", \"analysis\", \"src\"]\n+\n # Verbosity level: 0 == not verbose, 1 == verbose, 2 == very verbose\n #verbose = 0\n \n@@ -178,6 +190,10 @@\n # essentially skipping stage0 as the local compiler is recompiling itself again.\n #local-rebuild = false\n \n+# Print out how long each rustbuild step took (mostly intended for CI and\n+# tracking over time)\n+#print-step-timings = false\n+\n # =============================================================================\n # General install configuration options\n # =============================================================================\n@@ -250,6 +266,10 @@\n # standard library.\n #debuginfo-only-std = false\n \n+# Enable debuginfo for the extended tools: cargo, rls, rustfmt\n+# Adding debuginfo makes them several times larger.\n+#debuginfo-tools = false\n+\n # Whether or not jemalloc is built and enabled\n #use-jemalloc = true\n \n@@ -259,6 +279,12 @@\n # Whether or not `panic!`s generate backtraces (RUST_BACKTRACE)\n #backtrace = true\n \n+# Whether to always use incremental compilation when building rustc\n+#incremental = false\n+\n+# Build rustc with experimental parallelization\n+#experimental-parallel-queries = false\n+\n # The default linker that will be hard-coded into the generated compiler for\n # targets that don't specify linker explicitly in their target specifications.\n # Note that this is not the linker used to link said compiler.\n@@ -275,9 +301,9 @@\n # desired in distributions, for example.\n #rpath = true\n \n-# Suppresses extraneous output from tests to ensure the output of the test\n-# harness is relatively clean.\n-#quiet-tests = false\n+# Emits extraneous output from tests to ensure that failures of the test\n+# harness are debuggable just from logfiles.\n+#verbose-tests = false\n \n # Flag indicating whether tests are compiled with optimizations (the -O flag) or\n # with debuginfo (the -g flag)\n@@ -290,7 +316,7 @@\n \n # Flag indicating whether git info will be retrieved from .git automatically.\n # Having the git information can cause a lot of rebuilds during development.\n-# Note: If this attribute is not explicity set (e.g. if left commented out) it\n+# Note: If this attribute is not explicitly set (e.g. if left commented out) it\n # will default to true if channel = \"dev\", but will default to false otherwise.\n #ignore-git = true\n \n@@ -305,6 +331,42 @@\n # result (broken, compiling, testing) into this JSON file.\n #save-toolstates = \"/path/to/toolstates.json\"\n \n+# This is an array of the codegen backends that will be compiled for the rustc\n+# that's being compiled. The default is to only build the LLVM codegen backend,\n+# but you can also optionally enable the \"emscripten\" backend for asm.js or\n+# make this an empty array (but that probably won't get too far in the\n+# bootstrap)\n+#codegen-backends = [\"llvm\"]\n+\n+# This is the name of the directory in which codegen backends will get installed\n+#codegen-backends-dir = \"codegen-backends\"\n+\n+# Flag indicating whether `libstd` calls an imported function to handle basic IO\n+# when targeting WebAssembly. Enable this to debug tests for the `wasm32-unknown-unknown`\n+# target, as without this option the test output will not be captured.\n+#wasm-syscall = false\n+\n+# Indicates whether LLD will be compiled and made available in the sysroot for\n+# rustc to execute.\n+#lld = false\n+\n+# Indicates whether some LLVM tools, like llvm-objdump, will be made available in the\n+# sysroot.\n+#llvm-tools = false\n+\n+# Indicates whether LLDB will be made available in the sysroot.\n+# This is only built if LLVM is also being built.\n+#lldb = false\n+\n+# Whether to deny warnings in crates\n+#deny-warnings = true\n+\n+# Print backtrace on internal compiler errors during bootstrap\n+#backtrace-on-ice = false\n+\n+# Whether to verify generated LLVM IR\n+#verify-llvm-ir = false\n+\n # =============================================================================\n # Options for specific targets\n #\n@@ -332,7 +394,7 @@\n #linker = \"cc\"\n \n # Path to the `llvm-config` binary of the installation of a custom LLVM to link\n-# against. Note that if this is specifed we don't compile LLVM at all for this\n+# against. Note that if this is specified we don't compile LLVM at all for this\n # target.\n #llvm-config = \"../path/to/llvm/root/bin/llvm-config\"\n "}, {"sha": "4e16e61aa0d398cb0f21cfd60a67a64af037403c", "filename": "src/Cargo.lock", "status": "modified", "additions": 1645, "deletions": 1283, "changes": 2928, "blob_url": "https://github.com/rust-lang/rust/blob/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FCargo.lock?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd"}, {"sha": "01663487f92e12459857cecd4135d2272d2bfa14", "filename": "src/Cargo.toml", "status": "modified", "additions": 22, "deletions": 18, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FCargo.toml?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd", "patch": "@@ -4,6 +4,7 @@ members = [\n   \"rustc\",\n   \"libstd\",\n   \"libtest\",\n+  \"librustc_codegen_llvm\",\n   \"tools/cargotest\",\n   \"tools/clippy\",\n   \"tools/compiletest\",\n@@ -21,26 +22,14 @@ members = [\n   \"tools/rls\",\n   \"tools/rustfmt\",\n   \"tools/miri\",\n-  # FIXME(https://github.com/rust-lang/cargo/issues/4089): move these to exclude\n-  \"tools/rls/test_data/bin_lib\",\n-  \"tools/rls/test_data/borrow_error\",\n-  \"tools/rls/test_data/common\",\n-  \"tools/rls/test_data/deglob\",\n-  \"tools/rls/test_data/features\",\n-  \"tools/rls/test_data/find_all_refs_no_cfg_test\",\n-  \"tools/rls/test_data/find_impls\",\n-  \"tools/rls/test_data/infer_bin\",\n-  \"tools/rls/test_data/infer_custom_bin\",\n-  \"tools/rls/test_data/infer_lib\",\n-  \"tools/rls/test_data/multiple_bins\",\n-  \"tools/rls/test_data/reformat\",\n-  \"tools/rls/test_data/reformat_with_range\",\n-  \"tools/rls/test_data/workspace_symbol\",\n+  \"tools/rustdoc-themes\",\n+]\n+exclude = [\n+  \"tools/rls/test_data\",\n ]\n \n-# Curiously, compiletest will segfault if compiled with opt-level=3 on 64-bit\n-# MSVC when running the compile-fail test suite when a should-fail test panics.\n-# But hey if this is removed and it gets past the bots, sounds good to me.\n+# Curiously, LLVM 7.0 will segfault if compiled with opt-level=3\n+# See issue https://github.com/rust-lang/rust/issues/52378\n [profile.release]\n opt-level = 2\n [profile.bench]\n@@ -55,8 +44,23 @@ debug-assertions = false\n debug = false\n debug-assertions = false\n \n+# We want the RLS to use the version of Cargo that we've got vendored in this\n+# repository to ensure that the same exact version of Cargo is used by both the\n+# RLS and the Cargo binary itself. The RLS depends on Cargo as a git repository\n+# so we use a `[patch]` here to override the github repository with our local\n+# vendored copy.\n [patch.\"https://github.com/rust-lang/cargo\"]\n cargo = { path = \"tools/cargo\" }\n \n [patch.crates-io]\n+# Similar to Cargo above we want the RLS to use a vendored version of `rustfmt`\n+# that we're shipping as well (to ensure that the rustfmt in RLS and the\n+# `rustfmt` executable are the same exact version).\n rustfmt-nightly = { path = \"tools/rustfmt\" }\n+\n+# See comments in `tools/rustc-workspace-hack/README.md` for what's going on\n+# here\n+rustc-workspace-hack = { path = 'tools/rustc-workspace-hack' }\n+\n+[patch.\"https://github.com/rust-lang-nursery/rust-clippy\"]\n+clippy_lints = { path = \"tools/clippy/clippy_lints\" }"}, {"sha": "6da4944c392db58bde3aec9f189323da38cfac24", "filename": "src/README.md", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FREADME.md?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd", "patch": "@@ -0,0 +1,15 @@\n+This directory contains the source code of the rust project, including:\n+- `rustc` and its tests\n+- `libstd`\n+- Various submodules for tools, like rustdoc, rls, etc.\n+\n+For more information on how various parts of the compiler work, see the [rustc guide].\n+\n+Their is also useful content in the following READMEs, which are gradually being moved over to the guide:\n+- https://github.com/rust-lang/rust/tree/master/src/librustc/ty/query\n+- https://github.com/rust-lang/rust/tree/master/src/librustc/dep_graph\n+- https://github.com/rust-lang/rust/blob/master/src/librustc/infer/region_constraints\n+- https://github.com/rust-lang/rust/tree/master/src/librustc/infer/higher_ranked\n+- https://github.com/rust-lang/rust/tree/master/src/librustc/infer/lexical_region_resolve\n+\n+[rustc guide]: https://rust-lang-nursery.github.io/rustc-guide/about-this-guide.html"}, {"sha": "1c9bf65aa0e371b84755a8ddd6e79497fac57171", "filename": "src/binaryen", "status": "removed", "additions": 0, "deletions": 1, "changes": 1, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbinaryen?ref=ac64ef33756d05557153e00211cdf8fcf65d4be3", "patch": "@@ -1 +0,0 @@\n-Subproject commit 1c9bf65aa0e371b84755a8ddd6e79497fac57171"}, {"sha": "57a526038041e5037fe82acb2cbc23104968d463", "filename": "src/bootstrap/Cargo.toml", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fbootstrap%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fbootstrap%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2FCargo.toml?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd", "patch": "@@ -28,10 +28,15 @@ name = \"sccache-plus-cl\"\n path = \"bin/sccache-plus-cl.rs\"\n test = false\n \n+[[bin]]\n+name = \"llvm-config-wrapper\"\n+path = \"bin/llvm-config-wrapper.rs\"\n+test = false\n+\n [dependencies]\n build_helper = { path = \"../build_helper\" }\n cmake = \"0.1.23\"\n-filetime = \"0.1\"\n+filetime = \"0.2\"\n num_cpus = \"1.0\"\n getopts = \"0.2\"\n cc = \"1.0.1\"\n@@ -41,3 +46,8 @@ serde_derive = \"1.0.8\"\n serde_json = \"1.0.2\"\n toml = \"0.4\"\n lazy_static = \"0.2\"\n+time = \"0.1\"\n+petgraph = \"0.4.12\"\n+\n+[dev-dependencies]\n+pretty_assertions = \"0.5\""}, {"sha": "98c353eb6ec8c3fa967b317693d261948d0ed0b3", "filename": "src/bootstrap/README.md", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fbootstrap%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fbootstrap%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2FREADME.md?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd", "patch": "@@ -64,6 +64,10 @@ The script accepts commands, flags, and arguments to determine what to do:\n   # execute tests in the standard library in stage0\n   ./x.py test --stage 0 src/libstd\n \n+  # execute tests in the core and standard library in stage0,\n+  # without running doc tests (thus avoid depending on building the compiler)\n+  ./x.py test --stage 0 --no-doc src/libcore src/libstd\n+\n   # execute all doc tests\n   ./x.py test src/doc\n   ```"}, {"sha": "b1703f8c728e255dfd1af97277064619d59785ec", "filename": "src/bootstrap/bin/llvm-config-wrapper.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fbootstrap%2Fbin%2Fllvm-config-wrapper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fbootstrap%2Fbin%2Fllvm-config-wrapper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbin%2Fllvm-config-wrapper.rs?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd", "patch": "@@ -0,0 +1,27 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// The sheer existence of this file is an awful hack. See the comments in\n+// `src/bootstrap/native.rs` for why this is needed when compiling LLD.\n+\n+use std::env;\n+use std::process::{self, Stdio, Command};\n+use std::io::{self, Write};\n+\n+fn main() {\n+    let real_llvm_config = env::var_os(\"LLVM_CONFIG_REAL\").unwrap();\n+    let mut cmd = Command::new(real_llvm_config);\n+    cmd.args(env::args().skip(1)).stderr(Stdio::piped());\n+    let output = cmd.output().expect(\"failed to spawn llvm-config\");\n+    let stdout = String::from_utf8_lossy(&output.stdout);\n+    print!(\"{}\", stdout.replace(\"\\\\\", \"/\"));\n+    io::stdout().flush().unwrap();\n+    process::exit(output.status.code().unwrap_or(1));\n+}"}, {"sha": "7192cae8956e40b5157ac0ea5a34414f99e6d296", "filename": "src/bootstrap/bin/rustc.rs", "status": "modified", "additions": 87, "deletions": 35, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fbootstrap%2Fbin%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fbootstrap%2Fbin%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbin%2Frustc.rs?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd", "patch": "@@ -31,9 +31,11 @@ extern crate bootstrap;\n \n use std::env;\n use std::ffi::OsString;\n-use std::str::FromStr;\n+use std::io;\n use std::path::PathBuf;\n-use std::process::{Command, ExitStatus};\n+use std::process::Command;\n+use std::str::FromStr;\n+use std::time::Instant;\n \n fn main() {\n     let mut args = env::args_os().skip(1).collect::<Vec<_>>();\n@@ -61,6 +63,11 @@ fn main() {\n         args.remove(n);\n     }\n \n+    if let Some(s) = env::var_os(\"RUSTC_ERROR_FORMAT\") {\n+        args.push(\"--error-format\".into());\n+        args.push(s);\n+    }\n+\n     // Detect whether or not we're a build script depending on whether --target\n     // is passed (a bit janky...)\n     let target = args.windows(2)\n@@ -85,24 +92,32 @@ fn main() {\n     };\n     let stage = env::var(\"RUSTC_STAGE\").expect(\"RUSTC_STAGE was not set\");\n     let sysroot = env::var_os(\"RUSTC_SYSROOT\").expect(\"RUSTC_SYSROOT was not set\");\n-    let mut on_fail = env::var_os(\"RUSTC_ON_FAIL\").map(|of| Command::new(of));\n+    let on_fail = env::var_os(\"RUSTC_ON_FAIL\").map(|of| Command::new(of));\n \n     let rustc = env::var_os(rustc).unwrap_or_else(|| panic!(\"{:?} was not set\", rustc));\n     let libdir = env::var_os(libdir).unwrap_or_else(|| panic!(\"{:?} was not set\", libdir));\n     let mut dylib_path = bootstrap::util::dylib_path();\n-    dylib_path.insert(0, PathBuf::from(libdir));\n+    dylib_path.insert(0, PathBuf::from(&libdir));\n \n     let mut cmd = Command::new(rustc);\n     cmd.args(&args)\n         .arg(\"--cfg\")\n         .arg(format!(\"stage{}\", stage))\n         .env(bootstrap::util::dylib_path_var(),\n              env::join_paths(&dylib_path).unwrap());\n+    let mut maybe_crate = None;\n+\n+    // Print backtrace in case of ICE\n+    if env::var(\"RUSTC_BACKTRACE_ON_ICE\").is_ok() && env::var(\"RUST_BACKTRACE\").is_err() {\n+        cmd.env(\"RUST_BACKTRACE\", \"1\");\n+    }\n+\n+    cmd.env(\"RUSTC_BREAK_ON_ICE\", \"1\");\n \n     if let Some(target) = target {\n         // The stage0 compiler has a special sysroot distinct from what we\n         // actually downloaded, so we just always pass the `--sysroot` option.\n-        cmd.arg(\"--sysroot\").arg(sysroot);\n+        cmd.arg(\"--sysroot\").arg(&sysroot);\n \n         // When we build Rust dylibs they're all intended for intermediate\n         // usage, so make sure we pass the -Cprefer-dynamic flag instead of\n@@ -125,15 +140,11 @@ fn main() {\n             cmd.arg(format!(\"-Clinker={}\", target_linker));\n         }\n \n-        // Pass down incremental directory, if any.\n-        if let Ok(dir) = env::var(\"RUSTC_INCREMENTAL\") {\n-            cmd.arg(format!(\"-Zincremental={}\", dir));\n-        }\n-\n         let crate_name = args.windows(2)\n             .find(|a| &*a[0] == \"--crate-name\")\n             .unwrap();\n         let crate_name = &*crate_name[1];\n+        maybe_crate = Some(crate_name);\n \n         // If we're compiling specifically the `panic_abort` crate then we pass\n         // the `-C panic=abort` option. Note that we do not do this for any\n@@ -175,9 +186,6 @@ fn main() {\n         if let Ok(s) = env::var(\"RUSTC_CODEGEN_UNITS\") {\n             cmd.arg(\"-C\").arg(format!(\"codegen-units={}\", s));\n         }\n-        if env::var(\"RUSTC_THINLTO\").is_ok() {\n-            cmd.arg(\"-Ccodegen-units=16\").arg(\"-Zthinlto\");\n-        }\n \n         // Emit save-analysis info.\n         if env::var(\"RUSTC_SAVE_ANALYSIS\") == Ok(\"api\".to_string()) {\n@@ -224,7 +232,7 @@ fn main() {\n                 // flesh out rpath support more fully in the future.\n                 cmd.arg(\"-Z\").arg(\"osx-rpath-install-name\");\n                 Some(\"-Wl,-rpath,@loader_path/../lib\")\n-            } else if !target.contains(\"windows\") {\n+            } else if !target.contains(\"windows\") && !target.contains(\"wasm32\") {\n                 Some(\"-Wl,-rpath,$ORIGIN/../lib\")\n             } else {\n                 None\n@@ -246,9 +254,6 @@ fn main() {\n         // When running miri tests, we need to generate MIR for all libraries\n         if env::var(\"TEST_MIRI\").ok().map_or(false, |val| val == \"true\") {\n             cmd.arg(\"-Zalways-encode-mir\");\n-            if stage != \"0\" {\n-                cmd.arg(\"-Zmiri\");\n-            }\n             cmd.arg(\"-Zmir-emit-validate=1\");\n         }\n \n@@ -263,12 +268,25 @@ fn main() {\n         if let Ok(host_linker) = env::var(\"RUSTC_HOST_LINKER\") {\n             cmd.arg(format!(\"-Clinker={}\", host_linker));\n         }\n+\n+        if let Ok(s) = env::var(\"RUSTC_HOST_CRT_STATIC\") {\n+            if s == \"true\" {\n+                cmd.arg(\"-C\").arg(\"target-feature=+crt-static\");\n+            }\n+            if s == \"false\" {\n+                cmd.arg(\"-C\").arg(\"target-feature=-crt-static\");\n+            }\n+        }\n     }\n \n     if env::var_os(\"RUSTC_PARALLEL_QUERIES\").is_some() {\n         cmd.arg(\"--cfg\").arg(\"parallel_queries\");\n     }\n \n+    if env::var_os(\"RUSTC_VERIFY_LLVM_IR\").is_some() {\n+        cmd.arg(\"-Z\").arg(\"verify-llvm-ir\");\n+    }\n+\n     let color = match env::var(\"RUSTC_COLOR\") {\n         Ok(s) => usize::from_str(&s).expect(\"RUSTC_COLOR should be an integer\"),\n         Err(_) => 0,\n@@ -278,35 +296,69 @@ fn main() {\n         cmd.arg(\"--color=always\");\n     }\n \n+    if env::var_os(\"RUSTC_DENY_WARNINGS\").is_some() && env::var_os(\"RUSTC_EXTERNAL_TOOL\").is_none()\n+    {\n+        cmd.arg(\"-Dwarnings\");\n+        cmd.arg(\"-Dbare_trait_objects\");\n+    }\n+\n     if verbose > 1 {\n-        eprintln!(\"rustc command: {:?}\", cmd);\n+        eprintln!(\n+            \"rustc command: {:?}={:?} {:?}\",\n+            bootstrap::util::dylib_path_var(),\n+            env::join_paths(&dylib_path).unwrap(),\n+            cmd,\n+        );\n+        eprintln!(\"sysroot: {:?}\", sysroot);\n+        eprintln!(\"libdir: {:?}\", libdir);\n     }\n \n-    // Actually run the compiler!\n-    std::process::exit(if let Some(ref mut on_fail) = on_fail {\n-        match cmd.status() {\n-            Ok(s) if s.success() => 0,\n-            _ => {\n-                println!(\"\\nDid not run successfully:\\n{:?}\\n-------------\", cmd);\n-                exec_cmd(on_fail).expect(\"could not run the backup command\");\n-                1\n+    if let Some(mut on_fail) = on_fail {\n+        let e = match cmd.status() {\n+            Ok(s) if s.success() => std::process::exit(0),\n+            e => e,\n+        };\n+        println!(\"\\nDid not run successfully: {:?}\\n{:?}\\n-------------\", e, cmd);\n+        exec_cmd(&mut on_fail).expect(\"could not run the backup command\");\n+        std::process::exit(1);\n+    }\n+\n+    if env::var_os(\"RUSTC_PRINT_STEP_TIMINGS\").is_some() {\n+        if let Some(krate) = maybe_crate {\n+            let start = Instant::now();\n+            let status = cmd\n+                .status()\n+                .unwrap_or_else(|_| panic!(\"\\n\\n failed to run {:?}\", cmd));\n+            let dur = start.elapsed();\n+\n+            let is_test = args.iter().any(|a| a == \"--test\");\n+            eprintln!(\"[RUSTC-TIMING] {} test:{} {}.{:03}\",\n+                      krate.to_string_lossy(),\n+                      is_test,\n+                      dur.as_secs(),\n+                      dur.subsec_nanos() / 1_000_000);\n+\n+            match status.code() {\n+                Some(i) => std::process::exit(i),\n+                None => {\n+                    eprintln!(\"rustc exited with {}\", status);\n+                    std::process::exit(0xfe);\n+                }\n             }\n         }\n-    } else {\n-        std::process::exit(match exec_cmd(&mut cmd) {\n-            Ok(s) => s.code().unwrap_or(0xfe),\n-            Err(e) => panic!(\"\\n\\nfailed to run {:?}: {}\\n\\n\", cmd, e),\n-        })\n-    })\n+    }\n+\n+    let code = exec_cmd(&mut cmd).unwrap_or_else(|_| panic!(\"\\n\\n failed to run {:?}\", cmd));\n+    std::process::exit(code);\n }\n \n #[cfg(unix)]\n-fn exec_cmd(cmd: &mut Command) -> ::std::io::Result<ExitStatus> {\n+fn exec_cmd(cmd: &mut Command) -> io::Result<i32> {\n     use std::os::unix::process::CommandExt;\n     Err(cmd.exec())\n }\n \n #[cfg(not(unix))]\n-fn exec_cmd(cmd: &mut Command) -> ::std::io::Result<ExitStatus> {\n-    cmd.status()\n+fn exec_cmd(cmd: &mut Command) -> io::Result<i32> {\n+    cmd.status().map(|status| status.code().unwrap())\n }"}, {"sha": "a54e58665cceb8177b936b6744c0bfe50537e683", "filename": "src/bootstrap/bin/rustdoc.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fbootstrap%2Fbin%2Frustdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fbootstrap%2Fbin%2Frustdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbin%2Frustdoc.rs?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd", "patch": "@@ -35,7 +35,7 @@ fn main() {\n     };\n \n     let mut dylib_path = bootstrap::util::dylib_path();\n-    dylib_path.insert(0, PathBuf::from(libdir));\n+    dylib_path.insert(0, PathBuf::from(libdir.clone()));\n \n     let mut cmd = Command::new(rustdoc);\n     cmd.args(&args)\n@@ -62,16 +62,14 @@ fn main() {\n     // it up so we can make rustdoc print this into the docs\n     if let Some(version) = env::var_os(\"RUSTDOC_CRATE_VERSION\") {\n         // This \"unstable-options\" can be removed when `--crate-version` is stabilized\n-        cmd.arg(\"-Z\").arg(\"unstable-options\")\n+        cmd.arg(\"-Z\")\n+           .arg(\"unstable-options\")\n            .arg(\"--crate-version\").arg(version);\n-\n-        // While we can assume that `-Z unstable-options` is set, let's also force rustdoc to panic\n-        // if pulldown rendering differences are found\n-        cmd.arg(\"--deny-render-differences\");\n     }\n \n     if verbose > 1 {\n         eprintln!(\"rustdoc command: {:?}\", cmd);\n+        eprintln!(\"libdir: {:?}\", libdir);\n     }\n \n     std::process::exit(match cmd.status() {"}, {"sha": "0a20ac7e492dc44f87e4e4b4109b07b2a51aced0", "filename": "src/bootstrap/bin/sccache-plus-cl.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fbootstrap%2Fbin%2Fsccache-plus-cl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fbootstrap%2Fbin%2Fsccache-plus-cl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbin%2Fsccache-plus-cl.rs?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd", "patch": "@@ -16,8 +16,8 @@ use std::process::{self, Command};\n fn main() {\n     let target = env::var(\"SCCACHE_TARGET\").unwrap();\n     // Locate the actual compiler that we're invoking\n-    env::remove_var(\"CC\");\n-    env::remove_var(\"CXX\");\n+    env::set_var(\"CC\", env::var_os(\"SCCACHE_CC\").unwrap());\n+    env::set_var(\"CXX\", env::var_os(\"SCCACHE_CXX\").unwrap());\n     let mut cfg = cc::Build::new();\n     cfg.cargo_metadata(false)\n        .out_dir(\"/\")\n@@ -39,6 +39,12 @@ fn main() {\n         cmd.arg(arg);\n     }\n \n+    if let Ok(s) = env::var(\"SCCACHE_EXTRA_ARGS\") {\n+        for s in s.split_whitespace() {\n+            cmd.arg(s);\n+        }\n+    }\n+\n     let status = cmd.status().expect(\"failed to spawn\");\n     process::exit(status.code().unwrap_or(2))\n }"}, {"sha": "d9c66ce2d77905614b5f242c68bfafc123bc7d48", "filename": "src/bootstrap/bootstrap.py", "status": "modified", "additions": 149, "deletions": 57, "changes": 206, "blob_url": "https://github.com/rust-lang/rust/blob/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fbootstrap%2Fbootstrap.py", "raw_url": "https://github.com/rust-lang/rust/raw/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fbootstrap%2Fbootstrap.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbootstrap.py?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd", "patch": "@@ -88,7 +88,10 @@ def _download(path, url, probably_big, verbose, exception):\n             option = \"-#\"\n         else:\n             option = \"-s\"\n-        run([\"curl\", option, \"--retry\", \"3\", \"-Sf\", \"-o\", path, url],\n+        run([\"curl\", option,\n+             \"-y\", \"30\", \"-Y\", \"10\",    # timeout if speed is < 10 bytes/sec for > 30 seconds\n+             \"--connect-timeout\", \"30\", # timeout if cannot connect within 30 seconds\n+             \"--retry\", \"3\", \"-Sf\", \"-o\", path, url],\n             verbose=verbose,\n             exception=exception)\n \n@@ -294,7 +297,7 @@ def default_build_triple():\n             raise ValueError('unknown byteorder: {}'.format(sys.byteorder))\n         # only the n64 ABI is supported, indicate it\n         ostype += 'abi64'\n-    elif cputype == 'sparcv9' or cputype == 'sparc64':\n+    elif cputype == 'sparc' or cputype == 'sparcv9' or cputype == 'sparc64':\n         pass\n     else:\n         err = \"unknown cpu type: {}\".format(cputype)\n@@ -303,6 +306,19 @@ def default_build_triple():\n     return \"{}-{}\".format(cputype, ostype)\n \n \n+@contextlib.contextmanager\n+def output(filepath):\n+    tmp = filepath + '.tmp'\n+    with open(tmp, 'w') as f:\n+        yield f\n+    try:\n+        os.remove(filepath)  # PermissionError/OSError on Win32 if in use\n+        os.rename(tmp, filepath)\n+    except OSError:\n+        shutil.copy2(tmp, filepath)\n+        os.remove(tmp)\n+\n+\n class RustBuild(object):\n     \"\"\"Provide all the methods required to build Rust\"\"\"\n     def __init__(self):\n@@ -314,8 +330,7 @@ def __init__(self):\n         self.build_dir = os.path.join(os.getcwd(), \"build\")\n         self.clean = False\n         self.config_toml = ''\n-        self.printed = False\n-        self.rust_root = os.path.abspath(os.path.join(__file__, '../../..'))\n+        self.rust_root = ''\n         self.use_locked_deps = ''\n         self.use_vendored_sources = ''\n         self.verbose = False\n@@ -336,7 +351,6 @@ def download_stage0(self):\n         if self.rustc().startswith(self.bin_root()) and \\\n                 (not os.path.exists(self.rustc()) or\n                  self.program_out_of_date(self.rustc_stamp())):\n-            self.print_what_bootstrap_means()\n             if os.path.exists(self.bin_root()):\n                 shutil.rmtree(self.bin_root())\n             filename = \"rust-std-{}-{}.tar.gz\".format(\n@@ -348,9 +362,12 @@ def download_stage0(self):\n             self._download_stage0_helper(filename, \"rustc\")\n             self.fix_executable(\"{}/bin/rustc\".format(self.bin_root()))\n             self.fix_executable(\"{}/bin/rustdoc\".format(self.bin_root()))\n-            with open(self.rustc_stamp(), 'w') as rust_stamp:\n+            with output(self.rustc_stamp()) as rust_stamp:\n                 rust_stamp.write(self.date)\n \n+            # This is required so that we don't mix incompatible MinGW\n+            # libraries/binaries that are included in rust-std with\n+            # the system MinGW ones.\n             if \"pc-windows-gnu\" in self.build:\n                 filename = \"rust-mingw-{}-{}.tar.gz\".format(\n                     rustc_channel, self.build)\n@@ -359,11 +376,10 @@ def download_stage0(self):\n         if self.cargo().startswith(self.bin_root()) and \\\n                 (not os.path.exists(self.cargo()) or\n                  self.program_out_of_date(self.cargo_stamp())):\n-            self.print_what_bootstrap_means()\n             filename = \"cargo-{}-{}.tar.gz\".format(cargo_channel, self.build)\n             self._download_stage0_helper(filename, \"cargo\")\n             self.fix_executable(\"{}/bin/cargo\".format(self.bin_root()))\n-            with open(self.cargo_stamp(), 'w') as cargo_stamp:\n+            with output(self.cargo_stamp()) as cargo_stamp:\n                 cargo_stamp.write(self.date)\n \n     def _download_stage0_helper(self, filename, pattern):\n@@ -489,7 +505,7 @@ def bin_root(self):\n         \"\"\"\n         return os.path.join(self.build_dir, self.build, \"stage0\")\n \n-    def get_toml(self, key):\n+    def get_toml(self, key, section=None):\n         \"\"\"Returns the value of the given key in config.toml, otherwise returns None\n \n         >>> rb = RustBuild()\n@@ -501,12 +517,29 @@ def get_toml(self, key):\n \n         >>> rb.get_toml(\"key3\") is None\n         True\n+\n+        Optionally also matches the section the key appears in\n+\n+        >>> rb.config_toml = '[a]\\\\nkey = \"value1\"\\\\n[b]\\\\nkey = \"value2\"'\n+        >>> rb.get_toml('key', 'a')\n+        'value1'\n+        >>> rb.get_toml('key', 'b')\n+        'value2'\n+        >>> rb.get_toml('key', 'c') is None\n+        True\n         \"\"\"\n+\n+        cur_section = None\n         for line in self.config_toml.splitlines():\n+            section_match = re.match(r'^\\s*\\[(.*)\\]\\s*$', line)\n+            if section_match is not None:\n+                cur_section = section_match.group(1)\n+\n             match = re.match(r'^{}\\s*=(.*)$'.format(key), line)\n             if match is not None:\n                 value = match.group(1)\n-                return self.get_string(value) or value.strip()\n+                if section is None or section == cur_section:\n+                    return self.get_string(value) or value.strip()\n         return None\n \n     def cargo(self):\n@@ -560,23 +593,6 @@ def exe_suffix():\n             return '.exe'\n         return ''\n \n-    def print_what_bootstrap_means(self):\n-        \"\"\"Prints more information about the build system\"\"\"\n-        if hasattr(self, 'printed'):\n-            return\n-        self.printed = True\n-        if os.path.exists(self.bootstrap_binary()):\n-            return\n-        if '--help' not in sys.argv or len(sys.argv) == 1:\n-            return\n-\n-        print('info: the build system for Rust is written in Rust, so this')\n-        print('      script is now going to download a stage0 rust compiler')\n-        print('      and then compile the build system itself')\n-        print('')\n-        print('info: in the meantime you can read more about rustbuild at')\n-        print('      src/bootstrap/README.md before the download finishes')\n-\n     def bootstrap_binary(self):\n         \"\"\"Return the path of the boostrap binary\n \n@@ -590,7 +606,6 @@ def bootstrap_binary(self):\n \n     def build_bootstrap(self):\n         \"\"\"Build bootstrap\"\"\"\n-        self.print_what_bootstrap_means()\n         build_dir = os.path.join(self.build_dir, \"bootstrap\")\n         if self.clean and os.path.exists(build_dir):\n             shutil.rmtree(build_dir)\n@@ -607,17 +622,26 @@ def build_bootstrap(self):\n         env[\"LIBRARY_PATH\"] = os.path.join(self.bin_root(), \"lib\") + \\\n             (os.pathsep + env[\"LIBRARY_PATH\"]) \\\n             if \"LIBRARY_PATH\" in env else \"\"\n+        env[\"RUSTFLAGS\"] = \"-Cdebuginfo=2 \"\n+\n+        build_section = \"target.{}\".format(self.build_triple())\n+        target_features = []\n+        if self.get_toml(\"crt-static\", build_section) == \"true\":\n+            target_features += [\"+crt-static\"]\n+        elif self.get_toml(\"crt-static\", build_section) == \"false\":\n+            target_features += [\"-crt-static\"]\n+        if target_features:\n+            env[\"RUSTFLAGS\"] += \"-C target-feature=\" + (\",\".join(target_features)) + \" \"\n+\n         env[\"PATH\"] = os.path.join(self.bin_root(), \"bin\") + \\\n             os.pathsep + env[\"PATH\"]\n         if not os.path.isfile(self.cargo()):\n             raise Exception(\"no cargo executable found at `{}`\".format(\n                 self.cargo()))\n         args = [self.cargo(), \"build\", \"--manifest-path\",\n                 os.path.join(self.rust_root, \"src/bootstrap/Cargo.toml\")]\n-        if self.verbose:\n+        for _ in range(1, self.verbose):\n             args.append(\"--verbose\")\n-            if self.verbose > 1:\n-                args.append(\"--verbose\")\n         if self.use_locked_deps:\n             args.append(\"--locked\")\n         if self.use_vendored_sources:\n@@ -631,53 +655,118 @@ def build_triple(self):\n             return config\n         return default_build_triple()\n \n+    def check_submodule(self, module, slow_submodules):\n+        if not slow_submodules:\n+            checked_out = subprocess.Popen([\"git\", \"rev-parse\", \"HEAD\"],\n+                                           cwd=os.path.join(self.rust_root, module),\n+                                           stdout=subprocess.PIPE)\n+            return checked_out\n+        else:\n+            return None\n+\n+    def update_submodule(self, module, checked_out, recorded_submodules):\n+        module_path = os.path.join(self.rust_root, module)\n+\n+        if checked_out != None:\n+            default_encoding = sys.getdefaultencoding()\n+            checked_out = checked_out.communicate()[0].decode(default_encoding).strip()\n+            if recorded_submodules[module] == checked_out:\n+                return\n+\n+        print(\"Updating submodule\", module)\n+\n+        run([\"git\", \"submodule\", \"-q\", \"sync\", module],\n+            cwd=self.rust_root, verbose=self.verbose)\n+        run([\"git\", \"submodule\", \"update\",\n+            \"--init\", \"--recursive\", module],\n+            cwd=self.rust_root, verbose=self.verbose)\n+        run([\"git\", \"reset\", \"-q\", \"--hard\"],\n+            cwd=module_path, verbose=self.verbose)\n+        run([\"git\", \"clean\", \"-qdfx\"],\n+            cwd=module_path, verbose=self.verbose)\n+\n     def update_submodules(self):\n         \"\"\"Update submodules\"\"\"\n         if (not os.path.exists(os.path.join(self.rust_root, \".git\"))) or \\\n                 self.get_toml('submodules') == \"false\":\n             return\n-        print('Updating submodules')\n+        slow_submodules = self.get_toml('fast-submodules') == \"false\"\n+        start_time = time()\n+        if slow_submodules:\n+            print('Unconditionally updating all submodules')\n+        else:\n+            print('Updating only changed submodules')\n         default_encoding = sys.getdefaultencoding()\n-        run([\"git\", \"submodule\", \"-q\", \"sync\"], cwd=self.rust_root, verbose=self.verbose)\n         submodules = [s.split(' ', 1)[1] for s in subprocess.check_output(\n             [\"git\", \"config\", \"--file\",\n              os.path.join(self.rust_root, \".gitmodules\"),\n              \"--get-regexp\", \"path\"]\n         ).decode(default_encoding).splitlines()]\n-        submodules = [module for module in submodules\n-                      if not ((module.endswith(\"llvm\") and\n-                               self.get_toml('llvm-config')) or\n-                              (module.endswith(\"jemalloc\") and\n-                               (self.get_toml('use-jemalloc') == \"false\" or\n-                                self.get_toml('jemalloc'))))]\n-        run([\"git\", \"submodule\", \"update\",\n-             \"--init\", \"--recursive\"] + submodules,\n-            cwd=self.rust_root, verbose=self.verbose)\n-        run([\"git\", \"submodule\", \"-q\", \"foreach\", \"git\",\n-             \"reset\", \"-q\", \"--hard\"],\n-            cwd=self.rust_root, verbose=self.verbose)\n-        run([\"git\", \"submodule\", \"-q\", \"foreach\", \"git\",\n-             \"clean\", \"-qdfx\"],\n-            cwd=self.rust_root, verbose=self.verbose)\n+        filtered_submodules = []\n+        submodules_names = []\n+        for module in submodules:\n+            if module.endswith(\"llvm\"):\n+                if self.get_toml('llvm-config'):\n+                    continue\n+            if module.endswith(\"llvm-emscripten\"):\n+                backends = self.get_toml('codegen-backends')\n+                if backends is None or not 'emscripten' in backends:\n+                    continue\n+            if module.endswith(\"jemalloc\"):\n+                if self.get_toml('use-jemalloc') == 'false':\n+                    continue\n+                if self.get_toml('jemalloc'):\n+                    continue\n+            if module.endswith(\"lld\"):\n+                config = self.get_toml('lld')\n+                if config is None or config == 'false':\n+                    continue\n+            if module.endswith(\"lldb\") or module.endswith(\"clang\"):\n+                config = self.get_toml('lldb')\n+                if config is None or config == 'false':\n+                    continue\n+            check = self.check_submodule(module, slow_submodules)\n+            filtered_submodules.append((module, check))\n+            submodules_names.append(module)\n+        recorded = subprocess.Popen([\"git\", \"ls-tree\", \"HEAD\"] + submodules_names,\n+                                    cwd=self.rust_root, stdout=subprocess.PIPE)\n+        recorded = recorded.communicate()[0].decode(default_encoding).strip().splitlines()\n+        recorded_submodules = {}\n+        for data in recorded:\n+            data = data.split()\n+            recorded_submodules[data[3]] = data[2]\n+        for module in filtered_submodules:\n+            self.update_submodule(module[0], module[1], recorded_submodules)\n+        print(\"Submodules updated in %.2f seconds\" % (time() - start_time))\n \n     def set_dev_environment(self):\n         \"\"\"Set download URL for development environment\"\"\"\n         self._download_url = 'https://dev-static.rust-lang.org'\n \n \n-def bootstrap():\n+def bootstrap(help_triggered):\n     \"\"\"Configure, fetch, build and run the initial bootstrap\"\"\"\n+\n+    # If the user is asking for help, let them know that the whole download-and-build\n+    # process has to happen before anything is printed out.\n+    if help_triggered:\n+        print(\"info: Downloading and building bootstrap before processing --help\")\n+        print(\"      command. See src/bootstrap/README.md for help with common\")\n+        print(\"      commands.\")\n+\n     parser = argparse.ArgumentParser(description='Build rust')\n     parser.add_argument('--config')\n     parser.add_argument('--build')\n+    parser.add_argument('--src')\n     parser.add_argument('--clean', action='store_true')\n-    parser.add_argument('-v', '--verbose', action='store_true')\n+    parser.add_argument('-v', '--verbose', action='count', default=0)\n \n     args = [a for a in sys.argv if a != '-h' and a != '--help']\n     args, _ = parser.parse_known_args(args)\n \n     # Configure initial bootstrap\n     build = RustBuild()\n+    build.rust_root = args.src or os.path.abspath(os.path.join(__file__, '../../..'))\n     build.verbose = args.verbose\n     build.clean = args.clean\n \n@@ -687,10 +776,9 @@ def bootstrap():\n     except (OSError, IOError):\n         pass\n \n-    if '\\nverbose = 2' in build.config_toml:\n-        build.verbose = 2\n-    elif '\\nverbose = 1' in build.config_toml:\n-        build.verbose = 1\n+    match = re.search(r'\\nverbose = (\\d+)', build.config_toml)\n+    if match is not None:\n+        build.verbose = max(build.verbose, int(match.group(1)))\n \n     build.use_vendored_sources = '\\nvendor = true' in build.config_toml\n \n@@ -703,12 +791,12 @@ def bootstrap():\n             print('      and so in order to preserve your $HOME this will now')\n             print('      use vendored sources by default. Note that if this')\n             print('      does not work you should run a normal build first')\n-            print('      before running a command like `sudo make install`')\n+            print('      before running a command like `sudo ./x.py install`')\n \n     if build.use_vendored_sources:\n         if not os.path.exists('.cargo'):\n             os.makedirs('.cargo')\n-        with open('.cargo/config', 'w') as cargo_config:\n+        with output('.cargo/config') as cargo_config:\n             cargo_config.write(\"\"\"\n                 [source.crates-io]\n                 replace-with = 'vendored-sources'\n@@ -746,6 +834,10 @@ def bootstrap():\n     env[\"SRC\"] = build.rust_root\n     env[\"BOOTSTRAP_PARENT_ID\"] = str(os.getpid())\n     env[\"BOOTSTRAP_PYTHON\"] = sys.executable\n+    env[\"BUILD_DIR\"] = build.build_dir\n+    env[\"RUSTC_BOOTSTRAP\"] = '1'\n+    env[\"CARGO\"] = build.cargo()\n+    env[\"RUSTC\"] = build.rustc()\n     run(args, env=env, verbose=build.verbose)\n \n \n@@ -755,7 +847,7 @@ def main():\n     help_triggered = (\n         '-h' in sys.argv) or ('--help' in sys.argv) or (len(sys.argv) == 1)\n     try:\n-        bootstrap()\n+        bootstrap(help_triggered)\n         if not help_triggered:\n             print(\"Build completed successfully in {}\".format(\n                 format_build_time(time() - start_time)))"}, {"sha": "12c1972c22039aa4b4b8a498b326bfc70823269a", "filename": "src/bootstrap/builder.rs", "status": "modified", "additions": 1279, "deletions": 179, "changes": 1458, "blob_url": "https://github.com/rust-lang/rust/blob/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fbootstrap%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fbootstrap%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder.rs?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd", "patch": "@@ -9,36 +9,47 @@\n // except according to those terms.\n \n use std::any::Any;\n-use std::cell::RefCell;\n+use std::cell::{Cell, RefCell};\n use std::collections::BTreeSet;\n+use std::collections::HashMap;\n use std::env;\n use std::fmt::Debug;\n use std::fs;\n use std::hash::Hash;\n use std::ops::Deref;\n use std::path::{Path, PathBuf};\n use std::process::Command;\n+use std::time::{Duration, Instant};\n \n+use cache::{Cache, Interned, INTERNER};\n+use check;\n use compile;\n-use install;\n use dist;\n-use util::{exe, libdir, add_lib_path};\n-use {Build, Mode};\n-use cache::{INTERNER, Interned, Cache};\n-use check;\n-use flags::Subcommand;\n use doc;\n-use tool;\n+use flags::Subcommand;\n+use install;\n use native;\n+use test;\n+use tool;\n+use util::{add_lib_path, exe, libdir};\n+use {Build, DocTests, Mode};\n \n pub use Compiler;\n \n+use petgraph::graph::NodeIndex;\n+use petgraph::Graph;\n+\n pub struct Builder<'a> {\n     pub build: &'a Build,\n     pub top_stage: u32,\n     pub kind: Kind,\n     cache: Cache,\n-    stack: RefCell<Vec<Box<Any>>>,\n+    stack: RefCell<Vec<Box<dyn Any>>>,\n+    time_spent_on_dependencies: Cell<Duration>,\n+    pub paths: Vec<PathBuf>,\n+    graph_nodes: RefCell<HashMap<String, NodeIndex>>,\n+    graph: RefCell<Graph<String, bool>>,\n+    parent: Cell<Option<NodeIndex>>,\n }\n \n impl<'a> Deref for Builder<'a> {\n@@ -59,12 +70,6 @@ pub trait Step: 'static + Clone + Debug + PartialEq + Eq + Hash {\n     /// Run this rule for all hosts without cross compiling.\n     const ONLY_HOSTS: bool = false;\n \n-    /// Run this rule for all targets, but only with the native host.\n-    const ONLY_BUILD_TARGETS: bool = false;\n-\n-    /// Only run this step with the build triple as host and target.\n-    const ONLY_BUILD: bool = false;\n-\n     /// Primary function to execute this rule. Can call `builder.ensure(...)`\n     /// with other steps to run those.\n     fn run(self, builder: &Builder) -> Self::Output;\n@@ -94,56 +99,92 @@ pub struct RunConfig<'a> {\n     pub builder: &'a Builder<'a>,\n     pub host: Interned<String>,\n     pub target: Interned<String>,\n-    pub path: Option<&'a Path>,\n+    pub path: PathBuf,\n }\n \n struct StepDescription {\n     default: bool,\n     only_hosts: bool,\n-    only_build_targets: bool,\n-    only_build: bool,\n     should_run: fn(ShouldRun) -> ShouldRun,\n     make_run: fn(RunConfig),\n+    name: &'static str,\n+}\n+\n+#[derive(Debug, Clone, PartialOrd, Ord, PartialEq, Eq)]\n+pub enum PathSet {\n+    Set(BTreeSet<PathBuf>),\n+    Suite(PathBuf),\n+}\n+\n+impl PathSet {\n+    fn empty() -> PathSet {\n+        PathSet::Set(BTreeSet::new())\n+    }\n+\n+    fn one<P: Into<PathBuf>>(path: P) -> PathSet {\n+        let mut set = BTreeSet::new();\n+        set.insert(path.into());\n+        PathSet::Set(set)\n+    }\n+\n+    fn has(&self, needle: &Path) -> bool {\n+        match self {\n+            PathSet::Set(set) => set.iter().any(|p| p.ends_with(needle)),\n+            PathSet::Suite(_) => false,\n+        }\n+    }\n+\n+    fn path(&self, builder: &Builder) -> PathBuf {\n+        match self {\n+            PathSet::Set(set) => set\n+                .iter()\n+                .next()\n+                .unwrap_or(&builder.build.src)\n+                .to_path_buf(),\n+            PathSet::Suite(path) => PathBuf::from(path),\n+        }\n+    }\n }\n \n impl StepDescription {\n     fn from<S: Step>() -> StepDescription {\n         StepDescription {\n             default: S::DEFAULT,\n             only_hosts: S::ONLY_HOSTS,\n-            only_build_targets: S::ONLY_BUILD_TARGETS,\n-            only_build: S::ONLY_BUILD,\n             should_run: S::should_run,\n             make_run: S::make_run,\n+            name: unsafe { ::std::intrinsics::type_name::<S>() },\n         }\n     }\n \n-    fn maybe_run(&self, builder: &Builder, path: Option<&Path>) {\n-        let build = builder.build;\n-        let hosts = if self.only_build_targets || self.only_build {\n-            build.build_triple()\n-        } else {\n-            &build.hosts\n-        };\n+    fn maybe_run(&self, builder: &Builder, pathset: &PathSet) {\n+        if builder.config.exclude.iter().any(|e| pathset.has(e)) {\n+            eprintln!(\"Skipping {:?} because it is excluded\", pathset);\n+            return;\n+        } else if !builder.config.exclude.is_empty() {\n+            eprintln!(\n+                \"{:?} not skipped for {:?} -- not in {:?}\",\n+                pathset, self.name, builder.config.exclude\n+            );\n+        }\n+        let hosts = &builder.hosts;\n \n         // Determine the targets participating in this rule.\n         let targets = if self.only_hosts {\n-            if build.config.run_host_only {\n-                &[]\n-            } else if self.only_build {\n-                build.build_triple()\n+            if !builder.config.run_host_only {\n+                return; // don't run anything\n             } else {\n-                &build.hosts\n+                &builder.hosts\n             }\n         } else {\n-            &build.targets\n+            &builder.targets\n         };\n \n         for host in hosts {\n             for target in targets {\n                 let run = RunConfig {\n                     builder,\n-                    path,\n+                    path: pathset.path(builder),\n                     host: *host,\n                     target: *target,\n                 };\n@@ -153,27 +194,49 @@ impl StepDescription {\n     }\n \n     fn run(v: &[StepDescription], builder: &Builder, paths: &[PathBuf]) {\n-        let should_runs = v.iter().map(|desc| {\n-            (desc.should_run)(ShouldRun::new(builder))\n-        }).collect::<Vec<_>>();\n+        let should_runs = v\n+            .iter()\n+            .map(|desc| (desc.should_run)(ShouldRun::new(builder)))\n+            .collect::<Vec<_>>();\n+\n+        // sanity checks on rules\n+        for (desc, should_run) in v.iter().zip(&should_runs) {\n+            assert!(\n+                !should_run.paths.is_empty(),\n+                \"{:?} should have at least one pathset\",\n+                desc.name\n+            );\n+        }\n+\n         if paths.is_empty() {\n             for (desc, should_run) in v.iter().zip(should_runs) {\n                 if desc.default && should_run.is_really_default {\n-                    desc.maybe_run(builder, None);\n+                    for pathset in &should_run.paths {\n+                        desc.maybe_run(builder, pathset);\n+                    }\n                 }\n             }\n         } else {\n             for path in paths {\n+                // strip CurDir prefix if present\n+                let path = match path.strip_prefix(\".\") {\n+                    Ok(p) => p,\n+                    Err(_) => path,\n+                };\n+\n                 let mut attempted_run = false;\n                 for (desc, should_run) in v.iter().zip(&should_runs) {\n-                    if should_run.run(path) {\n+                    if let Some(suite) = should_run.is_suite_path(path) {\n                         attempted_run = true;\n-                        desc.maybe_run(builder, Some(path));\n+                        desc.maybe_run(builder, suite);\n+                    } else if let Some(pathset) = should_run.pathset_for_path(path) {\n+                        attempted_run = true;\n+                        desc.maybe_run(builder, pathset);\n                     }\n                 }\n \n                 if !attempted_run {\n-                    eprintln!(\"Warning: no rules matched {}.\", path.display());\n+                    panic!(\"Error: no rules matched {}.\", path.display());\n                 }\n             }\n         }\n@@ -184,10 +247,10 @@ impl StepDescription {\n pub struct ShouldRun<'a> {\n     pub builder: &'a Builder<'a>,\n     // use a BTreeSet to maintain sort order\n-    paths: BTreeSet<PathBuf>,\n+    paths: BTreeSet<PathSet>,\n \n     // If this is a default rule, this is an additional constraint placed on\n-    // it's run. Generally something like compiler docs being enabled.\n+    // its run. Generally something like compiler docs being enabled.\n     is_really_default: bool,\n }\n \n@@ -205,31 +268,64 @@ impl<'a> ShouldRun<'a> {\n         self\n     }\n \n+    // Unlike `krate` this will create just one pathset. As such, it probably shouldn't actually\n+    // ever be used, but as we transition to having all rules properly handle passing krate(...) by\n+    // actually doing something different for every crate passed.\n+    pub fn all_krates(mut self, name: &str) -> Self {\n+        let mut set = BTreeSet::new();\n+        for krate in self.builder.in_tree_crates(name) {\n+            set.insert(PathBuf::from(&krate.path));\n+        }\n+        self.paths.insert(PathSet::Set(set));\n+        self\n+    }\n+\n     pub fn krate(mut self, name: &str) -> Self {\n-        for (_, krate_path) in self.builder.crates(name) {\n-            self.paths.insert(PathBuf::from(krate_path));\n+        for krate in self.builder.in_tree_crates(name) {\n+            self.paths.insert(PathSet::one(&krate.path));\n         }\n         self\n     }\n \n-    pub fn path(mut self, path: &str) -> Self {\n-        self.paths.insert(PathBuf::from(path));\n+    // single, non-aliased path\n+    pub fn path(self, path: &str) -> Self {\n+        self.paths(&[path])\n+    }\n+\n+    // multiple aliases for the same job\n+    pub fn paths(mut self, paths: &[&str]) -> Self {\n+        self.paths\n+            .insert(PathSet::Set(paths.iter().map(PathBuf::from).collect()));\n+        self\n+    }\n+\n+    pub fn is_suite_path(&self, path: &Path) -> Option<&PathSet> {\n+        self.paths.iter().find(|pathset| match pathset {\n+            PathSet::Suite(p) => path.starts_with(p),\n+            PathSet::Set(_) => false,\n+        })\n+    }\n+\n+    pub fn suite_path(mut self, suite: &str) -> Self {\n+        self.paths.insert(PathSet::Suite(PathBuf::from(suite)));\n         self\n     }\n \n     // allows being more explicit about why should_run in Step returns the value passed to it\n-    pub fn never(self) -> ShouldRun<'a> {\n+    pub fn never(mut self) -> ShouldRun<'a> {\n+        self.paths.insert(PathSet::empty());\n         self\n     }\n \n-    fn run(&self, path: &Path) -> bool {\n-        self.paths.iter().any(|p| path.ends_with(p))\n+    fn pathset_for_path(&self, path: &Path) -> Option<&PathSet> {\n+        self.paths.iter().find(|pathset| pathset.has(path))\n     }\n }\n \n #[derive(Copy, Clone, PartialEq, Eq, Debug)]\n pub enum Kind {\n     Build,\n+    Check,\n     Test,\n     Bench,\n     Dist,\n@@ -245,26 +341,141 @@ impl<'a> Builder<'a> {\n             }};\n         }\n         match kind {\n-            Kind::Build => describe!(compile::Std, compile::Test, compile::Rustc,\n-                compile::StartupObjects, tool::BuildManifest, tool::Rustbook, tool::ErrorIndex,\n-                tool::UnstableBookGen, tool::Tidy, tool::Linkchecker, tool::CargoTest,\n-                tool::Compiletest, tool::RemoteTestServer, tool::RemoteTestClient,\n-                tool::RustInstaller, tool::Cargo, tool::Rls, tool::Rustdoc, tool::Clippy,\n-                native::Llvm, tool::Rustfmt, tool::Miri),\n-            Kind::Test => describe!(check::Tidy, check::Bootstrap, check::DefaultCompiletest,\n-                check::HostCompiletest, check::Crate, check::CrateLibrustc, check::Rustdoc,\n-                check::Linkcheck, check::Cargotest, check::Cargo, check::Rls, check::Docs,\n-                check::ErrorIndex, check::Distcheck, check::Rustfmt, check::Miri, check::Clippy),\n-            Kind::Bench => describe!(check::Crate, check::CrateLibrustc),\n-            Kind::Doc => describe!(doc::UnstableBook, doc::UnstableBookGen, doc::TheBook,\n-                doc::Standalone, doc::Std, doc::Test, doc::Rustc, doc::ErrorIndex, doc::Nomicon,\n-                doc::Reference, doc::Rustdoc, doc::RustByExample, doc::CargoBook),\n-            Kind::Dist => describe!(dist::Docs, dist::Mingw, dist::Rustc, dist::DebuggerScripts,\n-                dist::Std, dist::Analysis, dist::Src, dist::PlainSourceTarball, dist::Cargo,\n-                dist::Rls, dist::Rustfmt, dist::Extended, dist::HashSign,\n-                dist::DontDistWithMiriEnabled),\n-            Kind::Install => describe!(install::Docs, install::Std, install::Cargo, install::Rls,\n-                install::Rustfmt, install::Analysis, install::Src, install::Rustc),\n+            Kind::Build => describe!(\n+                compile::Std,\n+                compile::Test,\n+                compile::Rustc,\n+                compile::CodegenBackend,\n+                compile::StartupObjects,\n+                tool::BuildManifest,\n+                tool::Rustbook,\n+                tool::ErrorIndex,\n+                tool::UnstableBookGen,\n+                tool::Tidy,\n+                tool::Linkchecker,\n+                tool::CargoTest,\n+                tool::Compiletest,\n+                tool::RemoteTestServer,\n+                tool::RemoteTestClient,\n+                tool::RustInstaller,\n+                tool::Cargo,\n+                tool::Rls,\n+                tool::Rustdoc,\n+                tool::Clippy,\n+                native::Llvm,\n+                tool::Rustfmt,\n+                tool::Miri,\n+                native::Lld\n+            ),\n+            Kind::Check => describe!(\n+                check::Std,\n+                check::Test,\n+                check::Rustc,\n+                check::CodegenBackend,\n+                check::Rustdoc\n+            ),\n+            Kind::Test => describe!(\n+                test::Tidy,\n+                test::Ui,\n+                test::RunPass,\n+                test::CompileFail,\n+                test::ParseFail,\n+                test::RunFail,\n+                test::RunPassValgrind,\n+                test::MirOpt,\n+                test::Codegen,\n+                test::CodegenUnits,\n+                test::Incremental,\n+                test::Debuginfo,\n+                test::UiFullDeps,\n+                test::RunPassFullDeps,\n+                test::RunFailFullDeps,\n+                test::CompileFailFullDeps,\n+                test::IncrementalFullDeps,\n+                test::Rustdoc,\n+                test::Pretty,\n+                test::RunPassPretty,\n+                test::RunFailPretty,\n+                test::RunPassValgrindPretty,\n+                test::RunPassFullDepsPretty,\n+                test::RunFailFullDepsPretty,\n+                test::Crate,\n+                test::CrateLibrustc,\n+                test::CrateRustdoc,\n+                test::Linkcheck,\n+                test::Cargotest,\n+                test::Cargo,\n+                test::Rls,\n+                test::ErrorIndex,\n+                test::Distcheck,\n+                test::RunMakeFullDeps,\n+                test::Nomicon,\n+                test::Reference,\n+                test::RustdocBook,\n+                test::RustByExample,\n+                test::TheBook,\n+                test::UnstableBook,\n+                test::RustcBook,\n+                test::Rustfmt,\n+                test::Miri,\n+                test::Clippy,\n+                test::RustdocJS,\n+                test::RustdocTheme,\n+                // Run bootstrap close to the end as it's unlikely to fail\n+                test::Bootstrap,\n+                // Run run-make last, since these won't pass without make on Windows\n+                test::RunMake,\n+                test::RustdocUi\n+            ),\n+            Kind::Bench => describe!(test::Crate, test::CrateLibrustc),\n+            Kind::Doc => describe!(\n+                doc::UnstableBook,\n+                doc::UnstableBookGen,\n+                doc::TheBook,\n+                doc::Standalone,\n+                doc::Std,\n+                doc::Test,\n+                doc::WhitelistedRustc,\n+                doc::Rustc,\n+                doc::Rustdoc,\n+                doc::ErrorIndex,\n+                doc::Nomicon,\n+                doc::Reference,\n+                doc::RustdocBook,\n+                doc::RustByExample,\n+                doc::RustcBook,\n+                doc::CargoBook\n+            ),\n+            Kind::Dist => describe!(\n+                dist::Docs,\n+                dist::RustcDocs,\n+                dist::Mingw,\n+                dist::Rustc,\n+                dist::DebuggerScripts,\n+                dist::Std,\n+                dist::Analysis,\n+                dist::Src,\n+                dist::PlainSourceTarball,\n+                dist::Cargo,\n+                dist::Rls,\n+                dist::Rustfmt,\n+                dist::Clippy,\n+                dist::LlvmTools,\n+                dist::Lldb,\n+                dist::Extended,\n+                dist::HashSign\n+            ),\n+            Kind::Install => describe!(\n+                install::Docs,\n+                install::Std,\n+                install::Cargo,\n+                install::Rls,\n+                install::Rustfmt,\n+                install::Clippy,\n+                install::Analysis,\n+                install::Src,\n+                install::Rustc\n+            ),\n         }\n     }\n \n@@ -285,6 +496,11 @@ impl<'a> Builder<'a> {\n             kind,\n             cache: Cache::new(),\n             stack: RefCell::new(Vec::new()),\n+            time_spent_on_dependencies: Cell::new(Duration::new(0, 0)),\n+            paths: vec![],\n+            graph_nodes: RefCell::new(HashMap::new()),\n+            graph: RefCell::new(Graph::new()),\n+            parent: Cell::new(None),\n         };\n \n         let builder = &builder;\n@@ -293,15 +509,22 @@ impl<'a> Builder<'a> {\n             should_run = (desc.should_run)(should_run);\n         }\n         let mut help = String::from(\"Available paths:\\n\");\n-        for path in should_run.paths {\n-            help.push_str(format!(\"    ./x.py {} {}\\n\", subcommand, path.display()).as_str());\n+        for pathset in should_run.paths {\n+            if let PathSet::Set(set) = pathset {\n+                set.iter().for_each(|path| {\n+                    help.push_str(\n+                        format!(\"    ./x.py {} {}\\n\", subcommand, path.display()).as_str(),\n+                    )\n+                })\n+            }\n         }\n         Some(help)\n     }\n \n-    pub fn run(build: &Build) {\n+    pub fn new(build: &Build) -> Builder {\n         let (kind, paths) = match build.config.cmd {\n             Subcommand::Build { ref paths } => (Kind::Build, &paths[..]),\n+            Subcommand::Check { ref paths } => (Kind::Check, &paths[..]),\n             Subcommand::Doc { ref paths } => (Kind::Doc, &paths[..]),\n             Subcommand::Test { ref paths, .. } => (Kind::Test, &paths[..]),\n             Subcommand::Bench { ref paths, .. } => (Kind::Bench, &paths[..]),\n@@ -316,22 +539,47 @@ impl<'a> Builder<'a> {\n             kind,\n             cache: Cache::new(),\n             stack: RefCell::new(Vec::new()),\n+            time_spent_on_dependencies: Cell::new(Duration::new(0, 0)),\n+            paths: paths.to_owned(),\n+            graph_nodes: RefCell::new(HashMap::new()),\n+            graph: RefCell::new(Graph::new()),\n+            parent: Cell::new(None),\n         };\n \n-        StepDescription::run(&Builder::get_step_descriptions(builder.kind), &builder, paths);\n+        if kind == Kind::Dist {\n+            assert!(\n+                !builder.config.test_miri,\n+                \"Do not distribute with miri enabled.\\n\\\n+                The distributed libraries would include all MIR (increasing binary size).\n+                The distributed MIR would include validation statements.\"\n+            );\n+        }\n+\n+        builder\n+    }\n+\n+    pub fn execute_cli(&self) -> Graph<String, bool> {\n+        self.run_step_descriptions(&Builder::get_step_descriptions(self.kind), &self.paths);\n+        self.graph.borrow().clone()\n     }\n \n     pub fn default_doc(&self, paths: Option<&[PathBuf]>) {\n         let paths = paths.unwrap_or(&[]);\n-        StepDescription::run(&Builder::get_step_descriptions(Kind::Doc), self, paths);\n+        self.run_step_descriptions(&Builder::get_step_descriptions(Kind::Doc), paths);\n+    }\n+\n+    fn run_step_descriptions(&self, v: &[StepDescription], paths: &[PathBuf]) {\n+        StepDescription::run(v, self, paths);\n     }\n \n     /// Obtain a compiler at a given stage and for a given host. Explicitly does\n     /// not take `Compiler` since all `Compiler` instances are meant to be\n     /// obtained through this function, since it ensures that they are valid\n     /// (i.e., built and assembled).\n     pub fn compiler(&self, stage: u32, host: Interned<String>) -> Compiler {\n-        self.ensure(compile::Assemble { target_compiler: Compiler { stage, host } })\n+        self.ensure(compile::Assemble {\n+            target_compiler: Compiler { stage, host },\n+        })\n     }\n \n     pub fn sysroot(&self, compiler: Compiler) -> Interned<PathBuf> {\n@@ -341,7 +589,9 @@ impl<'a> Builder<'a> {\n     /// Returns the libdir where the standard library and other artifacts are\n     /// found for a compiler's sysroot.\n     pub fn sysroot_libdir(\n-        &self, compiler: Compiler, target: Interned<String>\n+        &self,\n+        compiler: Compiler,\n+        target: Interned<String>,\n     ) -> Interned<PathBuf> {\n         #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n         struct Libdir {\n@@ -357,13 +607,18 @@ impl<'a> Builder<'a> {\n \n             fn run(self, builder: &Builder) -> Interned<PathBuf> {\n                 let compiler = self.compiler;\n-                let lib = if compiler.stage >= 1 && builder.build.config.libdir.is_some() {\n-                    builder.build.config.libdir.clone().unwrap()\n+                let config = &builder.build.config;\n+                let lib = if compiler.stage >= 1 && config.libdir_relative().is_some() {\n+                    builder.build.config.libdir_relative().unwrap()\n                 } else {\n-                    PathBuf::from(\"lib\")\n+                    Path::new(\"lib\")\n                 };\n-                let sysroot = builder.sysroot(self.compiler).join(lib)\n-                    .join(\"rustlib\").join(self.target).join(\"lib\");\n+                let sysroot = builder\n+                    .sysroot(self.compiler)\n+                    .join(lib)\n+                    .join(\"rustlib\")\n+                    .join(self.target)\n+                    .join(\"lib\");\n                 let _ = fs::remove_dir_all(&sysroot);\n                 t!(fs::create_dir_all(&sysroot));\n                 INTERNER.intern_path(sysroot)\n@@ -372,14 +627,19 @@ impl<'a> Builder<'a> {\n         self.ensure(Libdir { compiler, target })\n     }\n \n+    pub fn sysroot_codegen_backends(&self, compiler: Compiler) -> PathBuf {\n+        self.sysroot_libdir(compiler, compiler.host)\n+            .with_file_name(self.config.rust_codegen_backends_dir.clone())\n+    }\n+\n     /// Returns the compiler's libdir where it stores the dynamic libraries that\n     /// it itself links against.\n     ///\n     /// For example this returns `<sysroot>/lib` on Unix and `<sysroot>/bin` on\n     /// Windows.\n     pub fn rustc_libdir(&self, compiler: Compiler) -> PathBuf {\n         if compiler.is_snapshot(self) {\n-            self.build.rustc_snapshot_libdir()\n+            self.rustc_snapshot_libdir()\n         } else {\n             self.sysroot(compiler).join(libdir(&compiler.host))\n         }\n@@ -392,7 +652,7 @@ impl<'a> Builder<'a> {\n         // compiler live next to the compiler and the system will find them\n         // automatically.\n         if cfg!(windows) {\n-            return\n+            return;\n         }\n \n         add_lib_path(vec![self.rustc_libdir(compiler)], cmd);\n@@ -403,7 +663,9 @@ impl<'a> Builder<'a> {\n         if compiler.is_snapshot(self) {\n             self.initial_rustc.clone()\n         } else {\n-            self.sysroot(compiler).join(\"bin\").join(exe(\"rustc\", &compiler.host))\n+            self.sysroot(compiler)\n+                .join(\"bin\")\n+                .join(exe(\"rustc\", &compiler.host))\n         }\n     }\n \n@@ -415,13 +677,16 @@ impl<'a> Builder<'a> {\n         let mut cmd = Command::new(&self.out.join(\"bootstrap/debug/rustdoc\"));\n         let compiler = self.compiler(self.top_stage, host);\n         cmd.env(\"RUSTC_STAGE\", compiler.stage.to_string())\n-           .env(\"RUSTC_SYSROOT\", self.sysroot(compiler))\n-           .env(\"RUSTDOC_LIBDIR\", self.sysroot_libdir(compiler, self.build.build))\n-           .env(\"CFG_RELEASE_CHANNEL\", &self.build.config.channel)\n-           .env(\"RUSTDOC_REAL\", self.rustdoc(host))\n-           .env(\"RUSTDOC_CRATE_VERSION\", self.build.rust_version())\n-           .env(\"RUSTC_BOOTSTRAP\", \"1\");\n-        if let Some(linker) = self.build.linker(host) {\n+            .env(\"RUSTC_SYSROOT\", self.sysroot(compiler))\n+            .env(\n+                \"RUSTDOC_LIBDIR\",\n+                self.sysroot_libdir(compiler, self.config.build),\n+            )\n+            .env(\"CFG_RELEASE_CHANNEL\", &self.config.channel)\n+            .env(\"RUSTDOC_REAL\", self.rustdoc(host))\n+            .env(\"RUSTDOC_CRATE_VERSION\", self.rust_version())\n+            .env(\"RUSTC_BOOTSTRAP\", \"1\");\n+        if let Some(linker) = self.linker(host) {\n             cmd.env(\"RUSTC_TARGET_LINKER\", linker);\n         }\n         cmd\n@@ -434,26 +699,48 @@ impl<'a> Builder<'a> {\n     /// rustc compiler, its output will be scoped by `mode`'s output directory,\n     /// it will pass the `--target` flag for the specified `target`, and will be\n     /// executing the Cargo command `cmd`.\n-    pub fn cargo(&self,\n-             compiler: Compiler,\n-             mode: Mode,\n-             target: Interned<String>,\n-             cmd: &str) -> Command {\n+    pub fn cargo(\n+        &self,\n+        compiler: Compiler,\n+        mode: Mode,\n+        target: Interned<String>,\n+        cmd: &str,\n+    ) -> Command {\n         let mut cargo = Command::new(&self.initial_cargo);\n         let out_dir = self.stage_out(compiler, mode);\n-        cargo.env(\"CARGO_TARGET_DIR\", out_dir)\n-             .arg(cmd)\n-             .arg(\"--target\").arg(target);\n+        cargo\n+            .env(\"CARGO_TARGET_DIR\", out_dir)\n+            .arg(cmd);\n \n-        // If we were invoked from `make` then that's already got a jobserver\n-        // set up for us so no need to tell Cargo about jobs all over again.\n-        if env::var_os(\"MAKEFLAGS\").is_none() && env::var_os(\"MFLAGS\").is_none() {\n-             cargo.arg(\"-j\").arg(self.jobs().to_string());\n+        if cmd != \"install\" {\n+            cargo.arg(\"--target\")\n+                 .arg(target);\n+        } else {\n+            assert_eq!(target, compiler.host);\n+        }\n+\n+        // Set a flag for `check` so that certain build scripts can do less work\n+        // (e.g. not building/requiring LLVM).\n+        if cmd == \"check\" {\n+            cargo.env(\"RUST_CHECK\", \"1\");\n         }\n \n+        cargo.arg(\"-j\").arg(self.jobs().to_string());\n+        // Remove make-related flags to ensure Cargo can correctly set things up\n+        cargo.env_remove(\"MAKEFLAGS\");\n+        cargo.env_remove(\"MFLAGS\");\n+\n         // FIXME: Temporary fix for https://github.com/rust-lang/cargo/issues/3005\n         // Force cargo to output binaries with disambiguating hashes in the name\n-        cargo.env(\"__CARGO_DEFAULT_LIB_METADATA\", &self.config.channel);\n+        let metadata = if compiler.stage == 0 {\n+            // Treat stage0 like special channel, whether it's a normal prior-\n+            // release rustc or a local rebuild with the same version, so we\n+            // never mix these libraries by accident.\n+            \"bootstrap\"\n+        } else {\n+            &self.config.channel\n+        };\n+        cargo.env(\"__CARGO_DEFAULT_LIB_METADATA\", &metadata);\n \n         let stage;\n         if compiler.stage == 0 && self.local_rebuild {\n@@ -463,49 +750,103 @@ impl<'a> Builder<'a> {\n             stage = compiler.stage;\n         }\n \n+        let mut extra_args = env::var(&format!(\"RUSTFLAGS_STAGE_{}\", stage)).unwrap_or_default();\n+        if stage != 0 {\n+            let s = env::var(\"RUSTFLAGS_STAGE_NOT_0\").unwrap_or_default();\n+            if !extra_args.is_empty() {\n+                extra_args.push_str(\" \");\n+            }\n+            extra_args.push_str(&s);\n+        }\n+\n+        if !extra_args.is_empty() {\n+            cargo.env(\n+                \"RUSTFLAGS\",\n+                format!(\n+                    \"{} {}\",\n+                    env::var(\"RUSTFLAGS\").unwrap_or_default(),\n+                    extra_args\n+                ),\n+            );\n+        }\n+\n+        let want_rustdoc = self.doc_tests != DocTests::No;\n+\n+        // We synthetically interpret a stage0 compiler used to build tools as a\n+        // \"raw\" compiler in that it's the exact snapshot we download. Normally\n+        // the stage0 build means it uses libraries build by the stage0\n+        // compiler, but for tools we just use the precompiled libraries that\n+        // we've downloaded\n+        let use_snapshot = mode == Mode::ToolBootstrap;\n+        assert!(!use_snapshot || stage == 0 || self.local_rebuild);\n+\n+        let maybe_sysroot = self.sysroot(compiler);\n+        let sysroot = if use_snapshot {\n+            self.rustc_snapshot_sysroot()\n+        } else {\n+            &maybe_sysroot\n+        };\n+        let libdir = sysroot.join(libdir(&compiler.host));\n+\n         // Customize the compiler we're running. Specify the compiler to cargo\n         // as our shim and then pass it some various options used to configure\n         // how the actual compiler itself is called.\n         //\n         // These variables are primarily all read by\n         // src/bootstrap/bin/{rustc.rs,rustdoc.rs}\n-        cargo.env(\"RUSTBUILD_NATIVE_DIR\", self.native_dir(target))\n-             .env(\"RUSTC\", self.out.join(\"bootstrap/debug/rustc\"))\n-             .env(\"RUSTC_REAL\", self.rustc(compiler))\n-             .env(\"RUSTC_STAGE\", stage.to_string())\n-             .env(\"RUSTC_DEBUG_ASSERTIONS\",\n-                  self.config.rust_debug_assertions.to_string())\n-             .env(\"RUSTC_SYSROOT\", self.sysroot(compiler))\n-             .env(\"RUSTC_LIBDIR\", self.rustc_libdir(compiler))\n-             .env(\"RUSTC_RPATH\", self.config.rust_rpath.to_string())\n-             .env(\"RUSTDOC\", self.out.join(\"bootstrap/debug/rustdoc\"))\n-             .env(\"RUSTDOC_REAL\", if cmd == \"doc\" || cmd == \"test\" {\n-                 self.rustdoc(compiler.host)\n-             } else {\n-                 PathBuf::from(\"/path/to/nowhere/rustdoc/not/required\")\n-             })\n-             .env(\"TEST_MIRI\", self.config.test_miri.to_string())\n-             .env(\"RUSTC_ERROR_METADATA_DST\", self.extended_error_dir());\n-        if let Some(n) = self.config.rust_codegen_units {\n-            cargo.env(\"RUSTC_CODEGEN_UNITS\", n.to_string());\n-        }\n+        cargo\n+            .env(\"RUSTBUILD_NATIVE_DIR\", self.native_dir(target))\n+            .env(\"RUSTC\", self.out.join(\"bootstrap/debug/rustc\"))\n+            .env(\"RUSTC_REAL\", self.rustc(compiler))\n+            .env(\"RUSTC_STAGE\", stage.to_string())\n+            .env(\n+                \"RUSTC_DEBUG_ASSERTIONS\",\n+                self.config.rust_debug_assertions.to_string(),\n+            )\n+            .env(\"RUSTC_SYSROOT\", &sysroot)\n+            .env(\"RUSTC_LIBDIR\", &libdir)\n+            .env(\"RUSTC_RPATH\", self.config.rust_rpath.to_string())\n+            .env(\"RUSTDOC\", self.out.join(\"bootstrap/debug/rustdoc\"))\n+            .env(\n+                \"RUSTDOC_REAL\",\n+                if cmd == \"doc\" || (cmd == \"test\" && want_rustdoc) {\n+                    self.rustdoc(compiler.host)\n+                } else {\n+                    PathBuf::from(\"/path/to/nowhere/rustdoc/not/required\")\n+                },\n+            )\n+            .env(\"TEST_MIRI\", self.config.test_miri.to_string())\n+            .env(\"RUSTC_ERROR_METADATA_DST\", self.extended_error_dir());\n \n-        if let Some(host_linker) = self.build.linker(compiler.host) {\n+        if let Some(host_linker) = self.linker(compiler.host) {\n             cargo.env(\"RUSTC_HOST_LINKER\", host_linker);\n         }\n-        if let Some(target_linker) = self.build.linker(target) {\n+        if let Some(target_linker) = self.linker(target) {\n             cargo.env(\"RUSTC_TARGET_LINKER\", target_linker);\n         }\n-        if cmd != \"build\" {\n-            cargo.env(\"RUSTDOC_LIBDIR\", self.rustc_libdir(self.compiler(2, self.build.build)));\n+        if let Some(ref error_format) = self.config.rustc_error_format {\n+            cargo.env(\"RUSTC_ERROR_FORMAT\", error_format);\n+        }\n+        if cmd != \"build\" && cmd != \"check\" && want_rustdoc {\n+            cargo.env(\"RUSTDOC_LIBDIR\", self.sysroot_libdir(compiler, self.config.build));\n         }\n \n-        if mode != Mode::Tool {\n-            // Tools don't get debuginfo right now, e.g. cargo and rls don't\n-            // get compiled with debuginfo.\n-            // Adding debuginfo increases their sizes by a factor of 3-4.\n+        if mode.is_tool() {\n+            // Tools like cargo and rls don't get debuginfo by default right now, but this can be\n+            // enabled in the config.  Adding debuginfo makes them several times larger.\n+            if self.config.rust_debuginfo_tools {\n+                cargo.env(\"RUSTC_DEBUGINFO\", self.config.rust_debuginfo.to_string());\n+                cargo.env(\n+                    \"RUSTC_DEBUGINFO_LINES\",\n+                    self.config.rust_debuginfo_lines.to_string(),\n+                );\n+            }\n+        } else {\n             cargo.env(\"RUSTC_DEBUGINFO\", self.config.rust_debuginfo.to_string());\n-            cargo.env(\"RUSTC_DEBUGINFO_LINES\", self.config.rust_debuginfo_lines.to_string());\n+            cargo.env(\n+                \"RUSTC_DEBUGINFO_LINES\",\n+                self.config.rust_debuginfo_lines.to_string(),\n+            );\n             cargo.env(\"RUSTC_FORCE_UNSTABLE\", \"1\");\n \n             // Currently the compiler depends on crates from crates.io, and\n@@ -531,6 +872,10 @@ impl<'a> Builder<'a> {\n             cargo.env(\"RUSTC_CRT_STATIC\", x.to_string());\n         }\n \n+        if let Some(x) = self.crt_static(compiler.host) {\n+            cargo.env(\"RUSTC_HOST_CRT_STATIC\", x.to_string());\n+        }\n+\n         // Enable usage of unstable features\n         cargo.env(\"RUSTC_BOOTSTRAP\", \"1\");\n         self.add_rust_test_threads(&mut cargo);\n@@ -550,28 +895,43 @@ impl<'a> Builder<'a> {\n         // build scripts in that situation.\n         //\n         // If LLVM support is disabled we need to use the snapshot compiler to compile\n-        // build scripts, as the new compiler doesnt support executables.\n-        if mode == Mode::Libstd || !self.build.config.llvm_enabled {\n-            cargo.env(\"RUSTC_SNAPSHOT\", &self.initial_rustc)\n-                 .env(\"RUSTC_SNAPSHOT_LIBDIR\", self.rustc_snapshot_libdir());\n+        // build scripts, as the new compiler doesn't support executables.\n+        if mode == Mode::Std || !self.config.llvm_enabled {\n+            cargo\n+                .env(\"RUSTC_SNAPSHOT\", &self.initial_rustc)\n+                .env(\"RUSTC_SNAPSHOT_LIBDIR\", self.rustc_snapshot_libdir());\n         } else {\n-            cargo.env(\"RUSTC_SNAPSHOT\", self.rustc(compiler))\n-                 .env(\"RUSTC_SNAPSHOT_LIBDIR\", self.rustc_libdir(compiler));\n+            cargo\n+                .env(\"RUSTC_SNAPSHOT\", self.rustc(compiler))\n+                .env(\"RUSTC_SNAPSHOT_LIBDIR\", self.rustc_libdir(compiler));\n         }\n \n-        // Ignore incremental modes except for stage0, since we're\n-        // not guaranteeing correctness across builds if the compiler\n-        // is changing under your feet.`\n-        if self.config.incremental && compiler.stage == 0 {\n-            let incr_dir = self.incremental_dir(compiler);\n-            cargo.env(\"RUSTC_INCREMENTAL\", incr_dir);\n+        if self.config.incremental {\n+            cargo.env(\"CARGO_INCREMENTAL\", \"1\");\n         }\n \n         if let Some(ref on_fail) = self.config.on_fail {\n             cargo.env(\"RUSTC_ON_FAIL\", on_fail);\n         }\n \n-        cargo.env(\"RUSTC_VERBOSE\", format!(\"{}\", self.verbosity));\n+        if self.config.print_step_timings {\n+            cargo.env(\"RUSTC_PRINT_STEP_TIMINGS\", \"1\");\n+        }\n+\n+        if self.config.backtrace_on_ice {\n+            cargo.env(\"RUSTC_BACKTRACE_ON_ICE\", \"1\");\n+        }\n+\n+        if self.config.rust_verify_llvm_ir {\n+            cargo.env(\"RUSTC_VERIFY_LLVM_IR\", \"1\");\n+        }\n+\n+        cargo.env(\"RUSTC_VERBOSE\", self.verbosity.to_string());\n+\n+        // in std, we want to avoid denying warnings for stage 0 as that makes cfg's painful.\n+        if self.config.deny_warnings && !(mode == Mode::Std && stage == 0) {\n+            cargo.env(\"RUSTC_DENY_WARNINGS\", \"1\");\n+        }\n \n         // Throughout the build Cargo can execute a number of build scripts\n         // compiling C/C++ code and we need to pass compilers, archivers, flags, etc\n@@ -580,61 +940,125 @@ impl<'a> Builder<'a> {\n         // the options through environment variables that are fetched and understood by both.\n         //\n         // FIXME: the guard against msvc shouldn't need to be here\n-        if !target.contains(\"msvc\") {\n-            let cc = self.cc(target);\n-            cargo.env(format!(\"CC_{}\", target), cc)\n-                 .env(\"CC\", cc);\n+        if target.contains(\"msvc\") {\n+            if let Some(ref cl) = self.config.llvm_clang_cl {\n+                cargo.env(\"CC\", cl).env(\"CXX\", cl);\n+            }\n+        } else {\n+            let ccache = self.config.ccache.as_ref();\n+            let ccacheify = |s: &Path| {\n+                let ccache = match ccache {\n+                    Some(ref s) => s,\n+                    None => return s.display().to_string(),\n+                };\n+                // FIXME: the cc-rs crate only recognizes the literal strings\n+                // `ccache` and `sccache` when doing caching compilations, so we\n+                // mirror that here. It should probably be fixed upstream to\n+                // accept a new env var or otherwise work with custom ccache\n+                // vars.\n+                match &ccache[..] {\n+                    \"ccache\" | \"sccache\" => format!(\"{} {}\", ccache, s.display()),\n+                    _ => s.display().to_string(),\n+                }\n+            };\n+            let cc = ccacheify(&self.cc(target));\n+            cargo.env(format!(\"CC_{}\", target), &cc).env(\"CC\", &cc);\n \n             let cflags = self.cflags(target).join(\" \");\n-            cargo.env(format!(\"CFLAGS_{}\", target), cflags.clone())\n-                 .env(\"CFLAGS\", cflags.clone());\n+            cargo\n+                .env(format!(\"CFLAGS_{}\", target), cflags.clone())\n+                .env(\"CFLAGS\", cflags.clone());\n \n             if let Some(ar) = self.ar(target) {\n                 let ranlib = format!(\"{} s\", ar.display());\n-                cargo.env(format!(\"AR_{}\", target), ar)\n-                     .env(\"AR\", ar)\n-                     .env(format!(\"RANLIB_{}\", target), ranlib.clone())\n-                     .env(\"RANLIB\", ranlib);\n+                cargo\n+                    .env(format!(\"AR_{}\", target), ar)\n+                    .env(\"AR\", ar)\n+                    .env(format!(\"RANLIB_{}\", target), ranlib.clone())\n+                    .env(\"RANLIB\", ranlib);\n             }\n \n             if let Ok(cxx) = self.cxx(target) {\n-                cargo.env(format!(\"CXX_{}\", target), cxx)\n-                     .env(\"CXX\", cxx)\n-                     .env(format!(\"CXXFLAGS_{}\", target), cflags.clone())\n-                     .env(\"CXXFLAGS\", cflags);\n+                let cxx = ccacheify(&cxx);\n+                cargo\n+                    .env(format!(\"CXX_{}\", target), &cxx)\n+                    .env(\"CXX\", &cxx)\n+                    .env(format!(\"CXXFLAGS_{}\", target), cflags.clone())\n+                    .env(\"CXXFLAGS\", cflags);\n             }\n         }\n \n-        if mode == Mode::Libstd && self.config.extended && compiler.is_final_stage(self) {\n+        if cmd == \"build\"\n+            && mode == Mode::Std\n+            && self.config.extended\n+            && compiler.is_final_stage(self)\n+        {\n             cargo.env(\"RUSTC_SAVE_ANALYSIS\", \"api\".to_string());\n         }\n \n         // For `cargo doc` invocations, make rustdoc print the Rust version into the docs\n-        cargo.env(\"RUSTDOC_CRATE_VERSION\", self.build.rust_version());\n+        cargo.env(\"RUSTDOC_CRATE_VERSION\", self.rust_version());\n \n         // Environment variables *required* throughout the build\n         //\n         // FIXME: should update code to not require this env var\n         cargo.env(\"CFG_COMPILER_HOST_TRIPLE\", target);\n \n         // Set this for all builds to make sure doc builds also get it.\n-        cargo.env(\"CFG_RELEASE_CHANNEL\", &self.build.config.channel);\n+        cargo.env(\"CFG_RELEASE_CHANNEL\", &self.config.channel);\n+\n+        // This one's a bit tricky. As of the time of this writing the compiler\n+        // links to the `winapi` crate on crates.io. This crate provides raw\n+        // bindings to Windows system functions, sort of like libc does for\n+        // Unix. This crate also, however, provides \"import libraries\" for the\n+        // MinGW targets. There's an import library per dll in the windows\n+        // distribution which is what's linked to. These custom import libraries\n+        // are used because the winapi crate can reference Windows functions not\n+        // present in the MinGW import libraries.\n+        //\n+        // For example MinGW may ship libdbghelp.a, but it may not have\n+        // references to all the functions in the dbghelp dll. Instead the\n+        // custom import library for dbghelp in the winapi crates has all this\n+        // information.\n+        //\n+        // Unfortunately for us though the import libraries are linked by\n+        // default via `-ldylib=winapi_foo`. That is, they're linked with the\n+        // `dylib` type with a `winapi_` prefix (so the winapi ones don't\n+        // conflict with the system MinGW ones). This consequently means that\n+        // the binaries we ship of things like rustc_codegen_llvm (aka the rustc_codegen_llvm\n+        // DLL) when linked against *again*, for example with procedural macros\n+        // or plugins, will trigger the propagation logic of `-ldylib`, passing\n+        // `-lwinapi_foo` to the linker again. This isn't actually available in\n+        // our distribution, however, so the link fails.\n+        //\n+        // To solve this problem we tell winapi to not use its bundled import\n+        // libraries. This means that it will link to the system MinGW import\n+        // libraries by default, and the `-ldylib=foo` directives will still get\n+        // passed to the final linker, but they'll look like `-lfoo` which can\n+        // be resolved because MinGW has the import library. The downside is we\n+        // don't get newer functions from Windows, but we don't use any of them\n+        // anyway.\n+        if !mode.is_tool() {\n+            cargo.env(\"WINAPI_NO_BUNDLED_LIBRARIES\", \"1\");\n+        }\n \n-        if self.is_very_verbose() {\n+        for _ in 1..self.verbosity {\n             cargo.arg(\"-v\");\n         }\n+\n+        // This must be kept before the thinlto check, as we set codegen units\n+        // to 1 forcibly there.\n+        if let Some(n) = self.config.rust_codegen_units {\n+            cargo.env(\"RUSTC_CODEGEN_UNITS\", n.to_string());\n+        }\n+\n         if self.config.rust_optimize {\n-            // FIXME: cargo bench does not accept `--release`\n-            if cmd != \"bench\" {\n+            // FIXME: cargo bench/install do not accept `--release`\n+            if cmd != \"bench\" && cmd != \"install\" {\n                 cargo.arg(\"--release\");\n             }\n-\n-            if self.config.rust_codegen_units.is_none() &&\n-               self.build.is_rust_llvm(compiler.host)\n-            {\n-                cargo.env(\"RUSTC_THINLTO\", \"1\");\n-            }\n         }\n+\n         if self.config.locked_deps {\n             cargo.arg(\"--locked\");\n         }\n@@ -647,15 +1071,18 @@ impl<'a> Builder<'a> {\n         cargo\n     }\n \n-    /// Ensure that a given step is built, returning it's output. This will\n+    /// Ensure that a given step is built, returning its output. This will\n     /// cache the step, so it is safe (and good!) to call this as often as\n     /// needed to ensure that all dependencies are built.\n     pub fn ensure<S: Step>(&'a self, step: S) -> S::Output {\n         {\n             let mut stack = self.stack.borrow_mut();\n             for stack_step in stack.iter() {\n                 // should skip\n-                if stack_step.downcast_ref::<S>().map_or(true, |stack_step| *stack_step != step) {\n+                if stack_step\n+                    .downcast_ref::<S>()\n+                    .map_or(true, |stack_step| *stack_step != step)\n+                {\n                     continue;\n                 }\n                 let mut out = String::new();\n@@ -666,21 +1093,694 @@ impl<'a> Builder<'a> {\n                 panic!(out);\n             }\n             if let Some(out) = self.cache.get(&step) {\n-                self.build.verbose(&format!(\"{}c {:?}\", \"  \".repeat(stack.len()), step));\n+                self.verbose(&format!(\"{}c {:?}\", \"  \".repeat(stack.len()), step));\n+\n+                {\n+                    let mut graph = self.graph.borrow_mut();\n+                    let parent = self.parent.get();\n+                    let us = *self\n+                        .graph_nodes\n+                        .borrow_mut()\n+                        .entry(format!(\"{:?}\", step))\n+                        .or_insert_with(|| graph.add_node(format!(\"{:?}\", step)));\n+                    if let Some(parent) = parent {\n+                        graph.add_edge(parent, us, false);\n+                    }\n+                }\n \n                 return out;\n             }\n-            self.build.verbose(&format!(\"{}> {:?}\", \"  \".repeat(stack.len()), step));\n+            self.verbose(&format!(\"{}> {:?}\", \"  \".repeat(stack.len()), step));\n             stack.push(Box::new(step.clone()));\n         }\n-        let out = step.clone().run(self);\n+\n+        let prev_parent = self.parent.get();\n+\n+        {\n+            let mut graph = self.graph.borrow_mut();\n+            let parent = self.parent.get();\n+            let us = *self\n+                .graph_nodes\n+                .borrow_mut()\n+                .entry(format!(\"{:?}\", step))\n+                .or_insert_with(|| graph.add_node(format!(\"{:?}\", step)));\n+            self.parent.set(Some(us));\n+            if let Some(parent) = parent {\n+                graph.add_edge(parent, us, true);\n+            }\n+        }\n+\n+        let (out, dur) = {\n+            let start = Instant::now();\n+            let zero = Duration::new(0, 0);\n+            let parent = self.time_spent_on_dependencies.replace(zero);\n+            let out = step.clone().run(self);\n+            let dur = start.elapsed();\n+            let deps = self.time_spent_on_dependencies.replace(parent + dur);\n+            (out, dur - deps)\n+        };\n+\n+        self.parent.set(prev_parent);\n+\n+        if self.config.print_step_timings && dur > Duration::from_millis(100) {\n+            println!(\n+                \"[TIMING] {:?} -- {}.{:03}\",\n+                step,\n+                dur.as_secs(),\n+                dur.subsec_nanos() / 1_000_000\n+            );\n+        }\n+\n         {\n             let mut stack = self.stack.borrow_mut();\n             let cur_step = stack.pop().expect(\"step stack empty\");\n             assert_eq!(cur_step.downcast_ref(), Some(&step));\n         }\n-        self.build.verbose(&format!(\"{}< {:?}\", \"  \".repeat(self.stack.borrow().len()), step));\n+        self.verbose(&format!(\n+            \"{}< {:?}\",\n+            \"  \".repeat(self.stack.borrow().len()),\n+            step\n+        ));\n         self.cache.put(step, out.clone());\n         out\n     }\n }\n+\n+#[cfg(test)]\n+mod __test {\n+    use super::*;\n+    use config::Config;\n+    use std::thread;\n+\n+    fn configure(host: &[&str], target: &[&str]) -> Config {\n+        let mut config = Config::default_opts();\n+        // don't save toolstates\n+        config.save_toolstates = None;\n+        config.run_host_only = true;\n+        config.dry_run = true;\n+        // try to avoid spurious failures in dist where we create/delete each others file\n+        let dir = config.out.join(\"tmp-rustbuild-tests\").join(\n+            &thread::current()\n+                .name()\n+                .unwrap_or(\"unknown\")\n+                .replace(\":\", \"-\"),\n+        );\n+        t!(fs::create_dir_all(&dir));\n+        config.out = dir;\n+        config.build = INTERNER.intern_str(\"A\");\n+        config.hosts = vec![config.build]\n+            .clone()\n+            .into_iter()\n+            .chain(host.iter().map(|s| INTERNER.intern_str(s)))\n+            .collect::<Vec<_>>();\n+        config.targets = config\n+            .hosts\n+            .clone()\n+            .into_iter()\n+            .chain(target.iter().map(|s| INTERNER.intern_str(s)))\n+            .collect::<Vec<_>>();\n+        config\n+    }\n+\n+    fn first<A, B>(v: Vec<(A, B)>) -> Vec<A> {\n+        v.into_iter().map(|(a, _)| a).collect::<Vec<_>>()\n+    }\n+\n+    #[test]\n+    fn dist_baseline() {\n+        let build = Build::new(configure(&[], &[]));\n+        let mut builder = Builder::new(&build);\n+        builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Dist), &[]);\n+\n+        let a = INTERNER.intern_str(\"A\");\n+\n+        assert_eq!(\n+            first(builder.cache.all::<dist::Docs>()),\n+            &[dist::Docs { stage: 2, host: a },]\n+        );\n+        assert_eq!(\n+            first(builder.cache.all::<dist::Mingw>()),\n+            &[dist::Mingw { host: a },]\n+        );\n+        assert_eq!(\n+            first(builder.cache.all::<dist::Rustc>()),\n+            &[dist::Rustc {\n+                compiler: Compiler { host: a, stage: 2 }\n+            },]\n+        );\n+        assert_eq!(\n+            first(builder.cache.all::<dist::Std>()),\n+            &[dist::Std {\n+                compiler: Compiler { host: a, stage: 2 },\n+                target: a,\n+            },]\n+        );\n+        assert_eq!(first(builder.cache.all::<dist::Src>()), &[dist::Src]);\n+    }\n+\n+    #[test]\n+    fn dist_with_targets() {\n+        let build = Build::new(configure(&[], &[\"B\"]));\n+        let mut builder = Builder::new(&build);\n+        builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Dist), &[]);\n+\n+        let a = INTERNER.intern_str(\"A\");\n+        let b = INTERNER.intern_str(\"B\");\n+\n+        assert_eq!(\n+            first(builder.cache.all::<dist::Docs>()),\n+            &[\n+                dist::Docs { stage: 2, host: a },\n+                dist::Docs { stage: 2, host: b },\n+            ]\n+        );\n+        assert_eq!(\n+            first(builder.cache.all::<dist::Mingw>()),\n+            &[dist::Mingw { host: a }, dist::Mingw { host: b },]\n+        );\n+        assert_eq!(\n+            first(builder.cache.all::<dist::Rustc>()),\n+            &[dist::Rustc {\n+                compiler: Compiler { host: a, stage: 2 }\n+            },]\n+        );\n+        assert_eq!(\n+            first(builder.cache.all::<dist::Std>()),\n+            &[\n+                dist::Std {\n+                    compiler: Compiler { host: a, stage: 2 },\n+                    target: a,\n+                },\n+                dist::Std {\n+                    compiler: Compiler { host: a, stage: 2 },\n+                    target: b,\n+                },\n+            ]\n+        );\n+        assert_eq!(first(builder.cache.all::<dist::Src>()), &[dist::Src]);\n+    }\n+\n+    #[test]\n+    fn dist_with_hosts() {\n+        let build = Build::new(configure(&[\"B\"], &[]));\n+        let mut builder = Builder::new(&build);\n+        builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Dist), &[]);\n+\n+        let a = INTERNER.intern_str(\"A\");\n+        let b = INTERNER.intern_str(\"B\");\n+\n+        assert_eq!(\n+            first(builder.cache.all::<dist::Docs>()),\n+            &[\n+                dist::Docs { stage: 2, host: a },\n+                dist::Docs { stage: 2, host: b },\n+            ]\n+        );\n+        assert_eq!(\n+            first(builder.cache.all::<dist::Mingw>()),\n+            &[dist::Mingw { host: a }, dist::Mingw { host: b },]\n+        );\n+        assert_eq!(\n+            first(builder.cache.all::<dist::Rustc>()),\n+            &[\n+                dist::Rustc {\n+                    compiler: Compiler { host: a, stage: 2 }\n+                },\n+                dist::Rustc {\n+                    compiler: Compiler { host: b, stage: 2 }\n+                },\n+            ]\n+        );\n+        assert_eq!(\n+            first(builder.cache.all::<dist::Std>()),\n+            &[\n+                dist::Std {\n+                    compiler: Compiler { host: a, stage: 2 },\n+                    target: a,\n+                },\n+                dist::Std {\n+                    compiler: Compiler { host: a, stage: 2 },\n+                    target: b,\n+                },\n+            ]\n+        );\n+        assert_eq!(first(builder.cache.all::<dist::Src>()), &[dist::Src]);\n+    }\n+\n+    #[test]\n+    fn dist_with_targets_and_hosts() {\n+        let build = Build::new(configure(&[\"B\"], &[\"C\"]));\n+        let mut builder = Builder::new(&build);\n+        builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Dist), &[]);\n+\n+        let a = INTERNER.intern_str(\"A\");\n+        let b = INTERNER.intern_str(\"B\");\n+        let c = INTERNER.intern_str(\"C\");\n+\n+        assert_eq!(\n+            first(builder.cache.all::<dist::Docs>()),\n+            &[\n+                dist::Docs { stage: 2, host: a },\n+                dist::Docs { stage: 2, host: b },\n+                dist::Docs { stage: 2, host: c },\n+            ]\n+        );\n+        assert_eq!(\n+            first(builder.cache.all::<dist::Mingw>()),\n+            &[\n+                dist::Mingw { host: a },\n+                dist::Mingw { host: b },\n+                dist::Mingw { host: c },\n+            ]\n+        );\n+        assert_eq!(\n+            first(builder.cache.all::<dist::Rustc>()),\n+            &[\n+                dist::Rustc {\n+                    compiler: Compiler { host: a, stage: 2 }\n+                },\n+                dist::Rustc {\n+                    compiler: Compiler { host: b, stage: 2 }\n+                },\n+            ]\n+        );\n+        assert_eq!(\n+            first(builder.cache.all::<dist::Std>()),\n+            &[\n+                dist::Std {\n+                    compiler: Compiler { host: a, stage: 2 },\n+                    target: a,\n+                },\n+                dist::Std {\n+                    compiler: Compiler { host: a, stage: 2 },\n+                    target: b,\n+                },\n+                dist::Std {\n+                    compiler: Compiler { host: a, stage: 2 },\n+                    target: c,\n+                },\n+            ]\n+        );\n+        assert_eq!(first(builder.cache.all::<dist::Src>()), &[dist::Src]);\n+    }\n+\n+    #[test]\n+    fn dist_with_target_flag() {\n+        let mut config = configure(&[\"B\"], &[\"C\"]);\n+        config.run_host_only = false; // as-if --target=C was passed\n+        let build = Build::new(config);\n+        let mut builder = Builder::new(&build);\n+        builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Dist), &[]);\n+\n+        let a = INTERNER.intern_str(\"A\");\n+        let b = INTERNER.intern_str(\"B\");\n+        let c = INTERNER.intern_str(\"C\");\n+\n+        assert_eq!(\n+            first(builder.cache.all::<dist::Docs>()),\n+            &[\n+                dist::Docs { stage: 2, host: a },\n+                dist::Docs { stage: 2, host: b },\n+                dist::Docs { stage: 2, host: c },\n+            ]\n+        );\n+        assert_eq!(\n+            first(builder.cache.all::<dist::Mingw>()),\n+            &[\n+                dist::Mingw { host: a },\n+                dist::Mingw { host: b },\n+                dist::Mingw { host: c },\n+            ]\n+        );\n+        assert_eq!(first(builder.cache.all::<dist::Rustc>()), &[]);\n+        assert_eq!(\n+            first(builder.cache.all::<dist::Std>()),\n+            &[\n+                dist::Std {\n+                    compiler: Compiler { host: a, stage: 2 },\n+                    target: a,\n+                },\n+                dist::Std {\n+                    compiler: Compiler { host: a, stage: 2 },\n+                    target: b,\n+                },\n+                dist::Std {\n+                    compiler: Compiler { host: a, stage: 2 },\n+                    target: c,\n+                },\n+            ]\n+        );\n+        assert_eq!(first(builder.cache.all::<dist::Src>()), &[]);\n+    }\n+\n+    #[test]\n+    fn dist_with_same_targets_and_hosts() {\n+        let build = Build::new(configure(&[\"B\"], &[\"B\"]));\n+        let mut builder = Builder::new(&build);\n+        builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Dist), &[]);\n+\n+        let a = INTERNER.intern_str(\"A\");\n+        let b = INTERNER.intern_str(\"B\");\n+\n+        assert_eq!(\n+            first(builder.cache.all::<dist::Docs>()),\n+            &[\n+                dist::Docs { stage: 2, host: a },\n+                dist::Docs { stage: 2, host: b },\n+            ]\n+        );\n+        assert_eq!(\n+            first(builder.cache.all::<dist::Mingw>()),\n+            &[dist::Mingw { host: a }, dist::Mingw { host: b },]\n+        );\n+        assert_eq!(\n+            first(builder.cache.all::<dist::Rustc>()),\n+            &[\n+                dist::Rustc {\n+                    compiler: Compiler { host: a, stage: 2 }\n+                },\n+                dist::Rustc {\n+                    compiler: Compiler { host: b, stage: 2 }\n+                },\n+            ]\n+        );\n+        assert_eq!(\n+            first(builder.cache.all::<dist::Std>()),\n+            &[\n+                dist::Std {\n+                    compiler: Compiler { host: a, stage: 2 },\n+                    target: a,\n+                },\n+                dist::Std {\n+                    compiler: Compiler { host: a, stage: 2 },\n+                    target: b,\n+                },\n+            ]\n+        );\n+        assert_eq!(first(builder.cache.all::<dist::Src>()), &[dist::Src]);\n+        assert_eq!(\n+            first(builder.cache.all::<compile::Std>()),\n+            &[\n+                compile::Std {\n+                    compiler: Compiler { host: a, stage: 0 },\n+                    target: a,\n+                },\n+                compile::Std {\n+                    compiler: Compiler { host: a, stage: 1 },\n+                    target: a,\n+                },\n+                compile::Std {\n+                    compiler: Compiler { host: a, stage: 2 },\n+                    target: a,\n+                },\n+                compile::Std {\n+                    compiler: Compiler { host: a, stage: 1 },\n+                    target: b,\n+                },\n+                compile::Std {\n+                    compiler: Compiler { host: a, stage: 2 },\n+                    target: b,\n+                },\n+            ]\n+        );\n+        assert_eq!(\n+            first(builder.cache.all::<compile::Test>()),\n+            &[\n+                compile::Test {\n+                    compiler: Compiler { host: a, stage: 0 },\n+                    target: a,\n+                },\n+                compile::Test {\n+                    compiler: Compiler { host: a, stage: 1 },\n+                    target: a,\n+                },\n+                compile::Test {\n+                    compiler: Compiler { host: a, stage: 2 },\n+                    target: a,\n+                },\n+                compile::Test {\n+                    compiler: Compiler { host: a, stage: 1 },\n+                    target: b,\n+                },\n+                compile::Test {\n+                    compiler: Compiler { host: a, stage: 2 },\n+                    target: b,\n+                },\n+            ]\n+        );\n+        assert_eq!(\n+            first(builder.cache.all::<compile::Assemble>()),\n+            &[\n+                compile::Assemble {\n+                    target_compiler: Compiler { host: a, stage: 0 },\n+                },\n+                compile::Assemble {\n+                    target_compiler: Compiler { host: a, stage: 1 },\n+                },\n+                compile::Assemble {\n+                    target_compiler: Compiler { host: a, stage: 2 },\n+                },\n+                compile::Assemble {\n+                    target_compiler: Compiler { host: b, stage: 2 },\n+                },\n+            ]\n+        );\n+    }\n+\n+    #[test]\n+    fn build_default() {\n+        let build = Build::new(configure(&[\"B\"], &[\"C\"]));\n+        let mut builder = Builder::new(&build);\n+        builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Build), &[]);\n+\n+        let a = INTERNER.intern_str(\"A\");\n+        let b = INTERNER.intern_str(\"B\");\n+        let c = INTERNER.intern_str(\"C\");\n+\n+        assert!(!builder.cache.all::<compile::Std>().is_empty());\n+        assert!(!builder.cache.all::<compile::Assemble>().is_empty());\n+        assert_eq!(\n+            first(builder.cache.all::<compile::Rustc>()),\n+            &[\n+                compile::Rustc {\n+                    compiler: Compiler { host: a, stage: 0 },\n+                    target: a,\n+                },\n+                compile::Rustc {\n+                    compiler: Compiler { host: a, stage: 1 },\n+                    target: a,\n+                },\n+                compile::Rustc {\n+                    compiler: Compiler { host: a, stage: 2 },\n+                    target: a,\n+                },\n+                compile::Rustc {\n+                    compiler: Compiler { host: b, stage: 2 },\n+                    target: a,\n+                },\n+                compile::Rustc {\n+                    compiler: Compiler { host: a, stage: 0 },\n+                    target: b,\n+                },\n+                compile::Rustc {\n+                    compiler: Compiler { host: a, stage: 1 },\n+                    target: b,\n+                },\n+                compile::Rustc {\n+                    compiler: Compiler { host: a, stage: 2 },\n+                    target: b,\n+                },\n+                compile::Rustc {\n+                    compiler: Compiler { host: b, stage: 2 },\n+                    target: b,\n+                },\n+            ]\n+        );\n+\n+        assert_eq!(\n+            first(builder.cache.all::<compile::Test>()),\n+            &[\n+                compile::Test {\n+                    compiler: Compiler { host: a, stage: 0 },\n+                    target: a,\n+                },\n+                compile::Test {\n+                    compiler: Compiler { host: a, stage: 1 },\n+                    target: a,\n+                },\n+                compile::Test {\n+                    compiler: Compiler { host: a, stage: 2 },\n+                    target: a,\n+                },\n+                compile::Test {\n+                    compiler: Compiler { host: b, stage: 2 },\n+                    target: a,\n+                },\n+                compile::Test {\n+                    compiler: Compiler { host: a, stage: 0 },\n+                    target: b,\n+                },\n+                compile::Test {\n+                    compiler: Compiler { host: a, stage: 1 },\n+                    target: b,\n+                },\n+                compile::Test {\n+                    compiler: Compiler { host: a, stage: 2 },\n+                    target: b,\n+                },\n+                compile::Test {\n+                    compiler: Compiler { host: b, stage: 2 },\n+                    target: b,\n+                },\n+                compile::Test {\n+                    compiler: Compiler { host: a, stage: 2 },\n+                    target: c,\n+                },\n+                compile::Test {\n+                    compiler: Compiler { host: b, stage: 2 },\n+                    target: c,\n+                },\n+            ]\n+        );\n+    }\n+\n+    #[test]\n+    fn build_with_target_flag() {\n+        let mut config = configure(&[\"B\"], &[\"C\"]);\n+        config.run_host_only = false;\n+        let build = Build::new(config);\n+        let mut builder = Builder::new(&build);\n+        builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Build), &[]);\n+\n+        let a = INTERNER.intern_str(\"A\");\n+        let b = INTERNER.intern_str(\"B\");\n+        let c = INTERNER.intern_str(\"C\");\n+\n+        assert!(!builder.cache.all::<compile::Std>().is_empty());\n+        assert_eq!(\n+            first(builder.cache.all::<compile::Assemble>()),\n+            &[\n+                compile::Assemble {\n+                    target_compiler: Compiler { host: a, stage: 0 },\n+                },\n+                compile::Assemble {\n+                    target_compiler: Compiler { host: a, stage: 1 },\n+                },\n+                compile::Assemble {\n+                    target_compiler: Compiler { host: b, stage: 1 },\n+                },\n+                compile::Assemble {\n+                    target_compiler: Compiler { host: a, stage: 2 },\n+                },\n+                compile::Assemble {\n+                    target_compiler: Compiler { host: b, stage: 2 },\n+                },\n+            ]\n+        );\n+        assert_eq!(\n+            first(builder.cache.all::<compile::Rustc>()),\n+            &[\n+                compile::Rustc {\n+                    compiler: Compiler { host: a, stage: 0 },\n+                    target: a,\n+                },\n+                compile::Rustc {\n+                    compiler: Compiler { host: a, stage: 1 },\n+                    target: a,\n+                },\n+                compile::Rustc {\n+                    compiler: Compiler { host: a, stage: 0 },\n+                    target: b,\n+                },\n+                compile::Rustc {\n+                    compiler: Compiler { host: a, stage: 1 },\n+                    target: b,\n+                },\n+            ]\n+        );\n+\n+        assert_eq!(\n+            first(builder.cache.all::<compile::Test>()),\n+            &[\n+                compile::Test {\n+                    compiler: Compiler { host: a, stage: 0 },\n+                    target: a,\n+                },\n+                compile::Test {\n+                    compiler: Compiler { host: a, stage: 1 },\n+                    target: a,\n+                },\n+                compile::Test {\n+                    compiler: Compiler { host: a, stage: 2 },\n+                    target: a,\n+                },\n+                compile::Test {\n+                    compiler: Compiler { host: b, stage: 2 },\n+                    target: a,\n+                },\n+                compile::Test {\n+                    compiler: Compiler { host: a, stage: 0 },\n+                    target: b,\n+                },\n+                compile::Test {\n+                    compiler: Compiler { host: a, stage: 1 },\n+                    target: b,\n+                },\n+                compile::Test {\n+                    compiler: Compiler { host: a, stage: 2 },\n+                    target: b,\n+                },\n+                compile::Test {\n+                    compiler: Compiler { host: b, stage: 2 },\n+                    target: b,\n+                },\n+                compile::Test {\n+                    compiler: Compiler { host: a, stage: 2 },\n+                    target: c,\n+                },\n+                compile::Test {\n+                    compiler: Compiler { host: b, stage: 2 },\n+                    target: c,\n+                },\n+            ]\n+        );\n+    }\n+\n+    #[test]\n+    fn test_with_no_doc_stage0() {\n+        let mut config = configure(&[], &[]);\n+        config.stage = Some(0);\n+        config.cmd = Subcommand::Test {\n+            paths: vec![\"src/libstd\".into()],\n+            test_args: vec![],\n+            rustc_args: vec![],\n+            fail_fast: true,\n+            doc_tests: DocTests::No,\n+            bless: false,\n+            compare_mode: None,\n+        };\n+\n+        let build = Build::new(config);\n+        let mut builder = Builder::new(&build);\n+\n+        let host = INTERNER.intern_str(\"A\");\n+\n+        builder.run_step_descriptions(\n+            &[StepDescription::from::<test::Crate>()],\n+            &[\"src/libstd\".into()],\n+        );\n+\n+        // Ensure we don't build any compiler artifacts.\n+        assert!(builder.cache.all::<compile::Rustc>().is_empty());\n+        assert_eq!(\n+            first(builder.cache.all::<test::Crate>()),\n+            &[test::Crate {\n+                compiler: Compiler { host, stage: 0 },\n+                target: host,\n+                mode: Mode::Std,\n+                test_kind: test::TestKind::Test,\n+                krate: INTERNER.intern_str(\"std\"),\n+            },]\n+        );\n+    }\n+}"}, {"sha": "bca5ff85ba23e846052ed1ed1b073f02579fe2ce", "filename": "src/bootstrap/cache.rs", "status": "modified", "additions": 27, "deletions": 1, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fbootstrap%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fbootstrap%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcache.rs?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd", "patch": "@@ -21,6 +21,7 @@ use std::mem;\n use std::ops::Deref;\n use std::path::{Path, PathBuf};\n use std::sync::Mutex;\n+use std::cmp::{PartialOrd, Ord, Ordering};\n \n use builder::Step;\n \n@@ -154,6 +155,19 @@ impl AsRef<OsStr> for Interned<String> {\n     }\n }\n \n+impl PartialOrd<Interned<String>> for Interned<String> {\n+    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n+        let l = INTERNER.strs.lock().unwrap();\n+        l.get(*self).partial_cmp(l.get(*other))\n+    }\n+}\n+\n+impl Ord for Interned<String> {\n+    fn cmp(&self, other: &Self) -> Ordering {\n+        let l = INTERNER.strs.lock().unwrap();\n+        l.get(*self).cmp(l.get(*other))\n+    }\n+}\n \n struct TyIntern<T> {\n     items: Vec<T>,\n@@ -235,7 +249,7 @@ lazy_static! {\n pub struct Cache(\n     RefCell<HashMap<\n         TypeId,\n-        Box<Any>, // actually a HashMap<Step, Interned<Step::Output>>\n+        Box<dyn Any>, // actually a HashMap<Step, Interned<Step::Output>>\n     >>\n );\n \n@@ -264,4 +278,16 @@ impl Cache {\n                         .expect(\"invalid type mapped\");\n         stepcache.get(step).cloned()\n     }\n+\n+    #[cfg(test)]\n+    pub fn all<S: Ord + Copy + Step>(&mut self) -> Vec<(S, S::Output)> {\n+        let cache = self.0.get_mut();\n+        let type_id = TypeId::of::<S>();\n+        let mut v = cache.remove(&type_id)\n+            .map(|b| b.downcast::<HashMap<S, S::Output>>().expect(\"correct type\"))\n+            .map(|m| m.into_iter().collect::<Vec<_>>())\n+            .unwrap_or_default();\n+        v.sort_by_key(|&(a, _)| a);\n+        v\n+    }\n }"}, {"sha": "698903f128d4dd346f60fd8848a79fa05741c997", "filename": "src/bootstrap/cc_detect.rs", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fbootstrap%2Fcc_detect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fbootstrap%2Fcc_detect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcc_detect.rs?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd", "patch": "@@ -77,8 +77,19 @@ pub fn find(build: &mut Build) {\n                                .collect::<HashSet<_>>();\n     for target in targets.into_iter() {\n         let mut cfg = cc::Build::new();\n-        cfg.cargo_metadata(false).opt_level(0).warnings(false).debug(false)\n+        cfg.cargo_metadata(false).opt_level(2).warnings(false).debug(false)\n            .target(&target).host(&build.build);\n+        match build.crt_static(target) {\n+            Some(a) => { cfg.static_crt(a); }\n+            None => {\n+                if target.contains(\"msvc\") {\n+                    cfg.static_crt(true);\n+                }\n+                if target.contains(\"musl\") {\n+                    cfg.static_flag(true);\n+                }\n+            }\n+        }\n \n         let config = build.config.target_config.get(&target);\n         if let Some(cc) = config.and_then(|c| c.cc.as_ref()) {\n@@ -94,8 +105,9 @@ pub fn find(build: &mut Build) {\n             cc2ar(compiler.path(), &target)\n         };\n \n-        build.verbose(&format!(\"CC_{} = {:?}\", &target, compiler.path()));\n         build.cc.insert(target, compiler);\n+        build.verbose(&format!(\"CC_{} = {:?}\", &target, build.cc(target)));\n+        build.verbose(&format!(\"CFLAGS_{} = {:?}\", &target, build.cflags(target)));\n         if let Some(ar) = ar {\n             build.verbose(&format!(\"AR_{} = {:?}\", &target, ar));\n             build.ar.insert(target, ar);\n@@ -106,7 +118,7 @@ pub fn find(build: &mut Build) {\n     let hosts = build.hosts.iter().cloned().chain(iter::once(build.build)).collect::<HashSet<_>>();\n     for host in hosts.into_iter() {\n         let mut cfg = cc::Build::new();\n-        cfg.cargo_metadata(false).opt_level(0).warnings(false).debug(false).cpp(true)\n+        cfg.cargo_metadata(false).opt_level(2).warnings(false).debug(false).cpp(true)\n            .target(&host).host(&build.build);\n         let config = build.config.target_config.get(&host);\n         if let Some(cxx) = config.and_then(|c| c.cxx.as_ref()) {"}, {"sha": "fa2b58fb2daa711714407124900514f49798d31b", "filename": "src/bootstrap/channel.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fbootstrap%2Fchannel.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fbootstrap%2Fchannel.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fchannel.rs?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd", "patch": "@@ -24,12 +24,7 @@ use Build;\n use config::Config;\n \n // The version number\n-pub const CFG_RELEASE_NUM: &str = \"1.25.0\";\n-\n-// An optional number to put after the label, e.g. '.2' -> '-beta.2'\n-// Be sure to make this starts with a dot to conform to semver pre-release\n-// versions (section 9)\n-pub const CFG_PRERELEASE_VERSION: &str = \".1\";\n+pub const CFG_RELEASE_NUM: &str = \"1.30.0\";\n \n pub struct GitInfo {\n     inner: Option<Info>,"}, {"sha": "133e5aa37a7db9715e55b83867e8a9ab0ad3fff2", "filename": "src/bootstrap/check.rs", "status": "modified", "additions": 155, "deletions": 1368, "changes": 1523, "blob_url": "https://github.com/rust-lang/rust/blob/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fbootstrap%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fbootstrap%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcheck.rs?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -8,1492 +8,279 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! Implementation of the test-related targets of the build system.\n-//!\n-//! This file implements the various regression test suites that we execute on\n-//! our CI.\n+//! Implementation of compiling the compiler and standard library, in \"check\" mode.\n \n-use std::collections::HashSet;\n-use std::env;\n-use std::ffi::OsString;\n-use std::iter;\n-use std::fmt;\n-use std::fs::{self, File};\n-use std::path::{PathBuf, Path};\n-use std::process::Command;\n-use std::io::Read;\n-\n-use build_helper::{self, output};\n-\n-use builder::{Kind, RunConfig, ShouldRun, Builder, Compiler, Step};\n+use compile::{run_cargo, std_cargo, test_cargo, rustc_cargo, rustc_cargo_env, add_to_sysroot};\n+use builder::{RunConfig, Builder, ShouldRun, Step};\n+use tool::{self, prepare_tool_cargo, SourceType};\n+use {Compiler, Mode};\n use cache::{INTERNER, Interned};\n-use compile;\n-use dist;\n-use native;\n-use tool::{self, Tool};\n-use util::{self, dylib_path, dylib_path_var};\n-use {Build, Mode};\n-use toolstate::ToolState;\n-\n-const ADB_TEST_DIR: &str = \"/data/tmp/work\";\n-\n-/// The two modes of the test runner; tests or benchmarks.\n-#[derive(Debug, PartialEq, Eq, Hash, Copy, Clone)]\n-pub enum TestKind {\n-    /// Run `cargo test`\n-    Test,\n-    /// Run `cargo bench`\n-    Bench,\n-}\n-\n-impl TestKind {\n-    // Return the cargo subcommand for this test kind\n-    fn subcommand(self) -> &'static str {\n-        match self {\n-            TestKind::Test => \"test\",\n-            TestKind::Bench => \"bench\",\n-        }\n-    }\n-}\n-\n-impl fmt::Display for TestKind {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        f.write_str(match *self {\n-            TestKind::Test => \"Testing\",\n-            TestKind::Bench => \"Benchmarking\",\n-        })\n-    }\n-}\n-\n-fn try_run(build: &Build, cmd: &mut Command) -> bool {\n-    if !build.fail_fast {\n-        if !build.try_run(cmd) {\n-            let mut failures = build.delayed_failures.borrow_mut();\n-            failures.push(format!(\"{:?}\", cmd));\n-            return false;\n-        }\n-    } else {\n-        build.run(cmd);\n-    }\n-    true\n-}\n-\n-fn try_run_quiet(build: &Build, cmd: &mut Command) {\n-    if !build.fail_fast {\n-        if !build.try_run_quiet(cmd) {\n-            let mut failures = build.delayed_failures.borrow_mut();\n-            failures.push(format!(\"{:?}\", cmd));\n-        }\n-    } else {\n-        build.run_quiet(cmd);\n-    }\n-}\n+use std::path::PathBuf;\n \n #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n-pub struct Linkcheck {\n-    host: Interned<String>,\n+pub struct Std {\n+    pub target: Interned<String>,\n }\n \n-impl Step for Linkcheck {\n+impl Step for Std {\n     type Output = ();\n-    const ONLY_HOSTS: bool = true;\n     const DEFAULT: bool = true;\n \n-    /// Runs the `linkchecker` tool as compiled in `stage` by the `host` compiler.\n-    ///\n-    /// This tool in `src/tools` will verify the validity of all our links in the\n-    /// documentation to ensure we don't have a bunch of dead ones.\n-    fn run(self, builder: &Builder) {\n-        let build = builder.build;\n-        let host = self.host;\n-\n-        println!(\"Linkcheck ({})\", host);\n-\n-        builder.default_doc(None);\n-\n-        let _time = util::timeit();\n-        try_run(build, builder.tool_cmd(Tool::Linkchecker)\n-                            .arg(build.out.join(host).join(\"doc\")));\n-    }\n-\n     fn should_run(run: ShouldRun) -> ShouldRun {\n-        let builder = run.builder;\n-        run.path(\"src/tools/linkchecker\").default_condition(builder.build.config.docs)\n+        run.all_krates(\"std\")\n     }\n \n     fn make_run(run: RunConfig) {\n-        run.builder.ensure(Linkcheck { host: run.target });\n-    }\n-}\n-\n-#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n-pub struct Cargotest {\n-    stage: u32,\n-    host: Interned<String>,\n-}\n-\n-impl Step for Cargotest {\n-    type Output = ();\n-    const ONLY_HOSTS: bool = true;\n-\n-    fn should_run(run: ShouldRun) -> ShouldRun {\n-        run.path(\"src/tools/cargotest\")\n-    }\n-\n-    fn make_run(run: RunConfig) {\n-        run.builder.ensure(Cargotest {\n-            stage: run.builder.top_stage,\n-            host: run.target,\n+        run.builder.ensure(Std {\n+            target: run.target,\n         });\n     }\n \n-    /// Runs the `cargotest` tool as compiled in `stage` by the `host` compiler.\n-    ///\n-    /// This tool in `src/tools` will check out a few Rust projects and run `cargo\n-    /// test` to ensure that we don't regress the test suites there.\n     fn run(self, builder: &Builder) {\n-        let build = builder.build;\n-        let compiler = builder.compiler(self.stage, self.host);\n-        builder.ensure(compile::Rustc { compiler, target: compiler.host });\n-\n-        // Note that this is a short, cryptic, and not scoped directory name. This\n-        // is currently to minimize the length of path on Windows where we otherwise\n-        // quickly run into path name limit constraints.\n-        let out_dir = build.out.join(\"ct\");\n-        t!(fs::create_dir_all(&out_dir));\n-\n-        let _time = util::timeit();\n-        let mut cmd = builder.tool_cmd(Tool::CargoTest);\n-        try_run(build, cmd.arg(&build.initial_cargo)\n-                          .arg(&out_dir)\n-                          .env(\"RUSTC\", builder.rustc(compiler))\n-                          .env(\"RUSTDOC\", builder.rustdoc(compiler.host)));\n-    }\n-}\n-\n-#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n-pub struct Cargo {\n-    stage: u32,\n-    host: Interned<String>,\n-}\n-\n-impl Step for Cargo {\n-    type Output = ();\n-    const ONLY_HOSTS: bool = true;\n-\n-    fn should_run(run: ShouldRun) -> ShouldRun {\n-        run.path(\"src/tools/cargo\")\n-    }\n-\n-    fn make_run(run: RunConfig) {\n-        run.builder.ensure(Cargo {\n-            stage: run.builder.top_stage,\n-            host: run.target,\n-        });\n-    }\n-\n-    /// Runs `cargo test` for `cargo` packaged with Rust.\n-    fn run(self, builder: &Builder) {\n-        let build = builder.build;\n-        let compiler = builder.compiler(self.stage, self.host);\n-\n-        builder.ensure(tool::Cargo { compiler, target: self.host });\n-        let mut cargo = builder.cargo(compiler, Mode::Tool, self.host, \"test\");\n-        cargo.arg(\"--manifest-path\").arg(build.src.join(\"src/tools/cargo/Cargo.toml\"));\n-        if !build.fail_fast {\n-            cargo.arg(\"--no-fail-fast\");\n-        }\n-\n-        // Don't build tests dynamically, just a pain to work with\n-        cargo.env(\"RUSTC_NO_PREFER_DYNAMIC\", \"1\");\n-\n-        // Don't run cross-compile tests, we may not have cross-compiled libstd libs\n-        // available.\n-        cargo.env(\"CFG_DISABLE_CROSS_TESTS\", \"1\");\n-\n-        try_run(build, cargo.env(\"PATH\", &path_for_cargo(builder, compiler)));\n-    }\n-}\n-\n-#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n-pub struct Rls {\n-    stage: u32,\n-    host: Interned<String>,\n-}\n-\n-impl Step for Rls {\n-    type Output = ();\n-    const ONLY_HOSTS: bool = true;\n-\n-    fn should_run(run: ShouldRun) -> ShouldRun {\n-        run.path(\"src/tools/rls\")\n-    }\n-\n-    fn make_run(run: RunConfig) {\n-        run.builder.ensure(Rls {\n-            stage: run.builder.top_stage,\n-            host: run.target,\n-        });\n-    }\n-\n-    /// Runs `cargo test` for the rls.\n-    fn run(self, builder: &Builder) {\n-        let build = builder.build;\n-        let stage = self.stage;\n-        let host = self.host;\n-        let compiler = builder.compiler(stage, host);\n-\n-        builder.ensure(tool::Rls { compiler, target: self.host });\n-        let mut cargo = tool::prepare_tool_cargo(builder,\n-                                                 compiler,\n-                                                 host,\n-                                                 \"test\",\n-                                                 \"src/tools/rls\");\n-\n-        // Don't build tests dynamically, just a pain to work with\n-        cargo.env(\"RUSTC_NO_PREFER_DYNAMIC\", \"1\");\n-\n-        builder.add_rustc_lib_path(compiler, &mut cargo);\n-\n-        if try_run(build, &mut cargo) {\n-            build.save_toolstate(\"rls\", ToolState::TestPass);\n-        }\n-    }\n-}\n-\n-#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n-pub struct Rustfmt {\n-    stage: u32,\n-    host: Interned<String>,\n-}\n-\n-impl Step for Rustfmt {\n-    type Output = ();\n-    const ONLY_HOSTS: bool = true;\n-\n-    fn should_run(run: ShouldRun) -> ShouldRun {\n-        run.path(\"src/tools/rustfmt\")\n-    }\n-\n-    fn make_run(run: RunConfig) {\n-        run.builder.ensure(Rustfmt {\n-            stage: run.builder.top_stage,\n-            host: run.target,\n-        });\n-    }\n-\n-    /// Runs `cargo test` for rustfmt.\n-    fn run(self, builder: &Builder) {\n-        let build = builder.build;\n-        let stage = self.stage;\n-        let host = self.host;\n-        let compiler = builder.compiler(stage, host);\n-\n-        builder.ensure(tool::Rustfmt { compiler, target: self.host });\n-        let mut cargo = tool::prepare_tool_cargo(builder,\n-                                                 compiler,\n-                                                 host,\n-                                                 \"test\",\n-                                                 \"src/tools/rustfmt\");\n-\n-        // Don't build tests dynamically, just a pain to work with\n-        cargo.env(\"RUSTC_NO_PREFER_DYNAMIC\", \"1\");\n-\n-        builder.add_rustc_lib_path(compiler, &mut cargo);\n-\n-        if try_run(build, &mut cargo) {\n-            build.save_toolstate(\"rustfmt\", ToolState::TestPass);\n-        }\n-    }\n-}\n-\n-#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n-pub struct Miri {\n-    stage: u32,\n-    host: Interned<String>,\n-}\n-\n-impl Step for Miri {\n-    type Output = ();\n-    const ONLY_HOSTS: bool = true;\n-    const DEFAULT: bool = true;\n-\n-    fn should_run(run: ShouldRun) -> ShouldRun {\n-        let test_miri = run.builder.build.config.test_miri;\n-        run.path(\"src/tools/miri\").default_condition(test_miri)\n-    }\n-\n-    fn make_run(run: RunConfig) {\n-        run.builder.ensure(Miri {\n-            stage: run.builder.top_stage,\n-            host: run.target,\n-        });\n-    }\n-\n-    /// Runs `cargo test` for miri.\n-    fn run(self, builder: &Builder) {\n-        let build = builder.build;\n-        let stage = self.stage;\n-        let host = self.host;\n-        let compiler = builder.compiler(stage, host);\n+        let target = self.target;\n+        let compiler = builder.compiler(0, builder.config.build);\n \n-        if let Some(miri) = builder.ensure(tool::Miri { compiler, target: self.host }) {\n-            let mut cargo = builder.cargo(compiler, Mode::Tool, host, \"test\");\n-            cargo.arg(\"--manifest-path\").arg(build.src.join(\"src/tools/miri/Cargo.toml\"));\n+        let out_dir = builder.stage_out(compiler, Mode::Std);\n+        builder.clear_if_dirty(&out_dir, &builder.rustc(compiler));\n \n-            // Don't build tests dynamically, just a pain to work with\n-            cargo.env(\"RUSTC_NO_PREFER_DYNAMIC\", \"1\");\n-            // miri tests need to know about the stage sysroot\n-            cargo.env(\"MIRI_SYSROOT\", builder.sysroot(compiler));\n-            cargo.env(\"RUSTC_TEST_SUITE\", builder.rustc(compiler));\n-            cargo.env(\"RUSTC_LIB_PATH\", builder.rustc_libdir(compiler));\n-            cargo.env(\"MIRI_PATH\", miri);\n+        let mut cargo = builder.cargo(compiler, Mode::Std, target, \"check\");\n+        std_cargo(builder, &compiler, target, &mut cargo);\n \n-            builder.add_rustc_lib_path(compiler, &mut cargo);\n+        let _folder = builder.fold_output(|| format!(\"stage{}-std\", compiler.stage));\n+        println!(\"Checking std artifacts ({} -> {})\", &compiler.host, target);\n+        run_cargo(builder,\n+                  &mut cargo,\n+                  &libstd_stamp(builder, compiler, target),\n+                  true);\n \n-            if try_run(build, &mut cargo) {\n-                build.save_toolstate(\"miri\", ToolState::TestPass);\n-            }\n-        } else {\n-            eprintln!(\"failed to test miri: could not build\");\n-        }\n+        let libdir = builder.sysroot_libdir(compiler, target);\n+        add_to_sysroot(&builder, &libdir, &libstd_stamp(builder, compiler, target));\n     }\n }\n \n #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n-pub struct Clippy {\n-    stage: u32,\n-    host: Interned<String>,\n+pub struct Rustc {\n+    pub target: Interned<String>,\n }\n \n-impl Step for Clippy {\n+impl Step for Rustc {\n     type Output = ();\n     const ONLY_HOSTS: bool = true;\n-    const DEFAULT: bool = false;\n-\n-    fn should_run(run: ShouldRun) -> ShouldRun {\n-        run.path(\"src/tools/clippy\")\n-    }\n-\n-    fn make_run(run: RunConfig) {\n-        run.builder.ensure(Clippy {\n-            stage: run.builder.top_stage,\n-            host: run.target,\n-        });\n-    }\n-\n-    /// Runs `cargo test` for clippy.\n-    fn run(self, builder: &Builder) {\n-        let build = builder.build;\n-        let stage = self.stage;\n-        let host = self.host;\n-        let compiler = builder.compiler(stage, host);\n-\n-        if let Some(clippy) = builder.ensure(tool::Clippy { compiler, target: self.host }) {\n-            let mut cargo = builder.cargo(compiler, Mode::Tool, host, \"test\");\n-            cargo.arg(\"--manifest-path\").arg(build.src.join(\"src/tools/clippy/Cargo.toml\"));\n-\n-            // Don't build tests dynamically, just a pain to work with\n-            cargo.env(\"RUSTC_NO_PREFER_DYNAMIC\", \"1\");\n-            // clippy tests need to know about the stage sysroot\n-            cargo.env(\"SYSROOT\", builder.sysroot(compiler));\n-            cargo.env(\"RUSTC_TEST_SUITE\", builder.rustc(compiler));\n-            cargo.env(\"RUSTC_LIB_PATH\", builder.rustc_libdir(compiler));\n-            let host_libs = builder.stage_out(compiler, Mode::Tool).join(builder.cargo_dir());\n-            cargo.env(\"HOST_LIBS\", host_libs);\n-            // clippy tests need to find the driver\n-            cargo.env(\"CLIPPY_DRIVER_PATH\", clippy);\n-\n-            builder.add_rustc_lib_path(compiler, &mut cargo);\n-\n-            if try_run(build, &mut cargo) {\n-                build.save_toolstate(\"clippy-driver\", ToolState::TestPass);\n-            }\n-        } else {\n-            eprintln!(\"failed to test clippy: could not build\");\n-        }\n-    }\n-}\n-\n-fn path_for_cargo(builder: &Builder, compiler: Compiler) -> OsString {\n-    // Configure PATH to find the right rustc. NB. we have to use PATH\n-    // and not RUSTC because the Cargo test suite has tests that will\n-    // fail if rustc is not spelled `rustc`.\n-    let path = builder.sysroot(compiler).join(\"bin\");\n-    let old_path = env::var_os(\"PATH\").unwrap_or_default();\n-    env::join_paths(iter::once(path).chain(env::split_paths(&old_path))).expect(\"\")\n-}\n-\n-#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n-pub struct Tidy {\n-    host: Interned<String>,\n-}\n-\n-impl Step for Tidy {\n-    type Output = ();\n     const DEFAULT: bool = true;\n-    const ONLY_HOSTS: bool = true;\n-    const ONLY_BUILD: bool = true;\n-\n-    /// Runs the `tidy` tool as compiled in `stage` by the `host` compiler.\n-    ///\n-    /// This tool in `src/tools` checks up on various bits and pieces of style and\n-    /// otherwise just implements a few lint-like checks that are specific to the\n-    /// compiler itself.\n-    fn run(self, builder: &Builder) {\n-        let build = builder.build;\n-        let host = self.host;\n-\n-        let _folder = build.fold_output(|| \"tidy\");\n-        println!(\"tidy check ({})\", host);\n-        let mut cmd = builder.tool_cmd(Tool::Tidy);\n-        cmd.arg(build.src.join(\"src\"));\n-        if !build.config.vendor {\n-            cmd.arg(\"--no-vendor\");\n-        }\n-        if build.config.quiet_tests {\n-            cmd.arg(\"--quiet\");\n-        }\n-        try_run(build, &mut cmd);\n-    }\n \n     fn should_run(run: ShouldRun) -> ShouldRun {\n-        run.path(\"src/tools/tidy\")\n-    }\n-\n-    fn make_run(run: RunConfig) {\n-        run.builder.ensure(Tidy {\n-            host: run.builder.build.build,\n-        });\n-    }\n-}\n-\n-fn testdir(build: &Build, host: Interned<String>) -> PathBuf {\n-    build.out.join(host).join(\"test\")\n-}\n-\n-#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n-struct Test {\n-    path: &'static str,\n-    mode: &'static str,\n-    suite: &'static str,\n-}\n-\n-static DEFAULT_COMPILETESTS: &[Test] = &[\n-    Test { path: \"src/test/ui\", mode: \"ui\", suite: \"ui\" },\n-    Test { path: \"src/test/run-pass\", mode: \"run-pass\", suite: \"run-pass\" },\n-    Test { path: \"src/test/compile-fail\", mode: \"compile-fail\", suite: \"compile-fail\" },\n-    Test { path: \"src/test/parse-fail\", mode: \"parse-fail\", suite: \"parse-fail\" },\n-    Test { path: \"src/test/run-fail\", mode: \"run-fail\", suite: \"run-fail\" },\n-    Test {\n-        path: \"src/test/run-pass-valgrind\",\n-        mode: \"run-pass-valgrind\",\n-        suite: \"run-pass-valgrind\"\n-    },\n-    Test { path: \"src/test/mir-opt\", mode: \"mir-opt\", suite: \"mir-opt\" },\n-    Test { path: \"src/test/codegen\", mode: \"codegen\", suite: \"codegen\" },\n-    Test { path: \"src/test/codegen-units\", mode: \"codegen-units\", suite: \"codegen-units\" },\n-    Test { path: \"src/test/incremental\", mode: \"incremental\", suite: \"incremental\" },\n-\n-    // What this runs varies depending on the native platform being apple\n-    Test { path: \"src/test/debuginfo\", mode: \"debuginfo-XXX\", suite: \"debuginfo\" },\n-];\n-\n-#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n-pub struct DefaultCompiletest {\n-    compiler: Compiler,\n-    target: Interned<String>,\n-    mode: &'static str,\n-    suite: &'static str,\n-}\n-\n-impl Step for DefaultCompiletest {\n-    type Output = ();\n-    const DEFAULT: bool = true;\n-\n-    fn should_run(mut run: ShouldRun) -> ShouldRun {\n-        for test in DEFAULT_COMPILETESTS {\n-            run = run.path(test.path);\n-        }\n-        run\n-    }\n-\n-    fn make_run(run: RunConfig) {\n-        let compiler = run.builder.compiler(run.builder.top_stage, run.host);\n-\n-        let test = run.path.map(|path| {\n-            DEFAULT_COMPILETESTS.iter().find(|&&test| {\n-                path.ends_with(test.path)\n-            }).unwrap_or_else(|| {\n-                panic!(\"make_run in compile test to receive test path, received {:?}\", path);\n-            })\n-        });\n-\n-        if let Some(test) = test {\n-            run.builder.ensure(DefaultCompiletest {\n-                compiler,\n-                target: run.target,\n-                mode: test.mode,\n-                suite: test.suite,\n-            });\n-        } else {\n-            for test in DEFAULT_COMPILETESTS {\n-                run.builder.ensure(DefaultCompiletest {\n-                    compiler,\n-                    target: run.target,\n-                    mode: test.mode,\n-                    suite: test.suite\n-                });\n-            }\n-        }\n-    }\n-\n-    fn run(self, builder: &Builder) {\n-        builder.ensure(Compiletest {\n-            compiler: self.compiler,\n-            target: self.target,\n-            mode: self.mode,\n-            suite: self.suite,\n-        })\n-    }\n-}\n-\n-// Also default, but host-only.\n-static HOST_COMPILETESTS: &[Test] = &[\n-    Test { path: \"src/test/ui-fulldeps\", mode: \"ui\", suite: \"ui-fulldeps\" },\n-    Test { path: \"src/test/run-pass-fulldeps\", mode: \"run-pass\", suite: \"run-pass-fulldeps\" },\n-    Test { path: \"src/test/run-fail-fulldeps\", mode: \"run-fail\", suite: \"run-fail-fulldeps\" },\n-    Test {\n-        path: \"src/test/compile-fail-fulldeps\",\n-        mode: \"compile-fail\",\n-        suite: \"compile-fail-fulldeps\",\n-    },\n-    Test { path: \"src/test/run-make\", mode: \"run-make\", suite: \"run-make\" },\n-    Test { path: \"src/test/rustdoc\", mode: \"rustdoc\", suite: \"rustdoc\" },\n-\n-    Test { path: \"src/test/pretty\", mode: \"pretty\", suite: \"pretty\" },\n-    Test { path: \"src/test/run-pass/pretty\", mode: \"pretty\", suite: \"run-pass\" },\n-    Test { path: \"src/test/run-fail/pretty\", mode: \"pretty\", suite: \"run-fail\" },\n-    Test { path: \"src/test/run-pass-valgrind/pretty\", mode: \"pretty\", suite: \"run-pass-valgrind\" },\n-    Test { path: \"src/test/run-pass-fulldeps/pretty\", mode: \"pretty\", suite: \"run-pass-fulldeps\" },\n-    Test { path: \"src/test/run-fail-fulldeps/pretty\", mode: \"pretty\", suite: \"run-fail-fulldeps\" },\n-];\n-\n-#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n-pub struct HostCompiletest {\n-    compiler: Compiler,\n-    target: Interned<String>,\n-    mode: &'static str,\n-    suite: &'static str,\n-}\n-\n-impl Step for HostCompiletest {\n-    type Output = ();\n-    const DEFAULT: bool = true;\n-    const ONLY_HOSTS: bool = true;\n-\n-    fn should_run(mut run: ShouldRun) -> ShouldRun {\n-        for test in HOST_COMPILETESTS {\n-            run = run.path(test.path);\n-        }\n-        run\n+        run.all_krates(\"rustc-main\")\n     }\n \n     fn make_run(run: RunConfig) {\n-        let compiler = run.builder.compiler(run.builder.top_stage, run.host);\n-\n-        let test = run.path.map(|path| {\n-            HOST_COMPILETESTS.iter().find(|&&test| {\n-                path.ends_with(test.path)\n-            }).unwrap_or_else(|| {\n-                panic!(\"make_run in compile test to receive test path, received {:?}\", path);\n-            })\n+        run.builder.ensure(Rustc {\n+            target: run.target,\n         });\n-\n-        if let Some(test) = test {\n-            run.builder.ensure(HostCompiletest {\n-                compiler,\n-                target: run.target,\n-                mode: test.mode,\n-                suite: test.suite,\n-            });\n-        } else {\n-            for test in HOST_COMPILETESTS {\n-                if test.mode == \"pretty\" {\n-                    continue;\n-                }\n-                run.builder.ensure(HostCompiletest {\n-                    compiler,\n-                    target: run.target,\n-                    mode: test.mode,\n-                    suite: test.suite\n-                });\n-            }\n-        }\n-    }\n-\n-    fn run(self, builder: &Builder) {\n-        builder.ensure(Compiletest {\n-            compiler: self.compiler,\n-            target: self.target,\n-            mode: self.mode,\n-            suite: self.suite,\n-        })\n-    }\n-}\n-\n-#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n-struct Compiletest {\n-    compiler: Compiler,\n-    target: Interned<String>,\n-    mode: &'static str,\n-    suite: &'static str,\n-}\n-\n-impl Step for Compiletest {\n-    type Output = ();\n-\n-    fn should_run(run: ShouldRun) -> ShouldRun {\n-        run.never()\n     }\n \n-    /// Executes the `compiletest` tool to run a suite of tests.\n+    /// Build the compiler.\n     ///\n-    /// Compiles all tests with `compiler` for `target` with the specified\n-    /// compiletest `mode` and `suite` arguments. For example `mode` can be\n-    /// \"run-pass\" or `suite` can be something like `debuginfo`.\n+    /// This will build the compiler for a particular stage of the build using\n+    /// the `compiler` targeting the `target` architecture. The artifacts\n+    /// created will also be linked into the sysroot directory.\n     fn run(self, builder: &Builder) {\n-        let build = builder.build;\n-        let compiler = self.compiler;\n+        let compiler = builder.compiler(0, builder.config.build);\n         let target = self.target;\n-        let mode = self.mode;\n-        let suite = self.suite;\n-\n-        // Skip codegen tests if they aren't enabled in configuration.\n-        if !build.config.codegen_tests && suite == \"codegen\" {\n-            return;\n-        }\n-\n-        if suite == \"debuginfo\" {\n-            // Skip debuginfo tests on MSVC\n-            if build.build.contains(\"msvc\") {\n-                return;\n-            }\n-\n-            if mode == \"debuginfo-XXX\" {\n-                return if build.build.contains(\"apple\") {\n-                    builder.ensure(Compiletest {\n-                        mode: \"debuginfo-lldb\",\n-                        ..self\n-                    });\n-                } else {\n-                    builder.ensure(Compiletest {\n-                        mode: \"debuginfo-gdb\",\n-                        ..self\n-                    });\n-                };\n-            }\n-\n-            builder.ensure(dist::DebuggerScripts {\n-                sysroot: builder.sysroot(compiler),\n-                host: target\n-            });\n-        }\n-\n-        if suite.ends_with(\"fulldeps\") ||\n-            // FIXME: Does pretty need librustc compiled? Note that there are\n-            // fulldeps test suites with mode = pretty as well.\n-            mode == \"pretty\" ||\n-            mode == \"rustdoc\" ||\n-            mode == \"run-make\" {\n-            builder.ensure(compile::Rustc { compiler, target });\n-        }\n-\n-        builder.ensure(compile::Test { compiler, target });\n-        builder.ensure(native::TestHelpers { target });\n-        builder.ensure(RemoteCopyLibs { compiler, target });\n-\n-        let _folder = build.fold_output(|| format!(\"test_{}\", suite));\n-        println!(\"Check compiletest suite={} mode={} ({} -> {})\",\n-                 suite, mode, &compiler.host, target);\n-        let mut cmd = builder.tool_cmd(Tool::Compiletest);\n-\n-        // compiletest currently has... a lot of arguments, so let's just pass all\n-        // of them!\n-\n-        cmd.arg(\"--compile-lib-path\").arg(builder.rustc_libdir(compiler));\n-        cmd.arg(\"--run-lib-path\").arg(builder.sysroot_libdir(compiler, target));\n-        cmd.arg(\"--rustc-path\").arg(builder.rustc(compiler));\n-\n-        // Avoid depending on rustdoc when we don't need it.\n-        if mode == \"rustdoc\" || mode == \"run-make\" {\n-            cmd.arg(\"--rustdoc-path\").arg(builder.rustdoc(compiler.host));\n-        }\n-\n-        cmd.arg(\"--src-base\").arg(build.src.join(\"src/test\").join(suite));\n-        cmd.arg(\"--build-base\").arg(testdir(build, compiler.host).join(suite));\n-        cmd.arg(\"--stage-id\").arg(format!(\"stage{}-{}\", compiler.stage, target));\n-        cmd.arg(\"--mode\").arg(mode);\n-        cmd.arg(\"--target\").arg(target);\n-        cmd.arg(\"--host\").arg(&*compiler.host);\n-        cmd.arg(\"--llvm-filecheck\").arg(build.llvm_filecheck(build.build));\n-\n-        if let Some(ref nodejs) = build.config.nodejs {\n-            cmd.arg(\"--nodejs\").arg(nodejs);\n-        }\n-\n-        let mut flags = vec![\"-Crpath\".to_string()];\n-        if build.config.rust_optimize_tests {\n-            flags.push(\"-O\".to_string());\n-        }\n-        if build.config.rust_debuginfo_tests {\n-            flags.push(\"-g\".to_string());\n-        }\n-        flags.push(\"-Zmiri -Zunstable-options\".to_string());\n-\n-        if let Some(linker) = build.linker(target) {\n-            cmd.arg(\"--linker\").arg(linker);\n-        }\n-\n-        let hostflags = flags.clone();\n-        cmd.arg(\"--host-rustcflags\").arg(hostflags.join(\" \"));\n-\n-        let mut targetflags = flags.clone();\n-        targetflags.push(format!(\"-Lnative={}\",\n-                                 build.test_helpers_out(target).display()));\n-        cmd.arg(\"--target-rustcflags\").arg(targetflags.join(\" \"));\n-\n-        cmd.arg(\"--docck-python\").arg(build.python());\n-\n-        if build.build.ends_with(\"apple-darwin\") {\n-            // Force /usr/bin/python on macOS for LLDB tests because we're loading the\n-            // LLDB plugin's compiled module which only works with the system python\n-            // (namely not Homebrew-installed python)\n-            cmd.arg(\"--lldb-python\").arg(\"/usr/bin/python\");\n-        } else {\n-            cmd.arg(\"--lldb-python\").arg(build.python());\n-        }\n-\n-        if let Some(ref gdb) = build.config.gdb {\n-            cmd.arg(\"--gdb\").arg(gdb);\n-        }\n-        if let Some(ref vers) = build.lldb_version {\n-            cmd.arg(\"--lldb-version\").arg(vers);\n-        }\n-        if let Some(ref dir) = build.lldb_python_dir {\n-            cmd.arg(\"--lldb-python-dir\").arg(dir);\n-        }\n-\n-        cmd.args(&build.config.cmd.test_args());\n-\n-        if build.is_verbose() {\n-            cmd.arg(\"--verbose\");\n-        }\n \n-        if build.config.quiet_tests {\n-            cmd.arg(\"--quiet\");\n-        }\n+        let stage_out = builder.stage_out(compiler, Mode::Rustc);\n+        builder.clear_if_dirty(&stage_out, &libstd_stamp(builder, compiler, target));\n+        builder.clear_if_dirty(&stage_out, &libtest_stamp(builder, compiler, target));\n \n-        if build.config.llvm_enabled {\n-            let llvm_config = build.llvm_config(target);\n-            let llvm_version = output(Command::new(&llvm_config).arg(\"--version\"));\n-            cmd.arg(\"--llvm-version\").arg(llvm_version);\n-            if !build.is_rust_llvm(target) {\n-                cmd.arg(\"--system-llvm\");\n-            }\n+        let mut cargo = builder.cargo(compiler, Mode::Rustc, target, \"check\");\n+        rustc_cargo(builder, &mut cargo);\n \n-            // Only pass correct values for these flags for the `run-make` suite as it\n-            // requires that a C++ compiler was configured which isn't always the case.\n-            if suite == \"run-make\" {\n-                let llvm_components = output(Command::new(&llvm_config).arg(\"--components\"));\n-                let llvm_cxxflags = output(Command::new(&llvm_config).arg(\"--cxxflags\"));\n-                cmd.arg(\"--cc\").arg(build.cc(target))\n-                .arg(\"--cxx\").arg(build.cxx(target).unwrap())\n-                .arg(\"--cflags\").arg(build.cflags(target).join(\" \"))\n-                .arg(\"--llvm-components\").arg(llvm_components.trim())\n-                .arg(\"--llvm-cxxflags\").arg(llvm_cxxflags.trim());\n-                if let Some(ar) = build.ar(target) {\n-                    cmd.arg(\"--ar\").arg(ar);\n-                }\n-            }\n-        }\n-        if suite == \"run-make\" && !build.config.llvm_enabled {\n-            println!(\"Ignoring run-make test suite as they generally dont work without LLVM\");\n-            return;\n-        }\n+        let _folder = builder.fold_output(|| format!(\"stage{}-rustc\", compiler.stage));\n+        println!(\"Checking compiler artifacts ({} -> {})\", &compiler.host, target);\n+        run_cargo(builder,\n+                  &mut cargo,\n+                  &librustc_stamp(builder, compiler, target),\n+                  true);\n \n-        if suite != \"run-make\" {\n-            cmd.arg(\"--cc\").arg(\"\")\n-               .arg(\"--cxx\").arg(\"\")\n-               .arg(\"--cflags\").arg(\"\")\n-               .arg(\"--llvm-components\").arg(\"\")\n-               .arg(\"--llvm-cxxflags\").arg(\"\");\n-        }\n-\n-        if build.remote_tested(target) {\n-            cmd.arg(\"--remote-test-client\").arg(builder.tool_exe(Tool::RemoteTestClient));\n-        }\n-\n-        // Running a C compiler on MSVC requires a few env vars to be set, to be\n-        // sure to set them here.\n-        //\n-        // Note that if we encounter `PATH` we make sure to append to our own `PATH`\n-        // rather than stomp over it.\n-        if target.contains(\"msvc\") {\n-            for &(ref k, ref v) in build.cc[&target].env() {\n-                if k != \"PATH\" {\n-                    cmd.env(k, v);\n-                }\n-            }\n-        }\n-        cmd.env(\"RUSTC_BOOTSTRAP\", \"1\");\n-        build.add_rust_test_threads(&mut cmd);\n-\n-        if build.config.sanitizers {\n-            cmd.env(\"SANITIZER_SUPPORT\", \"1\");\n-        }\n-\n-        if build.config.profiler {\n-            cmd.env(\"PROFILER_SUPPORT\", \"1\");\n-        }\n-\n-        cmd.arg(\"--adb-path\").arg(\"adb\");\n-        cmd.arg(\"--adb-test-dir\").arg(ADB_TEST_DIR);\n-        if target.contains(\"android\") {\n-            // Assume that cc for this target comes from the android sysroot\n-            cmd.arg(\"--android-cross-path\")\n-               .arg(build.cc(target).parent().unwrap().parent().unwrap());\n-        } else {\n-            cmd.arg(\"--android-cross-path\").arg(\"\");\n-        }\n-\n-        build.ci_env.force_coloring_in_ci(&mut cmd);\n-\n-        let _time = util::timeit();\n-        try_run(build, &mut cmd);\n+        let libdir = builder.sysroot_libdir(compiler, target);\n+        add_to_sysroot(&builder, &libdir, &librustc_stamp(builder, compiler, target));\n     }\n }\n \n #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n-pub struct Docs {\n-    compiler: Compiler,\n+pub struct CodegenBackend {\n+    pub target: Interned<String>,\n+    pub backend: Interned<String>,\n }\n \n-impl Step for Docs {\n+impl Step for CodegenBackend {\n     type Output = ();\n-    const DEFAULT: bool = true;\n     const ONLY_HOSTS: bool = true;\n-\n-    fn should_run(run: ShouldRun) -> ShouldRun {\n-        run.path(\"src/doc\")\n-    }\n-\n-    fn make_run(run: RunConfig) {\n-        run.builder.ensure(Docs {\n-            compiler: run.builder.compiler(run.builder.top_stage, run.host),\n-        });\n-    }\n-\n-    /// Run `rustdoc --test` for all documentation in `src/doc`.\n-    ///\n-    /// This will run all tests in our markdown documentation (e.g. the book)\n-    /// located in `src/doc`. The `rustdoc` that's run is the one that sits next to\n-    /// `compiler`.\n-    fn run(self, builder: &Builder) {\n-        let build = builder.build;\n-        let compiler = self.compiler;\n-\n-        builder.ensure(compile::Test { compiler, target: compiler.host });\n-\n-        // Do a breadth-first traversal of the `src/doc` directory and just run\n-        // tests for all files that end in `*.md`\n-        let mut stack = vec![build.src.join(\"src/doc\")];\n-        let _time = util::timeit();\n-        let _folder = build.fold_output(|| \"test_docs\");\n-\n-        while let Some(p) = stack.pop() {\n-            if p.is_dir() {\n-                stack.extend(t!(p.read_dir()).map(|p| t!(p).path()));\n-                continue\n-            }\n-\n-            if p.extension().and_then(|s| s.to_str()) != Some(\"md\") {\n-                continue;\n-            }\n-\n-            // The nostarch directory in the book is for no starch, and so isn't\n-            // guaranteed to build. We don't care if it doesn't build, so skip it.\n-            if p.to_str().map_or(false, |p| p.contains(\"nostarch\")) {\n-                continue;\n-            }\n-\n-            markdown_test(builder, compiler, &p);\n-        }\n-    }\n-}\n-\n-#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n-pub struct ErrorIndex {\n-    compiler: Compiler,\n-}\n-\n-impl Step for ErrorIndex {\n-    type Output = ();\n     const DEFAULT: bool = true;\n-    const ONLY_HOSTS: bool = true;\n \n     fn should_run(run: ShouldRun) -> ShouldRun {\n-        run.path(\"src/tools/error_index_generator\")\n+        run.all_krates(\"rustc_codegen_llvm\")\n     }\n \n     fn make_run(run: RunConfig) {\n-        run.builder.ensure(ErrorIndex {\n-            compiler: run.builder.compiler(run.builder.top_stage, run.host),\n+        let backend = run.builder.config.rust_codegen_backends.get(0);\n+        let backend = backend.cloned().unwrap_or_else(|| {\n+            INTERNER.intern_str(\"llvm\")\n+        });\n+        run.builder.ensure(CodegenBackend {\n+            target: run.target,\n+            backend,\n         });\n     }\n \n-    /// Run the error index generator tool to execute the tests located in the error\n-    /// index.\n-    ///\n-    /// The `error_index_generator` tool lives in `src/tools` and is used to\n-    /// generate a markdown file from the error indexes of the code base which is\n-    /// then passed to `rustdoc --test`.\n     fn run(self, builder: &Builder) {\n-        let build = builder.build;\n-        let compiler = self.compiler;\n-\n-        builder.ensure(compile::Std { compiler, target: compiler.host });\n-\n-        let _folder = build.fold_output(|| \"test_error_index\");\n-        println!(\"Testing error-index stage{}\", compiler.stage);\n-\n-        let dir = testdir(build, compiler.host);\n-        t!(fs::create_dir_all(&dir));\n-        let output = dir.join(\"error-index.md\");\n-\n-        let _time = util::timeit();\n-        build.run(builder.tool_cmd(Tool::ErrorIndex)\n-                    .arg(\"markdown\")\n-                    .arg(&output)\n-                    .env(\"CFG_BUILD\", &build.build)\n-                    .env(\"RUSTC_ERROR_METADATA_DST\", build.extended_error_dir()));\n-\n-        markdown_test(builder, compiler, &output);\n-    }\n-}\n+        let compiler = builder.compiler(0, builder.config.build);\n+        let target = self.target;\n+        let backend = self.backend;\n \n-fn markdown_test(builder: &Builder, compiler: Compiler, markdown: &Path) {\n-    let build = builder.build;\n-    let mut file = t!(File::open(markdown));\n-    let mut contents = String::new();\n-    t!(file.read_to_string(&mut contents));\n-    if !contents.contains(\"```\") {\n-        return;\n-    }\n+        let out_dir = builder.cargo_out(compiler, Mode::Codegen, target);\n+        builder.clear_if_dirty(&out_dir, &librustc_stamp(builder, compiler, target));\n \n-    println!(\"doc tests for: {}\", markdown.display());\n-    let mut cmd = builder.rustdoc_cmd(compiler.host);\n-    build.add_rust_test_threads(&mut cmd);\n-    cmd.arg(\"--test\");\n-    cmd.arg(markdown);\n-    cmd.env(\"RUSTC_BOOTSTRAP\", \"1\");\n+        let mut cargo = builder.cargo(compiler, Mode::Codegen, target, \"check\");\n+        cargo.arg(\"--manifest-path\").arg(builder.src.join(\"src/librustc_codegen_llvm/Cargo.toml\"));\n+        rustc_cargo_env(builder, &mut cargo);\n \n-    let test_args = build.config.cmd.test_args().join(\" \");\n-    cmd.arg(\"--test-args\").arg(test_args);\n+        // We won't build LLVM if it's not available, as it shouldn't affect `check`.\n \n-    if build.config.quiet_tests {\n-        try_run_quiet(build, &mut cmd);\n-    } else {\n-        try_run(build, &mut cmd);\n+        let _folder = builder.fold_output(|| format!(\"stage{}-rustc_codegen_llvm\", compiler.stage));\n+        run_cargo(builder,\n+                  &mut cargo,\n+                  &codegen_backend_stamp(builder, compiler, target, backend),\n+                  true);\n     }\n }\n \n #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n-pub struct CrateLibrustc {\n-    compiler: Compiler,\n-    target: Interned<String>,\n-    test_kind: TestKind,\n-    krate: Option<Interned<String>>,\n+pub struct Test {\n+    pub target: Interned<String>,\n }\n \n-impl Step for CrateLibrustc {\n+impl Step for Test {\n     type Output = ();\n     const DEFAULT: bool = true;\n-    const ONLY_HOSTS: bool = true;\n \n     fn should_run(run: ShouldRun) -> ShouldRun {\n-        run.krate(\"rustc-main\")\n+        run.all_krates(\"test\")\n     }\n \n     fn make_run(run: RunConfig) {\n-        let builder = run.builder;\n-        let compiler = builder.compiler(builder.top_stage, run.host);\n-\n-        let make = |name: Option<Interned<String>>| {\n-            let test_kind = if builder.kind == Kind::Test {\n-                TestKind::Test\n-            } else if builder.kind == Kind::Bench {\n-                TestKind::Bench\n-            } else {\n-                panic!(\"unexpected builder.kind in crate: {:?}\", builder.kind);\n-            };\n-\n-            builder.ensure(CrateLibrustc {\n-                compiler,\n-                target: run.target,\n-                test_kind,\n-                krate: name,\n-            });\n-        };\n-\n-        if let Some(path) = run.path {\n-            for (name, krate_path) in builder.crates(\"rustc-main\") {\n-                if path.ends_with(krate_path) {\n-                    make(Some(name));\n-                }\n-            }\n-        } else {\n-            make(None);\n-        }\n-    }\n-\n-\n-    fn run(self, builder: &Builder) {\n-        builder.ensure(Crate {\n-            compiler: self.compiler,\n-            target: self.target,\n-            mode: Mode::Librustc,\n-            test_kind: self.test_kind,\n-            krate: self.krate,\n+        run.builder.ensure(Test {\n+            target: run.target,\n         });\n     }\n-}\n-\n-#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n-pub struct Crate {\n-    compiler: Compiler,\n-    target: Interned<String>,\n-    mode: Mode,\n-    test_kind: TestKind,\n-    krate: Option<Interned<String>>,\n-}\n \n-impl Step for Crate {\n-    type Output = ();\n-    const DEFAULT: bool = true;\n-\n-    fn should_run(run: ShouldRun) -> ShouldRun {\n-        run.krate(\"std\").krate(\"test\")\n-    }\n-\n-    fn make_run(run: RunConfig) {\n-        let builder = run.builder;\n-        let compiler = builder.compiler(builder.top_stage, run.host);\n-\n-        let make = |mode: Mode, name: Option<Interned<String>>| {\n-            let test_kind = if builder.kind == Kind::Test {\n-                TestKind::Test\n-            } else if builder.kind == Kind::Bench {\n-                TestKind::Bench\n-            } else {\n-                panic!(\"unexpected builder.kind in crate: {:?}\", builder.kind);\n-            };\n-\n-            builder.ensure(Crate {\n-                compiler,\n-                target: run.target,\n-                mode,\n-                test_kind,\n-                krate: name,\n-            });\n-        };\n-\n-        if let Some(path) = run.path {\n-            for (name, krate_path) in builder.crates(\"std\") {\n-                if path.ends_with(krate_path) {\n-                    make(Mode::Libstd, Some(name));\n-                }\n-            }\n-            for (name, krate_path) in builder.crates(\"test\") {\n-                if path.ends_with(krate_path) {\n-                    make(Mode::Libtest, Some(name));\n-                }\n-            }\n-        } else {\n-            make(Mode::Libstd, None);\n-            make(Mode::Libtest, None);\n-        }\n-    }\n-\n-    /// Run all unit tests plus documentation tests for an entire crate DAG defined\n-    /// by a `Cargo.toml`\n-    ///\n-    /// This is what runs tests for crates like the standard library, compiler, etc.\n-    /// It essentially is the driver for running `cargo test`.\n-    ///\n-    /// Currently this runs all tests for a DAG by passing a bunch of `-p foo`\n-    /// arguments, and those arguments are discovered from `cargo metadata`.\n     fn run(self, builder: &Builder) {\n-        let build = builder.build;\n-        let compiler = self.compiler;\n+        let compiler = builder.compiler(0, builder.config.build);\n         let target = self.target;\n-        let mode = self.mode;\n-        let test_kind = self.test_kind;\n-        let krate = self.krate;\n-\n-        builder.ensure(compile::Test { compiler, target });\n-        builder.ensure(RemoteCopyLibs { compiler, target });\n-\n-        // If we're not doing a full bootstrap but we're testing a stage2 version of\n-        // libstd, then what we're actually testing is the libstd produced in\n-        // stage1. Reflect that here by updating the compiler that we're working\n-        // with automatically.\n-        let compiler = if build.force_use_stage1(compiler, target) {\n-            builder.compiler(1, compiler.host)\n-        } else {\n-            compiler.clone()\n-        };\n-\n-        let mut cargo = builder.cargo(compiler, mode, target, test_kind.subcommand());\n-        let (name, root) = match mode {\n-            Mode::Libstd => {\n-                compile::std_cargo(build, &compiler, target, &mut cargo);\n-                (\"libstd\", \"std\")\n-            }\n-            Mode::Libtest => {\n-                compile::test_cargo(build, &compiler, target, &mut cargo);\n-                (\"libtest\", \"test\")\n-            }\n-            Mode::Librustc => {\n-                builder.ensure(compile::Rustc { compiler, target });\n-                compile::rustc_cargo(build, target, &mut cargo);\n-                (\"librustc\", \"rustc-main\")\n-            }\n-            _ => panic!(\"can only test libraries\"),\n-        };\n-        let root = INTERNER.intern_string(String::from(root));\n-        let _folder = build.fold_output(|| {\n-            format!(\"{}_stage{}-{}\", test_kind.subcommand(), compiler.stage, name)\n-        });\n-        println!(\"{} {} stage{} ({} -> {})\", test_kind, name, compiler.stage,\n-                &compiler.host, target);\n-\n-        // Build up the base `cargo test` command.\n-        //\n-        // Pass in some standard flags then iterate over the graph we've discovered\n-        // in `cargo metadata` with the maps above and figure out what `-p`\n-        // arguments need to get passed.\n-        if test_kind.subcommand() == \"test\" && !build.fail_fast {\n-            cargo.arg(\"--no-fail-fast\");\n-        }\n \n-        match krate {\n-            Some(krate) => {\n-                cargo.arg(\"-p\").arg(krate);\n-            }\n-            None => {\n-                let mut visited = HashSet::new();\n-                let mut next = vec![root];\n-                while let Some(name) = next.pop() {\n-                    // Right now jemalloc and the sanitizer crates are\n-                    // target-specific crate in the sense that it's not present\n-                    // on all platforms. Custom skip it here for now, but if we\n-                    // add more this probably wants to get more generalized.\n-                    //\n-                    // Also skip `build_helper` as it's not compiled normally\n-                    // for target during the bootstrap and it's just meant to be\n-                    // a helper crate, not tested. If it leaks through then it\n-                    // ends up messing with various mtime calculations and such.\n-                    if !name.contains(\"jemalloc\") &&\n-                       *name != *\"build_helper\" &&\n-                       !(name.starts_with(\"rustc_\") && name.ends_with(\"san\")) &&\n-                       name != \"dlmalloc\" {\n-                        cargo.arg(\"-p\").arg(&format!(\"{}:0.0.0\", name));\n-                    }\n-                    for dep in build.crates[&name].deps.iter() {\n-                        if visited.insert(dep) {\n-                            next.push(*dep);\n-                        }\n-                    }\n-                }\n-            }\n-        }\n+        let out_dir = builder.stage_out(compiler, Mode::Test);\n+        builder.clear_if_dirty(&out_dir, &libstd_stamp(builder, compiler, target));\n \n-        // The tests are going to run with the *target* libraries, so we need to\n-        // ensure that those libraries show up in the LD_LIBRARY_PATH equivalent.\n-        //\n-        // Note that to run the compiler we need to run with the *host* libraries,\n-        // but our wrapper scripts arrange for that to be the case anyway.\n-        let mut dylib_path = dylib_path();\n-        dylib_path.insert(0, PathBuf::from(&*builder.sysroot_libdir(compiler, target)));\n-        cargo.env(dylib_path_var(), env::join_paths(&dylib_path).unwrap());\n+        let mut cargo = builder.cargo(compiler, Mode::Test, target, \"check\");\n+        test_cargo(builder, &compiler, target, &mut cargo);\n \n-        cargo.arg(\"--\");\n-        cargo.args(&build.config.cmd.test_args());\n+        let _folder = builder.fold_output(|| format!(\"stage{}-test\", compiler.stage));\n+        println!(\"Checking test artifacts ({} -> {})\", &compiler.host, target);\n+        run_cargo(builder,\n+                  &mut cargo,\n+                  &libtest_stamp(builder, compiler, target),\n+                  true);\n \n-        if build.config.quiet_tests {\n-            cargo.arg(\"--quiet\");\n-        }\n-\n-        let _time = util::timeit();\n-\n-        if target.contains(\"emscripten\") {\n-            cargo.env(format!(\"CARGO_TARGET_{}_RUNNER\", envify(&target)),\n-                      build.config.nodejs.as_ref().expect(\"nodejs not configured\"));\n-        } else if target.starts_with(\"wasm32\") {\n-            // On the wasm32-unknown-unknown target we're using LTO which is\n-            // incompatible with `-C prefer-dynamic`, so disable that here\n-            cargo.env(\"RUSTC_NO_PREFER_DYNAMIC\", \"1\");\n-\n-            let node = build.config.nodejs.as_ref()\n-                .expect(\"nodejs not configured\");\n-            let runner = format!(\"{} {}/src/etc/wasm32-shim.js\",\n-                                 node.display(),\n-                                 build.src.display());\n-            cargo.env(format!(\"CARGO_TARGET_{}_RUNNER\", envify(&target)), &runner);\n-        } else if build.remote_tested(target) {\n-            cargo.env(format!(\"CARGO_TARGET_{}_RUNNER\", envify(&target)),\n-                      format!(\"{} run\",\n-                              builder.tool_exe(Tool::RemoteTestClient).display()));\n-        }\n-        try_run(build, &mut cargo);\n+        let libdir = builder.sysroot_libdir(compiler, target);\n+        add_to_sysroot(builder, &libdir, &libtest_stamp(builder, compiler, target));\n     }\n }\n \n #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n pub struct Rustdoc {\n-    host: Interned<String>,\n-    test_kind: TestKind,\n+    pub target: Interned<String>,\n }\n \n impl Step for Rustdoc {\n     type Output = ();\n-    const DEFAULT: bool = true;\n     const ONLY_HOSTS: bool = true;\n+    const DEFAULT: bool = true;\n \n     fn should_run(run: ShouldRun) -> ShouldRun {\n-        run.path(\"src/librustdoc\").path(\"src/tools/rustdoc\")\n+        run.path(\"src/tools/rustdoc\")\n     }\n \n     fn make_run(run: RunConfig) {\n-        let builder = run.builder;\n-\n-        let test_kind = if builder.kind == Kind::Test {\n-            TestKind::Test\n-        } else if builder.kind == Kind::Bench {\n-            TestKind::Bench\n-        } else {\n-            panic!(\"unexpected builder.kind in crate: {:?}\", builder.kind);\n-        };\n-\n-        builder.ensure(Rustdoc {\n-            host: run.host,\n-            test_kind,\n+        run.builder.ensure(Rustdoc {\n+            target: run.target,\n         });\n     }\n \n     fn run(self, builder: &Builder) {\n-        let build = builder.build;\n-        let test_kind = self.test_kind;\n-\n-        let compiler = builder.compiler(builder.top_stage, self.host);\n-        let target = compiler.host;\n+        let compiler = builder.compiler(0, builder.config.build);\n+        let target = self.target;\n \n-        let mut cargo = tool::prepare_tool_cargo(builder,\n-                                                 compiler,\n-                                                 target,\n-                                                 test_kind.subcommand(),\n-                                                 \"src/tools/rustdoc\");\n-        let _folder = build.fold_output(|| {\n-            format!(\"{}_stage{}-rustdoc\", test_kind.subcommand(), compiler.stage)\n+        let stage_out = builder.stage_out(compiler, Mode::ToolRustc);\n+        builder.clear_if_dirty(&stage_out, &libstd_stamp(builder, compiler, target));\n+        builder.clear_if_dirty(&stage_out, &libtest_stamp(builder, compiler, target));\n+        builder.clear_if_dirty(&stage_out, &librustc_stamp(builder, compiler, target));\n+\n+        let mut cargo = prepare_tool_cargo(builder,\n+                                           compiler,\n+                                           Mode::ToolRustc,\n+                                           target,\n+                                           \"check\",\n+                                           \"src/tools/rustdoc\",\n+                                           SourceType::InTree);\n+\n+        let _folder = builder.fold_output(|| format!(\"stage{}-rustdoc\", compiler.stage));\n+        println!(\"Checking rustdoc artifacts ({} -> {})\", &compiler.host, target);\n+        run_cargo(builder,\n+                  &mut cargo,\n+                  &rustdoc_stamp(builder, compiler, target),\n+                  true);\n+\n+        let libdir = builder.sysroot_libdir(compiler, target);\n+        add_to_sysroot(&builder, &libdir, &rustdoc_stamp(builder, compiler, target));\n+\n+        builder.ensure(tool::CleanTools {\n+            compiler,\n+            target,\n+            cause: Mode::Rustc,\n         });\n-        println!(\"{} rustdoc stage{} ({} -> {})\", test_kind, compiler.stage,\n-                &compiler.host, target);\n-\n-        if test_kind.subcommand() == \"test\" && !build.fail_fast {\n-            cargo.arg(\"--no-fail-fast\");\n-        }\n-\n-        cargo.arg(\"-p\").arg(\"rustdoc:0.0.0\");\n-\n-        cargo.arg(\"--\");\n-        cargo.args(&build.config.cmd.test_args());\n-\n-        if build.config.quiet_tests {\n-            cargo.arg(\"--quiet\");\n-        }\n-\n-        let _time = util::timeit();\n-\n-        try_run(build, &mut cargo);\n     }\n }\n \n-fn envify(s: &str) -> String {\n-    s.chars().map(|c| {\n-        match c {\n-            '-' => '_',\n-            c => c,\n-        }\n-    }).flat_map(|c| c.to_uppercase()).collect()\n+/// Cargo's output path for the standard library in a given stage, compiled\n+/// by a particular compiler for the specified target.\n+pub fn libstd_stamp(builder: &Builder, compiler: Compiler, target: Interned<String>) -> PathBuf {\n+    builder.cargo_out(compiler, Mode::Std, target).join(\".libstd-check.stamp\")\n }\n \n-/// Some test suites are run inside emulators or on remote devices, and most\n-/// of our test binaries are linked dynamically which means we need to ship\n-/// the standard library and such to the emulator ahead of time. This step\n-/// represents this and is a dependency of all test suites.\n-///\n-/// Most of the time this is a noop. For some steps such as shipping data to\n-/// QEMU we have to build our own tools so we've got conditional dependencies\n-/// on those programs as well. Note that the remote test client is built for\n-/// the build target (us) and the server is built for the target.\n-#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n-pub struct RemoteCopyLibs {\n-    compiler: Compiler,\n-    target: Interned<String>,\n+/// Cargo's output path for libtest in a given stage, compiled by a particular\n+/// compiler for the specified target.\n+pub fn libtest_stamp(builder: &Builder, compiler: Compiler, target: Interned<String>) -> PathBuf {\n+    builder.cargo_out(compiler, Mode::Test, target).join(\".libtest-check.stamp\")\n }\n \n-impl Step for RemoteCopyLibs {\n-    type Output = ();\n-\n-    fn should_run(run: ShouldRun) -> ShouldRun {\n-        run.never()\n-    }\n-\n-    fn run(self, builder: &Builder) {\n-        let build = builder.build;\n-        let compiler = self.compiler;\n-        let target = self.target;\n-        if !build.remote_tested(target) {\n-            return\n-        }\n-\n-        builder.ensure(compile::Test { compiler, target });\n-\n-        println!(\"REMOTE copy libs to emulator ({})\", target);\n-        t!(fs::create_dir_all(build.out.join(\"tmp\")));\n-\n-        let server = builder.ensure(tool::RemoteTestServer { compiler, target });\n-\n-        // Spawn the emulator and wait for it to come online\n-        let tool = builder.tool_exe(Tool::RemoteTestClient);\n-        let mut cmd = Command::new(&tool);\n-        cmd.arg(\"spawn-emulator\")\n-           .arg(target)\n-           .arg(&server)\n-           .arg(build.out.join(\"tmp\"));\n-        if let Some(rootfs) = build.qemu_rootfs(target) {\n-            cmd.arg(rootfs);\n-        }\n-        build.run(&mut cmd);\n-\n-        // Push all our dylibs to the emulator\n-        for f in t!(builder.sysroot_libdir(compiler, target).read_dir()) {\n-            let f = t!(f);\n-            let name = f.file_name().into_string().unwrap();\n-            if util::is_dylib(&name) {\n-                build.run(Command::new(&tool)\n-                                  .arg(\"push\")\n-                                  .arg(f.path()));\n-            }\n-        }\n-    }\n+/// Cargo's output path for librustc in a given stage, compiled by a particular\n+/// compiler for the specified target.\n+pub fn librustc_stamp(builder: &Builder, compiler: Compiler, target: Interned<String>) -> PathBuf {\n+    builder.cargo_out(compiler, Mode::Rustc, target).join(\".librustc-check.stamp\")\n }\n \n-#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n-pub struct Distcheck;\n-\n-impl Step for Distcheck {\n-    type Output = ();\n-    const ONLY_BUILD: bool = true;\n-\n-    fn should_run(run: ShouldRun) -> ShouldRun {\n-        run.path(\"distcheck\")\n-    }\n-\n-    fn make_run(run: RunConfig) {\n-        run.builder.ensure(Distcheck);\n-    }\n-\n-    /// Run \"distcheck\", a 'make check' from a tarball\n-    fn run(self, builder: &Builder) {\n-        let build = builder.build;\n-\n-        println!(\"Distcheck\");\n-        let dir = build.out.join(\"tmp\").join(\"distcheck\");\n-        let _ = fs::remove_dir_all(&dir);\n-        t!(fs::create_dir_all(&dir));\n-\n-        // Guarantee that these are built before we begin running.\n-        builder.ensure(dist::PlainSourceTarball);\n-        builder.ensure(dist::Src);\n-\n-        let mut cmd = Command::new(\"tar\");\n-        cmd.arg(\"-xzf\")\n-           .arg(builder.ensure(dist::PlainSourceTarball))\n-           .arg(\"--strip-components=1\")\n-           .current_dir(&dir);\n-        build.run(&mut cmd);\n-        build.run(Command::new(\"./configure\")\n-                         .args(&build.config.configure_args)\n-                         .arg(\"--enable-vendor\")\n-                         .current_dir(&dir));\n-        build.run(Command::new(build_helper::make(&build.build))\n-                         .arg(\"check\")\n-                         .current_dir(&dir));\n-\n-        // Now make sure that rust-src has all of libstd's dependencies\n-        println!(\"Distcheck rust-src\");\n-        let dir = build.out.join(\"tmp\").join(\"distcheck-src\");\n-        let _ = fs::remove_dir_all(&dir);\n-        t!(fs::create_dir_all(&dir));\n-\n-        let mut cmd = Command::new(\"tar\");\n-        cmd.arg(\"-xzf\")\n-           .arg(builder.ensure(dist::Src))\n-           .arg(\"--strip-components=1\")\n-           .current_dir(&dir);\n-        build.run(&mut cmd);\n-\n-        let toml = dir.join(\"rust-src/lib/rustlib/src/rust/src/libstd/Cargo.toml\");\n-        build.run(Command::new(&build.initial_cargo)\n-                         .arg(\"generate-lockfile\")\n-                         .arg(\"--manifest-path\")\n-                         .arg(&toml)\n-                         .current_dir(&dir));\n-    }\n+/// Cargo's output path for librustc_codegen_llvm in a given stage, compiled by a particular\n+/// compiler for the specified target and backend.\n+fn codegen_backend_stamp(builder: &Builder,\n+                         compiler: Compiler,\n+                         target: Interned<String>,\n+                         backend: Interned<String>) -> PathBuf {\n+    builder.cargo_out(compiler, Mode::Codegen, target)\n+         .join(format!(\".librustc_codegen_llvm-{}-check.stamp\", backend))\n }\n \n-#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n-pub struct Bootstrap;\n-\n-impl Step for Bootstrap {\n-    type Output = ();\n-    const DEFAULT: bool = true;\n-    const ONLY_HOSTS: bool = true;\n-    const ONLY_BUILD: bool = true;\n-\n-    /// Test the build system itself\n-    fn run(self, builder: &Builder) {\n-        let build = builder.build;\n-        let mut cmd = Command::new(&build.initial_cargo);\n-        cmd.arg(\"test\")\n-           .current_dir(build.src.join(\"src/bootstrap\"))\n-           .env(\"CARGO_TARGET_DIR\", build.out.join(\"bootstrap\"))\n-           .env(\"RUSTC_BOOTSTRAP\", \"1\")\n-           .env(\"RUSTC\", &build.initial_rustc);\n-        if !build.fail_fast {\n-            cmd.arg(\"--no-fail-fast\");\n-        }\n-        cmd.arg(\"--\").args(&build.config.cmd.test_args());\n-        try_run(build, &mut cmd);\n-    }\n-\n-    fn should_run(run: ShouldRun) -> ShouldRun {\n-        run.path(\"src/bootstrap\")\n-    }\n-\n-    fn make_run(run: RunConfig) {\n-        run.builder.ensure(Bootstrap);\n-    }\n+/// Cargo's output path for rustdoc in a given stage, compiled by a particular\n+/// compiler for the specified target.\n+pub fn rustdoc_stamp(builder: &Builder, compiler: Compiler, target: Interned<String>) -> PathBuf {\n+    builder.cargo_out(compiler, Mode::ToolRustc, target)\n+        .join(\".rustdoc-check.stamp\")\n }"}, {"sha": "2f8816d111a9d2b4d6f89171d897d8fcca36088b", "filename": "src/bootstrap/compile.rs", "status": "modified", "additions": 570, "deletions": 269, "changes": 839, "blob_url": "https://github.com/rust-lang/rust/blob/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fbootstrap%2Fcompile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fbootstrap%2Fcompile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcompile.rs?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd", "patch": "@@ -16,28 +16,28 @@\n //! compiler. This module is also responsible for assembling the sysroot as it\n //! goes along from the output of the previous stage.\n \n+use std::borrow::Cow;\n use std::env;\n use std::fs::{self, File};\n use std::io::BufReader;\n use std::io::prelude::*;\n use std::path::{Path, PathBuf};\n use std::process::{Command, Stdio};\n use std::str;\n-use std::cmp::min;\n \n use build_helper::{output, mtime, up_to_date};\n use filetime::FileTime;\n use serde_json;\n \n-use util::{exe, libdir, is_dylib, copy, read_stamp_file, CiEnv};\n-use {Build, Compiler, Mode};\n+use util::{exe, libdir, is_dylib, CiEnv};\n+use {Compiler, Mode};\n use native;\n use tool;\n \n use cache::{INTERNER, Interned};\n use builder::{Step, RunConfig, ShouldRun, Builder};\n \n-#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n+#[derive(Debug, PartialOrd, Ord, Copy, Clone, PartialEq, Eq, Hash)]\n pub struct Std {\n     pub target: Interned<String>,\n     pub compiler: Compiler,\n@@ -48,7 +48,7 @@ impl Step for Std {\n     const DEFAULT: bool = true;\n \n     fn should_run(run: ShouldRun) -> ShouldRun {\n-        run.path(\"src/libstd\").krate(\"std\")\n+        run.all_krates(\"std\")\n     }\n \n     fn make_run(run: RunConfig) {\n@@ -64,25 +64,34 @@ impl Step for Std {\n     /// using the `compiler` targeting the `target` architecture. The artifacts\n     /// created will also be linked into the sysroot directory.\n     fn run(self, builder: &Builder) {\n-        let build = builder.build;\n         let target = self.target;\n         let compiler = self.compiler;\n \n+        if builder.config.keep_stage.contains(&compiler.stage) {\n+            builder.info(\"Warning: Using a potentially old libstd. This may not behave well.\");\n+            builder.ensure(StdLink {\n+                compiler: compiler,\n+                target_compiler: compiler,\n+                target,\n+            });\n+            return;\n+        }\n+\n         builder.ensure(StartupObjects { compiler, target });\n \n-        if build.force_use_stage1(compiler, target) {\n-            let from = builder.compiler(1, build.build);\n+        if builder.force_use_stage1(compiler, target) {\n+            let from = builder.compiler(1, builder.config.build);\n             builder.ensure(Std {\n                 compiler: from,\n                 target,\n             });\n-            println!(\"Uplifting stage1 std ({} -> {})\", from.host, target);\n+            builder.info(&format!(\"Uplifting stage1 std ({} -> {})\", from.host, target));\n \n             // Even if we're not building std this stage, the new sysroot must\n             // still contain the musl startup objects.\n-            if target.contains(\"musl\") && !target.contains(\"mips\") {\n+            if target.contains(\"musl\") {\n                 let libdir = builder.sysroot_libdir(compiler, target);\n-                copy_musl_third_party_objects(build, target, &libdir);\n+                copy_musl_third_party_objects(builder, target, &libdir);\n             }\n \n             builder.ensure(StdLink {\n@@ -93,25 +102,26 @@ impl Step for Std {\n             return;\n         }\n \n-        let _folder = build.fold_output(|| format!(\"stage{}-std\", compiler.stage));\n-        println!(\"Building stage{} std artifacts ({} -> {})\", compiler.stage,\n-                &compiler.host, target);\n-\n-        if target.contains(\"musl\") && !target.contains(\"mips\") {\n+        if target.contains(\"musl\") {\n             let libdir = builder.sysroot_libdir(compiler, target);\n-            copy_musl_third_party_objects(build, target, &libdir);\n+            copy_musl_third_party_objects(builder, target, &libdir);\n         }\n \n-        let out_dir = build.stage_out(compiler, Mode::Libstd);\n-        build.clear_if_dirty(&out_dir, &builder.rustc(compiler));\n-        let mut cargo = builder.cargo(compiler, Mode::Libstd, target, \"build\");\n-        std_cargo(build, &compiler, target, &mut cargo);\n-        run_cargo(build,\n+        let out_dir = builder.cargo_out(compiler, Mode::Std, target);\n+        builder.clear_if_dirty(&out_dir, &builder.rustc(compiler));\n+        let mut cargo = builder.cargo(compiler, Mode::Std, target, \"build\");\n+        std_cargo(builder, &compiler, target, &mut cargo);\n+\n+        let _folder = builder.fold_output(|| format!(\"stage{}-std\", compiler.stage));\n+        builder.info(&format!(\"Building stage{} std artifacts ({} -> {})\", compiler.stage,\n+                &compiler.host, target));\n+        run_cargo(builder,\n                   &mut cargo,\n-                  &libstd_stamp(build, compiler, target));\n+                  &libstd_stamp(builder, compiler, target),\n+                  false);\n \n         builder.ensure(StdLink {\n-            compiler: builder.compiler(compiler.stage, build.build),\n+            compiler: builder.compiler(compiler.stage, builder.config.build),\n             target_compiler: compiler,\n             target,\n         });\n@@ -124,58 +134,71 @@ impl Step for Std {\n /// with a glibc-targeting toolchain, given we have the appropriate startup\n /// files. As those shipped with glibc won't work, copy the ones provided by\n /// musl so we have them on linux-gnu hosts.\n-fn copy_musl_third_party_objects(build: &Build,\n+fn copy_musl_third_party_objects(builder: &Builder,\n                                  target: Interned<String>,\n                                  into: &Path) {\n     for &obj in &[\"crt1.o\", \"crti.o\", \"crtn.o\"] {\n-        copy(&build.musl_root(target).unwrap().join(\"lib\").join(obj), &into.join(obj));\n+        builder.copy(&builder.musl_root(target).unwrap().join(\"lib\").join(obj), &into.join(obj));\n     }\n }\n \n /// Configure cargo to compile the standard library, adding appropriate env vars\n /// and such.\n-pub fn std_cargo(build: &Build,\n+pub fn std_cargo(builder: &Builder,\n                  compiler: &Compiler,\n                  target: Interned<String>,\n                  cargo: &mut Command) {\n-    let mut features = build.std_features();\n-\n     if let Some(target) = env::var_os(\"MACOSX_STD_DEPLOYMENT_TARGET\") {\n         cargo.env(\"MACOSX_DEPLOYMENT_TARGET\", target);\n     }\n \n-    // When doing a local rebuild we tell cargo that we're stage1 rather than\n-    // stage0. This works fine if the local rust and being-built rust have the\n-    // same view of what the default allocator is, but fails otherwise. Since\n-    // we don't have a way to express an allocator preference yet, work\n-    // around the issue in the case of a local rebuild with jemalloc disabled.\n-    if compiler.stage == 0 && build.local_rebuild && !build.config.use_jemalloc {\n-        features.push_str(\" force_alloc_system\");\n-    }\n+    if builder.no_std(target) == Some(true) {\n+        // for no-std targets we only compile a few no_std crates\n+        cargo.arg(\"--features\").arg(\"c mem\")\n+            .args(&[\"-p\", \"alloc\"])\n+            .args(&[\"-p\", \"compiler_builtins\"])\n+            .arg(\"--manifest-path\")\n+            .arg(builder.src.join(\"src/rustc/compiler_builtins_shim/Cargo.toml\"));\n+    } else {\n+        let mut features = builder.std_features();\n+\n+        // When doing a local rebuild we tell cargo that we're stage1 rather than\n+        // stage0. This works fine if the local rust and being-built rust have the\n+        // same view of what the default allocator is, but fails otherwise. Since\n+        // we don't have a way to express an allocator preference yet, work\n+        // around the issue in the case of a local rebuild with jemalloc disabled.\n+        if compiler.stage == 0 && builder.local_rebuild && !builder.config.use_jemalloc {\n+            features.push_str(\" force_alloc_system\");\n+        }\n \n-    if compiler.stage != 0 && build.config.sanitizers {\n-        // This variable is used by the sanitizer runtime crates, e.g.\n-        // rustc_lsan, to build the sanitizer runtime from C code\n-        // When this variable is missing, those crates won't compile the C code,\n-        // so we don't set this variable during stage0 where llvm-config is\n-        // missing\n-        // We also only build the runtimes when --enable-sanitizers (or its\n-        // config.toml equivalent) is used\n-        cargo.env(\"LLVM_CONFIG\", build.llvm_config(target));\n-    }\n+        if compiler.stage != 0 && builder.config.sanitizers {\n+            // This variable is used by the sanitizer runtime crates, e.g.\n+            // rustc_lsan, to build the sanitizer runtime from C code\n+            // When this variable is missing, those crates won't compile the C code,\n+            // so we don't set this variable during stage0 where llvm-config is\n+            // missing\n+            // We also only build the runtimes when --enable-sanitizers (or its\n+            // config.toml equivalent) is used\n+            let llvm_config = builder.ensure(native::Llvm {\n+                target: builder.config.build,\n+                emscripten: false,\n+            });\n+            cargo.env(\"LLVM_CONFIG\", llvm_config);\n+        }\n \n-    cargo.arg(\"--features\").arg(features)\n-        .arg(\"--manifest-path\")\n-        .arg(build.src.join(\"src/libstd/Cargo.toml\"));\n+        cargo.arg(\"--features\").arg(features)\n+            .arg(\"--manifest-path\")\n+            .arg(builder.src.join(\"src/libstd/Cargo.toml\"));\n \n-    if let Some(target) = build.config.target_config.get(&target) {\n-        if let Some(ref jemalloc) = target.jemalloc {\n-            cargo.env(\"JEMALLOC_OVERRIDE\", jemalloc);\n+        if let Some(target) = builder.config.target_config.get(&target) {\n+            if let Some(ref jemalloc) = target.jemalloc {\n+                cargo.env(\"JEMALLOC_OVERRIDE\", jemalloc);\n+            }\n         }\n-    }\n-    if target.contains(\"musl\") {\n-        if let Some(p) = build.musl_root(target) {\n-            cargo.env(\"MUSL_ROOT\", p);\n+        if target.contains(\"musl\") {\n+            if let Some(p) = builder.musl_root(target) {\n+                cargo.env(\"MUSL_ROOT\", p);\n+            }\n         }\n     }\n }\n@@ -203,43 +226,42 @@ impl Step for StdLink {\n     /// libraries for `target`, and this method will find them in the relevant\n     /// output directory.\n     fn run(self, builder: &Builder) {\n-        let build = builder.build;\n         let compiler = self.compiler;\n         let target_compiler = self.target_compiler;\n         let target = self.target;\n-        println!(\"Copying stage{} std from stage{} ({} -> {} / {})\",\n+        builder.info(&format!(\"Copying stage{} std from stage{} ({} -> {} / {})\",\n                 target_compiler.stage,\n                 compiler.stage,\n                 &compiler.host,\n                 target_compiler.host,\n-                target);\n+                target));\n         let libdir = builder.sysroot_libdir(target_compiler, target);\n-        add_to_sysroot(&libdir, &libstd_stamp(build, compiler, target));\n+        add_to_sysroot(builder, &libdir, &libstd_stamp(builder, compiler, target));\n \n-        if build.config.sanitizers && compiler.stage != 0 && target == \"x86_64-apple-darwin\" {\n+        if builder.config.sanitizers && compiler.stage != 0 && target == \"x86_64-apple-darwin\" {\n             // The sanitizers are only built in stage1 or above, so the dylibs will\n             // be missing in stage0 and causes panic. See the `std()` function above\n             // for reason why the sanitizers are not built in stage0.\n-            copy_apple_sanitizer_dylibs(&build.native_dir(target), \"osx\", &libdir);\n+            copy_apple_sanitizer_dylibs(builder, &builder.native_dir(target), \"osx\", &libdir);\n         }\n \n         builder.ensure(tool::CleanTools {\n             compiler: target_compiler,\n             target,\n-            mode: Mode::Libstd,\n+            cause: Mode::Std,\n         });\n     }\n }\n \n-fn copy_apple_sanitizer_dylibs(native_dir: &Path, platform: &str, into: &Path) {\n+fn copy_apple_sanitizer_dylibs(builder: &Builder, native_dir: &Path, platform: &str, into: &Path) {\n     for &sanitizer in &[\"asan\", \"tsan\"] {\n         let filename = format!(\"libclang_rt.{}_{}_dynamic.dylib\", sanitizer, platform);\n         let mut src_path = native_dir.join(sanitizer);\n         src_path.push(\"build\");\n         src_path.push(\"lib\");\n         src_path.push(\"darwin\");\n         src_path.push(&filename);\n-        copy(&src_path, &into.join(filename));\n+        builder.copy(&src_path, &into.join(filename));\n     }\n }\n \n@@ -270,52 +292,55 @@ impl Step for StartupObjects {\n     /// files, so we just use the nightly snapshot compiler to always build them (as\n     /// no other compilers are guaranteed to be available).\n     fn run(self, builder: &Builder) {\n-        let build = builder.build;\n         let for_compiler = self.compiler;\n         let target = self.target;\n         if !target.contains(\"pc-windows-gnu\") {\n             return\n         }\n \n-        let src_dir = &build.src.join(\"src/rtstartup\");\n-        let dst_dir = &build.native_dir(target).join(\"rtstartup\");\n+        let src_dir = &builder.src.join(\"src/rtstartup\");\n+        let dst_dir = &builder.native_dir(target).join(\"rtstartup\");\n         let sysroot_dir = &builder.sysroot_libdir(for_compiler, target);\n         t!(fs::create_dir_all(dst_dir));\n \n         for file in &[\"rsbegin\", \"rsend\"] {\n             let src_file = &src_dir.join(file.to_string() + \".rs\");\n             let dst_file = &dst_dir.join(file.to_string() + \".o\");\n             if !up_to_date(src_file, dst_file) {\n-                let mut cmd = Command::new(&build.initial_rustc);\n-                build.run(cmd.env(\"RUSTC_BOOTSTRAP\", \"1\")\n+                let mut cmd = Command::new(&builder.initial_rustc);\n+                builder.run(cmd.env(\"RUSTC_BOOTSTRAP\", \"1\")\n                             .arg(\"--cfg\").arg(\"stage0\")\n                             .arg(\"--target\").arg(target)\n                             .arg(\"--emit=obj\")\n                             .arg(\"-o\").arg(dst_file)\n                             .arg(src_file));\n             }\n \n-            copy(dst_file, &sysroot_dir.join(file.to_string() + \".o\"));\n+            builder.copy(dst_file, &sysroot_dir.join(file.to_string() + \".o\"));\n         }\n \n         for obj in [\"crt2.o\", \"dllcrt2.o\"].iter() {\n-            copy(&compiler_file(build.cc(target), obj), &sysroot_dir.join(obj));\n+            let src = compiler_file(builder,\n+                                    builder.cc(target),\n+                                    target,\n+                                    obj);\n+            builder.copy(&src, &sysroot_dir.join(obj));\n         }\n     }\n }\n \n-#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n+#[derive(Debug, PartialOrd, Ord, Copy, Clone, PartialEq, Eq, Hash)]\n pub struct Test {\n-    pub compiler: Compiler,\n     pub target: Interned<String>,\n+    pub compiler: Compiler,\n }\n \n impl Step for Test {\n     type Output = ();\n     const DEFAULT: bool = true;\n \n     fn should_run(run: ShouldRun) -> ShouldRun {\n-        run.path(\"src/libtest\").krate(\"test\")\n+        run.all_krates(\"test\")\n     }\n \n     fn make_run(run: RunConfig) {\n@@ -331,55 +356,67 @@ impl Step for Test {\n     /// the build using the `compiler` targeting the `target` architecture. The\n     /// artifacts created will also be linked into the sysroot directory.\n     fn run(self, builder: &Builder) {\n-        let build = builder.build;\n         let target = self.target;\n         let compiler = self.compiler;\n \n         builder.ensure(Std { compiler, target });\n \n-        if build.force_use_stage1(compiler, target) {\n+        if builder.config.keep_stage.contains(&compiler.stage) {\n+            builder.info(\"Warning: Using a potentially old libtest. This may not behave well.\");\n+            builder.ensure(TestLink {\n+                compiler: compiler,\n+                target_compiler: compiler,\n+                target,\n+            });\n+            return;\n+        }\n+\n+        if builder.force_use_stage1(compiler, target) {\n             builder.ensure(Test {\n-                compiler: builder.compiler(1, build.build),\n+                compiler: builder.compiler(1, builder.config.build),\n                 target,\n             });\n-            println!(\"Uplifting stage1 test ({} -> {})\", &build.build, target);\n+            builder.info(\n+                &format!(\"Uplifting stage1 test ({} -> {})\", builder.config.build, target));\n             builder.ensure(TestLink {\n-                compiler: builder.compiler(1, build.build),\n+                compiler: builder.compiler(1, builder.config.build),\n                 target_compiler: compiler,\n                 target,\n             });\n             return;\n         }\n \n-        let _folder = build.fold_output(|| format!(\"stage{}-test\", compiler.stage));\n-        println!(\"Building stage{} test artifacts ({} -> {})\", compiler.stage,\n-                &compiler.host, target);\n-        let out_dir = build.stage_out(compiler, Mode::Libtest);\n-        build.clear_if_dirty(&out_dir, &libstd_stamp(build, compiler, target));\n-        let mut cargo = builder.cargo(compiler, Mode::Libtest, target, \"build\");\n-        test_cargo(build, &compiler, target, &mut cargo);\n-        run_cargo(build,\n+        let out_dir = builder.cargo_out(compiler, Mode::Test, target);\n+        builder.clear_if_dirty(&out_dir, &libstd_stamp(builder, compiler, target));\n+        let mut cargo = builder.cargo(compiler, Mode::Test, target, \"build\");\n+        test_cargo(builder, &compiler, target, &mut cargo);\n+\n+        let _folder = builder.fold_output(|| format!(\"stage{}-test\", compiler.stage));\n+        builder.info(&format!(\"Building stage{} test artifacts ({} -> {})\", compiler.stage,\n+                &compiler.host, target));\n+        run_cargo(builder,\n                   &mut cargo,\n-                  &libtest_stamp(build, compiler, target));\n+                  &libtest_stamp(builder, compiler, target),\n+                  false);\n \n         builder.ensure(TestLink {\n-            compiler: builder.compiler(compiler.stage, build.build),\n+            compiler: builder.compiler(compiler.stage, builder.config.build),\n             target_compiler: compiler,\n             target,\n         });\n     }\n }\n \n /// Same as `std_cargo`, but for libtest\n-pub fn test_cargo(build: &Build,\n+pub fn test_cargo(builder: &Builder,\n                   _compiler: &Compiler,\n                   _target: Interned<String>,\n                   cargo: &mut Command) {\n     if let Some(target) = env::var_os(\"MACOSX_STD_DEPLOYMENT_TARGET\") {\n         cargo.env(\"MACOSX_DEPLOYMENT_TARGET\", target);\n     }\n     cargo.arg(\"--manifest-path\")\n-        .arg(build.src.join(\"src/libtest/Cargo.toml\"));\n+        .arg(builder.src.join(\"src/libtest/Cargo.toml\"));\n }\n \n #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n@@ -398,30 +435,29 @@ impl Step for TestLink {\n \n     /// Same as `std_link`, only for libtest\n     fn run(self, builder: &Builder) {\n-        let build = builder.build;\n         let compiler = self.compiler;\n         let target_compiler = self.target_compiler;\n         let target = self.target;\n-        println!(\"Copying stage{} test from stage{} ({} -> {} / {})\",\n+        builder.info(&format!(\"Copying stage{} test from stage{} ({} -> {} / {})\",\n                 target_compiler.stage,\n                 compiler.stage,\n                 &compiler.host,\n                 target_compiler.host,\n-                target);\n-        add_to_sysroot(&builder.sysroot_libdir(target_compiler, target),\n-                    &libtest_stamp(build, compiler, target));\n+                target));\n+        add_to_sysroot(builder, &builder.sysroot_libdir(target_compiler, target),\n+                    &libtest_stamp(builder, compiler, target));\n         builder.ensure(tool::CleanTools {\n             compiler: target_compiler,\n             target,\n-            mode: Mode::Libtest,\n+            cause: Mode::Test,\n         });\n     }\n }\n \n-#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n+#[derive(Debug, PartialOrd, Ord, Copy, Clone, PartialEq, Eq, Hash)]\n pub struct Rustc {\n-    pub compiler: Compiler,\n     pub target: Interned<String>,\n+    pub compiler: Compiler,\n }\n \n impl Step for Rustc {\n@@ -430,7 +466,7 @@ impl Step for Rustc {\n     const DEFAULT: bool = true;\n \n     fn should_run(run: ShouldRun) -> ShouldRun {\n-        run.path(\"src/librustc\").krate(\"rustc-main\")\n+        run.all_krates(\"rustc-main\")\n     }\n \n     fn make_run(run: RunConfig) {\n@@ -446,24 +482,30 @@ impl Step for Rustc {\n     /// the `compiler` targeting the `target` architecture. The artifacts\n     /// created will also be linked into the sysroot directory.\n     fn run(self, builder: &Builder) {\n-        let build = builder.build;\n         let compiler = self.compiler;\n         let target = self.target;\n \n         builder.ensure(Test { compiler, target });\n \n-        // Build LLVM for our target. This will implicitly build the host LLVM\n-        // if necessary.\n-        builder.ensure(native::Llvm { target });\n+        if builder.config.keep_stage.contains(&compiler.stage) {\n+            builder.info(\"Warning: Using a potentially old librustc. This may not behave well.\");\n+            builder.ensure(RustcLink {\n+                compiler: compiler,\n+                target_compiler: compiler,\n+                target,\n+            });\n+            return;\n+        }\n \n-        if build.force_use_stage1(compiler, target) {\n+        if builder.force_use_stage1(compiler, target) {\n             builder.ensure(Rustc {\n-                compiler: builder.compiler(1, build.build),\n+                compiler: builder.compiler(1, builder.config.build),\n                 target,\n             });\n-            println!(\"Uplifting stage1 rustc ({} -> {})\", &build.build, target);\n+            builder.info(&format!(\"Uplifting stage1 rustc ({} -> {})\",\n+                builder.config.build, target));\n             builder.ensure(RustcLink {\n-                compiler: builder.compiler(1, build.build),\n+                compiler: builder.compiler(1, builder.config.build),\n                 target_compiler: compiler,\n                 target,\n             });\n@@ -472,92 +514,71 @@ impl Step for Rustc {\n \n         // Ensure that build scripts have a std to link against.\n         builder.ensure(Std {\n-            compiler: builder.compiler(self.compiler.stage, build.build),\n-            target: build.build,\n+            compiler: builder.compiler(self.compiler.stage, builder.config.build),\n+            target: builder.config.build,\n         });\n+        let cargo_out = builder.cargo_out(compiler, Mode::Rustc, target);\n+        builder.clear_if_dirty(&cargo_out, &libstd_stamp(builder, compiler, target));\n+        builder.clear_if_dirty(&cargo_out, &libtest_stamp(builder, compiler, target));\n \n-        let _folder = build.fold_output(|| format!(\"stage{}-rustc\", compiler.stage));\n-        println!(\"Building stage{} compiler artifacts ({} -> {})\",\n-                 compiler.stage, &compiler.host, target);\n-\n-        let stage_out = builder.stage_out(compiler, Mode::Librustc);\n-        build.clear_if_dirty(&stage_out, &libstd_stamp(build, compiler, target));\n-        build.clear_if_dirty(&stage_out, &libtest_stamp(build, compiler, target));\n+        let mut cargo = builder.cargo(compiler, Mode::Rustc, target, \"build\");\n+        rustc_cargo(builder, &mut cargo);\n \n-        let mut cargo = builder.cargo(compiler, Mode::Librustc, target, \"build\");\n-        rustc_cargo(build, target, &mut cargo);\n-        run_cargo(build,\n+        let _folder = builder.fold_output(|| format!(\"stage{}-rustc\", compiler.stage));\n+        builder.info(&format!(\"Building stage{} compiler artifacts ({} -> {})\",\n+                 compiler.stage, &compiler.host, target));\n+        run_cargo(builder,\n                   &mut cargo,\n-                  &librustc_stamp(build, compiler, target));\n+                  &librustc_stamp(builder, compiler, target),\n+                  false);\n \n         builder.ensure(RustcLink {\n-            compiler: builder.compiler(compiler.stage, build.build),\n+            compiler: builder.compiler(compiler.stage, builder.config.build),\n             target_compiler: compiler,\n             target,\n         });\n     }\n }\n \n-/// Same as `std_cargo`, but for libtest\n-pub fn rustc_cargo(build: &Build,\n-                   target: Interned<String>,\n-                   cargo: &mut Command) {\n-    cargo.arg(\"--features\").arg(build.rustc_features())\n+pub fn rustc_cargo(builder: &Builder, cargo: &mut Command) {\n+    cargo.arg(\"--features\").arg(builder.rustc_features())\n          .arg(\"--manifest-path\")\n-         .arg(build.src.join(\"src/rustc/Cargo.toml\"));\n+         .arg(builder.src.join(\"src/rustc/Cargo.toml\"));\n+    rustc_cargo_env(builder, cargo);\n+}\n \n+pub fn rustc_cargo_env(builder: &Builder, cargo: &mut Command) {\n     // Set some configuration variables picked up by build scripts and\n     // the compiler alike\n-    cargo.env(\"CFG_RELEASE\", build.rust_release())\n-         .env(\"CFG_RELEASE_CHANNEL\", &build.config.channel)\n-         .env(\"CFG_VERSION\", build.rust_version())\n-         .env(\"CFG_PREFIX\", build.config.prefix.clone().unwrap_or_default());\n+    cargo.env(\"CFG_RELEASE\", builder.rust_release())\n+         .env(\"CFG_RELEASE_CHANNEL\", &builder.config.channel)\n+         .env(\"CFG_VERSION\", builder.rust_version())\n+         .env(\"CFG_PREFIX\", builder.config.prefix.clone().unwrap_or_default())\n+         .env(\"CFG_CODEGEN_BACKENDS_DIR\", &builder.config.rust_codegen_backends_dir);\n \n-    let libdir_relative =\n-        build.config.libdir.clone().unwrap_or(PathBuf::from(\"lib\"));\n+    let libdir_relative = builder.config.libdir_relative().unwrap_or(Path::new(\"lib\"));\n     cargo.env(\"CFG_LIBDIR_RELATIVE\", libdir_relative);\n \n     // If we're not building a compiler with debugging information then remove\n     // these two env vars which would be set otherwise.\n-    if build.config.rust_debuginfo_only_std {\n+    if builder.config.rust_debuginfo_only_std {\n         cargo.env_remove(\"RUSTC_DEBUGINFO\");\n         cargo.env_remove(\"RUSTC_DEBUGINFO_LINES\");\n     }\n \n-    if let Some(ref ver_date) = build.rust_info.commit_date() {\n+    if let Some(ref ver_date) = builder.rust_info.commit_date() {\n         cargo.env(\"CFG_VER_DATE\", ver_date);\n     }\n-    if let Some(ref ver_hash) = build.rust_info.sha() {\n+    if let Some(ref ver_hash) = builder.rust_info.sha() {\n         cargo.env(\"CFG_VER_HASH\", ver_hash);\n     }\n-    if !build.unstable_features() {\n+    if !builder.unstable_features() {\n         cargo.env(\"CFG_DISABLE_UNSTABLE_FEATURES\", \"1\");\n     }\n-    // Flag that rust llvm is in use\n-    if build.is_rust_llvm(target) {\n-        cargo.env(\"LLVM_RUSTLLVM\", \"1\");\n-    }\n-    cargo.env(\"LLVM_CONFIG\", build.llvm_config(target));\n-    let target_config = build.config.target_config.get(&target);\n-    if let Some(s) = target_config.and_then(|c| c.llvm_config.as_ref()) {\n-        cargo.env(\"CFG_LLVM_ROOT\", s);\n-    }\n-    // Building with a static libstdc++ is only supported on linux right now,\n-    // not for MSVC or macOS\n-    if build.config.llvm_static_stdcpp &&\n-       !target.contains(\"freebsd\") &&\n-       !target.contains(\"windows\") &&\n-       !target.contains(\"apple\") {\n-        cargo.env(\"LLVM_STATIC_STDCPP\",\n-                  compiler_file(build.cxx(target).unwrap(), \"libstdc++.a\"));\n-    }\n-    if build.config.llvm_link_shared {\n-        cargo.env(\"LLVM_LINK_SHARED\", \"1\");\n-    }\n-    if let Some(ref s) = build.config.rustc_default_linker {\n+    if let Some(ref s) = builder.config.rustc_default_linker {\n         cargo.env(\"CFG_DEFAULT_LINKER\", s);\n     }\n-    if build.config.rustc_parallel_queries {\n+    if builder.config.rustc_parallel_queries {\n         cargo.env(\"RUSTC_PARALLEL_QUERIES\", \"1\");\n     }\n }\n@@ -578,47 +599,273 @@ impl Step for RustcLink {\n \n     /// Same as `std_link`, only for librustc\n     fn run(self, builder: &Builder) {\n-        let build = builder.build;\n         let compiler = self.compiler;\n         let target_compiler = self.target_compiler;\n         let target = self.target;\n-        println!(\"Copying stage{} rustc from stage{} ({} -> {} / {})\",\n+        builder.info(&format!(\"Copying stage{} rustc from stage{} ({} -> {} / {})\",\n                  target_compiler.stage,\n                  compiler.stage,\n                  &compiler.host,\n                  target_compiler.host,\n-                 target);\n-        add_to_sysroot(&builder.sysroot_libdir(target_compiler, target),\n-                       &librustc_stamp(build, compiler, target));\n+                 target));\n+        add_to_sysroot(builder, &builder.sysroot_libdir(target_compiler, target),\n+                       &librustc_stamp(builder, compiler, target));\n         builder.ensure(tool::CleanTools {\n             compiler: target_compiler,\n             target,\n-            mode: Mode::Librustc,\n+            cause: Mode::Rustc,\n+        });\n+    }\n+}\n+\n+#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n+pub struct CodegenBackend {\n+    pub compiler: Compiler,\n+    pub target: Interned<String>,\n+    pub backend: Interned<String>,\n+}\n+\n+impl Step for CodegenBackend {\n+    type Output = ();\n+    const ONLY_HOSTS: bool = true;\n+    const DEFAULT: bool = true;\n+\n+    fn should_run(run: ShouldRun) -> ShouldRun {\n+        run.all_krates(\"rustc_codegen_llvm\")\n+    }\n+\n+    fn make_run(run: RunConfig) {\n+        let backend = run.builder.config.rust_codegen_backends.get(0);\n+        let backend = backend.cloned().unwrap_or_else(|| {\n+            INTERNER.intern_str(\"llvm\")\n+        });\n+        run.builder.ensure(CodegenBackend {\n+            compiler: run.builder.compiler(run.builder.top_stage, run.host),\n+            target: run.target,\n+            backend,\n         });\n     }\n+\n+    fn run(self, builder: &Builder) {\n+        let compiler = self.compiler;\n+        let target = self.target;\n+        let backend = self.backend;\n+\n+        builder.ensure(Rustc { compiler, target });\n+\n+        if builder.config.keep_stage.contains(&compiler.stage) {\n+            builder.info(\"Warning: Using a potentially old codegen backend. \\\n+                This may not behave well.\");\n+            // Codegen backends are linked separately from this step today, so we don't do\n+            // anything here.\n+            return;\n+        }\n+\n+        if builder.force_use_stage1(compiler, target) {\n+            builder.ensure(CodegenBackend {\n+                compiler: builder.compiler(1, builder.config.build),\n+                target,\n+                backend,\n+            });\n+            return;\n+        }\n+\n+        let out_dir = builder.cargo_out(compiler, Mode::Codegen, target);\n+        builder.clear_if_dirty(&out_dir, &librustc_stamp(builder, compiler, target));\n+\n+        let mut cargo = builder.cargo(compiler, Mode::Codegen, target, \"build\");\n+        cargo.arg(\"--manifest-path\")\n+            .arg(builder.src.join(\"src/librustc_codegen_llvm/Cargo.toml\"));\n+        rustc_cargo_env(builder, &mut cargo);\n+\n+        let features = build_codegen_backend(&builder, &mut cargo, &compiler, target, backend);\n+\n+        let tmp_stamp = out_dir.join(\".tmp.stamp\");\n+\n+        let _folder = builder.fold_output(|| format!(\"stage{}-rustc_codegen_llvm\", compiler.stage));\n+        let files = run_cargo(builder,\n+                              cargo.arg(\"--features\").arg(features),\n+                              &tmp_stamp,\n+                              false);\n+        if builder.config.dry_run {\n+            return;\n+        }\n+        let mut files = files.into_iter()\n+            .filter(|f| {\n+                let filename = f.file_name().unwrap().to_str().unwrap();\n+                is_dylib(filename) && filename.contains(\"rustc_codegen_llvm-\")\n+            });\n+        let codegen_backend = match files.next() {\n+            Some(f) => f,\n+            None => panic!(\"no dylibs built for codegen backend?\"),\n+        };\n+        if let Some(f) = files.next() {\n+            panic!(\"codegen backend built two dylibs:\\n{}\\n{}\",\n+                   codegen_backend.display(),\n+                   f.display());\n+        }\n+        let stamp = codegen_backend_stamp(builder, compiler, target, backend);\n+        let codegen_backend = codegen_backend.to_str().unwrap();\n+        t!(t!(File::create(&stamp)).write_all(codegen_backend.as_bytes()));\n+    }\n+}\n+\n+pub fn build_codegen_backend(builder: &Builder,\n+                             cargo: &mut Command,\n+                             compiler: &Compiler,\n+                             target: Interned<String>,\n+                             backend: Interned<String>) -> String {\n+    let mut features = String::new();\n+\n+    match &*backend {\n+        \"llvm\" | \"emscripten\" => {\n+            // Build LLVM for our target. This will implicitly build the\n+            // host LLVM if necessary.\n+            let llvm_config = builder.ensure(native::Llvm {\n+                target,\n+                emscripten: backend == \"emscripten\",\n+            });\n+\n+            if backend == \"emscripten\" {\n+                features.push_str(\" emscripten\");\n+            }\n+\n+            builder.info(&format!(\"Building stage{} codegen artifacts ({} -> {}, {})\",\n+                     compiler.stage, &compiler.host, target, backend));\n+\n+            // Pass down configuration from the LLVM build into the build of\n+            // librustc_llvm and librustc_codegen_llvm.\n+            if builder.is_rust_llvm(target) {\n+                cargo.env(\"LLVM_RUSTLLVM\", \"1\");\n+            }\n+            cargo.env(\"LLVM_CONFIG\", &llvm_config);\n+            if backend != \"emscripten\" {\n+                let target_config = builder.config.target_config.get(&target);\n+                if let Some(s) = target_config.and_then(|c| c.llvm_config.as_ref()) {\n+                    cargo.env(\"CFG_LLVM_ROOT\", s);\n+                }\n+            }\n+            // Building with a static libstdc++ is only supported on linux right now,\n+            // not for MSVC or macOS\n+            if builder.config.llvm_static_stdcpp &&\n+               !target.contains(\"freebsd\") &&\n+               !target.contains(\"windows\") &&\n+               !target.contains(\"apple\") {\n+                let file = compiler_file(builder,\n+                                         builder.cxx(target).unwrap(),\n+                                         target,\n+                                         \"libstdc++.a\");\n+                cargo.env(\"LLVM_STATIC_STDCPP\", file);\n+            }\n+            if builder.config.llvm_link_shared {\n+                cargo.env(\"LLVM_LINK_SHARED\", \"1\");\n+            }\n+        }\n+        _ => panic!(\"unknown backend: {}\", backend),\n+    }\n+\n+    features\n+}\n+\n+/// Creates the `codegen-backends` folder for a compiler that's about to be\n+/// assembled as a complete compiler.\n+///\n+/// This will take the codegen artifacts produced by `compiler` and link them\n+/// into an appropriate location for `target_compiler` to be a functional\n+/// compiler.\n+fn copy_codegen_backends_to_sysroot(builder: &Builder,\n+                                    compiler: Compiler,\n+                                    target_compiler: Compiler) {\n+    let target = target_compiler.host;\n+\n+    // Note that this step is different than all the other `*Link` steps in\n+    // that it's not assembling a bunch of libraries but rather is primarily\n+    // moving the codegen backend into place. The codegen backend of rustc is\n+    // not linked into the main compiler by default but is rather dynamically\n+    // selected at runtime for inclusion.\n+    //\n+    // Here we're looking for the output dylib of the `CodegenBackend` step and\n+    // we're copying that into the `codegen-backends` folder.\n+    let dst = builder.sysroot_codegen_backends(target_compiler);\n+    t!(fs::create_dir_all(&dst));\n+\n+    if builder.config.dry_run {\n+        return;\n+    }\n+\n+    for backend in builder.config.rust_codegen_backends.iter() {\n+        let stamp = codegen_backend_stamp(builder, compiler, target, *backend);\n+        let mut dylib = String::new();\n+        t!(t!(File::open(&stamp)).read_to_string(&mut dylib));\n+        let file = Path::new(&dylib);\n+        let filename = file.file_name().unwrap().to_str().unwrap();\n+        // change `librustc_codegen_llvm-xxxxxx.so` to `librustc_codegen_llvm-llvm.so`\n+        let target_filename = {\n+            let dash = filename.find(\"-\").unwrap();\n+            let dot = filename.find(\".\").unwrap();\n+            format!(\"{}-{}{}\",\n+                    &filename[..dash],\n+                    backend,\n+                    &filename[dot..])\n+        };\n+        builder.copy(&file, &dst.join(target_filename));\n+    }\n+}\n+\n+fn copy_lld_to_sysroot(builder: &Builder,\n+                       target_compiler: Compiler,\n+                       lld_install_root: &Path) {\n+    let target = target_compiler.host;\n+\n+    let dst = builder.sysroot_libdir(target_compiler, target)\n+        .parent()\n+        .unwrap()\n+        .join(\"bin\");\n+    t!(fs::create_dir_all(&dst));\n+\n+    let src_exe = exe(\"lld\", &target);\n+    let dst_exe = exe(\"rust-lld\", &target);\n+    // we prepend this bin directory to the user PATH when linking Rust binaries. To\n+    // avoid shadowing the system LLD we rename the LLD we provide to `rust-lld`.\n+    builder.copy(&lld_install_root.join(\"bin\").join(&src_exe), &dst.join(&dst_exe));\n }\n \n /// Cargo's output path for the standard library in a given stage, compiled\n /// by a particular compiler for the specified target.\n-pub fn libstd_stamp(build: &Build, compiler: Compiler, target: Interned<String>) -> PathBuf {\n-    build.cargo_out(compiler, Mode::Libstd, target).join(\".libstd.stamp\")\n+pub fn libstd_stamp(builder: &Builder, compiler: Compiler, target: Interned<String>) -> PathBuf {\n+    builder.cargo_out(compiler, Mode::Std, target).join(\".libstd.stamp\")\n }\n \n /// Cargo's output path for libtest in a given stage, compiled by a particular\n /// compiler for the specified target.\n-pub fn libtest_stamp(build: &Build, compiler: Compiler, target: Interned<String>) -> PathBuf {\n-    build.cargo_out(compiler, Mode::Libtest, target).join(\".libtest.stamp\")\n+pub fn libtest_stamp(builder: &Builder, compiler: Compiler, target: Interned<String>) -> PathBuf {\n+    builder.cargo_out(compiler, Mode::Test, target).join(\".libtest.stamp\")\n }\n \n /// Cargo's output path for librustc in a given stage, compiled by a particular\n /// compiler for the specified target.\n-pub fn librustc_stamp(build: &Build, compiler: Compiler, target: Interned<String>) -> PathBuf {\n-    build.cargo_out(compiler, Mode::Librustc, target).join(\".librustc.stamp\")\n+pub fn librustc_stamp(builder: &Builder, compiler: Compiler, target: Interned<String>) -> PathBuf {\n+    builder.cargo_out(compiler, Mode::Rustc, target).join(\".librustc.stamp\")\n+}\n+\n+/// Cargo's output path for librustc_codegen_llvm in a given stage, compiled by a particular\n+/// compiler for the specified target and backend.\n+fn codegen_backend_stamp(builder: &Builder,\n+                         compiler: Compiler,\n+                         target: Interned<String>,\n+                         backend: Interned<String>) -> PathBuf {\n+    builder.cargo_out(compiler, Mode::Codegen, target)\n+        .join(format!(\".librustc_codegen_llvm-{}.stamp\", backend))\n }\n \n-fn compiler_file(compiler: &Path, file: &str) -> PathBuf {\n-    let out = output(Command::new(compiler)\n-                            .arg(format!(\"-print-file-name={}\", file)));\n+pub fn compiler_file(builder: &Builder,\n+                 compiler: &Path,\n+                 target: Interned<String>,\n+                 file: &str) -> PathBuf {\n+    let mut cmd = Command::new(compiler);\n+    cmd.args(builder.cflags(target));\n+    cmd.arg(format!(\"-print-file-name={}\", file));\n+    let out = output(&mut cmd);\n     PathBuf::from(out.trim())\n }\n \n@@ -641,20 +888,19 @@ impl Step for Sysroot {\n     /// thinks it is by default, but it's the same as the default for stages\n     /// 1-3.\n     fn run(self, builder: &Builder) -> Interned<PathBuf> {\n-        let build = builder.build;\n         let compiler = self.compiler;\n         let sysroot = if compiler.stage == 0 {\n-            build.out.join(&compiler.host).join(\"stage0-sysroot\")\n+            builder.out.join(&compiler.host).join(\"stage0-sysroot\")\n         } else {\n-            build.out.join(&compiler.host).join(format!(\"stage{}\", compiler.stage))\n+            builder.out.join(&compiler.host).join(format!(\"stage{}\", compiler.stage))\n         };\n         let _ = fs::remove_dir_all(&sysroot);\n         t!(fs::create_dir_all(&sysroot));\n         INTERNER.intern_path(sysroot)\n     }\n }\n \n-#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n+#[derive(Debug, Copy, PartialOrd, Ord, Clone, PartialEq, Eq, Hash)]\n pub struct Assemble {\n     /// The compiler which we will produce in this step. Assemble itself will\n     /// take care of ensuring that the necessary prerequisites to do so exist,\n@@ -667,85 +913,99 @@ impl Step for Assemble {\n     type Output = Compiler;\n \n     fn should_run(run: ShouldRun) -> ShouldRun {\n-        run.path(\"src/rustc\")\n+        run.never()\n     }\n \n     /// Prepare a new compiler from the artifacts in `stage`\n     ///\n     /// This will assemble a compiler in `build/$host/stage$stage`. The compiler\n-    /// must have been previously produced by the `stage - 1` build.build\n+    /// must have been previously produced by the `stage - 1` builder.build\n     /// compiler.\n     fn run(self, builder: &Builder) -> Compiler {\n-        let build = builder.build;\n         let target_compiler = self.target_compiler;\n \n         if target_compiler.stage == 0 {\n-            assert_eq!(build.build, target_compiler.host,\n+            assert_eq!(builder.config.build, target_compiler.host,\n                 \"Cannot obtain compiler for non-native build triple at stage 0\");\n             // The stage 0 compiler for the build triple is always pre-built.\n             return target_compiler;\n         }\n \n         // Get the compiler that we'll use to bootstrap ourselves.\n-        let build_compiler = if target_compiler.host != build.build {\n-            // Build a compiler for the host platform. We cannot use the stage0\n-            // compiler for the host platform for this because it doesn't have\n-            // the libraries we need.  FIXME: Perhaps we should download those\n-            // libraries? It would make builds faster...\n-            // FIXME: It may be faster if we build just a stage 1\n-            // compiler and then use that to bootstrap this compiler\n-            // forward.\n-            builder.compiler(target_compiler.stage - 1, build.build)\n-        } else {\n-            // Build the compiler we'll use to build the stage requested. This\n-            // may build more than one compiler (going down to stage 0).\n-            builder.compiler(target_compiler.stage - 1, target_compiler.host)\n-        };\n+        //\n+        // Note that this is where the recursive nature of the bootstrap\n+        // happens, as this will request the previous stage's compiler on\n+        // downwards to stage 0.\n+        //\n+        // Also note that we're building a compiler for the host platform. We\n+        // only assume that we can run `build` artifacts, which means that to\n+        // produce some other architecture compiler we need to start from\n+        // `build` to get there.\n+        //\n+        // FIXME: Perhaps we should download those libraries?\n+        //        It would make builds faster...\n+        //\n+        // FIXME: It may be faster if we build just a stage 1 compiler and then\n+        //        use that to bootstrap this compiler forward.\n+        let build_compiler =\n+            builder.compiler(target_compiler.stage - 1, builder.config.build);\n \n         // Build the libraries for this compiler to link to (i.e., the libraries\n         // it uses at runtime). NOTE: Crates the target compiler compiles don't\n         // link to these. (FIXME: Is that correct? It seems to be correct most\n         // of the time but I think we do link to these for stage2/bin compilers\n         // when not performing a full bootstrap).\n-        if builder.build.config.keep_stage.map_or(false, |s| target_compiler.stage <= s) {\n-            builder.verbose(\"skipping compilation of compiler due to --keep-stage\");\n-            let compiler = build_compiler;\n-            for stage in 0..min(target_compiler.stage, builder.config.keep_stage.unwrap()) {\n-                let target_compiler = builder.compiler(stage, target_compiler.host);\n-                let target = target_compiler.host;\n-                builder.ensure(StdLink { compiler, target_compiler, target });\n-                builder.ensure(TestLink { compiler, target_compiler, target });\n-                builder.ensure(RustcLink { compiler, target_compiler, target });\n-            }\n-        } else {\n-            builder.ensure(Rustc { compiler: build_compiler, target: target_compiler.host });\n+        builder.ensure(Rustc {\n+            compiler: build_compiler,\n+            target: target_compiler.host,\n+        });\n+        for &backend in builder.config.rust_codegen_backends.iter() {\n+            builder.ensure(CodegenBackend {\n+                compiler: build_compiler,\n+                target: target_compiler.host,\n+                backend,\n+            });\n         }\n \n+        let lld_install = if builder.config.lld_enabled {\n+            Some(builder.ensure(native::Lld {\n+                target: target_compiler.host,\n+            }))\n+        } else {\n+            None\n+        };\n+\n         let stage = target_compiler.stage;\n         let host = target_compiler.host;\n-        println!(\"Assembling stage{} compiler ({})\", stage, host);\n+        builder.info(&format!(\"Assembling stage{} compiler ({})\", stage, host));\n \n         // Link in all dylibs to the libdir\n         let sysroot = builder.sysroot(target_compiler);\n         let sysroot_libdir = sysroot.join(libdir(&*host));\n         t!(fs::create_dir_all(&sysroot_libdir));\n         let src_libdir = builder.sysroot_libdir(build_compiler, host);\n-        for f in t!(fs::read_dir(&src_libdir)).map(|f| t!(f)) {\n+        for f in builder.read_dir(&src_libdir) {\n             let filename = f.file_name().into_string().unwrap();\n             if is_dylib(&filename) {\n-                copy(&f.path(), &sysroot_libdir.join(&filename));\n+                builder.copy(&f.path(), &sysroot_libdir.join(&filename));\n             }\n         }\n \n-        let out_dir = build.cargo_out(build_compiler, Mode::Librustc, host);\n+        copy_codegen_backends_to_sysroot(builder,\n+                                         build_compiler,\n+                                         target_compiler);\n+        if let Some(lld_install) = lld_install {\n+            copy_lld_to_sysroot(builder, target_compiler, &lld_install);\n+        }\n \n         // Link the compiler binary itself into place\n-        let rustc = out_dir.join(exe(\"rustc\", &*host));\n+        let out_dir = builder.cargo_out(build_compiler, Mode::Rustc, host);\n+        let rustc = out_dir.join(exe(\"rustc_binary\", &*host));\n         let bindir = sysroot.join(\"bin\");\n         t!(fs::create_dir_all(&bindir));\n         let compiler = builder.rustc(target_compiler);\n         let _ = fs::remove_file(&compiler);\n-        copy(&rustc, &compiler);\n+        builder.copy(&rustc, &compiler);\n \n         target_compiler\n     }\n@@ -755,10 +1015,10 @@ impl Step for Assemble {\n ///\n /// For a particular stage this will link the file listed in `stamp` into the\n /// `sysroot_dst` provided.\n-fn add_to_sysroot(sysroot_dst: &Path, stamp: &Path) {\n+pub fn add_to_sysroot(builder: &Builder, sysroot_dst: &Path, stamp: &Path) {\n     t!(fs::create_dir_all(&sysroot_dst));\n-    for path in read_stamp_file(stamp) {\n-        copy(&path, &sysroot_dst.join(path.file_name().unwrap()));\n+    for path in builder.read_stamp_file(stamp) {\n+        builder.copy(&path, &sysroot_dst.join(path.file_name().unwrap()));\n     }\n }\n \n@@ -785,25 +1045,13 @@ fn stderr_isatty() -> bool {\n     }\n }\n \n-fn run_cargo(build: &Build, cargo: &mut Command, stamp: &Path) {\n-    // Instruct Cargo to give us json messages on stdout, critically leaving\n-    // stderr as piped so we can get those pretty colors.\n-    cargo.arg(\"--message-format\").arg(\"json\")\n-         .stdout(Stdio::piped());\n-\n-    if stderr_isatty() && build.ci_env == CiEnv::None {\n-        // since we pass message-format=json to cargo, we need to tell the rustc\n-        // wrapper to give us colored output if necessary. This is because we\n-        // only want Cargo's JSON output, not rustcs.\n-        cargo.env(\"RUSTC_COLOR\", \"1\");\n+pub fn run_cargo(builder: &Builder, cargo: &mut Command, stamp: &Path, is_check: bool)\n+    -> Vec<PathBuf>\n+{\n+    if builder.config.dry_run {\n+        return Vec::new();\n     }\n \n-    build.verbose(&format!(\"running: {:?}\", cargo));\n-    let mut child = match cargo.spawn() {\n-        Ok(child) => child,\n-        Err(e) => panic!(\"failed to execute command: {:?}\\nerror: {}\", cargo, e),\n-    };\n-\n     // `target_root_dir` looks like $dir/$target/release\n     let target_root_dir = stamp.parent().unwrap();\n     // `target_deps_dir` looks like $dir/$target/release/deps\n@@ -818,29 +1066,21 @@ fn run_cargo(build: &Build, cargo: &mut Command, stamp: &Path) {\n     // files we need to probe for later.\n     let mut deps = Vec::new();\n     let mut toplevel = Vec::new();\n-    let stdout = BufReader::new(child.stdout.take().unwrap());\n-    for line in stdout.lines() {\n-        let line = t!(line);\n-        let json: serde_json::Value = if line.starts_with(\"{\") {\n-            t!(serde_json::from_str(&line))\n-        } else {\n-            // If this was informational, just print it out and continue\n-            println!(\"{}\", line);\n-            continue\n+    let ok = stream_cargo(builder, cargo, &mut |msg| {\n+        let filenames = match msg {\n+            CargoMessage::CompilerArtifact { filenames, .. } => filenames,\n+            _ => return,\n         };\n-        if json[\"reason\"].as_str() != Some(\"compiler-artifact\") {\n-            continue\n-        }\n-        for filename in json[\"filenames\"].as_array().unwrap() {\n-            let filename = filename.as_str().unwrap();\n+        for filename in filenames {\n             // Skip files like executables\n             if !filename.ends_with(\".rlib\") &&\n                !filename.ends_with(\".lib\") &&\n-               !is_dylib(&filename) {\n-                continue\n+               !is_dylib(&filename) &&\n+               !(is_check && filename.ends_with(\".rmeta\")) {\n+                continue;\n             }\n \n-            let filename = Path::new(filename);\n+            let filename = Path::new(&*filename);\n \n             // If this was an output file in the \"host dir\" we don't actually\n             // worry about it, it's not relevant for us.\n@@ -873,15 +1113,10 @@ fn run_cargo(build: &Build, cargo: &mut Command, stamp: &Path) {\n \n             toplevel.push((file_stem, extension, expected_len));\n         }\n-    }\n+    });\n \n-    // Make sure Cargo actually succeeded after we read all of its stdout.\n-    let status = t!(child.wait());\n-    if !status.success() {\n-        panic!(\"command did not execute successfully: {:?}\\n\\\n-                expected success, got: {}\",\n-               cargo,\n-               status);\n+    if !ok {\n+        panic!(\"cargo must succeed\");\n     }\n \n     // Ok now we need to actually find all the files listed in `toplevel`. We've\n@@ -928,8 +1163,8 @@ fn run_cargo(build: &Build, cargo: &mut Command, stamp: &Path) {\n     let mut new_contents = Vec::new();\n     let mut max = None;\n     let mut max_path = None;\n-    for dep in deps {\n-        let mtime = mtime(&dep);\n+    for dep in deps.iter() {\n+        let mtime = mtime(dep);\n         if Some(mtime) > max {\n             max = Some(mtime);\n             max_path = Some(dep.clone());\n@@ -940,14 +1175,80 @@ fn run_cargo(build: &Build, cargo: &mut Command, stamp: &Path) {\n     let max = max.unwrap();\n     let max_path = max_path.unwrap();\n     if stamp_contents == new_contents && max <= stamp_mtime {\n-        build.verbose(&format!(\"not updating {:?}; contents equal and {} <= {}\",\n+        builder.verbose(&format!(\"not updating {:?}; contents equal and {:?} <= {:?}\",\n                 stamp, max, stamp_mtime));\n-        return\n+        return deps\n     }\n     if max > stamp_mtime {\n-        build.verbose(&format!(\"updating {:?} as {:?} changed\", stamp, max_path));\n+        builder.verbose(&format!(\"updating {:?} as {:?} changed\", stamp, max_path));\n     } else {\n-        build.verbose(&format!(\"updating {:?} as deps changed\", stamp));\n+        builder.verbose(&format!(\"updating {:?} as deps changed\", stamp));\n     }\n     t!(t!(File::create(stamp)).write_all(&new_contents));\n+    deps\n+}\n+\n+pub fn stream_cargo(\n+    builder: &Builder,\n+    cargo: &mut Command,\n+    cb: &mut dyn FnMut(CargoMessage),\n+) -> bool {\n+    if builder.config.dry_run {\n+        return true;\n+    }\n+    // Instruct Cargo to give us json messages on stdout, critically leaving\n+    // stderr as piped so we can get those pretty colors.\n+    cargo.arg(\"--message-format\").arg(\"json\")\n+         .stdout(Stdio::piped());\n+\n+    if stderr_isatty() && builder.ci_env == CiEnv::None &&\n+        // if the terminal is reported as dumb, then we don't want to enable color for rustc\n+        env::var_os(\"TERM\").map(|t| t != *\"dumb\").unwrap_or(true) {\n+        // since we pass message-format=json to cargo, we need to tell the rustc\n+        // wrapper to give us colored output if necessary. This is because we\n+        // only want Cargo's JSON output, not rustcs.\n+        cargo.env(\"RUSTC_COLOR\", \"1\");\n+    }\n+\n+    builder.verbose(&format!(\"running: {:?}\", cargo));\n+    let mut child = match cargo.spawn() {\n+        Ok(child) => child,\n+        Err(e) => panic!(\"failed to execute command: {:?}\\nerror: {}\", cargo, e),\n+    };\n+\n+    // Spawn Cargo slurping up its JSON output. We'll start building up the\n+    // `deps` array of all files it generated along with a `toplevel` array of\n+    // files we need to probe for later.\n+    let stdout = BufReader::new(child.stdout.take().unwrap());\n+    for line in stdout.lines() {\n+        let line = t!(line);\n+        match serde_json::from_str::<CargoMessage>(&line) {\n+            Ok(msg) => cb(msg),\n+            // If this was informational, just print it out and continue\n+            Err(_) => println!(\"{}\", line)\n+        }\n+    }\n+\n+    // Make sure Cargo actually succeeded after we read all of its stdout.\n+    let status = t!(child.wait());\n+    if !status.success() {\n+        eprintln!(\"command did not execute successfully: {:?}\\n\\\n+                  expected success, got: {}\",\n+                 cargo,\n+                 status);\n+    }\n+    status.success()\n+}\n+\n+#[derive(Deserialize)]\n+#[serde(tag = \"reason\", rename_all = \"kebab-case\")]\n+pub enum CargoMessage<'a> {\n+    CompilerArtifact {\n+        package_id: Cow<'a, str>,\n+        features: Vec<Cow<'a, str>>,\n+        filenames: Vec<Cow<'a, str>>,\n+    },\n+    BuildScriptExecuted {\n+        package_id: Cow<'a, str>,\n+    }\n }"}, {"sha": "43650332d3b67c901df7c8783b09953cd175401d", "filename": "src/bootstrap/config.rs", "status": "modified", "additions": 132, "deletions": 37, "changes": 169, "blob_url": "https://github.com/rust-lang/rust/blob/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fbootstrap%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fbootstrap%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfig.rs?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd", "patch": "@@ -13,17 +13,16 @@\n //! This module implements parsing `config.toml` configuration files to tweak\n //! how the build runs.\n \n-use std::collections::HashMap;\n+use std::collections::{HashMap, HashSet};\n use std::env;\n-use std::fs::File;\n+use std::fs::{self, File};\n use std::io::prelude::*;\n-use std::path::PathBuf;\n+use std::path::{Path, PathBuf};\n use std::process;\n use std::cmp;\n \n use num_cpus;\n use toml;\n-use util::exe;\n use cache::{INTERNER, Interned};\n use flags::Flags;\n pub use flags::Subcommand;\n@@ -45,26 +44,34 @@ pub struct Config {\n     pub ninja: bool,\n     pub verbose: usize,\n     pub submodules: bool,\n+    pub fast_submodules: bool,\n     pub compiler_docs: bool,\n     pub docs: bool,\n     pub locked_deps: bool,\n     pub vendor: bool,\n     pub target_config: HashMap<Interned<String>, Target>,\n     pub full_bootstrap: bool,\n     pub extended: bool,\n+    pub tools: Option<HashSet<String>>,\n     pub sanitizers: bool,\n     pub profiler: bool,\n     pub ignore_git: bool,\n+    pub exclude: Vec<PathBuf>,\n+    pub rustc_error_format: Option<String>,\n \n     pub run_host_only: bool,\n \n     pub on_fail: Option<String>,\n     pub stage: Option<u32>,\n-    pub keep_stage: Option<u32>,\n+    pub keep_stage: Vec<u32>,\n     pub src: PathBuf,\n     pub jobs: Option<u32>,\n     pub cmd: Subcommand,\n     pub incremental: bool,\n+    pub dry_run: bool,\n+\n+    pub deny_warnings: bool,\n+    pub backtrace_on_ice: bool,\n \n     // llvm codegen options\n     pub llvm_enabled: bool,\n@@ -74,23 +81,32 @@ pub struct Config {\n     pub llvm_version_check: bool,\n     pub llvm_static_stdcpp: bool,\n     pub llvm_link_shared: bool,\n+    pub llvm_clang_cl: Option<String>,\n     pub llvm_targets: Option<String>,\n     pub llvm_experimental_targets: String,\n     pub llvm_link_jobs: Option<u32>,\n \n+    pub lld_enabled: bool,\n+    pub lldb_enabled: bool,\n+    pub llvm_tools_enabled: bool,\n+\n     // rust codegen options\n     pub rust_optimize: bool,\n     pub rust_codegen_units: Option<u32>,\n     pub rust_debug_assertions: bool,\n     pub rust_debuginfo: bool,\n     pub rust_debuginfo_lines: bool,\n     pub rust_debuginfo_only_std: bool,\n+    pub rust_debuginfo_tools: bool,\n     pub rust_rpath: bool,\n     pub rustc_parallel_queries: bool,\n     pub rustc_default_linker: Option<String>,\n     pub rust_optimize_tests: bool,\n     pub rust_debuginfo_tests: bool,\n     pub rust_dist_src: bool,\n+    pub rust_codegen_backends: Vec<Interned<String>>,\n+    pub rust_codegen_backends_dir: String,\n+    pub rust_verify_llvm_ir: bool,\n \n     pub build: Interned<String>,\n     pub hosts: Vec<Interned<String>>,\n@@ -106,18 +122,21 @@ pub struct Config {\n     pub debug_jemalloc: bool,\n     pub use_jemalloc: bool,\n     pub backtrace: bool, // support for RUST_BACKTRACE\n+    pub wasm_syscall: bool,\n \n     // misc\n     pub low_priority: bool,\n     pub channel: String,\n-    pub quiet_tests: bool,\n+    pub verbose_tests: bool,\n     pub test_miri: bool,\n     pub save_toolstates: Option<PathBuf>,\n+    pub print_step_timings: bool,\n \n     // Fallback musl-root for all targets\n     pub musl_root: Option<PathBuf>,\n     pub prefix: Option<PathBuf>,\n     pub sysconfdir: Option<PathBuf>,\n+    pub datadir: Option<PathBuf>,\n     pub docdir: Option<PathBuf>,\n     pub bindir: Option<PathBuf>,\n     pub libdir: Option<PathBuf>,\n@@ -132,6 +151,7 @@ pub struct Config {\n     // These are either the stage0 downloaded binaries or the locally installed ones.\n     pub initial_cargo: PathBuf,\n     pub initial_rustc: PathBuf,\n+    pub out: PathBuf,\n }\n \n /// Per-target configuration stored in the global configuration structure.\n@@ -148,6 +168,7 @@ pub struct Target {\n     pub crt_static: Option<bool>,\n     pub musl_root: Option<PathBuf>,\n     pub qemu_rootfs: Option<PathBuf>,\n+    pub no_std: bool,\n }\n \n /// Structure of the `config.toml` file that configuration is read from.\n@@ -181,19 +202,22 @@ struct Build {\n     compiler_docs: Option<bool>,\n     docs: Option<bool>,\n     submodules: Option<bool>,\n+    fast_submodules: Option<bool>,\n     gdb: Option<String>,\n     locked_deps: Option<bool>,\n     vendor: Option<bool>,\n     nodejs: Option<String>,\n     python: Option<String>,\n     full_bootstrap: Option<bool>,\n     extended: Option<bool>,\n+    tools: Option<HashSet<String>>,\n     verbose: Option<usize>,\n     sanitizers: Option<bool>,\n     profiler: Option<bool>,\n     openssl_static: Option<bool>,\n     configure_args: Option<Vec<String>>,\n     local_rebuild: Option<bool>,\n+    print_step_timings: Option<bool>,\n }\n \n /// TOML representation of various global install decisions.\n@@ -202,13 +226,13 @@ struct Build {\n struct Install {\n     prefix: Option<String>,\n     sysconfdir: Option<String>,\n+    datadir: Option<String>,\n     docdir: Option<String>,\n     bindir: Option<String>,\n     libdir: Option<String>,\n     mandir: Option<String>,\n \n     // standard paths, currently unused\n-    datadir: Option<String>,\n     infodir: Option<String>,\n     localstatedir: Option<String>,\n }\n@@ -229,6 +253,7 @@ struct Llvm {\n     experimental_targets: Option<String>,\n     link_jobs: Option<u32>,\n     link_shared: Option<bool>,\n+    clang_cl: Option<String>\n }\n \n #[derive(Deserialize, Default, Clone)]\n@@ -263,6 +288,7 @@ struct Rust {\n     debuginfo: Option<bool>,\n     debuginfo_lines: Option<bool>,\n     debuginfo_only_std: Option<bool>,\n+    debuginfo_tools: Option<bool>,\n     experimental_parallel_queries: Option<bool>,\n     debug_jemalloc: Option<bool>,\n     use_jemalloc: Option<bool>,\n@@ -277,9 +303,19 @@ struct Rust {\n     ignore_git: Option<bool>,\n     debug: Option<bool>,\n     dist_src: Option<bool>,\n-    quiet_tests: Option<bool>,\n+    verbose_tests: Option<bool>,\n     test_miri: Option<bool>,\n+    incremental: Option<bool>,\n     save_toolstates: Option<String>,\n+    codegen_backends: Option<Vec<String>>,\n+    codegen_backends_dir: Option<String>,\n+    wasm_syscall: Option<bool>,\n+    lld: Option<bool>,\n+    lldb: Option<bool>,\n+    llvm_tools: Option<bool>,\n+    deny_warnings: Option<bool>,\n+    backtrace_on_ice: Option<bool>,\n+    verify_llvm_ir: Option<bool>,\n }\n \n /// TOML representation of how each build target is configured.\n@@ -299,9 +335,15 @@ struct TomlTarget {\n }\n \n impl Config {\n-    pub fn parse(args: &[String]) -> Config {\n-        let flags = Flags::parse(&args);\n-        let file = flags.config.clone();\n+    fn path_from_python(var_key: &str) -> PathBuf {\n+        match env::var_os(var_key) {\n+            // Do not trust paths from Python and normalize them slightly (#49785).\n+            Some(var_val) => Path::new(&var_val).components().collect(),\n+            _ => panic!(\"expected '{}' to be set\", var_key),\n+        }\n+    }\n+\n+    pub fn default_opts() -> Config {\n         let mut config = Config::default();\n         config.llvm_enabled = true;\n         config.llvm_optimize = true;\n@@ -311,24 +353,54 @@ impl Config {\n         config.rust_optimize = true;\n         config.rust_optimize_tests = true;\n         config.submodules = true;\n+        config.fast_submodules = true;\n         config.docs = true;\n         config.rust_rpath = true;\n         config.channel = \"dev\".to_string();\n         config.codegen_tests = true;\n         config.ignore_git = false;\n         config.rust_dist_src = true;\n         config.test_miri = false;\n+        config.rust_codegen_backends = vec![INTERNER.intern_str(\"llvm\")];\n+        config.rust_codegen_backends_dir = \"codegen-backends\".to_owned();\n+        config.deny_warnings = true;\n+\n+        // set by bootstrap.py\n+        config.build = INTERNER.intern_str(&env::var(\"BUILD\").expect(\"'BUILD' to be set\"));\n+        config.src = Config::path_from_python(\"SRC\");\n+        config.out = Config::path_from_python(\"BUILD_DIR\");\n+\n+        config.initial_rustc = Config::path_from_python(\"RUSTC\");\n+        config.initial_cargo = Config::path_from_python(\"CARGO\");\n+\n+        config\n+    }\n \n+    pub fn parse(args: &[String]) -> Config {\n+        let flags = Flags::parse(&args);\n+        let file = flags.config.clone();\n+        let mut config = Config::default_opts();\n+        config.exclude = flags.exclude;\n+        config.rustc_error_format = flags.rustc_error_format;\n         config.on_fail = flags.on_fail;\n         config.stage = flags.stage;\n-        config.src = flags.src;\n         config.jobs = flags.jobs;\n         config.cmd = flags.cmd;\n         config.incremental = flags.incremental;\n+        config.dry_run = flags.dry_run;\n         config.keep_stage = flags.keep_stage;\n+        if let Some(value) = flags.warnings {\n+            config.deny_warnings = value;\n+        }\n+\n+        if config.dry_run {\n+            let dir = config.out.join(\"tmp-dry-run\");\n+            t!(fs::create_dir_all(&dir));\n+            config.out = dir;\n+        }\n \n         // If --target was specified but --host wasn't specified, don't run any host-only tests.\n-        config.run_host_only = flags.host.is_empty() && !flags.target.is_empty();\n+        config.run_host_only = !(flags.host.is_empty() && !flags.target.is_empty());\n \n         let toml = file.map(|file| {\n             let mut f = t!(File::open(&file));\n@@ -345,12 +417,7 @@ impl Config {\n         }).unwrap_or_else(|| TomlConfig::default());\n \n         let build = toml.build.clone().unwrap_or(Build::default());\n-        set(&mut config.build, build.build.clone().map(|x| INTERNER.intern_string(x)));\n-        set(&mut config.build, flags.build);\n-        if config.build.is_empty() {\n-            // set by bootstrap.py\n-            config.build = INTERNER.intern_str(&env::var(\"BUILD\").unwrap());\n-        }\n+        // set by bootstrap.py\n         config.hosts.push(config.build.clone());\n         for host in build.host.iter() {\n             let host = INTERNER.intern_str(host);\n@@ -384,21 +451,25 @@ impl Config {\n         set(&mut config.compiler_docs, build.compiler_docs);\n         set(&mut config.docs, build.docs);\n         set(&mut config.submodules, build.submodules);\n+        set(&mut config.fast_submodules, build.fast_submodules);\n         set(&mut config.locked_deps, build.locked_deps);\n         set(&mut config.vendor, build.vendor);\n         set(&mut config.full_bootstrap, build.full_bootstrap);\n         set(&mut config.extended, build.extended);\n+        config.tools = build.tools;\n         set(&mut config.verbose, build.verbose);\n         set(&mut config.sanitizers, build.sanitizers);\n         set(&mut config.profiler, build.profiler);\n         set(&mut config.openssl_static, build.openssl_static);\n         set(&mut config.configure_args, build.configure_args);\n         set(&mut config.local_rebuild, build.local_rebuild);\n+        set(&mut config.print_step_timings, build.print_step_timings);\n         config.verbose = cmp::max(config.verbose, flags.verbose);\n \n         if let Some(ref install) = toml.install {\n             config.prefix = install.prefix.clone().map(PathBuf::from);\n             config.sysconfdir = install.sysconfdir.clone().map(PathBuf::from);\n+            config.datadir = install.datadir.clone().map(PathBuf::from);\n             config.docdir = install.docdir.clone().map(PathBuf::from);\n             config.bindir = install.bindir.clone().map(PathBuf::from);\n             config.libdir = install.libdir.clone().map(PathBuf::from);\n@@ -410,6 +481,7 @@ impl Config {\n         let mut llvm_assertions = None;\n         let mut debuginfo_lines = None;\n         let mut debuginfo_only_std = None;\n+        let mut debuginfo_tools = None;\n         let mut debug = None;\n         let mut debug_jemalloc = None;\n         let mut debuginfo = None;\n@@ -437,8 +509,9 @@ impl Config {\n             set(&mut config.llvm_link_shared, llvm.link_shared);\n             config.llvm_targets = llvm.targets.clone();\n             config.llvm_experimental_targets = llvm.experimental_targets.clone()\n-                .unwrap_or(\"WebAssembly\".to_string());\n+                .unwrap_or(\"WebAssembly;RISCV\".to_string());\n             config.llvm_link_jobs = llvm.link_jobs;\n+            config.llvm_clang_cl = llvm.clang_cl.clone();\n         }\n \n         if let Some(ref rust) = toml.rust {\n@@ -447,6 +520,7 @@ impl Config {\n             debuginfo = rust.debuginfo;\n             debuginfo_lines = rust.debuginfo_lines;\n             debuginfo_only_std = rust.debuginfo_only_std;\n+            debuginfo_tools = rust.debuginfo_tools;\n             optimize = rust.optimize;\n             ignore_git = rust.ignore_git;\n             debug_jemalloc = rust.debug_jemalloc;\n@@ -458,12 +532,31 @@ impl Config {\n             set(&mut config.backtrace, rust.backtrace);\n             set(&mut config.channel, rust.channel.clone());\n             set(&mut config.rust_dist_src, rust.dist_src);\n-            set(&mut config.quiet_tests, rust.quiet_tests);\n+            set(&mut config.verbose_tests, rust.verbose_tests);\n             set(&mut config.test_miri, rust.test_miri);\n+            // in the case \"false\" is set explicitly, do not overwrite the command line args\n+            if let Some(true) = rust.incremental {\n+                config.incremental = true;\n+            }\n+            set(&mut config.wasm_syscall, rust.wasm_syscall);\n+            set(&mut config.lld_enabled, rust.lld);\n+            set(&mut config.lldb_enabled, rust.lldb);\n+            set(&mut config.llvm_tools_enabled, rust.llvm_tools);\n             config.rustc_parallel_queries = rust.experimental_parallel_queries.unwrap_or(false);\n             config.rustc_default_linker = rust.default_linker.clone();\n             config.musl_root = rust.musl_root.clone().map(PathBuf::from);\n             config.save_toolstates = rust.save_toolstates.clone().map(PathBuf::from);\n+            set(&mut config.deny_warnings, rust.deny_warnings.or(flags.warnings));\n+            set(&mut config.backtrace_on_ice, rust.backtrace_on_ice);\n+            set(&mut config.rust_verify_llvm_ir, rust.verify_llvm_ir);\n+\n+            if let Some(ref backends) = rust.codegen_backends {\n+                config.rust_codegen_backends = backends.iter()\n+                    .map(|s| INTERNER.intern_str(s))\n+                    .collect();\n+            }\n+\n+            set(&mut config.rust_codegen_backends_dir, rust.codegen_backends_dir.clone());\n \n             match rust.codegen_units {\n                 Some(0) => config.rust_codegen_units = Some(num_cpus::get() as u32),\n@@ -477,13 +570,13 @@ impl Config {\n                 let mut target = Target::default();\n \n                 if let Some(ref s) = cfg.llvm_config {\n-                    target.llvm_config = Some(env::current_dir().unwrap().join(s));\n+                    target.llvm_config = Some(config.src.join(s));\n                 }\n                 if let Some(ref s) = cfg.jemalloc {\n-                    target.jemalloc = Some(env::current_dir().unwrap().join(s));\n+                    target.jemalloc = Some(config.src.join(s));\n                 }\n                 if let Some(ref s) = cfg.android_ndk {\n-                    target.ndk = Some(env::current_dir().unwrap().join(s));\n+                    target.ndk = Some(config.src.join(s));\n                 }\n                 target.cc = cfg.cc.clone().map(PathBuf::from);\n                 target.cxx = cfg.cxx.clone().map(PathBuf::from);\n@@ -504,22 +597,12 @@ impl Config {\n             set(&mut config.rust_dist_src, t.src_tarball);\n         }\n \n-        let cwd = t!(env::current_dir());\n-        let out = cwd.join(\"build\");\n-\n-        let stage0_root = out.join(&config.build).join(\"stage0/bin\");\n-        config.initial_rustc = match build.rustc {\n-            Some(s) => PathBuf::from(s),\n-            None => stage0_root.join(exe(\"rustc\", &config.build)),\n-        };\n-        config.initial_cargo = match build.cargo {\n-            Some(s) => PathBuf::from(s),\n-            None => stage0_root.join(exe(\"cargo\", &config.build)),\n-        };\n-\n         // Now that we've reached the end of our configuration, infer the\n         // default values for all options that we haven't otherwise stored yet.\n \n+        set(&mut config.initial_rustc, build.rustc.map(PathBuf::from));\n+        set(&mut config.initial_cargo, build.cargo.map(PathBuf::from));\n+\n         let default = false;\n         config.llvm_assertions = llvm_assertions.unwrap_or(default);\n \n@@ -529,6 +612,7 @@ impl Config {\n         };\n         config.rust_debuginfo_lines = debuginfo_lines.unwrap_or(default);\n         config.rust_debuginfo_only_std = debuginfo_only_std.unwrap_or(default);\n+        config.rust_debuginfo_tools = debuginfo_tools.unwrap_or(false);\n \n         let default = debug == Some(true);\n         config.debug_jemalloc = debug_jemalloc.unwrap_or(default);\n@@ -542,6 +626,17 @@ impl Config {\n         config\n     }\n \n+    /// Try to find the relative path of `libdir`.\n+    pub fn libdir_relative(&self) -> Option<&Path> {\n+        let libdir = self.libdir.as_ref()?;\n+        if libdir.is_relative() {\n+            Some(libdir)\n+        } else {\n+            // Try to make it relative to the prefix.\n+            libdir.strip_prefix(self.prefix.as_ref()?).ok()\n+        }\n+    }\n+\n     pub fn verbose(&self) -> bool {\n         self.verbose > 0\n     }"}, {"sha": "cf7f78eeba04b13b16e3d64de41efd7609c1f8ca", "filename": "src/bootstrap/configure.py", "status": "modified", "additions": 25, "deletions": 4, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fbootstrap%2Fconfigure.py", "raw_url": "https://github.com/rust-lang/rust/raw/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fbootstrap%2Fconfigure.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfigure.py?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd", "patch": "@@ -44,9 +44,10 @@ def v(*args):\n o(\"docs\", \"build.docs\", \"build standard library documentation\")\n o(\"compiler-docs\", \"build.compiler-docs\", \"build compiler documentation\")\n o(\"optimize-tests\", \"rust.optimize-tests\", \"build tests with optimizations\")\n+o(\"experimental-parallel-queries\", \"rust.experimental-parallel-queries\", \"build rustc with experimental parallelization\")\n o(\"test-miri\", \"rust.test-miri\", \"run miri's test suite\")\n o(\"debuginfo-tests\", \"rust.debuginfo-tests\", \"build tests with debugger metadata\")\n-o(\"quiet-tests\", \"rust.quiet-tests\", \"enable quieter output when running tests\")\n+o(\"verbose-tests\", \"rust.verbose-tests\", \"enable verbose output when running tests\")\n o(\"ccache\", \"llvm.ccache\", \"invoke gcc/clang via ccache to reuse object files between builds\")\n o(\"sccache\", None, \"invoke gcc/clang via sccache to reuse object files between builds\")\n o(\"local-rust\", None, \"use an installed rustc rather than downloading a snapshot\")\n@@ -65,6 +66,9 @@ def v(*args):\n o(\"dist-src\", \"rust.dist-src\", \"when building tarballs enables building a source tarball\")\n o(\"cargo-openssl-static\", \"build.openssl-static\", \"static openssl in cargo\")\n o(\"profiler\", \"build.profiler\", \"build the profiler runtime\")\n+o(\"emscripten\", None, \"compile the emscripten backend as well as LLVM\")\n+o(\"full-tools\", None, \"enable all tools\")\n+o(\"lldb\", \"rust.lldb\", \"build lldb\")\n \n # Optimization and debugging options. These may be overridden by the release\n # channel, etc.\n@@ -76,6 +80,7 @@ def v(*args):\n o(\"debuginfo\", \"rust.debuginfo\", \"build with debugger metadata\")\n o(\"debuginfo-lines\", \"rust.debuginfo-lines\", \"build with line number debugger metadata\")\n o(\"debuginfo-only-std\", \"rust.debuginfo-only-std\", \"build only libstd with debugging information\")\n+o(\"debuginfo-tools\", \"rust.debuginfo-tools\", \"build extended tools with debugging information\")\n o(\"debug-jemalloc\", \"rust.debug-jemalloc\", \"build jemalloc with --enable-debug --enable-fill\")\n v(\"save-toolstates\", \"rust.save-toolstates\", \"save build and test status of external tools into this file\")\n \n@@ -116,10 +121,16 @@ def v(*args):\n   \"arm-unknown-linux-musleabi install directory\")\n v(\"musl-root-armhf\", \"target.arm-unknown-linux-musleabihf.musl-root\",\n   \"arm-unknown-linux-musleabihf install directory\")\n+v(\"musl-root-armv5te\", \"target.armv5te-unknown-linux-musleabi.musl-root\",\n+  \"armv5te-unknown-linux-musleabi install directory\")\n v(\"musl-root-armv7\", \"target.armv7-unknown-linux-musleabihf.musl-root\",\n   \"armv7-unknown-linux-musleabihf install directory\")\n v(\"musl-root-aarch64\", \"target.aarch64-unknown-linux-musl.musl-root\",\n   \"aarch64-unknown-linux-musl install directory\")\n+v(\"musl-root-mips\", \"target.mips-unknown-linux-musl.musl-root\",\n+  \"mips-unknown-linux-musl install directory\")\n+v(\"musl-root-mipsel\", \"target.mipsel-unknown-linux-musl.musl-root\",\n+  \"mipsel-unknown-linux-musl install directory\")\n v(\"qemu-armhf-rootfs\", \"target.arm-unknown-linux-gnueabihf.qemu-rootfs\",\n   \"rootfs in qemu testing, you probably don't want to use this\")\n v(\"qemu-aarch64-rootfs\", \"target.aarch64-unknown-linux-gnu.qemu-rootfs\",\n@@ -138,6 +149,7 @@ def v(*args):\n o(\"full-bootstrap\", \"build.full-bootstrap\", \"build three compilers instead of two\")\n o(\"extended\", \"build.extended\", \"build an extended rust tool set\")\n \n+v(\"tools\", None, \"List of extended tools will be installed\")\n v(\"build\", \"build.build\", \"GNUs ./configure syntax LLVM build triple\")\n v(\"host\", None, \"GNUs ./configure syntax LLVM host triples\")\n v(\"target\", None, \"GNUs ./configure syntax LLVM target triples\")\n@@ -313,10 +325,19 @@ def set(key, value):\n         set('target.{}.llvm-config'.format(build()), value + '/bin/llvm-config')\n     elif option.name == 'jemalloc-root':\n         set('target.{}.jemalloc'.format(build()), value + '/libjemalloc_pic.a')\n+    elif option.name == 'tools':\n+        set('build.tools', value.split(','))\n     elif option.name == 'host':\n         set('build.host', value.split(','))\n     elif option.name == 'target':\n         set('build.target', value.split(','))\n+    elif option.name == 'emscripten':\n+        set('rust.codegen-backends', ['llvm', 'emscripten'])\n+    elif option.name == 'full-tools':\n+        set('rust.codegen-backends', ['llvm', 'emscripten'])\n+        set('rust.lld', True)\n+        set('rust.llvm-tools', True)\n+        set('build.extended', True)\n     elif option.name == 'option-checking':\n         # this was handled above\n         pass\n@@ -330,7 +351,7 @@ def set(key, value):\n # all the various comments and whatnot.\n #\n # Note that the `target` section is handled separately as we'll duplicate it\n-# per configure dtarget, so there's a bit of special handling for that here.\n+# per configured target, so there's a bit of special handling for that here.\n sections = {}\n cur_section = None\n sections[None] = []\n@@ -412,7 +433,7 @@ def configure_section(lines, config):\n # order that we read it in.\n p(\"\")\n p(\"writing `config.toml` in current directory\")\n-with open('config.toml', 'w') as f:\n+with bootstrap.output('config.toml') as f:\n     for section in section_order:\n         if section == 'target':\n             for target in targets:\n@@ -422,7 +443,7 @@ def configure_section(lines, config):\n             for line in sections[section]:\n                 f.write(line + \"\\n\")\n \n-with open('Makefile', 'w') as f:\n+with bootstrap.output('Makefile') as f:\n     contents = os.path.join(rust_dir, 'src', 'bootstrap', 'mk', 'Makefile.in')\n     contents = open(contents).read()\n     contents = contents.replace(\"$(CFG_SRC_DIR)\", rust_dir + '/')"}, {"sha": "6e473fae3be5c0208279c662f12e0ead34e9bca1", "filename": "src/bootstrap/dist.rs", "status": "modified", "additions": 755, "deletions": 395, "changes": 1150, "blob_url": "https://github.com/rust-lang/rust/blob/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fbootstrap%2Fdist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fbootstrap%2Fdist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdist.rs?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd", "patch": "@@ -20,46 +20,54 @@\n \n use std::env;\n use std::fs::{self, File};\n-use std::io::{self, Read, Write};\n+use std::io::{Read, Write};\n use std::path::{PathBuf, Path};\n use std::process::{Command, Stdio};\n \n use build_helper::output;\n \n-use {Build, Compiler, Mode};\n+use {Compiler, Mode, LLVM_TOOLS};\n use channel;\n-use util::{cp_r, libdir, is_dylib, cp_filtered, copy, replace_in_file};\n+use util::{libdir, is_dylib, exe};\n use builder::{Builder, RunConfig, ShouldRun, Step};\n use compile;\n+use native;\n use tool::{self, Tool};\n use cache::{INTERNER, Interned};\n+use time;\n \n-pub fn pkgname(build: &Build, component: &str) -> String {\n+pub fn pkgname(builder: &Builder, component: &str) -> String {\n     if component == \"cargo\" {\n-        format!(\"{}-{}\", component, build.cargo_package_vers())\n+        format!(\"{}-{}\", component, builder.cargo_package_vers())\n     } else if component == \"rls\" {\n-        format!(\"{}-{}\", component, build.rls_package_vers())\n+        format!(\"{}-{}\", component, builder.rls_package_vers())\n+    } else if component == \"clippy\" {\n+        format!(\"{}-{}\", component, builder.clippy_package_vers())\n     } else if component == \"rustfmt\" {\n-        format!(\"{}-{}\", component, build.rustfmt_package_vers())\n+        format!(\"{}-{}\", component, builder.rustfmt_package_vers())\n+    } else if component == \"llvm-tools\" {\n+        format!(\"{}-{}\", component, builder.llvm_tools_package_vers())\n+    } else if component == \"lldb\" {\n+        format!(\"{}-{}\", component, builder.lldb_package_vers())\n     } else {\n         assert!(component.starts_with(\"rust\"));\n-        format!(\"{}-{}\", component, build.rust_package_vers())\n+        format!(\"{}-{}\", component, builder.rust_package_vers())\n     }\n }\n \n-fn distdir(build: &Build) -> PathBuf {\n-    build.out.join(\"dist\")\n+fn distdir(builder: &Builder) -> PathBuf {\n+    builder.out.join(\"dist\")\n }\n \n-pub fn tmpdir(build: &Build) -> PathBuf {\n-    build.out.join(\"tmp/dist\")\n+pub fn tmpdir(builder: &Builder) -> PathBuf {\n+    builder.out.join(\"tmp/dist\")\n }\n \n fn rust_installer(builder: &Builder) -> Command {\n     builder.tool_cmd(Tool::RustInstaller)\n }\n \n-#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n+#[derive(Debug, PartialOrd, Ord, Copy, Clone, Hash, PartialEq, Eq)]\n pub struct Docs {\n     pub stage: u32,\n     pub host: Interned<String>,\n@@ -68,7 +76,6 @@ pub struct Docs {\n impl Step for Docs {\n     type Output = PathBuf;\n     const DEFAULT: bool = true;\n-    const ONLY_BUILD_TARGETS: bool = true;\n \n     fn should_run(run: ShouldRun) -> ShouldRun {\n         run.path(\"src/doc\")\n@@ -83,51 +90,104 @@ impl Step for Docs {\n \n     /// Builds the `rust-docs` installer component.\n     fn run(self, builder: &Builder) -> PathBuf {\n-        let build = builder.build;\n         let host = self.host;\n \n-        let name = pkgname(build, \"rust-docs\");\n+        let name = pkgname(builder, \"rust-docs\");\n \n-        println!(\"Dist docs ({})\", host);\n-        if !build.config.docs {\n-            println!(\"\\tskipping - docs disabled\");\n-            return distdir(build).join(format!(\"{}-{}.tar.gz\", name, host));\n+        builder.info(&format!(\"Dist docs ({})\", host));\n+        if !builder.config.docs {\n+            builder.info(\"\\tskipping - docs disabled\");\n+            return distdir(builder).join(format!(\"{}-{}.tar.gz\", name, host));\n         }\n \n         builder.default_doc(None);\n \n-        let image = tmpdir(build).join(format!(\"{}-{}-image\", name, host));\n+        let image = tmpdir(builder).join(format!(\"{}-{}-image\", name, host));\n         let _ = fs::remove_dir_all(&image);\n \n         let dst = image.join(\"share/doc/rust/html\");\n         t!(fs::create_dir_all(&dst));\n-        let src = build.out.join(host).join(\"doc\");\n-        cp_r(&src, &dst);\n+        let src = builder.doc_out(host);\n+        builder.cp_r(&src, &dst);\n \n         let mut cmd = rust_installer(builder);\n         cmd.arg(\"generate\")\n            .arg(\"--product-name=Rust-Documentation\")\n            .arg(\"--rel-manifest-dir=rustlib\")\n            .arg(\"--success-message=Rust-documentation-is-installed.\")\n            .arg(\"--image-dir\").arg(&image)\n-           .arg(\"--work-dir\").arg(&tmpdir(build))\n-           .arg(\"--output-dir\").arg(&distdir(build))\n+           .arg(\"--work-dir\").arg(&tmpdir(builder))\n+           .arg(\"--output-dir\").arg(&distdir(builder))\n            .arg(format!(\"--package-name={}-{}\", name, host))\n            .arg(\"--component-name=rust-docs\")\n            .arg(\"--legacy-manifest-dirs=rustlib,cargo\")\n            .arg(\"--bulk-dirs=share/doc/rust/html\");\n-        build.run(&mut cmd);\n-        t!(fs::remove_dir_all(&image));\n+        builder.run(&mut cmd);\n+        builder.remove_dir(&image);\n \n-        // As part of this step, *also* copy the docs directory to a directory which\n-        // buildbot typically uploads.\n-        if host == build.build {\n-            let dst = distdir(build).join(\"doc\").join(build.rust_package_vers());\n-            t!(fs::create_dir_all(&dst));\n-            cp_r(&src, &dst);\n+        distdir(builder).join(format!(\"{}-{}.tar.gz\", name, host))\n+    }\n+}\n+\n+#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n+pub struct RustcDocs {\n+    pub stage: u32,\n+    pub host: Interned<String>,\n+}\n+\n+impl Step for RustcDocs {\n+    type Output = PathBuf;\n+    const DEFAULT: bool = true;\n+\n+    fn should_run(run: ShouldRun) -> ShouldRun {\n+        run.path(\"src/librustc\")\n+    }\n+\n+    fn make_run(run: RunConfig) {\n+        run.builder.ensure(RustcDocs {\n+            stage: run.builder.top_stage,\n+            host: run.target,\n+        });\n+    }\n+\n+    /// Builds the `rustc-docs` installer component.\n+    fn run(self, builder: &Builder) -> PathBuf {\n+        let host = self.host;\n+\n+        let name = pkgname(builder, \"rustc-docs\");\n+\n+        builder.info(&format!(\"Dist compiler docs ({})\", host));\n+        if !builder.config.compiler_docs {\n+            builder.info(\"\\tskipping - compiler docs disabled\");\n+            return distdir(builder).join(format!(\"{}-{}.tar.gz\", name, host));\n         }\n \n-        distdir(build).join(format!(\"{}-{}.tar.gz\", name, host))\n+        builder.default_doc(None);\n+\n+        let image = tmpdir(builder).join(format!(\"{}-{}-image\", name, host));\n+        let _ = fs::remove_dir_all(&image);\n+\n+        let dst = image.join(\"share/doc/rust/html\");\n+        t!(fs::create_dir_all(&dst));\n+        let src = builder.compiler_doc_out(host);\n+        builder.cp_r(&src, &dst);\n+\n+        let mut cmd = rust_installer(builder);\n+        cmd.arg(\"generate\")\n+           .arg(\"--product-name=Rustc-Documentation\")\n+           .arg(\"--rel-manifest-dir=rustlib\")\n+           .arg(\"--success-message=Rustc-documentation-is-installed.\")\n+           .arg(\"--image-dir\").arg(&image)\n+           .arg(\"--work-dir\").arg(&tmpdir(builder))\n+           .arg(\"--output-dir\").arg(&distdir(builder))\n+           .arg(format!(\"--package-name={}-{}\", name, host))\n+           .arg(\"--component-name=rustc-docs\")\n+           .arg(\"--legacy-manifest-dirs=rustlib,cargo\")\n+           .arg(\"--bulk-dirs=share/doc/rust/html\");\n+        builder.run(&mut cmd);\n+        builder.remove_dir(&image);\n+\n+        distdir(builder).join(format!(\"{}-{}.tar.gz\", name, host))\n     }\n }\n \n@@ -151,10 +211,10 @@ fn find_files(files: &[&str], path: &[PathBuf]) -> Vec<PathBuf> {\n }\n \n fn make_win_dist(\n-    rust_root: &Path, plat_root: &Path, target_triple: Interned<String>, build: &Build\n+    rust_root: &Path, plat_root: &Path, target_triple: Interned<String>, builder: &Builder\n ) {\n     //Ask gcc where it keeps its stuff\n-    let mut cmd = Command::new(build.cc(target_triple));\n+    let mut cmd = Command::new(builder.cc(target_triple));\n     cmd.arg(\"-print-search-dirs\");\n     let gcc_out = output(&mut cmd);\n \n@@ -202,20 +262,25 @@ fn make_win_dist(\n         \"libbcrypt.a\",\n         \"libcomctl32.a\",\n         \"libcomdlg32.a\",\n+        \"libcredui.a\",\n         \"libcrypt32.a\",\n+        \"libdbghelp.a\",\n         \"libgdi32.a\",\n         \"libimagehlp.a\",\n         \"libiphlpapi.a\",\n         \"libkernel32.a\",\n+        \"libmsimg32.a\",\n         \"libmsvcrt.a\",\n         \"libodbc32.a\",\n         \"libole32.a\",\n         \"liboleaut32.a\",\n         \"libopengl32.a\",\n         \"libpsapi.a\",\n         \"librpcrt4.a\",\n+        \"libsecur32.a\",\n         \"libsetupapi.a\",\n         \"libshell32.a\",\n+        \"libsynchronization.a\",\n         \"libuser32.a\",\n         \"libuserenv.a\",\n         \"libuuid.a\",\n@@ -231,43 +296,44 @@ fn make_win_dist(\n     let rustc_dlls = find_files(&rustc_dlls, &bin_path);\n     let target_libs = find_files(&target_libs, &lib_path);\n \n-    fn copy_to_folder(src: &Path, dest_folder: &Path) {\n-        let file_name = src.file_name().unwrap();\n-        let dest = dest_folder.join(file_name);\n-        copy(src, &dest);\n-    }\n-\n-    //Copy runtime dlls next to rustc.exe\n+    // Copy runtime dlls next to rustc.exe\n     let dist_bin_dir = rust_root.join(\"bin/\");\n     fs::create_dir_all(&dist_bin_dir).expect(\"creating dist_bin_dir failed\");\n     for src in rustc_dlls {\n-        copy_to_folder(&src, &dist_bin_dir);\n+        builder.copy_to_folder(&src, &dist_bin_dir);\n     }\n \n     //Copy platform tools to platform-specific bin directory\n     let target_bin_dir = plat_root.join(\"lib\").join(\"rustlib\").join(target_triple).join(\"bin\");\n     fs::create_dir_all(&target_bin_dir).expect(\"creating target_bin_dir failed\");\n     for src in target_tools {\n-        copy_to_folder(&src, &target_bin_dir);\n+        builder.copy_to_folder(&src, &target_bin_dir);\n     }\n \n+    // Warn windows-gnu users that the bundled GCC cannot compile C files\n+    builder.create(\n+        &target_bin_dir.join(\"GCC-WARNING.txt\"),\n+        \"gcc.exe contained in this folder cannot be used for compiling C files - it is only\\\n+         used as a linker. In order to be able to compile projects containing C code use\\\n+         the GCC provided by MinGW or Cygwin.\"\n+    );\n+\n     //Copy platform libs to platform-specific lib directory\n     let target_lib_dir = plat_root.join(\"lib\").join(\"rustlib\").join(target_triple).join(\"lib\");\n     fs::create_dir_all(&target_lib_dir).expect(\"creating target_lib_dir failed\");\n     for src in target_libs {\n-        copy_to_folder(&src, &target_lib_dir);\n+        builder.copy_to_folder(&src, &target_lib_dir);\n     }\n }\n \n-#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n+#[derive(Debug, PartialOrd, Ord, Copy, Clone, Hash, PartialEq, Eq)]\n pub struct Mingw {\n-    host: Interned<String>,\n+    pub host: Interned<String>,\n }\n \n impl Step for Mingw {\n     type Output = Option<PathBuf>;\n     const DEFAULT: bool = true;\n-    const ONLY_BUILD_TARGETS: bool = true;\n \n     fn should_run(run: ShouldRun) -> ShouldRun {\n         run.never()\n@@ -282,43 +348,42 @@ impl Step for Mingw {\n     /// This contains all the bits and pieces to run the MinGW Windows targets\n     /// without any extra installed software (e.g. we bundle gcc, libraries, etc).\n     fn run(self, builder: &Builder) -> Option<PathBuf> {\n-        let build = builder.build;\n         let host = self.host;\n \n         if !host.contains(\"pc-windows-gnu\") {\n             return None;\n         }\n \n-        println!(\"Dist mingw ({})\", host);\n-        let name = pkgname(build, \"rust-mingw\");\n-        let image = tmpdir(build).join(format!(\"{}-{}-image\", name, host));\n+        builder.info(&format!(\"Dist mingw ({})\", host));\n+        let name = pkgname(builder, \"rust-mingw\");\n+        let image = tmpdir(builder).join(format!(\"{}-{}-image\", name, host));\n         let _ = fs::remove_dir_all(&image);\n         t!(fs::create_dir_all(&image));\n \n         // The first argument is a \"temporary directory\" which is just\n         // thrown away (this contains the runtime DLLs included in the rustc package\n         // above) and the second argument is where to place all the MinGW components\n         // (which is what we want).\n-        make_win_dist(&tmpdir(build), &image, host, &build);\n+        make_win_dist(&tmpdir(builder), &image, host, &builder);\n \n         let mut cmd = rust_installer(builder);\n         cmd.arg(\"generate\")\n            .arg(\"--product-name=Rust-MinGW\")\n            .arg(\"--rel-manifest-dir=rustlib\")\n            .arg(\"--success-message=Rust-MinGW-is-installed.\")\n            .arg(\"--image-dir\").arg(&image)\n-           .arg(\"--work-dir\").arg(&tmpdir(build))\n-           .arg(\"--output-dir\").arg(&distdir(build))\n+           .arg(\"--work-dir\").arg(&tmpdir(builder))\n+           .arg(\"--output-dir\").arg(&distdir(builder))\n            .arg(format!(\"--package-name={}-{}\", name, host))\n            .arg(\"--component-name=rust-mingw\")\n            .arg(\"--legacy-manifest-dirs=rustlib,cargo\");\n-        build.run(&mut cmd);\n+        builder.run(&mut cmd);\n         t!(fs::remove_dir_all(&image));\n-        Some(distdir(build).join(format!(\"{}-{}.tar.gz\", name, host)))\n+        Some(distdir(builder).join(format!(\"{}-{}.tar.gz\", name, host)))\n     }\n }\n \n-#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n+#[derive(Debug, PartialOrd, Ord, Copy, Clone, Hash, PartialEq, Eq)]\n pub struct Rustc {\n     pub compiler: Compiler,\n }\n@@ -327,7 +392,6 @@ impl Step for Rustc {\n     type Output = PathBuf;\n     const DEFAULT: bool = true;\n     const ONLY_HOSTS: bool = true;\n-    const ONLY_BUILD_TARGETS: bool = true;\n \n     fn should_run(run: ShouldRun) -> ShouldRun {\n         run.path(\"src/librustc\")\n@@ -341,15 +405,14 @@ impl Step for Rustc {\n \n     /// Creates the `rustc` installer component.\n     fn run(self, builder: &Builder) -> PathBuf {\n-        let build = builder.build;\n         let compiler = self.compiler;\n         let host = self.compiler.host;\n \n-        println!(\"Dist rustc stage{} ({})\", compiler.stage, compiler.host);\n-        let name = pkgname(build, \"rustc\");\n-        let image = tmpdir(build).join(format!(\"{}-{}-image\", name, host));\n+        builder.info(&format!(\"Dist rustc stage{} ({})\", compiler.stage, host));\n+        let name = pkgname(builder, \"rustc\");\n+        let image = tmpdir(builder).join(format!(\"{}-{}-image\", name, host));\n         let _ = fs::remove_dir_all(&image);\n-        let overlay = tmpdir(build).join(format!(\"{}-{}-overlay\", name, host));\n+        let overlay = tmpdir(builder).join(format!(\"{}-{}-overlay\", name, host));\n         let _ = fs::remove_dir_all(&overlay);\n \n         // Prepare the rustc \"image\", what will actually end up getting installed\n@@ -358,17 +421,17 @@ impl Step for Rustc {\n         // Prepare the overlay which is part of the tarball but won't actually be\n         // installed\n         let cp = |file: &str| {\n-            install(&build.src.join(file), &overlay, 0o644);\n+            builder.install(&builder.src.join(file), &overlay, 0o644);\n         };\n         cp(\"COPYRIGHT\");\n         cp(\"LICENSE-APACHE\");\n         cp(\"LICENSE-MIT\");\n         cp(\"README.md\");\n         // tiny morsel of metadata is used by rust-packaging\n-        let version = build.rust_version();\n-        t!(t!(File::create(overlay.join(\"version\"))).write_all(version.as_bytes()));\n-        if let Some(sha) = build.rust_sha() {\n-            t!(t!(File::create(overlay.join(\"git-commit-hash\"))).write_all(sha.as_bytes()));\n+        let version = builder.rust_version();\n+        builder.create(&overlay.join(\"version\"), &version);\n+        if let Some(sha) = builder.rust_sha() {\n+            builder.create(&overlay.join(\"git-commit-hash\"), &sha);\n         }\n \n         // On MinGW we've got a few runtime DLL dependencies that we need to\n@@ -382,11 +445,11 @@ impl Step for Rustc {\n         // install will *also* include the rust-mingw package, which also needs\n         // licenses, so to be safe we just include it here in all MinGW packages.\n         if host.contains(\"pc-windows-gnu\") {\n-            make_win_dist(&image, &tmpdir(build), host, build);\n+            make_win_dist(&image, &tmpdir(builder), host, builder);\n \n             let dst = image.join(\"share/doc\");\n             t!(fs::create_dir_all(&dst));\n-            cp_r(&build.src.join(\"src/etc/third-party\"), &dst);\n+            builder.cp_r(&builder.src.join(\"src/etc/third-party\"), &dst);\n         }\n \n         // Finally, wrap everything up in a nice tarball!\n@@ -396,58 +459,79 @@ impl Step for Rustc {\n            .arg(\"--rel-manifest-dir=rustlib\")\n            .arg(\"--success-message=Rust-is-ready-to-roll.\")\n            .arg(\"--image-dir\").arg(&image)\n-           .arg(\"--work-dir\").arg(&tmpdir(build))\n-           .arg(\"--output-dir\").arg(&distdir(build))\n+           .arg(\"--work-dir\").arg(&tmpdir(builder))\n+           .arg(\"--output-dir\").arg(&distdir(builder))\n            .arg(\"--non-installed-overlay\").arg(&overlay)\n            .arg(format!(\"--package-name={}-{}\", name, host))\n            .arg(\"--component-name=rustc\")\n            .arg(\"--legacy-manifest-dirs=rustlib,cargo\");\n-        build.run(&mut cmd);\n-        t!(fs::remove_dir_all(&image));\n-        t!(fs::remove_dir_all(&overlay));\n+        builder.run(&mut cmd);\n+        builder.remove_dir(&image);\n+        builder.remove_dir(&overlay);\n \n-        return distdir(build).join(format!(\"{}-{}.tar.gz\", name, host));\n+        return distdir(builder).join(format!(\"{}-{}.tar.gz\", name, host));\n \n         fn prepare_image(builder: &Builder, compiler: Compiler, image: &Path) {\n             let host = compiler.host;\n-            let build = builder.build;\n             let src = builder.sysroot(compiler);\n             let libdir = libdir(&host);\n \n             // Copy rustc/rustdoc binaries\n             t!(fs::create_dir_all(image.join(\"bin\")));\n-            cp_r(&src.join(\"bin\"), &image.join(\"bin\"));\n+            builder.cp_r(&src.join(\"bin\"), &image.join(\"bin\"));\n \n-            install(&builder.rustdoc(compiler.host), &image.join(\"bin\"), 0o755);\n+            builder.install(&builder.rustdoc(compiler.host), &image.join(\"bin\"), 0o755);\n \n             // Copy runtime DLLs needed by the compiler\n             if libdir != \"bin\" {\n-                for entry in t!(src.join(libdir).read_dir()).map(|e| t!(e)) {\n+                for entry in builder.read_dir(&src.join(libdir)) {\n                     let name = entry.file_name();\n                     if let Some(s) = name.to_str() {\n                         if is_dylib(s) {\n-                            install(&entry.path(), &image.join(libdir), 0o644);\n+                            builder.install(&entry.path(), &image.join(libdir), 0o644);\n                         }\n                     }\n                 }\n             }\n \n+            // Copy over the codegen backends\n+            let backends_src = builder.sysroot_codegen_backends(compiler);\n+            let backends_rel = backends_src.strip_prefix(&src).unwrap();\n+            let backends_dst = image.join(&backends_rel);\n+            t!(fs::create_dir_all(&backends_dst));\n+            builder.cp_r(&backends_src, &backends_dst);\n+\n+            // Copy over lld if it's there\n+            if builder.config.lld_enabled {\n+                let exe = exe(\"rust-lld\", &compiler.host);\n+                let src = builder.sysroot_libdir(compiler, host)\n+                    .parent()\n+                    .unwrap()\n+                    .join(\"bin\")\n+                    .join(&exe);\n+                // for the rationale about this rename check `compile::copy_lld_to_sysroot`\n+                let dst = image.join(\"lib/rustlib\")\n+                    .join(&*host)\n+                    .join(\"bin\")\n+                    .join(&exe);\n+                t!(fs::create_dir_all(&dst.parent().unwrap()));\n+                builder.copy(&src, &dst);\n+            }\n+\n             // Man pages\n             t!(fs::create_dir_all(image.join(\"share/man/man1\")));\n-            let man_src = build.src.join(\"src/doc/man\");\n+            let man_src = builder.src.join(\"src/doc/man\");\n             let man_dst = image.join(\"share/man/man1\");\n-            let date_output = output(Command::new(\"date\").arg(\"+%B %Y\"));\n-            let month_year = date_output.trim();\n+            let month_year = t!(time::strftime(\"%B %Y\", &time::now()));\n             // don't use our `bootstrap::util::{copy, cp_r}`, because those try\n             // to hardlink, and we don't want to edit the source templates\n-            for entry_result in t!(fs::read_dir(man_src)) {\n-                let file_entry = t!(entry_result);\n+            for file_entry in builder.read_dir(&man_src) {\n                 let page_src = file_entry.path();\n                 let page_dst = man_dst.join(file_entry.file_name());\n                 t!(fs::copy(&page_src, &page_dst));\n                 // template in month/year and version number\n-                replace_in_file(&page_dst,\n-                                &[(\"<INSERT DATE HERE>\", month_year),\n+                builder.replace_in_file(&page_dst,\n+                                &[(\"<INSERT DATE HERE>\", &month_year),\n                                   (\"<INSERT VERSION HERE>\", channel::CFG_RELEASE_NUM)]);\n             }\n \n@@ -459,7 +543,7 @@ impl Step for Rustc {\n \n             // Misc license info\n             let cp = |file: &str| {\n-                install(&build.src.join(file), &image.join(\"share/doc/rust\"), 0o644);\n+                builder.install(&builder.src.join(file), &image.join(\"share/doc/rust\"), 0o644);\n             };\n             cp(\"COPYRIGHT\");\n             cp(\"LICENSE-APACHE\");\n@@ -491,17 +575,16 @@ impl Step for DebuggerScripts {\n \n     /// Copies debugger scripts for `target` into the `sysroot` specified.\n     fn run(self, builder: &Builder) {\n-        let build = builder.build;\n         let host = self.host;\n         let sysroot = self.sysroot;\n         let dst = sysroot.join(\"lib/rustlib/etc\");\n         t!(fs::create_dir_all(&dst));\n         let cp_debugger_script = |file: &str| {\n-            install(&build.src.join(\"src/etc/\").join(file), &dst, 0o644);\n+            builder.install(&builder.src.join(\"src/etc/\").join(file), &dst, 0o644);\n         };\n         if host.contains(\"windows-msvc\") {\n             // windbg debugger scripts\n-            install(&build.src.join(\"src/etc/rust-windbg.cmd\"), &sysroot.join(\"bin\"),\n+            builder.install(&builder.src.join(\"src/etc/rust-windbg.cmd\"), &sysroot.join(\"bin\"),\n                 0o755);\n \n             cp_debugger_script(\"natvis/intrinsic.natvis\");\n@@ -511,22 +594,22 @@ impl Step for DebuggerScripts {\n             cp_debugger_script(\"debugger_pretty_printers_common.py\");\n \n             // gdb debugger scripts\n-            install(&build.src.join(\"src/etc/rust-gdb\"), &sysroot.join(\"bin\"),\n+            builder.install(&builder.src.join(\"src/etc/rust-gdb\"), &sysroot.join(\"bin\"),\n                     0o755);\n \n             cp_debugger_script(\"gdb_load_rust_pretty_printers.py\");\n             cp_debugger_script(\"gdb_rust_pretty_printing.py\");\n \n             // lldb debugger scripts\n-            install(&build.src.join(\"src/etc/rust-lldb\"), &sysroot.join(\"bin\"),\n+            builder.install(&builder.src.join(\"src/etc/rust-lldb\"), &sysroot.join(\"bin\"),\n                     0o755);\n \n             cp_debugger_script(\"lldb_rust_formatters.py\");\n         }\n     }\n }\n \n-#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n+#[derive(Debug, PartialOrd, Ord, Copy, Clone, Hash, PartialEq, Eq)]\n pub struct Std {\n     pub compiler: Compiler,\n     pub target: Interned<String>,\n@@ -535,66 +618,75 @@ pub struct Std {\n impl Step for Std {\n     type Output = PathBuf;\n     const DEFAULT: bool = true;\n-    const ONLY_BUILD_TARGETS: bool = true;\n \n     fn should_run(run: ShouldRun) -> ShouldRun {\n         run.path(\"src/libstd\")\n     }\n \n     fn make_run(run: RunConfig) {\n         run.builder.ensure(Std {\n-            compiler: run.builder.compiler(run.builder.top_stage, run.host),\n+            compiler: run.builder.compiler(run.builder.top_stage, run.builder.config.build),\n             target: run.target,\n         });\n     }\n \n     fn run(self, builder: &Builder) -> PathBuf {\n-        let build = builder.build;\n         let compiler = self.compiler;\n         let target = self.target;\n \n-        let name = pkgname(build, \"rust-std\");\n-        println!(\"Dist std stage{} ({} -> {})\", compiler.stage, &compiler.host, target);\n+        let name = pkgname(builder, \"rust-std\");\n+        builder.info(&format!(\"Dist std stage{} ({} -> {})\",\n+            compiler.stage, &compiler.host, target));\n \n         // The only true set of target libraries came from the build triple, so\n         // let's reduce redundant work by only producing archives from that host.\n-        if compiler.host != build.build {\n-            println!(\"\\tskipping, not a build host\");\n-            return distdir(build).join(format!(\"{}-{}.tar.gz\", name, target));\n+        if compiler.host != builder.config.build {\n+            builder.info(\"\\tskipping, not a build host\");\n+            return distdir(builder).join(format!(\"{}-{}.tar.gz\", name, target));\n         }\n \n         // We want to package up as many target libraries as possible\n         // for the `rust-std` package, so if this is a host target we\n         // depend on librustc and otherwise we just depend on libtest.\n-        if build.hosts.iter().any(|t| t == target) {\n+        if builder.hosts.iter().any(|t| t == target) {\n             builder.ensure(compile::Rustc { compiler, target });\n         } else {\n-            builder.ensure(compile::Test { compiler, target });\n+            if builder.no_std(target) == Some(true) {\n+                // the `test` doesn't compile for no-std targets\n+                builder.ensure(compile::Std { compiler, target });\n+            } else {\n+                builder.ensure(compile::Test { compiler, target });\n+            }\n         }\n \n-        let image = tmpdir(build).join(format!(\"{}-{}-image\", name, target));\n+        let image = tmpdir(builder).join(format!(\"{}-{}-image\", name, target));\n         let _ = fs::remove_dir_all(&image);\n \n         let dst = image.join(\"lib/rustlib\").join(target);\n         t!(fs::create_dir_all(&dst));\n         let mut src = builder.sysroot_libdir(compiler, target).to_path_buf();\n         src.pop(); // Remove the trailing /lib folder from the sysroot_libdir\n-        cp_r(&src, &dst);\n+        builder.cp_filtered(&src, &dst, &|path| {\n+            let name = path.file_name().and_then(|s| s.to_str());\n+            name != Some(builder.config.rust_codegen_backends_dir.as_str()) &&\n+                name != Some(\"bin\")\n+\n+        });\n \n         let mut cmd = rust_installer(builder);\n         cmd.arg(\"generate\")\n            .arg(\"--product-name=Rust\")\n            .arg(\"--rel-manifest-dir=rustlib\")\n            .arg(\"--success-message=std-is-standing-at-the-ready.\")\n            .arg(\"--image-dir\").arg(&image)\n-           .arg(\"--work-dir\").arg(&tmpdir(build))\n-           .arg(\"--output-dir\").arg(&distdir(build))\n+           .arg(\"--work-dir\").arg(&tmpdir(builder))\n+           .arg(\"--output-dir\").arg(&distdir(builder))\n            .arg(format!(\"--package-name={}-{}\", name, target))\n            .arg(format!(\"--component-name=rust-std-{}\", target))\n            .arg(\"--legacy-manifest-dirs=rustlib,cargo\");\n-        build.run(&mut cmd);\n-        t!(fs::remove_dir_all(&image));\n-        distdir(build).join(format!(\"{}-{}.tar.gz\", name, target))\n+        builder.run(&mut cmd);\n+        builder.remove_dir(&image);\n+        distdir(builder).join(format!(\"{}-{}.tar.gz\", name, target))\n     }\n }\n \n@@ -607,73 +699,71 @@ pub struct Analysis {\n impl Step for Analysis {\n     type Output = PathBuf;\n     const DEFAULT: bool = true;\n-    const ONLY_BUILD_TARGETS: bool = true;\n \n     fn should_run(run: ShouldRun) -> ShouldRun {\n         let builder = run.builder;\n-        run.path(\"analysis\").default_condition(builder.build.config.extended)\n+        run.path(\"analysis\").default_condition(builder.config.extended)\n     }\n \n     fn make_run(run: RunConfig) {\n         run.builder.ensure(Analysis {\n-            compiler: run.builder.compiler(run.builder.top_stage, run.host),\n+            compiler: run.builder.compiler(run.builder.top_stage, run.builder.config.build),\n             target: run.target,\n         });\n     }\n \n     /// Creates a tarball of save-analysis metadata, if available.\n     fn run(self, builder: &Builder) -> PathBuf {\n-        let build = builder.build;\n         let compiler = self.compiler;\n         let target = self.target;\n-        assert!(build.config.extended);\n-        println!(\"Dist analysis\");\n-        let name = pkgname(build, \"rust-analysis\");\n+        assert!(builder.config.extended);\n+        builder.info(\"Dist analysis\");\n+        let name = pkgname(builder, \"rust-analysis\");\n \n-        if &compiler.host != build.build {\n-            println!(\"\\tskipping, not a build host\");\n-            return distdir(build).join(format!(\"{}-{}.tar.gz\", name, target));\n+        if &compiler.host != builder.config.build {\n+            builder.info(\"\\tskipping, not a build host\");\n+            return distdir(builder).join(format!(\"{}-{}.tar.gz\", name, target));\n         }\n \n         builder.ensure(Std { compiler, target });\n \n         // Package save-analysis from stage1 if not doing a full bootstrap, as the\n         // stage2 artifacts is simply copied from stage1 in that case.\n-        let compiler = if build.force_use_stage1(compiler, target) {\n+        let compiler = if builder.force_use_stage1(compiler, target) {\n             builder.compiler(1, compiler.host)\n         } else {\n             compiler.clone()\n         };\n \n-        let image = tmpdir(build).join(format!(\"{}-{}-image\", name, target));\n+        let image = tmpdir(builder).join(format!(\"{}-{}-image\", name, target));\n \n-        let src = build.stage_out(compiler, Mode::Libstd)\n-            .join(target).join(build.cargo_dir()).join(\"deps\");\n+        let src = builder.stage_out(compiler, Mode::Std)\n+            .join(target).join(builder.cargo_dir()).join(\"deps\");\n \n         let image_src = src.join(\"save-analysis\");\n         let dst = image.join(\"lib/rustlib\").join(target).join(\"analysis\");\n         t!(fs::create_dir_all(&dst));\n-        println!(\"image_src: {:?}, dst: {:?}\", image_src, dst);\n-        cp_r(&image_src, &dst);\n+        builder.info(&format!(\"image_src: {:?}, dst: {:?}\", image_src, dst));\n+        builder.cp_r(&image_src, &dst);\n \n         let mut cmd = rust_installer(builder);\n         cmd.arg(\"generate\")\n            .arg(\"--product-name=Rust\")\n            .arg(\"--rel-manifest-dir=rustlib\")\n            .arg(\"--success-message=save-analysis-saved.\")\n            .arg(\"--image-dir\").arg(&image)\n-           .arg(\"--work-dir\").arg(&tmpdir(build))\n-           .arg(\"--output-dir\").arg(&distdir(build))\n+           .arg(\"--work-dir\").arg(&tmpdir(builder))\n+           .arg(\"--output-dir\").arg(&distdir(builder))\n            .arg(format!(\"--package-name={}-{}\", name, target))\n            .arg(format!(\"--component-name=rust-analysis-{}\", target))\n            .arg(\"--legacy-manifest-dirs=rustlib,cargo\");\n-        build.run(&mut cmd);\n-        t!(fs::remove_dir_all(&image));\n-        distdir(build).join(format!(\"{}-{}.tar.gz\", name, target))\n+        builder.run(&mut cmd);\n+        builder.remove_dir(&image);\n+        distdir(builder).join(format!(\"{}-{}.tar.gz\", name, target))\n     }\n }\n \n-fn copy_src_dirs(build: &Build, src_dirs: &[&str], exclude_dirs: &[&str], dst_dir: &Path) {\n+fn copy_src_dirs(builder: &Builder, src_dirs: &[&str], exclude_dirs: &[&str], dst_dir: &Path) {\n     fn filter_fn(exclude_dirs: &[&str], dir: &str, path: &Path) -> bool {\n         let spath = match path.to_str() {\n             Some(path) => path,\n@@ -712,20 +802,19 @@ fn copy_src_dirs(build: &Build, src_dirs: &[&str], exclude_dirs: &[&str], dst_di\n     for item in src_dirs {\n         let dst = &dst_dir.join(item);\n         t!(fs::create_dir_all(dst));\n-        cp_filtered(&build.src.join(item), dst, &|path| filter_fn(exclude_dirs, item, path));\n+        builder.cp_filtered(\n+            &builder.src.join(item), dst, &|path| filter_fn(exclude_dirs, item, path));\n     }\n }\n \n-#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n+#[derive(Debug, PartialOrd, Ord, Copy, Clone, Hash, PartialEq, Eq)]\n pub struct Src;\n \n impl Step for Src {\n     /// The output path of the src installer tarball\n     type Output = PathBuf;\n     const DEFAULT: bool = true;\n     const ONLY_HOSTS: bool = true;\n-    const ONLY_BUILD_TARGETS: bool = true;\n-    const ONLY_BUILD: bool = true;\n \n     fn should_run(run: ShouldRun) -> ShouldRun {\n         run.path(\"src\")\n@@ -737,11 +826,10 @@ impl Step for Src {\n \n     /// Creates the `rust-src` installer component\n     fn run(self, builder: &Builder) -> PathBuf {\n-        let build = builder.build;\n-        println!(\"Dist src\");\n+        builder.info(\"Dist src\");\n \n-        let name = pkgname(build, \"rust-src\");\n-        let image = tmpdir(build).join(format!(\"{}-image\", name));\n+        let name = pkgname(builder, \"rust-src\");\n+        let image = tmpdir(builder).join(format!(\"{}-image\", name));\n         let _ = fs::remove_dir_all(&image);\n \n         let dst = image.join(\"lib/rustlib/src\");\n@@ -770,7 +858,6 @@ impl Step for Src {\n             \"src/librustc_msan\",\n             \"src/librustc_tsan\",\n             \"src/libstd\",\n-            \"src/libstd_unicode\",\n             \"src/libunwind\",\n             \"src/rustc/compiler_builtins_shim\",\n             \"src/rustc/libc_shim\",\n@@ -779,15 +866,16 @@ impl Step for Src {\n             \"src/libterm\",\n             \"src/jemalloc\",\n             \"src/libprofiler_builtins\",\n+            \"src/stdsimd\",\n         ];\n         let std_src_dirs_exclude = [\n             \"src/libcompiler_builtins/compiler-rt/test\",\n             \"src/jemalloc/test/unit\",\n         ];\n \n-        copy_src_dirs(build, &std_src_dirs[..], &std_src_dirs_exclude[..], &dst_src);\n+        copy_src_dirs(builder, &std_src_dirs[..], &std_src_dirs_exclude[..], &dst_src);\n         for file in src_files.iter() {\n-            copy(&build.src.join(file), &dst_src.join(file));\n+            builder.copy(&builder.src.join(file), &dst_src.join(file));\n         }\n \n         // Create source tarball in rust-installer format\n@@ -797,30 +885,28 @@ impl Step for Src {\n            .arg(\"--rel-manifest-dir=rustlib\")\n            .arg(\"--success-message=Awesome-Source.\")\n            .arg(\"--image-dir\").arg(&image)\n-           .arg(\"--work-dir\").arg(&tmpdir(build))\n-           .arg(\"--output-dir\").arg(&distdir(build))\n+           .arg(\"--work-dir\").arg(&tmpdir(builder))\n+           .arg(\"--output-dir\").arg(&distdir(builder))\n            .arg(format!(\"--package-name={}\", name))\n            .arg(\"--component-name=rust-src\")\n            .arg(\"--legacy-manifest-dirs=rustlib,cargo\");\n-        build.run(&mut cmd);\n+        builder.run(&mut cmd);\n \n-        t!(fs::remove_dir_all(&image));\n-        distdir(build).join(&format!(\"{}.tar.gz\", name))\n+        builder.remove_dir(&image);\n+        distdir(builder).join(&format!(\"{}.tar.gz\", name))\n     }\n }\n \n const CARGO_VENDOR_VERSION: &str = \"0.1.4\";\n \n-#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n+#[derive(Debug, PartialOrd, Ord, Copy, Clone, Hash, PartialEq, Eq)]\n pub struct PlainSourceTarball;\n \n impl Step for PlainSourceTarball {\n     /// Produces the location of the tarball generated\n     type Output = PathBuf;\n     const DEFAULT: bool = true;\n     const ONLY_HOSTS: bool = true;\n-    const ONLY_BUILD_TARGETS: bool = true;\n-    const ONLY_BUILD: bool = true;\n \n     fn should_run(run: ShouldRun) -> ShouldRun {\n         let builder = run.builder;\n@@ -833,12 +919,11 @@ impl Step for PlainSourceTarball {\n \n     /// Creates the plain source tarball\n     fn run(self, builder: &Builder) -> PathBuf {\n-        let build = builder.build;\n-        println!(\"Create plain source tarball\");\n+        builder.info(\"Create plain source tarball\");\n \n         // Make sure that the root folder of tarball has the correct name\n-        let plain_name = format!(\"{}-src\", pkgname(build, \"rustc\"));\n-        let plain_dst_src = tmpdir(build).join(&plain_name);\n+        let plain_name = format!(\"{}-src\", pkgname(builder, \"rustc\"));\n+        let plain_dst_src = tmpdir(builder).join(&plain_name);\n         let _ = fs::remove_dir_all(&plain_dst_src);\n         t!(fs::create_dir_all(&plain_dst_src));\n \n@@ -858,85 +943,74 @@ impl Step for PlainSourceTarball {\n             \"src\",\n         ];\n \n-        copy_src_dirs(build, &src_dirs[..], &[], &plain_dst_src);\n+        copy_src_dirs(builder, &src_dirs[..], &[], &plain_dst_src);\n \n         // Copy the files normally\n         for item in &src_files {\n-            copy(&build.src.join(item), &plain_dst_src.join(item));\n+            builder.copy(&builder.src.join(item), &plain_dst_src.join(item));\n         }\n \n         // Create the version file\n-        write_file(&plain_dst_src.join(\"version\"), build.rust_version().as_bytes());\n-        if let Some(sha) = build.rust_sha() {\n-            write_file(&plain_dst_src.join(\"git-commit-hash\"), sha.as_bytes());\n+        builder.create(&plain_dst_src.join(\"version\"), &builder.rust_version());\n+        if let Some(sha) = builder.rust_sha() {\n+            builder.create(&plain_dst_src.join(\"git-commit-hash\"), &sha);\n         }\n \n         // If we're building from git sources, we need to vendor a complete distribution.\n-        if build.rust_info.is_git() {\n+        if builder.rust_info.is_git() {\n             // Get cargo-vendor installed, if it isn't already.\n             let mut has_cargo_vendor = false;\n-            let mut cmd = Command::new(&build.initial_cargo);\n+            let mut cmd = Command::new(&builder.initial_cargo);\n             for line in output(cmd.arg(\"install\").arg(\"--list\")).lines() {\n                 has_cargo_vendor |= line.starts_with(\"cargo-vendor \");\n             }\n             if !has_cargo_vendor {\n-                let mut cmd = Command::new(&build.initial_cargo);\n-                cmd.arg(\"install\")\n-                   .arg(\"--force\")\n+                let mut cmd = builder.cargo(\n+                    builder.compiler(0, builder.config.build),\n+                    Mode::ToolBootstrap,\n+                    builder.config.build,\n+                    \"install\"\n+                );\n+                cmd.arg(\"--force\")\n                    .arg(\"--debug\")\n                    .arg(\"--vers\").arg(CARGO_VENDOR_VERSION)\n-                   .arg(\"cargo-vendor\")\n-                   .env(\"RUSTC\", &build.initial_rustc);\n-                build.run(&mut cmd);\n+                   .arg(\"cargo-vendor\");\n+                if let Some(dir) = builder.openssl_install_dir(builder.config.build) {\n+                    builder.ensure(native::Openssl {\n+                        target: builder.config.build,\n+                    });\n+                    cmd.env(\"OPENSSL_DIR\", dir);\n+                }\n+                builder.run(&mut cmd);\n             }\n \n             // Vendor all Cargo dependencies\n-            let mut cmd = Command::new(&build.initial_cargo);\n+            let mut cmd = Command::new(&builder.initial_cargo);\n             cmd.arg(\"vendor\")\n                .current_dir(&plain_dst_src.join(\"src\"));\n-            build.run(&mut cmd);\n+            builder.run(&mut cmd);\n         }\n \n         // Create plain source tarball\n-        let plain_name = format!(\"rustc-{}-src\", build.rust_package_vers());\n-        let mut tarball = distdir(build).join(&format!(\"{}.tar.gz\", plain_name));\n+        let plain_name = format!(\"rustc-{}-src\", builder.rust_package_vers());\n+        let mut tarball = distdir(builder).join(&format!(\"{}.tar.gz\", plain_name));\n         tarball.set_extension(\"\"); // strip .gz\n         tarball.set_extension(\"\"); // strip .tar\n         if let Some(dir) = tarball.parent() {\n-            t!(fs::create_dir_all(dir));\n+            builder.create_dir(&dir);\n         }\n-        println!(\"running installer\");\n+        builder.info(\"running installer\");\n         let mut cmd = rust_installer(builder);\n         cmd.arg(\"tarball\")\n            .arg(\"--input\").arg(&plain_name)\n            .arg(\"--output\").arg(&tarball)\n            .arg(\"--work-dir=.\")\n-           .current_dir(tmpdir(build));\n-        build.run(&mut cmd);\n-        distdir(build).join(&format!(\"{}.tar.gz\", plain_name))\n+           .current_dir(tmpdir(builder));\n+        builder.run(&mut cmd);\n+        distdir(builder).join(&format!(\"{}.tar.gz\", plain_name))\n     }\n }\n \n-fn install(src: &Path, dstdir: &Path, perms: u32) {\n-    let dst = dstdir.join(src.file_name().unwrap());\n-    t!(fs::create_dir_all(dstdir));\n-    drop(fs::remove_file(&dst));\n-    {\n-        let mut s = t!(fs::File::open(&src));\n-        let mut d = t!(fs::File::create(&dst));\n-        io::copy(&mut s, &mut d).expect(\"failed to copy\");\n-    }\n-    chmod(&dst, perms);\n-}\n-\n-#[cfg(unix)]\n-fn chmod(path: &Path, perms: u32) {\n-    use std::os::unix::fs::*;\n-    t!(fs::set_permissions(path, fs::Permissions::from_mode(perms)));\n-}\n-#[cfg(windows)]\n-fn chmod(_path: &Path, _perms: u32) {}\n-\n // We have to run a few shell scripts, which choke quite a bit on both `\\`\n // characters and on `C:\\` paths, so normalize both of them away.\n pub fn sanitize_sh(path: &Path) -> String {\n@@ -956,20 +1030,14 @@ pub fn sanitize_sh(path: &Path) -> String {\n     }\n }\n \n-fn write_file(path: &Path, data: &[u8]) {\n-    let mut vf = t!(fs::File::create(path));\n-    t!(vf.write_all(data));\n-}\n-\n-#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n+#[derive(Debug, PartialOrd, Ord, Copy, Clone, Hash, PartialEq, Eq)]\n pub struct Cargo {\n     pub stage: u32,\n     pub target: Interned<String>,\n }\n \n impl Step for Cargo {\n     type Output = PathBuf;\n-    const ONLY_BUILD_TARGETS: bool = true;\n     const ONLY_HOSTS: bool = true;\n \n     fn should_run(run: ShouldRun) -> ShouldRun {\n@@ -984,52 +1052,51 @@ impl Step for Cargo {\n     }\n \n     fn run(self, builder: &Builder) -> PathBuf {\n-        let build = builder.build;\n         let stage = self.stage;\n         let target = self.target;\n \n-        println!(\"Dist cargo stage{} ({})\", stage, target);\n-        let src = build.src.join(\"src/tools/cargo\");\n+        builder.info(&format!(\"Dist cargo stage{} ({})\", stage, target));\n+        let src = builder.src.join(\"src/tools/cargo\");\n         let etc = src.join(\"src/etc\");\n-        let release_num = build.release_num(\"cargo\");\n-        let name = pkgname(build, \"cargo\");\n-        let version = builder.cargo_info.version(build, &release_num);\n+        let release_num = builder.release_num(\"cargo\");\n+        let name = pkgname(builder, \"cargo\");\n+        let version = builder.cargo_info.version(builder, &release_num);\n \n-        let tmp = tmpdir(build);\n+        let tmp = tmpdir(builder);\n         let image = tmp.join(\"cargo-image\");\n         drop(fs::remove_dir_all(&image));\n-        t!(fs::create_dir_all(&image));\n+        builder.create_dir(&image);\n \n         // Prepare the image directory\n-        t!(fs::create_dir_all(image.join(\"share/zsh/site-functions\")));\n-        t!(fs::create_dir_all(image.join(\"etc/bash_completion.d\")));\n+        builder.create_dir(&image.join(\"share/zsh/site-functions\"));\n+        builder.create_dir(&image.join(\"etc/bash_completion.d\"));\n         let cargo = builder.ensure(tool::Cargo {\n-            compiler: builder.compiler(stage, build.build),\n+            compiler: builder.compiler(stage, builder.config.build),\n             target\n         });\n-        install(&cargo, &image.join(\"bin\"), 0o755);\n+        builder.install(&cargo, &image.join(\"bin\"), 0o755);\n         for man in t!(etc.join(\"man\").read_dir()) {\n             let man = t!(man);\n-            install(&man.path(), &image.join(\"share/man/man1\"), 0o644);\n+            builder.install(&man.path(), &image.join(\"share/man/man1\"), 0o644);\n         }\n-        install(&etc.join(\"_cargo\"), &image.join(\"share/zsh/site-functions\"), 0o644);\n-        copy(&etc.join(\"cargo.bashcomp.sh\"),\n+        builder.install(&etc.join(\"_cargo\"), &image.join(\"share/zsh/site-functions\"), 0o644);\n+        builder.copy(&etc.join(\"cargo.bashcomp.sh\"),\n              &image.join(\"etc/bash_completion.d/cargo\"));\n         let doc = image.join(\"share/doc/cargo\");\n-        install(&src.join(\"README.md\"), &doc, 0o644);\n-        install(&src.join(\"LICENSE-MIT\"), &doc, 0o644);\n-        install(&src.join(\"LICENSE-APACHE\"), &doc, 0o644);\n-        install(&src.join(\"LICENSE-THIRD-PARTY\"), &doc, 0o644);\n+        builder.install(&src.join(\"README.md\"), &doc, 0o644);\n+        builder.install(&src.join(\"LICENSE-MIT\"), &doc, 0o644);\n+        builder.install(&src.join(\"LICENSE-APACHE\"), &doc, 0o644);\n+        builder.install(&src.join(\"LICENSE-THIRD-PARTY\"), &doc, 0o644);\n \n         // Prepare the overlay\n         let overlay = tmp.join(\"cargo-overlay\");\n         drop(fs::remove_dir_all(&overlay));\n-        t!(fs::create_dir_all(&overlay));\n-        install(&src.join(\"README.md\"), &overlay, 0o644);\n-        install(&src.join(\"LICENSE-MIT\"), &overlay, 0o644);\n-        install(&src.join(\"LICENSE-APACHE\"), &overlay, 0o644);\n-        install(&src.join(\"LICENSE-THIRD-PARTY\"), &overlay, 0o644);\n-        t!(t!(File::create(overlay.join(\"version\"))).write_all(version.as_bytes()));\n+        builder.create_dir(&overlay);\n+        builder.install(&src.join(\"README.md\"), &overlay, 0o644);\n+        builder.install(&src.join(\"LICENSE-MIT\"), &overlay, 0o644);\n+        builder.install(&src.join(\"LICENSE-APACHE\"), &overlay, 0o644);\n+        builder.install(&src.join(\"LICENSE-THIRD-PARTY\"), &overlay, 0o644);\n+        builder.create(&overlay.join(\"version\"), &version);\n \n         // Generate the installer tarball\n         let mut cmd = rust_installer(builder);\n@@ -1038,26 +1105,25 @@ impl Step for Cargo {\n            .arg(\"--rel-manifest-dir=rustlib\")\n            .arg(\"--success-message=Rust-is-ready-to-roll.\")\n            .arg(\"--image-dir\").arg(&image)\n-           .arg(\"--work-dir\").arg(&tmpdir(build))\n-           .arg(\"--output-dir\").arg(&distdir(build))\n+           .arg(\"--work-dir\").arg(&tmpdir(builder))\n+           .arg(\"--output-dir\").arg(&distdir(builder))\n            .arg(\"--non-installed-overlay\").arg(&overlay)\n            .arg(format!(\"--package-name={}-{}\", name, target))\n            .arg(\"--component-name=cargo\")\n            .arg(\"--legacy-manifest-dirs=rustlib,cargo\");\n-        build.run(&mut cmd);\n-        distdir(build).join(format!(\"{}-{}.tar.gz\", name, target))\n+        builder.run(&mut cmd);\n+        distdir(builder).join(format!(\"{}-{}.tar.gz\", name, target))\n     }\n }\n \n-#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n+#[derive(Debug, PartialOrd, Ord, Copy, Clone, Hash, PartialEq, Eq)]\n pub struct Rls {\n     pub stage: u32,\n     pub target: Interned<String>,\n }\n \n impl Step for Rls {\n     type Output = Option<PathBuf>;\n-    const ONLY_BUILD_TARGETS: bool = true;\n     const ONLY_HOSTS: bool = true;\n \n     fn should_run(run: ShouldRun) -> ShouldRun {\n@@ -1072,18 +1138,17 @@ impl Step for Rls {\n     }\n \n     fn run(self, builder: &Builder) -> Option<PathBuf> {\n-        let build = builder.build;\n         let stage = self.stage;\n         let target = self.target;\n-        assert!(build.config.extended);\n+        assert!(builder.config.extended);\n \n-        println!(\"Dist RLS stage{} ({})\", stage, target);\n-        let src = build.src.join(\"src/tools/rls\");\n-        let release_num = build.release_num(\"rls\");\n-        let name = pkgname(build, \"rls\");\n-        let version = build.rls_info.version(build, &release_num);\n+        builder.info(&format!(\"Dist RLS stage{} ({})\", stage, target));\n+        let src = builder.src.join(\"src/tools/rls\");\n+        let release_num = builder.release_num(\"rls\");\n+        let name = pkgname(builder, \"rls\");\n+        let version = builder.rls_info.version(builder, &release_num);\n \n-        let tmp = tmpdir(build);\n+        let tmp = tmpdir(builder);\n         let image = tmp.join(\"rls-image\");\n         drop(fs::remove_dir_all(&image));\n         t!(fs::create_dir_all(&image));\n@@ -1092,24 +1157,24 @@ impl Step for Rls {\n         // We expect RLS to build, because we've exited this step above if tool\n         // state for RLS isn't testing.\n         let rls = builder.ensure(tool::Rls {\n-            compiler: builder.compiler(stage, build.build),\n-            target\n+            compiler: builder.compiler(stage, builder.config.build),\n+            target, extra_features: Vec::new()\n         }).or_else(|| { println!(\"Unable to build RLS, skipping dist\"); None })?;\n \n-        install(&rls, &image.join(\"bin\"), 0o755);\n+        builder.install(&rls, &image.join(\"bin\"), 0o755);\n         let doc = image.join(\"share/doc/rls\");\n-        install(&src.join(\"README.md\"), &doc, 0o644);\n-        install(&src.join(\"LICENSE-MIT\"), &doc, 0o644);\n-        install(&src.join(\"LICENSE-APACHE\"), &doc, 0o644);\n+        builder.install(&src.join(\"README.md\"), &doc, 0o644);\n+        builder.install(&src.join(\"LICENSE-MIT\"), &doc, 0o644);\n+        builder.install(&src.join(\"LICENSE-APACHE\"), &doc, 0o644);\n \n         // Prepare the overlay\n         let overlay = tmp.join(\"rls-overlay\");\n         drop(fs::remove_dir_all(&overlay));\n         t!(fs::create_dir_all(&overlay));\n-        install(&src.join(\"README.md\"), &overlay, 0o644);\n-        install(&src.join(\"LICENSE-MIT\"), &overlay, 0o644);\n-        install(&src.join(\"LICENSE-APACHE\"), &overlay, 0o644);\n-        t!(t!(File::create(overlay.join(\"version\"))).write_all(version.as_bytes()));\n+        builder.install(&src.join(\"README.md\"), &overlay, 0o644);\n+        builder.install(&src.join(\"LICENSE-MIT\"), &overlay, 0o644);\n+        builder.install(&src.join(\"LICENSE-APACHE\"), &overlay, 0o644);\n+        builder.create(&overlay.join(\"version\"), &version);\n \n         // Generate the installer tarball\n         let mut cmd = rust_installer(builder);\n@@ -1118,28 +1183,108 @@ impl Step for Rls {\n            .arg(\"--rel-manifest-dir=rustlib\")\n            .arg(\"--success-message=RLS-ready-to-serve.\")\n            .arg(\"--image-dir\").arg(&image)\n-           .arg(\"--work-dir\").arg(&tmpdir(build))\n-           .arg(\"--output-dir\").arg(&distdir(build))\n+           .arg(\"--work-dir\").arg(&tmpdir(builder))\n+           .arg(\"--output-dir\").arg(&distdir(builder))\n            .arg(\"--non-installed-overlay\").arg(&overlay)\n            .arg(format!(\"--package-name={}-{}\", name, target))\n            .arg(\"--legacy-manifest-dirs=rustlib,cargo\")\n            .arg(\"--component-name=rls-preview\");\n \n-        build.run(&mut cmd);\n-        Some(distdir(build).join(format!(\"{}-{}.tar.gz\", name, target)))\n+        builder.run(&mut cmd);\n+        Some(distdir(builder).join(format!(\"{}-{}.tar.gz\", name, target)))\n     }\n }\n \n+#[derive(Debug, PartialOrd, Ord, Copy, Clone, Hash, PartialEq, Eq)]\n+pub struct Clippy {\n+    pub stage: u32,\n+    pub target: Interned<String>,\n+}\n \n-#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n+impl Step for Clippy {\n+    type Output = Option<PathBuf>;\n+    const ONLY_HOSTS: bool = true;\n+\n+    fn should_run(run: ShouldRun) -> ShouldRun {\n+        run.path(\"clippy\")\n+    }\n+\n+    fn make_run(run: RunConfig) {\n+        run.builder.ensure(Clippy {\n+            stage: run.builder.top_stage,\n+            target: run.target,\n+        });\n+    }\n+\n+    fn run(self, builder: &Builder) -> Option<PathBuf> {\n+        let stage = self.stage;\n+        let target = self.target;\n+        assert!(builder.config.extended);\n+\n+        builder.info(&format!(\"Dist clippy stage{} ({})\", stage, target));\n+        let src = builder.src.join(\"src/tools/clippy\");\n+        let release_num = builder.release_num(\"clippy\");\n+        let name = pkgname(builder, \"clippy\");\n+        let version = builder.clippy_info.version(builder, &release_num);\n+\n+        let tmp = tmpdir(builder);\n+        let image = tmp.join(\"clippy-image\");\n+        drop(fs::remove_dir_all(&image));\n+        builder.create_dir(&image);\n+\n+        // Prepare the image directory\n+        // We expect clippy to build, because we've exited this step above if tool\n+        // state for clippy isn't testing.\n+        let clippy = builder.ensure(tool::Clippy {\n+            compiler: builder.compiler(stage, builder.config.build),\n+            target, extra_features: Vec::new()\n+        }).or_else(|| { println!(\"Unable to build clippy, skipping dist\"); None })?;\n+        let cargoclippy = builder.ensure(tool::CargoClippy {\n+            compiler: builder.compiler(stage, builder.config.build),\n+            target, extra_features: Vec::new()\n+        }).or_else(|| { println!(\"Unable to build cargo clippy, skipping dist\"); None })?;\n+\n+        builder.install(&clippy, &image.join(\"bin\"), 0o755);\n+        builder.install(&cargoclippy, &image.join(\"bin\"), 0o755);\n+        let doc = image.join(\"share/doc/clippy\");\n+        builder.install(&src.join(\"README.md\"), &doc, 0o644);\n+        builder.install(&src.join(\"LICENSE\"), &doc, 0o644);\n+\n+        // Prepare the overlay\n+        let overlay = tmp.join(\"clippy-overlay\");\n+        drop(fs::remove_dir_all(&overlay));\n+        t!(fs::create_dir_all(&overlay));\n+        builder.install(&src.join(\"README.md\"), &overlay, 0o644);\n+        builder.install(&src.join(\"LICENSE\"), &doc, 0o644);\n+        builder.create(&overlay.join(\"version\"), &version);\n+\n+        // Generate the installer tarball\n+        let mut cmd = rust_installer(builder);\n+        cmd.arg(\"generate\")\n+           .arg(\"--product-name=Rust\")\n+           .arg(\"--rel-manifest-dir=rustlib\")\n+           .arg(\"--success-message=clippy-ready-to-serve.\")\n+           .arg(\"--image-dir\").arg(&image)\n+           .arg(\"--work-dir\").arg(&tmpdir(builder))\n+           .arg(\"--output-dir\").arg(&distdir(builder))\n+           .arg(\"--non-installed-overlay\").arg(&overlay)\n+           .arg(format!(\"--package-name={}-{}\", name, target))\n+           .arg(\"--legacy-manifest-dirs=rustlib,cargo\")\n+           .arg(\"--component-name=clippy-preview\");\n+\n+        builder.run(&mut cmd);\n+        Some(distdir(builder).join(format!(\"{}-{}.tar.gz\", name, target)))\n+    }\n+}\n+\n+#[derive(Debug, PartialOrd, Ord, Copy, Clone, Hash, PartialEq, Eq)]\n pub struct Rustfmt {\n     pub stage: u32,\n     pub target: Interned<String>,\n }\n \n impl Step for Rustfmt {\n     type Output = Option<PathBuf>;\n-    const ONLY_BUILD_TARGETS: bool = true;\n     const ONLY_HOSTS: bool = true;\n \n     fn should_run(run: ShouldRun) -> ShouldRun {\n@@ -1154,47 +1299,45 @@ impl Step for Rustfmt {\n     }\n \n     fn run(self, builder: &Builder) -> Option<PathBuf> {\n-        let build = builder.build;\n         let stage = self.stage;\n         let target = self.target;\n-        assert!(build.config.extended);\n \n-        println!(\"Dist Rustfmt stage{} ({})\", stage, target);\n-        let src = build.src.join(\"src/tools/rustfmt\");\n-        let release_num = build.release_num(\"rustfmt\");\n-        let name = pkgname(build, \"rustfmt\");\n-        let version = build.rustfmt_info.version(build, &release_num);\n+        builder.info(&format!(\"Dist Rustfmt stage{} ({})\", stage, target));\n+        let src = builder.src.join(\"src/tools/rustfmt\");\n+        let release_num = builder.release_num(\"rustfmt\");\n+        let name = pkgname(builder, \"rustfmt\");\n+        let version = builder.rustfmt_info.version(builder, &release_num);\n \n-        let tmp = tmpdir(build);\n+        let tmp = tmpdir(builder);\n         let image = tmp.join(\"rustfmt-image\");\n         drop(fs::remove_dir_all(&image));\n-        t!(fs::create_dir_all(&image));\n+        builder.create_dir(&image);\n \n         // Prepare the image directory\n         let rustfmt = builder.ensure(tool::Rustfmt {\n-            compiler: builder.compiler(stage, build.build),\n-            target\n+            compiler: builder.compiler(stage, builder.config.build),\n+            target, extra_features: Vec::new()\n         }).or_else(|| { println!(\"Unable to build Rustfmt, skipping dist\"); None })?;\n         let cargofmt = builder.ensure(tool::Cargofmt {\n-            compiler: builder.compiler(stage, build.build),\n-            target\n+            compiler: builder.compiler(stage, builder.config.build),\n+            target, extra_features: Vec::new()\n         }).or_else(|| { println!(\"Unable to build Cargofmt, skipping dist\"); None })?;\n \n-        install(&rustfmt, &image.join(\"bin\"), 0o755);\n-        install(&cargofmt, &image.join(\"bin\"), 0o755);\n+        builder.install(&rustfmt, &image.join(\"bin\"), 0o755);\n+        builder.install(&cargofmt, &image.join(\"bin\"), 0o755);\n         let doc = image.join(\"share/doc/rustfmt\");\n-        install(&src.join(\"README.md\"), &doc, 0o644);\n-        install(&src.join(\"LICENSE-MIT\"), &doc, 0o644);\n-        install(&src.join(\"LICENSE-APACHE\"), &doc, 0o644);\n+        builder.install(&src.join(\"README.md\"), &doc, 0o644);\n+        builder.install(&src.join(\"LICENSE-MIT\"), &doc, 0o644);\n+        builder.install(&src.join(\"LICENSE-APACHE\"), &doc, 0o644);\n \n         // Prepare the overlay\n         let overlay = tmp.join(\"rustfmt-overlay\");\n         drop(fs::remove_dir_all(&overlay));\n-        t!(fs::create_dir_all(&overlay));\n-        install(&src.join(\"README.md\"), &overlay, 0o644);\n-        install(&src.join(\"LICENSE-MIT\"), &overlay, 0o644);\n-        install(&src.join(\"LICENSE-APACHE\"), &overlay, 0o644);\n-        t!(t!(File::create(overlay.join(\"version\"))).write_all(version.as_bytes()));\n+        builder.create_dir(&overlay);\n+        builder.install(&src.join(\"README.md\"), &overlay, 0o644);\n+        builder.install(&src.join(\"LICENSE-MIT\"), &overlay, 0o644);\n+        builder.install(&src.join(\"LICENSE-APACHE\"), &overlay, 0o644);\n+        builder.create(&overlay.join(\"version\"), &version);\n \n         // Generate the installer tarball\n         let mut cmd = rust_installer(builder);\n@@ -1203,44 +1346,19 @@ impl Step for Rustfmt {\n            .arg(\"--rel-manifest-dir=rustlib\")\n            .arg(\"--success-message=rustfmt-ready-to-fmt.\")\n            .arg(\"--image-dir\").arg(&image)\n-           .arg(\"--work-dir\").arg(&tmpdir(build))\n-           .arg(\"--output-dir\").arg(&distdir(build))\n+           .arg(\"--work-dir\").arg(&tmpdir(builder))\n+           .arg(\"--output-dir\").arg(&distdir(builder))\n            .arg(\"--non-installed-overlay\").arg(&overlay)\n            .arg(format!(\"--package-name={}-{}\", name, target))\n            .arg(\"--legacy-manifest-dirs=rustlib,cargo\")\n            .arg(\"--component-name=rustfmt-preview\");\n \n-        build.run(&mut cmd);\n-        Some(distdir(build).join(format!(\"{}-{}.tar.gz\", name, target)))\n-    }\n-}\n-\n-\n-#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n-pub struct DontDistWithMiriEnabled;\n-\n-impl Step for DontDistWithMiriEnabled {\n-    type Output = PathBuf;\n-    const DEFAULT: bool = true;\n-\n-    fn should_run(run: ShouldRun) -> ShouldRun {\n-        let build_miri = run.builder.build.config.test_miri;\n-        run.default_condition(build_miri)\n-    }\n-\n-    fn make_run(run: RunConfig) {\n-        run.builder.ensure(DontDistWithMiriEnabled);\n-    }\n-\n-    fn run(self, _: &Builder) -> PathBuf {\n-        panic!(\"Do not distribute with miri enabled.\\n\\\n-                The distributed libraries would include all MIR (increasing binary size).\n-                The distributed MIR would include validation statements.\");\n+        builder.run(&mut cmd);\n+        Some(distdir(builder).join(format!(\"{}-{}.tar.gz\", name, target)))\n     }\n }\n \n-\n-#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n+#[derive(Debug, PartialOrd, Ord, Copy, Clone, Hash, PartialEq, Eq)]\n pub struct Extended {\n     stage: u32,\n     host: Interned<String>,\n@@ -1250,7 +1368,6 @@ pub struct Extended {\n impl Step for Extended {\n     type Output = ();\n     const DEFAULT: bool = true;\n-    const ONLY_BUILD_TARGETS: bool = true;\n     const ONLY_HOSTS: bool = true;\n \n     fn should_run(run: ShouldRun) -> ShouldRun {\n@@ -1261,25 +1378,27 @@ impl Step for Extended {\n     fn make_run(run: RunConfig) {\n         run.builder.ensure(Extended {\n             stage: run.builder.top_stage,\n-            host: run.host,\n+            host: run.builder.config.build,\n             target: run.target,\n         });\n     }\n \n     /// Creates a combined installer for the specified target in the provided stage.\n     fn run(self, builder: &Builder) {\n-        let build = builder.build;\n         let stage = self.stage;\n         let target = self.target;\n \n-        println!(\"Dist extended stage{} ({})\", stage, target);\n+        builder.info(&format!(\"Dist extended stage{} ({})\", stage, target));\n \n         let rustc_installer = builder.ensure(Rustc {\n             compiler: builder.compiler(stage, target),\n         });\n         let cargo_installer = builder.ensure(Cargo { stage, target });\n         let rustfmt_installer = builder.ensure(Rustfmt { stage, target });\n         let rls_installer = builder.ensure(Rls { stage, target });\n+        let llvm_tools_installer = builder.ensure(LlvmTools { stage, target });\n+        let clippy_installer = builder.ensure(Clippy { stage, target });\n+        let lldb_installer = builder.ensure(Lldb { target });\n         let mingw_installer = builder.ensure(Mingw { host: target });\n         let analysis_installer = builder.ensure(Analysis {\n             compiler: builder.compiler(stage, self.host),\n@@ -1292,21 +1411,21 @@ impl Step for Extended {\n             target,\n         });\n \n-        let tmp = tmpdir(build);\n+        let tmp = tmpdir(builder);\n         let overlay = tmp.join(\"extended-overlay\");\n-        let etc = build.src.join(\"src/etc/installer\");\n+        let etc = builder.src.join(\"src/etc/installer\");\n         let work = tmp.join(\"work\");\n \n         let _ = fs::remove_dir_all(&overlay);\n-        install(&build.src.join(\"COPYRIGHT\"), &overlay, 0o644);\n-        install(&build.src.join(\"LICENSE-APACHE\"), &overlay, 0o644);\n-        install(&build.src.join(\"LICENSE-MIT\"), &overlay, 0o644);\n-        let version = build.rust_version();\n-        t!(t!(File::create(overlay.join(\"version\"))).write_all(version.as_bytes()));\n-        if let Some(sha) = build.rust_sha() {\n-            t!(t!(File::create(overlay.join(\"git-commit-hash\"))).write_all(sha.as_bytes()));\n+        builder.install(&builder.src.join(\"COPYRIGHT\"), &overlay, 0o644);\n+        builder.install(&builder.src.join(\"LICENSE-APACHE\"), &overlay, 0o644);\n+        builder.install(&builder.src.join(\"LICENSE-MIT\"), &overlay, 0o644);\n+        let version = builder.rust_version();\n+        builder.create(&overlay.join(\"version\"), &version);\n+        if let Some(sha) = builder.rust_sha() {\n+            builder.create(&overlay.join(\"git-commit-hash\"), &sha);\n         }\n-        install(&etc.join(\"README.md\"), &overlay, 0o644);\n+        builder.install(&etc.join(\"README.md\"), &overlay, 0o644);\n \n         // When rust-std package split from rustc, we needed to ensure that during\n         // upgrades rustc was upgraded before rust-std. To avoid rustc clobbering\n@@ -1316,10 +1435,13 @@ impl Step for Extended {\n         tarballs.push(rustc_installer);\n         tarballs.push(cargo_installer);\n         tarballs.extend(rls_installer.clone());\n+        tarballs.extend(clippy_installer.clone());\n         tarballs.extend(rustfmt_installer.clone());\n+        tarballs.extend(llvm_tools_installer.clone());\n+        tarballs.extend(lldb_installer.clone());\n         tarballs.push(analysis_installer);\n         tarballs.push(std_installer);\n-        if build.config.docs {\n+        if builder.config.docs {\n             tarballs.push(docs_installer);\n         }\n         if target.contains(\"pc-windows-gnu\") {\n@@ -1337,19 +1459,19 @@ impl Step for Extended {\n             .arg(\"--rel-manifest-dir=rustlib\")\n             .arg(\"--success-message=Rust-is-ready-to-roll.\")\n             .arg(\"--work-dir\").arg(&work)\n-            .arg(\"--output-dir\").arg(&distdir(build))\n-            .arg(format!(\"--package-name={}-{}\", pkgname(build, \"rust\"), target))\n+            .arg(\"--output-dir\").arg(&distdir(builder))\n+            .arg(format!(\"--package-name={}-{}\", pkgname(builder, \"rust\"), target))\n             .arg(\"--legacy-manifest-dirs=rustlib,cargo\")\n             .arg(\"--input-tarballs\").arg(input_tarballs)\n             .arg(\"--non-installed-overlay\").arg(&overlay);\n-        build.run(&mut cmd);\n+        builder.run(&mut cmd);\n \n         let mut license = String::new();\n-        t!(t!(File::open(build.src.join(\"COPYRIGHT\"))).read_to_string(&mut license));\n+        license += &builder.read(&builder.src.join(\"COPYRIGHT\"));\n+        license += &builder.read(&builder.src.join(\"LICENSE-APACHE\"));\n+        license += &builder.read(&builder.src.join(\"LICENSE-MIT\"));\n         license.push_str(\"\\n\");\n-        t!(t!(File::open(build.src.join(\"LICENSE-APACHE\"))).read_to_string(&mut license));\n         license.push_str(\"\\n\");\n-        t!(t!(File::open(build.src.join(\"LICENSE-MIT\"))).read_to_string(&mut license));\n \n         let rtf = r\"{\\rtf1\\ansi\\deff0{\\fonttbl{\\f0\\fnil\\fcharset0 Arial;}}\\nowwrap\\fs18\";\n         let mut rtf = rtf.to_string();\n@@ -1384,6 +1506,9 @@ impl Step for Extended {\n             if rls_installer.is_none() {\n                 contents = filter(&contents, \"rls\");\n             }\n+            if clippy_installer.is_none() {\n+                contents = filter(&contents, \"clippy\");\n+            }\n             if rustfmt_installer.is_none() {\n                 contents = filter(&contents, \"rustfmt\");\n             }\n@@ -1402,14 +1527,14 @@ impl Step for Extended {\n                     .arg(\"--scripts\").arg(pkg.join(component))\n                     .arg(\"--nopayload\")\n                     .arg(pkg.join(component).with_extension(\"pkg\"));\n-                build.run(&mut cmd);\n+                builder.run(&mut cmd);\n             };\n \n             let prepare = |name: &str| {\n-                t!(fs::create_dir_all(pkg.join(name)));\n-                cp_r(&work.join(&format!(\"{}-{}\", pkgname(build, name), target)),\n+                builder.create_dir(&pkg.join(name));\n+                builder.cp_r(&work.join(&format!(\"{}-{}\", pkgname(builder, name), target)),\n                         &pkg.join(name));\n-                install(&etc.join(\"pkg/postinstall\"), &pkg.join(name), 0o755);\n+                builder.install(&etc.join(\"pkg/postinstall\"), &pkg.join(name), 0o755);\n                 pkgbuild(name);\n             };\n             prepare(\"rustc\");\n@@ -1421,41 +1546,46 @@ impl Step for Extended {\n             if rls_installer.is_some() {\n                 prepare(\"rls\");\n             }\n+            if clippy_installer.is_some() {\n+                prepare(\"clippy\");\n+            }\n \n             // create an 'uninstall' package\n-            install(&etc.join(\"pkg/postinstall\"), &pkg.join(\"uninstall\"), 0o755);\n+            builder.install(&etc.join(\"pkg/postinstall\"), &pkg.join(\"uninstall\"), 0o755);\n             pkgbuild(\"uninstall\");\n \n-            t!(fs::create_dir_all(pkg.join(\"res\")));\n-            t!(t!(File::create(pkg.join(\"res/LICENSE.txt\"))).write_all(license.as_bytes()));\n-            install(&etc.join(\"gfx/rust-logo.png\"), &pkg.join(\"res\"), 0o644);\n+            builder.create_dir(&pkg.join(\"res\"));\n+            builder.create(&pkg.join(\"res/LICENSE.txt\"), &license);\n+            builder.install(&etc.join(\"gfx/rust-logo.png\"), &pkg.join(\"res\"), 0o644);\n             let mut cmd = Command::new(\"productbuild\");\n             cmd.arg(\"--distribution\").arg(xform(&etc.join(\"pkg/Distribution.xml\")))\n                 .arg(\"--resources\").arg(pkg.join(\"res\"))\n-                .arg(distdir(build).join(format!(\"{}-{}.pkg\",\n-                                                    pkgname(build, \"rust\"),\n+                .arg(distdir(builder).join(format!(\"{}-{}.pkg\",\n+                                                    pkgname(builder, \"rust\"),\n                                                     target)))\n                 .arg(\"--package-path\").arg(&pkg);\n-            build.run(&mut cmd);\n+            builder.run(&mut cmd);\n         }\n \n         if target.contains(\"windows\") {\n             let exe = tmp.join(\"exe\");\n             let _ = fs::remove_dir_all(&exe);\n \n             let prepare = |name: &str| {\n-                t!(fs::create_dir_all(exe.join(name)));\n+                builder.create_dir(&exe.join(name));\n                 let dir = if name == \"rust-std\" || name == \"rust-analysis\" {\n                     format!(\"{}-{}\", name, target)\n                 } else if name == \"rls\" {\n                     \"rls-preview\".to_string()\n+                } else if name == \"clippy\" {\n+                    \"clippy-preview\".to_string()\n                 } else {\n                     name.to_string()\n                 };\n-                cp_r(&work.join(&format!(\"{}-{}\", pkgname(build, name), target))\n+                builder.cp_r(&work.join(&format!(\"{}-{}\", pkgname(builder, name), target))\n                             .join(dir),\n                         &exe.join(name));\n-                t!(fs::remove_file(exe.join(name).join(\"manifest.in\")));\n+                builder.remove(&exe.join(name).join(\"manifest.in\"));\n             };\n             prepare(\"rustc\");\n             prepare(\"cargo\");\n@@ -1465,15 +1595,18 @@ impl Step for Extended {\n             if rls_installer.is_some() {\n                 prepare(\"rls\");\n             }\n+            if clippy_installer.is_some() {\n+                prepare(\"clippy\");\n+            }\n             if target.contains(\"windows-gnu\") {\n                 prepare(\"rust-mingw\");\n             }\n \n-            install(&xform(&etc.join(\"exe/rust.iss\")), &exe, 0o644);\n-            install(&etc.join(\"exe/modpath.iss\"), &exe, 0o644);\n-            install(&etc.join(\"exe/upgrade.iss\"), &exe, 0o644);\n-            install(&etc.join(\"gfx/rust-logo.ico\"), &exe, 0o644);\n-            t!(t!(File::create(exe.join(\"LICENSE.txt\"))).write_all(license.as_bytes()));\n+            builder.install(&xform(&etc.join(\"exe/rust.iss\")), &exe, 0o644);\n+            builder.install(&etc.join(\"exe/modpath.iss\"), &exe, 0o644);\n+            builder.install(&etc.join(\"exe/upgrade.iss\"), &exe, 0o644);\n+            builder.install(&etc.join(\"gfx/rust-logo.ico\"), &exe, 0o644);\n+            builder.create(&exe.join(\"LICENSE.txt\"), &license);\n \n             // Generate exe installer\n             let mut cmd = Command::new(\"iscc\");\n@@ -1482,10 +1615,10 @@ impl Step for Extended {\n             if target.contains(\"windows-gnu\") {\n                 cmd.arg(\"/dMINGW\");\n             }\n-            add_env(build, &mut cmd, target);\n-            build.run(&mut cmd);\n-            install(&exe.join(format!(\"{}-{}.exe\", pkgname(build, \"rust\"), target)),\n-                    &distdir(build),\n+            add_env(builder, &mut cmd, target);\n+            builder.run(&mut cmd);\n+            builder.install(&exe.join(format!(\"{}-{}.exe\", pkgname(builder, \"rust\"), target)),\n+                    &distdir(builder),\n                     0o755);\n \n             // Generate msi installer\n@@ -1495,7 +1628,7 @@ impl Step for Extended {\n             let light = wix.join(\"bin/light.exe\");\n \n             let heat_flags = [\"-nologo\", \"-gg\", \"-sfrag\", \"-srd\", \"-sreg\"];\n-            build.run(Command::new(&heat)\n+            builder.run(Command::new(&heat)\n                             .current_dir(&exe)\n                             .arg(\"dir\")\n                             .arg(\"rustc\")\n@@ -1504,7 +1637,7 @@ impl Step for Extended {\n                             .arg(\"-dr\").arg(\"Rustc\")\n                             .arg(\"-var\").arg(\"var.RustcDir\")\n                             .arg(\"-out\").arg(exe.join(\"RustcGroup.wxs\")));\n-            build.run(Command::new(&heat)\n+            builder.run(Command::new(&heat)\n                             .current_dir(&exe)\n                             .arg(\"dir\")\n                             .arg(\"rust-docs\")\n@@ -1514,7 +1647,7 @@ impl Step for Extended {\n                             .arg(\"-var\").arg(\"var.DocsDir\")\n                             .arg(\"-out\").arg(exe.join(\"DocsGroup.wxs\"))\n                             .arg(\"-t\").arg(etc.join(\"msi/squash-components.xsl\")));\n-            build.run(Command::new(&heat)\n+            builder.run(Command::new(&heat)\n                             .current_dir(&exe)\n                             .arg(\"dir\")\n                             .arg(\"cargo\")\n@@ -1524,7 +1657,7 @@ impl Step for Extended {\n                             .arg(\"-var\").arg(\"var.CargoDir\")\n                             .arg(\"-out\").arg(exe.join(\"CargoGroup.wxs\"))\n                             .arg(\"-t\").arg(etc.join(\"msi/remove-duplicates.xsl\")));\n-            build.run(Command::new(&heat)\n+            builder.run(Command::new(&heat)\n                             .current_dir(&exe)\n                             .arg(\"dir\")\n                             .arg(\"rust-std\")\n@@ -1534,7 +1667,7 @@ impl Step for Extended {\n                             .arg(\"-var\").arg(\"var.StdDir\")\n                             .arg(\"-out\").arg(exe.join(\"StdGroup.wxs\")));\n             if rls_installer.is_some() {\n-                build.run(Command::new(&heat)\n+                builder.run(Command::new(&heat)\n                                 .current_dir(&exe)\n                                 .arg(\"dir\")\n                                 .arg(\"rls\")\n@@ -1545,7 +1678,19 @@ impl Step for Extended {\n                                 .arg(\"-out\").arg(exe.join(\"RlsGroup.wxs\"))\n                                 .arg(\"-t\").arg(etc.join(\"msi/remove-duplicates.xsl\")));\n             }\n-            build.run(Command::new(&heat)\n+            if clippy_installer.is_some() {\n+                builder.run(Command::new(&heat)\n+                                .current_dir(&exe)\n+                                .arg(\"dir\")\n+                                .arg(\"clippy\")\n+                                .args(&heat_flags)\n+                                .arg(\"-cg\").arg(\"ClippyGroup\")\n+                                .arg(\"-dr\").arg(\"Clippy\")\n+                                .arg(\"-var\").arg(\"var.ClippyDir\")\n+                                .arg(\"-out\").arg(exe.join(\"ClippyGroup.wxs\"))\n+                                .arg(\"-t\").arg(etc.join(\"msi/remove-duplicates.xsl\")));\n+            }\n+            builder.run(Command::new(&heat)\n                             .current_dir(&exe)\n                             .arg(\"dir\")\n                             .arg(\"rust-analysis\")\n@@ -1556,7 +1701,7 @@ impl Step for Extended {\n                             .arg(\"-out\").arg(exe.join(\"AnalysisGroup.wxs\"))\n                             .arg(\"-t\").arg(etc.join(\"msi/remove-duplicates.xsl\")));\n             if target.contains(\"windows-gnu\") {\n-                build.run(Command::new(&heat)\n+                builder.run(Command::new(&heat)\n                                 .current_dir(&exe)\n                                 .arg(\"dir\")\n                                 .arg(\"rust-mingw\")\n@@ -1582,15 +1727,18 @@ impl Step for Extended {\n                     .arg(\"-arch\").arg(&arch)\n                     .arg(\"-out\").arg(&output)\n                     .arg(&input);\n-                add_env(build, &mut cmd, target);\n+                add_env(builder, &mut cmd, target);\n \n                 if rls_installer.is_some() {\n                     cmd.arg(\"-dRlsDir=rls\");\n                 }\n+                if clippy_installer.is_some() {\n+                    cmd.arg(\"-dClippyDir=clippy\");\n+                }\n                 if target.contains(\"windows-gnu\") {\n                     cmd.arg(\"-dGccDir=rust-mingw\");\n                 }\n-                build.run(&mut cmd);\n+                builder.run(&mut cmd);\n             };\n             candle(&xform(&etc.join(\"msi/rust.wxs\")));\n             candle(&etc.join(\"msi/ui.wxs\"));\n@@ -1602,17 +1750,20 @@ impl Step for Extended {\n             if rls_installer.is_some() {\n                 candle(\"RlsGroup.wxs\".as_ref());\n             }\n+            if clippy_installer.is_some() {\n+                candle(\"ClippyGroup.wxs\".as_ref());\n+            }\n             candle(\"AnalysisGroup.wxs\".as_ref());\n \n             if target.contains(\"windows-gnu\") {\n                 candle(\"GccGroup.wxs\".as_ref());\n             }\n \n-            t!(t!(File::create(exe.join(\"LICENSE.rtf\"))).write_all(rtf.as_bytes()));\n-            install(&etc.join(\"gfx/banner.bmp\"), &exe, 0o644);\n-            install(&etc.join(\"gfx/dialogbg.bmp\"), &exe, 0o644);\n+            builder.create(&exe.join(\"LICENSE.rtf\"), &rtf);\n+            builder.install(&etc.join(\"gfx/banner.bmp\"), &exe, 0o644);\n+            builder.install(&etc.join(\"gfx/dialogbg.bmp\"), &exe, 0o644);\n \n-            let filename = format!(\"{}-{}.msi\", pkgname(build, \"rust\"), target);\n+            let filename = format!(\"{}-{}.msi\", pkgname(builder, \"rust\"), target);\n             let mut cmd = Command::new(&light);\n             cmd.arg(\"-nologo\")\n                 .arg(\"-ext\").arg(\"WixUIExtension\")\n@@ -1631,34 +1782,38 @@ impl Step for Extended {\n             if rls_installer.is_some() {\n                 cmd.arg(\"RlsGroup.wixobj\");\n             }\n+            if clippy_installer.is_some() {\n+                cmd.arg(\"ClippyGroup.wixobj\");\n+            }\n \n             if target.contains(\"windows-gnu\") {\n                 cmd.arg(\"GccGroup.wixobj\");\n             }\n             // ICE57 wrongly complains about the shortcuts\n             cmd.arg(\"-sice:ICE57\");\n \n-            build.run(&mut cmd);\n+            builder.run(&mut cmd);\n \n-            t!(fs::rename(exe.join(&filename), distdir(build).join(&filename)));\n+            if !builder.config.dry_run {\n+                t!(fs::rename(exe.join(&filename), distdir(builder).join(&filename)));\n+            }\n         }\n     }\n }\n \n-fn add_env(build: &Build, cmd: &mut Command, target: Interned<String>) {\n+fn add_env(builder: &Builder, cmd: &mut Command, target: Interned<String>) {\n     let mut parts = channel::CFG_RELEASE_NUM.split('.');\n-    cmd.env(\"CFG_RELEASE_INFO\", build.rust_version())\n+    cmd.env(\"CFG_RELEASE_INFO\", builder.rust_version())\n        .env(\"CFG_RELEASE_NUM\", channel::CFG_RELEASE_NUM)\n-       .env(\"CFG_RELEASE\", build.rust_release())\n-       .env(\"CFG_PRERELEASE_VERSION\", channel::CFG_PRERELEASE_VERSION)\n+       .env(\"CFG_RELEASE\", builder.rust_release())\n        .env(\"CFG_VER_MAJOR\", parts.next().unwrap())\n        .env(\"CFG_VER_MINOR\", parts.next().unwrap())\n        .env(\"CFG_VER_PATCH\", parts.next().unwrap())\n        .env(\"CFG_VER_BUILD\", \"0\") // just needed to build\n-       .env(\"CFG_PACKAGE_VERS\", build.rust_package_vers())\n-       .env(\"CFG_PACKAGE_NAME\", pkgname(build, \"rust\"))\n+       .env(\"CFG_PACKAGE_VERS\", builder.rust_package_vers())\n+       .env(\"CFG_PACKAGE_NAME\", pkgname(builder, \"rust\"))\n        .env(\"CFG_BUILD\", target)\n-       .env(\"CFG_CHANNEL\", &build.config.channel);\n+       .env(\"CFG_CHANNEL\", &builder.config.channel);\n \n     if target.contains(\"windows-gnu\") {\n        cmd.env(\"CFG_MINGW\", \"1\")\n@@ -1675,14 +1830,12 @@ fn add_env(build: &Build, cmd: &mut Command, target: Interned<String>) {\n     }\n }\n \n-#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n+#[derive(Debug, PartialOrd, Ord, Copy, Clone, Hash, PartialEq, Eq)]\n pub struct HashSign;\n \n impl Step for HashSign {\n     type Output = ();\n-    const ONLY_BUILD_TARGETS: bool = true;\n     const ONLY_HOSTS: bool = true;\n-    const ONLY_BUILD: bool = true;\n \n     fn should_run(run: ShouldRun) -> ShouldRun {\n         run.path(\"hash-and-sign\")\n@@ -1693,15 +1846,17 @@ impl Step for HashSign {\n     }\n \n     fn run(self, builder: &Builder) {\n-        let build = builder.build;\n         let mut cmd = builder.tool_cmd(Tool::BuildManifest);\n-        let sign = build.config.dist_sign_folder.as_ref().unwrap_or_else(|| {\n+        if builder.config.dry_run {\n+            return;\n+        }\n+        let sign = builder.config.dist_sign_folder.as_ref().unwrap_or_else(|| {\n             panic!(\"\\n\\nfailed to specify `dist.sign-folder` in `config.toml`\\n\\n\")\n         });\n-        let addr = build.config.dist_upload_addr.as_ref().unwrap_or_else(|| {\n+        let addr = builder.config.dist_upload_addr.as_ref().unwrap_or_else(|| {\n             panic!(\"\\n\\nfailed to specify `dist.upload-addr` in `config.toml`\\n\\n\")\n         });\n-        let file = build.config.dist_gpg_password_file.as_ref().unwrap_or_else(|| {\n+        let file = builder.config.dist_gpg_password_file.as_ref().unwrap_or_else(|| {\n             panic!(\"\\n\\nfailed to specify `dist.gpg-password-file` in `config.toml`\\n\\n\")\n         });\n         let mut pass = String::new();\n@@ -1710,19 +1865,224 @@ impl Step for HashSign {\n         let today = output(Command::new(\"date\").arg(\"+%Y-%m-%d\"));\n \n         cmd.arg(sign);\n-        cmd.arg(distdir(build));\n+        cmd.arg(distdir(builder));\n         cmd.arg(today.trim());\n-        cmd.arg(build.rust_package_vers());\n-        cmd.arg(build.package_vers(&build.release_num(\"cargo\")));\n-        cmd.arg(build.package_vers(&build.release_num(\"rls\")));\n-        cmd.arg(build.package_vers(&build.release_num(\"rustfmt\")));\n+        cmd.arg(builder.rust_package_vers());\n+        cmd.arg(builder.package_vers(&builder.release_num(\"cargo\")));\n+        cmd.arg(builder.package_vers(&builder.release_num(\"rls\")));\n+        cmd.arg(builder.package_vers(&builder.release_num(\"clippy\")));\n+        cmd.arg(builder.package_vers(&builder.release_num(\"rustfmt\")));\n+        cmd.arg(builder.llvm_tools_package_vers());\n+        cmd.arg(builder.lldb_package_vers());\n         cmd.arg(addr);\n \n-        t!(fs::create_dir_all(distdir(build)));\n+        builder.create_dir(&distdir(builder));\n \n         let mut child = t!(cmd.stdin(Stdio::piped()).spawn());\n         t!(child.stdin.take().unwrap().write_all(pass.as_bytes()));\n         let status = t!(child.wait());\n         assert!(status.success());\n     }\n }\n+\n+#[derive(Clone, Debug, Eq, Hash, PartialEq)]\n+pub struct LlvmTools {\n+    pub stage: u32,\n+    pub target: Interned<String>,\n+}\n+\n+impl Step for LlvmTools {\n+    type Output = Option<PathBuf>;\n+    const ONLY_HOSTS: bool = true;\n+\n+    fn should_run(run: ShouldRun) -> ShouldRun {\n+        run.path(\"llvm-tools\")\n+    }\n+\n+    fn make_run(run: RunConfig) {\n+        run.builder.ensure(LlvmTools {\n+            stage: run.builder.top_stage,\n+            target: run.target,\n+        });\n+    }\n+\n+    fn run(self, builder: &Builder) -> Option<PathBuf> {\n+        let stage = self.stage;\n+        let target = self.target;\n+        assert!(builder.config.extended);\n+\n+        /* run only if llvm-config isn't used */\n+        if let Some(config) = builder.config.target_config.get(&target) {\n+            if let Some(ref _s) = config.llvm_config {\n+                builder.info(&format!(\"Skipping LlvmTools stage{} ({}): external LLVM\",\n+                    stage, target));\n+                return None;\n+            }\n+        }\n+\n+        builder.info(&format!(\"Dist LlvmTools stage{} ({})\", stage, target));\n+        let src = builder.src.join(\"src/llvm\");\n+        let name = pkgname(builder, \"llvm-tools\");\n+\n+        let tmp = tmpdir(builder);\n+        let image = tmp.join(\"llvm-tools-image\");\n+        drop(fs::remove_dir_all(&image));\n+\n+        // Prepare the image directory\n+        let bindir = builder\n+            .llvm_out(target)\n+            .join(\"bin\");\n+        let dst = image.join(\"lib/rustlib\")\n+            .join(target)\n+            .join(\"bin\");\n+        t!(fs::create_dir_all(&dst));\n+        for tool in LLVM_TOOLS {\n+            let exe = bindir.join(exe(tool, &target));\n+            builder.install(&exe, &dst, 0o755);\n+        }\n+\n+        // Prepare the overlay\n+        let overlay = tmp.join(\"llvm-tools-overlay\");\n+        drop(fs::remove_dir_all(&overlay));\n+        builder.create_dir(&overlay);\n+        builder.install(&src.join(\"README.txt\"), &overlay, 0o644);\n+        builder.install(&src.join(\"LICENSE.TXT\"), &overlay, 0o644);\n+        builder.create(&overlay.join(\"version\"), &builder.llvm_tools_vers());\n+\n+        // Generate the installer tarball\n+        let mut cmd = rust_installer(builder);\n+        cmd.arg(\"generate\")\n+            .arg(\"--product-name=Rust\")\n+            .arg(\"--rel-manifest-dir=rustlib\")\n+            .arg(\"--success-message=llvm-tools-installed.\")\n+            .arg(\"--image-dir\").arg(&image)\n+            .arg(\"--work-dir\").arg(&tmpdir(builder))\n+            .arg(\"--output-dir\").arg(&distdir(builder))\n+            .arg(\"--non-installed-overlay\").arg(&overlay)\n+            .arg(format!(\"--package-name={}-{}\", name, target))\n+            .arg(\"--legacy-manifest-dirs=rustlib,cargo\")\n+            .arg(\"--component-name=llvm-tools-preview\");\n+\n+\n+        builder.run(&mut cmd);\n+        Some(distdir(builder).join(format!(\"{}-{}.tar.gz\", name, target)))\n+    }\n+}\n+\n+#[derive(Clone, Debug, Eq, Hash, PartialEq)]\n+pub struct Lldb {\n+    pub target: Interned<String>,\n+}\n+\n+impl Step for Lldb {\n+    type Output = Option<PathBuf>;\n+    const ONLY_HOSTS: bool = true;\n+    const DEFAULT: bool = true;\n+\n+    fn should_run(run: ShouldRun) -> ShouldRun {\n+        run.path(\"src/tools/lldb\")\n+    }\n+\n+    fn make_run(run: RunConfig) {\n+        run.builder.ensure(Lldb {\n+            target: run.target,\n+        });\n+    }\n+\n+    fn run(self, builder: &Builder) -> Option<PathBuf> {\n+        let target = self.target;\n+\n+        if builder.config.dry_run {\n+            return None;\n+        }\n+\n+        let bindir = builder\n+            .llvm_out(target)\n+            .join(\"bin\");\n+        let lldb_exe = bindir.join(exe(\"lldb\", &target));\n+        if !lldb_exe.exists() {\n+            return None;\n+        }\n+\n+        builder.info(&format!(\"Dist Lldb ({})\", target));\n+        let src = builder.src.join(\"src/tools/lldb\");\n+        let name = pkgname(builder, \"lldb\");\n+\n+        let tmp = tmpdir(builder);\n+        let image = tmp.join(\"lldb-image\");\n+        drop(fs::remove_dir_all(&image));\n+\n+        // Prepare the image directory\n+        let dst = image.join(\"bin\");\n+        t!(fs::create_dir_all(&dst));\n+        for program in &[\"lldb\", \"lldb-argdumper\", \"lldb-mi\", \"lldb-server\"] {\n+            let exe = bindir.join(exe(program, &target));\n+            builder.install(&exe, &dst, 0o755);\n+        }\n+\n+        // The libraries.\n+        let libdir = builder.llvm_out(target).join(\"lib\");\n+        let dst = image.join(\"lib\");\n+        t!(fs::create_dir_all(&dst));\n+        for entry in t!(fs::read_dir(&libdir)) {\n+            // let entry = t!(entry);\n+            let entry = entry.unwrap();\n+            if let Ok(name) = entry.file_name().into_string() {\n+                if name.starts_with(\"liblldb.\") && !name.ends_with(\".a\") {\n+                    if t!(entry.file_type()).is_symlink() {\n+                        builder.copy_to_folder(&entry.path(), &dst);\n+                    } else {\n+                       builder.install(&entry.path(), &dst, 0o755);\n+                    }\n+                }\n+            }\n+        }\n+\n+        // The lldb scripts might be installed in lib/python$version\n+        // or in lib64/python$version.  If lib64 exists, use it;\n+        // otherwise lib.\n+        let libdir = builder.llvm_out(target).join(\"lib64\");\n+        let (libdir, libdir_name) = if libdir.exists() {\n+            (libdir, \"lib64\")\n+        } else {\n+            (builder.llvm_out(target).join(\"lib\"), \"lib\")\n+        };\n+        for entry in t!(fs::read_dir(&libdir)) {\n+            let entry = t!(entry);\n+            if let Ok(name) = entry.file_name().into_string() {\n+                if name.starts_with(\"python\") {\n+                    let dst = image.join(libdir_name)\n+                        .join(entry.file_name());\n+                    t!(fs::create_dir_all(&dst));\n+                    builder.cp_r(&entry.path(), &dst);\n+                    break;\n+                }\n+            }\n+        }\n+\n+        // Prepare the overlay\n+        let overlay = tmp.join(\"lldb-overlay\");\n+        drop(fs::remove_dir_all(&overlay));\n+        builder.create_dir(&overlay);\n+        builder.install(&src.join(\"LICENSE.TXT\"), &overlay, 0o644);\n+        builder.create(&overlay.join(\"version\"), &builder.lldb_vers());\n+\n+        // Generate the installer tarball\n+        let mut cmd = rust_installer(builder);\n+        cmd.arg(\"generate\")\n+            .arg(\"--product-name=Rust\")\n+            .arg(\"--rel-manifest-dir=rustlib\")\n+            .arg(\"--success-message=lldb-installed.\")\n+            .arg(\"--image-dir\").arg(&image)\n+            .arg(\"--work-dir\").arg(&tmpdir(builder))\n+            .arg(\"--output-dir\").arg(&distdir(builder))\n+            .arg(\"--non-installed-overlay\").arg(&overlay)\n+            .arg(format!(\"--package-name={}-{}\", name, target))\n+            .arg(\"--legacy-manifest-dirs=rustlib,cargo\")\n+            .arg(\"--component-name=lldb-preview\");\n+\n+\n+        builder.run(&mut cmd);\n+        Some(distdir(builder).join(format!(\"{}-{}.tar.gz\", name, target)))\n+    }\n+}"}, {"sha": "ed9b5b1773fae0de01342200b363505902394a12", "filename": "src/bootstrap/doc.rs", "status": "modified", "additions": 327, "deletions": 141, "changes": 468, "blob_url": "https://github.com/rust-lang/rust/blob/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fbootstrap%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fbootstrap%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdoc.rs?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! Documentation generation for rustbuild.\n+//! Documentation generation for rustbuilder.\n //!\n //! This module implements generation for all bits and pieces of documentation\n //! for the Rust project. This notably includes suites like the rust book, the\n@@ -17,6 +17,7 @@\n //! Everything here is basically just a shim around calling either `rustbook` or\n //! `rustdoc`.\n \n+use std::collections::HashSet;\n use std::fs::{self, File};\n use std::io::prelude::*;\n use std::io;\n@@ -25,11 +26,12 @@ use std::path::{PathBuf, Path};\n use Mode;\n use build_helper::up_to_date;\n \n-use util::{cp_r, symlink_dir};\n+use util::symlink_dir;\n use builder::{Builder, Compiler, RunConfig, ShouldRun, Step};\n-use tool::Tool;\n+use tool::{self, prepare_tool_cargo, Tool, SourceType};\n use compile;\n use cache::{INTERNER, Interned};\n+use config::Config;\n \n macro_rules! book {\n     ($($name:ident, $path:expr, $book_name:expr;)+) => {\n@@ -45,7 +47,7 @@ macro_rules! book {\n \n             fn should_run(run: ShouldRun) -> ShouldRun {\n                 let builder = run.builder;\n-                run.path($path).default_condition(builder.build.config.docs)\n+                run.path($path).default_condition(builder.config.docs)\n             }\n \n             fn make_run(run: RunConfig) {\n@@ -68,7 +70,8 @@ macro_rules! book {\n book!(\n     Nomicon, \"src/doc/nomicon\", \"nomicon\";\n     Reference, \"src/doc/reference\", \"reference\";\n-    Rustdoc, \"src/doc/rustdoc\", \"rustdoc\";\n+    RustdocBook, \"src/doc/rustdoc\", \"rustdoc\";\n+    RustcBook, \"src/doc/rustc\", \"rustc\";\n     RustByExample, \"src/doc/rust-by-example\", \"rust-by-example\";\n );\n \n@@ -92,7 +95,7 @@ impl Step for Rustbook {\n     /// This will not actually generate any documentation if the documentation has\n     /// already been generated.\n     fn run(self, builder: &Builder) {\n-        let src = builder.build.src.join(\"src/doc\");\n+        let src = builder.src.join(\"src/doc\");\n         builder.ensure(RustbookSrc {\n             target: self.target,\n             name: self.name,\n@@ -112,7 +115,7 @@ impl Step for UnstableBook {\n \n     fn should_run(run: ShouldRun) -> ShouldRun {\n         let builder = run.builder;\n-        run.path(\"src/doc/unstable-book\").default_condition(builder.build.config.docs)\n+        run.path(\"src/doc/unstable-book\").default_condition(builder.config.docs)\n     }\n \n     fn make_run(run: RunConfig) {\n@@ -128,7 +131,7 @@ impl Step for UnstableBook {\n         builder.ensure(RustbookSrc {\n             target: self.target,\n             name: INTERNER.intern_str(\"unstable-book\"),\n-            src: builder.build.md_doc_out(self.target),\n+            src: builder.md_doc_out(self.target),\n         })\n     }\n }\n@@ -145,7 +148,7 @@ impl Step for CargoBook {\n \n     fn should_run(run: ShouldRun) -> ShouldRun {\n         let builder = run.builder;\n-        run.path(\"src/tools/cargo/src/doc/book\").default_condition(builder.build.config.docs)\n+        run.path(\"src/tools/cargo/src/doc/book\").default_condition(builder.config.docs)\n     }\n \n     fn make_run(run: RunConfig) {\n@@ -156,22 +159,20 @@ impl Step for CargoBook {\n     }\n \n     fn run(self, builder: &Builder) {\n-        let build = builder.build;\n-\n         let target = self.target;\n         let name = self.name;\n-        let src = build.src.join(\"src/tools/cargo/src/doc/book\");\n+        let src = builder.src.join(\"src/tools/cargo/src/doc\");\n \n-        let out = build.doc_out(target);\n+        let out = builder.doc_out(target);\n         t!(fs::create_dir_all(&out));\n \n         let out = out.join(name);\n \n-        println!(\"Cargo Book ({}) - {}\", target, name);\n+        builder.info(&format!(\"Cargo Book ({}) - {}\", target, name));\n \n         let _ = fs::remove_dir_all(&out);\n \n-        build.run(builder.tool_cmd(Tool::Rustbook)\n+        builder.run(builder.tool_cmd(Tool::Rustbook)\n                        .arg(\"build\")\n                        .arg(&src)\n                        .arg(\"-d\")\n@@ -198,23 +199,23 @@ impl Step for RustbookSrc {\n     /// This will not actually generate any documentation if the documentation has\n     /// already been generated.\n     fn run(self, builder: &Builder) {\n-        let build = builder.build;\n         let target = self.target;\n         let name = self.name;\n         let src = self.src;\n-        let out = build.doc_out(target);\n+        let out = builder.doc_out(target);\n         t!(fs::create_dir_all(&out));\n \n         let out = out.join(name);\n         let src = src.join(name);\n         let index = out.join(\"index.html\");\n         let rustbook = builder.tool_exe(Tool::Rustbook);\n+        let mut rustbook_cmd = builder.tool_cmd(Tool::Rustbook);\n         if up_to_date(&src, &index) && up_to_date(&rustbook, &index) {\n             return\n         }\n-        println!(\"Rustbook ({}) - {}\", target, name);\n+        builder.info(&format!(\"Rustbook ({}) - {}\", target, name));\n         let _ = fs::remove_dir_all(&out);\n-        build.run(builder.tool_cmd(Tool::Rustbook)\n+        builder.run(rustbook_cmd\n                        .arg(\"build\")\n                        .arg(&src)\n                        .arg(\"-d\")\n@@ -235,12 +236,12 @@ impl Step for TheBook {\n \n     fn should_run(run: ShouldRun) -> ShouldRun {\n         let builder = run.builder;\n-        run.path(\"src/doc/book\").default_condition(builder.build.config.docs)\n+        run.path(\"src/doc/book\").default_condition(builder.config.docs)\n     }\n \n     fn make_run(run: RunConfig) {\n         run.builder.ensure(TheBook {\n-            compiler: run.builder.compiler(run.builder.top_stage, run.builder.build.build),\n+            compiler: run.builder.compiler(run.builder.top_stage, run.builder.config.build),\n             target: run.target,\n             name: \"book\",\n         });\n@@ -256,7 +257,6 @@ impl Step for TheBook {\n     /// * Index page\n     /// * Redirect pages\n     fn run(self, builder: &Builder) {\n-        let build = builder.build;\n         let compiler = self.compiler;\n         let target = self.target;\n         let name = self.name;\n@@ -272,6 +272,12 @@ impl Step for TheBook {\n             name: INTERNER.intern_string(format!(\"{}/second-edition\", name)),\n         });\n \n+        // build book 2018 edition\n+        builder.ensure(Rustbook {\n+            target,\n+            name: INTERNER.intern_string(format!(\"{}/2018-edition\", name)),\n+        });\n+\n         // build the version info page and CSS\n         builder.ensure(Standalone {\n             compiler,\n@@ -280,12 +286,12 @@ impl Step for TheBook {\n \n         // build the index page\n         let index = format!(\"{}/index.md\", name);\n-        println!(\"Documenting book index ({})\", target);\n+        builder.info(&format!(\"Documenting book index ({})\", target));\n         invoke_rustdoc(builder, compiler, target, &index);\n \n         // build the redirect pages\n-        println!(\"Documenting book redirect pages ({})\", target);\n-        for file in t!(fs::read_dir(build.src.join(\"src/doc/book/redirects\"))) {\n+        builder.info(&format!(\"Documenting book redirect pages ({})\", target));\n+        for file in t!(fs::read_dir(builder.src.join(\"src/doc/book/redirects\"))) {\n             let file = t!(file);\n             let path = file.path();\n             let path = path.to_str().unwrap();\n@@ -296,13 +302,12 @@ impl Step for TheBook {\n }\n \n fn invoke_rustdoc(builder: &Builder, compiler: Compiler, target: Interned<String>, markdown: &str) {\n-    let build = builder.build;\n-    let out = build.doc_out(target);\n+    let out = builder.doc_out(target);\n \n-    let path = build.src.join(\"src/doc\").join(markdown);\n+    let path = builder.src.join(\"src/doc\").join(markdown);\n \n-    let favicon = build.src.join(\"src/doc/favicon.inc\");\n-    let footer = build.src.join(\"src/doc/footer.inc\");\n+    let favicon = builder.src.join(\"src/doc/favicon.inc\");\n+    let footer = builder.src.join(\"src/doc/footer.inc\");\n     let version_info = out.join(\"version_info.html\");\n \n     let mut cmd = builder.rustdoc_cmd(compiler.host);\n@@ -312,14 +317,15 @@ fn invoke_rustdoc(builder: &Builder, compiler: Compiler, target: Interned<String\n     cmd.arg(\"--html-after-content\").arg(&footer)\n         .arg(\"--html-before-content\").arg(&version_info)\n         .arg(\"--html-in-header\").arg(&favicon)\n+        .arg(\"--markdown-no-toc\")\n         .arg(\"--markdown-playground-url\")\n         .arg(\"https://play.rust-lang.org/\")\n         .arg(\"-o\").arg(&out)\n         .arg(&path)\n         .arg(\"--markdown-css\")\n         .arg(\"../rust.css\");\n \n-    build.run(&mut cmd);\n+    builder.run(&mut cmd);\n }\n \n #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n@@ -334,12 +340,12 @@ impl Step for Standalone {\n \n     fn should_run(run: ShouldRun) -> ShouldRun {\n         let builder = run.builder;\n-        run.path(\"src/doc\").default_condition(builder.build.config.docs)\n+        run.path(\"src/doc\").default_condition(builder.config.docs)\n     }\n \n     fn make_run(run: RunConfig) {\n         run.builder.ensure(Standalone {\n-            compiler: run.builder.compiler(run.builder.top_stage, run.builder.build.build),\n+            compiler: run.builder.compiler(run.builder.top_stage, run.builder.config.build),\n             target: run.target,\n         });\n     }\n@@ -353,31 +359,30 @@ impl Step for Standalone {\n     ///\n     /// In the end, this is just a glorified wrapper around rustdoc!\n     fn run(self, builder: &Builder) {\n-        let build = builder.build;\n         let target = self.target;\n         let compiler = self.compiler;\n-        println!(\"Documenting standalone ({})\", target);\n-        let out = build.doc_out(target);\n+        builder.info(&format!(\"Documenting standalone ({})\", target));\n+        let out = builder.doc_out(target);\n         t!(fs::create_dir_all(&out));\n \n-        let favicon = build.src.join(\"src/doc/favicon.inc\");\n-        let footer = build.src.join(\"src/doc/footer.inc\");\n-        let full_toc = build.src.join(\"src/doc/full-toc.inc\");\n-        t!(fs::copy(build.src.join(\"src/doc/rust.css\"), out.join(\"rust.css\")));\n+        let favicon = builder.src.join(\"src/doc/favicon.inc\");\n+        let footer = builder.src.join(\"src/doc/footer.inc\");\n+        let full_toc = builder.src.join(\"src/doc/full-toc.inc\");\n+        t!(fs::copy(builder.src.join(\"src/doc/rust.css\"), out.join(\"rust.css\")));\n \n-        let version_input = build.src.join(\"src/doc/version_info.html.template\");\n+        let version_input = builder.src.join(\"src/doc/version_info.html.template\");\n         let version_info = out.join(\"version_info.html\");\n \n-        if !up_to_date(&version_input, &version_info) {\n+        if !builder.config.dry_run && !up_to_date(&version_input, &version_info) {\n             let mut info = String::new();\n             t!(t!(File::open(&version_input)).read_to_string(&mut info));\n-            let info = info.replace(\"VERSION\", &build.rust_release())\n-                           .replace(\"SHORT_HASH\", build.rust_info.sha_short().unwrap_or(\"\"))\n-                           .replace(\"STAMP\", build.rust_info.sha().unwrap_or(\"\"));\n+            let info = info.replace(\"VERSION\", &builder.rust_release())\n+                           .replace(\"SHORT_HASH\", builder.rust_info.sha_short().unwrap_or(\"\"))\n+                           .replace(\"STAMP\", builder.rust_info.sha().unwrap_or(\"\"));\n             t!(t!(File::create(&version_info)).write_all(info.as_bytes()));\n         }\n \n-        for file in t!(fs::read_dir(build.src.join(\"src/doc\"))) {\n+        for file in t!(fs::read_dir(builder.src.join(\"src/doc\"))) {\n             let file = t!(file);\n             let path = file.path();\n             let filename = path.file_name().unwrap().to_str().unwrap();\n@@ -392,7 +397,7 @@ impl Step for Standalone {\n                up_to_date(&favicon, &html) &&\n                up_to_date(&full_toc, &html) &&\n                up_to_date(&version_info, &html) &&\n-               up_to_date(&rustdoc, &html) {\n+               (builder.config.dry_run || up_to_date(&rustdoc, &html)) {\n                 continue\n             }\n \n@@ -412,15 +417,15 @@ impl Step for Standalone {\n             } else {\n                 cmd.arg(\"--markdown-css\").arg(\"rust.css\");\n             }\n-            build.run(&mut cmd);\n+            builder.run(&mut cmd);\n         }\n     }\n }\n \n #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n pub struct Std {\n-    stage: u32,\n-    target: Interned<String>,\n+    pub stage: u32,\n+    pub target: Interned<String>,\n }\n \n impl Step for Std {\n@@ -429,7 +434,7 @@ impl Step for Std {\n \n     fn should_run(run: ShouldRun) -> ShouldRun {\n         let builder = run.builder;\n-        run.krate(\"std\").default_condition(builder.build.config.docs)\n+        run.all_krates(\"std\").default_condition(builder.config.docs)\n     }\n \n     fn make_run(run: RunConfig) {\n@@ -444,22 +449,21 @@ impl Step for Std {\n     /// This will generate all documentation for the standard library and its\n     /// dependencies. This is largely just a wrapper around `cargo doc`.\n     fn run(self, builder: &Builder) {\n-        let build = builder.build;\n         let stage = self.stage;\n         let target = self.target;\n-        println!(\"Documenting stage{} std ({})\", stage, target);\n-        let out = build.doc_out(target);\n+        builder.info(&format!(\"Documenting stage{} std ({})\", stage, target));\n+        let out = builder.doc_out(target);\n         t!(fs::create_dir_all(&out));\n-        let compiler = builder.compiler(stage, build.build);\n+        let compiler = builder.compiler(stage, builder.config.build);\n         let rustdoc = builder.rustdoc(compiler.host);\n-        let compiler = if build.force_use_stage1(compiler, target) {\n+        let compiler = if builder.force_use_stage1(compiler, target) {\n             builder.compiler(1, compiler.host)\n         } else {\n             compiler\n         };\n \n         builder.ensure(compile::Std { compiler, target });\n-        let out_dir = build.stage_out(compiler, Mode::Libstd)\n+        let out_dir = builder.stage_out(compiler, Mode::Std)\n                            .join(target).join(\"doc\");\n \n         // Here what we're doing is creating a *symlink* (directory junction on\n@@ -475,30 +479,26 @@ impl Step for Std {\n         //\n         // This way rustdoc generates output directly into the output, and rustdoc\n         // will also directly handle merging.\n-        let my_out = build.crate_doc_out(target);\n-        build.clear_if_dirty(&my_out, &rustdoc);\n-        t!(symlink_dir_force(&my_out, &out_dir));\n-\n-        let mut cargo = builder.cargo(compiler, Mode::Libstd, target, \"doc\");\n-        compile::std_cargo(build, &compiler, target, &mut cargo);\n-\n-        // We don't want to build docs for internal std dependencies unless\n-        // in compiler-docs mode. When not in that mode, we whitelist the crates\n-        // for which docs must be built.\n-        if !build.config.compiler_docs {\n-            cargo.arg(\"--no-deps\");\n-            for krate in &[\"alloc\", \"core\", \"std\", \"std_unicode\"] {\n-                cargo.arg(\"-p\").arg(krate);\n-                // Create all crate output directories first to make sure rustdoc uses\n-                // relative links.\n-                // FIXME: Cargo should probably do this itself.\n-                t!(fs::create_dir_all(out_dir.join(krate)));\n-            }\n+        let my_out = builder.crate_doc_out(target);\n+        builder.clear_if_dirty(&my_out, &rustdoc);\n+        t!(symlink_dir_force(&builder.config, &my_out, &out_dir));\n+\n+        let mut cargo = builder.cargo(compiler, Mode::Std, target, \"doc\");\n+        compile::std_cargo(builder, &compiler, target, &mut cargo);\n+\n+        // Keep a whitelist so we do not build internal stdlib crates, these will be\n+        // build by the rustc step later if enabled.\n+        cargo.arg(\"--no-deps\");\n+        for krate in &[\"alloc\", \"core\", \"std\"] {\n+            cargo.arg(\"-p\").arg(krate);\n+            // Create all crate output directories first to make sure rustdoc uses\n+            // relative links.\n+            // FIXME: Cargo should probably do this itself.\n+            t!(fs::create_dir_all(out_dir.join(krate)));\n         }\n \n-\n-        build.run(&mut cargo);\n-        cp_r(&my_out, &out);\n+        builder.run(&mut cargo);\n+        builder.cp_r(&my_out, &out);\n     }\n }\n \n@@ -514,7 +514,7 @@ impl Step for Test {\n \n     fn should_run(run: ShouldRun) -> ShouldRun {\n         let builder = run.builder;\n-        run.krate(\"test\").default_condition(builder.config.compiler_docs)\n+        run.krate(\"test\").default_condition(builder.config.docs)\n     }\n \n     fn make_run(run: RunConfig) {\n@@ -529,15 +529,14 @@ impl Step for Test {\n     /// This will generate all documentation for libtest and its dependencies. This\n     /// is largely just a wrapper around `cargo doc`.\n     fn run(self, builder: &Builder) {\n-        let build = builder.build;\n         let stage = self.stage;\n         let target = self.target;\n-        println!(\"Documenting stage{} test ({})\", stage, target);\n-        let out = build.doc_out(target);\n+        builder.info(&format!(\"Documenting stage{} test ({})\", stage, target));\n+        let out = builder.doc_out(target);\n         t!(fs::create_dir_all(&out));\n-        let compiler = builder.compiler(stage, build.build);\n+        let compiler = builder.compiler(stage, builder.config.build);\n         let rustdoc = builder.rustdoc(compiler.host);\n-        let compiler = if build.force_use_stage1(compiler, target) {\n+        let compiler = if builder.force_use_stage1(compiler, target) {\n             builder.compiler(1, compiler.host)\n         } else {\n             compiler\n@@ -547,58 +546,65 @@ impl Step for Test {\n         builder.ensure(Std { stage, target });\n \n         builder.ensure(compile::Test { compiler, target });\n-        let out_dir = build.stage_out(compiler, Mode::Libtest)\n+        let out_dir = builder.stage_out(compiler, Mode::Test)\n                            .join(target).join(\"doc\");\n \n         // See docs in std above for why we symlink\n-        let my_out = build.crate_doc_out(target);\n-        build.clear_if_dirty(&my_out, &rustdoc);\n-        t!(symlink_dir_force(&my_out, &out_dir));\n+        let my_out = builder.crate_doc_out(target);\n+        builder.clear_if_dirty(&my_out, &rustdoc);\n+        t!(symlink_dir_force(&builder.config, &my_out, &out_dir));\n \n-        let mut cargo = builder.cargo(compiler, Mode::Libtest, target, \"doc\");\n-        compile::test_cargo(build, &compiler, target, &mut cargo);\n-        build.run(&mut cargo);\n-        cp_r(&my_out, &out);\n+        let mut cargo = builder.cargo(compiler, Mode::Test, target, \"doc\");\n+        compile::test_cargo(builder, &compiler, target, &mut cargo);\n+\n+        cargo.arg(\"--no-deps\").arg(\"-p\").arg(\"test\");\n+\n+        builder.run(&mut cargo);\n+        builder.cp_r(&my_out, &out);\n     }\n }\n \n #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n-pub struct Rustc {\n+pub struct WhitelistedRustc {\n     stage: u32,\n     target: Interned<String>,\n }\n \n-impl Step for Rustc {\n+impl Step for WhitelistedRustc {\n     type Output = ();\n     const DEFAULT: bool = true;\n     const ONLY_HOSTS: bool = true;\n \n     fn should_run(run: ShouldRun) -> ShouldRun {\n         let builder = run.builder;\n-        run.krate(\"rustc-main\").default_condition(builder.build.config.docs)\n+        run.krate(\"rustc-main\").default_condition(builder.config.docs)\n     }\n \n     fn make_run(run: RunConfig) {\n-        run.builder.ensure(Rustc {\n+        run.builder.ensure(WhitelistedRustc {\n             stage: run.builder.top_stage,\n             target: run.target,\n         });\n     }\n \n-    /// Generate all compiler documentation.\n+    /// Generate whitelisted compiler crate documentation.\n     ///\n-    /// This will generate all documentation for the compiler libraries and their\n-    /// dependencies. This is largely just a wrapper around `cargo doc`.\n+    /// This will generate all documentation for crates that are whitelisted\n+    /// to be included in the standard documentation. This documentation is\n+    /// included in the standard Rust documentation, so we should always\n+    /// document it and symlink to merge with the rest of the std and test\n+    /// documentation. We don't build other compiler documentation\n+    /// here as we want to be able to keep it separate from the standard\n+    /// documentation. This is largely just a wrapper around `cargo doc`.\n     fn run(self, builder: &Builder) {\n-        let build = builder.build;\n         let stage = self.stage;\n         let target = self.target;\n-        println!(\"Documenting stage{} compiler ({})\", stage, target);\n-        let out = build.doc_out(target);\n+        builder.info(&format!(\"Documenting stage{} whitelisted compiler ({})\", stage, target));\n+        let out = builder.doc_out(target);\n         t!(fs::create_dir_all(&out));\n-        let compiler = builder.compiler(stage, build.build);\n+        let compiler = builder.compiler(stage, builder.config.build);\n         let rustdoc = builder.rustdoc(compiler.host);\n-        let compiler = if build.force_use_stage1(compiler, target) {\n+        let compiler = if builder.force_use_stage1(compiler, target) {\n             builder.compiler(1, compiler.host)\n         } else {\n             compiler\n@@ -608,32 +614,211 @@ impl Step for Rustc {\n         builder.ensure(Std { stage, target });\n \n         builder.ensure(compile::Rustc { compiler, target });\n-        let out_dir = build.stage_out(compiler, Mode::Librustc)\n+        let out_dir = builder.stage_out(compiler, Mode::Rustc)\n                            .join(target).join(\"doc\");\n \n         // See docs in std above for why we symlink\n-        let my_out = build.crate_doc_out(target);\n-        build.clear_if_dirty(&my_out, &rustdoc);\n-        t!(symlink_dir_force(&my_out, &out_dir));\n+        let my_out = builder.crate_doc_out(target);\n+        builder.clear_if_dirty(&my_out, &rustdoc);\n+        t!(symlink_dir_force(&builder.config, &my_out, &out_dir));\n+\n+        let mut cargo = builder.cargo(compiler, Mode::Rustc, target, \"doc\");\n+        compile::rustc_cargo(builder, &mut cargo);\n+\n+        // We don't want to build docs for internal compiler dependencies in this\n+        // step (there is another step for that). Therefore, we whitelist the crates\n+        // for which docs must be built.\n+        cargo.arg(\"--no-deps\");\n+        for krate in &[\"proc_macro\"] {\n+            cargo.arg(\"-p\").arg(krate);\n+        }\n+\n+        builder.run(&mut cargo);\n+        builder.cp_r(&my_out, &out);\n+    }\n+}\n+\n+#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n+pub struct Rustc {\n+    stage: u32,\n+    target: Interned<String>,\n+}\n \n-        let mut cargo = builder.cargo(compiler, Mode::Librustc, target, \"doc\");\n-        compile::rustc_cargo(build, target, &mut cargo);\n+impl Step for Rustc {\n+    type Output = ();\n+    const DEFAULT: bool = true;\n+    const ONLY_HOSTS: bool = true;\n \n-        if build.config.compiler_docs {\n-            // src/rustc/Cargo.toml contains a bin crate called rustc which\n-            // would otherwise overwrite the docs for the real rustc lib crate.\n-            cargo.arg(\"-p\").arg(\"rustc_driver\");\n+    fn should_run(run: ShouldRun) -> ShouldRun {\n+        let builder = run.builder;\n+        run.krate(\"rustc-main\").default_condition(builder.config.docs)\n+    }\n+\n+    fn make_run(run: RunConfig) {\n+        run.builder.ensure(Rustc {\n+            stage: run.builder.top_stage,\n+            target: run.target,\n+        });\n+    }\n+\n+    /// Generate compiler documentation.\n+    ///\n+    /// This will generate all documentation for compiler and dependencies.\n+    /// Compiler documentation is distributed separately, so we make sure\n+    /// we do not merge it with the other documentation from std, test and\n+    /// proc_macros. This is largely just a wrapper around `cargo doc`.\n+    fn run(self, builder: &Builder) {\n+        let stage = self.stage;\n+        let target = self.target;\n+        builder.info(&format!(\"Documenting stage{} compiler ({})\", stage, target));\n+\n+        // This is the intended out directory for compiler documentation.\n+        let out = builder.compiler_doc_out(target);\n+        t!(fs::create_dir_all(&out));\n+\n+        // Get the correct compiler for this stage.\n+        let compiler = builder.compiler(stage, builder.config.build);\n+        let rustdoc = builder.rustdoc(compiler.host);\n+        let compiler = if builder.force_use_stage1(compiler, target) {\n+            builder.compiler(1, compiler.host)\n         } else {\n-            // Like with libstd above if compiler docs aren't enabled then we're not\n-            // documenting internal dependencies, so we have a whitelist.\n-            cargo.arg(\"--no-deps\");\n-            for krate in &[\"proc_macro\"] {\n-                cargo.arg(\"-p\").arg(krate);\n-            }\n+            compiler\n+        };\n+\n+        if !builder.config.compiler_docs {\n+            builder.info(\"\\tskipping - compiler/librustdoc docs disabled\");\n+            return;\n+        }\n+\n+        // Build libstd docs so that we generate relative links.\n+        builder.ensure(Std { stage, target });\n+\n+        // Build rustc.\n+        builder.ensure(compile::Rustc { compiler, target });\n+\n+        // We do not symlink to the same shared folder that already contains std library\n+        // documentation from previous steps as we do not want to include that.\n+        let out_dir = builder.stage_out(compiler, Mode::Rustc).join(target).join(\"doc\");\n+        builder.clear_if_dirty(&out, &rustdoc);\n+        t!(symlink_dir_force(&builder.config, &out, &out_dir));\n+\n+        // Build cargo command.\n+        let mut cargo = builder.cargo(compiler, Mode::Rustc, target, \"doc\");\n+        cargo.env(\"RUSTDOCFLAGS\", \"--document-private-items\");\n+        compile::rustc_cargo(builder, &mut cargo);\n+\n+        // Only include compiler crates, no dependencies of those, such as `libc`.\n+        cargo.arg(\"--no-deps\");\n+\n+        // Find dependencies for top level crates.\n+        let mut compiler_crates = HashSet::new();\n+        for root_crate in &[\"rustc\", \"rustc_driver\"] {\n+            let interned_root_crate = INTERNER.intern_str(root_crate);\n+            find_compiler_crates(builder, &interned_root_crate, &mut compiler_crates);\n+        }\n+\n+        for krate in &compiler_crates {\n+            cargo.arg(\"-p\").arg(krate);\n+        }\n+\n+        builder.run(&mut cargo);\n+    }\n+}\n+\n+fn find_compiler_crates(\n+    builder: &Builder,\n+    name: &Interned<String>,\n+    crates: &mut HashSet<Interned<String>>\n+) {\n+    // Add current crate.\n+    crates.insert(*name);\n+\n+    // Look for dependencies.\n+    for dep in builder.crates.get(name).unwrap().deps.iter() {\n+        if builder.crates.get(dep).unwrap().is_local(builder) {\n+            find_compiler_crates(builder, dep, crates);\n+        }\n+    }\n+}\n+\n+#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n+pub struct Rustdoc {\n+    stage: u32,\n+    target: Interned<String>,\n+}\n+\n+impl Step for Rustdoc {\n+    type Output = ();\n+    const DEFAULT: bool = true;\n+    const ONLY_HOSTS: bool = true;\n+\n+    fn should_run(run: ShouldRun) -> ShouldRun {\n+        run.krate(\"rustdoc-tool\")\n+    }\n+\n+    fn make_run(run: RunConfig) {\n+        run.builder.ensure(Rustdoc {\n+            stage: run.builder.top_stage,\n+            target: run.target,\n+        });\n+    }\n+\n+    /// Generate compiler documentation.\n+    ///\n+    /// This will generate all documentation for compiler and dependencies.\n+    /// Compiler documentation is distributed separately, so we make sure\n+    /// we do not merge it with the other documentation from std, test and\n+    /// proc_macros. This is largely just a wrapper around `cargo doc`.\n+    fn run(self, builder: &Builder) {\n+        let stage = self.stage;\n+        let target = self.target;\n+        builder.info(&format!(\"Documenting stage{} rustdoc ({})\", stage, target));\n+\n+        // This is the intended out directory for compiler documentation.\n+        let out = builder.compiler_doc_out(target);\n+        t!(fs::create_dir_all(&out));\n+\n+        // Get the correct compiler for this stage.\n+        let compiler = builder.compiler(stage, builder.config.build);\n+        let rustdoc = builder.rustdoc(compiler.host);\n+        let compiler = if builder.force_use_stage1(compiler, target) {\n+            builder.compiler(1, compiler.host)\n+        } else {\n+            compiler\n+        };\n+\n+        if !builder.config.compiler_docs {\n+            builder.info(\"\\tskipping - compiler/librustdoc docs disabled\");\n+            return;\n         }\n \n-        build.run(&mut cargo);\n-        cp_r(&my_out, &out);\n+        // Build libstd docs so that we generate relative links.\n+        builder.ensure(Std { stage, target });\n+\n+        // Build rustdoc.\n+        builder.ensure(tool::Rustdoc { host: compiler.host });\n+\n+        // Symlink compiler docs to the output directory of rustdoc documentation.\n+        let out_dir = builder.stage_out(compiler, Mode::ToolRustc)\n+            .join(target)\n+            .join(\"doc\");\n+        t!(fs::create_dir_all(&out_dir));\n+        builder.clear_if_dirty(&out, &rustdoc);\n+        t!(symlink_dir_force(&builder.config, &out, &out_dir));\n+\n+        // Build cargo command.\n+        let mut cargo = prepare_tool_cargo(\n+            builder,\n+            compiler,\n+            Mode::ToolRustc,\n+            target,\n+            \"doc\",\n+            \"src/tools/rustdoc\",\n+            SourceType::InTree,\n+        );\n+\n+        cargo.env(\"RUSTDOCFLAGS\", \"--document-private-items\");\n+        builder.run(&mut cargo);\n     }\n }\n \n@@ -649,7 +834,7 @@ impl Step for ErrorIndex {\n \n     fn should_run(run: ShouldRun) -> ShouldRun {\n         let builder = run.builder;\n-        run.path(\"src/tools/error_index_generator\").default_condition(builder.build.config.docs)\n+        run.path(\"src/tools/error_index_generator\").default_condition(builder.config.docs)\n     }\n \n     fn make_run(run: RunConfig) {\n@@ -661,21 +846,20 @@ impl Step for ErrorIndex {\n     /// Generates the HTML rendered error-index by running the\n     /// `error_index_generator` tool.\n     fn run(self, builder: &Builder) {\n-        let build = builder.build;\n         let target = self.target;\n \n-        println!(\"Documenting error index ({})\", target);\n-        let out = build.doc_out(target);\n+        builder.info(&format!(\"Documenting error index ({})\", target));\n+        let out = builder.doc_out(target);\n         t!(fs::create_dir_all(&out));\n         let mut index = builder.tool_cmd(Tool::ErrorIndex);\n         index.arg(\"html\");\n         index.arg(out.join(\"error-index.html\"));\n \n         // FIXME: shouldn't have to pass this env var\n-        index.env(\"CFG_BUILD\", &build.build)\n-             .env(\"RUSTC_ERROR_METADATA_DST\", build.extended_error_dir());\n+        index.env(\"CFG_BUILD\", &builder.config.build)\n+             .env(\"RUSTC_ERROR_METADATA_DST\", builder.extended_error_dir());\n \n-        build.run(&mut index);\n+        builder.run(&mut index);\n     }\n }\n \n@@ -691,7 +875,7 @@ impl Step for UnstableBookGen {\n \n     fn should_run(run: ShouldRun) -> ShouldRun {\n         let builder = run.builder;\n-        run.path(\"src/tools/unstable-book-gen\").default_condition(builder.build.config.docs)\n+        run.path(\"src/tools/unstable-book-gen\").default_condition(builder.config.docs)\n     }\n \n     fn make_run(run: RunConfig) {\n@@ -701,27 +885,29 @@ impl Step for UnstableBookGen {\n     }\n \n     fn run(self, builder: &Builder) {\n-        let build = builder.build;\n         let target = self.target;\n \n         builder.ensure(compile::Std {\n-            compiler: builder.compiler(builder.top_stage, build.build),\n+            compiler: builder.compiler(builder.top_stage, builder.config.build),\n             target,\n         });\n \n-        println!(\"Generating unstable book md files ({})\", target);\n-        let out = build.md_doc_out(target).join(\"unstable-book\");\n-        t!(fs::create_dir_all(&out));\n-        t!(fs::remove_dir_all(&out));\n+        builder.info(&format!(\"Generating unstable book md files ({})\", target));\n+        let out = builder.md_doc_out(target).join(\"unstable-book\");\n+        builder.create_dir(&out);\n+        builder.remove_dir(&out);\n         let mut cmd = builder.tool_cmd(Tool::UnstableBookGen);\n-        cmd.arg(build.src.join(\"src\"));\n+        cmd.arg(builder.src.join(\"src\"));\n         cmd.arg(out);\n \n-        build.run(&mut cmd);\n+        builder.run(&mut cmd);\n     }\n }\n \n-fn symlink_dir_force(src: &Path, dst: &Path) -> io::Result<()> {\n+fn symlink_dir_force(config: &Config, src: &Path, dst: &Path) -> io::Result<()> {\n+    if config.dry_run {\n+        return Ok(());\n+    }\n     if let Ok(m) = fs::symlink_metadata(dst) {\n         if m.file_type().is_dir() {\n             try!(fs::remove_dir_all(dst));\n@@ -734,5 +920,5 @@ fn symlink_dir_force(src: &Path, dst: &Path) -> io::Result<()> {\n         }\n     }\n \n-    symlink_dir(src, dst)\n+    symlink_dir(config, src, dst)\n }"}, {"sha": "60b4d65f444014133bd81262a7cbdcabea84bdfe", "filename": "src/bootstrap/flags.rs", "status": "modified", "additions": 218, "deletions": 98, "changes": 316, "blob_url": "https://github.com/rust-lang/rust/blob/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fbootstrap%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fbootstrap%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fflags.rs?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd", "patch": "@@ -13,48 +13,59 @@\n //! This module implements the command-line parsing of the build system which\n //! has various flags to configure how it's run.\n \n-use std::env;\n use std::fs;\n use std::path::PathBuf;\n use std::process;\n \n use getopts::Options;\n \n-use Build;\n+use builder::Builder;\n use config::Config;\n use metadata;\n-use builder::Builder;\n+use {Build, DocTests};\n \n use cache::{Interned, INTERNER};\n \n /// Deserialized version of all flags for this compile.\n pub struct Flags {\n-    pub verbose: usize, // verbosity level: 0 == not verbose, 1 == verbose, 2 == very verbose\n+    pub verbose: usize, // number of -v args; each extra -v after the first is passed to Cargo\n     pub on_fail: Option<String>,\n     pub stage: Option<u32>,\n-    pub keep_stage: Option<u32>,\n-    pub build: Option<Interned<String>>,\n+    pub keep_stage: Vec<u32>,\n \n     pub host: Vec<Interned<String>>,\n     pub target: Vec<Interned<String>>,\n     pub config: Option<PathBuf>,\n-    pub src: PathBuf,\n     pub jobs: Option<u32>,\n     pub cmd: Subcommand,\n     pub incremental: bool,\n+    pub exclude: Vec<PathBuf>,\n+    pub rustc_error_format: Option<String>,\n+    pub dry_run: bool,\n+\n+    // true => deny\n+    pub warnings: Option<bool>,\n }\n \n pub enum Subcommand {\n     Build {\n         paths: Vec<PathBuf>,\n     },\n+    Check {\n+        paths: Vec<PathBuf>,\n+    },\n     Doc {\n         paths: Vec<PathBuf>,\n     },\n     Test {\n         paths: Vec<PathBuf>,\n+        /// Whether to automatically update stderr/stdout files\n+        bless: bool,\n+        compare_mode: Option<String>,\n         test_args: Vec<String>,\n+        rustc_args: Vec<String>,\n         fail_fast: bool,\n+        doc_tests: DocTests,\n     },\n     Bench {\n         paths: Vec<PathBuf>,\n@@ -82,19 +93,22 @@ impl Default for Subcommand {\n impl Flags {\n     pub fn parse(args: &[String]) -> Flags {\n         let mut extra_help = String::new();\n-        let mut subcommand_help = format!(\"\\\n+        let mut subcommand_help = format!(\n+            \"\\\n Usage: x.py <subcommand> [options] [<paths>...]\n \n Subcommands:\n     build       Compile either the compiler or libraries\n+    check       Compile either the compiler or libraries, using cargo check\n     test        Build and run some test suites\n     bench       Build and run some benchmarks\n     doc         Build documentation\n     clean       Clean out build directories\n     dist        Build distribution artifacts\n     install     Install distribution artifacts\n \n-To learn more about a subcommand, run `./x.py <subcommand> -h`\");\n+To learn more about a subcommand, run `./x.py <subcommand> -h`\"\n+        );\n \n         let mut opts = Options::new();\n         // Options common to all subcommands\n@@ -104,35 +118,50 @@ To learn more about a subcommand, run `./x.py <subcommand> -h`\");\n         opts.optopt(\"\", \"build\", \"build target of the stage0 compiler\", \"BUILD\");\n         opts.optmulti(\"\", \"host\", \"host targets to build\", \"HOST\");\n         opts.optmulti(\"\", \"target\", \"target targets to build\", \"TARGET\");\n+        opts.optmulti(\"\", \"exclude\", \"build paths to exclude\", \"PATH\");\n         opts.optopt(\"\", \"on-fail\", \"command to run on failure\", \"CMD\");\n-        opts.optopt(\"\", \"stage\", \"stage to build\", \"N\");\n-        opts.optopt(\"\", \"keep-stage\", \"stage to keep without recompiling\", \"N\");\n+        opts.optflag(\"\", \"dry-run\", \"dry run; don't build anything\");\n+        opts.optopt(\"\", \"stage\",\n+            \"stage to build (indicates compiler to use/test, e.g. stage 0 uses the \\\n+             bootstrap compiler, stage 1 the stage 0 rustc artifacts, etc.)\",\n+            \"N\");\n+        opts.optmulti(\"\", \"keep-stage\", \"stage(s) to keep without recompiling\", \"N\");\n         opts.optopt(\"\", \"src\", \"path to the root of the rust checkout\", \"DIR\");\n         opts.optopt(\"j\", \"jobs\", \"number of jobs to run in parallel\", \"JOBS\");\n         opts.optflag(\"h\", \"help\", \"print this help message\");\n+        opts.optopt(\n+            \"\",\n+            \"warnings\",\n+            \"if value is deny, will deny warnings, otherwise use default\",\n+            \"VALUE\",\n+        );\n+        opts.optopt(\"\", \"error-format\", \"rustc error format\", \"FORMAT\");\n \n         // fn usage()\n-        let usage = |exit_code: i32, opts: &Options, subcommand_help: &str, extra_help: &str| -> ! {\n-            println!(\"{}\", opts.usage(subcommand_help));\n-            if !extra_help.is_empty() {\n-                println!(\"{}\", extra_help);\n-            }\n-            process::exit(exit_code);\n-        };\n+        let usage =\n+            |exit_code: i32, opts: &Options, subcommand_help: &str, extra_help: &str| -> ! {\n+                println!(\"{}\", opts.usage(subcommand_help));\n+                if !extra_help.is_empty() {\n+                    println!(\"{}\", extra_help);\n+                }\n+                process::exit(exit_code);\n+            };\n \n         // We can't use getopt to parse the options until we have completed specifying which\n         // options are valid, but under the current implementation, some options are conditional on\n         // the subcommand. Therefore we must manually identify the subcommand first, so that we can\n         // complete the definition of the options.  Then we can use the getopt::Matches object from\n         // there on out.\n-        let subcommand = args.iter().find(|&s|\n+        let subcommand = args.iter().find(|&s| {\n             (s == \"build\")\n-            || (s == \"test\")\n-            || (s == \"bench\")\n-            || (s == \"doc\")\n-            || (s == \"clean\")\n-            || (s == \"dist\")\n-            || (s == \"install\"));\n+                || (s == \"check\")\n+                || (s == \"test\")\n+                || (s == \"bench\")\n+                || (s == \"doc\")\n+                || (s == \"clean\")\n+                || (s == \"dist\")\n+                || (s == \"install\")\n+        });\n         let subcommand = match subcommand {\n             Some(s) => s,\n             None => {\n@@ -147,13 +176,36 @@ To learn more about a subcommand, run `./x.py <subcommand> -h`\");\n \n         // Some subcommands get extra options\n         match subcommand.as_str() {\n-            \"test\"  => {\n+            \"test\" => {\n                 opts.optflag(\"\", \"no-fail-fast\", \"Run all tests regardless of failure\");\n                 opts.optmulti(\"\", \"test-args\", \"extra arguments\", \"ARGS\");\n-            },\n-            \"bench\" => { opts.optmulti(\"\", \"test-args\", \"extra arguments\", \"ARGS\"); },\n-            \"clean\" => { opts.optflag(\"\", \"all\", \"clean all build artifacts\"); },\n-            _ => { },\n+                opts.optmulti(\n+                    \"\",\n+                    \"rustc-args\",\n+                    \"extra options to pass the compiler when running tests\",\n+                    \"ARGS\",\n+                );\n+                opts.optflag(\"\", \"no-doc\", \"do not run doc tests\");\n+                opts.optflag(\"\", \"doc\", \"only run doc tests\");\n+                opts.optflag(\n+                    \"\",\n+                    \"bless\",\n+                    \"update all stderr/stdout files of failing ui tests\",\n+                );\n+                opts.optopt(\n+                    \"\",\n+                    \"compare-mode\",\n+                    \"mode describing what file the actual ui output will be compared to\",\n+                    \"COMPARE MODE\",\n+                );\n+            }\n+            \"bench\" => {\n+                opts.optmulti(\"\", \"test-args\", \"extra arguments\", \"ARGS\");\n+            }\n+            \"clean\" => {\n+                opts.optflag(\"\", \"all\", \"clean all build artifacts\");\n+            }\n+            _ => {}\n         };\n \n         // Done specifying what options are possible, so do the getopts parsing\n@@ -173,21 +225,24 @@ To learn more about a subcommand, run `./x.py <subcommand> -h`\");\n                 if check_subcommand != subcommand {\n                     pass_sanity_check = false;\n                 }\n-            },\n+            }\n             None => {\n                 pass_sanity_check = false;\n             }\n         }\n         if !pass_sanity_check {\n             println!(\"{}\\n\", subcommand_help);\n-            println!(\"Sorry, I couldn't figure out which subcommand you were trying to specify.\\n\\\n-                      You may need to move some options to after the subcommand.\\n\");\n+            println!(\n+                \"Sorry, I couldn't figure out which subcommand you were trying to specify.\\n\\\n+                 You may need to move some options to after the subcommand.\\n\"\n+            );\n             process::exit(1);\n         }\n         // Extra help text for some commands\n         match subcommand.as_str() {\n             \"build\" => {\n-                subcommand_help.push_str(\"\\n\n+                subcommand_help.push_str(\n+                    \"\\n\n Arguments:\n     This subcommand accepts a number of paths to directories to the crates\n     and/or artifacts to compile. For example:\n@@ -206,29 +261,56 @@ Arguments:\n \n         ./x.py build --stage 1 src/libtest\n \n-    This will first build everything once (like --stage 0 without further\n+    This will first build everything once (like `--stage 0` without further\n     arguments would), and then use the compiler built in stage 0 to build\n     src/libtest and its dependencies.\n-    Once this is done, build/$ARCH/stage1 contains a usable compiler.\");\n+    Once this is done, build/$ARCH/stage1 contains a usable compiler.\",\n+                );\n+            }\n+            \"check\" => {\n+                subcommand_help.push_str(\n+                    \"\\n\n+Arguments:\n+    This subcommand accepts a number of paths to directories to the crates\n+    and/or artifacts to compile. For example:\n+\n+        ./x.py check src/libcore\n+        ./x.py check src/libcore src/libproc_macro\n+\n+    If no arguments are passed then the complete artifacts are compiled: std, test, and rustc. Note\n+    also that since we use `cargo check`, by default this will automatically enable incremental\n+    compilation, so there's no need to pass it separately, though it won't hurt. We also completely\n+    ignore the stage passed, as there's no way to compile in non-stage 0 without actually building\n+    the compiler.\",\n+                );\n             }\n             \"test\" => {\n-                subcommand_help.push_str(\"\\n\n+                subcommand_help.push_str(\n+                    \"\\n\n Arguments:\n     This subcommand accepts a number of paths to directories to tests that\n     should be compiled and run. For example:\n \n         ./x.py test src/test/run-pass\n         ./x.py test src/libstd --test-args hash_map\n-        ./x.py test src/libstd --stage 0\n+        ./x.py test src/libstd --stage 0 --no-doc\n+        ./x.py test src/test/ui --bless\n+        ./x.py test src/test/ui --compare-mode nll\n+\n+    Note that `test src/test/* --stage N` does NOT depend on `build src/rustc --stage N`;\n+    just like `build src/libstd --stage N` it tests the compiler produced by the previous\n+    stage.\n \n     If no arguments are passed then the complete artifacts for that stage are\n     compiled and tested.\n \n         ./x.py test\n-        ./x.py test --stage 1\");\n+        ./x.py test --stage 1\",\n+                );\n             }\n             \"doc\" => {\n-                subcommand_help.push_str(\"\\n\n+                subcommand_help.push_str(\n+                    \"\\n\n Arguments:\n     This subcommand accepts a number of paths to directories of documentation\n     to build. For example:\n@@ -240,13 +322,16 @@ Arguments:\n     If no arguments are passed then everything is documented:\n \n         ./x.py doc\n-        ./x.py doc --stage 1\");\n+        ./x.py doc --stage 1\",\n+                );\n             }\n-            _ => { }\n+            _ => {}\n         };\n         // Get any optional paths which occur after the subcommand\n-        let cwd = t!(env::current_dir());\n-        let paths = matches.free[1..].iter().map(|p| cwd.join(p)).collect::<Vec<_>>();\n+        let paths = matches.free[1..]\n+            .iter()\n+            .map(|p| p.into())\n+            .collect::<Vec<PathBuf>>();\n \n         let cfg_file = matches.opt_str(\"config\").map(PathBuf::from).or_else(|| {\n             if fs::metadata(\"config.toml\").is_ok() {\n@@ -265,9 +350,12 @@ Arguments:\n             let maybe_rules_help = Builder::get_help(&build, subcommand.as_str());\n             extra_help.push_str(maybe_rules_help.unwrap_or_default().as_str());\n         } else if subcommand.as_str() != \"clean\" {\n-            extra_help.push_str(format!(\n-                \"Run `./x.py {} -h -v` to see a list of available paths.\",\n-                subcommand).as_str());\n+            extra_help.push_str(\n+                format!(\n+                    \"Run `./x.py {} -h -v` to see a list of available paths.\",\n+                    subcommand\n+                ).as_str(),\n+            );\n         }\n \n         // User passed in -h/--help?\n@@ -276,25 +364,28 @@ Arguments:\n         }\n \n         let cmd = match subcommand.as_str() {\n-            \"build\" => {\n-                Subcommand::Build { paths: paths }\n-            }\n-            \"test\" => {\n-                Subcommand::Test {\n-                    paths,\n-                    test_args: matches.opt_strs(\"test-args\"),\n-                    fail_fast: !matches.opt_present(\"no-fail-fast\"),\n-                }\n-            }\n-            \"bench\" => {\n-                Subcommand::Bench {\n-                    paths,\n-                    test_args: matches.opt_strs(\"test-args\"),\n-                }\n-            }\n-            \"doc\" => {\n-                Subcommand::Doc { paths: paths }\n-            }\n+            \"build\" => Subcommand::Build { paths: paths },\n+            \"check\" => Subcommand::Check { paths: paths },\n+            \"test\" => Subcommand::Test {\n+                paths,\n+                bless: matches.opt_present(\"bless\"),\n+                compare_mode: matches.opt_str(\"compare-mode\"),\n+                test_args: matches.opt_strs(\"test-args\"),\n+                rustc_args: matches.opt_strs(\"rustc-args\"),\n+                fail_fast: !matches.opt_present(\"no-fail-fast\"),\n+                doc_tests: if matches.opt_present(\"doc\") {\n+                    DocTests::Only\n+                } else if matches.opt_present(\"no-doc\") {\n+                    DocTests::No\n+                } else {\n+                    DocTests::Yes\n+                },\n+            },\n+            \"bench\" => Subcommand::Bench {\n+                paths,\n+                test_args: matches.opt_strs(\"test-args\"),\n+            },\n+            \"doc\" => Subcommand::Doc { paths: paths },\n             \"clean\" => {\n                 if paths.len() > 0 {\n                     println!(\"\\nclean does not take a path argument\\n\");\n@@ -305,71 +396,100 @@ Arguments:\n                     all: matches.opt_present(\"all\"),\n                 }\n             }\n-            \"dist\" => {\n-                Subcommand::Dist {\n-                    paths,\n-                }\n-            }\n-            \"install\" => {\n-                Subcommand::Install {\n-                    paths,\n-                }\n-            }\n+            \"dist\" => Subcommand::Dist { paths },\n+            \"install\" => Subcommand::Install { paths },\n             _ => {\n                 usage(1, &opts, &subcommand_help, &extra_help);\n             }\n         };\n \n-\n-        let mut stage = matches.opt_str(\"stage\").map(|j| j.parse().unwrap());\n-\n-        if matches.opt_present(\"incremental\") && stage.is_none() {\n-            stage = Some(1);\n-        }\n-\n-        let cwd = t!(env::current_dir());\n-        let src = matches.opt_str(\"src\").map(PathBuf::from)\n-            .or_else(|| env::var_os(\"SRC\").map(PathBuf::from))\n-            .unwrap_or(cwd);\n-\n         Flags {\n             verbose: matches.opt_count(\"verbose\"),\n-            stage,\n+            stage: matches.opt_str(\"stage\").map(|j| j.parse().unwrap()),\n+            dry_run: matches.opt_present(\"dry-run\"),\n             on_fail: matches.opt_str(\"on-fail\"),\n-            keep_stage: matches.opt_str(\"keep-stage\").map(|j| j.parse().unwrap()),\n-            build: matches.opt_str(\"build\").map(|s| INTERNER.intern_string(s)),\n+            rustc_error_format: matches.opt_str(\"error-format\"),\n+            keep_stage: matches.opt_strs(\"keep-stage\")\n+                .into_iter().map(|j| j.parse().unwrap())\n+                .collect(),\n             host: split(matches.opt_strs(\"host\"))\n-                .into_iter().map(|x| INTERNER.intern_string(x)).collect::<Vec<_>>(),\n+                .into_iter()\n+                .map(|x| INTERNER.intern_string(x))\n+                .collect::<Vec<_>>(),\n             target: split(matches.opt_strs(\"target\"))\n-                .into_iter().map(|x| INTERNER.intern_string(x)).collect::<Vec<_>>(),\n+                .into_iter()\n+                .map(|x| INTERNER.intern_string(x))\n+                .collect::<Vec<_>>(),\n             config: cfg_file,\n-            src,\n             jobs: matches.opt_str(\"jobs\").map(|j| j.parse().unwrap()),\n             cmd,\n             incremental: matches.opt_present(\"incremental\"),\n+            exclude: split(matches.opt_strs(\"exclude\"))\n+                .into_iter()\n+                .map(|p| p.into())\n+                .collect::<Vec<_>>(),\n+            warnings: matches.opt_str(\"warnings\").map(|v| v == \"deny\"),\n         }\n     }\n }\n \n impl Subcommand {\n     pub fn test_args(&self) -> Vec<&str> {\n         match *self {\n-            Subcommand::Test { ref test_args, .. } |\n-            Subcommand::Bench { ref test_args, .. } => {\n-                test_args.iter().flat_map(|s| s.split_whitespace()).collect()\n+            Subcommand::Test { ref test_args, .. } | Subcommand::Bench { ref test_args, .. } => {\n+                test_args\n+                    .iter()\n+                    .flat_map(|s| s.split_whitespace())\n+                    .collect()\n             }\n             _ => Vec::new(),\n         }\n     }\n \n+    pub fn rustc_args(&self) -> Vec<&str> {\n+        match *self {\n+            Subcommand::Test { ref rustc_args, .. } => rustc_args\n+                .iter()\n+                .flat_map(|s| s.split_whitespace())\n+                .collect(),\n+            _ => Vec::new(),\n+        }\n+    }\n+\n     pub fn fail_fast(&self) -> bool {\n         match *self {\n             Subcommand::Test { fail_fast, .. } => fail_fast,\n             _ => false,\n         }\n     }\n+\n+    pub fn doc_tests(&self) -> DocTests {\n+        match *self {\n+            Subcommand::Test { doc_tests, .. } => doc_tests,\n+            _ => DocTests::Yes,\n+        }\n+    }\n+\n+    pub fn bless(&self) -> bool {\n+        match *self {\n+            Subcommand::Test { bless, .. } => bless,\n+            _ => false,\n+        }\n+    }\n+\n+    pub fn compare_mode(&self) -> Option<&str> {\n+        match *self {\n+            Subcommand::Test {\n+                ref compare_mode, ..\n+            } => compare_mode.as_ref().map(|s| &s[..]),\n+            _ => None,\n+        }\n+    }\n }\n \n fn split(s: Vec<String>) -> Vec<String> {\n-    s.iter().flat_map(|s| s.split(',')).map(|s| s.to_string()).collect()\n+    s.iter()\n+        .flat_map(|s| s.split(','))\n+        .map(|s| s.to_string())\n+        .collect()\n }"}, {"sha": "cb28698aa3d6d22b2b7495550a40868c413a90fc", "filename": "src/bootstrap/install.rs", "status": "modified", "additions": 88, "deletions": 30, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fbootstrap%2Finstall.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fbootstrap%2Finstall.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Finstall.rs?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd", "patch": "@@ -22,6 +22,7 @@ use dist::{self, pkgname, sanitize_sh, tmpdir};\n \n use builder::{Builder, RunConfig, ShouldRun, Step};\n use cache::Interned;\n+use config::Config;\n \n pub fn install_docs(builder: &Builder, stage: u32, host: Interned<String>) {\n     install_sh(builder, \"docs\", \"rust-docs\", stage, Some(host));\n@@ -38,6 +39,9 @@ pub fn install_cargo(builder: &Builder, stage: u32, host: Interned<String>) {\n pub fn install_rls(builder: &Builder, stage: u32, host: Interned<String>) {\n     install_sh(builder, \"rls\", \"rls\", stage, Some(host));\n }\n+pub fn install_clippy(builder: &Builder, stage: u32, host: Interned<String>) {\n+    install_sh(builder, \"clippy\", \"clippy\", stage, Some(host));\n+}\n \n pub fn install_rustfmt(builder: &Builder, stage: u32, host: Interned<String>) {\n     install_sh(builder, \"rustfmt\", \"rustfmt\", stage, Some(host));\n@@ -61,23 +65,27 @@ fn install_sh(\n     stage: u32,\n     host: Option<Interned<String>>\n ) {\n-    let build = builder.build;\n-    println!(\"Install {} stage{} ({:?})\", package, stage, host);\n+    builder.info(&format!(\"Install {} stage{} ({:?})\", package, stage, host));\n \n     let prefix_default = PathBuf::from(\"/usr/local\");\n     let sysconfdir_default = PathBuf::from(\"/etc\");\n-    let docdir_default = PathBuf::from(\"share/doc/rust\");\n+    let datadir_default = PathBuf::from(\"share\");\n+    let docdir_default = datadir_default.join(\"doc/rust\");\n     let bindir_default = PathBuf::from(\"bin\");\n     let libdir_default = PathBuf::from(\"lib\");\n-    let mandir_default = PathBuf::from(\"share/man\");\n-    let prefix = build.config.prefix.as_ref().unwrap_or(&prefix_default);\n-    let sysconfdir = build.config.sysconfdir.as_ref().unwrap_or(&sysconfdir_default);\n-    let docdir = build.config.docdir.as_ref().unwrap_or(&docdir_default);\n-    let bindir = build.config.bindir.as_ref().unwrap_or(&bindir_default);\n-    let libdir = build.config.libdir.as_ref().unwrap_or(&libdir_default);\n-    let mandir = build.config.mandir.as_ref().unwrap_or(&mandir_default);\n+    let mandir_default = datadir_default.join(\"man\");\n+    let prefix = builder.config.prefix.as_ref().map_or(prefix_default, |p| {\n+        fs::canonicalize(p).unwrap_or_else(|_| panic!(\"could not canonicalize {}\", p.display()))\n+    });\n+    let sysconfdir = builder.config.sysconfdir.as_ref().unwrap_or(&sysconfdir_default);\n+    let datadir = builder.config.datadir.as_ref().unwrap_or(&datadir_default);\n+    let docdir = builder.config.docdir.as_ref().unwrap_or(&docdir_default);\n+    let bindir = builder.config.bindir.as_ref().unwrap_or(&bindir_default);\n+    let libdir = builder.config.libdir.as_ref().unwrap_or(&libdir_default);\n+    let mandir = builder.config.mandir.as_ref().unwrap_or(&mandir_default);\n \n     let sysconfdir = prefix.join(sysconfdir);\n+    let datadir = prefix.join(datadir);\n     let docdir = prefix.join(docdir);\n     let bindir = prefix.join(bindir);\n     let libdir = prefix.join(libdir);\n@@ -87,31 +95,33 @@ fn install_sh(\n \n     let prefix = add_destdir(&prefix, &destdir);\n     let sysconfdir = add_destdir(&sysconfdir, &destdir);\n+    let datadir = add_destdir(&datadir, &destdir);\n     let docdir = add_destdir(&docdir, &destdir);\n     let bindir = add_destdir(&bindir, &destdir);\n     let libdir = add_destdir(&libdir, &destdir);\n     let mandir = add_destdir(&mandir, &destdir);\n \n-    let empty_dir = build.out.join(\"tmp/empty_dir\");\n+    let empty_dir = builder.out.join(\"tmp/empty_dir\");\n \n     t!(fs::create_dir_all(&empty_dir));\n     let package_name = if let Some(host) = host {\n-        format!(\"{}-{}\", pkgname(build, name), host)\n+        format!(\"{}-{}\", pkgname(builder, name), host)\n     } else {\n-        pkgname(build, name)\n+        pkgname(builder, name)\n     };\n \n     let mut cmd = Command::new(\"sh\");\n     cmd.current_dir(&empty_dir)\n-        .arg(sanitize_sh(&tmpdir(build).join(&package_name).join(\"install.sh\")))\n+        .arg(sanitize_sh(&tmpdir(builder).join(&package_name).join(\"install.sh\")))\n         .arg(format!(\"--prefix={}\", sanitize_sh(&prefix)))\n         .arg(format!(\"--sysconfdir={}\", sanitize_sh(&sysconfdir)))\n+        .arg(format!(\"--datadir={}\", sanitize_sh(&datadir)))\n         .arg(format!(\"--docdir={}\", sanitize_sh(&docdir)))\n         .arg(format!(\"--bindir={}\", sanitize_sh(&bindir)))\n         .arg(format!(\"--libdir={}\", sanitize_sh(&libdir)))\n         .arg(format!(\"--mandir={}\", sanitize_sh(&mandir)))\n         .arg(\"--disable-ldconfig\");\n-    build.run(&mut cmd);\n+    builder.run(&mut cmd);\n     t!(fs::remove_dir_all(&empty_dir));\n }\n \n@@ -144,10 +154,22 @@ macro_rules! install {\n             pub host: Interned<String>,\n         }\n \n+        impl $name {\n+            #[allow(dead_code)]\n+            fn should_build(config: &Config) -> bool {\n+                config.extended && config.tools.as_ref()\n+                    .map_or(true, |t| t.contains($path))\n+            }\n+\n+            #[allow(dead_code)]\n+            fn should_install(builder: &Builder) -> bool {\n+                builder.config.tools.as_ref().map_or(false, |t| t.contains($path))\n+            }\n+        }\n+\n         impl Step for $name {\n             type Output = ();\n             const DEFAULT: bool = true;\n-            const ONLY_BUILD_TARGETS: bool = true;\n             const ONLY_HOSTS: bool = $only_hosts;\n             $(const $c: bool = true;)*\n \n@@ -160,7 +182,7 @@ macro_rules! install {\n                 run.builder.ensure($name {\n                     stage: run.builder.top_stage,\n                     target: run.target,\n-                    host: run.host,\n+                    host: run.builder.config.build,\n                 });\n             }\n \n@@ -177,47 +199,83 @@ install!((self, builder, _config),\n         install_docs(builder, self.stage, self.target);\n     };\n     Std, \"src/libstd\", true, only_hosts: true, {\n-        for target in &builder.build.targets {\n+        for target in &builder.targets {\n             builder.ensure(dist::Std {\n                 compiler: builder.compiler(self.stage, self.host),\n                 target: *target\n             });\n             install_std(builder, self.stage, *target);\n         }\n     };\n-    Cargo, \"cargo\", _config.extended, only_hosts: true, {\n+    Cargo, \"cargo\", Self::should_build(_config), only_hosts: true, {\n         builder.ensure(dist::Cargo { stage: self.stage, target: self.target });\n         install_cargo(builder, self.stage, self.target);\n     };\n-    Rls, \"rls\", _config.extended, only_hosts: true, {\n-        if builder.ensure(dist::Rls { stage: self.stage, target: self.target }).is_some() {\n+    Rls, \"rls\", Self::should_build(_config), only_hosts: true, {\n+        if builder.ensure(dist::Rls { stage: self.stage, target: self.target }).is_some() ||\n+            Self::should_install(builder) {\n             install_rls(builder, self.stage, self.target);\n         } else {\n-            println!(\"skipping Install RLS stage{} ({})\", self.stage, self.target);\n+            builder.info(&format!(\"skipping Install RLS stage{} ({})\", self.stage, self.target));\n         }\n     };\n-    Rustfmt, \"rustfmt\", _config.extended, only_hosts: true, {\n-        if builder.ensure(dist::Rustfmt { stage: self.stage, target: self.target }).is_some() {\n+    Clippy, \"clippy\", Self::should_build(_config), only_hosts: true, {\n+        if builder.ensure(dist::Clippy { stage: self.stage, target: self.target }).is_some() ||\n+            Self::should_install(builder) {\n+            install_clippy(builder, self.stage, self.target);\n+        } else {\n+            builder.info(&format!(\"skipping Install clippy stage{} ({})\", self.stage, self.target));\n+        }\n+    };\n+    Rustfmt, \"rustfmt\", Self::should_build(_config), only_hosts: true, {\n+        if builder.ensure(dist::Rustfmt { stage: self.stage, target: self.target }).is_some() ||\n+            Self::should_install(builder) {\n             install_rustfmt(builder, self.stage, self.target);\n         } else {\n-            println!(\"skipping Install Rustfmt stage{} ({})\", self.stage, self.target);\n+            builder.info(\n+                &format!(\"skipping Install Rustfmt stage{} ({})\", self.stage, self.target));\n         }\n     };\n-    Analysis, \"analysis\", _config.extended, only_hosts: false, {\n+    Analysis, \"analysis\", Self::should_build(_config), only_hosts: false, {\n         builder.ensure(dist::Analysis {\n             compiler: builder.compiler(self.stage, self.host),\n             target: self.target\n         });\n         install_analysis(builder, self.stage, self.target);\n     };\n-    Src, \"src\", _config.extended, only_hosts: true, {\n-        builder.ensure(dist::Src);\n-        install_src(builder, self.stage);\n-    }, ONLY_BUILD;\n     Rustc, \"src/librustc\", true, only_hosts: true, {\n         builder.ensure(dist::Rustc {\n             compiler: builder.compiler(self.stage, self.target),\n         });\n         install_rustc(builder, self.stage, self.target);\n     };\n );\n+\n+#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n+pub struct Src {\n+    pub stage: u32,\n+}\n+\n+impl Step for Src {\n+    type Output = ();\n+    const DEFAULT: bool = true;\n+    const ONLY_HOSTS: bool = true;\n+\n+    fn should_run(run: ShouldRun) -> ShouldRun {\n+        let config = &run.builder.config;\n+        let cond = config.extended &&\n+            config.tools.as_ref().map_or(true, |t| t.contains(\"src\"));\n+        run.path(\"src\").default_condition(cond)\n+    }\n+\n+    fn make_run(run: RunConfig) {\n+        run.builder.ensure(Src {\n+            stage: run.builder.top_stage,\n+        });\n+    }\n+\n+    fn run(self, builder: &Builder) {\n+        builder.ensure(dist::Src);\n+        install_src(builder, self.stage);\n+    }\n+}"}, {"sha": "6445ce8da332ea95904fb6b8a7ebbfd16f09d029", "filename": "src/bootstrap/job.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fbootstrap%2Fjob.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fbootstrap%2Fjob.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fjob.rs?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd", "patch": "@@ -122,12 +122,10 @@ struct JOBOBJECT_BASIC_LIMIT_INFORMATION {\n }\n \n pub unsafe fn setup(build: &mut Build) {\n-    // Tell Windows to not show any UI on errors (such as not finding a required dll\n-    // during startup or terminating abnormally).  This is important for running tests,\n-    // since some of them use abnormal termination by design.\n-    // This mode is inherited by all child processes.\n-    let mode = SetErrorMode(SEM_NOGPFAULTERRORBOX); // read inherited flags\n-    SetErrorMode(mode | SEM_FAILCRITICALERRORS | SEM_NOGPFAULTERRORBOX);\n+    // Enable the Windows Error Reporting dialog which msys disables,\n+    // so we can JIT debug rustc\n+    let mode = SetErrorMode(0);\n+    SetErrorMode(mode & !SEM_NOGPFAULTERRORBOX);\n \n     // Create a new job object for us to use\n     let job = CreateJobObjectW(0 as *mut _, 0 as *const _);"}, {"sha": "5bb475e07ba8db1fb4ae46b6180b96f1a267b12d", "filename": "src/bootstrap/lib.rs", "status": "modified", "additions": 452, "deletions": 89, "changes": 541, "blob_url": "https://github.com/rust-lang/rust/blob/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fbootstrap%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fbootstrap%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Flib.rs?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd", "patch": "@@ -113,9 +113,10 @@\n //! More documentation can be found in each respective module below, and you can\n //! also check out the `src/bootstrap/README.md` file for more information.\n \n+#![deny(bare_trait_objects)]\n #![deny(warnings)]\n-#![allow(stable_features)]\n-#![feature(associated_consts)]\n+#![feature(core_intrinsics)]\n+#![feature(drain_filter)]\n \n #[macro_use]\n extern crate build_helper;\n@@ -130,26 +131,40 @@ extern crate cc;\n extern crate getopts;\n extern crate num_cpus;\n extern crate toml;\n+extern crate time;\n+extern crate petgraph;\n+\n+#[cfg(test)]\n+#[macro_use]\n+extern crate pretty_assertions;\n \n #[cfg(unix)]\n extern crate libc;\n \n-use std::cell::RefCell;\n+use std::cell::{RefCell, Cell};\n use std::collections::{HashSet, HashMap};\n use std::env;\n-use std::fs::{self, File};\n-use std::io::Read;\n+use std::fs::{self, OpenOptions, File};\n+use std::io::{self, Seek, SeekFrom, Write, Read};\n use std::path::{PathBuf, Path};\n use std::process::{self, Command};\n use std::slice;\n+use std::str;\n+\n+#[cfg(unix)]\n+use std::os::unix::fs::symlink as symlink_file;\n+#[cfg(windows)]\n+use std::os::windows::fs::symlink_file;\n \n use build_helper::{run_silent, run_suppressed, try_run_silent, try_run_suppressed, output, mtime};\n+use filetime::FileTime;\n \n use util::{exe, libdir, OutputFolder, CiEnv};\n \n mod cc_detect;\n mod channel;\n mod check;\n+mod test;\n mod clean;\n mod compile;\n mod metadata;\n@@ -169,7 +184,7 @@ mod toolstate;\n #[cfg(windows)]\n mod job;\n \n-#[cfg(unix)]\n+#[cfg(all(unix, not(target_os = \"haiku\")))]\n mod job {\n     use libc;\n \n@@ -180,7 +195,7 @@ mod job {\n     }\n }\n \n-#[cfg(not(any(unix, windows)))]\n+#[cfg(any(target_os = \"haiku\", not(any(unix, windows))))]\n mod job {\n     pub unsafe fn setup(_build: &mut ::Build) {\n     }\n@@ -191,17 +206,36 @@ use flags::Subcommand;\n use cache::{Interned, INTERNER};\n use toolstate::ToolState;\n \n+const LLVM_TOOLS: &[&str] = &[\n+    \"llvm-nm\", // used to inspect binaries; it shows symbol names, their sizes and visibility\n+    \"llvm-objcopy\", // used to transform ELFs into binary format which flashing tools consume\n+    \"llvm-objdump\", // used to disassemble programs\n+    \"llvm-profdata\", // used to inspect and merge files generated by profiles\n+    \"llvm-size\", // used to prints the size of the linker sections of a program\n+    \"llvm-strip\", // used to discard symbols from binary files to reduce their size\n+];\n+\n /// A structure representing a Rust compiler.\n ///\n /// Each compiler has a `stage` that it is associated with and a `host` that\n /// corresponds to the platform the compiler runs on. This structure is used as\n /// a parameter to many methods below.\n-#[derive(Eq, PartialEq, Clone, Copy, Hash, Debug)]\n+#[derive(Eq, PartialOrd, Ord, PartialEq, Clone, Copy, Hash, Debug)]\n pub struct Compiler {\n     stage: u32,\n     host: Interned<String>,\n }\n \n+#[derive(PartialEq, Eq, Copy, Clone, Debug)]\n+pub enum DocTests {\n+    // Default, run normal tests and doc tests.\n+    Yes,\n+    // Do not run any doc tests.\n+    No,\n+    // Only run doc tests.\n+    Only,\n+}\n+\n /// Global configuration for the build system.\n ///\n /// This structure transitively contains all configuration for the build system.\n@@ -222,9 +256,11 @@ pub struct Build {\n     rust_info: channel::GitInfo,\n     cargo_info: channel::GitInfo,\n     rls_info: channel::GitInfo,\n+    clippy_info: channel::GitInfo,\n     rustfmt_info: channel::GitInfo,\n     local_rebuild: bool,\n     fail_fast: bool,\n+    doc_tests: DocTests,\n     verbosity: usize,\n \n     // Targets for which to build.\n@@ -250,37 +286,76 @@ pub struct Build {\n     is_sudo: bool,\n     ci_env: CiEnv,\n     delayed_failures: RefCell<Vec<String>>,\n+    prerelease_version: Cell<Option<u32>>,\n+    tool_artifacts: RefCell<HashMap<\n+        Interned<String>,\n+        HashMap<String, (&'static str, PathBuf, Vec<String>)>\n+    >>,\n }\n \n #[derive(Debug)]\n struct Crate {\n     name: Interned<String>,\n     version: String,\n-    deps: Vec<Interned<String>>,\n+    deps: HashSet<Interned<String>>,\n+    id: String,\n     path: PathBuf,\n     doc_step: String,\n     build_step: String,\n     test_step: String,\n     bench_step: String,\n }\n \n+impl Crate {\n+    fn is_local(&self, build: &Build) -> bool {\n+        self.path.starts_with(&build.config.src) &&\n+        !self.path.to_string_lossy().ends_with(\"_shim\")\n+    }\n+\n+    fn local_path(&self, build: &Build) -> PathBuf {\n+        assert!(self.is_local(build));\n+        self.path.strip_prefix(&build.config.src).unwrap().into()\n+    }\n+}\n+\n /// The various \"modes\" of invoking Cargo.\n ///\n /// These entries currently correspond to the various output directories of the\n /// build system, with each mod generating output in a different directory.\n-#[derive(Debug, Hash, Clone, Copy, PartialEq, Eq)]\n+#[derive(Debug, Hash, Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]\n pub enum Mode {\n     /// Build the standard library, placing output in the \"stageN-std\" directory.\n-    Libstd,\n+    Std,\n \n     /// Build libtest, placing output in the \"stageN-test\" directory.\n-    Libtest,\n+    Test,\n+\n+    /// Build librustc, and compiler libraries, placing output in the \"stageN-rustc\" directory.\n+    Rustc,\n+\n+    /// Build codegen libraries, placing output in the \"stageN-codegen\" directory\n+    Codegen,\n+\n+    /// Build some tools, placing output in the \"stageN-tools\" directory. The\n+    /// \"other\" here is for miscellaneous sets of tools that are built using the\n+    /// bootstrap compiler in its entirety (target libraries and all).\n+    /// Typically these tools compile with stable Rust.\n+    ToolBootstrap,\n \n-    /// Build librustc and compiler libraries, placing output in the \"stageN-rustc\" directory.\n-    Librustc,\n+    /// Compile a tool which uses all libraries we compile (up to rustc).\n+    /// Doesn't use the stage0 compiler libraries like \"other\", and includes\n+    /// tools like rustdoc, cargo, rls, etc.\n+    ToolStd,\n+    ToolRustc,\n+}\n \n-    /// Build some tool, placing output in the \"stageN-tools\" directory.\n-    Tool,\n+impl Mode {\n+    pub fn is_tool(&self) -> bool {\n+        match self {\n+            Mode::ToolBootstrap | Mode::ToolRustc | Mode::ToolStd => true,\n+            _ => false\n+        }\n+    }\n }\n \n impl Build {\n@@ -289,9 +364,8 @@ impl Build {\n     ///\n     /// By default all build output will be placed in the current directory.\n     pub fn new(config: Config) -> Build {\n-        let cwd = t!(env::current_dir());\n         let src = config.src.clone();\n-        let out = cwd.join(\"build\");\n+        let out = config.out.clone();\n \n         let is_sudo = match env::var_os(\"SUDO_USER\") {\n             Some(sudo_user) => {\n@@ -305,13 +379,15 @@ impl Build {\n         let rust_info = channel::GitInfo::new(&config, &src);\n         let cargo_info = channel::GitInfo::new(&config, &src.join(\"src/tools/cargo\"));\n         let rls_info = channel::GitInfo::new(&config, &src.join(\"src/tools/rls\"));\n+        let clippy_info = channel::GitInfo::new(&config, &src.join(\"src/tools/clippy\"));\n         let rustfmt_info = channel::GitInfo::new(&config, &src.join(\"src/tools/rustfmt\"));\n \n-        Build {\n+        let mut build = Build {\n             initial_rustc: config.initial_rustc.clone(),\n             initial_cargo: config.initial_cargo.clone(),\n             local_rebuild: config.local_rebuild,\n             fail_fast: config.cmd.fail_fast(),\n+            doc_tests: config.cmd.doc_tests(),\n             verbosity: config.verbose,\n \n             build: config.build,\n@@ -325,6 +401,7 @@ impl Build {\n             rust_info,\n             cargo_info,\n             rls_info,\n+            clippy_info,\n             rustfmt_info,\n             cc: HashMap::new(),\n             cxx: HashMap::new(),\n@@ -335,7 +412,32 @@ impl Build {\n             is_sudo,\n             ci_env: CiEnv::current(),\n             delayed_failures: RefCell::new(Vec::new()),\n+            prerelease_version: Cell::new(None),\n+            tool_artifacts: Default::default(),\n+        };\n+\n+        build.verbose(\"finding compilers\");\n+        cc_detect::find(&mut build);\n+        build.verbose(\"running sanity check\");\n+        sanity::check(&mut build);\n+\n+        // If local-rust is the same major.minor as the current version, then force a\n+        // local-rebuild\n+        let local_version_verbose = output(\n+            Command::new(&build.initial_rustc).arg(\"--version\").arg(\"--verbose\"));\n+        let local_release = local_version_verbose\n+            .lines().filter(|x| x.starts_with(\"release:\"))\n+            .next().unwrap().trim_left_matches(\"release:\").trim();\n+        let my_version = channel::CFG_RELEASE_NUM;\n+        if local_release.split('.').take(2).eq(my_version.split('.').take(2)) {\n+            build.verbose(&format!(\"auto-detected local-rebuild {}\", local_release));\n+            build.local_rebuild = true;\n         }\n+\n+        build.verbose(\"learning about cargo\");\n+        metadata::build(&mut build);\n+\n+        build\n     }\n \n     pub fn build_triple(&self) -> &[Interned<String>] {\n@@ -354,25 +456,28 @@ impl Build {\n             return clean::clean(self, all);\n         }\n \n-        self.verbose(\"finding compilers\");\n-        cc_detect::find(self);\n-        self.verbose(\"running sanity check\");\n-        sanity::check(self);\n-        // If local-rust is the same major.minor as the current version, then force a local-rebuild\n-        let local_version_verbose = output(\n-            Command::new(&self.initial_rustc).arg(\"--version\").arg(\"--verbose\"));\n-        let local_release = local_version_verbose\n-            .lines().filter(|x| x.starts_with(\"release:\"))\n-            .next().unwrap().trim_left_matches(\"release:\").trim();\n-        let my_version = channel::CFG_RELEASE_NUM;\n-        if local_release.split('.').take(2).eq(my_version.split('.').take(2)) {\n-            self.verbose(&format!(\"auto-detected local-rebuild {}\", local_release));\n-            self.local_rebuild = true;\n+        {\n+            let builder = builder::Builder::new(&self);\n+            if let Some(path) = builder.paths.get(0) {\n+                if path == Path::new(\"nonexistent/path/to/trigger/cargo/metadata\") {\n+                    return;\n+                }\n+            }\n         }\n-        self.verbose(\"learning about cargo\");\n-        metadata::build(self);\n \n-        builder::Builder::run(&self);\n+        if !self.config.dry_run {\n+            {\n+                self.config.dry_run = true;\n+                let builder = builder::Builder::new(&self);\n+                builder.execute_cli();\n+            }\n+            self.config.dry_run = false;\n+            let builder = builder::Builder::new(&self);\n+            builder.execute_cli();\n+        } else {\n+            let builder = builder::Builder::new(&self);\n+            let _ = builder.execute_cli();\n+        }\n \n         // Check for postponed failures from `test --no-fail-fast`.\n         let failures = self.delayed_failures.borrow();\n@@ -420,6 +525,9 @@ impl Build {\n         if self.config.profiler {\n             features.push_str(\" profiler\");\n         }\n+        if self.config.wasm_syscall {\n+            features.push_str(\" wasm_syscall\");\n+        }\n         features\n     }\n \n@@ -429,9 +537,6 @@ impl Build {\n         if self.config.use_jemalloc {\n             features.push_str(\" jemalloc\");\n         }\n-        if self.config.llvm_enabled {\n-            features.push_str(\" llvm\");\n-        }\n         features\n     }\n \n@@ -447,22 +552,19 @@ impl Build {\n         out\n     }\n \n-    /// Get the directory for incremental by-products when using the\n-    /// given compiler.\n-    fn incremental_dir(&self, compiler: Compiler) -> PathBuf {\n-        self.out.join(&*compiler.host).join(format!(\"stage{}-incremental\", compiler.stage))\n-    }\n-\n     /// Returns the root directory for all output generated in a particular\n     /// stage when running with a particular host compiler.\n     ///\n     /// The mode indicates what the root directory is for.\n     fn stage_out(&self, compiler: Compiler, mode: Mode) -> PathBuf {\n         let suffix = match mode {\n-            Mode::Libstd => \"-std\",\n-            Mode::Libtest => \"-test\",\n-            Mode::Tool => \"-tools\",\n-            Mode::Librustc => \"-rustc\",\n+            Mode::Std => \"-std\",\n+            Mode::Test => \"-test\",\n+            Mode::Rustc => \"-rustc\",\n+            Mode::Codegen => \"-codegen\",\n+            Mode::ToolBootstrap => \"-bootstrap-tools\",\n+            Mode::ToolStd => \"-tools\",\n+            Mode::ToolRustc => \"-tools\",\n         };\n         self.out.join(&*compiler.host)\n                 .join(format!(\"stage{}{}\", compiler.stage, suffix))\n@@ -486,11 +588,24 @@ impl Build {\n         self.out.join(&*target).join(\"llvm\")\n     }\n \n+    fn emscripten_llvm_out(&self, target: Interned<String>) -> PathBuf {\n+        self.out.join(&*target).join(\"llvm-emscripten\")\n+    }\n+\n+    fn lld_out(&self, target: Interned<String>) -> PathBuf {\n+        self.out.join(&*target).join(\"lld\")\n+    }\n+\n     /// Output directory for all documentation for a target\n     fn doc_out(&self, target: Interned<String>) -> PathBuf {\n         self.out.join(&*target).join(\"doc\")\n     }\n \n+    /// Output directory for all documentation for a target\n+    fn compiler_doc_out(&self, target: Interned<String>) -> PathBuf {\n+        self.out.join(&*target).join(\"compiler-doc\")\n+    }\n+\n     /// Output directory for some generated md crate documentation for a target (temporary)\n     fn md_doc_out(&self, target: Interned<String>) -> Interned<PathBuf> {\n         INTERNER.intern_path(self.out.join(&*target).join(\"md-doc\"))\n@@ -513,20 +628,6 @@ impl Build {\n         }\n     }\n \n-    /// Returns the path to `llvm-config` for the specified target.\n-    ///\n-    /// If a custom `llvm-config` was specified for target then that's returned\n-    /// instead.\n-    fn llvm_config(&self, target: Interned<String>) -> PathBuf {\n-        let target_config = self.config.target_config.get(&target);\n-        if let Some(s) = target_config.and_then(|c| c.llvm_config.as_ref()) {\n-            s.clone()\n-        } else {\n-            self.llvm_out(self.config.build).join(\"bin\")\n-                .join(exe(\"llvm-config\", &*target))\n-        }\n-    }\n-\n     /// Returns the path to `FileCheck` binary for the specified target\n     fn llvm_filecheck(&self, target: Interned<String>) -> PathBuf {\n         let target_config = self.config.target_config.get(&target);\n@@ -535,12 +636,20 @@ impl Build {\n             Path::new(llvm_bindir.trim()).join(exe(\"FileCheck\", &*target))\n         } else {\n             let base = self.llvm_out(self.config.build).join(\"build\");\n-            let exe = exe(\"FileCheck\", &*target);\n-            if !self.config.ninja && self.config.build.contains(\"msvc\") {\n-                base.join(\"Release/bin\").join(exe)\n+            let base = if !self.config.ninja && self.config.build.contains(\"msvc\") {\n+                if self.config.llvm_optimize {\n+                    if self.config.llvm_release_debuginfo {\n+                        base.join(\"RelWithDebInfo\")\n+                    } else {\n+                        base.join(\"Release\")\n+                    }\n+                } else {\n+                    base.join(\"Debug\")\n+                }\n             } else {\n-                base.join(\"bin\").join(exe)\n-            }\n+                base\n+            };\n+            base.join(\"bin\").join(exe(\"FileCheck\", &*target))\n         }\n     }\n \n@@ -564,18 +673,24 @@ impl Build {\n \n     /// Returns the libdir of the snapshot compiler.\n     fn rustc_snapshot_libdir(&self) -> PathBuf {\n+        self.rustc_snapshot_sysroot().join(libdir(&self.config.build))\n+    }\n+\n+    /// Returns the sysroot of the snapshot compiler.\n+    fn rustc_snapshot_sysroot(&self) -> &Path {\n         self.initial_rustc.parent().unwrap().parent().unwrap()\n-            .join(libdir(&self.config.build))\n     }\n \n     /// Runs a command, printing out nice contextual information if it fails.\n     fn run(&self, cmd: &mut Command) {\n+        if self.config.dry_run { return; }\n         self.verbose(&format!(\"running: {:?}\", cmd));\n         run_silent(cmd)\n     }\n \n     /// Runs a command, printing out nice contextual information if it fails.\n     fn run_quiet(&self, cmd: &mut Command) {\n+        if self.config.dry_run { return; }\n         self.verbose(&format!(\"running: {:?}\", cmd));\n         run_suppressed(cmd)\n     }\n@@ -584,6 +699,7 @@ impl Build {\n     /// Exits if the command failed to execute at all, otherwise returns its\n     /// `status.success()`.\n     fn try_run(&self, cmd: &mut Command) -> bool {\n+        if self.config.dry_run { return true; }\n         self.verbose(&format!(\"running: {:?}\", cmd));\n         try_run_silent(cmd)\n     }\n@@ -592,6 +708,7 @@ impl Build {\n     /// Exits if the command failed to execute at all, otherwise returns its\n     /// `status.success()`.\n     fn try_run_quiet(&self, cmd: &mut Command) -> bool {\n+        if self.config.dry_run { return true; }\n         self.verbose(&format!(\"running: {:?}\", cmd));\n         try_run_suppressed(cmd)\n     }\n@@ -600,17 +717,18 @@ impl Build {\n         self.verbosity > 0\n     }\n \n-    pub fn is_very_verbose(&self) -> bool {\n-        self.verbosity > 1\n-    }\n-\n     /// Prints a message if this build is configured in verbose mode.\n     fn verbose(&self, msg: &str) {\n         if self.is_verbose() {\n             println!(\"{}\", msg);\n         }\n     }\n \n+    fn info(&self, msg: &str) {\n+        if self.config.dry_run { return; }\n+        println!(\"{}\", msg);\n+    }\n+\n     /// Returns the number of parallel jobs that have been configured for this\n     /// build.\n     fn jobs(&self) -> u32 {\n@@ -664,13 +782,15 @@ impl Build {\n         }\n     }\n \n-    /// Returns the path to the linker for the given target if it needs to be overriden.\n+    /// Returns the path to the linker for the given target if it needs to be overridden.\n     fn linker(&self, target: Interned<String>) -> Option<&Path> {\n         if let Some(linker) = self.config.target_config.get(&target)\n                                                        .and_then(|c| c.linker.as_ref()) {\n             Some(linker)\n         } else if target != self.config.build &&\n-                  !target.contains(\"msvc\") && !target.contains(\"emscripten\") {\n+                  !target.contains(\"msvc\") &&\n+                  !target.contains(\"emscripten\") &&\n+                  !target.contains(\"wasm32\") {\n             Some(self.cc(target))\n         } else {\n             None\n@@ -695,6 +815,12 @@ impl Build {\n             .map(|p| &**p)\n     }\n \n+    /// Returns true if this is a no-std `target`, if defined\n+    fn no_std(&self, target: Interned<String>) -> Option<bool> {\n+        self.config.target_config.get(&target)\n+            .map(|t| t.no_std)\n+    }\n+\n     /// Returns whether the target will be tested using the `remote-test-client`\n     /// and `remote-test-server` binaries.\n     fn remote_tested(&self, target: Interned<String>) -> bool {\n@@ -774,12 +900,63 @@ impl Build {\n     fn release(&self, num: &str) -> String {\n         match &self.config.channel[..] {\n             \"stable\" => num.to_string(),\n-            \"beta\" => format!(\"{}-beta{}\", num, channel::CFG_PRERELEASE_VERSION),\n+            \"beta\" => if self.rust_info.is_git() {\n+                format!(\"{}-beta.{}\", num, self.beta_prerelease_version())\n+            } else {\n+                format!(\"{}-beta\", num)\n+            },\n             \"nightly\" => format!(\"{}-nightly\", num),\n             _ => format!(\"{}-dev\", num),\n         }\n     }\n \n+    fn beta_prerelease_version(&self) -> u32 {\n+        if let Some(s) = self.prerelease_version.get() {\n+            return s\n+        }\n+\n+        let beta = output(\n+            Command::new(\"git\")\n+                .arg(\"ls-remote\")\n+                .arg(\"origin\")\n+                .arg(\"beta\")\n+                .current_dir(&self.src)\n+        );\n+        let beta = beta.trim().split_whitespace().next().unwrap();\n+        let master = output(\n+            Command::new(\"git\")\n+                .arg(\"ls-remote\")\n+                .arg(\"origin\")\n+                .arg(\"master\")\n+                .current_dir(&self.src)\n+        );\n+        let master = master.trim().split_whitespace().next().unwrap();\n+\n+        // Figure out where the current beta branch started.\n+        let base = output(\n+            Command::new(\"git\")\n+                .arg(\"merge-base\")\n+                .arg(beta)\n+                .arg(master)\n+                .current_dir(&self.src),\n+        );\n+        let base = base.trim();\n+\n+        // Next figure out how many merge commits happened since we branched off\n+        // beta. That's our beta number!\n+        let count = output(\n+            Command::new(\"git\")\n+                .arg(\"rev-list\")\n+                .arg(\"--count\")\n+                .arg(\"--merges\")\n+                .arg(format!(\"{}...HEAD\", base))\n+                .current_dir(&self.src),\n+        );\n+        let n = count.trim().parse().unwrap();\n+        self.prerelease_version.set(Some(n));\n+        n\n+    }\n+\n     /// Returns the value of `release` above for Rust itself.\n     fn rust_release(&self) -> String {\n         self.release(channel::CFG_RELEASE_NUM)\n@@ -815,11 +992,32 @@ impl Build {\n         self.package_vers(&self.release_num(\"rls\"))\n     }\n \n+    /// Returns the value of `package_vers` above for clippy\n+    fn clippy_package_vers(&self) -> String {\n+        self.package_vers(&self.release_num(\"clippy\"))\n+    }\n+\n     /// Returns the value of `package_vers` above for rustfmt\n     fn rustfmt_package_vers(&self) -> String {\n         self.package_vers(&self.release_num(\"rustfmt\"))\n     }\n \n+    fn llvm_tools_package_vers(&self) -> String {\n+        self.package_vers(&self.rust_version())\n+    }\n+\n+    fn llvm_tools_vers(&self) -> String {\n+        self.rust_version()\n+    }\n+\n+    fn lldb_package_vers(&self) -> String {\n+        self.package_vers(&self.rust_version())\n+    }\n+\n+    fn lldb_vers(&self) -> String {\n+        self.rust_version()\n+    }\n+\n     /// Returns the `version` string associated with this compiler for Rust\n     /// itself.\n     ///\n@@ -865,7 +1063,7 @@ impl Build {\n     pub fn fold_output<D, F>(&self, name: F) -> Option<OutputFolder>\n         where D: Into<String>, F: FnOnce() -> D\n     {\n-        if self.ci_env == CiEnv::Travis {\n+        if !self.config.dry_run && self.ci_env == CiEnv::Travis {\n             Some(OutputFolder::new(name().into()))\n         } else {\n             None\n@@ -896,28 +1094,193 @@ impl Build {\n         }\n     }\n \n-    /// Get a list of crates from a root crate.\n-    ///\n-    /// Returns Vec<(crate, path to crate, is_root_crate)>\n-    fn crates(&self, root: &str) -> Vec<(Interned<String>, &Path)> {\n-        let interned = INTERNER.intern_string(root.to_owned());\n+    fn in_tree_crates(&self, root: &str) -> Vec<&Crate> {\n         let mut ret = Vec::new();\n-        let mut list = vec![interned];\n+        let mut list = vec![INTERNER.intern_str(root)];\n         let mut visited = HashSet::new();\n         while let Some(krate) = list.pop() {\n             let krate = &self.crates[&krate];\n-            // If we can't strip prefix, then out-of-tree path\n-            let path = krate.path.strip_prefix(&self.src).unwrap_or(&krate.path);\n-            ret.push((krate.name, path));\n-            for dep in &krate.deps {\n-                if visited.insert(dep) && dep != \"build_helper\" {\n-                    list.push(*dep);\n+            if krate.is_local(self) {\n+                ret.push(krate);\n+                for dep in &krate.deps {\n+                    if visited.insert(dep) && dep != \"build_helper\" {\n+                        list.push(*dep);\n+                    }\n                 }\n             }\n         }\n         ret\n     }\n+\n+    fn read_stamp_file(&self, stamp: &Path) -> Vec<PathBuf> {\n+        if self.config.dry_run {\n+            return Vec::new();\n+        }\n+\n+        let mut paths = Vec::new();\n+        let mut contents = Vec::new();\n+        t!(t!(File::open(stamp)).read_to_end(&mut contents));\n+        // This is the method we use for extracting paths from the stamp file passed to us. See\n+        // run_cargo for more information (in compile.rs).\n+        for part in contents.split(|b| *b == 0) {\n+            if part.is_empty() {\n+                continue\n+            }\n+            let path = PathBuf::from(t!(str::from_utf8(part)));\n+            paths.push(path);\n+        }\n+        paths\n+    }\n+\n+    /// Copies a file from `src` to `dst`\n+    pub fn copy(&self, src: &Path, dst: &Path) {\n+        if self.config.dry_run { return; }\n+        let _ = fs::remove_file(&dst);\n+        let metadata = t!(src.symlink_metadata());\n+        if metadata.file_type().is_symlink() {\n+            let link = t!(fs::read_link(src));\n+            t!(symlink_file(link, dst));\n+        } else if let Ok(()) = fs::hard_link(src, dst) {\n+            // Attempt to \"easy copy\" by creating a hard link\n+            // (symlinks don't work on windows), but if that fails\n+            // just fall back to a slow `copy` operation.\n+        } else {\n+            if let Err(e) = fs::copy(src, dst) {\n+                panic!(\"failed to copy `{}` to `{}`: {}\", src.display(),\n+                       dst.display(), e)\n+            }\n+            t!(fs::set_permissions(dst, metadata.permissions()));\n+            let atime = FileTime::from_last_access_time(&metadata);\n+            let mtime = FileTime::from_last_modification_time(&metadata);\n+            t!(filetime::set_file_times(dst, atime, mtime));\n+        }\n+    }\n+\n+    /// Search-and-replaces within a file. (Not maximally efficiently: allocates a\n+    /// new string for each replacement.)\n+    pub fn replace_in_file(&self, path: &Path, replacements: &[(&str, &str)]) {\n+        if self.config.dry_run { return; }\n+        let mut contents = String::new();\n+        let mut file = t!(OpenOptions::new().read(true).write(true).open(path));\n+        t!(file.read_to_string(&mut contents));\n+        for &(target, replacement) in replacements {\n+            contents = contents.replace(target, replacement);\n+        }\n+        t!(file.seek(SeekFrom::Start(0)));\n+        t!(file.set_len(0));\n+        t!(file.write_all(contents.as_bytes()));\n+    }\n+\n+    /// Copies the `src` directory recursively to `dst`. Both are assumed to exist\n+    /// when this function is called.\n+    pub fn cp_r(&self, src: &Path, dst: &Path) {\n+        if self.config.dry_run { return; }\n+        for f in t!(fs::read_dir(src)) {\n+            let f = t!(f);\n+            let path = f.path();\n+            let name = path.file_name().unwrap();\n+            let dst = dst.join(name);\n+            if t!(f.file_type()).is_dir() {\n+                t!(fs::create_dir_all(&dst));\n+                self.cp_r(&path, &dst);\n+            } else {\n+                let _ = fs::remove_file(&dst);\n+                self.copy(&path, &dst);\n+            }\n+        }\n+    }\n+\n+    /// Copies the `src` directory recursively to `dst`. Both are assumed to exist\n+    /// when this function is called. Unwanted files or directories can be skipped\n+    /// by returning `false` from the filter function.\n+    pub fn cp_filtered(&self, src: &Path, dst: &Path, filter: &dyn Fn(&Path) -> bool) {\n+        // Immediately recurse with an empty relative path\n+        self.recurse_(src, dst, Path::new(\"\"), filter)\n+    }\n+\n+    // Inner function does the actual work\n+    fn recurse_(&self, src: &Path, dst: &Path, relative: &Path, filter: &dyn Fn(&Path) -> bool) {\n+        for f in self.read_dir(src) {\n+            let path = f.path();\n+            let name = path.file_name().unwrap();\n+            let dst = dst.join(name);\n+            let relative = relative.join(name);\n+            // Only copy file or directory if the filter function returns true\n+            if filter(&relative) {\n+                if t!(f.file_type()).is_dir() {\n+                    let _ = fs::remove_dir_all(&dst);\n+                    self.create_dir(&dst);\n+                    self.recurse_(&path, &dst, &relative, filter);\n+                } else {\n+                    let _ = fs::remove_file(&dst);\n+                    self.copy(&path, &dst);\n+                }\n+            }\n+        }\n+    }\n+\n+    fn copy_to_folder(&self, src: &Path, dest_folder: &Path) {\n+        let file_name = src.file_name().unwrap();\n+        let dest = dest_folder.join(file_name);\n+        self.copy(src, &dest);\n+    }\n+\n+    fn install(&self, src: &Path, dstdir: &Path, perms: u32) {\n+        if self.config.dry_run { return; }\n+        let dst = dstdir.join(src.file_name().unwrap());\n+        t!(fs::create_dir_all(dstdir));\n+        drop(fs::remove_file(&dst));\n+        {\n+            let mut s = t!(fs::File::open(&src));\n+            let mut d = t!(fs::File::create(&dst));\n+            io::copy(&mut s, &mut d).expect(\"failed to copy\");\n+        }\n+        chmod(&dst, perms);\n+    }\n+\n+    fn create(&self, path: &Path, s: &str) {\n+        if self.config.dry_run { return; }\n+        t!(fs::write(path, s));\n+    }\n+\n+    fn read(&self, path: &Path) -> String {\n+        if self.config.dry_run { return String::new(); }\n+        t!(fs::read_to_string(path))\n+    }\n+\n+    fn create_dir(&self, dir: &Path) {\n+        if self.config.dry_run { return; }\n+        t!(fs::create_dir_all(dir))\n+    }\n+\n+    fn remove_dir(&self, dir: &Path) {\n+        if self.config.dry_run { return; }\n+        t!(fs::remove_dir_all(dir))\n+    }\n+\n+    fn read_dir(&self, dir: &Path) -> impl Iterator<Item=fs::DirEntry> {\n+        let iter = match fs::read_dir(dir) {\n+            Ok(v) => v,\n+            Err(_) if self.config.dry_run => return vec![].into_iter(),\n+            Err(err) => panic!(\"could not read dir {:?}: {:?}\", dir, err),\n+        };\n+        iter.map(|e| t!(e)).collect::<Vec<_>>().into_iter()\n+    }\n+\n+    fn remove(&self, f: &Path) {\n+        if self.config.dry_run { return; }\n+        fs::remove_file(f).unwrap_or_else(|_| panic!(\"failed to remove {:?}\", f));\n+    }\n+}\n+\n+#[cfg(unix)]\n+fn chmod(path: &Path, perms: u32) {\n+    use std::os::unix::fs::*;\n+    t!(fs::set_permissions(path, fs::Permissions::from_mode(perms)));\n }\n+#[cfg(windows)]\n+fn chmod(_path: &Path, _perms: u32) {}\n+\n \n impl<'a> Compiler {\n     pub fn with_stage(mut self, stage: u32) -> Compiler {"}, {"sha": "fa0b1983510b90075b44b6ff0175a5cf58ada47a", "filename": "src/bootstrap/metadata.rs", "status": "modified", "additions": 31, "deletions": 23, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fbootstrap%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fbootstrap%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fmetadata.rs?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd", "patch": "@@ -11,6 +11,7 @@\n use std::collections::HashMap;\n use std::process::Command;\n use std::path::PathBuf;\n+use std::collections::HashSet;\n \n use build_helper::output;\n use serde_json;\n@@ -45,12 +46,34 @@ struct ResolveNode {\n }\n \n pub fn build(build: &mut Build) {\n-    build_krate(build, \"src/libstd\");\n-    build_krate(build, \"src/libtest\");\n-    build_krate(build, \"src/rustc\");\n+    let mut resolves = Vec::new();\n+    build_krate(&build.std_features(), build, &mut resolves, \"src/libstd\");\n+    build_krate(\"\", build, &mut resolves, \"src/libtest\");\n+    build_krate(&build.rustc_features(), build, &mut resolves, \"src/rustc\");\n+\n+    let mut id2name = HashMap::with_capacity(build.crates.len());\n+    for (name, krate) in build.crates.iter() {\n+        id2name.insert(krate.id.clone(), name.clone());\n+    }\n+\n+    for node in resolves {\n+        let name = match id2name.get(&node.id) {\n+            Some(name) => name,\n+            None => continue,\n+        };\n+\n+        let krate = build.crates.get_mut(name).unwrap();\n+        for dep in node.dependencies.iter() {\n+            let dep = match id2name.get(dep) {\n+                Some(dep) => dep,\n+                None => continue,\n+            };\n+            krate.deps.insert(*dep);\n+        }\n+    }\n }\n \n-fn build_krate(build: &mut Build, krate: &str) {\n+fn build_krate(features: &str, build: &mut Build, resolves: &mut Vec<ResolveNode>, krate: &str) {\n     // Run `cargo metadata` to figure out what crates we're testing.\n     //\n     // Down below we're going to call `cargo test`, but to test the right set\n@@ -60,14 +83,13 @@ fn build_krate(build: &mut Build, krate: &str) {\n     let mut cargo = Command::new(&build.initial_cargo);\n     cargo.arg(\"metadata\")\n          .arg(\"--format-version\").arg(\"1\")\n+         .arg(\"--features\").arg(features)\n          .arg(\"--manifest-path\").arg(build.src.join(krate).join(\"Cargo.toml\"));\n     let output = output(&mut cargo);\n     let output: Output = serde_json::from_str(&output).unwrap();\n-    let mut id2name = HashMap::new();\n     for package in output.packages {\n         if package.source.is_none() {\n             let name = INTERNER.intern_string(package.name);\n-            id2name.insert(package.id, name);\n             let mut path = PathBuf::from(package.manifest_path);\n             path.pop();\n             build.crates.insert(name, Crate {\n@@ -77,25 +99,11 @@ fn build_krate(build: &mut Build, krate: &str) {\n                 bench_step: format!(\"bench-crate-{}\", name),\n                 name,\n                 version: package.version,\n-                deps: Vec::new(),\n+                id: package.id,\n+                deps: HashSet::new(),\n                 path,\n             });\n         }\n     }\n-\n-    for node in output.resolve.nodes {\n-        let name = match id2name.get(&node.id) {\n-            Some(name) => name,\n-            None => continue,\n-        };\n-\n-        let krate = build.crates.get_mut(name).unwrap();\n-        for dep in node.dependencies.iter() {\n-            let dep = match id2name.get(dep) {\n-                Some(dep) => dep,\n-                None => continue,\n-            };\n-            krate.deps.push(*dep);\n-        }\n-    }\n+    resolves.extend(output.resolve.nodes);\n }"}, {"sha": "bcf2f6a675e02715340fcd22a0350c9d264703ef", "filename": "src/bootstrap/mk/Makefile.in", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fbootstrap%2Fmk%2FMakefile.in", "raw_url": "https://github.com/rust-lang/rust/raw/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fbootstrap%2Fmk%2FMakefile.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fmk%2FMakefile.in?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd", "patch": "@@ -16,6 +16,12 @@ Q := @\n BOOTSTRAP_ARGS :=\n endif\n \n+ifdef EXCLUDE_CARGO\n+AUX_ARGS :=\n+else\n+AUX_ARGS := src/tools/cargo src/tools/cargotest\n+endif\n+\n BOOTSTRAP := $(CFG_PYTHON) $(CFG_SRC_DIR)src/bootstrap/bootstrap.py\n \n all:\n@@ -52,14 +58,13 @@ check:\n \t$(Q)$(BOOTSTRAP) test $(BOOTSTRAP_ARGS)\n check-aux:\n \t$(Q)$(BOOTSTRAP) test \\\n-\t\tsrc/tools/cargo \\\n-\t\tsrc/tools/cargotest \\\n \t\tsrc/test/pretty \\\n \t\tsrc/test/run-pass/pretty \\\n \t\tsrc/test/run-fail/pretty \\\n \t\tsrc/test/run-pass-valgrind/pretty \\\n \t\tsrc/test/run-pass-fulldeps/pretty \\\n \t\tsrc/test/run-fail-fulldeps/pretty \\\n+\t\t$(AUX_ARGS) \\\n \t\t$(BOOTSTRAP_ARGS)\n check-bootstrap:\n \t$(Q)$(CFG_PYTHON) $(CFG_SRC_DIR)src/bootstrap/bootstrap_test.py\n@@ -80,5 +85,12 @@ check-stage2-T-arm-linux-androideabi-H-x86_64-unknown-linux-gnu:\n check-stage2-T-x86_64-unknown-linux-musl-H-x86_64-unknown-linux-gnu:\n \t$(Q)$(BOOTSTRAP) test --target x86_64-unknown-linux-musl\n \n+TESTS_IN_2 := src/test/run-pass src/test/compile-fail src/test/run-pass-fulldeps\n+\n+appveyor-subset-1:\n+\t$(Q)$(BOOTSTRAP) test $(TESTS_IN_2:%=--exclude %)\n+appveyor-subset-2:\n+\t$(Q)$(BOOTSTRAP) test $(TESTS_IN_2)\n+\n \n .PHONY: dist"}, {"sha": "c99347aa94e6637548a86f2e49cf15262ad33775", "filename": "src/bootstrap/native.rs", "status": "modified", "additions": 340, "deletions": 136, "changes": 476, "blob_url": "https://github.com/rust-lang/rust/blob/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fbootstrap%2Fnative.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fbootstrap%2Fnative.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fnative.rs?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd", "patch": "@@ -22,101 +22,122 @@ use std::env;\n use std::ffi::OsString;\n use std::fs::{self, File};\n use std::io::{Read, Write};\n-use std::path::Path;\n+use std::path::{Path, PathBuf};\n use std::process::Command;\n \n use build_helper::output;\n use cmake;\n use cc;\n \n-use Build;\n-use util;\n+use util::{self, exe};\n use build_helper::up_to_date;\n use builder::{Builder, RunConfig, ShouldRun, Step};\n use cache::Interned;\n \n #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n pub struct Llvm {\n     pub target: Interned<String>,\n+    pub emscripten: bool,\n }\n \n impl Step for Llvm {\n-    type Output = ();\n+    type Output = PathBuf; // path to llvm-config\n+\n     const ONLY_HOSTS: bool = true;\n \n     fn should_run(run: ShouldRun) -> ShouldRun {\n-        run.path(\"src/llvm\")\n+        run.path(\"src/llvm\").path(\"src/llvm-emscripten\")\n     }\n \n     fn make_run(run: RunConfig) {\n-        run.builder.ensure(Llvm { target: run.target })\n+        let emscripten = run.path.ends_with(\"llvm-emscripten\");\n+        run.builder.ensure(Llvm {\n+            target: run.target,\n+            emscripten,\n+        });\n     }\n \n     /// Compile LLVM for `target`.\n-    fn run(self, builder: &Builder) {\n-        let build = builder.build;\n+    fn run(self, builder: &Builder) -> PathBuf {\n         let target = self.target;\n-\n-        // If we're not compiling for LLVM bail out here.\n-        if !build.config.llvm_enabled {\n-            return;\n-        }\n+        let emscripten = self.emscripten;\n \n         // If we're using a custom LLVM bail out here, but we can only use a\n         // custom LLVM for the build triple.\n-        if let Some(config) = build.config.target_config.get(&target) {\n-            if let Some(ref s) = config.llvm_config {\n-                return check_llvm_version(build, s);\n+        if !self.emscripten {\n+            if let Some(config) = builder.config.target_config.get(&target) {\n+                if let Some(ref s) = config.llvm_config {\n+                    check_llvm_version(builder, s);\n+                    return s.to_path_buf()\n+                }\n             }\n         }\n \n-        let rebuild_trigger = build.src.join(\"src/rustllvm/llvm-rebuild-trigger\");\n+        let rebuild_trigger = builder.src.join(\"src/rustllvm/llvm-rebuild-trigger\");\n         let mut rebuild_trigger_contents = String::new();\n         t!(t!(File::open(&rebuild_trigger)).read_to_string(&mut rebuild_trigger_contents));\n \n-        let out_dir = build.llvm_out(target);\n+        let (out_dir, llvm_config_ret_dir) = if emscripten {\n+            let dir = builder.emscripten_llvm_out(target);\n+            let config_dir = dir.join(\"bin\");\n+            (dir, config_dir)\n+        } else {\n+            let mut dir = builder.llvm_out(builder.config.build);\n+            if !builder.config.build.contains(\"msvc\") || builder.config.ninja {\n+                dir.push(\"build\");\n+            }\n+            (builder.llvm_out(target), dir.join(\"bin\"))\n+        };\n         let done_stamp = out_dir.join(\"llvm-finished-building\");\n+        let build_llvm_config = llvm_config_ret_dir\n+            .join(exe(\"llvm-config\", &*builder.config.build));\n         if done_stamp.exists() {\n             let mut done_contents = String::new();\n             t!(t!(File::open(&done_stamp)).read_to_string(&mut done_contents));\n \n             // If LLVM was already built previously and contents of the rebuild-trigger file\n             // didn't change from the previous build, then no action is required.\n             if done_contents == rebuild_trigger_contents {\n-                return\n+                return build_llvm_config\n             }\n         }\n \n-        let _folder = build.fold_output(|| \"llvm\");\n-        println!(\"Building LLVM for {}\", target);\n-        let _time = util::timeit();\n+        let _folder = builder.fold_output(|| \"llvm\");\n+        let descriptor = if emscripten { \"Emscripten \" } else { \"\" };\n+        builder.info(&format!(\"Building {}LLVM for {}\", descriptor, target));\n+        let _time = util::timeit(&builder);\n         t!(fs::create_dir_all(&out_dir));\n \n         // http://llvm.org/docs/CMake.html\n-        let mut cfg = cmake::Config::new(build.src.join(\"src/llvm\"));\n-        if build.config.ninja {\n-            cfg.generator(\"Ninja\");\n-        }\n+        let root = if self.emscripten { \"src/llvm-emscripten\" } else { \"src/llvm\" };\n+        let mut cfg = cmake::Config::new(builder.src.join(root));\n \n-        let profile = match (build.config.llvm_optimize, build.config.llvm_release_debuginfo) {\n+        let profile = match (builder.config.llvm_optimize, builder.config.llvm_release_debuginfo) {\n             (false, _) => \"Debug\",\n             (true, false) => \"Release\",\n             (true, true) => \"RelWithDebInfo\",\n         };\n \n-        // NOTE: remember to also update `config.toml.example` when changing the defaults!\n-        let llvm_targets = match build.config.llvm_targets {\n-            Some(ref s) => s,\n-            None => \"X86;ARM;AArch64;Mips;PowerPC;SystemZ;JSBackend;MSP430;Sparc;NVPTX;Hexagon\",\n+        // NOTE: remember to also update `config.toml.example` when changing the\n+        // defaults!\n+        let llvm_targets = if self.emscripten {\n+            \"JSBackend\"\n+        } else {\n+            match builder.config.llvm_targets {\n+                Some(ref s) => s,\n+                None => \"X86;ARM;AArch64;Mips;PowerPC;SystemZ;MSP430;Sparc;NVPTX;Hexagon\",\n+            }\n         };\n \n-        let llvm_exp_targets = &build.config.llvm_experimental_targets;\n+        let llvm_exp_targets = if self.emscripten {\n+            \"\"\n+        } else {\n+            &builder.config.llvm_experimental_targets[..]\n+        };\n \n-        let assertions = if build.config.llvm_assertions {\"ON\"} else {\"OFF\"};\n+        let assertions = if builder.config.llvm_assertions {\"ON\"} else {\"OFF\"};\n \n-        cfg.target(&target)\n-           .host(&build.build)\n-           .out_dir(&out_dir)\n+        cfg.out_dir(&out_dir)\n            .profile(profile)\n            .define(\"LLVM_ENABLE_ASSERTIONS\", assertions)\n            .define(\"LLVM_TARGETS_TO_BUILD\", llvm_targets)\n@@ -128,17 +149,42 @@ impl Step for Llvm {\n            .define(\"WITH_POLLY\", \"OFF\")\n            .define(\"LLVM_ENABLE_TERMINFO\", \"OFF\")\n            .define(\"LLVM_ENABLE_LIBEDIT\", \"OFF\")\n-           .define(\"LLVM_PARALLEL_COMPILE_JOBS\", build.jobs().to_string())\n+           .define(\"LLVM_PARALLEL_COMPILE_JOBS\", builder.jobs().to_string())\n            .define(\"LLVM_TARGET_ARCH\", target.split('-').next().unwrap())\n            .define(\"LLVM_DEFAULT_TARGET_TRIPLE\", target);\n \n+        // By default, LLVM will automatically find OCaml and, if it finds it,\n+        // install the LLVM bindings in LLVM_OCAML_INSTALL_PATH, which defaults\n+        // to /usr/bin/ocaml.\n+        // This causes problem for non-root builds of Rust. Side-step the issue\n+        // by setting LLVM_OCAML_INSTALL_PATH to a relative path, so it installs\n+        // in the prefix.\n+        cfg.define(\"LLVM_OCAML_INSTALL_PATH\",\n+            env::var_os(\"LLVM_OCAML_INSTALL_PATH\").unwrap_or_else(|| \"usr/lib/ocaml\".into()));\n+\n+        let want_lldb = builder.config.lldb_enabled && !self.emscripten;\n \n         // This setting makes the LLVM tools link to the dynamic LLVM library,\n         // which saves both memory during parallel links and overall disk space\n         // for the tools.  We don't distribute any of those tools, so this is\n         // just a local concern.  However, it doesn't work well everywhere.\n-        if target.contains(\"linux-gnu\") || target.contains(\"apple-darwin\") {\n-           cfg.define(\"LLVM_LINK_LLVM_DYLIB\", \"ON\");\n+        //\n+        // If we are shipping llvm tools then we statically link them LLVM\n+        if (target.contains(\"linux-gnu\") || target.contains(\"apple-darwin\")) &&\n+            !builder.config.llvm_tools_enabled &&\n+            !want_lldb {\n+                cfg.define(\"LLVM_LINK_LLVM_DYLIB\", \"ON\");\n+        }\n+\n+        // For distribution we want the LLVM tools to be *statically* linked to libstdc++\n+        if builder.config.llvm_tools_enabled || want_lldb {\n+            if !target.contains(\"windows\") {\n+                if target.contains(\"apple\") {\n+                    cfg.define(\"CMAKE_EXE_LINKER_FLAGS\", \"-static-libstdc++\");\n+                } else {\n+                    cfg.define(\"CMAKE_EXE_LINKER_FLAGS\", \"-Wl,-Bsymbolic -static-libstdc++\");\n+                }\n+            }\n         }\n \n         if target.contains(\"msvc\") {\n@@ -152,19 +198,33 @@ impl Step for Llvm {\n             cfg.define(\"LLVM_BUILD_32_BITS\", \"ON\");\n         }\n \n-        if let Some(num_linkers) = build.config.llvm_link_jobs {\n+        if want_lldb {\n+            cfg.define(\"LLVM_EXTERNAL_CLANG_SOURCE_DIR\", builder.src.join(\"src/tools/clang\"));\n+            cfg.define(\"LLVM_EXTERNAL_LLDB_SOURCE_DIR\", builder.src.join(\"src/tools/lldb\"));\n+            // For the time being, disable code signing.\n+            cfg.define(\"LLDB_CODESIGN_IDENTITY\", \"\");\n+        } else {\n+            // LLDB requires libxml2; but otherwise we want it to be disabled.\n+            // See https://github.com/rust-lang/rust/pull/50104\n+            cfg.define(\"LLVM_ENABLE_LIBXML2\", \"OFF\");\n+        }\n+\n+        if let Some(num_linkers) = builder.config.llvm_link_jobs {\n             if num_linkers > 0 {\n                 cfg.define(\"LLVM_PARALLEL_LINK_JOBS\", num_linkers.to_string());\n             }\n         }\n \n         // http://llvm.org/docs/HowToCrossCompileLLVM.html\n-        if target != build.build {\n-            builder.ensure(Llvm { target: build.build });\n+        if target != builder.config.build && !emscripten {\n+            builder.ensure(Llvm {\n+                target: builder.config.build,\n+                emscripten: false,\n+            });\n             // FIXME: if the llvm root for the build triple is overridden then we\n             //        should use llvm-tblgen from there, also should verify that it\n             //        actually exists most of the time in normal installs of LLVM.\n-            let host = build.llvm_out(build.build).join(\"bin/llvm-tblgen\");\n+            let host = builder.llvm_out(builder.config.build).join(\"bin/llvm-tblgen\");\n             cfg.define(\"CMAKE_CROSSCOMPILING\", \"True\")\n                .define(\"LLVM_TABLEGEN\", &host);\n \n@@ -174,96 +234,227 @@ impl Step for Llvm {\n                cfg.define(\"CMAKE_SYSTEM_NAME\", \"FreeBSD\");\n             }\n \n-            cfg.define(\"LLVM_NATIVE_BUILD\", build.llvm_out(build.build).join(\"build\"));\n+            cfg.define(\"LLVM_NATIVE_BUILD\", builder.llvm_out(builder.config.build).join(\"build\"));\n         }\n \n-        let sanitize_cc = |cc: &Path| {\n-            if target.contains(\"msvc\") {\n-                OsString::from(cc.to_str().unwrap().replace(\"\\\\\", \"/\"))\n-            } else {\n-                cc.as_os_str().to_owned()\n-            }\n-        };\n-\n-        let configure_compilers = |cfg: &mut cmake::Config| {\n-            // MSVC with CMake uses msbuild by default which doesn't respect these\n-            // vars that we'd otherwise configure. In that case we just skip this\n-            // entirely.\n-            if target.contains(\"msvc\") && !build.config.ninja {\n-                return\n-            }\n-\n-            let cc = build.cc(target);\n-            let cxx = build.cxx(target).unwrap();\n-\n-            // Handle msvc + ninja + ccache specially (this is what the bots use)\n-            if target.contains(\"msvc\") &&\n-               build.config.ninja &&\n-               build.config.ccache.is_some() {\n-                let mut cc = env::current_exe().expect(\"failed to get cwd\");\n-                cc.set_file_name(\"sccache-plus-cl.exe\");\n-\n-               cfg.define(\"CMAKE_C_COMPILER\", sanitize_cc(&cc))\n-                  .define(\"CMAKE_CXX_COMPILER\", sanitize_cc(&cc));\n-               cfg.env(\"SCCACHE_PATH\",\n-                       build.config.ccache.as_ref().unwrap())\n-                  .env(\"SCCACHE_TARGET\", target);\n-\n-            // If ccache is configured we inform the build a little differently hwo\n-            // to invoke ccache while also invoking our compilers.\n-            } else if let Some(ref ccache) = build.config.ccache {\n-               cfg.define(\"CMAKE_C_COMPILER\", ccache)\n-                  .define(\"CMAKE_C_COMPILER_ARG1\", sanitize_cc(cc))\n-                  .define(\"CMAKE_CXX_COMPILER\", ccache)\n-                  .define(\"CMAKE_CXX_COMPILER_ARG1\", sanitize_cc(cxx));\n-            } else {\n-               cfg.define(\"CMAKE_C_COMPILER\", sanitize_cc(cc))\n-                  .define(\"CMAKE_CXX_COMPILER\", sanitize_cc(cxx));\n-            }\n-\n-            cfg.build_arg(\"-j\").build_arg(build.jobs().to_string());\n-            cfg.define(\"CMAKE_C_FLAGS\", build.cflags(target).join(\" \"));\n-            cfg.define(\"CMAKE_CXX_FLAGS\", build.cflags(target).join(\" \"));\n-            if let Some(ar) = build.ar(target) {\n-                if ar.is_absolute() {\n-                    // LLVM build breaks if `CMAKE_AR` is a relative path, for some reason it\n-                    // tries to resolve this path in the LLVM build directory.\n-                    cfg.define(\"CMAKE_AR\", sanitize_cc(ar));\n-                }\n-            }\n-        };\n-\n-        configure_compilers(&mut cfg);\n-\n-        if env::var_os(\"SCCACHE_ERROR_LOG\").is_some() {\n-            cfg.env(\"RUST_LOG\", \"sccache=warn\");\n-        }\n+        configure_cmake(builder, target, &mut cfg, false);\n \n         // FIXME: we don't actually need to build all LLVM tools and all LLVM\n         //        libraries here, e.g. we just want a few components and a few\n         //        tools. Figure out how to filter them down and only build the right\n         //        tools and libs on all platforms.\n+\n+        if builder.config.dry_run {\n+            return build_llvm_config;\n+        }\n+\n         cfg.build();\n \n         t!(t!(File::create(&done_stamp)).write_all(rebuild_trigger_contents.as_bytes()));\n+\n+        build_llvm_config\n     }\n }\n \n-fn check_llvm_version(build: &Build, llvm_config: &Path) {\n-    if !build.config.llvm_version_check {\n+fn check_llvm_version(builder: &Builder, llvm_config: &Path) {\n+    if !builder.config.llvm_version_check {\n         return\n     }\n \n+    if builder.config.dry_run {\n+        return;\n+    }\n+\n     let mut cmd = Command::new(llvm_config);\n     let version = output(cmd.arg(\"--version\"));\n     let mut parts = version.split('.').take(2)\n         .filter_map(|s| s.parse::<u32>().ok());\n-    if let (Some(major), Some(minor)) = (parts.next(), parts.next()) {\n-        if major > 3 || (major == 3 && minor >= 9) {\n+    if let (Some(major), Some(_minor)) = (parts.next(), parts.next()) {\n+        if major >= 5 {\n             return\n         }\n     }\n-    panic!(\"\\n\\nbad LLVM version: {}, need >=3.9\\n\\n\", version)\n+    panic!(\"\\n\\nbad LLVM version: {}, need >=5.0\\n\\n\", version)\n+}\n+\n+fn configure_cmake(builder: &Builder,\n+                   target: Interned<String>,\n+                   cfg: &mut cmake::Config,\n+                   building_dist_binaries: bool) {\n+    if builder.config.ninja {\n+        cfg.generator(\"Ninja\");\n+    }\n+    cfg.target(&target)\n+       .host(&builder.config.build);\n+\n+    let sanitize_cc = |cc: &Path| {\n+        if target.contains(\"msvc\") {\n+            OsString::from(cc.to_str().unwrap().replace(\"\\\\\", \"/\"))\n+        } else {\n+            cc.as_os_str().to_owned()\n+        }\n+    };\n+\n+    // MSVC with CMake uses msbuild by default which doesn't respect these\n+    // vars that we'd otherwise configure. In that case we just skip this\n+    // entirely.\n+    if target.contains(\"msvc\") && !builder.config.ninja {\n+        return\n+    }\n+\n+    let (cc, cxx) = match builder.config.llvm_clang_cl {\n+        Some(ref cl) => (cl.as_ref(), cl.as_ref()),\n+        None => (builder.cc(target), builder.cxx(target).unwrap()),\n+    };\n+\n+    // Handle msvc + ninja + ccache specially (this is what the bots use)\n+    if target.contains(\"msvc\") &&\n+       builder.config.ninja &&\n+       builder.config.ccache.is_some()\n+    {\n+       let mut wrap_cc = env::current_exe().expect(\"failed to get cwd\");\n+       wrap_cc.set_file_name(\"sccache-plus-cl.exe\");\n+\n+       cfg.define(\"CMAKE_C_COMPILER\", sanitize_cc(&wrap_cc))\n+          .define(\"CMAKE_CXX_COMPILER\", sanitize_cc(&wrap_cc));\n+       cfg.env(\"SCCACHE_PATH\",\n+               builder.config.ccache.as_ref().unwrap())\n+          .env(\"SCCACHE_TARGET\", target)\n+          .env(\"SCCACHE_CC\", &cc)\n+          .env(\"SCCACHE_CXX\", &cxx);\n+\n+       // Building LLVM on MSVC can be a little ludicrous at times. We're so far\n+       // off the beaten path here that I'm not really sure this is even half\n+       // supported any more. Here we're trying to:\n+       //\n+       // * Build LLVM on MSVC\n+       // * Build LLVM with `clang-cl` instead of `cl.exe`\n+       // * Build a project with `sccache`\n+       // * Build for 32-bit as well\n+       // * Build with Ninja\n+       //\n+       // For `cl.exe` there are different binaries to compile 32/64 bit which\n+       // we use but for `clang-cl` there's only one which internally\n+       // multiplexes via flags. As a result it appears that CMake's detection\n+       // of a compiler's architecture and such on MSVC **doesn't** pass any\n+       // custom flags we pass in CMAKE_CXX_FLAGS below. This means that if we\n+       // use `clang-cl.exe` it's always diagnosed as a 64-bit compiler which\n+       // definitely causes problems since all the env vars are pointing to\n+       // 32-bit libraries.\n+       //\n+       // To hack aroudn this... again... we pass an argument that's\n+       // unconditionally passed in the sccache shim. This'll get CMake to\n+       // correctly diagnose it's doing a 32-bit compilation and LLVM will\n+       // internally configure itself appropriately.\n+       if builder.config.llvm_clang_cl.is_some() && target.contains(\"i686\") {\n+           cfg.env(\"SCCACHE_EXTRA_ARGS\", \"-m32\");\n+       }\n+\n+    // If ccache is configured we inform the build a little differently hwo\n+    // to invoke ccache while also invoking our compilers.\n+    } else if let Some(ref ccache) = builder.config.ccache {\n+       cfg.define(\"CMAKE_C_COMPILER\", ccache)\n+          .define(\"CMAKE_C_COMPILER_ARG1\", sanitize_cc(cc))\n+          .define(\"CMAKE_CXX_COMPILER\", ccache)\n+          .define(\"CMAKE_CXX_COMPILER_ARG1\", sanitize_cc(cxx));\n+    } else {\n+       cfg.define(\"CMAKE_C_COMPILER\", sanitize_cc(cc))\n+          .define(\"CMAKE_CXX_COMPILER\", sanitize_cc(cxx));\n+    }\n+\n+    cfg.build_arg(\"-j\").build_arg(builder.jobs().to_string());\n+    cfg.define(\"CMAKE_C_FLAGS\", builder.cflags(target).join(\" \"));\n+    let mut cxxflags = builder.cflags(target).join(\" \");\n+    if building_dist_binaries {\n+        if builder.config.llvm_static_stdcpp && !target.contains(\"windows\") {\n+            cxxflags.push_str(\" -static-libstdc++\");\n+        }\n+    }\n+    cfg.define(\"CMAKE_CXX_FLAGS\", cxxflags);\n+    if let Some(ar) = builder.ar(target) {\n+        if ar.is_absolute() {\n+            // LLVM build breaks if `CMAKE_AR` is a relative path, for some reason it\n+            // tries to resolve this path in the LLVM build directory.\n+            cfg.define(\"CMAKE_AR\", sanitize_cc(ar));\n+        }\n+    }\n+\n+    if env::var_os(\"SCCACHE_ERROR_LOG\").is_some() {\n+        cfg.env(\"RUST_LOG\", \"sccache=warn\");\n+    }\n+}\n+\n+#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n+pub struct Lld {\n+    pub target: Interned<String>,\n+}\n+\n+impl Step for Lld {\n+    type Output = PathBuf;\n+    const ONLY_HOSTS: bool = true;\n+\n+    fn should_run(run: ShouldRun) -> ShouldRun {\n+        run.path(\"src/tools/lld\")\n+    }\n+\n+    fn make_run(run: RunConfig) {\n+        run.builder.ensure(Lld { target: run.target });\n+    }\n+\n+    /// Compile LLVM for `target`.\n+    fn run(self, builder: &Builder) -> PathBuf {\n+        if builder.config.dry_run {\n+            return PathBuf::from(\"lld-out-dir-test-gen\");\n+        }\n+        let target = self.target;\n+\n+        let llvm_config = builder.ensure(Llvm {\n+            target: self.target,\n+            emscripten: false,\n+        });\n+\n+        let out_dir = builder.lld_out(target);\n+        let done_stamp = out_dir.join(\"lld-finished-building\");\n+        if done_stamp.exists() {\n+            return out_dir\n+        }\n+\n+        let _folder = builder.fold_output(|| \"lld\");\n+        builder.info(&format!(\"Building LLD for {}\", target));\n+        let _time = util::timeit(&builder);\n+        t!(fs::create_dir_all(&out_dir));\n+\n+        let mut cfg = cmake::Config::new(builder.src.join(\"src/tools/lld\"));\n+        configure_cmake(builder, target, &mut cfg, true);\n+\n+        // This is an awful, awful hack. Discovered when we migrated to using\n+        // clang-cl to compile LLVM/LLD it turns out that LLD, when built out of\n+        // tree, will execute `llvm-config --cmakedir` and then tell CMake about\n+        // that directory for later processing. Unfortunately if this path has\n+        // forward slashes in it (which it basically always does on Windows)\n+        // then CMake will hit a syntax error later on as... something isn't\n+        // escaped it seems?\n+        //\n+        // Instead of attempting to fix this problem in upstream CMake and/or\n+        // LLVM/LLD we just hack around it here. This thin wrapper will take the\n+        // output from llvm-config and replace all instances of `\\` with `/` to\n+        // ensure we don't hit the same bugs with escaping. It means that you\n+        // can't build on a system where your paths require `\\` on Windows, but\n+        // there's probably a lot of reasons you can't do that other than this.\n+        let llvm_config_shim = env::current_exe()\n+            .unwrap()\n+            .with_file_name(\"llvm-config-wrapper\");\n+        cfg.out_dir(&out_dir)\n+           .profile(\"Release\")\n+           .env(\"LLVM_CONFIG_REAL\", llvm_config)\n+           .define(\"LLVM_CONFIG_PATH\", llvm_config_shim)\n+           .define(\"LLVM_INCLUDE_TESTS\", \"OFF\");\n+\n+        cfg.build();\n+\n+        t!(File::create(&done_stamp));\n+        out_dir\n+    }\n }\n \n #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n@@ -275,7 +466,7 @@ impl Step for TestHelpers {\n     type Output = ();\n \n     fn should_run(run: ShouldRun) -> ShouldRun {\n-        run.path(\"src/rt/rust_test_helpers.c\")\n+        run.path(\"src/test/auxiliary/rust_test_helpers.c\")\n     }\n \n     fn make_run(run: RunConfig) {\n@@ -285,44 +476,46 @@ impl Step for TestHelpers {\n     /// Compiles the `rust_test_helpers.c` library which we used in various\n     /// `run-pass` test suites for ABI testing.\n     fn run(self, builder: &Builder) {\n-        let build = builder.build;\n+        if builder.config.dry_run {\n+            return;\n+        }\n         let target = self.target;\n-        let dst = build.test_helpers_out(target);\n-        let src = build.src.join(\"src/rt/rust_test_helpers.c\");\n+        let dst = builder.test_helpers_out(target);\n+        let src = builder.src.join(\"src/test/auxiliary/rust_test_helpers.c\");\n         if up_to_date(&src, &dst.join(\"librust_test_helpers.a\")) {\n             return\n         }\n \n-        let _folder = build.fold_output(|| \"build_test_helpers\");\n-        println!(\"Building test helpers\");\n+        let _folder = builder.fold_output(|| \"build_test_helpers\");\n+        builder.info(\"Building test helpers\");\n         t!(fs::create_dir_all(&dst));\n         let mut cfg = cc::Build::new();\n \n         // We may have found various cross-compilers a little differently due to our\n         // extra configuration, so inform gcc of these compilers. Note, though, that\n         // on MSVC we still need gcc's detection of env vars (ugh).\n         if !target.contains(\"msvc\") {\n-            if let Some(ar) = build.ar(target) {\n+            if let Some(ar) = builder.ar(target) {\n                 cfg.archiver(ar);\n             }\n-            cfg.compiler(build.cc(target));\n+            cfg.compiler(builder.cc(target));\n         }\n \n         cfg.cargo_metadata(false)\n            .out_dir(&dst)\n            .target(&target)\n-           .host(&build.build)\n+           .host(&builder.config.build)\n            .opt_level(0)\n            .warnings(false)\n            .debug(false)\n-           .file(build.src.join(\"src/rt/rust_test_helpers.c\"))\n+           .file(builder.src.join(\"src/test/auxiliary/rust_test_helpers.c\"))\n            .compile(\"rust_test_helpers\");\n     }\n }\n \n-const OPENSSL_VERS: &'static str = \"1.0.2m\";\n+const OPENSSL_VERS: &'static str = \"1.0.2n\";\n const OPENSSL_SHA256: &'static str =\n-    \"8c6ff15ec6b319b50788f42c7abc2890c08ba5a1cdcd3810eb9092deada37b0f\";\n+    \"370babb75f278c39e0c50e8c4e7493bc0f18db6867478341a832a982fd15a8fe\";\n \n #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n pub struct Openssl {\n@@ -337,9 +530,11 @@ impl Step for Openssl {\n     }\n \n     fn run(self, builder: &Builder) {\n-        let build = builder.build;\n+        if builder.config.dry_run {\n+            return;\n+        }\n         let target = self.target;\n-        let out = match build.openssl_dir(target) {\n+        let out = match builder.openssl_dir(target) {\n             Some(dir) => dir,\n             None => return,\n         };\n@@ -375,7 +570,8 @@ impl Step for Openssl {\n                 }\n \n                 // Ensure the hash is correct.\n-                let mut shasum = if target.contains(\"apple\") || build.build.contains(\"netbsd\") {\n+                let mut shasum = if target.contains(\"apple\") ||\n+                    builder.config.build.contains(\"netbsd\") {\n                     let mut cmd = Command::new(\"shasum\");\n                     cmd.arg(\"-a\").arg(\"256\");\n                     cmd\n@@ -408,10 +604,10 @@ impl Step for Openssl {\n             t!(fs::rename(&tmp, &tarball));\n         }\n         let obj = out.join(format!(\"openssl-{}\", OPENSSL_VERS));\n-        let dst = build.openssl_install_dir(target).unwrap();\n+        let dst = builder.openssl_install_dir(target).unwrap();\n         drop(fs::remove_dir_all(&obj));\n         drop(fs::remove_dir_all(&dst));\n-        build.run(Command::new(\"tar\").arg(\"zxf\").arg(&tarball).current_dir(&out));\n+        builder.run(Command::new(\"tar\").arg(\"zxf\").arg(&tarball).current_dir(&out));\n \n         let mut configure = Command::new(\"perl\");\n         configure.arg(obj.join(\"Configure\"));\n@@ -424,11 +620,14 @@ impl Step for Openssl {\n             \"aarch64-linux-android\" => \"linux-aarch64\",\n             \"aarch64-unknown-linux-gnu\" => \"linux-aarch64\",\n             \"aarch64-unknown-linux-musl\" => \"linux-aarch64\",\n+            \"aarch64-unknown-netbsd\" => \"BSD-generic64\",\n             \"arm-linux-androideabi\" => \"android\",\n             \"arm-unknown-linux-gnueabi\" => \"linux-armv4\",\n             \"arm-unknown-linux-gnueabihf\" => \"linux-armv4\",\n+            \"armv6-unknown-netbsd-eabihf\" => \"BSD-generic32\",\n             \"armv7-linux-androideabi\" => \"android-armv7\",\n             \"armv7-unknown-linux-gnueabihf\" => \"linux-armv4\",\n+            \"armv7-unknown-netbsd-eabihf\" => \"BSD-generic32\",\n             \"i586-unknown-linux-gnu\" => \"linux-elf\",\n             \"i586-unknown-linux-musl\" => \"linux-elf\",\n             \"i686-apple-darwin\" => \"darwin-i386-cc\",\n@@ -442,23 +641,28 @@ impl Step for Openssl {\n             \"mips64el-unknown-linux-gnuabi64\" => \"linux64-mips64\",\n             \"mipsel-unknown-linux-gnu\" => \"linux-mips32\",\n             \"powerpc-unknown-linux-gnu\" => \"linux-ppc\",\n+            \"powerpc-unknown-linux-gnuspe\" => \"linux-ppc\",\n+            \"powerpc-unknown-netbsd\" => \"BSD-generic32\",\n             \"powerpc64-unknown-linux-gnu\" => \"linux-ppc64\",\n             \"powerpc64le-unknown-linux-gnu\" => \"linux-ppc64le\",\n+            \"powerpc64le-unknown-linux-musl\" => \"linux-ppc64le\",\n             \"s390x-unknown-linux-gnu\" => \"linux64-s390x\",\n+            \"sparc-unknown-linux-gnu\" => \"linux-sparcv9\",\n             \"sparc64-unknown-linux-gnu\" => \"linux64-sparcv9\",\n             \"sparc64-unknown-netbsd\" => \"BSD-sparc64\",\n             \"x86_64-apple-darwin\" => \"darwin64-x86_64-cc\",\n             \"x86_64-linux-android\" => \"linux-x86_64\",\n             \"x86_64-unknown-freebsd\" => \"BSD-x86_64\",\n             \"x86_64-unknown-dragonfly\" => \"BSD-x86_64\",\n             \"x86_64-unknown-linux-gnu\" => \"linux-x86_64\",\n+            \"x86_64-unknown-linux-gnux32\" => \"linux-x32\",\n             \"x86_64-unknown-linux-musl\" => \"linux-x86_64\",\n             \"x86_64-unknown-netbsd\" => \"BSD-x86_64\",\n             _ => panic!(\"don't know how to configure OpenSSL for {}\", target),\n         };\n         configure.arg(os);\n-        configure.env(\"CC\", build.cc(target));\n-        for flag in build.cflags(target) {\n+        configure.env(\"CC\", builder.cc(target));\n+        for flag in builder.cflags(target) {\n             configure.arg(flag);\n         }\n         // There is no specific os target for android aarch64 or x86_64,\n@@ -470,7 +674,7 @@ impl Step for Openssl {\n         if target == \"sparc64-unknown-netbsd\" {\n             // Need -m64 to get assembly generated correctly for sparc64.\n             configure.arg(\"-m64\");\n-            if build.build.contains(\"netbsd\") {\n+            if builder.config.build.contains(\"netbsd\") {\n                 // Disable sparc64 asm on NetBSD builders, it uses\n                 // m4(1)'s -B flag, which NetBSD m4 does not support.\n                 configure.arg(\"no-asm\");\n@@ -483,12 +687,12 @@ impl Step for Openssl {\n             configure.arg(\"no-asm\");\n         }\n         configure.current_dir(&obj);\n-        println!(\"Configuring openssl for {}\", target);\n-        build.run_quiet(&mut configure);\n-        println!(\"Building openssl for {}\", target);\n-        build.run_quiet(Command::new(\"make\").arg(\"-j1\").current_dir(&obj));\n-        println!(\"Installing openssl for {}\", target);\n-        build.run_quiet(Command::new(\"make\").arg(\"install\").current_dir(&obj));\n+        builder.info(&format!(\"Configuring openssl for {}\", target));\n+        builder.run_quiet(&mut configure);\n+        builder.info(&format!(\"Building openssl for {}\", target));\n+        builder.run_quiet(Command::new(\"make\").arg(\"-j1\").current_dir(&obj));\n+        builder.info(&format!(\"Installing openssl for {}\", target));\n+        builder.run_quiet(Command::new(\"make\").arg(\"install\").arg(\"-j1\").current_dir(&obj));\n \n         let mut f = t!(File::create(&stamp));\n         t!(f.write_all(OPENSSL_VERS.as_bytes()));"}, {"sha": "c2610de23bebadf6678a5c5bf7187b3311398dd2", "filename": "src/bootstrap/sanity.rs", "status": "modified", "additions": 23, "deletions": 6, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fbootstrap%2Fsanity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fbootstrap%2Fsanity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fsanity.rs?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd", "patch": "@@ -140,14 +140,18 @@ pub fn check(build: &mut Build) {\n             continue;\n         }\n \n-        cmd_finder.must_have(build.cc(*target));\n-        if let Some(ar) = build.ar(*target) {\n-            cmd_finder.must_have(ar);\n+        if !build.config.dry_run {\n+            cmd_finder.must_have(build.cc(*target));\n+            if let Some(ar) = build.ar(*target) {\n+                cmd_finder.must_have(ar);\n+            }\n         }\n     }\n \n     for host in &build.hosts {\n-        cmd_finder.must_have(build.cxx(*host).unwrap());\n+        if !build.config.dry_run {\n+            cmd_finder.must_have(build.cxx(*host).unwrap());\n+        }\n \n         // The msvc hosts don't use jemalloc, turn it off globally to\n         // avoid packaging the dummy liballoc_jemalloc on that platform.\n@@ -169,13 +173,26 @@ pub fn check(build: &mut Build) {\n             panic!(\"the iOS target is only supported on macOS\");\n         }\n \n+        if target.contains(\"-none-\") {\n+            if build.no_std(*target).is_none() {\n+                let target = build.config.target_config.entry(target.clone())\n+                    .or_default();\n+\n+                target.no_std = true;\n+            }\n+\n+            if build.no_std(*target) == Some(false) {\n+                panic!(\"All the *-none-* targets are no-std targets\")\n+            }\n+        }\n+\n         // Make sure musl-root is valid\n-        if target.contains(\"musl\") && !target.contains(\"mips\") {\n+        if target.contains(\"musl\") {\n             // If this is a native target (host is also musl) and no musl-root is given,\n             // fall back to the system toolchain in /usr before giving up\n             if build.musl_root(*target).is_none() && build.config.build == *target {\n                 let target = build.config.target_config.entry(target.clone())\n-                                 .or_insert(Default::default());\n+                    .or_default();\n                 target.musl_root = Some(\"/usr\".into());\n             }\n             match build.musl_root(*target) {"}, {"sha": "f762d9414cff383d0554c76d3f8f87ad994eb8dd", "filename": "src/bootstrap/test.rs", "status": "added", "additions": 1967, "deletions": 0, "changes": 1967, "blob_url": "https://github.com/rust-lang/rust/blob/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fbootstrap%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fbootstrap%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftest.rs?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd", "patch": "@@ -0,0 +1,1967 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Implementation of the test-related targets of the build system.\n+//!\n+//! This file implements the various regression test suites that we execute on\n+//! our CI.\n+\n+use std::env;\n+use std::ffi::OsString;\n+use std::fmt;\n+use std::fs::{self, File};\n+use std::io::Read;\n+use std::iter;\n+use std::path::{Path, PathBuf};\n+use std::process::Command;\n+\n+use build_helper::{self, output};\n+\n+use builder::{Builder, Compiler, Kind, RunConfig, ShouldRun, Step};\n+use cache::{Interned, INTERNER};\n+use compile;\n+use dist;\n+use flags::Subcommand;\n+use native;\n+use tool::{self, Tool, SourceType};\n+use toolstate::ToolState;\n+use util::{self, dylib_path, dylib_path_var};\n+use Crate as CargoCrate;\n+use {DocTests, Mode};\n+\n+const ADB_TEST_DIR: &str = \"/data/tmp/work\";\n+\n+/// The two modes of the test runner; tests or benchmarks.\n+#[derive(Debug, PartialEq, Eq, Hash, Copy, Clone, PartialOrd, Ord)]\n+pub enum TestKind {\n+    /// Run `cargo test`\n+    Test,\n+    /// Run `cargo bench`\n+    Bench,\n+}\n+\n+impl From<Kind> for TestKind {\n+    fn from(kind: Kind) -> Self {\n+        match kind {\n+            Kind::Test => TestKind::Test,\n+            Kind::Bench => TestKind::Bench,\n+            _ => panic!(\"unexpected kind in crate: {:?}\", kind),\n+        }\n+    }\n+}\n+\n+impl TestKind {\n+    // Return the cargo subcommand for this test kind\n+    fn subcommand(self) -> &'static str {\n+        match self {\n+            TestKind::Test => \"test\",\n+            TestKind::Bench => \"bench\",\n+        }\n+    }\n+}\n+\n+impl fmt::Display for TestKind {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.write_str(match *self {\n+            TestKind::Test => \"Testing\",\n+            TestKind::Bench => \"Benchmarking\",\n+        })\n+    }\n+}\n+\n+fn try_run(builder: &Builder, cmd: &mut Command) -> bool {\n+    if !builder.fail_fast {\n+        if !builder.try_run(cmd) {\n+            let mut failures = builder.delayed_failures.borrow_mut();\n+            failures.push(format!(\"{:?}\", cmd));\n+            return false;\n+        }\n+    } else {\n+        builder.run(cmd);\n+    }\n+    true\n+}\n+\n+fn try_run_quiet(builder: &Builder, cmd: &mut Command) -> bool {\n+    if !builder.fail_fast {\n+        if !builder.try_run_quiet(cmd) {\n+            let mut failures = builder.delayed_failures.borrow_mut();\n+            failures.push(format!(\"{:?}\", cmd));\n+            return false;\n+        }\n+    } else {\n+        builder.run_quiet(cmd);\n+    }\n+    true\n+}\n+\n+#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n+pub struct Linkcheck {\n+    host: Interned<String>,\n+}\n+\n+impl Step for Linkcheck {\n+    type Output = ();\n+    const ONLY_HOSTS: bool = true;\n+    const DEFAULT: bool = true;\n+\n+    /// Runs the `linkchecker` tool as compiled in `stage` by the `host` compiler.\n+    ///\n+    /// This tool in `src/tools` will verify the validity of all our links in the\n+    /// documentation to ensure we don't have a bunch of dead ones.\n+    fn run(self, builder: &Builder) {\n+        let host = self.host;\n+\n+        builder.info(&format!(\"Linkcheck ({})\", host));\n+\n+        builder.default_doc(None);\n+\n+        let _time = util::timeit(&builder);\n+        try_run(\n+            builder,\n+            builder\n+                .tool_cmd(Tool::Linkchecker)\n+                .arg(builder.out.join(host).join(\"doc\")),\n+        );\n+    }\n+\n+    fn should_run(run: ShouldRun) -> ShouldRun {\n+        let builder = run.builder;\n+        run.path(\"src/tools/linkchecker\")\n+            .default_condition(builder.config.docs)\n+    }\n+\n+    fn make_run(run: RunConfig) {\n+        run.builder.ensure(Linkcheck { host: run.target });\n+    }\n+}\n+\n+#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n+pub struct Cargotest {\n+    stage: u32,\n+    host: Interned<String>,\n+}\n+\n+impl Step for Cargotest {\n+    type Output = ();\n+    const ONLY_HOSTS: bool = true;\n+\n+    fn should_run(run: ShouldRun) -> ShouldRun {\n+        run.path(\"src/tools/cargotest\")\n+    }\n+\n+    fn make_run(run: RunConfig) {\n+        run.builder.ensure(Cargotest {\n+            stage: run.builder.top_stage,\n+            host: run.target,\n+        });\n+    }\n+\n+    /// Runs the `cargotest` tool as compiled in `stage` by the `host` compiler.\n+    ///\n+    /// This tool in `src/tools` will check out a few Rust projects and run `cargo\n+    /// test` to ensure that we don't regress the test suites there.\n+    fn run(self, builder: &Builder) {\n+        let compiler = builder.compiler(self.stage, self.host);\n+        builder.ensure(compile::Rustc {\n+            compiler,\n+            target: compiler.host,\n+        });\n+\n+        // Note that this is a short, cryptic, and not scoped directory name. This\n+        // is currently to minimize the length of path on Windows where we otherwise\n+        // quickly run into path name limit constraints.\n+        let out_dir = builder.out.join(\"ct\");\n+        t!(fs::create_dir_all(&out_dir));\n+\n+        let _time = util::timeit(&builder);\n+        let mut cmd = builder.tool_cmd(Tool::CargoTest);\n+        try_run(\n+            builder,\n+            cmd.arg(&builder.initial_cargo)\n+                .arg(&out_dir)\n+                .env(\"RUSTC\", builder.rustc(compiler))\n+                .env(\"RUSTDOC\", builder.rustdoc(compiler.host)),\n+        );\n+    }\n+}\n+\n+#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n+pub struct Cargo {\n+    stage: u32,\n+    host: Interned<String>,\n+}\n+\n+impl Step for Cargo {\n+    type Output = ();\n+    const ONLY_HOSTS: bool = true;\n+\n+    fn should_run(run: ShouldRun) -> ShouldRun {\n+        run.path(\"src/tools/cargo\")\n+    }\n+\n+    fn make_run(run: RunConfig) {\n+        run.builder.ensure(Cargo {\n+            stage: run.builder.top_stage,\n+            host: run.target,\n+        });\n+    }\n+\n+    /// Runs `cargo test` for `cargo` packaged with Rust.\n+    fn run(self, builder: &Builder) {\n+        let compiler = builder.compiler(self.stage, self.host);\n+\n+        builder.ensure(tool::Cargo {\n+            compiler,\n+            target: self.host,\n+        });\n+        let mut cargo = tool::prepare_tool_cargo(builder,\n+                                                 compiler,\n+                                                 Mode::ToolRustc,\n+                                                 self.host,\n+                                                 \"test\",\n+                                                 \"src/tools/cargo\",\n+                                                 SourceType::Submodule);\n+\n+        if !builder.fail_fast {\n+            cargo.arg(\"--no-fail-fast\");\n+        }\n+\n+        // Don't run cross-compile tests, we may not have cross-compiled libstd libs\n+        // available.\n+        cargo.env(\"CFG_DISABLE_CROSS_TESTS\", \"1\");\n+\n+        try_run(\n+            builder,\n+            cargo.env(\"PATH\", &path_for_cargo(builder, compiler)),\n+        );\n+    }\n+}\n+\n+#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n+pub struct Rls {\n+    stage: u32,\n+    host: Interned<String>,\n+}\n+\n+impl Step for Rls {\n+    type Output = ();\n+    const ONLY_HOSTS: bool = true;\n+\n+    fn should_run(run: ShouldRun) -> ShouldRun {\n+        run.path(\"src/tools/rls\")\n+    }\n+\n+    fn make_run(run: RunConfig) {\n+        run.builder.ensure(Rls {\n+            stage: run.builder.top_stage,\n+            host: run.target,\n+        });\n+    }\n+\n+    /// Runs `cargo test` for the rls.\n+    fn run(self, builder: &Builder) {\n+        let stage = self.stage;\n+        let host = self.host;\n+        let compiler = builder.compiler(stage, host);\n+\n+        let build_result = builder.ensure(tool::Rls {\n+            compiler,\n+            target: self.host,\n+            extra_features: Vec::new(),\n+        });\n+        if build_result.is_none() {\n+            eprintln!(\"failed to test rls: could not build\");\n+            return;\n+        }\n+\n+        let mut cargo = tool::prepare_tool_cargo(builder,\n+                                                 compiler,\n+                                                 Mode::ToolRustc,\n+                                                 host,\n+                                                 \"test\",\n+                                                 \"src/tools/rls\",\n+                                                 SourceType::Submodule);\n+\n+        // Copy `src/tools/rls/test_data` to a writable drive.\n+        let test_workspace_path = builder.out.join(\"rls-test-data\");\n+        let test_data_path = test_workspace_path.join(\"test_data\");\n+        builder.create_dir(&test_data_path);\n+        builder.cp_r(&builder.src.join(\"src/tools/rls/test_data\"), &test_data_path);\n+        cargo.env(\"RLS_TEST_WORKSPACE_DIR\", test_workspace_path);\n+\n+        builder.add_rustc_lib_path(compiler, &mut cargo);\n+        cargo.arg(\"--\")\n+            .args(builder.config.cmd.test_args());\n+\n+        if try_run(builder, &mut cargo) {\n+            builder.save_toolstate(\"rls\", ToolState::TestPass);\n+        }\n+    }\n+}\n+\n+#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n+pub struct Rustfmt {\n+    stage: u32,\n+    host: Interned<String>,\n+}\n+\n+impl Step for Rustfmt {\n+    type Output = ();\n+    const ONLY_HOSTS: bool = true;\n+\n+    fn should_run(run: ShouldRun) -> ShouldRun {\n+        run.path(\"src/tools/rustfmt\")\n+    }\n+\n+    fn make_run(run: RunConfig) {\n+        run.builder.ensure(Rustfmt {\n+            stage: run.builder.top_stage,\n+            host: run.target,\n+        });\n+    }\n+\n+    /// Runs `cargo test` for rustfmt.\n+    fn run(self, builder: &Builder) {\n+        let stage = self.stage;\n+        let host = self.host;\n+        let compiler = builder.compiler(stage, host);\n+\n+        let build_result = builder.ensure(tool::Rustfmt {\n+            compiler,\n+            target: self.host,\n+            extra_features: Vec::new(),\n+        });\n+        if build_result.is_none() {\n+            eprintln!(\"failed to test rustfmt: could not build\");\n+            return;\n+        }\n+\n+        let mut cargo = tool::prepare_tool_cargo(builder,\n+                                                 compiler,\n+                                                 Mode::ToolRustc,\n+                                                 host,\n+                                                 \"test\",\n+                                                 \"src/tools/rustfmt\",\n+                                                 SourceType::Submodule);\n+\n+        let dir = testdir(builder, compiler.host);\n+        t!(fs::create_dir_all(&dir));\n+        cargo.env(\"RUSTFMT_TEST_DIR\", dir);\n+\n+        builder.add_rustc_lib_path(compiler, &mut cargo);\n+\n+        if try_run(builder, &mut cargo) {\n+            builder.save_toolstate(\"rustfmt\", ToolState::TestPass);\n+        }\n+    }\n+}\n+\n+#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n+pub struct Miri {\n+    stage: u32,\n+    host: Interned<String>,\n+}\n+\n+impl Step for Miri {\n+    type Output = ();\n+    const ONLY_HOSTS: bool = true;\n+    const DEFAULT: bool = true;\n+\n+    fn should_run(run: ShouldRun) -> ShouldRun {\n+        let test_miri = run.builder.config.test_miri;\n+        run.path(\"src/tools/miri\").default_condition(test_miri)\n+    }\n+\n+    fn make_run(run: RunConfig) {\n+        run.builder.ensure(Miri {\n+            stage: run.builder.top_stage,\n+            host: run.target,\n+        });\n+    }\n+\n+    /// Runs `cargo test` for miri.\n+    fn run(self, builder: &Builder) {\n+        let stage = self.stage;\n+        let host = self.host;\n+        let compiler = builder.compiler(stage, host);\n+\n+        let miri = builder.ensure(tool::Miri {\n+            compiler,\n+            target: self.host,\n+            extra_features: Vec::new(),\n+        });\n+        if let Some(miri) = miri {\n+            let mut cargo = tool::prepare_tool_cargo(builder,\n+                                                 compiler,\n+                                                 Mode::ToolRustc,\n+                                                 host,\n+                                                 \"test\",\n+                                                 \"src/tools/miri\",\n+                                                 SourceType::Submodule);\n+\n+            // miri tests need to know about the stage sysroot\n+            cargo.env(\"MIRI_SYSROOT\", builder.sysroot(compiler));\n+            cargo.env(\"RUSTC_TEST_SUITE\", builder.rustc(compiler));\n+            cargo.env(\"RUSTC_LIB_PATH\", builder.rustc_libdir(compiler));\n+            cargo.env(\"MIRI_PATH\", miri);\n+\n+            builder.add_rustc_lib_path(compiler, &mut cargo);\n+\n+            if try_run(builder, &mut cargo) {\n+                builder.save_toolstate(\"miri\", ToolState::TestPass);\n+            }\n+        } else {\n+            eprintln!(\"failed to test miri: could not build\");\n+        }\n+    }\n+}\n+\n+#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n+pub struct Clippy {\n+    stage: u32,\n+    host: Interned<String>,\n+}\n+\n+impl Step for Clippy {\n+    type Output = ();\n+    const ONLY_HOSTS: bool = true;\n+    const DEFAULT: bool = false;\n+\n+    fn should_run(run: ShouldRun) -> ShouldRun {\n+        run.path(\"src/tools/clippy\")\n+    }\n+\n+    fn make_run(run: RunConfig) {\n+        run.builder.ensure(Clippy {\n+            stage: run.builder.top_stage,\n+            host: run.target,\n+        });\n+    }\n+\n+    /// Runs `cargo test` for clippy.\n+    fn run(self, builder: &Builder) {\n+        let stage = self.stage;\n+        let host = self.host;\n+        let compiler = builder.compiler(stage, host);\n+\n+        let clippy = builder.ensure(tool::Clippy {\n+            compiler,\n+            target: self.host,\n+            extra_features: Vec::new(),\n+        });\n+        if let Some(clippy) = clippy {\n+            let mut cargo = tool::prepare_tool_cargo(builder,\n+                                                 compiler,\n+                                                 Mode::ToolRustc,\n+                                                 host,\n+                                                 \"test\",\n+                                                 \"src/tools/clippy\",\n+                                                 SourceType::Submodule);\n+\n+            // clippy tests need to know about the stage sysroot\n+            cargo.env(\"SYSROOT\", builder.sysroot(compiler));\n+            cargo.env(\"RUSTC_TEST_SUITE\", builder.rustc(compiler));\n+            cargo.env(\"RUSTC_LIB_PATH\", builder.rustc_libdir(compiler));\n+            let host_libs = builder\n+                .stage_out(compiler, Mode::ToolRustc)\n+                .join(builder.cargo_dir());\n+            cargo.env(\"HOST_LIBS\", host_libs);\n+            // clippy tests need to find the driver\n+            cargo.env(\"CLIPPY_DRIVER_PATH\", clippy);\n+\n+            builder.add_rustc_lib_path(compiler, &mut cargo);\n+\n+            if try_run(builder, &mut cargo) {\n+                builder.save_toolstate(\"clippy-driver\", ToolState::TestPass);\n+            }\n+        } else {\n+            eprintln!(\"failed to test clippy: could not build\");\n+        }\n+    }\n+}\n+\n+fn path_for_cargo(builder: &Builder, compiler: Compiler) -> OsString {\n+    // Configure PATH to find the right rustc. NB. we have to use PATH\n+    // and not RUSTC because the Cargo test suite has tests that will\n+    // fail if rustc is not spelled `rustc`.\n+    let path = builder.sysroot(compiler).join(\"bin\");\n+    let old_path = env::var_os(\"PATH\").unwrap_or_default();\n+    env::join_paths(iter::once(path).chain(env::split_paths(&old_path))).expect(\"\")\n+}\n+\n+#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n+pub struct RustdocTheme {\n+    pub compiler: Compiler,\n+}\n+\n+impl Step for RustdocTheme {\n+    type Output = ();\n+    const DEFAULT: bool = true;\n+    const ONLY_HOSTS: bool = true;\n+\n+    fn should_run(run: ShouldRun) -> ShouldRun {\n+        run.path(\"src/tools/rustdoc-themes\")\n+    }\n+\n+    fn make_run(run: RunConfig) {\n+        let compiler = run.builder.compiler(run.builder.top_stage, run.host);\n+\n+        run.builder.ensure(RustdocTheme { compiler: compiler });\n+    }\n+\n+    fn run(self, builder: &Builder) {\n+        let rustdoc = builder.out.join(\"bootstrap/debug/rustdoc\");\n+        let mut cmd = builder.tool_cmd(Tool::RustdocTheme);\n+        cmd.arg(rustdoc.to_str().unwrap())\n+            .arg(\n+                builder\n+                    .src\n+                    .join(\"src/librustdoc/html/static/themes\")\n+                    .to_str()\n+                    .unwrap(),\n+            )\n+            .env(\"RUSTC_STAGE\", self.compiler.stage.to_string())\n+            .env(\"RUSTC_SYSROOT\", builder.sysroot(self.compiler))\n+            .env(\n+                \"RUSTDOC_LIBDIR\",\n+                builder.sysroot_libdir(self.compiler, self.compiler.host),\n+            )\n+            .env(\"CFG_RELEASE_CHANNEL\", &builder.config.channel)\n+            .env(\"RUSTDOC_REAL\", builder.rustdoc(self.compiler.host))\n+            .env(\"RUSTDOC_CRATE_VERSION\", builder.rust_version())\n+            .env(\"RUSTC_BOOTSTRAP\", \"1\");\n+        if let Some(linker) = builder.linker(self.compiler.host) {\n+            cmd.env(\"RUSTC_TARGET_LINKER\", linker);\n+        }\n+        try_run(builder, &mut cmd);\n+    }\n+}\n+\n+#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n+pub struct RustdocJS {\n+    pub host: Interned<String>,\n+    pub target: Interned<String>,\n+}\n+\n+impl Step for RustdocJS {\n+    type Output = ();\n+    const DEFAULT: bool = true;\n+    const ONLY_HOSTS: bool = true;\n+\n+    fn should_run(run: ShouldRun) -> ShouldRun {\n+        run.path(\"src/test/rustdoc-js\")\n+    }\n+\n+    fn make_run(run: RunConfig) {\n+        run.builder.ensure(RustdocJS {\n+            host: run.host,\n+            target: run.target,\n+        });\n+    }\n+\n+    fn run(self, builder: &Builder) {\n+        if let Some(ref nodejs) = builder.config.nodejs {\n+            let mut command = Command::new(nodejs);\n+            command.args(&[\"src/tools/rustdoc-js/tester.js\", &*self.host]);\n+            builder.ensure(::doc::Std {\n+                target: self.target,\n+                stage: builder.top_stage,\n+            });\n+            builder.run(&mut command);\n+        } else {\n+            builder.info(&format!(\n+                \"No nodejs found, skipping \\\"src/test/rustdoc-js\\\" tests\"\n+            ));\n+        }\n+    }\n+}\n+\n+#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n+pub struct RustdocUi {\n+    pub host: Interned<String>,\n+    pub target: Interned<String>,\n+    pub compiler: Compiler,\n+}\n+\n+impl Step for RustdocUi {\n+    type Output = ();\n+    const DEFAULT: bool = true;\n+    const ONLY_HOSTS: bool = true;\n+\n+    fn should_run(run: ShouldRun) -> ShouldRun {\n+        run.path(\"src/test/rustdoc-ui\")\n+    }\n+\n+    fn make_run(run: RunConfig) {\n+        let compiler = run.builder.compiler(run.builder.top_stage, run.host);\n+        run.builder.ensure(RustdocUi {\n+            host: run.host,\n+            target: run.target,\n+            compiler,\n+        });\n+    }\n+\n+    fn run(self, builder: &Builder) {\n+        builder.ensure(Compiletest {\n+            compiler: self.compiler,\n+            target: self.target,\n+            mode: \"ui\",\n+            suite: \"rustdoc-ui\",\n+            path: None,\n+            compare_mode: None,\n+        })\n+    }\n+}\n+\n+#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n+pub struct Tidy;\n+\n+impl Step for Tidy {\n+    type Output = ();\n+    const DEFAULT: bool = true;\n+    const ONLY_HOSTS: bool = true;\n+\n+    /// Runs the `tidy` tool.\n+    ///\n+    /// This tool in `src/tools` checks up on various bits and pieces of style and\n+    /// otherwise just implements a few lint-like checks that are specific to the\n+    /// compiler itself.\n+    fn run(self, builder: &Builder) {\n+        let mut cmd = builder.tool_cmd(Tool::Tidy);\n+        cmd.arg(builder.src.join(\"src\"));\n+        cmd.arg(&builder.initial_cargo);\n+        if !builder.config.vendor {\n+            cmd.arg(\"--no-vendor\");\n+        }\n+        if !builder.config.verbose_tests {\n+            cmd.arg(\"--quiet\");\n+        }\n+\n+        let _folder = builder.fold_output(|| \"tidy\");\n+        builder.info(&format!(\"tidy check\"));\n+        try_run(builder, &mut cmd);\n+    }\n+\n+    fn should_run(run: ShouldRun) -> ShouldRun {\n+        run.path(\"src/tools/tidy\")\n+    }\n+\n+    fn make_run(run: RunConfig) {\n+        run.builder.ensure(Tidy);\n+    }\n+}\n+\n+fn testdir(builder: &Builder, host: Interned<String>) -> PathBuf {\n+    builder.out.join(host).join(\"test\")\n+}\n+\n+macro_rules! default_test {\n+    ($name:ident { path: $path:expr, mode: $mode:expr, suite: $suite:expr }) => {\n+        test!($name { path: $path, mode: $mode, suite: $suite, default: true, host: false });\n+    }\n+}\n+\n+macro_rules! default_test_with_compare_mode {\n+    ($name:ident { path: $path:expr, mode: $mode:expr, suite: $suite:expr,\n+                   compare_mode: $compare_mode:expr }) => {\n+        test_with_compare_mode!($name { path: $path, mode: $mode, suite: $suite, default: true,\n+                                        host: false, compare_mode: $compare_mode });\n+    }\n+}\n+\n+macro_rules! host_test {\n+    ($name:ident { path: $path:expr, mode: $mode:expr, suite: $suite:expr }) => {\n+        test!($name { path: $path, mode: $mode, suite: $suite, default: true, host: true });\n+    }\n+}\n+\n+macro_rules! test {\n+    ($name:ident { path: $path:expr, mode: $mode:expr, suite: $suite:expr, default: $default:expr,\n+                   host: $host:expr }) => {\n+        test_definitions!($name { path: $path, mode: $mode, suite: $suite, default: $default,\n+                                  host: $host, compare_mode: None });\n+    }\n+}\n+\n+macro_rules! test_with_compare_mode {\n+    ($name:ident { path: $path:expr, mode: $mode:expr, suite: $suite:expr, default: $default:expr,\n+                   host: $host:expr, compare_mode: $compare_mode:expr }) => {\n+        test_definitions!($name { path: $path, mode: $mode, suite: $suite, default: $default,\n+                                  host: $host, compare_mode: Some($compare_mode) });\n+    }\n+}\n+\n+macro_rules! test_definitions {\n+    ($name:ident {\n+        path: $path:expr,\n+        mode: $mode:expr,\n+        suite: $suite:expr,\n+        default: $default:expr,\n+        host: $host:expr,\n+        compare_mode: $compare_mode:expr\n+    }) => {\n+        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n+        pub struct $name {\n+            pub compiler: Compiler,\n+            pub target: Interned<String>,\n+        }\n+\n+        impl Step for $name {\n+            type Output = ();\n+            const DEFAULT: bool = $default;\n+            const ONLY_HOSTS: bool = $host;\n+\n+            fn should_run(run: ShouldRun) -> ShouldRun {\n+                run.suite_path($path)\n+            }\n+\n+            fn make_run(run: RunConfig) {\n+                let compiler = run.builder.compiler(run.builder.top_stage, run.host);\n+\n+                run.builder.ensure($name {\n+                    compiler,\n+                    target: run.target,\n+                });\n+            }\n+\n+            fn run(self, builder: &Builder) {\n+                builder.ensure(Compiletest {\n+                    compiler: self.compiler,\n+                    target: self.target,\n+                    mode: $mode,\n+                    suite: $suite,\n+                    path: Some($path),\n+                    compare_mode: $compare_mode,\n+                })\n+            }\n+        }\n+    }\n+}\n+\n+default_test_with_compare_mode!(Ui {\n+    path: \"src/test/ui\",\n+    mode: \"ui\",\n+    suite: \"ui\",\n+    compare_mode: \"nll\"\n+});\n+\n+default_test!(RunPass {\n+    path: \"src/test/run-pass\",\n+    mode: \"run-pass\",\n+    suite: \"run-pass\"\n+});\n+\n+default_test!(CompileFail {\n+    path: \"src/test/compile-fail\",\n+    mode: \"compile-fail\",\n+    suite: \"compile-fail\"\n+});\n+\n+default_test!(ParseFail {\n+    path: \"src/test/parse-fail\",\n+    mode: \"parse-fail\",\n+    suite: \"parse-fail\"\n+});\n+\n+default_test!(RunFail {\n+    path: \"src/test/run-fail\",\n+    mode: \"run-fail\",\n+    suite: \"run-fail\"\n+});\n+\n+default_test!(RunPassValgrind {\n+    path: \"src/test/run-pass-valgrind\",\n+    mode: \"run-pass-valgrind\",\n+    suite: \"run-pass-valgrind\"\n+});\n+\n+default_test!(MirOpt {\n+    path: \"src/test/mir-opt\",\n+    mode: \"mir-opt\",\n+    suite: \"mir-opt\"\n+});\n+\n+default_test!(Codegen {\n+    path: \"src/test/codegen\",\n+    mode: \"codegen\",\n+    suite: \"codegen\"\n+});\n+\n+default_test!(CodegenUnits {\n+    path: \"src/test/codegen-units\",\n+    mode: \"codegen-units\",\n+    suite: \"codegen-units\"\n+});\n+\n+default_test!(Incremental {\n+    path: \"src/test/incremental\",\n+    mode: \"incremental\",\n+    suite: \"incremental\"\n+});\n+\n+default_test!(Debuginfo {\n+    path: \"src/test/debuginfo\",\n+    // What this runs varies depending on the native platform being apple\n+    mode: \"debuginfo-XXX\",\n+    suite: \"debuginfo\"\n+});\n+\n+host_test!(UiFullDeps {\n+    path: \"src/test/ui-fulldeps\",\n+    mode: \"ui\",\n+    suite: \"ui-fulldeps\"\n+});\n+\n+host_test!(RunPassFullDeps {\n+    path: \"src/test/run-pass-fulldeps\",\n+    mode: \"run-pass\",\n+    suite: \"run-pass-fulldeps\"\n+});\n+\n+host_test!(RunFailFullDeps {\n+    path: \"src/test/run-fail-fulldeps\",\n+    mode: \"run-fail\",\n+    suite: \"run-fail-fulldeps\"\n+});\n+\n+host_test!(CompileFailFullDeps {\n+    path: \"src/test/compile-fail-fulldeps\",\n+    mode: \"compile-fail\",\n+    suite: \"compile-fail-fulldeps\"\n+});\n+\n+host_test!(IncrementalFullDeps {\n+    path: \"src/test/incremental-fulldeps\",\n+    mode: \"incremental\",\n+    suite: \"incremental-fulldeps\"\n+});\n+\n+host_test!(Rustdoc {\n+    path: \"src/test/rustdoc\",\n+    mode: \"rustdoc\",\n+    suite: \"rustdoc\"\n+});\n+\n+test!(Pretty {\n+    path: \"src/test/pretty\",\n+    mode: \"pretty\",\n+    suite: \"pretty\",\n+    default: false,\n+    host: true\n+});\n+test!(RunPassPretty {\n+    path: \"src/test/run-pass/pretty\",\n+    mode: \"pretty\",\n+    suite: \"run-pass\",\n+    default: false,\n+    host: true\n+});\n+test!(RunFailPretty {\n+    path: \"src/test/run-fail/pretty\",\n+    mode: \"pretty\",\n+    suite: \"run-fail\",\n+    default: false,\n+    host: true\n+});\n+test!(RunPassValgrindPretty {\n+    path: \"src/test/run-pass-valgrind/pretty\",\n+    mode: \"pretty\",\n+    suite: \"run-pass-valgrind\",\n+    default: false,\n+    host: true\n+});\n+test!(RunPassFullDepsPretty {\n+    path: \"src/test/run-pass-fulldeps/pretty\",\n+    mode: \"pretty\",\n+    suite: \"run-pass-fulldeps\",\n+    default: false,\n+    host: true\n+});\n+test!(RunFailFullDepsPretty {\n+    path: \"src/test/run-fail-fulldeps/pretty\",\n+    mode: \"pretty\",\n+    suite: \"run-fail-fulldeps\",\n+    default: false,\n+    host: true\n+});\n+\n+default_test!(RunMake {\n+    path: \"src/test/run-make\",\n+    mode: \"run-make\",\n+    suite: \"run-make\"\n+});\n+\n+host_test!(RunMakeFullDeps {\n+    path: \"src/test/run-make-fulldeps\",\n+    mode: \"run-make\",\n+    suite: \"run-make-fulldeps\"\n+});\n+\n+#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n+struct Compiletest {\n+    compiler: Compiler,\n+    target: Interned<String>,\n+    mode: &'static str,\n+    suite: &'static str,\n+    path: Option<&'static str>,\n+    compare_mode: Option<&'static str>,\n+}\n+\n+impl Step for Compiletest {\n+    type Output = ();\n+\n+    fn should_run(run: ShouldRun) -> ShouldRun {\n+        run.never()\n+    }\n+\n+    /// Executes the `compiletest` tool to run a suite of tests.\n+    ///\n+    /// Compiles all tests with `compiler` for `target` with the specified\n+    /// compiletest `mode` and `suite` arguments. For example `mode` can be\n+    /// \"run-pass\" or `suite` can be something like `debuginfo`.\n+    fn run(self, builder: &Builder) {\n+        let compiler = self.compiler;\n+        let target = self.target;\n+        let mode = self.mode;\n+        let suite = self.suite;\n+\n+        // Path for test suite\n+        let suite_path = self.path.unwrap_or(\"\");\n+\n+        // Skip codegen tests if they aren't enabled in configuration.\n+        if !builder.config.codegen_tests && suite == \"codegen\" {\n+            return;\n+        }\n+\n+        if suite == \"debuginfo\" {\n+            // Skip debuginfo tests on MSVC\n+            if builder.config.build.contains(\"msvc\") {\n+                return;\n+            }\n+\n+            if mode == \"debuginfo-XXX\" {\n+                return if builder.config.build.contains(\"apple\") {\n+                    builder.ensure(Compiletest {\n+                        mode: \"debuginfo-lldb\",\n+                        ..self\n+                    });\n+                } else {\n+                    builder.ensure(Compiletest {\n+                        mode: \"debuginfo-gdb\",\n+                        ..self\n+                    });\n+                };\n+            }\n+\n+            builder.ensure(dist::DebuggerScripts {\n+                sysroot: builder.sysroot(compiler),\n+                host: target,\n+            });\n+        }\n+\n+        if suite.ends_with(\"fulldeps\") ||\n+            // FIXME: Does pretty need librustc compiled? Note that there are\n+            // fulldeps test suites with mode = pretty as well.\n+            mode == \"pretty\"\n+        {\n+            builder.ensure(compile::Rustc { compiler, target });\n+        }\n+\n+        if builder.no_std(target) == Some(true) {\n+            // the `test` doesn't compile for no-std targets\n+            builder.ensure(compile::Std { compiler, target });\n+        } else {\n+            builder.ensure(compile::Test { compiler, target });\n+        }\n+\n+        if builder.no_std(target) == Some(true) {\n+            // for no_std run-make (e.g. thumb*),\n+            // we need a host compiler which is called by cargo.\n+            builder.ensure(compile::Std { compiler, target: compiler.host });\n+        }\n+\n+        builder.ensure(native::TestHelpers { target });\n+        builder.ensure(RemoteCopyLibs { compiler, target });\n+\n+        let mut cmd = builder.tool_cmd(Tool::Compiletest);\n+\n+        // compiletest currently has... a lot of arguments, so let's just pass all\n+        // of them!\n+\n+        cmd.arg(\"--compile-lib-path\")\n+            .arg(builder.rustc_libdir(compiler));\n+        cmd.arg(\"--run-lib-path\")\n+            .arg(builder.sysroot_libdir(compiler, target));\n+        cmd.arg(\"--rustc-path\").arg(builder.rustc(compiler));\n+\n+        let is_rustdoc_ui = suite.ends_with(\"rustdoc-ui\");\n+\n+        // Avoid depending on rustdoc when we don't need it.\n+        if mode == \"rustdoc\"\n+            || (mode == \"run-make\" && suite.ends_with(\"fulldeps\"))\n+            || (mode == \"ui\" && is_rustdoc_ui)\n+        {\n+            cmd.arg(\"--rustdoc-path\")\n+                .arg(builder.rustdoc(compiler.host));\n+        }\n+\n+        cmd.arg(\"--src-base\")\n+            .arg(builder.src.join(\"src/test\").join(suite));\n+        cmd.arg(\"--build-base\")\n+            .arg(testdir(builder, compiler.host).join(suite));\n+        cmd.arg(\"--stage-id\")\n+            .arg(format!(\"stage{}-{}\", compiler.stage, target));\n+        cmd.arg(\"--mode\").arg(mode);\n+        cmd.arg(\"--target\").arg(target);\n+        cmd.arg(\"--host\").arg(&*compiler.host);\n+        cmd.arg(\"--llvm-filecheck\")\n+            .arg(builder.llvm_filecheck(builder.config.build));\n+\n+        if builder.config.cmd.bless() {\n+            cmd.arg(\"--bless\");\n+        }\n+\n+        let compare_mode = builder.config.cmd.compare_mode().or(self.compare_mode);\n+\n+        if let Some(ref nodejs) = builder.config.nodejs {\n+            cmd.arg(\"--nodejs\").arg(nodejs);\n+        }\n+\n+        let mut flags = if is_rustdoc_ui {\n+            Vec::new()\n+        } else {\n+            vec![\"-Crpath\".to_string()]\n+        };\n+        if !is_rustdoc_ui {\n+            if builder.config.rust_optimize_tests {\n+                flags.push(\"-O\".to_string());\n+            }\n+            if builder.config.rust_debuginfo_tests {\n+                flags.push(\"-g\".to_string());\n+            }\n+        }\n+        flags.push(\"-Zunstable-options\".to_string());\n+        flags.push(builder.config.cmd.rustc_args().join(\" \"));\n+\n+        if let Some(linker) = builder.linker(target) {\n+            cmd.arg(\"--linker\").arg(linker);\n+        }\n+\n+        let hostflags = flags.clone();\n+        cmd.arg(\"--host-rustcflags\").arg(hostflags.join(\" \"));\n+\n+        let mut targetflags = flags.clone();\n+        targetflags.push(format!(\n+            \"-Lnative={}\",\n+            builder.test_helpers_out(target).display()\n+        ));\n+        cmd.arg(\"--target-rustcflags\").arg(targetflags.join(\" \"));\n+\n+        cmd.arg(\"--docck-python\").arg(builder.python());\n+\n+        if builder.config.build.ends_with(\"apple-darwin\") {\n+            // Force /usr/bin/python on macOS for LLDB tests because we're loading the\n+            // LLDB plugin's compiled module which only works with the system python\n+            // (namely not Homebrew-installed python)\n+            cmd.arg(\"--lldb-python\").arg(\"/usr/bin/python\");\n+        } else {\n+            cmd.arg(\"--lldb-python\").arg(builder.python());\n+        }\n+\n+        if let Some(ref gdb) = builder.config.gdb {\n+            cmd.arg(\"--gdb\").arg(gdb);\n+        }\n+        if let Some(ref vers) = builder.lldb_version {\n+            cmd.arg(\"--lldb-version\").arg(vers);\n+        }\n+        if let Some(ref dir) = builder.lldb_python_dir {\n+            cmd.arg(\"--lldb-python-dir\").arg(dir);\n+        }\n+\n+        // Get paths from cmd args\n+        let paths = match &builder.config.cmd {\n+            Subcommand::Test { ref paths, .. } => &paths[..],\n+            _ => &[],\n+        };\n+\n+        // Get test-args by striping suite path\n+        let mut test_args: Vec<&str> = paths\n+            .iter()\n+            .map(|p| {\n+                match p.strip_prefix(\".\") {\n+                    Ok(path) => path,\n+                    Err(_) => p,\n+                }\n+            })\n+            .filter(|p| p.starts_with(suite_path) && p.is_file())\n+            .map(|p| p.strip_prefix(suite_path).unwrap().to_str().unwrap())\n+            .collect();\n+\n+        test_args.append(&mut builder.config.cmd.test_args());\n+\n+        cmd.args(&test_args);\n+\n+        if builder.is_verbose() {\n+            cmd.arg(\"--verbose\");\n+        }\n+\n+        if !builder.config.verbose_tests {\n+            cmd.arg(\"--quiet\");\n+        }\n+\n+        if builder.config.llvm_enabled {\n+            let llvm_config = builder.ensure(native::Llvm {\n+                target: builder.config.build,\n+                emscripten: false,\n+            });\n+            if !builder.config.dry_run {\n+                let llvm_version = output(Command::new(&llvm_config).arg(\"--version\"));\n+                cmd.arg(\"--llvm-version\").arg(llvm_version);\n+            }\n+            if !builder.is_rust_llvm(target) {\n+                cmd.arg(\"--system-llvm\");\n+            }\n+\n+            // Only pass correct values for these flags for the `run-make` suite as it\n+            // requires that a C++ compiler was configured which isn't always the case.\n+            if !builder.config.dry_run && suite == \"run-make-fulldeps\" {\n+                let llvm_components = output(Command::new(&llvm_config).arg(\"--components\"));\n+                let llvm_cxxflags = output(Command::new(&llvm_config).arg(\"--cxxflags\"));\n+                cmd.arg(\"--cc\")\n+                    .arg(builder.cc(target))\n+                    .arg(\"--cxx\")\n+                    .arg(builder.cxx(target).unwrap())\n+                    .arg(\"--cflags\")\n+                    .arg(builder.cflags(target).join(\" \"))\n+                    .arg(\"--llvm-components\")\n+                    .arg(llvm_components.trim())\n+                    .arg(\"--llvm-cxxflags\")\n+                    .arg(llvm_cxxflags.trim());\n+                if let Some(ar) = builder.ar(target) {\n+                    cmd.arg(\"--ar\").arg(ar);\n+                }\n+            }\n+        }\n+        if suite == \"run-make-fulldeps\" && !builder.config.llvm_enabled {\n+            builder.info(&format!(\n+                \"Ignoring run-make test suite as they generally don't work without LLVM\"\n+            ));\n+            return;\n+        }\n+\n+        if suite != \"run-make-fulldeps\" {\n+            cmd.arg(\"--cc\")\n+                .arg(\"\")\n+                .arg(\"--cxx\")\n+                .arg(\"\")\n+                .arg(\"--cflags\")\n+                .arg(\"\")\n+                .arg(\"--llvm-components\")\n+                .arg(\"\")\n+                .arg(\"--llvm-cxxflags\")\n+                .arg(\"\");\n+        }\n+\n+        if builder.remote_tested(target) {\n+            cmd.arg(\"--remote-test-client\")\n+                .arg(builder.tool_exe(Tool::RemoteTestClient));\n+        }\n+\n+        // Running a C compiler on MSVC requires a few env vars to be set, to be\n+        // sure to set them here.\n+        //\n+        // Note that if we encounter `PATH` we make sure to append to our own `PATH`\n+        // rather than stomp over it.\n+        if target.contains(\"msvc\") {\n+            for &(ref k, ref v) in builder.cc[&target].env() {\n+                if k != \"PATH\" {\n+                    cmd.env(k, v);\n+                }\n+            }\n+        }\n+        cmd.env(\"RUSTC_BOOTSTRAP\", \"1\");\n+        builder.add_rust_test_threads(&mut cmd);\n+\n+        if builder.config.sanitizers {\n+            cmd.env(\"SANITIZER_SUPPORT\", \"1\");\n+        }\n+\n+        if builder.config.profiler {\n+            cmd.env(\"PROFILER_SUPPORT\", \"1\");\n+        }\n+\n+        cmd.env(\"RUST_TEST_TMPDIR\", builder.out.join(\"tmp\"));\n+\n+        cmd.arg(\"--adb-path\").arg(\"adb\");\n+        cmd.arg(\"--adb-test-dir\").arg(ADB_TEST_DIR);\n+        if target.contains(\"android\") {\n+            // Assume that cc for this target comes from the android sysroot\n+            cmd.arg(\"--android-cross-path\")\n+                .arg(builder.cc(target).parent().unwrap().parent().unwrap());\n+        } else {\n+            cmd.arg(\"--android-cross-path\").arg(\"\");\n+        }\n+\n+        builder.ci_env.force_coloring_in_ci(&mut cmd);\n+\n+        let _folder = builder.fold_output(|| format!(\"test_{}\", suite));\n+        builder.info(&format!(\n+            \"Check compiletest suite={} mode={} ({} -> {})\",\n+            suite, mode, &compiler.host, target\n+        ));\n+        let _time = util::timeit(&builder);\n+        try_run(builder, &mut cmd);\n+\n+        if let Some(compare_mode) = compare_mode {\n+            cmd.arg(\"--compare-mode\").arg(compare_mode);\n+            let _folder = builder.fold_output(|| format!(\"test_{}_{}\", suite, compare_mode));\n+            builder.info(&format!(\n+                \"Check compiletest suite={} mode={} compare_mode={} ({} -> {})\",\n+                suite, mode, compare_mode, &compiler.host, target\n+            ));\n+            let _time = util::timeit(&builder);\n+            try_run(builder, &mut cmd);\n+        }\n+    }\n+}\n+\n+#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n+struct DocTest {\n+    compiler: Compiler,\n+    path: &'static str,\n+    name: &'static str,\n+    is_ext_doc: bool,\n+}\n+\n+impl Step for DocTest {\n+    type Output = ();\n+    const ONLY_HOSTS: bool = true;\n+\n+    fn should_run(run: ShouldRun) -> ShouldRun {\n+        run.never()\n+    }\n+\n+    /// Run `rustdoc --test` for all documentation in `src/doc`.\n+    ///\n+    /// This will run all tests in our markdown documentation (e.g. the book)\n+    /// located in `src/doc`. The `rustdoc` that's run is the one that sits next to\n+    /// `compiler`.\n+    fn run(self, builder: &Builder) {\n+        let compiler = self.compiler;\n+\n+        builder.ensure(compile::Test {\n+            compiler,\n+            target: compiler.host,\n+        });\n+\n+        // Do a breadth-first traversal of the `src/doc` directory and just run\n+        // tests for all files that end in `*.md`\n+        let mut stack = vec![builder.src.join(self.path)];\n+        let _time = util::timeit(&builder);\n+        let _folder = builder.fold_output(|| format!(\"test_{}\", self.name));\n+\n+        let mut files = Vec::new();\n+        while let Some(p) = stack.pop() {\n+            if p.is_dir() {\n+                stack.extend(t!(p.read_dir()).map(|p| t!(p).path()));\n+                continue;\n+            }\n+\n+            if p.extension().and_then(|s| s.to_str()) != Some(\"md\") {\n+                continue;\n+            }\n+\n+            // The nostarch directory in the book is for no starch, and so isn't\n+            // guaranteed to builder. We don't care if it doesn't build, so skip it.\n+            if p.to_str().map_or(false, |p| p.contains(\"nostarch\")) {\n+                continue;\n+            }\n+\n+            files.push(p);\n+        }\n+\n+        files.sort();\n+\n+        let mut toolstate = ToolState::TestPass;\n+        for file in files {\n+            if !markdown_test(builder, compiler, &file) {\n+                toolstate = ToolState::TestFail;\n+            }\n+        }\n+        if self.is_ext_doc {\n+            builder.save_toolstate(self.name, toolstate);\n+        }\n+    }\n+}\n+\n+macro_rules! test_book {\n+    ($($name:ident, $path:expr, $book_name:expr, default=$default:expr;)+) => {\n+        $(\n+            #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n+            pub struct $name {\n+                compiler: Compiler,\n+            }\n+\n+            impl Step for $name {\n+                type Output = ();\n+                const DEFAULT: bool = $default;\n+                const ONLY_HOSTS: bool = true;\n+\n+                fn should_run(run: ShouldRun) -> ShouldRun {\n+                    run.path($path)\n+                }\n+\n+                fn make_run(run: RunConfig) {\n+                    run.builder.ensure($name {\n+                        compiler: run.builder.compiler(run.builder.top_stage, run.host),\n+                    });\n+                }\n+\n+                fn run(self, builder: &Builder) {\n+                    builder.ensure(DocTest {\n+                        compiler: self.compiler,\n+                        path: $path,\n+                        name: $book_name,\n+                        is_ext_doc: !$default,\n+                    });\n+                }\n+            }\n+        )+\n+    }\n+}\n+\n+test_book!(\n+    Nomicon, \"src/doc/nomicon\", \"nomicon\", default=false;\n+    Reference, \"src/doc/reference\", \"reference\", default=false;\n+    RustdocBook, \"src/doc/rustdoc\", \"rustdoc\", default=true;\n+    RustcBook, \"src/doc/rustc\", \"rustc\", default=true;\n+    RustByExample, \"src/doc/rust-by-example\", \"rust-by-example\", default=false;\n+    TheBook, \"src/doc/book\", \"book\", default=false;\n+    UnstableBook, \"src/doc/unstable-book\", \"unstable-book\", default=true;\n+);\n+\n+#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n+pub struct ErrorIndex {\n+    compiler: Compiler,\n+}\n+\n+impl Step for ErrorIndex {\n+    type Output = ();\n+    const DEFAULT: bool = true;\n+    const ONLY_HOSTS: bool = true;\n+\n+    fn should_run(run: ShouldRun) -> ShouldRun {\n+        run.path(\"src/tools/error_index_generator\")\n+    }\n+\n+    fn make_run(run: RunConfig) {\n+        run.builder.ensure(ErrorIndex {\n+            compiler: run.builder.compiler(run.builder.top_stage, run.host),\n+        });\n+    }\n+\n+    /// Run the error index generator tool to execute the tests located in the error\n+    /// index.\n+    ///\n+    /// The `error_index_generator` tool lives in `src/tools` and is used to\n+    /// generate a markdown file from the error indexes of the code base which is\n+    /// then passed to `rustdoc --test`.\n+    fn run(self, builder: &Builder) {\n+        let compiler = self.compiler;\n+\n+        builder.ensure(compile::Std {\n+            compiler,\n+            target: compiler.host,\n+        });\n+\n+        let dir = testdir(builder, compiler.host);\n+        t!(fs::create_dir_all(&dir));\n+        let output = dir.join(\"error-index.md\");\n+\n+        let mut tool = builder.tool_cmd(Tool::ErrorIndex);\n+        tool.arg(\"markdown\")\n+            .arg(&output)\n+            .env(\"CFG_BUILD\", &builder.config.build)\n+            .env(\"RUSTC_ERROR_METADATA_DST\", builder.extended_error_dir());\n+\n+        let _folder = builder.fold_output(|| \"test_error_index\");\n+        builder.info(&format!(\"Testing error-index stage{}\", compiler.stage));\n+        let _time = util::timeit(&builder);\n+        builder.run(&mut tool);\n+        markdown_test(builder, compiler, &output);\n+    }\n+}\n+\n+fn markdown_test(builder: &Builder, compiler: Compiler, markdown: &Path) -> bool {\n+    match File::open(markdown) {\n+        Ok(mut file) => {\n+            let mut contents = String::new();\n+            t!(file.read_to_string(&mut contents));\n+            if !contents.contains(\"```\") {\n+                return true;\n+            }\n+        }\n+        Err(_) => {}\n+    }\n+\n+    builder.info(&format!(\"doc tests for: {}\", markdown.display()));\n+    let mut cmd = builder.rustdoc_cmd(compiler.host);\n+    builder.add_rust_test_threads(&mut cmd);\n+    cmd.arg(\"--test\");\n+    cmd.arg(markdown);\n+    cmd.env(\"RUSTC_BOOTSTRAP\", \"1\");\n+\n+    let test_args = builder.config.cmd.test_args().join(\" \");\n+    cmd.arg(\"--test-args\").arg(test_args);\n+\n+    if builder.config.verbose_tests {\n+        try_run(builder, &mut cmd)\n+    } else {\n+        try_run_quiet(builder, &mut cmd)\n+    }\n+}\n+\n+#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n+pub struct CrateLibrustc {\n+    compiler: Compiler,\n+    target: Interned<String>,\n+    test_kind: TestKind,\n+    krate: Interned<String>,\n+}\n+\n+impl Step for CrateLibrustc {\n+    type Output = ();\n+    const DEFAULT: bool = true;\n+    const ONLY_HOSTS: bool = true;\n+\n+    fn should_run(run: ShouldRun) -> ShouldRun {\n+        run.krate(\"rustc-main\")\n+    }\n+\n+    fn make_run(run: RunConfig) {\n+        let builder = run.builder;\n+        let compiler = builder.compiler(builder.top_stage, run.host);\n+\n+        for krate in builder.in_tree_crates(\"rustc-main\") {\n+            if run.path.ends_with(&krate.path) {\n+                let test_kind = builder.kind.into();\n+\n+                builder.ensure(CrateLibrustc {\n+                    compiler,\n+                    target: run.target,\n+                    test_kind,\n+                    krate: krate.name,\n+                });\n+            }\n+        }\n+    }\n+\n+    fn run(self, builder: &Builder) {\n+        builder.ensure(Crate {\n+            compiler: self.compiler,\n+            target: self.target,\n+            mode: Mode::Rustc,\n+            test_kind: self.test_kind,\n+            krate: self.krate,\n+        });\n+    }\n+}\n+\n+#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n+pub struct CrateNotDefault {\n+    compiler: Compiler,\n+    target: Interned<String>,\n+    test_kind: TestKind,\n+    krate: &'static str,\n+}\n+\n+impl Step for CrateNotDefault {\n+    type Output = ();\n+\n+    fn should_run(run: ShouldRun) -> ShouldRun {\n+        run.path(\"src/liballoc_jemalloc\")\n+            .path(\"src/librustc_asan\")\n+            .path(\"src/librustc_lsan\")\n+            .path(\"src/librustc_msan\")\n+            .path(\"src/librustc_tsan\")\n+    }\n+\n+    fn make_run(run: RunConfig) {\n+        let builder = run.builder;\n+        let compiler = builder.compiler(builder.top_stage, run.host);\n+\n+        let test_kind = builder.kind.into();\n+\n+        builder.ensure(CrateNotDefault {\n+            compiler,\n+            target: run.target,\n+            test_kind,\n+            krate: match run.path {\n+                _ if run.path.ends_with(\"src/liballoc_jemalloc\") => \"alloc_jemalloc\",\n+                _ if run.path.ends_with(\"src/librustc_asan\") => \"rustc_asan\",\n+                _ if run.path.ends_with(\"src/librustc_lsan\") => \"rustc_lsan\",\n+                _ if run.path.ends_with(\"src/librustc_msan\") => \"rustc_msan\",\n+                _ if run.path.ends_with(\"src/librustc_tsan\") => \"rustc_tsan\",\n+                _ => panic!(\"unexpected path {:?}\", run.path),\n+            },\n+        });\n+    }\n+\n+    fn run(self, builder: &Builder) {\n+        builder.ensure(Crate {\n+            compiler: self.compiler,\n+            target: self.target,\n+            mode: Mode::Std,\n+            test_kind: self.test_kind,\n+            krate: INTERNER.intern_str(self.krate),\n+        });\n+    }\n+}\n+\n+#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]\n+pub struct Crate {\n+    pub compiler: Compiler,\n+    pub target: Interned<String>,\n+    pub mode: Mode,\n+    pub test_kind: TestKind,\n+    pub krate: Interned<String>,\n+}\n+\n+impl Step for Crate {\n+    type Output = ();\n+    const DEFAULT: bool = true;\n+\n+    fn should_run(mut run: ShouldRun) -> ShouldRun {\n+        let builder = run.builder;\n+        run = run.krate(\"test\");\n+        for krate in run.builder.in_tree_crates(\"std\") {\n+            if krate.is_local(&run.builder)\n+                && !krate.name.contains(\"jemalloc\")\n+                && !(krate.name.starts_with(\"rustc_\") && krate.name.ends_with(\"san\"))\n+                && krate.name != \"dlmalloc\"\n+            {\n+                run = run.path(krate.local_path(&builder).to_str().unwrap());\n+            }\n+        }\n+        run\n+    }\n+\n+    fn make_run(run: RunConfig) {\n+        let builder = run.builder;\n+        let compiler = builder.compiler(builder.top_stage, run.host);\n+\n+        let make = |mode: Mode, krate: &CargoCrate| {\n+            let test_kind = builder.kind.into();\n+\n+            builder.ensure(Crate {\n+                compiler,\n+                target: run.target,\n+                mode,\n+                test_kind,\n+                krate: krate.name,\n+            });\n+        };\n+\n+        for krate in builder.in_tree_crates(\"std\") {\n+            if run.path.ends_with(&krate.local_path(&builder)) {\n+                make(Mode::Std, krate);\n+            }\n+        }\n+        for krate in builder.in_tree_crates(\"test\") {\n+            if run.path.ends_with(&krate.local_path(&builder)) {\n+                make(Mode::Test, krate);\n+            }\n+        }\n+    }\n+\n+    /// Run all unit tests plus documentation tests for a given crate defined\n+    /// by a `Cargo.toml` (single manifest)\n+    ///\n+    /// This is what runs tests for crates like the standard library, compiler, etc.\n+    /// It essentially is the driver for running `cargo test`.\n+    ///\n+    /// Currently this runs all tests for a DAG by passing a bunch of `-p foo`\n+    /// arguments, and those arguments are discovered from `cargo metadata`.\n+    fn run(self, builder: &Builder) {\n+        let compiler = self.compiler;\n+        let target = self.target;\n+        let mode = self.mode;\n+        let test_kind = self.test_kind;\n+        let krate = self.krate;\n+\n+        builder.ensure(compile::Test { compiler, target });\n+        builder.ensure(RemoteCopyLibs { compiler, target });\n+\n+        // If we're not doing a full bootstrap but we're testing a stage2 version of\n+        // libstd, then what we're actually testing is the libstd produced in\n+        // stage1. Reflect that here by updating the compiler that we're working\n+        // with automatically.\n+        let compiler = if builder.force_use_stage1(compiler, target) {\n+            builder.compiler(1, compiler.host)\n+        } else {\n+            compiler.clone()\n+        };\n+\n+        let mut cargo = builder.cargo(compiler, mode, target, test_kind.subcommand());\n+        match mode {\n+            Mode::Std => {\n+                compile::std_cargo(builder, &compiler, target, &mut cargo);\n+            }\n+            Mode::Test => {\n+                compile::test_cargo(builder, &compiler, target, &mut cargo);\n+            }\n+            Mode::Rustc => {\n+                builder.ensure(compile::Rustc { compiler, target });\n+                compile::rustc_cargo(builder, &mut cargo);\n+            }\n+            _ => panic!(\"can only test libraries\"),\n+        };\n+\n+        // Build up the base `cargo test` command.\n+        //\n+        // Pass in some standard flags then iterate over the graph we've discovered\n+        // in `cargo metadata` with the maps above and figure out what `-p`\n+        // arguments need to get passed.\n+        if test_kind.subcommand() == \"test\" && !builder.fail_fast {\n+            cargo.arg(\"--no-fail-fast\");\n+        }\n+        match builder.doc_tests {\n+            DocTests::Only => {\n+                cargo.arg(\"--doc\");\n+            }\n+            DocTests::No => {\n+                cargo.args(&[\"--lib\", \"--bins\", \"--examples\", \"--tests\", \"--benches\"]);\n+            }\n+            DocTests::Yes => {}\n+        }\n+\n+        cargo.arg(\"-p\").arg(krate);\n+\n+        // The tests are going to run with the *target* libraries, so we need to\n+        // ensure that those libraries show up in the LD_LIBRARY_PATH equivalent.\n+        //\n+        // Note that to run the compiler we need to run with the *host* libraries,\n+        // but our wrapper scripts arrange for that to be the case anyway.\n+        let mut dylib_path = dylib_path();\n+        dylib_path.insert(0, PathBuf::from(&*builder.sysroot_libdir(compiler, target)));\n+        cargo.env(dylib_path_var(), env::join_paths(&dylib_path).unwrap());\n+\n+        cargo.arg(\"--\");\n+        cargo.args(&builder.config.cmd.test_args());\n+\n+        if !builder.config.verbose_tests {\n+            cargo.arg(\"--quiet\");\n+        }\n+\n+        if target.contains(\"emscripten\") {\n+            cargo.env(\n+                format!(\"CARGO_TARGET_{}_RUNNER\", envify(&target)),\n+                builder\n+                    .config\n+                    .nodejs\n+                    .as_ref()\n+                    .expect(\"nodejs not configured\"),\n+            );\n+        } else if target.starts_with(\"wasm32\") {\n+            // Warn about running tests without the `wasm_syscall` feature enabled.\n+            // The javascript shim implements the syscall interface so that test\n+            // output can be correctly reported.\n+            if !builder.config.wasm_syscall {\n+                builder.info(&format!(\n+                    \"Libstd was built without `wasm_syscall` feature enabled: \\\n+                     test output may not be visible.\"\n+                ));\n+            }\n+\n+            // On the wasm32-unknown-unknown target we're using LTO which is\n+            // incompatible with `-C prefer-dynamic`, so disable that here\n+            cargo.env(\"RUSTC_NO_PREFER_DYNAMIC\", \"1\");\n+\n+            let node = builder\n+                .config\n+                .nodejs\n+                .as_ref()\n+                .expect(\"nodejs not configured\");\n+            let runner = format!(\n+                \"{} {}/src/etc/wasm32-shim.js\",\n+                node.display(),\n+                builder.src.display()\n+            );\n+            cargo.env(format!(\"CARGO_TARGET_{}_RUNNER\", envify(&target)), &runner);\n+        } else if builder.remote_tested(target) {\n+            cargo.env(\n+                format!(\"CARGO_TARGET_{}_RUNNER\", envify(&target)),\n+                format!(\"{} run\", builder.tool_exe(Tool::RemoteTestClient).display()),\n+            );\n+        }\n+\n+        let _folder = builder.fold_output(|| {\n+            format!(\n+                \"{}_stage{}-{}\",\n+                test_kind.subcommand(),\n+                compiler.stage,\n+                krate\n+            )\n+        });\n+        builder.info(&format!(\n+            \"{} {} stage{} ({} -> {})\",\n+            test_kind, krate, compiler.stage, &compiler.host, target\n+        ));\n+        let _time = util::timeit(&builder);\n+        try_run(builder, &mut cargo);\n+    }\n+}\n+\n+#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n+pub struct CrateRustdoc {\n+    host: Interned<String>,\n+    test_kind: TestKind,\n+}\n+\n+impl Step for CrateRustdoc {\n+    type Output = ();\n+    const DEFAULT: bool = true;\n+    const ONLY_HOSTS: bool = true;\n+\n+    fn should_run(run: ShouldRun) -> ShouldRun {\n+        run.paths(&[\"src/librustdoc\", \"src/tools/rustdoc\"])\n+    }\n+\n+    fn make_run(run: RunConfig) {\n+        let builder = run.builder;\n+\n+        let test_kind = builder.kind.into();\n+\n+        builder.ensure(CrateRustdoc {\n+            host: run.host,\n+            test_kind,\n+        });\n+    }\n+\n+    fn run(self, builder: &Builder) {\n+        let test_kind = self.test_kind;\n+\n+        let compiler = builder.compiler(builder.top_stage, self.host);\n+        let target = compiler.host;\n+        builder.ensure(compile::Rustc { compiler, target });\n+\n+        let mut cargo = tool::prepare_tool_cargo(builder,\n+                                                 compiler,\n+                                                 Mode::ToolRustc,\n+                                                 target,\n+                                                 test_kind.subcommand(),\n+                                                 \"src/tools/rustdoc\",\n+                                                 SourceType::InTree);\n+        if test_kind.subcommand() == \"test\" && !builder.fail_fast {\n+            cargo.arg(\"--no-fail-fast\");\n+        }\n+\n+        cargo.arg(\"-p\").arg(\"rustdoc:0.0.0\");\n+\n+        cargo.arg(\"--\");\n+        cargo.args(&builder.config.cmd.test_args());\n+\n+        if !builder.config.verbose_tests {\n+            cargo.arg(\"--quiet\");\n+        }\n+\n+        let _folder = builder\n+            .fold_output(|| format!(\"{}_stage{}-rustdoc\", test_kind.subcommand(), compiler.stage));\n+        builder.info(&format!(\n+            \"{} rustdoc stage{} ({} -> {})\",\n+            test_kind, compiler.stage, &compiler.host, target\n+        ));\n+        let _time = util::timeit(&builder);\n+\n+        try_run(builder, &mut cargo);\n+    }\n+}\n+\n+fn envify(s: &str) -> String {\n+    s.chars()\n+        .map(|c| match c {\n+            '-' => '_',\n+            c => c,\n+        })\n+        .flat_map(|c| c.to_uppercase())\n+        .collect()\n+}\n+\n+/// Some test suites are run inside emulators or on remote devices, and most\n+/// of our test binaries are linked dynamically which means we need to ship\n+/// the standard library and such to the emulator ahead of time. This step\n+/// represents this and is a dependency of all test suites.\n+///\n+/// Most of the time this is a noop. For some steps such as shipping data to\n+/// QEMU we have to build our own tools so we've got conditional dependencies\n+/// on those programs as well. Note that the remote test client is built for\n+/// the build target (us) and the server is built for the target.\n+#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n+pub struct RemoteCopyLibs {\n+    compiler: Compiler,\n+    target: Interned<String>,\n+}\n+\n+impl Step for RemoteCopyLibs {\n+    type Output = ();\n+\n+    fn should_run(run: ShouldRun) -> ShouldRun {\n+        run.never()\n+    }\n+\n+    fn run(self, builder: &Builder) {\n+        let compiler = self.compiler;\n+        let target = self.target;\n+        if !builder.remote_tested(target) {\n+            return;\n+        }\n+\n+        builder.ensure(compile::Test { compiler, target });\n+\n+        builder.info(&format!(\"REMOTE copy libs to emulator ({})\", target));\n+        t!(fs::create_dir_all(builder.out.join(\"tmp\")));\n+\n+        let server = builder.ensure(tool::RemoteTestServer {\n+            compiler: compiler.with_stage(0),\n+            target,\n+        });\n+\n+        // Spawn the emulator and wait for it to come online\n+        let tool = builder.tool_exe(Tool::RemoteTestClient);\n+        let mut cmd = Command::new(&tool);\n+        cmd.arg(\"spawn-emulator\")\n+            .arg(target)\n+            .arg(&server)\n+            .arg(builder.out.join(\"tmp\"));\n+        if let Some(rootfs) = builder.qemu_rootfs(target) {\n+            cmd.arg(rootfs);\n+        }\n+        builder.run(&mut cmd);\n+\n+        // Push all our dylibs to the emulator\n+        for f in t!(builder.sysroot_libdir(compiler, target).read_dir()) {\n+            let f = t!(f);\n+            let name = f.file_name().into_string().unwrap();\n+            if util::is_dylib(&name) {\n+                builder.run(Command::new(&tool).arg(\"push\").arg(f.path()));\n+            }\n+        }\n+    }\n+}\n+\n+#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n+pub struct Distcheck;\n+\n+impl Step for Distcheck {\n+    type Output = ();\n+\n+    fn should_run(run: ShouldRun) -> ShouldRun {\n+        run.path(\"distcheck\")\n+    }\n+\n+    fn make_run(run: RunConfig) {\n+        run.builder.ensure(Distcheck);\n+    }\n+\n+    /// Run \"distcheck\", a 'make check' from a tarball\n+    fn run(self, builder: &Builder) {\n+        builder.info(&format!(\"Distcheck\"));\n+        let dir = builder.out.join(\"tmp\").join(\"distcheck\");\n+        let _ = fs::remove_dir_all(&dir);\n+        t!(fs::create_dir_all(&dir));\n+\n+        // Guarantee that these are built before we begin running.\n+        builder.ensure(dist::PlainSourceTarball);\n+        builder.ensure(dist::Src);\n+\n+        let mut cmd = Command::new(\"tar\");\n+        cmd.arg(\"-xzf\")\n+            .arg(builder.ensure(dist::PlainSourceTarball))\n+            .arg(\"--strip-components=1\")\n+            .current_dir(&dir);\n+        builder.run(&mut cmd);\n+        builder.run(\n+            Command::new(\"./configure\")\n+                .args(&builder.config.configure_args)\n+                .arg(\"--enable-vendor\")\n+                .current_dir(&dir),\n+        );\n+        builder.run(\n+            Command::new(build_helper::make(&builder.config.build))\n+                .arg(\"check\")\n+                .current_dir(&dir),\n+        );\n+\n+        // Now make sure that rust-src has all of libstd's dependencies\n+        builder.info(&format!(\"Distcheck rust-src\"));\n+        let dir = builder.out.join(\"tmp\").join(\"distcheck-src\");\n+        let _ = fs::remove_dir_all(&dir);\n+        t!(fs::create_dir_all(&dir));\n+\n+        let mut cmd = Command::new(\"tar\");\n+        cmd.arg(\"-xzf\")\n+            .arg(builder.ensure(dist::Src))\n+            .arg(\"--strip-components=1\")\n+            .current_dir(&dir);\n+        builder.run(&mut cmd);\n+\n+        let toml = dir.join(\"rust-src/lib/rustlib/src/rust/src/libstd/Cargo.toml\");\n+        builder.run(\n+            Command::new(&builder.initial_cargo)\n+                .arg(\"generate-lockfile\")\n+                .arg(\"--manifest-path\")\n+                .arg(&toml)\n+                .current_dir(&dir),\n+        );\n+    }\n+}\n+\n+#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n+pub struct Bootstrap;\n+\n+impl Step for Bootstrap {\n+    type Output = ();\n+    const DEFAULT: bool = true;\n+    const ONLY_HOSTS: bool = true;\n+\n+    /// Test the build system itself\n+    fn run(self, builder: &Builder) {\n+        let mut cmd = Command::new(&builder.initial_cargo);\n+        cmd.arg(\"test\")\n+            .current_dir(builder.src.join(\"src/bootstrap\"))\n+            .env(\"RUSTFLAGS\", \"-Cdebuginfo=2\")\n+            .env(\"CARGO_TARGET_DIR\", builder.out.join(\"bootstrap\"))\n+            .env(\"RUSTC_BOOTSTRAP\", \"1\")\n+            .env(\"RUSTC\", &builder.initial_rustc);\n+        if let Some(flags) = option_env!(\"RUSTFLAGS\") {\n+            // Use the same rustc flags for testing as for \"normal\" compilation,\n+            // so that Cargo doesn\u2019t recompile the entire dependency graph every time:\n+            // https://github.com/rust-lang/rust/issues/49215\n+            cmd.env(\"RUSTFLAGS\", flags);\n+        }\n+        if !builder.fail_fast {\n+            cmd.arg(\"--no-fail-fast\");\n+        }\n+        cmd.arg(\"--\").args(&builder.config.cmd.test_args());\n+        // rustbuild tests are racy on directory creation so just run them one at a time.\n+        // Since there's not many this shouldn't be a problem.\n+        cmd.arg(\"--test-threads=1\");\n+        try_run(builder, &mut cmd);\n+    }\n+\n+    fn should_run(run: ShouldRun) -> ShouldRun {\n+        run.path(\"src/bootstrap\")\n+    }\n+\n+    fn make_run(run: RunConfig) {\n+        run.builder.ensure(Bootstrap);\n+    }\n+}"}, {"sha": "23ef031dcb703b094e09bceb0d9678283df5d51b", "filename": "src/bootstrap/tool.rs", "status": "modified", "additions": 308, "deletions": 91, "changes": 399, "blob_url": "https://github.com/rust-lang/rust/blob/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fbootstrap%2Ftool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fbootstrap%2Ftool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftool.rs?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd", "patch": "@@ -10,13 +10,15 @@\n \n use std::fs;\n use std::env;\n+use std::iter;\n use std::path::PathBuf;\n use std::process::{Command, exit};\n+use std::collections::HashSet;\n \n use Mode;\n use Compiler;\n use builder::{Step, RunConfig, ShouldRun, Builder};\n-use util::{copy, exe, add_lib_path};\n+use util::{exe, add_lib_path};\n use compile::{self, libtest_stamp, libstd_stamp, librustc_stamp};\n use native;\n use channel::GitInfo;\n@@ -27,7 +29,7 @@ use toolstate::ToolState;\n pub struct CleanTools {\n     pub compiler: Compiler,\n     pub target: Interned<String>,\n-    pub mode: Mode,\n+    pub cause: Mode,\n }\n \n impl Step for CleanTools {\n@@ -38,50 +40,57 @@ impl Step for CleanTools {\n     }\n \n     fn run(self, builder: &Builder) {\n-        let build = builder.build;\n         let compiler = self.compiler;\n         let target = self.target;\n-        let mode = self.mode;\n+        let cause = self.cause;\n \n         // This is for the original compiler, but if we're forced to use stage 1, then\n         // std/test/rustc stamps won't exist in stage 2, so we need to get those from stage 1, since\n         // we copy the libs forward.\n-        let tools_dir = build.stage_out(compiler, Mode::Tool);\n+        let tools_dir = builder.stage_out(compiler, Mode::ToolRustc);\n         let compiler = if builder.force_use_stage1(compiler, target) {\n             builder.compiler(1, compiler.host)\n         } else {\n             compiler\n         };\n \n-        for &cur_mode in &[Mode::Libstd, Mode::Libtest, Mode::Librustc] {\n+        for &cur_mode in &[Mode::Std, Mode::Test, Mode::Rustc] {\n             let stamp = match cur_mode {\n-                Mode::Libstd => libstd_stamp(build, compiler, target),\n-                Mode::Libtest => libtest_stamp(build, compiler, target),\n-                Mode::Librustc => librustc_stamp(build, compiler, target),\n+                Mode::Std => libstd_stamp(builder, compiler, target),\n+                Mode::Test => libtest_stamp(builder, compiler, target),\n+                Mode::Rustc => librustc_stamp(builder, compiler, target),\n                 _ => panic!(),\n             };\n \n-            if build.clear_if_dirty(&tools_dir, &stamp) {\n+            if builder.clear_if_dirty(&tools_dir, &stamp) {\n                 break;\n             }\n \n             // If we are a rustc tool, and std changed, we also need to clear ourselves out -- our\n             // dependencies depend on std. Therefore, we iterate up until our own mode.\n-            if mode == cur_mode {\n+            if cause == cur_mode {\n                 break;\n             }\n         }\n     }\n }\n \n-#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n+#[derive(Debug, Clone, Hash, PartialEq, Eq)]\n+pub enum SourceType {\n+    InTree,\n+    Submodule,\n+}\n+\n+#[derive(Debug, Clone, Hash, PartialEq, Eq)]\n struct ToolBuild {\n     compiler: Compiler,\n     target: Interned<String>,\n     tool: &'static str,\n     path: &'static str,\n     mode: Mode,\n-    is_ext_tool: bool,\n+    is_optional_tool: bool,\n+    source_type: SourceType,\n+    extra_features: Vec<String>,\n }\n \n impl Step for ToolBuild {\n@@ -96,42 +105,146 @@ impl Step for ToolBuild {\n     /// This will build the specified tool with the specified `host` compiler in\n     /// `stage` into the normal cargo output directory.\n     fn run(self, builder: &Builder) -> Option<PathBuf> {\n-        let build = builder.build;\n         let compiler = self.compiler;\n         let target = self.target;\n         let tool = self.tool;\n         let path = self.path;\n-        let is_ext_tool = self.is_ext_tool;\n+        let is_optional_tool = self.is_optional_tool;\n \n         match self.mode {\n-            Mode::Libstd => builder.ensure(compile::Std { compiler, target }),\n-            Mode::Libtest => builder.ensure(compile::Test { compiler, target }),\n-            Mode::Librustc => builder.ensure(compile::Rustc { compiler, target }),\n-            Mode::Tool => panic!(\"unexpected Mode::Tool for tool build\")\n+            Mode::ToolRustc => {\n+                builder.ensure(compile::Rustc { compiler, target })\n+            }\n+            Mode::ToolStd => {\n+                builder.ensure(compile::Std { compiler, target })\n+            }\n+            Mode::ToolBootstrap => {} // uses downloaded stage0 compiler libs\n+            _ => panic!(\"unexpected Mode for tool build\")\n         }\n \n-        let _folder = build.fold_output(|| format!(\"stage{}-{}\", compiler.stage, tool));\n-        println!(\"Building stage{} tool {} ({})\", compiler.stage, tool, target);\n+        let mut cargo = prepare_tool_cargo(\n+            builder,\n+            compiler,\n+            self.mode,\n+            target,\n+            \"build\",\n+            path,\n+            self.source_type,\n+        );\n+        cargo.arg(\"--features\").arg(self.extra_features.join(\" \"));\n+\n+        let _folder = builder.fold_output(|| format!(\"stage{}-{}\", compiler.stage, tool));\n+        builder.info(&format!(\"Building stage{} tool {} ({})\", compiler.stage, tool, target));\n+        let mut duplicates = Vec::new();\n+        let is_expected = compile::stream_cargo(builder, &mut cargo, &mut |msg| {\n+            // Only care about big things like the RLS/Cargo for now\n+            match tool {\n+                | \"rls\"\n+                | \"cargo\"\n+                | \"clippy-driver\"\n+                => {}\n+\n+                _ => return,\n+            }\n+            let (id, features, filenames) = match msg {\n+                compile::CargoMessage::CompilerArtifact {\n+                    package_id,\n+                    features,\n+                    filenames\n+                } => {\n+                    (package_id, features, filenames)\n+                }\n+                _ => return,\n+            };\n+            let features = features.iter().map(|s| s.to_string()).collect::<Vec<_>>();\n \n-        let mut cargo = prepare_tool_cargo(builder, compiler, target, \"build\", path);\n-        let is_expected = build.try_run(&mut cargo);\n-        build.save_toolstate(tool, if is_expected {\n+            for path in filenames {\n+                let val = (tool, PathBuf::from(&*path), features.clone());\n+                // we're only interested in deduplicating rlibs for now\n+                if val.1.extension().and_then(|s| s.to_str()) != Some(\"rlib\") {\n+                    continue\n+                }\n+\n+                // Don't worry about libs that turn out to be host dependencies\n+                // or build scripts, we only care about target dependencies that\n+                // are in `deps`.\n+                if let Some(maybe_target) = val.1\n+                    .parent()                   // chop off file name\n+                    .and_then(|p| p.parent())   // chop off `deps`\n+                    .and_then(|p| p.parent())   // chop off `release`\n+                    .and_then(|p| p.file_name())\n+                    .and_then(|p| p.to_str())\n+                {\n+                    if maybe_target != &*target {\n+                        continue\n+                    }\n+                }\n+\n+                let mut artifacts = builder.tool_artifacts.borrow_mut();\n+                let prev_artifacts = artifacts\n+                    .entry(target)\n+                    .or_default();\n+                if let Some(prev) = prev_artifacts.get(&*id) {\n+                    if prev.1 != val.1 {\n+                        duplicates.push((\n+                            id.to_string(),\n+                            val,\n+                            prev.clone(),\n+                        ));\n+                    }\n+                    return\n+                }\n+                prev_artifacts.insert(id.to_string(), val);\n+            }\n+        });\n+\n+        if is_expected && duplicates.len() != 0 {\n+            println!(\"duplicate artfacts found when compiling a tool, this \\\n+                      typically means that something was recompiled because \\\n+                      a transitive dependency has different features activated \\\n+                      than in a previous build:\\n\");\n+            println!(\"the following dependencies are duplicated although they \\\n+                      have the same features enabled:\");\n+            for (id, cur, prev) in duplicates.drain_filter(|(_, cur, prev)| cur.2 == prev.2) {\n+                println!(\"  {}\", id);\n+                // same features\n+                println!(\"    `{}` ({:?})\\n    `{}` ({:?})\", cur.0, cur.1, prev.0, prev.1);\n+            }\n+            println!(\"the following dependencies have different features:\");\n+            for (id, cur, prev) in duplicates {\n+                println!(\"  {}\", id);\n+                let cur_features: HashSet<_> = cur.2.into_iter().collect();\n+                let prev_features: HashSet<_> = prev.2.into_iter().collect();\n+                println!(\"    `{}` additionally enabled features {:?} at {:?}\",\n+                         cur.0, &cur_features - &prev_features, cur.1);\n+                println!(\"    `{}` additionally enabled features {:?} at {:?}\",\n+                         prev.0, &prev_features - &cur_features, prev.1);\n+            }\n+            println!(\"\");\n+            println!(\"to fix this you will probably want to edit the local \\\n+                      src/tools/rustc-workspace-hack/Cargo.toml crate, as \\\n+                      that will update the dependency graph to ensure that \\\n+                      these crates all share the same feature set\");\n+            panic!(\"tools should not compile multiple copies of the same crate\");\n+        }\n+\n+        builder.save_toolstate(tool, if is_expected {\n             ToolState::TestFail\n         } else {\n             ToolState::BuildFail\n         });\n \n         if !is_expected {\n-            if !is_ext_tool {\n+            if !is_optional_tool {\n                 exit(1);\n             } else {\n                 return None;\n             }\n         } else {\n-            let cargo_out = build.cargo_out(compiler, Mode::Tool, target)\n+            let cargo_out = builder.cargo_out(compiler, self.mode, target)\n                 .join(exe(tool, &compiler.host));\n-            let bin = build.tools_dir(compiler).join(exe(tool, &compiler.host));\n-            copy(&cargo_out, &bin);\n+            let bin = builder.tools_dir(compiler).join(exe(tool, &compiler.host));\n+            builder.copy(&cargo_out, &bin);\n             Some(bin)\n         }\n     }\n@@ -140,20 +253,25 @@ impl Step for ToolBuild {\n pub fn prepare_tool_cargo(\n     builder: &Builder,\n     compiler: Compiler,\n+    mode: Mode,\n     target: Interned<String>,\n     command: &'static str,\n     path: &'static str,\n+    source_type: SourceType,\n ) -> Command {\n-    let build = builder.build;\n-    let mut cargo = builder.cargo(compiler, Mode::Tool, target, command);\n-    let dir = build.src.join(path);\n+    let mut cargo = builder.cargo(compiler, mode, target, command);\n+    let dir = builder.src.join(path);\n     cargo.arg(\"--manifest-path\").arg(dir.join(\"Cargo.toml\"));\n \n     // We don't want to build tools dynamically as they'll be running across\n     // stages and such and it's just easier if they're not dynamically linked.\n     cargo.env(\"RUSTC_NO_PREFER_DYNAMIC\", \"1\");\n \n-    if let Some(dir) = build.openssl_install_dir(target) {\n+    if source_type == SourceType::Submodule {\n+        cargo.env(\"RUSTC_EXTERNAL_TOOL\", \"1\");\n+    }\n+\n+    if let Some(dir) = builder.openssl_install_dir(target) {\n         cargo.env(\"OPENSSL_STATIC\", \"1\");\n         cargo.env(\"OPENSSL_DIR\", dir);\n         cargo.env(\"LIBZ_SYS_STATIC\", \"1\");\n@@ -163,10 +281,10 @@ pub fn prepare_tool_cargo(\n     // own copy\n     cargo.env(\"LZMA_API_STATIC\", \"1\");\n \n-    cargo.env(\"CFG_RELEASE_CHANNEL\", &build.config.channel);\n-    cargo.env(\"CFG_VERSION\", build.rust_version());\n+    cargo.env(\"CFG_RELEASE_CHANNEL\", &builder.config.channel);\n+    cargo.env(\"CFG_VERSION\", builder.rust_version());\n \n-    let info = GitInfo::new(&build.config, &dir);\n+    let info = GitInfo::new(&builder.config, &dir);\n     if let Some(sha) = info.sha() {\n         cargo.env(\"CFG_COMMIT_HASH\", sha);\n     }\n@@ -180,22 +298,39 @@ pub fn prepare_tool_cargo(\n }\n \n macro_rules! tool {\n-    ($($name:ident, $path:expr, $tool_name:expr, $mode:expr;)+) => {\n-        #[derive(Copy, Clone)]\n+    ($($name:ident, $path:expr, $tool_name:expr, $mode:expr\n+        $(,llvm_tools = $llvm:expr)* $(,is_external_tool = $external:expr)*;)+) => {\n+        #[derive(Copy, PartialEq, Eq, Clone)]\n         pub enum Tool {\n             $(\n                 $name,\n             )+\n         }\n \n+        impl Tool {\n+            pub fn get_mode(&self) -> Mode {\n+                let mode = match self {\n+                    $(Tool::$name => $mode,)+\n+                };\n+                mode\n+            }\n+\n+            /// Whether this tool requires LLVM to run\n+            pub fn uses_llvm_tools(&self) -> bool {\n+                match self {\n+                    $(Tool::$name => false $(|| $llvm)*,)+\n+                }\n+            }\n+        }\n+\n         impl<'a> Builder<'a> {\n             pub fn tool_exe(&self, tool: Tool) -> PathBuf {\n                 let stage = self.tool_default_stage(tool);\n                 match tool {\n                     $(Tool::$name =>\n                         self.ensure($name {\n-                            compiler: self.compiler(stage, self.build.build),\n-                            target: self.build.build,\n+                            compiler: self.compiler(stage, self.config.build),\n+                            target: self.config.build,\n                         }),\n                     )+\n                 }\n@@ -229,7 +364,7 @@ macro_rules! tool {\n \n             fn make_run(run: RunConfig) {\n                 run.builder.ensure($name {\n-                    compiler: run.builder.compiler(run.builder.top_stage, run.builder.build.build),\n+                    compiler: run.builder.compiler(run.builder.top_stage, run.builder.config.build),\n                     target: run.target,\n                 });\n             }\n@@ -241,7 +376,13 @@ macro_rules! tool {\n                     tool: $tool_name,\n                     mode: $mode,\n                     path: $path,\n-                    is_ext_tool: false,\n+                    is_optional_tool: false,\n+                    source_type: if false $(|| $external)* {\n+                        SourceType::Submodule\n+                    } else {\n+                        SourceType::InTree\n+                    },\n+                    extra_features: Vec::new(),\n                 }).expect(\"expected to build -- essential tool\")\n             }\n         }\n@@ -250,16 +391,18 @@ macro_rules! tool {\n }\n \n tool!(\n-    Rustbook, \"src/tools/rustbook\", \"rustbook\", Mode::Librustc;\n-    ErrorIndex, \"src/tools/error_index_generator\", \"error_index_generator\", Mode::Librustc;\n-    UnstableBookGen, \"src/tools/unstable-book-gen\", \"unstable-book-gen\", Mode::Libstd;\n-    Tidy, \"src/tools/tidy\", \"tidy\", Mode::Libstd;\n-    Linkchecker, \"src/tools/linkchecker\", \"linkchecker\", Mode::Libstd;\n-    CargoTest, \"src/tools/cargotest\", \"cargotest\", Mode::Libstd;\n-    Compiletest, \"src/tools/compiletest\", \"compiletest\", Mode::Libtest;\n-    BuildManifest, \"src/tools/build-manifest\", \"build-manifest\", Mode::Libstd;\n-    RemoteTestClient, \"src/tools/remote-test-client\", \"remote-test-client\", Mode::Libstd;\n-    RustInstaller, \"src/tools/rust-installer\", \"fabricate\", Mode::Libstd;\n+    Rustbook, \"src/tools/rustbook\", \"rustbook\", Mode::ToolBootstrap;\n+    ErrorIndex, \"src/tools/error_index_generator\", \"error_index_generator\", Mode::ToolRustc;\n+    UnstableBookGen, \"src/tools/unstable-book-gen\", \"unstable-book-gen\", Mode::ToolBootstrap;\n+    Tidy, \"src/tools/tidy\", \"tidy\", Mode::ToolBootstrap;\n+    Linkchecker, \"src/tools/linkchecker\", \"linkchecker\", Mode::ToolBootstrap;\n+    CargoTest, \"src/tools/cargotest\", \"cargotest\", Mode::ToolBootstrap;\n+    Compiletest, \"src/tools/compiletest\", \"compiletest\", Mode::ToolBootstrap, llvm_tools = true;\n+    BuildManifest, \"src/tools/build-manifest\", \"build-manifest\", Mode::ToolBootstrap;\n+    RemoteTestClient, \"src/tools/remote-test-client\", \"remote-test-client\", Mode::ToolBootstrap;\n+    RustInstaller, \"src/tools/rust-installer\", \"fabricate\", Mode::ToolBootstrap,\n+        is_external_tool = true;\n+    RustdocTheme, \"src/tools/rustdoc-themes\", \"rustdoc-themes\", Mode::ToolBootstrap;\n );\n \n #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n@@ -277,7 +420,7 @@ impl Step for RemoteTestServer {\n \n     fn make_run(run: RunConfig) {\n         run.builder.ensure(RemoteTestServer {\n-            compiler: run.builder.compiler(run.builder.top_stage, run.builder.build.build),\n+            compiler: run.builder.compiler(run.builder.top_stage, run.builder.config.build),\n             target: run.target,\n         });\n     }\n@@ -287,9 +430,11 @@ impl Step for RemoteTestServer {\n             compiler: self.compiler,\n             target: self.target,\n             tool: \"remote-test-server\",\n-            mode: Mode::Libstd,\n+            mode: Mode::ToolStd,\n             path: \"src/tools/remote-test-server\",\n-            is_ext_tool: false,\n+            is_optional_tool: false,\n+            source_type: SourceType::InTree,\n+            extra_features: Vec::new(),\n         }).expect(\"expected to build -- essential tool\")\n     }\n }\n@@ -315,43 +460,51 @@ impl Step for Rustdoc {\n     }\n \n     fn run(self, builder: &Builder) -> PathBuf {\n-        let build = builder.build;\n         let target_compiler = builder.compiler(builder.top_stage, self.host);\n         let target = target_compiler.host;\n         let build_compiler = if target_compiler.stage == 0 {\n-            builder.compiler(0, builder.build.build)\n+            builder.compiler(0, builder.config.build)\n         } else if target_compiler.stage >= 2 {\n             // Past stage 2, we consider the compiler to be ABI-compatible and hence capable of\n             // building rustdoc itself.\n-            builder.compiler(target_compiler.stage, builder.build.build)\n+            builder.compiler(target_compiler.stage, builder.config.build)\n         } else {\n             // Similar to `compile::Assemble`, build with the previous stage's compiler. Otherwise\n             // we'd have stageN/bin/rustc and stageN/bin/rustdoc be effectively different stage\n             // compilers, which isn't what we want.\n-            builder.compiler(target_compiler.stage - 1, builder.build.build)\n+            builder.compiler(target_compiler.stage - 1, builder.config.build)\n         };\n \n         builder.ensure(compile::Rustc { compiler: build_compiler, target });\n+        builder.ensure(compile::Rustc {\n+            compiler: build_compiler,\n+            target: builder.config.build,\n+        });\n \n-        let _folder = build.fold_output(|| format!(\"stage{}-rustdoc\", target_compiler.stage));\n-        println!(\"Building rustdoc for stage{} ({})\", target_compiler.stage, target_compiler.host);\n-\n-        let mut cargo = prepare_tool_cargo(builder,\n-                                           build_compiler,\n-                                           target,\n-                                           \"build\",\n-                                           \"src/tools/rustdoc\");\n+        let mut cargo = prepare_tool_cargo(\n+            builder,\n+            build_compiler,\n+            Mode::ToolRustc,\n+            target,\n+            \"build\",\n+            \"src/tools/rustdoc\",\n+            SourceType::InTree,\n+        );\n \n         // Most tools don't get debuginfo, but rustdoc should.\n         cargo.env(\"RUSTC_DEBUGINFO\", builder.config.rust_debuginfo.to_string())\n              .env(\"RUSTC_DEBUGINFO_LINES\", builder.config.rust_debuginfo_lines.to_string());\n \n-        build.run(&mut cargo);\n+        let _folder = builder.fold_output(|| format!(\"stage{}-rustdoc\", target_compiler.stage));\n+        builder.info(&format!(\"Building rustdoc for stage{} ({})\",\n+            target_compiler.stage, target_compiler.host));\n+        builder.run(&mut cargo);\n+\n         // Cargo adds a number of paths to the dylib search path on windows, which results in\n         // the wrong rustdoc being executed. To avoid the conflicting rustdocs, we name the \"tool\"\n         // rustdoc a different name.\n-        let tool_rustdoc = build.cargo_out(build_compiler, Mode::Tool, target)\n-            .join(exe(\"rustdoc-tool-binary\", &target_compiler.host));\n+        let tool_rustdoc = builder.cargo_out(build_compiler, Mode::ToolRustc, target)\n+            .join(exe(\"rustdoc_tool_binary\", &target_compiler.host));\n \n         // don't create a stage0-sysroot/bin directory.\n         if target_compiler.stage > 0 {\n@@ -360,7 +513,7 @@ impl Step for Rustdoc {\n             t!(fs::create_dir_all(&bindir));\n             let bin_rustdoc = bindir.join(exe(\"rustdoc\", &*target_compiler.host));\n             let _ = fs::remove_file(&bin_rustdoc);\n-            copy(&tool_rustdoc, &bin_rustdoc);\n+            builder.copy(&tool_rustdoc, &bin_rustdoc);\n             bin_rustdoc\n         } else {\n             tool_rustdoc\n@@ -381,12 +534,12 @@ impl Step for Cargo {\n \n     fn should_run(run: ShouldRun) -> ShouldRun {\n         let builder = run.builder;\n-        run.path(\"src/tools/cargo\").default_condition(builder.build.config.extended)\n+        run.path(\"src/tools/cargo\").default_condition(builder.config.extended)\n     }\n \n     fn make_run(run: RunConfig) {\n         run.builder.ensure(Cargo {\n-            compiler: run.builder.compiler(run.builder.top_stage, run.builder.build.build),\n+            compiler: run.builder.compiler(run.builder.top_stage, run.builder.config.build),\n             target: run.target,\n         });\n     }\n@@ -399,15 +552,17 @@ impl Step for Cargo {\n         // compiler to be available, so we need to depend on that.\n         builder.ensure(compile::Rustc {\n             compiler: self.compiler,\n-            target: builder.build.build,\n+            target: builder.config.build,\n         });\n         builder.ensure(ToolBuild {\n             compiler: self.compiler,\n             target: self.target,\n             tool: \"cargo\",\n-            mode: Mode::Librustc,\n+            mode: Mode::ToolRustc,\n             path: \"src/tools/cargo\",\n-            is_ext_tool: false,\n+            is_optional_tool: false,\n+            source_type: SourceType::Submodule,\n+            extra_features: Vec::new(),\n         }).expect(\"expected to build -- essential tool\")\n     }\n }\n@@ -420,10 +575,11 @@ macro_rules! tool_extended {\n        $tool_name:expr,\n        $extra_deps:block;)+) => {\n         $(\n-            #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n+            #[derive(Debug, Clone, Hash, PartialEq, Eq)]\n         pub struct $name {\n             pub compiler: Compiler,\n             pub target: Interned<String>,\n+            pub extra_features: Vec<String>,\n         }\n \n         impl Step for $name {\n@@ -433,25 +589,29 @@ macro_rules! tool_extended {\n \n             fn should_run(run: ShouldRun) -> ShouldRun {\n                 let builder = run.builder;\n-                run.path($path).default_condition(builder.build.config.extended)\n+                run.path($path).default_condition(builder.config.extended)\n             }\n \n             fn make_run(run: RunConfig) {\n                 run.builder.ensure($name {\n-                    compiler: run.builder.compiler(run.builder.top_stage, run.builder.build.build),\n+                    compiler: run.builder.compiler(run.builder.top_stage, run.builder.config.build),\n                     target: run.target,\n+                    extra_features: Vec::new(),\n                 });\n             }\n \n-            fn run($sel, $builder: &Builder) -> Option<PathBuf> {\n+            #[allow(unused_mut)]\n+            fn run(mut $sel, $builder: &Builder) -> Option<PathBuf> {\n                 $extra_deps\n                 $builder.ensure(ToolBuild {\n                     compiler: $sel.compiler,\n                     target: $sel.target,\n                     tool: $tool_name,\n-                    mode: Mode::Librustc,\n+                    mode: Mode::ToolRustc,\n                     path: $path,\n-                    is_ext_tool: true,\n+                    extra_features: $sel.extra_features,\n+                    is_optional_tool: true,\n+                    source_type: SourceType::Submodule,\n                 })\n             }\n         }\n@@ -461,24 +621,40 @@ macro_rules! tool_extended {\n \n tool_extended!((self, builder),\n     Cargofmt, rustfmt, \"src/tools/rustfmt\", \"cargo-fmt\", {};\n+    CargoClippy, clippy, \"src/tools/clippy\", \"cargo-clippy\", {\n+        // Clippy depends on procedural macros (serde), which requires a full host\n+        // compiler to be available, so we need to depend on that.\n+        builder.ensure(compile::Rustc {\n+            compiler: self.compiler,\n+            target: builder.config.build,\n+        });\n+    };\n     Clippy, clippy, \"src/tools/clippy\", \"clippy-driver\", {\n         // Clippy depends on procedural macros (serde), which requires a full host\n         // compiler to be available, so we need to depend on that.\n         builder.ensure(compile::Rustc {\n             compiler: self.compiler,\n-            target: builder.build.build,\n+            target: builder.config.build,\n         });\n     };\n     Miri, miri, \"src/tools/miri\", \"miri\", {};\n     Rls, rls, \"src/tools/rls\", \"rls\", {\n+        let clippy = builder.ensure(Clippy {\n+            compiler: self.compiler,\n+            target: self.target,\n+            extra_features: Vec::new(),\n+        });\n+        if clippy.is_some() {\n+            self.extra_features.push(\"clippy\".to_owned());\n+        }\n         builder.ensure(native::Openssl {\n             target: self.target,\n         });\n         // RLS depends on procedural macros, which requires a full host\n         // compiler to be available, so we need to depend on that.\n         builder.ensure(compile::Rustc {\n             compiler: self.compiler,\n-            target: builder.build.build,\n+            target: builder.config.build,\n         });\n     };\n     Rustfmt, rustfmt, \"src/tools/rustfmt\", \"rustfmt\", {};\n@@ -489,20 +665,24 @@ impl<'a> Builder<'a> {\n     /// `host`.\n     pub fn tool_cmd(&self, tool: Tool) -> Command {\n         let mut cmd = Command::new(self.tool_exe(tool));\n-        let compiler = self.compiler(self.tool_default_stage(tool), self.build.build);\n-        self.prepare_tool_cmd(compiler, &mut cmd);\n+        let compiler = self.compiler(self.tool_default_stage(tool), self.config.build);\n+        self.prepare_tool_cmd(compiler, tool, &mut cmd);\n         cmd\n     }\n \n     /// Prepares the `cmd` provided to be able to run the `compiler` provided.\n     ///\n     /// Notably this munges the dynamic library lookup path to point to the\n     /// right location to run `compiler`.\n-    fn prepare_tool_cmd(&self, compiler: Compiler, cmd: &mut Command) {\n+    fn prepare_tool_cmd(&self, compiler: Compiler, tool: Tool, cmd: &mut Command) {\n         let host = &compiler.host;\n-        let mut paths: Vec<PathBuf> = vec![\n-            PathBuf::from(&self.sysroot_libdir(compiler, compiler.host)),\n-            self.cargo_out(compiler, Mode::Tool, *host).join(\"deps\"),\n+        let mut lib_paths: Vec<PathBuf> = vec![\n+            if compiler.stage == 0 && tool != Tool::ErrorIndex {\n+                self.build.rustc_snapshot_libdir()\n+            } else {\n+                PathBuf::from(&self.sysroot_libdir(compiler, compiler.host))\n+            },\n+            self.cargo_out(compiler, tool.get_mode(), *host).join(\"deps\"),\n         ];\n \n         // On MSVC a tool may invoke a C compiler (e.g. compiletest in run-make\n@@ -517,11 +697,48 @@ impl<'a> Builder<'a> {\n                 }\n                 for path in env::split_paths(v) {\n                     if !curpaths.contains(&path) {\n-                        paths.push(path);\n+                        lib_paths.push(path);\n                     }\n                 }\n             }\n         }\n-        add_lib_path(paths, cmd);\n+\n+        // Add the llvm/bin directory to PATH since it contains lots of\n+        // useful, platform-independent tools\n+        if tool.uses_llvm_tools() {\n+            if let Some(llvm_bin_path) = self.llvm_bin_path() {\n+                if host.contains(\"windows\") {\n+                    // On Windows, PATH and the dynamic library path are the same,\n+                    // so we just add the LLVM bin path to lib_path\n+                    lib_paths.push(llvm_bin_path);\n+                } else {\n+                    let old_path = env::var_os(\"PATH\").unwrap_or_default();\n+                    let new_path = env::join_paths(iter::once(llvm_bin_path)\n+                            .chain(env::split_paths(&old_path)))\n+                        .expect(\"Could not add LLVM bin path to PATH\");\n+                    cmd.env(\"PATH\", new_path);\n+                }\n+            }\n+        }\n+\n+        add_lib_path(lib_paths, cmd);\n+    }\n+\n+    fn llvm_bin_path(&self) -> Option<PathBuf> {\n+        if self.config.llvm_enabled && !self.config.dry_run {\n+            let llvm_config = self.ensure(native::Llvm {\n+                target: self.config.build,\n+                emscripten: false,\n+            });\n+\n+            // Add the llvm/bin directory to PATH since it contains lots of\n+            // useful, platform-independent tools\n+            let llvm_bin_path = llvm_config.parent()\n+                .expect(\"Expected llvm-config to be contained in directory\");\n+            assert!(llvm_bin_path.is_dir());\n+            Some(llvm_bin_path.to_path_buf())\n+        } else {\n+            None\n+        }\n     }\n }"}, {"sha": "be03796921af865b7c2c3d0a16b75d6d6272c888", "filename": "src/bootstrap/util.rs", "status": "modified", "additions": 21, "deletions": 113, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fbootstrap%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fbootstrap%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Futil.rs?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd", "patch": "@@ -15,13 +15,14 @@\n \n use std::env;\n use std::str;\n-use std::fs::{self, File, OpenOptions};\n-use std::io::{self, Read, Write, Seek, SeekFrom};\n+use std::fs;\n+use std::io::{self, Write};\n use std::path::{Path, PathBuf};\n use std::process::Command;\n use std::time::{SystemTime, Instant};\n \n-use filetime::{self, FileTime};\n+use config::Config;\n+use builder::Builder;\n \n /// Returns the `name` as the filename of a static library for `target`.\n pub fn staticlib(name: &str, target: &str) -> String {\n@@ -32,102 +33,6 @@ pub fn staticlib(name: &str, target: &str) -> String {\n     }\n }\n \n-/// Copies a file from `src` to `dst`\n-pub fn copy(src: &Path, dst: &Path) {\n-    let _ = fs::remove_file(&dst);\n-    // Attempt to \"easy copy\" by creating a hard link (symlinks don't work on\n-    // windows), but if that fails just fall back to a slow `copy` operation.\n-    if let Ok(()) = fs::hard_link(src, dst) {\n-        return\n-    }\n-    if let Err(e) = fs::copy(src, dst) {\n-        panic!(\"failed to copy `{}` to `{}`: {}\", src.display(),\n-               dst.display(), e)\n-    }\n-    let metadata = t!(src.metadata());\n-    t!(fs::set_permissions(dst, metadata.permissions()));\n-    let atime = FileTime::from_last_access_time(&metadata);\n-    let mtime = FileTime::from_last_modification_time(&metadata);\n-    t!(filetime::set_file_times(dst, atime, mtime));\n-}\n-\n-/// Search-and-replaces within a file. (Not maximally efficiently: allocates a\n-/// new string for each replacement.)\n-pub fn replace_in_file(path: &Path, replacements: &[(&str, &str)]) {\n-    let mut contents = String::new();\n-    let mut file = t!(OpenOptions::new().read(true).write(true).open(path));\n-    t!(file.read_to_string(&mut contents));\n-    for &(target, replacement) in replacements {\n-        contents = contents.replace(target, replacement);\n-    }\n-    t!(file.seek(SeekFrom::Start(0)));\n-    t!(file.set_len(0));\n-    t!(file.write_all(contents.as_bytes()));\n-}\n-\n-pub fn read_stamp_file(stamp: &Path) -> Vec<PathBuf> {\n-    let mut paths = Vec::new();\n-    let mut contents = Vec::new();\n-    t!(t!(File::open(stamp)).read_to_end(&mut contents));\n-    // This is the method we use for extracting paths from the stamp file passed to us. See\n-    // run_cargo for more information (in compile.rs).\n-    for part in contents.split(|b| *b == 0) {\n-        if part.is_empty() {\n-            continue\n-        }\n-        let path = PathBuf::from(t!(str::from_utf8(part)));\n-        paths.push(path);\n-    }\n-    paths\n-}\n-\n-/// Copies the `src` directory recursively to `dst`. Both are assumed to exist\n-/// when this function is called.\n-pub fn cp_r(src: &Path, dst: &Path) {\n-    for f in t!(fs::read_dir(src)) {\n-        let f = t!(f);\n-        let path = f.path();\n-        let name = path.file_name().unwrap();\n-        let dst = dst.join(name);\n-        if t!(f.file_type()).is_dir() {\n-            t!(fs::create_dir_all(&dst));\n-            cp_r(&path, &dst);\n-        } else {\n-            let _ = fs::remove_file(&dst);\n-            copy(&path, &dst);\n-        }\n-    }\n-}\n-\n-/// Copies the `src` directory recursively to `dst`. Both are assumed to exist\n-/// when this function is called. Unwanted files or directories can be skipped\n-/// by returning `false` from the filter function.\n-pub fn cp_filtered(src: &Path, dst: &Path, filter: &Fn(&Path) -> bool) {\n-    // Inner function does the actual work\n-    fn recurse(src: &Path, dst: &Path, relative: &Path, filter: &Fn(&Path) -> bool) {\n-        for f in t!(fs::read_dir(src)) {\n-            let f = t!(f);\n-            let path = f.path();\n-            let name = path.file_name().unwrap();\n-            let dst = dst.join(name);\n-            let relative = relative.join(name);\n-            // Only copy file or directory if the filter function returns true\n-            if filter(&relative) {\n-                if t!(f.file_type()).is_dir() {\n-                    let _ = fs::remove_dir_all(&dst);\n-                    t!(fs::create_dir(&dst));\n-                    recurse(&path, &dst, &relative, filter);\n-                } else {\n-                    let _ = fs::remove_file(&dst);\n-                    copy(&path, &dst);\n-                }\n-            }\n-        }\n-    }\n-    // Immediately recurse with an empty relative path\n-    recurse(src, dst, Path::new(\"\"), filter)\n-}\n-\n /// Given an executable called `name`, return the filename for the\n /// executable for a particular target.\n pub fn exe(name: &str, target: &str) -> String {\n@@ -187,34 +92,34 @@ pub fn push_exe_path(mut buf: PathBuf, components: &[&str]) -> PathBuf {\n         file.push_str(\".exe\");\n     }\n \n-    for c in components {\n-        buf.push(c);\n-    }\n-\n+    buf.extend(components);\n     buf.push(file);\n \n     buf\n }\n \n-pub struct TimeIt(Instant);\n+pub struct TimeIt(bool, Instant);\n \n /// Returns an RAII structure that prints out how long it took to drop.\n-pub fn timeit() -> TimeIt {\n-    TimeIt(Instant::now())\n+pub fn timeit(builder: &Builder) -> TimeIt {\n+    TimeIt(builder.config.dry_run, Instant::now())\n }\n \n impl Drop for TimeIt {\n     fn drop(&mut self) {\n-        let time = self.0.elapsed();\n-        println!(\"\\tfinished in {}.{:03}\",\n-                 time.as_secs(),\n-                 time.subsec_nanos() / 1_000_000);\n+        let time = self.1.elapsed();\n+        if !self.0 {\n+            println!(\"\\tfinished in {}.{:03}\",\n+                    time.as_secs(),\n+                    time.subsec_nanos() / 1_000_000);\n+        }\n     }\n }\n \n /// Symlinks two directories, using junctions on Windows and normal symlinks on\n /// Unix.\n-pub fn symlink_dir(src: &Path, dest: &Path) -> io::Result<()> {\n+pub fn symlink_dir(config: &Config, src: &Path, dest: &Path) -> io::Result<()> {\n+    if config.dry_run { return Ok(()); }\n     let _ = fs::remove_dir(dest);\n     return symlink_dir_inner(src, dest);\n \n@@ -288,6 +193,7 @@ pub fn symlink_dir(src: &Path, dest: &Path) -> io::Result<()> {\n                                nOutBufferSize: DWORD,\n                                lpBytesReturned: LPDWORD,\n                                lpOverlapped: LPOVERLAPPED) -> BOOL;\n+            fn CloseHandle(hObject: HANDLE) -> BOOL;\n         }\n \n         fn to_u16s<S: AsRef<OsStr>>(s: S) -> io::Result<Vec<u16>> {\n@@ -341,11 +247,13 @@ pub fn symlink_dir(src: &Path, dest: &Path) -> io::Result<()> {\n                                       &mut ret,\n                                       ptr::null_mut());\n \n-            if res == 0 {\n+            let out = if res == 0 {\n                 Err(io::Error::last_os_error())\n             } else {\n                 Ok(())\n-            }\n+            };\n+            CloseHandle(h);\n+            out\n         }\n     }\n }"}, {"sha": "01d704f816bbc8fc00813d2636f3fe44a847db35", "filename": "src/build_helper/Cargo.toml", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fbuild_helper%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fbuild_helper%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbuild_helper%2FCargo.toml?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd", "patch": "@@ -6,6 +6,3 @@ authors = [\"The Rust Project Developers\"]\n [lib]\n name = \"build_helper\"\n path = \"lib.rs\"\n-\n-[dependencies]\n-filetime = \"0.1\""}, {"sha": "1cbb8e49bfa15e0579ebeb0e3b37aa0d0bda10db", "filename": "src/build_helper/lib.rs", "status": "modified", "additions": 93, "deletions": 63, "changes": 156, "blob_url": "https://github.com/rust-lang/rust/blob/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fbuild_helper%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fbuild_helper%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbuild_helper%2Flib.rs?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd", "patch": "@@ -8,16 +8,12 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![deny(warnings)]\n-\n-extern crate filetime;\n-\n use std::fs::File;\n use std::path::{Path, PathBuf};\n use std::process::{Command, Stdio};\n-use std::{fs, env};\n-\n-use filetime::FileTime;\n+use std::time::{SystemTime, UNIX_EPOCH};\n+use std::{env, fs};\n+use std::thread;\n \n /// A helper macro to `unwrap` a result except also print out details like:\n ///\n@@ -29,10 +25,12 @@ use filetime::FileTime;\n /// using a `Result` with `try!`, but this may change one day...\n #[macro_export]\n macro_rules! t {\n-    ($e:expr) => (match $e {\n-        Ok(e) => e,\n-        Err(e) => panic!(\"{} failed with {}\", stringify!($e), e),\n-    })\n+    ($e:expr) => {\n+        match $e {\n+            Ok(e) => e,\n+            Err(e) => panic!(\"{} failed with {}\", stringify!($e), e),\n+        }\n+    };\n }\n \n pub fn run(cmd: &mut Command) {\n@@ -49,14 +47,17 @@ pub fn run_silent(cmd: &mut Command) {\n pub fn try_run_silent(cmd: &mut Command) -> bool {\n     let status = match cmd.status() {\n         Ok(status) => status,\n-        Err(e) => fail(&format!(\"failed to execute command: {:?}\\nerror: {}\",\n-                                cmd, e)),\n+        Err(e) => fail(&format!(\n+            \"failed to execute command: {:?}\\nerror: {}\",\n+            cmd, e\n+        )),\n     };\n     if !status.success() {\n-        println!(\"\\n\\ncommand did not execute successfully: {:?}\\n\\\n-                  expected success, got: {}\\n\\n\",\n-                 cmd,\n-                 status);\n+        println!(\n+            \"\\n\\ncommand did not execute successfully: {:?}\\n\\\n+             expected success, got: {}\\n\\n\",\n+            cmd, status\n+        );\n     }\n     status.success()\n }\n@@ -70,18 +71,22 @@ pub fn run_suppressed(cmd: &mut Command) {\n pub fn try_run_suppressed(cmd: &mut Command) -> bool {\n     let output = match cmd.output() {\n         Ok(status) => status,\n-        Err(e) => fail(&format!(\"failed to execute command: {:?}\\nerror: {}\",\n-                                cmd, e)),\n+        Err(e) => fail(&format!(\n+            \"failed to execute command: {:?}\\nerror: {}\",\n+            cmd, e\n+        )),\n     };\n     if !output.status.success() {\n-        println!(\"\\n\\ncommand did not execute successfully: {:?}\\n\\\n-                  expected success, got: {}\\n\\n\\\n-                  stdout ----\\n{}\\n\\\n-                  stderr ----\\n{}\\n\\n\",\n-                 cmd,\n-                 output.status,\n-                 String::from_utf8_lossy(&output.stdout),\n-                 String::from_utf8_lossy(&output.stderr));\n+        println!(\n+            \"\\n\\ncommand did not execute successfully: {:?}\\n\\\n+             expected success, got: {}\\n\\n\\\n+             stdout ----\\n{}\\n\\\n+             stderr ----\\n{}\\n\\n\",\n+            cmd,\n+            output.status,\n+            String::from_utf8_lossy(&output.stdout),\n+            String::from_utf8_lossy(&output.stderr)\n+        );\n     }\n     output.status.success()\n }\n@@ -97,9 +102,9 @@ pub fn gnu_target(target: &str) -> String {\n }\n \n pub fn make(host: &str) -> PathBuf {\n-    if host.contains(\"bitrig\") || host.contains(\"dragonfly\") ||\n-        host.contains(\"freebsd\") || host.contains(\"netbsd\") ||\n-        host.contains(\"openbsd\") {\n+    if host.contains(\"bitrig\") || host.contains(\"dragonfly\") || host.contains(\"freebsd\")\n+        || host.contains(\"netbsd\") || host.contains(\"openbsd\")\n+    {\n         PathBuf::from(\"gmake\")\n     } else {\n         PathBuf::from(\"make\")\n@@ -109,23 +114,27 @@ pub fn make(host: &str) -> PathBuf {\n pub fn output(cmd: &mut Command) -> String {\n     let output = match cmd.stderr(Stdio::inherit()).output() {\n         Ok(status) => status,\n-        Err(e) => fail(&format!(\"failed to execute command: {:?}\\nerror: {}\",\n-                                cmd, e)),\n+        Err(e) => fail(&format!(\n+            \"failed to execute command: {:?}\\nerror: {}\",\n+            cmd, e\n+        )),\n     };\n     if !output.status.success() {\n-        panic!(\"command did not execute successfully: {:?}\\n\\\n-                expected success, got: {}\",\n-               cmd,\n-               output.status);\n+        panic!(\n+            \"command did not execute successfully: {:?}\\n\\\n+             expected success, got: {}\",\n+            cmd, output.status\n+        );\n     }\n     String::from_utf8(output.stdout).unwrap()\n }\n \n pub fn rerun_if_changed_anything_in_dir(dir: &Path) {\n-    let mut stack = dir.read_dir().unwrap()\n-                       .map(|e| e.unwrap())\n-                       .filter(|e| &*e.file_name() != \".git\")\n-                       .collect::<Vec<_>>();\n+    let mut stack = dir.read_dir()\n+        .unwrap()\n+        .map(|e| e.unwrap())\n+        .filter(|e| &*e.file_name() != \".git\")\n+        .collect::<Vec<_>>();\n     while let Some(entry) = stack.pop() {\n         let path = entry.path();\n         if entry.file_type().unwrap().is_dir() {\n@@ -137,10 +146,10 @@ pub fn rerun_if_changed_anything_in_dir(dir: &Path) {\n }\n \n /// Returns the last-modified time for `path`, or zero if it doesn't exist.\n-pub fn mtime(path: &Path) -> FileTime {\n-    fs::metadata(path).map(|f| {\n-        FileTime::from_last_modification_time(&f)\n-    }).unwrap_or(FileTime::zero())\n+pub fn mtime(path: &Path) -> SystemTime {\n+    fs::metadata(path)\n+        .and_then(|f| f.modified())\n+        .unwrap_or(UNIX_EPOCH)\n }\n \n /// Returns whether `dst` is up to date given that the file or files in `src`\n@@ -157,9 +166,9 @@ pub fn up_to_date(src: &Path, dst: &Path) -> bool {\n         Err(e) => panic!(\"source {:?} failed to get metadata: {}\", src, e),\n     };\n     if meta.is_dir() {\n-        dir_up_to_date(src, &threshold)\n+        dir_up_to_date(src, threshold)\n     } else {\n-        FileTime::from_last_modification_time(&meta) <= threshold\n+        meta.modified().unwrap_or(UNIX_EPOCH) <= threshold\n     }\n }\n \n@@ -171,7 +180,9 @@ pub struct NativeLibBoilerplate {\n \n impl Drop for NativeLibBoilerplate {\n     fn drop(&mut self) {\n-        t!(File::create(self.out_dir.join(\"rustbuild.timestamp\")));\n+        if !thread::panicking() {\n+            t!(File::create(self.out_dir.join(\"rustbuild.timestamp\")));\n+        }\n     }\n }\n \n@@ -181,11 +192,12 @@ impl Drop for NativeLibBoilerplate {\n // If Err is returned, then everything is up-to-date and further build actions can be skipped.\n // Timestamps are created automatically when the result of `native_lib_boilerplate` goes out\n // of scope, so all the build actions should be completed until then.\n-pub fn native_lib_boilerplate(src_name: &str,\n-                              out_name: &str,\n-                              link_name: &str,\n-                              search_subdir: &str)\n-                              -> Result<NativeLibBoilerplate, ()> {\n+pub fn native_lib_boilerplate(\n+    src_name: &str,\n+    out_name: &str,\n+    link_name: &str,\n+    search_subdir: &str,\n+) -> Result<NativeLibBoilerplate, ()> {\n     let current_dir = PathBuf::from(env::var(\"CARGO_MANIFEST_DIR\").unwrap());\n     let src_dir = current_dir.join(\"..\").join(src_name);\n     rerun_if_changed_anything_in_dir(&src_dir);\n@@ -198,41 +210,59 @@ pub fn native_lib_boilerplate(src_name: &str,\n     } else {\n         println!(\"cargo:rustc-link-lib=static={}\", link_name);\n     }\n-    println!(\"cargo:rustc-link-search=native={}\", out_dir.join(search_subdir).display());\n+    println!(\n+        \"cargo:rustc-link-search=native={}\",\n+        out_dir.join(search_subdir).display()\n+    );\n \n     let timestamp = out_dir.join(\"rustbuild.timestamp\");\n     if !up_to_date(Path::new(\"build.rs\"), &timestamp) || !up_to_date(&src_dir, &timestamp) {\n-        Ok(NativeLibBoilerplate { src_dir: src_dir, out_dir: out_dir })\n+        Ok(NativeLibBoilerplate {\n+            src_dir: src_dir,\n+            out_dir: out_dir,\n+        })\n     } else {\n         Err(())\n     }\n }\n \n-pub fn sanitizer_lib_boilerplate(sanitizer_name: &str) -> Result<NativeLibBoilerplate, ()> {\n-    let (link_name, search_path) = match &*env::var(\"TARGET\").unwrap() {\n+pub fn sanitizer_lib_boilerplate(sanitizer_name: &str)\n+    -> Result<(NativeLibBoilerplate, String), ()>\n+{\n+    let (link_name, search_path, dynamic) = match &*env::var(\"TARGET\").unwrap() {\n         \"x86_64-unknown-linux-gnu\" => (\n             format!(\"clang_rt.{}-x86_64\", sanitizer_name),\n             \"build/lib/linux\",\n+            false,\n         ),\n         \"x86_64-apple-darwin\" => (\n-            format!(\"dylib=clang_rt.{}_osx_dynamic\", sanitizer_name),\n+            format!(\"clang_rt.{}_osx_dynamic\", sanitizer_name),\n             \"build/lib/darwin\",\n+            true,\n         ),\n         _ => return Err(()),\n     };\n-    native_lib_boilerplate(\"libcompiler_builtins/compiler-rt\",\n-                           sanitizer_name,\n-                           &link_name,\n-                           search_path)\n+    let to_link = if dynamic {\n+        format!(\"dylib={}\", link_name)\n+    } else {\n+        format!(\"static={}\", link_name)\n+    };\n+    let lib = native_lib_boilerplate(\n+        \"libcompiler_builtins/compiler-rt\",\n+        sanitizer_name,\n+        &to_link,\n+        search_path,\n+    )?;\n+    Ok((lib, link_name))\n }\n \n-fn dir_up_to_date(src: &Path, threshold: &FileTime) -> bool {\n+fn dir_up_to_date(src: &Path, threshold: SystemTime) -> bool {\n     t!(fs::read_dir(src)).map(|e| t!(e)).all(|e| {\n         let meta = t!(e.metadata());\n         if meta.is_dir() {\n             dir_up_to_date(&e.path(), threshold)\n         } else {\n-            FileTime::from_last_modification_time(&meta) < *threshold\n+            meta.modified().unwrap_or(UNIX_EPOCH) < threshold\n         }\n     })\n }"}, {"sha": "e10ccd56a4a54613978def21f294de6d9fb86fdd", "filename": "src/ci/docker/arm-android/Dockerfile", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fci%2Fdocker%2Farm-android%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fci%2Fdocker%2Farm-android%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Farm-android%2FDockerfile?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd", "patch": "@@ -31,9 +31,7 @@ ENV PATH=$PATH:/android/sdk/platform-tools\n \n ENV TARGETS=arm-linux-androideabi\n \n-ENV RUST_CONFIGURE_ARGS \\\n-      --target=$TARGETS \\\n-      --arm-linux-androideabi-ndk=/android/ndk/arm-14\n+ENV RUST_CONFIGURE_ARGS --arm-linux-androideabi-ndk=/android/ndk/arm-14\n \n ENV SCRIPT python2.7 ../x.py test --target $TARGETS\n "}, {"sha": "2b7624d53ee05d04f706a105979678717bd59a55", "filename": "src/ci/docker/armhf-gnu/Dockerfile", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fci%2Fdocker%2Farmhf-gnu%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fci%2Fdocker%2Farmhf-gnu%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Farmhf-gnu%2FDockerfile?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd", "patch": "@@ -76,9 +76,7 @@ RUN curl -O http://ftp.nl.debian.org/debian/dists/jessie/main/installer-armhf/cu\n COPY scripts/sccache.sh /scripts/\n RUN sh /scripts/sccache.sh\n \n-ENV RUST_CONFIGURE_ARGS \\\n-      --target=arm-unknown-linux-gnueabihf \\\n-      --qemu-armhf-rootfs=/tmp/rootfs\n+ENV RUST_CONFIGURE_ARGS --qemu-armhf-rootfs=/tmp/rootfs\n ENV SCRIPT python2.7 ../x.py test --target arm-unknown-linux-gnueabihf\n \n ENV NO_CHANGE_USER=1"}, {"sha": "cb85cf3d9e9f094f87ba6617250e55ef68a7fd42", "filename": "src/ci/docker/asmjs/Dockerfile", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fci%2Fdocker%2Fasmjs%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fci%2Fdocker%2Fasmjs%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fasmjs%2FDockerfile?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd", "patch": "@@ -29,6 +29,11 @@ ENV EM_CONFIG=/emsdk-portable/.emscripten\n \n ENV TARGETS=asmjs-unknown-emscripten\n \n-ENV RUST_CONFIGURE_ARGS --target=$TARGETS\n+ENV RUST_CONFIGURE_ARGS --enable-emscripten --disable-optimize-tests\n \n-ENV SCRIPT python2.7 ../x.py test --target $TARGETS\n+ENV SCRIPT python2.7 ../x.py test --target $TARGETS \\\n+  src/test/run-pass \\\n+  src/test/run-fail \\\n+  src/libstd \\\n+  src/liballoc \\\n+  src/libcore"}, {"sha": "b2a3ba3ec2600ebc2d37296b328d09b675d237fd", "filename": "src/ci/docker/disabled/aarch64-gnu/Dockerfile", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fci%2Fdocker%2Fdisabled%2Faarch64-gnu%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fci%2Fdocker%2Fdisabled%2Faarch64-gnu%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdisabled%2Faarch64-gnu%2FDockerfile?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd", "patch": "@@ -74,7 +74,6 @@ COPY scripts/sccache.sh /scripts/\n RUN sh /scripts/sccache.sh\n \n ENV RUST_CONFIGURE_ARGS \\\n-      --target=aarch64-unknown-linux-gnu \\\n       --qemu-aarch64-rootfs=/tmp/rootfs\n ENV SCRIPT python2.7 ../x.py test --target aarch64-unknown-linux-gnu\n ENV NO_CHANGE_USER=1"}, {"sha": "a7903b6f42501337f8fe500dc9d41db069e94c9a", "filename": "src/ci/docker/disabled/dist-aarch64-android/Dockerfile", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fci%2Fdocker%2Fdisabled%2Fdist-aarch64-android%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fci%2Fdocker%2Fdisabled%2Fdist-aarch64-android%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdisabled%2Fdist-aarch64-android%2FDockerfile?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd", "patch": "@@ -14,8 +14,6 @@ ENV DEP_Z_ROOT=/android/ndk/arm64-21/sysroot/usr/\n ENV HOSTS=aarch64-linux-android\n \n ENV RUST_CONFIGURE_ARGS \\\n-      --host=$HOSTS \\\n-      --target=$HOSTS \\\n       --aarch64-linux-android-ndk=/android/ndk/arm64-21 \\\n       --disable-rpath \\\n       --enable-extended \\"}, {"sha": "34c6e640abb7c85460a9baee202e0bcc69881001", "filename": "src/ci/docker/disabled/dist-armebv7r-none-eabihf/Dockerfile", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fci%2Fdocker%2Fdisabled%2Fdist-armebv7r-none-eabihf%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fci%2Fdocker%2Fdisabled%2Fdist-armebv7r-none-eabihf%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdisabled%2Fdist-armebv7r-none-eabihf%2FDockerfile?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd", "patch": "@@ -0,0 +1,36 @@\n+FROM ubuntu:16.04\n+\n+RUN apt-get update && apt-get install -y --no-install-recommends \\\n+  g++ \\\n+  make \\\n+  file \\\n+  curl \\\n+  ca-certificates \\\n+  python2.7 \\\n+  git \\\n+  cmake \\\n+  sudo \\\n+  xz-utils \\\n+  bzip2 \\\n+  libssl-dev \\\n+  pkg-config\n+\n+\n+COPY scripts/sccache.sh /scripts/\n+RUN sh /scripts/sccache.sh\n+\n+ENV BASE_URL=https://releases.linaro.org/components/toolchain/binaries/latest/armeb-eabi/\n+ENV GCC_LINARO=gcc-linaro-7.2.1-2017.11-x86_64_armeb-eabi\n+\n+RUN curl -sL $BASE_URL/$GCC_LINARO.tar.xz | tar -xJ\n+\n+ENV PATH=$PATH:/$GCC_LINARO/bin\n+\n+ENV TARGET=armebv7r-none-eabihf\n+\n+ENV CC_armebv7r_none_eabihf=armeb-eabi-gcc \\\n+    CFLAGS_armebv7r_none_eabihf=\"-march=armv7-r\"\n+\n+ENV RUST_CONFIGURE_ARGS --disable-docs\n+\n+ENV SCRIPT python2.7 ../x.py dist --target $TARGET"}, {"sha": "c02a5e5a09542c3fd163ab7c7deed3f69fac42d5", "filename": "src/ci/docker/disabled/dist-armv7-android/Dockerfile", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fci%2Fdocker%2Fdisabled%2Fdist-armv7-android%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fci%2Fdocker%2Fdisabled%2Fdist-armv7-android%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdisabled%2Fdist-armv7-android%2FDockerfile?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd", "patch": "@@ -20,8 +20,6 @@ ENV DEP_Z_ROOT=/android/ndk/arm-14/sysroot/usr/\n ENV HOSTS=armv7-linux-androideabi\n \n ENV RUST_CONFIGURE_ARGS \\\n-      --host=$HOSTS \\\n-      --target=$HOSTS \\\n       --armv7-linux-androideabi-ndk=/android/ndk/arm \\\n       --disable-rpath \\\n       --enable-extended \\"}, {"sha": "04e83a431c45526e7587cb007164a55f2e8eea7d", "filename": "src/ci/docker/disabled/dist-i686-android/Dockerfile", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fci%2Fdocker%2Fdisabled%2Fdist-i686-android%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fci%2Fdocker%2Fdisabled%2Fdist-i686-android%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdisabled%2Fdist-i686-android%2FDockerfile?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd", "patch": "@@ -20,8 +20,6 @@ ENV DEP_Z_ROOT=/android/ndk/x86-14/sysroot/usr/\n ENV HOSTS=i686-linux-android\n \n ENV RUST_CONFIGURE_ARGS \\\n-      --host=$HOSTS \\\n-      --target=$HOSTS \\\n       --i686-linux-android-ndk=/android/ndk/x86 \\\n       --disable-rpath \\\n       --enable-extended \\"}, {"sha": "952c265a1390b75fa871cf06a4e1d13323db1420", "filename": "src/ci/docker/disabled/dist-sparc64-linux/Dockerfile", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fci%2Fdocker%2Fdisabled%2Fdist-sparc64-linux%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fci%2Fdocker%2Fdisabled%2Fdist-sparc64-linux%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdisabled%2Fdist-sparc64-linux%2FDockerfile?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd", "patch": "@@ -0,0 +1,26 @@\n+FROM ubuntu:16.04\n+\n+RUN apt-get update && apt-get install -y --no-install-recommends \\\n+  g++ \\\n+  make \\\n+  file \\\n+  curl \\\n+  ca-certificates \\\n+  python2.7 \\\n+  git \\\n+  cmake \\\n+  sudo \\\n+  gdb \\\n+  xz-utils \\\n+  g++-sparc64-linux-gnu \\\n+  libssl-dev \\\n+  pkg-config\n+\n+\n+COPY scripts/sccache.sh /scripts/\n+RUN sh /scripts/sccache.sh\n+\n+ENV HOSTS=sparc64-unknown-linux-gnu\n+\n+ENV RUST_CONFIGURE_ARGS --enable-extended --disable-docs\n+ENV SCRIPT python2.7 ../x.py dist --host $HOSTS --target $HOSTS"}, {"sha": "937301864cd059bfeaae5899f20d0d3305b5da29", "filename": "src/ci/docker/disabled/dist-x86_64-android/Dockerfile", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fci%2Fdocker%2Fdisabled%2Fdist-x86_64-android%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fci%2Fdocker%2Fdisabled%2Fdist-x86_64-android%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdisabled%2Fdist-x86_64-android%2FDockerfile?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd", "patch": "@@ -14,8 +14,6 @@ ENV DEP_Z_ROOT=/android/ndk/x86_64-21/sysroot/usr/\n ENV HOSTS=x86_64-linux-android\n \n ENV RUST_CONFIGURE_ARGS \\\n-      --host=$HOSTS \\\n-      --target=$HOSTS \\\n       --x86_64-linux-android-ndk=/android/ndk/x86_64-21 \\\n       --disable-rpath \\\n       --enable-extended \\"}, {"sha": "dbff9e32e1311d9ceff3e2314009dae43df16132", "filename": "src/ci/docker/disabled/dist-x86_64-dragonfly/Dockerfile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fci%2Fdocker%2Fdisabled%2Fdist-x86_64-dragonfly%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fci%2Fdocker%2Fdisabled%2Fdist-x86_64-dragonfly%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdisabled%2Fdist-x86_64-dragonfly%2FDockerfile?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd", "patch": "@@ -32,5 +32,5 @@ ENV \\\n \n ENV HOSTS=x86_64-unknown-dragonfly\n \n-ENV RUST_CONFIGURE_ARGS --host=$HOSTS --enable-extended\n+ENV RUST_CONFIGURE_ARGS --enable-extended\n ENV SCRIPT python2.7 ../x.py dist --host $HOSTS --target $HOSTS"}, {"sha": "440afd7c97f5e3a162e8e49fb145df681115caef", "filename": "src/ci/docker/disabled/dist-x86_64-haiku/Dockerfile", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fci%2Fdocker%2Fdisabled%2Fdist-x86_64-haiku%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fci%2Fdocker%2Fdisabled%2Fdist-x86_64-haiku%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdisabled%2Fdist-x86_64-haiku%2FDockerfile?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd", "patch": "@@ -42,8 +42,8 @@ RUN sh /scripts/sccache.sh\n ENV HOST=x86_64-unknown-haiku\n ENV TARGET=target.$HOST\n \n-ENV RUST_CONFIGURE_ARGS --host=$HOST --target=$HOST --disable-jemalloc \\\n+ENV RUST_CONFIGURE_ARGS --disable-jemalloc \\\n   --set=$TARGET.cc=x86_64-unknown-haiku-gcc \\\n   --set=$TARGET.cxx=x86_64-unknown-haiku-g++ \\\n   --set=$TARGET.llvm-config=/bin/llvm-config-haiku\n-ENV SCRIPT python2.7 ../x.py dist\n+ENV SCRIPT python2.7 ../x.py dist --host=$HOST --target=$HOST"}, {"sha": "f4c25f791bc3916bdf60be34aa927ae6b8ea88f5", "filename": "src/ci/docker/disabled/dist-x86_64-redox/Dockerfile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fci%2Fdocker%2Fdisabled%2Fdist-x86_64-redox%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fci%2Fdocker%2Fdisabled%2Fdist-x86_64-redox%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdisabled%2Fdist-x86_64-redox%2FDockerfile?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd", "patch": "@@ -18,5 +18,5 @@ ENV \\\n     CC_x86_64_unknown_redox=x86_64-unknown-redox-gcc \\\n     CXX_x86_64_unknown_redox=x86_64-unknown-redox-g++\n \n-ENV RUST_CONFIGURE_ARGS --target=x86_64-unknown-redox --enable-extended\n+ENV RUST_CONFIGURE_ARGS --enable-extended\n ENV SCRIPT python2.7 ../x.py dist --target x86_64-unknown-redox"}, {"sha": "420d47b314c0f63da8e006eb78688c6051eec6c5", "filename": "src/ci/docker/disabled/wasm32-exp/Dockerfile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fci%2Fdocker%2Fdisabled%2Fwasm32-exp%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fci%2Fdocker%2Fdisabled%2Fwasm32-exp%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdisabled%2Fwasm32-exp%2FDockerfile?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd", "patch": "@@ -30,6 +30,6 @@ ENV EM_CONFIG=/root/.emscripten\n \n ENV TARGETS=wasm32-experimental-emscripten\n \n-ENV RUST_CONFIGURE_ARGS --target=$TARGETS --experimental-targets=WebAssembly\n+ENV RUST_CONFIGURE_ARGS --experimental-targets=WebAssembly\n \n ENV SCRIPT python2.7 ../x.py test --target $TARGETS"}, {"sha": "6ac90d17450a37fbac1bcd610a0b86eaa72b3f8e", "filename": "src/ci/docker/disabled/wasm32/Dockerfile", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fci%2Fdocker%2Fdisabled%2Fwasm32%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fci%2Fdocker%2Fdisabled%2Fwasm32%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdisabled%2Fwasm32%2FDockerfile?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd", "patch": "@@ -29,7 +29,4 @@ ENV BINARYEN_ROOT=/emsdk-portable/clang/e1.37.13_64bit/binaryen/\n ENV EM_CONFIG=/emsdk-portable/.emscripten\n \n ENV TARGETS=wasm32-unknown-emscripten\n-\n-ENV RUST_CONFIGURE_ARGS --target=$TARGETS\n-\n ENV SCRIPT python2.7 ../x.py test --target $TARGETS"}, {"sha": "cddfa557f6aed7e43ac04c326cfe6509417e0c0d", "filename": "src/ci/docker/dist-aarch64-linux/Dockerfile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fci%2Fdocker%2Fdist-aarch64-linux%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fci%2Fdocker%2Fdist-aarch64-linux%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-aarch64-linux%2FDockerfile?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd", "patch": "@@ -32,5 +32,5 @@ ENV CC_aarch64_unknown_linux_gnu=aarch64-unknown-linux-gnueabi-gcc \\\n \n ENV HOSTS=aarch64-unknown-linux-gnu\n \n-ENV RUST_CONFIGURE_ARGS --host=$HOSTS --enable-extended\n+ENV RUST_CONFIGURE_ARGS --enable-extended --disable-docs\n ENV SCRIPT python2.7 ../x.py dist --host $HOSTS --target $HOSTS"}, {"sha": "e00c23dac89b087dd66edbec4e1ff6db704cb9fd", "filename": "src/ci/docker/dist-android/Dockerfile", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fci%2Fdocker%2Fdist-android%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fci%2Fdocker%2Fdist-android%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-android%2FDockerfile?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd", "patch": "@@ -21,13 +21,13 @@ ENV TARGETS=$TARGETS,aarch64-linux-android\n ENV TARGETS=$TARGETS,x86_64-linux-android\n \n ENV RUST_CONFIGURE_ARGS \\\n-      --target=$TARGETS \\\n       --enable-extended \\\n       --arm-linux-androideabi-ndk=/android/ndk/arm-14 \\\n       --armv7-linux-androideabi-ndk=/android/ndk/arm-14 \\\n       --i686-linux-android-ndk=/android/ndk/x86-14 \\\n       --aarch64-linux-android-ndk=/android/ndk/arm64-21 \\\n-      --x86_64-linux-android-ndk=/android/ndk/x86_64-21\n+      --x86_64-linux-android-ndk=/android/ndk/x86_64-21 \\\n+      --disable-docs\n \n ENV SCRIPT python2.7 ../x.py dist --target $TARGETS\n "}, {"sha": "6ddc5c1e04ae35223c38a6002ac6ef996f23a3e0", "filename": "src/ci/docker/dist-arm-linux/Dockerfile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fci%2Fdocker%2Fdist-arm-linux%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fci%2Fdocker%2Fdist-arm-linux%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-arm-linux%2FDockerfile?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd", "patch": "@@ -32,5 +32,5 @@ ENV CC_arm_unknown_linux_gnueabi=arm-unknown-linux-gnueabi-gcc \\\n \n ENV HOSTS=arm-unknown-linux-gnueabi\n \n-ENV RUST_CONFIGURE_ARGS --host=$HOSTS --enable-extended\n+ENV RUST_CONFIGURE_ARGS --enable-extended --disable-docs\n ENV SCRIPT python2.7 ../x.py dist --host $HOSTS --target $HOSTS"}, {"sha": "e4d4b2feeec40270c84f97b3277bfc4dfd6bb911", "filename": "src/ci/docker/dist-armhf-linux/Dockerfile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fci%2Fdocker%2Fdist-armhf-linux%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fci%2Fdocker%2Fdist-armhf-linux%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-armhf-linux%2FDockerfile?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd", "patch": "@@ -32,5 +32,5 @@ ENV CC_arm_unknown_linux_gnueabihf=arm-unknown-linux-gnueabihf-gcc \\\n \n ENV HOSTS=arm-unknown-linux-gnueabihf\n \n-ENV RUST_CONFIGURE_ARGS --host=$HOSTS --enable-extended\n+ENV RUST_CONFIGURE_ARGS --enable-extended --disable-docs\n ENV SCRIPT python2.7 ../x.py dist --host $HOSTS --target $HOSTS"}, {"sha": "99fe7bd7b8f7871fc5aa607f00ec2fb2103bfcb5", "filename": "src/ci/docker/dist-armv7-linux/Dockerfile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fci%2Fdocker%2Fdist-armv7-linux%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fci%2Fdocker%2Fdist-armv7-linux%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-armv7-linux%2FDockerfile?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd", "patch": "@@ -32,5 +32,5 @@ ENV CC_armv7_unknown_linux_gnueabihf=armv7-unknown-linux-gnueabihf-gcc \\\n \n ENV HOSTS=armv7-unknown-linux-gnueabihf\n \n-ENV RUST_CONFIGURE_ARGS --host=$HOSTS --enable-extended\n+ENV RUST_CONFIGURE_ARGS --enable-extended --disable-docs\n ENV SCRIPT python2.7 ../x.py dist --host $HOSTS --target $HOSTS"}, {"sha": "ba2d32a9296b4e099da0b8660652e79dfd13601f", "filename": "src/ci/docker/dist-i586-gnu-i586-i686-musl/Dockerfile", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fci%2Fdocker%2Fdist-i586-gnu-i586-i686-musl%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fci%2Fdocker%2Fdist-i586-gnu-i586-i686-musl%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-i586-gnu-i586-i686-musl%2FDockerfile?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd", "patch": "@@ -18,10 +18,10 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n \n WORKDIR /build/\n COPY scripts/musl.sh /build/\n-RUN CC=gcc CFLAGS=\"-m32 -fPIC -Wa,-mrelax-relocations=no\" \\\n+RUN CC=gcc CFLAGS=\"-m32 -Wa,-mrelax-relocations=no\" \\\n     CXX=g++ CXXFLAGS=\"-m32 -Wa,-mrelax-relocations=no\" \\\n     bash musl.sh i686 --target=i686 && \\\n-    CC=gcc CFLAGS=\"-march=pentium -m32 -fPIC -Wa,-mrelax-relocations=no\" \\\n+    CC=gcc CFLAGS=\"-march=pentium -m32 -Wa,-mrelax-relocations=no\" \\\n     CXX=g++ CXXFLAGS=\"-march=pentium -m32 -Wa,-mrelax-relocations=no\" \\\n     bash musl.sh i586 --target=i586 && \\\n     rm -rf /build\n@@ -30,10 +30,10 @@ COPY scripts/sccache.sh /scripts/\n RUN sh /scripts/sccache.sh\n \n ENV RUST_CONFIGURE_ARGS \\\n-      --target=i686-unknown-linux-musl,i586-unknown-linux-gnu \\\n       --musl-root-i586=/musl-i586 \\\n       --musl-root-i686=/musl-i686 \\\n-      --enable-extended\n+      --enable-extended \\\n+      --disable-docs\n \n # Newer binutils broke things on some vms/distros (i.e., linking against\n # unknown relocs disabled by the following flag), so we need to go out of our\n@@ -42,12 +42,9 @@ ENV RUST_CONFIGURE_ARGS \\\n # See: https://github.com/rust-lang/rust/issues/34978\n ENV CFLAGS_i686_unknown_linux_musl=-Wa,-mrelax-relocations=no\n ENV CFLAGS_i586_unknown_linux_gnu=-Wa,-mrelax-relocations=no\n-# FIXME remove -Wl,-melf_i386 after cc is updated to include\n-#       https://github.com/alexcrichton/cc-rs/pull/281\n-ENV CFLAGS_i586_unknown_linux_musl=\"-Wa,-mrelax-relocations=no -Wl,-melf_i386\"\n+ENV CFLAGS_i586_unknown_linux_musl=-Wa,-mrelax-relocations=no\n \n-ENV TARGETS=i586-unknown-linux-gnu\n-ENV TARGETS=$TARGETS,i686-unknown-linux-musl\n+ENV TARGETS=i586-unknown-linux-gnu,i686-unknown-linux-musl\n \n ENV SCRIPT \\\n       python2.7 ../x.py test --target $TARGETS && \\"}, {"sha": "6f6a663a3309387abf8ec5785f5f1df2f7687aa3", "filename": "src/ci/docker/dist-i686-freebsd/Dockerfile", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fci%2Fdocker%2Fdist-i686-freebsd%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fci%2Fdocker%2Fdist-i686-freebsd%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-i686-freebsd%2FDockerfile?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd", "patch": "@@ -1,4 +1,4 @@\n-FROM ubuntu:16.04\n+FROM ubuntu:18.04\n \n RUN apt-get update && apt-get install -y --no-install-recommends \\\n   clang \\\n@@ -29,5 +29,5 @@ ENV \\\n \n ENV HOSTS=i686-unknown-freebsd\n \n-ENV RUST_CONFIGURE_ARGS --host=$HOSTS --enable-extended\n+ENV RUST_CONFIGURE_ARGS --enable-extended --disable-docs\n ENV SCRIPT python2.7 ../x.py dist --host $HOSTS --target $HOSTS"}, {"sha": "d591fb28f36edcd9e0260471764dfc9d7cbac523", "filename": "src/ci/docker/dist-i686-linux/Dockerfile", "status": "modified", "additions": 35, "deletions": 19, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fci%2Fdocker%2Fdist-i686-linux%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fci%2Fdocker%2Fdist-i686-linux%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-i686-linux%2FDockerfile?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd", "patch": "@@ -29,13 +29,13 @@ ENV PATH=/rustroot/bin:$PATH\n ENV LD_LIBRARY_PATH=/rustroot/lib64:/rustroot/lib\n ENV PKG_CONFIG_PATH=/rustroot/lib/pkgconfig\n WORKDIR /tmp\n-COPY dist-i686-linux/shared.sh dist-i686-linux/build-binutils.sh /tmp/\n+COPY dist-x86_64-linux/shared.sh /tmp/\n \n # We need a build of openssl which supports SNI to download artifacts from\n # static.rust-lang.org. This'll be used to link into libcurl below (and used\n # later as well), so build a copy of OpenSSL with dynamic libraries into our\n # generic root.\n-COPY dist-i686-linux/build-openssl.sh /tmp/\n+COPY dist-x86_64-linux/build-openssl.sh /tmp/\n RUN ./build-openssl.sh\n \n # The `curl` binary on CentOS doesn't support SNI which is needed for fetching\n@@ -44,36 +44,43 @@ RUN ./build-openssl.sh\n #\n # Note that we also disable a bunch of optional features of curl that we don't\n # really need.\n-COPY dist-i686-linux/build-curl.sh /tmp/\n+COPY dist-x86_64-linux/build-curl.sh /tmp/\n RUN ./build-curl.sh\n \n # binutils < 2.22 has a bug where the 32-bit executables it generates\n # immediately segfault in Rust, so we need to install our own binutils.\n #\n # See https://github.com/rust-lang/rust/issues/20440 for more info\n+COPY dist-x86_64-linux/build-binutils.sh /tmp/\n RUN ./build-binutils.sh\n \n+# libssh2 (a dependency of Cargo) requires cmake 2.8.11 or higher but CentOS\n+# only has 2.6.4, so build our own\n+COPY dist-x86_64-linux/build-cmake.sh /tmp/\n+RUN ./build-cmake.sh\n+\n # Need a newer version of gcc than centos has to compile LLVM nowadays\n-COPY dist-i686-linux/build-gcc.sh /tmp/\n+COPY dist-x86_64-linux/build-gcc.sh /tmp/\n RUN ./build-gcc.sh\n \n # CentOS 5.5 has Python 2.4 by default, but LLVM needs 2.7+\n-COPY dist-i686-linux/build-python.sh /tmp/\n+COPY dist-x86_64-linux/build-python.sh /tmp/\n RUN ./build-python.sh\n \n+# Now build LLVM+Clang 6, afterwards configuring further compilations to use the\n+# clang/clang++ compilers.\n+COPY dist-x86_64-linux/build-clang.sh /tmp/\n+RUN ./build-clang.sh\n+ENV CC=clang CXX=clang++\n+\n # Apparently CentOS 5.5 desn't have `git` in yum, but we're gonna need it for\n # cloning, so download and build it here.\n-COPY dist-i686-linux/build-git.sh /tmp/\n+COPY dist-x86_64-linux/build-git.sh /tmp/\n RUN ./build-git.sh\n \n-# libssh2 (a dependency of Cargo) requires cmake 2.8.11 or higher but CentOS\n-# only has 2.6.4, so build our own\n-COPY dist-i686-linux/build-cmake.sh /tmp/\n-RUN ./build-cmake.sh\n-\n # for sanitizers, we need kernel headers files newer than the ones CentOS ships\n # with so we install newer ones here\n-COPY dist-i686-linux/build-headers.sh /tmp/\n+COPY dist-x86_64-linux/build-headers.sh /tmp/\n RUN ./build-headers.sh\n \n COPY scripts/sccache.sh /scripts/\n@@ -82,14 +89,23 @@ RUN sh /scripts/sccache.sh\n ENV HOSTS=i686-unknown-linux-gnu\n \n ENV RUST_CONFIGURE_ARGS \\\n-      --host=$HOSTS \\\n-      --enable-extended \\\n+      --enable-full-tools \\\n       --enable-sanitizers \\\n-      --enable-profiler\n-ENV SCRIPT python2.7 ../x.py dist --host $HOSTS --target $HOSTS\n-\n-# This is the only builder which will create source tarballs\n-ENV DIST_SRC 1\n+      --enable-profiler \\\n+      --set target.i686-unknown-linux-gnu.linker=clang \\\n+      --build=i686-unknown-linux-gnu\n+ENV SCRIPT python2.7 ../x.py dist --build $HOSTS --host $HOSTS --target $HOSTS\n+ENV CARGO_TARGET_I686_UNKNOWN_LINUX_GNU_LINKER=clang\n+\n+# This was added when we switched from gcc to clang. It's not clear why this is\n+# needed unfortunately, but without this the stage1 bootstrap segfaults\n+# somewhere inside of a build script. The build ends up just hanging instead of\n+# actually killing the process that segfaulted, but if the process is run\n+# manually in a debugger the segfault is immediately seen as well as the\n+# misaligned stack access.\n+#\n+# Added in #50200 there's some more logs there\n+ENV CFLAGS -mstackrealign\n \n # When we build cargo in this container, we don't want it to use the system\n # libcurl, instead it should compile its own."}, {"sha": "f4bdbd80d0edb761dc08e34286e0c76a1ef4a0a0", "filename": "src/ci/docker/dist-i686-linux/build-binutils.sh", "status": "removed", "additions": 0, "deletions": 26, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/ac64ef33756d05557153e00211cdf8fcf65d4be3/src%2Fci%2Fdocker%2Fdist-i686-linux%2Fbuild-binutils.sh", "raw_url": "https://github.com/rust-lang/rust/raw/ac64ef33756d05557153e00211cdf8fcf65d4be3/src%2Fci%2Fdocker%2Fdist-i686-linux%2Fbuild-binutils.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-i686-linux%2Fbuild-binutils.sh?ref=ac64ef33756d05557153e00211cdf8fcf65d4be3", "patch": "@@ -1,26 +0,0 @@\n-#!/usr/bin/env bash\n-# Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n-# file at the top-level directory of this distribution and at\n-# http://rust-lang.org/COPYRIGHT.\n-#\n-# Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-# http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-# <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-# option. This file may not be copied, modified, or distributed\n-# except according to those terms.\n-\n-set -ex\n-\n-source shared.sh\n-\n-curl https://ftp.gnu.org/gnu/binutils/binutils-2.25.1.tar.bz2 | tar xfj -\n-\n-mkdir binutils-build\n-cd binutils-build\n-hide_output ../binutils-2.25.1/configure --prefix=/rustroot\n-hide_output make -j10\n-hide_output make install\n-\n-cd ..\n-rm -rf binutils-build\n-rm -rf binutils-2.25.1"}, {"sha": "9a3763d421ad2b721d773494cc11fc2d7ffbec28", "filename": "src/ci/docker/dist-i686-linux/build-cmake.sh", "status": "removed", "additions": 0, "deletions": 25, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/ac64ef33756d05557153e00211cdf8fcf65d4be3/src%2Fci%2Fdocker%2Fdist-i686-linux%2Fbuild-cmake.sh", "raw_url": "https://github.com/rust-lang/rust/raw/ac64ef33756d05557153e00211cdf8fcf65d4be3/src%2Fci%2Fdocker%2Fdist-i686-linux%2Fbuild-cmake.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-i686-linux%2Fbuild-cmake.sh?ref=ac64ef33756d05557153e00211cdf8fcf65d4be3", "patch": "@@ -1,25 +0,0 @@\n-#!/usr/bin/env bash\n-# Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n-# file at the top-level directory of this distribution and at\n-# http://rust-lang.org/COPYRIGHT.\n-#\n-# Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-# http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-# <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-# option. This file may not be copied, modified, or distributed\n-# except according to those terms.\n-\n-set -ex\n-source shared.sh\n-\n-curl https://cmake.org/files/v3.6/cmake-3.6.3.tar.gz | tar xzf -\n-\n-mkdir cmake-build\n-cd cmake-build\n-hide_output ../cmake-3.6.3/configure --prefix=/rustroot\n-hide_output make -j10\n-hide_output make install\n-\n-cd ..\n-rm -rf cmake-build\n-rm -rf cmake-3.6.3"}, {"sha": "edf3175b81c436321f510ec99b560f627d93a677", "filename": "src/ci/docker/dist-i686-linux/build-curl.sh", "status": "removed", "additions": 0, "deletions": 43, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/ac64ef33756d05557153e00211cdf8fcf65d4be3/src%2Fci%2Fdocker%2Fdist-i686-linux%2Fbuild-curl.sh", "raw_url": "https://github.com/rust-lang/rust/raw/ac64ef33756d05557153e00211cdf8fcf65d4be3/src%2Fci%2Fdocker%2Fdist-i686-linux%2Fbuild-curl.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-i686-linux%2Fbuild-curl.sh?ref=ac64ef33756d05557153e00211cdf8fcf65d4be3", "patch": "@@ -1,43 +0,0 @@\n-#!/usr/bin/env bash\n-# Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n-# file at the top-level directory of this distribution and at\n-# http://rust-lang.org/COPYRIGHT.\n-#\n-# Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-# http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-# <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-# option. This file may not be copied, modified, or distributed\n-# except according to those terms.\n-\n-set -ex\n-source shared.sh\n-\n-VERSION=7.51.0\n-\n-curl http://cool.haxx.se/download/curl-$VERSION.tar.bz2 | tar xjf -\n-\n-mkdir curl-build\n-cd curl-build\n-hide_output ../curl-$VERSION/configure \\\n-      --prefix=/rustroot \\\n-      --with-ssl=/rustroot \\\n-      --disable-sspi \\\n-      --disable-gopher \\\n-      --disable-smtp \\\n-      --disable-smb \\\n-      --disable-imap \\\n-      --disable-pop3 \\\n-      --disable-tftp \\\n-      --disable-telnet \\\n-      --disable-manual \\\n-      --disable-dict \\\n-      --disable-rtsp \\\n-      --disable-ldaps \\\n-      --disable-ldap\n-hide_output make -j10\n-hide_output make install\n-\n-cd ..\n-rm -rf curl-build\n-rm -rf curl-$VERSION\n-yum erase -y curl"}, {"sha": "6b991bb59e4b0dcc5fd9018b51e70960afe9a6c9", "filename": "src/ci/docker/dist-i686-linux/build-gcc.sh", "status": "removed", "additions": 0, "deletions": 33, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/ac64ef33756d05557153e00211cdf8fcf65d4be3/src%2Fci%2Fdocker%2Fdist-i686-linux%2Fbuild-gcc.sh", "raw_url": "https://github.com/rust-lang/rust/raw/ac64ef33756d05557153e00211cdf8fcf65d4be3/src%2Fci%2Fdocker%2Fdist-i686-linux%2Fbuild-gcc.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-i686-linux%2Fbuild-gcc.sh?ref=ac64ef33756d05557153e00211cdf8fcf65d4be3", "patch": "@@ -1,33 +0,0 @@\n-#!/usr/bin/env bash\n-# Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n-# file at the top-level directory of this distribution and at\n-# http://rust-lang.org/COPYRIGHT.\n-#\n-# Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-# http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-# <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-# option. This file may not be copied, modified, or distributed\n-# except according to those terms.\n-\n-set -ex\n-\n-source shared.sh\n-\n-GCC=4.8.5\n-\n-curl https://ftp.gnu.org/gnu/gcc/gcc-$GCC/gcc-$GCC.tar.bz2 | tar xjf -\n-cd gcc-$GCC\n-./contrib/download_prerequisites\n-mkdir ../gcc-build\n-cd ../gcc-build\n-hide_output ../gcc-$GCC/configure \\\n-    --prefix=/rustroot \\\n-    --enable-languages=c,c++\n-hide_output make -j10\n-hide_output make install\n-ln -nsf gcc /rustroot/bin/cc\n-\n-cd ..\n-rm -rf gcc-build\n-rm -rf gcc-$GCC\n-yum erase -y gcc gcc-c++ binutils"}, {"sha": "ff62a68629a8bfdb79bee9d727f35c6066030434", "filename": "src/ci/docker/dist-i686-linux/build-git.sh", "status": "removed", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/ac64ef33756d05557153e00211cdf8fcf65d4be3/src%2Fci%2Fdocker%2Fdist-i686-linux%2Fbuild-git.sh", "raw_url": "https://github.com/rust-lang/rust/raw/ac64ef33756d05557153e00211cdf8fcf65d4be3/src%2Fci%2Fdocker%2Fdist-i686-linux%2Fbuild-git.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-i686-linux%2Fbuild-git.sh?ref=ac64ef33756d05557153e00211cdf8fcf65d4be3", "patch": "@@ -1,24 +0,0 @@\n-#!/usr/bin/env bash\n-# Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n-# file at the top-level directory of this distribution and at\n-# http://rust-lang.org/COPYRIGHT.\n-#\n-# Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-# http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-# <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-# option. This file may not be copied, modified, or distributed\n-# except according to those terms.\n-\n-set -ex\n-source shared.sh\n-\n-curl https://www.kernel.org/pub/software/scm/git/git-2.10.0.tar.gz | tar xzf -\n-\n-cd git-2.10.0\n-make configure\n-hide_output ./configure --prefix=/rustroot\n-hide_output make -j10\n-hide_output make install\n-\n-cd ..\n-rm -rf git-2.10.0"}, {"sha": "2f15114d6f98028857bbeef289cedc70d1c887e0", "filename": "src/ci/docker/dist-i686-linux/build-headers.sh", "status": "removed", "additions": 0, "deletions": 25, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/ac64ef33756d05557153e00211cdf8fcf65d4be3/src%2Fci%2Fdocker%2Fdist-i686-linux%2Fbuild-headers.sh", "raw_url": "https://github.com/rust-lang/rust/raw/ac64ef33756d05557153e00211cdf8fcf65d4be3/src%2Fci%2Fdocker%2Fdist-i686-linux%2Fbuild-headers.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-i686-linux%2Fbuild-headers.sh?ref=ac64ef33756d05557153e00211cdf8fcf65d4be3", "patch": "@@ -1,25 +0,0 @@\n-#!/usr/bin/env bash\n-# Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n-# file at the top-level directory of this distribution and at\n-# http://rust-lang.org/COPYRIGHT.\n-#\n-# Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-# http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-# <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-# option. This file may not be copied, modified, or distributed\n-# except according to those terms.\n-\n-set -ex\n-source shared.sh\n-\n-curl https://cdn.kernel.org/pub/linux/kernel/v3.x/linux-3.2.84.tar.xz | unxz | tar x\n-\n-cd linux-3.2.84\n-hide_output make mrproper\n-hide_output make INSTALL_HDR_PATH=dest headers_install\n-\n-find dest/include \\( -name .install -o -name ..install.cmd \\) -delete\n-yes | cp -fr dest/include/* /usr/include\n-\n-cd ..\n-rm -rf linux-3.2.84"}, {"sha": "e7226ace020bd8bc8dc35b11e1e07b3ab9b66a53", "filename": "src/ci/docker/dist-i686-linux/build-openssl.sh", "status": "removed", "additions": 0, "deletions": 28, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/ac64ef33756d05557153e00211cdf8fcf65d4be3/src%2Fci%2Fdocker%2Fdist-i686-linux%2Fbuild-openssl.sh", "raw_url": "https://github.com/rust-lang/rust/raw/ac64ef33756d05557153e00211cdf8fcf65d4be3/src%2Fci%2Fdocker%2Fdist-i686-linux%2Fbuild-openssl.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-i686-linux%2Fbuild-openssl.sh?ref=ac64ef33756d05557153e00211cdf8fcf65d4be3", "patch": "@@ -1,28 +0,0 @@\n-#!/usr/bin/env bash\n-# Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n-# file at the top-level directory of this distribution and at\n-# http://rust-lang.org/COPYRIGHT.\n-#\n-# Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-# http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-# <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-# option. This file may not be copied, modified, or distributed\n-# except according to those terms.\n-\n-set -ex\n-source shared.sh\n-\n-VERSION=1.0.2k\n-URL=https://s3-us-west-1.amazonaws.com/rust-lang-ci2/rust-ci-mirror/openssl-$VERSION.tar.gz\n-\n-curl $URL | tar xzf -\n-\n-cd openssl-$VERSION\n-hide_output ./config --prefix=/rustroot shared -fPIC\n-hide_output make -j10\n-hide_output make install\n-cd ..\n-rm -rf openssl-$VERSION\n-\n-# Make the system cert collection available to the new install.\n-ln -nsf /etc/pki/tls/cert.pem /rustroot/ssl/"}, {"sha": "c6b8cdde4b9af4d57737dd910efe1ebb67c4425e", "filename": "src/ci/docker/dist-i686-linux/build-python.sh", "status": "removed", "additions": 0, "deletions": 30, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/ac64ef33756d05557153e00211cdf8fcf65d4be3/src%2Fci%2Fdocker%2Fdist-i686-linux%2Fbuild-python.sh", "raw_url": "https://github.com/rust-lang/rust/raw/ac64ef33756d05557153e00211cdf8fcf65d4be3/src%2Fci%2Fdocker%2Fdist-i686-linux%2Fbuild-python.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-i686-linux%2Fbuild-python.sh?ref=ac64ef33756d05557153e00211cdf8fcf65d4be3", "patch": "@@ -1,30 +0,0 @@\n-#!/usr/bin/env bash\n-# Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n-# file at the top-level directory of this distribution and at\n-# http://rust-lang.org/COPYRIGHT.\n-#\n-# Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-# http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-# <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-# option. This file may not be copied, modified, or distributed\n-# except according to those terms.\n-\n-set -ex\n-source shared.sh\n-\n-curl https://www.python.org/ftp/python/2.7.12/Python-2.7.12.tgz | \\\n-  tar xzf -\n-\n-mkdir python-build\n-cd python-build\n-\n-# Gotta do some hackery to tell python about our custom OpenSSL build, but other\n-# than that fairly normal.\n-CFLAGS='-I /rustroot/include' LDFLAGS='-L /rustroot/lib -L /rustroot/lib64' \\\n-    hide_output ../Python-2.7.12/configure --prefix=/rustroot\n-hide_output make -j10\n-hide_output make install\n-\n-cd ..\n-rm -rf python-build\n-rm -rf Python-2.7.12"}, {"sha": "97e6d2908cf8a5ae3174e1bc08a17ea27fa3aae5", "filename": "src/ci/docker/dist-i686-linux/shared.sh", "status": "removed", "additions": 0, "deletions": 25, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/ac64ef33756d05557153e00211cdf8fcf65d4be3/src%2Fci%2Fdocker%2Fdist-i686-linux%2Fshared.sh", "raw_url": "https://github.com/rust-lang/rust/raw/ac64ef33756d05557153e00211cdf8fcf65d4be3/src%2Fci%2Fdocker%2Fdist-i686-linux%2Fshared.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-i686-linux%2Fshared.sh?ref=ac64ef33756d05557153e00211cdf8fcf65d4be3", "patch": "@@ -1,25 +0,0 @@\n-# Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n-# file at the top-level directory of this distribution and at\n-# http://rust-lang.org/COPYRIGHT.\n-#\n-# Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-# http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-# <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-# option. This file may not be copied, modified, or distributed\n-# except according to those terms.\n-\n-hide_output() {\n-  set +x\n-  on_err=\"\n-echo ERROR: An error was encountered with the build.\n-cat /tmp/build.log\n-exit 1\n-\"\n-  trap \"$on_err\" ERR\n-  bash -c \"while true; do sleep 30; echo \\$(date) - building ...; done\" &\n-  PING_LOOP_PID=$!\n-  $@ &> /tmp/build.log\n-  trap - ERR\n-  kill $PING_LOOP_PID\n-  set -x\n-}"}, {"sha": "466def1f80fbfd9cbdbf6d86d5e4d98630f1bd1e", "filename": "src/ci/docker/dist-mips-linux/Dockerfile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fci%2Fdocker%2Fdist-mips-linux%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fci%2Fdocker%2Fdist-mips-linux%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-mips-linux%2FDockerfile?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd", "patch": "@@ -22,5 +22,5 @@ RUN sh /scripts/sccache.sh\n \n ENV HOSTS=mips-unknown-linux-gnu\n \n-ENV RUST_CONFIGURE_ARGS --host=$HOSTS --enable-extended\n+ENV RUST_CONFIGURE_ARGS --enable-extended --disable-docs\n ENV SCRIPT python2.7 ../x.py dist --host $HOSTS --target $HOSTS"}, {"sha": "2205b733e99f1e5826fa92656fa68a94c509e30e", "filename": "src/ci/docker/dist-mips64-linux/Dockerfile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fci%2Fdocker%2Fdist-mips64-linux%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fci%2Fdocker%2Fdist-mips64-linux%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-mips64-linux%2FDockerfile?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd", "patch": "@@ -21,5 +21,5 @@ RUN sh /scripts/sccache.sh\n \n ENV HOSTS=mips64-unknown-linux-gnuabi64\n \n-ENV RUST_CONFIGURE_ARGS --host=$HOSTS --enable-extended\n+ENV RUST_CONFIGURE_ARGS --enable-extended --disable-docs\n ENV SCRIPT python2.7 ../x.py dist --host $HOSTS --target $HOSTS"}, {"sha": "f1d9dad46ea3f6dd58be2443f5caef48940cd3f6", "filename": "src/ci/docker/dist-mips64el-linux/Dockerfile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fci%2Fdocker%2Fdist-mips64el-linux%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fci%2Fdocker%2Fdist-mips64el-linux%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-mips64el-linux%2FDockerfile?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd", "patch": "@@ -22,5 +22,5 @@ RUN sh /scripts/sccache.sh\n \n ENV HOSTS=mips64el-unknown-linux-gnuabi64\n \n-ENV RUST_CONFIGURE_ARGS --host=$HOSTS --enable-extended\n+ENV RUST_CONFIGURE_ARGS --enable-extended --disable-docs\n ENV SCRIPT python2.7 ../x.py dist --host $HOSTS --target $HOSTS"}, {"sha": "ee73e29c76e35926ee5389ecf998f47a29ce4c1a", "filename": "src/ci/docker/dist-mipsel-linux/Dockerfile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fci%2Fdocker%2Fdist-mipsel-linux%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fci%2Fdocker%2Fdist-mipsel-linux%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-mipsel-linux%2FDockerfile?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd", "patch": "@@ -21,5 +21,5 @@ RUN sh /scripts/sccache.sh\n \n ENV HOSTS=mipsel-unknown-linux-gnu\n \n-ENV RUST_CONFIGURE_ARGS --host=$HOSTS --enable-extended\n+ENV RUST_CONFIGURE_ARGS --enable-extended --disable-docs\n ENV SCRIPT python2.7 ../x.py dist --host $HOSTS --target $HOSTS"}, {"sha": "f03aff060c1034065c5361930ac2fdf917129320", "filename": "src/ci/docker/dist-powerpc-linux/Dockerfile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fci%2Fdocker%2Fdist-powerpc-linux%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fci%2Fdocker%2Fdist-powerpc-linux%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-powerpc-linux%2FDockerfile?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd", "patch": "@@ -34,7 +34,7 @@ ENV \\\n \n ENV HOSTS=powerpc-unknown-linux-gnu\n \n-ENV RUST_CONFIGURE_ARGS --host=$HOSTS --enable-extended\n+ENV RUST_CONFIGURE_ARGS --enable-extended --disable-docs\n ENV SCRIPT python2.7 ../x.py dist --host $HOSTS --target $HOSTS\n \n # FIXME(#36150) this will fail the bootstrap. Probably means something bad is"}, {"sha": "bb30210c0563aa5433672b744fab108100aa4f1f", "filename": "src/ci/docker/dist-powerpc64-linux/Dockerfile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fci%2Fdocker%2Fdist-powerpc64-linux%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fci%2Fdocker%2Fdist-powerpc64-linux%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-powerpc64-linux%2FDockerfile?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd", "patch": "@@ -35,5 +35,5 @@ ENV \\\n \n ENV HOSTS=powerpc64-unknown-linux-gnu\n \n-ENV RUST_CONFIGURE_ARGS --host=$HOSTS --enable-extended\n+ENV RUST_CONFIGURE_ARGS --enable-extended --disable-docs\n ENV SCRIPT python2.7 ../x.py dist --host $HOSTS --target $HOSTS"}, {"sha": "ee9e4550483525ada46d587e492b623b07129d6b", "filename": "src/ci/docker/dist-powerpc64le-linux/Dockerfile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fci%2Fdocker%2Fdist-powerpc64le-linux%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fci%2Fdocker%2Fdist-powerpc64le-linux%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-powerpc64le-linux%2FDockerfile?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd", "patch": "@@ -32,5 +32,5 @@ ENV \\\n \n ENV HOSTS=powerpc64le-unknown-linux-gnu\n \n-ENV RUST_CONFIGURE_ARGS --host=$HOSTS --enable-extended\n+ENV RUST_CONFIGURE_ARGS --enable-extended --disable-docs\n ENV SCRIPT python2.7 ../x.py dist --host $HOSTS --target $HOSTS"}, {"sha": "7ba6fe643c2ae80b9f59bdcdf4197db18fa3c736", "filename": "src/ci/docker/dist-s390x-linux/Dockerfile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fci%2Fdocker%2Fdist-s390x-linux%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fci%2Fdocker%2Fdist-s390x-linux%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-s390x-linux%2FDockerfile?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd", "patch": "@@ -34,5 +34,5 @@ ENV \\\n \n ENV HOSTS=s390x-unknown-linux-gnu\n \n-ENV RUST_CONFIGURE_ARGS --host=$HOSTS --enable-extended\n+ENV RUST_CONFIGURE_ARGS --enable-extended --disable-docs\n ENV SCRIPT python2.7 ../x.py dist --host $HOSTS --target $HOSTS"}, {"sha": "bfc5e712f76c3aa1802e5a66fe45472454728b9b", "filename": "src/ci/docker/dist-various-1/Dockerfile", "status": "modified", "additions": 52, "deletions": 17, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fci%2Fdocker%2Fdist-various-1%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fci%2Fdocker%2Fdist-various-1%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-various-1%2FDockerfile?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd", "patch": "@@ -20,7 +20,9 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n   bzip2 \\\n   patch \\\n   libssl-dev \\\n-  pkg-config\n+  pkg-config \\\n+  gcc-arm-none-eabi \\\n+  libnewlib-arm-none-eabi\n \n WORKDIR /build\n \n@@ -30,8 +32,21 @@ RUN ./build-rumprun.sh\n COPY dist-various-1/install-x86_64-redox.sh /build\n RUN ./install-x86_64-redox.sh\n \n+COPY dist-various-1/install-mips-musl.sh /build\n+RUN ./install-mips-musl.sh\n+\n+COPY dist-various-1/install-mipsel-musl.sh /build\n+RUN ./install-mipsel-musl.sh\n+\n+# Suppress some warnings in the openwrt toolchains we downloaded\n+ENV STAGING_DIR=/tmp\n+\n COPY scripts/musl.sh /build\n RUN env \\\n+    CC=arm-linux-gnueabi-gcc CFLAGS=\"-march=armv5te -marm -mfloat-abi=soft\" \\\n+    CXX=arm-linux-gnueabi-g++ CXXFLAGS=\"-march=armv5te -marm -mfloat-abi=soft\" \\\n+    bash musl.sh armv5te && \\\n+    env \\\n     CC=arm-linux-gnueabi-gcc CFLAGS=\"-march=armv6 -marm\" \\\n     CXX=arm-linux-gnueabi-g++ CXXFLAGS=\"-march=armv6 -marm\" \\\n     bash musl.sh arm && \\\n@@ -47,13 +62,28 @@ RUN env \\\n     CC=aarch64-linux-gnu-gcc \\\n     CXX=aarch64-linux-gnu-g++ \\\n     bash musl.sh aarch64 && \\\n+    env \\\n+    CC=mips-openwrt-linux-gcc \\\n+    CXX=mips-openwrt-linux-g++ \\\n+    bash musl.sh mips && \\\n+    env \\\n+    CC=mipsel-openwrt-linux-gcc \\\n+    CXX=mipsel-openwrt-linux-g++ \\\n+    bash musl.sh mipsel && \\\n     rm -rf /build/*\n \n-COPY dist-various-1/install-mips-musl.sh /build\n-RUN ./install-mips-musl.sh\n+# FIXME(mozilla/sccache#235) this shouldn't be necessary but is currently\n+# necessary to disambiguate the mips compiler with the mipsel compiler. We want\n+# to give these two wrapper scripts (currently identical ones) different hashes\n+# to ensure that sccache understands that they're different compilers.\n+RUN \\\n+  echo \"# a\" >> /usr/local/mips-linux-musl/bin/mips-openwrt-linux-musl-wrapper.sh && \\\n+  echo \"# b\" >> /usr/local/mipsel-linux-musl/bin/mipsel-openwrt-linux-musl-wrapper.sh\n \n-COPY dist-various-1/install-mipsel-musl.sh /build\n-RUN ./install-mipsel-musl.sh\n+ENV RUN_MAKE_TARGETS=thumbv6m-none-eabi\n+ENV RUN_MAKE_TARGETS=$RUN_MAKE_TARGETS,thumbv7m-none-eabi\n+ENV RUN_MAKE_TARGETS=$RUN_MAKE_TARGETS,thumbv7em-none-eabi\n+ENV RUN_MAKE_TARGETS=$RUN_MAKE_TARGETS,thumbv7em-none-eabihf\n \n ENV TARGETS=asmjs-unknown-emscripten\n ENV TARGETS=$TARGETS,wasm32-unknown-emscripten\n@@ -63,31 +93,36 @@ ENV TARGETS=$TARGETS,mipsel-unknown-linux-musl\n ENV TARGETS=$TARGETS,arm-unknown-linux-musleabi\n ENV TARGETS=$TARGETS,arm-unknown-linux-musleabihf\n ENV TARGETS=$TARGETS,armv5te-unknown-linux-gnueabi\n+ENV TARGETS=$TARGETS,armv5te-unknown-linux-musleabi\n ENV TARGETS=$TARGETS,armv7-unknown-linux-musleabihf\n ENV TARGETS=$TARGETS,aarch64-unknown-linux-musl\n ENV TARGETS=$TARGETS,sparc64-unknown-linux-gnu\n ENV TARGETS=$TARGETS,x86_64-unknown-redox\n+ENV TARGETS=$TARGETS,thumbv6m-none-eabi\n+ENV TARGETS=$TARGETS,thumbv7m-none-eabi\n+ENV TARGETS=$TARGETS,thumbv7em-none-eabi\n+ENV TARGETS=$TARGETS,thumbv7em-none-eabihf\n+ENV TARGETS=$TARGETS,riscv32imac-unknown-none-elf\n \n-# FIXME: remove armv5te vars after https://github.com/alexcrichton/cc-rs/issues/271\n-#        get fixed and cc update\n ENV CC_mipsel_unknown_linux_musl=mipsel-openwrt-linux-gcc \\\n     CC_mips_unknown_linux_musl=mips-openwrt-linux-gcc \\\n     CC_sparc64_unknown_linux_gnu=sparc64-linux-gnu-gcc \\\n-    CC_x86_64_unknown_redox=x86_64-unknown-redox-gcc \\\n-    CC_armv5te_unknown_linux_gnueabi=arm-linux-gnueabi-gcc \\\n-    CFLAGS_armv5te_unknown_linux_gnueabi=\"-march=armv5te -marm -mfloat-abi=soft\"\n-\n-# Suppress some warnings in the openwrt toolchains we downloaded\n-ENV STAGING_DIR=/tmp\n+    CC_x86_64_unknown_redox=x86_64-unknown-redox-gcc\n \n ENV RUST_CONFIGURE_ARGS \\\n-      --enable-extended \\\n-      --target=$TARGETS \\\n+      --musl-root-armv5te=/musl-armv5te \\\n       --musl-root-arm=/musl-arm \\\n       --musl-root-armhf=/musl-armhf \\\n       --musl-root-armv7=/musl-armv7 \\\n-      --musl-root-aarch64=/musl-aarch64\n-ENV SCRIPT python2.7 ../x.py dist --target $TARGETS\n+      --musl-root-aarch64=/musl-aarch64 \\\n+      --musl-root-mips=/musl-mips \\\n+      --musl-root-mipsel=/musl-mipsel \\\n+      --enable-emscripten \\\n+      --disable-docs\n+\n+ENV SCRIPT \\ \n+      python2.7 ../x.py test --target $RUN_MAKE_TARGETS src/test/run-make && \\\n+      python2.7 ../x.py dist --target $TARGETS\n \n # sccache\n COPY scripts/sccache.sh /scripts/"}, {"sha": "7adb32efa1d414ef8daa1f1030fd7d92bcd51f24", "filename": "src/ci/docker/dist-various-2/Dockerfile", "status": "modified", "additions": 9, "deletions": 16, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fci%2Fdocker%2Fdist-various-2%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fci%2Fdocker%2Fdist-various-2%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-various-2%2FDockerfile?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd", "patch": "@@ -34,33 +34,26 @@ COPY scripts/sccache.sh /scripts/\n RUN sh /scripts/sccache.sh\n \n ENV \\\n-    AR_x86_64_unknown_fuchsia=x86_64-unknown-fuchsia-ar \\\n-    CC_x86_64_unknown_fuchsia=x86_64-unknown-fuchsia-clang \\\n-    CXX_x86_64_unknown_fuchsia=x86_64-unknown-fuchsia-clang++ \\\n-    AR_aarch64_unknown_fuchsia=aarch64-unknown-fuchsia-ar \\\n-    CC_aarch64_unknown_fuchsia=aarch64-unknown-fuchsia-clang \\\n-    CXX_aarch64_unknown_fuchsia=aarch64-unknown-fuchsia-clang++ \\\n+    AR_x86_64_fuchsia=x86_64-fuchsia-ar \\\n+    CC_x86_64_fuchsia=x86_64-fuchsia-clang \\\n+    CXX_x86_64_fuchsia=x86_64-fuchsia-clang++ \\\n+    AR_aarch64_fuchsia=aarch64-fuchsia-ar \\\n+    CC_aarch64_fuchsia=aarch64-fuchsia-clang \\\n+    CXX_aarch64_fuchsia=aarch64-fuchsia-clang++ \\\n     AR_sparcv9_sun_solaris=sparcv9-sun-solaris2.10-ar \\\n     CC_sparcv9_sun_solaris=sparcv9-sun-solaris2.10-gcc \\\n     CXX_sparcv9_sun_solaris=sparcv9-sun-solaris2.10-g++ \\\n     AR_x86_64_sun_solaris=x86_64-sun-solaris2.10-ar \\\n     CC_x86_64_sun_solaris=x86_64-sun-solaris2.10-gcc \\\n     CXX_x86_64_sun_solaris=x86_64-sun-solaris2.10-g++\n \n-# FIXME(EdSchouten): Remove this once cc \u22651.0.4 has been merged. It can\n-# automatically pick the right compiler path.\n-ENV \\\n-    AR_x86_64_unknown_cloudabi=x86_64-unknown-cloudabi-ar \\\n-    CC_x86_64_unknown_cloudabi=x86_64-unknown-cloudabi-clang \\\n-    CXX_x86_64_unknown_cloudabi=x86_64-unknown-cloudabi-clang++\n-\n-ENV TARGETS=x86_64-unknown-fuchsia\n-ENV TARGETS=$TARGETS,aarch64-unknown-fuchsia\n+ENV TARGETS=x86_64-fuchsia\n+ENV TARGETS=$TARGETS,aarch64-fuchsia\n ENV TARGETS=$TARGETS,sparcv9-sun-solaris\n ENV TARGETS=$TARGETS,wasm32-unknown-unknown\n ENV TARGETS=$TARGETS,x86_64-sun-solaris\n ENV TARGETS=$TARGETS,x86_64-unknown-linux-gnux32\n ENV TARGETS=$TARGETS,x86_64-unknown-cloudabi\n \n-ENV RUST_CONFIGURE_ARGS --target=$TARGETS --enable-extended\n+ENV RUST_CONFIGURE_ARGS --enable-extended --disable-docs\n ENV SCRIPT python2.7 ../x.py dist --target $TARGETS"}, {"sha": "8c04d849e8d0a9d5f800c4c8878ed2cde026d22e", "filename": "src/ci/docker/dist-various-2/build-cloudabi-toolchain.sh", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fci%2Fdocker%2Fdist-various-2%2Fbuild-cloudabi-toolchain.sh", "raw_url": "https://github.com/rust-lang/rust/raw/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fci%2Fdocker%2Fdist-various-2%2Fbuild-cloudabi-toolchain.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-various-2%2Fbuild-cloudabi-toolchain.sh?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd", "patch": "@@ -40,12 +40,6 @@ ln -s ../lib/llvm-5.0/bin/clang /usr/bin/${target}-c++\n ln -s ../lib/llvm-5.0/bin/lld /usr/bin/${target}-ld\n ln -s ../../${target} /usr/lib/llvm-5.0/${target}\n \n-# FIXME(EdSchouten): Remove this once cc \u22651.0.4 has been merged. It\n-# can make use of ${target}-cc and ${target}-c++, without incorrectly\n-# assuming it's MSVC.\n-ln -s ../lib/llvm-5.0/bin/clang /usr/bin/${target}-clang\n-ln -s ../lib/llvm-5.0/bin/clang /usr/bin/${target}-clang++\n-\n # Install the C++ runtime libraries from CloudABI Ports.\n echo deb https://nuxi.nl/distfiles/cloudabi-ports/debian/ cloudabi cloudabi > \\\n     /etc/apt/sources.list.d/cloudabi.list"}, {"sha": "ec19f7c4f45d972aaa5dac84c5f11da455ad7c17", "filename": "src/ci/docker/dist-various-2/build-fuchsia-toolchain.sh", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fci%2Fdocker%2Fdist-various-2%2Fbuild-fuchsia-toolchain.sh", "raw_url": "https://github.com/rust-lang/rust/raw/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fci%2Fdocker%2Fdist-various-2%2Fbuild-fuchsia-toolchain.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-various-2%2Fbuild-fuchsia-toolchain.sh?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd", "patch": "@@ -39,7 +39,7 @@ build() {\n   esac\n \n   hide_output make -j$(getconf _NPROCESSORS_ONLN) $tgt\n-  dst=/usr/local/${arch}-unknown-fuchsia\n+  dst=/usr/local/${arch}-fuchsia\n   mkdir -p $dst\n   cp -a build-${tgt}/sysroot/include $dst/\n   cp -a build-${tgt}/sysroot/lib $dst/\n@@ -55,11 +55,11 @@ rm -rf zircon\n \n for arch in x86_64 aarch64; do\n   for tool in clang clang++; do\n-    cat >/usr/local/bin/${arch}-unknown-fuchsia-${tool} <<EOF\n+    cat >/usr/local/bin/${arch}-fuchsia-${tool} <<EOF\n #!/bin/sh\n-${tool} --target=${arch}-unknown-fuchsia --sysroot=/usr/local/${arch}-unknown-fuchsia \"\\$@\"\n+${tool} --target=${arch}-fuchsia --sysroot=/usr/local/${arch}-fuchsia \"\\$@\"\n EOF\n-    chmod +x /usr/local/bin/${arch}-unknown-fuchsia-${tool}\n+    chmod +x /usr/local/bin/${arch}-fuchsia-${tool}\n   done\n-  ln -s /usr/local/bin/llvm-ar /usr/local/bin/${arch}-unknown-fuchsia-ar\n+  ln -s /usr/local/bin/llvm-ar /usr/local/bin/${arch}-fuchsia-ar\n done"}, {"sha": "698b81a92e935464724259a1e9b659c802351316", "filename": "src/ci/docker/dist-x86_64-freebsd/Dockerfile", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fci%2Fdocker%2Fdist-x86_64-freebsd%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fci%2Fdocker%2Fdist-x86_64-freebsd%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-x86_64-freebsd%2FDockerfile?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd", "patch": "@@ -1,4 +1,4 @@\n-FROM ubuntu:16.04\n+FROM ubuntu:18.04\n \n RUN apt-get update && apt-get install -y --no-install-recommends \\\n   clang \\\n@@ -29,5 +29,5 @@ ENV \\\n \n ENV HOSTS=x86_64-unknown-freebsd\n \n-ENV RUST_CONFIGURE_ARGS --host=$HOSTS --enable-extended\n+ENV RUST_CONFIGURE_ARGS --enable-extended --disable-docs\n ENV SCRIPT python2.7 ../x.py dist --host $HOSTS --target $HOSTS"}, {"sha": "5726fab7524ae88a55e35d27d8b1291f18fa8816", "filename": "src/ci/docker/dist-x86_64-linux/Dockerfile", "status": "modified", "additions": 19, "deletions": 10, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fci%2Fdocker%2Fdist-x86_64-linux%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fci%2Fdocker%2Fdist-x86_64-linux%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-x86_64-linux%2FDockerfile?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd", "patch": "@@ -29,7 +29,7 @@ ENV PATH=/rustroot/bin:$PATH\n ENV LD_LIBRARY_PATH=/rustroot/lib64:/rustroot/lib\n ENV PKG_CONFIG_PATH=/rustroot/lib/pkgconfig\n WORKDIR /tmp\n-COPY dist-x86_64-linux/shared.sh dist-x86_64-linux/build-binutils.sh /tmp/\n+COPY dist-x86_64-linux/shared.sh /tmp/\n \n # We need a build of openssl which supports SNI to download artifacts from\n # static.rust-lang.org. This'll be used to link into libcurl below (and used\n@@ -51,26 +51,33 @@ RUN ./build-curl.sh\n # immediately segfault in Rust, so we need to install our own binutils.\n #\n # See https://github.com/rust-lang/rust/issues/20440 for more info\n+COPY dist-x86_64-linux/build-binutils.sh /tmp/\n RUN ./build-binutils.sh\n \n-# Need a newer version of gcc than centos has to compile LLVM nowadays\n+# libssh2 (a dependency of Cargo) requires cmake 2.8.11 or higher but CentOS\n+# only has 2.6.4, so build our own\n+COPY dist-x86_64-linux/build-cmake.sh /tmp/\n+RUN ./build-cmake.sh\n+\n+# Build a version of gcc capable of building LLVM 6\n COPY dist-x86_64-linux/build-gcc.sh /tmp/\n RUN ./build-gcc.sh\n \n # CentOS 5.5 has Python 2.4 by default, but LLVM needs 2.7+\n COPY dist-x86_64-linux/build-python.sh /tmp/\n RUN ./build-python.sh\n \n+# Now build LLVM+Clang 6, afterwards configuring further compilations to use the\n+# clang/clang++ compilers.\n+COPY dist-x86_64-linux/build-clang.sh /tmp/\n+RUN ./build-clang.sh\n+ENV CC=clang CXX=clang++\n+\n # Apparently CentOS 5.5 desn't have `git` in yum, but we're gonna need it for\n # cloning, so download and build it here.\n COPY dist-x86_64-linux/build-git.sh /tmp/\n RUN ./build-git.sh\n \n-# libssh2 (a dependency of Cargo) requires cmake 2.8.11 or higher but CentOS\n-# only has 2.6.4, so build our own\n-COPY dist-x86_64-linux/build-cmake.sh /tmp/\n-RUN ./build-cmake.sh\n-\n # for sanitizers, we need kernel headers files newer than the ones CentOS ships\n # with so we install newer ones here\n COPY dist-x86_64-linux/build-headers.sh /tmp/\n@@ -82,11 +89,13 @@ RUN sh /scripts/sccache.sh\n ENV HOSTS=x86_64-unknown-linux-gnu\n \n ENV RUST_CONFIGURE_ARGS \\\n-      --host=$HOSTS \\\n-      --enable-extended \\\n+      --enable-full-tools \\\n       --enable-sanitizers \\\n-      --enable-profiler\n+      --enable-profiler \\\n+      --enable-compiler-docs \\\n+      --set target.x86_64-unknown-linux-gnu.linker=clang\n ENV SCRIPT python2.7 ../x.py dist --host $HOSTS --target $HOSTS\n+ENV CARGO_TARGET_X86_64_UNKNOWN_LINUX_GNU_LINKER=clang\n \n # This is the only builder which will create source tarballs\n ENV DIST_SRC 1"}, {"sha": "b0c27aa45bf9319d50c1574319c9d16ba0852be0", "filename": "src/ci/docker/dist-x86_64-linux/build-clang.sh", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fci%2Fdocker%2Fdist-x86_64-linux%2Fbuild-clang.sh", "raw_url": "https://github.com/rust-lang/rust/raw/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fci%2Fdocker%2Fdist-x86_64-linux%2Fbuild-clang.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-x86_64-linux%2Fbuild-clang.sh?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd", "patch": "@@ -0,0 +1,64 @@\n+#!/usr/bin/env bash\n+# Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+# file at the top-level directory of this distribution and at\n+# http://rust-lang.org/COPYRIGHT.\n+#\n+# Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+# http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+# <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+# option. This file may not be copied, modified, or distributed\n+# except according to those terms.\n+\n+set -ex\n+\n+source shared.sh\n+\n+LLVM=6.0.0\n+\n+mkdir clang\n+cd clang\n+\n+curl https://releases.llvm.org/$LLVM/llvm-$LLVM.src.tar.xz | \\\n+  xz -d | \\\n+  tar xf -\n+\n+cd llvm-$LLVM.src\n+\n+mkdir -p tools/clang\n+\n+curl https://releases.llvm.org/$LLVM/cfe-$LLVM.src.tar.xz | \\\n+  xz -d | \\\n+  tar xf - -C tools/clang --strip-components=1\n+\n+mkdir ../clang-build\n+cd ../clang-build\n+\n+# For whatever reason the default set of include paths for clang is different\n+# than that of gcc. As a result we need to manually include our sysroot's\n+# include path, /rustroot/include, to clang's default include path.\n+#\n+# Alsow there's this weird oddity with gcc where there's an 'include-fixed'\n+# directory that it generates. It turns out [1] that Centos 5's headers are so\n+# old that they're incompatible with modern C semantics. While gcc automatically\n+# fixes that clang doesn't account for this. Tell clang to manually include the\n+# fixed headers so we can successfully compile code later on.\n+#\n+# [1]: https://sourceware.org/ml/crossgcc/2008-11/msg00028.html\n+INC=\"/rustroot/include\"\n+INC=\"$INC:/rustroot/lib/gcc/x86_64-unknown-linux-gnu/4.8.5/include-fixed\"\n+INC=\"$INC:/usr/include\"\n+\n+hide_output \\\n+    cmake ../llvm-$LLVM.src \\\n+      -DCMAKE_C_COMPILER=/rustroot/bin/gcc \\\n+      -DCMAKE_CXX_COMPILER=/rustroot/bin/g++ \\\n+      -DCMAKE_BUILD_TYPE=Release \\\n+      -DCMAKE_INSTALL_PREFIX=/rustroot \\\n+      -DLLVM_TARGETS_TO_BUILD=X86 \\\n+      -DC_INCLUDE_DIRS=\"$INC\"\n+\n+hide_output make -j10\n+hide_output make install\n+\n+cd ../..\n+rm -rf clang"}, {"sha": "62ea2506f4ef81964c7e14d5f84dcc46539c1a2c", "filename": "src/ci/docker/dist-x86_64-linux/build-gcc.sh", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fci%2Fdocker%2Fdist-x86_64-linux%2Fbuild-gcc.sh", "raw_url": "https://github.com/rust-lang/rust/raw/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fci%2Fdocker%2Fdist-x86_64-linux%2Fbuild-gcc.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-x86_64-linux%2Fbuild-gcc.sh?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd", "patch": "@@ -17,6 +17,23 @@ GCC=4.8.5\n \n curl https://ftp.gnu.org/gnu/gcc/gcc-$GCC/gcc-$GCC.tar.bz2 | tar xjf -\n cd gcc-$GCC\n+\n+# FIXME(#49246): Remove the `sed` below.\n+#\n+# On 2018 March 21st, two Travis builders' cache for Docker are suddenly invalidated. Normally this\n+# is fine, because we just need to rebuild the Docker image. However, it reveals a network issue:\n+# downloading from `ftp://gcc.gnu.org/` from Travis (using passive mode) often leads to \"Connection\n+# timed out\" error, and even when the download completed, the file is usually corrupted. This causes\n+# nothing to be landed that day.\n+#\n+# We observed that the `gcc-4.8.5.tar.bz2` above can be downloaded successfully, so as a stability\n+# improvement we try to download from the HTTPS mirror instead. Turns out this uncovered the third\n+# bug: the host `gcc.gnu.org` and `cygwin.com` share the same IP, and the TLS certificate of the\n+# latter host is presented to `wget`! Therefore, we choose to download from the insecure HTTP server\n+# instead here.\n+#\n+sed -i'' 's|ftp://gcc\\.gnu\\.org/|http://gcc.gnu.org/|g' ./contrib/download_prerequisites\n+\n ./contrib/download_prerequisites\n mkdir ../gcc-build\n cd ../gcc-build\n@@ -25,7 +42,6 @@ hide_output ../gcc-$GCC/configure \\\n     --enable-languages=c,c++\n hide_output make -j10\n hide_output make install\n-ln -nsf gcc /rustroot/bin/cc\n \n cd ..\n rm -rf gcc-build"}, {"sha": "aa31f50ba0343134bfbece006ad3faf6c13afc72", "filename": "src/ci/docker/dist-x86_64-linux/build-git.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fci%2Fdocker%2Fdist-x86_64-linux%2Fbuild-git.sh", "raw_url": "https://github.com/rust-lang/rust/raw/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fci%2Fdocker%2Fdist-x86_64-linux%2Fbuild-git.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-x86_64-linux%2Fbuild-git.sh?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd", "patch": "@@ -12,7 +12,7 @@\n set -ex\n source shared.sh\n \n-curl https://www.kernel.org/pub/software/scm/git/git-2.10.0.tar.gz | tar xzf -\n+curl -L https://www.kernel.org/pub/software/scm/git/git-2.10.0.tar.gz | tar xzf -\n \n cd git-2.10.0\n make configure"}, {"sha": "06f8a2fbba836de9843927eb40b2392eb704cb0a", "filename": "src/ci/docker/dist-x86_64-musl/Dockerfile", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fci%2Fdocker%2Fdist-x86_64-musl%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fci%2Fdocker%2Fdist-x86_64-musl%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-x86_64-musl%2FDockerfile?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd", "patch": "@@ -21,7 +21,7 @@ WORKDIR /build/\n COPY scripts/musl.sh /build/\n # We need to mitigate rust-lang/rust#34978 when compiling musl itself as well\n RUN CC=gcc \\\n-    CFLAGS=\"-fPIC -Wa,-mrelax-relocations=no\" \\\n+    CFLAGS=\"-Wa,-mrelax-relocations=no\" \\\n     CXX=g++ \\\n     CXXFLAGS=\"-Wa,-mrelax-relocations=no\" \\\n     bash musl.sh x86_64 && rm -rf /build\n@@ -30,9 +30,9 @@ COPY scripts/sccache.sh /scripts/\n RUN sh /scripts/sccache.sh\n \n ENV RUST_CONFIGURE_ARGS \\\n-      --target=x86_64-unknown-linux-musl \\\n       --musl-root-x86_64=/musl-x86_64 \\\n-      --enable-extended\n+      --enable-extended \\\n+      --disable-docs\n \n # Newer binutils broke things on some vms/distros (i.e., linking against\n # unknown relocs disabled by the following flag), so we need to go out of our"}, {"sha": "a17a7ebc03dd165f92b588d2bf802d3b5d7ec754", "filename": "src/ci/docker/dist-x86_64-netbsd/Dockerfile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fci%2Fdocker%2Fdist-x86_64-netbsd%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fci%2Fdocker%2Fdist-x86_64-netbsd%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-x86_64-netbsd%2FDockerfile?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd", "patch": "@@ -33,5 +33,5 @@ ENV \\\n \n ENV HOSTS=x86_64-unknown-netbsd\n \n-ENV RUST_CONFIGURE_ARGS --host=$HOSTS --enable-extended\n+ENV RUST_CONFIGURE_ARGS --enable-extended --disable-docs\n ENV SCRIPT python2.7 ../x.py dist --host $HOSTS --target $HOSTS"}, {"sha": "e730dd86087fbd62d9b8526a4ff9251b53c89e0a", "filename": "src/ci/docker/dist-x86_64-netbsd/build-netbsd-toolchain.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fci%2Fdocker%2Fdist-x86_64-netbsd%2Fbuild-netbsd-toolchain.sh", "raw_url": "https://github.com/rust-lang/rust/raw/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fci%2Fdocker%2Fdist-x86_64-netbsd%2Fbuild-netbsd-toolchain.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-x86_64-netbsd%2Fbuild-netbsd-toolchain.sh?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd", "patch": "@@ -54,7 +54,7 @@ cd usr/src\n # The options, in order, do the following\n # * this is an unprivileged build\n # * output to a predictable location\n-# * disable various uneeded stuff\n+# * disable various unneeded stuff\n MKUNPRIVED=yes TOOLDIR=/x-tools/x86_64-unknown-netbsd \\\n MKSHARE=no MKDOC=no MKHTML=no MKINFO=no MKKMOD=no MKLINT=no MKMAN=no MKNLS=no MKPROFILE=no \\\n hide_output ./build.sh -j10 -m amd64 tools"}, {"sha": "aab339f399c598504021faf3a444175324a91185", "filename": "src/ci/docker/mingw-check/Dockerfile", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fci%2Fdocker%2Fmingw-check%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fci%2Fdocker%2Fmingw-check%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fmingw-check%2FDockerfile?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd", "patch": "@@ -0,0 +1,23 @@\n+FROM ubuntu:16.04\n+\n+RUN apt-get update && apt-get install -y --no-install-recommends \\\n+  g++ \\\n+  make \\\n+  file \\\n+  curl \\\n+  ca-certificates \\\n+  python2.7 \\\n+  git \\\n+  cmake \\\n+  sudo \\\n+  gdb \\\n+  xz-utils \\\n+  libssl-dev \\\n+  pkg-config \\\n+  mingw-w64\n+\n+COPY scripts/sccache.sh /scripts/\n+RUN sh /scripts/sccache.sh\n+\n+ENV RUN_CHECK_WITH_PARALLEL_QUERIES 1\n+ENV SCRIPT python2.7 ../x.py check --target=i686-pc-windows-gnu --host=i686-pc-windows-gnu"}, {"sha": "3a7714d32fa17741dbf0b4f38822a87dd8b776f0", "filename": "src/ci/docker/run.sh", "status": "modified", "additions": 36, "deletions": 2, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fci%2Fdocker%2Frun.sh", "raw_url": "https://github.com/rust-lang/rust/raw/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fci%2Fdocker%2Frun.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Frun.sh?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd", "patch": "@@ -27,6 +27,23 @@ travis_fold start build_docker\n travis_time_start\n \n if [ -f \"$docker_dir/$image/Dockerfile\" ]; then\n+    if [ \"$CI\" != \"\" ]; then\n+      cksum=$(find $docker_dir/$image $docker_dir/scripts -type f | \\\n+        sort | \\\n+        xargs cat | \\\n+        sha512sum | \\\n+        awk '{print $1}')\n+      s3url=\"s3://$SCCACHE_BUCKET/docker/$cksum\"\n+      url=\"https://s3-us-west-1.amazonaws.com/$SCCACHE_BUCKET/docker/$cksum\"\n+      echo \"Attempting to download $s3url\"\n+      rm -f /tmp/rustci_docker_cache\n+      set +e\n+      retry curl -f -L -C - -o /tmp/rustci_docker_cache \"$url\"\n+      loaded_images=$(docker load -i /tmp/rustci_docker_cache | sed 's/.* sha/sha/')\n+      set -e\n+      echo \"Downloaded containers:\\n$loaded_images\"\n+    fi\n+\n     dockerfile=\"$docker_dir/$image/Dockerfile\"\n     if [ -x /usr/bin/cygpath ]; then\n         context=\"`cygpath -w $docker_dir`\"\n@@ -40,6 +57,23 @@ if [ -f \"$docker_dir/$image/Dockerfile\" ]; then\n       -t rust-ci \\\n       -f \"$dockerfile\" \\\n       \"$context\"\n+\n+    if [ \"$s3url\" != \"\" ]; then\n+      digest=$(docker inspect rust-ci --format '{{.Id}}')\n+      echo \"Built container $digest\"\n+      if ! grep -q \"$digest\" <(echo \"$loaded_images\"); then\n+        echo \"Uploading finished image to $s3url\"\n+        set +e\n+        docker history -q rust-ci | \\\n+          grep -v missing | \\\n+          xargs docker save | \\\n+          gzip | \\\n+          aws s3 cp - $s3url\n+        set -e\n+      else\n+        echo \"Looks like docker image is the same as before, not uploading\"\n+      fi\n+    fi\n elif [ -f \"$docker_dir/disabled/$image/Dockerfile\" ]; then\n     if [ -n \"$TRAVIS_OS_NAME\" ]; then\n         echo Cannot run disabled images on travis!\n@@ -65,15 +99,14 @@ objdir=$root_dir/obj\n \n mkdir -p $HOME/.cargo\n mkdir -p $objdir/tmp\n+mkdir -p $objdir/cores\n \n args=\n if [ \"$SCCACHE_BUCKET\" != \"\" ]; then\n     args=\"$args --env SCCACHE_BUCKET\"\n     args=\"$args --env SCCACHE_REGION\"\n     args=\"$args --env AWS_ACCESS_KEY_ID\"\n     args=\"$args --env AWS_SECRET_ACCESS_KEY\"\n-    args=\"$args --env SCCACHE_ERROR_LOG=/tmp/sccache/sccache.log\"\n-    args=\"$args --volume $objdir/tmp:/tmp/sccache\"\n else\n     mkdir -p $HOME/.cache/sccache\n     args=\"$args --env SCCACHE_DIR=/sccache --volume $HOME/.cache/sccache:/sccache\"\n@@ -100,6 +133,7 @@ exec docker \\\n   --env TRAVIS \\\n   --env TRAVIS_BRANCH \\\n   --env TOOLSTATE_REPO_ACCESS_TOKEN \\\n+  --env CI_JOB_NAME=\"${CI_JOB_NAME-$IMAGE}\" \\\n   --volume \"$HOME/.cargo:/cargo\" \\\n   --volume \"$HOME/rustsrc:$HOME/rustsrc\" \\\n   --init \\"}, {"sha": "4ca7389d6d1a53102eca067a43697f88250dbcd9", "filename": "src/ci/docker/scripts/musl.sh", "status": "modified", "additions": 12, "deletions": 34, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fci%2Fdocker%2Fscripts%2Fmusl.sh", "raw_url": "https://github.com/rust-lang/rust/raw/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fci%2Fdocker%2Fscripts%2Fmusl.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fscripts%2Fmusl.sh?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd", "patch": "@@ -30,15 +30,23 @@ exit 1\n TAG=$1\n shift\n \n-MUSL=musl-1.1.18\n+export CFLAGS=\"-fPIC $CFLAGS\"\n+\n+# FIXME: remove the patch when upate to 1.1.20\n+MUSL=musl-1.1.19\n \n # may have been downloaded in a previous run\n if [ ! -d $MUSL ]; then\n   curl https://www.musl-libc.org/releases/$MUSL.tar.gz | tar xzf -\n+  # Patch to fix https://github.com/rust-lang/rust/issues/48967\n+  cd $MUSL && \\\n+    curl \"https://git.musl-libc.org/cgit/musl/patch/?id=610c5a8524c3d6cd3ac5a5f1231422e7648a3791\" |\\\n+    patch -p1 && \\\n+    cd -\n fi\n \n cd $MUSL\n-./configure --disable-shared --prefix=/musl-$TAG $@\n+./configure --enable-optimize --enable-debug --disable-shared --prefix=/musl-$TAG $@\n if [ \"$TAG\" = \"i586\" -o \"$TAG\" = \"i686\" ]; then\n   hide_output make -j$(nproc) AR=ar RANLIB=ranlib\n else\n@@ -49,42 +57,12 @@ hide_output make clean\n \n cd ..\n \n-LLVM=39\n+LLVM=60\n+\n # may have been downloaded in a previous run\n if [ ! -d libunwind-release_$LLVM ]; then\n   curl -L https://github.com/llvm-mirror/llvm/archive/release_$LLVM.tar.gz | tar xzf -\n   curl -L https://github.com/llvm-mirror/libunwind/archive/release_$LLVM.tar.gz | tar xzf -\n-  # Whoa what's this mysterious patch we're applying to libunwind! Why are we\n-  # swapping the values of ESP/EBP in libunwind?!\n-  #\n-  # Discovered in #35599 it turns out that the vanilla build of libunwind is not\n-  # suitable for unwinding i686 musl. After some investigation it ended up\n-  # looking like the register values for ESP/EBP were indeed incorrect (swapped)\n-  # in the source. Similar commits in libunwind (r280099 and r282589) have noticed\n-  # this for other platforms, and we just need to realize it for musl linux as\n-  # well.\n-  #\n-  # More technical info can be found at #35599\n-  cd libunwind-release_$LLVM\n-  patch -Np1 << EOF\n-diff --git a/include/libunwind.h b/include/libunwind.h\n-index c5b9633..1360eb2 100644\n---- a/include/libunwind.h\n-+++ b/include/libunwind.h\n-@@ -151,8 +151,8 @@ enum {\n-   UNW_X86_ECX = 1,\n-   UNW_X86_EDX = 2,\n-   UNW_X86_EBX = 3,\n--  UNW_X86_EBP = 4,\n--  UNW_X86_ESP = 5,\n-+  UNW_X86_ESP = 4,\n-+  UNW_X86_EBP = 5,\n-   UNW_X86_ESI = 6,\n-   UNW_X86_EDI = 7\n- };\n-fi\n-EOF\n-  cd ..\n fi\n \n mkdir libunwind-build"}, {"sha": "da52d08318115eb80a7cc39bb3ffde8e8439dad3", "filename": "src/ci/docker/scripts/sccache.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fci%2Fdocker%2Fscripts%2Fsccache.sh", "raw_url": "https://github.com/rust-lang/rust/raw/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fci%2Fdocker%2Fscripts%2Fsccache.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fscripts%2Fsccache.sh?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd", "patch": "@@ -13,6 +13,6 @@\n set -ex\n \n curl -fo /usr/local/bin/sccache \\\n-  https://s3-us-west-1.amazonaws.com/rust-lang-ci2/rust-ci-mirror/2017-05-12-sccache-x86_64-unknown-linux-musl\n+  https://s3-us-west-1.amazonaws.com/rust-lang-ci2/rust-ci-mirror/2018-04-02-sccache-x86_64-unknown-linux-musl\n \n chmod +x /usr/local/bin/sccache"}, {"sha": "56eda5480715bc1b5517f4d916f5b27b7718ad34", "filename": "src/ci/docker/wasm32-unknown/Dockerfile", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fci%2Fdocker%2Fwasm32-unknown%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fci%2Fdocker%2Fwasm32-unknown%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fwasm32-unknown%2FDockerfile?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd", "patch": "@@ -22,15 +22,21 @@ RUN sh /scripts/sccache.sh\n ENV TARGETS=wasm32-unknown-unknown\n \n ENV RUST_CONFIGURE_ARGS \\\n-  --target=$TARGETS \\\n-  --set build.nodejs=/node-v9.2.0-linux-x64/bin/node\n+  --set build.nodejs=/node-v9.2.0-linux-x64/bin/node \\\n+  --set rust.lld\n+\n+# Some run-make tests have assertions about code size, and enabling debug\n+# assertions in libstd causes the binary to be much bigger than it would\n+# otherwise normally be. We already test libstd with debug assertions in lots of\n+# other contexts as well\n+ENV NO_DEBUG_ASSERTIONS=1\n \n ENV SCRIPT python2.7 /checkout/x.py test --target $TARGETS \\\n+  src/test/run-make \\\n   src/test/ui \\\n   src/test/run-pass \\\n   src/test/compile-fail \\\n   src/test/parse-fail \\\n   src/test/mir-opt \\\n   src/test/codegen-units \\\n   src/libcore \\\n-  src/libstd_unicode/ \\"}, {"sha": "bdde7ad7fe854a0d29fad01b0a012433e82c9e54", "filename": "src/ci/docker/x86_64-gnu-debug/Dockerfile", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fci%2Fdocker%2Fx86_64-gnu-debug%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fci%2Fdocker%2Fx86_64-gnu-debug%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fx86_64-gnu-debug%2FDockerfile?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd", "patch": "@@ -16,6 +16,7 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n COPY scripts/sccache.sh /scripts/\n RUN sh /scripts/sccache.sh\n \n+ENV RUN_CHECK_WITH_PARALLEL_QUERIES 1\n ENV RUST_CONFIGURE_ARGS \\\n       --build=x86_64-unknown-linux-gnu \\\n       --enable-debug \\"}, {"sha": "7304ed6015cc9042f5e552df3244d45f105d932e", "filename": "src/ci/docker/x86_64-gnu-incremental/Dockerfile", "status": "removed", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/ac64ef33756d05557153e00211cdf8fcf65d4be3/src%2Fci%2Fdocker%2Fx86_64-gnu-incremental%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/ac64ef33756d05557153e00211cdf8fcf65d4be3/src%2Fci%2Fdocker%2Fx86_64-gnu-incremental%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fx86_64-gnu-incremental%2FDockerfile?ref=ac64ef33756d05557153e00211cdf8fcf65d4be3", "patch": "@@ -1,22 +0,0 @@\n-FROM ubuntu:16.04\n-\n-RUN apt-get update && apt-get install -y --no-install-recommends \\\n-  g++ \\\n-  make \\\n-  file \\\n-  curl \\\n-  ca-certificates \\\n-  python2.7 \\\n-  git \\\n-  cmake \\\n-  sudo \\\n-  gdb \\\n-  xz-utils\n-\n-COPY scripts/sccache.sh /scripts/\n-RUN sh /scripts/sccache.sh\n-\n-ENV RUST_CONFIGURE_ARGS --build=x86_64-unknown-linux-gnu\n-ENV RUSTFLAGS -Zincremental=/tmp/rust-incr-cache\n-ENV RUST_CHECK_TARGET check\n-ENV CARGO_INCREMENTAL 0"}, {"sha": "6b8186048988d089a08c9e8bc8c4aa393c466f82", "filename": "src/ci/docker/x86_64-gnu-llvm-3.9/Dockerfile", "status": "removed", "additions": 0, "deletions": 27, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/ac64ef33756d05557153e00211cdf8fcf65d4be3/src%2Fci%2Fdocker%2Fx86_64-gnu-llvm-3.9%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/ac64ef33756d05557153e00211cdf8fcf65d4be3/src%2Fci%2Fdocker%2Fx86_64-gnu-llvm-3.9%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fx86_64-gnu-llvm-3.9%2FDockerfile?ref=ac64ef33756d05557153e00211cdf8fcf65d4be3", "patch": "@@ -1,27 +0,0 @@\n-FROM ubuntu:16.04\n-\n-RUN apt-get update && apt-get install -y --no-install-recommends \\\n-  g++ \\\n-  make \\\n-  file \\\n-  curl \\\n-  ca-certificates \\\n-  python2.7 \\\n-  git \\\n-  cmake \\\n-  sudo \\\n-  gdb \\\n-  llvm-3.9-tools \\\n-  libedit-dev \\\n-  zlib1g-dev \\\n-  xz-utils\n-\n-COPY scripts/sccache.sh /scripts/\n-RUN sh /scripts/sccache.sh\n-\n-# using llvm-link-shared due to libffi issues -- see #34486\n-ENV RUST_CONFIGURE_ARGS \\\n-      --build=x86_64-unknown-linux-gnu \\\n-      --llvm-root=/usr/lib/llvm-3.9 \\\n-      --enable-llvm-link-shared\n-ENV RUST_CHECK_TARGET check"}, {"sha": "4f90c5097260ce153a595fe4151733934d26de2a", "filename": "src/ci/docker/x86_64-gnu-llvm-5.0/Dockerfile", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fci%2Fdocker%2Fx86_64-gnu-llvm-5.0%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fci%2Fdocker%2Fx86_64-gnu-llvm-5.0%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fx86_64-gnu-llvm-5.0%2FDockerfile?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd", "patch": "@@ -0,0 +1,27 @@\n+FROM ubuntu:16.04\n+\n+RUN apt-get update && apt-get install -y --no-install-recommends \\\n+  g++ \\\n+  make \\\n+  file \\\n+  curl \\\n+  ca-certificates \\\n+  python2.7 \\\n+  git \\\n+  cmake \\\n+  sudo \\\n+  gdb \\\n+  llvm-5.0-tools \\\n+  libedit-dev \\\n+  zlib1g-dev \\\n+  xz-utils\n+\n+COPY scripts/sccache.sh /scripts/\n+RUN sh /scripts/sccache.sh\n+\n+# using llvm-link-shared due to libffi issues -- see #34486\n+ENV RUST_CONFIGURE_ARGS \\\n+      --build=x86_64-unknown-linux-gnu \\\n+      --llvm-root=/usr/lib/llvm-5.0 \\\n+      --enable-llvm-link-shared\n+ENV RUST_CHECK_TARGET check"}, {"sha": "bab9145cbcb9c78ed68ee5c5a06fdf28cca932a6", "filename": "src/ci/docker/x86_64-gnu-tools/Dockerfile", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fci%2Fdocker%2Fx86_64-gnu-tools%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fci%2Fdocker%2Fx86_64-gnu-tools%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fx86_64-gnu-tools%2FDockerfile?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd", "patch": "@@ -17,6 +17,7 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n COPY scripts/sccache.sh /scripts/\n RUN sh /scripts/sccache.sh\n \n+COPY x86_64-gnu-tools/checkregression.py /tmp/\n COPY x86_64-gnu-tools/checktools.sh /tmp/\n COPY x86_64-gnu-tools/repo.sh /tmp/\n "}, {"sha": "208aab434ce1fa84f289b5e0c044a4bda3afd0fc", "filename": "src/ci/docker/x86_64-gnu-tools/checkregression.py", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fci%2Fdocker%2Fx86_64-gnu-tools%2Fcheckregression.py", "raw_url": "https://github.com/rust-lang/rust/raw/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fci%2Fdocker%2Fx86_64-gnu-tools%2Fcheckregression.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fx86_64-gnu-tools%2Fcheckregression.py?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd", "patch": "@@ -0,0 +1,48 @@\n+#!/usr/bin/env python\n+# -*- coding: utf-8 -*-\n+\n+# Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+# file at the top-level directory of this distribution and at\n+# http://rust-lang.org/COPYRIGHT.\n+#\n+# Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+# http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+# <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+# option. This file may not be copied, modified, or distributed\n+# except according to those terms.\n+\n+import sys\n+import json\n+\n+if __name__ == '__main__':\n+    os_name = sys.argv[1]\n+    toolstate_file = sys.argv[2]\n+    current_state = sys.argv[3]\n+    verb = sys.argv[4] # 'regressed' or 'changed'\n+\n+    with open(toolstate_file, 'r') as f:\n+        toolstate = json.load(f)\n+    with open(current_state, 'r') as f:\n+        current = json.load(f)\n+\n+    regressed = False\n+    for cur in current:\n+        tool = cur['tool']\n+        state = cur[os_name]\n+        new_state = toolstate.get(tool, '')\n+        if verb == 'regressed':\n+            updated = new_state < state\n+        elif verb == 'changed':\n+            updated = new_state != state\n+        else:\n+            print('Unknown verb {}'.format(updated))\n+            sys.exit(2)\n+        if updated:\n+            print(\n+                'The state of \"{}\" has {} from \"{}\" to \"{}\"'\n+                .format(tool, verb, state, new_state)\n+            )\n+            regressed = True\n+\n+    if regressed:\n+        sys.exit(1)"}, {"sha": "d876cb7f37a41b91dea2148a05f95818f55bb8ae", "filename": "src/ci/docker/x86_64-gnu-tools/checktools.sh", "status": "modified", "additions": 79, "deletions": 22, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fci%2Fdocker%2Fx86_64-gnu-tools%2Fchecktools.sh", "raw_url": "https://github.com/rust-lang/rust/raw/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fci%2Fdocker%2Fx86_64-gnu-tools%2Fchecktools.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fx86_64-gnu-tools%2Fchecktools.sh?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd", "patch": "@@ -17,52 +17,109 @@ TOOLSTATE_FILE=\"$(realpath $2)\"\n OS=\"$3\"\n COMMIT=\"$(git rev-parse HEAD)\"\n CHANGED_FILES=\"$(git diff --name-status HEAD HEAD^)\"\n+SIX_WEEK_CYCLE=\"$(( ($(date +%s) / 86400 - 20) % 42 ))\"\n+# ^ Number of days after the last promotion of beta.\n+#   Its value is 41 on the Tuesday where \"Promote master to beta (T-2)\" happens.\n+#   The Wednesday after this has value 0.\n+#   We track this value to prevent regressing tools in the last week of the 6-week cycle.\n \n touch \"$TOOLSTATE_FILE\"\n \n+# Try to test all the tools and store the build/test success in the TOOLSTATE_FILE\n+\n set +e\n python2.7 \"$X_PY\" test --no-fail-fast \\\n+    src/doc/book \\\n+    src/doc/nomicon \\\n+    src/doc/reference \\\n+    src/doc/rust-by-example \\\n+    src/tools/clippy \\\n     src/tools/rls \\\n     src/tools/rustfmt \\\n     src/tools/miri \\\n-    src/tools/clippy\n+\n set -e\n \n cat \"$TOOLSTATE_FILE\"\n+echo\n \n-# If this PR is intended to update one of these tools, do not let the build pass\n-# when they do not test-pass.\n-for TOOL in rls rustfmt miri clippy; do\n-    echo \"Verifying status of $TOOL...\"\n-    if echo \"$CHANGED_FILES\" | grep -q \"^M[[:blank:]]src/tools/$TOOL$\"; then\n-        echo \"This PR updated 'src/tools/$TOOL', verifying if status is 'test-pass'...\"\n-        if grep -vq '\"'\"$TOOL\"'[^\"]*\":\"test-pass\"' \"$TOOLSTATE_FILE\"; then\n+# This function checks that if a tool's submodule changed, the tool's state must improve\n+verify_status() {\n+    echo \"Verifying status of $1...\"\n+    if echo \"$CHANGED_FILES\" | grep -q \"^M[[:blank:]]$2$\"; then\n+        echo \"This PR updated '$2', verifying if status is 'test-pass'...\"\n+        if grep -vq '\"'\"$1\"'\":\"test-pass\"' \"$TOOLSTATE_FILE\"; then\n             echo\n-            echo \"\u26a0\ufe0f We detected that this PR updated '$TOOL', but its tests failed.\"\n+            echo \"\u26a0\ufe0f We detected that this PR updated '$1', but its tests failed.\"\n             echo\n-            echo \"If you do intend to update '$TOOL', please check the error messages above and\"\n+            echo \"If you do intend to update '$1', please check the error messages above and\"\n             echo \"commit another update.\"\n             echo\n-            echo \"If you do NOT intend to update '$TOOL', please ensure you did not accidentally\"\n-            echo \"change the submodule at 'src/tools/$TOOL'. You may ask your reviewer for the\"\n+            echo \"If you do NOT intend to update '$1', please ensure you did not accidentally\"\n+            echo \"change the submodule at '$2'. You may ask your reviewer for the\"\n             echo \"proper steps.\"\n             exit 3\n         fi\n     fi\n-done\n+}\n \n-if [ \"$RUST_RELEASE_CHANNEL\" = nightly -a -n \"${TOOLSTATE_REPO_ACCESS_TOKEN+is_set}\" ]; then\n-    . \"$(dirname $0)/repo.sh\"\n-    MESSAGE_FILE=$(mktemp -t msg.XXXXXX)\n-    echo \"($OS CI update)\" > \"$MESSAGE_FILE\"\n-    commit_toolstate_change \"$MESSAGE_FILE\" \\\n+# deduplicates the submodule check and the assertion that on beta some tools MUST be passing\n+check_dispatch() {\n+    if [ \"$1\" = submodule_changed ]; then\n+        # ignore $2 (branch id)\n+        verify_status $3 $4\n+    elif [ \"$2\" = beta ]; then\n+        echo \"Requiring test passing for $3...\"\n+        if grep -q '\"'\"$3\"'\":\"\\(test\\|build\\)-fail\"' \"$TOOLSTATE_FILE\"; then\n+            exit 4\n+        fi\n+    fi\n+}\n+\n+# list all tools here\n+status_check() {\n+    check_dispatch $1 beta book src/doc/book\n+    check_dispatch $1 beta nomicon src/doc/nomicon\n+    check_dispatch $1 beta reference src/doc/reference\n+    check_dispatch $1 beta rust-by-example src/doc/rust-by-example\n+    check_dispatch $1 beta rls src/tools/rls\n+    check_dispatch $1 beta rustfmt src/tools/rustfmt\n+    check_dispatch $1 beta clippy-driver src/tools/clippy\n+    # these tools are not required for beta to successfully branch\n+    check_dispatch $1 nightly miri src/tools/miri\n+}\n+\n+# If this PR is intended to update one of these tools, do not let the build pass\n+# when they do not test-pass.\n+\n+status_check \"submodule_changed\"\n+\n+CHECK_NOT=\"$(readlink -f \"$(dirname $0)/checkregression.py\")\"\n+change_toolstate() {\n+    # only update the history\n+    if python2.7 \"$CHECK_NOT\" \"$OS\" \"$TOOLSTATE_FILE\" \"_data/latest.json\" changed; then\n+        echo 'Toolstate is not changed. Not updating.'\n+    else\n+        if [ $SIX_WEEK_CYCLE -ge 35 ]; then\n+            python2.7 \"$CHECK_NOT\" \"$OS\" \"$TOOLSTATE_FILE\" \"_data/latest.json\" regressed\n+        fi\n         sed -i \"1 a\\\\\n $COMMIT\\t$(cat \"$TOOLSTATE_FILE\")\n \" \"history/$OS.tsv\"\n-    rm -f \"$MESSAGE_FILE\"\n+    fi\n+}\n+\n+if [ \"$RUST_RELEASE_CHANNEL\" = nightly ]; then\n+    if [ -n \"${TOOLSTATE_REPO_ACCESS_TOKEN+is_set}\" ]; then\n+        . \"$(dirname $0)/repo.sh\"\n+        MESSAGE_FILE=$(mktemp -t msg.XXXXXX)\n+        echo \"($OS CI update)\" > \"$MESSAGE_FILE\"\n+        commit_toolstate_change \"$MESSAGE_FILE\" change_toolstate\n+        rm -f \"$MESSAGE_FILE\"\n+    fi\n     exit 0\n fi\n \n-if grep -q fail \"$TOOLSTATE_FILE\"; then\n-    exit 4\n-fi\n+# abort compilation if an important tool doesn't build\n+# (this code is reachable if not on the nightly channel)\n+status_check \"beta_required\""}, {"sha": "807e6fb7b642e2d6b789ea7ef40aaf7c07633a88", "filename": "src/ci/docker/x86_64-gnu-tools/repo.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fci%2Fdocker%2Fx86_64-gnu-tools%2Frepo.sh", "raw_url": "https://github.com/rust-lang/rust/raw/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fci%2Fdocker%2Fx86_64-gnu-tools%2Frepo.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fx86_64-gnu-tools%2Frepo.sh?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd", "patch": "@@ -60,7 +60,7 @@ commit_toolstate_change() {\n     OLDFLAGS=\"$-\"\n     set -eu\n \n-    git config --global user.email '34210020+rust-toolstate-update@users.noreply.github.com'\n+    git config --global user.email '7378925+rust-toolstate-update@users.noreply.github.com'\n     git config --global user.name 'Rust Toolstate Update'\n     git config --global credential.helper store\n     printf 'https://%s:x-oauth-basic@github.com\\n' \"$TOOLSTATE_REPO_ACCESS_TOKEN\" \\"}, {"sha": "f2664e6d196c7afcab810ab0ee15f5e30b14eb64", "filename": "src/ci/init_repo.sh", "status": "modified", "additions": 36, "deletions": 39, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fci%2Finit_repo.sh", "raw_url": "https://github.com/rust-lang/rust/raw/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fci%2Finit_repo.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Finit_repo.sh?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd", "patch": "@@ -17,6 +17,7 @@ ci_dir=$(cd $(dirname $0) && pwd)\n . \"$ci_dir/shared.sh\"\n \n travis_fold start init_repo\n+travis_time_start\n \n REPO_DIR=\"$1\"\n CACHE_DIR=\"$2\"\n@@ -36,49 +37,45 @@ fi\n rm -rf \"$CACHE_DIR\"\n mkdir \"$CACHE_DIR\"\n \n-travis_fold start update_cache\n-travis_time_start\n-\n-# Update the cache (a pristine copy of the rust source master)\n-retry sh -c \"rm -rf $cache_src_dir && mkdir -p $cache_src_dir && \\\n-    git clone --depth 1 https://github.com/rust-lang/rust.git $cache_src_dir\"\n-(cd $cache_src_dir && git rm src/llvm)\n-retry sh -c \"cd $cache_src_dir && \\\n-    git submodule deinit -f . && git submodule sync && git submodule update --init\"\n-\n-travis_fold end update_cache\n-travis_time_finish\n+# On the beta channel we'll be automatically calculating the prerelease version\n+# via the git history, so unshallow our shallow clone from CI.\n+if grep -q RUST_RELEASE_CHANNEL=beta src/ci/run.sh; then\n+  git fetch origin --unshallow beta master\n+fi\n \n-travis_fold start update_submodules\n-travis_time_start\n+function fetch_submodule {\n+    local module=$1\n+    local cached=\"download-${module//\\//-}.tar.gz\"\n+    retry sh -c \"rm -f $cached && \\\n+        curl -sSL -o $cached $2\"\n+    mkdir $module\n+    touch \"$module/.git\"\n+    tar -C $module --strip-components=1 -xf $cached\n+    rm $cached\n+}\n \n-# Update the submodules of the repo we're in, using the pristine repo as\n-# a cache for any object files\n-# No, `git submodule foreach` won't work:\n-# http://stackoverflow.com/questions/12641469/list-submodules-in-a-git-repository\n+included=\"src/llvm src/llvm-emscripten src/doc/book src/doc/rust-by-example\"\n modules=\"$(git config --file .gitmodules --get-regexp '\\.path$' | cut -d' ' -f2)\"\n-for module in $modules; do\n-    if [ \"$module\" = src/llvm ]; then\n-        commit=\"$(git ls-tree HEAD src/llvm | awk '{print $3}')\"\n-        git rm src/llvm\n-        retry sh -c \"rm -f $commit.tar.gz && \\\n-            curl -sSL -O https://github.com/rust-lang/llvm/archive/$commit.tar.gz\"\n-        tar -C src/ -xf \"$commit.tar.gz\"\n-        rm \"$commit.tar.gz\"\n-        mv \"src/llvm-$commit\" src/llvm\n+modules=($modules)\n+use_git=\"\"\n+urls=\"$(git config --file .gitmodules --get-regexp '\\.url$' | cut -d' ' -f2)\"\n+urls=($urls)\n+for i in ${!modules[@]}; do\n+    module=${modules[$i]}\n+    if [[ \" $included \" = *\" $module \"* ]]; then\n+        commit=\"$(git ls-tree HEAD $module | awk '{print $3}')\"\n+        git rm $module\n+        url=${urls[$i]}\n+        url=${url/\\.git/}\n+        fetch_submodule $module \"$url/archive/$commit.tar.gz\" &\n         continue\n+    else\n+        use_git=\"$use_git $module\"\n     fi\n-    if [ ! -e \"$cache_src_dir/$module/.git\" ]; then\n-        echo \"WARNING: $module not found in pristine repo\"\n-        retry sh -c \"git submodule deinit -f $module && \\\n-            git submodule update --init --recursive $module\"\n-        continue\n-    fi\n-    retry sh -c \"git submodule deinit -f $module && \\\n-        git submodule update --init --recursive --reference $cache_src_dir/$module $module\"\n done\n-\n-travis_fold end update_submodules\n-travis_time_finish\n-\n+retry sh -c \"git submodule deinit -f $use_git && \\\n+    git submodule sync && \\\n+    git submodule update -j 16 --init --recursive $use_git\"\n+wait\n travis_fold end init_repo\n+travis_time_finish"}, {"sha": "09a0cf3541d8dde8f7dc524db62af022933b2e5b", "filename": "src/ci/run.sh", "status": "modified", "additions": 33, "deletions": 3, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fci%2Frun.sh", "raw_url": "https://github.com/rust-lang/rust/raw/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fci%2Frun.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Frun.sh?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd", "patch": "@@ -11,6 +11,10 @@\n \n set -e\n \n+if [ -n \"$CI_JOB_NAME\" ]; then\n+  echo \"[CI_JOB_NAME=$CI_JOB_NAME]\"\n+fi\n+\n if [ \"$NO_CHANGE_USER\" = \"\" ]; then\n   if [ \"$LOCAL_USER_ID\" != \"\" ]; then\n     useradd --shell /bin/bash -u $LOCAL_USER_ID -o -c \"\" -m user\n@@ -20,11 +24,16 @@ if [ \"$NO_CHANGE_USER\" = \"\" ]; then\n   fi\n fi\n \n+# only enable core dump on Linux\n+if [ -f /proc/sys/kernel/core_pattern ]; then\n+  ulimit -c unlimited\n+fi\n+\n ci_dir=`cd $(dirname $0) && pwd`\n source \"$ci_dir/shared.sh\"\n \n-if [ \"$TRAVIS\" == \"true\" ] && [ \"$TRAVIS_BRANCH\" != \"auto\" ]; then\n-    RUST_CONFIGURE_ARGS=\"$RUST_CONFIGURE_ARGS --enable-quiet-tests\"\n+if [ \"$TRAVIS\" != \"true\" ] || [ \"$TRAVIS_BRANCH\" == \"auto\" ]; then\n+    RUST_CONFIGURE_ARGS=\"$RUST_CONFIGURE_ARGS --set build.print-step-timings --enable-verbose-tests\"\n fi\n \n RUST_CONFIGURE_ARGS=\"$RUST_CONFIGURE_ARGS --enable-sccache\"\n@@ -66,6 +75,19 @@ else\n   fi\n fi\n \n+# We've had problems in the past of shell scripts leaking fds into the sccache\n+# server (#48192) which causes Cargo to erroneously think that a build script\n+# hasn't finished yet. Try to solve that problem by starting a very long-lived\n+# sccache server at the start of the build, but no need to worry if this fails.\n+SCCACHE_IDLE_TIMEOUT=10800 sccache --start-server || true\n+\n+if [ \"$RUN_CHECK_WITH_PARALLEL_QUERIES\" != \"\" ]; then\n+  $SRC/configure --enable-experimental-parallel-queries\n+  CARGO_INCREMENTAL=0 python2.7 ../x.py check\n+  rm -f config.toml\n+  rm -rf build\n+fi\n+\n travis_fold start configure\n travis_time_start\n $SRC/configure $RUST_CONFIGURE_ARGS\n@@ -84,11 +106,19 @@ make check-bootstrap\n travis_fold end check-bootstrap\n travis_time_finish\n \n+# Display the CPU and memory information. This helps us know why the CI timing\n+# is fluctuating.\n+travis_fold start log-system-info\n if [ \"$TRAVIS_OS_NAME\" = \"osx\" ]; then\n+    system_profiler SPHardwareDataType || true\n+    sysctl hw || true\n     ncpus=$(sysctl -n hw.ncpu)\n else\n+    cat /proc/cpuinfo || true\n+    cat /proc/meminfo || true\n     ncpus=$(grep processor /proc/cpuinfo | wc -l)\n fi\n+travis_fold end log-system-info\n \n if [ ! -z \"$SCRIPT\" ]; then\n   sh -x -c \"$SCRIPT\"\n@@ -97,7 +127,7 @@ else\n     travis_fold start \"make-$1\"\n     travis_time_start\n     echo \"make -j $ncpus $1\"\n-    make -j $ncpus \"$1\"\n+    make -j $ncpus $1\n     local retval=$?\n     travis_fold end \"make-$1\"\n     travis_time_finish"}, {"sha": "bb6945f0fd6bbb5b542778b466c532e8d3682c23", "filename": "src/ci/shared.sh", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fci%2Fshared.sh", "raw_url": "https://github.com/rust-lang/rust/raw/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fci%2Fshared.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fshared.sh?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd", "patch": "@@ -21,11 +21,12 @@ function retry {\n   while true; do\n     \"$@\" && break || {\n       if [[ $n -lt $max ]]; then\n+        sleep $n  # don't retry immediately\n         ((n++))\n         echo \"Command failed. Attempt $n/$max:\"\n       else\n         echo \"The command has failed after $n attempts.\"\n-        exit 1\n+        return 1\n       fi\n     }\n   done"}, {"sha": "c99638dc2ecfc750cc1656f6edb2bd062c1e0981", "filename": "src/dlmalloc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdlmalloc?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd", "patch": "@@ -1 +1 @@\n-Subproject commit d3812c3accaee7ad23068ed4fc089cc05c7a538f\n+Subproject commit c99638dc2ecfc750cc1656f6edb2bd062c1e0981"}, {"sha": "5f25894afd76d4bbb5437fbc4c23b7590d250e8a", "filename": "src/doc/README.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fdoc%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fdoc%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2FREADME.md?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd", "patch": "@@ -29,4 +29,4 @@ rustdoc reference.md\n An overview of how to use the `rustdoc` command is available [in the docs][1].\n Further details are available from the command line by with `rustdoc --help`.\n \n-[1]: https://github.com/rust-lang/rust/blob/master/src/doc/book/documentation.md\n+[1]: https://github.com/rust-lang/rust/blob/master/src/doc/rustdoc/src/what-is-rustdoc.md"}, {"sha": "88cdde350fd3a90c93f3bac8b4f168f105d28060", "filename": "src/doc/book", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd", "patch": "@@ -1 +1 @@\n-Subproject commit 194eb8d5f1753fb5f4501011cebdc1b585712474\n+Subproject commit 88cdde350fd3a90c93f3bac8b4f168f105d28060"}, {"sha": "ee9135b6578f6071e7f43fbbe6f2214f1253dbf6", "filename": "src/doc/grammar.md", "status": "modified", "additions": 9, "deletions": 14, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fdoc%2Fgrammar.md", "raw_url": "https://github.com/rust-lang/rust/raw/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fdoc%2Fgrammar.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fgrammar.md?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd", "patch": "@@ -101,29 +101,24 @@ properties: `ident`, `non_null`, `non_eol`, `non_single_quote` and\n \n ### Identifiers\n \n-The `ident` production is any nonempty Unicode[^non_ascii_idents] string of\n+The `ident` production is any nonempty Unicode string of\n the following form:\n \n-[^non_ascii_idents]: Non-ASCII characters in identifiers are currently feature\n-  gated. This is expected to improve soon.\n+- The first character is in one of the following ranges `U+0041` to `U+005A`\n+(\"A\" to \"Z\"), `U+0061` to `U+007A` (\"a\" to \"z\"), or `U+005F` (\"\\_\").\n+- The remaining characters are in the range `U+0030` to `U+0039` (\"0\" to \"9\"),\n+or any of the prior valid initial characters.\n \n-- The first character has property `XID_start`\n-- The remaining characters have property `XID_continue`\n-\n-that does _not_ occur in the set of [keywords](#keywords).\n-\n-> **Note**: `XID_start` and `XID_continue` as character properties cover the\n-> character ranges used to form the more familiar C and Java language-family\n-> identifiers.\n+as long as the identifier does _not_ occur in the set of [keywords](#keywords).\n \n ### Delimiter-restricted productions\n \n Some productions are defined by exclusion of particular Unicode characters:\n \n - `non_null` is any single Unicode character aside from `U+0000` (null)\n-- `non_eol` is `non_null` restricted to exclude `U+000A` (`'\\n'`)\n-- `non_single_quote` is `non_null` restricted to exclude `U+0027`  (`'`)\n-- `non_double_quote` is `non_null` restricted to exclude `U+0022` (`\"`)\n+- `non_eol` is any single Unicode character aside from `U+000A` (`'\\n'`)\n+- `non_single_quote` is any single Unicode character aside from `U+0027`  (`'`)\n+- `non_double_quote` is any single Unicode character aside from `U+0022` (`\"`)\n \n ## Comments\n "}, {"sha": "3a4f51069fc3b7f1534b7a5505633f5cfc04f90f", "filename": "src/doc/index.md", "status": "modified", "additions": 67, "deletions": 44, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fdoc%2Findex.md", "raw_url": "https://github.com/rust-lang/rust/raw/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fdoc%2Findex.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Findex.md?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd", "patch": "@@ -6,53 +6,76 @@ nav {\n }\n </style>\n \n-This page is an overview of the documentation included with your Rust install.\n-Other unofficial documentation may exist elsewhere; for example, the [Rust\n-Learning] project collects documentation from the community, and [Docs.rs]\n-builds documentation for individual Rust packages.\n+Welcome to an overview of the documentation provided by the Rust project.\n+All of these projects are managed by the Docs Team; there are other\n+unofficial documentation resources as well!\n \n-# API Documentation\n+Many of these resources take the form of \"books\"; we collectively call these\n+\"The Rust Bookshelf.\" Some are large, some are small.\n \n-Rust provides a standard library with a number of features; [we host its\n-documentation here][api].\n+# Learn Rust\n \n-# Extended Error Documentation\n+If you'd like to learn Rust, this is the spot for you! All of these resources\n+assume that you have programmed before, but not in any specific language:\n+\n+## The Rust Programming Language\n+\n+Affectionately nicknamed \"the book,\" [The Rust Programming\n+Language](book/index.html) will give you an overview of the language from\n+first principles. You'll build a few projects along the way, and by the end,\n+you'll have a solid grasp of the language.\n+\n+## Rust By Example\n+\n+If reading multiple hundreds of pages about a language isn't your style, then\n+[Rust By Example](rust-by-example/index.html) has you covered. While the book talks about code with\n+a lot of words, RBE shows off a bunch of code, and keeps the talking to a\n+minimum. It also includes exercises!\n+\n+# Use Rust\n+\n+Once you've gotten familliar with the language, these resources can help you\n+when you're actually using it day-to-day.\n+\n+## The Standard Library\n+\n+Rust's standard library has [extensive API documentation](std/index.html),\n+with explanations of how to use various things, as well as example code for\n+accomplishing various tasks.\n+\n+## The Rustc Book\n+\n+[The Rustc Book](rustc/index.html) describes the Rust compiler, `rustc`.\n+\n+## The Cargo Book\n+\n+[The Cargo Book](cargo/index.html) is a guide to Cargo, Rust's build tool and dependency manager.\n+\n+## The Rustdoc Book\n+\n+[The Rustdoc Book](rustdoc/index.html) describes our documentation tool, `rustdoc`.\n+\n+## Extended Error Listing\n \n Many of Rust's errors come with error codes, and you can request extended\n-diagnostics from the compiler on those errors. We also [have the text of those\n-extended errors on the web][err], if you prefer to read them that way.\n-\n-# The Rust Bookshelf\n-\n-Rust provides a number of book-length sets of documentation, collectively\n-nicknamed 'The Rust Bookshelf.'\n-\n-* [The Rust Programming Language][book] teaches you how to program in Rust.\n-* [The Cargo Book][cargo-book] is a guide to Cargo, Rust's build tool and dependency manager.\n-* [The Unstable Book][unstable-book] has documentation for unstable features.\n-* [The Rustonomicon][nomicon] is your guidebook to the dark arts of unsafe Rust.\n-* [The Reference][ref] is not a formal spec, but is more detailed and comprehensive than the book.\n-* [The Rustdoc Book][rustdoc-book] describes our documentation tool, `rustdoc`.\n-\n-Initially, documentation lands in the Unstable Book, and then, as part of the\n-stabilization process, is moved into the Book, Nomicon, or Reference.\n-\n-Another few words about the reference: it is guaranteed to be accurate, but not\n-complete. We have a policy that features must have documentation to be stabilized,\n-but we did not always have this policy, and so there are some stable things that\n-are not yet in the reference. We're working on back-filling things that landed\n-before this policy was put into place. That work is being tracked\n-[here][refchecklist].\n-\n-[Rust Learning]: https://github.com/ctjhoa/rust-learning\n-[Docs.rs]: https://docs.rs/\n-[api]: std/index.html\n-[ref]: reference/index.html\n-[refchecklist]: https://github.com/rust-lang-nursery/reference/issues/9\n-[err]: error-index.html\n-[book]: book/index.html\n-[nomicon]: nomicon/index.html\n-[unstable-book]: unstable-book/index.html\n-[rustdoc-book]: rustdoc/index.html\n-[cargo-book]: cargo/index.html\n+diagnostics from the compiler on those errors. You can also [read them\n+here](error-index.html), if you prefer to read them that way.\n+\n+# Master Rust\n+\n+Once you're quite familiar with the language, you may find these advanced\n+resources useful.\n+\n+## The Reference\n+\n+[The Reference](reference/index.html) is not a formal spec, but is more detailed and\n+comprehensive than the book.\n+\n+## The Rustonomicon\n+\n+[The Rustonomicon](nomicon/index.html) is your guidebook to the dark arts of unsafe\n+Rust. It's also sometimes called \"the 'nomicon.\"\n+\n+## The Unstable Book\n \n+[The Unstable Book](unstable-book/index.html) has documentation for unstable features."}, {"sha": "8f611063dbe5d901a222b5fb45134965d0ab319e", "filename": "src/doc/man/rustc.1", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fdoc%2Fman%2Frustc.1", "raw_url": "https://github.com/rust-lang/rust/raw/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fdoc%2Fman%2Frustc.1", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fman%2Frustc.1?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd", "patch": "@@ -55,7 +55,7 @@ Configure the output that \\fBrustc\\fR will produce. Each emission may also have\n an optional explicit output \\fIPATH\\fR specified for that particular emission\n kind. This path takes precedence over the \\fB-o\\fR option.\n .TP\n-\\fB\\-\\-print\\fR [crate\\-name|file\\-names|sysroot]\n+\\fB\\-\\-print\\fR [crate\\-name|\\:file\\-names|\\:sysroot|\\:cfg|\\:target\\-list|\\:target\\-cpus|\\:target\\-features|\\:relocation\\-models|\\:code\\-models|\\:tls\\-models|\\:target\\-spec\\-json|\\:native\\-static\\-libs]\n Comma separated list of compiler information to print on stdout.\n .TP\n \\fB\\-g\\fR\n@@ -125,6 +125,16 @@ Print version info and exit.\n \\fB\\-v\\fR, \\fB\\-\\-verbose\\fR\n Use verbose output.\n .TP\n+\\fB\\-\\-remap\\-path\\-prefix\\fR \\fIfrom\\fR=\\fIto\\fR\n+Remap source path prefixes in all output, including compiler diagnostics, debug information,\n+macro expansions, etc. The \\fIfrom\\fR=\\fIto\\fR parameter is scanned from right to left, so \\fIfrom\\fR\n+may contain '=', but \\fIto\\fR may not.\n+\n+This is useful for normalizing build products, for example by removing the current directory out of\n+pathnames emitted into the object files. The replacement is purely textual, with no consideration of\n+the current system's pathname syntax. For example \\fI\\-\\-remap\\-path\\-prefix foo=bar\\fR will\n+match \\fBfoo/lib.rs\\fR but not \\fB./foo/lib.rs\\fR.\n+.TP\n \\fB\\-\\-extern\\fR \\fINAME\\fR=\\fIPATH\\fR\n Specify where an external rust library is located. These should match\n \\fIextern\\fR declarations in the crate's source code."}, {"sha": "d7f78e8f6f4de7ddf10e6547932ada586e2a319b", "filename": "src/doc/man/rustdoc.1", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fdoc%2Fman%2Frustdoc.1", "raw_url": "https://github.com/rust-lang/rust/raw/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fdoc%2Fman%2Frustdoc.1", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fman%2Frustdoc.1?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd", "patch": "@@ -119,7 +119,7 @@ See <\\fBhttps://github.com/rust\\-lang/rust/issues\\fR>\n for issues.\n \n .SH \"AUTHOR\"\n-See \\fIAUTHORS.txt\\fR in the Rust source distribution.\n+See the version control history or <\\fBhttps://thanks.rust\\-lang.org\\fR>\n \n .SH \"COPYRIGHT\"\n This work is dual\\[hy]licensed under Apache\\ 2.0 and MIT terms."}, {"sha": "790e96b87f4b5817cac310e73a524d25c3d076d8", "filename": "src/doc/nomicon", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fnomicon?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd", "patch": "@@ -1 +1 @@\n-Subproject commit 2f7b05fd5939aa49d52c4ab309b9a47776ba7bd8\n+Subproject commit 790e96b87f4b5817cac310e73a524d25c3d076d8"}, {"sha": "219e261ddb833a5683627b0a9be87a0f4486abb9", "filename": "src/doc/reference", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd", "patch": "@@ -1 +1 @@\n-Subproject commit 1d791b55b23ec5389fbd5b3cee80db3f8bbdd162\n+Subproject commit 219e261ddb833a5683627b0a9be87a0f4486abb9"}, {"sha": "e3719fc78ff4a21dfd13cfcc9e2ca42cb5de29f4", "filename": "src/doc/rust-by-example", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frust-by-example?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd", "patch": "@@ -1 +1 @@\n-Subproject commit 4ebb8169dfe569b3dcbeab560607800bb717978a\n+Subproject commit e3719fc78ff4a21dfd13cfcc9e2ca42cb5de29f4"}, {"sha": "93e94e5586302629d12e7299d87fa076b69e5a88", "filename": "src/doc/rustc-ux-guidelines.md", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fdoc%2Frustc-ux-guidelines.md", "raw_url": "https://github.com/rust-lang/rust/raw/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fdoc%2Frustc-ux-guidelines.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc-ux-guidelines.md?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd", "patch": "@@ -64,13 +64,12 @@ for details on how to format and write long error codes.\n   [librustc](https://github.com/rust-lang/rust/blob/master/src/librustc/diagnostics.rs),\n   [libsyntax](https://github.com/rust-lang/rust/blob/master/src/libsyntax/diagnostics.rs),\n   [librustc_borrowck](https://github.com/rust-lang/rust/blob/master/src/librustc_borrowck/diagnostics.rs),\n-  [librustc_const_eval](https://github.com/rust-lang/rust/blob/master/src/librustc_const_eval/diagnostics.rs),\n   [librustc_metadata](https://github.com/rust-lang/rust/blob/master/src/librustc_metadata/diagnostics.rs),\n   [librustc_mir](https://github.com/rust-lang/rust/blob/master/src/librustc_mir/diagnostics.rs),\n   [librustc_passes](https://github.com/rust-lang/rust/blob/master/src/librustc_passes/diagnostics.rs),\n   [librustc_privacy](https://github.com/rust-lang/rust/blob/master/src/librustc_privacy/diagnostics.rs),\n   [librustc_resolve](https://github.com/rust-lang/rust/blob/master/src/librustc_resolve/diagnostics.rs),\n-  [librustc_trans](https://github.com/rust-lang/rust/blob/master/src/librustc_trans/diagnostics.rs),\n+  [librustc_codegen_llvm](https://github.com/rust-lang/rust/blob/master/src/librustc_codegen_llvm/diagnostics.rs),\n   [librustc_plugin](https://github.com/rust-lang/rust/blob/master/src/librustc_plugin/diagnostics.rs),\n   [librustc_typeck](https://github.com/rust-lang/rust/blob/master/src/librustc_typeck/diagnostics.rs).\n * Explanations have full markdown support. Use it, especially to highlight"}, {"sha": "7585238efedfc33acdd9494b0269951aaf3909ec", "filename": "src/doc/rustc/.gitignore", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fdoc%2Frustc%2F.gitignore", "raw_url": "https://github.com/rust-lang/rust/raw/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fdoc%2Frustc%2F.gitignore", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2F.gitignore?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd", "patch": "@@ -0,0 +1 @@\n+book"}, {"sha": "8adc05c5137206ddefc284b601d47d8b85ab0dcb", "filename": "src/doc/rustc/book.toml", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fdoc%2Frustc%2Fbook.toml", "raw_url": "https://github.com/rust-lang/rust/raw/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fdoc%2Frustc%2Fbook.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fbook.toml?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd", "patch": "@@ -0,0 +1,5 @@\n+[book]\n+authors = [\"The Rust Project Developers\"]\n+multilingual = false\n+src = \"src\"\n+title = \"The rustc book\""}, {"sha": "e4c0939fd46369d4ad9102b58dcdb4e59a4d9a02", "filename": "src/doc/rustc/src/SUMMARY.md", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fdoc%2Frustc%2Fsrc%2FSUMMARY.md", "raw_url": "https://github.com/rust-lang/rust/raw/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fdoc%2Frustc%2Fsrc%2FSUMMARY.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2FSUMMARY.md?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd", "patch": "@@ -0,0 +1,16 @@\n+# The Rustc Book\n+\n+- [What is rustc?](what-is-rustc.md)\n+- [Command-line arguments](command-line-arguments.md)\n+- [Lints](lints/index.md)\n+    - [Lint levels](lints/levels.md)\n+    - [Lint Groups](lints/groups.md)\n+    - [Lint listing](lints/listing/index.md)\n+        - [Allowed-by-default lints](lints/listing/allowed-by-default.md)\n+        - [Warn-by-default lints](lints/listing/warn-by-default.md)\n+        - [Deny-by-default lints](lints/listing/deny-by-default.md)\n+- [Codegen options](codegen-options/index.md)\n+- [Targets](targets/index.md)\n+    - [Built-in Targets](targets/built-in.md)\n+    - [Custom Targets](targets/custom.md)\n+- [Contributing to `rustc`](contributing.md)\n\\ No newline at end of file"}, {"sha": "eff09428902e8012669b88ddc87266e06894f238", "filename": "src/doc/rustc/src/codegen-options/index.md", "status": "added", "additions": 209, "deletions": 0, "changes": 209, "blob_url": "https://github.com/rust-lang/rust/blob/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fdoc%2Frustc%2Fsrc%2Fcodegen-options%2Findex.md", "raw_url": "https://github.com/rust-lang/rust/raw/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fdoc%2Frustc%2Fsrc%2Fcodegen-options%2Findex.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Fcodegen-options%2Findex.md?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd", "patch": "@@ -0,0 +1,209 @@\n+# Codegen options\n+\n+All of these options are passed to `rustc` via the `-C` flag, short for \"codegen.\" You can see\n+a version of this list for your exact compiler by running `rustc -C help`.\n+\n+## ar\n+\n+This option is deprecated and does nothing.\n+\n+## linker\n+\n+This flag lets you control which linker `rustc` invokes to link your code.\n+\n+## link-arg=val\n+\n+This flag lets you append a single extra argument to the linker invocation.\n+\n+\"Append\" is significant; you can pass this flag multiple times to add multiple arguments.\n+\n+## link-args\n+\n+This flag lets you append multiple extra arguments to the linker invocation. The\n+options should be separated by spaces.\n+\n+## link-dead-code\n+\n+Normally, the linker will remove dead code. This flag disables this behavior.\n+\n+An example of when this flag might be useful is when trying to construct code coverage\n+metrics.\n+\n+## lto\n+\n+This flag instructs LLVM to use [link time\n+optimizations](https://llvm.org/docs/LinkTimeOptimization.html).\n+\n+It takes one of two values, `thin` and `fat`. 'thin' LTO [is a new feature of\n+LLVM](http://blog.llvm.org/2016/06/thinlto-scalable-and-incremental-lto.html),\n+'fat' referring to the classic version of LTO.\n+\n+## target-cpu\n+\n+This instructs `rustc` to generate code specifically for a particular processor.\n+\n+You can run `rustc --print target-cpus` to see the valid options to pass\n+here. Additionally, `native` can be passed to use the processor of the host\n+machine.\n+\n+## target-feature\n+\n+Individual targets will support different features; this flag lets you control\n+enabling or disabling a feature.\n+\n+To see the valid options and an example of use, run `rustc --print\n+target-features`.\n+\n+## passes\n+\n+This flag can be used to add extra LLVM passes to the compilation.\n+\n+The list must be separated by spaces.\n+\n+## llvm-args\n+\n+This flag can be used to pass a list of arguments directly to LLVM.\n+\n+The list must be separated by spaces.\n+\n+## save-temps\n+\n+`rustc` will generate temporary files during compilation; normally it will\n+delete them after it's done with its work. This option will cause them to be\n+preserved instead of removed.\n+\n+## rpath\n+\n+This option allows you to set the value of\n+[`rpath`](https://en.wikipedia.org/wiki/Rpath).\n+\n+## overflow-checks\n+\n+This flag allows you to control the behavior of integer overflow. This flag\n+can be passed many options:\n+\n+* To turn overflow checks on: `y`, `yes`, or `on`.\n+* To turn overflow checks off: `n`, `no`, or `off`.\n+\n+## no-prepopulate-passes\n+\n+The pass manager comes pre-populated with a list of passes; this flag\n+ensures that list is empty.\n+\n+## no-vectorize-loops\n+\n+By default, `rustc` will attempt to [vectorize\n+loops](https://llvm.org/docs/Vectorizers.html#the-loop-vectorizer). This\n+flag will turn that behavior off.\n+\n+## no-vectorize-slp\n+\n+By default, `rustc` will attempt to vectorize loops using [superword-level\n+parallelism](https://llvm.org/docs/Vectorizers.html#the-slp-vectorizer). This\n+flag will turn that behavior off.\n+\n+## soft-float\n+\n+This option will make `rustc` generate code using \"soft floats.\" By default,\n+a lot of hardware supports floating point instructions, and so the code generated\n+will take advantage of this. \"soft floats\" emulate floating point instructions\n+in software.\n+\n+## prefer-dynamic\n+\n+By default, `rustc` prefers to statically link dependencies. This option will\n+make it use dynamic linking instead.\n+\n+## no-integrated-as\n+\n+LLVM comes with an internal assembler; this option will let you use an\n+external assembler instead.\n+\n+## no-redzone\n+\n+This flag allows you to disable [the\n+red zone](https://en.wikipedia.org/wiki/Red_zone_\\(computing\\)). This flag can\n+be passed many options:\n+\n+* To enable the red zone: `y`, `yes`, or `on`.\n+* To disable it: `n`, `no`, or `off`.\n+\n+## relocation-model\n+\n+This option lets you choose which relocation model to use.\n+\n+To find the valid options for this flag, run `rustc --print relocation-models`.\n+\n+## code-model=val\n+\n+This option lets you choose which code model to use.\n+\n+To find the valid options for this flag, run `rustc --print code-models`.\n+\n+## metadata\n+\n+This option allows you to control the metadata used for symbol mangling.\n+\n+## extra-filename\n+\n+This option allows you to put extra data in each output filename.\n+\n+## codegen-units\n+\n+This flag lets you control how many threads are used when doing\n+code generation.\n+\n+Increasing paralellism may speed up compile times, but may also\n+produce slower code.\n+\n+## remark\n+\n+This flag lets you print remarks for these optimization passes.\n+\n+The list of passes should be separated by spaces.\n+\n+`all` will remark on every pass.\n+\n+## no-stack-check\n+\n+This option is deprecated and does nothing.\n+\n+## debuginfo\n+\n+This flag lets you control debug information:\n+\n+* `0`: no debug info at all\n+* `1`: line tables only\n+* `2`: full debug info\n+\n+## opt-level\n+\n+This flag lets you control the optimization level.\n+\n+* `0`: no optimizations\n+* `1`: basic optimizations\n+* `2`: some optimizations\n+* `3`: all optimizations\n+* `s`: optimize for binary size\n+* `z`: optimize for binary size, but also turn off loop vectorization.\n+\n+## debug-assertions\n+\n+This flag lets you turn `cfg(debug_assertions)` on or off.\n+\n+## inline-threshold\n+\n+This option lets you set the threshold for inlining a function.\n+\n+The default is 225.\n+\n+## panic\n+\n+This option lets you control what happens when the code panics.\n+\n+* `abort`: terminate the process upon panic\n+* `unwind`: unwind the stack upon panic\n+\n+## incremental\n+\n+This flag allows you to enable incremental compilation."}, {"sha": "e2b001832fe31f5e6872e18961168123e5890a74", "filename": "src/doc/rustc/src/command-line-arguments.md", "status": "added", "additions": 116, "deletions": 0, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fdoc%2Frustc%2Fsrc%2Fcommand-line-arguments.md", "raw_url": "https://github.com/rust-lang/rust/raw/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fdoc%2Frustc%2Fsrc%2Fcommand-line-arguments.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Fcommand-line-arguments.md?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd", "patch": "@@ -0,0 +1,116 @@\n+# Command-line arguments\n+\n+Here's a list of command-line arguments to `rustc` and what they do.\n+\n+## `-h`/`--help`: get help\n+\n+This flag will print out help information for `rustc`.\n+\n+## `--cfg`: configure the compilation environment\n+\n+This flag can turn on or off various `#[cfg]` settings.\n+\n+## `-L`: add a directory to the library search path\n+\n+When looking for external crates, a directory passed to this flag will be searched.\n+\n+## `-l`: link the generated crate to a native library\n+\n+This flag allows you to specify linking to a specific native library when building\n+a crate.\n+\n+## `--crate-type`: a list of types of crates for the compiler to emit\n+\n+This instructs `rustc` on which crate type to build.\n+\n+## `--crate-name`: specify the name of the crate being built\n+\n+This informs `rustc` of the name of your crate.\n+\n+## `--emit`: emit output other than a crate\n+\n+Instead of producing a crate, this flag can print out things like the assembly or LLVM-IR.\n+\n+## `--print`: print compiler information\n+\n+This flag prints out various information about the compiler.\n+\n+## `-g`: include debug information\n+\n+A synonym for `-C debug-level=2`.\n+\n+## `-O`: optimize your code\n+\n+A synonym for `-C opt-level=2`.\n+\n+## `-o`: filename of the output\n+\n+This flag controls the output filename.\n+\n+## `--out-dir`: directory to write the output in\n+\n+The outputted crate will be written to this directory.\n+\n+## `--explain`: provide a detailed explanation of an error message\n+\n+Each error of `rustc`'s comes with an error code; this will print\n+out a longer explanation of a given error.\n+\n+## `--test`: build a test harness\n+\n+When compiling this crate, `rustc` will ignore your `main` function\n+and instead produce a test harness.\n+\n+## `--target`: select a target triple to build\n+\n+This controls which [target](targets/index.html) to produce.\n+\n+## `-W`: set lint warnings\n+\n+This flag will set which lints should be set to the [warn level](lints/levels.html#warn).\n+\n+## `-A`: set lint allowed\n+\n+This flag will set which lints should be set to the [allow level](lints/levels.html#allow).\n+\n+## `-D`: set lint denied\n+\n+This flag will set which lints should be set to the [deny level](lints/levels.html#deny).\n+\n+## `-F`: set lint forbidden\n+\n+This flag will set which lints should be set to the [forbid level](lints/levels.html#forbid).\n+\n+## `--cap-lints`: set the most restrictive lint level\n+\n+This flag lets you 'cap' lints, for more, [see here](lints/levels.html#capping-lints).\n+\n+## `-C`/`--codegen`: code generation options\n+\n+This flag will allow you to set [codegen options](codegen-options/index.html).\n+\n+## `-V`/`--version`: print a version\n+\n+This flag will print out `rustc`'s version.\n+\n+## `-v`/`--verbose`: use verbose output\n+\n+This flag, when combined with other flags, makes them produce extra output.\n+\n+## `--extern`: specify where an external library is located\n+\n+This flag allows you to pass the name and location of an external crate that will\n+be linked into the crate you're buildling.\n+\n+## `--sysroot`: Override the system root\n+\n+The \"sysroot\" is where `rustc` looks for the crates that come with the Rust\n+distribution; this flag allows that to be overridden.\n+\n+## `--error-format`: control how errors are produced\n+\n+This flag lets you control the format of errors.\n+\n+## `--color`: configure coloring of output\n+\n+This flag lets you control color settings of the output."}, {"sha": "fcb8e6b27dbf0d9d56522df277ee0b20778eb42d", "filename": "src/doc/rustc/src/contributing.md", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fdoc%2Frustc%2Fsrc%2Fcontributing.md", "raw_url": "https://github.com/rust-lang/rust/raw/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fdoc%2Frustc%2Fsrc%2Fcontributing.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Fcontributing.md?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd", "patch": "@@ -0,0 +1,6 @@\n+# Contributing to rustc\n+\n+We'd love to have your help improving `rustc`! To that end, we've written [a\n+whole book](https://rust-lang-nursery.github.io/rustc-guide/) on its\n+internals, how it works, and how to get started working on it. To learn\n+more, you'll want to check that out.\n\\ No newline at end of file"}, {"sha": "46b717f3387d2ce95cb4c0d4d7f25ed0c1deac78", "filename": "src/doc/rustc/src/lints/groups.md", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fdoc%2Frustc%2Fsrc%2Flints%2Fgroups.md", "raw_url": "https://github.com/rust-lang/rust/raw/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fdoc%2Frustc%2Fsrc%2Flints%2Fgroups.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Flints%2Fgroups.md?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd", "patch": "@@ -0,0 +1,29 @@\n+# Lint Groups\n+\n+`rustc` has the concept of a \"lint group\", where you can toggle several warnings\n+through one name.\n+\n+For example, the `nonstandard-style` lint sets `non-camel-case-types`,\n+`non-snake-case`, and `non-upper-case-globals` all at once. So these are\n+equivalent:\n+\n+```bash\n+$ rustc -D nonstandard-style\n+$ rustc -D non-camel-case-types -D non-snake-case -D non-upper-case-globals\n+```\n+\n+Here's a list of each lint group, and the lints that they are made up of:\n+\n+| group               | description                                                   | lints                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |\n+|---------------------|---------------------------------------------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n+| nonstandard-style   | Violation of standard naming conventions                      | non-camel-case-types, non-snake-case, non-upper-case-globals                                                                                                                                                                                                                                                                                                                                                                                                                           |\n+| warnings            | all lints that would be issuing warnings                      | all lints that would be issuing warnings                                                                                                                                                                                                                                                                                                                                                                                                                                               |\n+| edition-2018        | Lints that will be turned into errors in Rust 2018            | tyvar-behind-raw-pointer                                                                                                                                                                                                                                                                                                                                                                                                                                                               |\n+| rust-2018-idioms    | Lints to nudge you toward idiomatic features of Rust 2018     | bare-trait-object, unreachable-pub                                                                                                                                                                                                                                                                                                                                                                                                                                                     |\n+| unused              | These lints detect things being declared but not used         | unused-imports, unused-variables, unused-assignments, dead-code, unused-mut, unreachable-code, unreachable-patterns, unused-must-use, unused-unsafe, path-statements, unused-attributes, unused-macros, unused-allocation, unused-doc-comment, unused-extern-crates, unused-features, unused-parens                                                                                                                                                                                    |\n+| future-incompatible | Lints that detect code that has future-compatibility problems | private-in-public, pub-use-of-private-extern-crate, patterns-in-fns-without-body, safe-extern-statics, invalid-type-param-default, legacy-directory-ownership, legacy-imports, legacy-constructor-visibility, missing-fragment-specifier, illegal-floating-point-literal-pattern, anonymous-parameters, parenthesized-params-in-types-and-modules, late-bound-lifetime-arguments, safe-packed-borrows, incoherent-fundamental-impls, tyvar-behind-raw-pointer, unstable-name-collision |\n+\n+Additionally, there's a `bad-style` lint group that's a deprecated alias for `nonstandard-style`.\n+\n+Finally, you can also see the table above by invoking `rustc -W help`. This will give you the exact values for the specific\n+compiler you have installed.\n\\ No newline at end of file"}, {"sha": "bf345a24389d2bebc9d62b6777e64cf53a231e01", "filename": "src/doc/rustc/src/lints/index.md", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fdoc%2Frustc%2Fsrc%2Flints%2Findex.md", "raw_url": "https://github.com/rust-lang/rust/raw/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fdoc%2Frustc%2Fsrc%2Flints%2Findex.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Flints%2Findex.md?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd", "patch": "@@ -0,0 +1,28 @@\n+# Lints\n+\n+In software, a \"lint\" is a tool used to help improve your source code. The\n+Rust compiler contains a number of lints, and when it compiles your code, it will\n+also run the lints. These lints may produce a warning, an error, or nothing at all,\n+depending on how you've configured things.\n+\n+Here's a small example:\n+\n+```bash\n+$ cat main.rs\n+fn main() {\n+    let x = 5;\n+}\n+> rustc main.rs\n+warning: unused variable: `x`\n+ --> main.rs:2:9\n+  |\n+2 |     let x = 5;\n+  |         ^\n+  |\n+  = note: #[warn(unused_variables)] on by default\n+  = note: to avoid this warning, consider using `_x` instead\n+```\n+\n+This is the `unused_variables` lint, and it tells you that you've introduced\n+a variable that you don't use in your code. That's not *wrong*, so it's not\n+an error, but it might be a bug, so you get a warning."}, {"sha": "19bb6707d2285ffe357011e4a6f4796d6703a60b", "filename": "src/doc/rustc/src/lints/levels.md", "status": "added", "additions": 252, "deletions": 0, "changes": 252, "blob_url": "https://github.com/rust-lang/rust/blob/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fdoc%2Frustc%2Fsrc%2Flints%2Flevels.md", "raw_url": "https://github.com/rust-lang/rust/raw/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fdoc%2Frustc%2Fsrc%2Flints%2Flevels.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Flints%2Flevels.md?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd", "patch": "@@ -0,0 +1,252 @@\n+# Lint levels\n+\n+In `rustc`, lints are divided into four *levels*:\n+\n+1. allow\n+2. warn\n+3. deny\n+4. forbid\n+\n+Each lint has a default level (explained in the lint listing later in this\n+chapter), and the compiler has a default warning level. First, let's explain\n+what these levels mean, and then we'll talk about configuration.\n+\n+## allow\n+\n+These lints exist, but by default, do nothing. For example, consider this\n+source:\n+\n+```rust\n+pub fn foo() {}\n+```\n+\n+Compiling this file produces no warnings:\n+\n+```bash\n+$ rustc lib.rs --crate-type=lib\n+$\n+```\n+\n+But this code violates the `missing_docs` lint.\n+\n+These lints exist mostly to be manually turned on via configuration, as we'll\n+talk about later in this section.\n+\n+## warn\n+\n+The 'warn' lint level will produce a warning if you violate the lint. For example,\n+this code runs afoul of the `unused_variable` lint:\n+\n+```rust\n+pub fn foo() {\n+    let x = 5;\n+}\n+```\n+\n+This will produce this warning:\n+\n+```console\n+$ rustc lib.rs --crate-type=lib\n+warning: unused variable: `x`\n+ --> lib.rs:2:9\n+  |\n+2 |     let x = 5;\n+  |         ^\n+  |\n+  = note: #[warn(unused_variables)] on by default\n+  = note: to avoid this warning, consider using `_x` instead\n+```\n+\n+## deny\n+\n+A 'deny' lint produces an error if you violate it. For example, this code\n+runs into the `exceeding_bitshifts` lint.\n+\n+```rust,ignore\n+fn main() {\n+    100u8 << 10;\n+}\n+```\n+\n+```bash\n+> rustc main.rs\n+error: bitshift exceeds the type's number of bits\n+ --> main.rs:2:13\n+  |\n+2 |     100u8 << 10;\n+  |     ^^^^^^^^^^^\n+  |\n+  = note: #[deny(exceeding_bitshifts)] on by default\n+```\n+\n+What's the difference between an error from a lint and a regular old error?\n+Lints are configurable via levels, so in a similar way to 'allow' lints,\n+warnings that are 'deny' by default let you allow them. Similarly, you may\n+wish to set up a lint that is `warn` by default to produce an error instead.\n+This lint level gives you that.\n+\n+## forbid\n+\n+'forbid' is a special lint level that's stronger than 'deny'. It's the same\n+as 'deny' in that a lint at this level will produce an error, but unlike the\n+'deny' level, the 'forbid' level can not be overridden to be anything lower\n+than an error.\n+\n+## Configuring warning levels\n+\n+Remember our `missing_docs` example from the 'allow' lint level?\n+\n+```bash\n+$ cat lib.rs\n+pub fn foo() {}\n+$ rustc lib.rs --crate-type=lib\n+$\n+```\n+\n+We can configure this lint to operate at a higher level, both with\n+compiler flags, as well as with an attribute in the source code.\n+\n+You can also \"cap\" lints so that the compiler can choose to ignore\n+certain lint levels. We'll talk about that last.\n+\n+### Via compiler flag\n+\n+The `-A`, `-W`, `-D`, and `-F` flags let you turn one or more lints\n+into allowed, warning, deny, or forbid levels, like this:\n+\n+```bash\n+$ rustc lib.rs --crate-type=lib -W missing-docs\n+warning: missing documentation for crate\n+ --> lib.rs:1:1\n+  |\n+1 | pub fn foo() {}\n+  | ^^^^^^^^^^^^\n+  |\n+  = note: requested on the command line with `-W missing-docs`\n+\n+warning: missing documentation for a function\n+ --> lib.rs:1:1\n+  |\n+1 | pub fn foo() {}\n+  | ^^^^^^^^^^^^\n+> rustc lib.rs --crate-type=lib -D missing-docs\n+error: missing documentation for crate\n+ --> lib.rs:1:1\n+  |\n+1 | pub fn foo() {}\n+  | ^^^^^^^^^^^^\n+  |\n+  = note: requested on the command line with `-D missing-docs`\n+\n+error: missing documentation for a function\n+ --> lib.rs:1:1\n+  |\n+1 | pub fn foo() {}\n+  | ^^^^^^^^^^^^\n+\n+error: aborting due to 2 previous errors\n+```\n+\n+You can also pass each flag more than once for changing multiple lints:\n+\n+```bash\n+rustc lib.rs --crate-type=lib -D missing-docs -D unused-variables\n+```\n+\n+And of course, you can mix these four flags together:\n+\n+```bash\n+rustc lib.rs --crate-type=lib -D missing-docs -A unused-variables\n+```\n+\n+### Via an attribute\n+\n+You can also modify the lint level with a crate-wide attribute:\n+\n+```bash\n+> cat lib.rs\n+#![warn(missing_docs)]\n+\n+pub fn foo() {}\n+$ rustc lib.rs --crate-type=lib\n+warning: missing documentation for crate\n+ --> lib.rs:1:1\n+  |\n+1 | / #![warn(missing_docs)]\n+2 | |\n+3 | | pub fn foo() {}\n+  | |_______________^\n+  |\n+note: lint level defined here\n+ --> lib.rs:1:9\n+  |\n+1 | #![warn(missing_docs)]\n+  |         ^^^^^^^^^^^^\n+\n+warning: missing documentation for a function\n+ --> lib.rs:3:1\n+  |\n+3 | pub fn foo() {}\n+  | ^^^^^^^^^^^^\n+```\n+\n+All four, `warn`, `allow`, `deny`, and `forbid` all work this way.\n+\n+You can also pass in multiple lints per attribute:\n+\n+```rust\n+#![warn(missing_docs, unused_variables)]\n+\n+pub fn foo() {}\n+```\n+\n+And use multiple attributes together:\n+\n+```rust\n+#![warn(missing_docs)]\n+#![deny(unused_variables)]\n+\n+pub fn foo() {}\n+```\n+\n+### Capping lints\n+\n+`rustc` supports a flag, `--cap-lints LEVEL` that sets the \"lint cap level.\"\n+This is the maximum level for all lints. So for example, if we take our\n+code sample from the \"deny\" lint level above:\n+\n+```rust,ignore\n+fn main() {\n+    100u8 << 10;\n+}\n+```\n+\n+And we compile it, capping lints to warn:\n+\n+```bash\n+$ rustc lib.rs --cap-lints warn\n+warning: bitshift exceeds the type's number of bits\n+ --> lib.rs:2:5\n+  |\n+2 |     100u8 << 10;\n+  |     ^^^^^^^^^^^\n+  |\n+  = note: #[warn(exceeding_bitshifts)] on by default\n+\n+warning: this expression will panic at run-time\n+ --> lib.rs:2:5\n+  |\n+2 |     100u8 << 10;\n+  |     ^^^^^^^^^^^ attempt to shift left with overflow\n+```\n+\n+It now only warns, rather than errors. We can go further and allow all lints:\n+\n+```bash\n+$ rustc lib.rs --cap-lints allow\n+$\n+```\n+\n+This feature is used heavily by Cargo; it will pass `--cap-lints allow` when\n+compiling your dependencies, so that if they have any warnings, they do not\n+pollute the output of your build."}, {"sha": "7768b41f85ee44c7d906a06fc7d6bb84a7057f99", "filename": "src/doc/rustc/src/lints/listing/allowed-by-default.md", "status": "added", "additions": 453, "deletions": 0, "changes": 453, "blob_url": "https://github.com/rust-lang/rust/blob/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fdoc%2Frustc%2Fsrc%2Flints%2Flisting%2Fallowed-by-default.md", "raw_url": "https://github.com/rust-lang/rust/raw/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fdoc%2Frustc%2Fsrc%2Flints%2Flisting%2Fallowed-by-default.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Flints%2Flisting%2Fallowed-by-default.md?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd", "patch": "@@ -0,0 +1,453 @@\n+# Allowed-by-default lints\n+\n+These lints are all set to the 'allow' level by default. As such, they won't show up\n+unless you set them to a higher lint level with a flag or attribute.\n+\n+## anonymous-parameters\n+\n+This lint detects anonymous parameters. Some example code that triggers this lint:\n+\n+```rust\n+trait Foo {\n+    fn foo(usize);\n+}\n+```\n+\n+When set to 'deny', this will produce:\n+\n+```text\n+error: use of deprecated anonymous parameter\n+ --> src/lib.rs:5:11\n+  |\n+5 |     fn foo(usize);\n+  |           ^\n+  |\n+  = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+  = note: for more information, see issue #41686 <https://github.com/rust-lang/rust/issues/41686>\n+```\n+\n+This syntax is mostly a historical accident, and can be worked around quite\n+easily:\n+\n+```rust\n+trait Foo {\n+    fn foo(_: usize);\n+}\n+```\n+\n+## bare-trait-object\n+\n+This lint suggests using `dyn Trait` for trait objects. Some example code\n+that triggers this lint:\n+\n+```rust\n+#![feature(dyn_trait)]\n+\n+trait Trait { }\n+\n+fn takes_trait_object(_: Box<Trait>) {\n+}\n+```\n+\n+When set to 'deny', this will produce:\n+\n+```text\n+error: trait objects without an explicit `dyn` are deprecated\n+ --> src/lib.rs:7:30\n+  |\n+7 | fn takes_trait_object(_: Box<Trait>) {\n+  |                              ^^^^^ help: use `dyn`: `dyn Trait`\n+  |\n+```\n+\n+To fix it, do as the help message suggests:\n+\n+```rust\n+#![feature(dyn_trait)]\n+#![deny(bare_trait_objects)]\n+\n+trait Trait { }\n+\n+fn takes_trait_object(_: Box<dyn Trait>) {\n+}\n+```\n+\n+## box-pointers\n+\n+This lints use of the Box type. Some example code that triggers this lint:\n+\n+```rust\n+struct Foo {\n+    x: Box<isize>,\n+}\n+```\n+\n+When set to 'deny', this will produce:\n+\n+```text\n+error: type uses owned (Box type) pointers: std::boxed::Box<isize>\n+ --> src/lib.rs:6:5\n+  |\n+6 |     x: Box<isize> //~ ERROR type uses owned\n+  |     ^^^^^^^^^^^^^\n+  |\n+```\n+\n+This lint is mostly historical, and not particularly useful. `Box<T>` used to\n+be built into the language, and the only way to do heap allocation. Today's\n+Rust can call into other allocators, etc.\n+\n+## elided-lifetime-in-path\n+\n+This lint detects the use of hidden lifetime parameters. Some example code\n+that triggers this lint:\n+\n+```rust\n+struct Foo<'a> {\n+    x: &'a u32\n+}\n+\n+fn foo(x: &Foo) {\n+}\n+```\n+\n+When set to 'deny', this will produce:\n+\n+```text\n+error: hidden lifetime parameters are deprecated, try `Foo<'_>`\n+ --> src/lib.rs:5:12\n+  |\n+5 | fn foo(x: &Foo) {\n+  |            ^^^\n+  |\n+```\n+\n+Lifetime elision elides this lifetime, but that is being deprecated.\n+\n+## missing-copy-implementations\n+\n+This lint detects potentially-forgotten implementations of `Copy`. Some\n+example code that triggers this lint:\n+\n+```rust\n+pub struct Foo {\n+    pub field: i32\n+}\n+```\n+\n+When set to 'deny', this will produce:\n+\n+```text\n+error: type could implement `Copy`; consider adding `impl Copy`\n+ --> src/main.rs:3:1\n+  |\n+3 | / pub struct Foo { //~ ERROR type could implement `Copy`; consider adding `impl Copy`\n+4 | |     pub field: i32\n+5 | | }\n+  | |_^\n+  |\n+```\n+\n+You can fix the lint by deriving `Copy`.\n+\n+This lint is set to 'allow' because this code isn't bad; it's common to write\n+newtypes like this specifically so that a `Copy` type is no longer `Copy`.\n+\n+## missing-debug-implementations\n+\n+This lint detects missing implementations of `fmt::Debug`. Some example code\n+that triggers this lint:\n+\n+```rust\n+pub struct Foo;\n+```\n+\n+When set to 'deny', this will produce:\n+\n+```text\n+error: type does not implement `fmt::Debug`; consider adding #[derive(Debug)] or a manual implementation\n+ --> src/main.rs:3:1\n+  |\n+3 | pub struct Foo;\n+  | ^^^^^^^^^^^^^^^\n+  |\n+```\n+\n+You can fix the lint by deriving `Debug`.\n+\n+## missing-docs\n+\n+This lint detects missing documentation for public items. Some example code\n+that triggers this lint:\n+\n+```rust\n+pub fn foo() {}\n+```\n+\n+When set to 'deny', this will produce:\n+\n+```text\n+error: missing documentation for crate\n+ --> src/main.rs:1:1\n+  |\n+1 | / #![deny(missing_docs)]\n+2 | |\n+3 | | pub fn foo() {}\n+4 | |\n+5 | | fn main() {}\n+  | |____________^\n+  |\n+\n+error: missing documentation for a function\n+ --> src/main.rs:3:1\n+  |\n+3 | pub fn foo() {}\n+  | ^^^^^^^^^^^^\n+\n+```\n+\n+To fix the lint, add documentation to all items.\n+\n+## single-use-lifetime\n+\n+This lint detects lifetimes that are only used once. Some example code that\n+triggers this lint:\n+\n+```rust\n+struct Foo<'x> {\n+    x: &'x u32\n+}\n+```\n+\n+When set to 'deny', this will produce:\n+\n+```text\n+error: lifetime name `'x` only used once\n+ --> src/main.rs:3:12\n+  |\n+3 | struct Foo<'x> {\n+  |            ^^\n+  |\n+```\n+\n+## trivial-casts\n+\n+This lint detects trivial casts which could be removed. Some example code\n+that triggers this lint:\n+\n+```rust\n+let x: &u32 = &42;\n+let _ = x as *const u32;\n+```\n+\n+When set to 'deny', this will produce:\n+\n+```text\n+error: trivial cast: `&u32` as `*const u32`. Cast can be replaced by coercion, this might require type ascription or a temporary variable\n+ --> src/main.rs:5:13\n+  |\n+5 |     let _ = x as *const u32;\n+  |             ^^^^^^^^^^^^^^^\n+  |\n+note: lint level defined here\n+ --> src/main.rs:1:9\n+  |\n+1 | #![deny(trivial_casts)]\n+  |         ^^^^^^^^^^^^^\n+```\n+\n+## trivial-numeric-casts\n+\n+This lint detects trivial casts of numeric types which could be removed. Some\n+example code that triggers this lint:\n+\n+```rust\n+let x = 42i32 as i32;\n+```\n+\n+When set to 'deny', this will produce:\n+\n+```text\n+error: trivial numeric cast: `i32` as `i32`. Cast can be replaced by coercion, this might require type ascription or a temporary variable\n+ --> src/main.rs:4:13\n+  |\n+4 |     let x = 42i32 as i32;\n+  |             ^^^^^^^^^^^^\n+  |\n+```\n+\n+## unreachable-pub\n+\n+This lint triggers for `pub` items not reachable from the crate root. Some\n+example code that triggers this lint:\n+\n+```rust\n+mod foo {\n+    pub mod bar {\n+        \n+    }\n+}\n+```\n+\n+When set to 'deny', this will produce:\n+\n+```text\n+error: unreachable `pub` item\n+ --> src/main.rs:4:5\n+  |\n+4 |     pub mod bar {\n+  |     ---^^^^^^^^\n+  |     |\n+  |     help: consider restricting its visibility: `pub(crate)`\n+  |\n+```\n+\n+## unsafe-code\n+\n+This lint catches usage of `unsafe` code. Some example code that triggers this lint:\n+\n+```rust\n+fn main() {\n+    unsafe {\n+\n+    }\n+}\n+```\n+\n+When set to 'deny', this will produce:\n+\n+```text\n+error: usage of an `unsafe` block\n+ --> src/main.rs:4:5\n+  |\n+4 | /     unsafe {\n+5 | |         \n+6 | |     }\n+  | |_____^\n+  |\n+```\n+\n+## unstable-features\n+\n+This lint is deprecated and no longer used.\n+\n+## unused-extern-crates\n+\n+This lint guards against `extern crate` items that are never used. Some\n+example code that triggers this lint:\n+\n+```rust,ignore\n+extern crate semver;\n+```\n+\n+When set to 'deny', this will produce:\n+\n+```text\n+error: unused extern crate\n+ --> src/main.rs:3:1\n+  |\n+3 | extern crate semver;\n+  | ^^^^^^^^^^^^^^^^^^^^\n+  |\n+```\n+\n+## unused-import-braces\n+\n+This lint catches unnecessary braces around an imported item. Some example\n+code that triggers this lint:\n+\n+```rust\n+use test::{A};\n+\n+pub mod test {\n+    pub struct A;\n+}\n+# fn main() {}\n+```\n+\n+When set to 'deny', this will produce:\n+\n+```text\n+error: braces around A is unnecessary\n+ --> src/main.rs:3:1\n+  |\n+3 | use test::{A};\n+  | ^^^^^^^^^^^^^^\n+  |\n+```\n+\n+To fix it, `use test::A;`\n+\n+## unused-qualifications\n+\n+This lint detects unnecessarily qualified names. Some example code that triggers this lint:\n+\n+```rust\n+mod foo {\n+    pub fn bar() {}\n+}\n+\n+fn main() {\n+    use foo::bar;\n+    foo::bar();\n+}\n+```\n+\n+When set to 'deny', this will produce:\n+\n+```text\n+error: unnecessary qualification\n+ --> src/main.rs:9:5\n+  |\n+9 |     foo::bar();\n+  |     ^^^^^^^^\n+  |\n+```\n+\n+You can call `bar()` directly, without the `foo::`.\n+\n+## unused-results\n+\n+This lint checks for the unused result of an expression in a statement. Some\n+example code that triggers this lint:\n+\n+```rust,no_run\n+fn foo<T>() -> T { panic!() }\n+\n+fn main() {\n+    foo::<usize>();\n+}\n+```\n+\n+When set to 'deny', this will produce:\n+\n+```text\n+error: unused result\n+ --> src/main.rs:6:5\n+  |\n+6 |     foo::<usize>();\n+  |     ^^^^^^^^^^^^^^^\n+  |\n+```\n+\n+## variant-size-differences\n+\n+This lint detects enums with widely varying variant sizes. Some example code that triggers this lint:\n+\n+```rust\n+enum En {\n+    V0(u8),\n+    VBig([u8; 1024]),\n+}\n+```\n+\n+When set to 'deny', this will produce:\n+\n+```text\n+error: enum variant is more than three times larger (1024 bytes) than the next largest\n+ --> src/main.rs:5:5\n+  |\n+5 |     VBig([u8; 1024]),   //~ ERROR variant is more than three times larger\n+  |     ^^^^^^^^^^^^^^^^\n+  |\n+```"}, {"sha": "3a85a40fd1fdb9af606df8414f8289b4330949ee", "filename": "src/doc/rustc/src/lints/listing/deny-by-default.md", "status": "added", "additions": 245, "deletions": 0, "changes": 245, "blob_url": "https://github.com/rust-lang/rust/blob/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fdoc%2Frustc%2Fsrc%2Flints%2Flisting%2Fdeny-by-default.md", "raw_url": "https://github.com/rust-lang/rust/raw/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fdoc%2Frustc%2Fsrc%2Flints%2Flisting%2Fdeny-by-default.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Flints%2Flisting%2Fdeny-by-default.md?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd", "patch": "@@ -0,0 +1,245 @@\n+# Deny-by-default lints\n+\n+These lints are all set to the 'deny' level by default.\n+\n+## exceeding-bitshifts\n+\n+This lint detects that a shift exceeds the type's number of bits. Some\n+example code that triggers this lint:\n+\n+```rust,ignore\n+1_i32 << 32;\n+```\n+\n+This will produce:\n+\n+```text\n+error: bitshift exceeds the type's number of bits\n+ --> src/main.rs:2:5\n+  |\n+2 |     1_i32 << 32;\n+  |     ^^^^^^^^^^^\n+  |\n+```\n+\n+## invalid-type-param-default\n+\n+This lint detects type parameter default erroneously allowed in invalid location. Some\n+example code that triggers this lint:\n+\n+```rust,ignore\n+fn foo<T=i32>(t: T) {}\n+```\n+\n+This will produce:\n+\n+```text\n+error: defaults for type parameters are only allowed in `struct`, `enum`, `type`, or `trait` definitions.\n+ --> src/main.rs:4:8\n+  |\n+4 | fn foo<T=i32>(t: T) {}\n+  |        ^\n+  |\n+  = note: #[deny(invalid_type_param_default)] on by default\n+  = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+  = note: for more information, see issue #36887 <https://github.com/rust-lang/rust/issues/36887>\n+```\n+\n+## legacy-constructor-visibility\n+\n+[RFC 1506](https://github.com/rust-lang/rfcs/blob/master/text/1506-adt-kinds.md) modified some\n+visibility rules, and changed the visibility of struct constructors. Some\n+example code that triggers this lint:\n+\n+```rust,ignore\n+mod m {\n+    pub struct S(u8);\n+    \n+    fn f() {\n+        // this is trying to use S from the 'use' line, but becuase the `u8` is\n+        // not pub, it is private\n+        ::S;\n+    }\n+}\n+\n+use m::S;\n+```\n+\n+This will produce:\n+\n+```text\n+error: private struct constructors are not usable through re-exports in outer modules\n+ --> src/main.rs:5:9\n+  |\n+5 |         ::S;\n+  |         ^^^\n+  |\n+  = note: #[deny(legacy_constructor_visibility)] on by default\n+  = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+  = note: for more information, see issue #39207 <https://github.com/rust-lang/rust/issues/39207>\n+```\n+\n+\n+## legacy-directory-ownership\n+\n+The legacy_directory_ownership warning is issued when\n+\n+* There is a non-inline module with a #[path] attribute (e.g. #[path = \"foo.rs\"] mod bar;),\n+* The module's file (\"foo.rs\" in the above example) is not named \"mod.rs\", and\n+* The module's file contains a non-inline child module without a #[path] attribute.\n+\n+The warning can be fixed by renaming the parent module to \"mod.rs\" and moving\n+it into its own directory if appropriate.\n+\n+\n+## missing-fragment-specifier\n+\n+The missing_fragment_specifier warning is issued when an unused pattern in a\n+`macro_rules!` macro definition has a meta-variable (e.g. `$e`) that is not\n+followed by a fragment specifier (e.g. `:expr`).\n+\n+This warning can always be fixed by removing the unused pattern in the\n+`macro_rules!` macro definition.\n+\n+## mutable-transmutes\n+\n+This lint catches transmuting from `&T` to `&mut T` becuase it is undefined\n+behavior. Some example code that triggers this lint:\n+\n+```rust,ignore\n+unsafe {\n+    let y = std::mem::transmute::<&i32, &mut i32>(&5);\n+}\n+```\n+\n+This will produce:\n+\n+```text\n+error: mutating transmuted &mut T from &T may cause undefined behavior, consider instead using an UnsafeCell\n+ --> src/main.rs:3:17\n+  |\n+3 |         let y = std::mem::transmute::<&i32, &mut i32>(&5);\n+  |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+  |\n+```\n+\n+\n+## no-mangle-const-items\n+\n+This lint detects any `const` items with the `#[no_mangle]` attribute.\n+Constants do not have their symbols exported, and therefore, this probably\n+means you meant to use a `static`, not a `const`. Some example code that\n+triggers this lint:\n+\n+```rust,ignore\n+#[no_mangle]\n+const FOO: i32 = 5;\n+```\n+\n+This will produce:\n+\n+```text\n+error: const items should never be #[no_mangle]\n+ --> src/main.rs:3:1\n+  |\n+3 | const FOO: i32 = 5;\n+  | -----^^^^^^^^^^^^^^\n+  | |\n+  | help: try a static value: `pub static`\n+  |\n+```\n+\n+## parenthesized-params-in-types-and-modules\n+\n+This lint detects incorrect parentheses. Some example code that triggers this\n+lint:\n+\n+```rust,ignore\n+let x = 5 as usize();\n+```\n+\n+This will produce:\n+\n+```text\n+error: parenthesized parameters may only be used with a trait\n+ --> src/main.rs:2:21\n+  |\n+2 |   let x = 5 as usize();\n+  |                     ^^\n+  |\n+  = note: #[deny(parenthesized_params_in_types_and_modules)] on by default\n+  = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+  = note: for more information, see issue #42238 <https://github.com/rust-lang/rust/issues/42238>\n+```\n+\n+To fix it, remove the `()`s.\n+\n+## pub-use-of-private-extern-crate\n+\n+This lint detects a specific situation of re-exporting a private `extern crate`;\n+\n+## safe-extern-statics\n+\n+In older versions of Rust, there was a soundness issue where `extern static`s were allowed\n+to be accessed in safe code. This lint now catches and denies this kind of code.\n+\n+## unknown-crate-types\n+\n+This lint detects an unknown crate type found in a `#[crate_type]` directive. Some\n+example code that triggers this lint:\n+\n+```rust,ignore\n+#![crate_type=\"lol\"]\n+```\n+\n+This will produce:\n+\n+```text\n+error: invalid `crate_type` value\n+ --> src/lib.rs:1:1\n+  |\n+1 | #![crate_type=\"lol\"]\n+  | ^^^^^^^^^^^^^^^^^^^^\n+  |\n+```\n+\n+## incoherent-fundamental-impls\n+\n+This lint detects potentially-conflicting impls that were erroneously allowed. Some\n+example code that triggers this lint:\n+\n+```rust,ignore\n+pub trait Trait1<X> {\n+    type Output;\n+}\n+\n+pub trait Trait2<X> {}\n+\n+pub struct A;\n+\n+impl<X, T> Trait1<X> for T where T: Trait2<X> {\n+    type Output = ();\n+}\n+\n+impl<X> Trait1<Box<X>> for A {\n+    type Output = i32;\n+}\n+```\n+\n+This will produce:\n+\n+```text\n+error: conflicting implementations of trait `Trait1<std::boxed::Box<_>>` for type `A`: (E0119)\n+  --> src/main.rs:13:1\n+   |\n+9  | impl<X, T> Trait1<X> for T where T: Trait2<X> {\n+   | --------------------------------------------- first implementation here\n+...\n+13 | impl<X> Trait1<Box<X>> for A {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ conflicting implementation for `A`\n+   |\n+   = note: #[deny(incoherent_fundamental_impls)] on by default\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #46205 <https://github.com/rust-lang/rust/issues/46205>\n+   = note: downstream crates may implement trait `Trait2<std::boxed::Box<_>>` for type `A`\n+```"}, {"sha": "18cd2fe32a3cc75707effe23e285c4d187d5373f", "filename": "src/doc/rustc/src/lints/listing/index.md", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fdoc%2Frustc%2Fsrc%2Flints%2Flisting%2Findex.md", "raw_url": "https://github.com/rust-lang/rust/raw/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fdoc%2Frustc%2Fsrc%2Flints%2Flisting%2Findex.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Flints%2Flisting%2Findex.md?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd", "patch": "@@ -0,0 +1,5 @@\n+# Lint listing\n+\n+This section lists out all of the lints, grouped by their default lint levels.\n+\n+You can also see this list by running `rustc -W help`.\n\\ No newline at end of file"}, {"sha": "b49708ff6adcd2e11fb0276eb318904b22ba082c", "filename": "src/doc/rustc/src/lints/listing/warn-by-default.md", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fdoc%2Frustc%2Fsrc%2Flints%2Flisting%2Fwarn-by-default.md", "raw_url": "https://github.com/rust-lang/rust/raw/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fdoc%2Frustc%2Fsrc%2Flints%2Flisting%2Fwarn-by-default.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Flints%2Flisting%2Fwarn-by-default.md?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd"}, {"sha": "8620346e5b7480fcb5eb5240fdfc9ee6c9c42a17", "filename": "src/doc/rustc/src/targets/built-in.md", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fdoc%2Frustc%2Fsrc%2Ftargets%2Fbuilt-in.md", "raw_url": "https://github.com/rust-lang/rust/raw/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fdoc%2Frustc%2Fsrc%2Ftargets%2Fbuilt-in.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Ftargets%2Fbuilt-in.md?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd"}, {"sha": "0691afc60eae12c5b4dcb860aa586b2be92cd2ca", "filename": "src/doc/rustc/src/targets/custom.md", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fdoc%2Frustc%2Fsrc%2Ftargets%2Fcustom.md", "raw_url": "https://github.com/rust-lang/rust/raw/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fdoc%2Frustc%2Fsrc%2Ftargets%2Fcustom.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Ftargets%2Fcustom.md?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd"}, {"sha": "07e3a79471f5b5f4d877ed2129ef782df76fbdc9", "filename": "src/doc/rustc/src/targets/index.md", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fdoc%2Frustc%2Fsrc%2Ftargets%2Findex.md", "raw_url": "https://github.com/rust-lang/rust/raw/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fdoc%2Frustc%2Fsrc%2Ftargets%2Findex.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Ftargets%2Findex.md?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd"}, {"sha": "bed1b71c24e00132f7211802645949d8a2e081c2", "filename": "src/doc/rustc/src/what-is-rustc.md", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fdoc%2Frustc%2Fsrc%2Fwhat-is-rustc.md", "raw_url": "https://github.com/rust-lang/rust/raw/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fdoc%2Frustc%2Fsrc%2Fwhat-is-rustc.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Fwhat-is-rustc.md?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd"}, {"sha": "46528187c11754eecbf2be1e59434bb2a3acaec5", "filename": "src/doc/rustdoc/src/SUMMARY.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fdoc%2Frustdoc%2Fsrc%2FSUMMARY.md", "raw_url": "https://github.com/rust-lang/rust/raw/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fdoc%2Frustdoc%2Fsrc%2FSUMMARY.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustdoc%2Fsrc%2FSUMMARY.md?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd"}, {"sha": "417608cc5ca0a3e57f76c4cde1c28bc0addfabc3", "filename": "src/doc/rustdoc/src/command-line-arguments.md", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fdoc%2Frustdoc%2Fsrc%2Fcommand-line-arguments.md", "raw_url": "https://github.com/rust-lang/rust/raw/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fdoc%2Frustdoc%2Fsrc%2Fcommand-line-arguments.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustdoc%2Fsrc%2Fcommand-line-arguments.md?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd"}, {"sha": "e4af122d0cb98d55938994581144f0803faa0f33", "filename": "src/doc/rustdoc/src/documentation-tests.md", "status": "modified", "additions": 122, "deletions": 40, "changes": 162, "blob_url": "https://github.com/rust-lang/rust/blob/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fdoc%2Frustdoc%2Fsrc%2Fdocumentation-tests.md", "raw_url": "https://github.com/rust-lang/rust/raw/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fdoc%2Frustdoc%2Fsrc%2Fdocumentation-tests.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustdoc%2Fsrc%2Fdocumentation-tests.md?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd"}, {"sha": "615b3dca199f1cc218a426b49b1bfd2e74d40435", "filename": "src/doc/rustdoc/src/passes.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fdoc%2Frustdoc%2Fsrc%2Fpasses.md", "raw_url": "https://github.com/rust-lang/rust/raw/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fdoc%2Frustdoc%2Fsrc%2Fpasses.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustdoc%2Fsrc%2Fpasses.md?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd"}, {"sha": "7f110d6a3d22c20e4550047121fad058f565312e", "filename": "src/doc/rustdoc/src/unstable-features.md", "status": "added", "additions": 391, "deletions": 0, "changes": 391, "blob_url": "https://github.com/rust-lang/rust/blob/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fdoc%2Frustdoc%2Fsrc%2Funstable-features.md", "raw_url": "https://github.com/rust-lang/rust/raw/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fdoc%2Frustdoc%2Fsrc%2Funstable-features.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustdoc%2Fsrc%2Funstable-features.md?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd"}, {"sha": "320283f31b51feb3e3fd24a632195fcb42a5181a", "filename": "src/doc/tutorial.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fdoc%2Ftutorial.md", "raw_url": "https://github.com/rust-lang/rust/raw/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fdoc%2Ftutorial.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftutorial.md?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd"}, {"sha": "8ca04d253259258af86b8e2546cc28f943d8734d", "filename": "src/doc/unstable-book/src/compiler-flags/remap-path-prefix.md", "status": "removed", "additions": 0, "deletions": 37, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/ac64ef33756d05557153e00211cdf8fcf65d4be3/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Fremap-path-prefix.md", "raw_url": "https://github.com/rust-lang/rust/raw/ac64ef33756d05557153e00211cdf8fcf65d4be3/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Fremap-path-prefix.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Fremap-path-prefix.md?ref=ac64ef33756d05557153e00211cdf8fcf65d4be3"}, {"sha": "e8256469b145078be9889c75600c86e64081012c", "filename": "src/doc/unstable-book/src/language-features/advanced-slice-patterns.md", "status": "removed", "additions": 0, "deletions": 35, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/ac64ef33756d05557153e00211cdf8fcf65d4be3/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fadvanced-slice-patterns.md", "raw_url": "https://github.com/rust-lang/rust/raw/ac64ef33756d05557153e00211cdf8fcf65d4be3/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fadvanced-slice-patterns.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fadvanced-slice-patterns.md?ref=ac64ef33756d05557153e00211cdf8fcf65d4be3"}, {"sha": "414dc48e557d3ec3f391fbb7bd288c19a88a33e4", "filename": "src/doc/unstable-book/src/language-features/box-syntax.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fbox-syntax.md", "raw_url": "https://github.com/rust-lang/rust/raw/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fbox-syntax.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fbox-syntax.md?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd"}, {"sha": "247333d841ad08bce673f7438acc5c8608437ed2", "filename": "src/doc/unstable-book/src/language-features/catch-expr.md", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fcatch-expr.md", "raw_url": "https://github.com/rust-lang/rust/raw/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fcatch-expr.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fcatch-expr.md?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd"}, {"sha": "0be6a321103f0858b9e0d70981b6a6414e72a47c", "filename": "src/doc/unstable-book/src/language-features/conservative-impl-trait.md", "status": "removed", "additions": 0, "deletions": 66, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/ac64ef33756d05557153e00211cdf8fcf65d4be3/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fconservative-impl-trait.md", "raw_url": "https://github.com/rust-lang/rust/raw/ac64ef33756d05557153e00211cdf8fcf65d4be3/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fconservative-impl-trait.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fconservative-impl-trait.md?ref=ac64ef33756d05557153e00211cdf8fcf65d4be3"}, {"sha": "42d46ce15f676e552025619097bd9c90c17730e3", "filename": "src/doc/unstable-book/src/language-features/const-indexing.md", "status": "removed", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/ac64ef33756d05557153e00211cdf8fcf65d4be3/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fconst-indexing.md", "raw_url": "https://github.com/rust-lang/rust/raw/ac64ef33756d05557153e00211cdf8fcf65d4be3/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fconst-indexing.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fconst-indexing.md?ref=ac64ef33756d05557153e00211cdf8fcf65d4be3"}, {"sha": "9901dc1ebe307028eea40ffd140608c0a9b49cc1", "filename": "src/doc/unstable-book/src/language-features/crate-in-paths.md", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fcrate-in-paths.md", "raw_url": "https://github.com/rust-lang/rust/raw/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fcrate-in-paths.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fcrate-in-paths.md?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd"}, {"sha": "647ac0cf663fdc4cedc99dafe239bed8e4d16989", "filename": "src/doc/unstable-book/src/language-features/doc-alias.md", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fdoc-alias.md", "raw_url": "https://github.com/rust-lang/rust/raw/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fdoc-alias.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fdoc-alias.md?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd"}, {"sha": "6a22e7eba646b09185260f62d7f43e7114996d2a", "filename": "src/doc/unstable-book/src/language-features/extern-absolute-paths.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fextern-absolute-paths.md", "raw_url": "https://github.com/rust-lang/rust/raw/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fextern-absolute-paths.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fextern-absolute-paths.md?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd"}, {"sha": "71b6cd663a0833a129e33e83a4317a2d49af91ef", "filename": "src/doc/unstable-book/src/language-features/fn-must-use.md", "status": "removed", "additions": 0, "deletions": 30, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/ac64ef33756d05557153e00211cdf8fcf65d4be3/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Ffn-must-use.md", "raw_url": "https://github.com/rust-lang/rust/raw/ac64ef33756d05557153e00211cdf8fcf65d4be3/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Ffn-must-use.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Ffn-must-use.md?ref=ac64ef33756d05557153e00211cdf8fcf65d4be3"}, {"sha": "8e888de90a95149ecf786f9b62e8588114623547", "filename": "src/doc/unstable-book/src/language-features/generators.md", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fgenerators.md", "raw_url": "https://github.com/rust-lang/rust/raw/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fgenerators.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fgenerators.md?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd"}, {"sha": "b3e6925b666b77dd30fb44c5ba933a0e21a273b9", "filename": "src/doc/unstable-book/src/language-features/global-allocator.md", "status": "removed", "additions": 0, "deletions": 71, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/ac64ef33756d05557153e00211cdf8fcf65d4be3/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fglobal-allocator.md", "raw_url": "https://github.com/rust-lang/rust/raw/ac64ef33756d05557153e00211cdf8fcf65d4be3/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fglobal-allocator.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fglobal-allocator.md?ref=ac64ef33756d05557153e00211cdf8fcf65d4be3"}, {"sha": "a850b7644c3a76fee296606cf1ea858640251c41", "filename": "src/doc/unstable-book/src/language-features/i128-type.md", "status": "removed", "additions": 0, "deletions": 25, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/ac64ef33756d05557153e00211cdf8fcf65d4be3/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fi128-type.md", "raw_url": "https://github.com/rust-lang/rust/raw/ac64ef33756d05557153e00211cdf8fcf65d4be3/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fi128-type.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fi128-type.md?ref=ac64ef33756d05557153e00211cdf8fcf65d4be3"}, {"sha": "56f58803150ca6ca274b5b9046f771f92e1c0627", "filename": "src/doc/unstable-book/src/language-features/inclusive-range-syntax.md", "status": "removed", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ac64ef33756d05557153e00211cdf8fcf65d4be3/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Finclusive-range-syntax.md", "raw_url": "https://github.com/rust-lang/rust/raw/ac64ef33756d05557153e00211cdf8fcf65d4be3/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Finclusive-range-syntax.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Finclusive-range-syntax.md?ref=ac64ef33756d05557153e00211cdf8fcf65d4be3"}, {"sha": "73c7eafdb98d583b24f65201714e3ba07d5babb0", "filename": "src/doc/unstable-book/src/language-features/infer-outlives-requirements.md", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Finfer-outlives-requirements.md", "raw_url": "https://github.com/rust-lang/rust/raw/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Finfer-outlives-requirements.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Finfer-outlives-requirements.md?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd"}, {"sha": "f50472fb41e31128d1dcb1da186dc66516ecd35f", "filename": "src/doc/unstable-book/src/language-features/infer-static-outlives-requirements.md", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Finfer-static-outlives-requirements.md", "raw_url": "https://github.com/rust-lang/rust/raw/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Finfer-static-outlives-requirements.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Finfer-static-outlives-requirements.md?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd"}, {"sha": "46b843778e81077967d1864514553eb31d7696c5", "filename": "src/doc/unstable-book/src/language-features/irrefutable-let-patterns.md", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Firrefutable-let-patterns.md", "raw_url": "https://github.com/rust-lang/rust/raw/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Firrefutable-let-patterns.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Firrefutable-let-patterns.md?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd"}, {"sha": "bac619fd4a30d2c17e50d45415d55d1ef42600d6", "filename": "src/doc/unstable-book/src/language-features/lang-items.md", "status": "modified", "additions": 20, "deletions": 28, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Flang-items.md", "raw_url": "https://github.com/rust-lang/rust/raw/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Flang-items.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Flang-items.md?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd"}, {"sha": "251fc7209122c8e0d3df4c36c2219a61c713a8a5", "filename": "src/doc/unstable-book/src/language-features/macro-at-most-once-rep.md", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fmacro-at-most-once-rep.md", "raw_url": "https://github.com/rust-lang/rust/raw/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fmacro-at-most-once-rep.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fmacro-at-most-once-rep.md?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd"}, {"sha": "5b585d7f041d25877b2bd339cb01e7100f9413c3", "filename": "src/doc/unstable-book/src/language-features/macro-lifetime-matcher.md", "status": "removed", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ac64ef33756d05557153e00211cdf8fcf65d4be3/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fmacro-lifetime-matcher.md", "raw_url": "https://github.com/rust-lang/rust/raw/ac64ef33756d05557153e00211cdf8fcf65d4be3/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fmacro-lifetime-matcher.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fmacro-lifetime-matcher.md?ref=ac64ef33756d05557153e00211cdf8fcf65d4be3"}, {"sha": "7e3638fd1cf4c1d1362320d0efcab2323491a341", "filename": "src/doc/unstable-book/src/language-features/macro-literal-matcher.md", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fmacro-literal-matcher.md", "raw_url": "https://github.com/rust-lang/rust/raw/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fmacro-literal-matcher.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fmacro-literal-matcher.md?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd"}, {"sha": "f0a51af7fd1c807c17208f31894751a761a7b0ca", "filename": "src/doc/unstable-book/src/language-features/match-beginning-vert.md", "status": "removed", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/ac64ef33756d05557153e00211cdf8fcf65d4be3/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fmatch-beginning-vert.md", "raw_url": "https://github.com/rust-lang/rust/raw/ac64ef33756d05557153e00211cdf8fcf65d4be3/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fmatch-beginning-vert.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fmatch-beginning-vert.md?ref=ac64ef33756d05557153e00211cdf8fcf65d4be3"}, {"sha": "cc542931cbe1fc01b10f1e2aef1bf2bc417b7298", "filename": "src/doc/unstable-book/src/language-features/match-default-bindings.md", "status": "removed", "additions": 0, "deletions": 58, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/ac64ef33756d05557153e00211cdf8fcf65d4be3/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fmatch-default-bindings.md", "raw_url": "https://github.com/rust-lang/rust/raw/ac64ef33756d05557153e00211cdf8fcf65d4be3/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fmatch-default-bindings.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fmatch-default-bindings.md?ref=ac64ef33756d05557153e00211cdf8fcf65d4be3"}, {"sha": "f787f629756f32b38fc41418eed8540fe5ce9a76", "filename": "src/doc/unstable-book/src/language-features/on-unimplemented.md", "status": "modified", "additions": 95, "deletions": 2, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fon-unimplemented.md", "raw_url": "https://github.com/rust-lang/rust/raw/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fon-unimplemented.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fon-unimplemented.md?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd"}, {"sha": "19ece09509078d450c11f6a1efe0f09d12900139", "filename": "src/doc/unstable-book/src/language-features/plugin.md", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fplugin.md", "raw_url": "https://github.com/rust-lang/rust/raw/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fplugin.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fplugin.md?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd"}, {"sha": "1bd8c41629eea01712d001f940d2e797ee47138f", "filename": "src/doc/unstable-book/src/language-features/proc-macro.md", "status": "removed", "additions": 0, "deletions": 241, "changes": 241, "blob_url": "https://github.com/rust-lang/rust/blob/ac64ef33756d05557153e00211cdf8fcf65d4be3/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fproc-macro.md", "raw_url": "https://github.com/rust-lang/rust/raw/ac64ef33756d05557153e00211cdf8fcf65d4be3/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fproc-macro.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fproc-macro.md?ref=ac64ef33756d05557153e00211cdf8fcf65d4be3"}, {"sha": "2dd763d04b0abf6e03e00eb075200a24931f7875", "filename": "src/doc/unstable-book/src/language-features/repr-packed.md", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Frepr-packed.md", "raw_url": "https://github.com/rust-lang/rust/raw/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Frepr-packed.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Frepr-packed.md?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd"}, {"sha": "0858988952c105c3e987f16e977ed8510209aa61", "filename": "src/doc/unstable-book/src/language-features/repr128.md", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Frepr128.md", "raw_url": "https://github.com/rust-lang/rust/raw/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Frepr128.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Frepr128.md?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd"}, {"sha": "2416e85c17d1f68601ce0963670c286527e588b7", "filename": "src/doc/unstable-book/src/language-features/self-in-typedefs.md", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fself-in-typedefs.md", "raw_url": "https://github.com/rust-lang/rust/raw/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fself-in-typedefs.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fself-in-typedefs.md?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd"}, {"sha": "133174268ef93f16fbfc191b9bd405751e81af04", "filename": "src/doc/unstable-book/src/language-features/slice-patterns.md", "status": "modified", "additions": 16, "deletions": 12, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fslice-patterns.md", "raw_url": "https://github.com/rust-lang/rust/raw/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fslice-patterns.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fslice-patterns.md?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd"}, {"sha": "15fc84a3e2a3dad17eb2f2a2115c6c6f45fc6f02", "filename": "src/doc/unstable-book/src/language-features/tool-attributes.md", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Ftool-attributes.md", "raw_url": "https://github.com/rust-lang/rust/raw/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Ftool-attributes.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Ftool-attributes.md?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd"}, {"sha": "5c0d33b5ab0c492f6b3712165e5496cee3bf4fbd", "filename": "src/doc/unstable-book/src/language-features/tool-lints.md", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Ftool-lints.md", "raw_url": "https://github.com/rust-lang/rust/raw/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Ftool-lints.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Ftool-lints.md?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd"}, {"sha": "6b3c5e92720df6e9ef6ee001f4676c96dadadf98", "filename": "src/doc/unstable-book/src/language-features/universal-impl-trait.md", "status": "removed", "additions": 0, "deletions": 32, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/ac64ef33756d05557153e00211cdf8fcf65d4be3/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Funiversal-impl-trait.md", "raw_url": "https://github.com/rust-lang/rust/raw/ac64ef33756d05557153e00211cdf8fcf65d4be3/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Funiversal-impl-trait.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Funiversal-impl-trait.md?ref=ac64ef33756d05557153e00211cdf8fcf65d4be3"}, {"sha": "7a5fe5b7f28cdfc153c7f961389e7c9e4438daf4", "filename": "src/doc/unstable-book/src/language-features/unsized-locals.md", "status": "added", "additions": 180, "deletions": 0, "changes": 180, "blob_url": "https://github.com/rust-lang/rust/blob/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Funsized-locals.md", "raw_url": "https://github.com/rust-lang/rust/raw/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Funsized-locals.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Funsized-locals.md?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd"}, {"sha": "47b635bad736ff80af85b7ce71f0cef7b748c7e6", "filename": "src/doc/unstable-book/src/language-features/use-nested-groups.md", "status": "removed", "additions": 0, "deletions": 90, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/ac64ef33756d05557153e00211cdf8fcf65d4be3/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fuse-nested-groups.md", "raw_url": "https://github.com/rust-lang/rust/raw/ac64ef33756d05557153e00211cdf8fcf65d4be3/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fuse-nested-groups.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fuse-nested-groups.md?ref=ac64ef33756d05557153e00211cdf8fcf65d4be3"}, {"sha": "c3b7f2e41e15b27b265f37fcc75e53801538ef8c", "filename": "src/doc/unstable-book/src/language-features/used.md", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fused.md", "raw_url": "https://github.com/rust-lang/rust/raw/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fused.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fused.md?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd"}, {"sha": "425d4cb79b2df7e359fbd0c05edd3c8155d3156c", "filename": "src/doc/unstable-book/src/library-features/alloc-jemalloc.md", "status": "removed", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/ac64ef33756d05557153e00211cdf8fcf65d4be3/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Falloc-jemalloc.md", "raw_url": "https://github.com/rust-lang/rust/raw/ac64ef33756d05557153e00211cdf8fcf65d4be3/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Falloc-jemalloc.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Falloc-jemalloc.md?ref=ac64ef33756d05557153e00211cdf8fcf65d4be3"}, {"sha": "9effab202cabd909b8c270110f2ff1df5f7fa568", "filename": "src/doc/unstable-book/src/library-features/alloc-system.md", "status": "removed", "additions": 0, "deletions": 77, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/ac64ef33756d05557153e00211cdf8fcf65d4be3/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Falloc-system.md", "raw_url": "https://github.com/rust-lang/rust/raw/ac64ef33756d05557153e00211cdf8fcf65d4be3/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Falloc-system.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Falloc-system.md?ref=ac64ef33756d05557153e00211cdf8fcf65d4be3"}, {"sha": "1280c71e83c922fa2b5e3befe3419f6014aa1dd2", "filename": "src/doc/unstable-book/src/library-features/entry-and-modify.md", "status": "removed", "additions": 0, "deletions": 77, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/ac64ef33756d05557153e00211cdf8fcf65d4be3/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fentry-and-modify.md", "raw_url": "https://github.com/rust-lang/rust/raw/ac64ef33756d05557153e00211cdf8fcf65d4be3/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fentry-and-modify.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fentry-and-modify.md?ref=ac64ef33756d05557153e00211cdf8fcf65d4be3"}, {"sha": "f8c8a2a7a718bafa31c0f1dcd8adabb885cd12f6", "filename": "src/doc/unstable-book/src/library-features/entry-or-default.md", "status": "removed", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/ac64ef33756d05557153e00211cdf8fcf65d4be3/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fentry-or-default.md", "raw_url": "https://github.com/rust-lang/rust/raw/ac64ef33756d05557153e00211cdf8fcf65d4be3/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fentry-or-default.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fentry-or-default.md?ref=ac64ef33756d05557153e00211cdf8fcf65d4be3"}, {"sha": "40c2ef2db0551ec64fbe1b671bb6c5cb62582e74", "filename": "src/doc/unstable-book/src/library-features/future-atomic-orderings.md", "status": "removed", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ac64ef33756d05557153e00211cdf8fcf65d4be3/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Ffuture-atomic-orderings.md", "raw_url": "https://github.com/rust-lang/rust/raw/ac64ef33756d05557153e00211cdf8fcf65d4be3/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Ffuture-atomic-orderings.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Ffuture-atomic-orderings.md?ref=ac64ef33756d05557153e00211cdf8fcf65d4be3"}, {"sha": "5bee18d33d61bcf21538e1f4c21bf36bf76facce", "filename": "src/doc/unstable-book/src/library-features/io-error-internals.md", "status": "removed", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ac64ef33756d05557153e00211cdf8fcf65d4be3/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fio-error-internals.md", "raw_url": "https://github.com/rust-lang/rust/raw/ac64ef33756d05557153e00211cdf8fcf65d4be3/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fio-error-internals.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fio-error-internals.md?ref=ac64ef33756d05557153e00211cdf8fcf65d4be3"}, {"sha": "8c2954f7294e02b666e4ad15244be99048f15867", "filename": "src/doc/unstable-book/src/library-features/slice-rsplit.md", "status": "removed", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ac64ef33756d05557153e00211cdf8fcf65d4be3/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fslice-rsplit.md", "raw_url": "https://github.com/rust-lang/rust/raw/ac64ef33756d05557153e00211cdf8fcf65d4be3/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fslice-rsplit.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fslice-rsplit.md?ref=ac64ef33756d05557153e00211cdf8fcf65d4be3"}, {"sha": "2e4bb1a5257c94b76899fc56324825666a4542be", "filename": "src/doc/unstable-book/src/library-features/splice.md", "status": "removed", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/ac64ef33756d05557153e00211cdf8fcf65d4be3/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fsplice.md", "raw_url": "https://github.com/rust-lang/rust/raw/ac64ef33756d05557153e00211cdf8fcf65d4be3/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fsplice.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fsplice.md?ref=ac64ef33756d05557153e00211cdf8fcf65d4be3"}, {"sha": "049444aa49bdd2ef90d7316c2e6d6d41bdf16f80", "filename": "src/doc/unstable-book/src/library-features/string-retain.md", "status": "removed", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/ac64ef33756d05557153e00211cdf8fcf65d4be3/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fstring-retain.md", "raw_url": "https://github.com/rust-lang/rust/raw/ac64ef33756d05557153e00211cdf8fcf65d4be3/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fstring-retain.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fstring-retain.md?ref=ac64ef33756d05557153e00211cdf8fcf65d4be3"}, {"sha": "361e8d8e60eed9a48edc1c7a7023e7c3bb9ffadf", "filename": "src/etc/cat-and-grep.sh", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fetc%2Fcat-and-grep.sh", "raw_url": "https://github.com/rust-lang/rust/raw/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fetc%2Fcat-and-grep.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fcat-and-grep.sh?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd"}, {"sha": "cfe5b01e934e7032c0a99910ab144c5c63dfd7bf", "filename": "src/etc/char_private.py", "status": "removed", "additions": 0, "deletions": 254, "changes": 254, "blob_url": "https://github.com/rust-lang/rust/blob/ac64ef33756d05557153e00211cdf8fcf65d4be3/src%2Fetc%2Fchar_private.py", "raw_url": "https://github.com/rust-lang/rust/raw/ac64ef33756d05557153e00211cdf8fcf65d4be3/src%2Fetc%2Fchar_private.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fchar_private.py?ref=ac64ef33756d05557153e00211cdf8fcf65d4be3"}, {"sha": "1797f6708ac5b4745fcc2300fc3653b68c1320bc", "filename": "src/etc/debugger_pretty_printers_common.py", "status": "modified", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fetc%2Fdebugger_pretty_printers_common.py", "raw_url": "https://github.com/rust-lang/rust/raw/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fetc%2Fdebugger_pretty_printers_common.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fdebugger_pretty_printers_common.py?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd"}, {"sha": "216915dba5fe7c03116d1cf2906afd7bbafe392f", "filename": "src/etc/gdb_rust_pretty_printing.py", "status": "modified", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fetc%2Fgdb_rust_pretty_printing.py", "raw_url": "https://github.com/rust-lang/rust/raw/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fetc%2Fgdb_rust_pretty_printing.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fgdb_rust_pretty_printing.py?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd"}, {"sha": "2e9169ce5b942920c16dc5426003888fd98ec8b7", "filename": "src/etc/generate-deriving-span-tests.py", "status": "modified", "additions": 20, "deletions": 7, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fetc%2Fgenerate-deriving-span-tests.py", "raw_url": "https://github.com/rust-lang/rust/raw/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fetc%2Fgenerate-deriving-span-tests.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fgenerate-deriving-span-tests.py?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd"}, {"sha": "569788fe9c08a93cfca05915a7835ea629c34be0", "filename": "src/etc/htmldocck.py", "status": "modified", "additions": 13, "deletions": 9, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fetc%2Fhtmldocck.py", "raw_url": "https://github.com/rust-lang/rust/raw/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fetc%2Fhtmldocck.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fhtmldocck.py?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd"}, {"sha": "a471ccc6f5b48ef3748d8ec6fa840384758033de", "filename": "src/etc/installer/msi/rust.wxs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fetc%2Finstaller%2Fmsi%2Frust.wxs", "raw_url": "https://github.com/rust-lang/rust/raw/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fetc%2Finstaller%2Fmsi%2Frust.wxs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Finstaller%2Fmsi%2Frust.wxs?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd"}, {"sha": "046ea48638baf22f22cc5dc35b67b747e7376263", "filename": "src/etc/platform-intrinsics/generator.py", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fetc%2Fplatform-intrinsics%2Fgenerator.py", "raw_url": "https://github.com/rust-lang/rust/raw/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fetc%2Fplatform-intrinsics%2Fgenerator.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fplatform-intrinsics%2Fgenerator.py?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd"}, {"sha": "6835d6aa90874b7b7372dc8d68e557246a644696", "filename": "src/etc/rust-gdb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fetc%2Frust-gdb", "raw_url": "https://github.com/rust-lang/rust/raw/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fetc%2Frust-gdb", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Frust-gdb?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd"}, {"sha": "ac2223f4acef3052d32d35689b90eb1227ca4a19", "filename": "src/etc/sugarise-doc-comments.py", "status": "removed", "additions": 0, "deletions": 93, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/ac64ef33756d05557153e00211cdf8fcf65d4be3/src%2Fetc%2Fsugarise-doc-comments.py", "raw_url": "https://github.com/rust-lang/rust/raw/ac64ef33756d05557153e00211cdf8fcf65d4be3/src%2Fetc%2Fsugarise-doc-comments.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fsugarise-doc-comments.py?ref=ac64ef33756d05557153e00211cdf8fcf65d4be3"}, {"sha": "469a38da2b8312426589baef8928b7ad0a5d9e96", "filename": "src/etc/test-float-parse/many-digits.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fetc%2Ftest-float-parse%2Fmany-digits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fetc%2Ftest-float-parse%2Fmany-digits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Ftest-float-parse%2Fmany-digits.rs?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd"}, {"sha": "2994dd9d5e6446511698fd96162dab55767cd7c1", "filename": "src/etc/test-float-parse/rand-f64.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fetc%2Ftest-float-parse%2Frand-f64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fetc%2Ftest-float-parse%2Frand-f64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Ftest-float-parse%2Frand-f64.rs?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd"}, {"sha": "e9f5bba2312d823fe2f1d48ad9a3e0972c0482fc", "filename": "src/etc/test-float-parse/runtests.py", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fetc%2Ftest-float-parse%2Fruntests.py", "raw_url": "https://github.com/rust-lang/rust/raw/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fetc%2Ftest-float-parse%2Fruntests.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Ftest-float-parse%2Fruntests.py?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd"}, {"sha": "378aae597331600acfbf5e42f1242c6e46c10870", "filename": "src/etc/wasm32-shim.js", "status": "modified", "additions": 90, "deletions": 65, "changes": 155, "blob_url": "https://github.com/rust-lang/rust/blob/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fetc%2Fwasm32-shim.js", "raw_url": "https://github.com/rust-lang/rust/raw/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fetc%2Fwasm32-shim.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fwasm32-shim.js?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd"}, {"sha": "762f9565b7802e41a93ca3e693d96ea825fb03c2", "filename": "src/etc/ziggurat_tables.py", "status": "removed", "additions": 0, "deletions": 127, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/ac64ef33756d05557153e00211cdf8fcf65d4be3/src%2Fetc%2Fziggurat_tables.py", "raw_url": "https://github.com/rust-lang/rust/raw/ac64ef33756d05557153e00211cdf8fcf65d4be3/src%2Fetc%2Fziggurat_tables.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fziggurat_tables.py?ref=ac64ef33756d05557153e00211cdf8fcf65d4be3"}, {"sha": "a7da69f65faf2b3532cdc6537cff92a167a139ac", "filename": "src/grammar/parser-lalr.y", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fgrammar%2Fparser-lalr.y", "raw_url": "https://github.com/rust-lang/rust/raw/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fgrammar%2Fparser-lalr.y", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fgrammar%2Fparser-lalr.y?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd"}, {"sha": "1dad323769a07b95f0ae315544cc68dd26df1b4f", "filename": "src/liballoc/Cargo.toml", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fliballoc%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fliballoc%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2FCargo.toml?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd"}, {"sha": "c69b2fb5e1c2a3e27619f5994f767d8f49d036db", "filename": "src/liballoc/alloc.rs", "status": "added", "additions": 263, "deletions": 0, "changes": 263, "blob_url": "https://github.com/rust-lang/rust/blob/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fliballoc%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fliballoc%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Falloc.rs?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd"}, {"sha": "c2a8f5f8ff957e5004b9b2cf95ea0cb4d6dfe448", "filename": "src/liballoc/allocator.rs", "status": "removed", "additions": 0, "deletions": 1064, "changes": 1064, "blob_url": "https://github.com/rust-lang/rust/blob/ac64ef33756d05557153e00211cdf8fcf65d4be3/src%2Fliballoc%2Fallocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac64ef33756d05557153e00211cdf8fcf65d4be3/src%2Fliballoc%2Fallocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fallocator.rs?ref=ac64ef33756d05557153e00211cdf8fcf65d4be3"}, {"sha": "185af8835d1e49d14da8033e13deefa5329e8a71", "filename": "src/liballoc/arc.rs", "status": "removed", "additions": 0, "deletions": 1864, "changes": 1864, "blob_url": "https://github.com/rust-lang/rust/blob/ac64ef33756d05557153e00211cdf8fcf65d4be3/src%2Fliballoc%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac64ef33756d05557153e00211cdf8fcf65d4be3/src%2Fliballoc%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Farc.rs?ref=ac64ef33756d05557153e00211cdf8fcf65d4be3"}, {"sha": "b4f4fd74f3a39ac41815df8681ef3261b2fc1a6d", "filename": "src/liballoc/benches/lib.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fliballoc%2Fbenches%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fliballoc%2Fbenches%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fbenches%2Flib.rs?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd"}, {"sha": "a699ff9c0a76ec61d0a427ab58bfe10c23c09d72", "filename": "src/liballoc/benches/slice.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fliballoc%2Fbenches%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fliballoc%2Fbenches%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fbenches%2Fslice.rs?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd"}, {"sha": "bd33565113752d1c9d5ecbd97afc1488fde75fd8", "filename": "src/liballoc/benches/vec_deque_append.rs", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fliballoc%2Fbenches%2Fvec_deque_append.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fliballoc%2Fbenches%2Fvec_deque_append.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fbenches%2Fvec_deque_append.rs?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd"}, {"sha": "c6741ddb822d5bb9114889bc71fdd2203f72e559", "filename": "src/liballoc/borrow.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fliballoc%2Fborrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fliballoc%2Fborrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fborrow.rs?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd"}, {"sha": "08db5136d040450c0164841ed8fed83d0be2ad1f", "filename": "src/liballoc/boxed.rs", "status": "modified", "additions": 305, "deletions": 220, "changes": 525, "blob_url": "https://github.com/rust-lang/rust/blob/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fliballoc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fliballoc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fboxed.rs?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd"}, {"sha": "55995742a4a7da7bfa1ce5ec4008145190da7842", "filename": "src/liballoc/boxed_test.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fliballoc%2Fboxed_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fliballoc%2Fboxed_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fboxed_test.rs?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd"}, {"sha": "fcadcb544c431a9e9ede7bc00912ce3123b2533c", "filename": "src/liballoc/collections/binary_heap.rs", "status": "renamed", "additions": 34, "deletions": 74, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fliballoc%2Fcollections%2Fbinary_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fliballoc%2Fcollections%2Fbinary_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbinary_heap.rs?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd", "previous_filename": "src/liballoc/binary_heap.rs"}, {"sha": "8c950cd06d9e385373f56175d5253060c4e8390a", "filename": "src/liballoc/collections/btree/map.rs", "status": "renamed", "additions": 106, "deletions": 37, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd", "previous_filename": "src/liballoc/btree/map.rs"}, {"sha": "087c9f228d4448bb6c119675ce28eac9e354a6b4", "filename": "src/liballoc/collections/btree/mod.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fliballoc%2Fcollections%2Fbtree%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fliballoc%2Fcollections%2Fbtree%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fmod.rs?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd", "previous_filename": "src/liballoc/btree/mod.rs"}, {"sha": "0ae45b3123259a2b7dbb4c7286d3207757f3f3b4", "filename": "src/liballoc/collections/btree/node.rs", "status": "renamed", "additions": 134, "deletions": 54, "changes": 188, "blob_url": "https://github.com/rust-lang/rust/blob/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fliballoc%2Fcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fliballoc%2Fcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fnode.rs?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd", "previous_filename": "src/liballoc/btree/node.rs"}, {"sha": "bc1272fbc786e7aa4c2c9e39e24345c3a84f68a4", "filename": "src/liballoc/collections/btree/search.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fliballoc%2Fcollections%2Fbtree%2Fsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fliballoc%2Fcollections%2Fbtree%2Fsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fsearch.rs?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd", "previous_filename": "src/liballoc/btree/search.rs"}, {"sha": "af9a7074e4a4f96d9916ae126ac8f936879cf2e2", "filename": "src/liballoc/collections/btree/set.rs", "status": "renamed", "additions": 25, "deletions": 26, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fliballoc%2Fcollections%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fliballoc%2Fcollections%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fset.rs?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd", "previous_filename": "src/liballoc/btree/set.rs"}, {"sha": "9844de9a57d70274c4bf91cc93d79da0e381acf4", "filename": "src/liballoc/collections/linked_list.rs", "status": "renamed", "additions": 22, "deletions": 196, "changes": 218, "blob_url": "https://github.com/rust-lang/rust/blob/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fliballoc%2Fcollections%2Flinked_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fliballoc%2Fcollections%2Flinked_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Flinked_list.rs?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd", "previous_filename": "src/liballoc/linked_list.rs"}, {"sha": "96e0eb633b2f54cbaa38ad8c230a4c6f165ebc97", "filename": "src/liballoc/collections/mod.rs", "status": "added", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fliballoc%2Fcollections%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fliballoc%2Fcollections%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fmod.rs?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd"}, {"sha": "0f759bb8f0b4f9e2f97daf96ca4c6919e75d82cc", "filename": "src/liballoc/collections/vec_deque.rs", "status": "renamed", "additions": 311, "deletions": 172, "changes": 483, "blob_url": "https://github.com/rust-lang/rust/blob/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fliballoc%2Fcollections%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fliballoc%2Fcollections%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fvec_deque.rs?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd", "previous_filename": "src/liballoc/vec_deque.rs"}, {"sha": "b49ec0ae25212d05787ad7df0f845cebd52e8405", "filename": "src/liballoc/fmt.rs", "status": "modified", "additions": 16, "deletions": 9, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fliballoc%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fliballoc%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ffmt.rs?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd"}, {"sha": "b2bd9d7d8fafadf9006240a698d0609f0f6a0bd5", "filename": "src/liballoc/heap.rs", "status": "removed", "additions": 0, "deletions": 297, "changes": 297, "blob_url": "https://github.com/rust-lang/rust/blob/ac64ef33756d05557153e00211cdf8fcf65d4be3/src%2Fliballoc%2Fheap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac64ef33756d05557153e00211cdf8fcf65d4be3/src%2Fliballoc%2Fheap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fheap.rs?ref=ac64ef33756d05557153e00211cdf8fcf65d4be3"}, {"sha": "bcdfd8c9aa5d54b00eba93d67eb8a7d027d174e7", "filename": "src/liballoc/lib.rs", "status": "modified", "additions": 34, "deletions": 139, "changes": 173, "blob_url": "https://github.com/rust-lang/rust/blob/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fliballoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fliballoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flib.rs?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd"}, {"sha": "53b5e93a66e26d923d25d9d1d7ea94f2e0f8807c", "filename": "src/liballoc/prelude.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fliballoc%2Fprelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fliballoc%2Fprelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fprelude.rs?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd"}, {"sha": "f862da0d61e012ed816811947a14f3fcab5005a5", "filename": "src/liballoc/range.rs", "status": "removed", "additions": 0, "deletions": 152, "changes": 152, "blob_url": "https://github.com/rust-lang/rust/blob/ac64ef33756d05557153e00211cdf8fcf65d4be3/src%2Fliballoc%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac64ef33756d05557153e00211cdf8fcf65d4be3/src%2Fliballoc%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frange.rs?ref=ac64ef33756d05557153e00211cdf8fcf65d4be3"}, {"sha": "4f2686abf4515fbb11554df4b81dd83114b51976", "filename": "src/liballoc/raw_vec.rs", "status": "modified", "additions": 170, "deletions": 130, "changes": 300, "blob_url": "https://github.com/rust-lang/rust/blob/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fliballoc%2Fraw_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fliballoc%2Fraw_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fraw_vec.rs?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd"}, {"sha": "be049eb6e5ef377a56daff179198e8faa26a0bbe", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 77, "deletions": 66, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd"}, {"sha": "c27c596e7975a33463042261b9ec17d33aa7990c", "filename": "src/liballoc/slice.rs", "status": "modified", "additions": 159, "deletions": 1479, "changes": 1638, "blob_url": "https://github.com/rust-lang/rust/blob/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fliballoc%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fliballoc%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fslice.rs?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd"}, {"sha": "870bf971cd3f626d82c086dfd5021a94378b2df8", "filename": "src/liballoc/str.rs", "status": "modified", "additions": 189, "deletions": 1798, "changes": 1987, "blob_url": "https://github.com/rust-lang/rust/blob/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fliballoc%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fliballoc%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fstr.rs?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd"}, {"sha": "dd559df08cce6b356e77e8efa9e538018f0f3507", "filename": "src/liballoc/string.rs", "status": "modified", "additions": 142, "deletions": 36, "changes": 178, "blob_url": "https://github.com/rust-lang/rust/blob/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fliballoc%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fliballoc%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fstring.rs?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd"}, {"sha": "a00b6b4e435f06e504f6521d4c137e4a9cd38343", "filename": "src/liballoc/sync.rs", "status": "added", "additions": 1944, "deletions": 0, "changes": 1944, "blob_url": "https://github.com/rust-lang/rust/blob/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fliballoc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fliballoc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fsync.rs?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd"}, {"sha": "7a4eda21a601a61442dd1d4fbf6d68295cb29526", "filename": "src/liballoc/task.rs", "status": "added", "additions": 140, "deletions": 0, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fliballoc%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fliballoc%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftask.rs?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd"}, {"sha": "d90c22a3b18924496c9967a8e699ac6bc69684fc", "filename": "src/liballoc/tests/arc.rs", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fliballoc%2Ftests%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fliballoc%2Ftests%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Farc.rs?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd"}, {"sha": "8494463463cb941fa7873097ede52783ba4c5910", "filename": "src/liballoc/tests/binary_heap.rs", "status": "modified", "additions": 82, "deletions": 21, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fliballoc%2Ftests%2Fbinary_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fliballoc%2Ftests%2Fbinary_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fbinary_heap.rs?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd"}, {"sha": "6ebdb86cc4a9865a42bdde87419e87503ef249f0", "filename": "src/liballoc/tests/btree/map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fliballoc%2Ftests%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fliballoc%2Ftests%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fbtree%2Fmap.rs?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd"}, {"sha": "0330bda5e3238527c16071d92ebe585888e80311", "filename": "src/liballoc/tests/btree/set.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fliballoc%2Ftests%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fliballoc%2Ftests%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fbtree%2Fset.rs?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd"}, {"sha": "6fa88ce969a0e4866941b80337bd2c5841d31a06", "filename": "src/liballoc/tests/heap.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fliballoc%2Ftests%2Fheap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fliballoc%2Ftests%2Fheap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fheap.rs?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd"}, {"sha": "c12c7a81f79c8905a3ee3b77f7eb2662919ea488", "filename": "src/liballoc/tests/lib.rs", "status": "modified", "additions": 7, "deletions": 14, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fliballoc%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fliballoc%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Flib.rs?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd"}, {"sha": "9ec7c831444d18d02881e2b11a103da0332cc930", "filename": "src/liballoc/tests/rc.rs", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fliballoc%2Ftests%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fliballoc%2Ftests%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Frc.rs?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd"}, {"sha": "df5e18a9a184ecc60a9afa90c19cf4a508109d28", "filename": "src/liballoc/tests/slice.rs", "status": "modified", "additions": 202, "deletions": 3, "changes": 205, "blob_url": "https://github.com/rust-lang/rust/blob/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fliballoc%2Ftests%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fliballoc%2Ftests%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fslice.rs?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd"}, {"sha": "6275c7bb112063dc2205fc75698a7d6f7b8d3ba1", "filename": "src/liballoc/tests/str.rs", "status": "modified", "additions": 403, "deletions": 131, "changes": 534, "blob_url": "https://github.com/rust-lang/rust/blob/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fliballoc%2Ftests%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fliballoc%2Ftests%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fstr.rs?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd"}, {"sha": "befb36baeef1ebc0c91f67f8c4aa9dba2213bcbf", "filename": "src/liballoc/tests/string.rs", "status": "modified", "additions": 179, "deletions": 16, "changes": 195, "blob_url": "https://github.com/rust-lang/rust/blob/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fliballoc%2Ftests%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fliballoc%2Ftests%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fstring.rs?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd"}, {"sha": "e329b45a6175d8641532e4d71d6c1e0a7f05cc3a", "filename": "src/liballoc/tests/vec.rs", "status": "modified", "additions": 208, "deletions": 19, "changes": 227, "blob_url": "https://github.com/rust-lang/rust/blob/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fliballoc%2Ftests%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fliballoc%2Ftests%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fvec.rs?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd"}, {"sha": "3ea6c87a6516939ecca7ec94a41b162ba5cd18fc", "filename": "src/liballoc/tests/vec_deque.rs", "status": "modified", "additions": 300, "deletions": 13, "changes": 313, "blob_url": "https://github.com/rust-lang/rust/blob/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fliballoc%2Ftests%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fliballoc%2Ftests%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fvec_deque.rs?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd"}, {"sha": "cc913dfbb4b01e140abb47403998f7a65c224f3a", "filename": "src/liballoc/vec.rs", "status": "modified", "additions": 324, "deletions": 309, "changes": 633, "blob_url": "https://github.com/rust-lang/rust/blob/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fliballoc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fliballoc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fvec.rs?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd"}, {"sha": "7986d5dd2eb54b69a12990dc83891ba320a7e838", "filename": "src/liballoc_jemalloc/Cargo.toml", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fliballoc_jemalloc%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fliballoc_jemalloc%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc_jemalloc%2FCargo.toml?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd"}, {"sha": "fbda425a70bf5d6388455a4a0014e58a0a13d1d0", "filename": "src/liballoc_jemalloc/build.rs", "status": "modified", "additions": 14, "deletions": 8, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fliballoc_jemalloc%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fliballoc_jemalloc%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc_jemalloc%2Fbuild.rs?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd"}, {"sha": "480a24b9bd1f258ef94e1f8e04393384f3192e3a", "filename": "src/liballoc_jemalloc/lib.rs", "status": "modified", "additions": 9, "deletions": 130, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fliballoc_jemalloc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fliballoc_jemalloc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc_jemalloc%2Flib.rs?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd"}, {"sha": "c34e2f203a8371267134c2cc1271fcb15e24f45f", "filename": "src/liballoc_system/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fliballoc_system%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fliballoc_system%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc_system%2FCargo.toml?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd"}, {"sha": "c5e056f6b12bec1533cb698d450c72114b041a7f", "filename": "src/liballoc_system/lib.rs", "status": "modified", "additions": 114, "deletions": 314, "changes": 428, "blob_url": "https://github.com/rust-lang/rust/blob/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fliballoc_system%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Fliballoc_system%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc_system%2Flib.rs?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd"}, {"sha": "e2af67dd9286138e61ef1196d4d7a8487a80c20c", "filename": "src/libarena/Cargo.toml", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Flibarena%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Flibarena%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibarena%2FCargo.toml?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd"}, {"sha": "265721c749755628f4f1f0b262f6bbf7e3c7bea4", "filename": "src/libarena/lib.rs", "status": "modified", "additions": 107, "deletions": 27, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Flibarena%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08b1d83a46848dd7bd778aeae67a1e529e95d8cd/src%2Flibarena%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibarena%2Flib.rs?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd"}, {"sha": "f4d02bbdbf8a2c5a31f0801dfef597a86caad9e3", "filename": "src/libbacktrace", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace?ref=08b1d83a46848dd7bd778aeae67a1e529e95d8cd"}, {"sha": "acc07047f6729cc578b55bec881acb8f8fd379ba", "filename": "src/libbacktrace/ChangeLog", "status": "removed", "additions": 0, "deletions": 590, "changes": 590, "blob_url": "https://github.com/rust-lang/rust/blob/ac64ef33756d05557153e00211cdf8fcf65d4be3/src%2Flibbacktrace%2FChangeLog", "raw_url": "https://github.com/rust-lang/rust/raw/ac64ef33756d05557153e00211cdf8fcf65d4be3/src%2Flibbacktrace%2FChangeLog", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2FChangeLog?ref=ac64ef33756d05557153e00211cdf8fcf65d4be3"}, {"sha": "6b60e3b3b07382a48c7ffbaf992876426234bdee", "filename": "src/libbacktrace/ChangeLog.jit", "status": "removed", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ac64ef33756d05557153e00211cdf8fcf65d4be3/src%2Flibbacktrace%2FChangeLog.jit", "raw_url": "https://github.com/rust-lang/rust/raw/ac64ef33756d05557153e00211cdf8fcf65d4be3/src%2Flibbacktrace%2FChangeLog.jit", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2FChangeLog.jit?ref=ac64ef33756d05557153e00211cdf8fcf65d4be3"}, {"sha": "a7df02590982255a96166a4be552f07e6f42cabb", "filename": "src/libbacktrace/Makefile.am", "status": "removed", "additions": 0, "deletions": 136, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/ac64ef33756d05557153e00211cdf8fcf65d4be3/src%2Flibbacktrace%2FMakefile.am", "raw_url": "https://github.com/rust-lang/rust/raw/ac64ef33756d05557153e00211cdf8fcf65d4be3/src%2Flibbacktrace%2FMakefile.am", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2FMakefile.am?ref=ac64ef33756d05557153e00211cdf8fcf65d4be3"}, {"sha": "586b6a6eaa10e94d4bf4deb478e063f2653088ac", "filename": "src/libbacktrace/Makefile.in", "status": "removed", "additions": 0, "deletions": 770, "changes": 770, "blob_url": "https://github.com/rust-lang/rust/blob/ac64ef33756d05557153e00211cdf8fcf65d4be3/src%2Flibbacktrace%2FMakefile.in", "raw_url": "https://github.com/rust-lang/rust/raw/ac64ef33756d05557153e00211cdf8fcf65d4be3/src%2Flibbacktrace%2FMakefile.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2FMakefile.in?ref=ac64ef33756d05557153e00211cdf8fcf65d4be3"}, {"sha": "e8b225745c9c639e67ea4f6fa0f97041ba978276", "filename": "src/libbacktrace/README", "status": "removed", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/ac64ef33756d05557153e00211cdf8fcf65d4be3/src%2Flibbacktrace%2FREADME", "raw_url": "https://github.com/rust-lang/rust/raw/ac64ef33756d05557153e00211cdf8fcf65d4be3/src%2Flibbacktrace%2FREADME", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2FREADME?ref=ac64ef33756d05557153e00211cdf8fcf65d4be3"}, {"sha": "8e84ddd1f10132210a49e7d08ba522e09df3a8ad", "filename": "src/libbacktrace/aclocal.m4", "status": "removed", "additions": 0, "deletions": 683, "changes": 683, "blob_url": "https://github.com/rust-lang/rust/blob/ac64ef33756d05557153e00211cdf8fcf65d4be3/src%2Flibbacktrace%2Faclocal.m4", "raw_url": "https://github.com/rust-lang/rust/raw/ac64ef33756d05557153e00211cdf8fcf65d4be3/src%2Flibbacktrace%2Faclocal.m4", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2Faclocal.m4?ref=ac64ef33756d05557153e00211cdf8fcf65d4be3"}, {"sha": "a9f07a013f8feec7a4508b7fc7189fb188c90031", "filename": "src/libbacktrace/alloc.c", "status": "removed", "additions": 0, "deletions": 156, "changes": 156, "blob_url": "https://github.com/rust-lang/rust/blob/ac64ef33756d05557153e00211cdf8fcf65d4be3/src%2Flibbacktrace%2Falloc.c", "raw_url": "https://github.com/rust-lang/rust/raw/ac64ef33756d05557153e00211cdf8fcf65d4be3/src%2Flibbacktrace%2Falloc.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2Falloc.c?ref=ac64ef33756d05557153e00211cdf8fcf65d4be3"}, {"sha": "4087dd729175082d6e00f7371b4fbab18236aa78", "filename": "src/libbacktrace/ansidecl.h", "status": "removed", "additions": 0, "deletions": 329, "changes": 329, "blob_url": "https://github.com/rust-lang/rust/blob/ac64ef33756d05557153e00211cdf8fcf65d4be3/src%2Flibbacktrace%2Fansidecl.h", "raw_url": "https://github.com/rust-lang/rust/raw/ac64ef33756d05557153e00211cdf8fcf65d4be3/src%2Flibbacktrace%2Fansidecl.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2Fansidecl.h?ref=ac64ef33756d05557153e00211cdf8fcf65d4be3"}, {"sha": "cb0ad0298e68a4bd3fc92ca20efadde0d1a0a8ca", "filename": "src/libbacktrace/atomic.c", "status": "removed", "additions": 0, "deletions": 113, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/ac64ef33756d05557153e00211cdf8fcf65d4be3/src%2Flibbacktrace%2Fatomic.c", "raw_url": "https://github.com/rust-lang/rust/raw/ac64ef33756d05557153e00211cdf8fcf65d4be3/src%2Flibbacktrace%2Fatomic.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2Fatomic.c?ref=ac64ef33756d05557153e00211cdf8fcf65d4be3"}, {"sha": "ab34199fcd362cceefb43d28f2c28daad07cc1f8", "filename": "src/libbacktrace/backtrace-supported.h.in", "status": "removed", "additions": 0, "deletions": 66, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/ac64ef33756d05557153e00211cdf8fcf65d4be3/src%2Flibbacktrace%2Fbacktrace-supported.h.in", "raw_url": "https://github.com/rust-lang/rust/raw/ac64ef33756d05557153e00211cdf8fcf65d4be3/src%2Flibbacktrace%2Fbacktrace-supported.h.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2Fbacktrace-supported.h.in?ref=ac64ef33756d05557153e00211cdf8fcf65d4be3"}, {"sha": "b89bf554ac548d2ab2a88fe65aa3907ac354e4a8", "filename": "src/libbacktrace/backtrace.c", "status": "removed", "additions": 0, "deletions": 129, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/ac64ef33756d05557153e00211cdf8fcf65d4be3/src%2Flibbacktrace%2Fbacktrace.c", "raw_url": "https://github.com/rust-lang/rust/raw/ac64ef33756d05557153e00211cdf8fcf65d4be3/src%2Flibbacktrace%2Fbacktrace.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2Fbacktrace.c?ref=ac64ef33756d05557153e00211cdf8fcf65d4be3"}, {"sha": "d209219d9a419ea82a723d4a4bf4282a7a900a83", "filename": "src/libbacktrace/backtrace.h", "status": "removed", "additions": 0, "deletions": 199, "changes": 199, "blob_url": "https://github.com/rust-lang/rust/blob/ac64ef33756d05557153e00211cdf8fcf65d4be3/src%2Flibbacktrace%2Fbacktrace.h", "raw_url": "https://github.com/rust-lang/rust/raw/ac64ef33756d05557153e00211cdf8fcf65d4be3/src%2Flibbacktrace%2Fbacktrace.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2Fbacktrace.h?ref=ac64ef33756d05557153e00211cdf8fcf65d4be3"}, {"sha": "0506d2b112186b7b61fa89b3e2ec20b7286a699b", "filename": "src/libbacktrace/btest.c", "status": "removed", "additions": 0, "deletions": 721, "changes": 721, "blob_url": "https://github.com/rust-lang/rust/blob/ac64ef33756d05557153e00211cdf8fcf65d4be3/src%2Flibbacktrace%2Fbtest.c", "raw_url": "https://github.com/rust-lang/rust/raw/ac64ef33756d05557153e00211cdf8fcf65d4be3/src%2Flibbacktrace%2Fbtest.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2Fbtest.c?ref=ac64ef33756d05557153e00211cdf8fcf65d4be3"}, {"sha": "87cb805984d4f06782ed96a509fe18a290377f33", "filename": "src/libbacktrace/config.h.in", "status": "removed", "additions": 0, "deletions": 134, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/ac64ef33756d05557153e00211cdf8fcf65d4be3/src%2Flibbacktrace%2Fconfig.h.in", "raw_url": "https://github.com/rust-lang/rust/raw/ac64ef33756d05557153e00211cdf8fcf65d4be3/src%2Flibbacktrace%2Fconfig.h.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2Fconfig.h.in?ref=ac64ef33756d05557153e00211cdf8fcf65d4be3"}, {"sha": "40ea5dfe1152f0fc5160879bb71bfe1fae2595f6", "filename": "src/libbacktrace/config.sub", "status": "removed", "additions": 0, "deletions": 1836, "changes": 1836, "blob_url": "https://github.com/rust-lang/rust/blob/ac64ef33756d05557153e00211cdf8fcf65d4be3/src%2Flibbacktrace%2Fconfig.sub", "raw_url": "https://github.com/rust-lang/rust/raw/ac64ef33756d05557153e00211cdf8fcf65d4be3/src%2Flibbacktrace%2Fconfig.sub", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2Fconfig.sub?ref=ac64ef33756d05557153e00211cdf8fcf65d4be3"}, {"sha": "8bdb29d25606f81756b37437032f286dadcad96d", "filename": "src/libbacktrace/configure", "status": "removed", "additions": 0, "deletions": 15199, "changes": 15199, "blob_url": "https://github.com/rust-lang/rust/blob/ac64ef33756d05557153e00211cdf8fcf65d4be3/src%2Flibbacktrace%2Fconfigure", "raw_url": "https://github.com/rust-lang/rust/raw/ac64ef33756d05557153e00211cdf8fcf65d4be3/src%2Flibbacktrace%2Fconfigure", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2Fconfigure?ref=ac64ef33756d05557153e00211cdf8fcf65d4be3"}, {"sha": "ea1b27d807e13d9741f4fa7821f16e6f2e0006c3", "filename": "src/libbacktrace/configure.ac", "status": "removed", "additions": 0, "deletions": 418, "changes": 418, "blob_url": "https://github.com/rust-lang/rust/blob/ac64ef33756d05557153e00211cdf8fcf65d4be3/src%2Flibbacktrace%2Fconfigure.ac", "raw_url": "https://github.com/rust-lang/rust/raw/ac64ef33756d05557153e00211cdf8fcf65d4be3/src%2Flibbacktrace%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2Fconfigure.ac?ref=ac64ef33756d05557153e00211cdf8fcf65d4be3"}, {"sha": "55b8d7dc2a56d96e69df0a1be6728bad212754c7", "filename": "src/libbacktrace/dwarf.c", "status": "removed", "additions": 0, "deletions": 3038, "changes": 3038, "blob_url": "https://github.com/rust-lang/rust/blob/ac64ef33756d05557153e00211cdf8fcf65d4be3/src%2Flibbacktrace%2Fdwarf.c", "raw_url": "https://github.com/rust-lang/rust/raw/ac64ef33756d05557153e00211cdf8fcf65d4be3/src%2Flibbacktrace%2Fdwarf.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2Fdwarf.c?ref=ac64ef33756d05557153e00211cdf8fcf65d4be3"}, {"sha": "2dfee5666dea68d8292f04c5100c93e1f1fcf4f4", "filename": "src/libbacktrace/dwarf2.def", "status": "removed", "additions": 0, "deletions": 713, "changes": 713, "blob_url": "https://github.com/rust-lang/rust/blob/ac64ef33756d05557153e00211cdf8fcf65d4be3/src%2Flibbacktrace%2Fdwarf2.def", "raw_url": "https://github.com/rust-lang/rust/raw/ac64ef33756d05557153e00211cdf8fcf65d4be3/src%2Flibbacktrace%2Fdwarf2.def", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2Fdwarf2.def?ref=ac64ef33756d05557153e00211cdf8fcf65d4be3"}, {"sha": "4ada87162fa868eb80c6994e1877c6d9897ae732", "filename": "src/libbacktrace/dwarf2.h", "status": "removed", "additions": 0, "deletions": 430, "changes": 430, "blob_url": "https://github.com/rust-lang/rust/blob/ac64ef33756d05557153e00211cdf8fcf65d4be3/src%2Flibbacktrace%2Fdwarf2.h", "raw_url": "https://github.com/rust-lang/rust/raw/ac64ef33756d05557153e00211cdf8fcf65d4be3/src%2Flibbacktrace%2Fdwarf2.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2Fdwarf2.h?ref=ac64ef33756d05557153e00211cdf8fcf65d4be3"}, {"sha": "81ba3440ab7d18539180f53805ac36c408284a66", "filename": "src/libbacktrace/elf.c", "status": "removed", "additions": 0, "deletions": 979, "changes": 979, "blob_url": "https://github.com/rust-lang/rust/blob/ac64ef33756d05557153e00211cdf8fcf65d4be3/src%2Flibbacktrace%2Felf.c", "raw_url": "https://github.com/rust-lang/rust/raw/ac64ef33756d05557153e00211cdf8fcf65d4be3/src%2Flibbacktrace%2Felf.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2Felf.c?ref=ac64ef33756d05557153e00211cdf8fcf65d4be3"}, {"sha": "27ebbedc21ccf39f86f439138c2e418b556ccbd8", "filename": "src/libbacktrace/fileline.c", "status": "removed", "additions": 0, "deletions": 194, "changes": 194, "blob_url": "https://github.com/rust-lang/rust/blob/ac64ef33756d05557153e00211cdf8fcf65d4be3/src%2Flibbacktrace%2Ffileline.c", "raw_url": "https://github.com/rust-lang/rust/raw/ac64ef33756d05557153e00211cdf8fcf65d4be3/src%2Flibbacktrace%2Ffileline.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2Ffileline.c?ref=ac64ef33756d05557153e00211cdf8fcf65d4be3"}, {"sha": "1161daaa4f3581c81c4842509aa7c7298d3bbd7b", "filename": "src/libbacktrace/filenames.h", "status": "removed", "additions": 0, "deletions": 99, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/ac64ef33756d05557153e00211cdf8fcf65d4be3/src%2Flibbacktrace%2Ffilenames.h", "raw_url": "https://github.com/rust-lang/rust/raw/ac64ef33756d05557153e00211cdf8fcf65d4be3/src%2Flibbacktrace%2Ffilenames.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2Ffilenames.h?ref=ac64ef33756d05557153e00211cdf8fcf65d4be3"}, {"sha": "a5f6c8cc1800f0cb24d415cade2b0905f54a730f", "filename": "src/libbacktrace/filetype.awk", "status": "removed", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ac64ef33756d05557153e00211cdf8fcf65d4be3/src%2Flibbacktrace%2Ffiletype.awk", "raw_url": "https://github.com/rust-lang/rust/raw/ac64ef33756d05557153e00211cdf8fcf65d4be3/src%2Flibbacktrace%2Ffiletype.awk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2Ffiletype.awk?ref=ac64ef33756d05557153e00211cdf8fcf65d4be3"}, {"sha": "b1b5877aae7ca83dd2f04cc050c352b82e4a8d35", "filename": "src/libbacktrace/hashtab.h", "status": "removed", "additions": 0, "deletions": 204, "changes": 204, "blob_url": "https://github.com/rust-lang/rust/blob/ac64ef33756d05557153e00211cdf8fcf65d4be3/src%2Flibbacktrace%2Fhashtab.h", "raw_url": "https://github.com/rust-lang/rust/raw/ac64ef33756d05557153e00211cdf8fcf65d4be3/src%2Flibbacktrace%2Fhashtab.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2Fhashtab.h?ref=ac64ef33756d05557153e00211cdf8fcf65d4be3"}, {"sha": "0b0fdcbba69ab6dd05ca162a5328828d46ab1d54", "filename": "src/libbacktrace/install-sh", "status": "removed", "additions": 0, "deletions": 501, "changes": 501, "blob_url": "https://github.com/rust-lang/rust/blob/ac64ef33756d05557153e00211cdf8fcf65d4be3/src%2Flibbacktrace%2Finstall-sh", "raw_url": "https://github.com/rust-lang/rust/raw/ac64ef33756d05557153e00211cdf8fcf65d4be3/src%2Flibbacktrace%2Finstall-sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2Finstall-sh?ref=ac64ef33756d05557153e00211cdf8fcf65d4be3"}, {"sha": "73728da3f5664db0306a9ffd6e23066fff2df45d", "filename": "src/libbacktrace/internal.h", "status": "removed", "additions": 0, "deletions": 294, "changes": 294, "blob_url": "https://github.com/rust-lang/rust/blob/ac64ef33756d05557153e00211cdf8fcf65d4be3/src%2Flibbacktrace%2Finternal.h", "raw_url": "https://github.com/rust-lang/rust/raw/ac64ef33756d05557153e00211cdf8fcf65d4be3/src%2Flibbacktrace%2Finternal.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2Finternal.h?ref=ac64ef33756d05557153e00211cdf8fcf65d4be3"}, {"sha": "eff9e62be8a05644a842fd99ca5ae814282797b0", "filename": "src/libbacktrace/ltmain.sh", "status": "removed", "additions": 0, "deletions": 8636, "changes": 8636, "blob_url": "https://github.com/rust-lang/rust/blob/ac64ef33756d05557153e00211cdf8fcf65d4be3/src%2Flibbacktrace%2Fltmain.sh", "raw_url": "https://github.com/rust-lang/rust/raw/ac64ef33756d05557153e00211cdf8fcf65d4be3/src%2Flibbacktrace%2Fltmain.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2Fltmain.sh?ref=ac64ef33756d05557153e00211cdf8fcf65d4be3"}, {"sha": "9af14e724b40d8b292f5b9683e5ad7a51c07ee2b", "filename": "src/libbacktrace/macho.c", "status": "removed", "additions": 0, "deletions": 1416, "changes": 1416, "blob_url": "https://github.com/rust-lang/rust/blob/ac64ef33756d05557153e00211cdf8fcf65d4be3/src%2Flibbacktrace%2Fmacho.c", "raw_url": "https://github.com/rust-lang/rust/raw/ac64ef33756d05557153e00211cdf8fcf65d4be3/src%2Flibbacktrace%2Fmacho.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2Fmacho.c?ref=ac64ef33756d05557153e00211cdf8fcf65d4be3"}, {"sha": "138ef70711a02597b6e843516d84c687f9aef753", "filename": "src/libbacktrace/mmap.c", "status": "removed", "additions": 0, "deletions": 303, "changes": 303, "blob_url": "https://github.com/rust-lang/rust/blob/ac64ef33756d05557153e00211cdf8fcf65d4be3/src%2Flibbacktrace%2Fmmap.c", "raw_url": "https://github.com/rust-lang/rust/raw/ac64ef33756d05557153e00211cdf8fcf65d4be3/src%2Flibbacktrace%2Fmmap.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2Fmmap.c?ref=ac64ef33756d05557153e00211cdf8fcf65d4be3"}, {"sha": "dfdaf6fa52e6e774c1c59e5b4509b8c54a7e110a", "filename": "src/libbacktrace/mmapio.c", "status": "removed", "additions": 0, "deletions": 100, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/ac64ef33756d05557153e00211cdf8fcf65d4be3/src%2Flibbacktrace%2Fmmapio.c", "raw_url": "https://github.com/rust-lang/rust/raw/ac64ef33756d05557153e00211cdf8fcf65d4be3/src%2Flibbacktrace%2Fmmapio.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2Fmmapio.c?ref=ac64ef33756d05557153e00211cdf8fcf65d4be3"}, {"sha": "448a2049f1d1b46aa393f3b17e60d9a799181fc4", "filename": "src/libbacktrace/nounwind.c", "status": "removed", "additions": 0, "deletions": 66, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/ac64ef33756d05557153e00211cdf8fcf65d4be3/src%2Flibbacktrace%2Fnounwind.c", "raw_url": "https://github.com/rust-lang/rust/raw/ac64ef33756d05557153e00211cdf8fcf65d4be3/src%2Flibbacktrace%2Fnounwind.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2Fnounwind.c?ref=ac64ef33756d05557153e00211cdf8fcf65d4be3"}, {"sha": "2d6a9877219dcacac0a2fe31f6c4fe83193804e1", "filename": "src/libbacktrace/pecoff.c", "status": "removed", "additions": 0, "deletions": 942, "changes": 942, "blob_url": "https://github.com/rust-lang/rust/blob/ac64ef33756d05557153e00211cdf8fcf65d4be3/src%2Flibbacktrace%2Fpecoff.c", "raw_url": "https://github.com/rust-lang/rust/raw/ac64ef33756d05557153e00211cdf8fcf65d4be3/src%2Flibbacktrace%2Fpecoff.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2Fpecoff.c?ref=ac64ef33756d05557153e00211cdf8fcf65d4be3"}, {"sha": "09f5e95a6e42d824b1ef09d3d4ff489e61644f58", "filename": "src/libbacktrace/posix.c", "status": "removed", "additions": 0, "deletions": 100, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/ac64ef33756d05557153e00211cdf8fcf65d4be3/src%2Flibbacktrace%2Fposix.c", "raw_url": "https://github.com/rust-lang/rust/raw/ac64ef33756d05557153e00211cdf8fcf65d4be3/src%2Flibbacktrace%2Fposix.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2Fposix.c?ref=ac64ef33756d05557153e00211cdf8fcf65d4be3"}, {"sha": "74c8fcbee5a1f9bc853a0bb6e3607a15a20f9dba", "filename": "src/libbacktrace/print.c", "status": "removed", "additions": 0, "deletions": 92, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/ac64ef33756d05557153e00211cdf8fcf65d4be3/src%2Flibbacktrace%2Fprint.c", "raw_url": "https://github.com/rust-lang/rust/raw/ac64ef33756d05557153e00211cdf8fcf65d4be3/src%2Flibbacktrace%2Fprint.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2Fprint.c?ref=ac64ef33756d05557153e00211cdf8fcf65d4be3"}, {"sha": "7f0317c3a8ce91e3de6c8bc95cae597e3163faf2", "filename": "src/libbacktrace/read.c", "status": "removed", "additions": 0, "deletions": 96, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/ac64ef33756d05557153e00211cdf8fcf65d4be3/src%2Flibbacktrace%2Fread.c", "raw_url": "https://github.com/rust-lang/rust/raw/ac64ef33756d05557153e00211cdf8fcf65d4be3/src%2Flibbacktrace%2Fread.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2Fread.c?ref=ac64ef33756d05557153e00211cdf8fcf65d4be3"}, {"sha": "018773a7e5dbdb66de407529f2508a5cd5769b54", "filename": "src/libbacktrace/simple.c", "status": "removed", "additions": 0, "deletions": 108, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/ac64ef33756d05557153e00211cdf8fcf65d4be3/src%2Flibbacktrace%2Fsimple.c", "raw_url": "https://github.com/rust-lang/rust/raw/ac64ef33756d05557153e00211cdf8fcf65d4be3/src%2Flibbacktrace%2Fsimple.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2Fsimple.c?ref=ac64ef33756d05557153e00211cdf8fcf65d4be3"}, {"sha": "68a7df65a47f6e4cd8bcc9171410c269b462033e", "filename": "src/libbacktrace/sort.c", "status": "removed", "additions": 0, "deletions": 108, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/ac64ef33756d05557153e00211cdf8fcf65d4be3/src%2Flibbacktrace%2Fsort.c", "raw_url": "https://github.com/rust-lang/rust/raw/ac64ef33756d05557153e00211cdf8fcf65d4be3/src%2Flibbacktrace%2Fsort.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2Fsort.c?ref=ac64ef33756d05557153e00211cdf8fcf65d4be3"}, {"sha": "93420d9c61b19939ebd28d4fe0dccae745d2af57", "filename": "src/libbacktrace/state.c", "status": "removed", "additions": 0, "deletions": 72, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/ac64ef33756d05557153e00211cdf8fcf65d4be3/src%2Flibbacktrace%2Fstate.c", "raw_url": "https://github.com/rust-lang/rust/raw/ac64ef33756d05557153e00211cdf8fcf65d4be3/src%2Flibbacktrace%2Fstate.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibbacktrace%2Fstate.c?ref=ac64ef33756d05557153e00211cdf8fcf65d4be3"}]}