{"sha": "9c9be62b02eccd177db2311c337c7b469cd19e62", "node_id": "MDY6Q29tbWl0NzI0NzEyOjljOWJlNjJiMDJlY2NkMTc3ZGIyMzExYzMzN2M3YjQ2OWNkMTllNjI=", "commit": {"author": {"name": "Stefan Plantikow", "email": "stefan.plantikow@googlemail.com", "date": "2011-11-22T17:08:26Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-11-25T00:21:13Z"}, "message": "std: rewrote math to support most C95 libmath calls on f32, f64 and float", "tree": {"sha": "8c60235bc06d80b9ceabd4cb6b3441f3203586db", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8c60235bc06d80b9ceabd4cb6b3441f3203586db"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9c9be62b02eccd177db2311c337c7b469cd19e62", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9c9be62b02eccd177db2311c337c7b469cd19e62", "html_url": "https://github.com/rust-lang/rust/commit/9c9be62b02eccd177db2311c337c7b469cd19e62", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9c9be62b02eccd177db2311c337c7b469cd19e62/comments", "author": {"login": "boggle", "id": 50886, "node_id": "MDQ6VXNlcjUwODg2", "avatar_url": "https://avatars.githubusercontent.com/u/50886?v=4", "gravatar_id": "", "url": "https://api.github.com/users/boggle", "html_url": "https://github.com/boggle", "followers_url": "https://api.github.com/users/boggle/followers", "following_url": "https://api.github.com/users/boggle/following{/other_user}", "gists_url": "https://api.github.com/users/boggle/gists{/gist_id}", "starred_url": "https://api.github.com/users/boggle/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/boggle/subscriptions", "organizations_url": "https://api.github.com/users/boggle/orgs", "repos_url": "https://api.github.com/users/boggle/repos", "events_url": "https://api.github.com/users/boggle/events{/privacy}", "received_events_url": "https://api.github.com/users/boggle/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "75ce03dd7794c125cf103ab224083a26a4da531b", "url": "https://api.github.com/repos/rust-lang/rust/commits/75ce03dd7794c125cf103ab224083a26a4da531b", "html_url": "https://github.com/rust-lang/rust/commit/75ce03dd7794c125cf103ab224083a26a4da531b"}], "stats": {"total": 369, "additions": 305, "deletions": 64}, "files": [{"sha": "890300ce78124f3b8169b83dcac5b77237f40de6", "filename": "src/lib/ctypes.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9c9be62b02eccd177db2311c337c7b469cd19e62/src%2Flib%2Fctypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c9be62b02eccd177db2311c337c7b469cd19e62/src%2Flib%2Fctypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fctypes.rs?ref=9c9be62b02eccd177db2311c337c7b469cd19e62", "patch": "@@ -5,6 +5,7 @@ Definitions useful for C interop\n */\n \n type c_int = i32;\n+\n type long = int;\n type unsigned = u32;\n type ulong = uint;\n@@ -13,6 +14,9 @@ type intptr_t = uint;\n type uintptr_t = uint;\n type uint32_t = u32;\n \n+// This *must* match with \"import c_float = fXX\" in std::math per arch\n+type c_float = f64;\n+\n type size_t = uint;\n type ssize_t = int;\n type off_t = uint;"}, {"sha": "339e63086515e8a8177098b1663767592302677d", "filename": "src/lib/math.rs", "status": "modified", "additions": 295, "deletions": 58, "changes": 353, "blob_url": "https://github.com/rust-lang/rust/blob/9c9be62b02eccd177db2311c337c7b469cd19e62/src%2Flib%2Fmath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c9be62b02eccd177db2311c337c7b469cd19e62/src%2Flib%2Fmath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fmath.rs?ref=9c9be62b02eccd177db2311c337c7b469cd19e62", "patch": "@@ -1,125 +1,362 @@\n /* Module: math */\n \n-#[link_name = \"\"]\n+export consts;\n+export min, max;\n+\n+export f32, f64;\n+\n+// Currently this module supports from -lmath\n+// C95 - frexp - ldexp - fmod - modf + log2 + log1p\n+\n+export\n+    acos, asin, atan, atan2, ceil, cos, cosh, exp, abs, floor,\n+    ln, ln1p, log10, log2, pow, sin, sinh, sqrt, tan, tanh;\n+\n+// These two must match in width according to architecture\n+\n+import ctypes::c_float;\n+import c_float = f64;\n+\n+\n+#[link_name = \"m\"]\n #[abi = \"cdecl\"]\n-native mod libc {\n-    fn sqrt(n: float) -> float;\n-    fn sin(n: float) -> float;\n-    fn asin(n: float) -> float;\n-    fn cos(n: float) -> float;\n-    fn acos(n: float) -> float;\n-    fn tan(n: float) -> float;\n-    fn atan(n: float) -> float;\n-    #[link_name=\"log\"]\n-    fn ln(n: float) -> float;\n-    fn log2(n: float) -> float;\n-    fn log10(n: float) -> float;\n-    fn log1p(n: float) -> float;\n+native mod f64 {\n+\n+    // Alpabetically sorted by link_name\n+\n+    fn acos(n: f64) -> f64;\n+    fn asin(n: f64) -> f64;\n+    fn atan(n: f64) -> f64;\n+    fn atan2(a: f64, b: f64) -> f64;\n+    fn ceil(n: f64) -> f64;\n+    fn cos(n: f64) -> f64;\n+    fn cosh(n: f64) -> f64;\n+    fn exp(n: f64) -> f64;\n+    #[link_name=\"fabs\"] fn abs(n: f64) -> f64; \n+    fn floor(n: f64) -> f64;\n+    #[link_name=\"log\"] fn ln(n: f64) -> f64;\n+    #[link_name=\"log1p\"] fn ln1p(n: f64) -> f64;\n+    fn log10(n: f64) -> f64;\n+    fn log2(n: f64) -> f64;\n+    fn pow(n: f64, e: f64) -> f64;\n+    fn sin(n: f64) -> f64;\n+    fn sinh(n: f64) -> f64;\n+    fn sqrt(n: f64) -> f64;\n+    fn tan(n: f64) -> f64;\n+    fn tanh(n: f64) -> f64;\n+}\n+\n+#[link_name = \"m\"]\n+#[abi = \"cdecl\"]\n+native mod f32 {\n+\n+    // Alpabetically sorted by link_name\n+\n+    #[link_name=\"acosf\"] fn acos(n: f32) -> f32;\n+    #[link_name=\"asinf\"] fn asin(n: f32) -> f32;\n+    #[link_name=\"atanf\"] fn atan(n: f32) -> f32;\n+    #[link_name=\"atan2f\"] fn atan2(a: f32, b: f32) -> f32;\n+    #[link_name=\"ceilf\"] fn ceil(n: f32) -> f32;\n+    #[link_name=\"cosf\"] fn cos(n: f32) -> f32;\n+    #[link_name=\"coshf\"] fn cosh(n: f32) -> f32;\n+    #[link_name=\"expf\"] fn exp(n: f32) -> f32;\n+    #[link_name=\"fabsf\"] fn abs(n: f32) -> f32;\n+    #[link_name=\"floorf\"] fn floor(n: f32) -> f32;\n+    #[link_name=\"powf\"] fn pow(n: f32, e: f32) -> f32;\n+    #[link_name=\"sinf\"] fn sin(n: f32) -> f32;\n+    #[link_name=\"sinhf\"] fn sinh(n: f32) -> f32;\n+    #[link_name=\"sqrtf\"] fn sqrt(n: f32) -> f32;\n+    #[link_name=\"tanf\"] fn tan(n: f32) -> f32;\n+    #[link_name=\"tanhf\"] fn tanh(n: f32) -> f32;\n+    #[link_name=\"logf\"] fn ln(n: f32) -> f32;\n+    #[link_name=\"log1p\"] fn ln1p(n: f64) -> f64;\n+    #[link_name=\"log2f\"] fn log2(n: f32) -> f32;\n+    #[link_name=\"log10f\"] fn log10(n: f32) -> f32;\n+}\n+\n+\n+mod consts {\n+    /*\n+    Const: pi\n+\n+    Archimedes' constant\n+    */\n+    const pi: float = 3.14159265358979323846264338327950288;\n+\n+    /*\n+    Const: frac_pi_2\n+\n+    pi/2.0\n+    */\n+    const frac_pi_2: float = 1.57079632679489661923132169163975144;\n+\n+    /*\n+    Const: frac_pi_4\n+\n+    pi/4.0\n+    */\n+    const frac_pi_4: float = 0.785398163397448309615660845819875721;\n+\n+    /*\n+    Const: frac_1_pi\n+\n+    1.0/pi\n+    */\n+    const frac_1_pi: float = 0.318309886183790671537767526745028724;\n+\n+    /*\n+    Const: frac_2_pi\n+\n+    2.0/pi\n+    */\n+    const frac_2_pi: float = 0.636619772367581343075535053490057448;\n+\n+    /*\n+    Const: frac_2_sqrtpi\n+\n+    2.0/sqrt(pi)\n+    */\n+    const frac_2_sqrtpi: float = 1.12837916709551257389615890312154517;\n+\n+    /*\n+    Const: sqrt2\n+\n+    sqrt(2.0)\n+    */\n+    const sqrt2: float = 1.41421356237309504880168872420969808;\n+\n+    /*\n+    Const: frac_1_sqrt2\n+\n+    1.0/sqrt(2.0)\n+    */\n+    const frac_1_sqrt2: float = 0.707106781186547524400844362104849039;\n+\n+    /*\n+    Const: e\n+\n+    Euler's number\n+    */\n+    const e: float = 2.71828182845904523536028747135266250;\n+\n+    /*\n+    Const: log2_e\n+\n+    log2(e)\n+    */\n+    const log2_e: float = 1.44269504088896340735992468100189214;\n+\n+    /*\n+    Const: log10_e\n+\n+    log10(e)\n+    */\n+    const log10_e: float = 0.434294481903251827651128918916605082;\n+\n+    /*\n+    Const: ln_2\n+\n+    ln(2.0)\n+    */\n+    const ln_2: float = 0.693147180559945309417232121458176568;\n+\n+    /*\n+    Const: ln_10\n+\n+    ln(10.0)\n+    */\n+    const ln_10: float = 2.30258509299404568401799145468436421;\n+\n }\n \n /*\n-Function: sqrt\n+Function: min\n \n-Returns the square root\n+Returns the minimum of two values\n */\n-pure fn sqrt(x: float) -> float { unsafe { libc::sqrt(x) } }\n+pure fn min<copy T>(x: T, y: T) -> T { x < y ? x : y }\n \n /*\n-Function: sin\n+Function: max\n \n-Returns the sine of an angle\n+Returns the maximum of two values\n */\n-pure fn sin(x: float) -> float { unsafe { libc::sin(x) } }\n+pure fn max<copy T>(x: T, y: T) -> T { x < y ? y : x }\n \n /*\n-Function: cos\n+Function: acos\n \n-Returns the cosine of an angle\n+Returns the arccosine of an angle (measured in rad)\n */\n-pure fn cos(x: float) -> float { unsafe { libc::cos(x) } }\n+pure fn acos(x: float) -> float\n+    { unsafe { c_float::acos(x as c_float) as float } }\n \n /*\n-Function: tan\n+Function: asin\n \n-Returns the tangent of an angle\n+Returns the arcsine of an angle (measured in rad)\n */\n-pure fn tan(x: float) -> float { unsafe { libc::tan(x) } }\n+pure fn asin(x: float) -> float\n+    { unsafe { c_float::asin(x as c_float) as float } }\n \n /*\n-Function: asin\n+Function: atan\n \n-Returns the arcsine of an angle\n+Returns the arctangents of an angle (measured in rad)\n */\n-pure fn asin(x: float) -> float { unsafe { libc::asin(x) } }\n+pure fn atan(x: float) -> float\n+    { unsafe { c_float::atan(x as c_float) as float } }\n+\n \n /*\n-Function: acos\n+Function: atan2\n \n-Returns the arccosine of an angle\n+Returns the arctangent of an angle (measured in rad)\n */\n-pure fn acos(x: float) -> float { unsafe { libc::acos(x) } }\n+pure fn atan2(y: float, x: float) -> float\n+    { unsafe { c_float::atan2(y as c_float, x as c_float) as float } }\n \n /*\n-Function: atan\n+Function: ceil\n \n-Returns the arctangent of an angle\n+Returns:\n+\n+The smallest integral value less than or equal to `n`\n */\n-pure fn atan(x: float) -> float { unsafe { libc::atan(x) } }\n+pure fn ceil(n: float) -> float\n+    { unsafe { c_float::ceil(n as c_float) as float } }\n \n /*\n-Const: pi\n+Function: cos\n \n-Archimedes' constant\n+Returns the cosine of an angle `x` (measured in rad)\n */\n-const pi: float = 3.141592653589793;\n+pure fn cos(x: float) -> float\n+    { unsafe { c_float::cos(x as c_float) as float } }\n \n /*\n-Function: min\n+Function: cosh\n+\n+Returns the hyperbolic cosine of `x`\n \n-Returns the minimum of two values\n */\n-pure fn min<copy T>(x: T, y: T) -> T { x < y ? x : y }\n+pure fn cosh(x: float) -> float\n+    { unsafe { c_float::cosh(x as c_float) as float } }\n+\n \n /*\n-Function: max\n+Function: exp\n \n-Returns the maximum of two values\n+Returns:\n+\n+e to the power of `n*\n */\n-pure fn max<copy T>(x: T, y: T) -> T { x < y ? y : x }\n+pure fn exp(n: float) -> float\n+    { unsafe { c_float::exp(n as c_float) as float } }\n+\n+/*\n+Function: abs\n+\n+Returns:\n+\n+The absolute value of  `n`\n+\n+*/\n+pure fn abs(n: float) -> float\n+    { unsafe { c_float::abs(n as c_float) as float } }\n \n /*\n-Const: e\n+Function: floor\n+\n+Returns:\n \n-Euler's number\n+The largest integral value less than or equal to `n`\n */\n-const e: float = 2.718281828459045235;\n+pure fn floor(n: float) -> float\n+    { unsafe { c_float::floor(n as c_float) as float } }\n \n /*\n Function: ln\n \n-Returns the natural logaritm\n+Returns the natural logaritm of `n`\n */\n-pure fn ln(n: float) -> float { unsafe { libc::ln(n) } }\n+pure fn ln(n: float) -> float\n+    { unsafe { c_float::ln(n as c_float) as float } }\n \n /*\n-Function: log2\n+Function: ln1p\n+\n+Returns the natural logarithm of `1+n` accurately,\n+even for very small values of `n`\n+*/\n+pure fn ln1p(n: float) -> float\n+    { unsafe { c_float::ln1p(n as c_float) as float } }\n+\n+/*\n+Function: log10\n \n-Returns the logarithm to base 2\n+Returns the logarithm to base 10 of `n`\n */\n-pure fn log2(n: float) -> float { unsafe { libc::log2(n) } }\n+pure fn log10(n: float) -> float\n+    { unsafe { c_float::log10(n as c_float) as float } }\n \n /*\n Function: log2\n \n-Returns the logarithm to base 10\n+Returns the logarithm to base 2 of `n`\n+*/\n+pure fn log2(n: float) -> float\n+    { unsafe { c_float::log2(n as c_float) as float } }\n+\n+/*\n+Function: pow\n */\n-pure fn log10(n: float) -> float { unsafe { libc::log10(n) } }\n+pure fn pow(v: float, e: float) -> float\n+    { unsafe { c_float::pow(v as c_float, e as c_float) as float } }\n \n \n /*\n-Function: log1p\n+Function: sin\n \n-Returns the natural logarithm of `1+n` accurately,\n-even for very small values of `n`\n+Returns the sine of an angle `x` (measured in rad)\n+*/\n+pure fn sin(x: float) -> float\n+    { unsafe { c_float::sin(x as c_float) as float } }\n+\n+/*\n+Function: sinh\n+\n+Returns the hyperbolic sine of an angle `x` (measured in rad)\n */\n-pure fn ln1p(n: float) -> float { unsafe { libc::log1p(n) } }\n+pure fn sinh(x: float) -> float\n+    { unsafe { c_float::sinh(x as c_float) as float } }\n+\n+/*\n+Function: sqrt\n+\n+Returns the square root of `x`\n+*/\n+pure fn sqrt(x: float) -> float\n+    { unsafe { c_float::sqrt(x as c_float) as float } }\n+\n+/*\n+Function: tan\n+\n+Returns the tangent of an angle `x` (measured in rad)\n+\n+*/\n+pure fn tan(x: float) -> float\n+    { unsafe { c_float::tan(x as c_float) as float } }\n+\n+/*\n+Function: tanh\n+\n+Returns the hyperbolic tangent of an angle `x` (measured in rad)\n+\n+*/\n+pure fn tanh(x: float) -> float\n+    { unsafe { c_float::tanh(x as c_float) as float } }\n+\n+\n+\n+"}, {"sha": "53d93ae3077ac61e1b774258aa773554e8bc68fd", "filename": "src/test/stdtest/math.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9c9be62b02eccd177db2311c337c7b469cd19e62/src%2Ftest%2Fstdtest%2Fmath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c9be62b02eccd177db2311c337c7b469cd19e62/src%2Ftest%2Fstdtest%2Fmath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fstdtest%2Fmath.rs?ref=9c9be62b02eccd177db2311c337c7b469cd19e62", "patch": "@@ -24,14 +24,14 @@ fn test_max_min() {\n fn test_angle() {\n     fn angle(vec: (float, float)) -> float {\n         alt vec {\n-          (0f, y) when y < 0f { 1.5 * std::math::pi }\n-          (0f, y) { 0.5 * std::math::pi }\n+          (0f, y) when y < 0f { 1.5 * consts::pi }\n+          (0f, y) { 0.5 * consts::pi }\n           (x, y) { std::math::atan(y / x) }\n         }\n     }\n     assert angle((1f, 0f)) == 0f;\n-    assert angle((1f, 1f)) == 0.25 * pi;\n-    assert angle((0f, 1f)) == 0.5 * pi;\n+    assert angle((1f, 1f)) == 0.25 * consts::pi;\n+    assert angle((0f, 1f)) == 0.5 * consts::pi;\n }\n \n \n@@ -42,11 +42,11 @@ fn test_log_functions() {\n     assert log2(1.0) == 0.0;\n     assert log10(1.0) == 0.0;\n \n-    assert ln(e) == 1.0;\n+    assert ln(consts::e) == 1.0;\n     assert log2(2.0) == 1.0;\n     assert log10(10.0) == 1.0;\n \n-    assert ln(e*e*e*e) == 4.0;\n+    assert ln(consts::e*consts::e*consts::e*consts::e) == 4.0;\n     assert log2(256.0) == 8.0;\n     assert log10(1000.0) == 3.0;\n "}]}