{"sha": "d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ3NDhmYTZlY2NjZjZmNWI0YzdhZTRhYmVlMGEyZDIwNmIxNjVkZTI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-09-03T14:48:06Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-09-03T14:48:06Z"}, "message": "Auto merge of #36016 - petrochenkov:union, r=nikomatsakis\n\nImplement untagged unions (RFC 1444)\n\ncc https://github.com/rust-lang/rust/issues/32836\n\nNotes:\n- The RFC doesn't talk about `#[packed]` unions, this implementation supports them, packing changes union's alignment to 1 and removes trailing padding.\n- The RFC doesn't talk about dynamically sized unions, this implementation doesn't support them and rejects them during wf-checking (similarly, dynamically sized enums are not supported as well).\n- The lint for drop fields in unions can't work precisely before monomorphization, so it works pessimistically - non-`Copy` generic fields are reported, types not implementing `Drop` directly, but having non-trivial drop code are reported.\n\n    ```\n    struct S(String); // Doesn't implement `Drop`\n    union U<T> {\n        a: S, // Reported\n        b: T, // Reported\n    }\n    ```\n\n- https://github.com/rust-lang/rust/pull/35764 was indeed helpful and landed timely, I didn't have to implement internal drop flags for unions.\n- Unions are not permitted in constant patterns, because matching on union fields is unsafe, I didn't want unsafety checker to dig into all constants to uncover this possible unsafety.\n- The RFC doesn't talk about `#[derive]`, generally trait impls cannot be derived for unions, but some of them can. I implemented only `#[derive(Copy)]` so far. In theory shallow `#[derive(Clone)]` can be derived as well if all union fields are `Copy`, I left it for later though, it requires changing how `Clone` impls are generated.\n- Moving union fields is implemented as per https://github.com/rust-lang/rust/issues/32836#issuecomment-242511491.\n- Testing strategy: union specific behavior is tested, sometimes very basically (e.g. debuginfo), behavior common for all ADTs (e.g. something like coherence\nchecks) is not generally tested.\n\nr? @eddyb", "tree": {"sha": "5ada2c11762533ba6c6f21a7593b015cb1a89912", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5ada2c11762533ba6c6f21a7593b015cb1a89912"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2", "html_url": "https://github.com/rust-lang/rust/commit/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "01b35d82e51458870f61cf850b73479f253fcb54", "url": "https://api.github.com/repos/rust-lang/rust/commits/01b35d82e51458870f61cf850b73479f253fcb54", "html_url": "https://github.com/rust-lang/rust/commit/01b35d82e51458870f61cf850b73479f253fcb54"}, {"sha": "436cfe56534b405786816d4bbcccd11ed7571981", "url": "https://api.github.com/repos/rust-lang/rust/commits/436cfe56534b405786816d4bbcccd11ed7571981", "html_url": "https://github.com/rust-lang/rust/commit/436cfe56534b405786816d4bbcccd11ed7571981"}], "stats": {"total": 3261, "additions": 2899, "deletions": 362}, "files": [{"sha": "a2d4239388acefffa2bfa030345df07b10c9a433", "filename": "src/librustc/hir/check_attr.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustc%2Fhir%2Fcheck_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustc%2Fhir%2Fcheck_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fcheck_attr.rs?ref=d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2", "patch": "@@ -18,6 +18,7 @@ use syntax::visit::Visitor;\n enum Target {\n     Fn,\n     Struct,\n+    Union,\n     Enum,\n     Other,\n }\n@@ -27,6 +28,7 @@ impl Target {\n         match item.node {\n             ast::ItemKind::Fn(..) => Target::Fn,\n             ast::ItemKind::Struct(..) => Target::Struct,\n+            ast::ItemKind::Union(..) => Target::Union,\n             ast::ItemKind::Enum(..) => Target::Enum,\n             _ => Target::Other,\n         }\n@@ -62,17 +64,20 @@ impl<'a> CheckAttrVisitor<'a> {\n             let message = match &*name {\n                 \"C\" => {\n                     conflicting_reprs += 1;\n-                    if target != Target::Struct && target != Target::Enum {\n-                        \"attribute should be applied to struct or enum\"\n+                    if target != Target::Struct &&\n+                            target != Target::Union &&\n+                            target != Target::Enum {\n+                        \"attribute should be applied to struct, enum or union\"\n                     } else {\n                         continue\n                     }\n                 }\n                 \"packed\" => {\n                     // Do not increment conflicting_reprs here, because \"packed\"\n                     // can be used to modify another repr hint\n-                    if target != Target::Struct {\n-                        \"attribute should be applied to struct\"\n+                    if target != Target::Struct &&\n+                            target != Target::Union {\n+                        \"attribute should be applied to struct or union\"\n                     } else {\n                         continue\n                     }"}, {"sha": "aa0eac37ecff1979c631ba8e39cd8ee94b4ef359", "filename": "src/librustc/hir/def.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustc%2Fhir%2Fdef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustc%2Fhir%2Fdef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fdef.rs?ref=d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2", "patch": "@@ -41,6 +41,7 @@ pub enum Def {\n     // If Def::Struct lives in value namespace (e.g. tuple struct, unit struct expressions)\n     // it denotes a constructor and its DefId refers to NodeId of the struct's constructor.\n     Struct(DefId),\n+    Union(DefId),\n     Label(ast::NodeId),\n     Method(DefId),\n     Err,\n@@ -109,7 +110,7 @@ impl Def {\n \n             Def::Fn(..) | Def::Mod(..) | Def::ForeignMod(..) | Def::Static(..) |\n             Def::Variant(..) | Def::Enum(..) | Def::TyAlias(..) | Def::AssociatedTy(..) |\n-            Def::TyParam(..) | Def::Struct(..) | Def::Trait(..) |\n+            Def::TyParam(..) | Def::Struct(..) | Def::Union(..) | Def::Trait(..) |\n             Def::Method(..) | Def::Const(..) | Def::AssociatedConst(..) |\n             Def::PrimTy(..) | Def::Label(..) | Def::SelfTy(..) | Def::Err => {\n                 bug!(\"attempted .var_id() on invalid {:?}\", self)\n@@ -121,7 +122,7 @@ impl Def {\n         match *self {\n             Def::Fn(id) | Def::Mod(id) | Def::ForeignMod(id) | Def::Static(id, _) |\n             Def::Variant(_, id) | Def::Enum(id) | Def::TyAlias(id) | Def::AssociatedTy(_, id) |\n-            Def::TyParam(id) | Def::Struct(id) | Def::Trait(id) |\n+            Def::TyParam(id) | Def::Struct(id) | Def::Union(id) | Def::Trait(id) |\n             Def::Method(id) | Def::Const(id) | Def::AssociatedConst(id) |\n             Def::Local(id, _) | Def::Upvar(id, _, _, _) => {\n                 id\n@@ -147,6 +148,7 @@ impl Def {\n             Def::TyAlias(..) => \"type\",\n             Def::AssociatedTy(..) => \"associated type\",\n             Def::Struct(..) => \"struct\",\n+            Def::Union(..) => \"union\",\n             Def::Trait(..) => \"trait\",\n             Def::Method(..) => \"method\",\n             Def::Const(..) => \"constant\","}, {"sha": "57b5599bd1d7ffd59065f0d20c3077cbc0437f2b", "filename": "src/librustc/hir/fold.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustc%2Fhir%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustc%2Fhir%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Ffold.rs?ref=d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2", "patch": "@@ -761,6 +761,10 @@ pub fn noop_fold_item_underscore<T: Folder>(i: Item_, folder: &mut T) -> Item_ {\n             let struct_def = folder.fold_variant_data(struct_def);\n             ItemStruct(struct_def, folder.fold_generics(generics))\n         }\n+        ItemUnion(struct_def, generics) => {\n+            let struct_def = folder.fold_variant_data(struct_def);\n+            ItemUnion(struct_def, folder.fold_generics(generics))\n+        }\n         ItemDefaultImpl(unsafety, ref trait_ref) => {\n             ItemDefaultImpl(unsafety, folder.fold_trait_ref((*trait_ref).clone()))\n         }"}, {"sha": "62157b1ca36819db1c5c3d6c3ebc8d6aac2a42c7", "filename": "src/librustc/hir/intravisit.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustc%2Fhir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustc%2Fhir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fintravisit.rs?ref=d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2", "patch": "@@ -348,7 +348,8 @@ pub fn walk_item<'v, V: Visitor<'v>>(visitor: &mut V, item: &'v Item) {\n             visitor.visit_ty(typ);\n             walk_list!(visitor, visit_impl_item, impl_items);\n         }\n-        ItemStruct(ref struct_definition, ref generics) => {\n+        ItemStruct(ref struct_definition, ref generics) |\n+        ItemUnion(ref struct_definition, ref generics) => {\n             visitor.visit_generics(generics);\n             visitor.visit_id(item.id);\n             visitor.visit_variant_data(struct_definition, item.name, generics, item.id, item.span);"}, {"sha": "80e034721d63f59228821a805d9bd38d93ebdd8c", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2", "patch": "@@ -638,7 +638,10 @@ impl<'a> LoweringContext<'a> {\n                 let struct_def = self.lower_variant_data(struct_def);\n                 hir::ItemStruct(struct_def, self.lower_generics(generics))\n             }\n-            ItemKind::Union(..) => panic!(\"`union` is not yet implemented\"),\n+            ItemKind::Union(ref vdata, ref generics) => {\n+                let vdata = self.lower_variant_data(vdata);\n+                hir::ItemUnion(vdata, self.lower_generics(generics))\n+            }\n             ItemKind::DefaultImpl(unsafety, ref trait_ref) => {\n                 hir::ItemDefaultImpl(self.lower_unsafety(unsafety),\n                                      self.lower_trait_ref(trait_ref))"}, {"sha": "29fb19fd42152bfc8cfe46913c0b1e3e48b1e577", "filename": "src/librustc/hir/map/def_collector.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs?ref=d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2", "patch": "@@ -302,9 +302,9 @@ impl<'ast> intravisit::Visitor<'ast> for DefCollector<'ast> {\n         let def_data = match i.node {\n             hir::ItemDefaultImpl(..) | hir::ItemImpl(..) =>\n                 DefPathData::Impl,\n-            hir::ItemEnum(..) | hir::ItemStruct(..) | hir::ItemTrait(..) |\n-            hir::ItemExternCrate(..) | hir::ItemMod(..) | hir::ItemForeignMod(..) |\n-            hir::ItemTy(..) =>\n+            hir::ItemEnum(..) | hir::ItemStruct(..) | hir::ItemUnion(..) |\n+            hir::ItemTrait(..) | hir::ItemExternCrate(..) | hir::ItemMod(..) |\n+            hir::ItemForeignMod(..) | hir::ItemTy(..) =>\n                 DefPathData::TypeNs(i.name.as_str()),\n             hir::ItemStatic(..) | hir::ItemConst(..) | hir::ItemFn(..) =>\n                 DefPathData::ValueNs(i.name.as_str()),\n@@ -331,7 +331,8 @@ impl<'ast> intravisit::Visitor<'ast> for DefCollector<'ast> {\n                         });\n                     }\n                 }\n-                hir::ItemStruct(ref struct_def, _) => {\n+                hir::ItemStruct(ref struct_def, _) |\n+                hir::ItemUnion(ref struct_def, _) => {\n                     // If this is a tuple-like struct, register the constructor.\n                     if !struct_def.is_struct() {\n                         this.create_def(struct_def.id(),"}, {"sha": "3ffc95e64f5a755c7bcf52c5da39f74811f24777", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2", "patch": "@@ -1030,6 +1030,7 @@ fn node_id_to_string(map: &Map, id: NodeId, include_id: bool) -> String {\n                 ItemTy(..) => \"ty\",\n                 ItemEnum(..) => \"enum\",\n                 ItemStruct(..) => \"struct\",\n+                ItemUnion(..) => \"union\",\n                 ItemTrait(..) => \"trait\",\n                 ItemImpl(..) => \"impl\",\n                 ItemDefaultImpl(..) => \"default impl\","}, {"sha": "e16005558f82bacd946815d58dd94ee895f4bc3d", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2", "patch": "@@ -1483,6 +1483,8 @@ pub enum Item_ {\n     ItemEnum(EnumDef, Generics),\n     /// A struct definition, e.g. `struct Foo<A> {x: A}`\n     ItemStruct(VariantData, Generics),\n+    /// A union definition, e.g. `union Foo<A, B> {x: A, y: B}`\n+    ItemUnion(VariantData, Generics),\n     /// Represents a Trait Declaration\n     ItemTrait(Unsafety, Generics, TyParamBounds, HirVec<TraitItem>),\n \n@@ -1512,6 +1514,7 @@ impl Item_ {\n             ItemTy(..) => \"type alias\",\n             ItemEnum(..) => \"enum\",\n             ItemStruct(..) => \"struct\",\n+            ItemUnion(..) => \"union\",\n             ItemTrait(..) => \"trait\",\n             ItemImpl(..) |\n             ItemDefaultImpl(..) => \"item\","}, {"sha": "f236bd4884d5bf70ad8d3d731f117faf9e653970", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2", "patch": "@@ -752,7 +752,10 @@ impl<'a> State<'a> {\n                 self.head(&visibility_qualified(&item.vis, \"struct\"))?;\n                 self.print_struct(struct_def, generics, item.name, item.span, true)?;\n             }\n-\n+            hir::ItemUnion(ref struct_def, ref generics) => {\n+                self.head(&visibility_qualified(&item.vis, \"union\"))?;\n+                self.print_struct(struct_def, generics, item.name, item.span, true)?;\n+            }\n             hir::ItemDefaultImpl(unsafety, ref trait_ref) => {\n                 self.head(\"\")?;\n                 self.print_visibility(&item.vis)?;"}, {"sha": "efce0c8354bacbdd361c64bc87c7710daf1dc365", "filename": "src/librustc/infer/error_reporting.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustc%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustc%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting.rs?ref=d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2", "patch": "@@ -105,6 +105,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             match item.node {\n                 hir::ItemImpl(..) => \"impl\",\n                 hir::ItemStruct(..) => \"struct\",\n+                hir::ItemUnion(..) => \"union\",\n                 hir::ItemEnum(..) => \"enum\",\n                 hir::ItemTrait(..) => \"trait\",\n                 hir::ItemFn(..) => \"function body\",\n@@ -1370,7 +1371,8 @@ impl<'a, 'gcx, 'tcx> Rebuilder<'a, 'gcx, 'tcx> {\n                 }\n                 hir::TyPath(ref maybe_qself, ref path) => {\n                     match self.tcx.expect_def(cur_ty.id) {\n-                        Def::Enum(did) | Def::TyAlias(did) | Def::Struct(did) => {\n+                        Def::Enum(did) | Def::TyAlias(did) |\n+                        Def::Struct(did) | Def::Union(did) => {\n                             let generics = self.tcx.lookup_generics(did);\n \n                             let expected ="}, {"sha": "8aeb0757f5de29a3d525b902f35b873c688a7f59", "filename": "src/librustc/infer/freshen.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustc%2Finfer%2Ffreshen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustc%2Finfer%2Ffreshen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ffreshen.rs?ref=d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2", "patch": "@@ -168,6 +168,7 @@ impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for TypeFreshener<'a, 'gcx, 'tcx> {\n             ty::TyFnPtr(_) |\n             ty::TyTrait(..) |\n             ty::TyStruct(..) |\n+            ty::TyUnion(..) |\n             ty::TyClosure(..) |\n             ty::TyNever |\n             ty::TyTuple(..) |"}, {"sha": "0b1d9e8d8f69efd321523bef3c35df7b3b61e623", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2", "patch": "@@ -86,7 +86,7 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n     }\n \n     fn lookup_and_handle_definition(&mut self, id: ast::NodeId) {\n-        use ty::TypeVariants::{TyEnum, TyStruct};\n+        use ty::TypeVariants::{TyEnum, TyStruct, TyUnion};\n \n         let def = self.tcx.expect_def(id);\n \n@@ -96,7 +96,7 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n             if self.tcx.trait_of_item(def.def_id()).is_some() => {\n                 if let Some(substs) = self.tcx.tables.borrow().item_substs.get(&id) {\n                     match substs.substs.type_at(0).sty {\n-                        TyEnum(tyid, _) | TyStruct(tyid, _) => {\n+                        TyEnum(tyid, _) | TyStruct(tyid, _) | TyUnion(tyid, _) => {\n                             self.check_def_id(tyid.did)\n                         }\n                         _ => {}\n@@ -132,10 +132,11 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n     }\n \n     fn handle_field_access(&mut self, lhs: &hir::Expr, name: ast::Name) {\n-        if let ty::TyStruct(def, _) = self.tcx.expr_ty_adjusted(lhs).sty {\n-            self.insert_def_id(def.struct_variant().field_named(name).did);\n-        } else {\n-            span_bug!(lhs.span, \"named field access on non-struct\")\n+        match self.tcx.expr_ty_adjusted(lhs).sty {\n+            ty::TyStruct(def, _) | ty::TyUnion(def, _) => {\n+                self.insert_def_id(def.struct_variant().field_named(name).did);\n+            }\n+            _ => span_bug!(lhs.span, \"named field access on non-struct/union\"),\n         }\n     }\n \n@@ -148,7 +149,7 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n     fn handle_field_pattern_match(&mut self, lhs: &hir::Pat,\n                                   pats: &[codemap::Spanned<hir::FieldPat>]) {\n         let variant = match self.tcx.node_id_to_type(lhs.id).sty {\n-            ty::TyStruct(adt, _) | ty::TyEnum(adt, _) => {\n+            ty::TyStruct(adt, _) | ty::TyUnion(adt, _) | ty::TyEnum(adt, _) => {\n                 adt.variant_of_def(self.tcx.expect_def(lhs.id))\n             }\n             _ => span_bug!(lhs.span, \"non-ADT in struct pattern\")\n@@ -185,7 +186,7 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n         match *node {\n             ast_map::NodeItem(item) => {\n                 match item.node {\n-                    hir::ItemStruct(..) => {\n+                    hir::ItemStruct(..) | hir::ItemUnion(..) => {\n                         self.struct_has_extern_repr = item.attrs.iter().any(|attr| {\n                             attr::find_repr_attrs(self.tcx.sess.diagnostic(), attr)\n                                 .contains(&attr::ReprExtern)\n@@ -423,7 +424,8 @@ impl<'a, 'tcx> DeadVisitor<'a, 'tcx> {\n             | hir::ItemConst(..)\n             | hir::ItemFn(..)\n             | hir::ItemEnum(..)\n-            | hir::ItemStruct(..) => true,\n+            | hir::ItemStruct(..)\n+            | hir::ItemUnion(..) => true,\n             _ => false\n         };\n         let ctor_id = get_struct_ctor_id(item);"}, {"sha": "e52eba68da19871f7f77da88ea6fb266485ce86c", "filename": "src/librustc/middle/effect.rs", "status": "modified", "additions": 20, "deletions": 4, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustc%2Fmiddle%2Feffect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustc%2Fmiddle%2Feffect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Feffect.rs?ref=d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2", "patch": "@@ -13,15 +13,14 @@\n use self::RootUnsafeContext::*;\n \n use dep_graph::DepNode;\n-use hir::def::Def;\n use ty::{self, Ty, TyCtxt};\n use ty::MethodCall;\n \n use syntax::ast;\n use syntax_pos::Span;\n-use hir;\n-use hir::intravisit;\n-use hir::intravisit::{FnKind, Visitor};\n+use hir::{self, PatKind};\n+use hir::def::Def;\n+use hir::intravisit::{self, FnKind, Visitor};\n \n #[derive(Copy, Clone)]\n struct UnsafeContext {\n@@ -178,11 +177,28 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EffectCheckVisitor<'a, 'tcx> {\n                     self.require_unsafe(expr.span, \"use of mutable static\");\n                 }\n             }\n+            hir::ExprField(ref base_expr, field) => {\n+                if let ty::TyUnion(..) = self.tcx.expr_ty_adjusted(base_expr).sty {\n+                    self.require_unsafe(field.span, \"access to union field\");\n+                }\n+            }\n             _ => {}\n         }\n \n         intravisit::walk_expr(self, expr);\n     }\n+\n+    fn visit_pat(&mut self, pat: &hir::Pat) {\n+        if let PatKind::Struct(_, ref fields, _) = pat.node {\n+            if let ty::TyUnion(..) = self.tcx.pat_ty(pat).sty {\n+                for field in fields {\n+                    self.require_unsafe(field.span, \"matching on union field\");\n+                }\n+            }\n+        }\n+\n+        intravisit::walk_pat(self, pat);\n+    }\n }\n \n pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {"}, {"sha": "541aeeb7d8dd7e861f6fa6519f358839862284ec", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2", "patch": "@@ -414,7 +414,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n             }\n \n             hir::ExprStruct(_, ref fields, ref opt_with) => {\n-                self.walk_struct_expr(expr, fields, opt_with);\n+                self.walk_struct_expr(fields, opt_with);\n             }\n \n             hir::ExprTup(ref exprs) => {\n@@ -655,7 +655,6 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n     }\n \n     fn walk_struct_expr(&mut self,\n-                        _expr: &hir::Expr,\n                         fields: &[hir::Field],\n                         opt_with: &Option<P<hir::Expr>>) {\n         // Consume the expressions supplying values for each field.\n@@ -695,7 +694,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n                     with_expr.span,\n                     \"with expression doesn't evaluate to a struct\");\n             }\n-        };\n+        }\n \n         // walk the with expression so that complex expressions\n         // are properly handled.\n@@ -1012,7 +1011,8 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n                     debug!(\"variant downcast_cmt={:?} pat={:?}\", downcast_cmt, pat);\n                     delegate.matched_pat(pat, downcast_cmt, match_mode);\n                 }\n-                Some(Def::Struct(..)) | Some(Def::TyAlias(..)) | Some(Def::AssociatedTy(..)) => {\n+                Some(Def::Struct(..)) | Some(Def::Union(..)) |\n+                Some(Def::TyAlias(..)) | Some(Def::AssociatedTy(..)) => {\n                     debug!(\"struct cmt_pat={:?} pat={:?}\", cmt_pat, pat);\n                     delegate.matched_pat(pat, cmt_pat, match_mode);\n                 }"}, {"sha": "b17411ced57fb4fd569c8ae1c973705d6b06b521", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2", "patch": "@@ -572,7 +572,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n                id, expr_ty, def);\n \n         match def {\n-          Def::Struct(..) | Def::Variant(..) | Def::Const(..) |\n+          Def::Struct(..) | Def::Union(..) | Def::Variant(..) | Def::Const(..) |\n           Def::AssociatedConst(..) | Def::Fn(..) | Def::Method(..) => {\n                 Ok(self.cat_rvalue_node(id, span, expr_ty))\n           }"}, {"sha": "0625504af88ea9a8c58b482b14598561fc1b5983", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2", "patch": "@@ -269,7 +269,7 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n                     hir::ItemMod(..) | hir::ItemForeignMod(..) |\n                     hir::ItemImpl(..) | hir::ItemTrait(..) |\n                     hir::ItemStruct(..) | hir::ItemEnum(..) |\n-                    hir::ItemDefaultImpl(..) => {}\n+                    hir::ItemUnion(..) | hir::ItemDefaultImpl(..) => {}\n                 }\n             }\n             ast_map::NodeTraitItem(trait_method) => {"}, {"sha": "4d1eed612cfd5420cc321577d3b775ae7d6705da", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2", "patch": "@@ -156,6 +156,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for LifetimeContext<'a, 'tcx> {\n                 hir::ItemTy(_, ref generics) |\n                 hir::ItemEnum(_, ref generics) |\n                 hir::ItemStruct(_, ref generics) |\n+                hir::ItemUnion(_, ref generics) |\n                 hir::ItemTrait(_, ref generics, _, _) |\n                 hir::ItemImpl(_, _, ref generics, _, _, _) => {\n                     // These kinds of items have only early bound lifetime parameters."}, {"sha": "aea1ee8d82401d76ca83caaaad91fe30727b0aeb", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2", "patch": "@@ -561,9 +561,11 @@ pub fn check_expr<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, e: &hir::Expr,\n         hir::ExprField(ref base_e, ref field) => {\n             span = field.span;\n             match tcx.expr_ty_adjusted(base_e).sty {\n-                ty::TyStruct(def, _) => def.struct_variant().field_named(field.node).did,\n+                ty::TyStruct(def, _) | ty::TyUnion(def, _) => {\n+                    def.struct_variant().field_named(field.node).did\n+                }\n                 _ => span_bug!(e.span,\n-                               \"stability::check_expr: named field access on non-struct\")\n+                               \"stability::check_expr: named field access on non-struct/union\")\n             }\n         }\n         hir::ExprTupField(ref base_e, ref field) => {\n@@ -579,7 +581,7 @@ pub fn check_expr<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, e: &hir::Expr,\n         hir::ExprStruct(_, ref expr_fields, _) => {\n             let type_ = tcx.expr_ty(e);\n             match type_.sty {\n-                ty::TyStruct(def, _) => {\n+                ty::TyStruct(def, _) | ty::TyUnion(def, _) => {\n                     // check the stability of each field that appears\n                     // in the construction expression.\n                     for field in expr_fields {\n@@ -599,7 +601,7 @@ pub fn check_expr<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, e: &hir::Expr,\n                 _ => {\n                     span_bug!(e.span,\n                               \"stability::check_expr: struct construction \\\n-                               of non-struct, type {:?}\",\n+                               of non-struct/union, type {:?}\",\n                               type_);\n                 }\n             }\n@@ -647,7 +649,8 @@ pub fn check_pat<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, pat: &hir::Pat,\n     if is_internal(tcx, pat.span) { return; }\n \n     let v = match tcx.pat_ty_opt(pat) {\n-        Some(&ty::TyS { sty: ty::TyStruct(def, _), .. }) => def.struct_variant(),\n+        Some(&ty::TyS { sty: ty::TyStruct(def, _), .. }) |\n+        Some(&ty::TyS { sty: ty::TyUnion(def, _), .. }) => def.struct_variant(),\n         Some(_) | None => return,\n     };\n     match pat.node {"}, {"sha": "a2abaa5e12f5531d49590f46a4257884082cb8b3", "filename": "src/librustc/mir/repr.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustc%2Fmir%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustc%2Fmir%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Frepr.rs?ref=d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2", "patch": "@@ -962,7 +962,10 @@ pub enum CastKind {\n pub enum AggregateKind<'tcx> {\n     Vec,\n     Tuple,\n-    Adt(AdtDef<'tcx>, usize, &'tcx Substs<'tcx>),\n+    /// The second field is variant number (discriminant), it's equal to 0\n+    /// for struct and union expressions. The fourth field is active field\n+    /// number and is present only for union expressions.\n+    Adt(AdtDef<'tcx>, usize, &'tcx Substs<'tcx>, Option<usize>),\n     Closure(DefId, ClosureSubsts<'tcx>),\n }\n \n@@ -1069,7 +1072,7 @@ impl<'tcx> Debug for Rvalue<'tcx> {\n                         }\n                     }\n \n-                    Adt(adt_def, variant, substs) => {\n+                    Adt(adt_def, variant, substs, _) => {\n                         let variant_def = &adt_def.variants[variant];\n \n                         ppaux::parameterized(fmt, substs, variant_def.did,"}, {"sha": "a0ccc72aa1fcea0d317113b1128fe988bbf525cd", "filename": "src/librustc/mir/tcx.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustc%2Fmir%2Ftcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustc%2Fmir%2Ftcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Ftcx.rs?ref=d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2", "patch": "@@ -187,7 +187,7 @@ impl<'tcx> Rvalue<'tcx> {\n                             ops.iter().map(|op| op.ty(mir, tcx)).collect()\n                         ))\n                     }\n-                    AggregateKind::Adt(def, _, substs) => {\n+                    AggregateKind::Adt(def, _, substs, _) => {\n                         Some(tcx.lookup_item_type(def.did).ty.subst(tcx, substs))\n                     }\n                     AggregateKind::Closure(did, substs) => {"}, {"sha": "c2d0b2c686e777b8e4a0c3e1f095ebe42866ff08", "filename": "src/librustc/mir/visit.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fvisit.rs?ref=d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2", "patch": "@@ -536,7 +536,8 @@ macro_rules! make_mir_visitor {\n                             }\n                             AggregateKind::Adt(_adt_def,\n                                                _variant_index,\n-                                               ref $($mutability)* substs) => {\n+                                               ref $($mutability)* substs,\n+                                               _active_field_index) => {\n                                 self.visit_substs(substs);\n                             }\n                             AggregateKind::Closure(ref $($mutability)* def_id,"}, {"sha": "0a7d3e6e76d8f0052cfb3baa65a8805decac0819", "filename": "src/librustc/traits/coherence.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fcoherence.rs?ref=d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2", "patch": "@@ -224,7 +224,7 @@ fn fundamental_ty(tcx: TyCtxt, ty: Ty) -> bool {\n     match ty.sty {\n         ty::TyBox(..) | ty::TyRef(..) =>\n             true,\n-        ty::TyEnum(def, _) | ty::TyStruct(def, _) =>\n+        ty::TyEnum(def, _) | ty::TyStruct(def, _) | ty::TyUnion(def, _) =>\n             def.is_fundamental(),\n         ty::TyTrait(ref data) =>\n             tcx.has_attr(data.principal.def_id(), \"fundamental\"),\n@@ -261,7 +261,8 @@ fn ty_is_local_constructor(tcx: TyCtxt, ty: Ty, infer_is_local: InferIsLocal)->\n         }\n \n         ty::TyEnum(def, _) |\n-        ty::TyStruct(def, _) => {\n+        ty::TyStruct(def, _) |\n+        ty::TyUnion(def, _) => {\n             def.did.is_local()\n         }\n "}, {"sha": "e5ebe96932d4f9eb77734e84985f915beb2bae7b", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2", "patch": "@@ -166,13 +166,15 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 ty::TyParam(..) => Some(14),\n                 ty::TyAnon(..) => Some(15),\n                 ty::TyNever => Some(16),\n+                ty::TyUnion(..) => Some(17),\n                 ty::TyInfer(..) | ty::TyError => None\n             }\n         }\n \n         match (type_category(a), type_category(b)) {\n             (Some(cat_a), Some(cat_b)) => match (&a.sty, &b.sty) {\n                 (&ty::TyStruct(def_a, _), &ty::TyStruct(def_b, _)) |\n+                (&ty::TyUnion(def_a, _), &ty::TyUnion(def_b, _)) |\n                 (&ty::TyEnum(def_a, _), &ty::TyEnum(def_b, _)) =>\n                     def_a == def_b,\n                 _ => cat_a == cat_b"}, {"sha": "f8f10d9c26541996cf63ae80a1c96cd473d14fd1", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2", "patch": "@@ -1780,7 +1780,8 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                 Where(ty::Binder(tys.last().into_iter().cloned().collect()))\n             }\n \n-            ty::TyStruct(def, substs) | ty::TyEnum(def, substs) => {\n+            ty::TyStruct(def, substs) | ty::TyUnion(def, substs) |\n+            ty::TyEnum(def, substs) => {\n                 let sized_crit = def.sized_constraint(self.tcx());\n                 // (*) binder moved here\n                 Where(ty::Binder(match sized_crit.sty {\n@@ -1836,7 +1837,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                 Where(ty::Binder(tys.to_vec()))\n             }\n \n-            ty::TyStruct(..) | ty::TyEnum(..) |\n+            ty::TyStruct(..) | ty::TyUnion(..) | ty::TyEnum(..) |\n             ty::TyProjection(..) | ty::TyParam(..) | ty::TyAnon(..) => {\n                 // Fallback to whatever user-defined impls exist in this case.\n                 None\n@@ -1933,7 +1934,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                 substs.types().collect()\n             }\n \n-            ty::TyStruct(def, substs) | ty::TyEnum(def, substs) => {\n+            ty::TyStruct(def, substs) | ty::TyUnion(def, substs) | ty::TyEnum(def, substs) => {\n                 def.all_fields()\n                     .map(|f| f.ty(self.tcx(), substs))\n                     .collect()"}, {"sha": "d7d4693c1165f2e5c988022686d9ee347daad161", "filename": "src/librustc/ty/contents.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustc%2Fty%2Fcontents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustc%2Fty%2Fcontents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontents.rs?ref=d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2", "patch": "@@ -224,7 +224,8 @@ impl<'a, 'tcx> ty::TyS<'tcx> {\n                                         |ty| tc_ty(tcx, *ty, cache))\n                 }\n \n-                ty::TyStruct(def, substs) | ty::TyEnum(def, substs) => {\n+                ty::TyStruct(def, substs) | ty::TyUnion(def, substs) |\n+                ty::TyEnum(def, substs) => {\n                     let mut res =\n                         TypeContents::union(&def.variants, |v| {\n                             TypeContents::union(&v.fields, |f| {"}, {"sha": "0fc1641d31f705021016849f30e227fcf1ffebcd", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2", "patch": "@@ -1032,8 +1032,8 @@ impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n     pub fn print_debug_stats(self) {\n         sty_debug_print!(\n             self,\n-            TyEnum, TyBox, TyArray, TySlice, TyRawPtr, TyRef, TyFnDef, TyFnPtr,\n-            TyTrait, TyStruct, TyClosure, TyTuple, TyParam, TyInfer, TyProjection, TyAnon);\n+            TyEnum, TyBox, TyArray, TySlice, TyRawPtr, TyRef, TyFnDef, TyFnPtr, TyTrait,\n+            TyStruct, TyUnion, TyClosure, TyTuple, TyParam, TyInfer, TyProjection, TyAnon);\n \n         println!(\"Substs interner: #{}\", self.interners.substs.borrow().len());\n         println!(\"BareFnTy interner: #{}\", self.interners.bare_fn.borrow().len());\n@@ -1321,6 +1321,11 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         self.mk_ty(TyStruct(def, substs))\n     }\n \n+    pub fn mk_union(self, def: AdtDef<'tcx>, substs: &'tcx Substs<'tcx>) -> Ty<'tcx> {\n+        // take a copy of substs so that we own the vectors inside\n+        self.mk_ty(TyUnion(def, substs))\n+    }\n+\n     pub fn mk_closure(self,\n                       closure_id: DefId,\n                       substs: &'tcx Substs<'tcx>,"}, {"sha": "0e33e396f7e187f7a8bfccceb58b64961d81c966", "filename": "src/librustc/ty/error.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustc%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustc%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ferror.rs?ref=d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2", "patch": "@@ -247,6 +247,9 @@ impl<'a, 'gcx, 'lcx, 'tcx> ty::TyS<'tcx> {\n             ty::TyStruct(def, _) => {\n                 format!(\"struct `{}`\", tcx.item_path_str(def.did))\n             }\n+            ty::TyUnion(def, _) => {\n+                format!(\"union `{}`\", tcx.item_path_str(def.did))\n+            }\n             ty::TyClosure(..) => \"closure\".to_string(),\n             ty::TyTuple(_) => \"tuple\".to_string(),\n             ty::TyInfer(ty::TyVar(_)) => \"inferred type\".to_string(),"}, {"sha": "f9ca2484d7efcf6a32907d8b126f40e350e18dff", "filename": "src/librustc/ty/fast_reject.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustc%2Fty%2Ffast_reject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustc%2Fty%2Ffast_reject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ffast_reject.rs?ref=d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2", "patch": "@@ -30,6 +30,7 @@ pub enum SimplifiedType {\n     TupleSimplifiedType(usize),\n     TraitSimplifiedType(DefId),\n     StructSimplifiedType(DefId),\n+    UnionSimplifiedType(DefId),\n     ClosureSimplifiedType(DefId),\n     AnonSimplifiedType(DefId),\n     FunctionSimplifiedType(usize),\n@@ -66,6 +67,9 @@ pub fn simplify_type<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n         ty::TyStruct(def, _) => {\n             Some(StructSimplifiedType(def.did))\n         }\n+        ty::TyUnion(def, _) => {\n+            Some(UnionSimplifiedType(def.did))\n+        }\n         ty::TyRef(_, mt) => {\n             // since we introduce auto-refs during method lookup, we\n             // just treat &T and T as equivalent from the point of"}, {"sha": "ce6e4d6516ec6977601588d2cd0baa0fb8288c86", "filename": "src/librustc/ty/flags.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustc%2Fty%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustc%2Fty%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fflags.rs?ref=d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2", "patch": "@@ -102,7 +102,7 @@ impl FlagComputation {\n                 }\n             }\n \n-            &ty::TyEnum(_, substs) | &ty::TyStruct(_, substs) => {\n+            &ty::TyEnum(_, substs) | &ty::TyStruct(_, substs) | &ty::TyUnion(_, substs) => {\n                 self.add_substs(substs);\n             }\n "}, {"sha": "ba8d3328509254b2972607942ea65fcb0dbe1f71", "filename": "src/librustc/ty/item_path.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustc%2Fty%2Fitem_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustc%2Fty%2Fitem_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fitem_path.rs?ref=d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2", "patch": "@@ -263,6 +263,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         // anything other than a simple path.\n         match self_ty.sty {\n             ty::TyStruct(adt_def, substs) |\n+            ty::TyUnion(adt_def, substs) |\n             ty::TyEnum(adt_def, substs) => {\n                 if substs.types().next().is_none() { // ignore regions\n                     self.push_item_path(buffer, adt_def.did);\n@@ -320,6 +321,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n pub fn characteristic_def_id_of_type(ty: Ty) -> Option<DefId> {\n     match ty.sty {\n         ty::TyStruct(adt_def, _) |\n+        ty::TyUnion(adt_def, _) |\n         ty::TyEnum(adt_def, _) => Some(adt_def.did),\n \n         ty::TyTrait(ref data) => Some(data.principal.def_id()),"}, {"sha": "9270057b54415b8ac8ad7124e652f569461fec56", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 66, "deletions": 2, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2", "patch": "@@ -488,7 +488,7 @@ impl<'a, 'gcx, 'tcx> Struct {\n \n         for field in fields {\n             if !self.sized {\n-                bug!(\"Struct::compute: field #{} of `{}` comes after unsized field\",\n+                bug!(\"Struct::extend: field #{} of `{}` comes after unsized field\",\n                      self.offset_after_field.len(), scapegoat);\n             }\n \n@@ -623,6 +623,54 @@ impl<'a, 'gcx, 'tcx> Struct {\n     }\n }\n \n+/// An untagged union.\n+#[derive(PartialEq, Eq, Hash, Debug)]\n+pub struct Union {\n+    pub align: Align,\n+\n+    pub min_size: Size,\n+\n+    /// If true, no alignment padding is used.\n+    pub packed: bool,\n+}\n+\n+impl<'a, 'gcx, 'tcx> Union {\n+    pub fn new(dl: &TargetDataLayout, packed: bool) -> Union {\n+        Union {\n+            align: if packed { dl.i8_align } else { dl.aggregate_align },\n+            min_size: Size::from_bytes(0),\n+            packed: packed,\n+        }\n+    }\n+\n+    /// Extend the Struct with more fields.\n+    pub fn extend<I>(&mut self, dl: &TargetDataLayout,\n+                     fields: I,\n+                     scapegoat: Ty<'gcx>)\n+                     -> Result<(), LayoutError<'gcx>>\n+    where I: Iterator<Item=Result<&'a Layout, LayoutError<'gcx>>> {\n+        for (index, field) in fields.enumerate() {\n+            let field = field?;\n+            if field.is_unsized() {\n+                bug!(\"Union::extend: field #{} of `{}` is unsized\",\n+                     index, scapegoat);\n+            }\n+\n+            if !self.packed {\n+                self.align = self.align.max(field.align(dl));\n+            }\n+            self.min_size = cmp::max(self.min_size, field.size(dl));\n+        }\n+\n+        Ok(())\n+    }\n+\n+    /// Get the size with trailing aligment padding.\n+    pub fn stride(&self) -> Size {\n+        self.min_size.abi_align(self.align)\n+    }\n+}\n+\n /// The first half of a fat pointer.\n /// - For a trait object, this is the address of the box.\n /// - For a slice, this is the base address.\n@@ -690,6 +738,11 @@ pub enum Layout {\n         non_zero: bool\n     },\n \n+    /// Untagged unions.\n+    UntaggedUnion {\n+        variants: Union,\n+    },\n+\n     /// General-case enums: for each case there is a struct, and they\n     /// all start with a field for the discriminant.\n     General {\n@@ -896,6 +949,15 @@ impl<'a, 'gcx, 'tcx> Layout {\n                     non_zero: Some(def.did) == tcx.lang_items.non_zero()\n                 }\n             }\n+            ty::TyUnion(def, substs) => {\n+                let fields = def.struct_variant().fields.iter().map(|field| {\n+                    field.ty(tcx, substs).layout(infcx)\n+                });\n+                let packed = tcx.lookup_packed(def.did);\n+                let mut un = Union::new(dl, packed);\n+                un.extend(dl, fields, ty)?;\n+                UntaggedUnion { variants: un }\n+            }\n             ty::TyEnum(def, substs) => {\n                 let hint = *tcx.lookup_repr_hints(def.did).get(0)\n                     .unwrap_or(&attr::ReprAny);\n@@ -1115,7 +1177,7 @@ impl<'a, 'gcx, 'tcx> Layout {\n     pub fn is_unsized(&self) -> bool {\n         match *self {\n             Scalar {..} | Vector {..} | FatPointer {..} |\n-            CEnum {..} | General {..} |\n+            CEnum {..} | UntaggedUnion {..} | General {..} |\n             RawNullablePointer {..} |\n             StructWrappedNullablePointer {..} => false,\n \n@@ -1149,6 +1211,7 @@ impl<'a, 'gcx, 'tcx> Layout {\n \n             CEnum { discr, .. } => Int(discr).size(dl),\n             Array { size, .. } | General { size, .. } => size,\n+            UntaggedUnion { ref variants } => variants.stride(),\n \n             Univariant { ref variant, .. } |\n             StructWrappedNullablePointer { nonnull: ref variant, .. } => {\n@@ -1188,6 +1251,7 @@ impl<'a, 'gcx, 'tcx> Layout {\n \n             CEnum { discr, .. } => Int(discr).align(dl),\n             Array { align, .. } | General { align, .. } => align,\n+            UntaggedUnion { ref variants } => variants.align,\n \n             Univariant { ref variant, .. } |\n             StructWrappedNullablePointer { nonnull: ref variant, .. } => {"}, {"sha": "e88f72f2d84bc4a979ea85f64b77754060817ae6", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 16, "deletions": 7, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2", "patch": "@@ -948,6 +948,7 @@ impl<'tcx> TraitPredicate<'tcx> {\n                 .flat_map(|t| t.walk())\n                 .filter_map(|t| match t.sty {\n                     ty::TyStruct(adt_def, _) |\n+                    ty::TyUnion(adt_def, _) |\n                     ty::TyEnum(adt_def, _) =>\n                         Some(adt_def.did),\n                     _ =>\n@@ -1341,6 +1342,7 @@ impl<'a, 'tcx> ParameterEnvironment<'tcx> {\n                     }\n                     hir::ItemEnum(..) |\n                     hir::ItemStruct(..) |\n+                    hir::ItemUnion(..) |\n                     hir::ItemTy(..) |\n                     hir::ItemImpl(..) |\n                     hir::ItemConst(..) |\n@@ -1421,6 +1423,7 @@ bitflags! {\n         const IS_PHANTOM_DATA     = 1 << 3,\n         const IS_SIMD             = 1 << 4,\n         const IS_FUNDAMENTAL      = 1 << 5,\n+        const IS_UNION            = 1 << 6,\n     }\n }\n \n@@ -1513,7 +1516,7 @@ impl<'tcx> Decodable for AdtDef<'tcx> {\n \n \n #[derive(Copy, Clone, Debug, Eq, PartialEq)]\n-pub enum AdtKind { Struct, Enum }\n+pub enum AdtKind { Struct, Union, Enum }\n \n #[derive(Clone, Copy, PartialEq, Eq, Hash, Debug, RustcEncodable, RustcDecodable)]\n pub enum VariantKind { Struct, Tuple, Unit }\n@@ -1544,8 +1547,10 @@ impl<'a, 'gcx, 'tcx, 'container> AdtDefData<'gcx, 'container> {\n         if Some(did) == tcx.lang_items.phantom_data() {\n             flags = flags | AdtFlags::IS_PHANTOM_DATA;\n         }\n-        if let AdtKind::Enum = kind {\n-            flags = flags | AdtFlags::IS_ENUM;\n+        match kind {\n+            AdtKind::Enum => flags = flags | AdtFlags::IS_ENUM,\n+            AdtKind::Union => flags = flags | AdtFlags::IS_UNION,\n+            AdtKind::Struct => {}\n         }\n         AdtDefData {\n             did: did,\n@@ -1568,6 +1573,8 @@ impl<'a, 'gcx, 'tcx, 'container> AdtDefData<'gcx, 'container> {\n     pub fn adt_kind(&self) -> AdtKind {\n         if self.flags.get().intersects(AdtFlags::IS_ENUM) {\n             AdtKind::Enum\n+        } else if self.flags.get().intersects(AdtFlags::IS_UNION) {\n+            AdtKind::Union\n         } else {\n             AdtKind::Struct\n         }\n@@ -1610,7 +1617,8 @@ impl<'a, 'gcx, 'tcx, 'container> AdtDefData<'gcx, 'container> {\n     /// Asserts this is a struct and returns the struct's unique\n     /// variant.\n     pub fn struct_variant(&self) -> &VariantDefData<'gcx, 'container> {\n-        assert_eq!(self.adt_kind(), AdtKind::Struct);\n+        let adt_kind = self.adt_kind();\n+        assert!(adt_kind == AdtKind::Struct || adt_kind == AdtKind::Union);\n         &self.variants[0]\n     }\n \n@@ -1669,7 +1677,8 @@ impl<'a, 'gcx, 'tcx, 'container> AdtDefData<'gcx, 'container> {\n     pub fn variant_of_def(&self, def: Def) -> &VariantDefData<'gcx, 'container> {\n         match def {\n             Def::Variant(_, vid) => self.variant_with_id(vid),\n-            Def::Struct(..) | Def::TyAlias(..) | Def::AssociatedTy(..) => self.struct_variant(),\n+            Def::Struct(..) | Def::Union(..) |\n+            Def::TyAlias(..) | Def::AssociatedTy(..) => self.struct_variant(),\n             _ => bug!(\"unexpected def {:?} in variant_of_def\", def)\n         }\n     }\n@@ -1818,7 +1827,7 @@ impl<'a, 'tcx> AdtDefData<'tcx, 'tcx> {\n                 }\n             }\n \n-            TyEnum(adt, substs) | TyStruct(adt, substs) => {\n+            TyEnum(adt, substs) | TyStruct(adt, substs) | TyUnion(adt, substs) => {\n                 // recursive case\n                 let adt = tcx.lookup_adt_def_master(adt.did);\n                 adt.calculate_sized_constraint_inner(tcx, stack);\n@@ -2408,7 +2417,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             Def::Variant(enum_did, did) => {\n                 self.lookup_adt_def(enum_did).variant_with_id(did)\n             }\n-            Def::Struct(did) => {\n+            Def::Struct(did) | Def::Union(did) => {\n                 self.lookup_adt_def(did).struct_variant()\n             }\n             _ => bug!(\"expect_variant_def used with unexpected def {:?}\", def)"}, {"sha": "a7bb0374b75bf3810f49ff514d2ed9ca095d4e8f", "filename": "src/librustc/ty/outlives.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustc%2Fty%2Foutlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustc%2Fty%2Foutlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Foutlives.rs?ref=d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2", "patch": "@@ -174,6 +174,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             ty::TyNever |           // ...\n             ty::TyEnum(..) |        // OutlivesNominalType\n             ty::TyStruct(..) |      // OutlivesNominalType\n+            ty::TyUnion(..) |      // OutlivesNominalType\n             ty::TyBox(..) |         // OutlivesNominalType (ish)\n             ty::TyAnon(..) |        // OutlivesNominalType (ish)\n             ty::TyStr |             // OutlivesScalar (ish)"}, {"sha": "dfae19487b6f0ccb8bb38c0ac413de69bfa67f16", "filename": "src/librustc/ty/relate.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustc%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustc%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Frelate.rs?ref=d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2", "patch": "@@ -447,6 +447,13 @@ pub fn super_relate_tys<'a, 'gcx, 'tcx, R>(relation: &mut R,\n             Ok(tcx.mk_struct(a_def, substs))\n         }\n \n+        (&ty::TyUnion(a_def, a_substs), &ty::TyUnion(b_def, b_substs))\n+            if a_def == b_def =>\n+        {\n+            let substs = relate_item_substs(relation, a_def.did, a_substs, b_substs)?;\n+            Ok(tcx.mk_union(a_def, substs))\n+        }\n+\n         (&ty::TyClosure(a_id, a_substs),\n          &ty::TyClosure(b_id, b_substs))\n             if a_id == b_id =>"}, {"sha": "952641f6832f90b373f9fd46966e4a0ea0a78822", "filename": "src/librustc/ty/structural_impls.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fstructural_impls.rs?ref=d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2", "patch": "@@ -495,6 +495,7 @@ impl<'tcx> TypeFoldable<'tcx> for Ty<'tcx> {\n                 ty::TyRef(r.fold_with(folder), tm.fold_with(folder))\n             }\n             ty::TyStruct(did, substs) => ty::TyStruct(did, substs.fold_with(folder)),\n+            ty::TyUnion(did, substs) => ty::TyUnion(did, substs.fold_with(folder)),\n             ty::TyClosure(did, substs) => ty::TyClosure(did, substs.fold_with(folder)),\n             ty::TyProjection(ref data) => ty::TyProjection(data.fold_with(folder)),\n             ty::TyAnon(did, substs) => ty::TyAnon(did, substs.fold_with(folder)),\n@@ -524,6 +525,7 @@ impl<'tcx> TypeFoldable<'tcx> for Ty<'tcx> {\n             ty::TyFnPtr(ref f) => f.visit_with(visitor),\n             ty::TyRef(r, ref tm) => r.visit_with(visitor) || tm.visit_with(visitor),\n             ty::TyStruct(_did, ref substs) => substs.visit_with(visitor),\n+            ty::TyUnion(_did, ref substs) => substs.visit_with(visitor),\n             ty::TyClosure(_did, ref substs) => substs.visit_with(visitor),\n             ty::TyProjection(ref data) => data.visit_with(visitor),\n             ty::TyAnon(_, ref substs) => substs.visit_with(visitor),"}, {"sha": "d45fde925c511deeec73f01867428368d39bee01", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2", "patch": "@@ -112,14 +112,19 @@ pub enum TypeVariants<'tcx> {\n     /// That is, even after substitution it is possible that there are type\n     /// variables. This happens when the `TyEnum` corresponds to an enum\n     /// definition and not a concrete use of it. This is true for `TyStruct`\n-    /// as well.\n+    /// and `TyUnion` as well.\n     TyEnum(AdtDef<'tcx>, &'tcx Substs<'tcx>),\n \n     /// A structure type, defined with `struct`.\n     ///\n     /// See warning about substitutions for enumerated types.\n     TyStruct(AdtDef<'tcx>, &'tcx Substs<'tcx>),\n \n+    /// A union type, defined with `union`.\n+    ///\n+    /// See warning about substitutions for enumerated types.\n+    TyUnion(AdtDef<'tcx>, &'tcx Substs<'tcx>),\n+\n     /// `Box<T>`; this is nominally a struct in the documentation, but is\n     /// special-cased internally. For example, it is possible to implicitly\n     /// move the contents of a box out of that box, and methods of any type\n@@ -917,7 +922,7 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n         // FIXME(#24885): be smarter here, the AdtDefData::is_empty method could easily be made\n         // more complete.\n         match self.sty {\n-            TyEnum(def, _) | TyStruct(def, _) => def.is_empty(),\n+            TyEnum(def, _) | TyStruct(def, _) | TyUnion(def, _) => def.is_empty(),\n \n             // FIXME(canndrew): There's no reason why these can't be uncommented, they're tested\n             // and they don't break anything. But I'm keeping my changes small for now.\n@@ -980,7 +985,7 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n \n     pub fn is_structural(&self) -> bool {\n         match self.sty {\n-            TyStruct(..) | TyTuple(_) | TyEnum(..) |\n+            TyStruct(..) | TyUnion(..) | TyTuple(..) | TyEnum(..) |\n             TyArray(..) | TyClosure(..) => true,\n             _ => self.is_slice() | self.is_trait()\n         }\n@@ -1199,6 +1204,7 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n         match self.sty {\n             TyTrait(ref tt) => Some(tt.principal.def_id()),\n             TyStruct(def, _) |\n+            TyUnion(def, _) |\n             TyEnum(def, _) => Some(def.did),\n             TyClosure(id, _) => Some(id),\n             _ => None\n@@ -1207,7 +1213,7 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n \n     pub fn ty_adt_def(&self) -> Option<AdtDef<'tcx>> {\n         match self.sty {\n-            TyStruct(adt, _) | TyEnum(adt, _) => Some(adt),\n+            TyStruct(adt, _) | TyUnion(adt, _) | TyEnum(adt, _) => Some(adt),\n             _ => None\n         }\n     }\n@@ -1227,6 +1233,7 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n             }\n             TyEnum(_, substs) |\n             TyStruct(_, substs) |\n+            TyUnion(_, substs) |\n             TyAnon(_, substs) => {\n                 substs.regions().collect()\n             }"}, {"sha": "ad209094600ae19e198289ea2152ed790a44c4de", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 13, "deletions": 9, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2", "patch": "@@ -138,7 +138,7 @@ impl<'tcx> ParameterEnvironment<'tcx> {\n         // FIXME: (@jroesch) float this code up\n         tcx.infer_ctxt(None, Some(self.clone()), Reveal::ExactMatch).enter(|infcx| {\n             let adt = match self_type.sty {\n-                ty::TyStruct(struct_def, substs) => {\n+                ty::TyStruct(struct_def, substs) | ty::TyUnion(struct_def, substs) => {\n                     for field in struct_def.all_fields() {\n                         let field_ty = field.ty(tcx, substs);\n                         if infcx.type_moves_by_default(field_ty, span) {\n@@ -183,7 +183,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n \n     pub fn has_error_field(self, ty: Ty<'tcx>) -> bool {\n         match ty.sty {\n-            ty::TyStruct(def, substs) | ty::TyEnum(def, substs) => {\n+            ty::TyStruct(def, substs) | ty::TyUnion(def, substs) | ty::TyEnum(def, substs) => {\n                 for field in def.all_fields() {\n                     let field_ty = field.ty(self, substs);\n                     if let TyError = field_ty.sty {\n@@ -203,7 +203,8 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                                  i: usize,\n                                  variant: Option<DefId>) -> Option<Ty<'tcx>> {\n         match (&ty.sty, variant) {\n-            (&TyStruct(def, substs), None) => {\n+            (&TyStruct(def, substs), None) |\n+            (&TyUnion(def, substs), None) => {\n                 def.struct_variant().fields.get(i).map(|f| f.ty(self, substs))\n             }\n             (&TyEnum(def, substs), Some(vid)) => {\n@@ -225,7 +226,8 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                             n: Name,\n                             variant: Option<DefId>) -> Option<Ty<'tcx>> {\n         match (&ty.sty, variant) {\n-            (&TyStruct(def, substs), None) => {\n+            (&TyStruct(def, substs), None) |\n+            (&TyUnion(def, substs), None)  => {\n                 def.struct_variant().find_field_named(n).map(|f| f.ty(self, substs))\n             }\n             (&TyEnum(def, substs), Some(vid)) => {\n@@ -430,6 +432,7 @@ impl<'a, 'gcx, 'tcx> TypeVisitor<'tcx> for TypeIdHasher<'a, 'gcx, 'tcx> {\n             TyUint(u) => self.hash(u),\n             TyFloat(f) => self.hash(f),\n             TyStruct(d, _) |\n+            TyUnion(d, _) |\n             TyEnum(d, _) => self.def_id(d.did),\n             TyArray(_, n) => self.hash(n),\n             TyRawPtr(m) |\n@@ -558,7 +561,7 @@ impl<'a, 'tcx> ty::TyS<'tcx> {\n             }) => Some(true),\n \n             TyArray(..) | TySlice(_) | TyTrait(..) | TyTuple(..) |\n-            TyClosure(..) | TyEnum(..) | TyStruct(..) | TyAnon(..) |\n+            TyClosure(..) | TyEnum(..) | TyStruct(..) | TyUnion(..) | TyAnon(..) |\n             TyProjection(..) | TyParam(..) | TyInfer(..) | TyError => None\n         }.unwrap_or_else(|| !self.impls_bound(tcx, param_env, ty::BoundCopy, span));\n \n@@ -598,7 +601,7 @@ impl<'a, 'tcx> ty::TyS<'tcx> {\n \n             TyStr | TyTrait(..) | TySlice(_) => Some(false),\n \n-            TyEnum(..) | TyStruct(..) | TyProjection(..) | TyParam(..) |\n+            TyEnum(..) | TyStruct(..) | TyUnion(..) | TyProjection(..) | TyParam(..) |\n             TyInfer(..) | TyAnon(..) | TyError => None\n         }.unwrap_or_else(|| self.impls_bound(tcx, param_env, ty::BoundSized, span));\n \n@@ -660,7 +663,7 @@ impl<'a, 'tcx> ty::TyS<'tcx> {\n                 TyArray(ty, _) => {\n                     is_type_structurally_recursive(tcx, sp, seen, ty)\n                 }\n-                TyStruct(def, substs) | TyEnum(def, substs) => {\n+                TyStruct(def, substs) | TyUnion(def, substs) | TyEnum(def, substs) => {\n                     find_nonrepresentable(tcx,\n                                           sp,\n                                           seen,\n@@ -677,7 +680,7 @@ impl<'a, 'tcx> ty::TyS<'tcx> {\n \n         fn same_struct_or_enum<'tcx>(ty: Ty<'tcx>, def: ty::AdtDef<'tcx>) -> bool {\n             match ty.sty {\n-                TyStruct(ty_def, _) | TyEnum(ty_def, _) => {\n+                TyStruct(ty_def, _) | TyUnion(ty_def, _) | TyEnum(ty_def, _) => {\n                      ty_def == def\n                 }\n                 _ => false\n@@ -687,6 +690,7 @@ impl<'a, 'tcx> ty::TyS<'tcx> {\n         fn same_type<'tcx>(a: Ty<'tcx>, b: Ty<'tcx>) -> bool {\n             match (&a.sty, &b.sty) {\n                 (&TyStruct(did_a, ref substs_a), &TyStruct(did_b, ref substs_b)) |\n+                (&TyUnion(did_a, ref substs_a), &TyUnion(did_b, ref substs_b)) |\n                 (&TyEnum(did_a, ref substs_a), &TyEnum(did_b, ref substs_b)) => {\n                     if did_a != did_b {\n                         return false;\n@@ -709,7 +713,7 @@ impl<'a, 'tcx> ty::TyS<'tcx> {\n             debug!(\"is_type_structurally_recursive: {:?}\", ty);\n \n             match ty.sty {\n-                TyStruct(def, _) | TyEnum(def, _) => {\n+                TyStruct(def, _) | TyUnion(def, _) | TyEnum(def, _) => {\n                     {\n                         // Iterate through stack of previously seen types.\n                         let mut iter = seen.iter();"}, {"sha": "cea3bd6348dbe9bb5927839076dc0232ad79eb32", "filename": "src/librustc/ty/walk.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustc%2Fty%2Fwalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustc%2Fty%2Fwalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fwalk.rs?ref=d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2", "patch": "@@ -95,6 +95,7 @@ fn push_subtypes<'tcx>(stack: &mut Vec<Ty<'tcx>>, parent_ty: Ty<'tcx>) {\n         }\n         ty::TyEnum(_, ref substs) |\n         ty::TyStruct(_, ref substs) |\n+        ty::TyUnion(_, ref substs) |\n         ty::TyAnon(_, ref substs) => {\n             stack.extend(substs.types().rev());\n         }"}, {"sha": "599e2be4db247f0e4e133375749eafdfc2b79cf0", "filename": "src/librustc/ty/wf.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustc%2Fty%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustc%2Fty%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fwf.rs?ref=d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2", "patch": "@@ -337,7 +337,8 @@ impl<'a, 'gcx, 'tcx> WfPredicates<'a, 'gcx, 'tcx> {\n                 }\n \n                 ty::TyEnum(def, substs) |\n-                ty::TyStruct(def, substs) => {\n+                ty::TyStruct(def, substs) |\n+                ty::TyUnion(def, substs) => {\n                     // WfNominalType\n                     let obligations = self.nominal_obligations(def.did, substs);\n                     self.out.extend(obligations);"}, {"sha": "d0e02f2e8acdd05cdf95baf5695609b4bc72e3fc", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2", "patch": "@@ -8,11 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n use hir::def_id::DefId;\n use ty::subst::{self, Subst, Substs};\n use ty::{BrAnon, BrEnv, BrFresh, BrNamed};\n-use ty::{TyBool, TyChar, TyStruct, TyEnum};\n+use ty::{TyBool, TyChar, TyStruct, TyUnion, TyEnum};\n use ty::{TyError, TyStr, TyArray, TySlice, TyFloat, TyFnDef, TyFnPtr};\n use ty::{TyParam, TyRawPtr, TyRef, TyNever, TyTuple};\n use ty::TyClosure;\n@@ -869,7 +868,7 @@ impl<'tcx> fmt::Display for ty::TypeVariants<'tcx> {\n             TyInfer(infer_ty) => write!(f, \"{}\", infer_ty),\n             TyError => write!(f, \"[type error]\"),\n             TyParam(ref param_ty) => write!(f, \"{}\", param_ty),\n-            TyEnum(def, substs) | TyStruct(def, substs) => {\n+            TyEnum(def, substs) | TyStruct(def, substs) | TyUnion(def, substs) => {\n                 ty::tls::with(|tcx| {\n                     if def.did.is_local() &&\n                           !tcx.tcache.borrow().contains_key(&def.did) {"}, {"sha": "b4c6689c24b9e50e05204d05195e4c35bea4c9a0", "filename": "src/librustc_borrowck/borrowck/check_loans.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs?ref=d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2", "patch": "@@ -796,7 +796,9 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n             }\n             LpExtend(ref lp_base, _, LpInterior(_, InteriorField(_))) => {\n                 match lp_base.to_type().sty {\n-                    ty::TyStruct(def, _) | ty::TyEnum(def, _) if def.has_dtor() => {\n+                    ty::TyStruct(def, _) |\n+                    ty::TyUnion(def, _) |\n+                    ty::TyEnum(def, _) if def.has_dtor() => {\n                         // In the case where the owner implements drop, then\n                         // the path must be initialized to prevent a case of\n                         // partial reinitialization"}, {"sha": "86f396d8982b00f2ec81003b81801fa579d8dc19", "filename": "src/librustc_borrowck/borrowck/fragments.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustc_borrowck%2Fborrowck%2Ffragments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustc_borrowck%2Fborrowck%2Ffragments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Ffragments.rs?ref=d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2", "patch": "@@ -461,6 +461,10 @@ fn add_fragment_siblings_for_extension<'a, 'tcx>(this: &MoveData<'tcx>,\n             }\n         }\n \n+        (&ty::TyUnion(..), None) => {\n+            // Do nothing, all union fields are moved/assigned together.\n+        }\n+\n         (&ty::TyEnum(def, _), ref enum_variant_info) => {\n             let variant = match *enum_variant_info {\n                 Some((vid, ref _lp2)) => def.variant_with_id(vid),"}, {"sha": "3cf02fc85a46348a8d273d61ffb3b742486d985e", "filename": "src/librustc_borrowck/borrowck/gather_loans/gather_moves.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs?ref=d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2", "patch": "@@ -178,7 +178,7 @@ fn check_and_get_illegal_move_origin<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n         Categorization::Interior(ref b, mc::InteriorField(_)) |\n         Categorization::Interior(ref b, mc::InteriorElement(Kind::Pattern, _)) => {\n             match b.ty.sty {\n-                ty::TyStruct(def, _) | ty::TyEnum(def, _) => {\n+                ty::TyStruct(def, _) | ty::TyUnion(def, _) | ty::TyEnum(def, _) => {\n                     if def.has_dtor() {\n                         Some(cmt.clone())\n                     } else {"}, {"sha": "61c85e393d2dd1ac6f9d532f79ccbea04799896d", "filename": "src/librustc_borrowck/borrowck/gather_loans/move_error.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs?ref=d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2", "patch": "@@ -149,6 +149,7 @@ fn report_cannot_move_out_of<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n         Categorization::Interior(ref b, mc::InteriorField(_)) => {\n             match b.ty.sty {\n                 ty::TyStruct(def, _) |\n+                ty::TyUnion(def, _) |\n                 ty::TyEnum(def, _) if def.has_dtor() => {\n                     let mut err = struct_span_err!(bccx, move_from.span, E0509,\n                                                    \"cannot move out of type `{}`, \\"}, {"sha": "c08dc9330b8fd0a877ab5634694483c0bba13698", "filename": "src/librustc_borrowck/borrowck/gather_loans/restrictions.rs", "status": "modified", "additions": 29, "deletions": 2, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Frestrictions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Frestrictions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Frestrictions.rs?ref=d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2", "patch": "@@ -89,7 +89,7 @@ impl<'a, 'tcx> RestrictionsContext<'a, 'tcx> {\n                 self.restrict(cmt_base)\n             }\n \n-            Categorization::Interior(cmt_base, i) => {\n+            Categorization::Interior(cmt_base, interior) => {\n                 // R-Field\n                 //\n                 // Overwriting the base would not change the type of\n@@ -99,8 +99,35 @@ impl<'a, 'tcx> RestrictionsContext<'a, 'tcx> {\n                     Categorization::Downcast(_, variant_id) => Some(variant_id),\n                     _ => None\n                 };\n+                let interior = interior.cleaned();\n+                let base_ty = cmt_base.ty;\n                 let result = self.restrict(cmt_base);\n-                self.extend(result, &cmt, LpInterior(opt_variant_id, i.cleaned()))\n+                // Borrowing one union field automatically borrows all its fields.\n+                if let ty::TyUnion(ref adt_def, _) = base_ty.sty {\n+                    match result {\n+                        RestrictionResult::Safe => RestrictionResult::Safe,\n+                        RestrictionResult::SafeIf(base_lp, mut base_vec) => {\n+                            for field in &adt_def.struct_variant().fields {\n+                                let field = InteriorKind::InteriorField(mc::NamedField(field.name));\n+                                let field_ty = if field == interior {\n+                                    cmt.ty\n+                                } else {\n+                                    self.bccx.tcx.types.err // Doesn't matter\n+                                };\n+                                let sibling_lp_kind = LpExtend(base_lp.clone(), cmt.mutbl,\n+                                                               LpInterior(opt_variant_id, field));\n+                                let sibling_lp = Rc::new(LoanPath::new(sibling_lp_kind, field_ty));\n+                                base_vec.push(sibling_lp);\n+                            }\n+\n+                            let lp = new_lp(LpExtend(base_lp, cmt.mutbl,\n+                                                     LpInterior(opt_variant_id, interior)));\n+                            RestrictionResult::SafeIf(lp, base_vec)\n+                        }\n+                    }\n+                } else {\n+                    self.extend(result, &cmt, LpInterior(opt_variant_id, interior))\n+                }\n             }\n \n             Categorization::StaticItem => {"}, {"sha": "c5d103453798927c044f4594b10a731714b6b005", "filename": "src/librustc_borrowck/borrowck/mir/elaborate_drops.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Felaborate_drops.rs?ref=d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2", "patch": "@@ -709,7 +709,7 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n     fn open_drop<'a>(&mut self, c: &DropCtxt<'a, 'tcx>) -> BasicBlock {\n         let ty = c.lvalue.ty(self.mir, self.tcx).to_ty(self.tcx);\n         match ty.sty {\n-            ty::TyStruct(def, substs) | ty::TyEnum(def, substs) => {\n+            ty::TyStruct(def, substs) | ty::TyUnion(def, substs) | ty::TyEnum(def, substs) => {\n                 self.open_drop_for_adt(c, def, substs)\n             }\n             ty::TyTuple(tys) | ty::TyClosure(_, ty::ClosureSubsts {\n@@ -893,7 +893,7 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n         let ty = c.lvalue.ty(self.mir, self.tcx).to_ty(self.tcx);\n \n         match ty.sty {\n-            ty::TyStruct(def, _) | ty::TyEnum(def, _) => {\n+            ty::TyStruct(def, _) | ty::TyUnion(def, _) | ty::TyEnum(def, _) => {\n                 if def.has_dtor() {\n                     self.tcx.sess.span_warn(\n                         c.source_info.span,"}, {"sha": "be408e2db5c340229514162acf85e00be4482c3a", "filename": "src/librustc_borrowck/borrowck/mir/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fmod.rs?ref=d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2", "patch": "@@ -261,7 +261,7 @@ fn lvalue_contents_drop_state_cannot_differ<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx\n                    lv, ty);\n             true\n         }\n-        ty::TyStruct(def, _) | ty::TyEnum(def, _) if def.has_dtor() => {\n+        ty::TyStruct(def, _) | ty::TyUnion(def, _) | ty::TyEnum(def, _) if def.has_dtor() => {\n             debug!(\"lvalue_contents_drop_state_cannot_differ lv: {:?} ty: {:?} Drop => false\",\n                    lv, ty);\n             true"}, {"sha": "f5e20285e0c1be9f64a4975b66414697816eeae1", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2", "patch": "@@ -477,8 +477,6 @@ impl<'a, 'tcx> LoanPath<'tcx> {\n                     base.common(&base2).map(|x| {\n                         let xd = x.depth();\n                         if base.depth() == xd && base2.depth() == xd {\n-                            assert_eq!(base.ty, base2.ty);\n-                            assert_eq!(self.ty, other.ty);\n                             LoanPath {\n                                 kind: LpExtend(Rc::new(x), a, LpInterior(opt_variant_id, id)),\n                                 ty: self.ty,\n@@ -495,15 +493,13 @@ impl<'a, 'tcx> LoanPath<'tcx> {\n             (_, &LpExtend(ref other, _, LpDeref(_))) => self.common(&other),\n             (&LpVar(id), &LpVar(id2)) => {\n                 if id == id2 {\n-                    assert_eq!(self.ty, other.ty);\n                     Some(LoanPath { kind: LpVar(id), ty: self.ty })\n                 } else {\n                     None\n                 }\n             }\n             (&LpUpvar(id), &LpUpvar(id2)) => {\n                 if id == id2 {\n-                    assert_eq!(self.ty, other.ty);\n                     Some(LoanPath { kind: LpUpvar(id), ty: self.ty })\n                 } else {\n                     None\n@@ -1136,7 +1132,6 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                 out.push(')');\n             }\n \n-\n             LpExtend(ref lp_base, _, LpInterior(_, InteriorField(fname))) => {\n                 self.append_autoderefd_loan_path_to_string(&lp_base, out);\n                 match fname {"}, {"sha": "236a1a2835c2ae89c258a38783f3601701f35f23", "filename": "src/librustc_borrowck/borrowck/move_data.rs", "status": "modified", "additions": 56, "deletions": 1, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs?ref=d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2", "patch": "@@ -21,7 +21,8 @@ use rustc::middle::dataflow::DataFlowOperator;\n use rustc::middle::dataflow::KillFrom;\n use rustc::middle::expr_use_visitor as euv;\n use rustc::middle::expr_use_visitor::MutateMode;\n-use rustc::ty::TyCtxt;\n+use rustc::middle::mem_categorization as mc;\n+use rustc::ty::{self, TyCtxt};\n use rustc::util::nodemap::{FnvHashMap, NodeSet};\n \n use std::cell::RefCell;\n@@ -364,6 +365,32 @@ impl<'a, 'tcx> MoveData<'tcx> {\n                     lp: Rc<LoanPath<'tcx>>,\n                     id: ast::NodeId,\n                     kind: MoveKind) {\n+        // Moving one union field automatically moves all its fields.\n+        if let LpExtend(ref base_lp, mutbl, LpInterior(opt_variant_id, interior)) = lp.kind {\n+            if let ty::TyUnion(ref adt_def, _) = base_lp.ty.sty {\n+                for field in &adt_def.struct_variant().fields {\n+                    let field = InteriorKind::InteriorField(mc::NamedField(field.name));\n+                    let field_ty = if field == interior {\n+                        lp.ty\n+                    } else {\n+                        tcx.types.err // Doesn't matter\n+                    };\n+                    let sibling_lp_kind = LpExtend(base_lp.clone(), mutbl,\n+                                                   LpInterior(opt_variant_id, field));\n+                    let sibling_lp = Rc::new(LoanPath::new(sibling_lp_kind, field_ty));\n+                    self.add_move_helper(tcx, sibling_lp, id, kind);\n+                }\n+                return;\n+            }\n+        }\n+\n+        self.add_move_helper(tcx, lp.clone(), id, kind);\n+    }\n+\n+    fn add_move_helper(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                       lp: Rc<LoanPath<'tcx>>,\n+                       id: ast::NodeId,\n+                       kind: MoveKind) {\n         debug!(\"add_move(lp={:?}, id={}, kind={:?})\",\n                lp,\n                id,\n@@ -393,6 +420,34 @@ impl<'a, 'tcx> MoveData<'tcx> {\n                           span: Span,\n                           assignee_id: ast::NodeId,\n                           mode: euv::MutateMode) {\n+        // Assigning to one union field automatically assigns to all its fields.\n+        if let LpExtend(ref base_lp, mutbl, LpInterior(opt_variant_id, interior)) = lp.kind {\n+            if let ty::TyUnion(ref adt_def, _) = base_lp.ty.sty {\n+                for field in &adt_def.struct_variant().fields {\n+                    let field = InteriorKind::InteriorField(mc::NamedField(field.name));\n+                    let field_ty = if field == interior {\n+                        lp.ty\n+                    } else {\n+                        tcx.types.err // Doesn't matter\n+                    };\n+                    let sibling_lp_kind = LpExtend(base_lp.clone(), mutbl,\n+                                                   LpInterior(opt_variant_id, field));\n+                    let sibling_lp = Rc::new(LoanPath::new(sibling_lp_kind, field_ty));\n+                    self.add_assignment_helper(tcx, sibling_lp, assign_id, span, assignee_id, mode);\n+                }\n+                return;\n+            }\n+        }\n+\n+        self.add_assignment_helper(tcx, lp.clone(), assign_id, span, assignee_id, mode);\n+    }\n+\n+    fn add_assignment_helper(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                             lp: Rc<LoanPath<'tcx>>,\n+                             assign_id: ast::NodeId,\n+                             span: Span,\n+                             assignee_id: ast::NodeId,\n+                             mode: euv::MutateMode) {\n         debug!(\"add_assignment(lp={:?}, assign_id={}, assignee_id={}\",\n                lp, assign_id, assignee_id);\n "}, {"sha": "de28cbb7c9c966d135a9e463bd4f69332e5fd67f", "filename": "src/librustc_const_eval/check_match.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustc_const_eval%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustc_const_eval%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fcheck_match.rs?ref=d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2", "patch": "@@ -566,7 +566,7 @@ fn construct_witness<'a,'tcx>(cx: &MatchCheckCtxt<'a,'tcx>, ctor: &Constructor,\n     let pat = match left_ty.sty {\n         ty::TyTuple(..) => PatKind::Tuple(pats.collect(), None),\n \n-        ty::TyEnum(adt, _) | ty::TyStruct(adt, _)  => {\n+        ty::TyEnum(adt, _) | ty::TyStruct(adt, _) | ty::TyUnion(adt, _) => {\n             let v = ctor.variant_for_adt(adt);\n             match v.kind {\n                 VariantKind::Struct => {\n@@ -792,7 +792,8 @@ fn pat_constructors(cx: &MatchCheckCtxt, p: &Pat,\n         PatKind::Struct(..) | PatKind::TupleStruct(..) | PatKind::Path(..) =>\n             match cx.tcx.expect_def(pat.id) {\n                 Def::Variant(_, id) => vec![Variant(id)],\n-                Def::Struct(..) | Def::TyAlias(..) | Def::AssociatedTy(..) => vec![Single],\n+                Def::Struct(..) | Def::Union(..) |\n+                Def::TyAlias(..) | Def::AssociatedTy(..) => vec![Single],\n                 Def::Const(..) | Def::AssociatedConst(..) =>\n                     span_bug!(pat.span, \"const pattern should've been rewritten\"),\n                 def => span_bug!(pat.span, \"pat_constructors: unexpected definition {:?}\", def),\n@@ -836,7 +837,7 @@ pub fn constructor_arity(_cx: &MatchCheckCtxt, ctor: &Constructor, ty: Ty) -> us\n             _ => bug!()\n         },\n         ty::TyRef(..) => 1,\n-        ty::TyEnum(adt, _) | ty::TyStruct(adt, _) => {\n+        ty::TyEnum(adt, _) | ty::TyStruct(adt, _) | ty::TyUnion(adt, _) => {\n             ctor.variant_for_adt(adt).fields.len()\n         }\n         ty::TyArray(_, n) => n,"}, {"sha": "114b5e1331de2392ab25fc5e592f527862af54aa", "filename": "src/librustc_const_eval/eval.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustc_const_eval%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustc_const_eval%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Feval.rs?ref=d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2", "patch": "@@ -271,6 +271,10 @@ pub fn const_expr_to_pat<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                             tcx.item_path_str(adt_def.did)));\n             }\n         }\n+        ty::TyUnion(..) => {\n+            // Matching on union fields is unsafe, we can't hide it in constants\n+            tcx.sess.span_err(span, \"cannot use unions in constant patterns\");\n+        }\n         _ => { }\n     }\n     let pat = match expr.node {"}, {"sha": "9f5f82c144ccdcff62f08b7c25b636a73621b0cf", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2", "patch": "@@ -220,6 +220,7 @@ impl<'a, 'gcx, 'tcx> Env<'a, 'gcx, 'tcx> {\n \n                 hir::ItemEnum(..) |\n                 hir::ItemStruct(..) |\n+                hir::ItemUnion(..) |\n                 hir::ItemTrait(..) |\n                 hir::ItemImpl(..) |\n                 hir::ItemDefaultImpl(..) => {"}, {"sha": "d4a3ab59f9cb3cc14f481210a0af64a46d05928e", "filename": "src/librustc_incremental/calculate_svh/svh_visitor.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustc_incremental%2Fcalculate_svh%2Fsvh_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustc_incremental%2Fcalculate_svh%2Fsvh_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fcalculate_svh%2Fsvh_visitor.rs?ref=d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2", "patch": "@@ -419,6 +419,7 @@ impl<'a, 'hash, 'tcx> StrictVersionHashVisitor<'a, 'hash, 'tcx> {\n             Def::AssociatedTy(..) |\n             Def::TyParam(..) |\n             Def::Struct(..) |\n+            Def::Union(..) |\n             Def::Trait(..) |\n             Def::Method(..) |\n             Def::Const(..) |"}, {"sha": "1094d0ee12bbd9e6c67e0412471f4243aba08a07", "filename": "src/librustc_lint/bad_style.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustc_lint%2Fbad_style.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustc_lint%2Fbad_style.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbad_style.rs?ref=d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2", "patch": "@@ -111,7 +111,7 @@ impl LateLintPass for NonCamelCaseTypes {\n         }\n \n         match it.node {\n-            hir::ItemTy(..) | hir::ItemStruct(..) => {\n+            hir::ItemTy(..) | hir::ItemStruct(..) | hir::ItemUnion(..) => {\n                 self.check_case(cx, \"type\", it.name, it.span)\n             }\n             hir::ItemTrait(..) => {"}, {"sha": "1702c1c0edc9a73e22893838307c3b322bece5b5", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 46, "deletions": 3, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2", "patch": "@@ -116,15 +116,17 @@ impl LateLintPass for BoxPointers {\n             hir::ItemFn(..) |\n             hir::ItemTy(..) |\n             hir::ItemEnum(..) |\n-            hir::ItemStruct(..) =>\n+            hir::ItemStruct(..) |\n+            hir::ItemUnion(..) =>\n                 self.check_heap_type(cx, it.span,\n                                      cx.tcx.node_id_to_type(it.id)),\n             _ => ()\n         }\n \n         // If it's a struct, we also have to check the fields' types\n         match it.node {\n-            hir::ItemStruct(ref struct_def, _) => {\n+            hir::ItemStruct(ref struct_def, _) |\n+            hir::ItemUnion(ref struct_def, _) => {\n                 for struct_field in struct_def.fields() {\n                     self.check_heap_type(cx, struct_field.span,\n                                          cx.tcx.node_id_to_type(struct_field.id));\n@@ -348,6 +350,7 @@ impl LateLintPass for MissingDoc {\n             hir::ItemMod(..) => \"a module\",\n             hir::ItemEnum(..) => \"an enum\",\n             hir::ItemStruct(..) => \"a struct\",\n+            hir::ItemUnion(..) => \"a union\",\n             hir::ItemTrait(_, _, _, ref items) => {\n                 // Issue #11592, traits are always considered exported, even when private.\n                 if it.vis == hir::Visibility::Inherited {\n@@ -467,6 +470,13 @@ impl LateLintPass for MissingCopyImplementations {\n                 let def = cx.tcx.lookup_adt_def(cx.tcx.map.local_def_id(item.id));\n                 (def, cx.tcx.mk_struct(def, Substs::empty(cx.tcx)))\n             }\n+            hir::ItemUnion(_, ref ast_generics) => {\n+                if ast_generics.is_parameterized() {\n+                    return;\n+                }\n+                let def = cx.tcx.lookup_adt_def(cx.tcx.map.local_def_id(item.id));\n+                (def, cx.tcx.mk_union(def, Substs::empty(cx.tcx)))\n+            }\n             hir::ItemEnum(_, ref ast_generics) => {\n                 if ast_generics.is_parameterized() {\n                     return;\n@@ -523,7 +533,7 @@ impl LateLintPass for MissingDebugImplementations {\n         }\n \n         match item.node {\n-            hir::ItemStruct(..) | hir::ItemEnum(..) => {},\n+            hir::ItemStruct(..) | hir::ItemUnion(..) | hir::ItemEnum(..) => {},\n             _ => return,\n         }\n \n@@ -1154,3 +1164,36 @@ impl LateLintPass for UnstableFeatures {\n         }\n     }\n }\n+\n+/// Lint for unions that contain fields with possibly non-trivial destructors.\n+pub struct UnionsWithDropFields;\n+\n+declare_lint! {\n+    UNIONS_WITH_DROP_FIELDS,\n+    Warn,\n+    \"use of unions that contain fields with possibly non-trivial drop code\"\n+}\n+\n+impl LintPass for UnionsWithDropFields {\n+    fn get_lints(&self) -> LintArray {\n+        lint_array!(UNIONS_WITH_DROP_FIELDS)\n+    }\n+}\n+\n+impl LateLintPass for UnionsWithDropFields {\n+    fn check_item(&mut self, ctx: &LateContext, item: &hir::Item) {\n+        if let hir::ItemUnion(ref vdata, _) = item.node {\n+            let param_env = &ty::ParameterEnvironment::for_item(ctx.tcx, item.id);\n+            for field in vdata.fields() {\n+                let field_ty = ctx.tcx.node_id_to_type(field.id);\n+                if ctx.tcx.type_needs_drop_given_env(field_ty, param_env) {\n+                    ctx.span_lint(UNIONS_WITH_DROP_FIELDS,\n+                                  field.span,\n+                                  \"union contains a field with possibly non-trivial drop code, \\\n+                                   drop code of union fields is ignored when dropping the union\");\n+                    return;\n+                }\n+            }\n+        }\n+    }\n+}"}, {"sha": "c3b752d605f97cbd4fbe38c3044e1e9a868380ca", "filename": "src/librustc_lint/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustc_lint%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustc_lint%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Flib.rs?ref=d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2", "patch": "@@ -128,6 +128,7 @@ pub fn register_builtins(store: &mut lint::LintStore, sess: Option<&Session>) {\n                  InvalidNoMangleItems,\n                  PluginAsLibrary,\n                  MutableTransmutes,\n+                 UnionsWithDropFields,\n                  );\n \n     add_builtin_with_new!(sess,"}, {"sha": "54cec3fd7e135b04a4775d92d4eeb0294a99ef03", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 31, "deletions": 3, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2", "patch": "@@ -377,7 +377,8 @@ enum FfiResult {\n     FfiSafe,\n     FfiUnsafe(&'static str),\n     FfiBadStruct(DefId, &'static str),\n-    FfiBadEnum(DefId, &'static str)\n+    FfiBadUnion(DefId, &'static str),\n+    FfiBadEnum(DefId, &'static str),\n }\n \n /// Check if this enum can be safely exported based on the\n@@ -452,12 +453,32 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n                     let r = self.check_type_for_ffi(cache, field_ty);\n                     match r {\n                         FfiSafe => {}\n-                        FfiBadStruct(..) | FfiBadEnum(..) => { return r; }\n+                        FfiBadStruct(..) | FfiBadUnion(..) | FfiBadEnum(..) => { return r; }\n                         FfiUnsafe(s) => { return FfiBadStruct(def.did, s); }\n                     }\n                 }\n                 FfiSafe\n             }\n+            ty::TyUnion(def, substs) => {\n+                if !cx.lookup_repr_hints(def.did).contains(&attr::ReprExtern) {\n+                    return FfiUnsafe(\n+                        \"found union without foreign-function-safe \\\n+                         representation annotation in foreign module, \\\n+                         consider adding a #[repr(C)] attribute to \\\n+                         the type\");\n+                }\n+\n+                for field in &def.struct_variant().fields {\n+                    let field_ty = cx.normalize_associated_type(&field.ty(cx, substs));\n+                    let r = self.check_type_for_ffi(cache, field_ty);\n+                    match r {\n+                        FfiSafe => {}\n+                        FfiBadStruct(..) | FfiBadUnion(..) | FfiBadEnum(..) => { return r; }\n+                        FfiUnsafe(s) => { return FfiBadUnion(def.did, s); }\n+                    }\n+                }\n+                FfiSafe\n+            }\n             ty::TyEnum(def, substs) => {\n                 if def.variants.is_empty() {\n                     // Empty enums are okay... although sort of useless.\n@@ -507,7 +528,7 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n                         let r = self.check_type_for_ffi(cache, arg);\n                         match r {\n                             FfiSafe => {}\n-                            FfiBadStruct(..) | FfiBadEnum(..) => { return r; }\n+                            FfiBadStruct(..) | FfiBadUnion(..) | FfiBadEnum(..) => { return r; }\n                             FfiUnsafe(s) => { return FfiBadEnum(def.did, s); }\n                         }\n                     }\n@@ -614,6 +635,13 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n                     &format!(\"found non-foreign-function-safe member in \\\n                               struct marked #[repr(C)]: {}\", s));\n             }\n+            FfiResult::FfiBadUnion(_, s) => {\n+                // FIXME: This diagnostic is difficult to read, and doesn't\n+                // point at the relevant field.\n+                self.cx.span_lint(IMPROPER_CTYPES, sp,\n+                    &format!(\"found non-foreign-function-safe member in \\\n+                              union marked #[repr(C)]: {}\", s));\n+            }\n             FfiResult::FfiBadEnum(_, s) => {\n                 // FIXME: This diagnostic is difficult to read, and doesn't\n                 // point at the relevant variant."}, {"sha": "44f1cf7b533569a7fc2836149ff0eabe7217a599", "filename": "src/librustc_lint/unused.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustc_lint%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustc_lint%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Funused.rs?ref=d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2", "patch": "@@ -137,6 +137,7 @@ impl LateLintPass for UnusedResults {\n             ty::TyNever => return,\n             ty::TyBool => return,\n             ty::TyStruct(def, _) |\n+            ty::TyUnion(def, _) |\n             ty::TyEnum(def, _) => {\n                 let attrs = cx.tcx.get_attrs(def.did);\n                 check_must_use(cx, &attrs[..], s.span)"}, {"sha": "9d9c6f033a960b5bceca5e9a40196fdde8e33b11", "filename": "src/librustc_metadata/astencode.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustc_metadata%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustc_metadata%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fastencode.rs?ref=d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2", "patch": "@@ -416,6 +416,7 @@ impl tr for Def {\n               Def::Upvar(did1, nid1, index, nid2)\n           }\n           Def::Struct(did) => Def::Struct(did.tr(dcx)),\n+          Def::Union(did) => Def::Union(did.tr(dcx)),\n           Def::Label(nid) => Def::Label(dcx.tr_id(nid)),\n           Def::Err => Def::Err,\n         }"}, {"sha": "aeb95e5670d6a9e029f59d0136129bc1c6db7fa4", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2", "patch": "@@ -133,6 +133,7 @@ enum Family {\n     DefaultImpl,           // d\n     Trait,                 // I\n     Struct(VariantKind),   // S, s, u\n+    Union,                 // U\n     PublicField,           // g\n     InheritedField,        // N\n     Constant,              // C\n@@ -160,6 +161,7 @@ fn item_family(item: rbml::Doc) -> Family {\n       'S' => Struct(VariantKind::Struct),\n       's' => Struct(VariantKind::Tuple),\n       'u' => Struct(VariantKind::Unit),\n+      'U' => Union,\n       'g' => PublicField,\n       'N' => InheritedField,\n        c => bug!(\"unexpected family char: {}\", c)\n@@ -289,7 +291,7 @@ fn maybe_item_name(item: rbml::Doc) -> Option<ast::Name> {\n \n fn family_to_variant_kind<'tcx>(family: Family) -> Option<ty::VariantKind> {\n     match family {\n-        Struct(VariantKind::Struct) | Variant(VariantKind::Struct) =>\n+        Struct(VariantKind::Struct) | Variant(VariantKind::Struct) | Union =>\n             Some(ty::VariantKind::Struct),\n         Struct(VariantKind::Tuple) | Variant(VariantKind::Tuple) =>\n             Some(ty::VariantKind::Tuple),\n@@ -317,6 +319,7 @@ fn item_to_def_like(cdata: Cmd, item: rbml::Doc, did: DefId) -> DefLike {\n         ImmStatic => DlDef(Def::Static(did, false)),\n         MutStatic => DlDef(Def::Static(did, true)),\n         Struct(..) => DlDef(Def::Struct(did)),\n+        Union => DlDef(Def::Union(did)),\n         Fn        => DlDef(Def::Fn(did)),\n         Method | StaticMethod => {\n             DlDef(Def::Method(did))\n@@ -461,6 +464,10 @@ pub fn get_adt_def<'a, 'tcx>(cdata: Cmd,\n             (ty::AdtKind::Struct,\n              vec![get_struct_variant(cdata, doc, ctor_did.unwrap_or(did))])\n         }\n+        Union => {\n+            (ty::AdtKind::Union,\n+             vec![get_struct_variant(cdata, doc, did)])\n+        }\n         _ => bug!(\"get_adt_def called on a non-ADT {:?} - {:?}\",\n                   item_family(doc), did)\n     };"}, {"sha": "35f5eba4160d93e95aed09a5b5ee379000af9b4e", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2", "patch": "@@ -1029,6 +1029,33 @@ impl<'a, 'tcx, 'encoder> ItemContentBuilder<'a, 'tcx, 'encoder> {\n                                               def_to_u64(ctor_did));\n                 }\n             }\n+            hir::ItemUnion(..) => {\n+                let def = ecx.tcx.lookup_adt_def(def_id);\n+                let variant = def.struct_variant();\n+\n+                encode_def_id_and_key(ecx, self.rbml_w, def_id);\n+                encode_family(self.rbml_w, 'U');\n+                self.encode_bounds_and_type_for_item(item.id);\n+\n+                encode_item_variances(self.rbml_w, ecx, item.id);\n+                encode_name(self.rbml_w, item.name);\n+                encode_attributes(self.rbml_w, &item.attrs);\n+                encode_stability(self.rbml_w, stab);\n+                encode_deprecation(self.rbml_w, depr);\n+                self.encode_visibility(vis);\n+                self.encode_repr_attrs(&item.attrs);\n+\n+                /* Encode def_ids for each field and method\n+                for methods, write all the stuff get_trait_method\n+                needs to know*/\n+                self.encode_struct_fields(variant);\n+\n+                encode_inlined_item(ecx, self.rbml_w, InlinedItemRef::Item(def_id, item));\n+                self.encode_mir(item.id);\n+\n+                // Encode inherent implementations for self union.\n+                encode_inherent_implementations(ecx, self.rbml_w, def_id);\n+            }\n             hir::ItemDefaultImpl(unsafety, _) => {\n                 encode_def_id_and_key(ecx, self.rbml_w, def_id);\n                 encode_family(self.rbml_w, 'd');\n@@ -1179,6 +1206,9 @@ impl<'a, 'tcx, 'encoder> IndexBuilder<'a, 'tcx, 'encoder> {\n             hir::ItemStruct(ref struct_def, _) => {\n                 self.encode_addl_struct_info(def_id, struct_def.id(), item);\n             }\n+            hir::ItemUnion(..) => {\n+                self.encode_addl_union_info(def_id);\n+            }\n             hir::ItemImpl(_, _, _, _, _, ref ast_items) => {\n                 self.encode_addl_impl_info(def_id, item.id, ast_items);\n             }\n@@ -1214,6 +1244,10 @@ impl<'a, 'tcx, 'encoder> IndexBuilder<'a, 'tcx, 'encoder> {\n         }\n     }\n \n+    fn encode_addl_union_info(&mut self, def_id: DefId) {\n+        self.encode_fields(def_id);\n+    }\n+\n     fn encode_addl_impl_info(&mut self,\n                              def_id: DefId,\n                              impl_id: ast::NodeId,"}, {"sha": "55ff4817683de523072f78987c21f87e44628649", "filename": "src/librustc_metadata/tydecode.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustc_metadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustc_metadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Ftydecode.rs?ref=d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2", "patch": "@@ -472,6 +472,14 @@ impl<'a,'tcx> TyDecoder<'a,'tcx> {\n                 let def = self.tcx.lookup_adt_def(did);\n                 return self.tcx.mk_struct(def, substs);\n             }\n+            'U' => {\n+                assert_eq!(self.next(), '[');\n+                let did = self.parse_def();\n+                let substs = self.parse_substs();\n+                assert_eq!(self.next(), ']');\n+                let def = self.tcx.lookup_adt_def(did);\n+                return self.tcx.mk_union(def, substs);\n+            }\n             'k' => {\n                 assert_eq!(self.next(), '[');\n                 let did = self.parse_def();"}, {"sha": "bef3cf3a1940f965ec472504327f0c5ab1c5eee9", "filename": "src/librustc_metadata/tyencode.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustc_metadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustc_metadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Ftyencode.rs?ref=d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2", "patch": "@@ -170,6 +170,11 @@ pub fn enc_ty<'a, 'tcx>(w: &mut Cursor<Vec<u8>>, cx: &ctxt<'a, 'tcx>, t: Ty<'tcx\n             enc_substs(w, cx, substs);\n             write!(w, \"]\");\n         }\n+        ty::TyUnion(def, substs) => {\n+            write!(w, \"U[{}|\", (cx.ds)(cx.tcx, def.did));\n+            enc_substs(w, cx, substs);\n+            write!(w, \"]\");\n+        }\n         ty::TyClosure(def, substs) => {\n             write!(w, \"k[{}|\", (cx.ds)(cx.tcx, def));\n             enc_substs(w, cx, substs.func_substs);"}, {"sha": "6ea1fb5036065285b4faf0cf25d5fff4c8a12372", "filename": "src/librustc_mir/build/expr/as_rvalue.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2", "patch": "@@ -181,6 +181,9 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             ExprKind::Adt {\n                 adt_def, variant_index, substs, fields, base\n             } => { // see (*) above\n+                let is_union = adt_def.adt_kind() == ty::AdtKind::Union;\n+                let active_field_index = if is_union { Some(fields[0].name.index()) } else { None };\n+\n                 // first process the set of fields that were provided\n                 // (evaluating them in order given by user)\n                 let fields_map: FnvHashMap<_, _> =\n@@ -204,11 +207,11 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                         })\n                         .collect()\n                 } else {\n-                    field_names.iter().map(|n| fields_map[n].clone()).collect()\n+                    field_names.iter().filter_map(|n| fields_map.get(n).cloned()).collect()\n                 };\n \n-                block.and(Rvalue::Aggregate(AggregateKind::Adt(adt_def, variant_index, substs),\n-                                            fields))\n+                let adt = AggregateKind::Adt(adt_def, variant_index, substs, active_field_index);\n+                block.and(Rvalue::Aggregate(adt, fields))\n             }\n             ExprKind::Assign { .. } |\n             ExprKind::AssignOp { .. } => {"}, {"sha": "c8f660a2d9c7c7dbe7aeff37feeff8ff3871ba20", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2", "patch": "@@ -459,7 +459,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n \n         hir::ExprStruct(_, ref fields, ref base) => {\n             match expr_ty.sty {\n-                ty::TyStruct(adt, substs) => {\n+                ty::TyStruct(adt, substs) | ty::TyUnion(adt, substs) => {\n                     let field_refs = field_refs(&adt.variants[0], fields);\n                     ExprKind::Adt {\n                         adt_def: adt,\n@@ -579,7 +579,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                              body: block::to_expr_ref(cx, body) },\n         hir::ExprField(ref source, name) => {\n             let index = match cx.tcx.expr_ty_adjusted(source).sty {\n-                ty::TyStruct(adt_def, _) =>\n+                ty::TyStruct(adt_def, _) | ty::TyUnion(adt_def, _) =>\n                     adt_def.variants[0].index_of_field_named(name.node),\n                 ref ty =>\n                     span_bug!("}, {"sha": "30f79796aaa6de8f2aea395ce1961afe15be4ca1", "filename": "src/librustc_mir/hair/cx/pattern.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustc_mir%2Fhair%2Fcx%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustc_mir%2Fhair%2Fcx%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fpattern.rs?ref=d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2", "patch": "@@ -217,7 +217,9 @@ impl<'patcx, 'cx, 'gcx, 'tcx> PatCx<'patcx, 'cx, 'gcx, 'tcx> {\n             PatKind::Struct(_, ref fields, _) => {\n                 let pat_ty = self.cx.tcx.node_id_to_type(pat.id);\n                 let adt_def = match pat_ty.sty {\n-                    ty::TyStruct(adt_def, _) | ty::TyEnum(adt_def, _) => adt_def,\n+                    ty::TyStruct(adt_def, _) |\n+                    ty::TyUnion(adt_def, _) |\n+                    ty::TyEnum(adt_def, _) => adt_def,\n                     _ => {\n                         span_bug!(\n                             pat.span,\n@@ -313,7 +315,8 @@ impl<'patcx, 'cx, 'gcx, 'tcx> PatCx<'patcx, 'cx, 'gcx, 'tcx> {\n                 }\n             }\n \n-            Def::Struct(..) | Def::TyAlias(..) | Def::AssociatedTy(..) => {\n+            Def::Struct(..) | Def::Union(..) |\n+            Def::TyAlias(..) | Def::AssociatedTy(..) => {\n                 PatternKind::Leaf { subpatterns: subpatterns }\n             }\n "}, {"sha": "77af02c18c60ed3cb37f94e3a85b7f19e07c3c9d", "filename": "src/librustc_mir/transform/deaggregator.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustc_mir%2Ftransform%2Fdeaggregator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustc_mir%2Ftransform%2Fdeaggregator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fdeaggregator.rs?ref=d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2", "patch": "@@ -57,7 +57,7 @@ impl<'tcx> MirPass<'tcx> for Deaggregator {\n                 _ => span_bug!(src_info.span, \"expected aggregate, not {:?}\", rhs),\n             };\n             let (adt_def, variant, substs) = match agg_kind {\n-                &AggregateKind::Adt(adt_def, variant, substs) => (adt_def, variant, substs),\n+                &AggregateKind::Adt(adt_def, variant, substs, None) => (adt_def, variant, substs),\n                 _ => span_bug!(src_info.span, \"expected struct, not {:?}\", rhs),\n             };\n             let n = bb.statements.len();\n@@ -120,7 +120,7 @@ fn get_aggregate_statement_index<'a, 'tcx, 'b>(start: usize,\n             _ => continue,\n         };\n         let (adt_def, variant) = match kind {\n-            &AggregateKind::Adt(adt_def, variant, _) => (adt_def, variant),\n+            &AggregateKind::Adt(adt_def, variant, _, None) => (adt_def, variant),\n             _ => continue,\n         };\n         if operands.len() == 0 {"}, {"sha": "6c6a5f7fc74b0e0c9c67a6525df3d271a0c80c72", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2", "patch": "@@ -705,7 +705,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n             }\n \n             Rvalue::Aggregate(ref kind, _) => {\n-                if let AggregateKind::Adt(def, _, _) = *kind {\n+                if let AggregateKind::Adt(def, _, _, _) = *kind {\n                     if def.has_dtor() {\n                         self.add(Qualif::NEEDS_DROP);\n                         self.deny_drop();"}, {"sha": "55bd51cd75ba9c36836d91cfc589c737da8bed11", "filename": "src/librustc_mir/transform/type_check.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs?ref=d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2", "patch": "@@ -281,7 +281,9 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n                 (&adt_def.variants[variant_index], substs)\n             }\n             LvalueTy::Ty { ty } => match ty.sty {\n-                ty::TyStruct(adt_def, substs) | ty::TyEnum(adt_def, substs)\n+                ty::TyStruct(adt_def, substs) |\n+                ty::TyUnion(adt_def, substs) |\n+                ty::TyEnum(adt_def, substs)\n                     if adt_def.is_univariant() => {\n                         (&adt_def.variants[0], substs)\n                     }"}, {"sha": "b8284f5dcf10d0758aaf53f822acade94d03f5ae", "filename": "src/librustc_passes/ast_validation.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustc_passes%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustc_passes%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fast_validation.rs?ref=d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2", "patch": "@@ -196,6 +196,16 @@ impl<'a> Visitor for AstValidator<'a> {\n                 // Ensure that `path` attributes on modules are recorded as used (c.f. #35584).\n                 attr::first_attr_value_str_by_name(&item.attrs, \"path\");\n             }\n+            ItemKind::Union(ref vdata, _) => {\n+                if !vdata.is_struct() {\n+                    self.err_handler().span_err(item.span,\n+                                                \"tuple and unit unions are not permitted\");\n+                }\n+                if vdata.fields().len() == 0 {\n+                    self.err_handler().span_err(item.span,\n+                                                \"unions cannot have zero fields\");\n+                }\n+            }\n             _ => {}\n         }\n "}, {"sha": "c3749bf4546f3633fcb36522b4173a3975685f7e", "filename": "src/librustc_passes/consts.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustc_passes%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustc_passes%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fconsts.rs?ref=d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2", "patch": "@@ -440,6 +440,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for CheckCrateVisitor<'a, 'tcx> {\n fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>, e: &hir::Expr, node_ty: Ty<'tcx>) {\n     match node_ty.sty {\n         ty::TyStruct(def, _) |\n+        ty::TyUnion(def, _) |\n         ty::TyEnum(def, _) if def.has_dtor() => {\n             v.add_qualif(ConstQualif::NEEDS_DROP);\n         }"}, {"sha": "179863c16fff28f2b72c1371c63cfb9d1926608a", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 28, "deletions": 20, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2", "patch": "@@ -174,7 +174,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EmbargoVisitor<'a, 'tcx> {\n                     self.update(trait_item.id, item_level);\n                 }\n             }\n-            hir::ItemStruct(ref def, _) => {\n+            hir::ItemStruct(ref def, _) | hir::ItemUnion(ref def, _) => {\n                 if !def.is_struct() {\n                     self.update(def.id(), item_level);\n                 }\n@@ -234,7 +234,8 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EmbargoVisitor<'a, 'tcx> {\n                 }\n             }\n             // Visit everything except for private fields\n-            hir::ItemStruct(ref struct_def, ref generics) => {\n+            hir::ItemStruct(ref struct_def, ref generics) |\n+            hir::ItemUnion(ref struct_def, ref generics) => {\n                 if item_level.is_some() {\n                     self.reach().visit_generics(generics);\n                     for field in struct_def.fields() {\n@@ -320,8 +321,8 @@ impl<'b, 'a, 'tcx: 'a, 'v> Visitor<'v> for ReachEverythingInTheInterfaceVisitor<\n         if let hir::TyPath(_, ref path) = ty.node {\n             let def = self.ev.tcx.expect_def(ty.id);\n             match def {\n-                Def::Struct(def_id) | Def::Enum(def_id) | Def::TyAlias(def_id) |\n-                Def::Trait(def_id) | Def::AssociatedTy(def_id, _) => {\n+                Def::Struct(def_id) | Def::Union(def_id) | Def::Enum(def_id) |\n+                Def::TyAlias(def_id) | Def::Trait(def_id) | Def::AssociatedTy(def_id, _) => {\n                     if let Some(node_id) = self.ev.tcx.map.as_local_node_id(def_id) {\n                         let item = self.ev.tcx.map.expect_item(node_id);\n                         if let Def::TyAlias(..) = def {\n@@ -382,10 +383,11 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n \n     // Checks that a field is in scope.\n     fn check_field(&mut self, span: Span, def: ty::AdtDef<'tcx>, field: ty::FieldDef<'tcx>) {\n-        if def.adt_kind() == ty::AdtKind::Struct &&\n+        if def.adt_kind() != ty::AdtKind::Enum &&\n            !field.vis.is_accessible_from(self.curitem, &self.tcx.map) {\n-            struct_span_err!(self.tcx.sess, span, E0451, \"field `{}` of struct `{}` is private\",\n-                      field.name, self.tcx.item_path_str(def.did))\n+            let kind_descr = if def.adt_kind() == ty::AdtKind::Union { \"union\" } else { \"struct\" };\n+            struct_span_err!(self.tcx.sess, span, E0451, \"field `{}` of {} `{}` is private\",\n+                      field.name, kind_descr, self.tcx.item_path_str(def.did))\n                 .span_label(span, &format!(\"field `{}` is private\", field.name))\n                 .emit();\n         }\n@@ -427,19 +429,24 @@ impl<'a, 'tcx, 'v> Visitor<'v> for PrivacyVisitor<'a, 'tcx> {\n                 let method = self.tcx.tables.borrow().method_map[&method_call];\n                 self.check_method(expr.span, method.def_id);\n             }\n-            hir::ExprStruct(_, ref fields, _) => {\n+            hir::ExprStruct(_, ref expr_fields, _) => {\n                 let adt = self.tcx.expr_ty(expr).ty_adt_def().unwrap();\n                 let variant = adt.variant_of_def(self.tcx.expect_def(expr.id));\n                 // RFC 736: ensure all unmentioned fields are visible.\n                 // Rather than computing the set of unmentioned fields\n-                // (i.e. `all_fields - fields`), just check them all.\n-                for field in variant.fields.iter() {\n-                    let span = if let Some(f) = fields.iter().find(|f| f.name.node == field.name) {\n-                        f.span\n-                    } else {\n-                        expr.span\n-                    };\n-                    self.check_field(span, adt, field);\n+                // (i.e. `all_fields - fields`), just check them all,\n+                // unless the ADT is a union, then unmentioned fields\n+                // are not checked.\n+                if adt.adt_kind() == ty::AdtKind::Union {\n+                    for expr_field in expr_fields {\n+                        self.check_field(expr.span, adt, variant.field_named(expr_field.name.node));\n+                    }\n+                } else {\n+                    for field in &variant.fields {\n+                        let expr_field = expr_fields.iter().find(|f| f.name.node == field.name);\n+                        let span = if let Some(f) = expr_field { f.span } else { expr.span };\n+                        self.check_field(span, adt, field);\n+                    }\n                 }\n             }\n             hir::ExprPath(..) => {\n@@ -942,8 +949,8 @@ impl<'a, 'tcx: 'a, 'v> Visitor<'v> for SearchInterfaceForPrivateItemsVisitor<'a,\n                     // free type aliases, but this isn't done yet.\n                     return\n                 }\n-                Def::Struct(def_id) | Def::Enum(def_id) | Def::TyAlias(def_id) |\n-                Def::Trait(def_id) | Def::AssociatedTy(def_id, _) => {\n+                Def::Struct(def_id) | Def::Union(def_id) | Def::Enum(def_id) |\n+                Def::TyAlias(def_id) | Def::Trait(def_id) | Def::AssociatedTy(def_id, _) => {\n                     // Non-local means public (private items can't leave their crate, modulo bugs)\n                     if let Some(node_id) = self.tcx.map.as_local_node_id(def_id) {\n                         let item = self.tcx.map.expect_item(node_id);\n@@ -1067,8 +1074,9 @@ impl<'a, 'tcx, 'v> Visitor<'v> for PrivateItemsInPublicInterfacesVisitor<'a, 'tc\n                     check.visit_foreign_item(foreign_item);\n                 }\n             }\n-            // Subitems of structs have their own publicity\n-            hir::ItemStruct(ref struct_def, ref generics) => {\n+            // Subitems of structs and unions have their own publicity\n+            hir::ItemStruct(ref struct_def, ref generics) |\n+            hir::ItemUnion(ref struct_def, ref generics) => {\n                 check.required_visibility = item_visibility;\n                 check.visit_generics(generics);\n "}, {"sha": "8e97870c21a5bf68d9400718a45758197ade1035", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 20, "deletions": 1, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2", "patch": "@@ -278,7 +278,19 @@ impl<'b> Resolver<'b> {\n                 self.structs.insert(item_def_id, field_names);\n             }\n \n-            ItemKind::Union(..) => panic!(\"`union` is not yet implemented\"),\n+            ItemKind::Union(ref vdata, _) => {\n+                let def = Def::Union(self.definitions.local_def_id(item.id));\n+                self.define(parent, name, TypeNS, (def, sp, vis));\n+\n+                // Record the def ID and fields of this union.\n+                let field_names = vdata.fields().iter().enumerate().map(|(index, field)| {\n+                    self.resolve_visibility(&field.vis);\n+                    field.ident.map(|ident| ident.name)\n+                               .unwrap_or_else(|| token::intern(&index.to_string()))\n+                }).collect();\n+                let item_def_id = self.definitions.local_def_id(item.id);\n+                self.structs.insert(item_def_id, field_names);\n+            }\n \n             ItemKind::DefaultImpl(_, _) | ItemKind::Impl(..) => {}\n \n@@ -461,6 +473,13 @@ impl<'b> Resolver<'b> {\n                 let fields = self.session.cstore.struct_field_names(def_id);\n                 self.structs.insert(def_id, fields);\n             }\n+            Def::Union(def_id) => {\n+                let _ = self.try_define(parent, name, TypeNS, (def, DUMMY_SP, vis));\n+\n+                // Record the def ID and fields of this union.\n+                let fields = self.session.cstore.struct_field_names(def_id);\n+                self.structs.insert(def_id, fields);\n+            }\n             Def::Struct(..) => {}\n             Def::Local(..) |\n             Def::PrimTy(..) |"}, {"sha": "db0704db33fd543cc3e61f747d542ff680622175", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2", "patch": "@@ -2187,6 +2187,7 @@ impl<'a> Resolver<'a> {\n                                         Def::Trait(_) |\n                                         Def::Enum(_) |\n                                         Def::Struct(_) |\n+                                        Def::Union(_) |\n                                         Def::TyAlias(_) => true,\n                                         _               => false,\n                                     },\n@@ -2389,7 +2390,7 @@ impl<'a> Resolver<'a> {\n                 PatKind::Struct(ref path, _, _) => {\n                     self.resolve_pattern_path(pat.id, None, path, TypeNS, |def| {\n                         match def {\n-                            Def::Struct(..) | Def::Variant(..) |\n+                            Def::Struct(..) | Def::Union(..) | Def::Variant(..) |\n                             Def::TyAlias(..) | Def::AssociatedTy(..) => true,\n                             _ => false,\n                         }\n@@ -2735,7 +2736,7 @@ impl<'a> Resolver<'a> {\n             // Look for a field with the same name in the current self_type.\n             if let Some(resolution) = self.def_map.get(&node_id) {\n                 match resolution.base_def {\n-                    Def::Enum(did) | Def::TyAlias(did) |\n+                    Def::Enum(did) | Def::TyAlias(did) | Def::Union(did) |\n                     Def::Struct(did) | Def::Variant(_, did) if resolution.depth == 0 => {\n                         if let Some(fields) = self.structs.get(&did) {\n                             if fields.iter().any(|&field_name| name == field_name) {"}, {"sha": "f9a20cec42d14dcf169e730b09091d6f90186573", "filename": "src/librustc_save_analysis/dump_visitor.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdump_visitor.rs?ref=d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2", "patch": "@@ -300,6 +300,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n                 }.lower(self.tcx));\n             }\n             Def::Struct(..) |\n+            Def::Union(..) |\n             Def::Enum(..) |\n             Def::TyAlias(..) |\n             Def::AssociatedTy(..) |"}, {"sha": "47f3a06de1bd1166bd4a7f436f6020651095d786", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2", "patch": "@@ -404,7 +404,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                     }\n                 };\n                 match self.tcx.expr_ty_adjusted(&hir_node).sty {\n-                    ty::TyStruct(def, _) => {\n+                    ty::TyStruct(def, _) | ty::TyUnion(def, _) => {\n                         let f = def.struct_variant().field_named(ident.node.name);\n                         let sub_span = self.span_utils.span_for_last_ident(expr.span);\n                         filter!(self.span_utils, sub_span, expr.span, None);\n@@ -423,7 +423,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n             }\n             ast::ExprKind::Struct(ref path, _, _) => {\n                 match self.tcx.expr_ty_adjusted(&hir_node).sty {\n-                    ty::TyStruct(def, _) => {\n+                    ty::TyStruct(def, _) | ty::TyUnion(def, _) => {\n                         let sub_span = self.span_utils.span_for_last_ident(path.span);\n                         filter!(self.span_utils, sub_span, path.span, None);\n                         Some(Data::TypeRefData(TypeRefData {\n@@ -487,6 +487,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                 }))\n             }\n             Def::Struct(def_id) |\n+            Def::Union(def_id) |\n             Def::Enum(def_id) |\n             Def::TyAlias(def_id) |\n             Def::Trait(def_id) |"}, {"sha": "15a9d58c9b574369946257b8c039576be507e413", "filename": "src/librustc_trans/adt.rs", "status": "modified", "additions": 106, "deletions": 6, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustc_trans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustc_trans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fadt.rs?ref=d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2", "patch": "@@ -79,6 +79,8 @@ pub enum Repr<'tcx> {\n     CEnum(IntType, Disr, Disr), // discriminant range (signedness based on the IntType)\n     /// Single-case variants, and structs/tuples/records.\n     Univariant(Struct<'tcx>),\n+    /// Untagged unions.\n+    UntaggedUnion(Union<'tcx>),\n     /// General-case enums: for each case there is a struct, and they\n     /// all start with a field for the discriminant.\n     General(IntType, Vec<Struct<'tcx>>),\n@@ -121,6 +123,15 @@ pub struct Struct<'tcx> {\n     pub fields: Vec<Ty<'tcx>>,\n }\n \n+/// For untagged unions.\n+#[derive(Eq, PartialEq, Debug)]\n+pub struct Union<'tcx> {\n+    pub min_size: u64,\n+    pub align: u32,\n+    pub packed: bool,\n+    pub fields: Vec<Ty<'tcx>>,\n+}\n+\n #[derive(Copy, Clone)]\n pub struct MaybeSizedValue {\n     pub value: ValueRef,\n@@ -176,6 +187,13 @@ fn represent_type_uncached<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n             Univariant(mk_struct(cx, &ftys[..], packed, t))\n         }\n+        ty::TyUnion(def, substs) => {\n+            let ftys = def.struct_variant().fields.iter().map(|field| {\n+                monomorphize::field_ty(cx.tcx(), substs, field)\n+            }).collect::<Vec<_>>();\n+            let packed = cx.tcx().lookup_packed(def.did);\n+            UntaggedUnion(mk_union(cx, &ftys[..], packed, t))\n+        }\n         ty::TyClosure(_, ref substs) => {\n             Univariant(mk_struct(cx, &substs.upvar_tys, false, t))\n         }\n@@ -479,6 +497,31 @@ fn mk_struct<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     }\n }\n \n+fn mk_union<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n+                      tys: &[Ty<'tcx>], packed: bool,\n+                      _scapegoat: Ty<'tcx>)\n+                      -> Union<'tcx> {\n+    let mut min_size = 0;\n+    let mut align = 0;\n+    for llty in tys.iter().map(|&ty| type_of::sizing_type_of(cx, ty)) {\n+        let field_size = machine::llsize_of_alloc(cx, llty);\n+        if min_size < field_size {\n+            min_size = field_size;\n+        }\n+        let field_align = machine::llalign_of_min(cx, llty);\n+        if align < field_align {\n+            align = field_align;\n+        }\n+    }\n+\n+    Union {\n+        min_size: min_size,\n+        align: if packed { 1 } else { align },\n+        packed: packed,\n+        fields: tys.to_vec(),\n+    }\n+}\n+\n #[derive(Debug)]\n struct IntBounds {\n     slo: i64,\n@@ -643,7 +686,7 @@ pub fn incomplete_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n pub fn finish_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                 r: &Repr<'tcx>, llty: &mut Type) {\n     match *r {\n-        CEnum(..) | General(..) | RawNullablePointer { .. } => { }\n+        CEnum(..) | General(..) | UntaggedUnion(..) | RawNullablePointer { .. } => { }\n         Univariant(ref st) | StructWrappedNullablePointer { nonnull: ref st, .. } =>\n             llty.set_struct_body(&struct_llfields(cx, st, false, false),\n                                  st.packed)\n@@ -687,6 +730,34 @@ fn generic_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                 }\n             }\n         }\n+        UntaggedUnion(ref un) => {\n+            // Use alignment-sized ints to fill all the union storage.\n+            let (size, align) = (roundup(un.min_size, un.align), un.align);\n+\n+            let align_s = align as u64;\n+            assert_eq!(size % align_s, 0); // Ensure division in align_units comes out evenly\n+            let align_units = size / align_s;\n+            let fill_ty = match align_s {\n+                1 => Type::array(&Type::i8(cx), align_units),\n+                2 => Type::array(&Type::i16(cx), align_units),\n+                4 => Type::array(&Type::i32(cx), align_units),\n+                8 if machine::llalign_of_min(cx, Type::i64(cx)) == 8 =>\n+                                 Type::array(&Type::i64(cx), align_units),\n+                a if a.count_ones() == 1 => Type::array(&Type::vector(&Type::i32(cx), a / 4),\n+                                                              align_units),\n+                _ => bug!(\"unsupported union alignment: {}\", align)\n+            };\n+            match name {\n+                None => {\n+                    Type::struct_(cx, &[fill_ty], un.packed)\n+                }\n+                Some(name) => {\n+                    let mut llty = Type::named_struct(cx, name);\n+                    llty.set_struct_body(&[fill_ty], un.packed);\n+                    llty\n+                }\n+            }\n+        }\n         General(ity, ref sts) => {\n             // We need a representation that has:\n             // * The alignment of the most-aligned field\n@@ -759,7 +830,7 @@ pub fn trans_switch<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         RawNullablePointer { .. } | StructWrappedNullablePointer { .. } => {\n             (BranchKind::Switch, Some(trans_get_discr(bcx, r, scrutinee, None, range_assert)))\n         }\n-        Univariant(..) => {\n+        Univariant(..) | UntaggedUnion(..) => {\n             // N.B.: Univariant means <= 1 enum variants (*not* == 1 variants).\n             (BranchKind::Single, None)\n         }\n@@ -770,7 +841,7 @@ pub fn is_discr_signed<'tcx>(r: &Repr<'tcx>) -> bool {\n     match *r {\n         CEnum(ity, _, _) => ity.is_signed(),\n         General(ity, _) => ity.is_signed(),\n-        Univariant(..) => false,\n+        Univariant(..) | UntaggedUnion(..) => false,\n         RawNullablePointer { .. } => false,\n         StructWrappedNullablePointer { .. } => false,\n     }\n@@ -791,7 +862,7 @@ pub fn trans_get_discr<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, r: &Repr<'tcx>,\n             load_discr(bcx, ity, ptr, Disr(0), Disr(cases.len() as u64 - 1),\n                        range_assert)\n         }\n-        Univariant(..) => C_u8(bcx.ccx(), 0),\n+        Univariant(..) | UntaggedUnion(..) => C_u8(bcx.ccx(), 0),\n         RawNullablePointer { nndiscr, nnty, .. } =>  {\n             let cmp = if nndiscr == Disr(0) { IntEQ } else { IntNE };\n             let llptrty = type_of::sizing_type_of(bcx.ccx(), nnty);\n@@ -853,8 +924,8 @@ pub fn trans_case<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, r: &Repr, discr: Disr)\n         General(ity, _) => {\n             C_integral(ll_inttype(bcx.ccx(), ity), discr.0, true)\n         }\n-        Univariant(..) => {\n-            bug!(\"no cases for univariants or structs\")\n+        Univariant(..) | UntaggedUnion(..) => {\n+            bug!(\"no cases for univariants, structs or unions\")\n         }\n         RawNullablePointer { .. } |\n         StructWrappedNullablePointer { .. } => {\n@@ -881,6 +952,9 @@ pub fn trans_set_discr<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, r: &Repr<'tcx>,\n         Univariant(_) => {\n             assert_eq!(discr, Disr(0));\n         }\n+        UntaggedUnion(..) => {\n+            assert_eq!(discr, Disr(0));\n+        }\n         RawNullablePointer { nndiscr, nnty, ..} => {\n             if discr != nndiscr {\n                 let llptrty = type_of::sizing_type_of(bcx.ccx(), nnty);\n@@ -936,6 +1010,11 @@ pub fn trans_field_ptr_builder<'blk, 'tcx>(bcx: &BlockAndBuilder<'blk, 'tcx>,\n         General(_, ref cases) => {\n             struct_field_ptr(bcx, &cases[discr.0 as usize], val, ix + 1, true)\n         }\n+        UntaggedUnion(ref un) => {\n+            let ty = type_of::in_memory_type_of(bcx.ccx(), un.fields[ix]);\n+            if bcx.is_unreachable() { return C_undef(ty.ptr_to()); }\n+            bcx.pointercast(val.value, ty.ptr_to())\n+        }\n         RawNullablePointer { nndiscr, ref nullfields, .. } |\n         StructWrappedNullablePointer { nndiscr, ref nullfields, .. } if discr != nndiscr => {\n             // The unit-like case might have a nonzero number of unit-like fields.\n@@ -1097,6 +1176,11 @@ pub fn trans_const<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, r: &Repr<'tcx>, discr\n             contents.extend_from_slice(&[padding(ccx, max_sz - case.size)]);\n             C_struct(ccx, &contents[..], false)\n         }\n+        UntaggedUnion(ref un) => {\n+            assert_eq!(discr, Disr(0));\n+            let contents = build_const_union(ccx, un, vals[0]);\n+            C_struct(ccx, &contents, un.packed)\n+        }\n         Univariant(ref st) => {\n             assert_eq!(discr, Disr(0));\n             let contents = build_const_struct(ccx, st, vals);\n@@ -1190,6 +1274,21 @@ fn build_const_struct<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     cfields\n }\n \n+fn build_const_union<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+                               un: &Union<'tcx>,\n+                               field_val: ValueRef)\n+                               -> Vec<ValueRef> {\n+    let mut cfields = vec![field_val];\n+\n+    let offset = machine::llsize_of_alloc(ccx, val_ty(field_val));\n+    let size = roundup(un.min_size, un.align);\n+    if offset != size {\n+        cfields.push(padding(ccx, size - offset));\n+    }\n+\n+    cfields\n+}\n+\n fn padding(ccx: &CrateContext, size: u64) -> ValueRef {\n     C_undef(Type::array(&Type::i8(ccx), size))\n }\n@@ -1208,6 +1307,7 @@ pub fn const_get_field(r: &Repr, val: ValueRef, _discr: Disr,\n     match *r {\n         CEnum(..) => bug!(\"element access in C-like enum const\"),\n         Univariant(..) => const_struct_field(val, ix),\n+        UntaggedUnion(..) => const_struct_field(val, 0),\n         General(..) => const_struct_field(val, ix + 1),\n         RawNullablePointer { .. } => {\n             assert_eq!(ix, 0);"}, {"sha": "4bea5d7e87fc9c03197544b028c31d45dc741864", "filename": "src/librustc_trans/collector.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustc_trans%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustc_trans%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcollector.rs?ref=d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2", "patch": "@@ -744,6 +744,7 @@ fn find_drop_glue_neighbors<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n     // monomorphized Drop::drop() implementation.\n     let destructor_did = match ty.sty {\n         ty::TyStruct(def, _) |\n+        ty::TyUnion(def, _) |\n         ty::TyEnum(def, _)   => def.destructor(),\n         _ => None\n     };\n@@ -798,6 +799,7 @@ fn find_drop_glue_neighbors<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n             /* nothing to do */\n         }\n         ty::TyStruct(ref adt_def, substs) |\n+        ty::TyUnion(ref adt_def, substs) |\n         ty::TyEnum(ref adt_def, substs) => {\n             for field in adt_def.all_fields() {\n                 let field_type = monomorphize::apply_param_substs(scx,\n@@ -1121,8 +1123,9 @@ impl<'b, 'a, 'v> hir_visit::Visitor<'v> for RootCollector<'b, 'a, 'v> {\n                 }\n             }\n \n-            hir::ItemEnum(_, ref generics)        |\n-            hir::ItemStruct(_, ref generics)      => {\n+            hir::ItemEnum(_, ref generics) |\n+            hir::ItemStruct(_, ref generics) |\n+            hir::ItemUnion(_, ref generics) => {\n                 if !generics.is_parameterized() {\n                     let ty = {\n                         let tables = self.scx.tcx().tables.borrow();"}, {"sha": "6ae6f8aead77dff9d511cb1f23234329f184d38c", "filename": "src/librustc_trans/common.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustc_trans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustc_trans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcommon.rs?ref=d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2", "patch": "@@ -88,8 +88,8 @@ pub fn type_is_immediate<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ty: Ty<'tcx>) -\n         return false;\n     }\n     match ty.sty {\n-        ty::TyStruct(..) | ty::TyEnum(..) | ty::TyTuple(..) | ty::TyArray(_, _) |\n-        ty::TyClosure(..) => {\n+        ty::TyStruct(..) | ty::TyUnion(..) | ty::TyEnum(..) |\n+        ty::TyTuple(..) | ty::TyArray(..) | ty::TyClosure(..) => {\n             let llty = sizing_type_of(ccx, ty);\n             llsize_of_alloc(ccx, llty) <= llsize_of_alloc(ccx, ccx.int_type())\n         }\n@@ -205,7 +205,7 @@ impl<'a, 'tcx> VariantInfo<'tcx> {\n                    -> Self\n     {\n         match ty.sty {\n-            ty::TyStruct(adt, substs) | ty::TyEnum(adt, substs) => {\n+            ty::TyStruct(adt, substs) | ty::TyUnion(adt, substs) | ty::TyEnum(adt, substs) => {\n                 let variant = match opt_def {\n                     None => adt.struct_variant(),\n                     Some(def) => adt.variant_of_def(def)"}, {"sha": "bdfeee37625e812031af0ce7bbe4bf098d99dd8d", "filename": "src/librustc_trans/debuginfo/metadata.rs", "status": "modified", "additions": 114, "deletions": 3, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs?ref=d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2", "patch": "@@ -184,6 +184,10 @@ impl<'tcx> TypeMap<'tcx> {\n                 unique_type_id.push_str(\"struct \");\n                 from_def_id_and_substs(self, cx, def.did, substs, &mut unique_type_id);\n             },\n+            ty::TyUnion(def, substs) => {\n+                unique_type_id.push_str(\"union \");\n+                from_def_id_and_substs(self, cx, def.did, substs, &mut unique_type_id);\n+            },\n             ty::TyTuple(component_types) if component_types.is_empty() => {\n                 push_debuginfo_type_name(cx, type_, false, &mut unique_type_id);\n             },\n@@ -781,6 +785,12 @@ pub fn type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                     unique_type_id,\n                                     usage_site_span).finalize(cx)\n         }\n+        ty::TyUnion(..) => {\n+            prepare_union_metadata(cx,\n+                                   t,\n+                                   unique_type_id,\n+                                   usage_site_span).finalize(cx)\n+        }\n         ty::TyTuple(ref elements) => {\n             prepare_tuple_metadata(cx,\n                                    t,\n@@ -1031,6 +1041,7 @@ enum MemberDescriptionFactory<'tcx> {\n     StructMDF(StructMemberDescriptionFactory<'tcx>),\n     TupleMDF(TupleMemberDescriptionFactory<'tcx>),\n     EnumMDF(EnumMemberDescriptionFactory<'tcx>),\n+    UnionMDF(UnionMemberDescriptionFactory<'tcx>),\n     VariantMDF(VariantMemberDescriptionFactory<'tcx>)\n }\n \n@@ -1047,6 +1058,9 @@ impl<'tcx> MemberDescriptionFactory<'tcx> {\n             EnumMDF(ref this) => {\n                 this.create_member_descriptions(cx)\n             }\n+            UnionMDF(ref this) => {\n+                this.create_member_descriptions(cx)\n+            }\n             VariantMDF(ref this) => {\n                 this.create_member_descriptions(cx)\n             }\n@@ -1147,7 +1161,6 @@ fn prepare_struct_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     )\n }\n \n-\n //=-----------------------------------------------------------------------------\n // Tuples\n //=-----------------------------------------------------------------------------\n@@ -1202,6 +1215,66 @@ fn prepare_tuple_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     )\n }\n \n+//=-----------------------------------------------------------------------------\n+// Unions\n+//=-----------------------------------------------------------------------------\n+\n+struct UnionMemberDescriptionFactory<'tcx> {\n+    variant: ty::VariantDef<'tcx>,\n+    substs: &'tcx Substs<'tcx>,\n+    span: Span,\n+}\n+\n+impl<'tcx> UnionMemberDescriptionFactory<'tcx> {\n+    fn create_member_descriptions<'a>(&self, cx: &CrateContext<'a, 'tcx>)\n+                                      -> Vec<MemberDescription> {\n+        self.variant.fields.iter().map(|field| {\n+            let fty = monomorphize::field_ty(cx.tcx(), self.substs, field);\n+            MemberDescription {\n+                name: field.name.to_string(),\n+                llvm_type: type_of::type_of(cx, fty),\n+                type_metadata: type_metadata(cx, fty, self.span),\n+                offset: FixedMemberOffset { bytes: 0 },\n+                flags: FLAGS_NONE,\n+            }\n+        }).collect()\n+    }\n+}\n+\n+fn prepare_union_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n+                                    union_type: Ty<'tcx>,\n+                                    unique_type_id: UniqueTypeId,\n+                                    span: Span)\n+                                    -> RecursiveTypeDescription<'tcx> {\n+    let union_name = compute_debuginfo_type_name(cx, union_type, false);\n+    let union_llvm_type = type_of::in_memory_type_of(cx, union_type);\n+\n+    let (union_def_id, variant, substs) = match union_type.sty {\n+        ty::TyUnion(def, substs) => (def.did, def.struct_variant(), substs),\n+        _ => bug!(\"prepare_union_metadata on a non-union\")\n+    };\n+\n+    let (containing_scope, _) = get_namespace_and_span_for_item(cx, union_def_id);\n+\n+    let union_metadata_stub = create_union_stub(cx,\n+                                                union_llvm_type,\n+                                                &union_name,\n+                                                unique_type_id,\n+                                                containing_scope);\n+\n+    create_and_register_recursive_type_forward_declaration(\n+        cx,\n+        union_type,\n+        unique_type_id,\n+        union_metadata_stub,\n+        union_llvm_type,\n+        UnionMDF(UnionMemberDescriptionFactory {\n+            variant: variant,\n+            substs: substs,\n+            span: span,\n+        })\n+    )\n+}\n \n //=-----------------------------------------------------------------------------\n // Enums\n@@ -1411,7 +1484,9 @@ impl<'tcx> EnumMemberDescriptionFactory<'tcx> {\n                     }\n                 ]\n             },\n-            adt::CEnum(..) => span_bug!(self.span, \"This should be unreachable.\")\n+            adt::CEnum(..) | adt::UntaggedUnion(..) => {\n+                span_bug!(self.span, \"This should be unreachable.\")\n+            }\n         }\n     }\n }\n@@ -1609,7 +1684,7 @@ fn prepare_enum_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         },\n         adt::RawNullablePointer { .. }           |\n         adt::StructWrappedNullablePointer { .. } |\n-        adt::Univariant(..)                      => None,\n+        adt::Univariant(..) | adt::UntaggedUnion(..) => None,\n         adt::General(inttype, _) => Some(discriminant_type_metadata(inttype)),\n     };\n \n@@ -1789,6 +1864,42 @@ fn create_struct_stub(cx: &CrateContext,\n     return metadata_stub;\n }\n \n+fn create_union_stub(cx: &CrateContext,\n+                     union_llvm_type: Type,\n+                     union_type_name: &str,\n+                     unique_type_id: UniqueTypeId,\n+                     containing_scope: DIScope)\n+                   -> DICompositeType {\n+    let (union_size, union_align) = size_and_align_of(cx, union_llvm_type);\n+\n+    let unique_type_id_str = debug_context(cx).type_map\n+                                              .borrow()\n+                                              .get_unique_type_id_as_string(unique_type_id);\n+    let name = CString::new(union_type_name).unwrap();\n+    let unique_type_id = CString::new(unique_type_id_str.as_bytes()).unwrap();\n+    let metadata_stub = unsafe {\n+        // LLVMRustDIBuilderCreateUnionType() wants an empty array. A null\n+        // pointer will lead to hard to trace and debug LLVM assertions\n+        // later on in llvm/lib/IR/Value.cpp.\n+        let empty_array = create_DIArray(DIB(cx), &[]);\n+\n+        llvm::LLVMRustDIBuilderCreateUnionType(\n+            DIB(cx),\n+            containing_scope,\n+            name.as_ptr(),\n+            unknown_file_metadata(cx),\n+            UNKNOWN_LINE_NUMBER,\n+            bytes_to_bits(union_size),\n+            bytes_to_bits(union_align),\n+            0, // Flags\n+            empty_array,\n+            0, // RuntimeLang\n+            unique_type_id.as_ptr())\n+    };\n+\n+    return metadata_stub;\n+}\n+\n /// Creates debug information for the given global variable.\n ///\n /// Adds the created metadata nodes directly to the crate's IR."}, {"sha": "20a33498475a2c920ce99fe54b07730afeedd166", "filename": "src/librustc_trans/debuginfo/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs?ref=d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2", "patch": "@@ -421,7 +421,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                 // Only \"class\" methods are generally understood by LLVM,\n                 // so avoid methods on other types (e.g. `<*mut T>::null`).\n                 match impl_self_ty.sty {\n-                    ty::TyStruct(..) | ty::TyEnum(..) => {\n+                    ty::TyStruct(..) | ty::TyUnion(..) | ty::TyEnum(..) => {\n                         Some(type_metadata(cx, impl_self_ty, syntax_pos::DUMMY_SP))\n                     }\n                     _ => None"}, {"sha": "bd839243e201f73a277aa3544d13cb3cc8aa366a", "filename": "src/librustc_trans/debuginfo/type_names.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustc_trans%2Fdebuginfo%2Ftype_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustc_trans%2Fdebuginfo%2Ftype_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Ftype_names.rs?ref=d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2", "patch": "@@ -45,6 +45,7 @@ pub fn push_debuginfo_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         ty::TyUint(uint_ty) => output.push_str(uint_ty.ty_to_string()),\n         ty::TyFloat(float_ty) => output.push_str(float_ty.ty_to_string()),\n         ty::TyStruct(def, substs) |\n+        ty::TyUnion(def, substs) |\n         ty::TyEnum(def, substs) => {\n             push_item_name(cx, def.did, qualified, output);\n             push_type_params(cx, substs, output);"}, {"sha": "34c92f334d0ac6d387eebcfeecc45e3cfddf21aa", "filename": "src/librustc_trans/glue.rs", "status": "modified", "additions": 15, "deletions": 5, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustc_trans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustc_trans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fglue.rs?ref=d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2", "patch": "@@ -265,12 +265,13 @@ pub fn implement_drop_glue<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     fcx.finish(bcx, DebugLoc::None);\n }\n \n-fn trans_struct_drop<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+fn trans_custom_dtor<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                  t: Ty<'tcx>,\n-                                 v0: ValueRef)\n+                                 v0: ValueRef,\n+                                 shallow_drop: bool)\n                                  -> Block<'blk, 'tcx>\n {\n-    debug!(\"trans_struct_drop t: {}\", t);\n+    debug!(\"trans_custom_dtor t: {}\", t);\n     let tcx = bcx.tcx();\n     let mut bcx = bcx;\n \n@@ -286,7 +287,9 @@ fn trans_struct_drop<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n     // Issue #23611: schedule cleanup of contents, re-inspecting the\n     // discriminant (if any) in case of variant swap in drop code.\n-    bcx.fcx.schedule_drop_adt_contents(contents_scope, v0, t);\n+    if !shallow_drop {\n+        bcx.fcx.schedule_drop_adt_contents(contents_scope, v0, t);\n+    }\n \n     let (sized_args, unsized_args);\n     let args: &[ValueRef] = if type_is_sized(tcx, t) {\n@@ -486,7 +489,14 @@ fn make_drop_glue<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, v0: ValueRef, g: DropGlueK\n         }\n         ty::TyStruct(def, _) | ty::TyEnum(def, _)\n                 if def.dtor_kind().is_present() && !skip_dtor => {\n-            trans_struct_drop(bcx, t, v0)\n+            trans_custom_dtor(bcx, t, v0, false)\n+        }\n+        ty::TyUnion(def, _) => {\n+            if def.dtor_kind().is_present() && !skip_dtor {\n+                trans_custom_dtor(bcx, t, v0, true)\n+            } else {\n+                bcx\n+            }\n         }\n         _ => {\n             if bcx.fcx.type_needs_drop(t) {"}, {"sha": "15dc7bb4421c1a9bbc0d8dd2f505035ab1077460", "filename": "src/librustc_trans/mir/constant.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fconstant.rs?ref=d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2", "patch": "@@ -547,7 +547,7 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n                                                         self.monomorphize(&substs));\n                 }\n \n-                let val = if let mir::AggregateKind::Adt(adt_def, index, _) = *kind {\n+                let val = if let mir::AggregateKind::Adt(adt_def, index, _, _) = *kind {\n                     let repr = adt::represent_type(self.ccx, dest_ty);\n                     let disr = Disr::from(adt_def.variants[index].disr_val);\n                     adt::trans_const(self.ccx, &repr, disr, &fields)"}, {"sha": "21b019d7e24dff60cddf699052d63154ecdb022a", "filename": "src/librustc_trans/mir/rvalue.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Frvalue.rs?ref=d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2", "patch": "@@ -110,9 +110,9 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n \n             mir::Rvalue::Aggregate(ref kind, ref operands) => {\n                 match *kind {\n-                    mir::AggregateKind::Adt(adt_def, index, _) => {\n+                    mir::AggregateKind::Adt(adt_def, variant_index, _, active_field_index) => {\n                         let repr = adt::represent_type(bcx.ccx(), dest.ty.to_ty(bcx.tcx()));\n-                        let disr = Disr::from(adt_def.variants[index].disr_val);\n+                        let disr = Disr::from(adt_def.variants[variant_index].disr_val);\n                         bcx.with_block(|bcx| {\n                             adt::trans_set_discr(bcx, &repr, dest.llval, Disr::from(disr));\n                         });\n@@ -121,8 +121,9 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                             // Do not generate stores and GEPis for zero-sized fields.\n                             if !common::type_is_zero_size(bcx.ccx(), op.ty) {\n                                 let val = adt::MaybeSizedValue::sized(dest.llval);\n-                                let lldest_i = adt::trans_field_ptr_builder(&bcx, &repr,\n-                                                                            val, disr, i);\n+                                let field_index = active_field_index.unwrap_or(i);\n+                                let lldest_i = adt::trans_field_ptr_builder(&bcx, &repr, val,\n+                                                                            disr, field_index);\n                                 self.store_operand(&bcx, lldest_i, op);\n                             }\n                         }"}, {"sha": "deef0b09a17b032dfa1b63b06c5e11418310afec", "filename": "src/librustc_trans/trans_item.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustc_trans%2Ftrans_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustc_trans%2Ftrans_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans_item.rs?ref=d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2", "patch": "@@ -397,6 +397,7 @@ pub fn push_unique_type_name<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         ty::TyFloat(ast::FloatTy::F32) => output.push_str(\"f32\"),\n         ty::TyFloat(ast::FloatTy::F64) => output.push_str(\"f64\"),\n         ty::TyStruct(adt_def, substs) |\n+        ty::TyUnion(adt_def, substs) |\n         ty::TyEnum(adt_def, substs) => {\n             push_item_name(tcx, adt_def.did, output);\n             push_type_params(tcx, substs, &[], output);"}, {"sha": "b5565109306b4d57321729cadae3d11bd1352052", "filename": "src/librustc_trans/type_of.rs", "status": "modified", "additions": 37, "deletions": 48, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustc_trans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustc_trans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftype_of.rs?ref=d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2", "patch": "@@ -89,27 +89,23 @@ pub fn sizing_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Typ\n             Type::nil(cx)\n         }\n \n-        ty::TyTuple(..) | ty::TyEnum(..) | ty::TyClosure(..) => {\n-            let repr = adt::represent_type(cx, t);\n-            adt::sizing_type_of(cx, &repr, false)\n+        ty::TyStruct(..) if t.is_simd() => {\n+            let e = t.simd_type(cx.tcx());\n+            if !e.is_machine() {\n+                cx.sess().fatal(&format!(\"monomorphising SIMD type `{}` with \\\n+                                          a non-machine element type `{}`\",\n+                                         t, e))\n+            }\n+            let llet = type_of(cx, e);\n+            let n = t.simd_size(cx.tcx()) as u64;\n+            ensure_array_fits_in_address_space(cx, llet, n, t);\n+            Type::vector(&llet, n)\n         }\n \n-        ty::TyStruct(..) => {\n-            if t.is_simd() {\n-                let e = t.simd_type(cx.tcx());\n-                if !e.is_machine() {\n-                    cx.sess().fatal(&format!(\"monomorphising SIMD type `{}` with \\\n-                                              a non-machine element type `{}`\",\n-                                             t, e))\n-                }\n-                let llet = type_of(cx, e);\n-                let n = t.simd_size(cx.tcx()) as u64;\n-                ensure_array_fits_in_address_space(cx, llet, n, t);\n-                Type::vector(&llet, n)\n-            } else {\n-                let repr = adt::represent_type(cx, t);\n-                adt::sizing_type_of(cx, &repr, false)\n-            }\n+        ty::TyTuple(..) | ty::TyStruct(..) | ty::TyUnion(..) |\n+        ty::TyEnum(..) | ty::TyClosure(..) => {\n+            let repr = adt::represent_type(cx, t);\n+            adt::sizing_type_of(cx, &repr, false)\n         }\n \n         ty::TyProjection(..) | ty::TyInfer(..) | ty::TyParam(..) |\n@@ -244,15 +240,6 @@ pub fn in_memory_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) ->\n       ty::TyUint(t) => Type::uint_from_ty(cx, t),\n       ty::TyFloat(t) => Type::float_from_ty(cx, t),\n       ty::TyNever => Type::nil(cx),\n-      ty::TyEnum(def, ref substs) => {\n-          // Only create the named struct, but don't fill it in. We\n-          // fill it in *after* placing it into the type cache. This\n-          // avoids creating more than one copy of the enum when one\n-          // of the enum's variants refers to the enum itself.\n-          let repr = adt::represent_type(cx, t);\n-          let name = llvm_type_name(cx, def.did, substs);\n-          adt::incomplete_type_of(cx, &repr, &name[..])\n-      }\n       ty::TyClosure(..) => {\n           // Only create the named struct, but don't fill it in. We\n           // fill it in *after* placing it into the type cache.\n@@ -307,26 +294,28 @@ pub fn in_memory_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) ->\n           let repr = adt::represent_type(cx, t);\n           adt::type_of(cx, &repr)\n       }\n-      ty::TyStruct(def, ref substs) => {\n-          if t.is_simd() {\n-              let e = t.simd_type(cx.tcx());\n-              if !e.is_machine() {\n-                  cx.sess().fatal(&format!(\"monomorphising SIMD type `{}` with \\\n-                                            a non-machine element type `{}`\",\n-                                           t, e))\n-              }\n-              let llet = in_memory_type_of(cx, e);\n-              let n = t.simd_size(cx.tcx()) as u64;\n-              ensure_array_fits_in_address_space(cx, llet, n, t);\n-              Type::vector(&llet, n)\n-          } else {\n-              // Only create the named struct, but don't fill it in. We fill it\n-              // in *after* placing it into the type cache. This prevents\n-              // infinite recursion with recursive struct types.\n-              let repr = adt::represent_type(cx, t);\n-              let name = llvm_type_name(cx, def.did, substs);\n-              adt::incomplete_type_of(cx, &repr, &name[..])\n+      ty::TyStruct(..) if t.is_simd() => {\n+          let e = t.simd_type(cx.tcx());\n+          if !e.is_machine() {\n+              cx.sess().fatal(&format!(\"monomorphising SIMD type `{}` with \\\n+                                        a non-machine element type `{}`\",\n+                                       t, e))\n           }\n+          let llet = in_memory_type_of(cx, e);\n+          let n = t.simd_size(cx.tcx()) as u64;\n+          ensure_array_fits_in_address_space(cx, llet, n, t);\n+          Type::vector(&llet, n)\n+      }\n+      ty::TyStruct(def, ref substs) |\n+      ty::TyUnion(def, ref substs) |\n+      ty::TyEnum(def, ref substs) => {\n+          // Only create the named struct, but don't fill it in. We\n+          // fill it in *after* placing it into the type cache. This\n+          // avoids creating more than one copy of the enum when one\n+          // of the enum's variants refers to the enum itself.\n+          let repr = adt::represent_type(cx, t);\n+          let name = llvm_type_name(cx, def.did, substs);\n+          adt::incomplete_type_of(cx, &repr, &name[..])\n       }\n \n       ty::TyInfer(..) |\n@@ -342,7 +331,7 @@ pub fn in_memory_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) ->\n \n     // If this was an enum or struct, fill in the type now.\n     match t.sty {\n-        ty::TyEnum(..) | ty::TyStruct(..) | ty::TyClosure(..)\n+        ty::TyEnum(..) | ty::TyStruct(..) | ty::TyUnion(..) | ty::TyClosure(..)\n                 if !t.is_simd() => {\n             let repr = adt::represent_type(cx, t);\n             adt::finish_type_of(cx, &repr, &mut llty);"}, {"sha": "c445455ef2bc5b334321907ac892389e50fc53c8", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2", "patch": "@@ -1476,7 +1476,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                                                span,\n                                                partition_bounds(tcx, span, &[]))\n             }\n-            Def::Enum(did) | Def::TyAlias(did) | Def::Struct(did) => {\n+            Def::Enum(did) | Def::TyAlias(did) | Def::Struct(did) | Def::Union(did) => {\n                 tcx.prohibit_type_params(base_segments.split_last().unwrap().1);\n                 self.ast_path_to_ty(rscope,\n                                     span,"}, {"sha": "12fce4b928e08fe26eae293553a68425d3b60e23", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 27, "deletions": 21, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2", "patch": "@@ -11,7 +11,6 @@\n use hir::def::Def;\n use rustc::infer::{self, InferOk, TypeOrigin};\n use hir::pat_util::EnumerateAndAdjustIterator;\n-use rustc::ty::subst::Substs;\n use rustc::ty::{self, Ty, TypeFoldable, LvaluePreference, VariantKind};\n use check::{FnCtxt, Expectation};\n use lint;\n@@ -509,11 +508,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         self.demand_eqtype(pat.span, expected, pat_ty);\n \n         // Type check subpatterns.\n-        let substs = match pat_ty.sty {\n-            ty::TyStruct(_, substs) | ty::TyEnum(_, substs) => substs,\n-            _ => span_bug!(pat.span, \"struct variant is not an ADT\")\n-        };\n-        self.check_struct_pat_fields(pat.span, fields, variant, substs, etc);\n+        self.check_struct_pat_fields(pat_ty, pat.span, variant, fields, etc);\n     }\n \n     fn check_pat_path(&self,\n@@ -658,19 +653,21 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    /// `path` is the AST path item naming the type of this struct.\n-    /// `fields` is the field patterns of the struct pattern.\n-    /// `struct_fields` describes the type of each field of the struct.\n-    /// `struct_id` is the ID of the struct.\n-    /// `etc` is true if the pattern said '...' and false otherwise.\n-    pub fn check_struct_pat_fields(&self,\n-                                   span: Span,\n-                                   fields: &'gcx [Spanned<hir::FieldPat>],\n-                                   variant: ty::VariantDef<'tcx>,\n-                                   substs: &Substs<'tcx>,\n-                                   etc: bool) {\n+    fn check_struct_pat_fields(&self,\n+                               adt_ty: Ty<'tcx>,\n+                               span: Span,\n+                               variant: ty::VariantDef<'tcx>,\n+                               fields: &'gcx [Spanned<hir::FieldPat>],\n+                               etc: bool) {\n         let tcx = self.tcx;\n \n+        let (substs, kind_name) = match adt_ty.sty {\n+            ty::TyEnum(_, substs) => (substs, \"variant\"),\n+            ty::TyStruct(_, substs) => (substs, \"struct\"),\n+            ty::TyUnion(_, substs) => (substs, \"union\"),\n+            _ => span_bug!(span, \"struct pattern is not an ADT\")\n+        };\n+\n         // Index the struct fields' types.\n         let field_map = variant.fields\n             .iter()\n@@ -700,11 +697,13 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         .map(|f| self.field_ty(span, f, substs))\n                         .unwrap_or_else(|| {\n                             struct_span_err!(tcx.sess, span, E0026,\n-                                             \"struct `{}` does not have a field named `{}`\",\n+                                             \"{} `{}` does not have a field named `{}`\",\n+                                             kind_name,\n                                              tcx.item_path_str(variant.did),\n                                              field.name)\n                                 .span_label(span,\n-                                            &format!(\"struct `{}` does not have field `{}`\",\n+                                            &format!(\"{} `{}` does not have field `{}`\",\n+                                                     kind_name,\n                                                      tcx.item_path_str(variant.did),\n                                                      field.name))\n                                 .emit();\n@@ -717,8 +716,15 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             self.check_pat(&field.pat, field_ty);\n         }\n \n-        // Report an error if not all the fields were specified.\n-        if !etc {\n+        // Report an error if incorrect number of the fields were specified.\n+        if kind_name == \"union\" {\n+            if fields.len() != 1 {\n+                tcx.sess.span_err(span, \"union patterns should have exactly one field\");\n+            }\n+            if etc {\n+                tcx.sess.span_err(span, \"`..` cannot be used in union patterns\");\n+            }\n+        } else if !etc {\n             for field in variant.fields\n                 .iter()\n                 .filter(|field| !used_fields.contains_key(&field.name)) {"}, {"sha": "88add66b7dcb0a2059a20e94f7172a12417b9d94", "filename": "src/librustc_typeck/check/dropck.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs?ref=d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2", "patch": "@@ -45,6 +45,7 @@ pub fn check_drop_impl(ccx: &CrateCtxt, drop_impl_did: DefId) -> Result<(), ()>\n     let dtor_predicates = ccx.tcx.lookup_predicates(drop_impl_did);\n     match dtor_self_type.sty {\n         ty::TyEnum(adt_def, self_to_impl_substs) |\n+        ty::TyUnion(adt_def, self_to_impl_substs) |\n         ty::TyStruct(adt_def, self_to_impl_substs) => {\n             ensure_drop_params_and_item_params_correspond(ccx,\n                                                           drop_impl_did,\n@@ -304,7 +305,9 @@ pub fn check_safety_of_destructor_if_necessary<'a, 'gcx, 'tcx>(\n                                                      tcx.item_path_str(def_id),\n                                                      variant),\n                         ty::AdtKind::Struct => format!(\"struct {}\",\n-                                                       tcx.item_path_str(def_id))\n+                                                       tcx.item_path_str(def_id)),\n+                        ty::AdtKind::Union => format!(\"union {}\",\n+                                                       tcx.item_path_str(def_id)),\n                     };\n                     span_note!(\n                         &mut err,\n@@ -439,7 +442,7 @@ fn iterate_over_potentially_unsafe_regions_in_type<'a, 'b, 'gcx, 'tcx>(\n                 cx, context, ity, depth+1)\n         }\n \n-        ty::TyStruct(def, substs) | ty::TyEnum(def, substs) => {\n+        ty::TyStruct(def, substs) | ty::TyUnion(def, substs) | ty::TyEnum(def, substs) => {\n             let did = def.did;\n             for variant in &def.variants {\n                 for field in variant.fields.iter() {\n@@ -494,7 +497,7 @@ fn iterate_over_potentially_unsafe_regions_in_type<'a, 'b, 'gcx, 'tcx>(\n fn has_dtor_of_interest<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                                         ty: Ty<'tcx>) -> bool {\n     match ty.sty {\n-        ty::TyEnum(def, _) | ty::TyStruct(def, _) => {\n+        ty::TyEnum(def, _) | ty::TyStruct(def, _) | ty::TyUnion(def, _) => {\n             def.is_dtorck(tcx)\n         }\n         ty::TyTrait(..) | ty::TyProjection(..) | ty::TyAnon(..) => {"}, {"sha": "edee7300868714b2b7143a86d6382f64790880af", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2", "patch": "@@ -293,7 +293,8 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n                 self.assemble_inherent_impl_candidates_for_type(data.principal.def_id());\n             }\n             ty::TyEnum(def, _) |\n-            ty::TyStruct(def, _) => {\n+            ty::TyStruct(def, _) |\n+            ty::TyUnion(def, _) => {\n                 self.assemble_inherent_impl_candidates_for_type(def.did);\n             }\n             ty::TyBox(_) => {"}, {"sha": "e4ea9bb407d96e26332a74f3ef93d8324e3c89ae", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 29, "deletions": 23, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2", "patch": "@@ -164,30 +164,34 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 // give a helping note that it has to be called as (x.f)(...).\n                 if let Some(expr) = rcvr_expr {\n                     for (ty, _) in self.autoderef(span, rcvr_ty) {\n-                        if let ty::TyStruct(def, substs) = ty.sty {\n-                            if let Some(field) = def.struct_variant().find_field_named(item_name) {\n-                                let snippet = tcx.sess.codemap().span_to_snippet(expr.span);\n-                                let expr_string = match snippet {\n-                                    Ok(expr_string) => expr_string,\n-                                    _ => \"s\".into() // Default to a generic placeholder for the\n-                                                    // expression when we can't generate a\n-                                                    // string snippet\n-                                };\n-\n-                                let field_ty = field.ty(tcx, substs);\n-\n-                                if self.is_fn_ty(&field_ty, span) {\n-                                    err.span_note(span, &format!(\n-                                        \"use `({0}.{1})(...)` if you meant to call the function \\\n-                                         stored in the `{1}` field\",\n-                                        expr_string, item_name));\n-                                } else {\n-                                    err.span_note(span, &format!(\n-                                        \"did you mean to write `{0}.{1}`?\",\n-                                        expr_string, item_name));\n+                        match ty.sty {\n+                            ty::TyStruct(def, substs) | ty::TyUnion(def, substs) => {\n+                                if let Some(field) = def.struct_variant().\n+                                                         find_field_named(item_name) {\n+                                    let snippet = tcx.sess.codemap().span_to_snippet(expr.span);\n+                                    let expr_string = match snippet {\n+                                        Ok(expr_string) => expr_string,\n+                                        _ => \"s\".into() // Default to a generic placeholder for the\n+                                                        // expression when we can't generate a\n+                                                        // string snippet\n+                                    };\n+\n+                                    let field_ty = field.ty(tcx, substs);\n+\n+                                    if self.is_fn_ty(&field_ty, span) {\n+                                        err.span_note(span, &format!(\n+                                            \"use `({0}.{1})(...)` if you meant to call the \\\n+                                             function stored in the `{1}` field\",\n+                                            expr_string, item_name));\n+                                    } else {\n+                                        err.span_note(span, &format!(\n+                                            \"did you mean to write `{0}.{1}`?\",\n+                                            expr_string, item_name));\n+                                    }\n+                                    break;\n                                 }\n-                                break;\n                             }\n+                            _ => {}\n                         }\n                     }\n                 }\n@@ -355,7 +359,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                             rcvr_expr: Option<&hir::Expr>) -> bool {\n         fn is_local(ty: Ty) -> bool {\n             match ty.sty {\n-                ty::TyEnum(def, _) | ty::TyStruct(def, _) => def.did.is_local(),\n+                ty::TyEnum(def, _) | ty::TyStruct(def, _) | ty::TyUnion(def, _) => {\n+                    def.did.is_local()\n+                }\n \n                 ty::TyTrait(ref tr) => tr.principal.def_id().is_local(),\n "}, {"sha": "f4fea5542b3ded5bb9363e1d5ca3a073c08fb8c5", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 61, "deletions": 47, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2", "patch": "@@ -713,16 +713,18 @@ fn check_fn<'a, 'gcx, 'tcx>(inherited: &'a Inherited<'a, 'gcx, 'tcx>,\n     fcx\n }\n \n-pub fn check_struct(ccx: &CrateCtxt, id: ast::NodeId, span: Span) {\n-    let tcx = ccx.tcx;\n-\n-    check_representable(tcx, span, id, \"struct\");\n+fn check_struct(ccx: &CrateCtxt, id: ast::NodeId, span: Span) {\n+    check_representable(ccx.tcx, span, id);\n \n-    if tcx.lookup_simd(ccx.tcx.map.local_def_id(id)) {\n-        check_simd(tcx, span, id);\n+    if ccx.tcx.lookup_simd(ccx.tcx.map.local_def_id(id)) {\n+        check_simd(ccx.tcx, span, id);\n     }\n }\n \n+fn check_union(ccx: &CrateCtxt, id: ast::NodeId, span: Span) {\n+    check_representable(ccx.tcx, span, id);\n+}\n+\n pub fn check_item_type<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>, it: &'tcx hir::Item) {\n     debug!(\"check_item_type(it.id={}, it.name={})\",\n            it.id,\n@@ -762,6 +764,9 @@ pub fn check_item_type<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>, it: &'tcx hir::Item) {\n       hir::ItemStruct(..) => {\n         check_struct(ccx, it.id, it.span);\n       }\n+      hir::ItemUnion(..) => {\n+        check_union(ccx, it.id, it.span);\n+      }\n       hir::ItemTy(_, ref generics) => {\n         let pty_ty = ccx.tcx.node_id_to_type(it.id);\n         check_bounds_are_used(ccx, generics, pty_ty);\n@@ -1171,10 +1176,10 @@ fn check_const<'a, 'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n /// Checks whether a type can be represented in memory. In particular, it\n /// identifies types that contain themselves without indirection through a\n /// pointer, which would mean their size is unbounded.\n-pub fn check_representable<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                     sp: Span,\n-                                     item_id: ast::NodeId,\n-                                     _designation: &str) -> bool {\n+fn check_representable<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                 sp: Span,\n+                                 item_id: ast::NodeId)\n+                                 -> bool {\n     let rty = tcx.node_id_to_type(item_id);\n \n     // Check that it is possible to represent this type. This call identifies\n@@ -1274,7 +1279,7 @@ pub fn check_enum_variants<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n         disr_vals.push(current_disr_val);\n     }\n \n-    check_representable(ccx.tcx, sp, id, \"enum\");\n+    check_representable(ccx.tcx, sp, id);\n }\n \n impl<'a, 'gcx, 'tcx> AstConv<'gcx, 'tcx> for FnCtxt<'a, 'gcx, 'tcx> {\n@@ -2942,18 +2947,21 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         let mut private_candidate = None;\n         let mut autoderef = self.autoderef(expr.span, expr_t);\n         while let Some((base_t, autoderefs)) = autoderef.next() {\n-            if let ty::TyStruct(base_def, substs) = base_t.sty {\n-                debug!(\"struct named {:?}\",  base_t);\n-                if let Some(field) = base_def.struct_variant().find_field_named(field.node) {\n-                    let field_ty = self.field_ty(expr.span, field, substs);\n-                    if field.vis.is_accessible_from(self.body_id, &self.tcx().map) {\n-                        autoderef.finalize(lvalue_pref, Some(base));\n-                        self.write_ty(expr.id, field_ty);\n-                        self.write_autoderef_adjustment(base.id, autoderefs);\n-                        return;\n+            match base_t.sty {\n+                ty::TyStruct(base_def, substs) | ty::TyUnion(base_def, substs) => {\n+                    debug!(\"struct named {:?}\",  base_t);\n+                    if let Some(field) = base_def.struct_variant().find_field_named(field.node) {\n+                        let field_ty = self.field_ty(expr.span, field, substs);\n+                        if field.vis.is_accessible_from(self.body_id, &self.tcx().map) {\n+                            autoderef.finalize(lvalue_pref, Some(base));\n+                            self.write_ty(expr.id, field_ty);\n+                            self.write_autoderef_adjustment(base.id, autoderefs);\n+                            return;\n+                        }\n+                        private_candidate = Some((base_def.did, field_ty));\n                     }\n-                    private_candidate = Some((base_def.did, field_ty));\n                 }\n+                _ => {}\n             }\n         }\n         autoderef.unambiguous_final_ty();\n@@ -2986,12 +2994,15 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                          but no field with that name was found\",\n                         field.node, actual)\n             }, expr_t);\n-            if let ty::TyRawPtr(..) = expr_t.sty {\n-                err.note(&format!(\"`{0}` is a native pointer; perhaps you need to deref with \\\n-                                  `(*{0}).{1}`\", pprust::expr_to_string(base), field.node));\n-            }\n-            if let ty::TyStruct(def, _) = expr_t.sty {\n-                Self::suggest_field_names(&mut err, def.struct_variant(), field, vec![]);\n+            match expr_t.sty {\n+                ty::TyStruct(def, _) | ty::TyUnion(def, _) => {\n+                    Self::suggest_field_names(&mut err, def.struct_variant(), field, vec![]);\n+                }\n+                ty::TyRawPtr(..) => {\n+                    err.note(&format!(\"`{0}` is a native pointer; perhaps you need to deref with \\\n+                                      `(*{0}).{1}`\", pprust::expr_to_string(base), field.node));\n+                }\n+                _ => {}\n             }\n             err.emit();\n             self.write_error(expr.id);\n@@ -3098,17 +3109,18 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                             ty: Ty<'tcx>,\n                             variant: ty::VariantDef<'tcx>,\n                             field: &hir::Field,\n-                            skip_fields: &[hir::Field]) {\n+                            skip_fields: &[hir::Field],\n+                            kind_name: &str) {\n         let mut err = self.type_error_struct_with_diag(\n             field.name.span,\n             |actual| if let ty::TyEnum(..) = ty.sty {\n                 struct_span_err!(self.tcx.sess, field.name.span, E0559,\n-                                 \"struct variant `{}::{}` has no field named `{}`\",\n-                                 actual, variant.name.as_str(), field.name.node)\n+                                 \"{} `{}::{}` has no field named `{}`\",\n+                                 kind_name, actual, variant.name.as_str(), field.name.node)\n             } else {\n                 struct_span_err!(self.tcx.sess, field.name.span, E0560,\n-                                 \"structure `{}` has no field named `{}`\",\n-                                 actual, field.name.node)\n+                                 \"{} `{}` has no field named `{}`\",\n+                                 kind_name, actual, field.name.node)\n             },\n             ty);\n         // prevent all specified fields from being suggested\n@@ -3124,8 +3136,10 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                 ast_fields: &'gcx [hir::Field],\n                                 check_completeness: bool) {\n         let tcx = self.tcx;\n-        let substs = match adt_ty.sty {\n-            ty::TyStruct(_, substs) | ty::TyEnum(_, substs) => substs,\n+        let (substs, kind_name) = match adt_ty.sty {\n+            ty::TyEnum(_, substs) => (substs, \"variant\"),\n+            ty::TyStruct(_, substs) => (substs, \"struct\"),\n+            ty::TyUnion(_, substs) => (substs, \"union\"),\n             _ => span_bug!(span, \"non-ADT passed to check_expr_struct_fields\")\n         };\n \n@@ -3164,7 +3178,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n                     err.emit();\n                 } else {\n-                    self.report_unknown_field(adt_ty, variant, field, ast_fields);\n+                    self.report_unknown_field(adt_ty, variant, field, ast_fields, kind_name);\n                 }\n             }\n \n@@ -3173,11 +3187,12 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             self.check_expr_coercable_to_type(&field.expr, expected_field_type);\n         }\n \n-            // Make sure the programmer specified all the fields.\n-        if check_completeness &&\n-            !error_happened &&\n-            !remaining_fields.is_empty()\n-        {\n+        // Make sure the programmer specified correct number of fields.\n+        if kind_name == \"union\" {\n+            if ast_fields.len() != 1 {\n+                tcx.sess.span_err(span, \"union expressions should have exactly one field\");\n+            }\n+        } else if check_completeness && !error_happened && !remaining_fields.is_empty() {\n             span_err!(tcx.sess, span, E0063,\n                       \"missing field{} {} in initializer of `{}`\",\n                       if remaining_fields.len() == 1 {\"\"} else {\"s\"},\n@@ -3187,7 +3202,6 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                       .join(\", \"),\n                       adt_ty);\n         }\n-\n     }\n \n     fn check_struct_fields_on_error(&self,\n@@ -3217,15 +3231,14 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 self.set_tainted_by_errors();\n                 return None;\n             }\n-            Def::Variant(type_did, _) | Def::Struct(type_did) => {\n+            Def::Variant(type_did, _) | Def::Struct(type_did) | Def::Union(type_did) => {\n                 Some((type_did, self.tcx.expect_variant_def(def)))\n             }\n             Def::TyAlias(did) => {\n-                if let Some(&ty::TyStruct(adt, _)) = self.tcx.opt_lookup_item_type(did)\n-                                                             .map(|scheme| &scheme.ty.sty) {\n-                    Some((did, adt.struct_variant()))\n-                } else {\n-                    None\n+                match self.tcx.opt_lookup_item_type(did).map(|scheme| &scheme.ty.sty) {\n+                    Some(&ty::TyStruct(adt, _)) |\n+                    Some(&ty::TyUnion(adt, _)) => Some((did, adt.struct_variant())),\n+                    _ => None,\n                 }\n             }\n             _ => None\n@@ -4118,6 +4131,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         match def {\n             // Case 1 and 1b. Reference to a *type* or *enum variant*.\n             Def::Struct(def_id) |\n+            Def::Union(def_id) |\n             Def::Variant(_, def_id) |\n             Def::Enum(def_id) |\n             Def::TyAlias(def_id) |"}, {"sha": "7cc3be0a8906248c3f62ab7cb62f65d794d71cbb", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 19, "deletions": 14, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2", "patch": "@@ -136,14 +136,21 @@ impl<'ccx, 'gcx> CheckTypeWellFormedVisitor<'ccx, 'gcx> {\n                 self.check_item_type(item);\n             }\n             hir::ItemStruct(ref struct_def, ref ast_generics) => {\n-                self.check_type_defn(item, |fcx| {\n+                self.check_type_defn(item, false, |fcx| {\n+                    vec![fcx.struct_variant(struct_def)]\n+                });\n+\n+                self.check_variances_for_type_defn(item, ast_generics);\n+            }\n+            hir::ItemUnion(ref struct_def, ref ast_generics) => {\n+                self.check_type_defn(item, true, |fcx| {\n                     vec![fcx.struct_variant(struct_def)]\n                 });\n \n                 self.check_variances_for_type_defn(item, ast_generics);\n             }\n             hir::ItemEnum(ref enum_def, ref ast_generics) => {\n-                self.check_type_defn(item, |fcx| {\n+                self.check_type_defn(item, false, |fcx| {\n                     fcx.enum_variants(enum_def)\n                 });\n \n@@ -216,24 +223,22 @@ impl<'ccx, 'gcx> CheckTypeWellFormedVisitor<'ccx, 'gcx> {\n     }\n \n     /// In a type definition, we check that to ensure that the types of the fields are well-formed.\n-    fn check_type_defn<F>(&mut self, item: &hir::Item, mut lookup_fields: F) where\n-        F: for<'fcx, 'tcx> FnMut(&FnCtxt<'fcx, 'gcx, 'tcx>)\n-                                 -> Vec<AdtVariant<'tcx>>\n+    fn check_type_defn<F>(&mut self, item: &hir::Item, all_sized: bool, mut lookup_fields: F)\n+        where F: for<'fcx, 'tcx> FnMut(&FnCtxt<'fcx, 'gcx, 'tcx>) -> Vec<AdtVariant<'tcx>>\n     {\n         self.for_item(item).with_fcx(|fcx, this| {\n             let variants = lookup_fields(fcx);\n \n             for variant in &variants {\n                 // For DST, all intermediate types must be sized.\n-                if let Some((_, fields)) = variant.fields.split_last() {\n-                    for field in fields {\n-                        fcx.register_builtin_bound(\n-                            field.ty,\n-                            ty::BoundSized,\n-                            traits::ObligationCause::new(field.span,\n-                                                         fcx.body_id,\n-                                                         traits::FieldSized));\n-                    }\n+                let unsized_len = if all_sized || variant.fields.is_empty() { 0 } else { 1 };\n+                for field in &variant.fields[..variant.fields.len() - unsized_len] {\n+                    fcx.register_builtin_bound(\n+                        field.ty,\n+                        ty::BoundSized,\n+                        traits::ObligationCause::new(field.span,\n+                                                     fcx.body_id,\n+                                                     traits::FieldSized));\n                 }\n \n                 // All field types must be well-formed."}, {"sha": "fba145efa95078752161f76e0c2309ee91de19a0", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2", "patch": "@@ -24,7 +24,7 @@ use rustc::ty::{ImplOrTraitItemId, ConstTraitItemId};\n use rustc::ty::{MethodTraitItemId, TypeTraitItemId, ParameterEnvironment};\n use rustc::ty::{Ty, TyBool, TyChar, TyEnum, TyError};\n use rustc::ty::{TyParam, TyRawPtr};\n-use rustc::ty::{TyRef, TyStruct, TyTrait, TyNever, TyTuple};\n+use rustc::ty::{TyRef, TyStruct, TyUnion, TyTrait, TyNever, TyTuple};\n use rustc::ty::{TyStr, TyArray, TySlice, TyFloat, TyInfer, TyInt};\n use rustc::ty::{TyUint, TyClosure, TyBox, TyFnDef, TyFnPtr};\n use rustc::ty::{TyProjection, TyAnon};\n@@ -70,7 +70,8 @@ impl<'a, 'gcx, 'tcx> CoherenceChecker<'a, 'gcx, 'tcx> {\n     fn get_base_type_def_id(&self, span: Span, ty: Ty<'tcx>) -> Option<DefId> {\n         match ty.sty {\n             TyEnum(def, _) |\n-            TyStruct(def, _) => {\n+            TyStruct(def, _) |\n+            TyUnion(def, _) => {\n                 Some(def.did)\n             }\n \n@@ -241,7 +242,8 @@ impl<'a, 'gcx, 'tcx> CoherenceChecker<'a, 'gcx, 'tcx> {\n             let self_type = tcx.lookup_item_type(impl_did);\n             match self_type.ty.sty {\n                 ty::TyEnum(type_def, _) |\n-                ty::TyStruct(type_def, _) => {\n+                ty::TyStruct(type_def, _) |\n+                ty::TyUnion(type_def, _) => {\n                     type_def.set_destructor(method_def_id.def_id());\n                 }\n                 _ => {"}, {"sha": "4c38475335ce84b31c719a69b365c9c873b2854d", "filename": "src/librustc_typeck/coherence/orphan.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs?ref=d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2", "patch": "@@ -76,7 +76,8 @@ impl<'cx, 'tcx> OrphanChecker<'cx, 'tcx> {\n                 let self_ty = self.tcx.lookup_item_type(def_id).ty;\n                 match self_ty.sty {\n                     ty::TyEnum(def, _) |\n-                    ty::TyStruct(def, _) => {\n+                    ty::TyStruct(def, _) |\n+                    ty::TyUnion(def, _) => {\n                         self.check_def_id(item, def.did);\n                     }\n                     ty::TyTrait(ref data) => {\n@@ -293,7 +294,9 @@ impl<'cx, 'tcx> OrphanChecker<'cx, 'tcx> {\n                 {\n                     let self_ty = trait_ref.self_ty();\n                     let opt_self_def_id = match self_ty.sty {\n-                        ty::TyStruct(self_def, _) | ty::TyEnum(self_def, _) =>\n+                        ty::TyStruct(self_def, _) |\n+                        ty::TyUnion(self_def, _) |\n+                        ty::TyEnum(self_def, _) =>\n                             Some(self_def.did),\n                         ty::TyBox(..) =>\n                             self.tcx.lang_items.owned_box(),"}, {"sha": "c4d925372f18dcae7c0b2adfb1c5450464a1932d", "filename": "src/librustc_typeck/coherence/overlap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs?ref=d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2", "patch": "@@ -97,7 +97,7 @@ impl<'cx, 'tcx> OverlapChecker<'cx, 'tcx> {\n impl<'cx, 'tcx,'v> intravisit::Visitor<'v> for OverlapChecker<'cx, 'tcx> {\n     fn visit_item(&mut self, item: &'v hir::Item) {\n         match item.node {\n-            hir::ItemEnum(..) | hir::ItemStruct(..) => {\n+            hir::ItemEnum(..) | hir::ItemStruct(..) | hir::ItemUnion(..) => {\n                 let type_def_id = self.tcx.map.local_def_id(item.id);\n                 self.check_for_overlapping_inherent_impls(type_def_id);\n             }"}, {"sha": "31f28b3803d662a275ea33aedb0f72b0ac8d7de5", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 21, "deletions": 3, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2", "patch": "@@ -931,7 +931,8 @@ fn convert_item(ccx: &CrateCtxt, it: &hir::Item) {\n             tcx.trait_item_def_ids.borrow_mut().insert(ccx.tcx.map.local_def_id(it.id),\n                                                        trait_item_def_ids);\n         },\n-        hir::ItemStruct(ref struct_def, _) => {\n+        hir::ItemStruct(ref struct_def, _) |\n+        hir::ItemUnion(ref struct_def, _) => {\n             let def_id = ccx.tcx.map.local_def_id(it.id);\n             let scheme = type_scheme_of_def_id(ccx, def_id);\n             let predicates = predicates_of_item(ccx, it);\n@@ -1069,6 +1070,16 @@ fn convert_struct_def<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     adt\n }\n \n+fn convert_union_def<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n+                                it: &hir::Item,\n+                                def: &hir::VariantData)\n+                                -> ty::AdtDefMaster<'tcx>\n+{\n+    let did = ccx.tcx.map.local_def_id(it.id);\n+    let variants = vec![convert_struct_variant(ccx, did, it.name, ConstInt::Infer(0), def)];\n+    ccx.tcx.intern_adt_def(did, ty::AdtKind::Union, variants)\n+}\n+\n     fn evaluate_disr_expr(ccx: &CrateCtxt, repr_ty: attr::IntType, e: &hir::Expr)\n                           -> Option<ty::Disr> {\n         debug!(\"disr expr, checking {}\", pprust::expr_to_string(e));\n@@ -1439,7 +1450,8 @@ fn generics_of_def_id<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n \n                     ItemTy(_, ref generics) |\n                     ItemEnum(_, ref generics) |\n-                    ItemStruct(_, ref generics) => {\n+                    ItemStruct(_, ref generics) |\n+                    ItemUnion(_, ref generics) => {\n                         allow_defaults = true;\n                         generics\n                     }\n@@ -1576,6 +1588,11 @@ fn type_of_def_id<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                         let substs = mk_item_substs(&ccx.icx(generics), item.span, def_id);\n                         ccx.tcx.mk_struct(def, substs)\n                     }\n+                    ItemUnion(ref un, ref generics) => {\n+                        let def = convert_union_def(ccx, item, un);\n+                        let substs = mk_item_substs(&ccx.icx(generics), item.span, def_id);\n+                        ccx.tcx.mk_union(def, substs)\n+                    }\n                     ItemDefaultImpl(..) |\n                     ItemTrait(..) |\n                     ItemImpl(..) |\n@@ -1637,7 +1654,8 @@ fn predicates_of_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n         hir::ItemFn(_, _, _, _, ref generics, _) |\n         hir::ItemTy(_, ref generics) |\n         hir::ItemEnum(_, ref generics) |\n-        hir::ItemStruct(_, ref generics) => generics,\n+        hir::ItemStruct(_, ref generics) |\n+        hir::ItemUnion(_, ref generics) => generics,\n         _ => &no_generics\n     };\n "}, {"sha": "24eb29f45a5e5177ca3e1bafcf538f7563040425", "filename": "src/librustc_typeck/variance/constraints.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs?ref=d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2", "patch": "@@ -80,7 +80,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for ConstraintContext<'a, 'tcx> {\n         debug!(\"visit_item item={}\", tcx.map.node_to_string(item.id));\n \n         match item.node {\n-            hir::ItemEnum(..) | hir::ItemStruct(..) => {\n+            hir::ItemEnum(..) | hir::ItemStruct(..) | hir::ItemUnion(..) => {\n                 let scheme = tcx.lookup_item_type(did);\n \n                 // Not entirely obvious: constraints on structs/enums do not\n@@ -185,6 +185,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n                         hir::ItemTy(..) |\n                         hir::ItemEnum(..) |\n                         hir::ItemStruct(..) |\n+                        hir::ItemUnion(..) |\n                         hir::ItemTrait(..)   => is_inferred = true,\n                         hir::ItemFn(..)      => is_inferred = false,\n                         _                    => cannot_happen!(),\n@@ -344,7 +345,8 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n             }\n \n             ty::TyEnum(def, substs) |\n-            ty::TyStruct(def, substs) => {\n+            ty::TyStruct(def, substs) |\n+            ty::TyUnion(def, substs) => {\n                 let item_type = self.tcx().lookup_item_type(def.did);\n \n                 // This edge is actually implied by the call to"}, {"sha": "1238f7cbcb335cba4540b9100adc588a80c4c02b", "filename": "src/librustc_typeck/variance/terms.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustc_typeck%2Fvariance%2Fterms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustc_typeck%2Fvariance%2Fterms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fterms.rs?ref=d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2", "patch": "@@ -234,7 +234,8 @@ impl<'a, 'tcx, 'v> Visitor<'v> for TermsContext<'a, 'tcx> {\n \n         match item.node {\n             hir::ItemEnum(_, ref generics) |\n-            hir::ItemStruct(_, ref generics) => {\n+            hir::ItemStruct(_, ref generics) |\n+            hir::ItemUnion(_, ref generics) => {\n                 self.add_inferreds_for_item(item.id, false, generics);\n             }\n             hir::ItemTrait(_, ref generics, _, _) => {"}, {"sha": "b7e371e23f3237eebe145ab55a1f1d22955cb635", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2", "patch": "@@ -88,6 +88,11 @@ fn try_inline_def<'a, 'tcx>(cx: &DocContext, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             ret.extend(build_impls(cx, tcx, did));\n             clean::StructItem(build_struct(cx, tcx, did))\n         }\n+        Def::Union(did) => {\n+            record_extern_fqn(cx, did, clean::TypeUnion);\n+            ret.extend(build_impls(cx, tcx, did));\n+            clean::UnionItem(build_union(cx, tcx, did))\n+        }\n         Def::TyAlias(did) => {\n             record_extern_fqn(cx, did, clean::TypeTypedef);\n             ret.extend(build_impls(cx, tcx, did));\n@@ -214,6 +219,20 @@ fn build_struct<'a, 'tcx>(cx: &DocContext, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     }\n }\n \n+fn build_union<'a, 'tcx>(cx: &DocContext, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                          did: DefId) -> clean::Union {\n+    let t = tcx.lookup_item_type(did);\n+    let predicates = tcx.lookup_predicates(did);\n+    let variant = tcx.lookup_adt_def(did).struct_variant();\n+\n+    clean::Union {\n+        struct_type: doctree::Plain,\n+        generics: (t.generics, &predicates).clean(cx),\n+        fields: variant.fields.clean(cx),\n+        fields_stripped: false,\n+    }\n+}\n+\n fn build_type<'a, 'tcx>(cx: &DocContext, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                         did: DefId) -> clean::ItemEnum {\n     let t = tcx.lookup_item_type(did);"}, {"sha": "f8ec5a55e7d4c895d5a20ad1ef6aa8a9b4139242", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2", "patch": "@@ -321,6 +321,7 @@ impl Item {\n     pub fn has_stripped_fields(&self) -> Option<bool> {\n         match self.inner {\n             StructItem(ref _struct) => Some(_struct.fields_stripped),\n+            UnionItem(ref union) => Some(union.fields_stripped),\n             VariantItem(Variant { kind: StructVariant(ref vstruct)} ) => {\n                 Some(vstruct.fields_stripped)\n             },\n@@ -351,6 +352,7 @@ pub enum ItemEnum {\n     ExternCrateItem(String, Option<String>),\n     ImportItem(Import),\n     StructItem(Struct),\n+    UnionItem(Union),\n     EnumItem(Enum),\n     FunctionItem(Function),\n     ModuleItem(Module),\n@@ -414,6 +416,7 @@ impl Clean<Item> for doctree::Module {\n         items.extend(self.extern_crates.iter().map(|x| x.clean(cx)));\n         items.extend(self.imports.iter().flat_map(|x| x.clean(cx)));\n         items.extend(self.structs.iter().map(|x| x.clean(cx)));\n+        items.extend(self.unions.iter().map(|x| x.clean(cx)));\n         items.extend(self.enums.iter().map(|x| x.clean(cx)));\n         items.extend(self.fns.iter().map(|x| x.clean(cx)));\n         items.extend(self.foreigns.iter().flat_map(|x| x.clean(cx)));\n@@ -1464,6 +1467,7 @@ pub enum TypeKind {\n     TypeConst,\n     TypeStatic,\n     TypeStruct,\n+    TypeUnion,\n     TypeTrait,\n     TypeVariant,\n     TypeTypedef,\n@@ -1802,10 +1806,12 @@ impl<'tcx> Clean<Type> for ty::Ty<'tcx> {\n                 abi: fty.abi,\n             }),\n             ty::TyStruct(def, substs) |\n+            ty::TyUnion(def, substs) |\n             ty::TyEnum(def, substs) => {\n                 let did = def.did;\n                 let kind = match self.sty {\n                     ty::TyStruct(..) => TypeStruct,\n+                    ty::TyUnion(..) => TypeUnion,\n                     _ => TypeEnum,\n                 };\n                 inline::record_extern_fqn(cx, did, kind);\n@@ -1928,6 +1934,14 @@ pub struct Struct {\n     pub fields_stripped: bool,\n }\n \n+#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+pub struct Union {\n+    pub struct_type: doctree::StructType,\n+    pub generics: Generics,\n+    pub fields: Vec<Item>,\n+    pub fields_stripped: bool,\n+}\n+\n impl Clean<Item> for doctree::Struct {\n     fn clean(&self, cx: &DocContext) -> Item {\n         Item {\n@@ -1948,6 +1962,26 @@ impl Clean<Item> for doctree::Struct {\n     }\n }\n \n+impl Clean<Item> for doctree::Union {\n+    fn clean(&self, cx: &DocContext) -> Item {\n+        Item {\n+            name: Some(self.name.clean(cx)),\n+            attrs: self.attrs.clean(cx),\n+            source: self.whence.clean(cx),\n+            def_id: cx.map.local_def_id(self.id),\n+            visibility: self.vis.clean(cx),\n+            stability: self.stab.clean(cx),\n+            deprecation: self.depr.clean(cx),\n+            inner: UnionItem(Union {\n+                struct_type: self.struct_type,\n+                generics: self.generics.clean(cx),\n+                fields: self.fields.clean(cx),\n+                fields_stripped: false,\n+            }),\n+        }\n+    }\n+}\n+\n /// This is a more limited form of the standard Struct, different in that\n /// it lacks the things most items have (name, id, parameterization). Found\n /// only as a variant in an enum.\n@@ -2747,6 +2781,7 @@ fn register_def(cx: &DocContext, def: Def) -> DefId {\n         Def::Enum(i) => (i, TypeEnum),\n         Def::Trait(i) => (i, TypeTrait),\n         Def::Struct(i) => (i, TypeStruct),\n+        Def::Union(i) => (i, TypeUnion),\n         Def::Mod(i) => (i, TypeModule),\n         Def::Static(i, _) => (i, TypeStatic),\n         Def::Variant(i, _) => (i, TypeEnum),"}, {"sha": "cc62fcfa0aa8bdccc1e0bde42e5d0b1dd31e3a30", "filename": "src/librustdoc/doctree.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustdoc%2Fdoctree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustdoc%2Fdoctree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdoctree.rs?ref=d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2", "patch": "@@ -30,6 +30,7 @@ pub struct Module {\n     pub extern_crates: Vec<ExternCrate>,\n     pub imports: Vec<Import>,\n     pub structs: Vec<Struct>,\n+    pub unions: Vec<Union>,\n     pub enums: Vec<Enum>,\n     pub fns: Vec<Function>,\n     pub mods: Vec<Module>,\n@@ -62,6 +63,7 @@ impl Module {\n             extern_crates: Vec::new(),\n             imports    : Vec::new(),\n             structs    : Vec::new(),\n+            unions     : Vec::new(),\n             enums      : Vec::new(),\n             fns        : Vec::new(),\n             mods       : Vec::new(),\n@@ -108,6 +110,19 @@ pub struct Struct {\n     pub whence: Span,\n }\n \n+pub struct Union {\n+    pub vis: hir::Visibility,\n+    pub stab: Option<attr::Stability>,\n+    pub depr: Option<attr::Deprecation>,\n+    pub id: NodeId,\n+    pub struct_type: StructType,\n+    pub name: Name,\n+    pub generics: hir::Generics,\n+    pub attrs: hir::HirVec<ast::Attribute>,\n+    pub fields: hir::HirVec<hir::StructField>,\n+    pub whence: Span,\n+}\n+\n pub struct Enum {\n     pub vis: hir::Visibility,\n     pub stab: Option<attr::Stability>,"}, {"sha": "8d6ab221c4fcedc3952adb208b9e3faaff08daf6", "filename": "src/librustdoc/fold.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustdoc%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustdoc%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ffold.rs?ref=d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2", "patch": "@@ -49,6 +49,13 @@ pub trait DocFolder : Sized {\n                                      i.fields.iter().any(|f| f.is_stripped());\n                 StructItem(i)\n             },\n+            UnionItem(mut i) => {\n+                let num_fields = i.fields.len();\n+                i.fields = i.fields.into_iter().filter_map(|x| self.fold_item(x)).collect();\n+                i.fields_stripped |= num_fields != i.fields.len() ||\n+                                     i.fields.iter().any(|f| f.is_stripped());\n+                UnionItem(i)\n+            },\n             EnumItem(mut i) => {\n                 let num_variants = i.variants.len();\n                 i.variants = i.variants.into_iter().filter_map(|x| self.fold_item(x)).collect();"}, {"sha": "b93dc17dbdd7de51bae9cb8094088a7d4ba58b66", "filename": "src/librustdoc/html/item_type.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustdoc%2Fhtml%2Fitem_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustdoc%2Fhtml%2Fitem_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fitem_type.rs?ref=d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2", "patch": "@@ -40,6 +40,7 @@ pub enum ItemType {\n     AssociatedType  = 16,\n     Constant        = 17,\n     AssociatedConst = 18,\n+    Union           = 19,\n }\n \n \n@@ -62,6 +63,7 @@ impl<'a> From<&'a clean::Item> for ItemType {\n             clean::ExternCrateItem(..)     => ItemType::ExternCrate,\n             clean::ImportItem(..)          => ItemType::Import,\n             clean::StructItem(..)          => ItemType::Struct,\n+            clean::UnionItem(..)           => ItemType::Union,\n             clean::EnumItem(..)            => ItemType::Enum,\n             clean::FunctionItem(..)        => ItemType::Function,\n             clean::TypedefItem(..)         => ItemType::Typedef,\n@@ -89,6 +91,7 @@ impl From<clean::TypeKind> for ItemType {\n     fn from(kind: clean::TypeKind) -> ItemType {\n         match kind {\n             clean::TypeStruct   => ItemType::Struct,\n+            clean::TypeUnion    => ItemType::Union,\n             clean::TypeEnum     => ItemType::Enum,\n             clean::TypeFunction => ItemType::Function,\n             clean::TypeTrait    => ItemType::Trait,\n@@ -108,6 +111,7 @@ impl ItemType {\n             ItemType::ExternCrate     => \"externcrate\",\n             ItemType::Import          => \"import\",\n             ItemType::Struct          => \"struct\",\n+            ItemType::Union           => \"union\",\n             ItemType::Enum            => \"enum\",\n             ItemType::Function        => \"fn\",\n             ItemType::Typedef         => \"type\",\n@@ -129,6 +133,7 @@ impl ItemType {\n     pub fn name_space(&self) -> NameSpace {\n         match *self {\n             ItemType::Struct |\n+            ItemType::Union |\n             ItemType::Enum |\n             ItemType::Module |\n             ItemType::Typedef |"}, {"sha": "6f66ce88df7a5e44e2406b275ecd7b3d0727163b", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 76, "deletions": 3, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2", "patch": "@@ -1053,6 +1053,7 @@ impl DocFolder for Cache {\n                             // information if present.\n                             Some(&(ref fqp, ItemType::Trait)) |\n                             Some(&(ref fqp, ItemType::Struct)) |\n+                            Some(&(ref fqp, ItemType::Union)) |\n                             Some(&(ref fqp, ItemType::Enum)) =>\n                                 Some(&fqp[..fqp.len() - 1]),\n                             Some(..) => Some(&*self.stack),\n@@ -1106,7 +1107,8 @@ impl DocFolder for Cache {\n             clean::TypedefItem(..) | clean::TraitItem(..) |\n             clean::FunctionItem(..) | clean::ModuleItem(..) |\n             clean::ForeignFunctionItem(..) | clean::ForeignStaticItem(..) |\n-            clean::ConstantItem(..) | clean::StaticItem(..)\n+            clean::ConstantItem(..) | clean::StaticItem(..) |\n+            clean::UnionItem(..)\n             if !self.stripped_mod => {\n                 // Reexported items mean that the same id can show up twice\n                 // in the rustdoc ast that we're looking at. We know,\n@@ -1141,7 +1143,8 @@ impl DocFolder for Cache {\n         // Maintain the parent stack\n         let orig_parent_is_trait_impl = self.parent_is_trait_impl;\n         let parent_pushed = match item.inner {\n-            clean::TraitItem(..) | clean::EnumItem(..) | clean::StructItem(..) => {\n+            clean::TraitItem(..) | clean::EnumItem(..) |\n+            clean::StructItem(..) | clean::UnionItem(..) => {\n                 self.parent_stack.push(item.def_id);\n                 self.parent_is_trait_impl = false;\n                 true\n@@ -1557,6 +1560,7 @@ impl<'a> fmt::Display for Item<'a> {\n             clean::FunctionItem(..) => write!(fmt, \"Function \")?,\n             clean::TraitItem(..) => write!(fmt, \"Trait \")?,\n             clean::StructItem(..) => write!(fmt, \"Struct \")?,\n+            clean::UnionItem(..) => write!(fmt, \"Union \")?,\n             clean::EnumItem(..) => write!(fmt, \"Enum \")?,\n             clean::PrimitiveItem(..) => write!(fmt, \"Primitive Type \")?,\n             _ => {}\n@@ -1613,6 +1617,7 @@ impl<'a> fmt::Display for Item<'a> {\n                 item_function(fmt, self.cx, self.item, f),\n             clean::TraitItem(ref t) => item_trait(fmt, self.cx, self.item, t),\n             clean::StructItem(ref s) => item_struct(fmt, self.cx, self.item, s),\n+            clean::UnionItem(ref s) => item_union(fmt, self.cx, self.item, s),\n             clean::EnumItem(ref e) => item_enum(fmt, self.cx, self.item, e),\n             clean::TypedefItem(ref t, _) => item_typedef(fmt, self.cx, self.item, t),\n             clean::MacroItem(ref m) => item_macro(fmt, self.cx, self.item, m),\n@@ -1715,7 +1720,8 @@ fn item_module(w: &mut fmt::Formatter, cx: &Context,\n             ItemType::Trait           => 9,\n             ItemType::Function        => 10,\n             ItemType::Typedef         => 12,\n-            _                         => 13 + ty as u8,\n+            ItemType::Union           => 13,\n+            _                         => 14 + ty as u8,\n         }\n     }\n \n@@ -1759,6 +1765,7 @@ fn item_module(w: &mut fmt::Formatter, cx: &Context,\n                 ItemType::Import          => (\"reexports\", \"Reexports\"),\n                 ItemType::Module          => (\"modules\", \"Modules\"),\n                 ItemType::Struct          => (\"structs\", \"Structs\"),\n+                ItemType::Union           => (\"unions\", \"Unions\"),\n                 ItemType::Enum            => (\"enums\", \"Enums\"),\n                 ItemType::Function        => (\"functions\", \"Functions\"),\n                 ItemType::Typedef         => (\"types\", \"Type Definitions\"),\n@@ -2312,6 +2319,40 @@ fn item_struct(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n     render_assoc_items(w, cx, it, it.def_id, AssocItemRender::All)\n }\n \n+fn item_union(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n+               s: &clean::Union) -> fmt::Result {\n+    write!(w, \"<pre class='rust union'>\")?;\n+    render_attributes(w, it)?;\n+    render_union(w,\n+                 it,\n+                 Some(&s.generics),\n+                 &s.fields,\n+                 \"\",\n+                 true)?;\n+    write!(w, \"</pre>\")?;\n+\n+    document(w, cx, it)?;\n+    let mut fields = s.fields.iter().filter_map(|f| {\n+        match f.inner {\n+            clean::StructFieldItem(ref ty) => Some((f, ty)),\n+            _ => None,\n+        }\n+    }).peekable();\n+    if fields.peek().is_some() {\n+        write!(w, \"<h2 class='fields'>Fields</h2>\")?;\n+        for (field, ty) in fields {\n+            write!(w, \"<span id='{shortty}.{name}' class='{shortty}'><code>{name}: {ty}</code>\n+                       </span><span class='stab {stab}'></span>\",\n+                   shortty = ItemType::StructField,\n+                   stab = field.stability_class(),\n+                   name = field.name.as_ref().unwrap(),\n+                   ty = ty)?;\n+            document(w, cx, field)?;\n+        }\n+    }\n+    render_assoc_items(w, cx, it, it.def_id, AssocItemRender::All)\n+}\n+\n fn item_enum(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n              e: &clean::Enum) -> fmt::Result {\n     write!(w, \"<pre class='rust enum'>\")?;\n@@ -2514,6 +2555,38 @@ fn render_struct(w: &mut fmt::Formatter, it: &clean::Item,\n     Ok(())\n }\n \n+fn render_union(w: &mut fmt::Formatter, it: &clean::Item,\n+                g: Option<&clean::Generics>,\n+                fields: &[clean::Item],\n+                tab: &str,\n+                structhead: bool) -> fmt::Result {\n+    write!(w, \"{}{}{}\",\n+           VisSpace(&it.visibility),\n+           if structhead {\"union \"} else {\"\"},\n+           it.name.as_ref().unwrap())?;\n+    if let Some(g) = g {\n+        write!(w, \"{}\", g)?;\n+        write!(w, \"{}\", WhereClause(g))?;\n+    }\n+\n+    write!(w, \" {{\\n{}\", tab)?;\n+    for field in fields {\n+        if let clean::StructFieldItem(ref ty) = field.inner {\n+            write!(w, \"    {}{}: {},\\n{}\",\n+                   VisSpace(&field.visibility),\n+                   field.name.as_ref().unwrap(),\n+                   *ty,\n+                   tab)?;\n+        }\n+    }\n+\n+    if it.has_stripped_fields().unwrap() {\n+        write!(w, \"    // some fields omitted\\n{}\", tab)?;\n+    }\n+    write!(w, \"}}\")?;\n+    Ok(())\n+}\n+\n #[derive(Copy, Clone)]\n enum AssocItemLink<'a> {\n     Anchor(Option<&'a str>),"}, {"sha": "9bb7246e7a92e8ea1374ccc44a89fc777302ae35", "filename": "src/librustdoc/html/static/main.js", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "raw_url": "https://github.com/rust-lang/rust/raw/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js?ref=d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2", "patch": "@@ -34,7 +34,8 @@\n                      \"primitive\",\n                      \"associatedtype\",\n                      \"constant\",\n-                     \"associatedconstant\"];\n+                     \"associatedconstant\",\n+                     \"union\"];\n \n     // used for special search precedence\n     var TY_PRIMITIVE = itemTypes.indexOf(\"primitive\");"}, {"sha": "c60e22824965f97248cee5444111f0b20758c88d", "filename": "src/librustdoc/passes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustdoc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustdoc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses.rs?ref=d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2", "patch": "@@ -113,7 +113,7 @@ impl<'a> fold::DocFolder for Stripper<'a> {\n             clean::TraitItem(..) | clean::FunctionItem(..) |\n             clean::VariantItem(..) | clean::MethodItem(..) |\n             clean::ForeignFunctionItem(..) | clean::ForeignStaticItem(..) |\n-            clean::ConstantItem(..) => {\n+            clean::ConstantItem(..) | clean::UnionItem(..) => {\n                 if i.def_id.is_local() {\n                     if !self.access_levels.is_exported(i.def_id) {\n                         return None;"}, {"sha": "16a6e994b5a0b3c5bf4aa1033d3c064d00bd720d", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2", "patch": "@@ -108,6 +108,25 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n         }\n     }\n \n+    pub fn visit_union_data(&mut self, item: &hir::Item,\n+                            name: ast::Name, sd: &hir::VariantData,\n+                            generics: &hir::Generics) -> Union {\n+        debug!(\"Visiting union\");\n+        let struct_type = struct_type_from_def(&*sd);\n+        Union {\n+            id: item.id,\n+            struct_type: struct_type,\n+            name: name,\n+            vis: item.vis.clone(),\n+            stab: self.stability(item.id),\n+            depr: self.deprecation(item.id),\n+            attrs: item.attrs.clone(),\n+            generics: generics.clone(),\n+            fields: sd.fields().iter().cloned().collect(),\n+            whence: item.span\n+        }\n+    }\n+\n     pub fn visit_enum_def(&mut self, it: &hir::Item,\n                           name: ast::Name, def: &hir::EnumDef,\n                           params: &hir::Generics) -> Enum {\n@@ -258,6 +277,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n             match def {\n                 Def::Trait(did) |\n                 Def::Struct(did) |\n+                Def::Union(did) |\n                 Def::Enum(did) |\n                 Def::TyAlias(did) if !self_is_hidden => {\n                     self.cx.access_levels.borrow_mut().map.insert(did, AccessLevel::Public);\n@@ -365,6 +385,8 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                 om.enums.push(self.visit_enum_def(item, name, ed, gen)),\n             hir::ItemStruct(ref sd, ref gen) =>\n                 om.structs.push(self.visit_variant_data(item, name, sd, gen)),\n+            hir::ItemUnion(ref sd, ref gen) =>\n+                om.unions.push(self.visit_union_data(item, name, sd, gen)),\n             hir::ItemFn(ref fd, ref unsafety, constness, ref abi, ref gen, _) =>\n                 om.fns.push(self.visit_fn(item, name, &**fd, unsafety,\n                                           constness, abi, gen)),"}, {"sha": "3af030706b739ba647a8f519c45445c91c8bedb1", "filename": "src/librustdoc/visit_lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustdoc%2Fvisit_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibrustdoc%2Fvisit_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_lib.rs?ref=d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2", "patch": "@@ -73,6 +73,7 @@ impl<'a, 'b, 'tcx> LibEmbargoVisitor<'a, 'b, 'tcx> {\n                     Def::ForeignMod(did) |\n                     Def::Trait(did) |\n                     Def::Struct(did) |\n+                    Def::Union(did) |\n                     Def::Enum(did) |\n                     Def::TyAlias(did) |\n                     Def::Fn(did) |"}, {"sha": "4394fb0e1431263d64e2e04134fdfaa45263d811", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2", "patch": "@@ -1886,7 +1886,7 @@ pub enum ItemKind {\n     /// A union definition (`union` or `pub union`).\n     ///\n     /// E.g. `union Foo<A, B> { x: A, y: B }`\n-    Union(VariantData, Generics), // FIXME: not yet implemented\n+    Union(VariantData, Generics),\n     /// A Trait declaration (`trait` or `pub trait`).\n     ///\n     /// E.g. `trait Foo { .. }` or `trait Foo<T> { .. }`"}, {"sha": "287d33cc3e5b23b56a7f23b7b9656206ed162551", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2", "patch": "@@ -292,6 +292,9 @@ declare_features! (\n \n     // Macros 1.1\n     (active, rustc_macro, \"1.13.0\", Some(35900)),\n+\n+    // Allows untagged unions `union U { ... }`\n+    (active, untagged_unions, \"1.13.0\", Some(32836)),\n );\n \n declare_features! (\n@@ -953,6 +956,12 @@ impl<'a> Visitor for PostExpansionVisitor<'a> {\n                 }\n             }\n \n+            ast::ItemKind::Union(..) => {\n+                gate_feature_post!(&self, untagged_unions,\n+                                   i.span,\n+                                   \"unions are unstable and possibly buggy\");\n+            }\n+\n             ast::ItemKind::DefaultImpl(..) => {\n                 gate_feature_post!(&self, optin_builtin_traits,\n                                    i.span,"}, {"sha": "ec9dc1bae5ad9061f0ac2e643a87885c914f0add", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2", "patch": "@@ -5102,6 +5102,25 @@ impl<'a> Parser<'a> {\n         Ok((class_name, ItemKind::Struct(vdata, generics), None))\n     }\n \n+    /// Parse union Foo { ... }\n+    fn parse_item_union(&mut self) -> PResult<'a, ItemInfo> {\n+        let class_name = self.parse_ident()?;\n+        let mut generics = self.parse_generics()?;\n+\n+        let vdata = if self.token.is_keyword(keywords::Where) {\n+            generics.where_clause = self.parse_where_clause()?;\n+            VariantData::Struct(self.parse_record_struct_body()?, ast::DUMMY_NODE_ID)\n+        } else if self.token == token::OpenDelim(token::Brace) {\n+            VariantData::Struct(self.parse_record_struct_body()?, ast::DUMMY_NODE_ID)\n+        } else {\n+            let token_str = self.this_token_to_string();\n+            return Err(self.fatal(&format!(\"expected `where` or `{{` after union \\\n+                                            name, found `{}`\", token_str)))\n+        };\n+\n+        Ok((class_name, ItemKind::Union(vdata, generics), None))\n+    }\n+\n     pub fn parse_record_struct_body(&mut self) -> PResult<'a, Vec<StructField>> {\n         let mut fields = Vec::new();\n         if self.eat(&token::OpenDelim(token::Brace)) {\n@@ -5938,6 +5957,20 @@ impl<'a> Parser<'a> {\n                                     maybe_append(attrs, extra_attrs));\n             return Ok(Some(item));\n         }\n+        if self.check_keyword(keywords::Union) &&\n+                self.look_ahead(1, |t| t.is_ident() && !t.is_any_keyword()) {\n+            // UNION ITEM\n+            self.bump();\n+            let (ident, item_, extra_attrs) = self.parse_item_union()?;\n+            let last_span = self.last_span;\n+            let item = self.mk_item(lo,\n+                                    last_span.hi,\n+                                    ident,\n+                                    item_,\n+                                    visibility,\n+                                    maybe_append(attrs, extra_attrs));\n+            return Ok(Some(item));\n+        }\n         self.parse_macro_use_or_failure(attrs,macros_allowed,attributes_allowed,lo,visibility)\n     }\n "}, {"sha": "b37d53329839957b418b7dce11971792c73627f3", "filename": "src/libsyntax_ext/deriving/generic/mod.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs?ref=d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2", "patch": "@@ -410,9 +410,18 @@ impl<'a> TraitDef<'a> {\n                     ast::ItemKind::Enum(ref enum_def, ref generics) => {\n                         self.expand_enum_def(cx, enum_def, &item.attrs, item.ident, generics)\n                     }\n+                    ast::ItemKind::Union(ref struct_def, ref generics) => {\n+                        if self.supports_unions {\n+                            self.expand_struct_def(cx, &struct_def, item.ident, generics)\n+                        } else {\n+                            cx.span_err(mitem.span,\n+                                        \"this trait cannot be derived for unions\");\n+                            return;\n+                        }\n+                    }\n                     _ => {\n                         cx.span_err(mitem.span,\n-                                    \"`derive` may only be applied to structs and enums\");\n+                                    \"`derive` may only be applied to structs, enums and unions\");\n                         return;\n                     }\n                 };"}, {"sha": "7a04d377608d4ac2627230461d2e20ce41d7c623", "filename": "src/rt/rust_test_helpers.c", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Frt%2Frust_test_helpers.c", "raw_url": "https://github.com/rust-lang/rust/raw/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Frt%2Frust_test_helpers.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_test_helpers.c?ref=d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2", "patch": "@@ -247,3 +247,24 @@ double rust_interesting_average(uint64_t n, ...) {\n int32_t rust_int8_to_int32(int8_t x) {\n     return (int32_t)x;\n }\n+\n+typedef union LARGE_INTEGER {\n+  struct {\n+    uint32_t LowPart;\n+    uint32_t HighPart;\n+  };\n+  struct {\n+    uint32_t LowPart;\n+    uint32_t HighPart;\n+  } u;\n+  uint64_t QuadPart;\n+} LARGE_INTEGER;\n+\n+LARGE_INTEGER increment_all_parts(LARGE_INTEGER li) {\n+    li.LowPart += 1;\n+    li.HighPart += 1;\n+    li.u.LowPart += 1;\n+    li.u.HighPart += 1;\n+    li.QuadPart += 1;\n+    return li;\n+}"}, {"sha": "b07d3e2f9067597ffa9f508df7b9c712bf364817", "filename": "src/test/compile-fail/attr-usage-repr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Ftest%2Fcompile-fail%2Fattr-usage-repr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Ftest%2Fcompile-fail%2Fattr-usage-repr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fattr-usage-repr.rs?ref=d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2", "patch": "@@ -11,7 +11,7 @@\n #![allow(dead_code)]\n #![feature(repr_simd)]\n \n-#[repr(C)] //~ ERROR: attribute should be applied to struct or enum\n+#[repr(C)] //~ ERROR: attribute should be applied to struct, enum or union\n fn f() {}\n \n #[repr(C)]"}, {"sha": "19975d79b60be3fae35df9a0e02ac06179bffcc6", "filename": "src/test/compile-fail/borrowck/borrowck-union-borrow-nested.rs", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-union-borrow-nested.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-union-borrow-nested.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-union-borrow-nested.rs?ref=d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2", "patch": "@@ -0,0 +1,44 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-tidy-linelength\n+\n+#![feature(untagged_unions)]\n+\n+#[derive(Clone, Copy)]\n+struct S {\n+    a: u8,\n+    b: u16,\n+}\n+\n+union U {\n+    s: S,\n+    c: u32,\n+}\n+\n+impl Clone for U {\n+    fn clone(&self) -> Self { *self }\n+}\n+impl Copy for U {}\n+\n+fn main() {\n+    unsafe {\n+        {\n+            let mut u = U { s: S { a: 0, b: 1 } };\n+            let ra = &mut u.s.a;\n+            let b = u.s.b; // OK\n+        }\n+        {\n+            let mut u = U { s: S { a: 0, b: 1 } };\n+            let ra = &mut u.s.a;\n+            let b = u.c; //~ ERROR cannot use `u.c` because it was mutably borrowed\n+        }\n+    }\n+}"}, {"sha": "e8989a3c2d4998b733199b580fe9c6a8e84b6b80", "filename": "src/test/compile-fail/borrowck/borrowck-union-borrow.rs", "status": "added", "additions": 97, "deletions": 0, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-union-borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-union-borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-union-borrow.rs?ref=d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2", "patch": "@@ -0,0 +1,97 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-tidy-linelength\n+\n+#![feature(untagged_unions)]\n+\n+union U {\n+    a: u8,\n+    b: u64,\n+}\n+\n+impl Clone for U {\n+    fn clone(&self) -> Self { *self }\n+}\n+impl Copy for U {}\n+\n+fn main() {\n+    unsafe {\n+        let mut u = U { b: 0 };\n+        // Imm borrow, same field\n+        {\n+            let ra = &u.a;\n+            let ra2 = &u.a; // OK\n+        }\n+        {\n+            let ra = &u.a;\n+            let a = u.a; // OK\n+        }\n+        {\n+            let ra = &u.a;\n+            let rma = &mut u.a; //~ ERROR cannot borrow `u.a` as mutable because it is also borrowed as immutable\n+        }\n+        {\n+            let ra = &u.a;\n+            u.a = 1; //~ ERROR cannot assign to `u.a` because it is borrowed\n+        }\n+        // Imm borrow, other field\n+        {\n+            let ra = &u.a;\n+            let rb = &u.b; // OK\n+        }\n+        {\n+            let ra = &u.a;\n+            let b = u.b; // OK\n+        }\n+        {\n+            let ra = &u.a;\n+            let rmb = &mut u.b; //~ ERROR cannot borrow `u` (via `u.b`) as mutable because `u` is also borrowed as immutable (via `u.a`)\n+        }\n+        {\n+            let ra = &u.a;\n+            u.b = 1; //~ ERROR cannot assign to `u.b` because it is borrowed\n+        }\n+        // Mut borrow, same field\n+        {\n+            let rma = &mut u.a;\n+            let ra = &u.a; //~ ERROR cannot borrow `u.a` as immutable because it is also borrowed as mutable\n+        }\n+        {\n+            let ra = &mut u.a;\n+            let a = u.a; //~ ERROR cannot use `u.a` because it was mutably borrowed\n+        }\n+        {\n+            let rma = &mut u.a;\n+            let rma2 = &mut u.a; //~ ERROR cannot borrow `u.a` as mutable more than once at a time\n+        }\n+        {\n+            let rma = &mut u.a;\n+            u.a = 1; //~ ERROR cannot assign to `u.a` because it is borrowed\n+        }\n+        // Mut borrow, other field\n+        {\n+            let rma = &mut u.a;\n+            let rb = &u.b; //~ ERROR cannot borrow `u` (via `u.b`) as immutable because `u` is also borrowed as mutable (via `u.a`)\n+        }\n+        {\n+            let ra = &mut u.a;\n+            let b = u.b; //~ ERROR cannot use `u.b` because it was mutably borrowed\n+        }\n+        {\n+            let rma = &mut u.a;\n+            let rmb2 = &mut u.b; //~ ERROR cannot borrow `u` (via `u.b`) as mutable more than once at a time\n+        }\n+        {\n+            let rma = &mut u.a;\n+            u.b = 1; //~ ERROR cannot assign to `u.b` because it is borrowed\n+        }\n+    }\n+}"}, {"sha": "d4d7bc6b0f7c5c5a038d2a14635b80a446cdcb24", "filename": "src/test/compile-fail/borrowck/borrowck-union-move-assign.rs", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-union-move-assign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-union-move-assign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-union-move-assign.rs?ref=d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2", "patch": "@@ -0,0 +1,42 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(untagged_unions)]\n+\n+// Non-copy\n+struct A;\n+struct B;\n+\n+union U {\n+    a: A,\n+    b: B,\n+}\n+\n+fn main() {\n+    unsafe {\n+        {\n+            let mut u = U { a: A };\n+            let a = u.a;\n+            let a = u.a; //~ ERROR use of moved value: `u.a`\n+        }\n+        {\n+            let mut u = U { a: A };\n+            let a = u.a;\n+            u.a = A;\n+            let a = u.a; // OK\n+        }\n+        {\n+            let mut u = U { a: A };\n+            let a = u.a;\n+            u.b = B;\n+            let a = u.a; // OK\n+        }\n+    }\n+}"}, {"sha": "5320244cf43b3576a286f28a22a42606012f176e", "filename": "src/test/compile-fail/borrowck/borrowck-union-move.rs", "status": "added", "additions": 96, "deletions": 0, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-union-move.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-union-move.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-union-move.rs?ref=d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2", "patch": "@@ -0,0 +1,96 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(untagged_unions)]\n+\n+#[derive(Clone, Copy)]\n+struct Copy;\n+struct NonCopy;\n+\n+union Unn {\n+    n1: NonCopy,\n+    n2: NonCopy,\n+}\n+union Ucc {\n+    c1: Copy,\n+    c2: Copy,\n+}\n+union Ucn {\n+    c: Copy,\n+    n: NonCopy,\n+}\n+\n+fn main() {\n+    unsafe {\n+        // 2 NonCopy\n+        {\n+            let mut u = Unn { n1: NonCopy };\n+            let a = u.n1;\n+            let a = u.n1; //~ ERROR use of moved value: `u.n1`\n+        }\n+        {\n+            let mut u = Unn { n1: NonCopy };\n+            let a = u.n1;\n+            let a = u; //~ ERROR use of partially moved value: `u`\n+        }\n+        {\n+            let mut u = Unn { n1: NonCopy };\n+            let a = u.n1;\n+            let a = u.n2; //~ ERROR use of moved value: `u.n2`\n+        }\n+        // 2 Copy\n+        {\n+            let mut u = Ucc { c1: Copy };\n+            let a = u.c1;\n+            let a = u.c1; // OK\n+        }\n+        {\n+            let mut u = Ucc { c1: Copy };\n+            let a = u.c1;\n+            let a = u; // OK\n+        }\n+        {\n+            let mut u = Ucc { c1: Copy };\n+            let a = u.c1;\n+            let a = u.c2; // OK\n+        }\n+        // 1 Copy, 1 NonCopy\n+        {\n+            let mut u = Ucn { c: Copy };\n+            let a = u.c;\n+            let a = u.c; // OK\n+        }\n+        {\n+            let mut u = Ucn { c: Copy };\n+            let a = u.n;\n+            let a = u.n; //~ ERROR use of moved value: `u.n`\n+        }\n+        {\n+            let mut u = Ucn { c: Copy };\n+            let a = u.n;\n+            let a = u.c; //~ ERROR use of moved value: `u.c`\n+        }\n+        {\n+            let mut u = Ucn { c: Copy };\n+            let a = u.c;\n+            let a = u.n; // OK\n+        }\n+        {\n+            let mut u = Ucn { c: Copy };\n+            let a = u.c;\n+            let a = u; // OK\n+        }\n+        {\n+            let mut u = Ucn { c: Copy };\n+            let a = u.n;\n+            let a = u; //~ ERROR use of partially moved value: `u`\n+        }\n+    }\n+}"}, {"sha": "36e062f8464e9962a0024a5555ac0b468f2496ec", "filename": "src/test/compile-fail/borrowck/borrowck-union-uninitialized.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-union-uninitialized.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-union-uninitialized.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-union-uninitialized.rs?ref=d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2", "patch": "@@ -0,0 +1,30 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(untagged_unions)]\n+\n+struct S {\n+    a: u8,\n+}\n+\n+union U {\n+    a: u8,\n+}\n+\n+fn main() {\n+    unsafe {\n+        let mut s: S;\n+        let mut u: U;\n+        s.a = 0;\n+        u.a = 0;\n+        let sa = s.a; //~ ERROR use of possibly uninitialized variable: `s.a`\n+        let ua = u.a; //~ ERROR use of possibly uninitialized variable: `u.a`\n+    }\n+}"}, {"sha": "84dd22435b888934da6eaa10c1eeef6be4309067", "filename": "src/test/compile-fail/deriving-non-type.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Ftest%2Fcompile-fail%2Fderiving-non-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Ftest%2Fcompile-fail%2Fderiving-non-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fderiving-non-type.rs?ref=d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2", "patch": "@@ -12,29 +12,29 @@\n \n struct S;\n \n-#[derive(PartialEq)] //~ ERROR: `derive` may only be applied to structs and enums\n+#[derive(PartialEq)] //~ ERROR: `derive` may only be applied to structs, enums and unions\n trait T { }\n \n-#[derive(PartialEq)] //~ ERROR: `derive` may only be applied to structs and enums\n+#[derive(PartialEq)] //~ ERROR: `derive` may only be applied to structs, enums and unions\n impl S { }\n \n-#[derive(PartialEq)] //~ ERROR: `derive` may only be applied to structs and enums\n+#[derive(PartialEq)] //~ ERROR: `derive` may only be applied to structs, enums and unions\n impl T for S { }\n \n-#[derive(PartialEq)] //~ ERROR: `derive` may only be applied to structs and enums\n+#[derive(PartialEq)] //~ ERROR: `derive` may only be applied to structs, enums and unions\n static s: usize = 0;\n \n-#[derive(PartialEq)] //~ ERROR: `derive` may only be applied to structs and enums\n+#[derive(PartialEq)] //~ ERROR: `derive` may only be applied to structs, enums and unions\n const c: usize = 0;\n \n-#[derive(PartialEq)] //~ ERROR: `derive` may only be applied to structs and enums\n+#[derive(PartialEq)] //~ ERROR: `derive` may only be applied to structs, enums and unions\n mod m { }\n \n-#[derive(PartialEq)] //~ ERROR: `derive` may only be applied to structs and enums\n+#[derive(PartialEq)] //~ ERROR: `derive` may only be applied to structs, enums and unions\n extern \"C\" { }\n \n-#[derive(PartialEq)] //~ ERROR: `derive` may only be applied to structs and enums\n+#[derive(PartialEq)] //~ ERROR: `derive` may only be applied to structs, enums and unions\n type A = usize;\n \n-#[derive(PartialEq)] //~ ERROR: `derive` may only be applied to structs and enums\n+#[derive(PartialEq)] //~ ERROR: `derive` may only be applied to structs, enums and unions\n fn main() { }"}, {"sha": "d5f1614c14d2d0d8b1bfe7d73f6228159d885c9a", "filename": "src/test/compile-fail/issue-17800.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Ftest%2Fcompile-fail%2Fissue-17800.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Ftest%2Fcompile-fail%2Fissue-17800.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-17800.rs?ref=d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2", "patch": "@@ -18,7 +18,7 @@ enum MyOption<T> {\n fn main() {\n     match MyOption::MySome(42) {\n         MyOption::MySome { x: 42 } => (),\n-        //~^ ERROR struct `MyOption::MySome` does not have a field named `x`\n+        //~^ ERROR variant `MyOption::MySome` does not have a field named `x`\n         //~| ERROR pattern does not mention field `0`\n         _ => (),\n     }"}, {"sha": "a8350fe0986c044c4241a01aef05f53d78022bc9", "filename": "src/test/compile-fail/issue-19922.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Ftest%2Fcompile-fail%2Fissue-19922.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Ftest%2Fcompile-fail%2Fissue-19922.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-19922.rs?ref=d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2", "patch": "@@ -14,5 +14,5 @@ enum Homura {\n \n fn main() {\n     let homura = Homura::Akemi { kaname: () };\n-    //~^ ERROR struct variant `Homura::Akemi` has no field named `kaname`\n+    //~^ ERROR variant `Homura::Akemi` has no field named `kaname`\n }"}, {"sha": "7f73d9076ec99eec8ec4665a1c16b7dc54843de0", "filename": "src/test/compile-fail/issue-31769.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Ftest%2Fcompile-fail%2Fissue-31769.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Ftest%2Fcompile-fail%2Fissue-31769.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-31769.rs?ref=d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2", "patch": "@@ -10,5 +10,5 @@\n \n fn main() {\n     #[inline] struct Foo;  //~ ERROR attribute should be applied to function\n-    #[repr(C)] fn foo() {} //~ ERROR attribute should be applied to struct or enum\n+    #[repr(C)] fn foo() {} //~ ERROR attribute should be applied to struct, enum or union\n }"}, {"sha": "c93e75042dd1752c352cb4d88265baae9405afba", "filename": "src/test/compile-fail/issue-4736.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Ftest%2Fcompile-fail%2Fissue-4736.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Ftest%2Fcompile-fail%2Fissue-4736.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-4736.rs?ref=d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2", "patch": "@@ -13,5 +13,5 @@\n struct NonCopyable(());\n \n fn main() {\n-    let z = NonCopyable{ p: () }; //~ ERROR structure `NonCopyable` has no field named `p`\n+    let z = NonCopyable{ p: () }; //~ ERROR struct `NonCopyable` has no field named `p`\n }"}, {"sha": "c4aff9471b8a108573a0736cbe3c7d79052c1245", "filename": "src/test/compile-fail/numeric-fields.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Ftest%2Fcompile-fail%2Fnumeric-fields.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Ftest%2Fcompile-fail%2Fnumeric-fields.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnumeric-fields.rs?ref=d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2", "patch": "@@ -13,7 +13,7 @@\n struct S(u8, u16);\n \n fn main() {\n-    let s = S{0b1: 10, 0: 11}; //~ ERROR structure `S` has no field named `0b1`\n+    let s = S{0b1: 10, 0: 11}; //~ ERROR struct `S` has no field named `0b1`\n     match s {\n         S{0: a, 0x1: b, ..} => {} //~ ERROR does not have a field named `0x1`\n     }"}, {"sha": "4924fabafb0a0ee465be0c1991e26e3436b0e54c", "filename": "src/test/compile-fail/privacy/union-field-privacy-1.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Ftest%2Fcompile-fail%2Fprivacy%2Funion-field-privacy-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Ftest%2Fcompile-fail%2Fprivacy%2Funion-field-privacy-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fprivacy%2Funion-field-privacy-1.rs?ref=d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2", "patch": "@@ -0,0 +1,30 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(pub_restricted)]\n+#![feature(untagged_unions)]\n+\n+mod m {\n+    pub union U {\n+        pub a: u8,\n+        pub(super) b: u8,\n+        c: u8,\n+    }\n+}\n+\n+fn main() {\n+    let u = m::U { a: 0 }; // OK\n+    let u = m::U { b: 0 }; // OK\n+    let u = m::U { c: 0 }; //~ ERROR field `c` of union `m::U` is private\n+\n+    let m::U { a } = u; // OK\n+    let m::U { b } = u; // OK\n+    let m::U { c } = u; //~ ERROR field `c` of union `m::U` is private\n+}"}, {"sha": "7151538f412568893dfab75a11a1636c594ac923", "filename": "src/test/compile-fail/privacy/union-field-privacy-2.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Ftest%2Fcompile-fail%2Fprivacy%2Funion-field-privacy-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Ftest%2Fcompile-fail%2Fprivacy%2Funion-field-privacy-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fprivacy%2Funion-field-privacy-2.rs?ref=d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2", "patch": "@@ -0,0 +1,28 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(pub_restricted)]\n+#![feature(untagged_unions)]\n+\n+mod m {\n+    pub union U {\n+        pub a: u8,\n+        pub(super) b: u8,\n+        c: u8,\n+    }\n+}\n+\n+fn main() {\n+    let u = m::U { a: 10 };\n+\n+    let a = u.a; // OK\n+    let b = u.b; // OK\n+    let c = u.c; //~ ERROR field `c` of struct `m::U` is private\n+}"}, {"sha": "5f1f8ca856f9c7fff0698bbadbdca46f1d6b2f94", "filename": "src/test/compile-fail/struct-fields-hints-no-dupe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Ftest%2Fcompile-fail%2Fstruct-fields-hints-no-dupe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Ftest%2Fcompile-fail%2Fstruct-fields-hints-no-dupe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fstruct-fields-hints-no-dupe.rs?ref=d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2", "patch": "@@ -17,7 +17,7 @@ struct A {\n fn main() {\n     let a = A {\n         foo : 5,\n-        bar : 42,//~ ERROR structure `A` has no field named `bar`\n+        bar : 42,//~ ERROR struct `A` has no field named `bar`\n         //~^ HELP did you mean `barr`?\n         car : 9,\n     };"}, {"sha": "4ba1fd2f7bb33de6a946f77c1ca7018ff6ac5654", "filename": "src/test/compile-fail/struct-fields-hints.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Ftest%2Fcompile-fail%2Fstruct-fields-hints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Ftest%2Fcompile-fail%2Fstruct-fields-hints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fstruct-fields-hints.rs?ref=d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2", "patch": "@@ -17,7 +17,7 @@ struct A {\n fn main() {\n     let a = A {\n         foo : 5,\n-        bar : 42,//~ ERROR structure `A` has no field named `bar`\n+        bar : 42,//~ ERROR struct `A` has no field named `bar`\n         //~^ HELP did you mean `car`?\n     };\n }"}, {"sha": "5d16573f2f1e3e373070389e4ef589c55d56f5c4", "filename": "src/test/compile-fail/struct-fields-too-many.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Ftest%2Fcompile-fail%2Fstruct-fields-too-many.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Ftest%2Fcompile-fail%2Fstruct-fields-too-many.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fstruct-fields-too-many.rs?ref=d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2", "patch": "@@ -15,6 +15,6 @@ struct BuildData {\n fn main() {\n     let foo = BuildData {\n         foo: 0,\n-        bar: 0 //~ ERROR structure `BuildData` has no field named `bar`\n+        bar: 0 //~ ERROR struct `BuildData` has no field named `bar`\n     };\n }"}, {"sha": "41bd00a518c5c01caab4d4242fdf1911624b6f8b", "filename": "src/test/compile-fail/suggest-private-fields.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Ftest%2Fcompile-fail%2Fsuggest-private-fields.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Ftest%2Fcompile-fail%2Fsuggest-private-fields.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fsuggest-private-fields.rs?ref=d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2", "patch": "@@ -22,16 +22,16 @@ struct A {\n fn main () {\n     // external crate struct\n     let k = B {\n-        aa: 20, //~ ERROR structure `xc::B` has no field named `aa`\n+        aa: 20, //~ ERROR struct `xc::B` has no field named `aa`\n         //~^ HELP did you mean `a`?\n-        bb: 20, //~ ERROR structure `xc::B` has no field named `bb`\n+        bb: 20, //~ ERROR struct `xc::B` has no field named `bb`\n         //~^ HELP did you mean `a`?\n     };\n     // local crate struct\n     let l = A {\n-        aa: 20, //~ ERROR structure `A` has no field named `aa`\n+        aa: 20, //~ ERROR struct `A` has no field named `aa`\n         //~^ HELP did you mean `a`?\n-        bb: 20, //~ ERROR structure `A` has no field named `bb`\n+        bb: 20, //~ ERROR struct `A` has no field named `bb`\n         //~^ HELP did you mean `b`?\n     };\n }"}, {"sha": "b2bf173c59c8667dd1363d5f036a6374b8cf2f26", "filename": "src/test/compile-fail/union/union-const-eval.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Ftest%2Fcompile-fail%2Funion%2Funion-const-eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Ftest%2Fcompile-fail%2Funion%2Funion-const-eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funion%2Funion-const-eval.rs?ref=d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2", "patch": "@@ -0,0 +1,26 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(untagged_unions)]\n+\n+union U {\n+    a: usize,\n+    b: usize,\n+}\n+\n+const C: U = U { a: 10 };\n+\n+fn main() {\n+    unsafe {\n+        let a: [u8; C.a]; // OK\n+        let b: [u8; C.b]; //~ ERROR constant evaluation error\n+                          //~^ NOTE nonexistent struct field\n+    }\n+}"}, {"sha": "3d168980ed246b957bb7804ecca23989f555d6d7", "filename": "src/test/compile-fail/union/union-const-pat.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Ftest%2Fcompile-fail%2Funion%2Funion-const-pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Ftest%2Fcompile-fail%2Funion%2Funion-const-pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funion%2Funion-const-pat.rs?ref=d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2", "patch": "@@ -0,0 +1,25 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(untagged_unions)]\n+\n+union U {\n+    a: usize,\n+    b: usize,\n+}\n+\n+const C: U = U { a: 10 };\n+\n+fn main() {\n+    match C {\n+        C => {} //~ ERROR cannot use unions in constant patterns\n+        _ => {}\n+    }\n+}"}, {"sha": "6e08ae0074d482069261440d1b9ce99947077428", "filename": "src/test/compile-fail/union/union-copy.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Ftest%2Fcompile-fail%2Funion%2Funion-copy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Ftest%2Fcompile-fail%2Funion%2Funion-copy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funion%2Funion-copy.rs?ref=d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2", "patch": "@@ -0,0 +1,26 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(untagged_unions)]\n+\n+union U {\n+    a: u8\n+}\n+\n+union W {\n+    a: String\n+}\n+\n+impl Clone for U { fn clone(&self) { panic!(); } }\n+impl Clone for W { fn clone(&self) { panic!(); } }\n+impl Copy for U {} // OK\n+impl Copy for W {} //~ ERROR the trait `Copy` may not be implemented for this type\n+\n+fn main() {}"}, {"sha": "0f78e96f640c75b8c44b32dd28cdf6172372622b", "filename": "src/test/compile-fail/union/union-derive.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Ftest%2Fcompile-fail%2Funion%2Funion-derive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Ftest%2Fcompile-fail%2Funion%2Funion-derive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funion%2Funion-derive.rs?ref=d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2", "patch": "@@ -0,0 +1,30 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Most traits cannot be derived for unions.\n+\n+#![feature(untagged_unions)]\n+\n+#[derive(\n+    Clone, //~ ERROR this trait cannot be derived for unions\n+    PartialEq, //~ ERROR this trait cannot be derived for unions\n+    Eq, //~ ERROR this trait cannot be derived for unions\n+    PartialOrd, //~ ERROR this trait cannot be derived for unions\n+    Ord, //~ ERROR this trait cannot be derived for unions\n+    Hash, //~ ERROR this trait cannot be derived for unions\n+    Default, //~ ERROR this trait cannot be derived for unions\n+    Debug, //~ ERROR this trait cannot be derived for unions\n+)]\n+union U {\n+    a: u8,\n+    b: u16,\n+}\n+\n+fn main() {}"}, {"sha": "ce5bbf60fee2547eeb9a6ccdfca8e4f2d9efb3be", "filename": "src/test/compile-fail/union/union-empty.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Ftest%2Fcompile-fail%2Funion%2Funion-empty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Ftest%2Fcompile-fail%2Funion%2Funion-empty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funion%2Funion-empty.rs?ref=d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2", "patch": "@@ -0,0 +1,15 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(untagged_unions)]\n+\n+union U {} //~ ERROR unions cannot have zero fields\n+\n+fn main() {}"}, {"sha": "abfc4d909218b5490b0e1c1271411ffd53258d86", "filename": "src/test/compile-fail/union/union-feature-gate.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Ftest%2Fcompile-fail%2Funion%2Funion-feature-gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Ftest%2Fcompile-fail%2Funion%2Funion-feature-gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funion%2Funion-feature-gate.rs?ref=d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2", "patch": "@@ -0,0 +1,15 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+union U { //~ ERROR unions are unstable and possibly buggy\n+    a: u8,\n+}\n+\n+fn main() {}"}, {"sha": "a1721dda7decb70b44d39312831ce2cb5401ae57", "filename": "src/test/compile-fail/union/union-fields.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Ftest%2Fcompile-fail%2Funion%2Funion-fields.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Ftest%2Fcompile-fail%2Funion%2Funion-fields.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funion%2Funion-fields.rs?ref=d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2", "patch": "@@ -0,0 +1,35 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(untagged_unions)]\n+\n+union U {\n+    a: u8,\n+    b: u16,\n+}\n+\n+fn main() {\n+    let u = U {}; //~ ERROR union expressions should have exactly one field\n+    let u = U { a: 0 }; // OK\n+    let u = U { a: 0, b: 1 }; //~ ERROR union expressions should have exactly one field\n+    let u = U { a: 0, b: 1, c: 2 }; //~ ERROR union expressions should have exactly one field\n+                                    //~^ ERROR union `U` has no field named `c`\n+    let u = U { ..u }; //~ ERROR union expressions should have exactly one field\n+                       //~^ ERROR functional record update syntax requires a struct\n+\n+    let U {} = u; //~ ERROR union patterns should have exactly one field\n+    let U { a } = u; // OK\n+    let U { a, b } = u; //~ ERROR union patterns should have exactly one field\n+    let U { a, b, c } = u; //~ ERROR union patterns should have exactly one field\n+                           //~^ ERROR union `U` does not have a field named `c`\n+    let U { .. } = u; //~ ERROR union patterns should have exactly one field\n+                      //~^ ERROR `..` cannot be used in union patterns\n+    let U { a, .. } = u; //~ ERROR `..` cannot be used in union patterns\n+}"}, {"sha": "e6586b0fb7f6adeb00e24b75b6c789210bda2d3a", "filename": "src/test/compile-fail/union/union-generic.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Ftest%2Fcompile-fail%2Funion%2Funion-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Ftest%2Fcompile-fail%2Funion%2Funion-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funion%2Funion-generic.rs?ref=d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2", "patch": "@@ -0,0 +1,24 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(untagged_unions)]\n+\n+use std::rc::Rc;\n+\n+union U<T: Copy> {\n+    a: T\n+}\n+\n+fn main() {\n+    let u = U { a: Rc::new(0u32) };\n+    //~^ ERROR  the trait bound `std::rc::Rc<u32>: std::marker::Copy` is not satisfied\n+    let u = U::<Rc<u32>> { a: Default::default() };\n+    //~^ ERROR  the trait bound `std::rc::Rc<u32>: std::marker::Copy` is not satisfied\n+}"}, {"sha": "cb4683c2a0e12bf0abfcef0579ae2a8913472541", "filename": "src/test/compile-fail/union/union-nonrepresentable.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Ftest%2Fcompile-fail%2Funion%2Funion-nonrepresentable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Ftest%2Fcompile-fail%2Funion%2Funion-nonrepresentable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funion%2Funion-nonrepresentable.rs?ref=d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2", "patch": "@@ -0,0 +1,18 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(untagged_unions)]\n+\n+union U { //~ ERROR recursive type `U` has infinite size\n+    a: u8,\n+    b: U,\n+}\n+\n+fn main() {}"}, {"sha": "d7dfb126c93248d70d10c25c72f70956683cf664", "filename": "src/test/compile-fail/union/union-repr-c.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Ftest%2Fcompile-fail%2Funion%2Funion-repr-c.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Ftest%2Fcompile-fail%2Funion%2Funion-repr-c.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funion%2Funion-repr-c.rs?ref=d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2", "patch": "@@ -0,0 +1,29 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(untagged_unions)]\n+#![allow(unused)]\n+#![deny(improper_ctypes)]\n+\n+#[repr(C)]\n+union U {\n+    a: u8,\n+}\n+\n+union W {\n+    a: u8,\n+}\n+\n+extern \"C\" {\n+    static FOREIGN1: U; // OK\n+    static FOREIGN2: W; //~ ERROR found union without foreign-function-safe representation\n+}\n+\n+fn main() {}"}, {"sha": "b05e9b6e27334bae4d024537cdad3211147d83ef", "filename": "src/test/compile-fail/union/union-suggest-field.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Ftest%2Fcompile-fail%2Funion%2Funion-suggest-field.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Ftest%2Fcompile-fail%2Funion%2Funion-suggest-field.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funion%2Funion-suggest-field.rs?ref=d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2", "patch": "@@ -0,0 +1,29 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(untagged_unions)]\n+\n+union U {\n+    principal: u8,\n+}\n+\n+impl U {\n+    fn calculate(&self) {}\n+}\n+\n+fn main() {\n+    let u = U { principle: 0 }; //~ ERROR union `U` has no field named `principle`\n+                                //~^ HELP did you mean `principal`?\n+    let w = u.principial; //~ ERROR attempted access of field `principial` on type `U`\n+                          //~^ HELP did you mean `principal`?\n+\n+    let y = u.calculate; //~ ERROR attempted to take value of method `calculate` on type `U`\n+                         //~^ HELP maybe a `()` to call it is missing?\n+}"}, {"sha": "97e1ec2cba865d24d9d8dcd52daf163a4f8a41e1", "filename": "src/test/compile-fail/union/union-unsafe.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Ftest%2Fcompile-fail%2Funion%2Funion-unsafe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Ftest%2Fcompile-fail%2Funion%2Funion-unsafe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funion%2Funion-unsafe.rs?ref=d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2", "patch": "@@ -0,0 +1,24 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(untagged_unions)]\n+\n+union U {\n+    a: u8\n+}\n+\n+fn main() {\n+    let mut u = U { a: 10 }; // OK\n+    let a = u.a; //~ ERROR access to union field requires unsafe function or block\n+    u.a = 11; //~ ERROR access to union field requires unsafe function or block\n+    let U { a } = u; //~ ERROR matching on union field requires unsafe function or block\n+    if let U { a: 12 } = u {} //~ ERROR matching on union field requires unsafe function or block\n+    // let U { .. } = u; // OK\n+}"}, {"sha": "a238eaf052508460677a4c59f893754a2abf70f3", "filename": "src/test/compile-fail/union/union-unsized.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Ftest%2Fcompile-fail%2Funion%2Funion-unsized.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Ftest%2Fcompile-fail%2Funion%2Funion-unsized.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funion%2Funion-unsized.rs?ref=d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(untagged_unions)]\n+\n+union U {\n+    a: str, //~ ERROR the trait bound `str: std::marker::Sized` is not satisfied\n+    b: u8,\n+}\n+\n+union W {\n+    a: u8,\n+    b: str, //~ ERROR the trait bound `str: std::marker::Sized` is not satisfied\n+}\n+\n+fn main() {}"}, {"sha": "87a72efbe08e51fe8f77d5fdd857739112f28c63", "filename": "src/test/compile-fail/union/union-with-drop-fields-lint.rs", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Ftest%2Fcompile-fail%2Funion%2Funion-with-drop-fields-lint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Ftest%2Fcompile-fail%2Funion%2Funion-with-drop-fields-lint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funion%2Funion-with-drop-fields-lint.rs?ref=d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2", "patch": "@@ -0,0 +1,40 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(untagged_unions)]\n+#![allow(dead_code)]\n+#![deny(unions_with_drop_fields)]\n+\n+union U {\n+    a: u8, // OK\n+}\n+\n+union W {\n+    a: String, //~ ERROR union contains a field with possibly non-trivial drop code\n+    b: String, // OK, only one field is reported\n+}\n+\n+struct S(String);\n+\n+// `S` doesn't implement `Drop` trait, but still has non-trivial destructor\n+union Y {\n+    a: S, //~ ERROR union contains a field with possibly non-trivial drop code\n+}\n+\n+// We don't know if `T` is trivially-destructable or not until trans\n+union J<T> {\n+    a: T, //~ ERROR union contains a field with possibly non-trivial drop code\n+}\n+\n+union H<T: Copy> {\n+    a: T, // OK, `T` is `Copy`, no destructor\n+}\n+\n+fn main() {}"}, {"sha": "319927c979bf89798efa68997926ca4989182b4d", "filename": "src/test/debuginfo/union-smoke.rs", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Ftest%2Fdebuginfo%2Funion-smoke.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Ftest%2Fdebuginfo%2Funion-smoke.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Funion-smoke.rs?ref=d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2", "patch": "@@ -0,0 +1,50 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// min-lldb-version: 310\n+\n+// compile-flags:-g\n+\n+// === GDB TESTS ===================================================================================\n+\n+// gdb-command:run\n+// gdb-command:print u\n+// gdb-check:$1 = {a = {__0 = 2 '\\002', __1 = 2 '\\002'}, b = 514}\n+// gdb-command:print union_smoke::SU\n+// gdb-check:$2 = {a = {__0 = 1 '\\001', __1 = 1 '\\001'}, b = 257}\n+\n+// === LLDB TESTS ==================================================================================\n+\n+// lldb-command:run\n+// lldb-command:print u\n+// lldb-check:[...]$0 = { a = ('\\x02', '\\x02') b = 514 }\n+// lldb-command:print union_smoke::SU\n+// lldb-check:[...]$1 = 257\n+\n+#![allow(unused)]\n+#![feature(omit_gdb_pretty_printer_section)]\n+#![omit_gdb_pretty_printer_section]\n+#![feature(untagged_unions)]\n+\n+union U {\n+    a: (u8, u8),\n+    b: u16,\n+}\n+\n+static mut SU: U = U { a: (1, 1) };\n+\n+fn main() {\n+    let u = U { b: (2 << 8) + 2 };\n+    unsafe { SU = U { a: (1, 1) } }\n+\n+    zzz(); // #break\n+}\n+\n+fn zzz() {()}"}, {"sha": "c27294442e7a4679f369537e565d255195394daa", "filename": "src/test/incremental/struct_change_field_name.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Ftest%2Fincremental%2Fstruct_change_field_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Ftest%2Fincremental%2Fstruct_change_field_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fstruct_change_field_name.rs?ref=d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2", "patch": "@@ -37,7 +37,7 @@ pub struct Y {\n #[rustc_dirty(label=\"TypeckItemBody\", cfg=\"cfail2\")]\n pub fn use_X() -> u32 {\n     let x: X = X { x: 22 };\n-    //[cfail2]~^ ERROR structure `X` has no field named `x`\n+    //[cfail2]~^ ERROR struct `X` has no field named `x`\n     x.x as u32\n     //[cfail2]~^ ERROR attempted access of field `x`\n }"}, {"sha": "0231e38a729b731827cf3e3f5d03ac7d3bb54cc6", "filename": "src/test/run-pass/union/auxiliary/union.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Ftest%2Frun-pass%2Funion%2Fauxiliary%2Funion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Ftest%2Frun-pass%2Funion%2Fauxiliary%2Funion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funion%2Fauxiliary%2Funion.rs?ref=d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2", "patch": "@@ -0,0 +1,16 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(untagged_unions)]\n+\n+pub union U {\n+    pub a: u8,\n+    pub b: u16,\n+}"}, {"sha": "9394b618ddf25b1aeef058f9b6fa1f6e5d8f6107", "filename": "src/test/run-pass/union/union-backcomp.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Ftest%2Frun-pass%2Funion%2Funion-backcomp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Ftest%2Frun-pass%2Funion%2Funion-backcomp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funion%2Funion-backcomp.rs?ref=d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2", "patch": "@@ -0,0 +1,27 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(untagged_unions)]\n+\n+fn union() {}\n+\n+fn main() {\n+    union();\n+\n+    let union = 10;\n+\n+    union;\n+\n+    union as u8;\n+\n+    union U {\n+        a: u8,\n+    }\n+}"}, {"sha": "d23af4b41b73f71065834d9cede504dd3374a312", "filename": "src/test/run-pass/union/union-basic.rs", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Ftest%2Frun-pass%2Funion%2Funion-basic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Ftest%2Frun-pass%2Funion%2Funion-basic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funion%2Funion-basic.rs?ref=d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2", "patch": "@@ -0,0 +1,68 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:union.rs\n+\n+#![feature(untagged_unions)]\n+\n+extern crate union;\n+use std::mem::{size_of, align_of, zeroed};\n+\n+union U {\n+    a: u8,\n+    b: u16\n+}\n+\n+fn local() {\n+    assert_eq!(size_of::<U>(), 2);\n+    assert_eq!(align_of::<U>(), 2);\n+\n+    let u = U { a: 10 };\n+    unsafe {\n+        assert_eq!(u.a, 10);\n+        let U { a } = u;\n+        assert_eq!(a, 10);\n+    }\n+\n+    let mut w = U { b: 0 };\n+    unsafe {\n+        assert_eq!(w.a, 0);\n+        assert_eq!(w.b, 0);\n+        w.a = 1;\n+        assert_eq!(w.a, 1);\n+        assert_eq!(w.b, 1);\n+    }\n+}\n+\n+fn xcrate() {\n+    assert_eq!(size_of::<union::U>(), 2);\n+    assert_eq!(align_of::<union::U>(), 2);\n+\n+    let u = union::U { a: 10 };\n+    unsafe {\n+        assert_eq!(u.a, 10);\n+        let union::U { a } = u;\n+        assert_eq!(a, 10);\n+    }\n+\n+    let mut w = union::U { b: 0 };\n+    unsafe {\n+        assert_eq!(w.a, 0);\n+        assert_eq!(w.b, 0);\n+        w.a = 1;\n+        assert_eq!(w.a, 1);\n+        assert_eq!(w.b, 1);\n+    }\n+}\n+\n+fn main() {\n+    local();\n+    xcrate();\n+}"}, {"sha": "a9f97620ebd46e3c365f2c211a844c187645b66d", "filename": "src/test/run-pass/union/union-c-interop.rs", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Ftest%2Frun-pass%2Funion%2Funion-c-interop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Ftest%2Frun-pass%2Funion%2Funion-c-interop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funion%2Funion-c-interop.rs?ref=d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2", "patch": "@@ -0,0 +1,47 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(untagged_unions)]\n+\n+#[derive(Copy)]\n+#[repr(C)]\n+struct LARGE_INTEGER_U {\n+    LowPart: u32,\n+    HighPart: u32,\n+}\n+\n+#[derive(Copy)]\n+#[repr(C)]\n+union LARGE_INTEGER {\n+  __unnamed__: LARGE_INTEGER_U,\n+  u: LARGE_INTEGER_U,\n+  QuadPart: u64,\n+}\n+\n+impl Clone for LARGE_INTEGER_U { fn clone(&self) -> Self { *self } }\n+impl Clone for LARGE_INTEGER { fn clone(&self) -> Self { *self } }\n+\n+#[link(name = \"rust_test_helpers\")]\n+extern \"C\" {\n+    fn increment_all_parts(_: LARGE_INTEGER) -> LARGE_INTEGER;\n+}\n+\n+fn main() {\n+    unsafe {\n+        let mut li = LARGE_INTEGER { QuadPart: 0 };\n+        let li_c = increment_all_parts(li);\n+        li.__unnamed__.LowPart += 1;\n+        li.__unnamed__.HighPart += 1;\n+        li.u.LowPart += 1;\n+        li.u.HighPart += 1;\n+        li.QuadPart += 1;\n+        assert_eq!(li.QuadPart, li_c.QuadPart);\n+    }\n+}"}, {"sha": "bdae1a0eaf88f8accb505083de6303e4ff31abb3", "filename": "src/test/run-pass/union/union-const-trans.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Ftest%2Frun-pass%2Funion%2Funion-const-trans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Ftest%2Frun-pass%2Funion%2Funion-const-trans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funion%2Funion-const-trans.rs?ref=d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2", "patch": "@@ -0,0 +1,27 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(untagged_unions)]\n+\n+union U {\n+    a: u64,\n+    b: u64,\n+}\n+\n+const C: U = U { b: 10 };\n+\n+fn main() {\n+    unsafe {\n+        let a = C.a;\n+        let b = C.b;\n+        assert_eq!(a, 10);\n+        assert_eq!(b, 10);\n+     }\n+}"}, {"sha": "b71c23990a474ba3d618c08786c70a55dd5180bc", "filename": "src/test/run-pass/union/union-derive.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Ftest%2Frun-pass%2Funion%2Funion-derive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Ftest%2Frun-pass%2Funion%2Funion-derive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funion%2Funion-derive.rs?ref=d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2", "patch": "@@ -0,0 +1,31 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Some traits can be derived for unions.\n+\n+#![feature(untagged_unions)]\n+\n+#[derive(\n+    Copy,\n+)]\n+union U {\n+    a: u8,\n+    b: u16,\n+}\n+\n+impl Clone for U {\n+    fn clone(&self) -> Self { *self }\n+}\n+\n+fn main() {\n+    let u = U { b: 0 };\n+    let u1 = u;\n+    let u2 = u.clone();\n+}"}, {"sha": "0da68e43f32a1e91fb99ed4eddd7b63cc2d0bbcd", "filename": "src/test/run-pass/union/union-drop-assign.rs", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Ftest%2Frun-pass%2Funion%2Funion-drop-assign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Ftest%2Frun-pass%2Funion%2Funion-drop-assign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funion%2Funion-drop-assign.rs?ref=d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2", "patch": "@@ -0,0 +1,44 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Drop works for union itself.\n+\n+#![feature(untagged_unions)]\n+\n+struct S;\n+\n+union U {\n+    a: S\n+}\n+\n+impl Drop for S {\n+    fn drop(&mut self) {\n+        unsafe { CHECK += 10; }\n+    }\n+}\n+\n+impl Drop for U {\n+    fn drop(&mut self) {\n+        unsafe { CHECK += 1; }\n+    }\n+}\n+\n+static mut CHECK: u8 = 0;\n+\n+fn main() {\n+    unsafe {\n+        let mut u = U { a: S };\n+        assert_eq!(CHECK, 0);\n+        u = U { a: S };\n+        assert_eq!(CHECK, 1); // union itself is assigned, union is dropped, field is not dropped\n+        u.a = S;\n+        assert_eq!(CHECK, 11); // union field is assigned, field is dropped\n+    }\n+}"}, {"sha": "2ca68dc3b6e39dd0102e843d78e256eb20bae9b7", "filename": "src/test/run-pass/union/union-drop.rs", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Ftest%2Frun-pass%2Funion%2Funion-drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Ftest%2Frun-pass%2Funion%2Funion-drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funion%2Funion-drop.rs?ref=d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2", "patch": "@@ -0,0 +1,65 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Drop works for union itself.\n+\n+#![feature(untagged_unions)]\n+\n+struct S;\n+\n+union U {\n+    a: u8\n+}\n+\n+union W {\n+    a: S,\n+}\n+\n+union Y {\n+    a: S,\n+}\n+\n+impl Drop for S {\n+    fn drop(&mut self) {\n+        unsafe { CHECK += 10; }\n+    }\n+}\n+\n+impl Drop for U {\n+    fn drop(&mut self) {\n+        unsafe { CHECK += 1; }\n+    }\n+}\n+\n+impl Drop for W {\n+    fn drop(&mut self) {\n+        unsafe { CHECK += 1; }\n+    }\n+}\n+\n+static mut CHECK: u8 = 0;\n+\n+fn main() {\n+    unsafe {\n+        assert_eq!(CHECK, 0);\n+        {\n+            let u = U { a: 1 };\n+        }\n+        assert_eq!(CHECK, 1); // 1, dtor of U is called\n+        {\n+            let w = W { a: S };\n+        }\n+        assert_eq!(CHECK, 2); // 2, not 11, dtor of S is not called\n+        {\n+            let y = Y { a: S };\n+        }\n+        assert_eq!(CHECK, 2); // 2, not 12, dtor of S is not called\n+    }\n+}"}, {"sha": "9293805edbf832c92c3dc4e7702a54686b3bff3b", "filename": "src/test/run-pass/union/union-generic.rs", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Ftest%2Frun-pass%2Funion%2Funion-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Ftest%2Frun-pass%2Funion%2Funion-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funion%2Funion-generic.rs?ref=d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2", "patch": "@@ -0,0 +1,43 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(untagged_unions)]\n+\n+union MaybeItem<T: Iterator> {\n+    elem: T::Item,\n+    none: (),\n+}\n+\n+union U<A, B> {\n+    a: A,\n+    b: B,\n+}\n+\n+unsafe fn union_transmute<A, B>(a: A) -> B {\n+    U { a: a }.b\n+}\n+\n+fn main() {\n+    unsafe {\n+        let u = U::<String, Vec<u8>> { a: String::from(\"abcd\") };\n+\n+        assert_eq!(u.b.len(), 4);\n+        assert_eq!(u.b[0], b'a');\n+\n+        let b = union_transmute::<(u8, u8), u16>((1, 1));\n+        assert_eq!(b, (1 << 8) + 1);\n+\n+        let v: Vec<u8> = vec![1, 2, 3];\n+        let mut i = v.iter();\n+        i.next();\n+        let mi = MaybeItem::<std::slice::Iter<_>> { elem: i.next().unwrap() };\n+        assert_eq!(*mi.elem, 2);\n+    }\n+}"}, {"sha": "adea27bd25462a58a737b5dfaef42a92fe61080a", "filename": "src/test/run-pass/union/union-inherent-method.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Ftest%2Frun-pass%2Funion%2Funion-inherent-method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Ftest%2Frun-pass%2Funion%2Funion-inherent-method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funion%2Funion-inherent-method.rs?ref=d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2", "patch": "@@ -0,0 +1,24 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(untagged_unions)]\n+\n+union U {\n+    a: u8,\n+}\n+\n+impl U {\n+    fn method(&self) -> u8 { unsafe { self.a } }\n+}\n+\n+fn main() {\n+    let u = U { a: 10 };\n+    assert_eq!(u.method(), 10);\n+}"}, {"sha": "a23fbc3be9e2c8be22c0d715c774da7269311570", "filename": "src/test/run-pass/union/union-macro.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Ftest%2Frun-pass%2Funion%2Funion-macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Ftest%2Frun-pass%2Funion%2Funion-macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funion%2Funion-macro.rs?ref=d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2", "patch": "@@ -0,0 +1,33 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(untagged_unions)]\n+\n+macro_rules! duplicate {\n+   ($i: item) => {\n+        mod m1 {\n+            $i\n+        }\n+        mod m2 {\n+            $i\n+        }\n+   }\n+}\n+\n+duplicate! {\n+    pub union U {\n+        pub a: u8\n+    }\n+}\n+\n+fn main() {\n+    let u1 = m1::U { a: 0 };\n+    let u2 = m2::U { a: 0 };\n+}"}, {"sha": "9389a6237bca61cbdf7d601ff095c2a3d146a900", "filename": "src/test/run-pass/union/union-overwrite.rs", "status": "added", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Ftest%2Frun-pass%2Funion%2Funion-overwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Ftest%2Frun-pass%2Funion%2Funion-overwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funion%2Funion-overwrite.rs?ref=d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2", "patch": "@@ -0,0 +1,80 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(untagged_unions)]\n+\n+#[repr(C)]\n+struct Pair<T, U>(T, U);\n+#[repr(C)]\n+struct Triple<T>(T, T, T);\n+\n+#[repr(C)]\n+union U<A, B> {\n+    a: Pair<A, A>,\n+    b: B,\n+}\n+\n+#[repr(C)]\n+union W<A, B> {\n+    a: A,\n+    b: B,\n+}\n+\n+#[cfg(target_endian = \"little\")]\n+unsafe fn check() {\n+    let mut u = U::<u8, u16> { b: 0xDE_DE };\n+    u.a.0 = 0xBE;\n+    assert_eq!(u.b, 0xDE_BE);\n+\n+    let mut u = U::<u16, u32> { b: 0xDEAD_DEAD };\n+    u.a.0 = 0xBEEF;\n+    assert_eq!(u.b, 0xDEAD_BEEF);\n+\n+    let mut u = U::<u32, u64> { b: 0xDEADBEEF_DEADBEEF };\n+    u.a.0 = 0xBAADF00D;\n+    assert_eq!(u.b, 0xDEADBEEF_BAADF00D);\n+\n+    let mut w = W::<Pair<Triple<u8>, u8>, u32> { b: 0xDEAD_DEAD };\n+    w.a.0 = Triple(0, 0, 0);\n+    assert_eq!(w.b, 0xDE00_0000);\n+\n+    let mut w = W::<Pair<u8, Triple<u8>>, u32> { b: 0xDEAD_DEAD };\n+    w.a.1 = Triple(0, 0, 0);\n+    assert_eq!(w.b, 0x0000_00AD);\n+}\n+\n+#[cfg(target_endian = \"big\")]\n+unsafe fn check() {\n+    let mut u = U::<u8, u16> { b: 0xDE_DE };\n+    u.a.0 = 0xBE;\n+    assert_eq!(u.b, 0xBE_DE);\n+\n+    let mut u = U::<u16, u32> { b: 0xDEAD_DEAD };\n+    u.a.0 = 0xBEEF;\n+    assert_eq!(u.b, 0xBEEF_DEAD);\n+\n+    let mut u = U::<u32, u64> { b: 0xDEADBEEF_DEADBEEF };\n+    u.a.0 = 0xBAADF00D;\n+    assert_eq!(u.b, 0xBAADF00D_DEADBEEF);\n+\n+    let mut w = W::<Pair<Triple<u8>, u8>, u32> { b: 0xDEAD_DEAD };\n+    w.a.0 = Triple(0, 0, 0);\n+    assert_eq!(w.b, 0x0000_00AD);\n+\n+    let mut w = W::<Pair<u8, Triple<u8>>, u32> { b: 0xDEAD_DEAD };\n+    w.a.1 = Triple(0, 0, 0);\n+    assert_eq!(w.b, 0xDE00_0000);\n+}\n+\n+fn main() {\n+    unsafe {\n+        check();\n+    }\n+}"}, {"sha": "6a61280823e50ff43cd1a419a5cce5c424a90dc7", "filename": "src/test/run-pass/union/union-packed.rs", "status": "added", "additions": 104, "deletions": 0, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Ftest%2Frun-pass%2Funion%2Funion-packed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Ftest%2Frun-pass%2Funion%2Funion-packed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funion%2Funion-packed.rs?ref=d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2", "patch": "@@ -0,0 +1,104 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(untagged_unions)]\n+\n+use std::mem::{size_of, size_of_val, align_of, align_of_val};\n+\n+struct S {\n+    a: u16,\n+    b: [u8; 3],\n+}\n+\n+#[repr(packed)]\n+struct Sp {\n+    a: u16,\n+    b: [u8; 3],\n+}\n+\n+union U {\n+    a: u16,\n+    b: [u8; 3],\n+}\n+\n+#[repr(packed)]\n+union Up {\n+    a: u16,\n+    b: [u8; 3],\n+}\n+\n+const CS: S = S { a: 0, b: [0, 0, 0] };\n+const CSP: Sp = Sp { a: 0, b: [0, 0, 0] };\n+const CU: U = U { b: [0, 0, 0] };\n+const CUP: Up = Up { b: [0, 0, 0] };\n+\n+fn main() {\n+    let s = S { a: 0, b: [0, 0, 0] };\n+    assert_eq!(size_of::<S>(), 6);\n+    assert_eq!(size_of_val(&s), 6);\n+    assert_eq!(size_of_val(&CS), 6);\n+    assert_eq!(align_of::<S>(), 2);\n+    assert_eq!(align_of_val(&s), 2);\n+    assert_eq!(align_of_val(&CS), 2);\n+\n+    let sp = Sp { a: 0, b: [0, 0, 0] };\n+    assert_eq!(size_of::<Sp>(), 5);\n+    assert_eq!(size_of_val(&sp), 5);\n+    assert_eq!(size_of_val(&CSP), 5);\n+    assert_eq!(align_of::<Sp>(), 1);\n+    assert_eq!(align_of_val(&sp), 1);\n+    assert_eq!(align_of_val(&CSP), 1);\n+\n+    let u = U { b: [0, 0, 0] };\n+    assert_eq!(size_of::<U>(), 4);\n+    assert_eq!(size_of_val(&u), 4);\n+    assert_eq!(size_of_val(&CU), 4);\n+    assert_eq!(align_of::<U>(), 2);\n+    assert_eq!(align_of_val(&u), 2);\n+    assert_eq!(align_of_val(&CU), 2);\n+\n+    let up = Up { b: [0, 0, 0] };\n+    assert_eq!(size_of::<Up>(), 3);\n+    assert_eq!(size_of_val(&up), 3);\n+    assert_eq!(size_of_val(&CUP), 3);\n+    assert_eq!(align_of::<Up>(), 1);\n+    assert_eq!(align_of_val(&up), 1);\n+    assert_eq!(align_of_val(&CUP), 1);\n+\n+    hybrid::check_hybrid();\n+}\n+\n+mod hybrid {\n+    use std::mem::size_of;\n+\n+    #[repr(packed)]\n+    struct S1 {\n+        a: u16,\n+        b: u8,\n+    }\n+\n+    #[repr(packed)]\n+    union U {\n+        s: S1,\n+        c: u16,\n+    }\n+\n+    #[repr(packed)]\n+    struct S2 {\n+        d: u8,\n+        u: U,\n+    }\n+\n+    pub fn check_hybrid() {\n+        assert_eq!(size_of::<S1>(), 3);\n+        assert_eq!(size_of::<U>(), 3);\n+        assert_eq!(size_of::<S2>(), 4);\n+    }\n+}"}, {"sha": "e6144f35f1d549056d4da1f98579fa6004ff1146", "filename": "src/test/run-pass/union/union-pat-refutability.rs", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Ftest%2Frun-pass%2Funion%2Funion-pat-refutability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Ftest%2Frun-pass%2Funion%2Funion-pat-refutability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funion%2Funion-pat-refutability.rs?ref=d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2", "patch": "@@ -0,0 +1,62 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(untagged_unions)]\n+\n+#[repr(u32)]\n+enum Tag { I, F }\n+\n+#[repr(C)]\n+union U {\n+    i: i32,\n+    f: f32,\n+}\n+\n+#[repr(C)]\n+struct Value {\n+    tag: Tag,\n+    u: U,\n+}\n+\n+fn is_zero(v: Value) -> bool {\n+    unsafe {\n+        match v {\n+            Value { tag: Tag::I, u: U { i: 0 } } => true,\n+            Value { tag: Tag::F, u: U { f: 0.0 } } => true,\n+            _ => false,\n+        }\n+    }\n+}\n+\n+union W {\n+    a: u8,\n+    b: u8,\n+}\n+\n+fn refut(w: W) {\n+    unsafe {\n+        match w {\n+            W { a: 10 } => {\n+                panic!();\n+            }\n+            W { b } => {\n+                assert_eq!(b, 11);\n+            }\n+        }\n+    }\n+}\n+\n+fn main() {\n+    let v = Value { tag: Tag::I, u: U { i: 1 } };\n+    assert_eq!(is_zero(v), false);\n+\n+    let w = W { a: 11 };\n+    refut(w);\n+}"}, {"sha": "a5a2be0133abaf55e13fef61a7086371d2403e46", "filename": "src/test/run-pass/union/union-trait-impl.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Ftest%2Frun-pass%2Funion%2Funion-trait-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Ftest%2Frun-pass%2Funion%2Funion-trait-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funion%2Funion-trait-impl.rs?ref=d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2", "patch": "@@ -0,0 +1,27 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(untagged_unions)]\n+\n+use std::fmt;\n+\n+union U {\n+    a: u8\n+}\n+\n+impl fmt::Display for U {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> Result<(), fmt::Error> {\n+        unsafe { write!(f, \"Oh hai {}\", self.a) }\n+    }\n+}\n+\n+fn main() {\n+    assert_eq!(U { a: 2 }.to_string(), \"Oh hai 2\");\n+}"}, {"sha": "4eb66268ab8eab8fc55b20e60c6b7ed09a2db099", "filename": "src/test/run-pass/union/union-transmute.rs", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Ftest%2Frun-pass%2Funion%2Funion-transmute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Ftest%2Frun-pass%2Funion%2Funion-transmute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funion%2Funion-transmute.rs?ref=d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2", "patch": "@@ -0,0 +1,40 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(core_float)]\n+#![feature(float_extras)]\n+#![feature(untagged_unions)]\n+\n+extern crate core;\n+use core::num::Float;\n+\n+union U {\n+    a: (u8, u8),\n+    b: u16,\n+}\n+\n+union W {\n+    a: u32,\n+    b: f32,\n+}\n+\n+fn main() {\n+    unsafe {\n+        let mut u = U { a: (1, 1) };\n+        assert_eq!(u.b, (1 << 8) + 1);\n+        u.b = (2 << 8) + 2;\n+        assert_eq!(u.a, (2, 2));\n+\n+        let mut w = W { a: 0b0_11111111_00000000000000000000000 };\n+        assert_eq!(w.b, f32::infinity());\n+        w.b = f32::neg_infinity();\n+        assert_eq!(w.a, 0b1_11111111_00000000000000000000000);\n+    }\n+}"}, {"sha": "5a1424830d07480288f9b47f287f39109baa3deb", "filename": "src/test/run-pass/union/union-with-drop-fields-lint.rs", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Ftest%2Frun-pass%2Funion%2Funion-with-drop-fields-lint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Ftest%2Frun-pass%2Funion%2Funion-with-drop-fields-lint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funion%2Funion-with-drop-fields-lint.rs?ref=d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2", "patch": "@@ -0,0 +1,42 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-pretty\n+\n+#![feature(untagged_unions)]\n+#![allow(dead_code)]\n+#![allow(unions_with_drop_fields)]\n+\n+union U {\n+    a: u8, // OK\n+}\n+\n+union W {\n+    a: String, // OK\n+    b: String, // OK\n+}\n+\n+struct S(String);\n+\n+// `S` doesn't implement `Drop` trait, but still has non-trivial destructor\n+union Y {\n+    a: S, // OK\n+}\n+\n+// We don't know if `T` is trivially-destructable or not until trans\n+union J<T> {\n+    a: T, // OK\n+}\n+\n+union H<T: Copy> {\n+    a: T, // OK\n+}\n+\n+fn main() {}"}, {"sha": "0dcc9098ad75cbe54c87fe7fa6bbd7d9ced64cd2", "filename": "src/test/rustdoc/union.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Ftest%2Frustdoc%2Funion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2/src%2Ftest%2Frustdoc%2Funion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Funion.rs?ref=d748fa6ecccf6f5b4c7ae4abee0a2d206b165de2", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(untagged_unions)]\n+\n+// @has union/union.U.html\n+pub union U {\n+    // @has - //pre \"pub a: u8\"\n+    pub a: u8,\n+    // @has - //pre \"// some fields omitted\"\n+    // @!has - //pre \"b: u16\"\n+    b: u16,\n+}"}]}