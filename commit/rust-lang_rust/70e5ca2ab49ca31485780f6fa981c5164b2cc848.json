{"sha": "70e5ca2ab49ca31485780f6fa981c5164b2cc848", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcwZTVjYTJhYjQ5Y2EzMTQ4NTc4MGY2ZmE5ODFjNTE2NGIyY2M4NDg=", "commit": {"author": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2016-11-15T16:48:07Z"}, "committer": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2016-11-24T09:30:18Z"}, "message": "Revisions from review comments, squashed.\n\nBiggest change: Revised print-type-sizes output to include breakdown\nof layout.\n\nIncludes info about field sizes (and alignment + padding when padding\nis injected; the injected padding is derived from the offsets computed\nby layout module).\n\nOutput format is illustrated in commit that has the ui tests.\n\nNote: there exists (at least) one case of variant w/o name: empty\nenums.  Namely, empty enums use anonymous univariant repr. So for such\ncases, print the number of the variant instead of the name.\n\n----\n\nAlso, eddyb suggested of reading from `layout_cache` post-trans.\n\n(For casual readers: the compiler source often uses the word \"cache\"\nfor tables that are in fact not periodically purged, and thus are\nuseful as the basis for data like this.)\n\nSome types that were previously not printed are now included in the\noutput. (See e.g. the tests `print_type_sizes/generics.rs` and\n`print_type_sizes/variants.rs`)\n\n----\n\nOther review feedback:\n\nswitch to an exhaustive match when filtering in just structural types.\nswitch to hashset for layout info and move sort into print method.\n\n----\n\nDriveby change: Factored session::code_stats into its own module\n\n----\n\nincorporate njn feedback re output formatting.", "tree": {"sha": "7101eac9776c40346cb805273298230d19f4d50e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7101eac9776c40346cb805273298230d19f4d50e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/70e5ca2ab49ca31485780f6fa981c5164b2cc848", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/70e5ca2ab49ca31485780f6fa981c5164b2cc848", "html_url": "https://github.com/rust-lang/rust/commit/70e5ca2ab49ca31485780f6fa981c5164b2cc848", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/70e5ca2ab49ca31485780f6fa981c5164b2cc848/comments", "author": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9383fcf07f85d8e8b91a6150cf4ca252b37a5383", "url": "https://api.github.com/repos/rust-lang/rust/commits/9383fcf07f85d8e8b91a6150cf4ca252b37a5383", "html_url": "https://github.com/rust-lang/rust/commit/9383fcf07f85d8e8b91a6150cf4ca252b37a5383"}], "stats": {"total": 605, "additions": 377, "deletions": 228}, "files": [{"sha": "8308c54d70bf49a3a574b908a3fb165c244ef5c2", "filename": "src/librustc/session/code_stats.rs", "status": "added", "additions": 173, "deletions": 0, "changes": 173, "blob_url": "https://github.com/rust-lang/rust/blob/70e5ca2ab49ca31485780f6fa981c5164b2cc848/src%2Flibrustc%2Fsession%2Fcode_stats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70e5ca2ab49ca31485780f6fa981c5164b2cc848/src%2Flibrustc%2Fsession%2Fcode_stats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fcode_stats.rs?ref=70e5ca2ab49ca31485780f6fa981c5164b2cc848", "patch": "@@ -0,0 +1,173 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use ty::AdtKind;\n+use ty::layout::{Align, Size};\n+\n+use rustc_data_structures::fx::{FxHashSet};\n+\n+use std::cmp::{self, Ordering};\n+\n+#[derive(Clone, PartialEq, Eq, Hash, Debug)]\n+pub struct VariantInfo {\n+    pub name: Option<String>,\n+    pub kind: SizeKind,\n+    pub size: u64,\n+    pub align: u64,\n+    pub fields: Vec<FieldInfo>,\n+}\n+\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n+pub enum SizeKind { Exact, Min }\n+\n+#[derive(Clone, PartialEq, Eq, Hash, Debug)]\n+pub struct FieldInfo {\n+    pub name: String,\n+    pub offset: u64,\n+    pub size: u64,\n+    pub align: u64,\n+}\n+\n+impl From<AdtKind> for DataTypeKind {\n+    fn from(kind: AdtKind) -> Self {\n+        match kind {\n+            AdtKind::Struct => DataTypeKind::Struct,\n+            AdtKind::Enum => DataTypeKind::Enum,\n+            AdtKind::Union => DataTypeKind::Union,\n+        }\n+    }\n+}\n+\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n+pub enum DataTypeKind {\n+    Struct,\n+    Union,\n+    Enum,\n+    Closure,\n+}\n+\n+#[derive(PartialEq, Eq, Hash, Debug)]\n+pub struct TypeSizeInfo {\n+    pub kind: DataTypeKind,\n+    pub type_description: String,\n+    pub align: u64,\n+    pub overall_size: u64,\n+    pub opt_discr_size: Option<u64>,\n+    pub variants: Vec<VariantInfo>,\n+}\n+\n+#[derive(PartialEq, Eq, Debug)]\n+pub struct CodeStats {\n+    type_sizes: FxHashSet<TypeSizeInfo>,\n+}\n+\n+impl CodeStats {\n+    pub fn new() -> Self { CodeStats { type_sizes: FxHashSet() } }\n+\n+    pub fn record_type_size<S: ToString>(&mut self,\n+                                         kind: DataTypeKind,\n+                                         type_desc: S,\n+                                         align: Align,\n+                                         overall_size: Size,\n+                                         opt_discr_size: Option<Size>,\n+                                         variants: Vec<VariantInfo>) {\n+        let info = TypeSizeInfo {\n+            kind: kind,\n+            type_description: type_desc.to_string(),\n+            align: align.abi(),\n+            overall_size: overall_size.bytes(),\n+            opt_discr_size: opt_discr_size.map(|s| s.bytes()),\n+            variants: variants,\n+        };\n+        self.type_sizes.insert(info);\n+    }\n+\n+    pub fn print_type_sizes(&self) {\n+        let mut sorted: Vec<_> = self.type_sizes.iter().collect();\n+\n+        // Primary sort: large-to-small.\n+        // Secondary sort: description (dictionary order)\n+        sorted.sort_by(|info1, info2| {\n+            // (reversing cmp order to get large-to-small ordering)\n+            match info2.overall_size.cmp(&info1.overall_size) {\n+                Ordering::Equal => info1.type_description.cmp(&info2.type_description),\n+                other => other,\n+            }\n+        });\n+\n+        for info in &sorted {\n+            println!(\"print-type-size type: `{}`: {} bytes, alignment: {} bytes\",\n+                     info.type_description, info.overall_size, info.align);\n+            let indent = \"    \";\n+\n+            let discr_size = if let Some(discr_size) = info.opt_discr_size {\n+                println!(\"print-type-size {}discriminant: {} bytes\",\n+                         indent, discr_size);\n+                discr_size\n+            } else {\n+                0\n+            };\n+\n+            // We start this at discr_size (rather than 0) because\n+            // things like C-enums do not have variants but we still\n+            // want the max_variant_size at the end of the loop below\n+            // to reflect the presence of the discriminant.\n+            let mut max_variant_size = discr_size;\n+\n+            let struct_like = match info.kind {\n+                DataTypeKind::Struct | DataTypeKind::Closure => true,\n+                DataTypeKind::Enum | DataTypeKind::Union => false,\n+            };\n+            for (i, variant_info) in info.variants.iter().enumerate() {\n+                let VariantInfo { ref name, kind: _, align: _, size, ref fields } = *variant_info;\n+                let indent = if !struct_like {\n+                    let name = match name.as_ref() {\n+                        Some(name) => format!(\"{}\", name),\n+                        None => format!(\"{}\", i),\n+                    };\n+                    println!(\"print-type-size {}variant `{}`: {} bytes\",\n+                             indent, name, size - discr_size);\n+                    \"        \"\n+                } else {\n+                    assert!(i < 1);\n+                    \"    \"\n+                };\n+                max_variant_size = cmp::max(max_variant_size, size);\n+\n+                let mut min_offset = discr_size;\n+                for field in fields {\n+                    let FieldInfo { ref name, offset, size, align } = *field;\n+\n+                    // Include field alignment in output only if it caused padding injection\n+                    if min_offset != offset {\n+                        let pad = offset - min_offset;\n+                        println!(\"print-type-size {}padding: {} bytes\",\n+                                 indent, pad);\n+                        println!(\"print-type-size {}field `.{}`: {} bytes, alignment: {} bytes\",\n+                                 indent, name, size, align);\n+                    } else {\n+                        println!(\"print-type-size {}field `.{}`: {} bytes\",\n+                                 indent, name, size);\n+                    }\n+\n+                    min_offset = offset + size;\n+                }\n+            }\n+\n+            assert!(max_variant_size <= info.overall_size,\n+                    \"max_variant_size {} !<= {} overall_size\",\n+                    max_variant_size, info.overall_size);\n+            if max_variant_size < info.overall_size {\n+                println!(\"print-type-size {}end padding: {} bytes\",\n+                         indent, info.overall_size - max_variant_size);\n+            }\n+        }\n+    }\n+}"}, {"sha": "3d8cfd199615e491c916909e0c81cc10e12b5b82", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 4, "deletions": 68, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/70e5ca2ab49ca31485780f6fa981c5164b2cc848/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70e5ca2ab49ca31485780f6fa981c5164b2cc848/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=70e5ca2ab49ca31485780f6fa981c5164b2cc848", "patch": "@@ -8,6 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+pub use self::code_stats::{CodeStats, DataTypeKind, FieldInfo};\n+pub use self::code_stats::{SizeKind, TypeSizeInfo, VariantInfo};\n+\n use dep_graph::DepGraph;\n use hir::def_id::{CrateNum, DefIndex};\n use hir::svh::Svh;\n@@ -49,6 +52,7 @@ use std::fmt;\n use std::time::Duration;\n use libc::c_int;\n \n+mod code_stats;\n pub mod config;\n pub mod filesearch;\n pub mod search_paths;\n@@ -118,74 +122,6 @@ pub struct Session {\n     next_node_id: Cell<ast::NodeId>,\n }\n \n-#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n-pub enum VariantSize {\n-    Exact(u64),\n-    Min(u64),\n-}\n-\n-#[derive(PartialEq, Eq, Debug)]\n-pub struct TypeSizeInfo {\n-    pub type_description: String,\n-    pub overall_size: u64,\n-    pub variant_sizes: Option<Vec<VariantSize>>,\n-}\n-\n-#[derive(PartialEq, Eq, Debug)]\n-pub struct CodeStats {\n-    pub type_sizes: Vec<TypeSizeInfo>,\n-}\n-\n-impl CodeStats {\n-    fn new() -> Self {\n-        CodeStats { type_sizes: Vec::new() }\n-    }\n-\n-    pub fn record_type_size<S: ToString>(&mut self,\n-                                         type_desc: S,\n-                                         overall_size: u64,\n-                                         variant_sizes: Vec<VariantSize>) {\n-        let sizes = if variant_sizes.len() == 0 { None } else { Some(variant_sizes) };\n-        let info = TypeSizeInfo {\n-            type_description: type_desc.to_string(),\n-            overall_size: overall_size,\n-            variant_sizes: sizes,\n-        };\n-        if !self.type_sizes.contains(&info) {\n-            self.type_sizes.push(info);\n-        }\n-    }\n-\n-    pub fn sort_by_type_description(&mut self) {\n-        self.type_sizes.sort_by(|info1, info2| {\n-            info1.type_description.cmp(&info2.type_description)\n-        });\n-    }\n-\n-    pub fn sort_by_overall_size(&mut self) {\n-        self.type_sizes.sort_by(|info1, info2| {\n-            // (reversing cmp order to get large-to-small ordering)\n-            info2.overall_size.cmp(&info1.overall_size)\n-        });\n-    }\n-\n-    pub fn print_type_sizes(&self) {\n-        for info in &self.type_sizes {\n-            println!(\"print-type-size t: `{}` overall bytes: {}\",\n-                     info.type_description, info.overall_size);\n-            if let Some(ref variant_sizes) = info.variant_sizes {\n-                for (i, variant_size) in variant_sizes.iter().enumerate() {\n-                    let (kind, s) = match *variant_size {\n-                        VariantSize::Exact(s) => { (\"exact\", s) }\n-                        VariantSize::Min(s) =>   { (\"  min\", s) }\n-                    };\n-                    println!(\"print-type-size    variant[{}] {} bytes: {}\", i, kind, s);\n-                }\n-            }\n-        }\n-    }\n-}\n-\n pub struct PerfStats {\n     // The accumulated time needed for computing the SVH of the crate\n     pub svh_time: Cell<Duration>,"}, {"sha": "bc3c5d6ed4e203d845ae3e6c3697d0a8394175ab", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/70e5ca2ab49ca31485780f6fa981c5164b2cc848/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70e5ca2ab49ca31485780f6fa981c5164b2cc848/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=70e5ca2ab49ca31485780f6fa981c5164b2cc848", "patch": "@@ -559,11 +559,14 @@ impl<'a, 'gcx, 'tcx> Struct {\n \n             self.offsets.push(offset);\n \n+            debug!(\"Struct::extend offset: {:?} field: {:?} {:?}\", offset, field, field.size(dl));\n \n             offset = offset.checked_add(field.size(dl), dl)\n                            .map_or(Err(LayoutError::SizeOverflow(scapegoat)), Ok)?;\n         }\n \n+        debug!(\"Struct::extend min_size: {:?}\", offset);\n+\n         self.min_size = offset;\n \n         Ok(())\n@@ -707,12 +710,16 @@ impl<'a, 'gcx, 'tcx> Union {\n                      index, scapegoat);\n             }\n \n+            debug!(\"Union::extend field: {:?} {:?}\", field, field.size(dl));\n+\n             if !self.packed {\n                 self.align = self.align.max(field.align(dl));\n             }\n             self.min_size = cmp::max(self.min_size, field.size(dl));\n         }\n \n+        debug!(\"Union::extend min-size: {:?}\", self.min_size);\n+\n         Ok(())\n     }\n "}, {"sha": "9a4ecef0c0ebd16d91aa36670a9a6835e2bb4248", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/70e5ca2ab49ca31485780f6fa981c5164b2cc848/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70e5ca2ab49ca31485780f6fa981c5164b2cc848/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=70e5ca2ab49ca31485780f6fa981c5164b2cc848", "patch": "@@ -216,9 +216,6 @@ pub fn compile_input(sess: &Session,\n     };\n \n     if sess.opts.debugging_opts.print_type_sizes {\n-        // (these are stable sorts)\n-        sess.code_stats.borrow_mut().sort_by_type_description();\n-        sess.code_stats.borrow_mut().sort_by_overall_size();\n         sess.code_stats.borrow().print_type_sizes();\n     }\n \n@@ -1015,9 +1012,6 @@ pub fn phase_4_translate_to_llvm<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     time(time_passes, \"MIR optimisations\", || {\n         let mut passes = ::rustc::mir::transform::Passes::new();\n         passes.push_hook(box mir::transform::dump_mir::DumpMir);\n-        if tcx.sess.opts.debugging_opts.print_type_sizes {\n-            passes.push_pass(box mir::transform::print_type_sizes::GatherTypeSizesMir::new());\n-        }\n         passes.push_pass(box mir::transform::no_landing_pads::NoLandingPads);\n         passes.push_pass(box mir::transform::simplify::SimplifyCfg::new(\"no-landing-pads\"));\n "}, {"sha": "ae255f70fb78892ac21ca8e0e813427692053639", "filename": "src/librustc_mir/transform/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/70e5ca2ab49ca31485780f6fa981c5164b2cc848/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70e5ca2ab49ca31485780f6fa981c5164b2cc848/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fmod.rs?ref=70e5ca2ab49ca31485780f6fa981c5164b2cc848", "patch": "@@ -13,7 +13,6 @@ pub mod simplify;\n pub mod erase_regions;\n pub mod no_landing_pads;\n pub mod type_check;\n-pub mod print_type_sizes;\n pub mod add_call_guards;\n pub mod promote_consts;\n pub mod qualify_consts;"}, {"sha": "617a5ac78df351809ff095ed0d506994a90663fb", "filename": "src/librustc_mir/transform/print_type_sizes.rs", "status": "removed", "additions": 0, "deletions": 152, "changes": 152, "blob_url": "https://github.com/rust-lang/rust/blob/9383fcf07f85d8e8b91a6150cf4ca252b37a5383/src%2Flibrustc_mir%2Ftransform%2Fprint_type_sizes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9383fcf07f85d8e8b91a6150cf4ca252b37a5383/src%2Flibrustc_mir%2Ftransform%2Fprint_type_sizes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fprint_type_sizes.rs?ref=9383fcf07f85d8e8b91a6150cf4ca252b37a5383", "patch": "@@ -1,152 +0,0 @@\n-// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! This pass implements instrumentation to gather the layout of every type.\n-\n-use rustc::session::{VariantSize};\n-use rustc::traits::{Reveal};\n-use rustc::ty::{self, Ty, TyCtxt};\n-use rustc::ty::fold::{TypeFoldable};\n-use rustc::ty::layout::{Layout};\n-use rustc::mir::{Mir};\n-use rustc::mir::transform::{MirPass, MirPassHook, MirSource, Pass};\n-use rustc::mir::visit::Visitor;\n-\n-use std::collections::HashSet;\n-\n-pub struct GatherTypeSizesMir {\n-    _hidden: (),\n-}\n-\n-impl GatherTypeSizesMir {\n-    pub fn new() -> Self {\n-        GatherTypeSizesMir { _hidden: () }\n-    }\n-}\n-\n-impl Pass for GatherTypeSizesMir {\n-}\n-\n-impl<'tcx> MirPassHook<'tcx> for GatherTypeSizesMir {\n-    fn on_mir_pass<'a>(&mut self,\n-                       tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                       src: MirSource,\n-                       mir: &Mir<'tcx>,\n-                       _pass: &Pass,\n-                       _is_after: bool) {\n-        debug!(\"on_mir_pass: {}\", tcx.node_path_str(src.item_id()));\n-        self.go(tcx, mir);\n-    }\n-}\n-\n-impl<'tcx> MirPass<'tcx> for GatherTypeSizesMir {\n-    fn run_pass<'a>(&mut self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                    src: MirSource, mir: &mut Mir<'tcx>) {\n-        debug!(\"run_pass: {}\", tcx.node_path_str(src.item_id()));\n-        self.go(tcx, mir);\n-    }\n-}\n-\n-impl GatherTypeSizesMir {\n-    fn go<'a, 'tcx>(&mut self,\n-                    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                    mir: &Mir<'tcx>) {\n-        if tcx.sess.err_count() > 0 {\n-            // compiling a broken program can obviously result in a\n-            // broken MIR, so do not bother trying to process it.\n-            return;\n-        }\n-\n-        let mut visitor = TypeVisitor {\n-            tcx: tcx,\n-            seen: HashSet::new(),\n-        };\n-        visitor.visit_mir(mir);\n-    }\n-}\n-\n-struct TypeVisitor<'a, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    seen: HashSet<Ty<'tcx>>,\n-}\n-\n-impl<'a, 'tcx: 'a> Visitor<'tcx> for TypeVisitor<'a, 'tcx> {\n-    fn visit_ty(&mut self, ty: &Ty<'tcx>) {\n-        debug!(\"TypeVisitor::visit_ty ty=`{:?}`\", ty);\n-\n-        match ty.sty {\n-            ty::TyAdt(..) |\n-            ty::TyClosure(..) => {} // fall through\n-            _ => {\n-                debug!(\"print-type-size t: `{:?}` skip non-nominal\", ty);\n-                return;\n-            }\n-        }\n-\n-        if ty.has_param_types() {\n-            debug!(\"print-type-size t: `{:?}` skip has param types\", ty);\n-            return;\n-        }\n-        if ty.has_projection_types() {\n-            debug!(\"print-type-size t: `{:?}` skip has projections\", ty);\n-            return;\n-        }\n-\n-        if self.seen.contains(ty) {\n-            return;\n-        }\n-        self.seen.insert(ty);\n-\n-        let reveal = Reveal::All;\n-        // let reveal = Reveal::NotSpecializable;\n-\n-        self.tcx.infer_ctxt(None, None, reveal).enter(|infcx| {\n-            match ty.layout(&infcx) {\n-                Ok(layout) => {\n-                    let type_desc = format!(\"{:?}\", ty);\n-                    let overall_size = layout.size(&Default::default());\n-\n-                    let variant_sizes: Vec<_> = match *layout {\n-                        Layout::General { ref variants, .. } => {\n-                            variants.iter()\n-                                .map(|v| if v.sized {\n-                                    VariantSize::Exact(v.min_size.bytes())\n-                                } else {\n-                                    VariantSize::Min(v.min_size.bytes())\n-                                })\n-                                .collect()\n-                        }\n-\n-                        Layout::UntaggedUnion { variants: _ } => {\n-                            /* layout does not currently store info about each variant... */\n-                            Vec::new()\n-                        }\n-\n-                        // RawNullablePointer/StructWrappedNullablePointer\n-                        // don't provide any interesting size info\n-                        // beyond what we already reported for their\n-                        // total size.\n-                        _ => {\n-                            Vec::new()\n-                        }\n-                    };\n-\n-                    self.tcx.sess.code_stats.borrow_mut()\n-                        .record_type_size(type_desc,\n-                                          overall_size.bytes(),\n-                                          variant_sizes);\n-                }\n-                Err(err) => {\n-                    self.tcx.sess.warn(&format!(\"print-type-size t: `{:?}` err: {:?}\", ty, err));\n-                }\n-            }\n-        });\n-    }\n-}"}, {"sha": "e091ba07d4feaffd7f76dae85eedb3934f8e362c", "filename": "src/librustc_trans/adt.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/70e5ca2ab49ca31485780f6fa981c5164b2cc848/src%2Flibrustc_trans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70e5ca2ab49ca31485780f6fa981c5164b2cc848/src%2Flibrustc_trans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fadt.rs?ref=70e5ca2ab49ca31485780f6fa981c5164b2cc848", "patch": "@@ -247,6 +247,7 @@ fn generic_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             // of the size.\n             let size = size.bytes();\n             let align = align.abi();\n+            assert!(align <= std::u32::MAX as u64);\n             let discr_ty = Type::from_integer(cx, discr);\n             let discr_size = discr.size().bytes();\n             let padded_discr_size = roundup(discr_size, align as u32);"}, {"sha": "d697a5bafb79ed5a6d9503fb88269c5fdb6fabab", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 192, "deletions": 1, "changes": 193, "blob_url": "https://github.com/rust-lang/rust/blob/70e5ca2ab49ca31485780f6fa981c5164b2cc848/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70e5ca2ab49ca31485780f6fa981c5164b2cc848/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=70e5ca2ab49ca31485780f6fa981c5164b2cc848", "patch": "@@ -47,7 +47,7 @@ use rustc::hir::map as hir_map;\n use rustc::util::common::time;\n use session::config::{self, NoDebugInfo};\n use rustc_incremental::IncrementalHashesMap;\n-use session::Session;\n+use session::{self, DataTypeKind, Session};\n use abi::{self, Abi, FnType};\n use adt;\n use attributes;\n@@ -93,6 +93,7 @@ use std::i32;\n use syntax_pos::{Span, DUMMY_SP};\n use syntax::attr;\n use rustc::hir;\n+use rustc::ty::layout::{self, Layout};\n use syntax::ast;\n \n thread_local! {\n@@ -1741,6 +1742,10 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                               .collect())\n     });\n \n+    if tcx.sess.opts.debugging_opts.print_type_sizes {\n+        gather_type_sizes(tcx);\n+    }\n+\n     if sess.target.target.options.is_like_msvc &&\n        sess.crate_types.borrow().iter().any(|ct| *ct == config::CrateTypeRlib) {\n         create_imps(&crate_context_list);\n@@ -1771,6 +1776,192 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     }\n }\n \n+fn gather_type_sizes<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n+    let layout_cache = tcx.layout_cache.borrow();\n+    for (ty, layout) in layout_cache.iter() {\n+\n+        // (delay format until we actually need it)\n+        let record = |kind, opt_discr_size, variants| {\n+            let type_desc = format!(\"{:?}\", ty);\n+            let overall_size = layout.size(&tcx.data_layout);\n+            let align = layout.align(&tcx.data_layout);\n+            tcx.sess.code_stats.borrow_mut().record_type_size(kind,\n+                                                              type_desc,\n+                                                              align,\n+                                                              overall_size,\n+                                                              opt_discr_size,\n+                                                              variants);\n+        };\n+\n+        let (adt_def, substs) = match ty.sty {\n+            ty::TyAdt(ref adt_def, substs) => {\n+                debug!(\"print-type-size t: `{:?}` process adt\", ty);\n+                (adt_def, substs)\n+            }\n+\n+            ty::TyClosure(..) => {\n+                debug!(\"print-type-size t: `{:?}` record closure\", ty);\n+                record(DataTypeKind::Closure, None, vec![]);\n+                continue;\n+            }\n+\n+            _ => {\n+                debug!(\"print-type-size t: `{:?}` skip non-nominal\", ty);\n+                continue;\n+            }\n+        };\n+\n+        let adt_kind = adt_def.adt_kind();\n+\n+        let build_field_info = |(field_name, field_ty): (ast::Name, Ty), offset: &layout::Size| {\n+            match layout_cache.get(&field_ty) {\n+                None => bug!(\"no layout found for field {} type: `{:?}`\", field_name, field_ty),\n+                Some(field_layout) => {\n+                    session::FieldInfo {\n+                        name: field_name.to_string(),\n+                        offset: offset.bytes(),\n+                        size: field_layout.size(&tcx.data_layout).bytes(),\n+                        align: field_layout.align(&tcx.data_layout).abi(),\n+                    }\n+                }\n+            }\n+        };\n+\n+        let build_primitive_info = |name: ast::Name, value: &layout::Primitive| {\n+            session::VariantInfo {\n+                name: Some(name.to_string()),\n+                kind: session::SizeKind::Exact,\n+                align: value.align(&tcx.data_layout).abi(),\n+                size: value.size(&tcx.data_layout).bytes(),\n+                fields: vec![],\n+            }\n+        };\n+\n+        enum Fields<'a> {\n+            WithDiscrim(&'a layout::Struct),\n+            NoDiscrim(&'a layout::Struct),\n+        }\n+\n+        let build_variant_info = |n: Option<ast::Name>, flds: &[(ast::Name, Ty)], layout: Fields| {\n+            let (s, field_offsets) = match layout {\n+                Fields::WithDiscrim(s) => (s, &s.offsets[1..]),\n+                Fields::NoDiscrim(s) => (s, &s.offsets[0..]),\n+            };\n+            let field_info: Vec<_> = flds.iter()\n+                .zip(field_offsets.iter())\n+                .map(|(&field_name_ty, offset)| build_field_info(field_name_ty, offset))\n+                .collect();\n+\n+            session::VariantInfo {\n+                name: n.map(|n|n.to_string()),\n+                kind: if s.sized {\n+                    session::SizeKind::Exact\n+                } else {\n+                    session::SizeKind::Min\n+                },\n+                align: s.align.abi(),\n+                size: s.min_size.bytes(),\n+                fields: field_info,\n+            }\n+        };\n+\n+        match **layout {\n+            Layout::StructWrappedNullablePointer { nonnull: ref variant_layout,\n+                                                   nndiscr,\n+                                                   discrfield: _ } => {\n+                debug!(\"print-type-size t: `{:?}` adt struct-wrapped nullable nndiscr {} is {:?}\",\n+                       ty, nndiscr, variant_layout);\n+                let variant_def = &adt_def.variants[nndiscr as usize];\n+                let fields: Vec<_> = variant_def.fields.iter()\n+                    .map(|field_def| (field_def.name, field_def.ty(tcx, substs)))\n+                    .collect();\n+                record(adt_kind.into(),\n+                       None,\n+                       vec![build_variant_info(Some(variant_def.name),\n+                                               &fields,\n+                                               Fields::NoDiscrim(variant_layout))]);\n+            }\n+            Layout::RawNullablePointer { nndiscr, value } => {\n+                debug!(\"print-type-size t: `{:?}` adt raw nullable nndiscr {} is {:?}\",\n+                       ty, nndiscr, value);\n+                let variant_def = &adt_def.variants[nndiscr as usize];\n+                record(adt_kind.into(), None,\n+                       vec![build_primitive_info(variant_def.name, &value)]);\n+            }\n+            Layout::Univariant { variant: ref variant_layout, non_zero: _ } => {\n+                let variant_names = || {\n+                    adt_def.variants.iter().map(|v|format!(\"{}\", v.name)).collect::<Vec<_>>()\n+                };\n+                debug!(\"print-type-size t: `{:?}` adt univariant {:?} variants: {:?}\",\n+                       ty, variant_layout, variant_names());\n+                assert!(adt_def.variants.len() <= 1,\n+                        \"univariant with variants {:?}\", variant_names());\n+                if adt_def.variants.len() == 1 {\n+                    let variant_def = &adt_def.variants[0];\n+                    let fields: Vec<_> = variant_def.fields.iter()\n+                        .map(|field_def| (field_def.name, field_def.ty(tcx, substs)))\n+                        .collect();\n+                    record(adt_kind.into(),\n+                           None,\n+                           vec![build_variant_info(Some(variant_def.name),\n+                                                   &fields,\n+                                                   Fields::NoDiscrim(variant_layout))]);\n+                } else {\n+                    // (This case arises for *empty* enums; so give it\n+                    // zero variants.)\n+                    record(adt_kind.into(), None, vec![]);\n+                }\n+            }\n+\n+            Layout::General { ref variants, discr, .. } => {\n+                debug!(\"print-type-size t: `{:?}` adt general variants def {} layouts {} {:?}\",\n+                       ty, adt_def.variants.len(), variants.len(), variants);\n+                let variant_infos: Vec<_> = adt_def.variants.iter()\n+                    .zip(variants.iter())\n+                    .map(|(variant_def, variant_layout)| {\n+                        let fields: Vec<_> = variant_def.fields.iter()\n+                            .map(|field_def| (field_def.name, field_def.ty(tcx, substs)))\n+                            .collect();\n+                        build_variant_info(Some(variant_def.name),\n+                                           &fields,\n+                                           Fields::WithDiscrim(variant_layout))\n+                    })\n+                    .collect();\n+                record(adt_kind.into(), Some(discr.size()), variant_infos);\n+            }\n+\n+            Layout::UntaggedUnion { ref variants } => {\n+                debug!(\"print-type-size t: `{:?}` adt union variants {:?}\",\n+                       ty, variants);\n+                // layout does not currently store info about each\n+                // variant...\n+                record(adt_kind.into(), None, Vec::new());\n+            }\n+\n+            Layout::CEnum { discr, .. } => {\n+                debug!(\"print-type-size t: `{:?}` adt c-like enum\", ty);\n+                let variant_infos: Vec<_> = adt_def.variants.iter()\n+                    .map(|variant_def| {\n+                        build_primitive_info(variant_def.name,\n+                                             &layout::Primitive::Int(discr))\n+                    })\n+                    .collect();\n+                record(adt_kind.into(), Some(discr.size()), variant_infos);\n+            }\n+\n+            // other cases provide little interesting (i.e. adjustable\n+            // via representation tweaks) size info beyond total size.\n+            Layout::Scalar { .. } |\n+            Layout::Vector { .. } |\n+            Layout::Array { .. } |\n+            Layout::FatPointer { .. } => {\n+                debug!(\"print-type-size t: `{:?}` adt other\", ty);\n+                record(adt_kind.into(), None, Vec::new())\n+            }\n+        }\n+    }\n+}\n+\n /// For each CGU, identify if we can reuse an existing object file (or\n /// maybe other context).\n fn trans_reuse_previous_work_products(tcx: TyCtxt,"}]}