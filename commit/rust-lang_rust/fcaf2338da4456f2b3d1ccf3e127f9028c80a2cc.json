{"sha": "fcaf2338da4456f2b3d1ccf3e127f9028c80a2cc", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZjYWYyMzM4ZGE0NDU2ZjJiM2QxY2NmM2UxMjdmOTAyOGM4MGEyY2M=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2020-10-21T07:47:15Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2020-10-21T07:47:15Z"}, "message": "Miri engine interning: improve comments, and entirely skip ZST", "tree": {"sha": "7e06be248a666f26e68307182e14e1d4a9f5f5c6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7e06be248a666f26e68307182e14e1d4a9f5f5c6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fcaf2338da4456f2b3d1ccf3e127f9028c80a2cc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fcaf2338da4456f2b3d1ccf3e127f9028c80a2cc", "html_url": "https://github.com/rust-lang/rust/commit/fcaf2338da4456f2b3d1ccf3e127f9028c80a2cc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fcaf2338da4456f2b3d1ccf3e127f9028c80a2cc/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "22026538931f7349a1b78d7644b0288ff3282db2", "url": "https://api.github.com/repos/rust-lang/rust/commits/22026538931f7349a1b78d7644b0288ff3282db2", "html_url": "https://github.com/rust-lang/rust/commit/22026538931f7349a1b78d7644b0288ff3282db2"}], "stats": {"total": 28, "additions": 17, "deletions": 11}, "files": [{"sha": "846ca18990022470b82616b13a1241ebeac3f8ba", "filename": "compiler/rustc_mir/src/interpret/intern.rs", "status": "modified", "additions": 17, "deletions": 11, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/fcaf2338da4456f2b3d1ccf3e127f9028c80a2cc/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fintern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fcaf2338da4456f2b3d1ccf3e127f9028c80a2cc/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fintern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fintern.rs?ref=fcaf2338da4456f2b3d1ccf3e127f9028c80a2cc", "patch": "@@ -33,8 +33,9 @@ struct InternVisitor<'rt, 'mir, 'tcx, M: CompileTimeMachine<'mir, 'tcx>> {\n     /// A list of all encountered allocations. After type-based interning, we traverse this list to\n     /// also intern allocations that are only referenced by a raw pointer or inside a union.\n     leftover_allocations: &'rt mut FxHashSet<AllocId>,\n-    /// The root kind of the value that we're looking at. This field is never mutated and only used\n-    /// for sanity assertions that will ICE when `const_qualif` screws up.\n+    /// The root kind of the value that we're looking at. This field is never mutated for a\n+    /// particular allocation. It is primarily used to make as many allocations as possible\n+    /// read-only so LLVM can place them in const memory.\n     mode: InternMode,\n     /// This field stores whether we are *currently* inside an `UnsafeCell`. This can affect\n     /// the intern mode of references we encounter.\n@@ -113,8 +114,8 @@ fn intern_shallow<'rt, 'mir, 'tcx, M: CompileTimeMachine<'mir, 'tcx>>(\n         // For this, we need to take into account `UnsafeCell`. When `ty` is `None`, we assume\n         // no interior mutability.\n         let frozen = ty.map_or(true, |ty| ty.is_freeze(ecx.tcx, ecx.param_env));\n-        // For statics, allocation mutability is the combination of the place mutability and\n-        // the type mutability.\n+        // For statics, allocation mutability is the combination of place mutability and\n+        // type mutability.\n         // The entire allocation needs to be mutable if it contains an `UnsafeCell` anywhere.\n         let immutable = mutability == Mutability::Not && frozen;\n         if immutable {\n@@ -188,8 +189,8 @@ impl<'rt, 'mir, 'tcx: 'mir, M: CompileTimeMachine<'mir, 'tcx>> ValueVisitor<'mir\n             }\n         }\n \n-        // ZSTs do not need validation unless they're uninhabited\n-        if mplace.layout.is_zst() && !mplace.layout.abi.is_uninhabited() {\n+        // ZSTs cannot contain pointers, so we can skip them.\n+        if mplace.layout.is_zst() {\n             return Ok(());\n         }\n \n@@ -209,13 +210,12 @@ impl<'rt, 'mir, 'tcx: 'mir, M: CompileTimeMachine<'mir, 'tcx>> ValueVisitor<'mir\n             if let ty::Dynamic(..) =\n                 tcx.struct_tail_erasing_lifetimes(referenced_ty, self.ecx.param_env).kind()\n             {\n-                // Validation will error (with a better message) on an invalid vtable pointer\n-                // so we can safely not do anything if this is not a real pointer.\n                 if let Scalar::Ptr(vtable) = mplace.meta.unwrap_meta() {\n                     // Explicitly choose const mode here, since vtables are immutable, even\n                     // if the reference of the fat pointer is mutable.\n                     self.intern_shallow(vtable.alloc_id, InternMode::ConstInner, None);\n                 } else {\n+                    // Validation will error (with a better message) on an invalid vtable pointer.\n                     // Let validation show the error message, but make sure it *does* error.\n                     tcx.sess\n                         .delay_span_bug(tcx.span, \"vtables pointers cannot be integer pointers\");\n@@ -224,7 +224,8 @@ impl<'rt, 'mir, 'tcx: 'mir, M: CompileTimeMachine<'mir, 'tcx>> ValueVisitor<'mir\n             // Check if we have encountered this pointer+layout combination before.\n             // Only recurse for allocation-backed pointers.\n             if let Scalar::Ptr(ptr) = mplace.ptr {\n-                // Compute the mode with which we intern this.\n+                // Compute the mode with which we intern this. Our goal here is to make as many\n+                // statics as we can immutable so they can be placed in const memory by LLVM.\n                 let ref_mode = match self.mode {\n                     InternMode::Static(mutbl) => {\n                         // In statics, merge outer mutability with reference mutability and\n@@ -243,8 +244,13 @@ impl<'rt, 'mir, 'tcx: 'mir, M: CompileTimeMachine<'mir, 'tcx>> ValueVisitor<'mir\n                             }\n                             Mutability::Not => {\n                                 // A shared reference, things become immutable.\n-                                // We do *not* consier `freeze` here -- that is done more precisely\n-                                // when traversing the referenced data (by tracking `UnsafeCell`).\n+                                // We do *not* consider `freeze` here: `intern_shallow` considers\n+                                // `freeze` for the actual mutability of this allocation; the intern\n+                                // mode for references contained in this allocation is tracked more\n+                                // precisely when traversing the referenced data (by tracking\n+                                // `UnsafeCell`). This makes sure that `&(&i32, &Cell<i32>)` still\n+                                // has the left inner reference interned into a read-only\n+                                // allocation.\n                                 InternMode::Static(Mutability::Not)\n                             }\n                             Mutability::Mut => {"}]}