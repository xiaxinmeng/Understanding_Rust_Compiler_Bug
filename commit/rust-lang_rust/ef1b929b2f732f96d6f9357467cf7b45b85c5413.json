{"sha": "ef1b929b2f732f96d6f9357467cf7b45b85c5413", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVmMWI5MjliMmY3MzJmOTZkNmY5MzU3NDY3Y2Y3YjQ1Yjg1YzU0MTM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-04-22T10:16:33Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-04-22T10:16:33Z"}, "message": "auto merge of #13646 : cgaebel/rust/hashmap-cleanup, r=alexcrichton\n\nI went through the HashMap module, fixed spelling mistakes, minor inefficiencies, added tests, and other trivial changes. Hopefully this won't be a controversial PR.", "tree": {"sha": "4ca52f945e3dd5cf190ab924b281fddfe87cbecd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4ca52f945e3dd5cf190ab924b281fddfe87cbecd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ef1b929b2f732f96d6f9357467cf7b45b85c5413", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ef1b929b2f732f96d6f9357467cf7b45b85c5413", "html_url": "https://github.com/rust-lang/rust/commit/ef1b929b2f732f96d6f9357467cf7b45b85c5413", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ef1b929b2f732f96d6f9357467cf7b45b85c5413/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a5cd502e47ad99da87c328c1895e88d75cf702ff", "url": "https://api.github.com/repos/rust-lang/rust/commits/a5cd502e47ad99da87c328c1895e88d75cf702ff", "html_url": "https://github.com/rust-lang/rust/commit/a5cd502e47ad99da87c328c1895e88d75cf702ff"}, {"sha": "65d56612bb2e0427ef42ec366977318c10d41539", "url": "https://api.github.com/repos/rust-lang/rust/commits/65d56612bb2e0427ef42ec366977318c10d41539", "html_url": "https://github.com/rust-lang/rust/commit/65d56612bb2e0427ef42ec366977318c10d41539"}], "stats": {"total": 280, "additions": 168, "deletions": 112}, "files": [{"sha": "5b65fe460892587591fe228ba7b958631ec75a0d", "filename": "src/libcollections/hashmap.rs", "status": "modified", "additions": 168, "deletions": 112, "changes": 280, "blob_url": "https://github.com/rust-lang/rust/blob/ef1b929b2f732f96d6f9357467cf7b45b85c5413/src%2Flibcollections%2Fhashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef1b929b2f732f96d6f9357467cf7b45b85c5413/src%2Flibcollections%2Fhashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fhashmap.rs?ref=ef1b929b2f732f96d6f9357467cf7b45b85c5413", "patch": "@@ -43,7 +43,8 @@ mod table {\n     use std::ptr;\n     use std::ptr::RawPtr;\n     use std::rt::global_heap;\n-    use std::intrinsics::{size_of, min_align_of, transmute, move_val_init};\n+    use std::intrinsics::{size_of, min_align_of, transmute};\n+    use std::intrinsics::{move_val_init, set_memory};\n     use std::iter::{Iterator, range_step_inclusive};\n \n     static EMPTY_BUCKET: u64 = 0u64;\n@@ -52,15 +53,15 @@ mod table {\n     /// optimized arrays of hashes, keys, and values.\n     ///\n     /// This design uses less memory and is a lot faster than the naive\n-    /// `~[Option<u64, K, V>]`, because we don't pay for the overhead of an\n+    /// `Vec<Option<u64, K, V>>`, because we don't pay for the overhead of an\n     /// option on every element, and we get a generally more cache-aware design.\n     ///\n     /// Key invariants of this structure:\n     ///\n     ///   - if hashes[i] == EMPTY_BUCKET, then keys[i] and vals[i] have\n     ///     'undefined' contents. Don't read from them. This invariant is\n-    ///     enforced outside this module with the [EmptyIndex], [FullIndex],\n-    ///     and [SafeHash] types/concepts.\n+    ///     enforced outside this module with the `EmptyIndex`, `FullIndex`,\n+    ///     and `SafeHash` types.\n     ///\n     ///   - An `EmptyIndex` is only constructed for a bucket at an index with\n     ///     a hash of EMPTY_BUCKET.\n@@ -69,8 +70,9 @@ mod table {\n     ///     non-EMPTY_BUCKET hash.\n     ///\n     ///   - A `SafeHash` is only constructed for non-`EMPTY_BUCKET` hash. We get\n-    ///     around hashes of zero by changing them to 0x800_0000, which will\n-    ///     likely hash to the same bucket, but not be represented as \"empty\".\n+    ///     around hashes of zero by changing them to 0x8000_0000_0000_0000,\n+    ///     which will likely map to the same bucket, while not being confused\n+    ///     with \"empty\".\n     ///\n     ///   - All three \"arrays represented by pointers\" are the same length:\n     ///     `capacity`. This is set at creation and never changes. The arrays\n@@ -111,25 +113,27 @@ mod table {\n \n     /// Represents an index into a `RawTable` with no key or value in it.\n     pub struct EmptyIndex {\n-        idx:   int,\n+        idx:    int,\n         nocopy: marker::NoCopy,\n     }\n \n     /// Represents an index into a `RawTable` with a key, value, and hash\n     /// in it.\n     pub struct FullIndex {\n-        idx:   int,\n-        hash:  SafeHash,\n+        idx:    int,\n+        hash:   SafeHash,\n         nocopy: marker::NoCopy,\n     }\n \n     impl FullIndex {\n         /// Since we get the hash for free whenever we check the bucket state,\n-        /// this function is provided for fast access, letting us avoid making\n+        /// this function is provided for fast access, letting us avoid\n         /// redundant trips back to the hashtable.\n+        #[inline(always)]\n         pub fn hash(&self) -> SafeHash { self.hash }\n \n         /// Same comment as with `hash`.\n+        #[inline(always)]\n         pub fn raw_index(&self) -> uint { self.idx as uint }\n     }\n \n@@ -141,14 +145,16 @@ mod table {\n         Full(FullIndex),\n     }\n \n-    /// A hash that is not zero, since we use that to represent empty buckets.\n+    /// A hash that is not zero, since we use a hash of zero to represent empty\n+    /// buckets.\n     #[deriving(Eq)]\n     pub struct SafeHash {\n         hash: u64,\n     }\n \n     impl SafeHash {\n         /// Peek at the hash value, which is guaranteed to be non-zero.\n+        #[inline(always)]\n         pub fn inspect(&self) -> u64 { self.hash }\n     }\n \n@@ -171,12 +177,16 @@ mod table {\n \n     #[test]\n     fn test_rounding() {\n-        assert!(round_up_to_next(0, 4) == 0);\n-        assert!(round_up_to_next(1, 4) == 4);\n-        assert!(round_up_to_next(2, 4) == 4);\n-        assert!(round_up_to_next(3, 4) == 4);\n-        assert!(round_up_to_next(4, 4) == 4);\n-        assert!(round_up_to_next(5, 4) == 8);\n+        assert_eq!(round_up_to_next(0, 4), 0);\n+        assert_eq!(round_up_to_next(1, 4), 4);\n+        assert_eq!(round_up_to_next(2, 4), 4);\n+        assert_eq!(round_up_to_next(3, 4), 4);\n+        assert_eq!(round_up_to_next(4, 4), 4);\n+        assert_eq!(round_up_to_next(5, 4), 8);\n+    }\n+\n+    fn has_alignment(n: uint, alignment: uint) -> bool {\n+        round_up_to_next(n, alignment) == n\n     }\n \n     // Returns a tuple of (minimum required malloc alignment, hash_offset,\n@@ -200,6 +210,13 @@ mod table {\n         (min_align, hash_offset, keys_offset, vals_offset, end_of_vals)\n     }\n \n+    #[test]\n+    fn test_offset_calculation() {\n+        assert_eq!(calculate_offsets(128, 8, 15, 1, 4, 4 ), (8, 0, 128, 144, 148));\n+        assert_eq!(calculate_offsets(3,   1, 2,  1, 1, 1 ), (1, 0, 3,   5,   6));\n+        assert_eq!(calculate_offsets(6,   2, 12, 4, 24, 8), (8, 0, 8,   24,  48));\n+    }\n+\n     impl<K, V> RawTable<K, V> {\n \n         /// Does not initialize the buckets. The caller should ensure they,\n@@ -213,9 +230,9 @@ mod table {\n                 capacity.checked_mul(&size_of::< V >()).expect(\"capacity overflow\");\n \n             // Allocating hashmaps is a little tricky. We need to allocate three\n-            // arrays here, but since we know their sizes and alignments up front,\n-            // we could theoretically allocate only a single array, and then have\n-            // the subarrays just point into it.\n+            // arrays, but since we know their sizes and alignments up front,\n+            // we just allocate a single array, and then have the subarrays\n+            // point into it.\n             //\n             // This is great in theory, but in practice getting the alignment\n             // right is a little subtle. Therefore, calculating offsets has been\n@@ -231,8 +248,7 @@ mod table {\n             // FIXME #13094: If malloc was not at as aligned as we expected,\n             // our offset calculations are just plain wrong. We could support\n             // any alignment if we switched from `malloc` to `posix_memalign`.\n-            assert!(round_up_to_next(buffer as uint, malloc_alignment)\n-                == (buffer as uint));\n+            assert!(has_alignment(buffer as uint, malloc_alignment));\n \n             let hashes = buffer.offset(hash_offset as int) as *mut u64;\n             let keys   = buffer.offset(keys_offset as int) as *mut K;\n@@ -247,26 +263,20 @@ mod table {\n             }\n         }\n \n-\n-\n         /// Creates a new raw table from a given capacity. All buckets are\n         /// initially empty.\n         pub fn new(capacity: uint) -> RawTable<K, V> {\n             unsafe {\n                 let ret = RawTable::new_uninitialized(capacity);\n-\n-                for i in range(0, ret.capacity() as int) {\n-                    *ret.hashes.offset(i) = EMPTY_BUCKET;\n-                }\n-\n+                set_memory(ret.hashes, 0u8, capacity);\n                 ret\n             }\n         }\n \n         /// Reads a bucket at a given index, returning an enum indicating whether\n         /// there's anything there or not. You need to match on this enum to get\n-        /// the appropriate types to pass on to most of the rest of the functions\n-        /// in this module.\n+        /// the appropriate types to pass on to most of the other functions in\n+        /// this module.\n         pub fn peek(&self, index: uint) -> BucketState {\n             // FIXME #12049\n             if cfg!(test) { assert!(index < self.capacity) }\n@@ -279,13 +289,13 @@ mod table {\n             match hash {\n                 EMPTY_BUCKET =>\n                     Empty(EmptyIndex {\n-                        idx: idx,\n+                        idx:    idx,\n                         nocopy: nocopy\n                     }),\n                 full_hash =>\n                     Full(FullIndex {\n-                        idx:   idx,\n-                        hash:  SafeHash { hash: full_hash },\n+                        idx:    idx,\n+                        hash:   SafeHash { hash: full_hash },\n                         nocopy: nocopy,\n                     })\n             }\n@@ -321,13 +331,6 @@ mod table {\n             -> (&'a mut SafeHash, &'a mut K, &'a mut V) {\n             let idx = index.idx;\n \n-            // I'm totally abusing the fact that a pointer to any u64 in the\n-            // hashtable at a full index is a safe hash. Thanks to `SafeHash`\n-            // just being a wrapper around u64, this is true. It's just really\n-            // really really really unsafe. However, the exposed API is now\n-            // impossible to get wrong. You cannot insert an empty hash into\n-            // this slot now.\n-\n             unsafe {\n                 // FIXME #12049\n                 if cfg!(test) { assert!(*self.hashes.offset(idx) != EMPTY_BUCKET) }\n@@ -340,16 +343,16 @@ mod table {\n         /// Puts a key and value pair, along with the key's hash, into a given\n         /// index in the hashtable. Note how the `EmptyIndex` is 'moved' into this\n         /// function, because that slot will no longer be empty when we return!\n-        /// Because we know this, a FullIndex is returned for later use, pointing\n-        /// to the newly-filled slot in the hashtable.\n+        /// A FullIndex is returned for later use, pointing to the newly-filled\n+        /// slot in the hashtable.\n         ///\n         /// Use `make_hash` to construct a `SafeHash` to pass to this function.\n         pub fn put(&mut self, index: EmptyIndex, hash: SafeHash, k: K, v: V) -> FullIndex {\n             let idx = index.idx;\n \n             unsafe {\n                 // FIXME #12049\n-                if cfg!(test) { assert!(*self.hashes.offset(idx) == EMPTY_BUCKET) }\n+                if cfg!(test) { assert_eq!(*self.hashes.offset(idx), EMPTY_BUCKET) }\n                 *self.hashes.offset(idx) = hash.inspect();\n                 move_val_init(&mut *self.keys.offset(idx), k);\n                 move_val_init(&mut *self.vals.offset(idx), v);\n@@ -371,9 +374,7 @@ mod table {\n                 // FIXME #12049\n                 if cfg!(test) { assert!(*self.hashes.offset(idx) != EMPTY_BUCKET) }\n \n-                let hash_ptr = self.hashes.offset(idx);\n-\n-                *hash_ptr = EMPTY_BUCKET;\n+                *self.hashes.offset(idx) = EMPTY_BUCKET;\n \n                 // Drop the mutable constraint.\n                 let keys = self.keys as *K;\n@@ -400,31 +401,48 @@ mod table {\n         }\n \n         pub fn iter<'a>(&'a self) -> Entries<'a, K, V> {\n-            Entries { table: self, idx: 0 }\n+            Entries { table: self, idx: 0, elems_seen: 0 }\n         }\n \n         pub fn mut_iter<'a>(&'a mut self) -> MutEntries<'a, K, V> {\n-            MutEntries { table: self, idx: 0 }\n+            MutEntries { table: self, idx: 0, elems_seen: 0 }\n         }\n \n         pub fn move_iter(self) -> MoveEntries<K, V> {\n-            MoveEntries { table: self, idx: 0 }\n+            MoveEntries { table: self, idx: 0, elems_seen: 0 }\n         }\n     }\n \n+    // `read_all_mut` casts a `*u64` to a `*SafeHash`. Since we statically\n+    // ensure that a `FullIndex` points to an index with a non-zero hash,\n+    // and a `SafeHash` is just a `u64` with a different name, this is\n+    // safe.\n+    //\n+    // This test ensures that a `SafeHash` really IS the same size as a\n+    // `u64`. If you need to change the size of `SafeHash` (and\n+    // consequently made this test fail), `read_all_mut` needs to be\n+    // modified to no longer assume this.\n+    #[test]\n+    fn can_alias_safehash_as_u64() {\n+        unsafe { assert_eq!(size_of::<SafeHash>(), size_of::<u64>()) };\n+    }\n+\n     pub struct Entries<'a, K, V> {\n         table: &'a RawTable<K, V>,\n         idx: uint,\n+        elems_seen: uint,\n     }\n \n     pub struct MutEntries<'a, K, V> {\n         table: &'a mut RawTable<K, V>,\n         idx: uint,\n+        elems_seen: uint,\n     }\n \n     pub struct MoveEntries<K, V> {\n         table: RawTable<K, V>,\n         idx: uint,\n+        elems_seen: uint,\n     }\n \n     impl<'a, K, V> Iterator<(&'a K, &'a V)> for Entries<'a, K, V> {\n@@ -435,15 +453,18 @@ mod table {\n \n                 match self.table.peek(i) {\n                     Empty(_)  => {},\n-                    Full(idx) => return Some(self.table.read(&idx))\n+                    Full(idx) => {\n+                        self.elems_seen += 1;\n+                        return Some(self.table.read(&idx));\n+                    }\n                 }\n             }\n \n             None\n         }\n \n         fn size_hint(&self) -> (uint, Option<uint>) {\n-            let size = self.table.size() - self.idx;\n+            let size = self.table.size() - self.elems_seen;\n             (size, Some(size))\n         }\n     }\n@@ -460,7 +481,8 @@ mod table {\n                     // error: lifetime of `self` is too short to guarantee its contents\n                     //        can be safely reborrowed\n                     Full(idx) => unsafe {\n-                        return Some(transmute(self.table.read_mut(&idx)))\n+                        self.elems_seen += 1;\n+                        return Some(transmute(self.table.read_mut(&idx)));\n                     }\n                 }\n             }\n@@ -469,7 +491,7 @@ mod table {\n         }\n \n         fn size_hint(&self) -> (uint, Option<uint>) {\n-            let size = self.table.size() - self.idx;\n+            let size = self.table.size() - self.elems_seen;\n             (size, Some(size))\n         }\n     }\n@@ -526,18 +548,14 @@ mod table {\n         }\n     }\n \n-\n-\n     #[unsafe_destructor]\n     impl<K, V> Drop for RawTable<K, V> {\n         fn drop(&mut self) {\n-            // Ideally, this should be in reverse, since we're likely to have\n-            // partially taken some elements out with `.move_iter()` from the\n-            // front.\n+            // This is in reverse because we're likely to have partially taken\n+            // some elements out with `.move_iter()` from the front.\n             for i in range_step_inclusive(self.capacity as int - 1, 0, -1) {\n                 // Check if the size is 0, so we don't do a useless scan when\n                 // dropping empty tables such as on resize.\n-\n                 if self.size == 0 { break }\n \n                 match self.peek(i as uint) {\n@@ -546,7 +564,7 @@ mod table {\n                 }\n             }\n \n-            assert!(self.size == 0);\n+            assert_eq!(self.size, 0);\n \n             unsafe {\n                 libc::free(self.hashes as *mut libc::c_void);\n@@ -637,19 +655,12 @@ static INITIAL_LOAD_FACTOR: Fraction = (9, 10);\n // This would definitely be an avenue worth exploring if people start complaining\n // about the size of rust executables.\n //\n-// There's also two optimizations that have been omitted regarding how the\n-// hashtable allocates. The first is that a hashtable which never has an element\n-// inserted should not allocate. I'm suspicious of this one, because supporting\n-// that internally gains no performance over just using an\n-// `Option<HashMap<K, V>>`, and is significantly more complicated.\n-//\n-// The second omitted allocation optimization is that right now we allocate three\n-// arrays to back the hashtable. This is wasteful. In theory, we only need one\n-// array, and each of the three original arrays can just be slices of it. This\n-// would reduce the pressure on the allocator, and will play much nicer with the\n-// rest of the system. An initial implementation is commented out in\n-// `table::RawTable::new`, but I'm not confident it works for all sane alignments,\n-// especially if a type needs more alignment than `malloc` provides.\n+// There's also an \"optimization\" that has been omitted regarding how the\n+// hashtable allocates. The vector type has set the expectation that a hashtable\n+// which never has an element inserted should not allocate. I'm suspicious of\n+// implementing this for hashtables, because supporting it has no performance\n+// benefit over using an `Option<HashMap<K, V>>`, and is significantly more\n+// complicated.\n \n /// A hash map implementation which uses linear probing with Robin\n /// Hood bucket stealing.\n@@ -745,7 +756,7 @@ impl<K: TotalEq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     // This exploits the power-of-two size of the hashtable. As long as this\n     // is always true, we can use a bitmask of cap-1 to do modular arithmetic.\n     //\n-    // Prefer to use this with increasing values of `idx` rather than repeatedly\n+    // Prefer using this with increasing values of `idx` rather than repeatedly\n     // calling `probe_next`. This reduces data-dependencies between loops, which\n     // can help the optimizer, and certainly won't hurt it. `probe_next` is\n     // simply for convenience, and is no more efficient than `probe`.\n@@ -756,7 +767,7 @@ impl<K: TotalEq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n         ((hash.inspect() as uint) + idx) & hash_mask\n     }\n \n-    // Generate the next probe in a sequence. Prefer to use 'probe' by itself,\n+    // Generate the next probe in a sequence. Prefer using 'probe' by itself,\n     // but this can sometimes be useful.\n     fn probe_next(&self, probe: uint) -> uint {\n         let hash_mask = self.table.capacity() - 1;\n@@ -804,7 +815,7 @@ impl<K: TotalEq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n             if self.bucket_distance(&idx) < num_probes { return None }\n \n             // If the hash doesn't match, it can't be this one..\n-            if hash != &idx.hash() { continue }\n+            if *hash != idx.hash() { continue }\n \n             let (k, _) = self.table.read(&idx);\n \n@@ -1087,15 +1098,15 @@ impl<K: TotalEq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     ///   2) Ensure new_capacity is a power of two.\n     fn resize(&mut self, new_capacity: uint) {\n         assert!(self.table.size() <= new_capacity);\n-        assert!((new_capacity - 1) & new_capacity == 0);\n+        assert!(num::is_power_of_two(new_capacity));\n \n         self.grow_at = grow_at(new_capacity, self.load_factor);\n \n         let old_table = replace(&mut self.table, table::RawTable::new(new_capacity));\n         let old_size  = old_table.size();\n \n         for (h, k, v) in old_table.move_iter() {\n-            self.manual_insert_hashed_nocheck(h, k, v);\n+            self.insert_hashed_nocheck(h, k, v);\n         }\n \n         assert_eq!(self.table.size(), old_size);\n@@ -1171,13 +1182,13 @@ impl<K: TotalEq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n         }\n     }\n \n-    /// Manually insert a pre-hashed key-value pair, without first checking\n+    /// Insert a pre-hashed key-value pair, without first checking\n     /// that there's enough room in the buckets. Returns a reference to the\n     /// newly insert value.\n     ///\n     /// If the key already exists, the hashtable will be returned untouched\n     /// and a reference to the existing element will be returned.\n-    fn manual_insert_hashed_nocheck<'a>(\n+    fn insert_hashed_nocheck<'a>(\n         &'a mut self, hash: table::SafeHash, k: K, v: V) -> &'a mut V {\n \n         for dib in range_inclusive(0u, self.table.size()) {\n@@ -1226,43 +1237,41 @@ impl<K: TotalEq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n         fail!(\"Internal HashMap error: Out of space.\");\n     }\n \n-    fn manual_insert_hashed<'a>(&'a mut self, hash: table::SafeHash, k: K, v: V) -> &'a mut V {\n+    /// Inserts an element which has already been hashed, returning a reference\n+    /// to that element inside the hashtable. This is more efficient that using\n+    /// `insert`, since the key will not be rehashed.\n+    fn insert_hashed<'a>(&'a mut self, hash: table::SafeHash, k: K, v: V) -> &'a mut V {\n         let potential_new_size = self.table.size() + 1;\n         self.make_some_room(potential_new_size);\n-        self.manual_insert_hashed_nocheck(hash, k, v)\n-    }\n-\n-    /// Inserts an element, returning a reference to that element inside the\n-    /// hashtable.\n-    fn manual_insert<'a>(&'a mut self, k: K, v: V) -> &'a mut V {\n-        let hash = self.make_hash(&k);\n-        self.manual_insert_hashed(hash, k, v)\n+        self.insert_hashed_nocheck(hash, k, v)\n     }\n \n     /// Return the value corresponding to the key in the map, or insert\n     /// and return the value if it doesn't exist.\n     pub fn find_or_insert<'a>(&'a mut self, k: K, v: V) -> &'a mut V {\n-        match self.search(&k) {\n+        let hash = self.make_hash(&k);\n+        match self.search_hashed(&hash, &k) {\n             Some(idx) => {\n                 let (_, v_ref) = self.table.read_mut(&idx);\n                 v_ref\n             },\n-            None => self.manual_insert(k, v)\n+            None => self.insert_hashed(hash, k, v)\n         }\n     }\n \n     /// Return the value corresponding to the key in the map, or create,\n     /// insert, and return a new value if it doesn't exist.\n     pub fn find_or_insert_with<'a>(&'a mut self, k: K, f: |&K| -> V)\n                                -> &'a mut V {\n-        match self.search(&k) {\n+        let hash = self.make_hash(&k);\n+        match self.search_hashed(&hash, &k) {\n             Some(idx) => {\n                 let (_, v_ref) = self.table.read_mut(&idx);\n                 v_ref\n             },\n-            None      => {\n+            None => {\n                 let v = f(&k);\n-                self.manual_insert(k, v)\n+                self.insert_hashed(hash, k, v)\n             }\n         }\n     }\n@@ -1276,8 +1285,9 @@ impl<K: TotalEq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n                                  v: V,\n                                  f: |&K, &mut V|)\n                                  -> &'a mut V {\n-        match self.search(&k) {\n-            None      => self.manual_insert(k, v),\n+        let hash = self.make_hash(&k);\n+        match self.search_hashed(&hash, &k) {\n+            None      => self.insert_hashed(hash, k, v),\n             Some(idx) => {\n                 let (_, v_ref) = self.table.read_mut(&idx);\n                 f(&k, v_ref);\n@@ -1369,7 +1379,8 @@ impl<K: TotalEq + Hash<S>, V: Eq, S, H: Hasher<S>> Eq for HashMap<K, V, H> {\n     fn eq(&self, other: &HashMap<K, V, H>) -> bool {\n         if self.len() != other.len() { return false; }\n \n-        self.iter().all(|(key, value)| {\n+        self.iter()\n+          .all(|(key, value)| {\n             match other.find(key) {\n                 None    => false,\n                 Some(v) => *value == *v\n@@ -1393,7 +1404,7 @@ impl<K: TotalEq + Hash<S> + Show, V: Show, S, H: Hasher<S>> Show for HashMap<K,\n \n impl<K: TotalEq + Hash<S>, V, S, H: Hasher<S> + Default> Default for HashMap<K, V, H> {\n     fn default() -> HashMap<K, V, H> {\n-        HashMap::with_capacity_and_hasher(INITIAL_CAPACITY, Default::default())\n+        HashMap::with_hasher(Default::default())\n     }\n }\n \n@@ -1449,13 +1460,10 @@ pub struct HashSet<T, H = sip::SipHasher> {\n }\n \n impl<T: TotalEq + Hash<S>, S, H: Hasher<S>> Eq for HashSet<T, H> {\n-    // FIXME #11998: Since the value is a (), and `find` returns a Some(&()),\n-    // we trigger #11998 when matching on it. I've fallen back to manual\n-    // iteration until this is fixed.\n     fn eq(&self, other: &HashSet<T, H>) -> bool {\n         if self.len() != other.len() { return false; }\n \n-        self.iter().all(|key| other.map.contains_key(key))\n+        self.iter().all(|key| other.contains(key))\n     }\n }\n \n@@ -1468,7 +1476,7 @@ impl<T: TotalEq + Hash<S>, S, H: Hasher<S>> Mutable for HashSet<T, H> {\n }\n \n impl<T: TotalEq + Hash<S>, S, H: Hasher<S>> Set<T> for HashSet<T, H> {\n-    fn contains(&self, value: &T) -> bool { self.map.search(value).is_some() }\n+    fn contains(&self, value: &T) -> bool { self.map.contains_key(value) }\n \n     fn is_disjoint(&self, other: &HashSet<T, H>) -> bool {\n         self.iter().all(|v| !other.contains(v))\n@@ -1540,8 +1548,7 @@ impl<T: TotalEq + Hash<S>, S, H: Hasher<S>> HashSet<T, H> {\n \n     /// Visit the values representing the difference\n     pub fn difference<'a>(&'a self, other: &'a HashSet<T, H>) -> SetAlgebraItems<'a, T, H> {\n-        Repeat::new(other)\n-            .zip(self.iter())\n+        Repeat::new(other).zip(self.iter())\n             .filter_map(|(other, elt)| {\n                 if !other.contains(elt) { Some(elt) } else { None }\n             })\n@@ -1556,8 +1563,7 @@ impl<T: TotalEq + Hash<S>, S, H: Hasher<S>> HashSet<T, H> {\n     /// Visit the values representing the intersection\n     pub fn intersection<'a>(&'a self, other: &'a HashSet<T, H>)\n         -> SetAlgebraItems<'a, T, H> {\n-        Repeat::new(other)\n-            .zip(self.iter())\n+        Repeat::new(other).zip(self.iter())\n             .filter_map(|(other, elt)| {\n                 if other.contains(elt) { Some(elt) } else { None }\n             })\n@@ -1568,7 +1574,6 @@ impl<T: TotalEq + Hash<S>, S, H: Hasher<S>> HashSet<T, H> {\n         -> Chain<SetItems<'a, T>, SetAlgebraItems<'a, T, H>> {\n         self.iter().chain(other.difference(self))\n     }\n-\n }\n \n impl<T: TotalEq + Hash<S> + fmt::Show, S, H: Hasher<S>> fmt::Show for HashSet<T, H> {\n@@ -1953,7 +1958,7 @@ mod test_map {\n         m.insert(1, 2);\n         match m.find(&1) {\n             None => fail!(),\n-            Some(v) => assert!(*v == 2)\n+            Some(v) => assert_eq!(*v, 2)\n         }\n     }\n \n@@ -2020,6 +2025,32 @@ mod test_map {\n             assert_eq!(map.find(&k), Some(&v));\n         }\n     }\n+\n+    #[test]\n+    fn test_size_hint() {\n+        let xs = [(1, 1), (2, 2), (3, 3), (4, 4), (5, 5), (6, 6)];\n+\n+        let map: HashMap<int, int> = xs.iter().map(|&x| x).collect();\n+\n+        let mut iter = map.iter();\n+\n+        for _ in iter.by_ref().take(3) {}\n+\n+        assert_eq!(iter.size_hint(), (3, Some(3)));\n+    }\n+\n+    #[test]\n+    fn test_mut_size_hint() {\n+        let xs = [(1, 1), (2, 2), (3, 3), (4, 4), (5, 5), (6, 6)];\n+\n+        let mut map: HashMap<int, int> = xs.iter().map(|&x| x).collect();\n+\n+        let mut iter = map.mut_iter();\n+\n+        for _ in iter.by_ref().take(3) {}\n+\n+        assert_eq!(iter.size_hint(), (3, Some(3)));\n+    }\n }\n \n #[cfg(test)]\n@@ -2270,6 +2301,27 @@ mod bench {\n     use self::test::Bencher;\n     use std::iter::{range_inclusive};\n \n+    #[bench]\n+    fn new_drop(b : &mut Bencher) {\n+        use super::HashMap;\n+\n+        b.iter(|| {\n+            let m : HashMap<int, int> = HashMap::new();\n+            assert_eq!(m.len(), 0);\n+        })\n+    }\n+\n+    #[bench]\n+    fn new_insert_drop(b : &mut Bencher) {\n+        use super::HashMap;\n+\n+        b.iter(|| {\n+            let mut m = HashMap::new();\n+            m.insert(0, 0);\n+            assert_eq!(m.len(), 1);\n+        })\n+    }\n+\n     #[bench]\n     fn insert(b: &mut Bencher) {\n         use super::HashMap;\n@@ -2299,7 +2351,9 @@ mod bench {\n         }\n \n         b.iter(|| {\n-            m.contains_key(&412);\n+            for i in range_inclusive(1, 1000) {\n+                m.contains_key(&i);\n+            }\n         });\n     }\n \n@@ -2314,7 +2368,9 @@ mod bench {\n         }\n \n         b.iter(|| {\n-            m.contains_key(&2048);\n+            for i in range_inclusive(1001, 2000) {\n+                m.contains_key(&i);\n+            }\n         });\n     }\n "}]}