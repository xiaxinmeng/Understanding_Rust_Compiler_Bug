{"sha": "76e83339bb619aba206e5590b1e4b813a154b199", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc2ZTgzMzM5YmI2MTlhYmEyMDZlNTU5MGIxZTRiODEzYTE1NGIxOTk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-07-27T20:16:36Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-07-27T20:16:36Z"}, "message": "Auto merge of #73503 - lcnr:forall-predicate-what-and-why-2, r=nikomatsakis\n\nconvert higher ranked `Predicate`s to `PredicateKind::ForAll`\n\nimplements step 2 of https://github.com/rust-lang/compiler-team/issues/285\nr? @nikomatsakis", "tree": {"sha": "2362c199a9d3333c283842113c6bd1f8b137ed21", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2362c199a9d3333c283842113c6bd1f8b137ed21"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/76e83339bb619aba206e5590b1e4b813a154b199", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/76e83339bb619aba206e5590b1e4b813a154b199", "html_url": "https://github.com/rust-lang/rust/commit/76e83339bb619aba206e5590b1e4b813a154b199", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/76e83339bb619aba206e5590b1e4b813a154b199/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "efc02b03d18b0cbaa55b1e421d792f70a39230b2", "url": "https://api.github.com/repos/rust-lang/rust/commits/efc02b03d18b0cbaa55b1e421d792f70a39230b2", "html_url": "https://github.com/rust-lang/rust/commit/efc02b03d18b0cbaa55b1e421d792f70a39230b2"}, {"sha": "602ef6bc0edb3292b4ae96515328bb16348950fb", "url": "https://api.github.com/repos/rust-lang/rust/commits/602ef6bc0edb3292b4ae96515328bb16348950fb", "html_url": "https://github.com/rust-lang/rust/commit/602ef6bc0edb3292b4ae96515328bb16348950fb"}], "stats": {"total": 2418, "additions": 1268, "deletions": 1150}, "files": [{"sha": "0dbebac7e36c68578c578b734c08fddf7a6593f5", "filename": "src/librustc_infer/infer/canonical/query_response.rs", "status": "modified", "additions": 20, "deletions": 25, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/76e83339bb619aba206e5590b1e4b813a154b199/src%2Flibrustc_infer%2Finfer%2Fcanonical%2Fquery_response.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76e83339bb619aba206e5590b1e4b813a154b199/src%2Flibrustc_infer%2Finfer%2Fcanonical%2Fquery_response.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fcanonical%2Fquery_response.rs?ref=76e83339bb619aba206e5590b1e4b813a154b199", "patch": "@@ -525,28 +525,25 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n         result_subst: &'a CanonicalVarValues<'tcx>,\n     ) -> impl Iterator<Item = PredicateObligation<'tcx>> + 'a + Captures<'tcx> {\n         unsubstituted_region_constraints.iter().map(move |constraint| {\n-            let constraint = substitute_value(self.tcx, result_subst, constraint);\n-            let ty::OutlivesPredicate(k1, r2) = constraint.skip_binder(); // restored below\n+            let ty::OutlivesPredicate(k1, r2) =\n+                substitute_value(self.tcx, result_subst, constraint).skip_binder();\n \n-            Obligation::new(\n-                cause.clone(),\n-                param_env,\n-                match k1.unpack() {\n-                    GenericArgKind::Lifetime(r1) => ty::PredicateKind::RegionOutlives(\n-                        ty::Binder::bind(ty::OutlivesPredicate(r1, r2)),\n-                    )\n-                    .to_predicate(self.tcx),\n-                    GenericArgKind::Type(t1) => ty::PredicateKind::TypeOutlives(ty::Binder::bind(\n-                        ty::OutlivesPredicate(t1, r2),\n-                    ))\n-                    .to_predicate(self.tcx),\n-                    GenericArgKind::Const(..) => {\n-                        // Consts cannot outlive one another, so we don't expect to\n-                        // ecounter this branch.\n-                        span_bug!(cause.span, \"unexpected const outlives {:?}\", constraint);\n-                    }\n-                },\n-            )\n+            let predicate = match k1.unpack() {\n+                GenericArgKind::Lifetime(r1) => {\n+                    ty::PredicateAtom::RegionOutlives(ty::OutlivesPredicate(r1, r2))\n+                }\n+                GenericArgKind::Type(t1) => {\n+                    ty::PredicateAtom::TypeOutlives(ty::OutlivesPredicate(t1, r2))\n+                }\n+                GenericArgKind::Const(..) => {\n+                    // Consts cannot outlive one another, so we don't expect to\n+                    // encounter this branch.\n+                    span_bug!(cause.span, \"unexpected const outlives {:?}\", constraint);\n+                }\n+            }\n+            .potentially_quantified(self.tcx, ty::PredicateKind::ForAll);\n+\n+            Obligation::new(cause.clone(), param_env, predicate)\n         })\n     }\n \n@@ -666,10 +663,8 @@ impl<'tcx> TypeRelatingDelegate<'tcx> for QueryTypeRelatingDelegate<'_, 'tcx> {\n         self.obligations.push(Obligation {\n             cause: self.cause.clone(),\n             param_env: self.param_env,\n-            predicate: ty::PredicateKind::RegionOutlives(ty::Binder::dummy(ty::OutlivesPredicate(\n-                sup, sub,\n-            )))\n-            .to_predicate(self.infcx.tcx),\n+            predicate: ty::PredicateAtom::RegionOutlives(ty::OutlivesPredicate(sup, sub))\n+                .to_predicate(self.infcx.tcx),\n             recursion_depth: 0,\n         });\n     }"}, {"sha": "5b4d91de3ca92afd3edb38cdb141fbd49338786a", "filename": "src/librustc_infer/infer/combine.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/76e83339bb619aba206e5590b1e4b813a154b199/src%2Flibrustc_infer%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76e83339bb619aba206e5590b1e4b813a154b199/src%2Flibrustc_infer%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fcombine.rs?ref=76e83339bb619aba206e5590b1e4b813a154b199", "patch": "@@ -308,7 +308,7 @@ impl<'infcx, 'tcx> CombineFields<'infcx, 'tcx> {\n             self.obligations.push(Obligation::new(\n                 self.trace.cause.clone(),\n                 self.param_env,\n-                ty::PredicateKind::WellFormed(b_ty.into()).to_predicate(self.infcx.tcx),\n+                ty::PredicateAtom::WellFormed(b_ty.into()).to_predicate(self.infcx.tcx),\n             ));\n         }\n \n@@ -400,9 +400,9 @@ impl<'infcx, 'tcx> CombineFields<'infcx, 'tcx> {\n         b: &'tcx ty::Const<'tcx>,\n     ) {\n         let predicate = if a_is_expected {\n-            ty::PredicateKind::ConstEquate(a, b)\n+            ty::PredicateAtom::ConstEquate(a, b)\n         } else {\n-            ty::PredicateKind::ConstEquate(b, a)\n+            ty::PredicateAtom::ConstEquate(b, a)\n         };\n         self.obligations.push(Obligation::new(\n             self.trace.cause.clone(),"}, {"sha": "a1e7f1fa3e5e7df5e3dc573222e5cefd02bedf34", "filename": "src/librustc_infer/infer/outlives/mod.rs", "status": "modified", "additions": 20, "deletions": 14, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/76e83339bb619aba206e5590b1e4b813a154b199/src%2Flibrustc_infer%2Finfer%2Foutlives%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76e83339bb619aba206e5590b1e4b813a154b199/src%2Flibrustc_infer%2Finfer%2Foutlives%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Foutlives%2Fmod.rs?ref=76e83339bb619aba206e5590b1e4b813a154b199", "patch": "@@ -6,23 +6,29 @@ pub mod verify;\n \n use rustc_middle::traits::query::OutlivesBound;\n use rustc_middle::ty;\n+use rustc_middle::ty::fold::TypeFoldable;\n \n pub fn explicit_outlives_bounds<'tcx>(\n     param_env: ty::ParamEnv<'tcx>,\n ) -> impl Iterator<Item = OutlivesBound<'tcx>> + 'tcx {\n     debug!(\"explicit_outlives_bounds()\");\n-    param_env.caller_bounds().into_iter().filter_map(move |predicate| match predicate.kind() {\n-        ty::PredicateKind::Projection(..)\n-        | ty::PredicateKind::Trait(..)\n-        | ty::PredicateKind::Subtype(..)\n-        | ty::PredicateKind::WellFormed(..)\n-        | ty::PredicateKind::ObjectSafe(..)\n-        | ty::PredicateKind::ClosureKind(..)\n-        | ty::PredicateKind::TypeOutlives(..)\n-        | ty::PredicateKind::ConstEvaluatable(..)\n-        | ty::PredicateKind::ConstEquate(..) => None,\n-        ty::PredicateKind::RegionOutlives(ref data) => data\n-            .no_bound_vars()\n-            .map(|ty::OutlivesPredicate(r_a, r_b)| OutlivesBound::RegionSubRegion(r_b, r_a)),\n-    })\n+    param_env\n+        .caller_bounds()\n+        .into_iter()\n+        .map(ty::Predicate::skip_binders)\n+        .filter(|atom| !atom.has_escaping_bound_vars())\n+        .filter_map(move |atom| match atom {\n+            ty::PredicateAtom::Projection(..)\n+            | ty::PredicateAtom::Trait(..)\n+            | ty::PredicateAtom::Subtype(..)\n+            | ty::PredicateAtom::WellFormed(..)\n+            | ty::PredicateAtom::ObjectSafe(..)\n+            | ty::PredicateAtom::ClosureKind(..)\n+            | ty::PredicateAtom::TypeOutlives(..)\n+            | ty::PredicateAtom::ConstEvaluatable(..)\n+            | ty::PredicateAtom::ConstEquate(..) => None,\n+            ty::PredicateAtom::RegionOutlives(ty::OutlivesPredicate(r_a, r_b)) => {\n+                Some(OutlivesBound::RegionSubRegion(r_b, r_a))\n+            }\n+        })\n }"}, {"sha": "4f860c77d6541c068e31aface4ae6da3e056761b", "filename": "src/librustc_infer/infer/sub.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/76e83339bb619aba206e5590b1e4b813a154b199/src%2Flibrustc_infer%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76e83339bb619aba206e5590b1e4b813a154b199/src%2Flibrustc_infer%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fsub.rs?ref=76e83339bb619aba206e5590b1e4b813a154b199", "patch": "@@ -100,11 +100,11 @@ impl TypeRelation<'tcx> for Sub<'combine, 'infcx, 'tcx> {\n                 self.fields.obligations.push(Obligation::new(\n                     self.fields.trace.cause.clone(),\n                     self.fields.param_env,\n-                    ty::PredicateKind::Subtype(ty::Binder::dummy(ty::SubtypePredicate {\n+                    ty::PredicateAtom::Subtype(ty::SubtypePredicate {\n                         a_is_expected: self.a_is_expected,\n                         a,\n                         b,\n-                    }))\n+                    })\n                     .to_predicate(self.tcx()),\n                 ));\n "}, {"sha": "93fc7f1f3b8a7e97b49ff7f4b3f35afda7a953a4", "filename": "src/librustc_infer/traits/util.rs", "status": "modified", "additions": 28, "deletions": 60, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/76e83339bb619aba206e5590b1e4b813a154b199/src%2Flibrustc_infer%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76e83339bb619aba206e5590b1e4b813a154b199/src%2Flibrustc_infer%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Ftraits%2Futil.rs?ref=76e83339bb619aba206e5590b1e4b813a154b199", "patch": "@@ -3,51 +3,20 @@ use smallvec::smallvec;\n use crate::traits::{Obligation, ObligationCause, PredicateObligation};\n use rustc_data_structures::fx::FxHashSet;\n use rustc_middle::ty::outlives::Component;\n-use rustc_middle::ty::{self, ToPolyTraitRef, ToPredicate, TyCtxt, WithConstness};\n+use rustc_middle::ty::{self, ToPredicate, TyCtxt, WithConstness};\n use rustc_span::Span;\n \n pub fn anonymize_predicate<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     pred: ty::Predicate<'tcx>,\n ) -> ty::Predicate<'tcx> {\n-    let kind = pred.kind();\n-    let new = match kind {\n-        &ty::PredicateKind::Trait(ref data, constness) => {\n-            ty::PredicateKind::Trait(tcx.anonymize_late_bound_regions(data), constness)\n+    match pred.kind() {\n+        ty::PredicateKind::ForAll(binder) => {\n+            let new = ty::PredicateKind::ForAll(tcx.anonymize_late_bound_regions(binder));\n+            tcx.reuse_or_mk_predicate(pred, new)\n         }\n-\n-        ty::PredicateKind::RegionOutlives(data) => {\n-            ty::PredicateKind::RegionOutlives(tcx.anonymize_late_bound_regions(data))\n-        }\n-\n-        ty::PredicateKind::TypeOutlives(data) => {\n-            ty::PredicateKind::TypeOutlives(tcx.anonymize_late_bound_regions(data))\n-        }\n-\n-        ty::PredicateKind::Projection(data) => {\n-            ty::PredicateKind::Projection(tcx.anonymize_late_bound_regions(data))\n-        }\n-\n-        &ty::PredicateKind::WellFormed(data) => ty::PredicateKind::WellFormed(data),\n-\n-        &ty::PredicateKind::ObjectSafe(data) => ty::PredicateKind::ObjectSafe(data),\n-\n-        &ty::PredicateKind::ClosureKind(closure_def_id, closure_substs, kind) => {\n-            ty::PredicateKind::ClosureKind(closure_def_id, closure_substs, kind)\n-        }\n-\n-        ty::PredicateKind::Subtype(data) => {\n-            ty::PredicateKind::Subtype(tcx.anonymize_late_bound_regions(data))\n-        }\n-\n-        &ty::PredicateKind::ConstEvaluatable(def_id, substs) => {\n-            ty::PredicateKind::ConstEvaluatable(def_id, substs)\n-        }\n-\n-        ty::PredicateKind::ConstEquate(c1, c2) => ty::PredicateKind::ConstEquate(c1, c2),\n-    };\n-\n-    if new != *kind { new.to_predicate(tcx) } else { pred }\n+        ty::PredicateKind::Atom(_) => pred,\n+    }\n }\n \n struct PredicateSet<'tcx> {\n@@ -158,15 +127,16 @@ impl Elaborator<'tcx> {\n \n     fn elaborate(&mut self, obligation: &PredicateObligation<'tcx>) {\n         let tcx = self.visited.tcx;\n-        match obligation.predicate.kind() {\n-            ty::PredicateKind::Trait(ref data, _) => {\n+\n+        match obligation.predicate.skip_binders() {\n+            ty::PredicateAtom::Trait(data, _) => {\n                 // Get predicates declared on the trait.\n                 let predicates = tcx.super_predicates_of(data.def_id());\n \n-                let obligations = predicates.predicates.iter().map(|(pred, span)| {\n+                let obligations = predicates.predicates.iter().map(|&(pred, span)| {\n                     predicate_obligation(\n-                        pred.subst_supertrait(tcx, &data.to_poly_trait_ref()),\n-                        Some(*span),\n+                        pred.subst_supertrait(tcx, &ty::Binder::bind(data.trait_ref)),\n+                        Some(span),\n                     )\n                 });\n                 debug!(\"super_predicates: data={:?}\", data);\n@@ -180,36 +150,36 @@ impl Elaborator<'tcx> {\n \n                 self.stack.extend(obligations);\n             }\n-            ty::PredicateKind::WellFormed(..) => {\n+            ty::PredicateAtom::WellFormed(..) => {\n                 // Currently, we do not elaborate WF predicates,\n                 // although we easily could.\n             }\n-            ty::PredicateKind::ObjectSafe(..) => {\n+            ty::PredicateAtom::ObjectSafe(..) => {\n                 // Currently, we do not elaborate object-safe\n                 // predicates.\n             }\n-            ty::PredicateKind::Subtype(..) => {\n+            ty::PredicateAtom::Subtype(..) => {\n                 // Currently, we do not \"elaborate\" predicates like `X <: Y`,\n                 // though conceivably we might.\n             }\n-            ty::PredicateKind::Projection(..) => {\n+            ty::PredicateAtom::Projection(..) => {\n                 // Nothing to elaborate in a projection predicate.\n             }\n-            ty::PredicateKind::ClosureKind(..) => {\n+            ty::PredicateAtom::ClosureKind(..) => {\n                 // Nothing to elaborate when waiting for a closure's kind to be inferred.\n             }\n-            ty::PredicateKind::ConstEvaluatable(..) => {\n+            ty::PredicateAtom::ConstEvaluatable(..) => {\n                 // Currently, we do not elaborate const-evaluatable\n                 // predicates.\n             }\n-            ty::PredicateKind::ConstEquate(..) => {\n+            ty::PredicateAtom::ConstEquate(..) => {\n                 // Currently, we do not elaborate const-equate\n                 // predicates.\n             }\n-            ty::PredicateKind::RegionOutlives(..) => {\n+            ty::PredicateAtom::RegionOutlives(..) => {\n                 // Nothing to elaborate from `'a: 'b`.\n             }\n-            ty::PredicateKind::TypeOutlives(ref data) => {\n+            ty::PredicateAtom::TypeOutlives(ty::OutlivesPredicate(ty_max, r_min)) => {\n                 // We know that `T: 'a` for some type `T`. We can\n                 // often elaborate this. For example, if we know that\n                 // `[U]: 'a`, that implies that `U: 'a`. Similarly, if\n@@ -224,8 +194,6 @@ impl Elaborator<'tcx> {\n                 // consider this as evidence that `T: 'static`, but\n                 // I'm a bit wary of such constructions and so for now\n                 // I want to be conservative. --nmatsakis\n-                let ty_max = data.skip_binder().0;\n-                let r_min = data.skip_binder().1;\n                 if r_min.is_late_bound() {\n                     return;\n                 }\n@@ -241,16 +209,16 @@ impl Elaborator<'tcx> {\n                                 if r.is_late_bound() {\n                                     None\n                                 } else {\n-                                    Some(ty::PredicateKind::RegionOutlives(ty::Binder::dummy(\n-                                        ty::OutlivesPredicate(r, r_min),\n+                                    Some(ty::PredicateAtom::RegionOutlives(ty::OutlivesPredicate(\n+                                        r, r_min,\n                                     )))\n                                 }\n                             }\n \n                             Component::Param(p) => {\n                                 let ty = tcx.mk_ty_param(p.index, p.name);\n-                                Some(ty::PredicateKind::TypeOutlives(ty::Binder::dummy(\n-                                    ty::OutlivesPredicate(ty, r_min),\n+                                Some(ty::PredicateAtom::TypeOutlives(ty::OutlivesPredicate(\n+                                    ty, r_min,\n                                 )))\n                             }\n \n@@ -331,8 +299,8 @@ impl<'tcx, I: Iterator<Item = PredicateObligation<'tcx>>> Iterator for FilterToT\n \n     fn next(&mut self) -> Option<ty::PolyTraitRef<'tcx>> {\n         while let Some(obligation) = self.base_iterator.next() {\n-            if let ty::PredicateKind::Trait(data, _) = obligation.predicate.kind() {\n-                return Some(data.to_poly_trait_ref());\n+            if let Some(data) = obligation.predicate.to_opt_poly_trait_ref() {\n+                return Some(data);\n             }\n         }\n         None"}, {"sha": "a45817beea16450b3934a64bfd1dd028f4b55982", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 10, "deletions": 14, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/76e83339bb619aba206e5590b1e4b813a154b199/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76e83339bb619aba206e5590b1e4b813a154b199/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=76e83339bb619aba206e5590b1e4b813a154b199", "patch": "@@ -1202,13 +1202,13 @@ declare_lint_pass!(\n impl<'tcx> LateLintPass<'tcx> for TrivialConstraints {\n     fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx hir::Item<'tcx>) {\n         use rustc_middle::ty::fold::TypeFoldable;\n-        use rustc_middle::ty::PredicateKind::*;\n+        use rustc_middle::ty::PredicateAtom::*;\n \n         if cx.tcx.features().trivial_bounds {\n             let def_id = cx.tcx.hir().local_def_id(item.hir_id);\n             let predicates = cx.tcx.predicates_of(def_id);\n             for &(predicate, span) in predicates.predicates {\n-                let predicate_kind_name = match predicate.kind() {\n+                let predicate_kind_name = match predicate.skip_binders() {\n                     Trait(..) => \"Trait\",\n                     TypeOutlives(..) |\n                     RegionOutlives(..) => \"Lifetime\",\n@@ -1497,14 +1497,11 @@ impl ExplicitOutlivesRequirements {\n     ) -> Vec<ty::Region<'tcx>> {\n         inferred_outlives\n             .iter()\n-            .filter_map(|(pred, _)| match pred.kind() {\n-                ty::PredicateKind::RegionOutlives(outlives) => {\n-                    let outlives = outlives.skip_binder();\n-                    match outlives.0 {\n-                        ty::ReEarlyBound(ebr) if ebr.index == index => Some(outlives.1),\n-                        _ => None,\n-                    }\n-                }\n+            .filter_map(|(pred, _)| match pred.skip_binders() {\n+                ty::PredicateAtom::RegionOutlives(ty::OutlivesPredicate(a, b)) => match a {\n+                    ty::ReEarlyBound(ebr) if ebr.index == index => Some(b),\n+                    _ => None,\n+                },\n                 _ => None,\n             })\n             .collect()\n@@ -1516,10 +1513,9 @@ impl ExplicitOutlivesRequirements {\n     ) -> Vec<ty::Region<'tcx>> {\n         inferred_outlives\n             .iter()\n-            .filter_map(|(pred, _)| match pred.kind() {\n-                ty::PredicateKind::TypeOutlives(outlives) => {\n-                    let outlives = outlives.skip_binder();\n-                    outlives.0.is_param(index).then_some(outlives.1)\n+            .filter_map(|(pred, _)| match pred.skip_binders() {\n+                ty::PredicateAtom::TypeOutlives(ty::OutlivesPredicate(a, b)) => {\n+                    a.is_param(index).then_some(b)\n                 }\n                 _ => None,\n             })"}, {"sha": "dcb44ab64449840b526466a7771040bebba06922", "filename": "src/librustc_lint/unused.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/76e83339bb619aba206e5590b1e4b813a154b199/src%2Flibrustc_lint%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76e83339bb619aba206e5590b1e4b813a154b199/src%2Flibrustc_lint%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Funused.rs?ref=76e83339bb619aba206e5590b1e4b813a154b199", "patch": "@@ -146,11 +146,11 @@ impl<'tcx> LateLintPass<'tcx> for UnusedResults {\n                 ty::Opaque(def, _) => {\n                     let mut has_emitted = false;\n                     for (predicate, _) in cx.tcx.predicates_of(def).predicates {\n-                        if let ty::PredicateKind::Trait(ref poly_trait_predicate, _) =\n-                            predicate.kind()\n+                        // We only look at the `DefId`, so it is safe to skip the binder here.\n+                        if let ty::PredicateAtom::Trait(ref poly_trait_predicate, _) =\n+                            predicate.skip_binders()\n                         {\n-                            let trait_ref = poly_trait_predicate.skip_binder().trait_ref;\n-                            let def_id = trait_ref.def_id;\n+                            let def_id = poly_trait_predicate.trait_ref.def_id;\n                             let descr_pre =\n                                 &format!(\"{}implementer{} of \", descr_pre, plural_suffix,);\n                             if check_must_use_def(cx, def_id, span, descr_pre, descr_post) {"}, {"sha": "eeb58a0c55a3e7c2c77e2556255e53d826d9e1d2", "filename": "src/librustc_middle/ty/context.rs", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/76e83339bb619aba206e5590b1e4b813a154b199/src%2Flibrustc_middle%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76e83339bb619aba206e5590b1e4b813a154b199/src%2Flibrustc_middle%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fcontext.rs?ref=76e83339bb619aba206e5590b1e4b813a154b199", "patch": "@@ -102,7 +102,6 @@ impl<'tcx> CtxtInterners<'tcx> {\n             projs: Default::default(),\n             place_elems: Default::default(),\n             const_: Default::default(),\n-\n             chalk_environment_clause_list: Default::default(),\n         }\n     }\n@@ -2128,16 +2127,25 @@ impl<'tcx> TyCtxt<'tcx> {\n \n     #[allow(rustc::usage_of_ty_tykind)]\n     #[inline]\n-    pub fn mk_ty(&self, st: TyKind<'tcx>) -> Ty<'tcx> {\n+    pub fn mk_ty(self, st: TyKind<'tcx>) -> Ty<'tcx> {\n         self.interners.intern_ty(st)\n     }\n \n     #[inline]\n-    pub fn mk_predicate(&self, kind: PredicateKind<'tcx>) -> Predicate<'tcx> {\n+    pub fn mk_predicate(self, kind: PredicateKind<'tcx>) -> Predicate<'tcx> {\n         let inner = self.interners.intern_predicate(kind);\n         Predicate { inner }\n     }\n \n+    #[inline]\n+    pub fn reuse_or_mk_predicate(\n+        self,\n+        pred: Predicate<'tcx>,\n+        kind: PredicateKind<'tcx>,\n+    ) -> Predicate<'tcx> {\n+        if *pred.kind() != kind { self.mk_predicate(kind) } else { pred }\n+    }\n+\n     pub fn mk_mach_int(self, tm: ast::IntTy) -> Ty<'tcx> {\n         match tm {\n             ast::IntTy::Isize => self.types.isize,"}, {"sha": "27f50c240db67e61233673ff82d45584b0cbe9e3", "filename": "src/librustc_middle/ty/flags.rs", "status": "modified", "additions": 29, "deletions": 35, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/76e83339bb619aba206e5590b1e4b813a154b199/src%2Flibrustc_middle%2Fty%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76e83339bb619aba206e5590b1e4b813a154b199/src%2Flibrustc_middle%2Fty%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fflags.rs?ref=76e83339bb619aba206e5590b1e4b813a154b199", "patch": "@@ -203,55 +203,49 @@ impl FlagComputation {\n \n     fn add_predicate_kind(&mut self, kind: &ty::PredicateKind<'_>) {\n         match kind {\n-            ty::PredicateKind::Trait(trait_pred, _constness) => {\n+            ty::PredicateKind::ForAll(binder) => {\n                 let mut computation = FlagComputation::new();\n-                computation.add_substs(trait_pred.skip_binder().trait_ref.substs);\n \n-                self.add_bound_computation(computation);\n-            }\n-            ty::PredicateKind::RegionOutlives(poly_outlives) => {\n-                let mut computation = FlagComputation::new();\n-                let ty::OutlivesPredicate(a, b) = poly_outlives.skip_binder();\n-                computation.add_region(a);\n-                computation.add_region(b);\n+                computation.add_predicate_atom(binder.skip_binder());\n \n                 self.add_bound_computation(computation);\n             }\n-            ty::PredicateKind::TypeOutlives(poly_outlives) => {\n-                let mut computation = FlagComputation::new();\n-                let ty::OutlivesPredicate(ty, region) = poly_outlives.skip_binder();\n-                computation.add_ty(ty);\n-                computation.add_region(region);\n+            &ty::PredicateKind::Atom(atom) => self.add_predicate_atom(atom),\n+        }\n+    }\n \n-                self.add_bound_computation(computation);\n+    fn add_predicate_atom(&mut self, atom: ty::PredicateAtom<'_>) {\n+        match atom {\n+            ty::PredicateAtom::Trait(trait_pred, _constness) => {\n+                self.add_substs(trait_pred.trait_ref.substs);\n             }\n-            ty::PredicateKind::Subtype(poly_subtype) => {\n-                let mut computation = FlagComputation::new();\n-                let ty::SubtypePredicate { a_is_expected: _, a, b } = poly_subtype.skip_binder();\n-                computation.add_ty(a);\n-                computation.add_ty(b);\n-\n-                self.add_bound_computation(computation);\n+            ty::PredicateAtom::RegionOutlives(ty::OutlivesPredicate(a, b)) => {\n+                self.add_region(a);\n+                self.add_region(b);\n             }\n-            &ty::PredicateKind::Projection(projection) => {\n-                let mut computation = FlagComputation::new();\n-                let ty::ProjectionPredicate { projection_ty, ty } = projection.skip_binder();\n-                computation.add_projection_ty(projection_ty);\n-                computation.add_ty(ty);\n-\n-                self.add_bound_computation(computation);\n+            ty::PredicateAtom::TypeOutlives(ty::OutlivesPredicate(ty, region)) => {\n+                self.add_ty(ty);\n+                self.add_region(region);\n+            }\n+            ty::PredicateAtom::Subtype(ty::SubtypePredicate { a_is_expected: _, a, b }) => {\n+                self.add_ty(a);\n+                self.add_ty(b);\n+            }\n+            ty::PredicateAtom::Projection(ty::ProjectionPredicate { projection_ty, ty }) => {\n+                self.add_projection_ty(projection_ty);\n+                self.add_ty(ty);\n             }\n-            ty::PredicateKind::WellFormed(arg) => {\n-                self.add_substs(slice::from_ref(arg));\n+            ty::PredicateAtom::WellFormed(arg) => {\n+                self.add_substs(slice::from_ref(&arg));\n             }\n-            ty::PredicateKind::ObjectSafe(_def_id) => {}\n-            ty::PredicateKind::ClosureKind(_def_id, substs, _kind) => {\n+            ty::PredicateAtom::ObjectSafe(_def_id) => {}\n+            ty::PredicateAtom::ClosureKind(_def_id, substs, _kind) => {\n                 self.add_substs(substs);\n             }\n-            ty::PredicateKind::ConstEvaluatable(_def_id, substs) => {\n+            ty::PredicateAtom::ConstEvaluatable(_def_id, substs) => {\n                 self.add_substs(substs);\n             }\n-            ty::PredicateKind::ConstEquate(expected, found) => {\n+            ty::PredicateAtom::ConstEquate(expected, found) => {\n                 self.add_const(expected);\n                 self.add_const(found);\n             }"}, {"sha": "d1c6d3be5f4bbb849292914ba18aa015c62ddf52", "filename": "src/librustc_middle/ty/mod.rs", "status": "modified", "additions": 121, "deletions": 87, "changes": 208, "blob_url": "https://github.com/rust-lang/rust/blob/76e83339bb619aba206e5590b1e4b813a154b199/src%2Flibrustc_middle%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76e83339bb619aba206e5590b1e4b813a154b199/src%2Flibrustc_middle%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fmod.rs?ref=76e83339bb619aba206e5590b1e4b813a154b199", "patch": "@@ -1018,7 +1018,7 @@ crate struct PredicateInner<'tcx> {\n }\n \n #[cfg(target_arch = \"x86_64\")]\n-static_assert_size!(PredicateInner<'_>, 40);\n+static_assert_size!(PredicateInner<'_>, 48);\n \n #[derive(Clone, Copy, Lift)]\n pub struct Predicate<'tcx> {\n@@ -1048,6 +1048,44 @@ impl<'tcx> Predicate<'tcx> {\n     pub fn kind(self) -> &'tcx PredicateKind<'tcx> {\n         &self.inner.kind\n     }\n+\n+    /// Returns the inner `PredicateAtom`.\n+    ///\n+    /// The returned atom may contain unbound variables bound to binders skipped in this method.\n+    /// It is safe to reapply binders to the given atom.\n+    ///\n+    /// Note that this method panics in case this predicate has unbound variables.\n+    pub fn skip_binders(self) -> PredicateAtom<'tcx> {\n+        match self.kind() {\n+            &PredicateKind::ForAll(binder) => binder.skip_binder(),\n+            &PredicateKind::Atom(atom) => {\n+                debug_assert!(!atom.has_escaping_bound_vars());\n+                atom\n+            }\n+        }\n+    }\n+\n+    /// Returns the inner `PredicateAtom`.\n+    ///\n+    /// Note that this method does not check if the predicate has unbound variables.\n+    ///\n+    /// Rebinding the returned atom can causes the previously bound variables\n+    /// to end up at the wrong binding level.\n+    pub fn skip_binders_unchecked(self) -> PredicateAtom<'tcx> {\n+        match self.kind() {\n+            &PredicateKind::ForAll(binder) => binder.skip_binder(),\n+            &PredicateKind::Atom(atom) => atom,\n+        }\n+    }\n+\n+    /// Allows using a `Binder<PredicateAtom<'tcx>>` even if the given predicate previously\n+    /// contained unbound variables by shifting these variables outwards.\n+    pub fn bound_atom(self, tcx: TyCtxt<'tcx>) -> Binder<PredicateAtom<'tcx>> {\n+        match self.kind() {\n+            &PredicateKind::ForAll(binder) => binder,\n+            &PredicateKind::Atom(atom) => Binder::wrap_nonbinding(tcx, atom),\n+        }\n+    }\n }\n \n impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for Predicate<'tcx> {\n@@ -1068,24 +1106,32 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for Predicate<'tcx> {\n #[derive(Clone, Copy, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n #[derive(HashStable, TypeFoldable)]\n pub enum PredicateKind<'tcx> {\n+    /// `for<'a>: ...`\n+    ForAll(Binder<PredicateAtom<'tcx>>),\n+    Atom(PredicateAtom<'tcx>),\n+}\n+\n+#[derive(Clone, Copy, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n+#[derive(HashStable, TypeFoldable)]\n+pub enum PredicateAtom<'tcx> {\n     /// Corresponds to `where Foo: Bar<A, B, C>`. `Foo` here would be\n     /// the `Self` type of the trait reference and `A`, `B`, and `C`\n     /// would be the type parameters.\n     ///\n     /// A trait predicate will have `Constness::Const` if it originates\n     /// from a bound on a `const fn` without the `?const` opt-out (e.g.,\n     /// `const fn foobar<Foo: Bar>() {}`).\n-    Trait(PolyTraitPredicate<'tcx>, Constness),\n+    Trait(TraitPredicate<'tcx>, Constness),\n \n     /// `where 'a: 'b`\n-    RegionOutlives(PolyRegionOutlivesPredicate<'tcx>),\n+    RegionOutlives(RegionOutlivesPredicate<'tcx>),\n \n     /// `where T: 'a`\n-    TypeOutlives(PolyTypeOutlivesPredicate<'tcx>),\n+    TypeOutlives(TypeOutlivesPredicate<'tcx>),\n \n     /// `where <T as TraitRef>::Name == X`, approximately.\n     /// See the `ProjectionPredicate` struct for details.\n-    Projection(PolyProjectionPredicate<'tcx>),\n+    Projection(ProjectionPredicate<'tcx>),\n \n     /// No syntax: `T` well-formed.\n     WellFormed(GenericArg<'tcx>),\n@@ -1099,7 +1145,7 @@ pub enum PredicateKind<'tcx> {\n     ClosureKind(DefId, SubstsRef<'tcx>, ClosureKind),\n \n     /// `T1 <: T2`\n-    Subtype(PolySubtypePredicate<'tcx>),\n+    Subtype(SubtypePredicate<'tcx>),\n \n     /// Constant initializer must evaluate successfully.\n     ConstEvaluatable(ty::WithOptConstParam<DefId>, SubstsRef<'tcx>),\n@@ -1108,6 +1154,22 @@ pub enum PredicateKind<'tcx> {\n     ConstEquate(&'tcx Const<'tcx>, &'tcx Const<'tcx>),\n }\n \n+impl<'tcx> PredicateAtom<'tcx> {\n+    /// Wraps `self` with the given qualifier if this predicate has any unbound variables.\n+    pub fn potentially_quantified(\n+        self,\n+        tcx: TyCtxt<'tcx>,\n+        qualifier: impl FnOnce(Binder<PredicateAtom<'tcx>>) -> PredicateKind<'tcx>,\n+    ) -> Predicate<'tcx> {\n+        if self.has_escaping_bound_vars() {\n+            qualifier(Binder::bind(self))\n+        } else {\n+            PredicateKind::Atom(self)\n+        }\n+        .to_predicate(tcx)\n+    }\n+}\n+\n /// The crate outlives map is computed during typeck and contains the\n /// outlives of every item in the local crate. You should not use it\n /// directly, because to do so will make your pass dependent on the\n@@ -1119,7 +1181,7 @@ pub struct CratePredicatesMap<'tcx> {\n     /// For each struct with outlive bounds, maps to a vector of the\n     /// predicate of its outlive bounds. If an item has no outlives\n     /// bounds, it will have no entry.\n-    pub predicates: FxHashMap<DefId, &'tcx [(ty::Predicate<'tcx>, Span)]>,\n+    pub predicates: FxHashMap<DefId, &'tcx [(Predicate<'tcx>, Span)]>,\n }\n \n impl<'tcx> Predicate<'tcx> {\n@@ -1132,7 +1194,7 @@ impl<'tcx> Predicate<'tcx> {\n         self,\n         tcx: TyCtxt<'tcx>,\n         trait_ref: &ty::PolyTraitRef<'tcx>,\n-    ) -> ty::Predicate<'tcx> {\n+    ) -> Predicate<'tcx> {\n         // The interaction between HRTB and supertraits is not entirely\n         // obvious. Let me walk you (and myself) through an example.\n         //\n@@ -1192,39 +1254,10 @@ impl<'tcx> Predicate<'tcx> {\n         // substitution code expects equal binding levels in the values\n         // from the substitution and the value being substituted into, and\n         // this trick achieves that).\n-\n-        let substs = &trait_ref.skip_binder().substs;\n-        let kind = self.kind();\n-        let new = match kind {\n-            &PredicateKind::Trait(ref binder, constness) => {\n-                PredicateKind::Trait(binder.map_bound(|data| data.subst(tcx, substs)), constness)\n-            }\n-            PredicateKind::Subtype(binder) => {\n-                PredicateKind::Subtype(binder.map_bound(|data| data.subst(tcx, substs)))\n-            }\n-            PredicateKind::RegionOutlives(binder) => {\n-                PredicateKind::RegionOutlives(binder.map_bound(|data| data.subst(tcx, substs)))\n-            }\n-            PredicateKind::TypeOutlives(binder) => {\n-                PredicateKind::TypeOutlives(binder.map_bound(|data| data.subst(tcx, substs)))\n-            }\n-            PredicateKind::Projection(binder) => {\n-                PredicateKind::Projection(binder.map_bound(|data| data.subst(tcx, substs)))\n-            }\n-            &PredicateKind::WellFormed(data) => PredicateKind::WellFormed(data.subst(tcx, substs)),\n-            &PredicateKind::ObjectSafe(trait_def_id) => PredicateKind::ObjectSafe(trait_def_id),\n-            &PredicateKind::ClosureKind(closure_def_id, closure_substs, kind) => {\n-                PredicateKind::ClosureKind(closure_def_id, closure_substs.subst(tcx, substs), kind)\n-            }\n-            &PredicateKind::ConstEvaluatable(def_id, const_substs) => {\n-                PredicateKind::ConstEvaluatable(def_id, const_substs.subst(tcx, substs))\n-            }\n-            PredicateKind::ConstEquate(c1, c2) => {\n-                PredicateKind::ConstEquate(c1.subst(tcx, substs), c2.subst(tcx, substs))\n-            }\n-        };\n-\n-        if new != *kind { new.to_predicate(tcx) } else { self }\n+        let substs = trait_ref.skip_binder().substs;\n+        let pred = self.skip_binders();\n+        let new = pred.subst(tcx, substs);\n+        if new != pred { new.potentially_quantified(tcx, PredicateKind::ForAll) } else { self }\n     }\n }\n \n@@ -1349,86 +1382,87 @@ impl ToPredicate<'tcx> for PredicateKind<'tcx> {\n     }\n }\n \n-impl<'tcx> ToPredicate<'tcx> for ConstnessAnd<TraitRef<'tcx>> {\n+impl ToPredicate<'tcx> for PredicateAtom<'tcx> {\n+    #[inline(always)]\n     fn to_predicate(self, tcx: TyCtxt<'tcx>) -> Predicate<'tcx> {\n-        ty::PredicateKind::Trait(\n-            ty::Binder::dummy(ty::TraitPredicate { trait_ref: self.value }),\n-            self.constness,\n-        )\n-        .to_predicate(tcx)\n+        debug_assert!(!self.has_escaping_bound_vars(), \"escaping bound vars for {:?}\", self);\n+        tcx.mk_predicate(PredicateKind::Atom(self))\n     }\n }\n \n-impl<'tcx> ToPredicate<'tcx> for ConstnessAnd<&TraitRef<'tcx>> {\n+impl<'tcx> ToPredicate<'tcx> for ConstnessAnd<TraitRef<'tcx>> {\n     fn to_predicate(self, tcx: TyCtxt<'tcx>) -> Predicate<'tcx> {\n-        ty::PredicateKind::Trait(\n-            ty::Binder::dummy(ty::TraitPredicate { trait_ref: *self.value }),\n-            self.constness,\n-        )\n-        .to_predicate(tcx)\n+        PredicateAtom::Trait(ty::TraitPredicate { trait_ref: self.value }, self.constness)\n+            .to_predicate(tcx)\n     }\n }\n \n impl<'tcx> ToPredicate<'tcx> for ConstnessAnd<PolyTraitRef<'tcx>> {\n     fn to_predicate(self, tcx: TyCtxt<'tcx>) -> Predicate<'tcx> {\n-        ty::PredicateKind::Trait(self.value.to_poly_trait_predicate(), self.constness)\n-            .to_predicate(tcx)\n+        ConstnessAnd {\n+            value: self.value.map_bound(|trait_ref| ty::TraitPredicate { trait_ref }),\n+            constness: self.constness,\n+        }\n+        .to_predicate(tcx)\n     }\n }\n \n-impl<'tcx> ToPredicate<'tcx> for ConstnessAnd<&PolyTraitRef<'tcx>> {\n+impl<'tcx> ToPredicate<'tcx> for ConstnessAnd<PolyTraitPredicate<'tcx>> {\n     fn to_predicate(self, tcx: TyCtxt<'tcx>) -> Predicate<'tcx> {\n-        ty::PredicateKind::Trait(self.value.to_poly_trait_predicate(), self.constness)\n-            .to_predicate(tcx)\n+        PredicateAtom::Trait(self.value.skip_binder(), self.constness)\n+            .potentially_quantified(tcx, PredicateKind::ForAll)\n     }\n }\n \n impl<'tcx> ToPredicate<'tcx> for PolyRegionOutlivesPredicate<'tcx> {\n     fn to_predicate(self, tcx: TyCtxt<'tcx>) -> Predicate<'tcx> {\n-        PredicateKind::RegionOutlives(self).to_predicate(tcx)\n+        PredicateAtom::RegionOutlives(self.skip_binder())\n+            .potentially_quantified(tcx, PredicateKind::ForAll)\n     }\n }\n \n impl<'tcx> ToPredicate<'tcx> for PolyTypeOutlivesPredicate<'tcx> {\n     fn to_predicate(self, tcx: TyCtxt<'tcx>) -> Predicate<'tcx> {\n-        PredicateKind::TypeOutlives(self).to_predicate(tcx)\n+        PredicateAtom::TypeOutlives(self.skip_binder())\n+            .potentially_quantified(tcx, PredicateKind::ForAll)\n     }\n }\n \n impl<'tcx> ToPredicate<'tcx> for PolyProjectionPredicate<'tcx> {\n     fn to_predicate(self, tcx: TyCtxt<'tcx>) -> Predicate<'tcx> {\n-        PredicateKind::Projection(self).to_predicate(tcx)\n+        PredicateAtom::Projection(self.skip_binder())\n+            .potentially_quantified(tcx, PredicateKind::ForAll)\n     }\n }\n \n impl<'tcx> Predicate<'tcx> {\n     pub fn to_opt_poly_trait_ref(self) -> Option<PolyTraitRef<'tcx>> {\n-        match self.kind() {\n-            &PredicateKind::Trait(ref t, _) => Some(t.to_poly_trait_ref()),\n-            PredicateKind::Projection(..)\n-            | PredicateKind::Subtype(..)\n-            | PredicateKind::RegionOutlives(..)\n-            | PredicateKind::WellFormed(..)\n-            | PredicateKind::ObjectSafe(..)\n-            | PredicateKind::ClosureKind(..)\n-            | PredicateKind::TypeOutlives(..)\n-            | PredicateKind::ConstEvaluatable(..)\n-            | PredicateKind::ConstEquate(..) => None,\n+        match self.skip_binders() {\n+            PredicateAtom::Trait(t, _) => Some(ty::Binder::bind(t.trait_ref)),\n+            PredicateAtom::Projection(..)\n+            | PredicateAtom::Subtype(..)\n+            | PredicateAtom::RegionOutlives(..)\n+            | PredicateAtom::WellFormed(..)\n+            | PredicateAtom::ObjectSafe(..)\n+            | PredicateAtom::ClosureKind(..)\n+            | PredicateAtom::TypeOutlives(..)\n+            | PredicateAtom::ConstEvaluatable(..)\n+            | PredicateAtom::ConstEquate(..) => None,\n         }\n     }\n \n     pub fn to_opt_type_outlives(self) -> Option<PolyTypeOutlivesPredicate<'tcx>> {\n-        match self.kind() {\n-            &PredicateKind::TypeOutlives(data) => Some(data),\n-            PredicateKind::Trait(..)\n-            | PredicateKind::Projection(..)\n-            | PredicateKind::Subtype(..)\n-            | PredicateKind::RegionOutlives(..)\n-            | PredicateKind::WellFormed(..)\n-            | PredicateKind::ObjectSafe(..)\n-            | PredicateKind::ClosureKind(..)\n-            | PredicateKind::ConstEvaluatable(..)\n-            | PredicateKind::ConstEquate(..) => None,\n+        match self.skip_binders() {\n+            PredicateAtom::TypeOutlives(data) => Some(ty::Binder::bind(data)),\n+            PredicateAtom::Trait(..)\n+            | PredicateAtom::Projection(..)\n+            | PredicateAtom::Subtype(..)\n+            | PredicateAtom::RegionOutlives(..)\n+            | PredicateAtom::WellFormed(..)\n+            | PredicateAtom::ObjectSafe(..)\n+            | PredicateAtom::ClosureKind(..)\n+            | PredicateAtom::ConstEvaluatable(..)\n+            | PredicateAtom::ConstEquate(..) => None,\n         }\n     }\n }\n@@ -1692,7 +1726,7 @@ pub struct ParamEnv<'tcx> {\n     // Specifically, the low bit represents Reveal, with 0 meaning `UserFacing`\n     // and 1 meaning `All`. The rest is the pointer.\n     //\n-    // This relies on the List<ty::Predicate<'tcx>> type having at least 2-byte\n+    // This relies on the List<Predicate<'tcx>> type having at least 2-byte\n     // alignment. Lists start with a usize and are repr(C) so this should be\n     // fine; there is a debug_assert in the constructor as well.\n     //\n@@ -1706,7 +1740,7 @@ pub struct ParamEnv<'tcx> {\n     ///\n     /// Note: This is packed into the `packed_data` usize above, use the\n     /// `caller_bounds()` method to access it.\n-    caller_bounds: PhantomData<&'tcx List<ty::Predicate<'tcx>>>,\n+    caller_bounds: PhantomData<&'tcx List<Predicate<'tcx>>>,\n \n     /// Typically, this is `Reveal::UserFacing`, but during codegen we\n     /// want `Reveal::All`.\n@@ -1784,7 +1818,7 @@ impl<'tcx> ParamEnv<'tcx> {\n     }\n \n     #[inline]\n-    pub fn caller_bounds(self) -> &'tcx List<ty::Predicate<'tcx>> {\n+    pub fn caller_bounds(self) -> &'tcx List<Predicate<'tcx>> {\n         // mask out bottom bit\n         unsafe { &*((self.packed_data & (!1)) as *const _) }\n     }\n@@ -1809,7 +1843,7 @@ impl<'tcx> ParamEnv<'tcx> {\n     /// Construct a trait environment with the given set of predicates.\n     #[inline]\n     pub fn new(\n-        caller_bounds: &'tcx List<ty::Predicate<'tcx>>,\n+        caller_bounds: &'tcx List<Predicate<'tcx>>,\n         reveal: Reveal,\n         def_id: Option<DefId>,\n     ) -> Self {"}, {"sha": "3bb9c20370e8c9e1e7d0eb87276088cfe1ce5fdd", "filename": "src/librustc_middle/ty/print/pretty.rs", "status": "modified", "additions": 35, "deletions": 21, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/76e83339bb619aba206e5590b1e4b813a154b199/src%2Flibrustc_middle%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76e83339bb619aba206e5590b1e4b813a154b199/src%2Flibrustc_middle%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fprint%2Fpretty.rs?ref=76e83339bb619aba206e5590b1e4b813a154b199", "patch": "@@ -572,7 +572,14 @@ pub trait PrettyPrinter<'tcx>:\n                     let mut is_sized = false;\n                     p!(write(\"impl\"));\n                     for predicate in bounds.predicates {\n-                        if let Some(trait_ref) = predicate.to_opt_poly_trait_ref() {\n+                        // Note: We can't use `to_opt_poly_trait_ref` here as `predicate`\n+                        // may contain unbound variables. We therefore do this manually.\n+                        //\n+                        // FIXME(lcnr): Find out why exactly this is the case :)\n+                        if let ty::PredicateAtom::Trait(pred, _) =\n+                            predicate.bound_atom(self.tcx()).skip_binder()\n+                        {\n+                            let trait_ref = ty::Binder::bind(pred.trait_ref);\n                             // Don't print +Sized, but rather +?Sized if absent.\n                             if Some(trait_ref.def_id()) == self.tcx().lang_items().sized_trait() {\n                                 is_sized = true;\n@@ -2006,38 +2013,45 @@ define_print_and_forward_display! {\n \n     ty::Predicate<'tcx> {\n         match self.kind() {\n-            &ty::PredicateKind::Trait(ref data, constness) => {\n+            &ty::PredicateKind::Atom(atom) => p!(print(atom)),\n+            ty::PredicateKind::ForAll(binder) => p!(print(binder)),\n+        }\n+    }\n+\n+    ty::PredicateAtom<'tcx> {\n+        match *self {\n+            ty::PredicateAtom::Trait(ref data, constness) => {\n                 if let hir::Constness::Const = constness {\n                     p!(write(\"const \"));\n                 }\n                 p!(print(data))\n             }\n-            ty::PredicateKind::Subtype(predicate) => p!(print(predicate)),\n-            ty::PredicateKind::RegionOutlives(predicate) => p!(print(predicate)),\n-            ty::PredicateKind::TypeOutlives(predicate) => p!(print(predicate)),\n-            ty::PredicateKind::Projection(predicate) => p!(print(predicate)),\n-            ty::PredicateKind::WellFormed(arg) => p!(print(arg), write(\" well-formed\")),\n-            &ty::PredicateKind::ObjectSafe(trait_def_id) => {\n+            ty::PredicateAtom::Subtype(predicate) => p!(print(predicate)),\n+            ty::PredicateAtom::RegionOutlives(predicate) => p!(print(predicate)),\n+            ty::PredicateAtom::TypeOutlives(predicate) => p!(print(predicate)),\n+            ty::PredicateAtom::Projection(predicate) => p!(print(predicate)),\n+            ty::PredicateAtom::WellFormed(arg) => p!(print(arg), write(\" well-formed\")),\n+            ty::PredicateAtom::ObjectSafe(trait_def_id) => {\n                 p!(write(\"the trait `\"),\n-                   print_def_path(trait_def_id, &[]),\n-                   write(\"` is object-safe\"))\n+                print_def_path(trait_def_id, &[]),\n+                write(\"` is object-safe\"))\n             }\n-            &ty::PredicateKind::ClosureKind(closure_def_id, _closure_substs, kind) => {\n+            ty::PredicateAtom::ClosureKind(closure_def_id, _closure_substs, kind) => {\n                 p!(write(\"the closure `\"),\n-                   print_value_path(closure_def_id, &[]),\n-                   write(\"` implements the trait `{}`\", kind))\n+                print_value_path(closure_def_id, &[]),\n+                write(\"` implements the trait `{}`\", kind))\n             }\n-            &ty::PredicateKind::ConstEvaluatable(def, substs) => {\n+            ty::PredicateAtom::ConstEvaluatable(def, substs) => {\n                 p!(write(\"the constant `\"),\n-                   print_value_path(def.did, substs),\n-                   write(\"` can be evaluated\"))\n+                print_value_path(def.did, substs),\n+                write(\"` can be evaluated\"))\n             }\n-            ty::PredicateKind::ConstEquate(c1, c2) => {\n+            ty::PredicateAtom::ConstEquate(c1, c2) => {\n                 p!(write(\"the constant `\"),\n-                   print(c1),\n-                   write(\"` equals `\"),\n-                   print(c2),\n-                   write(\"`\"))\n+                print(c1),\n+                write(\"` equals `\"),\n+                print(c2),\n+                write(\"`\"))\n             }\n         }\n     }"}, {"sha": "21b8d7101a30477c71114c19e1e6257ca8d1b36c", "filename": "src/librustc_middle/ty/structural_impls.rs", "status": "modified", "additions": 48, "deletions": 31, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/76e83339bb619aba206e5590b1e4b813a154b199/src%2Flibrustc_middle%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76e83339bb619aba206e5590b1e4b813a154b199/src%2Flibrustc_middle%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fstructural_impls.rs?ref=76e83339bb619aba206e5590b1e4b813a154b199", "patch": "@@ -226,27 +226,36 @@ impl fmt::Debug for ty::Predicate<'tcx> {\n impl fmt::Debug for ty::PredicateKind<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match *self {\n-            ty::PredicateKind::Trait(ref a, constness) => {\n+            ty::PredicateKind::ForAll(binder) => write!(f, \"ForAll({:?})\", binder),\n+            ty::PredicateKind::Atom(atom) => write!(f, \"{:?}\", atom),\n+        }\n+    }\n+}\n+\n+impl fmt::Debug for ty::PredicateAtom<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        match *self {\n+            ty::PredicateAtom::Trait(ref a, constness) => {\n                 if let hir::Constness::Const = constness {\n                     write!(f, \"const \")?;\n                 }\n                 a.fmt(f)\n             }\n-            ty::PredicateKind::Subtype(ref pair) => pair.fmt(f),\n-            ty::PredicateKind::RegionOutlives(ref pair) => pair.fmt(f),\n-            ty::PredicateKind::TypeOutlives(ref pair) => pair.fmt(f),\n-            ty::PredicateKind::Projection(ref pair) => pair.fmt(f),\n-            ty::PredicateKind::WellFormed(data) => write!(f, \"WellFormed({:?})\", data),\n-            ty::PredicateKind::ObjectSafe(trait_def_id) => {\n+            ty::PredicateAtom::Subtype(ref pair) => pair.fmt(f),\n+            ty::PredicateAtom::RegionOutlives(ref pair) => pair.fmt(f),\n+            ty::PredicateAtom::TypeOutlives(ref pair) => pair.fmt(f),\n+            ty::PredicateAtom::Projection(ref pair) => pair.fmt(f),\n+            ty::PredicateAtom::WellFormed(data) => write!(f, \"WellFormed({:?})\", data),\n+            ty::PredicateAtom::ObjectSafe(trait_def_id) => {\n                 write!(f, \"ObjectSafe({:?})\", trait_def_id)\n             }\n-            ty::PredicateKind::ClosureKind(closure_def_id, closure_substs, kind) => {\n+            ty::PredicateAtom::ClosureKind(closure_def_id, closure_substs, kind) => {\n                 write!(f, \"ClosureKind({:?}, {:?}, {:?})\", closure_def_id, closure_substs, kind)\n             }\n-            ty::PredicateKind::ConstEvaluatable(def_id, substs) => {\n+            ty::PredicateAtom::ConstEvaluatable(def_id, substs) => {\n                 write!(f, \"ConstEvaluatable({:?}, {:?})\", def_id, substs)\n             }\n-            ty::PredicateKind::ConstEquate(c1, c2) => write!(f, \"ConstEquate({:?}, {:?})\", c1, c2),\n+            ty::PredicateAtom::ConstEquate(c1, c2) => write!(f, \"ConstEquate({:?}, {:?})\", c1, c2),\n         }\n     }\n }\n@@ -476,37 +485,45 @@ impl<'a, 'tcx> Lift<'tcx> for ty::ExistentialProjection<'a> {\n \n impl<'a, 'tcx> Lift<'tcx> for ty::PredicateKind<'a> {\n     type Lifted = ty::PredicateKind<'tcx>;\n+    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n+        match self {\n+            ty::PredicateKind::ForAll(binder) => tcx.lift(binder).map(ty::PredicateKind::ForAll),\n+            ty::PredicateKind::Atom(atom) => tcx.lift(atom).map(ty::PredicateKind::Atom),\n+        }\n+    }\n+}\n+\n+impl<'a, 'tcx> Lift<'tcx> for ty::PredicateAtom<'a> {\n+    type Lifted = ty::PredicateAtom<'tcx>;\n     fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n         match *self {\n-            ty::PredicateKind::Trait(ref binder, constness) => {\n-                tcx.lift(binder).map(|binder| ty::PredicateKind::Trait(binder, constness))\n-            }\n-            ty::PredicateKind::Subtype(ref binder) => {\n-                tcx.lift(binder).map(ty::PredicateKind::Subtype)\n+            ty::PredicateAtom::Trait(ref data, constness) => {\n+                tcx.lift(data).map(|data| ty::PredicateAtom::Trait(data, constness))\n             }\n-            ty::PredicateKind::RegionOutlives(ref binder) => {\n-                tcx.lift(binder).map(ty::PredicateKind::RegionOutlives)\n+            ty::PredicateAtom::Subtype(ref data) => tcx.lift(data).map(ty::PredicateAtom::Subtype),\n+            ty::PredicateAtom::RegionOutlives(ref data) => {\n+                tcx.lift(data).map(ty::PredicateAtom::RegionOutlives)\n             }\n-            ty::PredicateKind::TypeOutlives(ref binder) => {\n-                tcx.lift(binder).map(ty::PredicateKind::TypeOutlives)\n+            ty::PredicateAtom::TypeOutlives(ref data) => {\n+                tcx.lift(data).map(ty::PredicateAtom::TypeOutlives)\n             }\n-            ty::PredicateKind::Projection(ref binder) => {\n-                tcx.lift(binder).map(ty::PredicateKind::Projection)\n+            ty::PredicateAtom::Projection(ref data) => {\n+                tcx.lift(data).map(ty::PredicateAtom::Projection)\n             }\n-            ty::PredicateKind::WellFormed(ty) => tcx.lift(&ty).map(ty::PredicateKind::WellFormed),\n-            ty::PredicateKind::ClosureKind(closure_def_id, closure_substs, kind) => {\n+            ty::PredicateAtom::WellFormed(ty) => tcx.lift(&ty).map(ty::PredicateAtom::WellFormed),\n+            ty::PredicateAtom::ClosureKind(closure_def_id, closure_substs, kind) => {\n                 tcx.lift(&closure_substs).map(|closure_substs| {\n-                    ty::PredicateKind::ClosureKind(closure_def_id, closure_substs, kind)\n+                    ty::PredicateAtom::ClosureKind(closure_def_id, closure_substs, kind)\n                 })\n             }\n-            ty::PredicateKind::ObjectSafe(trait_def_id) => {\n-                Some(ty::PredicateKind::ObjectSafe(trait_def_id))\n+            ty::PredicateAtom::ObjectSafe(trait_def_id) => {\n+                Some(ty::PredicateAtom::ObjectSafe(trait_def_id))\n             }\n-            ty::PredicateKind::ConstEvaluatable(def_id, substs) => {\n-                tcx.lift(&substs).map(|substs| ty::PredicateKind::ConstEvaluatable(def_id, substs))\n+            ty::PredicateAtom::ConstEvaluatable(def_id, substs) => {\n+                tcx.lift(&substs).map(|substs| ty::PredicateAtom::ConstEvaluatable(def_id, substs))\n             }\n-            ty::PredicateKind::ConstEquate(c1, c2) => {\n-                tcx.lift(&(c1, c2)).map(|(c1, c2)| ty::PredicateKind::ConstEquate(c1, c2))\n+            ty::PredicateAtom::ConstEquate(c1, c2) => {\n+                tcx.lift(&(c1, c2)).map(|(c1, c2)| ty::PredicateAtom::ConstEquate(c1, c2))\n             }\n         }\n     }\n@@ -998,7 +1015,7 @@ impl<'tcx> TypeFoldable<'tcx> for ty::Region<'tcx> {\n impl<'tcx> TypeFoldable<'tcx> for ty::Predicate<'tcx> {\n     fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n         let new = ty::PredicateKind::super_fold_with(&self.inner.kind, folder);\n-        if new != self.inner.kind { folder.tcx().mk_predicate(new) } else { *self }\n+        folder.tcx().reuse_or_mk_predicate(*self, new)\n     }\n \n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {"}, {"sha": "df8fa4d73ddf17c9f4a23bf2a193f6bdbaa50ae3", "filename": "src/librustc_middle/ty/sty.rs", "status": "modified", "additions": 26, "deletions": 2, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/76e83339bb619aba206e5590b1e4b813a154b199/src%2Flibrustc_middle%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76e83339bb619aba206e5590b1e4b813a154b199/src%2Flibrustc_middle%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fsty.rs?ref=76e83339bb619aba206e5590b1e4b813a154b199", "patch": "@@ -652,8 +652,7 @@ impl<'tcx> Binder<ExistentialPredicate<'tcx>> {\n                 Binder(tr).with_self_ty(tcx, self_ty).without_const().to_predicate(tcx)\n             }\n             ExistentialPredicate::Projection(p) => {\n-                ty::PredicateKind::Projection(Binder(p.with_self_ty(tcx, self_ty)))\n-                    .to_predicate(tcx)\n+                Binder(p.with_self_ty(tcx, self_ty)).to_predicate(tcx)\n             }\n             ExistentialPredicate::AutoTrait(did) => {\n                 let trait_ref =\n@@ -896,6 +895,22 @@ impl<T> Binder<T> {\n         Binder(value)\n     }\n \n+    /// Wraps `value` in a binder without actually binding any currently\n+    /// unbound variables.\n+    ///\n+    /// Note that this will shift all debrujin indices of escaping bound variables\n+    /// by 1 to avoid accidential captures.\n+    pub fn wrap_nonbinding(tcx: TyCtxt<'tcx>, value: T) -> Binder<T>\n+    where\n+        T: TypeFoldable<'tcx>,\n+    {\n+        if value.has_escaping_bound_vars() {\n+            Binder::bind(super::fold::shift_vars(tcx, &value, 1))\n+        } else {\n+            Binder::dummy(value)\n+        }\n+    }\n+\n     /// Skips the binder and returns the \"bound\" value. This is a\n     /// risky thing to do because it's easy to get confused about\n     /// De Bruijn indices and the like. It is usually better to\n@@ -980,6 +995,15 @@ impl<T> Binder<T> {\n     }\n }\n \n+impl<T> Binder<Option<T>> {\n+    pub fn transpose(self) -> Option<Binder<T>> {\n+        match self.0 {\n+            Some(v) => Some(Binder(v)),\n+            None => None,\n+        }\n+    }\n+}\n+\n /// Represents the projection of an associated type. In explicit UFCS\n /// form this would be written `<T as Trait<..>>::N`.\n #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug, RustcEncodable, RustcDecodable)]"}, {"sha": "a0d99ac33c04ee1a226b24fe7bb66100ae341f27", "filename": "src/librustc_mir/borrow_check/diagnostics/region_errors.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/76e83339bb619aba206e5590b1e4b813a154b199/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fregion_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76e83339bb619aba206e5590b1e4b813a154b199/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fregion_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fregion_errors.rs?ref=76e83339bb619aba206e5590b1e4b813a154b199", "patch": "@@ -589,10 +589,10 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n \n                     let mut found = false;\n                     for predicate in bounds.predicates {\n-                        if let ty::PredicateKind::TypeOutlives(binder) = predicate.kind() {\n-                            if let ty::OutlivesPredicate(_, ty::RegionKind::ReStatic) =\n-                                binder.skip_binder()\n-                            {\n+                        if let ty::PredicateAtom::TypeOutlives(ty::OutlivesPredicate(_, r)) =\n+                            predicate.skip_binders()\n+                        {\n+                            if let ty::RegionKind::ReStatic = r {\n                                 found = true;\n                                 break;\n                             } else {"}, {"sha": "bc5c144cd742c42fb81df884d39f33f1896f97cf", "filename": "src/librustc_mir/borrow_check/type_check/mod.rs", "status": "modified", "additions": 15, "deletions": 19, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/76e83339bb619aba206e5590b1e4b813a154b199/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76e83339bb619aba206e5590b1e4b813a154b199/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fmod.rs?ref=76e83339bb619aba206e5590b1e4b813a154b199", "patch": "@@ -27,8 +27,8 @@ use rustc_middle::ty::cast::CastTy;\n use rustc_middle::ty::fold::TypeFoldable;\n use rustc_middle::ty::subst::{GenericArgKind, Subst, SubstsRef, UserSubsts};\n use rustc_middle::ty::{\n-    self, CanonicalUserTypeAnnotation, CanonicalUserTypeAnnotations, RegionVid, ToPolyTraitRef,\n-    ToPredicate, Ty, TyCtxt, UserType, UserTypeAnnotationIndex,\n+    self, CanonicalUserTypeAnnotation, CanonicalUserTypeAnnotations, RegionVid, ToPredicate, Ty,\n+    TyCtxt, UserType, UserTypeAnnotationIndex, WithConstness,\n };\n use rustc_span::{Span, DUMMY_SP};\n use rustc_target::abi::VariantIdx;\n@@ -1021,7 +1021,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                     }\n \n                     self.prove_predicate(\n-                        ty::PredicateKind::WellFormed(inferred_ty.into()).to_predicate(self.tcx()),\n+                        ty::PredicateAtom::WellFormed(inferred_ty.into()).to_predicate(self.tcx()),\n                         Locations::All(span),\n                         ConstraintCategory::TypeAnnotation,\n                     );\n@@ -1273,7 +1273,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                     obligations.obligations.push(traits::Obligation::new(\n                         ObligationCause::dummy(),\n                         param_env,\n-                        ty::PredicateKind::WellFormed(revealed_ty.into()).to_predicate(infcx.tcx),\n+                        ty::PredicateAtom::WellFormed(revealed_ty.into()).to_predicate(infcx.tcx),\n                     ));\n                     obligations.add(\n                         infcx\n@@ -1617,7 +1617,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                 self.check_call_dest(body, term, &sig, destination, term_location);\n \n                 self.prove_predicates(\n-                    sig.inputs_and_output.iter().map(|ty| ty::PredicateKind::WellFormed(ty.into())),\n+                    sig.inputs_and_output.iter().map(|ty| ty::PredicateAtom::WellFormed(ty.into())),\n                     term_location.to_locations(),\n                     ConstraintCategory::Boring,\n                 );\n@@ -2022,18 +2022,14 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                                         traits::ObligationCauseCode::RepeatVec(should_suggest),\n                                     ),\n                                     self.param_env,\n-                                    ty::PredicateKind::Trait(\n-                                        ty::Binder::bind(ty::TraitPredicate {\n-                                            trait_ref: ty::TraitRef::new(\n-                                                self.tcx().require_lang_item(\n-                                                    CopyTraitLangItem,\n-                                                    Some(self.last_span),\n-                                                ),\n-                                                tcx.mk_substs_trait(ty, &[]),\n-                                            ),\n-                                        }),\n-                                        hir::Constness::NotConst,\n-                                    )\n+                                    ty::Binder::bind(ty::TraitRef::new(\n+                                        self.tcx().require_lang_item(\n+                                            CopyTraitLangItem,\n+                                            Some(self.last_span),\n+                                        ),\n+                                        tcx.mk_substs_trait(ty, &[]),\n+                                    ))\n+                                    .without_const()\n                                     .to_predicate(self.tcx()),\n                                 ),\n                                 &traits::SelectionError::Unimplemented,\n@@ -2706,8 +2702,8 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         category: ConstraintCategory,\n     ) {\n         self.prove_predicates(\n-            Some(ty::PredicateKind::Trait(\n-                trait_ref.to_poly_trait_ref().to_poly_trait_predicate(),\n+            Some(ty::PredicateAtom::Trait(\n+                ty::TraitPredicate { trait_ref },\n                 hir::Constness::NotConst,\n             )),\n             locations,"}, {"sha": "562f512c5dacfee41c66541490a7822c71bb10d4", "filename": "src/librustc_mir/monomorphize/polymorphize.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/76e83339bb619aba206e5590b1e4b813a154b199/src%2Flibrustc_mir%2Fmonomorphize%2Fpolymorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76e83339bb619aba206e5590b1e4b813a154b199/src%2Flibrustc_mir%2Fmonomorphize%2Fpolymorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fpolymorphize.rs?ref=76e83339bb619aba206e5590b1e4b813a154b199", "patch": "@@ -131,22 +131,21 @@ fn mark_used_by_predicates<'tcx>(\n     let predicates = tcx.explicit_predicates_of(def_id);\n     debug!(\"mark_parameters_used_in_predicates: predicates_of={:?}\", predicates);\n     for (predicate, _) in predicates.predicates {\n-        match predicate.kind() {\n-            ty::PredicateKind::Trait(predicate, ..) => {\n-                let trait_ref = predicate.skip_binder().trait_ref;\n+        match predicate.skip_binders() {\n+            ty::PredicateAtom::Trait(predicate, ..) => {\n+                let trait_ref = predicate.trait_ref;\n                 if is_self_ty_used(unused_parameters, trait_ref.self_ty()) {\n                     for ty in trait_ref.substs.types() {\n                         debug!(\"unused_generic_params: (trait) ty={:?}\", ty);\n                         mark_ty(unused_parameters, ty);\n                     }\n                 }\n             }\n-            ty::PredicateKind::Projection(predicate, ..) => {\n-                let self_ty = predicate.skip_binder().projection_ty.self_ty();\n+            ty::PredicateAtom::Projection(proj, ..) => {\n+                let self_ty = proj.projection_ty.self_ty();\n                 if is_self_ty_used(unused_parameters, self_ty) {\n-                    let ty = predicate.ty();\n-                    debug!(\"unused_generic_params: (projection) ty={:?}\", ty);\n-                    mark_ty(unused_parameters, ty.skip_binder());\n+                    debug!(\"unused_generic_params: (projection ty={:?}\", proj.ty);\n+                    mark_ty(unused_parameters, proj.ty);\n                 }\n             }\n             _ => (),"}, {"sha": "de7d7f27186f2b4f59a772db0dd7b3fcc7ad096f", "filename": "src/librustc_mir/transform/qualify_min_const_fn.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/76e83339bb619aba206e5590b1e4b813a154b199/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76e83339bb619aba206e5590b1e4b813a154b199/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs?ref=76e83339bb619aba206e5590b1e4b813a154b199", "patch": "@@ -24,27 +24,27 @@ pub fn is_min_const_fn(tcx: TyCtxt<'tcx>, def_id: DefId, body: &'a Body<'tcx>) -\n     loop {\n         let predicates = tcx.predicates_of(current);\n         for (predicate, _) in predicates.predicates {\n-            match predicate.kind() {\n-                ty::PredicateKind::RegionOutlives(_)\n-                | ty::PredicateKind::TypeOutlives(_)\n-                | ty::PredicateKind::WellFormed(_)\n-                | ty::PredicateKind::Projection(_)\n-                | ty::PredicateKind::ConstEvaluatable(..)\n-                | ty::PredicateKind::ConstEquate(..) => continue,\n-                ty::PredicateKind::ObjectSafe(_) => {\n+            match predicate.skip_binders() {\n+                ty::PredicateAtom::RegionOutlives(_)\n+                | ty::PredicateAtom::TypeOutlives(_)\n+                | ty::PredicateAtom::WellFormed(_)\n+                | ty::PredicateAtom::Projection(_)\n+                | ty::PredicateAtom::ConstEvaluatable(..)\n+                | ty::PredicateAtom::ConstEquate(..) => continue,\n+                ty::PredicateAtom::ObjectSafe(_) => {\n                     bug!(\"object safe predicate on function: {:#?}\", predicate)\n                 }\n-                ty::PredicateKind::ClosureKind(..) => {\n+                ty::PredicateAtom::ClosureKind(..) => {\n                     bug!(\"closure kind predicate on function: {:#?}\", predicate)\n                 }\n-                ty::PredicateKind::Subtype(_) => {\n+                ty::PredicateAtom::Subtype(_) => {\n                     bug!(\"subtype predicate on function: {:#?}\", predicate)\n                 }\n-                &ty::PredicateKind::Trait(pred, constness) => {\n+                ty::PredicateAtom::Trait(pred, constness) => {\n                     if Some(pred.def_id()) == tcx.lang_items().sized_trait() {\n                         continue;\n                     }\n-                    match pred.skip_binder().self_ty().kind {\n+                    match pred.self_ty().kind {\n                         ty::Param(ref p) => {\n                             // Allow `T: ?const Trait`\n                             if constness == hir::Constness::NotConst"}, {"sha": "9c5fb4ce73450198d6ac4de1c29acc0b811da637", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 21, "deletions": 30, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/76e83339bb619aba206e5590b1e4b813a154b199/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76e83339bb619aba206e5590b1e4b813a154b199/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=76e83339bb619aba206e5590b1e4b813a154b199", "patch": "@@ -68,10 +68,7 @@ trait DefIdVisitor<'tcx> {\n     }\n }\n \n-struct DefIdVisitorSkeleton<'v, 'tcx, V>\n-where\n-    V: DefIdVisitor<'tcx> + ?Sized,\n-{\n+struct DefIdVisitorSkeleton<'v, 'tcx, V: ?Sized> {\n     def_id_visitor: &'v mut V,\n     visited_opaque_tys: FxHashSet<DefId>,\n     dummy: PhantomData<TyCtxt<'tcx>>,\n@@ -87,34 +84,28 @@ where\n             || (!self.def_id_visitor.shallow() && substs.visit_with(self))\n     }\n \n+    fn visit_predicate(&mut self, predicate: ty::Predicate<'tcx>) -> bool {\n+        match predicate.skip_binders() {\n+            ty::PredicateAtom::Trait(ty::TraitPredicate { trait_ref }, _) => {\n+                self.visit_trait(trait_ref)\n+            }\n+            ty::PredicateAtom::Projection(ty::ProjectionPredicate { projection_ty, ty }) => {\n+                ty.visit_with(self)\n+                    || self.visit_trait(projection_ty.trait_ref(self.def_id_visitor.tcx()))\n+            }\n+            ty::PredicateAtom::TypeOutlives(ty::OutlivesPredicate(ty, _region)) => {\n+                ty.visit_with(self)\n+            }\n+            ty::PredicateAtom::RegionOutlives(..) => false,\n+            _ => bug!(\"unexpected predicate: {:?}\", predicate),\n+        }\n+    }\n+\n     fn visit_predicates(&mut self, predicates: ty::GenericPredicates<'tcx>) -> bool {\n         let ty::GenericPredicates { parent: _, predicates } = predicates;\n-        for (predicate, _span) in predicates {\n-            match predicate.kind() {\n-                ty::PredicateKind::Trait(poly_predicate, _) => {\n-                    let ty::TraitPredicate { trait_ref } = poly_predicate.skip_binder();\n-                    if self.visit_trait(trait_ref) {\n-                        return true;\n-                    }\n-                }\n-                ty::PredicateKind::Projection(poly_predicate) => {\n-                    let ty::ProjectionPredicate { projection_ty, ty } =\n-                        poly_predicate.skip_binder();\n-                    if ty.visit_with(self) {\n-                        return true;\n-                    }\n-                    if self.visit_trait(projection_ty.trait_ref(self.def_id_visitor.tcx())) {\n-                        return true;\n-                    }\n-                }\n-                ty::PredicateKind::TypeOutlives(poly_predicate) => {\n-                    let ty::OutlivesPredicate(ty, _region) = poly_predicate.skip_binder();\n-                    if ty.visit_with(self) {\n-                        return true;\n-                    }\n-                }\n-                ty::PredicateKind::RegionOutlives(..) => {}\n-                _ => bug!(\"unexpected predicate: {:?}\", predicate),\n+        for &(predicate, _span) in predicates {\n+            if self.visit_predicate(predicate) {\n+                return true;\n             }\n         }\n         false"}, {"sha": "b84ad93341e8186f773a51d7e94501d8da3cb7a5", "filename": "src/librustc_trait_selection/opaque_types.rs", "status": "modified", "additions": 13, "deletions": 14, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/76e83339bb619aba206e5590b1e4b813a154b199/src%2Flibrustc_trait_selection%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76e83339bb619aba206e5590b1e4b813a154b199/src%2Flibrustc_trait_selection%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Fopaque_types.rs?ref=76e83339bb619aba206e5590b1e4b813a154b199", "patch": "@@ -1154,8 +1154,8 @@ impl<'a, 'tcx> Instantiator<'a, 'tcx> {\n         debug!(\"instantiate_opaque_types: ty_var={:?}\", ty_var);\n \n         for predicate in &bounds.predicates {\n-            if let ty::PredicateKind::Projection(projection) = predicate.kind() {\n-                if projection.skip_binder().ty.references_error() {\n+            if let ty::PredicateAtom::Projection(projection) = predicate.skip_binders() {\n+                if projection.ty.references_error() {\n                     // No point on adding these obligations since there's a type error involved.\n                     return ty_var;\n                 }\n@@ -1252,17 +1252,17 @@ crate fn required_region_bounds(\n     traits::elaborate_predicates(tcx, predicates)\n         .filter_map(|obligation| {\n             debug!(\"required_region_bounds(obligation={:?})\", obligation);\n-            match obligation.predicate.kind() {\n-                ty::PredicateKind::Projection(..)\n-                | ty::PredicateKind::Trait(..)\n-                | ty::PredicateKind::Subtype(..)\n-                | ty::PredicateKind::WellFormed(..)\n-                | ty::PredicateKind::ObjectSafe(..)\n-                | ty::PredicateKind::ClosureKind(..)\n-                | ty::PredicateKind::RegionOutlives(..)\n-                | ty::PredicateKind::ConstEvaluatable(..)\n-                | ty::PredicateKind::ConstEquate(..) => None,\n-                ty::PredicateKind::TypeOutlives(predicate) => {\n+            match obligation.predicate.skip_binders() {\n+                ty::PredicateAtom::Projection(..)\n+                | ty::PredicateAtom::Trait(..)\n+                | ty::PredicateAtom::Subtype(..)\n+                | ty::PredicateAtom::WellFormed(..)\n+                | ty::PredicateAtom::ObjectSafe(..)\n+                | ty::PredicateAtom::ClosureKind(..)\n+                | ty::PredicateAtom::RegionOutlives(..)\n+                | ty::PredicateAtom::ConstEvaluatable(..)\n+                | ty::PredicateAtom::ConstEquate(..) => None,\n+                ty::PredicateAtom::TypeOutlives(ty::OutlivesPredicate(ref t, ref r)) => {\n                     // Search for a bound of the form `erased_self_ty\n                     // : 'a`, but be wary of something like `for<'a>\n                     // erased_self_ty : 'a` (we interpret a\n@@ -1272,7 +1272,6 @@ crate fn required_region_bounds(\n                     // it's kind of a moot point since you could never\n                     // construct such an object, but this seems\n                     // correct even if that code changes).\n-                    let ty::OutlivesPredicate(ref t, ref r) = predicate.skip_binder();\n                     if t == &erased_self_ty && !r.has_escaping_bound_vars() {\n                         Some(*r)\n                     } else {"}, {"sha": "6fe67509660bc33e413080dfd465e8f28d1f9cbc", "filename": "src/librustc_trait_selection/traits/auto_trait.rs", "status": "modified", "additions": 25, "deletions": 21, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/76e83339bb619aba206e5590b1e4b813a154b199/src%2Flibrustc_trait_selection%2Ftraits%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76e83339bb619aba206e5590b1e4b813a154b199/src%2Flibrustc_trait_selection%2Ftraits%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fauto_trait.rs?ref=76e83339bb619aba206e5590b1e4b813a154b199", "patch": "@@ -344,8 +344,7 @@ impl AutoTraitFinder<'tcx> {\n                         already_visited.remove(&pred);\n                         self.add_user_pred(\n                             &mut user_computed_preds,\n-                            ty::PredicateKind::Trait(pred, hir::Constness::NotConst)\n-                                .to_predicate(self.tcx),\n+                            pred.without_const().to_predicate(self.tcx),\n                         );\n                         predicates.push_back(pred);\n                     } else {\n@@ -408,21 +407,21 @@ impl AutoTraitFinder<'tcx> {\n     /// under which a type implements an auto trait. A trait predicate involving\n     /// a HRTB means that the type needs to work with any choice of lifetime,\n     /// not just one specific lifetime (e.g., `'static`).\n-    fn add_user_pred<'c>(\n+    fn add_user_pred(\n         &self,\n-        user_computed_preds: &mut FxHashSet<ty::Predicate<'c>>,\n-        new_pred: ty::Predicate<'c>,\n+        user_computed_preds: &mut FxHashSet<ty::Predicate<'tcx>>,\n+        new_pred: ty::Predicate<'tcx>,\n     ) {\n         let mut should_add_new = true;\n         user_computed_preds.retain(|&old_pred| {\n             if let (\n-                ty::PredicateKind::Trait(new_trait, _),\n-                ty::PredicateKind::Trait(old_trait, _),\n-            ) = (new_pred.kind(), old_pred.kind())\n+                ty::PredicateAtom::Trait(new_trait, _),\n+                ty::PredicateAtom::Trait(old_trait, _),\n+            ) = (new_pred.skip_binders(), old_pred.skip_binders())\n             {\n                 if new_trait.def_id() == old_trait.def_id() {\n-                    let new_substs = new_trait.skip_binder().trait_ref.substs;\n-                    let old_substs = old_trait.skip_binder().trait_ref.substs;\n+                    let new_substs = new_trait.trait_ref.substs;\n+                    let old_substs = old_trait.trait_ref.substs;\n \n                     if !new_substs.types().eq(old_substs.types()) {\n                         // We can't compare lifetimes if the types are different,\n@@ -618,11 +617,12 @@ impl AutoTraitFinder<'tcx> {\n     ) -> bool {\n         let dummy_cause = ObligationCause::dummy();\n \n-        for (obligation, mut predicate) in nested.map(|o| (o.clone(), o.predicate)) {\n-            let is_new_pred = fresh_preds.insert(self.clean_pred(select.infcx(), predicate));\n+        for obligation in nested {\n+            let is_new_pred =\n+                fresh_preds.insert(self.clean_pred(select.infcx(), obligation.predicate));\n \n             // Resolve any inference variables that we can, to help selection succeed\n-            predicate = select.infcx().resolve_vars_if_possible(&predicate);\n+            let predicate = select.infcx().resolve_vars_if_possible(&obligation.predicate);\n \n             // We only add a predicate as a user-displayable bound if\n             // it involves a generic parameter, and doesn't contain\n@@ -636,17 +636,19 @@ impl AutoTraitFinder<'tcx> {\n             //\n             // We check this by calling is_of_param on the relevant types\n             // from the various possible predicates\n-            match predicate.kind() {\n-                &ty::PredicateKind::Trait(p, _) => {\n-                    if self.is_param_no_infer(p.skip_binder().trait_ref.substs)\n+\n+            match predicate.skip_binders() {\n+                ty::PredicateAtom::Trait(p, _) => {\n+                    if self.is_param_no_infer(p.trait_ref.substs)\n                         && !only_projections\n                         && is_new_pred\n                     {\n                         self.add_user_pred(computed_preds, predicate);\n                     }\n-                    predicates.push_back(p);\n+                    predicates.push_back(ty::Binder::bind(p));\n                 }\n-                &ty::PredicateKind::Projection(p) => {\n+                ty::PredicateAtom::Projection(p) => {\n+                    let p = ty::Binder::bind(p);\n                     debug!(\n                         \"evaluate_nested_obligations: examining projection predicate {:?}\",\n                         predicate\n@@ -758,7 +760,7 @@ impl AutoTraitFinder<'tcx> {\n                             }\n                         }\n                         Ok(None) => {\n-                            // It's ok not to make progress when hvave no inference variables -\n+                            // It's ok not to make progress when have no inference variables -\n                             // in that case, we were only performing unifcation to check if an\n                             // error occurred (which would indicate that it's impossible for our\n                             // type to implement the auto trait).\n@@ -771,12 +773,14 @@ impl AutoTraitFinder<'tcx> {\n                         }\n                     }\n                 }\n-                &ty::PredicateKind::RegionOutlives(binder) => {\n+                ty::PredicateAtom::RegionOutlives(binder) => {\n+                    let binder = ty::Binder::bind(binder);\n                     if select.infcx().region_outlives_predicate(&dummy_cause, binder).is_err() {\n                         return false;\n                     }\n                 }\n-                &ty::PredicateKind::TypeOutlives(binder) => {\n+                ty::PredicateAtom::TypeOutlives(binder) => {\n+                    let binder = ty::Binder::bind(binder);\n                     match (\n                         binder.no_bound_vars(),\n                         binder.map_bound_ref(|pred| pred.0).no_bound_vars(),"}, {"sha": "349fa68a4da9914a02488692301f6eb735eb75c3", "filename": "src/librustc_trait_selection/traits/error_reporting/mod.rs", "status": "modified", "additions": 40, "deletions": 40, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/76e83339bb619aba206e5590b1e4b813a154b199/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76e83339bb619aba206e5590b1e4b813a154b199/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=76e83339bb619aba206e5590b1e4b813a154b199", "patch": "@@ -255,9 +255,11 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                     .emit();\n                     return;\n                 }\n-                match obligation.predicate.kind() {\n-                    ty::PredicateKind::Trait(ref trait_predicate, _) => {\n-                        let trait_predicate = self.resolve_vars_if_possible(trait_predicate);\n+\n+                match obligation.predicate.skip_binders() {\n+                    ty::PredicateAtom::Trait(trait_predicate, _) => {\n+                        let trait_predicate = ty::Binder::bind(trait_predicate);\n+                        let trait_predicate = self.resolve_vars_if_possible(&trait_predicate);\n \n                         if self.tcx.sess.has_errors() && trait_predicate.references_error() {\n                             return;\n@@ -503,14 +505,8 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                                 );\n                                 trait_pred\n                             });\n-                            let unit_obligation = Obligation {\n-                                predicate: ty::PredicateKind::Trait(\n-                                    predicate,\n-                                    hir::Constness::NotConst,\n-                                )\n-                                .to_predicate(self.tcx),\n-                                ..obligation.clone()\n-                            };\n+                            let unit_obligation =\n+                                obligation.with(predicate.without_const().to_predicate(tcx));\n                             if self.predicate_may_hold(&unit_obligation) {\n                                 err.note(\n                                     \"the trait is implemented for `()`. \\\n@@ -526,15 +522,16 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                         err\n                     }\n \n-                    ty::PredicateKind::Subtype(ref predicate) => {\n+                    ty::PredicateAtom::Subtype(predicate) => {\n                         // Errors for Subtype predicates show up as\n                         // `FulfillmentErrorCode::CodeSubtypeError`,\n                         // not selection error.\n                         span_bug!(span, \"subtype requirement gave wrong error: `{:?}`\", predicate)\n                     }\n \n-                    ty::PredicateKind::RegionOutlives(ref predicate) => {\n-                        let predicate = self.resolve_vars_if_possible(predicate);\n+                    ty::PredicateAtom::RegionOutlives(predicate) => {\n+                        let predicate = ty::Binder::bind(predicate);\n+                        let predicate = self.resolve_vars_if_possible(&predicate);\n                         let err = self\n                             .region_outlives_predicate(&obligation.cause, predicate)\n                             .err()\n@@ -549,7 +546,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                         )\n                     }\n \n-                    ty::PredicateKind::Projection(..) | ty::PredicateKind::TypeOutlives(..) => {\n+                    ty::PredicateAtom::Projection(..) | ty::PredicateAtom::TypeOutlives(..) => {\n                         let predicate = self.resolve_vars_if_possible(&obligation.predicate);\n                         struct_span_err!(\n                             self.tcx.sess,\n@@ -560,12 +557,12 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                         )\n                     }\n \n-                    &ty::PredicateKind::ObjectSafe(trait_def_id) => {\n+                    ty::PredicateAtom::ObjectSafe(trait_def_id) => {\n                         let violations = self.tcx.object_safety_violations(trait_def_id);\n                         report_object_safety_error(self.tcx, span, trait_def_id, violations)\n                     }\n \n-                    &ty::PredicateKind::ClosureKind(closure_def_id, closure_substs, kind) => {\n+                    ty::PredicateAtom::ClosureKind(closure_def_id, closure_substs, kind) => {\n                         let found_kind = self.closure_kind(closure_substs).unwrap();\n                         let closure_span =\n                             self.tcx.sess.source_map().guess_head_span(\n@@ -624,7 +621,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                         return;\n                     }\n \n-                    ty::PredicateKind::WellFormed(ty) => {\n+                    ty::PredicateAtom::WellFormed(ty) => {\n                         if !self.tcx.sess.opts.debugging_opts.chalk {\n                             // WF predicates cannot themselves make\n                             // errors. They can only block due to\n@@ -642,7 +639,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                         }\n                     }\n \n-                    ty::PredicateKind::ConstEvaluatable(..) => {\n+                    ty::PredicateAtom::ConstEvaluatable(..) => {\n                         // Errors for `ConstEvaluatable` predicates show up as\n                         // `SelectionError::ConstEvalFailure`,\n                         // not `Unimplemented`.\n@@ -653,7 +650,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                         )\n                     }\n \n-                    ty::PredicateKind::ConstEquate(..) => {\n+                    ty::PredicateAtom::ConstEquate(..) => {\n                         // Errors for `ConstEquate` predicates show up as\n                         // `SelectionError::ConstEvalFailure`,\n                         // not `Unimplemented`.\n@@ -1089,18 +1086,21 @@ impl<'a, 'tcx> InferCtxtPrivExt<'tcx> for InferCtxt<'a, 'tcx> {\n             return true;\n         }\n \n-        let (cond, error) = match (cond.kind(), error.kind()) {\n-            (ty::PredicateKind::Trait(..), ty::PredicateKind::Trait(error, _)) => (cond, error),\n+        // FIXME: It should be possible to deal with `ForAll` in a cleaner way.\n+        let (cond, error) = match (cond.skip_binders(), error.skip_binders()) {\n+            (ty::PredicateAtom::Trait(..), ty::PredicateAtom::Trait(error, _)) => {\n+                (cond, ty::Binder::bind(error))\n+            }\n             _ => {\n                 // FIXME: make this work in other cases too.\n                 return false;\n             }\n         };\n \n         for obligation in super::elaborate_predicates(self.tcx, std::iter::once(cond)) {\n-            if let ty::PredicateKind::Trait(implication, _) = obligation.predicate.kind() {\n+            if let ty::PredicateAtom::Trait(implication, _) = obligation.predicate.skip_binders() {\n                 let error = error.to_poly_trait_ref();\n-                let implication = implication.to_poly_trait_ref();\n+                let implication = ty::Binder::bind(implication.trait_ref);\n                 // FIXME: I'm just not taking associated types at all here.\n                 // Eventually I'll need to implement param-env-aware\n                 // `\u0393\u2081 \u22a6 \u03c6\u2081 => \u0393\u2082 \u22a6 \u03c6\u2082` logic.\n@@ -1178,12 +1178,12 @@ impl<'a, 'tcx> InferCtxtPrivExt<'tcx> for InferCtxt<'a, 'tcx> {\n             //\n             // this can fail if the problem was higher-ranked, in which\n             // cause I have no idea for a good error message.\n-            if let ty::PredicateKind::Projection(ref data) = predicate.kind() {\n+            if let ty::PredicateAtom::Projection(data) = predicate.skip_binders() {\n                 let mut selcx = SelectionContext::new(self);\n                 let (data, _) = self.replace_bound_vars_with_fresh_vars(\n                     obligation.cause.span,\n                     infer::LateBoundRegionConversionTime::HigherRankedType,\n-                    data,\n+                    &ty::Binder::bind(data),\n                 );\n                 let mut obligations = vec![];\n                 let normalized_ty = super::normalize_projection_type(\n@@ -1470,9 +1470,9 @@ impl<'a, 'tcx> InferCtxtPrivExt<'tcx> for InferCtxt<'a, 'tcx> {\n             return;\n         }\n \n-        let mut err = match predicate.kind() {\n-            ty::PredicateKind::Trait(ref data, _) => {\n-                let trait_ref = data.to_poly_trait_ref();\n+        let mut err = match predicate.skip_binders() {\n+            ty::PredicateAtom::Trait(data, _) => {\n+                let trait_ref = ty::Binder::bind(data.trait_ref);\n                 let self_ty = trait_ref.skip_binder().self_ty();\n                 debug!(\"self_ty {:?} {:?} trait_ref {:?}\", self_ty, self_ty.kind, trait_ref);\n \n@@ -1570,7 +1570,7 @@ impl<'a, 'tcx> InferCtxtPrivExt<'tcx> for InferCtxt<'a, 'tcx> {\n                 err\n             }\n \n-            ty::PredicateKind::WellFormed(arg) => {\n+            ty::PredicateAtom::WellFormed(arg) => {\n                 // Same hacky approach as above to avoid deluging user\n                 // with error messages.\n                 if arg.references_error() || self.tcx.sess.has_errors() {\n@@ -1590,20 +1590,20 @@ impl<'a, 'tcx> InferCtxtPrivExt<'tcx> for InferCtxt<'a, 'tcx> {\n                 }\n             }\n \n-            ty::PredicateKind::Subtype(ref data) => {\n+            ty::PredicateAtom::Subtype(data) => {\n                 if data.references_error() || self.tcx.sess.has_errors() {\n                     // no need to overload user in such cases\n                     return;\n                 }\n-                let SubtypePredicate { a_is_expected: _, a, b } = data.skip_binder();\n+                let SubtypePredicate { a_is_expected: _, a, b } = data;\n                 // both must be type variables, or the other would've been instantiated\n                 assert!(a.is_ty_var() && b.is_ty_var());\n                 self.need_type_info_err(body_id, span, a, ErrorCode::E0282)\n             }\n-            ty::PredicateKind::Projection(ref data) => {\n-                let trait_ref = data.to_poly_trait_ref(self.tcx);\n+            ty::PredicateAtom::Projection(data) => {\n+                let trait_ref = ty::Binder::bind(data).to_poly_trait_ref(self.tcx);\n                 let self_ty = trait_ref.skip_binder().self_ty();\n-                let ty = data.skip_binder().ty;\n+                let ty = data.ty;\n                 if predicate.references_error() {\n                     return;\n                 }\n@@ -1724,16 +1724,16 @@ impl<'a, 'tcx> InferCtxtPrivExt<'tcx> for InferCtxt<'a, 'tcx> {\n         obligation: &PredicateObligation<'tcx>,\n     ) {\n         let (pred, item_def_id, span) =\n-            match (obligation.predicate.kind(), &obligation.cause.code.peel_derives()) {\n+            match (obligation.predicate.skip_binders(), obligation.cause.code.peel_derives()) {\n                 (\n-                    ty::PredicateKind::Trait(pred, _),\n-                    ObligationCauseCode::BindingObligation(item_def_id, span),\n+                    ty::PredicateAtom::Trait(pred, _),\n+                    &ObligationCauseCode::BindingObligation(item_def_id, span),\n                 ) => (pred, item_def_id, span),\n                 _ => return,\n             };\n \n         let node = match (\n-            self.tcx.hir().get_if_local(*item_def_id),\n+            self.tcx.hir().get_if_local(item_def_id),\n             Some(pred.def_id()) == self.tcx.lang_items().sized_trait(),\n         ) {\n             (Some(node), true) => node,\n@@ -1744,7 +1744,7 @@ impl<'a, 'tcx> InferCtxtPrivExt<'tcx> for InferCtxt<'a, 'tcx> {\n             None => return,\n         };\n         for param in generics.params {\n-            if param.span != *span\n+            if param.span != span\n                 || param.bounds.iter().any(|bound| {\n                     bound.trait_ref().and_then(|trait_ref| trait_ref.trait_def_id())\n                         == self.tcx.lang_items().sized_trait()"}, {"sha": "13f8c71a629a905381bcf60822c4bdf8e4136505", "filename": "src/librustc_trait_selection/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/76e83339bb619aba206e5590b1e4b813a154b199/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76e83339bb619aba206e5590b1e4b813a154b199/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=76e83339bb619aba206e5590b1e4b813a154b199", "patch": "@@ -1300,10 +1300,8 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n         // the type. The last generator (`outer_generator` below) has information about where the\n         // bound was introduced. At least one generator should be present for this diagnostic to be\n         // modified.\n-        let (mut trait_ref, mut target_ty) = match obligation.predicate.kind() {\n-            ty::PredicateKind::Trait(p, _) => {\n-                (Some(p.skip_binder().trait_ref), Some(p.skip_binder().self_ty()))\n-            }\n+        let (mut trait_ref, mut target_ty) = match obligation.predicate.skip_binders() {\n+            ty::PredicateAtom::Trait(p, _) => (Some(p.trait_ref), Some(p.self_ty())),\n             _ => (None, None),\n         };\n         let mut generator = None;"}, {"sha": "2eda1ce595a7debb84499685cd19b66c43ebe5ff", "filename": "src/librustc_trait_selection/traits/fulfill.rs", "status": "modified", "additions": 269, "deletions": 231, "changes": 500, "blob_url": "https://github.com/rust-lang/rust/blob/76e83339bb619aba206e5590b1e4b813a154b199/src%2Flibrustc_trait_selection%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76e83339bb619aba206e5590b1e4b813a154b199/src%2Flibrustc_trait_selection%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Ffulfill.rs?ref=76e83339bb619aba206e5590b1e4b813a154b199", "patch": "@@ -3,10 +3,11 @@ use rustc_data_structures::obligation_forest::ProcessResult;\n use rustc_data_structures::obligation_forest::{DoCompleted, Error, ForestObligation};\n use rustc_data_structures::obligation_forest::{ObligationForest, ObligationProcessor};\n use rustc_errors::ErrorReported;\n-use rustc_infer::traits::{TraitEngine, TraitEngineExt as _};\n+use rustc_infer::traits::{TraitEngine, TraitEngineExt as _, TraitObligation};\n use rustc_middle::mir::interpret::ErrorHandled;\n use rustc_middle::ty::error::ExpectedFound;\n-use rustc_middle::ty::{self, Const, ToPolyTraitRef, Ty, TypeFoldable};\n+use rustc_middle::ty::ToPredicate;\n+use rustc_middle::ty::{self, Binder, Const, Ty, TypeFoldable};\n use std::marker::PhantomData;\n \n use super::project;\n@@ -20,6 +21,7 @@ use super::{FulfillmentError, FulfillmentErrorCode};\n use super::{ObligationCause, PredicateObligation};\n \n use crate::traits::error_reporting::InferCtxtExt as _;\n+use crate::traits::project::PolyProjectionObligation;\n use crate::traits::query::evaluate_obligation::InferCtxtExt as _;\n \n impl<'tcx> ForestObligation for PendingPredicateObligation<'tcx> {\n@@ -318,267 +320,222 @@ impl<'a, 'b, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'b, 'tcx> {\n         let infcx = self.selcx.infcx();\n \n         match obligation.predicate.kind() {\n-            ty::PredicateKind::Trait(ref data, _) => {\n-                let trait_obligation = obligation.with(*data);\n-\n-                if obligation.predicate.is_global() {\n-                    // no type variables present, can use evaluation for better caching.\n-                    // FIXME: consider caching errors too.\n-                    if infcx.predicate_must_hold_considering_regions(&obligation) {\n-                        debug!(\n-                            \"selecting trait `{:?}` at depth {} evaluated to holds\",\n-                            data, obligation.recursion_depth\n-                        );\n-                        return ProcessResult::Changed(vec![]);\n-                    }\n+            ty::PredicateKind::ForAll(binder) => match binder.skip_binder() {\n+                // Evaluation will discard candidates using the leak check.\n+                // This means we need to pass it the bound version of our\n+                // predicate.\n+                ty::PredicateAtom::Trait(trait_ref, _constness) => {\n+                    let trait_obligation = obligation.with(Binder::bind(trait_ref));\n+\n+                    self.process_trait_obligation(\n+                        obligation,\n+                        trait_obligation,\n+                        &mut pending_obligation.stalled_on,\n+                    )\n                 }\n+                ty::PredicateAtom::Projection(data) => {\n+                    let project_obligation = obligation.with(Binder::bind(data));\n \n-                match self.selcx.select(&trait_obligation) {\n-                    Ok(Some(impl_source)) => {\n-                        debug!(\n-                            \"selecting trait `{:?}` at depth {} yielded Ok(Some)\",\n-                            data, obligation.recursion_depth\n-                        );\n-                        ProcessResult::Changed(mk_pending(impl_source.nested_obligations()))\n-                    }\n-                    Ok(None) => {\n-                        debug!(\n-                            \"selecting trait `{:?}` at depth {} yielded Ok(None)\",\n-                            data, obligation.recursion_depth\n-                        );\n-\n-                        // This is a bit subtle: for the most part, the\n-                        // only reason we can fail to make progress on\n-                        // trait selection is because we don't have enough\n-                        // information about the types in the trait.\n-                        pending_obligation.stalled_on =\n-                            trait_ref_infer_vars(self.selcx, data.to_poly_trait_ref());\n-\n-                        debug!(\n-                            \"process_predicate: pending obligation {:?} now stalled on {:?}\",\n-                            infcx.resolve_vars_if_possible(obligation),\n-                            pending_obligation.stalled_on\n-                        );\n+                    self.process_projection_obligation(\n+                        project_obligation,\n+                        &mut pending_obligation.stalled_on,\n+                    )\n+                }\n+                ty::PredicateAtom::RegionOutlives(_)\n+                | ty::PredicateAtom::TypeOutlives(_)\n+                | ty::PredicateAtom::WellFormed(_)\n+                | ty::PredicateAtom::ObjectSafe(_)\n+                | ty::PredicateAtom::ClosureKind(..)\n+                | ty::PredicateAtom::Subtype(_)\n+                | ty::PredicateAtom::ConstEvaluatable(..)\n+                | ty::PredicateAtom::ConstEquate(..) => {\n+                    let (pred, _) = infcx.replace_bound_vars_with_placeholders(binder);\n+                    ProcessResult::Changed(mk_pending(vec![\n+                        obligation.with(pred.to_predicate(self.selcx.tcx())),\n+                    ]))\n+                }\n+            },\n+            &ty::PredicateKind::Atom(atom) => match atom {\n+                ty::PredicateAtom::Trait(ref data, _) => {\n+                    let trait_obligation = obligation.with(Binder::dummy(*data));\n+\n+                    self.process_trait_obligation(\n+                        obligation,\n+                        trait_obligation,\n+                        &mut pending_obligation.stalled_on,\n+                    )\n+                }\n \n-                        ProcessResult::Unchanged\n+                ty::PredicateAtom::RegionOutlives(data) => {\n+                    match infcx.region_outlives_predicate(&obligation.cause, Binder::dummy(data)) {\n+                        Ok(()) => ProcessResult::Changed(vec![]),\n+                        Err(_) => ProcessResult::Error(CodeSelectionError(Unimplemented)),\n                     }\n-                    Err(selection_err) => {\n-                        info!(\n-                            \"selecting trait `{:?}` at depth {} yielded Err\",\n-                            data, obligation.recursion_depth\n-                        );\n+                }\n \n-                        ProcessResult::Error(CodeSelectionError(selection_err))\n+                ty::PredicateAtom::TypeOutlives(ty::OutlivesPredicate(t_a, r_b)) => {\n+                    if self.register_region_obligations {\n+                        self.selcx.infcx().register_region_obligation_with_cause(\n+                            t_a,\n+                            r_b,\n+                            &obligation.cause,\n+                        );\n                     }\n+                    ProcessResult::Changed(vec![])\n                 }\n-            }\n \n-            &ty::PredicateKind::RegionOutlives(binder) => {\n-                match infcx.region_outlives_predicate(&obligation.cause, binder) {\n-                    Ok(()) => ProcessResult::Changed(vec![]),\n-                    Err(_) => ProcessResult::Error(CodeSelectionError(Unimplemented)),\n+                ty::PredicateAtom::Projection(ref data) => {\n+                    let project_obligation = obligation.with(Binder::dummy(*data));\n+\n+                    self.process_projection_obligation(\n+                        project_obligation,\n+                        &mut pending_obligation.stalled_on,\n+                    )\n                 }\n-            }\n \n-            ty::PredicateKind::TypeOutlives(ref binder) => {\n-                // Check if there are higher-ranked vars.\n-                match binder.no_bound_vars() {\n-                    // If there are, inspect the underlying type further.\n-                    None => {\n-                        // Convert from `Binder<OutlivesPredicate<Ty, Region>>` to `Binder<Ty>`.\n-                        let binder = binder.map_bound_ref(|pred| pred.0);\n-\n-                        // Check if the type has any bound vars.\n-                        match binder.no_bound_vars() {\n-                            // If so, this obligation is an error (for now). Eventually we should be\n-                            // able to support additional cases here, like `for<'a> &'a str: 'a`.\n-                            // NOTE: this is duplicate-implemented between here and fulfillment.\n-                            None => ProcessResult::Error(CodeSelectionError(Unimplemented)),\n-                            // Otherwise, we have something of the form\n-                            // `for<'a> T: 'a where 'a not in T`, which we can treat as\n-                            // `T: 'static`.\n-                            Some(t_a) => {\n-                                let r_static = self.selcx.tcx().lifetimes.re_static;\n-                                if self.register_region_obligations {\n-                                    self.selcx.infcx().register_region_obligation_with_cause(\n-                                        t_a,\n-                                        r_static,\n-                                        &obligation.cause,\n-                                    );\n-                                }\n-                                ProcessResult::Changed(vec![])\n-                            }\n-                        }\n-                    }\n-                    // If there aren't, register the obligation.\n-                    Some(ty::OutlivesPredicate(t_a, r_b)) => {\n-                        if self.register_region_obligations {\n-                            self.selcx.infcx().register_region_obligation_with_cause(\n-                                t_a,\n-                                r_b,\n-                                &obligation.cause,\n-                            );\n-                        }\n+                ty::PredicateAtom::ObjectSafe(trait_def_id) => {\n+                    if !self.selcx.tcx().is_object_safe(trait_def_id) {\n+                        ProcessResult::Error(CodeSelectionError(Unimplemented))\n+                    } else {\n                         ProcessResult::Changed(vec![])\n                     }\n                 }\n-            }\n \n-            ty::PredicateKind::Projection(ref data) => {\n-                let project_obligation = obligation.with(*data);\n-                match project::poly_project_and_unify_type(self.selcx, &project_obligation) {\n-                    Ok(None) => {\n-                        let tcx = self.selcx.tcx();\n-                        pending_obligation.stalled_on =\n-                            trait_ref_infer_vars(self.selcx, data.to_poly_trait_ref(tcx));\n-                        ProcessResult::Unchanged\n+                ty::PredicateAtom::ClosureKind(_, closure_substs, kind) => {\n+                    match self.selcx.infcx().closure_kind(closure_substs) {\n+                        Some(closure_kind) => {\n+                            if closure_kind.extends(kind) {\n+                                ProcessResult::Changed(vec![])\n+                            } else {\n+                                ProcessResult::Error(CodeSelectionError(Unimplemented))\n+                            }\n+                        }\n+                        None => ProcessResult::Unchanged,\n                     }\n-                    Ok(Some(os)) => ProcessResult::Changed(mk_pending(os)),\n-                    Err(e) => ProcessResult::Error(CodeProjectionError(e)),\n                 }\n-            }\n \n-            &ty::PredicateKind::ObjectSafe(trait_def_id) => {\n-                if !self.selcx.tcx().is_object_safe(trait_def_id) {\n-                    ProcessResult::Error(CodeSelectionError(Unimplemented))\n-                } else {\n-                    ProcessResult::Changed(vec![])\n-                }\n-            }\n-\n-            &ty::PredicateKind::ClosureKind(_, closure_substs, kind) => {\n-                match self.selcx.infcx().closure_kind(closure_substs) {\n-                    Some(closure_kind) => {\n-                        if closure_kind.extends(kind) {\n-                            ProcessResult::Changed(vec![])\n-                        } else {\n-                            ProcessResult::Error(CodeSelectionError(Unimplemented))\n+                ty::PredicateAtom::WellFormed(arg) => {\n+                    match wf::obligations(\n+                        self.selcx.infcx(),\n+                        obligation.param_env,\n+                        obligation.cause.body_id,\n+                        arg,\n+                        obligation.cause.span,\n+                    ) {\n+                        None => {\n+                            pending_obligation.stalled_on =\n+                                vec![TyOrConstInferVar::maybe_from_generic_arg(arg).unwrap()];\n+                            ProcessResult::Unchanged\n                         }\n+                        Some(os) => ProcessResult::Changed(mk_pending(os)),\n                     }\n-                    None => ProcessResult::Unchanged,\n                 }\n-            }\n \n-            &ty::PredicateKind::WellFormed(arg) => {\n-                match wf::obligations(\n-                    self.selcx.infcx(),\n-                    obligation.param_env,\n-                    obligation.cause.body_id,\n-                    arg,\n-                    obligation.cause.span,\n-                ) {\n-                    None => {\n-                        pending_obligation.stalled_on =\n-                            vec![TyOrConstInferVar::maybe_from_generic_arg(arg).unwrap()];\n-                        ProcessResult::Unchanged\n+                ty::PredicateAtom::Subtype(subtype) => {\n+                    match self.selcx.infcx().subtype_predicate(\n+                        &obligation.cause,\n+                        obligation.param_env,\n+                        Binder::dummy(subtype),\n+                    ) {\n+                        None => {\n+                            // None means that both are unresolved.\n+                            pending_obligation.stalled_on = vec![\n+                                TyOrConstInferVar::maybe_from_ty(subtype.a).unwrap(),\n+                                TyOrConstInferVar::maybe_from_ty(subtype.b).unwrap(),\n+                            ];\n+                            ProcessResult::Unchanged\n+                        }\n+                        Some(Ok(ok)) => ProcessResult::Changed(mk_pending(ok.obligations)),\n+                        Some(Err(err)) => {\n+                            let expected_found =\n+                                ExpectedFound::new(subtype.a_is_expected, subtype.a, subtype.b);\n+                            ProcessResult::Error(FulfillmentErrorCode::CodeSubtypeError(\n+                                expected_found,\n+                                err,\n+                            ))\n+                        }\n                     }\n-                    Some(os) => ProcessResult::Changed(mk_pending(os)),\n                 }\n-            }\n \n-            &ty::PredicateKind::Subtype(subtype) => {\n-                match self.selcx.infcx().subtype_predicate(\n-                    &obligation.cause,\n-                    obligation.param_env,\n-                    subtype,\n-                ) {\n-                    None => {\n-                        // None means that both are unresolved.\n-                        pending_obligation.stalled_on = vec![\n-                            TyOrConstInferVar::maybe_from_ty(subtype.skip_binder().a).unwrap(),\n-                            TyOrConstInferVar::maybe_from_ty(subtype.skip_binder().b).unwrap(),\n-                        ];\n-                        ProcessResult::Unchanged\n-                    }\n-                    Some(Ok(ok)) => ProcessResult::Changed(mk_pending(ok.obligations)),\n-                    Some(Err(err)) => {\n-                        let expected_found = ExpectedFound::new(\n-                            subtype.skip_binder().a_is_expected,\n-                            subtype.skip_binder().a,\n-                            subtype.skip_binder().b,\n-                        );\n-                        ProcessResult::Error(FulfillmentErrorCode::CodeSubtypeError(\n-                            expected_found,\n-                            err,\n-                        ))\n+                ty::PredicateAtom::ConstEvaluatable(def_id, substs) => {\n+                    match self.selcx.infcx().const_eval_resolve(\n+                        obligation.param_env,\n+                        def_id,\n+                        substs,\n+                        None,\n+                        Some(obligation.cause.span),\n+                    ) {\n+                        Ok(_) => ProcessResult::Changed(vec![]),\n+                        Err(err) => ProcessResult::Error(CodeSelectionError(ConstEvalFailure(err))),\n                     }\n                 }\n-            }\n \n-            &ty::PredicateKind::ConstEvaluatable(def_id, substs) => {\n-                match self.selcx.infcx().const_eval_resolve(\n-                    obligation.param_env,\n-                    def_id,\n-                    substs,\n-                    None,\n-                    Some(obligation.cause.span),\n-                ) {\n-                    Ok(_) => ProcessResult::Changed(vec![]),\n-                    Err(err) => ProcessResult::Error(CodeSelectionError(ConstEvalFailure(err))),\n-                }\n-            }\n-\n-            ty::PredicateKind::ConstEquate(c1, c2) => {\n-                debug!(\"equating consts: c1={:?} c2={:?}\", c1, c2);\n-\n-                let stalled_on = &mut pending_obligation.stalled_on;\n-\n-                let mut evaluate = |c: &'tcx Const<'tcx>| {\n-                    if let ty::ConstKind::Unevaluated(def, substs, promoted) = c.val {\n-                        match self.selcx.infcx().const_eval_resolve(\n-                            obligation.param_env,\n-                            def,\n-                            substs,\n-                            promoted,\n-                            Some(obligation.cause.span),\n-                        ) {\n-                            Ok(val) => Ok(Const::from_value(self.selcx.tcx(), val, c.ty)),\n-                            Err(ErrorHandled::TooGeneric) => {\n-                                stalled_on.append(\n-                                    &mut substs\n-                                        .types()\n-                                        .filter_map(|ty| TyOrConstInferVar::maybe_from_ty(ty))\n-                                        .collect(),\n-                                );\n-                                Err(ErrorHandled::TooGeneric)\n+                ty::PredicateAtom::ConstEquate(c1, c2) => {\n+                    debug!(\"equating consts: c1={:?} c2={:?}\", c1, c2);\n+\n+                    let stalled_on = &mut pending_obligation.stalled_on;\n+\n+                    let mut evaluate = |c: &'tcx Const<'tcx>| {\n+                        if let ty::ConstKind::Unevaluated(def, substs, promoted) = c.val {\n+                            match self.selcx.infcx().const_eval_resolve(\n+                                obligation.param_env,\n+                                def,\n+                                substs,\n+                                promoted,\n+                                Some(obligation.cause.span),\n+                            ) {\n+                                Ok(val) => Ok(Const::from_value(self.selcx.tcx(), val, c.ty)),\n+                                Err(ErrorHandled::TooGeneric) => {\n+                                    stalled_on.append(\n+                                        &mut substs\n+                                            .types()\n+                                            .filter_map(|ty| TyOrConstInferVar::maybe_from_ty(ty))\n+                                            .collect(),\n+                                    );\n+                                    Err(ErrorHandled::TooGeneric)\n+                                }\n+                                Err(err) => Err(err),\n                             }\n-                            Err(err) => Err(err),\n+                        } else {\n+                            Ok(c)\n                         }\n-                    } else {\n-                        Ok(c)\n-                    }\n-                };\n-\n-                match (evaluate(c1), evaluate(c2)) {\n-                    (Ok(c1), Ok(c2)) => {\n-                        match self\n-                            .selcx\n-                            .infcx()\n-                            .at(&obligation.cause, obligation.param_env)\n-                            .eq(c1, c2)\n-                        {\n-                            Ok(_) => ProcessResult::Changed(vec![]),\n-                            Err(err) => {\n-                                ProcessResult::Error(FulfillmentErrorCode::CodeConstEquateError(\n-                                    ExpectedFound::new(true, c1, c2),\n-                                    err,\n-                                ))\n+                    };\n+\n+                    match (evaluate(c1), evaluate(c2)) {\n+                        (Ok(c1), Ok(c2)) => {\n+                            match self\n+                                .selcx\n+                                .infcx()\n+                                .at(&obligation.cause, obligation.param_env)\n+                                .eq(c1, c2)\n+                            {\n+                                Ok(_) => ProcessResult::Changed(vec![]),\n+                                Err(err) => ProcessResult::Error(\n+                                    FulfillmentErrorCode::CodeConstEquateError(\n+                                        ExpectedFound::new(true, c1, c2),\n+                                        err,\n+                                    ),\n+                                ),\n                             }\n                         }\n-                    }\n-                    (Err(ErrorHandled::Reported(ErrorReported)), _)\n-                    | (_, Err(ErrorHandled::Reported(ErrorReported))) => ProcessResult::Error(\n-                        CodeSelectionError(ConstEvalFailure(ErrorHandled::Reported(ErrorReported))),\n-                    ),\n-                    (Err(ErrorHandled::Linted), _) | (_, Err(ErrorHandled::Linted)) => span_bug!(\n-                        obligation.cause.span(self.selcx.tcx()),\n-                        \"ConstEquate: const_eval_resolve returned an unexpected error\"\n-                    ),\n-                    (Err(ErrorHandled::TooGeneric), _) | (_, Err(ErrorHandled::TooGeneric)) => {\n-                        ProcessResult::Unchanged\n+                        (Err(ErrorHandled::Reported(ErrorReported)), _)\n+                        | (_, Err(ErrorHandled::Reported(ErrorReported))) => {\n+                            ProcessResult::Error(CodeSelectionError(ConstEvalFailure(\n+                                ErrorHandled::Reported(ErrorReported),\n+                            )))\n+                        }\n+                        (Err(ErrorHandled::Linted), _) | (_, Err(ErrorHandled::Linted)) => {\n+                            span_bug!(\n+                                obligation.cause.span(self.selcx.tcx()),\n+                                \"ConstEquate: const_eval_resolve returned an unexpected error\"\n+                            )\n+                        }\n+                        (Err(ErrorHandled::TooGeneric), _) | (_, Err(ErrorHandled::TooGeneric)) => {\n+                            ProcessResult::Unchanged\n+                        }\n                     }\n                 }\n-            }\n+            },\n         }\n     }\n \n@@ -598,6 +555,87 @@ impl<'a, 'b, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'b, 'tcx> {\n     }\n }\n \n+impl<'a, 'b, 'tcx> FulfillProcessor<'a, 'b, 'tcx> {\n+    fn process_trait_obligation(\n+        &mut self,\n+        obligation: &PredicateObligation<'tcx>,\n+        trait_obligation: TraitObligation<'tcx>,\n+        stalled_on: &mut Vec<TyOrConstInferVar<'tcx>>,\n+    ) -> ProcessResult<PendingPredicateObligation<'tcx>, FulfillmentErrorCode<'tcx>> {\n+        let infcx = self.selcx.infcx();\n+        if obligation.predicate.is_global() {\n+            // no type variables present, can use evaluation for better caching.\n+            // FIXME: consider caching errors too.\n+            if infcx.predicate_must_hold_considering_regions(obligation) {\n+                debug!(\n+                    \"selecting trait `{:?}` at depth {} evaluated to holds\",\n+                    obligation.predicate, obligation.recursion_depth\n+                );\n+                return ProcessResult::Changed(vec![]);\n+            }\n+        }\n+\n+        match self.selcx.select(&trait_obligation) {\n+            Ok(Some(impl_source)) => {\n+                debug!(\n+                    \"selecting trait `{:?}` at depth {} yielded Ok(Some)\",\n+                    trait_obligation.predicate, obligation.recursion_depth\n+                );\n+                ProcessResult::Changed(mk_pending(impl_source.nested_obligations()))\n+            }\n+            Ok(None) => {\n+                debug!(\n+                    \"selecting trait `{:?}` at depth {} yielded Ok(None)\",\n+                    trait_obligation.predicate, obligation.recursion_depth\n+                );\n+\n+                // This is a bit subtle: for the most part, the\n+                // only reason we can fail to make progress on\n+                // trait selection is because we don't have enough\n+                // information about the types in the trait.\n+                *stalled_on = trait_ref_infer_vars(\n+                    self.selcx,\n+                    trait_obligation.predicate.map_bound(|pred| pred.trait_ref),\n+                );\n+\n+                debug!(\n+                    \"process_predicate: pending obligation {:?} now stalled on {:?}\",\n+                    infcx.resolve_vars_if_possible(obligation),\n+                    stalled_on\n+                );\n+\n+                ProcessResult::Unchanged\n+            }\n+            Err(selection_err) => {\n+                info!(\n+                    \"selecting trait `{:?}` at depth {} yielded Err\",\n+                    trait_obligation.predicate, obligation.recursion_depth\n+                );\n+\n+                ProcessResult::Error(CodeSelectionError(selection_err))\n+            }\n+        }\n+    }\n+\n+    fn process_projection_obligation(\n+        &mut self,\n+        project_obligation: PolyProjectionObligation<'tcx>,\n+        stalled_on: &mut Vec<TyOrConstInferVar<'tcx>>,\n+    ) -> ProcessResult<PendingPredicateObligation<'tcx>, FulfillmentErrorCode<'tcx>> {\n+        match project::poly_project_and_unify_type(self.selcx, &project_obligation) {\n+            Ok(None) => {\n+                *stalled_on = trait_ref_infer_vars(\n+                    self.selcx,\n+                    project_obligation.predicate.to_poly_trait_ref(self.selcx.tcx()),\n+                );\n+                ProcessResult::Unchanged\n+            }\n+            Ok(Some(os)) => ProcessResult::Changed(mk_pending(os)),\n+            Err(e) => ProcessResult::Error(CodeProjectionError(e)),\n+        }\n+    }\n+}\n+\n /// Returns the set of inference variables contained in a trait ref.\n fn trait_ref_infer_vars<'a, 'tcx>(\n     selcx: &mut SelectionContext<'a, 'tcx>,\n@@ -606,7 +644,7 @@ fn trait_ref_infer_vars<'a, 'tcx>(\n     selcx\n         .infcx()\n         .resolve_vars_if_possible(&trait_ref)\n-        .skip_binder() // ok b/c this check doesn't care about regions\n+        .skip_binder()\n         .substs\n         .iter()\n         // FIXME(eddyb) try using `skip_current_subtree` to skip everything that"}, {"sha": "afa48c2f76cf8a0fb79b77e4a6a246518c7e68a1", "filename": "src/librustc_trait_selection/traits/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/76e83339bb619aba206e5590b1e4b813a154b199/src%2Flibrustc_trait_selection%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76e83339bb619aba206e5590b1e4b813a154b199/src%2Flibrustc_trait_selection%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fmod.rs?ref=76e83339bb619aba206e5590b1e4b813a154b199", "patch": "@@ -328,8 +328,8 @@ pub fn normalize_param_env_or_error<'tcx>(\n     // This works fairly well because trait matching  does not actually care about param-env\n     // TypeOutlives predicates - these are normally used by regionck.\n     let outlives_predicates: Vec<_> = predicates\n-        .drain_filter(|predicate| match predicate.kind() {\n-            ty::PredicateKind::TypeOutlives(..) => true,\n+        .drain_filter(|predicate| match predicate.skip_binders() {\n+            ty::PredicateAtom::TypeOutlives(..) => true,\n             _ => false,\n         })\n         .collect();"}, {"sha": "c003e4f8068738ce725d8861838f1199530602a9", "filename": "src/librustc_trait_selection/traits/object_safety.rs", "status": "modified", "additions": 25, "deletions": 33, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/76e83339bb619aba206e5590b1e4b813a154b199/src%2Flibrustc_trait_selection%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76e83339bb619aba206e5590b1e4b813a154b199/src%2Flibrustc_trait_selection%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fobject_safety.rs?ref=76e83339bb619aba206e5590b1e4b813a154b199", "patch": "@@ -245,16 +245,12 @@ fn predicates_reference_self(\n         .iter()\n         .map(|(predicate, sp)| (predicate.subst_supertrait(tcx, &trait_ref), sp))\n         .filter_map(|(predicate, &sp)| {\n-            match predicate.kind() {\n-                ty::PredicateKind::Trait(ref data, _) => {\n+            match predicate.skip_binders() {\n+                ty::PredicateAtom::Trait(ref data, _) => {\n                     // In the case of a trait predicate, we can skip the \"self\" type.\n-                    if data.skip_binder().trait_ref.substs[1..].iter().any(has_self_ty) {\n-                        Some(sp)\n-                    } else {\n-                        None\n-                    }\n+                    if data.trait_ref.substs[1..].iter().any(has_self_ty) { Some(sp) } else { None }\n                 }\n-                ty::PredicateKind::Projection(ref data) => {\n+                ty::PredicateAtom::Projection(ref data) => {\n                     // And similarly for projections. This should be redundant with\n                     // the previous check because any projection should have a\n                     // matching `Trait` predicate with the same inputs, but we do\n@@ -267,23 +263,20 @@ fn predicates_reference_self(\n                     //\n                     // This is ALT2 in issue #56288, see that for discussion of the\n                     // possible alternatives.\n-                    if data.skip_binder().projection_ty.trait_ref(tcx).substs[1..]\n-                        .iter()\n-                        .any(has_self_ty)\n-                    {\n+                    if data.projection_ty.trait_ref(tcx).substs[1..].iter().any(has_self_ty) {\n                         Some(sp)\n                     } else {\n                         None\n                     }\n                 }\n-                ty::PredicateKind::WellFormed(..)\n-                | ty::PredicateKind::ObjectSafe(..)\n-                | ty::PredicateKind::TypeOutlives(..)\n-                | ty::PredicateKind::RegionOutlives(..)\n-                | ty::PredicateKind::ClosureKind(..)\n-                | ty::PredicateKind::Subtype(..)\n-                | ty::PredicateKind::ConstEvaluatable(..)\n-                | ty::PredicateKind::ConstEquate(..) => None,\n+                ty::PredicateAtom::WellFormed(..)\n+                | ty::PredicateAtom::ObjectSafe(..)\n+                | ty::PredicateAtom::TypeOutlives(..)\n+                | ty::PredicateAtom::RegionOutlives(..)\n+                | ty::PredicateAtom::ClosureKind(..)\n+                | ty::PredicateAtom::Subtype(..)\n+                | ty::PredicateAtom::ConstEvaluatable(..)\n+                | ty::PredicateAtom::ConstEquate(..) => None,\n             }\n         })\n         .collect()\n@@ -305,20 +298,19 @@ fn generics_require_sized_self(tcx: TyCtxt<'_>, def_id: DefId) -> bool {\n     let predicates = tcx.predicates_of(def_id);\n     let predicates = predicates.instantiate_identity(tcx).predicates;\n     elaborate_predicates(tcx, predicates.into_iter()).any(|obligation| {\n-        match obligation.predicate.kind() {\n-            ty::PredicateKind::Trait(ref trait_pred, _) => {\n-                trait_pred.def_id() == sized_def_id\n-                    && trait_pred.skip_binder().self_ty().is_param(0)\n+        match obligation.predicate.skip_binders() {\n+            ty::PredicateAtom::Trait(ref trait_pred, _) => {\n+                trait_pred.def_id() == sized_def_id && trait_pred.self_ty().is_param(0)\n             }\n-            ty::PredicateKind::Projection(..)\n-            | ty::PredicateKind::Subtype(..)\n-            | ty::PredicateKind::RegionOutlives(..)\n-            | ty::PredicateKind::WellFormed(..)\n-            | ty::PredicateKind::ObjectSafe(..)\n-            | ty::PredicateKind::ClosureKind(..)\n-            | ty::PredicateKind::TypeOutlives(..)\n-            | ty::PredicateKind::ConstEvaluatable(..)\n-            | ty::PredicateKind::ConstEquate(..) => false,\n+            ty::PredicateAtom::Projection(..)\n+            | ty::PredicateAtom::Subtype(..)\n+            | ty::PredicateAtom::RegionOutlives(..)\n+            | ty::PredicateAtom::WellFormed(..)\n+            | ty::PredicateAtom::ObjectSafe(..)\n+            | ty::PredicateAtom::ClosureKind(..)\n+            | ty::PredicateAtom::TypeOutlives(..)\n+            | ty::PredicateAtom::ConstEvaluatable(..)\n+            | ty::PredicateAtom::ConstEquate(..) => false,\n         }\n     })\n }"}, {"sha": "717b7e2fe574f05c7da7942b98e5d4fa0b4dd034", "filename": "src/librustc_trait_selection/traits/project.rs", "status": "modified", "additions": 25, "deletions": 21, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/76e83339bb619aba206e5590b1e4b813a154b199/src%2Flibrustc_trait_selection%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76e83339bb619aba206e5590b1e4b813a154b199/src%2Flibrustc_trait_selection%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fproject.rs?ref=76e83339bb619aba206e5590b1e4b813a154b199", "patch": "@@ -664,23 +664,25 @@ fn prune_cache_value_obligations<'a, 'tcx>(\n     let mut obligations: Vec<_> = result\n         .obligations\n         .iter()\n-        .filter(|obligation| match obligation.predicate.kind() {\n-            // We found a `T: Foo<X = U>` predicate, let's check\n-            // if `U` references any unresolved type\n-            // variables. In principle, we only care if this\n-            // projection can help resolve any of the type\n-            // variables found in `result.value` -- but we just\n-            // check for any type variables here, for fear of\n-            // indirect obligations (e.g., we project to `?0`,\n-            // but we have `T: Foo<X = ?1>` and `?1: Bar<X =\n-            // ?0>`).\n-            ty::PredicateKind::Projection(ref data) => {\n-                infcx.unresolved_type_vars(&data.ty()).is_some()\n-            }\n+        .filter(|obligation| {\n+            match obligation.predicate.skip_binders() {\n+                // We found a `T: Foo<X = U>` predicate, let's check\n+                // if `U` references any unresolved type\n+                // variables. In principle, we only care if this\n+                // projection can help resolve any of the type\n+                // variables found in `result.value` -- but we just\n+                // check for any type variables here, for fear of\n+                // indirect obligations (e.g., we project to `?0`,\n+                // but we have `T: Foo<X = ?1>` and `?1: Bar<X =\n+                // ?0>`).\n+                ty::PredicateAtom::Projection(data) => {\n+                    infcx.unresolved_type_vars(&ty::Binder::bind(data.ty)).is_some()\n+                }\n \n-            // We are only interested in `T: Foo<X = U>` predicates, whre\n-            // `U` references one of `unresolved_type_vars`. =)\n-            _ => false,\n+                // We are only interested in `T: Foo<X = U>` predicates, whre\n+                // `U` references one of `unresolved_type_vars`. =)\n+                _ => false,\n+            }\n         })\n         .cloned()\n         .collect();\n@@ -931,7 +933,8 @@ fn assemble_candidates_from_predicates<'cx, 'tcx>(\n     let infcx = selcx.infcx();\n     for predicate in env_predicates {\n         debug!(\"assemble_candidates_from_predicates: predicate={:?}\", predicate);\n-        if let &ty::PredicateKind::Projection(data) = predicate.kind() {\n+        if let ty::PredicateAtom::Projection(data) = predicate.skip_binders() {\n+            let data = ty::Binder::bind(data);\n             let same_def_id = data.projection_def_id() == obligation.predicate.item_def_id;\n \n             let is_match = same_def_id\n@@ -1221,11 +1224,12 @@ fn confirm_object_candidate<'cx, 'tcx>(\n \n         // select only those projections that are actually projecting an\n         // item with the correct name\n-        let env_predicates = env_predicates.filter_map(|o| match o.predicate.kind() {\n-            &ty::PredicateKind::Projection(data)\n-                if data.projection_def_id() == obligation.predicate.item_def_id =>\n+\n+        let env_predicates = env_predicates.filter_map(|o| match o.predicate.skip_binders() {\n+            ty::PredicateAtom::Projection(data)\n+                if data.projection_ty.item_def_id == obligation.predicate.item_def_id =>\n             {\n-                Some(data)\n+                Some(ty::Binder::bind(data))\n             }\n             _ => None,\n         });"}, {"sha": "93ddcb6855400b5cb95571d8d136df5143d483a1", "filename": "src/librustc_trait_selection/traits/query/type_op/prove_predicate.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/76e83339bb619aba206e5590b1e4b813a154b199/src%2Flibrustc_trait_selection%2Ftraits%2Fquery%2Ftype_op%2Fprove_predicate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76e83339bb619aba206e5590b1e4b813a154b199/src%2Flibrustc_trait_selection%2Ftraits%2Fquery%2Ftype_op%2Fprove_predicate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fquery%2Ftype_op%2Fprove_predicate.rs?ref=76e83339bb619aba206e5590b1e4b813a154b199", "patch": "@@ -15,10 +15,10 @@ impl<'tcx> super::QueryTypeOp<'tcx> for ProvePredicate<'tcx> {\n         // `&T`, accounts for about 60% percentage of the predicates\n         // we have to prove. No need to canonicalize and all that for\n         // such cases.\n-        if let ty::PredicateKind::Trait(trait_ref, _) = key.value.predicate.kind() {\n+        if let ty::PredicateAtom::Trait(trait_ref, _) = key.value.predicate.skip_binders() {\n             if let Some(sized_def_id) = tcx.lang_items().sized_trait() {\n                 if trait_ref.def_id() == sized_def_id {\n-                    if trait_ref.skip_binder().self_ty().is_trivially_sized(tcx) {\n+                    if trait_ref.self_ty().is_trivially_sized(tcx) {\n                         return Some(());\n                     }\n                 }"}, {"sha": "a04636af5796a0d96b5ce4b036119344c344d6bd", "filename": "src/librustc_trait_selection/traits/select/confirmation.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/76e83339bb619aba206e5590b1e4b813a154b199/src%2Flibrustc_trait_selection%2Ftraits%2Fselect%2Fconfirmation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76e83339bb619aba206e5590b1e4b813a154b199/src%2Flibrustc_trait_selection%2Ftraits%2Fselect%2Fconfirmation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fselect%2Fconfirmation.rs?ref=76e83339bb619aba206e5590b1e4b813a154b199", "patch": "@@ -532,7 +532,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             obligations.push(Obligation::new(\n                 obligation.cause.clone(),\n                 obligation.param_env,\n-                ty::PredicateKind::ClosureKind(closure_def_id, substs, kind)\n+                ty::PredicateAtom::ClosureKind(closure_def_id, substs, kind)\n                     .to_predicate(self.tcx()),\n             ));\n         }"}, {"sha": "4123f2938261c6478e92a14e79a8d425fff26ac8", "filename": "src/librustc_trait_selection/traits/select/mod.rs", "status": "modified", "additions": 22, "deletions": 19, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/76e83339bb619aba206e5590b1e4b813a154b199/src%2Flibrustc_trait_selection%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76e83339bb619aba206e5590b1e4b813a154b199/src%2Flibrustc_trait_selection%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fselect%2Fmod.rs?ref=76e83339bb619aba206e5590b1e4b813a154b199", "patch": "@@ -35,7 +35,9 @@ use rustc_middle::mir::interpret::ErrorHandled;\n use rustc_middle::ty::fast_reject;\n use rustc_middle::ty::relate::TypeRelation;\n use rustc_middle::ty::subst::{GenericArgKind, Subst, SubstsRef};\n-use rustc_middle::ty::{self, ToPolyTraitRef, ToPredicate, Ty, TyCtxt, TypeFoldable};\n+use rustc_middle::ty::{\n+    self, ToPolyTraitRef, ToPredicate, Ty, TyCtxt, TypeFoldable, WithConstness,\n+};\n use rustc_span::symbol::sym;\n \n use std::cell::{Cell, RefCell};\n@@ -406,14 +408,16 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             None => self.check_recursion_limit(&obligation, &obligation)?,\n         }\n \n-        match obligation.predicate.kind() {\n-            &ty::PredicateKind::Trait(t, _) => {\n+        match obligation.predicate.skip_binders() {\n+            ty::PredicateAtom::Trait(t, _) => {\n+                let t = ty::Binder::bind(t);\n                 debug_assert!(!t.has_escaping_bound_vars());\n                 let obligation = obligation.with(t);\n                 self.evaluate_trait_predicate_recursively(previous_stack, obligation)\n             }\n \n-            &ty::PredicateKind::Subtype(p) => {\n+            ty::PredicateAtom::Subtype(p) => {\n+                let p = ty::Binder::bind(p);\n                 // Does this code ever run?\n                 match self.infcx.subtype_predicate(&obligation.cause, obligation.param_env, p) {\n                     Some(Ok(InferOk { mut obligations, .. })) => {\n@@ -428,7 +432,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 }\n             }\n \n-            &ty::PredicateKind::WellFormed(arg) => match wf::obligations(\n+            ty::PredicateAtom::WellFormed(arg) => match wf::obligations(\n                 self.infcx,\n                 obligation.param_env,\n                 obligation.cause.body_id,\n@@ -442,20 +446,21 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 None => Ok(EvaluatedToAmbig),\n             },\n \n-            ty::PredicateKind::TypeOutlives(..) | ty::PredicateKind::RegionOutlives(..) => {\n+            ty::PredicateAtom::TypeOutlives(..) | ty::PredicateAtom::RegionOutlives(..) => {\n                 // We do not consider region relationships when evaluating trait matches.\n                 Ok(EvaluatedToOkModuloRegions)\n             }\n \n-            &ty::PredicateKind::ObjectSafe(trait_def_id) => {\n+            ty::PredicateAtom::ObjectSafe(trait_def_id) => {\n                 if self.tcx().is_object_safe(trait_def_id) {\n                     Ok(EvaluatedToOk)\n                 } else {\n                     Ok(EvaluatedToErr)\n                 }\n             }\n \n-            &ty::PredicateKind::Projection(data) => {\n+            ty::PredicateAtom::Projection(data) => {\n+                let data = ty::Binder::bind(data);\n                 let project_obligation = obligation.with(data);\n                 match project::poly_project_and_unify_type(self, &project_obligation) {\n                     Ok(Some(mut subobligations)) => {\n@@ -476,7 +481,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 }\n             }\n \n-            &ty::PredicateKind::ClosureKind(_, closure_substs, kind) => {\n+            ty::PredicateAtom::ClosureKind(_, closure_substs, kind) => {\n                 match self.infcx.closure_kind(closure_substs) {\n                     Some(closure_kind) => {\n                         if closure_kind.extends(kind) {\n@@ -489,7 +494,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 }\n             }\n \n-            &ty::PredicateKind::ConstEvaluatable(def_id, substs) => {\n+            ty::PredicateAtom::ConstEvaluatable(def_id, substs) => {\n                 match self.tcx().const_eval_resolve(\n                     obligation.param_env,\n                     def_id,\n@@ -503,7 +508,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 }\n             }\n \n-            ty::PredicateKind::ConstEquate(c1, c2) => {\n+            ty::PredicateAtom::ConstEquate(c1, c2) => {\n                 debug!(\"evaluate_predicate_recursively: equating consts c1={:?} c2={:?}\", c1, c2);\n \n                 let evaluate = |c: &'tcx ty::Const<'tcx>| {\n@@ -669,10 +674,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             // if the regions match exactly.\n             let cycle = stack.iter().skip(1).take_while(|s| s.depth >= cycle_depth);\n             let tcx = self.tcx();\n-            let cycle = cycle.map(|stack| {\n-                ty::PredicateKind::Trait(stack.obligation.predicate, hir::Constness::NotConst)\n-                    .to_predicate(tcx)\n-            });\n+            let cycle =\n+                cycle.map(|stack| stack.obligation.predicate.without_const().to_predicate(tcx));\n             if self.coinductive_match(cycle) {\n                 debug!(\"evaluate_stack({:?}) --> recursive, coinductive\", stack.fresh_trait_ref);\n                 Some(EvaluatedToOk)\n@@ -786,8 +789,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     }\n \n     fn coinductive_predicate(&self, predicate: ty::Predicate<'tcx>) -> bool {\n-        let result = match predicate.kind() {\n-            ty::PredicateKind::Trait(ref data, _) => self.tcx().trait_is_auto(data.def_id()),\n+        let result = match predicate.skip_binders() {\n+            ty::PredicateAtom::Trait(ref data, _) => self.tcx().trait_is_auto(data.def_id()),\n             _ => false,\n         };\n         debug!(\"coinductive_predicate({:?}) = {:?}\", predicate, result);\n@@ -1295,8 +1298,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         };\n \n         let matching_bound = predicates.iter().find_map(|bound| {\n-            if let ty::PredicateKind::Trait(bound, _) = bound.kind() {\n-                let bound = bound.to_poly_trait_ref();\n+            if let ty::PredicateAtom::Trait(pred, _) = bound.skip_binders() {\n+                let bound = ty::Binder::bind(pred.trait_ref);\n                 if self.infcx.probe(|_| {\n                     self.match_projection(obligation, bound, placeholder_trait_predicate.trait_ref)\n                 }) {"}, {"sha": "cc8997078e0f09e8be8d249074b31370ec3a8513", "filename": "src/librustc_trait_selection/traits/util.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/76e83339bb619aba206e5590b1e4b813a154b199/src%2Flibrustc_trait_selection%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76e83339bb619aba206e5590b1e4b813a154b199/src%2Flibrustc_trait_selection%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Futil.rs?ref=76e83339bb619aba206e5590b1e4b813a154b199", "patch": "@@ -59,8 +59,8 @@ impl<'tcx> TraitAliasExpansionInfo<'tcx> {\n         );\n     }\n \n-    pub fn trait_ref(&self) -> &ty::PolyTraitRef<'tcx> {\n-        &self.top().0\n+    pub fn trait_ref(&self) -> ty::PolyTraitRef<'tcx> {\n+        self.top().0\n     }\n \n     pub fn top(&self) -> &(ty::PolyTraitRef<'tcx>, Span) {\n@@ -109,7 +109,7 @@ impl<'tcx> TraitAliasExpander<'tcx> {\n \n         // Don't recurse if this trait alias is already on the stack for the DFS search.\n         let anon_pred = anonymize_predicate(tcx, pred);\n-        if item.path.iter().rev().skip(1).any(|(tr, _)| {\n+        if item.path.iter().rev().skip(1).any(|&(tr, _)| {\n             anonymize_predicate(tcx, tr.without_const().to_predicate(tcx)) == anon_pred\n         }) {\n             return false;"}, {"sha": "d225b10834a6b33e3744690733743c5cc385c78f", "filename": "src/librustc_trait_selection/traits/wf.rs", "status": "modified", "additions": 32, "deletions": 36, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/76e83339bb619aba206e5590b1e4b813a154b199/src%2Flibrustc_trait_selection%2Ftraits%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76e83339bb619aba206e5590b1e4b813a154b199/src%2Flibrustc_trait_selection%2Ftraits%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fwf.rs?ref=76e83339bb619aba206e5590b1e4b813a154b199", "patch": "@@ -93,38 +93,37 @@ pub fn predicate_obligations<'a, 'tcx>(\n ) -> Vec<traits::PredicateObligation<'tcx>> {\n     let mut wf = WfPredicates { infcx, param_env, body_id, span, out: vec![], item: None };\n \n-    // (*) ok to skip binders, because wf code is prepared for it\n-    match predicate.kind() {\n-        ty::PredicateKind::Trait(t, _) => {\n-            wf.compute_trait_ref(&t.skip_binder().trait_ref, Elaborate::None); // (*)\n+    // It's ok to skip the binder here because wf code is prepared for it\n+    match predicate.skip_binders() {\n+        ty::PredicateAtom::Trait(t, _) => {\n+            wf.compute_trait_ref(&t.trait_ref, Elaborate::None);\n         }\n-        ty::PredicateKind::RegionOutlives(..) => {}\n-        ty::PredicateKind::TypeOutlives(t) => {\n-            wf.compute(t.skip_binder().0.into());\n+        ty::PredicateAtom::RegionOutlives(..) => {}\n+        ty::PredicateAtom::TypeOutlives(ty::OutlivesPredicate(ty, _reg)) => {\n+            wf.compute(ty.into());\n         }\n-        ty::PredicateKind::Projection(t) => {\n-            let t = t.skip_binder(); // (*)\n+        ty::PredicateAtom::Projection(t) => {\n             wf.compute_projection(t.projection_ty);\n             wf.compute(t.ty.into());\n         }\n-        &ty::PredicateKind::WellFormed(arg) => {\n+        ty::PredicateAtom::WellFormed(arg) => {\n             wf.compute(arg);\n         }\n-        ty::PredicateKind::ObjectSafe(_) => {}\n-        ty::PredicateKind::ClosureKind(..) => {}\n-        ty::PredicateKind::Subtype(data) => {\n-            wf.compute(data.skip_binder().a.into()); // (*)\n-            wf.compute(data.skip_binder().b.into()); // (*)\n+        ty::PredicateAtom::ObjectSafe(_) => {}\n+        ty::PredicateAtom::ClosureKind(..) => {}\n+        ty::PredicateAtom::Subtype(ty::SubtypePredicate { a, b, a_is_expected: _ }) => {\n+            wf.compute(a.into());\n+            wf.compute(b.into());\n         }\n-        &ty::PredicateKind::ConstEvaluatable(def, substs) => {\n+        ty::PredicateAtom::ConstEvaluatable(def, substs) => {\n             let obligations = wf.nominal_obligations(def.did, substs);\n             wf.out.extend(obligations);\n \n             for arg in substs.iter() {\n                 wf.compute(arg);\n             }\n         }\n-        &ty::PredicateKind::ConstEquate(c1, c2) => {\n+        ty::PredicateAtom::ConstEquate(c1, c2) => {\n             wf.compute(c1.into());\n             wf.compute(c2.into());\n         }\n@@ -176,7 +175,7 @@ fn extend_cause_with_original_assoc_item_obligation<'tcx>(\n     trait_ref: &ty::TraitRef<'tcx>,\n     item: Option<&hir::Item<'tcx>>,\n     cause: &mut traits::ObligationCause<'tcx>,\n-    pred: &ty::Predicate<'_>,\n+    pred: &ty::Predicate<'tcx>,\n     mut trait_assoc_items: impl Iterator<Item = &'tcx ty::AssocItem>,\n ) {\n     debug!(\n@@ -192,15 +191,16 @@ fn extend_cause_with_original_assoc_item_obligation<'tcx>(\n             hir::ImplItemKind::Const(ty, _) | hir::ImplItemKind::TyAlias(ty) => ty.span,\n             _ => impl_item_ref.span,\n         };\n-    match pred.kind() {\n-        ty::PredicateKind::Projection(proj) => {\n+\n+    // It is fine to skip the binder as we don't care about regions here.\n+    match pred.skip_binders() {\n+        ty::PredicateAtom::Projection(proj) => {\n             // The obligation comes not from the current `impl` nor the `trait` being implemented,\n             // but rather from a \"second order\" obligation, where an associated type has a\n             // projection coming from another associated type. See\n             // `src/test/ui/associated-types/point-at-type-on-obligation-failure.rs` and\n             // `traits-assoc-type-in-supertrait-bad.rs`.\n-            let kind = &proj.ty().skip_binder().kind;\n-            if let ty::Projection(projection_ty) = kind {\n+            if let ty::Projection(projection_ty) = proj.ty.kind {\n                 let trait_assoc_item = tcx.associated_item(projection_ty.item_def_id);\n                 if let Some(impl_item_span) =\n                     items.iter().find(|item| item.ident == trait_assoc_item.ident).map(fix_span)\n@@ -209,15 +209,13 @@ fn extend_cause_with_original_assoc_item_obligation<'tcx>(\n                 }\n             }\n         }\n-        ty::PredicateKind::Trait(pred, _) => {\n+        ty::PredicateAtom::Trait(pred, _) => {\n             // An associated item obligation born out of the `trait` failed to be met. An example\n             // can be seen in `ui/associated-types/point-at-type-on-obligation-failure-2.rs`.\n             debug!(\"extended_cause_with_original_assoc_item_obligation trait proj {:?}\", pred);\n-            if let ty::Projection(ty::ProjectionTy { item_def_id, .. }) =\n-                &pred.skip_binder().self_ty().kind\n-            {\n+            if let ty::Projection(ty::ProjectionTy { item_def_id, .. }) = pred.self_ty().kind {\n                 if let Some(impl_item_span) = trait_assoc_items\n-                    .find(|i| i.def_id == *item_def_id)\n+                    .find(|i| i.def_id == item_def_id)\n                     .and_then(|trait_assoc_item| {\n                         items.iter().find(|i| i.ident == trait_assoc_item.ident).map(fix_span)\n                     })\n@@ -316,7 +314,7 @@ impl<'a, 'tcx> WfPredicates<'a, 'tcx> {\n                     traits::Obligation::new(\n                         new_cause,\n                         param_env,\n-                        ty::PredicateKind::WellFormed(arg).to_predicate(tcx),\n+                        ty::PredicateAtom::WellFormed(arg).to_predicate(tcx),\n                     )\n                 }),\n         );\n@@ -373,7 +371,7 @@ impl<'a, 'tcx> WfPredicates<'a, 'tcx> {\n                             let obligations = self.nominal_obligations(def.did, substs);\n                             self.out.extend(obligations);\n \n-                            let predicate = ty::PredicateKind::ConstEvaluatable(def, substs)\n+                            let predicate = ty::PredicateAtom::ConstEvaluatable(def, substs)\n                                 .to_predicate(self.tcx());\n                             let cause = self.cause(traits::MiscObligation);\n                             self.out.push(traits::Obligation::new(\n@@ -395,7 +393,7 @@ impl<'a, 'tcx> WfPredicates<'a, 'tcx> {\n                                 self.out.push(traits::Obligation::new(\n                                     cause,\n                                     self.param_env,\n-                                    ty::PredicateKind::WellFormed(resolved_constant.into())\n+                                    ty::PredicateAtom::WellFormed(resolved_constant.into())\n                                         .to_predicate(self.tcx()),\n                                 ));\n                             }\n@@ -481,10 +479,8 @@ impl<'a, 'tcx> WfPredicates<'a, 'tcx> {\n                         self.out.push(traits::Obligation::new(\n                             cause,\n                             param_env,\n-                            ty::PredicateKind::TypeOutlives(ty::Binder::dummy(\n-                                ty::OutlivesPredicate(rty, r),\n-                            ))\n-                            .to_predicate(self.tcx()),\n+                            ty::PredicateAtom::TypeOutlives(ty::OutlivesPredicate(rty, r))\n+                                .to_predicate(self.tcx()),\n                         ));\n                     }\n                 }\n@@ -574,7 +570,7 @@ impl<'a, 'tcx> WfPredicates<'a, 'tcx> {\n                             traits::Obligation::new(\n                                 cause.clone(),\n                                 param_env,\n-                                ty::PredicateKind::ObjectSafe(did).to_predicate(tcx),\n+                                ty::PredicateAtom::ObjectSafe(did).to_predicate(tcx),\n                             )\n                         }));\n                     }\n@@ -600,7 +596,7 @@ impl<'a, 'tcx> WfPredicates<'a, 'tcx> {\n                         self.out.push(traits::Obligation::new(\n                             cause,\n                             param_env,\n-                            ty::PredicateKind::WellFormed(ty.into()).to_predicate(self.tcx()),\n+                            ty::PredicateAtom::WellFormed(ty.into()).to_predicate(self.tcx()),\n                         ));\n                     } else {\n                         // Yes, resolved, proceed with the result."}, {"sha": "75785076d9ac1cd92d114d3fef82b720353e62b0", "filename": "src/librustc_traits/chalk/lowering.rs", "status": "modified", "additions": 72, "deletions": 45, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/76e83339bb619aba206e5590b1e4b813a154b199/src%2Flibrustc_traits%2Fchalk%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76e83339bb619aba206e5590b1e4b813a154b199/src%2Flibrustc_traits%2Fchalk%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fchalk%2Flowering.rs?ref=76e83339bb619aba206e5590b1e4b813a154b199", "patch": "@@ -78,10 +78,12 @@ impl<'tcx> LowerInto<'tcx, chalk_ir::InEnvironment<chalk_ir::Goal<RustInterner<'\n     ) -> chalk_ir::InEnvironment<chalk_ir::Goal<RustInterner<'tcx>>> {\n         let clauses = self.environment.into_iter().filter_map(|clause| match clause {\n             ChalkEnvironmentClause::Predicate(predicate) => {\n-                match predicate.kind() {\n-                    ty::PredicateKind::Trait(predicate, _) => {\n+                // FIXME(chalk): forall\n+                match predicate.bound_atom(interner.tcx).skip_binder() {\n+                    ty::PredicateAtom::Trait(predicate, _) => {\n+                        let predicate = ty::Binder::bind(predicate);\n                         let (predicate, binders, _named_regions) =\n-                            collect_bound_vars(interner, interner.tcx, predicate);\n+                            collect_bound_vars(interner, interner.tcx, &predicate);\n \n                         Some(\n                             chalk_ir::ProgramClauseData(chalk_ir::Binders::new(\n@@ -99,9 +101,10 @@ impl<'tcx> LowerInto<'tcx, chalk_ir::InEnvironment<chalk_ir::Goal<RustInterner<'\n                             .intern(interner),\n                         )\n                     }\n-                    ty::PredicateKind::RegionOutlives(predicate) => {\n+                    ty::PredicateAtom::RegionOutlives(predicate) => {\n+                        let predicate = ty::Binder::bind(predicate);\n                         let (predicate, binders, _named_regions) =\n-                            collect_bound_vars(interner, interner.tcx, predicate);\n+                            collect_bound_vars(interner, interner.tcx, &predicate);\n \n                         Some(\n                             chalk_ir::ProgramClauseData(chalk_ir::Binders::new(\n@@ -123,10 +126,11 @@ impl<'tcx> LowerInto<'tcx, chalk_ir::InEnvironment<chalk_ir::Goal<RustInterner<'\n                         )\n                     }\n                     // FIXME(chalk): need to add TypeOutlives\n-                    ty::PredicateKind::TypeOutlives(_) => None,\n-                    ty::PredicateKind::Projection(predicate) => {\n+                    ty::PredicateAtom::TypeOutlives(_) => None,\n+                    ty::PredicateAtom::Projection(predicate) => {\n+                        let predicate = ty::Binder::bind(predicate);\n                         let (predicate, binders, _named_regions) =\n-                            collect_bound_vars(interner, interner.tcx, predicate);\n+                            collect_bound_vars(interner, interner.tcx, &predicate);\n \n                         Some(\n                             chalk_ir::ProgramClauseData(chalk_ir::Binders::new(\n@@ -144,12 +148,12 @@ impl<'tcx> LowerInto<'tcx, chalk_ir::InEnvironment<chalk_ir::Goal<RustInterner<'\n                             .intern(interner),\n                         )\n                     }\n-                    ty::PredicateKind::WellFormed(..)\n-                    | ty::PredicateKind::ObjectSafe(..)\n-                    | ty::PredicateKind::ClosureKind(..)\n-                    | ty::PredicateKind::Subtype(..)\n-                    | ty::PredicateKind::ConstEvaluatable(..)\n-                    | ty::PredicateKind::ConstEquate(..) => {\n+                    ty::PredicateAtom::WellFormed(..)\n+                    | ty::PredicateAtom::ObjectSafe(..)\n+                    | ty::PredicateAtom::ClosureKind(..)\n+                    | ty::PredicateAtom::Subtype(..)\n+                    | ty::PredicateAtom::ConstEvaluatable(..)\n+                    | ty::PredicateAtom::ConstEquate(..) => {\n                         bug!(\"unexpected predicate {}\", predicate)\n                     }\n                 }\n@@ -181,11 +185,15 @@ impl<'tcx> LowerInto<'tcx, chalk_ir::InEnvironment<chalk_ir::Goal<RustInterner<'\n \n impl<'tcx> LowerInto<'tcx, chalk_ir::GoalData<RustInterner<'tcx>>> for ty::Predicate<'tcx> {\n     fn lower_into(self, interner: &RustInterner<'tcx>) -> chalk_ir::GoalData<RustInterner<'tcx>> {\n-        match self.kind() {\n-            ty::PredicateKind::Trait(predicate, _) => predicate.lower_into(interner),\n-            ty::PredicateKind::RegionOutlives(predicate) => {\n+        // FIXME(chalk): forall\n+        match self.bound_atom(interner.tcx).skip_binder() {\n+            ty::PredicateAtom::Trait(predicate, _) => {\n+                ty::Binder::bind(predicate).lower_into(interner)\n+            }\n+            ty::PredicateAtom::RegionOutlives(predicate) => {\n+                let predicate = ty::Binder::bind(predicate);\n                 let (predicate, binders, _named_regions) =\n-                    collect_bound_vars(interner, interner.tcx, predicate);\n+                    collect_bound_vars(interner, interner.tcx, &predicate);\n \n                 chalk_ir::GoalData::Quantified(\n                     chalk_ir::QuantifierKind::ForAll,\n@@ -202,20 +210,34 @@ impl<'tcx> LowerInto<'tcx, chalk_ir::GoalData<RustInterner<'tcx>>> for ty::Predi\n                 )\n             }\n             // FIXME(chalk): TypeOutlives\n-            ty::PredicateKind::TypeOutlives(_predicate) => {\n+            ty::PredicateAtom::TypeOutlives(_predicate) => {\n                 chalk_ir::GoalData::All(chalk_ir::Goals::new(interner))\n             }\n-            ty::PredicateKind::Projection(predicate) => predicate.lower_into(interner),\n-            ty::PredicateKind::WellFormed(arg) => match arg.unpack() {\n+            ty::PredicateAtom::Projection(predicate) => {\n+                ty::Binder::bind(predicate).lower_into(interner)\n+            }\n+            ty::PredicateAtom::WellFormed(arg) => match arg.unpack() {\n                 GenericArgKind::Type(ty) => match ty.kind {\n                     // FIXME(chalk): In Chalk, a placeholder is WellFormed if it\n                     // `FromEnv`. However, when we \"lower\" Params, we don't update\n                     // the environment.\n                     ty::Placeholder(..) => chalk_ir::GoalData::All(chalk_ir::Goals::new(interner)),\n \n-                    _ => chalk_ir::GoalData::DomainGoal(chalk_ir::DomainGoal::WellFormed(\n-                        chalk_ir::WellFormed::Ty(ty.lower_into(interner)),\n-                    )),\n+                    _ => {\n+                        let (ty, binders, _named_regions) =\n+                            collect_bound_vars(interner, interner.tcx, &ty::Binder::bind(ty));\n+\n+                        chalk_ir::GoalData::Quantified(\n+                            chalk_ir::QuantifierKind::ForAll,\n+                            chalk_ir::Binders::new(\n+                                binders,\n+                                chalk_ir::GoalData::DomainGoal(chalk_ir::DomainGoal::WellFormed(\n+                                    chalk_ir::WellFormed::Ty(ty.lower_into(interner)),\n+                                ))\n+                                .intern(interner),\n+                            ),\n+                        )\n+                    }\n                 },\n                 // FIXME(chalk): handle well formed consts\n                 GenericArgKind::Const(..) => {\n@@ -224,18 +246,18 @@ impl<'tcx> LowerInto<'tcx, chalk_ir::GoalData<RustInterner<'tcx>>> for ty::Predi\n                 GenericArgKind::Lifetime(lt) => bug!(\"unexpect well formed predicate: {:?}\", lt),\n             },\n \n-            ty::PredicateKind::ObjectSafe(t) => chalk_ir::GoalData::DomainGoal(\n-                chalk_ir::DomainGoal::ObjectSafe(chalk_ir::TraitId(*t)),\n+            ty::PredicateAtom::ObjectSafe(t) => chalk_ir::GoalData::DomainGoal(\n+                chalk_ir::DomainGoal::ObjectSafe(chalk_ir::TraitId(t)),\n             ),\n \n             // FIXME(chalk): other predicates\n             //\n             // We can defer this, but ultimately we'll want to express\n             // some of these in terms of chalk operations.\n-            ty::PredicateKind::ClosureKind(..)\n-            | ty::PredicateKind::Subtype(..)\n-            | ty::PredicateKind::ConstEvaluatable(..)\n-            | ty::PredicateKind::ConstEquate(..) => {\n+            ty::PredicateAtom::ClosureKind(..)\n+            | ty::PredicateAtom::Subtype(..)\n+            | ty::PredicateAtom::ConstEvaluatable(..)\n+            | ty::PredicateAtom::ConstEquate(..) => {\n                 chalk_ir::GoalData::All(chalk_ir::Goals::new(interner))\n             }\n         }\n@@ -532,19 +554,22 @@ impl<'tcx> LowerInto<'tcx, Option<chalk_ir::QuantifiedWhereClause<RustInterner<'\n         self,\n         interner: &RustInterner<'tcx>,\n     ) -> Option<chalk_ir::QuantifiedWhereClause<RustInterner<'tcx>>> {\n-        match &self.kind() {\n-            ty::PredicateKind::Trait(predicate, _) => {\n+        // FIXME(chalk): forall\n+        match self.bound_atom(interner.tcx).skip_binder() {\n+            ty::PredicateAtom::Trait(predicate, _) => {\n+                let predicate = ty::Binder::bind(predicate);\n                 let (predicate, binders, _named_regions) =\n-                    collect_bound_vars(interner, interner.tcx, predicate);\n+                    collect_bound_vars(interner, interner.tcx, &predicate);\n \n                 Some(chalk_ir::Binders::new(\n                     binders,\n                     chalk_ir::WhereClause::Implemented(predicate.trait_ref.lower_into(interner)),\n                 ))\n             }\n-            ty::PredicateKind::RegionOutlives(predicate) => {\n+            ty::PredicateAtom::RegionOutlives(predicate) => {\n+                let predicate = ty::Binder::bind(predicate);\n                 let (predicate, binders, _named_regions) =\n-                    collect_bound_vars(interner, interner.tcx, predicate);\n+                    collect_bound_vars(interner, interner.tcx, &predicate);\n \n                 Some(chalk_ir::Binders::new(\n                     binders,\n@@ -554,15 +579,15 @@ impl<'tcx> LowerInto<'tcx, Option<chalk_ir::QuantifiedWhereClause<RustInterner<'\n                     }),\n                 ))\n             }\n-            ty::PredicateKind::TypeOutlives(_predicate) => None,\n-            ty::PredicateKind::Projection(_predicate) => None,\n-            ty::PredicateKind::WellFormed(_ty) => None,\n-\n-            ty::PredicateKind::ObjectSafe(..)\n-            | ty::PredicateKind::ClosureKind(..)\n-            | ty::PredicateKind::Subtype(..)\n-            | ty::PredicateKind::ConstEvaluatable(..)\n-            | ty::PredicateKind::ConstEquate(..) => bug!(\"unexpected predicate {}\", &self),\n+            ty::PredicateAtom::TypeOutlives(_predicate) => None,\n+            ty::PredicateAtom::Projection(_predicate) => None,\n+            ty::PredicateAtom::WellFormed(_ty) => None,\n+\n+            ty::PredicateAtom::ObjectSafe(..)\n+            | ty::PredicateAtom::ClosureKind(..)\n+            | ty::PredicateAtom::Subtype(..)\n+            | ty::PredicateAtom::ConstEvaluatable(..)\n+            | ty::PredicateAtom::ConstEquate(..) => bug!(\"unexpected predicate {}\", &self),\n         }\n     }\n }\n@@ -632,7 +657,9 @@ crate fn collect_bound_vars<'a, 'tcx, T: TypeFoldable<'tcx>>(\n     }\n \n     (0..parameters.len()).for_each(|i| {\n-        parameters.get(&(i as u32)).expect(&format!(\"Skipped bound var index `{:?}`.\", i));\n+        parameters\n+            .get(&(i as u32))\n+            .or_else(|| bug!(\"Skipped bound var index: ty={:?}, parameters={:?}\", ty, parameters));\n     });\n \n     let binders = chalk_ir::VariableKinds::from(interner, parameters.into_iter().map(|(_, v)| v));"}, {"sha": "de3096eac9b193df599036065968bbcfe796ac73", "filename": "src/librustc_traits/implied_outlives_bounds.rs", "status": "modified", "additions": 15, "deletions": 19, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/76e83339bb619aba206e5590b1e4b813a154b199/src%2Flibrustc_traits%2Fimplied_outlives_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76e83339bb619aba206e5590b1e4b813a154b199/src%2Flibrustc_traits%2Fimplied_outlives_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fimplied_outlives_bounds.rs?ref=76e83339bb619aba206e5590b1e4b813a154b199", "patch": "@@ -95,29 +95,25 @@ fn compute_implied_outlives_bounds<'tcx>(\n         implied_bounds.extend(obligations.into_iter().flat_map(|obligation| {\n             assert!(!obligation.has_escaping_bound_vars());\n             match obligation.predicate.kind() {\n-                ty::PredicateKind::Trait(..)\n-                | ty::PredicateKind::Subtype(..)\n-                | ty::PredicateKind::Projection(..)\n-                | ty::PredicateKind::ClosureKind(..)\n-                | ty::PredicateKind::ObjectSafe(..)\n-                | ty::PredicateKind::ConstEvaluatable(..)\n-                | ty::PredicateKind::ConstEquate(..) => vec![],\n-\n-                &ty::PredicateKind::WellFormed(arg) => {\n-                    wf_args.push(arg);\n-                    vec![]\n-                }\n+                &ty::PredicateKind::ForAll(..) => vec![],\n+                &ty::PredicateKind::Atom(atom) => match atom {\n+                    ty::PredicateAtom::Trait(..)\n+                    | ty::PredicateAtom::Subtype(..)\n+                    | ty::PredicateAtom::Projection(..)\n+                    | ty::PredicateAtom::ClosureKind(..)\n+                    | ty::PredicateAtom::ObjectSafe(..)\n+                    | ty::PredicateAtom::ConstEvaluatable(..)\n+                    | ty::PredicateAtom::ConstEquate(..) => vec![],\n+                    ty::PredicateAtom::WellFormed(arg) => {\n+                        wf_args.push(arg);\n+                        vec![]\n+                    }\n \n-                ty::PredicateKind::RegionOutlives(ref data) => match data.no_bound_vars() {\n-                    None => vec![],\n-                    Some(ty::OutlivesPredicate(r_a, r_b)) => {\n+                    ty::PredicateAtom::RegionOutlives(ty::OutlivesPredicate(r_a, r_b)) => {\n                         vec![OutlivesBound::RegionSubRegion(r_b, r_a)]\n                     }\n-                },\n \n-                ty::PredicateKind::TypeOutlives(ref data) => match data.no_bound_vars() {\n-                    None => vec![],\n-                    Some(ty::OutlivesPredicate(ty_a, r_b)) => {\n+                    ty::PredicateAtom::TypeOutlives(ty::OutlivesPredicate(ty_a, r_b)) => {\n                         let ty_a = infcx.resolve_vars_if_possible(&ty_a);\n                         let mut components = smallvec![];\n                         tcx.push_outlives_components(ty_a, &mut components);"}, {"sha": "83aee31a39f3c223ae6af037ac29ebda5cacc3b2", "filename": "src/librustc_traits/normalize_erasing_regions.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/76e83339bb619aba206e5590b1e4b813a154b199/src%2Flibrustc_traits%2Fnormalize_erasing_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76e83339bb619aba206e5590b1e4b813a154b199/src%2Flibrustc_traits%2Fnormalize_erasing_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fnormalize_erasing_regions.rs?ref=76e83339bb619aba206e5590b1e4b813a154b199", "patch": "@@ -39,16 +39,16 @@ fn normalize_generic_arg_after_erasing_regions<'tcx>(\n     })\n }\n \n-fn not_outlives_predicate(p: &ty::Predicate<'_>) -> bool {\n-    match p.kind() {\n-        ty::PredicateKind::RegionOutlives(..) | ty::PredicateKind::TypeOutlives(..) => false,\n-        ty::PredicateKind::Trait(..)\n-        | ty::PredicateKind::Projection(..)\n-        | ty::PredicateKind::WellFormed(..)\n-        | ty::PredicateKind::ObjectSafe(..)\n-        | ty::PredicateKind::ClosureKind(..)\n-        | ty::PredicateKind::Subtype(..)\n-        | ty::PredicateKind::ConstEvaluatable(..)\n-        | ty::PredicateKind::ConstEquate(..) => true,\n+fn not_outlives_predicate(p: &ty::Predicate<'tcx>) -> bool {\n+    match p.skip_binders() {\n+        ty::PredicateAtom::RegionOutlives(..) | ty::PredicateAtom::TypeOutlives(..) => false,\n+        ty::PredicateAtom::Trait(..)\n+        | ty::PredicateAtom::Projection(..)\n+        | ty::PredicateAtom::WellFormed(..)\n+        | ty::PredicateAtom::ObjectSafe(..)\n+        | ty::PredicateAtom::ClosureKind(..)\n+        | ty::PredicateAtom::Subtype(..)\n+        | ty::PredicateAtom::ConstEvaluatable(..)\n+        | ty::PredicateAtom::ConstEquate(..) => true,\n     }\n }"}, {"sha": "139ed6dcd350c8b616b936b0599f8fbbab049dd9", "filename": "src/librustc_traits/type_op.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/76e83339bb619aba206e5590b1e4b813a154b199/src%2Flibrustc_traits%2Ftype_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76e83339bb619aba206e5590b1e4b813a154b199/src%2Flibrustc_traits%2Ftype_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Ftype_op.rs?ref=76e83339bb619aba206e5590b1e4b813a154b199", "patch": "@@ -140,7 +140,7 @@ impl AscribeUserTypeCx<'me, 'tcx> {\n             self.relate(self_ty, Variance::Invariant, impl_self_ty)?;\n \n             self.prove_predicate(\n-                ty::PredicateKind::WellFormed(impl_self_ty.into()).to_predicate(self.tcx()),\n+                ty::PredicateAtom::WellFormed(impl_self_ty.into()).to_predicate(self.tcx()),\n             );\n         }\n \n@@ -155,7 +155,7 @@ impl AscribeUserTypeCx<'me, 'tcx> {\n         // them?  This would only be relevant if some input\n         // type were ill-formed but did not appear in `ty`,\n         // which...could happen with normalization...\n-        self.prove_predicate(ty::PredicateKind::WellFormed(ty.into()).to_predicate(self.tcx()));\n+        self.prove_predicate(ty::PredicateAtom::WellFormed(ty.into()).to_predicate(self.tcx()));\n         Ok(())\n     }\n }"}, {"sha": "7f954dacf3e893c4a3b96bf9a9d0c2ad6c74fce0", "filename": "src/librustc_ty/ty.rs", "status": "modified", "additions": 15, "deletions": 16, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/76e83339bb619aba206e5590b1e4b813a154b199/src%2Flibrustc_ty%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76e83339bb619aba206e5590b1e4b813a154b199/src%2Flibrustc_ty%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ty%2Fty.rs?ref=76e83339bb619aba206e5590b1e4b813a154b199", "patch": "@@ -392,23 +392,23 @@ fn associated_type_projection_predicates(\n \n     let predicates = item_predicates.filter_map(|obligation| {\n         let pred = obligation.predicate;\n-        match pred.kind() {\n-            ty::PredicateKind::Trait(tr, _) => {\n-                if let ty::Projection(p) = tr.skip_binder().self_ty().kind {\n+        match pred.skip_binders() {\n+            ty::PredicateAtom::Trait(tr, _) => {\n+                if let ty::Projection(p) = tr.self_ty().kind {\n                     if p == assoc_item_ty {\n                         return Some(pred);\n                     }\n                 }\n             }\n-            ty::PredicateKind::Projection(proj) => {\n-                if let ty::Projection(p) = proj.skip_binder().projection_ty.self_ty().kind {\n+            ty::PredicateAtom::Projection(proj) => {\n+                if let ty::Projection(p) = proj.projection_ty.self_ty().kind {\n                     if p == assoc_item_ty {\n                         return Some(pred);\n                     }\n                 }\n             }\n-            ty::PredicateKind::TypeOutlives(outlives) => {\n-                if let ty::Projection(p) = outlives.skip_binder().0.kind {\n+            ty::PredicateAtom::TypeOutlives(outlives) => {\n+                if let ty::Projection(p) = outlives.0.kind {\n                     if p == assoc_item_ty {\n                         return Some(pred);\n                     }\n@@ -443,25 +443,24 @@ fn opaque_type_projection_predicates(\n \n     let filtered_predicates = predicates.filter_map(|obligation| {\n         let pred = obligation.predicate;\n-        match pred.kind() {\n-            ty::PredicateKind::Trait(tr, _) => {\n-                if let ty::Opaque(opaque_def_id, opaque_substs) = tr.skip_binder().self_ty().kind {\n+        match pred.skip_binders() {\n+            ty::PredicateAtom::Trait(tr, _) => {\n+                if let ty::Opaque(opaque_def_id, opaque_substs) = tr.self_ty().kind {\n                     if opaque_def_id == def_id && opaque_substs == substs {\n                         return Some(pred);\n                     }\n                 }\n             }\n-            ty::PredicateKind::Projection(proj) => {\n-                if let ty::Opaque(opaque_def_id, opaque_substs) =\n-                    proj.skip_binder().projection_ty.self_ty().kind\n+            ty::PredicateAtom::Projection(proj) => {\n+                if let ty::Opaque(opaque_def_id, opaque_substs) = proj.projection_ty.self_ty().kind\n                 {\n                     if opaque_def_id == def_id && opaque_substs == substs {\n                         return Some(pred);\n                     }\n                 }\n             }\n-            ty::PredicateKind::TypeOutlives(outlives) => {\n-                if let ty::Opaque(opaque_def_id, opaque_substs) = outlives.skip_binder().0.kind {\n+            ty::PredicateAtom::TypeOutlives(outlives) => {\n+                if let ty::Opaque(opaque_def_id, opaque_substs) = outlives.0.kind {\n                     if opaque_def_id == def_id && opaque_substs == substs {\n                         return Some(pred);\n                     }\n@@ -471,7 +470,7 @@ fn opaque_type_projection_predicates(\n                 }\n             }\n             // These can come from elaborating other predicates\n-            ty::PredicateKind::RegionOutlives(_) => return None,\n+            ty::PredicateAtom::RegionOutlives(_) => return None,\n             _ => {}\n         }\n         tcx.sess.delay_span_bug("}, {"sha": "79d2f104a525fe32b2a796e046b0a982ae4e293a", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/76e83339bb619aba206e5590b1e4b813a154b199/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76e83339bb619aba206e5590b1e4b813a154b199/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=76e83339bb619aba206e5590b1e4b813a154b199", "patch": "@@ -1705,16 +1705,19 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                     \"conv_object_ty_poly_trait_ref: observing object predicate `{:?}`\",\n                     obligation.predicate\n                 );\n-                match obligation.predicate.kind() {\n-                    ty::PredicateKind::Trait(pred, _) => {\n+\n+                match obligation.predicate.skip_binders() {\n+                    ty::PredicateAtom::Trait(pred, _) => {\n+                        let pred = ty::Binder::bind(pred);\n                         associated_types.entry(span).or_default().extend(\n                             tcx.associated_items(pred.def_id())\n                                 .in_definition_order()\n                                 .filter(|item| item.kind == ty::AssocKind::Type)\n                                 .map(|item| item.def_id),\n                         );\n                     }\n-                    &ty::PredicateKind::Projection(pred) => {\n+                    ty::PredicateAtom::Projection(pred) => {\n+                        let pred = ty::Binder::bind(pred);\n                         // A `Self` within the original bound will be substituted with a\n                         // `trait_object_dummy_self`, so check for that.\n                         let references_self ="}, {"sha": "255f611cfa3572c2f5aca33850d0b608afb36e39", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 13, "deletions": 4, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/76e83339bb619aba206e5590b1e4b813a154b199/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76e83339bb619aba206e5590b1e4b813a154b199/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=76e83339bb619aba206e5590b1e4b813a154b199", "patch": "@@ -206,11 +206,15 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     obligation.predicate\n                 );\n \n-                if let &ty::PredicateKind::Projection(proj_predicate) = obligation.predicate.kind()\n+                if let ty::PredicateAtom::Projection(proj_predicate) =\n+                    obligation.predicate.skip_binders()\n                 {\n                     // Given a Projection predicate, we can potentially infer\n                     // the complete signature.\n-                    self.deduce_sig_from_projection(Some(obligation.cause.span), proj_predicate)\n+                    self.deduce_sig_from_projection(\n+                        Some(obligation.cause.span),\n+                        ty::Binder::bind(proj_predicate),\n+                    )\n                 } else {\n                     None\n                 }\n@@ -627,8 +631,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // where R is the return type we are expecting. This type `T`\n         // will be our output.\n         let output_ty = self.obligations_for_self_ty(ret_vid).find_map(|(_, obligation)| {\n-            if let &ty::PredicateKind::Projection(proj_predicate) = obligation.predicate.kind() {\n-                self.deduce_future_output_from_projection(obligation.cause.span, proj_predicate)\n+            if let ty::PredicateAtom::Projection(proj_predicate) =\n+                obligation.predicate.skip_binders()\n+            {\n+                self.deduce_future_output_from_projection(\n+                    obligation.cause.span,\n+                    ty::Binder::bind(proj_predicate),\n+                )\n             } else {\n                 None\n             }"}, {"sha": "c7e9b97e2dbde3565f4af38b03a9bb5827edc8fb", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/76e83339bb619aba206e5590b1e4b813a154b199/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76e83339bb619aba206e5590b1e4b813a154b199/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=76e83339bb619aba206e5590b1e4b813a154b199", "patch": "@@ -582,18 +582,18 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n         while !queue.is_empty() {\n             let obligation = queue.remove(0);\n             debug!(\"coerce_unsized resolve step: {:?}\", obligation);\n-            let trait_pred = match obligation.predicate.kind() {\n-                &ty::PredicateKind::Trait(trait_pred, _)\n+            let trait_pred = match obligation.predicate.skip_binders() {\n+                ty::PredicateAtom::Trait(trait_pred, _)\n                     if traits.contains(&trait_pred.def_id()) =>\n                 {\n                     if unsize_did == trait_pred.def_id() {\n-                        let unsize_ty = trait_pred.skip_binder().trait_ref.substs[1].expect_ty();\n+                        let unsize_ty = trait_pred.trait_ref.substs[1].expect_ty();\n                         if let ty::Tuple(..) = unsize_ty.kind {\n                             debug!(\"coerce_unsized: found unsized tuple coercion\");\n                             has_unsized_tuple_coercion = true;\n                         }\n                     }\n-                    trait_pred\n+                    ty::Binder::bind(trait_pred)\n                 }\n                 _ => {\n                     coercion.obligations.push(obligation);"}, {"sha": "88c47b38ccc40b4e3ade7e772416e6304abd54f0", "filename": "src/librustc_typeck/check/dropck.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/76e83339bb619aba206e5590b1e4b813a154b199/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76e83339bb619aba206e5590b1e4b813a154b199/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs?ref=76e83339bb619aba206e5590b1e4b813a154b199", "patch": "@@ -226,12 +226,12 @@ fn ensure_drop_predicates_are_implied_by_item_defn<'tcx>(\n         // could be extended easily also to the other `Predicate`.\n         let predicate_matches_closure = |p: Predicate<'tcx>| {\n             let mut relator: SimpleEqRelation<'tcx> = SimpleEqRelation::new(tcx, self_param_env);\n-            match (predicate.kind(), p.kind()) {\n-                (&ty::PredicateKind::Trait(a, _), &ty::PredicateKind::Trait(b, _)) => {\n-                    relator.relate(a, b).is_ok()\n+            match (predicate.skip_binders(), p.skip_binders()) {\n+                (ty::PredicateAtom::Trait(a, _), ty::PredicateAtom::Trait(b, _)) => {\n+                    relator.relate(ty::Binder::bind(a), ty::Binder::bind(b)).is_ok()\n                 }\n-                (&ty::PredicateKind::Projection(a), &ty::PredicateKind::Projection(b)) => {\n-                    relator.relate(a, b).is_ok()\n+                (ty::PredicateAtom::Projection(a), ty::PredicateAtom::Projection(b)) => {\n+                    relator.relate(ty::Binder::bind(a), ty::Binder::bind(b)).is_ok()\n                 }\n                 _ => predicate == p,\n             }"}, {"sha": "41e37ee9752521cd91c6ee644175b7fe536a94e0", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/76e83339bb619aba206e5590b1e4b813a154b199/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76e83339bb619aba206e5590b1e4b813a154b199/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=76e83339bb619aba206e5590b1e4b813a154b199", "patch": "@@ -447,21 +447,24 @@ impl<'a, 'tcx> ConfirmContext<'a, 'tcx> {\n         };\n \n         traits::elaborate_predicates(self.tcx, predicates.predicates.iter().copied())\n-            .filter_map(|obligation| match obligation.predicate.kind() {\n-                ty::PredicateKind::Trait(trait_pred, _) if trait_pred.def_id() == sized_def_id => {\n+            // We don't care about regions here.\n+            .filter_map(|obligation| match obligation.predicate.skip_binders() {\n+                ty::PredicateAtom::Trait(trait_pred, _) if trait_pred.def_id() == sized_def_id => {\n                     let span = predicates\n                         .predicates\n                         .iter()\n                         .zip(predicates.spans.iter())\n                         .find_map(\n-                            |(p, span)| if *p == obligation.predicate { Some(*span) } else { None },\n+                            |(p, span)| {\n+                                if *p == obligation.predicate { Some(*span) } else { None }\n+                            },\n                         )\n                         .unwrap_or(rustc_span::DUMMY_SP);\n                     Some((trait_pred, span))\n                 }\n                 _ => None,\n             })\n-            .find_map(|(trait_pred, span)| match trait_pred.skip_binder().self_ty().kind {\n+            .find_map(|(trait_pred, span)| match trait_pred.self_ty().kind {\n                 ty::Dynamic(..) => Some(span),\n                 _ => None,\n             })"}, {"sha": "c9a4df0317abcd2eb9b95a12247da93e045d239f", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/76e83339bb619aba206e5590b1e4b813a154b199/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76e83339bb619aba206e5590b1e4b813a154b199/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=76e83339bb619aba206e5590b1e4b813a154b199", "patch": "@@ -399,7 +399,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         obligations.push(traits::Obligation::new(\n             cause,\n             self.param_env,\n-            ty::PredicateKind::WellFormed(method_ty.into()).to_predicate(tcx),\n+            ty::PredicateAtom::WellFormed(method_ty.into()).to_predicate(tcx),\n         ));\n \n         let callee = MethodCallee { def_id, substs: trait_ref.substs, sig: fn_sig };"}, {"sha": "106df847a05cff8ed93e835827a5c11a61fb5ec0", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 22, "deletions": 19, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/76e83339bb619aba206e5590b1e4b813a154b199/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76e83339bb619aba206e5590b1e4b813a154b199/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=76e83339bb619aba206e5590b1e4b813a154b199", "patch": "@@ -798,25 +798,28 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n         // FIXME: do we want to commit to this behavior for param bounds?\n         debug!(\"assemble_inherent_candidates_from_param(param_ty={:?})\", param_ty);\n \n-        let bounds = self.param_env.caller_bounds().iter().filter_map(|predicate| match predicate\n-            .kind()\n-        {\n-            ty::PredicateKind::Trait(ref trait_predicate, _) => {\n-                match trait_predicate.skip_binder().trait_ref.self_ty().kind {\n-                    ty::Param(ref p) if *p == param_ty => Some(trait_predicate.to_poly_trait_ref()),\n-                    _ => None,\n-                }\n-            }\n-            ty::PredicateKind::Subtype(..)\n-            | ty::PredicateKind::Projection(..)\n-            | ty::PredicateKind::RegionOutlives(..)\n-            | ty::PredicateKind::WellFormed(..)\n-            | ty::PredicateKind::ObjectSafe(..)\n-            | ty::PredicateKind::ClosureKind(..)\n-            | ty::PredicateKind::TypeOutlives(..)\n-            | ty::PredicateKind::ConstEvaluatable(..)\n-            | ty::PredicateKind::ConstEquate(..) => None,\n-        });\n+        let bounds =\n+            self.param_env.caller_bounds().iter().map(ty::Predicate::skip_binders).filter_map(\n+                |predicate| match predicate {\n+                    ty::PredicateAtom::Trait(trait_predicate, _) => {\n+                        match trait_predicate.trait_ref.self_ty().kind {\n+                            ty::Param(ref p) if *p == param_ty => {\n+                                Some(ty::Binder::bind(trait_predicate.trait_ref))\n+                            }\n+                            _ => None,\n+                        }\n+                    }\n+                    ty::PredicateAtom::Subtype(..)\n+                    | ty::PredicateAtom::Projection(..)\n+                    | ty::PredicateAtom::RegionOutlives(..)\n+                    | ty::PredicateAtom::WellFormed(..)\n+                    | ty::PredicateAtom::ObjectSafe(..)\n+                    | ty::PredicateAtom::ClosureKind(..)\n+                    | ty::PredicateAtom::TypeOutlives(..)\n+                    | ty::PredicateAtom::ConstEvaluatable(..)\n+                    | ty::PredicateAtom::ConstEquate(..) => None,\n+                },\n+            );\n \n         self.elaborate_bounds(bounds, |this, poly_trait_ref, item| {\n             let trait_ref = this.erase_late_bound_regions(&poly_trait_ref);"}, {"sha": "ae2cf6daf5350a862cf71e60a099252dead67691", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 21, "deletions": 13, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/76e83339bb619aba206e5590b1e4b813a154b199/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76e83339bb619aba206e5590b1e4b813a154b199/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=76e83339bb619aba206e5590b1e4b813a154b199", "patch": "@@ -570,12 +570,14 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     };\n                     let mut type_params = FxHashMap::default();\n                     let mut bound_spans = vec![];\n+\n                     let mut collect_type_param_suggestions =\n-                        |self_ty: Ty<'_>, parent_pred: &ty::Predicate<'_>, obligation: &str| {\n-                            if let (ty::Param(_), ty::PredicateKind::Trait(p, _)) =\n-                                (&self_ty.kind, parent_pred.kind())\n+                        |self_ty: Ty<'tcx>, parent_pred: &ty::Predicate<'tcx>, obligation: &str| {\n+                            // We don't care about regions here, so it's fine to skip the binder here.\n+                            if let (ty::Param(_), ty::PredicateAtom::Trait(p, _)) =\n+                                (&self_ty.kind, parent_pred.skip_binders())\n                             {\n-                                if let ty::Adt(def, _) = p.skip_binder().trait_ref.self_ty().kind {\n+                                if let ty::Adt(def, _) = p.trait_ref.self_ty().kind {\n                                     let node = def.did.as_local().map(|def_id| {\n                                         self.tcx.hir().get(self.tcx.hir().as_local_hir_id(def_id))\n                                     });\n@@ -625,8 +627,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         }\n                     };\n                     let mut format_pred = |pred: ty::Predicate<'tcx>| {\n-                        match pred.kind() {\n-                            ty::PredicateKind::Projection(pred) => {\n+                        match pred.skip_binders() {\n+                            ty::PredicateAtom::Projection(pred) => {\n+                                let pred = ty::Binder::bind(pred);\n                                 // `<Foo as Iterator>::Item = String`.\n                                 let trait_ref =\n                                     pred.skip_binder().projection_ty.trait_ref(self.tcx);\n@@ -644,7 +647,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                 bound_span_label(trait_ref.self_ty(), &obligation, &quiet);\n                                 Some((obligation, trait_ref.self_ty()))\n                             }\n-                            ty::PredicateKind::Trait(poly_trait_ref, _) => {\n+                            ty::PredicateAtom::Trait(poly_trait_ref, _) => {\n+                                let poly_trait_ref = ty::Binder::bind(poly_trait_ref);\n                                 let p = poly_trait_ref.skip_binder().trait_ref;\n                                 let self_ty = p.self_ty();\n                                 let path = p.print_only_trait_path();\n@@ -950,12 +954,16 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 // this isn't perfect (that is, there are cases when\n                 // implementing a trait would be legal but is rejected\n                 // here).\n-                unsatisfied_predicates.iter().all(|(p, _)| match p.kind() {\n-                    // Hide traits if they are present in predicates as they can be fixed without\n-                    // having to implement them.\n-                    ty::PredicateKind::Trait(t, _) => t.def_id() == info.def_id,\n-                    ty::PredicateKind::Projection(p) => p.item_def_id() == info.def_id,\n-                    _ => false,\n+                unsatisfied_predicates.iter().all(|(p, _)| {\n+                    match p.skip_binders() {\n+                        // Hide traits if they are present in predicates as they can be fixed without\n+                        // having to implement them.\n+                        ty::PredicateAtom::Trait(t, _) => t.def_id() == info.def_id,\n+                        ty::PredicateAtom::Projection(p) => {\n+                            p.projection_ty.item_def_id == info.def_id\n+                        }\n+                        _ => false,\n+                    }\n                 }) && (type_is_local || info.def_id.is_local())\n                     && self\n                         .associated_item(info.def_id, item_name, Namespace::ValueNS)"}, {"sha": "6cefc99f7b1718a46a94158022c66a60e95fac7d", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 56, "deletions": 55, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/76e83339bb619aba206e5590b1e4b813a154b199/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76e83339bb619aba206e5590b1e4b813a154b199/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=76e83339bb619aba206e5590b1e4b813a154b199", "patch": "@@ -2392,26 +2392,26 @@ fn missing_items_err(\n }\n \n /// Resugar `ty::GenericPredicates` in a way suitable to be used in structured suggestions.\n-fn bounds_from_generic_predicates(\n-    tcx: TyCtxt<'_>,\n-    predicates: ty::GenericPredicates<'_>,\n+fn bounds_from_generic_predicates<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    predicates: ty::GenericPredicates<'tcx>,\n ) -> (String, String) {\n-    let mut types: FxHashMap<Ty<'_>, Vec<DefId>> = FxHashMap::default();\n+    let mut types: FxHashMap<Ty<'tcx>, Vec<DefId>> = FxHashMap::default();\n     let mut projections = vec![];\n     for (predicate, _) in predicates.predicates {\n         debug!(\"predicate {:?}\", predicate);\n-        match predicate.kind() {\n-            ty::PredicateKind::Trait(trait_predicate, _) => {\n-                let entry = types.entry(trait_predicate.skip_binder().self_ty()).or_default();\n-                let def_id = trait_predicate.skip_binder().def_id();\n+        match predicate.skip_binders() {\n+            ty::PredicateAtom::Trait(trait_predicate, _) => {\n+                let entry = types.entry(trait_predicate.self_ty()).or_default();\n+                let def_id = trait_predicate.def_id();\n                 if Some(def_id) != tcx.lang_items().sized_trait() {\n                     // Type params are `Sized` by default, do not add that restriction to the list\n                     // if it is a positive requirement.\n-                    entry.push(trait_predicate.skip_binder().def_id());\n+                    entry.push(trait_predicate.def_id());\n                 }\n             }\n-            ty::PredicateKind::Projection(projection_pred) => {\n-                projections.push(projection_pred);\n+            ty::PredicateAtom::Projection(projection_pred) => {\n+                projections.push(ty::Binder::bind(projection_pred));\n             }\n             _ => {}\n         }\n@@ -2456,11 +2456,11 @@ fn bounds_from_generic_predicates(\n }\n \n /// Return placeholder code for the given function.\n-fn fn_sig_suggestion(\n-    tcx: TyCtxt<'_>,\n-    sig: ty::FnSig<'_>,\n+fn fn_sig_suggestion<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    sig: ty::FnSig<'tcx>,\n     ident: Ident,\n-    predicates: ty::GenericPredicates<'_>,\n+    predicates: ty::GenericPredicates<'tcx>,\n     assoc: &ty::AssocItem,\n ) -> String {\n     let args = sig\n@@ -2938,10 +2938,8 @@ impl<'a, 'tcx> AstConv<'tcx> for FnCtxt<'a, 'tcx> {\n             parent: None,\n             predicates: tcx.arena.alloc_from_iter(\n                 self.param_env.caller_bounds().iter().filter_map(|predicate| {\n-                    match predicate.kind() {\n-                        ty::PredicateKind::Trait(ref data, _)\n-                            if data.skip_binder().self_ty().is_param(index) =>\n-                        {\n+                    match predicate.skip_binders() {\n+                        ty::PredicateAtom::Trait(data, _) if data.self_ty().is_param(index) => {\n                             // HACK(eddyb) should get the original `Span`.\n                             let span = tcx.def_span(def_id);\n                             Some((predicate, span))\n@@ -3612,7 +3610,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         self.register_predicate(traits::Obligation::new(\n             cause,\n             self.param_env,\n-            ty::PredicateKind::WellFormed(arg).to_predicate(self.tcx),\n+            ty::PredicateAtom::WellFormed(arg).to_predicate(self.tcx),\n         ));\n     }\n \n@@ -3893,29 +3891,31 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             .borrow()\n             .pending_obligations()\n             .into_iter()\n-            .filter_map(move |obligation| match obligation.predicate.kind() {\n-                ty::PredicateKind::Projection(ref data) => {\n-                    Some((data.to_poly_trait_ref(self.tcx), obligation))\n-                }\n-                ty::PredicateKind::Trait(ref data, _) => {\n-                    Some((data.to_poly_trait_ref(), obligation))\n+            .filter_map(move |obligation| {\n+                match obligation.predicate.skip_binders() {\n+                    ty::PredicateAtom::Projection(data) => {\n+                        Some((ty::Binder::bind(data).to_poly_trait_ref(self.tcx), obligation))\n+                    }\n+                    ty::PredicateAtom::Trait(data, _) => {\n+                        Some((ty::Binder::bind(data).to_poly_trait_ref(), obligation))\n+                    }\n+                    ty::PredicateAtom::Subtype(..) => None,\n+                    ty::PredicateAtom::RegionOutlives(..) => None,\n+                    ty::PredicateAtom::TypeOutlives(..) => None,\n+                    ty::PredicateAtom::WellFormed(..) => None,\n+                    ty::PredicateAtom::ObjectSafe(..) => None,\n+                    ty::PredicateAtom::ConstEvaluatable(..) => None,\n+                    ty::PredicateAtom::ConstEquate(..) => None,\n+                    // N.B., this predicate is created by breaking down a\n+                    // `ClosureType: FnFoo()` predicate, where\n+                    // `ClosureType` represents some `Closure`. It can't\n+                    // possibly be referring to the current closure,\n+                    // because we haven't produced the `Closure` for\n+                    // this closure yet; this is exactly why the other\n+                    // code is looking for a self type of a unresolved\n+                    // inference variable.\n+                    ty::PredicateAtom::ClosureKind(..) => None,\n                 }\n-                ty::PredicateKind::Subtype(..) => None,\n-                ty::PredicateKind::RegionOutlives(..) => None,\n-                ty::PredicateKind::TypeOutlives(..) => None,\n-                ty::PredicateKind::WellFormed(..) => None,\n-                ty::PredicateKind::ObjectSafe(..) => None,\n-                ty::PredicateKind::ConstEvaluatable(..) => None,\n-                ty::PredicateKind::ConstEquate(..) => None,\n-                // N.B., this predicate is created by breaking down a\n-                // `ClosureType: FnFoo()` predicate, where\n-                // `ClosureType` represents some `Closure`. It can't\n-                // possibly be referring to the current closure,\n-                // because we haven't produced the `Closure` for\n-                // this closure yet; this is exactly why the other\n-                // code is looking for a self type of a unresolved\n-                // inference variable.\n-                ty::PredicateKind::ClosureKind(..) => None,\n             })\n             .filter(move |(tr, _)| self.self_type_matches_expected_vid(*tr, ty_var_root))\n     }\n@@ -4225,7 +4225,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// the corresponding argument's expression span instead of the `fn` call path span.\n     fn point_at_arg_instead_of_call_if_possible(\n         &self,\n-        errors: &mut Vec<traits::FulfillmentError<'_>>,\n+        errors: &mut Vec<traits::FulfillmentError<'tcx>>,\n         final_arg_types: &[(usize, Ty<'tcx>, Ty<'tcx>)],\n         call_sp: Span,\n         args: &'tcx [hir::Expr<'tcx>],\n@@ -4244,7 +4244,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 continue;\n             }\n \n-            if let ty::PredicateKind::Trait(predicate, _) = error.obligation.predicate.kind() {\n+            if let ty::PredicateAtom::Trait(predicate, _) =\n+                error.obligation.predicate.skip_binders()\n+            {\n                 // Collect the argument position for all arguments that could have caused this\n                 // `FulfillmentError`.\n                 let mut referenced_in = final_arg_types\n@@ -4255,7 +4257,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         let ty = self.resolve_vars_if_possible(&ty);\n                         // We walk the argument type because the argument's type could have\n                         // been `Option<T>`, but the `FulfillmentError` references `T`.\n-                        if ty.walk().any(|arg| arg == predicate.skip_binder().self_ty().into()) {\n+                        if ty.walk().any(|arg| arg == predicate.self_ty().into()) {\n                             Some(i)\n                         } else {\n                             None\n@@ -4284,15 +4286,15 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// instead of the `fn` call path span.\n     fn point_at_type_arg_instead_of_call_if_possible(\n         &self,\n-        errors: &mut Vec<traits::FulfillmentError<'_>>,\n+        errors: &mut Vec<traits::FulfillmentError<'tcx>>,\n         call_expr: &'tcx hir::Expr<'tcx>,\n     ) {\n         if let hir::ExprKind::Call(path, _) = &call_expr.kind {\n             if let hir::ExprKind::Path(qpath) = &path.kind {\n                 if let hir::QPath::Resolved(_, path) = &qpath {\n                     for error in errors {\n-                        if let ty::PredicateKind::Trait(predicate, _) =\n-                            error.obligation.predicate.kind()\n+                        if let ty::PredicateAtom::Trait(predicate, _) =\n+                            error.obligation.predicate.skip_binders()\n                         {\n                             // If any of the type arguments in this path segment caused the\n                             // `FullfillmentError`, point at its span (#61860).\n@@ -4313,7 +4315,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                     } else {\n                                         let ty = AstConv::ast_ty_to_ty(self, hir_ty);\n                                         let ty = self.resolve_vars_if_possible(&ty);\n-                                        if ty == predicate.skip_binder().self_ty() {\n+                                        if ty == predicate.self_ty() {\n                                             error.obligation.cause.make_mut().span = hir_ty.span;\n                                         }\n                                     }\n@@ -5365,12 +5367,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     item_def_id,\n                 };\n \n-                let predicate =\n-                    ty::PredicateKind::Projection(ty::Binder::bind(ty::ProjectionPredicate {\n-                        projection_ty,\n-                        ty: expected,\n-                    }))\n-                    .to_predicate(self.tcx);\n+                let predicate = ty::PredicateAtom::Projection(ty::ProjectionPredicate {\n+                    projection_ty,\n+                    ty: expected,\n+                })\n+                .potentially_quantified(self.tcx, ty::PredicateKind::ForAll);\n                 let obligation = traits::Obligation::new(self.misc(sp), self.param_env, predicate);\n \n                 debug!(\"suggest_missing_await: trying obligation {:?}\", obligation);"}, {"sha": "50d9a1ebd2c249d6671862e9af6a37cfc726e959", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/76e83339bb619aba206e5590b1e4b813a154b199/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76e83339bb619aba206e5590b1e4b813a154b199/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=76e83339bb619aba206e5590b1e4b813a154b199", "patch": "@@ -429,7 +429,7 @@ fn check_type_defn<'tcx, F>(\n                 fcx.register_predicate(traits::Obligation::new(\n                     cause,\n                     fcx.param_env,\n-                    ty::PredicateKind::ConstEvaluatable(\n+                    ty::PredicateAtom::ConstEvaluatable(\n                         ty::WithOptConstParam::unknown(discr_def_id.to_def_id()),\n                         discr_substs,\n                     )"}, {"sha": "76439af79f3512154316647a39581a77a8145210", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/76e83339bb619aba206e5590b1e4b813a154b199/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76e83339bb619aba206e5590b1e4b813a154b199/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=76e83339bb619aba206e5590b1e4b813a154b199", "patch": "@@ -552,10 +552,8 @@ fn type_param_predicates(\n     let extra_predicates = extend.into_iter().chain(\n         icx.type_parameter_bounds_in_generics(ast_generics, param_id, ty, OnlySelfBounds(true))\n             .into_iter()\n-            .filter(|(predicate, _)| match predicate.kind() {\n-                ty::PredicateKind::Trait(ref data, _) => {\n-                    data.skip_binder().self_ty().is_param(index)\n-                }\n+            .filter(|(predicate, _)| match predicate.skip_binders() {\n+                ty::PredicateAtom::Trait(data, _) => data.self_ty().is_param(index),\n                 _ => false,\n             }),\n     );\n@@ -1006,7 +1004,7 @@ fn super_predicates_of(tcx: TyCtxt<'_>, trait_def_id: DefId) -> ty::GenericPredi\n     // which will, in turn, reach indirect supertraits.\n     for &(pred, span) in superbounds {\n         debug!(\"superbound: {:?}\", pred);\n-        if let ty::PredicateKind::Trait(bound, _) = pred.kind() {\n+        if let ty::PredicateAtom::Trait(bound, _) = pred.skip_binders() {\n             tcx.at(span).super_predicates_of(bound.def_id());\n         }\n     }\n@@ -1932,8 +1930,8 @@ fn explicit_predicates_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::GenericPredicat\n                         let re_root_empty = tcx.lifetimes.re_root_empty;\n                         let predicate = ty::OutlivesPredicate(ty, re_root_empty);\n                         predicates.push((\n-                            ty::PredicateKind::TypeOutlives(ty::Binder::bind(predicate))\n-                                .to_predicate(tcx),\n+                            ty::PredicateAtom::TypeOutlives(predicate)\n+                                .potentially_quantified(tcx, ty::PredicateKind::ForAll),\n                             span,\n                         ));\n                     }\n@@ -1961,9 +1959,9 @@ fn explicit_predicates_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::GenericPredicat\n \n                         &hir::GenericBound::Outlives(ref lifetime) => {\n                             let region = AstConv::ast_region_to_region(&icx, lifetime, None);\n-                            let pred = ty::Binder::bind(ty::OutlivesPredicate(ty, region));\n                             predicates.push((\n-                                ty::PredicateKind::TypeOutlives(pred).to_predicate(tcx),\n+                                ty::PredicateAtom::TypeOutlives(ty::OutlivesPredicate(ty, region))\n+                                    .potentially_quantified(tcx, ty::PredicateKind::ForAll),\n                                 lifetime.span,\n                             ))\n                         }\n@@ -1980,9 +1978,9 @@ fn explicit_predicates_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::GenericPredicat\n                         }\n                         _ => bug!(),\n                     };\n-                    let pred = ty::Binder::bind(ty::OutlivesPredicate(r1, r2));\n+                    let pred = ty::PredicateAtom::RegionOutlives(ty::OutlivesPredicate(r1, r2));\n \n-                    (ty::PredicateKind::RegionOutlives(pred).to_predicate(icx.tcx), span)\n+                    (pred.potentially_quantified(icx.tcx, ty::PredicateKind::ForAll), span)\n                 }))\n             }\n \n@@ -2110,8 +2108,9 @@ fn predicates_from_bound<'tcx>(\n         }\n         hir::GenericBound::Outlives(ref lifetime) => {\n             let region = astconv.ast_region_to_region(lifetime, None);\n-            let pred = ty::Binder::bind(ty::OutlivesPredicate(param_ty, region));\n-            vec![(ty::PredicateKind::TypeOutlives(pred).to_predicate(astconv.tcx()), lifetime.span)]\n+            let pred = ty::PredicateAtom::TypeOutlives(ty::OutlivesPredicate(param_ty, region))\n+                .potentially_quantified(astconv.tcx(), ty::PredicateKind::ForAll);\n+            vec![(pred, lifetime.span)]\n         }\n     }\n }"}, {"sha": "7c80315ee194d52c5cf0f183f2918c79a182e8a6", "filename": "src/librustc_typeck/constrained_generic_params.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/76e83339bb619aba206e5590b1e4b813a154b199/src%2Flibrustc_typeck%2Fconstrained_generic_params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76e83339bb619aba206e5590b1e4b813a154b199/src%2Flibrustc_typeck%2Fconstrained_generic_params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fconstrained_generic_params.rs?ref=76e83339bb619aba206e5590b1e4b813a154b199", "patch": "@@ -180,11 +180,9 @@ pub fn setup_constraining_predicates<'tcx>(\n         changed = false;\n \n         for j in i..predicates.len() {\n-            if let ty::PredicateKind::Projection(ref poly_projection) = predicates[j].0.kind() {\n-                // Note that we can skip binder here because the impl\n-                // trait ref never contains any late-bound regions.\n-                let projection = poly_projection.skip_binder();\n-\n+            // Note that we don't have to care about binders here,\n+            // as the impl trait ref never contains any late-bound regions.\n+            if let ty::PredicateAtom::Projection(projection) = predicates[j].0.skip_binders() {\n                 // Special case: watch out for some kind of sneaky attempt\n                 // to project out an associated type defined by this very\n                 // trait."}, {"sha": "8257c6ce92547b8d51378a9797845c1a6b8a3385", "filename": "src/librustc_typeck/impl_wf_check/min_specialization.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/76e83339bb619aba206e5590b1e4b813a154b199/src%2Flibrustc_typeck%2Fimpl_wf_check%2Fmin_specialization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76e83339bb619aba206e5590b1e4b813a154b199/src%2Flibrustc_typeck%2Fimpl_wf_check%2Fmin_specialization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fimpl_wf_check%2Fmin_specialization.rs?ref=76e83339bb619aba206e5590b1e4b813a154b199", "patch": "@@ -198,9 +198,9 @@ fn unconstrained_parent_impl_substs<'tcx>(\n     // the functions in `cgp` add the constrained parameters to a list of\n     // unconstrained parameters.\n     for (predicate, _) in impl_generic_predicates.predicates.iter() {\n-        if let ty::PredicateKind::Projection(proj) = predicate.kind() {\n-            let projection_ty = proj.skip_binder().projection_ty;\n-            let projected_ty = proj.skip_binder().ty;\n+        if let ty::PredicateAtom::Projection(proj) = predicate.skip_binders() {\n+            let projection_ty = proj.projection_ty;\n+            let projected_ty = proj.ty;\n \n             let unbound_trait_ref = projection_ty.trait_ref(tcx);\n             if Some(unbound_trait_ref) == impl_trait_ref {\n@@ -359,13 +359,13 @@ fn check_predicates<'tcx>(\n \n fn check_specialization_on<'tcx>(tcx: TyCtxt<'tcx>, predicate: ty::Predicate<'tcx>, span: Span) {\n     debug!(\"can_specialize_on(predicate = {:?})\", predicate);\n-    match predicate.kind() {\n+    match predicate.skip_binders() {\n         // Global predicates are either always true or always false, so we\n         // are fine to specialize on.\n         _ if predicate.is_global() => (),\n         // We allow specializing on explicitly marked traits with no associated\n         // items.\n-        ty::PredicateKind::Trait(pred, hir::Constness::NotConst) => {\n+        ty::PredicateAtom::Trait(pred, hir::Constness::NotConst) => {\n             if !matches!(\n                 trait_predicate_kind(tcx, predicate),\n                 Some(TraitSpecializationKind::Marker)\n@@ -392,19 +392,19 @@ fn trait_predicate_kind<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     predicate: ty::Predicate<'tcx>,\n ) -> Option<TraitSpecializationKind> {\n-    match predicate.kind() {\n-        ty::PredicateKind::Trait(pred, hir::Constness::NotConst) => {\n+    match predicate.skip_binders() {\n+        ty::PredicateAtom::Trait(pred, hir::Constness::NotConst) => {\n             Some(tcx.trait_def(pred.def_id()).specialization_kind)\n         }\n-        ty::PredicateKind::Trait(_, hir::Constness::Const)\n-        | ty::PredicateKind::RegionOutlives(_)\n-        | ty::PredicateKind::TypeOutlives(_)\n-        | ty::PredicateKind::Projection(_)\n-        | ty::PredicateKind::WellFormed(_)\n-        | ty::PredicateKind::Subtype(_)\n-        | ty::PredicateKind::ObjectSafe(_)\n-        | ty::PredicateKind::ClosureKind(..)\n-        | ty::PredicateKind::ConstEvaluatable(..)\n-        | ty::PredicateKind::ConstEquate(..) => None,\n+        ty::PredicateAtom::Trait(_, hir::Constness::Const)\n+        | ty::PredicateAtom::RegionOutlives(_)\n+        | ty::PredicateAtom::TypeOutlives(_)\n+        | ty::PredicateAtom::Projection(_)\n+        | ty::PredicateAtom::WellFormed(_)\n+        | ty::PredicateAtom::Subtype(_)\n+        | ty::PredicateAtom::ObjectSafe(_)\n+        | ty::PredicateAtom::ClosureKind(..)\n+        | ty::PredicateAtom::ConstEvaluatable(..)\n+        | ty::PredicateAtom::ConstEquate(..) => None,\n     }\n }"}, {"sha": "135960a4c111414dc1f0d2e187e9890e83d16089", "filename": "src/librustc_typeck/outlives/explicit.rs", "status": "modified", "additions": 11, "deletions": 13, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/76e83339bb619aba206e5590b1e4b813a154b199/src%2Flibrustc_typeck%2Foutlives%2Fexplicit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76e83339bb619aba206e5590b1e4b813a154b199/src%2Flibrustc_typeck%2Foutlives%2Fexplicit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Foutlives%2Fexplicit.rs?ref=76e83339bb619aba206e5590b1e4b813a154b199", "patch": "@@ -29,9 +29,8 @@ impl<'tcx> ExplicitPredicatesMap<'tcx> {\n \n             // process predicates and convert to `RequiredPredicates` entry, see below\n             for &(predicate, span) in predicates.predicates {\n-                match predicate.kind() {\n-                    ty::PredicateKind::TypeOutlives(predicate) => {\n-                        let OutlivesPredicate(ref ty, ref reg) = predicate.skip_binder();\n+                match predicate.skip_binders() {\n+                    ty::PredicateAtom::TypeOutlives(OutlivesPredicate(ref ty, ref reg)) => {\n                         insert_outlives_predicate(\n                             tcx,\n                             (*ty).into(),\n@@ -41,8 +40,7 @@ impl<'tcx> ExplicitPredicatesMap<'tcx> {\n                         )\n                     }\n \n-                    ty::PredicateKind::RegionOutlives(predicate) => {\n-                        let OutlivesPredicate(ref reg1, ref reg2) = predicate.skip_binder();\n+                    ty::PredicateAtom::RegionOutlives(OutlivesPredicate(ref reg1, ref reg2)) => {\n                         insert_outlives_predicate(\n                             tcx,\n                             (*reg1).into(),\n@@ -52,14 +50,14 @@ impl<'tcx> ExplicitPredicatesMap<'tcx> {\n                         )\n                     }\n \n-                    ty::PredicateKind::Trait(..)\n-                    | ty::PredicateKind::Projection(..)\n-                    | ty::PredicateKind::WellFormed(..)\n-                    | ty::PredicateKind::ObjectSafe(..)\n-                    | ty::PredicateKind::ClosureKind(..)\n-                    | ty::PredicateKind::Subtype(..)\n-                    | ty::PredicateKind::ConstEvaluatable(..)\n-                    | ty::PredicateKind::ConstEquate(..) => (),\n+                    ty::PredicateAtom::Trait(..)\n+                    | ty::PredicateAtom::Projection(..)\n+                    | ty::PredicateAtom::WellFormed(..)\n+                    | ty::PredicateAtom::ObjectSafe(..)\n+                    | ty::PredicateAtom::ClosureKind(..)\n+                    | ty::PredicateAtom::Subtype(..)\n+                    | ty::PredicateAtom::ConstEvaluatable(..)\n+                    | ty::PredicateAtom::ConstEquate(..) => (),\n                 }\n             }\n "}, {"sha": "5dc7ac9fa0d4e9a9b4e6339ecb8adaed9fc2859d", "filename": "src/librustc_typeck/outlives/mod.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/76e83339bb619aba206e5590b1e4b813a154b199/src%2Flibrustc_typeck%2Foutlives%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76e83339bb619aba206e5590b1e4b813a154b199/src%2Flibrustc_typeck%2Foutlives%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Foutlives%2Fmod.rs?ref=76e83339bb619aba206e5590b1e4b813a154b199", "patch": "@@ -3,7 +3,7 @@ use rustc_hir as hir;\n use rustc_hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::subst::GenericArgKind;\n-use rustc_middle::ty::{self, CratePredicatesMap, ToPredicate, TyCtxt};\n+use rustc_middle::ty::{self, CratePredicatesMap, TyCtxt};\n use rustc_span::symbol::sym;\n use rustc_span::Span;\n \n@@ -31,8 +31,12 @@ fn inferred_outlives_of(tcx: TyCtxt<'_>, item_def_id: DefId) -> &[(ty::Predicate\n                     let mut pred: Vec<String> = predicates\n                         .iter()\n                         .map(|(out_pred, _)| match out_pred.kind() {\n-                            ty::PredicateKind::RegionOutlives(p) => p.to_string(),\n-                            ty::PredicateKind::TypeOutlives(p) => p.to_string(),\n+                            ty::PredicateKind::Atom(ty::PredicateAtom::RegionOutlives(p)) => {\n+                                p.to_string()\n+                            }\n+                            ty::PredicateKind::Atom(ty::PredicateAtom::TypeOutlives(p)) => {\n+                                p.to_string()\n+                            }\n                             err => bug!(\"unexpected predicate {:?}\", err),\n                         })\n                         .collect();\n@@ -85,17 +89,15 @@ fn inferred_outlives_crate(tcx: TyCtxt<'_>, crate_num: CrateNum) -> CratePredica\n                 |(ty::OutlivesPredicate(kind1, region2), &span)| {\n                     match kind1.unpack() {\n                         GenericArgKind::Type(ty1) => Some((\n-                            ty::PredicateKind::TypeOutlives(ty::Binder::bind(\n-                                ty::OutlivesPredicate(ty1, region2),\n-                            ))\n-                            .to_predicate(tcx),\n+                            ty::PredicateAtom::TypeOutlives(ty::OutlivesPredicate(ty1, region2))\n+                                .potentially_quantified(tcx, ty::PredicateKind::ForAll),\n                             span,\n                         )),\n                         GenericArgKind::Lifetime(region1) => Some((\n-                            ty::PredicateKind::RegionOutlives(ty::Binder::bind(\n-                                ty::OutlivesPredicate(region1, region2),\n+                            ty::PredicateAtom::RegionOutlives(ty::OutlivesPredicate(\n+                                region1, region2,\n                             ))\n-                            .to_predicate(tcx),\n+                            .potentially_quantified(tcx, ty::PredicateKind::ForAll),\n                             span,\n                         )),\n                         GenericArgKind::Const(_) => {"}, {"sha": "98d8f100b27d9187bdd4504857186d4e35c6bf80", "filename": "src/librustdoc/clean/auto_trait.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/76e83339bb619aba206e5590b1e4b813a154b199/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76e83339bb619aba206e5590b1e4b813a154b199/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs?ref=76e83339bb619aba206e5590b1e4b813a154b199", "patch": "@@ -315,12 +315,12 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n         tcx: TyCtxt<'tcx>,\n         pred: ty::Predicate<'tcx>,\n     ) -> FxHashSet<GenericParamDef> {\n-        let regions = match pred.kind() {\n-            ty::PredicateKind::Trait(poly_trait_pred, _) => {\n-                tcx.collect_referenced_late_bound_regions(&poly_trait_pred)\n+        let regions = match pred.skip_binders() {\n+            ty::PredicateAtom::Trait(poly_trait_pred, _) => {\n+                tcx.collect_referenced_late_bound_regions(&ty::Binder::bind(poly_trait_pred))\n             }\n-            ty::PredicateKind::Projection(poly_proj_pred) => {\n-                tcx.collect_referenced_late_bound_regions(&poly_proj_pred)\n+            ty::PredicateAtom::Projection(poly_proj_pred) => {\n+                tcx.collect_referenced_late_bound_regions(&ty::Binder::bind(poly_proj_pred))\n             }\n             _ => return FxHashSet::default(),\n         };\n@@ -465,8 +465,8 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n             .iter()\n             .filter(|p| {\n                 !orig_bounds.contains(p)\n-                    || match p.kind() {\n-                        ty::PredicateKind::Trait(pred, _) => pred.def_id() == sized_trait,\n+                    || match p.skip_binders() {\n+                        ty::PredicateAtom::Trait(pred, _) => pred.def_id() == sized_trait,\n                         _ => false,\n                     }\n             })"}, {"sha": "cc3a60c596ae7a321cdafc3e6b4acd789129d149", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 47, "deletions": 47, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/76e83339bb619aba206e5590b1e4b813a154b199/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76e83339bb619aba206e5590b1e4b813a154b199/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=76e83339bb619aba206e5590b1e4b813a154b199", "patch": "@@ -480,18 +480,18 @@ impl Clean<WherePredicate> for hir::WherePredicate<'_> {\n \n impl<'a> Clean<Option<WherePredicate>> for ty::Predicate<'a> {\n     fn clean(&self, cx: &DocContext<'_>) -> Option<WherePredicate> {\n-        match self.kind() {\n-            ty::PredicateKind::Trait(ref pred, _) => Some(pred.clean(cx)),\n-            ty::PredicateKind::Subtype(ref pred) => Some(pred.clean(cx)),\n-            ty::PredicateKind::RegionOutlives(ref pred) => pred.clean(cx),\n-            ty::PredicateKind::TypeOutlives(ref pred) => pred.clean(cx),\n-            ty::PredicateKind::Projection(ref pred) => Some(pred.clean(cx)),\n+        match self.skip_binders() {\n+            ty::PredicateAtom::Trait(pred, _) => Some(ty::Binder::bind(pred).clean(cx)),\n+            ty::PredicateAtom::RegionOutlives(pred) => pred.clean(cx),\n+            ty::PredicateAtom::TypeOutlives(pred) => pred.clean(cx),\n+            ty::PredicateAtom::Projection(pred) => Some(pred.clean(cx)),\n \n-            ty::PredicateKind::WellFormed(..)\n-            | ty::PredicateKind::ObjectSafe(..)\n-            | ty::PredicateKind::ClosureKind(..)\n-            | ty::PredicateKind::ConstEvaluatable(..)\n-            | ty::PredicateKind::ConstEquate(..) => panic!(\"not user writable\"),\n+            ty::PredicateAtom::Subtype(..)\n+            | ty::PredicateAtom::WellFormed(..)\n+            | ty::PredicateAtom::ObjectSafe(..)\n+            | ty::PredicateAtom::ClosureKind(..)\n+            | ty::PredicateAtom::ConstEvaluatable(..)\n+            | ty::PredicateAtom::ConstEquate(..) => panic!(\"not user writable\"),\n         }\n     }\n }\n@@ -506,20 +506,11 @@ impl<'a> Clean<WherePredicate> for ty::PolyTraitPredicate<'a> {\n     }\n }\n \n-impl<'tcx> Clean<WherePredicate> for ty::PolySubtypePredicate<'tcx> {\n-    fn clean(&self, _cx: &DocContext<'_>) -> WherePredicate {\n-        panic!(\n-            \"subtype predicates are an internal rustc artifact \\\n-                and should not be seen by rustdoc\"\n-        )\n-    }\n-}\n-\n impl<'tcx> Clean<Option<WherePredicate>>\n-    for ty::PolyOutlivesPredicate<ty::Region<'tcx>, ty::Region<'tcx>>\n+    for ty::OutlivesPredicate<ty::Region<'tcx>, ty::Region<'tcx>>\n {\n     fn clean(&self, cx: &DocContext<'_>) -> Option<WherePredicate> {\n-        let ty::OutlivesPredicate(a, b) = self.skip_binder();\n+        let ty::OutlivesPredicate(a, b) = self;\n \n         if let (ty::ReEmpty(_), ty::ReEmpty(_)) = (a, b) {\n             return None;\n@@ -532,9 +523,9 @@ impl<'tcx> Clean<Option<WherePredicate>>\n     }\n }\n \n-impl<'tcx> Clean<Option<WherePredicate>> for ty::PolyOutlivesPredicate<Ty<'tcx>, ty::Region<'tcx>> {\n+impl<'tcx> Clean<Option<WherePredicate>> for ty::OutlivesPredicate<Ty<'tcx>, ty::Region<'tcx>> {\n     fn clean(&self, cx: &DocContext<'_>) -> Option<WherePredicate> {\n-        let ty::OutlivesPredicate(ty, lt) = self.skip_binder();\n+        let ty::OutlivesPredicate(ty, lt) = self;\n \n         if let ty::ReEmpty(_) = lt {\n             return None;\n@@ -547,9 +538,9 @@ impl<'tcx> Clean<Option<WherePredicate>> for ty::PolyOutlivesPredicate<Ty<'tcx>,\n     }\n }\n \n-impl<'tcx> Clean<WherePredicate> for ty::PolyProjectionPredicate<'tcx> {\n+impl<'tcx> Clean<WherePredicate> for ty::ProjectionPredicate<'tcx> {\n     fn clean(&self, cx: &DocContext<'_>) -> WherePredicate {\n-        let ty::ProjectionPredicate { projection_ty, ty } = self.skip_binder();\n+        let ty::ProjectionPredicate { projection_ty, ty } = self;\n         WherePredicate::EqPredicate { lhs: projection_ty.clean(cx), rhs: ty.clean(cx) }\n     }\n }\n@@ -754,19 +745,24 @@ impl<'a, 'tcx> Clean<Generics> for (&'a ty::Generics, ty::GenericPredicates<'tcx\n             .flat_map(|(p, _)| {\n                 let mut projection = None;\n                 let param_idx = (|| {\n-                    if let Some(trait_ref) = p.to_opt_poly_trait_ref() {\n-                        if let ty::Param(param) = trait_ref.skip_binder().self_ty().kind {\n-                            return Some(param.index);\n+                    match p.skip_binders() {\n+                        ty::PredicateAtom::Trait(pred, _constness) => {\n+                            if let ty::Param(param) = pred.self_ty().kind {\n+                                return Some(param.index);\n+                            }\n                         }\n-                    } else if let Some(outlives) = p.to_opt_type_outlives() {\n-                        if let ty::Param(param) = outlives.skip_binder().0.kind {\n-                            return Some(param.index);\n+                        ty::PredicateAtom::TypeOutlives(ty::OutlivesPredicate(ty, _reg)) => {\n+                            if let ty::Param(param) = ty.kind {\n+                                return Some(param.index);\n+                            }\n                         }\n-                    } else if let ty::PredicateKind::Projection(p) = p.kind() {\n-                        if let ty::Param(param) = p.skip_binder().projection_ty.self_ty().kind {\n-                            projection = Some(p);\n-                            return Some(param.index);\n+                        ty::PredicateAtom::Projection(p) => {\n+                            if let ty::Param(param) = p.projection_ty.self_ty().kind {\n+                                projection = Some(ty::Binder::bind(p));\n+                                return Some(param.index);\n+                            }\n                         }\n+                        _ => (),\n                     }\n \n                     None\n@@ -1655,16 +1651,19 @@ impl<'tcx> Clean<Type> for Ty<'tcx> {\n                     .predicates\n                     .iter()\n                     .filter_map(|predicate| {\n-                        let trait_ref = if let Some(tr) = predicate.to_opt_poly_trait_ref() {\n-                            tr\n-                        } else if let ty::PredicateKind::TypeOutlives(pred) = predicate.kind() {\n-                            // these should turn up at the end\n-                            if let Some(r) = pred.skip_binder().1.clean(cx) {\n-                                regions.push(GenericBound::Outlives(r));\n+                        // Note: The substs of opaque types can contain unbound variables,\n+                        // meaning that we have to use `ignore_quantifiers_with_unbound_vars` here.\n+                        let trait_ref = match predicate.bound_atom(cx.tcx).skip_binder() {\n+                            ty::PredicateAtom::Trait(tr, _constness) => {\n+                                ty::Binder::bind(tr.trait_ref)\n+                            }\n+                            ty::PredicateAtom::TypeOutlives(ty::OutlivesPredicate(_ty, reg)) => {\n+                                if let Some(r) = reg.clean(cx) {\n+                                    regions.push(GenericBound::Outlives(r));\n+                                }\n+                                return None;\n                             }\n-                            return None;\n-                        } else {\n-                            return None;\n+                            _ => return None,\n                         };\n \n                         if let Some(sized) = cx.tcx.lang_items().sized_trait() {\n@@ -1678,8 +1677,9 @@ impl<'tcx> Clean<Type> for Ty<'tcx> {\n                             .predicates\n                             .iter()\n                             .filter_map(|pred| {\n-                                if let ty::PredicateKind::Projection(proj) = pred.kind() {\n-                                    let proj = proj.skip_binder();\n+                                if let ty::PredicateAtom::Projection(proj) =\n+                                    pred.bound_atom(cx.tcx).skip_binder()\n+                                {\n                                     if proj.projection_ty.trait_ref(cx.tcx)\n                                         == trait_ref.skip_binder()\n                                     {"}, {"sha": "0f995a60c22fd06d0247391a850ad588524251ef", "filename": "src/librustdoc/clean/simplify.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/76e83339bb619aba206e5590b1e4b813a154b199/src%2Flibrustdoc%2Fclean%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76e83339bb619aba206e5590b1e4b813a154b199/src%2Flibrustdoc%2Fclean%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fsimplify.rs?ref=76e83339bb619aba206e5590b1e4b813a154b199", "patch": "@@ -141,12 +141,8 @@ fn trait_is_same_or_supertrait(cx: &DocContext<'_>, child: DefId, trait_: DefId)\n         .predicates\n         .iter()\n         .filter_map(|(pred, _)| {\n-            if let ty::PredicateKind::Trait(ref pred, _) = pred.kind() {\n-                if pred.skip_binder().trait_ref.self_ty() == self_ty {\n-                    Some(pred.def_id())\n-                } else {\n-                    None\n-                }\n+            if let ty::PredicateAtom::Trait(pred, _) = pred.skip_binders() {\n+                if pred.trait_ref.self_ty() == self_ty { Some(pred.def_id()) } else { None }\n             } else {\n                 None\n             }"}, {"sha": "b1625536d420204fcb2e3640903ba01b1160a0eb", "filename": "src/test/ui/issues/issue-26217.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/76e83339bb619aba206e5590b1e4b813a154b199/src%2Ftest%2Fui%2Fissues%2Fissue-26217.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/76e83339bb619aba206e5590b1e4b813a154b199/src%2Ftest%2Fui%2Fissues%2Fissue-26217.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-26217.stderr?ref=76e83339bb619aba206e5590b1e4b813a154b199", "patch": "@@ -4,7 +4,7 @@ error[E0477]: the type `&'a i32` does not fulfill the required lifetime\n LL |     foo::<&'a i32>();\n    |     ^^^^^^^^^^^^^^\n    |\n-   = note: type must satisfy the static lifetime\n+   = note: type must outlive any other region\n \n error: aborting due to previous error\n "}, {"sha": "1361117f6c4dab093bfe7dc3bd35b30c70d3c7b8", "filename": "src/test/ui/specialization/min_specialization/repeated_projection_type.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/76e83339bb619aba206e5590b1e4b813a154b199/src%2Ftest%2Fui%2Fspecialization%2Fmin_specialization%2Frepeated_projection_type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/76e83339bb619aba206e5590b1e4b813a154b199/src%2Ftest%2Fui%2Fspecialization%2Fmin_specialization%2Frepeated_projection_type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspecialization%2Fmin_specialization%2Frepeated_projection_type.stderr?ref=76e83339bb619aba206e5590b1e4b813a154b199", "patch": "@@ -1,4 +1,4 @@\n-error: cannot specialize on `Binder(ProjectionPredicate(ProjectionTy { substs: [V], item_def_id: DefId(0:6 ~ repeated_projection_type[317d]::Id[0]::This[0]) }, (I,)))`\n+error: cannot specialize on `ProjectionPredicate(ProjectionTy { substs: [V], item_def_id: DefId(0:6 ~ repeated_projection_type[317d]::Id[0]::This[0]) }, (I,))`\n   --> $DIR/repeated_projection_type.rs:19:1\n    |\n LL | / impl<I, V: Id<This = (I,)>> X for V {"}, {"sha": "0fdb5b8c2a48e9a6217c96f58dec7808be398e1b", "filename": "src/tools/clippy/clippy_lints/src/future_not_send.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/76e83339bb619aba206e5590b1e4b813a154b199/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffuture_not_send.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76e83339bb619aba206e5590b1e4b813a154b199/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffuture_not_send.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffuture_not_send.rs?ref=76e83339bb619aba206e5590b1e4b813a154b199", "patch": "@@ -3,7 +3,7 @@ use rustc_hir::intravisit::FnKind;\n use rustc_hir::{Body, FnDecl, HirId};\n use rustc_infer::infer::TyCtxtInferExt;\n use rustc_lint::{LateContext, LateLintPass};\n-use rustc_middle::ty::{Opaque, PredicateKind::Trait, ToPolyTraitRef};\n+use rustc_middle::ty::{Opaque, PredicateAtom::Trait};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::{sym, Span};\n use rustc_trait_selection::traits::error_reporting::suggestions::InferCtxtExt;\n@@ -91,12 +91,11 @@ impl<'tcx> LateLintPass<'tcx> for FutureNotSend {\n                             cx.tcx.infer_ctxt().enter(|infcx| {\n                                 for FulfillmentError { obligation, .. } in send_errors {\n                                     infcx.maybe_note_obligation_cause_for_async_await(db, &obligation);\n-                                    if let Trait(trait_pred, _) = obligation.predicate.kind() {\n-                                        let trait_ref = trait_pred.to_poly_trait_ref();\n-                                        db.note(&*format!(\n+                                    if let Trait(trait_pred, _) = obligation.predicate.skip_binders() {\n+                                        db.note(&format!(\n                                             \"`{}` doesn't implement `{}`\",\n-                                            trait_ref.skip_binder().self_ty(),\n-                                            trait_ref.print_only_trait_path(),\n+                                            trait_pred.self_ty(),\n+                                            trait_pred.trait_ref.print_only_trait_path(),\n                                         ));\n                                     }\n                                 }"}, {"sha": "2c70183d87666d7aa0ac5ea93fc94d4406c7579d", "filename": "src/tools/clippy/clippy_lints/src/methods/mod.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/76e83339bb619aba206e5590b1e4b813a154b199/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76e83339bb619aba206e5590b1e4b813a154b199/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmod.rs?ref=76e83339bb619aba206e5590b1e4b813a154b199", "patch": "@@ -1558,13 +1558,10 @@ impl<'tcx> LateLintPass<'tcx> for Methods {\n             // if return type is impl trait, check the associated types\n             if let ty::Opaque(def_id, _) = ret_ty.kind {\n                 // one of the associated types must be Self\n-                for predicate in cx.tcx.predicates_of(def_id).predicates {\n-                    if let ty::PredicateKind::Projection(poly_projection_predicate) = predicate.0.kind() {\n-                        let binder = poly_projection_predicate.ty();\n-                        let associated_type = binder.skip_binder();\n-\n+                for &(predicate, _span) in cx.tcx.predicates_of(def_id).predicates {\n+                    if let ty::PredicateAtom::Projection(projection_predicate) = predicate.skip_binders() {\n                         // walk the associated type and check for Self\n-                        if contains_self_ty(associated_type) {\n+                        if contains_self_ty(projection_predicate.ty) {\n                             return;\n                         }\n                     }"}, {"sha": "095778777449831305e59398bda6ce891da4de73", "filename": "src/tools/clippy/clippy_lints/src/needless_pass_by_value.rs", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/76e83339bb619aba206e5590b1e4b813a154b199/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76e83339bb619aba206e5590b1e4b813a154b199/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_pass_by_value.rs?ref=76e83339bb619aba206e5590b1e4b813a154b199", "patch": "@@ -114,12 +114,12 @@ impl<'tcx> LateLintPass<'tcx> for NeedlessPassByValue {\n         let preds = traits::elaborate_predicates(cx.tcx, cx.param_env.caller_bounds().iter())\n             .filter(|p| !p.is_global())\n             .filter_map(|obligation| {\n-                if let ty::PredicateKind::Trait(poly_trait_ref, _) = obligation.predicate.kind() {\n-                    if poly_trait_ref.def_id() == sized_trait || poly_trait_ref.skip_binder().has_escaping_bound_vars()\n-                    {\n+                // Note that we do not want to deal with qualified predicates here.\n+                if let ty::PredicateKind::Atom(ty::PredicateAtom::Trait(pred, _)) = obligation.predicate.kind() {\n+                    if pred.def_id() == sized_trait {\n                         return None;\n                     }\n-                    Some(poly_trait_ref)\n+                    Some(pred)\n                 } else {\n                     None\n                 }\n@@ -159,23 +159,27 @@ impl<'tcx> LateLintPass<'tcx> for NeedlessPassByValue {\n                 }\n             }\n \n-            //\n             // * Exclude a type that is specifically bounded by `Borrow`.\n             // * Exclude a type whose reference also fulfills its bound. (e.g., `std::convert::AsRef`,\n             //   `serde::Serialize`)\n             let (implements_borrow_trait, all_borrowable_trait) = {\n                 let preds = preds\n                     .iter()\n-                    .filter(|t| t.skip_binder().self_ty() == ty)\n+                    .filter(|t| t.self_ty() == ty)\n                     .collect::<Vec<_>>();\n \n                 (\n                     preds.iter().any(|t| t.def_id() == borrow_trait),\n                     !preds.is_empty() && {\n                         let ty_empty_region = cx.tcx.mk_imm_ref(cx.tcx.lifetimes.re_root_empty, ty);\n                         preds.iter().all(|t| {\n-                            let ty_params = &t.skip_binder().trait_ref.substs.iter().skip(1).collect::<Vec<_>>();\n-                            implements_trait(cx, ty_empty_region, t.def_id(), ty_params)\n+                            let ty_params = t\n+                                .trait_ref\n+                                .substs\n+                                .iter()\n+                                .skip(1)\n+                                .collect::<Vec<_>>();\n+                            implements_trait(cx, ty_empty_region, t.def_id(), &ty_params)\n                         })\n                     },\n                 )"}, {"sha": "679aaec9fcd6c4402da0ea5ddff7756f950b4c52", "filename": "src/tools/clippy/clippy_lints/src/unit_return_expecting_ord.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/76e83339bb619aba206e5590b1e4b813a154b199/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funit_return_expecting_ord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76e83339bb619aba206e5590b1e4b813a154b199/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funit_return_expecting_ord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funit_return_expecting_ord.rs?ref=76e83339bb619aba206e5590b1e4b813a154b199", "patch": "@@ -4,7 +4,7 @@ use rustc_hir::def_id::DefId;\n use rustc_hir::{Expr, ExprKind, StmtKind};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::ty;\n-use rustc_middle::ty::{GenericPredicates, PredicateKind, ProjectionPredicate, TraitPredicate};\n+use rustc_middle::ty::{GenericPredicates, PredicateAtom, ProjectionPredicate, TraitPredicate};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::{BytePos, Span};\n \n@@ -42,8 +42,8 @@ fn get_trait_predicates_for_trait_id<'tcx>(\n     let mut preds = Vec::new();\n     for (pred, _) in generics.predicates {\n         if_chain! {\n-            if let PredicateKind::Trait(poly_trait_pred, _) = pred.kind();\n-            let trait_pred = cx.tcx.erase_late_bound_regions(&poly_trait_pred);\n+            if let PredicateAtom::Trait(poly_trait_pred, _) = pred.skip_binders();\n+            let trait_pred = cx.tcx.erase_late_bound_regions(&ty::Binder::bind(poly_trait_pred));\n             if let Some(trait_def_id) = trait_id;\n             if trait_def_id == trait_pred.trait_ref.def_id;\n             then {\n@@ -60,8 +60,8 @@ fn get_projection_pred<'tcx>(\n     pred: TraitPredicate<'tcx>,\n ) -> Option<ProjectionPredicate<'tcx>> {\n     generics.predicates.iter().find_map(|(proj_pred, _)| {\n-        if let PredicateKind::Projection(proj_pred) = proj_pred.kind() {\n-            let projection_pred = cx.tcx.erase_late_bound_regions(proj_pred);\n+        if let ty::PredicateAtom::Projection(proj_pred) = proj_pred.skip_binders() {\n+            let projection_pred = cx.tcx.erase_late_bound_regions(&ty::Binder::bind(proj_pred));\n             if projection_pred.projection_ty.substs == pred.trait_ref.substs {\n                 return Some(projection_pred);\n             }"}, {"sha": "655b1133cf74f14430d2a2a3415a70a53cfde184", "filename": "src/tools/clippy/clippy_lints/src/utils/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/76e83339bb619aba206e5590b1e4b813a154b199/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76e83339bb619aba206e5590b1e4b813a154b199/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fmod.rs?ref=76e83339bb619aba206e5590b1e4b813a154b199", "patch": "@@ -1263,8 +1263,8 @@ pub fn is_must_use_ty<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> bool {\n         ty::Tuple(ref substs) => substs.types().any(|ty| is_must_use_ty(cx, ty)),\n         ty::Opaque(ref def_id, _) => {\n             for (predicate, _) in cx.tcx.predicates_of(*def_id).predicates {\n-                if let ty::PredicateKind::Trait(ref poly_trait_predicate, _) = predicate.kind() {\n-                    if must_use_attr(&cx.tcx.get_attrs(poly_trait_predicate.skip_binder().trait_ref.def_id)).is_some() {\n+                if let ty::PredicateAtom::Trait(trait_predicate, _) = predicate.skip_binders() {\n+                    if must_use_attr(&cx.tcx.get_attrs(trait_predicate.trait_ref.def_id)).is_some() {\n                         return true;\n                     }\n                 }"}]}