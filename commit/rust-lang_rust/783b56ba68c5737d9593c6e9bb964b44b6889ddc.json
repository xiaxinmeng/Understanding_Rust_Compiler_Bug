{"sha": "783b56ba68c5737d9593c6e9bb964b44b6889ddc", "node_id": "C_kwDOAAsO6NoAKDc4M2I1NmJhNjhjNTczN2Q5NTkzYzZlOWJiOTY0YjQ0YjY4ODlkZGM", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2022-02-13T05:44:15Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-02-13T05:44:15Z"}, "message": "Rollup merge of #93851 - cyqsimon:option-examples, r=scottmcm\n\nMore practical examples for `Option::and_then` & `Result::and_then`\n\nTo be blatantly honest, I think the current example given for `Option::and_then` is objectively terrible. (No offence to whoever wrote them initially.)\n\n```rust\nfn sq(x: u32) -> Option<u32> { Some(x * x) }\nfn nope(_: u32) -> Option<u32> { None }\n\nassert_eq!(Some(2).and_then(sq).and_then(sq), Some(16));\nassert_eq!(Some(2).and_then(sq).and_then(nope), None);\nassert_eq!(Some(2).and_then(nope).and_then(sq), None);\nassert_eq!(None.and_then(sq).and_then(sq), None);\n```\n\nCurrent example:\n - does not demonstrate that `and_then` converts `Option<T>` to `Option<U>`\n - is far removed from any realistic code\n - generally just causes more confusion than it helps\n\nSo I replaced them with two blocks:\n - the first one shows basic usage (including the type conversion)\n - the second one shows an example of typical usage\n\nSame thing with `Result::and_then`.\n\nHopefully this helps with clarity.", "tree": {"sha": "6ee858a418d57f41fd4f6f3629dd04abcd69b075", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6ee858a418d57f41fd4f6f3629dd04abcd69b075"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/783b56ba68c5737d9593c6e9bb964b44b6889ddc", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJiCJqvCRBK7hj4Ov3rIwAA8HsIAKSXp4+HvJdLhQry+nQSErAt\nplSKVGLg1k/FAXbddhnfXNjt3eEXYDT49OkQiYHhzhnIsKfCOq9UKQ5hSv+Dfcar\nZboLZGpRju3sK+LRvG7BzA+hxnwclGfzLj4yiMBL0GMYsFDvnBOWVuNo9Z12xiNo\n8hwUg/CrSSzgEASAcN2Kc5pALHG/6oOzp2gXXG9tbbHS9ysHr3f8oJRz0RMWrNcA\niXdHidNXx7Cb//wzTM2Do03BD5Fz8pcWJvceIlReHof4Rml+CHmKcXDu6t8YJBww\nLNyxQPuLupAUXUnW6H8C3jvbUaHwp/Pn2CJRha2pi29SeDLFuOHd7Dzall0fV2Q=\n=Js32\n-----END PGP SIGNATURE-----\n", "payload": "tree 6ee858a418d57f41fd4f6f3629dd04abcd69b075\nparent aff74a16971237f45182843388ac662c1822f960\nparent f6f93fd7ba348a4e0e2e9ca7af597d117d6337a1\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1644731055 +0100\ncommitter GitHub <noreply@github.com> 1644731055 +0100\n\nRollup merge of #93851 - cyqsimon:option-examples, r=scottmcm\n\nMore practical examples for `Option::and_then` & `Result::and_then`\n\nTo be blatantly honest, I think the current example given for `Option::and_then` is objectively terrible. (No offence to whoever wrote them initially.)\n\n```rust\nfn sq(x: u32) -> Option<u32> { Some(x * x) }\nfn nope(_: u32) -> Option<u32> { None }\n\nassert_eq!(Some(2).and_then(sq).and_then(sq), Some(16));\nassert_eq!(Some(2).and_then(sq).and_then(nope), None);\nassert_eq!(Some(2).and_then(nope).and_then(sq), None);\nassert_eq!(None.and_then(sq).and_then(sq), None);\n```\n\nCurrent example:\n - does not demonstrate that `and_then` converts `Option<T>` to `Option<U>`\n - is far removed from any realistic code\n - generally just causes more confusion than it helps\n\nSo I replaced them with two blocks:\n - the first one shows basic usage (including the type conversion)\n - the second one shows an example of typical usage\n\nSame thing with `Result::and_then`.\n\nHopefully this helps with clarity.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/783b56ba68c5737d9593c6e9bb964b44b6889ddc", "html_url": "https://github.com/rust-lang/rust/commit/783b56ba68c5737d9593c6e9bb964b44b6889ddc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/783b56ba68c5737d9593c6e9bb964b44b6889ddc/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "aff74a16971237f45182843388ac662c1822f960", "url": "https://api.github.com/repos/rust-lang/rust/commits/aff74a16971237f45182843388ac662c1822f960", "html_url": "https://github.com/rust-lang/rust/commit/aff74a16971237f45182843388ac662c1822f960"}, {"sha": "f6f93fd7ba348a4e0e2e9ca7af597d117d6337a1", "url": "https://api.github.com/repos/rust-lang/rust/commits/f6f93fd7ba348a4e0e2e9ca7af597d117d6337a1", "html_url": "https://github.com/rust-lang/rust/commit/f6f93fd7ba348a4e0e2e9ca7af597d117d6337a1"}], "stats": {"total": 50, "additions": 37, "deletions": 13}, "files": [{"sha": "508837f63c3bee8d7bad27fc71c02b68f8f36e9b", "filename": "library/core/src/option.rs", "status": "modified", "additions": 18, "deletions": 6, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/783b56ba68c5737d9593c6e9bb964b44b6889ddc/library%2Fcore%2Fsrc%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/783b56ba68c5737d9593c6e9bb964b44b6889ddc/library%2Fcore%2Fsrc%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Foption.rs?ref=783b56ba68c5737d9593c6e9bb964b44b6889ddc", "patch": "@@ -1207,13 +1207,25 @@ impl<T> Option<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// fn sq(x: u32) -> Option<u32> { Some(x * x) }\n-    /// fn nope(_: u32) -> Option<u32> { None }\n+    /// fn sq_then_to_string(x: u32) -> Option<String> {\n+    ///     x.checked_mul(x).map(|sq| sq.to_string())\n+    /// }\n+    ///\n+    /// assert_eq!(Some(2).and_then(sq_then_to_string), Some(4.to_string()));\n+    /// assert_eq!(Some(1_000_000).and_then(sq_then_to_string), None); // overflowed!\n+    /// assert_eq!(None.and_then(sq_then_to_string), None);\n+    /// ```\n+    ///\n+    /// Often used to chain fallible operations that may return [`None`].\n+    ///\n+    /// ```\n+    /// let arr_2d = [[\"A0\", \"A1\"], [\"B0\", \"B1\"]];\n+    ///\n+    /// let item_0_1 = arr_2d.get(0).and_then(|row| row.get(1));\n+    /// assert_eq!(item_0_1, Some(&\"A1\"));\n     ///\n-    /// assert_eq!(Some(2).and_then(sq).and_then(sq), Some(16));\n-    /// assert_eq!(Some(2).and_then(sq).and_then(nope), None);\n-    /// assert_eq!(Some(2).and_then(nope).and_then(sq), None);\n-    /// assert_eq!(None.and_then(sq).and_then(sq), None);\n+    /// let item_2_0 = arr_2d.get(2).and_then(|row| row.get(0));\n+    /// assert_eq!(item_2_0, None);\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "801e3a0b3a4ccaf34038d70ed286bd3185d7802f", "filename": "library/core/src/result.rs", "status": "modified", "additions": 19, "deletions": 7, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/783b56ba68c5737d9593c6e9bb964b44b6889ddc/library%2Fcore%2Fsrc%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/783b56ba68c5737d9593c6e9bb964b44b6889ddc/library%2Fcore%2Fsrc%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fresult.rs?ref=783b56ba68c5737d9593c6e9bb964b44b6889ddc", "patch": "@@ -1281,16 +1281,28 @@ impl<T, E> Result<T, E> {\n     ///\n     /// # Examples\n     ///\n-    /// Basic usage:\n+    /// ```\n+    /// fn sq_then_to_string(x: u32) -> Result<String, &'static str> {\n+    ///     x.checked_mul(x).map(|sq| sq.to_string()).ok_or(\"overflowed\")\n+    /// }\n     ///\n+    /// assert_eq!(Ok(2).and_then(sq_then_to_string), Ok(4.to_string()));\n+    /// assert_eq!(Ok(1_000_000).and_then(sq_then_to_string), Err(\"overflowed\"));\n+    /// assert_eq!(Err(\"not a number\").and_then(sq_then_to_string), Err(\"not a number\"));\n     /// ```\n-    /// fn sq(x: u32) -> Result<u32, u32> { Ok(x * x) }\n-    /// fn err(x: u32) -> Result<u32, u32> { Err(x) }\n     ///\n-    /// assert_eq!(Ok(2).and_then(sq).and_then(sq), Ok(16));\n-    /// assert_eq!(Ok(2).and_then(sq).and_then(err), Err(4));\n-    /// assert_eq!(Ok(2).and_then(err).and_then(sq), Err(2));\n-    /// assert_eq!(Err(3).and_then(sq).and_then(sq), Err(3));\n+    /// Often used to chain fallible operations that may return [`Err`].\n+    ///\n+    /// ```\n+    /// use std::{io::ErrorKind, path::Path};\n+    ///\n+    /// // Note: on Windows \"/\" maps to \"C:\\\"\n+    /// let root_modified_time = Path::new(\"/\").metadata().and_then(|md| md.modified());\n+    /// assert!(root_modified_time.is_ok());\n+    ///\n+    /// let should_fail = Path::new(\"/bad/path\").metadata().and_then(|md| md.modified());\n+    /// assert!(should_fail.is_err());\n+    /// assert_eq!(should_fail.unwrap_err().kind(), ErrorKind::NotFound);\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]"}]}