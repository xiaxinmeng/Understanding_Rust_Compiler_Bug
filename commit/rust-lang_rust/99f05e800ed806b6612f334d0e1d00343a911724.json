{"sha": "99f05e800ed806b6612f334d0e1d00343a911724", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk5ZjA1ZTgwMGVkODA2YjY2MTJmMzM0ZDBlMWQwMDM0M2E5MTE3MjQ=", "commit": {"author": {"name": "Nicholas Nethercote", "email": "nnethercote@mozilla.com", "date": "2018-09-18T07:03:24Z"}, "committer": {"name": "Nicholas Nethercote", "email": "nnethercote@mozilla.com", "date": "2018-09-19T22:52:41Z"}, "message": "Improve handling of type bounds in `bit_set.rs`.\n\nCurrently, `BitSet` doesn't actually know its own domain size; it just\nknows how many words it contains. To improve things, this commit makes\nthe following changes.\n\n- It changes `BitSet` and `SparseBitSet` to store their own domain size,\n  and do more precise bounds and same-size checks with it. It also\n  changes the signature of `BitSet::to_string()` (and puts it within\n  `impl ToString`) now that the domain size need not be passed in from\n  outside.\n\n- It uses `derive(RustcDecodable, RustcEncodable)` for `BitSet`. This\n  required adding code to handle `PhantomData` in `libserialize`.\n\n- As a result, it removes the domain size from `HybridBitSet`, making a\n  lot of that code nicer.\n\n- Both set_up_to() and clear_above() were overly general, working with\n  arbitrary sizes when they are only needed for the domain size. The\n  commit removes the former, degeneralizes the latter, and removes the\n  (overly general) tests.\n\n- Changes `GrowableBitSet::grow()` to `ensure()`, fixing a bug where a\n  (1-based) domain size was confused with a (0-based) element index.\n\n- Changes `BitMatrix` to store its row count, and do more precise bounds\n  checks with it.\n\n- Changes `ty_params` in `select.rs` from a `BitSet` to a\n  `GrowableBitSet` because it repeatedly failed the new, more precise\n  bounds checks. (Changing the type was simpler than computing an\n  accurate domain size.)\n\n- Various other minor improvements.", "tree": {"sha": "5922a6b96179daa19bb34c6983393f4823a0dd49", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5922a6b96179daa19bb34c6983393f4823a0dd49"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/99f05e800ed806b6612f334d0e1d00343a911724", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/99f05e800ed806b6612f334d0e1d00343a911724", "html_url": "https://github.com/rust-lang/rust/commit/99f05e800ed806b6612f334d0e1d00343a911724", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/99f05e800ed806b6612f334d0e1d00343a911724/comments", "author": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ff6422d7a392acfc8af28994d65af2bbaecea4f6", "url": "https://api.github.com/repos/rust-lang/rust/commits/ff6422d7a392acfc8af28994d65af2bbaecea4f6", "html_url": "https://github.com/rust-lang/rust/commit/ff6422d7a392acfc8af28994d65af2bbaecea4f6"}], "stats": {"total": 412, "additions": 210, "deletions": 202}, "files": [{"sha": "366cf2b77ea58617cba22d0469b12d6759f8191c", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/99f05e800ed806b6612f334d0e1d00343a911724/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99f05e800ed806b6612f334d0e1d00343a911724/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=99f05e800ed806b6612f334d0e1d00343a911724", "patch": "@@ -44,7 +44,7 @@ use ty::relate::TypeRelation;\n use middle::lang_items;\n use mir::interpret::{GlobalId};\n \n-use rustc_data_structures::bit_set::BitSet;\n+use rustc_data_structures::bit_set::GrowableBitSet;\n use rustc_data_structures::sync::Lock;\n use std::iter;\n use std::cmp;\n@@ -3069,7 +3069,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                 } else {\n                     return Err(Unimplemented);\n                 };\n-                let mut ty_params = BitSet::new_empty(substs_a.types().count());\n+                let mut ty_params = GrowableBitSet::new_empty();\n                 let mut found = false;\n                 for ty in field.walk() {\n                     if let ty::Param(p) = ty.sty {"}, {"sha": "1fba57fa541f0140c8b96e9980ca9d025536ed73", "filename": "src/librustc_data_structures/bit_set.rs", "status": "modified", "additions": 190, "deletions": 196, "changes": 386, "blob_url": "https://github.com/rust-lang/rust/blob/99f05e800ed806b6612f334d0e1d00343a911724/src%2Flibrustc_data_structures%2Fbit_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99f05e800ed806b6612f334d0e1d00343a911724/src%2Flibrustc_data_structures%2Fbit_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fbit_set.rs?ref=99f05e800ed806b6612f334d0e1d00343a911724", "patch": "@@ -9,7 +9,6 @@\n // except according to those terms.\n \n use indexed_vec::{Idx, IndexVec};\n-use rustc_serialize;\n use smallvec::SmallVec;\n use std::fmt;\n use std::iter;\n@@ -26,68 +25,68 @@ pub const WORD_BITS: usize = WORD_BYTES * 8;\n ///\n /// `T` is an index type, typically a newtyped `usize` wrapper, but it can also\n /// just be `usize`.\n-#[derive(Clone, Eq, PartialEq)]\n+///\n+/// All operations that involve an element will panic if the element is equal\n+/// to or greater than the domain size. All operations that involve two bitsets\n+/// will panic if the bitsets have differing domain sizes.\n+#[derive(Clone, Eq, PartialEq, RustcDecodable, RustcEncodable)]\n pub struct BitSet<T: Idx> {\n+    domain_size: usize,\n     words: Vec<Word>,\n     marker: PhantomData<T>,\n }\n \n impl<T: Idx> BitSet<T> {\n+    /// Create a new, empty bitset with a given `domain_size`.\n     #[inline]\n     pub fn new_empty(domain_size: usize) -> BitSet<T> {\n         let num_words = num_words(domain_size);\n         BitSet {\n+            domain_size,\n             words: vec![0; num_words],\n             marker: PhantomData,\n         }\n     }\n \n+    /// Create a new, filled bitset with a given `domain_size`.\n     #[inline]\n     pub fn new_filled(domain_size: usize) -> BitSet<T> {\n         let num_words = num_words(domain_size);\n         let mut result = BitSet {\n+            domain_size,\n             words: vec![!0; num_words],\n             marker: PhantomData,\n         };\n-        result.clear_above(domain_size);\n+        result.clear_excess_bits();\n         result\n     }\n \n+    /// Get the domain size.\n+    pub fn domain_size(&self) -> usize {\n+        self.domain_size\n+    }\n+\n+    /// Clear all elements.\n     #[inline]\n     pub fn clear(&mut self) {\n         for word in &mut self.words {\n             *word = 0;\n         }\n     }\n \n-    /// Sets all elements up to and including `size`.\n-    pub fn set_up_to(&mut self, elem: usize) {\n-        for word in &mut self.words {\n-            *word = !0;\n+    /// Clear excess bits in the final word.\n+    fn clear_excess_bits(&mut self) {\n+        let num_bits_in_final_word = self.domain_size % WORD_BITS;\n+        if num_bits_in_final_word > 0 {\n+            let mask = (1 << num_bits_in_final_word) - 1;\n+            let final_word_idx = self.words.len() - 1;\n+            self.words[final_word_idx] &= mask;\n         }\n-        self.clear_above(elem);\n     }\n \n-    /// Clear all elements above `elem`.\n-    fn clear_above(&mut self, elem: usize) {\n-        let first_clear_block = elem / WORD_BITS;\n-\n-        if first_clear_block < self.words.len() {\n-            // Within `first_clear_block`, the `elem % WORD_BITS` LSBs should\n-            // remain.\n-            let mask = (1 << (elem % WORD_BITS)) - 1;\n-            self.words[first_clear_block] &= mask;\n-\n-            // All the blocks above `first_clear_block` are fully cleared.\n-            for word in &mut self.words[first_clear_block + 1..] {\n-                *word = 0;\n-            }\n-        }\n-    }\n-\n-    /// Efficiently overwrite `self` with `other`. Panics if `self` and `other`\n-    /// don't have the same length.\n+    /// Efficiently overwrite `self` with `other`.\n     pub fn overwrite(&mut self, other: &BitSet<T>) {\n+        assert!(self.domain_size == other.domain_size);\n         self.words.clone_from_slice(&other.words);\n     }\n \n@@ -99,16 +98,15 @@ impl<T: Idx> BitSet<T> {\n     /// True if `self` contains `elem`.\n     #[inline]\n     pub fn contains(&self, elem: T) -> bool {\n+        assert!(elem.index() < self.domain_size);\n         let (word_index, mask) = word_index_and_mask(elem);\n         (self.words[word_index] & mask) != 0\n     }\n \n-    /// True if `self` is a (non-strict) superset of `other`.\n-    ///\n-    /// The two sets must have the same domain_size.\n+    /// Is `self` is a (non-strict) superset of `other`?\n     #[inline]\n     pub fn superset(&self, other: &BitSet<T>) -> bool {\n-        assert_eq!(self.words.len(), other.words.len());\n+        assert_eq!(self.domain_size, other.domain_size);\n         self.words.iter().zip(&other.words).all(|(a, b)| (a & b) == *b)\n     }\n \n@@ -121,6 +119,7 @@ impl<T: Idx> BitSet<T> {\n     /// Insert `elem`. Returns true if the set has changed.\n     #[inline]\n     pub fn insert(&mut self, elem: T) -> bool {\n+        assert!(elem.index() < self.domain_size);\n         let (word_index, mask) = word_index_and_mask(elem);\n         let word_ref = &mut self.words[word_index];\n         let word = *word_ref;\n@@ -134,11 +133,13 @@ impl<T: Idx> BitSet<T> {\n         for word in &mut self.words {\n             *word = !0;\n         }\n+        self.clear_excess_bits();\n     }\n \n     /// Returns true if the set has changed.\n     #[inline]\n     pub fn remove(&mut self, elem: T) -> bool {\n+        assert!(elem.index() < self.domain_size);\n         let (word_index, mask) = word_index_and_mask(elem);\n         let word_ref = &mut self.words[word_index];\n         let word = *word_ref;\n@@ -162,6 +163,7 @@ impl<T: Idx> BitSet<T> {\n     /// Set `self = self & other` and return true if `self` changed.\n     /// (i.e., if any bits were removed).\n     pub fn intersect(&mut self, other: &BitSet<T>) -> bool {\n+        assert_eq!(self.domain_size, other.domain_size);\n         bitwise(&mut self.words, &other.words, |a, b| { a & b })\n     }\n \n@@ -182,43 +184,8 @@ impl<T: Idx> BitSet<T> {\n \n     /// Duplicates the set as a hybrid set.\n     pub fn to_hybrid(&self) -> HybridBitSet<T> {\n-        // This domain_size may be slightly larger than the one specified\n-        // upon creation, due to rounding up to a whole word. That's ok.\n-        let domain_size = self.words.len() * WORD_BITS;\n-\n         // Note: we currently don't bother trying to make a Sparse set.\n-        HybridBitSet::Dense(self.to_owned(), domain_size)\n-    }\n-\n-    pub fn to_string(&self, bits: usize) -> String {\n-        let mut result = String::new();\n-        let mut sep = '[';\n-\n-        // Note: this is a little endian printout of bytes.\n-\n-        // i tracks how many bits we have printed so far.\n-        let mut i = 0;\n-        for word in &self.words {\n-            let mut word = *word;\n-            for _ in 0..WORD_BYTES { // for each byte in `word`:\n-                let remain = bits - i;\n-                // If less than a byte remains, then mask just that many bits.\n-                let mask = if remain <= 8 { (1 << remain) - 1 } else { 0xFF };\n-                assert!(mask <= 0xFF);\n-                let byte = word & mask;\n-\n-                result.push_str(&format!(\"{}{:02x}\", sep, byte));\n-\n-                if remain <= 8 { break; }\n-                word >>= 8;\n-                i += 8;\n-                sep = '-';\n-            }\n-            sep = '|';\n-        }\n-        result.push(']');\n-\n-        result\n+        HybridBitSet::Dense(self.to_owned())\n     }\n }\n \n@@ -238,12 +205,14 @@ pub trait SubtractFromBitSet<T: Idx> {\n \n impl<T: Idx> UnionIntoBitSet<T> for BitSet<T> {\n     fn union_into(&self, other: &mut BitSet<T>) -> bool {\n+        assert_eq!(self.domain_size, other.domain_size);\n         bitwise(&mut other.words, &self.words, |a, b| { a | b })\n     }\n }\n \n impl<T: Idx> SubtractFromBitSet<T> for BitSet<T> {\n     fn subtract_from(&self, other: &mut BitSet<T>) -> bool {\n+        assert_eq!(self.domain_size, other.domain_size);\n         bitwise(&mut other.words, &self.words, |a, b| { a & !b })\n     }\n }\n@@ -256,19 +225,36 @@ impl<T: Idx> fmt::Debug for BitSet<T> {\n     }\n }\n \n-impl<T: Idx> rustc_serialize::Encodable for BitSet<T> {\n-    fn encode<E: rustc_serialize::Encoder>(&self, encoder: &mut E) -> Result<(), E::Error> {\n-        self.words.encode(encoder)\n-    }\n-}\n+impl<T: Idx> ToString for BitSet<T> {\n+    fn to_string(&self) -> String {\n+        let mut result = String::new();\n+        let mut sep = '[';\n \n-impl<T: Idx> rustc_serialize::Decodable for BitSet<T> {\n-    fn decode<D: rustc_serialize::Decoder>(d: &mut D) -> Result<BitSet<T>, D::Error> {\n-        let words: Vec<Word> = rustc_serialize::Decodable::decode(d)?;\n-        Ok(BitSet {\n-            words,\n-            marker: PhantomData,\n-        })\n+        // Note: this is a little endian printout of bytes.\n+\n+        // i tracks how many bits we have printed so far.\n+        let mut i = 0;\n+        for word in &self.words {\n+            let mut word = *word;\n+            for _ in 0..WORD_BYTES { // for each byte in `word`:\n+                let remain = self.domain_size - i;\n+                // If less than a byte remains, then mask just that many bits.\n+                let mask = if remain <= 8 { (1 << remain) - 1 } else { 0xFF };\n+                assert!(mask <= 0xFF);\n+                let byte = word & mask;\n+\n+                result.push_str(&format!(\"{}{:02x}\", sep, byte));\n+\n+                if remain <= 8 { break; }\n+                word >>= 8;\n+                i += 8;\n+                sep = '-';\n+            }\n+            sep = '|';\n+        }\n+        result.push(']');\n+\n+        result\n     }\n }\n \n@@ -326,67 +312,78 @@ const SPARSE_MAX: usize = 8;\n ///\n /// This type is used by `HybridBitSet`; do not use directly.\n #[derive(Clone, Debug)]\n-pub struct SparseBitSet<T: Idx>(SmallVec<[T; SPARSE_MAX]>);\n+pub struct SparseBitSet<T: Idx> {\n+    domain_size: usize,\n+    elems: SmallVec<[T; SPARSE_MAX]>,\n+}\n \n impl<T: Idx> SparseBitSet<T> {\n-    fn new_empty() -> Self {\n-        SparseBitSet(SmallVec::new())\n+    fn new_empty(domain_size: usize) -> Self {\n+        SparseBitSet {\n+            domain_size,\n+            elems: SmallVec::new()\n+        }\n     }\n \n     fn len(&self) -> usize {\n-        self.0.len()\n+        self.elems.len()\n     }\n \n     fn is_empty(&self) -> bool {\n-        self.0.len() == 0\n+        self.elems.len() == 0\n     }\n \n     fn contains(&self, elem: T) -> bool {\n-        self.0.contains(&elem)\n+        assert!(elem.index() < self.domain_size);\n+        self.elems.contains(&elem)\n     }\n \n     fn insert(&mut self, elem: T) -> bool {\n-        assert!(self.len() < SPARSE_MAX);\n-        if let Some(i) = self.0.iter().position(|&e| e >= elem) {\n-            if self.0[i] == elem {\n+        assert!(elem.index() < self.domain_size);\n+        let changed = if let Some(i) = self.elems.iter().position(|&e| e >= elem) {\n+            if self.elems[i] == elem {\n                 // `elem` is already in the set.\n                 false\n             } else {\n                 // `elem` is smaller than one or more existing elements.\n-                self.0.insert(i, elem);\n+                self.elems.insert(i, elem);\n                 true\n             }\n         } else {\n             // `elem` is larger than all existing elements.\n-            self.0.push(elem);\n+            self.elems.push(elem);\n             true\n-        }\n+        };\n+        assert!(self.len() <= SPARSE_MAX);\n+        changed\n     }\n \n     fn remove(&mut self, elem: T) -> bool {\n-        if let Some(i) = self.0.iter().position(|&e| e == elem) {\n-            self.0.remove(i);\n+        assert!(elem.index() < self.domain_size);\n+        if let Some(i) = self.elems.iter().position(|&e| e == elem) {\n+            self.elems.remove(i);\n             true\n         } else {\n             false\n         }\n     }\n \n-    fn to_dense(&self, domain_size: usize) -> BitSet<T> {\n-        let mut dense = BitSet::new_empty(domain_size);\n-        for elem in self.0.iter() {\n+    fn to_dense(&self) -> BitSet<T> {\n+        let mut dense = BitSet::new_empty(self.domain_size);\n+        for elem in self.elems.iter() {\n             dense.insert(*elem);\n         }\n         dense\n     }\n \n     fn iter(&self) -> slice::Iter<T> {\n-        self.0.iter()\n+        self.elems.iter()\n     }\n }\n \n impl<T: Idx> UnionIntoBitSet<T> for SparseBitSet<T> {\n     fn union_into(&self, other: &mut BitSet<T>) -> bool {\n+        assert_eq!(self.domain_size, other.domain_size);\n         let mut changed = false;\n         for elem in self.iter() {\n             changed |= other.insert(*elem);\n@@ -397,6 +394,7 @@ impl<T: Idx> UnionIntoBitSet<T> for SparseBitSet<T> {\n \n impl<T: Idx> SubtractFromBitSet<T> for SparseBitSet<T> {\n     fn subtract_from(&self, other: &mut BitSet<T>) -> bool {\n+        assert_eq!(self.domain_size, other.domain_size);\n         let mut changed = false;\n         for elem in self.iter() {\n             changed |= other.remove(*elem);\n@@ -414,10 +412,14 @@ impl<T: Idx> SubtractFromBitSet<T> for SparseBitSet<T> {\n ///\n /// `T` is an index type, typically a newtyped `usize` wrapper, but it can also\n /// just be `usize`.\n+///\n+/// All operations that involve an element will panic if the element is equal\n+/// to or greater than the domain size. All operations that involve two bitsets\n+/// will panic if the bitsets have differing domain sizes.\n #[derive(Clone, Debug)]\n pub enum HybridBitSet<T: Idx> {\n-    Sparse(SparseBitSet<T>, usize),\n-    Dense(BitSet<T>, usize),\n+    Sparse(SparseBitSet<T>),\n+    Dense(BitSet<T>),\n }\n \n impl<T: Idx> HybridBitSet<T> {\n@@ -427,17 +429,17 @@ impl<T: Idx> HybridBitSet<T> {\n     fn dummy() -> Self {\n         // The cheapest HybridBitSet to construct, which is only used to get\n         // around the borrow checker.\n-        HybridBitSet::Sparse(SparseBitSet::new_empty(), 0)\n+        HybridBitSet::Sparse(SparseBitSet::new_empty(0))\n     }\n \n     pub fn new_empty(domain_size: usize) -> Self {\n-        HybridBitSet::Sparse(SparseBitSet::new_empty(), domain_size)\n+        HybridBitSet::Sparse(SparseBitSet::new_empty(domain_size))\n     }\n \n-    pub fn domain_size(&self) -> usize {\n-        match *self {\n-            HybridBitSet::Sparse(_, size) => size,\n-            HybridBitSet::Dense(_, size) => size,\n+    fn domain_size(&self) -> usize {\n+        match self {\n+            HybridBitSet::Sparse(sparse) => sparse.domain_size,\n+            HybridBitSet::Dense(dense) => dense.domain_size,\n         }\n     }\n \n@@ -448,83 +450,88 @@ impl<T: Idx> HybridBitSet<T> {\n \n     pub fn contains(&self, elem: T) -> bool {\n         match self {\n-            HybridBitSet::Sparse(sparse, _) => sparse.contains(elem),\n-            HybridBitSet::Dense(dense, _) => dense.contains(elem),\n+            HybridBitSet::Sparse(sparse) => sparse.contains(elem),\n+            HybridBitSet::Dense(dense) => dense.contains(elem),\n         }\n     }\n \n     pub fn superset(&self, other: &HybridBitSet<T>) -> bool {\n         match (self, other) {\n-            (HybridBitSet::Dense(self_dense, _), HybridBitSet::Dense(other_dense, _)) => {\n+            (HybridBitSet::Dense(self_dense), HybridBitSet::Dense(other_dense)) => {\n                 self_dense.superset(other_dense)\n             }\n-            _ => other.iter().all(|elem| self.contains(elem)),\n+            _ => {\n+                assert!(self.domain_size() == other.domain_size());\n+                other.iter().all(|elem| self.contains(elem))\n+            }\n         }\n     }\n \n     pub fn is_empty(&self) -> bool {\n         match self {\n-            HybridBitSet::Sparse(sparse, _) => sparse.is_empty(),\n-            HybridBitSet::Dense(dense, _) => dense.is_empty(),\n+            HybridBitSet::Sparse(sparse) => sparse.is_empty(),\n+            HybridBitSet::Dense(dense) => dense.is_empty(),\n         }\n     }\n \n     pub fn insert(&mut self, elem: T) -> bool {\n+        // No need to check `elem` against `self.domain_size` here because all\n+        // the match cases check it, one way or another.\n         match self {\n-            HybridBitSet::Sparse(sparse, _) if sparse.len() < SPARSE_MAX => {\n+            HybridBitSet::Sparse(sparse) if sparse.len() < SPARSE_MAX => {\n                 // The set is sparse and has space for `elem`.\n                 sparse.insert(elem)\n             }\n-            HybridBitSet::Sparse(sparse, _) if sparse.contains(elem) => {\n+            HybridBitSet::Sparse(sparse) if sparse.contains(elem) => {\n                 // The set is sparse and does not have space for `elem`, but\n                 // that doesn't matter because `elem` is already present.\n                 false\n             }\n-            HybridBitSet::Sparse(_, _) => {\n+            HybridBitSet::Sparse(_) => {\n                 // The set is sparse and full. Convert to a dense set.\n                 match mem::replace(self, HybridBitSet::dummy()) {\n-                    HybridBitSet::Sparse(sparse, domain_size) => {\n-                        let mut dense = sparse.to_dense(domain_size);\n+                    HybridBitSet::Sparse(sparse) => {\n+                        let mut dense = sparse.to_dense();\n                         let changed = dense.insert(elem);\n                         assert!(changed);\n-                        *self = HybridBitSet::Dense(dense, domain_size);\n+                        *self = HybridBitSet::Dense(dense);\n                         changed\n                     }\n                     _ => unreachable!()\n                 }\n             }\n \n-            HybridBitSet::Dense(dense, _) => dense.insert(elem),\n+            HybridBitSet::Dense(dense) => dense.insert(elem),\n         }\n     }\n \n     pub fn insert_all(&mut self) {\n         let domain_size = self.domain_size();\n         match self {\n-            HybridBitSet::Sparse(_, _) => {\n-                let dense = BitSet::new_filled(domain_size);\n-                *self = HybridBitSet::Dense(dense, domain_size);\n+            HybridBitSet::Sparse(_) => {\n+                *self = HybridBitSet::Dense(BitSet::new_filled(domain_size));\n             }\n-            HybridBitSet::Dense(dense, _) => dense.insert_all(),\n+            HybridBitSet::Dense(dense) => dense.insert_all(),\n         }\n     }\n \n     pub fn remove(&mut self, elem: T) -> bool {\n         // Note: we currently don't bother going from Dense back to Sparse.\n         match self {\n-            HybridBitSet::Sparse(sparse, _) => sparse.remove(elem),\n-            HybridBitSet::Dense(dense, _) => dense.remove(elem),\n+            HybridBitSet::Sparse(sparse) => sparse.remove(elem),\n+            HybridBitSet::Dense(dense) => dense.remove(elem),\n         }\n     }\n \n     pub fn union(&mut self, other: &HybridBitSet<T>) -> bool {\n         match self {\n-            HybridBitSet::Sparse(_, _) => {\n+            HybridBitSet::Sparse(_) => {\n                 match other {\n-                    HybridBitSet::Sparse(other_sparse, _) => {\n+                    HybridBitSet::Sparse(other_sparse) => {\n                         // Both sets are sparse. Add the elements in\n                         // `other_sparse` to `self_hybrid` one at a time. This\n                         // may or may not cause `self_hybrid` to be densified.\n+                        assert_eq!(self.domain_size(), other.domain_size());\n                         let mut self_hybrid = mem::replace(self, HybridBitSet::dummy());\n                         let mut changed = false;\n                         for elem in other_sparse.iter() {\n@@ -533,14 +540,14 @@ impl<T: Idx> HybridBitSet<T> {\n                         *self = self_hybrid;\n                         changed\n                     }\n-                    HybridBitSet::Dense(other_dense, _) => {\n+                    HybridBitSet::Dense(other_dense) => {\n                         // `self` is sparse and `other` is dense. Densify\n                         // `self` and then do the bitwise union.\n                         match mem::replace(self, HybridBitSet::dummy()) {\n-                            HybridBitSet::Sparse(self_sparse, self_domain_size) => {\n-                                let mut new_dense = self_sparse.to_dense(self_domain_size);\n+                            HybridBitSet::Sparse(self_sparse) => {\n+                                let mut new_dense = self_sparse.to_dense();\n                                 let changed = new_dense.union(other_dense);\n-                                *self = HybridBitSet::Dense(new_dense, self_domain_size);\n+                                *self = HybridBitSet::Dense(new_dense);\n                                 changed\n                             }\n                             _ => unreachable!()\n@@ -549,40 +556,40 @@ impl<T: Idx> HybridBitSet<T> {\n                 }\n             }\n \n-            HybridBitSet::Dense(self_dense, _) => self_dense.union(other),\n+            HybridBitSet::Dense(self_dense) => self_dense.union(other),\n         }\n     }\n \n     /// Converts to a dense set, consuming itself in the process.\n     pub fn to_dense(self) -> BitSet<T> {\n         match self {\n-            HybridBitSet::Sparse(sparse, domain_size) => sparse.to_dense(domain_size),\n-            HybridBitSet::Dense(dense, _) => dense,\n+            HybridBitSet::Sparse(sparse) => sparse.to_dense(),\n+            HybridBitSet::Dense(dense) => dense,\n         }\n     }\n \n     pub fn iter(&self) -> HybridIter<T> {\n         match self {\n-            HybridBitSet::Sparse(sparse, _) => HybridIter::Sparse(sparse.iter()),\n-            HybridBitSet::Dense(dense, _) => HybridIter::Dense(dense.iter()),\n+            HybridBitSet::Sparse(sparse) => HybridIter::Sparse(sparse.iter()),\n+            HybridBitSet::Dense(dense) => HybridIter::Dense(dense.iter()),\n         }\n     }\n }\n \n impl<T: Idx> UnionIntoBitSet<T> for HybridBitSet<T> {\n     fn union_into(&self, other: &mut BitSet<T>) -> bool {\n         match self {\n-            HybridBitSet::Sparse(sparse, _) => sparse.union_into(other),\n-            HybridBitSet::Dense(dense, _) => dense.union_into(other),\n+            HybridBitSet::Sparse(sparse) => sparse.union_into(other),\n+            HybridBitSet::Dense(dense) => dense.union_into(other),\n         }\n     }\n }\n \n impl<T: Idx> SubtractFromBitSet<T> for HybridBitSet<T> {\n     fn subtract_from(&self, other: &mut BitSet<T>) -> bool {\n         match self {\n-            HybridBitSet::Sparse(sparse, _) => sparse.subtract_from(other),\n-            HybridBitSet::Dense(dense, _) => dense.subtract_from(other),\n+            HybridBitSet::Sparse(sparse) => sparse.subtract_from(other),\n+            HybridBitSet::Dense(dense) => dense.subtract_from(other),\n         }\n     }\n }\n@@ -607,16 +614,24 @@ impl<'a, T: Idx> Iterator for HybridIter<'a, T> {\n ///\n /// `T` is an index type, typically a newtyped `usize` wrapper, but it can also\n /// just be `usize`.\n+///\n+/// All operations that involve an element will panic if the element is equal\n+/// to or greater than the domain size.\n #[derive(Clone, Debug, PartialEq)]\n pub struct GrowableBitSet<T: Idx> {\n     bit_set: BitSet<T>,\n }\n \n impl<T: Idx> GrowableBitSet<T> {\n-    pub fn grow(&mut self, domain_size: T) {\n-        let num_words = num_words(domain_size);\n-        if self.bit_set.words.len() <= num_words {\n-            self.bit_set.words.resize(num_words + 1, 0)\n+    /// Ensure that the set can hold at least `min_domain_size` elements.\n+    pub fn ensure(&mut self, min_domain_size: usize) {\n+        if self.bit_set.domain_size < min_domain_size {\n+            self.bit_set.domain_size = min_domain_size;\n+        }\n+\n+        let min_num_words = num_words(min_domain_size);\n+        if self.bit_set.words.len() < min_num_words {\n+            self.bit_set.words.resize(min_num_words, 0)\n         }\n     }\n \n@@ -631,7 +646,7 @@ impl<T: Idx> GrowableBitSet<T> {\n     /// Returns true if the set has changed.\n     #[inline]\n     pub fn insert(&mut self, elem: T) -> bool {\n-        self.grow(elem);\n+        self.ensure(elem.index() + 1);\n         self.bit_set.insert(elem)\n     }\n \n@@ -651,39 +666,43 @@ impl<T: Idx> GrowableBitSet<T> {\n /// `R` and `C` are index types used to identify rows and columns respectively;\n /// typically newtyped `usize` wrappers, but they can also just be `usize`.\n ///\n+/// All operations that involve a row and/or column index will panic if the\n+/// index exceeds the relevant bound.\n #[derive(Clone, Debug)]\n pub struct BitMatrix<R: Idx, C: Idx> {\n-    columns: usize,\n+    num_rows: usize,\n+    num_columns: usize,\n     words: Vec<Word>,\n     marker: PhantomData<(R, C)>,\n }\n \n impl<R: Idx, C: Idx> BitMatrix<R, C> {\n     /// Create a new `rows x columns` matrix, initially empty.\n-    pub fn new(rows: usize, columns: usize) -> BitMatrix<R, C> {\n+    pub fn new(num_rows: usize, num_columns: usize) -> BitMatrix<R, C> {\n         // For every element, we need one bit for every other\n         // element. Round up to an even number of words.\n-        let words_per_row = num_words(columns);\n+        let words_per_row = num_words(num_columns);\n         BitMatrix {\n-            columns,\n-            words: vec![0; rows * words_per_row],\n+            num_rows,\n+            num_columns,\n+            words: vec![0; num_rows * words_per_row],\n             marker: PhantomData,\n         }\n     }\n \n     /// The range of bits for a given row.\n     fn range(&self, row: R) -> (usize, usize) {\n-        let row = row.index();\n-        let words_per_row = num_words(self.columns);\n-        let start = row * words_per_row;\n+        let words_per_row = num_words(self.num_columns);\n+        let start = row.index() * words_per_row;\n         (start, start + words_per_row)\n     }\n \n     /// Sets the cell at `(row, column)` to true. Put another way, insert\n     /// `column` to the bitset for `row`.\n     ///\n     /// Returns true if this changed the matrix, and false otherwise.\n-    pub fn insert(&mut self, row: R, column: R) -> bool {\n+    pub fn insert(&mut self, row: R, column: C) -> bool {\n+        assert!(row.index() < self.num_rows && column.index() < self.num_columns);\n         let (start, _) = self.range(row);\n         let (word_index, mask) = word_index_and_mask(column);\n         let words = &mut self.words[..];\n@@ -697,7 +716,8 @@ impl<R: Idx, C: Idx> BitMatrix<R, C> {\n     /// the matrix cell at `(row, column)` true?  Put yet another way,\n     /// if the matrix represents (transitive) reachability, can\n     /// `row` reach `column`?\n-    pub fn contains(&self, row: R, column: R) -> bool {\n+    pub fn contains(&self, row: R, column: C) -> bool {\n+        assert!(row.index() < self.num_rows && column.index() < self.num_columns);\n         let (start, _) = self.range(row);\n         let (word_index, mask) = word_index_and_mask(column);\n         (self.words[start + word_index] & mask) != 0\n@@ -707,11 +727,12 @@ impl<R: Idx, C: Idx> BitMatrix<R, C> {\n     /// is an O(n) operation where `n` is the number of elements\n     /// (somewhat independent from the actual size of the\n     /// intersection, in particular).\n-    pub fn intersect_rows(&self, a: R, b: R) -> Vec<C> {\n-        let (a_start, a_end) = self.range(a);\n-        let (b_start, b_end) = self.range(b);\n-        let mut result = Vec::with_capacity(self.columns);\n-        for (base, (i, j)) in (a_start..a_end).zip(b_start..b_end).enumerate() {\n+    pub fn intersect_rows(&self, row1: R, row2: R) -> Vec<C> {\n+        assert!(row1.index() < self.num_rows && row2.index() < self.num_rows);\n+        let (row1_start, row1_end) = self.range(row1);\n+        let (row2_start, row2_end) = self.range(row2);\n+        let mut result = Vec::with_capacity(self.num_columns);\n+        for (base, (i, j)) in (row1_start..row1_end).zip(row2_start..row2_end).enumerate() {\n             let mut v = self.words[i] & self.words[j];\n             for bit in 0..WORD_BITS {\n                 if v == 0 {\n@@ -734,6 +755,7 @@ impl<R: Idx, C: Idx> BitMatrix<R, C> {\n     /// `write` can reach everything that `read` can (and\n     /// potentially more).\n     pub fn union_rows(&mut self, read: R, write: R) -> bool {\n+        assert!(read.index() < self.num_rows && write.index() < self.num_rows);\n         let (read_start, read_end) = self.range(read);\n         let (write_start, write_end) = self.range(write);\n         let words = &mut self.words[..];\n@@ -750,6 +772,7 @@ impl<R: Idx, C: Idx> BitMatrix<R, C> {\n     /// Iterates through all the columns set to true in a given row of\n     /// the matrix.\n     pub fn iter<'a>(&'a self, row: R) -> BitIter<'a, C> {\n+        assert!(row.index() < self.num_rows);\n         let (start, end) = self.range(row);\n         BitIter {\n             cur: None,\n@@ -865,47 +888,18 @@ impl<R: Idx, C: Idx> SparseBitMatrix<R, C> {\n }\n \n #[inline]\n-fn num_words<T: Idx>(elements: T) -> usize {\n-    (elements.index() + WORD_BITS - 1) / WORD_BITS\n+fn num_words<T: Idx>(domain_size: T) -> usize {\n+    (domain_size.index() + WORD_BITS - 1) / WORD_BITS\n }\n \n #[inline]\n-fn word_index_and_mask<T: Idx>(index: T) -> (usize, Word) {\n-    let index = index.index();\n-    let word_index = index / WORD_BITS;\n-    let mask = 1 << (index % WORD_BITS);\n+fn word_index_and_mask<T: Idx>(elem: T) -> (usize, Word) {\n+    let elem = elem.index();\n+    let word_index = elem / WORD_BITS;\n+    let mask = 1 << (elem % WORD_BITS);\n     (word_index, mask)\n }\n \n-#[test]\n-fn test_clear_above() {\n-    use std::cmp;\n-\n-    for i in 0..256 {\n-        let mut idx_buf: BitSet<usize> = BitSet::new_filled(128);\n-        idx_buf.clear_above(i);\n-\n-        let elems: Vec<usize> = idx_buf.iter().collect();\n-        let expected: Vec<usize> = (0..cmp::min(i, 128)).collect();\n-        assert_eq!(elems, expected);\n-    }\n-}\n-\n-#[test]\n-fn test_set_up_to() {\n-    for i in 0..128 {\n-        for mut idx_buf in\n-            vec![BitSet::new_empty(128), BitSet::new_filled(128)].into_iter()\n-        {\n-            idx_buf.set_up_to(i);\n-\n-            let elems: Vec<usize> = idx_buf.iter().collect();\n-            let expected: Vec<usize> = (0..i).collect();\n-            assert_eq!(elems, expected);\n-        }\n-    }\n-}\n-\n #[test]\n fn test_new_filled() {\n     for i in 0..128 {\n@@ -936,7 +930,7 @@ fn bitset_iter_works() {\n \n #[test]\n fn bitset_iter_works_2() {\n-    let mut bitset: BitSet<usize> = BitSet::new_empty(319);\n+    let mut bitset: BitSet<usize> = BitSet::new_empty(320);\n     bitset.insert(0);\n     bitset.insert(127);\n     bitset.insert(191);\n@@ -1037,7 +1031,7 @@ fn grow() {\n         assert!(set.insert(index));\n         assert!(!set.insert(index));\n     }\n-    set.grow(128);\n+    set.ensure(128);\n \n     // Check if the bits set before growing are still set\n     for index in 0..65 {"}, {"sha": "1fbeb66be304fd56cf742839ff17393f82e34eff", "filename": "src/librustc_mir/dataflow/graphviz.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/99f05e800ed806b6612f334d0e1d00343a911724/src%2Flibrustc_mir%2Fdataflow%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99f05e800ed806b6612f334d0e1d00343a911724/src%2Flibrustc_mir%2Fdataflow%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fgraphviz.rs?ref=99f05e800ed806b6612f334d0e1d00343a911724", "patch": "@@ -216,13 +216,12 @@ where MWF: MirWithFlowState<'tcx>,\n         let i = n.index();\n \n         let flow = self.mbcx.flow_state();\n-        let bits_per_block = flow.sets.bits_per_block();\n \n         write!(w, \"<tr>\")?;\n \n         // Entry\n         let set = flow.sets.on_entry_set_for(i);\n-        write!(w, \"<td>{:?}</td>\", dot::escape_html(&set.to_string(bits_per_block)))?;\n+        write!(w, \"<td>{:?}</td>\", dot::escape_html(&set.to_string()))?;\n \n         // Terminator\n         write!(w, \"<td>\")?;"}, {"sha": "efdf9c3302374afb370534ea9e6e174eba8851ba", "filename": "src/librustc_mir/dataflow/impls/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/99f05e800ed806b6612f334d0e1d00343a911724/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99f05e800ed806b6612f334d0e1d00343a911724/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fmod.rs?ref=99f05e800ed806b6612f334d0e1d00343a911724", "patch": "@@ -354,7 +354,8 @@ impl<'a, 'gcx, 'tcx> BitDenotation for MaybeUninitializedPlaces<'a, 'gcx, 'tcx>\n     // sets on_entry bits for Arg places\n     fn start_block_effect(&self, entry_set: &mut BitSet<MovePathIndex>) {\n         // set all bits to 1 (uninit) before gathering counterevidence\n-        entry_set.set_up_to(self.bits_per_block());\n+        assert!(self.bits_per_block() == entry_set.domain_size());\n+        entry_set.insert_all();\n \n         drop_flag_effects_for_function_entry(\n             self.tcx, self.mir, self.mdpe,"}, {"sha": "ea01d17ac134124744e5b2293de308a3b22f4eaa", "filename": "src/librustc_mir/monomorphize/collector.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/99f05e800ed806b6612f334d0e1d00343a911724/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99f05e800ed806b6612f334d0e1d00343a911724/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs?ref=99f05e800ed806b6612f334d0e1d00343a911724", "patch": "@@ -256,7 +256,7 @@ impl<'tcx> InliningMap<'tcx> {\n         let new_items_count_total = new_items_count + self.targets.len();\n \n         self.targets.reserve(new_items_count);\n-        self.inlines.grow(new_items_count_total);\n+        self.inlines.ensure(new_items_count_total);\n \n         for (i, (target, inline)) in new_targets.enumerate() {\n             self.targets.push(target);"}, {"sha": "6f1652cdee06f79906fbb0138553150865659dc9", "filename": "src/libserialize/serialize.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/99f05e800ed806b6612f334d0e1d00343a911724/src%2Flibserialize%2Fserialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99f05e800ed806b6612f334d0e1d00343a911724/src%2Flibserialize%2Fserialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fserialize.rs?ref=99f05e800ed806b6612f334d0e1d00343a911724", "patch": "@@ -16,6 +16,7 @@ Core encoding and decoding interfaces.\n \n use std::borrow::Cow;\n use std::intrinsics;\n+use std::marker::PhantomData;\n use std::path;\n use std::rc::Rc;\n use std::cell::{Cell, RefCell};\n@@ -547,6 +548,19 @@ impl Decodable for () {\n     }\n }\n \n+impl<T> Encodable for PhantomData<T> {\n+    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n+        s.emit_unit()\n+    }\n+}\n+\n+impl<T> Decodable for PhantomData<T> {\n+    fn decode<D: Decoder>(d: &mut D) -> Result<PhantomData<T>, D::Error> {\n+        d.read_nil()?;\n+        Ok(PhantomData)\n+    }\n+}\n+\n impl<'a, T: ?Sized + Encodable> Encodable for &'a T {\n     fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n         (**self).encode(s)"}]}