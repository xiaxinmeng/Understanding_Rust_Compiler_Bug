{"sha": "2861ceb2fa1acc2c642abd4f2efb96c713a47e29", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI4NjFjZWIyZmExYWNjMmM2NDJhYmQ0ZjJlZmI5NmM3MTNhNDdlMjk=", "commit": {"author": {"name": "Christian Poveda", "email": "cpovedar@fnal.gov", "date": "2019-06-24T15:03:16Z"}, "committer": {"name": "Christian Poveda", "email": "cpovedar@fnal.gov", "date": "2019-06-24T15:03:16Z"}, "message": "Rename new fields and move rng to MemoryExtra", "tree": {"sha": "30ce8e56ccee97ead75a5837bacb00dfb397ad9a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/30ce8e56ccee97ead75a5837bacb00dfb397ad9a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2861ceb2fa1acc2c642abd4f2efb96c713a47e29", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2861ceb2fa1acc2c642abd4f2efb96c713a47e29", "html_url": "https://github.com/rust-lang/rust/commit/2861ceb2fa1acc2c642abd4f2efb96c713a47e29", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2861ceb2fa1acc2c642abd4f2efb96c713a47e29/comments", "author": {"login": "pvdrz", "id": 31802960, "node_id": "MDQ6VXNlcjMxODAyOTYw", "avatar_url": "https://avatars.githubusercontent.com/u/31802960?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pvdrz", "html_url": "https://github.com/pvdrz", "followers_url": "https://api.github.com/users/pvdrz/followers", "following_url": "https://api.github.com/users/pvdrz/following{/other_user}", "gists_url": "https://api.github.com/users/pvdrz/gists{/gist_id}", "starred_url": "https://api.github.com/users/pvdrz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pvdrz/subscriptions", "organizations_url": "https://api.github.com/users/pvdrz/orgs", "repos_url": "https://api.github.com/users/pvdrz/repos", "events_url": "https://api.github.com/users/pvdrz/events{/privacy}", "received_events_url": "https://api.github.com/users/pvdrz/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pvdrz", "id": 31802960, "node_id": "MDQ6VXNlcjMxODAyOTYw", "avatar_url": "https://avatars.githubusercontent.com/u/31802960?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pvdrz", "html_url": "https://github.com/pvdrz", "followers_url": "https://api.github.com/users/pvdrz/followers", "following_url": "https://api.github.com/users/pvdrz/following{/other_user}", "gists_url": "https://api.github.com/users/pvdrz/gists{/gist_id}", "starred_url": "https://api.github.com/users/pvdrz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pvdrz/subscriptions", "organizations_url": "https://api.github.com/users/pvdrz/orgs", "repos_url": "https://api.github.com/users/pvdrz/repos", "events_url": "https://api.github.com/users/pvdrz/events{/privacy}", "received_events_url": "https://api.github.com/users/pvdrz/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dd732e5862ba4601959bbae7993eb4924ddf8ee6", "url": "https://api.github.com/repos/rust-lang/rust/commits/dd732e5862ba4601959bbae7993eb4924ddf8ee6", "html_url": "https://github.com/rust-lang/rust/commit/dd732e5862ba4601959bbae7993eb4924ddf8ee6"}], "stats": {"total": 78, "additions": 37, "deletions": 41}, "files": [{"sha": "e47e2169121175aa23a8f46999216d40d72ebcc4", "filename": "src/fn_call.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2861ceb2fa1acc2c642abd4f2efb96c713a47e29/src%2Ffn_call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2861ceb2fa1acc2c642abd4f2efb96c713a47e29/src%2Ffn_call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ffn_call.rs?ref=2861ceb2fa1acc2c642abd4f2efb96c713a47e29", "patch": "@@ -979,7 +979,7 @@ fn gen_random<'mir, 'tcx>(\n     }\n     let ptr = dest.to_ptr()?;\n \n-    let data = match &mut this.machine.rng {\n+    let data = match &mut this.memory_mut().extra.rng {\n         Some(rng) => {\n             let mut data = vec![0; len];\n             rng.fill_bytes(&mut data);"}, {"sha": "f95cf0fda46b27e3c8621f6c7eb2884801235845", "filename": "src/intptrcast.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2861ceb2fa1acc2c642abd4f2efb96c713a47e29/src%2Fintptrcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2861ceb2fa1acc2c642abd4f2efb96c713a47e29/src%2Fintptrcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintptrcast.rs?ref=2861ceb2fa1acc2c642abd4f2efb96c713a47e29", "patch": "@@ -6,15 +6,17 @@ pub type MemoryState = RefCell<GlobalState>;\n \n #[derive(Clone, Debug)]\n pub struct GlobalState {\n-    pub vec: Vec<(u64, AllocId)>,\n-    pub addr: u64,\n+    /// This field is used as a map between the address of each allocation and its `AllocId`\n+    pub int_to_ptr_map: Vec<(u64, AllocId)>,\n+    pub next_base_addr: u64,\n }\n \n impl Default for GlobalState {\n+    // FIXME: Query the page size in the future\n     fn default() -> Self {\n         GlobalState {\n-            vec: Vec::default(),\n-            addr: 2u64.pow(16)\n+            int_to_ptr_map: Vec::default(),\n+            next_base_addr: 2u64.pow(16)\n         }\n     }\n }"}, {"sha": "5288537f20ee82a3b6b117864a197a38203aeab5", "filename": "src/lib.rs", "status": "modified", "additions": 23, "deletions": 32, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/2861ceb2fa1acc2c642abd4f2efb96c713a47e29/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2861ceb2fa1acc2c642abd4f2efb96c713a47e29/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=2861ceb2fa1acc2c642abd4f2efb96c713a47e29", "patch": "@@ -25,7 +25,7 @@ mod memory;\n \n use std::collections::HashMap;\n use std::borrow::Cow;\n-use std::cell::RefCell;\n+use std::cell::Cell;\n use std::rc::Rc;\n \n use rand::rngs::StdRng;\n@@ -83,9 +83,11 @@ pub fn create_ecx<'mir, 'tcx: 'mir>(\n     let mut ecx = InterpretCx::new(\n         tcx.at(syntax::source_map::DUMMY_SP),\n         ty::ParamEnv::reveal_all(),\n-        Evaluator::new(config.validate, config.seed),\n+        Evaluator::new(config.validate),\n     );\n \n+    ecx.memory_mut().extra.rng = config.seed.map(StdRng::seed_from_u64);\n+    \n     let main_instance = ty::Instance::mono(ecx.tcx.tcx, main_id);\n     let main_mir = ecx.load_mir(main_instance.def)?;\n \n@@ -209,9 +211,7 @@ pub fn create_ecx<'mir, 'tcx: 'mir>(\n             cur_ptr = cur_ptr.offset(char_size, tcx)?;\n         }\n     }\n-\n-    ecx.memory_mut().extra.seed = config.seed.clone();\n-    \n+ \n     assert!(args.next().is_none(), \"start lang item has more arguments than expected\");\n \n     Ok(ecx)\n@@ -347,14 +347,10 @@ pub struct Evaluator<'tcx> {\n \n     /// Whether to enforce the validity invariant.\n     pub(crate) validate: bool,\n-\n-    /// The random number generator to use if Miri\n-    /// is running in non-deterministic mode\n-    pub(crate) rng: Option<StdRng>\n }\n \n impl<'tcx> Evaluator<'tcx> {\n-    fn new(validate: bool, seed: Option<u64>) -> Self {\n+    fn new(validate: bool) -> Self {\n         Evaluator {\n             env_vars: HashMap::default(),\n             argc: None,\n@@ -363,7 +359,6 @@ impl<'tcx> Evaluator<'tcx> {\n             last_error: 0,\n             tls: TlsData::default(),\n             validate,\n-            rng: seed.map(|s| StdRng::seed_from_u64(s))\n         }\n     }\n }\n@@ -543,7 +538,7 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'tcx> {\n             mutability: alloc.mutability,\n             extra: AllocExtra {\n                 stacks: extra,\n-                base_addr: RefCell::new(None),\n+                base_addr: Cell::new(None),\n             },\n         };\n         (Cow::Owned(alloc), base_tag)\n@@ -598,20 +593,20 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'tcx> {\n             return err!(InvalidNullPointerUsage);\n         }\n         \n-        if memory.extra.seed.is_none() {\n+        if memory.extra.rng.is_none() {\n             return err!(ReadBytesAsPointer);\n         }\n \n         let extra = memory.extra.intptrcast.borrow();\n         \n-        match extra.vec.binary_search_by_key(&int, |(int, _)| *int) {\n+        match extra.int_to_ptr_map.binary_search_by_key(&int, |(int, _)| *int) {\n             Ok(pos) => {\n-                let (_, alloc_id) = extra.vec[pos];\n+                let (_, alloc_id) = extra.int_to_ptr_map[pos];\n                 Ok(Pointer::new_with_tag(alloc_id, Size::from_bytes(0), Tag::Untagged))\n             }\n             Err(pos) => {\n                 if pos > 0 {\n-                    let (glb, alloc_id) = extra.vec[pos - 1];\n+                    let (glb, alloc_id) = extra.int_to_ptr_map[pos - 1];\n                     let offset = int - glb;\n                     if offset <= memory.get(alloc_id)?.bytes.len() as u64 {\n                         Ok(Pointer::new_with_tag(alloc_id, Size::from_bytes(offset), Tag::Untagged))\n@@ -629,36 +624,32 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'tcx> {\n         ptr: Pointer<Self::PointerTag>,\n         memory: &Memory<'mir, 'tcx, Self>,\n     ) -> InterpResult<'tcx, u64> {\n-        if memory.extra.seed.is_none() {\n+        if memory.extra.rng.is_none() {\n             return err!(ReadPointerAsBytes);\n         }\n \n         let mut extra = memory.extra.intptrcast.borrow_mut();\n \n         let alloc = memory.get(ptr.alloc_id)?;\n \n-        let mut base_addr = alloc.extra.base_addr.borrow_mut();\n-        \n-        let addr = match *base_addr { \n-            Some(addr) => addr,\n+        let base_addr = match alloc.extra.base_addr.get() { \n+            Some(base_addr) => base_addr,\n             None => {\n-                let addr = extra.addr;\n-                extra.addr += alloc.bytes.len() as u64;\n+                let base_addr = extra.next_base_addr;\n+                extra.next_base_addr += alloc.bytes.len() as u64;\n \n-                *base_addr = Some(addr);\n+                alloc.extra.base_addr.set(Some(base_addr));\n \n-                let elem = (addr, ptr.alloc_id);\n+                let elem = (base_addr, ptr.alloc_id);\n \n-                if let Err(pos) = extra.vec.binary_search(&elem) {\n-                    extra.vec.insert(pos, elem);\n-                } else {\n-                    return err!(Unreachable);\n-                }\n+                // Given that `next_base_addr` increases in each allocation, pushing the\n+                // corresponding tuple keeps `int_to_ptr_map` sorted\n+                extra.int_to_ptr_map.push(elem); \n \n-                addr\n+                base_addr\n             }\n         };\n \n-        Ok(addr + ptr.offset.bytes())\n+        Ok(base_addr + ptr.offset.bytes())\n     }\n }"}, {"sha": "fafa9272bacd1243355bbb3e8fd255097c90829d", "filename": "src/memory.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/2861ceb2fa1acc2c642abd4f2efb96c713a47e29/src%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2861ceb2fa1acc2c642abd4f2efb96c713a47e29/src%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmemory.rs?ref=2861ceb2fa1acc2c642abd4f2efb96c713a47e29", "patch": "@@ -1,4 +1,5 @@\n-use std::cell::RefCell;\n+use std::cell::Cell;\n+use rand::rngs::StdRng;\n \n use rustc_mir::interpret::{Pointer, Allocation, AllocationExtra, InterpResult};\n use rustc_target::abi::Size;\n@@ -10,13 +11,15 @@ use crate::stacked_borrows::{Tag, AccessKind};\n pub struct MemoryState {\n     pub stacked: stacked_borrows::MemoryState,\n     pub intptrcast: intptrcast::MemoryState,\n-    pub seed: Option<u64>,\n+    /// The random number generator to use if Miri\n+    /// is running in non-deterministic mode\n+    pub(crate) rng: Option<StdRng>\n }\n \n #[derive(Debug, Clone,)]\n pub struct AllocExtra {\n     pub stacks: stacked_borrows::Stacks,\n-    pub base_addr: RefCell<Option<u64>>,\n+    pub base_addr: Cell<Option<u64>>,\n }\n \n impl AllocationExtra<Tag> for AllocExtra {"}, {"sha": "0ebb1e71610a6dc5485180f3cab42c116d49e02e", "filename": "src/operator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2861ceb2fa1acc2c642abd4f2efb96c713a47e29/src%2Foperator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2861ceb2fa1acc2c642abd4f2efb96c713a47e29/src%2Foperator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Foperator.rs?ref=2861ceb2fa1acc2c642abd4f2efb96c713a47e29", "patch": "@@ -44,7 +44,7 @@ impl<'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'mir, 'tcx> {\n \n         trace!(\"ptr_op: {:?} {:?} {:?}\", *left, bin_op, *right);\n \n-        if self.memory().extra.seed.is_some() && bin_op != Offset {\n+        if self.memory().extra.rng.is_some() && bin_op != Offset {\n             let l_bits = self.force_bits(left.imm.to_scalar()?, left.layout.size)?;\n             let r_bits = self.force_bits(right.imm.to_scalar()?, right.layout.size)?;\n             "}]}