{"sha": "905d5a38d69328385ce9963c65c385734c60322d", "node_id": "C_kwDOAAsO6NoAKDkwNWQ1YTM4ZDY5MzI4Mzg1Y2U5OTYzYzY1YzM4NTczNGM2MDMyMmQ", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-05-06T14:16:55Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-05-06T14:16:55Z"}, "message": "Auto merge of #111287 - matthiaskrgr:rollup-9lzax2c, r=matthiaskrgr\n\nRollup of 7 pull requests\n\nSuccessful merges:\n\n - #110577 (Use fulfillment to check `Drop` impl compatibility)\n - #110610 (Add Terminator conversion from MIR to SMIR, part #1)\n - #110985 (Fix spans in LLVM-generated inline asm errors)\n - #110989 (Make the BUG_REPORT_URL configurable by tools )\n - #111167 (debuginfo: split method declaration and definition)\n - #111230 (add hint for =< as <=)\n - #111279 (More robust debug assertions for `Instance::resolve` on built-in traits with non-standard trait items)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "0a9c58202e335237689a8590698a501a41806116", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0a9c58202e335237689a8590698a501a41806116"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/905d5a38d69328385ce9963c65c385734c60322d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/905d5a38d69328385ce9963c65c385734c60322d", "html_url": "https://github.com/rust-lang/rust/commit/905d5a38d69328385ce9963c65c385734c60322d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/905d5a38d69328385ce9963c65c385734c60322d/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "333b920feeb136d35fac804d51310df1a35c399e", "url": "https://api.github.com/repos/rust-lang/rust/commits/333b920feeb136d35fac804d51310df1a35c399e", "html_url": "https://github.com/rust-lang/rust/commit/333b920feeb136d35fac804d51310df1a35c399e"}, {"sha": "3cb1a4676a62eaa60c74a56c5e389aa1b258b3aa", "url": "https://api.github.com/repos/rust-lang/rust/commits/3cb1a4676a62eaa60c74a56c5e389aa1b258b3aa", "html_url": "https://github.com/rust-lang/rust/commit/3cb1a4676a62eaa60c74a56c5e389aa1b258b3aa"}], "stats": {"total": 1480, "additions": 1067, "deletions": 413}, "files": [{"sha": "724587a4a71c10f9898d0070177dea75a0619699", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/905d5a38d69328385ce9963c65c385734c60322d/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/905d5a38d69328385ce9963c65c385734c60322d/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=905d5a38d69328385ce9963c65c385734c60322d", "patch": "@@ -4093,6 +4093,7 @@ dependencies = [\n name = \"rustc_smir\"\n version = \"0.0.0\"\n dependencies = [\n+ \"rustc_hir\",\n  \"rustc_middle\",\n  \"rustc_span\",\n  \"tracing\","}, {"sha": "b138b0c0e70a17205b7f4c5b3628370f0b6065b1", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/mod.rs", "status": "modified", "additions": 51, "deletions": 34, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/905d5a38d69328385ce9963c65c385734c60322d/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/905d5a38d69328385ce9963c65c385734c60322d/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmod.rs?ref=905d5a38d69328385ce9963c65c385734c60322d", "patch": "@@ -322,7 +322,7 @@ impl<'ll, 'tcx> DebugInfoMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n         let tcx = self.tcx;\n \n         let def_id = instance.def_id();\n-        let containing_scope = get_containing_scope(self, instance);\n+        let (containing_scope, is_method) = get_containing_scope(self, instance);\n         let span = tcx.def_span(def_id);\n         let loc = self.lookup_debug_loc(span.lo());\n         let file_metadata = file_metadata(self, &loc.file);\n@@ -378,8 +378,29 @@ impl<'ll, 'tcx> DebugInfoMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n             }\n         }\n \n-        unsafe {\n-            return llvm::LLVMRustDIBuilderCreateFunction(\n+        // When we're adding a method to a type DIE, we only want a DW_AT_declaration there, because\n+        // LLVM LTO can't unify type definitions when a child DIE is a full subprogram definition.\n+        // When we use this `decl` below, the subprogram definition gets created at the CU level\n+        // with a DW_AT_specification pointing back to the type's declaration.\n+        let decl = is_method.then(|| unsafe {\n+            llvm::LLVMRustDIBuilderCreateMethod(\n+                DIB(self),\n+                containing_scope,\n+                name.as_ptr().cast(),\n+                name.len(),\n+                linkage_name.as_ptr().cast(),\n+                linkage_name.len(),\n+                file_metadata,\n+                loc.line,\n+                function_type_metadata,\n+                flags,\n+                spflags & !DISPFlags::SPFlagDefinition,\n+                template_parameters,\n+            )\n+        });\n+\n+        return unsafe {\n+            llvm::LLVMRustDIBuilderCreateFunction(\n                 DIB(self),\n                 containing_scope,\n                 name.as_ptr().cast(),\n@@ -394,9 +415,9 @@ impl<'ll, 'tcx> DebugInfoMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n                 spflags,\n                 maybe_definition_llfn,\n                 template_parameters,\n-                None,\n-            );\n-        }\n+                decl,\n+            )\n+        };\n \n         fn get_function_signature<'ll, 'tcx>(\n             cx: &CodegenCx<'ll, 'tcx>,\n@@ -493,14 +514,16 @@ impl<'ll, 'tcx> DebugInfoMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n             names\n         }\n \n+        /// Returns a scope, plus `true` if that's a type scope for \"class\" methods,\n+        /// otherwise `false` for plain namespace scopes.\n         fn get_containing_scope<'ll, 'tcx>(\n             cx: &CodegenCx<'ll, 'tcx>,\n             instance: Instance<'tcx>,\n-        ) -> &'ll DIScope {\n+        ) -> (&'ll DIScope, bool) {\n             // First, let's see if this is a method within an inherent impl. Because\n             // if yes, we want to make the result subroutine DIE a child of the\n             // subroutine's self-type.\n-            let self_type = cx.tcx.impl_of_method(instance.def_id()).and_then(|impl_def_id| {\n+            if let Some(impl_def_id) = cx.tcx.impl_of_method(instance.def_id()) {\n                 // If the method does *not* belong to a trait, proceed\n                 if cx.tcx.trait_id_of_impl(impl_def_id).is_none() {\n                     let impl_self_ty = cx.tcx.subst_and_normalize_erasing_regions(\n@@ -511,39 +534,33 @@ impl<'ll, 'tcx> DebugInfoMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n \n                     // Only \"class\" methods are generally understood by LLVM,\n                     // so avoid methods on other types (e.g., `<*mut T>::null`).\n-                    match impl_self_ty.kind() {\n-                        ty::Adt(def, ..) if !def.is_box() => {\n-                            // Again, only create type information if full debuginfo is enabled\n-                            if cx.sess().opts.debuginfo == DebugInfo::Full\n-                                && !impl_self_ty.has_param()\n-                            {\n-                                Some(type_di_node(cx, impl_self_ty))\n-                            } else {\n-                                Some(namespace::item_namespace(cx, def.did()))\n-                            }\n+                    if let ty::Adt(def, ..) = impl_self_ty.kind() && !def.is_box() {\n+                        // Again, only create type information if full debuginfo is enabled\n+                        if cx.sess().opts.debuginfo == DebugInfo::Full && !impl_self_ty.has_param()\n+                        {\n+                            return (type_di_node(cx, impl_self_ty), true);\n+                        } else {\n+                            return (namespace::item_namespace(cx, def.did()), false);\n                         }\n-                        _ => None,\n                     }\n                 } else {\n                     // For trait method impls we still use the \"parallel namespace\"\n                     // strategy\n-                    None\n                 }\n-            });\n+            }\n \n-            self_type.unwrap_or_else(|| {\n-                namespace::item_namespace(\n-                    cx,\n-                    DefId {\n-                        krate: instance.def_id().krate,\n-                        index: cx\n-                            .tcx\n-                            .def_key(instance.def_id())\n-                            .parent\n-                            .expect(\"get_containing_scope: missing parent?\"),\n-                    },\n-                )\n-            })\n+            let scope = namespace::item_namespace(\n+                cx,\n+                DefId {\n+                    krate: instance.def_id().krate,\n+                    index: cx\n+                        .tcx\n+                        .def_key(instance.def_id())\n+                        .parent\n+                        .expect(\"get_containing_scope: missing parent?\"),\n+                },\n+            );\n+            (scope, false)\n         }\n     }\n "}, {"sha": "61365e6dc4b0e93f9fae086bc674dbfeb482de06", "filename": "compiler/rustc_codegen_llvm/src/llvm/ffi.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/905d5a38d69328385ce9963c65c385734c60322d/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/905d5a38d69328385ce9963c65c385734c60322d/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs?ref=905d5a38d69328385ce9963c65c385734c60322d", "patch": "@@ -1987,6 +1987,21 @@ extern \"C\" {\n         Decl: Option<&'a DIDescriptor>,\n     ) -> &'a DISubprogram;\n \n+    pub fn LLVMRustDIBuilderCreateMethod<'a>(\n+        Builder: &DIBuilder<'a>,\n+        Scope: &'a DIDescriptor,\n+        Name: *const c_char,\n+        NameLen: size_t,\n+        LinkageName: *const c_char,\n+        LinkageNameLen: size_t,\n+        File: &'a DIFile,\n+        LineNo: c_uint,\n+        Ty: &'a DIType,\n+        Flags: DIFlags,\n+        SPFlags: DISPFlags,\n+        TParam: &'a DIArray,\n+    ) -> &'a DISubprogram;\n+\n     pub fn LLVMRustDIBuilderCreateBasicType<'a>(\n         Builder: &DIBuilder<'a>,\n         Name: *const c_char,"}, {"sha": "c323372bda42d98206a4a7c1c74d9c12c95cafe3", "filename": "compiler/rustc_codegen_ssa/src/back/write.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/905d5a38d69328385ce9963c65c385734c60322d/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/905d5a38d69328385ce9963c65c385734c60322d/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs?ref=905d5a38d69328385ce9963c65c385734c60322d", "patch": "@@ -1821,9 +1821,15 @@ impl SharedEmitterMain {\n                         let source = sess\n                             .source_map()\n                             .new_source_file(FileName::inline_asm_source_code(&buffer), buffer);\n-                        let source_span = Span::with_root_ctxt(source.start_pos, source.end_pos);\n-                        let spans: Vec<_> =\n-                            spans.iter().map(|sp| source_span.from_inner(*sp)).collect();\n+                        let spans: Vec<_> = spans\n+                            .iter()\n+                            .map(|sp| {\n+                                Span::with_root_ctxt(\n+                                    source.normalized_byte_pos(sp.start as u32),\n+                                    source.normalized_byte_pos(sp.end as u32),\n+                                )\n+                            })\n+                            .collect();\n                         err.span_note(spans, \"instantiated into assembly here\");\n                     }\n "}, {"sha": "405f3d5b66d423c224c4e0e48e2bd1b9c8fc9ee6", "filename": "compiler/rustc_driver_impl/src/lib.rs", "status": "modified", "additions": 57, "deletions": 46, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/905d5a38d69328385ce9963c65c385734c60322d/compiler%2Frustc_driver_impl%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/905d5a38d69328385ce9963c65c385734c60322d/compiler%2Frustc_driver_impl%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_driver_impl%2Fsrc%2Flib.rs?ref=905d5a38d69328385ce9963c65c385734c60322d", "patch": "@@ -25,7 +25,7 @@ use rustc_data_structures::profiling::{\n use rustc_data_structures::sync::SeqCst;\n use rustc_errors::registry::{InvalidErrorCode, Registry};\n use rustc_errors::{\n-    DiagnosticMessage, ErrorGuaranteed, PResult, SubdiagnosticMessage, TerminalUrl,\n+    DiagnosticMessage, ErrorGuaranteed, Handler, PResult, SubdiagnosticMessage, TerminalUrl,\n };\n use rustc_feature::find_gated_cfg;\n use rustc_fluent_macro::fluent_messages;\n@@ -55,7 +55,7 @@ use std::panic::{self, catch_unwind};\n use std::path::PathBuf;\n use std::process::{self, Command, Stdio};\n use std::str;\n-use std::sync::LazyLock;\n+use std::sync::OnceLock;\n use std::time::Instant;\n \n // This import blocks the use of panicking `print` and `println` in all the code\n@@ -119,7 +119,7 @@ pub const EXIT_SUCCESS: i32 = 0;\n /// Exit status code used for compilation failures and invalid flags.\n pub const EXIT_FAILURE: i32 = 1;\n \n-const BUG_REPORT_URL: &str = \"https://github.com/rust-lang/rust/issues/new\\\n+pub const DEFAULT_BUG_REPORT_URL: &str = \"https://github.com/rust-lang/rust/issues/new\\\n     ?labels=C-bug%2C+I-ICE%2C+T-compiler&template=ice.md\";\n \n const ICE_REPORT_COMPILER_FLAGS: &[&str] = &[\"-Z\", \"-C\", \"--crate-type\"];\n@@ -1196,43 +1196,66 @@ pub fn catch_with_exit_code(f: impl FnOnce() -> interface::Result<()>) -> i32 {\n     }\n }\n \n-static DEFAULT_HOOK: LazyLock<Box<dyn Fn(&panic::PanicInfo<'_>) + Sync + Send + 'static>> =\n-    LazyLock::new(|| {\n-        let hook = panic::take_hook();\n-        panic::set_hook(Box::new(|info| {\n-            // If the error was caused by a broken pipe then this is not a bug.\n-            // Write the error and return immediately. See #98700.\n-            #[cfg(windows)]\n-            if let Some(msg) = info.payload().downcast_ref::<String>() {\n-                if msg.starts_with(\"failed printing to stdout: \") && msg.ends_with(\"(os error 232)\")\n-                {\n-                    early_error_no_abort(ErrorOutputType::default(), &msg);\n-                    return;\n-                }\n-            };\n+/// Stores the default panic hook, from before [`install_ice_hook`] was called.\n+static DEFAULT_HOOK: OnceLock<Box<dyn Fn(&panic::PanicInfo<'_>) + Sync + Send + 'static>> =\n+    OnceLock::new();\n+\n+/// Installs a panic hook that will print the ICE message on unexpected panics.\n+///\n+/// The hook is intended to be useable even by external tools. You can pass a custom\n+/// `bug_report_url`, or report arbitrary info in `extra_info`. Note that `extra_info` is called in\n+/// a context where *the thread is currently panicking*, so it must not panic or the process will\n+/// abort.\n+///\n+/// If you have no extra info to report, pass the empty closure `|_| ()` as the argument to\n+/// extra_info.\n+///\n+/// A custom rustc driver can skip calling this to set up a custom ICE hook.\n+pub fn install_ice_hook(bug_report_url: &'static str, extra_info: fn(&Handler)) {\n+    // If the user has not explicitly overridden \"RUST_BACKTRACE\", then produce\n+    // full backtraces. When a compiler ICE happens, we want to gather\n+    // as much information as possible to present in the issue opened\n+    // by the user. Compiler developers and other rustc users can\n+    // opt in to less-verbose backtraces by manually setting \"RUST_BACKTRACE\"\n+    // (e.g. `RUST_BACKTRACE=1`)\n+    if std::env::var(\"RUST_BACKTRACE\").is_err() {\n+        std::env::set_var(\"RUST_BACKTRACE\", \"full\");\n+    }\n \n-            // Invoke the default handler, which prints the actual panic message and optionally a backtrace\n-            // Don't do this for delayed bugs, which already emit their own more useful backtrace.\n-            if !info.payload().is::<rustc_errors::DelayedBugPanic>() {\n-                (*DEFAULT_HOOK)(info);\n+    let default_hook = DEFAULT_HOOK.get_or_init(panic::take_hook);\n \n-                // Separate the output with an empty line\n-                eprintln!();\n+    panic::set_hook(Box::new(move |info| {\n+        // If the error was caused by a broken pipe then this is not a bug.\n+        // Write the error and return immediately. See #98700.\n+        #[cfg(windows)]\n+        if let Some(msg) = info.payload().downcast_ref::<String>() {\n+            if msg.starts_with(\"failed printing to stdout: \") && msg.ends_with(\"(os error 232)\") {\n+                early_error_no_abort(ErrorOutputType::default(), &msg);\n+                return;\n             }\n+        };\n \n-            // Print the ICE message\n-            report_ice(info, BUG_REPORT_URL);\n-        }));\n-        hook\n-    });\n+        // Invoke the default handler, which prints the actual panic message and optionally a backtrace\n+        // Don't do this for delayed bugs, which already emit their own more useful backtrace.\n+        if !info.payload().is::<rustc_errors::DelayedBugPanic>() {\n+            (*default_hook)(info);\n+\n+            // Separate the output with an empty line\n+            eprintln!();\n+        }\n+\n+        // Print the ICE message\n+        report_ice(info, bug_report_url, extra_info);\n+    }));\n+}\n \n /// Prints the ICE message, including query stack, but without backtrace.\n ///\n /// The message will point the user at `bug_report_url` to report the ICE.\n ///\n /// When `install_ice_hook` is called, this function will be called as the panic\n /// hook.\n-pub fn report_ice(info: &panic::PanicInfo<'_>, bug_report_url: &str) {\n+pub fn report_ice(info: &panic::PanicInfo<'_>, bug_report_url: &str, extra_info: fn(&Handler)) {\n     let fallback_bundle =\n         rustc_errors::fallback_fluent_bundle(crate::DEFAULT_LOCALE_RESOURCES.to_vec(), false);\n     let emitter = Box::new(rustc_errors::emitter::EmitterWriter::stderr(\n@@ -1277,29 +1300,17 @@ pub fn report_ice(info: &panic::PanicInfo<'_>, bug_report_url: &str) {\n \n     interface::try_print_query_stack(&handler, num_frames);\n \n+    // We don't trust this callback not to panic itself, so run it at the end after we're sure we've\n+    // printed all the relevant info.\n+    extra_info(&handler);\n+\n     #[cfg(windows)]\n     if env::var(\"RUSTC_BREAK_ON_ICE\").is_ok() {\n         // Trigger a debugger if we crashed during bootstrap\n         unsafe { windows::Win32::System::Diagnostics::Debug::DebugBreak() };\n     }\n }\n \n-/// Installs a panic hook that will print the ICE message on unexpected panics.\n-///\n-/// A custom rustc driver can skip calling this to set up a custom ICE hook.\n-pub fn install_ice_hook() {\n-    // If the user has not explicitly overridden \"RUST_BACKTRACE\", then produce\n-    // full backtraces. When a compiler ICE happens, we want to gather\n-    // as much information as possible to present in the issue opened\n-    // by the user. Compiler developers and other rustc users can\n-    // opt in to less-verbose backtraces by manually setting \"RUST_BACKTRACE\"\n-    // (e.g. `RUST_BACKTRACE=1`)\n-    if std::env::var(\"RUST_BACKTRACE\").is_err() {\n-        std::env::set_var(\"RUST_BACKTRACE\", \"full\");\n-    }\n-    LazyLock::force(&DEFAULT_HOOK);\n-}\n-\n /// This allows tools to enable rust logging without having to magically match rustc's\n /// tracing crate version.\n pub fn init_rustc_env_logger() {\n@@ -1370,7 +1381,7 @@ pub fn main() -> ! {\n     init_rustc_env_logger();\n     signal_handler::install();\n     let mut callbacks = TimePassesCallbacks::default();\n-    install_ice_hook();\n+    install_ice_hook(DEFAULT_BUG_REPORT_URL, |_| ());\n     let exit_code = catch_with_exit_code(|| {\n         let args = env::args_os()\n             .enumerate()"}, {"sha": "5ba1ca1c807bce908450ca87d5c4b7d87ddc1e0e", "filename": "compiler/rustc_hir_analysis/src/check/dropck.rs", "status": "modified", "additions": 91, "deletions": 233, "changes": 324, "blob_url": "https://github.com/rust-lang/rust/blob/905d5a38d69328385ce9963c65c385734c60322d/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/905d5a38d69328385ce9963c65c385734c60322d/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fdropck.rs?ref=905d5a38d69328385ce9963c65c385734c60322d", "patch": "@@ -1,12 +1,14 @@\n // FIXME(@lcnr): Move this module out of `rustc_hir_analysis`.\n //\n // We don't do any drop checking during hir typeck.\n+use rustc_data_structures::fx::FxHashSet;\n use rustc_errors::{struct_span_err, ErrorGuaranteed};\n-use rustc_middle::ty::error::TypeError;\n-use rustc_middle::ty::relate::{Relate, RelateResult, TypeRelation};\n+use rustc_infer::infer::outlives::env::OutlivesEnvironment;\n+use rustc_infer::infer::{RegionResolutionError, TyCtxtInferExt};\n use rustc_middle::ty::subst::SubstsRef;\n use rustc_middle::ty::util::IgnoreRegions;\n-use rustc_middle::ty::{self, Predicate, Ty, TyCtxt};\n+use rustc_middle::ty::{self, TyCtxt};\n+use rustc_trait_selection::traits::{self, ObligationCtxt};\n \n use crate::errors;\n use crate::hir::def_id::{DefId, LocalDefId};\n@@ -43,21 +45,20 @@ pub fn check_drop_impl(tcx: TyCtxt<'_>, drop_impl_did: DefId) -> Result<(), Erro\n         }\n     }\n     let dtor_self_type = tcx.type_of(drop_impl_did).subst_identity();\n-    let dtor_predicates = tcx.predicates_of(drop_impl_did);\n     match dtor_self_type.kind() {\n-        ty::Adt(adt_def, self_to_impl_substs) => {\n+        ty::Adt(adt_def, adt_to_impl_substs) => {\n             ensure_drop_params_and_item_params_correspond(\n                 tcx,\n                 drop_impl_did.expect_local(),\n                 adt_def.did(),\n-                self_to_impl_substs,\n+                adt_to_impl_substs,\n             )?;\n \n             ensure_drop_predicates_are_implied_by_item_defn(\n                 tcx,\n-                dtor_predicates,\n+                drop_impl_did.expect_local(),\n                 adt_def.did().expect_local(),\n-                self_to_impl_substs,\n+                adt_to_impl_substs,\n             )\n         }\n         _ => {\n@@ -78,9 +79,9 @@ fn ensure_drop_params_and_item_params_correspond<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     drop_impl_did: LocalDefId,\n     self_type_did: DefId,\n-    drop_impl_substs: SubstsRef<'tcx>,\n+    adt_to_impl_substs: SubstsRef<'tcx>,\n ) -> Result<(), ErrorGuaranteed> {\n-    let Err(arg) = tcx.uses_unique_generic_params(drop_impl_substs, IgnoreRegions::No) else {\n+    let Err(arg) = tcx.uses_unique_generic_params(adt_to_impl_substs, IgnoreRegions::No) else {\n         return Ok(())\n     };\n \n@@ -111,237 +112,94 @@ fn ensure_drop_params_and_item_params_correspond<'tcx>(\n /// implied by assuming the predicates attached to self_type_did.\n fn ensure_drop_predicates_are_implied_by_item_defn<'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    dtor_predicates: ty::GenericPredicates<'tcx>,\n-    self_type_did: LocalDefId,\n-    self_to_impl_substs: SubstsRef<'tcx>,\n+    drop_impl_def_id: LocalDefId,\n+    adt_def_id: LocalDefId,\n+    adt_to_impl_substs: SubstsRef<'tcx>,\n ) -> Result<(), ErrorGuaranteed> {\n-    let mut result = Ok(());\n-\n-    // Here is an example, analogous to that from\n-    // `compare_impl_method`.\n-    //\n-    // Consider a struct type:\n-    //\n-    //     struct Type<'c, 'b:'c, 'a> {\n-    //         x: &'a Contents            // (contents are irrelevant;\n-    //         y: &'c Cell<&'b Contents>, //  only the bounds matter for our purposes.)\n-    //     }\n-    //\n-    // and a Drop impl:\n-    //\n-    //     impl<'z, 'y:'z, 'x:'y> Drop for P<'z, 'y, 'x> {\n-    //         fn drop(&mut self) { self.y.set(self.x); } // (only legal if 'x: 'y)\n-    //     }\n-    //\n-    // We start out with self_to_impl_substs, that maps the generic\n-    // parameters of Type to that of the Drop impl.\n+    let infcx = tcx.infer_ctxt().build();\n+    let ocx = ObligationCtxt::new(&infcx);\n+\n+    // Take the param-env of the adt and substitute the substs that show up in\n+    // the implementation's self type. This gives us the assumptions that the\n+    // self ty of the implementation is allowed to know just from it being a\n+    // well-formed adt, since that's all we're allowed to assume while proving\n+    // the Drop implementation is not specialized.\n     //\n-    //     self_to_impl_substs = {'c => 'z, 'b => 'y, 'a => 'x}\n-    //\n-    // Applying this to the predicates (i.e., assumptions) provided by the item\n-    // definition yields the instantiated assumptions:\n-    //\n-    //     ['y : 'z]\n-    //\n-    // We then check all of the predicates of the Drop impl:\n-    //\n-    //     ['y:'z, 'x:'y]\n-    //\n-    // and ensure each is in the list of instantiated\n-    // assumptions. Here, `'y:'z` is present, but `'x:'y` is\n-    // absent. So we report an error that the Drop impl injected a\n-    // predicate that is not present on the struct definition.\n-\n-    // We can assume the predicates attached to struct/enum definition\n-    // hold.\n-    let generic_assumptions = tcx.predicates_of(self_type_did);\n-\n-    let assumptions_in_impl_context = generic_assumptions.instantiate(tcx, &self_to_impl_substs);\n-    let assumptions_in_impl_context = assumptions_in_impl_context.predicates;\n-\n-    debug!(?assumptions_in_impl_context, ?dtor_predicates.predicates);\n-\n-    let self_param_env = tcx.param_env(self_type_did);\n-\n-    // An earlier version of this code attempted to do this checking\n-    // via the traits::fulfill machinery. However, it ran into trouble\n-    // since the fulfill machinery merely turns outlives-predicates\n-    // 'a:'b and T:'b into region inference constraints. It is simpler\n-    // just to look for all the predicates directly.\n-\n-    assert_eq!(dtor_predicates.parent, None);\n-    for &(predicate, predicate_sp) in dtor_predicates.predicates {\n-        // (We do not need to worry about deep analysis of type\n-        // expressions etc because the Drop impls are already forced\n-        // to take on a structure that is roughly an alpha-renaming of\n-        // the generic parameters of the item definition.)\n-\n-        // This path now just checks *all* predicates via an instantiation of\n-        // the `SimpleEqRelation`, which simply forwards to the `relate` machinery\n-        // after taking care of anonymizing late bound regions.\n-        //\n-        // However, it may be more efficient in the future to batch\n-        // the analysis together via the fulfill (see comment above regarding\n-        // the usage of the fulfill machinery), rather than the\n-        // repeated `.iter().any(..)` calls.\n+    // We don't need to normalize this param-env or anything, since we're only\n+    // substituting it with free params, so no additional param-env normalization\n+    // can occur on top of what has been done in the param_env query itself.\n+    let param_env = ty::EarlyBinder(tcx.param_env(adt_def_id))\n+        .subst(tcx, adt_to_impl_substs)\n+        .with_constness(tcx.constness(drop_impl_def_id));\n+\n+    for (pred, span) in tcx.predicates_of(drop_impl_def_id).instantiate_identity(tcx) {\n+        let normalize_cause = traits::ObligationCause::misc(span, adt_def_id);\n+        let pred = ocx.normalize(&normalize_cause, param_env, pred);\n+        let cause = traits::ObligationCause::new(span, adt_def_id, traits::DropImpl);\n+        ocx.register_obligation(traits::Obligation::new(tcx, cause, param_env, pred));\n+    }\n \n-        // This closure is a more robust way to check `Predicate` equality\n-        // than simple `==` checks (which were the previous implementation).\n-        // It relies on `ty::relate` for `TraitPredicate`, `ProjectionPredicate`,\n-        // `ConstEvaluatable` and `TypeOutlives` (which implement the Relate trait),\n-        // while delegating on simple equality for the other `Predicate`.\n-        // This implementation solves (Issue #59497) and (Issue #58311).\n-        // It is unclear to me at the moment whether the approach based on `relate`\n-        // could be extended easily also to the other `Predicate`.\n-        let predicate_matches_closure = |p: Predicate<'tcx>| {\n-            let mut relator: SimpleEqRelation<'tcx> = SimpleEqRelation::new(tcx, self_param_env);\n-            let predicate = predicate.kind();\n-            let p = p.kind();\n-            match (predicate.skip_binder(), p.skip_binder()) {\n-                (\n-                    ty::PredicateKind::Clause(ty::Clause::Trait(a)),\n-                    ty::PredicateKind::Clause(ty::Clause::Trait(b)),\n-                ) => relator.relate(predicate.rebind(a), p.rebind(b)).is_ok(),\n-                (\n-                    ty::PredicateKind::Clause(ty::Clause::Projection(a)),\n-                    ty::PredicateKind::Clause(ty::Clause::Projection(b)),\n-                ) => relator.relate(predicate.rebind(a), p.rebind(b)).is_ok(),\n-                (\n-                    ty::PredicateKind::ConstEvaluatable(a),\n-                    ty::PredicateKind::ConstEvaluatable(b),\n-                ) => relator.relate(predicate.rebind(a), predicate.rebind(b)).is_ok(),\n-                (\n-                    ty::PredicateKind::Clause(ty::Clause::TypeOutlives(ty::OutlivesPredicate(\n-                        ty_a,\n-                        lt_a,\n-                    ))),\n-                    ty::PredicateKind::Clause(ty::Clause::TypeOutlives(ty::OutlivesPredicate(\n-                        ty_b,\n-                        lt_b,\n-                    ))),\n-                ) => {\n-                    relator.relate(predicate.rebind(ty_a), p.rebind(ty_b)).is_ok()\n-                        && relator.relate(predicate.rebind(lt_a), p.rebind(lt_b)).is_ok()\n-                }\n-                (ty::PredicateKind::WellFormed(arg_a), ty::PredicateKind::WellFormed(arg_b)) => {\n-                    relator.relate(predicate.rebind(arg_a), p.rebind(arg_b)).is_ok()\n-                }\n-                _ => predicate == p,\n+    // All of the custom error reporting logic is to preserve parity with the old\n+    // error messages.\n+    //\n+    // They can probably get removed with better treatment of the new `DropImpl`\n+    // obligation cause code, and perhaps some custom logic in `report_region_errors`.\n+\n+    let errors = ocx.select_all_or_error();\n+    if !errors.is_empty() {\n+        let mut guar = None;\n+        let mut root_predicates = FxHashSet::default();\n+        for error in errors {\n+            let root_predicate = error.root_obligation.predicate;\n+            if root_predicates.insert(root_predicate) {\n+                let item_span = tcx.def_span(adt_def_id);\n+                let self_descr = tcx.def_descr(adt_def_id.to_def_id());\n+                guar = Some(\n+                    struct_span_err!(\n+                        tcx.sess,\n+                        error.root_obligation.cause.span,\n+                        E0367,\n+                        \"`Drop` impl requires `{root_predicate}` \\\n+                        but the {self_descr} it is implemented for does not\",\n+                    )\n+                    .span_note(item_span, \"the implementor must specify the same requirement\")\n+                    .emit(),\n+                );\n             }\n-        };\n-\n-        if !assumptions_in_impl_context.iter().copied().any(predicate_matches_closure) {\n-            let item_span = tcx.def_span(self_type_did);\n-            let self_descr = tcx.def_descr(self_type_did.to_def_id());\n-            let reported = struct_span_err!(\n-                tcx.sess,\n-                predicate_sp,\n-                E0367,\n-                \"`Drop` impl requires `{predicate}` but the {self_descr} it is implemented for does not\",\n-            )\n-            .span_note(item_span, \"the implementor must specify the same requirement\")\n-            .emit();\n-            result = Err(reported);\n         }\n+        return Err(guar.unwrap());\n     }\n \n-    result\n-}\n-\n-/// This is an implementation of the [`TypeRelation`] trait with the\n-/// aim of simply comparing for equality (without side-effects).\n-///\n-/// It is not intended to be used anywhere else other than here.\n-pub(crate) struct SimpleEqRelation<'tcx> {\n-    tcx: TyCtxt<'tcx>,\n-    param_env: ty::ParamEnv<'tcx>,\n-}\n-\n-impl<'tcx> SimpleEqRelation<'tcx> {\n-    fn new(tcx: TyCtxt<'tcx>, param_env: ty::ParamEnv<'tcx>) -> SimpleEqRelation<'tcx> {\n-        SimpleEqRelation { tcx, param_env }\n-    }\n-}\n-\n-impl<'tcx> TypeRelation<'tcx> for SimpleEqRelation<'tcx> {\n-    fn tcx(&self) -> TyCtxt<'tcx> {\n-        self.tcx\n-    }\n-\n-    fn param_env(&self) -> ty::ParamEnv<'tcx> {\n-        self.param_env\n-    }\n-\n-    fn tag(&self) -> &'static str {\n-        \"dropck::SimpleEqRelation\"\n-    }\n-\n-    fn a_is_expected(&self) -> bool {\n-        true\n-    }\n-\n-    fn relate_with_variance<T: Relate<'tcx>>(\n-        &mut self,\n-        _: ty::Variance,\n-        _info: ty::VarianceDiagInfo<'tcx>,\n-        a: T,\n-        b: T,\n-    ) -> RelateResult<'tcx, T> {\n-        // Here we ignore variance because we require drop impl's types\n-        // to be *exactly* the same as to the ones in the struct definition.\n-        self.relate(a, b)\n-    }\n-\n-    fn tys(&mut self, a: Ty<'tcx>, b: Ty<'tcx>) -> RelateResult<'tcx, Ty<'tcx>> {\n-        debug!(\"SimpleEqRelation::tys(a={:?}, b={:?})\", a, b);\n-        ty::relate::super_relate_tys(self, a, b)\n-    }\n-\n-    fn regions(\n-        &mut self,\n-        a: ty::Region<'tcx>,\n-        b: ty::Region<'tcx>,\n-    ) -> RelateResult<'tcx, ty::Region<'tcx>> {\n-        debug!(\"SimpleEqRelation::regions(a={:?}, b={:?})\", a, b);\n-\n-        // We can just equate the regions because LBRs have been\n-        // already anonymized.\n-        if a == b {\n-            Ok(a)\n-        } else {\n-            // I'm not sure is this `TypeError` is the right one, but\n-            // it should not matter as it won't be checked (the dropck\n-            // will emit its own, more informative and higher-level errors\n-            // in case anything goes wrong).\n-            Err(TypeError::RegionsPlaceholderMismatch)\n+    let errors = ocx.infcx.resolve_regions(&OutlivesEnvironment::new(param_env));\n+    if !errors.is_empty() {\n+        let mut guar = None;\n+        for error in errors {\n+            let item_span = tcx.def_span(adt_def_id);\n+            let self_descr = tcx.def_descr(adt_def_id.to_def_id());\n+            let outlives = match error {\n+                RegionResolutionError::ConcreteFailure(_, a, b) => format!(\"{b}: {a}\"),\n+                RegionResolutionError::GenericBoundFailure(_, generic, r) => {\n+                    format!(\"{generic}: {r}\")\n+                }\n+                RegionResolutionError::SubSupConflict(_, _, _, a, _, b, _) => format!(\"{b}: {a}\"),\n+                RegionResolutionError::UpperBoundUniverseConflict(a, _, _, _, b) => {\n+                    format!(\"{b}: {a}\", a = tcx.mk_re_var(a))\n+                }\n+            };\n+            guar = Some(\n+                struct_span_err!(\n+                    tcx.sess,\n+                    error.origin().span(),\n+                    E0367,\n+                    \"`Drop` impl requires `{outlives}` \\\n+                    but the {self_descr} it is implemented for does not\",\n+                )\n+                .span_note(item_span, \"the implementor must specify the same requirement\")\n+                .emit(),\n+            );\n         }\n+        return Err(guar.unwrap());\n     }\n \n-    fn consts(\n-        &mut self,\n-        a: ty::Const<'tcx>,\n-        b: ty::Const<'tcx>,\n-    ) -> RelateResult<'tcx, ty::Const<'tcx>> {\n-        debug!(\"SimpleEqRelation::consts(a={:?}, b={:?})\", a, b);\n-        ty::relate::super_relate_consts(self, a, b)\n-    }\n-\n-    fn binders<T>(\n-        &mut self,\n-        a: ty::Binder<'tcx, T>,\n-        b: ty::Binder<'tcx, T>,\n-    ) -> RelateResult<'tcx, ty::Binder<'tcx, T>>\n-    where\n-        T: Relate<'tcx>,\n-    {\n-        debug!(\"SimpleEqRelation::binders({:?}: {:?}\", a, b);\n-\n-        // Anonymizing the LBRs is necessary to solve (Issue #59497).\n-        // After we do so, it should be totally fine to skip the binders.\n-        let anon_a = self.tcx.anonymize_bound_vars(a);\n-        let anon_b = self.tcx.anonymize_bound_vars(b);\n-        self.relate(anon_a.skip_binder(), anon_b.skip_binder())?;\n-\n-        Ok(a)\n-    }\n+    Ok(())\n }"}, {"sha": "8482ae2aa38c81f7645036c9d044aac9513ac020", "filename": "compiler/rustc_infer/src/infer/lexical_region_resolve/mod.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/905d5a38d69328385ce9963c65c385734c60322d/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/905d5a38d69328385ce9963c65c385734c60322d/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flexical_region_resolve%2Fmod.rs?ref=905d5a38d69328385ce9963c65c385734c60322d", "patch": "@@ -102,6 +102,17 @@ pub enum RegionResolutionError<'tcx> {\n     ),\n }\n \n+impl<'tcx> RegionResolutionError<'tcx> {\n+    pub fn origin(&self) -> &SubregionOrigin<'tcx> {\n+        match self {\n+            RegionResolutionError::ConcreteFailure(origin, _, _)\n+            | RegionResolutionError::GenericBoundFailure(origin, _, _)\n+            | RegionResolutionError::SubSupConflict(_, _, origin, _, _, _, _)\n+            | RegionResolutionError::UpperBoundUniverseConflict(_, _, _, origin, _) => origin,\n+        }\n+    }\n+}\n+\n struct RegionAndOrigin<'tcx> {\n     region: Region<'tcx>,\n     origin: SubregionOrigin<'tcx>,"}, {"sha": "49acd71b3e106a9d8d4604def4782cdba908dd06", "filename": "compiler/rustc_llvm/llvm-wrapper/RustWrapper.cpp", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/905d5a38d69328385ce9963c65c385734c60322d/compiler%2Frustc_llvm%2Fllvm-wrapper%2FRustWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/905d5a38d69328385ce9963c65c385734c60322d/compiler%2Frustc_llvm%2Fllvm-wrapper%2FRustWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_llvm%2Fllvm-wrapper%2FRustWrapper.cpp?ref=905d5a38d69328385ce9963c65c385734c60322d", "patch": "@@ -831,6 +831,28 @@ extern \"C\" LLVMMetadataRef LLVMRustDIBuilderCreateFunction(\n   return wrap(Sub);\n }\n \n+extern \"C\" LLVMMetadataRef LLVMRustDIBuilderCreateMethod(\n+    LLVMRustDIBuilderRef Builder, LLVMMetadataRef Scope,\n+    const char *Name, size_t NameLen,\n+    const char *LinkageName, size_t LinkageNameLen,\n+    LLVMMetadataRef File, unsigned LineNo,\n+    LLVMMetadataRef Ty, LLVMRustDIFlags Flags,\n+    LLVMRustDISPFlags SPFlags, LLVMMetadataRef TParam) {\n+  DITemplateParameterArray TParams =\n+      DITemplateParameterArray(unwrap<MDTuple>(TParam));\n+  DISubprogram::DISPFlags llvmSPFlags = fromRust(SPFlags);\n+  DINode::DIFlags llvmFlags = fromRust(Flags);\n+  DISubprogram *Sub = Builder->createMethod(\n+      unwrapDI<DIScope>(Scope),\n+      StringRef(Name, NameLen),\n+      StringRef(LinkageName, LinkageNameLen),\n+      unwrapDI<DIFile>(File), LineNo,\n+      unwrapDI<DISubroutineType>(Ty),\n+      0, 0, nullptr, // VTable params aren't used\n+      llvmFlags, llvmSPFlags, TParams);\n+  return wrap(Sub);\n+}\n+\n extern \"C\" LLVMMetadataRef LLVMRustDIBuilderCreateBasicType(\n     LLVMRustDIBuilderRef Builder, const char *Name, size_t NameLen,\n     uint64_t SizeInBits, unsigned Encoding) {"}, {"sha": "8366567c2c3649c15ebaf372f145ee53631bcac9", "filename": "compiler/rustc_middle/src/traits/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/905d5a38d69328385ce9963c65c385734c60322d/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/905d5a38d69328385ce9963c65c385734c60322d/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs?ref=905d5a38d69328385ce9963c65c385734c60322d", "patch": "@@ -444,6 +444,10 @@ pub enum ObligationCauseCode<'tcx> {\n     AscribeUserTypeProvePredicate(Span),\n \n     RustCall,\n+\n+    /// Obligations to prove that a `std::ops::Drop` impl is not stronger than\n+    /// the ADT it's being implemented for.\n+    DropImpl,\n }\n \n /// The 'location' at which we try to perform HIR-based wf checking."}, {"sha": "6c8f4af7594349904aa07aae527ecc493b44adab", "filename": "compiler/rustc_middle/src/ty/instance.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/905d5a38d69328385ce9963c65c385734c60322d/compiler%2Frustc_middle%2Fsrc%2Fty%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/905d5a38d69328385ce9963c65c385734c60322d/compiler%2Frustc_middle%2Fsrc%2Fty%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Finstance.rs?ref=905d5a38d69328385ce9963c65c385734c60322d", "patch": "@@ -385,7 +385,7 @@ impl<'tcx> Instance<'tcx> {\n     /// couldn't complete due to errors elsewhere - this is distinct\n     /// from `Ok(None)` to avoid misleading diagnostics when an error\n     /// has already been/will be emitted, for the original cause\n-    #[instrument(level = \"debug\", skip(tcx))]\n+    #[instrument(level = \"debug\", skip(tcx), ret)]\n     pub fn resolve(\n         tcx: TyCtxt<'tcx>,\n         param_env: ty::ParamEnv<'tcx>,"}, {"sha": "018eddea4b06b96f25eef8e0da21859eef5257e4", "filename": "compiler/rustc_parse/src/parser/expr.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/905d5a38d69328385ce9963c65c385734c60322d/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/905d5a38d69328385ce9963c65c385734c60322d/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs?ref=905d5a38d69328385ce9963c65c385734c60322d", "patch": "@@ -1448,8 +1448,19 @@ impl<'a> Parser<'a> {\n     }\n \n     fn parse_expr_path_start(&mut self) -> PResult<'a, P<Expr>> {\n+        let maybe_eq_tok = self.prev_token.clone();\n         let (qself, path) = if self.eat_lt() {\n-            let (qself, path) = self.parse_qpath(PathStyle::Expr)?;\n+            let lt_span = self.prev_token.span;\n+            let (qself, path) = self.parse_qpath(PathStyle::Expr).map_err(|mut err| {\n+                // Suggests using '<=' if there is an error parsing qpath when the previous token\n+                // is an '=' token. Only emits suggestion if the '<' token and '=' token are\n+                // directly adjacent (i.e. '=<')\n+                if maybe_eq_tok.kind == TokenKind::Eq && maybe_eq_tok.span.hi() == lt_span.lo() {\n+                    let eq_lt = maybe_eq_tok.span.to(lt_span);\n+                    err.span_suggestion(eq_lt, \"did you mean\", \"<=\", Applicability::Unspecified);\n+                }\n+                err\n+            })?;\n             (Some(qself), path)\n         } else {\n             (None, self.parse_path(PathStyle::Expr)?)"}, {"sha": "80360a3c73f8dcfddbff2b5ab5c324f9f0c0662f", "filename": "compiler/rustc_smir/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/905d5a38d69328385ce9963c65c385734c60322d/compiler%2Frustc_smir%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/905d5a38d69328385ce9963c65c385734c60322d/compiler%2Frustc_smir%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_smir%2FCargo.toml?ref=905d5a38d69328385ce9963c65c385734c60322d", "patch": "@@ -4,6 +4,7 @@ version = \"0.0.0\"\n edition = \"2021\"\n \n [dependencies]\n+rustc_hir = { path = \"../rustc_hir\" }\n rustc_middle = { path = \"../rustc_middle\", optional = true }\n rustc_span = { path = \"../rustc_span\", optional = true }\n tracing = \"0.1\""}, {"sha": "241cd182059ba2d0a54719714076c8a37d9be933", "filename": "compiler/rustc_smir/src/rustc_smir/mod.rs", "status": "modified", "additions": 117, "deletions": 9, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/905d5a38d69328385ce9963c65c385734c60322d/compiler%2Frustc_smir%2Fsrc%2Frustc_smir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/905d5a38d69328385ce9963c65c385734c60322d/compiler%2Frustc_smir%2Fsrc%2Frustc_smir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_smir%2Fsrc%2Frustc_smir%2Fmod.rs?ref=905d5a38d69328385ce9963c65c385734c60322d", "patch": "@@ -93,20 +93,26 @@ fn rustc_statement_to_statement(\n     }\n }\n \n-fn rustc_rvalue_to_rvalue(rvalue: &rustc_middle::mir::Rvalue<'_>) -> stable_mir::mir::Operand {\n+fn rustc_rvalue_to_rvalue(rvalue: &rustc_middle::mir::Rvalue<'_>) -> stable_mir::mir::Rvalue {\n     use rustc_middle::mir::Rvalue::*;\n     match rvalue {\n-        Use(op) => rustc_op_to_op(op),\n+        Use(op) => stable_mir::mir::Rvalue::Use(rustc_op_to_op(op)),\n         Repeat(_, _) => todo!(),\n         Ref(_, _, _) => todo!(),\n         ThreadLocalRef(_) => todo!(),\n         AddressOf(_, _) => todo!(),\n         Len(_) => todo!(),\n         Cast(_, _, _) => todo!(),\n         BinaryOp(_, _) => todo!(),\n-        CheckedBinaryOp(_, _) => todo!(),\n+        CheckedBinaryOp(bin_op, ops) => stable_mir::mir::Rvalue::CheckedBinaryOp(\n+            rustc_bin_op_to_bin_op(bin_op),\n+            rustc_op_to_op(&ops.0),\n+            rustc_op_to_op(&ops.1),\n+        ),\n         NullaryOp(_, _) => todo!(),\n-        UnaryOp(_, _) => todo!(),\n+        UnaryOp(un_op, op) => {\n+            stable_mir::mir::Rvalue::UnaryOp(rustc_un_op_to_un_op(un_op), rustc_op_to_op(op))\n+        }\n         Discriminant(_) => todo!(),\n         Aggregate(_, _) => todo!(),\n         ShallowInitBox(_, _) => todo!(),\n@@ -124,8 +130,10 @@ fn rustc_op_to_op(op: &rustc_middle::mir::Operand<'_>) -> stable_mir::mir::Opera\n }\n \n fn rustc_place_to_place(place: &rustc_middle::mir::Place<'_>) -> stable_mir::mir::Place {\n-    assert_eq!(&place.projection[..], &[]);\n-    stable_mir::mir::Place { local: place.local.as_usize() }\n+    stable_mir::mir::Place {\n+        local: place.local.as_usize(),\n+        projection: format!(\"{:?}\", place.projection),\n+    }\n }\n \n fn rustc_unwind_to_unwind(\n@@ -140,6 +148,96 @@ fn rustc_unwind_to_unwind(\n     }\n }\n \n+fn rustc_assert_msg_to_msg<'tcx>(\n+    assert_message: &rustc_middle::mir::AssertMessage<'tcx>,\n+) -> stable_mir::mir::AssertMessage {\n+    use rustc_middle::mir::AssertKind;\n+    match assert_message {\n+        AssertKind::BoundsCheck { len, index } => stable_mir::mir::AssertMessage::BoundsCheck {\n+            len: rustc_op_to_op(len),\n+            index: rustc_op_to_op(index),\n+        },\n+        AssertKind::Overflow(bin_op, op1, op2) => stable_mir::mir::AssertMessage::Overflow(\n+            rustc_bin_op_to_bin_op(bin_op),\n+            rustc_op_to_op(op1),\n+            rustc_op_to_op(op2),\n+        ),\n+        AssertKind::OverflowNeg(op) => {\n+            stable_mir::mir::AssertMessage::OverflowNeg(rustc_op_to_op(op))\n+        }\n+        AssertKind::DivisionByZero(op) => {\n+            stable_mir::mir::AssertMessage::DivisionByZero(rustc_op_to_op(op))\n+        }\n+        AssertKind::RemainderByZero(op) => {\n+            stable_mir::mir::AssertMessage::RemainderByZero(rustc_op_to_op(op))\n+        }\n+        AssertKind::ResumedAfterReturn(generator) => {\n+            stable_mir::mir::AssertMessage::ResumedAfterReturn(rustc_generator_to_generator(\n+                generator,\n+            ))\n+        }\n+        AssertKind::ResumedAfterPanic(generator) => {\n+            stable_mir::mir::AssertMessage::ResumedAfterPanic(rustc_generator_to_generator(\n+                generator,\n+            ))\n+        }\n+        AssertKind::MisalignedPointerDereference { required, found } => {\n+            stable_mir::mir::AssertMessage::MisalignedPointerDereference {\n+                required: rustc_op_to_op(required),\n+                found: rustc_op_to_op(found),\n+            }\n+        }\n+    }\n+}\n+\n+fn rustc_bin_op_to_bin_op(bin_op: &rustc_middle::mir::BinOp) -> stable_mir::mir::BinOp {\n+    use rustc_middle::mir::BinOp;\n+    match bin_op {\n+        BinOp::Add => stable_mir::mir::BinOp::Add,\n+        BinOp::Sub => stable_mir::mir::BinOp::Sub,\n+        BinOp::Mul => stable_mir::mir::BinOp::Mul,\n+        BinOp::Div => stable_mir::mir::BinOp::Div,\n+        BinOp::Rem => stable_mir::mir::BinOp::Rem,\n+        BinOp::BitXor => stable_mir::mir::BinOp::BitXor,\n+        BinOp::BitAnd => stable_mir::mir::BinOp::BitAnd,\n+        BinOp::BitOr => stable_mir::mir::BinOp::BitOr,\n+        BinOp::Shl => stable_mir::mir::BinOp::Shl,\n+        BinOp::Shr => stable_mir::mir::BinOp::Shr,\n+        BinOp::Eq => stable_mir::mir::BinOp::Eq,\n+        BinOp::Lt => stable_mir::mir::BinOp::Lt,\n+        BinOp::Le => stable_mir::mir::BinOp::Le,\n+        BinOp::Ne => stable_mir::mir::BinOp::Ne,\n+        BinOp::Ge => stable_mir::mir::BinOp::Ge,\n+        BinOp::Gt => stable_mir::mir::BinOp::Gt,\n+        BinOp::Offset => stable_mir::mir::BinOp::Offset,\n+    }\n+}\n+\n+fn rustc_un_op_to_un_op(unary_op: &rustc_middle::mir::UnOp) -> stable_mir::mir::UnOp {\n+    use rustc_middle::mir::UnOp;\n+    match unary_op {\n+        UnOp::Not => stable_mir::mir::UnOp::Not,\n+        UnOp::Neg => stable_mir::mir::UnOp::Neg,\n+    }\n+}\n+\n+fn rustc_generator_to_generator(\n+    generator: &rustc_hir::GeneratorKind,\n+) -> stable_mir::mir::GeneratorKind {\n+    use rustc_hir::{AsyncGeneratorKind, GeneratorKind};\n+    match generator {\n+        GeneratorKind::Async(async_gen) => {\n+            let async_gen = match async_gen {\n+                AsyncGeneratorKind::Block => stable_mir::mir::AsyncGeneratorKind::Block,\n+                AsyncGeneratorKind::Closure => stable_mir::mir::AsyncGeneratorKind::Closure,\n+                AsyncGeneratorKind::Fn => stable_mir::mir::AsyncGeneratorKind::Fn,\n+            };\n+            stable_mir::mir::GeneratorKind::Async(async_gen)\n+        }\n+        GeneratorKind::Gen => stable_mir::mir::GeneratorKind::Gen,\n+    }\n+}\n+\n fn rustc_terminator_to_terminator(\n     terminator: &rustc_middle::mir::Terminator<'_>,\n ) -> stable_mir::mir::Terminator {\n@@ -162,7 +260,11 @@ fn rustc_terminator_to_terminator(\n         Terminate => Terminator::Abort,\n         Return => Terminator::Return,\n         Unreachable => Terminator::Unreachable,\n-        Drop { .. } => todo!(),\n+        Drop { place, target, unwind } => Terminator::Drop {\n+            place: rustc_place_to_place(place),\n+            target: target.as_usize(),\n+            unwind: rustc_unwind_to_unwind(unwind),\n+        },\n         Call { func, args, destination, target, unwind, from_hir_call: _, fn_span: _ } => {\n             Terminator::Call {\n                 func: rustc_op_to_op(func),\n@@ -172,9 +274,15 @@ fn rustc_terminator_to_terminator(\n                 unwind: rustc_unwind_to_unwind(unwind),\n             }\n         }\n-        Assert { .. } => todo!(),\n+        Assert { cond, expected, msg, target, unwind } => Terminator::Assert {\n+            cond: rustc_op_to_op(cond),\n+            expected: *expected,\n+            msg: rustc_assert_msg_to_msg(msg),\n+            target: target.as_usize(),\n+            unwind: rustc_unwind_to_unwind(unwind),\n+        },\n         Yield { .. } => todo!(),\n-        GeneratorDrop => todo!(),\n+        GeneratorDrop => Terminator::GeneratorDrop,\n         FalseEdge { .. } => todo!(),\n         FalseUnwind { .. } => todo!(),\n         InlineAsm { .. } => todo!(),"}, {"sha": "4baf3f1f75eac400117a02ff4f1ed657d3bd6db3", "filename": "compiler/rustc_smir/src/stable_mir/mir/body.rs", "status": "modified", "additions": 66, "deletions": 4, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/905d5a38d69328385ce9963c65c385734c60322d/compiler%2Frustc_smir%2Fsrc%2Fstable_mir%2Fmir%2Fbody.rs", "raw_url": "https://github.com/rust-lang/rust/raw/905d5a38d69328385ce9963c65c385734c60322d/compiler%2Frustc_smir%2Fsrc%2Fstable_mir%2Fmir%2Fbody.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_smir%2Fsrc%2Fstable_mir%2Fmir%2Fbody.rs?ref=905d5a38d69328385ce9963c65c385734c60322d", "patch": "@@ -26,7 +26,7 @@ pub enum Terminator {\n     Drop {\n         place: Place,\n         target: usize,\n-        unwind: Option<usize>,\n+        unwind: UnwindAction,\n     },\n     Call {\n         func: Operand,\n@@ -38,10 +38,11 @@ pub enum Terminator {\n     Assert {\n         cond: Operand,\n         expected: bool,\n-        msg: String,\n+        msg: AssertMessage,\n         target: usize,\n-        cleanup: Option<usize>,\n+        unwind: UnwindAction,\n     },\n+    GeneratorDrop,\n }\n \n #[derive(Clone, Debug)]\n@@ -52,12 +53,72 @@ pub enum UnwindAction {\n     Cleanup(usize),\n }\n \n+#[derive(Clone, Debug)]\n+pub enum AssertMessage {\n+    BoundsCheck { len: Operand, index: Operand },\n+    Overflow(BinOp, Operand, Operand),\n+    OverflowNeg(Operand),\n+    DivisionByZero(Operand),\n+    RemainderByZero(Operand),\n+    ResumedAfterReturn(GeneratorKind),\n+    ResumedAfterPanic(GeneratorKind),\n+    MisalignedPointerDereference { required: Operand, found: Operand },\n+}\n+\n+#[derive(Clone, Debug)]\n+pub enum BinOp {\n+    Add,\n+    Sub,\n+    Mul,\n+    Div,\n+    Rem,\n+    BitXor,\n+    BitAnd,\n+    BitOr,\n+    Shl,\n+    Shr,\n+    Eq,\n+    Lt,\n+    Le,\n+    Ne,\n+    Ge,\n+    Gt,\n+    Offset,\n+}\n+\n+#[derive(Clone, Debug)]\n+pub enum UnOp {\n+    Not,\n+    Neg,\n+}\n+\n+#[derive(Clone, Debug)]\n+pub enum GeneratorKind {\n+    Async(AsyncGeneratorKind),\n+    Gen,\n+}\n+\n+#[derive(Clone, Debug)]\n+pub enum AsyncGeneratorKind {\n+    Block,\n+    Closure,\n+    Fn,\n+}\n+\n #[derive(Clone, Debug)]\n pub enum Statement {\n-    Assign(Place, Operand),\n+    Assign(Place, Rvalue),\n     Nop,\n }\n \n+// FIXME this is incomplete\n+#[derive(Clone, Debug)]\n+pub enum Rvalue {\n+    Use(Operand),\n+    CheckedBinaryOp(BinOp, Operand, Operand),\n+    UnaryOp(UnOp, Operand),\n+}\n+\n #[derive(Clone, Debug)]\n pub enum Operand {\n     Copy(Place),\n@@ -68,6 +129,7 @@ pub enum Operand {\n #[derive(Clone, Debug)]\n pub struct Place {\n     pub local: usize,\n+    pub projection: String,\n }\n \n #[derive(Clone, Debug)]"}, {"sha": "7bbab34c69a383d83010232751ff14a05aabd872", "filename": "compiler/rustc_span/src/lib.rs", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/905d5a38d69328385ce9963c65c385734c60322d/compiler%2Frustc_span%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/905d5a38d69328385ce9963c65c385734c60322d/compiler%2Frustc_span%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Flib.rs?ref=905d5a38d69328385ce9963c65c385734c60322d", "patch": "@@ -1744,6 +1744,28 @@ impl SourceFile {\n         BytePos::from_u32(pos.0 - self.start_pos.0 + diff)\n     }\n \n+    /// Calculates a normalized byte position from a byte offset relative to the\n+    /// start of the file.\n+    ///\n+    /// When we get an inline assembler error from LLVM during codegen, we\n+    /// import the expanded assembly code as a new `SourceFile`, which can then\n+    /// be used for error reporting with spans. However the byte offsets given\n+    /// to us by LLVM are relative to the start of the original buffer, not the\n+    /// normalized one. Hence we need to convert those offsets to the normalized\n+    /// form when constructing spans.\n+    pub fn normalized_byte_pos(&self, offset: u32) -> BytePos {\n+        let diff = match self\n+            .normalized_pos\n+            .binary_search_by(|np| (np.pos.0 + np.diff).cmp(&(self.start_pos.0 + offset)))\n+        {\n+            Ok(i) => self.normalized_pos[i].diff,\n+            Err(i) if i == 0 => 0,\n+            Err(i) => self.normalized_pos[i - 1].diff,\n+        };\n+\n+        BytePos::from_u32(self.start_pos.0 + offset - diff)\n+    }\n+\n     /// Converts an absolute `BytePos` to a `CharPos` relative to the `SourceFile`.\n     pub fn bytepos_to_file_charpos(&self, bpos: BytePos) -> CharPos {\n         // The number of extra bytes due to multibyte chars in the `SourceFile`."}, {"sha": "b97ec6c684b493d4df3d6f702199b7acd5b80b2b", "filename": "compiler/rustc_span/src/symbol.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/905d5a38d69328385ce9963c65c385734c60322d/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/905d5a38d69328385ce9963c65c385734c60322d/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs?ref=905d5a38d69328385ce9963c65c385734c60322d", "patch": "@@ -1207,6 +1207,7 @@ symbols! {\n         require,\n         residual,\n         result,\n+        resume,\n         return_position_impl_trait_in_trait,\n         return_type_notation,\n         rhs,"}, {"sha": "53bf38c0a340fddfd5d4b7d643af6fff5e9a096f", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/905d5a38d69328385ce9963c65c385734c60322d/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/905d5a38d69328385ce9963c65c385734c60322d/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=905d5a38d69328385ce9963c65c385734c60322d", "patch": "@@ -2793,7 +2793,8 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n             | ObligationCauseCode::LetElse\n             | ObligationCauseCode::BinOp { .. }\n             | ObligationCauseCode::AscribeUserTypeProvePredicate(..)\n-            | ObligationCauseCode::RustCall => {}\n+            | ObligationCauseCode::RustCall\n+            | ObligationCauseCode::DropImpl => {}\n             ObligationCauseCode::SliceOrArrayElem => {\n                 err.note(\"slice and array elements must have `Sized` type\");\n             }"}, {"sha": "b10aaad5f2af41fdc5a5e38ce2db87c639b6c091", "filename": "compiler/rustc_ty_utils/src/instance.rs", "status": "modified", "additions": 71, "deletions": 13, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/905d5a38d69328385ce9963c65c385734c60322d/compiler%2Frustc_ty_utils%2Fsrc%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/905d5a38d69328385ce9963c65c385734c60322d/compiler%2Frustc_ty_utils%2Fsrc%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Finstance.rs?ref=905d5a38d69328385ce9963c65c385734c60322d", "patch": "@@ -177,15 +177,55 @@ fn resolve_associated_item<'tcx>(\n \n             Some(ty::Instance::new(leaf_def.item.def_id, substs))\n         }\n-        traits::ImplSource::Generator(generator_data) => Some(Instance {\n-            def: ty::InstanceDef::Item(generator_data.generator_def_id),\n-            substs: generator_data.substs,\n-        }),\n-        traits::ImplSource::Future(future_data) => Some(Instance {\n-            def: ty::InstanceDef::Item(future_data.generator_def_id),\n-            substs: future_data.substs,\n-        }),\n+        traits::ImplSource::Generator(generator_data) => {\n+            if cfg!(debug_assertions) && tcx.item_name(trait_item_id) != sym::resume {\n+                // For compiler developers who'd like to add new items to `Generator`,\n+                // you either need to generate a shim body, or perhaps return\n+                // `InstanceDef::Item` pointing to a trait default method body if\n+                // it is given a default implementation by the trait.\n+                span_bug!(\n+                    tcx.def_span(generator_data.generator_def_id),\n+                    \"no definition for `{trait_ref}::{}` for built-in generator type\",\n+                    tcx.item_name(trait_item_id)\n+                )\n+            }\n+            Some(Instance {\n+                def: ty::InstanceDef::Item(generator_data.generator_def_id),\n+                substs: generator_data.substs,\n+            })\n+        }\n+        traits::ImplSource::Future(future_data) => {\n+            if cfg!(debug_assertions) && tcx.item_name(trait_item_id) != sym::poll {\n+                // For compiler developers who'd like to add new items to `Future`,\n+                // you either need to generate a shim body, or perhaps return\n+                // `InstanceDef::Item` pointing to a trait default method body if\n+                // it is given a default implementation by the trait.\n+                span_bug!(\n+                    tcx.def_span(future_data.generator_def_id),\n+                    \"no definition for `{trait_ref}::{}` for built-in async generator type\",\n+                    tcx.item_name(trait_item_id)\n+                )\n+            }\n+            Some(Instance {\n+                def: ty::InstanceDef::Item(future_data.generator_def_id),\n+                substs: future_data.substs,\n+            })\n+        }\n         traits::ImplSource::Closure(closure_data) => {\n+            if cfg!(debug_assertions)\n+                && ![sym::call, sym::call_mut, sym::call_once]\n+                    .contains(&tcx.item_name(trait_item_id))\n+            {\n+                // For compiler developers who'd like to add new items to `Fn`/`FnMut`/`FnOnce`,\n+                // you either need to generate a shim body, or perhaps return\n+                // `InstanceDef::Item` pointing to a trait default method body if\n+                // it is given a default implementation by the trait.\n+                span_bug!(\n+                    tcx.def_span(closure_data.closure_def_id),\n+                    \"no definition for `{trait_ref}::{}` for built-in closure type\",\n+                    tcx.item_name(trait_item_id)\n+                )\n+            }\n             let trait_closure_kind = tcx.fn_trait_kind_from_def_id(trait_id).unwrap();\n             Instance::resolve_closure(\n                 tcx,\n@@ -195,11 +235,29 @@ fn resolve_associated_item<'tcx>(\n             )\n         }\n         traits::ImplSource::FnPointer(ref data) => match data.fn_ty.kind() {\n-            ty::FnDef(..) | ty::FnPtr(..) => Some(Instance {\n-                def: ty::InstanceDef::FnPtrShim(trait_item_id, data.fn_ty),\n-                substs: rcvr_substs,\n-            }),\n-            _ => None,\n+            ty::FnDef(..) | ty::FnPtr(..) => {\n+                if cfg!(debug_assertions)\n+                    && ![sym::call, sym::call_mut, sym::call_once]\n+                        .contains(&tcx.item_name(trait_item_id))\n+                {\n+                    // For compiler developers who'd like to add new items to `Fn`/`FnMut`/`FnOnce`,\n+                    // you either need to generate a shim body, or perhaps return\n+                    // `InstanceDef::Item` pointing to a trait default method body if\n+                    // it is given a default implementation by the trait.\n+                    bug!(\n+                        \"no definition for `{trait_ref}::{}` for built-in fn type\",\n+                        tcx.item_name(trait_item_id)\n+                    )\n+                }\n+                Some(Instance {\n+                    def: ty::InstanceDef::FnPtrShim(trait_item_id, data.fn_ty),\n+                    substs: rcvr_substs,\n+                })\n+            }\n+            _ => bug!(\n+                \"no built-in definition for `{trait_ref}::{}` for non-fn type\",\n+                tcx.item_name(trait_item_id)\n+            ),\n         },\n         traits::ImplSource::Object(ref data) => {\n             traits::get_vtable_index_of_object_method(tcx, data, trait_item_id).map(|index| {"}, {"sha": "b6eb450d62be5d19a8c207332176fce7e984a380", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/905d5a38d69328385ce9963c65c385734c60322d/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/905d5a38d69328385ce9963c65c385734c60322d/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=905d5a38d69328385ce9963c65c385734c60322d", "patch": "@@ -156,15 +156,19 @@ pub fn main() {\n         }\n     }\n \n-    rustc_driver::install_ice_hook();\n+    rustc_driver::install_ice_hook(\n+        \"https://github.com/rust-lang/rust/issues/new\\\n+    ?labels=C-bug%2C+I-ICE%2C+T-rustdoc&template=ice.md\",\n+        |_| (),\n+    );\n \n-    // When using CI artifacts (with `download_stage1 = true`), tracing is unconditionally built\n+    // When using CI artifacts with `download-rustc`, tracing is unconditionally built\n     // with `--features=static_max_level_info`, which disables almost all rustdoc logging. To avoid\n     // this, compile our own version of `tracing` that logs all levels.\n     // NOTE: this compiles both versions of tracing unconditionally, because\n     // - The compile time hit is not that bad, especially compared to rustdoc's incremental times, and\n-    // - Otherwise, there's no warning that logging is being ignored when `download_stage1 = true`.\n-    // NOTE: The reason this doesn't show double logging when `download_stage1 = false` and\n+    // - Otherwise, there's no warning that logging is being ignored when `download-rustc` is enabled\n+    // NOTE: The reason this doesn't show double logging when `download-rustc = false` and\n     // `debug_logging = true` is because all rustc logging goes to its version of tracing (the one\n     // in the sysroot), and all of rustdoc's logging goes to its version (the one in Cargo.toml).\n     init_logging();"}, {"sha": "59bf447a7cd0758c9961b1cc826b4d4498dc487b", "filename": "src/tools/clippy/src/driver.rs", "status": "modified", "additions": 9, "deletions": 61, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/905d5a38d69328385ce9963c65c385734c60322d/src%2Ftools%2Fclippy%2Fsrc%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/905d5a38d69328385ce9963c65c385734c60322d/src%2Ftools%2Fclippy%2Fsrc%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fsrc%2Fdriver.rs?ref=905d5a38d69328385ce9963c65c385734c60322d", "patch": "@@ -11,7 +11,6 @@\n // FIXME: switch to something more ergonomic here, once available.\n // (Currently there is no way to opt into sysroot crates without `extern crate`.)\n extern crate rustc_driver;\n-extern crate rustc_errors;\n extern crate rustc_interface;\n extern crate rustc_session;\n extern crate rustc_span;\n@@ -20,13 +19,10 @@ use rustc_interface::interface;\n use rustc_session::parse::ParseSess;\n use rustc_span::symbol::Symbol;\n \n-use std::borrow::Cow;\n use std::env;\n use std::ops::Deref;\n-use std::panic;\n use std::path::Path;\n use std::process::exit;\n-use std::sync::LazyLock;\n \n /// If a command-line option matches `find_arg`, then apply the predicate `pred` on its value. If\n /// true, then return it. The parameter is assumed to be either `--arg=value` or `--arg value`.\n@@ -198,66 +194,18 @@ You can use tool lints to allow or deny lints from your code, eg.:\n \n const BUG_REPORT_URL: &str = \"https://github.com/rust-lang/rust-clippy/issues/new\";\n \n-type PanicCallback = dyn Fn(&panic::PanicInfo<'_>) + Sync + Send + 'static;\n-static ICE_HOOK: LazyLock<Box<PanicCallback>> = LazyLock::new(|| {\n-    let hook = panic::take_hook();\n-    panic::set_hook(Box::new(|info| report_clippy_ice(info, BUG_REPORT_URL)));\n-    hook\n-});\n-\n-fn report_clippy_ice(info: &panic::PanicInfo<'_>, bug_report_url: &str) {\n-    // Invoke our ICE handler, which prints the actual panic message and optionally a backtrace\n-    (*ICE_HOOK)(info);\n-\n-    // Separate the output with an empty line\n-    eprintln!();\n-\n-    let fallback_bundle = rustc_errors::fallback_fluent_bundle(rustc_driver::DEFAULT_LOCALE_RESOURCES.to_vec(), false);\n-    let emitter = Box::new(rustc_errors::emitter::EmitterWriter::stderr(\n-        rustc_errors::ColorConfig::Auto,\n-        None,\n-        None,\n-        fallback_bundle,\n-        false,\n-        false,\n-        None,\n-        false,\n-        false,\n-        rustc_errors::TerminalUrl::No,\n-    ));\n-    let handler = rustc_errors::Handler::with_emitter(true, None, emitter);\n-\n-    // a .span_bug or .bug call has already printed what\n-    // it wants to print.\n-    if !info.payload().is::<rustc_errors::ExplicitBug>() {\n-        let mut d = rustc_errors::Diagnostic::new(rustc_errors::Level::Bug, \"unexpected panic\");\n-        handler.emit_diagnostic(&mut d);\n-    }\n-\n-    let version_info = rustc_tools_util::get_version_info!();\n-\n-    let xs: Vec<Cow<'static, str>> = vec![\n-        \"the compiler unexpectedly panicked. this is a bug.\".into(),\n-        format!(\"we would appreciate a bug report: {bug_report_url}\").into(),\n-        format!(\"Clippy version: {version_info}\").into(),\n-    ];\n-\n-    for note in &xs {\n-        handler.note_without_error(note.as_ref());\n-    }\n-\n-    // If backtraces are enabled, also print the query stack\n-    let backtrace = env::var_os(\"RUST_BACKTRACE\").map_or(false, |x| &x != \"0\");\n-\n-    let num_frames = if backtrace { None } else { Some(2) };\n-\n-    interface::try_print_query_stack(&handler, num_frames);\n-}\n-\n #[allow(clippy::too_many_lines)]\n pub fn main() {\n     rustc_driver::init_rustc_env_logger();\n-    LazyLock::force(&ICE_HOOK);\n+\n+    rustc_driver::install_ice_hook(BUG_REPORT_URL, |handler| {\n+        // FIXME: this macro calls unwrap internally but is called in a panicking context!  It's not\n+        // as simple as moving the call from the hook to main, because `install_ice_hook` doesn't\n+        // accept a generic closure.\n+        let version_info = rustc_tools_util::get_version_info!();\n+        handler.note_without_error(format!(\"Clippy version: {version_info}\"));\n+    });\n+\n     exit(rustc_driver::catch_with_exit_code(move || {\n         let mut orig_args: Vec<String> = env::args().collect();\n         let has_sysroot_arg = arg_value(&orig_args, \"--sysroot\", |_| true).is_some();"}, {"sha": "65bc004fc4a4425f833a3e34a762f9ecc42fada7", "filename": "src/tools/miri/src/bin/miri.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/905d5a38d69328385ce9963c65c385734c60322d/src%2Ftools%2Fmiri%2Fsrc%2Fbin%2Fmiri.rs", "raw_url": "https://github.com/rust-lang/rust/raw/905d5a38d69328385ce9963c65c385734c60322d/src%2Ftools%2Fmiri%2Fsrc%2Fbin%2Fmiri.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fbin%2Fmiri.rs?ref=905d5a38d69328385ce9963c65c385734c60322d", "patch": "@@ -286,11 +286,10 @@ fn main() {\n     // (`install_ice_hook` might change `RUST_BACKTRACE`.)\n     let env_snapshot = env::vars_os().collect::<Vec<_>>();\n \n-    // Earliest rustc setup.\n-    rustc_driver::install_ice_hook();\n-\n     // If the environment asks us to actually be rustc, then do that.\n     if let Some(crate_kind) = env::var_os(\"MIRI_BE_RUSTC\") {\n+        // Earliest rustc setup.\n+        rustc_driver::install_ice_hook(rustc_driver::DEFAULT_BUG_REPORT_URL, |_| ());\n         rustc_driver::init_rustc_env_logger();\n \n         let target_crate = if crate_kind == \"target\" {\n@@ -309,6 +308,9 @@ fn main() {\n         )\n     }\n \n+    // Add an ICE bug report hook.\n+    rustc_driver::install_ice_hook(\"https://github.com/rust-lang/miri/issues/new\", |_| ());\n+\n     // Init loggers the Miri way.\n     init_early_loggers();\n "}, {"sha": "47846424b06e4a139c015c25e898e76685b15e7f", "filename": "src/tools/rustfmt/src/bin/main.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/905d5a38d69328385ce9963c65c385734c60322d/src%2Ftools%2Frustfmt%2Fsrc%2Fbin%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/905d5a38d69328385ce9963c65c385734c60322d/src%2Ftools%2Frustfmt%2Fsrc%2Fbin%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fsrc%2Fbin%2Fmain.rs?ref=905d5a38d69328385ce9963c65c385734c60322d", "patch": "@@ -1,3 +1,5 @@\n+#![feature(rustc_private)]\n+\n use anyhow::{format_err, Result};\n \n use io::Error as IoError;\n@@ -19,7 +21,14 @@ use crate::rustfmt::{\n     FormatReportFormatterBuilder, Input, Session, Verbosity,\n };\n \n+const BUG_REPORT_URL: &str = \"https://github.com/rust-lang/rustfmt/issues/new?labels=bug\";\n+\n+// N.B. these crates are loaded from the sysroot, so they need extern crate.\n+extern crate rustc_driver;\n+\n fn main() {\n+    rustc_driver::install_ice_hook(BUG_REPORT_URL, |_| ());\n+\n     env_logger::Builder::from_env(\"RUSTFMT_LOG\").init();\n     let opts = make_opts();\n "}, {"sha": "3b7a99d3dbc62c8576fa582194855246a763952f", "filename": "tests/run-make/issue-109934-lto-debuginfo/Makefile", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/905d5a38d69328385ce9963c65c385734c60322d/tests%2Frun-make%2Fissue-109934-lto-debuginfo%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/905d5a38d69328385ce9963c65c385734c60322d/tests%2Frun-make%2Fissue-109934-lto-debuginfo%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-make%2Fissue-109934-lto-debuginfo%2FMakefile?ref=905d5a38d69328385ce9963c65c385734c60322d", "patch": "@@ -0,0 +1,12 @@\n+# ignore-cross-compile\n+include ../tools.mk\n+\n+# With the upgrade to LLVM 16, this was getting:\n+#\n+#   error: Cannot represent a difference across sections\n+#\n+# The error stemmed from DI function definitions under type scopes, fixed by\n+# only declaring in type scope and defining the subprogram elsewhere.\n+\n+all:\n+\t$(RUSTC) lib.rs --test -C lto=fat -C debuginfo=2 -C incremental=$(TMPDIR)/inc-fat"}, {"sha": "c405928bd18241f61e0c72c7d8e75409c2fc9be4", "filename": "tests/run-make/issue-109934-lto-debuginfo/lib.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/905d5a38d69328385ce9963c65c385734c60322d/tests%2Frun-make%2Fissue-109934-lto-debuginfo%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/905d5a38d69328385ce9963c65c385734c60322d/tests%2Frun-make%2Fissue-109934-lto-debuginfo%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-make%2Fissue-109934-lto-debuginfo%2Flib.rs?ref=905d5a38d69328385ce9963c65c385734c60322d", "patch": "@@ -0,0 +1,9 @@\n+extern crate alloc;\n+\n+#[cfg(test)]\n+mod tests {\n+    #[test]\n+    fn something_alloc() {\n+        assert_eq!(Vec::<u32>::new(), Vec::<u32>::new());\n+    }\n+}"}, {"sha": "cc066447d313b3d6dab5d2c1bfe09561231551c3", "filename": "tests/rustdoc-ui/ice-bug-report-url.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/905d5a38d69328385ce9963c65c385734c60322d/tests%2Frustdoc-ui%2Fice-bug-report-url.rs", "raw_url": "https://github.com/rust-lang/rust/raw/905d5a38d69328385ce9963c65c385734c60322d/tests%2Frustdoc-ui%2Fice-bug-report-url.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-ui%2Fice-bug-report-url.rs?ref=905d5a38d69328385ce9963c65c385734c60322d", "patch": "@@ -0,0 +1,14 @@\n+// compile-flags: -Ztreat-err-as-bug\n+// failure-status: 101\n+// error-pattern: aborting due to\n+// error-pattern: we would appreciate a bug report: https://github.com/rust-lang/rust/issues/new?labels=C-bug%2C+I-ICE%2C+T-rustdoc&template=ice.md\n+\n+// normalize-stderr-test \"note: compiler flags.*\\n\\n\" -> \"\"\n+// normalize-stderr-test \"note: rustc.*running on.*\" -> \"note: rustc {version} running on {platform}\"\n+// normalize-stderr-test \"thread.*panicked at .*, compiler.*\" -> \"thread panicked at 'aborting due to `-Z treat-err-as-bug`'\"\n+// normalize-stderr-test \"\\s*\\d{1,}: .*\\n\" -> \"\"\n+// normalize-stderr-test \"\\s at .*\\n\" -> \"\"\n+// normalize-stderr-test \".*note: Some details are omitted.*\\n\" -> \"\"\n+\n+fn wrong()\n+//~^ ERROR expected one of"}, {"sha": "cfb73a9b9193f30e21270a5967e770889e0facee", "filename": "tests/rustdoc-ui/ice-bug-report-url.stderr", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/905d5a38d69328385ce9963c65c385734c60322d/tests%2Frustdoc-ui%2Fice-bug-report-url.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/905d5a38d69328385ce9963c65c385734c60322d/tests%2Frustdoc-ui%2Fice-bug-report-url.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-ui%2Fice-bug-report-url.stderr?ref=905d5a38d69328385ce9963c65c385734c60322d", "patch": "@@ -0,0 +1,16 @@\n+error: expected one of `->`, `where`, or `{`, found `<eof>`\n+  --> $DIR/ice-bug-report-url.rs:13:10\n+   |\n+LL | fn wrong()\n+   |          ^ expected one of `->`, `where`, or `{`\n+\n+thread panicked at 'aborting due to `-Z treat-err-as-bug`'\n+stack backtrace:\n+error: the compiler unexpectedly panicked. this is a bug.\n+\n+note: we would appreciate a bug report: https://github.com/rust-lang/rust/issues/new?labels=C-bug%2C+I-ICE%2C+T-rustdoc&template=ice.md\n+\n+note: rustc {version} running on {platform}\n+\n+query stack during panic:\n+end of query stack"}, {"sha": "1454d6dde6c979402019acd911dc4ee7cfe94cab", "filename": "tests/ui-fulldeps/stable-mir/crate-info.rs", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/905d5a38d69328385ce9963c65c385734c60322d/tests%2Fui-fulldeps%2Fstable-mir%2Fcrate-info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/905d5a38d69328385ce9963c65c385734c60322d/tests%2Fui-fulldeps%2Fstable-mir%2Fcrate-info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-fulldeps%2Fstable-mir%2Fcrate-info.rs?ref=905d5a38d69328385ce9963c65c385734c60322d", "patch": "@@ -60,6 +60,24 @@ fn test_stable_mir(tcx: TyCtxt<'_>) {\n         stable_mir::mir::Terminator::Call { .. } => {}\n         other => panic!(\"{other:?}\"),\n     }\n+\n+    let drop = get_item(tcx, &items, (DefKind::Fn, \"drop\")).unwrap();\n+    let body = drop.body();\n+    assert_eq!(body.blocks.len(), 2);\n+    let block = &body.blocks[0];\n+    match &block.terminator {\n+        stable_mir::mir::Terminator::Drop { .. } => {}\n+        other => panic!(\"{other:?}\"),\n+    }\n+\n+    let assert = get_item(tcx, &items, (DefKind::Fn, \"assert\")).unwrap();\n+    let body = assert.body();\n+    assert_eq!(body.blocks.len(), 2);\n+    let block = &body.blocks[0];\n+    match &block.terminator {\n+        stable_mir::mir::Terminator::Assert { .. } => {}\n+        other => panic!(\"{other:?}\"),\n+    }\n }\n \n // Use internal API to find a function in a crate.\n@@ -131,6 +149,12 @@ fn generate_input(path: &str) -> std::io::Result<()> {\n         let x_64 = foo::bar(x);\n         let y_64 = foo::bar(y);\n         x_64.wrapping_add(y_64)\n+    }}\n+\n+    pub fn drop(_: String) {{}}\n+\n+    pub fn assert(x: i32) -> i32 {{\n+        x + 1\n     }}\"#\n     )?;\n     Ok(())"}, {"sha": "3b506c7e7ec13865f64131e738dc19204d6bbf47", "filename": "tests/ui/dropck/explicit-drop-bounds.bad1.stderr", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/905d5a38d69328385ce9963c65c385734c60322d/tests%2Fui%2Fdropck%2Fexplicit-drop-bounds.bad1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/905d5a38d69328385ce9963c65c385734c60322d/tests%2Fui%2Fdropck%2Fexplicit-drop-bounds.bad1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fdropck%2Fexplicit-drop-bounds.bad1.stderr?ref=905d5a38d69328385ce9963c65c385734c60322d", "patch": "@@ -0,0 +1,35 @@\n+error[E0277]: the trait bound `T: Copy` is not satisfied\n+  --> $DIR/explicit-drop-bounds.rs:27:18\n+   |\n+LL | impl<T> Drop for DropMe<T>\n+   |                  ^^^^^^^^^ the trait `Copy` is not implemented for `T`\n+   |\n+note: required by a bound in `DropMe`\n+  --> $DIR/explicit-drop-bounds.rs:7:18\n+   |\n+LL | struct DropMe<T: Copy>(T);\n+   |                  ^^^^ required by this bound in `DropMe`\n+help: consider further restricting type parameter `T`\n+   |\n+LL |     [T; 1]: Copy, T: std::marker::Copy // But `[T; 1]: Copy` does not imply `T: Copy`\n+   |                 ~~~~~~~~~~~~~~~~~~~~~~\n+\n+error[E0277]: the trait bound `T: Copy` is not satisfied\n+  --> $DIR/explicit-drop-bounds.rs:32:13\n+   |\n+LL |     fn drop(&mut self) {}\n+   |             ^^^^^^^^^ the trait `Copy` is not implemented for `T`\n+   |\n+note: required by a bound in `DropMe`\n+  --> $DIR/explicit-drop-bounds.rs:7:18\n+   |\n+LL | struct DropMe<T: Copy>(T);\n+   |                  ^^^^ required by this bound in `DropMe`\n+help: consider further restricting type parameter `T`\n+   |\n+LL |     [T; 1]: Copy, T: std::marker::Copy // But `[T; 1]: Copy` does not imply `T: Copy`\n+   |                 ~~~~~~~~~~~~~~~~~~~~~~\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "832af3e521a9dbfbd1cd6e94466f5ef9d6b45bfc", "filename": "tests/ui/dropck/explicit-drop-bounds.bad2.stderr", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/905d5a38d69328385ce9963c65c385734c60322d/tests%2Fui%2Fdropck%2Fexplicit-drop-bounds.bad2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/905d5a38d69328385ce9963c65c385734c60322d/tests%2Fui%2Fdropck%2Fexplicit-drop-bounds.bad2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fdropck%2Fexplicit-drop-bounds.bad2.stderr?ref=905d5a38d69328385ce9963c65c385734c60322d", "patch": "@@ -0,0 +1,35 @@\n+error[E0277]: the trait bound `T: Copy` is not satisfied\n+  --> $DIR/explicit-drop-bounds.rs:37:18\n+   |\n+LL | impl<T> Drop for DropMe<T>\n+   |                  ^^^^^^^^^ the trait `Copy` is not implemented for `T`\n+   |\n+note: required by a bound in `DropMe`\n+  --> $DIR/explicit-drop-bounds.rs:7:18\n+   |\n+LL | struct DropMe<T: Copy>(T);\n+   |                  ^^^^ required by this bound in `DropMe`\n+help: consider restricting type parameter `T`\n+   |\n+LL | impl<T: std::marker::Copy> Drop for DropMe<T>\n+   |       +++++++++++++++++++\n+\n+error[E0277]: the trait bound `T: Copy` is not satisfied\n+  --> $DIR/explicit-drop-bounds.rs:40:13\n+   |\n+LL |     fn drop(&mut self) {}\n+   |             ^^^^^^^^^ the trait `Copy` is not implemented for `T`\n+   |\n+note: required by a bound in `DropMe`\n+  --> $DIR/explicit-drop-bounds.rs:7:18\n+   |\n+LL | struct DropMe<T: Copy>(T);\n+   |                  ^^^^ required by this bound in `DropMe`\n+help: consider restricting type parameter `T`\n+   |\n+LL | impl<T: std::marker::Copy> Drop for DropMe<T>\n+   |       +++++++++++++++++++\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "ab6f33c09994e443c515b4b3e90df8683bd523ec", "filename": "tests/ui/dropck/explicit-drop-bounds.rs", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/905d5a38d69328385ce9963c65c385734c60322d/tests%2Fui%2Fdropck%2Fexplicit-drop-bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/905d5a38d69328385ce9963c65c385734c60322d/tests%2Fui%2Fdropck%2Fexplicit-drop-bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fdropck%2Fexplicit-drop-bounds.rs?ref=905d5a38d69328385ce9963c65c385734c60322d", "patch": "@@ -0,0 +1,44 @@\n+// revisions: good1 good2 bad1 bad2\n+//[good1] check-pass\n+//[good2] check-pass\n+\n+use std::ops::Drop;\n+\n+struct DropMe<T: Copy>(T);\n+\n+#[cfg(good1)]\n+impl<T> Drop for DropMe<T>\n+where\n+    T: Copy + Clone,\n+{\n+    fn drop(&mut self) {}\n+}\n+\n+#[cfg(good2)]\n+impl<T> Drop for DropMe<T>\n+where\n+    T: Copy,\n+    [T; 1]: Copy, // Trivial bound implied by `T: Copy`\n+{\n+    fn drop(&mut self) {}\n+}\n+\n+#[cfg(bad1)]\n+impl<T> Drop for DropMe<T>\n+//[bad1]~^ ERROR the trait bound `T: Copy` is not satisfied\n+where\n+    [T; 1]: Copy, // But `[T; 1]: Copy` does not imply `T: Copy`\n+{\n+    fn drop(&mut self) {}\n+    //[bad1]~^ ERROR the trait bound `T: Copy` is not satisfied\n+}\n+\n+#[cfg(bad2)]\n+impl<T> Drop for DropMe<T>\n+//[bad2]~^ ERROR the trait bound `T: Copy` is not satisfied\n+{\n+    fn drop(&mut self) {}\n+    //[bad2]~^ ERROR the trait bound `T: Copy` is not satisfied\n+}\n+\n+fn main() {}"}, {"sha": "bf6d70e7d3758d3808465894cee248400aa74887", "filename": "tests/ui/dropck/explicit-implied-outlives.bad1.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/905d5a38d69328385ce9963c65c385734c60322d/tests%2Fui%2Fdropck%2Fexplicit-implied-outlives.bad1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/905d5a38d69328385ce9963c65c385734c60322d/tests%2Fui%2Fdropck%2Fexplicit-implied-outlives.bad1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fdropck%2Fexplicit-implied-outlives.bad1.stderr?ref=905d5a38d69328385ce9963c65c385734c60322d", "patch": "@@ -0,0 +1,15 @@\n+error[E0367]: `Drop` impl requires `T: 'static` but the struct it is implemented for does not\n+  --> $DIR/explicit-implied-outlives.rs:28:8\n+   |\n+LL |     T: 'static,\n+   |        ^^^^^^^\n+   |\n+note: the implementor must specify the same requirement\n+  --> $DIR/explicit-implied-outlives.rs:7:1\n+   |\n+LL | struct DropMe<'a, T>(&'a T);\n+   | ^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0367`."}, {"sha": "27a15170bddb53490a8fcb45a6d7bcbab2623527", "filename": "tests/ui/dropck/explicit-implied-outlives.bad2.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/905d5a38d69328385ce9963c65c385734c60322d/tests%2Fui%2Fdropck%2Fexplicit-implied-outlives.bad2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/905d5a38d69328385ce9963c65c385734c60322d/tests%2Fui%2Fdropck%2Fexplicit-implied-outlives.bad2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fdropck%2Fexplicit-implied-outlives.bad2.stderr?ref=905d5a38d69328385ce9963c65c385734c60322d", "patch": "@@ -0,0 +1,15 @@\n+error[E0367]: `Drop` impl requires `'a: 'static` but the struct it is implemented for does not\n+  --> $DIR/explicit-implied-outlives.rs:37:9\n+   |\n+LL |     'a: 'static,\n+   |         ^^^^^^^\n+   |\n+note: the implementor must specify the same requirement\n+  --> $DIR/explicit-implied-outlives.rs:7:1\n+   |\n+LL | struct DropMe<'a, T>(&'a T);\n+   | ^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0367`."}, {"sha": "fa446591f3dc4e167db68ed96036d0a3f7b816a7", "filename": "tests/ui/dropck/explicit-implied-outlives.rs", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/905d5a38d69328385ce9963c65c385734c60322d/tests%2Fui%2Fdropck%2Fexplicit-implied-outlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/905d5a38d69328385ce9963c65c385734c60322d/tests%2Fui%2Fdropck%2Fexplicit-implied-outlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fdropck%2Fexplicit-implied-outlives.rs?ref=905d5a38d69328385ce9963c65c385734c60322d", "patch": "@@ -0,0 +1,43 @@\n+// revisions: good1 good2 bad1 bad2\n+//[good1] check-pass\n+//[good2] check-pass\n+\n+use std::ops::Drop;\n+\n+struct DropMe<'a, T>(&'a T);\n+\n+#[cfg(good1)]\n+impl<'a, T> Drop for DropMe<'a, T>\n+where\n+    T: 'a, // Implied by struct, explicit on impl\n+{\n+    fn drop(&mut self) {}\n+}\n+\n+#[cfg(good2)]\n+impl<'a, T> Drop for DropMe<'a, T>\n+where\n+    'static: 'a, // Trivial bound\n+{\n+    fn drop(&mut self) {}\n+}\n+\n+#[cfg(bad1)]\n+impl<'a, T> Drop for DropMe<'a, T>\n+where\n+    T: 'static,\n+    //[bad1]~^ ERROR `Drop` impl requires `T: 'static`\n+{\n+    fn drop(&mut self) {}\n+}\n+\n+#[cfg(bad2)]\n+impl<'a, T> Drop for DropMe<'a, T>\n+where\n+    'a: 'static,\n+    //[bad2]~^ ERROR `Drop` impl requires `'a: 'static`\n+{\n+    fn drop(&mut self) {}\n+}\n+\n+fn main() {}"}, {"sha": "87154e25d4091fbf2f539dc3682ba8d96c33ef53", "filename": "tests/ui/dropck/transitive-outlives-2.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/905d5a38d69328385ce9963c65c385734c60322d/tests%2Fui%2Fdropck%2Ftransitive-outlives-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/905d5a38d69328385ce9963c65c385734c60322d/tests%2Fui%2Fdropck%2Ftransitive-outlives-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fdropck%2Ftransitive-outlives-2.rs?ref=905d5a38d69328385ce9963c65c385734c60322d", "patch": "@@ -0,0 +1,18 @@\n+// check-pass\n+\n+use std::marker::PhantomData;\n+use std::ops::Drop;\n+\n+// a >= b >= c >= a implies a = b = c\n+struct DropMe<'a: 'b, 'b: 'c, 'c: 'a>(\n+    PhantomData<&'a ()>,\n+    PhantomData<&'b ()>,\n+    PhantomData<&'c ()>,\n+);\n+\n+// a >= b, a >= c, b >= a, c >= a implies a = b = c\n+impl<'a: 'b + 'c, 'b: 'a, 'c: 'a> Drop for DropMe<'a, 'b, 'c> {\n+    fn drop(&mut self) {}\n+}\n+\n+fn main() {}"}, {"sha": "da5088b27b414346ff43f3fe46a5558cd29b1639", "filename": "tests/ui/dropck/transitive-outlives.bad.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/905d5a38d69328385ce9963c65c385734c60322d/tests%2Fui%2Fdropck%2Ftransitive-outlives.bad.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/905d5a38d69328385ce9963c65c385734c60322d/tests%2Fui%2Fdropck%2Ftransitive-outlives.bad.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fdropck%2Ftransitive-outlives.bad.stderr?ref=905d5a38d69328385ce9963c65c385734c60322d", "patch": "@@ -0,0 +1,15 @@\n+error[E0367]: `Drop` impl requires `'a: 'c` but the struct it is implemented for does not\n+  --> $DIR/transitive-outlives.rs:20:9\n+   |\n+LL |     'a: 'c,\n+   |         ^^\n+   |\n+note: the implementor must specify the same requirement\n+  --> $DIR/transitive-outlives.rs:7:1\n+   |\n+LL | struct DropMe<'a, 'b: 'a, 'c: 'b>(PhantomData<&'a ()>, PhantomData<&'b ()>, PhantomData<&'c ()>);\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0367`."}, {"sha": "d071664abdeb6b07d15750585ed7aa7283494d0f", "filename": "tests/ui/dropck/transitive-outlives.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/905d5a38d69328385ce9963c65c385734c60322d/tests%2Fui%2Fdropck%2Ftransitive-outlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/905d5a38d69328385ce9963c65c385734c60322d/tests%2Fui%2Fdropck%2Ftransitive-outlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fdropck%2Ftransitive-outlives.rs?ref=905d5a38d69328385ce9963c65c385734c60322d", "patch": "@@ -0,0 +1,26 @@\n+// revisions: good bad\n+//[good] check-pass\n+\n+use std::marker::PhantomData;\n+use std::ops::Drop;\n+\n+struct DropMe<'a, 'b: 'a, 'c: 'b>(PhantomData<&'a ()>, PhantomData<&'b ()>, PhantomData<&'c ()>);\n+\n+#[cfg(good)]\n+impl<'a, 'b, 'c> Drop for DropMe<'a, 'b, 'c>\n+where\n+    'c: 'a,\n+{\n+    fn drop(&mut self) {}\n+}\n+\n+#[cfg(bad)]\n+impl<'a, 'b, 'c> Drop for DropMe<'a, 'b, 'c>\n+where\n+    'a: 'c,\n+    //[bad]~^ ERROR `Drop` impl requires `'a: 'c`\n+{\n+    fn drop(&mut self) {}\n+}\n+\n+fn main() {}"}, {"sha": "a8f5d2c354bc979799634c2eb6e078fbe5acb944", "filename": "tests/ui/dropck/trivial-impl-bounds.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/905d5a38d69328385ce9963c65c385734c60322d/tests%2Fui%2Fdropck%2Ftrivial-impl-bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/905d5a38d69328385ce9963c65c385734c60322d/tests%2Fui%2Fdropck%2Ftrivial-impl-bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fdropck%2Ftrivial-impl-bounds.rs?ref=905d5a38d69328385ce9963c65c385734c60322d", "patch": "@@ -0,0 +1,34 @@\n+// revisions: good1 good2 good3\n+// check-pass\n+\n+use std::ops::Drop;\n+\n+struct Foo;\n+\n+const X: usize = 1;\n+\n+#[cfg(good1)]\n+impl Drop for Foo\n+where\n+    [(); X]:, // Trivial WF bound\n+{\n+    fn drop(&mut self) {}\n+}\n+\n+#[cfg(good2)]\n+impl Drop for Foo\n+where\n+    for<'a> &'a (): Copy, // Trivial trait bound\n+{\n+    fn drop(&mut self) {}\n+}\n+\n+#[cfg(good3)]\n+impl Drop for Foo\n+where\n+    for<'a> &'a (): 'a, // Trivial outlives bound\n+{\n+    fn drop(&mut self) {}\n+}\n+\n+fn main() {}"}, {"sha": "23c6c59d7a62b90f3720a6abce15fa84a38ebae0", "filename": "tests/ui/parser/eq-less-to-less-eq.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/905d5a38d69328385ce9963c65c385734c60322d/tests%2Fui%2Fparser%2Feq-less-to-less-eq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/905d5a38d69328385ce9963c65c385734c60322d/tests%2Fui%2Fparser%2Feq-less-to-less-eq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fparser%2Feq-less-to-less-eq.rs?ref=905d5a38d69328385ce9963c65c385734c60322d", "patch": "@@ -0,0 +1,33 @@\n+fn foo() {\n+    let a = 0;\n+    let b = 4;\n+    if a =< b { //~ERROR\n+        println!(\"yay!\");\n+    }\n+}\n+\n+fn bar() {\n+    let a = 0;\n+    let b = 4;\n+    if a = <b { //~ERROR\n+        println!(\"yay!\");\n+    }\n+}\n+\n+fn baz() {\n+    let a = 0;\n+    let b = 4;\n+    if a = < b { //~ERROR\n+        println!(\"yay!\");\n+    }\n+}\n+\n+fn qux() {\n+    let a = 0;\n+    let b = 4;\n+    if a =< i32>::abs(-4) { //~ERROR: mismatched types\n+        println!(\"yay!\");\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "4717d8287ff7b3523ac7f8df19e9bc7f9d341714", "filename": "tests/ui/parser/eq-less-to-less-eq.stderr", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/905d5a38d69328385ce9963c65c385734c60322d/tests%2Fui%2Fparser%2Feq-less-to-less-eq.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/905d5a38d69328385ce9963c65c385734c60322d/tests%2Fui%2Fparser%2Feq-less-to-less-eq.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fparser%2Feq-less-to-less-eq.stderr?ref=905d5a38d69328385ce9963c65c385734c60322d", "patch": "@@ -0,0 +1,34 @@\n+error: expected one of `!`, `(`, `+`, `::`, `<`, `>`, or `as`, found `{`\n+  --> $DIR/eq-less-to-less-eq.rs:4:15\n+   |\n+LL |     if a =< b {\n+   |          --   ^ expected one of 7 possible tokens\n+   |          |\n+   |          help: did you mean: `<=`\n+\n+error: expected one of `!`, `(`, `+`, `::`, `<`, `>`, or `as`, found `{`\n+  --> $DIR/eq-less-to-less-eq.rs:12:15\n+   |\n+LL |     if a = <b {\n+   |               ^ expected one of 7 possible tokens\n+\n+error: expected one of `!`, `(`, `+`, `::`, `<`, `>`, or `as`, found `{`\n+  --> $DIR/eq-less-to-less-eq.rs:20:16\n+   |\n+LL |     if a = < b {\n+   |                ^ expected one of 7 possible tokens\n+\n+error[E0308]: mismatched types\n+  --> $DIR/eq-less-to-less-eq.rs:28:8\n+   |\n+LL |     if a =< i32>::abs(-4) {\n+   |        ^^^^^^^^^^^^^^^^^^ expected `bool`, found `()`\n+   |\n+help: you might have meant to compare for equality\n+   |\n+LL |     if a ==< i32>::abs(-4) {\n+   |           +\n+\n+error: aborting due to 4 previous errors\n+\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "a985b1a6e12f695d26b31d82407229f5495d5474", "filename": "tests/ui/traits/non_lifetime_binders/drop-impl-pred.no.stderr", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/905d5a38d69328385ce9963c65c385734c60322d/tests%2Fui%2Ftraits%2Fnon_lifetime_binders%2Fdrop-impl-pred.no.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/905d5a38d69328385ce9963c65c385734c60322d/tests%2Fui%2Ftraits%2Fnon_lifetime_binders%2Fdrop-impl-pred.no.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fnon_lifetime_binders%2Fdrop-impl-pred.no.stderr?ref=905d5a38d69328385ce9963c65c385734c60322d", "patch": "@@ -0,0 +1,24 @@\n+warning: the feature `non_lifetime_binders` is incomplete and may not be safe to use and/or cause compiler crashes\n+  --> $DIR/drop-impl-pred.rs:6:12\n+   |\n+LL | #![feature(non_lifetime_binders)]\n+   |            ^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: see issue #108185 <https://github.com/rust-lang/rust/issues/108185> for more information\n+   = note: `#[warn(incomplete_features)]` on by default\n+\n+error[E0367]: `Drop` impl requires `H: Foo` but the struct it is implemented for does not\n+  --> $DIR/drop-impl-pred.rs:19:15\n+   |\n+LL |     for<H> H: Foo,\n+   |               ^^^\n+   |\n+note: the implementor must specify the same requirement\n+  --> $DIR/drop-impl-pred.rs:12:1\n+   |\n+LL | struct Bar<T>(T) where T: Foo;\n+   | ^^^^^^^^^^^^^\n+\n+error: aborting due to previous error; 1 warning emitted\n+\n+For more information about this error, try `rustc --explain E0367`."}, {"sha": "c65b5ea9ba4931106a19e1ce74d3780ab5d90aff", "filename": "tests/ui/traits/non_lifetime_binders/drop-impl-pred.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/905d5a38d69328385ce9963c65c385734c60322d/tests%2Fui%2Ftraits%2Fnon_lifetime_binders%2Fdrop-impl-pred.rs", "raw_url": "https://github.com/rust-lang/rust/raw/905d5a38d69328385ce9963c65c385734c60322d/tests%2Fui%2Ftraits%2Fnon_lifetime_binders%2Fdrop-impl-pred.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fnon_lifetime_binders%2Fdrop-impl-pred.rs?ref=905d5a38d69328385ce9963c65c385734c60322d", "patch": "@@ -0,0 +1,25 @@\n+// revisions: no yes\n+//[yes] check-pass\n+\n+// Issue 110557\n+\n+#![feature(non_lifetime_binders)]\n+//~^ WARN the feature `non_lifetime_binders` is incomplete\n+\n+pub trait Foo {}\n+\n+#[cfg(no)]\n+struct Bar<T>(T) where T: Foo;\n+\n+#[cfg(yes)]\n+struct Bar<T>(T) where for<H> H: Foo;\n+\n+impl<T> Drop for Bar<T>\n+where\n+    for<H> H: Foo,\n+//[no]~^ ERROR `Drop` impl requires `H: Foo` but the struct it is implemented for does not\n+{\n+    fn drop(&mut self) {}\n+}\n+\n+fn main() {}"}, {"sha": "165cf2ee13da8773f1c4eb539c465afc3a956895", "filename": "tests/ui/traits/non_lifetime_binders/drop-impl-pred.yes.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/905d5a38d69328385ce9963c65c385734c60322d/tests%2Fui%2Ftraits%2Fnon_lifetime_binders%2Fdrop-impl-pred.yes.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/905d5a38d69328385ce9963c65c385734c60322d/tests%2Fui%2Ftraits%2Fnon_lifetime_binders%2Fdrop-impl-pred.yes.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fnon_lifetime_binders%2Fdrop-impl-pred.yes.stderr?ref=905d5a38d69328385ce9963c65c385734c60322d", "patch": "@@ -0,0 +1,11 @@\n+warning: the feature `non_lifetime_binders` is incomplete and may not be safe to use and/or cause compiler crashes\n+  --> $DIR/drop-impl-pred.rs:6:12\n+   |\n+LL | #![feature(non_lifetime_binders)]\n+   |            ^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: see issue #108185 <https://github.com/rust-lang/rust/issues/108185> for more information\n+   = note: `#[warn(incomplete_features)]` on by default\n+\n+warning: 1 warning emitted\n+"}]}