{"sha": "af140757b4cb1a60d107c690720311ba8e06e7de", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFmMTQwNzU3YjRjYjFhNjBkMTA3YzY5MDcyMDMxMWJhOGUwNmU3ZGU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-08-22T20:23:37Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-08-22T20:23:37Z"}, "message": "Auto merge of #88240 - GuillaumeGomez:rollup-wdom91m, r=GuillaumeGomez\n\nRollup of 7 pull requests\n\nSuccessful merges:\n\n - #86747 (Improve wording of the `drop_bounds` lint)\n - #87166 (Show discriminant before overflow in diagnostic for duplicate values.)\n - #88077 (Generate an iOS LLVM target with a specific version)\n - #88164 (PassWrapper: adapt for LLVM 14 changes)\n - #88211 (cleanup: `Span::new` -> `Span::with_lo`)\n - #88229 (Suggest importing the right kind of macro.)\n - #88238 (Stop tracking namespace in used_imports.)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "061b9cd2842ef1ef966322cff231d92fac26e3c3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/061b9cd2842ef1ef966322cff231d92fac26e3c3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/af140757b4cb1a60d107c690720311ba8e06e7de", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/af140757b4cb1a60d107c690720311ba8e06e7de", "html_url": "https://github.com/rust-lang/rust/commit/af140757b4cb1a60d107c690720311ba8e06e7de", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/af140757b4cb1a60d107c690720311ba8e06e7de/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "91f9806208834de3fb5f62712356b0d84ec388fd", "url": "https://api.github.com/repos/rust-lang/rust/commits/91f9806208834de3fb5f62712356b0d84ec388fd", "html_url": "https://github.com/rust-lang/rust/commit/91f9806208834de3fb5f62712356b0d84ec388fd"}, {"sha": "3e8e8d2dad6181f58e78c14b9dd19c267ad602c0", "url": "https://api.github.com/repos/rust-lang/rust/commits/3e8e8d2dad6181f58e78c14b9dd19c267ad602c0", "html_url": "https://github.com/rust-lang/rust/commit/3e8e8d2dad6181f58e78c14b9dd19c267ad602c0"}], "stats": {"total": 246, "additions": 180, "deletions": 66}, "files": [{"sha": "edb158dd378063228b0376003854828459ac59f2", "filename": "compiler/rustc_lint/src/traits.rs", "status": "modified", "additions": 20, "deletions": 16, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/af140757b4cb1a60d107c690720311ba8e06e7de/compiler%2Frustc_lint%2Fsrc%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af140757b4cb1a60d107c690720311ba8e06e7de/compiler%2Frustc_lint%2Fsrc%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Ftraits.rs?ref=af140757b4cb1a60d107c690720311ba8e06e7de", "patch": "@@ -18,23 +18,27 @@ declare_lint! {\n     ///\n     /// ### Explanation\n     ///\n-    /// `Drop` bounds do not really accomplish anything. A type may have\n-    /// compiler-generated drop glue without implementing the `Drop` trait\n-    /// itself. The `Drop` trait also only has one method, `Drop::drop`, and\n-    /// that function is by fiat not callable in user code. So there is really\n-    /// no use case for using `Drop` in trait bounds.\n+    /// A generic trait bound of the form `T: Drop` is most likely misleading\n+    /// and not what the programmer intended (they probably should have used\n+    /// `std::mem::needs_drop` instead).\n     ///\n-    /// The most likely use case of a drop bound is to distinguish between\n-    /// types that have destructors and types that don't. Combined with\n-    /// specialization, a naive coder would write an implementation that\n-    /// assumed a type could be trivially dropped, then write a specialization\n-    /// for `T: Drop` that actually calls the destructor. Except that doing so\n-    /// is not correct; String, for example, doesn't actually implement Drop,\n-    /// but because String contains a Vec, assuming it can be trivially dropped\n-    /// will leak memory.\n+    /// `Drop` bounds do not actually indicate whether a type can be trivially\n+    /// dropped or not, because a composite type containing `Drop` types does\n+    /// not necessarily implement `Drop` itself. Na\u00efvely, one might be tempted\n+    /// to write an implementation that assumes that a type can be trivially\n+    /// dropped while also supplying a specialization for `T: Drop` that\n+    /// actually calls the destructor. However, this breaks down e.g. when `T`\n+    /// is `String`, which does not implement `Drop` itself but contains a\n+    /// `Vec`, which does implement `Drop`, so assuming `T` can be trivially\n+    /// dropped would lead to a memory leak here.\n+    ///\n+    /// Furthermore, the `Drop` trait only contains one method, `Drop::drop`,\n+    /// which may not be called explicitly in user code (`E0040`), so there is\n+    /// really no use case for using `Drop` in trait bounds, save perhaps for\n+    /// some obscure corner cases, which can use `#[allow(drop_bounds)]`.\n     pub DROP_BOUNDS,\n     Warn,\n-    \"bounds of the form `T: Drop` are useless\"\n+    \"bounds of the form `T: Drop` are most likely incorrect\"\n }\n \n declare_lint! {\n@@ -102,8 +106,8 @@ impl<'tcx> LateLintPass<'tcx> for DropTraitConstraints {\n                         None => return,\n                     };\n                     let msg = format!(\n-                        \"bounds on `{}` are useless, consider instead \\\n-                         using `{}` to detect if a type has a destructor\",\n+                        \"bounds on `{}` are most likely incorrect, consider instead \\\n+                         using `{}` to detect whether a type can be trivially dropped\",\n                         predicate,\n                         cx.tcx.def_path_str(needs_drop)\n                     );"}, {"sha": "b3f86f3295ae90f602a1f5272f7221956815d56d", "filename": "compiler/rustc_llvm/llvm-wrapper/PassWrapper.cpp", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/af140757b4cb1a60d107c690720311ba8e06e7de/compiler%2Frustc_llvm%2Fllvm-wrapper%2FPassWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/af140757b4cb1a60d107c690720311ba8e06e7de/compiler%2Frustc_llvm%2Fllvm-wrapper%2FPassWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_llvm%2Fllvm-wrapper%2FPassWrapper.cpp?ref=af140757b4cb1a60d107c690720311ba8e06e7de", "patch": "@@ -922,9 +922,17 @@ LLVMRustOptimizeWithNewPassManager(\n           MPM.addPass(RequireAnalysisPass<ASanGlobalsMetadataAnalysis, Module>());\n           MPM.addPass(ModuleAddressSanitizerPass(\n               /*CompileKernel=*/false, SanitizerOptions->SanitizeAddressRecover));\n+#if LLVM_VERSION_GE(14, 0)\n+          AddressSanitizerOptions opts(/*CompileKernel=*/false,\n+                                       SanitizerOptions->SanitizeAddressRecover,\n+                                       /*UseAfterScope=*/true,\n+                                       AsanDetectStackUseAfterReturnMode::Runtime);\n+          MPM.addPass(createModuleToFunctionPassAdaptor(AddressSanitizerPass(opts)));\n+#else\n           MPM.addPass(createModuleToFunctionPassAdaptor(AddressSanitizerPass(\n               /*CompileKernel=*/false, SanitizerOptions->SanitizeAddressRecover,\n               /*UseAfterScope=*/true)));\n+#endif\n         }\n       );\n #else\n@@ -952,8 +960,15 @@ LLVMRustOptimizeWithNewPassManager(\n #if LLVM_VERSION_GE(11, 0)\n       OptimizerLastEPCallbacks.push_back(\n         [SanitizerOptions](ModulePassManager &MPM, OptimizationLevel Level) {\n+#if LLVM_VERSION_GE(14, 0)\n+          HWAddressSanitizerOptions opts(\n+              /*CompileKernel=*/false, SanitizerOptions->SanitizeHWAddressRecover,\n+              /*DisableOptimization=*/false);\n+          MPM.addPass(HWAddressSanitizerPass(opts));\n+#else\n           MPM.addPass(HWAddressSanitizerPass(\n               /*CompileKernel=*/false, SanitizerOptions->SanitizeHWAddressRecover));\n+#endif\n         }\n       );\n #else"}, {"sha": "ffa26b9f299cba6a9136ee03f971bc4b0bf497e4", "filename": "compiler/rustc_middle/src/middle/region.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af140757b4cb1a60d107c690720311ba8e06e7de/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af140757b4cb1a60d107c690720311ba8e06e7de/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fregion.rs?ref=af140757b4cb1a60d107c690720311ba8e06e7de", "patch": "@@ -189,7 +189,7 @@ impl Scope {\n                 // To avoid issues with macro-generated spans, the span\n                 // of the statement must be nested in that of the block.\n                 if span.lo() <= stmt_span.lo() && stmt_span.lo() <= span.hi() {\n-                    return Span::new(stmt_span.lo(), span.hi(), span.ctxt());\n+                    return span.with_lo(stmt_span.lo());\n                 }\n             }\n         }"}, {"sha": "760b74699619619e8bd4969163ba8d93ebefbfba", "filename": "compiler/rustc_resolve/src/check_unused.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/af140757b4cb1a60d107c690720311ba8e06e7de/compiler%2Frustc_resolve%2Fsrc%2Fcheck_unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af140757b4cb1a60d107c690720311ba8e06e7de/compiler%2Frustc_resolve%2Fsrc%2Fcheck_unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fcheck_unused.rs?ref=af140757b4cb1a60d107c690720311ba8e06e7de", "patch": "@@ -63,8 +63,7 @@ impl<'a, 'b> UnusedImportCheckVisitor<'a, 'b> {\n     // We have information about whether `use` (import) items are actually\n     // used now. If an import is not used at all, we signal a lint error.\n     fn check_import(&mut self, id: ast::NodeId) {\n-        let mut used = false;\n-        self.r.per_ns(|this, ns| used |= this.used_imports.contains(&(id, ns)));\n+        let used = self.r.used_imports.contains(&id);\n         let def_id = self.r.local_def_id(id);\n         if !used {\n             if self.r.maybe_unused_trait_imports.contains(&def_id) {"}, {"sha": "3cf042687562ba62dddc6eecbd0dbae3b7719cdc", "filename": "compiler/rustc_resolve/src/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/af140757b4cb1a60d107c690720311ba8e06e7de/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af140757b4cb1a60d107c690720311ba8e06e7de/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs?ref=af140757b4cb1a60d107c690720311ba8e06e7de", "patch": "@@ -950,9 +950,7 @@ impl<'a> Resolver<'a> {\n         self.add_typo_suggestion(err, suggestion, ident.span);\n \n         let import_suggestions =\n-            self.lookup_import_candidates(ident, Namespace::MacroNS, parent_scope, |res| {\n-                matches!(res, Res::Def(DefKind::Macro(MacroKind::Bang), _))\n-            });\n+            self.lookup_import_candidates(ident, Namespace::MacroNS, parent_scope, is_expected);\n         show_candidates(err, None, &import_suggestions, false, true);\n \n         if macro_kind == MacroKind::Derive && (ident.name == sym::Send || ident.name == sym::Sync) {"}, {"sha": "dfb6d89a0d12601772f5ad183f2fc10b06fe727b", "filename": "compiler/rustc_resolve/src/imports.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/af140757b4cb1a60d107c690720311ba8e06e7de/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af140757b4cb1a60d107c690720311ba8e06e7de/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs?ref=af140757b4cb1a60d107c690720311ba8e06e7de", "patch": "@@ -303,7 +303,7 @@ impl<'a> Resolver<'a> {\n                     if self.last_import_segment && check_usable(self, binding).is_err() {\n                         Err((Determined, Weak::No))\n                     } else {\n-                        self.record_use(ident, ns, binding, restricted_shadowing);\n+                        self.record_use(ident, binding, restricted_shadowing);\n \n                         if let Some(shadowed_glob) = resolution.shadowed_glob {\n                             // Forbid expanded shadowing to avoid time travel.\n@@ -609,9 +609,9 @@ impl<'a> Resolver<'a> {\n             self.per_ns(|this, ns| {\n                 let key = this.new_key(target, ns);\n                 let _ = this.try_define(import.parent_scope.module, key, dummy_binding);\n-                // Consider erroneous imports used to avoid duplicate diagnostics.\n-                this.record_use(target, ns, dummy_binding, false);\n             });\n+            // Consider erroneous imports used to avoid duplicate diagnostics.\n+            self.record_use(target, dummy_binding, false);\n         }\n     }\n }\n@@ -709,7 +709,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n                 }\n             } else if is_indeterminate {\n                 // Consider erroneous imports used to avoid duplicate diagnostics.\n-                self.r.used_imports.insert((import.id, TypeNS));\n+                self.r.used_imports.insert(import.id);\n                 let path = import_path_to_string(\n                     &import.module_path.iter().map(|seg| seg.ident).collect::<Vec<_>>(),\n                     &import.kind,\n@@ -902,7 +902,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n         import.vis.set(orig_vis);\n         if let PathResult::Failed { .. } | PathResult::NonModule(..) = path_res {\n             // Consider erroneous imports used to avoid duplicate diagnostics.\n-            self.r.used_imports.insert((import.id, TypeNS));\n+            self.r.used_imports.insert(import.id);\n         }\n         let module = match path_res {\n             PathResult::Module(module) => {\n@@ -1043,7 +1043,6 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n                                 {\n                                     this.record_use(\n                                         ident,\n-                                        ns,\n                                         target_binding,\n                                         import.module_path.is_empty(),\n                                     );"}, {"sha": "0b552aa07f5179062631d70ea8347ffda0a206dd", "filename": "compiler/rustc_resolve/src/late.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/af140757b4cb1a60d107c690720311ba8e06e7de/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af140757b4cb1a60d107c690720311ba8e06e7de/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate.rs?ref=af140757b4cb1a60d107c690720311ba8e06e7de", "patch": "@@ -1738,7 +1738,7 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                 // whether they can be shadowed by fresh bindings or not, so force an error.\n                 // issues/33118#issuecomment-233962221 (see below) still applies here,\n                 // but we have to ignore it for backward compatibility.\n-                self.r.record_use(ident, ValueNS, binding, false);\n+                self.r.record_use(ident, binding, false);\n                 return None;\n             }\n             LexicalScopeBinding::Item(binding) => (binding.res(), Some(binding)),\n@@ -1753,7 +1753,7 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n             ) if is_syntactic_ambiguity => {\n                 // Disambiguate in favor of a unit struct/variant or constant pattern.\n                 if let Some(binding) = binding {\n-                    self.r.record_use(ident, ValueNS, binding, false);\n+                    self.r.record_use(ident, binding, false);\n                 }\n                 Some(res)\n             }"}, {"sha": "465007507dafeb682e958c69a61b59b0f9bf75bb", "filename": "compiler/rustc_resolve/src/lib.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/af140757b4cb1a60d107c690720311ba8e06e7de/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af140757b4cb1a60d107c690720311ba8e06e7de/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flib.rs?ref=af140757b4cb1a60d107c690720311ba8e06e7de", "patch": "@@ -942,7 +942,7 @@ pub struct Resolver<'a> {\n     glob_map: FxHashMap<LocalDefId, FxHashSet<Symbol>>,\n     /// Visibilities in \"lowered\" form, for all entities that have them.\n     visibilities: FxHashMap<LocalDefId, ty::Visibility>,\n-    used_imports: FxHashSet<(NodeId, Namespace)>,\n+    used_imports: FxHashSet<NodeId>,\n     maybe_unused_trait_imports: FxHashSet<LocalDefId>,\n     maybe_unused_extern_crates: Vec<(LocalDefId, Span)>,\n \n@@ -1656,7 +1656,6 @@ impl<'a> Resolver<'a> {\n     fn record_use(\n         &mut self,\n         ident: Ident,\n-        ns: Namespace,\n         used_binding: &'a NameBinding<'a>,\n         is_lexical_scope: bool,\n     ) {\n@@ -1684,9 +1683,9 @@ impl<'a> Resolver<'a> {\n             }\n             used.set(true);\n             import.used.set(true);\n-            self.used_imports.insert((import.id, ns));\n+            self.used_imports.insert(import.id);\n             self.add_to_glob_map(&import, ident);\n-            self.record_use(ident, ns, binding, false);\n+            self.record_use(ident, binding, false);\n         }\n     }\n \n@@ -3241,7 +3240,7 @@ impl<'a> Resolver<'a> {\n         self.extern_prelude.get(&ident.normalize_to_macros_2_0()).cloned().and_then(|entry| {\n             if let Some(binding) = entry.extern_crate_item {\n                 if !speculative && entry.introduced_by_item {\n-                    self.record_use(ident, TypeNS, binding, false);\n+                    self.record_use(ident, binding, false);\n                 }\n                 Some(binding)\n             } else {\n@@ -3428,7 +3427,7 @@ impl<'a> Resolver<'a> {\n         let is_import = name_binding.is_import();\n         let span = name_binding.span;\n         if let Res::Def(DefKind::Fn, _) = res {\n-            self.record_use(ident, ValueNS, name_binding, false);\n+            self.record_use(ident, name_binding, false);\n         }\n         self.main_def = Some(MainDefinition { res, is_import, span });\n     }"}, {"sha": "7f86f891c4450039b11c5bb9974672a24fe6342e", "filename": "compiler/rustc_resolve/src/macros.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af140757b4cb1a60d107c690720311ba8e06e7de/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af140757b4cb1a60d107c690720311ba8e06e7de/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs?ref=af140757b4cb1a60d107c690720311ba8e06e7de", "patch": "@@ -1090,7 +1090,7 @@ impl<'a> Resolver<'a> {\n             ) {\n                 Ok(binding) => {\n                     let initial_res = initial_binding.map(|initial_binding| {\n-                        self.record_use(ident, MacroNS, initial_binding, false);\n+                        self.record_use(ident, initial_binding, false);\n                         initial_binding.res()\n                     });\n                     let res = binding.res();"}, {"sha": "6468419fce7c3e5b973dad2b43552dc4c62a50e8", "filename": "compiler/rustc_target/src/spec/aarch64_apple_ios.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/af140757b4cb1a60d107c690720311ba8e06e7de/compiler%2Frustc_target%2Fsrc%2Fspec%2Faarch64_apple_ios.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af140757b4cb1a60d107c690720311ba8e06e7de/compiler%2Frustc_target%2Fsrc%2Fspec%2Faarch64_apple_ios.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Faarch64_apple_ios.rs?ref=af140757b4cb1a60d107c690720311ba8e06e7de", "patch": "@@ -2,8 +2,15 @@ use super::apple_sdk_base::{opts, Arch};\n use crate::spec::{FramePointer, Target, TargetOptions};\n \n pub fn target() -> Target {\n+    // Clang automatically chooses a more specific target based on\n+    // IPHONEOS_DEPLOYMENT_TARGET.\n+    // This is required for the target to pick the right\n+    // MACH-O commands, so we do too.\n+    let arch = \"arm64\";\n+    let llvm_target = super::apple_base::ios_llvm_target(arch);\n+\n     Target {\n-        llvm_target: \"arm64-apple-ios\".to_string(),\n+        llvm_target,\n         pointer_width: 64,\n         data_layout: \"e-m:o-i64:64-i128:128-n32:64-S128\".to_string(),\n         arch: \"aarch64\".to_string(),"}, {"sha": "cff0b3651e170b683ff7652d24ff8256f7c0f567", "filename": "compiler/rustc_target/src/spec/apple_base.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/af140757b4cb1a60d107c690720311ba8e06e7de/compiler%2Frustc_target%2Fsrc%2Fspec%2Fapple_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af140757b4cb1a60d107c690720311ba8e06e7de/compiler%2Frustc_target%2Fsrc%2Fspec%2Fapple_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fapple_base.rs?ref=af140757b4cb1a60d107c690720311ba8e06e7de", "patch": "@@ -91,6 +91,11 @@ fn ios_deployment_target() -> (u32, u32) {\n     deployment_target(\"IPHONEOS_DEPLOYMENT_TARGET\").unwrap_or((7, 0))\n }\n \n+pub fn ios_llvm_target(arch: &str) -> String {\n+    let (major, minor) = ios_deployment_target();\n+    format!(\"{}-apple-ios{}.{}.0\", arch, major, minor)\n+}\n+\n pub fn ios_sim_llvm_target(arch: &str) -> String {\n     let (major, minor) = ios_deployment_target();\n     format!(\"{}-apple-ios{}.{}.0-simulator\", arch, major, minor)"}, {"sha": "aae9518ad5140b22b47c8b881156800e48fdeacf", "filename": "compiler/rustc_typeck/src/check/check.rs", "status": "modified", "additions": 24, "deletions": 3, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/af140757b4cb1a60d107c690720311ba8e06e7de/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af140757b4cb1a60d107c690720311ba8e06e7de/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs?ref=af140757b4cb1a60d107c690720311ba8e06e7de", "patch": "@@ -1413,15 +1413,17 @@ fn check_enum<'tcx>(\n                 Some(ref expr) => tcx.hir().span(expr.hir_id),\n                 None => v.span,\n             };\n+            let display_discr = display_discriminant_value(tcx, v, discr.val);\n+            let display_discr_i = display_discriminant_value(tcx, variant_i, disr_vals[i].val);\n             struct_span_err!(\n                 tcx.sess,\n                 span,\n                 E0081,\n                 \"discriminant value `{}` already exists\",\n-                disr_vals[i]\n+                discr.val,\n             )\n-            .span_label(i_span, format!(\"first use of `{}`\", disr_vals[i]))\n-            .span_label(span, format!(\"enum already has `{}`\", disr_vals[i]))\n+            .span_label(i_span, format!(\"first use of {}\", display_discr_i))\n+            .span_label(span, format!(\"enum already has {}\", display_discr))\n             .emit();\n         }\n         disr_vals.push(discr);\n@@ -1431,6 +1433,25 @@ fn check_enum<'tcx>(\n     check_transparent(tcx, sp, def);\n }\n \n+/// Format an enum discriminant value for use in a diagnostic message.\n+fn display_discriminant_value<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    variant: &hir::Variant<'_>,\n+    evaluated: u128,\n+) -> String {\n+    if let Some(expr) = &variant.disr_expr {\n+        let body = &tcx.hir().body(expr.body).value;\n+        if let hir::ExprKind::Lit(lit) = &body.kind {\n+            if let rustc_ast::LitKind::Int(lit_value, _int_kind) = &lit.node {\n+                if evaluated != *lit_value {\n+                    return format!(\"`{}` (overflowed from `{}`)\", evaluated, lit_value);\n+                }\n+            }\n+        }\n+    }\n+    format!(\"`{}`\", evaluated)\n+}\n+\n pub(super) fn check_type_params_are_used<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     generics: &ty::Generics,"}, {"sha": "8d5bf98be9932b177037d98158f2376f12618a4c", "filename": "compiler/rustc_typeck/src/check/compare_method.rs", "status": "modified", "additions": 2, "deletions": 10, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/af140757b4cb1a60d107c690720311ba8e06e7de/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af140757b4cb1a60d107c690720311ba8e06e7de/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcompare_method.rs?ref=af140757b4cb1a60d107c690720311ba8e06e7de", "patch": "@@ -708,11 +708,7 @@ fn compare_number_of_method_arguments<'tcx>(\n                         Some(if pos == 0 {\n                             arg.span\n                         } else {\n-                            Span::new(\n-                                trait_m_sig.decl.inputs[0].span.lo(),\n-                                arg.span.hi(),\n-                                arg.span.ctxt(),\n-                            )\n+                            arg.span.with_lo(trait_m_sig.decl.inputs[0].span.lo())\n                         })\n                     } else {\n                         trait_item_span\n@@ -731,11 +727,7 @@ fn compare_number_of_method_arguments<'tcx>(\n                     if pos == 0 {\n                         arg.span\n                     } else {\n-                        Span::new(\n-                            impl_m_sig.decl.inputs[0].span.lo(),\n-                            arg.span.hi(),\n-                            arg.span.ctxt(),\n-                        )\n+                        arg.span.with_lo(impl_m_sig.decl.inputs[0].span.lo())\n                     }\n                 } else {\n                     impl_m_span"}, {"sha": "3ffb855a55dc854c69252ee1925fc24c9228f752", "filename": "src/test/ui/drop-bounds/drop-bounds.stderr", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/af140757b4cb1a60d107c690720311ba8e06e7de/src%2Ftest%2Fui%2Fdrop-bounds%2Fdrop-bounds.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/af140757b4cb1a60d107c690720311ba8e06e7de/src%2Ftest%2Fui%2Fdrop-bounds%2Fdrop-bounds.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdrop-bounds%2Fdrop-bounds.stderr?ref=af140757b4cb1a60d107c690720311ba8e06e7de", "patch": "@@ -1,4 +1,4 @@\n-error: bounds on `T: Drop` are useless, consider instead using `std::mem::needs_drop` to detect if a type has a destructor\n+error: bounds on `T: Drop` are most likely incorrect, consider instead using `std::mem::needs_drop` to detect whether a type can be trivially dropped\n   --> $DIR/drop-bounds.rs:2:11\n    |\n LL | fn foo<T: Drop>() {}\n@@ -10,37 +10,37 @@ note: the lint level is defined here\n LL | #![deny(drop_bounds)]\n    |         ^^^^^^^^^^^\n \n-error: bounds on `U: Drop` are useless, consider instead using `std::mem::needs_drop` to detect if a type has a destructor\n+error: bounds on `U: Drop` are most likely incorrect, consider instead using `std::mem::needs_drop` to detect whether a type can be trivially dropped\n   --> $DIR/drop-bounds.rs:5:8\n    |\n LL |     U: Drop,\n    |        ^^^^\n \n-error: bounds on `impl Drop: Drop` are useless, consider instead using `std::mem::needs_drop` to detect if a type has a destructor\n+error: bounds on `impl Drop: Drop` are most likely incorrect, consider instead using `std::mem::needs_drop` to detect whether a type can be trivially dropped\n   --> $DIR/drop-bounds.rs:8:17\n    |\n LL | fn baz(_x: impl Drop) {}\n    |                 ^^^^\n \n-error: bounds on `T: Drop` are useless, consider instead using `std::mem::needs_drop` to detect if a type has a destructor\n+error: bounds on `T: Drop` are most likely incorrect, consider instead using `std::mem::needs_drop` to detect whether a type can be trivially dropped\n   --> $DIR/drop-bounds.rs:9:15\n    |\n LL | struct Foo<T: Drop> {\n    |               ^^^^\n \n-error: bounds on `U: Drop` are useless, consider instead using `std::mem::needs_drop` to detect if a type has a destructor\n+error: bounds on `U: Drop` are most likely incorrect, consider instead using `std::mem::needs_drop` to detect whether a type can be trivially dropped\n   --> $DIR/drop-bounds.rs:12:24\n    |\n LL | struct Bar<U> where U: Drop {\n    |                        ^^^^\n \n-error: bounds on `Self: Drop` are useless, consider instead using `std::mem::needs_drop` to detect if a type has a destructor\n+error: bounds on `Self: Drop` are most likely incorrect, consider instead using `std::mem::needs_drop` to detect whether a type can be trivially dropped\n   --> $DIR/drop-bounds.rs:15:12\n    |\n LL | trait Baz: Drop {\n    |            ^^^^\n \n-error: bounds on `T: Drop` are useless, consider instead using `std::mem::needs_drop` to detect if a type has a destructor\n+error: bounds on `T: Drop` are most likely incorrect, consider instead using `std::mem::needs_drop` to detect whether a type can be trivially dropped\n   --> $DIR/drop-bounds.rs:17:9\n    |\n LL | impl<T: Drop> Baz for T {"}, {"sha": "473a0ad6f7a1384b6c4f5b3815548442048bbed2", "filename": "src/test/ui/enum/enum-discrim-autosizing.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/af140757b4cb1a60d107c690720311ba8e06e7de/src%2Ftest%2Fui%2Fenum%2Fenum-discrim-autosizing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af140757b4cb1a60d107c690720311ba8e06e7de/src%2Ftest%2Fui%2Fenum%2Fenum-discrim-autosizing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fenum%2Fenum-discrim-autosizing.rs?ref=af140757b4cb1a60d107c690720311ba8e06e7de", "patch": "@@ -4,8 +4,10 @@\n // so force the repr.\n #[cfg_attr(not(target_pointer_width = \"32\"), repr(i32))]\n enum Eu64 {\n-    Au64 = 0,\n-    Bu64 = 0x8000_0000_0000_0000 //~ERROR already exists\n+    Au64 = 0, //~NOTE first use of `0`\n+    Bu64 = 0x8000_0000_0000_0000\n+    //~^ ERROR discriminant value `0` already exists\n+    //~| NOTE enum already has `0` (overflowed from `9223372036854775808`)\n }\n \n fn main() {}"}, {"sha": "a0f39098a2e98dcac51b194fa3b0b3b72446b766", "filename": "src/test/ui/enum/enum-discrim-autosizing.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af140757b4cb1a60d107c690720311ba8e06e7de/src%2Ftest%2Fui%2Fenum%2Fenum-discrim-autosizing.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/af140757b4cb1a60d107c690720311ba8e06e7de/src%2Ftest%2Fui%2Fenum%2Fenum-discrim-autosizing.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fenum%2Fenum-discrim-autosizing.stderr?ref=af140757b4cb1a60d107c690720311ba8e06e7de", "patch": "@@ -4,7 +4,7 @@ error[E0081]: discriminant value `0` already exists\n LL |     Au64 = 0,\n    |            - first use of `0`\n LL |     Bu64 = 0x8000_0000_0000_0000\n-   |            ^^^^^^^^^^^^^^^^^^^^^ enum already has `0`\n+   |            ^^^^^^^^^^^^^^^^^^^^^ enum already has `0` (overflowed from `9223372036854775808`)\n \n error: aborting due to previous error\n "}, {"sha": "255e05ced19f722c3fee9a576ab8fe9b6d607741", "filename": "src/test/ui/error-codes/E0081.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/af140757b4cb1a60d107c690720311ba8e06e7de/src%2Ftest%2Fui%2Ferror-codes%2FE0081.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af140757b4cb1a60d107c690720311ba8e06e7de/src%2Ftest%2Fui%2Ferror-codes%2FE0081.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0081.rs?ref=af140757b4cb1a60d107c690720311ba8e06e7de", "patch": "@@ -1,9 +1,20 @@\n enum Enum {\n     P = 3,\n+    //~^ NOTE first use of `3`\n     X = 3,\n     //~^ ERROR discriminant value `3` already exists\n+    //~| NOTE enum already has `3`\n     Y = 5\n }\n \n+#[repr(u8)]\n+enum EnumOverflowRepr {\n+    P = 257,\n+    //~^ NOTE first use of `1` (overflowed from `257`)\n+    X = 513,\n+    //~^ ERROR discriminant value `1` already exists\n+    //~| NOTE enum already has `1` (overflowed from `513`)\n+}\n+\n fn main() {\n }"}, {"sha": "9b279bb0214c6eb129223aea0f73bab42face8e1", "filename": "src/test/ui/error-codes/E0081.stderr", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/af140757b4cb1a60d107c690720311ba8e06e7de/src%2Ftest%2Fui%2Ferror-codes%2FE0081.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/af140757b4cb1a60d107c690720311ba8e06e7de/src%2Ftest%2Fui%2Ferror-codes%2FE0081.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0081.stderr?ref=af140757b4cb1a60d107c690720311ba8e06e7de", "patch": "@@ -1,11 +1,21 @@\n error[E0081]: discriminant value `3` already exists\n-  --> $DIR/E0081.rs:3:9\n+  --> $DIR/E0081.rs:4:9\n    |\n LL |     P = 3,\n    |         - first use of `3`\n+LL |\n LL |     X = 3,\n    |         ^ enum already has `3`\n \n-error: aborting due to previous error\n+error[E0081]: discriminant value `1` already exists\n+  --> $DIR/E0081.rs:14:9\n+   |\n+LL |     P = 257,\n+   |         --- first use of `1` (overflowed from `257`)\n+LL |\n+LL |     X = 513,\n+   |         ^^^ enum already has `1` (overflowed from `513`)\n+\n+error: aborting due to 2 previous errors\n \n For more information about this error, try `rustc --explain E0081`."}, {"sha": "615b865e9f1e1e43e133bfcc37b8045c71245854", "filename": "src/test/ui/macros/issue-88228.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/af140757b4cb1a60d107c690720311ba8e06e7de/src%2Ftest%2Fui%2Fmacros%2Fissue-88228.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af140757b4cb1a60d107c690720311ba8e06e7de/src%2Ftest%2Fui%2Fmacros%2Fissue-88228.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fissue-88228.rs?ref=af140757b4cb1a60d107c690720311ba8e06e7de", "patch": "@@ -0,0 +1,22 @@\n+// compile-flags: -Z deduplicate-diagnostics=yes\n+// edition:2018\n+\n+mod hey {\n+    pub use Copy as Bla;\n+    pub use std::println as bla;\n+}\n+\n+#[derive(Bla)]\n+//~^ ERROR cannot find derive macro `Bla`\n+//~| NOTE consider importing this derive macro\n+struct A;\n+\n+#[derive(println)]\n+//~^ ERROR cannot find derive macro `println`\n+struct B;\n+\n+fn main() {\n+    bla!();\n+    //~^ ERROR cannot find macro `bla`\n+    //~| NOTE consider importing this macro\n+}"}, {"sha": "b164e39064c97be5067be82e278fa7822f242a4a", "filename": "src/test/ui/macros/issue-88228.stderr", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/af140757b4cb1a60d107c690720311ba8e06e7de/src%2Ftest%2Fui%2Fmacros%2Fissue-88228.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/af140757b4cb1a60d107c690720311ba8e06e7de/src%2Ftest%2Fui%2Fmacros%2Fissue-88228.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fissue-88228.stderr?ref=af140757b4cb1a60d107c690720311ba8e06e7de", "patch": "@@ -0,0 +1,26 @@\n+error: cannot find macro `bla` in this scope\n+  --> $DIR/issue-88228.rs:19:5\n+   |\n+LL |     bla!();\n+   |     ^^^\n+   |\n+   = note: consider importing this macro:\n+           crate::hey::bla\n+\n+error: cannot find derive macro `println` in this scope\n+  --> $DIR/issue-88228.rs:14:10\n+   |\n+LL | #[derive(println)]\n+   |          ^^^^^^^\n+\n+error: cannot find derive macro `Bla` in this scope\n+  --> $DIR/issue-88228.rs:9:10\n+   |\n+LL | #[derive(Bla)]\n+   |          ^^^\n+   |\n+   = note: consider importing this derive macro:\n+           crate::hey::Bla\n+\n+error: aborting due to 3 previous errors\n+"}, {"sha": "3b160935a2f8d91d37fb2011485f587bb74eca40", "filename": "src/test/ui/proc-macro/derive-helper-shadowing.stderr", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/af140757b4cb1a60d107c690720311ba8e06e7de/src%2Ftest%2Fui%2Fproc-macro%2Fderive-helper-shadowing.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/af140757b4cb1a60d107c690720311ba8e06e7de/src%2Ftest%2Fui%2Fproc-macro%2Fderive-helper-shadowing.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fderive-helper-shadowing.stderr?ref=af140757b4cb1a60d107c690720311ba8e06e7de", "patch": "@@ -16,6 +16,8 @@ error: cannot find attribute `empty_helper` in this scope\n LL |             #[derive(GenHelperUse)]\n    |                      ^^^^^^^^^^^^\n    |\n+   = note: consider importing this attribute macro:\n+           empty_helper\n    = note: this error originates in the derive macro `GenHelperUse` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: cannot find attribute `empty_helper` in this scope\n@@ -27,6 +29,8 @@ LL |         #[empty_helper]\n LL |             gen_helper_use!();\n    |             ------------------ in this macro invocation\n    |\n+   = note: consider importing this attribute macro:\n+           crate::empty_helper\n    = note: this error originates in the macro `gen_helper_use` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error[E0659]: `empty_helper` is ambiguous (name vs any other name during import resolution)"}, {"sha": "db0f412f2a18c8ebc5302fe2c6419c957d0a9a09", "filename": "src/tools/clippy/clippy_lints/src/unit_return_expecting_ord.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af140757b4cb1a60d107c690720311ba8e06e7de/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funit_return_expecting_ord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af140757b4cb1a60d107c690720311ba8e06e7de/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funit_return_expecting_ord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funit_return_expecting_ord.rs?ref=af140757b4cb1a60d107c690720311ba8e06e7de", "patch": "@@ -127,7 +127,7 @@ fn check_arg<'tcx>(cx: &LateContext<'tcx>, arg: &'tcx Expr<'tcx>) -> Option<(Spa\n                 then {\n                     let data = stmt.span.data();\n                     // Make a span out of the semicolon for the help message\n-                    Some((span, Some(Span::new(data.hi-BytePos(1), data.hi, data.ctxt))))\n+                    Some((span, Some(data.with_lo(data.hi-BytePos(1)))))\n                 } else {\n                     Some((span, None))\n                 }"}, {"sha": "85d1f65c51f0911aaf1ab76ffb36ce496a759536", "filename": "src/tools/clippy/clippy_lints/src/write.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af140757b4cb1a60d107c690720311ba8e06e7de/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af140757b4cb1a60d107c690720311ba8e06e7de/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fwrite.rs?ref=af140757b4cb1a60d107c690720311ba8e06e7de", "patch": "@@ -299,7 +299,7 @@ impl EarlyLintPass for Write {\n                     let nl_span = match (dest, only_nl) {\n                         // Special case of `write!(buf, \"\\n\")`: Mark everything from the end of\n                         // `buf` for removal so no trailing comma [`writeln!(buf, )`] remains.\n-                        (Some(dest_expr), true) => Span::new(dest_expr.span.hi(), nl_span.hi(), nl_span.ctxt()),\n+                        (Some(dest_expr), true) => nl_span.with_lo(dest_expr.span.hi()),\n                         _ => nl_span,\n                     };\n                     span_lint_and_then("}, {"sha": "2777e5bd0c4224beda24c2bdfb48ba6915f46eea", "filename": "src/tools/clippy/clippy_utils/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af140757b4cb1a60d107c690720311ba8e06e7de/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af140757b4cb1a60d107c690720311ba8e06e7de/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Flib.rs?ref=af140757b4cb1a60d107c690720311ba8e06e7de", "patch": "@@ -881,7 +881,7 @@ fn line_span<T: LintContext>(cx: &T, span: Span) -> Span {\n     let source_map_and_line = cx.sess().source_map().lookup_line(span.lo()).unwrap();\n     let line_no = source_map_and_line.line;\n     let line_start = source_map_and_line.sf.lines[line_no];\n-    Span::new(line_start, span.hi(), span.ctxt())\n+    span.with_lo(line_start)\n }\n \n /// Gets the parent node, if any."}]}