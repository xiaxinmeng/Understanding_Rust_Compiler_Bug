{"sha": "4443957f272e304e083a8d98583e608d65a712aa", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ0NDM5NTdmMjcyZTMwNGUwODNhOGQ5ODU4M2U2MDhkNjVhNzEyYWE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-05-12T20:28:19Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-05-12T20:28:19Z"}, "message": "Auto merge of #60767 - Centril:rollup-4cbsb73, r=Centril\n\nRollup of 4 pull requests\n\nSuccessful merges:\n\n - #60694 (Fix HIR printing of existential type #60662)\n - #60750 (syntax: Remove some legacy nonterminal tokens)\n - #60751 (Assorted cleanup in parser & AST validation)\n - #60752 (Fix minor typos for ItemLocalId)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "def75022d500e1c7803b5f0d84374bdc08e031bb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/def75022d500e1c7803b5f0d84374bdc08e031bb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4443957f272e304e083a8d98583e608d65a712aa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4443957f272e304e083a8d98583e608d65a712aa", "html_url": "https://github.com/rust-lang/rust/commit/4443957f272e304e083a8d98583e608d65a712aa", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4443957f272e304e083a8d98583e608d65a712aa/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1764b29725df66183059f406c8c65edf642bbd43", "url": "https://api.github.com/repos/rust-lang/rust/commits/1764b29725df66183059f406c8c65edf642bbd43", "html_url": "https://github.com/rust-lang/rust/commit/1764b29725df66183059f406c8c65edf642bbd43"}, {"sha": "b381e52c7c1123936bbf51483788f67fadca9e68", "url": "https://api.github.com/repos/rust-lang/rust/commits/b381e52c7c1123936bbf51483788f67fadca9e68", "html_url": "https://github.com/rust-lang/rust/commit/b381e52c7c1123936bbf51483788f67fadca9e68"}], "stats": {"total": 169, "additions": 80, "deletions": 89}, "files": [{"sha": "f407be4e87b828390db961551aa7d19e24607e1d", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4443957f272e304e083a8d98583e608d65a712aa/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4443957f272e304e083a8d98583e608d65a712aa/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=4443957f272e304e083a8d98583e608d65a712aa", "patch": "@@ -126,12 +126,12 @@ mod item_local_id_inner {\n     use rustc_macros::HashStable;\n     newtype_index! {\n         /// An `ItemLocalId` uniquely identifies something within a given \"item-like\",\n-        /// that is within a hir::Item, hir::TraitItem, or hir::ImplItem. There is no\n+        /// that is, within a hir::Item, hir::TraitItem, or hir::ImplItem. There is no\n         /// guarantee that the numerical value of a given `ItemLocalId` corresponds to\n         /// the node's position within the owning item in any way, but there is a\n         /// guarantee that the `LocalItemId`s within an owner occupy a dense range of\n         /// integers starting at zero, so a mapping that maps all or most nodes within\n-        /// an \"item-like\" to something else can be implement by a `Vec` instead of a\n+        /// an \"item-like\" to something else can be implemented by a `Vec` instead of a\n         /// tree or hash map.\n         pub struct ItemLocalId {\n             derive [HashStable]"}, {"sha": "8a9028e5443912471481ee6749b1065d4aadb7aa", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4443957f272e304e083a8d98583e608d65a712aa/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4443957f272e304e083a8d98583e608d65a712aa/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=4443957f272e304e083a8d98583e608d65a712aa", "patch": "@@ -618,7 +618,6 @@ impl<'a> State<'a> {\n \n                 self.print_where_clause(&exist.generics.where_clause)?;\n                 self.s.space()?;\n-                self.word_space(\":\")?;\n                 let mut real_bounds = Vec::with_capacity(exist.bounds.len());\n                 for b in exist.bounds.iter() {\n                     if let GenericBound::Trait(ref ptr, hir::TraitBoundModifier::Maybe) = *b {"}, {"sha": "16935796d4ba71838b26c9b373d32d9e8908c6ac", "filename": "src/librustc_passes/ast_validation.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/4443957f272e304e083a8d98583e608d65a712aa/src%2Flibrustc_passes%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4443957f272e304e083a8d98583e608d65a712aa/src%2Flibrustc_passes%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fast_validation.rs?ref=4443957f272e304e083a8d98583e608d65a712aa", "patch": "@@ -54,21 +54,21 @@ struct AstValidator<'a> {\n     has_proc_macro_decls: bool,\n     has_global_allocator: bool,\n \n-    // Used to ban nested `impl Trait`, e.g., `impl Into<impl Debug>`.\n-    // Nested `impl Trait` _is_ allowed in associated type position,\n-    // e.g `impl Iterator<Item=impl Debug>`\n+    /// Used to ban nested `impl Trait`, e.g., `impl Into<impl Debug>`.\n+    /// Nested `impl Trait` _is_ allowed in associated type position,\n+    /// e.g `impl Iterator<Item=impl Debug>`\n     outer_impl_trait: Option<OuterImplTrait>,\n \n-    // Used to ban `impl Trait` in path projections like `<impl Iterator>::Item`\n-    // or `Foo::Bar<impl Trait>`\n+    /// Used to ban `impl Trait` in path projections like `<impl Iterator>::Item`\n+    /// or `Foo::Bar<impl Trait>`\n     is_impl_trait_banned: bool,\n \n-    // rust-lang/rust#57979: the ban of nested `impl Trait` was buggy\n-    // until PRs #57730 and #57981 landed: it would jump directly to\n-    // walk_ty rather than visit_ty (or skip recurring entirely for\n-    // impl trait in projections), and thus miss some cases. We track\n-    // whether we should downgrade to a warning for short-term via\n-    // these booleans.\n+    /// rust-lang/rust#57979: the ban of nested `impl Trait` was buggy\n+    /// until PRs #57730 and #57981 landed: it would jump directly to\n+    /// walk_ty rather than visit_ty (or skip recurring entirely for\n+    /// impl trait in projections), and thus miss some cases. We track\n+    /// whether we should downgrade to a warning for short-term via\n+    /// these booleans.\n     warning_period_57979_didnt_record_next_impl_trait: bool,\n     warning_period_57979_impl_trait_in_proj: bool,\n }"}, {"sha": "f587e63e12b94b428e663f79a97c71a65c3bc754", "filename": "src/libsyntax/mut_visit.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4443957f272e304e083a8d98583e608d65a712aa/src%2Flibsyntax%2Fmut_visit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4443957f272e304e083a8d98583e608d65a712aa/src%2Flibsyntax%2Fmut_visit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fmut_visit.rs?ref=4443957f272e304e083a8d98583e608d65a712aa", "patch": "@@ -663,7 +663,6 @@ pub fn noop_visit_interpolated<T: MutVisitor>(nt: &mut token::Nonterminal, vis:\n         token::NtMeta(meta) => vis.visit_meta_item(meta),\n         token::NtPath(path) => vis.visit_path(path),\n         token::NtTT(tt) => vis.visit_tt(tt),\n-        token::NtArm(arm) => vis.visit_arm(arm),\n         token::NtImplItem(item) =>\n             visit_clobber(item, |item| {\n                 // See reasoning above.\n@@ -676,9 +675,6 @@ pub fn noop_visit_interpolated<T: MutVisitor>(nt: &mut token::Nonterminal, vis:\n                 vis.flat_map_trait_item(item)\n                     .expect_one(\"expected visitor to produce exactly one item\")\n             }),\n-        token::NtGenerics(generics) => vis.visit_generics(generics),\n-        token::NtWhereClause(where_clause) => vis.visit_where_clause(where_clause),\n-        token::NtArg(arg) => vis.visit_arg(arg),\n         token::NtVis(visib) => vis.visit_vis(visib),\n         token::NtForeignItem(item) =>\n             visit_clobber(item, |item| {"}, {"sha": "559cc522810de579a358af4e779d41b5e713f032", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 38, "deletions": 57, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/4443957f272e304e083a8d98583e608d65a712aa/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4443957f272e304e083a8d98583e608d65a712aa/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=4443957f272e304e083a8d98583e608d65a712aa", "patch": "@@ -1833,7 +1833,7 @@ impl<'a> Parser<'a> {\n         Ok(MutTy { ty: t, mutbl: mutbl })\n     }\n \n-    fn is_named_argument(&mut self) -> bool {\n+    fn is_named_argument(&self) -> bool {\n         let offset = match self.token {\n             token::Interpolated(ref nt) => match **nt {\n                 token::NtPat(..) => return self.look_ahead(1, |t| t == &token::Colon),\n@@ -1881,8 +1881,6 @@ impl<'a> Parser<'a> {\n     /// This version of parse arg doesn't necessarily require identifier names.\n     fn parse_arg_general(&mut self, require_name: bool, is_trait_item: bool,\n                          allow_c_variadic: bool) -> PResult<'a, Arg> {\n-        maybe_whole!(self, NtArg, |x| x);\n-\n         if let Ok(Some(_)) = self.parse_self_arg() {\n             let mut err = self.struct_span_err(self.prev_span,\n                 \"unexpected `self` argument in function\");\n@@ -2345,27 +2343,27 @@ impl<'a> Parser<'a> {\n         })\n     }\n \n-    fn mk_expr(&mut self, span: Span, node: ExprKind, attrs: ThinVec<Attribute>) -> P<Expr> {\n+    fn mk_expr(&self, span: Span, node: ExprKind, attrs: ThinVec<Attribute>) -> P<Expr> {\n         P(Expr { node, span, attrs, id: ast::DUMMY_NODE_ID })\n     }\n \n-    fn mk_unary(&mut self, unop: ast::UnOp, expr: P<Expr>) -> ast::ExprKind {\n+    fn mk_unary(&self, unop: ast::UnOp, expr: P<Expr>) -> ast::ExprKind {\n         ExprKind::Unary(unop, expr)\n     }\n \n-    fn mk_binary(&mut self, binop: ast::BinOp, lhs: P<Expr>, rhs: P<Expr>) -> ast::ExprKind {\n+    fn mk_binary(&self, binop: ast::BinOp, lhs: P<Expr>, rhs: P<Expr>) -> ast::ExprKind {\n         ExprKind::Binary(binop, lhs, rhs)\n     }\n \n-    fn mk_call(&mut self, f: P<Expr>, args: Vec<P<Expr>>) -> ast::ExprKind {\n+    fn mk_call(&self, f: P<Expr>, args: Vec<P<Expr>>) -> ast::ExprKind {\n         ExprKind::Call(f, args)\n     }\n \n-    fn mk_index(&mut self, expr: P<Expr>, idx: P<Expr>) -> ast::ExprKind {\n+    fn mk_index(&self, expr: P<Expr>, idx: P<Expr>) -> ast::ExprKind {\n         ExprKind::Index(expr, idx)\n     }\n \n-    fn mk_range(&mut self,\n+    fn mk_range(&self,\n                     start: Option<P<Expr>>,\n                     end: Option<P<Expr>>,\n                     limits: RangeLimits)\n@@ -2377,7 +2375,7 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    fn mk_assign_op(&mut self, binop: ast::BinOp,\n+    fn mk_assign_op(&self, binop: ast::BinOp,\n                         lhs: P<Expr>, rhs: P<Expr>) -> ast::ExprKind {\n         ExprKind::AssignOp(binop, lhs, rhs)\n     }\n@@ -2517,13 +2515,12 @@ impl<'a> Parser<'a> {\n                     hi = path.span;\n                     return Ok(self.mk_expr(lo.to(hi), ExprKind::Path(Some(qself), path), attrs));\n                 }\n-                if self.span.rust_2018() && self.check_keyword(keywords::Async)\n-                {\n-                    if self.is_async_block() { // check for `async {` and `async move {`\n-                        return self.parse_async_block(attrs);\n+                if self.span.rust_2018() && self.check_keyword(keywords::Async) {\n+                    return if self.is_async_block() { // check for `async {` and `async move {`\n+                        self.parse_async_block(attrs)\n                     } else {\n-                        return self.parse_lambda_expr(attrs);\n-                    }\n+                        self.parse_lambda_expr(attrs)\n+                    };\n                 }\n                 if self.check_keyword(keywords::Move) || self.check_keyword(keywords::Static) {\n                     return self.parse_lambda_expr(attrs);\n@@ -3448,7 +3445,8 @@ impl<'a> Parser<'a> {\n             } else {\n                 self.restrictions\n             };\n-            if op.precedence() < min_prec {\n+            let prec = op.precedence();\n+            if prec < min_prec {\n                 break;\n             }\n             // Check for deprecated `...` syntax\n@@ -3489,8 +3487,7 @@ impl<'a> Parser<'a> {\n                 // We have 2 alternatives here: `x..y`/`x..=y` and `x..`/`x..=` The other\n                 // two variants are handled with `parse_prefix_range_expr` call above.\n                 let rhs = if self.is_at_start_of_range_notation_rhs() {\n-                    Some(self.parse_assoc_expr_with(op.precedence() + 1,\n-                                                    LhsExpr::NotYetParsed)?)\n+                    Some(self.parse_assoc_expr_with(prec + 1, LhsExpr::NotYetParsed)?)\n                 } else {\n                     None\n                 };\n@@ -3510,28 +3507,18 @@ impl<'a> Parser<'a> {\n                 break\n             }\n \n-            let rhs = match op.fixity() {\n-                Fixity::Right => self.with_res(\n-                    restrictions - Restrictions::STMT_EXPR,\n-                    |this| {\n-                        this.parse_assoc_expr_with(op.precedence(),\n-                            LhsExpr::NotYetParsed)\n-                }),\n-                Fixity::Left => self.with_res(\n-                    restrictions - Restrictions::STMT_EXPR,\n-                    |this| {\n-                        this.parse_assoc_expr_with(op.precedence() + 1,\n-                            LhsExpr::NotYetParsed)\n-                }),\n+            let fixity = op.fixity();\n+            let prec_adjustment = match fixity {\n+                Fixity::Right => 0,\n+                Fixity::Left => 1,\n                 // We currently have no non-associative operators that are not handled above by\n                 // the special cases. The code is here only for future convenience.\n-                Fixity::None => self.with_res(\n-                    restrictions - Restrictions::STMT_EXPR,\n-                    |this| {\n-                        this.parse_assoc_expr_with(op.precedence() + 1,\n-                            LhsExpr::NotYetParsed)\n-                }),\n-            }?;\n+                Fixity::None => 1,\n+            };\n+            let rhs = self.with_res(\n+                restrictions - Restrictions::STMT_EXPR,\n+                |this| this.parse_assoc_expr_with(prec + prec_adjustment, LhsExpr::NotYetParsed)\n+            )?;\n \n             // Make sure that the span of the parent node is larger than the span of lhs and rhs,\n             // including the attributes.\n@@ -3577,7 +3564,7 @@ impl<'a> Parser<'a> {\n                 }\n             };\n \n-            if op.fixity() == Fixity::None { break }\n+            if let Fixity::None = fixity { break }\n         }\n         Ok(lhs)\n     }\n@@ -3714,7 +3701,7 @@ impl<'a> Parser<'a> {\n     /// Produce an error if comparison operators are chained (RFC #558).\n     /// We only need to check lhs, not rhs, because all comparison ops\n     /// have same precedence and are left-associative\n-    fn check_no_chained_comparison(&mut self, lhs: &Expr, outer_op: &AssocOp) {\n+    fn check_no_chained_comparison(&self, lhs: &Expr, outer_op: &AssocOp) {\n         debug_assert!(outer_op.is_comparison(),\n                       \"check_no_chained_comparison: {:?} is not comparison\",\n                       outer_op);\n@@ -4053,8 +4040,6 @@ impl<'a> Parser<'a> {\n     }\n \n     crate fn parse_arm(&mut self) -> PResult<'a, Arm> {\n-        maybe_whole!(self, NtArm, |x| x);\n-\n         let attrs = self.parse_outer_attributes()?;\n         let pats = self.parse_pats()?;\n         let guard = if self.eat_keyword(keywords::If) {\n@@ -5011,7 +4996,7 @@ impl<'a> Parser<'a> {\n         })\n     }\n \n-    fn is_async_block(&mut self) -> bool {\n+    fn is_async_block(&self) -> bool {\n         self.token.is_keyword(keywords::Async) &&\n         (\n             ( // `async move {`\n@@ -5023,19 +5008,19 @@ impl<'a> Parser<'a> {\n         )\n     }\n \n-    fn is_async_fn(&mut self) -> bool {\n+    fn is_async_fn(&self) -> bool {\n         self.token.is_keyword(keywords::Async) &&\n             self.look_ahead(1, |t| t.is_keyword(keywords::Fn))\n     }\n \n-    fn is_do_catch_block(&mut self) -> bool {\n+    fn is_do_catch_block(&self) -> bool {\n         self.token.is_keyword(keywords::Do) &&\n         self.look_ahead(1, |t| t.is_keyword(keywords::Catch)) &&\n         self.look_ahead(2, |t| *t == token::OpenDelim(token::Brace)) &&\n         !self.restrictions.contains(Restrictions::NO_STRUCT_LITERAL)\n     }\n \n-    fn is_try_block(&mut self) -> bool {\n+    fn is_try_block(&self) -> bool {\n         self.token.is_keyword(keywords::Try) &&\n         self.look_ahead(1, |t| *t == token::OpenDelim(token::Brace)) &&\n         self.span.rust_2018() &&\n@@ -5057,7 +5042,7 @@ impl<'a> Parser<'a> {\n         self.look_ahead(1, |t| t.is_keyword(keywords::Type))\n     }\n \n-    fn is_auto_trait_item(&mut self) -> bool {\n+    fn is_auto_trait_item(&self) -> bool {\n         // auto trait\n         (self.token.is_keyword(keywords::Auto)\n             && self.look_ahead(1, |t| t.is_keyword(keywords::Trait)))\n@@ -5319,7 +5304,7 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Checks if this expression is a successfully parsed statement.\n-    fn expr_is_complete(&mut self, e: &Expr) -> bool {\n+    fn expr_is_complete(&self, e: &Expr) -> bool {\n         self.restrictions.contains(Restrictions::STMT_EXPR) &&\n             !classify::expr_requires_semi_to_be_stmt(e)\n     }\n@@ -5789,8 +5774,6 @@ impl<'a> Parser<'a> {\n     ///                  | ( < lifetimes , typaramseq ( , )? > )\n     /// where   typaramseq = ( typaram ) | ( typaram , typaramseq )\n     fn parse_generics(&mut self) -> PResult<'a, ast::Generics> {\n-        maybe_whole!(self, NtGenerics, |x| x);\n-\n         let span_lo = self.span;\n         if self.eat_lt() {\n             let params = self.parse_generic_params()?;\n@@ -6043,8 +6026,6 @@ impl<'a> Parser<'a> {\n     /// where T : Trait<U, V> + 'b, 'a : 'b\n     /// ```\n     fn parse_where_clause(&mut self) -> PResult<'a, WhereClause> {\n-        maybe_whole!(self, NtWhereClause, |x| x);\n-\n         let mut where_clause = WhereClause {\n             id: ast::DUMMY_NODE_ID,\n             predicates: Vec::new(),\n@@ -6391,7 +6372,7 @@ impl<'a> Parser<'a> {\n         Ok((id, generics))\n     }\n \n-    fn mk_item(&mut self, span: Span, ident: Ident, node: ItemKind, vis: Visibility,\n+    fn mk_item(&self, span: Span, ident: Ident, node: ItemKind, vis: Visibility,\n                attrs: Vec<Attribute>) -> P<Item> {\n         P(Item {\n             ident,\n@@ -6423,7 +6404,7 @@ impl<'a> Parser<'a> {\n \n     /// Returns `true` if we are looking at `const ID`\n     /// (returns `false` for things like `const fn`, etc.).\n-    fn is_const_item(&mut self) -> bool {\n+    fn is_const_item(&self) -> bool {\n         self.token.is_keyword(keywords::Const) &&\n             !self.look_ahead(1, |t| t.is_keyword(keywords::Fn)) &&\n             !self.look_ahead(1, |t| t.is_keyword(keywords::Unsafe))\n@@ -6531,7 +6512,7 @@ impl<'a> Parser<'a> {\n         })\n     }\n \n-    fn complain_if_pub_macro(&mut self, vis: &VisibilityKind, sp: Span) {\n+    fn complain_if_pub_macro(&self, vis: &VisibilityKind, sp: Span) {\n         match *vis {\n             VisibilityKind::Inherited => {}\n             _ => {\n@@ -6560,7 +6541,7 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    fn missing_assoc_item_kind_err(&mut self, item_type: &str, prev_span: Span)\n+    fn missing_assoc_item_kind_err(&self, item_type: &str, prev_span: Span)\n                                    -> DiagnosticBuilder<'a>\n     {\n         let expected_kinds = if item_type == \"extern\" {"}, {"sha": "049fb6cb78b84f241bc5144ae4771b2c6b5de822", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 4, "deletions": 10, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/4443957f272e304e083a8d98583e608d65a712aa/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4443957f272e304e083a8d98583e608d65a712aa/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=4443957f272e304e083a8d98583e608d65a712aa", "patch": "@@ -597,14 +597,12 @@ pub enum Nonterminal {\n     NtPath(ast::Path),\n     NtVis(ast::Visibility),\n     NtTT(TokenTree),\n-    // These are not exposed to macros, but are used by quasiquote.\n-    NtArm(ast::Arm),\n-    NtImplItem(ast::ImplItem),\n+    // Used only for passing items to proc macro attributes (they are not\n+    // strictly necessary for that, `Annotatable` can be converted into\n+    // tokens directly, but doing that naively regresses pretty-printing).\n     NtTraitItem(ast::TraitItem),\n+    NtImplItem(ast::ImplItem),\n     NtForeignItem(ast::ForeignItem),\n-    NtGenerics(ast::Generics),\n-    NtWhereClause(ast::WhereClause),\n-    NtArg(ast::Arg),\n }\n \n impl PartialEq for Nonterminal {\n@@ -637,13 +635,9 @@ impl fmt::Debug for Nonterminal {\n             NtMeta(..) => f.pad(\"NtMeta(..)\"),\n             NtPath(..) => f.pad(\"NtPath(..)\"),\n             NtTT(..) => f.pad(\"NtTT(..)\"),\n-            NtArm(..) => f.pad(\"NtArm(..)\"),\n             NtImplItem(..) => f.pad(\"NtImplItem(..)\"),\n             NtTraitItem(..) => f.pad(\"NtTraitItem(..)\"),\n             NtForeignItem(..) => f.pad(\"NtForeignItem(..)\"),\n-            NtGenerics(..) => f.pad(\"NtGenerics(..)\"),\n-            NtWhereClause(..) => f.pad(\"NtWhereClause(..)\"),\n-            NtArg(..) => f.pad(\"NtArg(..)\"),\n             NtVis(..) => f.pad(\"NtVis(..)\"),\n             NtLifetime(..) => f.pad(\"NtLifetime(..)\"),\n         }"}, {"sha": "86db7a673d471afb105089d2d4e9541029d790a8", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4443957f272e304e083a8d98583e608d65a712aa/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4443957f272e304e083a8d98583e608d65a712aa/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=4443957f272e304e083a8d98583e608d65a712aa", "patch": "@@ -263,12 +263,8 @@ pub fn nonterminal_to_string(nt: &Nonterminal) -> String {\n         token::NtLifetime(e)        => ident_to_string(e),\n         token::NtLiteral(ref e)     => expr_to_string(e),\n         token::NtTT(ref tree)       => tt_to_string(tree.clone()),\n-        token::NtArm(ref e)         => arm_to_string(e),\n         token::NtImplItem(ref e)    => impl_item_to_string(e),\n         token::NtTraitItem(ref e)   => trait_item_to_string(e),\n-        token::NtGenerics(ref e)    => generic_params_to_string(&e.params),\n-        token::NtWhereClause(ref e) => where_clause_to_string(e),\n-        token::NtArg(ref e)         => arg_to_string(e),\n         token::NtVis(ref e)         => vis_to_string(e),\n         token::NtForeignItem(ref e) => foreign_item_to_string(e),\n     }"}, {"sha": "fe4eaff742d623e8c227c60fdc25a7dbdb82e639", "filename": "src/test/ui/issues/issue-60662.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/4443957f272e304e083a8d98583e608d65a712aa/src%2Ftest%2Fui%2Fissues%2Fissue-60662.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4443957f272e304e083a8d98583e608d65a712aa/src%2Ftest%2Fui%2Fissues%2Fissue-60662.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-60662.rs?ref=4443957f272e304e083a8d98583e608d65a712aa", "patch": "@@ -0,0 +1,11 @@\n+// compile-pass\n+// compile-flags: -Z unpretty=hir\n+\n+#![feature(existential_type)]\n+\n+trait Animal {\n+}\n+\n+fn main() {\n+    pub existential type ServeFut: Animal;\n+}"}, {"sha": "5acfdf9ed5342ef16b3476111b125ceec5e65831", "filename": "src/test/ui/issues/issue-60662.stdout", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/4443957f272e304e083a8d98583e608d65a712aa/src%2Ftest%2Fui%2Fissues%2Fissue-60662.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/4443957f272e304e083a8d98583e608d65a712aa/src%2Ftest%2Fui%2Fissues%2Fissue-60662.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-60662.stdout?ref=4443957f272e304e083a8d98583e608d65a712aa", "patch": "@@ -0,0 +1,14 @@\n+// compile-pass\n+// compile-flags: -Z unpretty=hir\n+\n+#![feature(existential_type)]\n+#[prelude_import]\n+use ::std::prelude::v1::*;\n+#[macro_use]\n+extern crate std;\n+\n+trait Animal { }\n+\n+fn main() {\n+              pub existential type ServeFut : Animal;\n+          }"}]}