{"sha": "d4ca1cffce6f948e190c5910f5b08771bf30ca59", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ0Y2ExY2ZmY2U2Zjk0OGUxOTBjNTkxMGY1YjA4NzcxYmYzMGNhNTk=", "commit": {"author": {"name": "Bj\u00f6rn Steinbrink", "email": "bsteinbr@gmail.com", "date": "2015-03-20T23:21:38Z"}, "committer": {"name": "Bj\u00f6rn Steinbrink", "email": "bsteinbr@gmail.com", "date": "2015-03-21T09:46:52Z"}, "message": "Fix volatile / atomic ops on bools and small aggregates\n\nBoolean values and small aggregates have a different type in\nargs/allocas than in SSA values but the intrinsics for volatile and\natomic ops were missing the necessary casts to handle that.\n\nFixes #23550", "tree": {"sha": "72d1ce43994158d8a7e016e145462f170e43423f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/72d1ce43994158d8a7e016e145462f170e43423f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d4ca1cffce6f948e190c5910f5b08771bf30ca59", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d4ca1cffce6f948e190c5910f5b08771bf30ca59", "html_url": "https://github.com/rust-lang/rust/commit/d4ca1cffce6f948e190c5910f5b08771bf30ca59", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d4ca1cffce6f948e190c5910f5b08771bf30ca59/comments", "author": {"login": "dotdash", "id": 230962, "node_id": "MDQ6VXNlcjIzMDk2Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/230962?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dotdash", "html_url": "https://github.com/dotdash", "followers_url": "https://api.github.com/users/dotdash/followers", "following_url": "https://api.github.com/users/dotdash/following{/other_user}", "gists_url": "https://api.github.com/users/dotdash/gists{/gist_id}", "starred_url": "https://api.github.com/users/dotdash/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dotdash/subscriptions", "organizations_url": "https://api.github.com/users/dotdash/orgs", "repos_url": "https://api.github.com/users/dotdash/repos", "events_url": "https://api.github.com/users/dotdash/events{/privacy}", "received_events_url": "https://api.github.com/users/dotdash/received_events", "type": "User", "site_admin": false}, "committer": {"login": "dotdash", "id": 230962, "node_id": "MDQ6VXNlcjIzMDk2Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/230962?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dotdash", "html_url": "https://github.com/dotdash", "followers_url": "https://api.github.com/users/dotdash/followers", "following_url": "https://api.github.com/users/dotdash/following{/other_user}", "gists_url": "https://api.github.com/users/dotdash/gists{/gist_id}", "starred_url": "https://api.github.com/users/dotdash/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dotdash/subscriptions", "organizations_url": "https://api.github.com/users/dotdash/orgs", "repos_url": "https://api.github.com/users/dotdash/repos", "events_url": "https://api.github.com/users/dotdash/events{/privacy}", "received_events_url": "https://api.github.com/users/dotdash/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ecdf792d1dda479d04781e5750737aa6cc574119", "url": "https://api.github.com/repos/rust-lang/rust/commits/ecdf792d1dda479d04781e5750737aa6cc574119", "html_url": "https://github.com/rust-lang/rust/commit/ecdf792d1dda479d04781e5750737aa6cc574119"}], "stats": {"total": 161, "additions": 116, "deletions": 45}, "files": [{"sha": "ebd92faaf0f5328dda42d28c11fca41a6b1199ef", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 54, "deletions": 38, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/d4ca1cffce6f948e190c5910f5b08771bf30ca59/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4ca1cffce6f948e190c5910f5b08771bf30ca59/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=d4ca1cffce6f948e190c5910f5b08771bf30ca59", "patch": "@@ -983,56 +983,72 @@ pub fn load_if_immediate<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n /// gives us better information about what we are loading.\n pub fn load_ty<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n                            ptr: ValueRef, t: Ty<'tcx>) -> ValueRef {\n-    if type_is_zero_size(cx.ccx(), t) {\n-        C_undef(type_of::type_of(cx.ccx(), t))\n-    } else if type_is_immediate(cx.ccx(), t) && type_of::type_of(cx.ccx(), t).is_aggregate() {\n-        // We want to pass small aggregates as immediate values, but using an aggregate LLVM type\n-        // for this leads to bad optimizations, so its arg type is an appropriately sized integer\n-        // and we have to convert it\n-        Load(cx, BitCast(cx, ptr, type_of::arg_type_of(cx.ccx(), t).ptr_to()))\n-    } else {\n-        unsafe {\n-            let global = llvm::LLVMIsAGlobalVariable(ptr);\n-            if !global.is_null() && llvm::LLVMIsGlobalConstant(global) == llvm::True {\n-                let val = llvm::LLVMGetInitializer(global);\n-                if !val.is_null() {\n-                    // This could go into its own function, for DRY.\n-                    // (something like \"pre-store packing/post-load unpacking\")\n-                    if ty::type_is_bool(t) {\n-                        return Trunc(cx, val, Type::i1(cx.ccx()));\n-                    } else {\n-                        return val;\n-                    }\n-                }\n+    if cx.unreachable.get() || type_is_zero_size(cx.ccx(), t) {\n+        return C_undef(type_of::type_of(cx.ccx(), t));\n+    }\n+\n+    let ptr = to_arg_ty_ptr(cx, ptr, t);\n+\n+    if type_is_immediate(cx.ccx(), t) && type_of::type_of(cx.ccx(), t).is_aggregate() {\n+        return Load(cx, ptr);\n+    }\n+\n+    unsafe {\n+        let global = llvm::LLVMIsAGlobalVariable(ptr);\n+        if !global.is_null() && llvm::LLVMIsGlobalConstant(global) == llvm::True {\n+            let val = llvm::LLVMGetInitializer(global);\n+            if !val.is_null() {\n+                return from_arg_ty(cx, val, t);\n             }\n         }\n-        if ty::type_is_bool(t) {\n-            Trunc(cx, LoadRangeAssert(cx, ptr, 0, 2, llvm::False), Type::i1(cx.ccx()))\n-        } else if ty::type_is_char(t) {\n-            // a char is a Unicode codepoint, and so takes values from 0\n-            // to 0x10FFFF inclusive only.\n-            LoadRangeAssert(cx, ptr, 0, 0x10FFFF + 1, llvm::False)\n-        } else if (ty::type_is_region_ptr(t) || ty::type_is_unique(t))\n-                  && !common::type_is_fat_ptr(cx.tcx(), t) {\n-            LoadNonNull(cx, ptr)\n-        } else {\n-            Load(cx, ptr)\n-        }\n     }\n+\n+    let val =  if ty::type_is_bool(t) {\n+        LoadRangeAssert(cx, ptr, 0, 2, llvm::False)\n+    } else if ty::type_is_char(t) {\n+        // a char is a Unicode codepoint, and so takes values from 0\n+        // to 0x10FFFF inclusive only.\n+        LoadRangeAssert(cx, ptr, 0, 0x10FFFF + 1, llvm::False)\n+    } else if (ty::type_is_region_ptr(t) || ty::type_is_unique(t))\n+        && !common::type_is_fat_ptr(cx.tcx(), t) {\n+            LoadNonNull(cx, ptr)\n+    } else {\n+        Load(cx, ptr)\n+    };\n+\n+    from_arg_ty(cx, val, t)\n }\n \n /// Helper for storing values in memory. Does the necessary conversion if the in-memory type\n /// differs from the type used for SSA values.\n pub fn store_ty<'blk, 'tcx>(cx: Block<'blk, 'tcx>, v: ValueRef, dst: ValueRef, t: Ty<'tcx>) {\n-    if ty::type_is_bool(t) {\n-        Store(cx, ZExt(cx, v, Type::i8(cx.ccx())), dst);\n-    } else if type_is_immediate(cx.ccx(), t) && type_of::type_of(cx.ccx(), t).is_aggregate() {\n+    Store(cx, to_arg_ty(cx, v, t), to_arg_ty_ptr(cx, dst, t));\n+}\n+\n+pub fn to_arg_ty(bcx: Block, val: ValueRef, ty: Ty) -> ValueRef {\n+    if ty::type_is_bool(ty) {\n+        ZExt(bcx, val, Type::i8(bcx.ccx()))\n+    } else {\n+        val\n+    }\n+}\n+\n+pub fn from_arg_ty(bcx: Block, val: ValueRef, ty: Ty) -> ValueRef {\n+    if ty::type_is_bool(ty) {\n+        Trunc(bcx, val, Type::i1(bcx.ccx()))\n+    } else {\n+        val\n+    }\n+}\n+\n+pub fn to_arg_ty_ptr<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, ptr: ValueRef, ty: Ty<'tcx>) -> ValueRef {\n+    if type_is_immediate(bcx.ccx(), ty) && type_of::type_of(bcx.ccx(), ty).is_aggregate() {\n         // We want to pass small aggregates as immediate values, but using an aggregate LLVM type\n         // for this leads to bad optimizations, so its arg type is an appropriately sized integer\n         // and we have to convert it\n-        Store(cx, v, BitCast(cx, dst, type_of::arg_type_of(cx.ccx(), t).ptr_to()));\n+        BitCast(bcx, ptr, type_of::arg_type_of(bcx.ccx(), ty).ptr_to())\n     } else {\n-        Store(cx, v, dst);\n+        ptr\n     }\n }\n "}, {"sha": "d158cfa7b88765b77f12dba0808328ebd9ef630b", "filename": "src/librustc_trans/trans/intrinsic.rs", "status": "modified", "additions": 23, "deletions": 7, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/d4ca1cffce6f948e190c5910f5b08771bf30ca59/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4ca1cffce6f948e190c5910f5b08771bf30ca59/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs?ref=d4ca1cffce6f948e190c5910f5b08771bf30ca59", "patch": "@@ -446,10 +446,15 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                              call_debug_location)\n         }\n         (_, \"volatile_load\") => {\n-            VolatileLoad(bcx, llargs[0])\n+            let tp_ty = *substs.types.get(FnSpace, 0);\n+            let ptr = to_arg_ty_ptr(bcx, llargs[0], tp_ty);\n+            from_arg_ty(bcx, VolatileLoad(bcx, ptr), tp_ty)\n         },\n         (_, \"volatile_store\") => {\n-            VolatileStore(bcx, llargs[1], llargs[0]);\n+            let tp_ty = *substs.types.get(FnSpace, 0);\n+            let ptr = to_arg_ty_ptr(bcx, llargs[0], tp_ty);\n+            let val = to_arg_ty(bcx, llargs[1], tp_ty);\n+            VolatileStore(bcx, val, ptr);\n             C_nil(ccx)\n         },\n \n@@ -709,8 +714,11 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                             llvm::SequentiallyConsistent\n                     };\n \n-                    let res = AtomicCmpXchg(bcx, llargs[0], llargs[1],\n-                                            llargs[2], order,\n+                    let tp_ty = *substs.types.get(FnSpace, 0);\n+                    let ptr = to_arg_ty_ptr(bcx, llargs[0], tp_ty);\n+                    let cmp = to_arg_ty(bcx, llargs[1], tp_ty);\n+                    let src = to_arg_ty(bcx, llargs[2], tp_ty);\n+                    let res = AtomicCmpXchg(bcx, ptr, cmp, src, order,\n                                             strongest_failure_ordering);\n                     if unsafe { llvm::LLVMVersionMinor() >= 5 } {\n                         ExtractValue(bcx, res, 0)\n@@ -720,10 +728,15 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                 }\n \n                 \"load\" => {\n-                    AtomicLoad(bcx, llargs[0], order)\n+                    let tp_ty = *substs.types.get(FnSpace, 0);\n+                    let ptr = to_arg_ty_ptr(bcx, llargs[0], tp_ty);\n+                    from_arg_ty(bcx, AtomicLoad(bcx, ptr, order), tp_ty)\n                 }\n                 \"store\" => {\n-                    AtomicStore(bcx, llargs[1], llargs[0], order);\n+                    let tp_ty = *substs.types.get(FnSpace, 0);\n+                    let ptr = to_arg_ty_ptr(bcx, llargs[0], tp_ty);\n+                    let val = to_arg_ty(bcx, llargs[1], tp_ty);\n+                    AtomicStore(bcx, val, ptr, order);\n                     C_nil(ccx)\n                 }\n \n@@ -749,7 +762,10 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                         _ => ccx.sess().fatal(\"unknown atomic operation\")\n                     };\n \n-                    AtomicRMW(bcx, atom_op, llargs[0], llargs[1], order)\n+                    let tp_ty = *substs.types.get(FnSpace, 0);\n+                    let ptr = to_arg_ty_ptr(bcx, llargs[0], tp_ty);\n+                    let val = to_arg_ty(bcx, llargs[1], tp_ty);\n+                    AtomicRMW(bcx, atom_op, ptr, val, order)\n                 }\n             }\n "}, {"sha": "97357c1dba4674da12abf8aea1c12dc8721adb05", "filename": "src/test/run-pass/issue-23550.rs", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/d4ca1cffce6f948e190c5910f5b08771bf30ca59/src%2Ftest%2Frun-pass%2Fissue-23550.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4ca1cffce6f948e190c5910f5b08771bf30ca59/src%2Ftest%2Frun-pass%2Fissue-23550.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-23550.rs?ref=d4ca1cffce6f948e190c5910f5b08771bf30ca59", "patch": "@@ -0,0 +1,39 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(core)]\n+#![allow(warnings)]\n+\n+use std::intrinsics;\n+\n+#[derive(Copy)]\n+struct Wrap(i64);\n+\n+// These volatile and atomic intrinsics used to cause an ICE\n+\n+unsafe fn test_bool(p: &mut bool, v: bool) {\n+    intrinsics::volatile_load(p);\n+    intrinsics::volatile_store(p, v);\n+    intrinsics::atomic_load(p);\n+    intrinsics::atomic_cxchg(p, v, v);\n+    intrinsics::atomic_store(p, v);\n+    intrinsics::atomic_xchg(p, v);\n+}\n+\n+unsafe fn test_immediate_fca(p: &mut Wrap, v: Wrap) {\n+    intrinsics::volatile_load(p);\n+    intrinsics::volatile_store(p, v);\n+    intrinsics::atomic_load(p);\n+    intrinsics::atomic_cxchg(p, v, v);\n+    intrinsics::atomic_store(p, v);\n+    intrinsics::atomic_xchg(p, v);\n+}\n+\n+fn main() {}"}]}