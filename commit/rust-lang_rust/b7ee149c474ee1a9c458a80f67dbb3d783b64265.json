{"sha": "b7ee149c474ee1a9c458a80f67dbb3d783b64265", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI3ZWUxNDljNDc0ZWUxYTljNDU4YTgwZjY3ZGJiM2Q3ODNiNjQyNjU=", "commit": {"author": {"name": "kennytm", "email": "kennytm@gmail.com", "date": "2018-03-22T09:51:19Z"}, "committer": {"name": "kennytm", "email": "kennytm@gmail.com", "date": "2018-03-22T14:43:30Z"}, "message": "Rollup merge of #48939 - wesleywiser:incr_query_wf_checking, r=michaelwoerister\n\nQuerify WF-checking so it can be cached\n\nr? @michaelwoerister", "tree": {"sha": "163b760bc80a5977c9c93d0536bcd4b0a997f499", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/163b760bc80a5977c9c93d0536bcd4b0a997f499"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b7ee149c474ee1a9c458a80f67dbb3d783b64265", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEZ1R8CLMp8f2GxWoQ/vbIBR0OATwFAlqzwRIACgkQ/vbIBR0O\nATxQSA//d3zhn6jCDHbexZYqjfMIKaW7KO/0nc7kXP1TXV8vtDg83QrmRRY5apMY\niA6/mouIwBP5cx5GNDyyfN9JwjBydqCr4k8qLwAdbqPvyV5qxpcMy2C9oBE22xa4\n207UqqCcWJcObhIObw5NplZA6y5SU0WkluiJ/NwxuUmJ0YzeybXZAmFUCOg3MMM8\noa05LtIwCLa8/WHBDuiblyOh1D/g5hVQY0orhDtCa3wgWcBShCj10OvibYwGlBFM\nJvMudr5fgs6gB0/ONHW+4S02sDTe3RtaHyVMEFZwOycU80egM3flhQcVB0InsuW7\n57OUSXBP8AN9Jaw4ZkPH5shG26KuBAzg2q/YQgwJSmpSMh1YJcCXqvXnaSkgthzp\nu+vrCjrXFC4GRBLpU8X7x2RMEFO5Y+FMnNVzsELNh1FfEG8VU09VIhoiyd2hqOmh\noNTZYBMqlS9SH4S63LpBCGQrS/kAZwSYXshJheHnWd4y0FtLixEm2fcNG7YG4HTU\nvqskqkR5scdj6Yv9kYzF0c1HoBS7DCuF0lSfRsY0hVnjRVePvjdvf+a0pJxqn5TW\nRzqm5QajDaKn9tRn6iG9Szdtst8FGYqXbRp3LglqfibPF2DTq0jvYT7VEwAktCoG\ntQkw0B88X/C+zc6uS7KNrfwhnsgxjPDOGebqI/99UENoWNlFFZc=\n=9kqe\n-----END PGP SIGNATURE-----", "payload": "tree 163b760bc80a5977c9c93d0536bcd4b0a997f499\nparent d67084215d0b0d534104fc2957e7ced3f4d922a9\nparent b418b7ba0f7393d789860f96a718a4fba2729271\nauthor kennytm <kennytm@gmail.com> 1521712279 +0800\ncommitter kennytm <kennytm@gmail.com> 1521729810 +0800\n\nRollup merge of #48939 - wesleywiser:incr_query_wf_checking, r=michaelwoerister\n\nQuerify WF-checking so it can be cached\n\nr? @michaelwoerister\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b7ee149c474ee1a9c458a80f67dbb3d783b64265", "html_url": "https://github.com/rust-lang/rust/commit/b7ee149c474ee1a9c458a80f67dbb3d783b64265", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b7ee149c474ee1a9c458a80f67dbb3d783b64265/comments", "author": {"login": "kennytm", "id": 103023, "node_id": "MDQ6VXNlcjEwMzAyMw==", "avatar_url": "https://avatars.githubusercontent.com/u/103023?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kennytm", "html_url": "https://github.com/kennytm", "followers_url": "https://api.github.com/users/kennytm/followers", "following_url": "https://api.github.com/users/kennytm/following{/other_user}", "gists_url": "https://api.github.com/users/kennytm/gists{/gist_id}", "starred_url": "https://api.github.com/users/kennytm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kennytm/subscriptions", "organizations_url": "https://api.github.com/users/kennytm/orgs", "repos_url": "https://api.github.com/users/kennytm/repos", "events_url": "https://api.github.com/users/kennytm/events{/privacy}", "received_events_url": "https://api.github.com/users/kennytm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "kennytm", "id": 103023, "node_id": "MDQ6VXNlcjEwMzAyMw==", "avatar_url": "https://avatars.githubusercontent.com/u/103023?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kennytm", "html_url": "https://github.com/kennytm", "followers_url": "https://api.github.com/users/kennytm/followers", "following_url": "https://api.github.com/users/kennytm/following{/other_user}", "gists_url": "https://api.github.com/users/kennytm/gists{/gist_id}", "starred_url": "https://api.github.com/users/kennytm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kennytm/subscriptions", "organizations_url": "https://api.github.com/users/kennytm/orgs", "repos_url": "https://api.github.com/users/kennytm/repos", "events_url": "https://api.github.com/users/kennytm/events{/privacy}", "received_events_url": "https://api.github.com/users/kennytm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d67084215d0b0d534104fc2957e7ced3f4d922a9", "url": "https://api.github.com/repos/rust-lang/rust/commits/d67084215d0b0d534104fc2957e7ced3f4d922a9", "html_url": "https://github.com/rust-lang/rust/commit/d67084215d0b0d534104fc2957e7ced3f4d922a9"}, {"sha": "b418b7ba0f7393d789860f96a718a4fba2729271", "url": "https://api.github.com/repos/rust-lang/rust/commits/b418b7ba0f7393d789860f96a718a4fba2729271", "html_url": "https://github.com/rust-lang/rust/commit/b418b7ba0f7393d789860f96a718a4fba2729271"}], "stats": {"total": 1051, "additions": 545, "deletions": 506}, "files": [{"sha": "1e2e4e5a69fa1ad0b9ef05757976eabc03b236bc", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b7ee149c474ee1a9c458a80f67dbb3d783b64265/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7ee149c474ee1a9c458a80f67dbb3d783b64265/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=b7ee149c474ee1a9c458a80f67dbb3d783b64265", "patch": "@@ -579,6 +579,9 @@ define_dep_nodes!( <'tcx>\n     [] GetPanicStrategy(CrateNum),\n     [] IsNoBuiltins(CrateNum),\n     [] ImplDefaultness(DefId),\n+    [] CheckItemWellFormed(DefId),\n+    [] CheckTraitItemWellFormed(DefId),\n+    [] CheckImplItemWellFormed(DefId),\n     [] ReachableNonGenerics(CrateNum),\n     [] NativeLibraries(CrateNum),\n     [] PluginRegistrarFn(CrateNum),"}, {"sha": "6c3b4efb932ad891923f0bce0c88fa90ec4a2c7c", "filename": "src/librustc/ty/maps/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b7ee149c474ee1a9c458a80f67dbb3d783b64265/src%2Flibrustc%2Fty%2Fmaps%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7ee149c474ee1a9c458a80f67dbb3d783b64265/src%2Flibrustc%2Fty%2Fmaps%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fmod.rs?ref=b7ee149c474ee1a9c458a80f67dbb3d783b64265", "patch": "@@ -299,6 +299,10 @@ define_maps! { <'tcx>\n \n     [] fn impl_defaultness: ImplDefaultness(DefId) -> hir::Defaultness,\n \n+    [] fn check_item_well_formed: CheckItemWellFormed(DefId) -> (),\n+    [] fn check_trait_item_well_formed: CheckTraitItemWellFormed(DefId) -> (),\n+    [] fn check_impl_item_well_formed: CheckImplItemWellFormed(DefId) -> (),\n+\n     // The DefIds of all non-generic functions and statics in the given crate\n     // that can be reached from outside the crate.\n     //"}, {"sha": "4170fa7679716034468fdf9e8cb52d32403f1eed", "filename": "src/librustc/ty/maps/plumbing.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b7ee149c474ee1a9c458a80f67dbb3d783b64265/src%2Flibrustc%2Fty%2Fmaps%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7ee149c474ee1a9c458a80f67dbb3d783b64265/src%2Flibrustc%2Fty%2Fmaps%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fplumbing.rs?ref=b7ee149c474ee1a9c458a80f67dbb3d783b64265", "patch": "@@ -871,6 +871,9 @@ pub fn force_from_dep_node<'a, 'gcx, 'lcx>(tcx: TyCtxt<'a, 'gcx, 'lcx>,\n         DepKind::GetPanicStrategy => { force!(panic_strategy, krate!()); }\n         DepKind::IsNoBuiltins => { force!(is_no_builtins, krate!()); }\n         DepKind::ImplDefaultness => { force!(impl_defaultness, def_id!()); }\n+        DepKind::CheckItemWellFormed => { force!(check_item_well_formed, def_id!()); }\n+        DepKind::CheckTraitItemWellFormed => { force!(check_trait_item_well_formed, def_id!()); }\n+        DepKind::CheckImplItemWellFormed => { force!(check_impl_item_well_formed, def_id!()); }\n         DepKind::ReachableNonGenerics => { force!(reachable_non_generics, krate!()); }\n         DepKind::NativeLibraries => { force!(native_libraries, krate!()); }\n         DepKind::PluginRegistrarFn => { force!(plugin_registrar_fn, krate!()); }"}, {"sha": "eb61aa94cd76fbf571d153fd7bd00fa8c85ea451", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/b7ee149c474ee1a9c458a80f67dbb3d783b64265/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7ee149c474ee1a9c458a80f67dbb3d783b64265/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=b7ee149c474ee1a9c458a80f67dbb3d783b64265", "patch": "@@ -718,13 +718,28 @@ fn typeck_item_bodies<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, crate_num: CrateNum\n     })?)\n }\n \n+fn check_item_well_formed<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) {\n+    wfcheck::check_item_well_formed(tcx, def_id);\n+}\n+\n+fn check_trait_item_well_formed<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) {\n+    wfcheck::check_trait_item(tcx, def_id);\n+}\n+\n+fn check_impl_item_well_formed<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) {\n+    wfcheck::check_impl_item(tcx, def_id);\n+}\n+\n pub fn provide(providers: &mut Providers) {\n     *providers = Providers {\n         typeck_item_bodies,\n         typeck_tables_of,\n         has_typeck_tables,\n         adt_destructor,\n         used_trait_imports,\n+        check_item_well_formed,\n+        check_trait_item_well_formed,\n+        check_impl_item_well_formed,\n         ..*providers\n     };\n }"}, {"sha": "406ff9463a03c314f4da185ca068dd0ae2c24a37", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 520, "deletions": 506, "changes": 1026, "blob_url": "https://github.com/rust-lang/rust/blob/b7ee149c474ee1a9c458a80f67dbb3d783b64265/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7ee149c474ee1a9c458a80f67dbb3d783b64265/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=b7ee149c474ee1a9c458a80f67dbb3d783b64265", "patch": "@@ -26,17 +26,11 @@ use errors::{DiagnosticBuilder, DiagnosticId};\n use rustc::hir::intravisit::{self, Visitor, NestedVisitorMap};\n use rustc::hir;\n \n-pub struct CheckTypeWellFormedVisitor<'a, 'tcx:'a> {\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    code: ObligationCauseCode<'tcx>,\n-}\n-\n /// Helper type of a temporary returned by .for_item(...).\n /// Necessary because we can't write the following bound:\n /// F: for<'b, 'tcx> where 'gcx: 'tcx FnOnce(FnCtxt<'b, 'gcx, 'tcx>).\n struct CheckWfFcxBuilder<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     inherited: super::InheritedBuilder<'a, 'gcx, 'tcx>,\n-    code: ObligationCauseCode<'gcx>,\n     id: ast::NodeId,\n     span: Span,\n     param_env: ty::ParamEnv<'tcx>,\n@@ -45,585 +39,597 @@ struct CheckWfFcxBuilder<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n impl<'a, 'gcx, 'tcx> CheckWfFcxBuilder<'a, 'gcx, 'tcx> {\n     fn with_fcx<F>(&'tcx mut self, f: F) where\n         F: for<'b> FnOnce(&FnCtxt<'b, 'gcx, 'tcx>,\n-                          &mut CheckTypeWellFormedVisitor<'b, 'gcx>) -> Vec<Ty<'tcx>>\n+                         TyCtxt<'b, 'gcx, 'gcx>) -> Vec<Ty<'tcx>>\n     {\n-        let code = self.code.clone();\n         let id = self.id;\n         let span = self.span;\n         let param_env = self.param_env;\n         self.inherited.enter(|inh| {\n             let fcx = FnCtxt::new(&inh, param_env, id);\n-            let wf_tys = f(&fcx, &mut CheckTypeWellFormedVisitor {\n-                tcx: fcx.tcx.global_tcx(),\n-                code,\n-            });\n+            let wf_tys = f(&fcx, fcx.tcx.global_tcx());\n             fcx.select_all_obligations_or_error();\n             fcx.regionck_item(id, span, &wf_tys);\n         });\n     }\n }\n \n-impl<'a, 'gcx> CheckTypeWellFormedVisitor<'a, 'gcx> {\n-    pub fn new(tcx: TyCtxt<'a, 'gcx, 'gcx>)\n-               -> CheckTypeWellFormedVisitor<'a, 'gcx> {\n-        CheckTypeWellFormedVisitor {\n-            tcx,\n-            code: ObligationCauseCode::MiscObligation\n-        }\n-    }\n-\n-    /// Checks that the field types (in a struct def'n) or argument types (in an enum def'n) are\n-    /// well-formed, meaning that they do not require any constraints not declared in the struct\n-    /// definition itself. For example, this definition would be illegal:\n-    ///\n-    ///     struct Ref<'a, T> { x: &'a T }\n-    ///\n-    /// because the type did not declare that `T:'a`.\n-    ///\n-    /// We do this check as a pre-pass before checking fn bodies because if these constraints are\n-    /// not included it frequently leads to confusing errors in fn bodies. So it's better to check\n-    /// the types first.\n-    fn check_item_well_formed(&mut self, item: &hir::Item) {\n-        let tcx = self.tcx;\n-        debug!(\"check_item_well_formed(it.id={}, it.name={})\",\n-               item.id,\n-               tcx.item_path_str(tcx.hir.local_def_id(item.id)));\n-\n-        match item.node {\n-            // Right now we check that every default trait implementation\n-            // has an implementation of itself. Basically, a case like:\n-            //\n-            // `impl Trait for T {}`\n-            //\n-            // has a requirement of `T: Trait` which was required for default\n-            // method implementations. Although this could be improved now that\n-            // there's a better infrastructure in place for this, it's being left\n-            // for a follow-up work.\n-            //\n-            // Since there's such a requirement, we need to check *just* positive\n-            // implementations, otherwise things like:\n-            //\n-            // impl !Send for T {}\n-            //\n-            // won't be allowed unless there's an *explicit* implementation of `Send`\n-            // for `T`\n-            hir::ItemImpl(_, polarity, defaultness, _, ref trait_ref, ref self_ty, _) => {\n-                let is_auto = tcx.impl_trait_ref(tcx.hir.local_def_id(item.id))\n-                                 .map_or(false, |trait_ref| tcx.trait_is_auto(trait_ref.def_id));\n-                if let (hir::Defaultness::Default { .. }, true) = (defaultness, is_auto) {\n-                    tcx.sess.span_err(item.span, \"impls of auto traits cannot be default\");\n-                }\n-                if polarity == hir::ImplPolarity::Positive {\n-                    self.check_impl(item, self_ty, trait_ref);\n-                } else {\n-                    // FIXME(#27579) what amount of WF checking do we need for neg impls?\n-                    if trait_ref.is_some() && !is_auto {\n-                        span_err!(tcx.sess, item.span, E0192,\n-                                  \"negative impls are only allowed for \\\n-                                   auto traits (e.g., `Send` and `Sync`)\")\n-                    }\n-                }\n-            }\n-            hir::ItemFn(..) => {\n-                self.check_item_fn(item);\n-            }\n-            hir::ItemStatic(..) => {\n-                self.check_item_type(item);\n+/// Checks that the field types (in a struct def'n) or argument types (in an enum def'n) are\n+/// well-formed, meaning that they do not require any constraints not declared in the struct\n+/// definition itself. For example, this definition would be illegal:\n+///\n+///     struct Ref<'a, T> { x: &'a T }\n+///\n+/// because the type did not declare that `T:'a`.\n+///\n+/// We do this check as a pre-pass before checking fn bodies because if these constraints are\n+/// not included it frequently leads to confusing errors in fn bodies. So it's better to check\n+/// the types first.\n+pub fn check_item_well_formed<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) {\n+    let node_id = tcx.hir.as_local_node_id(def_id).unwrap();\n+    let item = tcx.hir.expect_item(node_id);\n+\n+    debug!(\"check_item_well_formed(it.id={}, it.name={})\",\n+            item.id,\n+            tcx.item_path_str(def_id));\n+\n+    match item.node {\n+        // Right now we check that every default trait implementation\n+        // has an implementation of itself. Basically, a case like:\n+        //\n+        // `impl Trait for T {}`\n+        //\n+        // has a requirement of `T: Trait` which was required for default\n+        // method implementations. Although this could be improved now that\n+        // there's a better infrastructure in place for this, it's being left\n+        // for a follow-up work.\n+        //\n+        // Since there's such a requirement, we need to check *just* positive\n+        // implementations, otherwise things like:\n+        //\n+        // impl !Send for T {}\n+        //\n+        // won't be allowed unless there's an *explicit* implementation of `Send`\n+        // for `T`\n+        hir::ItemImpl(_, polarity, defaultness, _, ref trait_ref, ref self_ty, _) => {\n+            let is_auto = tcx.impl_trait_ref(tcx.hir.local_def_id(item.id))\n+                                .map_or(false, |trait_ref| tcx.trait_is_auto(trait_ref.def_id));\n+            if let (hir::Defaultness::Default { .. }, true) = (defaultness, is_auto) {\n+                tcx.sess.span_err(item.span, \"impls of auto traits cannot be default\");\n             }\n-            hir::ItemConst(..) => {\n-                self.check_item_type(item);\n+            if polarity == hir::ImplPolarity::Positive {\n+                check_impl(tcx, item, self_ty, trait_ref);\n+            } else {\n+                // FIXME(#27579) what amount of WF checking do we need for neg impls?\n+                if trait_ref.is_some() && !is_auto {\n+                    span_err!(tcx.sess, item.span, E0192,\n+                                \"negative impls are only allowed for \\\n+                                auto traits (e.g., `Send` and `Sync`)\")\n+                }\n             }\n-            hir::ItemStruct(ref struct_def, ref ast_generics) => {\n-                self.check_type_defn(item, false, |fcx| {\n-                    vec![fcx.non_enum_variant(struct_def)]\n-                });\n+        }\n+        hir::ItemFn(..) => {\n+            check_item_fn(tcx, item);\n+        }\n+        hir::ItemStatic(..) => {\n+            check_item_type(tcx, item);\n+        }\n+        hir::ItemConst(..) => {\n+            check_item_type(tcx, item);\n+        }\n+        hir::ItemStruct(ref struct_def, ref ast_generics) => {\n+            check_type_defn(tcx, item, false, |fcx| {\n+                vec![fcx.non_enum_variant(struct_def)]\n+            });\n \n-                self.check_variances_for_type_defn(item, ast_generics);\n-            }\n-            hir::ItemUnion(ref struct_def, ref ast_generics) => {\n-                self.check_type_defn(item, true, |fcx| {\n-                    vec![fcx.non_enum_variant(struct_def)]\n-                });\n+            check_variances_for_type_defn(tcx, item, ast_generics);\n+        }\n+        hir::ItemUnion(ref struct_def, ref ast_generics) => {\n+            check_type_defn(tcx, item, true, |fcx| {\n+                vec![fcx.non_enum_variant(struct_def)]\n+            });\n \n-                self.check_variances_for_type_defn(item, ast_generics);\n-            }\n-            hir::ItemEnum(ref enum_def, ref ast_generics) => {\n-                self.check_type_defn(item, true, |fcx| {\n-                    fcx.enum_variants(enum_def)\n-                });\n+            check_variances_for_type_defn(tcx, item, ast_generics);\n+        }\n+        hir::ItemEnum(ref enum_def, ref ast_generics) => {\n+            check_type_defn(tcx, item, true, |fcx| {\n+                fcx.enum_variants(enum_def)\n+            });\n \n-                self.check_variances_for_type_defn(item, ast_generics);\n-            }\n-            hir::ItemTrait(..) => {\n-                self.check_trait(item);\n-            }\n-            _ => {}\n+            check_variances_for_type_defn(tcx, item, ast_generics);\n         }\n+        hir::ItemTrait(..) => {\n+            check_trait(tcx, item);\n+        }\n+        _ => {}\n     }\n+}\n \n-    fn check_associated_item(&mut self,\n-                             item_id: ast::NodeId,\n-                             span: Span,\n-                             sig_if_method: Option<&hir::MethodSig>) {\n-        let code = self.code.clone();\n-        self.for_id(item_id, span).with_fcx(|fcx, this| {\n-            let item = fcx.tcx.associated_item(fcx.tcx.hir.local_def_id(item_id));\n-\n-            let (mut implied_bounds, self_ty) = match item.container {\n-                ty::TraitContainer(_) => (vec![], fcx.tcx.mk_self_type()),\n-                ty::ImplContainer(def_id) => (fcx.impl_implied_bounds(def_id, span),\n-                                              fcx.tcx.type_of(def_id))\n-            };\n+pub fn check_trait_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) {\n+    let node_id = tcx.hir.as_local_node_id(def_id).unwrap();\n+    let trait_item = tcx.hir.expect_trait_item(node_id);\n+\n+    let method_sig = match trait_item.node {\n+        hir::TraitItemKind::Method(ref sig, _) => Some(sig),\n+        _ => None\n+    };\n+    check_associated_item(tcx, trait_item.id, trait_item.span, method_sig);\n+}\n+\n+pub fn check_impl_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) {\n+    let node_id = tcx.hir.as_local_node_id(def_id).unwrap();\n+    let impl_item = tcx.hir.expect_impl_item(node_id);\n+\n+    let method_sig = match impl_item.node {\n+        hir::ImplItemKind::Method(ref sig, _) => Some(sig),\n+        _ => None\n+    };\n+    check_associated_item(tcx, impl_item.id, impl_item.span, method_sig);\n+}\n+\n+fn check_associated_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                            item_id: ast::NodeId,\n+                            span: Span,\n+                            sig_if_method: Option<&hir::MethodSig>) {\n+    let code = ObligationCauseCode::MiscObligation;\n+    for_id(tcx, item_id, span).with_fcx(|fcx, tcx| {\n+        let item = fcx.tcx.associated_item(fcx.tcx.hir.local_def_id(item_id));\n+\n+        let (mut implied_bounds, self_ty) = match item.container {\n+            ty::TraitContainer(_) => (vec![], fcx.tcx.mk_self_type()),\n+            ty::ImplContainer(def_id) => (fcx.impl_implied_bounds(def_id, span),\n+                                            fcx.tcx.type_of(def_id))\n+        };\n \n-            match item.kind {\n-                ty::AssociatedKind::Const => {\n+        match item.kind {\n+            ty::AssociatedKind::Const => {\n+                let ty = fcx.tcx.type_of(item.def_id);\n+                let ty = fcx.normalize_associated_types_in(span, &ty);\n+                fcx.register_wf_obligation(ty, span, code.clone());\n+            }\n+            ty::AssociatedKind::Method => {\n+                reject_shadowing_type_parameters(fcx.tcx, item.def_id);\n+                let sig = fcx.tcx.fn_sig(item.def_id);\n+                let sig = fcx.normalize_associated_types_in(span, &sig);\n+                check_fn_or_method(tcx, fcx, span, sig,\n+                                        item.def_id, &mut implied_bounds);\n+                let sig_if_method = sig_if_method.expect(\"bad signature for method\");\n+                check_method_receiver(fcx, sig_if_method, &item, self_ty);\n+            }\n+            ty::AssociatedKind::Type => {\n+                if item.defaultness.has_value() {\n                     let ty = fcx.tcx.type_of(item.def_id);\n                     let ty = fcx.normalize_associated_types_in(span, &ty);\n                     fcx.register_wf_obligation(ty, span, code.clone());\n                 }\n-                ty::AssociatedKind::Method => {\n-                    reject_shadowing_type_parameters(fcx.tcx, item.def_id);\n-                    let sig = fcx.tcx.fn_sig(item.def_id);\n-                    let sig = fcx.normalize_associated_types_in(span, &sig);\n-                    this.check_fn_or_method(fcx, span, sig,\n-                                            item.def_id, &mut implied_bounds);\n-                    let sig_if_method = sig_if_method.expect(\"bad signature for method\");\n-                    this.check_method_receiver(fcx, sig_if_method, &item, self_ty);\n-                }\n-                ty::AssociatedKind::Type => {\n-                    if item.defaultness.has_value() {\n-                        let ty = fcx.tcx.type_of(item.def_id);\n-                        let ty = fcx.normalize_associated_types_in(span, &ty);\n-                        fcx.register_wf_obligation(ty, span, code.clone());\n-                    }\n-                }\n             }\n+        }\n \n-            implied_bounds\n-        })\n-    }\n-\n-    fn for_item<'tcx>(&self, item: &hir::Item)\n-                      -> CheckWfFcxBuilder<'a, 'gcx, 'tcx> {\n-        self.for_id(item.id, item.span)\n-    }\n+        implied_bounds\n+    })\n+}\n \n-    fn for_id<'tcx>(&self, id: ast::NodeId, span: Span)\n+fn for_item<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'gcx>, item: &hir::Item)\n                     -> CheckWfFcxBuilder<'a, 'gcx, 'tcx> {\n-        let def_id = self.tcx.hir.local_def_id(id);\n-        CheckWfFcxBuilder {\n-            inherited: Inherited::build(self.tcx, def_id),\n-            code: self.code.clone(),\n-            id,\n-            span,\n-            param_env: self.tcx.param_env(def_id),\n-        }\n+    for_id(tcx, item.id, item.span)\n+}\n+\n+fn for_id<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'gcx>, id: ast::NodeId, span: Span)\n+                -> CheckWfFcxBuilder<'a, 'gcx, 'tcx> {\n+    let def_id = tcx.hir.local_def_id(id);\n+    CheckWfFcxBuilder {\n+        inherited: Inherited::build(tcx, def_id),\n+        id,\n+        span,\n+        param_env: tcx.param_env(def_id),\n     }\n+}\n \n-    /// In a type definition, we check that to ensure that the types of the fields are well-formed.\n-    fn check_type_defn<F>(&mut self, item: &hir::Item, all_sized: bool, mut lookup_fields: F)\n-        where F: for<'fcx, 'tcx> FnMut(&FnCtxt<'fcx, 'gcx, 'tcx>) -> Vec<AdtVariant<'tcx>>\n-    {\n-        self.for_item(item).with_fcx(|fcx, this| {\n-            let variants = lookup_fields(fcx);\n-            let def_id = fcx.tcx.hir.local_def_id(item.id);\n-            let packed = fcx.tcx.adt_def(def_id).repr.packed();\n-\n-            for variant in &variants {\n-                // For DST, or when drop needs to copy things around, all\n-                // intermediate types must be sized.\n-                let needs_drop_copy = || {\n-                    packed && {\n-                        let ty = variant.fields.last().unwrap().ty;\n-                        let ty = fcx.tcx.erase_regions(&ty).lift_to_tcx(this.tcx)\n-                            .unwrap_or_else(|| {\n-                                span_bug!(item.span, \"inference variables in {:?}\", ty)\n-                            });\n-                        ty.needs_drop(this.tcx, this.tcx.param_env(def_id))\n-                    }\n-                };\n-                let unsized_len = if\n-                    all_sized ||\n-                    variant.fields.is_empty() ||\n-                    needs_drop_copy()\n-                {\n-                    0\n-                } else {\n-                    1\n-                };\n-                for field in &variant.fields[..variant.fields.len() - unsized_len] {\n-                    fcx.register_bound(\n-                        field.ty,\n-                        fcx.tcx.require_lang_item(lang_items::SizedTraitLangItem),\n-                        traits::ObligationCause::new(field.span,\n-                                                     fcx.body_id,\n-                                                     traits::FieldSized(match item.node.adt_kind() {\n-                                                        Some(i) => i,\n-                                                        None => bug!(),\n-                                                     })));\n+/// In a type definition, we check that to ensure that the types of the fields are well-formed.\n+fn check_type_defn<'a, 'tcx, F>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                item: &hir::Item, all_sized: bool, mut lookup_fields: F)\n+    where F: for<'fcx, 'gcx, 'tcx2> FnMut(&FnCtxt<'fcx, 'gcx, 'tcx2>) -> Vec<AdtVariant<'tcx2>>\n+{\n+    for_item(tcx, item).with_fcx(|fcx, fcx_tcx| {\n+        let variants = lookup_fields(fcx);\n+        let def_id = fcx.tcx.hir.local_def_id(item.id);\n+        let packed = fcx.tcx.adt_def(def_id).repr.packed();\n+\n+        for variant in &variants {\n+            // For DST, or when drop needs to copy things around, all\n+            // intermediate types must be sized.\n+            let needs_drop_copy = || {\n+                packed && {\n+                    let ty = variant.fields.last().unwrap().ty;\n+                    let ty = fcx.tcx.erase_regions(&ty).lift_to_tcx(fcx_tcx)\n+                        .unwrap_or_else(|| {\n+                            span_bug!(item.span, \"inference variables in {:?}\", ty)\n+                        });\n+                    ty.needs_drop(fcx_tcx, fcx_tcx.param_env(def_id))\n                 }\n+            };\n+            let unsized_len = if\n+                all_sized ||\n+                variant.fields.is_empty() ||\n+                needs_drop_copy()\n+            {\n+                0\n+            } else {\n+                1\n+            };\n+            for field in &variant.fields[..variant.fields.len() - unsized_len] {\n+                fcx.register_bound(\n+                    field.ty,\n+                    fcx.tcx.require_lang_item(lang_items::SizedTraitLangItem),\n+                    traits::ObligationCause::new(field.span,\n+                                                    fcx.body_id,\n+                                                    traits::FieldSized(match item.node.adt_kind() {\n+                                                    Some(i) => i,\n+                                                    None => bug!(),\n+                                                    })));\n+            }\n \n-                // All field types must be well-formed.\n-                for field in &variant.fields {\n-                    fcx.register_wf_obligation(field.ty, field.span, this.code.clone())\n-                }\n+            // All field types must be well-formed.\n+            for field in &variant.fields {\n+                fcx.register_wf_obligation(field.ty, field.span,\n+                    ObligationCauseCode::MiscObligation)\n             }\n+        }\n \n-            self.check_where_clauses(fcx, item.span, def_id);\n+        check_where_clauses(tcx, fcx, item.span, def_id);\n \n-            vec![] // no implied bounds in a struct def'n\n-        });\n-    }\n+        vec![] // no implied bounds in a struct def'n\n+    });\n+}\n \n-    fn check_trait(&mut self, item: &hir::Item) {\n-        let trait_def_id = self.tcx.hir.local_def_id(item.id);\n-        self.for_item(item).with_fcx(|fcx, _| {\n-            self.check_where_clauses(fcx, item.span, trait_def_id);\n-            vec![]\n-        });\n-    }\n+fn check_trait<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, item: &hir::Item) {\n+    let trait_def_id = tcx.hir.local_def_id(item.id);\n+    for_item(tcx, item).with_fcx(|fcx, _| {\n+        check_where_clauses(tcx, fcx, item.span, trait_def_id);\n+        vec![]\n+    });\n+}\n \n-    fn check_item_fn(&mut self, item: &hir::Item) {\n-        self.for_item(item).with_fcx(|fcx, this| {\n-            let def_id = fcx.tcx.hir.local_def_id(item.id);\n-            let sig = fcx.tcx.fn_sig(def_id);\n-            let sig = fcx.normalize_associated_types_in(item.span, &sig);\n-            let mut implied_bounds = vec![];\n-            this.check_fn_or_method(fcx, item.span, sig,\n-                                    def_id, &mut implied_bounds);\n-            implied_bounds\n-        })\n-    }\n+fn check_item_fn<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, item: &hir::Item) {\n+    for_item(tcx, item).with_fcx(|fcx, tcx| {\n+        let def_id = fcx.tcx.hir.local_def_id(item.id);\n+        let sig = fcx.tcx.fn_sig(def_id);\n+        let sig = fcx.normalize_associated_types_in(item.span, &sig);\n+        let mut implied_bounds = vec![];\n+        check_fn_or_method(tcx, fcx, item.span, sig,\n+                                def_id, &mut implied_bounds);\n+        implied_bounds\n+    })\n+}\n \n-    fn check_item_type(&mut self,\n-                       item: &hir::Item)\n-    {\n-        debug!(\"check_item_type: {:?}\", item);\n+fn check_item_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                    item: &hir::Item)\n+{\n+    debug!(\"check_item_type: {:?}\", item);\n \n-        self.for_item(item).with_fcx(|fcx, this| {\n-            let ty = fcx.tcx.type_of(fcx.tcx.hir.local_def_id(item.id));\n-            let item_ty = fcx.normalize_associated_types_in(item.span, &ty);\n+    for_item(tcx, item).with_fcx(|fcx, _this| {\n+        let ty = fcx.tcx.type_of(fcx.tcx.hir.local_def_id(item.id));\n+        let item_ty = fcx.normalize_associated_types_in(item.span, &ty);\n \n-            fcx.register_wf_obligation(item_ty, item.span, this.code.clone());\n+        fcx.register_wf_obligation(item_ty, item.span, ObligationCauseCode::MiscObligation);\n \n-            vec![] // no implied bounds in a const etc\n-        });\n-    }\n+        vec![] // no implied bounds in a const etc\n+    });\n+}\n \n-    fn check_impl(&mut self,\n-                  item: &hir::Item,\n-                  ast_self_ty: &hir::Ty,\n-                  ast_trait_ref: &Option<hir::TraitRef>)\n-    {\n-        debug!(\"check_impl: {:?}\", item);\n-\n-        self.for_item(item).with_fcx(|fcx, this| {\n-            let item_def_id = fcx.tcx.hir.local_def_id(item.id);\n-\n-            match *ast_trait_ref {\n-                Some(ref ast_trait_ref) => {\n-                    let trait_ref = fcx.tcx.impl_trait_ref(item_def_id).unwrap();\n-                    let trait_ref =\n-                        fcx.normalize_associated_types_in(\n-                            ast_trait_ref.path.span, &trait_ref);\n-                    let obligations =\n-                        ty::wf::trait_obligations(fcx,\n-                                                  fcx.param_env,\n-                                                  fcx.body_id,\n-                                                  &trait_ref,\n-                                                  ast_trait_ref.path.span);\n-                    for obligation in obligations {\n-                        fcx.register_predicate(obligation);\n-                    }\n-                }\n-                None => {\n-                    let self_ty = fcx.tcx.type_of(item_def_id);\n-                    let self_ty = fcx.normalize_associated_types_in(item.span, &self_ty);\n-                    fcx.register_wf_obligation(self_ty, ast_self_ty.span, this.code.clone());\n+fn check_impl<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                item: &hir::Item,\n+                ast_self_ty: &hir::Ty,\n+                ast_trait_ref: &Option<hir::TraitRef>)\n+{\n+    debug!(\"check_impl: {:?}\", item);\n+\n+    for_item(tcx, item).with_fcx(|fcx, tcx| {\n+        let item_def_id = fcx.tcx.hir.local_def_id(item.id);\n+\n+        match *ast_trait_ref {\n+            Some(ref ast_trait_ref) => {\n+                let trait_ref = fcx.tcx.impl_trait_ref(item_def_id).unwrap();\n+                let trait_ref =\n+                    fcx.normalize_associated_types_in(\n+                        ast_trait_ref.path.span, &trait_ref);\n+                let obligations =\n+                    ty::wf::trait_obligations(fcx,\n+                                                fcx.param_env,\n+                                                fcx.body_id,\n+                                                &trait_ref,\n+                                                ast_trait_ref.path.span);\n+                for obligation in obligations {\n+                    fcx.register_predicate(obligation);\n                 }\n             }\n+            None => {\n+                let self_ty = fcx.tcx.type_of(item_def_id);\n+                let self_ty = fcx.normalize_associated_types_in(item.span, &self_ty);\n+                fcx.register_wf_obligation(self_ty, ast_self_ty.span,\n+                    ObligationCauseCode::MiscObligation);\n+            }\n+        }\n \n-            this.check_where_clauses(fcx, item.span, item_def_id);\n+        check_where_clauses(tcx, fcx, item.span, item_def_id);\n \n-            fcx.impl_implied_bounds(item_def_id, item.span)\n-        });\n-    }\n+        fcx.impl_implied_bounds(item_def_id, item.span)\n+    });\n+}\n \n-    /// Checks where clauses and inline bounds that are declared on def_id.\n-    fn check_where_clauses<'fcx, 'tcx>(&mut self,\n-                                       fcx: &FnCtxt<'fcx, 'gcx, 'tcx>,\n-                                       span: Span,\n-                                       def_id: DefId) {\n-        use ty::subst::Subst;\n-        use rustc::ty::TypeFoldable;\n-\n-        let mut predicates = fcx.tcx.predicates_of(def_id);\n-        let mut substituted_predicates = Vec::new();\n-\n-        let generics = self.tcx.generics_of(def_id);\n-        let is_our_default = |def: &ty::TypeParameterDef|\n-                                def.has_default && def.index >= generics.parent_count() as u32;\n-\n-        // Check that concrete defaults are well-formed. See test `type-check-defaults.rs`.\n-        // For example this forbids the declaration:\n-        // struct Foo<T = Vec<[u32]>> { .. }\n-        // Here the default `Vec<[u32]>` is not WF because `[u32]: Sized` does not hold.\n-        for d in generics.types.iter().cloned().filter(is_our_default).map(|p| p.def_id) {\n-            let ty = fcx.tcx.type_of(d);\n-            // ignore dependent defaults -- that is, where the default of one type\n-            // parameter includes another (e.g., <T, U = T>). In those cases, we can't\n-            // be sure if it will error or not as user might always specify the other.\n-            if !ty.needs_subst() {\n-                fcx.register_wf_obligation(ty, fcx.tcx.def_span(d), self.code.clone());\n-            }\n+/// Checks where clauses and inline bounds that are declared on def_id.\n+fn check_where_clauses<'a, 'gcx, 'fcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'gcx>,\n+                                    fcx: &FnCtxt<'fcx, 'gcx, 'tcx>,\n+                                    span: Span,\n+                                    def_id: DefId) {\n+    use ty::subst::Subst;\n+    use rustc::ty::TypeFoldable;\n+\n+    let mut predicates = fcx.tcx.predicates_of(def_id);\n+    let mut substituted_predicates = Vec::new();\n+\n+    let generics = tcx.generics_of(def_id);\n+    let is_our_default = |def: &ty::TypeParameterDef|\n+                            def.has_default && def.index >= generics.parent_count() as u32;\n+\n+    // Check that concrete defaults are well-formed. See test `type-check-defaults.rs`.\n+    // For example this forbids the declaration:\n+    // struct Foo<T = Vec<[u32]>> { .. }\n+    // Here the default `Vec<[u32]>` is not WF because `[u32]: Sized` does not hold.\n+    for d in generics.types.iter().cloned().filter(is_our_default).map(|p| p.def_id) {\n+        let ty = fcx.tcx.type_of(d);\n+        // ignore dependent defaults -- that is, where the default of one type\n+        // parameter includes another (e.g., <T, U = T>). In those cases, we can't\n+        // be sure if it will error or not as user might always specify the other.\n+        if !ty.needs_subst() {\n+            fcx.register_wf_obligation(ty, fcx.tcx.def_span(d),\n+                ObligationCauseCode::MiscObligation);\n         }\n+    }\n \n-        // Check that trait predicates are WF when params are substituted by their defaults.\n-        // We don't want to overly constrain the predicates that may be written but we want to\n-        // catch cases where a default my never be applied such as `struct Foo<T: Copy = String>`.\n-        // Therefore we check if a predicate which contains a single type param\n-        // with a concrete default is WF with that default substituted.\n-        // For more examples see tests `defaults-well-formedness.rs` and `type-check-defaults.rs`.\n-        //\n-        // First we build the defaulted substitution.\n-        let substs = ty::subst::Substs::for_item(fcx.tcx, def_id, |def, _| {\n-                // All regions are identity.\n-                fcx.tcx.mk_region(ty::ReEarlyBound(def.to_early_bound_region_data()))\n-            }, |def, _| {\n-                // If the param has a default,\n-                if is_our_default(def) {\n-                    let default_ty = fcx.tcx.type_of(def.def_id);\n-                    // and it's not a dependent default\n-                    if !default_ty.needs_subst() {\n-                        // then substitute with the default.\n-                        return default_ty;\n-                    }\n+    // Check that trait predicates are WF when params are substituted by their defaults.\n+    // We don't want to overly constrain the predicates that may be written but we want to\n+    // catch cases where a default my never be applied such as `struct Foo<T: Copy = String>`.\n+    // Therefore we check if a predicate which contains a single type param\n+    // with a concrete default is WF with that default substituted.\n+    // For more examples see tests `defaults-well-formedness.rs` and `type-check-defaults.rs`.\n+    //\n+    // First we build the defaulted substitution.\n+    let substs = ty::subst::Substs::for_item(fcx.tcx, def_id, |def, _| {\n+            // All regions are identity.\n+            fcx.tcx.mk_region(ty::ReEarlyBound(def.to_early_bound_region_data()))\n+        }, |def, _| {\n+            // If the param has a default,\n+            if is_our_default(def) {\n+                let default_ty = fcx.tcx.type_of(def.def_id);\n+                // and it's not a dependent default\n+                if !default_ty.needs_subst() {\n+                    // then substitute with the default.\n+                    return default_ty;\n                 }\n-                // Mark unwanted params as err.\n-                fcx.tcx.types.err\n-            });\n-        // Now we build the substituted predicates.\n-        for &pred in predicates.predicates.iter() {\n-            struct CountParams { params: FxHashSet<u32> }\n-            impl<'tcx> ty::fold::TypeVisitor<'tcx> for CountParams {\n-                fn visit_ty(&mut self, t: Ty<'tcx>) -> bool {\n-                    match t.sty {\n-                        ty::TyParam(p) => {\n-                            self.params.insert(p.idx);\n-                            t.super_visit_with(self)\n-                        }\n-                        _ => t.super_visit_with(self)\n+            }\n+            // Mark unwanted params as err.\n+            fcx.tcx.types.err\n+        });\n+    // Now we build the substituted predicates.\n+    for &pred in predicates.predicates.iter() {\n+        struct CountParams { params: FxHashSet<u32> }\n+        impl<'tcx> ty::fold::TypeVisitor<'tcx> for CountParams {\n+            fn visit_ty(&mut self, t: Ty<'tcx>) -> bool {\n+                match t.sty {\n+                    ty::TyParam(p) => {\n+                        self.params.insert(p.idx);\n+                        t.super_visit_with(self)\n                     }\n+                    _ => t.super_visit_with(self)\n                 }\n             }\n-            let mut param_count = CountParams { params: FxHashSet() };\n-            pred.visit_with(&mut param_count);\n-            let substituted_pred = pred.subst(fcx.tcx, substs);\n-            // Don't check non-defaulted params, dependent defaults or preds with multiple params.\n-            if substituted_pred.references_error() || param_count.params.len() > 1 {\n-                continue;\n-            }\n-            // Avoid duplication of predicates that contain no parameters, for example.\n-            if !predicates.predicates.contains(&substituted_pred) {\n-                substituted_predicates.push(substituted_pred);\n-            }\n         }\n-\n-        predicates.predicates.extend(substituted_predicates);\n-        let predicates = predicates.instantiate_identity(fcx.tcx);\n-        let predicates = fcx.normalize_associated_types_in(span, &predicates);\n-\n-        let obligations =\n-            predicates.predicates\n-                      .iter()\n-                      .flat_map(|p| ty::wf::predicate_obligations(fcx,\n-                                                                  fcx.param_env,\n-                                                                  fcx.body_id,\n-                                                                  p,\n-                                                                  span));\n-\n-        for obligation in obligations {\n-            fcx.register_predicate(obligation);\n+        let mut param_count = CountParams { params: FxHashSet() };\n+        pred.visit_with(&mut param_count);\n+        let substituted_pred = pred.subst(fcx.tcx, substs);\n+        // Don't check non-defaulted params, dependent defaults or preds with multiple params.\n+        if substituted_pred.references_error() || param_count.params.len() > 1 {\n+            continue;\n+        }\n+        // Avoid duplication of predicates that contain no parameters, for example.\n+        if !predicates.predicates.contains(&substituted_pred) {\n+            substituted_predicates.push(substituted_pred);\n         }\n     }\n \n-    fn check_fn_or_method<'fcx, 'tcx>(&mut self,\n-                                      fcx: &FnCtxt<'fcx, 'gcx, 'tcx>,\n-                                      span: Span,\n-                                      sig: ty::PolyFnSig<'tcx>,\n-                                      def_id: DefId,\n-                                      implied_bounds: &mut Vec<Ty<'tcx>>)\n-    {\n-        let sig = fcx.normalize_associated_types_in(span, &sig);\n-        let sig = fcx.tcx.liberate_late_bound_regions(def_id, &sig);\n-\n-        for input_ty in sig.inputs() {\n-            fcx.register_wf_obligation(&input_ty, span, self.code.clone());\n-        }\n-        implied_bounds.extend(sig.inputs());\n+    predicates.predicates.extend(substituted_predicates);\n+    let predicates = predicates.instantiate_identity(fcx.tcx);\n+    let predicates = fcx.normalize_associated_types_in(span, &predicates);\n+\n+    let obligations =\n+        predicates.predicates\n+                    .iter()\n+                    .flat_map(|p| ty::wf::predicate_obligations(fcx,\n+                                                                fcx.param_env,\n+                                                                fcx.body_id,\n+                                                                p,\n+                                                                span));\n+\n+    for obligation in obligations {\n+        fcx.register_predicate(obligation);\n+    }\n+}\n \n-        fcx.register_wf_obligation(sig.output(), span, self.code.clone());\n+fn check_fn_or_method<'a, 'fcx, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'gcx>,\n+                                    fcx: &FnCtxt<'fcx, 'gcx, 'tcx>,\n+                                    span: Span,\n+                                    sig: ty::PolyFnSig<'tcx>,\n+                                    def_id: DefId,\n+                                    implied_bounds: &mut Vec<Ty<'tcx>>)\n+{\n+    let sig = fcx.normalize_associated_types_in(span, &sig);\n+    let sig = fcx.tcx.liberate_late_bound_regions(def_id, &sig);\n+\n+    for input_ty in sig.inputs() {\n+        fcx.register_wf_obligation(&input_ty, span, ObligationCauseCode::MiscObligation);\n+    }\n+    implied_bounds.extend(sig.inputs());\n \n-        // FIXME(#25759) return types should not be implied bounds\n-        implied_bounds.push(sig.output());\n+    fcx.register_wf_obligation(sig.output(), span, ObligationCauseCode::MiscObligation);\n \n-        self.check_where_clauses(fcx, span, def_id);\n-    }\n+    // FIXME(#25759) return types should not be implied bounds\n+    implied_bounds.push(sig.output());\n \n-    fn check_method_receiver<'fcx, 'tcx>(&mut self,\n-                                         fcx: &FnCtxt<'fcx, 'gcx, 'tcx>,\n-                                         method_sig: &hir::MethodSig,\n-                                         method: &ty::AssociatedItem,\n-                                         self_ty: Ty<'tcx>)\n-    {\n-        // check that the method has a valid receiver type, given the type `Self`\n-        debug!(\"check_method_receiver({:?}, self_ty={:?})\",\n-               method, self_ty);\n+    check_where_clauses(tcx, fcx, span, def_id);\n+}\n \n-        if !method.method_has_self_argument {\n-            return;\n-        }\n+fn check_method_receiver<'fcx, 'gcx, 'tcx>(fcx: &FnCtxt<'fcx, 'gcx, 'tcx>,\n+                                           method_sig: &hir::MethodSig,\n+                                           method: &ty::AssociatedItem,\n+                                           self_ty: Ty<'tcx>)\n+{\n+    // check that the method has a valid receiver type, given the type `Self`\n+    debug!(\"check_method_receiver({:?}, self_ty={:?})\",\n+            method, self_ty);\n+\n+    if !method.method_has_self_argument {\n+        return;\n+    }\n \n-        let span = method_sig.decl.inputs[0].span;\n+    let span = method_sig.decl.inputs[0].span;\n \n-        let sig = fcx.tcx.fn_sig(method.def_id);\n-        let sig = fcx.normalize_associated_types_in(span, &sig);\n-        let sig = fcx.tcx.liberate_late_bound_regions(method.def_id, &sig);\n+    let sig = fcx.tcx.fn_sig(method.def_id);\n+    let sig = fcx.normalize_associated_types_in(span, &sig);\n+    let sig = fcx.tcx.liberate_late_bound_regions(method.def_id, &sig);\n \n-        debug!(\"check_method_receiver: sig={:?}\", sig);\n+    debug!(\"check_method_receiver: sig={:?}\", sig);\n \n-        let self_ty = fcx.normalize_associated_types_in(span, &self_ty);\n-        let self_ty = fcx.tcx.liberate_late_bound_regions(\n-            method.def_id,\n-            &ty::Binder(self_ty)\n-        );\n+    let self_ty = fcx.normalize_associated_types_in(span, &self_ty);\n+    let self_ty = fcx.tcx.liberate_late_bound_regions(\n+        method.def_id,\n+        &ty::Binder(self_ty)\n+    );\n \n-        let self_arg_ty = sig.inputs()[0];\n+    let self_arg_ty = sig.inputs()[0];\n \n-        let cause = fcx.cause(span, ObligationCauseCode::MethodReceiver);\n-        let self_arg_ty = fcx.normalize_associated_types_in(span, &self_arg_ty);\n-        let self_arg_ty = fcx.tcx.liberate_late_bound_regions(\n-            method.def_id,\n-            &ty::Binder(self_arg_ty)\n-        );\n+    let cause = fcx.cause(span, ObligationCauseCode::MethodReceiver);\n+    let self_arg_ty = fcx.normalize_associated_types_in(span, &self_arg_ty);\n+    let self_arg_ty = fcx.tcx.liberate_late_bound_regions(\n+        method.def_id,\n+        &ty::Binder(self_arg_ty)\n+    );\n \n-        let mut autoderef = fcx.autoderef(span, self_arg_ty).include_raw_pointers();\n+    let mut autoderef = fcx.autoderef(span, self_arg_ty).include_raw_pointers();\n \n-        loop {\n-            if let Some((potential_self_ty, _)) = autoderef.next() {\n-                debug!(\"check_method_receiver: potential self type `{:?}` to match `{:?}`\",\n-                    potential_self_ty, self_ty);\n+    loop {\n+        if let Some((potential_self_ty, _)) = autoderef.next() {\n+            debug!(\"check_method_receiver: potential self type `{:?}` to match `{:?}`\",\n+                potential_self_ty, self_ty);\n \n-                if fcx.infcx.can_eq(fcx.param_env, self_ty, potential_self_ty).is_ok() {\n-                    autoderef.finalize();\n-                    if let Some(mut err) = fcx.demand_eqtype_with_origin(\n-                        &cause, self_ty, potential_self_ty) {\n-                        err.emit();\n-                    }\n-                    break\n+            if fcx.infcx.can_eq(fcx.param_env, self_ty, potential_self_ty).is_ok() {\n+                autoderef.finalize();\n+                if let Some(mut err) = fcx.demand_eqtype_with_origin(\n+                    &cause, self_ty, potential_self_ty) {\n+                    err.emit();\n                 }\n-            } else {\n-                fcx.tcx.sess.diagnostic().mut_span_err(\n-                    span, &format!(\"invalid `self` type: {:?}\", self_arg_ty))\n-                .note(&format!(\"type must be `{:?}` or a type that dereferences to it\", self_ty))\n-                .help(\"consider changing to `self`, `&self`, `&mut self`, or `self: Box<Self>`\")\n-                .code(DiagnosticId::Error(\"E0307\".into()))\n-                .emit();\n-                return\n+                break\n             }\n+        } else {\n+            fcx.tcx.sess.diagnostic().mut_span_err(\n+                span, &format!(\"invalid `self` type: {:?}\", self_arg_ty))\n+            .note(&format!(\"type must be `{:?}` or a type that dereferences to it\", self_ty))\n+            .help(\"consider changing to `self`, `&self`, `&mut self`, or `self: Box<Self>`\")\n+            .code(DiagnosticId::Error(\"E0307\".into()))\n+            .emit();\n+            return\n         }\n+    }\n \n-        let is_self_ty = |ty| fcx.infcx.can_eq(fcx.param_env, self_ty, ty).is_ok();\n-        let self_kind = ExplicitSelf::determine(self_arg_ty, is_self_ty);\n-\n-        if !fcx.tcx.features().arbitrary_self_types {\n-            match self_kind {\n-                ExplicitSelf::ByValue |\n-                ExplicitSelf::ByReference(_, _) |\n-                ExplicitSelf::ByBox => (),\n-\n-                ExplicitSelf::ByRawPointer(_) => {\n-                    feature_gate::feature_err(\n-                        &fcx.tcx.sess.parse_sess,\n-                        \"arbitrary_self_types\",\n-                        span,\n-                        GateIssue::Language,\n-                        \"raw pointer `self` is unstable\")\n-                    .help(\"consider changing to `self`, `&self`, `&mut self`, or `self: Box<Self>`\")\n-                    .emit();\n-                }\n+    let is_self_ty = |ty| fcx.infcx.can_eq(fcx.param_env, self_ty, ty).is_ok();\n+    let self_kind = ExplicitSelf::determine(self_arg_ty, is_self_ty);\n+\n+    if !fcx.tcx.features().arbitrary_self_types {\n+        match self_kind {\n+            ExplicitSelf::ByValue |\n+            ExplicitSelf::ByReference(_, _) |\n+            ExplicitSelf::ByBox => (),\n+\n+            ExplicitSelf::ByRawPointer(_) => {\n+                feature_gate::feature_err(\n+                    &fcx.tcx.sess.parse_sess,\n+                    \"arbitrary_self_types\",\n+                    span,\n+                    GateIssue::Language,\n+                    \"raw pointer `self` is unstable\")\n+                .help(\"consider changing to `self`, `&self`, `&mut self`, or `self: Box<Self>`\")\n+                .emit();\n+            }\n \n-                ExplicitSelf::Other => {\n-                    feature_gate::feature_err(\n-                        &fcx.tcx.sess.parse_sess,\n-                        \"arbitrary_self_types\",\n-                        span,\n-                        GateIssue::Language,\"arbitrary `self` types are unstable\")\n-                    .help(\"consider changing to `self`, `&self`, `&mut self`, or `self: Box<Self>`\")\n-                    .emit();\n-                }\n+            ExplicitSelf::Other => {\n+                feature_gate::feature_err(\n+                    &fcx.tcx.sess.parse_sess,\n+                    \"arbitrary_self_types\",\n+                    span,\n+                    GateIssue::Language,\"arbitrary `self` types are unstable\")\n+                .help(\"consider changing to `self`, `&self`, `&mut self`, or `self: Box<Self>`\")\n+                .emit();\n             }\n         }\n     }\n+}\n \n-    fn check_variances_for_type_defn(&self,\n-                                     item: &hir::Item,\n-                                     ast_generics: &hir::Generics)\n-    {\n-        let item_def_id = self.tcx.hir.local_def_id(item.id);\n-        let ty = self.tcx.type_of(item_def_id);\n-        if self.tcx.has_error_field(ty) {\n-            return;\n-        }\n-\n-        let ty_predicates = self.tcx.predicates_of(item_def_id);\n-        assert_eq!(ty_predicates.parent, None);\n-        let variances = self.tcx.variances_of(item_def_id);\n+fn check_variances_for_type_defn<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                    item: &hir::Item,\n+                                    ast_generics: &hir::Generics)\n+{\n+    let item_def_id = tcx.hir.local_def_id(item.id);\n+    let ty = tcx.type_of(item_def_id);\n+    if tcx.has_error_field(ty) {\n+        return;\n+    }\n \n-        let mut constrained_parameters: FxHashSet<_> =\n-            variances.iter().enumerate()\n-                     .filter(|&(_, &variance)| variance != ty::Bivariant)\n-                     .map(|(index, _)| Parameter(index as u32))\n-                     .collect();\n+    let ty_predicates = tcx.predicates_of(item_def_id);\n+    assert_eq!(ty_predicates.parent, None);\n+    let variances = tcx.variances_of(item_def_id);\n \n-        identify_constrained_type_params(self.tcx,\n-                                         ty_predicates.predicates.as_slice(),\n-                                         None,\n-                                         &mut constrained_parameters);\n+    let mut constrained_parameters: FxHashSet<_> =\n+        variances.iter().enumerate()\n+                    .filter(|&(_, &variance)| variance != ty::Bivariant)\n+                    .map(|(index, _)| Parameter(index as u32))\n+                    .collect();\n \n-        for (index, _) in variances.iter().enumerate() {\n-            if constrained_parameters.contains(&Parameter(index as u32)) {\n-                continue;\n-            }\n+    identify_constrained_type_params(tcx,\n+                                        ty_predicates.predicates.as_slice(),\n+                                        None,\n+                                        &mut constrained_parameters);\n \n-            let (span, name) = match ast_generics.params[index] {\n-                hir::GenericParam::Lifetime(ref ld) => (ld.lifetime.span, ld.lifetime.name.name()),\n-                hir::GenericParam::Type(ref tp) => (tp.span, tp.name),\n-            };\n-            self.report_bivariance(span, name);\n+    for (index, _) in variances.iter().enumerate() {\n+        if constrained_parameters.contains(&Parameter(index as u32)) {\n+            continue;\n         }\n+\n+        let (span, name) = match ast_generics.params[index] {\n+            hir::GenericParam::Lifetime(ref ld) => (ld.lifetime.span, ld.lifetime.name.name()),\n+            hir::GenericParam::Type(ref tp) => (tp.span, tp.name),\n+        };\n+        report_bivariance(tcx, span, name);\n     }\n+}\n \n-    fn report_bivariance(&self,\n-                         span: Span,\n-                         param_name: ast::Name)\n-    {\n-        let mut err = error_392(self.tcx, span, param_name);\n-\n-        let suggested_marker_id = self.tcx.lang_items().phantom_data();\n-        match suggested_marker_id {\n-            Some(def_id) => {\n-                err.help(\n-                    &format!(\"consider removing `{}` or using a marker such as `{}`\",\n-                             param_name,\n-                             self.tcx.item_path_str(def_id)));\n-            }\n-            None => {\n-                // no lang items, no help!\n-            }\n+fn report_bivariance<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                        span: Span,\n+                        param_name: ast::Name)\n+{\n+    let mut err = error_392(tcx, span, param_name);\n+\n+    let suggested_marker_id = tcx.lang_items().phantom_data();\n+    match suggested_marker_id {\n+        Some(def_id) => {\n+            err.help(\n+                &format!(\"consider removing `{}` or using a marker such as `{}`\",\n+                            param_name,\n+                            tcx.item_path_str(def_id)));\n+        }\n+        None => {\n+            // no lang items, no help!\n         }\n-        err.emit();\n     }\n+    err.emit();\n }\n \n fn reject_shadowing_type_parameters(tcx: TyCtxt, def_id: DefId) {\n@@ -648,34 +654,42 @@ fn reject_shadowing_type_parameters(tcx: TyCtxt, def_id: DefId) {\n     }\n }\n \n+pub struct CheckTypeWellFormedVisitor<'a, 'tcx: 'a> {\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+}\n+\n+impl<'a, 'gcx> CheckTypeWellFormedVisitor<'a, 'gcx> {\n+    pub fn new(tcx: TyCtxt<'a, 'gcx, 'gcx>)\n+               -> CheckTypeWellFormedVisitor<'a, 'gcx> {\n+        CheckTypeWellFormedVisitor {\n+            tcx,\n+        }\n+    }\n+}\n+\n impl<'a, 'tcx, 'v> Visitor<'v> for CheckTypeWellFormedVisitor<'a, 'tcx> {\n     fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'v> {\n         NestedVisitorMap::None\n     }\n \n     fn visit_item(&mut self, i: &hir::Item) {\n         debug!(\"visit_item: {:?}\", i);\n-        self.check_item_well_formed(i);\n+        let def_id = self.tcx.hir.local_def_id(i.id);\n+        ty::maps::queries::check_item_well_formed::ensure(self.tcx, def_id);\n         intravisit::walk_item(self, i);\n     }\n \n     fn visit_trait_item(&mut self, trait_item: &'v hir::TraitItem) {\n         debug!(\"visit_trait_item: {:?}\", trait_item);\n-        let method_sig = match trait_item.node {\n-            hir::TraitItemKind::Method(ref sig, _) => Some(sig),\n-            _ => None\n-        };\n-        self.check_associated_item(trait_item.id, trait_item.span, method_sig);\n+        let def_id = self.tcx.hir.local_def_id(trait_item.id);\n+        ty::maps::queries::check_trait_item_well_formed::ensure(self.tcx, def_id);\n         intravisit::walk_trait_item(self, trait_item)\n     }\n \n     fn visit_impl_item(&mut self, impl_item: &'v hir::ImplItem) {\n         debug!(\"visit_impl_item: {:?}\", impl_item);\n-        let method_sig = match impl_item.node {\n-            hir::ImplItemKind::Method(ref sig, _) => Some(sig),\n-            _ => None\n-        };\n-        self.check_associated_item(impl_item.id, impl_item.span, method_sig);\n+        let def_id = self.tcx.hir.local_def_id(impl_item.id);\n+        ty::maps::queries::check_impl_item_well_formed::ensure(self.tcx, def_id);\n         intravisit::walk_impl_item(self, impl_item)\n     }\n }"}]}