{"sha": "7d03617bab24a689bc704e71e509b9c11c655f26", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdkMDM2MTdiYWIyNGE2ODliYzcwNGU3MWU1MDliOWMxMWM2NTVmMjY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-12-14T13:44:15Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-12-14T13:44:15Z"}, "message": "Auto merge of #56568 - notriddle:master, r=alexcrichton\n\nRemove dependency on shell32.dll\n\nCloses #56510 if it works on MinGW (I've only tested it on MSVC).", "tree": {"sha": "d4d9c3c7d6b37412dc7c97fb8f860a6746f59b55", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d4d9c3c7d6b37412dc7c97fb8f860a6746f59b55"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7d03617bab24a689bc704e71e509b9c11c655f26", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7d03617bab24a689bc704e71e509b9c11c655f26", "html_url": "https://github.com/rust-lang/rust/commit/7d03617bab24a689bc704e71e509b9c11c655f26", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7d03617bab24a689bc704e71e509b9c11c655f26/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f4b07e0713b2d82417968db08cd0575734cdac0d", "url": "https://api.github.com/repos/rust-lang/rust/commits/f4b07e0713b2d82417968db08cd0575734cdac0d", "html_url": "https://github.com/rust-lang/rust/commit/f4b07e0713b2d82417968db08cd0575734cdac0d"}, {"sha": "83fe6e4392b2b89005f3056cf56a382887c939d5", "url": "https://api.github.com/repos/rust-lang/rust/commits/83fe6e4392b2b89005f3056cf56a382887c939d5", "html_url": "https://github.com/rust-lang/rust/commit/83fe6e4392b2b89005f3056cf56a382887c939d5"}], "stats": {"total": 264, "additions": 210, "deletions": 54}, "files": [{"sha": "7143de55c8831c74a886be688c3e7ac1454baa87", "filename": "src/libstd/build.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7d03617bab24a689bc704e71e509b9c11c655f26/src%2Flibstd%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d03617bab24a689bc704e71e509b9c11c655f26/src%2Flibstd%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbuild.rs?ref=7d03617bab24a689bc704e71e509b9c11c655f26", "patch": "@@ -68,7 +68,6 @@ fn main() {\n         println!(\"cargo:rustc-link-lib=advapi32\");\n         println!(\"cargo:rustc-link-lib=ws2_32\");\n         println!(\"cargo:rustc-link-lib=userenv\");\n-        println!(\"cargo:rustc-link-lib=shell32\");\n     } else if target.contains(\"fuchsia\") {\n         println!(\"cargo:rustc-link-lib=zircon\");\n         println!(\"cargo:rustc-link-lib=fdio\");"}, {"sha": "9e9198e05ee0ed73bc90f03035063e02fd2858d0", "filename": "src/libstd/sys/windows/args.rs", "status": "modified", "additions": 209, "deletions": 49, "changes": 258, "blob_url": "https://github.com/rust-lang/rust/blob/7d03617bab24a689bc704e71e509b9c11c655f26/src%2Flibstd%2Fsys%2Fwindows%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d03617bab24a689bc704e71e509b9c11c655f26/src%2Flibstd%2Fsys%2Fwindows%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fargs.rs?ref=7d03617bab24a689bc704e71e509b9c11c655f26", "patch": "@@ -11,33 +11,161 @@\n #![allow(dead_code)] // runtime init functions not used during testing\n \n use os::windows::prelude::*;\n+use sys::windows::os::current_exe;\n use sys::c;\n-use slice;\n-use ops::Range;\n use ffi::OsString;\n-use libc::{c_int, c_void};\n use fmt;\n+use vec;\n+use core::iter;\n+use slice;\n+use path::PathBuf;\n \n pub unsafe fn init(_argc: isize, _argv: *const *const u8) { }\n \n pub unsafe fn cleanup() { }\n \n pub fn args() -> Args {\n     unsafe {\n-        let mut nArgs: c_int = 0;\n-        let lpCmdLine = c::GetCommandLineW();\n-        let szArgList = c::CommandLineToArgvW(lpCmdLine, &mut nArgs);\n-\n-        // szArcList can be NULL if CommandLinToArgvW failed,\n-        // but in that case nArgs is 0 so we won't actually\n-        // try to read a null pointer\n-        Args { cur: szArgList, range: 0..(nArgs as isize) }\n+        let lp_cmd_line = c::GetCommandLineW();\n+        let parsed_args_list = parse_lp_cmd_line(\n+            lp_cmd_line as *const u16,\n+            || current_exe().map(PathBuf::into_os_string).unwrap_or_else(|_| OsString::new()));\n+\n+        Args { parsed_args_list: parsed_args_list.into_iter() }\n     }\n }\n \n+/// Implements the Windows command-line argument parsing algorithm.\n+///\n+/// Microsoft's documentation for the Windows CLI argument format can be found at\n+/// <https://docs.microsoft.com/en-us/previous-versions//17w5ykft(v=vs.85)>.\n+///\n+/// Windows includes a function to do this in shell32.dll,\n+/// but linking with that DLL causes the process to be registered as a GUI application.\n+/// GUI applications add a bunch of overhead, even if no windows are drawn. See\n+/// <https://randomascii.wordpress.com/2018/12/03/a-not-called-function-can-cause-a-5x-slowdown/>.\n+///\n+/// This function was tested for equivalence to the shell32.dll implementation in\n+/// Windows 10 Pro v1803, using an exhaustive test suite available at\n+/// <https://gist.github.com/notriddle/dde431930c392e428055b2dc22e638f5> or\n+/// <https://paste.gg/p/anonymous/47d6ed5f5bd549168b1c69c799825223>.\n+unsafe fn parse_lp_cmd_line<F: Fn() -> OsString>(lp_cmd_line: *const u16, exe_name: F)\n+                                                 -> Vec<OsString> {\n+    const BACKSLASH: u16 = '\\\\' as u16;\n+    const QUOTE: u16 = '\"' as u16;\n+    const TAB: u16 = '\\t' as u16;\n+    const SPACE: u16 = ' ' as u16;\n+    let mut ret_val = Vec::new();\n+    if lp_cmd_line.is_null() || *lp_cmd_line == 0 {\n+        ret_val.push(exe_name());\n+        return ret_val;\n+    }\n+    let mut cmd_line = {\n+        let mut end = 0;\n+        while *lp_cmd_line.offset(end) != 0 {\n+            end += 1;\n+        }\n+        slice::from_raw_parts(lp_cmd_line, end as usize)\n+    };\n+    // The executable name at the beginning is special.\n+    cmd_line = match cmd_line[0] {\n+        // The executable name ends at the next quote mark,\n+        // no matter what.\n+        QUOTE => {\n+            let args = {\n+                let mut cut = cmd_line[1..].splitn(2, |&c| c == QUOTE);\n+                if let Some(exe) = cut.next() {\n+                    ret_val.push(OsString::from_wide(exe));\n+                }\n+                cut.next()\n+            };\n+            if let Some(args) = args {\n+                args\n+            } else {\n+                return ret_val;\n+            }\n+        }\n+        // Implement quirk: when they say whitespace here,\n+        // they include the entire ASCII control plane:\n+        // \"However, if lpCmdLine starts with any amount of whitespace, CommandLineToArgvW\n+        // will consider the first argument to be an empty string. Excess whitespace at the\n+        // end of lpCmdLine is ignored.\"\n+        0...SPACE => {\n+            ret_val.push(OsString::new());\n+            &cmd_line[1..]\n+        },\n+        // The executable name ends at the next whitespace,\n+        // no matter what.\n+        _ => {\n+            let args = {\n+                let mut cut = cmd_line.splitn(2, |&c| c > 0 && c <= SPACE);\n+                if let Some(exe) = cut.next() {\n+                    ret_val.push(OsString::from_wide(exe));\n+                }\n+                cut.next()\n+            };\n+            if let Some(args) = args {\n+                args\n+            } else {\n+                return ret_val;\n+            }\n+        }\n+    };\n+    let mut cur = Vec::new();\n+    let mut in_quotes = false;\n+    let mut was_in_quotes = false;\n+    let mut backslash_count: usize = 0;\n+    for &c in cmd_line {\n+        match c {\n+            // backslash\n+            BACKSLASH => {\n+                backslash_count += 1;\n+                was_in_quotes = false;\n+            },\n+            QUOTE if backslash_count % 2 == 0 => {\n+                cur.extend(iter::repeat(b'\\\\' as u16).take(backslash_count / 2));\n+                backslash_count = 0;\n+                if was_in_quotes {\n+                    cur.push('\"' as u16);\n+                    was_in_quotes = false;\n+                } else {\n+                    was_in_quotes = in_quotes;\n+                    in_quotes = !in_quotes;\n+                }\n+            }\n+            QUOTE if backslash_count % 2 != 0 => {\n+                cur.extend(iter::repeat(b'\\\\' as u16).take(backslash_count / 2));\n+                backslash_count = 0;\n+                was_in_quotes = false;\n+                cur.push(b'\"' as u16);\n+            }\n+            SPACE | TAB if !in_quotes => {\n+                cur.extend(iter::repeat(b'\\\\' as u16).take(backslash_count));\n+                if !cur.is_empty() || was_in_quotes {\n+                    ret_val.push(OsString::from_wide(&cur[..]));\n+                    cur.truncate(0);\n+                }\n+                backslash_count = 0;\n+                was_in_quotes = false;\n+            }\n+            _ => {\n+                cur.extend(iter::repeat(b'\\\\' as u16).take(backslash_count));\n+                backslash_count = 0;\n+                was_in_quotes = false;\n+                cur.push(c);\n+            }\n+        }\n+    }\n+    cur.extend(iter::repeat(b'\\\\' as u16).take(backslash_count));\n+    // include empty quoted strings at the end of the arguments list\n+    if !cur.is_empty() || was_in_quotes || in_quotes {\n+        ret_val.push(OsString::from_wide(&cur[..]));\n+    }\n+    ret_val\n+}\n+\n pub struct Args {\n-    range: Range<isize>,\n-    cur: *mut *mut u16,\n+    parsed_args_list: vec::IntoIter<OsString>,\n }\n \n pub struct ArgsInnerDebug<'a> {\n@@ -46,19 +174,7 @@ pub struct ArgsInnerDebug<'a> {\n \n impl<'a> fmt::Debug for ArgsInnerDebug<'a> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        f.write_str(\"[\")?;\n-        let mut first = true;\n-        for i in self.args.range.clone() {\n-            if !first {\n-                f.write_str(\", \")?;\n-            }\n-            first = false;\n-\n-            // Here we do allocation which could be avoided.\n-            fmt::Debug::fmt(&unsafe { os_string_from_ptr(*self.args.cur.offset(i)) }, f)?;\n-        }\n-        f.write_str(\"]\")?;\n-        Ok(())\n+        self.args.parsed_args_list.as_slice().fmt(f)\n     }\n }\n \n@@ -70,38 +186,82 @@ impl Args {\n     }\n }\n \n-unsafe fn os_string_from_ptr(ptr: *mut u16) -> OsString {\n-    let mut len = 0;\n-    while *ptr.offset(len) != 0 { len += 1; }\n-\n-    // Push it onto the list.\n-    let ptr = ptr as *const u16;\n-    let buf = slice::from_raw_parts(ptr, len as usize);\n-    OsStringExt::from_wide(buf)\n-}\n-\n impl Iterator for Args {\n     type Item = OsString;\n-    fn next(&mut self) -> Option<OsString> {\n-        self.range.next().map(|i| unsafe { os_string_from_ptr(*self.cur.offset(i)) } )\n-    }\n-    fn size_hint(&self) -> (usize, Option<usize>) { self.range.size_hint() }\n+    fn next(&mut self) -> Option<OsString> { self.parsed_args_list.next() }\n+    fn size_hint(&self) -> (usize, Option<usize>) { self.parsed_args_list.size_hint() }\n }\n \n impl DoubleEndedIterator for Args {\n-    fn next_back(&mut self) -> Option<OsString> {\n-        self.range.next_back().map(|i| unsafe { os_string_from_ptr(*self.cur.offset(i)) } )\n-    }\n+    fn next_back(&mut self) -> Option<OsString> { self.parsed_args_list.next_back() }\n }\n \n impl ExactSizeIterator for Args {\n-    fn len(&self) -> usize { self.range.len() }\n+    fn len(&self) -> usize { self.parsed_args_list.len() }\n }\n \n-impl Drop for Args {\n-    fn drop(&mut self) {\n-        // self.cur can be null if CommandLineToArgvW previously failed,\n-        // but LocalFree ignores NULL pointers\n-        unsafe { c::LocalFree(self.cur as *mut c_void); }\n+#[cfg(test)]\n+mod tests {\n+    use sys::windows::args::*;\n+    use ffi::OsString;\n+\n+    fn chk(string: &str, parts: &[&str]) {\n+        let mut wide: Vec<u16> = OsString::from(string).encode_wide().collect();\n+        wide.push(0);\n+        let parsed = unsafe {\n+            parse_lp_cmd_line(wide.as_ptr() as *const u16, || OsString::from(\"TEST.EXE\"))\n+        };\n+        let expected: Vec<OsString> = parts.iter().map(|k| OsString::from(k)).collect();\n+        assert_eq!(parsed.as_slice(), expected.as_slice());\n+    }\n+\n+    #[test]\n+    fn empty() {\n+        chk(\"\", &[\"TEST.EXE\"]);\n+        chk(\"\\0\", &[\"TEST.EXE\"]);\n+    }\n+\n+    #[test]\n+    fn single_words() {\n+        chk(\"EXE one_word\", &[\"EXE\", \"one_word\"]);\n+        chk(\"EXE a\", &[\"EXE\", \"a\"]);\n+        chk(\"EXE \ud83d\ude05\", &[\"EXE\", \"\ud83d\ude05\"]);\n+        chk(\"EXE \ud83d\ude05\ud83e\udd26\", &[\"EXE\", \"\ud83d\ude05\ud83e\udd26\"]);\n+    }\n+\n+    #[test]\n+    fn official_examples() {\n+        chk(r#\"EXE \"abc\" d e\"#, &[\"EXE\", \"abc\", \"d\", \"e\"]);\n+        chk(r#\"EXE a\\\\\\b d\"e f\"g h\"#, &[\"EXE\", r#\"a\\\\\\b\"#, \"de fg\", \"h\"]);\n+        chk(r#\"EXE a\\\\\\\"b c d\"#, &[\"EXE\", r#\"a\\\"b\"#, \"c\", \"d\"]);\n+        chk(r#\"EXE a\\\\\\\\\"b c\" d e\"#, &[\"EXE\", r#\"a\\\\b c\"#, \"d\", \"e\"]);\n+    }\n+\n+    #[test]\n+    fn whitespace_behavior() {\n+        chk(r#\" test\"#, &[\"\", \"test\"]);\n+        chk(r#\"  test\"#, &[\"\", \"test\"]);\n+        chk(r#\" test test2\"#, &[\"\", \"test\", \"test2\"]);\n+        chk(r#\" test  test2\"#, &[\"\", \"test\", \"test2\"]);\n+        chk(r#\"test test2 \"#, &[\"test\", \"test2\"]);\n+        chk(r#\"test  test2 \"#, &[\"test\", \"test2\"]);\n+        chk(r#\"test \"#, &[\"test\"]);\n+    }\n+\n+    #[test]\n+    fn genius_quotes() {\n+        chk(r#\"EXE \"\" \"\"\"#, &[\"EXE\", \"\", \"\"]);\n+        chk(r#\"EXE \"\" \"\"\"\"#, &[\"EXE\", \"\", \"\\\"\"]);\n+        chk(\n+            r#\"EXE \"this is \"\"\"all\"\"\" in the same argument\"\"#,\n+            &[\"EXE\", \"this is \\\"all\\\" in the same argument\"]\n+        );\n+        chk(r#\"EXE \"a\"\"\"#, &[\"EXE\", \"a\\\"\"]);\n+        chk(r#\"EXE \"a\"\" a\"#, &[\"EXE\", \"a\\\"\", \"a\"]);\n+        // quotes cannot be escaped in command names\n+        chk(r#\"\"EXE\" check\"#, &[\"EXE\", \"check\"]);\n+        chk(r#\"\"EXE check\"\"#, &[\"EXE check\"]);\n+        chk(r#\"\"EXE \"\"\"for\"\"\" check\"#, &[\"EXE \", r#\"for\"\"#, \"check\"]);\n+        chk(r#\"\"EXE \\\"for\\\" check\"#, &[r#\"EXE \\\"#, r#\"for\"\"#,  \"check\"]);\n     }\n }"}, {"sha": "fa21f459a8a85754f67ad6541f3a2c688c25adc3", "filename": "src/libstd/sys/windows/c.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7d03617bab24a689bc704e71e509b9c11c655f26/src%2Flibstd%2Fsys%2Fwindows%2Fc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d03617bab24a689bc704e71e509b9c11c655f26/src%2Flibstd%2Fsys%2Fwindows%2Fc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fc.rs?ref=7d03617bab24a689bc704e71e509b9c11c655f26", "patch": "@@ -1035,9 +1035,6 @@ extern \"system\" {\n \n     pub fn SetLastError(dwErrCode: DWORD);\n     pub fn GetCommandLineW() -> *mut LPCWSTR;\n-    pub fn LocalFree(ptr: *mut c_void);\n-    pub fn CommandLineToArgvW(lpCmdLine: *mut LPCWSTR,\n-                              pNumArgs: *mut c_int) -> *mut *mut u16;\n     pub fn GetTempPathW(nBufferLength: DWORD,\n                         lpBuffer: LPCWSTR) -> DWORD;\n     pub fn OpenProcessToken(ProcessHandle: HANDLE,"}, {"sha": "79399281804fb2cd8c682db02857c242645c94d1", "filename": "src/test/run-make-fulldeps/tools.mk", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d03617bab24a689bc704e71e509b9c11c655f26/src%2Ftest%2Frun-make-fulldeps%2Ftools.mk", "raw_url": "https://github.com/rust-lang/rust/raw/7d03617bab24a689bc704e71e509b9c11c655f26/src%2Ftest%2Frun-make-fulldeps%2Ftools.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Ftools.mk?ref=7d03617bab24a689bc704e71e509b9c11c655f26", "patch": "@@ -76,7 +76,7 @@ endif\n # Extra flags needed to compile a working executable with the standard library\n ifdef IS_WINDOWS\n ifdef IS_MSVC\n-\tEXTRACFLAGS := ws2_32.lib userenv.lib shell32.lib advapi32.lib\n+\tEXTRACFLAGS := ws2_32.lib userenv.lib advapi32.lib\n else\n \tEXTRACFLAGS := -lws2_32 -luserenv\n endif"}]}