{"sha": "c1157161d988a15156513dbe0f1f7895fb227606", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMxMTU3MTYxZDk4OGExNTE1NjUxM2RiZTBmMWY3ODk1ZmIyMjc2MDY=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-06-27T21:10:24Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-06-27T21:11:02Z"}, "message": "rustc: Don't give variables the same name as enums in trans\n\nConflicts:\n\n\tsrc/rustc/middle/trans/alt.rs\n\tsrc/rustc/middle/trans/base.rs\n\tsrc/rustc/middle/trans/closure.rs\n\tsrc/rustc/middle/trans/impl.rs\n\tsrc/rustc/middle/trans/uniq.rs", "tree": {"sha": "909fa14dadf000da9f3fdf7b6e9828f6d5843a0b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/909fa14dadf000da9f3fdf7b6e9828f6d5843a0b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c1157161d988a15156513dbe0f1f7895fb227606", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c1157161d988a15156513dbe0f1f7895fb227606", "html_url": "https://github.com/rust-lang/rust/commit/c1157161d988a15156513dbe0f1f7895fb227606", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c1157161d988a15156513dbe0f1f7895fb227606/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6cf5910de2107b3b7489c61f6b7dcf11b560d692", "url": "https://api.github.com/repos/rust-lang/rust/commits/6cf5910de2107b3b7489c61f6b7dcf11b560d692", "html_url": "https://github.com/rust-lang/rust/commit/6cf5910de2107b3b7489c61f6b7dcf11b560d692"}], "stats": {"total": 94, "additions": 47, "deletions": 47}, "files": [{"sha": "f65265f32162ab923a3522e978182168d5b70920", "filename": "src/rustc/middle/trans/alt.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/c1157161d988a15156513dbe0f1f7895fb227606/src%2Frustc%2Fmiddle%2Ftrans%2Falt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1157161d988a15156513dbe0f1f7895fb227606/src%2Frustc%2Fmiddle%2Ftrans%2Falt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Falt.rs?ref=c1157161d988a15156513dbe0f1f7895fb227606", "patch": "@@ -461,8 +461,8 @@ fn compile_submatch(bcx: block, m: match, vals: [ValueRef]/~,\n \n     // Unbox in case of a box field\n     if any_box_pat(m, col) {\n-        let box = Load(bcx, val);\n-        let box_no_addrspace = non_gc_box_cast(bcx, box);\n+        let llbox = Load(bcx, val);\n+        let box_no_addrspace = non_gc_box_cast(bcx, llbox);\n         let unboxed =\n             GEPi(bcx, box_no_addrspace, [0u, abi::box_field_body]/~);\n         compile_submatch(bcx, enter_box(dm, m, col, val), [unboxed]/~\n@@ -471,8 +471,8 @@ fn compile_submatch(bcx: block, m: match, vals: [ValueRef]/~,\n     }\n \n     if any_uniq_pat(m, col) {\n-        let box = Load(bcx, val);\n-        let box_no_addrspace = non_gc_box_cast(bcx, box);\n+        let llbox = Load(bcx, val);\n+        let box_no_addrspace = non_gc_box_cast(bcx, llbox);\n         let unboxed =\n             GEPi(bcx, box_no_addrspace, [0u, abi::box_field_body]/~);\n         compile_submatch(bcx, enter_uniq(dm, m, col, val),\n@@ -553,11 +553,11 @@ fn compile_submatch(bcx: block, m: match, vals: [ValueRef]/~,\n                             trans_compare(bcx, ast::eq, test_val, t, val, t)\n                           }\n                           range_result({val: vbegin, _}, {bcx, val: vend}) {\n-                            let {bcx, val: ge} = trans_compare(\n+                            let {bcx, val: llge} = trans_compare(\n                                 bcx, ast::ge, test_val, t, vbegin, t);\n-                            let {bcx, val: le} = trans_compare(\n+                            let {bcx, val: llle} = trans_compare(\n                                 bcx, ast::le, test_val, t, vend, t);\n-                            {bcx: bcx, val: And(bcx, ge, le)}\n+                            {bcx: bcx, val: And(bcx, llge, llle)}\n                           }\n                         }\n                     }\n@@ -744,15 +744,15 @@ fn bind_irrefutable_pat(bcx: block, pat: @ast::pat, val: ValueRef,\n         }\n       }\n       ast::pat_box(inner) {\n-        let box = Load(bcx, val);\n+        let llbox = Load(bcx, val);\n         let unboxed =\n-            GEPi(bcx, box, [0u, abi::box_field_body]/~);\n+            GEPi(bcx, llbox, [0u, abi::box_field_body]/~);\n         bcx = bind_irrefutable_pat(bcx, inner, unboxed, true);\n       }\n       ast::pat_uniq(inner) {\n-        let box = Load(bcx, val);\n+        let llbox = Load(bcx, val);\n         let unboxed =\n-            GEPi(bcx, box, [0u, abi::box_field_body]/~);\n+            GEPi(bcx, llbox, [0u, abi::box_field_body]/~);\n         bcx = bind_irrefutable_pat(bcx, inner, unboxed, true);\n       }\n       ast::pat_wild | ast::pat_lit(_) | ast::pat_range(_, _) { }"}, {"sha": "4f5d2c4ca0d55842250dc0879acca74aa7e5d77f", "filename": "src/rustc/middle/trans/base.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/c1157161d988a15156513dbe0f1f7895fb227606/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1157161d988a15156513dbe0f1f7895fb227606/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=c1157161d988a15156513dbe0f1f7895fb227606", "patch": "@@ -386,10 +386,10 @@ fn malloc_raw(bcx: block, t: ty::t, heap: heap) -> ValueRef {\n fn malloc_general_dyn(bcx: block, t: ty::t, heap: heap, size: ValueRef) ->\n     {box: ValueRef, body: ValueRef} {\n     let _icx = bcx.insn_ctxt(\"malloc_general\");\n-    let box = malloc_raw_dyn(bcx, t, heap, size);\n-    let non_gc_box = non_gc_box_cast(bcx, box);\n+    let llbox = malloc_raw_dyn(bcx, t, heap, size);\n+    let non_gc_box = non_gc_box_cast(bcx, llbox);\n     let body = GEPi(bcx, non_gc_box, [0u, abi::box_field_body]/~);\n-    ret {box: box, body: body};\n+    ret {box: llbox, body: body};\n }\n \n fn malloc_general(bcx: block, t: ty::t, heap: heap) ->\n@@ -652,8 +652,8 @@ fn make_take_glue(bcx: block, v: ValueRef, t: ty::t) {\n         closure::make_fn_glue(bcx, v, t, take_ty)\n       }\n       ty::ty_iface(_, _) {\n-        let box = Load(bcx, GEPi(bcx, v, [0u, 1u]/~));\n-        incr_refcnt_of_boxed(bcx, box);\n+        let llbox = Load(bcx, GEPi(bcx, v, [0u, 1u]/~));\n+        incr_refcnt_of_boxed(bcx, llbox);\n         bcx\n       }\n       ty::ty_opaque_closure_ptr(ck) {\n@@ -806,8 +806,8 @@ fn make_drop_glue(bcx: block, v0: ValueRef, t: ty::t) {\n         closure::make_fn_glue(bcx, v0, t, drop_ty)\n       }\n       ty::ty_iface(_, _) {\n-        let box = Load(bcx, GEPi(bcx, v0, [0u, 1u]/~));\n-        decr_refcnt_maybe_free(bcx, box, ty::mk_opaque_box(ccx.tcx))\n+        let llbox = Load(bcx, GEPi(bcx, v0, [0u, 1u]/~));\n+        decr_refcnt_maybe_free(bcx, llbox, ty::mk_opaque_box(ccx.tcx))\n       }\n       ty::ty_opaque_closure_ptr(ck) {\n         closure::make_opaque_cbox_drop_glue(bcx, ck, v0)\n@@ -1518,10 +1518,10 @@ fn trans_unary(bcx: block, op: ast::unop, e: @ast::expr,\n       }\n       ast::neg {\n         let {bcx, val} = trans_temp_expr(bcx, e);\n-        let neg = if ty::type_is_fp(e_ty) {\n+        let llneg = if ty::type_is_fp(e_ty) {\n             FNeg(bcx, val)\n         } else { Neg(bcx, val) };\n-        store_in_dest(bcx, neg, dest)\n+        store_in_dest(bcx, llneg, dest)\n       }\n       ast::box(_) {\n         trans_boxed_expr(bcx, e, e_ty, heap_shared, dest)\n@@ -2158,7 +2158,7 @@ fn monomorphic_fn(ccx: @crate_ctxt, fn_id: ast::def_id,\n     }\n \n     let tpt = ty::lookup_item_type(ccx.tcx, fn_id);\n-    let mut item_ty = tpt.ty;\n+    let mut llitem_ty = tpt.ty;\n \n     let map_node = session::expect(ccx.sess, ccx.tcx.items.find(fn_id.node),\n      {|| #fmt(\"While monomorphizing %?, couldn't find it in the item map \\\n@@ -2190,7 +2190,7 @@ fn monomorphic_fn(ccx: @crate_ctxt, fn_id: ast::def_id,\n           ccx.tcx.sess.bug(\"Can't monomorphize a local\")\n       }\n     };\n-    let mono_ty = ty::subst_tps(ccx.tcx, substs, item_ty);\n+    let mono_ty = ty::subst_tps(ccx.tcx, substs, llitem_ty);\n     let llfty = type_of_fn_from_ty(ccx, mono_ty);\n \n     let depth = option::get_default(ccx.monomorphizing.find(fn_id), 0u);\n@@ -2543,12 +2543,12 @@ fn trans_rec_field(bcx: block, base: @ast::expr,\n \n fn trans_rec_field_inner(bcx: block, val: ValueRef, ty: ty::t,\n                          field: ast::ident, sp: span) -> lval_result {\n-    let mut deref = false;\n+    let mut llderef = false;\n     let fields = alt ty::get(ty).struct {\n        ty::ty_rec(fs) { fs }\n        ty::ty_class(did, substs) {\n          if option::is_some(ty::ty_dtor(bcx.tcx(), did)) {\n-           deref = true;\n+           llderef = true;\n          }\n          ty::class_items_as_mutable_fields(bcx.tcx(), did, substs)\n        }\n@@ -2567,7 +2567,7 @@ fn trans_rec_field_inner(bcx: block, val: ValueRef, ty: ty::t,\n        have to select out the object itself\n        (If any other code does the same thing, that's\n        a bug */\n-    let val = if deref {\n+    let val = if llderef {\n         GEPi(bcx, GEPi(bcx, val, [0u, 1u]/~), [0u, ix]/~)\n     }\n     else { GEPi(bcx, val, [0u, ix]/~) };"}, {"sha": "756917082e4f7be7067637927f0571d4a30d959f", "filename": "src/rustc/middle/trans/closure.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/c1157161d988a15156513dbe0f1f7895fb227606/src%2Frustc%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1157161d988a15156513dbe0f1f7895fb227606/src%2Frustc%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fclosure.rs?ref=c1157161d988a15156513dbe0f1f7895fb227606", "patch": "@@ -150,21 +150,21 @@ fn allocate_cbox(bcx: block,\n     let _icx = bcx.insn_ctxt(\"closure::allocate_cbox\");\n     let ccx = bcx.ccx(), tcx = ccx.tcx;\n \n-    fn nuke_ref_count(bcx: block, box: ValueRef) {\n+    fn nuke_ref_count(bcx: block, llbox: ValueRef) {\n         let _icx = bcx.insn_ctxt(\"closure::nuke_ref_count\");\n         // Initialize ref count to arbitrary value for debugging:\n         let ccx = bcx.ccx();\n-        let box = PointerCast(bcx, box, T_opaque_box_ptr(ccx));\n-        let ref_cnt = GEPi(bcx, box, [0u, abi::box_field_refcnt]/~);\n+        let llbox = PointerCast(bcx, llbox, T_opaque_box_ptr(ccx));\n+        let ref_cnt = GEPi(bcx, llbox, [0u, abi::box_field_refcnt]/~);\n         let rc = C_int(ccx, 0x12345678);\n         Store(bcx, rc, ref_cnt);\n     }\n \n     fn store_tydesc(bcx: block,\n                     cdata_ty: ty::t,\n-                    box: ValueRef,\n+                    llbox: ValueRef,\n                     &ti: option<@tydesc_info>) -> block {\n-        let bound_tydesc = GEPi(bcx, box, [0u, abi::box_field_tydesc]/~);\n+        let bound_tydesc = GEPi(bcx, llbox, [0u, abi::box_field_tydesc]/~);\n         let td = base::get_tydesc(bcx.ccx(), cdata_ty, ti);\n         Store(bcx, td, bound_tydesc);\n         bcx\n@@ -173,29 +173,29 @@ fn allocate_cbox(bcx: block,\n     // Allocate and initialize the box:\n     let mut ti = none;\n     let mut temp_cleanups = []/~;\n-    let (bcx, box) = alt ck {\n+    let (bcx, llbox) = alt ck {\n       ty::ck_box {\n         get_tydesc(ccx, cdata_ty, ti);\n-        let box = malloc_raw(bcx, cdata_ty, heap_shared);\n-        (bcx, box)\n+        let llbox = malloc_raw(bcx, cdata_ty, heap_shared);\n+        (bcx, llbox)\n       }\n       ty::ck_uniq {\n-        let box = malloc_raw(bcx, cdata_ty, heap_exchange);\n-        (bcx, box)\n+        let llbox = malloc_raw(bcx, cdata_ty, heap_exchange);\n+        (bcx, llbox)\n       }\n       ty::ck_block {\n         let cbox_ty = tuplify_box_ty(tcx, cdata_ty);\n-        let box = base::alloc_ty(bcx, cbox_ty);\n-        nuke_ref_count(bcx, box);\n-        (bcx, box)\n+        let llbox = base::alloc_ty(bcx, cbox_ty);\n+        nuke_ref_count(bcx, llbox);\n+        (bcx, llbox)\n       }\n     };\n \n     base::lazily_emit_tydesc_glue(ccx, abi::tydesc_field_take_glue, ti);\n     base::lazily_emit_tydesc_glue(ccx, abi::tydesc_field_drop_glue, ti);\n     base::lazily_emit_tydesc_glue(ccx, abi::tydesc_field_free_glue, ti);\n \n-    ret (bcx, box, temp_cleanups);\n+    ret (bcx, llbox, temp_cleanups);\n }\n \n type closure_result = {"}, {"sha": "8a905a4a0472b0a6b406ebbc3aabf8dc46c1b865", "filename": "src/rustc/middle/trans/impl.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/c1157161d988a15156513dbe0f1f7895fb227606/src%2Frustc%2Fmiddle%2Ftrans%2Fimpl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1157161d988a15156513dbe0f1f7895fb227606/src%2Frustc%2Fmiddle%2Ftrans%2Fimpl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fimpl.rs?ref=c1157161d988a15156513dbe0f1f7895fb227606", "patch": "@@ -150,10 +150,10 @@ fn trans_iface_callee(bcx: block, val: ValueRef,\n     let ccx = bcx.ccx();\n     let vtable = Load(bcx, PointerCast(bcx, GEPi(bcx, val, [0u, 0u]/~),\n                                        T_ptr(T_ptr(T_vtable()))));\n-    let box = Load(bcx, GEPi(bcx, val, [0u, 1u]/~));\n+    let llbox = Load(bcx, GEPi(bcx, val, [0u, 1u]/~));\n     // FIXME[impl] I doubt this is alignment-safe (#2534)\n-    let self = GEPi(bcx, box, [0u, abi::box_field_body]/~);\n-    let env = self_env(self, ty::mk_opaque_box(bcx.tcx()), some(box));\n+    let self = GEPi(bcx, llbox, [0u, abi::box_field_body]/~);\n+    let env = self_env(self, ty::mk_opaque_box(bcx.tcx()), some(llbox));\n     let llfty = type_of::type_of_fn_from_ty(ccx, callee_ty);\n     let vtable = PointerCast(bcx, vtable,\n                              T_ptr(T_array(T_ptr(llfty), n_method + 1u)));\n@@ -284,13 +284,13 @@ fn trans_cast(bcx: block, val: @ast::expr, id: ast::node_id, dest: dest)\n     if dest == ignore { ret trans_expr(bcx, val, ignore); }\n     let ccx = bcx.ccx();\n     let v_ty = expr_ty(bcx, val);\n-    let {box, body} = malloc_boxed(bcx, v_ty);\n-    add_clean_free(bcx, box, heap_shared);\n+    let {box: llbox, body: body} = malloc_boxed(bcx, v_ty);\n+    add_clean_free(bcx, llbox, heap_shared);\n     let bcx = trans_expr_save_in(bcx, val, body);\n-    revoke_clean(bcx, box);\n+    revoke_clean(bcx, llbox);\n     let result = get_dest_addr(dest);\n-    Store(bcx, box, PointerCast(bcx, GEPi(bcx, result, [0u, 1u]/~),\n-                                T_ptr(val_ty(box))));\n+    Store(bcx, llbox, PointerCast(bcx, GEPi(bcx, result, [0u, 1u]/~),\n+                                  T_ptr(val_ty(llbox))));\n     let orig = ccx.maps.vtable_map.get(id)[0];\n     let orig = resolve_vtable_in_fn_ctxt(bcx.fcx, orig);\n     let vtable = get_vtable(bcx.ccx(), orig);"}]}