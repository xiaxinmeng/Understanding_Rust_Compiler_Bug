{"sha": "6bacbcc32efee19f05da01fc9a9474657988485d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZiYWNiY2MzMmVmZWUxOWYwNWRhMDFmYzlhOTQ3NDY1Nzk4ODQ4NWQ=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2014-04-09T02:55:56Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2014-04-10T01:53:13Z"}, "message": "doc: Edit intro", "tree": {"sha": "09e503084914b729c778e49a15df173bd4090b3b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/09e503084914b729c778e49a15df173bd4090b3b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6bacbcc32efee19f05da01fc9a9474657988485d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6bacbcc32efee19f05da01fc9a9474657988485d", "html_url": "https://github.com/rust-lang/rust/commit/6bacbcc32efee19f05da01fc9a9474657988485d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6bacbcc32efee19f05da01fc9a9474657988485d/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ad66f56afd7fd3127d6991bd6078246a799573c0", "url": "https://api.github.com/repos/rust-lang/rust/commits/ad66f56afd7fd3127d6991bd6078246a799573c0", "html_url": "https://github.com/rust-lang/rust/commit/ad66f56afd7fd3127d6991bd6078246a799573c0"}], "stats": {"total": 394, "additions": 230, "deletions": 164}, "files": [{"sha": "be5422f41ebc8c026d874eb73c10f433ae009227", "filename": "src/doc/intro.md", "status": "modified", "additions": 230, "deletions": 164, "changes": 394, "blob_url": "https://github.com/rust-lang/rust/blob/6bacbcc32efee19f05da01fc9a9474657988485d/src%2Fdoc%2Fintro.md", "raw_url": "https://github.com/rust-lang/rust/raw/6bacbcc32efee19f05da01fc9a9474657988485d/src%2Fdoc%2Fintro.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fintro.md?ref=6bacbcc32efee19f05da01fc9a9474657988485d", "patch": "@@ -1,36 +1,37 @@\n % A 30-minute Introduction to Rust\n \n-Rust is a systems programming language that focuses on strong compile-time correctness guarantees.\n-It improves upon the ideas other systems languages like C++, D,\n-and Cyclone by providing very strong guarantees and explicit control over the life cycle of memory.\n+Rust is a systems programming language that combines strong compile-time correctness guarantees with fast performance.\n+It improves upon the ideas of other systems languages like C++\n+by providing guaranteed memory safety (no crashes, no data races) and complete control over the lifecycle of memory.\n Strong memory guarantees make writing correct concurrent Rust code easier than in other languages.\n-This might sound very complex, but it's easier than it sounds!\n This tutorial will give you an idea of what Rust is like in about thirty minutes.\n-It expects that you're at least vaguely familiar with a previous 'curly brace' language.\n+It expects that you're at least vaguely familiar with a previous 'curly brace' language,\n+but does not require prior experience with systems programming.\n The concepts are more important than the syntax,\n so don't worry if you don't get every last detail:\n-the [tutorial](http://static.rust-lang.org/doc/master/tutorial.html) can help you out with that later.\n+the [tutorial](tutorial.html) can help you out with that later.\n \n Let's talk about the most important concept in Rust, \"ownership,\"\n and its implications on a task that programmers usually find very difficult: concurrency.\n \n-## Ownership\n+# The power of ownership\n \n Ownership is central to Rust,\n-and is one of its more interesting and unique features.\n-\"Ownership\" refers to which parts of your code are allowed to modify various parts of memory.\n+and is the feature from which many of Rust's powerful capabilities are derived.\n+\"Ownership\" refers to which parts of your code are allowed read,\n+write, and ultimately release, memory.\n Let's start by looking at some C++ code:\n \n-```\n-int *dangling(void)\n+```notrust\n+int* dangling(void)\n {\n     int i = 1234;\n     return &i;\n }\n \n int add_one(void)\n {\n-    int *num = dangling();\n+    int* num = dangling();\n     return *num + 1;\n }\n ```\n@@ -48,13 +49,11 @@ it can happen quite often in C++ code.\n There's a similar problem when memory on the heap is allocated with `malloc` (or `new`),\n then freed with `free` (or `delete`),\n yet your code attempts to do something with the pointer to that memory.\n-More modern C++ uses RAII with constructors/destructors,\n-but it amounts to the same thing.\n This problem is called a 'dangling pointer,'\n and it's not possible to write Rust code that has it.\n-Let's try:\n+Let's try writing it in Rust:\n \n-```\n+```ignore\n fn dangling() -> &int {\n     let i = 1234;\n     return &i;\n@@ -64,25 +63,28 @@ fn add_one() -> int {\n     let num = dangling();\n     return *num + 1;\n }\n-```\n-\n-When you try to compile this program, you'll get an interesting (and long) error message:\n \n+fn main() {\n+    add_one();\n+}\n ```\n-temp.rs:3:11: 3:13 error: borrowed value does not live long enough\n-temp.rs:3     return &i;\n-\n-temp.rs:1:22: 4:1 note: borrowed pointer must be valid for the anonymous lifetime #1 defined on the block at 1:22...\n-temp.rs:1 fn dangling() -> &int {\n-temp.rs:2     let i = 1234;\n-temp.rs:3     return &i;\n-temp.rs:4 }\n-                            \n-temp.rs:1:22: 4:1 note: ...but borrowed value is only valid for the block at 1:22\n-temp.rs:1 fn dangling() -> &int {      \n-temp.rs:2     let i = 1234;            \n-temp.rs:3     return &i;               \n-temp.rs:4  }                            \n+\n+Save this program as `dangling.rs`. When you try to compile this program with `rustc dangling.rs`, you'll get an interesting (and long) error message:\n+\n+```notrust\n+dangling.rs:3:12: 3:14 error: `i` does not live long enough\n+dangling.rs:3     return &i;\n+                         ^~\n+dangling.rs:1:23: 4:2 note: reference must be valid for the anonymous lifetime #1 defined on the block at 1:22...\n+dangling.rs:1 fn dangling() -> &int {\n+dangling.rs:2     let i = 1234;\n+dangling.rs:3     return &i;\n+dangling.rs:4 }\n+dangling.rs:1:23: 4:2 note: ...but borrowed value is only valid for the block at 1:22\n+dangling.rs:1 fn dangling() -> &int {\n+dangling.rs:2     let i = 1234;\n+dangling.rs:3     return &i;\n+dangling.rs:4 }\n error: aborting due to previous error\n ```\n \n@@ -104,24 +106,24 @@ This concept applies directly to Rust code as well:\n some code \"owns\" a particular pointer to memory.\n It's the sole owner of that pointer.\n It can also lend that memory out to some other code for a while:\n-the code \"borrows\" it.\n-It borrows it for a certain period of time, called a \"lifetime.\"\n+that code \"borrows\" the memory,\n+and it borrows it for a precise period of time,\n+called a \"lifetime.\"\n \n That's all there is to it.\n That doesn't seem so hard, right?\n Let's go back to that error message:\n-`error: borrowed value does not live long enough`.\n+`error: 'i' does not live long enough`.\n We tried to loan out a particular variable, `i`,\n-using Rust's borrowed pointers: the `&`.\n-But Rust knew that the variable would be invalid after the function returns,\n+using a reference (the `&` operator) but Rust knew that the variable would be invalid after the function returns,\n and so it tells us that:\n-`borrowed pointer must be valid for the anonymous lifetime #1... but borrowed value is only valid for the block`.\n+`reference must be valid for the anonymous lifetime #1...`.\n Neat!\n \n That's a great example for stack memory,\n but what about heap memory?\n Rust has a second kind of pointer,\n-a 'unique' pointer,\n+an 'owned box',\n that you can create with a `~`.\n Check it out:\n \n@@ -137,24 +139,28 @@ fn add_one() -> int {\n }\n ```\n \n-This code will successfully compile.\n-Note that instead of a stack allocated `1234`,\n-we use an owned pointer to that value instead: `~1234`.\n+Now instead of a stack allocated `1234`,\n+we have a heap allocated `~1234`.\n+Whereas `&` borrows a pointer to existing memory,\n+creating an owned box allocates memory on the heap and places a value in it,\n+giving you the sole pointer to that memory.\n You can roughly compare these two lines:\n \n ```\n-// rust\n+// Rust\n let i = ~1234;\n+```\n \n+```notrust\n // C++\n int *i = new int;\n *i = 1234;\n ```\n \n-Rust is able to infer the size of the type,\n-then allocates the correct amount of memory and sets it to the value you asked for.\n+Rust infers the correct type,\n+allocates the correct amount of memory and sets it to the value you asked for.\n This means that it's impossible to allocate uninitialized memory:\n-Rust does not have the concept of null.\n+*Rust does not have the concept of null*.\n Hooray!\n There's one other difference between this line of Rust and the C++:\n The Rust compiler also figures out the lifetime of `i`,\n@@ -166,166 +172,230 @@ so there's no runtime overhead.\n You'll get (basically) the exact same code that you'd get if you wrote the correct C++,\n but it's impossible to write the incorrect version, thanks to the compiler.\n \n-You've seen one way that ownership and lifetimes are useful to prevent code that would normally be dangerous in a less-strict language,\n+You've seen one way that ownership and borrowing are useful to prevent code that would normally be dangerous in a less-strict language,\n but let's talk about another: concurrency.\n \n-## Concurrency\n+# Owning concurrency\n \n Concurrency is an incredibly hot topic in the software world right now.\n It's always been an interesting area of study for computer scientists,\n but as usage of the Internet explodes,\n people are looking to improve the number of users a given service can handle.\n Concurrency is one way of achieving this goal.\n There is a pretty big drawback to concurrent code, though:\n-it can be hard to reason about,\n-because it is non-deterministic.\n+it can be hard to reason about, because it is non-deterministic.\n There are a few different approaches to writing good concurrent code,\n-but let's talk about how Rust's notions of ownership and lifetimes can assist with achieving correct but concurrent code.\n+but let's talk about how Rust's notions of ownership and lifetimes contribute to correct but concurrent code.\n \n-First, let's go over a simple concurrency example in Rust.\n-Rust allows you to spin up 'tasks,'\n-which are lightweight, 'green' threads.\n-These tasks do not have any shared memory, and so,\n-we communicate between tasks with a 'channel'.\n-Like this:\n+First, let's go over a simple concurrency example.\n+Rust makes it easy to create \"tasks\",\n+otherwise known as \"threads\".\n+Typically, tasks do not share memory but instead communicate amongst each other with 'channels', like this:\n \n ```\n fn main() {\n-    let numbers = [1,2,3];\n+    let numbers = ~[1,2,3];\n \n-    let (port, chan)  = Chan::new();\n-    chan.send(numbers);\n+    let (tx, rx)  = channel();\n+    tx.send(numbers);\n \n-    do spawn {\n-        let numbers = port.recv();\n-        println!(\"{:d}\", numbers[0]);\n-    }\n+    spawn(proc() {\n+        let numbers = rx.recv();\n+        println!(\"{}\", numbers[0]);\n+    })\n }\n ```\n \n-In this example, we create a vector of numbers.\n-We then make a new `Chan`,\n-which is the name of the package Rust implements channels with.\n-This returns two different ends of the channel:\n-a channel and a port.\n-You send data into the channel end, and it comes out the port end.\n-The `spawn` function spins up a new task.\n+In this example, we create a boxed array of numbers.\n+We then make a 'channel',\n+Rust's primary means of passing messages between tasks.\n+The `channel` function returns two different ends of the channel:\n+a `Sender` and `Receiver` (commonly abbreviated `tx` and `rx`).\n+The `spawn` function spins up a new task,\n+given a *heap allocated closure* to run.\n As you can see in the code,\n-we call `port.recv()` (short for 'receive') inside of the new task,\n-and we call `chan.send()` outside,\n-passing in our vector.\n-We then print the first element of the vector.\n-\n-This works out because Rust copies the vector when it is sent through the channel.\n-That way, if it were mutable, there wouldn't be a race condition.\n-However, if we're making a lot of tasks, or if our data is very large,\n-making a copy for each task inflates our memory usage with no real benefit.\n-\n-Enter Arc.\n-Arc stands for 'atomically reference counted,'\n-and it's a way to share immutable data between multiple tasks.\n-Here's some code:\n+we call `chan.send()` from the original task,\n+passing in our boxed array,\n+and we call `rx.recv()` (short for 'receive') inside of the new task:\n+values given to the `Sender` via the `send` method come out the other end via the `recv` method on the `Receiver`.\n+\n+Now here's the exciting part:\n+because `numbers` is an owned type,\n+when it is sent across the channel,\n+it is actually *moved*,\n+transfering ownership of `numbers` between tasks.\n+This ownership transfer is *very fast* -\n+in this case simply copying a pointer -\n+while also ensuring that the original owning task cannot create data races by continuing to read or write to `numbers` in parallel with the new owner.\n+\n+To prove that Rust performs the ownership transfer,\n+try to modify the previous example to continue using the variable `numbers`:\n+\n+```ignore\n+fn main() {\n+    let numbers = ~[1,2,3];\n+\n+    let (tx, rx)  = channel();\n+    tx.send(numbers);\n+\n+    spawn(proc() {\n+        let numbers = rx.recv();\n+        println!(\"{}\", numbers[0]);\n+    });\n \n+    // Try to print a number from the original task\n+    println!(\"{}\", numbers[0]);\n+}\n ```\n-extern mod extra;\n-use extra::arc::Arc;\n \n-fn main() {\n-    let numbers = [1,2,3];\n+This will result an error indicating that the value is no longer in scope:\n \n-    let numbers_arc = Arc::new(numbers);\n+```notrust\n+concurrency.rs:12:20: 12:27 error: use of moved value: 'numbers'\n+concurrency.rs:12     println!(\"{}\", numbers[0]);\n+                                     ^~~~~~~\n+```\n+\n+Since only one task can own a boxed array at a time,\n+if instead of distributing our `numbers` array to a single task we wanted to distribute it to many tasks,\n+we would need to copy the array for each.\n+Let's see an example that uses the `clone` method to create copies of the data:\n+\n+```\n+fn main() {\n+    let numbers = ~[1,2,3];\n \n     for num in range(0, 3) {\n-        let (port, chan)  = Chan::new();\n-        chan.send(numbers_arc.clone());\n-\n-        do spawn {\n-            let local_arc = port.recv();\n-            let task_numbers = local_arc.get();\n-            println!(\"{:d}\", task_numbers[num]);\n-        }\n+        let (tx, rx)  = channel();\n+        // Use `clone` to send a *copy* of the array\n+        tx.send(numbers.clone());\n+\n+        spawn(proc() {\n+            let numbers = rx.recv();\n+            println!(\"{:d}\", numbers[num as uint]);\n+        })\n     }\n }\n ```\n \n-This is very similar to the code we had before,\n+This is similar to the code we had before,\n except now we loop three times,\n making three tasks,\n-and sending an `Arc` between them.\n-`Arc::new` creates a new Arc,\n-`.clone()` makes a new reference to that Arc,\n-and `.get()` gets the value out of the Arc.\n-So we make a new reference for each task,\n-send that reference down the channel,\n-and then use the reference to print out a number.\n-Now we're not copying our vector.\n+and *cloning* `numbers` before sending it.\n+\n+However, if we're making a lot of tasks,\n+or if our data is very large,\n+creating a copy for each task requires a lot of work and a lot of extra memory for little benefit.\n+In practice, we might not want to do this because of the cost.\n+Enter `Arc`,\n+an atomically reference counted box (\"A.R.C.\" == \"atomically reference counted\").\n+`Arc` is the most common way to *share* data between tasks.\n+Here's some code:\n+\n+```\n+extern crate sync;\n+use sync::Arc;\n+\n+fn main() {\n+    let numbers = ~[1,2,3];\n+    let numbers = Arc::new(numbers);\n+\n+    for num in range(0, 3) {\n+        let (tx, rx)  = channel();\n+        tx.send(numbers.clone());\n+\n+        spawn(proc() {\n+            let numbers = rx.recv();\n+            println!(\"{:d}\", numbers[num as uint]);\n+        })\n+    }\n+}\n+```\n+\n+This is almost exactly the same,\n+except that this time `numbers` is first put into an `Arc`.\n+`Arc::new` creates the `Arc`,\n+`.clone()` makes another `Arc` that referrs to the same contents.\n+So we clone the `Arc` for each task,\n+send that clone down the channel,\n+and then use it to print out a number.\n+Now instead of copying an entire array to send it to our multiple tasks we are just copying a pointer (the `Arc`) and *sharing* the array.\n+\n+How can this work though?\n+Surely if we're sharing data then can't we cause data races if one task writes to the array while others read?\n+\n+Well, Rust is super-smart and will only let you put data into an `Arc` that is provably safe to share.\n+In this case, it's safe to share the array *as long as it's immutable*,\n+i.e. many tasks may read the data in parallel as long as none can write.\n+So for this type and many others `Arc` will only give you an immutable view of the data.\n \n Arcs are great for immutable data,\n but what about mutable data?\n-Shared mutable state is the bane of the concurrent programmer.\n-You can use a mutex to protect shared mutable state,\n-but if you forget to acquire the mutex, bad things can happen.\n+Shared mutable state is the bane of the concurrent programmer:\n+you can use a mutex to protect shared mutable state,\n+but if you forget to acquire the mutex, bad things can happen, including crashes.\n+Rust provides mutexes but makes it impossible to use them in a way that subverts memory safety.\n \n-Rust provides a tool for shared mutable state: `RWArc`.\n-This variant of an Arc allows the contents of the Arc to be mutated.\n-Check it out:\n+Let's take the same example yet again,\n+and modify it to mutate the shared state:\n \n ```\n-extern mod extra;\n-use extra::arc::RWArc;\n+extern crate sync;\n+use sync::{Arc, Mutex};\n \n fn main() {\n-    let numbers = [1,2,3];\n-\n-    let numbers_arc = RWArc::new(numbers);\n+    let numbers = ~[1,2,3];\n+    let numbers_lock = Arc::new(Mutex::new(numbers));\n \n     for num in range(0, 3) {\n-        let (port, chan)  = Chan::new();\n-        chan.send(numbers_arc.clone());\n+        let (tx, rx)  = channel();\n+        tx.send(numbers_lock.clone());\n+\n+        spawn(proc() {\n+            let numbers_lock = rx.recv();\n \n-        do spawn {\n-            let local_arc = port.recv();\n+            // Take the lock, along with exclusive access to the underlying array\n+            let mut numbers = numbers_lock.lock();\n+            numbers[num as uint] += 1;\n \n-            local_arc.write(|nums| {\n-                nums[num] += 1\n-            });\n+            println!(\"{}\", numbers[num as uint]);\n \n-            local_arc.read(|nums| {\n-                println!(\"{:d}\", nums[num]);\n-            })\n-        }\n+            // When `numbers` goes out of scope the lock is dropped\n+        })\n     }\n }\n ```\n \n-We now use the `RWArc` package to get a read/write Arc.\n-The read/write Arc has a slightly different API than `Arc`:\n-`read` and `write` allow you to, well, read and write the data.\n-They both take closures as arguments,\n-and the read/write Arc will, in the case of write,\n-acquire a mutex,\n-and then pass the data to this closure.\n-After the closure does its thing, the mutex is released.\n+This example is starting to get more subtle,\n+but it hints at the powerful compositionality of Rust's concurrent types.\n+This time we've put our array of numbers inside a `Mutex` and then put *that* inside the `Arc`.\n+Like immutable data,\n+`Mutex`es are sharable,\n+but unlike immutable data,\n+data inside a `Mutex` may be mutated as long as the mutex is locked.\n \n-You can see how this makes it impossible to mutate the state without remembering to aquire the lock.\n-We gain the efficiency of shared mutable state,\n-while retaining the safety of disallowing shared mutable state.\n+The `lock` method here returns not your original array or a pointer thereof,\n+but a `MutexGuard`,\n+a type that is responsible for releasing the lock when it goes out of scope.\n+This same `MutexGuard` can transparently be treated as if it were the value the `Mutex` contains,\n+as you can see in the subsequent indexing operation that performs the mutation.\n \n-But wait, how is that possible?\n-We can't both allow and disallow mutable state.\n-What gives?\n+OK, let's stop there before we get too deep.\n \n-## A footnote: unsafe\n+# A footnote: unsafe\n \n-So, the Rust language does not allow for shared mutable state,\n-yet I just showed you some code that has it.\n-How's this possible? The answer: `unsafe`.\n+The Rust compiler and libraries are entirely written in Rust;\n+we say that Rust is \"self-hosting\".\n+If Rust makes it impossible to unsafely share data between threads,\n+and Rust is written in Rust,\n+then how does it implement concurrent types like `Arc` and `Mutex`?\n+The answer: `unsafe`.\n \n You see, while the Rust compiler is very smart,\n and saves you from making mistakes you might normally make,\n it's not an artificial intelligence.\n-Because we're smarter than the compiler,\n-sometimes, we need to over-ride this safe behavior.\n+Because we're smarter than the compiler -\n+sometimes - we need to over-ride this safe behavior.\n For this purpose, Rust has an `unsafe` keyword.\n Within an `unsafe` block,\n Rust turns off many of its safety checks.\n@@ -337,28 +407,24 @@ If one of the major goals of Rust was safety,\n why allow that safety to be turned off?\n Well, there are really only three main reasons to do it:\n interfacing with external code,\n-such as doing FFI into a C library,\n-performance (in certain cases),\n+such as doing FFI into a C library;\n+performance (in certain cases);\n and to provide a safe abstraction around operations that normally would not be safe.\n-Our Arcs are an example of this last purpose.\n-We can safely hand out multiple references to the `Arc`,\n-because we are sure the data is immutable,\n-and therefore it is safe to share.\n-We can hand out multiple references to the `RWArc`,\n-because we know that we've wrapped the data in a mutex,\n-and therefore it is safe to share.\n+Our `Arc`s are an example of this last purpose.\n+We can safely hand out multiple pointers to the contents of the `Arc`,\n+because we are sure the data is safe to share.\n But the Rust compiler can't know that we've made these choices,\n so _inside_ the implementation of the Arcs,\n we use `unsafe` blocks to do (normally) dangerous things.\n But we expose a safe interface,\n-which means that the Arcs are impossible to use incorrectly.\n+which means that the `Arc`s are impossible to use incorrectly.\n \n-This is how Rust's type system allows you to not make some of the mistakes that make concurrent programming difficult,\n+This is how Rust's type system prevents you from making some of the mistakes that make concurrent programming difficult,\n yet get the efficiency of languages such as C++.\n \n-## That's all, folks\n+# That's all, folks\n \n I hope that this taste of Rust has given you an idea if Rust is the right language for you.\n If that's true,\n-I encourage you to check out [the tutorial](http://static.rust-lang.org/doc/0.9/tutorial.html) for a full,\n-in-depth exploration of Rust's syntax and concepts.\n\\ No newline at end of file\n+I encourage you to check out [the tutorial](tutorial.html) for a full,\n+in-depth exploration of Rust's syntax and concepts."}]}