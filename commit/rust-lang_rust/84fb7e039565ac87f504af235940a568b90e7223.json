{"sha": "84fb7e039565ac87f504af235940a568b90e7223", "node_id": "C_kwDOAAsO6NoAKDg0ZmI3ZTAzOTU2NWFjODdmNTA0YWYyMzU5NDBhNTY4YjkwZTcyMjM", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-08-17T13:14:55Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-08-17T13:14:55Z"}, "message": "Auto merge of #9287 - Jarcho:trans_undefined, r=xFrednet\n\n`transmute_undefined_repr` fix\n\nchangelog: Don't lint `transmute_undefined_repr` when the the first field of a `repr(C)` type is compatible with the other type", "tree": {"sha": "05d08cf603c33fae41816cd3722a91313cc76703", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/05d08cf603c33fae41816cd3722a91313cc76703"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/84fb7e039565ac87f504af235940a568b90e7223", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/84fb7e039565ac87f504af235940a568b90e7223", "html_url": "https://github.com/rust-lang/rust/commit/84fb7e039565ac87f504af235940a568b90e7223", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/84fb7e039565ac87f504af235940a568b90e7223/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dc497c82ff1eb7377a0490885f5bbc53c0f1e4e8", "url": "https://api.github.com/repos/rust-lang/rust/commits/dc497c82ff1eb7377a0490885f5bbc53c0f1e4e8", "html_url": "https://github.com/rust-lang/rust/commit/dc497c82ff1eb7377a0490885f5bbc53c0f1e4e8"}, {"sha": "99e77d07b2856fccd083d5810a9756e07cc4c524", "url": "https://api.github.com/repos/rust-lang/rust/commits/99e77d07b2856fccd083d5810a9756e07cc4c524", "html_url": "https://github.com/rust-lang/rust/commit/99e77d07b2856fccd083d5810a9756e07cc4c524"}], "stats": {"total": 450, "additions": 222, "deletions": 228}, "files": [{"sha": "b6d7d9f5b42ec2a7c5138163a738ced1b4cb8271", "filename": "clippy_lints/src/transmute/transmute_undefined_repr.rs", "status": "modified", "additions": 183, "deletions": 217, "changes": 400, "blob_url": "https://github.com/rust-lang/rust/blob/84fb7e039565ac87f504af235940a568b90e7223/clippy_lints%2Fsrc%2Ftransmute%2Ftransmute_undefined_repr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84fb7e039565ac87f504af235940a568b90e7223/clippy_lints%2Fsrc%2Ftransmute%2Ftransmute_undefined_repr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftransmute%2Ftransmute_undefined_repr.rs?ref=84fb7e039565ac87f504af235940a568b90e7223", "patch": "@@ -5,9 +5,9 @@ use rustc_hir::Expr;\n use rustc_lint::LateContext;\n use rustc_middle::ty::subst::{Subst, SubstsRef};\n use rustc_middle::ty::{self, IntTy, Ty, TypeAndMut, UintTy};\n-use rustc_span::Span;\n+use rustc_span::DUMMY_SP;\n \n-#[allow(clippy::too_many_lines)]\n+#[expect(clippy::too_many_lines)]\n pub(super) fn check<'tcx>(\n     cx: &LateContext<'tcx>,\n     e: &'tcx Expr<'_>,\n@@ -18,116 +18,89 @@ pub(super) fn check<'tcx>(\n     let mut to_ty = cx.tcx.erase_regions(to_ty_orig);\n \n     while from_ty != to_ty {\n-        match reduce_refs(cx, e.span, from_ty, to_ty) {\n-            ReducedTys::FromFatPtr {\n-                unsized_ty,\n-                to_ty: to_sub_ty,\n-            } => match reduce_ty(cx, to_sub_ty) {\n-                ReducedTy::TypeErasure => break,\n-                ReducedTy::UnorderedFields(ty) if is_size_pair(ty) => break,\n-                ReducedTy::Ref(to_sub_ty) => {\n-                    from_ty = unsized_ty;\n-                    to_ty = to_sub_ty;\n-                    continue;\n-                },\n-                _ => {\n-                    span_lint_and_then(\n-                        cx,\n-                        TRANSMUTE_UNDEFINED_REPR,\n-                        e.span,\n-                        &format!(\"transmute from `{}` which has an undefined layout\", from_ty_orig),\n-                        |diag| {\n-                            if from_ty_orig.peel_refs() != unsized_ty {\n-                                diag.note(&format!(\"the contained type `&{}` has an undefined layout\", unsized_ty));\n-                            }\n-                        },\n-                    );\n-                    return true;\n-                },\n+        let reduced_tys = reduce_refs(cx, from_ty, to_ty);\n+        match (reduce_ty(cx, reduced_tys.from_ty), reduce_ty(cx, reduced_tys.to_ty)) {\n+            // Various forms of type erasure.\n+            (ReducedTy::TypeErasure { raw_ptr_only: false }, _)\n+            | (_, ReducedTy::TypeErasure { raw_ptr_only: false }) => return false,\n+            (ReducedTy::TypeErasure { .. }, _) if reduced_tys.from_raw_ptr => return false,\n+            (_, ReducedTy::TypeErasure { .. }) if reduced_tys.to_raw_ptr => return false,\n+\n+            // `Repr(C)` <-> unordered type.\n+            // If the first field of the `Repr(C)` type matches then the transmute is ok\n+            (ReducedTy::OrderedFields(_, Some(from_sub_ty)), ReducedTy::UnorderedFields(to_sub_ty))\n+            | (ReducedTy::UnorderedFields(from_sub_ty), ReducedTy::OrderedFields(_, Some(to_sub_ty))) => {\n+                from_ty = from_sub_ty;\n+                to_ty = to_sub_ty;\n+                continue;\n             },\n-            ReducedTys::ToFatPtr {\n-                unsized_ty,\n-                from_ty: from_sub_ty,\n-            } => match reduce_ty(cx, from_sub_ty) {\n-                ReducedTy::TypeErasure => break,\n-                ReducedTy::UnorderedFields(ty) if is_size_pair(ty) => break,\n-                ReducedTy::Ref(from_sub_ty) => {\n-                    from_ty = from_sub_ty;\n-                    to_ty = unsized_ty;\n-                    continue;\n-                },\n-                _ => {\n-                    span_lint_and_then(\n-                        cx,\n-                        TRANSMUTE_UNDEFINED_REPR,\n-                        e.span,\n-                        &format!(\"transmute to `{}` which has an undefined layout\", to_ty_orig),\n-                        |diag| {\n-                            if to_ty_orig.peel_refs() != unsized_ty {\n-                                diag.note(&format!(\"the contained type `&{}` has an undefined layout\", unsized_ty));\n-                            }\n-                        },\n-                    );\n-                    return true;\n-                },\n+            (ReducedTy::OrderedFields(_, Some(from_sub_ty)), ReducedTy::Other(to_sub_ty)) if reduced_tys.to_fat_ptr => {\n+                from_ty = from_sub_ty;\n+                to_ty = to_sub_ty;\n+                continue;\n             },\n-            ReducedTys::ToPtr {\n-                from_ty: from_sub_ty,\n-                to_ty: to_sub_ty,\n-            } => match reduce_ty(cx, from_sub_ty) {\n-                ReducedTy::UnorderedFields(from_ty) => {\n-                    span_lint_and_then(\n-                        cx,\n-                        TRANSMUTE_UNDEFINED_REPR,\n-                        e.span,\n-                        &format!(\"transmute from `{}` which has an undefined layout\", from_ty_orig),\n-                        |diag| {\n-                            if from_ty_orig.peel_refs() != from_ty {\n-                                diag.note(&format!(\"the contained type `{}` has an undefined layout\", from_ty));\n-                            }\n-                        },\n-                    );\n-                    return true;\n-                },\n-                ReducedTy::Ref(from_sub_ty) => {\n-                    from_ty = from_sub_ty;\n-                    to_ty = to_sub_ty;\n-                    continue;\n-                },\n-                _ => break,\n+            (ReducedTy::Other(from_sub_ty), ReducedTy::OrderedFields(_, Some(to_sub_ty)))\n+                if reduced_tys.from_fat_ptr =>\n+            {\n+                from_ty = from_sub_ty;\n+                to_ty = to_sub_ty;\n+                continue;\n             },\n-            ReducedTys::FromPtr {\n-                from_ty: from_sub_ty,\n-                to_ty: to_sub_ty,\n-            } => match reduce_ty(cx, to_sub_ty) {\n-                ReducedTy::UnorderedFields(to_ty) => {\n-                    span_lint_and_then(\n-                        cx,\n-                        TRANSMUTE_UNDEFINED_REPR,\n-                        e.span,\n-                        &format!(\"transmute to `{}` which has an undefined layout\", to_ty_orig),\n-                        |diag| {\n-                            if to_ty_orig.peel_refs() != to_ty {\n-                                diag.note(&format!(\"the contained type `{}` has an undefined layout\", to_ty));\n-                            }\n-                        },\n-                    );\n-                    return true;\n-                },\n-                ReducedTy::Ref(to_sub_ty) => {\n-                    from_ty = from_sub_ty;\n-                    to_ty = to_sub_ty;\n-                    continue;\n-                },\n-                _ => break,\n+\n+            // ptr <-> ptr\n+            (ReducedTy::Other(from_sub_ty), ReducedTy::Other(to_sub_ty))\n+                if matches!(from_sub_ty.kind(), ty::Ref(..) | ty::RawPtr(_))\n+                    && matches!(to_sub_ty.kind(), ty::Ref(..) | ty::RawPtr(_)) =>\n+            {\n+                from_ty = from_sub_ty;\n+                to_ty = to_sub_ty;\n+                continue;\n             },\n-            ReducedTys::Other {\n-                from_ty: from_sub_ty,\n-                to_ty: to_sub_ty,\n-            } => match (reduce_ty(cx, from_sub_ty), reduce_ty(cx, to_sub_ty)) {\n-                (ReducedTy::TypeErasure, _) | (_, ReducedTy::TypeErasure) => return false,\n-                (ReducedTy::UnorderedFields(from_ty), ReducedTy::UnorderedFields(to_ty)) if from_ty != to_ty => {\n-                    let same_adt_did = if let (ty::Adt(from_def, from_subs), ty::Adt(to_def, to_subs))\n+\n+            // fat ptr <-> (*size, *size)\n+            (ReducedTy::Other(_), ReducedTy::UnorderedFields(to_ty))\n+                if reduced_tys.from_fat_ptr && is_size_pair(to_ty) =>\n+            {\n+                return false;\n+            },\n+            (ReducedTy::UnorderedFields(from_ty), ReducedTy::Other(_))\n+                if reduced_tys.to_fat_ptr && is_size_pair(from_ty) =>\n+            {\n+                return false;\n+            },\n+\n+            // fat ptr -> some struct | some struct -> fat ptr\n+            (ReducedTy::Other(_), _) if reduced_tys.from_fat_ptr => {\n+                span_lint_and_then(\n+                    cx,\n+                    TRANSMUTE_UNDEFINED_REPR,\n+                    e.span,\n+                    &format!(\"transmute from `{}` which has an undefined layout\", from_ty_orig),\n+                    |diag| {\n+                        if from_ty_orig.peel_refs() != from_ty.peel_refs() {\n+                            diag.note(&format!(\"the contained type `{}` has an undefined layout\", from_ty));\n+                        }\n+                    },\n+                );\n+                return true;\n+            },\n+            (_, ReducedTy::Other(_)) if reduced_tys.to_fat_ptr => {\n+                span_lint_and_then(\n+                    cx,\n+                    TRANSMUTE_UNDEFINED_REPR,\n+                    e.span,\n+                    &format!(\"transmute to `{}` which has an undefined layout\", to_ty_orig),\n+                    |diag| {\n+                        if to_ty_orig.peel_refs() != to_ty.peel_refs() {\n+                            diag.note(&format!(\"the contained type `{}` has an undefined layout\", to_ty));\n+                        }\n+                    },\n+                );\n+                return true;\n+            },\n+\n+            (ReducedTy::UnorderedFields(from_ty), ReducedTy::UnorderedFields(to_ty)) if from_ty != to_ty => {\n+                let same_adt_did = if let (ty::Adt(from_def, from_subs), ty::Adt(to_def, to_subs))\n                         = (from_ty.kind(), to_ty.kind())\n                         && from_def == to_def\n                     {\n@@ -138,144 +111,137 @@ pub(super) fn check<'tcx>(\n                     } else {\n                         None\n                     };\n-                    span_lint_and_then(\n-                        cx,\n-                        TRANSMUTE_UNDEFINED_REPR,\n-                        e.span,\n-                        &format!(\n-                            \"transmute from `{}` to `{}`, both of which have an undefined layout\",\n-                            from_ty_orig, to_ty_orig\n-                        ),\n-                        |diag| {\n-                            if let Some(same_adt_did) = same_adt_did {\n-                                diag.note(&format!(\n-                                    \"two instances of the same generic type (`{}`) may have different layouts\",\n-                                    cx.tcx.item_name(same_adt_did)\n-                                ));\n-                            } else {\n-                                if from_ty_orig.peel_refs() != from_ty {\n-                                    diag.note(&format!(\"the contained type `{}` has an undefined layout\", from_ty));\n-                                }\n-                                if to_ty_orig.peel_refs() != to_ty {\n-                                    diag.note(&format!(\"the contained type `{}` has an undefined layout\", to_ty));\n-                                }\n-                            }\n-                        },\n-                    );\n-                    return true;\n-                },\n-                (\n-                    ReducedTy::UnorderedFields(from_ty),\n-                    ReducedTy::Other(_) | ReducedTy::OrderedFields(_) | ReducedTy::Ref(_),\n-                ) => {\n-                    span_lint_and_then(\n-                        cx,\n-                        TRANSMUTE_UNDEFINED_REPR,\n-                        e.span,\n-                        &format!(\"transmute from `{}` which has an undefined layout\", from_ty_orig),\n-                        |diag| {\n+                span_lint_and_then(\n+                    cx,\n+                    TRANSMUTE_UNDEFINED_REPR,\n+                    e.span,\n+                    &format!(\n+                        \"transmute from `{}` to `{}`, both of which have an undefined layout\",\n+                        from_ty_orig, to_ty_orig\n+                    ),\n+                    |diag| {\n+                        if let Some(same_adt_did) = same_adt_did {\n+                            diag.note(&format!(\n+                                \"two instances of the same generic type (`{}`) may have different layouts\",\n+                                cx.tcx.item_name(same_adt_did)\n+                            ));\n+                        } else {\n                             if from_ty_orig.peel_refs() != from_ty {\n                                 diag.note(&format!(\"the contained type `{}` has an undefined layout\", from_ty));\n                             }\n-                        },\n-                    );\n-                    return true;\n-                },\n-                (\n-                    ReducedTy::Other(_) | ReducedTy::OrderedFields(_) | ReducedTy::Ref(_),\n-                    ReducedTy::UnorderedFields(to_ty),\n-                ) => {\n-                    span_lint_and_then(\n-                        cx,\n-                        TRANSMUTE_UNDEFINED_REPR,\n-                        e.span,\n-                        &format!(\"transmute into `{}` which has an undefined layout\", to_ty_orig),\n-                        |diag| {\n                             if to_ty_orig.peel_refs() != to_ty {\n                                 diag.note(&format!(\"the contained type `{}` has an undefined layout\", to_ty));\n                             }\n-                        },\n-                    );\n-                    return true;\n-                },\n-                (ReducedTy::Ref(from_sub_ty), ReducedTy::Ref(to_sub_ty)) => {\n-                    from_ty = from_sub_ty;\n-                    to_ty = to_sub_ty;\n-                    continue;\n-                },\n-                (\n-                    ReducedTy::OrderedFields(_) | ReducedTy::Ref(_) | ReducedTy::Other(_) | ReducedTy::Param,\n-                    ReducedTy::OrderedFields(_) | ReducedTy::Ref(_) | ReducedTy::Other(_) | ReducedTy::Param,\n-                )\n-                | (\n-                    ReducedTy::UnorderedFields(_) | ReducedTy::Param,\n-                    ReducedTy::UnorderedFields(_) | ReducedTy::Param,\n-                ) => break,\n+                        }\n+                    },\n+                );\n+                return true;\n+            },\n+            (\n+                ReducedTy::UnorderedFields(from_ty),\n+                ReducedTy::Other(_) | ReducedTy::OrderedFields(..) | ReducedTy::TypeErasure { raw_ptr_only: true },\n+            ) => {\n+                span_lint_and_then(\n+                    cx,\n+                    TRANSMUTE_UNDEFINED_REPR,\n+                    e.span,\n+                    &format!(\"transmute from `{}` which has an undefined layout\", from_ty_orig),\n+                    |diag| {\n+                        if from_ty_orig.peel_refs() != from_ty {\n+                            diag.note(&format!(\"the contained type `{}` has an undefined layout\", from_ty));\n+                        }\n+                    },\n+                );\n+                return true;\n+            },\n+            (\n+                ReducedTy::Other(_) | ReducedTy::OrderedFields(..) | ReducedTy::TypeErasure { raw_ptr_only: true },\n+                ReducedTy::UnorderedFields(to_ty),\n+            ) => {\n+                span_lint_and_then(\n+                    cx,\n+                    TRANSMUTE_UNDEFINED_REPR,\n+                    e.span,\n+                    &format!(\"transmute into `{}` which has an undefined layout\", to_ty_orig),\n+                    |diag| {\n+                        if to_ty_orig.peel_refs() != to_ty {\n+                            diag.note(&format!(\"the contained type `{}` has an undefined layout\", to_ty));\n+                        }\n+                    },\n+                );\n+                return true;\n+            },\n+            (\n+                ReducedTy::OrderedFields(..) | ReducedTy::Other(_) | ReducedTy::TypeErasure { raw_ptr_only: true },\n+                ReducedTy::OrderedFields(..) | ReducedTy::Other(_) | ReducedTy::TypeErasure { raw_ptr_only: true },\n+            )\n+            | (ReducedTy::UnorderedFields(_), ReducedTy::UnorderedFields(_)) => {\n+                break;\n             },\n         }\n     }\n \n     false\n }\n \n-enum ReducedTys<'tcx> {\n-    FromFatPtr { unsized_ty: Ty<'tcx>, to_ty: Ty<'tcx> },\n-    ToFatPtr { unsized_ty: Ty<'tcx>, from_ty: Ty<'tcx> },\n-    ToPtr { from_ty: Ty<'tcx>, to_ty: Ty<'tcx> },\n-    FromPtr { from_ty: Ty<'tcx>, to_ty: Ty<'tcx> },\n-    Other { from_ty: Ty<'tcx>, to_ty: Ty<'tcx> },\n+#[expect(clippy::struct_excessive_bools)]\n+struct ReducedTys<'tcx> {\n+    from_ty: Ty<'tcx>,\n+    to_ty: Ty<'tcx>,\n+    from_raw_ptr: bool,\n+    to_raw_ptr: bool,\n+    from_fat_ptr: bool,\n+    to_fat_ptr: bool,\n }\n \n /// Remove references so long as both types are references.\n-fn reduce_refs<'tcx>(\n-    cx: &LateContext<'tcx>,\n-    span: Span,\n-    mut from_ty: Ty<'tcx>,\n-    mut to_ty: Ty<'tcx>,\n-) -> ReducedTys<'tcx> {\n-    loop {\n-        return match (from_ty.kind(), to_ty.kind()) {\n+fn reduce_refs<'tcx>(cx: &LateContext<'tcx>, mut from_ty: Ty<'tcx>, mut to_ty: Ty<'tcx>) -> ReducedTys<'tcx> {\n+    let mut from_raw_ptr = false;\n+    let mut to_raw_ptr = false;\n+    let (from_fat_ptr, to_fat_ptr) = loop {\n+        break match (from_ty.kind(), to_ty.kind()) {\n             (\n                 &(ty::Ref(_, from_sub_ty, _) | ty::RawPtr(TypeAndMut { ty: from_sub_ty, .. })),\n                 &(ty::Ref(_, to_sub_ty, _) | ty::RawPtr(TypeAndMut { ty: to_sub_ty, .. })),\n             ) => {\n+                from_raw_ptr = matches!(*from_ty.kind(), ty::RawPtr(_));\n                 from_ty = from_sub_ty;\n+                to_raw_ptr = matches!(*to_ty.kind(), ty::RawPtr(_));\n                 to_ty = to_sub_ty;\n                 continue;\n             },\n             (&(ty::Ref(_, unsized_ty, _) | ty::RawPtr(TypeAndMut { ty: unsized_ty, .. })), _)\n-                if !unsized_ty.is_sized(cx.tcx.at(span), cx.param_env) =>\n+                if !unsized_ty.is_sized(cx.tcx.at(DUMMY_SP), cx.param_env) =>\n             {\n-                ReducedTys::FromFatPtr { unsized_ty, to_ty }\n+                (true, false)\n             },\n             (_, &(ty::Ref(_, unsized_ty, _) | ty::RawPtr(TypeAndMut { ty: unsized_ty, .. })))\n-                if !unsized_ty.is_sized(cx.tcx.at(span), cx.param_env) =>\n+                if !unsized_ty.is_sized(cx.tcx.at(DUMMY_SP), cx.param_env) =>\n             {\n-                ReducedTys::ToFatPtr { unsized_ty, from_ty }\n+                (false, true)\n             },\n-            (&(ty::Ref(_, from_ty, _) | ty::RawPtr(TypeAndMut { ty: from_ty, .. })), _) => {\n-                ReducedTys::FromPtr { from_ty, to_ty }\n-            },\n-            (_, &(ty::Ref(_, to_ty, _) | ty::RawPtr(TypeAndMut { ty: to_ty, .. }))) => {\n-                ReducedTys::ToPtr { from_ty, to_ty }\n-            },\n-            _ => ReducedTys::Other { from_ty, to_ty },\n+            _ => (false, false),\n         };\n+    };\n+    ReducedTys {\n+        from_ty,\n+        to_ty,\n+        from_raw_ptr,\n+        to_raw_ptr,\n+        from_fat_ptr,\n+        to_fat_ptr,\n     }\n }\n \n enum ReducedTy<'tcx> {\n     /// The type can be used for type erasure.\n-    TypeErasure,\n+    TypeErasure { raw_ptr_only: bool },\n     /// The type is a struct containing either zero non-zero sized fields, or multiple non-zero\n     /// sized fields with a defined order.\n-    OrderedFields(Ty<'tcx>),\n+    /// The second value is the first non-zero sized type.\n+    OrderedFields(Ty<'tcx>, Option<Ty<'tcx>>),\n     /// The type is a struct containing multiple non-zero sized fields with no defined order.\n     UnorderedFields(Ty<'tcx>),\n-    /// The type is a reference to the contained type.\n-    Ref(Ty<'tcx>),\n-    /// The type is a generic parameter.\n-    Param,\n     /// Any other type.\n     Other(Ty<'tcx>),\n }\n@@ -285,16 +251,18 @@ fn reduce_ty<'tcx>(cx: &LateContext<'tcx>, mut ty: Ty<'tcx>) -> ReducedTy<'tcx>\n     loop {\n         ty = cx.tcx.try_normalize_erasing_regions(cx.param_env, ty).unwrap_or(ty);\n         return match *ty.kind() {\n-            ty::Array(sub_ty, _) if matches!(sub_ty.kind(), ty::Int(_) | ty::Uint(_)) => ReducedTy::TypeErasure,\n+            ty::Array(sub_ty, _) if matches!(sub_ty.kind(), ty::Int(_) | ty::Uint(_)) => {\n+                ReducedTy::TypeErasure { raw_ptr_only: false }\n+            },\n             ty::Array(sub_ty, _) | ty::Slice(sub_ty) => {\n                 ty = sub_ty;\n                 continue;\n             },\n-            ty::Tuple(args) if args.is_empty() => ReducedTy::TypeErasure,\n+            ty::Tuple(args) if args.is_empty() => ReducedTy::TypeErasure { raw_ptr_only: false },\n             ty::Tuple(args) => {\n                 let mut iter = args.iter();\n                 let Some(sized_ty) = iter.find(|&ty| !is_zero_sized_ty(cx, ty)) else {\n-                    return ReducedTy::OrderedFields(ty);\n+                    return ReducedTy::OrderedFields(ty, None);\n                 };\n                 if iter.all(|ty| is_zero_sized_ty(cx, ty)) {\n                     ty = sized_ty;\n@@ -309,27 +277,25 @@ fn reduce_ty<'tcx>(cx: &LateContext<'tcx>, mut ty: Ty<'tcx>) -> ReducedTy<'tcx>\n                     .iter()\n                     .map(|f| cx.tcx.bound_type_of(f.did).subst(cx.tcx, substs));\n                 let Some(sized_ty) = iter.find(|&ty| !is_zero_sized_ty(cx, ty)) else {\n-                    return ReducedTy::TypeErasure;\n+                    return ReducedTy::TypeErasure { raw_ptr_only: false };\n                 };\n                 if iter.all(|ty| is_zero_sized_ty(cx, ty)) {\n                     ty = sized_ty;\n                     continue;\n                 }\n                 if def.repr().inhibit_struct_field_reordering_opt() {\n-                    ReducedTy::OrderedFields(ty)\n+                    ReducedTy::OrderedFields(ty, Some(sized_ty))\n                 } else {\n                     ReducedTy::UnorderedFields(ty)\n                 }\n             },\n             ty::Adt(def, _) if def.is_enum() && (def.variants().is_empty() || is_c_void(cx, ty)) => {\n-                ReducedTy::TypeErasure\n+                ReducedTy::TypeErasure { raw_ptr_only: false }\n             },\n             // TODO: Check if the conversion to or from at least one of a union's fields is valid.\n-            ty::Adt(def, _) if def.is_union() => ReducedTy::TypeErasure,\n-            ty::Foreign(_) => ReducedTy::TypeErasure,\n-            ty::Ref(_, ty, _) => ReducedTy::Ref(ty),\n-            ty::RawPtr(ty) => ReducedTy::Ref(ty.ty),\n-            ty::Param(_) => ReducedTy::Param,\n+            ty::Adt(def, _) if def.is_union() => ReducedTy::TypeErasure { raw_ptr_only: false },\n+            ty::Foreign(_) | ty::Param(_) => ReducedTy::TypeErasure { raw_ptr_only: false },\n+            ty::Int(_) | ty::Uint(_) => ReducedTy::TypeErasure { raw_ptr_only: true },\n             _ => ReducedTy::Other(ty),\n         };\n     }"}, {"sha": "5aad0b44270a3cc5b9e72a5dd1405e9d52fee5e7", "filename": "tests/ui/transmute_undefined_repr.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/84fb7e039565ac87f504af235940a568b90e7223/tests%2Fui%2Ftransmute_undefined_repr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/84fb7e039565ac87f504af235940a568b90e7223/tests%2Fui%2Ftransmute_undefined_repr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftransmute_undefined_repr.rs?ref=84fb7e039565ac87f504af235940a568b90e7223", "patch": "@@ -4,6 +4,7 @@\n use core::any::TypeId;\n use core::ffi::c_void;\n use core::mem::{size_of, transmute, MaybeUninit};\n+use core::ptr::NonNull;\n \n fn value<T>() -> T {\n     unimplemented!()\n@@ -109,6 +110,17 @@ fn main() {\n         let _: Ty2<u32, u32> = transmute(value::<MaybeUninit<Ty2<u32, u32>>>()); // Ok\n \n         let _: Ty<&[u32]> = transmute::<&[u32], _>(value::<&Vec<u32>>()); // Ok\n+\n+        let _: *const Ty2<u32, u32> = transmute(value::<*const Ty2C<Ty2<u32, u32>, u32>>()); // Ok\n+        let _: *const Ty2C<Ty2<u32, u32>, u32> = transmute(value::<*const Ty2<u32, u32>>()); // Ok\n+        let _: *const Ty2<u32, u32> = transmute(value::<*const Ty2C<(), Ty2<u32, u32>>>()); // Ok\n+        let _: *const Ty2C<(), Ty2<u32, u32>> = transmute(value::<*const Ty2<u32, u32>>()); // Ok\n+\n+        let _: *const Ty2<u32, u32> = transmute(value::<*const Ty2C<u32, Ty2<u32, u32>>>()); // Err\n+        let _: *const Ty2C<u32, Ty2<u32, u32>> = transmute(value::<*const Ty2<u32, u32>>()); // Err\n+\n+        let _: NonNull<u8> = transmute(value::<NonNull<(String, String)>>()); // Ok\n+        let _: NonNull<(String, String)> = transmute(value::<NonNull<u8>>()); // Ok\n     }\n }\n "}, {"sha": "e50a773290e17c60fe6a5bc839e0d009fe821650", "filename": "tests/ui/transmute_undefined_repr.stderr", "status": "modified", "additions": 27, "deletions": 11, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/84fb7e039565ac87f504af235940a568b90e7223/tests%2Fui%2Ftransmute_undefined_repr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/84fb7e039565ac87f504af235940a568b90e7223/tests%2Fui%2Ftransmute_undefined_repr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftransmute_undefined_repr.stderr?ref=84fb7e039565ac87f504af235940a568b90e7223", "patch": "@@ -1,80 +1,96 @@\n error: transmute from `Ty2<u32, i32>` which has an undefined layout\n-  --> $DIR/transmute_undefined_repr.rs:27:33\n+  --> $DIR/transmute_undefined_repr.rs:28:33\n    |\n LL |         let _: Ty2C<u32, i32> = transmute(value::<Ty2<u32, i32>>()); // Lint, Ty2 is unordered\n    |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: `-D clippy::transmute-undefined-repr` implied by `-D warnings`\n \n error: transmute into `Ty2<u32, i32>` which has an undefined layout\n-  --> $DIR/transmute_undefined_repr.rs:28:32\n+  --> $DIR/transmute_undefined_repr.rs:29:32\n    |\n LL |         let _: Ty2<u32, i32> = transmute(value::<Ty2C<u32, i32>>()); // Lint, Ty2 is unordered\n    |                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: transmute from `Ty<Ty2<u32, i32>>` to `Ty2<u32, f32>`, both of which have an undefined layout\n-  --> $DIR/transmute_undefined_repr.rs:33:32\n+  --> $DIR/transmute_undefined_repr.rs:34:32\n    |\n LL |         let _: Ty2<u32, f32> = transmute(value::<Ty<Ty2<u32, i32>>>()); // Lint, different Ty2 instances\n    |                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: two instances of the same generic type (`Ty2`) may have different layouts\n \n error: transmute from `Ty2<u32, f32>` to `Ty<Ty2<u32, i32>>`, both of which have an undefined layout\n-  --> $DIR/transmute_undefined_repr.rs:34:36\n+  --> $DIR/transmute_undefined_repr.rs:35:36\n    |\n LL |         let _: Ty<Ty2<u32, i32>> = transmute(value::<Ty2<u32, f32>>()); // Lint, different Ty2 instances\n    |                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: two instances of the same generic type (`Ty2`) may have different layouts\n \n error: transmute from `Ty<&Ty2<u32, i32>>` to `&Ty2<u32, f32>`, both of which have an undefined layout\n-  --> $DIR/transmute_undefined_repr.rs:39:33\n+  --> $DIR/transmute_undefined_repr.rs:40:33\n    |\n LL |         let _: &Ty2<u32, f32> = transmute(value::<Ty<&Ty2<u32, i32>>>()); // Lint, different Ty2 instances\n    |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: two instances of the same generic type (`Ty2`) may have different layouts\n \n error: transmute from `&Ty2<u32, f32>` to `Ty<&Ty2<u32, i32>>`, both of which have an undefined layout\n-  --> $DIR/transmute_undefined_repr.rs:40:37\n+  --> $DIR/transmute_undefined_repr.rs:41:37\n    |\n LL |         let _: Ty<&Ty2<u32, i32>> = transmute(value::<&Ty2<u32, f32>>()); // Lint, different Ty2 instances\n    |                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: two instances of the same generic type (`Ty2`) may have different layouts\n \n error: transmute from `std::boxed::Box<Ty2<u32, u32>>` to `&mut Ty2<u32, f32>`, both of which have an undefined layout\n-  --> $DIR/transmute_undefined_repr.rs:57:45\n+  --> $DIR/transmute_undefined_repr.rs:58:45\n    |\n LL |         let _: &'static mut Ty2<u32, f32> = transmute(value::<Box<Ty2<u32, u32>>>()); // Lint, different Ty2 instances\n    |                                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: two instances of the same generic type (`Ty2`) may have different layouts\n \n error: transmute from `&mut Ty2<u32, f32>` to `std::boxed::Box<Ty2<u32, u32>>`, both of which have an undefined layout\n-  --> $DIR/transmute_undefined_repr.rs:58:37\n+  --> $DIR/transmute_undefined_repr.rs:59:37\n    |\n LL |         let _: Box<Ty2<u32, u32>> = transmute(value::<&'static mut Ty2<u32, f32>>()); // Lint, different Ty2 instances\n    |                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: two instances of the same generic type (`Ty2`) may have different layouts\n \n+error: transmute into `*const Ty2<u32, u32>` which has an undefined layout\n+  --> $DIR/transmute_undefined_repr.rs:119:39\n+   |\n+LL |         let _: *const Ty2<u32, u32> = transmute(value::<*const Ty2C<u32, Ty2<u32, u32>>>()); // Err\n+   |                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: the contained type `Ty2<u32, u32>` has an undefined layout\n+\n+error: transmute from `*const Ty2<u32, u32>` which has an undefined layout\n+  --> $DIR/transmute_undefined_repr.rs:120:50\n+   |\n+LL |         let _: *const Ty2C<u32, Ty2<u32, u32>> = transmute(value::<*const Ty2<u32, u32>>()); // Err\n+   |                                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: the contained type `Ty2<u32, u32>` has an undefined layout\n+\n error: transmute from `std::vec::Vec<Ty2<U, i32>>` to `std::vec::Vec<Ty2<T, u32>>`, both of which have an undefined layout\n-  --> $DIR/transmute_undefined_repr.rs:138:35\n+  --> $DIR/transmute_undefined_repr.rs:150:35\n    |\n LL |         let _: Vec<Ty2<T, u32>> = transmute(value::<Vec<Ty2<U, i32>>>()); // Err\n    |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: two instances of the same generic type (`Vec`) may have different layouts\n \n error: transmute from `std::vec::Vec<Ty2<T, u32>>` to `std::vec::Vec<Ty2<U, i32>>`, both of which have an undefined layout\n-  --> $DIR/transmute_undefined_repr.rs:139:35\n+  --> $DIR/transmute_undefined_repr.rs:151:35\n    |\n LL |         let _: Vec<Ty2<U, i32>> = transmute(value::<Vec<Ty2<T, u32>>>()); // Err\n    |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: two instances of the same generic type (`Vec`) may have different layouts\n \n-error: aborting due to 10 previous errors\n+error: aborting due to 12 previous errors\n "}]}