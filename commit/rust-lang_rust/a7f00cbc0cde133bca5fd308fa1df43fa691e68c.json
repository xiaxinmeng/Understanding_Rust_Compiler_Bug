{"sha": "a7f00cbc0cde133bca5fd308fa1df43fa691e68c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE3ZjAwY2JjMGNkZTEzM2JjYTVmZDMwOGZhMWRmNDNmYTY5MWU2OGM=", "commit": {"author": {"name": "Jordan Woehr", "email": "jordanwoehr@gmail.com", "date": "2015-03-18T05:23:13Z"}, "committer": {"name": "Jordan Woehr", "email": "jordanwoehr@gmail.com", "date": "2015-03-18T05:23:13Z"}, "message": "Fix a bug in inline assembly codegen where host clobbers were always used regardless of target", "tree": {"sha": "8a57aae4904cf99bfe89c4bbfa87b7a765b72359", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8a57aae4904cf99bfe89c4bbfa87b7a765b72359"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a7f00cbc0cde133bca5fd308fa1df43fa691e68c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a7f00cbc0cde133bca5fd308fa1df43fa691e68c", "html_url": "https://github.com/rust-lang/rust/commit/a7f00cbc0cde133bca5fd308fa1df43fa691e68c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a7f00cbc0cde133bca5fd308fa1df43fa691e68c/comments", "author": {"login": "woehr", "id": 468371, "node_id": "MDQ6VXNlcjQ2ODM3MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/468371?v=4", "gravatar_id": "", "url": "https://api.github.com/users/woehr", "html_url": "https://github.com/woehr", "followers_url": "https://api.github.com/users/woehr/followers", "following_url": "https://api.github.com/users/woehr/following{/other_user}", "gists_url": "https://api.github.com/users/woehr/gists{/gist_id}", "starred_url": "https://api.github.com/users/woehr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/woehr/subscriptions", "organizations_url": "https://api.github.com/users/woehr/orgs", "repos_url": "https://api.github.com/users/woehr/repos", "events_url": "https://api.github.com/users/woehr/events{/privacy}", "received_events_url": "https://api.github.com/users/woehr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "woehr", "id": 468371, "node_id": "MDQ6VXNlcjQ2ODM3MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/468371?v=4", "gravatar_id": "", "url": "https://api.github.com/users/woehr", "html_url": "https://github.com/woehr", "followers_url": "https://api.github.com/users/woehr/followers", "following_url": "https://api.github.com/users/woehr/following{/other_user}", "gists_url": "https://api.github.com/users/woehr/gists{/gist_id}", "starred_url": "https://api.github.com/users/woehr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/woehr/subscriptions", "organizations_url": "https://api.github.com/users/woehr/orgs", "repos_url": "https://api.github.com/users/woehr/repos", "events_url": "https://api.github.com/users/woehr/events{/privacy}", "received_events_url": "https://api.github.com/users/woehr/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "883551b1d739993dffcba01ee9ea3237cf406d9a", "url": "https://api.github.com/repos/rust-lang/rust/commits/883551b1d739993dffcba01ee9ea3237cf406d9a", "html_url": "https://github.com/rust-lang/rust/commit/883551b1d739993dffcba01ee9ea3237cf406d9a"}], "stats": {"total": 73, "additions": 26, "deletions": 47}, "files": [{"sha": "df0d212f9e26c27e53fe2c612b96af9555e89be2", "filename": "src/librustc_trans/trans/asm.rs", "status": "modified", "additions": 26, "deletions": 47, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/a7f00cbc0cde133bca5fd308fa1df43fa691e68c/src%2Flibrustc_trans%2Ftrans%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7f00cbc0cde133bca5fd308fa1df43fa691e68c/src%2Flibrustc_trans%2Ftrans%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fasm.rs?ref=a7f00cbc0cde133bca5fd308fa1df43fa691e68c", "patch": "@@ -76,43 +76,34 @@ pub fn trans_inline_asm<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, ia: &ast::InlineAsm)\n     // no failure occurred preparing operands, no need to cleanup\n     fcx.pop_custom_cleanup_scope(temp_scope);\n \n-    let mut constraints = constraints.iter()\n-                                     .map(|s| s.to_string())\n-                                     .chain(ext_constraints.into_iter())\n-                                     .collect::<Vec<String>>()\n-                                     .connect(\",\");\n-\n-    let mut clobbers = ia.clobbers.iter()\n-                                  .map(|s| format!(\"~{{{}}}\", &s))\n-                                  .collect::<Vec<String>>()\n-                                  .connect(\",\");\n-    let more_clobbers = get_clobbers();\n-    if !more_clobbers.is_empty() {\n-        if !clobbers.is_empty() {\n-            clobbers.push(',');\n-        }\n-        clobbers.push_str(&more_clobbers[..]);\n-    }\n-\n-    // Add the clobbers to our constraints list\n-    if clobbers.len() != 0 && constraints.len() != 0 {\n-        constraints.push(',');\n-        constraints.push_str(&clobbers[..]);\n-    } else {\n-        constraints.push_str(&clobbers[..]);\n-    }\n+    let clobbers = ia.clobbers.iter()\n+                              .map(|s| format!(\"~{{{}}}\", &s))\n+                              .collect::<Vec<String>>();\n+\n+    // Default per-arch clobbers\n+    // Basically what clang does\n+    let arch_clobbers = match bcx.sess().target.target.arch.as_slice() {\n+        \"x86\" | \"x86_64\" => vec!(\"~{dirflag}\", \"~{fpsr}\", \"~{flags}\"),\n+        _                => Vec::new()\n+    };\n \n-    debug!(\"Asm Constraints: {}\", &constraints[..]);\n+    let all_constraints= constraints.iter()\n+                                    .map(|s| s.to_string())\n+                                    .chain(ext_constraints.into_iter())\n+                                    .chain(clobbers.into_iter())\n+                                    .chain(arch_clobbers.into_iter()\n+                                               .map(|s| s.to_string()))\n+                                    .collect::<Vec<String>>()\n+                                    .connect(\",\");\n \n-    let num_outputs = outputs.len();\n+    debug!(\"Asm Constraints: {}\", &all_constraints[..]);\n \n     // Depending on how many outputs we have, the return type is different\n-    let output_type = if num_outputs == 0 {\n-        Type::void(bcx.ccx())\n-    } else if num_outputs == 1 {\n-        output_types[0]\n-    } else {\n-        Type::struct_(bcx.ccx(), &output_types[..], false)\n+    let num_outputs = outputs.len();\n+    let output_type = match num_outputs {\n+        0 => Type::void(bcx.ccx()),\n+        1 => output_types[0],\n+        _ => Type::struct_(bcx.ccx(), &output_types[..], false)\n     };\n \n     let dialect = match ia.dialect {\n@@ -121,10 +112,10 @@ pub fn trans_inline_asm<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, ia: &ast::InlineAsm)\n     };\n \n     let asm = CString::new(ia.asm.as_bytes()).unwrap();\n-    let constraints = CString::new(constraints).unwrap();\n+    let constraint_cstr = CString::new(all_constraints).unwrap();\n     let r = InlineAsmCall(bcx,\n                           asm.as_ptr(),\n-                          constraints.as_ptr(),\n+                          constraint_cstr.as_ptr(),\n                           &inputs,\n                           output_type,\n                           ia.volatile,\n@@ -158,15 +149,3 @@ pub fn trans_inline_asm<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, ia: &ast::InlineAsm)\n \n }\n \n-// Default per-arch clobbers\n-// Basically what clang does\n-\n-#[cfg(not(any(target_arch = \"x86\", target_arch = \"x86_64\")))]\n-fn get_clobbers() -> String {\n-    \"\".to_string()\n-}\n-\n-#[cfg(any(target_arch = \"x86\", target_arch = \"x86_64\"))]\n-fn get_clobbers() -> String {\n-    \"~{dirflag},~{fpsr},~{flags}\".to_string()\n-}"}]}