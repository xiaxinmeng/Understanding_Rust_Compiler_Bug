{"sha": "c88f337fc9b086b7a5553db0660148311cd8421f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM4OGYzMzdmYzliMDg2YjdhNTU1M2RiMDY2MDE0ODMxMWNkODQyMWY=", "commit": {"author": {"name": "John Clements", "email": "clements@racket-lang.org", "date": "2013-05-17T18:11:24Z"}, "committer": {"name": "John Clements", "email": "clements@racket-lang.org", "date": "2013-06-05T19:01:39Z"}, "message": "remove unused cx's", "tree": {"sha": "82185dd8f3a92af5203d7329904fc0cfde95b1ec", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/82185dd8f3a92af5203d7329904fc0cfde95b1ec"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c88f337fc9b086b7a5553db0660148311cd8421f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c88f337fc9b086b7a5553db0660148311cd8421f", "html_url": "https://github.com/rust-lang/rust/commit/c88f337fc9b086b7a5553db0660148311cd8421f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c88f337fc9b086b7a5553db0660148311cd8421f/comments", "author": {"login": "jbclements", "id": 226617, "node_id": "MDQ6VXNlcjIyNjYxNw==", "avatar_url": "https://avatars.githubusercontent.com/u/226617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jbclements", "html_url": "https://github.com/jbclements", "followers_url": "https://api.github.com/users/jbclements/followers", "following_url": "https://api.github.com/users/jbclements/following{/other_user}", "gists_url": "https://api.github.com/users/jbclements/gists{/gist_id}", "starred_url": "https://api.github.com/users/jbclements/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jbclements/subscriptions", "organizations_url": "https://api.github.com/users/jbclements/orgs", "repos_url": "https://api.github.com/users/jbclements/repos", "events_url": "https://api.github.com/users/jbclements/events{/privacy}", "received_events_url": "https://api.github.com/users/jbclements/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jbclements", "id": 226617, "node_id": "MDQ6VXNlcjIyNjYxNw==", "avatar_url": "https://avatars.githubusercontent.com/u/226617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jbclements", "html_url": "https://github.com/jbclements", "followers_url": "https://api.github.com/users/jbclements/followers", "following_url": "https://api.github.com/users/jbclements/following{/other_user}", "gists_url": "https://api.github.com/users/jbclements/gists{/gist_id}", "starred_url": "https://api.github.com/users/jbclements/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jbclements/subscriptions", "organizations_url": "https://api.github.com/users/jbclements/orgs", "repos_url": "https://api.github.com/users/jbclements/repos", "events_url": "https://api.github.com/users/jbclements/events{/privacy}", "received_events_url": "https://api.github.com/users/jbclements/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "04a691a511d0203b1f521960f845e623cc45d261", "url": "https://api.github.com/repos/rust-lang/rust/commits/04a691a511d0203b1f521960f845e623cc45d261", "html_url": "https://github.com/rust-lang/rust/commit/04a691a511d0203b1f521960f845e623cc45d261"}], "stats": {"total": 192, "additions": 96, "deletions": 96}, "files": [{"sha": "e51ce5e4676af14407b0aeb3a9cd96a22a36b346", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c88f337fc9b086b7a5553db0660148311cd8421f/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c88f337fc9b086b7a5553db0660148311cd8421f/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=c88f337fc9b086b7a5553db0660148311cd8421f", "patch": "@@ -738,7 +738,7 @@ mod test {\n     use parse::token::{gensym, get_ident_interner};\n     use core::io;\n     use core::option::{None, Some};\n-    use util::parser_testing::{string_to_item_and_sess};\n+    use util::parser_testing::{string_to_item, string_to_pat, strs_to_idents};\n \n     // make sure that fail! is present\n     #[test] fn fail_exists_test () {\n@@ -842,7 +842,7 @@ mod test {\n \n     #[test]\n     fn renaming () {\n-        let (maybe_item_ast,sess) = string_to_item_and_sess(@~\"fn a() -> int { let b = 13; b} \");\n+        let maybe_item_ast = string_to_item(@~\"fn a() -> int { let b = 13; b} \");\n         let item_ast = match maybe_item_ast {\n             Some(x) => x,\n             None => fail!(\"test case fail\")"}, {"sha": "1e5b3c3ee7eb4f8dedb15bbe7047d1201c7ef972", "filename": "src/libsyntax/ext/pipes/pipec.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c88f337fc9b086b7a5553db0660148311cd8421f/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c88f337fc9b086b7a5553db0660148311cd8421f/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs?ref=c88f337fc9b086b7a5553db0660148311cd8421f", "patch": "@@ -325,10 +325,10 @@ impl gen_init for protocol {\n \n         cx.parse_item(fmt!(\"pub fn init%s() -> (server::%s, client::%s)\\\n                             { pub use std::pipes::HasBuffer; %s }\",\n-                           start_state.generics.to_source(cx),\n-                           start_state.to_ty(cx).to_source(cx),\n-                           start_state.to_ty(cx).to_source(cx),\n-                           body.to_source(cx)))\n+                           start_state.generics.to_source(),\n+                           start_state.to_ty(cx).to_source(),\n+                           start_state.to_ty(cx).to_source(),\n+                           body.to_source()))\n     }\n \n     fn gen_buffer_init(&self, ext_cx: @ExtCtxt) -> @ast::expr {"}, {"sha": "062532afef8d63ad69f7b361201a0979bc40ae88", "filename": "src/libsyntax/ext/quote.rs", "status": "modified", "additions": 90, "deletions": 90, "changes": 180, "blob_url": "https://github.com/rust-lang/rust/blob/c88f337fc9b086b7a5553db0660148311cd8421f/src%2Flibsyntax%2Fext%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c88f337fc9b086b7a5553db0660148311cd8421f/src%2Flibsyntax%2Fext%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fquote.rs?ref=c88f337fc9b086b7a5553db0660148311cd8421f", "patch": "@@ -63,142 +63,142 @@ pub mod rt {\n \n     trait ToSource : ToTokens {\n         // Takes a thing and generates a string containing rust code for it.\n-        pub fn to_source(cx: @ExtCtxt) -> ~str;\n+        pub fn to_source() -> ~str;\n \n         // If you can make source, you can definitely make tokens.\n         pub fn to_tokens(cx: @ExtCtxt) -> ~[token_tree] {\n-            cx.parse_tts(self.to_source(cx))\n+            cx.parse_tts(self.to_source())\n         }\n     }\n \n     */\n \n     pub trait ToSource {\n         // Takes a thing and generates a string containing rust code for it.\n-        pub fn to_source(&self, cx: @ExtCtxt) -> ~str;\n+        pub fn to_source(&self) -> ~str;\n     }\n \n     impl ToSource for ast::ident {\n-        fn to_source(&self, cx: @ExtCtxt) -> ~str {\n+        fn to_source(&self) -> ~str {\n             copy *ident_to_str(self)\n         }\n     }\n \n     impl ToSource for @ast::item {\n-        fn to_source(&self, cx: @ExtCtxt) -> ~str {\n+        fn to_source(&self) -> ~str {\n             item_to_str(*self, get_ident_interner())\n         }\n     }\n \n     impl<'self> ToSource for &'self [@ast::item] {\n-        fn to_source(&self, cx: @ExtCtxt) -> ~str {\n-            str::connect(self.map(|i| i.to_source(cx)), \"\\n\\n\")\n+        fn to_source(&self) -> ~str {\n+            str::connect(self.map(|i| i.to_source()), ~\"\\n\\n\")\n         }\n     }\n \n     impl ToSource for @ast::Ty {\n-        fn to_source(&self, cx: @ExtCtxt) -> ~str {\n+        fn to_source(&self) -> ~str {\n             ty_to_str(*self, get_ident_interner())\n         }\n     }\n \n     impl<'self> ToSource for &'self [@ast::Ty] {\n-        fn to_source(&self, cx: @ExtCtxt) -> ~str {\n-            str::connect(self.map(|i| i.to_source(cx)), \", \")\n+        fn to_source(&self) -> ~str {\n+            str::connect(self.map(|i| i.to_source()), ~\", \")\n         }\n     }\n \n     impl ToSource for Generics {\n-        fn to_source(&self, cx: @ExtCtxt) -> ~str {\n+        fn to_source(&self) -> ~str {\n             pprust::generics_to_str(self, get_ident_interner())\n         }\n     }\n \n     impl ToSource for @ast::expr {\n-        fn to_source(&self, cx: @ExtCtxt) -> ~str {\n+        fn to_source(&self) -> ~str {\n             pprust::expr_to_str(*self, get_ident_interner())\n         }\n     }\n \n     impl ToSource for ast::blk {\n-        fn to_source(&self, cx: @ExtCtxt) -> ~str {\n+        fn to_source(&self) -> ~str {\n             pprust::block_to_str(self, get_ident_interner())\n         }\n     }\n \n     impl<'self> ToSource for &'self str {\n-        fn to_source(&self, _cx: @ExtCtxt) -> ~str {\n+        fn to_source(&self) -> ~str {\n             let lit = dummy_spanned(ast::lit_str(@str::to_owned(*self)));\n             pprust::lit_to_str(@lit)\n         }\n     }\n \n     impl ToSource for int {\n-        fn to_source(&self, _cx: @ExtCtxt) -> ~str {\n+        fn to_source(&self) -> ~str {\n             let lit = dummy_spanned(ast::lit_int(*self as i64, ast::ty_i));\n             pprust::lit_to_str(@lit)\n         }\n     }\n \n     impl ToSource for i8 {\n-        fn to_source(&self, _cx: @ExtCtxt) -> ~str {\n+        fn to_source(&self) -> ~str {\n             let lit = dummy_spanned(ast::lit_int(*self as i64, ast::ty_i8));\n             pprust::lit_to_str(@lit)\n         }\n     }\n \n     impl ToSource for i16 {\n-        fn to_source(&self, _cx: @ExtCtxt) -> ~str {\n+        fn to_source(&self) -> ~str {\n             let lit = dummy_spanned(ast::lit_int(*self as i64, ast::ty_i16));\n             pprust::lit_to_str(@lit)\n         }\n     }\n \n \n     impl ToSource for i32 {\n-        fn to_source(&self, _cx: @ExtCtxt) -> ~str {\n+        fn to_source(&self) -> ~str {\n             let lit = dummy_spanned(ast::lit_int(*self as i64, ast::ty_i32));\n             pprust::lit_to_str(@lit)\n         }\n     }\n \n     impl ToSource for i64 {\n-        fn to_source(&self, _cx: @ExtCtxt) -> ~str {\n+        fn to_source(&self) -> ~str {\n             let lit = dummy_spanned(ast::lit_int(*self as i64, ast::ty_i64));\n             pprust::lit_to_str(@lit)\n         }\n     }\n \n     impl ToSource for uint {\n-        fn to_source(&self, _cx: @ExtCtxt) -> ~str {\n+        fn to_source(&self) -> ~str {\n             let lit = dummy_spanned(ast::lit_uint(*self as u64, ast::ty_u));\n             pprust::lit_to_str(@lit)\n         }\n     }\n \n     impl ToSource for u8 {\n-        fn to_source(&self, _cx: @ExtCtxt) -> ~str {\n+        fn to_source(&self) -> ~str {\n             let lit = dummy_spanned(ast::lit_uint(*self as u64, ast::ty_u8));\n             pprust::lit_to_str(@lit)\n         }\n     }\n \n     impl ToSource for u16 {\n-        fn to_source(&self, _cx: @ExtCtxt) -> ~str {\n+        fn to_source(&self) -> ~str {\n             let lit = dummy_spanned(ast::lit_uint(*self as u64, ast::ty_u16));\n             pprust::lit_to_str(@lit)\n         }\n     }\n \n     impl ToSource for u32 {\n-        fn to_source(&self, _cx: @ExtCtxt) -> ~str {\n+        fn to_source(&self) -> ~str {\n             let lit = dummy_spanned(ast::lit_uint(*self as u64, ast::ty_u32));\n             pprust::lit_to_str(@lit)\n         }\n     }\n \n     impl ToSource for u64 {\n-        fn to_source(&self, _cx: @ExtCtxt) -> ~str {\n+        fn to_source(&self) -> ~str {\n             let lit = dummy_spanned(ast::lit_uint(*self as u64, ast::ty_u64));\n             pprust::lit_to_str(@lit)\n         }\n@@ -208,115 +208,115 @@ pub mod rt {\n \n     impl ToTokens for ast::ident {\n         fn to_tokens(&self, cx: @ExtCtxt) -> ~[token_tree] {\n-            cx.parse_tts(self.to_source(cx))\n+            cx.parse_tts(self.to_source())\n         }\n     }\n \n     impl ToTokens for @ast::item {\n         fn to_tokens(&self, cx: @ExtCtxt) -> ~[token_tree] {\n-            cx.parse_tts(self.to_source(cx))\n+            cx.parse_tts(self.to_source())\n         }\n     }\n \n     impl<'self> ToTokens for &'self [@ast::item] {\n         fn to_tokens(&self, cx: @ExtCtxt) -> ~[token_tree] {\n-            cx.parse_tts(self.to_source(cx))\n+            cx.parse_tts(self.to_source())\n         }\n     }\n \n     impl ToTokens for @ast::Ty {\n         fn to_tokens(&self, cx: @ExtCtxt) -> ~[token_tree] {\n-            cx.parse_tts(self.to_source(cx))\n+            cx.parse_tts(self.to_source())\n         }\n     }\n \n     impl<'self> ToTokens for &'self [@ast::Ty] {\n         fn to_tokens(&self, cx: @ExtCtxt) -> ~[token_tree] {\n-            cx.parse_tts(self.to_source(cx))\n+            cx.parse_tts(self.to_source())\n         }\n     }\n \n     impl ToTokens for Generics {\n         fn to_tokens(&self, cx: @ExtCtxt) -> ~[token_tree] {\n-            cx.parse_tts(self.to_source(cx))\n+            cx.parse_tts(self.to_source())\n         }\n     }\n \n     impl ToTokens for @ast::expr {\n         fn to_tokens(&self, cx: @ExtCtxt) -> ~[token_tree] {\n-            cx.parse_tts(self.to_source(cx))\n+            cx.parse_tts(self.to_source())\n         }\n     }\n \n     impl ToTokens for ast::blk {\n         fn to_tokens(&self, cx: @ExtCtxt) -> ~[token_tree] {\n-            cx.parse_tts(self.to_source(cx))\n+            cx.parse_tts(self.to_source())\n         }\n     }\n \n     impl<'self> ToTokens for &'self str {\n         fn to_tokens(&self, cx: @ExtCtxt) -> ~[token_tree] {\n-            cx.parse_tts(self.to_source(cx))\n+            cx.parse_tts(self.to_source())\n         }\n     }\n \n     impl ToTokens for int {\n         fn to_tokens(&self, cx: @ExtCtxt) -> ~[token_tree] {\n-            cx.parse_tts(self.to_source(cx))\n+            cx.parse_tts(self.to_source())\n         }\n     }\n \n     impl ToTokens for i8 {\n         fn to_tokens(&self, cx: @ExtCtxt) -> ~[token_tree] {\n-            cx.parse_tts(self.to_source(cx))\n+            cx.parse_tts(self.to_source())\n         }\n     }\n \n     impl ToTokens for i16 {\n         fn to_tokens(&self, cx: @ExtCtxt) -> ~[token_tree] {\n-            cx.parse_tts(self.to_source(cx))\n+            cx.parse_tts(self.to_source())\n         }\n     }\n \n     impl ToTokens for i32 {\n         fn to_tokens(&self, cx: @ExtCtxt) -> ~[token_tree] {\n-            cx.parse_tts(self.to_source(cx))\n+            cx.parse_tts(self.to_source())\n         }\n     }\n \n     impl ToTokens for i64 {\n         fn to_tokens(&self, cx: @ExtCtxt) -> ~[token_tree] {\n-            cx.parse_tts(self.to_source(cx))\n+            cx.parse_tts(self.to_source())\n         }\n     }\n \n     impl ToTokens for uint {\n         fn to_tokens(&self, cx: @ExtCtxt) -> ~[token_tree] {\n-            cx.parse_tts(self.to_source(cx))\n+            cx.parse_tts(self.to_source())\n         }\n     }\n \n     impl ToTokens for u8 {\n         fn to_tokens(&self, cx: @ExtCtxt) -> ~[token_tree] {\n-            cx.parse_tts(self.to_source(cx))\n+            cx.parse_tts(self.to_source())\n         }\n     }\n \n     impl ToTokens for u16 {\n         fn to_tokens(&self, cx: @ExtCtxt) -> ~[token_tree] {\n-            cx.parse_tts(self.to_source(cx))\n+            cx.parse_tts(self.to_source())\n         }\n     }\n \n     impl ToTokens for u32 {\n         fn to_tokens(&self, cx: @ExtCtxt) -> ~[token_tree] {\n-            cx.parse_tts(self.to_source(cx))\n+            cx.parse_tts(self.to_source())\n         }\n     }\n \n     impl ToTokens for u64 {\n         fn to_tokens(&self, cx: @ExtCtxt) -> ~[token_tree] {\n-            cx.parse_tts(self.to_source(cx))\n+            cx.parse_tts(self.to_source())\n         }\n     }\n \n@@ -417,25 +417,25 @@ pub fn expand_quote_stmt(cx: @ExtCtxt,\n                                     ~[e_attrs], tts))\n }\n \n-fn ids_ext(cx: @ExtCtxt, strs: ~[~str]) -> ~[ast::ident] {\n+fn ids_ext(strs: ~[~str]) -> ~[ast::ident] {\n     strs.map(|str| str_to_ident(*str))\n }\n \n-fn id_ext(cx: @ExtCtxt, str: &str) -> ast::ident {\n+fn id_ext(str: &str) -> ast::ident {\n     str_to_ident(str)\n }\n \n // Lift an ident to the expr that evaluates to that ident.\n fn mk_ident(cx: @ExtCtxt, sp: span, ident: ast::ident) -> @ast::expr {\n     let e_str = cx.expr_str(sp, cx.str_of(ident));\n     cx.expr_method_call(sp,\n-                        cx.expr_ident(sp, id_ext(cx, \"ext_cx\")),\n-                        id_ext(cx, \"ident_of\"),\n+                        cx.expr_ident(sp, id_ext(\"ext_cx\")),\n+                        id_ext(\"ident_of\"),\n                         ~[e_str])\n }\n \n fn mk_bytepos(cx: @ExtCtxt, sp: span, bpos: BytePos) -> @ast::expr {\n-    let path = id_ext(cx, \"BytePos\");\n+    let path = id_ext(\"BytePos\");\n     let arg = cx.expr_uint(sp, bpos.to_uint());\n     cx.expr_call_ident(sp, path, ~[arg])\n }\n@@ -453,20 +453,20 @@ fn mk_binop(cx: @ExtCtxt, sp: span, bop: token::binop) -> @ast::expr {\n         SHL => \"SHL\",\n         SHR => \"SHR\"\n     };\n-    cx.expr_ident(sp, id_ext(cx, name))\n+    cx.expr_ident(sp, id_ext(name))\n }\n \n fn mk_token(cx: @ExtCtxt, sp: span, tok: &token::Token) -> @ast::expr {\n \n     match *tok {\n         BINOP(binop) => {\n             return cx.expr_call_ident(sp,\n-                                      id_ext(cx, \"BINOP\"),\n+                                      id_ext(\"BINOP\"),\n                                       ~[mk_binop(cx, sp, binop)]);\n         }\n         BINOPEQ(binop) => {\n             return cx.expr_call_ident(sp,\n-                                      id_ext(cx, \"BINOPEQ\"),\n+                                      id_ext(\"BINOPEQ\"),\n                                       ~[mk_binop(cx, sp, binop)]);\n         }\n \n@@ -479,12 +479,12 @@ fn mk_token(cx: @ExtCtxt, sp: span, tok: &token::Token) -> @ast::expr {\n                 ast::ty_i32 => ~\"ty_i32\",\n                 ast::ty_i64 => ~\"ty_i64\"\n             };\n-            let e_ity = cx.expr_ident(sp, id_ext(cx, s_ity));\n+            let e_ity = cx.expr_ident(sp, id_ext(s_ity));\n \n             let e_i64 = cx.expr_lit(sp, ast::lit_int(i, ast::ty_i64));\n \n             return cx.expr_call_ident(sp,\n-                                      id_ext(cx, \"LIT_INT\"),\n+                                      id_ext(\"LIT_INT\"),\n                                       ~[e_i64, e_ity]);\n         }\n \n@@ -496,20 +496,20 @@ fn mk_token(cx: @ExtCtxt, sp: span, tok: &token::Token) -> @ast::expr {\n                 ast::ty_u32 => ~\"ty_u32\",\n                 ast::ty_u64 => ~\"ty_u64\"\n             };\n-            let e_uty = cx.expr_ident(sp, id_ext(cx, s_uty));\n+            let e_uty = cx.expr_ident(sp, id_ext(s_uty));\n \n             let e_u64 = cx.expr_lit(sp, ast::lit_uint(u, ast::ty_u64));\n \n             return cx.expr_call_ident(sp,\n-                                      id_ext(cx, \"LIT_UINT\"),\n+                                      id_ext(\"LIT_UINT\"),\n                                       ~[e_u64, e_uty]);\n         }\n \n         LIT_INT_UNSUFFIXED(i) => {\n             let e_i64 = cx.expr_lit(sp, ast::lit_int(i, ast::ty_i64));\n \n             return cx.expr_call_ident(sp,\n-                                      id_ext(cx, \"LIT_INT_UNSUFFIXED\"),\n+                                      id_ext(\"LIT_INT_UNSUFFIXED\"),\n                                       ~[e_i64]);\n         }\n \n@@ -519,37 +519,37 @@ fn mk_token(cx: @ExtCtxt, sp: span, tok: &token::Token) -> @ast::expr {\n                 ast::ty_f32 => ~\"ty_f32\",\n                 ast::ty_f64 => ~\"ty_f64\"\n             };\n-            let e_fty = cx.expr_ident(sp, id_ext(cx, s_fty));\n+            let e_fty = cx.expr_ident(sp, id_ext(s_fty));\n \n             let e_fident = mk_ident(cx, sp, fident);\n \n             return cx.expr_call_ident(sp,\n-                                      id_ext(cx, \"LIT_FLOAT\"),\n+                                      id_ext(\"LIT_FLOAT\"),\n                                       ~[e_fident, e_fty]);\n         }\n \n         LIT_STR(ident) => {\n             return cx.expr_call_ident(sp,\n-                                      id_ext(cx, \"LIT_STR\"),\n+                                      id_ext(\"LIT_STR\"),\n                                       ~[mk_ident(cx, sp, ident)]);\n         }\n \n         IDENT(ident, b) => {\n             return cx.expr_call_ident(sp,\n-                                      id_ext(cx, \"IDENT\"),\n+                                      id_ext(\"IDENT\"),\n                                       ~[mk_ident(cx, sp, ident),\n                                         cx.expr_bool(sp, b)]);\n         }\n \n         LIFETIME(ident) => {\n             return cx.expr_call_ident(sp,\n-                                      id_ext(cx, \"LIFETIME\"),\n+                                      id_ext(\"LIFETIME\"),\n                                       ~[mk_ident(cx, sp, ident)]);\n         }\n \n         DOC_COMMENT(ident) => {\n             return cx.expr_call_ident(sp,\n-                                      id_ext(cx, \"DOC_COMMENT\"),\n+                                      id_ext(\"DOC_COMMENT\"),\n                                       ~[mk_ident(cx, sp, ident)]);\n         }\n \n@@ -593,7 +593,7 @@ fn mk_token(cx: @ExtCtxt, sp: span, tok: &token::Token) -> @ast::expr {\n         EOF => \"EOF\",\n         _ => fail!()\n     };\n-    cx.expr_ident(sp, id_ext(cx, name))\n+    cx.expr_ident(sp, id_ext(name))\n }\n \n \n@@ -603,14 +603,14 @@ fn mk_tt(cx: @ExtCtxt, sp: span, tt: &ast::token_tree)\n     match *tt {\n \n         ast::tt_tok(sp, ref tok) => {\n-            let e_sp = cx.expr_ident(sp, id_ext(cx, \"sp\"));\n+            let e_sp = cx.expr_ident(sp, id_ext(\"sp\"));\n             let e_tok = cx.expr_call_ident(sp,\n-                                           id_ext(cx, \"tt_tok\"),\n+                                           id_ext(\"tt_tok\"),\n                                            ~[e_sp, mk_token(cx, sp, tok)]);\n             let e_push =\n                 cx.expr_method_call(sp,\n-                                    cx.expr_ident(sp, id_ext(cx, \"tt\")),\n-                                    id_ext(cx, \"push\"),\n+                                    cx.expr_ident(sp, id_ext(\"tt\")),\n+                                    id_ext(\"push\"),\n                                     ~[e_tok]);\n             ~[cx.stmt_expr(e_push)]\n         }\n@@ -625,13 +625,13 @@ fn mk_tt(cx: @ExtCtxt, sp: span, tt: &ast::token_tree)\n             let e_to_toks =\n                 cx.expr_method_call(sp,\n                                     cx.expr_ident(sp, ident),\n-                                    id_ext(cx, \"to_tokens\"),\n-                                    ~[cx.expr_ident(sp, id_ext(cx, \"ext_cx\"))]);\n+                                    id_ext(\"to_tokens\"),\n+                                    ~[cx.expr_ident(sp, id_ext(\"ext_cx\"))]);\n \n             let e_push =\n                 cx.expr_method_call(sp,\n-                                    cx.expr_ident(sp, id_ext(cx, \"tt\")),\n-                                    id_ext(cx, \"push_all_move\"),\n+                                    cx.expr_ident(sp, id_ext(\"tt\")),\n+                                    id_ext(\"push_all_move\"),\n                                     ~[e_to_toks]);\n \n             ~[cx.stmt_expr(e_push)]\n@@ -671,10 +671,10 @@ fn expand_tts(cx: @ExtCtxt,\n     // import the runtime module, followed by a tt-building expression.\n \n     let uses = ~[ cx.view_use_glob(sp, ast::public,\n-                                   ids_ext(cx, ~[~\"syntax\",\n-                                                 ~\"ext\",\n-                                                 ~\"quote\",\n-                                                 ~\"rt\"])) ];\n+                                   ids_ext(~[~\"syntax\",\n+                                             ~\"ext\",\n+                                             ~\"quote\",\n+                                             ~\"rt\"])) ];\n \n     // We also bind a single value, sp, to ext_cx.call_site()\n     //\n@@ -703,23 +703,23 @@ fn expand_tts(cx: @ExtCtxt,\n     // worth the hassle.\n \n     let e_sp = cx.expr_method_call(sp,\n-                                   cx.expr_ident(sp, id_ext(cx, \"ext_cx\")),\n-                                   id_ext(cx, \"call_site\"),\n+                                   cx.expr_ident(sp, id_ext(\"ext_cx\")),\n+                                   id_ext(\"call_site\"),\n                                    ~[]);\n \n     let stmt_let_sp = cx.stmt_let(sp, false,\n-                                  id_ext(cx, \"sp\"),\n+                                  id_ext(\"sp\"),\n                                   e_sp);\n \n     let stmt_let_tt = cx.stmt_let(sp, true,\n-                                  id_ext(cx, \"tt\"),\n+                                  id_ext(\"tt\"),\n                                   cx.expr_vec_uniq(sp, ~[]));\n \n     cx.expr_blk(\n         cx.blk_all(sp, uses,\n                    ~[stmt_let_sp,\n                      stmt_let_tt] + mk_tts(cx, sp, tts),\n-                   Some(cx.expr_ident(sp, id_ext(cx, \"tt\")))))\n+                   Some(cx.expr_ident(sp, id_ext(\"tt\")))))\n }\n \n fn expand_parse_call(cx: @ExtCtxt,\n@@ -730,25 +730,25 @@ fn expand_parse_call(cx: @ExtCtxt,\n     let tts_expr = expand_tts(cx, sp, tts);\n \n     let cfg_call = || cx.expr_method_call(\n-        sp, cx.expr_ident(sp, id_ext(cx, \"ext_cx\")),\n-        id_ext(cx, \"cfg\"), ~[]);\n+        sp, cx.expr_ident(sp, id_ext(\"ext_cx\")),\n+        id_ext(\"cfg\"), ~[]);\n \n     let parse_sess_call = || cx.expr_method_call(\n-        sp, cx.expr_ident(sp, id_ext(cx, \"ext_cx\")),\n-        id_ext(cx, \"parse_sess\"), ~[]);\n+        sp, cx.expr_ident(sp, id_ext(\"ext_cx\")),\n+        id_ext(\"parse_sess\"), ~[]);\n \n     let new_parser_call =\n         cx.expr_call_global(sp,\n-                            ids_ext(cx, ~[~\"syntax\",\n-                                          ~\"ext\",\n-                                          ~\"quote\",\n-                                          ~\"rt\",\n-                                          ~\"new_parser_from_tts\"]),\n+                            ids_ext(~[~\"syntax\",\n+                                      ~\"ext\",\n+                                      ~\"quote\",\n+                                      ~\"rt\",\n+                                      ~\"new_parser_from_tts\"]),\n                             ~[parse_sess_call(),\n                               cfg_call(),\n                               tts_expr]);\n \n     cx.expr_method_call(sp, new_parser_call,\n-                        id_ext(cx, parse_method),\n+                        id_ext(parse_method),\n                         arg_exprs)\n }"}]}