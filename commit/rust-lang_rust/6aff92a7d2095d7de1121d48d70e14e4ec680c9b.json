{"sha": "6aff92a7d2095d7de1121d48d70e14e4ec680c9b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZhZmY5MmE3ZDIwOTVkN2RlMTEyMWQ0OGQ3MGUxNGU0ZWM2ODBjOWI=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2020-03-20T23:57:30Z"}, "committer": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2020-03-21T21:18:57Z"}, "message": "move DropArena -> libarena", "tree": {"sha": "d6fa347fe30a6e42a82f2c8c33fe12d34969e841", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d6fa347fe30a6e42a82f2c8c33fe12d34969e841"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6aff92a7d2095d7de1121d48d70e14e4ec680c9b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6aff92a7d2095d7de1121d48d70e14e4ec680c9b", "html_url": "https://github.com/rust-lang/rust/commit/6aff92a7d2095d7de1121d48d70e14e4ec680c9b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6aff92a7d2095d7de1121d48d70e14e4ec680c9b/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "38114ff16e7856f98b2b4be7ab4cd29b38bed59a", "url": "https://api.github.com/repos/rust-lang/rust/commits/38114ff16e7856f98b2b4be7ab4cd29b38bed59a", "html_url": "https://github.com/rust-lang/rust/commit/38114ff16e7856f98b2b4be7ab4cd29b38bed59a"}], "stats": {"total": 168, "additions": 82, "deletions": 86}, "files": [{"sha": "0fb06601914a7daab9a90fd9ccfad731842cdda7", "filename": "src/libarena/lib.rs", "status": "modified", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/6aff92a7d2095d7de1121d48d70e14e4ec680c9b/src%2Flibarena%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6aff92a7d2095d7de1121d48d70e14e4ec680c9b/src%2Flibarena%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibarena%2Flib.rs?ref=6aff92a7d2095d7de1121d48d70e14e4ec680c9b", "patch": "@@ -488,5 +488,86 @@ impl DroplessArena {\n     }\n }\n \n+/// Calls the destructor for an object when dropped.\n+struct DropType {\n+    drop_fn: unsafe fn(*mut u8),\n+    obj: *mut u8,\n+}\n+\n+unsafe fn drop_for_type<T>(to_drop: *mut u8) {\n+    std::ptr::drop_in_place(to_drop as *mut T)\n+}\n+\n+impl Drop for DropType {\n+    fn drop(&mut self) {\n+        unsafe { (self.drop_fn)(self.obj) }\n+    }\n+}\n+\n+/// An arena which can be used to allocate any type.\n+/// Allocating in this arena is unsafe since the type system\n+/// doesn't know which types it contains. In order to\n+/// allocate safely, you must store a PhantomData<T>\n+/// alongside this arena for each type T you allocate.\n+#[derive(Default)]\n+pub struct DropArena {\n+    /// A list of destructors to run when the arena drops.\n+    /// Ordered so `destructors` gets dropped before the arena\n+    /// since its destructor can reference memory in the arena.\n+    destructors: RefCell<Vec<DropType>>,\n+    arena: DroplessArena,\n+}\n+\n+impl DropArena {\n+    #[inline]\n+    pub unsafe fn alloc<T>(&self, object: T) -> &mut T {\n+        let mem =\n+            self.arena.alloc_raw(mem::size_of::<T>(), mem::align_of::<T>()) as *mut _ as *mut T;\n+        // Write into uninitialized memory.\n+        ptr::write(mem, object);\n+        let result = &mut *mem;\n+        // Record the destructor after doing the allocation as that may panic\n+        // and would cause `object`'s destuctor to run twice if it was recorded before\n+        self.destructors\n+            .borrow_mut()\n+            .push(DropType { drop_fn: drop_for_type::<T>, obj: result as *mut T as *mut u8 });\n+        result\n+    }\n+\n+    #[inline]\n+    pub unsafe fn alloc_from_iter<T, I: IntoIterator<Item = T>>(&self, iter: I) -> &mut [T] {\n+        let mut vec: SmallVec<[_; 8]> = iter.into_iter().collect();\n+        if vec.is_empty() {\n+            return &mut [];\n+        }\n+        let len = vec.len();\n+\n+        let start_ptr = self\n+            .arena\n+            .alloc_raw(len.checked_mul(mem::size_of::<T>()).unwrap(), mem::align_of::<T>())\n+            as *mut _ as *mut T;\n+\n+        let mut destructors = self.destructors.borrow_mut();\n+        // Reserve space for the destructors so we can't panic while adding them\n+        destructors.reserve(len);\n+\n+        // Move the content to the arena by copying it and then forgetting\n+        // the content of the SmallVec\n+        vec.as_ptr().copy_to_nonoverlapping(start_ptr, len);\n+        mem::forget(vec.drain(..));\n+\n+        // Record the destructors after doing the allocation as that may panic\n+        // and would cause `object`'s destuctor to run twice if it was recorded before\n+        for i in 0..len {\n+            destructors.push(DropType {\n+                drop_fn: drop_for_type::<T>,\n+                obj: start_ptr.offset(i as isize) as *mut u8,\n+            });\n+        }\n+\n+        slice::from_raw_parts_mut(start_ptr, len)\n+    }\n+}\n+\n #[cfg(test)]\n mod tests;"}, {"sha": "2f73566920d0aed0237ffd1e2a0136b16061f86a", "filename": "src/librustc/arena.rs", "status": "modified", "additions": 1, "deletions": 86, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/6aff92a7d2095d7de1121d48d70e14e4ec680c9b/src%2Flibrustc%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6aff92a7d2095d7de1121d48d70e14e4ec680c9b/src%2Flibrustc%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Farena.rs?ref=6aff92a7d2095d7de1121d48d70e14e4ec680c9b", "patch": "@@ -1,10 +1,6 @@\n-use arena::{DroplessArena, TypedArena};\n-use smallvec::SmallVec;\n-use std::cell::RefCell;\n+use arena::{DropArena, DroplessArena, TypedArena};\n use std::marker::PhantomData;\n use std::mem;\n-use std::ptr;\n-use std::slice;\n \n /// This declares a list of types which can be allocated by `Arena`.\n ///\n@@ -275,84 +271,3 @@ impl<'tcx> Arena<'tcx> {\n         }\n     }\n }\n-\n-/// Calls the destructor for an object when dropped.\n-struct DropType {\n-    drop_fn: unsafe fn(*mut u8),\n-    obj: *mut u8,\n-}\n-\n-unsafe fn drop_for_type<T>(to_drop: *mut u8) {\n-    std::ptr::drop_in_place(to_drop as *mut T)\n-}\n-\n-impl Drop for DropType {\n-    fn drop(&mut self) {\n-        unsafe { (self.drop_fn)(self.obj) }\n-    }\n-}\n-\n-/// An arena which can be used to allocate any type.\n-/// Allocating in this arena is unsafe since the type system\n-/// doesn't know which types it contains. In order to\n-/// allocate safely, you must store a PhantomData<T>\n-/// alongside this arena for each type T you allocate.\n-#[derive(Default)]\n-struct DropArena {\n-    /// A list of destructors to run when the arena drops.\n-    /// Ordered so `destructors` gets dropped before the arena\n-    /// since its destructor can reference memory in the arena.\n-    destructors: RefCell<Vec<DropType>>,\n-    arena: DroplessArena,\n-}\n-\n-impl DropArena {\n-    #[inline]\n-    unsafe fn alloc<T>(&self, object: T) -> &mut T {\n-        let mem =\n-            self.arena.alloc_raw(mem::size_of::<T>(), mem::align_of::<T>()) as *mut _ as *mut T;\n-        // Write into uninitialized memory.\n-        ptr::write(mem, object);\n-        let result = &mut *mem;\n-        // Record the destructor after doing the allocation as that may panic\n-        // and would cause `object`'s destuctor to run twice if it was recorded before\n-        self.destructors\n-            .borrow_mut()\n-            .push(DropType { drop_fn: drop_for_type::<T>, obj: result as *mut T as *mut u8 });\n-        result\n-    }\n-\n-    #[inline]\n-    unsafe fn alloc_from_iter<T, I: IntoIterator<Item = T>>(&self, iter: I) -> &mut [T] {\n-        let mut vec: SmallVec<[_; 8]> = iter.into_iter().collect();\n-        if vec.is_empty() {\n-            return &mut [];\n-        }\n-        let len = vec.len();\n-\n-        let start_ptr = self\n-            .arena\n-            .alloc_raw(len.checked_mul(mem::size_of::<T>()).unwrap(), mem::align_of::<T>())\n-            as *mut _ as *mut T;\n-\n-        let mut destructors = self.destructors.borrow_mut();\n-        // Reserve space for the destructors so we can't panic while adding them\n-        destructors.reserve(len);\n-\n-        // Move the content to the arena by copying it and then forgetting\n-        // the content of the SmallVec\n-        vec.as_ptr().copy_to_nonoverlapping(start_ptr, len);\n-        mem::forget(vec.drain(..));\n-\n-        // Record the destructors after doing the allocation as that may panic\n-        // and would cause `object`'s destuctor to run twice if it was recorded before\n-        for i in 0..len {\n-            destructors.push(DropType {\n-                drop_fn: drop_for_type::<T>,\n-                obj: start_ptr.offset(i as isize) as *mut u8,\n-            });\n-        }\n-\n-        slice::from_raw_parts_mut(start_ptr, len)\n-    }\n-}"}]}