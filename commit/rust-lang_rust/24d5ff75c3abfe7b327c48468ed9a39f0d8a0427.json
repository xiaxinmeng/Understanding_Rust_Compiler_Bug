{"sha": "24d5ff75c3abfe7b327c48468ed9a39f0d8a0427", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI0ZDVmZjc1YzNhYmZlN2IzMjdjNDg0NjhlZDlhMzlmMGQ4YTA0Mjc=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2010-06-24T23:19:55Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2010-06-24T23:19:55Z"}, "message": "Fix output-slot handling for real. It's been broken for a long time.", "tree": {"sha": "605bded39c9bf42a2823f725c2690c4e9e9c91d7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/605bded39c9bf42a2823f725c2690c4e9e9c91d7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/24d5ff75c3abfe7b327c48468ed9a39f0d8a0427", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/24d5ff75c3abfe7b327c48468ed9a39f0d8a0427", "html_url": "https://github.com/rust-lang/rust/commit/24d5ff75c3abfe7b327c48468ed9a39f0d8a0427", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/24d5ff75c3abfe7b327c48468ed9a39f0d8a0427/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d3c0762ff85ff7d29668d1f5d2361df03978bbea", "url": "https://api.github.com/repos/rust-lang/rust/commits/d3c0762ff85ff7d29668d1f5d2361df03978bbea", "html_url": "https://github.com/rust-lang/rust/commit/d3c0762ff85ff7d29668d1f5d2361df03978bbea"}], "stats": {"total": 144, "additions": 68, "deletions": 76}, "files": [{"sha": "ddf148380d01389bcdff8eb153478fc3e88ddd4d", "filename": "src/boot/me/semant.ml", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/24d5ff75c3abfe7b327c48468ed9a39f0d8a0427/src%2Fboot%2Fme%2Fsemant.ml", "raw_url": "https://github.com/rust-lang/rust/raw/24d5ff75c3abfe7b327c48468ed9a39f0d8a0427/src%2Fboot%2Fme%2Fsemant.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Fme%2Fsemant.ml?ref=24d5ff75c3abfe7b327c48468ed9a39f0d8a0427", "patch": "@@ -1792,16 +1792,16 @@ let word_slot (abi:Abi.abi) : Ast.slot =\n   interior_slot (Ast.TY_mach abi.Abi.abi_word_ty)\n ;;\n \n-let read_alias_slot (ty:Ast.ty) : Ast.slot =\n+let alias_slot (ty:Ast.ty) : Ast.slot =\n   { Ast.slot_mode = Ast.MODE_alias;\n     Ast.slot_mutable = false;\n     Ast.slot_ty = Some ty }\n ;;\n \n-let word_write_alias_slot (abi:Abi.abi) : Ast.slot =\n+let mutable_alias_slot (ty:Ast.ty) : Ast.slot =\n   { Ast.slot_mode = Ast.MODE_alias;\n     Ast.slot_mutable = true;\n-    Ast.slot_ty = Some (Ast.TY_mach abi.Abi.abi_word_ty) }\n+    Ast.slot_ty = Some ty }\n ;;\n \n let mk_ty_fn_or_iter"}, {"sha": "99e53753ea20389736976f73b426eadcf3cfa236", "filename": "src/boot/me/trans.ml", "status": "modified", "additions": 56, "deletions": 64, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/24d5ff75c3abfe7b327c48468ed9a39f0d8a0427/src%2Fboot%2Fme%2Ftrans.ml", "raw_url": "https://github.com/rust-lang/rust/raw/24d5ff75c3abfe7b327c48468ed9a39f0d8a0427/src%2Fboot%2Fme%2Ftrans.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Fme%2Ftrans.ml?ref=24d5ff75c3abfe7b327c48468ed9a39f0d8a0427", "patch": "@@ -27,6 +27,16 @@ type call =\n     }\n ;;\n \n+let need_ty_fn ty =\n+  match ty with\n+      Ast.TY_fn tfn -> tfn\n+    | _ -> bug () \"need fn\"\n+;;\n+\n+let call_output_slot call =\n+  (fst (need_ty_fn call.call_callee_ty)).Ast.sig_output_slot\n+;;\n+\n let trans_visitor\n     (cx:ctxt)\n     (path:Ast.name_component Stack.t)\n@@ -240,10 +250,6 @@ let trans_visitor\n     Il.Mem (mem, Il.ScalarTy (Il.ValTy word_bits))\n   in\n \n-  let wordptr_at (mem:Il.mem) : Il.cell =\n-    Il.Mem (mem, Il.ScalarTy (Il.AddrTy (Il.ScalarTy (Il.ValTy word_bits))))\n-  in\n-\n   let mov (dst:Il.cell) (src:Il.operand) : unit =\n     emit (Il.umov dst src)\n   in\n@@ -1547,7 +1553,7 @@ let trans_visitor\n   and ty_params_covering (t:Ast.ty) : Ast.slot =\n     let n_ty_params = n_used_type_params t in\n     let params = make_tydesc_slots n_ty_params in\n-      read_alias_slot (Ast.TY_tup params)\n+      alias_slot (Ast.TY_tup params)\n \n   and get_drop_glue\n       (ty:Ast.ty)\n@@ -1563,7 +1569,7 @@ let trans_visitor\n         note_drop_step ty \"drop-glue complete\";\n     in\n     let ty_params_ptr = ty_params_covering ty in\n-    let fty = mk_simple_ty_fn [| ty_params_ptr; read_alias_slot ty |] in\n+    let fty = mk_simple_ty_fn [| ty_params_ptr; alias_slot ty |] in\n       get_typed_mem_glue g fty inner\n \n \n@@ -1632,7 +1638,7 @@ let trans_visitor\n         mark_ty ty_params ty (deref cell) curr_iso\n     in\n     let ty_params_ptr = ty_params_covering ty in\n-    let fty = mk_simple_ty_fn [| ty_params_ptr; read_alias_slot ty |] in\n+    let fty = mk_simple_ty_fn [| ty_params_ptr; alias_slot ty |] in\n       get_typed_mem_glue g fty inner\n \n \n@@ -1654,7 +1660,7 @@ let trans_visitor\n         (interior_slot ty)     (* dst *)\n         [|\n           ty_params_ptr;\n-          read_alias_slot ty;  (* src *)\n+          alias_slot ty;       (* src *)\n           word_slot            (* clone-task *)\n         |]\n     in\n@@ -1676,7 +1682,7 @@ let trans_visitor\n     let fty =\n       mk_ty_fn\n         (interior_slot ty)\n-        [| ty_params_ptr; read_alias_slot ty |]\n+        [| ty_params_ptr; alias_slot ty |]\n     in\n       get_typed_mem_glue g fty inner\n \n@@ -1992,7 +1998,7 @@ let trans_visitor\n             Ast.DOMAIN_thread ->\n               begin\n                 trans_upcall \"upcall_new_thread\" new_task [| |];\n-                copy_fn_args false (CLONE_all new_task) call;\n+                copy_fn_args false true (CLONE_all new_task) call;\n                 trans_upcall \"upcall_start_thread\" task_cell\n                   [|\n                     Il.Cell new_task;\n@@ -2004,7 +2010,7 @@ let trans_visitor\n          | _ ->\n              begin\n                  trans_upcall \"upcall_new_task\" new_task [| |];\n-                 copy_fn_args false (CLONE_chan new_task) call;\n+                 copy_fn_args false true (CLONE_chan new_task) call;\n                  trans_upcall \"upcall_start_task\" task_cell\n                    [|\n                      Il.Cell new_task;\n@@ -3337,13 +3343,22 @@ let trans_visitor\n         bound_arg_slots bound_args\n \n \n-  and trans_arg0 (arg_cell:Il.cell) (output_cell:Il.cell) : unit =\n+  and trans_arg0 (arg_cell:Il.cell) (initializing:bool) (call:call) : unit =\n     (* Emit arg0 of any call: the output slot. *)\n     iflog (fun _ -> annotate \"fn-call arg 0: output slot\");\n-    trans_init_slot_from_cell\n-      CLONE_none\n-      arg_cell (word_write_alias_slot abi)\n-      output_cell word_slot\n+    if not initializing\n+    then\n+      drop_slot\n+        (get_ty_params_of_current_frame())\n+        call.call_output\n+        (call_output_slot call) None;\n+    (* We always get to the same state here: the output slot is uninitialized.\n+     * We then do something that's illegal to do in the language, but legal\n+     * here: alias the uninitialized memory. We are ok doing this because the\n+     * call will fill it in before anyone else observes it. That's the\n+     * point.\n+     *)\n+    mov arg_cell (Il.Cell (alias call.call_output));\n \n   and trans_arg1 (arg_cell:Il.cell) : unit =\n     (* Emit arg1 of any call: the task pointer. *)\n@@ -3385,6 +3400,7 @@ let trans_visitor\n \n   and copy_fn_args\n       (tail_area:bool)\n+      (initializing_arg0:bool)\n       (clone:clone_ctrl)\n       (call:call)\n       : unit =\n@@ -3489,7 +3505,7 @@ let trans_visitor\n \n         trans_arg1 callee_task_cell;\n \n-        trans_arg0 callee_output_cell call.call_output\n+        trans_arg0 callee_output_cell initializing_arg0 call\n \n \n \n@@ -3700,13 +3716,12 @@ let trans_visitor\n     in\n       iflog (fun _ -> annotate\n                (Printf.sprintf \"copy args for tail call to %s\" (logname ())));\n-      copy_fn_args true CLONE_none call;\n+      copy_fn_args true true CLONE_none call;\n       drop_slots_at_curr_stmt();\n       abi.Abi.abi_emit_fn_tail_call (emitter())\n         (force_sz (current_fn_callsz()))\n         caller_argsz callee_code callee_argsz;\n \n-\n   and trans_prepare_call\n       (initializing:bool)\n       (logname:(unit -> string))\n@@ -3716,17 +3731,8 @@ let trans_visitor\n     let callee_fptr = callee_fn_ptr call.call_callee_ptr call.call_ctrl in\n       iflog (fun _ -> annotate\n                (Printf.sprintf \"copy args for call to %s\" (logname ())));\n-      copy_fn_args false CLONE_none call;\n+      copy_fn_args false initializing CLONE_none call;\n       iflog (fun _ -> annotate (Printf.sprintf \"call %s\" (logname ())));\n-      if not initializing\n-      then\n-        begin\n-          match call.call_callee_ty with\n-              Ast.TY_fn (tsig, _) ->\n-                drop_slot (get_ty_params_of_current_frame()) call.call_output\n-                  tsig.Ast.sig_output_slot None;\n-            | _ -> bug () \"calling non-fn\"\n-        end;\n       callee_fptr\n \n   and callee_drop_slot\n@@ -3868,15 +3874,20 @@ let trans_visitor\n       b\n \n \n-  and trans_set_outptr (at:Ast.atom) : unit =\n-    let (dst_mem, _) =\n-      need_mem_cell\n-        (deref (wordptr_at (fp_imm out_mem_disp)))\n+  and get_current_output_cell_and_slot _ : (Il.cell * Ast.slot) =\n+    let curr_fty =\n+      need_ty_fn (Hashtbl.find cx.ctxt_all_item_types (current_fn()))\n+    in\n+    let curr_args = get_args_for_current_frame () in\n+    let curr_outptr =\n+      get_element_ptr curr_args Abi.calltup_elt_out_ptr\n     in\n-    let atom_ty = atom_type cx at in\n-    let dst_slot = interior_slot atom_ty in\n-    let dst_ty = referent_type abi atom_ty in\n-    let dst_cell = Il.Mem (dst_mem, dst_ty) in\n+    let dst_cell = deref curr_outptr in\n+    let dst_slot = (fst curr_fty).Ast.sig_output_slot in\n+      (dst_cell, dst_slot)\n+\n+  and trans_set_outptr (at:Ast.atom) : unit =\n+    let (dst_cell, dst_slot) = get_current_output_cell_and_slot () in\n       trans_init_slot_from_atom\n         CLONE_none dst_cell dst_slot at\n \n@@ -4239,26 +4250,13 @@ let trans_visitor\n           emit (Il.jmp Il.JMP Il.CodeNone)\n \n       | Ast.STMT_be (flv, args) ->\n-          let ty = lval_ty cx flv in\n           let ty_params =\n             match htab_search cx.ctxt_call_lval_params (lval_base_id flv) with\n                 Some params -> params\n               | None -> [| |]\n             in\n-            begin\n-              match ty with\n-                  Ast.TY_fn (tsig, _) ->\n-                    let result_ty = slot_ty tsig.Ast.sig_output_slot in\n-                    let (dst_mem, _) =\n-                      need_mem_cell\n-                        (deref (wordptr_at (fp_imm out_mem_disp)))\n-                    in\n-                    let dst_rty = referent_type abi result_ty in\n-                    let dst_cell = Il.Mem (dst_mem, dst_rty) in\n-                      trans_be_fn cx dst_cell flv ty_params args\n-\n-                | _ -> bug () \"Calling unexpected lval.\"\n-            end\n+          let (dst_cell, _) = get_current_output_cell_and_slot () in\n+            trans_be_fn cx dst_cell flv ty_params args\n \n       | Ast.STMT_put atom_opt ->\n           trans_put atom_opt\n@@ -4446,10 +4444,9 @@ let trans_visitor\n \n     let ctor_ty = Hashtbl.find cx.ctxt_all_item_types obj_id in\n     let obj_ty =\n-      match ctor_ty with\n-          Ast.TY_fn (tsig, _) -> slot_ty tsig.Ast.sig_output_slot\n-        | _ -> bug () \"object constructor doesn't have function type\"\n+      slot_ty (fst (need_ty_fn ctor_ty)).Ast.sig_output_slot\n     in\n+\n     let vtbl_ptr = get_obj_vtbl obj_id in\n     let _ =\n       iflog (fun _ -> annotate \"calculate vtbl-ptr from displacement\")\n@@ -4667,15 +4664,10 @@ let trans_visitor\n     let (header_tup, _, _) = tag in\n     let ctor_ty = Hashtbl.find cx.ctxt_all_item_types tagid in\n     let ttag =\n-      match ctor_ty with\n-          Ast.TY_fn (tsig, _) ->\n-            begin\n-              match slot_ty tsig.Ast.sig_output_slot with\n-                  Ast.TY_tag ttag -> ttag\n-                | Ast.TY_iso tiso -> get_iso_tag tiso\n-                | _ -> bugi cx tagid \"unexpected fn type for tag constructor\"\n-            end\n-        | _ -> bugi cx tagid \"unexpected type for tag constructor\"\n+      match slot_ty (fst (need_ty_fn ctor_ty)).Ast.sig_output_slot with\n+          Ast.TY_tag ttag -> ttag\n+        | Ast.TY_iso tiso -> get_iso_tag tiso\n+        | _ -> bugi cx tagid \"unexpected fn type for tag constructor\"\n     in\n     let slots =\n       Array.map (fun sloti -> referent_to_slot cx sloti.id) header_tup"}, {"sha": "3dd5ae2e3b5685ac6a8b9fef8cffb13df6f23a53", "filename": "src/test/run-pass/output-slot-variants.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/24d5ff75c3abfe7b327c48468ed9a39f0d8a0427/src%2Ftest%2Frun-pass%2Foutput-slot-variants.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24d5ff75c3abfe7b327c48468ed9a39f0d8a0427/src%2Ftest%2Frun-pass%2Foutput-slot-variants.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Foutput-slot-variants.rs?ref=24d5ff75c3abfe7b327c48468ed9a39f0d8a0427", "patch": "@@ -35,24 +35,24 @@ fn main() {\n   int_i = ret_int_i(); // non-initializing\n   int_i = ret_int_i(); // non-initializing\n \n-  //ext_i = ret_ext_i(); // initializing\n-  //ext_i = ret_ext_i(); // non-initializing\n-  //ext_i = ret_ext_i(); // non-initializing\n+  ext_i = ret_ext_i(); // initializing\n+  ext_i = ret_ext_i(); // non-initializing\n+  ext_i = ret_ext_i(); // non-initializing\n \n   int_tup = ret_int_tup(); // initializing\n   int_tup = ret_int_tup(); // non-initializing\n   int_tup = ret_int_tup(); // non-initializing\n \n-  //ext_tup = ret_ext_tup(); // initializing\n-  //ext_tup = ret_ext_tup(); // non-initializing\n-  //ext_tup = ret_ext_tup(); // non-initializing\n+  ext_tup = ret_ext_tup(); // initializing\n+  ext_tup = ret_ext_tup(); // non-initializing\n+  ext_tup = ret_ext_tup(); // non-initializing\n \n   ext_mem = ret_ext_mem(); // initializing\n   ext_mem = ret_ext_mem(); // non-initializing\n   ext_mem = ret_ext_mem(); // non-initializing\n \n-  //ext_ext_mem = ret_ext_ext_mem(); // initializing\n-  //ext_ext_mem = ret_ext_ext_mem(); // non-initializing\n-  //ext_ext_mem = ret_ext_ext_mem(); // non-initializing\n+  ext_ext_mem = ret_ext_ext_mem(); // initializing\n+  ext_ext_mem = ret_ext_ext_mem(); // non-initializing\n+  ext_ext_mem = ret_ext_ext_mem(); // non-initializing\n \n }"}]}