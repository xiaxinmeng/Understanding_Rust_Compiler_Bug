{"sha": "de3cf6e8a472bf67df278cfae8986afdcc215c18", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRlM2NmNmU4YTQ3MmJmNjdkZjI3OGNmYWU4OTg2YWZkY2MyMTVjMTg=", "commit": {"author": {"name": "Wesley Wiser", "email": "wwiser@gmail.com", "date": "2020-04-04T00:28:07Z"}, "committer": {"name": "Wesley Wiser", "email": "wwiser@gmail.com", "date": "2020-04-15T18:58:53Z"}, "message": "Run `SimplifyLocals` iteratively until we get to a fixedpoint", "tree": {"sha": "ccc17fdb90b5146a4f140cb07773f95436e3c930", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ccc17fdb90b5146a4f140cb07773f95436e3c930"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/de3cf6e8a472bf67df278cfae8986afdcc215c18", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/de3cf6e8a472bf67df278cfae8986afdcc215c18", "html_url": "https://github.com/rust-lang/rust/commit/de3cf6e8a472bf67df278cfae8986afdcc215c18", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/de3cf6e8a472bf67df278cfae8986afdcc215c18/comments", "author": {"login": "wesleywiser", "id": 831192, "node_id": "MDQ6VXNlcjgzMTE5Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/831192?v=4", "gravatar_id": "", "url": "https://api.github.com/users/wesleywiser", "html_url": "https://github.com/wesleywiser", "followers_url": "https://api.github.com/users/wesleywiser/followers", "following_url": "https://api.github.com/users/wesleywiser/following{/other_user}", "gists_url": "https://api.github.com/users/wesleywiser/gists{/gist_id}", "starred_url": "https://api.github.com/users/wesleywiser/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/wesleywiser/subscriptions", "organizations_url": "https://api.github.com/users/wesleywiser/orgs", "repos_url": "https://api.github.com/users/wesleywiser/repos", "events_url": "https://api.github.com/users/wesleywiser/events{/privacy}", "received_events_url": "https://api.github.com/users/wesleywiser/received_events", "type": "User", "site_admin": false}, "committer": {"login": "wesleywiser", "id": 831192, "node_id": "MDQ6VXNlcjgzMTE5Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/831192?v=4", "gravatar_id": "", "url": "https://api.github.com/users/wesleywiser", "html_url": "https://github.com/wesleywiser", "followers_url": "https://api.github.com/users/wesleywiser/followers", "following_url": "https://api.github.com/users/wesleywiser/following{/other_user}", "gists_url": "https://api.github.com/users/wesleywiser/gists{/gist_id}", "starred_url": "https://api.github.com/users/wesleywiser/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/wesleywiser/subscriptions", "organizations_url": "https://api.github.com/users/wesleywiser/orgs", "repos_url": "https://api.github.com/users/wesleywiser/repos", "events_url": "https://api.github.com/users/wesleywiser/events{/privacy}", "received_events_url": "https://api.github.com/users/wesleywiser/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7c0802b34124b777f2cf414a4d88a8576645c3c3", "url": "https://api.github.com/repos/rust-lang/rust/commits/7c0802b34124b777f2cf414a4d88a8576645c3c3", "html_url": "https://github.com/rust-lang/rust/commit/7c0802b34124b777f2cf414a4d88a8576645c3c3"}], "stats": {"total": 158, "additions": 131, "deletions": 27}, "files": [{"sha": "31d902bef1d6dc3a8beede3c29c27f1c9c5d82ef", "filename": "src/librustc_mir/transform/simplify.rs", "status": "modified", "additions": 131, "deletions": 27, "changes": 158, "blob_url": "https://github.com/rust-lang/rust/blob/de3cf6e8a472bf67df278cfae8986afdcc215c18/src%2Flibrustc_mir%2Ftransform%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de3cf6e8a472bf67df278cfae8986afdcc215c18/src%2Flibrustc_mir%2Ftransform%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fsimplify.rs?ref=de3cf6e8a472bf67df278cfae8986afdcc215c18", "patch": "@@ -306,49 +306,74 @@ pub struct SimplifyLocals;\n impl<'tcx> MirPass<'tcx> for SimplifyLocals {\n     fn run_pass(&self, tcx: TyCtxt<'tcx>, source: MirSource<'tcx>, body: &mut BodyAndCache<'tcx>) {\n         trace!(\"running SimplifyLocals on {:?}\", source);\n-        let locals = {\n+\n+        let mut used_locals = {\n             let read_only_cache = read_only!(body);\n-            let mut marker = DeclMarker { locals: BitSet::new_empty(body.local_decls.len()), body };\n+            let mut marker = DeclMarker::new(body);\n             marker.visit_body(&read_only_cache);\n-            // Return pointer and arguments are always live\n-            marker.locals.insert(RETURN_PLACE);\n-            for arg in body.args_iter() {\n-                marker.locals.insert(arg);\n-            }\n \n-            marker.locals\n+            marker.local_counts\n         };\n \n-        let map = make_local_map(&mut body.local_decls, locals);\n-        // Update references to all vars and tmps now\n-        LocalUpdater { map, tcx }.visit_body(body);\n-        body.local_decls.shrink_to_fit();\n+        let arg_count = body.arg_count;\n+\n+        loop {\n+            let mut remove_statements = RemoveStatements::new(&mut used_locals, arg_count, tcx);\n+            remove_statements.visit_body(body);\n+\n+            if !remove_statements.modified {\n+                break;\n+            }\n+        }\n+\n+        let map = make_local_map(&mut body.local_decls, used_locals, arg_count);\n+\n+        // Only bother running the `LocalUpdater` if we actually found locals to remove.\n+        if map.iter().any(Option::is_none) {\n+            // Update references to all vars and tmps now\n+            let mut updater = LocalUpdater { map, tcx };\n+            updater.visit_body(body);\n+\n+            body.local_decls.shrink_to_fit();\n+        }\n     }\n }\n \n /// Construct the mapping while swapping out unused stuff out from the `vec`.\n fn make_local_map<V>(\n-    vec: &mut IndexVec<Local, V>,\n-    mask: BitSet<Local>,\n+    local_decls: &mut IndexVec<Local, V>,\n+    used_locals: IndexVec<Local, usize>,\n+    arg_count: usize,\n ) -> IndexVec<Local, Option<Local>> {\n-    let mut map: IndexVec<Local, Option<Local>> = IndexVec::from_elem(None, &*vec);\n+    let mut map: IndexVec<Local, Option<Local>> = IndexVec::from_elem(None, &*local_decls);\n     let mut used = Local::new(0);\n-    for alive_index in mask.iter() {\n+    for (alive_index, count) in used_locals.iter_enumerated() {\n+        // The `RETURN_PLACE` and arguments are always live.\n+        if alive_index.as_usize() > arg_count && *count == 0 {\n+            continue;\n+        }\n+\n         map[alive_index] = Some(used);\n         if alive_index != used {\n-            vec.swap(alive_index, used);\n+            local_decls.swap(alive_index, used);\n         }\n         used.increment_by(1);\n     }\n-    vec.truncate(used.index());\n+    local_decls.truncate(used.index());\n     map\n }\n \n struct DeclMarker<'a, 'tcx> {\n-    pub locals: BitSet<Local>,\n+    pub local_counts: IndexVec<Local, usize>,\n     pub body: &'a Body<'tcx>,\n }\n \n+impl<'a, 'tcx> DeclMarker<'a, 'tcx> {\n+    pub fn new(body: &'a Body<'tcx>) -> Self {\n+        Self { local_counts: IndexVec::from_elem(0, &body.local_decls), body }\n+    }\n+}\n+\n impl<'a, 'tcx> Visitor<'tcx> for DeclMarker<'a, 'tcx> {\n     fn visit_local(&mut self, local: &Local, ctx: PlaceContext, location: Location) {\n         // Ignore storage markers altogether, they get removed along with their otherwise unused\n@@ -408,29 +433,108 @@ impl<'a, 'tcx> Visitor<'tcx> for DeclMarker<'a, 'tcx> {\n             }\n         }\n \n-        self.locals.insert(*local);\n+        self.local_counts[*local] += 1;\n     }\n }\n \n-struct LocalUpdater<'tcx> {\n-    map: IndexVec<Local, Option<Local>>,\n+struct StatementDeclMarker<'a, 'tcx> {\n+    used_locals: IndexVec<Local, usize>,\n+    statement: &'a Statement<'tcx>,\n+}\n+\n+impl<'a, 'tcx> StatementDeclMarker<'a, 'tcx> {\n+    pub fn new(local_count: usize, statement: &'a Statement<'tcx>) -> Self {\n+        Self { used_locals: IndexVec::from_elem_n(0, local_count), statement }\n+    }\n+}\n+\n+impl<'a, 'tcx> Visitor<'tcx> for StatementDeclMarker<'a, 'tcx> {\n+    fn visit_local(&mut self, local: &Local, context: PlaceContext, _location: Location) {\n+        // Skip the lvalue for assignments\n+        if let StatementKind::Assign(box (p, _)) = self.statement.kind {\n+            if p.local == *local && context.is_place_assignment() {\n+                return;\n+            }\n+        }\n+\n+        self.used_locals[*local] += 1;\n+    }\n+}\n+\n+struct RemoveStatements<'a, 'tcx> {\n+    used_locals: &'a mut IndexVec<Local, usize>,\n+    arg_count: usize,\n     tcx: TyCtxt<'tcx>,\n+    modified: bool,\n }\n \n-impl<'tcx> MutVisitor<'tcx> for LocalUpdater<'tcx> {\n+impl<'a, 'tcx> RemoveStatements<'a, 'tcx> {\n+    fn new(\n+        used_locals: &'a mut IndexVec<Local, usize>,\n+        arg_count: usize,\n+        tcx: TyCtxt<'tcx>,\n+    ) -> Self {\n+        Self { used_locals, arg_count, tcx, modified: false }\n+    }\n+\n+    fn keep_local(&self, l: Local) -> bool {\n+        trace!(\"keep_local({:?}): count: {:?}\", l, self.used_locals[l]);\n+        l.as_usize() <= self.arg_count || self.used_locals[l] != 0\n+    }\n+}\n+\n+impl<'a, 'tcx> MutVisitor<'tcx> for RemoveStatements<'a, 'tcx> {\n     fn tcx(&self) -> TyCtxt<'tcx> {\n         self.tcx\n     }\n \n     fn visit_basic_block_data(&mut self, block: BasicBlock, data: &mut BasicBlockData<'tcx>) {\n         // Remove unnecessary StorageLive and StorageDead annotations.\n-        data.statements.retain(|stmt| match &stmt.kind {\n-            StatementKind::StorageLive(l) | StatementKind::StorageDead(l) => self.map[*l].is_some(),\n-            StatementKind::Assign(box (place, _)) => self.map[place.local].is_some(),\n-            _ => true,\n+        let mut i = 0usize;\n+        data.statements.retain(|stmt| {\n+            let keep = match &stmt.kind {\n+                StatementKind::StorageLive(l) | StatementKind::StorageDead(l) => {\n+                    self.keep_local(*l)\n+                }\n+                StatementKind::Assign(box (place, _)) => self.keep_local(place.local),\n+                _ => true,\n+            };\n+\n+            if !keep {\n+                trace!(\"removing statement {:?}\", stmt);\n+                self.modified = true;\n+\n+                let mut visitor = StatementDeclMarker::new(self.used_locals.len(), stmt);\n+                visitor.visit_statement(stmt, Location { block, statement_index: i });\n+\n+                for (local, count) in visitor.used_locals.iter_enumerated() {\n+                    let used_count = &mut self.used_locals[local];\n+\n+                    // If this is the local we're removing...\n+                    if *used_count != 0 {\n+                        *used_count -= count;\n+                    }\n+                }\n+            }\n+\n+            i += 1;\n+\n+            keep\n         });\n+\n         self.super_basic_block_data(block, data);\n     }\n+}\n+\n+struct LocalUpdater<'tcx> {\n+    map: IndexVec<Local, Option<Local>>,\n+    tcx: TyCtxt<'tcx>,\n+}\n+\n+impl<'tcx> MutVisitor<'tcx> for LocalUpdater<'tcx> {\n+    fn tcx(&self) -> TyCtxt<'tcx> {\n+        self.tcx\n+    }\n \n     fn visit_local(&mut self, l: &mut Local, _: PlaceContext, _: Location) {\n         *l = self.map[*l].unwrap();"}]}