{"sha": "41e4218d2a218896d9acde3ab68d7862b56b7f54", "node_id": "C_kwDOAAsO6NoAKDQxZTQyMThkMmEyMTg4OTZkOWFjZGUzYWI2OGQ3ODYyYjU2YjdmNTQ", "commit": {"author": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2022-11-02T04:09:01Z"}, "committer": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2022-11-02T04:11:05Z"}, "message": "Use TraitEngine less", "tree": {"sha": "6d58078e2eaec07fed965c2203dd3c9bc6aa9e6f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6d58078e2eaec07fed965c2203dd3c9bc6aa9e6f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/41e4218d2a218896d9acde3ab68d7862b56b7f54", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/41e4218d2a218896d9acde3ab68d7862b56b7f54", "html_url": "https://github.com/rust-lang/rust/commit/41e4218d2a218896d9acde3ab68d7862b56b7f54", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/41e4218d2a218896d9acde3ab68d7862b56b7f54/comments", "author": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "11ebe6512b4c77633c59f8dcdd421df3b79d1a9f", "url": "https://api.github.com/repos/rust-lang/rust/commits/11ebe6512b4c77633c59f8dcdd421df3b79d1a9f", "html_url": "https://github.com/rust-lang/rust/commit/11ebe6512b4c77633c59f8dcdd421df3b79d1a9f"}], "stats": {"total": 143, "additions": 57, "deletions": 86}, "files": [{"sha": "8987a51757cd50ff2fa23fc72aba03839c4d4d59", "filename": "compiler/rustc_borrowck/src/diagnostics/conflict_errors.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/41e4218d2a218896d9acde3ab68d7862b56b7f54/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41e4218d2a218896d9acde3ab68d7862b56b7f54/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs?ref=41e4218d2a218896d9acde3ab68d7862b56b7f54", "patch": "@@ -23,7 +23,6 @@ use rustc_span::hygiene::DesugaringKind;\n use rustc_span::symbol::sym;\n use rustc_span::{BytePos, Span, Symbol};\n use rustc_trait_selection::infer::InferCtxtExt;\n-use rustc_trait_selection::traits::TraitEngineExt as _;\n \n use crate::borrow_set::TwoPhaseActivation;\n use crate::borrowck_errors;\n@@ -613,24 +612,20 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         else { return; };\n         // Try to find predicates on *generic params* that would allow copying `ty`\n         let infcx = tcx.infer_ctxt().build();\n-        let mut fulfill_cx = <dyn rustc_infer::traits::TraitEngine<'_>>::new(infcx.tcx);\n-\n         let copy_did = infcx.tcx.lang_items().copy_trait().unwrap();\n         let cause = ObligationCause::new(\n             span,\n             self.mir_hir_id(),\n             rustc_infer::traits::ObligationCauseCode::MiscObligation,\n         );\n-        fulfill_cx.register_bound(\n+        let errors = rustc_trait_selection::traits::fully_solve_bound(\n             &infcx,\n+            cause,\n             self.param_env,\n             // Erase any region vids from the type, which may not be resolved\n             infcx.tcx.erase_regions(ty),\n             copy_did,\n-            cause,\n         );\n-        // Select all, including ambiguous predicates\n-        let errors = fulfill_cx.select_all_or_error(&infcx);\n \n         // Only emit suggestion if all required predicates are on generic\n         let predicates: Result<Vec<_>, _> = errors"}, {"sha": "95ea42b584a3a6d502798fb28467597764193927", "filename": "compiler/rustc_borrowck/src/region_infer/opaque_types.rs", "status": "modified", "additions": 25, "deletions": 28, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/41e4218d2a218896d9acde3ab68d7862b56b7f54/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41e4218d2a218896d9acde3ab68d7862b56b7f54/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs?ref=41e4218d2a218896d9acde3ab68d7862b56b7f54", "patch": "@@ -4,15 +4,15 @@ use rustc_hir::def_id::LocalDefId;\n use rustc_hir::OpaqueTyOrigin;\n use rustc_infer::infer::TyCtxtInferExt as _;\n use rustc_infer::infer::{DefiningAnchor, InferCtxt};\n-use rustc_infer::traits::{Obligation, ObligationCause, TraitEngine};\n+use rustc_infer::traits::{Obligation, ObligationCause};\n use rustc_middle::ty::subst::{GenericArgKind, InternalSubsts};\n use rustc_middle::ty::visit::TypeVisitable;\n use rustc_middle::ty::{\n     self, OpaqueHiddenType, OpaqueTypeKey, ToPredicate, Ty, TyCtxt, TypeFoldable,\n };\n use rustc_span::Span;\n use rustc_trait_selection::traits::error_reporting::TypeErrCtxtExt as _;\n-use rustc_trait_selection::traits::TraitEngineExt as _;\n+use rustc_trait_selection::traits::ObligationCtxt;\n \n use super::RegionInferenceContext;\n \n@@ -252,48 +252,45 @@ impl<'tcx> InferCtxtExt<'tcx> for InferCtxt<'tcx> {\n         // type-alias-impl-trait/issue-67844-nested-opaque.rs\n         let infcx =\n             self.tcx.infer_ctxt().with_opaque_type_inference(DefiningAnchor::Bubble).build();\n+        let ocx = ObligationCtxt::new(&infcx);\n         // Require the hidden type to be well-formed with only the generics of the opaque type.\n         // Defining use functions may have more bounds than the opaque type, which is ok, as long as the\n         // hidden type is well formed even without those bounds.\n         let predicate = ty::Binder::dummy(ty::PredicateKind::WellFormed(definition_ty.into()))\n             .to_predicate(infcx.tcx);\n-        let mut fulfillment_cx = <dyn TraitEngine<'tcx>>::new(infcx.tcx);\n \n         let id_substs = InternalSubsts::identity_for_item(self.tcx, def_id.to_def_id());\n \n         // Require that the hidden type actually fulfills all the bounds of the opaque type, even without\n         // the bounds that the function supplies.\n         let opaque_ty = self.tcx.mk_opaque(def_id.to_def_id(), id_substs);\n-        match infcx\n-            .at(&ObligationCause::misc(instantiated_ty.span, body_id), param_env)\n-            .eq(opaque_ty, definition_ty)\n-        {\n-            Ok(infer_ok) => {\n-                for obligation in infer_ok.obligations {\n-                    fulfillment_cx.register_predicate_obligation(&infcx, obligation);\n-                }\n-            }\n-            Err(err) => {\n-                infcx\n-                    .err_ctxt()\n-                    .report_mismatched_types(\n-                        &ObligationCause::misc(instantiated_ty.span, body_id),\n-                        opaque_ty,\n-                        definition_ty,\n-                        err,\n-                    )\n-                    .emit();\n-            }\n+        if let Err(err) = ocx.eq(\n+            &ObligationCause::misc(instantiated_ty.span, body_id),\n+            param_env,\n+            opaque_ty,\n+            definition_ty,\n+        ) {\n+            infcx\n+                .err_ctxt()\n+                .report_mismatched_types(\n+                    &ObligationCause::misc(instantiated_ty.span, body_id),\n+                    opaque_ty,\n+                    definition_ty,\n+                    err,\n+                )\n+                .emit();\n         }\n \n-        fulfillment_cx.register_predicate_obligation(\n-            &infcx,\n-            Obligation::misc(instantiated_ty.span, body_id, param_env, predicate),\n-        );\n+        ocx.register_obligation(Obligation::misc(\n+            instantiated_ty.span,\n+            body_id,\n+            param_env,\n+            predicate,\n+        ));\n \n         // Check that all obligations are satisfied by the implementation's\n         // version.\n-        let errors = fulfillment_cx.select_all_or_error(&infcx);\n+        let errors = ocx.select_all_or_error();\n \n         // This is still required for many(half of the tests in ui/type-alias-impl-trait)\n         // tests to pass"}, {"sha": "b1ad22b899e30215f339ed97c5c0d2496bb8ff00", "filename": "compiler/rustc_const_eval/src/transform/check_consts/check.rs", "status": "modified", "additions": 15, "deletions": 27, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/41e4218d2a218896d9acde3ab68d7862b56b7f54/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41e4218d2a218896d9acde3ab68d7862b56b7f54/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fcheck.rs?ref=41e4218d2a218896d9acde3ab68d7862b56b7f54", "patch": "@@ -13,11 +13,8 @@ use rustc_middle::ty::{self, adjustment::PointerCast, Instance, InstanceDef, Ty,\n use rustc_middle::ty::{Binder, TraitPredicate, TraitRef, TypeVisitable};\n use rustc_mir_dataflow::{self, Analysis};\n use rustc_span::{sym, Span, Symbol};\n-use rustc_trait_selection::infer::InferCtxtExt;\n use rustc_trait_selection::traits::error_reporting::TypeErrCtxtExt as _;\n-use rustc_trait_selection::traits::{\n-    self, ObligationCauseCode, SelectionContext, TraitEngine, TraitEngineExt,\n-};\n+use rustc_trait_selection::traits::{self, ObligationCauseCode, ObligationCtxt, SelectionContext};\n \n use std::mem;\n use std::ops::Deref;\n@@ -747,35 +744,26 @@ impl<'tcx> Visitor<'tcx> for Checker<'_, 'tcx> {\n                     // \"non-const\" check. This is required for correctness here.\n                     {\n                         let infcx = tcx.infer_ctxt().build();\n-                        let mut fulfill_cx = <dyn TraitEngine<'_>>::new(infcx.tcx);\n+                        let ocx = ObligationCtxt::new(&infcx);\n+\n                         let predicates = tcx.predicates_of(callee).instantiate(tcx, substs);\n                         let hir_id = tcx\n                             .hir()\n                             .local_def_id_to_hir_id(self.body.source.def_id().expect_local());\n-                        let cause = || {\n-                            ObligationCause::new(\n-                                terminator.source_info.span,\n-                                hir_id,\n-                                ObligationCauseCode::ItemObligation(callee),\n-                            )\n-                        };\n-                        let normalized = infcx.partially_normalize_associated_types_in(\n-                            cause(),\n-                            param_env,\n-                            predicates,\n+                        let cause = ObligationCause::new(\n+                            terminator.source_info.span,\n+                            hir_id,\n+                            ObligationCauseCode::ItemObligation(callee),\n                         );\n-\n-                        for p in normalized.obligations {\n-                            fulfill_cx.register_predicate_obligation(&infcx, p);\n-                        }\n-                        for obligation in traits::predicates_for_generics(\n-                            |_, _| cause(),\n+                        let normalized_predicates =\n+                            ocx.normalize(cause.clone(), param_env, predicates);\n+                        ocx.register_obligations(traits::predicates_for_generics(\n+                            |_, _| cause.clone(),\n                             self.param_env,\n-                            normalized.value,\n-                        ) {\n-                            fulfill_cx.register_predicate_obligation(&infcx, obligation);\n-                        }\n-                        let errors = fulfill_cx.select_all_or_error(&infcx);\n+                            normalized_predicates,\n+                        ));\n+\n+                        let errors = ocx.select_all_or_error();\n                         if !errors.is_empty() {\n                             infcx.err_ctxt().report_fulfillment_errors(&errors, None, false);\n                         }"}, {"sha": "8598369e884b4e4a1fccbb0fdcb4352619ea0919", "filename": "compiler/rustc_hir_typeck/src/op.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/41e4218d2a218896d9acde3ab68d7862b56b7f54/compiler%2Frustc_hir_typeck%2Fsrc%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41e4218d2a218896d9acde3ab68d7862b56b7f54/compiler%2Frustc_hir_typeck%2Fsrc%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fop.rs?ref=41e4218d2a218896d9acde3ab68d7862b56b7f54", "patch": "@@ -19,7 +19,7 @@ use rustc_span::symbol::{sym, Ident};\n use rustc_span::Span;\n use rustc_trait_selection::infer::InferCtxtExt;\n use rustc_trait_selection::traits::error_reporting::suggestions::TypeErrCtxtExt as _;\n-use rustc_trait_selection::traits::{FulfillmentError, TraitEngine, TraitEngineExt};\n+use rustc_trait_selection::traits::FulfillmentError;\n use rustc_type_ir::sty::TyKind::*;\n \n impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n@@ -785,9 +785,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     other_ty_expr,\n                     expected,\n                 );\n-                let mut fulfill = <dyn TraitEngine<'_>>::new(self.tcx);\n-                fulfill.register_predicate_obligation(self, obligation);\n-                Err(fulfill.select_where_possible(&self.infcx))\n+                Err(rustc_trait_selection::traits::fully_solve_obligation(self, obligation))\n             }\n         }\n     }"}, {"sha": "4187850153ccd001c22f3659f4803a0f5b1ea75c", "filename": "compiler/rustc_lint/src/for_loops_over_fallibles.rs", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/41e4218d2a218896d9acde3ab68d7862b56b7f54/compiler%2Frustc_lint%2Fsrc%2Ffor_loops_over_fallibles.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41e4218d2a218896d9acde3ab68d7862b56b7f54/compiler%2Frustc_lint%2Fsrc%2Ffor_loops_over_fallibles.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Ffor_loops_over_fallibles.rs?ref=41e4218d2a218896d9acde3ab68d7862b56b7f54", "patch": "@@ -3,11 +3,9 @@ use crate::{LateContext, LateLintPass, LintContext};\n use hir::{Expr, Pat};\n use rustc_errors::{Applicability, DelayDm};\n use rustc_hir as hir;\n-use rustc_infer::traits::TraitEngine;\n use rustc_infer::{infer::TyCtxtInferExt, traits::ObligationCause};\n use rustc_middle::ty::{self, List};\n use rustc_span::{sym, Span};\n-use rustc_trait_selection::traits::TraitEngineExt;\n \n declare_lint! {\n     /// The `for_loops_over_fallibles` lint checks for `for` loops over `Option` or `Result` values.\n@@ -160,24 +158,19 @@ fn suggest_question_mark<'tcx>(\n \n     let ty = substs.type_at(0);\n     let infcx = cx.tcx.infer_ctxt().build();\n-    let mut fulfill_cx = <dyn TraitEngine<'_>>::new(infcx.tcx);\n-\n     let cause = ObligationCause::new(\n         span,\n         body_id.hir_id,\n         rustc_infer::traits::ObligationCauseCode::MiscObligation,\n     );\n-    fulfill_cx.register_bound(\n+    let errors = rustc_trait_selection::traits::fully_solve_bound(\n         &infcx,\n+        cause,\n         ty::ParamEnv::empty(),\n         // Erase any region vids from the type, which may not be resolved\n         infcx.tcx.erase_regions(ty),\n         into_iterator_did,\n-        cause,\n     );\n \n-    // Select all, including ambiguous predicates\n-    let errors = fulfill_cx.select_all_or_error(&infcx);\n-\n     errors.is_empty()\n }"}, {"sha": "b1a161c353637610c4d3fd3caad65ed26bb0219e", "filename": "compiler/rustc_trait_selection/src/traits/outlives_bounds.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/41e4218d2a218896d9acde3ab68d7862b56b7f54/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Foutlives_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41e4218d2a218896d9acde3ab68d7862b56b7f54/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Foutlives_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Foutlives_bounds.rs?ref=41e4218d2a218896d9acde3ab68d7862b56b7f54", "patch": "@@ -1,7 +1,7 @@\n use crate::infer::InferCtxt;\n use crate::traits::query::type_op::{self, TypeOp, TypeOpOutput};\n use crate::traits::query::NoSolution;\n-use crate::traits::{ObligationCause, TraitEngine, TraitEngineExt};\n+use crate::traits::ObligationCause;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_hir as hir;\n use rustc_hir::HirId;\n@@ -74,20 +74,20 @@ impl<'a, 'tcx: 'a> InferCtxtExt<'a, 'tcx> for InferCtxt<'tcx> {\n             debug!(?constraints);\n             // Instantiation may have produced new inference variables and constraints on those\n             // variables. Process these constraints.\n-            let mut fulfill_cx = <dyn TraitEngine<'tcx>>::new(self.tcx);\n             let cause = ObligationCause::misc(span, body_id);\n-            for &constraint in &constraints.outlives {\n-                let obligation = self.query_outlives_constraint_to_obligation(\n-                    constraint,\n-                    cause.clone(),\n-                    param_env,\n-                );\n-                fulfill_cx.register_predicate_obligation(self, obligation);\n-            }\n+            let errors = super::fully_solve_obligations(\n+                self,\n+                constraints.outlives.iter().map(|constraint| {\n+                    self.query_outlives_constraint_to_obligation(\n+                        *constraint,\n+                        cause.clone(),\n+                        param_env,\n+                    )\n+                }),\n+            );\n             if !constraints.member_constraints.is_empty() {\n                 span_bug!(span, \"{:#?}\", constraints.member_constraints);\n             }\n-            let errors = fulfill_cx.select_all_or_error(self);\n             if !errors.is_empty() {\n                 self.tcx.sess.delay_span_bug(\n                     span,"}]}