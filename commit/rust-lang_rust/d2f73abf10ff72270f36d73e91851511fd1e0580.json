{"sha": "d2f73abf10ff72270f36d73e91851511fd1e0580", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQyZjczYWJmMTBmZjcyMjcwZjM2ZDczZTkxODUxNTExZmQxZTA1ODA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-02-22T00:36:52Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-02-22T00:36:52Z"}, "message": "auto merge of #12382 : bjz/rust/fmt-int, r=alexcrichton\n\nThis is PR is the beginning of a complete rewrite and ultimate removal of the `std::num::strconv` module (see #6220), and the removal of the `ToStrRadix` trait in favour of using the `std::fmt` functionality directly. This should make for a cleaner API, encourage less allocation, and make the implementation more comprehensible .\r\n\r\nThe `Formatter::{pad_integral, with_padding}` methods have also been refactored make things easier to understand.\r\n\r\nThe formatting tests for integers have been moved out of `run-pass/ifmt.rs` in order to provide more immediate feedback when building using `make check-stage2-std NO_REBUILD=1`.\r\n\r\nArbitrary radixes are now easier to use in format strings. For example:\r\n\r\n~~~rust\r\nassert_eq!(format!(\"{:04}\", radix(3, 2)), ~\"0011\");\r\n~~~\r\n\r\nThe benchmarks have been standardised between `std::num::strconv` and `std::num::fmt` to make it easier to compare the performance of the different implementations.\r\n\r\n~~~\r\n type | radix | std::num::strconv      | std::num::fmt\r\n======|=======|========================|======================\r\n int  | bin   | 1748 ns/iter (+/- 150) | 321 ns/iter (+/- 25)\r\n int  | oct   |  706 ns/iter (+/- 53)  | 179 ns/iter (+/- 22)\r\n int  | dec   |  640 ns/iter (+/- 59)  | 207 ns/iter (+/- 10)\r\n int  | hex   |  637 ns/iter (+/- 77)  | 205 ns/iter (+/- 19)\r\n int  | 36    |  446 ns/iter (+/- 30)  | 309 ns/iter (+/- 20)\r\n------|-------|------------------------|----------------------\r\n uint | bin   | 1724 ns/iter (+/- 159) | 322 ns/iter (+/- 13)\r\n uint | oct   |  663 ns/iter (+/- 25)  | 175 ns/iter (+/- 7)\r\n uint | dec   |  613 ns/iter (+/- 30)  | 186 ns/iter (+/- 6)\r\n uint | hex   |  519 ns/iter (+/- 44)  | 207 ns/iter (+/- 20)\r\n uint | 36    |  418 ns/iter (+/- 16)  | 308 ns/iter (+/- 32)\r\n~~~", "tree": {"sha": "457abe392a3416bc600d1b167c91bbb71f5f15a9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/457abe392a3416bc600d1b167c91bbb71f5f15a9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d2f73abf10ff72270f36d73e91851511fd1e0580", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d2f73abf10ff72270f36d73e91851511fd1e0580", "html_url": "https://github.com/rust-lang/rust/commit/d2f73abf10ff72270f36d73e91851511fd1e0580", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d2f73abf10ff72270f36d73e91851511fd1e0580/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "87c7e1542c386a06a5fb1de63c36df8b95088231", "url": "https://api.github.com/repos/rust-lang/rust/commits/87c7e1542c386a06a5fb1de63c36df8b95088231", "html_url": "https://github.com/rust-lang/rust/commit/87c7e1542c386a06a5fb1de63c36df8b95088231"}, {"sha": "6943acd1a50b0c4d0d95e298c151aa796ae05269", "url": "https://api.github.com/repos/rust-lang/rust/commits/6943acd1a50b0c4d0d95e298c151aa796ae05269", "html_url": "https://github.com/rust-lang/rust/commit/6943acd1a50b0c4d0d95e298c151aa796ae05269"}], "stats": {"total": 1003, "additions": 667, "deletions": 336}, "files": [{"sha": "79f33a88562737653dfcecbe990013d9869b97a6", "filename": "src/doc/complement-cheatsheet.md", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d2f73abf10ff72270f36d73e91851511fd1e0580/src%2Fdoc%2Fcomplement-cheatsheet.md", "raw_url": "https://github.com/rust-lang/rust/raw/d2f73abf10ff72270f36d73e91851511fd1e0580/src%2Fdoc%2Fcomplement-cheatsheet.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fcomplement-cheatsheet.md?ref=d2f73abf10ff72270f36d73e91851511fd1e0580", "patch": "@@ -22,13 +22,14 @@ let y: int = x.unwrap();\n \n **Int to string, in non-base-10**\n \n-Use [`ToStrRadix`](http://static.rust-lang.org/doc/master/std/num/trait.ToStrRadix.html).\n+Use the `format!` syntax extension.\n \n ~~~\n-use std::num::ToStrRadix;\n-\n let x: int = 42;\n-let y: ~str = x.to_str_radix(16);\n+let y: ~str = format!(\"{:t}\", x);   // binary\n+let y: ~str = format!(\"{:o}\", x);   // octal\n+let y: ~str = format!(\"{:x}\", x);   // lowercase hexadecimal\n+let y: ~str = format!(\"{:X}\", x);   // uppercase hexidecimal\n ~~~\n \n **String to int, in non-base-10**"}, {"sha": "09c21d54c87a0ce3cc9d1b1652d5ca32a47e49d0", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2f73abf10ff72270f36d73e91851511fd1e0580/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2f73abf10ff72270f36d73e91851511fd1e0580/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=d2f73abf10ff72270f36d73e91851511fd1e0580", "patch": "@@ -2024,7 +2024,7 @@ impl ops::Sub<TypeContents,TypeContents> for TypeContents {\n \n impl ToStr for TypeContents {\n     fn to_str(&self) -> ~str {\n-        format!(\"TypeContents({})\", self.bits.to_str_radix(2))\n+        format!(\"TypeContents({:t})\", self.bits)\n     }\n }\n "}, {"sha": "aa3e3a23182e0ea0d1daa44fdd45cb91d9760e46", "filename": "src/librustc/middle/typeck/infer/to_str.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d2f73abf10ff72270f36d73e91851511fd1e0580/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fto_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2f73abf10ff72270f36d73e91851511fd1e0580/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fto_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fto_str.rs?ref=d2f73abf10ff72270f36d73e91851511fd1e0580", "patch": "@@ -70,8 +70,7 @@ impl<V:Vid + ToStr,T:InferStr> InferStr for VarValue<V, T> {\n     fn inf_str(&self, cx: &InferCtxt) -> ~str {\n         match *self {\n           Redirect(ref vid) => format!(\"Redirect({})\", vid.to_str()),\n-          Root(ref pt, rk) => format!(\"Root({}, {})\", pt.inf_str(cx),\n-                               rk.to_str_radix(10u))\n+          Root(ref pt, rk) => format!(\"Root({}, {})\", pt.inf_str(cx), rk)\n         }\n     }\n }"}, {"sha": "38fae798d5dde252fc0a82b1a696c0f48857fe9c", "filename": "src/libstd/fmt/mod.rs", "status": "modified", "additions": 54, "deletions": 121, "changes": 175, "blob_url": "https://github.com/rust-lang/rust/blob/d2f73abf10ff72270f36d73e91851511fd1e0580/src%2Flibstd%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2f73abf10ff72270f36d73e91851511fd1e0580/src%2Flibstd%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffmt%2Fmod.rs?ref=d2f73abf10ff72270f36d73e91851511fd1e0580", "patch": "@@ -215,7 +215,7 @@ impl fmt::Binary for Vector2D {\n         // for details, and the function `pad` can be used to pad strings.\n         let decimals = f.precision.unwrap_or(3);\n         let string = f64::to_str_exact(magnitude, decimals);\n-        f.pad_integral(string.as_bytes(), \"\", true)\n+        f.pad_integral(true, \"\", string.as_bytes())\n     }\n }\n \n@@ -493,6 +493,11 @@ use str;\n use vec::ImmutableVector;\n use vec;\n \n+pub use self::num::radix;\n+pub use self::num::Radix;\n+pub use self::num::RadixFmt;\n+\n+mod num;\n pub mod parse;\n pub mod rt;\n \n@@ -891,58 +896,60 @@ impl<'a> Formatter<'a> {\n     ///\n     /// # Arguments\n     ///\n-    ///     * s - the byte array that the number has been formatted into\n-    ///     * alternate_prefix - if the '#' character (FlagAlternate) is\n-    ///       provided, this is the prefix to put in front of the number.\n-    ///       Currently this is 0x/0o/0b/etc.\n-    ///     * positive - whether the original integer was positive or not.\n+    ///     * is_positive - whether the original integer was positive or not.\n+    ///     * prefix - if the '#' character (FlagAlternate) is provided, this\n+    ///       is the prefix to put in front of the number.\n+    ///     * buf - the byte array that the number has been formatted into\n     ///\n     /// This function will correctly account for the flags provided as well as\n     /// the minimum width. It will not take precision into account.\n-    pub fn pad_integral(&mut self, s: &[u8], alternate_prefix: &str,\n-                        positive: bool) -> Result {\n+    pub fn pad_integral(&mut self, is_positive: bool, prefix: &str, buf: &[u8]) -> Result {\n         use fmt::parse::{FlagAlternate, FlagSignPlus, FlagSignAwareZeroPad};\n \n-        let mut actual_len = s.len();\n-        if self.flags & 1 << (FlagAlternate as uint) != 0 {\n-            actual_len += alternate_prefix.len();\n-        }\n-        if self.flags & 1 << (FlagSignPlus as uint) != 0 {\n-            actual_len += 1;\n-        } else if !positive {\n-            actual_len += 1;\n+        let mut width = buf.len();\n+\n+        let mut sign = None;\n+        if !is_positive {\n+            sign = Some('-'); width += 1;\n+        } else if self.flags & (1 << (FlagSignPlus as uint)) != 0 {\n+            sign = Some('+'); width += 1;\n         }\n \n-        let mut signprinted = false;\n-        let sign = |this: &mut Formatter| {\n-            if !signprinted {\n-                if this.flags & 1 << (FlagSignPlus as uint) != 0 && positive {\n-                    try!(this.buf.write(['+' as u8]));\n-                } else if !positive {\n-                    try!(this.buf.write(['-' as u8]));\n-                }\n-                if this.flags & 1 << (FlagAlternate as uint) != 0 {\n-                    try!(this.buf.write(alternate_prefix.as_bytes()));\n-                }\n-                signprinted = true;\n-            }\n-            Ok(())\n-        };\n+        let mut prefixed = false;\n+        if self.flags & (1 << (FlagAlternate as uint)) != 0 {\n+            prefixed = true; width += prefix.len();\n+        }\n \n-        let emit = |this: &mut Formatter| {\n-            sign(this).and_then(|()| this.buf.write(s))\n+        // Writes the sign if it exists, and then the prefix if it was requested\n+        let write_prefix = |f: &mut Formatter| {\n+            for c in sign.move_iter() { try!(f.buf.write_char(c)); }\n+            if prefixed { f.buf.write_str(prefix) }\n+            else { Ok(()) }\n         };\n \n+        // The `width` field is more of a `min-width` parameter at this point.\n         match self.width {\n-            None => emit(self),\n-            Some(min) if actual_len >= min => emit(self),\n+            // If there's no minimum length requirements then we can just\n+            // write the bytes.\n+            None => {\n+                try!(write_prefix(self)); self.buf.write(buf)\n+            }\n+            // Check if we're over the minimum width, if so then we can also\n+            // just write the bytes.\n+            Some(min) if width >= min => {\n+                try!(write_prefix(self)); self.buf.write(buf)\n+            }\n+            // The sign and prefix goes before the padding if the fill character\n+            // is zero\n+            Some(min) if self.flags & (1 << (FlagSignAwareZeroPad as uint)) != 0 => {\n+                self.fill = '0';\n+                try!(write_prefix(self));\n+                self.with_padding(min - width, parse::AlignRight, |f| f.buf.write(buf))\n+            }\n+            // Otherwise, the sign and prefix goes after the padding\n             Some(min) => {\n-                if self.flags & 1 << (FlagSignAwareZeroPad as uint) != 0 {\n-                    self.fill = '0';\n-                    try!(sign(self));\n-                }\n-                self.with_padding(min - actual_len, parse::AlignRight, |me| {\n-                    emit(me)\n+                self.with_padding(min - width, parse::AlignRight, |f| {\n+                    try!(write_prefix(f)); f.buf.write(buf)\n                 })\n             }\n         }\n@@ -979,19 +986,16 @@ impl<'a> Formatter<'a> {\n             }\n             None => {}\n         }\n-\n         // The `width` field is more of a `min-width` parameter at this point.\n         match self.width {\n             // If we're under the maximum length, and there's no minimum length\n             // requirements, then we can just emit the string\n             None => self.buf.write(s.as_bytes()),\n-\n             // If we're under the maximum width, check if we're over the minimum\n             // width, if so it's as easy as just emitting the string.\n             Some(width) if s.char_len() >= width => {\n                 self.buf.write(s.as_bytes())\n             }\n-\n             // If we're under both the maximum and the minimum width, then fill\n             // up the minimum width with the specified string + some alignment.\n             Some(width) => {\n@@ -1002,6 +1006,8 @@ impl<'a> Formatter<'a> {\n         }\n     }\n \n+    /// Runs a callback, emitting the correct padding either before or\n+    /// afterwards depending on whether right or left alingment is requested.\n     fn with_padding(&mut self,\n                     padding: uint,\n                     default: parse::Alignment,\n@@ -1075,67 +1081,6 @@ impl Char for char {\n     }\n }\n \n-macro_rules! int_base(($ty:ident, $into:ident, $base:expr,\n-                       $name:ident, $prefix:expr) => {\n-    impl $name for $ty {\n-        fn fmt(&self, f: &mut Formatter) -> Result {\n-            ::$into::to_str_bytes(*self as $into, $base, |buf| {\n-                f.pad_integral(buf, $prefix, true)\n-            })\n-        }\n-    }\n-})\n-macro_rules! upper_hex(($ty:ident, $into:ident) => {\n-    impl UpperHex for $ty {\n-        fn fmt(&self, f: &mut Formatter) -> Result {\n-            ::$into::to_str_bytes(*self as $into, 16, |buf| {\n-                upperhex(buf, f)\n-            })\n-        }\n-    }\n-})\n-// Not sure why, but this causes an \"unresolved enum variant, struct or const\"\n-// when inlined into the above macro...\n-#[doc(hidden)]\n-pub fn upperhex(buf: &[u8], f: &mut Formatter) -> Result {\n-    let mut local = [0u8, ..16];\n-    for i in ::iter::range(0, buf.len()) {\n-        local[i] = match buf[i] as char {\n-            'a' .. 'f' => (buf[i] - 'a' as u8) + 'A' as u8,\n-            c => c as u8,\n-        }\n-    }\n-    f.pad_integral(local.slice_to(buf.len()), \"0x\", true)\n-}\n-\n-macro_rules! integer(($signed:ident, $unsigned:ident) => {\n-    // Signed is special because it actuall emits the negative sign,\n-    // nothing else should do that, however.\n-    impl Signed for $signed {\n-        fn fmt(&self, f: &mut Formatter) -> Result {\n-            ::$unsigned::to_str_bytes(self.abs() as $unsigned, 10, |buf| {\n-                f.pad_integral(buf, \"\", *self >= 0)\n-            })\n-        }\n-    }\n-    int_base!($signed, $unsigned, 2, Binary, \"0b\")\n-    int_base!($signed, $unsigned, 8, Octal, \"0o\")\n-    int_base!($signed, $unsigned, 16, LowerHex, \"0x\")\n-    upper_hex!($signed, $unsigned)\n-\n-    int_base!($unsigned, $unsigned, 2, Binary, \"0b\")\n-    int_base!($unsigned, $unsigned, 8, Octal, \"0o\")\n-    int_base!($unsigned, $unsigned, 10, Unsigned, \"\")\n-    int_base!($unsigned, $unsigned, 16, LowerHex, \"0x\")\n-    upper_hex!($unsigned, $unsigned)\n-})\n-\n-integer!(int, uint)\n-integer!(i8, u8)\n-integer!(i16, u16)\n-integer!(i32, u32)\n-integer!(i64, u64)\n-\n macro_rules! floating(($ty:ident) => {\n     impl Float for $ty {\n         fn fmt(&self, fmt: &mut Formatter) -> Result {\n@@ -1144,7 +1089,7 @@ macro_rules! floating(($ty:ident) => {\n                 Some(i) => ::$ty::to_str_exact(self.abs(), i),\n                 None => ::$ty::to_str_digits(self.abs(), 6)\n             };\n-            fmt.pad_integral(s.as_bytes(), \"\", *self >= 0.0)\n+            fmt.pad_integral(*self >= 0.0, \"\", s.as_bytes())\n         }\n     }\n \n@@ -1155,7 +1100,7 @@ macro_rules! floating(($ty:ident) => {\n                 Some(i) => ::$ty::to_str_exp_exact(self.abs(), i, false),\n                 None => ::$ty::to_str_exp_digits(self.abs(), 6, false)\n             };\n-            fmt.pad_integral(s.as_bytes(), \"\", *self >= 0.0)\n+            fmt.pad_integral(*self >= 0.0, \"\", s.as_bytes())\n         }\n     }\n \n@@ -1166,7 +1111,7 @@ macro_rules! floating(($ty:ident) => {\n                 Some(i) => ::$ty::to_str_exp_exact(self.abs(), i, true),\n                 None => ::$ty::to_str_exp_digits(self.abs(), 6, true)\n             };\n-            fmt.pad_integral(s.as_bytes(), \"\", *self >= 0.0)\n+            fmt.pad_integral(*self >= 0.0, \"\", s.as_bytes())\n         }\n     }\n })\n@@ -1193,9 +1138,7 @@ impl<T> Poly for T {\n impl<T> Pointer for *T {\n     fn fmt(&self, f: &mut Formatter) -> Result {\n         f.flags |= 1 << (parse::FlagAlternate as uint);\n-        ::uint::to_str_bytes(*self as uint, 16, |buf| {\n-            f.pad_integral(buf, \"0x\", true)\n-        })\n+        secret_lower_hex::<uint>(&(*self as uint), f)\n     }\n }\n impl<T> Pointer for *mut T {\n@@ -1223,16 +1166,6 @@ macro_rules! delegate(($ty:ty to $other:ident) => {\n         }\n     }\n })\n-delegate!(int to signed)\n-delegate!( i8 to signed)\n-delegate!(i16 to signed)\n-delegate!(i32 to signed)\n-delegate!(i64 to signed)\n-delegate!(uint to unsigned)\n-delegate!(  u8 to unsigned)\n-delegate!( u16 to unsigned)\n-delegate!( u32 to unsigned)\n-delegate!( u64 to unsigned)\n delegate!(~str to string)\n delegate!(&'a str to string)\n delegate!(bool to bool)"}, {"sha": "681d0678ed4953380cb2ed0aa15ebde601c05e9c", "filename": "src/libstd/fmt/num.rs", "status": "added", "additions": 467, "deletions": 0, "changes": 467, "blob_url": "https://github.com/rust-lang/rust/blob/d2f73abf10ff72270f36d73e91851511fd1e0580/src%2Flibstd%2Ffmt%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2f73abf10ff72270f36d73e91851511fd1e0580/src%2Flibstd%2Ffmt%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffmt%2Fnum.rs?ref=d2f73abf10ff72270f36d73e91851511fd1e0580", "patch": "@@ -0,0 +1,467 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Integer and floating-point number formatting\n+\n+// FIXME: #6220 Implement floating point formatting\n+\n+use container::Container;\n+use fmt;\n+use iter::{Iterator, DoubleEndedIterator};\n+use num::{Int, cast, zero};\n+use option::{Some, None};\n+use vec::{ImmutableVector, MutableVector};\n+\n+/// A type that represents a specific radix\n+trait GenericRadix {\n+    /// The number of digits.\n+    fn base(&self) -> u8;\n+\n+    /// A radix-specific prefix string.\n+    fn prefix(&self) -> &'static str { \"\" }\n+\n+    /// Converts an integer to corresponding radix digit.\n+    fn digit(&self, x: u8) -> u8;\n+\n+    /// Format an integer using the radix using a formatter.\n+    fn fmt_int<T: Int>(&self, mut x: T, f: &mut fmt::Formatter) -> fmt::Result {\n+        // The radix can be as low as 2, so we need a buffer of at least 64\n+        // characters for a base 2 number.\n+        let mut buf = [0u8, ..64];\n+        let base = cast(self.base()).unwrap();\n+        let mut curr = buf.len();\n+        let is_positive = x >= zero();\n+        if is_positive {\n+            // Accumulate each digit of the number from the least significant\n+            // to the most significant figure.\n+            for byte in buf.mut_iter().rev() {\n+                let n = x % base;                         // Get the current place value.\n+                x = x / base;                             // Deaccumulate the number.\n+                *byte = self.digit(cast(n).unwrap());     // Store the digit in the buffer.\n+                curr -= 1;\n+                if x == zero() { break; }                 // No more digits left to accumulate.\n+            }\n+        } else {\n+            // Do the same as above, but accounting for two's complement.\n+            for byte in buf.mut_iter().rev() {\n+                let n = -(x % base);                      // Get the current place value.\n+                x = x / base;                             // Deaccumulate the number.\n+                *byte = self.digit(cast(n).unwrap());     // Store the digit in the buffer.\n+                curr -= 1;\n+                if x == zero() { break; }                 // No more digits left to accumulate.\n+            }\n+        }\n+        f.pad_integral(is_positive, self.prefix(), buf.slice_from(curr))\n+    }\n+}\n+\n+/// A binary (base 2) radix\n+#[deriving(Clone, Eq)]\n+struct Binary;\n+\n+/// An octal (base 8) radix\n+#[deriving(Clone, Eq)]\n+struct Octal;\n+\n+/// A decimal (base 10) radix\n+#[deriving(Clone, Eq)]\n+struct Decimal;\n+\n+/// A hexidecimal (base 16) radix, formatted with lower-case characters\n+#[deriving(Clone, Eq)]\n+struct LowerHex;\n+\n+/// A hexidecimal (base 16) radix, formatted with upper-case characters\n+#[deriving(Clone, Eq)]\n+pub struct UpperHex;\n+\n+macro_rules! radix {\n+    ($T:ident, $base:expr, $prefix:expr, $($x:pat => $conv:expr),+) => {\n+        impl GenericRadix for $T {\n+            fn base(&self) -> u8 { $base }\n+            fn prefix(&self) -> &'static str { $prefix }\n+            fn digit(&self, x: u8) -> u8 {\n+                match x {\n+                    $($x => $conv,)+\n+                    x => fail!(\"number not in the range 0..{}: {}\", self.base() - 1, x),\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+radix!(Binary,    2, \"0b\", x @  0 .. 2 => '0' as u8 + x)\n+radix!(Octal,     8, \"0o\", x @  0 .. 7 => '0' as u8 + x)\n+radix!(Decimal,  10, \"\",   x @  0 .. 9 => '0' as u8 + x)\n+radix!(LowerHex, 16, \"0x\", x @  0 .. 9 => '0' as u8 + x,\n+                           x @ 10 ..15 => 'a' as u8 + (x - 10))\n+radix!(UpperHex, 16, \"0x\", x @  0 .. 9 => '0' as u8 + x,\n+                           x @ 10 ..15 => 'A' as u8 + (x - 10))\n+\n+/// A radix with in the range of `2..36`.\n+#[deriving(Clone, Eq)]\n+pub struct Radix {\n+    priv base: u8,\n+}\n+\n+impl Radix {\n+    fn new(base: u8) -> Radix {\n+        assert!(2 <= base && base <= 36, \"the base must be in the range of 0..36: {}\", base);\n+        Radix { base: base }\n+    }\n+}\n+\n+impl GenericRadix for Radix {\n+    fn base(&self) -> u8 { self.base }\n+    fn digit(&self, x: u8) -> u8 {\n+        match x {\n+            x @  0 ..9 => '0' as u8 + x,\n+            x if x < self.base() => 'a' as u8 + (x - 10),\n+            x => fail!(\"number not in the range 0..{}: {}\", self.base() - 1, x),\n+        }\n+    }\n+}\n+\n+/// A helper type for formatting radixes.\n+pub struct RadixFmt<T, R>(T, R);\n+\n+/// Constructs a radix formatter in the range of `2..36`.\n+///\n+/// # Example\n+///\n+/// ~~~\n+/// use std::fmt::radix;\n+/// assert_eq!(format!(\"{}\", radix(55, 36)), ~\"1j\");\n+/// ~~~\n+pub fn radix<T>(x: T, base: u8) -> RadixFmt<T, Radix> {\n+    RadixFmt(x, Radix::new(base))\n+}\n+\n+macro_rules! radix_fmt {\n+    ($T:ty as $U:ty, $fmt:ident) => {\n+        impl fmt::Show for RadixFmt<$T, Radix> {\n+            fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+                match *self { RadixFmt(ref x, radix) => radix.$fmt(*x as $U, f) }\n+            }\n+        }\n+    }\n+}\n+macro_rules! int_base {\n+    ($Trait:ident for $T:ident as $U:ident -> $Radix:ident) => {\n+        impl fmt::$Trait for $T {\n+            fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+                $Radix.fmt_int(*self as $U, f)\n+            }\n+        }\n+    }\n+}\n+macro_rules! integer {\n+    ($Int:ident, $Uint:ident) => {\n+        int_base!(Show     for $Int as $Int   -> Decimal)\n+        int_base!(Signed   for $Int as $Int   -> Decimal)\n+        int_base!(Binary   for $Int as $Uint  -> Binary)\n+        int_base!(Octal    for $Int as $Uint  -> Octal)\n+        int_base!(LowerHex for $Int as $Uint  -> LowerHex)\n+        int_base!(UpperHex for $Int as $Uint  -> UpperHex)\n+        radix_fmt!($Int as $Uint, fmt_int)\n+\n+        int_base!(Show     for $Uint as $Uint -> Decimal)\n+        int_base!(Unsigned for $Uint as $Uint -> Decimal)\n+        int_base!(Binary   for $Uint as $Uint -> Binary)\n+        int_base!(Octal    for $Uint as $Uint -> Octal)\n+        int_base!(LowerHex for $Uint as $Uint -> LowerHex)\n+        int_base!(UpperHex for $Uint as $Uint -> UpperHex)\n+        radix_fmt!($Uint as $Uint, fmt_int)\n+    }\n+}\n+integer!(int, uint)\n+integer!(i8, u8)\n+integer!(i16, u16)\n+integer!(i32, u32)\n+integer!(i64, u64)\n+\n+#[cfg(test)]\n+mod tests {\n+    use fmt::radix;\n+    use super::{Binary, Octal, Decimal, LowerHex, UpperHex};\n+    use super::{GenericRadix, Radix};\n+\n+    #[test]\n+    fn test_radix_base() {\n+        assert_eq!(Binary.base(), 2);\n+        assert_eq!(Octal.base(), 8);\n+        assert_eq!(Decimal.base(), 10);\n+        assert_eq!(LowerHex.base(), 16);\n+        assert_eq!(UpperHex.base(), 16);\n+        assert_eq!(Radix { base: 36 }.base(), 36);\n+    }\n+\n+    #[test]\n+    fn test_radix_prefix() {\n+        assert_eq!(Binary.prefix(), \"0b\");\n+        assert_eq!(Octal.prefix(), \"0o\");\n+        assert_eq!(Decimal.prefix(), \"\");\n+        assert_eq!(LowerHex.prefix(), \"0x\");\n+        assert_eq!(UpperHex.prefix(), \"0x\");\n+        assert_eq!(Radix { base: 36 }.prefix(), \"\");\n+    }\n+\n+    #[test]\n+    fn test_radix_digit() {\n+        assert_eq!(Binary.digit(0), '0' as u8);\n+        assert_eq!(Binary.digit(2), '2' as u8);\n+        assert_eq!(Octal.digit(0), '0' as u8);\n+        assert_eq!(Octal.digit(7), '7' as u8);\n+        assert_eq!(Decimal.digit(0), '0' as u8);\n+        assert_eq!(Decimal.digit(9), '9' as u8);\n+        assert_eq!(LowerHex.digit(0), '0' as u8);\n+        assert_eq!(LowerHex.digit(10), 'a' as u8);\n+        assert_eq!(LowerHex.digit(15), 'f' as u8);\n+        assert_eq!(UpperHex.digit(0), '0' as u8);\n+        assert_eq!(UpperHex.digit(10), 'A' as u8);\n+        assert_eq!(UpperHex.digit(15), 'F' as u8);\n+        assert_eq!(Radix { base: 36 }.digit(0), '0' as u8);\n+        assert_eq!(Radix { base: 36 }.digit(15), 'f' as u8);\n+        assert_eq!(Radix { base: 36 }.digit(35), 'z' as u8);\n+    }\n+\n+    #[test]\n+    #[should_fail]\n+    fn test_hex_radix_digit_overflow() {\n+        let _ = LowerHex.digit(16);\n+    }\n+\n+    #[test]\n+    fn test_format_int() {\n+        // Formatting integers should select the right implementation based off\n+        // the type of the argument. Also, hex/octal/binary should be defined\n+        // for integers, but they shouldn't emit the negative sign.\n+        assert_eq!(format!(\"{}\", 1i), ~\"1\");\n+        assert_eq!(format!(\"{}\", 1i8), ~\"1\");\n+        assert_eq!(format!(\"{}\", 1i16), ~\"1\");\n+        assert_eq!(format!(\"{}\", 1i32), ~\"1\");\n+        assert_eq!(format!(\"{}\", 1i64), ~\"1\");\n+        assert_eq!(format!(\"{:d}\", -1i), ~\"-1\");\n+        assert_eq!(format!(\"{:d}\", -1i8), ~\"-1\");\n+        assert_eq!(format!(\"{:d}\", -1i16), ~\"-1\");\n+        assert_eq!(format!(\"{:d}\", -1i32), ~\"-1\");\n+        assert_eq!(format!(\"{:d}\", -1i64), ~\"-1\");\n+        assert_eq!(format!(\"{:t}\", 1i), ~\"1\");\n+        assert_eq!(format!(\"{:t}\", 1i8), ~\"1\");\n+        assert_eq!(format!(\"{:t}\", 1i16), ~\"1\");\n+        assert_eq!(format!(\"{:t}\", 1i32), ~\"1\");\n+        assert_eq!(format!(\"{:t}\", 1i64), ~\"1\");\n+        assert_eq!(format!(\"{:x}\", 1i), ~\"1\");\n+        assert_eq!(format!(\"{:x}\", 1i8), ~\"1\");\n+        assert_eq!(format!(\"{:x}\", 1i16), ~\"1\");\n+        assert_eq!(format!(\"{:x}\", 1i32), ~\"1\");\n+        assert_eq!(format!(\"{:x}\", 1i64), ~\"1\");\n+        assert_eq!(format!(\"{:X}\", 1i), ~\"1\");\n+        assert_eq!(format!(\"{:X}\", 1i8), ~\"1\");\n+        assert_eq!(format!(\"{:X}\", 1i16), ~\"1\");\n+        assert_eq!(format!(\"{:X}\", 1i32), ~\"1\");\n+        assert_eq!(format!(\"{:X}\", 1i64), ~\"1\");\n+        assert_eq!(format!(\"{:o}\", 1i), ~\"1\");\n+        assert_eq!(format!(\"{:o}\", 1i8), ~\"1\");\n+        assert_eq!(format!(\"{:o}\", 1i16), ~\"1\");\n+        assert_eq!(format!(\"{:o}\", 1i32), ~\"1\");\n+        assert_eq!(format!(\"{:o}\", 1i64), ~\"1\");\n+\n+        assert_eq!(format!(\"{}\", 1u), ~\"1\");\n+        assert_eq!(format!(\"{}\", 1u8), ~\"1\");\n+        assert_eq!(format!(\"{}\", 1u16), ~\"1\");\n+        assert_eq!(format!(\"{}\", 1u32), ~\"1\");\n+        assert_eq!(format!(\"{}\", 1u64), ~\"1\");\n+        assert_eq!(format!(\"{:u}\", 1u), ~\"1\");\n+        assert_eq!(format!(\"{:u}\", 1u8), ~\"1\");\n+        assert_eq!(format!(\"{:u}\", 1u16), ~\"1\");\n+        assert_eq!(format!(\"{:u}\", 1u32), ~\"1\");\n+        assert_eq!(format!(\"{:u}\", 1u64), ~\"1\");\n+        assert_eq!(format!(\"{:t}\", 1u), ~\"1\");\n+        assert_eq!(format!(\"{:t}\", 1u8), ~\"1\");\n+        assert_eq!(format!(\"{:t}\", 1u16), ~\"1\");\n+        assert_eq!(format!(\"{:t}\", 1u32), ~\"1\");\n+        assert_eq!(format!(\"{:t}\", 1u64), ~\"1\");\n+        assert_eq!(format!(\"{:x}\", 1u), ~\"1\");\n+        assert_eq!(format!(\"{:x}\", 1u8), ~\"1\");\n+        assert_eq!(format!(\"{:x}\", 1u16), ~\"1\");\n+        assert_eq!(format!(\"{:x}\", 1u32), ~\"1\");\n+        assert_eq!(format!(\"{:x}\", 1u64), ~\"1\");\n+        assert_eq!(format!(\"{:X}\", 1u), ~\"1\");\n+        assert_eq!(format!(\"{:X}\", 1u8), ~\"1\");\n+        assert_eq!(format!(\"{:X}\", 1u16), ~\"1\");\n+        assert_eq!(format!(\"{:X}\", 1u32), ~\"1\");\n+        assert_eq!(format!(\"{:X}\", 1u64), ~\"1\");\n+        assert_eq!(format!(\"{:o}\", 1u), ~\"1\");\n+        assert_eq!(format!(\"{:o}\", 1u8), ~\"1\");\n+        assert_eq!(format!(\"{:o}\", 1u16), ~\"1\");\n+        assert_eq!(format!(\"{:o}\", 1u32), ~\"1\");\n+        assert_eq!(format!(\"{:o}\", 1u64), ~\"1\");\n+\n+        // Test a larger number\n+        assert_eq!(format!(\"{:t}\", 55), ~\"110111\");\n+        assert_eq!(format!(\"{:o}\", 55), ~\"67\");\n+        assert_eq!(format!(\"{:d}\", 55), ~\"55\");\n+        assert_eq!(format!(\"{:x}\", 55), ~\"37\");\n+        assert_eq!(format!(\"{:X}\", 55), ~\"37\");\n+    }\n+\n+    #[test]\n+    fn test_format_int_zero() {\n+        assert_eq!(format!(\"{}\", 0i), ~\"0\");\n+        assert_eq!(format!(\"{:d}\", 0i), ~\"0\");\n+        assert_eq!(format!(\"{:t}\", 0i), ~\"0\");\n+        assert_eq!(format!(\"{:o}\", 0i), ~\"0\");\n+        assert_eq!(format!(\"{:x}\", 0i), ~\"0\");\n+        assert_eq!(format!(\"{:X}\", 0i), ~\"0\");\n+\n+        assert_eq!(format!(\"{}\", 0u), ~\"0\");\n+        assert_eq!(format!(\"{:u}\", 0u), ~\"0\");\n+        assert_eq!(format!(\"{:t}\", 0u), ~\"0\");\n+        assert_eq!(format!(\"{:o}\", 0u), ~\"0\");\n+        assert_eq!(format!(\"{:x}\", 0u), ~\"0\");\n+        assert_eq!(format!(\"{:X}\", 0u), ~\"0\");\n+    }\n+\n+    #[test]\n+    fn test_format_int_flags() {\n+        assert_eq!(format!(\"{:3d}\", 1), ~\"  1\");\n+        assert_eq!(format!(\"{:>3d}\", 1), ~\"  1\");\n+        assert_eq!(format!(\"{:>+3d}\", 1), ~\" +1\");\n+        assert_eq!(format!(\"{:<3d}\", 1), ~\"1  \");\n+        assert_eq!(format!(\"{:#d}\", 1), ~\"1\");\n+        assert_eq!(format!(\"{:#x}\", 10), ~\"0xa\");\n+        assert_eq!(format!(\"{:#X}\", 10), ~\"0xA\");\n+        assert_eq!(format!(\"{:#5x}\", 10), ~\"  0xa\");\n+        assert_eq!(format!(\"{:#o}\", 10), ~\"0o12\");\n+        assert_eq!(format!(\"{:08x}\", 10), ~\"0000000a\");\n+        assert_eq!(format!(\"{:8x}\", 10), ~\"       a\");\n+        assert_eq!(format!(\"{:<8x}\", 10), ~\"a       \");\n+        assert_eq!(format!(\"{:>8x}\", 10), ~\"       a\");\n+        assert_eq!(format!(\"{:#08x}\", 10), ~\"0x00000a\");\n+        assert_eq!(format!(\"{:08d}\", -10), ~\"-0000010\");\n+        assert_eq!(format!(\"{:x}\", -1u8), ~\"ff\");\n+        assert_eq!(format!(\"{:X}\", -1u8), ~\"FF\");\n+        assert_eq!(format!(\"{:t}\", -1u8), ~\"11111111\");\n+        assert_eq!(format!(\"{:o}\", -1u8), ~\"377\");\n+        assert_eq!(format!(\"{:#x}\", -1u8), ~\"0xff\");\n+        assert_eq!(format!(\"{:#X}\", -1u8), ~\"0xFF\");\n+        assert_eq!(format!(\"{:#t}\", -1u8), ~\"0b11111111\");\n+        assert_eq!(format!(\"{:#o}\", -1u8), ~\"0o377\");\n+    }\n+\n+    #[test]\n+    fn test_format_int_sign_padding() {\n+        assert_eq!(format!(\"{:+5d}\", 1), ~\"   +1\");\n+        assert_eq!(format!(\"{:+5d}\", -1), ~\"   -1\");\n+        assert_eq!(format!(\"{:05d}\", 1), ~\"00001\");\n+        assert_eq!(format!(\"{:05d}\", -1), ~\"-0001\");\n+        assert_eq!(format!(\"{:+05d}\", 1), ~\"+0001\");\n+        assert_eq!(format!(\"{:+05d}\", -1), ~\"-0001\");\n+    }\n+\n+    #[test]\n+    fn test_format_int_twos_complement() {\n+        use {i8, i16, i32, i64};\n+        assert_eq!(format!(\"{}\", i8::MIN), ~\"-128\");\n+        assert_eq!(format!(\"{}\", i16::MIN), ~\"-32768\");\n+        assert_eq!(format!(\"{}\", i32::MIN), ~\"-2147483648\");\n+        assert_eq!(format!(\"{}\", i64::MIN), ~\"-9223372036854775808\");\n+    }\n+\n+    #[test]\n+    fn test_format_radix() {\n+        assert_eq!(format!(\"{:04}\", radix(3, 2)), ~\"0011\");\n+        assert_eq!(format!(\"{}\", radix(55, 36)), ~\"1j\");\n+    }\n+\n+    #[test]\n+    #[should_fail]\n+    fn test_radix_base_too_large() {\n+        let _ = radix(55, 37);\n+    }\n+}\n+\n+#[cfg(test)]\n+mod bench {\n+    extern crate test;\n+\n+    mod uint {\n+        use super::test::BenchHarness;\n+        use fmt::radix;\n+        use rand::{XorShiftRng, Rng};\n+\n+        #[bench]\n+        fn format_bin(bh: &mut BenchHarness) {\n+            let mut rng = XorShiftRng::new();\n+            bh.iter(|| { format!(\"{:t}\", rng.gen::<uint>()); })\n+        }\n+\n+        #[bench]\n+        fn format_oct(bh: &mut BenchHarness) {\n+            let mut rng = XorShiftRng::new();\n+            bh.iter(|| { format!(\"{:o}\", rng.gen::<uint>()); })\n+        }\n+\n+        #[bench]\n+        fn format_dec(bh: &mut BenchHarness) {\n+            let mut rng = XorShiftRng::new();\n+            bh.iter(|| { format!(\"{:u}\", rng.gen::<uint>()); })\n+        }\n+\n+        #[bench]\n+        fn format_hex(bh: &mut BenchHarness) {\n+            let mut rng = XorShiftRng::new();\n+            bh.iter(|| { format!(\"{:x}\", rng.gen::<uint>()); })\n+        }\n+\n+        #[bench]\n+        fn format_base_36(bh: &mut BenchHarness) {\n+            let mut rng = XorShiftRng::new();\n+            bh.iter(|| { format!(\"{}\", radix(rng.gen::<uint>(), 36)); })\n+        }\n+    }\n+\n+    mod int {\n+        use super::test::BenchHarness;\n+        use fmt::radix;\n+        use rand::{XorShiftRng, Rng};\n+\n+        #[bench]\n+        fn format_bin(bh: &mut BenchHarness) {\n+            let mut rng = XorShiftRng::new();\n+            bh.iter(|| { format!(\"{:t}\", rng.gen::<int>()); })\n+        }\n+\n+        #[bench]\n+        fn format_oct(bh: &mut BenchHarness) {\n+            let mut rng = XorShiftRng::new();\n+            bh.iter(|| { format!(\"{:o}\", rng.gen::<int>()); })\n+        }\n+\n+        #[bench]\n+        fn format_dec(bh: &mut BenchHarness) {\n+            let mut rng = XorShiftRng::new();\n+            bh.iter(|| { format!(\"{:d}\", rng.gen::<int>()); })\n+        }\n+\n+        #[bench]\n+        fn format_hex(bh: &mut BenchHarness) {\n+            let mut rng = XorShiftRng::new();\n+            bh.iter(|| { format!(\"{:x}\", rng.gen::<int>()); })\n+        }\n+\n+        #[bench]\n+        fn format_base_36(bh: &mut BenchHarness) {\n+            let mut rng = XorShiftRng::new();\n+            bh.iter(|| { format!(\"{}\", radix(rng.gen::<int>(), 36)); })\n+        }\n+    }\n+}"}, {"sha": "432e27257f355fe9f3e9ce5f250e9447059dab01", "filename": "src/libstd/hash.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d2f73abf10ff72270f36d73e91851511fd1e0580/src%2Flibstd%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2f73abf10ff72270f36d73e91851511fd1e0580/src%2Flibstd%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fhash.rs?ref=d2f73abf10ff72270f36d73e91851511fd1e0580", "patch": "@@ -29,7 +29,6 @@\n use container::Container;\n use io::{Writer, IoResult};\n use iter::Iterator;\n-use num::ToStrRadix;\n use option::{Some, None};\n use result::Ok;\n use str::OwnedStr;\n@@ -281,7 +280,7 @@ impl Streaming for SipState {\n         let r = self.result_bytes();\n         let mut s = ~\"\";\n         for b in r.iter() {\n-            s.push_str((*b as uint).to_str_radix(16u));\n+            s.push_str(format!(\"{:x}\", *b));\n         }\n         s\n     }\n@@ -391,7 +390,7 @@ mod tests {\n         fn to_hex_str(r: &[u8, ..8]) -> ~str {\n             let mut s = ~\"\";\n             for b in r.iter() {\n-                s.push_str((*b as uint).to_str_radix(16u));\n+                s.push_str(format!(\"{:x}\", *b));\n             }\n             s\n         }"}, {"sha": "f09dc3da9bfe9d31c0edca2f133cb4de72c52fec", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d2f73abf10ff72270f36d73e91851511fd1e0580/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2f73abf10ff72270f36d73e91851511fd1e0580/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=d2f73abf10ff72270f36d73e91851511fd1e0580", "patch": "@@ -857,12 +857,12 @@ pub trait Writer {\n \n     /// Write the result of passing n through `int::to_str_bytes`.\n     fn write_int(&mut self, n: int) -> IoResult<()> {\n-        int::to_str_bytes(n, 10u, |bytes| self.write(bytes))\n+        write!(self, \"{:d}\", n)\n     }\n \n     /// Write the result of passing n through `uint::to_str_bytes`.\n     fn write_uint(&mut self, n: uint) -> IoResult<()> {\n-        uint::to_str_bytes(n, 10u, |bytes| self.write(bytes))\n+        write!(self, \"{:u}\", n)\n     }\n \n     /// Write a little-endian uint (number of bytes depends on system)."}, {"sha": "43a7019081207c0defb921484750b4a0365693cf", "filename": "src/libstd/num/int_macros.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2f73abf10ff72270f36d73e91851511fd1e0580/src%2Flibstd%2Fnum%2Fint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2f73abf10ff72270f36d73e91851511fd1e0580/src%2Flibstd%2Fnum%2Fint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fint_macros.rs?ref=d2f73abf10ff72270f36d73e91851511fd1e0580", "patch": "@@ -277,7 +277,7 @@ impl ToStr for $T {\n     /// Convert to a string in base 10.\n     #[inline]\n     fn to_str(&self) -> ~str {\n-        self.to_str_radix(10)\n+        format!(\"{:d}\", *self)\n     }\n }\n "}, {"sha": "b23e42ad1c6892dd204655247d8393841360bc7b", "filename": "src/libstd/num/mod.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d2f73abf10ff72270f36d73e91851511fd1e0580/src%2Flibstd%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2f73abf10ff72270f36d73e91851511fd1e0580/src%2Flibstd%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fmod.rs?ref=d2f73abf10ff72270f36d73e91851511fd1e0580", "patch": "@@ -17,10 +17,12 @@\n \n use clone::{Clone, DeepClone};\n use cmp::{Eq, Ord};\n+use kinds::Pod;\n use mem::size_of;\n use ops::{Add, Sub, Mul, Div, Rem, Neg};\n use ops::{Not, BitAnd, BitOr, BitXor, Shl, Shr};\n use option::{Option, Some, None};\n+use fmt::{Show, Binary, Octal, LowerHex, UpperHex};\n \n pub mod strconv;\n \n@@ -243,7 +245,8 @@ pub trait Bitwise: Bounded\n /// Specifies the available operations common to all of Rust's core numeric primitives.\n /// These may not always make sense from a purely mathematical point of view, but\n /// may be useful for systems programming.\n-pub trait Primitive: Clone\n+pub trait Primitive: Pod\n+                   + Clone\n                    + DeepClone\n                    + Num\n                    + NumCast\n@@ -256,7 +259,12 @@ pub trait Int: Primitive\n              + CheckedAdd\n              + CheckedSub\n              + CheckedMul\n-             + CheckedDiv {}\n+             + CheckedDiv\n+             + Show\n+             + Binary\n+             + Octal\n+             + LowerHex\n+             + UpperHex {}\n \n /// Returns the smallest power of 2 greater than or equal to `n`.\n #[inline]"}, {"sha": "153c042c6a8c16acfa63ca875106cb25e2da4e6a", "filename": "src/libstd/num/strconv.rs", "status": "modified", "additions": 81, "deletions": 17, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/d2f73abf10ff72270f36d73e91851511fd1e0580/src%2Flibstd%2Fnum%2Fstrconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2f73abf10ff72270f36d73e91851511fd1e0580/src%2Flibstd%2Fnum%2Fstrconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fstrconv.rs?ref=d2f73abf10ff72270f36d73e91851511fd1e0580", "patch": "@@ -792,24 +792,88 @@ mod test {\n #[cfg(test)]\n mod bench {\n     extern crate test;\n-    use self::test::BenchHarness;\n-    use rand::{XorShiftRng, Rng};\n-    use to_str::ToStr;\n-    use f64;\n-\n-    #[bench]\n-    fn uint_to_str_rand(bh: &mut BenchHarness) {\n-        let mut rng = XorShiftRng::new();\n-        bh.iter(|| {\n-            rng.gen::<uint>().to_str();\n-        })\n+\n+    mod uint {\n+        use super::test::BenchHarness;\n+        use rand::{XorShiftRng, Rng};\n+        use num::ToStrRadix;\n+\n+        #[bench]\n+        fn to_str_bin(bh: &mut BenchHarness) {\n+            let mut rng = XorShiftRng::new();\n+            bh.iter(|| { rng.gen::<uint>().to_str_radix(2); })\n+        }\n+\n+        #[bench]\n+        fn to_str_oct(bh: &mut BenchHarness) {\n+            let mut rng = XorShiftRng::new();\n+            bh.iter(|| { rng.gen::<uint>().to_str_radix(8); })\n+        }\n+\n+        #[bench]\n+        fn to_str_dec(bh: &mut BenchHarness) {\n+            let mut rng = XorShiftRng::new();\n+            bh.iter(|| { rng.gen::<uint>().to_str_radix(10); })\n+        }\n+\n+        #[bench]\n+        fn to_str_hex(bh: &mut BenchHarness) {\n+            let mut rng = XorShiftRng::new();\n+            bh.iter(|| { rng.gen::<uint>().to_str_radix(16); })\n+        }\n+\n+        #[bench]\n+        fn to_str_base_36(bh: &mut BenchHarness) {\n+            let mut rng = XorShiftRng::new();\n+            bh.iter(|| { rng.gen::<uint>().to_str_radix(36); })\n+        }\n     }\n \n-    #[bench]\n-    fn float_to_str_rand(bh: &mut BenchHarness) {\n-        let mut rng = XorShiftRng::new();\n-        bh.iter(|| {\n-            f64::to_str(rng.gen());\n-        })\n+    mod int {\n+        use super::test::BenchHarness;\n+        use rand::{XorShiftRng, Rng};\n+        use num::ToStrRadix;\n+\n+        #[bench]\n+        fn to_str_bin(bh: &mut BenchHarness) {\n+            let mut rng = XorShiftRng::new();\n+            bh.iter(|| { rng.gen::<int>().to_str_radix(2); })\n+        }\n+\n+        #[bench]\n+        fn to_str_oct(bh: &mut BenchHarness) {\n+            let mut rng = XorShiftRng::new();\n+            bh.iter(|| { rng.gen::<int>().to_str_radix(8); })\n+        }\n+\n+        #[bench]\n+        fn to_str_dec(bh: &mut BenchHarness) {\n+            let mut rng = XorShiftRng::new();\n+            bh.iter(|| { rng.gen::<int>().to_str_radix(10); })\n+        }\n+\n+        #[bench]\n+        fn to_str_hex(bh: &mut BenchHarness) {\n+            let mut rng = XorShiftRng::new();\n+            bh.iter(|| { rng.gen::<int>().to_str_radix(16); })\n+        }\n+\n+        #[bench]\n+        fn to_str_base_36(bh: &mut BenchHarness) {\n+            let mut rng = XorShiftRng::new();\n+            bh.iter(|| { rng.gen::<int>().to_str_radix(36); })\n+        }\n+    }\n+\n+    mod f64 {\n+        use super::test::BenchHarness;\n+        use rand::{XorShiftRng, Rng};\n+        use f64;\n+\n+        #[bench]\n+        fn float_to_str(bh: &mut BenchHarness) {\n+            let mut rng = XorShiftRng::new();\n+            bh.iter(|| { f64::to_str(rng.gen()); })\n+        }\n     }\n }"}, {"sha": "d60b523544601b4c6a846d649dc3b4c2a417d074", "filename": "src/libstd/num/uint_macros.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2f73abf10ff72270f36d73e91851511fd1e0580/src%2Flibstd%2Fnum%2Fuint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2f73abf10ff72270f36d73e91851511fd1e0580/src%2Flibstd%2Fnum%2Fuint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fuint_macros.rs?ref=d2f73abf10ff72270f36d73e91851511fd1e0580", "patch": "@@ -191,7 +191,7 @@ impl ToStr for $T {\n     /// Convert to a string in base 10.\n     #[inline]\n     fn to_str(&self) -> ~str {\n-        self.to_str_radix(10u)\n+        format!(\"{:u}\", *self)\n     }\n }\n "}, {"sha": "680ac11230021b8a377d54e20959f42d22a1fa27", "filename": "src/libstd/repr.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d2f73abf10ff72270f36d73e91851511fd1e0580/src%2Flibstd%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2f73abf10ff72270f36d73e91851511fd1e0580/src%2Flibstd%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frepr.rs?ref=d2f73abf10ff72270f36d73e91851511fd1e0580", "patch": "@@ -60,19 +60,13 @@ impl Repr for bool {\n \n impl Repr for int {\n     fn write_repr(&self, writer: &mut io::Writer) -> io::IoResult<()> {\n-        ::int::to_str_bytes(*self, 10u, |bits| {\n-            writer.write(bits)\n-        })\n+        write!(writer, \"{}\", *self)\n     }\n }\n \n macro_rules! int_repr(($ty:ident, $suffix:expr) => (impl Repr for $ty {\n     fn write_repr(&self, writer: &mut io::Writer) -> io::IoResult<()> {\n-        ::$ty::to_str_bytes(*self, 10u, |bits| {\n-            writer.write(bits).and_then(|()| {\n-                writer.write(bytes!($suffix))\n-            })\n-        })\n+        write!(writer, \"{}{}\", *self, $suffix)\n     }\n }))\n "}, {"sha": "3b1386021d23209801f95dc779cdb7076b22bdf7", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 3, "deletions": 18, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/d2f73abf10ff72270f36d73e91851511fd1e0580/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2f73abf10ff72270f36d73e91851511fd1e0580/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=d2f73abf10ff72270f36d73e91851511fd1e0580", "patch": "@@ -2267,29 +2267,14 @@ pub fn print_literal(s: &mut State, lit: &ast::Lit) -> io::IoResult<()> {\n           word(&mut s.s, res)\n       }\n       ast::LitInt(i, t) => {\n-        if i < 0_i64 {\n-            word(&mut s.s,\n-                 ~\"-\" + (-i as u64).to_str_radix(10u)\n-                 + ast_util::int_ty_to_str(t))\n-        } else {\n-            word(&mut s.s,\n-                 (i as u64).to_str_radix(10u)\n-                 + ast_util::int_ty_to_str(t))\n-        }\n+        word(&mut s.s, format!(\"{}{}\", i, ast_util::int_ty_to_str(t)))\n       }\n       ast::LitUint(u, t) => {\n-        word(&mut s.s,\n-             u.to_str_radix(10u)\n-             + ast_util::uint_ty_to_str(t))\n+        word(&mut s.s, format!(\"{}{}\", u, ast_util::uint_ty_to_str(t)))\n       }\n       ast::LitIntUnsuffixed(i) => {\n-        if i < 0_i64 {\n-            word(&mut s.s, ~\"-\" + (-i as u64).to_str_radix(10u))\n-        } else {\n-            word(&mut s.s, (i as u64).to_str_radix(10u))\n-        }\n+        word(&mut s.s, format!(\"{}\", i))\n       }\n-\n       ast::LitFloat(ref f, t) => {\n         word(&mut s.s, f.get() + ast_util::float_ty_to_str(t))\n       }"}, {"sha": "948e79b4481052e583383dd465f631aee58349e8", "filename": "src/libterm/terminfo/parm.rs", "status": "modified", "additions": 37, "deletions": 57, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/d2f73abf10ff72270f36d73e91851511fd1e0580/src%2Flibterm%2Fterminfo%2Fparm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2f73abf10ff72270f36d73e91851511fd1e0580/src%2Flibterm%2Fterminfo%2Fparm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fterminfo%2Fparm.rs?ref=d2f73abf10ff72270f36d73e91851511fd1e0580", "patch": "@@ -12,7 +12,6 @@\n \n use std::{char, vec};\n use std::mem::replace;\n-use std::num::strconv::{SignNone,SignNeg,SignAll,int_to_str_bytes_common};\n \n #[deriving(Eq)]\n enum States {\n@@ -480,68 +479,49 @@ impl FormatOp {\n fn format(val: Param, op: FormatOp, flags: Flags) -> Result<~[u8],~str> {\n     let mut s = match val {\n         Number(d) => {\n+            let mut s = match (op, flags.sign) {\n+                (FormatDigit, true)  => format!(\"{:+d}\", d).into_bytes(),\n+                (FormatDigit, false) => format!(\"{:d}\", d).into_bytes(),\n+                (FormatOctal, _)     => format!(\"{:o}\", d).into_bytes(),\n+                (FormatHex, _)       => format!(\"{:x}\", d).into_bytes(),\n+                (FormatHEX, _)       => format!(\"{:X}\", d).into_bytes(),\n+                (FormatString, _)    => return Err(~\"non-number on stack with %s\"),\n+            };\n+            if flags.precision > s.len() {\n+                let mut s_ = vec::with_capacity(flags.precision);\n+                let n = flags.precision - s.len();\n+                s_.grow(n, &('0' as u8));\n+                s_.push_all_move(s);\n+                s = s_;\n+            }\n+            assert!(!s.is_empty(), \"string conversion produced empty result\");\n             match op {\n-                FormatString => {\n-                    return Err(~\"non-number on stack with %s\")\n+                FormatDigit => {\n+                    if flags.space && !(s[0] == '-' as u8 || s[0] == '+' as u8) {\n+                        s.unshift(' ' as u8);\n+                    }\n                 }\n-                _ => {\n-                    let radix = match op {\n-                        FormatDigit => 10,\n-                        FormatOctal => 8,\n-                        FormatHex|FormatHEX => 16,\n-                        FormatString => unreachable!()\n-                    };\n-                    let mut s = ~[];\n-                    match op {\n-                        FormatDigit => {\n-                            let sign = if flags.sign { SignAll } else { SignNeg };\n-                            int_to_str_bytes_common(d, radix, sign, |c| {\n-                                s.push(c);\n-                            })\n-                        }\n-                        _ => {\n-                            int_to_str_bytes_common(d as uint, radix, SignNone, |c| {\n-                                s.push(c);\n-                            })\n-                        }\n-                    };\n-                    if flags.precision > s.len() {\n-                        let mut s_ = vec::with_capacity(flags.precision);\n-                        let n = flags.precision - s.len();\n-                        s_.grow(n, &('0' as u8));\n-                        s_.push_all_move(s);\n-                        s = s_;\n+                FormatOctal => {\n+                    if flags.alternate && s[0] != '0' as u8 {\n+                        s.unshift('0' as u8);\n                     }\n-                    assert!(!s.is_empty(), \"string conversion produced empty result\");\n-                    match op {\n-                        FormatDigit => {\n-                            if flags.space && !(s[0] == '-' as u8 || s[0] == '+' as u8) {\n-                                s.unshift(' ' as u8);\n-                            }\n-                        }\n-                        FormatOctal => {\n-                            if flags.alternate && s[0] != '0' as u8 {\n-                                s.unshift('0' as u8);\n-                            }\n-                        }\n-                        FormatHex => {\n-                            if flags.alternate {\n-                                let s_ = replace(&mut s, ~['0' as u8, 'x' as u8]);\n-                                s.push_all_move(s_);\n-                            }\n-                        }\n-                        FormatHEX => {\n-                            s = s.into_ascii().to_upper().into_bytes();\n-                            if flags.alternate {\n-                                let s_ = replace(&mut s, ~['0' as u8, 'X' as u8]);\n-                                s.push_all_move(s_);\n-                            }\n-                        }\n-                        FormatString => unreachable!()\n+                }\n+                FormatHex => {\n+                    if flags.alternate {\n+                        let s_ = replace(&mut s, ~['0' as u8, 'x' as u8]);\n+                        s.push_all_move(s_);\n+                    }\n+                }\n+                FormatHEX => {\n+                    s = s.into_ascii().to_upper().into_bytes();\n+                    if flags.alternate {\n+                        let s_ = replace(&mut s, ~['0' as u8, 'X' as u8]);\n+                        s.push_all_move(s_);\n                     }\n-                    s\n                 }\n+                FormatString => unreachable!()\n             }\n+            s\n         }\n         String(s) => {\n             match op {"}, {"sha": "ca798a77a4fd12387e1eb9f891b05300e69603f0", "filename": "src/test/run-pass/ifmt.rs", "status": "modified", "additions": 0, "deletions": 99, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/d2f73abf10ff72270f36d73e91851511fd1e0580/src%2Ftest%2Frun-pass%2Fifmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2f73abf10ff72270f36d73e91851511fd1e0580/src%2Ftest%2Frun-pass%2Fifmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fifmt.rs?ref=d2f73abf10ff72270f36d73e91851511fd1e0580", "patch": "@@ -36,7 +36,6 @@ impl fmt::Signed for B {\n macro_rules! t(($a:expr, $b:expr) => { assert_eq!($a, $b.to_owned()) })\n \n pub fn main() {\n-\n     // Make sure there's a poly formatter that takes anything\n     t!(format!(\"{:?}\", 1), \"1\");\n     t!(format!(\"{:?}\", A), \"A\");\n@@ -49,16 +48,6 @@ pub fn main() {\n     t!(format!(\"hello \\\\{\"), \"hello {\");\n \n     // default formatters should work\n-    t!(format!(\"{}\", 1i), \"1\");\n-    t!(format!(\"{}\", 1i8), \"1\");\n-    t!(format!(\"{}\", 1i16), \"1\");\n-    t!(format!(\"{}\", 1i32), \"1\");\n-    t!(format!(\"{}\", 1i64), \"1\");\n-    t!(format!(\"{}\", 1u), \"1\");\n-    t!(format!(\"{}\", 1u8), \"1\");\n-    t!(format!(\"{}\", 1u16), \"1\");\n-    t!(format!(\"{}\", 1u32), \"1\");\n-    t!(format!(\"{}\", 1u64), \"1\");\n     t!(format!(\"{}\", 1.0f32), \"1\");\n     t!(format!(\"{}\", 1.0f64), \"1\");\n     t!(format!(\"{}\", \"a\"), \"a\");\n@@ -126,94 +115,6 @@ pub fn main() {\n     t!(format!(\"{:-#s}\", \"a\"), \"a\");\n     t!(format!(\"{:+#s}\", \"a\"), \"a\");\n \n-    // Formatting integers should select the right implementation based off the\n-    // type of the argument. Also, hex/octal/binary should be defined for\n-    // integers, but they shouldn't emit the negative sign.\n-    t!(format!(\"{:d}\", -1i), \"-1\");\n-    t!(format!(\"{:d}\", -1i8), \"-1\");\n-    t!(format!(\"{:d}\", -1i16), \"-1\");\n-    t!(format!(\"{:d}\", -1i32), \"-1\");\n-    t!(format!(\"{:d}\", -1i64), \"-1\");\n-    t!(format!(\"{:t}\", 1i), \"1\");\n-    t!(format!(\"{:t}\", 1i8), \"1\");\n-    t!(format!(\"{:t}\", 1i16), \"1\");\n-    t!(format!(\"{:t}\", 1i32), \"1\");\n-    t!(format!(\"{:t}\", 1i64), \"1\");\n-    t!(format!(\"{:x}\", 1i), \"1\");\n-    t!(format!(\"{:x}\", 1i8), \"1\");\n-    t!(format!(\"{:x}\", 1i16), \"1\");\n-    t!(format!(\"{:x}\", 1i32), \"1\");\n-    t!(format!(\"{:x}\", 1i64), \"1\");\n-    t!(format!(\"{:X}\", 1i), \"1\");\n-    t!(format!(\"{:X}\", 1i8), \"1\");\n-    t!(format!(\"{:X}\", 1i16), \"1\");\n-    t!(format!(\"{:X}\", 1i32), \"1\");\n-    t!(format!(\"{:X}\", 1i64), \"1\");\n-    t!(format!(\"{:o}\", 1i), \"1\");\n-    t!(format!(\"{:o}\", 1i8), \"1\");\n-    t!(format!(\"{:o}\", 1i16), \"1\");\n-    t!(format!(\"{:o}\", 1i32), \"1\");\n-    t!(format!(\"{:o}\", 1i64), \"1\");\n-\n-    t!(format!(\"{:u}\", 1u), \"1\");\n-    t!(format!(\"{:u}\", 1u8), \"1\");\n-    t!(format!(\"{:u}\", 1u16), \"1\");\n-    t!(format!(\"{:u}\", 1u32), \"1\");\n-    t!(format!(\"{:u}\", 1u64), \"1\");\n-    t!(format!(\"{:t}\", 1u), \"1\");\n-    t!(format!(\"{:t}\", 1u8), \"1\");\n-    t!(format!(\"{:t}\", 1u16), \"1\");\n-    t!(format!(\"{:t}\", 1u32), \"1\");\n-    t!(format!(\"{:t}\", 1u64), \"1\");\n-    t!(format!(\"{:x}\", 1u), \"1\");\n-    t!(format!(\"{:x}\", 1u8), \"1\");\n-    t!(format!(\"{:x}\", 1u16), \"1\");\n-    t!(format!(\"{:x}\", 1u32), \"1\");\n-    t!(format!(\"{:x}\", 1u64), \"1\");\n-    t!(format!(\"{:X}\", 1u), \"1\");\n-    t!(format!(\"{:X}\", 1u8), \"1\");\n-    t!(format!(\"{:X}\", 1u16), \"1\");\n-    t!(format!(\"{:X}\", 1u32), \"1\");\n-    t!(format!(\"{:X}\", 1u64), \"1\");\n-    t!(format!(\"{:o}\", 1u), \"1\");\n-    t!(format!(\"{:o}\", 1u8), \"1\");\n-    t!(format!(\"{:o}\", 1u16), \"1\");\n-    t!(format!(\"{:o}\", 1u32), \"1\");\n-    t!(format!(\"{:o}\", 1u64), \"1\");\n-\n-    // Test the flags for formatting integers\n-    t!(format!(\"{:3d}\", 1),  \"  1\");\n-    t!(format!(\"{:>3d}\", 1),  \"  1\");\n-    t!(format!(\"{:>+3d}\", 1), \" +1\");\n-    t!(format!(\"{:<3d}\", 1), \"1  \");\n-    t!(format!(\"{:#d}\", 1), \"1\");\n-    t!(format!(\"{:#x}\", 10), \"0xa\");\n-    t!(format!(\"{:#X}\", 10), \"0xA\");\n-    t!(format!(\"{:#5x}\", 10), \"  0xa\");\n-    t!(format!(\"{:#o}\", 10), \"0o12\");\n-    t!(format!(\"{:08x}\", 10),  \"0000000a\");\n-    t!(format!(\"{:8x}\", 10),   \"       a\");\n-    t!(format!(\"{:<8x}\", 10),  \"a       \");\n-    t!(format!(\"{:>8x}\", 10),  \"       a\");\n-    t!(format!(\"{:#08x}\", 10), \"0x00000a\");\n-    t!(format!(\"{:08d}\", -10), \"-0000010\");\n-    t!(format!(\"{:x}\", -1u8), \"ff\");\n-    t!(format!(\"{:X}\", -1u8), \"FF\");\n-    t!(format!(\"{:t}\", -1u8), \"11111111\");\n-    t!(format!(\"{:o}\", -1u8), \"377\");\n-    t!(format!(\"{:#x}\", -1u8), \"0xff\");\n-    t!(format!(\"{:#X}\", -1u8), \"0xFF\");\n-    t!(format!(\"{:#t}\", -1u8), \"0b11111111\");\n-    t!(format!(\"{:#o}\", -1u8), \"0o377\");\n-\n-    // Signed combinations\n-    t!(format!(\"{:+5d}\", 1),  \"   +1\");\n-    t!(format!(\"{:+5d}\", -1), \"   -1\");\n-    t!(format!(\"{:05d}\", 1),   \"00001\");\n-    t!(format!(\"{:05d}\", -1),  \"-0001\");\n-    t!(format!(\"{:+05d}\", 1),  \"+0001\");\n-    t!(format!(\"{:+05d}\", -1), \"-0001\");\n-\n     // Some float stuff\n     t!(format!(\"{:f}\", 1.0f32), \"1\");\n     t!(format!(\"{:f}\", 1.0f64), \"1\");"}]}