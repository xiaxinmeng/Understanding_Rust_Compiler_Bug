{"sha": "c41a039c56de183468fc5b428e61e2522991fd35", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM0MWEwMzljNTZkZTE4MzQ2OGZjNWI0MjhlNjFlMjUyMjk5MWZkMzU=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2020-09-09T06:58:29Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2020-09-17T15:29:19Z"}, "message": "patch --extern and --emit; test suite passes now!", "tree": {"sha": "aff8e0cd9f099e2c54bcbdf3113a41db5fec8e5f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/aff8e0cd9f099e2c54bcbdf3113a41db5fec8e5f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c41a039c56de183468fc5b428e61e2522991fd35", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c41a039c56de183468fc5b428e61e2522991fd35", "html_url": "https://github.com/rust-lang/rust/commit/c41a039c56de183468fc5b428e61e2522991fd35", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c41a039c56de183468fc5b428e61e2522991fd35/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7ee2729824f1922d361c54a8d43e04190b513fc5", "url": "https://api.github.com/repos/rust-lang/rust/commits/7ee2729824f1922d361c54a8d43e04190b513fc5", "html_url": "https://github.com/rust-lang/rust/commit/7ee2729824f1922d361c54a8d43e04190b513fc5"}], "stats": {"total": 135, "additions": 90, "deletions": 45}, "files": [{"sha": "bf27195d5392f2534dbd5bb25eb9812d7e9a3c95", "filename": "cargo-miri/bin.rs", "status": "modified", "additions": 73, "deletions": 25, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/c41a039c56de183468fc5b428e61e2522991fd35/cargo-miri%2Fbin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c41a039c56de183468fc5b428e61e2522991fd35/cargo-miri%2Fbin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/cargo-miri%2Fbin.rs?ref=c41a039c56de183468fc5b428e61e2522991fd35", "patch": "@@ -47,14 +47,14 @@ enum MiriCommand {\n #[derive(Serialize, Deserialize)]\n struct CrateRunInfo {\n     /// The command-line arguments.\n-    args: Vec<OsString>,\n+    args: Vec<String>,\n     /// The environment.\n     env: Vec<(OsString, OsString)>,\n }\n \n impl CrateRunInfo {\n     /// Gather all the information we need.\n-    fn collect(args: env::ArgsOs) -> Self {\n+    fn collect(args: env::Args) -> Self {\n         let args = args.collect();\n         let env = env::vars_os().collect();\n         CrateRunInfo { args, env }\n@@ -362,11 +362,11 @@ path = \"lib.rs\"\n     }\n }\n \n-fn phase_cargo_miri(mut args: env::ArgsOs) {\n+fn phase_cargo_miri(mut args: env::Args) {\n     // Require a subcommand before any flags.\n     // We cannot know which of those flags take arguments and which do not,\n     // so we cannot detect subcommands later.\n-    let subcommand = match args.next().as_deref().and_then(|s| s.to_str()) {\n+    let subcommand = match args.next().as_deref() {\n         Some(\"test\") => MiriCommand::Test,\n         Some(\"run\") => MiriCommand::Run,\n         Some(\"setup\") => MiriCommand::Setup,\n@@ -423,12 +423,12 @@ fn phase_cargo_miri(mut args: env::ArgsOs) {\n     // Run cargo.\n     if verbose {\n         cmd.env(\"MIRI_VERBOSE\", \"\"); // this makes `inside_cargo_rustc` verbose.\n-        eprintln!(\"+ {:?}\", cmd);\n+        eprintln!(\"[cargo-miri miri] {:?}\", cmd);\n     }\n     exec(cmd)\n }\n \n-fn phase_cargo_rustc(args: env::ArgsOs) {\n+fn phase_cargo_rustc(args: env::Args) {\n     /// Determines if we are being invoked (as rustc) to build a crate for\n     /// the \"target\" architecture, in contrast to the \"host\" architecture.\n     /// Host crates are for build scripts and proc macros and still need to\n@@ -473,19 +473,41 @@ fn phase_cargo_rustc(args: env::ArgsOs) {\n             // (and cargo passes this before the filename so it should be unique)\n             get_arg_flag_value(\"extra-filename\").unwrap_or(String::new()),\n         ));\n+        if verbose {\n+            eprintln!(\"[cargo-miri rustc] writing run info to {:?}\", path.display());\n+        }\n \n         let file = File::create(&path)\n-            .unwrap_or_else(|_| show_error(format!(\"Cannot create {}\", path.display())));\n+            .unwrap_or_else(|_| show_error(format!(\"Cannot create {:?}\", path.display())));\n         let file = BufWriter::new(file);\n         serde_json::ser::to_writer(file, &info)\n-            .unwrap_or_else(|_| show_error(format!(\"Cannot write to {}\", path.display())));\n+            .unwrap_or_else(|_| show_error(format!(\"Cannot write to {:?}\", path.display())));\n         return;\n     }\n \n     let mut cmd = miri();\n-    // Forward arguments.\n-    cmd.args(args);\n-    // FIXME: Make the build check-only!\n+    // Forward arguments, but (only for target crates!) remove \"link\" from \"--emit\" to make this a check-only build.\n+    let emit_flag = \"--emit\";\n+    for arg in args {\n+        if target_crate && arg.starts_with(emit_flag) {\n+            // Patch this argument. First, extract its value.\n+            let val = &arg[emit_flag.len()..];\n+            assert!(val.starts_with(\"=\"), \"`cargo` should pass `--emit=X` as one argument\");\n+            let val = &val[1..];\n+            let mut val: Vec<_> = val.split(',').collect();\n+            // Now make sure \"link\" is not in there, but \"metadata\" is.\n+            if let Some(i) = val.iter().position(|&s| s == \"link\") {\n+                val.remove(i);\n+                if !val.iter().any(|&s| s == \"metadata\") {\n+                    val.push(\"metadata\");\n+                }\n+            }\n+            cmd.arg(format!(\"{}={}\", emit_flag, val.join(\",\")));\n+            // FIXME: due to this, the `.rlib` file does not get created and cargo re-triggers the build each time.\n+        } else {\n+            cmd.arg(arg);\n+        }\n+    }\n \n     // We make sure to only specify our custom Xargo sysroot for target crates - that is,\n     // crates which are needed for interpretation by Miri. proc-macros and build scripts\n@@ -503,36 +525,60 @@ fn phase_cargo_rustc(args: env::ArgsOs) {\n \n     // Run it.\n     if verbose {\n-        eprintln!(\"+ {:?}\", cmd);\n+        eprintln!(\"[cargo-miri rustc] {:?}\", cmd);\n     }\n     exec(cmd)\n }\n \n-fn phase_cargo_runner(binary: &str, args: env::ArgsOs) {\n+fn phase_cargo_runner(binary: &str, binary_args: env::Args) {\n     let verbose = std::env::var_os(\"MIRI_VERBOSE\").is_some();\n \n     let file = File::open(binary)\n-        .unwrap_or_else(|_| show_error(format!(\"File {:?} not found, or cargo-miri invoked incorrectly\", binary)));\n+        .unwrap_or_else(|_| show_error(format!(\"File {:?} not found or `cargo-miri` invoked incorrectly; please only invoke this binary through `cargo miri`\", binary)));\n     let file = BufReader::new(file);\n     let info: CrateRunInfo = serde_json::from_reader(file)\n         .unwrap_or_else(|_| show_error(format!(\"File {:?} does not contain valid JSON\", binary)));\n-    // FIXME: remove the file.\n+    fs::remove_file(binary)\n+        .unwrap_or_else(|_| show_error(format!(\"Unable to remove file {:?}\", binary)));\n \n     let mut cmd = miri();\n-    // Forward rustc arguments,with our sysroot.\n-    cmd.args(info.args);\n+    // Forward rustc arguments. We need to patch \"--extern\" filenames because\n+    // we forced a check-only build without cargo knowing about that: replace `.rlib` suffix by `.rmeta`.\n+    let mut args = info.args.into_iter();\n+    let extern_flag = \"--extern\";\n+    while let Some(arg) = args.next() {\n+        if arg == extern_flag {\n+            let next_arg = args.next().expect(\"`--extern` should be followed by a filename\");\n+            let next_arg = next_arg.strip_suffix(\".rlib\").expect(\"all extern filenames should end in `.rlib`\");\n+            cmd.arg(extern_flag);\n+            cmd.arg(format!(\"{}.rmeta\", next_arg));\n+        } else {\n+            cmd.arg(arg);\n+        }\n+    }\n+    // Set sysroot.\n     let sysroot =\n         env::var_os(\"MIRI_SYSROOT\").expect(\"The wrapper should have set MIRI_SYSROOT\");\n     cmd.arg(\"--sysroot\");\n     cmd.arg(sysroot);\n+    // Respect `MIRIFLAGS`.\n+    if let Ok(a) = env::var(\"MIRIFLAGS\") {\n+        // This code is taken from `RUSTFLAGS` handling in cargo.\n+        let args = a\n+                .split(' ')\n+                .map(str::trim)\n+                .filter(|s| !s.is_empty())\n+                .map(str::to_string);\n+        cmd.args(args);\n+    }\n \n     // Then pass binary arguments.\n     cmd.arg(\"--\");\n-    cmd.args(args);\n+    cmd.args(binary_args);\n \n     // Run it.\n     if verbose {\n-        eprintln!(\"+ {:?}\", cmd);\n+        eprintln!(\"[cargo-miri runner] {:?}\", cmd);\n     }\n     exec(cmd)\n }\n@@ -548,7 +594,9 @@ fn main() {\n         return;\n     }\n \n-    let mut args = std::env::args_os();\n+    // Rustc does not support non-UTF-8 arguments so we make no attempt either.\n+    // (We do support non-UTF-8 environment variables though.)\n+    let mut args = std::env::args();\n     // Skip binary name.\n     args.next().unwrap();\n \n@@ -559,10 +607,10 @@ fn main() {\n     //   binary crates for later interpretation.\n     // - When we are executed due to CARGO_TARGET_RUNNER, we start interpretation based on the\n     //   flags that were stored earlier.\n-    // FIXME: report errors for these unwraps.\n-    match &*args.next().unwrap().to_str().unwrap() {\n-        \"miri\" => phase_cargo_miri(args),\n-        \"rustc\" => phase_cargo_rustc(args),\n-        binary => phase_cargo_runner(binary, args),\n+    match args.next().as_deref() {\n+        Some(\"miri\") => phase_cargo_miri(args),\n+        Some(\"rustc\") => phase_cargo_rustc(args),\n+        Some(binary) => phase_cargo_runner(binary, args),\n+        _ => show_error(format!(\"`cargo-miri` called without first argument; please only invoke this binary through `cargo miri`\")),\n     }\n }"}, {"sha": "6a28f1b403e8fefc670bf73897f975e09f5d32aa", "filename": "test-cargo-miri/run-test.py", "status": "modified", "additions": 15, "deletions": 10, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/c41a039c56de183468fc5b428e61e2522991fd35/test-cargo-miri%2Frun-test.py", "raw_url": "https://github.com/rust-lang/rust/raw/c41a039c56de183468fc5b428e61e2522991fd35/test-cargo-miri%2Frun-test.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/test-cargo-miri%2Frun-test.py?ref=c41a039c56de183468fc5b428e61e2522991fd35", "patch": "@@ -21,13 +21,16 @@ def cargo_miri(cmd):\n         args += [\"--target\", os.environ['MIRI_TEST_TARGET']]\n     return args\n \n-def test(name, cmd, stdout_ref, stderr_ref):\n+def test(name, cmd, stdout_ref, stderr_ref, env={}):\n     print(\"==> Testing `{}` <==\".format(name))\n     ## Call `cargo miri`, capture all output\n+    p_env = os.environ.copy()\n+    p_env.update(env)\n     p = subprocess.Popen(\n         cmd,\n         stdout=subprocess.PIPE,\n-        stderr=subprocess.PIPE\n+        stderr=subprocess.PIPE,\n+        env=p_env,\n     )\n     (stdout, stderr) = p.communicate()\n     stdout = stdout.decode(\"UTF-8\")\n@@ -55,29 +58,31 @@ def test_cargo_miri_run():\n         \"stdout.ref\", \"stderr.ref\"\n     )\n     test(\"cargo miri run (with arguments)\",\n-        cargo_miri(\"run\") + [\"--\", \"--\", \"hello world\", '\"hello world\"'],\n+        cargo_miri(\"run\") + [\"--\", \"hello world\", '\"hello world\"'],\n         \"stdout.ref\", \"stderr.ref2\"\n     )\n \n def test_cargo_miri_test():\n     test(\"cargo miri test\",\n-        cargo_miri(\"test\") + [\"--\", \"-Zmiri-seed=feed\"],\n-        \"test.stdout.ref\", \"test.stderr.ref\"\n+        cargo_miri(\"test\"),\n+        \"test.stdout.ref\", \"test.stderr.ref\",\n+        env={'MIRIFLAGS': \"-Zmiri-seed=feed\"},\n     )\n     test(\"cargo miri test (with filter)\",\n-        cargo_miri(\"test\") + [\"--\", \"--\", \"le1\"],\n+        cargo_miri(\"test\") + [\"--\", \"--format=pretty\", \"le1\"],\n         \"test.stdout.ref2\", \"test.stderr.ref\"\n     )\n     test(\"cargo miri test (without isolation)\",\n-        cargo_miri(\"test\") + [\"--\", \"-Zmiri-disable-isolation\", \"--\", \"num_cpus\"],\n-        \"test.stdout.ref3\", \"test.stderr.ref\"\n+        cargo_miri(\"test\") + [\"--\", \"--format=pretty\", \"num_cpus\"],\n+        \"test.stdout.ref3\", \"test.stderr.ref\",\n+        env={'MIRIFLAGS': \"-Zmiri-disable-isolation\"},\n     )\n     test(\"cargo miri test (test target)\",\n-        cargo_miri(\"test\") + [\"--test\", \"test\"],\n+        cargo_miri(\"test\") + [\"--test\", \"test\", \"--\", \"--format=pretty\"],\n         \"test.stdout.ref4\", \"test.stderr.ref\"\n     )\n     test(\"cargo miri test (bin target)\",\n-        cargo_miri(\"test\") + [\"--bin\", \"cargo-miri-test\"],\n+        cargo_miri(\"test\") + [\"--bin\", \"cargo-miri-test\", \"--\", \"--format=pretty\"],\n         \"test.stdout.ref5\", \"test.stderr.ref\"\n     )\n "}, {"sha": "fa78cd35487839f7141c0aec5afe419e81fd5188", "filename": "test-cargo-miri/test.stdout.ref", "status": "modified", "additions": 2, "deletions": 10, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c41a039c56de183468fc5b428e61e2522991fd35/test-cargo-miri%2Ftest.stdout.ref", "raw_url": "https://github.com/rust-lang/rust/raw/c41a039c56de183468fc5b428e61e2522991fd35/test-cargo-miri%2Ftest.stdout.ref", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/test-cargo-miri%2Ftest.stdout.ref?ref=c41a039c56de183468fc5b428e61e2522991fd35", "patch": "@@ -1,18 +1,10 @@\n \n running 1 test\n-test test::rng ... ok\n-\n+.\n test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out\n \n \n running 7 tests\n-test do_panic ... ok\n-test does_not_work_on_miri ... ignored\n-test entropy_rng ... ok\n-test fail_index_check ... ok\n-test num_cpus ... ok\n-test simple1 ... ok\n-test simple2 ... ok\n-\n+.i.....\n test result: ok. 6 passed; 0 failed; 1 ignored; 0 measured; 0 filtered out\n "}]}