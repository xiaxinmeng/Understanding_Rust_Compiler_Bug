{"sha": "329e487e582cba7ae1eaa444b0d004cee94ae7c3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMyOWU0ODdlNTgyY2JhN2FlMWVhYTQ0NGIwZDAwNGNlZTk0YWU3YzM=", "commit": {"author": {"name": "Eli Friedman", "email": "eli.friedman@gmail.com", "date": "2015-10-24T02:20:03Z"}, "committer": {"name": "Eli Friedman", "email": "eli.friedman@gmail.com", "date": "2015-10-28T03:09:10Z"}, "message": "Start pushing panics outward in lexer.", "tree": {"sha": "50ad1a6a5d43807e543daeadb87cbb0c22014113", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/50ad1a6a5d43807e543daeadb87cbb0c22014113"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/329e487e582cba7ae1eaa444b0d004cee94ae7c3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/329e487e582cba7ae1eaa444b0d004cee94ae7c3", "html_url": "https://github.com/rust-lang/rust/commit/329e487e582cba7ae1eaa444b0d004cee94ae7c3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/329e487e582cba7ae1eaa444b0d004cee94ae7c3/comments", "author": {"login": "eefriedman", "id": 12769964, "node_id": "MDQ6VXNlcjEyNzY5OTY0", "avatar_url": "https://avatars.githubusercontent.com/u/12769964?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eefriedman", "html_url": "https://github.com/eefriedman", "followers_url": "https://api.github.com/users/eefriedman/followers", "following_url": "https://api.github.com/users/eefriedman/following{/other_user}", "gists_url": "https://api.github.com/users/eefriedman/gists{/gist_id}", "starred_url": "https://api.github.com/users/eefriedman/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eefriedman/subscriptions", "organizations_url": "https://api.github.com/users/eefriedman/orgs", "repos_url": "https://api.github.com/users/eefriedman/repos", "events_url": "https://api.github.com/users/eefriedman/events{/privacy}", "received_events_url": "https://api.github.com/users/eefriedman/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eefriedman", "id": 12769964, "node_id": "MDQ6VXNlcjEyNzY5OTY0", "avatar_url": "https://avatars.githubusercontent.com/u/12769964?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eefriedman", "html_url": "https://github.com/eefriedman", "followers_url": "https://api.github.com/users/eefriedman/followers", "following_url": "https://api.github.com/users/eefriedman/following{/other_user}", "gists_url": "https://api.github.com/users/eefriedman/gists{/gist_id}", "starred_url": "https://api.github.com/users/eefriedman/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eefriedman/subscriptions", "organizations_url": "https://api.github.com/users/eefriedman/orgs", "repos_url": "https://api.github.com/users/eefriedman/repos", "events_url": "https://api.github.com/users/eefriedman/events{/privacy}", "received_events_url": "https://api.github.com/users/eefriedman/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "de95857129a8bdcc623f57f669b535ddf8a8db6e", "url": "https://api.github.com/repos/rust-lang/rust/commits/de95857129a8bdcc623f57f669b535ddf8a8db6e", "html_url": "https://github.com/rust-lang/rust/commit/de95857129a8bdcc623f57f669b535ddf8a8db6e"}], "stats": {"total": 72, "additions": 38, "deletions": 34}, "files": [{"sha": "e5e2c3a986db374b76b03711b51daf16f9eabbee", "filename": "src/libsyntax/parse/lexer/comments.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/329e487e582cba7ae1eaa444b0d004cee94ae7c3/src%2Flibsyntax%2Fparse%2Flexer%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329e487e582cba7ae1eaa444b0d004cee94ae7c3/src%2Flibsyntax%2Fparse%2Flexer%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fcomments.rs?ref=329e487e582cba7ae1eaa444b0d004cee94ae7c3", "patch": "@@ -270,7 +270,7 @@ fn read_block_comment(rdr: &mut StringReader,\n         while level > 0 {\n             debug!(\"=== block comment level {}\", level);\n             if rdr.is_eof() {\n-                rdr.fatal(\"unterminated block comment\");\n+                panic!(rdr.fatal(\"unterminated block comment\"));\n             }\n             if rdr.curr_is('\\n') {\n                 trim_whitespace_prefix_and_push_line(&mut lines,"}, {"sha": "9e38ffe7f0dc423c062fa15803c42cb89d26afbc", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 37, "deletions": 33, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/329e487e582cba7ae1eaa444b0d004cee94ae7c3/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/329e487e582cba7ae1eaa444b0d004cee94ae7c3/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=329e487e582cba7ae1eaa444b0d004cee94ae7c3", "patch": "@@ -11,6 +11,7 @@\n use ast;\n use codemap::{BytePos, CharPos, CodeMap, Pos, Span};\n use codemap;\n+use diagnostic::FatalError;\n use diagnostic::SpanHandler;\n use ext::tt::transcribe::tt_next_token;\n use parse::token::str_to_ident;\n@@ -30,7 +31,7 @@ pub trait Reader {\n     fn is_eof(&self) -> bool;\n     fn next_token(&mut self) -> TokenAndSpan;\n     /// Report a fatal error with the current span.\n-    fn fatal(&self, &str) -> !;\n+    fn fatal(&self, &str) -> FatalError;\n     /// Report a non-fatal error with the current span.\n     fn err(&self, &str);\n     fn peek(&self) -> TokenAndSpan;\n@@ -86,7 +87,7 @@ impl<'a> Reader for StringReader<'a> {\n         self.advance_token();\n         ret_val\n     }\n-    fn fatal(&self, m: &str) -> ! {\n+    fn fatal(&self, m: &str) -> FatalError {\n         self.fatal_span(self.peek_span, m)\n     }\n     fn err(&self, m: &str) {\n@@ -110,8 +111,8 @@ impl<'a> Reader for TtReader<'a> {\n         debug!(\"TtReader: r={:?}\", r);\n         r\n     }\n-    fn fatal(&self, m: &str) -> ! {\n-        panic!(self.sp_diag.span_fatal(self.cur_span, m));\n+    fn fatal(&self, m: &str) -> FatalError {\n+        self.sp_diag.span_fatal(self.cur_span, m)\n     }\n     fn err(&self, m: &str) {\n         self.sp_diag.span_err(self.cur_span, m);\n@@ -163,8 +164,8 @@ impl<'a> StringReader<'a> {\n     }\n \n     /// Report a fatal lexical error with a given span.\n-    pub fn fatal_span(&self, sp: Span, m: &str) -> ! {\n-        panic!(self.span_diagnostic.span_fatal(sp, m))\n+    pub fn fatal_span(&self, sp: Span, m: &str) -> FatalError {\n+        self.span_diagnostic.span_fatal(sp, m)\n     }\n \n     /// Report a lexical error with a given span.\n@@ -178,7 +179,7 @@ impl<'a> StringReader<'a> {\n     }\n \n     /// Report a fatal error spanning [`from_pos`, `to_pos`).\n-    fn fatal_span_(&self, from_pos: BytePos, to_pos: BytePos, m: &str) -> ! {\n+    fn fatal_span_(&self, from_pos: BytePos, to_pos: BytePos, m: &str) -> FatalError {\n         self.fatal_span(codemap::mk_sp(from_pos, to_pos), m)\n     }\n \n@@ -194,11 +195,11 @@ impl<'a> StringReader<'a> {\n \n     /// Report a lexical error spanning [`from_pos`, `to_pos`), appending an\n     /// escaped character to the error message\n-    fn fatal_span_char(&self, from_pos: BytePos, to_pos: BytePos, m: &str, c: char) -> ! {\n+    fn fatal_span_char(&self, from_pos: BytePos, to_pos: BytePos, m: &str, c: char) -> FatalError {\n         let mut m = m.to_string();\n         m.push_str(\": \");\n         for c in c.escape_default() { m.push(c) }\n-        self.fatal_span_(from_pos, to_pos, &m[..]);\n+        self.fatal_span_(from_pos, to_pos, &m[..])\n     }\n \n     /// Report a lexical error spanning [`from_pos`, `to_pos`), appending an\n@@ -212,12 +213,12 @@ impl<'a> StringReader<'a> {\n \n     /// Report a lexical error spanning [`from_pos`, `to_pos`), appending the\n     /// offending string to the error message\n-    fn fatal_span_verbose(&self, from_pos: BytePos, to_pos: BytePos, mut m: String) -> ! {\n+    fn fatal_span_verbose(&self, from_pos: BytePos, to_pos: BytePos, mut m: String) -> FatalError {\n         m.push_str(\": \");\n         let from = self.byte_offset(from_pos).to_usize();\n         let to = self.byte_offset(to_pos).to_usize();\n         m.push_str(&self.source_text[from..to]);\n-        self.fatal_span_(from_pos, to_pos, &m[..]);\n+        self.fatal_span_(from_pos, to_pos, &m[..])\n     }\n \n     /// Advance peek_tok and peek_span to refer to the next token, and\n@@ -538,7 +539,7 @@ impl<'a> StringReader<'a> {\n                     \"unterminated block comment\"\n                 };\n                 let last_bpos = self.last_pos;\n-                self.fatal_span_(start_bpos, last_bpos, msg);\n+                panic!(self.fatal_span_(start_bpos, last_bpos, msg));\n             }\n             let n = self.curr.unwrap();\n             match n {\n@@ -682,7 +683,9 @@ impl<'a> StringReader<'a> {\n         for _ in 0..n_digits {\n             if self.is_eof() {\n                 let last_bpos = self.last_pos;\n-                self.fatal_span_(start_bpos, last_bpos, \"unterminated numeric character escape\");\n+                panic!(self.fatal_span_(start_bpos,\n+                                        last_bpos,\n+                                        \"unterminated numeric character escape\"));\n             }\n             if self.curr_is(delim) {\n                 let last_bpos = self.last_pos;\n@@ -835,15 +838,15 @@ impl<'a> StringReader<'a> {\n             let c = match self.curr {\n                 Some(c) => c,\n                 None => {\n-                    self.fatal_span_(start_bpos, self.last_pos,\n-                                     \"unterminated unicode escape (found EOF)\");\n+                    panic!(self.fatal_span_(start_bpos, self.last_pos,\n+                                            \"unterminated unicode escape (found EOF)\"));\n                 }\n             };\n             accum_int *= 16;\n             accum_int += c.to_digit(16).unwrap_or_else(|| {\n                 if c == delim {\n-                    self.fatal_span_(self.last_pos, self.pos,\n-                                     \"unterminated unicode escape (needed a `}`)\");\n+                    panic!(self.fatal_span_(self.last_pos, self.pos,\n+                                            \"unterminated unicode escape (needed a `}`)\"));\n                 } else {\n                     self.err_span_char(self.last_pos, self.pos,\n                                    \"invalid character in unicode escape\", c);\n@@ -1077,12 +1080,12 @@ impl<'a> StringReader<'a> {\n             let valid = self.scan_char_or_byte(start, c2, /* ascii_only = */ false, '\\'');\n             if !self.curr_is('\\'') {\n                 let last_bpos = self.last_pos;\n-                self.fatal_span_verbose(\n+                panic!(self.fatal_span_verbose(\n                                    // Byte offsetting here is okay because the\n                                    // character before position `start` is an\n                                    // ascii single quote.\n                                    start - BytePos(1), last_bpos,\n-                                   \"unterminated character constant\".to_string());\n+                                   \"unterminated character constant\".to_string()));\n             }\n             let id = if valid { self.name_from(start) } else { token::intern(\"0\") };\n             self.bump(); // advance curr past token\n@@ -1107,7 +1110,9 @@ impl<'a> StringReader<'a> {\n             while !self.curr_is('\"') {\n                 if self.is_eof() {\n                     let last_bpos = self.last_pos;\n-                    self.fatal_span_(start_bpos, last_bpos, \"unterminated double quote string\");\n+                    panic!(self.fatal_span_(start_bpos,\n+                                            last_bpos,\n+                                            \"unterminated double quote string\"));\n                 }\n \n                 let ch_start = self.last_pos;\n@@ -1133,14 +1138,14 @@ impl<'a> StringReader<'a> {\n \n             if self.is_eof() {\n                 let last_bpos = self.last_pos;\n-                self.fatal_span_(start_bpos, last_bpos, \"unterminated raw string\");\n+                panic!(self.fatal_span_(start_bpos, last_bpos, \"unterminated raw string\"));\n             } else if !self.curr_is('\"') {\n                 let last_bpos = self.last_pos;\n                 let curr_char = self.curr.unwrap();\n-                self.fatal_span_char(start_bpos, last_bpos,\n+                panic!(self.fatal_span_char(start_bpos, last_bpos,\n                                 \"found invalid character; \\\n                                  only `#` is allowed in raw string delimitation\",\n-                                curr_char);\n+                                curr_char));\n             }\n             self.bump();\n             let content_start_bpos = self.last_pos;\n@@ -1149,7 +1154,7 @@ impl<'a> StringReader<'a> {\n             'outer: loop {\n                 if self.is_eof() {\n                     let last_bpos = self.last_pos;\n-                    self.fatal_span_(start_bpos, last_bpos, \"unterminated raw string\");\n+                    panic!(self.fatal_span_(start_bpos, last_bpos, \"unterminated raw string\"));\n                 }\n                 //if self.curr_is('\"') {\n                     //content_end_bpos = self.last_pos;\n@@ -1218,7 +1223,7 @@ impl<'a> StringReader<'a> {\n           c => {\n               let last_bpos = self.last_pos;\n               let bpos = self.pos;\n-              self.fatal_span_char(last_bpos, bpos, \"unknown start of token\", c);\n+              panic!(self.fatal_span_char(last_bpos, bpos, \"unknown start of token\", c));\n           }\n         }\n     }\n@@ -1271,9 +1276,9 @@ impl<'a> StringReader<'a> {\n             // character before position `start` are an\n             // ascii single quote and ascii 'b'.\n             let last_pos = self.last_pos;\n-            self.fatal_span_verbose(\n+            panic!(self.fatal_span_verbose(\n                 start - BytePos(2), last_pos,\n-                \"unterminated byte constant\".to_string());\n+                \"unterminated byte constant\".to_string()));\n         }\n \n         let id = if valid { self.name_from(start) } else { token::intern(\"?\") };\n@@ -1293,8 +1298,7 @@ impl<'a> StringReader<'a> {\n         while !self.curr_is('\"') {\n             if self.is_eof() {\n                 let last_pos = self.last_pos;\n-                self.fatal_span_(start, last_pos,\n-                                  \"unterminated double quote byte string\");\n+                panic!(self.fatal_span_(start, last_pos, \"unterminated double quote byte string\"));\n             }\n \n             let ch_start = self.last_pos;\n@@ -1318,14 +1322,14 @@ impl<'a> StringReader<'a> {\n \n         if self.is_eof() {\n             let last_pos = self.last_pos;\n-            self.fatal_span_(start_bpos, last_pos, \"unterminated raw string\");\n+            panic!(self.fatal_span_(start_bpos, last_pos, \"unterminated raw string\"));\n         } else if !self.curr_is('\"') {\n             let last_pos = self.last_pos;\n             let ch = self.curr.unwrap();\n-            self.fatal_span_char(start_bpos, last_pos,\n+            panic!(self.fatal_span_char(start_bpos, last_pos,\n                             \"found invalid character; \\\n                              only `#` is allowed in raw string delimitation\",\n-                            ch);\n+                            ch));\n         }\n         self.bump();\n         let content_start_bpos = self.last_pos;\n@@ -1334,7 +1338,7 @@ impl<'a> StringReader<'a> {\n             match self.curr {\n                 None => {\n                     let last_pos = self.last_pos;\n-                    self.fatal_span_(start_bpos, last_pos, \"unterminated raw string\")\n+                    panic!(self.fatal_span_(start_bpos, last_pos, \"unterminated raw string\"))\n                 },\n                 Some('\"') => {\n                     content_end_bpos = self.last_pos;"}]}