{"sha": "39e6ae2dccdea270ef70aa7eecdd87252a5c36f2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM5ZTZhZTJkY2NkZWEyNzBlZjcwYWE3ZWVjZGQ4NzI1MmE1YzM2ZjI=", "commit": {"author": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-12-14T09:59:41Z"}, "committer": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-12-19T20:57:02Z"}, "message": "Clean up `get_traits_containing_item`.", "tree": {"sha": "a35a97d00e0a11abffc6d58134c975764857a9cf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a35a97d00e0a11abffc6d58134c975764857a9cf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/39e6ae2dccdea270ef70aa7eecdd87252a5c36f2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/39e6ae2dccdea270ef70aa7eecdd87252a5c36f2", "html_url": "https://github.com/rust-lang/rust/commit/39e6ae2dccdea270ef70aa7eecdd87252a5c36f2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/39e6ae2dccdea270ef70aa7eecdd87252a5c36f2/comments", "author": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8d9ba291f54e45cb4d12a066850680241efa25f5", "url": "https://api.github.com/repos/rust-lang/rust/commits/8d9ba291f54e45cb4d12a066850680241efa25f5", "html_url": "https://github.com/rust-lang/rust/commit/8d9ba291f54e45cb4d12a066850680241efa25f5"}], "stats": {"total": 92, "additions": 42, "deletions": 50}, "files": [{"sha": "fb28b45d20e5a59b719f300555e9746f2b915146", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 42, "deletions": 50, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/39e6ae2dccdea270ef70aa7eecdd87252a5c36f2/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39e6ae2dccdea270ef70aa7eecdd87252a5c36f2/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=39e6ae2dccdea270ef70aa7eecdd87252a5c36f2", "patch": "@@ -2863,72 +2863,64 @@ impl<'a> Resolver<'a> {\n     fn get_traits_containing_item(&mut self, name: Name) -> Vec<TraitCandidate> {\n         debug!(\"(getting traits containing item) looking for '{}'\", name);\n \n-        fn add_trait_info(found_traits: &mut Vec<TraitCandidate>,\n-                          trait_def_id: DefId,\n-                          import_id: Option<NodeId>,\n-                          name: Name) {\n-            debug!(\"(adding trait info) found trait {:?} for method '{}'\",\n-                   trait_def_id,\n-                   name);\n-            found_traits.push(TraitCandidate {\n-                def_id: trait_def_id,\n-                import_id: import_id,\n-            });\n-        }\n-\n         let mut found_traits = Vec::new();\n         // Look for the current trait.\n         if let Some((trait_def_id, _)) = self.current_trait_ref {\n             if self.trait_item_map.contains_key(&(name, trait_def_id)) {\n-                add_trait_info(&mut found_traits, trait_def_id, None, name);\n+                found_traits.push(TraitCandidate { def_id: trait_def_id, import_id: None });\n             }\n         }\n \n         let mut search_module = self.current_module;\n         loop {\n-            // Look for trait children.\n-            let mut search_in_module = |this: &mut Self, module: Module<'a>| {\n-                let mut traits = module.traits.borrow_mut();\n-                if traits.is_none() {\n-                    let mut collected_traits = Vec::new();\n-                    module.for_each_child(|name, ns, binding| {\n-                        if ns != TypeNS { return }\n-                        if let Def::Trait(_) = binding.def() {\n-                            collected_traits.push((name, binding));\n-                        }\n-                    });\n-                    *traits = Some(collected_traits.into_boxed_slice());\n-                }\n-\n-                for &(trait_name, binding) in traits.as_ref().unwrap().iter() {\n-                    let trait_def_id = binding.def().def_id();\n-                    if this.trait_item_map.contains_key(&(name, trait_def_id)) {\n-                        let mut import_id = None;\n-                        if let NameBindingKind::Import { directive, .. } = binding.kind {\n-                            let id = directive.id;\n-                            this.maybe_unused_trait_imports.insert(id);\n-                            this.add_to_glob_map(id, trait_name);\n-                            import_id = Some(id);\n-                        }\n-                        add_trait_info(&mut found_traits, trait_def_id, import_id, name);\n-                    }\n-                }\n-            };\n-            search_in_module(self, search_module);\n+            self.get_traits_in_module_containing_item(name, search_module, &mut found_traits);\n+            match search_module.kind {\n+                ModuleKind::Block(..) => search_module = search_module.parent.unwrap(),\n+                _ => break,\n+            }\n+        }\n \n-            if let ModuleKind::Block(..) = search_module.kind {\n-                search_module = search_module.parent.unwrap();\n-            } else {\n-                if !search_module.no_implicit_prelude {\n-                    self.prelude.map(|prelude| search_in_module(self, prelude));\n-                }\n-                break;\n+        if let Some(prelude) = self.prelude {\n+            if !search_module.no_implicit_prelude {\n+                self.get_traits_in_module_containing_item(name, prelude, &mut found_traits);\n             }\n         }\n \n         found_traits\n     }\n \n+    fn get_traits_in_module_containing_item(&mut self,\n+                                            name: Name,\n+                                            module: Module,\n+                                            found_traits: &mut Vec<TraitCandidate>) {\n+        let mut traits = module.traits.borrow_mut();\n+        if traits.is_none() {\n+            let mut collected_traits = Vec::new();\n+            module.for_each_child(|name, ns, binding| {\n+                if ns != TypeNS { return }\n+                if let Def::Trait(_) = binding.def() {\n+                    collected_traits.push((name, binding));\n+                }\n+            });\n+            *traits = Some(collected_traits.into_boxed_slice());\n+        }\n+\n+        for &(trait_name, binding) in traits.as_ref().unwrap().iter() {\n+            let trait_def_id = binding.def().def_id();\n+            if self.trait_item_map.contains_key(&(name, trait_def_id)) {\n+                let import_id = match binding.kind {\n+                    NameBindingKind::Import { directive, .. } => {\n+                        self.maybe_unused_trait_imports.insert(directive.id);\n+                        self.add_to_glob_map(directive.id, trait_name);\n+                        Some(directive.id)\n+                    }\n+                    _ => None,\n+                };\n+                found_traits.push(TraitCandidate { def_id: trait_def_id, import_id: import_id });\n+            }\n+        }\n+    }\n+\n     /// When name resolution fails, this method can be used to look up candidate\n     /// entities with the expected name. It allows filtering them using the\n     /// supplied predicate (which should be used to only accept the types of"}]}