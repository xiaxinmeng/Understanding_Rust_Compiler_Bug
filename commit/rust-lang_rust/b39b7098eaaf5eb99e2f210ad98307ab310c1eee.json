{"sha": "b39b7098eaaf5eb99e2f210ad98307ab310c1eee", "node_id": "C_kwDOAAsO6NoAKGIzOWI3MDk4ZWFhZjVlYjk5ZTJmMjEwYWQ5ODMwN2FiMzEwYzFlZWU", "commit": {"author": {"name": "Nicholas Nethercote", "email": "n.nethercote@gmail.com", "date": "2023-05-24T00:08:40Z"}, "committer": {"name": "Nicholas Nethercote", "email": "n.nethercote@gmail.com", "date": "2023-05-24T02:25:58Z"}, "message": "Remove the `merging` module.\n\nThree of the four methods in `DefaultPartitioning` are defined in\n`default.rs`. But `merge_codegen_units` is defined in a separate module,\n`merging`, even though it's less than 100 lines of code and roughly the\nsame size as the other three methods. (Also, the `merging` module\ncurrently sits alongside `default`, when it should be a submodule of\n`default`, adding to the confusion.)\n\nIn #74275 this explanation was given:\n\n> I pulled this out into a separate module since it seemed like we might\n> want a few different merge algorithms to choose from.\n\nBut in the three years since there have been no additional merging\nalgorithms, and there is no mechanism for choosing between different\nmerging algorithms. (There is a mechanism,\n`-Zcgu-partitioning-strategy`, for choosing between different\npartitioning strategies, but the merging algorithm is just one piece of\na partitioning strategy.)\n\nThis commit merges `merging` into `default`, making the code easier to\nnavigate and read.", "tree": {"sha": "9d88fbeff4913c0c8828f8f968bd35dade712951", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9d88fbeff4913c0c8828f8f968bd35dade712951"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b39b7098eaaf5eb99e2f210ad98307ab310c1eee", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b39b7098eaaf5eb99e2f210ad98307ab310c1eee", "html_url": "https://github.com/rust-lang/rust/commit/b39b7098eaaf5eb99e2f210ad98307ab310c1eee", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b39b7098eaaf5eb99e2f210ad98307ab310c1eee/comments", "author": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e26c0c92bda6a66a5ea2f308b28e53a0a9bfba7f", "url": "https://api.github.com/repos/rust-lang/rust/commits/e26c0c92bda6a66a5ea2f308b28e53a0a9bfba7f", "html_url": "https://github.com/rust-lang/rust/commit/e26c0c92bda6a66a5ea2f308b28e53a0a9bfba7f"}], "stats": {"total": 203, "additions": 94, "deletions": 109}, "files": [{"sha": "60f71f5dd81c49079b516bc031389e926f67fc60", "filename": "compiler/rustc_monomorphize/src/partitioning/default.rs", "status": "modified", "additions": 94, "deletions": 2, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/b39b7098eaaf5eb99e2f210ad98307ab310c1eee/compiler%2Frustc_monomorphize%2Fsrc%2Fpartitioning%2Fdefault.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b39b7098eaaf5eb99e2f210ad98307ab310c1eee/compiler%2Frustc_monomorphize%2Fsrc%2Fpartitioning%2Fdefault.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_monomorphize%2Fsrc%2Fpartitioning%2Fdefault.rs?ref=b39b7098eaaf5eb99e2f210ad98307ab310c1eee", "patch": "@@ -1,3 +1,4 @@\n+use std::cmp;\n use std::collections::hash_map::Entry;\n \n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n@@ -14,7 +15,6 @@ use rustc_span::symbol::Symbol;\n \n use super::PartitioningCx;\n use crate::collector::InliningMap;\n-use crate::partitioning::merging;\n use crate::partitioning::{\n     MonoItemPlacement, Partition, PostInliningPartitioning, PreInliningPartitioning,\n };\n@@ -103,7 +103,99 @@ impl<'tcx> Partition<'tcx> for DefaultPartitioning {\n         cx: &PartitioningCx<'_, 'tcx>,\n         initial_partitioning: &mut PreInliningPartitioning<'tcx>,\n     ) {\n-        merging::merge_codegen_units(cx, initial_partitioning);\n+        assert!(cx.target_cgu_count >= 1);\n+        let codegen_units = &mut initial_partitioning.codegen_units;\n+\n+        // Note that at this point in time the `codegen_units` here may not be\n+        // in a deterministic order (but we know they're deterministically the\n+        // same set). We want this merging to produce a deterministic ordering\n+        // of codegen units from the input.\n+        //\n+        // Due to basically how we've implemented the merging below (merge the\n+        // two smallest into each other) we're sure to start off with a\n+        // deterministic order (sorted by name). This'll mean that if two cgus\n+        // have the same size the stable sort below will keep everything nice\n+        // and deterministic.\n+        codegen_units.sort_by(|a, b| a.name().as_str().cmp(b.name().as_str()));\n+\n+        // This map keeps track of what got merged into what.\n+        let mut cgu_contents: FxHashMap<Symbol, Vec<Symbol>> =\n+            codegen_units.iter().map(|cgu| (cgu.name(), vec![cgu.name()])).collect();\n+\n+        // Merge the two smallest codegen units until the target size is\n+        // reached.\n+        while codegen_units.len() > cx.target_cgu_count {\n+            // Sort small cgus to the back\n+            codegen_units.sort_by_cached_key(|cgu| cmp::Reverse(cgu.size_estimate()));\n+            let mut smallest = codegen_units.pop().unwrap();\n+            let second_smallest = codegen_units.last_mut().unwrap();\n+\n+            // Move the mono-items from `smallest` to `second_smallest`\n+            second_smallest.modify_size_estimate(smallest.size_estimate());\n+            for (k, v) in smallest.items_mut().drain() {\n+                second_smallest.items_mut().insert(k, v);\n+            }\n+\n+            // Record that `second_smallest` now contains all the stuff that was\n+            // in `smallest` before.\n+            let mut consumed_cgu_names = cgu_contents.remove(&smallest.name()).unwrap();\n+            cgu_contents.get_mut(&second_smallest.name()).unwrap().append(&mut consumed_cgu_names);\n+\n+            debug!(\n+                \"CodegenUnit {} merged into CodegenUnit {}\",\n+                smallest.name(),\n+                second_smallest.name()\n+            );\n+        }\n+\n+        let cgu_name_builder = &mut CodegenUnitNameBuilder::new(cx.tcx);\n+\n+        if cx.tcx.sess.opts.incremental.is_some() {\n+            // If we are doing incremental compilation, we want CGU names to\n+            // reflect the path of the source level module they correspond to.\n+            // For CGUs that contain the code of multiple modules because of the\n+            // merging done above, we use a concatenation of the names of all\n+            // contained CGUs.\n+            let new_cgu_names: FxHashMap<Symbol, String> = cgu_contents\n+                .into_iter()\n+                // This `filter` makes sure we only update the name of CGUs that\n+                // were actually modified by merging.\n+                .filter(|(_, cgu_contents)| cgu_contents.len() > 1)\n+                .map(|(current_cgu_name, cgu_contents)| {\n+                    let mut cgu_contents: Vec<&str> =\n+                        cgu_contents.iter().map(|s| s.as_str()).collect();\n+\n+                    // Sort the names, so things are deterministic and easy to\n+                    // predict. We are sorting primitive `&str`s here so we can\n+                    // use unstable sort.\n+                    cgu_contents.sort_unstable();\n+\n+                    (current_cgu_name, cgu_contents.join(\"--\"))\n+                })\n+                .collect();\n+\n+            for cgu in codegen_units.iter_mut() {\n+                if let Some(new_cgu_name) = new_cgu_names.get(&cgu.name()) {\n+                    if cx.tcx.sess.opts.unstable_opts.human_readable_cgu_names {\n+                        cgu.set_name(Symbol::intern(&new_cgu_name));\n+                    } else {\n+                        // If we don't require CGU names to be human-readable,\n+                        // we use a fixed length hash of the composite CGU name\n+                        // instead.\n+                        let new_cgu_name = CodegenUnit::mangle_name(&new_cgu_name);\n+                        cgu.set_name(Symbol::intern(&new_cgu_name));\n+                    }\n+                }\n+            }\n+        } else {\n+            // If we are compiling non-incrementally we just generate simple CGU\n+            // names containing an index.\n+            for (index, cgu) in codegen_units.iter_mut().enumerate() {\n+                let numbered_codegen_unit_name =\n+                    cgu_name_builder.build_cgu_name_no_mangle(LOCAL_CRATE, &[\"cgu\"], Some(index));\n+                cgu.set_name(numbered_codegen_unit_name);\n+            }\n+        }\n     }\n \n     fn place_inlined_mono_items("}, {"sha": "9ab8da1858eff2ca9fb0b5d38550578ec8625c74", "filename": "compiler/rustc_monomorphize/src/partitioning/merging.rs", "status": "removed", "additions": 0, "deletions": 106, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/e26c0c92bda6a66a5ea2f308b28e53a0a9bfba7f/compiler%2Frustc_monomorphize%2Fsrc%2Fpartitioning%2Fmerging.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e26c0c92bda6a66a5ea2f308b28e53a0a9bfba7f/compiler%2Frustc_monomorphize%2Fsrc%2Fpartitioning%2Fmerging.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_monomorphize%2Fsrc%2Fpartitioning%2Fmerging.rs?ref=e26c0c92bda6a66a5ea2f308b28e53a0a9bfba7f", "patch": "@@ -1,106 +0,0 @@\n-use std::cmp;\n-\n-use rustc_data_structures::fx::FxHashMap;\n-use rustc_hir::def_id::LOCAL_CRATE;\n-use rustc_middle::mir::mono::{CodegenUnit, CodegenUnitNameBuilder};\n-use rustc_span::symbol::Symbol;\n-\n-use super::PartitioningCx;\n-use crate::partitioning::PreInliningPartitioning;\n-\n-pub fn merge_codegen_units<'tcx>(\n-    cx: &PartitioningCx<'_, 'tcx>,\n-    initial_partitioning: &mut PreInliningPartitioning<'tcx>,\n-) {\n-    assert!(cx.target_cgu_count >= 1);\n-    let codegen_units = &mut initial_partitioning.codegen_units;\n-\n-    // Note that at this point in time the `codegen_units` here may not be in a\n-    // deterministic order (but we know they're deterministically the same set).\n-    // We want this merging to produce a deterministic ordering of codegen units\n-    // from the input.\n-    //\n-    // Due to basically how we've implemented the merging below (merge the two\n-    // smallest into each other) we're sure to start off with a deterministic\n-    // order (sorted by name). This'll mean that if two cgus have the same size\n-    // the stable sort below will keep everything nice and deterministic.\n-    codegen_units.sort_by(|a, b| a.name().as_str().cmp(b.name().as_str()));\n-\n-    // This map keeps track of what got merged into what.\n-    let mut cgu_contents: FxHashMap<Symbol, Vec<Symbol>> =\n-        codegen_units.iter().map(|cgu| (cgu.name(), vec![cgu.name()])).collect();\n-\n-    // Merge the two smallest codegen units until the target size is reached.\n-    while codegen_units.len() > cx.target_cgu_count {\n-        // Sort small cgus to the back\n-        codegen_units.sort_by_cached_key(|cgu| cmp::Reverse(cgu.size_estimate()));\n-        let mut smallest = codegen_units.pop().unwrap();\n-        let second_smallest = codegen_units.last_mut().unwrap();\n-\n-        // Move the mono-items from `smallest` to `second_smallest`\n-        second_smallest.modify_size_estimate(smallest.size_estimate());\n-        for (k, v) in smallest.items_mut().drain() {\n-            second_smallest.items_mut().insert(k, v);\n-        }\n-\n-        // Record that `second_smallest` now contains all the stuff that was in\n-        // `smallest` before.\n-        let mut consumed_cgu_names = cgu_contents.remove(&smallest.name()).unwrap();\n-        cgu_contents.get_mut(&second_smallest.name()).unwrap().append(&mut consumed_cgu_names);\n-\n-        debug!(\n-            \"CodegenUnit {} merged into CodegenUnit {}\",\n-            smallest.name(),\n-            second_smallest.name()\n-        );\n-    }\n-\n-    let cgu_name_builder = &mut CodegenUnitNameBuilder::new(cx.tcx);\n-\n-    if cx.tcx.sess.opts.incremental.is_some() {\n-        // If we are doing incremental compilation, we want CGU names to\n-        // reflect the path of the source level module they correspond to.\n-        // For CGUs that contain the code of multiple modules because of the\n-        // merging done above, we use a concatenation of the names of\n-        // all contained CGUs.\n-        let new_cgu_names: FxHashMap<Symbol, String> = cgu_contents\n-            .into_iter()\n-            // This `filter` makes sure we only update the name of CGUs that\n-            // were actually modified by merging.\n-            .filter(|(_, cgu_contents)| cgu_contents.len() > 1)\n-            .map(|(current_cgu_name, cgu_contents)| {\n-                let mut cgu_contents: Vec<&str> = cgu_contents.iter().map(|s| s.as_str()).collect();\n-\n-                // Sort the names, so things are deterministic and easy to\n-                // predict.\n-\n-                // We are sorting primitive &strs here so we can use unstable sort\n-                cgu_contents.sort_unstable();\n-\n-                (current_cgu_name, cgu_contents.join(\"--\"))\n-            })\n-            .collect();\n-\n-        for cgu in codegen_units.iter_mut() {\n-            if let Some(new_cgu_name) = new_cgu_names.get(&cgu.name()) {\n-                if cx.tcx.sess.opts.unstable_opts.human_readable_cgu_names {\n-                    cgu.set_name(Symbol::intern(&new_cgu_name));\n-                } else {\n-                    // If we don't require CGU names to be human-readable, we\n-                    // use a fixed length hash of the composite CGU name\n-                    // instead.\n-                    let new_cgu_name = CodegenUnit::mangle_name(&new_cgu_name);\n-                    cgu.set_name(Symbol::intern(&new_cgu_name));\n-                }\n-            }\n-        }\n-    } else {\n-        // If we are compiling non-incrementally we just generate simple CGU\n-        // names containing an index.\n-        for (index, cgu) in codegen_units.iter_mut().enumerate() {\n-            let numbered_codegen_unit_name =\n-                cgu_name_builder.build_cgu_name_no_mangle(LOCAL_CRATE, &[\"cgu\"], Some(index));\n-            cgu.set_name(numbered_codegen_unit_name);\n-        }\n-    }\n-}"}, {"sha": "8ea82b39534d7b4a442a64788606a93e0001e954", "filename": "compiler/rustc_monomorphize/src/partitioning/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b39b7098eaaf5eb99e2f210ad98307ab310c1eee/compiler%2Frustc_monomorphize%2Fsrc%2Fpartitioning%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b39b7098eaaf5eb99e2f210ad98307ab310c1eee/compiler%2Frustc_monomorphize%2Fsrc%2Fpartitioning%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_monomorphize%2Fsrc%2Fpartitioning%2Fmod.rs?ref=b39b7098eaaf5eb99e2f210ad98307ab310c1eee", "patch": "@@ -93,7 +93,6 @@\n //! inlining, even when they are not marked `#[inline]`.\n \n mod default;\n-mod merging;\n \n use std::cmp;\n use std::fs::{self, File};"}]}