{"sha": "305331c00fe0b3838479e536903915420c4274ef", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMwNTMzMWMwMGZlMGIzODM4NDc5ZTUzNjkwMzkxNTQyMGM0Mjc0ZWY=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2013-05-16T07:04:24Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2013-05-16T19:03:58Z"}, "message": "core: Document some intrinsics", "tree": {"sha": "2700ccd1160129659a7a89605ee9d580575a99b4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2700ccd1160129659a7a89605ee9d580575a99b4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/305331c00fe0b3838479e536903915420c4274ef", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/305331c00fe0b3838479e536903915420c4274ef", "html_url": "https://github.com/rust-lang/rust/commit/305331c00fe0b3838479e536903915420c4274ef", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/305331c00fe0b3838479e536903915420c4274ef/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "92b7a453956f0548cf6c89117c8ae48d81553582", "url": "https://api.github.com/repos/rust-lang/rust/commits/92b7a453956f0548cf6c89117c8ae48d81553582", "html_url": "https://github.com/rust-lang/rust/commit/92b7a453956f0548cf6c89117c8ae48d81553582"}], "stats": {"total": 76, "additions": 68, "deletions": 8}, "files": [{"sha": "1636abedf7a7d6042a8c9004efabab81c1604e79", "filename": "src/libcore/unstable/intrinsics.rs", "status": "modified", "additions": 68, "deletions": 8, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/305331c00fe0b3838479e536903915420c4274ef/src%2Flibcore%2Funstable%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/305331c00fe0b3838479e536903915420c4274ef/src%2Flibcore%2Funstable%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funstable%2Fintrinsics.rs?ref=305331c00fe0b3838479e536903915420c4274ef", "patch": "@@ -8,62 +8,119 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-/*!\n-An attempt to move all intrinsic declarations to a single place,\n-as mentioned in #3369\n-The intrinsics are defined in librustc/middle/trans/foreign.rs.\n+/*! rustc compiler intrinsics.\n+\n+The corresponding definitions are in librustc/middle/trans/foreign.rs.\n+\n+# Atomics\n+\n+The atomic intrinsics provide common atomic operations on machine\n+words, with multiple possible memory orderings. They obey the same\n+semantics as C++0x. See the LLVM documentation on [[atomics]].\n+\n+[atomics]: http://llvm.org/docs/Atomics.html\n+\n+A quick refresher on memory ordering:\n+\n+* Acquire - a barrier for aquiring a lock. Subsequent reads and writes\n+  take place after the barrier.\n+* Release - a barrier for releasing a lock. Preceding reads and writes\n+  take place before the barrier.\n+* Sequentially consistent - sequentially consistent operations are\n+  guaranteed to happen in order. This is the standard mode for working\n+  with atomic types and is equivalent to Java's `volatile`.\n+\n */\n \n #[abi = \"rust-intrinsic\"]\n pub extern \"rust-intrinsic\" {\n+\n+    /// Atomic compare and exchange, sequentially consistent.\n     pub fn atomic_cxchg(dst: &mut int, old: int, src: int) -> int;\n+    /// Atomic compare and exchange, acquire ordering.\n     pub fn atomic_cxchg_acq(dst: &mut int, old: int, src: int) -> int;\n+    /// Atomic compare and exchange, release ordering.\n     pub fn atomic_cxchg_rel(dst: &mut int, old: int, src: int) -> int;\n \n+    /// Atomic load, sequentially consistent.\n     #[cfg(not(stage0))]\n     pub fn atomic_load(src: &int) -> int;\n+    /// Atomic load, acquire ordering.\n     #[cfg(not(stage0))]\n     pub fn atomic_load_acq(src: &int) -> int;\n \n+    /// Atomic store, sequentially consistent.\n     #[cfg(not(stage0))]\n     pub fn atomic_store(dst: &mut int, val: int);\n+    /// Atomic store, release ordering.\n     #[cfg(not(stage0))]\n     pub fn atomic_store_rel(dst: &mut int, val: int);\n \n+    /// Atomic exchange, sequentially consistent.\n     pub fn atomic_xchg(dst: &mut int, src: int) -> int;\n+    /// Atomic exchange, acquire ordering.\n     pub fn atomic_xchg_acq(dst: &mut int, src: int) -> int;\n+    /// Atomic exchange, release ordering.\n     pub fn atomic_xchg_rel(dst: &mut int, src: int) -> int;\n \n+    /// Atomic addition, sequentially consistent.\n     pub fn atomic_xadd(dst: &mut int, src: int) -> int;\n+    /// Atomic addition, acquire ordering.\n     pub fn atomic_xadd_acq(dst: &mut int, src: int) -> int;\n+    /// Atomic addition, release ordering.\n     pub fn atomic_xadd_rel(dst: &mut int, src: int) -> int;\n \n+    /// Atomic subtraction, sequentially consistent.\n     pub fn atomic_xsub(dst: &mut int, src: int) -> int;\n+    /// Atomic subtraction, acquire ordering.\n     pub fn atomic_xsub_acq(dst: &mut int, src: int) -> int;\n+    /// Atomic subtraction, release ordering.\n     pub fn atomic_xsub_rel(dst: &mut int, src: int) -> int;\n \n+    /// The size of a type in bytes.\n+    ///\n+    /// This is the exact number of bytes in memory taken up by a\n+    /// value of the given type. In other words, a memset of this size\n+    /// would *exactly* overwrite a value. When laid out in vectors\n+    /// and structures there may be additional padding between\n+    /// elements.\n     pub fn size_of<T>() -> uint;\n \n+    /// Move a value to a memory location containing a value.\n+    ///\n+    /// Drop glue is run on the destination, which must contain a\n+    /// valid Rust value.\n     pub fn move_val<T>(dst: &mut T, src: T);\n+\n+    /// Move a value to an uninitialized memory location.\n+    ///\n+    /// Drop glue is not run on the destination.\n     pub fn move_val_init<T>(dst: &mut T, src: T);\n \n     pub fn min_align_of<T>() -> uint;\n     pub fn pref_align_of<T>() -> uint;\n \n+    /// Get a static pointer to a type descriptor.\n     pub fn get_tydesc<T>() -> *();\n \n-    /// init is unsafe because it returns a zeroed-out datum,\n+    /// Create a value initialized to zero.\n+    ///\n+    /// `init` is unsafe because it returns a zeroed-out datum,\n     /// which is unsafe unless T is POD. We don't have a POD\n-    /// kind yet. (See #4074)\n+    /// kind yet. (See #4074).\n     pub unsafe fn init<T>() -> T;\n \n+    /// Create an uninitialized value.\n     #[cfg(not(stage0))]\n     pub unsafe fn uninit<T>() -> T;\n \n-    /// forget is unsafe because the caller is responsible for\n-    /// ensuring the argument is deallocated already\n+    /// Move a value out of scope without running drop glue.\n+    ///\n+    /// `forget` is unsafe because the caller is responsible for\n+    /// ensuring the argument is deallocated already.\n     pub unsafe fn forget<T>(_: T) -> ();\n \n+    /// Returns `true` if a type requires drop glue.\n     pub fn needs_drop<T>() -> bool;\n \n     // XXX: intrinsic uses legacy modes and has reference to TyDesc\n@@ -72,9 +129,12 @@ pub extern \"rust-intrinsic\" {\n     // XXX: intrinsic uses legacy modes\n     //fn frame_address(f: &once fn(*u8));\n \n+    /// Get the address of the `__morestack` stack growth function.\n     pub fn morestack_addr() -> *();\n \n+    /// Equivalent to the `llvm.memmove.p0i8.0i8.i32` intrinsic.\n     pub fn memmove32(dst: *mut u8, src: *u8, size: u32);\n+    /// Equivalent to the `llvm.memmove.p0i8.0i8.i64` intrinsic.\n     pub fn memmove64(dst: *mut u8, src: *u8, size: u64);\n \n     pub fn sqrtf32(x: f32) -> f32;"}]}