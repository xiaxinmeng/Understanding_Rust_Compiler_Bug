{"sha": "4baa8c27a706e75e41910e115d4da57ad394012d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRiYWE4YzI3YTcwNmU3NWU0MTkxMGUxMTVkNGRhNTdhZDM5NDAxMmQ=", "commit": {"author": {"name": "Caleb Zulawski", "email": "caleb.zulawski@gmail.com", "date": "2020-10-13T03:34:56Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-10-13T03:34:56Z"}, "message": "Merge pull request #34 from rust-lang/feature/round\n\nFeature/round", "tree": {"sha": "332f968da7cc8209bdfa7ae9b86fd14be3c5fa34", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/332f968da7cc8209bdfa7ae9b86fd14be3c5fa34"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4baa8c27a706e75e41910e115d4da57ad394012d", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfhSBgCRBK7hj4Ov3rIwAAdHIIAIy9rX/0810rHPFwOjFYVczX\nVzeOidBVyM8rVabfv79HwNeR3/WptWtgmg8/knaL45F/ur4agKcHx3sZ8PkKwWqW\nEn3io2hsGc/ZmMBn1nPSY57VKT0IkHAjv9Rsw+v+CLtCz/U2+RBSBfjJFZO3XrC8\nyNqvg/jcSGFXW9VzWZj49FIzQy8RDUzFKXN+bDlSKxS+xjBoXoyZ21+U/qIbbOci\nzk4ob92JgT1+aqpJp5e/UJzkDS4Lb/Ny7XbdJIY24hgLL3IMc9EjAxQaojrUjejH\nVjer2vy53ahP2vOb1alxMP9p2yX1av5U3mWEVYes7HoNUQu++10QhWOAloKWeRQ=\n=cMPu\n-----END PGP SIGNATURE-----\n", "payload": "tree 332f968da7cc8209bdfa7ae9b86fd14be3c5fa34\nparent 285fff01f10a3194853073b308bb334ae9a13392\nparent 387063382853cc4f20900eb666c1e97dc05cb998\nauthor Caleb Zulawski <caleb.zulawski@gmail.com> 1602560096 -0400\ncommitter GitHub <noreply@github.com> 1602560096 -0400\n\nMerge pull request #34 from rust-lang/feature/round\n\nFeature/round"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4baa8c27a706e75e41910e115d4da57ad394012d", "html_url": "https://github.com/rust-lang/rust/commit/4baa8c27a706e75e41910e115d4da57ad394012d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4baa8c27a706e75e41910e115d4da57ad394012d/comments", "author": {"login": "calebzulawski", "id": 563826, "node_id": "MDQ6VXNlcjU2MzgyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/563826?v=4", "gravatar_id": "", "url": "https://api.github.com/users/calebzulawski", "html_url": "https://github.com/calebzulawski", "followers_url": "https://api.github.com/users/calebzulawski/followers", "following_url": "https://api.github.com/users/calebzulawski/following{/other_user}", "gists_url": "https://api.github.com/users/calebzulawski/gists{/gist_id}", "starred_url": "https://api.github.com/users/calebzulawski/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/calebzulawski/subscriptions", "organizations_url": "https://api.github.com/users/calebzulawski/orgs", "repos_url": "https://api.github.com/users/calebzulawski/repos", "events_url": "https://api.github.com/users/calebzulawski/events{/privacy}", "received_events_url": "https://api.github.com/users/calebzulawski/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "285fff01f10a3194853073b308bb334ae9a13392", "url": "https://api.github.com/repos/rust-lang/rust/commits/285fff01f10a3194853073b308bb334ae9a13392", "html_url": "https://github.com/rust-lang/rust/commit/285fff01f10a3194853073b308bb334ae9a13392"}, {"sha": "387063382853cc4f20900eb666c1e97dc05cb998", "url": "https://api.github.com/repos/rust-lang/rust/commits/387063382853cc4f20900eb666c1e97dc05cb998", "html_url": "https://github.com/rust-lang/rust/commit/387063382853cc4f20900eb666c1e97dc05cb998"}], "stats": {"total": 319, "additions": 305, "deletions": 14}, "files": [{"sha": "8d33125769275f2576d51d8421bd99661bc8e137", "filename": ".github/workflows/ci.yml", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4baa8c27a706e75e41910e115d4da57ad394012d/.github%2Fworkflows%2Fci.yml", "raw_url": "https://github.com/rust-lang/rust/raw/4baa8c27a706e75e41910e115d4da57ad394012d/.github%2Fworkflows%2Fci.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.github%2Fworkflows%2Fci.yml?ref=4baa8c27a706e75e41910e115d4da57ad394012d", "patch": "@@ -121,7 +121,8 @@ jobs:\n           # for NaNs which makes it worth testing on despite that.\n           - mips-unknown-linux-gnu\n           - mips64-unknown-linux-gnuabi64\n-          - riscv64gc-unknown-linux-gnu\n+          # TODO: reenable pending https://github.com/rust-lang/rust/issues/77866\n+          # - riscv64gc-unknown-linux-gnu\n \n     steps:\n       - uses: actions/checkout@v2"}, {"sha": "acf85983a9837bb5c02aa0ce797f2e7ee77e018f", "filename": "crates/core_simd/src/intrinsics.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4baa8c27a706e75e41910e115d4da57ad394012d/crates%2Fcore_simd%2Fsrc%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4baa8c27a706e75e41910e115d4da57ad394012d/crates%2Fcore_simd%2Fsrc%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fintrinsics.rs?ref=4baa8c27a706e75e41910e115d4da57ad394012d", "patch": "@@ -36,4 +36,7 @@ extern \"platform-intrinsic\" {\n \n     /// xor\n     pub(crate) fn simd_xor<T>(x: T, y: T) -> T;\n+\n+    /// fptoui/fptosi/uitofp/sitofp\n+    pub(crate) fn simd_cast<T, U>(x: T) -> U;\n }"}, {"sha": "cea39e6f3f3d9774cfb3b99f391b323ad95ba5e5", "filename": "crates/core_simd/src/lib.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4baa8c27a706e75e41910e115d4da57ad394012d/crates%2Fcore_simd%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4baa8c27a706e75e41910e115d4da57ad394012d/crates%2Fcore_simd%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Flib.rs?ref=4baa8c27a706e75e41910e115d4da57ad394012d", "patch": "@@ -1,5 +1,5 @@\n #![no_std]\n-#![feature(repr_simd, platform_intrinsics)]\n+#![feature(repr_simd, platform_intrinsics, link_llvm_intrinsics, simd_ffi)]\n #![warn(missing_docs)]\n //! Portable SIMD module.\n \n@@ -56,3 +56,5 @@ mod vectors_mask128;\n pub use vectors_mask128::*;\n mod vectors_masksize;\n pub use vectors_masksize::*;\n+\n+mod round;"}, {"sha": "021e5af88737bd56fa0e71f090451a9700d9279b", "filename": "crates/core_simd/src/round.rs", "status": "added", "additions": 153, "deletions": 0, "changes": 153, "blob_url": "https://github.com/rust-lang/rust/blob/4baa8c27a706e75e41910e115d4da57ad394012d/crates%2Fcore_simd%2Fsrc%2Fround.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4baa8c27a706e75e41910e115d4da57ad394012d/crates%2Fcore_simd%2Fsrc%2Fround.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fround.rs?ref=4baa8c27a706e75e41910e115d4da57ad394012d", "patch": "@@ -0,0 +1,153 @@\n+macro_rules! implement {\n+    {\n+        impl $type:ident {\n+            int_type = $int_type:ident,\n+            floor = $floor_intrinsic:literal,\n+            ceil = $ceil_intrinsic:literal,\n+            round = $round_intrinsic:literal,\n+            trunc = $trunc_intrinsic:literal,\n+        }\n+    } => {\n+        mod $type {\n+            #[allow(improper_ctypes)]\n+            extern \"C\" {\n+                #[link_name = $floor_intrinsic]\n+                fn floor_intrinsic(x: crate::$type) -> crate::$type;\n+                #[link_name = $ceil_intrinsic]\n+                fn ceil_intrinsic(x: crate::$type) -> crate::$type;\n+                #[link_name = $round_intrinsic]\n+                fn round_intrinsic(x: crate::$type) -> crate::$type;\n+                #[link_name = $trunc_intrinsic]\n+                fn trunc_intrinsic(x: crate::$type) -> crate::$type;\n+            }\n+\n+            impl crate::$type {\n+                /// Returns the largest integer less than or equal to each lane.\n+                #[must_use = \"method returns a new vector and does not mutate the original value\"]\n+                #[inline]\n+                pub fn floor(self) -> Self {\n+                    unsafe { floor_intrinsic(self) }\n+                }\n+\n+                /// Returns the smallest integer greater than or equal to each lane.\n+                #[must_use = \"method returns a new vector and does not mutate the original value\"]\n+                #[inline]\n+                pub fn ceil(self) -> Self {\n+                    unsafe { ceil_intrinsic(self) }\n+                }\n+\n+                /// Returns the nearest integer to each lane. Round half-way cases away from 0.0.\n+                #[must_use = \"method returns a new vector and does not mutate the original value\"]\n+                #[inline]\n+                pub fn round(self) -> Self {\n+                    unsafe { round_intrinsic(self) }\n+                }\n+\n+                /// Returns the integer part of each lane.\n+                #[must_use = \"method returns a new vector and does not mutate the original value\"]\n+                #[inline]\n+                pub fn trunc(self) -> Self {\n+                    unsafe { trunc_intrinsic(self) }\n+                }\n+\n+                /// Returns the fractional part of each lane.\n+                #[must_use = \"method returns a new vector and does not mutate the original value\"]\n+                #[inline]\n+                pub fn fract(self) -> Self {\n+                    self - self.trunc()\n+                }\n+\n+                /// Rounds toward zero and converts to the same-width integer type, assuming that\n+                /// the value is finite and fits in that type.\n+                ///\n+                /// # Safety\n+                /// The value must:\n+                ///\n+                /// * Not be NaN\n+                /// * Not be infinite\n+                /// * Be representable in the return type, after truncating off its fractional part\n+                #[inline]\n+                pub unsafe fn to_int_unchecked(self) -> crate::$int_type {\n+                    crate::intrinsics::simd_cast(self)\n+                }\n+\n+                /// Creates a floating-point vector from an integer vector.  Rounds values that are\n+                /// not exactly representable.\n+                #[inline]\n+                pub fn round_from_int(value: crate::$int_type) -> Self {\n+                    unsafe { crate::intrinsics::simd_cast(value) }\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+implement! {\n+    impl f32x2 {\n+        int_type = i32x2,\n+        floor = \"llvm.floor.v2f32\",\n+        ceil = \"llvm.ceil.v2f32\",\n+        round = \"llvm.round.v2f32\",\n+        trunc = \"llvm.trunc.v2f32\",\n+    }\n+}\n+\n+implement! {\n+    impl f32x4 {\n+        int_type = i32x4,\n+        floor = \"llvm.floor.v4f32\",\n+        ceil = \"llvm.ceil.v4f32\",\n+        round = \"llvm.round.v4f32\",\n+        trunc = \"llvm.trunc.v4f32\",\n+    }\n+}\n+\n+implement! {\n+    impl f32x8 {\n+        int_type = i32x8,\n+        floor = \"llvm.floor.v8f32\",\n+        ceil = \"llvm.ceil.v8f32\",\n+        round = \"llvm.round.v8f32\",\n+        trunc = \"llvm.trunc.v8f32\",\n+    }\n+}\n+\n+implement! {\n+    impl f32x16 {\n+        int_type = i32x16,\n+        floor = \"llvm.floor.v16f32\",\n+        ceil = \"llvm.ceil.v16f32\",\n+        round = \"llvm.round.v16f32\",\n+        trunc = \"llvm.trunc.v16f32\",\n+    }\n+}\n+\n+implement! {\n+    impl f64x2 {\n+        int_type = i64x2,\n+        floor = \"llvm.floor.v2f64\",\n+        ceil = \"llvm.ceil.v2f64\",\n+        round = \"llvm.round.v2f64\",\n+        trunc = \"llvm.trunc.v2f64\",\n+    }\n+}\n+\n+implement! {\n+    impl f64x4 {\n+        int_type = i64x4,\n+        floor = \"llvm.floor.v4f64\",\n+        ceil = \"llvm.ceil.v4f64\",\n+        round = \"llvm.round.v4f64\",\n+        trunc = \"llvm.trunc.v4f64\",\n+    }\n+}\n+\n+implement! {\n+    impl f64x8 {\n+        int_type = i64x8,\n+        floor = \"llvm.floor.v8f64\",\n+        ceil = \"llvm.ceil.v8f64\",\n+        round = \"llvm.round.v8f64\",\n+        trunc = \"llvm.trunc.v8f64\",\n+    }\n+}"}, {"sha": "15f1a88ffd5c3232274f806a0f2c3d54de098c70", "filename": "crates/core_simd/tests/helpers/lanewise.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/4baa8c27a706e75e41910e115d4da57ad394012d/crates%2Fcore_simd%2Ftests%2Fhelpers%2Flanewise.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4baa8c27a706e75e41910e115d4da57ad394012d/crates%2Fcore_simd%2Ftests%2Fhelpers%2Flanewise.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Ftests%2Fhelpers%2Flanewise.rs?ref=4baa8c27a706e75e41910e115d4da57ad394012d", "patch": "@@ -1,8 +1,13 @@\n-pub fn apply_unary_lanewise<T: Copy, V: AsMut<[T]> + Default>(mut x: V, f: impl Fn(T) -> T) -> V {\n-    for lane in x.as_mut() {\n-        *lane = f(*lane)\n+pub fn apply_unary_lanewise<T1: Copy, T2: Copy, V1: AsRef<[T1]>, V2: AsMut<[T2]> + Default>(\n+    x: V1,\n+    f: impl Fn(T1) -> T2,\n+) -> V2 {\n+    let mut y = V2::default();\n+    assert_eq!(x.as_ref().len(), y.as_mut().len());\n+    for (x, y) in x.as_ref().iter().zip(y.as_mut().iter_mut()) {\n+        *y = f(*x);\n     }\n-    x\n+    y\n }\n \n pub fn apply_binary_lanewise<T: Copy, V: AsRef<[T]> + AsMut<[T]> + Default>("}, {"sha": "1472822fe1fe559f935b5b1381c6ff0999d6ad2b", "filename": "crates/core_simd/tests/ops_impl/f32.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4baa8c27a706e75e41910e115d4da57ad394012d/crates%2Fcore_simd%2Ftests%2Fops_impl%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4baa8c27a706e75e41910e115d4da57ad394012d/crates%2Fcore_simd%2Ftests%2Fops_impl%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Ftests%2Fops_impl%2Ff32.rs?ref=4baa8c27a706e75e41910e115d4da57ad394012d", "patch": "@@ -1,6 +1,6 @@\n use super::helpers;\n \n-float_tests! { f32x2, f32 }\n-float_tests! { f32x4, f32 }\n-float_tests! { f32x8, f32 }\n-float_tests! { f32x16, f32 }\n+float_tests! { f32x2, f32, i32x2, i32 }\n+float_tests! { f32x4, f32, i32x4, i32 }\n+float_tests! { f32x8, f32, i32x8, i32 }\n+float_tests! { f32x16, f32, i32x16, i32 }"}, {"sha": "8f573baa1ad222a20fe7a35ff7c13a6135750112", "filename": "crates/core_simd/tests/ops_impl/f64.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4baa8c27a706e75e41910e115d4da57ad394012d/crates%2Fcore_simd%2Ftests%2Fops_impl%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4baa8c27a706e75e41910e115d4da57ad394012d/crates%2Fcore_simd%2Ftests%2Fops_impl%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Ftests%2Fops_impl%2Ff64.rs?ref=4baa8c27a706e75e41910e115d4da57ad394012d", "patch": "@@ -1,5 +1,5 @@\n use super::helpers;\n \n-float_tests! { f64x2, f64 }\n-float_tests! { f64x4, f64 }\n-float_tests! { f64x8, f64 }\n+float_tests! { f64x2, f64, i64x2, i64 }\n+float_tests! { f64x4, f64, i64x4, i64 }\n+float_tests! { f64x8, f64, i64x8, i64 }"}, {"sha": "1f49aef9f12c24f77d6080678ddfc302d8f8cc3e", "filename": "crates/core_simd/tests/ops_impl/float_macros.rs", "status": "modified", "additions": 128, "deletions": 1, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/4baa8c27a706e75e41910e115d4da57ad394012d/crates%2Fcore_simd%2Ftests%2Fops_impl%2Ffloat_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4baa8c27a706e75e41910e115d4da57ad394012d/crates%2Fcore_simd%2Ftests%2Fops_impl%2Ffloat_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Ftests%2Fops_impl%2Ffloat_macros.rs?ref=4baa8c27a706e75e41910e115d4da57ad394012d", "patch": "@@ -1,5 +1,5 @@\n macro_rules! float_tests {\n-    { $vector:ident, $scalar:ident } => {\n+    { $vector:ident, $scalar:ident, $int_vector:ident, $int_scalar:ident } => {\n         #[cfg(test)]\n         mod $vector {\n             use super::*;\n@@ -24,6 +24,18 @@ macro_rules! float_tests {\n                 slice.chunks_exact(lanes).map(from_slice)\n             }\n \n+            fn from_slice_int(slice: &[$int_scalar]) -> core_simd::$int_vector {\n+                let mut value = core_simd::$int_vector::default();\n+                let value_slice: &mut [_] = value.as_mut();\n+                value_slice.copy_from_slice(&slice[0..value_slice.len()]);\n+                value\n+            }\n+\n+            fn slice_chunks_int(slice: &[$int_scalar]) -> impl Iterator<Item = core_simd::$int_vector> + '_ {\n+                let lanes = core::mem::size_of::<core_simd::$int_vector>() / core::mem::size_of::<$int_scalar>();\n+                slice.chunks_exact(lanes).map(from_slice_int)\n+            }\n+\n             const A: [$scalar; 16] = [0.,   1.,  2.,  3.,  4.,  5.,  6.,  7.,  8.,  9., 10., 11., 12., 13., 14., 15.];\n             const B: [$scalar; 16] = [16., 17., 18., 19., 20., 21., 22., 23., 24., 25., 26., 27., 28., 29., 30., 31.];\n             const C: [$scalar; 16] = [\n@@ -322,6 +334,121 @@ macro_rules! float_tests {\n                     assert_biteq!(v.abs(), expected);\n                 }\n             }\n+\n+            #[test]\n+            #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n+            fn ceil_odd_floats() {\n+                for v in slice_chunks(&C) {\n+                    let expected = apply_unary_lanewise(v, <$scalar>::ceil);\n+                    assert_biteq!(v.ceil(), expected);\n+                }\n+            }\n+\n+            #[test]\n+            #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n+            fn floor_odd_floats() {\n+                for v in slice_chunks(&C) {\n+                    let expected = apply_unary_lanewise(v, <$scalar>::floor);\n+                    assert_biteq!(v.floor(), expected);\n+                }\n+            }\n+\n+            #[test]\n+            #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n+            fn round_odd_floats() {\n+                for v in slice_chunks(&C) {\n+                    let expected = apply_unary_lanewise(v, <$scalar>::round);\n+                    assert_biteq!(v.round(), expected);\n+                }\n+            }\n+\n+            #[test]\n+            #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n+            fn round_mode() {\n+                assert_biteq!(core_simd::$vector::splat(1.5).round(), core_simd::$vector::splat(2.0));\n+                assert_biteq!(core_simd::$vector::splat(2.5).round(), core_simd::$vector::splat(3.0));\n+                assert_biteq!(core_simd::$vector::splat(-1.5).round(), core_simd::$vector::splat(-2.0));\n+                assert_biteq!(core_simd::$vector::splat(-2.5).round(), core_simd::$vector::splat(-3.0));\n+            }\n+\n+            #[test]\n+            #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n+            fn trunc_odd_floats() {\n+                for v in slice_chunks(&C) {\n+                    let expected = apply_unary_lanewise(v, <$scalar>::trunc);\n+                    assert_biteq!(v.trunc(), expected);\n+                }\n+            }\n+\n+            #[test]\n+            #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n+            fn fract_odd_floats() {\n+                for v in slice_chunks(&C) {\n+                    let expected = apply_unary_lanewise(v, <$scalar>::fract);\n+                    assert_biteq!(v.fract(), expected);\n+                }\n+            }\n+\n+            #[test]\n+            #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n+            fn to_int_unchecked() {\n+                // The maximum integer that can be represented by the equivalently sized float has\n+                // all of the mantissa digits set to 1, pushed up to the MSB.\n+                const ALL_MANTISSA_BITS: $int_scalar = ((1 << <$scalar>::MANTISSA_DIGITS) - 1);\n+                const MAX_REPRESENTABLE_VALUE: $int_scalar =\n+                    ALL_MANTISSA_BITS << (core::mem::size_of::<$scalar>() * 8 - <$scalar>::MANTISSA_DIGITS as usize - 1);\n+                const VALUES: [$scalar; 16] = [\n+                    -0.0,\n+                    0.0,\n+                    -1.0,\n+                    1.0,\n+                    ALL_MANTISSA_BITS as $scalar,\n+                    -ALL_MANTISSA_BITS as $scalar,\n+                    MAX_REPRESENTABLE_VALUE as $scalar,\n+                    -MAX_REPRESENTABLE_VALUE as $scalar,\n+                    (MAX_REPRESENTABLE_VALUE / 2) as $scalar,\n+                    (-MAX_REPRESENTABLE_VALUE / 2) as $scalar,\n+                    <$scalar>::MIN_POSITIVE,\n+                    -<$scalar>::MIN_POSITIVE,\n+                    <$scalar>::EPSILON,\n+                    -<$scalar>::EPSILON,\n+                    100.0 / 3.0,\n+                    -100.0 / 3.0,\n+                ];\n+\n+                for v in slice_chunks(&VALUES) {\n+                    let expected = apply_unary_lanewise(v, |x| unsafe { x.to_int_unchecked() });\n+                    assert_biteq!(unsafe { v.to_int_unchecked() }, expected);\n+                }\n+            }\n+\n+            #[test]\n+            #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n+            fn round_from_int() {\n+                const VALUES: [$int_scalar; 16] = [\n+                    0,\n+                    0,\n+                    1,\n+                    -1,\n+                    100,\n+                    -100,\n+                    200,\n+                    -200,\n+                    413,\n+                    -413,\n+                    1017,\n+                    -1017,\n+                    1234567,\n+                    -1234567,\n+                    <$int_scalar>::MAX,\n+                    <$int_scalar>::MIN,\n+                ];\n+\n+                for v in slice_chunks_int(&VALUES) {\n+                    let expected = apply_unary_lanewise(v, |x| x as $scalar);\n+                    assert_biteq!(core_simd::$vector::round_from_int(v), expected);\n+                }\n+            }\n         }\n     }\n }"}]}