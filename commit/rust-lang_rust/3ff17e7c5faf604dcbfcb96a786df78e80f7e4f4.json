{"sha": "3ff17e7c5faf604dcbfcb96a786df78e80f7e4f4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNmZjE3ZTdjNWZhZjYwNGRjYmZjYjk2YTc4NmRmNzhlODBmN2U0ZjQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-12-09T10:50:41Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-12-09T10:50:41Z"}, "message": "Auto merge of #67016 - lqd:placeholder_loans, r=matthewjasper\n\nIn which we implement illegal subset relations errors using Polonius\n\nThis PR is the rustc side of implementing subset errors using Polonius. That is, in\n```rust\nfn foo<'a, 'b>(x: &'a u32, y: &'b u32) -> &'a u32 {\n    y\n}\n```\nreturning `y` requires that `'b: 'a` but we have no evidence of that, so this is an error. (Evidence that the relation holds could come from explicit bounds, or via implied bounds).\n\nPolonius outputs one such error per CFG point where the free region's placeholder loan unexpectedly flowed into another free region. While all these CFG locations could be useful in diagnostics in the future, rustc does not do that (and the duplication is only partially handled in the rest of the errors/diagnostics infrastructure, e.g. duplicate suggestions will be shown by the \"outlives suggestions\" or some of the `#[rustc_*]` NLL/MIR debug dumps), so I deduplicated the errors.\n\n(The ordering also matters, otherwise some of the elided lifetime naming would change behaviour).\n\nI've blessed a couple of tests, where the output is currently suboptimal:\n- the `hrtb-perfect-forwarding` tests mix subset errors with higher-ranked subtyping, however the plan is for chalk to eventually take care of some of this to generate polonius constraints (i.e. it's not polonius' job). Until that happens, polonius will not see the error that NLL sees.\n- some other tests have errors and diagnostics specific to `'static`, I _believe_ this to be because of it being treated as more \"special\" than in polonius. I believe the output is not wrong, but could be better, and appears elsewhere (I feel we'll need to look at polonius' handling of `'static` at some point in the future, maybe to match a bit more what NLL does when it produces errors)\n\nI'll create a tracking issue in the polonius repo to record these 2 points (and a general \"we'll need to go over the blessed output\" issue, much like we did for NLLs)\n\nThe last blessed test is because it's an improvement: in this case, more errors/suggestions were computed, instead of the existing code path where this case apparently stops at the first error.\n\nThe `Naive` variant in Polonius computes those errors, so this PR also switches the default variant to that, as we're also in the process of temporarily deactivating all other variants (which exist mostly for performance considerations) until we have completed more work on completeness and correctness, before focusing on efficiency once again.\n\nWhile most of the correctness in this PR is hidden in the polonius compare-mode (which of course passes locally), I've added a couple of smoke-tests to the existing ones, so that we have some confidence that it works (and keeps working) until we're in a position where we can run them on CI.\n\nAs mentioned during yesterday's wg-polonius meeting, @nikomatsakis has already read through most of this PR (and which is matching  what they thought needed to be done [during the recent Polonius sprint](https://hackmd.io/CGMNjt1hR_qYtsR9hgdGmw#Compiler-notes-on-generating-the-placeholder-loans-support)), but Matthew was hopefully going to review (again, not urgent), so:\n\nr? @matthewjasper\n\n(This updates to the latest `polonius-engine` release, and I'm not sure whether `Cargo.lock` updates can easily be rolled up, but apart from that: this changes little that's tested on CI, so seems safe-ish to rollup ?)", "tree": {"sha": "ed56abf85c9d0c6a023326c2ff108f2e93252942", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ed56abf85c9d0c6a023326c2ff108f2e93252942"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3ff17e7c5faf604dcbfcb96a786df78e80f7e4f4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3ff17e7c5faf604dcbfcb96a786df78e80f7e4f4", "html_url": "https://github.com/rust-lang/rust/commit/3ff17e7c5faf604dcbfcb96a786df78e80f7e4f4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3ff17e7c5faf604dcbfcb96a786df78e80f7e4f4/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dbbe4f10fa68105223af6096df617ebb7ca59a48", "url": "https://api.github.com/repos/rust-lang/rust/commits/dbbe4f10fa68105223af6096df617ebb7ca59a48", "html_url": "https://github.com/rust-lang/rust/commit/dbbe4f10fa68105223af6096df617ebb7ca59a48"}, {"sha": "1314ba323b6612d5109344c1d8bf9ae16e1e421f", "url": "https://api.github.com/repos/rust-lang/rust/commits/1314ba323b6612d5109344c1d8bf9ae16e1e421f", "html_url": "https://github.com/rust-lang/rust/commit/1314ba323b6612d5109344c1d8bf9ae16e1e421f"}], "stats": {"total": 660, "additions": 622, "deletions": 38}, "files": [{"sha": "113b7e7654e94a8ecc9cb989669c4c8cc97b2a7e", "filename": "Cargo.lock", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3ff17e7c5faf604dcbfcb96a786df78e80f7e4f4/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/3ff17e7c5faf604dcbfcb96a786df78e80f7e4f4/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=3ff17e7c5faf604dcbfcb96a786df78e80f7e4f4", "patch": "@@ -2577,9 +2577,9 @@ checksum = \"676e8eb2b1b4c9043511a9b7bea0915320d7e502b0a079fb03f9635a5252b18c\"\n \n [[package]]\n name = \"polonius-engine\"\n-version = \"0.10.0\"\n+version = \"0.11.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"50fa9dbfd0d3d60594da338cfe6f94028433eecae4b11b7e83fd99759227bbfe\"\n+checksum = \"1e478d7c38eb785c6416cbe58df12aa55d7aefa3759b6d3e044b2ed03f423cec\"\n dependencies = [\n  \"datafrog\",\n  \"log\","}, {"sha": "a4536bb6c41f09a3b2617c2ebc628f87dc5004ae", "filename": "src/librustc/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3ff17e7c5faf604dcbfcb96a786df78e80f7e4f4/src%2Flibrustc%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/3ff17e7c5faf604dcbfcb96a786df78e80f7e4f4/src%2Flibrustc%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2FCargo.toml?ref=3ff17e7c5faf604dcbfcb96a786df78e80f7e4f4", "patch": "@@ -20,7 +20,7 @@ scoped-tls = \"1.0\"\n log = { version = \"0.4\", features = [\"release_max_level_info\", \"std\"] }\n rustc-rayon = \"0.3.0\"\n rustc-rayon-core = \"0.3.0\"\n-polonius-engine  = \"0.10.0\"\n+polonius-engine = \"0.11.0\"\n rustc_apfloat = { path = \"../librustc_apfloat\" }\n rustc_feature = { path = \"../librustc_feature\" }\n rustc_target = { path = \"../librustc_target\" }"}, {"sha": "bbf6999b983754c85f68bfd8a7f0bd7b9dd68766", "filename": "src/librustc_data_structures/transitive_relation.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3ff17e7c5faf604dcbfcb96a786df78e80f7e4f4/src%2Flibrustc_data_structures%2Ftransitive_relation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ff17e7c5faf604dcbfcb96a786df78e80f7e4f4/src%2Flibrustc_data_structures%2Ftransitive_relation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Ftransitive_relation.rs?ref=3ff17e7c5faf604dcbfcb96a786df78e80f7e4f4", "patch": "@@ -373,6 +373,14 @@ impl<T: Clone + Debug + Eq + Hash> TransitiveRelation<T> {\n         }\n         matrix\n     }\n+\n+    /// Lists all the base edges in the graph: the initial _non-transitive_ set of element\n+    /// relations, which will be later used as the basis for the transitive closure computation.\n+    pub fn base_edges(&self) -> impl Iterator<Item=(&T, &T)> {\n+        self.edges\n+            .iter()\n+            .map(move |edge| (&self.elements[edge.source.0], &self.elements[edge.target.0]))\n+    }\n }\n \n /// Pare down is used as a step in the LUB computation. It edits the"}, {"sha": "7e3bd98176e6a3479124a4735e36b34842bf3405", "filename": "src/librustc_mir/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3ff17e7c5faf604dcbfcb96a786df78e80f7e4f4/src%2Flibrustc_mir%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/3ff17e7c5faf604dcbfcb96a786df78e80f7e4f4/src%2Flibrustc_mir%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2FCargo.toml?ref=3ff17e7c5faf604dcbfcb96a786df78e80f7e4f4", "patch": "@@ -16,7 +16,7 @@ dot = { path = \"../libgraphviz\", package = \"graphviz\" }\n itertools = \"0.8\"\n log = \"0.4\"\n log_settings = \"0.1.1\"\n-polonius-engine  = \"0.10.0\"\n+polonius-engine = \"0.11.0\"\n rustc = { path = \"../librustc\" }\n rustc_target = { path = \"../librustc_target\" }\n rustc_data_structures = { path = \"../librustc_data_structures\" }"}, {"sha": "57c544fda0c5467f30099bf523dc75e76aebcdac", "filename": "src/librustc_mir/borrow_check/flows.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/3ff17e7c5faf604dcbfcb96a786df78e80f7e4f4/src%2Flibrustc_mir%2Fborrow_check%2Fflows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ff17e7c5faf604dcbfcb96a786df78e80f7e4f4/src%2Flibrustc_mir%2Fborrow_check%2Fflows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fflows.rs?ref=3ff17e7c5faf604dcbfcb96a786df78e80f7e4f4", "patch": "@@ -3,16 +3,15 @@\n //! FIXME: this might be better as a \"generic\" fixed-point combinator,\n //! but is not as ugly as it is right now.\n \n-use rustc::mir::{BasicBlock, Local, Location};\n-use rustc::ty::RegionVid;\n+use rustc::mir::{BasicBlock, Location};\n use rustc_index::bit_set::BitIter;\n \n use crate::borrow_check::location::LocationIndex;\n \n-use polonius_engine::Output;\n+use crate::borrow_check::nll::PoloniusOutput;\n \n use crate::dataflow::indexes::BorrowIndex;\n-use crate::dataflow::move_paths::{HasMoveData, MovePathIndex};\n+use crate::dataflow::move_paths::HasMoveData;\n use crate::dataflow::Borrows;\n use crate::dataflow::EverInitializedPlaces;\n use crate::dataflow::MaybeUninitializedPlaces;\n@@ -21,8 +20,6 @@ use either::Either;\n use std::fmt;\n use std::rc::Rc;\n \n-crate type PoloniusOutput = Output<RegionVid, BorrowIndex, LocationIndex, Local, MovePathIndex>;\n-\n crate struct Flows<'b, 'tcx> {\n     borrows: FlowAtLocation<'tcx, Borrows<'b, 'tcx>>,\n     pub uninits: FlowAtLocation<'tcx, MaybeUninitializedPlaces<'b, 'tcx>>,"}, {"sha": "a16c36d749f0d704d0d86a6987585d394417d734", "filename": "src/librustc_mir/borrow_check/nll/facts.rs", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/3ff17e7c5faf604dcbfcb96a786df78e80f7e4f4/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ffacts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ff17e7c5faf604dcbfcb96a786df78e80f7e4f4/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ffacts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ffacts.rs?ref=3ff17e7c5faf604dcbfcb96a786df78e80f7e4f4", "patch": "@@ -1,6 +1,6 @@\n use crate::borrow_check::location::{LocationIndex, LocationTable};\n use crate::dataflow::indexes::{BorrowIndex, MovePathIndex};\n-use polonius_engine::AllFacts as PoloniusAllFacts;\n+use polonius_engine::AllFacts as PoloniusFacts;\n use polonius_engine::Atom;\n use rustc::mir::Local;\n use rustc::ty::{RegionVid, TyCtxt};\n@@ -11,7 +11,18 @@ use std::fs::{self, File};\n use std::io::Write;\n use std::path::Path;\n \n-crate type AllFacts = PoloniusAllFacts<RegionVid, BorrowIndex, LocationIndex, Local, MovePathIndex>;\n+#[derive(Copy, Clone, Debug)]\n+crate struct RustcFacts;\n+\n+impl polonius_engine::FactTypes for RustcFacts {\n+    type Origin = RegionVid;\n+    type Loan = BorrowIndex;\n+    type Point = LocationIndex;\n+    type Variable = Local;\n+    type Path = MovePathIndex;\n+}\n+\n+crate type AllFacts = PoloniusFacts<RustcFacts>;\n \n crate trait AllFactsExt {\n     /// Returns `true` if there is a need to gather `AllFacts` given the\n@@ -55,6 +66,7 @@ impl AllFactsExt for AllFacts {\n             wr.write_facts_to_path(self.[\n                 borrow_region,\n                 universal_region,\n+                placeholder,\n                 cfg_edge,\n                 killed,\n                 outlives,\n@@ -69,6 +81,7 @@ impl AllFactsExt for AllFacts {\n                 initialized_at,\n                 moved_out_at,\n                 path_accessed_at,\n+                known_subset,\n             ])\n         }\n         Ok(())"}, {"sha": "bbcb823c8f91c003551c3f1b7d5bb19b46d13dd4", "filename": "src/librustc_mir/borrow_check/nll/mod.rs", "status": "modified", "additions": 49, "deletions": 8, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/3ff17e7c5faf604dcbfcb96a786df78e80f7e4f4/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ff17e7c5faf604dcbfcb96a786df78e80f7e4f4/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs?ref=3ff17e7c5faf604dcbfcb96a786df78e80f7e4f4", "patch": "@@ -1,10 +1,9 @@\n use crate::borrow_check::borrow_set::BorrowSet;\n-use crate::borrow_check::location::{LocationIndex, LocationTable};\n+use crate::borrow_check::location::LocationTable;\n use crate::borrow_check::nll::facts::AllFactsExt;\n use crate::borrow_check::nll::type_check::{MirTypeckResults, MirTypeckRegionConstraints};\n use crate::borrow_check::nll::region_infer::values::RegionValueElements;\n-use crate::dataflow::indexes::BorrowIndex;\n-use crate::dataflow::move_paths::{InitLocation, MoveData, MovePathIndex, InitKind};\n+use crate::dataflow::move_paths::{InitLocation, MoveData, InitKind};\n use crate::dataflow::FlowAtLocation;\n use crate::dataflow::MaybeInitializedPlaces;\n use crate::transform::MirSource;\n@@ -43,10 +42,12 @@ crate mod universal_regions;\n crate mod type_check;\n crate mod region_infer;\n \n-use self::facts::AllFacts;\n+use self::facts::{AllFacts, RustcFacts};\n use self::region_infer::RegionInferenceContext;\n use self::universal_regions::UniversalRegions;\n \n+crate type PoloniusOutput = Output<RustcFacts>;\n+\n /// Rewrites the regions in the MIR to use NLL variables, also\n /// scraping out the set of universal regions (e.g., region parameters)\n /// declared on the function. That set will need to be given to\n@@ -170,7 +171,7 @@ pub(in crate::borrow_check) fn compute_regions<'cx, 'tcx>(\n     errors_buffer: &mut Vec<Diagnostic>,\n ) -> (\n     RegionInferenceContext<'tcx>,\n-    Option<Rc<Output<RegionVid, BorrowIndex, LocationIndex, Local, MovePathIndex>>>,\n+    Option<Rc<PoloniusOutput>>,\n     Option<ClosureRegionRequirements<'tcx>>,\n ) {\n     let mut all_facts = AllFacts::enabled(infcx.tcx).then_some(AllFacts::default());\n@@ -204,6 +205,39 @@ pub(in crate::borrow_check) fn compute_regions<'cx, 'tcx>(\n             .universal_region\n             .extend(universal_regions.universal_regions());\n         populate_polonius_move_facts(all_facts, move_data, location_table, &body);\n+\n+        // Emit universal regions facts, and their relations, for Polonius.\n+        //\n+        // 1: universal regions are modeled in Polonius as a pair:\n+        // - the universal region vid itself.\n+        // - a \"placeholder loan\" associated to this universal region. Since they don't exist in\n+        //   the `borrow_set`, their `BorrowIndex` are synthesized as the universal region index\n+        //   added to the existing number of loans, as if they succeeded them in the set.\n+        //\n+        let borrow_count = borrow_set.borrows.len();\n+        debug!(\n+            \"compute_regions: polonius placeholders, num_universals={}, borrow_count={}\",\n+            universal_regions.len(),\n+            borrow_count\n+        );\n+\n+        for universal_region in universal_regions.universal_regions() {\n+            let universal_region_idx = universal_region.index();\n+            let placeholder_loan_idx = borrow_count + universal_region_idx;\n+            all_facts.placeholder.push((universal_region, placeholder_loan_idx.into()));\n+        }\n+\n+        // 2: the universal region relations `outlives` constraints are emitted as\n+        //  `known_subset` facts.\n+        for (fr1, fr2) in universal_region_relations.known_outlives() {\n+            if fr1 != fr2 {\n+                debug!(\n+                    \"compute_regions: emitting polonius `known_subset` fr1={:?}, fr2={:?}\",\n+                    fr1, fr2\n+                );\n+                all_facts.known_subset.push((*fr1, *fr2));\n+            }\n+        }\n     }\n \n     // Create the region inference context, taking ownership of the\n@@ -265,7 +299,7 @@ pub(in crate::borrow_check) fn compute_regions<'cx, 'tcx>(\n \n         if infcx.tcx.sess.opts.debugging_opts.polonius {\n             let algorithm = env::var(\"POLONIUS_ALGORITHM\")\n-                .unwrap_or_else(|_| String::from(\"Hybrid\"));\n+                .unwrap_or_else(|_| String::from(\"Naive\"));\n             let algorithm = Algorithm::from_str(&algorithm).unwrap();\n             debug!(\"compute_regions: using polonius algorithm {:?}\", algorithm);\n             Some(Rc::new(Output::compute(\n@@ -279,8 +313,15 @@ pub(in crate::borrow_check) fn compute_regions<'cx, 'tcx>(\n     });\n \n     // Solve the region constraints.\n-    let closure_region_requirements =\n-        regioncx.solve(infcx, &body, local_names, upvars, def_id, errors_buffer);\n+    let closure_region_requirements = regioncx.solve(\n+        infcx,\n+        &body,\n+        local_names,\n+        upvars,\n+        def_id,\n+        errors_buffer,\n+        polonius_output.clone(),\n+    );\n \n     // Dump MIR results into a file, if that is enabled. This let us\n     // write unit-tests, as well as helping with debugging."}, {"sha": "d62537b1ad46581e333d7b2122eea08b4ae27a0c", "filename": "src/librustc_mir/borrow_check/nll/region_infer/mod.rs", "status": "modified", "additions": 177, "deletions": 18, "changes": 195, "blob_url": "https://github.com/rust-lang/rust/blob/3ff17e7c5faf604dcbfcb96a786df78e80f7e4f4/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ff17e7c5faf604dcbfcb96a786df78e80f7e4f4/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs?ref=3ff17e7c5faf604dcbfcb96a786df78e80f7e4f4", "patch": "@@ -44,7 +44,7 @@ use crate::borrow_check::{\n \n use self::values::{LivenessValues, RegionValueElements, RegionValues};\n use super::universal_regions::UniversalRegions;\n-use super::ToRegionVid;\n+use super::{PoloniusOutput, ToRegionVid};\n \n mod dump_mir;\n mod graphviz;\n@@ -484,6 +484,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         upvars: &[Upvar],\n         mir_def_id: DefId,\n         errors_buffer: &mut Vec<Diagnostic>,\n+        polonius_output: Option<Rc<PoloniusOutput>>,\n     ) -> Option<ClosureRegionRequirements<'tcx>> {\n         self.propagate_constraints(body);\n \n@@ -509,16 +510,33 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         // multiple problems.\n         let mut region_naming = RegionErrorNamingCtx::new();\n \n-        self.check_universal_regions(\n-            infcx,\n-            body,\n-            local_names,\n-            upvars,\n-            mir_def_id,\n-            outlives_requirements.as_mut(),\n-            errors_buffer,\n-            &mut region_naming,\n-        );\n+        // In Polonius mode, the errors about missing universal region relations are in the output\n+        // and need to be emitted or propagated. Otherwise, we need to check whether the\n+        // constraints were too strong, and if so, emit or propagate those errors.\n+        if infcx.tcx.sess.opts.debugging_opts.polonius {\n+            self.check_polonius_subset_errors(\n+                infcx,\n+                body,\n+                local_names,\n+                upvars,\n+                mir_def_id,\n+                outlives_requirements.as_mut(),\n+                errors_buffer,\n+                &mut region_naming,\n+                polonius_output.expect(\"Polonius output is unavailable despite `-Z polonius`\"),\n+            );\n+        } else {\n+            self.check_universal_regions(\n+                infcx,\n+                body,\n+                local_names,\n+                upvars,\n+                mir_def_id,\n+                outlives_requirements.as_mut(),\n+                errors_buffer,\n+                &mut region_naming,\n+            );\n+        }\n \n         self.check_member_constraints(infcx, mir_def_id, errors_buffer);\n \n@@ -1372,6 +1390,114 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         outlives_suggestion.add_suggestion(body, self, infcx, errors_buffer, region_naming);\n     }\n \n+    /// Checks if Polonius has found any unexpected free region relations.\n+    ///\n+    /// In Polonius terms, a \"subset error\" (or \"illegal subset relation error\") is the equivalent\n+    /// of NLL's \"checking if any region constraints were too strong\": a placeholder origin `'a`\n+    /// was unexpectedly found to be a subset of another placeholder origin `'b`, and means in NLL\n+    /// terms that the \"longer free region\" `'a` outlived the \"shorter free region\" `'b`.\n+    ///\n+    /// More details can be found in this blog post by Niko:\n+    /// http://smallcultfollowing.com/babysteps/blog/2019/01/17/polonius-and-region-errors/\n+    ///\n+    /// In the canonical example\n+    ///\n+    ///     fn foo<'a, 'b>(x: &'a u32) -> &'b u32 { x }\n+    ///\n+    /// returning `x` requires `&'a u32 <: &'b u32` and hence we establish (transitively) a\n+    /// constraint that `'a: 'b`. It is an error that we have no evidence that this\n+    /// constraint holds.\n+    ///\n+    /// If `propagated_outlives_requirements` is `Some`, then we will\n+    /// push unsatisfied obligations into there. Otherwise, we'll\n+    /// report them as errors.\n+    fn check_polonius_subset_errors(\n+        &self,\n+        infcx: &InferCtxt<'_, 'tcx>,\n+        body: &Body<'tcx>,\n+        local_names: &IndexVec<Local, Option<Symbol>>,\n+        upvars: &[Upvar],\n+        mir_def_id: DefId,\n+        mut propagated_outlives_requirements: Option<&mut Vec<ClosureOutlivesRequirement<'tcx>>>,\n+        errors_buffer: &mut Vec<Diagnostic>,\n+        region_naming: &mut RegionErrorNamingCtx,\n+        polonius_output: Rc<PoloniusOutput>,\n+    ) {\n+        debug!(\n+            \"check_polonius_subset_errors: {} subset_errors\",\n+            polonius_output.subset_errors.len()\n+        );\n+\n+        let mut outlives_suggestion = OutlivesSuggestionBuilder::new(mir_def_id, local_names);\n+\n+        // Similarly to `check_universal_regions`: a free region relation, which was not explicitly\n+        // declared (\"known\") was found by Polonius, so emit an error, or propagate the\n+        // requirements for our caller into the `propagated_outlives_requirements` vector.\n+        //\n+        // Polonius doesn't model regions (\"origins\") as CFG-subsets or durations, but the\n+        // `longer_fr` and `shorter_fr` terminology will still be used here, for consistency with\n+        // the rest of the NLL infrastructure. The \"subset origin\" is the \"longer free region\",\n+        // and the \"superset origin\" is the outlived \"shorter free region\".\n+        //\n+        // Note: Polonius will produce a subset error at every point where the unexpected\n+        // `longer_fr`'s \"placeholder loan\" is contained in the `shorter_fr`. This can be helpful\n+        // for diagnostics in the future, e.g. to point more precisely at the key locations\n+        // requiring this constraint to hold. However, the error and diagnostics code downstream\n+        // expects that these errors are not duplicated (and that they are in a certain order).\n+        // Otherwise, diagnostics messages such as the ones giving names like `'1` to elided or\n+        // anonymous lifetimes for example, could give these names differently, while others like\n+        // the outlives suggestions or the debug output from `#[rustc_regions]` would be\n+        // duplicated. The polonius subset errors are deduplicated here, while keeping the\n+        // CFG-location ordering.\n+        let mut subset_errors: Vec<_> = polonius_output\n+            .subset_errors\n+            .iter()\n+            .flat_map(|(_location, subset_errors)| subset_errors.iter())\n+            .collect();\n+        subset_errors.sort();\n+        subset_errors.dedup();\n+\n+        for (longer_fr, shorter_fr) in subset_errors.into_iter() {\n+            debug!(\"check_polonius_subset_errors: subset_error longer_fr={:?},\\\n+                shorter_fr={:?}\", longer_fr, shorter_fr);\n+\n+            self.report_or_propagate_universal_region_error(\n+                *longer_fr,\n+                *shorter_fr,\n+                infcx,\n+                body,\n+                local_names,\n+                upvars,\n+                mir_def_id,\n+                &mut propagated_outlives_requirements,\n+                &mut outlives_suggestion,\n+                errors_buffer,\n+                region_naming,\n+            );\n+        }\n+\n+        // Handle the placeholder errors as usual, until the chalk-rustc-polonius triumvirate has\n+        // a more complete picture on how to separate this responsibility.\n+        for (fr, fr_definition) in self.definitions.iter_enumerated() {\n+            match fr_definition.origin {\n+                NLLRegionVariableOrigin::FreeRegion => {\n+                    // handled by polonius above\n+                }\n+\n+                NLLRegionVariableOrigin::Placeholder(placeholder) => {\n+                    self.check_bound_universal_region(infcx, body, mir_def_id, fr, placeholder);\n+                }\n+\n+                NLLRegionVariableOrigin::Existential { .. } => {\n+                    // nothing to check here\n+                }\n+            }\n+        }\n+\n+        // Emit outlives suggestions\n+        outlives_suggestion.add_suggestion(body, self, infcx, errors_buffer, region_naming);\n+    }\n+\n     /// Checks the final value for the free region `fr` to see if it\n     /// grew too large. In particular, examine what `end(X)` points\n     /// wound up in `fr`'s final value; for each `end(X)` where `X !=\n@@ -1471,8 +1597,37 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             return None;\n         }\n \n+        self.report_or_propagate_universal_region_error(\n+            longer_fr,\n+            shorter_fr,\n+            infcx,\n+            body,\n+            local_names,\n+            upvars,\n+            mir_def_id,\n+            propagated_outlives_requirements,\n+            outlives_suggestion,\n+            errors_buffer,\n+            region_naming,\n+        )\n+    }\n+\n+    fn report_or_propagate_universal_region_error(\n+        &self,\n+        longer_fr: RegionVid,\n+        shorter_fr: RegionVid,\n+        infcx: &InferCtxt<'_, 'tcx>,\n+        body: &Body<'tcx>,\n+        local_names: &IndexVec<Local, Option<Symbol>>,\n+        upvars: &[Upvar],\n+        mir_def_id: DefId,\n+        propagated_outlives_requirements: &mut Option<&mut Vec<ClosureOutlivesRequirement<'tcx>>>,\n+        outlives_suggestion: &mut OutlivesSuggestionBuilder<'_>,\n+        errors_buffer: &mut Vec<Diagnostic>,\n+        region_naming: &mut RegionErrorNamingCtx,\n+    ) -> Option<ErrorReported> {\n         debug!(\n-            \"check_universal_region_relation: fr={:?} does not outlive shorter_fr={:?}\",\n+            \"report_or_propagate_universal_region_error: fr={:?} does not outlive shorter_fr={:?}\",\n             longer_fr, shorter_fr,\n         );\n \n@@ -1481,9 +1636,9 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             // We'll call it `fr-` -- it's ever so slightly smaller than\n             // `longer_fr`.\n \n-            if let Some(fr_minus) = self.universal_region_relations.non_local_lower_bound(longer_fr)\n-            {\n-                debug!(\"check_universal_region: fr_minus={:?}\", fr_minus);\n+            if let Some(fr_minus) =\n+                self.universal_region_relations.non_local_lower_bound(longer_fr) {\n+                debug!(\"report_or_propagate_universal_region_error: fr_minus={:?}\", fr_minus);\n \n                 let blame_span_category =\n                     self.find_outlives_blame_span(body, longer_fr,\n@@ -1492,9 +1647,13 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                 // Grow `shorter_fr` until we find some non-local regions. (We\n                 // always will.)  We'll call them `shorter_fr+` -- they're ever\n                 // so slightly larger than `shorter_fr`.\n-                let shorter_fr_plus =\n-                    self.universal_region_relations.non_local_upper_bounds(&shorter_fr);\n-                debug!(\"check_universal_region: shorter_fr_plus={:?}\", shorter_fr_plus);\n+                let shorter_fr_plus = self\n+                    .universal_region_relations\n+                    .non_local_upper_bounds(&shorter_fr);\n+                debug!(\n+                    \"report_or_propagate_universal_region_error: shorter_fr_plus={:?}\",\n+                    shorter_fr_plus\n+                );\n                 for &&fr in &shorter_fr_plus {\n                     // Push the constraint `fr-: shorter_fr+`\n                     propagated_outlives_requirements.push(ClosureOutlivesRequirement {"}, {"sha": "8bb68383a49baa3da6d18db7ae1bb495336b3af8", "filename": "src/librustc_mir/borrow_check/nll/type_check/free_region_relations.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3ff17e7c5faf604dcbfcb96a786df78e80f7e4f4/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Ffree_region_relations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ff17e7c5faf604dcbfcb96a786df78e80f7e4f4/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Ffree_region_relations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Ffree_region_relations.rs?ref=3ff17e7c5faf604dcbfcb96a786df78e80f7e4f4", "patch": "@@ -217,6 +217,11 @@ impl UniversalRegionRelations<'tcx> {\n     crate fn regions_outlived_by(&self, fr1: RegionVid) -> Vec<&RegionVid> {\n         self.outlives.reachable_from(&fr1)\n     }\n+\n+    /// Returns the _non-transitive_ set of known `outlives` constraints between free regions.\n+    crate fn known_outlives(&self) -> impl Iterator<Item=(&RegionVid, &RegionVid)> {\n+        self.outlives.base_edges()\n+    }\n }\n \n struct UniversalRegionRelationsBuilder<'this, 'tcx> {"}, {"sha": "2a7461fb469b271181f736bfb8d1fc55966143cf", "filename": "src/test/ui/closures/closure-expected-type/expect-region-supply-region.polonius.stderr", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/3ff17e7c5faf604dcbfcb96a786df78e80f7e4f4/src%2Ftest%2Fui%2Fclosures%2Fclosure-expected-type%2Fexpect-region-supply-region.polonius.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3ff17e7c5faf604dcbfcb96a786df78e80f7e4f4/src%2Ftest%2Fui%2Fclosures%2Fclosure-expected-type%2Fexpect-region-supply-region.polonius.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2Fclosure-expected-type%2Fexpect-region-supply-region.polonius.stderr?ref=3ff17e7c5faf604dcbfcb96a786df78e80f7e4f4", "patch": "@@ -0,0 +1,56 @@\n+error[E0521]: borrowed data escapes outside of closure\n+  --> $DIR/expect-region-supply-region.rs:18:9\n+   |\n+LL |     let mut f: Option<&u32> = None;\n+   |         ----- `f` is declared here, outside of the closure body\n+LL |     closure_expecting_bound(|x| {\n+   |                              - `x` is a reference that is only valid in the closure body\n+LL |         f = Some(x);\n+   |         ^^^^^^^^^^^ `x` escapes the closure body here\n+\n+error[E0521]: borrowed data escapes outside of closure\n+  --> $DIR/expect-region-supply-region.rs:28:9\n+   |\n+LL |     let mut f: Option<&u32> = None;\n+   |         ----- `f` is declared here, outside of the closure body\n+LL |     closure_expecting_bound(|x: &u32| {\n+   |                              - `x` is a reference that is only valid in the closure body\n+LL |         f = Some(x);\n+   |         ^^^^^^^^^^^ `x` escapes the closure body here\n+\n+error: lifetime may not live long enough\n+  --> $DIR/expect-region-supply-region.rs:37:30\n+   |\n+LL | fn expect_bound_supply_named<'x>() {\n+   |                              -- lifetime `'x` defined here\n+...\n+LL |     closure_expecting_bound(|x: &'x u32| {\n+   |                              ^  - let's call the lifetime of this reference `'1`\n+   |                              |\n+   |                              requires that `'1` must outlive `'x`\n+\n+error[E0521]: borrowed data escapes outside of closure\n+  --> $DIR/expect-region-supply-region.rs:42:9\n+   |\n+LL |     let mut f: Option<&u32> = None;\n+   |         ----- `f` is declared here, outside of the closure body\n+...\n+LL |     closure_expecting_bound(|x: &'x u32| {\n+   |                              - `x` is a reference that is only valid in the closure body\n+...\n+LL |         f = Some(x);\n+   |         ^^^^^^^^^^^ `x` escapes the closure body here\n+\n+error: lifetime may not live long enough\n+  --> $DIR/expect-region-supply-region.rs:37:30\n+   |\n+LL | fn expect_bound_supply_named<'x>() {\n+   |                              -- lifetime `'x` defined here\n+...\n+LL |     closure_expecting_bound(|x: &'x u32| {\n+   |                              ^ requires that `'x` must outlive `'static`\n+   |\n+   = help: consider replacing `'x` with `'static`\n+\n+error: aborting due to 5 previous errors\n+"}, {"sha": "558d643cde8958a29af8658a93f88baad8860fa9", "filename": "src/test/ui/hrtb/hrtb-perfect-forwarding.polonius.stderr", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/3ff17e7c5faf604dcbfcb96a786df78e80f7e4f4/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-perfect-forwarding.polonius.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3ff17e7c5faf604dcbfcb96a786df78e80f7e4f4/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-perfect-forwarding.polonius.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-perfect-forwarding.polonius.stderr?ref=3ff17e7c5faf604dcbfcb96a786df78e80f7e4f4", "patch": "@@ -0,0 +1,68 @@\n+warning: function cannot return without recursing\n+  --> $DIR/hrtb-perfect-forwarding.rs:22:1\n+   |\n+LL | / fn no_hrtb<'b,T>(mut t: T)\n+LL | |     where T : Bar<&'b isize>\n+LL | | {\n+LL | |     // OK -- `T : Bar<&'b isize>`, and thus the impl above ensures that\n+LL | |     // `&mut T : Bar<&'b isize>`.\n+LL | |     no_hrtb(&mut t);\n+   | |     --------------- recursive call site\n+LL | | }\n+   | |_^ cannot return without recursing\n+   |\n+   = note: `#[warn(unconditional_recursion)]` on by default\n+   = help: a `loop` may express intention better if this is on purpose\n+\n+warning: function cannot return without recursing\n+  --> $DIR/hrtb-perfect-forwarding.rs:30:1\n+   |\n+LL | / fn bar_hrtb<T>(mut t: T)\n+LL | |     where T : for<'b> Bar<&'b isize>\n+LL | | {\n+LL | |     // OK -- `T : for<'b> Bar<&'b isize>`, and thus the impl above\n+...  |\n+LL | |     bar_hrtb(&mut t);\n+   | |     ---------------- recursive call site\n+LL | | }\n+   | |_^ cannot return without recursing\n+   |\n+   = help: a `loop` may express intention better if this is on purpose\n+\n+warning: function cannot return without recursing\n+  --> $DIR/hrtb-perfect-forwarding.rs:39:1\n+   |\n+LL | / fn foo_hrtb_bar_not<'b,T>(mut t: T)\n+LL | |     where T : for<'a> Foo<&'a isize> + Bar<&'b isize>\n+LL | | {\n+LL | |     // Not OK -- The forwarding impl for `Foo` requires that `Bar` also\n+...  |\n+LL | |     foo_hrtb_bar_not(&mut t);\n+   | |     ------------------------ recursive call site\n+LL | | }\n+   | |_^ cannot return without recursing\n+   |\n+   = help: a `loop` may express intention better if this is on purpose\n+\n+error: higher-ranked subtype error\n+  --> $DIR/hrtb-perfect-forwarding.rs:46:5\n+   |\n+LL |     foo_hrtb_bar_not(&mut t);\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+warning: function cannot return without recursing\n+  --> $DIR/hrtb-perfect-forwarding.rs:49:1\n+   |\n+LL | / fn foo_hrtb_bar_hrtb<T>(mut t: T)\n+LL | |     where T : for<'a> Foo<&'a isize> + for<'b> Bar<&'b isize>\n+LL | | {\n+LL | |     // OK -- now we have `T : for<'b> Bar&'b isize>`.\n+LL | |     foo_hrtb_bar_hrtb(&mut t);\n+   | |     ------------------------- recursive call site\n+LL | | }\n+   | |_^ cannot return without recursing\n+   |\n+   = help: a `loop` may express intention better if this is on purpose\n+\n+error: aborting due to previous error\n+"}, {"sha": "72e8fa33d7b4d04c0bb9db797ee5e83448ea6586", "filename": "src/test/ui/impl-trait/multiple-lifetimes/error-handling.polonius.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3ff17e7c5faf604dcbfcb96a786df78e80f7e4f4/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Ferror-handling.polonius.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3ff17e7c5faf604dcbfcb96a786df78e80f7e4f4/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Ferror-handling.polonius.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Ferror-handling.polonius.stderr?ref=3ff17e7c5faf604dcbfcb96a786df78e80f7e4f4", "patch": "@@ -0,0 +1,12 @@\n+error: lifetime may not live long enough\n+  --> $DIR/error-handling.rs:13:56\n+   |\n+LL | fn foo<'a, 'b, 'c>(x: &'static i32, mut y: &'a i32) -> E<'b, 'c> {\n+   |        --  -- lifetime `'b` defined here               ^^^^^^^^^ opaque type requires that `'a` must outlive `'b`\n+   |        |\n+   |        lifetime `'a` defined here\n+   |\n+   = help: consider adding the following bound: `'a: 'b`\n+\n+error: aborting due to previous error\n+"}, {"sha": "815744618f62c69e2b51b8157c0bc405b0f74621", "filename": "src/test/ui/nll/outlives-suggestion-simple.polonius.stderr", "status": "added", "additions": 121, "deletions": 0, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/3ff17e7c5faf604dcbfcb96a786df78e80f7e4f4/src%2Ftest%2Fui%2Fnll%2Foutlives-suggestion-simple.polonius.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3ff17e7c5faf604dcbfcb96a786df78e80f7e4f4/src%2Ftest%2Fui%2Fnll%2Foutlives-suggestion-simple.polonius.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Foutlives-suggestion-simple.polonius.stderr?ref=3ff17e7c5faf604dcbfcb96a786df78e80f7e4f4", "patch": "@@ -0,0 +1,121 @@\n+error: lifetime may not live long enough\n+  --> $DIR/outlives-suggestion-simple.rs:6:5\n+   |\n+LL | fn foo1<'a, 'b>(x: &'a usize) -> &'b usize {\n+   |         --  -- lifetime `'b` defined here\n+   |         |\n+   |         lifetime `'a` defined here\n+LL |     x\n+   |     ^ returning this value requires that `'a` must outlive `'b`\n+   |\n+   = help: consider adding the following bound: `'a: 'b`\n+\n+error: lifetime may not live long enough\n+  --> $DIR/outlives-suggestion-simple.rs:10:5\n+   |\n+LL | fn foo2<'a>(x: &'a usize) -> &'static usize {\n+   |         -- lifetime `'a` defined here\n+LL |     x\n+   |     ^ returning this value requires that `'a` must outlive `'static`\n+   |\n+   = help: consider replacing `'a` with `'static`\n+\n+error: lifetime may not live long enough\n+  --> $DIR/outlives-suggestion-simple.rs:14:5\n+   |\n+LL | fn foo3<'a, 'b>(x: &'a usize, y: &'b usize) -> (&'b usize, &'a usize) {\n+   |         --  -- lifetime `'b` defined here\n+   |         |\n+   |         lifetime `'a` defined here\n+LL |     (x, y)\n+   |     ^^^^^^ function was supposed to return data with lifetime `'b` but it is returning data with lifetime `'a`\n+   |\n+   = help: consider adding the following bound: `'a: 'b`\n+\n+error: lifetime may not live long enough\n+  --> $DIR/outlives-suggestion-simple.rs:14:5\n+   |\n+LL | fn foo3<'a, 'b>(x: &'a usize, y: &'b usize) -> (&'b usize, &'a usize) {\n+   |         --  -- lifetime `'b` defined here\n+   |         |\n+   |         lifetime `'a` defined here\n+LL |     (x, y)\n+   |     ^^^^^^ function was supposed to return data with lifetime `'a` but it is returning data with lifetime `'b`\n+   |\n+   = help: consider adding the following bound: `'b: 'a`\n+\n+help: `'a` and `'b` must be the same: replace one with the other\n+\n+error: lifetime may not live long enough\n+  --> $DIR/outlives-suggestion-simple.rs:22:5\n+   |\n+LL | fn foo4<'a, 'b, 'c>(x: &'a usize) -> (&'b usize, &'c usize) {\n+   |         --  -- lifetime `'b` defined here\n+   |         |\n+   |         lifetime `'a` defined here\n+...\n+LL |     (x, x)\n+   |     ^^^^^^ returning this value requires that `'a` must outlive `'b`\n+   |\n+   = help: consider adding the following bound: `'a: 'b`\n+\n+error: lifetime may not live long enough\n+  --> $DIR/outlives-suggestion-simple.rs:22:5\n+   |\n+LL | fn foo4<'a, 'b, 'c>(x: &'a usize) -> (&'b usize, &'c usize) {\n+   |         --      -- lifetime `'c` defined here\n+   |         |\n+   |         lifetime `'a` defined here\n+...\n+LL |     (x, x)\n+   |     ^^^^^^ returning this value requires that `'a` must outlive `'c`\n+   |\n+   = help: consider adding the following bound: `'a: 'c`\n+\n+error: lifetime may not live long enough\n+  --> $DIR/outlives-suggestion-simple.rs:31:9\n+   |\n+LL |     pub fn foo<'a>(x: &'a usize) -> Self {\n+   |                -- lifetime `'a` defined here\n+LL |         Foo { x }\n+   |         ^^^^^^^^^ returning this value requires that `'a` must outlive `'static`\n+   |\n+   = help: consider replacing `'a` with `'static`\n+\n+error: lifetime may not live long enough\n+  --> $DIR/outlives-suggestion-simple.rs:41:9\n+   |\n+LL | impl<'a> Bar<'a> {\n+   |      -- lifetime `'a` defined here\n+LL |     pub fn get<'b>(&self) -> &'b usize {\n+   |                -- lifetime `'b` defined here\n+LL |         self.x\n+   |         ^^^^^^ returning this value requires that `'a` must outlive `'b`\n+   |\n+   = help: consider adding the following bound: `'a: 'b`\n+\n+error: lifetime may not live long enough\n+  --> $DIR/outlives-suggestion-simple.rs:52:9\n+   |\n+LL | impl<'a> Baz<'a> {\n+   |      -- lifetime `'a` defined here\n+LL |     fn get<'b>(&'b self) -> &'a i32 {\n+   |            -- lifetime `'b` defined here\n+LL |         self.x\n+   |         ^^^^^^ returning this value requires that `'b` must outlive `'a`\n+   |\n+   = help: consider adding the following bound: `'b: 'a`\n+\n+error[E0521]: borrowed data escapes outside of function\n+  --> $DIR/outlives-suggestion-simple.rs:73:9\n+   |\n+LL |     fn get_bar(&self) -> Bar2 {\n+   |                -----\n+   |                |\n+   |                `self` is declared here, outside of the function body\n+   |                `self` is a reference that is only valid in the function body\n+LL |         Bar2::new(&self)\n+   |         ^^^^^^^^^^^^^^^^ `self` escapes the function body here\n+\n+error: aborting due to 10 previous errors\n+"}, {"sha": "3f6f67ebf4030084cfa22be2421c8dcf49fbae3d", "filename": "src/test/ui/nll/polonius/subset-relations.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/3ff17e7c5faf604dcbfcb96a786df78e80f7e4f4/src%2Ftest%2Fui%2Fnll%2Fpolonius%2Fsubset-relations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ff17e7c5faf604dcbfcb96a786df78e80f7e4f4/src%2Ftest%2Fui%2Fnll%2Fpolonius%2Fsubset-relations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fpolonius%2Fsubset-relations.rs?ref=3ff17e7c5faf604dcbfcb96a786df78e80f7e4f4", "patch": "@@ -0,0 +1,30 @@\n+// Checks that Polonius can compute cases of universal regions errors:\n+// \"illegal subset relation errors\", cases where analysis finds that\n+// two free regions outlive each other, without any evidence that this\n+// relation holds.\n+\n+// ignore-compare-mode-nll\n+// compile-flags: -Z borrowck=mir -Zpolonius\n+\n+// returning `y` requires that `'b: 'a`, but it's not known to be true\n+fn missing_subset<'a, 'b>(x: &'a u32, y: &'b u32) -> &'a u32 {\n+    y //~ ERROR\n+}\n+\n+// `'b: 'a` is explicitly declared\n+fn valid_subset<'a, 'b: 'a>(x: &'a u32, y: &'b u32) -> &'a u32 {\n+    y\n+}\n+\n+// because of `x`, it is implied that `'b: 'a` holds\n+fn implied_bounds_subset<'a, 'b>(x: &'a &'b mut u32) -> &'a u32 {\n+    x\n+}\n+\n+// `'b: 'a` is declared, and `'a: 'c` is known via implied bounds:\n+// `'b: 'c` is therefore known to hold transitively\n+fn transitively_valid_subset<'a, 'b: 'a, 'c>(x: &'c &'a u32, y: &'b u32) -> &'c u32  {\n+    y\n+}\n+\n+fn main() {}"}, {"sha": "63645106f82c169dc1f4ee2585bebc4e7066d692", "filename": "src/test/ui/nll/polonius/subset-relations.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3ff17e7c5faf604dcbfcb96a786df78e80f7e4f4/src%2Ftest%2Fui%2Fnll%2Fpolonius%2Fsubset-relations.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3ff17e7c5faf604dcbfcb96a786df78e80f7e4f4/src%2Ftest%2Fui%2Fnll%2Fpolonius%2Fsubset-relations.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fpolonius%2Fsubset-relations.stderr?ref=3ff17e7c5faf604dcbfcb96a786df78e80f7e4f4", "patch": "@@ -0,0 +1,14 @@\n+error: lifetime may not live long enough\n+  --> $DIR/subset-relations.rs:11:5\n+   |\n+LL | fn missing_subset<'a, 'b>(x: &'a u32, y: &'b u32) -> &'a u32 {\n+   |                   --  -- lifetime `'b` defined here\n+   |                   |\n+   |                   lifetime `'a` defined here\n+LL |     y\n+   |     ^ function was supposed to return data with lifetime `'a` but it is returning data with lifetime `'b`\n+   |\n+   = help: consider adding the following bound: `'b: 'a`\n+\n+error: aborting due to previous error\n+"}, {"sha": "d5bcdf64441712fd341f95ac6300f0d47172ecdf", "filename": "src/test/ui/nll/user-annotations/closure-substs.polonius.stderr", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/3ff17e7c5faf604dcbfcb96a786df78e80f7e4f4/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fclosure-substs.polonius.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3ff17e7c5faf604dcbfcb96a786df78e80f7e4f4/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fclosure-substs.polonius.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fclosure-substs.polonius.stderr?ref=3ff17e7c5faf604dcbfcb96a786df78e80f7e4f4", "patch": "@@ -0,0 +1,60 @@\n+error: lifetime may not live long enough\n+  --> $DIR/closure-substs.rs:8:16\n+   |\n+LL | fn foo<'a>() {\n+   |        -- lifetime `'a` defined here\n+...\n+LL |         return x;\n+   |                ^ returning this value requires that `'a` must outlive `'static`\n+   |\n+   = help: consider replacing `'a` with `'static`\n+\n+error: lifetime may not live long enough\n+  --> $DIR/closure-substs.rs:15:16\n+   |\n+LL |     |x: &i32| -> &'static i32 {\n+   |         - let's call the lifetime of this reference `'1`\n+LL |         return x;\n+   |                ^ returning this value requires that `'1` must outlive `'static`\n+\n+error: lifetime may not live long enough\n+  --> $DIR/closure-substs.rs:15:16\n+   |\n+LL |     |x: &i32| -> &'static i32 {\n+   |         -        ------------ return type of closure is &'2 i32\n+   |         |\n+   |         let's call the lifetime of this reference `'1`\n+LL |         return x;\n+   |                ^ returning this value requires that `'1` must outlive `'2`\n+\n+error: lifetime may not live long enough\n+  --> $DIR/closure-substs.rs:22:9\n+   |\n+LL | fn bar<'a>() {\n+   |        -- lifetime `'a` defined here\n+...\n+LL |         b(x);\n+   |         ^^^^ argument requires that `'a` must outlive `'static`\n+   |\n+   = help: consider replacing `'a` with `'static`\n+\n+error[E0521]: borrowed data escapes outside of closure\n+  --> $DIR/closure-substs.rs:29:9\n+   |\n+LL |     |x: &i32, b: fn(&'static i32)| {\n+   |      - `x` is a reference that is only valid in the closure body\n+LL |         b(x);\n+   |         ^^^^ `x` escapes the closure body here\n+\n+error[E0521]: borrowed data escapes outside of closure\n+  --> $DIR/closure-substs.rs:29:9\n+   |\n+LL |     |x: &i32, b: fn(&'static i32)| {\n+   |      -        - `b` is declared here, outside of the closure body\n+   |      |\n+   |      `x` is a reference that is only valid in the closure body\n+LL |         b(x);\n+   |         ^^^^ `x` escapes the closure body here\n+\n+error: aborting due to 6 previous errors\n+"}]}