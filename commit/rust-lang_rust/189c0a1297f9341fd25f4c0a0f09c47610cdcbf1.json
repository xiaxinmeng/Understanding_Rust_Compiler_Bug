{"sha": "189c0a1297f9341fd25f4c0a0f09c47610cdcbf1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE4OWMwYTEyOTdmOTM0MWZkMjVmNGMwYTBmMDljNDc2MTBjZGNiZjE=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2018-05-25T23:50:15Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2018-05-26T11:41:58Z"}, "message": "Use `Ident`s for fields in HIR", "tree": {"sha": "0bf238c902c11160f73a346737661493b16e825c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0bf238c902c11160f73a346737661493b16e825c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/189c0a1297f9341fd25f4c0a0f09c47610cdcbf1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/189c0a1297f9341fd25f4c0a0f09c47610cdcbf1", "html_url": "https://github.com/rust-lang/rust/commit/189c0a1297f9341fd25f4c0a0f09c47610cdcbf1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/189c0a1297f9341fd25f4c0a0f09c47610cdcbf1/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "444a9c3f1afad7585e7a65a05dbea8025a67b675", "url": "https://api.github.com/repos/rust-lang/rust/commits/444a9c3f1afad7585e7a65a05dbea8025a67b675", "html_url": "https://github.com/rust-lang/rust/commit/444a9c3f1afad7585e7a65a05dbea8025a67b675"}], "stats": {"total": 316, "additions": 167, "deletions": 149}, "files": [{"sha": "5a49ee30d9c70c5dc1090bd48b349f5eb64cf34f", "filename": "src/librustc/hir/intravisit.rs", "status": "modified", "additions": 13, "deletions": 6, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/189c0a1297f9341fd25f4c0a0f09c47610cdcbf1/src%2Flibrustc%2Fhir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189c0a1297f9341fd25f4c0a0f09c47610cdcbf1/src%2Flibrustc%2Fhir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fintravisit.rs?ref=189c0a1297f9341fd25f4c0a0f09c47610cdcbf1", "patch": "@@ -42,7 +42,7 @@\n //! example generator inference, and possibly also HIR borrowck.\n \n use rustc_target::spec::abi::Abi;\n-use syntax::ast::{NodeId, CRATE_NODE_ID, Name, Attribute};\n+use syntax::ast::{NodeId, CRATE_NODE_ID, Ident, Name, Attribute};\n use syntax_pos::Span;\n use hir::*;\n use hir::def::Def;\n@@ -248,6 +248,9 @@ pub trait Visitor<'v> : Sized {\n     fn visit_name(&mut self, _span: Span, _name: Name) {\n         // Nothing to do.\n     }\n+    fn visit_ident(&mut self, ident: Ident) {\n+        walk_ident(self, ident)\n+    }\n     fn visit_mod(&mut self, m: &'v Mod, _s: Span, n: NodeId) {\n         walk_mod(self, m, n)\n     }\n@@ -413,6 +416,10 @@ pub fn walk_local<'v, V: Visitor<'v>>(visitor: &mut V, local: &'v Local) {\n     walk_list!(visitor, visit_ty, &local.ty);\n }\n \n+pub fn walk_ident<'v, V: Visitor<'v>>(visitor: &mut V, ident: Ident) {\n+    visitor.visit_name(ident.span, ident.name);\n+}\n+\n pub fn walk_label<'v, V: Visitor<'v>>(visitor: &mut V, label: &'v Label) {\n     visitor.visit_name(label.span, label.name);\n }\n@@ -662,7 +669,7 @@ pub fn walk_pat<'v, V: Visitor<'v>>(visitor: &mut V, pattern: &'v Pat) {\n             visitor.visit_qpath(qpath, pattern.id, pattern.span);\n             for field in fields {\n                 visitor.visit_id(field.node.id);\n-                visitor.visit_name(field.span, field.node.name);\n+                visitor.visit_ident(field.node.ident);\n                 visitor.visit_pat(&field.node.pat)\n             }\n         }\n@@ -915,7 +922,7 @@ pub fn walk_struct_def<'v, V: Visitor<'v>>(visitor: &mut V, struct_definition: &\n pub fn walk_struct_field<'v, V: Visitor<'v>>(visitor: &mut V, struct_field: &'v StructField) {\n     visitor.visit_id(struct_field.id);\n     visitor.visit_vis(&struct_field.vis);\n-    visitor.visit_name(struct_field.span, struct_field.name);\n+    visitor.visit_ident(struct_field.ident);\n     visitor.visit_ty(&struct_field.ty);\n     walk_list!(visitor, visit_attribute, &struct_field.attrs);\n }\n@@ -970,7 +977,7 @@ pub fn walk_expr<'v, V: Visitor<'v>>(visitor: &mut V, expression: &'v Expr) {\n             visitor.visit_qpath(qpath, expression.id, expression.span);\n             for field in fields {\n                 visitor.visit_id(field.id);\n-                visitor.visit_name(field.name.span, field.name.node);\n+                visitor.visit_ident(field.ident);\n                 visitor.visit_expr(&field.expr)\n             }\n             walk_list!(visitor, visit_expr, optional_base);\n@@ -1035,9 +1042,9 @@ pub fn walk_expr<'v, V: Visitor<'v>>(visitor: &mut V, expression: &'v Expr) {\n             visitor.visit_expr(right_expression);\n             visitor.visit_expr(left_expression)\n         }\n-        ExprField(ref subexpression, ref name) => {\n+        ExprField(ref subexpression, ident) => {\n             visitor.visit_expr(subexpression);\n-            visitor.visit_name(name.span, name.node);\n+            visitor.visit_ident(ident);\n         }\n         ExprIndex(ref main_expression, ref index_expression) => {\n             visitor.visit_expr(main_expression);"}, {"sha": "e9563a8a9e2d6e849ccdbdff9ee1e18aadffd8ce", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/189c0a1297f9341fd25f4c0a0f09c47610cdcbf1/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189c0a1297f9341fd25f4c0a0f09c47610cdcbf1/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=189c0a1297f9341fd25f4c0a0f09c47610cdcbf1", "patch": "@@ -2093,11 +2093,11 @@ impl<'a> LoweringContext<'a> {\n         hir::StructField {\n             span: f.span,\n             id: self.lower_node_id(f.id).node_id,\n-            name: self.lower_ident(match f.ident {\n+            ident: match f.ident {\n                 Some(ident) => ident,\n                 // FIXME(jseyfried) positional field hygiene\n                 None => Ident::new(Symbol::intern(&index.to_string()), f.span),\n-            }),\n+            },\n             vis: self.lower_visibility(&f.vis, None),\n             ty: self.lower_ty(&f.ty, ImplTraitContext::Disallowed),\n             attrs: self.lower_attrs(&f.attrs),\n@@ -2107,7 +2107,7 @@ impl<'a> LoweringContext<'a> {\n     fn lower_field(&mut self, f: &Field) -> hir::Field {\n         hir::Field {\n             id: self.next_id().node_id,\n-            name: respan(f.ident.span, self.lower_ident(f.ident)),\n+            ident: f.ident,\n             expr: P(self.lower_expr(&f.expr)),\n             span: f.span,\n             is_shorthand: f.is_shorthand,\n@@ -2877,7 +2877,7 @@ impl<'a> LoweringContext<'a> {\n                         span: f.span,\n                         node: hir::FieldPat {\n                             id: self.next_id().node_id,\n-                            name: self.lower_ident(f.node.ident),\n+                            ident: f.node.ident,\n                             pat: self.lower_pat(&f.node.pat),\n                             is_shorthand: f.node.is_shorthand,\n                         },\n@@ -3119,10 +3119,7 @@ impl<'a> LoweringContext<'a> {\n                 P(self.lower_expr(el)),\n                 P(self.lower_expr(er)),\n             ),\n-            ExprKind::Field(ref el, ident) => hir::ExprField(\n-                P(self.lower_expr(el)),\n-                respan(ident.span, self.lower_ident(ident)),\n-            ),\n+            ExprKind::Field(ref el, ident) => hir::ExprField(P(self.lower_expr(el)), ident),\n             ExprKind::Index(ref el, ref er) => {\n                 hir::ExprIndex(P(self.lower_expr(el)), P(self.lower_expr(er)))\n             }\n@@ -3162,7 +3159,8 @@ impl<'a> LoweringContext<'a> {\n                         let expr = P(self.lower_expr(&e));\n                         let unstable_span =\n                             self.allow_internal_unstable(CompilerDesugaringKind::DotFill, e.span);\n-                        self.field(Symbol::intern(s), expr, unstable_span)\n+                        let ident = Ident::new(Symbol::intern(s), unstable_span);\n+                        self.field(ident, expr, unstable_span)\n                     })\n                     .collect::<P<[hir::Field]>>();\n \n@@ -3777,10 +3775,10 @@ impl<'a> LoweringContext<'a> {\n         }\n     }\n \n-    fn field(&mut self, name: Name, expr: P<hir::Expr>, span: Span) -> hir::Field {\n+    fn field(&mut self, ident: Ident, expr: P<hir::Expr>, span: Span) -> hir::Field {\n         hir::Field {\n             id: self.next_id().node_id,\n-            name: Spanned { node: name, span },\n+            ident,\n             span,\n             expr,\n             is_shorthand: false,"}, {"sha": "d6de2f57e9295f150fb1bedc20e883a5a8298912", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/189c0a1297f9341fd25f4c0a0f09c47610cdcbf1/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189c0a1297f9341fd25f4c0a0f09c47610cdcbf1/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=189c0a1297f9341fd25f4c0a0f09c47610cdcbf1", "patch": "@@ -909,7 +909,7 @@ impl<'hir> Map<'hir> {\n             NodeImplItem(ii) => ii.name,\n             NodeTraitItem(ti) => ti.name,\n             NodeVariant(v) => v.node.name,\n-            NodeField(f) => f.name,\n+            NodeField(f) => f.ident.name,\n             NodeLifetime(lt) => lt.name.name(),\n             NodeTyParam(tp) => tp.name,\n             NodeBinding(&Pat { node: PatKind::Binding(_,_,l,_), .. }) => l.node,\n@@ -1105,7 +1105,7 @@ impl<T:Named> Named for Spanned<T> { fn name(&self) -> Name { self.node.name() }\n impl Named for Item { fn name(&self) -> Name { self.name } }\n impl Named for ForeignItem { fn name(&self) -> Name { self.name } }\n impl Named for Variant_ { fn name(&self) -> Name { self.name } }\n-impl Named for StructField { fn name(&self) -> Name { self.name } }\n+impl Named for StructField { fn name(&self) -> Name { self.ident.name } }\n impl Named for TraitItem { fn name(&self) -> Name { self.name } }\n impl Named for ImplItem { fn name(&self) -> Name { self.name } }\n \n@@ -1291,7 +1291,7 @@ fn node_id_to_string(map: &Map, id: NodeId, include_id: bool) -> String {\n         }\n         Some(NodeField(ref field)) => {\n             format!(\"field {} in {}{}\",\n-                    field.name,\n+                    field.ident,\n                     path_str(), id_str)\n         }\n         Some(NodeAnonConst(_)) => {"}, {"sha": "254b77c11d803aa2f5b5e2db2e44295e83efd046", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/189c0a1297f9341fd25f4c0a0f09c47610cdcbf1/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189c0a1297f9341fd25f4c0a0f09c47610cdcbf1/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=189c0a1297f9341fd25f4c0a0f09c47610cdcbf1", "patch": "@@ -35,7 +35,7 @@ use mir::mono::Linkage;\n use syntax_pos::{Span, DUMMY_SP};\n use syntax::codemap::{self, Spanned};\n use rustc_target::spec::abi::Abi;\n-use syntax::ast::{self, Name, NodeId, DUMMY_NODE_ID, AsmDialect};\n+use syntax::ast::{self, Ident, Name, NodeId, DUMMY_NODE_ID, AsmDialect};\n use syntax::ast::{Attribute, Lit, StrStyle, FloatTy, IntTy, UintTy, MetaItem};\n use syntax::attr::InlineAttr;\n use syntax::ext::hygiene::SyntaxContext;\n@@ -866,7 +866,7 @@ impl Pat {\n pub struct FieldPat {\n     pub id: NodeId,\n     /// The identifier for the field\n-    pub name: Name,\n+    pub ident: Ident,\n     /// The pattern the field is destructured to\n     pub pat: P<Pat>,\n     pub is_shorthand: bool,\n@@ -1211,7 +1211,7 @@ pub struct Arm {\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct Field {\n     pub id: NodeId,\n-    pub name: Spanned<Name>,\n+    pub ident: Ident,\n     pub expr: P<Expr>,\n     pub span: Span,\n     pub is_shorthand: bool,\n@@ -1414,7 +1414,7 @@ pub enum Expr_ {\n     /// For example, `a += 1`.\n     ExprAssignOp(BinOp, P<Expr>, P<Expr>),\n     /// Access of a named (`obj.foo`) or unnamed (`obj.0`) struct or tuple field\n-    ExprField(P<Expr>, Spanned<Name>),\n+    ExprField(P<Expr>, Ident),\n     /// An indexing operation (`foo[2]`)\n     ExprIndex(P<Expr>, P<Expr>),\n \n@@ -1973,7 +1973,7 @@ impl Visibility {\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct StructField {\n     pub span: Span,\n-    pub name: Name,\n+    pub ident: Ident,\n     pub vis: Visibility,\n     pub id: NodeId,\n     pub ty: P<Ty>,\n@@ -1983,7 +1983,7 @@ pub struct StructField {\n impl StructField {\n     // Still necessary in couple of places\n     pub fn is_positional(&self) -> bool {\n-        let first = self.name.as_str().as_bytes()[0];\n+        let first = self.ident.name.as_str().as_bytes()[0];\n         first >= b'0' && first <= b'9'\n     }\n }"}, {"sha": "9ad427ab5b1c28e04d889c4451dee203548bb20a", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 14, "deletions": 10, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/189c0a1297f9341fd25f4c0a0f09c47610cdcbf1/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189c0a1297f9341fd25f4c0a0f09c47610cdcbf1/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=189c0a1297f9341fd25f4c0a0f09c47610cdcbf1", "patch": "@@ -857,7 +857,7 @@ impl<'a> State<'a> {\n                 self.maybe_print_comment(field.span.lo())?;\n                 self.print_outer_attributes(&field.attrs)?;\n                 self.print_visibility(&field.vis)?;\n-                self.print_name(field.name)?;\n+                self.print_ident(field.ident)?;\n                 self.word_nbsp(\":\")?;\n                 self.print_type(&field.ty)?;\n                 self.s.word(\",\")?;\n@@ -1166,7 +1166,7 @@ impl<'a> State<'a> {\n                            |s, field| {\n                                s.ibox(indent_unit)?;\n                                if !field.is_shorthand {\n-                                    s.print_name(field.name.node)?;\n+                                    s.print_ident(field.ident)?;\n                                     s.word_space(\":\")?;\n                                }\n                                s.print_expr(&field.expr)?;\n@@ -1406,10 +1406,10 @@ impl<'a> State<'a> {\n                 self.word_space(\"=\")?;\n                 self.print_expr_maybe_paren(&rhs, prec)?;\n             }\n-            hir::ExprField(ref expr, name) => {\n+            hir::ExprField(ref expr, ident) => {\n                 self.print_expr_maybe_paren(expr, parser::PREC_POSTFIX)?;\n                 self.s.word(\".\")?;\n-                self.print_name(name.node)?;\n+                self.print_ident(ident)?;\n             }\n             hir::ExprIndex(ref expr, ref index) => {\n                 self.print_expr_maybe_paren(&expr, parser::PREC_POSTFIX)?;\n@@ -1561,13 +1561,17 @@ impl<'a> State<'a> {\n         self.s.word(&i.to_string())\n     }\n \n-    pub fn print_name(&mut self, name: ast::Name) -> io::Result<()> {\n-        if name.to_ident().is_raw_guess() {\n-            self.s.word(&format!(\"r#{}\", name))?;\n+    pub fn print_ident(&mut self, ident: ast::Ident) -> io::Result<()> {\n+        if ident.is_raw_guess() {\n+            self.s.word(&format!(\"r#{}\", ident.name))?;\n         } else {\n-            self.s.word(&name.as_str())?;\n+            self.s.word(&ident.name.as_str())?;\n         }\n-        self.ann.post(self, NodeName(&name))\n+        self.ann.post(self, NodeName(&ident.name))\n+    }\n+\n+    pub fn print_name(&mut self, name: ast::Name) -> io::Result<()> {\n+        self.print_ident(name.to_ident())\n     }\n \n     pub fn print_for_decl(&mut self, loc: &hir::Local, coll: &hir::Expr) -> io::Result<()> {\n@@ -1773,7 +1777,7 @@ impl<'a> State<'a> {\n                                    |s, f| {\n                                        s.cbox(indent_unit)?;\n                                        if !f.node.is_shorthand {\n-                                           s.print_name(f.node.name)?;\n+                                           s.print_ident(f.node.ident)?;\n                                            s.word_nbsp(\":\")?;\n                                        }\n                                        s.print_pat(&f.node.pat)?;"}, {"sha": "9b202f55f3c0a23fd313d8d683fde6dd99022f2c", "filename": "src/librustc/ich/impls_hir.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/189c0a1297f9341fd25f4c0a0f09c47610cdcbf1/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189c0a1297f9341fd25f4c0a0f09c47610cdcbf1/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_hir.rs?ref=189c0a1297f9341fd25f4c0a0f09c47610cdcbf1", "patch": "@@ -427,12 +427,12 @@ impl<'a> HashStable<StableHashingContext<'a>> for hir::FieldPat {\n                                           hasher: &mut StableHasher<W>) {\n         let hir::FieldPat {\n             id: _,\n-            name,\n+            ident,\n             ref pat,\n             is_shorthand,\n         } = *self;\n \n-        name.hash_stable(hcx, hasher);\n+        ident.hash_stable(hcx, hasher);\n         pat.hash_stable(hcx, hasher);\n         is_shorthand.hash_stable(hcx, hasher);\n     }\n@@ -525,13 +525,13 @@ impl<'a> HashStable<StableHashingContext<'a>> for hir::Field {\n                                           hasher: &mut StableHasher<W>) {\n         let hir::Field {\n             id: _,\n-            name,\n+            ident,\n             ref expr,\n             span,\n             is_shorthand,\n         } = *self;\n \n-        name.hash_stable(hcx, hasher);\n+        ident.hash_stable(hcx, hasher);\n         expr.hash_stable(hcx, hasher);\n         span.hash_stable(hcx, hasher);\n         is_shorthand.hash_stable(hcx, hasher);\n@@ -598,7 +598,7 @@ impl_stable_hash_for!(enum hir::Expr_ {\n     ExprBlock(blk, label),\n     ExprAssign(lhs, rhs),\n     ExprAssignOp(op, lhs, rhs),\n-    ExprField(owner, field_name),\n+    ExprField(owner, ident),\n     ExprIndex(lhs, rhs),\n     ExprPath(path),\n     ExprAddrOf(mutability, sub),\n@@ -835,7 +835,7 @@ impl_stable_hash_for!(enum hir::UseKind {\n \n impl_stable_hash_for!(struct hir::StructField {\n     span,\n-    name,\n+    ident,\n     vis,\n     id,\n     ty,"}, {"sha": "0f8926c6f44010bffb05b3da89f0a82c85ea58c1", "filename": "src/librustc/ich/impls_ty.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/189c0a1297f9341fd25f4c0a0f09c47610cdcbf1/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189c0a1297f9341fd25f4c0a0f09c47610cdcbf1/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_ty.rs?ref=189c0a1297f9341fd25f4c0a0f09c47610cdcbf1", "patch": "@@ -357,11 +357,17 @@ impl_stable_hash_for!(enum ty::VariantDiscr {\n     Relative(distance)\n });\n \n-impl_stable_hash_for!(struct ty::FieldDef {\n-    did,\n-    name,\n-    vis\n-});\n+impl<'a, 'gcx> HashStable<StableHashingContext<'a>> for ty::FieldDef {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a>,\n+                                          hasher: &mut StableHasher<W>) {\n+        let ty::FieldDef { did, ident, vis } = *self;\n+\n+        did.hash_stable(hcx, hasher);\n+        ident.name.hash_stable(hcx, hasher);\n+        vis.hash_stable(hcx, hasher);\n+    }\n+}\n \n impl<'a, 'gcx> HashStable<StableHashingContext<'a>>\n for ::middle::const_val::ConstVal<'gcx> {"}, {"sha": "e3b20789714396da242338cf0c3876cc0af070c2", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/189c0a1297f9341fd25f4c0a0f09c47610cdcbf1/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189c0a1297f9341fd25f4c0a0f09c47610cdcbf1/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=189c0a1297f9341fd25f4c0a0f09c47610cdcbf1", "patch": "@@ -588,7 +588,7 @@ impl<'a, 'tcx> Visitor<'tcx> for DeadVisitor<'a, 'tcx> {\n \n     fn visit_struct_field(&mut self, field: &'tcx hir::StructField) {\n         if self.should_warn_about_field(&field) {\n-            self.warn_dead_code(field.id, field.span, field.name, \"field\", \"used\");\n+            self.warn_dead_code(field.id, field.span, field.ident.name, \"field\", \"used\");\n         }\n         intravisit::walk_struct_field(self, field);\n     }"}, {"sha": "fd6c2f652f04bfab41fa292202f6bfebdaf5c04a", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/189c0a1297f9341fd25f4c0a0f09c47610cdcbf1/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189c0a1297f9341fd25f4c0a0f09c47610cdcbf1/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=189c0a1297f9341fd25f4c0a0f09c47610cdcbf1", "patch": "@@ -669,7 +669,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n                             &*with_expr,\n                             with_cmt.clone(),\n                             f_index,\n-                            with_field.name,\n+                            with_field.ident,\n                             with_field.ty(self.tcx(), substs)\n                         );\n                         self.delegate_consume(with_expr.id, with_expr.span, &cmt_field);"}, {"sha": "39c4da08b03a39c7ea0a3b5f62e80a62dfccc783", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/189c0a1297f9341fd25f4c0a0f09c47610cdcbf1/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189c0a1297f9341fd25f4c0a0f09c47610cdcbf1/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=189c0a1297f9341fd25f4c0a0f09c47610cdcbf1", "patch": "@@ -647,14 +647,14 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n             }\n           }\n \n-          hir::ExprField(ref base, f_name) => {\n+          hir::ExprField(ref base, f_ident) => {\n             let base_cmt = Rc::new(self.cat_expr(&base)?);\n             debug!(\"cat_expr(cat_field): id={} expr={:?} base={:?}\",\n                    expr.id,\n                    expr,\n                    base_cmt);\n             let f_index = self.tcx.field_index(expr.id, self.tables);\n-            Ok(self.cat_field(expr, base_cmt, f_index, f_name.node, expr_ty))\n+            Ok(self.cat_field(expr, base_cmt, f_index, f_ident, expr_ty))\n           }\n \n           hir::ExprIndex(ref base, _) => {\n@@ -983,14 +983,15 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n                                  node: &N,\n                                  base_cmt: cmt<'tcx>,\n                                  f_index: usize,\n-                                 f_name: Name,\n+                                 f_ident: ast::Ident,\n                                  f_ty: Ty<'tcx>)\n                                  -> cmt_<'tcx> {\n         let ret = cmt_ {\n             id: node.id(),\n             span: node.span(),\n             mutbl: base_cmt.mutbl.inherit(),\n-            cat: Categorization::Interior(base_cmt, InteriorField(FieldIndex(f_index, f_name))),\n+            cat: Categorization::Interior(base_cmt,\n+                                          InteriorField(FieldIndex(f_index, f_ident.name))),\n             ty: f_ty,\n             note: NoteNone\n         };\n@@ -1301,8 +1302,8 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n             for fp in field_pats {\n                 let field_ty = self.pat_ty(&fp.node.pat)?; // see (*2)\n                 let f_index = self.tcx.field_index(fp.node.id, self.tables);\n-                let cmt_field =\n-                    Rc::new(self.cat_field(pat, cmt.clone(), f_index, fp.node.name, field_ty));\n+                let cmt_field = Rc::new(self.cat_field(pat, cmt.clone(), f_index,\n+                                                       fp.node.ident, field_ty));\n                 self.cat_pattern_(cmt_field, &fp.node.pat, op)?;\n             }\n           }"}, {"sha": "774d83648854dc3e7d1909bb6a9dab57f8f094ed", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/189c0a1297f9341fd25f4c0a0f09c47610cdcbf1/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189c0a1297f9341fd25f4c0a0f09c47610cdcbf1/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=189c0a1297f9341fd25f4c0a0f09c47610cdcbf1", "patch": "@@ -1774,7 +1774,7 @@ impl<'tcx> Debug for Rvalue<'tcx> {\n                             CtorKind::Fictive => {\n                                 let mut struct_fmt = fmt.debug_struct(\"\");\n                                 for (field, place) in variant_def.fields.iter().zip(places) {\n-                                    struct_fmt.field(&field.name.as_str(), place);\n+                                    struct_fmt.field(&field.ident.name.as_str(), place);\n                                 }\n                                 struct_fmt.finish()\n                             }"}, {"sha": "aacfbd065558f4bb8e4f7edde335e095ffa5c4c8", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/189c0a1297f9341fd25f4c0a0f09c47610cdcbf1/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189c0a1297f9341fd25f4c0a0f09c47610cdcbf1/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=189c0a1297f9341fd25f4c0a0f09c47610cdcbf1", "patch": "@@ -976,7 +976,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             }) => {\n                 (self.tcx.sess.codemap().def_span(span),\n                  fields.iter().map(|field| {\n-                     ArgKind::Arg(format!(\"{}\", field.name), \"_\".to_string())\n+                     ArgKind::Arg(format!(\"{}\", field.ident), \"_\".to_string())\n                  }).collect::<Vec<_>>())\n             }\n             hir::map::NodeStructCtor(ref variant_data) => {"}, {"sha": "499398abcf99622cd3ad02987ff8936510b71a8d", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/189c0a1297f9341fd25f4c0a0f09c47610cdcbf1/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189c0a1297f9341fd25f4c0a0f09c47610cdcbf1/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=189c0a1297f9341fd25f4c0a0f09c47610cdcbf1", "patch": "@@ -1227,7 +1227,7 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n                 if !adt_def.variants.is_empty() {\n                     let variant_def = &adt_def.variants[index];\n                     let fields: Vec<_> =\n-                        variant_def.fields.iter().map(|f| f.name).collect();\n+                        variant_def.fields.iter().map(|f| f.ident.name).collect();\n                     record(adt_kind.into(),\n                            adt_packed,\n                            None,\n@@ -1248,7 +1248,7 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n                 let variant_infos: Vec<_> =\n                     adt_def.variants.iter().enumerate().map(|(i, variant_def)| {\n                         let fields: Vec<_> =\n-                            variant_def.fields.iter().map(|f| f.name).collect();\n+                            variant_def.fields.iter().map(|f| f.ident.name).collect();\n                         build_variant_info(Some(variant_def.name),\n                                             &fields,\n                                             layout.for_variant(self, i))"}, {"sha": "115c6442db57d82092be7ba0c495ce3a79d3b2f1", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/189c0a1297f9341fd25f4c0a0f09c47610cdcbf1/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189c0a1297f9341fd25f4c0a0f09c47610cdcbf1/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=189c0a1297f9341fd25f4c0a0f09c47610cdcbf1", "patch": "@@ -1619,7 +1619,7 @@ pub enum VariantDiscr {\n #[derive(Debug)]\n pub struct FieldDef {\n     pub did: DefId,\n-    pub name: Name,\n+    pub ident: Ident,\n     pub vis: Visibility,\n }\n \n@@ -2454,7 +2454,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n \n     pub fn find_field_index(self, ident: Ident, variant: &VariantDef) -> Option<usize> {\n         variant.fields.iter().position(|field| {\n-            self.adjust_ident(ident.modern(), variant.did, DUMMY_NODE_ID).0 == field.name.to_ident()\n+            self.adjust_ident(ident, variant.did, DUMMY_NODE_ID).0 == field.ident.modern()\n         })\n     }\n \n@@ -2635,18 +2635,16 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     // supposed definition name (`def_name`). The method also needs `DefId` of the supposed\n     // definition's parent/scope to perform comparison.\n     pub fn hygienic_eq(self, use_name: Name, def_name: Name, def_parent_def_id: DefId) -> bool {\n-        self.adjust(use_name, def_parent_def_id, DUMMY_NODE_ID).0 == def_name.to_ident()\n-    }\n-\n-    pub fn adjust(self, name: Name, scope: DefId, block: NodeId) -> (Ident, DefId) {\n-        self.adjust_ident(name.to_ident(), scope, block)\n+        let (use_ident, def_ident) = (use_name.to_ident(), def_name.to_ident());\n+        self.adjust_ident(use_ident, def_parent_def_id, DUMMY_NODE_ID).0 == def_ident\n     }\n \n     pub fn adjust_ident(self, mut ident: Ident, scope: DefId, block: NodeId) -> (Ident, DefId) {\n         let expansion = match scope.krate {\n             LOCAL_CRATE => self.hir.definitions().expansion(scope.index),\n             _ => Mark::root(),\n         };\n+        ident = ident.modern();\n         let scope = match ident.span.adjust(expansion) {\n             Some(macro_def) => self.hir.definitions().macro_def_scope(macro_def),\n             None if block == DUMMY_NODE_ID => DefId::local(CRATE_DEF_INDEX), // Dummy DefId"}, {"sha": "408ab44cde62ba15f149c8e761e35812ae66b876", "filename": "src/librustc_borrowck/borrowck/gather_loans/restrictions.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/189c0a1297f9341fd25f4c0a0f09c47610cdcbf1/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Frestrictions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189c0a1297f9341fd25f4c0a0f09c47610cdcbf1/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Frestrictions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Frestrictions.rs?ref=189c0a1297f9341fd25f4c0a0f09c47610cdcbf1", "patch": "@@ -108,8 +108,9 @@ impl<'a, 'tcx> RestrictionsContext<'a, 'tcx> {\n                         RestrictionResult::Safe => RestrictionResult::Safe,\n                         RestrictionResult::SafeIf(base_lp, mut base_vec) => {\n                             for (i, field) in adt_def.non_enum_variant().fields.iter().enumerate() {\n-                                let field =\n-                                    InteriorKind::InteriorField(mc::FieldIndex(i, field.name));\n+                                let field = InteriorKind::InteriorField(\n+                                    mc::FieldIndex(i, field.ident.name)\n+                                );\n                                 let field_ty = if field == interior {\n                                     cmt.ty\n                                 } else {"}, {"sha": "4091ca046f44dc7f6a6ec5956d9641433711988d", "filename": "src/librustc_borrowck/borrowck/move_data.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/189c0a1297f9341fd25f4c0a0f09c47610cdcbf1/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189c0a1297f9341fd25f4c0a0f09c47610cdcbf1/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs?ref=189c0a1297f9341fd25f4c0a0f09c47610cdcbf1", "patch": "@@ -343,7 +343,8 @@ impl<'a, 'tcx> MoveData<'tcx> {\n                     = (&base_lp.ty.sty, lp_elem) {\n                 if adt_def.is_union() {\n                     for (i, field) in adt_def.non_enum_variant().fields.iter().enumerate() {\n-                        let field = InteriorKind::InteriorField(mc::FieldIndex(i, field.name));\n+                        let field =\n+                            InteriorKind::InteriorField(mc::FieldIndex(i, field.ident.name));\n                         if field != interior {\n                             let sibling_lp_kind =\n                                 LpExtend(base_lp.clone(), mutbl, LpInterior(opt_variant_id, field));\n@@ -395,7 +396,8 @@ impl<'a, 'tcx> MoveData<'tcx> {\n             if let ty::TyAdt(adt_def, _) = base_lp.ty.sty {\n                 if adt_def.is_union() {\n                     for (i, field) in adt_def.non_enum_variant().fields.iter().enumerate() {\n-                        let field = InteriorKind::InteriorField(mc::FieldIndex(i, field.name));\n+                        let field =\n+                            InteriorKind::InteriorField(mc::FieldIndex(i, field.ident.name));\n                         let field_ty = if field == interior {\n                             lp.ty\n                         } else {"}, {"sha": "1eec57c9c877c04f547bc37d412322e4cc857b4e", "filename": "src/librustc_codegen_llvm/debuginfo/metadata.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/189c0a1297f9341fd25f4c0a0f09c47610cdcbf1/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189c0a1297f9341fd25f4c0a0f09c47610cdcbf1/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs?ref=189c0a1297f9341fd25f4c0a0f09c47610cdcbf1", "patch": "@@ -951,7 +951,7 @@ impl<'tcx> StructMemberDescriptionFactory<'tcx> {\n             let name = if self.variant.ctor_kind == CtorKind::Fn {\n                 format!(\"__{}\", i)\n             } else {\n-                f.name.to_string()\n+                f.ident.to_string()\n             };\n             let field = layout.field(cx, i);\n             let (size, align) = field.size_and_align();\n@@ -1072,7 +1072,7 @@ impl<'tcx> UnionMemberDescriptionFactory<'tcx> {\n             let field = self.layout.field(cx, i);\n             let (size, align) = field.size_and_align();\n             MemberDescription {\n-                name: f.name.to_string(),\n+                name: f.ident.to_string(),\n                 type_metadata: type_metadata(cx, field.ty, self.span),\n                 offset: Size::ZERO,\n                 size,\n@@ -1338,7 +1338,7 @@ fn describe_enum_variant<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n         let name = if variant.ctor_kind == CtorKind::Fn {\n             format!(\"__{}\", i)\n         } else {\n-            variant.fields[i].name.to_string()\n+            variant.fields[i].ident.to_string()\n         };\n         (name, layout.field(cx, i).ty)\n     })).collect();"}, {"sha": "3deff82d35b9fcf9d79b5941fef9fa803c5d499f", "filename": "src/librustc_lint/bad_style.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/189c0a1297f9341fd25f4c0a0f09c47610cdcbf1/src%2Flibrustc_lint%2Fbad_style.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189c0a1297f9341fd25f4c0a0f09c47610cdcbf1/src%2Flibrustc_lint%2Fbad_style.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbad_style.rs?ref=189c0a1297f9341fd25f4c0a0f09c47610cdcbf1", "patch": "@@ -324,7 +324,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NonSnakeCase {\n                         _: &hir::Generics,\n                         _: ast::NodeId) {\n         for sf in s.fields() {\n-            self.check_snake_case(cx, \"structure field\", &sf.name.as_str(), Some(sf.span));\n+            self.check_snake_case(cx, \"structure field\", &sf.ident.name.as_str(), Some(sf.span));\n         }\n     }\n }"}, {"sha": "11c653895fce033f821870ba8b910ce5ecc073af", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/189c0a1297f9341fd25f4c0a0f09c47610cdcbf1/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189c0a1297f9341fd25f4c0a0f09c47610cdcbf1/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=189c0a1297f9341fd25f4c0a0f09c47610cdcbf1", "patch": "@@ -542,7 +542,7 @@ impl<'a, 'tcx> CrateMetadata {\n                 let f = self.entry(index);\n                 ty::FieldDef {\n                     did: self.local_def_id(index),\n-                    name: self.item_name(index).as_symbol(),\n+                    ident: Ident::from_interned_str(self.item_name(index)),\n                     vis: f.visibility.decode(self)\n                 }\n             }).collect(),"}, {"sha": "9061af1b68ca4717c9f4c562d22da3b79fb45013", "filename": "src/librustc_mir/borrow_check/error_reporting.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/189c0a1297f9341fd25f4c0a0f09c47610cdcbf1/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189c0a1297f9341fd25f4c0a0f09c47610cdcbf1/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs?ref=189c0a1297f9341fd25f4c0a0f09c47610cdcbf1", "patch": "@@ -746,7 +746,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             Place::Projection(ref proj) => match proj.elem {\n                 ProjectionElem::Deref => self.describe_field(&proj.base, field),\n                 ProjectionElem::Downcast(def, variant_index) => {\n-                    format!(\"{}\", def.variants[variant_index].fields[field.index()].name)\n+                    format!(\"{}\", def.variants[variant_index].fields[field.index()].ident)\n                 }\n                 ProjectionElem::Field(_, field_type) => {\n                     self.describe_field_from_ty(&field_type, field)\n@@ -770,7 +770,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 ty::TyAdt(def, _) => if def.is_enum() {\n                     format!(\"{}\", field.index())\n                 } else {\n-                    format!(\"{}\", def.non_enum_variant().fields[field.index()].name)\n+                    format!(\"{}\", def.non_enum_variant().fields[field.index()].ident)\n                 },\n                 ty::TyTuple(_) => format!(\"{}\", field.index()),\n                 ty::TyRef(_, ty, _) | ty::TyRawPtr(ty::TypeAndMut { ty, .. }) => {"}, {"sha": "4cfe74413dfa5b2d1a7c3fc101d296610cca2348", "filename": "src/librustc_mir/hair/pattern/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/189c0a1297f9341fd25f4c0a0f09c47610cdcbf1/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189c0a1297f9341fd25f4c0a0f09c47610cdcbf1/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs?ref=189c0a1297f9341fd25f4c0a0f09c47610cdcbf1", "patch": "@@ -183,7 +183,7 @@ impl<'tcx> fmt::Display for Pattern<'tcx> {\n                             if let PatternKind::Wild = *p.pattern.kind {\n                                 continue;\n                             }\n-                            let name = variant.fields[p.field.index()].name;\n+                            let name = variant.fields[p.field.index()].ident;\n                             write!(f, \"{}{}: {}\", start_or_continue(), name, p.pattern)?;\n                             printed += 1;\n                         }"}, {"sha": "bfb8c282d377baa0ecaea580c89eeadd5a91eb5c", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/189c0a1297f9341fd25f4c0a0f09c47610cdcbf1/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189c0a1297f9341fd25f4c0a0f09c47610cdcbf1/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=189c0a1297f9341fd25f4c0a0f09c47610cdcbf1", "patch": "@@ -504,12 +504,12 @@ impl<'a, 'tcx> NamePrivacyVisitor<'a, 'tcx> {\n                    span: Span, // Span of the field pattern, e.g. `x: 0`\n                    def: &'tcx ty::AdtDef, // Definition of the struct or enum\n                    field: &'tcx ty::FieldDef) { // Definition of the field\n-        let ident = Ident::new(keywords::Invalid.name(), use_ctxt.modern());\n+        let ident = Ident::new(keywords::Invalid.name(), use_ctxt);\n         let def_id = self.tcx.adjust_ident(ident, def.did, self.current_item).1;\n         if !def.is_enum() && !field.vis.is_accessible_from(def_id, self.tcx) {\n             struct_span_err!(self.tcx.sess, span, E0451, \"field `{}` of {} `{}` is private\",\n-                             field.name, def.variant_descr(), self.tcx.item_path_str(def.did))\n-                .span_label(span, format!(\"field `{}` is private\", field.name))\n+                             field.ident, def.variant_descr(), self.tcx.item_path_str(def.did))\n+                .span_label(span, format!(\"field `{}` is private\", field.ident))\n                 .emit();\n         }\n     }\n@@ -580,14 +580,14 @@ impl<'a, 'tcx> Visitor<'tcx> for NamePrivacyVisitor<'a, 'tcx> {\n                             self.tcx.field_index(f.id, self.tables) == vf_index\n                         });\n                         let (use_ctxt, span) = match field {\n-                            Some(field) => (field.name.node.to_ident().span, field.span),\n+                            Some(field) => (field.ident.span, field.span),\n                             None => (base.span, base.span),\n                         };\n                         self.check_field(use_ctxt, span, adt, variant_field);\n                     }\n                 } else {\n                     for field in fields {\n-                        let use_ctxt = field.name.node.to_ident().span;\n+                        let use_ctxt = field.ident.span;\n                         let index = self.tcx.field_index(field.id, self.tables);\n                         self.check_field(use_ctxt, field.span, adt, &variant.fields[index]);\n                     }\n@@ -606,7 +606,7 @@ impl<'a, 'tcx> Visitor<'tcx> for NamePrivacyVisitor<'a, 'tcx> {\n                 let adt = self.tables.pat_ty(pat).ty_adt_def().unwrap();\n                 let variant = adt.variant_of_def(def);\n                 for field in fields {\n-                    let use_ctxt = field.node.name.to_ident().span;\n+                    let use_ctxt = field.node.ident.span;\n                     let index = self.tcx.field_index(field.node.id, self.tables);\n                     self.check_field(use_ctxt, field.span, adt, &variant.fields[index]);\n                 }"}, {"sha": "7ef510f41254f1e19c452f625ffebad608858eab", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/189c0a1297f9341fd25f4c0a0f09c47610cdcbf1/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189c0a1297f9341fd25f4c0a0f09c47610cdcbf1/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=189c0a1297f9341fd25f4c0a0f09c47610cdcbf1", "patch": "@@ -557,7 +557,8 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                                           binding.item_name, binding.span)\n         }?;\n \n-        let (assoc_ident, def_scope) = tcx.adjust(binding.item_name, candidate.def_id(), ref_id);\n+        let (assoc_ident, def_scope) =\n+            tcx.adjust_ident(binding.item_name.to_ident(), candidate.def_id(), ref_id);\n         let assoc_ty = tcx.associated_items(candidate.def_id()).find(|i| {\n             i.kind == ty::AssociatedKind::Type && i.name.to_ident() == assoc_ident\n         }).expect(\"missing associated type\");\n@@ -907,7 +908,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         };\n \n         let trait_did = bound.def_id();\n-        let (assoc_ident, def_scope) = tcx.adjust(assoc_name, trait_did, ref_id);\n+        let (assoc_ident, def_scope) = tcx.adjust_ident(assoc_name.to_ident(), trait_did, ref_id);\n         let item = tcx.associated_items(trait_did).find(|i| {\n             Namespace::from(i.kind) == Namespace::Type &&\n             i.name.to_ident() == assoc_ident"}, {"sha": "439c0e2d610fae60d0526b31567bd1315eb8e789", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/189c0a1297f9341fd25f4c0a0f09c47610cdcbf1/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189c0a1297f9341fd25f4c0a0f09c47610cdcbf1/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=189c0a1297f9341fd25f4c0a0f09c47610cdcbf1", "patch": "@@ -859,7 +859,7 @@ https://doc.rust-lang.org/reference/types.html#trait-objects\");\n         let field_map = variant.fields\n             .iter()\n             .enumerate()\n-            .map(|(i, field)| (field.name.to_ident(), (i, field)))\n+            .map(|(i, field)| (field.ident.modern(), (i, field)))\n             .collect::<FxHashMap<_, _>>();\n \n         // Keep track of which fields have already appeared in the pattern.\n@@ -868,16 +868,16 @@ https://doc.rust-lang.org/reference/types.html#trait-objects\");\n         let mut inexistent_fields = vec![];\n         // Typecheck each field.\n         for &Spanned { node: ref field, span } in fields {\n-            let ident = tcx.adjust(field.name, variant.did, self.body_id).0;\n+            let ident = tcx.adjust_ident(field.ident, variant.did, self.body_id).0;\n             let field_ty = match used_fields.entry(ident) {\n                 Occupied(occupied) => {\n                     struct_span_err!(tcx.sess, span, E0025,\n                                      \"field `{}` bound multiple times \\\n                                       in the pattern\",\n-                                     field.name)\n+                                     field.ident)\n                         .span_label(span,\n-                                    format!(\"multiple uses of `{}` in pattern\", field.name))\n-                        .span_label(*occupied.get(), format!(\"first use of `{}`\", field.name))\n+                                    format!(\"multiple uses of `{}` in pattern\", field.ident))\n+                        .span_label(*occupied.get(), format!(\"first use of `{}`\", field.ident))\n                         .emit();\n                     tcx.types.err\n                 }\n@@ -890,7 +890,7 @@ https://doc.rust-lang.org/reference/types.html#trait-objects\");\n                             self.field_ty(span, f, substs)\n                         })\n                         .unwrap_or_else(|| {\n-                            inexistent_fields.push((span, field.name));\n+                            inexistent_fields.push((span, field.ident));\n                             tcx.types.err\n                         })\n                 }\n@@ -958,7 +958,7 @@ https://doc.rust-lang.org/reference/types.html#trait-objects\");\n         } else if !etc {\n             let unmentioned_fields = variant.fields\n                 .iter()\n-                .map(|field| field.name.to_ident())\n+                .map(|field| field.ident.modern())\n                 .filter(|ident| !used_fields.contains_key(&ident))\n                 .collect::<Vec<_>>();\n             if unmentioned_fields.len() > 0 {"}, {"sha": "169caf1f672667e7c064f3ce8e17d5b6b57fdc0d", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/189c0a1297f9341fd25f4c0a0f09c47610cdcbf1/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189c0a1297f9341fd25f4c0a0f09c47610cdcbf1/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=189c0a1297f9341fd25f4c0a0f09c47610cdcbf1", "patch": "@@ -114,15 +114,15 @@ pub enum CandidateSource {\n impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     /// Determines whether the type `self_ty` supports a method name `method_name` or not.\n     pub fn method_exists(&self,\n-                         span: Span,\n-                         method_name: ast::Name,\n+                         method_name: ast::Ident,\n                          self_ty: Ty<'tcx>,\n                          call_expr_id: ast::NodeId,\n                          allow_private: bool)\n                          -> bool {\n         let mode = probe::Mode::MethodCall;\n-        match self.probe_for_name(span, mode, method_name, IsSuggestion(false),\n-                                  self_ty, call_expr_id, ProbeScope::TraitsInScope) {\n+        match self.probe_for_name(method_name.span, mode, method_name.name,\n+                                  IsSuggestion(false), self_ty, call_expr_id,\n+                                  ProbeScope::TraitsInScope) {\n             Ok(..) => true,\n             Err(NoMatch(..)) => false,\n             Err(Ambiguity(..)) => true,"}, {"sha": "7c51765f0608e3c353065fbca2bfa724a93712fb", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/189c0a1297f9341fd25f4c0a0f09c47610cdcbf1/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189c0a1297f9341fd25f4c0a0f09c47610cdcbf1/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=189c0a1297f9341fd25f4c0a0f09c47610cdcbf1", "patch": "@@ -422,7 +422,8 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n     {\n         let is_accessible = if let Some(name) = self.method_name {\n             let item = candidate.item;\n-            let def_scope = self.tcx.adjust(name, item.container.id(), self.body_id).1;\n+            let def_scope =\n+                self.tcx.adjust_ident(name.to_ident(), item.container.id(), self.body_id).1;\n             item.vis.is_accessible_from(def_scope, self.tcx)\n         } else {\n             true"}, {"sha": "474a83a6d6ccfe0862007d61ff8ae40467fa2ca6", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 36, "deletions": 37, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/189c0a1297f9341fd25f4c0a0f09c47610cdcbf1/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189c0a1297f9341fd25f4c0a0f09c47610cdcbf1/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=189c0a1297f9341fd25f4c0a0f09c47610cdcbf1", "patch": "@@ -120,7 +120,7 @@ use std::ops::{self, Deref};\n use rustc_target::spec::abi::Abi;\n use syntax::ast;\n use syntax::attr;\n-use syntax::codemap::{original_sp, Spanned};\n+use syntax::codemap::original_sp;\n use syntax::feature_gate::{GateIssue, emit_feature_err};\n use syntax::ptr::P;\n use syntax::symbol::{Symbol, LocalInternedString, keywords};\n@@ -3045,7 +3045,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                    expr: &'gcx hir::Expr,\n                    needs: Needs,\n                    base: &'gcx hir::Expr,\n-                   field: &Spanned<ast::Name>) -> Ty<'tcx> {\n+                   field: ast::Ident) -> Ty<'tcx> {\n         let expr_t = self.check_expr_with_needs(base, needs);\n         let expr_t = self.structurally_resolved_type(base.span,\n                                                      expr_t);\n@@ -3056,9 +3056,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 ty::TyAdt(base_def, substs) if !base_def.is_enum() => {\n                     debug!(\"struct named {:?}\",  base_t);\n                     let (ident, def_scope) =\n-                        self.tcx.adjust(field.node, base_def.did, self.body_id);\n+                        self.tcx.adjust_ident(field, base_def.did, self.body_id);\n                     let fields = &base_def.non_enum_variant().fields;\n-                    if let Some(index) = fields.iter().position(|f| f.name.to_ident() == ident) {\n+                    if let Some(index) = fields.iter().position(|f| f.ident.modern() == ident) {\n                         let field = &fields[index];\n                         let field_ty = self.field_ty(expr.span, field, substs);\n                         // Save the index of all fields regardless of their visibility in case\n@@ -3076,7 +3076,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     }\n                 }\n                 ty::TyTuple(ref tys) => {\n-                    let fstr = field.node.as_str();\n+                    let fstr = field.name.as_str();\n                     if let Ok(index) = fstr.parse::<usize>() {\n                         if fstr == index.to_string() {\n                             if let Some(field_ty) = tys.get(index) {\n@@ -3099,31 +3099,31 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             let struct_path = self.tcx().item_path_str(did);\n             let mut err = struct_span_err!(self.tcx().sess, expr.span, E0616,\n                                            \"field `{}` of struct `{}` is private\",\n-                                           field.node, struct_path);\n+                                           field, struct_path);\n             // Also check if an accessible method exists, which is often what is meant.\n-            if self.method_exists(field.span, field.node, expr_t, expr.id, false) {\n-                err.note(&format!(\"a method `{}` also exists, perhaps you wish to call it\",\n-                                  field.node));\n+            if self.method_exists(field, expr_t, expr.id, false) {\n+                err.note(&format!(\"a method `{}` also exists, perhaps you wish to call it\", field));\n             }\n             err.emit();\n             field_ty\n-        } else if field.node == keywords::Invalid.name() {\n+        } else if field.name == keywords::Invalid.name() {\n             self.tcx().types.err\n-        } else if self.method_exists(field.span, field.node, expr_t, expr.id, true) {\n+        } else if self.method_exists(field, expr_t, expr.id, true) {\n             type_error_struct!(self.tcx().sess, field.span, expr_t, E0615,\n                               \"attempted to take value of method `{}` on type `{}`\",\n-                              field.node, expr_t)\n+                              field, expr_t)\n                 .help(\"maybe a `()` to call it is missing?\")\n                 .emit();\n             self.tcx().types.err\n         } else {\n             if !expr_t.is_primitive_ty() {\n-                let mut err = self.no_such_field_err(field.span, &field.node, expr_t);\n+                let mut err = self.no_such_field_err(field.span, field, expr_t);\n \n                 match expr_t.sty {\n                     ty::TyAdt(def, _) if !def.is_enum() => {\n                         if let Some(suggested_field_name) =\n-                            Self::suggest_field_name(def.non_enum_variant(), field, vec![]) {\n+                            Self::suggest_field_name(def.non_enum_variant(),\n+                                                     &field.name.as_str(), vec![]) {\n                                 err.span_label(field.span,\n                                                format!(\"did you mean `{}`?\", suggested_field_name));\n                             } else {\n@@ -3139,7 +3139,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     ty::TyRawPtr(..) => {\n                         let base = self.tcx.hir.node_to_pretty_string(base.id);\n                         let msg = format!(\"`{}` is a native pointer; try dereferencing it\", base);\n-                        let suggestion = format!(\"(*{}).{}\", base, field.node);\n+                        let suggestion = format!(\"(*{}).{}\", base, field);\n                         err.span_suggestion(field.span, &msg, suggestion);\n                     }\n                     _ => {}\n@@ -3156,29 +3156,28 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n     // Return an hint about the closest match in field names\n     fn suggest_field_name(variant: &'tcx ty::VariantDef,\n-                          field: &Spanned<ast::Name>,\n+                          field: &str,\n                           skip: Vec<LocalInternedString>)\n                           -> Option<Symbol> {\n-        let name = field.node.as_str();\n         let names = variant.fields.iter().filter_map(|field| {\n             // ignore already set fields and private fields from non-local crates\n-            if skip.iter().any(|x| *x == field.name.as_str()) ||\n+            if skip.iter().any(|x| *x == field.ident.name.as_str()) ||\n                (variant.did.krate != LOCAL_CRATE && field.vis != Visibility::Public) {\n                 None\n             } else {\n-                Some(&field.name)\n+                Some(&field.ident.name)\n             }\n         });\n \n-        find_best_match_for_name(names, &name, None)\n+        find_best_match_for_name(names, field, None)\n     }\n \n     fn available_field_names(&self, variant: &'tcx ty::VariantDef) -> Vec<ast::Name> {\n         let mut available = Vec::new();\n         for field in variant.fields.iter() {\n-            let (_, def_scope) = self.tcx.adjust(field.name, variant.did, self.body_id);\n+            let def_scope = self.tcx.adjust_ident(field.ident, variant.did, self.body_id).1;\n             if field.vis.is_accessible_from(def_scope, self.tcx) {\n-                available.push(field.name);\n+                available.push(field.ident.name);\n             }\n         }\n         available\n@@ -3209,36 +3208,36 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                             skip_fields: &[hir::Field],\n                             kind_name: &str) {\n         let mut err = self.type_error_struct_with_diag(\n-            field.name.span,\n+            field.ident.span,\n             |actual| match ty.sty {\n                 ty::TyAdt(adt, ..) if adt.is_enum() => {\n-                    struct_span_err!(self.tcx.sess, field.name.span, E0559,\n+                    struct_span_err!(self.tcx.sess, field.ident.span, E0559,\n                                     \"{} `{}::{}` has no field named `{}`\",\n-                                    kind_name, actual, variant.name, field.name.node)\n+                                    kind_name, actual, variant.name, field.ident)\n                 }\n                 _ => {\n-                    struct_span_err!(self.tcx.sess, field.name.span, E0560,\n+                    struct_span_err!(self.tcx.sess, field.ident.span, E0560,\n                                     \"{} `{}` has no field named `{}`\",\n-                                    kind_name, actual, field.name.node)\n+                                    kind_name, actual, field.ident)\n                 }\n             },\n             ty);\n         // prevent all specified fields from being suggested\n-        let skip_fields = skip_fields.iter().map(|ref x| x.name.node.as_str());\n+        let skip_fields = skip_fields.iter().map(|ref x| x.ident.name.as_str());\n         if let Some(field_name) = Self::suggest_field_name(variant,\n-                                                           &field.name,\n+                                                           &field.ident.name.as_str(),\n                                                            skip_fields.collect()) {\n-            err.span_label(field.name.span,\n+            err.span_label(field.ident.span,\n                            format!(\"field does not exist - did you mean `{}`?\", field_name));\n         } else {\n             match ty.sty {\n                 ty::TyAdt(adt, ..) => {\n                     if adt.is_enum() {\n-                        err.span_label(field.name.span,\n+                        err.span_label(field.ident.span,\n                                        format!(\"`{}::{}` does not have this field\",\n                                                ty, variant.name));\n                     } else {\n-                        err.span_label(field.name.span,\n+                        err.span_label(field.ident.span,\n                                        format!(\"`{}` does not have this field\", ty));\n                     }\n                     let available_field_names = self.available_field_names(variant);\n@@ -3278,7 +3277,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n         let mut remaining_fields = FxHashMap();\n         for (i, field) in variant.fields.iter().enumerate() {\n-            remaining_fields.insert(field.name.to_ident(), (i, field));\n+            remaining_fields.insert(field.ident.modern(), (i, field));\n         }\n \n         let mut seen_fields = FxHashMap();\n@@ -3287,7 +3286,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n         // Typecheck each field.\n         for field in ast_fields {\n-            let ident = tcx.adjust(field.name.node, variant.did, self.body_id).0;\n+            let ident = tcx.adjust_ident(field.ident, variant.did, self.body_id).0;\n             let field_type = if let Some((i, v_field)) = remaining_fields.remove(&ident) {\n                 seen_fields.insert(ident, field.span);\n                 self.write_field_index(field.id, i);\n@@ -3304,12 +3303,12 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 error_happened = true;\n                 if let Some(prev_span) = seen_fields.get(&ident) {\n                     let mut err = struct_span_err!(self.tcx.sess,\n-                                                field.name.span,\n+                                                field.ident.span,\n                                                 E0062,\n                                                 \"field `{}` specified more than once\",\n                                                 ident);\n \n-                    err.span_label(field.name.span, \"used more than once\");\n+                    err.span_label(field.ident.span, \"used more than once\");\n                     err.span_label(*prev_span, format!(\"first use of `{}`\", ident));\n \n                     err.emit();\n@@ -4054,7 +4053,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n           hir::ExprStruct(ref qpath, ref fields, ref base_expr) => {\n             self.check_expr_struct(expr, expected, qpath, fields, base_expr)\n           }\n-          hir::ExprField(ref base, ref field) => {\n+          hir::ExprField(ref base, field) => {\n             self.check_field(expr, needs, &base, field)\n           }\n           hir::ExprIndex(ref base, ref idx) => {"}, {"sha": "dde13680260687af7f97085f97a9f40e3640d1d1", "filename": "src/librustc_typeck/coherence/builtin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/189c0a1297f9341fd25f4c0a0f09c47610cdcbf1/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189c0a1297f9341fd25f4c0a0f09c47610cdcbf1/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs?ref=189c0a1297f9341fd25f4c0a0f09c47610cdcbf1", "patch": "@@ -354,7 +354,7 @@ pub fn coerce_unsized_info<'a, 'gcx>(gcx: TyCtxt<'a, 'gcx, 'gcx>,\n                                       diff_fields.len(),\n                                       diff_fields.iter()\n                                           .map(|&(i, a, b)| {\n-                                              format!(\"{} ({} to {})\", fields[i].name, a, b)\n+                                              format!(\"{} ({} to {})\", fields[i].ident, a, b)\n                                           })\n                                           .collect::<Vec<_>>()\n                                           .join(\", \")));"}, {"sha": "d0c67c2882cffcc84c1cac0db844619814f97756", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/189c0a1297f9341fd25f4c0a0f09c47610cdcbf1/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189c0a1297f9341fd25f4c0a0f09c47610cdcbf1/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=189c0a1297f9341fd25f4c0a0f09c47610cdcbf1", "patch": "@@ -520,21 +520,21 @@ fn convert_struct_variant<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let node_id = tcx.hir.as_local_node_id(did).unwrap();\n     let fields = def.fields().iter().map(|f| {\n         let fid = tcx.hir.local_def_id(f.id);\n-        let dup_span = seen_fields.get(&f.name.to_ident()).cloned();\n+        let dup_span = seen_fields.get(&f.ident.modern()).cloned();\n         if let Some(prev_span) = dup_span {\n             struct_span_err!(tcx.sess, f.span, E0124,\n                              \"field `{}` is already declared\",\n-                             f.name)\n+                             f.ident)\n                 .span_label(f.span, \"field already declared\")\n-                .span_label(prev_span, format!(\"`{}` first declared here\", f.name))\n+                .span_label(prev_span, format!(\"`{}` first declared here\", f.ident))\n                 .emit();\n         } else {\n-            seen_fields.insert(f.name.to_ident(), f.span);\n+            seen_fields.insert(f.ident.modern(), f.span);\n         }\n \n         ty::FieldDef {\n             did: fid,\n-            name: f.name,\n+            ident: f.ident,\n             vis: ty::Visibility::from_hir(&f.vis, node_id, tcx)\n         }\n     }).collect();"}, {"sha": "2e3ea3de7b0b7455dd18ae69ff4536ac16dbf748", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/189c0a1297f9341fd25f4c0a0f09c47610cdcbf1/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189c0a1297f9341fd25f4c0a0f09c47610cdcbf1/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=189c0a1297f9341fd25f4c0a0f09c47610cdcbf1", "patch": "@@ -1091,19 +1091,19 @@ fn resolve(cx: &DocContext, path_str: &str, is_val: bool) -> Result<(Def, Option\n                         _ => false,\n                     };\n                     let elem = if is_enum {\n-                        cx.tcx.adt_def(did).all_fields().find(|item| item.name == item_name)\n+                        cx.tcx.adt_def(did).all_fields().find(|item| item.ident.name == item_name)\n                     } else {\n                         cx.tcx.adt_def(did)\n                               .non_enum_variant()\n                               .fields\n                               .iter()\n-                              .find(|item| item.name == item_name)\n+                              .find(|item| item.ident.name == item_name)\n                     };\n                     if let Some(item) = elem {\n                         Ok((ty.def,\n                             Some(format!(\"{}.{}\",\n                                          if is_enum { \"variant\" } else { \"structfield\" },\n-                                         item.name))))\n+                                         item.ident))))\n                     } else {\n                         Err(())\n                     }\n@@ -2990,7 +2990,7 @@ impl<'tcx> Clean<Type> for Ty<'tcx> {\n impl Clean<Item> for hir::StructField {\n     fn clean(&self, cx: &DocContext) -> Item {\n         Item {\n-            name: Some(self.name).clean(cx),\n+            name: Some(self.ident.name).clean(cx),\n             attrs: self.attrs.clean(cx),\n             source: self.span.clean(cx),\n             visibility: self.vis.clean(cx),\n@@ -3005,7 +3005,7 @@ impl Clean<Item> for hir::StructField {\n impl<'tcx> Clean<Item> for ty::FieldDef {\n     fn clean(&self, cx: &DocContext) -> Item {\n         Item {\n-            name: Some(self.name).clean(cx),\n+            name: Some(self.ident.name).clean(cx),\n             attrs: cx.tcx.get_attrs(self.did).clean(cx),\n             source: cx.tcx.def_span(self.did).clean(cx),\n             visibility: self.vis.clean(cx),\n@@ -3201,7 +3201,7 @@ impl<'tcx> Clean<Item> for ty::VariantDef {\n                     fields: self.fields.iter().map(|field| {\n                         Item {\n                             source: cx.tcx.def_span(field.did).clean(cx),\n-                            name: Some(field.name.clean(cx)),\n+                            name: Some(field.ident.name.clean(cx)),\n                             attrs: cx.tcx.get_attrs(field.did).clean(cx),\n                             visibility: field.vis.clean(cx),\n                             def_id: field.did,\n@@ -3850,7 +3850,7 @@ fn name_from_pat(p: &hir::Pat) -> String {\n         PatKind::Struct(ref name, ref fields, etc) => {\n             format!(\"{} {{ {}{} }}\", qpath_to_string(name),\n                 fields.iter().map(|&Spanned { node: ref fp, .. }|\n-                                  format!(\"{}: {}\", fp.name, name_from_pat(&*fp.pat)))\n+                                  format!(\"{}: {}\", fp.ident, name_from_pat(&*fp.pat)))\n                              .collect::<Vec<String>>().join(\", \"),\n                 if etc { \", ...\" } else { \"\" }\n             )"}, {"sha": "6086c5a47c78c62dd058235a68a066fa69911d1c", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/189c0a1297f9341fd25f4c0a0f09c47610cdcbf1/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/189c0a1297f9341fd25f4c0a0f09c47610cdcbf1/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=189c0a1297f9341fd25f4c0a0f09c47610cdcbf1", "patch": "@@ -743,7 +743,7 @@ impl<'a, 'hir> intravisit::Visitor<'hir> for HirCollector<'a, 'hir> {\n     }\n \n     fn visit_struct_field(&mut self, f: &'hir hir::StructField) {\n-        self.visit_testable(f.name.to_string(), &f.attrs, |this| {\n+        self.visit_testable(f.ident.to_string(), &f.attrs, |this| {\n             intravisit::walk_struct_field(this, f);\n         });\n     }"}]}