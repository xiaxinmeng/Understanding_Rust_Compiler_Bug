{"sha": "9822acac0d9913a64d5ebf5ecda967eecbea5037", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk4MjJhY2FjMGQ5OTEzYTY0ZDVlYmY1ZWNkYTk2N2VlY2JlYTUwMzc=", "commit": {"author": {"name": "Igor Aleksanov", "email": "popzxc@yandex.ru", "date": "2020-10-25T08:32:41Z"}, "committer": {"name": "Igor Aleksanov", "email": "popzxc@yandex.ru", "date": "2020-10-25T08:32:41Z"}, "message": "Remove presentation module", "tree": {"sha": "21e3e933712ec911c26407179e2ebcc050749bc0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/21e3e933712ec911c26407179e2ebcc050749bc0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9822acac0d9913a64d5ebf5ecda967eecbea5037", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9822acac0d9913a64d5ebf5ecda967eecbea5037", "html_url": "https://github.com/rust-lang/rust/commit/9822acac0d9913a64d5ebf5ecda967eecbea5037", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9822acac0d9913a64d5ebf5ecda967eecbea5037/comments", "author": {"login": "popzxc", "id": 12111581, "node_id": "MDQ6VXNlcjEyMTExNTgx", "avatar_url": "https://avatars.githubusercontent.com/u/12111581?v=4", "gravatar_id": "", "url": "https://api.github.com/users/popzxc", "html_url": "https://github.com/popzxc", "followers_url": "https://api.github.com/users/popzxc/followers", "following_url": "https://api.github.com/users/popzxc/following{/other_user}", "gists_url": "https://api.github.com/users/popzxc/gists{/gist_id}", "starred_url": "https://api.github.com/users/popzxc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/popzxc/subscriptions", "organizations_url": "https://api.github.com/users/popzxc/orgs", "repos_url": "https://api.github.com/users/popzxc/repos", "events_url": "https://api.github.com/users/popzxc/events{/privacy}", "received_events_url": "https://api.github.com/users/popzxc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "popzxc", "id": 12111581, "node_id": "MDQ6VXNlcjEyMTExNTgx", "avatar_url": "https://avatars.githubusercontent.com/u/12111581?v=4", "gravatar_id": "", "url": "https://api.github.com/users/popzxc", "html_url": "https://github.com/popzxc", "followers_url": "https://api.github.com/users/popzxc/followers", "following_url": "https://api.github.com/users/popzxc/following{/other_user}", "gists_url": "https://api.github.com/users/popzxc/gists{/gist_id}", "starred_url": "https://api.github.com/users/popzxc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/popzxc/subscriptions", "organizations_url": "https://api.github.com/users/popzxc/orgs", "repos_url": "https://api.github.com/users/popzxc/repos", "events_url": "https://api.github.com/users/popzxc/events{/privacy}", "received_events_url": "https://api.github.com/users/popzxc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f731d910cbfe36bbdfa3a3f1415d5c48c4a79238", "url": "https://api.github.com/repos/rust-lang/rust/commits/f731d910cbfe36bbdfa3a3f1415d5c48c4a79238", "html_url": "https://github.com/rust-lang/rust/commit/f731d910cbfe36bbdfa3a3f1415d5c48c4a79238"}], "stats": {"total": 2830, "additions": 1409, "deletions": 1421}, "files": [{"sha": "4984df0590fdeaf40431c43483744aedf10026ab", "filename": "crates/completion/src/completions.rs", "status": "modified", "additions": 1409, "deletions": 8, "changes": 1417, "blob_url": "https://github.com/rust-lang/rust/blob/9822acac0d9913a64d5ebf5ecda967eecbea5037/crates%2Fcompletion%2Fsrc%2Fcompletions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9822acac0d9913a64d5ebf5ecda967eecbea5037/crates%2Fcompletion%2Fsrc%2Fcompletions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcompletion%2Fsrc%2Fcompletions.rs?ref=9822acac0d9913a64d5ebf5ecda967eecbea5037", "patch": "@@ -12,14 +12,36 @@ pub(crate) mod macro_in_item_position;\n pub(crate) mod trait_impl;\n pub(crate) mod mod_;\n \n-use crate::item::{Builder, CompletionItem};\n+use hir::{HasAttrs, HasSource, HirDisplay, ModPath, Mutability, ScopeDef, StructKind, Type};\n+use itertools::Itertools;\n+use syntax::{ast::NameOwner, display::*};\n+use test_utils::mark;\n+\n+use crate::{\n+    item::Builder, CompletionContext, CompletionItem, CompletionItemKind, CompletionKind,\n+    CompletionScore, RootDatabase,\n+};\n \n /// Represents an in-progress set of completions being built.\n #[derive(Debug, Default)]\n pub struct Completions {\n     buf: Vec<CompletionItem>,\n }\n \n+impl Into<Vec<CompletionItem>> for Completions {\n+    fn into(self) -> Vec<CompletionItem> {\n+        self.buf\n+    }\n+}\n+\n+impl Builder {\n+    /// Convenience method, which allows to add a freshly created completion into accumulator\n+    /// without binding it to the variable.\n+    pub(crate) fn add_to(self, acc: &mut Completions) {\n+        acc.add(self.build())\n+    }\n+}\n+\n impl Completions {\n     pub fn add(&mut self, item: CompletionItem) {\n         self.buf.push(item.into())\n@@ -32,18 +54,1397 @@ impl Completions {\n     {\n         items.into_iter().for_each(|item| self.add(item.into()))\n     }\n+\n+    pub(crate) fn add_field(&mut self, ctx: &CompletionContext, field: hir::Field, ty: &Type) {\n+        let is_deprecated = is_deprecated(field, ctx.db);\n+        let name = field.name(ctx.db);\n+        let mut item =\n+            CompletionItem::new(CompletionKind::Reference, ctx.source_range(), name.to_string())\n+                .kind(CompletionItemKind::Field)\n+                .detail(ty.display(ctx.db).to_string())\n+                .set_documentation(field.docs(ctx.db))\n+                .set_deprecated(is_deprecated);\n+\n+        if let Some(score) = compute_score(ctx, &ty, &name.to_string()) {\n+            item = item.set_score(score);\n+        }\n+\n+        item.add_to(self);\n+    }\n+\n+    pub(crate) fn add_tuple_field(&mut self, ctx: &CompletionContext, field: usize, ty: &Type) {\n+        CompletionItem::new(CompletionKind::Reference, ctx.source_range(), field.to_string())\n+            .kind(CompletionItemKind::Field)\n+            .detail(ty.display(ctx.db).to_string())\n+            .add_to(self);\n+    }\n+\n+    pub(crate) fn add_resolution(\n+        &mut self,\n+        ctx: &CompletionContext,\n+        local_name: String,\n+        resolution: &ScopeDef,\n+    ) {\n+        use hir::ModuleDef::*;\n+\n+        let completion_kind = match resolution {\n+            ScopeDef::ModuleDef(BuiltinType(..)) => CompletionKind::BuiltinType,\n+            _ => CompletionKind::Reference,\n+        };\n+\n+        let kind = match resolution {\n+            ScopeDef::ModuleDef(Module(..)) => CompletionItemKind::Module,\n+            ScopeDef::ModuleDef(Function(func)) => {\n+                self.add_function(ctx, *func, Some(local_name));\n+                return;\n+            }\n+            ScopeDef::ModuleDef(Adt(hir::Adt::Struct(_))) => CompletionItemKind::Struct,\n+            // FIXME: add CompletionItemKind::Union\n+            ScopeDef::ModuleDef(Adt(hir::Adt::Union(_))) => CompletionItemKind::Struct,\n+            ScopeDef::ModuleDef(Adt(hir::Adt::Enum(_))) => CompletionItemKind::Enum,\n+\n+            ScopeDef::ModuleDef(EnumVariant(var)) => {\n+                self.add_enum_variant(ctx, *var, Some(local_name));\n+                return;\n+            }\n+            ScopeDef::ModuleDef(Const(..)) => CompletionItemKind::Const,\n+            ScopeDef::ModuleDef(Static(..)) => CompletionItemKind::Static,\n+            ScopeDef::ModuleDef(Trait(..)) => CompletionItemKind::Trait,\n+            ScopeDef::ModuleDef(TypeAlias(..)) => CompletionItemKind::TypeAlias,\n+            ScopeDef::ModuleDef(BuiltinType(..)) => CompletionItemKind::BuiltinType,\n+            ScopeDef::GenericParam(..) => CompletionItemKind::TypeParam,\n+            ScopeDef::Local(..) => CompletionItemKind::Binding,\n+            // (does this need its own kind?)\n+            ScopeDef::AdtSelfType(..) | ScopeDef::ImplSelfType(..) => CompletionItemKind::TypeParam,\n+            ScopeDef::MacroDef(mac) => {\n+                self.add_macro(ctx, Some(local_name), *mac);\n+                return;\n+            }\n+            ScopeDef::Unknown => {\n+                CompletionItem::new(CompletionKind::Reference, ctx.source_range(), local_name)\n+                    .kind(CompletionItemKind::UnresolvedReference)\n+                    .add_to(self);\n+                return;\n+            }\n+        };\n+\n+        let docs = match resolution {\n+            ScopeDef::ModuleDef(Module(it)) => it.docs(ctx.db),\n+            ScopeDef::ModuleDef(Adt(it)) => it.docs(ctx.db),\n+            ScopeDef::ModuleDef(EnumVariant(it)) => it.docs(ctx.db),\n+            ScopeDef::ModuleDef(Const(it)) => it.docs(ctx.db),\n+            ScopeDef::ModuleDef(Static(it)) => it.docs(ctx.db),\n+            ScopeDef::ModuleDef(Trait(it)) => it.docs(ctx.db),\n+            ScopeDef::ModuleDef(TypeAlias(it)) => it.docs(ctx.db),\n+            _ => None,\n+        };\n+\n+        let mut item = CompletionItem::new(completion_kind, ctx.source_range(), local_name.clone());\n+        if let ScopeDef::Local(local) = resolution {\n+            let ty = local.ty(ctx.db);\n+            if !ty.is_unknown() {\n+                item = item.detail(ty.display(ctx.db).to_string());\n+            }\n+        };\n+\n+        let mut ref_match = None;\n+        if let ScopeDef::Local(local) = resolution {\n+            if let Some((active_name, active_type)) = ctx.active_name_and_type() {\n+                let ty = local.ty(ctx.db);\n+                if let Some(score) =\n+                    compute_score_from_active(&active_type, &active_name, &ty, &local_name)\n+                {\n+                    item = item.set_score(score);\n+                }\n+                ref_match = refed_type_matches(&active_type, &active_name, &ty, &local_name);\n+            }\n+        }\n+\n+        // Add `<>` for generic types\n+        if ctx.is_path_type && !ctx.has_type_args && ctx.config.add_call_parenthesis {\n+            if let Some(cap) = ctx.config.snippet_cap {\n+                let has_non_default_type_params = match resolution {\n+                    ScopeDef::ModuleDef(Adt(it)) => it.has_non_default_type_params(ctx.db),\n+                    ScopeDef::ModuleDef(TypeAlias(it)) => it.has_non_default_type_params(ctx.db),\n+                    _ => false,\n+                };\n+                if has_non_default_type_params {\n+                    mark::hit!(inserts_angle_brackets_for_generics);\n+                    item = item\n+                        .lookup_by(local_name.clone())\n+                        .label(format!(\"{}<\u2026>\", local_name))\n+                        .insert_snippet(cap, format!(\"{}<$0>\", local_name));\n+                }\n+            }\n+        }\n+\n+        item.kind(kind).set_documentation(docs).set_ref_match(ref_match).add_to(self)\n+    }\n+\n+    pub(crate) fn add_macro(\n+        &mut self,\n+        ctx: &CompletionContext,\n+        name: Option<String>,\n+        macro_: hir::MacroDef,\n+    ) {\n+        // FIXME: Currently proc-macro do not have ast-node,\n+        // such that it does not have source\n+        if macro_.is_proc_macro() {\n+            return;\n+        }\n+\n+        let name = match name {\n+            Some(it) => it,\n+            None => return,\n+        };\n+\n+        let ast_node = macro_.source(ctx.db).value;\n+        let detail = macro_label(&ast_node);\n+\n+        let docs = macro_.docs(ctx.db);\n+\n+        let mut builder = CompletionItem::new(\n+            CompletionKind::Reference,\n+            ctx.source_range(),\n+            &format!(\"{}!\", name),\n+        )\n+        .kind(CompletionItemKind::Macro)\n+        .set_documentation(docs.clone())\n+        .set_deprecated(is_deprecated(macro_, ctx.db))\n+        .detail(detail);\n+\n+        let needs_bang = ctx.use_item_syntax.is_none() && !ctx.is_macro_call;\n+        builder = match ctx.config.snippet_cap {\n+            Some(cap) if needs_bang => {\n+                let docs = docs.as_ref().map_or(\"\", |s| s.as_str());\n+                let (bra, ket) = guess_macro_braces(&name, docs);\n+                builder\n+                    .insert_snippet(cap, format!(\"{}!{}$0{}\", name, bra, ket))\n+                    .label(format!(\"{}!{}\u2026{}\", name, bra, ket))\n+                    .lookup_by(format!(\"{}!\", name))\n+            }\n+            None if needs_bang => builder.insert_text(format!(\"{}!\", name)),\n+            _ => {\n+                mark::hit!(dont_insert_macro_call_parens_unncessary);\n+                builder.insert_text(name)\n+            }\n+        };\n+\n+        self.add(builder.build());\n+    }\n+\n+    pub(crate) fn add_function(\n+        &mut self,\n+        ctx: &CompletionContext,\n+        func: hir::Function,\n+        local_name: Option<String>,\n+    ) {\n+        fn add_arg(arg: &str, ty: &Type, ctx: &CompletionContext) -> String {\n+            if let Some(derefed_ty) = ty.remove_ref() {\n+                for (name, local) in ctx.locals.iter() {\n+                    if name == arg && local.ty(ctx.db) == derefed_ty {\n+                        return (if ty.is_mutable_reference() { \"&mut \" } else { \"&\" }).to_string()\n+                            + &arg.to_string();\n+                    }\n+                }\n+            }\n+            arg.to_string()\n+        };\n+        let name = local_name.unwrap_or_else(|| func.name(ctx.db).to_string());\n+        let ast_node = func.source(ctx.db).value;\n+\n+        let mut builder =\n+            CompletionItem::new(CompletionKind::Reference, ctx.source_range(), name.clone())\n+                .kind(if func.self_param(ctx.db).is_some() {\n+                    CompletionItemKind::Method\n+                } else {\n+                    CompletionItemKind::Function\n+                })\n+                .set_documentation(func.docs(ctx.db))\n+                .set_deprecated(is_deprecated(func, ctx.db))\n+                .detail(function_declaration(&ast_node));\n+\n+        let params_ty = func.params(ctx.db);\n+        let params = ast_node\n+            .param_list()\n+            .into_iter()\n+            .flat_map(|it| it.params())\n+            .zip(params_ty)\n+            .flat_map(|(it, param_ty)| {\n+                if let Some(pat) = it.pat() {\n+                    let name = pat.to_string();\n+                    let arg = name.trim_start_matches(\"mut \").trim_start_matches('_');\n+                    return Some(add_arg(arg, param_ty.ty(), ctx));\n+                }\n+                None\n+            })\n+            .collect();\n+\n+        builder = builder.add_call_parens(ctx, name, Params::Named(params));\n+\n+        self.add(builder.build())\n+    }\n+\n+    pub(crate) fn add_const(&mut self, ctx: &CompletionContext, constant: hir::Const) {\n+        let ast_node = constant.source(ctx.db).value;\n+        let name = match ast_node.name() {\n+            Some(name) => name,\n+            _ => return,\n+        };\n+        let detail = const_label(&ast_node);\n+\n+        CompletionItem::new(CompletionKind::Reference, ctx.source_range(), name.text().to_string())\n+            .kind(CompletionItemKind::Const)\n+            .set_documentation(constant.docs(ctx.db))\n+            .set_deprecated(is_deprecated(constant, ctx.db))\n+            .detail(detail)\n+            .add_to(self);\n+    }\n+\n+    pub(crate) fn add_type_alias(&mut self, ctx: &CompletionContext, type_alias: hir::TypeAlias) {\n+        let type_def = type_alias.source(ctx.db).value;\n+        let name = match type_def.name() {\n+            Some(name) => name,\n+            _ => return,\n+        };\n+        let detail = type_label(&type_def);\n+\n+        CompletionItem::new(CompletionKind::Reference, ctx.source_range(), name.text().to_string())\n+            .kind(CompletionItemKind::TypeAlias)\n+            .set_documentation(type_alias.docs(ctx.db))\n+            .set_deprecated(is_deprecated(type_alias, ctx.db))\n+            .detail(detail)\n+            .add_to(self);\n+    }\n+\n+    pub(crate) fn add_qualified_enum_variant(\n+        &mut self,\n+        ctx: &CompletionContext,\n+        variant: hir::EnumVariant,\n+        path: ModPath,\n+    ) {\n+        self.add_enum_variant_impl(ctx, variant, None, Some(path))\n+    }\n+\n+    pub(crate) fn add_enum_variant(\n+        &mut self,\n+        ctx: &CompletionContext,\n+        variant: hir::EnumVariant,\n+        local_name: Option<String>,\n+    ) {\n+        self.add_enum_variant_impl(ctx, variant, local_name, None)\n+    }\n+\n+    fn add_enum_variant_impl(\n+        &mut self,\n+        ctx: &CompletionContext,\n+        variant: hir::EnumVariant,\n+        local_name: Option<String>,\n+        path: Option<ModPath>,\n+    ) {\n+        let is_deprecated = is_deprecated(variant, ctx.db);\n+        let name = local_name.unwrap_or_else(|| variant.name(ctx.db).to_string());\n+        let (qualified_name, short_qualified_name) = match &path {\n+            Some(path) => {\n+                let full = path.to_string();\n+                let short =\n+                    path.segments[path.segments.len().saturating_sub(2)..].iter().join(\"::\");\n+                (full, short)\n+            }\n+            None => (name.to_string(), name.to_string()),\n+        };\n+        let detail_types = variant\n+            .fields(ctx.db)\n+            .into_iter()\n+            .map(|field| (field.name(ctx.db), field.signature_ty(ctx.db)));\n+        let variant_kind = variant.kind(ctx.db);\n+        let detail = match variant_kind {\n+            StructKind::Tuple | StructKind::Unit => format!(\n+                \"({})\",\n+                detail_types.map(|(_, t)| t.display(ctx.db).to_string()).format(\", \")\n+            ),\n+            StructKind::Record => format!(\n+                \"{{ {} }}\",\n+                detail_types\n+                    .map(|(n, t)| format!(\"{}: {}\", n, t.display(ctx.db).to_string()))\n+                    .format(\", \")\n+            ),\n+        };\n+        let mut res = CompletionItem::new(\n+            CompletionKind::Reference,\n+            ctx.source_range(),\n+            qualified_name.clone(),\n+        )\n+        .kind(CompletionItemKind::EnumVariant)\n+        .set_documentation(variant.docs(ctx.db))\n+        .set_deprecated(is_deprecated)\n+        .detail(detail);\n+\n+        if variant_kind == StructKind::Tuple {\n+            mark::hit!(inserts_parens_for_tuple_enums);\n+            let params = Params::Anonymous(variant.fields(ctx.db).len());\n+            res = res.add_call_parens(ctx, short_qualified_name, params)\n+        } else if path.is_some() {\n+            res = res.lookup_by(short_qualified_name);\n+        }\n+\n+        res.add_to(self);\n+    }\n }\n \n-impl Into<Vec<CompletionItem>> for Completions {\n-    fn into(self) -> Vec<CompletionItem> {\n-        self.buf\n+fn compute_score_from_active(\n+    active_type: &Type,\n+    active_name: &str,\n+    ty: &Type,\n+    name: &str,\n+) -> Option<CompletionScore> {\n+    // Compute score\n+    // For the same type\n+    if active_type != ty {\n+        return None;\n+    }\n+\n+    let mut res = CompletionScore::TypeMatch;\n+\n+    // If same type + same name then go top position\n+    if active_name == name {\n+        res = CompletionScore::TypeAndNameMatch\n+    }\n+\n+    Some(res)\n+}\n+fn refed_type_matches(\n+    active_type: &Type,\n+    active_name: &str,\n+    ty: &Type,\n+    name: &str,\n+) -> Option<(Mutability, CompletionScore)> {\n+    let derefed_active = active_type.remove_ref()?;\n+    let score = compute_score_from_active(&derefed_active, &active_name, &ty, &name)?;\n+    Some((\n+        if active_type.is_mutable_reference() { Mutability::Mut } else { Mutability::Shared },\n+        score,\n+    ))\n+}\n+\n+fn compute_score(ctx: &CompletionContext, ty: &Type, name: &str) -> Option<CompletionScore> {\n+    let (active_name, active_type) = ctx.active_name_and_type()?;\n+    compute_score_from_active(&active_type, &active_name, ty, name)\n+}\n+\n+enum Params {\n+    Named(Vec<String>),\n+    Anonymous(usize),\n+}\n+\n+impl Params {\n+    fn len(&self) -> usize {\n+        match self {\n+            Params::Named(xs) => xs.len(),\n+            Params::Anonymous(len) => *len,\n+        }\n+    }\n+\n+    fn is_empty(&self) -> bool {\n+        self.len() == 0\n     }\n }\n \n impl Builder {\n-    /// Convenience method, which allows to add a freshly created completion into accumulator\n-    /// without binding it to the variable.\n-    pub(crate) fn add_to(self, acc: &mut Completions) {\n-        acc.add(self.build())\n+    fn add_call_parens(mut self, ctx: &CompletionContext, name: String, params: Params) -> Builder {\n+        if !ctx.config.add_call_parenthesis {\n+            return self;\n+        }\n+        if ctx.use_item_syntax.is_some() {\n+            mark::hit!(no_parens_in_use_item);\n+            return self;\n+        }\n+        if ctx.is_pattern_call {\n+            mark::hit!(dont_duplicate_pattern_parens);\n+            return self;\n+        }\n+        if ctx.is_call {\n+            return self;\n+        }\n+\n+        // Don't add parentheses if the expected type is some function reference.\n+        if let Some(ty) = &ctx.expected_type {\n+            if ty.is_fn() {\n+                mark::hit!(no_call_parens_if_fn_ptr_needed);\n+                return self;\n+            }\n+        }\n+\n+        let cap = match ctx.config.snippet_cap {\n+            Some(it) => it,\n+            None => return self,\n+        };\n+        // If not an import, add parenthesis automatically.\n+        mark::hit!(inserts_parens_for_function_calls);\n+\n+        let (snippet, label) = if params.is_empty() {\n+            (format!(\"{}()$0\", name), format!(\"{}()\", name))\n+        } else {\n+            self = self.trigger_call_info();\n+            let snippet = match (ctx.config.add_call_argument_snippets, params) {\n+                (true, Params::Named(params)) => {\n+                    let function_params_snippet =\n+                        params.iter().enumerate().format_with(\", \", |(index, param_name), f| {\n+                            f(&format_args!(\"${{{}:{}}}\", index + 1, param_name))\n+                        });\n+                    format!(\"{}({})$0\", name, function_params_snippet)\n+                }\n+                _ => {\n+                    mark::hit!(suppress_arg_snippets);\n+                    format!(\"{}($0)\", name)\n+                }\n+            };\n+\n+            (snippet, format!(\"{}(\u2026)\", name))\n+        };\n+        self.lookup_by(name).label(label).insert_snippet(cap, snippet)\n+    }\n+}\n+\n+fn is_deprecated(node: impl HasAttrs, db: &RootDatabase) -> bool {\n+    node.attrs(db).by_key(\"deprecated\").exists()\n+}\n+\n+fn guess_macro_braces(macro_name: &str, docs: &str) -> (&'static str, &'static str) {\n+    let mut votes = [0, 0, 0];\n+    for (idx, s) in docs.match_indices(&macro_name) {\n+        let (before, after) = (&docs[..idx], &docs[idx + s.len()..]);\n+        // Ensure to match the full word\n+        if after.starts_with('!')\n+            && !before.ends_with(|c: char| c == '_' || c.is_ascii_alphanumeric())\n+        {\n+            // It may have spaces before the braces like `foo! {}`\n+            match after[1..].chars().find(|&c| !c.is_whitespace()) {\n+                Some('{') => votes[0] += 1,\n+                Some('[') => votes[1] += 1,\n+                Some('(') => votes[2] += 1,\n+                _ => {}\n+            }\n+        }\n+    }\n+\n+    // Insert a space before `{}`.\n+    // We prefer the last one when some votes equal.\n+    let (_vote, (bra, ket)) = votes\n+        .iter()\n+        .zip(&[(\" {\", \"}\"), (\"[\", \"]\"), (\"(\", \")\")])\n+        .max_by_key(|&(&vote, _)| vote)\n+        .unwrap();\n+    (*bra, *ket)\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use std::cmp::Reverse;\n+\n+    use expect_test::{expect, Expect};\n+    use test_utils::mark;\n+\n+    use crate::{\n+        test_utils::{check_edit, check_edit_with_config, do_completion, get_all_items},\n+        CompletionConfig, CompletionKind, CompletionScore,\n+    };\n+\n+    fn check(ra_fixture: &str, expect: Expect) {\n+        let actual = do_completion(ra_fixture, CompletionKind::Reference);\n+        expect.assert_debug_eq(&actual);\n+    }\n+\n+    fn check_scores(ra_fixture: &str, expect: Expect) {\n+        fn display_score(score: Option<CompletionScore>) -> &'static str {\n+            match score {\n+                Some(CompletionScore::TypeMatch) => \"[type]\",\n+                Some(CompletionScore::TypeAndNameMatch) => \"[type+name]\",\n+                None => \"[]\".into(),\n+            }\n+        }\n+\n+        let mut completions = get_all_items(CompletionConfig::default(), ra_fixture);\n+        completions.sort_by_key(|it| (Reverse(it.score()), it.label().to_string()));\n+        let actual = completions\n+            .into_iter()\n+            .filter(|it| it.completion_kind == CompletionKind::Reference)\n+            .map(|it| {\n+                let tag = it.kind().unwrap().tag();\n+                let score = display_score(it.score());\n+                format!(\"{} {} {}\\n\", tag, it.label(), score)\n+            })\n+            .collect::<String>();\n+        expect.assert_eq(&actual);\n+    }\n+\n+    #[test]\n+    fn enum_detail_includes_record_fields() {\n+        check(\n+            r#\"\n+enum Foo { Foo { x: i32, y: i32 } }\n+\n+fn main() { Foo::Fo<|> }\n+\"#,\n+            expect![[r#\"\n+                [\n+                    CompletionItem {\n+                        label: \"Foo\",\n+                        source_range: 54..56,\n+                        delete: 54..56,\n+                        insert: \"Foo\",\n+                        kind: EnumVariant,\n+                        detail: \"{ x: i32, y: i32 }\",\n+                    },\n+                ]\n+            \"#]],\n+        );\n+    }\n+\n+    #[test]\n+    fn enum_detail_doesnt_include_tuple_fields() {\n+        check(\n+            r#\"\n+enum Foo { Foo (i32, i32) }\n+\n+fn main() { Foo::Fo<|> }\n+\"#,\n+            expect![[r#\"\n+                [\n+                    CompletionItem {\n+                        label: \"Foo(\u2026)\",\n+                        source_range: 46..48,\n+                        delete: 46..48,\n+                        insert: \"Foo($0)\",\n+                        kind: EnumVariant,\n+                        lookup: \"Foo\",\n+                        detail: \"(i32, i32)\",\n+                        trigger_call_info: true,\n+                    },\n+                ]\n+            \"#]],\n+        );\n+    }\n+\n+    #[test]\n+    fn enum_detail_just_parentheses_for_unit() {\n+        check(\n+            r#\"\n+enum Foo { Foo }\n+\n+fn main() { Foo::Fo<|> }\n+\"#,\n+            expect![[r#\"\n+                [\n+                    CompletionItem {\n+                        label: \"Foo\",\n+                        source_range: 35..37,\n+                        delete: 35..37,\n+                        insert: \"Foo\",\n+                        kind: EnumVariant,\n+                        detail: \"()\",\n+                    },\n+                ]\n+            \"#]],\n+        );\n+    }\n+\n+    #[test]\n+    fn lookup_enums_by_two_qualifiers() {\n+        check(\n+            r#\"\n+mod m {\n+    pub enum Spam { Foo, Bar(i32) }\n+}\n+fn main() { let _: m::Spam = S<|> }\n+\"#,\n+            expect![[r#\"\n+                [\n+                    CompletionItem {\n+                        label: \"Spam::Bar(\u2026)\",\n+                        source_range: 75..76,\n+                        delete: 75..76,\n+                        insert: \"Spam::Bar($0)\",\n+                        kind: EnumVariant,\n+                        lookup: \"Spam::Bar\",\n+                        detail: \"(i32)\",\n+                        trigger_call_info: true,\n+                    },\n+                    CompletionItem {\n+                        label: \"m\",\n+                        source_range: 75..76,\n+                        delete: 75..76,\n+                        insert: \"m\",\n+                        kind: Module,\n+                    },\n+                    CompletionItem {\n+                        label: \"m::Spam::Foo\",\n+                        source_range: 75..76,\n+                        delete: 75..76,\n+                        insert: \"m::Spam::Foo\",\n+                        kind: EnumVariant,\n+                        lookup: \"Spam::Foo\",\n+                        detail: \"()\",\n+                    },\n+                    CompletionItem {\n+                        label: \"main()\",\n+                        source_range: 75..76,\n+                        delete: 75..76,\n+                        insert: \"main()$0\",\n+                        kind: Function,\n+                        lookup: \"main\",\n+                        detail: \"fn main()\",\n+                    },\n+                ]\n+            \"#]],\n+        )\n+    }\n+\n+    #[test]\n+    fn sets_deprecated_flag_in_items() {\n+        check(\n+            r#\"\n+#[deprecated]\n+fn something_deprecated() {}\n+#[deprecated(since = \"1.0.0\")]\n+fn something_else_deprecated() {}\n+\n+fn main() { som<|> }\n+\"#,\n+            expect![[r#\"\n+                [\n+                    CompletionItem {\n+                        label: \"main()\",\n+                        source_range: 121..124,\n+                        delete: 121..124,\n+                        insert: \"main()$0\",\n+                        kind: Function,\n+                        lookup: \"main\",\n+                        detail: \"fn main()\",\n+                    },\n+                    CompletionItem {\n+                        label: \"something_deprecated()\",\n+                        source_range: 121..124,\n+                        delete: 121..124,\n+                        insert: \"something_deprecated()$0\",\n+                        kind: Function,\n+                        lookup: \"something_deprecated\",\n+                        detail: \"fn something_deprecated()\",\n+                        deprecated: true,\n+                    },\n+                    CompletionItem {\n+                        label: \"something_else_deprecated()\",\n+                        source_range: 121..124,\n+                        delete: 121..124,\n+                        insert: \"something_else_deprecated()$0\",\n+                        kind: Function,\n+                        lookup: \"something_else_deprecated\",\n+                        detail: \"fn something_else_deprecated()\",\n+                        deprecated: true,\n+                    },\n+                ]\n+            \"#]],\n+        );\n+\n+        check(\n+            r#\"\n+struct A { #[deprecated] the_field: u32 }\n+fn foo() { A { the<|> } }\n+\"#,\n+            expect![[r#\"\n+                [\n+                    CompletionItem {\n+                        label: \"the_field\",\n+                        source_range: 57..60,\n+                        delete: 57..60,\n+                        insert: \"the_field\",\n+                        kind: Field,\n+                        detail: \"u32\",\n+                        deprecated: true,\n+                    },\n+                ]\n+            \"#]],\n+        );\n+    }\n+\n+    #[test]\n+    fn renders_docs() {\n+        check(\n+            r#\"\n+struct S {\n+    /// Field docs\n+    foo:\n+}\n+impl S {\n+    /// Method docs\n+    fn bar(self) { self.<|> }\n+}\"#,\n+            expect![[r#\"\n+                [\n+                    CompletionItem {\n+                        label: \"bar()\",\n+                        source_range: 94..94,\n+                        delete: 94..94,\n+                        insert: \"bar()$0\",\n+                        kind: Method,\n+                        lookup: \"bar\",\n+                        detail: \"fn bar(self)\",\n+                        documentation: Documentation(\n+                            \"Method docs\",\n+                        ),\n+                    },\n+                    CompletionItem {\n+                        label: \"foo\",\n+                        source_range: 94..94,\n+                        delete: 94..94,\n+                        insert: \"foo\",\n+                        kind: Field,\n+                        detail: \"{unknown}\",\n+                        documentation: Documentation(\n+                            \"Field docs\",\n+                        ),\n+                    },\n+                ]\n+            \"#]],\n+        );\n+\n+        check(\n+            r#\"\n+use self::my<|>;\n+\n+/// mod docs\n+mod my { }\n+\n+/// enum docs\n+enum E {\n+    /// variant docs\n+    V\n+}\n+use self::E::*;\n+\"#,\n+            expect![[r#\"\n+                [\n+                    CompletionItem {\n+                        label: \"E\",\n+                        source_range: 10..12,\n+                        delete: 10..12,\n+                        insert: \"E\",\n+                        kind: Enum,\n+                        documentation: Documentation(\n+                            \"enum docs\",\n+                        ),\n+                    },\n+                    CompletionItem {\n+                        label: \"V\",\n+                        source_range: 10..12,\n+                        delete: 10..12,\n+                        insert: \"V\",\n+                        kind: EnumVariant,\n+                        detail: \"()\",\n+                        documentation: Documentation(\n+                            \"variant docs\",\n+                        ),\n+                    },\n+                    CompletionItem {\n+                        label: \"my\",\n+                        source_range: 10..12,\n+                        delete: 10..12,\n+                        insert: \"my\",\n+                        kind: Module,\n+                        documentation: Documentation(\n+                            \"mod docs\",\n+                        ),\n+                    },\n+                ]\n+            \"#]],\n+        )\n+    }\n+\n+    #[test]\n+    fn dont_render_attrs() {\n+        check(\n+            r#\"\n+struct S;\n+impl S {\n+    #[inline]\n+    fn the_method(&self) { }\n+}\n+fn foo(s: S) { s.<|> }\n+\"#,\n+            expect![[r#\"\n+                [\n+                    CompletionItem {\n+                        label: \"the_method()\",\n+                        source_range: 81..81,\n+                        delete: 81..81,\n+                        insert: \"the_method()$0\",\n+                        kind: Method,\n+                        lookup: \"the_method\",\n+                        detail: \"fn the_method(&self)\",\n+                    },\n+                ]\n+            \"#]],\n+        )\n+    }\n+\n+    #[test]\n+    fn inserts_parens_for_function_calls() {\n+        mark::check!(inserts_parens_for_function_calls);\n+        check_edit(\n+            \"no_args\",\n+            r#\"\n+fn no_args() {}\n+fn main() { no_<|> }\n+\"#,\n+            r#\"\n+fn no_args() {}\n+fn main() { no_args()$0 }\n+\"#,\n+        );\n+\n+        check_edit(\n+            \"with_args\",\n+            r#\"\n+fn with_args(x: i32, y: String) {}\n+fn main() { with_<|> }\n+\"#,\n+            r#\"\n+fn with_args(x: i32, y: String) {}\n+fn main() { with_args(${1:x}, ${2:y})$0 }\n+\"#,\n+        );\n+\n+        check_edit(\n+            \"foo\",\n+            r#\"\n+struct S;\n+impl S {\n+    fn foo(&self) {}\n+}\n+fn bar(s: &S) { s.f<|> }\n+\"#,\n+            r#\"\n+struct S;\n+impl S {\n+    fn foo(&self) {}\n+}\n+fn bar(s: &S) { s.foo()$0 }\n+\"#,\n+        );\n+\n+        check_edit(\n+            \"foo\",\n+            r#\"\n+struct S {}\n+impl S {\n+    fn foo(&self, x: i32) {}\n+}\n+fn bar(s: &S) {\n+    s.f<|>\n+}\n+\"#,\n+            r#\"\n+struct S {}\n+impl S {\n+    fn foo(&self, x: i32) {}\n+}\n+fn bar(s: &S) {\n+    s.foo(${1:x})$0\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn suppress_arg_snippets() {\n+        mark::check!(suppress_arg_snippets);\n+        check_edit_with_config(\n+            CompletionConfig { add_call_argument_snippets: false, ..CompletionConfig::default() },\n+            \"with_args\",\n+            r#\"\n+fn with_args(x: i32, y: String) {}\n+fn main() { with_<|> }\n+\"#,\n+            r#\"\n+fn with_args(x: i32, y: String) {}\n+fn main() { with_args($0) }\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn strips_underscores_from_args() {\n+        check_edit(\n+            \"foo\",\n+            r#\"\n+fn foo(_foo: i32, ___bar: bool, ho_ge_: String) {}\n+fn main() { f<|> }\n+\"#,\n+            r#\"\n+fn foo(_foo: i32, ___bar: bool, ho_ge_: String) {}\n+fn main() { foo(${1:foo}, ${2:bar}, ${3:ho_ge_})$0 }\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn insert_ref_when_matching_local_in_scope() {\n+        check_edit(\n+            \"ref_arg\",\n+            r#\"\n+struct Foo {}\n+fn ref_arg(x: &Foo) {}\n+fn main() {\n+    let x = Foo {};\n+    ref_ar<|>\n+}\n+\"#,\n+            r#\"\n+struct Foo {}\n+fn ref_arg(x: &Foo) {}\n+fn main() {\n+    let x = Foo {};\n+    ref_arg(${1:&x})$0\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn insert_mut_ref_when_matching_local_in_scope() {\n+        check_edit(\n+            \"ref_arg\",\n+            r#\"\n+struct Foo {}\n+fn ref_arg(x: &mut Foo) {}\n+fn main() {\n+    let x = Foo {};\n+    ref_ar<|>\n+}\n+\"#,\n+            r#\"\n+struct Foo {}\n+fn ref_arg(x: &mut Foo) {}\n+fn main() {\n+    let x = Foo {};\n+    ref_arg(${1:&mut x})$0\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn insert_ref_when_matching_local_in_scope_for_method() {\n+        check_edit(\n+            \"apply_foo\",\n+            r#\"\n+struct Foo {}\n+struct Bar {}\n+impl Bar {\n+    fn apply_foo(&self, x: &Foo) {}\n+}\n+\n+fn main() {\n+    let x = Foo {};\n+    let y = Bar {};\n+    y.<|>\n+}\n+\"#,\n+            r#\"\n+struct Foo {}\n+struct Bar {}\n+impl Bar {\n+    fn apply_foo(&self, x: &Foo) {}\n+}\n+\n+fn main() {\n+    let x = Foo {};\n+    let y = Bar {};\n+    y.apply_foo(${1:&x})$0\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn trim_mut_keyword_in_func_completion() {\n+        check_edit(\n+            \"take_mutably\",\n+            r#\"\n+fn take_mutably(mut x: &i32) {}\n+\n+fn main() {\n+    take_m<|>\n+}\n+\"#,\n+            r#\"\n+fn take_mutably(mut x: &i32) {}\n+\n+fn main() {\n+    take_mutably(${1:x})$0\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn inserts_parens_for_tuple_enums() {\n+        mark::check!(inserts_parens_for_tuple_enums);\n+        check_edit(\n+            \"Some\",\n+            r#\"\n+enum Option<T> { Some(T), None }\n+use Option::*;\n+fn main() -> Option<i32> {\n+    Som<|>\n+}\n+\"#,\n+            r#\"\n+enum Option<T> { Some(T), None }\n+use Option::*;\n+fn main() -> Option<i32> {\n+    Some($0)\n+}\n+\"#,\n+        );\n+        check_edit(\n+            \"Some\",\n+            r#\"\n+enum Option<T> { Some(T), None }\n+use Option::*;\n+fn main(value: Option<i32>) {\n+    match value {\n+        Som<|>\n+    }\n+}\n+\"#,\n+            r#\"\n+enum Option<T> { Some(T), None }\n+use Option::*;\n+fn main(value: Option<i32>) {\n+    match value {\n+        Some($0)\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn dont_duplicate_pattern_parens() {\n+        mark::check!(dont_duplicate_pattern_parens);\n+        check_edit(\n+            \"Var\",\n+            r#\"\n+enum E { Var(i32) }\n+fn main() {\n+    match E::Var(92) {\n+        E::<|>(92) => (),\n+    }\n+}\n+\"#,\n+            r#\"\n+enum E { Var(i32) }\n+fn main() {\n+    match E::Var(92) {\n+        E::Var(92) => (),\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn no_call_parens_if_fn_ptr_needed() {\n+        mark::check!(no_call_parens_if_fn_ptr_needed);\n+        check_edit(\n+            \"foo\",\n+            r#\"\n+fn foo(foo: u8, bar: u8) {}\n+struct ManualVtable { f: fn(u8, u8) }\n+\n+fn main() -> ManualVtable {\n+    ManualVtable { f: f<|> }\n+}\n+\"#,\n+            r#\"\n+fn foo(foo: u8, bar: u8) {}\n+struct ManualVtable { f: fn(u8, u8) }\n+\n+fn main() -> ManualVtable {\n+    ManualVtable { f: foo }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn no_parens_in_use_item() {\n+        mark::check!(no_parens_in_use_item);\n+        check_edit(\n+            \"foo\",\n+            r#\"\n+mod m { pub fn foo() {} }\n+use crate::m::f<|>;\n+\"#,\n+            r#\"\n+mod m { pub fn foo() {} }\n+use crate::m::foo;\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn no_parens_in_call() {\n+        check_edit(\n+            \"foo\",\n+            r#\"\n+fn foo(x: i32) {}\n+fn main() { f<|>(); }\n+\"#,\n+            r#\"\n+fn foo(x: i32) {}\n+fn main() { foo(); }\n+\"#,\n+        );\n+        check_edit(\n+            \"foo\",\n+            r#\"\n+struct Foo;\n+impl Foo { fn foo(&self){} }\n+fn f(foo: &Foo) { foo.f<|>(); }\n+\"#,\n+            r#\"\n+struct Foo;\n+impl Foo { fn foo(&self){} }\n+fn f(foo: &Foo) { foo.foo(); }\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn inserts_angle_brackets_for_generics() {\n+        mark::check!(inserts_angle_brackets_for_generics);\n+        check_edit(\n+            \"Vec\",\n+            r#\"\n+struct Vec<T> {}\n+fn foo(xs: Ve<|>)\n+\"#,\n+            r#\"\n+struct Vec<T> {}\n+fn foo(xs: Vec<$0>)\n+\"#,\n+        );\n+        check_edit(\n+            \"Vec\",\n+            r#\"\n+type Vec<T> = (T,);\n+fn foo(xs: Ve<|>)\n+\"#,\n+            r#\"\n+type Vec<T> = (T,);\n+fn foo(xs: Vec<$0>)\n+\"#,\n+        );\n+        check_edit(\n+            \"Vec\",\n+            r#\"\n+struct Vec<T = i128> {}\n+fn foo(xs: Ve<|>)\n+\"#,\n+            r#\"\n+struct Vec<T = i128> {}\n+fn foo(xs: Vec)\n+\"#,\n+        );\n+        check_edit(\n+            \"Vec\",\n+            r#\"\n+struct Vec<T> {}\n+fn foo(xs: Ve<|><i128>)\n+\"#,\n+            r#\"\n+struct Vec<T> {}\n+fn foo(xs: Vec<i128>)\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn dont_insert_macro_call_parens_unncessary() {\n+        mark::check!(dont_insert_macro_call_parens_unncessary);\n+        check_edit(\n+            \"frobnicate!\",\n+            r#\"\n+//- /main.rs crate:main deps:foo\n+use foo::<|>;\n+//- /foo/lib.rs crate:foo\n+#[macro_export]\n+macro_rules frobnicate { () => () }\n+\"#,\n+            r#\"\n+use foo::frobnicate;\n+\"#,\n+        );\n+\n+        check_edit(\n+            \"frobnicate!\",\n+            r#\"\n+macro_rules frobnicate { () => () }\n+fn main() { frob<|>!(); }\n+\"#,\n+            r#\"\n+macro_rules frobnicate { () => () }\n+fn main() { frobnicate!(); }\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn active_param_score() {\n+        mark::check!(active_param_type_match);\n+        check_scores(\n+            r#\"\n+struct S { foo: i64, bar: u32, baz: u32 }\n+fn test(bar: u32) { }\n+fn foo(s: S) { test(s.<|>) }\n+\"#,\n+            expect![[r#\"\n+                fd bar [type+name]\n+                fd baz [type]\n+                fd foo []\n+            \"#]],\n+        );\n+    }\n+\n+    #[test]\n+    fn record_field_scores() {\n+        mark::check!(record_field_type_match);\n+        check_scores(\n+            r#\"\n+struct A { foo: i64, bar: u32, baz: u32 }\n+struct B { x: (), y: f32, bar: u32 }\n+fn foo(a: A) { B { bar: a.<|> }; }\n+\"#,\n+            expect![[r#\"\n+                fd bar [type+name]\n+                fd baz [type]\n+                fd foo []\n+            \"#]],\n+        )\n+    }\n+\n+    #[test]\n+    fn record_field_and_call_scores() {\n+        check_scores(\n+            r#\"\n+struct A { foo: i64, bar: u32, baz: u32 }\n+struct B { x: (), y: f32, bar: u32 }\n+fn f(foo: i64) {  }\n+fn foo(a: A) { B { bar: f(a.<|>) }; }\n+\"#,\n+            expect![[r#\"\n+                fd foo [type+name]\n+                fd bar []\n+                fd baz []\n+            \"#]],\n+        );\n+        check_scores(\n+            r#\"\n+struct A { foo: i64, bar: u32, baz: u32 }\n+struct B { x: (), y: f32, bar: u32 }\n+fn f(foo: i64) {  }\n+fn foo(a: A) { f(B { bar: a.<|> }); }\n+\"#,\n+            expect![[r#\"\n+                fd bar [type+name]\n+                fd baz [type]\n+                fd foo []\n+            \"#]],\n+        );\n+    }\n+\n+    #[test]\n+    fn prioritize_exact_ref_match() {\n+        check_scores(\n+            r#\"\n+struct WorldSnapshot { _f: () };\n+fn go(world: &WorldSnapshot) { go(w<|>) }\n+\"#,\n+            expect![[r#\"\n+                bn world [type+name]\n+                st WorldSnapshot []\n+                fn go(\u2026) []\n+            \"#]],\n+        );\n+    }\n+\n+    #[test]\n+    fn too_many_arguments() {\n+        check_scores(\n+            r#\"\n+struct Foo;\n+fn f(foo: &Foo) { f(foo, w<|>) }\n+\"#,\n+            expect![[r#\"\n+                st Foo []\n+                fn f(\u2026) []\n+                bn foo []\n+            \"#]],\n+        );\n+    }\n+\n+    #[test]\n+    fn guesses_macro_braces() {\n+        check_edit(\n+            \"vec!\",\n+            r#\"\n+/// Creates a [`Vec`] containing the arguments.\n+///\n+/// ```\n+/// let v = vec![1, 2, 3];\n+/// assert_eq!(v[0], 1);\n+/// assert_eq!(v[1], 2);\n+/// assert_eq!(v[2], 3);\n+/// ```\n+macro_rules! vec { () => {} }\n+\n+fn fn main() { v<|> }\n+\"#,\n+            r#\"\n+/// Creates a [`Vec`] containing the arguments.\n+///\n+/// ```\n+/// let v = vec![1, 2, 3];\n+/// assert_eq!(v[0], 1);\n+/// assert_eq!(v[1], 2);\n+/// assert_eq!(v[2], 3);\n+/// ```\n+macro_rules! vec { () => {} }\n+\n+fn fn main() { vec![$0] }\n+\"#,\n+        );\n+\n+        check_edit(\n+            \"foo!\",\n+            r#\"\n+/// Foo\n+///\n+/// Don't call `fooo!()` `fooo!()`, or `_foo![]` `_foo![]`,\n+/// call as `let _=foo!  { hello world };`\n+macro_rules! foo { () => {} }\n+fn main() { <|> }\n+\"#,\n+            r#\"\n+/// Foo\n+///\n+/// Don't call `fooo!()` `fooo!()`, or `_foo![]` `_foo![]`,\n+/// call as `let _=foo!  { hello world };`\n+macro_rules! foo { () => {} }\n+fn main() { foo! {$0} }\n+\"#,\n+        )\n     }\n }"}, {"sha": "89c0a997816d758f84a9c078496c4a943088e437", "filename": "crates/completion/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9822acac0d9913a64d5ebf5ecda967eecbea5037/crates%2Fcompletion%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9822acac0d9913a64d5ebf5ecda967eecbea5037/crates%2Fcompletion%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcompletion%2Fsrc%2Flib.rs?ref=9822acac0d9913a64d5ebf5ecda967eecbea5037", "patch": "@@ -3,7 +3,6 @@\n mod config;\n mod item;\n mod context;\n-mod presentation;\n mod patterns;\n mod generated_lint_completions;\n #[cfg(test)]"}, {"sha": "17584f734429fe0806c77f612510d68bae300d35", "filename": "crates/completion/src/presentation.rs", "status": "removed", "additions": 0, "deletions": 1412, "changes": 1412, "blob_url": "https://github.com/rust-lang/rust/blob/f731d910cbfe36bbdfa3a3f1415d5c48c4a79238/crates%2Fcompletion%2Fsrc%2Fpresentation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f731d910cbfe36bbdfa3a3f1415d5c48c4a79238/crates%2Fcompletion%2Fsrc%2Fpresentation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcompletion%2Fsrc%2Fpresentation.rs?ref=f731d910cbfe36bbdfa3a3f1415d5c48c4a79238", "patch": "@@ -1,1412 +0,0 @@\n-//! This modules takes care of rendering various definitions as completion items.\n-//! It also handles scoring (sorting) completions.\n-\n-use hir::{HasAttrs, HasSource, HirDisplay, ModPath, Mutability, ScopeDef, StructKind, Type};\n-use itertools::Itertools;\n-use syntax::{ast::NameOwner, display::*};\n-use test_utils::mark;\n-\n-use crate::{\n-    // display::{const_label, function_declaration, macro_label, type_label},\n-    CompletionScore,\n-    RootDatabase,\n-    {\n-        item::Builder, CompletionContext, CompletionItem, CompletionItemKind, CompletionKind,\n-        Completions,\n-    },\n-};\n-\n-impl Completions {\n-    pub(crate) fn add_field(&mut self, ctx: &CompletionContext, field: hir::Field, ty: &Type) {\n-        let is_deprecated = is_deprecated(field, ctx.db);\n-        let name = field.name(ctx.db);\n-        let mut item =\n-            CompletionItem::new(CompletionKind::Reference, ctx.source_range(), name.to_string())\n-                .kind(CompletionItemKind::Field)\n-                .detail(ty.display(ctx.db).to_string())\n-                .set_documentation(field.docs(ctx.db))\n-                .set_deprecated(is_deprecated);\n-\n-        if let Some(score) = compute_score(ctx, &ty, &name.to_string()) {\n-            item = item.set_score(score);\n-        }\n-\n-        item.add_to(self);\n-    }\n-\n-    pub(crate) fn add_tuple_field(&mut self, ctx: &CompletionContext, field: usize, ty: &Type) {\n-        CompletionItem::new(CompletionKind::Reference, ctx.source_range(), field.to_string())\n-            .kind(CompletionItemKind::Field)\n-            .detail(ty.display(ctx.db).to_string())\n-            .add_to(self);\n-    }\n-\n-    pub(crate) fn add_resolution(\n-        &mut self,\n-        ctx: &CompletionContext,\n-        local_name: String,\n-        resolution: &ScopeDef,\n-    ) {\n-        use hir::ModuleDef::*;\n-\n-        let completion_kind = match resolution {\n-            ScopeDef::ModuleDef(BuiltinType(..)) => CompletionKind::BuiltinType,\n-            _ => CompletionKind::Reference,\n-        };\n-\n-        let kind = match resolution {\n-            ScopeDef::ModuleDef(Module(..)) => CompletionItemKind::Module,\n-            ScopeDef::ModuleDef(Function(func)) => {\n-                self.add_function(ctx, *func, Some(local_name));\n-                return;\n-            }\n-            ScopeDef::ModuleDef(Adt(hir::Adt::Struct(_))) => CompletionItemKind::Struct,\n-            // FIXME: add CompletionItemKind::Union\n-            ScopeDef::ModuleDef(Adt(hir::Adt::Union(_))) => CompletionItemKind::Struct,\n-            ScopeDef::ModuleDef(Adt(hir::Adt::Enum(_))) => CompletionItemKind::Enum,\n-\n-            ScopeDef::ModuleDef(EnumVariant(var)) => {\n-                self.add_enum_variant(ctx, *var, Some(local_name));\n-                return;\n-            }\n-            ScopeDef::ModuleDef(Const(..)) => CompletionItemKind::Const,\n-            ScopeDef::ModuleDef(Static(..)) => CompletionItemKind::Static,\n-            ScopeDef::ModuleDef(Trait(..)) => CompletionItemKind::Trait,\n-            ScopeDef::ModuleDef(TypeAlias(..)) => CompletionItemKind::TypeAlias,\n-            ScopeDef::ModuleDef(BuiltinType(..)) => CompletionItemKind::BuiltinType,\n-            ScopeDef::GenericParam(..) => CompletionItemKind::TypeParam,\n-            ScopeDef::Local(..) => CompletionItemKind::Binding,\n-            // (does this need its own kind?)\n-            ScopeDef::AdtSelfType(..) | ScopeDef::ImplSelfType(..) => CompletionItemKind::TypeParam,\n-            ScopeDef::MacroDef(mac) => {\n-                self.add_macro(ctx, Some(local_name), *mac);\n-                return;\n-            }\n-            ScopeDef::Unknown => {\n-                CompletionItem::new(CompletionKind::Reference, ctx.source_range(), local_name)\n-                    .kind(CompletionItemKind::UnresolvedReference)\n-                    .add_to(self);\n-                return;\n-            }\n-        };\n-\n-        let docs = match resolution {\n-            ScopeDef::ModuleDef(Module(it)) => it.docs(ctx.db),\n-            ScopeDef::ModuleDef(Adt(it)) => it.docs(ctx.db),\n-            ScopeDef::ModuleDef(EnumVariant(it)) => it.docs(ctx.db),\n-            ScopeDef::ModuleDef(Const(it)) => it.docs(ctx.db),\n-            ScopeDef::ModuleDef(Static(it)) => it.docs(ctx.db),\n-            ScopeDef::ModuleDef(Trait(it)) => it.docs(ctx.db),\n-            ScopeDef::ModuleDef(TypeAlias(it)) => it.docs(ctx.db),\n-            _ => None,\n-        };\n-\n-        let mut item = CompletionItem::new(completion_kind, ctx.source_range(), local_name.clone());\n-        if let ScopeDef::Local(local) = resolution {\n-            let ty = local.ty(ctx.db);\n-            if !ty.is_unknown() {\n-                item = item.detail(ty.display(ctx.db).to_string());\n-            }\n-        };\n-\n-        let mut ref_match = None;\n-        if let ScopeDef::Local(local) = resolution {\n-            if let Some((active_name, active_type)) = ctx.active_name_and_type() {\n-                let ty = local.ty(ctx.db);\n-                if let Some(score) =\n-                    compute_score_from_active(&active_type, &active_name, &ty, &local_name)\n-                {\n-                    item = item.set_score(score);\n-                }\n-                ref_match = refed_type_matches(&active_type, &active_name, &ty, &local_name);\n-            }\n-        }\n-\n-        // Add `<>` for generic types\n-        if ctx.is_path_type && !ctx.has_type_args && ctx.config.add_call_parenthesis {\n-            if let Some(cap) = ctx.config.snippet_cap {\n-                let has_non_default_type_params = match resolution {\n-                    ScopeDef::ModuleDef(Adt(it)) => it.has_non_default_type_params(ctx.db),\n-                    ScopeDef::ModuleDef(TypeAlias(it)) => it.has_non_default_type_params(ctx.db),\n-                    _ => false,\n-                };\n-                if has_non_default_type_params {\n-                    mark::hit!(inserts_angle_brackets_for_generics);\n-                    item = item\n-                        .lookup_by(local_name.clone())\n-                        .label(format!(\"{}<\u2026>\", local_name))\n-                        .insert_snippet(cap, format!(\"{}<$0>\", local_name));\n-                }\n-            }\n-        }\n-\n-        item.kind(kind).set_documentation(docs).set_ref_match(ref_match).add_to(self)\n-    }\n-\n-    pub(crate) fn add_macro(\n-        &mut self,\n-        ctx: &CompletionContext,\n-        name: Option<String>,\n-        macro_: hir::MacroDef,\n-    ) {\n-        // FIXME: Currently proc-macro do not have ast-node,\n-        // such that it does not have source\n-        if macro_.is_proc_macro() {\n-            return;\n-        }\n-\n-        let name = match name {\n-            Some(it) => it,\n-            None => return,\n-        };\n-\n-        let ast_node = macro_.source(ctx.db).value;\n-        let detail = macro_label(&ast_node);\n-\n-        let docs = macro_.docs(ctx.db);\n-\n-        let mut builder = CompletionItem::new(\n-            CompletionKind::Reference,\n-            ctx.source_range(),\n-            &format!(\"{}!\", name),\n-        )\n-        .kind(CompletionItemKind::Macro)\n-        .set_documentation(docs.clone())\n-        .set_deprecated(is_deprecated(macro_, ctx.db))\n-        .detail(detail);\n-\n-        let needs_bang = ctx.use_item_syntax.is_none() && !ctx.is_macro_call;\n-        builder = match ctx.config.snippet_cap {\n-            Some(cap) if needs_bang => {\n-                let docs = docs.as_ref().map_or(\"\", |s| s.as_str());\n-                let (bra, ket) = guess_macro_braces(&name, docs);\n-                builder\n-                    .insert_snippet(cap, format!(\"{}!{}$0{}\", name, bra, ket))\n-                    .label(format!(\"{}!{}\u2026{}\", name, bra, ket))\n-                    .lookup_by(format!(\"{}!\", name))\n-            }\n-            None if needs_bang => builder.insert_text(format!(\"{}!\", name)),\n-            _ => {\n-                mark::hit!(dont_insert_macro_call_parens_unncessary);\n-                builder.insert_text(name)\n-            }\n-        };\n-\n-        self.add(builder.build());\n-    }\n-\n-    pub(crate) fn add_function(\n-        &mut self,\n-        ctx: &CompletionContext,\n-        func: hir::Function,\n-        local_name: Option<String>,\n-    ) {\n-        fn add_arg(arg: &str, ty: &Type, ctx: &CompletionContext) -> String {\n-            if let Some(derefed_ty) = ty.remove_ref() {\n-                for (name, local) in ctx.locals.iter() {\n-                    if name == arg && local.ty(ctx.db) == derefed_ty {\n-                        return (if ty.is_mutable_reference() { \"&mut \" } else { \"&\" }).to_string()\n-                            + &arg.to_string();\n-                    }\n-                }\n-            }\n-            arg.to_string()\n-        };\n-        let name = local_name.unwrap_or_else(|| func.name(ctx.db).to_string());\n-        let ast_node = func.source(ctx.db).value;\n-\n-        let mut builder =\n-            CompletionItem::new(CompletionKind::Reference, ctx.source_range(), name.clone())\n-                .kind(if func.self_param(ctx.db).is_some() {\n-                    CompletionItemKind::Method\n-                } else {\n-                    CompletionItemKind::Function\n-                })\n-                .set_documentation(func.docs(ctx.db))\n-                .set_deprecated(is_deprecated(func, ctx.db))\n-                .detail(function_declaration(&ast_node));\n-\n-        let params_ty = func.params(ctx.db);\n-        let params = ast_node\n-            .param_list()\n-            .into_iter()\n-            .flat_map(|it| it.params())\n-            .zip(params_ty)\n-            .flat_map(|(it, param_ty)| {\n-                if let Some(pat) = it.pat() {\n-                    let name = pat.to_string();\n-                    let arg = name.trim_start_matches(\"mut \").trim_start_matches('_');\n-                    return Some(add_arg(arg, param_ty.ty(), ctx));\n-                }\n-                None\n-            })\n-            .collect();\n-\n-        builder = builder.add_call_parens(ctx, name, Params::Named(params));\n-\n-        self.add(builder.build())\n-    }\n-\n-    pub(crate) fn add_const(&mut self, ctx: &CompletionContext, constant: hir::Const) {\n-        let ast_node = constant.source(ctx.db).value;\n-        let name = match ast_node.name() {\n-            Some(name) => name,\n-            _ => return,\n-        };\n-        let detail = const_label(&ast_node);\n-\n-        CompletionItem::new(CompletionKind::Reference, ctx.source_range(), name.text().to_string())\n-            .kind(CompletionItemKind::Const)\n-            .set_documentation(constant.docs(ctx.db))\n-            .set_deprecated(is_deprecated(constant, ctx.db))\n-            .detail(detail)\n-            .add_to(self);\n-    }\n-\n-    pub(crate) fn add_type_alias(&mut self, ctx: &CompletionContext, type_alias: hir::TypeAlias) {\n-        let type_def = type_alias.source(ctx.db).value;\n-        let name = match type_def.name() {\n-            Some(name) => name,\n-            _ => return,\n-        };\n-        let detail = type_label(&type_def);\n-\n-        CompletionItem::new(CompletionKind::Reference, ctx.source_range(), name.text().to_string())\n-            .kind(CompletionItemKind::TypeAlias)\n-            .set_documentation(type_alias.docs(ctx.db))\n-            .set_deprecated(is_deprecated(type_alias, ctx.db))\n-            .detail(detail)\n-            .add_to(self);\n-    }\n-\n-    pub(crate) fn add_qualified_enum_variant(\n-        &mut self,\n-        ctx: &CompletionContext,\n-        variant: hir::EnumVariant,\n-        path: ModPath,\n-    ) {\n-        self.add_enum_variant_impl(ctx, variant, None, Some(path))\n-    }\n-\n-    pub(crate) fn add_enum_variant(\n-        &mut self,\n-        ctx: &CompletionContext,\n-        variant: hir::EnumVariant,\n-        local_name: Option<String>,\n-    ) {\n-        self.add_enum_variant_impl(ctx, variant, local_name, None)\n-    }\n-\n-    fn add_enum_variant_impl(\n-        &mut self,\n-        ctx: &CompletionContext,\n-        variant: hir::EnumVariant,\n-        local_name: Option<String>,\n-        path: Option<ModPath>,\n-    ) {\n-        let is_deprecated = is_deprecated(variant, ctx.db);\n-        let name = local_name.unwrap_or_else(|| variant.name(ctx.db).to_string());\n-        let (qualified_name, short_qualified_name) = match &path {\n-            Some(path) => {\n-                let full = path.to_string();\n-                let short =\n-                    path.segments[path.segments.len().saturating_sub(2)..].iter().join(\"::\");\n-                (full, short)\n-            }\n-            None => (name.to_string(), name.to_string()),\n-        };\n-        let detail_types = variant\n-            .fields(ctx.db)\n-            .into_iter()\n-            .map(|field| (field.name(ctx.db), field.signature_ty(ctx.db)));\n-        let variant_kind = variant.kind(ctx.db);\n-        let detail = match variant_kind {\n-            StructKind::Tuple | StructKind::Unit => format!(\n-                \"({})\",\n-                detail_types.map(|(_, t)| t.display(ctx.db).to_string()).format(\", \")\n-            ),\n-            StructKind::Record => format!(\n-                \"{{ {} }}\",\n-                detail_types\n-                    .map(|(n, t)| format!(\"{}: {}\", n, t.display(ctx.db).to_string()))\n-                    .format(\", \")\n-            ),\n-        };\n-        let mut res = CompletionItem::new(\n-            CompletionKind::Reference,\n-            ctx.source_range(),\n-            qualified_name.clone(),\n-        )\n-        .kind(CompletionItemKind::EnumVariant)\n-        .set_documentation(variant.docs(ctx.db))\n-        .set_deprecated(is_deprecated)\n-        .detail(detail);\n-\n-        if variant_kind == StructKind::Tuple {\n-            mark::hit!(inserts_parens_for_tuple_enums);\n-            let params = Params::Anonymous(variant.fields(ctx.db).len());\n-            res = res.add_call_parens(ctx, short_qualified_name, params)\n-        } else if path.is_some() {\n-            res = res.lookup_by(short_qualified_name);\n-        }\n-\n-        res.add_to(self);\n-    }\n-}\n-\n-fn compute_score_from_active(\n-    active_type: &Type,\n-    active_name: &str,\n-    ty: &Type,\n-    name: &str,\n-) -> Option<CompletionScore> {\n-    // Compute score\n-    // For the same type\n-    if active_type != ty {\n-        return None;\n-    }\n-\n-    let mut res = CompletionScore::TypeMatch;\n-\n-    // If same type + same name then go top position\n-    if active_name == name {\n-        res = CompletionScore::TypeAndNameMatch\n-    }\n-\n-    Some(res)\n-}\n-fn refed_type_matches(\n-    active_type: &Type,\n-    active_name: &str,\n-    ty: &Type,\n-    name: &str,\n-) -> Option<(Mutability, CompletionScore)> {\n-    let derefed_active = active_type.remove_ref()?;\n-    let score = compute_score_from_active(&derefed_active, &active_name, &ty, &name)?;\n-    Some((\n-        if active_type.is_mutable_reference() { Mutability::Mut } else { Mutability::Shared },\n-        score,\n-    ))\n-}\n-\n-fn compute_score(ctx: &CompletionContext, ty: &Type, name: &str) -> Option<CompletionScore> {\n-    let (active_name, active_type) = ctx.active_name_and_type()?;\n-    compute_score_from_active(&active_type, &active_name, ty, name)\n-}\n-\n-enum Params {\n-    Named(Vec<String>),\n-    Anonymous(usize),\n-}\n-\n-impl Params {\n-    fn len(&self) -> usize {\n-        match self {\n-            Params::Named(xs) => xs.len(),\n-            Params::Anonymous(len) => *len,\n-        }\n-    }\n-\n-    fn is_empty(&self) -> bool {\n-        self.len() == 0\n-    }\n-}\n-\n-impl Builder {\n-    fn add_call_parens(mut self, ctx: &CompletionContext, name: String, params: Params) -> Builder {\n-        if !ctx.config.add_call_parenthesis {\n-            return self;\n-        }\n-        if ctx.use_item_syntax.is_some() {\n-            mark::hit!(no_parens_in_use_item);\n-            return self;\n-        }\n-        if ctx.is_pattern_call {\n-            mark::hit!(dont_duplicate_pattern_parens);\n-            return self;\n-        }\n-        if ctx.is_call {\n-            return self;\n-        }\n-\n-        // Don't add parentheses if the expected type is some function reference.\n-        if let Some(ty) = &ctx.expected_type {\n-            if ty.is_fn() {\n-                mark::hit!(no_call_parens_if_fn_ptr_needed);\n-                return self;\n-            }\n-        }\n-\n-        let cap = match ctx.config.snippet_cap {\n-            Some(it) => it,\n-            None => return self,\n-        };\n-        // If not an import, add parenthesis automatically.\n-        mark::hit!(inserts_parens_for_function_calls);\n-\n-        let (snippet, label) = if params.is_empty() {\n-            (format!(\"{}()$0\", name), format!(\"{}()\", name))\n-        } else {\n-            self = self.trigger_call_info();\n-            let snippet = match (ctx.config.add_call_argument_snippets, params) {\n-                (true, Params::Named(params)) => {\n-                    let function_params_snippet =\n-                        params.iter().enumerate().format_with(\", \", |(index, param_name), f| {\n-                            f(&format_args!(\"${{{}:{}}}\", index + 1, param_name))\n-                        });\n-                    format!(\"{}({})$0\", name, function_params_snippet)\n-                }\n-                _ => {\n-                    mark::hit!(suppress_arg_snippets);\n-                    format!(\"{}($0)\", name)\n-                }\n-            };\n-\n-            (snippet, format!(\"{}(\u2026)\", name))\n-        };\n-        self.lookup_by(name).label(label).insert_snippet(cap, snippet)\n-    }\n-}\n-\n-fn is_deprecated(node: impl HasAttrs, db: &RootDatabase) -> bool {\n-    node.attrs(db).by_key(\"deprecated\").exists()\n-}\n-\n-fn guess_macro_braces(macro_name: &str, docs: &str) -> (&'static str, &'static str) {\n-    let mut votes = [0, 0, 0];\n-    for (idx, s) in docs.match_indices(&macro_name) {\n-        let (before, after) = (&docs[..idx], &docs[idx + s.len()..]);\n-        // Ensure to match the full word\n-        if after.starts_with('!')\n-            && !before.ends_with(|c: char| c == '_' || c.is_ascii_alphanumeric())\n-        {\n-            // It may have spaces before the braces like `foo! {}`\n-            match after[1..].chars().find(|&c| !c.is_whitespace()) {\n-                Some('{') => votes[0] += 1,\n-                Some('[') => votes[1] += 1,\n-                Some('(') => votes[2] += 1,\n-                _ => {}\n-            }\n-        }\n-    }\n-\n-    // Insert a space before `{}`.\n-    // We prefer the last one when some votes equal.\n-    let (_vote, (bra, ket)) = votes\n-        .iter()\n-        .zip(&[(\" {\", \"}\"), (\"[\", \"]\"), (\"(\", \")\")])\n-        .max_by_key(|&(&vote, _)| vote)\n-        .unwrap();\n-    (*bra, *ket)\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    use std::cmp::Reverse;\n-\n-    use expect_test::{expect, Expect};\n-    use test_utils::mark;\n-\n-    use crate::{\n-        test_utils::{check_edit, check_edit_with_config, do_completion, get_all_items},\n-        CompletionConfig, CompletionKind, CompletionScore,\n-    };\n-\n-    fn check(ra_fixture: &str, expect: Expect) {\n-        let actual = do_completion(ra_fixture, CompletionKind::Reference);\n-        expect.assert_debug_eq(&actual);\n-    }\n-\n-    fn check_scores(ra_fixture: &str, expect: Expect) {\n-        fn display_score(score: Option<CompletionScore>) -> &'static str {\n-            match score {\n-                Some(CompletionScore::TypeMatch) => \"[type]\",\n-                Some(CompletionScore::TypeAndNameMatch) => \"[type+name]\",\n-                None => \"[]\".into(),\n-            }\n-        }\n-\n-        let mut completions = get_all_items(CompletionConfig::default(), ra_fixture);\n-        completions.sort_by_key(|it| (Reverse(it.score()), it.label().to_string()));\n-        let actual = completions\n-            .into_iter()\n-            .filter(|it| it.completion_kind == CompletionKind::Reference)\n-            .map(|it| {\n-                let tag = it.kind().unwrap().tag();\n-                let score = display_score(it.score());\n-                format!(\"{} {} {}\\n\", tag, it.label(), score)\n-            })\n-            .collect::<String>();\n-        expect.assert_eq(&actual);\n-    }\n-\n-    #[test]\n-    fn enum_detail_includes_record_fields() {\n-        check(\n-            r#\"\n-enum Foo { Foo { x: i32, y: i32 } }\n-\n-fn main() { Foo::Fo<|> }\n-\"#,\n-            expect![[r#\"\n-                [\n-                    CompletionItem {\n-                        label: \"Foo\",\n-                        source_range: 54..56,\n-                        delete: 54..56,\n-                        insert: \"Foo\",\n-                        kind: EnumVariant,\n-                        detail: \"{ x: i32, y: i32 }\",\n-                    },\n-                ]\n-            \"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn enum_detail_doesnt_include_tuple_fields() {\n-        check(\n-            r#\"\n-enum Foo { Foo (i32, i32) }\n-\n-fn main() { Foo::Fo<|> }\n-\"#,\n-            expect![[r#\"\n-                [\n-                    CompletionItem {\n-                        label: \"Foo(\u2026)\",\n-                        source_range: 46..48,\n-                        delete: 46..48,\n-                        insert: \"Foo($0)\",\n-                        kind: EnumVariant,\n-                        lookup: \"Foo\",\n-                        detail: \"(i32, i32)\",\n-                        trigger_call_info: true,\n-                    },\n-                ]\n-            \"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn enum_detail_just_parentheses_for_unit() {\n-        check(\n-            r#\"\n-enum Foo { Foo }\n-\n-fn main() { Foo::Fo<|> }\n-\"#,\n-            expect![[r#\"\n-                [\n-                    CompletionItem {\n-                        label: \"Foo\",\n-                        source_range: 35..37,\n-                        delete: 35..37,\n-                        insert: \"Foo\",\n-                        kind: EnumVariant,\n-                        detail: \"()\",\n-                    },\n-                ]\n-            \"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn lookup_enums_by_two_qualifiers() {\n-        check(\n-            r#\"\n-mod m {\n-    pub enum Spam { Foo, Bar(i32) }\n-}\n-fn main() { let _: m::Spam = S<|> }\n-\"#,\n-            expect![[r#\"\n-                [\n-                    CompletionItem {\n-                        label: \"Spam::Bar(\u2026)\",\n-                        source_range: 75..76,\n-                        delete: 75..76,\n-                        insert: \"Spam::Bar($0)\",\n-                        kind: EnumVariant,\n-                        lookup: \"Spam::Bar\",\n-                        detail: \"(i32)\",\n-                        trigger_call_info: true,\n-                    },\n-                    CompletionItem {\n-                        label: \"m\",\n-                        source_range: 75..76,\n-                        delete: 75..76,\n-                        insert: \"m\",\n-                        kind: Module,\n-                    },\n-                    CompletionItem {\n-                        label: \"m::Spam::Foo\",\n-                        source_range: 75..76,\n-                        delete: 75..76,\n-                        insert: \"m::Spam::Foo\",\n-                        kind: EnumVariant,\n-                        lookup: \"Spam::Foo\",\n-                        detail: \"()\",\n-                    },\n-                    CompletionItem {\n-                        label: \"main()\",\n-                        source_range: 75..76,\n-                        delete: 75..76,\n-                        insert: \"main()$0\",\n-                        kind: Function,\n-                        lookup: \"main\",\n-                        detail: \"fn main()\",\n-                    },\n-                ]\n-            \"#]],\n-        )\n-    }\n-\n-    #[test]\n-    fn sets_deprecated_flag_in_items() {\n-        check(\n-            r#\"\n-#[deprecated]\n-fn something_deprecated() {}\n-#[deprecated(since = \"1.0.0\")]\n-fn something_else_deprecated() {}\n-\n-fn main() { som<|> }\n-\"#,\n-            expect![[r#\"\n-                [\n-                    CompletionItem {\n-                        label: \"main()\",\n-                        source_range: 121..124,\n-                        delete: 121..124,\n-                        insert: \"main()$0\",\n-                        kind: Function,\n-                        lookup: \"main\",\n-                        detail: \"fn main()\",\n-                    },\n-                    CompletionItem {\n-                        label: \"something_deprecated()\",\n-                        source_range: 121..124,\n-                        delete: 121..124,\n-                        insert: \"something_deprecated()$0\",\n-                        kind: Function,\n-                        lookup: \"something_deprecated\",\n-                        detail: \"fn something_deprecated()\",\n-                        deprecated: true,\n-                    },\n-                    CompletionItem {\n-                        label: \"something_else_deprecated()\",\n-                        source_range: 121..124,\n-                        delete: 121..124,\n-                        insert: \"something_else_deprecated()$0\",\n-                        kind: Function,\n-                        lookup: \"something_else_deprecated\",\n-                        detail: \"fn something_else_deprecated()\",\n-                        deprecated: true,\n-                    },\n-                ]\n-            \"#]],\n-        );\n-\n-        check(\n-            r#\"\n-struct A { #[deprecated] the_field: u32 }\n-fn foo() { A { the<|> } }\n-\"#,\n-            expect![[r#\"\n-                [\n-                    CompletionItem {\n-                        label: \"the_field\",\n-                        source_range: 57..60,\n-                        delete: 57..60,\n-                        insert: \"the_field\",\n-                        kind: Field,\n-                        detail: \"u32\",\n-                        deprecated: true,\n-                    },\n-                ]\n-            \"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn renders_docs() {\n-        check(\n-            r#\"\n-struct S {\n-    /// Field docs\n-    foo:\n-}\n-impl S {\n-    /// Method docs\n-    fn bar(self) { self.<|> }\n-}\"#,\n-            expect![[r#\"\n-                [\n-                    CompletionItem {\n-                        label: \"bar()\",\n-                        source_range: 94..94,\n-                        delete: 94..94,\n-                        insert: \"bar()$0\",\n-                        kind: Method,\n-                        lookup: \"bar\",\n-                        detail: \"fn bar(self)\",\n-                        documentation: Documentation(\n-                            \"Method docs\",\n-                        ),\n-                    },\n-                    CompletionItem {\n-                        label: \"foo\",\n-                        source_range: 94..94,\n-                        delete: 94..94,\n-                        insert: \"foo\",\n-                        kind: Field,\n-                        detail: \"{unknown}\",\n-                        documentation: Documentation(\n-                            \"Field docs\",\n-                        ),\n-                    },\n-                ]\n-            \"#]],\n-        );\n-\n-        check(\n-            r#\"\n-use self::my<|>;\n-\n-/// mod docs\n-mod my { }\n-\n-/// enum docs\n-enum E {\n-    /// variant docs\n-    V\n-}\n-use self::E::*;\n-\"#,\n-            expect![[r#\"\n-                [\n-                    CompletionItem {\n-                        label: \"E\",\n-                        source_range: 10..12,\n-                        delete: 10..12,\n-                        insert: \"E\",\n-                        kind: Enum,\n-                        documentation: Documentation(\n-                            \"enum docs\",\n-                        ),\n-                    },\n-                    CompletionItem {\n-                        label: \"V\",\n-                        source_range: 10..12,\n-                        delete: 10..12,\n-                        insert: \"V\",\n-                        kind: EnumVariant,\n-                        detail: \"()\",\n-                        documentation: Documentation(\n-                            \"variant docs\",\n-                        ),\n-                    },\n-                    CompletionItem {\n-                        label: \"my\",\n-                        source_range: 10..12,\n-                        delete: 10..12,\n-                        insert: \"my\",\n-                        kind: Module,\n-                        documentation: Documentation(\n-                            \"mod docs\",\n-                        ),\n-                    },\n-                ]\n-            \"#]],\n-        )\n-    }\n-\n-    #[test]\n-    fn dont_render_attrs() {\n-        check(\n-            r#\"\n-struct S;\n-impl S {\n-    #[inline]\n-    fn the_method(&self) { }\n-}\n-fn foo(s: S) { s.<|> }\n-\"#,\n-            expect![[r#\"\n-                [\n-                    CompletionItem {\n-                        label: \"the_method()\",\n-                        source_range: 81..81,\n-                        delete: 81..81,\n-                        insert: \"the_method()$0\",\n-                        kind: Method,\n-                        lookup: \"the_method\",\n-                        detail: \"fn the_method(&self)\",\n-                    },\n-                ]\n-            \"#]],\n-        )\n-    }\n-\n-    #[test]\n-    fn inserts_parens_for_function_calls() {\n-        mark::check!(inserts_parens_for_function_calls);\n-        check_edit(\n-            \"no_args\",\n-            r#\"\n-fn no_args() {}\n-fn main() { no_<|> }\n-\"#,\n-            r#\"\n-fn no_args() {}\n-fn main() { no_args()$0 }\n-\"#,\n-        );\n-\n-        check_edit(\n-            \"with_args\",\n-            r#\"\n-fn with_args(x: i32, y: String) {}\n-fn main() { with_<|> }\n-\"#,\n-            r#\"\n-fn with_args(x: i32, y: String) {}\n-fn main() { with_args(${1:x}, ${2:y})$0 }\n-\"#,\n-        );\n-\n-        check_edit(\n-            \"foo\",\n-            r#\"\n-struct S;\n-impl S {\n-    fn foo(&self) {}\n-}\n-fn bar(s: &S) { s.f<|> }\n-\"#,\n-            r#\"\n-struct S;\n-impl S {\n-    fn foo(&self) {}\n-}\n-fn bar(s: &S) { s.foo()$0 }\n-\"#,\n-        );\n-\n-        check_edit(\n-            \"foo\",\n-            r#\"\n-struct S {}\n-impl S {\n-    fn foo(&self, x: i32) {}\n-}\n-fn bar(s: &S) {\n-    s.f<|>\n-}\n-\"#,\n-            r#\"\n-struct S {}\n-impl S {\n-    fn foo(&self, x: i32) {}\n-}\n-fn bar(s: &S) {\n-    s.foo(${1:x})$0\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn suppress_arg_snippets() {\n-        mark::check!(suppress_arg_snippets);\n-        check_edit_with_config(\n-            CompletionConfig { add_call_argument_snippets: false, ..CompletionConfig::default() },\n-            \"with_args\",\n-            r#\"\n-fn with_args(x: i32, y: String) {}\n-fn main() { with_<|> }\n-\"#,\n-            r#\"\n-fn with_args(x: i32, y: String) {}\n-fn main() { with_args($0) }\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn strips_underscores_from_args() {\n-        check_edit(\n-            \"foo\",\n-            r#\"\n-fn foo(_foo: i32, ___bar: bool, ho_ge_: String) {}\n-fn main() { f<|> }\n-\"#,\n-            r#\"\n-fn foo(_foo: i32, ___bar: bool, ho_ge_: String) {}\n-fn main() { foo(${1:foo}, ${2:bar}, ${3:ho_ge_})$0 }\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn insert_ref_when_matching_local_in_scope() {\n-        check_edit(\n-            \"ref_arg\",\n-            r#\"\n-struct Foo {}\n-fn ref_arg(x: &Foo) {}\n-fn main() {\n-    let x = Foo {};\n-    ref_ar<|>\n-}\n-\"#,\n-            r#\"\n-struct Foo {}\n-fn ref_arg(x: &Foo) {}\n-fn main() {\n-    let x = Foo {};\n-    ref_arg(${1:&x})$0\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn insert_mut_ref_when_matching_local_in_scope() {\n-        check_edit(\n-            \"ref_arg\",\n-            r#\"\n-struct Foo {}\n-fn ref_arg(x: &mut Foo) {}\n-fn main() {\n-    let x = Foo {};\n-    ref_ar<|>\n-}\n-\"#,\n-            r#\"\n-struct Foo {}\n-fn ref_arg(x: &mut Foo) {}\n-fn main() {\n-    let x = Foo {};\n-    ref_arg(${1:&mut x})$0\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn insert_ref_when_matching_local_in_scope_for_method() {\n-        check_edit(\n-            \"apply_foo\",\n-            r#\"\n-struct Foo {}\n-struct Bar {}\n-impl Bar {\n-    fn apply_foo(&self, x: &Foo) {}\n-}\n-\n-fn main() {\n-    let x = Foo {};\n-    let y = Bar {};\n-    y.<|>\n-}\n-\"#,\n-            r#\"\n-struct Foo {}\n-struct Bar {}\n-impl Bar {\n-    fn apply_foo(&self, x: &Foo) {}\n-}\n-\n-fn main() {\n-    let x = Foo {};\n-    let y = Bar {};\n-    y.apply_foo(${1:&x})$0\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn trim_mut_keyword_in_func_completion() {\n-        check_edit(\n-            \"take_mutably\",\n-            r#\"\n-fn take_mutably(mut x: &i32) {}\n-\n-fn main() {\n-    take_m<|>\n-}\n-\"#,\n-            r#\"\n-fn take_mutably(mut x: &i32) {}\n-\n-fn main() {\n-    take_mutably(${1:x})$0\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn inserts_parens_for_tuple_enums() {\n-        mark::check!(inserts_parens_for_tuple_enums);\n-        check_edit(\n-            \"Some\",\n-            r#\"\n-enum Option<T> { Some(T), None }\n-use Option::*;\n-fn main() -> Option<i32> {\n-    Som<|>\n-}\n-\"#,\n-            r#\"\n-enum Option<T> { Some(T), None }\n-use Option::*;\n-fn main() -> Option<i32> {\n-    Some($0)\n-}\n-\"#,\n-        );\n-        check_edit(\n-            \"Some\",\n-            r#\"\n-enum Option<T> { Some(T), None }\n-use Option::*;\n-fn main(value: Option<i32>) {\n-    match value {\n-        Som<|>\n-    }\n-}\n-\"#,\n-            r#\"\n-enum Option<T> { Some(T), None }\n-use Option::*;\n-fn main(value: Option<i32>) {\n-    match value {\n-        Some($0)\n-    }\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn dont_duplicate_pattern_parens() {\n-        mark::check!(dont_duplicate_pattern_parens);\n-        check_edit(\n-            \"Var\",\n-            r#\"\n-enum E { Var(i32) }\n-fn main() {\n-    match E::Var(92) {\n-        E::<|>(92) => (),\n-    }\n-}\n-\"#,\n-            r#\"\n-enum E { Var(i32) }\n-fn main() {\n-    match E::Var(92) {\n-        E::Var(92) => (),\n-    }\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn no_call_parens_if_fn_ptr_needed() {\n-        mark::check!(no_call_parens_if_fn_ptr_needed);\n-        check_edit(\n-            \"foo\",\n-            r#\"\n-fn foo(foo: u8, bar: u8) {}\n-struct ManualVtable { f: fn(u8, u8) }\n-\n-fn main() -> ManualVtable {\n-    ManualVtable { f: f<|> }\n-}\n-\"#,\n-            r#\"\n-fn foo(foo: u8, bar: u8) {}\n-struct ManualVtable { f: fn(u8, u8) }\n-\n-fn main() -> ManualVtable {\n-    ManualVtable { f: foo }\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn no_parens_in_use_item() {\n-        mark::check!(no_parens_in_use_item);\n-        check_edit(\n-            \"foo\",\n-            r#\"\n-mod m { pub fn foo() {} }\n-use crate::m::f<|>;\n-\"#,\n-            r#\"\n-mod m { pub fn foo() {} }\n-use crate::m::foo;\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn no_parens_in_call() {\n-        check_edit(\n-            \"foo\",\n-            r#\"\n-fn foo(x: i32) {}\n-fn main() { f<|>(); }\n-\"#,\n-            r#\"\n-fn foo(x: i32) {}\n-fn main() { foo(); }\n-\"#,\n-        );\n-        check_edit(\n-            \"foo\",\n-            r#\"\n-struct Foo;\n-impl Foo { fn foo(&self){} }\n-fn f(foo: &Foo) { foo.f<|>(); }\n-\"#,\n-            r#\"\n-struct Foo;\n-impl Foo { fn foo(&self){} }\n-fn f(foo: &Foo) { foo.foo(); }\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn inserts_angle_brackets_for_generics() {\n-        mark::check!(inserts_angle_brackets_for_generics);\n-        check_edit(\n-            \"Vec\",\n-            r#\"\n-struct Vec<T> {}\n-fn foo(xs: Ve<|>)\n-\"#,\n-            r#\"\n-struct Vec<T> {}\n-fn foo(xs: Vec<$0>)\n-\"#,\n-        );\n-        check_edit(\n-            \"Vec\",\n-            r#\"\n-type Vec<T> = (T,);\n-fn foo(xs: Ve<|>)\n-\"#,\n-            r#\"\n-type Vec<T> = (T,);\n-fn foo(xs: Vec<$0>)\n-\"#,\n-        );\n-        check_edit(\n-            \"Vec\",\n-            r#\"\n-struct Vec<T = i128> {}\n-fn foo(xs: Ve<|>)\n-\"#,\n-            r#\"\n-struct Vec<T = i128> {}\n-fn foo(xs: Vec)\n-\"#,\n-        );\n-        check_edit(\n-            \"Vec\",\n-            r#\"\n-struct Vec<T> {}\n-fn foo(xs: Ve<|><i128>)\n-\"#,\n-            r#\"\n-struct Vec<T> {}\n-fn foo(xs: Vec<i128>)\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn dont_insert_macro_call_parens_unncessary() {\n-        mark::check!(dont_insert_macro_call_parens_unncessary);\n-        check_edit(\n-            \"frobnicate!\",\n-            r#\"\n-//- /main.rs crate:main deps:foo\n-use foo::<|>;\n-//- /foo/lib.rs crate:foo\n-#[macro_export]\n-macro_rules frobnicate { () => () }\n-\"#,\n-            r#\"\n-use foo::frobnicate;\n-\"#,\n-        );\n-\n-        check_edit(\n-            \"frobnicate!\",\n-            r#\"\n-macro_rules frobnicate { () => () }\n-fn main() { frob<|>!(); }\n-\"#,\n-            r#\"\n-macro_rules frobnicate { () => () }\n-fn main() { frobnicate!(); }\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn active_param_score() {\n-        mark::check!(active_param_type_match);\n-        check_scores(\n-            r#\"\n-struct S { foo: i64, bar: u32, baz: u32 }\n-fn test(bar: u32) { }\n-fn foo(s: S) { test(s.<|>) }\n-\"#,\n-            expect![[r#\"\n-                fd bar [type+name]\n-                fd baz [type]\n-                fd foo []\n-            \"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn record_field_scores() {\n-        mark::check!(record_field_type_match);\n-        check_scores(\n-            r#\"\n-struct A { foo: i64, bar: u32, baz: u32 }\n-struct B { x: (), y: f32, bar: u32 }\n-fn foo(a: A) { B { bar: a.<|> }; }\n-\"#,\n-            expect![[r#\"\n-                fd bar [type+name]\n-                fd baz [type]\n-                fd foo []\n-            \"#]],\n-        )\n-    }\n-\n-    #[test]\n-    fn record_field_and_call_scores() {\n-        check_scores(\n-            r#\"\n-struct A { foo: i64, bar: u32, baz: u32 }\n-struct B { x: (), y: f32, bar: u32 }\n-fn f(foo: i64) {  }\n-fn foo(a: A) { B { bar: f(a.<|>) }; }\n-\"#,\n-            expect![[r#\"\n-                fd foo [type+name]\n-                fd bar []\n-                fd baz []\n-            \"#]],\n-        );\n-        check_scores(\n-            r#\"\n-struct A { foo: i64, bar: u32, baz: u32 }\n-struct B { x: (), y: f32, bar: u32 }\n-fn f(foo: i64) {  }\n-fn foo(a: A) { f(B { bar: a.<|> }); }\n-\"#,\n-            expect![[r#\"\n-                fd bar [type+name]\n-                fd baz [type]\n-                fd foo []\n-            \"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn prioritize_exact_ref_match() {\n-        check_scores(\n-            r#\"\n-struct WorldSnapshot { _f: () };\n-fn go(world: &WorldSnapshot) { go(w<|>) }\n-\"#,\n-            expect![[r#\"\n-                bn world [type+name]\n-                st WorldSnapshot []\n-                fn go(\u2026) []\n-            \"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn too_many_arguments() {\n-        check_scores(\n-            r#\"\n-struct Foo;\n-fn f(foo: &Foo) { f(foo, w<|>) }\n-\"#,\n-            expect![[r#\"\n-                st Foo []\n-                fn f(\u2026) []\n-                bn foo []\n-            \"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn guesses_macro_braces() {\n-        check_edit(\n-            \"vec!\",\n-            r#\"\n-/// Creates a [`Vec`] containing the arguments.\n-///\n-/// ```\n-/// let v = vec![1, 2, 3];\n-/// assert_eq!(v[0], 1);\n-/// assert_eq!(v[1], 2);\n-/// assert_eq!(v[2], 3);\n-/// ```\n-macro_rules! vec { () => {} }\n-\n-fn fn main() { v<|> }\n-\"#,\n-            r#\"\n-/// Creates a [`Vec`] containing the arguments.\n-///\n-/// ```\n-/// let v = vec![1, 2, 3];\n-/// assert_eq!(v[0], 1);\n-/// assert_eq!(v[1], 2);\n-/// assert_eq!(v[2], 3);\n-/// ```\n-macro_rules! vec { () => {} }\n-\n-fn fn main() { vec![$0] }\n-\"#,\n-        );\n-\n-        check_edit(\n-            \"foo!\",\n-            r#\"\n-/// Foo\n-///\n-/// Don't call `fooo!()` `fooo!()`, or `_foo![]` `_foo![]`,\n-/// call as `let _=foo!  { hello world };`\n-macro_rules! foo { () => {} }\n-fn main() { <|> }\n-\"#,\n-            r#\"\n-/// Foo\n-///\n-/// Don't call `fooo!()` `fooo!()`, or `_foo![]` `_foo![]`,\n-/// call as `let _=foo!  { hello world };`\n-macro_rules! foo { () => {} }\n-fn main() { foo! {$0} }\n-\"#,\n-        )\n-    }\n-}"}]}