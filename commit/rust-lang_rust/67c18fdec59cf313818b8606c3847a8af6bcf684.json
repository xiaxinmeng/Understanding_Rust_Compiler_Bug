{"sha": "67c18fdec59cf313818b8606c3847a8af6bcf684", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY3YzE4ZmRlYzU5Y2YzMTM4MThiODYwNmMzODQ3YThhZjZiY2Y2ODQ=", "commit": {"author": {"name": "Mara Bos", "email": "m-ou.se@m-ou.se", "date": "2020-10-10T18:20:14Z"}, "committer": {"name": "Mara Bos", "email": "m-ou.se@m-ou.se", "date": "2020-12-08T21:57:57Z"}, "message": "Use Pin for the 'don't move' requirement of ReentrantMutex.\n\nThe code in io::stdio before this change misused the ReentrantMutexes,\nby calling init() on them and moving them afterwards. Now that\nReentrantMutex requires Pin for init(), this mistake is no longer easy\nto make.", "tree": {"sha": "283449abe305d1eb37410871e507cd1c0fcdcf04", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/283449abe305d1eb37410871e507cd1c0fcdcf04"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/67c18fdec59cf313818b8606c3847a8af6bcf684", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/67c18fdec59cf313818b8606c3847a8af6bcf684", "html_url": "https://github.com/rust-lang/rust/commit/67c18fdec59cf313818b8606c3847a8af6bcf684", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/67c18fdec59cf313818b8606c3847a8af6bcf684/comments", "author": {"login": "m-ou-se", "id": 783247, "node_id": "MDQ6VXNlcjc4MzI0Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/783247?v=4", "gravatar_id": "", "url": "https://api.github.com/users/m-ou-se", "html_url": "https://github.com/m-ou-se", "followers_url": "https://api.github.com/users/m-ou-se/followers", "following_url": "https://api.github.com/users/m-ou-se/following{/other_user}", "gists_url": "https://api.github.com/users/m-ou-se/gists{/gist_id}", "starred_url": "https://api.github.com/users/m-ou-se/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/m-ou-se/subscriptions", "organizations_url": "https://api.github.com/users/m-ou-se/orgs", "repos_url": "https://api.github.com/users/m-ou-se/repos", "events_url": "https://api.github.com/users/m-ou-se/events{/privacy}", "received_events_url": "https://api.github.com/users/m-ou-se/received_events", "type": "User", "site_admin": false}, "committer": {"login": "m-ou-se", "id": 783247, "node_id": "MDQ6VXNlcjc4MzI0Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/783247?v=4", "gravatar_id": "", "url": "https://api.github.com/users/m-ou-se", "html_url": "https://github.com/m-ou-se", "followers_url": "https://api.github.com/users/m-ou-se/followers", "following_url": "https://api.github.com/users/m-ou-se/following{/other_user}", "gists_url": "https://api.github.com/users/m-ou-se/gists{/gist_id}", "starred_url": "https://api.github.com/users/m-ou-se/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/m-ou-se/subscriptions", "organizations_url": "https://api.github.com/users/m-ou-se/orgs", "repos_url": "https://api.github.com/users/m-ou-se/repos", "events_url": "https://api.github.com/users/m-ou-se/events{/privacy}", "received_events_url": "https://api.github.com/users/m-ou-se/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8fe90966e19a4c3b6d05484d5368e5f9b444eb8b", "url": "https://api.github.com/repos/rust-lang/rust/commits/8fe90966e19a4c3b6d05484d5368e5f9b444eb8b", "html_url": "https://github.com/rust-lang/rust/commit/8fe90966e19a4c3b6d05484d5368e5f9b444eb8b"}], "stats": {"total": 143, "additions": 70, "deletions": 73}, "files": [{"sha": "1160011f352875514d15687f05c3fd75d117292f", "filename": "library/std/src/io/stdio.rs", "status": "modified", "additions": 29, "deletions": 25, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/67c18fdec59cf313818b8606c3847a8af6bcf684/library%2Fstd%2Fsrc%2Fio%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67c18fdec59cf313818b8606c3847a8af6bcf684/library%2Fstd%2Fsrc%2Fio%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fstdio.rs?ref=67c18fdec59cf313818b8606c3847a8af6bcf684", "patch": "@@ -9,6 +9,7 @@ use crate::cell::{Cell, RefCell};\n use crate::fmt;\n use crate::io::{self, BufReader, Initializer, IoSlice, IoSliceMut, LineWriter};\n use crate::lazy::SyncOnceCell;\n+use crate::pin::Pin;\n use crate::sync::atomic::{AtomicBool, Ordering};\n use crate::sync::{Arc, Mutex, MutexGuard};\n use crate::sys::stdio;\n@@ -490,7 +491,7 @@ pub struct Stdout {\n     // FIXME: this should be LineWriter or BufWriter depending on the state of\n     //        stdout (tty or not). Note that if this is not line buffered it\n     //        should also flush-on-panic or some form of flush-on-abort.\n-    inner: &'static ReentrantMutex<RefCell<LineWriter<StdoutRaw>>>,\n+    inner: Pin<&'static ReentrantMutex<RefCell<LineWriter<StdoutRaw>>>>,\n }\n \n /// A locked reference to the `Stdout` handle.\n@@ -550,25 +551,29 @@ pub struct StdoutLock<'a> {\n pub fn stdout() -> Stdout {\n     static INSTANCE: SyncOnceCell<ReentrantMutex<RefCell<LineWriter<StdoutRaw>>>> =\n         SyncOnceCell::new();\n+\n+    fn cleanup() {\n+        if let Some(instance) = INSTANCE.get() {\n+            // Flush the data and disable buffering during shutdown\n+            // by replacing the line writer by one with zero\n+            // buffering capacity.\n+            // We use try_lock() instead of lock(), because someone\n+            // might have leaked a StdoutLock, which would\n+            // otherwise cause a deadlock here.\n+            if let Some(lock) = Pin::static_ref(instance).try_lock() {\n+                *lock.borrow_mut() = LineWriter::with_capacity(0, stdout_raw());\n+            }\n+        }\n+    }\n+\n     Stdout {\n-        inner: INSTANCE.get_or_init(|| unsafe {\n-            let _ = sys_common::at_exit(|| {\n-                if let Some(instance) = INSTANCE.get() {\n-                    // Flush the data and disable buffering during shutdown\n-                    // by replacing the line writer by one with zero\n-                    // buffering capacity.\n-                    // We use try_lock() instead of lock(), because someone\n-                    // might have leaked a StdoutLock, which would\n-                    // otherwise cause a deadlock here.\n-                    if let Some(lock) = instance.try_lock() {\n-                        *lock.borrow_mut() = LineWriter::with_capacity(0, stdout_raw());\n-                    }\n-                }\n-            });\n-            let r = ReentrantMutex::new(RefCell::new(LineWriter::new(stdout_raw())));\n-            r.init();\n-            r\n-        }),\n+        inner: Pin::static_ref(&INSTANCE).get_or_init_pin(\n+            || unsafe {\n+                let _ = sys_common::at_exit(cleanup);\n+                ReentrantMutex::new(RefCell::new(LineWriter::new(stdout_raw())))\n+            },\n+            |mutex| unsafe { mutex.init() },\n+        ),\n     }\n }\n \n@@ -700,7 +705,7 @@ impl fmt::Debug for StdoutLock<'_> {\n /// an error.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Stderr {\n-    inner: &'static ReentrantMutex<RefCell<StderrRaw>>,\n+    inner: Pin<&'static ReentrantMutex<RefCell<StderrRaw>>>,\n }\n \n /// A locked reference to the `Stderr` handle.\n@@ -762,11 +767,10 @@ pub fn stderr() -> Stderr {\n     static INSTANCE: SyncOnceCell<ReentrantMutex<RefCell<StderrRaw>>> = SyncOnceCell::new();\n \n     Stderr {\n-        inner: INSTANCE.get_or_init(|| unsafe {\n-            let r = ReentrantMutex::new(RefCell::new(stderr_raw()));\n-            r.init();\n-            r\n-        }),\n+        inner: Pin::static_ref(&INSTANCE).get_or_init_pin(\n+            || unsafe { ReentrantMutex::new(RefCell::new(stderr_raw())) },\n+            |mutex| unsafe { mutex.init() },\n+        ),\n     }\n }\n "}, {"sha": "def8db1f45c37fb3a6b7c88e15ab028216342cf3", "filename": "library/std/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/67c18fdec59cf313818b8606c3847a8af6bcf684/library%2Fstd%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67c18fdec59cf313818b8606c3847a8af6bcf684/library%2Fstd%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Flib.rs?ref=67c18fdec59cf313818b8606c3847a8af6bcf684", "patch": "@@ -266,6 +266,7 @@\n #![feature(format_args_nl)]\n #![feature(gen_future)]\n #![feature(generator_trait)]\n+#![feature(get_mut_unchecked)]\n #![feature(global_asm)]\n #![feature(hashmap_internals)]\n #![feature(int_error_internals)]\n@@ -293,6 +294,7 @@\n #![feature(panic_info_message)]\n #![feature(panic_internals)]\n #![feature(panic_unwind)]\n+#![feature(pin_static_ref)]\n #![feature(prelude_import)]\n #![feature(ptr_internals)]\n #![feature(raw)]"}, {"sha": "475bfca9b6dcccc7ccb27ee31735e8306143d06c", "filename": "library/std/src/sys_common/remutex.rs", "status": "modified", "additions": 19, "deletions": 33, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/67c18fdec59cf313818b8606c3847a8af6bcf684/library%2Fstd%2Fsrc%2Fsys_common%2Fremutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67c18fdec59cf313818b8606c3847a8af6bcf684/library%2Fstd%2Fsrc%2Fsys_common%2Fremutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys_common%2Fremutex.rs?ref=67c18fdec59cf313818b8606c3847a8af6bcf684", "patch": "@@ -1,9 +1,10 @@\n #[cfg(all(test, not(target_os = \"emscripten\")))]\n mod tests;\n \n-use crate::fmt;\n+use crate::marker::PhantomPinned;\n use crate::ops::Deref;\n use crate::panic::{RefUnwindSafe, UnwindSafe};\n+use crate::pin::Pin;\n use crate::sys::mutex as sys;\n \n /// A re-entrant mutual exclusion\n@@ -14,6 +15,7 @@ use crate::sys::mutex as sys;\n pub struct ReentrantMutex<T> {\n     inner: sys::ReentrantMutex,\n     data: T,\n+    _pinned: PhantomPinned,\n }\n \n unsafe impl<T: Send> Send for ReentrantMutex<T> {}\n@@ -36,7 +38,7 @@ impl<T> RefUnwindSafe for ReentrantMutex<T> {}\n /// guarded data.\n #[must_use = \"if unused the ReentrantMutex will immediately unlock\"]\n pub struct ReentrantMutexGuard<'a, T: 'a> {\n-    lock: &'a ReentrantMutex<T>,\n+    lock: Pin<&'a ReentrantMutex<T>>,\n }\n \n impl<T> !Send for ReentrantMutexGuard<'_, T> {}\n@@ -50,7 +52,11 @@ impl<T> ReentrantMutex<T> {\n     /// once this mutex is in its final resting place, and only then are the\n     /// lock/unlock methods safe.\n     pub const unsafe fn new(t: T) -> ReentrantMutex<T> {\n-        ReentrantMutex { inner: sys::ReentrantMutex::uninitialized(), data: t }\n+        ReentrantMutex {\n+            inner: sys::ReentrantMutex::uninitialized(),\n+            data: t,\n+            _pinned: PhantomPinned,\n+        }\n     }\n \n     /// Initializes this mutex so it's ready for use.\n@@ -59,8 +65,8 @@ impl<T> ReentrantMutex<T> {\n     ///\n     /// Unsafe to call more than once, and must be called after this will no\n     /// longer move in memory.\n-    pub unsafe fn init(&self) {\n-        self.inner.init();\n+    pub unsafe fn init(self: Pin<&mut Self>) {\n+        self.get_unchecked_mut().inner.init()\n     }\n \n     /// Acquires a mutex, blocking the current thread until it is able to do so.\n@@ -75,9 +81,9 @@ impl<T> ReentrantMutex<T> {\n     /// If another user of this mutex panicked while holding the mutex, then\n     /// this call will return failure if the mutex would otherwise be\n     /// acquired.\n-    pub fn lock(&self) -> ReentrantMutexGuard<'_, T> {\n+    pub fn lock(self: Pin<&Self>) -> ReentrantMutexGuard<'_, T> {\n         unsafe { self.inner.lock() }\n-        ReentrantMutexGuard::new(&self)\n+        ReentrantMutexGuard { lock: self }\n     }\n \n     /// Attempts to acquire this lock.\n@@ -92,8 +98,12 @@ impl<T> ReentrantMutex<T> {\n     /// If another user of this mutex panicked while holding the mutex, then\n     /// this call will return failure if the mutex would otherwise be\n     /// acquired.\n-    pub fn try_lock(&self) -> Option<ReentrantMutexGuard<'_, T>> {\n-        if unsafe { self.inner.try_lock() } { Some(ReentrantMutexGuard::new(&self)) } else { None }\n+    pub fn try_lock(self: Pin<&Self>) -> Option<ReentrantMutexGuard<'_, T>> {\n+        if unsafe { self.inner.try_lock() } {\n+            Some(ReentrantMutexGuard { lock: self })\n+        } else {\n+            None\n+        }\n     }\n }\n \n@@ -106,30 +116,6 @@ impl<T> Drop for ReentrantMutex<T> {\n     }\n }\n \n-impl<T: fmt::Debug + 'static> fmt::Debug for ReentrantMutex<T> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        match self.try_lock() {\n-            Some(guard) => f.debug_struct(\"ReentrantMutex\").field(\"data\", &*guard).finish(),\n-            None => {\n-                struct LockedPlaceholder;\n-                impl fmt::Debug for LockedPlaceholder {\n-                    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-                        f.write_str(\"<locked>\")\n-                    }\n-                }\n-\n-                f.debug_struct(\"ReentrantMutex\").field(\"data\", &LockedPlaceholder).finish()\n-            }\n-        }\n-    }\n-}\n-\n-impl<'mutex, T> ReentrantMutexGuard<'mutex, T> {\n-    fn new(lock: &'mutex ReentrantMutex<T>) -> ReentrantMutexGuard<'mutex, T> {\n-        ReentrantMutexGuard { lock }\n-    }\n-}\n-\n impl<T> Deref for ReentrantMutexGuard<'_, T> {\n     type Target = T;\n "}, {"sha": "88453ded2f9fb2d310e1ace420194fa4eaf37538", "filename": "library/std/src/sys_common/remutex/tests.rs", "status": "modified", "additions": 20, "deletions": 15, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/67c18fdec59cf313818b8606c3847a8af6bcf684/library%2Fstd%2Fsrc%2Fsys_common%2Fremutex%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67c18fdec59cf313818b8606c3847a8af6bcf684/library%2Fstd%2Fsrc%2Fsys_common%2Fremutex%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys_common%2Fremutex%2Ftests.rs?ref=67c18fdec59cf313818b8606c3847a8af6bcf684", "patch": "@@ -1,15 +1,18 @@\n+use crate::boxed::Box;\n use crate::cell::RefCell;\n+use crate::pin::Pin;\n use crate::sync::Arc;\n use crate::sys_common::remutex::{ReentrantMutex, ReentrantMutexGuard};\n use crate::thread;\n \n #[test]\n fn smoke() {\n     let m = unsafe {\n-        let m = ReentrantMutex::new(());\n-        m.init();\n+        let mut m = Box::pin(ReentrantMutex::new(()));\n+        m.as_mut().init();\n         m\n     };\n+    let m = m.as_ref();\n     {\n         let a = m.lock();\n         {\n@@ -27,18 +30,19 @@ fn smoke() {\n #[test]\n fn is_mutex() {\n     let m = unsafe {\n-        let m = Arc::new(ReentrantMutex::new(RefCell::new(0)));\n-        m.init();\n-        m\n+        // FIXME: Simplify this if Arc gets a Arc::get_pin_mut.\n+        let mut m = Arc::new(ReentrantMutex::new(RefCell::new(0)));\n+        Pin::new_unchecked(Arc::get_mut_unchecked(&mut m)).init();\n+        Pin::new_unchecked(m)\n     };\n     let m2 = m.clone();\n-    let lock = m.lock();\n+    let lock = m.as_ref().lock();\n     let child = thread::spawn(move || {\n-        let lock = m2.lock();\n+        let lock = m2.as_ref().lock();\n         assert_eq!(*lock.borrow(), 4950);\n     });\n     for i in 0..100 {\n-        let lock = m.lock();\n+        let lock = m.as_ref().lock();\n         *lock.borrow_mut() += i;\n     }\n     drop(lock);\n@@ -48,20 +52,21 @@ fn is_mutex() {\n #[test]\n fn trylock_works() {\n     let m = unsafe {\n-        let m = Arc::new(ReentrantMutex::new(()));\n-        m.init();\n-        m\n+        // FIXME: Simplify this if Arc gets a Arc::get_pin_mut.\n+        let mut m = Arc::new(ReentrantMutex::new(()));\n+        Pin::new_unchecked(Arc::get_mut_unchecked(&mut m)).init();\n+        Pin::new_unchecked(m)\n     };\n     let m2 = m.clone();\n-    let _lock = m.try_lock();\n-    let _lock2 = m.try_lock();\n+    let _lock = m.as_ref().try_lock();\n+    let _lock2 = m.as_ref().try_lock();\n     thread::spawn(move || {\n-        let lock = m2.try_lock();\n+        let lock = m2.as_ref().try_lock();\n         assert!(lock.is_none());\n     })\n     .join()\n     .unwrap();\n-    let _lock3 = m.try_lock();\n+    let _lock3 = m.as_ref().try_lock();\n }\n \n pub struct Answer<'a>(pub ReentrantMutexGuard<'a, RefCell<u32>>);"}]}