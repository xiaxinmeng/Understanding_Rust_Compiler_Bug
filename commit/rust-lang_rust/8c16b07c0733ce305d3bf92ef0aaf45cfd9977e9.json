{"sha": "8c16b07c0733ce305d3bf92ef0aaf45cfd9977e9", "node_id": "C_kwDOAAsO6NoAKDhjMTZiMDdjMDczM2NlMzA1ZDNiZjkyZWYwYWFmNDVjZmQ5OTc3ZTk", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2022-03-18T19:01:25Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-03-18T19:01:25Z"}, "message": "Merge #11760\n\n11760: feat: Provide signature help when editing generic args r=jonas-schievink a=jonas-schievink\n\n![screenshot-2022-03-18-19:48:14](https://user-images.githubusercontent.com/1786438/159067106-3917a355-ca77-4d23-ad56-945dcc945425.png)\r\n\r\nbors r+\n\nCo-authored-by: Jonas Schievink <jonas.schievink@ferrous-systems.com>", "tree": {"sha": "a6eaf23aad7f0e70e81108f1972e02f84fbed5bf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a6eaf23aad7f0e70e81108f1972e02f84fbed5bf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8c16b07c0733ce305d3bf92ef0aaf45cfd9977e9", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJiNNcFCRBK7hj4Ov3rIwAA1y4IAF+vPOy3+P8WEYQm1vDxFzs9\nXRj5MZ6WoSPX3QYEBl78vN9kkldAA6EvusjNQ8GNJcmxOROUfXgZDWzcoknuXwFu\nWo3fd9QUGAGqp+MPWqBpVuccmnGfNrgaXAtVrw4a1l5C8hciprUrM2q9d/AdPfLf\n4Dor1nXfzN6chcWeOrkiNCAGizk7LyEbujwDfpeyL+fjjzou5JacN6/Ed2YRAfRo\nxMon5U1EnQIWPz4pfGLln0fPlW0i8SWEGtZMDUcgkKqHwyIXM1Lw+/PWjlEP0XpM\nctYxhSZMUT68Kyhed7Uji4MpoQ6H2rrnRl/FK2USU987geQ5U+BkUpfC+F7M1u4=\n=fiPK\n-----END PGP SIGNATURE-----\n", "payload": "tree a6eaf23aad7f0e70e81108f1972e02f84fbed5bf\nparent e3217c50150e369aed845fc00103d78e1b1b7a74\nparent 0642724e94f032268d74d90b97752ad4717004b5\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1647630085 +0000\ncommitter GitHub <noreply@github.com> 1647630085 +0000\n\nMerge #11760\n\n11760: feat: Provide signature help when editing generic args r=jonas-schievink a=jonas-schievink\n\n![screenshot-2022-03-18-19:48:14](https://user-images.githubusercontent.com/1786438/159067106-3917a355-ca77-4d23-ad56-945dcc945425.png)\r\n\r\nbors r+\n\nCo-authored-by: Jonas Schievink <jonas.schievink@ferrous-systems.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8c16b07c0733ce305d3bf92ef0aaf45cfd9977e9", "html_url": "https://github.com/rust-lang/rust/commit/8c16b07c0733ce305d3bf92ef0aaf45cfd9977e9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8c16b07c0733ce305d3bf92ef0aaf45cfd9977e9/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e3217c50150e369aed845fc00103d78e1b1b7a74", "url": "https://api.github.com/repos/rust-lang/rust/commits/e3217c50150e369aed845fc00103d78e1b1b7a74", "html_url": "https://github.com/rust-lang/rust/commit/e3217c50150e369aed845fc00103d78e1b1b7a74"}, {"sha": "0642724e94f032268d74d90b97752ad4717004b5", "url": "https://api.github.com/repos/rust-lang/rust/commits/0642724e94f032268d74d90b97752ad4717004b5", "html_url": "https://github.com/rust-lang/rust/commit/0642724e94f032268d74d90b97752ad4717004b5"}], "stats": {"total": 313, "additions": 305, "deletions": 8}, "files": [{"sha": "3c12907b824a492a854350bc1dd744aaa1c8e66e", "filename": "crates/hir/src/lib.rs", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8c16b07c0733ce305d3bf92ef0aaf45cfd9977e9/crates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c16b07c0733ce305d3bf92ef0aaf45cfd9977e9/crates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Flib.rs?ref=8c16b07c0733ce305d3bf92ef0aaf45cfd9977e9", "patch": "@@ -2075,7 +2075,7 @@ impl GenericDef {\n                 id: LifetimeParamId { parent: self.into(), local_id },\n             })\n             .map(GenericParam::LifetimeParam);\n-        ty_params.chain(lt_params).collect()\n+        lt_params.chain(ty_params).collect()\n     }\n \n     pub fn type_params(self, db: &dyn HirDatabase) -> Vec<TypeOrConstParam> {\n@@ -2336,6 +2336,18 @@ impl TypeParam {\n         self.id.parent().module(db.upcast()).into()\n     }\n \n+    /// Is this type parameter implicitly introduced (eg. `Self` in a trait or an `impl Trait`\n+    /// argument)?\n+    pub fn is_implicit(self, db: &dyn HirDatabase) -> bool {\n+        let params = db.generic_params(self.id.parent());\n+        let data = &params.type_or_consts[self.id.local_id()];\n+        match data.type_param().unwrap().provenance {\n+            hir_def::generics::TypeParamProvenance::TypeParamList => false,\n+            hir_def::generics::TypeParamProvenance::TraitSelf\n+            | hir_def::generics::TypeParamProvenance::ArgumentImplTrait => true,\n+        }\n+    }\n+\n     pub fn ty(self, db: &dyn HirDatabase) -> Type {\n         let resolver = self.id.parent().resolver(db.upcast());\n         let krate = self.id.parent().module(db.upcast()).krate();"}, {"sha": "ad831f0f949270c025b0124fc5447975d3d506c3", "filename": "crates/ide/src/call_info.rs", "status": "modified", "additions": 241, "deletions": 6, "changes": 247, "blob_url": "https://github.com/rust-lang/rust/blob/8c16b07c0733ce305d3bf92ef0aaf45cfd9977e9/crates%2Fide%2Fsrc%2Fcall_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c16b07c0733ce305d3bf92ef0aaf45cfd9977e9/crates%2Fide%2Fsrc%2Fcall_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fcall_info.rs?ref=8c16b07c0733ce305d3bf92ef0aaf45cfd9977e9", "patch": "@@ -2,7 +2,10 @@\n \n use either::Either;\n use hir::{HasAttrs, HirDisplay, Semantics};\n-use ide_db::{active_parameter::callable_for_token, base_db::FilePosition};\n+use ide_db::{\n+    active_parameter::{callable_for_token, generics_for_token},\n+    base_db::FilePosition,\n+};\n use stdx::format_to;\n use syntax::{algo, AstNode, Direction, TextRange, TextSize};\n \n@@ -27,8 +30,16 @@ impl CallInfo {\n         &self.parameters\n     }\n \n-    fn push_param(&mut self, param: &str) {\n-        if !self.signature.ends_with('(') {\n+    fn push_call_param(&mut self, param: &str) {\n+        self.push_param('(', param);\n+    }\n+\n+    fn push_generic_param(&mut self, param: &str) {\n+        self.push_param('<', param);\n+    }\n+\n+    fn push_param(&mut self, opening_delim: char, param: &str) {\n+        if !self.signature.ends_with(opening_delim) {\n             self.signature.push_str(\", \");\n         }\n         let start = TextSize::of(&self.signature);\n@@ -51,8 +62,22 @@ pub(crate) fn call_info(db: &RootDatabase, position: FilePosition) -> Option<Cal\n         .and_then(|tok| algo::skip_trivia_token(tok, Direction::Prev))?;\n     let token = sema.descend_into_macros_single(token);\n \n-    let (callable, active_parameter) = callable_for_token(&sema, token)?;\n+    if let Some((callable, active_parameter)) = callable_for_token(&sema, token.clone()) {\n+        return Some(call_info_for_callable(db, callable, active_parameter));\n+    }\n+\n+    if let Some((generic_def, active_parameter)) = generics_for_token(&sema, token.clone()) {\n+        return call_info_for_generics(db, generic_def, active_parameter);\n+    }\n+\n+    None\n+}\n \n+fn call_info_for_callable(\n+    db: &RootDatabase,\n+    callable: hir::Callable,\n+    active_parameter: Option<usize>,\n+) -> CallInfo {\n     let mut res =\n         CallInfo { doc: None, signature: String::new(), parameters: vec![], active_parameter };\n \n@@ -92,7 +117,7 @@ pub(crate) fn call_info(db: &RootDatabase, position: FilePosition) -> Option<Cal\n                 }\n             }\n             format_to!(buf, \"{}\", ty.display(db));\n-            res.push_param(&buf);\n+            res.push_call_param(&buf);\n         }\n     }\n     res.signature.push(')');\n@@ -106,6 +131,75 @@ pub(crate) fn call_info(db: &RootDatabase, position: FilePosition) -> Option<Cal\n         }\n         hir::CallableKind::TupleStruct(_) | hir::CallableKind::TupleEnumVariant(_) => {}\n     }\n+    res\n+}\n+\n+fn call_info_for_generics(\n+    db: &RootDatabase,\n+    mut generics_def: hir::GenericDef,\n+    active_parameter: usize,\n+) -> Option<CallInfo> {\n+    let mut res = CallInfo {\n+        doc: None,\n+        signature: String::new(),\n+        parameters: vec![],\n+        active_parameter: Some(active_parameter),\n+    };\n+\n+    match generics_def {\n+        hir::GenericDef::Function(it) => {\n+            res.doc = it.docs(db).map(|it| it.into());\n+            format_to!(res.signature, \"fn {}\", it.name(db));\n+        }\n+        hir::GenericDef::Adt(hir::Adt::Enum(it)) => {\n+            res.doc = it.docs(db).map(|it| it.into());\n+            format_to!(res.signature, \"enum {}\", it.name(db));\n+        }\n+        hir::GenericDef::Adt(hir::Adt::Struct(it)) => {\n+            res.doc = it.docs(db).map(|it| it.into());\n+            format_to!(res.signature, \"struct {}\", it.name(db));\n+        }\n+        hir::GenericDef::Adt(hir::Adt::Union(it)) => {\n+            res.doc = it.docs(db).map(|it| it.into());\n+            format_to!(res.signature, \"union {}\", it.name(db));\n+        }\n+        hir::GenericDef::Trait(it) => {\n+            res.doc = it.docs(db).map(|it| it.into());\n+            format_to!(res.signature, \"trait {}\", it.name(db));\n+        }\n+        hir::GenericDef::TypeAlias(it) => {\n+            res.doc = it.docs(db).map(|it| it.into());\n+            format_to!(res.signature, \"type {}\", it.name(db));\n+        }\n+        hir::GenericDef::Variant(it) => {\n+            // In paths, generics of an enum can be specified *after* one of its variants.\n+            // eg. `None::<u8>`\n+            // We'll use the signature of the enum, but include the docs of the variant.\n+            res.doc = it.docs(db).map(|it| it.into());\n+            let it = it.parent_enum(db);\n+            format_to!(res.signature, \"enum {}\", it.name(db));\n+            generics_def = it.into();\n+        }\n+        // These don't have generic args that can be specified\n+        hir::GenericDef::Impl(_) | hir::GenericDef::Const(_) => return None,\n+    }\n+\n+    res.signature.push('<');\n+    let params = generics_def.params(db);\n+    let mut buf = String::new();\n+    for param in params {\n+        if let hir::GenericParam::TypeParam(ty) = param {\n+            if ty.is_implicit(db) {\n+                continue;\n+            }\n+        }\n+\n+        buf.clear();\n+        format_to!(buf, \"{}\", param.display(db));\n+        res.push_generic_param(&buf);\n+    }\n+    res.signature.push('>');\n+\n     Some(res)\n }\n \n@@ -128,7 +222,14 @@ mod tests {\n     }\n \n     fn check(ra_fixture: &str, expect: Expect) {\n-        let (db, position) = position(ra_fixture);\n+        // Implicitly add `Sized` to avoid noisy `T: ?Sized` in the results.\n+        let fixture = format!(\n+            r#\"\n+#[lang = \"sized\"] trait Sized {{}}\n+{ra_fixture}\n+            \"#\n+        );\n+        let (db, position) = position(&fixture);\n         let call_info = crate::call_info::call_info(&db, position);\n         let actual = match call_info {\n             Some(call_info) => {\n@@ -676,4 +777,138 @@ fn main() {\n         \"#]],\n         )\n     }\n+\n+    #[test]\n+    fn test_generics_simple() {\n+        check(\n+            r#\"\n+/// Option docs.\n+enum Option<T> {\n+    Some(T),\n+    None,\n+}\n+\n+fn f() {\n+    let opt: Option<$0\n+}\n+        \"#,\n+            expect![[r#\"\n+                Option docs.\n+                ------\n+                enum Option<T>\n+                (<T>)\n+            \"#]],\n+        );\n+    }\n+\n+    #[test]\n+    fn test_generics_on_variant() {\n+        check(\n+            r#\"\n+/// Option docs.\n+enum Option<T> {\n+    /// Some docs.\n+    Some(T),\n+    /// None docs.\n+    None,\n+}\n+\n+use Option::*;\n+\n+fn f() {\n+    None::<$0\n+}\n+        \"#,\n+            expect![[r#\"\n+                None docs.\n+                ------\n+                enum Option<T>\n+                (<T>)\n+            \"#]],\n+        );\n+    }\n+\n+    #[test]\n+    fn test_lots_of_generics() {\n+        check(\n+            r#\"\n+trait Tr<T> {}\n+\n+struct S<T>(T);\n+\n+impl<T> S<T> {\n+    fn f<G, H>(g: G, h: impl Tr<G>) where G: Tr<()> {}\n+}\n+\n+fn f() {\n+    S::<u8>::f::<(), $0\n+}\n+        \"#,\n+            expect![[r#\"\n+                fn f<G: Tr<()>, H>\n+                (G: Tr<()>, <H>)\n+            \"#]],\n+        );\n+    }\n+\n+    #[test]\n+    fn test_generics_in_trait_ufcs() {\n+        check(\n+            r#\"\n+trait Tr {\n+    fn f<T: Tr, U>() {}\n+}\n+\n+struct S;\n+\n+impl Tr for S {}\n+\n+fn f() {\n+    <S as Tr>::f::<$0\n+}\n+        \"#,\n+            expect![[r#\"\n+                fn f<T: Tr, U>\n+                (<T: Tr>, U)\n+            \"#]],\n+        );\n+    }\n+\n+    #[test]\n+    fn test_generics_in_method_call() {\n+        check(\n+            r#\"\n+struct S;\n+\n+impl S {\n+    fn f<T>(&self) {}\n+}\n+\n+fn f() {\n+    S.f::<$0\n+}\n+        \"#,\n+            expect![[r#\"\n+            fn f<T>\n+            (<T>)\n+        \"#]],\n+        );\n+    }\n+\n+    #[test]\n+    fn test_generic_kinds() {\n+        check(\n+            r#\"\n+fn callee<'a, const A: (), T, const C: u8>() {}\n+\n+fn f() {\n+    callee::<'static, $0\n+}\n+        \"#,\n+            expect![[r#\"\n+            fn callee<'a, const A: (), T, const C: u8>\n+            ('a, <const A: ()>, T, const C: u8)\n+        \"#]],\n+        );\n+    }\n }"}, {"sha": "67b819c5a5de96f6a6e607520d9a9284fa09531d", "filename": "crates/ide_db/src/active_parameter.rs", "status": "modified", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/8c16b07c0733ce305d3bf92ef0aaf45cfd9977e9/crates%2Fide_db%2Fsrc%2Factive_parameter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c16b07c0733ce305d3bf92ef0aaf45cfd9977e9/crates%2Fide_db%2Fsrc%2Factive_parameter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Factive_parameter.rs?ref=8c16b07c0733ce305d3bf92ef0aaf45cfd9977e9", "patch": "@@ -68,3 +68,53 @@ pub fn callable_for_token(\n     };\n     Some((callable, active_param))\n }\n+\n+pub fn generics_for_token(\n+    sema: &Semantics<RootDatabase>,\n+    token: SyntaxToken,\n+) -> Option<(hir::GenericDef, usize)> {\n+    let parent = token.parent()?;\n+    let arg_list = parent\n+        .ancestors()\n+        .filter_map(ast::GenericArgList::cast)\n+        .find(|list| list.syntax().text_range().contains(token.text_range().start()))?;\n+\n+    let active_param = arg_list\n+        .generic_args()\n+        .take_while(|arg| arg.syntax().text_range().end() <= token.text_range().start())\n+        .count();\n+\n+    if let Some(path) = arg_list.syntax().ancestors().find_map(ast::Path::cast) {\n+        let res = sema.resolve_path(&path)?;\n+        let generic_def: hir::GenericDef = match res {\n+            hir::PathResolution::Def(hir::ModuleDef::Adt(it)) => it.into(),\n+            hir::PathResolution::Def(hir::ModuleDef::Function(it)) => it.into(),\n+            hir::PathResolution::Def(hir::ModuleDef::Trait(it)) => it.into(),\n+            hir::PathResolution::Def(hir::ModuleDef::TypeAlias(it)) => it.into(),\n+            hir::PathResolution::Def(hir::ModuleDef::Variant(it)) => it.into(),\n+            hir::PathResolution::Def(hir::ModuleDef::BuiltinType(_))\n+            | hir::PathResolution::Def(hir::ModuleDef::Const(_))\n+            | hir::PathResolution::Def(hir::ModuleDef::Macro(_))\n+            | hir::PathResolution::Def(hir::ModuleDef::Module(_))\n+            | hir::PathResolution::Def(hir::ModuleDef::Static(_)) => return None,\n+            hir::PathResolution::AssocItem(hir::AssocItem::Function(it)) => it.into(),\n+            hir::PathResolution::AssocItem(hir::AssocItem::TypeAlias(it)) => it.into(),\n+            hir::PathResolution::AssocItem(hir::AssocItem::Const(_)) => return None,\n+            hir::PathResolution::BuiltinAttr(_)\n+            | hir::PathResolution::ToolModule(_)\n+            | hir::PathResolution::Local(_)\n+            | hir::PathResolution::TypeParam(_)\n+            | hir::PathResolution::ConstParam(_)\n+            | hir::PathResolution::SelfType(_) => return None,\n+        };\n+\n+        Some((generic_def, active_param))\n+    } else if let Some(method_call) = arg_list.syntax().parent().and_then(ast::MethodCallExpr::cast)\n+    {\n+        // recv.method::<$0>()\n+        let method = sema.resolve_method_call(&method_call)?;\n+        Some((method.into(), active_param))\n+    } else {\n+        None\n+    }\n+}"}, {"sha": "d83af2a48a9b2da377fb57919ed431778174c4d7", "filename": "crates/rust-analyzer/src/caps.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c16b07c0733ce305d3bf92ef0aaf45cfd9977e9/crates%2Frust-analyzer%2Fsrc%2Fcaps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c16b07c0733ce305d3bf92ef0aaf45cfd9977e9/crates%2Frust-analyzer%2Fsrc%2Fcaps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fcaps.rs?ref=8c16b07c0733ce305d3bf92ef0aaf45cfd9977e9", "patch": "@@ -34,7 +34,7 @@ pub fn server_capabilities(config: &Config) -> ServerCapabilities {\n             work_done_progress_options: WorkDoneProgressOptions { work_done_progress: None },\n         }),\n         signature_help_provider: Some(SignatureHelpOptions {\n-            trigger_characters: Some(vec![\"(\".to_string(), \",\".to_string()]),\n+            trigger_characters: Some(vec![\"(\".to_string(), \",\".to_string(), \"<\".to_string()]),\n             retrigger_characters: None,\n             work_done_progress_options: WorkDoneProgressOptions { work_done_progress: None },\n         }),"}]}