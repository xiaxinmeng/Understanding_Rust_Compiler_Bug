{"sha": "081c607b0afb496fa61ab1b66a6615f9ea6ac663", "node_id": "C_kwDOAAsO6NoAKDA4MWM2MDdiMGFmYjQ5NmZhNjFhYjFiNjZhNjYxNWY5ZWE2YWM2NjM", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2023-03-21T18:00:12Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2023-03-21T18:00:12Z"}, "message": "Rollup merge of #109336 - compiler-errors:constrain-to-ct-err, r=BoxyUwU\n\nConstrain const vars to error if const types are mismatched\n\nWhen equating two consts of different types, if either are const variables, constrain them to the correct const error kind.\n\nThis helps us avoid \"successfully\" matching a const against an impl signature but leaving unconstrained const vars, which will lead to incremental ICEs when we call const-eval queries during const projection.\n\nFixes #109296\n\nThe second commit in the stack fixes a regression in the first commit where we end up mentioning `[const error]` in an impl overlap error message. I think the error message changes for the better, but I could implement alternative strategies to avoid this without delaying the overlap error message...\n\nr? `@BoxyUwU`", "tree": {"sha": "aff3933c8302508028f0478c97edf0960f25c6f9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/aff3933c8302508028f0478c97edf0960f25c6f9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/081c607b0afb496fa61ab1b66a6615f9ea6ac663", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJkGfCsCRBK7hj4Ov3rIwAAtyEIAGerTekIfHDcjhuL8v+JlYkb\n1OW+TTBnnvuLXLk0Nzmoii8Zb+PDc+Q9mW+IDS4eDjIcGIse7eGzriOt9mBDomTb\naGXM+hVPekOoV/k6iuOpaPjZehulhR82p6oTdUu4h6fh/BrgZ5BTEcoceXjpBq/x\nNlvOx8ukjjj/AyMZrirHwA6lHMwLYS8rsLsN6NYWOKecuhN47kQZHSNIqLzmBhHV\nzN055WRnnzKo89NnsUVw5kdSq5tt3uLpVENlIqM3R0Up+I61G+s+KqVxbBydtnTi\ndoTGR91Xwk3/T0/iAss7WWRB/NdpIG2r46Tqsfft/sw8hTo3BLV8PBWAQAIIACM=\n=UgYp\n-----END PGP SIGNATURE-----\n", "payload": "tree aff3933c8302508028f0478c97edf0960f25c6f9\nparent ee330a3ff524852f2cd9c22fc3453a631658a94d\nparent 9174edbae9d3f95b9e1d89ebf4921b761e333204\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1679421612 +0100\ncommitter GitHub <noreply@github.com> 1679421612 +0100\n\nRollup merge of #109336 - compiler-errors:constrain-to-ct-err, r=BoxyUwU\n\nConstrain const vars to error if const types are mismatched\n\nWhen equating two consts of different types, if either are const variables, constrain them to the correct const error kind.\n\nThis helps us avoid \"successfully\" matching a const against an impl signature but leaving unconstrained const vars, which will lead to incremental ICEs when we call const-eval queries during const projection.\n\nFixes #109296\n\nThe second commit in the stack fixes a regression in the first commit where we end up mentioning `[const error]` in an impl overlap error message. I think the error message changes for the better, but I could implement alternative strategies to avoid this without delaying the overlap error message...\n\nr? `@BoxyUwU`\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/081c607b0afb496fa61ab1b66a6615f9ea6ac663", "html_url": "https://github.com/rust-lang/rust/commit/081c607b0afb496fa61ab1b66a6615f9ea6ac663", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/081c607b0afb496fa61ab1b66a6615f9ea6ac663/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ee330a3ff524852f2cd9c22fc3453a631658a94d", "url": "https://api.github.com/repos/rust-lang/rust/commits/ee330a3ff524852f2cd9c22fc3453a631658a94d", "html_url": "https://github.com/rust-lang/rust/commit/ee330a3ff524852f2cd9c22fc3453a631658a94d"}, {"sha": "9174edbae9d3f95b9e1d89ebf4921b761e333204", "url": "https://api.github.com/repos/rust-lang/rust/commits/9174edbae9d3f95b9e1d89ebf4921b761e333204", "html_url": "https://github.com/rust-lang/rust/commit/9174edbae9d3f95b9e1d89ebf4921b761e333204"}], "stats": {"total": 64, "additions": 51, "deletions": 13}, "files": [{"sha": "4503af03ca341200fadd47c843d6e9c543bcce97", "filename": "compiler/rustc_infer/src/infer/combine.rs", "status": "modified", "additions": 13, "deletions": 4, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/081c607b0afb496fa61ab1b66a6615f9ea6ac663/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/081c607b0afb496fa61ab1b66a6615f9ea6ac663/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs?ref=081c607b0afb496fa61ab1b66a6615f9ea6ac663", "patch": "@@ -189,10 +189,19 @@ impl<'tcx> InferCtxt<'tcx> {\n         // the expected const's type. Specifically, we don't want const infer vars\n         // to do any type shapeshifting before and after resolution.\n         if let Err(guar) = compatible_types {\n-            return Ok(self.tcx.const_error_with_guaranteed(\n-                if relation.a_is_expected() { a.ty() } else { b.ty() },\n-                guar,\n-            ));\n+            // HACK: equating both sides with `[const error]` eagerly prevents us\n+            // from leaving unconstrained inference vars during things like impl\n+            // matching in the solver.\n+            let a_error = self.tcx.const_error_with_guaranteed(a.ty(), guar);\n+            if let ty::ConstKind::Infer(InferConst::Var(vid)) = a.kind() {\n+                return self.unify_const_variable(vid, a_error);\n+            }\n+            let b_error = self.tcx.const_error_with_guaranteed(b.ty(), guar);\n+            if let ty::ConstKind::Infer(InferConst::Var(vid)) = b.kind() {\n+                return self.unify_const_variable(vid, b_error);\n+            }\n+\n+            return Ok(if relation.a_is_expected() { a_error } else { b_error });\n         }\n \n         match (a.kind(), b.kind()) {"}, {"sha": "8546bbe52dcc39d369520f97958284dfc79f7225", "filename": "compiler/rustc_trait_selection/src/traits/specialize/mod.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/081c607b0afb496fa61ab1b66a6615f9ea6ac663/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/081c607b0afb496fa61ab1b66a6615f9ea6ac663/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fmod.rs?ref=081c607b0afb496fa61ab1b66a6615f9ea6ac663", "patch": "@@ -22,7 +22,7 @@ use crate::traits::{\n use rustc_data_structures::fx::FxIndexSet;\n use rustc_errors::{error_code, DelayDm, Diagnostic};\n use rustc_hir::def_id::{DefId, LocalDefId};\n-use rustc_middle::ty::{self, ImplSubject, Ty, TyCtxt};\n+use rustc_middle::ty::{self, ImplSubject, Ty, TyCtxt, TypeVisitableExt};\n use rustc_middle::ty::{InternalSubsts, SubstsRef};\n use rustc_session::lint::builtin::COHERENCE_LEAK_CHECK;\n use rustc_session::lint::builtin::ORDER_DEPENDENT_TRAIT_OBJECTS;\n@@ -350,6 +350,10 @@ fn report_conflicting_impls<'tcx>(\n         impl_span: Span,\n         err: &mut Diagnostic,\n     ) {\n+        if (overlap.trait_ref, overlap.self_ty).references_error() {\n+            err.downgrade_to_delayed_bug();\n+        }\n+\n         match tcx.span_of_impl(overlap.with_impl) {\n             Ok(span) => {\n                 err.span_label(span, \"first implementation here\");"}, {"sha": "e13dfbacd242225c5eb374973abe9b1c3db57ca2", "filename": "tests/ui/const-generics/bad-subst-const-kind.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/081c607b0afb496fa61ab1b66a6615f9ea6ac663/tests%2Fui%2Fconst-generics%2Fbad-subst-const-kind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/081c607b0afb496fa61ab1b66a6615f9ea6ac663/tests%2Fui%2Fconst-generics%2Fbad-subst-const-kind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconst-generics%2Fbad-subst-const-kind.rs?ref=081c607b0afb496fa61ab1b66a6615f9ea6ac663", "patch": "@@ -0,0 +1,13 @@\n+// incremental\n+#![crate_type = \"lib\"]\n+\n+trait Q {\n+    const ASSOC: usize;\n+}\n+\n+impl<const N: u64> Q for [u8; N] {\n+    //~^ ERROR mismatched types\n+    const ASSOC: usize = 1;\n+}\n+\n+pub fn test() -> [u8; <[u8; 13] as Q>::ASSOC] { todo!() }"}, {"sha": "bd24f9140e4ea72912355109b1f662bb57dfb0cc", "filename": "tests/ui/const-generics/bad-subst-const-kind.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/081c607b0afb496fa61ab1b66a6615f9ea6ac663/tests%2Fui%2Fconst-generics%2Fbad-subst-const-kind.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/081c607b0afb496fa61ab1b66a6615f9ea6ac663/tests%2Fui%2Fconst-generics%2Fbad-subst-const-kind.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconst-generics%2Fbad-subst-const-kind.stderr?ref=081c607b0afb496fa61ab1b66a6615f9ea6ac663", "patch": "@@ -0,0 +1,9 @@\n+error[E0308]: mismatched types\n+  --> $DIR/bad-subst-const-kind.rs:8:31\n+   |\n+LL | impl<const N: u64> Q for [u8; N] {\n+   |                               ^ expected `usize`, found `u64`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "5fd7c647c253111888d7059dfe31f9c626f26fe0", "filename": "tests/ui/specialization/min_specialization/bad-const-wf-doesnt-specialize.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/081c607b0afb496fa61ab1b66a6615f9ea6ac663/tests%2Fui%2Fspecialization%2Fmin_specialization%2Fbad-const-wf-doesnt-specialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/081c607b0afb496fa61ab1b66a6615f9ea6ac663/tests%2Fui%2Fspecialization%2Fmin_specialization%2Fbad-const-wf-doesnt-specialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fspecialization%2Fmin_specialization%2Fbad-const-wf-doesnt-specialize.rs?ref=081c607b0afb496fa61ab1b66a6615f9ea6ac663", "patch": "@@ -2,11 +2,11 @@\n \n // An impl that has an erroneous const substitution should not specialize one\n // that is well-formed.\n-\n+#[derive(Clone)]\n struct S<const L: usize>;\n \n impl<const N: i32> Copy for S<N> {}\n+//~^ ERROR the constant `N` is not of type `usize`\n impl<const M: usize> Copy for S<M> {}\n-//~^ ERROR conflicting implementations of trait `Copy` for type `S<_>`\n \n fn main() {}"}, {"sha": "6d7028c5e7088e18cbf060cfae64233e3be8c857", "filename": "tests/ui/specialization/min_specialization/bad-const-wf-doesnt-specialize.stderr", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/081c607b0afb496fa61ab1b66a6615f9ea6ac663/tests%2Fui%2Fspecialization%2Fmin_specialization%2Fbad-const-wf-doesnt-specialize.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/081c607b0afb496fa61ab1b66a6615f9ea6ac663/tests%2Fui%2Fspecialization%2Fmin_specialization%2Fbad-const-wf-doesnt-specialize.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fspecialization%2Fmin_specialization%2Fbad-const-wf-doesnt-specialize.stderr?ref=081c607b0afb496fa61ab1b66a6615f9ea6ac663", "patch": "@@ -1,11 +1,14 @@\n-error[E0119]: conflicting implementations of trait `Copy` for type `S<_>`\n-  --> $DIR/bad-const-wf-doesnt-specialize.rs:9:1\n+error: the constant `N` is not of type `usize`\n+  --> $DIR/bad-const-wf-doesnt-specialize.rs:8:29\n    |\n LL | impl<const N: i32> Copy for S<N> {}\n-   | -------------------------------- first implementation here\n-LL | impl<const M: usize> Copy for S<M> {}\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ conflicting implementation for `S<_>`\n+   |                             ^^^^\n+   |\n+note: required by a bound in `S`\n+  --> $DIR/bad-const-wf-doesnt-specialize.rs:6:10\n+   |\n+LL | struct S<const L: usize>;\n+   |          ^^^^^^^^^^^^^^ required by this bound in `S`\n \n error: aborting due to previous error\n \n-For more information about this error, try `rustc --explain E0119`."}]}