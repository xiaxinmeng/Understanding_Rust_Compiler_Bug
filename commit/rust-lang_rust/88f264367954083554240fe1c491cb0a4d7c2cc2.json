{"sha": "88f264367954083554240fe1c491cb0a4d7c2cc2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg4ZjI2NDM2Nzk1NDA4MzU1NDI0MGZlMWM0OTFjYjBhNGQ3YzJjYzI=", "commit": {"author": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2018-07-12T20:00:57Z"}, "committer": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2018-07-21T22:22:30Z"}, "message": "Add \"self\" intra-link support", "tree": {"sha": "f5eb7dfb388c579e5e2427df9674deeb2d91435e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f5eb7dfb388c579e5e2427df9674deeb2d91435e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/88f264367954083554240fe1c491cb0a4d7c2cc2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/88f264367954083554240fe1c491cb0a4d7c2cc2", "html_url": "https://github.com/rust-lang/rust/commit/88f264367954083554240fe1c491cb0a4d7c2cc2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/88f264367954083554240fe1c491cb0a4d7c2cc2/comments", "author": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "committer": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6cc42a4488d5dbc4c4109ed4a2f2ea81efa77f86", "url": "https://api.github.com/repos/rust-lang/rust/commits/6cc42a4488d5dbc4c4109ed4a2f2ea81efa77f86", "html_url": "https://github.com/rust-lang/rust/commit/6cc42a4488d5dbc4c4109ed4a2f2ea81efa77f86"}], "stats": {"total": 106, "additions": 102, "deletions": 4}, "files": [{"sha": "7cbddbec5f77eb1e8f56b223c16cf948365e45b5", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 59, "deletions": 2, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/88f264367954083554240fe1c491cb0a4d7c2cc2/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88f264367954083554240fe1c491cb0a4d7c2cc2/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=88f264367954083554240fe1c491cb0a4d7c2cc2", "patch": "@@ -20,7 +20,7 @@ pub use self::Visibility::{Public, Inherited};\n \n use rustc_target::spec::abi::Abi;\n use syntax;\n-use syntax::ast::{self, AttrStyle, NodeId, Ident};\n+use syntax::ast::{self, AttrStyle, Name, NodeId, Ident};\n use syntax::attr;\n use syntax::codemap::{dummy_spanned, Spanned};\n use syntax::feature_gate::UnstableFeatures;\n@@ -39,6 +39,7 @@ use rustc::hir::{self, GenericArg, HirVec};\n use rustc::hir::def::{self, Def, CtorKind};\n use rustc::hir::def_id::{CrateNum, DefId, DefIndex, CRATE_DEF_INDEX, LOCAL_CRATE};\n use rustc::hir::def_id::DefIndexAddressSpace;\n+use rustc::hir::map::Node;\n use rustc::ty::subst::Substs;\n use rustc::ty::{self, TyCtxt, Region, RegionVid, Ty, AdtKind};\n use rustc::middle::stability;\n@@ -576,10 +577,23 @@ impl Clean<Item> for doctree::Module {\n                                  .next()\n                                  .map_or(true, |a| a.style == AttrStyle::Inner) {\n             // inner doc comment, use the module's own scope for resolution\n+            if self.id != NodeId::new(0) {\n+                *cx.current_item_name.borrow_mut() = Some(cx.tcx.hir.name(self.id));\n+            } else {\n+                *cx.current_item_name.borrow_mut() = None;\n+            }\n             cx.mod_ids.borrow_mut().push(self.id);\n             self.attrs.clean(cx)\n         } else {\n             // outer doc comment, use its parent's scope\n+            match cx.mod_ids.borrow().last() {\n+                Some(parent) if *parent != NodeId::new(0) => {\n+                    *cx.current_item_name.borrow_mut() = Some(cx.tcx.hir.name(*parent));\n+                }\n+                _ => {\n+                    *cx.current_item_name.borrow_mut() = None;\n+                }\n+            }\n             let attrs = self.attrs.clean(cx);\n             cx.mod_ids.borrow_mut().push(self.id);\n             attrs\n@@ -1132,11 +1146,17 @@ fn resolve(cx: &DocContext, path_str: &str, is_val: bool) -> Result<(Def, Option\n         };\n \n         let mut path = if let Some(second) = split.next() {\n-            second\n+            second.to_owned()\n         } else {\n             return Err(())\n         };\n \n+        if path == \"self\" || path == \"Self\" {\n+            if let Some(name) = *cx.current_item_name.borrow() {\n+                path = name.to_string();\n+            }\n+        }\n+\n         let ty = cx.resolver.borrow_mut()\n                             .with_scope(*id,\n             |resolver| {\n@@ -2110,6 +2130,8 @@ impl Clean<Item> for doctree::Function {\n         let (generics, decl) = enter_impl_trait(cx, || {\n             (self.generics.clean(cx), (&self.decl, self.body).clean(cx))\n         });\n+\n+        *cx.current_item_name.borrow_mut() = Some(self.name);\n         Item {\n             name: Some(self.name.clean(cx)),\n             attrs: self.attrs.clean(cx),\n@@ -2288,6 +2310,7 @@ pub struct Trait {\n \n impl Clean<Item> for doctree::Trait {\n     fn clean(&self, cx: &DocContext) -> Item {\n+        *cx.current_item_name.borrow_mut() = Some(self.name);\n         let attrs = self.attrs.clean(cx);\n         let is_spotlight = attrs.has_doc_flag(\"spotlight\");\n         Item {\n@@ -2359,6 +2382,7 @@ impl Clean<Item> for hir::TraitItem {\n                 AssociatedTypeItem(bounds.clean(cx), default.clean(cx))\n             }\n         };\n+        *cx.current_item_name.borrow_mut() = Some(self.ident.name);\n         Item {\n             name: Some(self.ident.name.clean(cx)),\n             attrs: self.attrs.clean(cx),\n@@ -2387,6 +2411,7 @@ impl Clean<Item> for hir::ImplItem {\n                 generics: Generics::default(),\n             }, true),\n         };\n+        *cx.current_item_name.borrow_mut() = Some(self.ident.name);\n         Item {\n             name: Some(self.ident.name.clean(cx)),\n             source: self.span.clean(cx),\n@@ -3179,6 +3204,7 @@ impl<'tcx> Clean<Type> for Ty<'tcx> {\n \n impl Clean<Item> for hir::StructField {\n     fn clean(&self, cx: &DocContext) -> Item {\n+        *cx.current_item_name.borrow_mut() = Some(self.ident.name);\n         Item {\n             name: Some(self.ident.name).clean(cx),\n             attrs: self.attrs.clean(cx),\n@@ -3257,6 +3283,7 @@ impl Clean<Vec<Item>> for doctree::Struct {\n         let name = self.name.clean(cx);\n         let mut ret = get_auto_traits_with_node_id(cx, self.id, name.clone());\n \n+        *cx.current_item_name.borrow_mut() = Some(self.name);\n         ret.push(Item {\n             name: Some(name),\n             attrs: self.attrs.clean(cx),\n@@ -3282,6 +3309,7 @@ impl Clean<Vec<Item>> for doctree::Union {\n         let name = self.name.clean(cx);\n         let mut ret = get_auto_traits_with_node_id(cx, self.id, name.clone());\n \n+        *cx.current_item_name.borrow_mut() = Some(self.name);\n         ret.push(Item {\n             name: Some(name),\n             attrs: self.attrs.clean(cx),\n@@ -3334,6 +3362,7 @@ impl Clean<Vec<Item>> for doctree::Enum {\n         let name = self.name.clean(cx);\n         let mut ret = get_auto_traits_with_node_id(cx, self.id, name.clone());\n \n+        *cx.current_item_name.borrow_mut() = Some(self.name);\n         ret.push(Item {\n             name: Some(name),\n             attrs: self.attrs.clean(cx),\n@@ -3360,6 +3389,7 @@ pub struct Variant {\n \n impl Clean<Item> for doctree::Variant {\n     fn clean(&self, cx: &DocContext) -> Item {\n+        *cx.current_item_name.borrow_mut() = Some(self.name);\n         Item {\n             name: Some(self.name.clean(cx)),\n             attrs: self.attrs.clean(cx),\n@@ -3655,6 +3685,7 @@ pub struct Typedef {\n \n impl Clean<Item> for doctree::Typedef {\n     fn clean(&self, cx: &DocContext) -> Item {\n+        *cx.current_item_name.borrow_mut() = Some(self.name);\n         Item {\n             name: Some(self.name.clean(cx)),\n             attrs: self.attrs.clean(cx),\n@@ -3706,6 +3737,7 @@ pub struct Static {\n impl Clean<Item> for doctree::Static {\n     fn clean(&self, cx: &DocContext) -> Item {\n         debug!(\"cleaning static {}: {:?}\", self.name.clean(cx), self);\n+        *cx.current_item_name.borrow_mut() = Some(self.name);\n         Item {\n             name: Some(self.name.clean(cx)),\n             attrs: self.attrs.clean(cx),\n@@ -3731,6 +3763,7 @@ pub struct Constant {\n \n impl Clean<Item> for doctree::Constant {\n     fn clean(&self, cx: &DocContext) -> Item {\n+        *cx.current_item_name.borrow_mut() = Some(self.name);\n         Item {\n             name: Some(self.name.clean(cx)),\n             attrs: self.attrs.clean(cx),\n@@ -3800,6 +3833,23 @@ pub fn get_auto_traits_with_def_id(cx: &DocContext, id: DefId) -> Vec<Item> {\n     finder.get_with_def_id(id)\n }\n \n+fn get_name_if_possible(cx: &DocContext, node: NodeId) -> Option<Name> {\n+    match cx.tcx.hir.get(node) {\n+        Node::NodeItem(_) |\n+        Node::NodeForeignItem(_) |\n+        Node::NodeImplItem(_) |\n+        Node::NodeTraitItem(_) |\n+        Node::NodeVariant(_) |\n+        Node::NodeField(_) |\n+        Node::NodeLifetime(_) |\n+        Node::NodeGenericParam(_) |\n+        Node::NodeBinding(&hir::Pat { node: hir::PatKind::Binding(_,_,_,_), .. }) |\n+        Node::NodeStructCtor(_) => {}\n+        _ => return None,\n+    }\n+    Some(cx.tcx.hir.name(node))\n+}\n+\n impl Clean<Vec<Item>> for doctree::Impl {\n     fn clean(&self, cx: &DocContext) -> Vec<Item> {\n         let mut ret = Vec::new();\n@@ -3819,6 +3869,7 @@ impl Clean<Vec<Item>> for doctree::Impl {\n                   .collect()\n         }).unwrap_or(FxHashSet());\n \n+        *cx.current_item_name.borrow_mut() = get_name_if_possible(cx, self.for_.id);\n         ret.push(Item {\n             name: None,\n             attrs: self.attrs.clean(cx),\n@@ -3905,6 +3956,7 @@ fn build_deref_target_impls(cx: &DocContext,\n \n impl Clean<Item> for doctree::ExternCrate {\n     fn clean(&self, cx: &DocContext) -> Item {\n+        *cx.current_item_name.borrow_mut() = Some(self.name);\n         Item {\n             name: None,\n             attrs: self.attrs.clean(cx),\n@@ -3951,6 +4003,8 @@ impl Clean<Vec<Item>> for doctree::Import {\n             }\n             Import::Simple(name.clean(cx), resolve_use_source(cx, path))\n         };\n+\n+        *cx.current_item_name.borrow_mut() = Some(self.name);\n         vec![Item {\n             name: None,\n             attrs: self.attrs.clean(cx),\n@@ -4019,6 +4073,8 @@ impl Clean<Item> for hir::ForeignItem {\n                 ForeignTypeItem\n             }\n         };\n+\n+        *cx.current_item_name.borrow_mut() = Some(self.name);\n         Item {\n             name: Some(self.name.clean(cx)),\n             attrs: self.attrs.clean(cx),\n@@ -4194,6 +4250,7 @@ pub struct Macro {\n impl Clean<Item> for doctree::Macro {\n     fn clean(&self, cx: &DocContext) -> Item {\n         let name = self.name.clean(cx);\n+        *cx.current_item_name.borrow_mut() = None;\n         Item {\n             name: Some(name.clone()),\n             attrs: self.attrs.clean(cx),"}, {"sha": "375a9c981a10c054b02ff48a9ccde64b71bda759", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/88f264367954083554240fe1c491cb0a4d7c2cc2/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88f264367954083554240fe1c491cb0a4d7c2cc2/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=88f264367954083554240fe1c491cb0a4d7c2cc2", "patch": "@@ -25,7 +25,7 @@ use rustc_metadata::creader::CrateLoader;\n use rustc_metadata::cstore::CStore;\n use rustc_target::spec::TargetTriple;\n \n-use syntax::ast::NodeId;\n+use syntax::ast::{Name, NodeId};\n use syntax::codemap;\n use syntax::edition::Edition;\n use syntax::feature_gate::UnstableFeatures;\n@@ -82,7 +82,8 @@ pub struct DocContext<'a, 'tcx: 'a, 'rcx: 'a> {\n     pub fake_def_ids: RefCell<FxHashMap<CrateNum, DefId>>,\n     pub all_fake_def_ids: RefCell<FxHashSet<DefId>>,\n     /// Maps (type_id, trait_id) -> auto trait impl\n-    pub generated_synthetics: RefCell<FxHashSet<(DefId, DefId)>>\n+    pub generated_synthetics: RefCell<FxHashSet<(DefId, DefId)>>,\n+    pub current_item_name: RefCell<Option<Name>>,\n }\n \n impl<'a, 'tcx, 'rcx> DocContext<'a, 'tcx, 'rcx> {\n@@ -383,6 +384,7 @@ pub fn run_core(search_paths: SearchPaths,\n                 fake_def_ids: RefCell::new(FxHashMap()),\n                 all_fake_def_ids: RefCell::new(FxHashSet()),\n                 generated_synthetics: RefCell::new(FxHashSet()),\n+                current_item_name: RefCell::new(None),\n             };\n             debug!(\"crate: {:?}\", tcx.hir.krate());\n "}, {"sha": "21317f2af42be1a3b035c4aee15e93d83730c4b6", "filename": "src/test/rustdoc/intra-link-self.rs", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/88f264367954083554240fe1c491cb0a4d7c2cc2/src%2Ftest%2Frustdoc%2Fintra-link-self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88f264367954083554240fe1c491cb0a4d7c2cc2/src%2Ftest%2Frustdoc%2Fintra-link-self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fintra-link-self.rs?ref=88f264367954083554240fe1c491cb0a4d7c2cc2", "patch": "@@ -0,0 +1,39 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![crate_name = \"foo\"]\n+\n+// @has foo/index.html '//a/@href' '../foo/struct.Foo.html#method.new'\n+// @has foo/struct.Foo.html '//a/@href' '../foo/struct.Foo.html#method.new'\n+\n+/// Use [`new`] to create a new instance.\n+///\n+/// [`new`]: Self::new\n+pub struct Foo;\n+\n+impl Foo {\n+    pub fn new() -> Self {\n+        unimplemented!()\n+    }\n+}\n+\n+// @has foo/index.html '//a/@href' '../foo/struct.Bar.html#method.new2'\n+// @has foo/struct.Bar.html '//a/@href' '../foo/struct.Bar.html#method.new2'\n+\n+/// Use [`new2`] to create a new instance.\n+///\n+/// [`new2`]: Self::new2\n+pub struct Bar;\n+\n+impl Bar {\n+    pub fn new2() -> Self {\n+        unimplemented!()\n+    }\n+}"}]}