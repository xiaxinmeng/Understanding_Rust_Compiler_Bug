{"sha": "9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlmMjJkZGY2YmI3MDAxYjg4NDAwNmI5NTI4ZjhmYzhjNWI5NGFlOGY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-06-17T23:30:37Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-06-17T23:30:37Z"}, "message": "Auto merge of #61915 - Centril:rollup-oire3i8, r=Centril\n\nRollup of 5 pull requests\n\nSuccessful merges:\n\n - #61702 (test more variants of enum-int-casting)\n - #61836 (Replace some uses of NodeId with HirId)\n - #61885 (Help LLVM better optimize slice::Iter(Mut)::len)\n - #61893 (make `Weak::ptr_eq`s into methods)\n - #61908 (don't ICE on large files)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "f1dc22e419adbdb3e281ab35975a513846fdde2e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f1dc22e419adbdb3e281ab35975a513846fdde2e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f", "html_url": "https://github.com/rust-lang/rust/commit/9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b25ee644971a168287ee166edbd11642dbcfeab8", "url": "https://api.github.com/repos/rust-lang/rust/commits/b25ee644971a168287ee166edbd11642dbcfeab8", "html_url": "https://github.com/rust-lang/rust/commit/b25ee644971a168287ee166edbd11642dbcfeab8"}, {"sha": "6fe265315626be4f5c3116217dfebd4435fbc14e", "url": "https://api.github.com/repos/rust-lang/rust/commits/6fe265315626be4f5c3116217dfebd4435fbc14e", "html_url": "https://github.com/rust-lang/rust/commit/6fe265315626be4f5c3116217dfebd4435fbc14e"}], "stats": {"total": 761, "additions": 357, "deletions": 404}, "files": [{"sha": "ee78839f7f00318bf12b3dfe0623d0e92df37d8b", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f", "patch": "@@ -1515,18 +1515,18 @@ impl<T: ?Sized> Weak<T> {\n     ///\n     /// ```\n     /// #![feature(weak_ptr_eq)]\n-    /// use std::rc::{Rc, Weak};\n+    /// use std::rc::Rc;\n     ///\n     /// let first_rc = Rc::new(5);\n     /// let first = Rc::downgrade(&first_rc);\n     /// let second = Rc::downgrade(&first_rc);\n     ///\n-    /// assert!(Weak::ptr_eq(&first, &second));\n+    /// assert!(first.ptr_eq(&second));\n     ///\n     /// let third_rc = Rc::new(5);\n     /// let third = Rc::downgrade(&third_rc);\n     ///\n-    /// assert!(!Weak::ptr_eq(&first, &third));\n+    /// assert!(!first.ptr_eq(&third));\n     /// ```\n     ///\n     /// Comparing `Weak::new`.\n@@ -1537,16 +1537,16 @@ impl<T: ?Sized> Weak<T> {\n     ///\n     /// let first = Weak::new();\n     /// let second = Weak::new();\n-    /// assert!(Weak::ptr_eq(&first, &second));\n+    /// assert!(first.ptr_eq(&second));\n     ///\n     /// let third_rc = Rc::new(());\n     /// let third = Rc::downgrade(&third_rc);\n-    /// assert!(!Weak::ptr_eq(&first, &third));\n+    /// assert!(!first.ptr_eq(&third));\n     /// ```\n     #[inline]\n     #[unstable(feature = \"weak_ptr_eq\", issue = \"55981\")]\n-    pub fn ptr_eq(this: &Self, other: &Self) -> bool {\n-        this.ptr.as_ptr() == other.ptr.as_ptr()\n+    pub fn ptr_eq(&self, other: &Self) -> bool {\n+        self.ptr.as_ptr() == other.ptr.as_ptr()\n     }\n }\n "}, {"sha": "6c23b3179ed68254812860d4dceaf0c87a4044be", "filename": "src/liballoc/sync.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f/src%2Fliballoc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f/src%2Fliballoc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fsync.rs?ref=9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f", "patch": "@@ -1349,18 +1349,18 @@ impl<T: ?Sized> Weak<T> {\n     ///\n     /// ```\n     /// #![feature(weak_ptr_eq)]\n-    /// use std::sync::{Arc, Weak};\n+    /// use std::sync::Arc;\n     ///\n     /// let first_rc = Arc::new(5);\n     /// let first = Arc::downgrade(&first_rc);\n     /// let second = Arc::downgrade(&first_rc);\n     ///\n-    /// assert!(Weak::ptr_eq(&first, &second));\n+    /// assert!(first.ptr_eq(&second));\n     ///\n     /// let third_rc = Arc::new(5);\n     /// let third = Arc::downgrade(&third_rc);\n     ///\n-    /// assert!(!Weak::ptr_eq(&first, &third));\n+    /// assert!(!first.ptr_eq(&third));\n     /// ```\n     ///\n     /// Comparing `Weak::new`.\n@@ -1371,16 +1371,16 @@ impl<T: ?Sized> Weak<T> {\n     ///\n     /// let first = Weak::new();\n     /// let second = Weak::new();\n-    /// assert!(Weak::ptr_eq(&first, &second));\n+    /// assert!(first.ptr_eq(&second));\n     ///\n     /// let third_rc = Arc::new(());\n     /// let third = Arc::downgrade(&third_rc);\n-    /// assert!(!Weak::ptr_eq(&first, &third));\n+    /// assert!(!first.ptr_eq(&third));\n     /// ```\n     #[inline]\n     #[unstable(feature = \"weak_ptr_eq\", issue = \"55981\")]\n-    pub fn ptr_eq(this: &Self, other: &Self) -> bool {\n-        this.ptr.as_ptr() == other.ptr.as_ptr()\n+    pub fn ptr_eq(&self, other: &Self) -> bool {\n+        self.ptr.as_ptr() == other.ptr.as_ptr()\n     }\n }\n "}, {"sha": "b30eff8baa9c87347c605d87382bf0848024cd7c", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f", "patch": "@@ -1607,3 +1607,9 @@ pub fn maxnumf64(x: f64, y: f64) -> f64 {\n     // Identical to the `f32` case.\n     (if x < y || x != x { y } else { x }) * 1.0\n }\n+\n+/// For bootstrapping, implement unchecked_sub as just wrapping_sub.\n+#[cfg(bootstrap)]\n+pub unsafe fn unchecked_sub<T>(x: T, y: T) -> T {\n+    sub_with_overflow(x, y).0\n+}"}, {"sha": "b2376cdf9fa7628f0422b91ec13b835482ca8902", "filename": "src/libcore/slice/mod.rs", "status": "modified", "additions": 17, "deletions": 4, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f/src%2Flibcore%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f/src%2Flibcore%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Fmod.rs?ref=9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f", "patch": "@@ -25,7 +25,7 @@\n use crate::cmp::Ordering::{self, Less, Equal, Greater};\n use crate::cmp;\n use crate::fmt;\n-use crate::intrinsics::assume;\n+use crate::intrinsics::{assume, exact_div, unchecked_sub};\n use crate::isize;\n use crate::iter::*;\n use crate::ops::{FnMut, Try, self};\n@@ -2998,14 +2998,27 @@ macro_rules! is_empty {\n // unexpected way. (Tested by `codegen/slice-position-bounds-check`.)\n macro_rules! len {\n     ($self: ident) => {{\n+        #![allow(unused_unsafe)] // we're sometimes used within an unsafe block\n+\n         let start = $self.ptr;\n-        let diff = ($self.end as usize).wrapping_sub(start as usize);\n         let size = size_from_ptr(start);\n         if size == 0 {\n+            // This _cannot_ use `unchecked_sub` because we depend on wrapping\n+            // to represent the length of long ZST slice iterators.\n+            let diff = ($self.end as usize).wrapping_sub(start as usize);\n             diff\n         } else {\n-            // Using division instead of `offset_from` helps LLVM remove bounds checks\n-            diff / size\n+            // We know that `start <= end`, so can do better than `offset_from`,\n+            // which needs to deal in signed.  By setting appropriate flags here\n+            // we can tell LLVM this, which helps it remove bounds checks.\n+            // SAFETY: By the type invariant, `start <= end`\n+            let diff = unsafe { unchecked_sub($self.end as usize, start as usize) };\n+            // By also telling LLVM that the pointers are apart by an exact\n+            // multiple of the type size, it can optimize `len() == 0` down to\n+            // `start == end` instead of `(end - start) < size`.\n+            // SAFETY: By the type invariant, the pointers are aligned so the\n+            //         distance between them must be a multiple of pointee size\n+            unsafe { exact_div(diff, size) }\n         }\n     }}\n }"}, {"sha": "85602320f0b0d9a9867f8016d389734c90280d3c", "filename": "src/librustc/cfg/construct.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fcfg%2Fconstruct.rs?ref=9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f", "patch": "@@ -42,7 +42,7 @@ pub fn construct<'tcx>(tcx: TyCtxt<'tcx>, body: &hir::Body) -> CFG {\n     let body_exit;\n \n     // Find the tables for this body.\n-    let owner_def_id = tcx.hir().local_def_id(tcx.hir().body_owner(body.id()));\n+    let owner_def_id = tcx.hir().body_owner_def_id(body.id());\n     let tables = tcx.typeck_tables_of(owner_def_id);\n \n     let mut cfg_builder = CFGBuilder {\n@@ -357,7 +357,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n             args: I) -> CFGIndex {\n         let func_or_rcvr_exit = self.expr(func_or_rcvr, pred);\n         let ret = self.straightline(call_expr, func_or_rcvr_exit, args);\n-        let m = self.tcx.hir().get_module_parent_by_hir_id(call_expr.hir_id);\n+        let m = self.tcx.hir().get_module_parent(call_expr.hir_id);\n         if self.tcx.is_ty_uninhabited_from(m, self.tables.expr_ty(call_expr)) {\n             self.add_unreachable_node()\n         } else {"}, {"sha": "66963e5856eec85b9ba5454c8ee7a6e5ec86b1bf", "filename": "src/librustc/cfg/graphviz.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f/src%2Flibrustc%2Fcfg%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f/src%2Flibrustc%2Fcfg%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fcfg%2Fgraphviz.rs?ref=9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f", "patch": "@@ -22,11 +22,11 @@ pub struct LabelledCFG<'a, 'tcx: 'a> {\n impl<'a, 'tcx> LabelledCFG<'a, 'tcx> {\n     fn local_id_to_string(&self, local_id: hir::ItemLocalId) -> String {\n         assert!(self.cfg.owner_def_id.is_local());\n-        let node_id = self.tcx.hir().hir_to_node_id(hir::HirId {\n+        let hir_id = hir::HirId {\n             owner: self.tcx.hir().def_index_to_hir_id(self.cfg.owner_def_id.index).owner,\n             local_id\n-        });\n-        let s = self.tcx.hir().node_to_string(node_id);\n+        };\n+        let s = self.tcx.hir().node_to_string(hir_id);\n \n         // Replacing newlines with \\\\l causes each line to be left-aligned,\n         // improving presentation of (long) pretty-printed expressions."}, {"sha": "666cfc3f6dcac4bf838dfc73f05c9a0e46746802", "filename": "src/librustc/hir/intravisit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f/src%2Flibrustc%2Fhir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f/src%2Flibrustc%2Fhir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fintravisit.rs?ref=9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f", "patch": "@@ -171,7 +171,7 @@ pub trait Visitor<'v> : Sized {\n     /// but cannot supply a `Map`; see `nested_visit_map` for advice.\n     #[allow(unused_variables)]\n     fn visit_nested_item(&mut self, id: ItemId) {\n-        let opt_item = self.nested_visit_map().inter().map(|map| map.expect_item_by_hir_id(id.id));\n+        let opt_item = self.nested_visit_map().inter().map(|map| map.expect_item(id.id));\n         if let Some(item) = opt_item {\n             self.visit_item(item);\n         }"}, {"sha": "32d0e069f72deb0881d53406408eb6d306c81103", "filename": "src/librustc/hir/map/hir_id_validator.rs", "status": "modified", "additions": 4, "deletions": 15, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f/src%2Flibrustc%2Fhir%2Fmap%2Fhir_id_validator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f/src%2Flibrustc%2Fhir%2Fmap%2Fhir_id_validator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fhir_id_validator.rs?ref=9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f", "patch": "@@ -1,6 +1,5 @@\n use crate::hir::def_id::{DefId, DefIndex, CRATE_DEF_INDEX};\n use crate::hir::{self, intravisit, HirId, ItemLocalId};\n-use syntax::ast::NodeId;\n use crate::hir::itemlikevisit::ItemLikeVisitor;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::sync::{Lock, ParallelIterator, par_iter};\n@@ -112,19 +111,9 @@ impl<'a, 'hir: 'a> HirIdValidator<'a, 'hir> {\n \n                 trace!(\"missing hir id {:#?}\", hir_id);\n \n-                // We are already in ICE mode here, so doing a linear search\n-                // should be fine.\n-                let (node_id, _) = self.hir_map\n-                                       .definitions()\n-                                       .node_to_hir_id\n-                                       .iter()\n-                                       .enumerate()\n-                                       .find(|&(_, &entry)| hir_id == entry)\n-                                       .expect(\"no node_to_hir_id entry\");\n-                let node_id = NodeId::from_usize(node_id);\n                 missing_items.push(format!(\"[local_id: {}, node:{}]\",\n                                            local_id,\n-                                           self.hir_map.node_to_string(node_id)));\n+                                           self.hir_map.node_to_string(hir_id)));\n             }\n             self.error(|| format!(\n                 \"ItemLocalIds not assigned densely in {}. \\\n@@ -138,7 +127,7 @@ impl<'a, 'hir: 'a> HirIdValidator<'a, 'hir> {\n                         owner: owner_def_index,\n                         local_id,\n                     })\n-                    .map(|h| format!(\"({:?} {})\", h, self.hir_map.hir_to_string(h)))\n+                    .map(|h| format!(\"({:?} {})\", h, self.hir_map.node_to_string(h)))\n                     .collect::<Vec<_>>()));\n         }\n     }\n@@ -156,14 +145,14 @@ impl<'a, 'hir: 'a> intravisit::Visitor<'hir> for HirIdValidator<'a, 'hir> {\n \n         if hir_id == hir::DUMMY_HIR_ID {\n             self.error(|| format!(\"HirIdValidator: HirId {:?} is invalid\",\n-                                  self.hir_map.hir_to_string(hir_id)));\n+                                  self.hir_map.node_to_string(hir_id)));\n             return;\n         }\n \n         if owner != hir_id.owner {\n             self.error(|| format!(\n                 \"HirIdValidator: The recorded owner of {} is {} instead of {}\",\n-                self.hir_map.hir_to_string(hir_id),\n+                self.hir_map.node_to_string(hir_id),\n                 self.hir_map.def_path(DefId::local(hir_id.owner)).to_string_no_crate(),\n                 self.hir_map.def_path(DefId::local(owner)).to_string_no_crate()));\n         }"}, {"sha": "85c86991f489a9a6bb3f5f558a0b4e9a5a5385be", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 39, "deletions": 125, "changes": 164, "blob_url": "https://github.com/rust-lang/rust/blob/9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f", "patch": "@@ -35,7 +35,7 @@ mod def_collector;\n pub mod definitions;\n mod hir_id_validator;\n \n-/// Represents an entry and its parent `NodeId`.\n+/// Represents an entry and its parent `HirId`.\n #[derive(Copy, Clone, Debug)]\n pub struct Entry<'hir> {\n     parent: HirId,\n@@ -200,7 +200,7 @@ impl<'hir> Map<'hir> {\n     /// \"reveals\" the content of a node to the caller (who might not\n     /// otherwise have had access to those contents, and hence needs a\n     /// read recorded). If the function just returns a DefId or\n-    /// NodeId, no actual content was returned, so no read is needed.\n+    /// HirId, no actual content was returned, so no read is needed.\n     pub fn read(&self, hir_id: HirId) {\n         if let Some(entry) = self.lookup(hir_id) {\n             self.dep_graph.read_index(entry.dep_node);\n@@ -286,21 +286,11 @@ impl<'hir> Map<'hir> {\n         self.definitions.def_index_to_hir_id(def_index)\n     }\n \n-    #[inline]\n-    pub fn def_index_to_node_id(&self, def_index: DefIndex) -> NodeId {\n-        self.definitions.def_index_to_node_id(def_index)\n-    }\n-\n     #[inline]\n     pub fn local_def_id_to_hir_id(&self, def_id: LocalDefId) -> HirId {\n         self.definitions.def_index_to_hir_id(def_id.to_def_id().index)\n     }\n \n-    #[inline]\n-    pub fn local_def_id_to_node_id(&self, def_id: LocalDefId) -> NodeId {\n-        self.definitions.as_local_node_id(def_id.to_def_id()).unwrap()\n-    }\n-\n     fn def_kind(&self, node_id: NodeId) -> Option<DefKind> {\n         let node = if let Some(node) = self.find(node_id) {\n             node\n@@ -422,12 +412,6 @@ impl<'hir> Map<'hir> {\n         self.forest.krate.body(id)\n     }\n \n-    pub fn fn_decl(&self, node_id: ast::NodeId) -> Option<FnDecl> {\n-        let hir_id = self.node_to_hir_id(node_id);\n-        self.fn_decl_by_hir_id(hir_id)\n-    }\n-\n-    // FIXME(@ljedrz): replace the `NodeId` variant.\n     pub fn fn_decl_by_hir_id(&self, hir_id: HirId) -> Option<FnDecl> {\n         if let Some(entry) = self.find_entry(hir_id) {\n             entry.fn_decl().cloned()\n@@ -436,28 +420,22 @@ impl<'hir> Map<'hir> {\n         }\n     }\n \n-    /// Returns the `NodeId` that corresponds to the definition of\n+    /// Returns the `HirId` that corresponds to the definition of\n     /// which this is the body of, i.e., a `fn`, `const` or `static`\n     /// item (possibly associated), a closure, or a `hir::AnonConst`.\n-    pub fn body_owner(&self, BodyId { hir_id }: BodyId) -> NodeId {\n+    pub fn body_owner(&self, BodyId { hir_id }: BodyId) -> HirId {\n         let parent = self.get_parent_node_by_hir_id(hir_id);\n         assert!(self.lookup(parent).map_or(false, |e| e.is_body_owner(hir_id)));\n-        self.hir_to_node_id(parent)\n+        parent\n     }\n \n     pub fn body_owner_def_id(&self, id: BodyId) -> DefId {\n-        self.local_def_id(self.body_owner(id))\n+        self.local_def_id_from_hir_id(self.body_owner(id))\n     }\n \n-    /// Given a `NodeId`, returns the `BodyId` associated with it,\n+    /// Given a `HirId`, returns the `BodyId` associated with it,\n     /// if the node is a body owner, otherwise returns `None`.\n-    pub fn maybe_body_owned_by(&self, id: NodeId) -> Option<BodyId> {\n-        let hir_id = self.node_to_hir_id(id);\n-        self.maybe_body_owned_by_by_hir_id(hir_id)\n-    }\n-\n-    // FIXME(@ljedrz): replace the `NodeId` variant.\n-    pub fn maybe_body_owned_by_by_hir_id(&self, hir_id: HirId) -> Option<BodyId> {\n+    pub fn maybe_body_owned_by(&self, hir_id: HirId) -> Option<BodyId> {\n         if let Some(entry) = self.find_entry(hir_id) {\n             if self.dep_graph.is_fully_enabled() {\n                 let hir_id_owner = hir_id.owner;\n@@ -473,19 +451,13 @@ impl<'hir> Map<'hir> {\n \n     /// Given a body owner's id, returns the `BodyId` associated with it.\n     pub fn body_owned_by(&self, id: HirId) -> BodyId {\n-        self.maybe_body_owned_by_by_hir_id(id).unwrap_or_else(|| {\n-            span_bug!(self.span_by_hir_id(id), \"body_owned_by: {} has no associated body\",\n-                      self.hir_to_string(id));\n+        self.maybe_body_owned_by(id).unwrap_or_else(|| {\n+            span_bug!(self.span(id), \"body_owned_by: {} has no associated body\",\n+                      self.node_to_string(id));\n         })\n     }\n \n-    pub fn body_owner_kind(&self, id: NodeId) -> BodyOwnerKind {\n-        let hir_id = self.node_to_hir_id(id);\n-        self.body_owner_kind_by_hir_id(hir_id)\n-    }\n-\n-    // FIXME(@ljedrz): replace the `NodeId` variant.\n-    pub fn body_owner_kind_by_hir_id(&self, id: HirId) -> BodyOwnerKind {\n+    pub fn body_owner_kind(&self, id: HirId) -> BodyOwnerKind {\n         match self.get_by_hir_id(id) {\n             Node::Item(&Item { node: ItemKind::Const(..), .. }) |\n             Node::TraitItem(&TraitItem { node: TraitItemKind::Const(..), .. }) |\n@@ -514,7 +486,7 @@ impl<'hir> Map<'hir> {\n             Node::Item(&Item { node: ItemKind::Trait(..), .. }) |\n             Node::Item(&Item { node: ItemKind::TraitAlias(..), .. }) => id,\n             Node::GenericParam(_) => self.get_parent_node_by_hir_id(id),\n-            _ => bug!(\"ty_param_owner: {} not a type parameter\", self.hir_to_string(id))\n+            _ => bug!(\"ty_param_owner: {} not a type parameter\", self.node_to_string(id))\n         }\n     }\n \n@@ -523,7 +495,7 @@ impl<'hir> Map<'hir> {\n             Node::Item(&Item { node: ItemKind::Trait(..), .. }) |\n             Node::Item(&Item { node: ItemKind::TraitAlias(..), .. }) => kw::SelfUpper,\n             Node::GenericParam(param) => param.name.ident().name,\n-            _ => bug!(\"ty_param_name: {} not a type parameter\", self.hir_to_string(id)),\n+            _ => bug!(\"ty_param_name: {} not a type parameter\", self.node_to_string(id)),\n         }\n     }\n \n@@ -576,7 +548,7 @@ impl<'hir> Map<'hir> {\n         let module = &self.forest.krate.modules[&node_id];\n \n         for id in &module.items {\n-            visitor.visit_item(self.expect_item_by_hir_id(*id));\n+            visitor.visit_item(self.expect_item(*id));\n         }\n \n         for id in &module.trait_items {\n@@ -709,7 +681,7 @@ impl<'hir> Map<'hir> {\n \n     /// If there is some error when walking the parents (e.g., a node does not\n     /// have a parent in the map or a node can't be found), then we return the\n-    /// last good `NodeId` we found. Note that reaching the crate root (`id == 0`),\n+    /// last good `HirId` we found. Note that reaching the crate root (`id == 0`),\n     /// is not an error, since items in the crate module have the crate root as\n     /// parent.\n     fn walk_parent_nodes<F, F2>(&self,\n@@ -745,15 +717,15 @@ impl<'hir> Map<'hir> {\n         }\n     }\n \n-    /// Retrieves the `NodeId` for `id`'s enclosing method, unless there's a\n+    /// Retrieves the `HirId` for `id`'s enclosing method, unless there's a\n     /// `while` or `loop` before reaching it, as block tail returns are not\n     /// available in them.\n     ///\n     /// ```\n     /// fn foo(x: usize) -> bool {\n     ///     if x == 1 {\n     ///         true  // `get_return_block` gets passed the `id` corresponding\n-    ///     } else {  // to this, it will return `foo`'s `NodeId`.\n+    ///     } else {  // to this, it will return `foo`'s `HirId`.\n     ///         false\n     ///     }\n     /// }\n@@ -793,17 +765,10 @@ impl<'hir> Map<'hir> {\n         self.walk_parent_nodes(id, match_fn, match_non_returning_block).ok()\n     }\n \n-    /// Retrieves the `NodeId` for `id`'s parent item, or `id` itself if no\n+    /// Retrieves the `HirId` for `id`'s parent item, or `id` itself if no\n     /// parent item is in this map. The \"parent item\" is the closest parent node\n     /// in the HIR which is recorded by the map and is an item, either an item\n     /// in a module, trait, or impl.\n-    pub fn get_parent(&self, id: NodeId) -> NodeId {\n-        let hir_id = self.node_to_hir_id(id);\n-        let parent_hir_id = self.get_parent_item(hir_id);\n-        self.hir_to_node_id(parent_hir_id)\n-    }\n-\n-    // FIXME(@ljedrz): replace the `NodeId` variant.\n     pub fn get_parent_item(&self, hir_id: HirId) -> HirId {\n         match self.walk_parent_nodes(hir_id, |node| match *node {\n             Node::Item(_) |\n@@ -819,13 +784,7 @@ impl<'hir> Map<'hir> {\n \n     /// Returns the `DefId` of `id`'s nearest module parent, or `id` itself if no\n     /// module parent is in this map.\n-    pub fn get_module_parent(&self, id: NodeId) -> DefId {\n-        let hir_id = self.node_to_hir_id(id);\n-        self.get_module_parent_by_hir_id(hir_id)\n-    }\n-\n-    // FIXME(@ljedrz): replace the `NodeId` variant.\n-    pub fn get_module_parent_by_hir_id(&self, id: HirId) -> DefId {\n+    pub fn get_module_parent(&self, id: HirId) -> DefId {\n         self.local_def_id_from_hir_id(self.get_module_parent_node(id))\n     }\n \n@@ -901,23 +860,11 @@ impl<'hir> Map<'hir> {\n         Some(scope)\n     }\n \n-    pub fn get_parent_did(&self, id: NodeId) -> DefId {\n-        let hir_id = self.node_to_hir_id(id);\n-        self.get_parent_did_by_hir_id(hir_id)\n-    }\n-\n-    // FIXME(@ljedrz): replace the `NodeId` variant.\n-    pub fn get_parent_did_by_hir_id(&self, id: HirId) -> DefId {\n+    pub fn get_parent_did(&self, id: HirId) -> DefId {\n         self.local_def_id_from_hir_id(self.get_parent_item(id))\n     }\n \n-    pub fn get_foreign_abi(&self, id: NodeId) -> Abi {\n-        let hir_id = self.node_to_hir_id(id);\n-        self.get_foreign_abi_by_hir_id(hir_id)\n-    }\n-\n-    // FIXME(@ljedrz): replace the `NodeId` variant.\n-    pub fn get_foreign_abi_by_hir_id(&self, hir_id: HirId) -> Abi {\n+    pub fn get_foreign_abi(&self, hir_id: HirId) -> Abi {\n         let parent = self.get_parent_item(hir_id);\n         if let Some(entry) = self.find_entry(parent) {\n             if let Entry {\n@@ -927,33 +874,27 @@ impl<'hir> Map<'hir> {\n                 return nm.abi;\n             }\n         }\n-        bug!(\"expected foreign mod or inlined parent, found {}\", self.hir_to_string(parent))\n-    }\n-\n-    pub fn expect_item(&self, id: NodeId) -> &'hir Item {\n-        let hir_id = self.node_to_hir_id(id);\n-        self.expect_item_by_hir_id(hir_id)\n+        bug!(\"expected foreign mod or inlined parent, found {}\", self.node_to_string(parent))\n     }\n \n-    // FIXME(@ljedrz): replace the `NodeId` variant.\n-    pub fn expect_item_by_hir_id(&self, id: HirId) -> &'hir Item {\n+    pub fn expect_item(&self, id: HirId) -> &'hir Item {\n         match self.find_by_hir_id(id) { // read recorded by `find`\n             Some(Node::Item(item)) => item,\n-            _ => bug!(\"expected item, found {}\", self.hir_to_string(id))\n+            _ => bug!(\"expected item, found {}\", self.node_to_string(id))\n         }\n     }\n \n     pub fn expect_impl_item(&self, id: HirId) -> &'hir ImplItem {\n         match self.find_by_hir_id(id) {\n             Some(Node::ImplItem(item)) => item,\n-            _ => bug!(\"expected impl item, found {}\", self.hir_to_string(id))\n+            _ => bug!(\"expected impl item, found {}\", self.node_to_string(id))\n         }\n     }\n \n     pub fn expect_trait_item(&self, id: HirId) -> &'hir TraitItem {\n         match self.find_by_hir_id(id) {\n             Some(Node::TraitItem(item)) => item,\n-            _ => bug!(\"expected trait item, found {}\", self.hir_to_string(id))\n+            _ => bug!(\"expected trait item, found {}\", self.node_to_string(id))\n         }\n     }\n \n@@ -963,26 +904,26 @@ impl<'hir> Map<'hir> {\n                 match i.node {\n                     ItemKind::Struct(ref struct_def, _) |\n                     ItemKind::Union(ref struct_def, _) => struct_def,\n-                    _ => bug!(\"struct ID bound to non-struct {}\", self.hir_to_string(id))\n+                    _ => bug!(\"struct ID bound to non-struct {}\", self.node_to_string(id))\n                 }\n             }\n             Some(Node::Variant(variant)) => &variant.node.data,\n             Some(Node::Ctor(data)) => data,\n-            _ => bug!(\"expected struct or variant, found {}\", self.hir_to_string(id))\n+            _ => bug!(\"expected struct or variant, found {}\", self.node_to_string(id))\n         }\n     }\n \n     pub fn expect_variant(&self, id: HirId) -> &'hir Variant {\n         match self.find_by_hir_id(id) {\n             Some(Node::Variant(variant)) => variant,\n-            _ => bug!(\"expected variant, found {}\", self.hir_to_string(id)),\n+            _ => bug!(\"expected variant, found {}\", self.node_to_string(id)),\n         }\n     }\n \n     pub fn expect_foreign_item(&self, id: HirId) -> &'hir ForeignItem {\n         match self.find_by_hir_id(id) {\n             Some(Node::ForeignItem(item)) => item,\n-            _ => bug!(\"expected foreign item, found {}\", self.hir_to_string(id))\n+            _ => bug!(\"expected foreign item, found {}\", self.node_to_string(id))\n         }\n     }\n \n@@ -995,7 +936,7 @@ impl<'hir> Map<'hir> {\n     pub fn expect_expr_by_hir_id(&self, id: HirId) -> &'hir Expr {\n         match self.find_by_hir_id(id) { // read recorded by find\n             Some(Node::Expr(expr)) => expr,\n-            _ => bug!(\"expected expr, found {}\", self.hir_to_string(id))\n+            _ => bug!(\"expected expr, found {}\", self.node_to_string(id))\n         }\n     }\n \n@@ -1018,19 +959,13 @@ impl<'hir> Map<'hir> {\n             Node::GenericParam(param) => param.name.ident().name,\n             Node::Binding(&Pat { node: PatKind::Binding(_, _, l, _), .. }) => l.name,\n             Node::Ctor(..) => self.name_by_hir_id(self.get_parent_item(id)),\n-            _ => bug!(\"no name for {}\", self.hir_to_string(id))\n+            _ => bug!(\"no name for {}\", self.node_to_string(id))\n         }\n     }\n \n     /// Given a node ID, gets a list of attributes associated with the AST\n     /// corresponding to the node-ID.\n-    pub fn attrs(&self, id: NodeId) -> &'hir [ast::Attribute] {\n-        let hir_id = self.node_to_hir_id(id);\n-        self.attrs_by_hir_id(hir_id)\n-    }\n-\n-    // FIXME(@ljedrz): replace the `NodeId` variant.\n-    pub fn attrs_by_hir_id(&self, id: HirId) -> &'hir [ast::Attribute] {\n+    pub fn attrs(&self, id: HirId) -> &'hir [ast::Attribute] {\n         self.read(id); // reveals attributes on the node\n         let attrs = match self.find_entry(id).map(|entry| entry.node) {\n             Some(Node::Local(l)) => Some(&l.attrs[..]),\n@@ -1046,7 +981,7 @@ impl<'hir> Map<'hir> {\n             Some(Node::GenericParam(param)) => Some(&param.attrs[..]),\n             // Unit/tuple structs/variants take the attributes straight from\n             // the struct/variant definition.\n-            Some(Node::Ctor(..)) => return self.attrs_by_hir_id(self.get_parent_item(id)),\n+            Some(Node::Ctor(..)) => return self.attrs(self.get_parent_item(id)),\n             Some(Node::Crate) => Some(&self.forest.krate.attrs[..]),\n             _ => None\n         };\n@@ -1093,13 +1028,7 @@ impl<'hir> Map<'hir> {\n         })\n     }\n \n-    pub fn span(&self, id: NodeId) -> Span {\n-        let hir_id = self.node_to_hir_id(id);\n-        self.span_by_hir_id(hir_id)\n-    }\n-\n-    // FIXME(@ljedrz): replace the `NodeId` variant.\n-    pub fn span_by_hir_id(&self, hir_id: HirId) -> Span {\n+    pub fn span(&self, hir_id: HirId) -> Span {\n         self.read(hir_id); // reveals span from node\n         match self.find_entry(hir_id).map(|entry| entry.node) {\n             Some(Node::Item(item)) => item.span,\n@@ -1139,32 +1068,17 @@ impl<'hir> Map<'hir> {\n     }\n \n     pub fn span_if_local(&self, id: DefId) -> Option<Span> {\n-        self.as_local_node_id(id).map(|id| self.span(id))\n+        self.as_local_hir_id(id).map(|id| self.span(id))\n     }\n \n-    pub fn node_to_string(&self, id: NodeId) -> String {\n-        hir_id_to_string(self, self.node_to_hir_id(id), true)\n-    }\n-\n-    // FIXME(@ljedrz): replace the `NodeId` variant.\n-    pub fn hir_to_string(&self, id: HirId) -> String {\n+    pub fn node_to_string(&self, id: HirId) -> String {\n         hir_id_to_string(self, id, true)\n     }\n \n-    pub fn node_to_user_string(&self, id: NodeId) -> String {\n-        hir_id_to_string(self, self.node_to_hir_id(id), false)\n-    }\n-\n-    // FIXME(@ljedrz): replace the `NodeId` variant.\n     pub fn hir_to_user_string(&self, id: HirId) -> String {\n         hir_id_to_string(self, id, false)\n     }\n \n-    pub fn node_to_pretty_string(&self, id: NodeId) -> String {\n-        print::to_string(self, |s| s.print_node(self.get(id)))\n-    }\n-\n-    // FIXME(@ljedrz): replace the `NodeId` variant.\n     pub fn hir_to_pretty_string(&self, id: HirId) -> String {\n         print::to_string(self, |s| s.print_node(self.get_by_hir_id(id)))\n     }\n@@ -1307,7 +1221,7 @@ pub fn map_crate<'hir>(sess: &crate::session::Session,\n impl<'hir> print::PpAnn for Map<'hir> {\n     fn nested(&self, state: &mut print::State<'_>, nested: print::Nested) -> io::Result<()> {\n         match nested {\n-            Nested::Item(id) => state.print_item(self.expect_item_by_hir_id(id.id)),\n+            Nested::Item(id) => state.print_item(self.expect_item(id.id)),\n             Nested::TraitItem(id) => state.print_trait_item(self.trait_item(id)),\n             Nested::ImplItem(id) => state.print_impl_item(self.impl_item(id)),\n             Nested::Body(id) => state.print_expr(&self.body(id).value),"}, {"sha": "0884a726a27b0b58d38e55456fec44632cc2696e", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f", "patch": "@@ -2177,8 +2177,8 @@ pub enum UseKind {\n /// References to traits in impls.\n ///\n /// `resolve` maps each `TraitRef`'s `ref_id` to its defining trait; that's all\n-/// that the `ref_id` is for. Note that `ref_id`'s value is not the `NodeId` of the\n-/// trait being referred to but just a unique `NodeId` that serves as a key\n+/// that the `ref_id` is for. Note that `ref_id`'s value is not the `HirId` of the\n+/// trait being referred to but just a unique `HirId` that serves as a key\n /// within the resolution map.\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub struct TraitRef {"}, {"sha": "54b4435573baac2171577065d9355d78581986dd", "filename": "src/librustc/hir/upvars.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f/src%2Flibrustc%2Fhir%2Fupvars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f/src%2Flibrustc%2Fhir%2Fupvars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fupvars.rs?ref=9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f", "patch": "@@ -14,8 +14,8 @@ pub fn provide(providers: &mut Providers<'_>) {\n             return None;\n         }\n \n-        let node_id = tcx.hir().as_local_node_id(def_id).unwrap();\n-        let body = tcx.hir().body(tcx.hir().maybe_body_owned_by(node_id)?);\n+        let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n+        let body = tcx.hir().body(tcx.hir().maybe_body_owned_by(hir_id)?);\n \n         let mut local_collector = LocalCollector::default();\n         local_collector.visit_body(body);"}, {"sha": "321c06897de111a538e7cfbcb0aa05b18caabd7f", "filename": "src/librustc/infer/error_reporting/mod.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f", "patch": "@@ -86,7 +86,7 @@ impl<'tcx> TyCtxt<'tcx> {\n                     )\n                 };\n                 let span = scope.span(self, region_scope_tree);\n-                let tag = match self.hir().find(scope.node_id(self, region_scope_tree)) {\n+                let tag = match self.hir().find_by_hir_id(scope.hir_id(region_scope_tree)) {\n                     Some(Node::Block(_)) => \"block\",\n                     Some(Node::Expr(expr)) => match expr.node {\n                         hir::ExprKind::Call(..) => \"call\",\n@@ -191,7 +191,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         };\n         let (prefix, span) = match *region {\n             ty::ReEarlyBound(ref br) => {\n-                let mut sp = cm.def_span(self.hir().span_by_hir_id(node));\n+                let mut sp = cm.def_span(self.hir().span(node));\n                 if let Some(param) = self.hir()\n                     .get_generics(scope)\n                     .and_then(|generics| generics.get_named(br.name))\n@@ -204,7 +204,7 @@ impl<'tcx> TyCtxt<'tcx> {\n                 bound_region: ty::BoundRegion::BrNamed(_, name),\n                 ..\n             }) => {\n-                let mut sp = cm.def_span(self.hir().span_by_hir_id(node));\n+                let mut sp = cm.def_span(self.hir().span(node));\n                 if let Some(param) = self.hir()\n                     .get_generics(scope)\n                     .and_then(|generics| generics.get_named(name))\n@@ -216,11 +216,11 @@ impl<'tcx> TyCtxt<'tcx> {\n             ty::ReFree(ref fr) => match fr.bound_region {\n                 ty::BrAnon(idx) => (\n                     format!(\"the anonymous lifetime #{} defined on\", idx + 1),\n-                    self.hir().span_by_hir_id(node),\n+                    self.hir().span(node),\n                 ),\n                 _ => (\n                     format!(\"the lifetime {} as defined on\", region),\n-                    cm.def_span(self.hir().span_by_hir_id(node)),\n+                    cm.def_span(self.hir().span(node)),\n                 ),\n             },\n             _ => bug!(),\n@@ -1330,12 +1330,12 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     if !param.is_self() {\n                         let type_param = generics.type_param(param, self.tcx);\n                         let hir = &self.tcx.hir();\n-                        hir.as_local_node_id(type_param.def_id).map(|id| {\n+                        hir.as_local_hir_id(type_param.def_id).map(|id| {\n                             // Get the `hir::Param` to verify whether it already has any bounds.\n                             // We do this to avoid suggesting code that ends up as `T: 'a'b`,\n                             // instead we suggest `T: 'a + 'b` in that case.\n                             let mut has_bounds = false;\n-                            if let Node::GenericParam(ref param) = hir.get(id) {\n+                            if let Node::GenericParam(ref param) = hir.get_by_hir_id(id) {\n                                 has_bounds = !param.bounds.is_empty();\n                             }\n                             let sp = hir.span(id);"}, {"sha": "78d1d56993e062bea3ae8eec5a281bcd98e19a2d", "filename": "src/librustc/infer/error_reporting/nice_region_error/find_anon_type.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ffind_anon_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ffind_anon_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ffind_anon_type.rs?ref=9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f", "patch": "@@ -28,8 +28,8 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n     ) -> Option<(&hir::Ty, &hir::FnDecl)> {\n         if let Some(anon_reg) = self.tcx().is_suitable_region(region) {\n             let def_id = anon_reg.def_id;\n-            if let Some(node_id) = self.tcx().hir().as_local_node_id(def_id) {\n-                let fndecl = match self.tcx().hir().get(node_id) {\n+            if let Some(hir_id) = self.tcx().hir().as_local_hir_id(def_id) {\n+                let fndecl = match self.tcx().hir().get_by_hir_id(hir_id) {\n                     Node::Item(&hir::Item {\n                         node: hir::ItemKind::Fn(ref fndecl, ..),\n                         .."}, {"sha": "6ed2b67556ddcec5521f7167cdbe85ef6ab16e0b", "filename": "src/librustc/infer/error_reporting/nice_region_error/outlives_closure.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Foutlives_closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Foutlives_closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Foutlives_closure.rs?ref=9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f", "patch": "@@ -48,11 +48,11 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n             if let (&SubregionOrigin::BindingTypeIsNotValidAtDecl(ref external_span),\n                     &RegionKind::ReFree(ref free_region)) = (&sub_origin, sup_region) {\n                 let hir = &self.tcx().hir();\n-                if let Some(node_id) = hir.as_local_node_id(free_region.scope) {\n+                if let Some(hir_id) = hir.as_local_hir_id(free_region.scope) {\n                     if let Node::Expr(Expr {\n                         node: Closure(_, _, _, closure_span, None),\n                         ..\n-                    }) = hir.get(node_id) {\n+                    }) = hir.get_by_hir_id(hir_id) {\n                         let sup_sp = sup_origin.span();\n                         let origin_sp = origin.span();\n                         let mut err = self.tcx().sess.struct_span_err("}, {"sha": "f33f917392653a9715a4aa68dd4cdfd9b5b7c194", "filename": "src/librustc/infer/error_reporting/nice_region_error/util.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Futil.rs?ref=9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f", "patch": "@@ -51,19 +51,19 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n         };\n \n         let hir = &self.tcx().hir();\n-        if let Some(node_id) = hir.as_local_node_id(id) {\n-            if let Some(body_id) = hir.maybe_body_owned_by(node_id) {\n+        if let Some(hir_id) = hir.as_local_hir_id(id) {\n+            if let Some(body_id) = hir.maybe_body_owned_by(hir_id) {\n                 let body = hir.body(body_id);\n                 let owner_id = hir.body_owner(body_id);\n-                let fn_decl = hir.fn_decl(owner_id).unwrap();\n+                let fn_decl = hir.fn_decl_by_hir_id(owner_id).unwrap();\n                 if let Some(tables) = self.tables {\n                     body.arguments\n                         .iter()\n                         .enumerate()\n                         .filter_map(|(index, arg)| {\n                             // May return None; sometimes the tables are not yet populated.\n                             let ty_hir_id = fn_decl.inputs[index].hir_id;\n-                            let arg_ty_span = hir.span(hir.hir_to_node_id(ty_hir_id));\n+                            let arg_ty_span = hir.span(ty_hir_id);\n                             let ty = tables.node_type_opt(arg.hir_id)?;\n                             let mut found_anon_region = false;\n                             let new_arg_ty = self.tcx().fold_regions(&ty, &mut false, |r, _| {"}, {"sha": "328ace51a58282c96b0ef8e87151f3de9c976f9c", "filename": "src/librustc/infer/opaque_types/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs?ref=9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f", "patch": "@@ -819,7 +819,7 @@ impl<'a, 'tcx> Instantiator<'a, 'tcx> {\n                             },\n                             _ => bug!(\n                                 \"expected (impl) item, found {}\",\n-                                tcx.hir().hir_to_string(opaque_hir_id),\n+                                tcx.hir().node_to_string(opaque_hir_id),\n                             ),\n                         };\n                         if in_definition_scope {"}, {"sha": "e90f4ca94c625cbfaa67e73a0c719eab94dfb6f2", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f", "patch": "@@ -1399,7 +1399,7 @@ fn late_lint_mod_pass<'tcx, T: for<'a> LateLintPass<'a, 'tcx>>(\n \n     // Visit the crate attributes\n     if hir_id == hir::CRATE_HIR_ID {\n-        walk_list!(cx, visit_attribute, tcx.hir().attrs_by_hir_id(hir::CRATE_HIR_ID));\n+        walk_list!(cx, visit_attribute, tcx.hir().attrs(hir::CRATE_HIR_ID));\n     }\n }\n "}, {"sha": "041944d887bd9431c0f3ac82eeb2d3df91e86c4b", "filename": "src/librustc/lint/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f/src%2Flibrustc%2Flint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f/src%2Flibrustc%2Flint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fmod.rs?ref=9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f", "patch": "@@ -762,7 +762,7 @@ pub fn struct_lint_level<'a>(sess: &'a Session,\n }\n \n pub fn maybe_lint_level_root(tcx: TyCtxt<'_>, id: hir::HirId) -> bool {\n-    let attrs = tcx.hir().attrs_by_hir_id(id);\n+    let attrs = tcx.hir().attrs(id);\n     attrs.iter().any(|attr| Level::from_symbol(attr.name_or_empty()).is_some())\n }\n "}, {"sha": "63503f58156bc4484b22cdef5c7a2fc59944402f", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f", "patch": "@@ -292,7 +292,7 @@ impl<'a, 'tcx> Visitor<'tcx> for MarkSymbolVisitor<'a, 'tcx> {\n     fn visit_ty(&mut self, ty: &'tcx hir::Ty) {\n         match ty.node {\n             TyKind::Def(item_id, _) => {\n-                let item = self.tcx.hir().expect_item_by_hir_id(item_id.id);\n+                let item = self.tcx.hir().expect_item(item_id.id);\n                 intravisit::walk_item(self, item);\n             }\n             _ => ()"}, {"sha": "3d2bc6c7bf88259ca8b2b5288098af15faa01f79", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f", "patch": "@@ -1171,7 +1171,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n             }\n \n             hir::ExprKind::Call(ref f, ref args) => {\n-                let m = self.ir.tcx.hir().get_module_parent_by_hir_id(expr.hir_id);\n+                let m = self.ir.tcx.hir().get_module_parent(expr.hir_id);\n                 let succ = if self.ir.tcx.is_ty_uninhabited_from(m, self.tables.expr_ty(expr)) {\n                     self.s.exit_ln\n                 } else {\n@@ -1182,7 +1182,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n             }\n \n             hir::ExprKind::MethodCall(.., ref args) => {\n-                let m = self.ir.tcx.hir().get_module_parent_by_hir_id(expr.hir_id);\n+                let m = self.ir.tcx.hir().get_module_parent(expr.hir_id);\n                 let succ = if self.ir.tcx.is_ty_uninhabited_from(m, self.tables.expr_ty(expr)) {\n                     self.s.exit_ln\n                 } else {"}, {"sha": "192e72383acee591d12134ee7bb78ce798de1a91", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f", "patch": "@@ -342,9 +342,9 @@ impl MutabilityCategory {\n     fn from_local(\n         tcx: TyCtxt<'_>,\n         tables: &ty::TypeckTables<'_>,\n-        id: ast::NodeId,\n+        id: hir::HirId,\n     ) -> MutabilityCategory {\n-        let ret = match tcx.hir().get(id) {\n+        let ret = match tcx.hir().get_by_hir_id(id) {\n             Node::Binding(p) => match p.node {\n                 PatKind::Binding(..) => {\n                     let bm = *tables.pat_binding_modes()\n@@ -500,7 +500,6 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n             // FIXME\n             None if self.is_tainted_by_errors() => Err(()),\n             None => {\n-                let id = self.tcx.hir().hir_to_node_id(id);\n                 bug!(\"no type for node {}: {} in mem_categorization\",\n                      id, self.tcx.hir().node_to_string(id));\n             }\n@@ -753,15 +752,14 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n             }\n \n             Res::Local(var_id) => {\n-                let var_nid = self.tcx.hir().hir_to_node_id(var_id);\n                 if self.upvars.map_or(false, |upvars| upvars.contains_key(&var_id)) {\n-                    self.cat_upvar(hir_id, span, var_nid)\n+                    self.cat_upvar(hir_id, span, var_id)\n                 } else {\n                     Ok(cmt_ {\n                         hir_id,\n                         span,\n                         cat: Categorization::Local(var_id),\n-                        mutbl: MutabilityCategory::from_local(self.tcx, self.tables, var_nid),\n+                        mutbl: MutabilityCategory::from_local(self.tcx, self.tables, var_id),\n                         ty: expr_ty,\n                         note: NoteNone\n                     })\n@@ -778,7 +776,7 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n         &self,\n         hir_id: hir::HirId,\n         span: Span,\n-        var_id: ast::NodeId,\n+        var_id: hir::HirId,\n     ) -> McResult<cmt_<'tcx>> {\n         // An upvar can have up to 3 components. We translate first to a\n         // `Categorization::Upvar`, which is itself a fiction -- it represents the reference to the\n@@ -828,13 +826,12 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n             _ => span_bug!(span, \"unexpected type for fn in mem_categorization: {:?}\", ty),\n         };\n \n-        let var_hir_id = self.tcx.hir().node_to_hir_id(var_id);\n         let upvar_id = ty::UpvarId {\n-            var_path: ty::UpvarPath { hir_id: var_hir_id },\n+            var_path: ty::UpvarPath { hir_id: var_id },\n             closure_expr_id: closure_expr_def_id.to_local(),\n         };\n \n-        let var_ty = self.node_ty(var_hir_id)?;\n+        let var_ty = self.node_ty(var_id)?;\n \n         // Mutability of original variable itself\n         let var_mutbl = MutabilityCategory::from_local(self.tcx, self.tables, var_id);"}, {"sha": "628a44cbfe01fa7b3c0cadb5a0d2b4c89735aec5", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f", "patch": "@@ -174,12 +174,12 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n                         } else {\n                             let impl_did = self.tcx\n                                                .hir()\n-                                               .get_parent_did_by_hir_id(hir_id);\n+                                               .get_parent_did(hir_id);\n                             // Check the impl. If the generics on the self\n                             // type of the impl require inlining, this method\n                             // does too.\n                             let impl_hir_id = self.tcx.hir().as_local_hir_id(impl_did).unwrap();\n-                            match self.tcx.hir().expect_item_by_hir_id(impl_hir_id).node {\n+                            match self.tcx.hir().expect_item(impl_hir_id).node {\n                                 hir::ItemKind::Impl(..) => {\n                                     let generics = self.tcx.generics_of(impl_did);\n                                     generics.requires_monomorphization(self.tcx)\n@@ -296,7 +296,7 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n                         self.visit_nested_body(body);\n                     }\n                     hir::ImplItemKind::Method(_, body) => {\n-                        let did = self.tcx.hir().get_parent_did_by_hir_id(search_item);\n+                        let did = self.tcx.hir().get_parent_did(search_item);\n                         if method_might_be_inlined(self.tcx, impl_item, did) {\n                             self.visit_nested_body(body)\n                         }\n@@ -318,7 +318,7 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n             _ => {\n                 bug!(\n                     \"found unexpected node kind in worklist: {} ({:?})\",\n-                    self.tcx.hir().hir_to_string(search_item),\n+                    self.tcx.hir().node_to_string(search_item),\n                     node,\n                 );\n             }"}, {"sha": "dfab8e36bf9d1a4ac963b9b18fbe0d6fda6e9f54", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f", "patch": "@@ -14,7 +14,6 @@ use std::mem;\n use std::fmt;\n use rustc_macros::HashStable;\n use syntax::source_map;\n-use syntax::ast;\n use syntax_pos::{Span, DUMMY_SP};\n use crate::ty::{DefIdTree, TyCtxt};\n use crate::ty::query::Providers;\n@@ -169,29 +168,29 @@ impl Scope {\n         self.id\n     }\n \n-    pub fn node_id(&self, tcx: TyCtxt<'_>, scope_tree: &ScopeTree) -> ast::NodeId {\n+    pub fn hir_id(&self, scope_tree: &ScopeTree) -> hir::HirId {\n         match scope_tree.root_body {\n             Some(hir_id) => {\n-                tcx.hir().hir_to_node_id(hir::HirId {\n+                hir::HirId {\n                     owner: hir_id.owner,\n                     local_id: self.item_local_id()\n-                })\n+                }\n             }\n-            None => ast::DUMMY_NODE_ID\n+            None => hir::DUMMY_HIR_ID\n         }\n     }\n \n     /// Returns the span of this `Scope`. Note that in general the\n     /// returned span may not correspond to the span of any `NodeId` in\n     /// the AST.\n     pub fn span(&self, tcx: TyCtxt<'_>, scope_tree: &ScopeTree) -> Span {\n-        let node_id = self.node_id(tcx, scope_tree);\n-        if node_id == ast::DUMMY_NODE_ID {\n+        let hir_id = self.hir_id(scope_tree);\n+        if hir_id == hir::DUMMY_HIR_ID {\n             return DUMMY_SP;\n         }\n-        let span = tcx.hir().span(node_id);\n+        let span = tcx.hir().span(hir_id);\n         if let ScopeData::Remainder(first_statement_index) = self.data {\n-            if let Node::Block(ref blk) = tcx.hir().get(node_id) {\n+            if let Node::Block(ref blk) = tcx.hir().get_by_hir_id(hir_id) {\n                 // Want span for scope starting after the\n                 // indexed statement and ending at end of\n                 // `blk`; reuse span of `blk` and shift `lo`\n@@ -650,7 +649,7 @@ impl<'tcx> ScopeTree {\n         let param_owner = tcx.parent(br.def_id).unwrap();\n \n         let param_owner_id = tcx.hir().as_local_hir_id(param_owner).unwrap();\n-        let scope = tcx.hir().maybe_body_owned_by_by_hir_id(param_owner_id).map(|body_id| {\n+        let scope = tcx.hir().maybe_body_owned_by(param_owner_id).map(|body_id| {\n             tcx.hir().body(body_id).value.hir_id.local_id\n         }).unwrap_or_else(|| {\n             // The lifetime was defined on node that doesn't own a body,\n@@ -1337,7 +1336,7 @@ fn region_scope_tree<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> &'tcx ScopeTree\n     }\n \n     let id = tcx.hir().as_local_hir_id(def_id).unwrap();\n-    let scope_tree = if let Some(body_id) = tcx.hir().maybe_body_owned_by_by_hir_id(id) {\n+    let scope_tree = if let Some(body_id) = tcx.hir().maybe_body_owned_by(id) {\n         let mut visitor = RegionResolutionVisitor {\n             tcx,\n             scope_tree: ScopeTree::default(),"}, {"sha": "76bff500634a91fdead737b81c8135536ea16133", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f", "patch": "@@ -625,7 +625,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                 // `abstract type MyAnonTy<'b>: MyTrait<'b>;`\n                 //                          ^            ^ this gets resolved in the scope of\n                 //                                         the exist_ty generics\n-                let (generics, bounds) = match self.tcx.hir().expect_item_by_hir_id(item_id.id).node\n+                let (generics, bounds) = match self.tcx.hir().expect_item(item_id.id).node\n                 {\n                     // named existential types are reached via TyKind::Path\n                     // this arm is for `impl Trait` in the types of statics, constants and locals\n@@ -1236,7 +1236,7 @@ fn extract_labels(ctxt: &mut LifetimeContext<'_, '_>, body: &hir::Body) {\n                         signal_shadowing_problem(\n                             tcx,\n                             label.name,\n-                            original_lifetime(tcx.hir().span_by_hir_id(hir_id)),\n+                            original_lifetime(tcx.hir().span(hir_id)),\n                             shadower_label(label.span),\n                         );\n                         return;\n@@ -1590,7 +1590,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                             if let Some(parent_hir_id) = self.tcx.hir()\n                                 .as_local_hir_id(parent_def_id) {\n                                     // lifetimes in `derive` expansions don't count (Issue #53738)\n-                                    if self.tcx.hir().attrs_by_hir_id(parent_hir_id).iter()\n+                                    if self.tcx.hir().attrs(parent_hir_id).iter()\n                                         .any(|attr| attr.check_name(sym::automatically_derived)) {\n                                             continue;\n                                         }\n@@ -1690,7 +1690,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         // Find the start of nested early scopes, e.g., in methods.\n         let mut index = 0;\n         if let Some(parent_id) = parent_id {\n-            let parent = self.tcx.hir().expect_item_by_hir_id(parent_id);\n+            let parent = self.tcx.hir().expect_item(parent_id);\n             if sub_items_have_self_param(&parent.node) {\n                 index += 1; // Self comes before lifetimes\n             }\n@@ -1823,7 +1823,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                 // Do not free early-bound regions, only late-bound ones.\n             } else if let Some(body_id) = outermost_body {\n                 let fn_id = self.tcx.hir().body_owner(body_id);\n-                match self.tcx.hir().get(fn_id) {\n+                match self.tcx.hir().get_by_hir_id(fn_id) {\n                     Node::Item(&hir::Item {\n                         node: hir::ItemKind::Fn(..),\n                         ..\n@@ -1836,7 +1836,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                         node: hir::ImplItemKind::Method(..),\n                         ..\n                     }) => {\n-                        let scope = self.tcx.hir().local_def_id(fn_id);\n+                        let scope = self.tcx.hir().local_def_id_from_hir_id(fn_id);\n                         def = Region::Free(scope, def.id().unwrap());\n                     }\n                     _ => {}\n@@ -2065,7 +2065,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n             }) => {\n                 if let hir::ItemKind::Trait(.., ref trait_items) = self.tcx\n                     .hir()\n-                    .expect_item_by_hir_id(self.tcx.hir().get_parent_item(parent))\n+                    .expect_item(self.tcx.hir().get_parent_item(parent))\n                     .node\n                 {\n                     assoc_item_kind = trait_items\n@@ -2085,7 +2085,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n             }) => {\n                 if let hir::ItemKind::Impl(.., ref self_ty, ref impl_items) = self.tcx\n                     .hir()\n-                    .expect_item_by_hir_id(self.tcx.hir().get_parent_item(parent))\n+                    .expect_item(self.tcx.hir().get_parent_item(parent))\n                     .node\n                 {\n                     impl_self = Some(self_ty);\n@@ -2629,7 +2629,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                         signal_shadowing_problem(\n                             self.tcx,\n                             param.name.ident().name,\n-                            original_lifetime(self.tcx.hir().span_by_hir_id(hir_id)),\n+                            original_lifetime(self.tcx.hir().span(hir_id)),\n                             shadower_lifetime(&param),\n                         );\n                         return;\n@@ -2696,7 +2696,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n \n         debug!(\n             \"insert_lifetime: {} resolved to {:?} span={:?}\",\n-            self.tcx.hir().hir_to_string(lifetime_ref.hir_id),\n+            self.tcx.hir().node_to_string(lifetime_ref.hir_id),\n             def,\n             self.tcx.sess.source_map().span_to_string(lifetime_ref.span)\n         );"}, {"sha": "1d5c1cb927d280764f6c090dbf9890ee15160504", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f", "patch": "@@ -2565,7 +2565,7 @@ impl<'tcx> Debug for Rvalue<'tcx> {\n                             let name = if tcx.sess.opts.debugging_opts.span_free_formats {\n                                 format!(\"[closure@{:?}]\", hir_id)\n                             } else {\n-                                format!(\"[closure@{:?}]\", tcx.hir().span_by_hir_id(hir_id))\n+                                format!(\"[closure@{:?}]\", tcx.hir().span(hir_id))\n                             };\n                             let mut struct_fmt = fmt.debug_struct(&name);\n \n@@ -2585,7 +2585,7 @@ impl<'tcx> Debug for Rvalue<'tcx> {\n                     AggregateKind::Generator(def_id, _, _) => ty::tls::with(|tcx| {\n                         if let Some(hir_id) = tcx.hir().as_local_hir_id(def_id) {\n                             let name = format!(\"[generator@{:?}]\",\n-                                               tcx.hir().span_by_hir_id(hir_id));\n+                                               tcx.hir().span(hir_id));\n                             let mut struct_fmt = fmt.debug_struct(&name);\n \n                             if let Some(upvars) = tcx.upvars(def_id) {"}, {"sha": "432a61de6cb984cc46ae500c4bd520d53d3877fb", "filename": "src/librustc/mir/mono.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f/src%2Flibrustc%2Fmir%2Fmono.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f/src%2Flibrustc%2Fmir%2Fmono.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmono.rs?ref=9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f", "patch": "@@ -218,7 +218,7 @@ impl<'tcx> MonoItem<'tcx> {\n             MonoItem::GlobalAsm(hir_id) => {\n                 Some(hir_id)\n             }\n-        }.map(|hir_id| tcx.hir().span_by_hir_id(hir_id))\n+        }.map(|hir_id| tcx.hir().span(hir_id))\n     }\n }\n "}, {"sha": "dcf69fee0e16d30d0ee17333d7501e174c36796b", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f", "patch": "@@ -1013,10 +1013,8 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         trait_ref: &ty::Binder<ty::TraitRef<'tcx>>,\n     ) {\n         let hir = self.tcx.hir();\n-        let parent_node = hir.get_parent_node(\n-            hir.hir_to_node_id(obligation.cause.body_id),\n-        );\n-        let node = hir.find(parent_node);\n+        let parent_node = hir.get_parent_node_by_hir_id(obligation.cause.body_id);\n+        let node = hir.find_by_hir_id(parent_node);\n         if let Some(hir::Node::Item(hir::Item {\n             node: hir::ItemKind::Fn(decl, _, _, body_id),\n             ..\n@@ -1098,7 +1096,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             }\n             Node::Ctor(ref variant_data) => {\n                 let span = variant_data.ctor_hir_id()\n-                    .map(|hir_id| self.tcx.hir().span_by_hir_id(hir_id))\n+                    .map(|hir_id| self.tcx.hir().span(hir_id))\n                     .unwrap_or(DUMMY_SP);\n                 let span = self.tcx.sess.source_map().def_span(span);\n "}, {"sha": "2d295679be32406c2eac5c67dc8b418d8d8045cf", "filename": "src/librustc/traits/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f/src%2Flibrustc%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f/src%2Flibrustc%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Futil.rs?ref=9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f", "patch": "@@ -654,7 +654,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     pub fn impl_is_default(self, node_item_def_id: DefId) -> bool {\n         match self.hir().as_local_hir_id(node_item_def_id) {\n             Some(hir_id) => {\n-                let item = self.hir().expect_item_by_hir_id(hir_id);\n+                let item = self.hir().expect_item(hir_id);\n                 if let hir::ItemKind::Impl(_, _, defaultness, ..) = item.node {\n                     defaultness.is_default()\n                 } else {"}, {"sha": "b84ebd8afe8852bfdff20a09ef7ab7bd07dd8e96", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f", "patch": "@@ -250,11 +250,9 @@ fn validate_hir_id_for_typeck_tables(local_id_root: Option<DefId>,\n         if let Some(local_id_root) = local_id_root {\n             if hir_id.owner != local_id_root.index {\n                 ty::tls::with(|tcx| {\n-                    let node_id = tcx.hir().hir_to_node_id(hir_id);\n-\n                     bug!(\"node {} with HirId::owner {:?} cannot be placed in \\\n                           TypeckTables with local_id_root {:?}\",\n-                         tcx.hir().node_to_string(node_id),\n+                         tcx.hir().node_to_string(hir_id),\n                          DefId::local(hir_id.owner),\n                          local_id_root)\n                 });\n@@ -556,7 +554,7 @@ impl<'tcx> TypeckTables<'tcx> {\n     pub fn node_type(&self, id: hir::HirId) -> Ty<'tcx> {\n         self.node_type_opt(id).unwrap_or_else(||\n             bug!(\"node_type: no type for node `{}`\",\n-                 tls::with(|tcx| tcx.hir().hir_to_string(id)))\n+                 tls::with(|tcx| tcx.hir().node_to_string(id)))\n         )\n     }\n "}, {"sha": "361410380e8f8ad52b4e738ab9ae31c9b7d14ab1", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f", "patch": "@@ -277,7 +277,7 @@ impl Visibility {\n                 def => Visibility::Restricted(def.def_id()),\n             },\n             hir::VisibilityKind::Inherited => {\n-                Visibility::Restricted(tcx.hir().get_module_parent_by_hir_id(id))\n+                Visibility::Restricted(tcx.hir().get_module_parent(id))\n             }\n         }\n     }\n@@ -3016,7 +3016,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     /// Gets the attributes of a definition.\n     pub fn get_attrs(self, did: DefId) -> Attributes<'tcx> {\n         if let Some(id) = self.hir().as_local_hir_id(did) {\n-            Attributes::Borrowed(self.hir().attrs_by_hir_id(id))\n+            Attributes::Borrowed(self.hir().attrs(id))\n         } else {\n             Attributes::Owned(self.item_attrs(did))\n         }\n@@ -3068,7 +3068,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     pub fn span_of_impl(self, impl_did: DefId) -> Result<Span, Symbol> {\n         if impl_did.is_local() {\n             let hir_id = self.hir().as_local_hir_id(impl_did).unwrap();\n-            Ok(self.hir().span_by_hir_id(hir_id))\n+            Ok(self.hir().span(hir_id))\n         } else {\n             Err(self.crate_name(impl_did.krate))\n         }\n@@ -3103,7 +3103,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         let scope = match ident.span.modernize_and_adjust(self.expansion_that_defined(scope)) {\n             Some(actual_expansion) =>\n                 self.hir().definitions().parent_module_of_macro_def(actual_expansion),\n-            None => self.hir().get_module_parent_by_hir_id(block),\n+            None => self.hir().get_module_parent(block),\n         };\n         (ident, scope)\n     }\n@@ -3129,7 +3129,7 @@ fn associated_item<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> AssocItem {\n     let id = tcx.hir().as_local_hir_id(def_id).unwrap();\n     let parent_id = tcx.hir().get_parent_item(id);\n     let parent_def_id = tcx.hir().local_def_id_from_hir_id(parent_id);\n-    let parent_item = tcx.hir().expect_item_by_hir_id(parent_id);\n+    let parent_item = tcx.hir().expect_item(parent_id);\n     match parent_item.node {\n         hir::ItemKind::Impl(.., ref impl_item_refs) => {\n             if let Some(impl_item_ref) = impl_item_refs.iter().find(|i| i.id.hir_id == id) {\n@@ -3186,7 +3186,7 @@ fn adt_sized_constraint<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> AdtSizedConst\n \n fn associated_item_def_ids<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> &'tcx [DefId] {\n     let id = tcx.hir().as_local_hir_id(def_id).unwrap();\n-    let item = tcx.hir().expect_item_by_hir_id(id);\n+    let item = tcx.hir().expect_item(id);\n     match item.node {\n         hir::ItemKind::Trait(.., ref trait_item_refs) => {\n             tcx.arena.alloc_from_iter(\n@@ -3266,7 +3266,7 @@ fn param_env<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> ParamEnv<'tcx> {\n     );\n \n     let body_id = tcx.hir().as_local_hir_id(def_id).map_or(hir::DUMMY_HIR_ID, |id| {\n-        tcx.hir().maybe_body_owned_by_by_hir_id(id).map_or(id, |body| body.hir_id)\n+        tcx.hir().maybe_body_owned_by(id).map_or(id, |body| body.hir_id)\n     });\n     let cause = traits::ObligationCause::misc(tcx.def_span(def_id), body_id);\n     traits::normalize_param_env_or_error(tcx, def_id, unnormalized_env, cause)"}, {"sha": "d143cc3e6092d00331c829ccc078698361eaf733", "filename": "src/librustc/ty/print/pretty.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs?ref=9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f", "patch": "@@ -589,7 +589,7 @@ pub trait PrettyPrinter<'tcx>:\n \n                 // FIXME(eddyb) should use `def_span`.\n                 if let Some(hir_id) = self.tcx().hir().as_local_hir_id(did) {\n-                    p!(write(\"@{:?}\", self.tcx().hir().span_by_hir_id(hir_id)));\n+                    p!(write(\"@{:?}\", self.tcx().hir().span(hir_id)));\n                     let mut sep = \" \";\n                     for (&var_id, upvar_ty) in self.tcx().upvars(did)\n                         .as_ref()\n@@ -631,7 +631,7 @@ pub trait PrettyPrinter<'tcx>:\n                     if self.tcx().sess.opts.debugging_opts.span_free_formats {\n                         p!(write(\"@{:?}\", hir_id));\n                     } else {\n-                        p!(write(\"@{:?}\", self.tcx().hir().span_by_hir_id(hir_id)));\n+                        p!(write(\"@{:?}\", self.tcx().hir().span(hir_id)));\n                     }\n                     let mut sep = \" \";\n                     for (&var_id, upvar_ty) in self.tcx().upvars(did)"}, {"sha": "58be2cf76c72438ee3a373d24d11ca23b00f5b33", "filename": "src/librustc_borrowck/borrowck/gather_loans/move_error.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs?ref=9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f", "patch": "@@ -88,7 +88,7 @@ fn report_move_errors<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>, errors: &[MoveErr\n             }\n         }\n         if let NoteClosureEnv(upvar_id) = error.move_from.note {\n-            err.span_label(bccx.tcx.hir().span_by_hir_id(upvar_id.var_path.hir_id),\n+            err.span_label(bccx.tcx.hir().span(upvar_id.var_path.hir_id),\n                            \"captured outer variable\");\n         }\n         err.emit();"}, {"sha": "93cea6d2f019fcf02f80b921c7cae75c579fcdae", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 17, "deletions": 20, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f", "patch": "@@ -198,7 +198,7 @@ pub fn build_borrowck_dataflow_data_for_fn<'a, 'tcx>(\n     cfg: &cfg::CFG,\n ) -> (BorrowckCtxt<'a, 'tcx>, AnalysisData<'tcx>) {\n     let owner_id = tcx.hir().body_owner(body_id);\n-    let owner_def_id = tcx.hir().local_def_id(owner_id);\n+    let owner_def_id = tcx.hir().local_def_id_from_hir_id(owner_id);\n     let tables = tcx.typeck_tables_of(owner_def_id);\n     let region_scope_tree = tcx.region_scope_tree(owner_def_id);\n     let body = tcx.hir().body(body_id);\n@@ -389,8 +389,8 @@ pub enum LoanPathElem<'tcx> {\n }\n \n fn closure_to_block(closure_id: LocalDefId, tcx: TyCtxt<'_>) -> HirId {\n-    let closure_id = tcx.hir().local_def_id_to_node_id(closure_id);\n-    match tcx.hir().get(closure_id) {\n+    let closure_id = tcx.hir().local_def_id_to_hir_id(closure_id);\n+    match tcx.hir().get_by_hir_id(closure_id) {\n         Node::Expr(expr) => match expr.node {\n             hir::ExprKind::Closure(.., body_id, _, _) => {\n                 body_id.hir_id\n@@ -699,7 +699,7 @@ impl BorrowckCtxt<'_, 'tcx> {\n             }\n \n             move_data::MoveExpr |\n-            move_data::MovePat => (self.tcx.hir().span_by_hir_id(hir_id), \"\"),\n+            move_data::MovePat => (self.tcx.hir().span(hir_id), \"\"),\n \n             move_data::Captured =>\n                 (match self.tcx.hir().expect_expr_by_hir_id(hir_id).node {\n@@ -828,7 +828,7 @@ impl BorrowckCtxt<'_, 'tcx> {\n                         let mut db = self.cannot_assign(error_span, &descr, Origin::Ast);\n                         if let mc::NoteClosureEnv(upvar_id) = err.cmt.note {\n                             let hir_id = upvar_id.var_path.hir_id;\n-                            let sp = self.tcx.hir().span_by_hir_id(hir_id);\n+                            let sp = self.tcx.hir().span(hir_id);\n                             let fn_closure_msg = \"`Fn` closures cannot capture their enclosing \\\n                                                   environment for modifications\";\n                             match (self.tcx.sess.source_map().span_to_snippet(sp), &err.cmt.cat) {\n@@ -896,8 +896,7 @@ impl BorrowckCtxt<'_, 'tcx> {\n                 // to implement two traits for \"one operator\" is not very intuitive for\n                 // many programmers.\n                 if err.cmt.note == mc::NoteIndex {\n-                    let node_id = self.tcx.hir().hir_to_node_id(err.cmt.hir_id);\n-                    let node =  self.tcx.hir().get(node_id);\n+                    let node = self.tcx.hir().get_by_hir_id(err.cmt.hir_id);\n \n                     // This pattern probably always matches.\n                     if let Node::Expr(\n@@ -1022,8 +1021,8 @@ impl BorrowckCtxt<'_, 'tcx> {\n                 }\n \n                 if let ty::ReScope(scope) = *super_scope {\n-                    let node_id = scope.node_id(self.tcx, &self.region_scope_tree);\n-                    match self.tcx.hir().find(node_id) {\n+                    let hir_id = scope.hir_id(&self.region_scope_tree);\n+                    match self.tcx.hir().find_by_hir_id(hir_id) {\n                         Some(Node::Stmt(_)) => {\n                             if *sub_scope != ty::ReStatic {\n                                 db.note(\"consider using a `let` binding to increase its lifetime\");\n@@ -1118,7 +1117,7 @@ impl BorrowckCtxt<'_, 'tcx> {\n                     \"consider changing this closure to take self by mutable reference\"\n                 };\n                 let hir_id = self.tcx.hir().local_def_id_to_hir_id(id);\n-                let help_span = self.tcx.hir().span_by_hir_id(hir_id);\n+                let help_span = self.tcx.hir().span(hir_id);\n                 self.cannot_act_on_capture_in_sharable_fn(span,\n                                                           prefix,\n                                                           (help_span, help_msg),\n@@ -1224,7 +1223,7 @@ impl BorrowckCtxt<'_, 'tcx> {\n             Some(ImmutabilityBlame::LocalDeref(hir_id)) => {\n                 match self.local_binding_mode(hir_id) {\n                     ty::BindByReference(..) => {\n-                        let let_span = self.tcx.hir().span_by_hir_id(hir_id);\n+                        let let_span = self.tcx.hir().span(hir_id);\n                         let suggestion = suggest_ref_mut(self.tcx, let_span);\n                         if let Some(replace_str) = suggestion {\n                             db.span_suggestion(\n@@ -1272,7 +1271,7 @@ impl BorrowckCtxt<'_, 'tcx> {\n                             db: &mut DiagnosticBuilder<'_>,\n                             borrowed_hir_id: hir::HirId,\n                             binding_hir_id: hir::HirId) {\n-        let let_span = self.tcx.hir().span_by_hir_id(binding_hir_id);\n+        let let_span = self.tcx.hir().span(binding_hir_id);\n         if let ty::BindByValue(..) = self.local_binding_mode(binding_hir_id) {\n             if let Ok(snippet) = self.tcx.sess.source_map().span_to_snippet(let_span) {\n                 let (ty, is_implicit_self) = self.local_ty(binding_hir_id);\n@@ -1290,7 +1289,7 @@ impl BorrowckCtxt<'_, 'tcx> {\n                 {\n                     let borrow_expr_id = self.tcx.hir().get_parent_node_by_hir_id(borrowed_hir_id);\n                     db.span_suggestion(\n-                        self.tcx.hir().span_by_hir_id(borrow_expr_id),\n+                        self.tcx.hir().span(borrow_expr_id),\n                         \"consider removing the `&mut`, as it is an \\\n                         immutable binding to a mutable reference\",\n                         snippet,\n@@ -1361,7 +1360,7 @@ impl BorrowckCtxt<'_, 'tcx> {\n                 if *kind == ty::ClosureKind::Fn {\n                     let closure_hir_id =\n                         self.tcx.hir().local_def_id_to_hir_id(upvar_id.closure_expr_id);\n-                    db.span_help(self.tcx.hir().span_by_hir_id(closure_hir_id),\n+                    db.span_help(self.tcx.hir().span(closure_hir_id),\n                                  \"consider changing this closure to take \\\n                                   self by mutable reference\");\n                 }\n@@ -1370,7 +1369,7 @@ impl BorrowckCtxt<'_, 'tcx> {\n                 if let Categorization::Deref(..) = err.cmt.cat {\n                     db.span_label(*error_span, \"cannot borrow as mutable\");\n                 } else if let Categorization::Local(local_id) = err.cmt.cat {\n-                    let span = self.tcx.hir().span_by_hir_id(local_id);\n+                    let span = self.tcx.hir().span(local_id);\n                     if let Ok(snippet) = self.tcx.sess.source_map().span_to_snippet(span) {\n                         if snippet.starts_with(\"ref mut \") || snippet.starts_with(\"&mut \") {\n                             db.span_label(*error_span, \"cannot reborrow mutably\");\n@@ -1509,13 +1508,12 @@ impl<'tcx> fmt::Debug for LoanPath<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match self.kind {\n             LpVar(id) => {\n-                write!(f, \"$({})\", ty::tls::with(|tcx| tcx.hir().hir_to_string(id)))\n+                write!(f, \"$({})\", ty::tls::with(|tcx| tcx.hir().node_to_string(id)))\n             }\n \n             LpUpvar(ty::UpvarId{ var_path: ty::UpvarPath {hir_id: var_id}, closure_expr_id }) => {\n                 let s = ty::tls::with(|tcx| {\n-                    let var_node_id = tcx.hir().hir_to_node_id(var_id);\n-                    tcx.hir().node_to_string(var_node_id)\n+                    tcx.hir().node_to_string(var_id)\n                 });\n                 write!(f, \"$({} captured by id={:?})\", s, closure_expr_id)\n             }\n@@ -1549,8 +1547,7 @@ impl<'tcx> fmt::Display for LoanPath<'tcx> {\n \n             LpUpvar(ty::UpvarId{ var_path: ty::UpvarPath { hir_id }, closure_expr_id: _ }) => {\n                 let s = ty::tls::with(|tcx| {\n-                    let var_node_id = tcx.hir().hir_to_node_id(hir_id);\n-                    tcx.hir().node_to_string(var_node_id)\n+                    tcx.hir().node_to_string(hir_id)\n                 });\n                 write!(f, \"$({} captured by closure)\", s)\n             }"}, {"sha": "dc50c0e19efbf5faee4dc33d703009da258365e8", "filename": "src/librustc_codegen_ssa/mono_item.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f/src%2Flibrustc_codegen_ssa%2Fmono_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f/src%2Flibrustc_codegen_ssa%2Fmono_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmono_item.rs?ref=9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f", "patch": "@@ -29,7 +29,7 @@ impl<'a, 'tcx: 'a> MonoItemExt<'a, 'tcx> for MonoItem<'tcx> {\n                 cx.codegen_static(def_id, cx.tcx().is_mutable_static(def_id));\n             }\n             MonoItem::GlobalAsm(hir_id) => {\n-                let item = cx.tcx().hir().expect_item_by_hir_id(hir_id);\n+                let item = cx.tcx().hir().expect_item(hir_id);\n                 if let hir::ItemKind::GlobalAsm(ref ga) = item.node {\n                     cx.codegen_global_asm(ga);\n                 } else {"}, {"sha": "683da5865cda4e8905817bb83c725bf28289960e", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f", "patch": "@@ -922,7 +922,8 @@ fn print_with_analysis<'tcx>(\n                                             got {:?}\",\n                                             node);\n \n-                    tcx.sess.span_fatal(tcx.hir().span(nodeid), &message)\n+                    let hir_id = tcx.hir().node_to_hir_id(nodeid);\n+                    tcx.sess.span_fatal(tcx.hir().span(hir_id), &message)\n                 }\n             }\n         }"}, {"sha": "b221b8ed30c59dc8c2a314636e4ad29fc501b6c4", "filename": "src/librustc_lint/nonstandard_style.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f/src%2Flibrustc_lint%2Fnonstandard_style.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f/src%2Flibrustc_lint%2Fnonstandard_style.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fnonstandard_style.rs?ref=9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f", "patch": "@@ -254,7 +254,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NonSnakeCase {\n         let crate_ident = if let Some(name) = &cx.tcx.sess.opts.crate_name {\n             Some(Ident::from_str(name))\n         } else {\n-            attr::find_by_name(&cx.tcx.hir().attrs_by_hir_id(hir::CRATE_HIR_ID), sym::crate_name)\n+            attr::find_by_name(&cx.tcx.hir().attrs(hir::CRATE_HIR_ID), sym::crate_name)\n                 .and_then(|attr| attr.meta())\n                 .and_then(|meta| {\n                     meta.name_value_literal().and_then(|lit| {"}, {"sha": "9fc23e45d203cab296e5aa26fc385175fc61151d", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f", "patch": "@@ -921,7 +921,7 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ImproperCTypes {\n     fn check_foreign_item(&mut self, cx: &LateContext<'_, '_>, it: &hir::ForeignItem) {\n         let mut vis = ImproperCTypesVisitor { cx };\n-        let abi = cx.tcx.hir().get_foreign_abi_by_hir_id(it.hir_id);\n+        let abi = cx.tcx.hir().get_foreign_abi(it.hir_id);\n         if abi != Abi::RustIntrinsic && abi != Abi::PlatformIntrinsic {\n             match it.node {\n                 hir::ForeignItemKind::Fn(ref decl, _, _) => {"}, {"sha": "f84ce2f015edf3d75b70c32588e51174d59165ba", "filename": "src/librustc_lint/unused.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f/src%2Flibrustc_lint%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f/src%2Flibrustc_lint%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Funused.rs?ref=9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f", "patch": "@@ -136,7 +136,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedResults {\n             descr_post_path: &str,\n         ) -> bool {\n             if ty.is_unit() || cx.tcx.is_ty_uninhabited_from(\n-                cx.tcx.hir().get_module_parent_by_hir_id(expr.hir_id), ty)\n+                cx.tcx.hir().get_module_parent(expr.hir_id), ty)\n             {\n                 return true;\n             }"}, {"sha": "b52b6dfbb5e1229f7f5a9fed2fe59530afbc7826", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f", "patch": "@@ -579,7 +579,7 @@ impl EncodeContext<'tcx> {\n         };\n \n         let enum_id = tcx.hir().as_local_hir_id(enum_did).unwrap();\n-        let enum_vis = &tcx.hir().expect_item_by_hir_id(enum_id).vis;\n+        let enum_vis = &tcx.hir().expect_item(enum_id).vis;\n \n         Entry {\n             kind: EntryKind::Variant(self.lazy(&data)),\n@@ -632,7 +632,7 @@ impl EncodeContext<'tcx> {\n         // Variant constructors have the same visibility as the parent enums, unless marked as\n         // non-exhaustive, in which case they are lowered to `pub(crate)`.\n         let enum_id = tcx.hir().as_local_hir_id(enum_did).unwrap();\n-        let enum_vis = &tcx.hir().expect_item_by_hir_id(enum_id).vis;\n+        let enum_vis = &tcx.hir().expect_item(enum_id).vis;\n         let mut ctor_vis = ty::Visibility::from_hir(enum_vis, enum_id, tcx);\n         if variant.is_field_list_non_exhaustive() && ctor_vis == ty::Visibility::Public {\n             ctor_vis = ty::Visibility::Restricted(DefId::local(CRATE_DEF_INDEX));\n@@ -751,7 +751,7 @@ impl EncodeContext<'tcx> {\n         };\n \n         let struct_id = tcx.hir().as_local_hir_id(adt_def_id).unwrap();\n-        let struct_vis = &tcx.hir().expect_item_by_hir_id(struct_id).vis;\n+        let struct_vis = &tcx.hir().expect_item(struct_id).vis;\n         let mut ctor_vis = ty::Visibility::from_hir(struct_vis, struct_id, tcx);\n         for field in &variant.fields {\n             if ctor_vis.is_at_least(field.vis, tcx) {"}, {"sha": "c4a11efe5bce43a215e62fbca7295006cbba2305", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f", "patch": "@@ -177,7 +177,7 @@ fn do_mir_borrowck<'a, 'tcx>(\n         |bd, i| DebugFormatted::new(&bd.move_data().move_paths[i]),\n     ));\n \n-    let locals_are_invalidated_at_exit = tcx.hir().body_owner_kind_by_hir_id(id).is_fn_or_closure();\n+    let locals_are_invalidated_at_exit = tcx.hir().body_owner_kind(id).is_fn_or_closure();\n     let borrow_set = Rc::new(BorrowSet::build(\n             tcx, body, locals_are_invalidated_at_exit, &mdpe.move_data));\n "}, {"sha": "d15229367251ae3befe6173a30c808ebae1934b1", "filename": "src/librustc_mir/borrow_check/move_errors.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f/src%2Flibrustc_mir%2Fborrow_check%2Fmove_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f/src%2Flibrustc_mir%2Fborrow_check%2Fmove_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmove_errors.rs?ref=9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f", "patch": "@@ -422,7 +422,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                 let upvar = &self.upvars[upvar_field.unwrap().index()];\n                 let upvar_hir_id = upvar.var_hir_id;\n                 let upvar_name = upvar.name;\n-                let upvar_span = self.infcx.tcx.hir().span_by_hir_id(upvar_hir_id);\n+                let upvar_span = self.infcx.tcx.hir().span(upvar_hir_id);\n \n                 let place_name = self.describe_place(move_place).unwrap();\n "}, {"sha": "fc11cd82f8a9aabd7f1e17d41f9d7b6d7cdddb48", "filename": "src/librustc_mir/borrow_check/mutability_errors.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs?ref=9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f", "patch": "@@ -304,8 +304,8 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                 err.span_label(span, format!(\"cannot {ACT}\", ACT = act));\n \n                 let upvar_hir_id = self.upvars[upvar_index.index()].var_hir_id;\n-                let upvar_node_id = self.infcx.tcx.hir().hir_to_node_id(upvar_hir_id);\n-                if let Some(Node::Binding(pat)) = self.infcx.tcx.hir().find(upvar_node_id) {\n+                if let Some(Node::Binding(pat)) = self.infcx.tcx.hir().find_by_hir_id(upvar_hir_id)\n+                {\n                     if let hir::PatKind::Binding(\n                         hir::BindingAnnotation::Unannotated,\n                         _,"}, {"sha": "46b690129ea259d9b4e077b95bc482c58aa9cee6", "filename": "src/librustc_mir/borrow_check/nll/region_infer/error_reporting/region_name.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fregion_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fregion_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fregion_name.rs?ref=9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f", "patch": "@@ -230,14 +230,14 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                 },\n \n                 ty::BoundRegion::BrEnv => {\n-                    let mir_node_id = tcx.hir()\n-                                         .as_local_node_id(mir_def_id)\n-                                         .expect(\"non-local mir\");\n+                    let mir_hir_id = tcx.hir()\n+                                        .as_local_hir_id(mir_def_id)\n+                                        .expect(\"non-local mir\");\n                     let def_ty = self.universal_regions.defining_ty;\n \n                     if let DefiningTy::Closure(def_id, substs) = def_ty {\n                         let args_span = if let hir::ExprKind::Closure(_, _, _, span, _) =\n-                            tcx.hir().expect_expr(mir_node_id).node\n+                            tcx.hir().expect_expr_by_hir_id(mir_hir_id).node\n                         {\n                             span\n                         } else {\n@@ -310,7 +310,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         let scope = error_region.free_region_binding_scope(tcx);\n         let node = tcx.hir().as_local_hir_id(scope).unwrap_or(hir::DUMMY_HIR_ID);\n \n-        let span = tcx.sess.source_map().def_span(tcx.hir().span_by_hir_id(node));\n+        let span = tcx.sess.source_map().def_span(tcx.hir().span(node));\n         if let Some(param) = tcx.hir()\n             .get_generics(scope)\n             .and_then(|generics| generics.get_named(name))\n@@ -367,8 +367,8 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         argument_index: usize,\n         counter: &mut usize,\n     ) -> Option<RegionName> {\n-        let mir_node_id = infcx.tcx.hir().as_local_node_id(mir_def_id)?;\n-        let fn_decl = infcx.tcx.hir().fn_decl(mir_node_id)?;\n+        let mir_hir_id = infcx.tcx.hir().as_local_hir_id(mir_def_id)?;\n+        let fn_decl = infcx.tcx.hir().fn_decl_by_hir_id(mir_hir_id)?;\n         let argument_hir_ty: &hir::Ty = &fn_decl.inputs[argument_index];\n         match argument_hir_ty.node {\n             // This indicates a variable with no type annotation, like\n@@ -696,9 +696,9 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         highlight.highlighting_region_vid(fr, *counter);\n         let type_name = infcx.extract_type_name(&return_ty, Some(highlight));\n \n-        let mir_node_id = tcx.hir().as_local_node_id(mir_def_id).expect(\"non-local mir\");\n+        let mir_hir_id = tcx.hir().as_local_hir_id(mir_def_id).expect(\"non-local mir\");\n \n-        let (return_span, mir_description) = match tcx.hir().get(mir_node_id) {\n+        let (return_span, mir_description) = match tcx.hir().get_by_hir_id(mir_hir_id) {\n             hir::Node::Expr(hir::Expr {\n                 node: hir::ExprKind::Closure(_, return_ty, _, span, gen_move),\n                 ..\n@@ -759,9 +759,9 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         highlight.highlighting_region_vid(fr, *counter);\n         let type_name = infcx.extract_type_name(&yield_ty, Some(highlight));\n \n-        let mir_node_id = tcx.hir().as_local_node_id(mir_def_id).expect(\"non-local mir\");\n+        let mir_hir_id = tcx.hir().as_local_hir_id(mir_def_id).expect(\"non-local mir\");\n \n-        let yield_span = match tcx.hir().get(mir_node_id) {\n+        let yield_span = match tcx.hir().get_by_hir_id(mir_hir_id) {\n             hir::Node::Expr(hir::Expr {\n                 node: hir::ExprKind::Closure(_, _, _, span, _),\n                 .."}, {"sha": "59fc4113794a45ff8ecbaa0d68d221f768a60f19", "filename": "src/librustc_mir/borrow_check/nll/region_infer/error_reporting/var_name.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fvar_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fvar_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fvar_name.rs?ref=9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f", "patch": "@@ -73,7 +73,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         debug!(\"get_upvar_name_and_span_for_region: upvar_hir_id={:?}\", upvar_hir_id);\n \n         let upvar_name = tcx.hir().name_by_hir_id(upvar_hir_id);\n-        let upvar_span = tcx.hir().span_by_hir_id(upvar_hir_id);\n+        let upvar_span = tcx.hir().span(upvar_hir_id);\n         debug!(\"get_upvar_name_and_span_for_region: upvar_name={:?} upvar_span={:?}\",\n                upvar_name, upvar_span);\n "}, {"sha": "a236359f1d4313627f7f8b422d09a7cf37be72e9", "filename": "src/librustc_mir/borrow_check/nll/universal_regions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Funiversal_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Funiversal_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Funiversal_regions.rs?ref=9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f", "patch": "@@ -471,7 +471,7 @@ impl<'cx, 'tcx> UniversalRegionsBuilder<'cx, 'tcx> {\n         let tcx = self.infcx.tcx;\n         let closure_base_def_id = tcx.closure_base_def_id(self.mir_def_id);\n \n-        match tcx.hir().body_owner_kind_by_hir_id(self.mir_hir_id) {\n+        match tcx.hir().body_owner_kind(self.mir_hir_id) {\n             BodyOwnerKind::Closure |\n             BodyOwnerKind::Fn => {\n                 let defining_ty = if self.mir_def_id == closure_base_def_id {"}, {"sha": "a0e45caeb6b3bf6a3991a56a530a2150d43330fd", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f", "patch": "@@ -55,10 +55,10 @@ pub fn mir_build<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> Body<'tcx> {\n             (*body_id, ty.span)\n         }\n         Node::AnonConst(hir::AnonConst { body, hir_id, .. }) => {\n-            (*body, tcx.hir().span_by_hir_id(*hir_id))\n+            (*body, tcx.hir().span(*hir_id))\n         }\n \n-        _ => span_bug!(tcx.hir().span_by_hir_id(id), \"can't build MIR for {:?}\", def_id),\n+        _ => span_bug!(tcx.hir().span(id), \"can't build MIR for {:?}\", def_id),\n     };\n \n     tcx.infer_ctxt().enter(|infcx| {\n@@ -101,9 +101,9 @@ pub fn mir_build<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> Body<'tcx> {\n                         let owner_id = tcx.hir().body_owner(body_id);\n                         let opt_ty_info;\n                         let self_arg;\n-                        if let Some(ref fn_decl) = tcx.hir().fn_decl(owner_id) {\n+                        if let Some(ref fn_decl) = tcx.hir().fn_decl_by_hir_id(owner_id) {\n                             let ty_hir_id = fn_decl.inputs[index].hir_id;\n-                            let ty_span = tcx.hir().span_by_hir_id(ty_hir_id);\n+                            let ty_span = tcx.hir().span(ty_hir_id);\n                             opt_ty_info = Some(ty_span);\n                             self_arg = if index == 0 && fn_decl.implicit_self.has_implicit_self() {\n                                 match fn_decl.implicit_self {\n@@ -131,7 +131,7 @@ pub fn mir_build<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> Body<'tcx> {\n                     ty::Generator(gen_def_id, gen_substs, ..) =>\n                         gen_substs.sig(gen_def_id, tcx),\n                     _ =>\n-                        span_bug!(tcx.hir().span_by_hir_id(id),\n+                        span_bug!(tcx.hir().span(id),\n                                   \"generator w/o generator type: {:?}\", ty),\n                 };\n                 (Some(gen_sig.yield_ty), gen_sig.return_ty)\n@@ -535,7 +535,7 @@ where\n \n     let tcx = hir.tcx();\n     let tcx_hir = tcx.hir();\n-    let span = tcx_hir.span_by_hir_id(fn_id);\n+    let span = tcx_hir.span(fn_id);\n \n     let hir_tables = hir.tables();\n     let fn_def_id = tcx_hir.local_def_id_from_hir_id(fn_id);"}, {"sha": "d5932052d1aa3365731b5b63bf2e20217531107c", "filename": "src/librustc_mir/hair/cx/block.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs?ref=9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f", "patch": "@@ -49,7 +49,7 @@ fn mirror_stmts<'a, 'tcx>(\n     for (index, stmt) in stmts.iter().enumerate() {\n         let hir_id = stmt.hir_id;\n         let opt_dxn_ext = cx.region_scope_tree.opt_destruction_scope(hir_id.local_id);\n-        let stmt_span = StatementSpan(cx.tcx.hir().span_by_hir_id(hir_id));\n+        let stmt_span = StatementSpan(cx.tcx.hir().span(hir_id));\n         match stmt.node {\n             hir::StmtKind::Expr(ref expr) |\n             hir::StmtKind::Semi(ref expr) => {"}, {"sha": "9f05cf981f5178bec7204cf914f925faa8380ad6", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f", "patch": "@@ -908,12 +908,13 @@ fn convert_path_expr<'a, 'tcx>(\n         }\n \n         Res::Def(DefKind::ConstParam, def_id) => {\n-            let node_id = cx.tcx.hir().as_local_node_id(def_id).unwrap();\n-            let item_id = cx.tcx.hir().get_parent_node(node_id);\n-            let item_def_id = cx.tcx.hir().local_def_id(item_id);\n+            let hir_id = cx.tcx.hir().as_local_hir_id(def_id).unwrap();\n+            let item_id = cx.tcx.hir().get_parent_node_by_hir_id(hir_id);\n+            let item_def_id = cx.tcx.hir().local_def_id_from_hir_id(item_id);\n             let generics = cx.tcx.generics_of(item_def_id);\n-            let index = generics.param_def_id_to_index[&cx.tcx.hir().local_def_id(node_id)];\n-            let name = cx.tcx.hir().name(node_id).as_interned_str();\n+            let local_def_id = cx.tcx.hir().local_def_id_from_hir_id(hir_id);\n+            let index = generics.param_def_id_to_index[&local_def_id];\n+            let name = cx.tcx.hir().name_by_hir_id(hir_id).as_interned_str();\n             let val = ConstValue::Param(ty::ParamConst::new(index, name));\n             ExprKind::Literal {\n                 literal: cx.tcx.mk_const("}, {"sha": "ff53cf02d8d15b8b77e5d2d10181f1cecfd7dd25", "filename": "src/librustc_mir/hair/cx/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs?ref=9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f", "patch": "@@ -56,7 +56,7 @@ impl<'a, 'tcx> Cx<'a, 'tcx> {\n         let tcx = infcx.tcx;\n         let src_def_id = tcx.hir().local_def_id_from_hir_id(src_id);\n         let tables = tcx.typeck_tables_of(src_def_id);\n-        let body_owner_kind = tcx.hir().body_owner_kind_by_hir_id(src_id);\n+        let body_owner_kind = tcx.hir().body_owner_kind(src_id);\n \n         let constness = match body_owner_kind {\n             hir::BodyOwnerKind::Const |\n@@ -65,7 +65,7 @@ impl<'a, 'tcx> Cx<'a, 'tcx> {\n             hir::BodyOwnerKind::Fn => hir::Constness::NotConst,\n         };\n \n-        let attrs = tcx.hir().attrs_by_hir_id(src_id);\n+        let attrs = tcx.hir().attrs(src_id);\n \n         // Some functions always have overflow checks enabled,\n         // however, they may not get codegen'd, depending on"}, {"sha": "159b526bdba654cad82cab7931eaeae872bf286d", "filename": "src/librustc_mir/hair/pattern/check_match.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs?ref=9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f", "patch": "@@ -161,7 +161,7 @@ impl<'a, 'tcx> MatchVisitor<'a, 'tcx> {\n             }\n         }\n \n-        let module = self.tcx.hir().get_module_parent_by_hir_id(scrut.hir_id);\n+        let module = self.tcx.hir().get_module_parent(scrut.hir_id);\n         MatchCheckCtxt::create_and_enter(self.tcx, self.param_env, module, |ref mut cx| {\n             let mut have_errors = false;\n \n@@ -193,7 +193,7 @@ impl<'a, 'tcx> MatchVisitor<'a, 'tcx> {\n             // Then, if the match has no arms, check whether the scrutinee\n             // is uninhabited.\n             let pat_ty = self.tables.node_type(scrut.hir_id);\n-            let module = self.tcx.hir().get_module_parent_by_hir_id(scrut.hir_id);\n+            let module = self.tcx.hir().get_module_parent(scrut.hir_id);\n             let mut def_span = None;\n             let mut missing_variants = vec![];\n             if inlined_arms.is_empty() {\n@@ -261,7 +261,7 @@ impl<'a, 'tcx> MatchVisitor<'a, 'tcx> {\n     }\n \n     fn check_irrefutable(&self, pat: &'tcx Pat, origin: &str) {\n-        let module = self.tcx.hir().get_module_parent_by_hir_id(pat.hir_id);\n+        let module = self.tcx.hir().get_module_parent(pat.hir_id);\n         MatchCheckCtxt::create_and_enter(self.tcx, self.param_env, module, |ref mut cx| {\n             let mut patcx = PatternContext::new(self.tcx,\n                                                 self.param_env.and(self.identity_substs),"}, {"sha": "3460c21b52d034744cba6a52b9ae96c5ffa6f9ea", "filename": "src/librustc_mir/interpret/validity.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs?ref=9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f", "patch": "@@ -175,8 +175,8 @@ impl<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, 'tcx, M\n                         // Sometimes the index is beyond the number of upvars (seen\n                         // for a generator).\n                         if let Some((&var_hir_id, _)) = upvars.get_index(field) {\n-                            let var_node_id = self.ecx.tcx.hir().hir_to_node_id(var_hir_id);\n-                            if let hir::Node::Binding(pat) = self.ecx.tcx.hir().get(var_node_id) {\n+                            let node = self.ecx.tcx.hir().get_by_hir_id(var_hir_id);\n+                            if let hir::Node::Binding(pat) = node {\n                                 if let hir::PatKind::Binding(_, _, ident, _) = pat.node {\n                                     name = Some(ident.name);\n                                 }"}, {"sha": "a7120888742d0faa0f8637003f2b99864d96aeac", "filename": "src/librustc_mir/lints.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f/src%2Flibrustc_mir%2Flints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f/src%2Flibrustc_mir%2Flints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Flints.rs?ref=9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f", "patch": "@@ -130,7 +130,7 @@ fn check_fn_for_unconditional_recursion(\n     // recurs.\n     if !reached_exit_without_self_call && !self_call_locations.is_empty() {\n         let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n-        let sp = tcx.sess.source_map().def_span(tcx.hir().span_by_hir_id(hir_id));\n+        let sp = tcx.sess.source_map().def_span(tcx.hir().span(hir_id));\n         let mut db = tcx.struct_span_lint_hir(UNCONDITIONAL_RECURSION,\n                                               hir_id,\n                                               sp,"}, {"sha": "2e74ebcf061e2c3800a38831f6adff5ba983852f", "filename": "src/librustc_mir/monomorphize/collector.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs?ref=9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f", "patch": "@@ -455,7 +455,7 @@ fn check_recursion_limit<'tcx>(\n         let error = format!(\"reached the recursion limit while instantiating `{}`\",\n                             instance);\n         if let Some(hir_id) = tcx.hir().as_local_hir_id(def_id) {\n-            tcx.sess.span_fatal(tcx.hir().span_by_hir_id(hir_id), &error);\n+            tcx.sess.span_fatal(tcx.hir().span(hir_id), &error);\n         } else {\n             tcx.sess.fatal(&error);\n         }"}, {"sha": "2bcf058ad7c35c8335766c56749bd0d18b46ddfb", "filename": "src/librustc_mir/monomorphize/item.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f/src%2Flibrustc_mir%2Fmonomorphize%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f/src%2Flibrustc_mir%2Fmonomorphize%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fitem.rs?ref=9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f", "patch": "@@ -193,7 +193,7 @@ pub trait MonoItemExt<'tcx>: fmt::Debug {\n             MonoItem::GlobalAsm(hir_id) => {\n                 Some(hir_id)\n             }\n-        }.map(|hir_id| tcx.hir().span_by_hir_id(hir_id))\n+        }.map(|hir_id| tcx.hir().span(hir_id))\n     }\n }\n "}, {"sha": "32153f7bcd9cc44835d826b88060ffbc791e0931", "filename": "src/librustc_mir/transform/check_unsafety.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs?ref=9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f", "patch": "@@ -488,7 +488,7 @@ fn check_unused_unsafe<'a, 'tcx>(\n ) {\n     let body_id =\n         tcx.hir().as_local_hir_id(def_id).and_then(|hir_id| {\n-            tcx.hir().maybe_body_owned_by_by_hir_id(hir_id)\n+            tcx.hir().maybe_body_owned_by(hir_id)\n         });\n \n     let body_id = match body_id {\n@@ -527,7 +527,7 @@ fn unsafety_check_result<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> UnsafetyChec\n     let param_env = tcx.param_env(def_id);\n \n     let id = tcx.hir().as_local_hir_id(def_id).unwrap();\n-    let (const_context, min_const_fn) = match tcx.hir().body_owner_kind_by_hir_id(id) {\n+    let (const_context, min_const_fn) = match tcx.hir().body_owner_kind(id) {\n         hir::BodyOwnerKind::Closure => (false, false),\n         hir::BodyOwnerKind::Fn => (tcx.is_const_fn(def_id), tcx.is_min_const_fn(def_id)),\n         hir::BodyOwnerKind::Const |\n@@ -591,12 +591,12 @@ fn is_enclosed(\n }\n \n fn report_unused_unsafe(tcx: TyCtxt<'_>, used_unsafe: &FxHashSet<hir::HirId>, id: hir::HirId) {\n-    let span = tcx.sess.source_map().def_span(tcx.hir().span_by_hir_id(id));\n+    let span = tcx.sess.source_map().def_span(tcx.hir().span(id));\n     let msg = \"unnecessary `unsafe` block\";\n     let mut db = tcx.struct_span_lint_hir(UNUSED_UNSAFE, id, span, msg);\n     db.span_label(span, msg);\n     if let Some((kind, id)) = is_enclosed(tcx, used_unsafe, id) {\n-        db.span_label(tcx.sess.source_map().def_span(tcx.hir().span_by_hir_id(id)),\n+        db.span_label(tcx.sess.source_map().def_span(tcx.hir().span(id)),\n                       format!(\"because it's nested under this `unsafe` {}\", kind));\n     }\n     db.emit();"}, {"sha": "5e6f1bc15f02a655ea1b7fe79567ae56b8c2ec91", "filename": "src/librustc_mir/transform/inline.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Finline.rs?ref=9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f", "patch": "@@ -70,7 +70,7 @@ impl Inliner<'tcx> {\n \n         // Only do inlining into fn bodies.\n         let id = self.tcx.hir().as_local_hir_id(self.source.def_id()).unwrap();\n-        if self.tcx.hir().body_owner_kind_by_hir_id(id).is_fn_or_closure()\n+        if self.tcx.hir().body_owner_kind(id).is_fn_or_closure()\n             && self.source.promoted.is_none()\n         {\n             for (bb, bb_data) in caller_body.basic_blocks().iter_enumerated() {"}, {"sha": "79bb2cfe08db32ff80f7880e61b6ad1fd688fb12", "filename": "src/librustc_mir/transform/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fmod.rs?ref=9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f", "patch": "@@ -208,7 +208,7 @@ fn mir_const<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> &'tcx Steal<Body<'tcx>>\n \n fn mir_validated(tcx: TyCtxt<'tcx>, def_id: DefId) -> &'tcx Steal<Body<'tcx>> {\n     let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n-    if let hir::BodyOwnerKind::Const = tcx.hir().body_owner_kind_by_hir_id(hir_id) {\n+    if let hir::BodyOwnerKind::Const = tcx.hir().body_owner_kind(hir_id) {\n         // Ensure that we compute the `mir_const_qualif` for constants at\n         // this point, before we steal the mir-const result.\n         let _ = tcx.mir_const_qualif(def_id);"}, {"sha": "b6abfdb7425aa2cd6ea4c02a2dfb662d25af7cae", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f", "patch": "@@ -1503,7 +1503,7 @@ impl MirPass for QualifyAndPromoteConstants {\n         let def_id = src.def_id();\n         let id = tcx.hir().as_local_hir_id(def_id).unwrap();\n         let mut const_promoted_temps = None;\n-        let mode = match tcx.hir().body_owner_kind_by_hir_id(id) {\n+        let mode = match tcx.hir().body_owner_kind(id) {\n             hir::BodyOwnerKind::Closure => Mode::NonConstFn,\n             hir::BodyOwnerKind::Fn => {\n                 if tcx.is_const_fn(def_id) {"}, {"sha": "5397a4af8fa8fb6c19df1bbee8e3255de7a9067d", "filename": "src/librustc_passes/rvalue_promotion.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f/src%2Flibrustc_passes%2Frvalue_promotion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f/src%2Flibrustc_passes%2Frvalue_promotion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Frvalue_promotion.rs?ref=9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f", "patch": "@@ -165,7 +165,7 @@ impl<'a, 'tcx> CheckCrateVisitor<'a, 'tcx> {\n impl<'a, 'tcx> CheckCrateVisitor<'a, 'tcx> {\n     fn check_nested_body(&mut self, body_id: hir::BodyId) -> Promotability {\n         let item_id = self.tcx.hir().body_owner(body_id);\n-        let item_def_id = self.tcx.hir().local_def_id(item_id);\n+        let item_def_id = self.tcx.hir().local_def_id_from_hir_id(item_id);\n \n         let outer_in_fn = self.in_fn;\n         let outer_tables = self.tables;"}, {"sha": "9eaa6f920f085808f5910ebdb5aab440c0bf671d", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f", "patch": "@@ -233,7 +233,7 @@ fn def_id_visibility<'tcx>(\n                 Node::Item(item) => &item.vis,\n                 Node::ForeignItem(foreign_item) => &foreign_item.vis,\n                 Node::TraitItem(..) | Node::Variant(..) => {\n-                    return def_id_visibility(tcx, tcx.hir().get_parent_did_by_hir_id(hir_id));\n+                    return def_id_visibility(tcx, tcx.hir().get_parent_did(hir_id));\n                 }\n                 Node::ImplItem(impl_item) => {\n                     match tcx.hir().get_by_hir_id(tcx.hir().get_parent_item(hir_id)) {\n@@ -255,7 +255,7 @@ fn def_id_visibility<'tcx>(\n                                 tcx, parent_did,\n                             );\n \n-                            let adt_def = tcx.adt_def(tcx.hir().get_parent_did_by_hir_id(hir_id));\n+                            let adt_def = tcx.adt_def(tcx.hir().get_parent_did(hir_id));\n                             let ctor_did = tcx.hir().local_def_id_from_hir_id(\n                                 vdata.ctor_hir_id().unwrap());\n                             let variant = adt_def.variant_with_ctor_id(ctor_did);\n@@ -294,7 +294,7 @@ fn def_id_visibility<'tcx>(\n                             // visibility to within the crate.\n                             if ctor_vis == ty::Visibility::Public {\n                                 let adt_def =\n-                                    tcx.adt_def(tcx.hir().get_parent_did_by_hir_id(hir_id));\n+                                    tcx.adt_def(tcx.hir().get_parent_did(hir_id));\n                                 if adt_def.non_enum_variant().is_field_list_non_exhaustive() {\n                                     ctor_vis =\n                                         ty::Visibility::Restricted(DefId::local(CRATE_DEF_INDEX));\n@@ -311,7 +311,7 @@ fn def_id_visibility<'tcx>(\n                 }\n                 Node::Expr(expr) => {\n                     return (ty::Visibility::Restricted(\n-                        tcx.hir().get_module_parent_by_hir_id(expr.hir_id)),\n+                        tcx.hir().get_module_parent(expr.hir_id)),\n                             expr.span, \"private\")\n                 }\n                 node => bug!(\"unexpected node kind: {:?}\", node)\n@@ -501,11 +501,11 @@ impl EmbargoVisitor<'tcx> {\n             if let Some(item) = module.res\n                 .and_then(|res| res.mod_def_id())\n                 .and_then(|def_id| self.tcx.hir().as_local_hir_id(def_id))\n-                .map(|module_hir_id| self.tcx.hir().expect_item_by_hir_id(module_hir_id))\n+                .map(|module_hir_id| self.tcx.hir().expect_item(module_hir_id))\n              {\n                 if let hir::ItemKind::Mod(m) = &item.node {\n                     for item_id in m.item_ids.as_ref() {\n-                        let item = self.tcx.hir().expect_item_by_hir_id(item_id.id);\n+                        let item = self.tcx.hir().expect_item(item_id.id);\n                         let def_id = self.tcx.hir().local_def_id_from_hir_id(item_id.id);\n                         if !self.tcx.hygienic_eq(segment.ident, item.ident, def_id) { continue; }\n                         if let hir::ItemKind::Use(..) = item.node {\n@@ -764,7 +764,7 @@ impl Visitor<'tcx> for EmbargoVisitor<'tcx> {\n             let module = if module_id == hir::CRATE_HIR_ID {\n                 &self.tcx.hir().krate().module\n             } else if let hir::ItemKind::Mod(ref module) =\n-                          self.tcx.hir().expect_item_by_hir_id(module_id).node {\n+                          self.tcx.hir().expect_item(module_id).node {\n                 module\n             } else {\n                 unreachable!()\n@@ -1690,7 +1690,7 @@ impl<'a, 'tcx> PrivateItemsInPublicInterfacesVisitor<'a, 'tcx> {\n             tcx: self.tcx,\n             item_id,\n             item_def_id: self.tcx.hir().local_def_id_from_hir_id(item_id),\n-            span: self.tcx.hir().span_by_hir_id(item_id),\n+            span: self.tcx.hir().span(item_id),\n             required_visibility,\n             has_pub_restricted: self.has_pub_restricted,\n             has_old_errors,"}, {"sha": "97124e534771643e298ffc9200bb7f4da7cb79c3", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f", "patch": "@@ -2196,12 +2196,12 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         if let Some(def_id) = self.const_param_def_id(expr) {\n             // Find the name and index of the const parameter by indexing the generics of the\n             // parent item and construct a `ParamConst`.\n-            let node_id = tcx.hir().as_local_node_id(def_id).unwrap();\n-            let item_id = tcx.hir().get_parent_node(node_id);\n-            let item_def_id = tcx.hir().local_def_id(item_id);\n+            let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n+            let item_id = tcx.hir().get_parent_node_by_hir_id(hir_id);\n+            let item_def_id = tcx.hir().local_def_id_from_hir_id(item_id);\n             let generics = tcx.generics_of(item_def_id);\n-            let index = generics.param_def_id_to_index[&tcx.hir().local_def_id(node_id)];\n-            let name = tcx.hir().name(node_id).as_interned_str();\n+            let index = generics.param_def_id_to_index[&tcx.hir().local_def_id_from_hir_id(hir_id)];\n+            let name = tcx.hir().name_by_hir_id(hir_id).as_interned_str();\n             const_.val = ConstValue::Param(ty::ParamConst::new(index, name));\n         }\n "}, {"sha": "42c7ff607c55a538d2d7e8aae044e0e6f10f7e6c", "filename": "src/librustc_typeck/check/callee.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs?ref=9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f", "patch": "@@ -354,7 +354,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     let def_span = match def {\n                         Res::Err => None,\n                         Res::Local(id) => {\n-                            Some(self.tcx.hir().span_by_hir_id(id))\n+                            Some(self.tcx.hir().span(id))\n                         },\n                         _ => def\n                             .opt_def_id()"}, {"sha": "946082746f46fe9ef55143950b3bb18b188a7eca", "filename": "src/librustc_typeck/check/compare_method.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs?ref=9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f", "patch": "@@ -813,7 +813,7 @@ fn compare_synthetic_generics<'tcx>(\n     {\n         if impl_synthetic != trait_synthetic {\n             let impl_hir_id = tcx.hir().as_local_hir_id(impl_def_id).unwrap();\n-            let impl_span = tcx.hir().span_by_hir_id(impl_hir_id);\n+            let impl_span = tcx.hir().span(impl_hir_id);\n             let trait_span = tcx.def_span(trait_def_id);\n             let mut err = struct_span_err!(tcx.sess,\n                                            impl_span,"}, {"sha": "a2621abf44d8dd29229d8f0107aa95985f542092", "filename": "src/librustc_typeck/check/dropck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs?ref=9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f", "patch": "@@ -213,7 +213,7 @@ fn ensure_drop_predicates_are_implied_by_item_defn<'tcx>(\n         // repeated `contains` calls.\n \n         if !assumptions_in_impl_context.contains(&predicate) {\n-            let item_span = tcx.hir().span_by_hir_id(self_type_hir_id);\n+            let item_span = tcx.hir().span(self_type_hir_id);\n             struct_span_err!(\n                 tcx.sess,\n                 drop_impl_span,"}, {"sha": "421688097b892d4f9288bc55beefce5159665491", "filename": "src/librustc_typeck/check/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs?ref=9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f", "patch": "@@ -180,7 +180,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         self.diverges.set(self.diverges.get() | old_diverges);\n         self.has_errors.set(self.has_errors.get() | old_has_errors);\n \n-        debug!(\"type of {} is...\", self.tcx.hir().hir_to_string(expr.hir_id));\n+        debug!(\"type of {} is...\", self.tcx.hir().node_to_string(expr.hir_id));\n         debug!(\"... {:?}, expected is {:?}\", ty, expected);\n \n         ty"}, {"sha": "29b4fee138e829e083a452ea1100768b6f4c5fce", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f", "patch": "@@ -264,7 +264,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                 // local binding\n                                 if let &QPath::Resolved(_, ref path) = &qpath {\n                                     if let hir::def::Res::Local(hir_id) = path.res {\n-                                        let span = tcx.hir().span_by_hir_id(hir_id);\n+                                        let span = tcx.hir().span(hir_id);\n                                         let snippet = tcx.sess.source_map().span_to_snippet(span);\n                                         let filename = tcx.sess.source_map().span_to_filename(span);\n \n@@ -370,7 +370,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         });\n \n                     if let Some((field, field_ty)) = field_receiver {\n-                        let scope = self.tcx.hir().get_module_parent_by_hir_id(self.body_id);\n+                        let scope = self.tcx.hir().get_module_parent(self.body_id);\n                         let is_accessible = field.vis.is_accessible_from(scope, self.tcx);\n \n                         if is_accessible {\n@@ -564,7 +564,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                               err: &mut DiagnosticBuilder<'_>,\n                               mut msg: String,\n                               candidates: Vec<DefId>) {\n-        let module_did = self.tcx.hir().get_module_parent_by_hir_id(self.body_id);\n+        let module_did = self.tcx.hir().get_module_parent(self.body_id);\n         let module_id = self.tcx.hir().as_local_hir_id(module_did).unwrap();\n         let krate = self.tcx.hir().krate();\n         let (span, found_use) = UsePlacementFinder::check(self.tcx, krate, module_id);\n@@ -897,7 +897,7 @@ impl hir::intravisit::Visitor<'tcx> for UsePlacementFinder<'tcx> {\n         }\n         // Find a `use` statement.\n         for item_id in &module.item_ids {\n-            let item = self.tcx.hir().expect_item_by_hir_id(item_id.id);\n+            let item = self.tcx.hir().expect_item(item_id.id);\n             match item.node {\n                 hir::ItemKind::Use(..) => {\n                     // Don't suggest placing a `use` before the prelude"}, {"sha": "10bfe9e034d32c09faf2b2d8167c0bd3d27669c4", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f", "patch": "@@ -622,7 +622,7 @@ impl Inherited<'a, 'tcx> {\n     fn new(infcx: InferCtxt<'a, 'tcx>, def_id: DefId) -> Self {\n         let tcx = infcx.tcx;\n         let item_id = tcx.hir().as_local_hir_id(def_id);\n-        let body_id = item_id.and_then(|id| tcx.hir().maybe_body_owned_by_by_hir_id(id));\n+        let body_id = item_id.and_then(|id| tcx.hir().maybe_body_owned_by(id));\n         let implicit_region_bound = body_id.map(|body_id| {\n             let body = tcx.hir().body(body_id);\n             tcx.mk_region(ty::ReScope(region::Scope {\n@@ -821,7 +821,7 @@ fn typeck_tables_of<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> &'tcx ty::TypeckT\n     }\n \n     let id = tcx.hir().as_local_hir_id(def_id).unwrap();\n-    let span = tcx.hir().span_by_hir_id(id);\n+    let span = tcx.hir().span(id);\n \n     // Figure out what primary body this item has.\n     let (body_id, fn_decl) = primary_body_of(tcx, id).unwrap_or_else(|| {\n@@ -1193,7 +1193,7 @@ fn check_fn<'a, 'tcx>(\n                 }\n \n                 let inputs = fn_sig.inputs();\n-                let span = fcx.tcx.hir().span_by_hir_id(fn_id);\n+                let span = fcx.tcx.hir().span(fn_id);\n                 if inputs.len() == 1 {\n                     let arg_is_panic_info = match inputs[0].sty {\n                         ty::Ref(region, ty, mutbl) => match ty.sty {\n@@ -1246,7 +1246,7 @@ fn check_fn<'a, 'tcx>(\n                 }\n \n                 let inputs = fn_sig.inputs();\n-                let span = fcx.tcx.hir().span_by_hir_id(fn_id);\n+                let span = fcx.tcx.hir().span(fn_id);\n                 if inputs.len() == 1 {\n                     let arg_is_alloc_layout = match inputs[0].sty {\n                         ty::Adt(ref adt, _) => {\n@@ -1909,11 +1909,11 @@ pub fn check_enum<'tcx>(tcx: TyCtxt<'tcx>, sp: Span, vs: &'tcx [hir::Variant], i\n             let variant_i_hir_id = tcx.hir().as_local_hir_id(variant_did).unwrap();\n             let variant_i = tcx.hir().expect_variant(variant_i_hir_id);\n             let i_span = match variant_i.node.disr_expr {\n-                Some(ref expr) => tcx.hir().span_by_hir_id(expr.hir_id),\n-                None => tcx.hir().span_by_hir_id(variant_i_hir_id)\n+                Some(ref expr) => tcx.hir().span(expr.hir_id),\n+                None => tcx.hir().span(variant_i_hir_id)\n             };\n             let span = match v.node.disr_expr {\n-                Some(ref expr) => tcx.hir().span_by_hir_id(expr.hir_id),\n+                Some(ref expr) => tcx.hir().span(expr.hir_id),\n                 None => v.span\n             };\n             struct_span_err!(tcx.sess, span, E0081,\n@@ -2181,7 +2181,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     pub fn local_ty(&self, span: Span, nid: hir::HirId) -> LocalTy<'tcx> {\n         self.locals.borrow().get(&nid).cloned().unwrap_or_else(||\n             span_bug!(span, \"no type for local variable {}\",\n-                      self.tcx.hir().hir_to_string(nid))\n+                      self.tcx.hir().node_to_string(nid))\n         )\n     }\n \n@@ -2517,9 +2517,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             Some(&t) => t,\n             None if self.is_tainted_by_errors() => self.tcx.types.err,\n             None => {\n-                let node_id = self.tcx.hir().hir_to_node_id(id);\n                 bug!(\"no type for node {}: {} in fcx {}\",\n-                     node_id, self.tcx.hir().node_to_string(node_id),\n+                     id, self.tcx.hir().node_to_string(id),\n                      self.tag());\n             }\n         }\n@@ -4364,7 +4363,7 @@ pub fn check_bounds_are_used<'tcx>(tcx: TyCtxt<'tcx>, generics: &ty::Generics, t\n     for (&used, param) in types_used.iter().zip(types) {\n         if !used {\n             let id = tcx.hir().as_local_hir_id(param.def_id).unwrap();\n-            let span = tcx.hir().span_by_hir_id(id);\n+            let span = tcx.hir().span(id);\n             struct_span_err!(tcx.sess, span, E0091, \"type parameter `{}` is unused\", param.name)\n                 .span_label(span, \"unused type parameter\")\n                 .emit();"}, {"sha": "5c710399446efba6bc63097365b522728220d71d", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f", "patch": "@@ -175,7 +175,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         if self.err_count_since_creation() == 0 {\n             // regionck assumes typeck succeeded\n-            rcx.visit_fn_body(fn_id, body, self.tcx.hir().span_by_hir_id(fn_id));\n+            rcx.visit_fn_body(fn_id, body, self.tcx.hir().span(fn_id));\n         }\n \n         rcx.resolve_regions_and_report_errors(SuppressRegionErrors::when_nll_is_enabled(self.tcx));"}, {"sha": "034ff5f8347679387d5392ff5c4dde512e0a3be2", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f", "patch": "@@ -70,7 +70,7 @@ impl<'tcx> CheckWfFcxBuilder<'tcx> {\n /// the types first.\n pub fn check_item_well_formed<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) {\n     let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n-    let item = tcx.hir().expect_item_by_hir_id(hir_id);\n+    let item = tcx.hir().expect_item(hir_id);\n \n     debug!(\"check_item_well_formed(it.hir_id={:?}, it.name={})\",\n            item.hir_id,"}, {"sha": "ffc323f28b6757a016dacb9b80b5f1b549f93dfd", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f", "patch": "@@ -34,7 +34,7 @@ use syntax_pos::Span;\n impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     pub fn resolve_type_vars_in_body(&self, body: &'tcx hir::Body) -> &'tcx ty::TypeckTables<'tcx> {\n         let item_id = self.tcx.hir().body_owner(body.id());\n-        let item_def_id = self.tcx.hir().local_def_id(item_id);\n+        let item_def_id = self.tcx.hir().local_def_id_from_hir_id(item_id);\n \n         // This attribute causes us to dump some writeback information\n         // in the form of errors, which is uSymbolfor unit tests.\n@@ -47,8 +47,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // Type only exists for constants and statics, not functions.\n         match self.tcx.hir().body_owner_kind(item_id) {\n             hir::BodyOwnerKind::Const | hir::BodyOwnerKind::Static(_) => {\n-                let item_hir_id = self.tcx.hir().node_to_hir_id(item_id);\n-                wbcx.visit_node_id(body.value.span, item_hir_id);\n+                wbcx.visit_node_id(body.value.span, item_id);\n             }\n             hir::BodyOwnerKind::Closure | hir::BodyOwnerKind::Fn => (),\n         }\n@@ -399,7 +398,7 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n             if let ty::UserType::TypeOf(_, user_substs) = c_ty.value {\n                 if self.rustc_dump_user_substs {\n                     // This is a unit-testing mechanism.\n-                    let span = self.tcx().hir().span_by_hir_id(hir_id);\n+                    let span = self.tcx().hir().span(hir_id);\n                     // We need to buffer the errors in order to guarantee a consistent\n                     // order when emitting them.\n                     let err = self.tcx().sess.struct_span_err(\n@@ -774,13 +773,13 @@ impl Locatable for Span {\n impl Locatable for DefIndex {\n     fn to_span(&self, tcx: TyCtxt<'_>) -> Span {\n         let hir_id = tcx.hir().def_index_to_hir_id(*self);\n-        tcx.hir().span_by_hir_id(hir_id)\n+        tcx.hir().span(hir_id)\n     }\n }\n \n impl Locatable for hir::HirId {\n     fn to_span(&self, tcx: TyCtxt<'_>) -> Span {\n-        tcx.hir().span_by_hir_id(*self)\n+        tcx.hir().span(*self)\n     }\n }\n "}, {"sha": "dda86778f27270ff295e6a6dd3501eabc1058892", "filename": "src/librustc_typeck/check_unused.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f/src%2Flibrustc_typeck%2Fcheck_unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f/src%2Flibrustc_typeck%2Fcheck_unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck_unused.rs?ref=9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f", "patch": "@@ -121,7 +121,7 @@ fn unused_crates_lint<'tcx>(tcx: TyCtxt<'tcx>) {\n \n     for extern_crate in &crates_to_lint {\n         let id = tcx.hir().as_local_hir_id(extern_crate.def_id).unwrap();\n-        let item = tcx.hir().expect_item_by_hir_id(id);\n+        let item = tcx.hir().expect_item(id);\n \n         // If the crate is fully unused, we suggest removing it altogether.\n         // We do this in any edition."}, {"sha": "e392622060c9b9e1fac4de0e59aed5da75800480", "filename": "src/librustc_typeck/coherence/builtin.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs?ref=9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f", "patch": "@@ -88,7 +88,7 @@ fn visit_implementation_of_copy<'tcx>(tcx: TyCtxt<'tcx>, impl_did: DefId) {\n     debug!(\"visit_implementation_of_copy: self_type={:?} (bound)\",\n            self_type);\n \n-    let span = tcx.hir().span_by_hir_id(impl_hir_id);\n+    let span = tcx.hir().span(impl_hir_id);\n     let param_env = tcx.param_env(impl_did);\n     assert!(!self_type.has_escaping_bound_vars());\n \n@@ -98,7 +98,7 @@ fn visit_implementation_of_copy<'tcx>(tcx: TyCtxt<'tcx>, impl_did: DefId) {\n     match param_env.can_type_implement_copy(tcx, self_type) {\n         Ok(()) => {}\n         Err(CopyImplementationError::InfrigingFields(fields)) => {\n-            let item = tcx.hir().expect_item_by_hir_id(impl_hir_id);\n+            let item = tcx.hir().expect_item(impl_hir_id);\n             let span = if let ItemKind::Impl(.., Some(ref tr), _, _) = item.node {\n                 tr.path.span\n             } else {\n@@ -115,7 +115,7 @@ fn visit_implementation_of_copy<'tcx>(tcx: TyCtxt<'tcx>, impl_did: DefId) {\n             err.emit()\n         }\n         Err(CopyImplementationError::NotAnAdt) => {\n-            let item = tcx.hir().expect_item_by_hir_id(impl_hir_id);\n+            let item = tcx.hir().expect_item(impl_hir_id);\n             let span = if let ItemKind::Impl(.., ref ty, _) = item.node {\n                 ty.span\n             } else {\n@@ -161,7 +161,7 @@ fn visit_implementation_of_dispatch_from_dyn<'tcx>(tcx: TyCtxt<'tcx>, impl_did:\n         let dispatch_from_dyn_trait = tcx.lang_items().dispatch_from_dyn_trait().unwrap();\n \n         let impl_hir_id = tcx.hir().as_local_hir_id(impl_did).unwrap();\n-        let span = tcx.hir().span_by_hir_id(impl_hir_id);\n+        let span = tcx.hir().span(impl_hir_id);\n \n         let source = tcx.type_of(impl_did);\n         assert!(!source.has_escaping_bound_vars());\n@@ -343,7 +343,7 @@ pub fn coerce_unsized_info<'tcx>(gcx: TyCtxt<'tcx>, impl_did: DefId) -> CoerceUn\n            source,\n            target);\n \n-    let span = gcx.hir().span_by_hir_id(impl_hir_id);\n+    let span = gcx.hir().span(impl_hir_id);\n     let param_env = gcx.param_env(impl_did);\n     assert!(!source.has_escaping_bound_vars());\n \n@@ -480,11 +480,11 @@ pub fn coerce_unsized_info<'tcx>(gcx: TyCtxt<'tcx>, impl_did: DefId) -> CoerceUn\n                                being coerced, none found\");\n                     return err_info;\n                 } else if diff_fields.len() > 1 {\n-                    let item = gcx.hir().expect_item_by_hir_id(impl_hir_id);\n+                    let item = gcx.hir().expect_item(impl_hir_id);\n                     let span = if let ItemKind::Impl(.., Some(ref t), _, _) = item.node {\n                         t.path.span\n                     } else {\n-                        gcx.hir().span_by_hir_id(impl_hir_id)\n+                        gcx.hir().span(impl_hir_id)\n                     };\n \n                     let mut err = struct_span_err!(gcx.sess,"}, {"sha": "4e6fcfe0593e2393a5bb0f765c6fd5c310af2ec3", "filename": "src/librustc_typeck/coherence/orphan.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs?ref=9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f", "patch": "@@ -26,7 +26,7 @@ impl ItemLikeVisitor<'v> for OrphanChecker<'tcx> {\n         // \"Trait\" impl\n         if let hir::ItemKind::Impl(.., Some(_), _, _) = item.node {\n             debug!(\"coherence2::orphan check: trait impl {}\",\n-                   self.tcx.hir().hir_to_string(item.hir_id));\n+                   self.tcx.hir().node_to_string(item.hir_id));\n             let trait_ref = self.tcx.impl_trait_ref(def_id).unwrap();\n             let trait_def_id = trait_ref.def_id;\n             let cm = self.tcx.sess.source_map();"}, {"sha": "5606d9c0ce815157a7b943d8096cae7d2aa5bd90", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f", "patch": "@@ -395,7 +395,7 @@ fn is_param<'tcx>(tcx: TyCtxt<'tcx>, ast_ty: &hir::Ty, param_id: hir::HirId) ->\n }\n \n fn convert_item<'tcx>(tcx: TyCtxt<'tcx>, item_id: hir::HirId) {\n-    let it = tcx.hir().expect_item_by_hir_id(item_id);\n+    let it = tcx.hir().expect_item(item_id);\n     debug!(\"convert: item {} with id {}\", it.ident, it.hir_id);\n     let def_id = tcx.hir().local_def_id_from_hir_id(item_id);\n     match it.node {\n@@ -742,7 +742,7 @@ fn super_predicates_of<'tcx>(\n \n fn trait_def<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> &'tcx ty::TraitDef {\n     let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n-    let item = tcx.hir().expect_item_by_hir_id(hir_id);\n+    let item = tcx.hir().expect_item(hir_id);\n \n     let (is_auto, unsafety) = match item.node {\n         hir::ItemKind::Trait(is_auto, unsafety, ..) => (is_auto == hir::IsAuto::Yes, unsafety),\n@@ -1177,7 +1177,7 @@ pub fn checked_type_of<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId, fail: bool) -> Op\n             ImplItemKind::Const(ref ty, _) => icx.to_ty(ty),\n             ImplItemKind::Existential(_) => {\n                 if tcx\n-                    .impl_trait_ref(tcx.hir().get_parent_did_by_hir_id(hir_id))\n+                    .impl_trait_ref(tcx.hir().get_parent_did(hir_id))\n                     .is_none()\n                 {\n                     report_assoc_ty_on_inherent_impl(tcx, item.span);\n@@ -1187,7 +1187,7 @@ pub fn checked_type_of<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId, fail: bool) -> Op\n             }\n             ImplItemKind::Type(ref ty) => {\n                 if tcx\n-                    .impl_trait_ref(tcx.hir().get_parent_did_by_hir_id(hir_id))\n+                    .impl_trait_ref(tcx.hir().get_parent_did(hir_id))\n                     .is_none()\n                 {\n                     report_assoc_ty_on_inherent_impl(tcx, item.span);\n@@ -1272,7 +1272,7 @@ pub fn checked_type_of<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId, fail: bool) -> Op\n             ..\n         }) => match *def {\n             VariantData::Unit(..) | VariantData::Struct(..) => {\n-                tcx.type_of(tcx.hir().get_parent_did_by_hir_id(hir_id))\n+                tcx.type_of(tcx.hir().get_parent_did(hir_id))\n             }\n             VariantData::Tuple(..) => {\n                 let substs = InternalSubsts::identity_for_item(tcx, def_id);\n@@ -1325,7 +1325,7 @@ pub fn checked_type_of<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId, fail: bool) -> Op\n                     ..\n                 }) if e.hir_id == hir_id =>\n                 {\n-                    tcx.adt_def(tcx.hir().get_parent_did_by_hir_id(hir_id))\n+                    tcx.adt_def(tcx.hir().get_parent_did(hir_id))\n                         .repr\n                         .discr_type()\n                         .to_ty(tcx)\n@@ -1709,15 +1709,15 @@ fn fn_sig<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> ty::PolyFnSig<'tcx> {\n             node: ForeignItemKind::Fn(ref fn_decl, _, _),\n             ..\n         }) => {\n-            let abi = tcx.hir().get_foreign_abi_by_hir_id(hir_id);\n+            let abi = tcx.hir().get_foreign_abi(hir_id);\n             compute_sig_of_foreign_fn_decl(tcx, def_id, fn_decl, abi)\n         }\n \n         Ctor(data) | Variant(Spanned {\n             node: hir::VariantKind { data, ..  },\n             ..\n         }) if data.ctor_hir_id().is_some() => {\n-            let ty = tcx.type_of(tcx.hir().get_parent_did_by_hir_id(hir_id));\n+            let ty = tcx.type_of(tcx.hir().get_parent_did(hir_id));\n             let inputs = data.fields()\n                 .iter()\n                 .map(|f| tcx.type_of(tcx.hir().local_def_id_from_hir_id(f.hir_id)));\n@@ -1762,7 +1762,7 @@ fn impl_trait_ref<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> Option<ty::TraitRef\n     let icx = ItemCtxt::new(tcx, def_id);\n \n     let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n-    match tcx.hir().expect_item_by_hir_id(hir_id).node {\n+    match tcx.hir().expect_item(hir_id).node {\n         hir::ItemKind::Impl(.., ref opt_trait_ref, _, _) => {\n             opt_trait_ref.as_ref().map(|ast_trait_ref| {\n                 let selfty = tcx.type_of(def_id);\n@@ -1775,7 +1775,7 @@ fn impl_trait_ref<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> Option<ty::TraitRef\n \n fn impl_polarity<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> hir::ImplPolarity {\n     let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n-    match tcx.hir().expect_item_by_hir_id(hir_id).node {\n+    match tcx.hir().expect_item(hir_id).node {\n         hir::ItemKind::Impl(_, polarity, ..) => polarity,\n         ref item => bug!(\"impl_polarity: {:?} not an impl\", item),\n     }"}, {"sha": "5dbd667485e98d89fe63ec98473dfbde7456a22c", "filename": "src/librustc_typeck/variance/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f/src%2Flibrustc_typeck%2Fvariance%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f/src%2Flibrustc_typeck%2Fvariance%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fmod.rs?ref=9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f", "patch": "@@ -46,7 +46,7 @@ fn variances_of<'tcx>(tcx: TyCtxt<'tcx>, item_def_id: DefId) -> &'tcx [ty::Varia\n     let id = tcx.hir().as_local_hir_id(item_def_id).expect(\"expected local def-id\");\n     let unsupported = || {\n         // Variance not relevant.\n-        span_bug!(tcx.hir().span_by_hir_id(id), \"asked to compute variance for wrong kind of item\")\n+        span_bug!(tcx.hir().span(id), \"asked to compute variance for wrong kind of item\")\n     };\n     match tcx.hir().get_by_hir_id(id) {\n         Node::Item(item) => match item.node {"}, {"sha": "99f87ccb6f65e76fd465784fb09ea63da1520a33", "filename": "src/librustc_typeck/variance/terms.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f/src%2Flibrustc_typeck%2Fvariance%2Fterms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f/src%2Flibrustc_typeck%2Fvariance%2Fterms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fterms.rs?ref=9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f", "patch": "@@ -129,7 +129,7 @@ impl<'a, 'tcx> TermsContext<'a, 'tcx> {\n impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for TermsContext<'a, 'tcx> {\n     fn visit_item(&mut self, item: &hir::Item) {\n         debug!(\"add_inferreds for item {}\",\n-               self.tcx.hir().hir_to_string(item.hir_id));\n+               self.tcx.hir().node_to_string(item.hir_id));\n \n         match item.node {\n             hir::ItemKind::Struct(ref struct_def, _) |"}, {"sha": "c14ae5932af479faf628c8a28b3db3a0be5fa965", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f", "patch": "@@ -305,7 +305,7 @@ pub fn build_impl(cx: &DocContext<'_>, did: DefId, ret: &mut Vec<clean::Item>) {\n     }\n \n     let for_ = if let Some(hir_id) = tcx.hir().as_local_hir_id(did) {\n-        match tcx.hir().expect_item_by_hir_id(hir_id).node {\n+        match tcx.hir().expect_item(hir_id).node {\n             hir::ItemKind::Impl(.., ref t, _) => {\n                 t.clean(cx)\n             }\n@@ -327,7 +327,7 @@ pub fn build_impl(cx: &DocContext<'_>, did: DefId, ret: &mut Vec<clean::Item>) {\n \n     let predicates = tcx.explicit_predicates_of(did);\n     let (trait_items, generics) = if let Some(hir_id) = tcx.hir().as_local_hir_id(did) {\n-        match tcx.hir().expect_item_by_hir_id(hir_id).node {\n+        match tcx.hir().expect_item(hir_id).node {\n             hir::ItemKind::Impl(.., ref gen, _, _, ref item_ids) => {\n                 (\n                     item_ids.iter()"}, {"sha": "4becb42d3055174d6ad446570a48bb99bbeddbc7", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f", "patch": "@@ -276,7 +276,7 @@ impl Clean<ExternalCrate> for CrateNum {\n         };\n         let primitives = if root.is_local() {\n             cx.tcx.hir().krate().module.item_ids.iter().filter_map(|&id| {\n-                let item = cx.tcx.hir().expect_item_by_hir_id(id.id);\n+                let item = cx.tcx.hir().expect_item(id.id);\n                 match item.node {\n                     hir::ItemKind::Mod(_) => {\n                         as_primitive(Res::Def(\n@@ -320,7 +320,7 @@ impl Clean<ExternalCrate> for CrateNum {\n         };\n         let keywords = if root.is_local() {\n             cx.tcx.hir().krate().module.item_ids.iter().filter_map(|&id| {\n-                let item = cx.tcx.hir().expect_item_by_hir_id(id.id);\n+                let item = cx.tcx.hir().expect_item(id.id);\n                 match item.node {\n                     hir::ItemKind::Mod(_) => {\n                         as_keyword(Res::Def(\n@@ -2777,7 +2777,7 @@ impl Clean<Type> for hir::Ty {\n             },\n             TyKind::Tup(ref tys) => Tuple(tys.clean(cx)),\n             TyKind::Def(item_id, _) => {\n-                let item = cx.tcx.hir().expect_item_by_hir_id(item_id.id);\n+                let item = cx.tcx.hir().expect_item(item_id.id);\n                 if let hir::ItemKind::Existential(ref ty) = item.node {\n                     ImplTrait(ty.bounds.clean(cx))\n                 } else {\n@@ -2799,7 +2799,7 @@ impl Clean<Type> for hir::Ty {\n                     // Substitute private type aliases\n                     if let Some(hir_id) = cx.tcx.hir().as_local_hir_id(def_id) {\n                         if !cx.renderinfo.borrow().access_levels.is_exported(def_id) {\n-                            alias = Some(&cx.tcx.hir().expect_item_by_hir_id(hir_id).node);\n+                            alias = Some(&cx.tcx.hir().expect_item(hir_id).node);\n                         }\n                     }\n                 };\n@@ -4441,7 +4441,7 @@ pub fn path_to_def_local(tcx: TyCtxt<'_>, path: &[Symbol]) -> Option<DefId> {\n         let segment = path_it.next()?;\n \n         for item_id in mem::replace(&mut items, HirVec::new()).iter() {\n-            let item = tcx.hir().expect_item_by_hir_id(item_id.id);\n+            let item = tcx.hir().expect_item(item_id.id);\n             if item.ident.name == *segment {\n                 if path_it.peek().is_none() {\n                     return Some(tcx.hir().local_def_id_from_hir_id(item_id.id))"}, {"sha": "ff76579d67d21a6b81a449eec6b3d2069f901c1e", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f", "patch": "@@ -248,7 +248,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n         let orig_inside_public_path = self.inside_public_path;\n         self.inside_public_path &= vis.node.is_pub();\n         for i in &m.item_ids {\n-            let item = self.cx.tcx.hir().expect_item_by_hir_id(i.id);\n+            let item = self.cx.tcx.hir().expect_item(i.id);\n             self.visit_item(item, None, &mut om);\n         }\n         self.inside_public_path = orig_inside_public_path;\n@@ -275,7 +275,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n         fn inherits_doc_hidden(cx: &core::DocContext<'_>, mut node: hir::HirId) -> bool {\n             while let Some(id) = cx.tcx.hir().get_enclosing_scope(node) {\n                 node = id;\n-                if cx.tcx.hir().attrs_by_hir_id(node)\n+                if cx.tcx.hir().attrs(node)\n                     .lists(sym::doc).has_word(sym::hidden) {\n                     return true;\n                 }\n@@ -295,7 +295,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n             return false;\n         };\n \n-        let use_attrs = tcx.hir().attrs_by_hir_id(id);\n+        let use_attrs = tcx.hir().attrs(id);\n         // Don't inline `doc(hidden)` imports so they can be stripped at a later stage.\n         let is_no_inline = use_attrs.lists(sym::doc).has_word(sym::no_inline) ||\n                            use_attrs.lists(sym::doc).has_word(sym::hidden);\n@@ -346,7 +346,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n             Node::Item(&hir::Item { node: hir::ItemKind::Mod(ref m), .. }) if glob => {\n                 let prev = mem::replace(&mut self.inlining, true);\n                 for i in &m.item_ids {\n-                    let i = self.cx.tcx.hir().expect_item_by_hir_id(i.id);\n+                    let i = self.cx.tcx.hir().expect_item(i.id);\n                     self.visit_item(i, None, om);\n                 }\n                 self.inlining = prev;\n@@ -361,7 +361,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n             Node::ForeignItem(it) if !glob => {\n                 // Generate a fresh `extern {}` block if we want to inline a foreign item.\n                 om.foreigns.push(hir::ForeignMod {\n-                    abi: tcx.hir().get_foreign_abi_by_hir_id(it.hir_id),\n+                    abi: tcx.hir().get_foreign_abi(it.hir_id),\n                     items: vec![hir::ForeignItem {\n                         ident: renamed.unwrap_or(it.ident),\n                         .. it.clone()"}, {"sha": "c0307263387ec6c7e8ec034f33da873f8ad40b8f", "filename": "src/libsyntax/source_map.rs", "status": "modified", "additions": 16, "deletions": 3, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f/src%2Flibsyntax%2Fsource_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f/src%2Flibsyntax%2Fsource_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fsource_map.rs?ref=9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f", "patch": "@@ -191,6 +191,18 @@ impl SourceMap {\n     /// If a file already exists in the source_map with the same id, that file is returned\n     /// unmodified\n     pub fn new_source_file(&self, filename: FileName, src: String) -> Lrc<SourceFile> {\n+        self.try_new_source_file(filename, src)\n+            .unwrap_or_else(|OffsetOverflowError| {\n+                eprintln!(\"fatal error: rustc does not support files larger than 4GB\");\n+                errors::FatalError.raise()\n+            })\n+    }\n+\n+    fn try_new_source_file(\n+        &self,\n+        filename: FileName,\n+        src: String\n+    ) -> Result<Lrc<SourceFile>, OffsetOverflowError> {\n         let start_pos = self.next_start_pos();\n \n         // The path is used to determine the directory for loading submodules and\n@@ -212,7 +224,7 @@ impl SourceMap {\n                                                        was_remapped,\n                                                        Some(&unmapped_path));\n \n-        return match self.source_file_by_stable_id(file_id) {\n+        let lrc_sf = match self.source_file_by_stable_id(file_id) {\n             Some(lrc_sf) => lrc_sf,\n             None => {\n                 let source_file = Lrc::new(SourceFile::new(\n@@ -221,7 +233,7 @@ impl SourceMap {\n                     unmapped_path,\n                     src,\n                     Pos::from_usize(start_pos),\n-                ));\n+                )?);\n \n                 let mut files = self.files.borrow_mut();\n \n@@ -230,7 +242,8 @@ impl SourceMap {\n \n                 source_file\n             }\n-        }\n+        };\n+        Ok(lrc_sf)\n     }\n \n     /// Allocates a new SourceFile representing a source file from an external"}, {"sha": "2dd409bf5bee09b86a734bd60b881b7dcbd72993", "filename": "src/libsyntax_pos/lib.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f/src%2Flibsyntax_pos%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f/src%2Flibsyntax_pos%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Flib.rs?ref=9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f", "patch": "@@ -859,6 +859,9 @@ impl ExternalSource {\n     }\n }\n \n+#[derive(Debug)]\n+pub struct OffsetOverflowError;\n+\n /// A single source in the `SourceMap`.\n #[derive(Clone)]\n pub struct SourceFile {\n@@ -1040,7 +1043,7 @@ impl SourceFile {\n                name_was_remapped: bool,\n                unmapped_path: FileName,\n                mut src: String,\n-               start_pos: BytePos) -> SourceFile {\n+               start_pos: BytePos) -> Result<SourceFile, OffsetOverflowError> {\n         remove_bom(&mut src);\n \n         let src_hash = {\n@@ -1054,11 +1057,14 @@ impl SourceFile {\n             hasher.finish()\n         };\n         let end_pos = start_pos.to_usize() + src.len();\n+        if end_pos > u32::max_value() as usize {\n+            return Err(OffsetOverflowError);\n+        }\n \n         let (lines, multibyte_chars, non_narrow_chars) =\n             analyze_source_file::analyze_source_file(&src[..], start_pos);\n \n-        SourceFile {\n+        Ok(SourceFile {\n             name,\n             name_was_remapped,\n             unmapped_path: Some(unmapped_path),\n@@ -1072,7 +1078,7 @@ impl SourceFile {\n             multibyte_chars,\n             non_narrow_chars,\n             name_hash,\n-        }\n+        })\n     }\n \n     /// Returns the `BytePos` of the beginning of the current line."}, {"sha": "a5516833900a8c8ef74da65fc9a42753b988f0a0", "filename": "src/test/codegen/slice-iter-len-eq-zero.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f/src%2Ftest%2Fcodegen%2Fslice-iter-len-eq-zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f/src%2Ftest%2Fcodegen%2Fslice-iter-len-eq-zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fslice-iter-len-eq-zero.rs?ref=9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f", "patch": "@@ -0,0 +1,14 @@\n+// no-system-llvm\n+// compile-flags: -O\n+#![crate_type = \"lib\"]\n+\n+type Demo = [u8; 3];\n+\n+// CHECK-LABEL: @slice_iter_len_eq_zero\n+#[no_mangle]\n+pub fn slice_iter_len_eq_zero(y: std::slice::Iter<'_, Demo>) -> bool {\n+    // CHECK-NOT: sub\n+    // CHECK: %2 = icmp eq i8* %1, %0\n+    // CHECK: ret i1 %2\n+    y.len() == 0\n+}"}, {"sha": "76554eaba9c92916518ee4274b16682b2a215f04", "filename": "src/test/run-pass-fulldeps/auxiliary/issue-40001-plugin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fissue-40001-plugin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fissue-40001-plugin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fissue-40001-plugin.rs?ref=9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f", "patch": "@@ -45,7 +45,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingWhitelistedAttrPass {\n \n         let item = match cx.tcx.hir().get_by_hir_id(id) {\n             Node::Item(item) => item,\n-            _ => cx.tcx.hir().expect_item_by_hir_id(cx.tcx.hir().get_parent_item(id)),\n+            _ => cx.tcx.hir().expect_item(cx.tcx.hir().get_parent_item(id)),\n         };\n \n         if !attr::contains_name(&item.attrs, Symbol::intern(\"whitelisted_attr\")) {"}, {"sha": "a3255c2f601b367efb3117485fb0f475b9b6db0a", "filename": "src/test/run-pass/consts/const-enum-cast.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f/src%2Ftest%2Frun-pass%2Fconsts%2Fconst-enum-cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f/src%2Ftest%2Frun-pass%2Fconsts%2Fconst-enum-cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconsts%2Fconst-enum-cast.rs?ref=9f22ddf6bb7001b884006b9528f8fc8c5b94ae8f", "patch": "@@ -1,9 +1,8 @@\n // run-pass\n-#![allow(dead_code)]\n #![allow(non_upper_case_globals)]\n \n enum A { A1, A2 }\n-enum B { B1=0, B2=2 }\n+enum B { B1=4, B2=2 }\n \n pub fn main () {\n     static c1: isize = A::A2 as isize;\n@@ -14,4 +13,14 @@ pub fn main () {\n     assert_eq!(c2, 2);\n     assert_eq!(a1, 1);\n     assert_eq!(a2, 2);\n+\n+    // Turns out that adding a let-binding generates totally different MIR.\n+    static c1_2: isize = { let v = A::A1; v as isize };\n+    static c2_2: isize = { let v = B::B1; v as isize };\n+    let a1_2 = { let v = A::A1; v as isize };\n+    let a2_2 = { let v = B::B1; v as isize };\n+    assert_eq!(c1_2, 0);\n+    assert_eq!(c2_2, 4);\n+    assert_eq!(a1_2, 0);\n+    assert_eq!(a2_2, 4);\n }"}]}