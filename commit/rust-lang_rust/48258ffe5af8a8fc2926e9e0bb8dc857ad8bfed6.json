{"sha": "48258ffe5af8a8fc2926e9e0bb8dc857ad8bfed6", "node_id": "C_kwDOAAsO6NoAKDQ4MjU4ZmZlNWFmOGE4ZmMyOTI2ZTllMGJiOGRjODU3YWQ4YmZlZDY", "commit": {"author": {"name": "Gary Guo", "email": "gary@garyguo.net", "date": "2021-10-13T20:20:10Z"}, "committer": {"name": "Gary Guo", "email": "gary@garyguo.net", "date": "2022-01-07T22:55:34Z"}, "message": "Remove region from UpvarCapture and move it to CapturedPlace\n\nRegion info is completely unnecessary for upvar capture kind computation\nand is only needed to create the final upvar tuple ty. Doing so makes\ncreation of UpvarCapture very cheap and expose further cleanup opportunity.", "tree": {"sha": "0320699e541e9a70e0cb85d3478aa65b384d55f8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0320699e541e9a70e0cb85d3478aa65b384d55f8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/48258ffe5af8a8fc2926e9e0bb8dc857ad8bfed6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/48258ffe5af8a8fc2926e9e0bb8dc857ad8bfed6", "html_url": "https://github.com/rust-lang/rust/commit/48258ffe5af8a8fc2926e9e0bb8dc857ad8bfed6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/48258ffe5af8a8fc2926e9e0bb8dc857ad8bfed6/comments", "author": {"login": "nbdd0121", "id": 4065244, "node_id": "MDQ6VXNlcjQwNjUyNDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/4065244?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nbdd0121", "html_url": "https://github.com/nbdd0121", "followers_url": "https://api.github.com/users/nbdd0121/followers", "following_url": "https://api.github.com/users/nbdd0121/following{/other_user}", "gists_url": "https://api.github.com/users/nbdd0121/gists{/gist_id}", "starred_url": "https://api.github.com/users/nbdd0121/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nbdd0121/subscriptions", "organizations_url": "https://api.github.com/users/nbdd0121/orgs", "repos_url": "https://api.github.com/users/nbdd0121/repos", "events_url": "https://api.github.com/users/nbdd0121/events{/privacy}", "received_events_url": "https://api.github.com/users/nbdd0121/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nbdd0121", "id": 4065244, "node_id": "MDQ6VXNlcjQwNjUyNDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/4065244?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nbdd0121", "html_url": "https://github.com/nbdd0121", "followers_url": "https://api.github.com/users/nbdd0121/followers", "following_url": "https://api.github.com/users/nbdd0121/following{/other_user}", "gists_url": "https://api.github.com/users/nbdd0121/gists{/gist_id}", "starred_url": "https://api.github.com/users/nbdd0121/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nbdd0121/subscriptions", "organizations_url": "https://api.github.com/users/nbdd0121/orgs", "repos_url": "https://api.github.com/users/nbdd0121/repos", "events_url": "https://api.github.com/users/nbdd0121/events{/privacy}", "received_events_url": "https://api.github.com/users/nbdd0121/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3698e03fb60893786843df01b50dc8326f6c5c5a", "url": "https://api.github.com/repos/rust-lang/rust/commits/3698e03fb60893786843df01b50dc8326f6c5c5a", "html_url": "https://github.com/rust-lang/rust/commit/3698e03fb60893786843df01b50dc8326f6c5c5a"}], "stats": {"total": 219, "additions": 103, "deletions": 116}, "files": [{"sha": "02935af8314f00f6f1c16297e53c5b6d78775539", "filename": "compiler/rustc_borrowck/src/diagnostics/mutability_errors.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/48258ffe5af8a8fc2926e9e0bb8dc857ad8bfed6/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48258ffe5af8a8fc2926e9e0bb8dc857ad8bfed6/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmutability_errors.rs?ref=48258ffe5af8a8fc2926e9e0bb8dc857ad8bfed6", "patch": "@@ -706,10 +706,9 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                         &origin_projection,\n                     ) {\n                         match captured_place.info.capture_kind {\n-                            ty::UpvarCapture::ByRef(ty::UpvarBorrow {\n-                                kind: ty::BorrowKind::MutBorrow | ty::BorrowKind::UniqueImmBorrow,\n-                                ..\n-                            }) => {\n+                            ty::UpvarCapture::ByRef(\n+                                ty::BorrowKind::MutBorrow | ty::BorrowKind::UniqueImmBorrow,\n+                            ) => {\n                                 capture_reason = format!(\"mutable borrow of `{}`\", upvar);\n                             }\n                             ty::UpvarCapture::ByValue => {"}, {"sha": "9c2f0ca061a7f8a3435cdf37d52cbb12e405f567", "filename": "compiler/rustc_middle/src/ty/closure.rs", "status": "modified", "additions": 9, "deletions": 17, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/48258ffe5af8a8fc2926e9e0bb8dc857ad8bfed6/compiler%2Frustc_middle%2Fsrc%2Fty%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48258ffe5af8a8fc2926e9e0bb8dc857ad8bfed6/compiler%2Frustc_middle%2Fsrc%2Fty%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fclosure.rs?ref=48258ffe5af8a8fc2926e9e0bb8dc857ad8bfed6", "patch": "@@ -52,29 +52,18 @@ impl UpvarId {\n /// Information describing the capture of an upvar. This is computed\n /// during `typeck`, specifically by `regionck`.\n #[derive(PartialEq, Clone, Debug, Copy, TyEncodable, TyDecodable, TypeFoldable, HashStable)]\n-pub enum UpvarCapture<'tcx> {\n+pub enum UpvarCapture {\n     /// Upvar is captured by value. This is always true when the\n     /// closure is labeled `move`, but can also be true in other cases\n     /// depending on inference.\n     ByValue,\n \n     /// Upvar is captured by reference.\n-    ByRef(UpvarBorrow<'tcx>),\n-}\n-\n-#[derive(PartialEq, Clone, Copy, TyEncodable, TyDecodable, TypeFoldable, HashStable)]\n-pub struct UpvarBorrow<'tcx> {\n-    /// The kind of borrow: by-ref upvars have access to shared\n-    /// immutable borrows, which are not part of the normal language\n-    /// syntax.\n-    pub kind: BorrowKind,\n-\n-    /// Region of the resulting reference.\n-    pub region: ty::Region<'tcx>,\n+    ByRef(BorrowKind),\n }\n \n pub type UpvarListMap = FxHashMap<DefId, FxIndexMap<hir::HirId, UpvarId>>;\n-pub type UpvarCaptureMap<'tcx> = FxHashMap<UpvarId, UpvarCapture<'tcx>>;\n+pub type UpvarCaptureMap = FxHashMap<UpvarId, UpvarCapture>;\n \n /// Given the closure DefId this map provides a map of root variables to minimum\n /// set of `CapturedPlace`s that need to be tracked to support all captures of that closure.\n@@ -144,10 +133,13 @@ pub struct CapturedPlace<'tcx> {\n     pub place: HirPlace<'tcx>,\n \n     /// `CaptureKind` and expression(s) that resulted in such capture of `place`.\n-    pub info: CaptureInfo<'tcx>,\n+    pub info: CaptureInfo,\n \n     /// Represents if `place` can be mutated or not.\n     pub mutability: hir::Mutability,\n+\n+    /// Region of the resulting reference if the upvar is captured by ref.\n+    pub region: Option<ty::Region<'tcx>>,\n }\n \n impl<'tcx> CapturedPlace<'tcx> {\n@@ -281,7 +273,7 @@ pub fn is_ancestor_or_same_capture(\n /// for a particular capture as well as identifying the part of the source code\n /// that triggered this capture to occur.\n #[derive(PartialEq, Clone, Debug, Copy, TyEncodable, TyDecodable, TypeFoldable, HashStable)]\n-pub struct CaptureInfo<'tcx> {\n+pub struct CaptureInfo {\n     /// Expr Id pointing to use that resulted in selecting the current capture kind\n     ///\n     /// Eg:\n@@ -319,7 +311,7 @@ pub struct CaptureInfo<'tcx> {\n     pub path_expr_id: Option<hir::HirId>,\n \n     /// Capture mode that was selected\n-    pub capture_kind: UpvarCapture<'tcx>,\n+    pub capture_kind: UpvarCapture,\n }\n \n pub fn place_to_string_for_capture<'tcx>(tcx: TyCtxt<'tcx>, place: &HirPlace<'tcx>) -> String {"}, {"sha": "d61554b29ac4b40a763ce4af3d8c151102663886", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/48258ffe5af8a8fc2926e9e0bb8dc857ad8bfed6/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48258ffe5af8a8fc2926e9e0bb8dc857ad8bfed6/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=48258ffe5af8a8fc2926e9e0bb8dc857ad8bfed6", "patch": "@@ -56,8 +56,8 @@ pub use self::binding::BindingMode::*;\n pub use self::closure::{\n     is_ancestor_or_same_capture, place_to_string_for_capture, BorrowKind, CaptureInfo,\n     CapturedPlace, ClosureKind, MinCaptureInformationMap, MinCaptureList,\n-    RootVariableMinCaptureList, UpvarBorrow, UpvarCapture, UpvarCaptureMap, UpvarId, UpvarListMap,\n-    UpvarPath, CAPTURE_STRUCT_LOCAL,\n+    RootVariableMinCaptureList, UpvarCapture, UpvarCaptureMap, UpvarId, UpvarListMap, UpvarPath,\n+    CAPTURE_STRUCT_LOCAL,\n };\n pub use self::consts::{Const, ConstInt, ConstKind, InferConst, ScalarInt, Unevaluated, ValTree};\n pub use self::context::{"}, {"sha": "bb8c2b180e40ebfaade721f5e129065429d49f59", "filename": "compiler/rustc_middle/src/ty/structural_impls.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/48258ffe5af8a8fc2926e9e0bb8dc857ad8bfed6/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48258ffe5af8a8fc2926e9e0bb8dc857ad8bfed6/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs?ref=48258ffe5af8a8fc2926e9e0bb8dc857ad8bfed6", "patch": "@@ -47,12 +47,6 @@ impl fmt::Debug for ty::UpvarId {\n     }\n }\n \n-impl<'tcx> fmt::Debug for ty::UpvarBorrow<'tcx> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(f, \"UpvarBorrow({:?}, {:?})\", self.kind, self.region)\n-    }\n-}\n-\n impl<'tcx> fmt::Debug for ty::ExistentialTraitRef<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         with_no_trimmed_paths(|| fmt::Display::fmt(self, f))"}, {"sha": "c62de1543883eb60e95be6852f5078b17669da24", "filename": "compiler/rustc_mir_build/src/thir/cx/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/48258ffe5af8a8fc2926e9e0bb8dc857ad8bfed6/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48258ffe5af8a8fc2926e9e0bb8dc857ad8bfed6/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs?ref=48258ffe5af8a8fc2926e9e0bb8dc857ad8bfed6", "patch": "@@ -1110,7 +1110,7 @@ impl<'tcx> Cx<'tcx> {\n         match upvar_capture {\n             ty::UpvarCapture::ByValue => captured_place_expr,\n             ty::UpvarCapture::ByRef(upvar_borrow) => {\n-                let borrow_kind = match upvar_borrow.kind {\n+                let borrow_kind = match upvar_borrow {\n                     ty::BorrowKind::ImmBorrow => BorrowKind::Shared,\n                     ty::BorrowKind::UniqueImmBorrow => BorrowKind::Unique,\n                     ty::BorrowKind::MutBorrow => BorrowKind::Mut { allow_two_phase_borrow: false },"}, {"sha": "0c2f40733505d6a74379384fbc6fff1e855d284e", "filename": "compiler/rustc_typeck/src/check/regionck.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/48258ffe5af8a8fc2926e9e0bb8dc857ad8bfed6/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48258ffe5af8a8fc2926e9e0bb8dc857ad8bfed6/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fregionck.rs?ref=48258ffe5af8a8fc2926e9e0bb8dc857ad8bfed6", "patch": "@@ -859,9 +859,9 @@ impl<'a, 'tcx> RegionCtxt<'a, 'tcx> {\n                     self.sub_regions(\n                         infer::ReborrowUpvar(span, upvar_id),\n                         borrow_region,\n-                        upvar_borrow.region,\n+                        captured_place.region.unwrap(),\n                     );\n-                    if let ty::ImmBorrow = upvar_borrow.kind {\n+                    if let ty::ImmBorrow = upvar_borrow {\n                         debug!(\"link_upvar_region: capture by shared ref\");\n                     } else {\n                         all_captures_are_imm_borrow = false;"}, {"sha": "591c2fc5a81456f41ae4a2d0d7365efef1685e16", "filename": "compiler/rustc_typeck/src/check/upvar.rs", "status": "modified", "additions": 84, "deletions": 82, "changes": 166, "blob_url": "https://github.com/rust-lang/rust/blob/48258ffe5af8a8fc2926e9e0bb8dc857ad8bfed6/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48258ffe5af8a8fc2926e9e0bb8dc857ad8bfed6/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs?ref=48258ffe5af8a8fc2926e9e0bb8dc857ad8bfed6", "patch": "@@ -72,7 +72,7 @@ enum PlaceAncestryRelation {\n /// Intermediate format to store a captured `Place` and associated `ty::CaptureInfo`\n /// during capture analysis. Information in this map feeds into the minimum capture\n /// analysis pass.\n-type InferredCaptureInformation<'tcx> = FxIndexMap<Place<'tcx>, ty::CaptureInfo<'tcx>>;\n+type InferredCaptureInformation<'tcx> = FxIndexMap<Place<'tcx>, ty::CaptureInfo>;\n \n impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     pub fn closure_analyze(&self, body: &'tcx hir::Body<'tcx>) {\n@@ -208,7 +208,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let mut delegate = InferBorrowKind {\n             fcx: self,\n             closure_def_id,\n-            closure_span: span,\n             capture_information: Default::default(),\n             fake_reads: Default::default(),\n         };\n@@ -231,7 +230,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let (capture_information, closure_kind, origin) = self\n             .process_collected_capture_information(capture_clause, delegate.capture_information);\n \n-        self.compute_min_captures(closure_def_id, capture_information);\n+        self.compute_min_captures(closure_def_id, capture_information, span);\n \n         let closure_hir_id = self.tcx.hir().local_def_id_to_hir_id(local_def_id);\n \n@@ -252,9 +251,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n                     debug!(\"seed place {:?}\", place);\n \n-                    let upvar_id = ty::UpvarId::new(*var_hir_id, local_def_id);\n-                    let capture_kind =\n-                        self.init_capture_kind_for_place(&place, capture_clause, upvar_id, span);\n+                    let capture_kind = self.init_capture_kind_for_place(&place, capture_clause);\n                     let fake_info = ty::CaptureInfo {\n                         capture_kind_expr_id: None,\n                         path_expr_id: None,\n@@ -266,7 +263,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             }\n \n             // This will update the min captures based on this new fake information.\n-            self.compute_min_captures(closure_def_id, capture_information);\n+            self.compute_min_captures(closure_def_id, capture_information, span);\n         }\n \n         let before_feature_tys = self.final_upvar_tys(closure_def_id);\n@@ -362,7 +359,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     captured_place.place, upvar_ty, capture, captured_place.mutability,\n                 );\n \n-                apply_capture_kind_on_capture_ty(self.tcx, upvar_ty, capture)\n+                apply_capture_kind_on_capture_ty(self.tcx, upvar_ty, capture, captured_place.region)\n             })\n             .collect()\n     }\n@@ -417,10 +414,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     ty::ClosureKind::FnOnce => (closure_kind, origin),\n                 },\n \n-                ty::UpvarCapture::ByRef(ty::UpvarBorrow {\n-                    kind: ty::BorrowKind::MutBorrow | ty::BorrowKind::UniqueImmBorrow,\n-                    ..\n-                }) => {\n+                ty::UpvarCapture::ByRef(\n+                    ty::BorrowKind::MutBorrow | ty::BorrowKind::UniqueImmBorrow,\n+                ) => {\n                     match closure_kind {\n                         ty::ClosureKind::Fn => {\n                             (ty::ClosureKind::FnMut, Some((usage_span, place.clone())))\n@@ -535,6 +531,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         &self,\n         closure_def_id: DefId,\n         capture_information: InferredCaptureInformation<'tcx>,\n+        closure_span: Span,\n     ) {\n         if capture_information.is_empty() {\n             return;\n@@ -554,8 +551,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             let min_cap_list = match root_var_min_capture_list.get_mut(&var_hir_id) {\n                 None => {\n                     let mutability = self.determine_capture_mutability(&typeck_results, &place);\n-                    let min_cap_list =\n-                        vec![ty::CapturedPlace { place, info: capture_info, mutability }];\n+                    let min_cap_list = vec![ty::CapturedPlace {\n+                        place,\n+                        info: capture_info,\n+                        mutability,\n+                        region: None,\n+                    }];\n                     root_var_min_capture_list.insert(var_hir_id, min_cap_list);\n                     continue;\n                 }\n@@ -640,12 +641,31 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             // Only need to insert when we don't have an ancestor in the existing min capture list\n             if !ancestor_found {\n                 let mutability = self.determine_capture_mutability(&typeck_results, &place);\n-                let captured_place =\n-                    ty::CapturedPlace { place, info: updated_capture_info, mutability };\n+                let captured_place = ty::CapturedPlace {\n+                    place,\n+                    info: updated_capture_info,\n+                    mutability,\n+                    region: None,\n+                };\n                 min_cap_list.push(captured_place);\n             }\n         }\n \n+        // For each capture that is determined to be captured by ref, add region info.\n+        for (_, captures) in &mut root_var_min_capture_list {\n+            for capture in captures {\n+                match capture.info.capture_kind {\n+                    ty::UpvarCapture::ByRef(_) => {\n+                        let PlaceBase::Upvar(upvar_id) = capture.place.base else { bug!(\"expected upvar\") };\n+                        let origin = UpvarRegion(upvar_id, closure_span);\n+                        let upvar_region = self.next_region_var(origin);\n+                        capture.region = Some(upvar_region);\n+                    }\n+                    _ => (),\n+                }\n+            }\n+        }\n+\n         debug!(\n             \"For closure={:?}, min_captures before sorting={:?}\",\n             closure_def_id, root_var_min_capture_list\n@@ -947,7 +967,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     max_capture_info = determine_capture_info(max_capture_info, capture.info);\n                 }\n \n-                apply_capture_kind_on_capture_ty(self.tcx, ty, max_capture_info.capture_kind)\n+                apply_capture_kind_on_capture_ty(\n+                    self.tcx,\n+                    ty,\n+                    max_capture_info.capture_kind,\n+                    Some(&ty::ReErased),\n+                )\n             }\n         };\n \n@@ -977,6 +1002,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 self.tcx,\n                 capture.place.ty(),\n                 capture.info.capture_kind,\n+                Some(&ty::ReErased),\n             );\n \n             // Checks if a capture implements any of the auto traits\n@@ -1470,9 +1496,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         &self,\n         place: &Place<'tcx>,\n         capture_clause: hir::CaptureBy,\n-        upvar_id: ty::UpvarId,\n-        closure_span: Span,\n-    ) -> ty::UpvarCapture<'tcx> {\n+    ) -> ty::UpvarCapture {\n         match capture_clause {\n             // In case of a move closure if the data is accessed through a reference we\n             // want to capture by ref to allow precise capture using reborrows.\n@@ -1483,12 +1507,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             hir::CaptureBy::Value if !place.deref_tys().any(ty::TyS::is_ref) => {\n                 ty::UpvarCapture::ByValue\n             }\n-            hir::CaptureBy::Value | hir::CaptureBy::Ref => {\n-                let origin = UpvarRegion(upvar_id, closure_span);\n-                let upvar_region = self.next_region_var(origin);\n-                let upvar_borrow = ty::UpvarBorrow { kind: ty::ImmBorrow, region: upvar_region };\n-                ty::UpvarCapture::ByRef(upvar_borrow)\n-            }\n+            hir::CaptureBy::Value | hir::CaptureBy::Ref => ty::UpvarCapture::ByRef(ty::ImmBorrow),\n         }\n     }\n \n@@ -1513,7 +1532,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     fn log_capture_analysis_first_pass(\n         &self,\n         closure_def_id: rustc_hir::def_id::DefId,\n-        capture_information: &FxIndexMap<Place<'tcx>, ty::CaptureInfo<'tcx>>,\n+        capture_information: &FxIndexMap<Place<'tcx>, ty::CaptureInfo>,\n         closure_span: Span,\n     ) {\n         if self.should_log_capture_analysis(closure_def_id) {\n@@ -1630,8 +1649,8 @@ fn restrict_repr_packed_field_ref_capture<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     place: &Place<'tcx>,\n-    mut curr_borrow_kind: ty::UpvarCapture<'tcx>,\n-) -> (Place<'tcx>, ty::UpvarCapture<'tcx>) {\n+    mut curr_borrow_kind: ty::UpvarCapture,\n+) -> (Place<'tcx>, ty::UpvarCapture) {\n     let pos = place.projections.iter().enumerate().position(|(i, p)| {\n         let ty = place.ty_before_projection(i);\n \n@@ -1675,12 +1694,14 @@ fn restrict_repr_packed_field_ref_capture<'tcx>(\n fn apply_capture_kind_on_capture_ty<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     ty: Ty<'tcx>,\n-    capture_kind: UpvarCapture<'tcx>,\n+    capture_kind: UpvarCapture,\n+    region: Option<ty::Region<'tcx>>,\n ) -> Ty<'tcx> {\n     match capture_kind {\n         ty::UpvarCapture::ByValue => ty,\n-        ty::UpvarCapture::ByRef(borrow) => tcx\n-            .mk_ref(borrow.region, ty::TypeAndMut { ty: ty, mutbl: borrow.kind.to_mutbl_lossy() }),\n+        ty::UpvarCapture::ByRef(kind) => {\n+            tcx.mk_ref(region.unwrap(), ty::TypeAndMut { ty: ty, mutbl: kind.to_mutbl_lossy() })\n+        }\n     }\n }\n \n@@ -1710,8 +1731,6 @@ struct InferBorrowKind<'a, 'tcx> {\n     // The def-id of the closure whose kind and upvar accesses are being inferred.\n     closure_def_id: DefId,\n \n-    closure_span: Span,\n-\n     /// For each Place that is captured by the closure, we track the minimal kind of\n     /// access we need (ref, ref mut, move, etc) and the expression that resulted in such access.\n     ///\n@@ -1749,7 +1768,6 @@ impl<'a, 'tcx> InferBorrowKind<'a, 'tcx> {\n         place_with_id: &PlaceWithHirId<'tcx>,\n         diag_expr_id: hir::HirId,\n     ) {\n-        let tcx = self.fcx.tcx;\n         let PlaceBase::Upvar(upvar_id) = place_with_id.place.base else {\n             return;\n         };\n@@ -1842,15 +1860,11 @@ impl<'a, 'tcx> InferBorrowKind<'a, 'tcx> {\n         if let ty::UpvarCapture::ByValue = curr_capture_info.capture_kind {\n             // It's already captured by value, we don't need to do anything here\n             return;\n-        } else if let ty::UpvarCapture::ByRef(curr_upvar_borrow) = curr_capture_info.capture_kind {\n-            // Use the same region as the current capture information\n-            // Doesn't matter since only one of the UpvarBorrow will be used.\n-            let new_upvar_borrow = ty::UpvarBorrow { kind, region: curr_upvar_borrow.region };\n-\n+        } else if let ty::UpvarCapture::ByRef(_) = curr_capture_info.capture_kind {\n             let capture_info = ty::CaptureInfo {\n                 capture_kind_expr_id: Some(diag_expr_id),\n                 path_expr_id: Some(diag_expr_id),\n-                capture_kind: ty::UpvarCapture::ByRef(new_upvar_borrow),\n+                capture_kind: ty::UpvarCapture::ByRef(kind),\n             };\n             let updated_info = determine_capture_info(curr_capture_info, capture_info);\n             self.capture_information[&place_with_id.place] = updated_info;\n@@ -1868,10 +1882,7 @@ impl<'a, 'tcx> InferBorrowKind<'a, 'tcx> {\n \n             // Initialize to ImmBorrow\n             // We will escalate the CaptureKind based on any uses we see or in `process_collected_capture_information`.\n-            let origin = UpvarRegion(upvar_id, self.closure_span);\n-            let upvar_region = self.fcx.next_region_var(origin);\n-            let upvar_borrow = ty::UpvarBorrow { kind: ty::ImmBorrow, region: upvar_region };\n-            let capture_kind = ty::UpvarCapture::ByRef(upvar_borrow);\n+            let capture_kind = ty::UpvarCapture::ByRef(ty::ImmBorrow);\n \n             let expr_id = Some(diag_expr_id);\n             let capture_info = ty::CaptureInfo {\n@@ -1894,10 +1905,7 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for InferBorrowKind<'a, 'tcx> {\n         if let PlaceBase::Upvar(_) = place.base {\n             // We need to restrict Fake Read precision to avoid fake reading unsafe code,\n             // such as deref of a raw pointer.\n-            let dummy_capture_kind = ty::UpvarCapture::ByRef(ty::UpvarBorrow {\n-                kind: ty::BorrowKind::ImmBorrow,\n-                region: &ty::ReErased,\n-            });\n+            let dummy_capture_kind = ty::UpvarCapture::ByRef(ty::BorrowKind::ImmBorrow);\n \n             let (place, _) = restrict_capture_precision(place, dummy_capture_kind);\n \n@@ -1928,8 +1936,7 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for InferBorrowKind<'a, 'tcx> {\n         bk: ty::BorrowKind,\n     ) {\n         // The region here will get discarded/ignored\n-        let dummy_capture_kind =\n-            ty::UpvarCapture::ByRef(ty::UpvarBorrow { kind: bk, region: &ty::ReErased });\n+        let dummy_capture_kind = ty::UpvarCapture::ByRef(bk);\n \n         // We only want repr packed restriction to be applied to reading references into a packed\n         // struct, and not when the data is being moved. Therefore we call this method here instead\n@@ -1948,7 +1955,7 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for InferBorrowKind<'a, 'tcx> {\n         }\n \n         match updated_kind {\n-            ty::UpvarCapture::ByRef(ty::UpvarBorrow { kind, .. }) => match kind {\n+            ty::UpvarCapture::ByRef(kind) => match kind {\n                 ty::ImmBorrow => {}\n                 ty::UniqueImmBorrow => {\n                     self.adjust_upvar_borrow_kind_for_unique(&place_with_id, diag_expr_id);\n@@ -1973,9 +1980,9 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for InferBorrowKind<'a, 'tcx> {\n fn restrict_precision_for_drop_types<'a, 'tcx>(\n     fcx: &'a FnCtxt<'a, 'tcx>,\n     mut place: Place<'tcx>,\n-    mut curr_mode: ty::UpvarCapture<'tcx>,\n+    mut curr_mode: ty::UpvarCapture,\n     span: Span,\n-) -> (Place<'tcx>, ty::UpvarCapture<'tcx>) {\n+) -> (Place<'tcx>, ty::UpvarCapture) {\n     let is_copy_type = fcx.infcx.type_is_copy_modulo_regions(fcx.param_env, place.ty(), span);\n \n     if let (false, UpvarCapture::ByValue) = (is_copy_type, curr_mode) {\n@@ -1999,8 +2006,8 @@ fn restrict_precision_for_drop_types<'a, 'tcx>(\n /// - No projections are applied on top of Union ADTs, since these require unsafe blocks.\n fn restrict_precision_for_unsafe<'tcx>(\n     mut place: Place<'tcx>,\n-    mut curr_mode: ty::UpvarCapture<'tcx>,\n-) -> (Place<'tcx>, ty::UpvarCapture<'tcx>) {\n+    mut curr_mode: ty::UpvarCapture,\n+) -> (Place<'tcx>, ty::UpvarCapture) {\n     if place.base_ty.is_unsafe_ptr() {\n         truncate_place_to_len_and_update_capture_kind(&mut place, &mut curr_mode, 0);\n     }\n@@ -2032,8 +2039,8 @@ fn restrict_precision_for_unsafe<'tcx>(\n /// Returns the truncated place and updated cature mode.\n fn restrict_capture_precision<'tcx>(\n     place: Place<'tcx>,\n-    curr_mode: ty::UpvarCapture<'tcx>,\n-) -> (Place<'tcx>, ty::UpvarCapture<'tcx>) {\n+    curr_mode: ty::UpvarCapture,\n+) -> (Place<'tcx>, ty::UpvarCapture) {\n     let (mut place, mut curr_mode) = restrict_precision_for_unsafe(place, curr_mode);\n \n     if place.projections.is_empty() {\n@@ -2060,8 +2067,8 @@ fn restrict_capture_precision<'tcx>(\n /// Truncate deref of any reference.\n fn adjust_for_move_closure<'tcx>(\n     mut place: Place<'tcx>,\n-    mut kind: ty::UpvarCapture<'tcx>,\n-) -> (Place<'tcx>, ty::UpvarCapture<'tcx>) {\n+    mut kind: ty::UpvarCapture,\n+) -> (Place<'tcx>, ty::UpvarCapture) {\n     let first_deref = place.projections.iter().position(|proj| proj.kind == ProjectionKind::Deref);\n \n     if let Some(idx) = first_deref {\n@@ -2075,8 +2082,8 @@ fn adjust_for_move_closure<'tcx>(\n /// from enclosing stack frame.\n fn adjust_for_non_move_closure<'tcx>(\n     mut place: Place<'tcx>,\n-    mut kind: ty::UpvarCapture<'tcx>,\n-) -> (Place<'tcx>, ty::UpvarCapture<'tcx>) {\n+    mut kind: ty::UpvarCapture,\n+) -> (Place<'tcx>, ty::UpvarCapture) {\n     let contains_deref =\n         place.projections.iter().position(|proj| proj.kind == ProjectionKind::Deref);\n \n@@ -2119,13 +2126,13 @@ fn construct_place_string<'tcx>(tcx: TyCtxt<'_>, place: &Place<'tcx>) -> String\n fn construct_capture_kind_reason_string<'tcx>(\n     tcx: TyCtxt<'_>,\n     place: &Place<'tcx>,\n-    capture_info: &ty::CaptureInfo<'tcx>,\n+    capture_info: &ty::CaptureInfo,\n ) -> String {\n     let place_str = construct_place_string(tcx, place);\n \n     let capture_kind_str = match capture_info.capture_kind {\n         ty::UpvarCapture::ByValue => \"ByValue\".into(),\n-        ty::UpvarCapture::ByRef(borrow) => format!(\"{:?}\", borrow.kind),\n+        ty::UpvarCapture::ByRef(kind) => format!(\"{:?}\", kind),\n     };\n \n     format!(\"{} captured as {} here\", place_str, capture_kind_str)\n@@ -2140,13 +2147,13 @@ fn construct_path_string<'tcx>(tcx: TyCtxt<'_>, place: &Place<'tcx>) -> String {\n fn construct_capture_info_string<'tcx>(\n     tcx: TyCtxt<'_>,\n     place: &Place<'tcx>,\n-    capture_info: &ty::CaptureInfo<'tcx>,\n+    capture_info: &ty::CaptureInfo,\n ) -> String {\n     let place_str = construct_place_string(tcx, place);\n \n     let capture_kind_str = match capture_info.capture_kind {\n         ty::UpvarCapture::ByValue => \"ByValue\".into(),\n-        ty::UpvarCapture::ByRef(borrow) => format!(\"{:?}\", borrow.kind),\n+        ty::UpvarCapture::ByRef(kind) => format!(\"{:?}\", kind),\n     };\n     format!(\"{} -> {}\", place_str, capture_kind_str)\n }\n@@ -2229,17 +2236,15 @@ fn migration_suggestion_for_2229(\n /// would've already handled `E1`, and have an existing capture_information for it.\n /// Calling `determine_capture_info(existing_info_e1, current_info_e2)` will return\n /// `existing_info_e1` in this case, allowing us to point to `E1` in case of diagnostics.\n-fn determine_capture_info<'tcx>(\n-    capture_info_a: ty::CaptureInfo<'tcx>,\n-    capture_info_b: ty::CaptureInfo<'tcx>,\n-) -> ty::CaptureInfo<'tcx> {\n+fn determine_capture_info(\n+    capture_info_a: ty::CaptureInfo,\n+    capture_info_b: ty::CaptureInfo,\n+) -> ty::CaptureInfo {\n     // If the capture kind is equivalent then, we don't need to escalate and can compare the\n     // expressions.\n     let eq_capture_kind = match (capture_info_a.capture_kind, capture_info_b.capture_kind) {\n         (ty::UpvarCapture::ByValue, ty::UpvarCapture::ByValue) => true,\n-        (ty::UpvarCapture::ByRef(ref_a), ty::UpvarCapture::ByRef(ref_b)) => {\n-            ref_a.kind == ref_b.kind\n-        }\n+        (ty::UpvarCapture::ByRef(ref_a), ty::UpvarCapture::ByRef(ref_b)) => ref_a == ref_b,\n         (ty::UpvarCapture::ByValue, _) | (ty::UpvarCapture::ByRef(_), _) => false,\n     };\n \n@@ -2255,7 +2260,7 @@ fn determine_capture_info<'tcx>(\n             (ty::UpvarCapture::ByValue, _) => capture_info_a,\n             (_, ty::UpvarCapture::ByValue) => capture_info_b,\n             (ty::UpvarCapture::ByRef(ref_a), ty::UpvarCapture::ByRef(ref_b)) => {\n-                match (ref_a.kind, ref_b.kind) {\n+                match (ref_a, ref_b) {\n                     // Take LHS:\n                     (ty::UniqueImmBorrow | ty::MutBorrow, ty::ImmBorrow)\n                     | (ty::MutBorrow, ty::UniqueImmBorrow) => capture_info_a,\n@@ -2283,7 +2288,7 @@ fn determine_capture_info<'tcx>(\n /// contained `Deref` of `&mut`.\n fn truncate_place_to_len_and_update_capture_kind<'tcx>(\n     place: &mut Place<'tcx>,\n-    curr_mode: &mut ty::UpvarCapture<'tcx>,\n+    curr_mode: &mut ty::UpvarCapture,\n     len: usize,\n ) {\n     let is_mut_ref = |ty: Ty<'_>| matches!(ty.kind(), ty::Ref(.., hir::Mutability::Mut));\n@@ -2293,15 +2298,12 @@ fn truncate_place_to_len_and_update_capture_kind<'tcx>(\n     // Note that if the place contained Deref of a raw pointer it would've not been MutBorrow, so\n     // we don't need to worry about that case here.\n     match curr_mode {\n-        ty::UpvarCapture::ByRef(ty::UpvarBorrow { kind: ty::BorrowKind::MutBorrow, region }) => {\n+        ty::UpvarCapture::ByRef(ty::BorrowKind::MutBorrow) => {\n             for i in len..place.projections.len() {\n                 if place.projections[i].kind == ProjectionKind::Deref\n                     && is_mut_ref(place.ty_before_projection(i))\n                 {\n-                    *curr_mode = ty::UpvarCapture::ByRef(ty::UpvarBorrow {\n-                        kind: ty::BorrowKind::UniqueImmBorrow,\n-                        region,\n-                    });\n+                    *curr_mode = ty::UpvarCapture::ByRef(ty::BorrowKind::UniqueImmBorrow);\n                     break;\n                 }\n             }\n@@ -2379,8 +2381,8 @@ fn determine_place_ancestry_relation<'tcx>(\n /// ```\n fn truncate_capture_for_optimization<'tcx>(\n     mut place: Place<'tcx>,\n-    mut curr_mode: ty::UpvarCapture<'tcx>,\n-) -> (Place<'tcx>, ty::UpvarCapture<'tcx>) {\n+    mut curr_mode: ty::UpvarCapture,\n+) -> (Place<'tcx>, ty::UpvarCapture) {\n     let is_shared_ref = |ty: Ty<'_>| matches!(ty.kind(), ty::Ref(.., hir::Mutability::Not));\n \n     // Find the right-most deref (if any). All the projections that come after this"}, {"sha": "352cdefc0b47b415a5e26974a7e6c1be84c5d4c4", "filename": "compiler/rustc_typeck/src/expr_use_visitor.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/48258ffe5af8a8fc2926e9e0bb8dc857ad8bfed6/compiler%2Frustc_typeck%2Fsrc%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48258ffe5af8a8fc2926e9e0bb8dc857ad8bfed6/compiler%2Frustc_typeck%2Fsrc%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fexpr_use_visitor.rs?ref=48258ffe5af8a8fc2926e9e0bb8dc857ad8bfed6", "patch": "@@ -803,7 +803,7 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n                             self.delegate.borrow(\n                                 &place_with_id,\n                                 place_with_id.hir_id,\n-                                upvar_borrow.kind,\n+                                upvar_borrow,\n                             );\n                         }\n                     }"}, {"sha": "2a06cf121ff01c43d7f98056338d13e9e5ee2828", "filename": "src/tools/clippy/clippy_utils/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/48258ffe5af8a8fc2926e9e0bb8dc857ad8bfed6/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48258ffe5af8a8fc2926e9e0bb8dc857ad8bfed6/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Flib.rs?ref=48258ffe5af8a8fc2926e9e0bb8dc857ad8bfed6", "patch": "@@ -970,7 +970,7 @@ pub fn can_move_expr_to_closure(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) ->\n                         if !self.locals.contains(&local_id) {\n                             let capture = match capture.info.capture_kind {\n                                 UpvarCapture::ByValue => CaptureKind::Value,\n-                                UpvarCapture::ByRef(borrow) => match borrow.kind {\n+                                UpvarCapture::ByRef(kind) => match kind {\n                                     BorrowKind::ImmBorrow => CaptureKind::Ref(Mutability::Not),\n                                     BorrowKind::UniqueImmBorrow | BorrowKind::MutBorrow => {\n                                         CaptureKind::Ref(Mutability::Mut)"}]}