{"sha": "0cd06fb4813bdd0e49528b380b3f19c37527616a", "node_id": "C_kwDOAAsO6NoAKDBjZDA2ZmI0ODEzYmRkMGU0OTUyOGIzODBiM2YxOWMzNzUyNzYxNmE", "commit": {"author": {"name": "Guillaume Gomez", "email": "guillaume.gomez@huawei.com", "date": "2022-08-10T12:46:18Z"}, "committer": {"name": "Guillaume Gomez", "email": "guillaume.gomez@huawei.com", "date": "2022-08-10T12:46:18Z"}, "message": "remove Clean trait implementation for hir::GenericArgs", "tree": {"sha": "865a823cd54125931a5053157015f3b63bc1ef36", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/865a823cd54125931a5053157015f3b63bc1ef36"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0cd06fb4813bdd0e49528b380b3f19c37527616a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0cd06fb4813bdd0e49528b380b3f19c37527616a", "html_url": "https://github.com/rust-lang/rust/commit/0cd06fb4813bdd0e49528b380b3f19c37527616a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0cd06fb4813bdd0e49528b380b3f19c37527616a/comments", "author": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "committer": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a4f52a562240f32a757268c63589b1e4c3a0f934", "url": "https://api.github.com/repos/rust-lang/rust/commits/a4f52a562240f32a757268c63589b1e4c3a0f934", "html_url": "https://github.com/rust-lang/rust/commit/a4f52a562240f32a757268c63589b1e4c3a0f934"}], "stats": {"total": 68, "additions": 38, "deletions": 30}, "files": [{"sha": "6e24638548979bfc71895839f23a335b712e636b", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 38, "deletions": 30, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/0cd06fb4813bdd0e49528b380b3f19c37527616a/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0cd06fb4813bdd0e49528b380b3f19c37527616a/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=0cd06fb4813bdd0e49528b380b3f19c37527616a", "patch": "@@ -123,7 +123,7 @@ fn clean_generic_bound<'tcx>(\n \n             let trait_ref = ty::TraitRef::identity(cx.tcx, def_id).skip_binder();\n \n-            let generic_args = generic_args.clean(cx);\n+            let generic_args = clean_generic_args(generic_args, cx);\n             let GenericArgs::AngleBracketed { bindings, .. } = generic_args\n             else {\n                 bug!(\"clean: parenthesized `GenericBound::LangItemTrait`\");\n@@ -1826,39 +1826,44 @@ fn clean_path<'tcx>(path: &hir::Path<'tcx>, cx: &mut DocContext<'tcx>) -> Path {\n     Path { res: path.res, segments: path.segments.iter().map(|x| x.clean(cx)).collect() }\n }\n \n-impl<'tcx> Clean<'tcx, GenericArgs> for hir::GenericArgs<'tcx> {\n-    fn clean(&self, cx: &mut DocContext<'tcx>) -> GenericArgs {\n-        if self.parenthesized {\n-            let output = clean_ty(self.bindings[0].ty(), cx);\n-            let output =\n-                if output != Type::Tuple(Vec::new()) { Some(Box::new(output)) } else { None };\n-            let inputs = self.inputs().iter().map(|x| clean_ty(x, cx)).collect::<Vec<_>>().into();\n-            GenericArgs::Parenthesized { inputs, output }\n-        } else {\n-            let args = self\n-                .args\n-                .iter()\n-                .map(|arg| match arg {\n-                    hir::GenericArg::Lifetime(lt) if !lt.is_elided() => {\n-                        GenericArg::Lifetime(clean_lifetime(*lt, cx))\n-                    }\n-                    hir::GenericArg::Lifetime(_) => GenericArg::Lifetime(Lifetime::elided()),\n-                    hir::GenericArg::Type(ty) => GenericArg::Type(clean_ty(ty, cx)),\n-                    hir::GenericArg::Const(ct) => GenericArg::Const(Box::new(clean_const(ct, cx))),\n-                    hir::GenericArg::Infer(_inf) => GenericArg::Infer,\n-                })\n-                .collect::<Vec<_>>()\n-                .into();\n-            let bindings =\n-                self.bindings.iter().map(|x| clean_type_binding(x, cx)).collect::<Vec<_>>().into();\n-            GenericArgs::AngleBracketed { args, bindings }\n-        }\n+fn clean_generic_args<'tcx>(\n+    generic_args: &hir::GenericArgs<'tcx>,\n+    cx: &mut DocContext<'tcx>,\n+) -> GenericArgs {\n+    if generic_args.parenthesized {\n+        let output = clean_ty(generic_args.bindings[0].ty(), cx);\n+        let output = if output != Type::Tuple(Vec::new()) { Some(Box::new(output)) } else { None };\n+        let inputs =\n+            generic_args.inputs().iter().map(|x| clean_ty(x, cx)).collect::<Vec<_>>().into();\n+        GenericArgs::Parenthesized { inputs, output }\n+    } else {\n+        let args = generic_args\n+            .args\n+            .iter()\n+            .map(|arg| match arg {\n+                hir::GenericArg::Lifetime(lt) if !lt.is_elided() => {\n+                    GenericArg::Lifetime(clean_lifetime(*lt, cx))\n+                }\n+                hir::GenericArg::Lifetime(_) => GenericArg::Lifetime(Lifetime::elided()),\n+                hir::GenericArg::Type(ty) => GenericArg::Type(clean_ty(ty, cx)),\n+                hir::GenericArg::Const(ct) => GenericArg::Const(Box::new(clean_const(ct, cx))),\n+                hir::GenericArg::Infer(_inf) => GenericArg::Infer,\n+            })\n+            .collect::<Vec<_>>()\n+            .into();\n+        let bindings = generic_args\n+            .bindings\n+            .iter()\n+            .map(|x| clean_type_binding(x, cx))\n+            .collect::<Vec<_>>()\n+            .into();\n+        GenericArgs::AngleBracketed { args, bindings }\n     }\n }\n \n impl<'tcx> Clean<'tcx, PathSegment> for hir::PathSegment<'tcx> {\n     fn clean(&self, cx: &mut DocContext<'tcx>) -> PathSegment {\n-        PathSegment { name: self.ident.name, args: self.args().clean(cx) }\n+        PathSegment { name: self.ident.name, args: clean_generic_args(self.args(), cx) }\n     }\n }\n \n@@ -2228,7 +2233,10 @@ fn clean_type_binding<'tcx>(\n     cx: &mut DocContext<'tcx>,\n ) -> TypeBinding {\n     TypeBinding {\n-        assoc: PathSegment { name: type_binding.ident.name, args: type_binding.gen_args.clean(cx) },\n+        assoc: PathSegment {\n+            name: type_binding.ident.name,\n+            args: clean_generic_args(type_binding.gen_args, cx),\n+        },\n         kind: match type_binding.kind {\n             hir::TypeBindingKind::Equality { ref term } => {\n                 TypeBindingKind::Equality { term: clean_hir_term(term, cx) }"}]}