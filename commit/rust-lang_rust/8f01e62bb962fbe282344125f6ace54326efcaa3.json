{"sha": "8f01e62bb962fbe282344125f6ace54326efcaa3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhmMDFlNjJiYjk2MmZiZTI4MjM0NDEyNWY2YWNlNTQzMjZlZmNhYTM=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-04-09T08:47:05Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-04-09T09:04:18Z"}, "message": "Scale back the traits", "tree": {"sha": "e3982d1b2adace537e621ece4706603e657e18de", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e3982d1b2adace537e621ece4706603e657e18de"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8f01e62bb962fbe282344125f6ace54326efcaa3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8f01e62bb962fbe282344125f6ace54326efcaa3", "html_url": "https://github.com/rust-lang/rust/commit/8f01e62bb962fbe282344125f6ace54326efcaa3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8f01e62bb962fbe282344125f6ace54326efcaa3/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "68196ccc10c60de52bb771d295879456f73ede95", "url": "https://api.github.com/repos/rust-lang/rust/commits/68196ccc10c60de52bb771d295879456f73ede95", "html_url": "https://github.com/rust-lang/rust/commit/68196ccc10c60de52bb771d295879456f73ede95"}], "stats": {"total": 3306, "additions": 3061, "deletions": 245}, "files": [{"sha": "ab0f44dd2e0fab4ee4762e12a8bfe76dfd4fdf23", "filename": "crates/ra_syntax/src/ast.rs", "status": "modified", "additions": 5, "deletions": 103, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/8f01e62bb962fbe282344125f6ace54326efcaa3/crates%2Fra_syntax%2Fsrc%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f01e62bb962fbe282344125f6ace54326efcaa3/crates%2Fra_syntax%2Fsrc%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast.rs?ref=8f01e62bb962fbe282344125f6ace54326efcaa3", "patch": "@@ -11,10 +11,7 @@ pub mod make;\n use std::marker::PhantomData;\n \n use crate::{\n-    syntax_node::{\n-        NodeOrToken, SyntaxElement, SyntaxElementChildren, SyntaxNode, SyntaxNodeChildren,\n-        SyntaxToken,\n-    },\n+    syntax_node::{SyntaxNode, SyntaxNodeChildren, SyntaxToken},\n     SmolStr, SyntaxKind,\n };\n \n@@ -33,24 +30,16 @@ pub use self::{\n /// conversion itself has zero runtime cost: ast and syntax nodes have exactly\n /// the same representation: a pointer to the tree root and a pointer to the\n /// node itself.\n-pub trait AstNode: AstElement {\n+pub trait AstNode {\n     fn can_cast(kind: SyntaxKind) -> bool\n     where\n         Self: Sized;\n \n-    fn cast_or_return(syntax: SyntaxNode) -> Result<Self, SyntaxNode>\n-    where\n-        Self: Sized;\n-\n     fn cast(syntax: SyntaxNode) -> Option<Self>\n     where\n-        Self: Sized,\n-    {\n-        <Self as AstNode>::cast_or_return(syntax).ok()\n-    }\n+        Self: Sized;\n \n     fn syntax(&self) -> &SyntaxNode;\n-    fn into_syntax(self) -> SyntaxNode;\n }\n \n #[test]\n@@ -59,51 +48,22 @@ fn assert_ast_is_object_safe() {\n }\n \n /// Like `AstNode`, but wraps tokens rather than interior nodes.\n-pub trait AstToken: AstElement {\n+pub trait AstToken {\n     fn can_cast(token: SyntaxKind) -> bool\n     where\n         Self: Sized;\n \n-    fn cast_or_return(syntax: SyntaxToken) -> Result<Self, SyntaxToken>\n-    where\n-        Self: Sized;\n-\n     fn cast(syntax: SyntaxToken) -> Option<Self>\n     where\n-        Self: Sized,\n-    {\n-        <Self as AstToken>::cast_or_return(syntax).ok()\n-    }\n+        Self: Sized;\n \n     fn syntax(&self) -> &SyntaxToken;\n-    fn into_syntax(self) -> SyntaxToken;\n \n     fn text(&self) -> &SmolStr {\n         self.syntax().text()\n     }\n }\n \n-/// Like `AstNode`, but wraps either nodes or tokens rather than interior nodes.\n-pub trait AstElement: std::fmt::Display {\n-    fn can_cast_element(kind: SyntaxKind) -> bool\n-    where\n-        Self: Sized;\n-\n-    fn cast_or_return_element(syntax: SyntaxElement) -> Result<Self, SyntaxElement>\n-    where\n-        Self: Sized;\n-\n-    fn cast_element(syntax: SyntaxElement) -> Option<Self>\n-    where\n-        Self: Sized,\n-    {\n-        <Self as AstElement>::cast_or_return_element(syntax).ok()\n-    }\n-\n-    fn syntax_element(&self) -> NodeOrToken<&SyntaxNode, &SyntaxToken>;\n-    fn into_syntax_element(self) -> SyntaxElement;\n-}\n-\n /// An iterator over `SyntaxNode` children of a particular AST type.\n #[derive(Debug, Clone)]\n pub struct AstChildren<N> {\n@@ -132,64 +92,6 @@ fn children<P: AstNode + ?Sized, C: AstNode>(parent: &P) -> AstChildren<C> {\n     AstChildren::new(parent.syntax())\n }\n \n-/// An iterator over `SyntaxToken` children of a particular AST type.\n-#[derive(Debug, Clone)]\n-pub struct AstChildTokens<N> {\n-    inner: SyntaxElementChildren,\n-    ph: PhantomData<N>,\n-}\n-\n-impl<N> AstChildTokens<N> {\n-    fn new(parent: &SyntaxNode) -> Self {\n-        AstChildTokens { inner: parent.children_with_tokens(), ph: PhantomData }\n-    }\n-}\n-\n-impl<N: AstToken> Iterator for AstChildTokens<N> {\n-    type Item = N;\n-    fn next(&mut self) -> Option<N> {\n-        self.inner.by_ref().filter_map(|x| x.into_token()).find_map(N::cast)\n-    }\n-}\n-\n-fn child_token_opt<P: AstNode + ?Sized, C: AstToken>(parent: &P) -> Option<C> {\n-    child_tokens(parent).next()\n-}\n-\n-fn child_tokens<P: AstNode + ?Sized, C: AstToken>(parent: &P) -> AstChildTokens<C> {\n-    AstChildTokens::new(parent.syntax())\n-}\n-\n-/// An iterator over `SyntaxNode` children of a particular AST type.\n-#[derive(Debug, Clone)]\n-pub struct AstChildElements<N> {\n-    inner: SyntaxElementChildren,\n-    ph: PhantomData<N>,\n-}\n-\n-impl<N> AstChildElements<N> {\n-    fn new(parent: &SyntaxNode) -> Self {\n-        AstChildElements { inner: parent.children_with_tokens(), ph: PhantomData }\n-    }\n-}\n-\n-impl<N: AstElement> Iterator for AstChildElements<N> {\n-    type Item = N;\n-    fn next(&mut self) -> Option<N> {\n-        self.inner.by_ref().find_map(N::cast_element)\n-    }\n-}\n-\n-#[allow(dead_code)]\n-fn child_element_opt<P: AstNode + ?Sized, C: AstElement>(parent: &P) -> Option<C> {\n-    child_elements(parent).next()\n-}\n-\n-#[allow(dead_code)]\n-fn child_elements<P: AstNode + ?Sized, C: AstElement>(parent: &P) -> AstChildElements<C> {\n-    AstChildElements::new(parent.syntax())\n-}\n-\n #[test]\n fn test_doc_comment_none() {\n     let file = SourceFile::parse("}, {"sha": "385fddc89ee5694aff974707e7a2f6495082c634", "filename": "crates/ra_syntax/src/ast/generated.rs", "status": "modified", "additions": 3028, "deletions": 2, "changes": 3030, "blob_url": "https://github.com/rust-lang/rust/blob/8f01e62bb962fbe282344125f6ace54326efcaa3/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f01e62bb962fbe282344125f6ace54326efcaa3/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs?ref=8f01e62bb962fbe282344125f6ace54326efcaa3"}, {"sha": "2dfb68371876ffe079590780dbe93e8ad4e95baa", "filename": "xtask/src/codegen/gen_syntax.rs", "status": "modified", "additions": 28, "deletions": 140, "changes": 168, "blob_url": "https://github.com/rust-lang/rust/blob/8f01e62bb962fbe282344125f6ace54326efcaa3/xtask%2Fsrc%2Fcodegen%2Fgen_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f01e62bb962fbe282344125f6ace54326efcaa3/xtask%2Fsrc%2Fcodegen%2Fgen_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xtask%2Fsrc%2Fcodegen%2Fgen_syntax.rs?ref=8f01e62bb962fbe282344125f6ace54326efcaa3", "patch": "@@ -97,11 +97,13 @@ fn generate_ast(kinds: KindsSrc<'_>, grammar: AstSrc<'_>) -> Result<String> {\n         let name = format_ident!(\"{}\", to_pascal_case(kind_str));\n         quote! {\n             #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-            pub struct #name(SyntaxToken);\n+            pub struct #name {\n+                pub(crate) syntax: SyntaxToken,\n+            }\n \n             impl std::fmt::Display for #name {\n                 fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n-                    std::fmt::Display::fmt(self.syntax(), f)\n+                    std::fmt::Display::fmt(&self.syntax, f)\n                 }\n             }\n \n@@ -112,29 +114,10 @@ fn generate_ast(kinds: KindsSrc<'_>, grammar: AstSrc<'_>) -> Result<String> {\n                         _ => false,\n                     }\n                 }\n-                fn cast_or_return(syntax: SyntaxToken) -> Result<Self, SyntaxToken> {\n-                    if Self::can_cast(syntax.kind()) { Ok(Self(syntax)) } else { Err(syntax) }\n-                }\n-                fn syntax(&self) -> &SyntaxToken { &self.0 }\n-                fn into_syntax(self) -> SyntaxToken { self.0 }\n-            }\n-\n-            impl AstElement for #name {\n-                fn can_cast_element(kind: SyntaxKind) -> bool {\n-                    match kind {\n-                        #kind => true,\n-                        _ => false,\n-                    }\n-                }\n-                fn cast_or_return_element(syntax: SyntaxElement) -> Result<Self, SyntaxElement> {\n-                    if Self::can_cast_element(syntax.kind()) { Ok(Self(syntax.into_token().unwrap())) } else { Err(syntax) }\n-                }\n-                fn syntax_element(&self) -> NodeOrToken<&SyntaxNode, &SyntaxToken> {\n-                    NodeOrToken::Token(&self.0)\n-                }\n-                fn into_syntax_element(self) -> SyntaxElement {\n-                    NodeOrToken::Token(self.0)\n+                fn cast(syntax: SyntaxToken) -> Option<Self> {\n+                    if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }\n                 }\n+                fn syntax(&self) -> &SyntaxToken { &self.syntax }\n             }\n         }\n     });\n@@ -156,28 +139,21 @@ fn generate_ast(kinds: KindsSrc<'_>, grammar: AstSrc<'_>) -> Result<String> {\n                 FieldSrc::Optional(ty) | FieldSrc::Many(ty) => ty,\n                 FieldSrc::Shorthand => name,\n             };\n-            let element_kinds = &element_kinds_map.get(*ty).unwrap_or_else(|| panic!(\"type not found: {}\", *ty));\n-            let iter = if !element_kinds.has_tokens {\n-                format_ident!(\"AstChildren\")\n-            } else if !element_kinds.has_nodes {\n-                format_ident!(\"AstChildTokens\")\n-            } else {\n-                format_ident!(\"AstChildElements\")\n-            };\n+\n             let ty = format_ident!(\"{}\", ty);\n \n             match field {\n                 FieldSrc::Many(_) => {\n                     quote! {\n-                        pub fn #method_name(&self) -> #iter<#ty> {\n-                            #iter::new(&self.syntax)\n+                        pub fn #method_name(&self) -> AstChildren<#ty> {\n+                            AstChildren::new(&self.syntax)\n                         }\n                     }\n                 }\n                 FieldSrc::Optional(_) | FieldSrc::Shorthand => {\n                     quote! {\n                         pub fn #method_name(&self) -> Option<#ty> {\n-                            #iter::new(&self.syntax).next()\n+                            AstChildren::new(&self.syntax).next()\n                         }\n                     }\n                 }\n@@ -203,29 +179,10 @@ fn generate_ast(kinds: KindsSrc<'_>, grammar: AstSrc<'_>) -> Result<String> {\n                         _ => false,\n                     }\n                 }\n-                fn cast_or_return(syntax: SyntaxNode) -> Result<Self, SyntaxNode> {\n-                    if Self::can_cast(syntax.kind()) { Ok(Self { syntax }) } else { Err(syntax) }\n+                fn cast(syntax: SyntaxNode) -> Option<Self> {\n+                    if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }\n                 }\n                 fn syntax(&self) -> &SyntaxNode { &self.syntax }\n-                fn into_syntax(self) -> SyntaxNode { self.syntax }\n-            }\n-\n-            impl AstElement for #name {\n-                fn can_cast_element(kind: SyntaxKind) -> bool {\n-                    match kind {\n-                        #kind => true,\n-                        _ => false,\n-                    }\n-                }\n-                fn cast_or_return_element(syntax: SyntaxElement) -> Result<Self, SyntaxElement> {\n-                    if Self::can_cast_element(syntax.kind()) { Ok(Self { syntax: syntax.into_node().unwrap() }) } else { Err(syntax) }\n-                }\n-                fn syntax_element(&self) -> NodeOrToken<&SyntaxNode, &SyntaxToken> {\n-                    NodeOrToken::Node(&self.syntax)\n-                }\n-                fn into_syntax_element(self) -> SyntaxElement {\n-                    NodeOrToken::Node(self.syntax)\n-                }\n             }\n \n             #(#traits)*\n@@ -238,71 +195,16 @@ fn generate_ast(kinds: KindsSrc<'_>, grammar: AstSrc<'_>) -> Result<String> {\n \n     let enums = grammar.enums.iter().map(|en| {\n         let variants = en.variants.iter().map(|var| format_ident!(\"{}\", var)).collect::<Vec<_>>();\n-        let element_kinds = &element_kinds_map[&en.name.to_string()];\n         let name = format_ident!(\"{}\", en.name);\n-        let kinds = en.variants\n+        let kinds = variants\n             .iter()\n-            .map(|name| {\n-                element_kinds_map[*name].kinds.iter().collect::<Vec<_>>()\n-            })\n+            .map(|name| format_ident!(\"{}\", to_upper_snake_case(&name.to_string())))\n             .collect::<Vec<_>>();\n         let traits = en.traits.iter().map(|trait_name| {\n             let trait_name = format_ident!(\"{}\", trait_name);\n             quote!(impl ast::#trait_name for #name {})\n         });\n \n-        let all_kinds = &element_kinds.kinds;\n-\n-        let specific_ast_trait = if element_kinds.has_nodes != element_kinds.has_tokens {\n-            let (ast_trait, syntax_type) = if element_kinds.has_tokens {\n-                (\n-                    quote!(AstToken),\n-                    quote!(SyntaxToken),\n-                )\n-            } else {\n-                (\n-                    quote!(AstNode),\n-                    quote!(SyntaxNode),\n-                )\n-            };\n-\n-            quote! {\n-                impl #ast_trait for #name {\n-                    fn can_cast(kind: SyntaxKind) -> bool {\n-                        match kind {\n-                            #(#all_kinds)|* => true,\n-                            _ => false,\n-                        }\n-                    }\n-                    #[allow(unreachable_patterns)]\n-                    fn cast_or_return(syntax: #syntax_type) -> Result<Self, #syntax_type> {\n-                        match syntax.kind() {\n-                            #(\n-                            #(#kinds)|* => #variants::cast_or_return(syntax).map(|x| #name::#variants(x)),\n-                            )*\n-                            _ => Err(syntax),\n-                        }\n-                    }\n-                    fn syntax(&self) -> &#syntax_type {\n-                        match self {\n-                            #(\n-                            #name::#variants(it) => it.syntax(),\n-                            )*\n-                        }\n-                    }\n-                    fn into_syntax(self) -> #syntax_type {\n-                        match self {\n-                            #(\n-                            #name::#variants(it) => it.into_syntax(),\n-                            )*\n-                        }\n-                    }\n-                }\n-            }\n-        } else {\n-            Default::default()\n-        };\n-\n         quote! {\n             #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n             pub enum #name {\n@@ -319,48 +221,34 @@ fn generate_ast(kinds: KindsSrc<'_>, grammar: AstSrc<'_>) -> Result<String> {\n \n             impl std::fmt::Display for #name {\n                 fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n-                    match self {\n-                        #(\n-                        #name::#variants(it) => std::fmt::Display::fmt(it, f),\n-                        )*\n-                    }\n+                    std::fmt::Display::fmt(self.syntax(), f)\n                 }\n             }\n \n-            #specific_ast_trait\n-\n-            impl AstElement for #name {\n-                fn can_cast_element(kind: SyntaxKind) -> bool {\n+            impl AstNode for #name {\n+                fn can_cast(kind: SyntaxKind) -> bool {\n                     match kind {\n-                        #(#all_kinds)|* => true,\n+                        #(#kinds)|* => true,\n                         _ => false,\n                     }\n                 }\n-                #[allow(unreachable_patterns)]\n-                fn cast_or_return_element(syntax: SyntaxElement) -> Result<Self, SyntaxElement> {\n-                    match syntax.kind() {\n+                fn cast(syntax: SyntaxNode) -> Option<Self> {\n+                    let res = match syntax.kind() {\n                         #(\n-                        #(#kinds)|* => #variants::cast_or_return_element(syntax).map(|x| #name::#variants(x)),\n+                        #kinds => #name::#variants(#variants { syntax }),\n                         )*\n-                        _ => Err(syntax),\n-                    }\n+                        _ => return None,\n+                    };\n+                    Some(res)\n                 }\n-                fn syntax_element(&self) -> NodeOrToken<&SyntaxNode, &SyntaxToken> {\n+                fn syntax(&self) -> &SyntaxNode {\n                     match self {\n                         #(\n-                        #name::#variants(it) => it.syntax_element(),\n-                        )*\n-                    }\n-                }\n-                fn into_syntax_element(self) -> SyntaxElement {\n-                    match self {\n-                        #(\n-                        #name::#variants(it) => it.into_syntax_element(),\n+                        #name::#variants(it) => &it.syntax,\n                         )*\n                     }\n                 }\n             }\n-\n             #(#traits)*\n         }\n     });\n@@ -380,7 +268,7 @@ fn generate_ast(kinds: KindsSrc<'_>, grammar: AstSrc<'_>) -> Result<String> {\n         #[allow(unused_imports)]\n         use crate::{\n             SyntaxNode, SyntaxToken, SyntaxElement, NodeOrToken, SyntaxKind::{self, *},\n-            ast::{self, AstNode, AstToken, AstElement, AstChildren, AstChildTokens, AstChildElements},\n+            ast::{self, AstNode, AstToken, AstChildren},\n         };\n \n         #(#tokens)*"}]}