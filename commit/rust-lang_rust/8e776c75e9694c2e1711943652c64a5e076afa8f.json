{"sha": "8e776c75e9694c2e1711943652c64a5e076afa8f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhlNzc2Yzc1ZTk2OTRjMmUxNzExOTQzNjUyYzY0YTVlMDc2YWZhOGY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-08-22T03:21:32Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-08-22T03:21:32Z"}, "message": "auto merge of #8570 : catamorphism/rust/2013-08-16-rollup, r=catamorphism\n\nNothing arguable here, as far as I can tell.", "tree": {"sha": "8ea396f883ba818f1db86ef523803aeac2e1568c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8ea396f883ba818f1db86ef523803aeac2e1568c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8e776c75e9694c2e1711943652c64a5e076afa8f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8e776c75e9694c2e1711943652c64a5e076afa8f", "html_url": "https://github.com/rust-lang/rust/commit/8e776c75e9694c2e1711943652c64a5e076afa8f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8e776c75e9694c2e1711943652c64a5e076afa8f/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3ddfb725127a49e03593c0c56542f12826713bd6", "url": "https://api.github.com/repos/rust-lang/rust/commits/3ddfb725127a49e03593c0c56542f12826713bd6", "html_url": "https://github.com/rust-lang/rust/commit/3ddfb725127a49e03593c0c56542f12826713bd6"}, {"sha": "a9aa4ad2a017f5ed1655917fe8a6bb66591d7025", "url": "https://api.github.com/repos/rust-lang/rust/commits/a9aa4ad2a017f5ed1655917fe8a6bb66591d7025", "html_url": "https://github.com/rust-lang/rust/commit/a9aa4ad2a017f5ed1655917fe8a6bb66591d7025"}], "stats": {"total": 543, "additions": 395, "deletions": 148}, "files": [{"sha": "009198b9b6e8adc4c254ebd5711b7ea263c9676c", "filename": "src/libextra/fileinput.rs", "status": "modified", "additions": 25, "deletions": 20, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/8e776c75e9694c2e1711943652c64a5e076afa8f/src%2Flibextra%2Ffileinput.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e776c75e9694c2e1711943652c64a5e076afa8f/src%2Flibextra%2Ffileinput.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ffileinput.rs?ref=8e776c75e9694c2e1711943652c64a5e076afa8f", "patch": "@@ -27,7 +27,7 @@ reset once it has been finished, so attempting to iterate on `[None,\n None]` will only take input once unless `io::stdin().seek(0, SeekSet)`\n is called between.\n \n-The `pathify` function handles converting a list of file paths as\n+The `make_path_option_vec` function handles converting a list of file paths as\n strings to the appropriate format, including the (optional) conversion\n of `\"-\"` to `stdin`.\n \n@@ -42,7 +42,7 @@ to handle any `FileInput` structs. E.g. a simple `cat` program\n \n or a program that numbers lines after concatenating two files\n \n-    for input_vec_state(pathify([~\"a.txt\", ~\"b.txt\"])) |line, state| {\n+    for input_vec_state(make_path_option_vec([~\"a.txt\", ~\"b.txt\"])) |line, state| {\n         io::println(fmt!(\"%u: %s\", state.line_num,\n                                    line));\n     }\n@@ -145,8 +145,14 @@ struct FileInput_ {\n     previous_was_newline: bool\n }\n \n-// XXX: remove this when Reader has &mut self. Should be removable via\n-// \"self.fi.\" -> \"self.\" and renaming FileInput_. Documentation above\n+\n+// FIXME #5723: remove this when Reader has &mut self.\n+// Removing it would mean giving read_byte in the Reader impl for\n+// FileInput &mut self, which in turn means giving most of the\n+// io::Reader trait methods &mut self. That can't be done right now\n+// because of io::with_bytes_reader and #5723.\n+// Should be removable via\n+// \"self.fi\" -> \"self.\" and renaming FileInput_. Documentation above\n // will likely have to be updated to use `let mut in = ...`.\n pub struct FileInput  {\n     fi: @mut FileInput_\n@@ -194,7 +200,7 @@ impl FileInput {\n     */\n     pub fn from_args() -> FileInput {\n         let args = os::args();\n-        let pathed = pathify(args.tail(), true);\n+        let pathed = make_path_option_vec(args.tail(), true);\n         FileInput::from_vec(pathed)\n     }\n \n@@ -351,8 +357,7 @@ Convert a list of strings to an appropriate form for a `FileInput`\n instance. `stdin_hyphen` controls whether `-` represents `stdin` or\n a literal `-`.\n */\n-// XXX: stupid, unclear name\n-pub fn pathify(vec: &[~str], stdin_hyphen : bool) -> ~[Option<Path>] {\n+pub fn make_path_option_vec(vec: &[~str], stdin_hyphen : bool) -> ~[Option<Path>] {\n     vec.iter().map(|str| {\n         if stdin_hyphen && \"-\" == *str {\n             None\n@@ -410,7 +415,7 @@ pub fn input_vec_state(files: ~[Option<Path>],\n #[cfg(test)]\n mod test {\n \n-    use super::{FileInput, pathify, input_vec, input_vec_state};\n+    use super::{FileInput, make_path_option_vec, input_vec, input_vec_state};\n \n     use std::io;\n     use std::uint;\n@@ -426,22 +431,22 @@ mod test {\n     }\n \n     #[test]\n-    fn test_pathify() {\n+    fn test_make_path_option_vec() {\n         let strs = [~\"some/path\",\n                     ~\"some/other/path\"];\n         let paths = ~[Some(Path(\"some/path\")),\n                       Some(Path(\"some/other/path\"))];\n \n-        assert_eq!(pathify(strs, true), paths.clone());\n-        assert_eq!(pathify(strs, false), paths);\n+        assert_eq!(make_path_option_vec(strs, true), paths.clone());\n+        assert_eq!(make_path_option_vec(strs, false), paths);\n \n-        assert_eq!(pathify([~\"-\"], true), ~[None]);\n-        assert_eq!(pathify([~\"-\"], false), ~[Some(Path(\"-\"))]);\n+        assert_eq!(make_path_option_vec([~\"-\"], true), ~[None]);\n+        assert_eq!(make_path_option_vec([~\"-\"], false), ~[Some(Path(\"-\"))]);\n     }\n \n     #[test]\n     fn test_fileinput_read_byte() {\n-        let filenames = pathify(vec::from_fn(\n+        let filenames = make_path_option_vec(vec::from_fn(\n             3,\n             |i| fmt!(\"tmp/lib-fileinput-test-fileinput-read-byte-%u.tmp\", i)), true);\n \n@@ -471,7 +476,7 @@ mod test {\n \n     #[test]\n     fn test_fileinput_read() {\n-        let filenames = pathify(vec::from_fn(\n+        let filenames = make_path_option_vec(vec::from_fn(\n             3,\n             |i| fmt!(\"tmp/lib-fileinput-test-fileinput-read-%u.tmp\", i)), true);\n \n@@ -492,7 +497,7 @@ mod test {\n     #[test]\n     fn test_input_vec() {\n         let mut all_lines = ~[];\n-        let filenames = pathify(vec::from_fn(\n+        let filenames = make_path_option_vec(vec::from_fn(\n             3,\n             |i| fmt!(\"tmp/lib-fileinput-test-input-vec-%u.tmp\", i)), true);\n \n@@ -514,7 +519,7 @@ mod test {\n \n     #[test]\n     fn test_input_vec_state() {\n-        let filenames = pathify(vec::from_fn(\n+        let filenames = make_path_option_vec(vec::from_fn(\n             3,\n             |i| fmt!(\"tmp/lib-fileinput-test-input-vec-state-%u.tmp\", i)),true);\n \n@@ -536,7 +541,7 @@ mod test {\n \n     #[test]\n     fn test_empty_files() {\n-        let filenames = pathify(vec::from_fn(\n+        let filenames = make_path_option_vec(vec::from_fn(\n             3,\n             |i| fmt!(\"tmp/lib-fileinput-test-empty-files-%u.tmp\", i)),true);\n \n@@ -583,7 +588,7 @@ mod test {\n \n     #[test]\n     fn test_next_file() {\n-        let filenames = pathify(vec::from_fn(\n+        let filenames = make_path_option_vec(vec::from_fn(\n             3,\n             |i| fmt!(\"tmp/lib-fileinput-test-next-file-%u.tmp\", i)),true);\n \n@@ -614,7 +619,7 @@ mod test {\n     #[test]\n     #[should_fail]\n     fn test_input_vec_missing_file() {\n-        do input_vec(pathify([~\"this/file/doesnt/exist\"], true)) |line| {\n+        do input_vec(make_path_option_vec([~\"this/file/doesnt/exist\"], true)) |line| {\n             println(line);\n             true\n         };"}, {"sha": "daad3970445a921527b62737bd2f67ae8859e79a", "filename": "src/libextra/flatpipes.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8e776c75e9694c2e1711943652c64a5e076afa8f/src%2Flibextra%2Fflatpipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e776c75e9694c2e1711943652c64a5e076afa8f/src%2Flibextra%2Fflatpipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fflatpipes.rs?ref=8e776c75e9694c2e1711943652c64a5e076afa8f", "patch": "@@ -564,8 +564,10 @@ pub mod bytepipes {\n         }\n     }\n \n-    // XXX: Remove `@mut` when this module is ported to the new I/O traits,\n-    // which use `&mut self` properly.\n+    // FIXME #6850: Remove `@mut` when this module is ported to the new I/O traits,\n+    // which use `&mut self` properly. (For example, util::comm::GenericPort's try_recv\n+    // method doesn't use `&mut self`, so the `try_recv` method in the impl of `BytePort`\n+    // for `PipeBytePort` can't have `&mut self` either.)\n     pub struct PipeBytePort {\n         port: comm::Port<~[u8]>,\n         buf: @mut ~[u8]"}, {"sha": "b75295ffd22ea18393a6b0703b8f52c1aa5e9155", "filename": "src/libextra/io_util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8e776c75e9694c2e1711943652c64a5e076afa8f/src%2Flibextra%2Fio_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e776c75e9694c2e1711943652c64a5e076afa8f/src%2Flibextra%2Fio_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fio_util.rs?ref=8e776c75e9694c2e1711943652c64a5e076afa8f", "patch": "@@ -30,7 +30,7 @@ impl BufReader {\n     }\n \n     fn as_bytes_reader<A>(&self, f: &fn(&BytesReader) -> A) -> A {\n-        // XXX FIXME(#5723)\n+        // FIXME(#5723)\n         let bytes = ::std::util::id::<&[u8]>(self.buf);\n         let bytes: &'static [u8] = unsafe { cast::transmute(bytes) };\n         // Recreating the BytesReader state every call since"}, {"sha": "2e8748e4ff8328552e80596b43b5a3b1e349d4cc", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 90, "deletions": 57, "changes": 147, "blob_url": "https://github.com/rust-lang/rust/blob/8e776c75e9694c2e1711943652c64a5e076afa8f/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e776c75e9694c2e1711943652c64a5e076afa8f/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=8e776c75e9694c2e1711943652c64a5e076afa8f", "patch": "@@ -831,6 +831,7 @@ pub fn Resolver(session: Session,\n         trait_map: HashMap::new(),\n         used_imports: HashSet::new(),\n \n+        emit_errors: true,\n         intr: session.intr()\n     };\n \n@@ -888,6 +889,11 @@ pub struct Resolver {\n     export_map2: ExportMap2,\n     trait_map: TraitMap,\n \n+    // Whether or not to print error messages. Can be set to true\n+    // when getting additional info for error message suggestions,\n+    // so as to avoid printing duplicate errors\n+    emit_errors: bool,\n+\n     used_imports: HashSet<NodeId>,\n }\n \n@@ -1072,7 +1078,7 @@ impl Resolver {\n                     // Return an error here by looking up the namespace that\n                     // had the duplicate.\n                     let ns = ns.unwrap();\n-                    self.session.span_err(sp,\n+                    self.resolve_error(sp,\n                         fmt!(\"duplicate definition of %s `%s`\",\n                              namespace_error_to_str(duplicate_type),\n                              self.session.str_of(name)));\n@@ -2074,7 +2080,7 @@ impl Resolver {\n                                    self.import_path_to_str(\n                                        import_directive.module_path,\n                                        *import_directive.subclass));\n-                    self.session.span_err(import_directive.span, msg);\n+                    self.resolve_error(import_directive.span, msg);\n                 }\n                 Indeterminate => {\n                     // Bail out. We'll come around next time.\n@@ -2249,9 +2255,6 @@ impl Resolver {\n \n         // We need to resolve both namespaces for this to succeed.\n         //\n-        // FIXME #4949: See if there's some way of handling namespaces in\n-        // a more generic way. We have two of them; it seems worth\n-        // doing...\n \n         let mut value_result = UnknownResult;\n         let mut type_result = UnknownResult;\n@@ -2448,12 +2451,12 @@ impl Resolver {\n \n         let span = directive.span;\n         if resolve_fail {\n-            self.session.span_err(span, fmt!(\"unresolved import: there is no `%s` in `%s`\",\n+            self.resolve_error(span, fmt!(\"unresolved import: there is no `%s` in `%s`\",\n                                              self.session.str_of(source),\n                                              self.module_to_str(containing_module)));\n             return Failed;\n         } else if priv_fail {\n-            self.session.span_err(span, fmt!(\"unresolved import: found `%s` in `%s` but it is \\\n+            self.resolve_error(span, fmt!(\"unresolved import: found `%s` in `%s` but it is \\\n                                              private\", self.session.str_of(source),\n                                              self.module_to_str(containing_module)));\n             return Failed;\n@@ -2620,14 +2623,14 @@ impl Resolver {\n                             hi: span.lo + BytePos(segment_name.len()),\n                             expn_info: span.expn_info,\n                         };\n-                        self.session.span_err(span,\n+                        self.resolve_error(span,\n                                               fmt!(\"unresolved import. maybe \\\n                                                     a missing `extern mod \\\n                                                     %s`?\",\n                                                     segment_name));\n                         return Failed;\n                     }\n-                    self.session.span_err(span, fmt!(\"unresolved import: could not find `%s` in \\\n+                    self.resolve_error(span, fmt!(\"unresolved import: could not find `%s` in \\\n                                                      `%s`.\", segment_name, module_name));\n                     return Failed;\n                 }\n@@ -2645,7 +2648,7 @@ impl Resolver {\n                             match type_def.module_def {\n                                 None => {\n                                     // Not a module.\n-                                    self.session.span_err(span,\n+                                    self.resolve_error(span,\n                                                           fmt!(\"not a \\\n                                                                 module `%s`\",\n                                                                self.session.\n@@ -2661,7 +2664,7 @@ impl Resolver {\n                                            module_def.kind) {\n                                         (ImportSearch, TraitModuleKind) |\n                                         (ImportSearch, ImplModuleKind) => {\n-                                            self.session.span_err(\n+                                            self.resolve_error(\n                                                 span,\n                                                 \"cannot import from a trait \\\n                                                  or type implementation\");\n@@ -2674,7 +2677,7 @@ impl Resolver {\n                         }\n                         None => {\n                             // There are no type bindings at all.\n-                            self.session.span_err(span,\n+                            self.resolve_error(span,\n                                                   fmt!(\"not a module `%s`\",\n                                                        self.session.str_of(\n                                                             name)));\n@@ -2726,7 +2729,7 @@ impl Resolver {\n                 let mpath = self.idents_to_str(module_path);\n                 match mpath.rfind(':') {\n                     Some(idx) => {\n-                        self.session.span_err(span, fmt!(\"unresolved import: could not find `%s` \\\n+                        self.resolve_error(span, fmt!(\"unresolved import: could not find `%s` \\\n                                                          in `%s`\",\n                                                          // idx +- 1 to account for the colons\n                                                          // on either side\n@@ -2762,8 +2765,7 @@ impl Resolver {\n                             module_path[0]);\n                         match result {\n                             Failed => {\n-                                self.session.span_err(span,\n-                                                      \"unresolved name\");\n+                                self.resolve_error(span, \"unresolved name\");\n                                 return Failed;\n                             }\n                             Indeterminate => {\n@@ -3143,11 +3145,11 @@ impl Resolver {\n         if index != import_count {\n             let sn = self.session.codemap.span_to_snippet(imports[index].span).unwrap();\n             if sn.contains(\"::\") {\n-                self.session.span_err(imports[index].span, \"unresolved import\");\n+                self.resolve_error(imports[index].span, \"unresolved import\");\n             } else {\n                 let err = fmt!(\"unresolved import (maybe you meant `%s::*`?)\",\n                                sn.slice(0, sn.len()));\n-                self.session.span_err(imports[index].span, err);\n+                self.resolve_error(imports[index].span, err);\n             }\n         }\n \n@@ -3412,15 +3414,15 @@ impl Resolver {\n                         // named function item. This is not allowed, so we\n                         // report an error.\n \n-                        self.session.span_err(\n+                        self.resolve_error(\n                             span,\n                             \"can't capture dynamic environment in a fn item; \\\n                             use the || { ... } closure form instead\");\n                     } else {\n                         // This was an attempt to use a type parameter outside\n                         // its scope.\n \n-                        self.session.span_err(span,\n+                        self.resolve_error(span,\n                                               \"attempt to use a type \\\n                                               argument out of scope\");\n                     }\n@@ -3435,15 +3437,15 @@ impl Resolver {\n                         // named function item. This is not allowed, so we\n                         // report an error.\n \n-                        self.session.span_err(\n+                        self.resolve_error(\n                             span,\n                             \"can't capture dynamic environment in a fn item; \\\n                             use the || { ... } closure form instead\");\n                     } else {\n                         // This was an attempt to use a type parameter outside\n                         // its scope.\n \n-                        self.session.span_err(span,\n+                        self.resolve_error(span,\n                                               \"attempt to use a type \\\n                                               argument out of scope\");\n                     }\n@@ -3452,7 +3454,7 @@ impl Resolver {\n                 }\n                 ConstantItemRibKind => {\n                     // Still doesn't deal with upvars\n-                    self.session.span_err(span,\n+                    self.resolve_error(span,\n                                           \"attempt to use a non-constant \\\n                                            value in a constant\");\n \n@@ -3849,7 +3851,7 @@ impl Resolver {\n                 };\n \n                 let msg = fmt!(\"attempt to %s a nonexistent trait `%s`\", usage_str, path_str);\n-                self.session.span_err(trait_reference.path.span, msg);\n+                self.resolve_error(trait_reference.path.span, msg);\n             }\n             Some(def) => {\n                 debug!(\"(resolving trait) found trait def: %?\", def);\n@@ -3870,7 +3872,7 @@ impl Resolver {\n                     match ident_map.find(&ident) {\n                         Some(&prev_field) => {\n                             let ident_str = self.session.str_of(ident);\n-                            self.session.span_err(field.span,\n+                            self.resolve_error(field.span,\n                                 fmt!(\"field `%s` is already declared\", ident_str));\n                             self.session.span_note(prev_field.span,\n                                 \"Previously declared here\");\n@@ -4055,15 +4057,15 @@ impl Resolver {\n             for (&key, &binding_0) in map_0.iter() {\n                 match map_i.find(&key) {\n                   None => {\n-                    self.session.span_err(\n+                    self.resolve_error(\n                         p.span,\n                         fmt!(\"variable `%s` from pattern #1 is \\\n                                   not bound in pattern #%u\",\n                              self.session.str_of(key), i + 1));\n                   }\n                   Some(binding_i) => {\n                     if binding_0.binding_mode != binding_i.binding_mode {\n-                        self.session.span_err(\n+                        self.resolve_error(\n                             binding_i.span,\n                             fmt!(\"variable `%s` is bound with different \\\n                                       mode in pattern #%u than in pattern #1\",\n@@ -4075,7 +4077,7 @@ impl Resolver {\n \n             for (&key, &binding) in map_i.iter() {\n                 if !map_0.contains_key(&key) {\n-                    self.session.span_err(\n+                    self.resolve_error(\n                         binding.span,\n                         fmt!(\"variable `%s` from pattern #%u is \\\n                                   not bound in pattern #1\",\n@@ -4188,7 +4190,7 @@ impl Resolver {\n                         self.record_def(path_id, def);\n                     }\n                     None => {\n-                        self.session.span_err\n+                        self.resolve_error\n                             (ty.span, fmt!(\"use of undeclared type name `%s`\",\n                                            self.idents_to_str(path.idents)));\n                     }\n@@ -4256,7 +4258,7 @@ impl Resolver {\n                             self.record_def(pattern.id, def);\n                         }\n                         FoundStructOrEnumVariant(_) => {\n-                            self.session.span_err(pattern.span,\n+                            self.resolve_error(pattern.span,\n                                                   fmt!(\"declaration of `%s` \\\n                                                         shadows an enum \\\n                                                         variant or unit-like \\\n@@ -4276,7 +4278,7 @@ impl Resolver {\n                             self.record_def(pattern.id, def);\n                         }\n                         FoundConst(_) => {\n-                            self.session.span_err(pattern.span,\n+                            self.resolve_error(pattern.span,\n                                                   \"only refutable patterns \\\n                                                    allowed here\");\n                         }\n@@ -4330,7 +4332,7 @@ impl Resolver {\n                                       // Then this is a duplicate variable\n                                       // in the same disjunct, which is an\n                                       // error\n-                                     self.session.span_err(pattern.span,\n+                                     self.resolve_error(pattern.span,\n                                        fmt!(\"Identifier `%s` is bound more \\\n                                              than once in the same pattern\",\n                                             path_to_str(path, self.session\n@@ -4370,14 +4372,14 @@ impl Resolver {\n                             self.record_def(pattern.id, def);\n                         }\n                         Some(_) => {\n-                            self.session.span_err(\n+                            self.resolve_error(\n                                 path.span,\n                                 fmt!(\"`%s` is not an enum variant or constant\",\n                                      self.session.str_of(\n                                          *path.idents.last())));\n                         }\n                         None => {\n-                            self.session.span_err(path.span,\n+                            self.resolve_error(path.span,\n                                                   \"unresolved enum variant\");\n                         }\n                     }\n@@ -4398,14 +4400,14 @@ impl Resolver {\n                             self.record_def(pattern.id, def);\n                         }\n                         Some(_) => {\n-                            self.session.span_err(\n+                            self.resolve_error(\n                                 path.span,\n                                 fmt!(\"`%s` is not an enum variant, struct or const\",\n                                      self.session.str_of(\n                                          *path.idents.last())));\n                         }\n                         None => {\n-                            self.session.span_err(path.span,\n+                            self.resolve_error(path.span,\n                                                   \"unresolved enum variant, \\\n                                                    struct or const\");\n                         }\n@@ -4444,7 +4446,7 @@ impl Resolver {\n                         result => {\n                             debug!(\"(resolving pattern) didn't find struct \\\n                                     def: %?\", result);\n-                            self.session.span_err(\n+                            self.resolve_error(\n                                 path.span,\n                                 fmt!(\"`%s` does not name a structure\",\n                                      self.idents_to_str(path.idents)));\n@@ -4664,7 +4666,7 @@ impl Resolver {\n                                        path.span,\n                                        PathPublicOnlySearch) {\n             Failed => {\n-                self.session.span_err(path.span,\n+                self.resolve_error(path.span,\n                                       fmt!(\"use of undeclared module `%s`\",\n                                            self.idents_to_str(\n                                                module_path_idents)));\n@@ -4732,7 +4734,7 @@ impl Resolver {\n                                                  path.span,\n                                                  PathPublicOrPrivateSearch) {\n             Failed => {\n-                self.session.span_err(path.span,\n+                self.resolve_error(path.span,\n                                       fmt!(\"use of undeclared module `::%s`\",\n                                             self.idents_to_str(\n                                               module_path_idents)));\n@@ -4858,6 +4860,19 @@ impl Resolver {\n         }\n     }\n \n+    fn with_no_errors<T>(@mut self, f: &fn() -> T) -> T {\n+        self.emit_errors = false;\n+        let rs = f();\n+        self.emit_errors = true;\n+        rs\n+    }\n+\n+    fn resolve_error(@mut self, span: span, s: &str) {\n+        if self.emit_errors {\n+            self.session.span_err(span, s);\n+        }\n+    }\n+\n     pub fn find_best_match_for_name(@mut self,\n                                     name: &str,\n                                     max_distance: uint)\n@@ -4957,7 +4972,7 @@ impl Resolver {\n                         // out here.\n                         match def {\n                             def_method(*) => {\n-                                self.session.span_err(expr.span,\n+                                self.resolve_error(expr.span,\n                                                       \"first-class methods \\\n                                                        are not supported\");\n                                 self.session.span_note(expr.span,\n@@ -4974,27 +4989,45 @@ impl Resolver {\n                         let wrong_name = self.idents_to_str(\n                             path.idents);\n                         if self.name_exists_in_scope_struct(wrong_name) {\n-                            self.session.span_err(expr.span,\n+                            self.resolve_error(expr.span,\n                                         fmt!(\"unresolved name `%s`. \\\n                                             Did you mean `self.%s`?\",\n                                         wrong_name,\n                                         wrong_name));\n                         }\n                         else {\n-                            // limit search to 5 to reduce the number\n-                            // of stupid suggestions\n-                            match self.find_best_match_for_name(wrong_name, 5) {\n-                                Some(m) => {\n-                                    self.session.span_err(expr.span,\n-                                            fmt!(\"unresolved name `%s`. \\\n-                                                Did you mean `%s`?\",\n-                                                wrong_name, m));\n-                                }\n-                                None => {\n-                                    self.session.span_err(expr.span,\n-                                            fmt!(\"unresolved name `%s`.\",\n-                                                wrong_name));\n+                            // Be helpful if the name refers to a struct\n+                            // (The pattern matching def_tys where the id is in self.structs\n+                            // matches on regular structs while excluding tuple- and enum-like\n+                            // structs, which wouldn't result in this error.)\n+                            match self.with_no_errors(||\n+                                self.resolve_path(expr.id, path, TypeNS, false, visitor)) {\n+                                Some(def_ty(struct_id))\n+                                  if self.structs.contains(&struct_id) => {\n+                                    self.resolve_error(expr.span,\n+                                            fmt!(\"`%s` is a structure name, but this expression \\\n+                                                uses it like a function name\", wrong_name));\n+\n+                                    self.session.span_note(expr.span, fmt!(\"Did you mean to write: \\\n+                                                `%s { /* fields */ }`?\", wrong_name));\n+\n                                 }\n+                                _ =>\n+                                   // limit search to 5 to reduce the number\n+                                   // of stupid suggestions\n+                                   match self.find_best_match_for_name(wrong_name, 5) {\n+                                       Some(m) => {\n+                                           self.resolve_error(expr.span,\n+                                               fmt!(\"unresolved name `%s`. \\\n+                                                   Did you mean `%s`?\",\n+                                                   wrong_name, m));\n+                                       }\n+                                       None => {\n+                                           self.resolve_error(expr.span,\n+                                                fmt!(\"unresolved name `%s`.\",\n+                                                    wrong_name));\n+                                       }\n+                                   }\n                             }\n                         }\n                     }\n@@ -5027,7 +5060,7 @@ impl Resolver {\n                     result => {\n                         debug!(\"(resolving expression) didn't find struct \\\n                                 def: %?\", result);\n-                        self.session.span_err(\n+                        self.resolve_error(\n                             path.span,\n                             fmt!(\"`%s` does not name a structure\",\n                                  self.idents_to_str(path.idents)));\n@@ -5056,7 +5089,7 @@ impl Resolver {\n                 match self.search_ribs(self.label_ribs, label, expr.span,\n                                        DontAllowCapturingSelf) {\n                     None =>\n-                        self.session.span_err(expr.span,\n+                        self.resolve_error(expr.span,\n                                               fmt!(\"use of undeclared label \\\n                                                    `%s`\",\n                                                    self.session.str_of(\n@@ -5075,7 +5108,7 @@ impl Resolver {\n             expr_self => {\n                 match self.resolve_self_value_in_local_ribs(expr.span) {\n                     None => {\n-                        self.session.span_err(expr.span,\n+                        self.resolve_error(expr.span,\n                                               \"`self` is not allowed in \\\n                                                this context\")\n                     }\n@@ -5306,7 +5339,7 @@ impl Resolver {\n         match pat_binding_mode {\n             bind_infer => {}\n             bind_by_ref(*) => {\n-                self.session.span_err(\n+                self.resolve_error(\n                     pat.span,\n                     fmt!(\"cannot use `ref` binding mode with %s\",\n                          descr));"}, {"sha": "d130ef249ef1c7165223f1f7e23e8f24391fc7d9", "filename": "src/librustpkg/tests.rs", "status": "modified", "additions": 46, "deletions": 21, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/8e776c75e9694c2e1711943652c64a5e076afa8f/src%2Flibrustpkg%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e776c75e9694c2e1711943652c64a5e076afa8f/src%2Flibrustpkg%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftests.rs?ref=8e776c75e9694c2e1711943652c64a5e076afa8f", "patch": "@@ -473,13 +473,16 @@ fn test_install_invalid() {\n }\n \n // Tests above should (maybe) be converted to shell out to rustpkg, too\n-\n+#[test]\n fn test_install_git() {\n     let sysroot = test_sysroot();\n     debug!(\"sysroot = %s\", sysroot.to_str());\n     let temp_pkg_id = git_repo_pkg();\n     let repo = init_git_repo(&temp_pkg_id.path);\n-    let repo_subdir = repo.push(\"mockgithub.com\").push(\"catamorphism\").push(\"test_pkg\");\n+    debug!(\"repo = %s\", repo.to_str());\n+    let repo_subdir = repo.push(\"mockgithub.com\").push(\"catamorphism\").push(\"test-pkg\");\n+    debug!(\"repo_subdir = %s\", repo_subdir.to_str());\n+\n     writeFile(&repo_subdir.push(\"main.rs\"),\n               \"fn main() { let _x = (); }\");\n     writeFile(&repo_subdir.push(\"lib.rs\"),\n@@ -494,30 +497,28 @@ fn test_install_git() {\n            temp_pkg_id.path.to_str(), repo.to_str());\n     // should have test, bench, lib, and main\n     command_line_test([~\"install\", temp_pkg_id.path.to_str()], &repo);\n+    let ws = repo.push(\".rust\");\n     // Check that all files exist\n-    debug!(\"Checking for files in %s\", repo.to_str());\n-    let exec = target_executable_in_workspace(&temp_pkg_id, &repo);\n+    debug!(\"Checking for files in %s\", ws.to_str());\n+    let exec = target_executable_in_workspace(&temp_pkg_id, &ws);\n     debug!(\"exec = %s\", exec.to_str());\n     assert!(os::path_exists(&exec));\n     assert!(is_rwx(&exec));\n     let _built_lib =\n         built_library_in_workspace(&temp_pkg_id,\n-                                   &repo).expect(\"test_install_git: built lib should exist\");\n-    let lib = target_library_in_workspace(&temp_pkg_id, &repo);\n-    debug!(\"lib = %s\", lib.to_str());\n-    assert!(os::path_exists(&lib));\n-    assert!(is_rwx(&lib));\n+                                   &ws).expect(\"test_install_git: built lib should exist\");\n+    assert_lib_exists(&ws, temp_pkg_id.short_name, temp_pkg_id.version.clone());\n     let built_test = built_test_in_workspace(&temp_pkg_id,\n-                         &repo).expect(\"test_install_git: built test should exist\");\n+                         &ws).expect(\"test_install_git: built test should exist\");\n     assert!(os::path_exists(&built_test));\n     let built_bench = built_bench_in_workspace(&temp_pkg_id,\n-                          &repo).expect(\"test_install_git: built bench should exist\");\n+                          &ws).expect(\"test_install_git: built bench should exist\");\n     assert!(os::path_exists(&built_bench));\n     // And that the test and bench executables aren't installed\n-    let test = target_test_in_workspace(&temp_pkg_id, &repo);\n+    let test = target_test_in_workspace(&temp_pkg_id, &ws);\n     assert!(!os::path_exists(&test));\n     debug!(\"test = %s\", test.to_str());\n-    let bench = target_bench_in_workspace(&temp_pkg_id, &repo);\n+    let bench = target_bench_in_workspace(&temp_pkg_id, &ws);\n     debug!(\"bench = %s\", bench.to_str());\n     assert!(!os::path_exists(&bench));\n }\n@@ -563,6 +564,7 @@ fn test_package_ids_must_be_relative_path_like() {\n \n }\n \n+#[test]\n fn test_package_version() {\n     let local_path = \"mockgithub.com/catamorphism/test_pkg_version\";\n     let repo = init_git_repo(&Path(local_path));\n@@ -578,28 +580,27 @@ fn test_package_version() {\n               \"#[bench] pub fn f() { (); }\");\n     add_git_tag(&repo_subdir, ~\"0.4\");\n \n+    // It won't pick up the 0.4 version because the dir isn't in the RUST_PATH, but...\n     let temp_pkg_id = PkgId::new(\"mockgithub.com/catamorphism/test_pkg_version\");\n-    match temp_pkg_id.version {\n-        ExactRevision(~\"0.4\") => (),\n-        _ => fail!(fmt!(\"test_package_version: package version was %?, expected Some(0.4)\",\n-                        temp_pkg_id.version))\n-    }\n     // This should look at the prefix, clone into a workspace, then build.\n     command_line_test([~\"install\", ~\"mockgithub.com/catamorphism/test_pkg_version\"],\n                       &repo);\n+    let ws = repo.push(\".rust\");\n+    // we can still match on the filename to make sure it contains the 0.4 version\n     assert!(match built_library_in_workspace(&temp_pkg_id,\n-                                             &repo) {\n+                                             &ws) {\n         Some(p) => p.to_str().ends_with(fmt!(\"0.4%s\", os::consts::DLL_SUFFIX)),\n         None    => false\n     });\n-    assert!(built_executable_in_workspace(&temp_pkg_id, &repo)\n-            == Some(repo.push(\"build\").\n+    assert!(built_executable_in_workspace(&temp_pkg_id, &ws)\n+            == Some(ws.push(\"build\").\n                     push(\"mockgithub.com\").\n                     push(\"catamorphism\").\n                     push(\"test_pkg_version\").\n                     push(\"test_pkg_version\")));\n }\n \n+#[test]\n fn test_package_request_version() {\n     let local_path = \"mockgithub.com/catamorphism/test_pkg_version\";\n     let repo = init_git_repo(&Path(local_path));\n@@ -1034,6 +1035,30 @@ fn test_extern_mod() {\n     assert!(os::path_exists(&exec_file) && is_executable(&exec_file));\n }\n \n+#[test]\n+fn test_import_rustpkg() {\n+    let p_id = PkgId::new(\"foo\");\n+    let workspace = create_local_package(&p_id);\n+    writeFile(&workspace.push(\"src\").push(\"foo-0.1\").push(\"pkg.rs\"),\n+              \"extern mod rustpkg; fn main() {}\");\n+    command_line_test([~\"build\", ~\"foo\"], &workspace);\n+    debug!(\"workspace = %s\", workspace.to_str());\n+    assert!(os::path_exists(&workspace.push(\"build\").push(\"foo\").push(fmt!(\"pkg%s\",\n+        os::EXE_SUFFIX))));\n+}\n+\n+#[test]\n+fn test_macro_pkg_script() {\n+    let p_id = PkgId::new(\"foo\");\n+    let workspace = create_local_package(&p_id);\n+    writeFile(&workspace.push(\"src\").push(\"foo-0.1\").push(\"pkg.rs\"),\n+              \"extern mod rustpkg; fn main() { debug!(\\\"Hi\\\"); }\");\n+    command_line_test([~\"build\", ~\"foo\"], &workspace);\n+    debug!(\"workspace = %s\", workspace.to_str());\n+    assert!(os::path_exists(&workspace.push(\"build\").push(\"foo\").push(fmt!(\"pkg%s\",\n+        os::EXE_SUFFIX))));\n+}\n+\n /// Returns true if p exists and is executable\n fn is_executable(p: &Path) -> bool {\n     use std::libc::consts::os::posix88::{S_IXUSR};"}, {"sha": "d001e2c6970f89a39b9037195b4a995697c22c6e", "filename": "src/libstd/at_vec.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8e776c75e9694c2e1711943652c64a5e076afa8f/src%2Flibstd%2Fat_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e776c75e9694c2e1711943652c64a5e076afa8f/src%2Flibstd%2Fat_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fat_vec.rs?ref=8e776c75e9694c2e1711943652c64a5e076afa8f", "patch": "@@ -255,8 +255,6 @@ pub mod raw {\n         if capacity(*v) < n {\n             let ptr: *mut *mut Box<Vec<()>> = transmute(v);\n             let ty = intrinsics::get_tydesc::<T>();\n-            // XXX transmute shouldn't be necessary\n-            let ty = cast::transmute(ty);\n             return reserve_raw(ty, ptr, n);\n         }\n     }"}, {"sha": "6d08b3c84bdedbc3bf6416050339e5758762e872", "filename": "src/libstd/rand/distributions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8e776c75e9694c2e1711943652c64a5e076afa8f/src%2Flibstd%2Frand%2Fdistributions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e776c75e9694c2e1711943652c64a5e076afa8f/src%2Flibstd%2Frand%2Fdistributions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fdistributions.rs?ref=8e776c75e9694c2e1711943652c64a5e076afa8f", "patch": "@@ -92,7 +92,7 @@ impl Rand for StandardNormal {\n             let mut x = 1.0f64;\n             let mut y = 0.0f64;\n \n-            // XXX infinities?\n+            // FIXME #7755: infinities?\n             while -2.0 * y < x * x {\n                 x = rng.gen::<f64>().ln() / ziggurat_tables::ZIG_NORM_R;\n                 y = rng.gen::<f64>().ln();"}, {"sha": "baaf3d44e79d3b22231985f60255dd6ec6d5afdd", "filename": "src/libstd/rt/args.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8e776c75e9694c2e1711943652c64a5e076afa8f/src%2Flibstd%2Frt%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e776c75e9694c2e1711943652c64a5e076afa8f/src%2Flibstd%2Frt%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fargs.rs?ref=8e776c75e9694c2e1711943652c64a5e076afa8f", "patch": "@@ -17,8 +17,8 @@\n //! Only valid to call on linux. Mac and Windows use syscalls to\n //! discover the command line arguments.\n //!\n-//! XXX: Would be nice for this to not exist.\n-//! XXX: This has a lot of C glue for lack of globals.\n+//! FIXME #7756: Would be nice for this to not exist.\n+//! FIXME #7756: This has a lot of C glue for lack of globals.\n \n use option::Option;\n "}, {"sha": "5d55261a69dc3a7e386860c047156bae9caef159", "filename": "src/libstd/rt/comm.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8e776c75e9694c2e1711943652c64a5e076afa8f/src%2Flibstd%2Frt%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e776c75e9694c2e1711943652c64a5e076afa8f/src%2Flibstd%2Frt%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fcomm.rs?ref=8e776c75e9694c2e1711943652c64a5e076afa8f", "patch": "@@ -46,7 +46,7 @@ struct Packet<T> {\n     payload: Option<T>,\n }\n \n-/// A one-shot channel.\n+// A one-shot channel.\n pub struct ChanOne<T> {\n     void_packet: *mut Void,\n     suppress_finalize: bool\n@@ -681,7 +681,7 @@ impl<T> Clone for SharedPort<T> {\n     }\n }\n \n-// XXX: Need better name\n+// FIXME #7760: Need better name\n type MegaPipe<T> = (SharedPort<T>, SharedChan<T>);\n \n pub fn megapipe<T: Send>() -> MegaPipe<T> {\n@@ -1027,9 +1027,8 @@ mod test {\n     fn shared_port_stress() {\n         if util::limit_thread_creation_due_to_osx_and_valgrind() { return; }\n         do run_in_mt_newsched_task {\n-            // XXX: Removing these type annotations causes an ICE\n-            let (end_port, end_chan) = stream::<()>();\n-            let (port, chan) = stream::<()>();\n+            let (end_port, end_chan) = stream();\n+            let (port, chan) = stream();\n             let end_chan = SharedChan::new(end_chan);\n             let port = SharedPort::new(port);\n             let total = stress_factor() + 100;"}, {"sha": "5aaddc68383f1e34171aff4f29347f6970e275e0", "filename": "src/libstd/rt/context.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8e776c75e9694c2e1711943652c64a5e076afa8f/src%2Flibstd%2Frt%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e776c75e9694c2e1711943652c64a5e076afa8f/src%2Flibstd%2Frt%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fcontext.rs?ref=8e776c75e9694c2e1711943652c64a5e076afa8f", "patch": "@@ -14,10 +14,10 @@ use libc::c_void;\n use cast::{transmute, transmute_mut_unsafe,\n            transmute_region, transmute_mut_region};\n \n-// XXX: Registers is boxed so that it is 16-byte aligned, for storing\n+// FIXME #7761: Registers is boxed so that it is 16-byte aligned, for storing\n // SSE regs.  It would be marginally better not to do this. In C++ we\n // use an attribute on a struct.\n-// XXX: It would be nice to define regs as `~Option<Registers>` since\n+// FIXME #7761: It would be nice to define regs as `~Option<Registers>` since\n // the registers are sometimes empty, but the discriminant would\n // then misalign the regs again.\n pub struct Context {\n@@ -37,7 +37,7 @@ impl Context {\n \n     /// Create a new context that will resume execution by running ~fn()\n     pub fn new(start: ~fn(), stack: &mut StackSegment) -> Context {\n-        // XXX: Putting main into a ~ so it's a thin pointer and can\n+        // FIXME #7767: Putting main into a ~ so it's a thin pointer and can\n         // be passed to the spawn function.  Another unfortunate\n         // allocation\n         let start = ~start;\n@@ -206,7 +206,7 @@ fn align_down(sp: *mut uint) -> *mut uint {\n     }\n }\n \n-// XXX: ptr::offset is positive ints only\n+// ptr::mut_offset is positive ints only\n #[inline]\n pub fn mut_offset<T>(ptr: *mut T, count: int) -> *mut T {\n     use std::sys::size_of;"}, {"sha": "3ce04a902e2bdb2cd6bc3a2c17fa3cb6d11341a5", "filename": "src/libstd/rt/io/extensions.rs", "status": "modified", "additions": 26, "deletions": 25, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/8e776c75e9694c2e1711943652c64a5e076afa8f/src%2Flibstd%2Frt%2Fio%2Fextensions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e776c75e9694c2e1711943652c64a5e076afa8f/src%2Flibstd%2Frt%2Fio%2Fextensions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fextensions.rs?ref=8e776c75e9694c2e1711943652c64a5e076afa8f", "patch": "@@ -229,7 +229,7 @@ pub trait WriterByteConversions {\n     fn write_be_i64(&mut self, n: i64);\n \n     /// Write a big-endian i32 (4 bytes).\n-    fn write_be_i32(&mut self, n: i32);\n+    fn write_be_i32_(&mut self, n: i32);\n \n     /// Write a big-endian i16 (2 bytes).\n     fn write_be_i16(&mut self, n: i16);\n@@ -238,7 +238,7 @@ pub trait WriterByteConversions {\n     fn write_be_f64(&mut self, f: f64);\n \n     /// Write a big-endian IEEE754 single-precision floating-point (4 bytes).\n-    fn write_be_f32(&mut self, f: f32);\n+    fn write_be_f32_(&mut self, f: f32);\n \n     /// Write a little-endian u64 (8 bytes).\n     fn write_le_u64_(&mut self, n: u64);\n@@ -264,7 +264,7 @@ pub trait WriterByteConversions {\n \n     /// Write a little-endian IEEE754 single-precision floating-point\n     /// (4 bytes).\n-    fn write_le_f32(&mut self, f: f32);\n+    fn write_le_f32_(&mut self, f: f32);\n \n     /// Write a u8 (1 byte).\n     fn write_u8(&mut self, n: u8);\n@@ -519,7 +519,7 @@ impl<T: Writer> WriterByteConversions for T {\n         u64_to_be_bytes(n as u64, 8u, |v| self.write(v))\n     }\n \n-    fn write_be_i32(&mut self, n: i32) {\n+    fn write_be_i32_(&mut self, n: i32) {\n         u64_to_be_bytes(n as u64, 4u, |v| self.write(v))\n     }\n \n@@ -533,7 +533,7 @@ impl<T: Writer> WriterByteConversions for T {\n         }\n     }\n \n-    fn write_be_f32(&mut self, f: f32) {\n+    fn write_be_f32_(&mut self, f: f32) {\n         unsafe {\n             self.write_be_u32(cast::transmute(f))\n         }\n@@ -569,7 +569,7 @@ impl<T: Writer> WriterByteConversions for T {\n         }\n     }\n \n-    fn write_le_f32(&mut self, f: f32) {\n+    fn write_le_f32_(&mut self, f: f32) {\n         unsafe {\n             self.write_le_u32(cast::transmute(f))\n         }\n@@ -594,7 +594,7 @@ mod test {\n     use super::ReaderUtil;\n     use option::{Some, None};\n     use cell::Cell;\n-    use rt::io::mem::MemReader;\n+    use rt::io::mem::{MemReader, MemWriter};\n     use rt::io::mock::MockReader;\n     use rt::io::{read_error, placeholder_error};\n \n@@ -827,48 +827,49 @@ mod test {\n         assert!(buf == ~[10, 11]);\n     }\n \n-    // XXX: Some problem with resolve here\n-    /*#[test]\n-    fn test_read_write_le() {\n-        let uints = [0, 1, 2, 42, 10_123, 100_123_456, u64::max_value];\n+\n+    #[test]\n+    fn test_read_write_le_mem() {\n+        let uints = [0, 1, 2, 42, 10_123, 100_123_456, ::u64::max_value];\n \n         let mut writer = MemWriter::new();\n-        for uints.each |i| {\n-            writer.write_le_u64(*i);\n+        for i in uints.iter() {\n+            writer.write_le_u64_(*i);\n         }\n \n         let mut reader = MemReader::new(writer.inner());\n-        for uints.each |i| {\n+        for i in uints.iter() {\n             assert!(reader.read_le_u64() == *i);\n         }\n     }\n \n+\n     #[test]\n     fn test_read_write_be() {\n-        let uints = [0, 1, 2, 42, 10_123, 100_123_456, u64::max_value];\n+        let uints = [0, 1, 2, 42, 10_123, 100_123_456, ::u64::max_value];\n \n         let mut writer = MemWriter::new();\n-        for uints.each |i| {\n-            writer.write_be_u64(*i);\n+        for i in uints.iter() {\n+            writer.write_be_u64_(*i);\n         }\n \n         let mut reader = MemReader::new(writer.inner());\n-        for uints.each |i| {\n+        for i in uints.iter() {\n             assert!(reader.read_be_u64() == *i);\n         }\n     }\n \n     #[test]\n     fn test_read_be_int_n() {\n-        let ints = [i32::min_value, -123456, -42, -5, 0, 1, i32::max_value];\n+        let ints = [::i32::min_value, -123456, -42, -5, 0, 1, ::i32::max_value];\n \n         let mut writer = MemWriter::new();\n-        for ints.each |i| {\n-            writer.write_be_i32(*i);\n+        for i in ints.iter() {\n+            writer.write_be_i32_(*i);\n         }\n \n         let mut reader = MemReader::new(writer.inner());\n-        for ints.each |i| {\n+        for i in ints.iter() {\n             // this tests that the sign extension is working\n             // (comparing the values as i32 would not test this)\n             assert!(reader.read_be_int_n(4) == *i as i64);\n@@ -893,12 +894,12 @@ mod test {\n         let f:f32 = 8.1250;\n \n         let mut writer = MemWriter::new();\n-        writer.write_be_f32(f);\n-        writer.write_le_f32(f);\n+        writer.write_be_f32_(f);\n+        writer.write_le_f32_(f);\n \n         let mut reader = MemReader::new(writer.inner());\n         assert!(reader.read_be_f32() == 8.1250);\n         assert!(reader.read_le_f32() == 8.1250);\n-    }*/\n+    }\n \n }"}, {"sha": "9128961165900a1e4257878ec9ae3d24f2c65ddb", "filename": "src/libstd/rt/io/file.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8e776c75e9694c2e1711943652c64a5e076afa8f/src%2Flibstd%2Frt%2Fio%2Ffile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e776c75e9694c2e1711943652c64a5e076afa8f/src%2Flibstd%2Frt%2Fio%2Ffile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Ffile.rs?ref=8e776c75e9694c2e1711943652c64a5e076afa8f", "patch": "@@ -13,7 +13,7 @@ use super::support::PathLike;\n use super::{Reader, Writer, Seek};\n use super::SeekStyle;\n \n-/// # XXX\n+/// # FIXME #7785\n /// * Ugh, this is ridiculous. What is the best way to represent these options?\n enum FileMode {\n     /// Opens an existing file. IoError if file does not exist."}, {"sha": "278df5b170e4bb3db035e1c7f2d82c1cc46e6496", "filename": "src/libstd/std.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8e776c75e9694c2e1711943652c64a5e076afa8f/src%2Flibstd%2Fstd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e776c75e9694c2e1711943652c64a5e076afa8f/src%2Flibstd%2Fstd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstd.rs?ref=8e776c75e9694c2e1711943652c64a5e076afa8f", "patch": "@@ -198,7 +198,7 @@ mod unicode;\n #[path = \"num/cmath.rs\"]\n mod cmath;\n \n-// XXX: This shouldn't be pub, and it should be reexported under 'unstable'\n+// FIXME #7809: This shouldn't be pub, and it should be reexported under 'unstable'\n // but name resolution doesn't work without it being pub.\n pub mod rt;\n "}, {"sha": "5ffa03dec26d192b9921385145c2327ac4dc4351", "filename": "src/libstd/task/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8e776c75e9694c2e1711943652c64a5e076afa8f/src%2Flibstd%2Ftask%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e776c75e9694c2e1711943652c64a5e076afa8f/src%2Flibstd%2Ftask%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask%2Fmod.rs?ref=8e776c75e9694c2e1711943652c64a5e076afa8f", "patch": "@@ -543,7 +543,7 @@ pub fn deschedule() {\n     use rt::local::Local;\n     use rt::sched::Scheduler;\n \n-    // XXX: What does yield really mean in newsched?\n+    // FIXME #6842: What does yield really mean in newsched?\n     // FIXME(#7544): Optimize this, since we know we won't block.\n     let sched = Local::take::<Scheduler>();\n     do sched.deschedule_running_task_and_then |sched, task| {"}, {"sha": "135f71621575a778adc18006f38a2d9b4129e68e", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/8e776c75e9694c2e1711943652c64a5e076afa8f/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e776c75e9694c2e1711943652c64a5e076afa8f/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=8e776c75e9694c2e1711943652c64a5e076afa8f", "patch": "@@ -5061,12 +5061,19 @@ impl Parser {\n         }\n     }\n \n-    pub fn parse_str(&self) -> @str {\n+    pub fn parse_optional_str(&self) -> Option<@str> {\n         match *self.token {\n             token::LIT_STR(s) => {\n                 self.bump();\n-                ident_to_str(&s)\n+                Some(ident_to_str(&s))\n             }\n+            _ => None\n+        }\n+    }\n+\n+    pub fn parse_str(&self) -> @str {\n+        match self.parse_optional_str() {\n+            Some(s) => { s }\n             _ =>  self.fatal(\"expected string literal\")\n         }\n     }"}, {"sha": "1903786eef85190e5ce069f0d7f7f9245776a3cf", "filename": "src/test/compile-fail/attrs-after-extern-mod.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/8e776c75e9694c2e1711943652c64a5e076afa8f/src%2Ftest%2Fcompile-fail%2Fattrs-after-extern-mod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e776c75e9694c2e1711943652c64a5e076afa8f/src%2Ftest%2Fcompile-fail%2Fattrs-after-extern-mod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fattrs-after-extern-mod.rs?ref=8e776c75e9694c2e1711943652c64a5e076afa8f", "patch": "@@ -0,0 +1,24 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Constants (static variables) can be used to match in patterns, but mutable\n+// statics cannot. This ensures that there's some form of error if this is\n+// attempted.\n+\n+use std::libc;\n+\n+#[nolink]\n+extern {\n+    static mut debug_static_mut: libc::c_int;\n+    pub fn debug_static_mut_check_four();\n+    #[cfg(stage37)] //~ ERROR expected item after attributes\n+}\n+\n+pub fn main() {}"}, {"sha": "a54f05ec3480729d6820fde0fb5c96cfdafb7b08", "filename": "src/test/compile-fail/issue-6458-1.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8e776c75e9694c2e1711943652c64a5e076afa8f/src%2Ftest%2Fcompile-fail%2Fissue-6458-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e776c75e9694c2e1711943652c64a5e076afa8f/src%2Ftest%2Fcompile-fail%2Fissue-6458-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-6458-1.rs?ref=8e776c75e9694c2e1711943652c64a5e076afa8f", "patch": "@@ -0,0 +1,12 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn foo<T>(t: T) {}\n+fn main() { foo(fail!()) } //~ ERROR cannot determine a type for this expression: unconstrained type"}, {"sha": "8621b37146ff309074673c89e597a7f433bd29d3", "filename": "src/test/compile-fail/issue-6458-2.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/8e776c75e9694c2e1711943652c64a5e076afa8f/src%2Ftest%2Fcompile-fail%2Fissue-6458-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e776c75e9694c2e1711943652c64a5e076afa8f/src%2Ftest%2Fcompile-fail%2Fissue-6458-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-6458-2.rs?ref=8e776c75e9694c2e1711943652c64a5e076afa8f", "patch": "@@ -0,0 +1,13 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn main() {\n+    fmt!(\"%?\", None); //~ ERROR: cannot determine a type for this expression: unconstrained type\n+}"}, {"sha": "ac41cc116825a83cd2b9812cb62efc692b0dc022", "filename": "src/test/compile-fail/issue-6458-3.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/8e776c75e9694c2e1711943652c64a5e076afa8f/src%2Ftest%2Fcompile-fail%2Fissue-6458-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e776c75e9694c2e1711943652c64a5e076afa8f/src%2Ftest%2Fcompile-fail%2Fissue-6458-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-6458-3.rs?ref=8e776c75e9694c2e1711943652c64a5e076afa8f", "patch": "@@ -0,0 +1,15 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::cast;\n+\n+fn main() {\n+    cast::transmute(0);  //~ ERROR: cannot determine a type for this expression: unconstrained type\n+}"}, {"sha": "131d9c824b63c4def578045fdd07bdc375d097fb", "filename": "src/test/compile-fail/issue-6458-4.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/8e776c75e9694c2e1711943652c64a5e076afa8f/src%2Ftest%2Fcompile-fail%2Fissue-6458-4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e776c75e9694c2e1711943652c64a5e076afa8f/src%2Ftest%2Fcompile-fail%2Fissue-6458-4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-6458-4.rs?ref=8e776c75e9694c2e1711943652c64a5e076afa8f", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn foo(b: bool) -> Result<bool,~str> {\n+    Err(~\"bar\"); //~ ERROR: cannot determine a type for this expression: unconstrained type\n+}\n+\n+fn main() {\n+    foo(false);\n+}"}, {"sha": "8d9c63687ffad827f537499d038ad96d27abf462", "filename": "src/test/compile-fail/issue-6458.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/8e776c75e9694c2e1711943652c64a5e076afa8f/src%2Ftest%2Fcompile-fail%2Fissue-6458.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e776c75e9694c2e1711943652c64a5e076afa8f/src%2Ftest%2Fcompile-fail%2Fissue-6458.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-6458.rs?ref=8e776c75e9694c2e1711943652c64a5e076afa8f", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+pub struct TypeWithState<State>;\n+pub struct MyState;\n+\n+pub fn foo<State>(_: TypeWithState<State>) {}\n+\n+pub fn bar() {\n+   foo(TypeWithState); //~ ERROR: cannot determine a type for this expression: unconstrained type\n+}\n+\n+fn main() {\n+}"}, {"sha": "168aa5f9d691f5f59aad6a74a2ece5ae3c8c88fa", "filename": "src/test/compile-fail/issue-6702.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/8e776c75e9694c2e1711943652c64a5e076afa8f/src%2Ftest%2Fcompile-fail%2Fissue-6702.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e776c75e9694c2e1711943652c64a5e076afa8f/src%2Ftest%2Fcompile-fail%2Fissue-6702.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-6702.rs?ref=8e776c75e9694c2e1711943652c64a5e076afa8f", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+struct Monster {\n+    damage: int\n+}\n+\n+\n+fn main() {\n+    let _m = Monster(); //~ ERROR `Monster` is a structure name, but\n+    //~^ NOTE Did you mean to write: `Monster { /* fields */ }`?\n+}"}, {"sha": "fa22665e8c35517d80dbdff504d6d016729b29a0", "filename": "src/test/compile-fail/issue-7013.rs", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/8e776c75e9694c2e1711943652c64a5e076afa8f/src%2Ftest%2Fcompile-fail%2Fissue-7013.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e776c75e9694c2e1711943652c64a5e076afa8f/src%2Ftest%2Fcompile-fail%2Fissue-7013.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-7013.rs?ref=8e776c75e9694c2e1711943652c64a5e076afa8f", "patch": "@@ -0,0 +1,43 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+extern mod extra;\n+use extra::rc::RcMut;\n+\n+trait Foo\n+{\n+    fn set(&mut self, v: RcMut<A>);\n+}\n+\n+struct B\n+{\n+    v: Option<RcMut<A>>\n+}\n+\n+impl Foo for B\n+{\n+    fn set(&mut self, v: RcMut<A>)\n+    {\n+        self.v = Some(v);\n+    }\n+}\n+\n+struct A\n+{\n+    v: ~Foo,\n+}\n+\n+fn main()\n+{\n+    let a = A {v: ~B{v: None} as ~Foo}; //~ ERROR cannot pack type `~B`, which does not fulfill `Send`\n+    let v = RcMut::from_freeze(a); //~ ERROR instantiating a type parameter with an incompatible type\n+    let w = v.clone();\n+    v.with_mut_borrow(|p| {p.v.set(w.clone());})\n+}"}, {"sha": "3e588bb53d2a6e53b7992d5bf9f3ca68d49584a1", "filename": "src/test/run-pass/issue-5917.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8e776c75e9694c2e1711943652c64a5e076afa8f/src%2Ftest%2Frun-pass%2Fissue-5917.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e776c75e9694c2e1711943652c64a5e076afa8f/src%2Ftest%2Frun-pass%2Fissue-5917.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-5917.rs?ref=8e776c75e9694c2e1711943652c64a5e076afa8f", "patch": "@@ -8,12 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// xfail-test\n-\n use std::io;\n \n struct T (&'static [int]);\n static t : T = T (&'static [5, 4, 3]);\n fn main () {\n     assert_eq!(t[0], 5);\n-}\n\\ No newline at end of file\n+}"}, {"sha": "4ee552394768aa631e1cd145b74696d4c95c27c1", "filename": "src/test/run-pass/owned-implies-static.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/8e776c75e9694c2e1711943652c64a5e076afa8f/src%2Ftest%2Frun-pass%2Fowned-implies-static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e776c75e9694c2e1711943652c64a5e076afa8f/src%2Ftest%2Frun-pass%2Fowned-implies-static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fowned-implies-static.rs?ref=8e776c75e9694c2e1711943652c64a5e076afa8f", "patch": "@@ -0,0 +1,15 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn f<T: 'static>(_x: T) {}\n+\n+fn main() {\n+    f(~5);\n+}"}]}