{"sha": "8828049b2398b0df3bfc76d06bcf5154cdbe536a", "node_id": "C_kwDOAAsO6NoAKDg4MjgwNDliMjM5OGIwZGYzYmZjNzZkMDZiY2Y1MTU0Y2RiZTUzNmE", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2022-09-02T14:57:31Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2022-09-02T15:02:12Z"}, "message": "Lift out the module scope into a field in the Resolver\n\nA Resolver *always* has a module scope at the end of its scope stack,\ninstead of encoding this as an invariant we can just lift this scope\nout into a field, allowing us to skip going through the scope vec\nindirection entirely.", "tree": {"sha": "1ab88cda6240aab7f704bb22aeba0c7aceb3cf6f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1ab88cda6240aab7f704bb22aeba0c7aceb3cf6f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8828049b2398b0df3bfc76d06bcf5154cdbe536a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8828049b2398b0df3bfc76d06bcf5154cdbe536a", "html_url": "https://github.com/rust-lang/rust/commit/8828049b2398b0df3bfc76d06bcf5154cdbe536a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8828049b2398b0df3bfc76d06bcf5154cdbe536a/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2bb6635a852aefe4f1151352f0b11e3a9e2f5b6d", "url": "https://api.github.com/repos/rust-lang/rust/commits/2bb6635a852aefe4f1151352f0b11e3a9e2f5b6d", "html_url": "https://github.com/rust-lang/rust/commit/2bb6635a852aefe4f1151352f0b11e3a9e2f5b6d"}], "stats": {"total": 370, "additions": 211, "deletions": 159}, "files": [{"sha": "22f5fb9926638e0f7ea9413563fbcec4a372483f", "filename": "crates/hir-def/src/body.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/8828049b2398b0df3bfc76d06bcf5154cdbe536a/crates%2Fhir-def%2Fsrc%2Fbody.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8828049b2398b0df3bfc76d06bcf5154cdbe536a/crates%2Fhir-def%2Fsrc%2Fbody.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fbody.rs?ref=8828049b2398b0df3bfc76d06bcf5154cdbe536a", "patch": "@@ -250,6 +250,10 @@ pub type PatSource = InFile<PatPtr>;\n \n pub type LabelPtr = AstPtr<ast::Label>;\n pub type LabelSource = InFile<LabelPtr>;\n+\n+pub type FieldPtr = AstPtr<ast::RecordExprField>;\n+pub type FieldSource = InFile<FieldPtr>;\n+\n /// An item body together with the mapping from syntax nodes to HIR expression\n /// IDs. This is needed to go from e.g. a position in a file to the HIR\n /// expression containing it; but for type inference etc., we want to operate on\n@@ -274,8 +278,8 @@ pub struct BodySourceMap {\n \n     /// We don't create explicit nodes for record fields (`S { record_field: 92 }`).\n     /// Instead, we use id of expression (`92`) to identify the field.\n-    field_map: FxHashMap<InFile<AstPtr<ast::RecordExprField>>, ExprId>,\n-    field_map_back: FxHashMap<ExprId, InFile<AstPtr<ast::RecordExprField>>>,\n+    field_map: FxHashMap<FieldSource, ExprId>,\n+    field_map_back: FxHashMap<ExprId, FieldSource>,\n \n     expansions: FxHashMap<InFile<AstPtr<ast::MacroCall>>, HirFileId>,\n \n@@ -456,9 +460,10 @@ impl BodySourceMap {\n         self.label_map.get(&src).cloned()\n     }\n \n-    pub fn field_syntax(&self, expr: ExprId) -> InFile<AstPtr<ast::RecordExprField>> {\n+    pub fn field_syntax(&self, expr: ExprId) -> FieldSource {\n         self.field_map_back[&expr].clone()\n     }\n+\n     pub fn node_field(&self, node: InFile<&ast::RecordExprField>) -> Option<ExprId> {\n         let src = node.map(AstPtr::new);\n         self.field_map.get(&src).cloned()"}, {"sha": "3b3297f7811c07628ba30e2382531672f2c89c39", "filename": "crates/hir-def/src/body/lower.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8828049b2398b0df3bfc76d06bcf5154cdbe536a/crates%2Fhir-def%2Fsrc%2Fbody%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8828049b2398b0df3bfc76d06bcf5154cdbe536a/crates%2Fhir-def%2Fsrc%2Fbody%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fbody%2Flower.rs?ref=8828049b2398b0df3bfc76d06bcf5154cdbe536a", "patch": "@@ -24,7 +24,7 @@ use syntax::{\n \n use crate::{\n     adt::StructKind,\n-    body::{Body, BodySourceMap, Expander, LabelSource, PatPtr},\n+    body::{Body, BodySourceMap, Expander, ExprPtr, LabelPtr, LabelSource, PatPtr},\n     body::{BodyDiagnostic, ExprSource, PatSource},\n     builtin_type::{BuiltinFloat, BuiltinInt, BuiltinUint},\n     db::DefDatabase,\n@@ -150,7 +150,7 @@ impl ExprCollector<'_> {\n         LowerCtx::new(self.db, self.expander.current_file_id)\n     }\n \n-    fn alloc_expr(&mut self, expr: Expr, ptr: AstPtr<ast::Expr>) -> ExprId {\n+    fn alloc_expr(&mut self, expr: Expr, ptr: ExprPtr) -> ExprId {\n         let src = self.expander.to_source(ptr);\n         let id = self.make_expr(expr, src.clone());\n         self.source_map.expr_map.insert(src, id);\n@@ -185,7 +185,7 @@ impl ExprCollector<'_> {\n         id\n     }\n \n-    fn alloc_label(&mut self, label: Label, ptr: AstPtr<ast::Label>) -> LabelId {\n+    fn alloc_label(&mut self, label: Label, ptr: LabelPtr) -> LabelId {\n         let src = self.expander.to_source(ptr);\n         let id = self.make_label(label, src.clone());\n         self.source_map.label_map.insert(src, id);"}, {"sha": "45f64ebb06007b7c5cf1a414d02930d5a12b203a", "filename": "crates/hir-def/src/body/scope.rs", "status": "modified", "additions": 21, "deletions": 10, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/8828049b2398b0df3bfc76d06bcf5154cdbe536a/crates%2Fhir-def%2Fsrc%2Fbody%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8828049b2398b0df3bfc76d06bcf5154cdbe536a/crates%2Fhir-def%2Fsrc%2Fbody%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fbody%2Fscope.rs?ref=8828049b2398b0df3bfc76d06bcf5154cdbe536a", "patch": "@@ -47,16 +47,9 @@ pub struct ScopeData {\n impl ExprScopes {\n     pub(crate) fn expr_scopes_query(db: &dyn DefDatabase, def: DefWithBodyId) -> Arc<ExprScopes> {\n         let body = db.body(def);\n-        Arc::new(ExprScopes::new(&*body))\n-    }\n-\n-    fn new(body: &Body) -> ExprScopes {\n-        let mut scopes =\n-            ExprScopes { scopes: Arena::default(), scope_by_expr: FxHashMap::default() };\n-        let mut root = scopes.root_scope();\n-        scopes.add_params_bindings(body, root, &body.params);\n-        compute_expr_scopes(body.body_expr, body, &mut scopes, &mut root);\n-        scopes\n+        let mut scopes = ExprScopes::new(&*body);\n+        scopes.shrink_to_fit();\n+        Arc::new(scopes)\n     }\n \n     pub fn entries(&self, scope: ScopeId) -> &[ScopeEntry] {\n@@ -89,6 +82,17 @@ impl ExprScopes {\n     pub fn scope_by_expr(&self) -> &FxHashMap<ExprId, ScopeId> {\n         &self.scope_by_expr\n     }\n+}\n+\n+impl ExprScopes {\n+    fn new(body: &Body) -> ExprScopes {\n+        let mut scopes =\n+            ExprScopes { scopes: Arena::default(), scope_by_expr: FxHashMap::default() };\n+        let mut root = scopes.root_scope();\n+        scopes.add_params_bindings(body, root, &body.params);\n+        compute_expr_scopes(body.body_expr, body, &mut scopes, &mut root);\n+        scopes\n+    }\n \n     fn root_scope(&mut self) -> ScopeId {\n         self.scopes.alloc(ScopeData { parent: None, block: None, label: None, entries: vec![] })\n@@ -138,6 +142,13 @@ impl ExprScopes {\n     fn set_scope(&mut self, node: ExprId, scope: ScopeId) {\n         self.scope_by_expr.insert(node, scope);\n     }\n+\n+    fn shrink_to_fit(&mut self) {\n+        let ExprScopes { scopes, scope_by_expr } = self;\n+        scopes.shrink_to_fit();\n+        scopes.values_mut().for_each(|it| it.entries.shrink_to_fit());\n+        scope_by_expr.shrink_to_fit();\n+    }\n }\n \n fn compute_block_scopes("}, {"sha": "769aa9dcb0caab529eac867c87301568642a9431", "filename": "crates/hir-def/src/resolver.rs", "status": "modified", "additions": 141, "deletions": 141, "changes": 282, "blob_url": "https://github.com/rust-lang/rust/blob/8828049b2398b0df3bfc76d06bcf5154cdbe536a/crates%2Fhir-def%2Fsrc%2Fresolver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8828049b2398b0df3bfc76d06bcf5154cdbe536a/crates%2Fhir-def%2Fsrc%2Fresolver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fresolver.rs?ref=8828049b2398b0df3bfc76d06bcf5154cdbe536a", "patch": "@@ -31,12 +31,10 @@ pub struct Resolver {\n     ///\n     /// When using, you generally want to process the scopes in reverse order,\n     /// there's `scopes` *method* for that.\n-    ///\n-    /// Invariant: There exists at least one Scope::ModuleScope at the start of the vec.\n     scopes: Vec<Scope>,\n+    module_scope: ModuleItemMap,\n }\n \n-// FIXME how to store these best\n #[derive(Debug, Clone)]\n struct ModuleItemMap {\n     def_map: Arc<DefMap>,\n@@ -53,7 +51,7 @@ struct ExprScope {\n #[derive(Debug, Clone)]\n enum Scope {\n     /// All the items and imported names of a module\n-    ModuleScope(ModuleItemMap),\n+    BlockScope(ModuleItemMap),\n     /// Brings the generic parameters of an item into scope\n     GenericParams { def: GenericDefId, params: Interned<GenericParams> },\n     /// Brings `Self` in `impl` block into scope\n@@ -127,24 +125,6 @@ impl Resolver {\n         }\n     }\n \n-    fn scopes(&self) -> impl Iterator<Item = &Scope> {\n-        self.scopes.iter().rev()\n-    }\n-\n-    fn resolve_module_path(\n-        &self,\n-        db: &dyn DefDatabase,\n-        path: &ModPath,\n-        shadow: BuiltinShadowMode,\n-    ) -> PerNs {\n-        let (item_map, module) = self.module_scope();\n-        let (module_res, segment_index) = item_map.resolve_path(db, module, path, shadow);\n-        if segment_index.is_some() {\n-            return PerNs::none();\n-        }\n-        module_res\n-    }\n-\n     pub fn resolve_module_path_in_items(&self, db: &dyn DefDatabase, path: &ModPath) -> PerNs {\n         self.resolve_module_path(db, path, BuiltinShadowMode::Module)\n     }\n@@ -155,7 +135,7 @@ impl Resolver {\n         db: &dyn DefDatabase,\n         path: &ModPath,\n     ) -> Option<PerNs> {\n-        let (item_map, module) = self.module_scope();\n+        let (item_map, module) = self.item_scope();\n         let (module_res, idx) = item_map.resolve_path(db, module, path, BuiltinShadowMode::Module);\n         match module_res.take_types()? {\n             ModuleDefId::TraitId(it) => {\n@@ -183,37 +163,38 @@ impl Resolver {\n     ) -> Option<(TypeNs, Option<usize>)> {\n         let first_name = path.segments().first()?;\n         let skip_to_mod = path.kind != PathKind::Plain;\n+        if skip_to_mod {\n+            return self.module_scope.resolve_path_in_type_ns(db, path);\n+        }\n+\n+        let remaining_idx = || if path.segments().len() == 1 { None } else { Some(1) };\n+\n         for scope in self.scopes() {\n             match scope {\n                 Scope::ExprScope(_) => continue,\n-                Scope::GenericParams { .. } | Scope::ImplDefScope(_) if skip_to_mod => continue,\n-\n                 Scope::GenericParams { params, def } => {\n                     if let Some(id) = params.find_type_by_name(first_name, *def) {\n-                        let idx = if path.segments().len() == 1 { None } else { Some(1) };\n-                        return Some((TypeNs::GenericParam(id), idx));\n+                        return Some((TypeNs::GenericParam(id), remaining_idx()));\n                     }\n                 }\n-                Scope::ImplDefScope(impl_) => {\n+                &Scope::ImplDefScope(impl_) => {\n                     if first_name == &name![Self] {\n-                        let idx = if path.segments().len() == 1 { None } else { Some(1) };\n-                        return Some((TypeNs::SelfType(*impl_), idx));\n+                        return Some((TypeNs::SelfType(impl_), remaining_idx()));\n                     }\n                 }\n-                Scope::AdtScope(adt) => {\n+                &Scope::AdtScope(adt) => {\n                     if first_name == &name![Self] {\n-                        let idx = if path.segments().len() == 1 { None } else { Some(1) };\n-                        return Some((TypeNs::AdtSelfType(*adt), idx));\n+                        return Some((TypeNs::AdtSelfType(adt), remaining_idx()));\n                     }\n                 }\n-                Scope::ModuleScope(m) => {\n+                Scope::BlockScope(m) => {\n                     if let Some(res) = m.resolve_path_in_type_ns(db, path) {\n                         return Some(res);\n                     }\n                 }\n             }\n         }\n-        None\n+        self.module_scope.resolve_path_in_type_ns(db, path)\n     }\n \n     pub fn resolve_path_in_type_ns_fully(\n@@ -235,7 +216,7 @@ impl Resolver {\n     ) -> Option<Visibility> {\n         match visibility {\n             RawVisibility::Module(_) => {\n-                let (item_map, module) = self.module_scope();\n+                let (item_map, module) = self.item_scope();\n                 item_map.resolve_visibility(db, module, visibility)\n             }\n             RawVisibility::Public => Some(Visibility::Public),\n@@ -251,18 +232,14 @@ impl Resolver {\n         let tmp = name![self];\n         let first_name = if path.is_self() { &tmp } else { path.segments().first()? };\n         let skip_to_mod = path.kind != PathKind::Plain && !path.is_self();\n+        if skip_to_mod {\n+            return self.module_scope.resolve_path_in_value_ns(db, path);\n+        }\n+\n         for scope in self.scopes() {\n             match scope {\n-                Scope::AdtScope(_)\n-                | Scope::ExprScope(_)\n-                | Scope::GenericParams { .. }\n-                | Scope::ImplDefScope(_)\n-                    if skip_to_mod =>\n-                {\n-                    continue\n-                }\n-\n-                Scope::ExprScope(scope) if n_segments <= 1 => {\n+                Scope::ExprScope(_) if n_segments > 1 => continue,\n+                Scope::ExprScope(scope) => {\n                     let entry = scope\n                         .expr_scopes\n                         .entries(scope.scope_id)\n@@ -273,60 +250,56 @@ impl Resolver {\n                         return Some(ResolveValueResult::ValueNs(ValueNs::LocalBinding(e.pat())));\n                     }\n                 }\n-                Scope::ExprScope(_) => continue,\n-\n                 Scope::GenericParams { params, def } if n_segments > 1 => {\n                     if let Some(id) = params.find_type_by_name(first_name, *def) {\n                         let ty = TypeNs::GenericParam(id);\n                         return Some(ResolveValueResult::Partial(ty, 1));\n                     }\n                 }\n-                Scope::GenericParams { params, def } if n_segments == 1 => {\n+                Scope::GenericParams { .. } if n_segments != 1 => continue,\n+                Scope::GenericParams { params, def } => {\n                     if let Some(id) = params.find_const_by_name(first_name, *def) {\n                         let val = ValueNs::GenericParam(id);\n                         return Some(ResolveValueResult::ValueNs(val));\n                     }\n                 }\n-                Scope::GenericParams { .. } => continue,\n \n-                Scope::ImplDefScope(impl_) => {\n+                &Scope::ImplDefScope(impl_) => {\n                     if first_name == &name![Self] {\n-                        if n_segments > 1 {\n-                            let ty = TypeNs::SelfType(*impl_);\n-                            return Some(ResolveValueResult::Partial(ty, 1));\n+                        return Some(if n_segments > 1 {\n+                            ResolveValueResult::Partial(TypeNs::SelfType(impl_), 1)\n                         } else {\n-                            return Some(ResolveValueResult::ValueNs(ValueNs::ImplSelf(*impl_)));\n-                        }\n+                            ResolveValueResult::ValueNs(ValueNs::ImplSelf(impl_))\n+                        });\n                     }\n                 }\n+                // bare `Self` doesn't work in the value namespace in a struct/enum definition\n+                Scope::AdtScope(_) if n_segments == 1 => continue,\n                 Scope::AdtScope(adt) => {\n-                    if n_segments == 1 {\n-                        // bare `Self` doesn't work in the value namespace in a struct/enum definition\n-                        continue;\n-                    }\n                     if first_name == &name![Self] {\n                         let ty = TypeNs::AdtSelfType(*adt);\n                         return Some(ResolveValueResult::Partial(ty, 1));\n                     }\n                 }\n \n-                Scope::ModuleScope(m) => {\n+                Scope::BlockScope(m) => {\n                     if let Some(def) = m.resolve_path_in_value_ns(db, path) {\n                         return Some(def);\n                     }\n                 }\n             }\n         }\n \n+        if let res @ Some(_) = self.module_scope.resolve_path_in_value_ns(db, path) {\n+            return res;\n+        }\n+\n         // If a path of the shape `u16::from_le_bytes` failed to resolve at all, then we fall back\n         // to resolving to the primitive type, to allow this to still work in the presence of\n         // `use core::u16;`.\n         if path.kind == PathKind::Plain && path.segments().len() > 1 {\n-            match BuiltinType::by_name(&path.segments()[0]) {\n-                Some(builtin) => {\n-                    return Some(ResolveValueResult::Partial(TypeNs::BuiltinType(builtin), 1));\n-                }\n-                None => {}\n+            if let Some(builtin) = BuiltinType::by_name(&path.segments()[0]) {\n+                return Some(ResolveValueResult::Partial(TypeNs::BuiltinType(builtin), 1));\n             }\n         }\n \n@@ -345,7 +318,7 @@ impl Resolver {\n     }\n \n     pub fn resolve_path_as_macro(&self, db: &dyn DefDatabase, path: &ModPath) -> Option<MacroId> {\n-        let (item_map, module) = self.module_scope();\n+        let (item_map, module) = self.item_scope();\n         item_map.resolve_path(db, module, path, BuiltinShadowMode::Other).0.take_macros()\n     }\n \n@@ -395,30 +368,34 @@ impl Resolver {\n         for scope in self.scopes() {\n             scope.process_names(&mut res, db);\n         }\n+        process_module_scope_names(&mut res, db, &self.module_scope);\n         res.map\n     }\n \n     pub fn traits_in_scope(&self, db: &dyn DefDatabase) -> FxHashSet<TraitId> {\n         let mut traits = FxHashSet::default();\n-        for scope in self.scopes() {\n-            match scope {\n-                Scope::ModuleScope(m) => {\n-                    if let Some(prelude) = m.def_map.prelude() {\n-                        let prelude_def_map = prelude.def_map(db);\n-                        traits.extend(prelude_def_map[prelude.local_id].scope.traits());\n-                    }\n-                    traits.extend(m.def_map[m.module_id].scope.traits());\n \n-                    // Add all traits that are in scope because of the containing DefMaps\n-                    m.def_map.with_ancestor_maps(db, m.module_id, &mut |def_map, module| {\n-                        if let Some(prelude) = def_map.prelude() {\n-                            let prelude_def_map = prelude.def_map(db);\n-                            traits.extend(prelude_def_map[prelude.local_id].scope.traits());\n-                        }\n-                        traits.extend(def_map[module].scope.traits());\n-                        None::<()>\n-                    });\n+        let collect_module_traits = |traits: &mut FxHashSet<_>, m: &ModuleItemMap| {\n+            if let Some(prelude) = m.def_map.prelude() {\n+                let prelude_def_map = prelude.def_map(db);\n+                traits.extend(prelude_def_map[prelude.local_id].scope.traits());\n+            }\n+            traits.extend(m.def_map[m.module_id].scope.traits());\n+\n+            // Add all traits that are in scope because of the containing DefMaps\n+            m.def_map.with_ancestor_maps(db, m.module_id, &mut |def_map, module| {\n+                if let Some(prelude) = def_map.prelude() {\n+                    let prelude_def_map = prelude.def_map(db);\n+                    traits.extend(prelude_def_map[prelude.local_id].scope.traits());\n                 }\n+                traits.extend(def_map[module].scope.traits());\n+                None::<()>\n+            });\n+        };\n+\n+        for scope in self.scopes() {\n+            match scope {\n+                Scope::BlockScope(m) => collect_module_traits(&mut traits, m),\n                 &Scope::ImplDefScope(impl_) => {\n                     if let Some(target_trait) = &db.impl_data(impl_).target_trait {\n                         if let Some(TypeNs::TraitId(trait_)) =\n@@ -431,35 +408,22 @@ impl Resolver {\n                 _ => (),\n             }\n         }\n-        traits\n-    }\n \n-    fn module_scope(&self) -> (&DefMap, LocalModuleId) {\n-        self.scopes()\n-            .find_map(|scope| match scope {\n-                Scope::ModuleScope(m) => Some((&*m.def_map, m.module_id)),\n-                _ => None,\n-            })\n-            .expect(\"module scope invariant violated\")\n+        collect_module_traits(&mut traits, &self.module_scope);\n+        traits\n     }\n \n     pub fn module(&self) -> ModuleId {\n-        let (def_map, local_id) = self.module_scope();\n+        let (def_map, local_id) = self.item_scope();\n         def_map.module_id(local_id)\n     }\n \n     pub fn krate(&self) -> CrateId {\n-        self.def_map().krate()\n+        self.module_scope.def_map.krate()\n     }\n \n     pub fn def_map(&self) -> &DefMap {\n-        self.scopes\n-            .get(0)\n-            .and_then(|scope| match scope {\n-                Scope::ModuleScope(m) => Some(&m.def_map),\n-                _ => None,\n-            })\n-            .expect(\"module scope invariant violated\")\n+        self.item_scope().0\n     }\n \n     pub fn where_predicates_in_scope(\n@@ -488,6 +452,36 @@ impl Resolver {\n     }\n }\n \n+impl Resolver {\n+    fn scopes(&self) -> impl Iterator<Item = &Scope> {\n+        self.scopes.iter().rev()\n+    }\n+\n+    fn resolve_module_path(\n+        &self,\n+        db: &dyn DefDatabase,\n+        path: &ModPath,\n+        shadow: BuiltinShadowMode,\n+    ) -> PerNs {\n+        let (item_map, module) = self.item_scope();\n+        let (module_res, segment_index) = item_map.resolve_path(db, module, path, shadow);\n+        if segment_index.is_some() {\n+            return PerNs::none();\n+        }\n+        module_res\n+    }\n+\n+    /// The innermost block scope that contains items or the module scope that contains this resolver.\n+    fn item_scope(&self) -> (&DefMap, LocalModuleId) {\n+        self.scopes()\n+            .find_map(|scope| match scope {\n+                Scope::BlockScope(m) => Some((&*m.def_map, m.module_id)),\n+                _ => None,\n+            })\n+            .unwrap_or((&self.module_scope.def_map, self.module_scope.module_id))\n+    }\n+}\n+\n #[derive(Copy, Clone, Debug, PartialEq, Eq)]\n pub enum ScopeDef {\n     ModuleDef(ModuleDefId),\n@@ -499,41 +493,42 @@ pub enum ScopeDef {\n     Label(LabelId),\n }\n \n+fn process_module_scope_names(acc: &mut ScopeNames, db: &dyn DefDatabase, m: &ModuleItemMap) {\n+    // FIXME: should we provide `self` here?\n+    // f(\n+    //     Name::self_param(),\n+    //     PerNs::types(Resolution::Def {\n+    //         def: m.module.into(),\n+    //     }),\n+    // );\n+    m.def_map[m.module_id].scope.entries().for_each(|(name, def)| {\n+        acc.add_per_ns(name, def);\n+    });\n+    m.def_map[m.module_id].scope.legacy_macros().for_each(|(name, macs)| {\n+        macs.iter().for_each(|&mac| {\n+            acc.add(name, ScopeDef::ModuleDef(ModuleDefId::MacroId(MacroId::from(mac))));\n+        })\n+    });\n+    m.def_map.extern_prelude().for_each(|(name, &def)| {\n+        acc.add(name, ScopeDef::ModuleDef(ModuleDefId::ModuleId(def)));\n+    });\n+    if m.def_map.block_id().is_none() {\n+        BUILTIN_SCOPE.iter().for_each(|(name, &def)| {\n+            acc.add_per_ns(name, def);\n+        });\n+    }\n+    if let Some(prelude) = m.def_map.prelude() {\n+        let prelude_def_map = prelude.def_map(db);\n+        for (name, def) in prelude_def_map[prelude.local_id].scope.entries() {\n+            acc.add_per_ns(name, def)\n+        }\n+    }\n+}\n+\n impl Scope {\n     fn process_names(&self, acc: &mut ScopeNames, db: &dyn DefDatabase) {\n         match self {\n-            Scope::ModuleScope(m) => {\n-                // FIXME: should we provide `self` here?\n-                // f(\n-                //     Name::self_param(),\n-                //     PerNs::types(Resolution::Def {\n-                //         def: m.module.into(),\n-                //     }),\n-                // );\n-                m.def_map[m.module_id].scope.entries().for_each(|(name, def)| {\n-                    acc.add_per_ns(name, def);\n-                });\n-                m.def_map[m.module_id].scope.legacy_macros().for_each(|(name, macs)| {\n-                    macs.iter().for_each(|&mac| {\n-                        acc.add(\n-                            name,\n-                            ScopeDef::ModuleDef(ModuleDefId::MacroId(MacroId::from(mac))),\n-                        );\n-                    })\n-                });\n-                m.def_map.extern_prelude().for_each(|(name, &def)| {\n-                    acc.add(name, ScopeDef::ModuleDef(ModuleDefId::ModuleId(def)));\n-                });\n-                BUILTIN_SCOPE.iter().for_each(|(name, &def)| {\n-                    acc.add_per_ns(name, def);\n-                });\n-                if let Some(prelude) = m.def_map.prelude() {\n-                    let prelude_def_map = prelude.def_map(db);\n-                    for (name, def) in prelude_def_map[prelude.local_id].scope.entries() {\n-                        acc.add_per_ns(name, def)\n-                    }\n-                }\n-            }\n+            Scope::BlockScope(m) => process_module_scope_names(acc, db, m),\n             Scope::GenericParams { params, def: parent } => {\n                 let parent = *parent;\n                 for (local_id, param) in params.type_or_consts.iter() {\n@@ -596,7 +591,7 @@ pub fn resolver_for_scope(\n         if let Some(block) = scopes.block(scope) {\n             if let Some(def_map) = db.block_def_map(block) {\n                 let root = def_map.root();\n-                r = r.push_module_scope(def_map, root);\n+                r = r.push_block_scope(def_map, root);\n                 // FIXME: This adds as many module scopes as there are blocks, but resolving in each\n                 // already traverses all parents, so this is O(n\u00b2). I think we could only store the\n                 // innermost module scope instead?\n@@ -623,8 +618,8 @@ impl Resolver {\n         self.push_scope(Scope::ImplDefScope(impl_def))\n     }\n \n-    fn push_module_scope(self, def_map: Arc<DefMap>, module_id: LocalModuleId) -> Resolver {\n-        self.push_scope(Scope::ModuleScope(ModuleItemMap { def_map, module_id }))\n+    fn push_block_scope(self, def_map: Arc<DefMap>, module_id: LocalModuleId) -> Resolver {\n+        self.push_scope(Scope::BlockScope(ModuleItemMap { def_map, module_id }))\n     }\n \n     fn push_expr_scope(\n@@ -768,14 +763,19 @@ pub trait HasResolver: Copy {\n impl HasResolver for ModuleId {\n     fn resolver(self, db: &dyn DefDatabase) -> Resolver {\n         let mut def_map = self.def_map(db);\n-        let mut modules: SmallVec<[_; 2]> = smallvec![(def_map.clone(), self.local_id)];\n+        let mut modules: SmallVec<[_; 1]> = smallvec![];\n+        let mut module_id = self.local_id;\n         while let Some(parent) = def_map.parent() {\n+            modules.push((def_map, module_id));\n             def_map = parent.def_map(db);\n-            modules.push((def_map.clone(), parent.local_id));\n+            module_id = parent.local_id;\n         }\n-        let mut resolver = Resolver { scopes: Vec::with_capacity(modules.len()) };\n+        let mut resolver = Resolver {\n+            scopes: Vec::with_capacity(modules.len()),\n+            module_scope: ModuleItemMap { def_map, module_id },\n+        };\n         for (def_map, module) in modules.into_iter().rev() {\n-            resolver = resolver.push_module_scope(def_map, module);\n+            resolver = resolver.push_block_scope(def_map, module);\n         }\n         resolver\n     }"}, {"sha": "344036dd8139d28d433c745b6121ab8c85e9865f", "filename": "crates/hir-ty/src/autoderef.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8828049b2398b0df3bfc76d06bcf5154cdbe536a/crates%2Fhir-ty%2Fsrc%2Fautoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8828049b2398b0df3bfc76d06bcf5154cdbe536a/crates%2Fhir-ty%2Fsrc%2Fautoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fautoderef.rs?ref=8828049b2398b0df3bfc76d06bcf5154cdbe536a", "patch": "@@ -104,8 +104,7 @@ pub(crate) fn deref(table: &mut InferenceTable<'_>, ty: Ty) -> Option<Ty> {\n \n fn builtin_deref(ty: &Ty) -> Option<&Ty> {\n     match ty.kind(Interner) {\n-        TyKind::Ref(.., ty) => Some(ty),\n-        TyKind::Raw(.., ty) => Some(ty),\n+        TyKind::Ref(.., ty) | TyKind::Raw(.., ty) => Some(ty),\n         _ => None,\n     }\n }"}, {"sha": "ccaaf3991769ec737833da7eb0bec769d36a501a", "filename": "lib/la-arena/src/lib.rs", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/8828049b2398b0df3bfc76d06bcf5154cdbe536a/lib%2Fla-arena%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8828049b2398b0df3bfc76d06bcf5154cdbe536a/lib%2Fla-arena%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/lib%2Fla-arena%2Fsrc%2Flib.rs?ref=8828049b2398b0df3bfc76d06bcf5154cdbe536a", "patch": "@@ -322,6 +322,43 @@ impl<T> Arena<T> {\n             .map(|(idx, value)| (Idx::from_raw(RawIdx(idx as u32)), value))\n     }\n \n+    /// Returns an iterator over the arena\u2019s values.\n+    ///\n+    /// ```\n+    /// let mut arena = la_arena::Arena::new();\n+    /// let idx1 = arena.alloc(20);\n+    /// let idx2 = arena.alloc(40);\n+    /// let idx3 = arena.alloc(60);\n+    ///\n+    /// let mut iterator = arena.values();\n+    /// assert_eq!(iterator.next(), Some(&20));\n+    /// assert_eq!(iterator.next(), Some(&40));\n+    /// assert_eq!(iterator.next(), Some(&60));\n+    /// ```\n+    pub fn values(&mut self) -> impl Iterator<Item = &T> + ExactSizeIterator + DoubleEndedIterator {\n+        self.data.iter()\n+    }\n+\n+    /// Returns an iterator over the arena\u2019s mutable values.\n+    ///\n+    /// ```\n+    /// let mut arena = la_arena::Arena::new();\n+    /// let idx1 = arena.alloc(20);\n+    ///\n+    /// assert_eq!(arena[idx1], 20);\n+    ///\n+    /// let mut iterator = arena.values_mut();\n+    /// *iterator.next().unwrap() = 10;\n+    /// drop(iterator);\n+    ///\n+    /// assert_eq!(arena[idx1], 10);\n+    /// ```\n+    pub fn values_mut(\n+        &mut self,\n+    ) -> impl Iterator<Item = &mut T> + ExactSizeIterator + DoubleEndedIterator {\n+        self.data.iter_mut()\n+    }\n+\n     /// Reallocates the arena to make it take up as little space as possible.\n     pub fn shrink_to_fit(&mut self) {\n         self.data.shrink_to_fit();"}]}