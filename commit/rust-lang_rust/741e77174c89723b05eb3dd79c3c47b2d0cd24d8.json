{"sha": "741e77174c89723b05eb3dd79c3c47b2d0cd24d8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc0MWU3NzE3NGM4OTcyM2IwNWViM2RkNzljM2M0N2IyZDBjZDI0ZDg=", "commit": {"author": {"name": "Rafael \u00c1vila de Esp\u00edndola", "email": "respindola@mozilla.com", "date": "2011-06-16T18:09:15Z"}, "committer": {"name": "Rafael \u00c1vila de Esp\u00edndola", "email": "respindola@mozilla.com", "date": "2011-06-16T18:09:15Z"}, "message": "Merge remote branch 'upstream/master'", "tree": {"sha": "50e4097fc7987bb2c47196c9bb3fdb6bbbf53b17", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/50e4097fc7987bb2c47196c9bb3fdb6bbbf53b17"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/741e77174c89723b05eb3dd79c3c47b2d0cd24d8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/741e77174c89723b05eb3dd79c3c47b2d0cd24d8", "html_url": "https://github.com/rust-lang/rust/commit/741e77174c89723b05eb3dd79c3c47b2d0cd24d8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/741e77174c89723b05eb3dd79c3c47b2d0cd24d8/comments", "author": null, "committer": null, "parents": [{"sha": "c51ac6730f54c2c02c9c32db04052c238380f692", "url": "https://api.github.com/repos/rust-lang/rust/commits/c51ac6730f54c2c02c9c32db04052c238380f692", "html_url": "https://github.com/rust-lang/rust/commit/c51ac6730f54c2c02c9c32db04052c238380f692"}, {"sha": "f9da8b2676c192e7a1ad68c719b84edf1b52ccb7", "url": "https://api.github.com/repos/rust-lang/rust/commits/f9da8b2676c192e7a1ad68c719b84edf1b52ccb7", "html_url": "https://github.com/rust-lang/rust/commit/f9da8b2676c192e7a1ad68c719b84edf1b52ccb7"}], "stats": {"total": 157, "additions": 127, "deletions": 30}, "files": [{"sha": "c733e5b372db4e068ef2b02f42e38c76de16d672", "filename": "src/comp/front/parser.rs", "status": "modified", "additions": 21, "deletions": 6, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/741e77174c89723b05eb3dd79c3c47b2d0cd24d8/src%2Fcomp%2Ffront%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/741e77174c89723b05eb3dd79c3c47b2d0cd24d8/src%2Fcomp%2Ffront%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fparser.rs?ref=741e77174c89723b05eb3dd79c3c47b2d0cd24d8", "patch": "@@ -411,6 +411,26 @@ fn parse_ty_constrs(@ast::ty t, &parser p) -> @ast::ty {\n     ret t;\n }\n \n+fn parse_ty_postfix(@ast::ty orig_t, &parser p) -> @ast::ty {\n+    auto lo = p.get_lo_pos();\n+    if (p.peek() == token::LBRACKET) {\n+        p.bump();\n+\n+        auto mut;\n+        if (eat_word(p, \"mutable\")) {\n+            mut = ast::mut;\n+        } else {\n+            mut = ast::imm;\n+        }\n+\n+        expect(p, token::RBRACKET);\n+        auto hi = p.get_hi_pos();\n+        auto t = ast::ty_ivec(rec(ty=orig_t, mut=mut));\n+        ret parse_ty_postfix(@spanned(lo, hi, t), p);\n+    }\n+    ret parse_ty_constrs(orig_t, p);\n+}\n+\n fn parse_ty_or_bang(&parser p) -> ty_or_bang {\n     alt (p.peek()) {\n         case (token::NOT) { p.bump(); ret a_bang[@ast::ty]; }\n@@ -522,11 +542,6 @@ fn parse_ty(&parser p) -> @ast::ty {\n         t = ast::ty_chan(parse_ty(p));\n         hi = p.get_hi_pos();\n         expect(p, token::RBRACKET);\n-    } else if (eat_word(p, \"ivec\")) {\n-        expect(p, token::LBRACKET);\n-        t = ast::ty_ivec(parse_mt(p));\n-        hi = p.get_hi_pos();\n-        expect(p, token::RBRACKET);\n     } else if (eat_word(p, \"mutable\")) {\n         p.get_session().span_warn(p.get_span(),\n                                   \"ignoring deprecated 'mutable'\"\n@@ -539,7 +554,7 @@ fn parse_ty(&parser p) -> @ast::ty {\n         t = ast::ty_path(path, p.get_ann());\n         hi = path.span.hi;\n     } else { p.err(\"expecting type\"); t = ast::ty_nil; fail; }\n-    ret parse_ty_constrs(@spanned(lo, hi, t), p);\n+    ret parse_ty_postfix(@spanned(lo, hi, t), p);\n }\n \n fn parse_arg(&parser p) -> ast::arg {"}, {"sha": "ffacc7224bfec0637d63212aa6f57b1d407bc3a1", "filename": "src/rt/intrinsics/intrinsics.cpp", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/741e77174c89723b05eb3dd79c3c47b2d0cd24d8/src%2Frt%2Fintrinsics%2Fintrinsics.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/741e77174c89723b05eb3dd79c3c47b2d0cd24d8/src%2Frt%2Fintrinsics%2Fintrinsics.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fintrinsics%2Fintrinsics.cpp?ref=741e77174c89723b05eb3dd79c3c47b2d0cd24d8", "patch": "@@ -1,5 +1,5 @@\n-// Use `clang++ -emit-llvm -S -arch i386 -O3 -I../isaac -I../uthash -o\n-//      intrinsics.ll intrinsics.cpp`\n+// Use `clang++ -emit-llvm -S -arch i386 -O3 -I../isaac -I../uthash\n+//      -I../arch/i386 -o intrinsics.ll intrinsics.cpp`\n \n #include \"../rust_internal.h\"\n \n@@ -9,3 +9,16 @@ rust_intrinsic_vec_len(rust_task *task, type_desc *ty, rust_vec *v)\n     return v->fill / ty->size;\n }\n \n+extern \"C\" size_t\n+rust_intrinsic_ivec_len(rust_task *task, type_desc *ty, rust_ivec *v)\n+{\n+    size_t fill;\n+    if (v->fill)\n+        fill = v->fill;\n+    else if (v->payload.ptr)\n+        fill = v->payload.ptr->fill;\n+    else\n+        fill = 0;\n+    return fill / ty->size;\n+}\n+"}, {"sha": "f163df46e6d613b70d3939e5aa6cd2cab1a38cf0", "filename": "src/rt/intrinsics/intrinsics.ll.in", "status": "modified", "additions": 59, "deletions": 22, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/741e77174c89723b05eb3dd79c3c47b2d0cd24d8/src%2Frt%2Fintrinsics%2Fintrinsics.ll.in", "raw_url": "https://github.com/rust-lang/rust/raw/741e77174c89723b05eb3dd79c3c47b2d0cd24d8/src%2Frt%2Fintrinsics%2Fintrinsics.ll.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fintrinsics%2Fintrinsics.ll.in?ref=741e77174c89723b05eb3dd79c3c47b2d0cd24d8", "patch": "@@ -3,53 +3,63 @@ target datalayout = \"e-p:32:32:32-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:32:64-f3\n target triple = \"@CFG_LLVM_TRIPLE@\"\n \n %0 = type { i32, i8**, i32 }\n-%1 = type { %\"struct.hash_map<rust_task *, rust_handle<rust_task> *>::map_entry\"* }\n-%2 = type { %\"struct.hash_map<rust_port *, rust_handle<rust_port> *>::map_entry\"* }\n-%3 = type { %\"struct.hash_map<rust_dom *, rust_handle<rust_dom> *>::map_entry\"* }\n-%4 = type { i32, %struct.rust_dom**, i32 }\n+%1 = type { i32, %struct.rust_task**, i32 }\n+%2 = type { %\"struct.hash_map<rust_task *, rust_handle<rust_task> *>::map_entry\"* }\n+%3 = type { %\"struct.hash_map<rust_port *, rust_handle<rust_port> *>::map_entry\"* }\n+%4 = type { %\"struct.hash_map<rust_dom *, rust_handle<rust_dom> *>::map_entry\"* }\n %5 = type { i32 (...)**, %6 }\n-%6 = type { i32, %class.rust_message_queue**, i32 }\n-%7 = type opaque\n-%8 = type { %\"struct.hash_map<rust_port *, rust_proxy<rust_port> *>::map_entry\"* }\n+%6 = type { i32, %struct.rust_dom**, i32 }\n+%7 = type { i32 (...)**, %8 }\n+%8 = type { i32, %class.rust_message_queue**, i32 }\n+%9 = type opaque\n+%10 = type opaque\n+%11 = type { %\"struct.hash_map<rust_port *, rust_proxy<rust_port> *>::map_entry\"* }\n %class.array_list = type { i32, %struct.maybe_proxy**, i32 }\n+%class.context = type { %struct.registers_t, %class.context* }\n %class.hash_map = type { %\"struct.hash_map<rust_task *, rust_proxy<rust_task> *>::map_entry\"* }\n-%class.indexed_list = type { i32 (...)**, %4 }\n+%class.indexed_list = type { i32 (...)**, %1 }\n %class.lock_and_signal = type { i32 (...)**, %struct._opaque_pthread_cond_t, %struct._opaque_pthread_mutex_t }\n+%class.lock_free_queue = type { i32 (...)**, %\"struct.lock_free_queue<rust_message *>::pointer_t\", %\"struct.lock_free_queue<rust_message *>::pointer_t\" }\n %class.memory_region = type { i32 (...)**, %class.rust_srv*, %class.memory_region*, i32, %0, i8, i8, %class.lock_and_signal }\n-%class.ptr_vec = type { %struct.rust_dom*, i32, i32, %class.rust_crate_cache** }\n-%class.rust_crate = type { i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32 }\n-%class.rust_crate_cache = type { [4 x i8], %\"class.rust_crate_cache::rust_sym\"**, %\"class.rust_crate_cache::c_sym\"**, %\"class.rust_crate_cache::lib\"**, %struct.type_desc*, %class.rust_crate*, %struct.rust_dom*, i32 }\n-%\"class.rust_crate_cache::c_sym\" = type { [4 x i8], i32, %\"class.rust_crate_cache::lib\"*, %struct.rust_dom* }\n-%\"class.rust_crate_cache::lib\" = type { [4 x i8], i32, %struct.rust_dom* }\n-%\"class.rust_crate_cache::rust_sym\" = type { [4 x i8], i32, %\"class.rust_crate_cache::c_sym\"*, %struct.rust_dom* }\n+%class.rust_crate_cache = type { %struct.type_desc*, %struct.rust_dom*, i32 }\n %class.rust_handle = type opaque\n-%class.rust_kernel = type { [12 x i8], %class.memory_region*, %class.rust_log, %class.rust_srv*, %1, %2, %3, i8, %class.lock_and_signal, %class.indexed_list, %5 }\n+%class.rust_kernel = type { %class.rust_thread, %class.memory_region*, %class.rust_log, %class.rust_srv*, %2, %3, %4, i8, %class.lock_and_signal, %5, %7 }\n %class.rust_log = type { i32 (...)**, %class.rust_srv*, %struct.rust_dom*, i8, i8 }\n-%class.rust_message_queue = type { [20 x i8], %class.memory_region, %class.rust_kernel*, %7*, i32 }\n+%class.rust_message_queue = type { %class.lock_free_queue, %class.memory_region, %class.rust_kernel*, %10*, i32 }\n %class.rust_srv = type { i32 (...)**, %class.memory_region, %class.memory_region }\n-%class.rust_task_list = type { [16 x i8], %struct.rust_dom*, i8* }\n+%class.rust_task_list = type { %class.indexed_list, %struct.rust_dom*, i8* }\n+%class.rust_thread = type { i32 (...)**, i8, %struct._opaque_pthread_t* }\n %class.timer = type { i32 (...)**, i64, i64 }\n %struct.UT_hash_bucket = type { %struct.UT_hash_handle*, i32, i32 }\n %struct.UT_hash_handle = type { %struct.UT_hash_table*, i8*, i8*, %struct.UT_hash_handle*, %struct.UT_hash_handle*, i8*, i32, i32 }\n %struct.UT_hash_table = type { %struct.UT_hash_bucket*, i32, i32, i32, %struct.UT_hash_handle*, i32, i32, i32, i32, i32 }\n+%struct.__darwin_pthread_handler_rec = type { void (i8*)*, i8*, %struct.__darwin_pthread_handler_rec* }\n %struct._opaque_pthread_attr_t = type { i32, [36 x i8] }\n %struct._opaque_pthread_cond_t = type { i32, [24 x i8] }\n %struct._opaque_pthread_mutex_t = type { i32, [40 x i8] }\n+%struct._opaque_pthread_t = type { i32, %struct.__darwin_pthread_handler_rec*, [596 x i8] }\n %struct.gc_alloc = type { %struct.gc_alloc*, %struct.gc_alloc*, i32, [0 x i8] }\n %\"struct.hash_map<rust_dom *, rust_handle<rust_dom> *>::map_entry\" = type opaque\n %\"struct.hash_map<rust_port *, rust_handle<rust_port> *>::map_entry\" = type opaque\n %\"struct.hash_map<rust_port *, rust_proxy<rust_port> *>::map_entry\" = type opaque\n %\"struct.hash_map<rust_task *, rust_handle<rust_task> *>::map_entry\" = type opaque\n %\"struct.hash_map<rust_task *, rust_proxy<rust_task> *>::map_entry\" = type opaque\n-%struct.maybe_proxy = type { [4 x i8], %struct.rust_task* }\n+%\"struct.lock_free_queue<rust_message *>::node_t\" = type { %9*, %\"struct.lock_free_queue<rust_message *>::pointer_t\" }\n+%\"struct.lock_free_queue<rust_message *>::pointer_t\" = type { %\"struct.lock_free_queue<rust_message *>::node_t\"*, i32 }\n+%struct.maybe_proxy = type { %struct.rc_base, %struct.rust_task* }\n %struct.randctx = type { i32, [256 x i32], [256 x i32], i32, i32, i32 }\n+%struct.rc_base = type { i32 }\n+%struct.registers_t = type { i32, i32, i32, i32, i32, i32, i32, i32, i16, i16, i16, i16, i16, i16, i32, i32 }\n %struct.rust_alarm = type { %struct.rust_task*, i32 }\n %struct.rust_cond = type { i8 }\n-%struct.rust_dom = type { [4 x i8], i32, %class.rust_crate*, %class.rust_log, i32, %class.rust_srv*, %class.memory_region, %class.memory_region, i8*, %class.rust_task_list, %class.rust_task_list, %class.rust_task_list, %class.rust_task_list, %class.ptr_vec, %struct.randctx, %struct.rust_task*, %struct.rust_task*, i32, %class.rust_kernel*, i32, %class.hash_map, %8, %class.rust_message_queue*, %struct._opaque_pthread_attr_t }\n-%struct.rust_task = type { [8 x i8], %struct.stk_seg*, i32, i32, %struct.gc_alloc*, %struct.rust_dom*, %class.rust_crate_cache*, i8*, %class.rust_task_list*, %struct.rust_cond*, i8*, %struct.rust_task*, i32, i32, i32, %class.timer, i32*, %class.array_list, %struct.rust_alarm, %class.rust_handle* }\n-%struct.rust_vec = type { [4 x i8], i32, i32, i32, [0 x i8] }\n+%struct.rust_dom = type { %struct.rc_base, i32, %class.rust_log, i32, %class.rust_srv*, %class.memory_region, %class.memory_region, i8*, %class.rust_task_list, %class.rust_task_list, %class.rust_task_list, %class.rust_task_list, %class.rust_crate_cache, %struct.randctx, %struct.rust_task*, %struct.rust_task*, i32, %class.rust_kernel*, i32, %class.hash_map, %11, %class.rust_message_queue*, %struct._opaque_pthread_attr_t }\n+%struct.rust_ivec = type { i32, i32, %union.rust_ivec_payload }\n+%struct.rust_ivec_heap = type { i32, [0 x i8] }\n+%struct.rust_task = type { %struct.maybe_proxy, %struct.stk_seg*, i32, i32, %struct.gc_alloc*, %struct.rust_dom*, %class.rust_crate_cache*, i8*, %class.rust_task_list*, %struct.rust_cond*, i8*, %struct.rust_task*, i32, i32, i32, %class.timer, i32*, %class.array_list, %struct.rust_alarm, %class.rust_handle*, %class.context }\n+%struct.rust_vec = type { %struct.rc_base, i32, i32, i32, [0 x i8] }\n %struct.stk_seg = type { i32, i32, [0 x i8] }\n-%struct.type_desc = type { %struct.type_desc**, i32, i32, i32, i32, i32, i32, i32, i32, i32, %struct.UT_hash_handle, i32, [0 x %struct.type_desc*] }\n+%struct.type_desc = type { %struct.type_desc**, i32, i32, void (i8*, %struct.rust_task*, i8*, %struct.type_desc**, i8*)*, void (i8*, %struct.rust_task*, i8*, %struct.type_desc**, i8*)*, void (i8*, %struct.rust_task*, i8*, %struct.type_desc**, i8*)*, void (i8*, %struct.rust_task*, i8*, %struct.type_desc**, i8*)*, void (i8*, %struct.rust_task*, i8*, %struct.type_desc**, i8*)*, void (i8*, %struct.rust_task*, i8*, %struct.type_desc**, i8*)*, i32, void (i8*, %struct.rust_task*, i8*, %struct.type_desc**, i8*, i8*, i8)*, %struct.UT_hash_handle, i32, [0 x %struct.type_desc*] }\n+%union.rust_ivec_payload = type { %struct.rust_ivec_heap* }\n \n define linkonce_odr i32 @rust_intrinsic_vec_len(%struct.rust_task* nocapture %task, %struct.type_desc* nocapture %ty, %struct.rust_vec* nocapture %v) nounwind readonly ssp {\n entry:\n@@ -61,6 +71,33 @@ entry:\n   ret i32 %div\n }\n \n+define linkonce_odr i32 @rust_intrinsic_ivec_len(%struct.rust_task* nocapture %task, %struct.type_desc* nocapture %ty, %struct.rust_ivec* nocapture %v) nounwind readonly ssp {\n+entry:\n+  %fill1 = getelementptr inbounds %struct.rust_ivec* %v, i32 0, i32 0\n+  %tmp2 = load i32* %fill1, align 4, !tbaa !0\n+  %tobool = icmp eq i32 %tmp2, 0\n+  br i1 %tobool, label %if.else, label %if.end17\n+\n+if.else:                                          ; preds = %entry\n+  %ptr = getelementptr inbounds %struct.rust_ivec* %v, i32 0, i32 2, i32 0\n+  %tmp7 = load %struct.rust_ivec_heap** %ptr, align 4, !tbaa !3\n+  %tobool8 = icmp eq %struct.rust_ivec_heap* %tmp7, null\n+  br i1 %tobool8, label %if.end17, label %if.then9\n+\n+if.then9:                                         ; preds = %if.else\n+  %fill14 = getelementptr inbounds %struct.rust_ivec_heap* %tmp7, i32 0, i32 0\n+  %tmp15 = load i32* %fill14, align 4, !tbaa !0\n+  br label %if.end17\n+\n+if.end17:                                         ; preds = %if.else, %entry, %if.then9\n+  %fill.0 = phi i32 [ %tmp15, %if.then9 ], [ %tmp2, %entry ], [ 0, %if.else ]\n+  %size = getelementptr inbounds %struct.type_desc* %ty, i32 0, i32 1\n+  %tmp20 = load i32* %size, align 4, !tbaa !0\n+  %div = udiv i32 %fill.0, %tmp20\n+  ret i32 %div\n+}\n+\n !0 = metadata !{metadata !\"long\", metadata !1}\n !1 = metadata !{metadata !\"omnipotent char\", metadata !2}\n !2 = metadata !{metadata !\"Simple C/C++ TBAA\", null}\n+!3 = metadata !{metadata !\"any pointer\", metadata !1}"}, {"sha": "2437a5c364dd468f5075c343afa2e09c5e29b18e", "filename": "src/rt/rust_builtin.cpp", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/741e77174c89723b05eb3dd79c3c47b2d0cd24d8/src%2Frt%2Frust_builtin.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/741e77174c89723b05eb3dd79c3c47b2d0cd24d8/src%2Frt%2Frust_builtin.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_builtin.cpp?ref=741e77174c89723b05eb3dd79c3c47b2d0cd24d8", "patch": "@@ -576,6 +576,37 @@ get_time(rust_task *task, uint32_t *sec, uint32_t *usec) {\n }\n #endif\n \n+/**\n+ * Preallocates the exact number of bytes in the given interior vector.\n+ */\n+extern \"C\" void\n+ivec_reserve(rust_task *task, type_desc *ty, rust_ivec *v, size_t n_elems)\n+{\n+    size_t new_alloc = n_elems * ty->size;\n+    if (new_alloc <= v->alloc)\n+        return;     // Already big enough.\n+\n+    rust_ivec_heap *heap_part;\n+    if (v->fill) {\n+        // On stack; spill to heap.\n+        heap_part = (rust_ivec_heap *)task->malloc(new_alloc +\n+                                                   sizeof(size_t));\n+        heap_part->fill = v->fill;\n+        memcpy(&heap_part->data, v->payload.data, v->fill);\n+\n+        v->fill = 0;\n+        v->payload.ptr = heap_part;\n+    } else {\n+        // On heap; resize.\n+        heap_part = (rust_ivec_heap *)task->realloc(v->payload.ptr,\n+                                                    new_alloc);\n+        v->payload.ptr = heap_part;\n+    }\n+\n+    v->alloc = new_alloc;\n+}\n+\n+\n //\n // Local Variables:\n // mode: C++"}, {"sha": "be4a5a8d96efc9cd051db5dc71e9393ff7b6bd88", "filename": "src/rt/rustrt.def.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/741e77174c89723b05eb3dd79c3c47b2d0cd24d8/src%2Frt%2Frustrt.def.in", "raw_url": "https://github.com/rust-lang/rust/raw/741e77174c89723b05eb3dd79c3c47b2d0cd24d8/src%2Frt%2Frustrt.def.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frustrt.def.in?ref=741e77174c89723b05eb3dd79c3c47b2d0cd24d8", "patch": "@@ -9,6 +9,7 @@ debug_trap\n debug_tydesc\n do_gc\n get_time\n+ivec_reserve\n last_os_error\n rand_free\n rand_new"}]}