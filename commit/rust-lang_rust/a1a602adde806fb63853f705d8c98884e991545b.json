{"sha": "a1a602adde806fb63853f705d8c98884e991545b", "node_id": "C_kwDOAAsO6NoAKGExYTYwMmFkZGU4MDZmYjYzODUzZjcwNWQ4Yzk4ODg0ZTk5MTU0NWI", "commit": {"author": {"name": "The8472", "email": "git@infinite-source.de", "date": "2021-07-31T15:39:35Z"}, "committer": {"name": "The 8472", "email": "git@infinite-source.de", "date": "2022-03-21T21:29:38Z"}, "message": "add module-level documentation for vec's in-place iteration", "tree": {"sha": "4245ed4c7c540ce5f4ff17b07f6726bcbd0a641c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4245ed4c7c540ce5f4ff17b07f6726bcbd0a641c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a1a602adde806fb63853f705d8c98884e991545b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a1a602adde806fb63853f705d8c98884e991545b", "html_url": "https://github.com/rust-lang/rust/commit/a1a602adde806fb63853f705d8c98884e991545b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a1a602adde806fb63853f705d8c98884e991545b/comments", "author": {"login": "the8472", "id": 1065730, "node_id": "MDQ6VXNlcjEwNjU3MzA=", "avatar_url": "https://avatars.githubusercontent.com/u/1065730?v=4", "gravatar_id": "", "url": "https://api.github.com/users/the8472", "html_url": "https://github.com/the8472", "followers_url": "https://api.github.com/users/the8472/followers", "following_url": "https://api.github.com/users/the8472/following{/other_user}", "gists_url": "https://api.github.com/users/the8472/gists{/gist_id}", "starred_url": "https://api.github.com/users/the8472/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/the8472/subscriptions", "organizations_url": "https://api.github.com/users/the8472/orgs", "repos_url": "https://api.github.com/users/the8472/repos", "events_url": "https://api.github.com/users/the8472/events{/privacy}", "received_events_url": "https://api.github.com/users/the8472/received_events", "type": "User", "site_admin": false}, "committer": {"login": "the8472", "id": 1065730, "node_id": "MDQ6VXNlcjEwNjU3MzA=", "avatar_url": "https://avatars.githubusercontent.com/u/1065730?v=4", "gravatar_id": "", "url": "https://api.github.com/users/the8472", "html_url": "https://github.com/the8472", "followers_url": "https://api.github.com/users/the8472/followers", "following_url": "https://api.github.com/users/the8472/following{/other_user}", "gists_url": "https://api.github.com/users/the8472/gists{/gist_id}", "starred_url": "https://api.github.com/users/the8472/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/the8472/subscriptions", "organizations_url": "https://api.github.com/users/the8472/orgs", "repos_url": "https://api.github.com/users/the8472/repos", "events_url": "https://api.github.com/users/the8472/events{/privacy}", "received_events_url": "https://api.github.com/users/the8472/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "79b43b35bee22c89334485d8847c4fae0b54a6c6", "url": "https://api.github.com/repos/rust-lang/rust/commits/79b43b35bee22c89334485d8847c4fae0b54a6c6", "html_url": "https://github.com/rust-lang/rust/commit/79b43b35bee22c89334485d8847c4fae0b54a6c6"}], "stats": {"total": 188, "additions": 168, "deletions": 20}, "files": [{"sha": "2ab52a4d58401b53f01f263d7a20e6e99c1c4013", "filename": "library/alloc/src/collections/binary_heap.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a1a602adde806fb63853f705d8c98884e991545b/library%2Falloc%2Fsrc%2Fcollections%2Fbinary_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1a602adde806fb63853f705d8c98884e991545b/library%2Falloc%2Fsrc%2Fcollections%2Fbinary_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbinary_heap.rs?ref=a1a602adde806fb63853f705d8c98884e991545b", "patch": "@@ -1401,6 +1401,8 @@ impl<T> ExactSizeIterator for IntoIter<T> {\n #[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<T> FusedIterator for IntoIter<T> {}\n \n+// In addition to the SAFETY invariants of the following three unsafe traits\n+// also refer to the vec::in_place_collect module documentation to get an overview\n #[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n #[doc(hidden)]\n unsafe impl<T> SourceIter for IntoIter<T> {"}, {"sha": "59f7cc6b004d16adea6253d357cd5bea08e5b09f", "filename": "library/alloc/src/vec/in_place_collect.rs", "status": "modified", "additions": 152, "deletions": 20, "changes": 172, "blob_url": "https://github.com/rust-lang/rust/blob/a1a602adde806fb63853f705d8c98884e991545b/library%2Falloc%2Fsrc%2Fvec%2Fin_place_collect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1a602adde806fb63853f705d8c98884e991545b/library%2Falloc%2Fsrc%2Fvec%2Fin_place_collect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fvec%2Fin_place_collect.rs?ref=a1a602adde806fb63853f705d8c98884e991545b", "patch": "@@ -1,3 +1,132 @@\n+//! Inplace iterate-and-collect specialization for `Vec`\n+//!\n+//! The specialization in this module applies to iterators in the shape of\n+//! `source.adapter().adapter().adapter().collect::<Vec<U>>()`\n+//! where `source` is an owning iterator obtained from [`Vec<T>`], [`Box<[T]>`] (by conversion to `Vec`)\n+//! or [`BinaryHeap<T>`], the adapters each consume one or more items per step\n+//! (represented by [`InPlaceIterable`]), provide transitive access to `source` (via [`SourceIter`])\n+//! and thus the underlying allocation. And finally the layouts of `T` and `U` must\n+//! have the same size and alignment, this is currently ensured via const eval instead of trait\n+//! bounds.\n+//!\n+//! [`BinaryHeap<T>`]: crate::collections::BinaryHeap\n+//! [`Box<[T]>`]: crate::boxed::Box\n+//!\n+//! By extension some other collections which use `collect::Vec<_>()` internally in their\n+//! `FromIterator` implementation benefit from this too.\n+//!\n+//! Access to the underlying source goes through a further layer of indirection via the private\n+//! trait [`AsIntoIter`] to hide the implementation detail that other collections may use\n+//! `vec::IntoIter` internally.\n+//!\n+//! In-place iteration depends on the interaction of several unsafe traits, implementation\n+//! details of multiple parts in the iterator pipeline and often requires holistic reasoning\n+//! across multiple structs since iterators are executed cooperatively rather than having\n+//! a central evaluator/visitor struct executing all iterator components.\n+//!\n+//! # Reading from and writing to the same allocation\n+//!\n+//! By its nature collecting in place means that the reader and writer side of the iterator\n+//! use the same allocation. Since `fold()` and co. take a reference to the iterator for the\n+//! duration of the iteration that means we can't interleave the step of reading a value\n+//! and getting a reference to write to. Instead raw pointers must be used on the reader\n+//! and writer side.\n+//!\n+//! That writes never clobber a yet-to-be-read item is ensured by the [`InPlaceIterable`] requirements.\n+//!\n+//! # Layout constraints\n+//!\n+//! [`Allocator`] requires that `allocate()` and `deallocate()` have matching alignment and size.\n+//! Additionally this specialization doesn't make sense for ZSTs as there is no reallocation to\n+//! avoid and it would make pointer arithmetic more difficult.\n+//!\n+//! [`Allocator`]: core::alloc::Allocator\n+//!\n+//! # Drop- and panic-safety\n+//!\n+//! Iteration can panic, requiring dropping the already written parts but also the remainder of\n+//! the source. Iteration can also leave some source items unconsumed which must be dropped.\n+//! All those drops in turn can panic which then must either leak the allocation or abort to avoid\n+//! double-drops.\n+//!\n+//! These tasks are handled by [`InPlaceDrop`] and [`vec::IntoIter::forget_allocation_drop_remaining()`]\n+//!\n+//! [`vec::IntoIter::forget_allocation_drop_remaining()`]: super::IntoIter::forget_allocation_drop_remaining()\n+//!\n+//! # O(1) collect\n+//!\n+//! The main iteration itself is further specialized when the iterator implements\n+//! [`TrustedRandomAccessNoCoerce`] to let the optimizer see that it is a counted loop with a single\n+//! induction variable. This can turn some iterators into a noop, i.e. it reduces them from O(n) to\n+//! O(1). This particular optimization is quite fickle and doesn't always work, see [#79308]\n+//!\n+//! [#79308]: https://github.com/rust-lang/rust/issues/79308\n+//!\n+//! Since unchecked accesses through that trait do not advance the read pointer of `IntoIter`\n+//! this would interact unsoundly with the requirements about dropping the tail described above.\n+//! But since the normal `Drop` implementation of `IntoIter` would suffer from the same problem it\n+//! is only correct for `TrustedRandomAccessNoCoerce` to be implemented when the items don't\n+//! have a destructor. Thus that implicit requirement also makes the specialization safe to use for\n+//! in-place collection.\n+//!\n+//! # Adapter implementations\n+//!\n+//! The invariants for adapters are documented in [`SourceIter`] and [`InPlaceIterable`], but\n+//! getting them right can be rather subtle for multiple, sometimes non-local reasons.\n+//! For example `InPlaceIterable` would be valid to implement for [`Peekable`], except\n+//! that it is stateful, cloneable and `IntoIter`'s clone implementation shortens the underlying\n+//! allocation which means if the iterator has been peeked and then gets cloned there no longer is\n+//! enough room, thus breaking an invariant (#85322).\n+//!\n+//! [#85322]: https://github.com/rust-lang/rust/issues/85322\n+//! [`Peekable`]: core::iter::Peekable\n+//!\n+//!\n+//! # Examples\n+//!\n+//! Some cases that are optimized by this specialization, more can be found in the `Vec`\n+//! benchmarks:\n+//!\n+//! ```rust\n+//! # #[allow(dead_code)]\n+//! /// Converts a usize vec into an isize one.\n+//! pub fn cast(vec: Vec<usize>) -> Vec<isize> {\n+//!   // Does not allocate, free or panic. On optlevel>=2 it does not loop.\n+//!   // Of course this particular case could and should be written with `into_raw_parts` and\n+//!   // `from_raw_parts` instead.\n+//!   vec.into_iter().map(|u| u as isize).collect()\n+//! }\n+//! ```\n+//!\n+//! ```rust\n+//! # #[allow(dead_code)]\n+//! /// Drops remaining items in `src` and if the layouts of `T` and `U` match it\n+//! /// returns an empty Vec backed by the original allocation. Otherwise it returns a new\n+//! /// empty vec.\n+//! pub fn recycle_allocation<T, U>(src: Vec<T>) -> Vec<U> {\n+//!   src.into_iter().filter_map(|_| None).collect()\n+//! }\n+//! ```\n+//!\n+//! ```rust\n+//! let vec = vec![13usize; 1024];\n+//! let _ = vec.into_iter()\n+//!   .enumerate()\n+//!   .filter_map(|(idx, val)| if idx % 2 == 0 { Some(val+idx) } else {None})\n+//!   .collect::<Vec<_>>();\n+//!\n+//! // is equivalent to the following, but doesn't require bounds checks\n+//!\n+//! let mut vec = vec![13usize; 1024];\n+//! let mut write_idx = 0;\n+//! for idx in 0..vec.len() {\n+//!    if idx % 2 == 0 {\n+//!       vec[write_idx] = vec[idx] + idx;\n+//!       write_idx += 1;\n+//!    }\n+//! }\n+//! vec.truncate(write_idx);\n+//! ```\n use core::iter::{InPlaceIterable, SourceIter, TrustedRandomAccessNoCoerce};\n use core::mem::{self, ManuallyDrop};\n use core::ptr::{self};\n@@ -16,11 +145,8 @@ where\n     I: Iterator<Item = T> + SourceIter<Source: AsIntoIter> + InPlaceIterableMarker,\n {\n     default fn from_iter(mut iterator: I) -> Self {\n-        // Additional requirements which cannot expressed via trait bounds. We rely on const eval\n-        // instead:\n-        // a) no ZSTs as there would be no allocation to reuse and pointer arithmetic would panic\n-        // b) size match as required by Alloc contract\n-        // c) alignments match as required by Alloc contract\n+        // See \"Layout constraints\" section in the module documentation. We rely on const\n+        // optimization here since these conditions currently cannot be expressed as trait bounds\n         if mem::size_of::<T>() == 0\n             || mem::size_of::<T>()\n                 != mem::size_of::<<<I as SourceIter>::Source as AsIntoIter>::Item>()\n@@ -58,21 +184,13 @@ where\n             );\n         }\n \n-        // drop any remaining values at the tail of the source\n-        // but prevent drop of the allocation itself once IntoIter goes out of scope\n-        // if the drop panics then we also leak any elements collected into dst_buf\n+        // Drop any remaining values at the tail of the source but prevent drop of the allocation\n+        // itself once IntoIter goes out of scope.\n+        // If the drop panics then we also leak any elements collected into dst_buf.\n         //\n-        // FIXME: Since `SpecInPlaceCollect::collect_in_place` above might use\n-        // `__iterator_get_unchecked` internally, this call might be operating on\n-        // a `vec::IntoIter` with incorrect internal state regarding which elements\n-        // have already been \u201cconsumed\u201d. However, the `TrustedRandomIteratorNoCoerce`\n-        // implementation of `vec::IntoIter` is only present if the `Vec` elements\n-        // don\u2019t have a destructor, so it doesn\u2019t matter if elements are \u201cdropped multiple times\u201d\n-        // in this case.\n-        // This argument technically currently lacks justification from the `# Safety` docs for\n-        // `SourceIter`/`InPlaceIterable` and/or `TrustedRandomAccess`, so it might be possible that\n-        // someone could inadvertently create new library unsoundness\n-        // involving this `.forget_allocation_drop_remaining()` call.\n+        // Note: This access to the source wouldn't be allowed by the TrustedRandomIteratorNoCoerce\n+        // contract (used by SpecInPlaceCollect below). But see the \"O(1) collect\" section in the\n+        // module documenttation why this is ok anyway.\n         src.forget_allocation_drop_remaining();\n \n         let vec = unsafe { Vec::from_raw_parts(dst_buf, len, cap) };\n@@ -155,7 +273,21 @@ where\n     }\n }\n \n-// internal helper trait for in-place iteration specialization.\n+/// Internal helper trait for in-place iteration specialization.\n+///\n+/// Currently this is only implemented by [`vec::IntoIter`] - returning a reference to itself - and\n+/// [`binary_heap::IntoIter`] which returns a reference to its inner representation.\n+///\n+/// Since this is an internal trait it hides the implementation detail `binary_heap::IntoIter`\n+/// uses `vec::IntoIter` internally.\n+///\n+/// [`vec::IntoIter`]: super::IntoIter\n+/// [`binary_heap::IntoIter`]: crate::collections::binary_heap::IntoIter\n+///\n+/// # Safety\n+///\n+/// In-place iteration relies on implementation details of `vec::IntoIter`, most importantly that\n+/// it does not create references to the whole allocation during iteration, only raw pointers\n #[rustc_specialization_trait]\n pub(crate) unsafe trait AsIntoIter {\n     type Item;"}, {"sha": "f80d22d6bdb6d7dbf86d85ff4c24e5e3c53ecdad", "filename": "library/alloc/src/vec/into_iter.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a1a602adde806fb63853f705d8c98884e991545b/library%2Falloc%2Fsrc%2Fvec%2Finto_iter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1a602adde806fb63853f705d8c98884e991545b/library%2Falloc%2Fsrc%2Fvec%2Finto_iter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fvec%2Finto_iter.rs?ref=a1a602adde806fb63853f705d8c98884e991545b", "patch": "@@ -99,6 +99,9 @@ impl<T, A: Allocator> IntoIter<T, A> {\n     /// (&mut into_iter).for_each(core::mem::drop);\n     /// unsafe { core::ptr::write(&mut into_iter, Vec::new().into_iter()); }\n     /// ```\n+    ///\n+    /// This method is used by in-place iteration, refer to the vec::in_place_collect\n+    /// documentation for an overview.\n     #[cfg(not(no_global_oom_handling))]\n     pub(super) fn forget_allocation_drop_remaining(&mut self) {\n         let remaining = self.as_raw_mut_slice();\n@@ -325,6 +328,8 @@ unsafe impl<#[may_dangle] T, A: Allocator> Drop for IntoIter<T, A> {\n     }\n }\n \n+// In addition to the SAFETY invariants of the following three unsafe traits\n+// also refer to the vec::in_place_collect module documentation to get an overview\n #[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n #[doc(hidden)]\n unsafe impl<T, A: Allocator> InPlaceIterable for IntoIter<T, A> {}"}, {"sha": "4500b44b7e9aff39ccd2589d1cd0f8f7c68c23d1", "filename": "library/core/src/iter/adapters/mod.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a1a602adde806fb63853f705d8c98884e991545b/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1a602adde806fb63853f705d8c98884e991545b/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fmod.rs?ref=a1a602adde806fb63853f705d8c98884e991545b", "patch": "@@ -78,6 +78,11 @@ pub use self::zip::zip;\n /// The trait is unsafe because implementers must uphold additional safety properties.\n /// See [`as_inner`] for details.\n ///\n+/// The primary use of this trait is in-place iteration. Refer to the [`vec::in_place_collect`]\n+/// module documentation for more information.\n+///\n+/// [`vec::in_place_collect`]: ../../../../alloc/vec/in_place_collect/index.html\n+///\n /// # Examples\n ///\n /// Retrieving a partially consumed source:"}, {"sha": "da753745740d70cfd376f46f747a9b4bd6810f0e", "filename": "library/core/src/iter/traits/marker.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a1a602adde806fb63853f705d8c98884e991545b/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fmarker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1a602adde806fb63853f705d8c98884e991545b/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fmarker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fmarker.rs?ref=a1a602adde806fb63853f705d8c98884e991545b", "patch": "@@ -51,6 +51,10 @@ unsafe impl<I: TrustedLen + ?Sized> TrustedLen for &mut I {}\n /// in its place, assuming structural constraints of the source allow such an insertion.\n /// In other words this trait indicates that an iterator pipeline can be collected in place.\n ///\n+/// The primary use of this trait is in-place iteration. Refer to the [`vec::in_place_collect`]\n+/// module documentation for more information.\n+///\n+/// [`vec::in_place_collect`]: ../../../../alloc/vec/in_place_collect/index.html\n /// [`SourceIter`]: crate::iter::SourceIter\n /// [`next()`]: Iterator::next\n /// [`try_fold()`]: Iterator::try_fold"}]}