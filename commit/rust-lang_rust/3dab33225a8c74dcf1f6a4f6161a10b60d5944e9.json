{"sha": "3dab33225a8c74dcf1f6a4f6161a10b60d5944e9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNkYWIzMzIyNWE4Yzc0ZGNmMWY2YTRmNjE2MWExMGI2MGQ1OTQ0ZTk=", "commit": {"author": {"name": "Thomas Lively", "email": "7121787+tlively@users.noreply.github.com", "date": "2018-09-06T04:40:39Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2018-09-06T04:40:39Z"}, "message": "Merge branch 'master' into fix-submodules", "tree": {"sha": "24f2e486873ff3f12493265327d999767cf21599", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/24f2e486873ff3f12493265327d999767cf21599"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3dab33225a8c74dcf1f6a4f6161a10b60d5944e9", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJbkK/HCRBK7hj4Ov3rIwAAdHIIAHDMa/PZEJ4Vt8vQguKK2s+V\ny18N/Tapk3FUdyUJgh7GIkT+fDvgXj3CvCAdpDdnJHJFG+Cl6Y2wMbtCxNWzWSJB\nyKnPXNepZjN44yKXjhR+C7pQzhYu8BtFjcdf9qZOKZID7PVcEmYR9plr+bMyVUf+\nMzZV3ZR20zTQy9JLgpJzdoszqUielu+qvH0tMoQi2KB6eDKRUPE0JJQKSLMPegGi\nc1dvBzW9YhajusRpIyivwXgzr9KkNc2gfX2fZiohOAUZUhFb4L3j3mE51vSSjYNJ\na+NWcTkRoSZSo1JwUXme3ig9AqfO6+62JFXyJv6KNQGgMvlO//R+bdG1+Q6OnvQ=\n=rGVK\n-----END PGP SIGNATURE-----\n", "payload": "tree 24f2e486873ff3f12493265327d999767cf21599\nparent 482346ce75ff112bfbe991d37fb66057cb80c804\nparent 27e5457f3fa6c6e322e05352f0109f2cd511396c\nauthor Thomas Lively <7121787+tlively@users.noreply.github.com> 1536208839 -0700\ncommitter GitHub <noreply@github.com> 1536208839 -0700\n\nMerge branch 'master' into fix-submodules"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3dab33225a8c74dcf1f6a4f6161a10b60d5944e9", "html_url": "https://github.com/rust-lang/rust/commit/3dab33225a8c74dcf1f6a4f6161a10b60d5944e9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3dab33225a8c74dcf1f6a4f6161a10b60d5944e9/comments", "author": {"login": "tlively", "id": 7121787, "node_id": "MDQ6VXNlcjcxMjE3ODc=", "avatar_url": "https://avatars.githubusercontent.com/u/7121787?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tlively", "html_url": "https://github.com/tlively", "followers_url": "https://api.github.com/users/tlively/followers", "following_url": "https://api.github.com/users/tlively/following{/other_user}", "gists_url": "https://api.github.com/users/tlively/gists{/gist_id}", "starred_url": "https://api.github.com/users/tlively/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tlively/subscriptions", "organizations_url": "https://api.github.com/users/tlively/orgs", "repos_url": "https://api.github.com/users/tlively/repos", "events_url": "https://api.github.com/users/tlively/events{/privacy}", "received_events_url": "https://api.github.com/users/tlively/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "482346ce75ff112bfbe991d37fb66057cb80c804", "url": "https://api.github.com/repos/rust-lang/rust/commits/482346ce75ff112bfbe991d37fb66057cb80c804", "html_url": "https://github.com/rust-lang/rust/commit/482346ce75ff112bfbe991d37fb66057cb80c804"}, {"sha": "27e5457f3fa6c6e322e05352f0109f2cd511396c", "url": "https://api.github.com/repos/rust-lang/rust/commits/27e5457f3fa6c6e322e05352f0109f2cd511396c", "html_url": "https://github.com/rust-lang/rust/commit/27e5457f3fa6c6e322e05352f0109f2cd511396c"}], "stats": {"total": 1903, "additions": 1210, "deletions": 693}, "files": [{"sha": "038237aa179a9b421aab40eb989f03d1679a073f", "filename": ".gitmodules", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3dab33225a8c74dcf1f6a4f6161a10b60d5944e9/.gitmodules", "raw_url": "https://github.com/rust-lang/rust/raw/3dab33225a8c74dcf1f6a4f6161a10b60d5944e9/.gitmodules", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.gitmodules?ref=3dab33225a8c74dcf1f6a4f6161a10b60d5944e9", "patch": "@@ -59,8 +59,9 @@\n [submodule \"src/tools/lldb\"]\n \tpath = src/tools/lldb\n \turl = https://github.com/rust-lang-nursery/lldb.git\n-\tbranch = rust-release-70\n+\tbranch = rust-release-80-v1\n [submodule \"src/tools/clang\"]\n \tpath = src/tools/clang\n \turl = https://github.com/rust-lang-nursery/clang.git\n-\tbranch = release_70\n+\tbranch = rust-release-80-v1\n+  \n\\ No newline at end of file"}, {"sha": "b1701e4a65451aa82205f0c1af1211ef3e007ae2", "filename": ".travis.yml", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3dab33225a8c74dcf1f6a4f6161a10b60d5944e9/.travis.yml", "raw_url": "https://github.com/rust-lang/rust/raw/3dab33225a8c74dcf1f6a4f6161a10b60d5944e9/.travis.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.travis.yml?ref=3dab33225a8c74dcf1f6a4f6161a10b60d5944e9", "patch": "@@ -30,7 +30,7 @@ matrix:\n \n     - env: >\n         RUST_CHECK_TARGET=dist\n-        RUST_CONFIGURE_ARGS=\"--enable-extended --enable-profiler\"\n+        RUST_CONFIGURE_ARGS=\"--enable-extended --enable-profiler --enable-lldb\"\n         SRC=.\n         DEPLOY_ALT=1\n         RUSTC_RETRY_LINKER_ON_SEGFAULT=1\n@@ -87,7 +87,7 @@ matrix:\n     # OSX 10.7 and `xcode7` is the latest Xcode able to compile LLVM for 10.7.\n     - env: >\n         RUST_CHECK_TARGET=dist\n-        RUST_CONFIGURE_ARGS=\"--build=i686-apple-darwin --enable-full-tools --enable-profiler\"\n+        RUST_CONFIGURE_ARGS=\"--build=i686-apple-darwin --enable-full-tools --enable-profiler --enable-lldb\"\n         SRC=.\n         DEPLOY=1\n         RUSTC_RETRY_LINKER_ON_SEGFAULT=1\n@@ -101,7 +101,7 @@ matrix:\n \n     - env: >\n         RUST_CHECK_TARGET=dist\n-        RUST_CONFIGURE_ARGS=\"--target=aarch64-apple-ios,armv7-apple-ios,armv7s-apple-ios,i386-apple-ios,x86_64-apple-ios --enable-full-tools --enable-sanitizers --enable-profiler\"\n+        RUST_CONFIGURE_ARGS=\"--target=aarch64-apple-ios,armv7-apple-ios,armv7s-apple-ios,i386-apple-ios,x86_64-apple-ios --enable-full-tools --enable-sanitizers --enable-profiler --enable-lldb\"\n         SRC=.\n         DEPLOY=1\n         RUSTC_RETRY_LINKER_ON_SEGFAULT=1"}, {"sha": "a4f9082c284cd226770dfcf74e5e924f216d9b1b", "filename": "src/Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3dab33225a8c74dcf1f6a4f6161a10b60d5944e9/src%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/3dab33225a8c74dcf1f6a4f6161a10b60d5944e9/src%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FCargo.lock?ref=3dab33225a8c74dcf1f6a4f6161a10b60d5944e9", "patch": "@@ -2739,6 +2739,7 @@ name = \"syntax_ext\"\n version = \"0.0.0\"\n dependencies = [\n  \"fmt_macros 0.0.0\",\n+ \"log 0.4.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"proc_macro 0.0.0\",\n  \"rustc_data_structures 0.0.0\",\n  \"rustc_errors 0.0.0\","}, {"sha": "c3282275f6fd48969cf35df75113b5a946189f88", "filename": "src/bootstrap/dist.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3dab33225a8c74dcf1f6a4f6161a10b60d5944e9/src%2Fbootstrap%2Fdist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dab33225a8c74dcf1f6a4f6161a10b60d5944e9/src%2Fbootstrap%2Fdist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdist.rs?ref=3dab33225a8c74dcf1f6a4f6161a10b60d5944e9", "patch": "@@ -1913,7 +1913,7 @@ fn maybe_install_llvm_dylib(builder: &Builder,\n                    llvm_dylib_path.display(), e);\n         });\n \n-        let dst_libdir = image.join(\"lib\");\n+        let dst_libdir = image.join(\"lib/rustlib\").join(&*target).join(\"lib\");\n         t!(fs::create_dir_all(&dst_libdir));\n \n         builder.install(&llvm_dylib_path, &dst_libdir, 0o644);\n@@ -1967,7 +1967,9 @@ impl Step for LlvmTools {\n         let src_bindir = builder\n             .llvm_out(target)\n             .join(\"bin\");\n-        let dst_bindir = image.join(\"bin\");\n+        let dst_bindir = image.join(\"lib/rustlib\")\n+            .join(&*target)\n+            .join(\"bin\");\n         t!(fs::create_dir_all(&dst_bindir));\n         for tool in LLVM_TOOLS {\n             let exe = src_bindir.join(exe(tool, &target));"}, {"sha": "3990b6ad2f080f4efca3a2ce37380a75b534d9bb", "filename": "src/doc/unstable-book/src/language-features/custom-test-frameworks.md", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/3dab33225a8c74dcf1f6a4f6161a10b60d5944e9/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fcustom-test-frameworks.md", "raw_url": "https://github.com/rust-lang/rust/raw/3dab33225a8c74dcf1f6a4f6161a10b60d5944e9/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fcustom-test-frameworks.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fcustom-test-frameworks.md?ref=3dab33225a8c74dcf1f6a4f6161a10b60d5944e9", "patch": "@@ -0,0 +1,33 @@\n+# `custom_test_frameworks`\n+\n+The tracking issue for this feature is: [#50297]\n+\n+[#50297]: https://github.com/rust-lang/rust/issues/50297\n+\n+------------------------\n+\n+The `custom_test_frameworks` feature allows the use of `#[test_case]` and `#![test_runner]`.\n+Any function, const, or static can be annotated with `#[test_case]` causing it to be aggregated (like `#[test]`)\n+and be passed to the test runner determined by the `#![test_runner]` crate attribute.\n+\n+```rust\n+#![feature(custom_test_frameworks)]\n+#![test_runner(my_runner)]\n+\n+fn my_runner(tests: &[&i32]) {\n+    for t in tests {\n+        if **t == 0 {\n+            println!(\"PASSED\");\n+        } else {\n+            println!(\"FAILED\");\n+        }\n+    }\n+}\n+\n+#[test_case]\n+const WILL_PASS: i32 = 0;\n+\n+#[test_case]\n+const WILL_FAIL: i32 = 4;\n+```\n+"}, {"sha": "a5fa7f0c4d938a96332bc64bf6ee64ad528698a8", "filename": "src/liballoc/tests/str.rs", "status": "modified", "additions": 38, "deletions": 30, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/3dab33225a8c74dcf1f6a4f6161a10b60d5944e9/src%2Fliballoc%2Ftests%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dab33225a8c74dcf1f6a4f6161a10b60d5944e9/src%2Fliballoc%2Ftests%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fstr.rs?ref=3dab33225a8c74dcf1f6a4f6161a10b60d5944e9", "patch": "@@ -727,33 +727,33 @@ fn test_is_char_boundary() {\n }\n \n #[test]\n-fn test_trim_left_matches() {\n+fn test_trim_start_matches() {\n     let v: &[char] = &[];\n-    assert_eq!(\" *** foo *** \".trim_left_matches(v), \" *** foo *** \");\n+    assert_eq!(\" *** foo *** \".trim_start_matches(v), \" *** foo *** \");\n     let chars: &[char] = &['*', ' '];\n-    assert_eq!(\" *** foo *** \".trim_left_matches(chars), \"foo *** \");\n-    assert_eq!(\" ***  *** \".trim_left_matches(chars), \"\");\n-    assert_eq!(\"foo *** \".trim_left_matches(chars), \"foo *** \");\n+    assert_eq!(\" *** foo *** \".trim_start_matches(chars), \"foo *** \");\n+    assert_eq!(\" ***  *** \".trim_start_matches(chars), \"\");\n+    assert_eq!(\"foo *** \".trim_start_matches(chars), \"foo *** \");\n \n-    assert_eq!(\"11foo1bar11\".trim_left_matches('1'), \"foo1bar11\");\n+    assert_eq!(\"11foo1bar11\".trim_start_matches('1'), \"foo1bar11\");\n     let chars: &[char] = &['1', '2'];\n-    assert_eq!(\"12foo1bar12\".trim_left_matches(chars), \"foo1bar12\");\n-    assert_eq!(\"123foo1bar123\".trim_left_matches(|c: char| c.is_numeric()), \"foo1bar123\");\n+    assert_eq!(\"12foo1bar12\".trim_start_matches(chars), \"foo1bar12\");\n+    assert_eq!(\"123foo1bar123\".trim_start_matches(|c: char| c.is_numeric()), \"foo1bar123\");\n }\n \n #[test]\n-fn test_trim_right_matches() {\n+fn test_trim_end_matches() {\n     let v: &[char] = &[];\n-    assert_eq!(\" *** foo *** \".trim_right_matches(v), \" *** foo *** \");\n+    assert_eq!(\" *** foo *** \".trim_end_matches(v), \" *** foo *** \");\n     let chars: &[char] = &['*', ' '];\n-    assert_eq!(\" *** foo *** \".trim_right_matches(chars), \" *** foo\");\n-    assert_eq!(\" ***  *** \".trim_right_matches(chars), \"\");\n-    assert_eq!(\" *** foo\".trim_right_matches(chars), \" *** foo\");\n+    assert_eq!(\" *** foo *** \".trim_end_matches(chars), \" *** foo\");\n+    assert_eq!(\" ***  *** \".trim_end_matches(chars), \"\");\n+    assert_eq!(\" *** foo\".trim_end_matches(chars), \" *** foo\");\n \n-    assert_eq!(\"11foo1bar11\".trim_right_matches('1'), \"11foo1bar\");\n+    assert_eq!(\"11foo1bar11\".trim_end_matches('1'), \"11foo1bar\");\n     let chars: &[char] = &['1', '2'];\n-    assert_eq!(\"12foo1bar12\".trim_right_matches(chars), \"12foo1bar\");\n-    assert_eq!(\"123foo1bar123\".trim_right_matches(|c: char| c.is_numeric()), \"123foo1bar\");\n+    assert_eq!(\"12foo1bar12\".trim_end_matches(chars), \"12foo1bar\");\n+    assert_eq!(\"123foo1bar123\".trim_end_matches(|c: char| c.is_numeric()), \"123foo1bar\");\n }\n \n #[test]\n@@ -772,23 +772,23 @@ fn test_trim_matches() {\n }\n \n #[test]\n-fn test_trim_left() {\n-    assert_eq!(\"\".trim_left(), \"\");\n-    assert_eq!(\"a\".trim_left(), \"a\");\n-    assert_eq!(\"    \".trim_left(), \"\");\n-    assert_eq!(\"     blah\".trim_left(), \"blah\");\n-    assert_eq!(\"   \\u{3000}  wut\".trim_left(), \"wut\");\n-    assert_eq!(\"hey \".trim_left(), \"hey \");\n+fn test_trim_start() {\n+    assert_eq!(\"\".trim_start(), \"\");\n+    assert_eq!(\"a\".trim_start(), \"a\");\n+    assert_eq!(\"    \".trim_start(), \"\");\n+    assert_eq!(\"     blah\".trim_start(), \"blah\");\n+    assert_eq!(\"   \\u{3000}  wut\".trim_start(), \"wut\");\n+    assert_eq!(\"hey \".trim_start(), \"hey \");\n }\n \n #[test]\n-fn test_trim_right() {\n-    assert_eq!(\"\".trim_right(), \"\");\n-    assert_eq!(\"a\".trim_right(), \"a\");\n-    assert_eq!(\"    \".trim_right(), \"\");\n-    assert_eq!(\"blah     \".trim_right(), \"blah\");\n-    assert_eq!(\"wut   \\u{3000}  \".trim_right(), \"wut\");\n-    assert_eq!(\" hey\".trim_right(), \" hey\");\n+fn test_trim_end() {\n+    assert_eq!(\"\".trim_end(), \"\");\n+    assert_eq!(\"a\".trim_end(), \"a\");\n+    assert_eq!(\"    \".trim_end(), \"\");\n+    assert_eq!(\"blah     \".trim_end(), \"blah\");\n+    assert_eq!(\"wut   \\u{3000}  \".trim_end(), \"wut\");\n+    assert_eq!(\" hey\".trim_end(), \" hey\");\n }\n \n #[test]\n@@ -1518,12 +1518,20 @@ fn trim_ws() {\n                     \"a \\t  \");\n     assert_eq!(\" \\t  a \\t  \".trim_right_matches(|c: char| c.is_whitespace()),\n                \" \\t  a\");\n+    assert_eq!(\" \\t  a \\t  \".trim_start_matches(|c: char| c.is_whitespace()),\n+                    \"a \\t  \");\n+    assert_eq!(\" \\t  a \\t  \".trim_end_matches(|c: char| c.is_whitespace()),\n+               \" \\t  a\");\n     assert_eq!(\" \\t  a \\t  \".trim_matches(|c: char| c.is_whitespace()),\n                     \"a\");\n     assert_eq!(\" \\t   \\t  \".trim_left_matches(|c: char| c.is_whitespace()),\n                          \"\");\n     assert_eq!(\" \\t   \\t  \".trim_right_matches(|c: char| c.is_whitespace()),\n                \"\");\n+    assert_eq!(\" \\t   \\t  \".trim_start_matches(|c: char| c.is_whitespace()),\n+                         \"\");\n+    assert_eq!(\" \\t   \\t  \".trim_end_matches(|c: char| c.is_whitespace()),\n+               \"\");\n     assert_eq!(\" \\t   \\t  \".trim_matches(|c: char| c.is_whitespace()),\n                \"\");\n }"}, {"sha": "2c941c28d4b80e938583864558c399e7a10f7ab2", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 157, "deletions": 13, "changes": 170, "blob_url": "https://github.com/rust-lang/rust/blob/3dab33225a8c74dcf1f6a4f6161a10b60d5944e9/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dab33225a8c74dcf1f6a4f6161a10b60d5944e9/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=3dab33225a8c74dcf1f6a4f6161a10b60d5944e9", "patch": "@@ -3563,6 +3563,76 @@ impl str {\n         self.trim_matches(|c: char| c.is_whitespace())\n     }\n \n+    /// Returns a string slice with leading whitespace removed.\n+    ///\n+    /// 'Whitespace' is defined according to the terms of the Unicode Derived\n+    /// Core Property `White_Space`.\n+    ///\n+    /// # Text directionality\n+    ///\n+    /// A string is a sequence of bytes. `start` in this context means the first\n+    /// position of that byte string; for a left-to-right language like English or\n+    /// Russian, this will be left side; and for right-to-left languages like\n+    /// like Arabic or Hebrew, this will be the right side.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let s = \" Hello\\tworld\\t\";\n+    /// assert_eq!(\"Hello\\tworld\\t\", s.trim_start());\n+    /// ```\n+    ///\n+    /// Directionality:\n+    ///\n+    /// ```\n+    /// let s = \"  English  \";\n+    /// assert!(Some('E') == s.trim_start().chars().next());\n+    ///\n+    /// let s = \"  \u05e2\u05d1\u05e8\u05d9\u05ea  \";\n+    /// assert!(Some('\u05e2') == s.trim_start().chars().next());\n+    /// ```\n+    #[stable(feature = \"trim_direction\", since = \"1.30.0\")]\n+    pub fn trim_start(&self) -> &str {\n+        self.trim_start_matches(|c: char| c.is_whitespace())\n+    }\n+\n+    /// Returns a string slice with trailing whitespace removed.\n+    ///\n+    /// 'Whitespace' is defined according to the terms of the Unicode Derived\n+    /// Core Property `White_Space`.\n+    ///\n+    /// # Text directionality\n+    ///\n+    /// A string is a sequence of bytes. `end` in this context means the last\n+    /// position of that byte string; for a left-to-right language like English or\n+    /// Russian, this will be right side; and for right-to-left languages like\n+    /// like Arabic or Hebrew, this will be the left side.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let s = \" Hello\\tworld\\t\";\n+    /// assert_eq!(\" Hello\\tworld\", s.trim_end());\n+    /// ```\n+    ///\n+    /// Directionality:\n+    ///\n+    /// ```\n+    /// let s = \"  English  \";\n+    /// assert!(Some('h') == s.trim_end().chars().rev().next());\n+    ///\n+    /// let s = \"  \u05e2\u05d1\u05e8\u05d9\u05ea  \";\n+    /// assert!(Some('\u05ea') == s.trim_end().chars().rev().next());\n+    /// ```\n+    #[stable(feature = \"trim_direction\", since = \"1.30.0\")]\n+    pub fn trim_end(&self) -> &str {\n+        self.trim_end_matches(|c: char| c.is_whitespace())\n+    }\n+\n     /// Returns a string slice with leading whitespace removed.\n     ///\n     /// 'Whitespace' is defined according to the terms of the Unicode Derived\n@@ -3595,8 +3665,9 @@ impl str {\n     /// assert!(Some('\u05e2') == s.trim_left().chars().next());\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[rustc_deprecated(reason = \"superseded by `trim_start`\", since = \"1.33.0\")]\n     pub fn trim_left(&self) -> &str {\n-        self.trim_left_matches(|c: char| c.is_whitespace())\n+        self.trim_start()\n     }\n \n     /// Returns a string slice with trailing whitespace removed.\n@@ -3631,8 +3702,9 @@ impl str {\n     /// assert!(Some('\u05ea') == s.trim_right().chars().rev().next());\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[rustc_deprecated(reason = \"superseded by `trim_end`\", since = \"1.33.0\")]\n     pub fn trim_right(&self) -> &str {\n-        self.trim_right_matches(|c: char| c.is_whitespace())\n+        self.trim_end()\n     }\n \n     /// Returns a string slice with all prefixes and suffixes that match a\n@@ -3697,14 +3769,14 @@ impl str {\n     /// Basic usage:\n     ///\n     /// ```\n-    /// assert_eq!(\"11foo1bar11\".trim_left_matches('1'), \"foo1bar11\");\n-    /// assert_eq!(\"123foo1bar123\".trim_left_matches(char::is_numeric), \"foo1bar123\");\n+    /// assert_eq!(\"11foo1bar11\".trim_start_matches('1'), \"foo1bar11\");\n+    /// assert_eq!(\"123foo1bar123\".trim_start_matches(char::is_numeric), \"foo1bar123\");\n     ///\n     /// let x: &[_] = &['1', '2'];\n-    /// assert_eq!(\"12foo1bar12\".trim_left_matches(x), \"foo1bar12\");\n+    /// assert_eq!(\"12foo1bar12\".trim_start_matches(x), \"foo1bar12\");\n     /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn trim_left_matches<'a, P: Pattern<'a>>(&'a self, pat: P) -> &'a str {\n+    #[stable(feature = \"trim_direction\", since = \"1.30.0\")]\n+    pub fn trim_start_matches<'a, P: Pattern<'a>>(&'a self, pat: P) -> &'a str {\n         let mut i = self.len();\n         let mut matcher = pat.into_searcher(self);\n         if let Some((a, _)) = matcher.next_reject() {\n@@ -3734,20 +3806,20 @@ impl str {\n     /// Simple patterns:\n     ///\n     /// ```\n-    /// assert_eq!(\"11foo1bar11\".trim_right_matches('1'), \"11foo1bar\");\n-    /// assert_eq!(\"123foo1bar123\".trim_right_matches(char::is_numeric), \"123foo1bar\");\n+    /// assert_eq!(\"11foo1bar11\".trim_end_matches('1'), \"11foo1bar\");\n+    /// assert_eq!(\"123foo1bar123\".trim_end_matches(char::is_numeric), \"123foo1bar\");\n     ///\n     /// let x: &[_] = &['1', '2'];\n-    /// assert_eq!(\"12foo1bar12\".trim_right_matches(x), \"12foo1bar\");\n+    /// assert_eq!(\"12foo1bar12\".trim_end_matches(x), \"12foo1bar\");\n     /// ```\n     ///\n     /// A more complex pattern, using a closure:\n     ///\n     /// ```\n-    /// assert_eq!(\"1fooX\".trim_right_matches(|c| c == '1' || c == 'X'), \"1foo\");\n+    /// assert_eq!(\"1fooX\".trim_end_matches(|c| c == '1' || c == 'X'), \"1foo\");\n     /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn trim_right_matches<'a, P: Pattern<'a>>(&'a self, pat: P) -> &'a str\n+    #[stable(feature = \"trim_direction\", since = \"1.30.0\")]\n+    pub fn trim_end_matches<'a, P: Pattern<'a>>(&'a self, pat: P) -> &'a str\n         where P::Searcher: ReverseSearcher<'a>\n     {\n         let mut j = 0;\n@@ -3761,6 +3833,78 @@ impl str {\n         }\n     }\n \n+    /// Returns a string slice with all prefixes that match a pattern\n+    /// repeatedly removed.\n+    ///\n+    /// The pattern can be a `&str`, [`char`], or a closure that determines if\n+    /// a character matches.\n+    ///\n+    /// [`char`]: primitive.char.html\n+    ///\n+    /// # Text directionality\n+    ///\n+    /// A string is a sequence of bytes. 'Left' in this context means the first\n+    /// position of that byte string; for a language like Arabic or Hebrew\n+    /// which are 'right to left' rather than 'left to right', this will be\n+    /// the _right_ side, not the left.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// assert_eq!(\"11foo1bar11\".trim_left_matches('1'), \"foo1bar11\");\n+    /// assert_eq!(\"123foo1bar123\".trim_left_matches(char::is_numeric), \"foo1bar123\");\n+    ///\n+    /// let x: &[_] = &['1', '2'];\n+    /// assert_eq!(\"12foo1bar12\".trim_left_matches(x), \"foo1bar12\");\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[rustc_deprecated(reason = \"superseded by `trim_start_matches`\", since = \"1.33.0\")]\n+    pub fn trim_left_matches<'a, P: Pattern<'a>>(&'a self, pat: P) -> &'a str {\n+        self.trim_start_matches(pat)\n+    }\n+\n+    /// Returns a string slice with all suffixes that match a pattern\n+    /// repeatedly removed.\n+    ///\n+    /// The pattern can be a `&str`, [`char`], or a closure that\n+    /// determines if a character matches.\n+    ///\n+    /// [`char`]: primitive.char.html\n+    ///\n+    /// # Text directionality\n+    ///\n+    /// A string is a sequence of bytes. 'Right' in this context means the last\n+    /// position of that byte string; for a language like Arabic or Hebrew\n+    /// which are 'right to left' rather than 'left to right', this will be\n+    /// the _left_ side, not the right.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Simple patterns:\n+    ///\n+    /// ```\n+    /// assert_eq!(\"11foo1bar11\".trim_right_matches('1'), \"11foo1bar\");\n+    /// assert_eq!(\"123foo1bar123\".trim_right_matches(char::is_numeric), \"123foo1bar\");\n+    ///\n+    /// let x: &[_] = &['1', '2'];\n+    /// assert_eq!(\"12foo1bar12\".trim_right_matches(x), \"12foo1bar\");\n+    /// ```\n+    ///\n+    /// A more complex pattern, using a closure:\n+    ///\n+    /// ```\n+    /// assert_eq!(\"1fooX\".trim_right_matches(|c| c == '1' || c == 'X'), \"1foo\");\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[rustc_deprecated(reason = \"superseded by `trim_end_matches`\", since = \"1.33.0\")]\n+    pub fn trim_right_matches<'a, P: Pattern<'a>>(&'a self, pat: P) -> &'a str\n+        where P::Searcher: ReverseSearcher<'a>\n+    {\n+        self.trim_end_matches(pat)\n+    }\n+\n     /// Parses this string slice into another type.\n     ///\n     /// Because `parse` is so general, it can cause problems with type"}, {"sha": "25bc662c408f65ca47e545e66b2de7ae029172bc", "filename": "src/librustc_codegen_llvm/back/lto.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3dab33225a8c74dcf1f6a4f6161a10b60d5944e9/src%2Flibrustc_codegen_llvm%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dab33225a8c74dcf1f6a4f6161a10b60d5944e9/src%2Flibrustc_codegen_llvm%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Flto.rs?ref=3dab33225a8c74dcf1f6a4f6161a10b60d5944e9", "patch": "@@ -29,7 +29,7 @@ use {ModuleCodegen, ModuleLlvm, ModuleKind};\n use libc;\n \n use std::ffi::{CStr, CString};\n-use std::fs::{self, File};\n+use std::fs;\n use std::ptr;\n use std::slice;\n use std::sync::Arc;\n@@ -619,15 +619,15 @@ fn run_pass_manager(cgcx: &CodegenContext,\n pub enum SerializedModule {\n     Local(ModuleBuffer),\n     FromRlib(Vec<u8>),\n-    FromUncompressedFile(memmap::Mmap, File),\n+    FromUncompressedFile(memmap::Mmap),\n }\n \n impl SerializedModule {\n     fn data(&self) -> &[u8] {\n         match *self {\n             SerializedModule::Local(ref m) => m.data(),\n             SerializedModule::FromRlib(ref m) => m,\n-            SerializedModule::FromUncompressedFile(ref m, _) => m,\n+            SerializedModule::FromUncompressedFile(ref m) => m,\n         }\n     }\n }"}, {"sha": "6b257ed4c3e94f8b23e386eab095afd3ad350e4c", "filename": "src/librustc_codegen_llvm/back/write.rs", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/3dab33225a8c74dcf1f6a4f6161a10b60d5944e9/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dab33225a8c74dcf1f6a4f6161a10b60d5944e9/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs?ref=3dab33225a8c74dcf1f6a4f6161a10b60d5944e9", "patch": "@@ -176,13 +176,22 @@ pub fn target_machine_factory(sess: &Session, find_features: bool)\n         None => llvm::CodeModel::None,\n     };\n \n-    let singlethread = sess.target.target.options.singlethread;\n+    let features = attributes::llvm_target_features(sess).collect::<Vec<_>>();\n+    let mut singlethread = sess.target.target.options.singlethread;\n+\n+    // On the wasm target once the `atomics` feature is enabled that means that\n+    // we're no longer single-threaded, or otherwise we don't want LLVM to\n+    // lower atomic operations to single-threaded operations.\n+    if singlethread &&\n+        sess.target.target.llvm_target.contains(\"wasm32\") &&\n+        features.iter().any(|s| *s == \"+atomics\")\n+    {\n+        singlethread = false;\n+    }\n \n     let triple = SmallCStr::new(&sess.target.target.llvm_target);\n     let cpu = SmallCStr::new(llvm_util::target_cpu(sess));\n-    let features = attributes::llvm_target_features(sess)\n-        .collect::<Vec<_>>()\n-        .join(\",\");\n+    let features = features.join(\",\");\n     let features = CString::new(features).unwrap();\n     let is_pie_binary = !find_features && is_pie_binary(sess);\n     let trap_unreachable = sess.target.target.options.trap_unreachable;\n@@ -2485,7 +2494,7 @@ pub(crate) fn submit_pre_lto_module_to_llvm(tcx: TyCtxt,\n \n     // Schedule the module to be loaded\n     drop(tcx.tx_to_llvm_workers.lock().send(Box::new(Message::AddImportOnlyModule {\n-        module_data: SerializedModule::FromUncompressedFile(mmap, file),\n+        module_data: SerializedModule::FromUncompressedFile(mmap),\n         work_product: module.source,\n     })));\n }"}, {"sha": "9e8ff2047036bc6767fe75c04dd97a57f81648ef", "filename": "src/librustc_codegen_llvm/llvm_util.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3dab33225a8c74dcf1f6a4f6161a10b60d5944e9/src%2Flibrustc_codegen_llvm%2Fllvm_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dab33225a8c74dcf1f6a4f6161a10b60d5944e9/src%2Flibrustc_codegen_llvm%2Fllvm_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fllvm_util.rs?ref=3dab33225a8c74dcf1f6a4f6161a10b60d5944e9", "patch": "@@ -177,6 +177,7 @@ const MIPS_WHITELIST: &[(&str, Option<&str>)] = &[\n \n const WASM_WHITELIST: &[(&str, Option<&str>)] = &[\n     (\"simd128\", Some(\"wasm_target_feature\")),\n+    (\"atomics\", Some(\"wasm_target_feature\")),\n ];\n \n /// When rustdoc is running, provide a list of all known features so that all their respective"}, {"sha": "d27b0856c1533358ba39d074ebc286d1b85a1239", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3dab33225a8c74dcf1f6a4f6161a10b60d5944e9/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dab33225a8c74dcf1f6a4f6161a10b60d5944e9/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=3dab33225a8c74dcf1f6a4f6161a10b60d5944e9", "patch": "@@ -828,7 +828,6 @@ where\n     let (mut krate, features) = syntax::config::features(\n         krate,\n         &sess.parse_sess,\n-        sess.opts.test,\n         sess.edition(),\n     );\n     // these need to be set \"early\" so that expansion sees `quote` if enabled."}, {"sha": "8ebb181247cfd369599a442887104db3e867db6c", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 40, "deletions": 27, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/3dab33225a8c74dcf1f6a4f6161a10b60d5944e9/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dab33225a8c74dcf1f6a4f6161a10b60d5944e9/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=3dab33225a8c74dcf1f6a4f6161a10b60d5944e9", "patch": "@@ -1835,43 +1835,56 @@ impl EarlyLintPass for EllipsisInclusiveRangePatterns {\n }\n \n declare_lint! {\n-    UNNAMEABLE_TEST_FUNCTIONS,\n+    UNNAMEABLE_TEST_ITEMS,\n     Warn,\n-    \"detects an function that cannot be named being marked as #[test]\"\n+    \"detects an item that cannot be named being marked as #[test_case]\",\n+    report_in_external_macro: true\n+}\n+\n+pub struct UnnameableTestItems {\n+    boundary: ast::NodeId, // NodeId of the item under which things are not nameable\n+    items_nameable: bool,\n }\n \n-pub struct UnnameableTestFunctions;\n+impl UnnameableTestItems {\n+    pub fn new() -> Self {\n+        Self {\n+            boundary: ast::DUMMY_NODE_ID,\n+            items_nameable: true\n+        }\n+    }\n+}\n \n-impl LintPass for UnnameableTestFunctions {\n+impl LintPass for UnnameableTestItems {\n     fn get_lints(&self) -> LintArray {\n-        lint_array!(UNNAMEABLE_TEST_FUNCTIONS)\n+        lint_array!(UNNAMEABLE_TEST_ITEMS)\n     }\n }\n \n-impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnnameableTestFunctions {\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnnameableTestItems {\n     fn check_item(&mut self, cx: &LateContext, it: &hir::Item) {\n-        match it.node {\n-            hir::ItemKind::Fn(..) => {\n-                for attr in &it.attrs {\n-                    if attr.name() == \"test\" {\n-                        let parent = cx.tcx.hir.get_parent(it.id);\n-                        match cx.tcx.hir.find(parent) {\n-                            Some(Node::Item(hir::Item {node: hir::ItemKind::Mod(_), ..})) |\n-                            None => {}\n-                            _ => {\n-                                cx.struct_span_lint(\n-                                    UNNAMEABLE_TEST_FUNCTIONS,\n-                                    attr.span,\n-                                    \"cannot test inner function\",\n-                                ).emit();\n-                            }\n-                        }\n-                        break;\n-                    }\n-                }\n+        if self.items_nameable {\n+            if let hir::ItemKind::Mod(..) = it.node {}\n+            else {\n+                self.items_nameable = false;\n+                self.boundary = it.id;\n             }\n-            _ => return,\n-        };\n+            return;\n+        }\n+\n+        if let Some(attr) = attr::find_by_name(&it.attrs, \"rustc_test_marker\") {\n+            cx.struct_span_lint(\n+                UNNAMEABLE_TEST_ITEMS,\n+                attr.span,\n+                \"cannot test inner items\",\n+            ).emit();\n+        }\n+    }\n+\n+    fn check_item_post(&mut self, _cx: &LateContext, it: &hir::Item) {\n+        if !self.items_nameable && self.boundary == it.id {\n+            self.items_nameable = true;\n+        }\n     }\n }\n "}, {"sha": "2c32cbdd00f363019a5be05af46a20405fcf79cd", "filename": "src/librustc_lint/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3dab33225a8c74dcf1f6a4f6161a10b60d5944e9/src%2Flibrustc_lint%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dab33225a8c74dcf1f6a4f6161a10b60d5944e9/src%2Flibrustc_lint%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Flib.rs?ref=3dab33225a8c74dcf1f6a4f6161a10b60d5944e9", "patch": "@@ -149,7 +149,7 @@ pub fn register_builtins(store: &mut lint::LintStore, sess: Option<&Session>) {\n         MutableTransmutes: MutableTransmutes,\n         UnionsWithDropFields: UnionsWithDropFields,\n         UnreachablePub: UnreachablePub,\n-        UnnameableTestFunctions: UnnameableTestFunctions,\n+        UnnameableTestItems: UnnameableTestItems::new(),\n         TypeAliasBounds: TypeAliasBounds,\n         UnusedBrokenConst: UnusedBrokenConst,\n         TrivialConstraints: TrivialConstraints,"}, {"sha": "65fe01ff96aa561f2c6e2e101764aa25552090f1", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3dab33225a8c74dcf1f6a4f6161a10b60d5944e9/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dab33225a8c74dcf1f6a4f6161a10b60d5944e9/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=3dab33225a8c74dcf1f6a4f6161a10b60d5944e9", "patch": "@@ -1412,6 +1412,7 @@ pub struct Resolver<'a, 'b: 'a> {\n     crate_loader: &'a mut CrateLoader<'b>,\n     macro_names: FxHashSet<Ident>,\n     macro_prelude: FxHashMap<Name, &'a NameBinding<'a>>,\n+    unshadowable_attrs: FxHashMap<Name, &'a NameBinding<'a>>,\n     pub all_macros: FxHashMap<Name, Def>,\n     macro_map: FxHashMap<DefId, Lrc<SyntaxExtension>>,\n     macro_defs: FxHashMap<Mark, DefId>,\n@@ -1729,6 +1730,7 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n             crate_loader,\n             macro_names: FxHashSet(),\n             macro_prelude: FxHashMap(),\n+            unshadowable_attrs: FxHashMap(),\n             all_macros: FxHashMap(),\n             macro_map: FxHashMap(),\n             invocations,"}, {"sha": "f403e09b7f768c54d812fd1bccac338d5b9e4fb6", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/3dab33225a8c74dcf1f6a4f6161a10b60d5944e9/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dab33225a8c74dcf1f6a4f6161a10b60d5944e9/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=3dab33225a8c74dcf1f6a4f6161a10b60d5944e9", "patch": "@@ -207,6 +207,23 @@ impl<'a, 'crateloader: 'a> base::Resolver for Resolver<'a, 'crateloader> {\n         self.macro_prelude.insert(ident.name, binding);\n     }\n \n+    fn add_unshadowable_attr(&mut self, ident: ast::Ident, ext: Lrc<SyntaxExtension>) {\n+        let def_id = DefId {\n+            krate: BUILTIN_MACROS_CRATE,\n+            index: DefIndex::from_array_index(self.macro_map.len(),\n+                                              DefIndexAddressSpace::Low),\n+        };\n+        let kind = ext.kind();\n+        self.macro_map.insert(def_id, ext);\n+        let binding = self.arenas.alloc_name_binding(NameBinding {\n+            kind: NameBindingKind::Def(Def::Macro(def_id, kind), false),\n+            span: DUMMY_SP,\n+            vis: ty::Visibility::Invisible,\n+            expansion: Mark::root(),\n+        });\n+        self.unshadowable_attrs.insert(ident.name, binding);\n+    }\n+\n     fn resolve_imports(&mut self) {\n         ImportResolver { resolver: self }.resolve_imports()\n     }\n@@ -462,6 +479,12 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n             return def;\n         }\n \n+        if kind == MacroKind::Attr {\n+            if let Some(ext) = self.unshadowable_attrs.get(&path[0].name) {\n+                return Ok(ext.def());\n+            }\n+        }\n+\n         let legacy_resolution = self.resolve_legacy_scope(&invocation.legacy_scope, path[0], false);\n         let result = if let Some((legacy_binding, _)) = legacy_resolution {\n             Ok(legacy_binding.def())"}, {"sha": "c0455ceb8390ce669802e9bc9650153882e9ef08", "filename": "src/librustc_target/spec/wasm32_unknown_unknown.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3dab33225a8c74dcf1f6a4f6161a10b60d5944e9/src%2Flibrustc_target%2Fspec%2Fwasm32_unknown_unknown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dab33225a8c74dcf1f6a4f6161a10b60d5944e9/src%2Flibrustc_target%2Fspec%2Fwasm32_unknown_unknown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fwasm32_unknown_unknown.rs?ref=3dab33225a8c74dcf1f6a4f6161a10b60d5944e9", "patch": "@@ -36,8 +36,7 @@ pub fn target() -> Result<Target, String> {\n         dll_suffix: \".wasm\".to_string(),\n         linker_is_gnu: false,\n \n-        // A bit of a lie, but \"eh\"\n-        max_atomic_width: Some(32),\n+        max_atomic_width: Some(64),\n \n         // Unwinding doesn't work right now, so the whole target unconditionally\n         // defaults to panic=abort. Note that this is guaranteed to change in"}, {"sha": "9851749be3765ff0ba8f7e6ba0ef1b9a7b220472", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3dab33225a8c74dcf1f6a4f6161a10b60d5944e9/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dab33225a8c74dcf1f6a4f6161a10b60d5944e9/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=3dab33225a8c74dcf1f6a4f6161a10b60d5944e9", "patch": "@@ -1587,7 +1587,7 @@ impl TyKind {\n         if let TyKind::ImplicitSelf = *self { true } else { false }\n     }\n \n-    crate fn is_unit(&self) -> bool {\n+    pub fn is_unit(&self) -> bool {\n         if let TyKind::Tup(ref tys) = *self { tys.is_empty() } else { false }\n     }\n }"}, {"sha": "5233267e3a95af043a0fb1165b3b5e3762f5fac8", "filename": "src/libsyntax/config.rs", "status": "modified", "additions": 2, "deletions": 13, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/3dab33225a8c74dcf1f6a4f6161a10b60d5944e9/src%2Flibsyntax%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dab33225a8c74dcf1f6a4f6161a10b60d5944e9/src%2Flibsyntax%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fconfig.rs?ref=3dab33225a8c74dcf1f6a4f6161a10b60d5944e9", "patch": "@@ -21,18 +21,16 @@ use ptr::P;\n \n /// A folder that strips out items that do not belong in the current configuration.\n pub struct StripUnconfigured<'a> {\n-    pub should_test: bool,\n     pub sess: &'a ParseSess,\n     pub features: Option<&'a Features>,\n }\n \n // `cfg_attr`-process the crate's attributes and compute the crate's features.\n-pub fn features(mut krate: ast::Crate, sess: &ParseSess, should_test: bool, edition: Edition)\n+pub fn features(mut krate: ast::Crate, sess: &ParseSess, edition: Edition)\n                 -> (ast::Crate, Features) {\n     let features;\n     {\n         let mut strip_unconfigured = StripUnconfigured {\n-            should_test,\n             sess,\n             features: None,\n         };\n@@ -118,11 +116,6 @@ impl<'a> StripUnconfigured<'a> {\n     // Determine if a node with the given attributes should be included in this configuration.\n     pub fn in_cfg(&mut self, attrs: &[ast::Attribute]) -> bool {\n         attrs.iter().all(|attr| {\n-            // When not compiling with --test we should not compile the #[test] functions\n-            if !self.should_test && is_test_or_bench(attr) {\n-                return false;\n-            }\n-\n             let mis = if !is_cfg(attr) {\n                 return true;\n             } else if let Some(mis) = attr.meta_item_list() {\n@@ -249,7 +242,7 @@ impl<'a> StripUnconfigured<'a> {\n         //\n         // NB: This is intentionally not part of the fold_expr() function\n         //     in order for fold_opt_expr() to be able to avoid this check\n-        if let Some(attr) = expr.attrs().iter().find(|a| is_cfg(a) || is_test_or_bench(a)) {\n+        if let Some(attr) = expr.attrs().iter().find(|a| is_cfg(a)) {\n             let msg = \"removing an expression is not supported in this position\";\n             self.sess.span_diagnostic.span_err(attr.span, msg);\n         }\n@@ -352,7 +345,3 @@ impl<'a> fold::Folder for StripUnconfigured<'a> {\n fn is_cfg(attr: &ast::Attribute) -> bool {\n     attr.check_name(\"cfg\")\n }\n-\n-pub fn is_test_or_bench(attr: &ast::Attribute) -> bool {\n-    attr.check_name(\"test\") || attr.check_name(\"bench\")\n-}"}, {"sha": "0e059bc4a6ce5a7d29395d5fd7398cf259758350", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3dab33225a8c74dcf1f6a4f6161a10b60d5944e9/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dab33225a8c74dcf1f6a4f6161a10b60d5944e9/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=3dab33225a8c74dcf1f6a4f6161a10b60d5944e9", "patch": "@@ -721,6 +721,7 @@ pub trait Resolver {\n     fn visit_ast_fragment_with_placeholders(&mut self, mark: Mark, fragment: &AstFragment,\n                                             derives: &[Mark]);\n     fn add_builtin(&mut self, ident: ast::Ident, ext: Lrc<SyntaxExtension>);\n+    fn add_unshadowable_attr(&mut self, ident: ast::Ident, ext: Lrc<SyntaxExtension>);\n \n     fn resolve_imports(&mut self);\n     // Resolves attribute and derive legacy macros from `#![plugin(..)]`.\n@@ -729,6 +730,7 @@ pub trait Resolver {\n \n     fn resolve_macro_invocation(&mut self, invoc: &Invocation, scope: Mark, force: bool)\n                                 -> Result<Option<Lrc<SyntaxExtension>>, Determinacy>;\n+\n     fn resolve_macro_path(&mut self, path: &ast::Path, kind: MacroKind, scope: Mark,\n                           derives_in_scope: &[ast::Path], force: bool)\n                           -> Result<Lrc<SyntaxExtension>, Determinacy>;\n@@ -759,6 +761,7 @@ impl Resolver for DummyResolver {\n     fn visit_ast_fragment_with_placeholders(&mut self, _invoc: Mark, _fragment: &AstFragment,\n                                             _derives: &[Mark]) {}\n     fn add_builtin(&mut self, _ident: ast::Ident, _ext: Lrc<SyntaxExtension>) {}\n+    fn add_unshadowable_attr(&mut self, _ident: ast::Ident, _ext: Lrc<SyntaxExtension>) {}\n \n     fn resolve_imports(&mut self) {}\n     fn find_legacy_attr_invoc(&mut self, _attrs: &mut Vec<Attribute>, _allow_derive: bool)"}, {"sha": "3bb19121ee308ad337851cbf2c057e8e9b96a406", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 6, "deletions": 74, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/3dab33225a8c74dcf1f6a4f6161a10b60d5944e9/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dab33225a8c74dcf1f6a4f6161a10b60d5944e9/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=3dab33225a8c74dcf1f6a4f6161a10b60d5944e9", "patch": "@@ -12,10 +12,9 @@ use ast::{self, Block, Ident, NodeId, PatKind, Path};\n use ast::{MacStmtStyle, StmtKind, ItemKind};\n use attr::{self, HasAttrs};\n use source_map::{ExpnInfo, MacroBang, MacroAttribute, dummy_spanned, respan};\n-use config::{is_test_or_bench, StripUnconfigured};\n+use config::StripUnconfigured;\n use errors::{Applicability, FatalError};\n use ext::base::*;\n-use ext::build::AstBuilder;\n use ext::derive::{add_derived_markers, collect_derives};\n use ext::hygiene::{self, Mark, SyntaxContext};\n use ext::placeholders::{placeholder, PlaceholderExpander};\n@@ -37,7 +36,6 @@ use visit::{self, Visitor};\n use rustc_data_structures::fx::FxHashMap;\n use std::fs::File;\n use std::io::Read;\n-use std::iter::FromIterator;\n use std::{iter, mem};\n use std::rc::Rc;\n use std::path::PathBuf;\n@@ -452,14 +450,12 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n         let (fragment_with_placeholders, invocations) = {\n             let mut collector = InvocationCollector {\n                 cfg: StripUnconfigured {\n-                    should_test: self.cx.ecfg.should_test,\n                     sess: self.cx.parse_sess,\n                     features: self.cx.ecfg.features,\n                 },\n                 cx: self.cx,\n                 invocations: Vec::new(),\n                 monotonic: self.monotonic,\n-                tests_nameable: true,\n             };\n             (fragment.fold_with(&mut collector), collector.invocations)\n         };\n@@ -477,7 +473,6 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n \n     fn fully_configure(&mut self, item: Annotatable) -> Annotatable {\n         let mut cfg = StripUnconfigured {\n-            should_test: self.cx.ecfg.should_test,\n             sess: self.cx.parse_sess,\n             features: self.cx.ecfg.features,\n         };\n@@ -1049,11 +1044,6 @@ struct InvocationCollector<'a, 'b: 'a> {\n     cfg: StripUnconfigured<'a>,\n     invocations: Vec<Invocation>,\n     monotonic: bool,\n-\n-    /// Test functions need to be nameable. Tests inside functions or in other\n-    /// unnameable locations need to be ignored. `tests_nameable` tracks whether\n-    /// any test functions found in the current context would be nameable.\n-    tests_nameable: bool,\n }\n \n impl<'a, 'b> InvocationCollector<'a, 'b> {\n@@ -1071,20 +1061,6 @@ impl<'a, 'b> InvocationCollector<'a, 'b> {\n         placeholder(fragment_kind, NodeId::placeholder_from_mark(mark))\n     }\n \n-    /// Folds the item allowing tests to be expanded because they are still nameable.\n-    /// This should probably only be called with module items\n-    fn fold_nameable(&mut self, item: P<ast::Item>) -> OneVector<P<ast::Item>> {\n-        fold::noop_fold_item(item, self)\n-    }\n-\n-    /// Folds the item but doesn't allow tests to occur within it\n-    fn fold_unnameable(&mut self, item: P<ast::Item>) -> OneVector<P<ast::Item>> {\n-        let was_nameable = mem::replace(&mut self.tests_nameable, false);\n-        let items = fold::noop_fold_item(item, self);\n-        self.tests_nameable = was_nameable;\n-        items\n-    }\n-\n     fn collect_bang(&mut self, mac: ast::Mac, span: Span, kind: AstFragmentKind) -> AstFragment {\n         self.collect(kind, InvocationKind::Bang { mac: mac, ident: None, span: span })\n     }\n@@ -1299,7 +1275,7 @@ impl<'a, 'b> Folder for InvocationCollector<'a, 'b> {\n     fn fold_item(&mut self, item: P<ast::Item>) -> OneVector<P<ast::Item>> {\n         let item = configure!(self, item);\n \n-        let (attr, traits, mut item) = self.classify_item(item);\n+        let (attr, traits, item) = self.classify_item(item);\n         if attr.is_some() || !traits.is_empty() {\n             let item = Annotatable::Item(item);\n             return self.collect_attr(attr, traits, item, AstFragmentKind::Items).make_items();\n@@ -1321,7 +1297,7 @@ impl<'a, 'b> Folder for InvocationCollector<'a, 'b> {\n             }\n             ast::ItemKind::Mod(ast::Mod { inner, .. }) => {\n                 if item.ident == keywords::Invalid.ident() {\n-                    return self.fold_nameable(item);\n+                    return noop_fold_item(item, self);\n                 }\n \n                 let orig_directory_ownership = self.cx.current_expansion.directory_ownership;\n@@ -1361,58 +1337,13 @@ impl<'a, 'b> Folder for InvocationCollector<'a, 'b> {\n \n                 let orig_module =\n                     mem::replace(&mut self.cx.current_expansion.module, Rc::new(module));\n-                let result = self.fold_nameable(item);\n+                let result = noop_fold_item(item, self);\n                 self.cx.current_expansion.module = orig_module;\n                 self.cx.current_expansion.directory_ownership = orig_directory_ownership;\n                 result\n             }\n-            // Ensure that test functions are accessible from the test harness.\n-            // #[test] fn foo() {}\n-            // becomes:\n-            // #[test] pub fn foo_gensym(){}\n-            // #[allow(unused)]\n-            // use foo_gensym as foo;\n-            ast::ItemKind::Fn(..) if self.cx.ecfg.should_test => {\n-                if self.tests_nameable && item.attrs.iter().any(|attr| is_test_or_bench(attr)) {\n-                    let orig_ident = item.ident;\n-                    let orig_vis   = item.vis.clone();\n-\n-                    // Publicize the item under gensymed name to avoid pollution\n-                    item = item.map(|mut item| {\n-                        item.vis = respan(item.vis.span, ast::VisibilityKind::Public);\n-                        item.ident = item.ident.gensym();\n-                        item\n-                    });\n-\n-                    // Use the gensymed name under the item's original visibility\n-                    let mut use_item = self.cx.item_use_simple_(\n-                        item.ident.span,\n-                        orig_vis,\n-                        Some(orig_ident),\n-                        self.cx.path(item.ident.span,\n-                            vec![keywords::SelfValue.ident(), item.ident]));\n-\n-                    // #[allow(unused)] because the test function probably isn't being referenced\n-                    use_item = use_item.map(|mut ui| {\n-                        ui.attrs.push(\n-                            self.cx.attribute(DUMMY_SP, attr::mk_list_item(DUMMY_SP,\n-                                Ident::from_str(\"allow\"), vec![\n-                                    attr::mk_nested_word_item(Ident::from_str(\"unused\"))\n-                                ]\n-                            ))\n-                        );\n-\n-                        ui\n-                    });\n \n-                    OneVector::from_iter(\n-                        self.fold_unnameable(item).into_iter()\n-                            .chain(self.fold_unnameable(use_item)))\n-                } else {\n-                    self.fold_unnameable(item)\n-                }\n-            }\n-            _ => self.fold_unnameable(item),\n+            _ => noop_fold_item(item, self),\n         }\n     }\n \n@@ -1637,6 +1568,7 @@ impl<'feat> ExpansionConfig<'feat> {\n     feature_tests! {\n         fn enable_quotes = quote,\n         fn enable_asm = asm,\n+        fn enable_custom_test_frameworks = custom_test_frameworks,\n         fn enable_global_asm = global_asm,\n         fn enable_log_syntax = log_syntax,\n         fn enable_concat_idents = concat_idents,"}, {"sha": "e3ea3563d853bb6fc6e2b9bc85f1b56fdddaf852", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 16, "deletions": 2, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/3dab33225a8c74dcf1f6a4f6161a10b60d5944e9/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dab33225a8c74dcf1f6a4f6161a10b60d5944e9/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=3dab33225a8c74dcf1f6a4f6161a10b60d5944e9", "patch": "@@ -515,6 +515,10 @@ declare_features! (\n \n     // unsized rvalues at arguments and parameters\n     (active, unsized_locals, \"1.30.0\", Some(48055), None),\n+\n+    // #![test_runner]\n+    // #[test_case]\n+    (active, custom_test_frameworks, \"1.30.0\", Some(50297), None),\n );\n \n declare_features! (\n@@ -765,8 +769,6 @@ pub const BUILTIN_ATTRIBUTES: &'static [(&'static str, AttributeType, AttributeG\n     (\"cfg_attr\", Normal, Ungated),\n     (\"main\", Normal, Ungated),\n     (\"start\", Normal, Ungated),\n-    (\"test\", Normal, Ungated),\n-    (\"bench\", Normal, Ungated),\n     (\"repr\", Normal, Ungated),\n     (\"path\", Normal, Ungated),\n     (\"abi\", Normal, Ungated),\n@@ -959,6 +961,11 @@ pub const BUILTIN_ATTRIBUTES: &'static [(&'static str, AttributeType, AttributeG\n                                                       attribute is just used for rustc unit \\\n                                                       tests and will never be stable\",\n                                                      cfg_fn!(rustc_attrs))),\n+    (\"rustc_test_marker\", Normal, Gated(Stability::Unstable,\n+                                     \"rustc_attrs\",\n+                                     \"the `#[rustc_test_marker]` attribute \\\n+                                      is used internally to track tests\",\n+                                     cfg_fn!(rustc_attrs))),\n \n     // RFC #2094\n     (\"nll\", Whitelisted, Gated(Stability::Unstable,\n@@ -1156,6 +1163,10 @@ pub const BUILTIN_ATTRIBUTES: &'static [(&'static str, AttributeType, AttributeG\n     (\"no_builtins\", CrateLevel, Ungated),\n     (\"recursion_limit\", CrateLevel, Ungated),\n     (\"type_length_limit\", CrateLevel, Ungated),\n+    (\"test_runner\", CrateLevel, Gated(Stability::Unstable,\n+                    \"custom_test_frameworks\",\n+                    EXPLAIN_CUSTOM_TEST_FRAMEWORKS,\n+                    cfg_fn!(custom_test_frameworks))),\n ];\n \n // cfg(...)'s that are feature gated\n@@ -1372,6 +1383,9 @@ pub const EXPLAIN_ASM: &'static str =\n pub const EXPLAIN_GLOBAL_ASM: &'static str =\n     \"`global_asm!` is not stable enough for use and is subject to change\";\n \n+pub const EXPLAIN_CUSTOM_TEST_FRAMEWORKS: &'static str =\n+    \"custom test frameworks are an unstable feature\";\n+\n pub const EXPLAIN_LOG_SYNTAX: &'static str =\n     \"`log_syntax!` is not stable enough for use and is subject to change\";\n "}, {"sha": "5f80af77f494046f0353f2470f39d826edf2cf7d", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3dab33225a8c74dcf1f6a4f6161a10b60d5944e9/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dab33225a8c74dcf1f6a4f6161a10b60d5944e9/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=3dab33225a8c74dcf1f6a4f6161a10b60d5944e9", "patch": "@@ -6272,7 +6272,6 @@ impl<'a> Parser<'a> {\n         let (in_cfg, outer_attrs) = {\n             let mut strip_unconfigured = ::config::StripUnconfigured {\n                 sess: self.sess,\n-                should_test: false, // irrelevant\n                 features: None, // don't perform gated feature checking\n             };\n             let outer_attrs = strip_unconfigured.process_cfg_attrs(outer_attrs.to_owned());"}, {"sha": "ab67736c389c0164f20c1093dac4a73995ffb9dc", "filename": "src/libsyntax/test.rs", "status": "modified", "additions": 104, "deletions": 476, "changes": 580, "blob_url": "https://github.com/rust-lang/rust/blob/3dab33225a8c74dcf1f6a4f6161a10b60d5944e9/src%2Flibsyntax%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dab33225a8c74dcf1f6a4f6161a10b60d5944e9/src%2Flibsyntax%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftest.rs?ref=3dab33225a8c74dcf1f6a4f6161a10b60d5944e9", "patch": "@@ -22,7 +22,7 @@ use std::vec;\n use attr::{self, HasAttrs};\n use syntax_pos::{self, DUMMY_SP, NO_EXPANSION, Span, SourceFile, BytePos};\n \n-use source_map::{self, SourceMap, ExpnInfo, MacroAttribute, dummy_spanned};\n+use source_map::{self, SourceMap, ExpnInfo, MacroAttribute, dummy_spanned, respan};\n use errors;\n use config;\n use entry::{self, EntryPointType};\n@@ -43,29 +43,21 @@ use symbol::{self, Symbol, keywords};\n use ThinVec;\n use rustc_data_structures::small_vec::ExpectOne;\n \n-enum ShouldPanic {\n-    No,\n-    Yes(Option<Symbol>),\n-}\n-\n struct Test {\n     span: Span,\n-    path: Vec<Ident> ,\n-    bench: bool,\n-    ignore: bool,\n-    should_panic: ShouldPanic,\n-    allow_fail: bool,\n+    path: Vec<Ident>,\n }\n \n struct TestCtxt<'a> {\n     span_diagnostic: &'a errors::Handler,\n     path: Vec<Ident>,\n     ext_cx: ExtCtxt<'a>,\n-    testfns: Vec<Test>,\n+    test_cases: Vec<Test>,\n     reexport_test_harness_main: Option<Symbol>,\n     is_libtest: bool,\n     ctxt: SyntaxContext,\n     features: &'a Features,\n+    test_runner: Option<ast::Path>,\n \n     // top-level re-export submodule, filled out after folding is finished\n     toplevel_reexport: Option<Ident>,\n@@ -87,9 +79,13 @@ pub fn modify_for_testing(sess: &ParseSess,\n         attr::first_attr_value_str_by_name(&krate.attrs,\n                                            \"reexport_test_harness_main\");\n \n+    // Do this here so that the test_runner crate attribute gets marked as used\n+    // even in non-test builds\n+    let test_runner = get_test_runner(span_diagnostic, &krate);\n+\n     if should_test {\n         generate_test_harness(sess, resolver, reexport_test_harness_main,\n-                              krate, span_diagnostic, features)\n+                              krate, span_diagnostic, features, test_runner)\n     } else {\n         krate\n     }\n@@ -107,13 +103,13 @@ impl<'a> fold::Folder for TestHarnessGenerator<'a> {\n     fn fold_crate(&mut self, c: ast::Crate) -> ast::Crate {\n         let mut folded = fold::noop_fold_crate(c, self);\n \n-        // Add a special __test module to the crate that will contain code\n-        // generated for the test harness\n-        let (mod_, reexport) = mk_test_module(&mut self.cx);\n-        if let Some(re) = reexport {\n-            folded.module.items.push(re)\n-        }\n-        folded.module.items.push(mod_);\n+        // Create a main function to run our tests\n+        let test_main = {\n+            let unresolved = mk_main(&mut self.cx);\n+            self.cx.ext_cx.monotonic_expander().fold_item(unresolved).pop().unwrap()\n+        };\n+\n+        folded.module.items.push(test_main);\n         folded\n     }\n \n@@ -124,41 +120,18 @@ impl<'a> fold::Folder for TestHarnessGenerator<'a> {\n         }\n         debug!(\"current path: {}\", path_name_i(&self.cx.path));\n \n-        if is_test_fn(&self.cx, &i) || is_bench_fn(&self.cx, &i) {\n-            match i.node {\n-                ast::ItemKind::Fn(_, header, _, _) => {\n-                    if header.unsafety == ast::Unsafety::Unsafe {\n-                        let diag = self.cx.span_diagnostic;\n-                        diag.span_fatal(\n-                            i.span,\n-                            \"unsafe functions cannot be used for tests\"\n-                        ).raise();\n-                    }\n-                    if header.asyncness.is_async() {\n-                        let diag = self.cx.span_diagnostic;\n-                        diag.span_fatal(\n-                            i.span,\n-                            \"async functions cannot be used for tests\"\n-                        ).raise();\n-                    }\n-                }\n-                _ => {},\n-            }\n+        let mut item = i.into_inner();\n+        if is_test_case(&item) {\n+            debug!(\"this is a test item\");\n \n-            debug!(\"this is a test function\");\n             let test = Test {\n-                span: i.span,\n+                span: item.span,\n                 path: self.cx.path.clone(),\n-                bench: is_bench_fn(&self.cx, &i),\n-                ignore: is_ignored(&i),\n-                should_panic: should_panic(&i, &self.cx),\n-                allow_fail: is_allowed_fail(&i),\n             };\n-            self.cx.testfns.push(test);\n-            self.tests.push(i.ident);\n+            self.cx.test_cases.push(test);\n+            self.tests.push(item.ident);\n         }\n \n-        let mut item = i.into_inner();\n         // We don't want to recurse into anything other than mods, since\n         // mods or tests inside of functions will break things\n         if let ast::ItemKind::Mod(module) = item.node {\n@@ -190,6 +163,8 @@ impl<'a> fold::Folder for TestHarnessGenerator<'a> {\n     fn fold_mac(&mut self, mac: ast::Mac) -> ast::Mac { mac }\n }\n \n+/// A folder used to remove any entry points (like fn main) because the harness\n+/// generator will provide its own\n struct EntryPointCleaner {\n     // Current depth in the ast\n     depth: usize,\n@@ -242,6 +217,10 @@ impl fold::Folder for EntryPointCleaner {\n     fn fold_mac(&mut self, mac: ast::Mac) -> ast::Mac { mac }\n }\n \n+/// Creates an item (specifically a module) that \"pub use\"s the tests passed in.\n+/// Each tested submodule will contain a similar reexport module that we will export\n+/// under the name of the original module. That is, `submod::__test_reexports` is\n+/// reexported like so `pub use submod::__test_reexports as submod`.\n fn mk_reexport_mod(cx: &mut TestCtxt,\n                    parent: ast::NodeId,\n                    tests: Vec<Ident>,\n@@ -279,12 +258,14 @@ fn mk_reexport_mod(cx: &mut TestCtxt,\n     (it, sym)\n }\n \n+/// Crawl over the crate, inserting test reexports and the test main function\n fn generate_test_harness(sess: &ParseSess,\n                          resolver: &mut dyn Resolver,\n                          reexport_test_harness_main: Option<Symbol>,\n                          krate: ast::Crate,\n                          sd: &errors::Handler,\n-                         features: &Features) -> ast::Crate {\n+                         features: &Features,\n+                         test_runner: Option<ast::Path>) -> ast::Crate {\n     // Remove the entry points\n     let mut cleaner = EntryPointCleaner { depth: 0 };\n     let krate = cleaner.fold_crate(krate);\n@@ -298,19 +279,20 @@ fn generate_test_harness(sess: &ParseSess,\n         span_diagnostic: sd,\n         ext_cx: ExtCtxt::new(sess, econfig, resolver),\n         path: Vec::new(),\n-        testfns: Vec::new(),\n+        test_cases: Vec::new(),\n         reexport_test_harness_main,\n         // NB: doesn't consider the value of `--crate-name` passed on the command line.\n         is_libtest: attr::find_crate_name(&krate.attrs).map(|s| s == \"test\").unwrap_or(false),\n         toplevel_reexport: None,\n         ctxt: SyntaxContext::empty().apply_mark(mark),\n         features,\n+        test_runner\n     };\n \n     mark.set_expn_info(ExpnInfo {\n         call_site: DUMMY_SP,\n         def_site: None,\n-        format: MacroAttribute(Symbol::intern(\"test\")),\n+        format: MacroAttribute(Symbol::intern(\"test_case\")),\n         allow_internal_unstable: true,\n         allow_internal_unsafe: false,\n         local_inner_macros: false,\n@@ -344,288 +326,72 @@ enum BadTestSignature {\n     ShouldPanicOnlyWithNoArgs,\n }\n \n-fn is_test_fn(cx: &TestCtxt, i: &ast::Item) -> bool {\n-    let has_test_attr = attr::contains_name(&i.attrs, \"test\");\n-\n-    fn has_test_signature(_cx: &TestCtxt, i: &ast::Item) -> HasTestSignature {\n-        let has_should_panic_attr = attr::contains_name(&i.attrs, \"should_panic\");\n-        match i.node {\n-            ast::ItemKind::Fn(ref decl, _, ref generics, _) => {\n-                // If the termination trait is active, the compiler will check that the output\n-                // type implements the `Termination` trait as `libtest` enforces that.\n-                let has_output = match decl.output {\n-                    ast::FunctionRetTy::Default(..) => false,\n-                    ast::FunctionRetTy::Ty(ref t) if t.node.is_unit() => false,\n-                    _ => true\n-                };\n-\n-                if !decl.inputs.is_empty() {\n-                    return No(BadTestSignature::NoArgumentsAllowed);\n-                }\n-\n-                match (has_output, has_should_panic_attr) {\n-                    (true, true) => No(BadTestSignature::ShouldPanicOnlyWithNoArgs),\n-                    (true, false) => if !generics.params.is_empty() {\n-                        No(BadTestSignature::WrongTypeSignature)\n-                    } else {\n-                        Yes\n-                    },\n-                    (false, _) => Yes\n-                }\n-            }\n-            _ => No(BadTestSignature::NotEvenAFunction),\n-        }\n-    }\n-\n-    let has_test_signature = if has_test_attr {\n-        let diag = cx.span_diagnostic;\n-        match has_test_signature(cx, i) {\n-            Yes => true,\n-            No(cause) => {\n-                match cause {\n-                    BadTestSignature::NotEvenAFunction =>\n-                        diag.span_err(i.span, \"only functions may be used as tests\"),\n-                    BadTestSignature::WrongTypeSignature =>\n-                        diag.span_err(i.span,\n-                                      \"functions used as tests must have signature fn() -> ()\"),\n-                    BadTestSignature::NoArgumentsAllowed =>\n-                        diag.span_err(i.span, \"functions used as tests can not have any arguments\"),\n-                    BadTestSignature::ShouldPanicOnlyWithNoArgs =>\n-                        diag.span_err(i.span, \"functions using `#[should_panic]` must return `()`\"),\n-                }\n-                false\n-            }\n-        }\n-    } else {\n-        false\n-    };\n-\n-    has_test_attr && has_test_signature\n-}\n-\n-fn is_bench_fn(cx: &TestCtxt, i: &ast::Item) -> bool {\n-    let has_bench_attr = attr::contains_name(&i.attrs, \"bench\");\n-\n-    fn has_bench_signature(_cx: &TestCtxt, i: &ast::Item) -> bool {\n-        match i.node {\n-            ast::ItemKind::Fn(ref decl, _, _, _) => {\n-                // NB: inadequate check, but we're running\n-                // well before resolve, can't get too deep.\n-                decl.inputs.len() == 1\n-            }\n-            _ => false\n-        }\n-    }\n-\n-    let has_bench_signature = has_bench_signature(cx, i);\n-\n-    if has_bench_attr && !has_bench_signature {\n-        let diag = cx.span_diagnostic;\n-\n-        diag.span_err(i.span, \"functions used as benches must have signature \\\n-                                   `fn(&mut Bencher) -> impl Termination`\");\n-    }\n-\n-    has_bench_attr && has_bench_signature\n-}\n-\n-fn is_ignored(i: &ast::Item) -> bool {\n-    attr::contains_name(&i.attrs, \"ignore\")\n-}\n-\n-fn is_allowed_fail(i: &ast::Item) -> bool {\n-    attr::contains_name(&i.attrs, \"allow_fail\")\n-}\n-\n-fn should_panic(i: &ast::Item, cx: &TestCtxt) -> ShouldPanic {\n-    match attr::find_by_name(&i.attrs, \"should_panic\") {\n-        Some(attr) => {\n-            let sd = cx.span_diagnostic;\n-            if attr.is_value_str() {\n-                sd.struct_span_warn(\n-                    attr.span(),\n-                    \"attribute must be of the form: \\\n-                     `#[should_panic]` or \\\n-                     `#[should_panic(expected = \\\"error message\\\")]`\"\n-                ).note(\"Errors in this attribute were erroneously allowed \\\n-                        and will become a hard error in a future release.\")\n-                .emit();\n-                return ShouldPanic::Yes(None);\n-            }\n-            match attr.meta_item_list() {\n-                // Handle #[should_panic]\n-                None => ShouldPanic::Yes(None),\n-                // Handle #[should_panic(expected = \"foo\")]\n-                Some(list) => {\n-                    let msg = list.iter()\n-                        .find(|mi| mi.check_name(\"expected\"))\n-                        .and_then(|mi| mi.meta_item())\n-                        .and_then(|mi| mi.value_str());\n-                    if list.len() != 1 || msg.is_none() {\n-                        sd.struct_span_warn(\n-                            attr.span(),\n-                            \"argument must be of the form: \\\n-                             `expected = \\\"error message\\\"`\"\n-                        ).note(\"Errors in this attribute were erroneously \\\n-                                allowed and will become a hard error in a \\\n-                                future release.\").emit();\n-                        ShouldPanic::Yes(None)\n-                    } else {\n-                        ShouldPanic::Yes(msg)\n-                    }\n-                },\n-            }\n-        }\n-        None => ShouldPanic::No,\n-    }\n-}\n-\n-/*\n-\n-We're going to be building a module that looks more or less like:\n-\n-mod __test {\n-  extern crate test (name = \"test\", vers = \"...\");\n-  fn main() {\n-    test::test_main_static(&::os::args()[], tests, test::Options::new())\n-  }\n-\n-  static tests : &'static [test::TestDescAndFn] = &[\n-    ... the list of tests in the crate ...\n-  ];\n-}\n-\n-*/\n-\n-fn mk_std(cx: &TestCtxt) -> P<ast::Item> {\n-    let id_test = Ident::from_str(\"test\");\n-    let sp = ignored_span(cx, DUMMY_SP);\n-    let (vi, vis, ident) = if cx.is_libtest {\n-        (ast::ItemKind::Use(P(ast::UseTree {\n-            span: DUMMY_SP,\n-            prefix: path_node(vec![id_test]),\n-            kind: ast::UseTreeKind::Simple(None, ast::DUMMY_NODE_ID, ast::DUMMY_NODE_ID),\n-        })),\n-         ast::VisibilityKind::Public, keywords::Invalid.ident())\n-    } else {\n-        (ast::ItemKind::ExternCrate(None), ast::VisibilityKind::Inherited, id_test)\n-    };\n-    P(ast::Item {\n-        id: ast::DUMMY_NODE_ID,\n-        ident,\n-        node: vi,\n-        attrs: vec![],\n-        vis: dummy_spanned(vis),\n-        span: sp,\n-        tokens: None,\n-    })\n-}\n-\n+/// Creates a function item for use as the main function of a test build.\n+/// This function will call the `test_runner` as specified by the crate attribute\n fn mk_main(cx: &mut TestCtxt) -> P<ast::Item> {\n     // Writing this out by hand with 'ignored_span':\n     //        pub fn main() {\n     //            #![main]\n-    //            use std::slice::AsSlice;\n-    //            test::test_main_static(::std::os::args().as_slice(), TESTS, test::Options::new());\n+    //            test::test_main_static(::std::os::args().as_slice(), &[..tests]);\n     //        }\n-\n     let sp = ignored_span(cx, DUMMY_SP);\n     let ecx = &cx.ext_cx;\n-\n-    // test::test_main_static\n-    let test_main_path =\n-        ecx.path(sp, vec![Ident::from_str(\"test\"), Ident::from_str(\"test_main_static\")]);\n+    let test_id = ecx.ident_of(\"test\").gensym();\n \n     // test::test_main_static(...)\n-    let test_main_path_expr = ecx.expr_path(test_main_path);\n-    let tests_ident_expr = ecx.expr_ident(sp, Ident::from_str(\"TESTS\"));\n+    let mut test_runner = cx.test_runner.clone().unwrap_or(\n+        ecx.path(sp, vec![\n+            test_id, ecx.ident_of(\"test_main_static\")\n+        ]));\n+\n+    test_runner.span = sp;\n+\n+    let test_main_path_expr = ecx.expr_path(test_runner.clone());\n     let call_test_main = ecx.expr_call(sp, test_main_path_expr,\n-                                       vec![tests_ident_expr]);\n+                                       vec![mk_tests_slice(cx)]);\n     let call_test_main = ecx.stmt_expr(call_test_main);\n+\n     // #![main]\n     let main_meta = ecx.meta_word(sp, Symbol::intern(\"main\"));\n     let main_attr = ecx.attribute(sp, main_meta);\n+\n+    // extern crate test as test_gensym\n+    let test_extern_stmt = ecx.stmt_item(sp, ecx.item(sp,\n+        test_id,\n+        vec![],\n+        ast::ItemKind::ExternCrate(Some(Symbol::intern(\"test\")))\n+    ));\n+\n     // pub fn main() { ... }\n     let main_ret_ty = ecx.ty(sp, ast::TyKind::Tup(vec![]));\n-    let main_body = ecx.block(sp, vec![call_test_main]);\n+\n+    // If no test runner is provided we need to import the test crate\n+    let main_body = if cx.test_runner.is_none() {\n+        ecx.block(sp, vec![test_extern_stmt, call_test_main])\n+    } else {\n+        ecx.block(sp, vec![call_test_main])\n+    };\n+\n     let main = ast::ItemKind::Fn(ecx.fn_decl(vec![], ast::FunctionRetTy::Ty(main_ret_ty)),\n                            ast::FnHeader::default(),\n                            ast::Generics::default(),\n                            main_body);\n+\n+    // Honor the reexport_test_harness_main attribute\n+    let main_id = Ident::new(\n+        cx.reexport_test_harness_main.unwrap_or(Symbol::gensym(\"main\")),\n+        sp);\n+\n     P(ast::Item {\n-        ident: Ident::from_str(\"main\"),\n+        ident: main_id,\n         attrs: vec![main_attr],\n         id: ast::DUMMY_NODE_ID,\n         node: main,\n         vis: dummy_spanned(ast::VisibilityKind::Public),\n         span: sp,\n         tokens: None,\n     })\n-}\n-\n-fn mk_test_module(cx: &mut TestCtxt) -> (P<ast::Item>, Option<P<ast::Item>>) {\n-    // Link to test crate\n-    let import = mk_std(cx);\n-\n-    // A constant vector of test descriptors.\n-    let tests = mk_tests(cx);\n-\n-    // The synthesized main function which will call the console test runner\n-    // with our list of tests\n-    let mainfn = mk_main(cx);\n \n-    let testmod = ast::Mod {\n-        inner: DUMMY_SP,\n-        items: vec![import, mainfn, tests],\n-    };\n-    let item_ = ast::ItemKind::Mod(testmod);\n-    let mod_ident = Ident::with_empty_ctxt(Symbol::gensym(\"__test\"));\n-\n-    let mut expander = cx.ext_cx.monotonic_expander();\n-    let item = expander.fold_item(P(ast::Item {\n-        id: ast::DUMMY_NODE_ID,\n-        ident: mod_ident,\n-        attrs: vec![],\n-        node: item_,\n-        vis: dummy_spanned(ast::VisibilityKind::Public),\n-        span: DUMMY_SP,\n-        tokens: None,\n-    })).pop().unwrap();\n-    let reexport = cx.reexport_test_harness_main.map(|s| {\n-        // building `use __test::main as <ident>;`\n-        let rename = Ident::with_empty_ctxt(s);\n-\n-        let use_path = ast::UseTree {\n-            span: DUMMY_SP,\n-            prefix: path_node(vec![mod_ident, Ident::from_str(\"main\")]),\n-            kind: ast::UseTreeKind::Simple(Some(rename), ast::DUMMY_NODE_ID, ast::DUMMY_NODE_ID),\n-        };\n-\n-        expander.fold_item(P(ast::Item {\n-            id: ast::DUMMY_NODE_ID,\n-            ident: keywords::Invalid.ident(),\n-            attrs: vec![],\n-            node: ast::ItemKind::Use(P(use_path)),\n-            vis: dummy_spanned(ast::VisibilityKind::Inherited),\n-            span: DUMMY_SP,\n-            tokens: None,\n-        })).pop().unwrap()\n-    });\n-\n-    debug!(\"Synthetic test module:\\n{}\\n\", pprust::item_to_string(&item));\n-\n-    (item, reexport)\n-}\n-\n-fn nospan<T>(t: T) -> source_map::Spanned<T> {\n-    source_map::Spanned { node: t, span: DUMMY_SP }\n-}\n-\n-fn path_node(ids: Vec<Ident>) -> ast::Path {\n-    ast::Path {\n-        span: DUMMY_SP,\n-        segments: ids.into_iter().map(|id| ast::PathSegment::from_ident(id)).collect(),\n-    }\n }\n \n fn path_name_i(idents: &[Ident]) -> String {\n@@ -640,184 +406,46 @@ fn path_name_i(idents: &[Ident]) -> String {\n     path_name\n }\n \n-fn mk_tests(cx: &TestCtxt) -> P<ast::Item> {\n-    // The vector of test_descs for this crate\n-    let test_descs = mk_test_descs(cx);\n-\n-    // FIXME #15962: should be using quote_item, but that stringifies\n-    // __test_reexports, causing it to be reinterned, losing the\n-    // gensym information.\n-    let sp = ignored_span(cx, DUMMY_SP);\n-    let ecx = &cx.ext_cx;\n-    let struct_type = ecx.ty_path(ecx.path(sp, vec![ecx.ident_of(\"self\"),\n-                                                    ecx.ident_of(\"test\"),\n-                                                    ecx.ident_of(\"TestDescAndFn\")]));\n-    let static_lt = ecx.lifetime(sp, keywords::StaticLifetime.ident());\n-    // &'static [self::test::TestDescAndFn]\n-    let static_type = ecx.ty_rptr(sp,\n-                                  ecx.ty(sp, ast::TyKind::Slice(struct_type)),\n-                                  Some(static_lt),\n-                                  ast::Mutability::Immutable);\n-    // static TESTS: $static_type = &[...];\n-    ecx.item_const(sp,\n-                   ecx.ident_of(\"TESTS\"),\n-                   static_type,\n-                   test_descs)\n+/// Creates a slice containing every test like so:\n+/// &[path::to::test1, path::to::test2]\n+fn mk_tests_slice(cx: &TestCtxt) -> P<ast::Expr> {\n+    debug!(\"building test vector from {} tests\", cx.test_cases.len());\n+    let ref ecx = cx.ext_cx;\n+\n+    ecx.expr_vec_slice(DUMMY_SP,\n+        cx.test_cases.iter().map(|test| {\n+            ecx.expr_addr_of(test.span,\n+                ecx.expr_path(ecx.path(test.span, visible_path(cx, &test.path))))\n+        }).collect())\n }\n \n-fn mk_test_descs(cx: &TestCtxt) -> P<ast::Expr> {\n-    debug!(\"building test vector from {} tests\", cx.testfns.len());\n-\n-    P(ast::Expr {\n-        id: ast::DUMMY_NODE_ID,\n-        node: ast::ExprKind::AddrOf(ast::Mutability::Immutable,\n-            P(ast::Expr {\n-                id: ast::DUMMY_NODE_ID,\n-                node: ast::ExprKind::Array(cx.testfns.iter().map(|test| {\n-                    mk_test_desc_and_fn_rec(cx, test)\n-                }).collect()),\n-                span: DUMMY_SP,\n-                attrs: ThinVec::new(),\n-            })),\n-        span: DUMMY_SP,\n-        attrs: ThinVec::new(),\n-    })\n-}\n-\n-fn mk_test_desc_and_fn_rec(cx: &TestCtxt, test: &Test) -> P<ast::Expr> {\n-    // FIXME #15962: should be using quote_expr, but that stringifies\n-    // __test_reexports, causing it to be reinterned, losing the\n-    // gensym information.\n-\n-    let span = ignored_span(cx, test.span);\n-    let ecx = &cx.ext_cx;\n-    let self_id = ecx.ident_of(\"self\");\n-    let test_id = ecx.ident_of(\"test\");\n-\n-    // creates self::test::$name\n-    let test_path = |name| {\n-        ecx.path(span, vec![self_id, test_id, ecx.ident_of(name)])\n-    };\n-    // creates $name: $expr\n-    let field = |name, expr| ecx.field_imm(span, ecx.ident_of(name), expr);\n-\n-    // path to the #[test] function: \"foo::bar::baz\"\n-    let path_string = path_name_i(&test.path[..]);\n-\n-    debug!(\"encoding {}\", path_string);\n-\n-    let name_expr = ecx.expr_str(span, Symbol::intern(&path_string));\n-\n-    // self::test::StaticTestName($name_expr)\n-    let name_expr = ecx.expr_call(span,\n-                                  ecx.expr_path(test_path(\"StaticTestName\")),\n-                                  vec![name_expr]);\n-\n-    let ignore_expr = ecx.expr_bool(span, test.ignore);\n-    let should_panic_path = |name| {\n-        ecx.path(span, vec![self_id, test_id, ecx.ident_of(\"ShouldPanic\"), ecx.ident_of(name)])\n-    };\n-    let fail_expr = match test.should_panic {\n-        ShouldPanic::No => ecx.expr_path(should_panic_path(\"No\")),\n-        ShouldPanic::Yes(msg) => {\n-            match msg {\n-                Some(msg) => {\n-                    let msg = ecx.expr_str(span, msg);\n-                    let path = should_panic_path(\"YesWithMessage\");\n-                    ecx.expr_call(span, ecx.expr_path(path), vec![msg])\n-                }\n-                None => ecx.expr_path(should_panic_path(\"Yes\")),\n-            }\n-        }\n-    };\n-    let allow_fail_expr = ecx.expr_bool(span, test.allow_fail);\n-\n-    // self::test::TestDesc { ... }\n-    let desc_expr = ecx.expr_struct(\n-        span,\n-        test_path(\"TestDesc\"),\n-        vec![field(\"name\", name_expr),\n-             field(\"ignore\", ignore_expr),\n-             field(\"should_panic\", fail_expr),\n-             field(\"allow_fail\", allow_fail_expr)]);\n-\n+/// Creates a path from the top-level __test module to the test via __test_reexports\n+fn visible_path(cx: &TestCtxt, path: &[Ident]) -> Vec<Ident>{\n     let mut visible_path = vec![];\n-    if cx.features.extern_absolute_paths {\n-        visible_path.push(keywords::Crate.ident());\n-    }\n     match cx.toplevel_reexport {\n         Some(id) => visible_path.push(id),\n         None => {\n-            let diag = cx.span_diagnostic;\n-            diag.bug(\"expected to find top-level re-export name, but found None\");\n-        }\n-    };\n-    visible_path.extend_from_slice(&test.path[..]);\n-\n-    // Rather than directly give the test function to the test\n-    // harness, we create a wrapper like one of the following:\n-    //\n-    //     || test::assert_test_result(real_function()) // for test\n-    //     |b| test::assert_test_result(real_function(b)) // for bench\n-    //\n-    // this will coerce into a fn pointer that is specialized to the\n-    // actual return type of `real_function` (Typically `()`, but not always).\n-    let fn_expr = {\n-        // construct `real_function()` (this will be inserted into the overall expr)\n-        let real_function_expr = ecx.expr_path(ecx.path_global(span, visible_path));\n-        // construct path `test::assert_test_result`\n-        let assert_test_result = test_path(\"assert_test_result\");\n-        if test.bench {\n-            // construct `|b| {..}`\n-            let b_ident = Ident::with_empty_ctxt(Symbol::gensym(\"b\"));\n-            let b_expr = ecx.expr_ident(span, b_ident);\n-            ecx.lambda(\n-                span,\n-                vec![b_ident],\n-                // construct `assert_test_result(..)`\n-                ecx.expr_call(\n-                    span,\n-                    ecx.expr_path(assert_test_result),\n-                    vec![\n-                        // construct `real_function(b)`\n-                        ecx.expr_call(\n-                            span,\n-                            real_function_expr,\n-                            vec![b_expr],\n-                        )\n-                    ],\n-                ),\n-            )\n-        } else {\n-            // construct `|| {..}`\n-            ecx.lambda(\n-                span,\n-                vec![],\n-                // construct `assert_test_result(..)`\n-                ecx.expr_call(\n-                    span,\n-                    ecx.expr_path(assert_test_result),\n-                    vec![\n-                        // construct `real_function()`\n-                        ecx.expr_call(\n-                            span,\n-                            real_function_expr,\n-                            vec![],\n-                        )\n-                    ],\n-                ),\n-            )\n+            cx.span_diagnostic.bug(\"expected to find top-level re-export name, but found None\");\n         }\n-    };\n-\n-    let variant_name = if test.bench { \"StaticBenchFn\" } else { \"StaticTestFn\" };\n+    }\n+    visible_path.extend_from_slice(path);\n+    visible_path\n+}\n \n-    // self::test::$variant_name($fn_expr)\n-    let testfn_expr = ecx.expr_call(span, ecx.expr_path(test_path(variant_name)), vec![fn_expr]);\n+fn is_test_case(i: &ast::Item) -> bool {\n+    attr::contains_name(&i.attrs, \"rustc_test_marker\")\n+}\n \n-    // self::test::TestDescAndFn { ... }\n-    ecx.expr_struct(span,\n-                    test_path(\"TestDescAndFn\"),\n-                    vec![field(\"desc\", desc_expr),\n-                         field(\"testfn\", testfn_expr)])\n+fn get_test_runner(sd: &errors::Handler, krate: &ast::Crate) -> Option<ast::Path> {\n+    let test_attr = attr::find_by_name(&krate.attrs, \"test_runner\")?;\n+    if let Some(meta_list) = test_attr.meta_item_list() {\n+        if meta_list.len() != 1 {\n+            sd.span_fatal(test_attr.span(),\n+                \"#![test_runner(..)] accepts exactly 1 argument\").raise()\n+        }\n+        Some(meta_list[0].word().as_ref().unwrap().ident.clone())\n+    } else {\n+        sd.span_fatal(test_attr.span(),\n+            \"test_runner must be of the form #[test_runner(..)]\").raise()\n+    }\n }"}, {"sha": "5a691bde3ecb3c24886bccc936a7e5acbeaa4633", "filename": "src/libsyntax_ext/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3dab33225a8c74dcf1f6a4f6161a10b60d5944e9/src%2Flibsyntax_ext%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/3dab33225a8c74dcf1f6a4f6161a10b60d5944e9/src%2Flibsyntax_ext%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2FCargo.toml?ref=3dab33225a8c74dcf1f6a4f6161a10b60d5944e9", "patch": "@@ -17,3 +17,4 @@ syntax_pos = { path = \"../libsyntax_pos\" }\n rustc_data_structures = { path = \"../librustc_data_structures\" }\n rustc_target = { path = \"../librustc_target\" }\n smallvec = { version = \"0.6.5\", features = [\"union\"] }\n+log = \"0.4\""}, {"sha": "e16f3b1ccb3f3da4fe4b5b15bf1e4727b11af074", "filename": "src/libsyntax_ext/lib.rs", "status": "modified", "additions": 20, "deletions": 2, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/3dab33225a8c74dcf1f6a4f6161a10b60d5944e9/src%2Flibsyntax_ext%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dab33225a8c74dcf1f6a4f6161a10b60d5944e9/src%2Flibsyntax_ext%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Flib.rs?ref=3dab33225a8c74dcf1f6a4f6161a10b60d5944e9", "patch": "@@ -19,7 +19,7 @@\n #![cfg_attr(not(stage0), feature(nll))]\n #![cfg_attr(not(stage0), feature(infer_outlives_requirements))]\n #![feature(str_escape)]\n-\n+#![feature(quote)]\n #![feature(rustc_diagnostic_macros)]\n \n extern crate fmt_macros;\n@@ -32,6 +32,8 @@ extern crate rustc_errors as errors;\n extern crate rustc_target;\n #[macro_use]\n extern crate smallvec;\n+#[macro_use]\n+extern crate log;\n \n mod diagnostics;\n \n@@ -51,6 +53,8 @@ mod format_foreign;\n mod global_asm;\n mod log_syntax;\n mod trace_macros;\n+mod test;\n+mod test_case;\n \n pub mod proc_macro_registrar;\n \n@@ -59,7 +63,7 @@ pub mod proc_macro_impl;\n \n use rustc_data_structures::sync::Lrc;\n use syntax::ast;\n-use syntax::ext::base::{MacroExpanderFn, NormalTT, NamedSyntaxExtension};\n+use syntax::ext::base::{MacroExpanderFn, NormalTT, NamedSyntaxExtension, MultiModifier};\n use syntax::ext::hygiene;\n use syntax::symbol::Symbol;\n \n@@ -68,6 +72,18 @@ pub fn register_builtins(resolver: &mut dyn syntax::ext::base::Resolver,\n                          enable_quotes: bool) {\n     deriving::register_builtin_derives(resolver);\n \n+    {\n+        let mut register_unshadowable = |name, ext| {\n+            resolver.add_unshadowable_attr(ast::Ident::with_empty_ctxt(name), Lrc::new(ext));\n+        };\n+\n+        register_unshadowable(Symbol::intern(\"test\"),\n+            MultiModifier(Box::new(test::expand_test)));\n+\n+        register_unshadowable(Symbol::intern(\"bench\"),\n+            MultiModifier(Box::new(test::expand_bench)));\n+    }\n+\n     let mut register = |name, ext| {\n         resolver.add_builtin(ast::Ident::with_empty_ctxt(name), Lrc::new(ext));\n     };\n@@ -130,6 +146,8 @@ pub fn register_builtins(resolver: &mut dyn syntax::ext::base::Resolver,\n         assert: assert::expand_assert,\n     }\n \n+    register(Symbol::intern(\"test_case\"), MultiModifier(Box::new(test_case::expand)));\n+\n     // format_args uses `unstable` things internally.\n     register(Symbol::intern(\"format_args\"),\n              NormalTT {"}, {"sha": "be3485cfa7cc23a5e2c8a40e3a22e42ac4822f39", "filename": "src/libsyntax_ext/test.rs", "status": "added", "additions": 334, "deletions": 0, "changes": 334, "blob_url": "https://github.com/rust-lang/rust/blob/3dab33225a8c74dcf1f6a4f6161a10b60d5944e9/src%2Flibsyntax_ext%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dab33225a8c74dcf1f6a4f6161a10b60d5944e9/src%2Flibsyntax_ext%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Ftest.rs?ref=3dab33225a8c74dcf1f6a4f6161a10b60d5944e9", "patch": "@@ -0,0 +1,334 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+/// The expansion from a test function to the appropriate test struct for libtest\n+/// Ideally, this code would be in libtest but for efficiency and error messages it lives here.\n+\n+use syntax::ext::base::*;\n+use syntax::ext::build::AstBuilder;\n+use syntax::ext::hygiene::{self, Mark, SyntaxContext};\n+use syntax::attr;\n+use syntax::ast;\n+use syntax::print::pprust;\n+use syntax::symbol::Symbol;\n+use syntax_pos::{DUMMY_SP, Span};\n+use syntax::source_map::{ExpnInfo, MacroAttribute};\n+use std::iter;\n+\n+pub fn expand_test(\n+    cx: &mut ExtCtxt,\n+    attr_sp: Span,\n+    _meta_item: &ast::MetaItem,\n+    item: Annotatable,\n+) -> Vec<Annotatable> {\n+    expand_test_or_bench(cx, attr_sp, item, false)\n+}\n+\n+pub fn expand_bench(\n+    cx: &mut ExtCtxt,\n+    attr_sp: Span,\n+    _meta_item: &ast::MetaItem,\n+    item: Annotatable,\n+) -> Vec<Annotatable> {\n+    expand_test_or_bench(cx, attr_sp, item, true)\n+}\n+\n+pub fn expand_test_or_bench(\n+    cx: &mut ExtCtxt,\n+    attr_sp: Span,\n+    item: Annotatable,\n+    is_bench: bool\n+) -> Vec<Annotatable> {\n+    // If we're not in test configuration, remove the annotated item\n+    if !cx.ecfg.should_test { return vec![]; }\n+\n+    let item =\n+        if let Annotatable::Item(i) = item { i }\n+        else {\n+            cx.parse_sess.span_diagnostic.span_fatal(item.span(),\n+                \"#[test] attribute is only allowed on fn items\").raise();\n+        };\n+\n+    if let ast::ItemKind::Mac(_) = item.node {\n+        cx.parse_sess.span_diagnostic.span_warn(item.span,\n+            \"#[test] attribute should not be used on macros. Use #[cfg(test)] instead.\");\n+        return vec![Annotatable::Item(item)];\n+    }\n+\n+    // has_*_signature will report any errors in the type so compilation\n+    // will fail. We shouldn't try to expand in this case because the errors\n+    // would be spurious.\n+    if (!is_bench && !has_test_signature(cx, &item)) ||\n+        (is_bench && !has_bench_signature(cx, &item)) {\n+        return vec![Annotatable::Item(item)];\n+    }\n+\n+    let (sp, attr_sp) = {\n+        let mark = Mark::fresh(Mark::root());\n+        mark.set_expn_info(ExpnInfo {\n+            call_site: DUMMY_SP,\n+            def_site: None,\n+            format: MacroAttribute(Symbol::intern(\"test\")),\n+            allow_internal_unstable: true,\n+            allow_internal_unsafe: false,\n+            local_inner_macros: false,\n+            edition: hygiene::default_edition(),\n+        });\n+        (item.span.with_ctxt(SyntaxContext::empty().apply_mark(mark)),\n+         attr_sp.with_ctxt(SyntaxContext::empty().apply_mark(mark)))\n+    };\n+\n+    // Gensym \"test\" so we can extern crate without conflicting with any local names\n+    let test_id = cx.ident_of(\"test\").gensym();\n+\n+    // creates test::$name\n+    let test_path = |name| {\n+        cx.path(sp, vec![test_id, cx.ident_of(name)])\n+    };\n+\n+    // creates test::$name\n+    let should_panic_path = |name| {\n+        cx.path(sp, vec![test_id, cx.ident_of(\"ShouldPanic\"), cx.ident_of(name)])\n+    };\n+\n+    // creates $name: $expr\n+    let field = |name, expr| cx.field_imm(sp, cx.ident_of(name), expr);\n+\n+    let test_fn = if is_bench {\n+        // A simple ident for a lambda\n+        let b = cx.ident_of(\"b\");\n+\n+        cx.expr_call(sp, cx.expr_path(test_path(\"StaticBenchFn\")), vec![\n+            // |b| self::test::assert_test_result(\n+            cx.lambda1(sp,\n+                cx.expr_call(sp, cx.expr_path(test_path(\"assert_test_result\")), vec![\n+                    // super::$test_fn(b)\n+                    cx.expr_call(sp,\n+                        cx.expr_path(cx.path(sp, vec![item.ident])),\n+                        vec![cx.expr_ident(sp, b)])\n+                ]),\n+                b\n+            )\n+            // )\n+        ])\n+    } else {\n+        cx.expr_call(sp, cx.expr_path(test_path(\"StaticTestFn\")), vec![\n+            // || {\n+            cx.lambda0(sp,\n+                // test::assert_test_result(\n+                cx.expr_call(sp, cx.expr_path(test_path(\"assert_test_result\")), vec![\n+                    // $test_fn()\n+                    cx.expr_call(sp, cx.expr_path(cx.path(sp, vec![item.ident])), vec![])\n+                // )\n+                ])\n+            // }\n+            )\n+        // )\n+        ])\n+    };\n+\n+    let mut test_const = cx.item(sp, item.ident.gensym(),\n+        vec![\n+            // #[cfg(test)]\n+            cx.attribute(attr_sp, cx.meta_list(attr_sp, Symbol::intern(\"cfg\"), vec![\n+                cx.meta_list_item_word(attr_sp, Symbol::intern(\"test\"))\n+            ])),\n+            // #[rustc_test_marker]\n+            cx.attribute(attr_sp, cx.meta_word(attr_sp, Symbol::intern(\"rustc_test_marker\")))\n+        ],\n+        // const $ident: test::TestDescAndFn =\n+        ast::ItemKind::Const(cx.ty(sp, ast::TyKind::Path(None, test_path(\"TestDescAndFn\"))),\n+            // test::TestDescAndFn {\n+            cx.expr_struct(sp, test_path(\"TestDescAndFn\"), vec![\n+                // desc: test::TestDesc {\n+                field(\"desc\", cx.expr_struct(sp, test_path(\"TestDesc\"), vec![\n+                    // name: \"path::to::test\"\n+                    field(\"name\", cx.expr_call(sp, cx.expr_path(test_path(\"StaticTestName\")),\n+                        vec![\n+                            cx.expr_str(sp, Symbol::intern(&item_path(\n+                                // skip the name of the root module\n+                                &cx.current_expansion.module.mod_path[1..],\n+                                &item.ident\n+                            )))\n+                        ])),\n+                    // ignore: true | false\n+                    field(\"ignore\", cx.expr_bool(sp, should_ignore(&item))),\n+                    // allow_fail: true | false\n+                    field(\"allow_fail\", cx.expr_bool(sp, should_fail(&item))),\n+                    // should_panic: ...\n+                    field(\"should_panic\", match should_panic(cx, &item) {\n+                        // test::ShouldPanic::No\n+                        ShouldPanic::No => cx.expr_path(should_panic_path(\"No\")),\n+                        // test::ShouldPanic::Yes\n+                        ShouldPanic::Yes(None) => cx.expr_path(should_panic_path(\"Yes\")),\n+                        // test::ShouldPanic::YesWithMessage(\"...\")\n+                        ShouldPanic::Yes(Some(sym)) => cx.expr_call(sp,\n+                            cx.expr_path(should_panic_path(\"YesWithMessage\")),\n+                            vec![cx.expr_str(sp, sym)]),\n+                    }),\n+                // },\n+                ])),\n+                // testfn: test::StaticTestFn(...) | test::StaticBenchFn(...)\n+                field(\"testfn\", test_fn)\n+            // }\n+            ])\n+        // }\n+        ));\n+    test_const = test_const.map(|mut tc| { tc.vis.node = ast::VisibilityKind::Public; tc});\n+\n+    // extern crate test as test_gensym\n+    let test_extern = cx.item(sp,\n+        test_id,\n+        vec![],\n+        ast::ItemKind::ExternCrate(Some(Symbol::intern(\"test\")))\n+    );\n+\n+    debug!(\"Synthetic test item:\\n{}\\n\", pprust::item_to_string(&test_const));\n+\n+    vec![\n+        // Access to libtest under a gensymed name\n+        Annotatable::Item(test_extern),\n+        // The generated test case\n+        Annotatable::Item(test_const),\n+        // The original item\n+        Annotatable::Item(item)\n+    ]\n+}\n+\n+fn item_path(mod_path: &[ast::Ident], item_ident: &ast::Ident) -> String {\n+    mod_path.iter().chain(iter::once(item_ident))\n+        .map(|x| x.to_string()).collect::<Vec<String>>().join(\"::\")\n+}\n+\n+enum ShouldPanic {\n+    No,\n+    Yes(Option<Symbol>),\n+}\n+\n+fn should_ignore(i: &ast::Item) -> bool {\n+    attr::contains_name(&i.attrs, \"ignore\")\n+}\n+\n+fn should_fail(i: &ast::Item) -> bool {\n+    attr::contains_name(&i.attrs, \"allow_fail\")\n+}\n+\n+fn should_panic(cx: &ExtCtxt, i: &ast::Item) -> ShouldPanic {\n+    match attr::find_by_name(&i.attrs, \"should_panic\") {\n+        Some(attr) => {\n+            let ref sd = cx.parse_sess.span_diagnostic;\n+            if attr.is_value_str() {\n+                sd.struct_span_warn(\n+                    attr.span(),\n+                    \"attribute must be of the form: \\\n+                     `#[should_panic]` or \\\n+                     `#[should_panic(expected = \\\"error message\\\")]`\"\n+                ).note(\"Errors in this attribute were erroneously allowed \\\n+                        and will become a hard error in a future release.\")\n+                .emit();\n+                return ShouldPanic::Yes(None);\n+            }\n+            match attr.meta_item_list() {\n+                // Handle #[should_panic]\n+                None => ShouldPanic::Yes(None),\n+                // Handle #[should_panic(expected = \"foo\")]\n+                Some(list) => {\n+                    let msg = list.iter()\n+                        .find(|mi| mi.check_name(\"expected\"))\n+                        .and_then(|mi| mi.meta_item())\n+                        .and_then(|mi| mi.value_str());\n+                    if list.len() != 1 || msg.is_none() {\n+                        sd.struct_span_warn(\n+                            attr.span(),\n+                            \"argument must be of the form: \\\n+                             `expected = \\\"error message\\\"`\"\n+                        ).note(\"Errors in this attribute were erroneously \\\n+                                allowed and will become a hard error in a \\\n+                                future release.\").emit();\n+                        ShouldPanic::Yes(None)\n+                    } else {\n+                        ShouldPanic::Yes(msg)\n+                    }\n+                },\n+            }\n+        }\n+        None => ShouldPanic::No,\n+    }\n+}\n+\n+fn has_test_signature(cx: &ExtCtxt, i: &ast::Item) -> bool {\n+    let has_should_panic_attr = attr::contains_name(&i.attrs, \"should_panic\");\n+    let ref sd = cx.parse_sess.span_diagnostic;\n+    if let ast::ItemKind::Fn(ref decl, ref header, ref generics, _) = i.node {\n+        if header.unsafety == ast::Unsafety::Unsafe {\n+            sd.span_err(\n+                i.span,\n+                \"unsafe functions cannot be used for tests\"\n+            );\n+            return false\n+        }\n+        if header.asyncness.is_async() {\n+            sd.span_err(\n+                i.span,\n+                \"async functions cannot be used for tests\"\n+            );\n+            return false\n+        }\n+\n+\n+        // If the termination trait is active, the compiler will check that the output\n+        // type implements the `Termination` trait as `libtest` enforces that.\n+        let has_output = match decl.output {\n+            ast::FunctionRetTy::Default(..) => false,\n+            ast::FunctionRetTy::Ty(ref t) if t.node.is_unit() => false,\n+            _ => true\n+        };\n+\n+        if !decl.inputs.is_empty() {\n+            sd.span_err(i.span, \"functions used as tests can not have any arguments\");\n+            return false;\n+        }\n+\n+        match (has_output, has_should_panic_attr) {\n+            (true, true) => {\n+                sd.span_err(i.span, \"functions using `#[should_panic]` must return `()`\");\n+                false\n+            },\n+            (true, false) => if !generics.params.is_empty() {\n+                sd.span_err(i.span,\n+                                \"functions used as tests must have signature fn() -> ()\");\n+                false\n+            } else {\n+                true\n+            },\n+            (false, _) => true\n+        }\n+    } else {\n+        sd.span_err(i.span, \"only functions may be used as tests\");\n+        false\n+    }\n+}\n+\n+fn has_bench_signature(cx: &ExtCtxt, i: &ast::Item) -> bool {\n+    let has_sig = if let ast::ItemKind::Fn(ref decl, _, _, _) = i.node {\n+        // NB: inadequate check, but we're running\n+        // well before resolve, can't get too deep.\n+        decl.inputs.len() == 1\n+    } else {\n+        false\n+    };\n+\n+    if !has_sig {\n+        cx.parse_sess.span_diagnostic.span_err(i.span, \"functions used as benches must have \\\n+            signature `fn(&mut Bencher) -> impl Termination`\");\n+    }\n+\n+    has_sig\n+}"}, {"sha": "0128db7dd78d7cca4b7ba9f49feb5e8458618bb6", "filename": "src/libsyntax_ext/test_case.rs", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/3dab33225a8c74dcf1f6a4f6161a10b60d5944e9/src%2Flibsyntax_ext%2Ftest_case.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dab33225a8c74dcf1f6a4f6161a10b60d5944e9/src%2Flibsyntax_ext%2Ftest_case.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Ftest_case.rs?ref=3dab33225a8c74dcf1f6a4f6161a10b60d5944e9", "patch": "@@ -0,0 +1,75 @@\n+\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// #[test_case] is used by custom test authors to mark tests\n+// When building for test, it needs to make the item public and gensym the name\n+// Otherwise, we'll omit the item. This behavior means that any item annotated\n+// with #[test_case] is never addressable.\n+//\n+// We mark item with an inert attribute \"rustc_test_marker\" which the test generation\n+// logic will pick up on.\n+\n+use syntax::ext::base::*;\n+use syntax::ext::build::AstBuilder;\n+use syntax::ext::hygiene::{self, Mark, SyntaxContext};\n+use syntax::ast;\n+use syntax::source_map::respan;\n+use syntax::symbol::Symbol;\n+use syntax_pos::{DUMMY_SP, Span};\n+use syntax::source_map::{ExpnInfo, MacroAttribute};\n+use syntax::feature_gate;\n+\n+pub fn expand(\n+    ecx: &mut ExtCtxt,\n+    attr_sp: Span,\n+    _meta_item: &ast::MetaItem,\n+    anno_item: Annotatable\n+) -> Vec<Annotatable> {\n+    if !ecx.ecfg.enable_custom_test_frameworks() {\n+        feature_gate::emit_feature_err(&ecx.parse_sess,\n+                                       \"custom_test_frameworks\",\n+                                       attr_sp,\n+                                       feature_gate::GateIssue::Language,\n+                                       feature_gate::EXPLAIN_CUSTOM_TEST_FRAMEWORKS);\n+\n+        return vec![anno_item];\n+    }\n+\n+    if !ecx.ecfg.should_test { return vec![]; }\n+\n+    let sp = {\n+        let mark = Mark::fresh(Mark::root());\n+        mark.set_expn_info(ExpnInfo {\n+            call_site: DUMMY_SP,\n+            def_site: None,\n+            format: MacroAttribute(Symbol::intern(\"test_case\")),\n+            allow_internal_unstable: true,\n+            allow_internal_unsafe: false,\n+            local_inner_macros: false,\n+            edition: hygiene::default_edition(),\n+        });\n+        attr_sp.with_ctxt(SyntaxContext::empty().apply_mark(mark))\n+    };\n+\n+    let mut item = anno_item.expect_item();\n+\n+    item = item.map(|mut item| {\n+        item.vis = respan(item.vis.span, ast::VisibilityKind::Public);\n+        item.ident = item.ident.gensym();\n+        item.attrs.push(\n+            ecx.attribute(sp,\n+                ecx.meta_word(sp, Symbol::intern(\"rustc_test_marker\")))\n+        );\n+        item\n+    });\n+\n+    return vec![Annotatable::Item(item)]\n+}"}, {"sha": "3c803ad82337f600ada136fbeeeec02ed7e290c4", "filename": "src/libtest/formatters/json.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3dab33225a8c74dcf1f6a4f6161a10b60d5944e9/src%2Flibtest%2Fformatters%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dab33225a8c74dcf1f6a4f6161a10b60d5944e9/src%2Flibtest%2Fformatters%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Fformatters%2Fjson.rs?ref=3dab33225a8c74dcf1f6a4f6161a10b60d5944e9", "patch": "@@ -50,7 +50,7 @@ impl<T: Write> JsonFormatter<T> {\n impl<T: Write> OutputFormatter for JsonFormatter<T> {\n     fn write_run_start(&mut self, test_count: usize) -> io::Result<()> {\n         self.write_message(&*format!(\n-            r#\"{{ \"type\": \"suite\", \"event\": \"started\", \"test_count\": \"{}\" }}\"#,\n+            r#\"{{ \"type\": \"suite\", \"event\": \"started\", \"test_count\": {} }}\"#,\n             test_count\n         ))\n     }\n@@ -136,7 +136,7 @@ impl<T: Write> OutputFormatter for JsonFormatter<T> {\n              \\\"allowed_fail\\\": {}, \\\n              \\\"ignored\\\": {}, \\\n              \\\"measured\\\": {}, \\\n-             \\\"filtered_out\\\": \\\"{}\\\" }}\",\n+             \\\"filtered_out\\\": {} }}\",\n             if state.failed == 0 { \"ok\" } else { \"failed\" },\n             state.passed,\n             state.failed + state.allowed_fail,"}, {"sha": "bf3cb7c537bd0da9879851e85c5c1d5312c49d94", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3dab33225a8c74dcf1f6a4f6161a10b60d5944e9/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dab33225a8c74dcf1f6a4f6161a10b60d5944e9/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=3dab33225a8c74dcf1f6a4f6161a10b60d5944e9", "patch": "@@ -41,6 +41,7 @@\n #![feature(panic_unwind)]\n #![feature(staged_api)]\n #![feature(termination_trait_lib)]\n+#![feature(test)]\n \n extern crate getopts;\n #[cfg(any(unix, target_os = \"cloudabi\"))]\n@@ -302,7 +303,7 @@ pub fn test_main(args: &[String], tests: Vec<TestDescAndFn>, options: Options) {\n // a Vec<TestDescAndFn> is used in order to effect ownership-transfer\n // semantics into parallel test runners, which in turn requires a Vec<>\n // rather than a &[].\n-pub fn test_main_static(tests: &[TestDescAndFn]) {\n+pub fn test_main_static(tests: &[&TestDescAndFn]) {\n     let args = env::args().collect::<Vec<_>>();\n     let owned_tests = tests\n         .iter()"}, {"sha": "9a8749712c355122f874648dc060eec333100920", "filename": "src/libtest/stats.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3dab33225a8c74dcf1f6a4f6161a10b60d5944e9/src%2Flibtest%2Fstats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dab33225a8c74dcf1f6a4f6161a10b60d5944e9/src%2Flibtest%2Fstats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Fstats.rs?ref=3dab33225a8c74dcf1f6a4f6161a10b60d5944e9", "patch": "@@ -907,7 +907,8 @@ mod tests {\n \n #[cfg(test)]\n mod bench {\n-    use Bencher;\n+    extern crate test;\n+    use self::test::Bencher;\n     use stats::Stats;\n \n     #[bench]"}, {"sha": "7067e7250728fa9aae942e139587e21ab50cfd7e", "filename": "src/test/incremental/issue-49595/issue_49595.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3dab33225a8c74dcf1f6a4f6161a10b60d5944e9/src%2Ftest%2Fincremental%2Fissue-49595%2Fissue_49595.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dab33225a8c74dcf1f6a4f6161a10b60d5944e9/src%2Ftest%2Fincremental%2Fissue-49595%2Fissue_49595.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fissue-49595%2Fissue_49595.rs?ref=3dab33225a8c74dcf1f6a4f6161a10b60d5944e9", "patch": "@@ -15,12 +15,11 @@\n #![feature(rustc_attrs)]\n #![crate_type = \"rlib\"]\n \n-#![rustc_partition_codegened(module=\"issue_49595-__test\", cfg=\"cfail2\")]\n+#![rustc_partition_codegened(module=\"issue_49595-tests\", cfg=\"cfail2\")]\n #![rustc_partition_codegened(module=\"issue_49595-lit_test\", cfg=\"cfail3\")]\n \n mod tests {\n-    #[cfg_attr(not(cfail1), ignore)]\n-    #[test]\n+    #[cfg_attr(not(cfail1), test)]\n     fn test() {\n     }\n }"}, {"sha": "d8169ece89b38b2d47a9fa2edb18f2629d3ff07f", "filename": "src/test/run-make-fulldeps/libtest-json/output.json", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3dab33225a8c74dcf1f6a4f6161a10b60d5944e9/src%2Ftest%2Frun-make-fulldeps%2Flibtest-json%2Foutput.json", "raw_url": "https://github.com/rust-lang/rust/raw/3dab33225a8c74dcf1f6a4f6161a10b60d5944e9/src%2Ftest%2Frun-make-fulldeps%2Flibtest-json%2Foutput.json", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Flibtest-json%2Foutput.json?ref=3dab33225a8c74dcf1f6a4f6161a10b60d5944e9", "patch": "@@ -1,4 +1,4 @@\n-{ \"type\": \"suite\", \"event\": \"started\", \"test_count\": \"4\" }\n+{ \"type\": \"suite\", \"event\": \"started\", \"test_count\": 4 }\n { \"type\": \"test\", \"event\": \"started\", \"name\": \"a\" }\n { \"type\": \"test\", \"name\": \"a\", \"event\": \"ok\" }\n { \"type\": \"test\", \"event\": \"started\", \"name\": \"b\" }\n@@ -7,4 +7,4 @@\n { \"type\": \"test\", \"name\": \"c\", \"event\": \"ok\" }\n { \"type\": \"test\", \"event\": \"started\", \"name\": \"d\" }\n { \"type\": \"test\", \"name\": \"d\", \"event\": \"ignored\" }\n-{ \"type\": \"suite\", \"event\": \"failed\", \"passed\": 2, \"failed\": 1, \"allowed_fail\": 0, \"ignored\": 1, \"measured\": 0, \"filtered_out\": \"0\" }\n+{ \"type\": \"suite\", \"event\": \"failed\", \"passed\": 2, \"failed\": 1, \"allowed_fail\": 0, \"ignored\": 1, \"measured\": 0, \"filtered_out\": 0 }"}, {"sha": "55eca7f45a5aec0a7814892316c3a1ada6d08ca3", "filename": "src/test/ui/cfg-non-opt-expr.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3dab33225a8c74dcf1f6a4f6161a10b60d5944e9/src%2Ftest%2Fui%2Fcfg-non-opt-expr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dab33225a8c74dcf1f6a4f6161a10b60d5944e9/src%2Ftest%2Fui%2Fcfg-non-opt-expr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcfg-non-opt-expr.rs?ref=3dab33225a8c74dcf1f6a4f6161a10b60d5944e9", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n #![feature(stmt_expr_attributes)]\n+#![feature(custom_test_frameworks)]\n \n fn main() {\n     let _ = #[cfg(unset)] ();\n@@ -17,6 +18,4 @@ fn main() {\n     //~^ ERROR removing an expression is not supported in this position\n     let _ = [1, 2, 3][#[cfg(unset)] 1];\n     //~^ ERROR removing an expression is not supported in this position\n-    let _ = #[test] ();\n-    //~^ ERROR removing an expression is not supported in this position\n }"}, {"sha": "1892cee113ecb93edcb646ccd7a08f68941eb1f5", "filename": "src/test/ui/cfg-non-opt-expr.stderr", "status": "modified", "additions": 4, "deletions": 10, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3dab33225a8c74dcf1f6a4f6161a10b60d5944e9/src%2Ftest%2Fui%2Fcfg-non-opt-expr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3dab33225a8c74dcf1f6a4f6161a10b60d5944e9/src%2Ftest%2Fui%2Fcfg-non-opt-expr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcfg-non-opt-expr.stderr?ref=3dab33225a8c74dcf1f6a4f6161a10b60d5944e9", "patch": "@@ -1,26 +1,20 @@\n error: removing an expression is not supported in this position\n-  --> $DIR/cfg-non-opt-expr.rs:14:13\n+  --> $DIR/cfg-non-opt-expr.rs:15:13\n    |\n LL |     let _ = #[cfg(unset)] ();\n    |             ^^^^^^^^^^^^^\n \n error: removing an expression is not supported in this position\n-  --> $DIR/cfg-non-opt-expr.rs:16:21\n+  --> $DIR/cfg-non-opt-expr.rs:17:21\n    |\n LL |     let _ = 1 + 2 + #[cfg(unset)] 3;\n    |                     ^^^^^^^^^^^^^\n \n error: removing an expression is not supported in this position\n-  --> $DIR/cfg-non-opt-expr.rs:18:23\n+  --> $DIR/cfg-non-opt-expr.rs:19:23\n    |\n LL |     let _ = [1, 2, 3][#[cfg(unset)] 1];\n    |                       ^^^^^^^^^^^^^\n \n-error: removing an expression is not supported in this position\n-  --> $DIR/cfg-non-opt-expr.rs:20:13\n-   |\n-LL |     let _ = #[test] ();\n-   |             ^^^^^^^\n-\n-error: aborting due to 4 previous errors\n+error: aborting due to 3 previous errors\n "}, {"sha": "39a4dc569fa62534cf1f971cf7f15ed3b8082994", "filename": "src/test/ui/custom-test-frameworks-simple.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/3dab33225a8c74dcf1f6a4f6161a10b60d5944e9/src%2Ftest%2Fui%2Fcustom-test-frameworks-simple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dab33225a8c74dcf1f6a4f6161a10b60d5944e9/src%2Ftest%2Fui%2Fcustom-test-frameworks-simple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcustom-test-frameworks-simple.rs?ref=3dab33225a8c74dcf1f6a4f6161a10b60d5944e9", "patch": "@@ -0,0 +1,32 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags: --test\n+// run-pass\n+\n+#![feature(custom_test_frameworks)]\n+#![test_runner(crate::foo_runner)]\n+\n+#[cfg(test)]\n+fn foo_runner(ts: &[&Fn(usize)->()]) {\n+    for (i, t) in ts.iter().enumerate() {\n+        t(i);\n+    }\n+}\n+\n+#[test_case]\n+fn test1(i: usize) {\n+    println!(\"Hi #{}\", i);\n+}\n+\n+#[test_case]\n+fn test2(i: usize) {\n+    println!(\"Hey #{}\", i);\n+}"}, {"sha": "c204e69eafca687f8ca93c9108cb3cbb39821d7a", "filename": "src/test/ui/custom_test_frameworks/auxiliary/dynamic_runner.rs", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/3dab33225a8c74dcf1f6a4f6161a10b60d5944e9/src%2Ftest%2Fui%2Fcustom_test_frameworks%2Fauxiliary%2Fdynamic_runner.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dab33225a8c74dcf1f6a4f6161a10b60d5944e9/src%2Ftest%2Fui%2Fcustom_test_frameworks%2Fauxiliary%2Fdynamic_runner.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcustom_test_frameworks%2Fauxiliary%2Fdynamic_runner.rs?ref=3dab33225a8c74dcf1f6a4f6161a10b60d5944e9", "patch": "@@ -0,0 +1,45 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::process::exit;\n+\n+pub trait Testable {\n+    // Name of the test\n+    fn name(&self) -> String;\n+\n+    // Tests pass by default\n+    fn run(&self) -> bool {\n+        true\n+    }\n+\n+    // A test can generate subtests\n+    fn subtests(&self) -> Vec<Box<dyn Testable>> {\n+        vec![]\n+    }\n+}\n+\n+fn run_test(t: &dyn Testable) -> bool {\n+    let success = t.subtests().into_iter().all(|sub_t| run_test(&*sub_t)) && t.run();\n+    println!(\"{}...{}\", t.name(), if success { \"SUCCESS\" } else { \"FAIL\" });\n+    success\n+}\n+\n+pub fn runner(tests: &[&dyn Testable]) {\n+    let mut failed = false;\n+    for t in tests {\n+        if !run_test(*t) {\n+            failed = true;\n+        }\n+    }\n+\n+    if failed {\n+        exit(1);\n+    }\n+}"}, {"sha": "7b6b5e02955cce15a788a70e1665acc50b12dbca", "filename": "src/test/ui/custom_test_frameworks/auxiliary/example_runner.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/3dab33225a8c74dcf1f6a4f6161a10b60d5944e9/src%2Ftest%2Fui%2Fcustom_test_frameworks%2Fauxiliary%2Fexample_runner.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dab33225a8c74dcf1f6a4f6161a10b60d5944e9/src%2Ftest%2Fui%2Fcustom_test_frameworks%2Fauxiliary%2Fexample_runner.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcustom_test_frameworks%2Fauxiliary%2Fexample_runner.rs?ref=3dab33225a8c74dcf1f6a4f6161a10b60d5944e9", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+pub trait Testable {\n+    fn name(&self) -> String;\n+    fn run(&self) -> Option<String>; // None will be success, Some is the error message\n+}\n+\n+pub fn runner(tests: &[&dyn Testable]) {\n+    for t in tests {\n+        print!(\"{}........{}\", t.name(), t.run().unwrap_or_else(|| \"SUCCESS\".to_string()));\n+    }\n+}"}, {"sha": "f82571b948ab7eb9ab022e70371a5fdced145511", "filename": "src/test/ui/custom_test_frameworks/dynamic.rs", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/3dab33225a8c74dcf1f6a4f6161a10b60d5944e9/src%2Ftest%2Fui%2Fcustom_test_frameworks%2Fdynamic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dab33225a8c74dcf1f6a4f6161a10b60d5944e9/src%2Ftest%2Fui%2Fcustom_test_frameworks%2Fdynamic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcustom_test_frameworks%2Fdynamic.rs?ref=3dab33225a8c74dcf1f6a4f6161a10b60d5944e9", "patch": "@@ -0,0 +1,45 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// run-pass\n+// aux-build:dynamic_runner.rs\n+// compile-flags:--test\n+#![feature(custom_test_frameworks)]\n+#![test_runner(dynamic_runner::runner)]\n+\n+extern crate dynamic_runner;\n+\n+pub struct AllFoo(&'static str);\n+struct IsFoo(String);\n+\n+impl dynamic_runner::Testable for AllFoo {\n+    fn name(&self) -> String {\n+        String::from(self.0)\n+    }\n+\n+    fn subtests(&self) -> Vec<Box<dyn dynamic_runner::Testable>> {\n+        self.0.split(\" \").map(|word|\n+            Box::new(IsFoo(word.into())) as Box<dyn dynamic_runner::Testable>\n+        ).collect()\n+    }\n+}\n+\n+impl dynamic_runner::Testable for IsFoo {\n+    fn name(&self) -> String {\n+        self.0.clone()\n+    }\n+\n+    fn run(&self) -> bool {\n+        self.0 == \"foo\"\n+    }\n+}\n+\n+#[test_case]\n+const TEST_2: AllFoo = AllFoo(\"foo foo\");"}, {"sha": "9fcf76ec33e28f24182c73100eda7ffb63927c2a", "filename": "src/test/ui/custom_test_frameworks/full.rs", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/3dab33225a8c74dcf1f6a4f6161a10b60d5944e9/src%2Ftest%2Fui%2Fcustom_test_frameworks%2Ffull.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dab33225a8c74dcf1f6a4f6161a10b60d5944e9/src%2Ftest%2Fui%2Fcustom_test_frameworks%2Ffull.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcustom_test_frameworks%2Ffull.rs?ref=3dab33225a8c74dcf1f6a4f6161a10b60d5944e9", "patch": "@@ -0,0 +1,38 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// run-pass\n+// aux-build:example_runner.rs\n+// compile-flags:--test\n+\n+#![feature(custom_test_frameworks)]\n+#![test_runner(example_runner::runner)]\n+extern crate example_runner;\n+\n+pub struct IsFoo(&'static str);\n+\n+impl example_runner::Testable for IsFoo {\n+    fn name(&self) -> String {\n+        self.0.to_string()\n+    }\n+\n+    fn run(&self) -> Option<String> {\n+        if self.0 != \"foo\" {\n+            return Some(format!(\"{} != foo\", self.0));\n+        }\n+        None\n+    }\n+}\n+\n+#[test_case]\n+const TEST_1: IsFoo = IsFoo(\"hello\");\n+\n+#[test_case]\n+const TEST_2: IsFoo = IsFoo(\"foo\");"}, {"sha": "28753f1649abdc6184cdf7acba057f465935912f", "filename": "src/test/ui/custom_test_frameworks/mismatch.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/3dab33225a8c74dcf1f6a4f6161a10b60d5944e9/src%2Ftest%2Fui%2Fcustom_test_frameworks%2Fmismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dab33225a8c74dcf1f6a4f6161a10b60d5944e9/src%2Ftest%2Fui%2Fcustom_test_frameworks%2Fmismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcustom_test_frameworks%2Fmismatch.rs?ref=3dab33225a8c74dcf1f6a4f6161a10b60d5944e9", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:example_runner.rs\n+// compile-flags:--test\n+#![feature(custom_test_frameworks)]\n+#![test_runner(example_runner::runner)]\n+\n+extern crate example_runner;\n+\n+#[test]\n+fn wrong_kind(){}"}, {"sha": "8e2afaedfffaad459c2097347d75fcaf4b2f4d41", "filename": "src/test/ui/custom_test_frameworks/mismatch.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/3dab33225a8c74dcf1f6a4f6161a10b60d5944e9/src%2Ftest%2Fui%2Fcustom_test_frameworks%2Fmismatch.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3dab33225a8c74dcf1f6a4f6161a10b60d5944e9/src%2Ftest%2Fui%2Fcustom_test_frameworks%2Fmismatch.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcustom_test_frameworks%2Fmismatch.stderr?ref=3dab33225a8c74dcf1f6a4f6161a10b60d5944e9", "patch": "@@ -0,0 +1,11 @@\n+error[E0277]: the trait bound `test::TestDescAndFn: example_runner::Testable` is not satisfied\n+  --> $DIR/mismatch.rs:19:1\n+   |\n+LL | fn wrong_kind(){}\n+   | ^^^^^^^^^^^^^^^^^ the trait `example_runner::Testable` is not implemented for `test::TestDescAndFn`\n+   |\n+   = note: required for the cast to the object type `dyn example_runner::Testable`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "7c9f7dd040207fd80f106eef2329923477b50875", "filename": "src/test/ui/feature-gate-custom_test_frameworks.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/3dab33225a8c74dcf1f6a4f6161a10b60d5944e9/src%2Ftest%2Fui%2Ffeature-gate-custom_test_frameworks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dab33225a8c74dcf1f6a4f6161a10b60d5944e9/src%2Ftest%2Fui%2Ffeature-gate-custom_test_frameworks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate-custom_test_frameworks.rs?ref=3dab33225a8c74dcf1f6a4f6161a10b60d5944e9", "patch": "@@ -0,0 +1,13 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![test_runner(main)] //~ ERROR custom test frameworks are an unstable feature\n+\n+fn main() {}"}, {"sha": "bfcbab500671f2b643943f5d6e827033d37afe84", "filename": "src/test/ui/feature-gate-custom_test_frameworks.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/3dab33225a8c74dcf1f6a4f6161a10b60d5944e9/src%2Ftest%2Fui%2Ffeature-gate-custom_test_frameworks.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3dab33225a8c74dcf1f6a4f6161a10b60d5944e9/src%2Ftest%2Fui%2Ffeature-gate-custom_test_frameworks.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate-custom_test_frameworks.stderr?ref=3dab33225a8c74dcf1f6a4f6161a10b60d5944e9", "patch": "@@ -0,0 +1,11 @@\n+error[E0658]: custom test frameworks are an unstable feature (see issue #50297)\n+  --> $DIR/feature-gate-custom_test_frameworks.rs:11:1\n+   |\n+LL | #![test_runner(main)] //~ ERROR custom test frameworks are an unstable feature\n+   | ^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: add #![feature(custom_test_frameworks)] to the crate attributes to enable\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0658`."}, {"sha": "5b964c1a14b992aa6a41e2d53e6fa4720aa052f4", "filename": "src/test/ui/inaccessible-test-modules.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3dab33225a8c74dcf1f6a4f6161a10b60d5944e9/src%2Ftest%2Fui%2Finaccessible-test-modules.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3dab33225a8c74dcf1f6a4f6161a10b60d5944e9/src%2Ftest%2Fui%2Finaccessible-test-modules.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finaccessible-test-modules.stderr?ref=3dab33225a8c74dcf1f6a4f6161a10b60d5944e9", "patch": "@@ -2,7 +2,7 @@ error[E0432]: unresolved import `__test`\n   --> $DIR/inaccessible-test-modules.rs:15:5\n    |\n LL | use __test as x; //~ ERROR unresolved import `__test`\n-   |     ^^^^^^^^^^^ no `__test` in the root. Did you mean to use `__test`?\n+   |     ^^^^^^^^^^^ no `__test` in the root. Did you mean to use `test`?\n \n error[E0432]: unresolved import `__test_reexports`\n   --> $DIR/inaccessible-test-modules.rs:16:5"}, {"sha": "424cbd981c87d9b92c6aeb632377c14cf121a61d", "filename": "src/test/ui/issues/issue-11692-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3dab33225a8c74dcf1f6a4f6161a10b60d5944e9/src%2Ftest%2Fui%2Fissues%2Fissue-11692-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dab33225a8c74dcf1f6a4f6161a10b60d5944e9/src%2Ftest%2Fui%2Fissues%2Fissue-11692-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-11692-2.rs?ref=3dab33225a8c74dcf1f6a4f6161a10b60d5944e9", "patch": "@@ -10,5 +10,5 @@\n \n fn main() {\n     concat!(test!());\n-    //~^ ERROR cannot find macro `test!` in this scope\n+    //~^ error: cannot find macro `test!` in this scope\n }"}, {"sha": "853a2a0f1b4f1018f812d7823b14f01d1b9b2d05", "filename": "src/test/ui/issues/issue-12997-2.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3dab33225a8c74dcf1f6a4f6161a10b60d5944e9/src%2Ftest%2Fui%2Fissues%2Fissue-12997-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3dab33225a8c74dcf1f6a4f6161a10b60d5944e9/src%2Ftest%2Fui%2Fissues%2Fissue-12997-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-12997-2.stderr?ref=3dab33225a8c74dcf1f6a4f6161a10b60d5944e9", "patch": "@@ -5,7 +5,7 @@ LL | fn bar(x: isize) { }\n    | ^^^^^^^^^^^^^^^^^^^^ expected isize, found mutable reference\n    |\n    = note: expected type `isize`\n-              found type `&mut __test::test::Bencher`\n+              found type `&mut test::Bencher`\n \n error: aborting due to previous error\n "}, {"sha": "a7727c69e4c0cfb2ae2e730d5961e22471996afb", "filename": "src/test/ui/lint/test-inner-fn.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3dab33225a8c74dcf1f6a4f6161a10b60d5944e9/src%2Ftest%2Fui%2Flint%2Ftest-inner-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dab33225a8c74dcf1f6a4f6161a10b60d5944e9/src%2Ftest%2Fui%2Flint%2Ftest-inner-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Ftest-inner-fn.rs?ref=3dab33225a8c74dcf1f6a4f6161a10b60d5944e9", "patch": "@@ -8,19 +8,19 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// compile-flags: --test -D unnameable_test_functions\n+// compile-flags: --test -D unnameable_test_items\n \n #[test]\n fn foo() {\n-    #[test] //~ ERROR cannot test inner function [unnameable_test_functions]\n+    #[test] //~ ERROR cannot test inner items [unnameable_test_items]\n     fn bar() {}\n     bar();\n }\n \n mod x {\n     #[test]\n     fn foo() {\n-        #[test] //~ ERROR cannot test inner function [unnameable_test_functions]\n+        #[test] //~ ERROR cannot test inner items [unnameable_test_items]\n         fn bar() {}\n         bar();\n     }"}, {"sha": "182fb31a9aa3707853f01412cd25f618e00dc510", "filename": "src/test/ui/lint/test-inner-fn.stderr", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3dab33225a8c74dcf1f6a4f6161a10b60d5944e9/src%2Ftest%2Fui%2Flint%2Ftest-inner-fn.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3dab33225a8c74dcf1f6a4f6161a10b60d5944e9/src%2Ftest%2Fui%2Flint%2Ftest-inner-fn.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Ftest-inner-fn.stderr?ref=3dab33225a8c74dcf1f6a4f6161a10b60d5944e9", "patch": "@@ -1,15 +1,15 @@\n-error: cannot test inner function\n+error: cannot test inner items\n   --> $DIR/test-inner-fn.rs:15:5\n    |\n-LL |     #[test] //~ ERROR cannot test inner function [unnameable_test_functions]\n+LL |     #[test] //~ ERROR cannot test inner items [unnameable_test_items]\n    |     ^^^^^^^\n    |\n-   = note: requested on the command line with `-D unnameable-test-functions`\n+   = note: requested on the command line with `-D unnameable-test-items`\n \n-error: cannot test inner function\n+error: cannot test inner items\n   --> $DIR/test-inner-fn.rs:23:9\n    |\n-LL |         #[test] //~ ERROR cannot test inner function [unnameable_test_functions]\n+LL |         #[test] //~ ERROR cannot test inner items [unnameable_test_items]\n    |         ^^^^^^^\n \n error: aborting due to 2 previous errors"}, {"sha": "0e95c053ce4cfa46c7d57139380f061c21000643", "filename": "src/test/ui/rfc-1937-termination-trait/termination-trait-test-wrong-type.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3dab33225a8c74dcf1f6a4f6161a10b60d5944e9/src%2Ftest%2Fui%2Frfc-1937-termination-trait%2Ftermination-trait-test-wrong-type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3dab33225a8c74dcf1f6a4f6161a10b60d5944e9/src%2Ftest%2Fui%2Frfc-1937-termination-trait%2Ftermination-trait-test-wrong-type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-1937-termination-trait%2Ftermination-trait-test-wrong-type.stderr?ref=3dab33225a8c74dcf1f6a4f6161a10b60d5944e9", "patch": "@@ -7,7 +7,7 @@ LL | | }\n    | |_^ `main` can only return types that implement `std::process::Termination`\n    |\n    = help: the trait `std::process::Termination` is not implemented for `std::result::Result<f32, std::num::ParseIntError>`\n-   = note: required by `__test::test::assert_test_result`\n+   = note: required by `test::assert_test_result`\n \n error: aborting due to previous error\n "}, {"sha": "a153e63443406ba6392dd07b9233bac1acbc1d68", "filename": "src/test/ui/test-on-macro.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/3dab33225a8c74dcf1f6a4f6161a10b60d5944e9/src%2Ftest%2Fui%2Ftest-on-macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dab33225a8c74dcf1f6a4f6161a10b60d5944e9/src%2Ftest%2Fui%2Ftest-on-macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftest-on-macro.rs?ref=3dab33225a8c74dcf1f6a4f6161a10b60d5944e9", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-pass\n+// compile-flags:--test\n+\n+#![deny(warnings)]\n+\n+macro_rules! foo {\n+    () => (fn foo(){})\n+}\n+\n+#[test]\n+foo!();\n+\n+fn main(){}"}, {"sha": "a45bb25255efadeffee1b8df63a7aa748797d12e", "filename": "src/test/ui/test-on-macro.stderr", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3dab33225a8c74dcf1f6a4f6161a10b60d5944e9/src%2Ftest%2Fui%2Ftest-on-macro.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3dab33225a8c74dcf1f6a4f6161a10b60d5944e9/src%2Ftest%2Fui%2Ftest-on-macro.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftest-on-macro.stderr?ref=3dab33225a8c74dcf1f6a4f6161a10b60d5944e9", "patch": "@@ -0,0 +1,6 @@\n+warning: #[test] attribute should not be used on macros. Use #[cfg(test)] instead.\n+  --> $DIR/test-on-macro.rs:21:1\n+   |\n+LL | foo!();\n+   | ^^^^^^^\n+"}, {"sha": "2e9d2dcc4100c8b6b8663203dbdf3ebb653369e3", "filename": "src/test/ui/test-shadowing/auxiliary/test_macro.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3dab33225a8c74dcf1f6a4f6161a10b60d5944e9/src%2Ftest%2Fui%2Ftest-shadowing%2Fauxiliary%2Ftest_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dab33225a8c74dcf1f6a4f6161a10b60d5944e9/src%2Ftest%2Fui%2Ftest-shadowing%2Fauxiliary%2Ftest_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftest-shadowing%2Fauxiliary%2Ftest_macro.rs?ref=3dab33225a8c74dcf1f6a4f6161a10b60d5944e9", "patch": "@@ -0,0 +1,14 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#[macro_export]\n+macro_rules! test {\n+    () => {};\n+}"}, {"sha": "4b1a437818f872201dbda368a48a418c0a38b0ef", "filename": "src/test/ui/test-shadowing/test-cant-be-shadowed.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/3dab33225a8c74dcf1f6a4f6161a10b60d5944e9/src%2Ftest%2Fui%2Ftest-shadowing%2Ftest-cant-be-shadowed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dab33225a8c74dcf1f6a4f6161a10b60d5944e9/src%2Ftest%2Fui%2Ftest-shadowing%2Ftest-cant-be-shadowed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftest-shadowing%2Ftest-cant-be-shadowed.rs?ref=3dab33225a8c74dcf1f6a4f6161a10b60d5944e9", "patch": "@@ -0,0 +1,18 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-pass\n+// aux-build:test_macro.rs\n+// compile-flags:--test\n+\n+#[macro_use] extern crate test_macro;\n+\n+#[test]\n+fn foo(){}"}, {"sha": "d0fc1788123de9844c8088b977cd142021cea1f2", "filename": "src/tools/clang", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclang?ref=3dab33225a8c74dcf1f6a4f6161a10b60d5944e9", "patch": "@@ -1 +1 @@\n-Subproject commit 2a284a70e26997273c296afe06586ffdf3a142fd\n+Subproject commit d0fc1788123de9844c8088b977cd142021cea1f2"}, {"sha": "7728fa22bebea288abfea3b70cf795c60b93df3a", "filename": "src/tools/lldb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Flldb?ref=3dab33225a8c74dcf1f6a4f6161a10b60d5944e9", "patch": "@@ -1 +1 @@\n-Subproject commit 3dbe998969d457c5cef245f61b48bdaed0f5c059\n+Subproject commit 7728fa22bebea288abfea3b70cf795c60b93df3a"}]}