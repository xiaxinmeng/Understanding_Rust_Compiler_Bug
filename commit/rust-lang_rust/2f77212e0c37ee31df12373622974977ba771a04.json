{"sha": "2f77212e0c37ee31df12373622974977ba771a04", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJmNzcyMTJlMGMzN2VlMzFkZjEyMzczNjIyOTc0OTc3YmE3NzFhMDQ=", "commit": {"author": {"name": "Cameron Zwarich", "email": "zwarich@mozilla.com", "date": "2014-06-16T22:40:20Z"}, "committer": {"name": "Cameron Zwarich", "email": "zwarich@mozilla.com", "date": "2014-06-16T22:40:20Z"}, "message": "Remove comments that no longer apply after the removal of `const`", "tree": {"sha": "ea02a267650e8728c16a9f90420ac9256e467263", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ea02a267650e8728c16a9f90420ac9256e467263"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2f77212e0c37ee31df12373622974977ba771a04", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2f77212e0c37ee31df12373622974977ba771a04", "html_url": "https://github.com/rust-lang/rust/commit/2f77212e0c37ee31df12373622974977ba771a04", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2f77212e0c37ee31df12373622974977ba771a04/comments", "author": null, "committer": null, "parents": [{"sha": "8a5c5b6081ee041145024176c668cb19e39a01d4", "url": "https://api.github.com/repos/rust-lang/rust/commits/8a5c5b6081ee041145024176c668cb19e39a01d4", "html_url": "https://github.com/rust-lang/rust/commit/8a5c5b6081ee041145024176c668cb19e39a01d4"}], "stats": {"total": 42, "additions": 4, "deletions": 38}, "files": [{"sha": "077bb99e21b65281c958fc2adc754f3269c27db3", "filename": "src/librustc/middle/borrowck/check_loans.rs", "status": "modified", "additions": 4, "deletions": 38, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/2f77212e0c37ee31df12373622974977ba771a04/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f77212e0c37ee31df12373622974977ba771a04/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs?ref=2f77212e0c37ee31df12373622974977ba771a04", "patch": "@@ -829,28 +829,8 @@ impl<'a> CheckLoanCtxt<'a> {\n             //    let p = &v;\n             //    v = ~[4];\n             //\n-            // In this case, creating `p` triggers a RESTR_MUTATE\n-            // restriction on the path `v`.\n-            //\n-            // Here is a second, more subtle example:\n-            //\n-            //    let mut v = ~[1, 2, 3];\n-            //    let p = &const v[0];\n-            //    v[0] = 4;                   // OK\n-            //    v[1] = 5;                   // OK\n-            //    v = ~[4, 5, 3];             // Error\n-            //\n-            // In this case, `p` is pointing to `v[0]`, and it is a\n-            // `const` pointer in any case. So the first two\n-            // assignments are legal (and would be permitted by this\n-            // check). However, the final assignment (which is\n-            // logically equivalent) is forbidden, because it would\n-            // cause the existing `v` array to be freed, thus\n-            // invalidating `p`. In the code, this error results\n-            // because `gather_loans::restrictions` adds a\n-            // `RESTR_MUTATE` restriction whenever the contents of an\n-            // owned pointer are borrowed, and hence while `v[*]` is not\n-            // restricted from being written, `v` is.\n+            // In this case, creating `p` restricts the mutation of `v`.\n+\n             let cont = this.each_in_scope_restriction(assignment_id,\n                                                       &*loan_path,\n                                                       |loan, restr| {\n@@ -882,28 +862,14 @@ impl<'a> CheckLoanCtxt<'a> {\n             //\n             // So in this loop, we walk back up the loan path so long\n             // as the mutability of the path is dependent on a super\n-            // path, and check that the super path was not lent out as\n-            // mutable or immutable (a const loan is ok).\n+            // path, and check that the super path was not borrowed.\n             //\n             // Mutability of a path can be dependent on the super path\n             // in two ways. First, it might be inherited mutability.\n             // Second, the pointee of an `&mut` pointer can only be\n             // mutated if it is found in an unaliased location, so we\n             // have to check that the owner location is not borrowed.\n-            //\n-            // Note that we are *not* checking for any and all\n-            // restrictions.  We are only interested in the pointers\n-            // that the user created, whereas we add restrictions for\n-            // all kinds of paths that are not directly aliased. If we checked\n-            // for all restrictions, and not just loans, then the following\n-            // valid program would be considered illegal:\n-            //\n-            //    let mut v = ~[1, 2, 3];\n-            //    let p = &const v[0];\n-            //    v[1] = 5; // ok\n-            //\n-            // Here the restriction that `v` not be mutated would be misapplied\n-            // to block the subpath `v[1]`.\n+\n             let full_loan_path = loan_path.clone();\n             let mut loan_path = loan_path;\n             loop {"}]}