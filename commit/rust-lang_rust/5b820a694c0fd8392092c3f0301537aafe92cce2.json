{"sha": "5b820a694c0fd8392092c3f0301537aafe92cce2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjViODIwYTY5NGMwZmQ4MzkyMDkyYzNmMDMwMTUzN2FhZmU5MmNjZTI=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2018-05-13T15:35:57Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2018-05-15T20:24:17Z"}, "message": "Address feedback, remove remaining review comments, add some more docs", "tree": {"sha": "aa446392b10425e74f80330c1f3edfd5a8343a3d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/aa446392b10425e74f80330c1f3edfd5a8343a3d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5b820a694c0fd8392092c3f0301537aafe92cce2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5b820a694c0fd8392092c3f0301537aafe92cce2", "html_url": "https://github.com/rust-lang/rust/commit/5b820a694c0fd8392092c3f0301537aafe92cce2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5b820a694c0fd8392092c3f0301537aafe92cce2/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "780616ed74d22d96cb7464c2d558244bd665e39a", "url": "https://api.github.com/repos/rust-lang/rust/commits/780616ed74d22d96cb7464c2d558244bd665e39a", "html_url": "https://github.com/rust-lang/rust/commit/780616ed74d22d96cb7464c2d558244bd665e39a"}], "stats": {"total": 83, "additions": 30, "deletions": 53}, "files": [{"sha": "bf99a14a4549ab6d1f967335737f15193ca3e804", "filename": "src/libproc_macro/lib.rs", "status": "modified", "additions": 29, "deletions": 52, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/5b820a694c0fd8392092c3f0301537aafe92cce2/src%2Flibproc_macro%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b820a694c0fd8392092c3f0301537aafe92cce2/src%2Flibproc_macro%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2Flib.rs?ref=5b820a694c0fd8392092c3f0301537aafe92cce2", "patch": "@@ -11,13 +11,11 @@\n //! A support library for macro authors when defining new macros.\n //!\n //! This library, provided by the standard distribution, provides the types\n-//! consumed in the interfaces of procedurally defined macro definitions.\n-//! Currently the primary use of this crate is to provide the ability to define\n-//! new custom derive modes through `#[proc_macro_derive]`.\n+//! consumed in the interfaces of procedurally defined macro definitions such as\n+//! function-like macros `#[proc_macro]`, macro attribures `#[proc_macro_attribute]` and\n+//! custom derive attributes`#[proc_macro_derive]`.\n //!\n-//! Note that this crate is intentionally very bare-bones currently. The main\n-//! type, `TokenStream`, only supports `fmt::Display` and `FromStr`\n-//! implementations, indicating that it can only go to and come from a string.\n+//! Note that this crate is intentionally bare-bones currently.\n //! This functionality is intended to be expanded over time as more surface\n //! area for macro authors is stabilized.\n //!\n@@ -110,8 +108,8 @@ impl TokenStream {\n /// May fail for a number of reasons, for example, if the string contains unbalanced delimiters\n /// or characters not existing in the language.\n ///\n-/// REVIEW The function actually panics on any error and never returns `LexError`.\n-/// REVIEW Should the panics be documented?\n+/// NOTE: Some errors may cause panics instead of returning `LexError`. We reserve the right to\n+/// change these errors into `LexError`s later.\n #[stable(feature = \"proc_macro_lib\", since = \"1.15.0\")]\n impl FromStr for TokenStream {\n     type Err = LexError;\n@@ -132,9 +130,9 @@ impl FromStr for TokenStream {\n     }\n }\n \n-/// Prints the token stream as a string that should be losslessly convertible back\n+/// Prints the token stream as a string that is supposed to be losslessly convertible back\n /// into the same token stream (modulo spans), except for possibly `TokenTree::Group`s\n-/// with `Delimiter::None` delimiters.\n+/// with `Delimiter::None` delimiters and negative numeric literals.\n #[stable(feature = \"proc_macro_lib\", since = \"1.15.0\")]\n impl fmt::Display for TokenStream {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n@@ -152,9 +150,6 @@ impl fmt::Debug for TokenStream {\n }\n \n /// Creates a token stream containing a single token tree.\n-///\n-/// REVIEW We don't generally have impls `From<T> for Collection<T>`, but I see why this exists\n-/// REVIEW from practical point of view.\n #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n impl From<TokenTree> for TokenStream {\n     fn from(tree: TokenTree) -> TokenStream {\n@@ -217,9 +212,6 @@ pub mod token_stream {\n                 // need to flattened during iteration over stream's token trees.\n                 // Eventually this needs to be removed in favor of keeping original token trees\n                 // and not doing the roundtrip through AST.\n-                //\n-                // REVIEW This may actually be observable if we can create a dummy span via\n-                // proc macro API, but it looks like we can't do it with 1.2 yet.\n                 if tree.span().0 == DUMMY_SP {\n                     if let TokenTree::Group(ref group) = tree {\n                         if group.delimiter() == Delimiter::None {\n@@ -246,7 +238,7 @@ pub mod token_stream {\n \n /// `quote!(..)` accepts arbitrary tokens and expands into a `TokenStream` describing the input.\n /// For example, `quote!(a + b)` will produce a expression, that, when evaluated, constructs\n-/// the `TokenStream` `[Word(\"a\"), Punct('+', Alone), Word(\"b\")]`.\n+/// the `TokenStream` `[Ident(\"a\"), Punct('+', Alone), Ident(\"b\")]`.\n ///\n /// Unquoting is done with `$`, and works by taking the single next ident as the unquoted term.\n /// To quote `$` itself, use `$$`.\n@@ -266,9 +258,6 @@ pub fn quote_span(span: Span) -> TokenStream {\n }\n \n /// A region of source code, along with macro expansion information.\n-///\n-/// REVIEW ATTENTION: `Copy` impl on a struct with private fields.\n-/// REVIEW Do we want to guarantee `Span` to be `Copy`? Yes.\n #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n #[derive(Copy, Clone)]\n pub struct Span(syntax_pos::Span);\n@@ -555,10 +544,6 @@ impl fmt::Debug for TokenTree {\n     }\n }\n \n-/// REVIEW the impls below are kind of `From<T> for Option<T>`, not strictly necessary,\n-/// REVIEW but convenient. No harm, I guess. I'd actually like to see impls\n-/// REVIEW `From<Group/Ident/Punct/Literal> for TokenStream` to avoid stuttering like\n-/// REVIEW `TokenTree::Literal(Literal::string(\"lalala\")).into()`.\n #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n impl From<Group> for TokenTree {\n     fn from(g: Group) -> TokenTree {\n@@ -587,9 +572,9 @@ impl From<Literal> for TokenTree {\n     }\n }\n \n-/// Prints the token tree as a string that should be losslessly convertible back\n+/// Prints the token tree as a string that is supposed to be losslessly convertible back\n /// into the same token tree (modulo spans), except for possibly `TokenTree::Group`s\n-/// with `Delimiter::None` delimiters.\n+/// with `Delimiter::None` delimiters and negative numeric literals.\n #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n impl fmt::Display for TokenTree {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n@@ -699,14 +684,9 @@ impl fmt::Display for Group {\n ///\n /// Multicharacter operators like `+=` are represented as two instances of `Punct` with different\n /// forms of `Spacing` returned.\n-///\n-/// REVIEW ATTENTION: `Copy` impl on a struct with private fields.\n-/// REVIEW Do we want to guarantee `Punct` to be `Copy`?\n #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n-#[derive(Copy, Clone, Debug)]\n+#[derive(Clone, Debug)]\n pub struct Punct {\n-    // REVIEW(INTERNAL) `Punct` can avoid using `char` internally and\n-    // REVIEW(INTERNAL) can keep u8 or an u8-like enum.\n     ch: char,\n     spacing: Spacing,\n     span: Span,\n@@ -735,9 +715,6 @@ impl Punct {\n     ///\n     /// The returned `Punct` will have the default span of `Span::call_site()`\n     /// which can be further configured with the `set_span` method below.\n-    ///\n-    /// REVIEW Why we even use `char` here? There's no reason to use unicode here.\n-    /// REVIEW I guess because it's more convenient to write `new('+')` than `new(b'+')`, that's ok.\n     #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n     pub fn new(ch: char, spacing: Spacing) -> Punct {\n         const LEGAL_CHARS: &[char] = &['=', '<', '>', '!', '~', '+', '-', '*', '/', '%',\n@@ -753,10 +730,6 @@ impl Punct {\n     }\n \n     /// Returns the value of this punctuation character as `char`.\n-    ///\n-    /// REVIEW Again, there's no need for unicode here,\n-    /// REVIEW except for maybe future compatibility in case Rust turns into APL,\n-    /// REVIEW but if it's more convenient to use `char` then that's okay.\n     #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n     pub fn as_char(&self) -> char {\n         self.ch\n@@ -794,13 +767,9 @@ impl fmt::Display for Punct {\n }\n \n /// An identifier (`ident`) or lifetime identifier (`'ident`).\n-///\n-/// REVIEW ATTENTION: `Copy` impl on a struct with private fields.\n-/// REVIEW Do we want to guarantee `Ident` to be `Copy`?\n-#[derive(Copy, Clone, Debug)]\n+#[derive(Clone, Debug)]\n #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n pub struct Ident {\n-    // REVIEW(INTERNAL) Symbol + Span is actually `ast::Ident`! We can use it here.\n     sym: Symbol,\n     span: Span,\n     is_raw: bool,\n@@ -856,13 +825,6 @@ impl Ident {\n         ident\n     }\n \n-    // FIXME: Remove this, do not stabilize\n-    /// Get a reference to the interned string.\n-    #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n-    pub fn as_str(&self) -> &str {\n-        unsafe { &*(&*self.sym.as_str() as *const str) }\n-    }\n-\n     /// Returns the span of this `Ident`, encompassing the entire string returned\n     /// by `as_str`.\n     #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n@@ -882,6 +844,9 @@ impl Ident {\n #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n impl fmt::Display for Ident {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        if self.is_raw {\n+            f.write_str(\"r#\")?;\n+        }\n         self.sym.as_str().fmt(f)\n     }\n }\n@@ -910,6 +875,8 @@ macro_rules! suffixed_int_literals {\n         /// This function will create an integer like `1u32` where the integer\n         /// value specified is the first part of the token and the integral is\n         /// also suffixed at the end.\n+        /// Literals created from negative numbers may not survive rountrips through\n+        /// `TokenStream` or strings and may be broken into two tokens (`-` and positive literal).\n         ///\n         /// Literals created through this method have the `Span::call_site()`\n         /// span by default, which can be configured with the `set_span` method\n@@ -934,6 +901,8 @@ macro_rules! unsuffixed_int_literals {\n         /// specified on this token, meaning that invocations like\n         /// `Literal::i8_unsuffixed(1)` are equivalent to\n         /// `Literal::u32_unsuffixed(1)`.\n+        /// Literals created from negative numbers may not survive rountrips through\n+        /// `TokenStream` or strings and may be broken into two tokens (`-` and positive literal).\n         ///\n         /// Literals created through this method have the `Span::call_site()`\n         /// span by default, which can be configured with the `set_span` method\n@@ -985,6 +954,8 @@ impl Literal {\n     /// This constructor is similar to those like `Literal::i8_unsuffixed` where\n     /// the float's value is emitted directly into the token but no suffix is\n     /// used, so it may be inferred to be a `f64` later in the compiler.\n+    /// Literals created from negative numbers may not survive rountrips through\n+    /// `TokenStream` or strings and may be broken into two tokens (`-` and positive literal).\n     ///\n     /// # Panics\n     ///\n@@ -1008,6 +979,8 @@ impl Literal {\n     /// specified is the preceding part of the token and `f32` is the suffix of\n     /// the token. This token will always be inferred to be an `f32` in the\n     /// compiler.\n+    /// Literals created from negative numbers may not survive rountrips through\n+    /// `TokenStream` or strings and may be broken into two tokens (`-` and positive literal).\n     ///\n     /// # Panics\n     ///\n@@ -1030,6 +1003,8 @@ impl Literal {\n     /// This constructor is similar to those like `Literal::i8_unsuffixed` where\n     /// the float's value is emitted directly into the token but no suffix is\n     /// used, so it may be inferred to be a `f64` later in the compiler.\n+    /// Literals created from negative numbers may not survive rountrips through\n+    /// `TokenStream` or strings and may be broken into two tokens (`-` and positive literal).\n     ///\n     /// # Panics\n     ///\n@@ -1053,6 +1028,8 @@ impl Literal {\n     /// specified is the preceding part of the token and `f64` is the suffix of\n     /// the token. This token will always be inferred to be an `f64` in the\n     /// compiler.\n+    /// Literals created from negative numbers may not survive rountrips through\n+    /// `TokenStream` or strings and may be broken into two tokens (`-` and positive literal).\n     ///\n     /// # Panics\n     ///\n@@ -1347,7 +1324,7 @@ impl TokenTree {\n             '#' => Pound,\n             '$' => Dollar,\n             '?' => Question,\n-            _ => panic!(\"unsupported character {}\", ch),\n+            _ => unreachable!(),\n         };\n \n         let tree = TokenTree::Token(span.0, token);"}, {"sha": "390d4bc08682509e9352d442bceec6b7f66db4d8", "filename": "src/libproc_macro/quote.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5b820a694c0fd8392092c3f0301537aafe92cce2/src%2Flibproc_macro%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b820a694c0fd8392092c3f0301537aafe92cce2/src%2Flibproc_macro%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2Fquote.rs?ref=5b820a694c0fd8392092c3f0301537aafe92cce2", "patch": "@@ -118,7 +118,7 @@ impl Quote for TokenStream {\n                     TokenTree::Punct(ref tt) if tt.as_char() == '$' => {}\n                     _ => panic!(\"`$` must be followed by an ident or `$` in `quote!`\"),\n                 }\n-            } else if let TokenTree::Punct(tt) = tree {\n+            } else if let TokenTree::Punct(ref tt) = tree {\n                 if tt.as_char() == '$' {\n                     after_dollar = true;\n                     return None;"}]}