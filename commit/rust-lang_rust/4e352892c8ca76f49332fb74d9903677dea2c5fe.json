{"sha": "4e352892c8ca76f49332fb74d9903677dea2c5fe", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRlMzUyODkyYzhjYTc2ZjQ5MzMyZmI3NGQ5OTAzNjc3ZGVhMmM1ZmU=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2014-10-29T22:03:40Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2014-11-06T11:48:23Z"}, "message": "Restructure parsing of paths, which is quite tortured", "tree": {"sha": "f8fef03732b8ed6c40fb031b72d8581cfcd10f96", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f8fef03732b8ed6c40fb031b72d8581cfcd10f96"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4e352892c8ca76f49332fb74d9903677dea2c5fe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4e352892c8ca76f49332fb74d9903677dea2c5fe", "html_url": "https://github.com/rust-lang/rust/commit/4e352892c8ca76f49332fb74d9903677dea2c5fe", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4e352892c8ca76f49332fb74d9903677dea2c5fe/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e84e7a00ddec76570bbaa9afea385d544f616814", "url": "https://api.github.com/repos/rust-lang/rust/commits/e84e7a00ddec76570bbaa9afea385d544f616814", "html_url": "https://github.com/rust-lang/rust/commit/e84e7a00ddec76570bbaa9afea385d544f616814"}], "stats": {"total": 150, "additions": 108, "deletions": 42}, "files": [{"sha": "fd244a443a8a009e258c4e014d65ae6498f8c2f0", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 108, "deletions": 42, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/4e352892c8ca76f49332fb74d9903677dea2c5fe/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e352892c8ca76f49332fb74d9903677dea2c5fe/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=4e352892c8ca76f49332fb74d9903677dea2c5fe", "patch": "@@ -1706,50 +1706,18 @@ impl<'a> Parser<'a> {\n         // Parse any number of segments and bound sets. A segment is an\n         // identifier followed by an optional lifetime and a set of types.\n         // A bound set is a set of type parameter bounds.\n-        let mut segments = Vec::new();\n-        loop {\n-            // First, parse an identifier.\n-            let identifier = self.parse_ident();\n-\n-            // Parse the '::' before type parameters if it's required. If\n-            // it is required and wasn't present, then we're done.\n-            if mode == LifetimeAndTypesWithColons &&\n-                    !self.eat(&token::ModSep) {\n-                segments.push(ast::PathSegment {\n-                    identifier: identifier,\n-                    lifetimes: Vec::new(),\n-                    types: OwnedSlice::empty(),\n-                });\n-                break\n+        let segments = match mode {\n+            LifetimeAndTypesWithoutColons |\n+            LifetimeAndTypesAndBounds => {\n+                self.parse_path_segments_without_colons()\n             }\n-\n-            // Parse the `<` before the lifetime and types, if applicable.\n-            let (any_lifetime_or_types, lifetimes, types) = {\n-                if mode != NoTypesAllowed && self.eat_lt(false) {\n-                    let (lifetimes, types) =\n-                        self.parse_generic_values_after_lt();\n-                    (true, lifetimes, OwnedSlice::from_vec(types))\n-                } else {\n-                    (false, Vec::new(), OwnedSlice::empty())\n-                }\n-            };\n-\n-            // Assemble and push the result.\n-            segments.push(ast::PathSegment {\n-                identifier: identifier,\n-                lifetimes: lifetimes,\n-                types: types,\n-            });\n-\n-            // We're done if we don't see a '::', unless the mode required\n-            // a double colon to get here in the first place.\n-            if !(mode == LifetimeAndTypesWithColons &&\n-                    !any_lifetime_or_types) {\n-                if !self.eat(&token::ModSep) {\n-                    break\n-                }\n+            LifetimeAndTypesWithColons => {\n+                self.parse_path_segments_with_colons()\n             }\n-        }\n+            NoTypesAllowed => {\n+                self.parse_path_segments_without_types()\n+            }\n+        };\n \n         // Next, parse a plus and bounded type parameters, if\n         // applicable. We need to remember whether the separate was\n@@ -1792,6 +1760,104 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n+    /// Examples:\n+    /// - `a::b<T,U>::c<V,W>`\n+    /// - `a::b<T,U>::c(V) -> W`\n+    /// - `a::b<T,U>::c(V)`\n+    pub fn parse_path_segments_without_colons(&mut self) -> Vec<ast::PathSegment> {\n+        let mut segments = Vec::new();\n+        loop {\n+            // First, parse an identifier.\n+            let identifier = self.parse_ident();\n+\n+            // Parse types, optionally.\n+            let (lifetimes, types) = if self.eat_lt(false) {\n+                self.parse_generic_values_after_lt()\n+            } else if false && self.eat(&token::LParen) {\n+                let mut types = self.parse_seq_to_end(\n+                    &token::RParen,\n+                    seq_sep_trailing_allowed(token::Comma),\n+                    |p| p.parse_ty(true));\n+\n+                if self.eat(&token::RArrow) {\n+                    types.push(self.parse_ty(true))\n+                }\n+\n+                (Vec::new(), types)\n+            } else {\n+                (Vec::new(), Vec::new())\n+            };\n+\n+            // Assemble and push the result.\n+            segments.push(ast::PathSegment { identifier: identifier,\n+                                             lifetimes: lifetimes,\n+                                             types: OwnedSlice::from_vec(types), });\n+\n+            // Continue only if we see a `::`\n+            if !self.eat(&token::ModSep) {\n+                return segments;\n+            }\n+        }\n+    }\n+\n+    /// Examples:\n+    /// - `a::b::<T,U>::c`\n+    pub fn parse_path_segments_with_colons(&mut self) -> Vec<ast::PathSegment> {\n+        let mut segments = Vec::new();\n+        loop {\n+            // First, parse an identifier.\n+            let identifier = self.parse_ident();\n+\n+            // If we do not see a `::`, stop.\n+            if !self.eat(&token::ModSep) {\n+                segments.push(ast::PathSegment { identifier: identifier,\n+                                                 lifetimes: Vec::new(),\n+                                                 types: OwnedSlice::empty() });\n+                return segments;\n+            }\n+\n+            // Check for a type segment.\n+            if self.eat_lt(false) {\n+                // Consumed `a::b::<`, go look for types\n+                let (lifetimes, types) = self.parse_generic_values_after_lt();\n+                segments.push(ast::PathSegment { identifier: identifier,\n+                                                 lifetimes: lifetimes,\n+                                                 types: OwnedSlice::from_vec(types) });\n+\n+                // Consumed `a::b::<T,U>`, check for `::` before proceeding\n+                if !self.eat(&token::ModSep) {\n+                    return segments;\n+                }\n+            } else {\n+                // Consumed `a::`, go look for `b`\n+                segments.push(ast::PathSegment { identifier: identifier,\n+                                                 lifetimes: Vec::new(),\n+                                                 types: OwnedSlice::empty() });\n+            }\n+        }\n+    }\n+\n+\n+    /// Examples:\n+    /// - `a::b::c`\n+    pub fn parse_path_segments_without_types(&mut self) -> Vec<ast::PathSegment> {\n+        let mut segments = Vec::new();\n+        loop {\n+            // First, parse an identifier.\n+            let identifier = self.parse_ident();\n+\n+            // Assemble and push the result.\n+            segments.push(ast::PathSegment { identifier: identifier,\n+                                             lifetimes: Vec::new(),\n+                                             types: OwnedSlice::empty(), });\n+\n+            // If we do not see a `::`, stop.\n+            if !self.eat(&token::ModSep) {\n+                return segments;\n+            }\n+        }\n+    }\n+\n     /// parses 0 or 1 lifetime\n     pub fn parse_opt_lifetime(&mut self) -> Option<ast::Lifetime> {\n         match self.token {"}]}