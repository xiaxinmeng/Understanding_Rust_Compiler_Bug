{"sha": "0e95c3434b848da6fd7b8cd0ff27bec5d51db01c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBlOTVjMzQzNGI4NDhkYTZmZDdiOGNkMGZmMjdiZWM1ZDUxZGIwMWM=", "commit": {"author": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2013-09-24T12:34:51Z"}, "committer": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2013-09-24T12:34:51Z"}, "message": "Part of #7081: Fold remainder of typeck's visit env into their visitor structs.", "tree": {"sha": "c32c21a8d264ca304113e2632ee2eb4aa168533f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c32c21a8d264ca304113e2632ee2eb4aa168533f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0e95c3434b848da6fd7b8cd0ff27bec5d51db01c", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0e95c3434b848da6fd7b8cd0ff27bec5d51db01c", "html_url": "https://github.com/rust-lang/rust/commit/0e95c3434b848da6fd7b8cd0ff27bec5d51db01c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0e95c3434b848da6fd7b8cd0ff27bec5d51db01c/comments", "author": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4f691cd5bc83311da1b91b6e5da54e5514440749", "url": "https://api.github.com/repos/rust-lang/rust/commits/4f691cd5bc83311da1b91b6e5da54e5514440749", "html_url": "https://github.com/rust-lang/rust/commit/4f691cd5bc83311da1b91b6e5da54e5514440749"}], "stats": {"total": 212, "additions": 101, "deletions": 111}, "files": [{"sha": "606b0255cd705b089c9ea64d92711509f45acc60", "filename": "src/librustc/middle/typeck/check/_match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0e95c3434b848da6fd7b8cd0ff27bec5d51db01c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e95c3434b848da6fd7b8cd0ff27bec5d51db01c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs?ref=0e95c3434b848da6fd7b8cd0ff27bec5d51db01c", "patch": "@@ -37,12 +37,12 @@ pub fn check_match(fcx: @mut FnCtxt,\n     // Typecheck the patterns first, so that we get types for all the\n     // bindings.\n     for arm in arms.iter() {\n-        let pcx = pat_ctxt {\n+        let mut pcx = pat_ctxt {\n             fcx: fcx,\n             map: pat_id_map(tcx.def_map, arm.pats[0]),\n         };\n \n-        for p in arm.pats.iter() { check_pat(&pcx, *p, discrim_ty);}\n+        for p in arm.pats.iter() { check_pat(&mut pcx, *p, discrim_ty);}\n     }\n \n     // The result of the match is the common supertype of all the"}, {"sha": "78c20b54845471aa15692266040e55b84c5f2ed1", "filename": "src/librustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 62, "deletions": 68, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/0e95c3434b848da6fd7b8cd0ff27bec5d51db01c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e95c3434b848da6fd7b8cd0ff27bec5d51db01c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=0e95c3434b848da6fd7b8cd0ff27bec5d51db01c", "patch": "@@ -122,12 +122,13 @@ impl Rcx {\n     }\n \n     /// Try to resolve the type for the given node.\n-    pub fn resolve_node_type(@mut self, id: ast::NodeId) -> ty::t {\n-        self.resolve_type(self.fcx.node_ty(id))\n+    pub fn resolve_node_type(&mut self, id: ast::NodeId) -> ty::t {\n+        let t = self.fcx.node_ty(id);\n+        self.resolve_type(t)\n     }\n \n     /// Try to resolve the type for the given node.\n-    pub fn resolve_expr_type_adjusted(@mut self, expr: @ast::Expr) -> ty::t {\n+    pub fn resolve_expr_type_adjusted(&mut self, expr: @ast::Expr) -> ty::t {\n         let ty_unadjusted = self.resolve_node_type(expr.id);\n         if ty::type_is_error(ty_unadjusted) || ty::type_is_bot(ty_unadjusted) {\n             ty_unadjusted\n@@ -141,30 +142,28 @@ impl Rcx {\n }\n \n pub fn regionck_expr(fcx: @mut FnCtxt, e: @ast::Expr) {\n-    let rcx = @mut Rcx { fcx: fcx, errors_reported: 0,\n+    let mut rcx = Rcx { fcx: fcx, errors_reported: 0,\n                          repeating_scope: e.id };\n+    let rcx = &mut rcx;\n     if fcx.err_count_since_creation() == 0 {\n         // regionck assumes typeck succeeded\n-        let mut v = regionck_visitor();\n-        v.visit_expr(e, rcx);\n+        rcx.visit_expr(e, ());\n     }\n     fcx.infcx().resolve_regions();\n }\n \n pub fn regionck_fn(fcx: @mut FnCtxt, blk: &ast::Block) {\n-    let rcx = @mut Rcx { fcx: fcx, errors_reported: 0,\n+    let mut rcx = Rcx { fcx: fcx, errors_reported: 0,\n                          repeating_scope: blk.id };\n+    let rcx = &mut rcx;\n     if fcx.err_count_since_creation() == 0 {\n         // regionck assumes typeck succeeded\n-        let mut v = regionck_visitor();\n-        v.visit_block(blk, rcx);\n+        rcx.visit_block(blk, ());\n     }\n     fcx.infcx().resolve_regions();\n }\n \n-struct RegionckVisitor;\n-\n-impl Visitor<@mut Rcx> for RegionckVisitor {\n+impl Visitor<()> for Rcx {\n     // (*) FIXME(#3238) should use visit_pat, not visit_arm/visit_local,\n     // However, right now we run into an issue whereby some free\n     // regions are not properly related if they appear within the\n@@ -173,48 +172,44 @@ impl Visitor<@mut Rcx> for RegionckVisitor {\n     // hierarchy, and in particular the relationships between free\n     // regions, until regionck, as described in #3238.\n \n-    fn visit_item(&mut self, i:@ast::item, e:@mut Rcx) { visit_item(self, i, e); }\n+    fn visit_item(&mut self, i:@ast::item, _:()) { visit_item(self, i); }\n \n-    fn visit_expr(&mut self, ex:@ast::Expr, e:@mut Rcx) { visit_expr(self, ex, e); }\n+    fn visit_expr(&mut self, ex:@ast::Expr, _:()) { visit_expr(self, ex); }\n \n         //visit_pat: visit_pat, // (*) see above\n \n-    fn visit_arm(&mut self, a:&ast::Arm, e:@mut Rcx) { visit_arm(self, a, e); }\n-\n-    fn visit_local(&mut self, l:@ast::Local, e:@mut Rcx) { visit_local(self, l, e); }\n+    fn visit_arm(&mut self, a:&ast::Arm, _:()) { visit_arm(self, a); }\n \n-    fn visit_block(&mut self, b:&ast::Block, e:@mut Rcx) { visit_block(self, b, e); }\n-}\n+    fn visit_local(&mut self, l:@ast::Local, _:()) { visit_local(self, l); }\n \n-fn regionck_visitor() -> RegionckVisitor {\n-    RegionckVisitor\n+    fn visit_block(&mut self, b:&ast::Block, _:()) { visit_block(self, b); }\n }\n \n-fn visit_item(_v: &mut RegionckVisitor, _item: @ast::item, _rcx: @mut Rcx) {\n+fn visit_item(_rcx: &mut Rcx, _item: @ast::item) {\n     // Ignore items\n }\n \n-fn visit_block(v: &mut RegionckVisitor, b: &ast::Block, rcx: @mut Rcx) {\n+fn visit_block(rcx: &mut Rcx, b: &ast::Block) {\n     rcx.fcx.tcx().region_maps.record_cleanup_scope(b.id);\n-    visit::walk_block(v, b, rcx);\n+    visit::walk_block(rcx, b, ());\n }\n \n-fn visit_arm(v: &mut RegionckVisitor, arm: &ast::Arm, rcx: @mut Rcx) {\n+fn visit_arm(rcx: &mut Rcx, arm: &ast::Arm) {\n     // see above\n     for &p in arm.pats.iter() {\n         constrain_bindings_in_pat(p, rcx);\n     }\n \n-    visit::walk_arm(v, arm, rcx);\n+    visit::walk_arm(rcx, arm, ());\n }\n \n-fn visit_local(v: &mut RegionckVisitor, l: @ast::Local, rcx: @mut Rcx) {\n+fn visit_local(rcx: &mut Rcx, l: @ast::Local) {\n     // see above\n     constrain_bindings_in_pat(l.pat, rcx);\n-    visit::walk_local(v, l, rcx);\n+    visit::walk_local(rcx, l, ());\n }\n \n-fn constrain_bindings_in_pat(pat: @ast::Pat, rcx: @mut Rcx) {\n+fn constrain_bindings_in_pat(pat: @ast::Pat, rcx: &mut Rcx) {\n     let tcx = rcx.fcx.tcx();\n     debug!(\"regionck::visit_pat(pat=%s)\", pat.repr(tcx));\n     do pat_util::pat_bindings(tcx.def_map, pat) |_, id, span, _| {\n@@ -248,7 +243,7 @@ fn constrain_bindings_in_pat(pat: @ast::Pat, rcx: @mut Rcx) {\n     }\n }\n \n-fn visit_expr(v: &mut RegionckVisitor, expr: @ast::Expr, rcx: @mut Rcx) {\n+fn visit_expr(rcx: &mut Rcx, expr: @ast::Expr) {\n     debug!(\"regionck::visit_expr(e=%s, repeating_scope=%?)\",\n            expr.repr(rcx.fcx.tcx()), rcx.repeating_scope);\n \n@@ -336,13 +331,13 @@ fn visit_expr(v: &mut RegionckVisitor, expr: @ast::Expr, rcx: @mut Rcx) {\n             constrain_callee(rcx, callee.id, expr, callee);\n             constrain_call(rcx, callee.id, expr, None, *args, false);\n \n-            visit::walk_expr(v, expr, rcx);\n+            visit::walk_expr(rcx, expr, ());\n         }\n \n         ast::ExprMethodCall(callee_id, arg0, _, _, ref args, _) => {\n             constrain_call(rcx, callee_id, expr, Some(arg0), *args, false);\n \n-            visit::walk_expr(v,expr, rcx);\n+            visit::walk_expr(rcx, expr, ());\n         }\n \n         ast::ExprIndex(callee_id, lhs, rhs) |\n@@ -354,30 +349,30 @@ fn visit_expr(v: &mut RegionckVisitor, expr: @ast::Expr, rcx: @mut Rcx) {\n             // should be converted to an adjustment!\n             constrain_call(rcx, callee_id, expr, Some(lhs), [rhs], true);\n \n-            visit::walk_expr(v, expr, rcx);\n+            visit::walk_expr(rcx, expr, ());\n         }\n \n         ast::ExprUnary(callee_id, _, lhs) if has_method_map => {\n             // As above.\n             constrain_call(rcx, callee_id, expr, Some(lhs), [], true);\n \n-            visit::walk_expr(v, expr, rcx);\n+            visit::walk_expr(rcx, expr, ());\n         }\n \n         ast::ExprUnary(_, ast::UnDeref, base) => {\n             // For *a, the lifetime of a must enclose the deref\n             let base_ty = rcx.resolve_node_type(base.id);\n             constrain_derefs(rcx, expr, 1, base_ty);\n \n-            visit::walk_expr(v, expr, rcx);\n+            visit::walk_expr(rcx, expr, ());\n         }\n \n         ast::ExprIndex(_, vec_expr, _) => {\n             // For a[b], the lifetime of a must enclose the deref\n             let vec_type = rcx.resolve_expr_type_adjusted(vec_expr);\n             constrain_index(rcx, expr, vec_type);\n \n-            visit::walk_expr(v, expr, rcx);\n+            visit::walk_expr(rcx, expr, ());\n         }\n \n         ast::ExprCast(source, _) => {\n@@ -407,7 +402,7 @@ fn visit_expr(v: &mut RegionckVisitor, expr: @ast::Expr, rcx: @mut Rcx) {\n                 _ => ()\n             }\n \n-            visit::walk_expr(v, expr, rcx);\n+            visit::walk_expr(rcx, expr, ());\n         }\n \n         ast::ExprAddrOf(_, base) => {\n@@ -423,44 +418,43 @@ fn visit_expr(v: &mut RegionckVisitor, expr: @ast::Expr, rcx: @mut Rcx) {\n             let ty0 = rcx.resolve_node_type(expr.id);\n             constrain_regions_in_type(rcx, ty::re_scope(expr.id),\n                                       infer::AddrOf(expr.span), ty0);\n-            visit::walk_expr(v, expr, rcx);\n+            visit::walk_expr(rcx, expr, ());\n         }\n \n         ast::ExprMatch(discr, ref arms) => {\n             guarantor::for_match(rcx, discr, *arms);\n \n-            visit::walk_expr(v, expr, rcx);\n+            visit::walk_expr(rcx, expr, ());\n         }\n \n         ast::ExprFnBlock(*) => {\n-            check_expr_fn_block(rcx, expr, v);\n+            check_expr_fn_block(rcx, expr);\n         }\n \n         ast::ExprLoop(ref body, _) => {\n             let repeating_scope = rcx.set_repeating_scope(body.id);\n-            visit::walk_expr(v, expr, rcx);\n+            visit::walk_expr(rcx, expr, ());\n             rcx.set_repeating_scope(repeating_scope);\n         }\n \n         ast::ExprWhile(cond, ref body) => {\n             let repeating_scope = rcx.set_repeating_scope(cond.id);\n-            v.visit_expr(cond, rcx);\n+            rcx.visit_expr(cond, ());\n \n             rcx.set_repeating_scope(body.id);\n-            v.visit_block(body, rcx);\n+            rcx.visit_block(body, ());\n \n             rcx.set_repeating_scope(repeating_scope);\n         }\n \n         _ => {\n-            visit::walk_expr(v, expr, rcx);\n+            visit::walk_expr(rcx, expr, ());\n         }\n     }\n }\n \n-fn check_expr_fn_block(rcx: @mut Rcx,\n-                       expr: @ast::Expr,\n-                       v: &mut RegionckVisitor) {\n+fn check_expr_fn_block(rcx: &mut Rcx,\n+                       expr: @ast::Expr) {\n     let tcx = rcx.fcx.tcx();\n     match expr.node {\n         ast::ExprFnBlock(_, ref body) => {\n@@ -489,7 +483,7 @@ fn check_expr_fn_block(rcx: @mut Rcx,\n             }\n \n             let repeating_scope = rcx.set_repeating_scope(body.id);\n-            visit::walk_expr(v, expr, rcx);\n+            visit::walk_expr(rcx, expr, ());\n             rcx.set_repeating_scope(repeating_scope);\n         }\n \n@@ -501,7 +495,7 @@ fn check_expr_fn_block(rcx: @mut Rcx,\n     }\n }\n \n-fn constrain_callee(rcx: @mut Rcx,\n+fn constrain_callee(rcx: &mut Rcx,\n                     callee_id: ast::NodeId,\n                     call_expr: @ast::Expr,\n                     callee_expr: @ast::Expr)\n@@ -526,7 +520,7 @@ fn constrain_callee(rcx: @mut Rcx,\n     }\n }\n \n-fn constrain_call(rcx: @mut Rcx,\n+fn constrain_call(rcx: &mut Rcx,\n                   // might be expr_call, expr_method_call, or an overloaded\n                   // operator\n                   callee_id: ast::NodeId,\n@@ -589,7 +583,7 @@ fn constrain_call(rcx: @mut Rcx,\n         fn_sig.output);\n }\n \n-fn constrain_derefs(rcx: @mut Rcx,\n+fn constrain_derefs(rcx: &mut Rcx,\n                     deref_expr: @ast::Expr,\n                     derefs: uint,\n                     mut derefd_ty: ty::t)\n@@ -625,7 +619,7 @@ fn constrain_derefs(rcx: @mut Rcx,\n     }\n }\n \n-pub fn mk_subregion_due_to_derefence(rcx: @mut Rcx,\n+pub fn mk_subregion_due_to_derefence(rcx: &mut Rcx,\n                                      deref_span: Span,\n                                      minimum_lifetime: ty::Region,\n                                      maximum_lifetime: ty::Region) {\n@@ -634,7 +628,7 @@ pub fn mk_subregion_due_to_derefence(rcx: @mut Rcx,\n }\n \n \n-fn constrain_index(rcx: @mut Rcx,\n+fn constrain_index(rcx: &mut Rcx,\n                    index_expr: @ast::Expr,\n                    indexed_ty: ty::t)\n {\n@@ -659,7 +653,7 @@ fn constrain_index(rcx: @mut Rcx,\n     }\n }\n \n-fn constrain_free_variables(rcx: @mut Rcx,\n+fn constrain_free_variables(rcx: &mut Rcx,\n                             region: ty::Region,\n                             expr: @ast::Expr) {\n     /*!\n@@ -681,7 +675,7 @@ fn constrain_free_variables(rcx: @mut Rcx,\n }\n \n fn constrain_regions_in_type_of_node(\n-    rcx: @mut Rcx,\n+    rcx: &mut Rcx,\n     id: ast::NodeId,\n     minimum_lifetime: ty::Region,\n     origin: infer::SubregionOrigin) -> bool\n@@ -706,7 +700,7 @@ fn constrain_regions_in_type_of_node(\n }\n \n fn constrain_regions_in_type(\n-    rcx: @mut Rcx,\n+    rcx: &mut Rcx,\n     minimum_lifetime: ty::Region,\n     origin: infer::SubregionOrigin,\n     ty: ty::t) -> bool\n@@ -812,7 +806,7 @@ pub mod guarantor {\n     use syntax::codemap::Span;\n     use util::ppaux::{ty_to_str};\n \n-    pub fn for_addr_of(rcx: @mut Rcx, expr: @ast::Expr, base: @ast::Expr) {\n+    pub fn for_addr_of(rcx: &mut Rcx, expr: @ast::Expr, base: @ast::Expr) {\n         /*!\n          * Computes the guarantor for an expression `&base` and then\n          * ensures that the lifetime of the resulting pointer is linked\n@@ -825,7 +819,7 @@ pub mod guarantor {\n         link(rcx, expr.span, expr.id, guarantor);\n     }\n \n-    pub fn for_match(rcx: @mut Rcx, discr: @ast::Expr, arms: &[ast::Arm]) {\n+    pub fn for_match(rcx: &mut Rcx, discr: @ast::Expr, arms: &[ast::Arm]) {\n         /*!\n          * Computes the guarantors for any ref bindings in a match and\n          * then ensures that the lifetime of the resulting pointer is\n@@ -842,7 +836,7 @@ pub mod guarantor {\n         }\n     }\n \n-    pub fn for_autoref(rcx: @mut Rcx,\n+    pub fn for_autoref(rcx: &mut Rcx,\n                        expr: @ast::Expr,\n                        autoderefs: uint,\n                        autoref: &ty::AutoRef) {\n@@ -882,7 +876,7 @@ pub mod guarantor {\n         }\n \n         fn maybe_make_subregion(\n-            rcx: @mut Rcx,\n+            rcx: &mut Rcx,\n             expr: @ast::Expr,\n             sub_region: ty::Region,\n             sup_region: Option<ty::Region>)\n@@ -894,7 +888,7 @@ pub mod guarantor {\n         }\n     }\n \n-    pub fn for_by_ref(rcx: @mut Rcx,\n+    pub fn for_by_ref(rcx: &mut Rcx,\n                       expr: @ast::Expr,\n                       callee_scope: ast::NodeId) {\n         /*!\n@@ -917,7 +911,7 @@ pub mod guarantor {\n     }\n \n     fn link(\n-        rcx: @mut Rcx,\n+        rcx: &mut Rcx,\n         span: Span,\n         id: ast::NodeId,\n         guarantor: Option<ty::Region>) {\n@@ -974,7 +968,7 @@ pub mod guarantor {\n         ty: ty::t\n     }\n \n-    fn guarantor(rcx: @mut Rcx, expr: @ast::Expr) -> Option<ty::Region> {\n+    fn guarantor(rcx: &mut Rcx, expr: @ast::Expr) -> Option<ty::Region> {\n         /*!\n          *\n          * Computes the guarantor of `expr`, or None if `expr` is\n@@ -1045,7 +1039,7 @@ pub mod guarantor {\n         }\n     }\n \n-    fn categorize(rcx: @mut Rcx, expr: @ast::Expr) -> ExprCategorization {\n+    fn categorize(rcx: &mut Rcx, expr: @ast::Expr) -> ExprCategorization {\n         debug!(\"categorize()\");\n \n         let mut expr_ct = categorize_unadjusted(rcx, expr);\n@@ -1096,7 +1090,7 @@ pub mod guarantor {\n         return expr_ct.cat;\n     }\n \n-    fn categorize_unadjusted(rcx: @mut Rcx,\n+    fn categorize_unadjusted(rcx: &mut Rcx,\n                              expr: @ast::Expr)\n                           -> ExprCategorizationType {\n         debug!(\"categorize_unadjusted()\");\n@@ -1120,7 +1114,7 @@ pub mod guarantor {\n     }\n \n     fn apply_autoderefs(\n-        rcx: @mut Rcx,\n+        rcx: &mut Rcx,\n         expr: @ast::Expr,\n         autoderefs: uint,\n         ct: ExprCategorizationType)\n@@ -1198,7 +1192,7 @@ pub mod guarantor {\n     }\n \n     fn link_ref_bindings_in_pat(\n-        rcx: @mut Rcx,\n+        rcx: &mut Rcx,\n         pat: @ast::Pat,\n         guarantor: Option<ty::Region>) {\n         /*!\n@@ -1271,7 +1265,7 @@ pub mod guarantor {\n         }\n     }\n \n-    fn link_ref_bindings_in_pats(rcx: @mut Rcx,\n+    fn link_ref_bindings_in_pats(rcx: &mut Rcx,\n                                  pats: &~[@ast::Pat],\n                                  guarantor: Option<ty::Region>) {\n         for pat in pats.iter() {"}, {"sha": "0e1536357207df5509df16bce1406766c809ce53", "filename": "src/librustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/0e95c3434b848da6fd7b8cd0ff27bec5d51db01c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e95c3434b848da6fd7b8cd0ff27bec5d51db01c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=0e95c3434b848da6fd7b8cd0ff27bec5d51db01c", "patch": "@@ -720,11 +720,11 @@ pub fn early_resolve_expr(ex: @ast::Expr,\n     }\n }\n \n-fn resolve_expr(v: &mut VtableResolveVisitor,\n-                ex: @ast::Expr,\n-                fcx: @mut FnCtxt) {\n+fn resolve_expr(fcx: @mut FnCtxt,\n+                ex: @ast::Expr) {\n+    let mut fcx = fcx;\n     early_resolve_expr(ex, fcx, false);\n-    visit::walk_expr(v, ex, fcx);\n+    visit::walk_expr(&mut fcx, ex, ());\n }\n \n pub fn resolve_impl(ccx: @mut CrateCtxt, impl_item: @ast::item) {\n@@ -771,20 +771,18 @@ pub fn resolve_impl(ccx: @mut CrateCtxt, impl_item: @ast::item) {\n     }\n }\n \n-struct VtableResolveVisitor;\n-\n-impl visit::Visitor<@mut FnCtxt> for VtableResolveVisitor {\n-    fn visit_expr(&mut self, ex:@ast::Expr, e:@mut FnCtxt) {\n-        resolve_expr(self, ex, e);\n+impl visit::Visitor<()> for @mut FnCtxt {\n+    fn visit_expr(&mut self, ex:@ast::Expr, _:()) {\n+        resolve_expr(*self, ex);\n     }\n-    fn visit_item(&mut self, _:@ast::item, _:@mut FnCtxt) {\n+    fn visit_item(&mut self, _:@ast::item, _:()) {\n         // no-op\n     }\n }\n \n // Detect points where a trait-bounded type parameter is\n // instantiated, resolve the impls for the parameters.\n pub fn resolve_in_block(fcx: @mut FnCtxt, bl: &ast::Block) {\n-    let mut visitor = VtableResolveVisitor;\n-    visit::walk_block(&mut visitor, bl, fcx);\n+    let mut fcx = fcx;\n+    visit::walk_block(&mut fcx, bl, ());\n }"}, {"sha": "5e9ca576a560a93b1f96a2c024306db732099bd5", "filename": "src/librustc/middle/typeck/check/writeback.rs", "status": "modified", "additions": 27, "deletions": 29, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/0e95c3434b848da6fd7b8cd0ff27bec5d51db01c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e95c3434b848da6fd7b8cd0ff27bec5d51db01c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs?ref=0e95c3434b848da6fd7b8cd0ff27bec5d51db01c", "patch": "@@ -114,7 +114,7 @@ fn resolve_vtable_map_entry(fcx: @mut FnCtxt, sp: Span, id: ast::NodeId) {\n     }\n }\n \n-fn resolve_type_vars_for_node(wbcx: @mut WbCtxt, sp: Span, id: ast::NodeId)\n+fn resolve_type_vars_for_node(wbcx: &mut WbCtxt, sp: Span, id: ast::NodeId)\n                            -> Option<ty::t> {\n     let fcx = wbcx.fcx;\n     let tcx = fcx.ccx.tcx;\n@@ -196,7 +196,7 @@ fn resolve_type_vars_for_node(wbcx: @mut WbCtxt, sp: Span, id: ast::NodeId)\n     }\n }\n \n-fn maybe_resolve_type_vars_for_node(wbcx: @mut WbCtxt,\n+fn maybe_resolve_type_vars_for_node(wbcx: &mut WbCtxt,\n                                     sp: Span,\n                                     id: ast::NodeId)\n                                  -> Option<ty::t> {\n@@ -215,15 +215,13 @@ struct WbCtxt {\n     success: bool,\n }\n \n-struct WbVisitor;\n-\n-fn visit_stmt(s: @ast::Stmt, (wbcx, v): (@mut WbCtxt, &mut WbVisitor)) {\n+fn visit_stmt(s: @ast::Stmt, wbcx: &mut WbCtxt) {\n     if !wbcx.success { return; }\n     resolve_type_vars_for_node(wbcx, s.span, ty::stmt_node_id(s));\n-    visit::walk_stmt(v, s, wbcx);\n+    visit::walk_stmt(wbcx, s, ());\n }\n \n-fn visit_expr(e: @ast::Expr, (wbcx, v): (@mut WbCtxt, &mut WbVisitor)) {\n+fn visit_expr(e: @ast::Expr, wbcx: &mut WbCtxt) {\n     if !wbcx.success {\n         return;\n     }\n@@ -268,19 +266,19 @@ fn visit_expr(e: @ast::Expr, (wbcx, v): (@mut WbCtxt, &mut WbVisitor)) {\n         _ => ()\n     }\n \n-    visit::walk_expr(v, e, wbcx);\n+    visit::walk_expr(wbcx, e, ());\n }\n \n-fn visit_block(b: &ast::Block, (wbcx, v): (@mut WbCtxt, &mut WbVisitor)) {\n+fn visit_block(b: &ast::Block, wbcx: &mut WbCtxt) {\n     if !wbcx.success {\n         return;\n     }\n \n     resolve_type_vars_for_node(wbcx, b.span, b.id);\n-    visit::walk_block(v, b, wbcx);\n+    visit::walk_block(wbcx, b, ());\n }\n \n-fn visit_pat(p: @ast::Pat, (wbcx, v): (@mut WbCtxt, &mut WbVisitor)) {\n+fn visit_pat(p: @ast::Pat, wbcx: &mut WbCtxt) {\n     if !wbcx.success {\n         return;\n     }\n@@ -291,10 +289,10 @@ fn visit_pat(p: @ast::Pat, (wbcx, v): (@mut WbCtxt, &mut WbVisitor)) {\n            wbcx.fcx.infcx().ty_to_str(\n                ty::node_id_to_type(wbcx.fcx.ccx.tcx,\n                                    p.id)));\n-    visit::walk_pat(v, p, wbcx);\n+    visit::walk_pat(wbcx, p, ());\n }\n \n-fn visit_local(l: @ast::Local, (wbcx, v): (@mut WbCtxt, &mut WbVisitor)) {\n+fn visit_local(l: @ast::Local, wbcx: &mut WbCtxt) {\n     if !wbcx.success { return; }\n     let var_ty = wbcx.fcx.local_ty(l.span, l.id);\n     match resolve_type(wbcx.fcx.infcx(), var_ty, resolve_all | force_all) {\n@@ -314,42 +312,42 @@ fn visit_local(l: @ast::Local, (wbcx, v): (@mut WbCtxt, &mut WbVisitor)) {\n             wbcx.success = false;\n         }\n     }\n-    visit::walk_local(v, l, wbcx);\n+    visit::walk_local(wbcx, l, ());\n }\n-fn visit_item(_item: @ast::item, (_wbcx, _v): (@mut WbCtxt, &mut WbVisitor)) {\n+fn visit_item(_item: @ast::item, _wbcx: &mut WbCtxt) {\n     // Ignore items\n }\n \n-impl Visitor<@mut WbCtxt> for WbVisitor {\n-    fn visit_item(&mut self, i:@ast::item, e:@mut WbCtxt) { visit_item(i, (e, self)); }\n-    fn visit_stmt(&mut self, s:@ast::Stmt, e:@mut WbCtxt) { visit_stmt(s, (e, self)); }\n-    fn visit_expr(&mut self, ex:@ast::Expr, e:@mut WbCtxt) { visit_expr(ex, (e, self)); }\n-    fn visit_block(&mut self, b:&ast::Block, e:@mut WbCtxt) { visit_block(b, (e, self)); }\n-    fn visit_pat(&mut self, p:@ast::Pat, e:@mut WbCtxt) { visit_pat(p, (e, self)); }\n-    fn visit_local(&mut self, l:@ast::Local, e:@mut WbCtxt) { visit_local(l, (e, self)); }\n+impl Visitor<()> for WbCtxt {\n+    fn visit_item(&mut self, i:@ast::item, _:()) { visit_item(i, self); }\n+    fn visit_stmt(&mut self, s:@ast::Stmt, _:()) { visit_stmt(s, self); }\n+    fn visit_expr(&mut self, ex:@ast::Expr, _:()) { visit_expr(ex, self); }\n+    fn visit_block(&mut self, b:&ast::Block, _:()) { visit_block(b, self); }\n+    fn visit_pat(&mut self, p:@ast::Pat, _:()) { visit_pat(p, self); }\n+    fn visit_local(&mut self, l:@ast::Local, _:()) { visit_local(l, self); }\n }\n \n pub fn resolve_type_vars_in_expr(fcx: @mut FnCtxt, e: @ast::Expr) -> bool {\n-    let wbcx = @mut WbCtxt { fcx: fcx, success: true };\n-    let mut visit = WbVisitor;\n-    visit.visit_expr(e, wbcx);\n+    let mut wbcx = WbCtxt { fcx: fcx, success: true };\n+    let wbcx = &mut wbcx;\n+    wbcx.visit_expr(e, ());\n     return wbcx.success;\n }\n \n pub fn resolve_type_vars_in_fn(fcx: @mut FnCtxt,\n                                decl: &ast::fn_decl,\n                                blk: &ast::Block,\n                                self_info: Option<SelfInfo>) -> bool {\n-    let wbcx = @mut WbCtxt { fcx: fcx, success: true };\n-    let mut visit = WbVisitor;\n-    visit.visit_block(blk, wbcx);\n+    let mut wbcx = WbCtxt { fcx: fcx, success: true };\n+    let wbcx = &mut wbcx;\n+    wbcx.visit_block(blk, ());\n     for self_info in self_info.iter() {\n         resolve_type_vars_for_node(wbcx,\n                                    self_info.span,\n                                    self_info.self_id);\n     }\n     for arg in decl.inputs.iter() {\n-        visit.visit_pat(arg.pat, wbcx);\n+        wbcx.visit_pat(arg.pat, ());\n         // Privacy needs the type for the whole pattern, not just each binding\n         if !pat_util::pat_is_binding(fcx.tcx().def_map, arg.pat) {\n             resolve_type_vars_for_node(wbcx, arg.pat.span, arg.pat.id);"}]}