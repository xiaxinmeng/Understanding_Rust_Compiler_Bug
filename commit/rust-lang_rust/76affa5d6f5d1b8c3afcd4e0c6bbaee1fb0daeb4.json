{"sha": "76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc2YWZmYTVkNmY1ZDFiOGMzYWZjZDRlMGM2YmJhZWUxZmIwZGFlYjQ=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-05-03T02:23:22Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-05-11T01:14:58Z"}, "message": "rustc: Split 'tcx into 'gcx and 'tcx for InferCtxt and its users.", "tree": {"sha": "106d9822eeb61381393aed89eb5133f1d28135cb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/106d9822eeb61381393aed89eb5133f1d28135cb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4", "html_url": "https://github.com/rust-lang/rust/commit/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "166dbc3273ab760004c97d8598b9f30853e6f85a", "url": "https://api.github.com/repos/rust-lang/rust/commits/166dbc3273ab760004c97d8598b9f30853e6f85a", "html_url": "https://github.com/rust-lang/rust/commit/166dbc3273ab760004c97d8598b9f30853e6f85a"}], "stats": {"total": 2485, "additions": 1296, "deletions": 1189}, "files": [{"sha": "64c51c9432853546992a0238615880c44d57a5ad", "filename": "src/librustc/cfg/construct.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fcfg%2Fconstruct.rs?ref=76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4", "patch": "@@ -19,7 +19,7 @@ use syntax::ptr::P;\n use hir::{self, PatKind};\n \n struct CFGBuilder<'a, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'tcx>,\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     graph: CFGGraph,\n     fn_exit: CFGIndex,\n     loop_scopes: Vec<LoopScope>,\n@@ -32,8 +32,8 @@ struct LoopScope {\n     break_index: CFGIndex,    // where to go on a `break\n }\n \n-pub fn construct(tcx: TyCtxt,\n-                 blk: &hir::Block) -> CFG {\n+pub fn construct<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                           blk: &hir::Block) -> CFG {\n     let mut graph = graph::Graph::new();\n     let entry = graph.add_node(CFGNodeData::Entry);\n "}, {"sha": "617e2ed2f1aebfb5abd2cc859f6236c0c4856da5", "filename": "src/librustc/cfg/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc%2Fcfg%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc%2Fcfg%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fcfg%2Fmod.rs?ref=76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4", "patch": "@@ -58,8 +58,8 @@ pub type CFGNode = graph::Node<CFGNodeData>;\n pub type CFGEdge = graph::Edge<CFGEdgeData>;\n \n impl CFG {\n-    pub fn new(tcx: TyCtxt,\n-               blk: &hir::Block) -> CFG {\n+    pub fn new<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                         blk: &hir::Block) -> CFG {\n         construct::construct(tcx, blk)\n     }\n "}, {"sha": "321d109ca0e726f8ce689f643ca09b4c22968599", "filename": "src/librustc/dep_graph/visit.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc%2Fdep_graph%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc%2Fdep_graph%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fvisit.rs?ref=76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4", "patch": "@@ -22,13 +22,13 @@ use super::dep_node::DepNode;\n /// read edge from the corresponding AST node. This is used in\n /// compiler passes to automatically record the item that they are\n /// working on.\n-pub fn visit_all_items_in_krate<'a, 'tcx, V, F>(tcx: TyCtxt<'a, 'tcx>,\n+pub fn visit_all_items_in_krate<'a, 'tcx, V, F>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                                 mut dep_node_fn: F,\n                                                 visitor: &mut V)\n     where F: FnMut(DefId) -> DepNode<DefId>, V: Visitor<'tcx>\n {\n     struct TrackingVisitor<'visit, 'tcx: 'visit, F: 'visit, V: 'visit> {\n-        tcx: TyCtxt<'visit, 'tcx>,\n+        tcx: TyCtxt<'visit, 'tcx, 'tcx>,\n         dep_node_fn: &'visit mut F,\n         visitor: &'visit mut V\n     }"}, {"sha": "6bbd6a207ee0477cb3adf896d92965284b2a1632", "filename": "src/librustc/hir/pat_util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc%2Fhir%2Fpat_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc%2Fhir%2Fpat_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fpat_util.rs?ref=76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4", "patch": "@@ -209,7 +209,7 @@ pub fn simple_name<'a>(pat: &'a hir::Pat) -> Option<ast::Name> {\n     }\n }\n \n-pub fn def_to_path(tcx: TyCtxt, id: DefId) -> hir::Path {\n+pub fn def_to_path<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, id: DefId) -> hir::Path {\n     let name = tcx.item_name(id);\n     hir::Path::from_ident(DUMMY_SP, hir::Ident::from_name(name))\n }"}, {"sha": "f853396e7583b8863188d496819c3fba9425d1ff", "filename": "src/librustc/infer/bivariate.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc%2Finfer%2Fbivariate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc%2Finfer%2Fbivariate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fbivariate.rs?ref=76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4", "patch": "@@ -32,20 +32,20 @@ use ty::{self, Ty, TyCtxt};\n use ty::TyVar;\n use ty::relate::{Relate, RelateResult, TypeRelation};\n \n-pub struct Bivariate<'a, 'tcx: 'a> {\n-    fields: CombineFields<'a, 'tcx>\n+pub struct Bivariate<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n+    fields: CombineFields<'a, 'gcx, 'tcx>\n }\n \n-impl<'a, 'tcx> Bivariate<'a, 'tcx> {\n-    pub fn new(fields: CombineFields<'a, 'tcx>) -> Bivariate<'a, 'tcx> {\n+impl<'a, 'tcx> Bivariate<'a, 'tcx, 'tcx> {\n+    pub fn new(fields: CombineFields<'a, 'tcx, 'tcx>) -> Bivariate<'a, 'tcx, 'tcx> {\n         Bivariate { fields: fields }\n     }\n }\n \n-impl<'a, 'tcx> TypeRelation<'a, 'tcx> for Bivariate<'a, 'tcx> {\n+impl<'a, 'tcx> TypeRelation<'a, 'tcx> for Bivariate<'a, 'tcx, 'tcx> {\n     fn tag(&self) -> &'static str { \"Bivariate\" }\n \n-    fn tcx(&self) -> TyCtxt<'a, 'tcx> { self.fields.tcx() }\n+    fn tcx(&self) -> TyCtxt<'a, 'tcx, 'tcx> { self.fields.tcx() }\n \n     fn a_is_expected(&self) -> bool { self.fields.a_is_expected }\n "}, {"sha": "6a2dba14fd1020b730f29eecb0cfeb000a34e452", "filename": "src/librustc/infer/combine.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcombine.rs?ref=76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4", "patch": "@@ -52,15 +52,15 @@ use syntax::ast;\n use syntax::codemap::Span;\n \n #[derive(Clone)]\n-pub struct CombineFields<'a, 'tcx: 'a> {\n-    pub infcx: &'a InferCtxt<'a, 'tcx>,\n+pub struct CombineFields<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n+    pub infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n     pub a_is_expected: bool,\n     pub trace: TypeTrace<'tcx>,\n     pub cause: Option<ty::relate::Cause>,\n     pub obligations: PredicateObligations<'tcx>,\n }\n \n-impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n+impl<'a, 'tcx> InferCtxt<'a, 'tcx, 'tcx> {\n pub fn super_combine_tys<R>(&self,\n                             relation: &mut R,\n                             a: Ty<'tcx>,\n@@ -150,35 +150,35 @@ fn unify_float_variable(&self,\n }\n }\n \n-impl<'a, 'tcx> CombineFields<'a, 'tcx> {\n-    pub fn tcx(&self) -> TyCtxt<'a, 'tcx> {\n+impl<'a, 'tcx> CombineFields<'a, 'tcx, 'tcx> {\n+    pub fn tcx(&self) -> TyCtxt<'a, 'tcx, 'tcx> {\n         self.infcx.tcx\n     }\n \n-    pub fn switch_expected(&self) -> CombineFields<'a, 'tcx> {\n+    pub fn switch_expected(&self) -> CombineFields<'a, 'tcx, 'tcx> {\n         CombineFields {\n             a_is_expected: !self.a_is_expected,\n             ..(*self).clone()\n         }\n     }\n \n-    pub fn equate(&self) -> Equate<'a, 'tcx> {\n+    pub fn equate(&self) -> Equate<'a, 'tcx, 'tcx> {\n         Equate::new(self.clone())\n     }\n \n-    pub fn bivariate(&self) -> Bivariate<'a, 'tcx> {\n+    pub fn bivariate(&self) -> Bivariate<'a, 'tcx, 'tcx> {\n         Bivariate::new(self.clone())\n     }\n \n-    pub fn sub(&self) -> Sub<'a, 'tcx> {\n+    pub fn sub(&self) -> Sub<'a, 'tcx, 'tcx> {\n         Sub::new(self.clone())\n     }\n \n-    pub fn lub(&self) -> Lub<'a, 'tcx> {\n+    pub fn lub(&self) -> Lub<'a, 'tcx, 'tcx> {\n         Lub::new(self.clone())\n     }\n \n-    pub fn glb(&self) -> Glb<'a, 'tcx> {\n+    pub fn glb(&self) -> Glb<'a, 'tcx, 'tcx> {\n         Glb::new(self.clone())\n     }\n \n@@ -291,16 +291,16 @@ impl<'a, 'tcx> CombineFields<'a, 'tcx> {\n     }\n }\n \n-struct Generalizer<'cx, 'tcx:'cx> {\n-    infcx: &'cx InferCtxt<'cx, 'tcx>,\n+struct Generalizer<'cx, 'gcx: 'cx+'tcx, 'tcx: 'cx> {\n+    infcx: &'cx InferCtxt<'cx, 'gcx, 'tcx>,\n     span: Span,\n     for_vid: ty::TyVid,\n     make_region_vars: bool,\n     cycle_detected: bool,\n }\n \n-impl<'cx, 'tcx> ty::fold::TypeFolder<'tcx> for Generalizer<'cx, 'tcx> {\n-    fn tcx<'a>(&'a self) -> TyCtxt<'a, 'tcx> {\n+impl<'cx, 'tcx> ty::fold::TypeFolder<'tcx> for Generalizer<'cx, 'tcx, 'tcx> {\n+    fn tcx<'a>(&'a self) -> TyCtxt<'a, 'tcx, 'tcx> {\n         self.infcx.tcx\n     }\n "}, {"sha": "433baf42c40b51df6437ca65fd08c0d301b87686", "filename": "src/librustc/infer/equate.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc%2Finfer%2Fequate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc%2Finfer%2Fequate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fequate.rs?ref=76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4", "patch": "@@ -19,12 +19,12 @@ use ty::relate::{Relate, RelateResult, TypeRelation};\n use traits::PredicateObligations;\n \n /// Ensures `a` is made equal to `b`. Returns `a` on success.\n-pub struct Equate<'a, 'tcx: 'a> {\n-    fields: CombineFields<'a, 'tcx>\n+pub struct Equate<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n+    fields: CombineFields<'a, 'gcx, 'tcx>\n }\n \n-impl<'a, 'tcx> Equate<'a, 'tcx> {\n-    pub fn new(fields: CombineFields<'a, 'tcx>) -> Equate<'a, 'tcx> {\n+impl<'a, 'tcx> Equate<'a, 'tcx, 'tcx> {\n+    pub fn new(fields: CombineFields<'a, 'tcx, 'tcx>) -> Equate<'a, 'tcx, 'tcx> {\n         Equate { fields: fields }\n     }\n \n@@ -33,10 +33,10 @@ impl<'a, 'tcx> Equate<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> TypeRelation<'a,'tcx> for Equate<'a, 'tcx> {\n+impl<'a, 'tcx> TypeRelation<'a,'tcx> for Equate<'a, 'tcx, 'tcx> {\n     fn tag(&self) -> &'static str { \"Equate\" }\n \n-    fn tcx(&self) -> TyCtxt<'a, 'tcx> { self.fields.tcx() }\n+    fn tcx(&self) -> TyCtxt<'a, 'tcx, 'tcx> { self.fields.tcx() }\n \n     fn a_is_expected(&self) -> bool { self.fields.a_is_expected }\n "}, {"sha": "219ebf625ec332c05879258f7bf37964e0fb6bcb", "filename": "src/librustc/infer/error_reporting.rs", "status": "modified", "additions": 19, "deletions": 18, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting.rs?ref=76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4", "patch": "@@ -95,7 +95,7 @@ use syntax::codemap::{self, Pos, Span};\n use syntax::parse::token;\n use syntax::ptr::P;\n \n-impl<'a, 'tcx> TyCtxt<'a, 'tcx> {\n+impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n     pub fn note_and_explain_region(self,\n                                    err: &mut DiagnosticBuilder,\n                                    prefix: &str,\n@@ -112,8 +112,9 @@ impl<'a, 'tcx> TyCtxt<'a, 'tcx> {\n             }\n         }\n \n-        fn explain_span(tcx: TyCtxt, heading: &str, span: Span)\n-                        -> (String, Option<Span>) {\n+        fn explain_span<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                  heading: &str, span: Span)\n+                                  -> (String, Option<Span>) {\n             let lo = tcx.sess.codemap().lookup_char_pos_adj(span.lo);\n             (format!(\"the {} at {}:{}\", heading, lo.line, lo.col.to_usize()),\n              Some(span))\n@@ -301,7 +302,7 @@ trait ErrorReportingHelpers<'tcx> {\n                                 span: Span);\n }\n \n-impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n+impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx, 'tcx> {\n     fn report_region_errors(&self,\n                             errors: &Vec<RegionResolutionError<'tcx>>) {\n         debug!(\"report_region_errors(): {} errors to start\", errors.len());\n@@ -474,10 +475,10 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n             }\n         }\n \n-        fn free_regions_from_same_fn(tcx: TyCtxt,\n-                                     sub: Region,\n-                                     sup: Region)\n-                                     -> Option<FreeRegionsFromSameFn> {\n+        fn free_regions_from_same_fn<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                               sub: Region,\n+                                               sup: Region)\n+                                               -> Option<FreeRegionsFromSameFn> {\n             debug!(\"free_regions_from_same_fn(sub={:?}, sup={:?})\", sub, sup);\n             let (scope_id, fr1, fr2) = match (sub, sup) {\n                 (ReFree(fr1), ReFree(fr2)) => {\n@@ -1109,7 +1110,7 @@ struct RebuildPathInfo<'a> {\n }\n \n struct Rebuilder<'a, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'tcx>,\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     fn_decl: &'a hir::FnDecl,\n     expl_self_opt: Option<&'a hir::ExplicitSelf_>,\n     generics: &'a hir::Generics,\n@@ -1125,7 +1126,7 @@ enum FreshOrKept {\n }\n \n impl<'a, 'tcx> Rebuilder<'a, 'tcx> {\n-    fn new(tcx: TyCtxt<'a, 'tcx>,\n+    fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n            fn_decl: &'a hir::FnDecl,\n            expl_self_opt: Option<&'a hir::ExplicitSelf_>,\n            generics: &'a hir::Generics,\n@@ -1641,7 +1642,7 @@ impl<'a, 'tcx> Rebuilder<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> ErrorReportingHelpers<'tcx> for InferCtxt<'a, 'tcx> {\n+impl<'a, 'tcx> ErrorReportingHelpers<'tcx> for InferCtxt<'a, 'tcx, 'tcx> {\n     fn give_expl_lifetime_param(&self,\n                                 err: &mut DiagnosticBuilder,\n                                 decl: &hir::FnDecl,\n@@ -1904,34 +1905,34 @@ impl<'a, 'tcx> ErrorReportingHelpers<'tcx> for InferCtxt<'a, 'tcx> {\n }\n \n pub trait Resolvable<'tcx> {\n-    fn resolve<'a>(&self, infcx: &InferCtxt<'a, 'tcx>) -> Self;\n+    fn resolve<'a>(&self, infcx: &InferCtxt<'a, 'tcx, 'tcx>) -> Self;\n }\n \n impl<'tcx> Resolvable<'tcx> for Ty<'tcx> {\n-    fn resolve<'a>(&self, infcx: &InferCtxt<'a, 'tcx>) -> Ty<'tcx> {\n+    fn resolve<'a>(&self, infcx: &InferCtxt<'a, 'tcx, 'tcx>) -> Ty<'tcx> {\n         infcx.resolve_type_vars_if_possible(self)\n     }\n }\n \n impl<'tcx> Resolvable<'tcx> for ty::TraitRef<'tcx> {\n-    fn resolve<'a>(&self, infcx: &InferCtxt<'a, 'tcx>)\n+    fn resolve<'a>(&self, infcx: &InferCtxt<'a, 'tcx, 'tcx>)\n                    -> ty::TraitRef<'tcx> {\n         infcx.resolve_type_vars_if_possible(self)\n     }\n }\n \n impl<'tcx> Resolvable<'tcx> for ty::PolyTraitRef<'tcx> {\n     fn resolve<'a>(&self,\n-                   infcx: &InferCtxt<'a, 'tcx>)\n+                   infcx: &InferCtxt<'a, 'tcx, 'tcx>)\n                    -> ty::PolyTraitRef<'tcx>\n     {\n         infcx.resolve_type_vars_if_possible(self)\n     }\n }\n \n-fn lifetimes_in_scope(tcx: TyCtxt,\n-                      scope_id: ast::NodeId)\n-                      -> Vec<hir::LifetimeDef> {\n+fn lifetimes_in_scope<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                scope_id: ast::NodeId)\n+                                -> Vec<hir::LifetimeDef> {\n     let mut taken = Vec::new();\n     let parent = tcx.map.get_parent(scope_id);\n     let method_id_opt = match tcx.map.find(parent) {"}, {"sha": "72f12188f92d94fee4fd8b20e622510081da8d98", "filename": "src/librustc/infer/freshen.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc%2Finfer%2Ffreshen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc%2Finfer%2Ffreshen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ffreshen.rs?ref=76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4", "patch": "@@ -37,14 +37,14 @@ use std::collections::hash_map::{self, Entry};\n use super::InferCtxt;\n use super::unify_key::ToType;\n \n-pub struct TypeFreshener<'a, 'tcx:'a> {\n-    infcx: &'a InferCtxt<'a, 'tcx>,\n+pub struct TypeFreshener<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n+    infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n     freshen_count: u32,\n     freshen_map: hash_map::HashMap<ty::InferTy, Ty<'tcx>>,\n }\n \n-impl<'a, 'tcx> TypeFreshener<'a, 'tcx> {\n-    pub fn new(infcx: &'a InferCtxt<'a, 'tcx>) -> TypeFreshener<'a, 'tcx> {\n+impl<'a, 'tcx> TypeFreshener<'a, 'tcx, 'tcx> {\n+    pub fn new(infcx: &'a InferCtxt<'a, 'tcx, 'tcx>) -> TypeFreshener<'a, 'tcx, 'tcx> {\n         TypeFreshener {\n             infcx: infcx,\n             freshen_count: 0,\n@@ -77,8 +77,8 @@ impl<'a, 'tcx> TypeFreshener<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> TypeFolder<'tcx> for TypeFreshener<'a, 'tcx> {\n-    fn tcx<'b>(&'b self) -> TyCtxt<'b, 'tcx> {\n+impl<'a, 'tcx> TypeFolder<'tcx> for TypeFreshener<'a, 'tcx, 'tcx> {\n+    fn tcx<'b>(&'b self) -> TyCtxt<'b, 'tcx, 'tcx> {\n         self.infcx.tcx\n     }\n "}, {"sha": "6daf60648ba02148e7c27a2ab7e4c4609c67976e", "filename": "src/librustc/infer/glb.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc%2Finfer%2Fglb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc%2Finfer%2Fglb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fglb.rs?ref=76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4", "patch": "@@ -19,12 +19,12 @@ use ty::relate::{Relate, RelateResult, TypeRelation};\n use traits::PredicateObligations;\n \n /// \"Greatest lower bound\" (common subtype)\n-pub struct Glb<'a, 'tcx: 'a> {\n-    fields: CombineFields<'a, 'tcx>\n+pub struct Glb<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n+    fields: CombineFields<'a, 'gcx, 'tcx>\n }\n \n-impl<'a, 'tcx> Glb<'a, 'tcx> {\n-    pub fn new(fields: CombineFields<'a, 'tcx>) -> Glb<'a, 'tcx> {\n+impl<'a, 'tcx> Glb<'a, 'tcx, 'tcx> {\n+    pub fn new(fields: CombineFields<'a, 'tcx, 'tcx>) -> Glb<'a, 'tcx, 'tcx> {\n         Glb { fields: fields }\n     }\n \n@@ -33,10 +33,10 @@ impl<'a, 'tcx> Glb<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> TypeRelation<'a, 'tcx> for Glb<'a, 'tcx> {\n+impl<'a, 'tcx> TypeRelation<'a, 'tcx> for Glb<'a, 'tcx, 'tcx> {\n     fn tag(&self) -> &'static str { \"Glb\" }\n \n-    fn tcx(&self) -> TyCtxt<'a, 'tcx> { self.fields.tcx() }\n+    fn tcx(&self) -> TyCtxt<'a, 'tcx, 'tcx> { self.fields.tcx() }\n \n     fn a_is_expected(&self) -> bool { self.fields.a_is_expected }\n \n@@ -76,8 +76,8 @@ impl<'a, 'tcx> TypeRelation<'a, 'tcx> for Glb<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> LatticeDir<'a,'tcx> for Glb<'a, 'tcx> {\n-    fn infcx(&self) -> &'a InferCtxt<'a,'tcx> {\n+impl<'a, 'tcx> LatticeDir<'a,'tcx> for Glb<'a, 'tcx, 'tcx> {\n+    fn infcx(&self) -> &'a InferCtxt<'a, 'tcx, 'tcx> {\n         self.fields.infcx\n     }\n "}, {"sha": "803dbfdfdeaceb2562c5496d4f16f349dd05c321", "filename": "src/librustc/infer/higher_ranked/mod.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs?ref=76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4", "patch": "@@ -31,7 +31,7 @@ pub trait HigherRankedRelations<'a,'tcx> {\n         where T: Relate<'a,'tcx>;\n }\n \n-impl<'a,'tcx> HigherRankedRelations<'a,'tcx> for CombineFields<'a,'tcx> {\n+impl<'a,'tcx> HigherRankedRelations<'a,'tcx> for CombineFields<'a, 'tcx, 'tcx> {\n     fn higher_ranked_sub<T>(&self, a: &Binder<T>, b: &Binder<T>)\n                             -> RelateResult<'tcx, Binder<T>>\n         where T: Relate<'a,'tcx>\n@@ -119,14 +119,14 @@ impl<'a,'tcx> HigherRankedRelations<'a,'tcx> for CombineFields<'a,'tcx> {\n             Ok(ty::Binder(result1))\n         });\n \n-        fn generalize_region(infcx: &InferCtxt,\n-                             span: Span,\n-                             snapshot: &CombinedSnapshot,\n-                             debruijn: ty::DebruijnIndex,\n-                             new_vars: &[ty::RegionVid],\n-                             a_map: &FnvHashMap<ty::BoundRegion, ty::Region>,\n-                             r0: ty::Region)\n-                             -> ty::Region {\n+        fn generalize_region<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx, 'tcx>,\n+                                       span: Span,\n+                                       snapshot: &CombinedSnapshot,\n+                                       debruijn: ty::DebruijnIndex,\n+                                       new_vars: &[ty::RegionVid],\n+                                       a_map: &FnvHashMap<ty::BoundRegion, ty::Region>,\n+                                       r0: ty::Region)\n+                                       -> ty::Region {\n             // Regions that pre-dated the LUB computation stay as they are.\n             if !is_var_in_set(new_vars, r0) {\n                 assert!(!r0.is_bound());\n@@ -214,15 +214,15 @@ impl<'a,'tcx> HigherRankedRelations<'a,'tcx> for CombineFields<'a,'tcx> {\n             Ok(ty::Binder(result1))\n         });\n \n-        fn generalize_region(infcx: &InferCtxt,\n-                             span: Span,\n-                             snapshot: &CombinedSnapshot,\n-                             debruijn: ty::DebruijnIndex,\n-                             new_vars: &[ty::RegionVid],\n-                             a_map: &FnvHashMap<ty::BoundRegion, ty::Region>,\n-                             a_vars: &[ty::RegionVid],\n-                             b_vars: &[ty::RegionVid],\n-                             r0: ty::Region) -> ty::Region {\n+        fn generalize_region<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx, 'tcx>,\n+                                       span: Span,\n+                                       snapshot: &CombinedSnapshot,\n+                                       debruijn: ty::DebruijnIndex,\n+                                       new_vars: &[ty::RegionVid],\n+                                       a_map: &FnvHashMap<ty::BoundRegion, ty::Region>,\n+                                       a_vars: &[ty::RegionVid],\n+                                       b_vars: &[ty::RegionVid],\n+                                       r0: ty::Region) -> ty::Region {\n             if !is_var_in_set(new_vars, r0) {\n                 assert!(!r0.is_bound());\n                 return r0;\n@@ -306,7 +306,7 @@ impl<'a,'tcx> HigherRankedRelations<'a,'tcx> for CombineFields<'a,'tcx> {\n     }\n }\n \n-fn var_ids<'a, 'tcx>(fields: &CombineFields<'a, 'tcx>,\n+fn var_ids<'a, 'tcx>(fields: &CombineFields<'a, 'tcx, 'tcx>,\n                       map: &FnvHashMap<ty::BoundRegion, ty::Region>)\n                      -> Vec<ty::RegionVid> {\n     map.iter()\n@@ -329,7 +329,7 @@ fn is_var_in_set(new_vars: &[ty::RegionVid], r: ty::Region) -> bool {\n     }\n }\n \n-fn fold_regions_in<'a, 'tcx, T, F>(tcx: TyCtxt<'a, 'tcx>,\n+fn fold_regions_in<'a, 'tcx, T, F>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                    unbound_value: &T,\n                                    mut fldr: F)\n                                    -> T\n@@ -349,7 +349,7 @@ fn fold_regions_in<'a, 'tcx, T, F>(tcx: TyCtxt<'a, 'tcx>,\n     })\n }\n \n-impl<'a,'tcx> InferCtxt<'a,'tcx> {\n+impl<'a,'tcx> InferCtxt<'a,'tcx, 'tcx> {\n     fn tainted_regions(&self, snapshot: &CombinedSnapshot, r: ty::Region) -> Vec<ty::Region> {\n         self.region_vars.tainted(&snapshot.region_vars_snapshot, r)\n     }"}, {"sha": "69f86686fe4b2d0e73357170e75cf26c72a1a99a", "filename": "src/librustc/infer/lattice.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc%2Finfer%2Flattice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc%2Finfer%2Flattice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Flattice.rs?ref=76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4", "patch": "@@ -36,7 +36,7 @@ use ty::{self, Ty};\n use ty::relate::{RelateResult, TypeRelation};\n \n pub trait LatticeDir<'f,'tcx> : TypeRelation<'f,'tcx> {\n-    fn infcx(&self) -> &'f InferCtxt<'f, 'tcx>;\n+    fn infcx(&self) -> &'f InferCtxt<'f, 'tcx, 'tcx>;\n \n     // Relates the type `v` to `a` and `b` such that `v` represents\n     // the LUB/GLB of `a` and `b` as appropriate."}, {"sha": "890170325ee488de552deac6668f4d21be8d3e03", "filename": "src/librustc/infer/lub.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc%2Finfer%2Flub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc%2Finfer%2Flub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Flub.rs?ref=76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4", "patch": "@@ -19,12 +19,12 @@ use ty::relate::{Relate, RelateResult, TypeRelation};\n use traits::PredicateObligations;\n \n /// \"Least upper bound\" (common supertype)\n-pub struct Lub<'a, 'tcx: 'a> {\n-    fields: CombineFields<'a, 'tcx>\n+pub struct Lub<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n+    fields: CombineFields<'a, 'gcx, 'tcx>\n }\n \n-impl<'a, 'tcx> Lub<'a, 'tcx> {\n-    pub fn new(fields: CombineFields<'a, 'tcx>) -> Lub<'a, 'tcx> {\n+impl<'a, 'tcx> Lub<'a, 'tcx, 'tcx> {\n+    pub fn new(fields: CombineFields<'a, 'tcx, 'tcx>) -> Lub<'a, 'tcx, 'tcx> {\n         Lub { fields: fields }\n     }\n \n@@ -33,10 +33,10 @@ impl<'a, 'tcx> Lub<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> TypeRelation<'a, 'tcx> for Lub<'a, 'tcx> {\n+impl<'a, 'tcx> TypeRelation<'a, 'tcx> for Lub<'a, 'tcx, 'tcx> {\n     fn tag(&self) -> &'static str { \"Lub\" }\n \n-    fn tcx(&self) -> TyCtxt<'a, 'tcx> { self.fields.tcx() }\n+    fn tcx(&self) -> TyCtxt<'a, 'tcx, 'tcx> { self.fields.tcx() }\n \n     fn a_is_expected(&self) -> bool { self.fields.a_is_expected }\n \n@@ -76,8 +76,8 @@ impl<'a, 'tcx> TypeRelation<'a, 'tcx> for Lub<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> LatticeDir<'a,'tcx> for Lub<'a, 'tcx> {\n-    fn infcx(&self) -> &'a InferCtxt<'a,'tcx> {\n+impl<'a, 'tcx> LatticeDir<'a,'tcx> for Lub<'a, 'tcx, 'tcx> {\n+    fn infcx(&self) -> &'a InferCtxt<'a, 'tcx, 'tcx> {\n         self.fields.infcx\n     }\n "}, {"sha": "cef2ae12d6be8481d303f3aaf1749337835656b0", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4", "patch": "@@ -73,8 +73,8 @@ pub type Bound<T> = Option<T>;\n pub type UnitResult<'tcx> = RelateResult<'tcx, ()>; // \"unify result\"\n pub type FixupResult<T> = Result<T, FixupError>; // \"fixup result\"\n \n-pub struct InferCtxt<'a, 'tcx: 'a> {\n-    pub tcx: TyCtxt<'a, 'tcx>,\n+pub struct InferCtxt<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n+    pub tcx: TyCtxt<'a, 'gcx, 'tcx>,\n \n     pub tables: &'a RefCell<ty::Tables<'tcx>>,\n \n@@ -384,8 +384,8 @@ impl fmt::Display for FixupError {\n     }\n }\n \n-impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n-    pub fn new(tcx: TyCtxt<'a, 'tcx>,\n+impl<'a, 'tcx> InferCtxt<'a, 'tcx, 'tcx> {\n+    pub fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                tables: &'a RefCell<ty::Tables<'tcx>>,\n                param_env: Option<ty::ParameterEnvironment<'a, 'tcx>>,\n                projection_mode: ProjectionMode)\n@@ -406,7 +406,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         }\n     }\n \n-    pub fn normalizing(tcx: TyCtxt<'a, 'tcx>,\n+    pub fn normalizing(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                        tables: &'a RefCell<ty::Tables<'tcx>>,\n                        projection_mode: ProjectionMode)\n                        -> Self {\n@@ -441,7 +441,7 @@ pub struct CombinedSnapshot {\n }\n \n // NOTE: Callable from trans only!\n-impl<'a, 'tcx> TyCtxt<'a, 'tcx> {\n+impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n     pub fn normalize_associated_type<T>(self, value: &T) -> T\n         where T : TypeFoldable<'tcx>\n     {\n@@ -473,7 +473,7 @@ impl<'a, 'tcx> TyCtxt<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n+impl<'a, 'tcx> InferCtxt<'a, 'tcx, 'tcx> {\n pub fn drain_fulfillment_cx_or_panic<T>(&self,\n                                         span: Span,\n                                         fulfill_cx: &mut traits::FulfillmentContext<'tcx>,\n@@ -532,7 +532,7 @@ pub fn drain_fulfillment_cx<T>(&self,\n         }\n     }\n \n-    pub fn freshener<'b>(&'b self) -> TypeFreshener<'b, 'tcx> {\n+    pub fn freshener<'b>(&'b self) -> TypeFreshener<'b, 'tcx, 'tcx> {\n         freshen::TypeFreshener::new(self)\n     }\n \n@@ -603,8 +603,7 @@ pub fn drain_fulfillment_cx<T>(&self,\n     }\n \n     fn combine_fields(&'a self, a_is_expected: bool, trace: TypeTrace<'tcx>)\n-        -> CombineFields<'a, 'tcx>\n-    {\n+                      -> CombineFields<'a, 'tcx, 'tcx> {\n         CombineFields {\n             infcx: self,\n             a_is_expected: a_is_expected,\n@@ -1539,7 +1538,7 @@ impl<'a, 'tcx> TypeTrace<'tcx> {\n         }\n     }\n \n-    pub fn dummy(tcx: TyCtxt<'a, 'tcx>) -> TypeTrace<'tcx> {\n+    pub fn dummy(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> TypeTrace<'tcx> {\n         TypeTrace {\n             origin: TypeOrigin::Misc(codemap::DUMMY_SP),\n             values: Types(ExpectedFound {"}, {"sha": "5c39e39bee02243aff8f7523288119c1535a653a", "filename": "src/librustc/infer/region_inference/graphviz.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc%2Finfer%2Fregion_inference%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc%2Finfer%2Fregion_inference%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fregion_inference%2Fgraphviz.rs?ref=76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4", "patch": "@@ -119,7 +119,7 @@ pub fn maybe_print_constraints_for<'a, 'tcx>(region_vars: &RegionVarBindings<'a,\n }\n \n struct ConstraintGraph<'a, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'tcx>,\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     graph_name: String,\n     map: &'a FnvHashMap<Constraint, SubregionOrigin<'tcx>>,\n     node_ids: FnvHashMap<Node, usize>,\n@@ -139,7 +139,7 @@ enum Edge {\n }\n \n impl<'a, 'tcx> ConstraintGraph<'a, 'tcx> {\n-    fn new(tcx: TyCtxt<'a, 'tcx>,\n+    fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n            name: String,\n            map: &'a ConstraintMap<'tcx>)\n            -> ConstraintGraph<'a, 'tcx> {\n@@ -258,7 +258,7 @@ impl<'a, 'tcx> dot::GraphWalk<'a> for ConstraintGraph<'a, 'tcx> {\n \n pub type ConstraintMap<'tcx> = FnvHashMap<Constraint, SubregionOrigin<'tcx>>;\n \n-fn dump_region_constraints_to<'a, 'tcx: 'a>(tcx: TyCtxt<'a, 'tcx>,\n+fn dump_region_constraints_to<'a, 'tcx: 'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                             map: &ConstraintMap<'tcx>,\n                                             path: &str)\n                                             -> io::Result<()> {"}, {"sha": "3e231f8bb3ec07084ca00e00d65bb2f71e4ebea1", "filename": "src/librustc/infer/region_inference/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fregion_inference%2Fmod.rs?ref=76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4", "patch": "@@ -191,7 +191,7 @@ impl SameRegions {\n pub type CombineMap = FnvHashMap<TwoRegions, RegionVid>;\n \n pub struct RegionVarBindings<'a, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'tcx>,\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     var_origins: RefCell<Vec<RegionVariableOrigin>>,\n \n     // Constraints of the form `A <= B` introduced by the region\n@@ -254,7 +254,7 @@ pub struct RegionSnapshot {\n }\n \n impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n-    pub fn new(tcx: TyCtxt<'a, 'tcx>) -> RegionVarBindings<'a, 'tcx> {\n+    pub fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> RegionVarBindings<'a, 'tcx> {\n         RegionVarBindings {\n             tcx: tcx,\n             var_origins: RefCell::new(Vec::new()),\n@@ -1363,15 +1363,15 @@ impl<'tcx> fmt::Display for GenericKind<'tcx> {\n }\n \n impl<'a, 'tcx> GenericKind<'tcx> {\n-    pub fn to_ty(&self, tcx: TyCtxt<'a, 'tcx>) -> Ty<'tcx> {\n+    pub fn to_ty(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Ty<'tcx> {\n         match *self {\n             GenericKind::Param(ref p) => p.to_ty(tcx),\n             GenericKind::Projection(ref p) => tcx.mk_projection(p.trait_ref.clone(), p.item_name),\n         }\n     }\n }\n \n-impl VerifyBound {\n+impl<'a, 'tcx> VerifyBound {\n     fn for_each_region(&self, f: &mut FnMut(ty::Region)) {\n         match self {\n             &VerifyBound::AnyRegion(ref rs) |\n@@ -1424,7 +1424,7 @@ impl VerifyBound {\n         }\n     }\n \n-    fn is_met(&self, tcx: TyCtxt,\n+    fn is_met(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n               free_regions: &FreeRegionMap,\n               var_values: &Vec<VarValue>,\n               min: ty::Region)"}, {"sha": "af5341e56ee291fd0b865265dbb3e800ac8d7207", "filename": "src/librustc/infer/resolve.rs", "status": "modified", "additions": 18, "deletions": 17, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc%2Finfer%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc%2Finfer%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fresolve.rs?ref=76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4", "patch": "@@ -19,18 +19,18 @@ use ty::{self, Ty, TyCtxt, TypeFoldable};\n /// been unified with (similar to `shallow_resolve`, but deep). This is\n /// useful for printing messages etc but also required at various\n /// points for correctness.\n-pub struct OpportunisticTypeResolver<'a, 'tcx:'a> {\n-    infcx: &'a InferCtxt<'a, 'tcx>,\n+pub struct OpportunisticTypeResolver<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n+    infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n }\n \n-impl<'a, 'tcx> OpportunisticTypeResolver<'a, 'tcx> {\n-    pub fn new(infcx: &'a InferCtxt<'a, 'tcx>) -> OpportunisticTypeResolver<'a, 'tcx> {\n+impl<'a, 'tcx> OpportunisticTypeResolver<'a, 'tcx, 'tcx> {\n+    pub fn new(infcx: &'a InferCtxt<'a, 'tcx, 'tcx>) -> OpportunisticTypeResolver<'a, 'tcx, 'tcx> {\n         OpportunisticTypeResolver { infcx: infcx }\n     }\n }\n \n-impl<'a, 'tcx> ty::fold::TypeFolder<'tcx> for OpportunisticTypeResolver<'a, 'tcx> {\n-    fn tcx<'b>(&'b self) -> TyCtxt<'b, 'tcx> {\n+impl<'a, 'tcx> ty::fold::TypeFolder<'tcx> for OpportunisticTypeResolver<'a, 'tcx, 'tcx> {\n+    fn tcx<'b>(&'b self) -> TyCtxt<'b, 'tcx, 'tcx> {\n         self.infcx.tcx\n     }\n \n@@ -47,18 +47,18 @@ impl<'a, 'tcx> ty::fold::TypeFolder<'tcx> for OpportunisticTypeResolver<'a, 'tcx\n /// The opportunistic type and region resolver is similar to the\n /// opportunistic type resolver, but also opportunistly resolves\n /// regions. It is useful for canonicalization.\n-pub struct OpportunisticTypeAndRegionResolver<'a, 'tcx:'a> {\n-    infcx: &'a InferCtxt<'a, 'tcx>,\n+pub struct OpportunisticTypeAndRegionResolver<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n+    infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n }\n \n-impl<'a, 'tcx> OpportunisticTypeAndRegionResolver<'a, 'tcx> {\n-    pub fn new(infcx: &'a InferCtxt<'a, 'tcx>) -> Self {\n+impl<'a, 'tcx> OpportunisticTypeAndRegionResolver<'a, 'tcx, 'tcx> {\n+    pub fn new(infcx: &'a InferCtxt<'a, 'tcx, 'tcx>) -> Self {\n         OpportunisticTypeAndRegionResolver { infcx: infcx }\n     }\n }\n \n-impl<'a, 'tcx> ty::fold::TypeFolder<'tcx> for OpportunisticTypeAndRegionResolver<'a, 'tcx> {\n-    fn tcx<'b>(&'b self) -> TyCtxt<'b, 'tcx> {\n+impl<'a, 'tcx> ty::fold::TypeFolder<'tcx> for OpportunisticTypeAndRegionResolver<'a, 'tcx, 'tcx> {\n+    fn tcx<'b>(&'b self) -> TyCtxt<'b, 'tcx, 'tcx> {\n         self.infcx.tcx\n     }\n \n@@ -85,7 +85,8 @@ impl<'a, 'tcx> ty::fold::TypeFolder<'tcx> for OpportunisticTypeAndRegionResolver\n /// Full type resolution replaces all type and region variables with\n /// their concrete results. If any variable cannot be replaced (never unified, etc)\n /// then an `Err` result is returned.\n-pub fn fully_resolve<'a, 'tcx, T>(infcx: &InferCtxt<'a,'tcx>, value: &T) -> FixupResult<T>\n+pub fn fully_resolve<'a, 'tcx, T>(infcx: &InferCtxt<'a, 'tcx, 'tcx>,\n+                                  value: &T) -> FixupResult<T>\n     where T : TypeFoldable<'tcx>\n {\n     let mut full_resolver = FullTypeResolver { infcx: infcx, err: None };\n@@ -98,13 +99,13 @@ pub fn fully_resolve<'a, 'tcx, T>(infcx: &InferCtxt<'a,'tcx>, value: &T) -> Fixu\n \n // N.B. This type is not public because the protocol around checking the\n // `err` field is not enforcable otherwise.\n-struct FullTypeResolver<'a, 'tcx:'a> {\n-    infcx: &'a InferCtxt<'a, 'tcx>,\n+struct FullTypeResolver<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n+    infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n     err: Option<FixupError>,\n }\n \n-impl<'a, 'tcx> ty::fold::TypeFolder<'tcx> for FullTypeResolver<'a, 'tcx> {\n-    fn tcx<'b>(&'b self) -> TyCtxt<'b, 'tcx> {\n+impl<'a, 'tcx> ty::fold::TypeFolder<'tcx> for FullTypeResolver<'a, 'tcx, 'tcx> {\n+    fn tcx<'b>(&'b self) -> TyCtxt<'b, 'tcx, 'tcx> {\n         self.infcx.tcx\n     }\n "}, {"sha": "969ae1e0bd1b9204181a20682efff4a60f0002ba", "filename": "src/librustc/infer/sub.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fsub.rs?ref=76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4", "patch": "@@ -20,12 +20,12 @@ use traits::PredicateObligations;\n use std::mem;\n \n /// Ensures `a` is made a subtype of `b`. Returns `a` on success.\n-pub struct Sub<'a, 'tcx: 'a> {\n-    fields: CombineFields<'a, 'tcx>,\n+pub struct Sub<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n+    fields: CombineFields<'a, 'gcx, 'tcx>,\n }\n \n-impl<'a, 'tcx> Sub<'a, 'tcx> {\n-    pub fn new(f: CombineFields<'a, 'tcx>) -> Sub<'a, 'tcx> {\n+impl<'a, 'tcx> Sub<'a, 'tcx, 'tcx> {\n+    pub fn new(f: CombineFields<'a, 'tcx, 'tcx>) -> Sub<'a, 'tcx, 'tcx> {\n         Sub { fields: f }\n     }\n \n@@ -34,9 +34,9 @@ impl<'a, 'tcx> Sub<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> TypeRelation<'a, 'tcx> for Sub<'a, 'tcx> {\n+impl<'a, 'tcx> TypeRelation<'a, 'tcx> for Sub<'a, 'tcx, 'tcx> {\n     fn tag(&self) -> &'static str { \"Sub\" }\n-    fn tcx(&self) -> TyCtxt<'a, 'tcx> { self.fields.infcx.tcx }\n+    fn tcx(&self) -> TyCtxt<'a, 'tcx, 'tcx> { self.fields.infcx.tcx }\n     fn a_is_expected(&self) -> bool { self.fields.a_is_expected }\n \n     fn with_cause<F,R>(&mut self, cause: Cause, f: F) -> R"}, {"sha": "922bbbc1b4cf99918d376a7d92515ef3ebf857fd", "filename": "src/librustc/infer/unify_key.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc%2Finfer%2Funify_key.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc%2Finfer%2Funify_key.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Funify_key.rs?ref=76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4", "patch": "@@ -13,7 +13,7 @@ use ty::{self, IntVarValue, Ty, TyCtxt};\n use rustc_data_structures::unify::{Combine, UnifyKey};\n \n pub trait ToType<'tcx> {\n-    fn to_type<'a>(&self, tcx: TyCtxt<'a, 'tcx>) -> Ty<'tcx>;\n+    fn to_type<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Ty<'tcx>;\n }\n \n impl UnifyKey for ty::IntVid {\n@@ -51,7 +51,7 @@ impl UnifyKey for ty::RegionVid {\n }\n \n impl<'tcx> ToType<'tcx> for IntVarValue {\n-    fn to_type<'a>(&self, tcx: TyCtxt<'a, 'tcx>) -> Ty<'tcx> {\n+    fn to_type<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Ty<'tcx> {\n         match *self {\n             ty::IntType(i) => tcx.mk_mach_int(i),\n             ty::UintType(i) => tcx.mk_mach_uint(i),\n@@ -69,7 +69,7 @@ impl UnifyKey for ty::FloatVid {\n }\n \n impl<'tcx> ToType<'tcx> for ast::FloatTy {\n-    fn to_type<'a>(&self, tcx: TyCtxt<'a, 'tcx>) -> Ty<'tcx> {\n+    fn to_type<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Ty<'tcx> {\n         tcx.mk_mach_float(*self)\n     }\n }"}, {"sha": "a4b9b5f45563f4e18f864e6a45acc73514b6d680", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4", "patch": "@@ -297,7 +297,7 @@ impl LintStore {\n /// Context for lint checking after type checking.\n pub struct LateContext<'a, 'tcx: 'a> {\n     /// Type context we're checking in.\n-    pub tcx: TyCtxt<'a, 'tcx>,\n+    pub tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     /// The crate being checked.\n     pub krate: &'a hir::Crate,\n@@ -652,7 +652,7 @@ impl<'a> EarlyContext<'a> {\n }\n \n impl<'a, 'tcx> LateContext<'a, 'tcx> {\n-    fn new(tcx: TyCtxt<'a, 'tcx>,\n+    fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n            krate: &'a hir::Crate,\n            access_levels: &'a AccessLevels) -> LateContext<'a, 'tcx> {\n         // We want to own the lint store, so move it out of the session.\n@@ -1220,7 +1220,8 @@ fn check_lint_name_cmdline(sess: &Session, lint_cx: &LintStore,\n /// Perform lint checking on a crate.\n ///\n /// Consumes the `lint_store` field of the `Session`.\n-pub fn check_crate(tcx: TyCtxt, access_levels: &AccessLevels) {\n+pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                             access_levels: &AccessLevels) {\n     let _task = tcx.dep_graph.in_task(DepNode::LateLintCheck);\n \n     let krate = tcx.map.krate();"}, {"sha": "99521f9ef0ff994494df98156bffc2bd3df5a4a7", "filename": "src/librustc/middle/astconv_util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc%2Fmiddle%2Fastconv_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc%2Fmiddle%2Fastconv_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastconv_util.rs?ref=76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4", "patch": "@@ -20,7 +20,7 @@ use ty::{Ty, TyCtxt};\n use syntax::codemap::Span;\n use hir as ast;\n \n-impl<'a, 'tcx> TyCtxt<'a, 'tcx> {\n+impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n pub fn prohibit_type_params(self, segments: &[ast::PathSegment]) {\n     for segment in segments {\n         for typ in segment.parameters.types() {"}, {"sha": "c0af457ed236c3bcdc733dd38b2ee86589d95b5f", "filename": "src/librustc/middle/cstore.rs", "status": "modified", "additions": 36, "deletions": 36, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcstore.rs?ref=76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4", "patch": "@@ -161,55 +161,55 @@ pub trait CrateStore<'tcx> : Any {\n     fn deprecation(&self, def: DefId) -> Option<attr::Deprecation>;\n     fn visibility(&self, def: DefId) -> ty::Visibility;\n     fn closure_kind(&self, def_id: DefId) -> ty::ClosureKind;\n-    fn closure_ty<'a>(&self, tcx: TyCtxt<'a, 'tcx>, def_id: DefId)\n+    fn closure_ty<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId)\n                       -> ty::ClosureTy<'tcx>;\n     fn item_variances(&self, def: DefId) -> ty::ItemVariances;\n     fn repr_attrs(&self, def: DefId) -> Vec<attr::ReprAttr>;\n-    fn item_type<'a>(&self, tcx: TyCtxt<'a, 'tcx>, def: DefId)\n+    fn item_type<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n                      -> ty::TypeScheme<'tcx>;\n     fn visible_parent_map<'a>(&'a self) -> ::std::cell::RefMut<'a, DefIdMap<DefId>>;\n     fn item_name(&self, def: DefId) -> ast::Name;\n-    fn item_predicates<'a>(&self, tcx: TyCtxt<'a, 'tcx>, def: DefId)\n+    fn item_predicates<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n                            -> ty::GenericPredicates<'tcx>;\n-    fn item_super_predicates<'a>(&self, tcx: TyCtxt<'a, 'tcx>, def: DefId)\n+    fn item_super_predicates<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n                                  -> ty::GenericPredicates<'tcx>;\n     fn item_attrs(&self, def_id: DefId) -> Vec<ast::Attribute>;\n     fn item_symbol(&self, def: DefId) -> String;\n-    fn trait_def<'a>(&self, tcx: TyCtxt<'a, 'tcx>, def: DefId)-> ty::TraitDef<'tcx>;\n-    fn adt_def<'a>(&self, tcx: TyCtxt<'a, 'tcx>, def: DefId) -> ty::AdtDefMaster<'tcx>;\n+    fn trait_def<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)-> ty::TraitDef<'tcx>;\n+    fn adt_def<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId) -> ty::AdtDefMaster<'tcx>;\n     fn method_arg_names(&self, did: DefId) -> Vec<String>;\n     fn inherent_implementations_for_type(&self, def_id: DefId) -> Vec<DefId>;\n \n     // trait info\n     fn implementations_of_trait(&self, def_id: DefId) -> Vec<DefId>;\n-    fn provided_trait_methods<'a>(&self, tcx: TyCtxt<'a, 'tcx>, def: DefId)\n+    fn provided_trait_methods<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n                                   -> Vec<Rc<ty::Method<'tcx>>>;\n     fn trait_item_def_ids(&self, def: DefId)\n                           -> Vec<ty::ImplOrTraitItemId>;\n \n     // impl info\n     fn impl_items(&self, impl_def_id: DefId) -> Vec<ty::ImplOrTraitItemId>;\n-    fn impl_trait_ref<'a>(&self, tcx: TyCtxt<'a, 'tcx>, def: DefId)\n+    fn impl_trait_ref<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n                           -> Option<ty::TraitRef<'tcx>>;\n     fn impl_polarity(&self, def: DefId) -> Option<hir::ImplPolarity>;\n     fn custom_coerce_unsized_kind(&self, def: DefId)\n                                   -> Option<ty::adjustment::CustomCoerceUnsized>;\n-    fn associated_consts<'a>(&self, tcx: TyCtxt<'a, 'tcx>, def: DefId)\n+    fn associated_consts<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n                              -> Vec<Rc<ty::AssociatedConst<'tcx>>>;\n     fn impl_parent(&self, impl_def_id: DefId) -> Option<DefId>;\n \n     // trait/impl-item info\n-    fn trait_of_item<'a>(&self, tcx: TyCtxt<'a, 'tcx>, def_id: DefId)\n+    fn trait_of_item<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId)\n                          -> Option<DefId>;\n-    fn impl_or_trait_item<'a>(&self, tcx: TyCtxt<'a, 'tcx>, def: DefId)\n+    fn impl_or_trait_item<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n                               -> Option<ty::ImplOrTraitItem<'tcx>>;\n \n     // flags\n     fn is_const_fn(&self, did: DefId) -> bool;\n     fn is_defaulted_trait(&self, did: DefId) -> bool;\n     fn is_impl(&self, did: DefId) -> bool;\n     fn is_default_impl(&self, impl_did: DefId) -> bool;\n-    fn is_extern_item<'a>(&self, tcx: TyCtxt<'a, 'tcx>, did: DefId) -> bool;\n+    fn is_extern_item<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, did: DefId) -> bool;\n     fn is_static_method(&self, did: DefId) -> bool;\n     fn is_statically_included_foreign_item(&self, id: ast::NodeId) -> bool;\n     fn is_typedef(&self, did: DefId) -> bool;\n@@ -250,9 +250,9 @@ pub trait CrateStore<'tcx> : Any {\n     fn crate_top_level_items(&self, cnum: ast::CrateNum) -> Vec<ChildItem>;\n \n     // misc. metadata\n-    fn maybe_get_item_ast<'a>(&'tcx self, tcx: TyCtxt<'a, 'tcx>, def: DefId)\n+    fn maybe_get_item_ast<'a>(&'tcx self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n                               -> FoundAst<'tcx>;\n-    fn maybe_get_item_mir<'a>(&self, tcx: TyCtxt<'a, 'tcx>, def: DefId)\n+    fn maybe_get_item_mir<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n                               -> Option<Mir<'tcx>>;\n     fn is_item_mir_available(&self, def: DefId) -> bool;\n \n@@ -266,14 +266,14 @@ pub trait CrateStore<'tcx> : Any {\n     fn metadata_filename(&self) -> &str;\n     fn metadata_section_name(&self, target: &Target) -> &str;\n     fn encode_type<'a>(&self,\n-                       tcx: TyCtxt<'a, 'tcx>,\n+                       tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                        ty: Ty<'tcx>,\n-                       def_id_to_string: for<'b> fn(TyCtxt<'b, 'tcx>, DefId) -> String)\n+                       def_id_to_string: for<'b> fn(TyCtxt<'b, 'tcx, 'tcx>, DefId) -> String)\n                        -> Vec<u8>;\n     fn used_crates(&self, prefer: LinkagePreference) -> Vec<(ast::CrateNum, Option<PathBuf>)>;\n     fn used_crate_source(&self, cnum: ast::CrateNum) -> CrateSource;\n     fn extern_mod_stmt_cnum(&self, emod_id: ast::NodeId) -> Option<ast::CrateNum>;\n-    fn encode_metadata<'a>(&self, tcx: TyCtxt<'a, 'tcx>,\n+    fn encode_metadata<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                            reexports: &def::ExportMap,\n                            item_symbols: &RefCell<NodeMap<String>>,\n                            link_meta: &LinkMeta,\n@@ -338,61 +338,61 @@ impl<'tcx> CrateStore<'tcx> for DummyCrateStore {\n     fn deprecation(&self, def: DefId) -> Option<attr::Deprecation> { bug!(\"deprecation\") }\n     fn visibility(&self, def: DefId) -> ty::Visibility { bug!(\"visibility\") }\n     fn closure_kind(&self, def_id: DefId) -> ty::ClosureKind  { bug!(\"closure_kind\") }\n-    fn closure_ty<'a>(&self, tcx: TyCtxt<'a, 'tcx>, def_id: DefId)\n+    fn closure_ty<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId)\n                       -> ty::ClosureTy<'tcx>  { bug!(\"closure_ty\") }\n     fn item_variances(&self, def: DefId) -> ty::ItemVariances { bug!(\"item_variances\") }\n     fn repr_attrs(&self, def: DefId) -> Vec<attr::ReprAttr> { bug!(\"repr_attrs\") }\n-    fn item_type<'a>(&self, tcx: TyCtxt<'a, 'tcx>, def: DefId)\n+    fn item_type<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n                      -> ty::TypeScheme<'tcx> { bug!(\"item_type\") }\n     fn visible_parent_map<'a>(&'a self) -> ::std::cell::RefMut<'a, DefIdMap<DefId>> {\n         bug!(\"visible_parent_map\")\n     }\n     fn item_name(&self, def: DefId) -> ast::Name { bug!(\"item_name\") }\n-    fn item_predicates<'a>(&self, tcx: TyCtxt<'a, 'tcx>, def: DefId)\n+    fn item_predicates<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n                            -> ty::GenericPredicates<'tcx> { bug!(\"item_predicates\") }\n-    fn item_super_predicates<'a>(&self, tcx: TyCtxt<'a, 'tcx>, def: DefId)\n+    fn item_super_predicates<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n                                  -> ty::GenericPredicates<'tcx> { bug!(\"item_super_predicates\") }\n     fn item_attrs(&self, def_id: DefId) -> Vec<ast::Attribute> { bug!(\"item_attrs\") }\n     fn item_symbol(&self, def: DefId) -> String { bug!(\"item_symbol\") }\n-    fn trait_def<'a>(&self, tcx: TyCtxt<'a, 'tcx>, def: DefId)-> ty::TraitDef<'tcx>\n+    fn trait_def<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)-> ty::TraitDef<'tcx>\n         { bug!(\"trait_def\") }\n-    fn adt_def<'a>(&self, tcx: TyCtxt<'a, 'tcx>, def: DefId) -> ty::AdtDefMaster<'tcx>\n+    fn adt_def<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId) -> ty::AdtDefMaster<'tcx>\n         { bug!(\"adt_def\") }\n     fn method_arg_names(&self, did: DefId) -> Vec<String> { bug!(\"method_arg_names\") }\n     fn inherent_implementations_for_type(&self, def_id: DefId) -> Vec<DefId> { vec![] }\n \n     // trait info\n     fn implementations_of_trait(&self, def_id: DefId) -> Vec<DefId> { vec![] }\n-    fn provided_trait_methods<'a>(&self, tcx: TyCtxt<'a, 'tcx>, def: DefId)\n+    fn provided_trait_methods<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n                                   -> Vec<Rc<ty::Method<'tcx>>> { bug!(\"provided_trait_methods\") }\n     fn trait_item_def_ids(&self, def: DefId)\n                           -> Vec<ty::ImplOrTraitItemId> { bug!(\"trait_item_def_ids\") }\n \n     // impl info\n     fn impl_items(&self, impl_def_id: DefId) -> Vec<ty::ImplOrTraitItemId>\n         { bug!(\"impl_items\") }\n-    fn impl_trait_ref<'a>(&self, tcx: TyCtxt<'a, 'tcx>, def: DefId)\n+    fn impl_trait_ref<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n                           -> Option<ty::TraitRef<'tcx>> { bug!(\"impl_trait_ref\") }\n     fn impl_polarity(&self, def: DefId) -> Option<hir::ImplPolarity> { bug!(\"impl_polarity\") }\n     fn custom_coerce_unsized_kind(&self, def: DefId)\n                                   -> Option<ty::adjustment::CustomCoerceUnsized>\n         { bug!(\"custom_coerce_unsized_kind\") }\n-    fn associated_consts<'a>(&self, tcx: TyCtxt<'a, 'tcx>, def: DefId)\n+    fn associated_consts<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n                              -> Vec<Rc<ty::AssociatedConst<'tcx>>> { bug!(\"associated_consts\") }\n     fn impl_parent(&self, def: DefId) -> Option<DefId> { bug!(\"impl_parent\") }\n \n     // trait/impl-item info\n-    fn trait_of_item<'a>(&self, tcx: TyCtxt<'a, 'tcx>, def_id: DefId)\n+    fn trait_of_item<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId)\n                          -> Option<DefId> { bug!(\"trait_of_item\") }\n-    fn impl_or_trait_item<'a>(&self, tcx: TyCtxt<'a, 'tcx>, def: DefId)\n+    fn impl_or_trait_item<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n                               -> Option<ty::ImplOrTraitItem<'tcx>> { bug!(\"impl_or_trait_item\") }\n \n     // flags\n     fn is_const_fn(&self, did: DefId) -> bool { bug!(\"is_const_fn\") }\n     fn is_defaulted_trait(&self, did: DefId) -> bool { bug!(\"is_defaulted_trait\") }\n     fn is_impl(&self, did: DefId) -> bool { bug!(\"is_impl\") }\n     fn is_default_impl(&self, impl_did: DefId) -> bool { bug!(\"is_default_impl\") }\n-    fn is_extern_item<'a>(&self, tcx: TyCtxt<'a, 'tcx>, did: DefId) -> bool\n+    fn is_extern_item<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, did: DefId) -> bool\n         { bug!(\"is_extern_item\") }\n     fn is_static_method(&self, did: DefId) -> bool { bug!(\"is_static_method\") }\n     fn is_statically_included_foreign_item(&self, id: ast::NodeId) -> bool { false }\n@@ -446,9 +446,9 @@ impl<'tcx> CrateStore<'tcx> for DummyCrateStore {\n         { bug!(\"crate_top_level_items\") }\n \n     // misc. metadata\n-    fn maybe_get_item_ast<'a>(&'tcx self, tcx: TyCtxt<'a, 'tcx>, def: DefId)\n+    fn maybe_get_item_ast<'a>(&'tcx self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n                               -> FoundAst<'tcx> { bug!(\"maybe_get_item_ast\") }\n-    fn maybe_get_item_mir<'a>(&self, tcx: TyCtxt<'a, 'tcx>, def: DefId)\n+    fn maybe_get_item_mir<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n                               -> Option<Mir<'tcx>> { bug!(\"maybe_get_item_mir\") }\n     fn is_item_mir_available(&self, def: DefId) -> bool {\n         bug!(\"is_item_mir_available\")\n@@ -464,17 +464,17 @@ impl<'tcx> CrateStore<'tcx> for DummyCrateStore {\n     fn metadata_filename(&self) -> &str { bug!(\"metadata_filename\") }\n     fn metadata_section_name(&self, target: &Target) -> &str { bug!(\"metadata_section_name\") }\n     fn encode_type<'a>(&self,\n-                       tcx: TyCtxt<'a, 'tcx>,\n+                       tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                        ty: Ty<'tcx>,\n-                       def_id_to_string: for<'b> fn(TyCtxt<'b, 'tcx>, DefId) -> String)\n+                       def_id_to_string: for<'b> fn(TyCtxt<'b, 'tcx, 'tcx>, DefId) -> String)\n                        -> Vec<u8> {\n         bug!(\"encode_type\")\n     }\n     fn used_crates(&self, prefer: LinkagePreference) -> Vec<(ast::CrateNum, Option<PathBuf>)>\n         { vec![] }\n     fn used_crate_source(&self, cnum: ast::CrateNum) -> CrateSource { bug!(\"used_crate_source\") }\n     fn extern_mod_stmt_cnum(&self, emod_id: ast::NodeId) -> Option<ast::CrateNum> { None }\n-    fn encode_metadata<'a>(&self, tcx: TyCtxt<'a, 'tcx>,\n+    fn encode_metadata<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                            reexports: &def::ExportMap,\n                            item_symbols: &RefCell<NodeMap<String>>,\n                            link_meta: &LinkMeta,\n@@ -507,7 +507,7 @@ pub mod tls {\n     use hir::def_id::DefId;\n \n     pub trait EncodingContext<'tcx> {\n-        fn tcx<'a>(&'a self) -> TyCtxt<'a, 'tcx>;\n+        fn tcx<'a>(&'a self) -> TyCtxt<'a, 'tcx, 'tcx>;\n         fn encode_ty(&self, encoder: &mut OpaqueEncoder, t: Ty<'tcx>);\n         fn encode_substs(&self, encoder: &mut OpaqueEncoder, substs: &Substs<'tcx>);\n     }\n@@ -574,7 +574,7 @@ pub mod tls {\n     }\n \n     pub trait DecodingContext<'tcx> {\n-        fn tcx<'a>(&'a self) -> TyCtxt<'a, 'tcx>;\n+        fn tcx<'a>(&'a self) -> TyCtxt<'a, 'tcx, 'tcx>;\n         fn decode_ty(&self, decoder: &mut OpaqueDecoder) -> ty::Ty<'tcx>;\n         fn decode_substs(&self, decoder: &mut OpaqueDecoder) -> Substs<'tcx>;\n         fn translate_def_id(&self, def_id: DefId) -> DefId;"}, {"sha": "41b27a48b29f8b789775eb60b7e09d1ed4a2dd6a", "filename": "src/librustc/middle/dataflow.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdataflow.rs?ref=76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4", "patch": "@@ -37,7 +37,7 @@ pub enum EntryOrExit {\n \n #[derive(Clone)]\n pub struct DataFlowContext<'a, 'tcx: 'a, O> {\n-    tcx: TyCtxt<'a, 'tcx>,\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     /// a name for the analysis using this dataflow instance\n     analysis_name: &'static str,\n@@ -222,7 +222,7 @@ pub enum KillFrom {\n }\n \n impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n-    pub fn new(tcx: TyCtxt<'a, 'tcx>,\n+    pub fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                analysis_name: &'static str,\n                decl: Option<&hir::FnDecl>,\n                cfg: &cfg::CFG,"}, {"sha": "cc6b83fccf92cdd5e8813a9d5323dc8ddd7c7dc6", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 15, "deletions": 12, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4", "patch": "@@ -31,7 +31,8 @@ use syntax::attr;\n // explored. For example, if it's a live NodeItem that is a\n // function, then we should explore its block to check for codes that\n // may need to be marked as live.\n-fn should_explore(tcx: TyCtxt, node_id: ast::NodeId) -> bool {\n+fn should_explore<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                            node_id: ast::NodeId) -> bool {\n     match tcx.map.find(node_id) {\n         Some(ast_map::NodeItem(..)) |\n         Some(ast_map::NodeImplItem(..)) |\n@@ -45,7 +46,7 @@ fn should_explore(tcx: TyCtxt, node_id: ast::NodeId) -> bool {\n \n struct MarkSymbolVisitor<'a, 'tcx: 'a> {\n     worklist: Vec<ast::NodeId>,\n-    tcx: TyCtxt<'a, 'tcx>,\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     live_symbols: Box<HashSet<ast::NodeId>>,\n     struct_has_extern_repr: bool,\n     ignore_non_const_paths: bool,\n@@ -54,7 +55,7 @@ struct MarkSymbolVisitor<'a, 'tcx: 'a> {\n }\n \n impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n-    fn new(tcx: TyCtxt<'a, 'tcx>,\n+    fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n            worklist: Vec<ast::NodeId>) -> MarkSymbolVisitor<'a, 'tcx> {\n         MarkSymbolVisitor {\n             worklist: worklist,\n@@ -362,9 +363,10 @@ impl<'v> Visitor<'v> for LifeSeeder {\n     }\n }\n \n-fn create_and_seed_worklist(tcx: TyCtxt,\n-                            access_levels: &privacy::AccessLevels,\n-                            krate: &hir::Crate) -> Vec<ast::NodeId> {\n+fn create_and_seed_worklist<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                      access_levels: &privacy::AccessLevels,\n+                                      krate: &hir::Crate)\n+                                      -> Vec<ast::NodeId> {\n     let mut worklist = Vec::new();\n     for (id, _) in &access_levels.map {\n         worklist.push(*id);\n@@ -385,10 +387,10 @@ fn create_and_seed_worklist(tcx: TyCtxt,\n     return life_seeder.worklist;\n }\n \n-fn find_live(tcx: TyCtxt,\n-             access_levels: &privacy::AccessLevels,\n-             krate: &hir::Crate)\n-             -> Box<HashSet<ast::NodeId>> {\n+fn find_live<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                       access_levels: &privacy::AccessLevels,\n+                       krate: &hir::Crate)\n+                       -> Box<HashSet<ast::NodeId>> {\n     let worklist = create_and_seed_worklist(tcx, access_levels, krate);\n     let mut symbol_visitor = MarkSymbolVisitor::new(tcx, worklist);\n     symbol_visitor.mark_live_symbols();\n@@ -405,7 +407,7 @@ fn get_struct_ctor_id(item: &hir::Item) -> Option<ast::NodeId> {\n }\n \n struct DeadVisitor<'a, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'tcx>,\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     live_symbols: Box<HashSet<ast::NodeId>>,\n }\n \n@@ -583,7 +585,8 @@ impl<'a, 'tcx, 'v> Visitor<'v> for DeadVisitor<'a, 'tcx> {\n     }\n }\n \n-pub fn check_crate(tcx: TyCtxt, access_levels: &privacy::AccessLevels) {\n+pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                             access_levels: &privacy::AccessLevels) {\n     let _task = tcx.dep_graph.in_task(DepNode::DeadCheck);\n     let krate = tcx.map.krate();\n     let live_symbols = find_live(tcx, access_levels, krate);"}, {"sha": "b62368c2a98781e33b2ad5d9dfef2fe887dfb299", "filename": "src/librustc/middle/effect.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc%2Fmiddle%2Feffect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc%2Fmiddle%2Feffect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Feffect.rs?ref=76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4", "patch": "@@ -51,7 +51,7 @@ fn type_is_unsafe_function(ty: Ty) -> bool {\n }\n \n struct EffectCheckVisitor<'a, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'tcx>,\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     /// Whether we're in an unsafe context.\n     unsafe_context: UnsafeContext,\n@@ -183,7 +183,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EffectCheckVisitor<'a, 'tcx> {\n     }\n }\n \n-pub fn check_crate(tcx: TyCtxt) {\n+pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     let _task = tcx.dep_graph.in_task(DepNode::EffectCheck);\n \n     let mut visitor = EffectCheckVisitor {"}, {"sha": "3c813dffb0a414aaa1341a8894bf31d7cd12f24b", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 38, "deletions": 39, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4", "patch": "@@ -22,7 +22,7 @@ use self::OverloadedCallType::*;\n use hir::pat_util;\n use hir::def::Def;\n use hir::def_id::{DefId};\n-use infer;\n+use infer::InferCtxt;\n use middle::mem_categorization as mc;\n use ty::{self, TyCtxt, adjustment};\n \n@@ -209,8 +209,8 @@ enum OverloadedCallType {\n }\n \n impl OverloadedCallType {\n-    fn from_trait_id(tcx: TyCtxt, trait_id: DefId)\n-                     -> OverloadedCallType {\n+    fn from_trait_id<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, trait_id: DefId)\n+                               -> OverloadedCallType {\n         for &(maybe_function_trait, overloaded_call_type) in &[\n             (tcx.lang_items.fn_once_trait(), FnOnceOverloadedCall),\n             (tcx.lang_items.fn_mut_trait(), FnMutOverloadedCall),\n@@ -227,8 +227,8 @@ impl OverloadedCallType {\n         bug!(\"overloaded call didn't map to known function trait\")\n     }\n \n-    fn from_method_id(tcx: TyCtxt, method_id: DefId)\n-                      -> OverloadedCallType {\n+    fn from_method_id<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, method_id: DefId)\n+                                -> OverloadedCallType {\n         let method = tcx.impl_or_trait_item(method_id);\n         OverloadedCallType::from_trait_id(tcx, method.container().id())\n     }\n@@ -241,9 +241,8 @@ impl OverloadedCallType {\n // mem_categorization, it requires a TYPER, which is a type that\n // supplies types from the tree. After type checking is complete, you\n // can just use the tcx as the typer.\n-pub struct ExprUseVisitor<'d, 't, 'a: 't, 'tcx:'a+'d> {\n-    typer: &'t infer::InferCtxt<'a, 'tcx>,\n-    mc: mc::MemCategorizationContext<'t, 'a, 'tcx>,\n+pub struct ExprUseVisitor<'d, 'a, 'gcx: 'a+'tcx, 'tcx:'a+'d> {\n+    mc: mc::MemCategorizationContext<'a, 'gcx, 'tcx>,\n     delegate: &'d mut Delegate<'tcx>,\n }\n \n@@ -272,14 +271,14 @@ enum PassArgs {\n     ByRef,\n }\n \n-impl<'d,'t,'a,'tcx> ExprUseVisitor<'d,'t,'a,'tcx> {\n+impl<'d, 'a, 'tcx> ExprUseVisitor<'d, 'a, 'tcx, 'tcx> {\n     pub fn new(delegate: &'d mut (Delegate<'tcx>+'d),\n-               typer: &'t infer::InferCtxt<'a, 'tcx>)\n-               -> ExprUseVisitor<'d,'t,'a,'tcx> where 'tcx:'a+'d\n+               infcx: &'a InferCtxt<'a, 'tcx, 'tcx>) -> Self\n     {\n-        let mc: mc::MemCategorizationContext<'t, 'a, 'tcx> =\n-            mc::MemCategorizationContext::new(typer);\n-        ExprUseVisitor { typer: typer, mc: mc, delegate: delegate }\n+        ExprUseVisitor {\n+            mc: mc::MemCategorizationContext::new(infcx),\n+            delegate: delegate\n+        }\n     }\n \n     pub fn walk_fn(&mut self,\n@@ -293,7 +292,7 @@ impl<'d,'t,'a,'tcx> ExprUseVisitor<'d,'t,'a,'tcx> {\n                          decl: &hir::FnDecl,\n                          body: &hir::Block) {\n         for arg in &decl.inputs {\n-            let arg_ty = return_if_err!(self.typer.node_ty(arg.pat.id));\n+            let arg_ty = return_if_err!(self.mc.infcx.node_ty(arg.pat.id));\n \n             let fn_body_scope = self.tcx().region_maps.node_extent(body.id);\n             let arg_cmt = self.mc.cat_rvalue(\n@@ -306,8 +305,8 @@ impl<'d,'t,'a,'tcx> ExprUseVisitor<'d,'t,'a,'tcx> {\n         }\n     }\n \n-    fn tcx(&self) -> TyCtxt<'t, 'tcx> {\n-        self.typer.tcx\n+    fn tcx(&self) -> TyCtxt<'a, 'tcx, 'tcx> {\n+        self.mc.infcx.tcx\n     }\n \n     fn delegate_consume(&mut self,\n@@ -317,7 +316,7 @@ impl<'d,'t,'a,'tcx> ExprUseVisitor<'d,'t,'a,'tcx> {\n         debug!(\"delegate_consume(consume_id={}, cmt={:?})\",\n                consume_id, cmt);\n \n-        let mode = copy_or_move(self.typer, &cmt, DirectRefMove);\n+        let mode = copy_or_move(self.mc.infcx, &cmt, DirectRefMove);\n         self.delegate.consume(consume_id, consume_span, cmt, mode);\n     }\n \n@@ -442,7 +441,7 @@ impl<'d,'t,'a,'tcx> ExprUseVisitor<'d,'t,'a,'tcx> {\n             hir::ExprAddrOf(m, ref base) => {   // &base\n                 // make sure that the thing we are pointing out stays valid\n                 // for the lifetime `scope_r` of the resulting ptr:\n-                let expr_ty = return_if_err!(self.typer.node_ty(expr.id));\n+                let expr_ty = return_if_err!(self.mc.infcx.node_ty(expr.id));\n                 if let ty::TyRef(&r, _) = expr_ty.sty {\n                     let bk = ty::BorrowKind::from_mutbl(m);\n                     self.borrow_expr(&base, r, bk, AddrOf);\n@@ -548,7 +547,7 @@ impl<'d,'t,'a,'tcx> ExprUseVisitor<'d,'t,'a,'tcx> {\n     }\n \n     fn walk_callee(&mut self, call: &hir::Expr, callee: &hir::Expr) {\n-        let callee_ty = return_if_err!(self.typer.expr_ty_adjusted(callee));\n+        let callee_ty = return_if_err!(self.mc.infcx.expr_ty_adjusted(callee));\n         debug!(\"walk_callee: callee={:?} callee_ty={:?}\",\n                callee, callee_ty);\n         let call_scope = self.tcx().region_maps.node_extent(call.id);\n@@ -559,7 +558,7 @@ impl<'d,'t,'a,'tcx> ExprUseVisitor<'d,'t,'a,'tcx> {\n             ty::TyError => { }\n             _ => {\n                 let overloaded_call_type =\n-                    match self.typer.node_method_id(ty::MethodCall::expr(call.id)) {\n+                    match self.mc.infcx.node_method_id(ty::MethodCall::expr(call.id)) {\n                         Some(method_id) => {\n                             OverloadedCallType::from_method_id(self.tcx(), method_id)\n                         }\n@@ -615,7 +614,7 @@ impl<'d,'t,'a,'tcx> ExprUseVisitor<'d,'t,'a,'tcx> {\n         match local.init {\n             None => {\n                 let delegate = &mut self.delegate;\n-                pat_util::pat_bindings(&self.typer.tcx.def_map, &local.pat,\n+                pat_util::pat_bindings(&self.mc.infcx.tcx.def_map, &local.pat,\n                                        |_, id, span, _| {\n                     delegate.decl_without_init(id, span);\n                 })\n@@ -707,9 +706,9 @@ impl<'d,'t,'a,'tcx> ExprUseVisitor<'d,'t,'a,'tcx> {\n     // consumed or borrowed as part of the automatic adjustment\n     // process.\n     fn walk_adjustment(&mut self, expr: &hir::Expr) {\n-        let typer = self.typer;\n+        let infcx = self.mc.infcx;\n         //NOTE(@jroesch): mixed RefCell borrow causes crash\n-        let adj = typer.adjustments().get(&expr.id).map(|x| x.clone());\n+        let adj = infcx.adjustments().get(&expr.id).map(|x| x.clone());\n         if let Some(adjustment) = adj {\n             match adjustment {\n                 adjustment::AdjustReifyFnPointer |\n@@ -739,7 +738,7 @@ impl<'d,'t,'a,'tcx> ExprUseVisitor<'d,'t,'a,'tcx> {\n \n         for i in 0..autoderefs {\n             let deref_id = ty::MethodCall::autoderef(expr.id, i as u32);\n-            match self.typer.node_method_ty(deref_id) {\n+            match self.mc.infcx.node_method_ty(deref_id) {\n                 None => {}\n                 Some(method_ty) => {\n                     let cmt = return_if_err!(self.mc.cat_expr_autoderefd(expr, i));\n@@ -865,7 +864,7 @@ impl<'d,'t,'a,'tcx> ExprUseVisitor<'d,'t,'a,'tcx> {\n                                 pass_args: PassArgs)\n                                 -> bool\n     {\n-        if !self.typer.is_method_call(expr.id) {\n+        if !self.mc.infcx.is_method_call(expr.id) {\n             return false;\n         }\n \n@@ -941,7 +940,7 @@ impl<'d,'t,'a,'tcx> ExprUseVisitor<'d,'t,'a,'tcx> {\n                     PatKind::Ident(hir::BindByRef(_), _, _) =>\n                         mode.lub(BorrowingMatch),\n                     PatKind::Ident(hir::BindByValue(_), _, _) => {\n-                        match copy_or_move(self.typer, &cmt_pat, PatBindingMove) {\n+                        match copy_or_move(self.mc.infcx, &cmt_pat, PatBindingMove) {\n                             Copy => mode.lub(CopyingMatch),\n                             Move(_) => mode.lub(MovingMatch),\n                         }\n@@ -967,7 +966,7 @@ impl<'d,'t,'a,'tcx> ExprUseVisitor<'d,'t,'a,'tcx> {\n                pat);\n \n         let mc = &self.mc;\n-        let typer = self.typer;\n+        let infcx = self.mc.infcx;\n         let def_map = &self.tcx().def_map;\n         let delegate = &mut self.delegate;\n         return_if_err!(mc.cat_pattern(cmt_discr.clone(), pat, |mc, cmt_pat, pat| {\n@@ -978,7 +977,7 @@ impl<'d,'t,'a,'tcx> ExprUseVisitor<'d,'t,'a,'tcx> {\n                        match_mode);\n \n                 // pat_ty: the type of the binding being produced.\n-                let pat_ty = return_if_err!(typer.node_ty(pat.id));\n+                let pat_ty = return_if_err!(infcx.node_ty(pat.id));\n \n                 // Each match binding is effectively an assignment to the\n                 // binding being produced.\n@@ -1000,7 +999,7 @@ impl<'d,'t,'a,'tcx> ExprUseVisitor<'d,'t,'a,'tcx> {\n                         }\n                     }\n                     PatKind::Ident(hir::BindByValue(_), _, _) => {\n-                        let mode = copy_or_move(typer, &cmt_pat, PatBindingMove);\n+                        let mode = copy_or_move(infcx, &cmt_pat, PatBindingMove);\n                         debug!(\"walk_pat binding consuming pat\");\n                         delegate.consume_pat(pat, cmt_pat, mode);\n                     }\n@@ -1057,7 +1056,7 @@ impl<'d,'t,'a,'tcx> ExprUseVisitor<'d,'t,'a,'tcx> {\n         // the leaves of the pattern tree structure.\n         return_if_err!(mc.cat_pattern(cmt_discr, pat, |mc, cmt_pat, pat| {\n             let def_map = def_map.borrow();\n-            let tcx = typer.tcx;\n+            let tcx = infcx.tcx;\n \n             match pat.node {\n                 PatKind::TupleStruct(..) | PatKind::Path(..) | PatKind::QPath(..) |\n@@ -1150,13 +1149,13 @@ impl<'d,'t,'a,'tcx> ExprUseVisitor<'d,'t,'a,'tcx> {\n                 let id_var = freevar.def.var_id();\n                 let upvar_id = ty::UpvarId { var_id: id_var,\n                                              closure_expr_id: closure_expr.id };\n-                let upvar_capture = self.typer.upvar_capture(upvar_id).unwrap();\n+                let upvar_capture = self.mc.infcx.upvar_capture(upvar_id).unwrap();\n                 let cmt_var = return_if_err!(self.cat_captured_var(closure_expr.id,\n                                                                    fn_decl_span,\n                                                                    freevar.def));\n                 match upvar_capture {\n                     ty::UpvarCapture::ByValue => {\n-                        let mode = copy_or_move(self.typer, &cmt_var, CaptureMove);\n+                        let mode = copy_or_move(self.mc.infcx, &cmt_var, CaptureMove);\n                         self.delegate.consume(closure_expr.id, freevar.span, cmt_var, mode);\n                     }\n                     ty::UpvarCapture::ByRef(upvar_borrow) => {\n@@ -1180,17 +1179,17 @@ impl<'d,'t,'a,'tcx> ExprUseVisitor<'d,'t,'a,'tcx> {\n         // Create the cmt for the variable being borrowed, from the\n         // caller's perspective\n         let var_id = upvar_def.var_id();\n-        let var_ty = self.typer.node_ty(var_id)?;\n+        let var_ty = self.mc.infcx.node_ty(var_id)?;\n         self.mc.cat_def(closure_id, closure_span, var_ty, upvar_def)\n     }\n }\n \n-fn copy_or_move<'a, 'tcx>(typer: &infer::InferCtxt<'a, 'tcx>,\n-                      cmt: &mc::cmt<'tcx>,\n-                      move_reason: MoveReason)\n-                      -> ConsumeMode\n+fn copy_or_move<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx, 'tcx>,\n+                          cmt: &mc::cmt<'tcx>,\n+                          move_reason: MoveReason)\n+                          -> ConsumeMode\n {\n-    if typer.type_moves_by_default(cmt.ty, cmt.span) {\n+    if infcx.type_moves_by_default(cmt.ty, cmt.span) {\n         Move(move_reason)\n     } else {\n         Copy"}, {"sha": "90d4627c93d15f807a2c42102ec477eb66e2959d", "filename": "src/librustc/middle/free_region.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc%2Fmiddle%2Ffree_region.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc%2Fmiddle%2Ffree_region.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ffree_region.rs?ref=76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4", "patch": "@@ -120,11 +120,11 @@ impl FreeRegionMap {\n \n     /// Determines whether one region is a subregion of another.  This is intended to run *after\n     /// inference* and sadly the logic is somewhat duplicated with the code in infer.rs.\n-    pub fn is_subregion_of(&self,\n-                           tcx: TyCtxt,\n-                           sub_region: ty::Region,\n-                           super_region: ty::Region)\n-                           -> bool {\n+    pub fn is_subregion_of<'a, 'tcx>(&self,\n+                                     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                     sub_region: ty::Region,\n+                                     super_region: ty::Region)\n+                                     -> bool {\n         let result = sub_region == super_region || {\n             match (sub_region, super_region) {\n                 (ty::ReEmpty, _) |"}, {"sha": "e87de2875ddd7d1a34c897542ebaba890f4e6cf0", "filename": "src/librustc/middle/intrinsicck.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs?ref=76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4", "patch": "@@ -22,15 +22,15 @@ use syntax::codemap::Span;\n use hir::intravisit::{self, Visitor, FnKind};\n use hir;\n \n-pub fn check_crate(tcx: TyCtxt) {\n+pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     let mut visitor = ItemVisitor {\n         tcx: tcx\n     };\n     tcx.visit_all_items_in_krate(DepNode::IntrinsicCheck, &mut visitor);\n }\n \n struct ItemVisitor<'a, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'tcx>\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>\n }\n \n impl<'a, 'tcx> ItemVisitor<'a, 'tcx> {\n@@ -46,11 +46,11 @@ impl<'a, 'tcx> ItemVisitor<'a, 'tcx> {\n     }\n }\n \n-struct ExprVisitor<'a, 'tcx: 'a> {\n-    infcx: &'a InferCtxt<'a, 'tcx>\n+struct ExprVisitor<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n+    infcx: &'a InferCtxt<'a, 'gcx, 'tcx>\n }\n \n-impl<'a, 'tcx> ExprVisitor<'a, 'tcx> {\n+impl<'a, 'tcx> ExprVisitor<'a, 'tcx, 'tcx> {\n     fn def_id_is_transmute(&self, def_id: DefId) -> bool {\n         let intrinsic = match self.infcx.tcx.lookup_item_type(def_id).ty.sty {\n             ty::TyFnDef(_, _, ref bfty) => bfty.abi == RustIntrinsic,\n@@ -159,7 +159,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for ItemVisitor<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx, 'v> Visitor<'v> for ExprVisitor<'a, 'tcx> {\n+impl<'a, 'tcx, 'v> Visitor<'v> for ExprVisitor<'a, 'tcx, 'tcx> {\n     fn visit_expr(&mut self, expr: &hir::Expr) {\n         if let hir::ExprPath(..) = expr.node {\n             match self.infcx.tcx.resolve_expr(expr) {"}, {"sha": "eeace7f658d0fdd6a5167c61ecaf29b34852ffc0", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4", "patch": "@@ -195,7 +195,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for IrMaps<'a, 'tcx> {\n     fn visit_arm(&mut self, a: &hir::Arm) { visit_arm(self, a); }\n }\n \n-pub fn check_crate(tcx: TyCtxt) {\n+pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     let _task = tcx.dep_graph.in_task(DepNode::Liveness);\n     tcx.map.krate().visit_all_items(&mut IrMaps::new(tcx));\n     tcx.sess.abort_if_errors();\n@@ -263,7 +263,7 @@ enum VarKind {\n }\n \n struct IrMaps<'a, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'tcx>,\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     num_live_nodes: usize,\n     num_vars: usize,\n@@ -275,7 +275,7 @@ struct IrMaps<'a, 'tcx: 'a> {\n }\n \n impl<'a, 'tcx> IrMaps<'a, 'tcx> {\n-    fn new(tcx: TyCtxt<'a, 'tcx>) -> IrMaps<'a, 'tcx> {\n+    fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> IrMaps<'a, 'tcx> {\n         IrMaps {\n             tcx: tcx,\n             num_live_nodes: 0,"}, {"sha": "53e6102587bd7af428b0d1d239f88d87bbb28d92", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 31, "deletions": 28, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4", "patch": "@@ -73,7 +73,7 @@ use self::Aliasability::*;\n \n use hir::def_id::DefId;\n use hir::map as ast_map;\n-use infer;\n+use infer::InferCtxt;\n use middle::const_qualif::ConstQualif;\n use hir::def::Def;\n use ty::adjustment;\n@@ -256,8 +256,8 @@ impl ast_node for hir::Pat {\n }\n \n #[derive(Copy, Clone)]\n-pub struct MemCategorizationContext<'t, 'a: 't, 'tcx : 'a> {\n-    pub typer: &'t infer::InferCtxt<'a, 'tcx>,\n+pub struct MemCategorizationContext<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n+    pub infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n }\n \n pub type McResult<T> = Result<T, ()>;\n@@ -302,7 +302,9 @@ impl MutabilityCategory {\n         ret\n     }\n \n-    fn from_local(tcx: TyCtxt, id: ast::NodeId) -> MutabilityCategory {\n+    fn from_local<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                            id: ast::NodeId)\n+                            -> MutabilityCategory {\n         let ret = match tcx.map.get(id) {\n             ast_map::NodeLocal(p) => match p.node {\n                 PatKind::Ident(bind_mode, _, _) => {\n@@ -358,17 +360,18 @@ impl MutabilityCategory {\n     }\n }\n \n-impl<'t, 'a,'tcx> MemCategorizationContext<'t, 'a, 'tcx> {\n-    pub fn new(typer: &'t infer::InferCtxt<'a, 'tcx>) -> MemCategorizationContext<'t, 'a, 'tcx> {\n-        MemCategorizationContext { typer: typer }\n+impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx, 'tcx> {\n+    pub fn new(infcx: &'a InferCtxt<'a, 'tcx, 'tcx>)\n+               -> MemCategorizationContext<'a, 'tcx, 'tcx> {\n+        MemCategorizationContext { infcx: infcx }\n     }\n \n-    fn tcx(&self) -> TyCtxt<'a, 'tcx> {\n-        self.typer.tcx\n+    fn tcx(&self) -> TyCtxt<'a, 'tcx, 'tcx> {\n+        self.infcx.tcx\n     }\n \n     fn expr_ty(&self, expr: &hir::Expr) -> McResult<Ty<'tcx>> {\n-        match self.typer.node_ty(expr.id) {\n+        match self.infcx.node_ty(expr.id) {\n             Ok(t) => Ok(t),\n             Err(()) => {\n                 debug!(\"expr_ty({:?}) yielded Err\", expr);\n@@ -381,16 +384,16 @@ impl<'t, 'a,'tcx> MemCategorizationContext<'t, 'a, 'tcx> {\n         let unadjusted_ty = self.expr_ty(expr)?;\n         Ok(unadjusted_ty.adjust(\n             self.tcx(), expr.span, expr.id,\n-            self.typer.adjustments().get(&expr.id),\n-            |method_call| self.typer.node_method_ty(method_call)))\n+            self.infcx.adjustments().get(&expr.id),\n+            |method_call| self.infcx.node_method_ty(method_call)))\n     }\n \n     fn node_ty(&self, id: ast::NodeId) -> McResult<Ty<'tcx>> {\n-        self.typer.node_ty(id)\n+        self.infcx.node_ty(id)\n     }\n \n     fn pat_ty(&self, pat: &hir::Pat) -> McResult<Ty<'tcx>> {\n-        let base_ty = self.typer.node_ty(pat.id)?;\n+        let base_ty = self.infcx.node_ty(pat.id)?;\n         // FIXME (Issue #18207): This code detects whether we are\n         // looking at a `ref x`, and if so, figures out what the type\n         // *being borrowed* is.  But ideally we would put in a more\n@@ -413,7 +416,7 @@ impl<'t, 'a,'tcx> MemCategorizationContext<'t, 'a, 'tcx> {\n     }\n \n     pub fn cat_expr(&self, expr: &hir::Expr) -> McResult<cmt<'tcx>> {\n-        match self.typer.adjustments().get(&expr.id) {\n+        match self.infcx.adjustments().get(&expr.id) {\n             None => {\n                 // No adjustments.\n                 self.cat_expr_unadjusted(expr)\n@@ -485,7 +488,7 @@ impl<'t, 'a,'tcx> MemCategorizationContext<'t, 'a, 'tcx> {\n           hir::ExprIndex(ref base, _) => {\n             let method_call = ty::MethodCall::expr(expr.id());\n             let context = InteriorOffsetKind::Index;\n-            match self.typer.node_method_ty(method_call) {\n+            match self.infcx.node_method_ty(method_call) {\n                 Some(method_ty) => {\n                     // If this is an index implemented by a method call, then it\n                     // will include an implicit deref of the result.\n@@ -578,7 +581,7 @@ impl<'t, 'a,'tcx> MemCategorizationContext<'t, 'a, 'tcx> {\n               let ty = self.node_ty(fn_node_id)?;\n               match ty.sty {\n                   ty::TyClosure(closure_id, _) => {\n-                      match self.typer.closure_kind(closure_id) {\n+                      match self.infcx.closure_kind(closure_id) {\n                           Some(kind) => {\n                               self.cat_upvar(id, span, var_id, fn_node_id, kind)\n                           }\n@@ -687,7 +690,7 @@ impl<'t, 'a,'tcx> MemCategorizationContext<'t, 'a, 'tcx> {\n         // for that.\n         let upvar_id = ty::UpvarId { var_id: var_id,\n                                      closure_expr_id: fn_node_id };\n-        let upvar_capture = self.typer.upvar_capture(upvar_id).unwrap();\n+        let upvar_capture = self.infcx.upvar_capture(upvar_id).unwrap();\n         let cmt_result = match upvar_capture {\n             ty::UpvarCapture::ByValue => {\n                 cmt_result\n@@ -785,7 +788,7 @@ impl<'t, 'a,'tcx> MemCategorizationContext<'t, 'a, 'tcx> {\n     /// Returns the lifetime of a temporary created by expr with id `id`.\n     /// This could be `'static` if `id` is part of a constant expression.\n     pub fn temporary_scope(&self, id: ast::NodeId) -> ty::Region {\n-        match self.typer.temporary_scope(id) {\n+        match self.infcx.temporary_scope(id) {\n             Some(scope) => ty::ReScope(scope),\n             None => ty::ReStatic\n         }\n@@ -882,7 +885,7 @@ impl<'t, 'a,'tcx> MemCategorizationContext<'t, 'a, 'tcx> {\n             expr_id: node.id(),\n             autoderef: deref_cnt as u32\n         };\n-        let method_ty = self.typer.node_method_ty(method_call);\n+        let method_ty = self.infcx.node_method_ty(method_call);\n \n         debug!(\"cat_deref: method_call={:?} method_ty={:?}\",\n                method_call, method_ty.map(|ty| ty));\n@@ -977,7 +980,7 @@ impl<'t, 'a,'tcx> MemCategorizationContext<'t, 'a, 'tcx> {\n         //! - `base_cmt`: the cmt of `elt`\n \n         let method_call = ty::MethodCall::expr(elt.id());\n-        let method_ty = self.typer.node_method_ty(method_call);\n+        let method_ty = self.infcx.node_method_ty(method_call);\n \n         let element_ty = match method_ty {\n             Some(method_ty) => {\n@@ -1082,10 +1085,10 @@ impl<'t, 'a,'tcx> MemCategorizationContext<'t, 'a, 'tcx> {\n         /// In a pattern like [a, b, ..c], normally `c` has slice type, but if you have [a, b,\n         /// ..ref c], then the type of `ref c` will be `&&[]`, so to extract the slice details we\n         /// have to recurse through rptrs.\n-        fn vec_slice_info(tcx: TyCtxt,\n-                          pat: &hir::Pat,\n-                          slice_ty: Ty)\n-                          -> (hir::Mutability, ty::Region) {\n+        fn vec_slice_info<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                    pat: &hir::Pat,\n+                                    slice_ty: Ty)\n+                                    -> (hir::Mutability, ty::Region) {\n             match slice_ty.sty {\n                 ty::TyRef(r, ref mt) => match mt.ty.sty {\n                     ty::TySlice(_) => (mt.mutbl, *r),\n@@ -1137,15 +1140,15 @@ impl<'t, 'a,'tcx> MemCategorizationContext<'t, 'a, 'tcx> {\n     }\n \n     pub fn cat_pattern<F>(&self, cmt: cmt<'tcx>, pat: &hir::Pat, mut op: F) -> McResult<()>\n-        where F: FnMut(&MemCategorizationContext<'t, 'a, 'tcx>, cmt<'tcx>, &hir::Pat),\n+        where F: FnMut(&MemCategorizationContext<'a, 'tcx, 'tcx>, cmt<'tcx>, &hir::Pat),\n     {\n         self.cat_pattern_(cmt, pat, &mut op)\n     }\n \n     // FIXME(#19596) This is a workaround, but there should be a better way to do this\n     fn cat_pattern_<F>(&self, cmt: cmt<'tcx>, pat: &hir::Pat, op: &mut F)\n                        -> McResult<()>\n-        where F : FnMut(&MemCategorizationContext<'t, 'a, 'tcx>, cmt<'tcx>, &hir::Pat),\n+        where F : FnMut(&MemCategorizationContext<'a, 'tcx, 'tcx>, cmt<'tcx>, &hir::Pat),\n     {\n         // Here, `cmt` is the categorization for the value being\n         // matched and pat is the pattern it is being matched against.\n@@ -1463,7 +1466,7 @@ impl<'tcx> cmt_<'tcx> {\n     }\n \n \n-    pub fn descriptive_string(&self, tcx: TyCtxt) -> String {\n+    pub fn descriptive_string<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> String {\n         match self.cat {\n             Categorization::StaticItem => {\n                 \"static item\".to_string()"}, {"sha": "bca5af69edfd033e9db4f93905ada8f123aa6731", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4", "patch": "@@ -55,9 +55,10 @@ fn item_might_be_inlined(item: &hir::Item) -> bool {\n     }\n }\n \n-fn method_might_be_inlined(tcx: TyCtxt, sig: &hir::MethodSig,\n-                           impl_item: &hir::ImplItem,\n-                           impl_src: DefId) -> bool {\n+fn method_might_be_inlined<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                     sig: &hir::MethodSig,\n+                                     impl_item: &hir::ImplItem,\n+                                     impl_src: DefId) -> bool {\n     if attr::requests_inline(&impl_item.attrs) ||\n         generics_require_inlining(&sig.generics) {\n         return true\n@@ -77,7 +78,7 @@ fn method_might_be_inlined(tcx: TyCtxt, sig: &hir::MethodSig,\n // Information needed while computing reachability.\n struct ReachableContext<'a, 'tcx: 'a> {\n     // The type context.\n-    tcx: TyCtxt<'a, 'tcx>,\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     // The set of items which must be exported in the linkage sense.\n     reachable_symbols: NodeSet,\n     // A worklist of item IDs. Each item ID in this worklist will be inlined\n@@ -142,7 +143,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for ReachableContext<'a, 'tcx> {\n \n impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n     // Creates a new reachability computation context.\n-    fn new(tcx: TyCtxt<'a, 'tcx>) -> ReachableContext<'a, 'tcx> {\n+    fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> ReachableContext<'a, 'tcx> {\n         let any_library = tcx.sess.crate_types.borrow().iter().any(|ty| {\n             *ty != config::CrateTypeExecutable\n         });\n@@ -344,9 +345,9 @@ impl<'a, 'v> Visitor<'v> for CollectPrivateImplItemsVisitor<'a> {\n     }\n }\n \n-pub fn find_reachable(tcx: TyCtxt,\n-                      access_levels: &privacy::AccessLevels)\n-                      -> NodeSet {\n+pub fn find_reachable<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                access_levels: &privacy::AccessLevels)\n+                                -> NodeSet {\n     let _task = tcx.dep_graph.in_task(DepNode::Reachability);\n \n     let mut reachable_context = ReachableContext::new(tcx);"}, {"sha": "9fabdf58b6fbc51ec091f5f3de32ec25b8762c8b", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 37, "deletions": 21, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4", "patch": "@@ -72,7 +72,7 @@ pub struct Index<'tcx> {\n \n // A private tree-walker for producing an Index.\n struct Annotator<'a, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'tcx>,\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     index: &'a mut Index<'tcx>,\n     parent_stab: Option<&'tcx Stability>,\n     parent_depr: Option<Deprecation>,\n@@ -280,7 +280,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for Annotator<'a, 'tcx> {\n \n impl<'a, 'tcx> Index<'tcx> {\n     /// Construct the stability index for a crate being compiled.\n-    pub fn build(&mut self, tcx: TyCtxt<'a, 'tcx>, access_levels: &AccessLevels) {\n+    pub fn build(&mut self, tcx: TyCtxt<'a, 'tcx, 'tcx>, access_levels: &AccessLevels) {\n         let _task = tcx.dep_graph.in_task(DepNode::StabilityIndex);\n         let krate = tcx.map.krate();\n         let mut annotator = Annotator {\n@@ -320,8 +320,8 @@ impl<'a, 'tcx> Index<'tcx> {\n /// Cross-references the feature names of unstable APIs with enabled\n /// features and possibly prints errors. Returns a list of all\n /// features used.\n-pub fn check_unstable_api_usage(tcx: TyCtxt)\n-                                -> FnvHashMap<InternedString, StabilityLevel> {\n+pub fn check_unstable_api_usage<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>)\n+                                          -> FnvHashMap<InternedString, StabilityLevel> {\n     let _task = tcx.dep_graph.in_task(DepNode::StabilityCheck);\n     let ref active_lib_features = tcx.sess.features.borrow().declared_lib_features;\n \n@@ -340,7 +340,7 @@ pub fn check_unstable_api_usage(tcx: TyCtxt)\n }\n \n struct Checker<'a, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'tcx>,\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     active_features: FnvHashSet<InternedString>,\n     used_features: FnvHashMap<InternedString, StabilityLevel>,\n     // Within a block where feature gate checking can be skipped.\n@@ -468,8 +468,12 @@ impl<'a, 'v, 'tcx> Visitor<'v> for Checker<'a, 'tcx> {\n }\n \n /// Helper for discovering nodes to check for stability\n-pub fn check_item(tcx: TyCtxt, item: &hir::Item, warn_about_defns: bool,\n-                  cb: &mut FnMut(DefId, Span, &Option<&Stability>, &Option<Deprecation>)) {\n+pub fn check_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                            item: &hir::Item,\n+                            warn_about_defns: bool,\n+                            cb: &mut FnMut(DefId, Span,\n+                                           &Option<&Stability>,\n+                                           &Option<Deprecation>)) {\n     match item.node {\n         hir::ItemExternCrate(_) => {\n             // compiler-generated `extern crate` items have a dummy span.\n@@ -505,8 +509,10 @@ pub fn check_item(tcx: TyCtxt, item: &hir::Item, warn_about_defns: bool,\n }\n \n /// Helper for discovering nodes to check for stability\n-pub fn check_expr(tcx: TyCtxt, e: &hir::Expr,\n-                  cb: &mut FnMut(DefId, Span, &Option<&Stability>, &Option<Deprecation>)) {\n+pub fn check_expr<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, e: &hir::Expr,\n+                            cb: &mut FnMut(DefId, Span,\n+                                           &Option<&Stability>,\n+                                           &Option<Deprecation>)) {\n     let span;\n     let id = match e.node {\n         hir::ExprMethodCall(i, _, _) => {\n@@ -566,8 +572,11 @@ pub fn check_expr(tcx: TyCtxt, e: &hir::Expr,\n     maybe_do_stability_check(tcx, id, span, cb);\n }\n \n-pub fn check_path(tcx: TyCtxt, path: &hir::Path, id: ast::NodeId,\n-                  cb: &mut FnMut(DefId, Span, &Option<&Stability>, &Option<Deprecation>)) {\n+pub fn check_path<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                            path: &hir::Path, id: ast::NodeId,\n+                            cb: &mut FnMut(DefId, Span,\n+                                           &Option<&Stability>,\n+                                           &Option<Deprecation>)) {\n     match tcx.def_map.borrow().get(&id).map(|d| d.full_def()) {\n         Some(Def::PrimTy(..)) => {}\n         Some(Def::SelfTy(..)) => {}\n@@ -578,8 +587,11 @@ pub fn check_path(tcx: TyCtxt, path: &hir::Path, id: ast::NodeId,\n     }\n }\n \n-pub fn check_path_list_item(tcx: TyCtxt, item: &hir::PathListItem,\n-                  cb: &mut FnMut(DefId, Span, &Option<&Stability>, &Option<Deprecation>)) {\n+pub fn check_path_list_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                      item: &hir::PathListItem,\n+                                      cb: &mut FnMut(DefId, Span,\n+                                                     &Option<&Stability>,\n+                                                     &Option<Deprecation>)) {\n     match tcx.def_map.borrow().get(&item.node.id()).map(|d| d.full_def()) {\n         Some(Def::PrimTy(..)) => {}\n         Some(def) => {\n@@ -589,8 +601,10 @@ pub fn check_path_list_item(tcx: TyCtxt, item: &hir::PathListItem,\n     }\n }\n \n-pub fn check_pat(tcx: TyCtxt, pat: &hir::Pat,\n-                 cb: &mut FnMut(DefId, Span, &Option<&Stability>, &Option<Deprecation>)) {\n+pub fn check_pat<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, pat: &hir::Pat,\n+                           cb: &mut FnMut(DefId, Span,\n+                                          &Option<&Stability>,\n+                                          &Option<Deprecation>)) {\n     debug!(\"check_pat(pat = {:?})\", pat);\n     if is_internal(tcx, pat.span) { return; }\n \n@@ -618,9 +632,11 @@ pub fn check_pat(tcx: TyCtxt, pat: &hir::Pat,\n     }\n }\n \n-fn maybe_do_stability_check(tcx: TyCtxt, id: DefId, span: Span,\n-                            cb: &mut FnMut(DefId, Span,\n-                                           &Option<&Stability>, &Option<Deprecation>)) {\n+fn maybe_do_stability_check<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                      id: DefId, span: Span,\n+                                      cb: &mut FnMut(DefId, Span,\n+                                                     &Option<&Stability>,\n+                                                     &Option<Deprecation>)) {\n     if is_internal(tcx, span) {\n         debug!(\"maybe_do_stability_check: \\\n                 skipping span={:?} since it is internal\", span);\n@@ -636,11 +652,11 @@ fn maybe_do_stability_check(tcx: TyCtxt, id: DefId, span: Span,\n     cb(id, span, &stability, &deprecation);\n }\n \n-fn is_internal(tcx: TyCtxt, span: Span) -> bool {\n+fn is_internal<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, span: Span) -> bool {\n     tcx.sess.codemap().span_allows_unstable(span)\n }\n \n-fn is_staged_api(tcx: TyCtxt, id: DefId) -> bool {\n+fn is_staged_api<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, id: DefId) -> bool {\n     match tcx.trait_item_of_item(id) {\n         Some(ty::MethodTraitItemId(trait_method_id))\n             if trait_method_id != id => {\n@@ -653,7 +669,7 @@ fn is_staged_api(tcx: TyCtxt, id: DefId) -> bool {\n     }\n }\n \n-impl<'a, 'tcx> TyCtxt<'a, 'tcx> {\n+impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n /// Lookup the stability for a node, loading external crate\n /// metadata as necessary.\n pub fn lookup_stability(self, id: DefId) -> Option<&'tcx Stability> {"}, {"sha": "b122907b64d627dd59f08cf6448e946cb2a4db57", "filename": "src/librustc/mir/tcx.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc%2Fmir%2Ftcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc%2Fmir%2Ftcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Ftcx.rs?ref=76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4", "patch": "@@ -35,7 +35,7 @@ impl<'a, 'tcx> LvalueTy<'tcx> {\n         LvalueTy::Ty { ty: ty }\n     }\n \n-    pub fn to_ty(&self, tcx: TyCtxt<'a, 'tcx>) -> Ty<'tcx> {\n+    pub fn to_ty(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Ty<'tcx> {\n         match *self {\n             LvalueTy::Ty { ty } =>\n                 ty,\n@@ -44,7 +44,7 @@ impl<'a, 'tcx> LvalueTy<'tcx> {\n         }\n     }\n \n-    pub fn projection_ty(self, tcx: TyCtxt<'a, 'tcx>,\n+    pub fn projection_ty(self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                          elem: &LvalueElem<'tcx>)\n                          -> LvalueTy<'tcx>\n     {\n@@ -101,7 +101,7 @@ impl<'tcx> TypeFoldable<'tcx> for LvalueTy<'tcx> {\n }\n \n impl<'a, 'tcx> Mir<'tcx> {\n-    pub fn operand_ty(&self, tcx: TyCtxt<'a, 'tcx>,\n+    pub fn operand_ty(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                       operand: &Operand<'tcx>)\n                       -> Ty<'tcx>\n     {\n@@ -111,7 +111,7 @@ impl<'a, 'tcx> Mir<'tcx> {\n         }\n     }\n \n-    pub fn binop_ty(&self, tcx: TyCtxt<'a, 'tcx>,\n+    pub fn binop_ty(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                     op: BinOp,\n                     lhs_ty: Ty<'tcx>,\n                     rhs_ty: Ty<'tcx>)\n@@ -135,7 +135,7 @@ impl<'a, 'tcx> Mir<'tcx> {\n         }\n     }\n \n-    pub fn lvalue_ty(&self, tcx: TyCtxt<'a, 'tcx>,\n+    pub fn lvalue_ty(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                      lvalue: &Lvalue<'tcx>)\n                      -> LvalueTy<'tcx>\n     {\n@@ -155,7 +155,7 @@ impl<'a, 'tcx> Mir<'tcx> {\n         }\n     }\n \n-    pub fn rvalue_ty(&self, tcx: TyCtxt<'a, 'tcx>,\n+    pub fn rvalue_ty(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                      rvalue: &Rvalue<'tcx>)\n                      -> Option<Ty<'tcx>>\n     {"}, {"sha": "79c44b2b851c72a86c284673be235d165bcfc2da", "filename": "src/librustc/mir/transform.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc%2Fmir%2Ftransform.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc%2Fmir%2Ftransform.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Ftransform.rs?ref=76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4", "patch": "@@ -33,8 +33,8 @@ pub enum MirSource {\n     Promoted(NodeId, usize)\n }\n \n-impl MirSource {\n-    pub fn from_node(tcx: TyCtxt, id: NodeId) -> MirSource {\n+impl<'a, 'tcx> MirSource {\n+    pub fn from_node(tcx: TyCtxt<'a, 'tcx, 'tcx>, id: NodeId) -> MirSource {\n         use hir::*;\n \n         // Handle constants in enum discriminants, types, and repeat expressions.\n@@ -79,21 +79,22 @@ pub trait Pass {\n \n /// A pass which inspects the whole MirMap.\n pub trait MirMapPass<'tcx>: Pass {\n-    fn run_pass<'a>(&mut self, tcx: TyCtxt<'a, 'tcx>, map: &mut MirMap<'tcx>);\n+    fn run_pass<'a>(&mut self, tcx: TyCtxt<'a, 'tcx, 'tcx>, map: &mut MirMap<'tcx>);\n }\n \n /// A pass which inspects Mir of functions in isolation.\n pub trait MirPass<'tcx>: Pass {\n-    fn run_pass_on_promoted<'a>(&mut self, tcx: TyCtxt<'a, 'tcx>,\n+    fn run_pass_on_promoted<'a>(&mut self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                 item_id: NodeId, index: usize,\n                                 mir: &mut Mir<'tcx>) {\n         self.run_pass(tcx, MirSource::Promoted(item_id, index), mir);\n     }\n-    fn run_pass<'a>(&mut self, tcx: TyCtxt<'a, 'tcx>, src: MirSource, mir: &mut Mir<'tcx>);\n+    fn run_pass<'a>(&mut self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                    src: MirSource, mir: &mut Mir<'tcx>);\n }\n \n impl<'tcx, T: MirPass<'tcx>> MirMapPass<'tcx> for T {\n-    fn run_pass<'a>(&mut self, tcx: TyCtxt<'a, 'tcx>, map: &mut MirMap<'tcx>) {\n+    fn run_pass<'a>(&mut self, tcx: TyCtxt<'a, 'tcx, 'tcx>, map: &mut MirMap<'tcx>) {\n         for (&id, mir) in &mut map.map {\n             let def_id = tcx.map.local_def_id(id);\n             let _task = tcx.dep_graph.in_task(self.dep_node(def_id));\n@@ -123,7 +124,7 @@ impl<'a, 'tcx> Passes {\n         passes\n     }\n \n-    pub fn run_passes(&mut self, tcx: TyCtxt<'a, 'tcx>, map: &mut MirMap<'tcx>) {\n+    pub fn run_passes(&mut self, tcx: TyCtxt<'a, 'tcx, 'tcx>, map: &mut MirMap<'tcx>) {\n         for pass in &mut self.plugin_passes {\n             pass.run_pass(tcx, map);\n         }"}, {"sha": "8802f98d54a9e02423ee01a46b49c4e1e9c090aa", "filename": "src/librustc/traits/coherence.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fcoherence.rs?ref=76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4", "patch": "@@ -24,7 +24,7 @@ struct InferIsLocal(bool);\n \n /// If there are types that satisfy both impls, returns a suitably-freshened\n /// `ImplHeader` with those types substituted\n-pub fn overlapping_impls<'cx, 'tcx>(infcx: &InferCtxt<'cx, 'tcx>,\n+pub fn overlapping_impls<'cx, 'tcx>(infcx: &InferCtxt<'cx, 'tcx, 'tcx>,\n                                     impl1_def_id: DefId,\n                                     impl2_def_id: DefId)\n                                     -> Option<ty::ImplHeader<'tcx>>\n@@ -41,7 +41,7 @@ pub fn overlapping_impls<'cx, 'tcx>(infcx: &InferCtxt<'cx, 'tcx>,\n \n /// Can both impl `a` and impl `b` be satisfied by a common type (including\n /// `where` clauses)? If so, returns an `ImplHeader` that unifies the two impls.\n-fn overlap<'cx, 'tcx>(selcx: &mut SelectionContext<'cx, 'tcx>,\n+fn overlap<'cx, 'tcx>(selcx: &mut SelectionContext<'cx, 'tcx, 'tcx>,\n                       a_def_id: DefId,\n                       b_def_id: DefId)\n                       -> Option<ty::ImplHeader<'tcx>>\n@@ -86,7 +86,7 @@ fn overlap<'cx, 'tcx>(selcx: &mut SelectionContext<'cx, 'tcx>,\n     Some(selcx.infcx().resolve_type_vars_if_possible(&a_impl_header))\n }\n \n-pub fn trait_ref_is_knowable<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx>,\n+pub fn trait_ref_is_knowable<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                        trait_ref: &ty::TraitRef<'tcx>) -> bool\n {\n     debug!(\"trait_ref_is_knowable(trait_ref={:?})\", trait_ref);\n@@ -129,7 +129,7 @@ pub enum OrphanCheckErr<'tcx> {\n ///\n /// 1. All type parameters in `Self` must be \"covered\" by some local type constructor.\n /// 2. Some local type must appear in `Self`.\n-pub fn orphan_check<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx>,\n+pub fn orphan_check<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                               impl_def_id: DefId)\n                               -> Result<(), OrphanCheckErr<'tcx>>\n {\n@@ -150,7 +150,7 @@ pub fn orphan_check<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx>,\n     orphan_check_trait_ref(tcx, &trait_ref, InferIsLocal(false))\n }\n \n-fn orphan_check_trait_ref<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx>,\n+fn orphan_check_trait_ref<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                     trait_ref: &ty::TraitRef<'tcx>,\n                                     infer_is_local: InferIsLocal)\n                                     -> Result<(), OrphanCheckErr<'tcx>>\n@@ -198,7 +198,7 @@ fn orphan_check_trait_ref<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx>,\n     return Err(OrphanCheckErr::NoLocalInputType);\n }\n \n-fn uncovered_tys<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx>,\n+fn uncovered_tys<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                            ty: Ty<'tcx>,\n                            infer_is_local: InferIsLocal)\n                            -> Vec<Ty<'tcx>>\n@@ -222,13 +222,15 @@ fn is_type_parameter<'tcx>(ty: Ty<'tcx>) -> bool {\n     }\n }\n \n-fn ty_is_local<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx>, ty: Ty<'tcx>, infer_is_local: InferIsLocal) -> bool\n+fn ty_is_local<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                         ty: Ty<'tcx>,\n+                         infer_is_local: InferIsLocal) -> bool\n {\n     ty_is_local_constructor(tcx, ty, infer_is_local) ||\n         fundamental_ty(tcx, ty) && ty.walk_shallow().any(|t| ty_is_local(tcx, t, infer_is_local))\n }\n \n-fn fundamental_ty<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx>, ty: Ty<'tcx>) -> bool\n+fn fundamental_ty<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, ty: Ty<'tcx>) -> bool\n {\n     match ty.sty {\n         ty::TyBox(..) | ty::TyRef(..) =>\n@@ -242,7 +244,7 @@ fn fundamental_ty<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx>, ty: Ty<'tcx>) -> bool\n     }\n }\n \n-fn ty_is_local_constructor<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx>,\n+fn ty_is_local_constructor<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                      ty: Ty<'tcx>,\n                                      infer_is_local: InferIsLocal)\n                                      -> bool"}, {"sha": "786f58f20ccf790941f9a9682f9072f5e89c284c", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4", "patch": "@@ -47,7 +47,7 @@ pub struct TraitErrorKey<'tcx> {\n }\n \n impl<'tcx> TraitErrorKey<'tcx> {\n-    fn from_error<'a>(infcx: &InferCtxt<'a, 'tcx>,\n+    fn from_error<'a>(infcx: &InferCtxt<'a, 'tcx, 'tcx>,\n                       e: &FulfillmentError<'tcx>,\n                       warning_node_id: Option<ast::NodeId>) -> Self {\n         let predicate =\n@@ -60,7 +60,7 @@ impl<'tcx> TraitErrorKey<'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n+impl<'a, 'tcx> InferCtxt<'a, 'tcx, 'tcx> {\n pub fn report_fulfillment_errors(&self, errors: &Vec<FulfillmentError<'tcx>>) {\n     for error in errors {\n         self.report_fulfillment_error(error, None);\n@@ -558,7 +558,7 @@ pub fn report_selection_error(&self,\n }\n }\n \n-impl<'a, 'tcx> TyCtxt<'a, 'tcx> {\n+impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n pub fn recursive_type_with_infinite_size_error(self,\n                                                type_def_id: DefId)\n                                                -> DiagnosticBuilder<'tcx>\n@@ -646,7 +646,7 @@ pub fn report_object_safety_error(self,\n }\n }\n \n-impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n+impl<'a, 'tcx> InferCtxt<'a, 'tcx, 'tcx> {\n fn maybe_report_ambiguity(&self, obligation: &PredicateObligation<'tcx>) {\n     // Unable to successfully determine, probably means\n     // insufficient type information, but could mean\n@@ -738,13 +738,13 @@ fn maybe_report_ambiguity(&self, obligation: &PredicateObligation<'tcx>) {\n /// to the type parameters.\n fn predicate_can_apply(&self, pred: ty::PolyTraitRef<'tcx>) -> bool {\n     struct ParamToVarFolder<'a, 'tcx: 'a> {\n-        infcx: &'a InferCtxt<'a, 'tcx>,\n+        infcx: &'a InferCtxt<'a, 'tcx, 'tcx>,\n         var_map: FnvHashMap<Ty<'tcx>, Ty<'tcx>>\n     }\n \n     impl<'a, 'tcx> TypeFolder<'tcx> for ParamToVarFolder<'a, 'tcx>\n     {\n-        fn tcx<'b>(&'b self) -> TyCtxt<'b, 'tcx> { self.infcx.tcx }\n+        fn tcx<'b>(&'b self) -> TyCtxt<'b, 'tcx, 'tcx> { self.infcx.tcx }\n \n         fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n             if let ty::TyParam(..) = ty.sty {"}, {"sha": "9d87be36ecc62fde98309bd9154c537a1e6a16a8", "filename": "src/librustc/traits/fulfill.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ffulfill.rs?ref=76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4", "patch": "@@ -130,7 +130,7 @@ impl<'a, 'tcx> FulfillmentContext<'tcx> {\n     /// something concrete. If this fails, we'll unify `$0` with\n     /// `projection_ty` again.\n     pub fn normalize_projection_type(&mut self,\n-                                     infcx: &InferCtxt<'a,'tcx>,\n+                                     infcx: &InferCtxt<'a, 'tcx, 'tcx>,\n                                      projection_ty: ty::ProjectionTy<'tcx>,\n                                      cause: ObligationCause<'tcx>)\n                                      -> Ty<'tcx>\n@@ -155,7 +155,7 @@ impl<'a, 'tcx> FulfillmentContext<'tcx> {\n     }\n \n     pub fn register_builtin_bound(&mut self,\n-                                  infcx: &InferCtxt<'a, 'tcx>,\n+                                  infcx: &InferCtxt<'a, 'tcx, 'tcx>,\n                                   ty: Ty<'tcx>,\n                                   builtin_bound: ty::BuiltinBound,\n                                   cause: ObligationCause<'tcx>)\n@@ -177,7 +177,7 @@ impl<'a, 'tcx> FulfillmentContext<'tcx> {\n     }\n \n     pub fn register_predicate_obligation(&mut self,\n-                                         infcx: &InferCtxt<'a, 'tcx>,\n+                                         infcx: &InferCtxt<'a, 'tcx, 'tcx>,\n                                          obligation: PredicateObligation<'tcx>)\n     {\n         // this helps to reduce duplicate errors, as well as making\n@@ -200,7 +200,7 @@ impl<'a, 'tcx> FulfillmentContext<'tcx> {\n     }\n \n     pub fn register_rfc1592_obligation(&mut self,\n-                                       _infcx: &InferCtxt<'a,'tcx>,\n+                                       _infcx: &InferCtxt<'a, 'tcx, 'tcx>,\n                                        obligation: PredicateObligation<'tcx>)\n     {\n         self.rfc1592_obligations.push(obligation);\n@@ -217,7 +217,7 @@ impl<'a, 'tcx> FulfillmentContext<'tcx> {\n     }\n \n     pub fn select_rfc1592_obligations(&mut self,\n-                                      infcx: &InferCtxt<'a,'tcx>)\n+                                      infcx: &InferCtxt<'a, 'tcx, 'tcx>)\n                                       -> Result<(),Vec<FulfillmentError<'tcx>>>\n     {\n         while !self.rfc1592_obligations.is_empty() {\n@@ -232,7 +232,7 @@ impl<'a, 'tcx> FulfillmentContext<'tcx> {\n     }\n \n     pub fn select_all_or_error(&mut self,\n-                               infcx: &InferCtxt<'a,'tcx>)\n+                               infcx: &InferCtxt<'a, 'tcx, 'tcx>)\n                                -> Result<(),Vec<FulfillmentError<'tcx>>>\n     {\n         self.select_where_possible(infcx)?;\n@@ -250,7 +250,7 @@ impl<'a, 'tcx> FulfillmentContext<'tcx> {\n     }\n \n     pub fn select_where_possible(&mut self,\n-                                 infcx: &InferCtxt<'a, 'tcx>)\n+                                 infcx: &InferCtxt<'a, 'tcx, 'tcx>)\n                                  -> Result<(),Vec<FulfillmentError<'tcx>>>\n     {\n         let mut selcx = SelectionContext::new(infcx);\n@@ -261,7 +261,7 @@ impl<'a, 'tcx> FulfillmentContext<'tcx> {\n         self.predicates.pending_obligations()\n     }\n \n-    fn is_duplicate_or_add(&mut self, tcx: TyCtxt<'a, 'tcx>,\n+    fn is_duplicate_or_add(&mut self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                            predicate: &ty::Predicate<'tcx>)\n                            -> bool {\n         // For \"global\" predicates -- that is, predicates that don't\n@@ -289,7 +289,7 @@ impl<'a, 'tcx> FulfillmentContext<'tcx> {\n \n     /// Attempts to select obligations using `selcx`. If `only_new_obligations` is true, then it\n     /// only attempts to select obligations that haven't been seen before.\n-    fn select(&mut self, selcx: &mut SelectionContext<'a, 'tcx>)\n+    fn select(&mut self, selcx: &mut SelectionContext<'a, 'tcx, 'tcx>)\n               -> Result<(),Vec<FulfillmentError<'tcx>>> {\n         debug!(\"select(obligation-forest-size={})\", self.predicates.len());\n \n@@ -341,7 +341,7 @@ impl<'a, 'tcx> FulfillmentContext<'tcx> {\n }\n \n /// Like `process_predicate1`, but wrap result into a pending predicate.\n-fn process_predicate<'a,'tcx>(selcx: &mut SelectionContext<'a,'tcx>,\n+fn process_predicate<'a,'tcx>(selcx: &mut SelectionContext<'a,'tcx, 'tcx>,\n                               tree_cache: &mut LocalFulfilledPredicates<'tcx>,\n                               pending_obligation: &mut PendingPredicateObligation<'tcx>,\n                               backtrace: Backtrace<PendingPredicateObligation<'tcx>>,\n@@ -362,8 +362,8 @@ fn process_predicate<'a,'tcx>(selcx: &mut SelectionContext<'a,'tcx>,\n     }\n }\n \n-fn process_child_obligations<'a,'tcx>(\n-    selcx: &mut SelectionContext<'a,'tcx>,\n+fn process_child_obligations<'a, 'tcx>(\n+    selcx: &mut SelectionContext<'a, 'tcx, 'tcx>,\n     tree_cache: &mut LocalFulfilledPredicates<'tcx>,\n     pending_obligation: &PredicateObligation<'tcx>,\n     backtrace: Backtrace<PendingPredicateObligation<'tcx>>,\n@@ -478,7 +478,7 @@ impl<'a, 'b, 'tcx> AncestorSet<'b, 'tcx> {\n     /// type-resolved).  Returns `None` if not; otherwise, returns\n     /// `Some` with the index within the backtrace.\n     fn has(&mut self,\n-           infcx: &InferCtxt<'a, 'tcx>,\n+           infcx: &InferCtxt<'a, 'tcx, 'tcx>,\n            predicate: &ty::Predicate<'tcx>)\n            -> Option<usize> {\n         // the first time, we have to populate the cache\n@@ -514,7 +514,7 @@ impl<'a, 'b, 'tcx> AncestorSet<'b, 'tcx> {\n }\n \n /// Return the set of type variables contained in a trait ref\n-fn trait_ref_type_vars<'a, 'tcx>(selcx: &mut SelectionContext<'a, 'tcx>,\n+fn trait_ref_type_vars<'a, 'tcx>(selcx: &mut SelectionContext<'a, 'tcx, 'tcx>,\n                                  t: ty::PolyTraitRef<'tcx>) -> Vec<Ty<'tcx>>\n {\n     t.skip_binder() // ok b/c this check doesn't care about regions\n@@ -531,7 +531,7 @@ fn trait_ref_type_vars<'a, 'tcx>(selcx: &mut SelectionContext<'a, 'tcx>,\n /// - `Ok(Some(v))` if the predicate is true, presuming that `v` are also true\n /// - `Ok(None)` if we don't have enough info to be sure\n /// - `Err` if the predicate does not hold\n-fn process_predicate1<'a,'tcx>(selcx: &mut SelectionContext<'a,'tcx>,\n+fn process_predicate1<'a,'tcx>(selcx: &mut SelectionContext<'a,'tcx, 'tcx>,\n                                pending_obligation: &mut PendingPredicateObligation<'tcx>,\n                                region_obligations: &mut NodeMap<Vec<RegionObligation<'tcx>>>,\n                                rfc1592_obligations: &mut Vec<PredicateObligation<'tcx>>)\n@@ -722,9 +722,9 @@ fn process_predicate1<'a,'tcx>(selcx: &mut SelectionContext<'a,'tcx>,\n /// - it also appears in the backtrace at some position `X`; and,\n /// - all the predicates at positions `X..` between `X` an the top are\n ///   also defaulted traits.\n-fn coinductive_match<'a,'tcx>(selcx: &mut SelectionContext<'a,'tcx>,\n-                              cycle: &[PredicateObligation<'tcx>])\n-                              -> bool\n+fn coinductive_match<'a, 'tcx>(selcx: &mut SelectionContext<'a, 'tcx, 'tcx>,\n+                               cycle: &[PredicateObligation<'tcx>])\n+                               -> bool\n {\n     let len = cycle.len();\n \n@@ -740,7 +740,7 @@ fn coinductive_match<'a,'tcx>(selcx: &mut SelectionContext<'a,'tcx>,\n         })\n }\n \n-fn coinductive_obligation<'a, 'tcx>(selcx: &SelectionContext<'a, 'tcx>,\n+fn coinductive_obligation<'a, 'tcx>(selcx: &SelectionContext<'a, 'tcx, 'tcx>,\n                                     obligation: &PredicateObligation<'tcx>)\n                                     -> bool {\n     match obligation.predicate {"}, {"sha": "25710e86f6026601c3ddc26b43c392b50a795b89", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4", "patch": "@@ -316,7 +316,7 @@ pub fn predicates_for_generics<'tcx>(cause: ObligationCause<'tcx>,\n /// `bound` or is not known to meet bound (note that this is\n /// conservative towards *no impl*, which is the opposite of the\n /// `evaluate` methods).\n-pub fn type_known_to_meet_builtin_bound<'a,'tcx>(infcx: &InferCtxt<'a,'tcx>,\n+pub fn type_known_to_meet_builtin_bound<'a,'tcx>(infcx: &InferCtxt<'a,'tcx, 'tcx>,\n                                                  ty: Ty<'tcx>,\n                                                  bound: ty::BuiltinBound,\n                                                  span: Span)\n@@ -460,7 +460,7 @@ pub fn normalize_param_env_or_error<'a,'tcx>(unnormalized_env: ty::ParameterEnvi\n     infcx.parameter_environment.with_caller_bounds(predicates)\n }\n \n-pub fn fully_normalize<'a,'tcx,T>(infcx: &InferCtxt<'a,'tcx>,\n+pub fn fully_normalize<'a,'tcx,T>(infcx: &InferCtxt<'a,'tcx, 'tcx>,\n                                   cause: ObligationCause<'tcx>,\n                                   value: &T)\n                                   -> Result<T, Vec<FulfillmentError<'tcx>>>"}, {"sha": "74818e683f1158fe8df9c38f2d95107c9f385631", "filename": "src/librustc/traits/object_safety.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fobject_safety.rs?ref=76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4", "patch": "@@ -53,7 +53,7 @@ pub enum MethodViolationCode {\n     Generic,\n }\n \n-impl<'a, 'tcx> TyCtxt<'a, 'tcx> {\n+impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n pub fn is_object_safe(self, trait_def_id: DefId) -> bool {\n     // Because we query yes/no results frequently, we keep a cache:\n     let def = self.lookup_trait_def(trait_def_id);"}, {"sha": "88ec6d65918596f0622ce2644d3ca95998ed4ba1", "filename": "src/librustc/traits/project.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fproject.rs?ref=76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4", "patch": "@@ -172,7 +172,7 @@ struct ProjectionTyCandidateSet<'tcx> {\n ///\n /// If successful, this may result in additional obligations.\n pub fn poly_project_and_unify_type<'cx,'tcx>(\n-    selcx: &mut SelectionContext<'cx,'tcx>,\n+    selcx: &mut SelectionContext<'cx,'tcx, 'tcx>,\n     obligation: &PolyProjectionObligation<'tcx>)\n     -> Result<Option<Vec<PredicateObligation<'tcx>>>, MismatchedProjectionTypes<'tcx>>\n {\n@@ -205,7 +205,7 @@ pub fn poly_project_and_unify_type<'cx,'tcx>(\n ///\n /// If successful, this may result in additional obligations.\n fn project_and_unify_type<'cx,'tcx>(\n-    selcx: &mut SelectionContext<'cx,'tcx>,\n+    selcx: &mut SelectionContext<'cx,'tcx, 'tcx>,\n     obligation: &ProjectionObligation<'tcx>)\n     -> Result<Option<Vec<PredicateObligation<'tcx>>>, MismatchedProjectionTypes<'tcx>>\n {\n@@ -240,7 +240,7 @@ fn project_and_unify_type<'cx,'tcx>(\n     }\n }\n \n-fn consider_unification_despite_ambiguity<'cx,'tcx>(selcx: &mut SelectionContext<'cx,'tcx>,\n+fn consider_unification_despite_ambiguity<'cx,'tcx>(selcx: &mut SelectionContext<'cx,'tcx, 'tcx>,\n                                                     obligation: &ProjectionObligation<'tcx>) {\n     debug!(\"consider_unification_despite_ambiguity(obligation={:?})\",\n            obligation);\n@@ -295,7 +295,7 @@ fn consider_unification_despite_ambiguity<'cx,'tcx>(selcx: &mut SelectionContext\n /// them with a fully resolved type where possible. The return value\n /// combines the normalized result and any additional obligations that\n /// were incurred as result.\n-pub fn normalize<'a,'b,'tcx,T>(selcx: &'a mut SelectionContext<'b,'tcx>,\n+pub fn normalize<'a,'b,'tcx,T>(selcx: &'a mut SelectionContext<'b,'tcx, 'tcx>,\n                                cause: ObligationCause<'tcx>,\n                                value: &T)\n                                -> Normalized<'tcx, T>\n@@ -305,7 +305,7 @@ pub fn normalize<'a,'b,'tcx,T>(selcx: &'a mut SelectionContext<'b,'tcx>,\n }\n \n /// As `normalize`, but with a custom depth.\n-pub fn normalize_with_depth<'a,'b,'tcx,T>(selcx: &'a mut SelectionContext<'b,'tcx>,\n+pub fn normalize_with_depth<'a,'b,'tcx,T>(selcx: &'a mut SelectionContext<'b,'tcx, 'tcx>,\n                                           cause: ObligationCause<'tcx>,\n                                           depth: usize,\n                                           value: &T)\n@@ -322,14 +322,14 @@ pub fn normalize_with_depth<'a,'b,'tcx,T>(selcx: &'a mut SelectionContext<'b,'tc\n }\n \n struct AssociatedTypeNormalizer<'a,'b:'a,'tcx:'b> {\n-    selcx: &'a mut SelectionContext<'b,'tcx>,\n+    selcx: &'a mut SelectionContext<'b,'tcx, 'tcx>,\n     cause: ObligationCause<'tcx>,\n     obligations: Vec<PredicateObligation<'tcx>>,\n     depth: usize,\n }\n \n impl<'a,'b,'tcx> AssociatedTypeNormalizer<'a,'b,'tcx> {\n-    fn new(selcx: &'a mut SelectionContext<'b,'tcx>,\n+    fn new(selcx: &'a mut SelectionContext<'b,'tcx, 'tcx>,\n            cause: ObligationCause<'tcx>,\n            depth: usize)\n            -> AssociatedTypeNormalizer<'a,'b,'tcx>\n@@ -354,7 +354,7 @@ impl<'a,'b,'tcx> AssociatedTypeNormalizer<'a,'b,'tcx> {\n }\n \n impl<'a,'b,'tcx> TypeFolder<'tcx> for AssociatedTypeNormalizer<'a,'b,'tcx> {\n-    fn tcx<'c>(&'c self) -> TyCtxt<'c, 'tcx> {\n+    fn tcx<'c>(&'c self) -> TyCtxt<'c, 'tcx, 'tcx> {\n         self.selcx.tcx()\n     }\n \n@@ -423,7 +423,7 @@ impl<'tcx,T> Normalized<'tcx,T> {\n /// substitute a fresh type variable `$X` and generate a new\n /// obligation `<T as Trait>::Item == $X` for later.\n pub fn normalize_projection_type<'a,'b,'tcx>(\n-    selcx: &'a mut SelectionContext<'b,'tcx>,\n+    selcx: &'a mut SelectionContext<'b,'tcx, 'tcx>,\n     projection_ty: ty::ProjectionTy<'tcx>,\n     cause: ObligationCause<'tcx>,\n     depth: usize)\n@@ -454,7 +454,7 @@ pub fn normalize_projection_type<'a,'b,'tcx>(\n /// additional obligations). Returns `None` in the case of ambiguity,\n /// which indicates that there are unbound type variables.\n fn opt_normalize_projection_type<'a,'b,'tcx>(\n-    selcx: &'a mut SelectionContext<'b,'tcx>,\n+    selcx: &'a mut SelectionContext<'b,'tcx, 'tcx>,\n     projection_ty: ty::ProjectionTy<'tcx>,\n     cause: ObligationCause<'tcx>,\n     depth: usize)\n@@ -542,7 +542,7 @@ fn opt_normalize_projection_type<'a,'b,'tcx>(\n /// an error for this obligation, but we legitimately should not,\n /// because it contains `[type error]`. Yuck! (See issue #29857 for\n /// one case where this arose.)\n-fn normalize_to_error<'a,'tcx>(selcx: &mut SelectionContext<'a,'tcx>,\n+fn normalize_to_error<'a,'tcx>(selcx: &mut SelectionContext<'a,'tcx, 'tcx>,\n                                projection_ty: ty::ProjectionTy<'tcx>,\n                                cause: ObligationCause<'tcx>,\n                                depth: usize)\n@@ -566,7 +566,7 @@ enum ProjectedTy<'tcx> {\n \n /// Compute the result of a projection type (if we can).\n fn project_type<'cx,'tcx>(\n-    selcx: &mut SelectionContext<'cx,'tcx>,\n+    selcx: &mut SelectionContext<'cx,'tcx, 'tcx>,\n     obligation: &ProjectionTyObligation<'tcx>)\n     -> Result<ProjectedTy<'tcx>, ProjectionTyError<'tcx>>\n {\n@@ -749,7 +749,7 @@ fn project_type<'cx,'tcx>(\n /// environment to see whether there are any projection predicates\n /// there that can answer this question.\n fn assemble_candidates_from_param_env<'cx,'tcx>(\n-    selcx: &mut SelectionContext<'cx,'tcx>,\n+    selcx: &mut SelectionContext<'cx,'tcx, 'tcx>,\n     obligation: &ProjectionTyObligation<'tcx>,\n     obligation_trait_ref: &ty::TraitRef<'tcx>,\n     candidate_set: &mut ProjectionTyCandidateSet<'tcx>)\n@@ -775,7 +775,7 @@ fn assemble_candidates_from_param_env<'cx,'tcx>(\n ///\n /// Here, for example, we could conclude that the result is `i32`.\n fn assemble_candidates_from_trait_def<'cx,'tcx>(\n-    selcx: &mut SelectionContext<'cx,'tcx>,\n+    selcx: &mut SelectionContext<'cx,'tcx, 'tcx>,\n     obligation: &ProjectionTyObligation<'tcx>,\n     obligation_trait_ref: &ty::TraitRef<'tcx>,\n     candidate_set: &mut ProjectionTyCandidateSet<'tcx>)\n@@ -807,7 +807,7 @@ fn assemble_candidates_from_trait_def<'cx,'tcx>(\n }\n \n fn assemble_candidates_from_predicates<'cx,'tcx,I>(\n-    selcx: &mut SelectionContext<'cx,'tcx>,\n+    selcx: &mut SelectionContext<'cx,'tcx, 'tcx>,\n     obligation: &ProjectionTyObligation<'tcx>,\n     obligation_trait_ref: &ty::TraitRef<'tcx>,\n     candidate_set: &mut ProjectionTyCandidateSet<'tcx>,\n@@ -854,7 +854,7 @@ fn assemble_candidates_from_predicates<'cx,'tcx,I>(\n }\n \n fn assemble_candidates_from_object_type<'cx,'tcx>(\n-    selcx: &mut SelectionContext<'cx,'tcx>,\n+    selcx: &mut SelectionContext<'cx,'tcx, 'tcx>,\n     obligation:  &ProjectionTyObligation<'tcx>,\n     obligation_trait_ref: &ty::TraitRef<'tcx>,\n     candidate_set: &mut ProjectionTyCandidateSet<'tcx>)\n@@ -886,7 +886,7 @@ fn assemble_candidates_from_object_type<'cx,'tcx>(\n }\n \n fn assemble_candidates_from_impls<'cx,'tcx>(\n-    selcx: &mut SelectionContext<'cx,'tcx>,\n+    selcx: &mut SelectionContext<'cx,'tcx, 'tcx>,\n     obligation: &ProjectionTyObligation<'tcx>,\n     obligation_trait_ref: &ty::TraitRef<'tcx>,\n     candidate_set: &mut ProjectionTyCandidateSet<'tcx>)\n@@ -970,7 +970,7 @@ fn assemble_candidates_from_impls<'cx,'tcx>(\n }\n \n fn confirm_candidate<'cx,'tcx>(\n-    selcx: &mut SelectionContext<'cx,'tcx>,\n+    selcx: &mut SelectionContext<'cx,'tcx, 'tcx>,\n     obligation: &ProjectionTyObligation<'tcx>,\n     candidate: ProjectionTyCandidate<'tcx>)\n     -> (Ty<'tcx>, Vec<PredicateObligation<'tcx>>)\n@@ -1000,7 +1000,7 @@ fn confirm_candidate<'cx,'tcx>(\n }\n \n fn confirm_fn_pointer_candidate<'cx,'tcx>(\n-    selcx: &mut SelectionContext<'cx,'tcx>,\n+    selcx: &mut SelectionContext<'cx,'tcx, 'tcx>,\n     obligation: &ProjectionTyObligation<'tcx>,\n     fn_type: Ty<'tcx>)\n     -> (Ty<'tcx>, Vec<PredicateObligation<'tcx>>)\n@@ -1011,7 +1011,7 @@ fn confirm_fn_pointer_candidate<'cx,'tcx>(\n }\n \n fn confirm_closure_candidate<'cx,'tcx>(\n-    selcx: &mut SelectionContext<'cx,'tcx>,\n+    selcx: &mut SelectionContext<'cx,'tcx, 'tcx>,\n     obligation: &ProjectionTyObligation<'tcx>,\n     vtable: VtableClosureData<'tcx, PredicateObligation<'tcx>>)\n     -> (Ty<'tcx>, Vec<PredicateObligation<'tcx>>)\n@@ -1034,7 +1034,7 @@ fn confirm_closure_candidate<'cx,'tcx>(\n }\n \n fn confirm_callable_candidate<'cx,'tcx>(\n-    selcx: &mut SelectionContext<'cx,'tcx>,\n+    selcx: &mut SelectionContext<'cx,'tcx, 'tcx>,\n     obligation: &ProjectionTyObligation<'tcx>,\n     fn_sig: &ty::PolyFnSig<'tcx>,\n     flag: util::TupleArgumentsFlag)\n@@ -1068,7 +1068,7 @@ fn confirm_callable_candidate<'cx,'tcx>(\n }\n \n fn confirm_param_env_candidate<'cx,'tcx>(\n-    selcx: &mut SelectionContext<'cx,'tcx>,\n+    selcx: &mut SelectionContext<'cx,'tcx, 'tcx>,\n     obligation: &ProjectionTyObligation<'tcx>,\n     poly_projection: ty::PolyProjectionPredicate<'tcx>)\n     -> (Ty<'tcx>, Vec<PredicateObligation<'tcx>>)\n@@ -1107,7 +1107,7 @@ fn confirm_param_env_candidate<'cx,'tcx>(\n }\n \n fn confirm_impl_candidate<'cx,'tcx>(\n-    selcx: &mut SelectionContext<'cx,'tcx>,\n+    selcx: &mut SelectionContext<'cx,'tcx, 'tcx>,\n     obligation: &ProjectionTyObligation<'tcx>,\n     impl_vtable: VtableImplData<'tcx, PredicateObligation<'tcx>>)\n     -> (Ty<'tcx>, Vec<PredicateObligation<'tcx>>)\n@@ -1146,7 +1146,7 @@ fn confirm_impl_candidate<'cx,'tcx>(\n ///\n /// Based on the \"projection mode\", this lookup may in fact only examine the\n /// topmost impl. See the comments for `ProjectionMode` for more details.\n-fn assoc_ty_def<'cx, 'tcx>(selcx: &SelectionContext<'cx, 'tcx>,\n+fn assoc_ty_def<'cx, 'tcx>(selcx: &SelectionContext<'cx, 'tcx, 'tcx>,\n                            impl_def_id: DefId,\n                            assoc_ty_name: ast::Name)\n                            -> Option<specialization_graph::NodeItem<Rc<ty::AssociatedType<'tcx>>>>"}, {"sha": "eda9587f98ed3110f8b5f5b9411002bbe14b165e", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4", "patch": "@@ -49,15 +49,15 @@ use syntax::abi::Abi;\n use hir;\n use util::nodemap::FnvHashMap;\n \n-pub struct SelectionContext<'cx, 'tcx:'cx> {\n-    infcx: &'cx InferCtxt<'cx, 'tcx>,\n+pub struct SelectionContext<'cx, 'gcx: 'cx+'tcx, 'tcx: 'cx> {\n+    infcx: &'cx InferCtxt<'cx, 'gcx, 'tcx>,\n \n     /// Freshener used specifically for skolemizing entries on the\n     /// obligation stack. This ensures that all entries on the stack\n     /// at one time will have the same set of skolemized entries,\n     /// which is important for checking for trait bounds that\n     /// recursively require themselves.\n-    freshener: TypeFreshener<'cx, 'tcx>,\n+    freshener: TypeFreshener<'cx, 'tcx, 'tcx>,\n \n     /// If true, indicates that the evaluation should be conservative\n     /// and consider the possibility of types outside this crate.\n@@ -262,36 +262,36 @@ pub struct EvaluationCache<'tcx> {\n     hashmap: RefCell<FnvHashMap<ty::PolyTraitRef<'tcx>, EvaluationResult>>\n }\n \n-impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n-    pub fn new(infcx: &'cx InferCtxt<'cx, 'tcx>) -> SelectionContext<'cx, 'tcx> {\n+impl<'cx, 'tcx> SelectionContext<'cx, 'tcx, 'tcx> {\n+    pub fn new(infcx: &'cx InferCtxt<'cx, 'tcx, 'tcx>) -> SelectionContext<'cx, 'tcx, 'tcx> {\n         SelectionContext {\n             infcx: infcx,\n             freshener: infcx.freshener(),\n             intercrate: false,\n         }\n     }\n \n-    pub fn intercrate(infcx: &'cx InferCtxt<'cx, 'tcx>) -> SelectionContext<'cx, 'tcx> {\n+    pub fn intercrate(infcx: &'cx InferCtxt<'cx, 'tcx, 'tcx>) -> SelectionContext<'cx, 'tcx, 'tcx> {\n         SelectionContext {\n             infcx: infcx,\n             freshener: infcx.freshener(),\n             intercrate: true,\n         }\n     }\n \n-    pub fn infcx(&self) -> &'cx InferCtxt<'cx, 'tcx> {\n+    pub fn infcx(&self) -> &'cx InferCtxt<'cx, 'tcx, 'tcx> {\n         self.infcx\n     }\n \n-    pub fn tcx(&self) -> TyCtxt<'cx, 'tcx> {\n+    pub fn tcx(&self) -> TyCtxt<'cx, 'tcx, 'tcx> {\n         self.infcx.tcx\n     }\n \n     pub fn param_env(&self) -> &'cx ty::ParameterEnvironment<'cx, 'tcx> {\n         self.infcx.param_env()\n     }\n \n-    pub fn closure_typer(&self) -> &'cx InferCtxt<'cx, 'tcx> {\n+    pub fn closure_typer(&self) -> &'cx InferCtxt<'cx, 'tcx, 'tcx> {\n         self.infcx\n     }\n "}, {"sha": "0de493443a906c1b2d93007bb93872fe7c8d70a1", "filename": "src/librustc/traits/specialize/mod.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs?ref=76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4", "patch": "@@ -31,8 +31,8 @@ use syntax::codemap::DUMMY_SP;\n pub mod specialization_graph;\n \n /// Information pertinent to an overlapping impl error.\n-pub struct Overlap<'a, 'tcx: 'a> {\n-    pub in_context: InferCtxt<'a, 'tcx>,\n+pub struct Overlap<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n+    pub in_context: InferCtxt<'a, 'gcx, 'tcx>,\n     pub with_impl: DefId,\n     pub on_trait_ref: ty::TraitRef<'tcx>,\n }\n@@ -72,7 +72,7 @@ pub struct Overlap<'a, 'tcx: 'a> {\n /// through associated type projection. We deal with such cases by using\n /// *fulfillment* to relate the two impls, requiring that all projections are\n /// resolved.\n-pub fn translate_substs<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n+pub fn translate_substs<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx, 'tcx>,\n                                   source_impl: DefId,\n                                   source_substs: &'tcx Substs<'tcx>,\n                                   target_node: specialization_graph::Node)\n@@ -108,7 +108,9 @@ pub fn translate_substs<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n /// Specialization is determined by the sets of types to which the impls apply;\n /// impl1 specializes impl2 if it applies to a subset of the types impl2 applies\n /// to.\n-pub fn specializes(tcx: TyCtxt, impl1_def_id: DefId, impl2_def_id: DefId) -> bool {\n+pub fn specializes<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                             impl1_def_id: DefId,\n+                             impl2_def_id: DefId) -> bool {\n     // The feature gate should prevent introducing new specializations, but not\n     // taking advantage of upstream ones.\n     if !tcx.sess.features.borrow().specialization &&\n@@ -165,7 +167,7 @@ pub fn specializes(tcx: TyCtxt, impl1_def_id: DefId, impl2_def_id: DefId) -> boo\n /// generics of `target_impl`, including both those needed to unify with\n /// `source_trait_ref` and those whose identity is determined via a where\n /// clause in the impl.\n-fn fulfill_implication<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n+fn fulfill_implication<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx, 'tcx>,\n                                  source_trait_ref: ty::TraitRef<'tcx>,\n                                  target_impl: DefId)\n                                  -> Result<Substs<'tcx>, ()> {"}, {"sha": "8f605a3a556018cdbb235ff374238c60d936e499", "filename": "src/librustc/traits/specialize/specialization_graph.rs", "status": "modified", "additions": 16, "deletions": 11, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs?ref=76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4", "patch": "@@ -78,7 +78,7 @@ enum InsertResult<'a, 'tcx: 'a> {\n \n     /// The impl has an unresolvable overlap with an existing child (neither\n     /// specializes the other).\n-    Overlapped(Overlap<'a, 'tcx>),\n+    Overlapped(Overlap<'a, 'tcx, 'tcx>),\n }\n \n impl<'a, 'tcx> Children {\n@@ -90,7 +90,9 @@ impl<'a, 'tcx> Children {\n     }\n \n     /// Insert an impl into this set of children without comparing to any existing impls\n-    fn insert_blindly(&mut self, tcx: TyCtxt, impl_def_id: DefId) {\n+    fn insert_blindly(&mut self,\n+                      tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                      impl_def_id: DefId) {\n         let trait_ref = tcx.impl_trait_ref(impl_def_id).unwrap();\n         if let Some(sty) = fast_reject::simplify_type(tcx, trait_ref.self_ty(), false) {\n             self.nonblanket_impls.entry(sty).or_insert(vec![]).push(impl_def_id)\n@@ -102,7 +104,7 @@ impl<'a, 'tcx> Children {\n     /// Attempt to insert an impl into this set of children, while comparing for\n     /// specialiation relationships.\n     fn insert(&mut self,\n-              tcx: TyCtxt<'a, 'tcx>,\n+              tcx: TyCtxt<'a, 'tcx, 'tcx>,\n               impl_def_id: DefId,\n               simplified_self: Option<SimplifiedType>)\n               -> InsertResult<'a, 'tcx>\n@@ -174,9 +176,9 @@ impl<'a, 'tcx> Graph {\n     /// conflicts with it (has overlap, but neither specializes the other),\n     /// information about the area of overlap is returned in the `Err`.\n     pub fn insert(&mut self,\n-                  tcx: TyCtxt<'a, 'tcx>,\n+                  tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                   impl_def_id: DefId)\n-                  -> Result<(), Overlap<'a, 'tcx>> {\n+                  -> Result<(), Overlap<'a, 'tcx, 'tcx>> {\n         assert!(impl_def_id.is_local());\n \n         let trait_ref = tcx.impl_trait_ref(impl_def_id).unwrap();\n@@ -235,7 +237,10 @@ impl<'a, 'tcx> Graph {\n     }\n \n     /// Insert cached metadata mapping from a child impl back to its parent.\n-    pub fn record_impl_from_cstore(&mut self, tcx: TyCtxt, parent: DefId, child: DefId) {\n+    pub fn record_impl_from_cstore(&mut self,\n+                                   tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                   parent: DefId,\n+                                   child: DefId) {\n         if self.parent.insert(child, parent).is_some() {\n             bug!(\"When recording an impl from the crate store, information about its parent \\\n                   was already present.\");\n@@ -269,7 +274,7 @@ impl<'a, 'tcx> Node {\n     }\n \n     /// Iterate over the items defined directly by the given (impl or trait) node.\n-    pub fn items(&self, tcx: TyCtxt<'a, 'tcx>) -> NodeItems<'a, 'tcx> {\n+    pub fn items(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> NodeItems<'a, 'tcx> {\n         match *self {\n             Node::Impl(impl_def_id) => {\n                 NodeItems::Impl {\n@@ -299,7 +304,7 @@ impl<'a, 'tcx> Node {\n /// An iterator over the items defined within a trait or impl.\n pub enum NodeItems<'a, 'tcx: 'a> {\n     Impl {\n-        tcx: TyCtxt<'a, 'tcx>,\n+        tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         items: cell::Ref<'a, Vec<ty::ImplOrTraitItemId>>,\n         idx: usize,\n     },\n@@ -411,7 +416,7 @@ impl<'a, 'tcx> Iterator for ConstDefs<'a, 'tcx> {\n impl<'a, 'tcx> Ancestors<'a, 'tcx> {\n     /// Search the items from the given ancestors, returning each type definition\n     /// with the given name.\n-    pub fn type_defs(self, tcx: TyCtxt<'a, 'tcx>, name: Name) -> TypeDefs<'a, 'tcx> {\n+    pub fn type_defs(self, tcx: TyCtxt<'a, 'tcx, 'tcx>, name: Name) -> TypeDefs<'a, 'tcx> {\n         let iter = self.flat_map(move |node| {\n             node.items(tcx)\n                 .filter_map(move |item| {\n@@ -432,7 +437,7 @@ impl<'a, 'tcx> Ancestors<'a, 'tcx> {\n \n     /// Search the items from the given ancestors, returning each fn definition\n     /// with the given name.\n-    pub fn fn_defs(self, tcx: TyCtxt<'a, 'tcx>, name: Name) -> FnDefs<'a, 'tcx> {\n+    pub fn fn_defs(self, tcx: TyCtxt<'a, 'tcx, 'tcx>, name: Name) -> FnDefs<'a, 'tcx> {\n         let iter = self.flat_map(move |node| {\n             node.items(tcx)\n                 .filter_map(move |item| {\n@@ -453,7 +458,7 @@ impl<'a, 'tcx> Ancestors<'a, 'tcx> {\n \n     /// Search the items from the given ancestors, returning each const\n     /// definition with the given name.\n-    pub fn const_defs(self, tcx: TyCtxt<'a, 'tcx>, name: Name) -> ConstDefs<'a, 'tcx> {\n+    pub fn const_defs(self, tcx: TyCtxt<'a, 'tcx, 'tcx>, name: Name) -> ConstDefs<'a, 'tcx> {\n         let iter = self.flat_map(move |node| {\n             node.items(tcx)\n                 .filter_map(move |item| {"}, {"sha": "001f273b31184acc67e0c21502703eb8623efcaf", "filename": "src/librustc/traits/util.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Futil.rs?ref=76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4", "patch": "@@ -18,7 +18,7 @@ use util::nodemap::FnvHashSet;\n \n use super::{Obligation, ObligationCause, PredicateObligation, SelectionContext, Normalized};\n \n-fn anonymize_predicate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx>, pred: &ty::Predicate<'tcx>)\n+fn anonymize_predicate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, pred: &ty::Predicate<'tcx>)\n                                  -> ty::Predicate<'tcx> {\n     match *pred {\n         ty::Predicate::Trait(ref data) =>\n@@ -52,12 +52,12 @@ fn anonymize_predicate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx>, pred: &ty::Predicate<'tc\n \n \n struct PredicateSet<'a,'tcx:'a> {\n-    tcx: TyCtxt<'a, 'tcx>,\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     set: FnvHashSet<ty::Predicate<'tcx>>,\n }\n \n impl<'a,'tcx> PredicateSet<'a,'tcx> {\n-    fn new(tcx: TyCtxt<'a, 'tcx>) -> PredicateSet<'a,'tcx> {\n+    fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> PredicateSet<'a,'tcx> {\n         PredicateSet { tcx: tcx, set: FnvHashSet() }\n     }\n \n@@ -88,21 +88,21 @@ impl<'a,'tcx> PredicateSet<'a,'tcx> {\n /// Foo : 'static`, and we know that `T : Foo`, then we know that `T :\n /// 'static`.\n pub struct Elaborator<'cx, 'tcx:'cx> {\n-    tcx: TyCtxt<'cx, 'tcx>,\n+    tcx: TyCtxt<'cx, 'tcx, 'tcx>,\n     stack: Vec<ty::Predicate<'tcx>>,\n     visited: PredicateSet<'cx,'tcx>,\n }\n \n pub fn elaborate_trait_ref<'cx, 'tcx>(\n-    tcx: TyCtxt<'cx, 'tcx>,\n+    tcx: TyCtxt<'cx, 'tcx, 'tcx>,\n     trait_ref: ty::PolyTraitRef<'tcx>)\n     -> Elaborator<'cx, 'tcx>\n {\n     elaborate_predicates(tcx, vec![trait_ref.to_predicate()])\n }\n \n pub fn elaborate_trait_refs<'cx, 'tcx>(\n-    tcx: TyCtxt<'cx, 'tcx>,\n+    tcx: TyCtxt<'cx, 'tcx, 'tcx>,\n     trait_refs: &[ty::PolyTraitRef<'tcx>])\n     -> Elaborator<'cx, 'tcx>\n {\n@@ -113,7 +113,7 @@ pub fn elaborate_trait_refs<'cx, 'tcx>(\n }\n \n pub fn elaborate_predicates<'cx, 'tcx>(\n-    tcx: TyCtxt<'cx, 'tcx>,\n+    tcx: TyCtxt<'cx, 'tcx, 'tcx>,\n     mut predicates: Vec<ty::Predicate<'tcx>>)\n     -> Elaborator<'cx, 'tcx>\n {\n@@ -222,14 +222,14 @@ impl<'cx, 'tcx> Iterator for Elaborator<'cx, 'tcx> {\n \n pub type Supertraits<'cx, 'tcx> = FilterToTraits<Elaborator<'cx, 'tcx>>;\n \n-pub fn supertraits<'cx, 'tcx>(tcx: TyCtxt<'cx, 'tcx>,\n+pub fn supertraits<'cx, 'tcx>(tcx: TyCtxt<'cx, 'tcx, 'tcx>,\n                               trait_ref: ty::PolyTraitRef<'tcx>)\n                               -> Supertraits<'cx, 'tcx>\n {\n     elaborate_trait_ref(tcx, trait_ref).filter_to_traits()\n }\n \n-pub fn transitive_bounds<'cx, 'tcx>(tcx: TyCtxt<'cx, 'tcx>,\n+pub fn transitive_bounds<'cx, 'tcx>(tcx: TyCtxt<'cx, 'tcx, 'tcx>,\n                                     bounds: &[ty::PolyTraitRef<'tcx>])\n                                     -> Supertraits<'cx, 'tcx>\n {\n@@ -240,12 +240,12 @@ pub fn transitive_bounds<'cx, 'tcx>(tcx: TyCtxt<'cx, 'tcx>,\n // Iterator over def-ids of supertraits\n \n pub struct SupertraitDefIds<'cx, 'tcx:'cx> {\n-    tcx: TyCtxt<'cx, 'tcx>,\n+    tcx: TyCtxt<'cx, 'tcx, 'tcx>,\n     stack: Vec<DefId>,\n     visited: FnvHashSet<DefId>,\n }\n \n-pub fn supertrait_def_ids<'cx, 'tcx>(tcx: TyCtxt<'cx, 'tcx>,\n+pub fn supertrait_def_ids<'cx, 'tcx>(tcx: TyCtxt<'cx, 'tcx, 'tcx>,\n                                      trait_def_id: DefId)\n                                      -> SupertraitDefIds<'cx, 'tcx>\n {\n@@ -319,7 +319,7 @@ impl<'tcx,I:Iterator<Item=ty::Predicate<'tcx>>> Iterator for FilterToTraits<I> {\n /// Instantiate all bound parameters of the impl with the given substs,\n /// returning the resulting trait ref and all obligations that arise.\n /// The obligations are closed under normalization.\n-pub fn impl_trait_ref_and_oblig<'a,'tcx>(selcx: &mut SelectionContext<'a,'tcx>,\n+pub fn impl_trait_ref_and_oblig<'a,'tcx>(selcx: &mut SelectionContext<'a,'tcx, 'tcx>,\n                                          impl_def_id: DefId,\n                                          impl_substs: &Substs<'tcx>)\n                                          -> (ty::TraitRef<'tcx>,\n@@ -352,7 +352,7 @@ pub fn impl_trait_ref_and_oblig<'a,'tcx>(selcx: &mut SelectionContext<'a,'tcx>,\n // declared on the impl declaration e.g., `impl<A,B> for Box<[(A,B)]>`\n // would return ($0, $1) where $0 and $1 are freshly instantiated type\n // variables.\n-pub fn fresh_type_vars_for_impl<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n+pub fn fresh_type_vars_for_impl<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx, 'tcx>,\n                                           span: Span,\n                                           impl_def_id: DefId)\n                                           -> Substs<'tcx>\n@@ -391,7 +391,7 @@ pub fn predicate_for_trait_ref<'tcx>(\n     }\n }\n \n-impl<'a, 'tcx> TyCtxt<'a, 'tcx> {\n+impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n pub fn trait_ref_for_builtin_bound(self,\n     builtin_bound: ty::BuiltinBound,\n     param_ty: Ty<'tcx>)"}, {"sha": "ef53b7360917d91bc2c8583b5018f13e590f6cbc", "filename": "src/librustc/ty/_match.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc%2Fty%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc%2Fty%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2F_match.rs?ref=76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4", "patch": "@@ -29,18 +29,18 @@ use ty::relate::{self, Relate, TypeRelation, RelateResult};\n /// important thing about the result is Ok/Err. Also, matching never\n /// affects any type variables or unification state.\n pub struct Match<'a, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'tcx>\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>\n }\n \n impl<'a, 'tcx> Match<'a, 'tcx> {\n-    pub fn new(tcx: TyCtxt<'a, 'tcx>) -> Match<'a, 'tcx> {\n+    pub fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Match<'a, 'tcx> {\n         Match { tcx: tcx }\n     }\n }\n \n impl<'a, 'tcx> TypeRelation<'a, 'tcx> for Match<'a, 'tcx> {\n     fn tag(&self) -> &'static str { \"Match\" }\n-    fn tcx(&self) -> TyCtxt<'a, 'tcx> { self.tcx }\n+    fn tcx(&self) -> TyCtxt<'a, 'tcx, 'tcx> { self.tcx }\n     fn a_is_expected(&self) -> bool { true } // irrelevant\n \n     fn relate_with_variance<T:Relate<'a,'tcx>>(&mut self,"}, {"sha": "1cc60c808efd6a2597fe199ca903159685ca82c9", "filename": "src/librustc/ty/adjustment.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc%2Fty%2Fadjustment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc%2Fty%2Fadjustment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fadjustment.rs?ref=76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4", "patch": "@@ -139,7 +139,7 @@ pub enum CustomCoerceUnsized {\n impl<'a, 'tcx> ty::TyS<'tcx> {\n     /// See `expr_ty_adjusted`\n     pub fn adjust<F>(&'tcx self,\n-                     tcx: TyCtxt<'a, 'tcx>,\n+                     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                      span: Span,\n                      expr_id: ast::NodeId,\n                      adjustment: Option<&AutoAdjustment<'tcx>>,\n@@ -216,7 +216,7 @@ impl<'a, 'tcx> ty::TyS<'tcx> {\n     }\n \n     pub fn adjust_for_autoderef<F>(&'tcx self,\n-                                   tcx: TyCtxt<'a, 'tcx>,\n+                                   tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                    expr_id: ast::NodeId,\n                                    expr_span: Span,\n                                    autoderef: u32, // how many autoderefs so far?\n@@ -244,7 +244,7 @@ impl<'a, 'tcx> ty::TyS<'tcx> {\n         }\n     }\n \n-    pub fn adjust_for_autoref(&'tcx self, tcx: TyCtxt<'a, 'tcx>,\n+    pub fn adjust_for_autoref(&'tcx self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                               autoref: Option<AutoRef<'tcx>>)\n                               -> Ty<'tcx> {\n         match autoref {"}, {"sha": "33b33092b25c04c672558f9411904c891be416ec", "filename": "src/librustc/ty/contents.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc%2Fty%2Fcontents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc%2Fty%2Fcontents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontents.rs?ref=76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4", "patch": "@@ -140,10 +140,10 @@ impl fmt::Debug for TypeContents {\n }\n \n impl<'a, 'tcx> ty::TyS<'tcx> {\n-    pub fn type_contents(&'tcx self, tcx: TyCtxt<'a, 'tcx>) -> TypeContents {\n+    pub fn type_contents(&'tcx self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> TypeContents {\n         return tcx.tc_cache.memoize(self, || tc_ty(tcx, self, &mut FnvHashMap()));\n \n-        fn tc_ty<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx>,\n+        fn tc_ty<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                            ty: Ty<'tcx>,\n                            cache: &mut FnvHashMap<Ty<'tcx>, TypeContents>) -> TypeContents\n         {\n@@ -255,8 +255,9 @@ impl<'a, 'tcx> ty::TyS<'tcx> {\n             result\n         }\n \n-        fn apply_lang_items(tcx: TyCtxt, did: DefId, tc: TypeContents)\n-                            -> TypeContents {\n+        fn apply_lang_items<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                      did: DefId, tc: TypeContents)\n+                                      -> TypeContents {\n             if Some(did) == tcx.lang_items.unsafe_cell_type() {\n                 tc | TC::InteriorUnsafe\n             } else {"}, {"sha": "bdeb6d146a2925482d3e82277103ec115ac97a57", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 22, "deletions": 18, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4", "patch": "@@ -210,7 +210,7 @@ impl<'a, 'tcx> Tables<'tcx> {\n     }\n \n     pub fn closure_kind(this: &RefCell<Self>,\n-                        tcx: TyCtxt<'a, 'tcx>,\n+                        tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                         def_id: DefId)\n                         -> ty::ClosureKind {\n         // If this is a local def-id, it should be inserted into the\n@@ -226,7 +226,7 @@ impl<'a, 'tcx> Tables<'tcx> {\n     }\n \n     pub fn closure_type(this: &RefCell<Self>,\n-                        tcx: TyCtxt<'a, 'tcx>,\n+                        tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                         def_id: DefId,\n                         substs: &ClosureSubsts<'tcx>)\n                         -> ty::ClosureTy<'tcx>\n@@ -271,14 +271,14 @@ impl<'tcx> CommonTypes<'tcx> {\n /// generates so that so that it can be reused and doesn't have to be redone\n /// later on.\n #[derive(Copy, Clone)]\n-pub struct TyCtxt<'a, 'tcx: 'a> {\n-    gcx: &'a GlobalCtxt<'tcx>,\n+pub struct TyCtxt<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n+    gcx: &'a GlobalCtxt<'gcx>,\n     interners: &'a CtxtInterners<'tcx>\n }\n \n-impl<'a, 'tcx> Deref for TyCtxt<'a, 'tcx> {\n-    type Target = &'a GlobalCtxt<'tcx>;\n-    fn deref(&self) -> &&'a GlobalCtxt<'tcx> {\n+impl<'a, 'gcx, 'tcx> Deref for TyCtxt<'a, 'gcx, 'tcx> {\n+    type Target = &'a GlobalCtxt<'gcx>;\n+    fn deref(&self) -> &Self::Target {\n         &self.gcx\n     }\n }\n@@ -486,15 +486,15 @@ pub struct GlobalCtxt<'tcx> {\n \n impl<'tcx> GlobalCtxt<'tcx> {\n     /// Get the global TyCtxt.\n-    pub fn global_tcx<'a>(&'a self) -> TyCtxt<'a, 'tcx> {\n+    pub fn global_tcx<'a>(&'a self) -> TyCtxt<'a, 'tcx, 'tcx> {\n         TyCtxt {\n             gcx: self,\n             interners: &self.global_interners\n         }\n     }\n }\n \n-impl<'a, 'tcx> TyCtxt<'a, 'tcx> {\n+impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n     pub fn crate_name(self, cnum: ast::CrateNum) -> token::InternedString {\n         if cnum == LOCAL_CRATE {\n             self.crate_name.clone()\n@@ -617,7 +617,7 @@ impl<'a, 'tcx> TyCtxt<'a, 'tcx> {\n                                   stability: stability::Index<'tcx>,\n                                  crate_name: &str,\n                                   f: F) -> R\n-                                  where F: for<'b> FnOnce(TyCtxt<'b, 'tcx>) -> R\n+                                  where F: for<'b> FnOnce(TyCtxt<'b, 'tcx, 'tcx>) -> R\n     {\n         let data_layout = TargetDataLayout::parse(s);\n         let interners = CtxtInterners::new(arenas);\n@@ -693,12 +693,12 @@ impl<'a, 'tcx> TyCtxt<'a, 'tcx> {\n /// e.g. `()` or `u8`, was interned in a different context.\n pub trait Lift<'tcx> {\n     type Lifted;\n-    fn lift_to_tcx<'a>(&self, tcx: TyCtxt<'a, 'tcx>) -> Option<Self::Lifted>;\n+    fn lift_to_tcx<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Option<Self::Lifted>;\n }\n \n impl<'a, 'tcx> Lift<'tcx> for Ty<'a> {\n     type Lifted = Ty<'tcx>;\n-    fn lift_to_tcx<'b>(&self, tcx: TyCtxt<'b, 'tcx>) -> Option<Ty<'tcx>> {\n+    fn lift_to_tcx<'b>(&self, tcx: TyCtxt<'b, 'tcx, 'tcx>) -> Option<Ty<'tcx>> {\n         if let Some(&InternedTy { ty }) = tcx.interners.type_.borrow().get(&self.sty) {\n             if *self as *const _ == ty as *const _ {\n                 return Some(ty);\n@@ -710,7 +710,7 @@ impl<'a, 'tcx> Lift<'tcx> for Ty<'a> {\n \n impl<'a, 'tcx> Lift<'tcx> for &'a Substs<'a> {\n     type Lifted = &'tcx Substs<'tcx>;\n-    fn lift_to_tcx<'b>(&self, tcx: TyCtxt<'b, 'tcx>) -> Option<&'tcx Substs<'tcx>> {\n+    fn lift_to_tcx<'b>(&self, tcx: TyCtxt<'b, 'tcx, 'tcx>) -> Option<&'tcx Substs<'tcx>> {\n         if let Some(&InternedSubsts { substs }) = tcx.interners.substs.borrow().get(*self) {\n             if *self as *const _ == substs as *const _ {\n                 return Some(substs);\n@@ -744,7 +744,7 @@ pub mod tls {\n     }\n \n     pub fn enter<'tcx, F, R>(gcx: GlobalCtxt<'tcx>, f: F) -> R\n-        where F: for<'a> FnOnce(TyCtxt<'a, 'tcx>) -> R\n+        where F: for<'a> FnOnce(TyCtxt<'a, 'tcx, 'tcx>) -> R\n     {\n         codemap::SPAN_DEBUG.with(|span_dbg| {\n             let original_span_debug = span_dbg.get();\n@@ -762,7 +762,9 @@ pub mod tls {\n         })\n     }\n \n-    pub fn with<F: FnOnce(TyCtxt) -> R, R>(f: F) -> R {\n+    pub fn with<F, R>(f: F) -> R\n+        where F: for<'a, 'tcx> FnOnce(TyCtxt<'a, 'tcx, 'tcx>) -> R\n+    {\n         TLS_TCX.with(|gcx| {\n             let gcx = gcx.get().unwrap();\n             let gcx = unsafe { &*(gcx as *const GlobalCtxt) };\n@@ -773,7 +775,9 @@ pub mod tls {\n         })\n     }\n \n-    pub fn with_opt<F: FnOnce(Option<TyCtxt>) -> R, R>(f: F) -> R {\n+    pub fn with_opt<F, R>(f: F) -> R\n+        where F: for<'a, 'tcx> FnOnce(Option<TyCtxt<'a, 'tcx, 'tcx>>) -> R\n+    {\n         if TLS_TCX.with(|gcx| gcx.get().is_some()) {\n             with(|v| f(Some(v)))\n         } else {\n@@ -846,7 +850,7 @@ macro_rules! sty_debug_print {\n     }}\n }\n \n-impl<'a, 'tcx> TyCtxt<'a, 'tcx> {\n+impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n     pub fn print_debug_stats(self) {\n         sty_debug_print!(\n             self,\n@@ -906,7 +910,7 @@ fn bound_list_is_sorted(bounds: &[ty::PolyProjectionPredicate]) -> bool {\n             |(index, bound)| bounds[index].sort_key() <= bound.sort_key())\n }\n \n-impl<'a, 'tcx> TyCtxt<'a, 'tcx> {\n+impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n     // Type constructors\n     pub fn mk_substs(self, substs: Substs<'tcx>) -> &'tcx Substs<'tcx> {\n         if let Some(interned) = self.interners.substs.borrow().get(&substs) {"}, {"sha": "49ab25cc5ad82488aad88140372b453682e4c601", "filename": "src/librustc/ty/error.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ferror.rs?ref=76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4", "patch": "@@ -210,8 +210,8 @@ impl<'tcx> fmt::Display for TypeError<'tcx> {\n     }\n }\n \n-impl<'tcx> ty::TyS<'tcx> {\n-    fn sort_string(&self, tcx: TyCtxt) -> String {\n+impl<'a, 'tcx, 'lcx> ty::TyS<'tcx> {\n+    fn sort_string(&self, tcx: TyCtxt<'a, 'lcx, 'lcx>) -> String {\n         match self.sty {\n             ty::TyBool | ty::TyChar | ty::TyInt(_) |\n             ty::TyUint(_) | ty::TyFloat(_) | ty::TyStr => self.to_string(),\n@@ -252,7 +252,7 @@ impl<'tcx> ty::TyS<'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> TyCtxt<'a, 'tcx> {\n+impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n     pub fn note_and_explain_type_err(self,\n                                      db: &mut DiagnosticBuilder,\n                                      err: &TypeError<'tcx>,"}, {"sha": "ad07894f8bbb5f126cedf7228e0140136daaf561", "filename": "src/librustc/ty/fast_reject.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc%2Fty%2Ffast_reject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc%2Fty%2Ffast_reject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ffast_reject.rs?ref=76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4", "patch": "@@ -43,10 +43,10 @@ pub enum SimplifiedType {\n /// then we can't say much about whether two types would unify. Put another way,\n /// `can_simplify_params` should be true if type parameters appear free in `ty` and `false` if they\n /// are to be considered bound.\n-pub fn simplify_type(tcx: TyCtxt,\n-                     ty: Ty,\n-                     can_simplify_params: bool)\n-                     -> Option<SimplifiedType>\n+pub fn simplify_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                               ty: Ty,\n+                               can_simplify_params: bool)\n+                               -> Option<SimplifiedType>\n {\n     match ty.sty {\n         ty::TyBool => Some(BoolSimplifiedType),"}, {"sha": "d145c080d4bfa94dca3abbc563bfb58586b1d74a", "filename": "src/librustc/ty/fold.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc%2Fty%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc%2Fty%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ffold.rs?ref=76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4", "patch": "@@ -114,7 +114,7 @@ pub trait TypeFoldable<'tcx>: fmt::Debug + Clone {\n /// identity fold, it should invoke `foo.fold_with(self)` to fold each\n /// sub-item.\n pub trait TypeFolder<'tcx> : Sized {\n-    fn tcx<'a>(&'a self) -> TyCtxt<'a, 'tcx>;\n+    fn tcx<'a>(&'a self) -> TyCtxt<'a, 'tcx, 'tcx>;\n \n     fn fold_binder<T>(&mut self, t: &Binder<T>) -> Binder<T>\n         where T : TypeFoldable<'tcx>\n@@ -202,14 +202,14 @@ pub trait TypeVisitor<'tcx> : Sized {\n // Some sample folders\n \n pub struct BottomUpFolder<'a, 'tcx: 'a, F> where F: FnMut(Ty<'tcx>) -> Ty<'tcx> {\n-    pub tcx: TyCtxt<'a, 'tcx>,\n+    pub tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     pub fldop: F,\n }\n \n impl<'a, 'tcx, F> TypeFolder<'tcx> for BottomUpFolder<'a, 'tcx, F> where\n     F: FnMut(Ty<'tcx>) -> Ty<'tcx>,\n {\n-    fn tcx<'b>(&'b self) -> TyCtxt<'b, 'tcx> { self.tcx }\n+    fn tcx<'b>(&'b self) -> TyCtxt<'b, 'tcx, 'tcx> { self.tcx }\n \n     fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n         let t1 = ty.super_fold_with(self);\n@@ -220,7 +220,7 @@ impl<'a, 'tcx, F> TypeFolder<'tcx> for BottomUpFolder<'a, 'tcx, F> where\n ///////////////////////////////////////////////////////////////////////////\n // Region folder\n \n-impl<'a, 'tcx> TyCtxt<'a, 'tcx> {\n+impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n     /// Collects the free and escaping regions in `value` into `region_set`. Returns\n     /// whether any late-bound regions were skipped\n     pub fn collect_regions<T>(self,\n@@ -260,14 +260,14 @@ impl<'a, 'tcx> TyCtxt<'a, 'tcx> {\n /// visited by `fld_r`.\n \n pub struct RegionFolder<'a, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'tcx>,\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     skipped_regions: &'a mut bool,\n     current_depth: u32,\n     fld_r: &'a mut (FnMut(ty::Region, u32) -> ty::Region + 'a),\n }\n \n impl<'a, 'tcx> RegionFolder<'a, 'tcx> {\n-    pub fn new<F>(tcx: TyCtxt<'a, 'tcx>,\n+    pub fn new<F>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                   skipped_regions: &'a mut bool,\n                   fld_r: &'a mut F) -> RegionFolder<'a, 'tcx>\n         where F : FnMut(ty::Region, u32) -> ty::Region\n@@ -283,7 +283,7 @@ impl<'a, 'tcx> RegionFolder<'a, 'tcx> {\n \n impl<'a, 'tcx> TypeFolder<'tcx> for RegionFolder<'a, 'tcx>\n {\n-    fn tcx<'b>(&'b self) -> TyCtxt<'b, 'tcx> { self.tcx }\n+    fn tcx<'b>(&'b self) -> TyCtxt<'b, 'tcx, 'tcx> { self.tcx }\n \n     fn fold_binder<T: TypeFoldable<'tcx>>(&mut self, t: &ty::Binder<T>) -> ty::Binder<T> {\n         self.current_depth += 1;\n@@ -315,13 +315,13 @@ impl<'a, 'tcx> TypeFolder<'tcx> for RegionFolder<'a, 'tcx>\n // Replaces the escaping regions in a type.\n \n struct RegionReplacer<'a, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'tcx>,\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     current_depth: u32,\n     fld_r: &'a mut (FnMut(ty::BoundRegion) -> ty::Region + 'a),\n     map: FnvHashMap<ty::BoundRegion, ty::Region>\n }\n \n-impl<'a, 'tcx> TyCtxt<'a, 'tcx> {\n+impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n     pub fn replace_late_bound_regions<T,F>(self,\n         value: &Binder<T>,\n         mut f: F)\n@@ -409,7 +409,7 @@ impl<'a, 'tcx> TyCtxt<'a, 'tcx> {\n }\n \n impl<'a, 'tcx> RegionReplacer<'a, 'tcx> {\n-    fn new<F>(tcx: TyCtxt<'a, 'tcx>, fld_r: &'a mut F) -> RegionReplacer<'a, 'tcx>\n+    fn new<F>(tcx: TyCtxt<'a, 'tcx, 'tcx>, fld_r: &'a mut F) -> RegionReplacer<'a, 'tcx>\n         where F : FnMut(ty::BoundRegion) -> ty::Region\n     {\n         RegionReplacer {\n@@ -423,7 +423,7 @@ impl<'a, 'tcx> RegionReplacer<'a, 'tcx> {\n \n impl<'a, 'tcx> TypeFolder<'tcx> for RegionReplacer<'a, 'tcx>\n {\n-    fn tcx<'b>(&'b self) -> TyCtxt<'b, 'tcx> { self.tcx }\n+    fn tcx<'b>(&'b self) -> TyCtxt<'b, 'tcx, 'tcx> { self.tcx }\n \n     fn fold_binder<T: TypeFoldable<'tcx>>(&mut self, t: &ty::Binder<T>) -> ty::Binder<T> {\n         self.current_depth += 1;\n@@ -463,7 +463,7 @@ impl<'a, 'tcx> TypeFolder<'tcx> for RegionReplacer<'a, 'tcx>\n ///////////////////////////////////////////////////////////////////////////\n // Region eraser\n \n-impl<'a, 'tcx> TyCtxt<'a, 'tcx> {\n+impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n     /// Returns an equivalent value with all free regions removed (note\n     /// that late-bound regions remain, because they are important for\n     /// subtyping, but they are anonymized and normalized as well)..\n@@ -475,10 +475,10 @@ impl<'a, 'tcx> TyCtxt<'a, 'tcx> {\n                value, value1);\n         return value1;\n \n-        struct RegionEraser<'a, 'tcx: 'a>(TyCtxt<'a, 'tcx>);\n+        struct RegionEraser<'a, 'tcx: 'a>(TyCtxt<'a, 'tcx, 'tcx>);\n \n         impl<'a, 'tcx> TypeFolder<'tcx> for RegionEraser<'a, 'tcx> {\n-            fn tcx<'b>(&'b self) -> TyCtxt<'b, 'tcx> { self.0 }\n+            fn tcx<'b>(&'b self) -> TyCtxt<'b, 'tcx, 'tcx> { self.0 }\n \n             fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n                 match self.tcx().normalized_cache.borrow().get(&ty).cloned() {\n@@ -543,7 +543,7 @@ pub fn shift_region(region: ty::Region, amount: u32) -> ty::Region {\n     }\n }\n \n-pub fn shift_regions<'a, 'tcx, T:TypeFoldable<'tcx>>(tcx: TyCtxt<'a, 'tcx>,\n+pub fn shift_regions<'a, 'tcx, T:TypeFoldable<'tcx>>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                                      amount: u32, value: &T) -> T {\n     debug!(\"shift_regions(value={:?}, amount={})\",\n            value, amount);"}, {"sha": "05e39e9ca44e3f9dc78ba5a6dafee60837faddb1", "filename": "src/librustc/ty/item_path.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc%2Fty%2Fitem_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc%2Fty%2Fitem_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fitem_path.rs?ref=76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4", "patch": "@@ -14,7 +14,7 @@ use hir::def_id::{DefId, CRATE_DEF_INDEX};\n use ty::{self, Ty, TyCtxt};\n use syntax::ast;\n \n-impl<'a, 'tcx> TyCtxt<'a, 'tcx> {\n+impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n     /// Returns a string identifying this def-id. This string is\n     /// suitable for user output. It is relative to the current crate\n     /// root."}, {"sha": "9c9da6960e73e0dd9b25234ee7743a163f8d8462", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4", "patch": "@@ -466,7 +466,7 @@ pub struct Struct {\n     pub offset_after_field: Vec<Size>\n }\n \n-impl Struct {\n+impl<'a, 'tcx> Struct {\n     pub fn new(dl: &TargetDataLayout, packed: bool) -> Struct {\n         Struct {\n             align: if packed { dl.i8_align } else { dl.aggregate_align },\n@@ -477,10 +477,10 @@ impl Struct {\n     }\n \n     /// Extend the Struct with more fields.\n-    pub fn extend<'a, 'tcx, I>(&mut self, dl: &TargetDataLayout,\n-                               fields: I,\n-                               scapegoat: Ty<'tcx>)\n-                               -> Result<(), LayoutError<'tcx>>\n+    pub fn extend<I>(&mut self, dl: &TargetDataLayout,\n+                     fields: I,\n+                     scapegoat: Ty<'tcx>)\n+                     -> Result<(), LayoutError<'tcx>>\n     where I: Iterator<Item=Result<&'a Layout, LayoutError<'tcx>>> {\n         self.offset_after_field.reserve(fields.size_hint().0);\n \n@@ -527,8 +527,8 @@ impl Struct {\n     }\n \n     /// Determine whether a structure would be zero-sized, given its fields.\n-    pub fn would_be_zero_sized<'a, 'tcx, I>(dl: &TargetDataLayout, fields: I)\n-                                            -> Result<bool, LayoutError<'tcx>>\n+    pub fn would_be_zero_sized<I>(dl: &TargetDataLayout, fields: I)\n+                                  -> Result<bool, LayoutError<'tcx>>\n     where I: Iterator<Item=Result<&'a Layout, LayoutError<'tcx>>> {\n         for field in fields {\n             let field = field?;\n@@ -542,9 +542,9 @@ impl Struct {\n     /// Find the path leading to a non-zero leaf field, starting from\n     /// the given type and recursing through aggregates.\n     // FIXME(eddyb) track value ranges and traverse already optimized enums.\n-    pub fn non_zero_field_in_type<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n-                                            ty: Ty<'tcx>)\n-                                            -> Result<Option<FieldPath>, LayoutError<'tcx>> {\n+    pub fn non_zero_field_in_type(infcx: &InferCtxt<'a, 'tcx, 'tcx>,\n+                                  ty: Ty<'tcx>)\n+                                  -> Result<Option<FieldPath>, LayoutError<'tcx>> {\n         let tcx = infcx.tcx;\n         match (ty.layout(infcx)?, &ty.sty) {\n             (&Scalar { non_zero: true, .. }, _) => Ok(Some(vec![])),\n@@ -600,9 +600,9 @@ impl Struct {\n \n     /// Find the path leading to a non-zero leaf field, starting from\n     /// the given set of fields and recursing through aggregates.\n-    pub fn non_zero_field_path<'a, 'tcx, I>(infcx: &InferCtxt<'a, 'tcx>,\n-                                            fields: I)\n-                                            -> Result<Option<FieldPath>, LayoutError<'tcx>>\n+    pub fn non_zero_field_path<I>(infcx: &InferCtxt<'a, 'tcx, 'tcx>,\n+                                  fields: I)\n+                                  -> Result<Option<FieldPath>, LayoutError<'tcx>>\n     where I: Iterator<Item=Ty<'tcx>> {\n         for (i, ty) in fields.enumerate() {\n             if let Some(mut path) = Struct::non_zero_field_in_type(infcx, ty)? {\n@@ -736,7 +736,7 @@ impl<'tcx> fmt::Display for LayoutError<'tcx> {\n }\n \n /// Helper function for normalizing associated types in an inference context.\n-fn normalize_associated_type<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n+fn normalize_associated_type<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx, 'tcx>,\n                                        ty: Ty<'tcx>)\n                                        -> Ty<'tcx> {\n     if !ty.has_projection_types() {\n@@ -757,10 +757,10 @@ fn normalize_associated_type<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n     infcx.drain_fulfillment_cx_or_panic(DUMMY_SP, &mut fulfill_cx, &result)\n }\n \n-impl Layout {\n-    pub fn compute_uncached<'a, 'tcx>(ty: Ty<'tcx>,\n-                                      infcx: &InferCtxt<'a, 'tcx>)\n-                                      -> Result<Layout, LayoutError<'tcx>> {\n+impl<'a, 'tcx> Layout {\n+    pub fn compute_uncached(ty: Ty<'tcx>,\n+                            infcx: &InferCtxt<'a, 'tcx, 'tcx>)\n+                            -> Result<Layout, LayoutError<'tcx>> {\n         let tcx = infcx.tcx;\n         let dl = &tcx.data_layout;\n         assert!(!ty.has_infer_types());\n@@ -1220,9 +1220,9 @@ pub enum SizeSkeleton<'tcx> {\n     }\n }\n \n-impl<'tcx> SizeSkeleton<'tcx> {\n-    pub fn compute<'a>(ty: Ty<'tcx>, infcx: &InferCtxt<'a, 'tcx>)\n-                       -> Result<SizeSkeleton<'tcx>, LayoutError<'tcx>> {\n+impl<'a, 'tcx> SizeSkeleton<'tcx> {\n+    pub fn compute(ty: Ty<'tcx>, infcx: &InferCtxt<'a, 'tcx, 'tcx>)\n+                   -> Result<SizeSkeleton<'tcx>, LayoutError<'tcx>> {\n         let tcx = infcx.tcx;\n         assert!(!ty.has_infer_types());\n "}, {"sha": "5e860eeedf4b693b920a8f0e6ebe44bbcb6e522a", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4", "patch": "@@ -166,7 +166,7 @@ pub struct ImplHeader<'tcx> {\n }\n \n impl<'a, 'tcx> ImplHeader<'tcx> {\n-    pub fn with_fresh_ty_vars(selcx: &mut traits::SelectionContext<'a, 'tcx>,\n+    pub fn with_fresh_ty_vars(selcx: &mut traits::SelectionContext<'a, 'tcx, 'tcx>,\n                               impl_def_id: DefId)\n                               -> ImplHeader<'tcx>\n     {\n@@ -780,14 +780,14 @@ impl<'a, 'tcx> GenericPredicates<'tcx> {\n         }\n     }\n \n-    pub fn instantiate(&self, tcx: TyCtxt<'a, 'tcx>, substs: &Substs<'tcx>)\n+    pub fn instantiate(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, substs: &Substs<'tcx>)\n                        -> InstantiatedPredicates<'tcx> {\n         InstantiatedPredicates {\n             predicates: self.predicates.subst(tcx, substs),\n         }\n     }\n \n-    pub fn instantiate_supertrait(&self, tcx: TyCtxt<'a, 'tcx>,\n+    pub fn instantiate_supertrait(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                   poly_trait_ref: &ty::PolyTraitRef<'tcx>)\n                                   -> InstantiatedPredicates<'tcx>\n     {\n@@ -838,7 +838,7 @@ impl<'a, 'tcx> Predicate<'tcx> {\n     /// poly-trait-ref holds. This is slightly different from a normal\n     /// substitution in terms of what happens with bound regions.  See\n     /// lengthy comment below for details.\n-    pub fn subst_supertrait(&self, tcx: TyCtxt<'a, 'tcx>,\n+    pub fn subst_supertrait(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                             trait_ref: &ty::PolyTraitRef<'tcx>)\n                             -> ty::Predicate<'tcx>\n     {\n@@ -1210,7 +1210,7 @@ impl<'tcx> TraitRef<'tcx> {\n /// more distinctions clearer.\n #[derive(Clone)]\n pub struct ParameterEnvironment<'a, 'tcx:'a> {\n-    pub tcx: TyCtxt<'a, 'tcx>,\n+    pub tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     /// See `construct_free_substs` for details.\n     pub free_substs: Substs<'tcx>,\n@@ -1260,7 +1260,7 @@ impl<'a, 'tcx> ParameterEnvironment<'a, 'tcx> {\n     }\n \n     /// Construct a parameter environment given an item, impl item, or trait item\n-    pub fn for_item(tcx: TyCtxt<'a, 'tcx>, id: NodeId) -> ParameterEnvironment<'a, 'tcx> {\n+    pub fn for_item(tcx: TyCtxt<'a, 'tcx, 'tcx>, id: NodeId) -> ParameterEnvironment<'a, 'tcx> {\n         match tcx.map.find(id) {\n             Some(ast_map::NodeImplItem(ref impl_item)) => {\n                 match impl_item.node {\n@@ -1569,7 +1569,7 @@ impl VariantKind {\n }\n \n impl<'a, 'tcx, 'container> AdtDefData<'tcx, 'container> {\n-    fn new(tcx: TyCtxt<'a, 'tcx>,\n+    fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n            did: DefId,\n            kind: AdtKind,\n            variants: Vec<VariantDefData<'tcx, 'container>>) -> Self {\n@@ -1599,7 +1599,7 @@ impl<'a, 'tcx, 'container> AdtDefData<'tcx, 'container> {\n         }\n     }\n \n-    fn calculate_dtorck(&'tcx self, tcx: TyCtxt<'a, 'tcx>) {\n+    fn calculate_dtorck(&'tcx self, tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n         if tcx.is_adt_dtorck(self) {\n             self.flags.set(self.flags.get() | AdtFlags::IS_DTORCK);\n         }\n@@ -1620,7 +1620,7 @@ impl<'a, 'tcx, 'container> AdtDefData<'tcx, 'container> {\n     /// true, this type being safe for destruction requires it to be\n     /// alive; Otherwise, only the contents are required to be.\n     #[inline]\n-    pub fn is_dtorck(&'tcx self, tcx: TyCtxt<'a, 'tcx>) -> bool {\n+    pub fn is_dtorck(&'tcx self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> bool {\n         if !self.flags.get().intersects(AdtFlags::IS_DTORCK_VALID) {\n             self.calculate_dtorck(tcx)\n         }\n@@ -1661,12 +1661,12 @@ impl<'a, 'tcx, 'container> AdtDefData<'tcx, 'container> {\n     }\n \n     #[inline]\n-    pub fn type_scheme(&self, tcx: TyCtxt<'a, 'tcx>) -> TypeScheme<'tcx> {\n+    pub fn type_scheme(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> TypeScheme<'tcx> {\n         tcx.lookup_item_type(self.did)\n     }\n \n     #[inline]\n-    pub fn predicates(&self, tcx: TyCtxt<'a, 'tcx>) -> GenericPredicates<'tcx> {\n+    pub fn predicates(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> GenericPredicates<'tcx> {\n         tcx.lookup_predicates(self.did)\n     }\n \n@@ -1754,7 +1754,7 @@ impl<'a, 'tcx, 'container> AdtDefData<'tcx, 'container> {\n     ///\n     /// Due to normalization being eager, this applies even if\n     /// the associated type is behind a pointer, e.g. issue #31299.\n-    pub fn sized_constraint(&self, tcx: TyCtxt<'a, 'tcx>) -> Ty<'tcx> {\n+    pub fn sized_constraint(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Ty<'tcx> {\n         let dep_node = DepNode::SizedConstraint(self.did);\n         match self.sized_constraint.get(dep_node) {\n             None => {\n@@ -1783,7 +1783,7 @@ impl<'a, 'tcx> AdtDefData<'tcx, 'tcx> {\n     ///       such.\n     ///     - a TyError, if a type contained itself. The representability\n     ///       check should catch this case.\n-    fn calculate_sized_constraint_inner(&'tcx self, tcx: TyCtxt<'a, 'tcx>,\n+    fn calculate_sized_constraint_inner(&'tcx self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                         stack: &mut Vec<AdtDefMaster<'tcx>>)\n     {\n \n@@ -1836,7 +1836,7 @@ impl<'a, 'tcx> AdtDefData<'tcx, 'tcx> {\n \n     fn sized_constraint_for_ty(\n         &'tcx self,\n-        tcx: TyCtxt<'a, 'tcx>,\n+        tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         stack: &mut Vec<AdtDefMaster<'tcx>>,\n         ty: Ty<'tcx>\n     ) -> Vec<Ty<'tcx>> {\n@@ -1963,7 +1963,7 @@ impl<'a, 'tcx, 'container> FieldDefData<'tcx, 'container> {\n         }\n     }\n \n-    pub fn ty(&self, tcx: TyCtxt<'a, 'tcx>, subst: &Substs<'tcx>) -> Ty<'tcx> {\n+    pub fn ty(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, subst: &Substs<'tcx>) -> Ty<'tcx> {\n         self.unsubst_ty().subst(tcx, subst)\n     }\n \n@@ -1993,8 +1993,8 @@ pub enum ClosureKind {\n     FnOnce,\n }\n \n-impl ClosureKind {\n-    pub fn trait_did(&self, tcx: TyCtxt) -> DefId {\n+impl<'a, 'tcx> ClosureKind {\n+    pub fn trait_did(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> DefId {\n         let result = match *self {\n             ClosureKind::Fn => tcx.lang_items.require(FnTraitLangItem),\n             ClosureKind::FnMut => {\n@@ -2144,7 +2144,7 @@ impl BorrowKind {\n     }\n }\n \n-impl<'a, 'tcx> TyCtxt<'a, 'tcx> {\n+impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n     pub fn node_id_to_type(self, id: NodeId) -> Ty<'tcx> {\n         match self.node_id_to_type_opt(id) {\n            Some(ty) => ty,\n@@ -2941,7 +2941,7 @@ pub enum ExplicitSelfCategory {\n     ByBox,\n }\n \n-impl<'a, 'tcx> TyCtxt<'a, 'tcx> {\n+impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n     pub fn with_freevars<T, F>(self, fid: NodeId, f: F) -> T where\n         F: FnOnce(&[hir::Freevar]) -> T,\n     {"}, {"sha": "7a16989bbb4005bfb984e4c224e7bd93bfe17c5d", "filename": "src/librustc/ty/outlives.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc%2Fty%2Foutlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc%2Fty%2Foutlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Foutlives.rs?ref=76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4", "patch": "@@ -55,7 +55,7 @@ pub enum Component<'tcx> {\n     EscapingProjection(Vec<Component<'tcx>>),\n }\n \n-impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n+impl<'a, 'tcx> InferCtxt<'a, 'tcx, 'tcx> {\n /// Returns all the things that must outlive `'a` for the condition\n /// `ty0: 'a` to hold.\n pub fn outlives_components(&self, ty0: Ty<'tcx>)"}, {"sha": "417b6c5479edcfb9593a479f96557c13b7c91a9f", "filename": "src/librustc/ty/relate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Frelate.rs?ref=76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4", "patch": "@@ -29,7 +29,7 @@ pub enum Cause {\n }\n \n pub trait TypeRelation<'a,'tcx> : Sized {\n-    fn tcx(&self) -> TyCtxt<'a, 'tcx>;\n+    fn tcx(&self) -> TyCtxt<'a, 'tcx, 'tcx>;\n \n     /// Returns a static string we can use for printouts.\n     fn tag(&self) -> &'static str;"}, {"sha": "e715732ceb2b24d3b944b17f6493df4e03ecd145", "filename": "src/librustc/ty/structural_impls.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fstructural_impls.rs?ref=76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4", "patch": "@@ -24,14 +24,14 @@ use hir;\n \n impl<'tcx, A: Lift<'tcx>, B: Lift<'tcx>> Lift<'tcx> for (A, B) {\n     type Lifted = (A::Lifted, B::Lifted);\n-    fn lift_to_tcx<'a>(&self, tcx: TyCtxt<'a, 'tcx>) -> Option<Self::Lifted> {\n+    fn lift_to_tcx<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Option<Self::Lifted> {\n         tcx.lift(&self.0).and_then(|a| tcx.lift(&self.1).map(|b| (a, b)))\n     }\n }\n \n impl<'tcx, T: Lift<'tcx>> Lift<'tcx> for [T] {\n     type Lifted = Vec<T::Lifted>;\n-    fn lift_to_tcx<'a>(&self, tcx: TyCtxt<'a, 'tcx>) -> Option<Self::Lifted> {\n+    fn lift_to_tcx<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Option<Self::Lifted> {\n         // type annotation needed to inform `projection_must_outlive`\n         let mut result : Vec<<T as Lift<'tcx>>::Lifted>\n             = Vec::with_capacity(self.len());\n@@ -55,7 +55,7 @@ impl<'tcx> Lift<'tcx> for ty::Region {\n \n impl<'a, 'tcx> Lift<'tcx> for TraitRef<'a> {\n     type Lifted = TraitRef<'tcx>;\n-    fn lift_to_tcx<'b>(&self, tcx: TyCtxt<'b, 'tcx>) -> Option<TraitRef<'tcx>> {\n+    fn lift_to_tcx<'b>(&self, tcx: TyCtxt<'b, 'tcx, 'tcx>) -> Option<TraitRef<'tcx>> {\n         tcx.lift(&self.substs).map(|substs| TraitRef {\n             def_id: self.def_id,\n             substs: substs\n@@ -65,7 +65,7 @@ impl<'a, 'tcx> Lift<'tcx> for TraitRef<'a> {\n \n impl<'a, 'tcx> Lift<'tcx> for ty::TraitPredicate<'a> {\n     type Lifted = ty::TraitPredicate<'tcx>;\n-    fn lift_to_tcx<'b>(&self, tcx: TyCtxt<'b, 'tcx>) -> Option<ty::TraitPredicate<'tcx>> {\n+    fn lift_to_tcx<'b>(&self, tcx: TyCtxt<'b, 'tcx, 'tcx>) -> Option<ty::TraitPredicate<'tcx>> {\n         tcx.lift(&self.trait_ref).map(|trait_ref| ty::TraitPredicate {\n             trait_ref: trait_ref\n         })\n@@ -74,21 +74,22 @@ impl<'a, 'tcx> Lift<'tcx> for ty::TraitPredicate<'a> {\n \n impl<'a, 'tcx> Lift<'tcx> for ty::EquatePredicate<'a> {\n     type Lifted = ty::EquatePredicate<'tcx>;\n-    fn lift_to_tcx<'b>(&self, tcx: TyCtxt<'b, 'tcx>) -> Option<ty::EquatePredicate<'tcx>> {\n+    fn lift_to_tcx<'b>(&self, tcx: TyCtxt<'b, 'tcx, 'tcx>) -> Option<ty::EquatePredicate<'tcx>> {\n         tcx.lift(&(self.0, self.1)).map(|(a, b)| ty::EquatePredicate(a, b))\n     }\n }\n \n impl<'tcx, A: Copy+Lift<'tcx>, B: Copy+Lift<'tcx>> Lift<'tcx> for ty::OutlivesPredicate<A, B> {\n     type Lifted = ty::OutlivesPredicate<A::Lifted, B::Lifted>;\n-    fn lift_to_tcx<'a>(&self, tcx: TyCtxt<'a, 'tcx>) -> Option<Self::Lifted> {\n+    fn lift_to_tcx<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Option<Self::Lifted> {\n         tcx.lift(&(self.0, self.1)).map(|(a, b)| ty::OutlivesPredicate(a, b))\n     }\n }\n \n impl<'a, 'tcx> Lift<'tcx> for ty::ProjectionPredicate<'a> {\n     type Lifted = ty::ProjectionPredicate<'tcx>;\n-    fn lift_to_tcx<'b>(&self, tcx: TyCtxt<'b, 'tcx>) -> Option<ty::ProjectionPredicate<'tcx>> {\n+    fn lift_to_tcx<'b>(&self, tcx: TyCtxt<'b, 'tcx, 'tcx>)\n+                       -> Option<ty::ProjectionPredicate<'tcx>> {\n         tcx.lift(&(self.projection_ty.trait_ref, self.ty)).map(|(trait_ref, ty)| {\n             ty::ProjectionPredicate {\n                 projection_ty: ty::ProjectionTy {\n@@ -103,7 +104,7 @@ impl<'a, 'tcx> Lift<'tcx> for ty::ProjectionPredicate<'a> {\n \n impl<'tcx, T: Lift<'tcx>> Lift<'tcx> for ty::Binder<T> {\n     type Lifted = ty::Binder<T::Lifted>;\n-    fn lift_to_tcx<'a>(&self, tcx: TyCtxt<'a, 'tcx>) -> Option<Self::Lifted> {\n+    fn lift_to_tcx<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Option<Self::Lifted> {\n         tcx.lift(&self.0).map(|x| ty::Binder(x))\n     }\n }"}, {"sha": "b2aa359af07581190e2f3c56a3ea4102b9780b38", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4", "patch": "@@ -279,7 +279,7 @@ impl<'a, 'tcx> TraitTy<'tcx> {\n     /// we convert the principal trait-ref into a normal trait-ref,\n     /// you must give *some* self-type. A common choice is `mk_err()`\n     /// or some skolemized type.\n-    pub fn principal_trait_ref_with_self_ty(&self, tcx: TyCtxt<'a, 'tcx>,\n+    pub fn principal_trait_ref_with_self_ty(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                             self_ty: Ty<'tcx>)\n                                             -> ty::PolyTraitRef<'tcx>\n     {\n@@ -292,7 +292,7 @@ impl<'a, 'tcx> TraitTy<'tcx> {\n         })\n     }\n \n-    pub fn projection_bounds_with_self_ty(&self, tcx: TyCtxt<'a, 'tcx>,\n+    pub fn projection_bounds_with_self_ty(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                           self_ty: Ty<'tcx>)\n                                           -> Vec<ty::PolyProjectionPredicate<'tcx>>\n     {\n@@ -537,7 +537,7 @@ impl<'a, 'tcx> ParamTy {\n         ParamTy::new(def.space, def.index, def.name)\n     }\n \n-    pub fn to_ty(self, tcx: TyCtxt<'a, 'tcx>) -> Ty<'tcx> {\n+    pub fn to_ty(self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Ty<'tcx> {\n         tcx.mk_param(self.space, self.idx, self.name)\n     }\n \n@@ -771,7 +771,7 @@ impl<'a, 'tcx> BuiltinBounds {\n         self.into_iter()\n     }\n \n-    pub fn to_predicates(&self, tcx: TyCtxt<'a, 'tcx>,\n+    pub fn to_predicates(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                          self_ty: Ty<'tcx>)\n                          -> Vec<ty::Predicate<'tcx>> {\n         self.iter().filter_map(|builtin_bound|\n@@ -819,7 +819,7 @@ impl CLike for BuiltinBound {\n     }\n }\n \n-impl<'a, 'tcx> TyCtxt<'a, 'tcx> {\n+impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n     pub fn try_add_builtin_trait(self,\n                                  trait_def_id: DefId,\n                                  builtin_bounds: &mut EnumSet<BuiltinBound>)\n@@ -971,15 +971,15 @@ impl<'a, 'tcx> TyS<'tcx> {\n         }\n     }\n \n-    pub fn sequence_element_type(&self, tcx: TyCtxt<'a, 'tcx>) -> Ty<'tcx> {\n+    pub fn sequence_element_type(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Ty<'tcx> {\n         match self.sty {\n             TyArray(ty, _) | TySlice(ty) => ty,\n             TyStr => tcx.mk_mach_uint(ast::UintTy::U8),\n             _ => bug!(\"sequence_element_type called on non-sequence value: {}\", self),\n         }\n     }\n \n-    pub fn simd_type(&self, tcx: TyCtxt<'a, 'tcx>) -> Ty<'tcx> {\n+    pub fn simd_type(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Ty<'tcx> {\n         match self.sty {\n             TyStruct(def, substs) => {\n                 def.struct_variant().fields[0].ty(tcx, substs)"}, {"sha": "655aa3e969375787147e123e385a062dcdd6239a", "filename": "src/librustc/ty/subst.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc%2Fty%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc%2Fty%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsubst.rs?ref=76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4", "patch": "@@ -122,7 +122,7 @@ impl<'a, 'tcx> Substs<'tcx> {\n     }\n \n     /// Creates a trait-ref out of this substs, ignoring the FnSpace substs\n-    pub fn to_trait_ref(&self, tcx: TyCtxt<'a, 'tcx>, trait_id: DefId)\n+    pub fn to_trait_ref(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, trait_id: DefId)\n                         -> ty::TraitRef<'tcx> {\n         let Substs { mut types, mut regions } = self.clone();\n         types.truncate(FnSpace, 0);\n@@ -532,18 +532,18 @@ impl<'a,T> IntoIterator for &'a VecPerParamSpace<T> {\n // there is more information available (for better errors).\n \n pub trait Subst<'tcx> : Sized {\n-    fn subst<'a>(&self, tcx: TyCtxt<'a, 'tcx>, substs: &Substs<'tcx>) -> Self {\n+    fn subst<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, substs: &Substs<'tcx>) -> Self {\n         self.subst_spanned(tcx, substs, None)\n     }\n \n-    fn subst_spanned<'a>(&self, tcx: TyCtxt<'a, 'tcx>,\n+    fn subst_spanned<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                          substs: &Substs<'tcx>,\n                          span: Option<Span>)\n                          -> Self;\n }\n \n impl<'tcx, T:TypeFoldable<'tcx>> Subst<'tcx> for T {\n-    fn subst_spanned<'a>(&self, tcx: TyCtxt<'a, 'tcx>,\n+    fn subst_spanned<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                          substs: &Substs<'tcx>,\n                          span: Option<Span>)\n                          -> T\n@@ -562,7 +562,7 @@ impl<'tcx, T:TypeFoldable<'tcx>> Subst<'tcx> for T {\n // The actual substitution engine itself is a type folder.\n \n struct SubstFolder<'a, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'tcx>,\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     substs: &'a Substs<'tcx>,\n \n     // The location for which the substitution is performed, if available.\n@@ -579,7 +579,7 @@ struct SubstFolder<'a, 'tcx: 'a> {\n }\n \n impl<'a, 'tcx> TypeFolder<'tcx> for SubstFolder<'a, 'tcx> {\n-    fn tcx<'b>(&'b self) -> TyCtxt<'b, 'tcx> { self.tcx }\n+    fn tcx<'b>(&'b self) -> TyCtxt<'b, 'tcx, 'tcx> { self.tcx }\n \n     fn fold_binder<T: TypeFoldable<'tcx>>(&mut self, t: &ty::Binder<T>) -> ty::Binder<T> {\n         self.region_binders_passed += 1;"}, {"sha": "c08d2dc0848092e4e78b78ba11f74d4ab133a3f9", "filename": "src/librustc/ty/trait_def.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc%2Fty%2Ftrait_def.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc%2Fty%2Ftrait_def.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ftrait_def.rs?ref=76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4", "patch": "@@ -117,18 +117,18 @@ impl<'a, 'tcx> TraitDef<'tcx> {\n         );\n     }\n \n-    fn write_trait_impls(&self, tcx: TyCtxt<'a, 'tcx>) {\n+    fn write_trait_impls(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n         tcx.dep_graph.write(DepNode::TraitImpls(self.trait_ref.def_id));\n     }\n \n-    fn read_trait_impls(&self, tcx: TyCtxt<'a, 'tcx>) {\n+    fn read_trait_impls(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n         tcx.dep_graph.read(DepNode::TraitImpls(self.trait_ref.def_id));\n     }\n \n     /// Records a basic trait-to-implementation mapping.\n     ///\n     /// Returns `true` iff the impl has not previously been recorded.\n-    fn record_impl(&self, tcx: TyCtxt<'a, 'tcx>,\n+    fn record_impl(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                    impl_def_id: DefId,\n                    impl_trait_ref: TraitRef<'tcx>)\n                    -> bool {\n@@ -163,7 +163,7 @@ impl<'a, 'tcx> TraitDef<'tcx> {\n     }\n \n     /// Records a trait-to-implementation mapping for a crate-local impl.\n-    pub fn record_local_impl(&self, tcx: TyCtxt<'a, 'tcx>,\n+    pub fn record_local_impl(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                              impl_def_id: DefId,\n                              impl_trait_ref: TraitRef<'tcx>) {\n         assert!(impl_def_id.is_local());\n@@ -176,7 +176,7 @@ impl<'a, 'tcx> TraitDef<'tcx> {\n     /// The `parent_impl` is the immediately-less-specialized impl, or the\n     /// trait's def ID if the impl is not a specialization -- information that\n     /// should be pulled from the metadata.\n-    pub fn record_remote_impl(&self, tcx: TyCtxt<'a, 'tcx>,\n+    pub fn record_remote_impl(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                               impl_def_id: DefId,\n                               impl_trait_ref: TraitRef<'tcx>,\n                               parent_impl: DefId) {\n@@ -194,9 +194,10 @@ impl<'a, 'tcx> TraitDef<'tcx> {\n     /// Adds a local impl into the specialization graph, returning an error with\n     /// overlap information if the impl overlaps but does not specialize an\n     /// existing impl.\n-    pub fn add_impl_for_specialization(&self, tcx: TyCtxt<'a, 'tcx>,\n+    pub fn add_impl_for_specialization(&self,\n+                                       tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                        impl_def_id: DefId)\n-                                       -> Result<(), traits::Overlap<'a, 'tcx>> {\n+                                       -> Result<(), traits::Overlap<'a, 'tcx, 'tcx>> {\n         assert!(impl_def_id.is_local());\n \n         self.specialization_graph.borrow_mut()\n@@ -207,7 +208,7 @@ impl<'a, 'tcx> TraitDef<'tcx> {\n         specialization_graph::ancestors(self, of_impl)\n     }\n \n-    pub fn for_each_impl<F: FnMut(DefId)>(&self, tcx: TyCtxt<'a, 'tcx>, mut f: F) {\n+    pub fn for_each_impl<F: FnMut(DefId)>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, mut f: F) {\n         self.read_trait_impls(tcx);\n         tcx.populate_implementations_for_trait_if_necessary(self.trait_ref.def_id);\n \n@@ -225,7 +226,7 @@ impl<'a, 'tcx> TraitDef<'tcx> {\n     /// Iterate over every impl that could possibly match the\n     /// self-type `self_ty`.\n     pub fn for_each_relevant_impl<F: FnMut(DefId)>(&self,\n-                                                   tcx: TyCtxt<'a, 'tcx>,\n+                                                   tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                                    self_ty: Ty<'tcx>,\n                                                    mut f: F)\n     {"}, {"sha": "8402efcabc6f8882924f30b51ccbaeaa243e5259", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 16, "deletions": 13, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4", "patch": "@@ -32,14 +32,15 @@ use syntax::codemap::Span;\n use hir;\n \n pub trait IntTypeExt {\n-    fn to_ty<'a, 'tcx>(&self, tcx: TyCtxt<'a, 'tcx>) -> Ty<'tcx>;\n-    fn disr_incr(&self, tcx: TyCtxt, val: Option<Disr>) -> Option<Disr>;\n+    fn to_ty<'a, 'tcx>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Ty<'tcx>;\n+    fn disr_incr<'a, 'tcx>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, val: Option<Disr>)\n+                           -> Option<Disr>;\n     fn assert_ty_matches(&self, val: Disr);\n-    fn initial_discriminant(&self, tcx: TyCtxt) -> Disr;\n+    fn initial_discriminant<'a, 'tcx>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Disr;\n }\n \n impl IntTypeExt for attr::IntType {\n-    fn to_ty<'a, 'tcx>(&self, tcx: TyCtxt<'a, 'tcx>) -> Ty<'tcx> {\n+    fn to_ty<'a, 'tcx>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Ty<'tcx> {\n         match *self {\n             SignedInt(ast::IntTy::I8)      => tcx.types.i8,\n             SignedInt(ast::IntTy::I16)     => tcx.types.i16,\n@@ -54,7 +55,7 @@ impl IntTypeExt for attr::IntType {\n         }\n     }\n \n-    fn initial_discriminant(&self, tcx: TyCtxt) -> Disr {\n+    fn initial_discriminant<'a, 'tcx>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Disr {\n         match *self {\n             SignedInt(ast::IntTy::I8)    => ConstInt::I8(0),\n             SignedInt(ast::IntTy::I16)   => ConstInt::I16(0),\n@@ -93,7 +94,8 @@ impl IntTypeExt for attr::IntType {\n         }\n     }\n \n-    fn disr_incr(&self, tcx: TyCtxt, val: Option<Disr>) -> Option<Disr> {\n+    fn disr_incr<'a, 'tcx>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, val: Option<Disr>)\n+                           -> Option<Disr> {\n         if let Some(val) = val {\n             self.assert_ty_matches(val);\n             (val + ConstInt::Infer(1)).ok()\n@@ -170,7 +172,7 @@ impl<'a, 'tcx> ParameterEnvironment<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> TyCtxt<'a, 'tcx> {\n+impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n     pub fn pat_contains_ref_binding(self, pat: &hir::Pat) -> Option<hir::Mutability> {\n         pat_util::pat_contains_ref_binding(&self.def_map, pat)\n     }\n@@ -337,7 +339,7 @@ impl<'a, 'tcx> TyCtxt<'a, 'tcx> {\n         helper(self, ty, svh, &mut state);\n         return state.finish();\n \n-        fn helper<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx>, ty: Ty<'tcx>, svh: &Svh,\n+        fn helper<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, ty: Ty<'tcx>, svh: &Svh,\n                         state: &mut SipHasher) {\n             macro_rules! byte { ($b:expr) => { ($b as u8).hash(state) } }\n             macro_rules! hash { ($e:expr) => { $e.hash(state) }  }\n@@ -600,7 +602,7 @@ impl<'a, 'tcx> ty::TyS<'tcx> {\n     }\n \n     #[inline]\n-    pub fn layout(&'tcx self, infcx: &InferCtxt<'a, 'tcx>)\n+    pub fn layout(&'tcx self, infcx: &InferCtxt<'a, 'tcx, 'tcx>)\n                   -> Result<&'tcx Layout, LayoutError<'tcx>> {\n         let can_cache = !self.has_param_types() && !self.has_self_ty();\n         if can_cache {\n@@ -620,10 +622,11 @@ impl<'a, 'tcx> ty::TyS<'tcx> {\n \n     /// Check whether a type is representable. This means it cannot contain unboxed\n     /// structural recursion. This check is needed for structs and enums.\n-    pub fn is_representable(&'tcx self, tcx: TyCtxt<'a, 'tcx>, sp: Span) -> Representability {\n+    pub fn is_representable(&'tcx self, tcx: TyCtxt<'a, 'tcx, 'tcx>, sp: Span)\n+                            -> Representability {\n \n         // Iterate until something non-representable is found\n-        fn find_nonrepresentable<'a, 'tcx, It>(tcx: TyCtxt<'a, 'tcx>,\n+        fn find_nonrepresentable<'a, 'tcx, It>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                                sp: Span,\n                                                seen: &mut Vec<Ty<'tcx>>,\n                                                iter: It)\n@@ -633,7 +636,7 @@ impl<'a, 'tcx> ty::TyS<'tcx> {\n                       |r, ty| cmp::max(r, is_type_structurally_recursive(tcx, sp, seen, ty)))\n         }\n \n-        fn are_inner_types_recursive<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx>, sp: Span,\n+        fn are_inner_types_recursive<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, sp: Span,\n                                                seen: &mut Vec<Ty<'tcx>>, ty: Ty<'tcx>)\n                                                -> Representability {\n             match ty.sty {\n@@ -692,7 +695,7 @@ impl<'a, 'tcx> ty::TyS<'tcx> {\n \n         // Does the type `ty` directly (without indirection through a pointer)\n         // contain any types on stack `seen`?\n-        fn is_type_structurally_recursive<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx>,\n+        fn is_type_structurally_recursive<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                                     sp: Span,\n                                                     seen: &mut Vec<Ty<'tcx>>,\n                                                     ty: Ty<'tcx>) -> Representability {"}, {"sha": "9b701c6abc0d4d642afb2442dfee5065ebaa1e0c", "filename": "src/librustc/ty/wf.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc%2Fty%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc%2Fty%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fwf.rs?ref=76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4", "patch": "@@ -25,7 +25,7 @@ use util::common::ErrorReported;\n /// inference variable, returns `None`, because we are not able to\n /// make any progress at all. This is to prevent \"livelock\" where we\n /// say \"$0 is WF if $0 is WF\".\n-pub fn obligations<'a,'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n+pub fn obligations<'a,'tcx>(infcx: &InferCtxt<'a, 'tcx, 'tcx>,\n                             body_id: ast::NodeId,\n                             ty: Ty<'tcx>,\n                             span: Span)\n@@ -49,7 +49,7 @@ pub fn obligations<'a,'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n /// well-formed.  For example, if there is a trait `Set` defined like\n /// `trait Set<K:Eq>`, then the trait reference `Foo: Set<Bar>` is WF\n /// if `Bar: Eq`.\n-pub fn trait_obligations<'a,'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n+pub fn trait_obligations<'a,'tcx>(infcx: &InferCtxt<'a, 'tcx, 'tcx>,\n                                   body_id: ast::NodeId,\n                                   trait_ref: &ty::TraitRef<'tcx>,\n                                   span: Span)\n@@ -60,7 +60,7 @@ pub fn trait_obligations<'a,'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n     wf.normalize()\n }\n \n-pub fn predicate_obligations<'a,'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n+pub fn predicate_obligations<'a,'tcx>(infcx: &InferCtxt<'a, 'tcx, 'tcx>,\n                                       body_id: ast::NodeId,\n                                       predicate: &ty::Predicate<'tcx>,\n                                       span: Span)\n@@ -123,8 +123,8 @@ pub enum ImpliedBound<'tcx> {\n /// Compute the implied bounds that a callee/impl can assume based on\n /// the fact that caller/projector has ensured that `ty` is WF.  See\n /// the `ImpliedBound` type for more details.\n-pub fn implied_bounds<'a,'tcx>(\n-    infcx: &'a InferCtxt<'a,'tcx>,\n+pub fn implied_bounds<'a, 'tcx>(\n+    infcx: &'a InferCtxt<'a, 'tcx, 'tcx>,\n     body_id: ast::NodeId,\n     ty: Ty<'tcx>,\n     span: Span)\n@@ -228,7 +228,7 @@ fn implied_bounds_from_components<'tcx>(sub_region: ty::Region,\n }\n \n struct WfPredicates<'a,'tcx:'a> {\n-    infcx: &'a InferCtxt<'a, 'tcx>,\n+    infcx: &'a InferCtxt<'a, 'tcx, 'tcx>,\n     body_id: ast::NodeId,\n     span: Span,\n     out: Vec<traits::PredicateObligation<'tcx>>,\n@@ -526,7 +526,7 @@ impl<'a,'tcx> WfPredicates<'a,'tcx> {\n /// `'static` would appear in the list. The hard work is done by\n /// `ty::required_region_bounds`, see that for more information.\n pub fn object_region_bounds<'a, 'tcx>(\n-    tcx: TyCtxt<'a, 'tcx>,\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     principal: &ty::PolyTraitRef<'tcx>,\n     others: ty::BuiltinBounds)\n     -> Vec<ty::Region>"}, {"sha": "47d7e3a0a3c63237019ff4c865d763467bc51702", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4", "patch": "@@ -68,12 +68,12 @@ pub enum Ns {\n     Value\n }\n \n-fn number_of_supplied_defaults<'a, 'tcx, GG>(tcx: TyCtxt<'a, 'tcx>,\n+fn number_of_supplied_defaults<'a, 'tcx, GG>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                              substs: &subst::Substs,\n                                              space: subst::ParamSpace,\n                                              get_generics: GG)\n                                              -> usize\n-    where GG: FnOnce(TyCtxt<'a, 'tcx>) -> ty::Generics<'tcx>\n+    where GG: FnOnce(TyCtxt<'a, 'tcx, 'tcx>) -> ty::Generics<'tcx>\n {\n     let generics = get_generics(tcx);\n \n@@ -114,7 +114,7 @@ pub fn parameterized<GG>(f: &mut fmt::Formatter,\n                          projections: &[ty::ProjectionPredicate],\n                          get_generics: GG)\n                          -> fmt::Result\n-    where GG: for<'a, 'tcx> FnOnce(TyCtxt<'a, 'tcx>) -> ty::Generics<'tcx>\n+    where GG: for<'a, 'tcx> FnOnce(TyCtxt<'a, 'tcx, 'tcx>) -> ty::Generics<'tcx>\n {\n     if let (Ns::Value, Some(self_ty)) = (ns, substs.self_ty()) {\n         write!(f, \"<{} as \", self_ty)?;\n@@ -231,7 +231,7 @@ pub fn parameterized<GG>(f: &mut fmt::Formatter,\n }\n \n fn in_binder<'a, 'tcx, T, U>(f: &mut fmt::Formatter,\n-                             tcx: TyCtxt<'a, 'tcx>,\n+                             tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                              original: &ty::Binder<T>,\n                              lifted: Option<ty::Binder<U>>) -> fmt::Result\n     where T: fmt::Display, U: fmt::Display + TypeFoldable<'tcx>"}, {"sha": "50db6c9bfed40c000547d6aa491c9d357654de09", "filename": "src/librustc_borrowck/borrowck/check_loans.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs?ref=76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4", "patch": "@@ -233,7 +233,7 @@ fn compatible_borrow_kinds(borrow_kind1: ty::BorrowKind,\n }\n \n impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n-    pub fn tcx(&self) -> TyCtxt<'a, 'tcx> { self.bccx.tcx }\n+    pub fn tcx(&self) -> TyCtxt<'a, 'tcx, 'tcx> { self.bccx.tcx }\n \n     pub fn each_issued_loan<F>(&self, node: ast::NodeId, mut op: F) -> bool where\n         F: FnMut(&Loan<'tcx>) -> bool,"}, {"sha": "6ab85d7d449dc7c2000c6a13c3923fe50ad3cfe9", "filename": "src/librustc_borrowck/borrowck/fragments.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc_borrowck%2Fborrowck%2Ffragments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc_borrowck%2Fborrowck%2Ffragments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Ffragments.rs?ref=76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4", "patch": "@@ -200,7 +200,7 @@ impl FragmentSets {\n }\n \n pub fn instrument_move_fragments<'a, 'tcx>(this: &MoveData<'tcx>,\n-                                           tcx: TyCtxt<'a, 'tcx>,\n+                                           tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                            sp: Span,\n                                            id: ast::NodeId) {\n     let span_err = tcx.map.attrs(id).iter()\n@@ -245,7 +245,7 @@ pub fn instrument_move_fragments<'a, 'tcx>(this: &MoveData<'tcx>,\n ///\n /// Note: \"left-over fragments\" means paths that were not directly referenced in moves nor\n /// assignments, but must nonetheless be tracked as potential drop obligations.\n-pub fn fixup_fragment_sets<'a, 'tcx>(this: &MoveData<'tcx>, tcx: TyCtxt<'a, 'tcx>) {\n+pub fn fixup_fragment_sets<'a, 'tcx>(this: &MoveData<'tcx>, tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n \n     let mut fragments = this.fragments.borrow_mut();\n \n@@ -347,7 +347,7 @@ pub fn fixup_fragment_sets<'a, 'tcx>(this: &MoveData<'tcx>, tcx: TyCtxt<'a, 'tcx\n /// example, if `lp` represents `s.x.j`, then adds moves paths for `s.x.i` and `s.x.k`, the\n /// siblings of `s.x.j`.\n fn add_fragment_siblings<'a, 'tcx>(this: &MoveData<'tcx>,\n-                                   tcx: TyCtxt<'a, 'tcx>,\n+                                   tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                    gathered_fragments: &mut Vec<Fragment>,\n                                    lp: Rc<LoanPath<'tcx>>,\n                                    origin_id: Option<ast::NodeId>) {\n@@ -406,7 +406,7 @@ fn add_fragment_siblings<'a, 'tcx>(this: &MoveData<'tcx>,\n /// We have determined that `origin_lp` destructures to LpExtend(parent, original_field_name).\n /// Based on this, add move paths for all of the siblings of `origin_lp`.\n fn add_fragment_siblings_for_extension<'a, 'tcx>(this: &MoveData<'tcx>,\n-                                                 tcx: TyCtxt<'a, 'tcx>,\n+                                                 tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                                  gathered_fragments: &mut Vec<Fragment>,\n                                                  parent_lp: &Rc<LoanPath<'tcx>>,\n                                                  mc: mc::MutabilityCategory,\n@@ -505,7 +505,7 @@ fn add_fragment_siblings_for_extension<'a, 'tcx>(this: &MoveData<'tcx>,\n /// Adds the single sibling `LpExtend(parent, new_field_name)` of `origin_lp` (the original\n /// loan-path).\n fn add_fragment_sibling_core<'a, 'tcx>(this: &MoveData<'tcx>,\n-                                       tcx: TyCtxt<'a, 'tcx>,\n+                                       tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                        gathered_fragments: &mut Vec<Fragment>,\n                                        parent: Rc<LoanPath<'tcx>>,\n                                        mc: mc::MutabilityCategory,"}, {"sha": "c6d329bb0ef218350bd107ed54fa11b4301e981b", "filename": "src/librustc_borrowck/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4", "patch": "@@ -255,7 +255,7 @@ fn check_mutability<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n }\n \n impl<'a, 'tcx> GatherLoanCtxt<'a, 'tcx> {\n-    pub fn tcx(&self) -> TyCtxt<'a, 'tcx> { self.bccx.tcx }\n+    pub fn tcx(&self) -> TyCtxt<'a, 'tcx, 'tcx> { self.bccx.tcx }\n \n     /// Guarantees that `cmt` is assignable, or reports an error.\n     fn guarantee_assignment_valid(&mut self,"}, {"sha": "d6dd176e3ba288b4cabf600c5723621f69b79ff3", "filename": "src/librustc_borrowck/borrowck/mir/dataflow.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow.rs?ref=76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4", "patch": "@@ -459,7 +459,7 @@ impl<D: BitDenotation> DataflowState<D> {\n \n \n impl<'a, 'tcx> DataflowState<MoveData<'tcx>> {\n-    pub fn new_move_analysis(mir: &Mir<'tcx>, tcx: TyCtxt<'a, 'tcx>) -> Self {\n+    pub fn new_move_analysis(mir: &Mir<'tcx>, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Self {\n         let move_data = MoveData::gather_moves(mir, tcx);\n         DataflowState::new(mir, move_data)\n     }"}, {"sha": "bf3d671bdb5af5611e28d55e2d022ced7793cd98", "filename": "src/librustc_borrowck/borrowck/mir/gather_moves.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fgather_moves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fgather_moves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fgather_moves.rs?ref=76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4", "patch": "@@ -483,7 +483,7 @@ impl<'a, 'tcx> MovePathDataBuilder<'a, 'tcx> {\n }\n \n impl<'a, 'tcx> MoveData<'tcx> {\n-    pub fn gather_moves(mir: &Mir<'tcx>, tcx: TyCtxt<'a, 'tcx>) -> Self {\n+    pub fn gather_moves(mir: &Mir<'tcx>, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Self {\n         gather_moves(mir, tcx)\n     }\n }\n@@ -494,7 +494,7 @@ enum StmtKind {\n     Aggregate, Drop, CallFn, CallArg, Return,\n }\n \n-fn gather_moves<'a, 'tcx>(mir: &Mir<'tcx>, tcx: TyCtxt<'a, 'tcx>) -> MoveData<'tcx> {\n+fn gather_moves<'a, 'tcx>(mir: &Mir<'tcx>, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> MoveData<'tcx> {\n     use self::StmtKind as SK;\n \n     let bbs = mir.all_basic_blocks();\n@@ -667,7 +667,7 @@ fn gather_moves<'a, 'tcx>(mir: &Mir<'tcx>, tcx: TyCtxt<'a, 'tcx>) -> MoveData<'t\n }\n \n struct BlockContext<'b, 'a: 'b, 'tcx: 'a> {\n-    tcx: TyCtxt<'b, 'tcx>,\n+    tcx: TyCtxt<'b, 'tcx, 'tcx>,\n     moves: &'b mut Vec<MoveOut>,\n     builder: MovePathDataBuilder<'a, 'tcx>,\n     path_map: &'b mut Vec<Vec<MoveOutIndex>>,"}, {"sha": "cfc12a710827fe17329b813d5625642fdd407bd4", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4", "patch": "@@ -100,7 +100,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for BorrowckCtxt<'a, 'tcx> {\n     }\n }\n \n-pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx>, mir_map: &MirMap<'tcx>) {\n+pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, mir_map: &MirMap<'tcx>) {\n     let mut bccx = BorrowckCtxt {\n         tcx: tcx,\n         mir_map: Some(mir_map),\n@@ -244,7 +244,7 @@ fn build_borrowck_dataflow_data<'a, 'tcx>(this: &mut BorrowckCtxt<'a, 'tcx>,\n /// Accessor for introspective clients inspecting `AnalysisData` and\n /// the `BorrowckCtxt` itself , e.g. the flowgraph visualizer.\n pub fn build_borrowck_dataflow_data_for_fn<'a, 'tcx>(\n-    tcx: TyCtxt<'a, 'tcx>,\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     mir_map: Option<&'a MirMap<'tcx>>,\n     fn_parts: FnParts<'a>,\n     cfg: &cfg::CFG)\n@@ -278,7 +278,7 @@ pub fn build_borrowck_dataflow_data_for_fn<'a, 'tcx>(\n // Type definitions\n \n pub struct BorrowckCtxt<'a, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'tcx>,\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     // Hacky. As we visit various fns, we have to load up the\n     // free-region map for each one. This map is computed by during\n@@ -427,7 +427,7 @@ pub fn closure_to_block(closure_id: ast::NodeId,\n }\n \n impl<'a, 'tcx> LoanPath<'tcx> {\n-    pub fn kill_scope(&self, tcx: TyCtxt<'a, 'tcx>) -> region::CodeExtent {\n+    pub fn kill_scope(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> region::CodeExtent {\n         match self.kind {\n             LpVar(local_id) => tcx.region_maps.var_scope(local_id),\n             LpUpvar(upvar_id) => {"}, {"sha": "a742260018676257766e8e8afa878bc514dc4f40", "filename": "src/librustc_borrowck/borrowck/move_data.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs?ref=76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4", "patch": "@@ -272,7 +272,7 @@ impl<'a, 'tcx> MoveData<'tcx> {\n \n     /// Returns the existing move path index for `lp`, if any, and otherwise adds a new index for\n     /// `lp` and any of its base paths that do not yet have an index.\n-    pub fn move_path(&self, tcx: TyCtxt<'a, 'tcx>,\n+    pub fn move_path(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                      lp: Rc<LoanPath<'tcx>>) -> MovePathIndex {\n         match self.path_map.borrow().get(&lp) {\n             Some(&index) => {\n@@ -363,7 +363,7 @@ impl<'a, 'tcx> MoveData<'tcx> {\n     }\n \n     /// Adds a new move entry for a move of `lp` that occurs at location `id` with kind `kind`.\n-    pub fn add_move(&self, tcx: TyCtxt<'a, 'tcx>,\n+    pub fn add_move(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                     lp: Rc<LoanPath<'tcx>>,\n                     id: ast::NodeId,\n                     kind: MoveKind) {\n@@ -390,7 +390,7 @@ impl<'a, 'tcx> MoveData<'tcx> {\n \n     /// Adds a new record for an assignment to `lp` that occurs at location `id` with the given\n     /// `span`.\n-    pub fn add_assignment(&self, tcx: TyCtxt<'a, 'tcx>,\n+    pub fn add_assignment(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                           lp: Rc<LoanPath<'tcx>>,\n                           assign_id: ast::NodeId,\n                           span: Span,\n@@ -434,7 +434,7 @@ impl<'a, 'tcx> MoveData<'tcx> {\n     /// variant `lp`, that occurs at location `pattern_id`.  (One\n     /// should be able to recover the span info from the\n     /// `pattern_id` and the ast_map, I think.)\n-    pub fn add_variant_match(&self, tcx: TyCtxt<'a, 'tcx>,\n+    pub fn add_variant_match(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                              lp: Rc<LoanPath<'tcx>>,\n                              pattern_id: ast::NodeId,\n                              base_lp: Rc<LoanPath<'tcx>>,\n@@ -457,7 +457,7 @@ impl<'a, 'tcx> MoveData<'tcx> {\n         self.variant_matches.borrow_mut().push(variant_match);\n     }\n \n-    fn fixup_fragment_sets(&self, tcx: TyCtxt<'a, 'tcx>) {\n+    fn fixup_fragment_sets(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n         fragments::fixup_fragment_sets(self, tcx)\n     }\n \n@@ -466,7 +466,7 @@ impl<'a, 'tcx> MoveData<'tcx> {\n     /// Moves are generated by moves and killed by assignments and\n     /// scoping. Assignments are generated by assignment to variables and\n     /// killed by scoping. See `README.md` for more details.\n-    fn add_gen_kills(&self, tcx: TyCtxt<'a, 'tcx>,\n+    fn add_gen_kills(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                      dfcx_moves: &mut MoveDataFlow,\n                      dfcx_assign: &mut AssignDataFlow) {\n         for (i, the_move) in self.moves.borrow().iter().enumerate() {\n@@ -595,7 +595,7 @@ impl<'a, 'tcx> MoveData<'tcx> {\n \n impl<'a, 'tcx> FlowedMoveData<'a, 'tcx> {\n     pub fn new(move_data: MoveData<'tcx>,\n-               tcx: TyCtxt<'a, 'tcx>,\n+               tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                cfg: &cfg::CFG,\n                id_range: IdRange,\n                decl: &hir::FnDecl,"}, {"sha": "bde9a856cc48b04cd10253270dabceeaacc5879f", "filename": "src/librustc_const_eval/check_match.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc_const_eval%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc_const_eval%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fcheck_match.rs?ref=76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4", "patch": "@@ -106,7 +106,7 @@ impl<'a> FromIterator<Vec<&'a Pat>> for Matrix<'a> {\n \n //NOTE: appears to be the only place other then InferCtxt to contain a ParamEnv\n pub struct MatchCheckCtxt<'a, 'tcx: 'a> {\n-    pub tcx: TyCtxt<'a, 'tcx>,\n+    pub tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     pub param_env: ParameterEnvironment<'a, 'tcx>,\n }\n \n@@ -153,7 +153,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for MatchCheckCtxt<'a, 'tcx> {\n     }\n }\n \n-pub fn check_crate(tcx: TyCtxt) {\n+pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     tcx.visit_all_items_in_krate(DepNode::MatchCheck, &mut MatchCheckCtxt {\n         tcx: tcx,\n         param_env: tcx.empty_parameter_environment(),\n@@ -455,13 +455,13 @@ fn const_val_to_expr(value: &ConstVal) -> P<hir::Expr> {\n }\n \n pub struct StaticInliner<'a, 'tcx: 'a> {\n-    pub tcx: TyCtxt<'a, 'tcx>,\n+    pub tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     pub failed: bool,\n     pub renaming_map: Option<&'a mut FnvHashMap<(NodeId, Span), NodeId>>,\n }\n \n impl<'a, 'tcx> StaticInliner<'a, 'tcx> {\n-    pub fn new<'b>(tcx: TyCtxt<'b, 'tcx>,\n+    pub fn new<'b>(tcx: TyCtxt<'b, 'tcx, 'tcx>,\n                    renaming_map: Option<&'b mut FnvHashMap<(NodeId, Span), NodeId>>)\n                    -> StaticInliner<'b, 'tcx> {\n         StaticInliner {"}, {"sha": "eaf1d6ad6d20f37f3b5b754b3afadbcb32f44815", "filename": "src/librustc_const_eval/eval.rs", "status": "modified", "additions": 23, "deletions": 17, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc_const_eval%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc_const_eval%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Feval.rs?ref=76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4", "patch": "@@ -54,7 +54,7 @@ macro_rules! math {\n     }\n }\n \n-fn lookup_variant_by_id<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx>,\n+fn lookup_variant_by_id<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                   enum_def: DefId,\n                                   variant_def: DefId)\n                                   -> Option<&'tcx Expr> {\n@@ -90,7 +90,7 @@ fn lookup_variant_by_id<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx>,\n ///\n /// `substs` is optional and is used for associated constants.\n /// This generally happens in late/trans const evaluation.\n-pub fn lookup_const_by_id<'a, 'tcx: 'a>(tcx: TyCtxt<'a, 'tcx>,\n+pub fn lookup_const_by_id<'a, 'tcx: 'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                         def_id: DefId,\n                                         substs: Option<subst::Substs<'tcx>>)\n                                         -> Option<(&'tcx Expr, Option<ty::Ty<'tcx>>)> {\n@@ -182,8 +182,9 @@ pub fn lookup_const_by_id<'a, 'tcx: 'a>(tcx: TyCtxt<'a, 'tcx>,\n     }\n }\n \n-fn inline_const_fn_from_external_crate(tcx: TyCtxt, def_id: DefId)\n-                                       -> Option<ast::NodeId> {\n+fn inline_const_fn_from_external_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                                 def_id: DefId)\n+                                                 -> Option<ast::NodeId> {\n     match tcx.extern_const_fns.borrow().get(&def_id) {\n         Some(&ast::DUMMY_NODE_ID) => return None,\n         Some(&fn_id) => return Some(fn_id),\n@@ -205,7 +206,7 @@ fn inline_const_fn_from_external_crate(tcx: TyCtxt, def_id: DefId)\n     fn_id\n }\n \n-pub fn lookup_const_fn_by_id<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx>, def_id: DefId)\n+pub fn lookup_const_fn_by_id<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId)\n                                        -> Option<FnLikeNode<'tcx>>\n {\n     let fn_id = if let Some(node_id) = tcx.map.as_local_node_id(def_id) {\n@@ -238,8 +239,11 @@ pub fn lookup_const_fn_by_id<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx>, def_id: DefId)\n     }\n }\n \n-pub fn const_expr_to_pat(tcx: TyCtxt, expr: &Expr, pat_id: ast::NodeId, span: Span)\n-                         -> Result<P<hir::Pat>, DefId> {\n+pub fn const_expr_to_pat<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                   expr: &Expr,\n+                                   pat_id: ast::NodeId,\n+                                   span: Span)\n+                                   -> Result<P<hir::Pat>, DefId> {\n     let pat_ty = tcx.expr_ty(expr);\n     debug!(\"expr={:?} pat_ty={:?} pat_id={}\", expr, pat_ty, pat_id);\n     match pat_ty.sty {\n@@ -339,7 +343,8 @@ pub fn const_expr_to_pat(tcx: TyCtxt, expr: &Expr, pat_id: ast::NodeId, span: Sp\n     Ok(P(hir::Pat { id: expr.id, node: pat, span: span }))\n }\n \n-pub fn eval_const_expr(tcx: TyCtxt, e: &Expr) -> ConstVal {\n+pub fn eval_const_expr<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                 e: &Expr) -> ConstVal {\n     match eval_const_expr_partial(tcx, e, ExprTypeChecked, None) {\n         Ok(r) => r,\n         // non-const path still needs to be a fatal error, because enums are funky\n@@ -526,7 +531,7 @@ macro_rules! signal {\n /// guaranteed to be evaluatable. `ty_hint` is usually ExprTypeChecked,\n /// but a few places need to evaluate constants during type-checking, like\n /// computing the length of an array. (See also the FIXME above EvalHint.)\n-pub fn eval_const_expr_partial<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx>,\n+pub fn eval_const_expr_partial<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                          e: &Expr,\n                                          ty_hint: EvalHint<'tcx>,\n                                          fn_args: FnArgMap) -> EvalResult {\n@@ -932,7 +937,7 @@ pub fn eval_const_expr_partial<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx>,\n }\n \n fn infer<'a, 'tcx>(i: ConstInt,\n-                   tcx: TyCtxt<'a, 'tcx>,\n+                   tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                    ty_hint: &ty::TypeVariants<'tcx>)\n                    -> Result<ConstInt, ErrKind> {\n     use syntax::ast::*;\n@@ -996,7 +1001,7 @@ fn infer<'a, 'tcx>(i: ConstInt,\n     }\n }\n \n-fn resolve_trait_associated_const<'a, 'tcx: 'a>(tcx: TyCtxt<'a, 'tcx>,\n+fn resolve_trait_associated_const<'a, 'tcx: 'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                                 ti: &'tcx hir::TraitItem,\n                                                 trait_id: DefId,\n                                                 rcvr_substs: subst::Substs<'tcx>)\n@@ -1053,7 +1058,7 @@ fn resolve_trait_associated_const<'a, 'tcx: 'a>(tcx: TyCtxt<'a, 'tcx>,\n     }\n }\n \n-fn cast_const_int<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx>, val: ConstInt, ty: ty::Ty) -> CastResult {\n+fn cast_const_int<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, val: ConstInt, ty: ty::Ty) -> CastResult {\n     let v = val.to_u64_unchecked();\n     match ty.sty {\n         ty::TyBool if v == 0 => Ok(Bool(false)),\n@@ -1098,7 +1103,7 @@ fn cast_const_int<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx>, val: ConstInt, ty: ty::Ty) ->\n     }\n }\n \n-fn cast_const_float<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx>, f: f64, ty: ty::Ty) -> CastResult {\n+fn cast_const_float<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, f: f64, ty: ty::Ty) -> CastResult {\n     match ty.sty {\n         ty::TyInt(_) if f >= 0.0 => cast_const_int(tcx, Infer(f as u64), ty),\n         ty::TyInt(_) => cast_const_int(tcx, InferSigned(f as i64), ty),\n@@ -1109,7 +1114,7 @@ fn cast_const_float<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx>, f: f64, ty: ty::Ty) -> Cast\n     }\n }\n \n-fn cast_const<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx>, val: ConstVal, ty: ty::Ty) -> CastResult {\n+fn cast_const<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, val: ConstVal, ty: ty::Ty) -> CastResult {\n     match val {\n         Integral(i) => cast_const_int(tcx, i, ty),\n         Bool(b) => cast_const_int(tcx, Infer(b as u64), ty),\n@@ -1127,7 +1132,7 @@ fn cast_const<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx>, val: ConstVal, ty: ty::Ty) -> Cas\n }\n \n fn lit_to_const<'a, 'tcx>(lit: &ast::LitKind,\n-                          tcx: TyCtxt<'a, 'tcx>,\n+                          tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                           ty_hint: Option<Ty<'tcx>>,\n                           span: Span)\n                           -> Result<ConstVal, ErrKind> {\n@@ -1197,7 +1202,7 @@ pub fn compare_const_vals(a: &ConstVal, b: &ConstVal) -> Option<Ordering> {\n     }\n }\n \n-pub fn compare_lit_exprs<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx>,\n+pub fn compare_lit_exprs<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                    a: &Expr,\n                                    b: &Expr) -> Option<Ordering> {\n     let a = match eval_const_expr_partial(tcx, a, ExprTypeChecked, None) {\n@@ -1219,7 +1224,8 @@ pub fn compare_lit_exprs<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx>,\n \n \n /// Returns the repeat count for a repeating vector expression.\n-pub fn eval_repeat_count(tcx: TyCtxt, count_expr: &hir::Expr) -> usize {\n+pub fn eval_repeat_count<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                   count_expr: &hir::Expr) -> usize {\n     let hint = UncheckedExprHint(tcx.types.usize);\n     match eval_const_expr_partial(tcx, count_expr, hint, None) {\n         Ok(Integral(Usize(count))) => {"}, {"sha": "f0c2de293277580fd3c778b6d423547c7ddc1e99", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4", "patch": "@@ -367,7 +367,7 @@ pub struct CompileState<'a, 'b, 'ast: 'a, 'tcx: 'b> where 'ast: 'tcx {\n     pub resolutions: Option<&'a Resolutions>,\n     pub mir_map: Option<&'b MirMap<'tcx>>,\n     pub analysis: Option<&'a ty::CrateAnalysis<'a>>,\n-    pub tcx: Option<TyCtxt<'b, 'tcx>>,\n+    pub tcx: Option<TyCtxt<'b, 'tcx, 'tcx>>,\n     pub trans: Option<&'a trans::CrateTranslation>,\n }\n \n@@ -464,7 +464,7 @@ impl<'a, 'b, 'ast, 'tcx> CompileState<'a, 'b, 'ast, 'tcx> {\n                             hir_crate: &'a hir::Crate,\n                             analysis: &'a ty::CrateAnalysis<'a>,\n                             mir_map: Option<&'b MirMap<'tcx>>,\n-                            tcx: TyCtxt<'b, 'tcx>,\n+                            tcx: TyCtxt<'b, 'tcx, 'tcx>,\n                             crate_name: &'a str)\n                             -> CompileState<'a, 'b, 'ast, 'tcx> {\n         CompileState {\n@@ -817,7 +817,7 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n                                                name: &str,\n                                                f: F)\n                                                -> Result<R, usize>\n-    where F: for<'a> FnOnce(TyCtxt<'a, 'tcx>,\n+    where F: for<'a> FnOnce(TyCtxt<'a, 'tcx, 'tcx>,\n                             Option<MirMap<'tcx>>,\n                             ty::CrateAnalysis,\n                             CompileResult) -> R\n@@ -992,7 +992,7 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n }\n \n /// Run the translation phase to LLVM, after which the AST and analysis can\n-pub fn phase_4_translate_to_llvm<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx>,\n+pub fn phase_4_translate_to_llvm<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                            mut mir_map: MirMap<'tcx>,\n                                            analysis: ty::CrateAnalysis)\n                                            -> trans::CrateTranslation {"}, {"sha": "d841f7c86a93e3228ba42bdba8e09e9747b7961a", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4", "patch": "@@ -469,7 +469,7 @@ impl<'ast> pprust::PpAnn for HygieneAnnotation<'ast> {\n \n \n struct TypedAnnotation<'a, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'tcx>,\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n }\n \n impl<'b, 'tcx> HirPrinterSupport<'tcx> for TypedAnnotation<'b, 'tcx> {\n@@ -690,7 +690,7 @@ impl fold::Folder for ReplaceBodyWithLoop {\n }\n \n fn print_flowgraph<'a, 'tcx, W: Write>(variants: Vec<borrowck_dot::Variant>,\n-                                       tcx: TyCtxt<'a, 'tcx>,\n+                                       tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                        mir_map: Option<&MirMap<'tcx>>,\n                                        code: blocks::Code,\n                                        mode: PpFlowGraphMode,"}, {"sha": "b2de22583dc15698bf219e64526ea88c04efadbc", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4", "patch": "@@ -43,7 +43,7 @@ use syntax::feature_gate::UnstableFeatures;\n use rustc::hir;\n \n struct Env<'a, 'tcx: 'a> {\n-    infcx: &'a infer::InferCtxt<'a, 'tcx>,\n+    infcx: &'a infer::InferCtxt<'a, 'tcx, 'tcx>,\n }\n \n struct RH<'a> {\n@@ -160,7 +160,7 @@ fn test_env<F>(source_string: &str,\n }\n \n impl<'a, 'tcx> Env<'a, 'tcx> {\n-    pub fn tcx(&self) -> TyCtxt<'a, 'tcx> {\n+    pub fn tcx(&self) -> TyCtxt<'a, 'tcx, 'tcx> {\n         self.infcx.tcx\n     }\n \n@@ -354,25 +354,25 @@ impl<'a, 'tcx> Env<'a, 'tcx> {\n         infer::TypeTrace::dummy(self.tcx())\n     }\n \n-    pub fn sub(&self, t1: &Ty<'tcx>, t2: &Ty<'tcx>) -> InferResult<'tcx, Ty<'tcx>> {\n+    pub fn sub(&self, t1: Ty<'tcx>, t2: Ty<'tcx>) -> InferResult<'tcx, Ty<'tcx>> {\n         let trace = self.dummy_type_trace();\n-        self.infcx.sub(true, trace, t1, t2)\n+        self.infcx.sub(true, trace, &t1, &t2)\n     }\n \n-    pub fn lub(&self, t1: &Ty<'tcx>, t2: &Ty<'tcx>) -> InferResult<'tcx, Ty<'tcx>> {\n+    pub fn lub(&self, t1: Ty<'tcx>, t2: Ty<'tcx>) -> InferResult<'tcx, Ty<'tcx>> {\n         let trace = self.dummy_type_trace();\n-        self.infcx.lub(true, trace, t1, t2)\n+        self.infcx.lub(true, trace, &t1, &t2)\n     }\n \n-    pub fn glb(&self, t1: &Ty<'tcx>, t2: &Ty<'tcx>) -> InferResult<'tcx, Ty<'tcx>> {\n+    pub fn glb(&self, t1: Ty<'tcx>, t2: Ty<'tcx>) -> InferResult<'tcx, Ty<'tcx>> {\n         let trace = self.dummy_type_trace();\n-        self.infcx.glb(true, trace, t1, t2)\n+        self.infcx.glb(true, trace, &t1, &t2)\n     }\n \n     /// Checks that `t1 <: t2` is true (this may register additional\n     /// region checks).\n     pub fn check_sub(&self, t1: Ty<'tcx>, t2: Ty<'tcx>) {\n-        match self.sub(&t1, &t2) {\n+        match self.sub(t1, t2) {\n             Ok(InferOk { obligations, .. }) => {\n                 // FIXME(#32730) once obligations are being propagated, assert the right thing.\n                 assert!(obligations.is_empty());\n@@ -386,7 +386,7 @@ impl<'a, 'tcx> Env<'a, 'tcx> {\n     /// Checks that `t1 <: t2` is false (this may register additional\n     /// region checks).\n     pub fn check_not_sub(&self, t1: Ty<'tcx>, t2: Ty<'tcx>) {\n-        match self.sub(&t1, &t2) {\n+        match self.sub(t1, t2) {\n             Err(_) => {}\n             Ok(_) => {\n                 panic!(\"unexpected success computing sub({:?},{:?})\", t1, t2);\n@@ -396,7 +396,7 @@ impl<'a, 'tcx> Env<'a, 'tcx> {\n \n     /// Checks that `LUB(t1,t2) == t_lub`\n     pub fn check_lub(&self, t1: Ty<'tcx>, t2: Ty<'tcx>, t_lub: Ty<'tcx>) {\n-        match self.lub(&t1, &t2) {\n+        match self.lub(t1, t2) {\n             Ok(InferOk { obligations, value: t }) => {\n                 // FIXME(#32730) once obligations are being propagated, assert the right thing.\n                 assert!(obligations.is_empty());\n@@ -412,7 +412,7 @@ impl<'a, 'tcx> Env<'a, 'tcx> {\n     /// Checks that `GLB(t1,t2) == t_glb`\n     pub fn check_glb(&self, t1: Ty<'tcx>, t2: Ty<'tcx>, t_glb: Ty<'tcx>) {\n         debug!(\"check_glb(t1={}, t2={}, t_glb={})\", t1, t2, t_glb);\n-        match self.glb(&t1, &t2) {\n+        match self.glb(t1, t2) {\n             Err(e) => {\n                 panic!(\"unexpected error computing LUB: {:?}\", e)\n             }"}, {"sha": "b74e7e212262585dc8a763820129964e3cb703be", "filename": "src/librustc_incremental/assert_dep_graph.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc_incremental%2Fassert_dep_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc_incremental%2Fassert_dep_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fassert_dep_graph.rs?ref=76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4", "patch": "@@ -63,7 +63,7 @@ const IF_THIS_CHANGED: &'static str = \"rustc_if_this_changed\";\n const THEN_THIS_WOULD_NEED: &'static str = \"rustc_then_this_would_need\";\n const ID: &'static str = \"id\";\n \n-pub fn assert_dep_graph(tcx: TyCtxt) {\n+pub fn assert_dep_graph<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     let _ignore = tcx.dep_graph.in_ignore();\n \n     if tcx.sess.opts.debugging_opts.dump_dep_graph {\n@@ -98,7 +98,7 @@ type TargetHashMap =\n                FnvHashSet<(Span, InternedString, ast::NodeId, DepNode<DefId>)>>;\n \n struct IfThisChanged<'a, 'tcx:'a> {\n-    tcx: TyCtxt<'a, 'tcx>,\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     if_this_changed: SourceHashMap,\n     then_this_would_need: TargetHashMap,\n }\n@@ -172,9 +172,9 @@ impl<'a, 'tcx> Visitor<'tcx> for IfThisChanged<'a, 'tcx> {\n     }\n }\n \n-fn check_paths(tcx: TyCtxt,\n-               if_this_changed: &SourceHashMap,\n-               then_this_would_need: &TargetHashMap)\n+fn check_paths<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                         if_this_changed: &SourceHashMap,\n+                         then_this_would_need: &TargetHashMap)\n {\n     // Return early here so as not to construct the query, which is not cheap.\n     if if_this_changed.is_empty() {"}, {"sha": "ef3ac4c342690d9fb565225c63651604389dbd4f", "filename": "src/librustc_incremental/calculate_svh.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc_incremental%2Fcalculate_svh.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc_incremental%2Fcalculate_svh.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fcalculate_svh.rs?ref=76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4", "patch": "@@ -27,7 +27,7 @@ pub trait SvhCalculate {\n     fn calculate_item_hash(self, def_id: DefId) -> u64;\n }\n \n-impl<'a, 'tcx> SvhCalculate for TyCtxt<'a, 'tcx> {\n+impl<'a, 'tcx> SvhCalculate for TyCtxt<'a, 'tcx, 'tcx> {\n     fn calculate_krate_hash(self) -> Svh {\n         // FIXME (#14132): This is better than it used to be, but it still not\n         // ideal. We now attempt to hash only the relevant portions of the\n@@ -118,13 +118,13 @@ mod svh_visitor {\n     use std::hash::{Hash, SipHasher};\n \n     pub struct StrictVersionHashVisitor<'a, 'tcx: 'a> {\n-        pub tcx: TyCtxt<'a, 'tcx>,\n+        pub tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         pub st: &'a mut SipHasher,\n     }\n \n     impl<'a, 'tcx> StrictVersionHashVisitor<'a, 'tcx> {\n         pub fn new(st: &'a mut SipHasher,\n-                   tcx: TyCtxt<'a, 'tcx>)\n+                   tcx: TyCtxt<'a, 'tcx, 'tcx>)\n                    -> Self {\n             StrictVersionHashVisitor { st: st, tcx: tcx }\n         }"}, {"sha": "e256b7cf7d0e111099bd2d751a6abb84b56fe528", "filename": "src/librustc_incremental/persist/directory.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc_incremental%2Fpersist%2Fdirectory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc_incremental%2Fpersist%2Fdirectory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fdirectory.rs?ref=76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4", "patch": "@@ -63,13 +63,13 @@ impl RetracedDefIdDirectory {\n }\n \n pub struct DefIdDirectoryBuilder<'a,'tcx:'a> {\n-    tcx: TyCtxt<'a, 'tcx>,\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     hash: DefIdMap<Option<DefPathIndex>>,\n     directory: DefIdDirectory,\n }\n \n impl<'a,'tcx> DefIdDirectoryBuilder<'a,'tcx> {\n-    pub fn new(tcx: TyCtxt<'a, 'tcx>) -> DefIdDirectoryBuilder<'a, 'tcx> {\n+    pub fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> DefIdDirectoryBuilder<'a, 'tcx> {\n         DefIdDirectoryBuilder {\n             tcx: tcx,\n             hash: DefIdMap(),"}, {"sha": "dee4d667b8d95c6b1a23b740455cda4e2d58d2b8", "filename": "src/librustc_incremental/persist/dirty_clean.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs?ref=76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4", "patch": "@@ -38,7 +38,7 @@ const CLEAN: &'static str = \"rustc_clean\";\n const LABEL: &'static str = \"label\";\n const CFG: &'static str = \"cfg\";\n \n-pub fn check_dirty_clean_annotations(tcx: TyCtxt) {\n+pub fn check_dirty_clean_annotations<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     let _ignore = tcx.dep_graph.in_ignore();\n     let query = tcx.dep_graph.query();\n     let krate = tcx.map.krate();\n@@ -49,7 +49,7 @@ pub fn check_dirty_clean_annotations(tcx: TyCtxt) {\n }\n \n pub struct DirtyCleanVisitor<'a, 'tcx:'a> {\n-    tcx: TyCtxt<'a, 'tcx>,\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     query: &'a DepGraphQuery<DefId>,\n }\n "}, {"sha": "f9e479745d10f902ac5506bc0ddc657b54786476", "filename": "src/librustc_incremental/persist/load.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc_incremental%2Fpersist%2Fload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc_incremental%2Fpersist%2Fload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fload.rs?ref=76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4", "patch": "@@ -37,7 +37,7 @@ type CleanEdges = Vec<(DepNode<DefId>, DepNode<DefId>)>;\n /// early in compilation, before we've really done any work, but\n /// actually it doesn't matter all that much.) See `README.md` for\n /// more general overview.\n-pub fn load_dep_graph(tcx: TyCtxt) {\n+pub fn load_dep_graph<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     let _ignore = tcx.dep_graph.in_ignore();\n \n     if let Some(dep_graph) = dep_graph_path(tcx) {\n@@ -47,7 +47,7 @@ pub fn load_dep_graph(tcx: TyCtxt) {\n     }\n }\n \n-pub fn load_dep_graph_if_exists(tcx: TyCtxt, path: &Path) {\n+pub fn load_dep_graph_if_exists<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, path: &Path) {\n     if !path.exists() {\n         return;\n     }\n@@ -74,7 +74,9 @@ pub fn load_dep_graph_if_exists(tcx: TyCtxt, path: &Path) {\n     }\n }\n \n-pub fn decode_dep_graph(tcx: TyCtxt, data: &[u8]) -> Result<(), Error>\n+pub fn decode_dep_graph<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                  data: &[u8])\n+                                  -> Result<(), Error>\n {\n     // Deserialize the directory and dep-graph.\n     let mut decoder = Decoder::new(data, 0);\n@@ -128,10 +130,10 @@ pub fn decode_dep_graph(tcx: TyCtxt, data: &[u8]) -> Result<(), Error>\n     Ok(())\n }\n \n-fn initial_dirty_nodes(tcx: TyCtxt,\n-                       hashed_items: &[SerializedHash],\n-                       retraced: &RetracedDefIdDirectory)\n-                       -> DirtyNodes {\n+fn initial_dirty_nodes<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                 hashed_items: &[SerializedHash],\n+                                 retraced: &RetracedDefIdDirectory)\n+                                 -> DirtyNodes {\n     let mut items_removed = false;\n     let mut dirty_nodes = FnvHashSet();\n     for hashed_item in hashed_items {"}, {"sha": "cbb3464f3ef4ae8be8f94736369fa5aba8d75539", "filename": "src/librustc_incremental/persist/save.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs?ref=76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4", "patch": "@@ -20,7 +20,7 @@ use super::data::*;\n use super::directory::*;\n use super::util::*;\n \n-pub fn save_dep_graph(tcx: TyCtxt) {\n+pub fn save_dep_graph<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     let _ignore = tcx.dep_graph.in_ignore();\n \n     if let Some(dep_graph) = dep_graph_path(tcx) {\n@@ -68,7 +68,9 @@ pub fn save_dep_graph(tcx: TyCtxt) {\n     }\n }\n \n-pub fn encode_dep_graph(tcx: TyCtxt, encoder: &mut Encoder) -> io::Result<()> {\n+pub fn encode_dep_graph<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                  encoder: &mut Encoder)\n+                                  -> io::Result<()> {\n     // Here we take advantage of how RBML allows us to skip around\n     // and encode the depgraph as a two-part structure:\n     //"}, {"sha": "4e6b88eb4345b4771bf5687bb141ff23634d57b2", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4", "patch": "@@ -792,9 +792,9 @@ impl LateLintPass for UnconditionalRecursion {\n         }\n \n         // Check if the expression `id` performs a call to `method`.\n-        fn expr_refers_to_this_method(tcx: TyCtxt,\n-                                      method: &ty::Method,\n-                                      id: ast::NodeId) -> bool {\n+        fn expr_refers_to_this_method<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                                method: &ty::Method,\n+                                                id: ast::NodeId) -> bool {\n             // Check for method calls and overloaded operators.\n             let opt_m = tcx.tables.borrow().method_map.get(&ty::MethodCall::expr(id)).cloned();\n             if let Some(m) = opt_m {\n@@ -840,7 +840,7 @@ impl LateLintPass for UnconditionalRecursion {\n \n         // Check if the method call to the method with the ID `callee_id`\n         // and instantiated with `callee_substs` refers to method `method`.\n-        fn method_call_refers_to_method<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx>,\n+        fn method_call_refers_to_method<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                                   method: &ty::Method,\n                                                   callee_id: DefId,\n                                                   callee_substs: &Substs<'tcx>,"}, {"sha": "892924db6fad86c57fab9f90265b8eb4ff615e21", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4", "patch": "@@ -294,8 +294,10 @@ impl LateLintPass for TypeLimits {\n             }\n         }\n \n-        fn check_limits(tcx: TyCtxt, binop: hir::BinOp,\n-                        l: &hir::Expr, r: &hir::Expr) -> bool {\n+        fn check_limits<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                  binop: hir::BinOp,\n+                                  l: &hir::Expr,\n+                                  r: &hir::Expr) -> bool {\n             let (lit, expr, swap) = match (&l.node, &r.node) {\n                 (&hir::ExprLit(_), _) => (l, r, true),\n                 (_, &hir::ExprLit(_)) => (r, l, false),\n@@ -375,7 +377,7 @@ enum FfiResult {\n /// to function pointers and references, but could be\n /// expanded to cover NonZero raw pointers and newtypes.\n /// FIXME: This duplicates code in trans.\n-fn is_repr_nullable_ptr<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx>,\n+fn is_repr_nullable_ptr<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                   def: ty::AdtDef<'tcx>,\n                                   substs: &Substs<'tcx>)\n                                   -> bool {"}, {"sha": "86e382742451dc04e28dce186177c7b726a9ff06", "filename": "src/librustc_metadata/astencode.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc_metadata%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc_metadata%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fastencode.rs?ref=76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4", "patch": "@@ -60,7 +60,7 @@ use rustc_serialize::{Encodable, EncoderHelpers};\n #[cfg(test)] use rustc::hir::lowering::{lower_item, LoweringContext, DummyResolver};\n \n struct DecodeContext<'a, 'b, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'tcx>,\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     cdata: &'b cstore::crate_metadata,\n     from_id_range: IdRange,\n     to_id_range: IdRange,\n@@ -123,7 +123,7 @@ impl<'a, 'b, 'c, 'tcx> ast_map::FoldOps for &'a DecodeContext<'b, 'c, 'tcx> {\n /// Decodes an item from its AST in the cdata's metadata and adds it to the\n /// ast-map.\n pub fn decode_inlined_item<'a, 'tcx>(cdata: &cstore::crate_metadata,\n-                                     tcx: TyCtxt<'a, 'tcx>,\n+                                     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                      parent_def_path: ast_map::DefPath,\n                                      parent_did: DefId,\n                                      ast_doc: rbml::Doc,\n@@ -861,17 +861,17 @@ trait rbml_decoder_decoder_helpers<'tcx> {\n \n     // Versions of the type reading functions that don't need the full\n     // DecodeContext.\n-    fn read_ty_nodcx<'a>(&mut self, tcx: TyCtxt<'a, 'tcx>,\n+    fn read_ty_nodcx<'a>(&mut self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                          cdata: &cstore::crate_metadata) -> Ty<'tcx>;\n-    fn read_tys_nodcx<'a>(&mut self, tcx: TyCtxt<'a, 'tcx>,\n+    fn read_tys_nodcx<'a>(&mut self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                           cdata: &cstore::crate_metadata) -> Vec<Ty<'tcx>>;\n-    fn read_substs_nodcx<'a>(&mut self, tcx: TyCtxt<'a, 'tcx>,\n+    fn read_substs_nodcx<'a>(&mut self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                              cdata: &cstore::crate_metadata)\n                              -> subst::Substs<'tcx>;\n }\n \n impl<'a, 'tcx> rbml_decoder_decoder_helpers<'tcx> for reader::Decoder<'a> {\n-    fn read_ty_nodcx<'b>(&mut self, tcx: TyCtxt<'b, 'tcx>,\n+    fn read_ty_nodcx<'b>(&mut self, tcx: TyCtxt<'b, 'tcx, 'tcx>,\n                          cdata: &cstore::crate_metadata)\n                          -> Ty<'tcx> {\n         self.read_opaque(|_, doc| {\n@@ -882,15 +882,15 @@ impl<'a, 'tcx> rbml_decoder_decoder_helpers<'tcx> for reader::Decoder<'a> {\n         }).unwrap()\n     }\n \n-    fn read_tys_nodcx<'b>(&mut self, tcx: TyCtxt<'b, 'tcx>,\n+    fn read_tys_nodcx<'b>(&mut self, tcx: TyCtxt<'b, 'tcx, 'tcx>,\n                           cdata: &cstore::crate_metadata) -> Vec<Ty<'tcx>> {\n         self.read_to_vec(|this| Ok(this.read_ty_nodcx(tcx, cdata)) )\n             .unwrap()\n             .into_iter()\n             .collect()\n     }\n \n-    fn read_substs_nodcx<'b>(&mut self, tcx: TyCtxt<'b, 'tcx>,\n+    fn read_substs_nodcx<'b>(&mut self, tcx: TyCtxt<'b, 'tcx, 'tcx>,\n                              cdata: &cstore::crate_metadata)\n                              -> subst::Substs<'tcx>\n     {"}, {"sha": "8d464099783a6554d209fc8cdcdbcf01ab329558", "filename": "src/librustc_metadata/csearch.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc_metadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc_metadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcsearch.rs?ref=76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4", "patch": "@@ -61,7 +61,7 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n         decoder::closure_kind(&cdata, def_id.index)\n     }\n \n-    fn closure_ty<'a>(&self, tcx: TyCtxt<'a, 'tcx>, def_id: DefId) -> ty::ClosureTy<'tcx>\n+    fn closure_ty<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> ty::ClosureTy<'tcx>\n     {\n         assert!(!def_id.is_local());\n         let cdata = self.get_crate_data(def_id.krate);\n@@ -78,21 +78,21 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n         decoder::get_repr_attrs(&cdata, def.index)\n     }\n \n-    fn item_type<'a>(&self, tcx: TyCtxt<'a, 'tcx>, def: DefId)\n+    fn item_type<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n                      -> ty::TypeScheme<'tcx>\n     {\n         let cdata = self.get_crate_data(def.krate);\n         decoder::get_type(&cdata, def.index, tcx)\n     }\n \n-    fn item_predicates<'a>(&self, tcx: TyCtxt<'a, 'tcx>, def: DefId)\n+    fn item_predicates<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n                            -> ty::GenericPredicates<'tcx>\n     {\n         let cdata = self.get_crate_data(def.krate);\n         decoder::get_predicates(&cdata, def.index, tcx)\n     }\n \n-    fn item_super_predicates<'a>(&self, tcx: TyCtxt<'a, 'tcx>, def: DefId)\n+    fn item_super_predicates<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n                                  -> ty::GenericPredicates<'tcx>\n     {\n         let cdata = self.get_crate_data(def.krate);\n@@ -111,13 +111,13 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n         decoder::get_symbol(&cdata, def.index)\n     }\n \n-    fn trait_def<'a>(&self, tcx: TyCtxt<'a, 'tcx>, def: DefId) -> ty::TraitDef<'tcx>\n+    fn trait_def<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId) -> ty::TraitDef<'tcx>\n     {\n         let cdata = self.get_crate_data(def.krate);\n         decoder::get_trait_def(&cdata, def.index, tcx)\n     }\n \n-    fn adt_def<'a>(&self, tcx: TyCtxt<'a, 'tcx>, def: DefId) -> ty::AdtDefMaster<'tcx>\n+    fn adt_def<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId) -> ty::AdtDefMaster<'tcx>\n     {\n         let cdata = self.get_crate_data(def.krate);\n         decoder::get_adt_def(&self.intr, &cdata, def.index, tcx)\n@@ -155,7 +155,7 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n         result\n     }\n \n-    fn provided_trait_methods<'a>(&self, tcx: TyCtxt<'a, 'tcx>, def: DefId)\n+    fn provided_trait_methods<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n                                   -> Vec<Rc<ty::Method<'tcx>>>\n     {\n         let cdata = self.get_crate_data(def.krate);\n@@ -181,7 +181,7 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n         decoder::get_impl_polarity(&cdata, def.index)\n     }\n \n-    fn impl_trait_ref<'a>(&self, tcx: TyCtxt<'a, 'tcx>, def: DefId)\n+    fn impl_trait_ref<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n                           -> Option<ty::TraitRef<'tcx>>\n     {\n         let cdata = self.get_crate_data(def.krate);\n@@ -196,7 +196,7 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n     }\n \n     // FIXME: killme\n-    fn associated_consts<'a>(&self, tcx: TyCtxt<'a, 'tcx>, def: DefId)\n+    fn associated_consts<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n                              -> Vec<Rc<ty::AssociatedConst<'tcx>>> {\n         let cdata = self.get_crate_data(def.krate);\n         decoder::get_associated_consts(self.intr.clone(), &cdata, def.index, tcx)\n@@ -207,13 +207,13 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n         decoder::get_parent_impl(&*cdata, impl_def.index)\n     }\n \n-    fn trait_of_item<'a>(&self, tcx: TyCtxt<'a, 'tcx>, def_id: DefId) -> Option<DefId>\n+    fn trait_of_item<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> Option<DefId>\n     {\n         let cdata = self.get_crate_data(def_id.krate);\n         decoder::get_trait_of_item(&cdata, def_id.index, tcx)\n     }\n \n-    fn impl_or_trait_item<'a>(&self, tcx: TyCtxt<'a, 'tcx>, def: DefId)\n+    fn impl_or_trait_item<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n                               -> Option<ty::ImplOrTraitItem<'tcx>>\n     {\n         let cdata = self.get_crate_data(def.krate);\n@@ -247,7 +247,7 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n         decoder::is_default_impl(&cdata, impl_did.index)\n     }\n \n-    fn is_extern_item<'a>(&self, tcx: TyCtxt<'a, 'tcx>, did: DefId) -> bool {\n+    fn is_extern_item<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, did: DefId) -> bool {\n         let cdata = self.get_crate_data(did.krate);\n         decoder::is_extern_item(&cdata, did.index, tcx)\n     }\n@@ -442,14 +442,14 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n         result\n     }\n \n-    fn maybe_get_item_ast<'a>(&'tcx self, tcx: TyCtxt<'a, 'tcx>, def: DefId)\n+    fn maybe_get_item_ast<'a>(&'tcx self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n                               -> FoundAst<'tcx>\n     {\n         let cdata = self.get_crate_data(def.krate);\n         decoder::maybe_get_item_ast(&cdata, tcx, def.index)\n     }\n \n-    fn maybe_get_item_mir<'a>(&self, tcx: TyCtxt<'a, 'tcx>, def: DefId)\n+    fn maybe_get_item_mir<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n                               -> Option<Mir<'tcx>> {\n         let cdata = self.get_crate_data(def.krate);\n         decoder::maybe_get_item_mir(&cdata, tcx, def.index)\n@@ -487,9 +487,9 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n         loader::meta_section_name(target)\n     }\n     fn encode_type<'a>(&self,\n-                       tcx: TyCtxt<'a, 'tcx>,\n+                       tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                        ty: Ty<'tcx>,\n-                       def_id_to_string: for<'b> fn(TyCtxt<'b, 'tcx>, DefId) -> String)\n+                       def_id_to_string: for<'b> fn(TyCtxt<'b, 'tcx, 'tcx>, DefId) -> String)\n                        -> Vec<u8>\n     {\n         encoder::encoded_ty(tcx, ty, def_id_to_string)\n@@ -510,7 +510,7 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n         self.do_extern_mod_stmt_cnum(emod_id)\n     }\n \n-    fn encode_metadata<'a>(&self, tcx: TyCtxt<'a, 'tcx>,\n+    fn encode_metadata<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                            reexports: &def::ExportMap,\n                            item_symbols: &RefCell<NodeMap<String>>,\n                            link_meta: &LinkMeta,"}, {"sha": "860b9f25023bb63730cb15be54e6cca00c73381e", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 29, "deletions": 23, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4", "patch": "@@ -223,14 +223,15 @@ fn variant_disr_val(d: rbml::Doc) -> Option<u64> {\n     })\n }\n \n-fn doc_type<'a, 'tcx>(doc: rbml::Doc, tcx: TyCtxt<'a, 'tcx>, cdata: Cmd) -> Ty<'tcx> {\n+fn doc_type<'a, 'tcx>(doc: rbml::Doc, tcx: TyCtxt<'a, 'tcx, 'tcx>, cdata: Cmd) -> Ty<'tcx> {\n     let tp = reader::get_doc(doc, tag_items_data_item_type);\n     TyDecoder::with_doc(tcx, cdata.cnum, tp,\n                         &mut |did| translate_def_id(cdata, did))\n         .parse_ty()\n }\n \n-fn maybe_doc_type<'a, 'tcx>(doc: rbml::Doc, tcx: TyCtxt<'a, 'tcx>, cdata: Cmd) -> Option<Ty<'tcx>> {\n+fn maybe_doc_type<'a, 'tcx>(doc: rbml::Doc, tcx: TyCtxt<'a, 'tcx, 'tcx>, cdata: Cmd)\n+                            -> Option<Ty<'tcx>> {\n     reader::maybe_get_doc(doc, tag_items_data_item_type).map(|tp| {\n         TyDecoder::with_doc(tcx, cdata.cnum, tp,\n                             &mut |did| translate_def_id(cdata, did))\n@@ -239,18 +240,18 @@ fn maybe_doc_type<'a, 'tcx>(doc: rbml::Doc, tcx: TyCtxt<'a, 'tcx>, cdata: Cmd) -\n }\n \n pub fn item_type<'a, 'tcx>(_item_id: DefId, item: rbml::Doc,\n-                           tcx: TyCtxt<'a, 'tcx>, cdata: Cmd) -> Ty<'tcx> {\n+                           tcx: TyCtxt<'a, 'tcx, 'tcx>, cdata: Cmd) -> Ty<'tcx> {\n     doc_type(item, tcx, cdata)\n }\n \n-fn doc_trait_ref<'a, 'tcx>(doc: rbml::Doc, tcx: TyCtxt<'a, 'tcx>, cdata: Cmd)\n+fn doc_trait_ref<'a, 'tcx>(doc: rbml::Doc, tcx: TyCtxt<'a, 'tcx, 'tcx>, cdata: Cmd)\n                            -> ty::TraitRef<'tcx> {\n     TyDecoder::with_doc(tcx, cdata.cnum, doc,\n                         &mut |did| translate_def_id(cdata, did))\n         .parse_trait_ref()\n }\n \n-fn item_trait_ref<'a, 'tcx>(doc: rbml::Doc, tcx: TyCtxt<'a, 'tcx>, cdata: Cmd)\n+fn item_trait_ref<'a, 'tcx>(doc: rbml::Doc, tcx: TyCtxt<'a, 'tcx, 'tcx>, cdata: Cmd)\n                             -> ty::TraitRef<'tcx> {\n     let tp = reader::get_doc(doc, tag_item_trait_ref);\n     doc_trait_ref(tp, tcx, cdata)\n@@ -352,7 +353,7 @@ fn parse_associated_type_names(item_doc: rbml::Doc) -> Vec<ast::Name> {\n \n pub fn get_trait_def<'a, 'tcx>(cdata: Cmd,\n                                item_id: DefIndex,\n-                               tcx: TyCtxt<'a, 'tcx>) -> ty::TraitDef<'tcx>\n+                               tcx: TyCtxt<'a, 'tcx, 'tcx>) -> ty::TraitDef<'tcx>\n {\n     let item_doc = cdata.lookup_item(item_id);\n     let generics = doc_generics(item_doc, tcx, cdata, tag_item_generics);\n@@ -370,7 +371,7 @@ pub fn get_trait_def<'a, 'tcx>(cdata: Cmd,\n pub fn get_adt_def<'a, 'tcx>(intr: &IdentInterner,\n                              cdata: Cmd,\n                              item_id: DefIndex,\n-                             tcx: TyCtxt<'a, 'tcx>)\n+                             tcx: TyCtxt<'a, 'tcx, 'tcx>)\n                              -> ty::AdtDefMaster<'tcx>\n {\n     fn expect_variant_kind(family: Family) -> ty::VariantKind {\n@@ -498,7 +499,7 @@ pub fn get_adt_def<'a, 'tcx>(intr: &IdentInterner,\n \n pub fn get_predicates<'a, 'tcx>(cdata: Cmd,\n                                 item_id: DefIndex,\n-                                tcx: TyCtxt<'a, 'tcx>)\n+                                tcx: TyCtxt<'a, 'tcx, 'tcx>)\n                                 -> ty::GenericPredicates<'tcx>\n {\n     let item_doc = cdata.lookup_item(item_id);\n@@ -507,14 +508,14 @@ pub fn get_predicates<'a, 'tcx>(cdata: Cmd,\n \n pub fn get_super_predicates<'a, 'tcx>(cdata: Cmd,\n                                       item_id: DefIndex,\n-                                      tcx: TyCtxt<'a, 'tcx>)\n+                                      tcx: TyCtxt<'a, 'tcx, 'tcx>)\n                                       -> ty::GenericPredicates<'tcx>\n {\n     let item_doc = cdata.lookup_item(item_id);\n     doc_predicates(item_doc, tcx, cdata, tag_item_super_predicates)\n }\n \n-pub fn get_type<'a, 'tcx>(cdata: Cmd, id: DefIndex, tcx: TyCtxt<'a, 'tcx>)\n+pub fn get_type<'a, 'tcx>(cdata: Cmd, id: DefIndex, tcx: TyCtxt<'a, 'tcx, 'tcx>)\n                           -> ty::TypeScheme<'tcx>\n {\n     let item_doc = cdata.lookup_item(id);\n@@ -593,7 +594,7 @@ pub fn get_custom_coerce_unsized_kind<'tcx>(\n \n pub fn get_impl_trait<'a, 'tcx>(cdata: Cmd,\n                                 id: DefIndex,\n-                                tcx: TyCtxt<'a, 'tcx>)\n+                                tcx: TyCtxt<'a, 'tcx, 'tcx>)\n                                 -> Option<ty::TraitRef<'tcx>>\n {\n     let item_doc = cdata.lookup_item(id);\n@@ -776,7 +777,7 @@ pub fn get_item_name(intr: &IdentInterner, cdata: Cmd, id: DefIndex) -> ast::Nam\n     item_name(intr, cdata.lookup_item(id))\n }\n \n-pub fn maybe_get_item_ast<'a, 'tcx>(cdata: Cmd, tcx: TyCtxt<'a, 'tcx>, id: DefIndex)\n+pub fn maybe_get_item_ast<'a, 'tcx>(cdata: Cmd, tcx: TyCtxt<'a, 'tcx, 'tcx>, id: DefIndex)\n                                     -> FoundAst<'tcx> {\n     debug!(\"Looking up item: {:?}\", id);\n     let item_doc = cdata.lookup_item(id);\n@@ -829,7 +830,7 @@ pub fn is_item_mir_available<'tcx>(cdata: Cmd, id: DefIndex) -> bool {\n }\n \n pub fn maybe_get_item_mir<'a, 'tcx>(cdata: Cmd,\n-                                    tcx: TyCtxt<'a, 'tcx>,\n+                                    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                     id: DefIndex)\n                                     -> Option<mir::repr::Mir<'tcx>> {\n     let item_doc = cdata.lookup_item(id);\n@@ -947,7 +948,7 @@ pub fn is_static_method(cdata: Cmd, id: DefIndex) -> bool {\n pub fn get_impl_or_trait_item<'a, 'tcx>(intr: Rc<IdentInterner>,\n                                         cdata: Cmd,\n                                         id: DefIndex,\n-                                        tcx: TyCtxt<'a, 'tcx>)\n+                                        tcx: TyCtxt<'a, 'tcx, 'tcx>)\n                                         -> Option<ty::ImplOrTraitItem<'tcx>> {\n     let item_doc = cdata.lookup_item(id);\n \n@@ -1042,7 +1043,7 @@ pub fn get_item_variances(cdata: Cmd, id: DefIndex) -> ty::ItemVariances {\n pub fn get_provided_trait_methods<'a, 'tcx>(intr: Rc<IdentInterner>,\n                                             cdata: Cmd,\n                                             id: DefIndex,\n-                                            tcx: TyCtxt<'a, 'tcx>)\n+                                            tcx: TyCtxt<'a, 'tcx, 'tcx>)\n                                             -> Vec<Rc<ty::Method<'tcx>>> {\n     let item = cdata.lookup_item(id);\n \n@@ -1069,7 +1070,7 @@ pub fn get_provided_trait_methods<'a, 'tcx>(intr: Rc<IdentInterner>,\n pub fn get_associated_consts<'a, 'tcx>(intr: Rc<IdentInterner>,\n                                        cdata: Cmd,\n                                        id: DefIndex,\n-                                       tcx: TyCtxt<'a, 'tcx>)\n+                                       tcx: TyCtxt<'a, 'tcx, 'tcx>)\n                                        -> Vec<Rc<ty::AssociatedConst<'tcx>>> {\n     let item = cdata.lookup_item(id);\n \n@@ -1443,8 +1444,10 @@ pub fn each_implementation_for_trait<F>(cdata: Cmd,\n     }\n }\n \n-pub fn get_trait_of_item(cdata: Cmd, id: DefIndex, tcx: TyCtxt)\n-                         -> Option<DefId> {\n+pub fn get_trait_of_item<'a, 'tcx>(cdata: Cmd,\n+                                   id: DefIndex,\n+                                   tcx: TyCtxt<'a, 'tcx, 'tcx>)\n+                                   -> Option<DefId> {\n     let item_doc = cdata.lookup_item(id);\n     let parent_item_id = match item_parent_item(cdata, item_doc) {\n         None => return None,\n@@ -1578,7 +1581,10 @@ pub fn is_const_fn(cdata: Cmd, id: DefIndex) -> bool {\n     }\n }\n \n-pub fn is_extern_item(cdata: Cmd, id: DefIndex, tcx: TyCtxt) -> bool {\n+pub fn is_extern_item<'a, 'tcx>(cdata: Cmd,\n+                                id: DefIndex,\n+                                tcx: TyCtxt<'a, 'tcx, 'tcx>)\n+                                -> bool {\n     let item_doc = match cdata.get_item(id) {\n         Some(doc) => doc,\n         None => return false,\n@@ -1614,7 +1620,7 @@ pub fn is_impl(cdata: Cmd, id: DefIndex) -> bool {\n }\n \n fn doc_generics<'a, 'tcx>(base_doc: rbml::Doc,\n-                          tcx: TyCtxt<'a, 'tcx>,\n+                          tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                           cdata: Cmd,\n                           tag: usize)\n                           -> ty::Generics<'tcx>\n@@ -1663,7 +1669,7 @@ fn doc_generics<'a, 'tcx>(base_doc: rbml::Doc,\n \n fn doc_predicate<'a, 'tcx>(cdata: Cmd,\n                            doc: rbml::Doc,\n-                           tcx: TyCtxt<'a, 'tcx>)\n+                           tcx: TyCtxt<'a, 'tcx, 'tcx>)\n                            -> ty::Predicate<'tcx>\n {\n     let predicate_pos = cdata.xref_index.lookup(\n@@ -1675,7 +1681,7 @@ fn doc_predicate<'a, 'tcx>(cdata: Cmd,\n }\n \n fn doc_predicates<'a, 'tcx>(base_doc: rbml::Doc,\n-                            tcx: TyCtxt<'a, 'tcx>,\n+                            tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                             cdata: Cmd,\n                             tag: usize)\n                             -> ty::GenericPredicates<'tcx>\n@@ -1730,7 +1736,7 @@ pub fn closure_kind(cdata: Cmd, closure_id: DefIndex) -> ty::ClosureKind {\n     ty::ClosureKind::decode(&mut decoder).unwrap()\n }\n \n-pub fn closure_ty<'a, 'tcx>(cdata: Cmd, closure_id: DefIndex, tcx: TyCtxt<'a, 'tcx>)\n+pub fn closure_ty<'a, 'tcx>(cdata: Cmd, closure_id: DefIndex, tcx: TyCtxt<'a, 'tcx, 'tcx>)\n                             -> ty::ClosureTy<'tcx> {\n     let closure_doc = cdata.lookup_item(closure_id);\n     let closure_ty_doc = reader::get_doc(closure_doc, tag_items_closure_ty);"}, {"sha": "020f12d753e63c6ab55e3a12024eb690f3bd2100", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4", "patch": "@@ -56,7 +56,7 @@ use rustc::hir::map::DefKey;\n \n pub struct EncodeContext<'a, 'tcx: 'a> {\n     pub diag: &'a Handler,\n-    pub tcx: TyCtxt<'a, 'tcx>,\n+    pub tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     pub reexports: &'a def::ExportMap,\n     pub item_symbols: &'a RefCell<NodeMap<String>>,\n     pub link_meta: &'a LinkMeta,\n@@ -1697,7 +1697,7 @@ fn encode_struct_field_attrs(ecx: &EncodeContext,\n \n \n struct ImplVisitor<'a, 'tcx:'a> {\n-    tcx: TyCtxt<'a, 'tcx>,\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     impls: FnvHashMap<DefId, Vec<DefId>>\n }\n \n@@ -2016,9 +2016,9 @@ fn encode_metadata_inner(rbml_w: &mut Encoder,\n }\n \n // Get the encoded string for a type\n-pub fn encoded_ty<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx>,\n+pub fn encoded_ty<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                             t: Ty<'tcx>,\n-                            def_id_to_string: for<'b> fn(TyCtxt<'b, 'tcx>, DefId) -> String)\n+                            def_id_to_string: for<'b> fn(TyCtxt<'b, 'tcx, 'tcx>, DefId) -> String)\n                             -> Vec<u8> {\n     let mut wr = Cursor::new(Vec::new());\n     tyencode::enc_ty(&mut wr, &tyencode::ctxt {"}, {"sha": "23142ca80ef0ecc695c088650263b15c5d2eb26c", "filename": "src/librustc_metadata/tls_context.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc_metadata%2Ftls_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc_metadata%2Ftls_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Ftls_context.rs?ref=76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4", "patch": "@@ -25,7 +25,7 @@ use tyencode;\n \n impl<'a, 'tcx: 'a> tls::EncodingContext<'tcx> for encoder::EncodeContext<'a, 'tcx> {\n \n-    fn tcx<'s>(&'s self) -> TyCtxt<'s, 'tcx> {\n+    fn tcx<'s>(&'s self) -> TyCtxt<'s, 'tcx, 'tcx> {\n         self.tcx\n     }\n \n@@ -40,12 +40,12 @@ impl<'a, 'tcx: 'a> tls::EncodingContext<'tcx> for encoder::EncodeContext<'a, 'tc\n \n pub struct DecodingContext<'a, 'tcx: 'a> {\n     pub crate_metadata: Cmd<'a>,\n-    pub tcx: TyCtxt<'a, 'tcx>,\n+    pub tcx: TyCtxt<'a, 'tcx, 'tcx>,\n }\n \n impl<'a, 'tcx: 'a> tls::DecodingContext<'tcx> for DecodingContext<'a, 'tcx> {\n \n-    fn tcx<'s>(&'s self) -> TyCtxt<'s, 'tcx> {\n+    fn tcx<'s>(&'s self) -> TyCtxt<'s, 'tcx, 'tcx> {\n         self.tcx\n     }\n "}, {"sha": "8f33042be01332c80f0c1e661bcc17facd74a79f", "filename": "src/librustc_metadata/tydecode.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc_metadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc_metadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Ftydecode.rs?ref=76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4", "patch": "@@ -41,12 +41,12 @@ pub struct TyDecoder<'a, 'tcx: 'a> {\n     data: &'a [u8],\n     krate: ast::CrateNum,\n     pos: usize,\n-    tcx: TyCtxt<'a, 'tcx>,\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     conv_def_id: DefIdConvert<'a>,\n }\n \n impl<'a,'tcx> TyDecoder<'a,'tcx> {\n-    pub fn with_doc(tcx: TyCtxt<'a, 'tcx>,\n+    pub fn with_doc(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                     crate_num: ast::CrateNum,\n                     doc: rbml::Doc<'a>,\n                     conv: DefIdConvert<'a>)\n@@ -57,7 +57,7 @@ impl<'a,'tcx> TyDecoder<'a,'tcx> {\n     pub fn new(data: &'a [u8],\n                crate_num: ast::CrateNum,\n                pos: usize,\n-               tcx: TyCtxt<'a, 'tcx>,\n+               tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                conv: DefIdConvert<'a>)\n                -> TyDecoder<'a, 'tcx> {\n         TyDecoder {"}, {"sha": "b663ba4f0d29ca64c47bc637f6f1f019d7922133", "filename": "src/librustc_metadata/tyencode.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc_metadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc_metadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Ftyencode.rs?ref=76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4", "patch": "@@ -37,9 +37,9 @@ use encoder;\n pub struct ctxt<'a, 'tcx: 'a> {\n     pub diag: &'a Handler,\n     // Def -> str Callback:\n-    pub ds: for<'b> fn(TyCtxt<'b, 'tcx>, DefId) -> String,\n+    pub ds: for<'b> fn(TyCtxt<'b, 'tcx, 'tcx>, DefId) -> String,\n     // The type context.\n-    pub tcx: TyCtxt<'a, 'tcx>,\n+    pub tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     pub abbrevs: &'a abbrev_map<'tcx>\n }\n "}, {"sha": "ac64d1eb65b4f659ffcc04b0afa74cd60df02a5a", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4", "patch": "@@ -22,7 +22,7 @@ use syntax::codemap::Span;\n use syntax::parse::token::keywords;\n \n pub struct Builder<'a, 'tcx: 'a> {\n-    hir: Cx<'a, 'tcx>,\n+    hir: Cx<'a, 'tcx, 'tcx>,\n     cfg: CFG<'tcx>,\n \n     fn_span: Span,\n@@ -160,7 +160,7 @@ macro_rules! unpack {\n ///////////////////////////////////////////////////////////////////////////\n /// the main entry point for building MIR for a function\n \n-pub fn construct_fn<'a, 'tcx, A>(hir: Cx<'a,'tcx>,\n+pub fn construct_fn<'a, 'tcx, A>(hir: Cx<'a, 'tcx, 'tcx>,\n                                  fn_id: ast::NodeId,\n                                  arguments: A,\n                                  return_ty: ty::FnOutput<'tcx>,\n@@ -232,7 +232,7 @@ pub fn construct_fn<'a, 'tcx, A>(hir: Cx<'a,'tcx>,\n     builder.finish(upvar_decls, arg_decls, return_ty)\n }\n \n-pub fn construct_const<'a, 'tcx>(hir: Cx<'a,'tcx>,\n+pub fn construct_const<'a, 'tcx>(hir: Cx<'a, 'tcx, 'tcx>,\n                                  item_id: ast::NodeId,\n                                  ast_expr: &'tcx hir::Expr)\n                                  -> (Mir<'tcx>, ScopeAuxiliaryVec) {\n@@ -260,7 +260,7 @@ pub fn construct_const<'a, 'tcx>(hir: Cx<'a,'tcx>,\n }\n \n impl<'a,'tcx> Builder<'a,'tcx> {\n-    fn new(hir: Cx<'a, 'tcx>, span: Span) -> Builder<'a, 'tcx> {\n+    fn new(hir: Cx<'a, 'tcx, 'tcx>, span: Span) -> Builder<'a, 'tcx> {\n         let mut builder = Builder {\n             hir: hir,\n             cfg: CFG { basic_blocks: vec![] },"}, {"sha": "d07a58b981b91c953f9902c41767eae92d9d11db", "filename": "src/librustc_mir/build/scope.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fscope.rs?ref=76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4", "patch": "@@ -662,7 +662,7 @@ fn build_scope_drops<'tcx>(cfg: &mut CFG<'tcx>,\n     block.unit()\n }\n \n-fn build_diverge_scope<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx>,\n+fn build_diverge_scope<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                  cfg: &mut CFG<'tcx>,\n                                  unit_temp: &Lvalue<'tcx>,\n                                  scope: &mut Scope<'tcx>,\n@@ -721,7 +721,7 @@ fn build_diverge_scope<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx>,\n     target\n }\n \n-fn build_free<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx>,\n+fn build_free<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                         unit_temp: &Lvalue<'tcx>,\n                         data: &FreeData<'tcx>,\n                         target: BasicBlock)"}, {"sha": "6a34d9ff0b4c4ed1cdfda7474bb6569efafb802d", "filename": "src/librustc_mir/graphviz.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc_mir%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc_mir%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fgraphviz.rs?ref=76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4", "patch": "@@ -16,7 +16,7 @@ use std::io::{self, Write};\n use syntax::ast::NodeId;\n \n /// Write a graphviz DOT graph of a list of MIRs.\n-pub fn write_mir_graphviz<'a, 'b, 'tcx, W, I>(tcx: TyCtxt<'b, 'tcx>,\n+pub fn write_mir_graphviz<'a, 'b, 'tcx, W, I>(tcx: TyCtxt<'b, 'tcx, 'tcx>,\n                                               iter: I, w: &mut W)\n                                               -> io::Result<()>\n where W: Write, I: Iterator<Item=(&'a NodeId, &'a Mir<'a>)> {\n@@ -118,8 +118,11 @@ fn write_edges<W: Write>(source: BasicBlock, mir: &Mir, w: &mut W) -> io::Result\n /// Write the graphviz DOT label for the overall graph. This is essentially a block of text that\n /// will appear below the graph, showing the type of the `fn` this MIR represents and the types of\n /// all the variables and temporaries.\n-fn write_graph_label<W: Write>(tcx: TyCtxt, nid: NodeId, mir: &Mir, w: &mut W)\n--> io::Result<()> {\n+fn write_graph_label<'a, 'tcx, W: Write>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                         nid: NodeId,\n+                                         mir: &Mir,\n+                                         w: &mut W)\n+                                         -> io::Result<()> {\n     write!(w, \"    label=<fn {}(\", dot::escape_html(&tcx.node_path_str(nid)))?;\n \n     // fn argument types."}, {"sha": "fd568aebea430ead9243bb0d60ed52bb60d2a6b7", "filename": "src/librustc_mir/hair/cx/block.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs?ref=76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4", "patch": "@@ -18,7 +18,7 @@ use syntax::ast;\n impl<'tcx> Mirror<'tcx> for &'tcx hir::Block {\n     type Output = Block<'tcx>;\n \n-    fn make_mirror<'a>(self, cx: &mut Cx<'a, 'tcx>) -> Block<'tcx> {\n+    fn make_mirror<'a>(self, cx: &mut Cx<'a, 'tcx, 'tcx>) -> Block<'tcx> {\n         // We have to eagerly translate the \"spine\" of the statements\n         // in order to get the lexical scoping correctly.\n         let stmts = mirror_stmts(cx, self.id, &*self.stmts);\n@@ -31,10 +31,10 @@ impl<'tcx> Mirror<'tcx> for &'tcx hir::Block {\n     }\n }\n \n-fn mirror_stmts<'a,'tcx:'a>(cx: &mut Cx<'a,'tcx>,\n-                            block_id: ast::NodeId,\n-                            stmts: &'tcx [hir::Stmt])\n-                            -> Vec<StmtRef<'tcx>>\n+fn mirror_stmts<'a, 'tcx>(cx: &mut Cx<'a, 'tcx, 'tcx>,\n+                          block_id: ast::NodeId,\n+                          stmts: &'tcx [hir::Stmt])\n+                          -> Vec<StmtRef<'tcx>>\n {\n     let mut result = vec![];\n     for (index, stmt) in stmts.iter().enumerate() {\n@@ -74,7 +74,9 @@ fn mirror_stmts<'a,'tcx:'a>(cx: &mut Cx<'a,'tcx>,\n     return result;\n }\n \n-pub fn to_expr_ref<'a, 'tcx: 'a>(cx: &mut Cx<'a, 'tcx>, block: &'tcx hir::Block) -> ExprRef<'tcx> {\n+pub fn to_expr_ref<'a, 'tcx>(cx: &mut Cx<'a, 'tcx, 'tcx>,\n+                             block: &'tcx hir::Block)\n+                             -> ExprRef<'tcx> {\n     let block_ty = cx.tcx.node_id_to_type(block.id);\n     let temp_lifetime = cx.tcx.region_maps.temporary_scope(block.id);\n     let expr = Expr {"}, {"sha": "bc1197b449bd1bb946116b899fb060938b2a5d0c", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 38, "deletions": 32, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4", "patch": "@@ -29,7 +29,7 @@ use syntax::ptr::P;\n impl<'tcx> Mirror<'tcx> for &'tcx hir::Expr {\n     type Output = Expr<'tcx>;\n \n-    fn make_mirror<'a>(self, cx: &mut Cx<'a, 'tcx>) -> Expr<'tcx> {\n+    fn make_mirror<'a>(self, cx: &mut Cx<'a, 'tcx, 'tcx>) -> Expr<'tcx> {\n         let temp_lifetime = cx.tcx.region_maps.temporary_scope(self.id);\n         let expr_extent = cx.tcx.region_maps.node_extent(self.id);\n \n@@ -202,7 +202,9 @@ impl<'tcx> Mirror<'tcx> for &'tcx hir::Expr {\n     }\n }\n \n-fn make_mirror_unadjusted<'a, 'tcx>(cx: &mut Cx<'a, 'tcx>, expr: &'tcx hir::Expr) -> Expr<'tcx> {\n+fn make_mirror_unadjusted<'a, 'tcx>(cx: &mut Cx<'a, 'tcx, 'tcx>,\n+                                    expr: &'tcx hir::Expr)\n+                                    -> Expr<'tcx> {\n     let expr_ty = cx.tcx.expr_ty(expr);\n     let temp_lifetime = cx.tcx.region_maps.temporary_scope(expr.id);\n \n@@ -620,10 +622,10 @@ fn make_mirror_unadjusted<'a, 'tcx>(cx: &mut Cx<'a, 'tcx>, expr: &'tcx hir::Expr\n     }\n }\n \n-fn method_callee<'a, 'tcx: 'a>(cx: &mut Cx<'a, 'tcx>,\n-                               expr: &hir::Expr,\n-                               method_call: ty::MethodCall)\n-                               -> Expr<'tcx> {\n+fn method_callee<'a, 'tcx>(cx: &mut Cx<'a, 'tcx, 'tcx>,\n+                           expr: &hir::Expr,\n+                           method_call: ty::MethodCall)\n+                           -> Expr<'tcx> {\n     let tables = cx.tcx.tables.borrow();\n     let callee = &tables.method_map[&method_call];\n     let temp_lifetime = cx.tcx.region_maps.temporary_scope(expr.id);\n@@ -647,7 +649,8 @@ fn to_borrow_kind(m: hir::Mutability) -> BorrowKind {\n     }\n }\n \n-fn convert_arm<'a, 'tcx: 'a>(cx: &mut Cx<'a, 'tcx>, arm: &'tcx hir::Arm) -> Arm<'tcx> {\n+fn convert_arm<'a, 'tcx>(cx: &mut Cx<'a, 'tcx, 'tcx>,\n+                         arm: &'tcx hir::Arm) -> Arm<'tcx> {\n     let mut map;\n     let opt_map = if arm.pats.len() == 1 {\n         None\n@@ -666,7 +669,9 @@ fn convert_arm<'a, 'tcx: 'a>(cx: &mut Cx<'a, 'tcx>, arm: &'tcx hir::Arm) -> Arm<\n     }\n }\n \n-fn convert_path_expr<'a, 'tcx: 'a>(cx: &mut Cx<'a, 'tcx>, expr: &'tcx hir::Expr) -> ExprKind<'tcx> {\n+fn convert_path_expr<'a, 'tcx>(cx: &mut Cx<'a, 'tcx, 'tcx>,\n+                               expr: &'tcx hir::Expr)\n+                               -> ExprKind<'tcx> {\n     let substs = cx.tcx.mk_substs(cx.tcx.node_id_item_substs(expr.id).substs);\n     // Otherwise there may be def_map borrow conflicts\n     let def = cx.tcx.def_map.borrow()[&expr.id].full_def();\n@@ -738,10 +743,10 @@ fn convert_path_expr<'a, 'tcx: 'a>(cx: &mut Cx<'a, 'tcx>, expr: &'tcx hir::Expr)\n     }\n }\n \n-fn convert_var<'a, 'tcx: 'a>(cx: &mut Cx<'a, 'tcx>,\n-                             expr: &'tcx hir::Expr,\n-                             def: Def)\n-                             -> ExprKind<'tcx> {\n+fn convert_var<'a, 'tcx>(cx: &mut Cx<'a, 'tcx, 'tcx>,\n+                         expr: &'tcx hir::Expr,\n+                         def: Def)\n+                         -> ExprKind<'tcx> {\n     let temp_lifetime = cx.tcx.region_maps.temporary_scope(expr.id);\n \n     match def {\n@@ -903,13 +908,13 @@ enum PassArgs {\n     ByRef,\n }\n \n-fn overloaded_operator<'a, 'tcx: 'a>(cx: &mut Cx<'a, 'tcx>,\n-                                     expr: &'tcx hir::Expr,\n-                                     method_call: ty::MethodCall,\n-                                     pass_args: PassArgs,\n-                                     receiver: ExprRef<'tcx>,\n-                                     args: Vec<&'tcx P<hir::Expr>>)\n-                                     -> ExprKind<'tcx> {\n+fn overloaded_operator<'a, 'tcx>(cx: &mut Cx<'a, 'tcx, 'tcx>,\n+                                 expr: &'tcx hir::Expr,\n+                                 method_call: ty::MethodCall,\n+                                 pass_args: PassArgs,\n+                                 receiver: ExprRef<'tcx>,\n+                                 args: Vec<&'tcx P<hir::Expr>>)\n+                                 -> ExprKind<'tcx> {\n     // the receiver has all the adjustments that are needed, so we can\n     // just push a reference to it\n     let mut argrefs = vec![receiver];\n@@ -954,13 +959,13 @@ fn overloaded_operator<'a, 'tcx: 'a>(cx: &mut Cx<'a, 'tcx>,\n     }\n }\n \n-fn overloaded_lvalue<'a, 'tcx: 'a>(cx: &mut Cx<'a, 'tcx>,\n-                                   expr: &'tcx hir::Expr,\n-                                   method_call: ty::MethodCall,\n-                                   pass_args: PassArgs,\n-                                   receiver: ExprRef<'tcx>,\n-                                   args: Vec<&'tcx P<hir::Expr>>)\n-                                   -> ExprKind<'tcx> {\n+fn overloaded_lvalue<'a, 'tcx>(cx: &mut Cx<'a, 'tcx, 'tcx>,\n+                               expr: &'tcx hir::Expr,\n+                               method_call: ty::MethodCall,\n+                               pass_args: PassArgs,\n+                               receiver: ExprRef<'tcx>,\n+                               args: Vec<&'tcx P<hir::Expr>>)\n+                               -> ExprKind<'tcx> {\n     // For an overloaded *x or x[y] expression of type T, the method\n     // call returns an &T and we must add the deref so that the types\n     // line up (this is because `*x` and `x[y]` represent lvalues):\n@@ -989,11 +994,11 @@ fn overloaded_lvalue<'a, 'tcx: 'a>(cx: &mut Cx<'a, 'tcx>,\n     ExprKind::Deref { arg: ref_expr.to_ref() }\n }\n \n-fn capture_freevar<'a, 'tcx: 'a>(cx: &mut Cx<'a, 'tcx>,\n-                                 closure_expr: &'tcx hir::Expr,\n-                                 freevar: &hir::Freevar,\n-                                 freevar_ty: Ty<'tcx>)\n-                                 -> ExprRef<'tcx> {\n+fn capture_freevar<'a, 'tcx>(cx: &mut Cx<'a, 'tcx, 'tcx>,\n+                             closure_expr: &'tcx hir::Expr,\n+                             freevar: &hir::Freevar,\n+                             freevar_ty: Ty<'tcx>)\n+                             -> ExprRef<'tcx> {\n     let id_var = freevar.def.var_id();\n     let upvar_id = ty::UpvarId {\n         var_id: id_var,\n@@ -1030,7 +1035,8 @@ fn capture_freevar<'a, 'tcx: 'a>(cx: &mut Cx<'a, 'tcx>,\n     }\n }\n \n-fn loop_label<'a, 'tcx: 'a>(cx: &mut Cx<'a, 'tcx>, expr: &'tcx hir::Expr) -> CodeExtent {\n+fn loop_label<'a, 'tcx>(cx: &mut Cx<'a, 'tcx, 'tcx>,\n+                        expr: &'tcx hir::Expr) -> CodeExtent {\n     match cx.tcx.def_map.borrow().get(&expr.id).map(|d| d.full_def()) {\n         Some(Def::Label(loop_id)) => cx.tcx.region_maps.node_extent(loop_id),\n         d => {"}, {"sha": "8f79b6e68eeea13e716116c60adcc473608eb7f3", "filename": "src/librustc_mir/hair/cx/mod.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs?ref=76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4", "patch": "@@ -29,16 +29,16 @@ use rustc::hir;\n use rustc_const_math::{ConstInt, ConstUsize};\n \n #[derive(Copy, Clone)]\n-pub struct Cx<'a, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'tcx>,\n-    infcx: &'a InferCtxt<'a, 'tcx>,\n+pub struct Cx<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n+    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+    infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n     constness: hir::Constness\n }\n \n-impl<'a,'tcx> Cx<'a,'tcx> {\n-    pub fn new(infcx: &'a InferCtxt<'a, 'tcx>,\n+impl<'a, 'tcx> Cx<'a, 'tcx, 'tcx> {\n+    pub fn new(infcx: &'a InferCtxt<'a, 'tcx, 'tcx>,\n                constness: hir::Constness)\n-               -> Cx<'a, 'tcx> {\n+               -> Cx<'a, 'tcx, 'tcx> {\n         Cx {\n             tcx: infcx.tcx,\n             infcx: infcx,\n@@ -47,7 +47,7 @@ impl<'a,'tcx> Cx<'a,'tcx> {\n     }\n }\n \n-impl<'a,'tcx:'a> Cx<'a, 'tcx> {\n+impl<'a, 'tcx: 'a> Cx<'a, 'tcx, 'tcx> {\n     /// Normalizes `ast` into the appropriate `mirror` type.\n     pub fn mirror<M: Mirror<'tcx>>(&mut self, ast: M) -> M::Output {\n         ast.make_mirror(self)\n@@ -144,7 +144,7 @@ impl<'a,'tcx:'a> Cx<'a, 'tcx> {\n         self.tcx.type_needs_drop_given_env(ty, &self.infcx.parameter_environment)\n     }\n \n-    pub fn tcx(&self) -> TyCtxt<'a, 'tcx> {\n+    pub fn tcx(&self) -> TyCtxt<'a, 'tcx, 'tcx> {\n         self.tcx\n     }\n }"}, {"sha": "3fbfead0c08d3ce012a8031ecbcd483ff2b81278", "filename": "src/librustc_mir/hair/cx/pattern.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc_mir%2Fhair%2Fcx%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc_mir%2Fhair%2Fcx%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fpattern.rs?ref=76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4", "patch": "@@ -35,11 +35,11 @@ use syntax::ptr::P;\n /// }\n /// ```\n struct PatCx<'patcx, 'cx: 'patcx, 'tcx: 'cx> {\n-    cx: &'patcx mut Cx<'cx, 'tcx>,\n+    cx: &'patcx mut Cx<'cx, 'tcx, 'tcx>,\n     binding_map: Option<&'patcx FnvHashMap<ast::Name, ast::NodeId>>,\n }\n \n-impl<'cx, 'tcx> Cx<'cx, 'tcx> {\n+impl<'cx, 'tcx> Cx<'cx, 'tcx, 'tcx> {\n     pub fn irrefutable_pat(&mut self, pat: &hir::Pat) -> Pattern<'tcx> {\n         PatCx::new(self, None).to_pattern(pat)\n     }\n@@ -53,7 +53,7 @@ impl<'cx, 'tcx> Cx<'cx, 'tcx> {\n }\n \n impl<'patcx, 'cx, 'tcx> PatCx<'patcx, 'cx, 'tcx> {\n-    fn new(cx: &'patcx mut Cx<'cx, 'tcx>,\n+    fn new(cx: &'patcx mut Cx<'cx, 'tcx, 'tcx>,\n                binding_map: Option<&'patcx FnvHashMap<ast::Name, ast::NodeId>>)\n                -> PatCx<'patcx, 'cx, 'tcx> {\n         PatCx {"}, {"sha": "d29e931f59389d2fbfcd1d8c4b9631648b9e01e6", "filename": "src/librustc_mir/hair/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fmod.rs?ref=76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4", "patch": "@@ -358,21 +358,21 @@ pub struct FieldPattern<'tcx> {\n pub trait Mirror<'tcx> {\n     type Output;\n \n-    fn make_mirror<'a>(self, cx: &mut Cx<'a, 'tcx>) -> Self::Output;\n+    fn make_mirror<'a>(self, cx: &mut Cx<'a, 'tcx, 'tcx>) -> Self::Output;\n }\n \n impl<'tcx> Mirror<'tcx> for Expr<'tcx> {\n     type Output = Expr<'tcx>;\n \n-    fn make_mirror<'a>(self, _: &mut Cx<'a, 'tcx>) -> Expr<'tcx> {\n+    fn make_mirror<'a>(self, _: &mut Cx<'a, 'tcx, 'tcx>) -> Expr<'tcx> {\n         self\n     }\n }\n \n impl<'tcx> Mirror<'tcx> for ExprRef<'tcx> {\n     type Output = Expr<'tcx>;\n \n-    fn make_mirror<'a>(self, hir: &mut Cx<'a, 'tcx>) -> Expr<'tcx> {\n+    fn make_mirror<'a>(self, hir: &mut Cx<'a, 'tcx, 'tcx>) -> Expr<'tcx> {\n         match self {\n             ExprRef::Hair(h) => h.make_mirror(hir),\n             ExprRef::Mirror(m) => *m,\n@@ -383,15 +383,15 @@ impl<'tcx> Mirror<'tcx> for ExprRef<'tcx> {\n impl<'tcx> Mirror<'tcx> for Stmt<'tcx> {\n     type Output = Stmt<'tcx>;\n \n-    fn make_mirror<'a>(self, _: &mut Cx<'a, 'tcx>) -> Stmt<'tcx> {\n+    fn make_mirror<'a>(self, _: &mut Cx<'a, 'tcx, 'tcx>) -> Stmt<'tcx> {\n         self\n     }\n }\n \n impl<'tcx> Mirror<'tcx> for StmtRef<'tcx> {\n     type Output = Stmt<'tcx>;\n \n-    fn make_mirror<'a>(self, _: &mut Cx<'a,'tcx>) -> Stmt<'tcx> {\n+    fn make_mirror<'a>(self, _: &mut Cx<'a, 'tcx, 'tcx>) -> Stmt<'tcx> {\n         match self {\n             StmtRef::Mirror(m) => *m,\n         }\n@@ -401,7 +401,7 @@ impl<'tcx> Mirror<'tcx> for StmtRef<'tcx> {\n impl<'tcx> Mirror<'tcx> for Block<'tcx> {\n     type Output = Block<'tcx>;\n \n-    fn make_mirror<'a>(self, _: &mut Cx<'a, 'tcx>) -> Block<'tcx> {\n+    fn make_mirror<'a>(self, _: &mut Cx<'a, 'tcx, 'tcx>) -> Block<'tcx> {\n         self\n     }\n }"}, {"sha": "139bb755ad10ac31c497d0714be4c2dc24778e98", "filename": "src/librustc_mir/mir_map.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc_mir%2Fmir_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc_mir%2Fmir_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmir_map.rs?ref=76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4", "patch": "@@ -34,7 +34,7 @@ use rustc::hir::map::blocks::FnLikeNode;\n use syntax::ast;\n use syntax::codemap::Span;\n \n-pub fn build_mir_for_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx>) -> MirMap<'tcx> {\n+pub fn build_mir_for_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> MirMap<'tcx> {\n     let mut map = MirMap {\n         map: NodeMap(),\n     };\n@@ -52,13 +52,13 @@ pub fn build_mir_for_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx>) -> MirMap<'tcx> {\n // BuildMir -- walks a crate, looking for fn items and methods to build MIR from\n \n struct BuildMir<'a, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'tcx>,\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     map: &'a mut MirMap<'tcx>,\n }\n \n impl<'a, 'tcx> BuildMir<'a, 'tcx> {\n     fn build<F>(&mut self, src: MirSource, f: F)\n-        where F: for<'b> FnOnce(Cx<'b, 'tcx>) -> (Mir<'tcx>, build::ScopeAuxiliaryVec)\n+        where F: for<'b> FnOnce(Cx<'b, 'tcx, 'tcx>) -> (Mir<'tcx>, build::ScopeAuxiliaryVec)\n     {\n         let constness = match src {\n             MirSource::Const(_) |\n@@ -202,7 +202,7 @@ impl<'a, 'tcx> Visitor<'tcx> for BuildMir<'a, 'tcx> {\n     }\n }\n \n-fn closure_self_ty<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx>,\n+fn closure_self_ty<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                              closure_expr_id: ast::NodeId,\n                              body_id: ast::NodeId)\n                              -> Ty<'tcx> {"}, {"sha": "bf6689de236ce1ff240a394f56ac1ea6b1273fac", "filename": "src/librustc_mir/pretty.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc_mir%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc_mir%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fpretty.rs?ref=76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4", "patch": "@@ -36,7 +36,7 @@ const INDENT: &'static str = \"    \";\n /// - `substring1&substring2,...` -- `&`-separated list of substrings\n ///   that can appear in the pass-name or the `item_path_str` for the given\n ///   node-id. If any one of the substrings match, the data is dumped out.\n-pub fn dump_mir<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx>,\n+pub fn dump_mir<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                           pass_name: &str,\n                           disambiguator: &Display,\n                           src: MirSource,\n@@ -73,7 +73,7 @@ pub fn dump_mir<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx>,\n }\n \n /// Write out a human-readable textual representation for the given MIR.\n-pub fn write_mir_pretty<'a, 'b, 'tcx, I>(tcx: TyCtxt<'b, 'tcx>,\n+pub fn write_mir_pretty<'a, 'b, 'tcx, I>(tcx: TyCtxt<'b, 'tcx, 'tcx>,\n                                          iter: I,\n                                          w: &mut Write)\n                                          -> io::Result<()>\n@@ -95,7 +95,7 @@ enum Annotation {\n     ExitScope(ScopeId),\n }\n \n-pub fn write_mir_fn<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx>,\n+pub fn write_mir_fn<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                               src: MirSource,\n                               mir: &Mir<'tcx>,\n                               w: &mut Write,\n@@ -219,8 +219,11 @@ fn write_scope_tree(tcx: TyCtxt,\n \n /// Write out a human-readable textual representation of the MIR's `fn` type and the types of its\n /// local variables (both user-defined bindings and compiler temporaries).\n-fn write_mir_intro(tcx: TyCtxt, src: MirSource, mir: &Mir, w: &mut Write)\n-                   -> io::Result<()> {\n+fn write_mir_intro<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                             src: MirSource,\n+                             mir: &Mir,\n+                             w: &mut Write)\n+                             -> io::Result<()> {\n     match src {\n         MirSource::Fn(_) => write!(w, \"fn\")?,\n         MirSource::Const(_) => write!(w, \"const\")?,"}, {"sha": "a6af30b7eec08e6cb83a0f9e497d3572242ec682", "filename": "src/librustc_mir/transform/break_critical_edges.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc_mir%2Ftransform%2Fbreak_critical_edges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc_mir%2Ftransform%2Fbreak_critical_edges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fbreak_critical_edges.rs?ref=76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4", "patch": "@@ -42,7 +42,8 @@ pub struct BreakCriticalEdges;\n  */\n \n impl<'tcx> MirPass<'tcx> for BreakCriticalEdges {\n-    fn run_pass<'a>(&mut self, _: TyCtxt<'a, 'tcx>, _: MirSource, mir: &mut Mir<'tcx>) {\n+    fn run_pass<'a>(&mut self, _: TyCtxt<'a, 'tcx, 'tcx>,\n+                    _: MirSource, mir: &mut Mir<'tcx>) {\n         break_critical_edges(mir);\n     }\n }"}, {"sha": "1ee1ee737aaf3fd656defc9dbf71dae8a3872ef9", "filename": "src/librustc_mir/transform/erase_regions.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc_mir%2Ftransform%2Ferase_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc_mir%2Ftransform%2Ferase_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Ferase_regions.rs?ref=76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4", "patch": "@@ -19,11 +19,11 @@ use rustc::mir::visit::MutVisitor;\n use rustc::mir::transform::{MirPass, MirSource, Pass};\n \n struct EraseRegionsVisitor<'a, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'tcx>,\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n }\n \n impl<'a, 'tcx> EraseRegionsVisitor<'a, 'tcx> {\n-    pub fn new(tcx: TyCtxt<'a, 'tcx>) -> Self {\n+    pub fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Self {\n         EraseRegionsVisitor {\n             tcx: tcx\n         }\n@@ -46,7 +46,8 @@ pub struct EraseRegions;\n impl Pass for EraseRegions {}\n \n impl<'tcx> MirPass<'tcx> for EraseRegions {\n-    fn run_pass<'a>(&mut self, tcx: TyCtxt<'a, 'tcx>, _: MirSource, mir: &mut Mir<'tcx>) {\n+    fn run_pass<'a>(&mut self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                    _: MirSource, mir: &mut Mir<'tcx>) {\n         EraseRegionsVisitor::new(tcx).visit_mir(mir);\n     }\n }"}, {"sha": "de05032fa558624e90f40206504bd942a1ca6db3", "filename": "src/librustc_mir/transform/no_landing_pads.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc_mir%2Ftransform%2Fno_landing_pads.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc_mir%2Ftransform%2Fno_landing_pads.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fno_landing_pads.rs?ref=76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4", "patch": "@@ -41,7 +41,8 @@ impl<'tcx> MutVisitor<'tcx> for NoLandingPads {\n }\n \n impl<'tcx> MirPass<'tcx> for NoLandingPads {\n-    fn run_pass<'a>(&mut self, tcx: TyCtxt<'a, 'tcx>, _: MirSource, mir: &mut Mir<'tcx>) {\n+    fn run_pass<'a>(&mut self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                    _: MirSource, mir: &mut Mir<'tcx>) {\n         if tcx.sess.no_landing_pads() {\n             self.visit_mir(mir);\n         }"}, {"sha": "431568b004d3ddbda6ec75e2680e9c5efa18c8d2", "filename": "src/librustc_mir/transform/promote_consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs?ref=76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4", "patch": "@@ -331,7 +331,7 @@ impl<'a, 'tcx> MutVisitor<'tcx> for Promoter<'a, 'tcx> {\n }\n \n pub fn promote_candidates<'a, 'tcx>(mir: &mut Mir<'tcx>,\n-                                    tcx: TyCtxt<'a, 'tcx>,\n+                                    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                     mut temps: Vec<TempState>,\n                                     candidates: Vec<Candidate>) {\n     // Visit candidates in reverse, in case they're nested."}, {"sha": "2f44786aa0e3882079113bd9e75d2c9c2edec351", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4", "patch": "@@ -126,13 +126,13 @@ fn is_const_fn(tcx: TyCtxt, def_id: DefId) -> bool {\n     }\n }\n \n-struct Qualifier<'a, 'tcx: 'a> {\n+struct Qualifier<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     mode: Mode,\n     span: Span,\n     def_id: DefId,\n     mir: &'a Mir<'tcx>,\n     rpo: ReversePostorder<'a, 'tcx>,\n-    tcx: TyCtxt<'a, 'tcx>,\n+    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n     param_env: ty::ParameterEnvironment<'a, 'tcx>,\n     qualif_map: &'a mut DefIdMap<Qualif>,\n     mir_map: Option<&'a MirMap<'tcx>>,\n@@ -145,14 +145,14 @@ struct Qualifier<'a, 'tcx: 'a> {\n     promotion_candidates: Vec<Candidate>\n }\n \n-impl<'a, 'tcx> Qualifier<'a, 'tcx> {\n+impl<'a, 'tcx> Qualifier<'a, 'tcx, 'tcx> {\n     fn new(param_env: ty::ParameterEnvironment<'a, 'tcx>,\n            qualif_map: &'a mut DefIdMap<Qualif>,\n            mir_map: Option<&'a MirMap<'tcx>>,\n            def_id: DefId,\n            mir: &'a Mir<'tcx>,\n            mode: Mode)\n-           -> Qualifier<'a, 'tcx> {\n+           -> Qualifier<'a, 'tcx, 'tcx> {\n         let mut rpo = traversal::reverse_postorder(mir);\n         let temps = promote_consts::collect_temps(mir, &mut rpo);\n         rpo.reset();\n@@ -492,7 +492,7 @@ impl<'a, 'tcx> Qualifier<'a, 'tcx> {\n /// Accumulates an Rvalue or Call's effects in self.qualif.\n /// For functions (constant or not), it also records\n /// candidates for promotion in promotion_candidates.\n-impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx> {\n+impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n     fn visit_lvalue(&mut self, lvalue: &Lvalue<'tcx>, context: LvalueContext) {\n         match *lvalue {\n             Lvalue::Arg(_) => {\n@@ -908,7 +908,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx> {\n     }\n }\n \n-fn qualify_const_item_cached<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx>,\n+fn qualify_const_item_cached<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                        qualif_map: &mut DefIdMap<Qualif>,\n                                        mir_map: Option<&MirMap<'tcx>>,\n                                        def_id: DefId)\n@@ -951,7 +951,7 @@ pub struct QualifyAndPromoteConstants;\n impl Pass for QualifyAndPromoteConstants {}\n \n impl<'tcx> MirMapPass<'tcx> for QualifyAndPromoteConstants {\n-    fn run_pass<'a>(&mut self, tcx: TyCtxt<'a, 'tcx>, map: &mut MirMap<'tcx>) {\n+    fn run_pass<'a>(&mut self, tcx: TyCtxt<'a, 'tcx, 'tcx>, map: &mut MirMap<'tcx>) {\n         let mut qualif_map = DefIdMap();\n \n         // First, visit `const` items, potentially recursing, to get"}, {"sha": "44f3ce7361cf49f18b7eb14e5d13c505f0eb97ef", "filename": "src/librustc_mir/transform/remove_dead_blocks.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc_mir%2Ftransform%2Fremove_dead_blocks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc_mir%2Ftransform%2Fremove_dead_blocks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fremove_dead_blocks.rs?ref=76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4", "patch": "@@ -40,7 +40,8 @@ use rustc::mir::transform::{Pass, MirPass, MirSource};\n pub struct RemoveDeadBlocks;\n \n impl<'tcx> MirPass<'tcx> for RemoveDeadBlocks {\n-    fn run_pass<'a>(&mut self, _: TyCtxt<'a, 'tcx>, _: MirSource, mir: &mut Mir<'tcx>) {\n+    fn run_pass<'a>(&mut self, _: TyCtxt<'a, 'tcx, 'tcx>,\n+                    _: MirSource, mir: &mut Mir<'tcx>) {\n         let mut seen = BitVector::new(mir.basic_blocks.len());\n         // This block is always required.\n         seen.insert(START_BLOCK.index());"}, {"sha": "fa897384a542a39508274884e4eb857082601fb9", "filename": "src/librustc_mir/transform/simplify_cfg.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc_mir%2Ftransform%2Fsimplify_cfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc_mir%2Ftransform%2Fsimplify_cfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fsimplify_cfg.rs?ref=76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4", "patch": "@@ -111,7 +111,8 @@ impl SimplifyCfg {\n }\n \n impl<'tcx> MirPass<'tcx> for SimplifyCfg {\n-    fn run_pass<'a>(&mut self, tcx: TyCtxt<'a, 'tcx>, src: MirSource, mir: &mut Mir<'tcx>) {\n+    fn run_pass<'a>(&mut self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                    src: MirSource, mir: &mut Mir<'tcx>) {\n         let mut counter = 0;\n         let mut changed = true;\n         while changed {"}, {"sha": "aed20dd76549b4714687e20166e188068567cef5", "filename": "src/librustc_mir/transform/type_check.rs", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs?ref=76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4", "patch": "@@ -54,14 +54,14 @@ enum FieldAccessError {\n /// The sanitize_XYZ methods here take an MIR object and compute its\n /// type, calling `span_mirbug` and returning an error type if there\n /// is a problem.\n-struct TypeVerifier<'a, 'b: 'a, 'tcx: 'b> {\n-    cx: &'a mut TypeChecker<'b, 'tcx>,\n+struct TypeVerifier<'a, 'b: 'a, 'gcx: 'b+'tcx, 'tcx: 'b> {\n+    cx: &'a mut TypeChecker<'b, 'gcx, 'tcx>,\n     mir: &'a Mir<'tcx>,\n     last_span: Span,\n     errors_reported: bool\n }\n \n-impl<'a, 'b, 'tcx> Visitor<'tcx> for TypeVerifier<'a, 'b, 'tcx> {\n+impl<'a, 'b, 'tcx> Visitor<'tcx> for TypeVerifier<'a, 'b, 'tcx, 'tcx> {\n     fn visit_span(&mut self, span: &Span) {\n         if *span != DUMMY_SP {\n             self.last_span = *span;\n@@ -104,8 +104,8 @@ impl<'a, 'b, 'tcx> Visitor<'tcx> for TypeVerifier<'a, 'b, 'tcx> {\n     }\n }\n \n-impl<'a, 'b, 'tcx> TypeVerifier<'a, 'b, 'tcx> {\n-    fn new(cx: &'a mut TypeChecker<'b, 'tcx>, mir: &'a Mir<'tcx>) -> Self {\n+impl<'a, 'b, 'tcx> TypeVerifier<'a, 'b, 'tcx, 'tcx> {\n+    fn new(cx: &'a mut TypeChecker<'b, 'tcx, 'tcx>, mir: &'a Mir<'tcx>) -> Self {\n         TypeVerifier {\n             cx: cx,\n             mir: mir,\n@@ -114,11 +114,11 @@ impl<'a, 'b, 'tcx> TypeVerifier<'a, 'b, 'tcx> {\n         }\n     }\n \n-    fn tcx(&self) -> TyCtxt<'a, 'tcx> {\n+    fn tcx(&self) -> TyCtxt<'a, 'tcx, 'tcx> {\n         self.cx.infcx.tcx\n     }\n \n-    fn infcx(&self) -> &'a InferCtxt<'a, 'tcx> {\n+    fn infcx(&self) -> &'a InferCtxt<'a, 'tcx, 'tcx> {\n         self.cx.infcx\n     }\n \n@@ -318,14 +318,14 @@ impl<'a, 'b, 'tcx> TypeVerifier<'a, 'b, 'tcx> {\n     }\n }\n \n-pub struct TypeChecker<'a, 'tcx: 'a> {\n-    infcx: &'a InferCtxt<'a, 'tcx>,\n+pub struct TypeChecker<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n+    infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n     fulfillment_cx: traits::FulfillmentContext<'tcx>,\n     last_span: Span\n }\n \n-impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n-    fn new(infcx: &'a InferCtxt<'a, 'tcx>) -> Self {\n+impl<'a, 'tcx> TypeChecker<'a, 'tcx, 'tcx> {\n+    fn new(infcx: &'a InferCtxt<'a, 'tcx, 'tcx>) -> Self {\n         TypeChecker {\n             infcx: infcx,\n             fulfillment_cx: traits::FulfillmentContext::new(),\n@@ -349,7 +349,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n             .map(|InferOk { obligations, .. }| assert!(obligations.is_empty()))\n     }\n \n-    fn tcx(&self) -> TyCtxt<'a, 'tcx> {\n+    fn tcx(&self) -> TyCtxt<'a, 'tcx, 'tcx> {\n         self.infcx.tcx\n     }\n \n@@ -576,7 +576,8 @@ impl TypeckMir {\n }\n \n impl<'tcx> MirPass<'tcx> for TypeckMir {\n-    fn run_pass<'a>(&mut self, tcx: TyCtxt<'a, 'tcx>, src: MirSource, mir: &mut Mir<'tcx>) {\n+    fn run_pass<'a>(&mut self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                    src: MirSource, mir: &mut Mir<'tcx>) {\n         if tcx.sess.err_count() > 0 {\n             // compiling a broken program can obviously result in a\n             // broken MIR, so try not to report duplicate errors."}, {"sha": "98aff8e27f1ce721d62d664e77bbfb86fa4e02d3", "filename": "src/librustc_passes/consts.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc_passes%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc_passes%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fconsts.rs?ref=76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4", "patch": "@@ -68,7 +68,7 @@ enum Mode {\n }\n \n struct CheckCrateVisitor<'a, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'tcx>,\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     mode: Mode,\n     qualif: ConstQualif,\n     rvalue_borrows: NodeMap<hir::Mutability>\n@@ -88,7 +88,7 @@ impl<'a, 'tcx> CheckCrateVisitor<'a, 'tcx> {\n     }\n \n     fn with_euv<'b, F, R>(&'b mut self, item_id: Option<ast::NodeId>, f: F) -> R where\n-        F: for<'t> FnOnce(&mut euv::ExprUseVisitor<'b, 't, 'b, 'tcx>) -> R,\n+        F: for<'c> FnOnce(&mut euv::ExprUseVisitor<'b, 'c, 'tcx, 'tcx>) -> R,\n     {\n         let param_env = match item_id {\n             Some(item_id) => ty::ParameterEnvironment::for_item(self.tcx, item_id),\n@@ -663,7 +663,7 @@ fn check_adjustments<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>, e: &hir::Exp\n     }\n }\n \n-pub fn check_crate(tcx: TyCtxt) {\n+pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     tcx.visit_all_items_in_krate(DepNode::CheckConst, &mut CheckCrateVisitor {\n         tcx: tcx,\n         mode: Mode::Var,"}, {"sha": "b8d633687265cd5f0eb20838cbc6294a3b9554de", "filename": "src/librustc_passes/rvalues.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc_passes%2Frvalues.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc_passes%2Frvalues.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Frvalues.rs?ref=76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4", "patch": "@@ -23,13 +23,13 @@ use rustc::hir::intravisit;\n use syntax::ast;\n use syntax::codemap::Span;\n \n-pub fn check_crate(tcx: TyCtxt) {\n+pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     let mut rvcx = RvalueContext { tcx: tcx };\n     tcx.visit_all_items_in_krate(DepNode::RvalueCheck, &mut rvcx);\n }\n \n struct RvalueContext<'a, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'tcx>,\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n }\n \n impl<'a, 'tcx, 'v> intravisit::Visitor<'v> for RvalueContext<'a, 'tcx> {\n@@ -54,7 +54,7 @@ impl<'a, 'tcx, 'v> intravisit::Visitor<'v> for RvalueContext<'a, 'tcx> {\n }\n \n struct RvalueContextDelegate<'a, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'tcx>,\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     param_env: &'a ty::ParameterEnvironment<'a,'tcx>,\n }\n "}, {"sha": "0b2763baf4f67a90c719d7e828069d3109f9a67f", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4", "patch": "@@ -58,7 +58,7 @@ type CheckResult = Option<(Span, String, Option<(Span, String)>)>;\n ////////////////////////////////////////////////////////////////////////////////\n \n struct EmbargoVisitor<'a, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'tcx>,\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     export_map: &'a def::ExportMap,\n \n     // Accessibility levels for reachable nodes\n@@ -376,7 +376,7 @@ impl<'b, 'a, 'tcx: 'a, 'v> Visitor<'v> for ReachEverythingInTheInterfaceVisitor<\n ////////////////////////////////////////////////////////////////////////////////\n \n struct PrivacyVisitor<'a, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'tcx>,\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     curitem: ast::NodeId,\n     in_foreign: bool,\n }\n@@ -526,7 +526,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for PrivacyVisitor<'a, 'tcx> {\n ////////////////////////////////////////////////////////////////////////////////\n \n struct SanePrivacyVisitor<'a, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'tcx>,\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n }\n \n impl<'a, 'tcx, 'v> Visitor<'v> for SanePrivacyVisitor<'a, 'tcx> {\n@@ -597,7 +597,7 @@ impl<'a, 'tcx> SanePrivacyVisitor<'a, 'tcx> {\n ///////////////////////////////////////////////////////////////////////////////\n \n struct ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'tcx>,\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     access_levels: &'a AccessLevels,\n     in_variant: bool,\n     // set of errors produced by this obsolete visitor\n@@ -937,7 +937,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx>\n ///////////////////////////////////////////////////////////////////////////////\n \n struct SearchInterfaceForPrivateItemsVisitor<'a, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'tcx>,\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     /// The visitor checks that each component type is at least this visible\n     required_visibility: ty::Visibility,\n     /// The visibility of the least visible component that has been visited\n@@ -946,7 +946,7 @@ struct SearchInterfaceForPrivateItemsVisitor<'a, 'tcx: 'a> {\n }\n \n impl<'a, 'tcx: 'a> SearchInterfaceForPrivateItemsVisitor<'a, 'tcx> {\n-    fn new(tcx: TyCtxt<'a, 'tcx>, old_error_set: &'a NodeSet) -> Self {\n+    fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>, old_error_set: &'a NodeSet) -> Self {\n         SearchInterfaceForPrivateItemsVisitor {\n             tcx: tcx,\n             min_visibility: ty::Visibility::Public,\n@@ -1082,7 +1082,7 @@ impl<'a, 'tcx: 'a, 'v> Visitor<'v> for SearchInterfaceForPrivateItemsVisitor<'a,\n }\n \n struct PrivateItemsInPublicInterfacesVisitor<'a, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'tcx>,\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     old_error_set: &'a NodeSet,\n }\n \n@@ -1173,7 +1173,9 @@ impl<'a, 'tcx, 'v> Visitor<'v> for PrivateItemsInPublicInterfacesVisitor<'a, 'tc\n     }\n }\n \n-pub fn check_crate(tcx: TyCtxt, export_map: &def::ExportMap) -> AccessLevels {\n+pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                             export_map: &def::ExportMap)\n+                             -> AccessLevels {\n     let _task = tcx.dep_graph.in_task(DepNode::Privacy);\n \n     let krate = tcx.map.krate();"}, {"sha": "f0dd7b8b9bba1c11c1f9970ba2c5001571f52391", "filename": "src/librustc_save_analysis/dump_visitor.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdump_visitor.rs?ref=76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4", "patch": "@@ -62,7 +62,7 @@ macro_rules! down_cast_data {\n pub struct DumpVisitor<'l, 'tcx: 'l, 'll, D: 'll> {\n     save_ctxt: SaveContext<'l, 'tcx>,\n     sess: &'l Session,\n-    tcx: TyCtxt<'l, 'tcx>,\n+    tcx: TyCtxt<'l, 'tcx, 'tcx>,\n     analysis: &'l ty::CrateAnalysis<'l>,\n     dumper: &'ll mut D,\n \n@@ -79,7 +79,7 @@ pub struct DumpVisitor<'l, 'tcx: 'l, 'll, D: 'll> {\n }\n \n impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n-    pub fn new(tcx: TyCtxt<'l, 'tcx>,\n+    pub fn new(tcx: TyCtxt<'l, 'tcx, 'tcx>,\n                save_ctxt: SaveContext<'l, 'tcx>,\n                analysis: &'l ty::CrateAnalysis<'l>,\n                dumper: &'ll mut D)"}, {"sha": "d62c14d2c575ecbf4ede5a1a8b4972d6569a9dff", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4", "patch": "@@ -75,7 +75,7 @@ pub mod recorder {\n }\n \n pub struct SaveContext<'l, 'tcx: 'l> {\n-    tcx: TyCtxt<'l, 'tcx>,\n+    tcx: TyCtxt<'l, 'tcx, 'tcx>,\n     span_utils: SpanUtils<'tcx>,\n }\n \n@@ -84,12 +84,12 @@ macro_rules! option_try(\n );\n \n impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n-    pub fn new(tcx: TyCtxt<'l, 'tcx>) -> SaveContext<'l, 'tcx> {\n+    pub fn new(tcx: TyCtxt<'l, 'tcx, 'tcx>) -> SaveContext<'l, 'tcx> {\n         let span_utils = SpanUtils::new(&tcx.sess);\n         SaveContext::from_span_utils(tcx, span_utils)\n     }\n \n-    pub fn from_span_utils(tcx: TyCtxt<'l, 'tcx>,\n+    pub fn from_span_utils(tcx: TyCtxt<'l, 'tcx, 'tcx>,\n                            span_utils: SpanUtils<'tcx>)\n                            -> SaveContext<'l, 'tcx> {\n         SaveContext {\n@@ -699,7 +699,7 @@ impl Format {\n     }\n }\n \n-pub fn process_crate<'l, 'tcx>(tcx: TyCtxt<'l, 'tcx>,\n+pub fn process_crate<'l, 'tcx>(tcx: TyCtxt<'l, 'tcx, 'tcx>,\n                                krate: &ast::Crate,\n                                analysis: &'l ty::CrateAnalysis<'l>,\n                                cratename: &str,"}, {"sha": "08d1c33b1a59ff1ae86ce2f693f6d9f76ce33e57", "filename": "src/librustc_trans/_match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc_trans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc_trans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2F_match.rs?ref=76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4", "patch": "@@ -239,7 +239,7 @@ use syntax::ptr::P;\n struct ConstantExpr<'a>(&'a hir::Expr);\n \n impl<'a> ConstantExpr<'a> {\n-    fn eq(self, other: ConstantExpr<'a>, tcx: TyCtxt) -> bool {\n+    fn eq<'b, 'tcx>(self, other: ConstantExpr<'a>, tcx: TyCtxt<'b, 'tcx, 'tcx>) -> bool {\n         match compare_lit_exprs(tcx, self.0, other.0) {\n             Some(result) => result == Ordering::Equal,\n             None => bug!(\"compare_list_exprs: type mismatch\"),\n@@ -260,7 +260,7 @@ enum Opt<'a, 'tcx> {\n }\n \n impl<'a, 'b, 'tcx> Opt<'a, 'tcx> {\n-    fn eq(&self, other: &Opt<'a, 'tcx>, tcx: TyCtxt<'b, 'tcx>) -> bool {\n+    fn eq(&self, other: &Opt<'a, 'tcx>, tcx: TyCtxt<'b, 'tcx, 'tcx>) -> bool {\n         match (self, other) {\n             (&ConstantValue(a, _), &ConstantValue(b, _)) => a.eq(b, tcx),\n             (&ConstantRange(a1, a2, _), &ConstantRange(b1, b2, _)) => {"}, {"sha": "49775388038afb172d4084f8e1ec322d7e820280", "filename": "src/librustc_trans/adt.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc_trans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc_trans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fadt.rs?ref=76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4", "patch": "@@ -237,7 +237,7 @@ fn dtor_to_init_u8(dtor: bool) -> u8 {\n }\n \n pub trait GetDtorType<'tcx> { fn dtor_type(self) -> Ty<'tcx>; }\n-impl<'a, 'tcx> GetDtorType<'tcx> for TyCtxt<'a, 'tcx> {\n+impl<'a, 'tcx> GetDtorType<'tcx> for TyCtxt<'a, 'tcx, 'tcx> {\n     fn dtor_type(self) -> Ty<'tcx> { self.types.u8 }\n }\n \n@@ -442,7 +442,7 @@ struct Case<'tcx> {\n /// This represents the (GEP) indices to follow to get to the discriminant field\n pub type DiscrField = Vec<usize>;\n \n-fn find_discr_field_candidate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx>,\n+fn find_discr_field_candidate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                         ty: Ty<'tcx>,\n                                         mut path: DiscrField)\n                                         -> Option<DiscrField> {\n@@ -545,7 +545,7 @@ impl<'tcx> Case<'tcx> {\n     }\n }\n \n-fn get_cases<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx>,\n+fn get_cases<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                        adt: ty::AdtDef<'tcx>,\n                        substs: &subst::Substs<'tcx>)\n                        -> Vec<Case<'tcx>> {\n@@ -669,7 +669,7 @@ fn bounds_usable(cx: &CrateContext, ity: IntType, bounds: &IntBounds) -> bool {\n     }\n }\n \n-pub fn ty_of_inttype<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx>, ity: IntType) -> Ty<'tcx> {\n+pub fn ty_of_inttype<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, ity: IntType) -> Ty<'tcx> {\n     match ity {\n         attr::SignedInt(t) => tcx.mk_mach_int(t),\n         attr::UnsignedInt(t) => tcx.mk_mach_uint(t)"}, {"sha": "00d9658cb59439a719b6c5b368679a0161392953", "filename": "src/librustc_trans/back/link.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc_trans%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc_trans%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flink.rs?ref=76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4", "patch": "@@ -124,7 +124,9 @@ pub fn find_crate_name(sess: Option<&Session>,\n \n }\n \n-pub fn build_link_meta(tcx: TyCtxt, name: &str) -> LinkMeta {\n+pub fn build_link_meta<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                 name: &str)\n+                                 -> LinkMeta {\n     let r = LinkMeta {\n         crate_name: name.to_owned(),\n         crate_hash: tcx.calculate_krate_hash(),"}, {"sha": "0cf82d66b2b682add653f9340e784bdf517739e8", "filename": "src/librustc_trans/back/symbol_names.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc_trans%2Fback%2Fsymbol_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc_trans%2Fback%2Fsymbol_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fsymbol_names.rs?ref=76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4", "patch": "@@ -111,12 +111,12 @@ use std::fmt::Write;\n use syntax::parse::token::{self, InternedString};\n use serialize::hex::ToHex;\n \n-pub fn def_id_to_string<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx>, def_id: DefId) -> String {\n+pub fn def_id_to_string<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> String {\n     let def_path = tcx.def_path(def_id);\n     def_path_to_string(tcx, &def_path)\n }\n \n-pub fn def_path_to_string<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx>, def_path: &DefPath) -> String {\n+pub fn def_path_to_string<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_path: &DefPath) -> String {\n     let mut s = String::with_capacity(def_path.data.len() * 16);\n \n     s.push_str(&tcx.crate_name(def_path.krate));"}, {"sha": "7665b730caddf940a6a73dbc7a6ae1b7640e97f1", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4", "patch": "@@ -1308,7 +1308,9 @@ impl<'v> Visitor<'v> for FindNestedReturn {\n     }\n }\n \n-fn build_cfg(tcx: TyCtxt, id: ast::NodeId) -> (ast::NodeId, Option<cfg::CFG>) {\n+fn build_cfg<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                       id: ast::NodeId)\n+                       -> (ast::NodeId, Option<cfg::CFG>) {\n     let blk = match tcx.map.find(id) {\n         Some(hir_map::NodeItem(i)) => {\n             match i.node {\n@@ -2688,7 +2690,7 @@ pub fn filter_reachable_ids(scx: &SharedCrateContext) -> NodeSet {\n     }).collect()\n }\n \n-pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx>,\n+pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                              mir_map: &MirMap<'tcx>,\n                              analysis: ty::CrateAnalysis)\n                              -> CrateTranslation {"}, {"sha": "0d012ba6391d2fe56aa27dad202aee1ed92c9ce0", "filename": "src/librustc_trans/callee.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc_trans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc_trans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcallee.rs?ref=76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4", "patch": "@@ -275,7 +275,7 @@ impl<'tcx> Callee<'tcx> {\n }\n \n /// Given a DefId and some Substs, produces the monomorphic item type.\n-fn def_ty<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx>,\n+fn def_ty<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                     def_id: DefId,\n                     substs: &'tcx subst::Substs<'tcx>)\n                     -> Ty<'tcx> {"}, {"sha": "c9a04ede6b15d14965a79e712e5346dca2dcf696", "filename": "src/librustc_trans/closure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc_trans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc_trans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fclosure.rs?ref=76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4", "patch": "@@ -119,7 +119,7 @@ impl ClosureEnv {\n     }\n }\n \n-fn get_self_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx>,\n+fn get_self_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                            closure_id: DefId,\n                            fn_ty: Ty<'tcx>)\n                            -> Ty<'tcx> {"}, {"sha": "14b7e5803a8c9ff671e92eb8d6d36a2be7139091", "filename": "src/librustc_trans/collector.rs", "status": "modified", "additions": 19, "deletions": 18, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc_trans%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc_trans%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcollector.rs?ref=76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4", "patch": "@@ -432,7 +432,7 @@ fn collect_items_rec<'a, 'tcx: 'a>(scx: &SharedCrateContext<'a, 'tcx>,\n     debug!(\"END collect_items_rec({})\", starting_point.to_string(scx.tcx()));\n }\n \n-fn record_references<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx>,\n+fn record_references<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                caller: TransItem<'tcx>,\n                                callees: &[TransItem<'tcx>],\n                                reference_map: &mut ReferenceMap<'tcx>) {\n@@ -445,7 +445,7 @@ fn record_references<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx>,\n     reference_map.record_references(caller, iter);\n }\n \n-fn check_recursion_limit<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx>,\n+fn check_recursion_limit<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                    instance: Instance<'tcx>,\n                                    recursion_depths: &mut DefIdMap<usize>)\n                                    -> (DefId, usize) {\n@@ -606,7 +606,7 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n \n         self.super_operand(operand);\n \n-        fn can_result_in_trans_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx>,\n+        fn can_result_in_trans_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                               def_id: DefId)\n                                               -> bool {\n             if !match tcx.lookup_item_type(def_id).ty.sty {\n@@ -635,7 +635,7 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n     }\n }\n \n-fn can_have_local_instance<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx>,\n+fn can_have_local_instance<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                      def_id: DefId)\n                                      -> bool {\n     // Take a look if we have the definition available. If not, we\n@@ -960,7 +960,7 @@ fn find_vtable_types_for_unsizing<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n     }\n }\n \n-fn create_fn_trans_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx>,\n+fn create_fn_trans_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                   def_id: DefId,\n                                   fn_substs: &Substs<'tcx>,\n                                   param_substs: &Substs<'tcx>)\n@@ -1146,7 +1146,7 @@ impl<'b, 'a, 'v> hir_visit::Visitor<'v> for RootCollector<'b, 'a, 'v> {\n     }\n }\n \n-fn create_trans_items_for_default_impls<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx>,\n+fn create_trans_items_for_default_impls<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                                   item: &'tcx hir::Item,\n                                                   output: &mut Vec<TransItem<'tcx>>) {\n     match item.node {\n@@ -1225,7 +1225,7 @@ fn create_trans_items_for_default_impls<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx>,\n \n /// Same as `unique_type_name()` but with the result pushed onto the given\n /// `output` parameter.\n-pub fn push_unique_type_name<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx>,\n+pub fn push_unique_type_name<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                        t: ty::Ty<'tcx>,\n                                        output: &mut String) {\n     match t.sty {\n@@ -1363,9 +1363,9 @@ pub fn push_unique_type_name<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx>,\n     }\n }\n \n-fn push_item_name(tcx: TyCtxt,\n-                  def_id: DefId,\n-                  output: &mut String) {\n+fn push_item_name<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                            def_id: DefId,\n+                            output: &mut String) {\n     let def_path = tcx.def_path(def_id);\n \n     // some_crate::\n@@ -1384,7 +1384,7 @@ fn push_item_name(tcx: TyCtxt,\n     output.pop();\n }\n \n-fn push_type_params<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx>,\n+fn push_type_params<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                               types: &'tcx subst::VecPerParamSpace<Ty<'tcx>>,\n                               projections: &[ty::PolyProjectionPredicate<'tcx>],\n                               output: &mut String) {\n@@ -1414,20 +1414,21 @@ fn push_type_params<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx>,\n     output.push('>');\n }\n \n-fn push_instance_as_string<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx>,\n+fn push_instance_as_string<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                      instance: Instance<'tcx>,\n                                      output: &mut String) {\n     push_item_name(tcx, instance.def, output);\n     push_type_params(tcx, &instance.substs.types, &[], output);\n }\n \n-pub fn def_id_to_string(tcx: TyCtxt, def_id: DefId) -> String {\n+pub fn def_id_to_string<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                  def_id: DefId) -> String {\n     let mut output = String::new();\n     push_item_name(tcx, def_id, &mut output);\n     output\n }\n \n-fn type_to_string<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx>,\n+fn type_to_string<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                             ty: ty::Ty<'tcx>)\n                             -> String {\n     let mut output = String::new();\n@@ -1436,7 +1437,7 @@ fn type_to_string<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx>,\n }\n \n impl<'a, 'tcx> TransItem<'tcx> {\n-    pub fn requests_inline(&self, tcx: TyCtxt<'a, 'tcx>) -> bool {\n+    pub fn requests_inline(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> bool {\n         match *self {\n             TransItem::Fn(ref instance) => {\n                 let attributes = tcx.get_attrs(instance.def);\n@@ -1463,7 +1464,7 @@ impl<'a, 'tcx> TransItem<'tcx> {\n         }\n     }\n \n-    pub fn explicit_linkage(&self, tcx: TyCtxt<'a, 'tcx>) -> Option<llvm::Linkage> {\n+    pub fn explicit_linkage(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Option<llvm::Linkage> {\n         let def_id = match *self {\n             TransItem::Fn(ref instance) => instance.def,\n             TransItem::Static(node_id) => tcx.map.local_def_id(node_id),\n@@ -1487,7 +1488,7 @@ impl<'a, 'tcx> TransItem<'tcx> {\n         }\n     }\n \n-    pub fn to_string(&self, tcx: TyCtxt<'a, 'tcx>) -> String {\n+    pub fn to_string(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> String {\n         let hir_map = &tcx.map;\n \n         return match *self {\n@@ -1510,7 +1511,7 @@ impl<'a, 'tcx> TransItem<'tcx> {\n             },\n         };\n \n-        fn to_string_internal<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx>,\n+        fn to_string_internal<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                         prefix: &str,\n                                         instance: Instance<'tcx>)\n                                         -> String {"}, {"sha": "a4728f40b310765b4bb96d27f3fc570abb5946d3", "filename": "src/librustc_trans/common.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc_trans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc_trans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcommon.rs?ref=76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4", "patch": "@@ -58,11 +58,11 @@ use syntax::parse::token;\n pub use context::{CrateContext, SharedCrateContext};\n \n /// Is the type's representation size known at compile time?\n-pub fn type_is_sized<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx>, ty: Ty<'tcx>) -> bool {\n+pub fn type_is_sized<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, ty: Ty<'tcx>) -> bool {\n     ty.is_sized(&tcx.empty_parameter_environment(), DUMMY_SP)\n }\n \n-pub fn type_is_fat_ptr<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx>, ty: Ty<'tcx>) -> bool {\n+pub fn type_is_fat_ptr<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, ty: Ty<'tcx>) -> bool {\n     match ty.sty {\n         ty::TyRawPtr(ty::TypeAndMut{ty, ..}) |\n         ty::TyRef(_, ty::TypeAndMut{ty, ..}) |\n@@ -165,7 +165,7 @@ pub struct VariantInfo<'tcx> {\n }\n \n impl<'a, 'tcx> VariantInfo<'tcx> {\n-    pub fn from_ty(tcx: TyCtxt<'a, 'tcx>,\n+    pub fn from_ty(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                    ty: Ty<'tcx>,\n                    opt_def: Option<Def>)\n                    -> Self\n@@ -201,7 +201,7 @@ impl<'a, 'tcx> VariantInfo<'tcx> {\n     }\n \n     /// Return the variant corresponding to a given node (e.g. expr)\n-    pub fn of_node(tcx: TyCtxt<'a, 'tcx>, ty: Ty<'tcx>, id: ast::NodeId) -> Self {\n+    pub fn of_node(tcx: TyCtxt<'a, 'tcx, 'tcx>, ty: Ty<'tcx>, id: ast::NodeId) -> Self {\n         let node_def = tcx.def_map.borrow().get(&id).map(|v| v.full_def());\n         Self::from_ty(tcx, ty, node_def)\n     }\n@@ -568,7 +568,7 @@ impl<'blk, 'tcx> BlockS<'blk, 'tcx> {\n     pub fn fcx(&self) -> &'blk FunctionContext<'blk, 'tcx> {\n         self.fcx\n     }\n-    pub fn tcx(&self) -> TyCtxt<'blk, 'tcx> {\n+    pub fn tcx(&self) -> TyCtxt<'blk, 'tcx, 'tcx> {\n         self.fcx.ccx.tcx()\n     }\n     pub fn sess(&self) -> &'blk Session { self.fcx.ccx.sess() }\n@@ -694,7 +694,7 @@ impl<'blk, 'tcx> BlockAndBuilder<'blk, 'tcx> {\n     pub fn fcx(&self) -> &'blk FunctionContext<'blk, 'tcx> {\n         self.bcx.fcx()\n     }\n-    pub fn tcx(&self) -> TyCtxt<'blk, 'tcx> {\n+    pub fn tcx(&self) -> TyCtxt<'blk, 'tcx, 'tcx> {\n         self.bcx.tcx()\n     }\n     pub fn sess(&self) -> &'blk Session {\n@@ -1119,7 +1119,7 @@ pub fn fulfill_obligation<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n /// returns false, then either normalize encountered an error or one\n /// of the predicates did not hold. Used when creating vtables to\n /// check for unsatisfiable methods.\n-pub fn normalize_and_test_predicates<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx>,\n+pub fn normalize_and_test_predicates<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                                predicates: Vec<ty::Predicate<'tcx>>)\n                                                -> bool\n {"}, {"sha": "61137d7f377c295ca1d88c606d550d73514360d5", "filename": "src/librustc_trans/context.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc_trans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc_trans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcontext.rs?ref=76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4", "patch": "@@ -73,7 +73,7 @@ pub struct SharedCrateContext<'a, 'tcx: 'a> {\n     item_symbols: RefCell<NodeMap<String>>,\n     link_meta: LinkMeta,\n     symbol_hasher: RefCell<Sha256>,\n-    tcx: TyCtxt<'a, 'tcx>,\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     stats: Stats,\n     check_overflow: bool,\n     check_drop_flag_for_sanity: bool,\n@@ -331,7 +331,7 @@ unsafe fn create_context_and_module(sess: &Session, mod_name: &str) -> (ContextR\n }\n \n impl<'b, 'tcx> SharedCrateContext<'b, 'tcx> {\n-    pub fn new(tcx: TyCtxt<'b, 'tcx>,\n+    pub fn new(tcx: TyCtxt<'b, 'tcx, 'tcx>,\n                mir_map: &'b MirMap<'tcx>,\n                export_map: ExportMap,\n                symbol_hasher: Sha256,\n@@ -450,7 +450,7 @@ impl<'b, 'tcx> SharedCrateContext<'b, 'tcx> {\n         &self.link_meta\n     }\n \n-    pub fn tcx<'a>(&'a self) -> TyCtxt<'a, 'tcx> {\n+    pub fn tcx<'a>(&'a self) -> TyCtxt<'a, 'tcx, 'tcx> {\n         self.tcx\n     }\n \n@@ -640,7 +640,7 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n         }\n     }\n \n-    pub fn tcx<'a>(&'a self) -> TyCtxt<'a, 'tcx> {\n+    pub fn tcx<'a>(&'a self) -> TyCtxt<'a, 'tcx, 'tcx> {\n         self.shared.tcx\n     }\n "}, {"sha": "03a3e753d82d39e9415e457e08b4629dfa58d156", "filename": "src/librustc_trans/expr.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc_trans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc_trans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fexpr.rs?ref=76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4", "patch": "@@ -722,7 +722,7 @@ fn trans_field<'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n                               base: &hir::Expr,\n                               get_idx: F)\n                               -> DatumBlock<'blk, 'tcx, Expr> where\n-    F: FnOnce(TyCtxt<'blk, 'tcx>, &VariantInfo<'tcx>) -> usize,\n+    F: FnOnce(TyCtxt<'blk, 'tcx, 'tcx>, &VariantInfo<'tcx>) -> usize,\n {\n     let mut bcx = bcx;\n     let _icx = push_ctxt(\"trans_rec_field\");\n@@ -1826,7 +1826,7 @@ fn trans_binary<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     }\n }\n \n-pub fn cast_is_noop<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx>,\n+pub fn cast_is_noop<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                               expr: &hir::Expr,\n                               t_in: Ty<'tcx>,\n                               t_out: Ty<'tcx>)\n@@ -2377,7 +2377,7 @@ enum ExprKind {\n     RvalueStmt\n }\n \n-fn expr_kind(tcx: TyCtxt, expr: &hir::Expr) -> ExprKind {\n+fn expr_kind<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, expr: &hir::Expr) -> ExprKind {\n     if tcx.is_method_call(expr.id) {\n         // Overloaded operations are generally calls, and hence they are\n         // generated via DPS, but there are a few exceptions:"}, {"sha": "4574c590a6279231408d8738aaa772e245ee3f36", "filename": "src/librustc_trans/glue.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc_trans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc_trans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fglue.rs?ref=76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4", "patch": "@@ -89,11 +89,12 @@ pub fn trans_exchange_free_ty<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     }\n }\n \n-pub fn type_needs_drop<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx>, ty: Ty<'tcx>) -> bool {\n+pub fn type_needs_drop<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                 ty: Ty<'tcx>) -> bool {\n     tcx.type_needs_drop_given_env(ty, &tcx.empty_parameter_environment())\n }\n \n-pub fn get_drop_glue_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx>,\n+pub fn get_drop_glue_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                     t: Ty<'tcx>) -> Ty<'tcx> {\n     // Even if there is no dtor for t, there might be one deeper down and we\n     // might need to pass in the vtable ptr."}, {"sha": "231c301503ece62160d493ffa6b72ff06fda214a", "filename": "src/librustc_trans/meth.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc_trans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc_trans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmeth.rs?ref=76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4", "patch": "@@ -215,7 +215,7 @@ pub fn get_vtable<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     vtable\n }\n \n-pub fn get_vtable_methods<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx>,\n+pub fn get_vtable_methods<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                     impl_id: DefId,\n                                     substs: &'tcx subst::Substs<'tcx>)\n                                     -> Vec<Option<ImplMethod<'tcx>>>\n@@ -304,7 +304,7 @@ pub struct ImplMethod<'tcx> {\n }\n \n /// Locates the applicable definition of a method, given its name.\n-pub fn get_impl_method<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx>,\n+pub fn get_impl_method<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                  impl_def_id: DefId,\n                                  substs: &'tcx Substs<'tcx>,\n                                  name: Name)"}, {"sha": "7c3feba5de74baa384528caad27c74940d53a8b3", "filename": "src/librustc_trans/monomorphize.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc_trans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc_trans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmonomorphize.rs?ref=76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4", "patch": "@@ -182,14 +182,14 @@ impl<'tcx> Instance<'tcx> {\n         assert!(substs.regions.iter().all(|&r| r == ty::ReStatic));\n         Instance { def: def_id, substs: substs }\n     }\n-    pub fn mono<'a>(tcx: TyCtxt<'a, 'tcx>, def_id: DefId) -> Instance<'tcx> {\n+    pub fn mono<'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> Instance<'tcx> {\n         Instance::new(def_id, tcx.mk_substs(Substs::empty()))\n     }\n }\n \n /// Monomorphizes a type from the AST by first applying the in-scope\n /// substitutions and then normalizing any associated types.\n-pub fn apply_param_substs<'a, 'tcx, T>(tcx: TyCtxt<'a, 'tcx>,\n+pub fn apply_param_substs<'a, 'tcx, T>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                        param_substs: &Substs<'tcx>,\n                                        value: &T)\n                                        -> T\n@@ -201,7 +201,7 @@ pub fn apply_param_substs<'a, 'tcx, T>(tcx: TyCtxt<'a, 'tcx>,\n \n \n /// Returns the normalized type of a struct field\n-pub fn field_ty<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx>,\n+pub fn field_ty<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                           param_substs: &Substs<'tcx>,\n                           f: ty::FieldDef<'tcx>)\n                           -> Ty<'tcx>"}, {"sha": "18a860f9357b906005467f2e5b4d9f9cf2d7997b", "filename": "src/librustc_trans/partitioning.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc_trans%2Fpartitioning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc_trans%2Fpartitioning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fpartitioning.rs?ref=76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4", "patch": "@@ -153,7 +153,7 @@ pub enum PartitioningStrategy {\n // Anything we can't find a proper codegen unit for goes into this.\n const FALLBACK_CODEGEN_UNIT: &'static str = \"__rustc_fallback_codegen_unit\";\n \n-pub fn partition<'a, 'tcx, I>(tcx: TyCtxt<'a, 'tcx>,\n+pub fn partition<'a, 'tcx, I>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                               trans_items: I,\n                               strategy: PartitioningStrategy,\n                               reference_map: &ReferenceMap<'tcx>)\n@@ -193,7 +193,7 @@ struct PreInliningPartitioning<'tcx> {\n struct PostInliningPartitioning<'tcx>(Vec<CodegenUnit<'tcx>>);\n struct PostDeclarationsPartitioning<'tcx>(Vec<CodegenUnit<'tcx>>);\n \n-fn place_root_translation_items<'a, 'tcx, I>(tcx: TyCtxt<'a, 'tcx>,\n+fn place_root_translation_items<'a, 'tcx, I>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                              trans_items: I)\n                                              -> PreInliningPartitioning<'tcx>\n     where I: Iterator<Item = TransItem<'tcx>>\n@@ -375,7 +375,7 @@ fn place_declarations<'tcx>(codegen_units: PostInliningPartitioning<'tcx>,\n     PostDeclarationsPartitioning(codegen_units)\n }\n \n-fn characteristic_def_id_of_trans_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx>,\n+fn characteristic_def_id_of_trans_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                                  trans_item: TransItem<'tcx>)\n                                                  -> Option<DefId> {\n     match trans_item {\n@@ -410,7 +410,7 @@ fn characteristic_def_id_of_trans_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx>,\n     }\n }\n \n-fn compute_codegen_unit_name<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx>,\n+fn compute_codegen_unit_name<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                        def_id: DefId,\n                                        volatile: bool)\n                                        -> InternedString {"}, {"sha": "dcb40b0b418d4c36b4147bc1cd5d8be4a42fd20a", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 53, "deletions": 66, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4", "patch": "@@ -78,8 +78,8 @@ use rustc::hir::print as pprust;\n use rustc::hir;\n use rustc_back::slice;\n \n-pub trait AstConv<'tcx> {\n-    fn tcx<'a>(&'a self) -> TyCtxt<'a, 'tcx>;\n+pub trait AstConv<'gcx, 'tcx> {\n+    fn tcx<'a>(&'a self) -> TyCtxt<'a, 'gcx, 'tcx>;\n \n     /// Identify the type scheme for an item with a type, like a type\n     /// alias, fn, or struct. This allows you to figure out the set of\n@@ -112,16 +112,14 @@ pub trait AstConv<'tcx> {\n     /// are in scope into free ones. This function should only return Some\n     /// within a fn body.\n     /// See ParameterEnvironment::free_substs for more information.\n-    fn get_free_substs(&self) -> Option<&Substs<'tcx>> {\n-        None\n-    }\n+    fn get_free_substs(&self) -> Option<&Substs<'tcx>>;\n \n     /// What type should we use when a type is omitted?\n-        fn ty_infer(&self,\n-                    param_and_substs: Option<ty::TypeParameterDef<'tcx>>,\n-                    substs: Option<&mut Substs<'tcx>>,\n-                    space: Option<ParamSpace>,\n-                    span: Span) -> Ty<'tcx>;\n+    fn ty_infer(&self,\n+                param_and_substs: Option<ty::TypeParameterDef<'tcx>>,\n+                substs: Option<&mut Substs<'tcx>>,\n+                space: Option<ParamSpace>,\n+                span: Span) -> Ty<'tcx>;\n \n     /// Projecting an associated type from a (potentially)\n     /// higher-ranked trait reference is more complicated, because of\n@@ -134,18 +132,7 @@ pub trait AstConv<'tcx> {\n                                         span: Span,\n                                         poly_trait_ref: ty::PolyTraitRef<'tcx>,\n                                         item_name: ast::Name)\n-                                        -> Ty<'tcx>\n-    {\n-        if let Some(trait_ref) = self.tcx().no_late_bound_regions(&poly_trait_ref) {\n-            self.projected_ty(span, trait_ref, item_name)\n-        } else {\n-            // no late-bound regions, we can just ignore the binder\n-            span_err!(self.tcx().sess, span, E0212,\n-                \"cannot extract an associated type from a higher-ranked trait bound \\\n-                 in this context\");\n-            self.tcx().types.err\n-        }\n-    }\n+                                        -> Ty<'tcx>;\n \n     /// Project an associated type from a non-higher-ranked trait reference.\n     /// This is fairly straightforward and can be accommodated in any context.\n@@ -268,7 +255,7 @@ fn report_elision_failure(\n }\n \n pub fn opt_ast_region_to_region<'tcx>(\n-    this: &AstConv<'tcx>,\n+    this: &AstConv<'tcx, 'tcx>,\n     rscope: &RegionScope,\n     default_span: Span,\n     opt_lifetime: &Option<hir::Lifetime>) -> ty::Region\n@@ -302,7 +289,7 @@ pub fn opt_ast_region_to_region<'tcx>(\n /// Given a path `path` that refers to an item `I` with the declared generics `decl_generics`,\n /// returns an appropriate set of substitutions for this particular reference to `I`.\n pub fn ast_path_substs_for_ty<'tcx>(\n-    this: &AstConv<'tcx>,\n+    this: &AstConv<'tcx, 'tcx>,\n     rscope: &RegionScope,\n     span: Span,\n     param_mode: PathParamMode,\n@@ -357,7 +344,7 @@ pub enum PathParamMode {\n }\n \n fn create_region_substs<'tcx>(\n-    this: &AstConv<'tcx>,\n+    this: &AstConv<'tcx, 'tcx>,\n     rscope: &RegionScope,\n     span: Span,\n     decl_generics: &ty::Generics<'tcx>,\n@@ -401,7 +388,7 @@ fn create_region_substs<'tcx>(\n /// -- that is, a substitution with no types but the correct number of\n /// regions.\n fn create_substs_for_ast_path<'tcx>(\n-    this: &AstConv<'tcx>,\n+    this: &AstConv<'tcx, 'tcx>,\n     span: Span,\n     param_mode: PathParamMode,\n     decl_generics: &ty::Generics<'tcx>,\n@@ -502,7 +489,7 @@ fn create_substs_for_ast_path<'tcx>(\n \n /// Returns types_provided if it is not empty, otherwise populating the\n /// type parameters with inference variables as appropriate.\n-fn get_type_substs_for_defs<'tcx>(this: &AstConv<'tcx>,\n+fn get_type_substs_for_defs<'tcx>(this: &AstConv<'tcx, 'tcx>,\n                                   span: Span,\n                                   types_provided: Vec<Ty<'tcx>>,\n                                   param_mode: PathParamMode,\n@@ -542,7 +529,7 @@ struct ConvertedBinding<'tcx> {\n     span: Span,\n }\n \n-fn convert_angle_bracketed_parameters<'tcx>(this: &AstConv<'tcx>,\n+fn convert_angle_bracketed_parameters<'tcx>(this: &AstConv<'tcx, 'tcx>,\n                                             rscope: &RegionScope,\n                                             span: Span,\n                                             decl_generics: &ty::Generics<'tcx>,\n@@ -579,7 +566,7 @@ fn convert_angle_bracketed_parameters<'tcx>(this: &AstConv<'tcx>,\n /// Returns the appropriate lifetime to use for any output lifetimes\n /// (if one exists) and a vector of the (pattern, number of lifetimes)\n /// corresponding to each input type/pattern.\n-fn find_implied_output_region<'tcx>(this: &AstConv<'tcx>,\n+fn find_implied_output_region<'tcx>(this: &AstConv<'tcx, 'tcx>,\n                                     input_tys: &[Ty<'tcx>],\n                                     input_pats: Vec<String>) -> ElidedLifetime\n {\n@@ -615,7 +602,7 @@ fn find_implied_output_region<'tcx>(this: &AstConv<'tcx>,\n     }\n }\n \n-fn convert_ty_with_lifetime_elision<'tcx>(this: &AstConv<'tcx>,\n+fn convert_ty_with_lifetime_elision<'tcx>(this: &AstConv<'tcx, 'tcx>,\n                                           elided_lifetime: ElidedLifetime,\n                                           ty: &hir::Ty)\n                                           -> Ty<'tcx>\n@@ -635,7 +622,7 @@ fn convert_ty_with_lifetime_elision<'tcx>(this: &AstConv<'tcx>,\n     }\n }\n \n-fn convert_parenthesized_parameters<'tcx>(this: &AstConv<'tcx>,\n+fn convert_parenthesized_parameters<'tcx>(this: &AstConv<'tcx, 'tcx>,\n                                           rscope: &RegionScope,\n                                           span: Span,\n                                           decl_generics: &ty::Generics<'tcx>,\n@@ -681,7 +668,7 @@ fn convert_parenthesized_parameters<'tcx>(this: &AstConv<'tcx>,\n }\n \n pub fn instantiate_poly_trait_ref<'tcx>(\n-    this: &AstConv<'tcx>,\n+    this: &AstConv<'tcx, 'tcx>,\n     rscope: &RegionScope,\n     ast_trait_ref: &hir::PolyTraitRef,\n     self_ty: Option<Ty<'tcx>>,\n@@ -707,7 +694,7 @@ pub fn instantiate_poly_trait_ref<'tcx>(\n /// If the `projections` argument is `None`, then assoc type bindings like `Foo<T=X>`\n /// are disallowed. Otherwise, they are pushed onto the vector given.\n pub fn instantiate_mono_trait_ref<'tcx>(\n-    this: &AstConv<'tcx>,\n+    this: &AstConv<'tcx, 'tcx>,\n     rscope: &RegionScope,\n     trait_ref: &hir::TraitRef,\n     self_ty: Option<Ty<'tcx>>)\n@@ -723,7 +710,7 @@ pub fn instantiate_mono_trait_ref<'tcx>(\n                                trait_ref.path.segments.last().unwrap())\n }\n \n-fn trait_def_id<'tcx>(this: &AstConv<'tcx>, trait_ref: &hir::TraitRef) -> DefId {\n+fn trait_def_id<'tcx>(this: &AstConv<'tcx, 'tcx>, trait_ref: &hir::TraitRef) -> DefId {\n     let path = &trait_ref.path;\n     match ::lookup_full_def(this.tcx(), path.span, trait_ref.ref_id) {\n         Def::Trait(trait_def_id) => trait_def_id,\n@@ -738,7 +725,7 @@ fn trait_def_id<'tcx>(this: &AstConv<'tcx>, trait_ref: &hir::TraitRef) -> DefId\n }\n \n fn object_path_to_poly_trait_ref<'a,'tcx>(\n-    this: &AstConv<'tcx>,\n+    this: &AstConv<'tcx, 'tcx>,\n     rscope: &RegionScope,\n     span: Span,\n     param_mode: PathParamMode,\n@@ -758,7 +745,7 @@ fn object_path_to_poly_trait_ref<'a,'tcx>(\n }\n \n fn ast_path_to_poly_trait_ref<'a,'tcx>(\n-    this: &AstConv<'tcx>,\n+    this: &AstConv<'tcx, 'tcx>,\n     rscope: &RegionScope,\n     span: Span,\n     param_mode: PathParamMode,\n@@ -807,7 +794,7 @@ fn ast_path_to_poly_trait_ref<'a,'tcx>(\n     poly_trait_ref\n }\n \n-fn ast_path_to_mono_trait_ref<'a,'tcx>(this: &AstConv<'tcx>,\n+fn ast_path_to_mono_trait_ref<'a,'tcx>(this: &AstConv<'tcx, 'tcx>,\n                                        rscope: &RegionScope,\n                                        span: Span,\n                                        param_mode: PathParamMode,\n@@ -828,7 +815,7 @@ fn ast_path_to_mono_trait_ref<'a,'tcx>(this: &AstConv<'tcx>,\n     ty::TraitRef::new(trait_def_id, substs)\n }\n \n-fn create_substs_for_ast_trait_ref<'a,'tcx>(this: &AstConv<'tcx>,\n+fn create_substs_for_ast_trait_ref<'a,'tcx>(this: &AstConv<'tcx, 'tcx>,\n                                             rscope: &RegionScope,\n                                             span: Span,\n                                             param_mode: PathParamMode,\n@@ -889,7 +876,7 @@ fn create_substs_for_ast_trait_ref<'a,'tcx>(this: &AstConv<'tcx>,\n }\n \n fn ast_type_binding_to_poly_projection_predicate<'tcx>(\n-    this: &AstConv<'tcx>,\n+    this: &AstConv<'tcx, 'tcx>,\n     mut trait_ref: ty::PolyTraitRef<'tcx>,\n     self_ty: Option<Ty<'tcx>>,\n     binding: &ConvertedBinding<'tcx>)\n@@ -976,7 +963,7 @@ fn ast_type_binding_to_poly_projection_predicate<'tcx>(\n }\n \n fn ast_path_to_ty<'tcx>(\n-    this: &AstConv<'tcx>,\n+    this: &AstConv<'tcx, 'tcx>,\n     rscope: &RegionScope,\n     span: Span,\n     param_mode: PathParamMode,\n@@ -1012,7 +999,7 @@ fn ast_path_to_ty<'tcx>(\n \n type TraitAndProjections<'tcx> = (ty::PolyTraitRef<'tcx>, Vec<ty::PolyProjectionPredicate<'tcx>>);\n \n-fn ast_ty_to_trait_ref<'tcx>(this: &AstConv<'tcx>,\n+fn ast_ty_to_trait_ref<'tcx>(this: &AstConv<'tcx, 'tcx>,\n                              rscope: &RegionScope,\n                              ty: &hir::Ty,\n                              bounds: &[hir::TyParamBound])\n@@ -1096,7 +1083,7 @@ fn ast_ty_to_trait_ref<'tcx>(this: &AstConv<'tcx>,\n     }\n }\n \n-fn trait_ref_to_object_type<'tcx>(this: &AstConv<'tcx>,\n+fn trait_ref_to_object_type<'tcx>(this: &AstConv<'tcx, 'tcx>,\n                                   rscope: &RegionScope,\n                                   span: Span,\n                                   trait_ref: ty::PolyTraitRef<'tcx>,\n@@ -1118,7 +1105,7 @@ fn trait_ref_to_object_type<'tcx>(this: &AstConv<'tcx>,\n     result\n }\n \n-fn make_object_type<'tcx>(this: &AstConv<'tcx>,\n+fn make_object_type<'tcx>(this: &AstConv<'tcx, 'tcx>,\n                           span: Span,\n                           principal: ty::PolyTraitRef<'tcx>,\n                           bounds: ty::ExistentialBounds<'tcx>)\n@@ -1191,7 +1178,7 @@ fn report_ambiguous_associated_type(tcx: TyCtxt,\n // (which might be `Self`, but only if it is the `Self` of a trait, not an\n // impl). This function will fail if there are no suitable bounds or there is\n // any ambiguity.\n-fn find_bound_for_assoc_item<'tcx>(this: &AstConv<'tcx>,\n+fn find_bound_for_assoc_item<'tcx>(this: &AstConv<'tcx, 'tcx>,\n                                    ty_param_node_id: ast::NodeId,\n                                    ty_param_name: ast::Name,\n                                    assoc_name: ast::Name,\n@@ -1229,7 +1216,7 @@ fn find_bound_for_assoc_item<'tcx>(this: &AstConv<'tcx>,\n \n // Checks that bounds contains exactly one element and reports appropriate\n // errors otherwise.\n-fn one_bound_for_assoc_type<'tcx>(this: &AstConv<'tcx>,\n+fn one_bound_for_assoc_type<'tcx>(this: &AstConv<'tcx, 'tcx>,\n                                   bounds: Vec<ty::PolyTraitRef<'tcx>>,\n                                   ty_param_name: &str,\n                                   assoc_name: &str,\n@@ -1268,7 +1255,7 @@ fn one_bound_for_assoc_type<'tcx>(this: &AstConv<'tcx>,\n // the whole path.\n // Will fail except for T::A and Self::A; i.e., if ty/ty_path_def are not a type\n // parameter or Self.\n-fn associated_path_def_to_ty<'tcx>(this: &AstConv<'tcx>,\n+fn associated_path_def_to_ty<'tcx>(this: &AstConv<'tcx, 'tcx>,\n                                    span: Span,\n                                    ty: Ty<'tcx>,\n                                    ty_path_def: Def,\n@@ -1370,7 +1357,7 @@ fn associated_path_def_to_ty<'tcx>(this: &AstConv<'tcx>,\n     (ty, Def::AssociatedTy(trait_did, item_did))\n }\n \n-fn qpath_to_ty<'tcx>(this: &AstConv<'tcx>,\n+fn qpath_to_ty<'tcx>(this: &AstConv<'tcx, 'tcx>,\n                      rscope: &RegionScope,\n                      span: Span,\n                      param_mode: PathParamMode,\n@@ -1425,7 +1412,7 @@ fn qpath_to_ty<'tcx>(this: &AstConv<'tcx>,\n /// * `region_substs`: a partial substitution consisting of\n ///   only the region type parameters being supplied to this type.\n /// * `ast_ty`: the ast representation of the type being supplied\n-pub fn ast_ty_arg_to_ty<'tcx>(this: &AstConv<'tcx>,\n+pub fn ast_ty_arg_to_ty<'tcx>(this: &AstConv<'tcx, 'tcx>,\n                               rscope: &RegionScope,\n                               decl_generics: &ty::Generics<'tcx>,\n                               index: usize,\n@@ -1447,7 +1434,7 @@ pub fn ast_ty_arg_to_ty<'tcx>(this: &AstConv<'tcx>,\n // Check the base def in a PathResolution and convert it to a Ty. If there are\n // associated types in the PathResolution, these will need to be separately\n // resolved.\n-fn base_def_to_ty<'tcx>(this: &AstConv<'tcx>,\n+fn base_def_to_ty<'tcx>(this: &AstConv<'tcx, 'tcx>,\n                         rscope: &RegionScope,\n                         span: Span,\n                         param_mode: PathParamMode,\n@@ -1552,7 +1539,7 @@ fn base_def_to_ty<'tcx>(this: &AstConv<'tcx>,\n \n // Note that both base_segments and assoc_segments may be empty, although not at\n // the same time.\n-pub fn finish_resolving_def_to_ty<'tcx>(this: &AstConv<'tcx>,\n+pub fn finish_resolving_def_to_ty<'tcx>(this: &AstConv<'tcx, 'tcx>,\n                                         rscope: &RegionScope,\n                                         span: Span,\n                                         param_mode: PathParamMode,\n@@ -1588,7 +1575,7 @@ pub fn finish_resolving_def_to_ty<'tcx>(this: &AstConv<'tcx>,\n \n /// Parses the programmer's textual representation of a type into our\n /// internal notion of a type.\n-pub fn ast_ty_to_ty<'tcx>(this: &AstConv<'tcx>,\n+pub fn ast_ty_to_ty<'tcx>(this: &AstConv<'tcx, 'tcx>,\n                           rscope: &RegionScope,\n                           ast_ty: &hir::Ty)\n                           -> Ty<'tcx>\n@@ -1734,7 +1721,7 @@ pub fn ast_ty_to_ty<'tcx>(this: &AstConv<'tcx>,\n     return typ;\n }\n \n-pub fn ty_of_arg<'tcx>(this: &AstConv<'tcx>,\n+pub fn ty_of_arg<'tcx>(this: &AstConv<'tcx, 'tcx>,\n                        rscope: &RegionScope,\n                        a: &hir::Arg,\n                        expected_ty: Option<Ty<'tcx>>)\n@@ -1752,7 +1739,7 @@ struct SelfInfo<'a, 'tcx> {\n     explicit_self: &'a hir::ExplicitSelf,\n }\n \n-pub fn ty_of_method<'tcx>(this: &AstConv<'tcx>,\n+pub fn ty_of_method<'tcx>(this: &AstConv<'tcx, 'tcx>,\n                           sig: &hir::MethodSig,\n                           untransformed_self_ty: Ty<'tcx>)\n                           -> (ty::BareFnTy<'tcx>, ty::ExplicitSelfCategory) {\n@@ -1769,13 +1756,13 @@ pub fn ty_of_method<'tcx>(this: &AstConv<'tcx>,\n     (bare_fn_ty, optional_explicit_self_category.unwrap())\n }\n \n-pub fn ty_of_bare_fn<'tcx>(this: &AstConv<'tcx>, unsafety: hir::Unsafety, abi: abi::Abi,\n+pub fn ty_of_bare_fn<'tcx>(this: &AstConv<'tcx, 'tcx>, unsafety: hir::Unsafety, abi: abi::Abi,\n                                               decl: &hir::FnDecl) -> ty::BareFnTy<'tcx> {\n     let (bare_fn_ty, _) = ty_of_method_or_bare_fn(this, unsafety, abi, None, decl);\n     bare_fn_ty\n }\n \n-fn ty_of_method_or_bare_fn<'a, 'tcx>(this: &AstConv<'tcx>,\n+fn ty_of_method_or_bare_fn<'a, 'tcx>(this: &AstConv<'tcx, 'tcx>,\n                                      unsafety: hir::Unsafety,\n                                      abi: abi::Abi,\n                                      opt_self_info: Option<SelfInfo<'a, 'tcx>>,\n@@ -1837,7 +1824,7 @@ fn ty_of_method_or_bare_fn<'a, 'tcx>(this: &AstConv<'tcx>,\n     }, explicit_self_category)\n }\n \n-fn determine_self_type<'a, 'tcx>(this: &AstConv<'tcx>,\n+fn determine_self_type<'a, 'tcx>(this: &AstConv<'tcx, 'tcx>,\n                                  rscope: &RegionScope,\n                                  self_info: SelfInfo<'a, 'tcx>)\n                                  -> (Option<Ty<'tcx>>, Option<ty::ExplicitSelfCategory>)\n@@ -1929,7 +1916,7 @@ fn determine_self_type<'a, 'tcx>(this: &AstConv<'tcx>,\n }\n \n pub fn ty_of_closure<'tcx>(\n-    this: &AstConv<'tcx>,\n+    this: &AstConv<'tcx, 'tcx>,\n     unsafety: hir::Unsafety,\n     decl: &hir::FnDecl,\n     abi: abi::Abi,\n@@ -1992,7 +1979,7 @@ pub fn ty_of_closure<'tcx>(\n /// for closures. Eventually this should all be normalized, I think, so that there is no \"main\n /// trait ref\" and instead we just have a flat list of bounds as the existential type.\n fn conv_existential_bounds<'tcx>(\n-    this: &AstConv<'tcx>,\n+    this: &AstConv<'tcx, 'tcx>,\n     rscope: &RegionScope,\n     span: Span,\n     principal_trait_ref: ty::PolyTraitRef<'tcx>,\n@@ -2008,7 +1995,7 @@ fn conv_existential_bounds<'tcx>(\n }\n \n fn conv_ty_poly_trait_ref<'tcx>(\n-    this: &AstConv<'tcx>,\n+    this: &AstConv<'tcx, 'tcx>,\n     rscope: &RegionScope,\n     span: Span,\n     ast_bounds: &[hir::TyParamBound])\n@@ -2042,7 +2029,7 @@ fn conv_ty_poly_trait_ref<'tcx>(\n }\n \n pub fn conv_existential_bounds_from_partitioned_bounds<'tcx>(\n-    this: &AstConv<'tcx>,\n+    this: &AstConv<'tcx, 'tcx>,\n     rscope: &RegionScope,\n     span: Span,\n     principal_trait_ref: ty::PolyTraitRef<'tcx>,\n@@ -2093,7 +2080,7 @@ pub fn conv_existential_bounds_from_partitioned_bounds<'tcx>(\n /// user provided, if they provided one, and otherwise search the supertypes of trait bounds for\n /// region bounds. It may be that we can derive no bound at all, in which case we return `None`.\n fn compute_object_lifetime_bound<'tcx>(\n-    this: &AstConv<'tcx>,\n+    this: &AstConv<'tcx, 'tcx>,\n     span: Span,\n     explicit_region_bounds: &[&hir::Lifetime],\n     principal_trait_ref: ty::PolyTraitRef<'tcx>,\n@@ -2159,10 +2146,10 @@ pub struct PartitionedBounds<'a> {\n \n /// Divides a list of bounds from the AST into three groups: builtin bounds (Copy, Sized etc),\n /// general trait bounds, and region bounds.\n-pub fn partition_bounds<'a>(tcx: TyCtxt,\n-                            _span: Span,\n-                            ast_bounds: &'a [hir::TyParamBound])\n-                            -> PartitionedBounds<'a>\n+pub fn partition_bounds<'a, 'b, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                      _span: Span,\n+                                      ast_bounds: &'b [hir::TyParamBound])\n+                                      -> PartitionedBounds<'b>\n {\n     let mut builtin_bounds = ty::BuiltinBounds::empty();\n     let mut region_bounds = Vec::new();\n@@ -2250,7 +2237,7 @@ pub struct Bounds<'tcx> {\n }\n \n impl<'a, 'tcx> Bounds<'tcx> {\n-    pub fn predicates(&self, tcx: TyCtxt<'a, 'tcx>, param_ty: Ty<'tcx>)\n+    pub fn predicates(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, param_ty: Ty<'tcx>)\n                       -> Vec<ty::Predicate<'tcx>>\n     {\n         let mut vec = Vec::new();"}, {"sha": "537f1e33c36697e5fe44ef6e34b14be9c13cad7b", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4", "patch": "@@ -30,13 +30,13 @@ use syntax::ptr::P;\n use rustc::hir::{self, PatKind};\n use rustc::hir::print as pprust;\n \n-pub struct PatCtxt<'a, 'tcx: 'a> {\n-    pub fcx: &'a FnCtxt<'a, 'tcx>,\n+pub struct PatCtxt<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n+    pub fcx: &'a FnCtxt<'a, 'gcx, 'tcx>,\n     pub map: PatIdMap,\n }\n \n-impl<'a, 'tcx> Deref for PatCtxt<'a, 'tcx> {\n-    type Target = FnCtxt<'a, 'tcx>;\n+impl<'a, 'gcx, 'tcx> Deref for PatCtxt<'a, 'gcx, 'tcx> {\n+    type Target = FnCtxt<'a, 'gcx, 'tcx>;\n     fn deref(&self) -> &Self::Target {\n         self.fcx\n     }\n@@ -56,7 +56,7 @@ fn bad_struct_kind_err(sess: &Session, pat: &hir::Pat, path: &hir::Path, lint: b\n     }\n }\n \n-impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n+impl<'a, 'tcx> PatCtxt<'a, 'tcx, 'tcx> {\n pub fn check_pat(&self, pat: &'tcx hir::Pat, expected: Ty<'tcx>) {\n     let tcx = self.tcx();\n \n@@ -456,7 +456,7 @@ pub fn check_dereferencable(&self, span: Span, expected: Ty<'tcx>, inner: &hir::\n }\n }\n \n-impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n+impl<'a, 'tcx> FnCtxt<'a, 'tcx, 'tcx> {\n pub fn check_match(&self,\n                    expr: &'tcx hir::Expr,\n                    discrim: &'tcx hir::Expr,\n@@ -579,7 +579,7 @@ pub fn check_match(&self,\n }\n }\n \n-impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n+impl<'a, 'tcx> PatCtxt<'a, 'tcx, 'tcx> {\n pub fn check_pat_struct(&self, pat: &'tcx hir::Pat,\n                         path: &hir::Path, fields: &'tcx [Spanned<hir::FieldPat>],\n                         etc: bool, expected: Ty<'tcx>) {"}, {"sha": "fbc5a0b33aa2e801eef395391c9f871ecb89deb5", "filename": "src/librustc_typeck/check/assoc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc_typeck%2Fcheck%2Fassoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc_typeck%2Fcheck%2Fassoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fassoc.rs?ref=76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4", "patch": "@@ -16,7 +16,7 @@ use syntax::ast;\n use syntax::codemap::Span;\n \n //FIXME(@jroesch): Ideally we should be able to drop the fulfillment_cx argument.\n-pub fn normalize_associated_types_in<'a,'tcx,T>(infcx: &InferCtxt<'a,'tcx>,\n+pub fn normalize_associated_types_in<'a,'tcx,T>(infcx: &InferCtxt<'a,'tcx, 'tcx>,\n                                                 fulfillment_cx: &mut FulfillmentContext<'tcx>,\n                                                 span: Span,\n                                                 body_id: ast::NodeId,"}, {"sha": "f46e6204ea48dacca16afb8bf074230f2dd2aad3", "filename": "src/librustc_typeck/check/callee.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs?ref=76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4", "patch": "@@ -63,7 +63,7 @@ enum CallStep<'tcx> {\n     Overloaded(ty::MethodCallee<'tcx>)\n }\n \n-impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n+impl<'a, 'tcx> FnCtxt<'a, 'tcx, 'tcx> {\n pub fn check_call(&self,\n                   call_expr: &'tcx hir::Expr,\n                   callee_expr: &'tcx hir::Expr,\n@@ -338,7 +338,7 @@ struct CallResolution<'tcx> {\n }\n \n impl<'tcx> DeferredCallResolution<'tcx> for CallResolution<'tcx> {\n-    fn resolve<'a>(&mut self, fcx: &FnCtxt<'a,'tcx>) {\n+    fn resolve<'a>(&mut self, fcx: &FnCtxt<'a,'tcx, 'tcx>) {\n         debug!(\"DeferredCallResolution::resolve() {:?}\",\n                self);\n "}, {"sha": "e4cd9540e960144e404058a85396c2cfd19d63df", "filename": "src/librustc_typeck/check/cast.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs?ref=76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4", "patch": "@@ -72,7 +72,7 @@ enum UnsizeKind<'tcx> {\n     OfParam(&'tcx ty::ParamTy)\n }\n \n-impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n+impl<'a, 'tcx> FnCtxt<'a, 'tcx, 'tcx> {\n /// Returns the kind of unsize information of t, or None\n /// if t is sized or it is unknown.\n fn unsize_kind(&self, t: Ty<'tcx>) -> Option<UnsizeKind<'tcx>> {\n@@ -110,7 +110,7 @@ enum CastError {\n }\n \n impl<'a, 'tcx> CastCheck<'tcx> {\n-    pub fn new(fcx: &FnCtxt<'a, 'tcx>,\n+    pub fn new(fcx: &FnCtxt<'a, 'tcx, 'tcx>,\n                expr: &'tcx hir::Expr,\n                expr_ty: Ty<'tcx>,\n                cast_ty: Ty<'tcx>,\n@@ -139,7 +139,7 @@ impl<'a, 'tcx> CastCheck<'tcx> {\n         }\n     }\n \n-    fn report_cast_error(&self, fcx: &FnCtxt<'a, 'tcx>, e: CastError) {\n+    fn report_cast_error(&self, fcx: &FnCtxt<'a, 'tcx, 'tcx>, e: CastError) {\n         match e {\n             CastError::NeedViaPtr |\n             CastError::NeedViaThinPtr |\n@@ -202,7 +202,7 @@ impl<'a, 'tcx> CastCheck<'tcx> {\n         }\n     }\n \n-    fn report_cast_to_unsized_type(&self, fcx: &FnCtxt<'a, 'tcx>) {\n+    fn report_cast_to_unsized_type(&self, fcx: &FnCtxt<'a, 'tcx, 'tcx>) {\n         if\n             self.cast_ty.references_error() ||\n             self.expr_ty.references_error()\n@@ -256,7 +256,7 @@ impl<'a, 'tcx> CastCheck<'tcx> {\n         err.emit();\n     }\n \n-    fn trivial_cast_lint(&self, fcx: &FnCtxt<'a, 'tcx>) {\n+    fn trivial_cast_lint(&self, fcx: &FnCtxt<'a, 'tcx, 'tcx>) {\n         let t_cast = self.cast_ty;\n         let t_expr = self.expr_ty;\n         if t_cast.is_numeric() && t_expr.is_numeric() {\n@@ -281,7 +281,7 @@ impl<'a, 'tcx> CastCheck<'tcx> {\n \n     }\n \n-    pub fn check(mut self, fcx: &FnCtxt<'a, 'tcx>) {\n+    pub fn check(mut self, fcx: &FnCtxt<'a, 'tcx, 'tcx>) {\n         self.expr_ty = fcx.structurally_resolved_type(self.span, self.expr_ty);\n         self.cast_ty = fcx.structurally_resolved_type(self.span, self.cast_ty);\n \n@@ -309,7 +309,7 @@ impl<'a, 'tcx> CastCheck<'tcx> {\n     /// Check a cast, and report an error if one exists. In some cases, this\n     /// can return Ok and create type errors in the fcx rather than returning\n     /// directly. coercion-cast is handled in check instead of here.\n-    fn do_check(&self, fcx: &FnCtxt<'a, 'tcx>) -> Result<CastKind, CastError> {\n+    fn do_check(&self, fcx: &FnCtxt<'a, 'tcx, 'tcx>) -> Result<CastKind, CastError> {\n         use rustc::ty::cast::IntTy::*;\n         use rustc::ty::cast::CastTy::*;\n \n@@ -377,7 +377,7 @@ impl<'a, 'tcx> CastCheck<'tcx> {\n     }\n \n     fn check_ptr_ptr_cast(&self,\n-                          fcx: &FnCtxt<'a, 'tcx>,\n+                          fcx: &FnCtxt<'a, 'tcx, 'tcx>,\n                           m_expr: &'tcx ty::TypeAndMut<'tcx>,\n                           m_cast: &'tcx ty::TypeAndMut<'tcx>)\n                           -> Result<CastKind, CastError>\n@@ -404,7 +404,7 @@ impl<'a, 'tcx> CastCheck<'tcx> {\n     }\n \n     fn check_fptr_ptr_cast(&self,\n-                           fcx: &FnCtxt<'a, 'tcx>,\n+                           fcx: &FnCtxt<'a, 'tcx, 'tcx>,\n                            m_cast: &'tcx ty::TypeAndMut<'tcx>)\n                            -> Result<CastKind, CastError>\n     {\n@@ -418,7 +418,7 @@ impl<'a, 'tcx> CastCheck<'tcx> {\n     }\n \n     fn check_ptr_addr_cast(&self,\n-                           fcx: &FnCtxt<'a, 'tcx>,\n+                           fcx: &FnCtxt<'a, 'tcx, 'tcx>,\n                            m_expr: &'tcx ty::TypeAndMut<'tcx>)\n                            -> Result<CastKind, CastError>\n     {\n@@ -432,7 +432,7 @@ impl<'a, 'tcx> CastCheck<'tcx> {\n     }\n \n     fn check_ref_cast(&self,\n-                      fcx: &FnCtxt<'a, 'tcx>,\n+                      fcx: &FnCtxt<'a, 'tcx, 'tcx>,\n                       m_expr: &'tcx ty::TypeAndMut<'tcx>,\n                       m_cast: &'tcx ty::TypeAndMut<'tcx>)\n                       -> Result<CastKind, CastError>\n@@ -458,7 +458,7 @@ impl<'a, 'tcx> CastCheck<'tcx> {\n     }\n \n     fn check_addr_ptr_cast(&self,\n-                           fcx: &FnCtxt<'a, 'tcx>,\n+                           fcx: &FnCtxt<'a, 'tcx, 'tcx>,\n                            m_cast: &'tcx ty::TypeAndMut<'tcx>)\n                            -> Result<CastKind, CastError>\n     {\n@@ -470,13 +470,13 @@ impl<'a, 'tcx> CastCheck<'tcx> {\n         }\n     }\n \n-    fn try_coercion_cast(&self, fcx: &FnCtxt<'a, 'tcx>) -> bool {\n+    fn try_coercion_cast(&self, fcx: &FnCtxt<'a, 'tcx, 'tcx>) -> bool {\n         fcx.try_coerce(self.expr, self.cast_ty).is_ok()\n     }\n \n }\n \n-impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n+impl<'a, 'tcx> FnCtxt<'a, 'tcx, 'tcx> {\n     fn type_is_known_to_be_sized(&self,\n                                  ty: Ty<'tcx>,\n                                  span: Span)"}, {"sha": "e6ec47f1364da6a7a4006d393201e83e7ce9943e", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4", "patch": "@@ -19,7 +19,7 @@ use std::cmp;\n use syntax::abi::Abi;\n use rustc::hir;\n \n-impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n+impl<'a, 'tcx> FnCtxt<'a, 'tcx, 'tcx> {\n pub fn check_expr_closure(&self,\n                           expr: &hir::Expr,\n                           _capture: hir::CaptureClause,"}, {"sha": "6e24df481bde7c883f2c8e2ca0ab8c0bdf505d65", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4", "patch": "@@ -77,8 +77,8 @@ use std::cell::RefCell;\n use std::collections::VecDeque;\n use rustc::hir;\n \n-struct Coerce<'a, 'tcx: 'a> {\n-    fcx: &'a FnCtxt<'a, 'tcx>,\n+struct Coerce<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n+    fcx: &'a FnCtxt<'a, 'gcx, 'tcx>,\n     origin: TypeOrigin,\n     use_lub: bool,\n     unsizing_obligations: RefCell<Vec<traits::PredicateObligation<'tcx>>>,\n@@ -97,8 +97,8 @@ fn coerce_mutbls<'tcx>(from_mutbl: hir::Mutability,\n     }\n }\n \n-impl<'f, 'tcx> Coerce<'f, 'tcx> {\n-    fn new(fcx: &'f FnCtxt<'f, 'tcx>, origin: TypeOrigin) -> Self {\n+impl<'f, 'tcx> Coerce<'f, 'tcx, 'tcx> {\n+    fn new(fcx: &'f FnCtxt<'f, 'tcx, 'tcx>, origin: TypeOrigin) -> Self {\n         Coerce {\n             fcx: fcx,\n             origin: origin,\n@@ -107,7 +107,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n         }\n     }\n \n-    fn tcx(&self) -> TyCtxt<'f, 'tcx> {\n+    fn tcx(&self) -> TyCtxt<'f, 'tcx, 'tcx> {\n         self.fcx.tcx()\n     }\n \n@@ -591,7 +591,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n     }\n }\n \n-fn apply<'a, 'b, 'tcx, E, I>(coerce: &mut Coerce<'a, 'tcx>,\n+fn apply<'a, 'b, 'tcx, E, I>(coerce: &mut Coerce<'a, 'tcx, 'tcx>,\n                              exprs: &E,\n                              a: Ty<'tcx>,\n                              b: Ty<'tcx>)\n@@ -614,7 +614,7 @@ fn apply<'a, 'b, 'tcx, E, I>(coerce: &mut Coerce<'a, 'tcx>,\n     Ok((ty, adjustment))\n }\n \n-impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n+impl<'a, 'tcx> FnCtxt<'a, 'tcx, 'tcx> {\n /// Attempt to coerce an expression to a type, and return the\n /// adjusted type of the expression, if successful.\n /// Adjustments are only recorded if the coercion succeeded."}, {"sha": "f80e715721ca67cf06bedb95fe24ec91b9a80691", "filename": "src/librustc_typeck/check/demand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs?ref=76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4", "patch": "@@ -16,7 +16,7 @@ use rustc::infer::{InferOk, TypeOrigin};\n use syntax::codemap::Span;\n use rustc::hir;\n \n-impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n+impl<'a, 'tcx> FnCtxt<'a, 'tcx, 'tcx> {\n // Requires that the two types unify, and prints an error message if\n // they don't.\n pub fn demand_suptype(&self, sp: Span, expected: Ty<'tcx>, actual: Ty<'tcx>) {"}, {"sha": "e5f1447802570b55e27d032b4f5effa977e2f19a", "filename": "src/librustc_typeck/check/dropck.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs?ref=76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4", "patch": "@@ -274,7 +274,7 @@ fn ensure_drop_predicates_are_implied_by_item_defn<'a, 'tcx>(\n /// ensuring that they do not access data nor invoke methods of\n /// values that have been previously dropped).\n ///\n-pub fn check_safety_of_destructor_if_necessary<'a, 'tcx>(rcx: &mut RegionCtxt<'a, 'tcx>,\n+pub fn check_safety_of_destructor_if_necessary<'a, 'tcx>(rcx: &mut RegionCtxt<'a, 'tcx, 'tcx>,\n                                                          typ: ty::Ty<'tcx>,\n                                                          span: Span,\n                                                          scope: region::CodeExtent) {\n@@ -343,8 +343,8 @@ enum TypeContext {\n     }\n }\n \n-struct DropckContext<'a, 'b: 'a, 'tcx: 'b> {\n-    rcx: &'a mut RegionCtxt<'b, 'tcx>,\n+struct DropckContext<'a, 'b: 'a, 'gcx: 'b+'tcx, 'tcx: 'b> {\n+    rcx: &'a mut RegionCtxt<'b, 'gcx, 'tcx>,\n     /// types that have already been traversed\n     breadcrumbs: FnvHashSet<Ty<'tcx>>,\n     /// span for error reporting\n@@ -355,7 +355,7 @@ struct DropckContext<'a, 'b: 'a, 'tcx: 'b> {\n \n // `context` is used for reporting overflow errors\n fn iterate_over_potentially_unsafe_regions_in_type<'a, 'b, 'tcx>(\n-    cx: &mut DropckContext<'a, 'b, 'tcx>,\n+    cx: &mut DropckContext<'a, 'b, 'tcx, 'tcx>,\n     context: TypeContext,\n     ty: Ty<'tcx>,\n     depth: usize) -> Result<(), Error<'tcx>>\n@@ -500,7 +500,7 @@ fn iterate_over_potentially_unsafe_regions_in_type<'a, 'b, 'tcx>(\n     }\n }\n \n-fn has_dtor_of_interest<'a, 'b, 'tcx>(cx: &DropckContext<'a, 'b, 'tcx>,\n+fn has_dtor_of_interest<'a, 'b, 'tcx>(cx: &DropckContext<'a, 'b, 'tcx, 'tcx>,\n                                       ty: ty::Ty<'tcx>) -> bool {\n     match ty.sty {\n         ty::TyEnum(def, _) | ty::TyStruct(def, _) => {"}, {"sha": "a2570ef8eef4c10614c4696b88e1c811862a43ad", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4", "patch": "@@ -23,11 +23,11 @@ use rustc::infer::{InferCtxt, InferOk, TypeOrigin};\n use syntax::codemap::Span;\n use rustc::hir;\n \n-struct ConfirmContext<'a, 'tcx:'a> {\n-    fcx: &'a FnCtxt<'a, 'tcx>,\n+struct ConfirmContext<'a, 'gcx: 'a+'tcx, 'tcx: 'a>{\n+    fcx: &'a FnCtxt<'a, 'gcx, 'tcx>,\n     span: Span,\n-    self_expr: &'tcx hir::Expr,\n-    call_expr: &'tcx hir::Expr,\n+    self_expr: &'gcx hir::Expr,\n+    call_expr: &'gcx hir::Expr,\n }\n \n struct InstantiatedMethodSig<'tcx> {\n@@ -44,7 +44,7 @@ struct InstantiatedMethodSig<'tcx> {\n     method_predicates: ty::InstantiatedPredicates<'tcx>,\n }\n \n-impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n+impl<'a, 'tcx> FnCtxt<'a, 'tcx, 'tcx> {\n pub fn confirm_method(&self,\n                       span: Span,\n                       self_expr: &'tcx hir::Expr,\n@@ -64,12 +64,12 @@ pub fn confirm_method(&self,\n }\n }\n \n-impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n-    fn new(fcx: &'a FnCtxt<'a, 'tcx>,\n+impl<'a,'tcx> ConfirmContext<'a,'tcx, 'tcx> {\n+    fn new(fcx: &'a FnCtxt<'a, 'tcx, 'tcx>,\n            span: Span,\n            self_expr: &'tcx hir::Expr,\n            call_expr: &'tcx hir::Expr)\n-           -> ConfirmContext<'a, 'tcx>\n+           -> ConfirmContext<'a, 'tcx, 'tcx>\n     {\n         ConfirmContext { fcx: fcx, span: span, self_expr: self_expr, call_expr: call_expr }\n     }\n@@ -278,7 +278,7 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n     }\n \n     fn extract_trait_ref<R, F>(&mut self, self_ty: Ty<'tcx>, mut closure: F) -> R where\n-        F: FnMut(&mut ConfirmContext<'a, 'tcx>, Ty<'tcx>, &ty::TraitTy<'tcx>) -> R,\n+        F: FnMut(&mut ConfirmContext<'a, 'tcx, 'tcx>, Ty<'tcx>, &ty::TraitTy<'tcx>) -> R,\n     {\n         // If we specified that this is an object method, then the\n         // self-type ought to be something that can be dereferenced to\n@@ -617,11 +617,11 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n     ///////////////////////////////////////////////////////////////////////////\n     // MISCELLANY\n \n-    fn tcx(&self) -> TyCtxt<'a, 'tcx> {\n+    fn tcx(&self) -> TyCtxt<'a, 'tcx, 'tcx> {\n         self.fcx.tcx()\n     }\n \n-    fn infcx(&self) -> &'a InferCtxt<'a, 'tcx> {\n+    fn infcx(&self) -> &'a InferCtxt<'a, 'tcx, 'tcx> {\n         self.fcx.infcx()\n     }\n "}, {"sha": "ae3446bbde8b8e5ba67e5a2f32a643595570fb20", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4", "patch": "@@ -78,7 +78,7 @@ pub enum CandidateSource {\n     TraitSource(/* trait id */ DefId),\n }\n \n-impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n+impl<'a, 'tcx> FnCtxt<'a, 'tcx, 'tcx> {\n /// Determines whether the type `self_ty` supports a method name `method_name` or not.\n pub fn method_exists(&self,\n                      span: Span,"}, {"sha": "00c90dcbee426bb0b6b034a46b662f8c8fc321dc", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4", "patch": "@@ -31,8 +31,8 @@ use std::rc::Rc;\n use self::CandidateKind::*;\n pub use self::PickKind::*;\n \n-struct ProbeContext<'a, 'tcx:'a> {\n-    fcx: &'a FnCtxt<'a, 'tcx>,\n+struct ProbeContext<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n+    fcx: &'a FnCtxt<'a, 'gcx, 'tcx>,\n     span: Span,\n     mode: Mode,\n     item_name: ast::Name,\n@@ -128,7 +128,7 @@ pub enum Mode {\n     Path\n }\n \n-impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n+impl<'a, 'tcx> FnCtxt<'a, 'tcx, 'tcx> {\n pub fn probe_method(&self,\n                     span: Span,\n                     mode: Mode,\n@@ -233,14 +233,14 @@ fn create_steps(&self,\n }\n }\n \n-impl<'a,'tcx> ProbeContext<'a,'tcx> {\n-    fn new(fcx: &'a FnCtxt<'a,'tcx>,\n+impl<'a,'tcx> ProbeContext<'a,'tcx, 'tcx> {\n+    fn new(fcx: &'a FnCtxt<'a,'tcx, 'tcx>,\n            span: Span,\n            mode: Mode,\n            item_name: ast::Name,\n            steps: Vec<CandidateStep<'tcx>>,\n            opt_simplified_steps: Option<Vec<ty::fast_reject::SimplifiedType>>)\n-           -> ProbeContext<'a,'tcx>\n+           -> ProbeContext<'a,'tcx, 'tcx>\n     {\n         ProbeContext {\n             fcx: fcx,\n@@ -267,11 +267,11 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n         self.private_candidate = None;\n     }\n \n-    fn tcx(&self) -> TyCtxt<'a, 'tcx> {\n+    fn tcx(&self) -> TyCtxt<'a, 'tcx, 'tcx> {\n         self.fcx.tcx()\n     }\n \n-    fn infcx(&self) -> &'a InferCtxt<'a, 'tcx> {\n+    fn infcx(&self) -> &'a InferCtxt<'a, 'tcx, 'tcx> {\n         self.fcx.infcx()\n     }\n \n@@ -554,7 +554,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n         mut mk_cand: F,\n     ) where\n         F: for<'b> FnMut(\n-            &mut ProbeContext<'b, 'tcx>,\n+            &mut ProbeContext<'b, 'tcx, 'tcx>,\n             ty::PolyTraitRef<'tcx>,\n             ty::ImplOrTraitItem<'tcx>,\n         ),"}, {"sha": "ab3c6b4513d098d6624a9a78ee61f26f031ec493", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4", "patch": "@@ -39,7 +39,7 @@ use std::cmp::Ordering;\n use super::{MethodError, NoMatchData, CandidateSource};\n use super::probe::Mode;\n \n-impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n+impl<'a, 'tcx> FnCtxt<'a, 'tcx, 'tcx> {\n fn is_fn_ty(&self, ty: &Ty<'tcx>, span: Span) -> bool {\n     let tcx = self.tcx();\n     match ty.sty {"}, {"sha": "486b353488e1162ff833789d362b4d4dce859a6b", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 41, "deletions": 39, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4", "patch": "@@ -154,8 +154,8 @@ mod op;\n /// Here, the function `foo()` and the closure passed to\n /// `bar()` will each have their own `FnCtxt`, but they will\n /// share the inherited fields.\n-pub struct Inherited<'a, 'tcx: 'a> {\n-    infcx: InferCtxt<'a, 'tcx>,\n+pub struct Inherited<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n+    infcx: InferCtxt<'a, 'gcx, 'tcx>,\n     locals: RefCell<NodeMap<Ty<'tcx>>>,\n \n     fulfillment_cx: RefCell<traits::FulfillmentContext<'tcx>>,\n@@ -175,7 +175,7 @@ pub struct Inherited<'a, 'tcx: 'a> {\n }\n \n trait DeferredCallResolution<'tcx> {\n-    fn resolve<'a>(&mut self, fcx: &FnCtxt<'a,'tcx>);\n+    fn resolve<'a>(&mut self, fcx: &FnCtxt<'a,'tcx, 'tcx>);\n }\n \n type DeferredCallResolutionHandler<'tcx> = Box<DeferredCallResolution<'tcx>+'tcx>;\n@@ -215,7 +215,7 @@ impl<'a, 'tcx> Expectation<'tcx> {\n     // an expected type. Otherwise, we might write parts of the type\n     // when checking the 'then' block which are incompatible with the\n     // 'else' branch.\n-    fn adjust_for_branches(&self, fcx: &FnCtxt<'a, 'tcx>) -> Expectation<'tcx> {\n+    fn adjust_for_branches(&self, fcx: &FnCtxt<'a, 'tcx, 'tcx>) -> Expectation<'tcx> {\n         match *self {\n             ExpectHasType(ety) => {\n                 let ety = fcx.infcx().shallow_resolve(ety);\n@@ -251,7 +251,7 @@ impl<'a, 'tcx> Expectation<'tcx> {\n     /// which still is useful, because it informs integer literals and the like.\n     /// See the test case `test/run-pass/coerce-expect-unsized.rs` and #20169\n     /// for examples of where this comes up,.\n-    fn rvalue_hint(fcx: &FnCtxt<'a, 'tcx>, ty: Ty<'tcx>) -> Expectation<'tcx> {\n+    fn rvalue_hint(fcx: &FnCtxt<'a, 'tcx, 'tcx>, ty: Ty<'tcx>) -> Expectation<'tcx> {\n         match fcx.tcx().struct_tail(ty).sty {\n             ty::TySlice(_) | ty::TyStr | ty::TyTrait(..) => {\n                 ExpectRvalueLikeUnsized(ty)\n@@ -263,7 +263,7 @@ impl<'a, 'tcx> Expectation<'tcx> {\n     // Resolves `expected` by a single level if it is a variable. If\n     // there is no expected type or resolution is not possible (e.g.,\n     // no constraints yet present), just returns `None`.\n-    fn resolve(self, fcx: &FnCtxt<'a, 'tcx>) -> Expectation<'tcx> {\n+    fn resolve(self, fcx: &FnCtxt<'a, 'tcx, 'tcx>) -> Expectation<'tcx> {\n         match self {\n             NoExpectation => {\n                 NoExpectation\n@@ -283,7 +283,7 @@ impl<'a, 'tcx> Expectation<'tcx> {\n         }\n     }\n \n-    fn to_option(self, fcx: &FnCtxt<'a, 'tcx>) -> Option<Ty<'tcx>> {\n+    fn to_option(self, fcx: &FnCtxt<'a, 'tcx, 'tcx>) -> Option<Ty<'tcx>> {\n         match self.resolve(fcx) {\n             NoExpectation => None,\n             ExpectCastableToType(ty) |\n@@ -292,7 +292,7 @@ impl<'a, 'tcx> Expectation<'tcx> {\n         }\n     }\n \n-    fn only_has_type(self, fcx: &FnCtxt<'a, 'tcx>) -> Option<Ty<'tcx>> {\n+    fn only_has_type(self, fcx: &FnCtxt<'a, 'tcx, 'tcx>) -> Option<Ty<'tcx>> {\n         match self.resolve(fcx) {\n             ExpectHasType(ty) => Some(ty),\n             _ => None\n@@ -342,7 +342,7 @@ impl UnsafetyState {\n }\n \n #[derive(Clone)]\n-pub struct FnCtxt<'a, 'tcx: 'a> {\n+pub struct FnCtxt<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     body_id: ast::NodeId,\n \n     // This flag is set to true if, during the writeback phase, we encounter\n@@ -359,16 +359,16 @@ pub struct FnCtxt<'a, 'tcx: 'a> {\n \n     ps: RefCell<UnsafetyState>,\n \n-    inh: &'a Inherited<'a, 'tcx>,\n+    inh: &'a Inherited<'a, 'gcx, 'tcx>,\n \n-    ccx: &'a CrateCtxt<'a, 'tcx>,\n+    ccx: &'a CrateCtxt<'a, 'gcx>,\n }\n \n-impl<'a, 'tcx> Inherited<'a, 'tcx> {\n-    fn new(tcx: TyCtxt<'a, 'tcx>,\n+impl<'a, 'tcx> Inherited<'a, 'tcx, 'tcx> {\n+    fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n            tables: &'a RefCell<ty::Tables<'tcx>>,\n            param_env: ty::ParameterEnvironment<'a, 'tcx>)\n-           -> Inherited<'a, 'tcx> {\n+           -> Inherited<'a, 'tcx, 'tcx> {\n \n         Inherited {\n             infcx: InferCtxt::new(tcx, tables, Some(param_env), ProjectionMode::AnyFinal),\n@@ -398,7 +398,7 @@ impl<'a, 'tcx> Inherited<'a, 'tcx> {\n \n fn static_inherited_fields<'a, 'tcx>(ccx: &'a CrateCtxt<'a, 'tcx>,\n                                      tables: &'a RefCell<ty::Tables<'tcx>>)\n-                                    -> Inherited<'a, 'tcx> {\n+                                    -> Inherited<'a, 'tcx, 'tcx> {\n     // It's kind of a kludge to manufacture a fake function context\n     // and statement context, but we might as well do write the code only once\n     let param_env = ccx.tcx.empty_parameter_environment();\n@@ -513,11 +513,11 @@ fn check_bare_fn<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     }\n }\n \n-struct GatherLocalsVisitor<'a, 'tcx: 'a> {\n-    fcx: &'a FnCtxt<'a, 'tcx>\n+struct GatherLocalsVisitor<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n+    fcx: &'a FnCtxt<'a, 'gcx, 'tcx>\n }\n \n-impl<'a, 'tcx> GatherLocalsVisitor<'a, 'tcx> {\n+impl<'a, 'tcx> GatherLocalsVisitor<'a, 'tcx, 'tcx> {\n     fn assign(&mut self, _span: Span, nid: ast::NodeId, ty_opt: Option<Ty<'tcx>>) -> Ty<'tcx> {\n         match ty_opt {\n             None => {\n@@ -535,7 +535,7 @@ impl<'a, 'tcx> GatherLocalsVisitor<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> Visitor<'tcx> for GatherLocalsVisitor<'a, 'tcx> {\n+impl<'a, 'tcx> Visitor<'tcx> for GatherLocalsVisitor<'a, 'tcx, 'tcx> {\n     // Add explicitly-declared locals.\n     fn visit_local(&mut self, local: &'tcx hir::Local) {\n         let o_ty = match local.ty {\n@@ -610,8 +610,8 @@ fn check_fn<'a, 'tcx>(ccx: &'a CrateCtxt<'a, 'tcx>,\n                       decl: &'tcx hir::FnDecl,\n                       fn_id: ast::NodeId,\n                       body: &'tcx hir::Block,\n-                      inherited: &'a Inherited<'a, 'tcx>)\n-                      -> FnCtxt<'a, 'tcx>\n+                      inherited: &'a Inherited<'a, 'tcx, 'tcx>)\n+                      -> FnCtxt<'a, 'tcx, 'tcx>\n {\n     let tcx = ccx.tcx;\n \n@@ -902,9 +902,9 @@ fn check_method_body<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     check_bare_fn(ccx, &sig.decl, body, id, span, fty, param_env);\n }\n \n-fn report_forbidden_specialization(tcx: TyCtxt,\n-                                   impl_item: &hir::ImplItem,\n-                                   parent_impl: DefId)\n+fn report_forbidden_specialization<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                             impl_item: &hir::ImplItem,\n+                                             parent_impl: DefId)\n {\n     let mut err = struct_span_err!(\n         tcx.sess, impl_item.span, E0520,\n@@ -925,8 +925,10 @@ fn report_forbidden_specialization(tcx: TyCtxt,\n     err.emit();\n }\n \n-fn check_specialization_validity<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx>, trait_def: &ty::TraitDef<'tcx>,\n-                                           impl_id: DefId, impl_item: &hir::ImplItem)\n+fn check_specialization_validity<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                           trait_def: &ty::TraitDef<'tcx>,\n+                                           impl_id: DefId,\n+                                           impl_item: &hir::ImplItem)\n {\n     let ancestors = trait_def.ancestors(impl_id);\n \n@@ -1143,10 +1145,10 @@ fn check_const<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n /// Checks whether a type can be represented in memory. In particular, it\n /// identifies types that contain themselves without indirection through a\n /// pointer, which would mean their size is unbounded.\n-pub fn check_representable(tcx: TyCtxt,\n-                           sp: Span,\n-                           item_id: ast::NodeId,\n-                           _designation: &str) -> bool {\n+pub fn check_representable<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                     sp: Span,\n+                                     item_id: ast::NodeId,\n+                                     _designation: &str) -> bool {\n     let rty = tcx.node_id_to_type(item_id);\n \n     // Check that it is possible to represent this type. This call identifies\n@@ -1165,7 +1167,7 @@ pub fn check_representable(tcx: TyCtxt,\n     return true\n }\n \n-pub fn check_simd(tcx: TyCtxt, sp: Span, id: ast::NodeId) {\n+pub fn check_simd<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, sp: Span, id: ast::NodeId) {\n     let t = tcx.node_id_to_type(id);\n     match t.sty {\n         ty::TyStruct(def, substs) => {\n@@ -1252,8 +1254,8 @@ pub fn check_enum_variants<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n     check_representable(ccx.tcx, sp, id, \"enum\");\n }\n \n-impl<'a, 'tcx> AstConv<'tcx> for FnCtxt<'a, 'tcx> {\n-    fn tcx<'b>(&'b self) -> TyCtxt<'b, 'tcx> { self.infcx().tcx }\n+impl<'a, 'tcx> AstConv<'tcx, 'tcx> for FnCtxt<'a, 'tcx, 'tcx> {\n+    fn tcx<'b>(&'b self) -> TyCtxt<'b, 'tcx, 'tcx> { self.infcx().tcx }\n \n     fn get_item_type_scheme(&self, _: Span, id: DefId)\n                             -> Result<ty::TypeScheme<'tcx>, ErrorReported>\n@@ -1364,7 +1366,7 @@ impl<'a, 'tcx> AstConv<'tcx> for FnCtxt<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> RegionScope for FnCtxt<'a, 'tcx> {\n+impl<'a, 'tcx> RegionScope for FnCtxt<'a, 'tcx, 'tcx> {\n     fn object_lifetime_default(&self, span: Span) -> Option<ty::Region> {\n         Some(self.base_object_lifetime_default(span))\n     }\n@@ -1421,12 +1423,12 @@ enum TupleArgumentsFlag {\n     TupleArguments,\n }\n \n-impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n+impl<'a, 'tcx> FnCtxt<'a, 'tcx, 'tcx> {\n     pub fn new(ccx: &'a CrateCtxt<'a, 'tcx>,\n-               inh: &'a Inherited<'a, 'tcx>,\n+               inh: &'a Inherited<'a, 'tcx, 'tcx>,\n                rty: ty::FnOutput<'tcx>,\n                body_id: ast::NodeId)\n-               -> FnCtxt<'a, 'tcx> {\n+               -> FnCtxt<'a, 'tcx, 'tcx> {\n         FnCtxt {\n             body_id: body_id,\n             writeback_errors: Cell::new(false),\n@@ -1438,9 +1440,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n     }\n \n-    pub fn tcx(&self) -> TyCtxt<'a, 'tcx> { self.infcx().tcx }\n+    pub fn tcx(&self) -> TyCtxt<'a, 'tcx, 'tcx> { self.infcx().tcx }\n \n-    pub fn infcx(&self) -> &InferCtxt<'a,'tcx> {\n+    pub fn infcx(&self) -> &InferCtxt<'a,'tcx, 'tcx> {\n         &self.inh.infcx\n     }\n "}, {"sha": "977eb4b35ff5ee4526e4028114cd647983956267", "filename": "src/librustc_typeck/check/op.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fop.rs?ref=76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4", "patch": "@@ -17,7 +17,7 @@ use syntax::ast;\n use syntax::parse::token;\n use rustc::hir;\n \n-impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n+impl<'a, 'tcx> FnCtxt<'a, 'tcx, 'tcx> {\n /// Check a `a <op>= b`\n pub fn check_binop_assign(&self,\n                           expr: &'tcx hir::Expr,"}, {"sha": "c16a00e723eef009477484b9a339333c4904243f", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4", "patch": "@@ -112,7 +112,7 @@ macro_rules! ignore_err {\n ///////////////////////////////////////////////////////////////////////////\n // PUBLIC ENTRY POINTS\n \n-impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n+impl<'a, 'tcx> FnCtxt<'a, 'tcx, 'tcx> {\n pub fn regionck_expr(&self, e: &hir::Expr) {\n     let mut rcx = RegionCtxt::new(self, RepeatingScope(e.id), e.id, Subject(e.id));\n     if self.err_count_since_creation() == 0 {\n@@ -166,8 +166,8 @@ pub fn regionck_fn(&self,\n ///////////////////////////////////////////////////////////////////////////\n // INTERNALS\n \n-pub struct RegionCtxt<'a, 'tcx: 'a> {\n-    pub fcx: &'a FnCtxt<'a, 'tcx>,\n+pub struct RegionCtxt<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n+    pub fcx: &'a FnCtxt<'a, 'gcx, 'tcx>,\n \n     region_bound_pairs: Vec<(ty::Region, GenericKind<'tcx>)>,\n \n@@ -190,11 +190,11 @@ pub struct RegionCtxt<'a, 'tcx: 'a> {\n pub struct RepeatingScope(ast::NodeId);\n pub enum SubjectNode { Subject(ast::NodeId), None }\n \n-impl<'a, 'tcx> RegionCtxt<'a, 'tcx> {\n-    pub fn new(fcx: &'a FnCtxt<'a, 'tcx>,\n+impl<'a, 'tcx> RegionCtxt<'a, 'tcx, 'tcx> {\n+    pub fn new(fcx: &'a FnCtxt<'a, 'tcx, 'tcx>,\n                initial_repeating_scope: RepeatingScope,\n                initial_body_id: ast::NodeId,\n-               subject: SubjectNode) -> RegionCtxt<'a, 'tcx> {\n+               subject: SubjectNode) -> RegionCtxt<'a, 'tcx, 'tcx> {\n         let RepeatingScope(initial_repeating_scope) = initial_repeating_scope;\n         RegionCtxt {\n             fcx: fcx,\n@@ -207,11 +207,11 @@ impl<'a, 'tcx> RegionCtxt<'a, 'tcx> {\n         }\n     }\n \n-    pub fn tcx(&self) -> TyCtxt<'a, 'tcx> {\n+    pub fn tcx(&self) -> TyCtxt<'a, 'tcx, 'tcx> {\n         self.fcx.tcx()\n     }\n \n-    pub fn infcx(&self) -> &InferCtxt<'a,'tcx> {\n+    pub fn infcx(&self) -> &InferCtxt<'a,'tcx, 'tcx> {\n         self.fcx.infcx()\n     }\n \n@@ -489,7 +489,7 @@ fn constrain_bindings_in_pat(&mut self, pat: &hir::Pat) {\n }\n }\n \n-impl<'a, 'tcx, 'v> Visitor<'v> for RegionCtxt<'a, 'tcx> {\n+impl<'a, 'tcx, 'v> Visitor<'v> for RegionCtxt<'a, 'tcx, 'tcx> {\n     // (..) FIXME(#3238) should use visit_pat, not visit_arm/visit_local,\n     // However, right now we run into an issue whereby some free\n     // regions are not properly related if they appear within the\n@@ -798,7 +798,7 @@ fn visit_expr(&mut self, expr: &hir::Expr) {\n }\n }\n \n-impl<'a, 'tcx> RegionCtxt<'a, 'tcx> {\n+impl<'a, 'tcx> RegionCtxt<'a, 'tcx, 'tcx> {\n fn constrain_cast(&mut self,\n                   cast_expr: &hir::Expr,\n                   source_expr: &hir::Expr)\n@@ -1155,7 +1155,7 @@ fn link_fn_args(&self, body_scope: CodeExtent, args: &[hir::Arg]) {\n /// Link lifetimes of any ref bindings in `root_pat` to the pointers found in the discriminant, if\n /// needed.\n fn link_pattern<'t>(&self,\n-                    mc: mc::MemCategorizationContext<'t, 'a, 'tcx>,\n+                    mc: mc::MemCategorizationContext<'a, 'tcx, 'tcx>,\n                     discr_cmt: mc::cmt<'tcx>,\n                     root_pat: &hir::Pat) {\n     debug!(\"link_pattern(discr_cmt={:?}, root_pat={:?})\","}, {"sha": "414a3157c0efcd90e74c6cc7d16d62d19014e690", "filename": "src/librustc_typeck/check/upvar.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs?ref=76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4", "patch": "@@ -56,7 +56,7 @@ use rustc::hir::intravisit::{self, Visitor};\n ///////////////////////////////////////////////////////////////////////////\n // PUBLIC ENTRY POINTS\n \n-impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n+impl<'a, 'tcx> FnCtxt<'a, 'tcx, 'tcx> {\n pub fn closure_analyze_fn(&self, body: &hir::Block) {\n     let mut seed = SeedBorrowKind::new(self);\n     seed.visit_block(body);\n@@ -85,12 +85,12 @@ pub fn closure_analyze_const(&self, body: &hir::Expr) {\n ///////////////////////////////////////////////////////////////////////////\n // SEED BORROW KIND\n \n-struct SeedBorrowKind<'a,'tcx:'a> {\n-    fcx: &'a FnCtxt<'a,'tcx>,\n+struct SeedBorrowKind<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n+    fcx: &'a FnCtxt<'a, 'gcx, 'tcx>,\n     closures_with_inferred_kinds: HashSet<ast::NodeId>,\n }\n \n-impl<'a, 'tcx, 'v> Visitor<'v> for SeedBorrowKind<'a, 'tcx> {\n+impl<'a, 'tcx, 'v> Visitor<'v> for SeedBorrowKind<'a, 'tcx, 'tcx> {\n     fn visit_expr(&mut self, expr: &hir::Expr) {\n         match expr.node {\n             hir::ExprClosure(cc, _, ref body, _) => {\n@@ -104,16 +104,16 @@ impl<'a, 'tcx, 'v> Visitor<'v> for SeedBorrowKind<'a, 'tcx> {\n     }\n }\n \n-impl<'a,'tcx> SeedBorrowKind<'a,'tcx> {\n-    fn new(fcx: &'a FnCtxt<'a,'tcx>) -> SeedBorrowKind<'a,'tcx> {\n+impl<'a,'tcx> SeedBorrowKind<'a,'tcx, 'tcx> {\n+    fn new(fcx: &'a FnCtxt<'a,'tcx, 'tcx>) -> SeedBorrowKind<'a,'tcx, 'tcx> {\n         SeedBorrowKind { fcx: fcx, closures_with_inferred_kinds: HashSet::new() }\n     }\n \n-    fn tcx(&self) -> TyCtxt<'a, 'tcx> {\n+    fn tcx(&self) -> TyCtxt<'a, 'tcx, 'tcx> {\n         self.fcx.tcx()\n     }\n \n-    fn infcx(&self) -> &'a InferCtxt<'a,'tcx> {\n+    fn infcx(&self) -> &'a InferCtxt<'a,'tcx, 'tcx> {\n         self.fcx.infcx()\n     }\n \n@@ -160,15 +160,15 @@ impl<'a,'tcx> SeedBorrowKind<'a,'tcx> {\n ///////////////////////////////////////////////////////////////////////////\n // ADJUST BORROW KIND\n \n-struct AdjustBorrowKind<'a,'tcx:'a> {\n-    fcx: &'a FnCtxt<'a,'tcx>,\n+struct AdjustBorrowKind<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n+    fcx: &'a FnCtxt<'a, 'gcx, 'tcx>,\n     closures_with_inferred_kinds: &'a HashSet<ast::NodeId>,\n }\n \n-impl<'a,'tcx> AdjustBorrowKind<'a,'tcx> {\n-    fn new(fcx: &'a FnCtxt<'a,'tcx>,\n+impl<'a,'tcx> AdjustBorrowKind<'a,'tcx, 'tcx> {\n+    fn new(fcx: &'a FnCtxt<'a,'tcx, 'tcx>,\n            closures_with_inferred_kinds: &'a HashSet<ast::NodeId>)\n-           -> AdjustBorrowKind<'a,'tcx> {\n+           -> AdjustBorrowKind<'a,'tcx, 'tcx> {\n         AdjustBorrowKind { fcx: fcx, closures_with_inferred_kinds: closures_with_inferred_kinds }\n     }\n \n@@ -500,7 +500,7 @@ impl<'a,'tcx> AdjustBorrowKind<'a,'tcx> {\n     }\n }\n \n-impl<'a, 'tcx, 'v> Visitor<'v> for AdjustBorrowKind<'a, 'tcx> {\n+impl<'a, 'tcx, 'v> Visitor<'v> for AdjustBorrowKind<'a, 'tcx, 'tcx> {\n     fn visit_fn(&mut self,\n                 fn_kind: intravisit::FnKind<'v>,\n                 decl: &'v hir::FnDecl,\n@@ -513,7 +513,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for AdjustBorrowKind<'a, 'tcx> {\n     }\n }\n \n-impl<'a,'tcx> euv::Delegate<'tcx> for AdjustBorrowKind<'a,'tcx> {\n+impl<'a,'tcx> euv::Delegate<'tcx> for AdjustBorrowKind<'a,'tcx, 'tcx> {\n     fn consume(&mut self,\n                _consume_id: ast::NodeId,\n                _consume_span: Span,"}, {"sha": "bc99fd7fb640dbcd22f8dabd640a87684269323f", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4", "patch": "@@ -40,7 +40,7 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n         }\n     }\n \n-    fn tcx(&self) -> TyCtxt<'ccx, 'tcx> {\n+    fn tcx(&self) -> TyCtxt<'ccx, 'tcx, 'tcx> {\n         self.ccx.tcx\n     }\n \n@@ -168,14 +168,14 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n     }\n \n     fn with_item_fcx<F>(&mut self, item: &hir::Item, f: F) where\n-        F: for<'fcx> FnMut(&FnCtxt<'fcx, 'tcx>,\n+        F: for<'fcx> FnMut(&FnCtxt<'fcx, 'tcx, 'tcx>,\n                            &mut CheckTypeWellFormedVisitor<'ccx,'tcx>) -> Vec<Ty<'tcx>>,\n     {\n         self.with_fcx(item.id, item.span, f)\n     }\n \n     fn with_fcx<F>(&mut self, id: ast::NodeId, span: Span, mut f: F) where\n-        F: for<'fcx> FnMut(&FnCtxt<'fcx, 'tcx>,\n+        F: for<'fcx> FnMut(&FnCtxt<'fcx, 'tcx, 'tcx>,\n                            &mut CheckTypeWellFormedVisitor<'ccx,'tcx>) -> Vec<Ty<'tcx>>,\n     {\n         let ccx = self.ccx;\n@@ -190,7 +190,7 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n \n     /// In a type definition, we check that to ensure that the types of the fields are well-formed.\n     fn check_type_defn<F>(&mut self, item: &hir::Item, mut lookup_fields: F) where\n-        F: for<'fcx> FnMut(&FnCtxt<'fcx, 'tcx>) -> Vec<AdtVariant<'tcx>>,\n+        F: for<'fcx> FnMut(&FnCtxt<'fcx, 'tcx, 'tcx>) -> Vec<AdtVariant<'tcx>>,\n     {\n         self.with_item_fcx(item, |fcx, this| {\n             let variants = lookup_fields(fcx);\n@@ -332,7 +332,7 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n     }\n \n     fn check_where_clauses<'fcx>(&mut self,\n-                                 fcx: &FnCtxt<'fcx,'tcx>,\n+                                 fcx: &FnCtxt<'fcx,'tcx, 'tcx>,\n                                  span: Span,\n                                  predicates: &ty::InstantiatedPredicates<'tcx>)\n     {\n@@ -350,7 +350,7 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n     }\n \n     fn check_fn_or_method<'fcx>(&mut self,\n-                                fcx: &FnCtxt<'fcx,'tcx>,\n+                                fcx: &FnCtxt<'fcx,'tcx, 'tcx>,\n                                 span: Span,\n                                 fty: &ty::BareFnTy<'tcx>,\n                                 predicates: &ty::InstantiatedPredicates<'tcx>,\n@@ -380,7 +380,7 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n     }\n \n     fn check_method_receiver<'fcx>(&mut self,\n-                                   fcx: &FnCtxt<'fcx,'tcx>,\n+                                   fcx: &FnCtxt<'fcx,'tcx, 'tcx>,\n                                    span: Span,\n                                    method: &ty::Method<'tcx>,\n                                    free_id_outlive: CodeExtent,\n@@ -554,7 +554,7 @@ struct AdtField<'tcx> {\n     span: Span,\n }\n \n-impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n+impl<'a, 'tcx> FnCtxt<'a, 'tcx, 'tcx> {\n fn struct_variant(&self, struct_def: &hir::VariantData) -> AdtVariant<'tcx> {\n     let fields =\n         struct_def.fields().iter()"}, {"sha": "d1d653df034fdbf065e4f30b0f963171e794f7a3", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4", "patch": "@@ -19,7 +19,7 @@ use hir::pat_util;\n use rustc::ty::{self, Ty, TyCtxt, MethodCall, MethodCallee};\n use rustc::ty::adjustment;\n use rustc::ty::fold::{TypeFolder,TypeFoldable};\n-use rustc::infer;\n+use rustc::infer::{InferCtxt, FixupError};\n use write_substs_to_tcx;\n use write_ty_to_tcx;\n \n@@ -34,7 +34,7 @@ use rustc::hir;\n ///////////////////////////////////////////////////////////////////////////\n // Entry point functions\n \n-impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n+impl<'a, 'tcx> FnCtxt<'a, 'tcx, 'tcx> {\n pub fn resolve_type_vars_in_expr(&self, e: &hir::Expr) {\n     assert_eq!(self.writeback_errors.get(), false);\n     let mut wbcx = WritebackCx::new(self);\n@@ -74,16 +74,16 @@ pub fn resolve_type_vars_in_fn(&self, decl: &hir::FnDecl, blk: &hir::Block) {\n // there, it applies a few ad-hoc checks that were not convenient to\n // do elsewhere.\n \n-struct WritebackCx<'cx, 'tcx: 'cx> {\n-    fcx: &'cx FnCtxt<'cx, 'tcx>,\n+struct WritebackCx<'cx, 'gcx: 'cx+'tcx, 'tcx: 'cx> {\n+    fcx: &'cx FnCtxt<'cx, 'gcx, 'tcx>,\n }\n \n-impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n-    fn new(fcx: &'cx FnCtxt<'cx, 'tcx>) -> WritebackCx<'cx, 'tcx> {\n+impl<'cx, 'tcx> WritebackCx<'cx, 'tcx, 'tcx> {\n+    fn new(fcx: &'cx FnCtxt<'cx, 'tcx, 'tcx>) -> WritebackCx<'cx, 'tcx, 'tcx> {\n         WritebackCx { fcx: fcx }\n     }\n \n-    fn tcx(&self) -> TyCtxt<'cx, 'tcx> {\n+    fn tcx(&self) -> TyCtxt<'cx, 'tcx, 'tcx> {\n         self.fcx.tcx()\n     }\n \n@@ -134,7 +134,7 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n // below. In general, a function is made into a `visitor` if it must\n // traffic in node-ids or update tables in the type context etc.\n \n-impl<'cx, 'tcx, 'v> Visitor<'v> for WritebackCx<'cx, 'tcx> {\n+impl<'cx, 'tcx, 'v> Visitor<'v> for WritebackCx<'cx, 'tcx, 'tcx> {\n     fn visit_stmt(&mut self, s: &hir::Stmt) {\n         if self.fcx.writeback_errors.get() {\n             return;\n@@ -214,7 +214,7 @@ impl<'cx, 'tcx, 'v> Visitor<'v> for WritebackCx<'cx, 'tcx> {\n     }\n }\n \n-impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n+impl<'cx, 'tcx> WritebackCx<'cx, 'tcx, 'tcx> {\n     fn visit_upvar_borrow_map(&self) {\n         if self.fcx.writeback_errors.get() {\n             return;\n@@ -379,7 +379,7 @@ enum ResolveReason {\n }\n \n impl ResolveReason {\n-    fn span(&self, tcx: TyCtxt) -> Span {\n+    fn span<'a, 'tcx>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Span {\n         match *self {\n             ResolvingExpr(s) => s,\n             ResolvingLocal(s) => s,\n@@ -408,33 +408,33 @@ impl ResolveReason {\n // The Resolver. This is the type folding engine that detects\n // unresolved types and so forth.\n \n-struct Resolver<'cx, 'tcx: 'cx> {\n-    tcx: TyCtxt<'cx, 'tcx>,\n-    infcx: &'cx infer::InferCtxt<'cx, 'tcx>,\n+struct Resolver<'cx, 'gcx: 'cx+'tcx, 'tcx: 'cx> {\n+    tcx: TyCtxt<'cx, 'gcx, 'tcx>,\n+    infcx: &'cx InferCtxt<'cx, 'gcx, 'tcx>,\n     writeback_errors: &'cx Cell<bool>,\n     reason: ResolveReason,\n }\n \n-impl<'cx, 'tcx> Resolver<'cx, 'tcx> {\n-    fn new(fcx: &'cx FnCtxt<'cx, 'tcx>,\n+impl<'cx, 'tcx> Resolver<'cx, 'tcx, 'tcx> {\n+    fn new(fcx: &'cx FnCtxt<'cx, 'tcx, 'tcx>,\n            reason: ResolveReason)\n-           -> Resolver<'cx, 'tcx>\n+           -> Resolver<'cx, 'tcx, 'tcx>\n     {\n         Resolver::from_infcx(fcx.infcx(), &fcx.writeback_errors, reason)\n     }\n \n-    fn from_infcx(infcx: &'cx infer::InferCtxt<'cx, 'tcx>,\n+    fn from_infcx(infcx: &'cx InferCtxt<'cx, 'tcx, 'tcx>,\n                   writeback_errors: &'cx Cell<bool>,\n                   reason: ResolveReason)\n-                  -> Resolver<'cx, 'tcx>\n+                  -> Resolver<'cx, 'tcx, 'tcx>\n     {\n         Resolver { infcx: infcx,\n                    tcx: infcx.tcx,\n                    writeback_errors: writeback_errors,\n                    reason: reason }\n     }\n \n-    fn report_error(&self, e: infer::FixupError) {\n+    fn report_error(&self, e: FixupError) {\n         self.writeback_errors.set(true);\n         if !self.tcx.sess.has_errors() {\n             match self.reason {\n@@ -480,8 +480,8 @@ impl<'cx, 'tcx> Resolver<'cx, 'tcx> {\n     }\n }\n \n-impl<'cx, 'tcx> TypeFolder<'tcx> for Resolver<'cx, 'tcx> {\n-    fn tcx<'a>(&'a self) -> TyCtxt<'a, 'tcx> {\n+impl<'cx, 'tcx> TypeFolder<'tcx> for Resolver<'cx, 'tcx, 'tcx> {\n+    fn tcx<'a>(&'a self) -> TyCtxt<'a, 'tcx, 'tcx> {\n         self.tcx\n     }\n "}, {"sha": "c3538ace347491b3346cb3d4bd8f18181d87e415", "filename": "src/librustc_typeck/check_unused.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc_typeck%2Fcheck_unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc_typeck%2Fcheck_unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck_unused.rs?ref=76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4", "patch": "@@ -19,7 +19,7 @@ use rustc::hir;\n use rustc::hir::intravisit::Visitor;\n \n struct UnusedTraitImportVisitor<'a, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'tcx>,\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n }\n \n impl<'a, 'tcx> UnusedTraitImportVisitor<'a, 'tcx> {\n@@ -57,7 +57,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for UnusedTraitImportVisitor<'a, 'tcx> {\n     }\n }\n \n-pub fn check_crate(tcx: TyCtxt) {\n+pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     let _task = tcx.dep_graph.in_task(DepNode::UnusedTraitCheck);\n     let mut visitor = UnusedTraitImportVisitor { tcx: tcx };\n     tcx.map.krate().visit_all_items(&mut visitor);"}, {"sha": "71450c841411d747fd52a60b5c9020ef01355055", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4", "patch": "@@ -46,25 +46,25 @@ mod orphan;\n mod overlap;\n mod unsafety;\n \n-struct CoherenceChecker<'a, 'tcx: 'a> {\n-    crate_context: &'a CrateCtxt<'a, 'tcx>,\n-    inference_context: InferCtxt<'a, 'tcx>,\n+struct CoherenceChecker<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n+    crate_context: &'a CrateCtxt<'a, 'gcx>,\n+    inference_context: InferCtxt<'a, 'gcx, 'tcx>,\n     inherent_impls: RefCell<DefIdMap<Rc<RefCell<Vec<DefId>>>>>,\n }\n \n-struct CoherenceCheckVisitor<'a, 'tcx: 'a> {\n-    cc: &'a CoherenceChecker<'a, 'tcx>\n+struct CoherenceCheckVisitor<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n+    cc: &'a CoherenceChecker<'a, 'gcx, 'tcx>\n }\n \n-impl<'a, 'tcx, 'v> intravisit::Visitor<'v> for CoherenceCheckVisitor<'a, 'tcx> {\n+impl<'a, 'tcx, 'v> intravisit::Visitor<'v> for CoherenceCheckVisitor<'a, 'tcx, 'tcx> {\n     fn visit_item(&mut self, item: &Item) {\n         if let ItemImpl(..) = item.node {\n             self.cc.check_implementation(item)\n         }\n     }\n }\n \n-impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n+impl<'a, 'tcx> CoherenceChecker<'a, 'tcx, 'tcx> {\n \n // Returns the def ID of the base type, if there is one.\n fn get_base_type_def_id(&self, span: Span, ty: Ty<'tcx>) -> Option<DefId> {"}, {"sha": "d9ad03222029d765c27364f8ad00f871c9625008", "filename": "src/librustc_typeck/coherence/orphan.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs?ref=76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4", "patch": "@@ -21,13 +21,13 @@ use rustc::dep_graph::DepNode;\n use rustc::hir::intravisit;\n use rustc::hir;\n \n-pub fn check(tcx: TyCtxt) {\n+pub fn check<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     let mut orphan = OrphanChecker { tcx: tcx };\n     tcx.visit_all_items_in_krate(DepNode::CoherenceOrphanCheck, &mut orphan);\n }\n \n struct OrphanChecker<'cx, 'tcx:'cx> {\n-    tcx: TyCtxt<'cx, 'tcx>\n+    tcx: TyCtxt<'cx, 'tcx, 'tcx>\n }\n \n impl<'cx, 'tcx> OrphanChecker<'cx, 'tcx> {"}, {"sha": "a1af84d620f8d4249c7f875a1e44bd5a0d316df0", "filename": "src/librustc_typeck/coherence/overlap.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs?ref=76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4", "patch": "@@ -23,7 +23,7 @@ use rustc::hir::intravisit;\n use util::nodemap::DefIdMap;\n use lint;\n \n-pub fn check(tcx: TyCtxt) {\n+pub fn check<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     let mut overlap = OverlapChecker { tcx: tcx,\n                                        default_impls: DefIdMap() };\n \n@@ -33,7 +33,7 @@ pub fn check(tcx: TyCtxt) {\n }\n \n struct OverlapChecker<'cx, 'tcx:'cx> {\n-    tcx: TyCtxt<'cx, 'tcx>,\n+    tcx: TyCtxt<'cx, 'tcx, 'tcx>,\n \n     // maps from a trait def-id to an impl id\n     default_impls: DefIdMap<ast::NodeId>,\n@@ -44,8 +44,9 @@ impl<'cx, 'tcx> OverlapChecker<'cx, 'tcx> {\n         #[derive(Copy, Clone, PartialEq)]\n         enum Namespace { Type, Value }\n \n-        fn name_and_namespace(tcx: TyCtxt, item: &ty::ImplOrTraitItemId)\n-                              -> (ast::Name, Namespace)\n+        fn name_and_namespace<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                        item: &ty::ImplOrTraitItemId)\n+                                        -> (ast::Name, Namespace)\n         {\n             let name = tcx.impl_or_trait_item(item.def_id()).name();\n             (name, match *item {"}, {"sha": "53ec72abac05fff64c5677a1304cd950d8e14f36", "filename": "src/librustc_typeck/coherence/unsafety.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc_typeck%2Fcoherence%2Funsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc_typeck%2Fcoherence%2Funsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Funsafety.rs?ref=76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4", "patch": "@@ -15,13 +15,13 @@ use rustc::ty::TyCtxt;\n use rustc::hir::intravisit;\n use rustc::hir;\n \n-pub fn check(tcx: TyCtxt) {\n+pub fn check<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     let mut orphan = UnsafetyChecker { tcx: tcx };\n     tcx.map.krate().visit_all_items(&mut orphan);\n }\n \n struct UnsafetyChecker<'cx, 'tcx:'cx> {\n-    tcx: TyCtxt<'cx, 'tcx>\n+    tcx: TyCtxt<'cx, 'tcx, 'tcx>\n }\n \n impl<'cx, 'tcx, 'v> UnsafetyChecker<'cx, 'tcx> {"}, {"sha": "25ae23cd5317084b7533dbbee1420fabefb86cab", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 39, "deletions": 18, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4", "patch": "@@ -295,8 +295,8 @@ impl<'a,'tcx> ItemCtxt<'a,'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> AstConv<'tcx> for ItemCtxt<'a, 'tcx> {\n-    fn tcx<'b>(&'b self) -> TyCtxt<'b, 'tcx> { self.ccx.tcx }\n+impl<'a, 'tcx> AstConv<'tcx, 'tcx> for ItemCtxt<'a, 'tcx> {\n+    fn tcx<'b>(&'b self) -> TyCtxt<'b, 'tcx, 'tcx> { self.ccx.tcx }\n \n     fn get_item_type_scheme(&self, span: Span, id: DefId)\n                             -> Result<ty::TypeScheme<'tcx>, ErrorReported>\n@@ -353,16 +353,37 @@ impl<'a, 'tcx> AstConv<'tcx> for ItemCtxt<'a, 'tcx> {\n         }\n     }\n \n-        fn ty_infer(&self,\n-                    _ty_param_def: Option<ty::TypeParameterDef<'tcx>>,\n-                    _substs: Option<&mut Substs<'tcx>>,\n-                    _space: Option<ParamSpace>,\n-                    span: Span) -> Ty<'tcx> {\n+    fn get_free_substs(&self) -> Option<&Substs<'tcx>> {\n+        None\n+    }\n+\n+    fn ty_infer(&self,\n+                _ty_param_def: Option<ty::TypeParameterDef<'tcx>>,\n+                _substs: Option<&mut Substs<'tcx>>,\n+                _space: Option<ParamSpace>,\n+                span: Span) -> Ty<'tcx> {\n         span_err!(self.tcx().sess, span, E0121,\n                   \"the type placeholder `_` is not allowed within types on item signatures\");\n         self.tcx().types.err\n     }\n \n+    fn projected_ty_from_poly_trait_ref(&self,\n+                                        span: Span,\n+                                        poly_trait_ref: ty::PolyTraitRef<'tcx>,\n+                                        item_name: ast::Name)\n+                                        -> Ty<'tcx>\n+    {\n+        if let Some(trait_ref) = self.tcx().no_late_bound_regions(&poly_trait_ref) {\n+            self.projected_ty(span, trait_ref, item_name)\n+        } else {\n+            // no late-bound regions, we can just ignore the binder\n+            span_err!(self.tcx().sess, span, E0212,\n+                \"cannot extract an associated type from a higher-ranked trait bound \\\n+                 in this context\");\n+            self.tcx().types.err\n+        }\n+    }\n+\n     fn projected_ty(&self,\n                     _span: Span,\n                     trait_ref: ty::TraitRef<'tcx>,\n@@ -381,7 +402,7 @@ impl<'a, 'tcx> AstConv<'tcx> for ItemCtxt<'a, 'tcx> {\n /// an `ItemCtxt`. This allows us to use multiple kinds of sources.\n trait GetTypeParameterBounds<'tcx> {\n     fn get_type_parameter_bounds(&self,\n-                                 astconv: &AstConv<'tcx>,\n+                                 astconv: &AstConv<'tcx, 'tcx>,\n                                  span: Span,\n                                  node_id: ast::NodeId)\n                                  -> Vec<ty::Predicate<'tcx>>;\n@@ -392,7 +413,7 @@ impl<'a,'b,'tcx,A,B> GetTypeParameterBounds<'tcx> for (&'a A,&'b B)\n     where A : GetTypeParameterBounds<'tcx>, B : GetTypeParameterBounds<'tcx>\n {\n     fn get_type_parameter_bounds(&self,\n-                                 astconv: &AstConv<'tcx>,\n+                                 astconv: &AstConv<'tcx, 'tcx>,\n                                  span: Span,\n                                  node_id: ast::NodeId)\n                                  -> Vec<ty::Predicate<'tcx>>\n@@ -406,7 +427,7 @@ impl<'a,'b,'tcx,A,B> GetTypeParameterBounds<'tcx> for (&'a A,&'b B)\n /// Empty set of bounds.\n impl<'tcx> GetTypeParameterBounds<'tcx> for () {\n     fn get_type_parameter_bounds(&self,\n-                                 _astconv: &AstConv<'tcx>,\n+                                 _astconv: &AstConv<'tcx, 'tcx>,\n                                  _span: Span,\n                                  _node_id: ast::NodeId)\n                                  -> Vec<ty::Predicate<'tcx>>\n@@ -420,7 +441,7 @@ impl<'tcx> GetTypeParameterBounds<'tcx> for () {\n /// from the trait/impl have been fully converted.\n impl<'tcx> GetTypeParameterBounds<'tcx> for ty::GenericPredicates<'tcx> {\n     fn get_type_parameter_bounds(&self,\n-                                 astconv: &AstConv<'tcx>,\n+                                 astconv: &AstConv<'tcx, 'tcx>,\n                                  _span: Span,\n                                  node_id: ast::NodeId)\n                                  -> Vec<ty::Predicate<'tcx>>\n@@ -459,7 +480,7 @@ impl<'tcx> GetTypeParameterBounds<'tcx> for ty::GenericPredicates<'tcx> {\n /// bounds for a type parameter `X` if `X::Foo` is used.\n impl<'tcx> GetTypeParameterBounds<'tcx> for hir::Generics {\n     fn get_type_parameter_bounds(&self,\n-                                 astconv: &AstConv<'tcx>,\n+                                 astconv: &AstConv<'tcx, 'tcx>,\n                                  _: Span,\n                                  node_id: ast::NodeId)\n                                  -> Vec<ty::Predicate<'tcx>>\n@@ -498,7 +519,7 @@ impl<'tcx> GetTypeParameterBounds<'tcx> for hir::Generics {\n /// parameter with id `param_id`. We use this so as to avoid running\n /// `ast_ty_to_ty`, because we want to avoid triggering an all-out\n /// conversion of the type to avoid inducing unnecessary cycles.\n-fn is_param<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx>,\n+fn is_param<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                       ast_ty: &hir::Ty,\n                       param_id: ast::NodeId)\n                       -> bool\n@@ -1664,7 +1685,7 @@ fn ty_generic_predicates_for_fn<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n }\n \n // Add the Sized bound, unless the type parameter is marked as `?Sized`.\n-fn add_unsized_bound<'tcx>(astconv: &AstConv<'tcx>,\n+fn add_unsized_bound<'tcx>(astconv: &AstConv<'tcx, 'tcx>,\n                            bounds: &mut ty::BuiltinBounds,\n                            ast_bounds: &[hir::TyParamBound],\n                            span: Span)\n@@ -2008,7 +2029,7 @@ enum SizedByDefault { Yes, No, }\n /// Translate the AST's notion of ty param bounds (which are an enum consisting of a newtyped Ty or\n /// a region) to ty's notion of ty param bounds, which can either be user-defined traits, or the\n /// built-in trait (formerly known as kind): Send.\n-fn compute_bounds<'tcx>(astconv: &AstConv<'tcx>,\n+fn compute_bounds<'tcx>(astconv: &AstConv<'tcx, 'tcx>,\n                         param_ty: ty::Ty<'tcx>,\n                         ast_bounds: &[hir::TyParamBound],\n                         sized_by_default: SizedByDefault,\n@@ -2038,7 +2059,7 @@ fn compute_bounds<'tcx>(astconv: &AstConv<'tcx>,\n /// because this can be anywhere from 0 predicates (`T:?Sized` adds no\n /// predicates) to 1 (`T:Foo`) to many (`T:Bar<X=i32>` adds `T:Bar`\n /// and `<T as Bar>::X == i32`).\n-fn predicates_from_bound<'tcx>(astconv: &AstConv<'tcx>,\n+fn predicates_from_bound<'tcx>(astconv: &AstConv<'tcx, 'tcx>,\n                                param_ty: Ty<'tcx>,\n                                bound: &hir::TyParamBound)\n                                -> Vec<ty::Predicate<'tcx>>\n@@ -2063,7 +2084,7 @@ fn predicates_from_bound<'tcx>(astconv: &AstConv<'tcx>,\n     }\n }\n \n-fn conv_poly_trait_ref<'tcx>(astconv: &AstConv<'tcx>,\n+fn conv_poly_trait_ref<'tcx>(astconv: &AstConv<'tcx, 'tcx>,\n                              param_ty: Ty<'tcx>,\n                              trait_ref: &hir::PolyTraitRef,\n                              projections: &mut Vec<ty::PolyProjectionPredicate<'tcx>>)\n@@ -2076,7 +2097,7 @@ fn conv_poly_trait_ref<'tcx>(astconv: &AstConv<'tcx>,\n                                         projections)\n }\n \n-fn conv_param_bounds<'a,'tcx>(astconv: &AstConv<'tcx>,\n+fn conv_param_bounds<'a,'tcx>(astconv: &AstConv<'tcx, 'tcx>,\n                               span: Span,\n                               param_ty: ty::Ty<'tcx>,\n                               ast_bounds: &[hir::TyParamBound])"}, {"sha": "0fb751f370055f1231d8504f5df53541e6d04f6a", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4", "patch": "@@ -149,7 +149,7 @@ pub struct CrateCtxt<'a, 'tcx: 'a> {\n     /// Note that these cycles can cross multiple items.\n     pub stack: RefCell<Vec<collect::AstConvRequest>>,\n \n-    pub tcx: TyCtxt<'a, 'tcx>,\n+    pub tcx: TyCtxt<'a, 'tcx, 'tcx>,\n }\n \n // Functions that write types into the node type table\n@@ -193,7 +193,7 @@ fn require_c_abi_if_variadic(tcx: TyCtxt,\n }\n \n fn require_same_types<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n-                                maybe_infcx: Option<&infer::InferCtxt<'a, 'tcx>>,\n+                                maybe_infcx: Option<&infer::InferCtxt<'a, 'tcx, 'tcx>>,\n                                 span: Span,\n                                 t1: Ty<'tcx>,\n                                 t2: Ty<'tcx>,\n@@ -329,7 +329,9 @@ fn check_for_entry_fn(ccx: &CrateCtxt) {\n     }\n }\n \n-pub fn check_crate(tcx: TyCtxt, trait_map: hir::TraitMap) -> CompileResult {\n+pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                             trait_map: hir::TraitMap)\n+                             -> CompileResult {\n     let time_passes = tcx.sess.time_passes();\n     let ccx = CrateCtxt {\n         trait_map: trait_map,"}, {"sha": "d4d16a607899bc058a0405442f3e3372efc55c0e", "filename": "src/librustc_typeck/variance/constraints.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs?ref=76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4", "patch": "@@ -127,7 +127,7 @@ fn is_lifetime(map: &hir_map::Map, param_id: ast::NodeId) -> bool {\n }\n \n impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n-    fn tcx(&self) -> TyCtxt<'a, 'tcx> {\n+    fn tcx(&self) -> TyCtxt<'a, 'tcx, 'tcx> {\n         self.terms_cx.tcx\n     }\n "}, {"sha": "13ed6cf7641405194950c2acf92f1e6ff70c987e", "filename": "src/librustc_typeck/variance/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc_typeck%2Fvariance%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc_typeck%2Fvariance%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fmod.rs?ref=76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4", "patch": "@@ -27,7 +27,7 @@ mod solve;\n /// Code for transforming variances.\n mod xform;\n \n-pub fn infer_variance(tcx: TyCtxt) {\n+pub fn infer_variance<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     let mut arena = arena::TypedArena::new();\n     let terms_cx = terms::determine_parameters_to_be_inferred(tcx, &mut arena);\n     let constraints_cx = constraints::add_constraints_from_crate(terms_cx);"}, {"sha": "d9e7e8cbf7df4eb16c948e1666bf239366605784", "filename": "src/librustc_typeck/variance/terms.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc_typeck%2Fvariance%2Fterms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustc_typeck%2Fvariance%2Fterms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fterms.rs?ref=76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4", "patch": "@@ -59,7 +59,7 @@ impl<'a> fmt::Debug for VarianceTerm<'a> {\n // The first pass over the crate simply builds up the set of inferreds.\n \n pub struct TermsContext<'a, 'tcx: 'a> {\n-    pub tcx: TyCtxt<'a, 'tcx>,\n+    pub tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     pub arena: &'a TypedArena<VarianceTerm<'a>>,\n \n     pub empty_variances: Rc<ty::ItemVariances>,\n@@ -98,7 +98,7 @@ pub struct InferredInfo<'a> {\n }\n \n pub fn determine_parameters_to_be_inferred<'a, 'tcx>(\n-    tcx: TyCtxt<'a, 'tcx>,\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     arena: &'a mut TypedArena<VarianceTerm<'a>>)\n     -> TermsContext<'a, 'tcx>\n {"}, {"sha": "c9df54dfef267ad83638f05988a35d0e099e514b", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 31, "deletions": 28, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4", "patch": "@@ -68,8 +68,8 @@ pub fn try_inline(cx: &DocContext, id: ast::NodeId, into: Option<ast::Name>)\n     })\n }\n \n-fn try_inline_def(cx: &DocContext, tcx: TyCtxt,\n-                  def: Def) -> Option<Vec<clean::Item>> {\n+fn try_inline_def<'a, 'tcx>(cx: &DocContext, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                            def: Def) -> Option<Vec<clean::Item>> {\n     let mut ret = Vec::new();\n     let did = def.def_id();\n     let inner = match def {\n@@ -130,8 +130,8 @@ fn try_inline_def(cx: &DocContext, tcx: TyCtxt,\n     Some(ret)\n }\n \n-pub fn load_attrs(cx: &DocContext, tcx: TyCtxt,\n-                  did: DefId) -> Vec<clean::Attribute> {\n+pub fn load_attrs<'a, 'tcx>(cx: &DocContext, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                            did: DefId) -> Vec<clean::Attribute> {\n     tcx.get_attrs(did).iter().map(|a| a.clean(cx)).collect()\n }\n \n@@ -150,8 +150,8 @@ pub fn record_extern_fqn(cx: &DocContext, did: DefId, kind: clean::TypeKind) {\n     }\n }\n \n-pub fn build_external_trait(cx: &DocContext, tcx: TyCtxt,\n-                            did: DefId) -> clean::Trait {\n+pub fn build_external_trait<'a, 'tcx>(cx: &DocContext, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                      did: DefId) -> clean::Trait {\n     let def = tcx.lookup_trait_def(did);\n     let trait_items = tcx.trait_items(did).clean(cx);\n     let predicates = tcx.lookup_predicates(did);\n@@ -166,7 +166,8 @@ pub fn build_external_trait(cx: &DocContext, tcx: TyCtxt,\n     }\n }\n \n-fn build_external_function(cx: &DocContext, tcx: TyCtxt, did: DefId) -> clean::Function {\n+fn build_external_function<'a, 'tcx>(cx: &DocContext, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                     did: DefId) -> clean::Function {\n     let t = tcx.lookup_item_type(did);\n     let (decl, style, abi) = match t.ty.sty {\n         ty::TyFnDef(_, _, ref f) => ((did, &f.sig).clean(cx), f.unsafety, f.abi),\n@@ -189,7 +190,8 @@ fn build_external_function(cx: &DocContext, tcx: TyCtxt, did: DefId) -> clean::F\n     }\n }\n \n-fn build_struct(cx: &DocContext, tcx: TyCtxt, did: DefId) -> clean::Struct {\n+fn build_struct<'a, 'tcx>(cx: &DocContext, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                          did: DefId) -> clean::Struct {\n     let t = tcx.lookup_item_type(did);\n     let predicates = tcx.lookup_predicates(did);\n     let variant = tcx.lookup_adt_def(did).struct_variant();\n@@ -207,7 +209,8 @@ fn build_struct(cx: &DocContext, tcx: TyCtxt, did: DefId) -> clean::Struct {\n     }\n }\n \n-fn build_type(cx: &DocContext, tcx: TyCtxt, did: DefId) -> clean::ItemEnum {\n+fn build_type<'a, 'tcx>(cx: &DocContext, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                        did: DefId) -> clean::ItemEnum {\n     let t = tcx.lookup_item_type(did);\n     let predicates = tcx.lookup_predicates(did);\n     match t.ty.sty {\n@@ -227,9 +230,9 @@ fn build_type(cx: &DocContext, tcx: TyCtxt, did: DefId) -> clean::ItemEnum {\n     }, false)\n }\n \n-pub fn build_impls(cx: &DocContext,\n-                   tcx: TyCtxt,\n-                   did: DefId) -> Vec<clean::Item> {\n+pub fn build_impls<'a, 'tcx>(cx: &DocContext,\n+                             tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                             did: DefId) -> Vec<clean::Item> {\n     tcx.populate_inherent_implementations_for_type_if_necessary(did);\n     let mut impls = Vec::new();\n \n@@ -252,9 +255,9 @@ pub fn build_impls(cx: &DocContext,\n             populate_impls(cx, tcx, item.def, &mut impls);\n         }\n \n-        fn populate_impls(cx: &DocContext, tcx: TyCtxt,\n-                          def: cstore::DefLike,\n-                          impls: &mut Vec<clean::Item>) {\n+        fn populate_impls<'a, 'tcx>(cx: &DocContext, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                    def: cstore::DefLike,\n+                                    impls: &mut Vec<clean::Item>) {\n             match def {\n                 cstore::DlImpl(did) => build_impl(cx, tcx, did, impls),\n                 cstore::DlDef(Def::Mod(did)) => {\n@@ -270,10 +273,10 @@ pub fn build_impls(cx: &DocContext,\n     impls\n }\n \n-pub fn build_impl(cx: &DocContext,\n-                  tcx: TyCtxt,\n-                  did: DefId,\n-                  ret: &mut Vec<clean::Item>) {\n+pub fn build_impl<'a, 'tcx>(cx: &DocContext,\n+                            tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                            did: DefId,\n+                            ret: &mut Vec<clean::Item>) {\n     if !cx.renderinfo.borrow_mut().inlined.insert(did) {\n         return\n     }\n@@ -441,17 +444,17 @@ pub fn build_impl(cx: &DocContext,\n     });\n }\n \n-fn build_module(cx: &DocContext, tcx: TyCtxt,\n-                did: DefId) -> clean::Module {\n+fn build_module<'a, 'tcx>(cx: &DocContext, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                          did: DefId) -> clean::Module {\n     let mut items = Vec::new();\n     fill_in(cx, tcx, did, &mut items);\n     return clean::Module {\n         items: items,\n         is_crate: false,\n     };\n \n-    fn fill_in(cx: &DocContext, tcx: TyCtxt, did: DefId,\n-               items: &mut Vec<clean::Item>) {\n+    fn fill_in<'a, 'tcx>(cx: &DocContext, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                         did: DefId, items: &mut Vec<clean::Item>) {\n         // If we're reexporting a reexport it may actually reexport something in\n         // two namespaces, so the target may be listed twice. Make sure we only\n         // visit each node at most once.\n@@ -476,8 +479,8 @@ fn build_module(cx: &DocContext, tcx: TyCtxt,\n     }\n }\n \n-fn build_const(cx: &DocContext, tcx: TyCtxt,\n-               did: DefId) -> clean::Constant {\n+fn build_const<'a, 'tcx>(cx: &DocContext, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                         did: DefId) -> clean::Constant {\n     let (expr, ty) = lookup_const_by_id(tcx, did, None).unwrap_or_else(|| {\n         panic!(\"expected lookup_const_by_id to succeed for {:?}\", did);\n     });\n@@ -491,9 +494,9 @@ fn build_const(cx: &DocContext, tcx: TyCtxt,\n     }\n }\n \n-fn build_static(cx: &DocContext, tcx: TyCtxt,\n-                did: DefId,\n-                mutable: bool) -> clean::Static {\n+fn build_static<'a, 'tcx>(cx: &DocContext, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                          did: DefId,\n+                          mutable: bool) -> clean::Static {\n     clean::Static {\n         type_: tcx.lookup_item_type(did).ty.clean(cx),\n         mutability: if mutable {clean::Mutable} else {clean::Immutable},"}, {"sha": "895c0bb8490108336d46ed763efb05d626200219", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4", "patch": "@@ -42,7 +42,7 @@ pub use rustc::session::search_paths::SearchPaths;\n \n /// Are we generating documentation (`Typed`) or tests (`NotTyped`)?\n pub enum MaybeTyped<'a, 'tcx: 'a> {\n-    Typed(TyCtxt<'a, 'tcx>),\n+    Typed(TyCtxt<'a, 'tcx, 'tcx>),\n     NotTyped(&'a session::Session)\n }\n \n@@ -74,14 +74,14 @@ impl<'b, 'tcx> DocContext<'b, 'tcx> {\n         }\n     }\n \n-    pub fn tcx_opt<'a>(&'a self) -> Option<TyCtxt<'a, 'tcx>> {\n+    pub fn tcx_opt<'a>(&'a self) -> Option<TyCtxt<'a, 'tcx, 'tcx>> {\n         match self.maybe_typed {\n             Typed(tcx) => Some(tcx),\n             NotTyped(_) => None\n         }\n     }\n \n-    pub fn tcx<'a>(&'a self) -> TyCtxt<'a, 'tcx> {\n+    pub fn tcx<'a>(&'a self) -> TyCtxt<'a, 'tcx, 'tcx> {\n         let tcx_opt = self.tcx_opt();\n         tcx_opt.expect(\"tcx not present\")\n     }"}, {"sha": "0abf71ba444aefa49a236485305d5684fed997ee", "filename": "src/test/run-pass-fulldeps/auxiliary/dummy_mir_pass.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fdummy_mir_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fdummy_mir_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fdummy_mir_pass.rs?ref=76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4", "patch": "@@ -30,7 +30,8 @@ struct Pass;\n \n impl transform::Pass for Pass {}\n impl<'tcx> MirPass<'tcx> for Pass {\n-    fn run_pass<'a>(&mut self, _: TyCtxt<'a, 'tcx>, _: MirSource, mir: &mut Mir<'tcx>) {\n+    fn run_pass<'a>(&mut self, _: TyCtxt<'a, 'tcx, 'tcx>,\n+                    _: MirSource, mir: &mut Mir<'tcx>) {\n         Visitor.visit_mir(mir)\n     }\n }"}]}