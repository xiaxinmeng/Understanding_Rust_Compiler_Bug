{"sha": "2dd5ad0be84f8d14dc357fb35a4b21fe5a34030a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJkZDVhZDBiZTg0ZjhkMTRkYzM1N2ZiMzVhNGIyMWZlNWEzNDAzMGE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-05-18T15:39:07Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-05-18T15:39:07Z"}, "message": "Auto merge of #25501 - nham:E0072_E0073, r=alexcrichton\n\ncc #24407", "tree": {"sha": "9845be12726202aeecc09ba9fc05145539359208", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9845be12726202aeecc09ba9fc05145539359208"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2dd5ad0be84f8d14dc357fb35a4b21fe5a34030a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2dd5ad0be84f8d14dc357fb35a4b21fe5a34030a", "html_url": "https://github.com/rust-lang/rust/commit/2dd5ad0be84f8d14dc357fb35a4b21fe5a34030a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2dd5ad0be84f8d14dc357fb35a4b21fe5a34030a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "84b1e084862c08c19c36f0cf1f3698343c8ba7fa", "url": "https://api.github.com/repos/rust-lang/rust/commits/84b1e084862c08c19c36f0cf1f3698343c8ba7fa", "html_url": "https://github.com/rust-lang/rust/commit/84b1e084862c08c19c36f0cf1f3698343c8ba7fa"}, {"sha": "c69a152018de3c70e949f758d59e6aa86e19e9d4", "url": "https://api.github.com/repos/rust-lang/rust/commits/c69a152018de3c70e949f758d59e6aa86e19e9d4", "html_url": "https://github.com/rust-lang/rust/commit/c69a152018de3c70e949f758d59e6aa86e19e9d4"}], "stats": {"total": 131, "additions": 123, "deletions": 8}, "files": [{"sha": "bb60de955f0c14989e909d786c500274a13bb94c", "filename": "src/librustc_typeck/diagnostics.rs", "status": "modified", "additions": 121, "deletions": 6, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/2dd5ad0be84f8d14dc357fb35a4b21fe5a34030a/src%2Flibrustc_typeck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dd5ad0be84f8d14dc357fb35a4b21fe5a34030a/src%2Flibrustc_typeck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fdiagnostics.rs?ref=2dd5ad0be84f8d14dc357fb35a4b21fe5a34030a", "patch": "@@ -170,6 +170,63 @@ Since `return;` is just like `return ();`, there is a mismatch between the\n function's return type and the value being returned.\n \"##,\n \n+E0072: r##\"\n+When defining a recursive struct or enum, any use of the type being defined\n+from inside the definition must occur behind a pointer (like `Box` or `&`).\n+This is because structs and enums must have a well-defined size, and without\n+the pointer the size of the type would need to be unbounded.\n+\n+Consider the following erroneous definition of a type for a list of bytes:\n+\n+```\n+// error, illegal recursive struct type\n+struct ListNode {\n+    head: u8,\n+    tail: Option<ListNode>,\n+}\n+```\n+\n+This type cannot have a well-defined size, because it needs to be arbitrarily\n+large (since we would be able to nest `ListNode`s to any depth). Specifically,\n+\n+```\n+size of ListNode = 1 byte for head\n+                 + 1 byte for the discriminant of the Option\n+                 + size of ListNode\n+```\n+\n+One way to fix this is by wrapping `ListNode` in a `Box`, like so:\n+\n+```\n+struct ListNode {\n+    head: u8,\n+    tail: Option<Box<ListNode>>,\n+}\n+```\n+\n+This works because `Box` is a pointer, so its size is well-known.\n+\"##,\n+\n+E0073: r##\"\n+You cannot define a struct (or enum) `Foo` that requires an instance of `Foo`\n+in order to make a new `Foo` value. This is because there would be no way a\n+first instance of `Foo` could be made to initialize another instance!\n+\n+Here's an example of a struct that has this problem:\n+\n+```\n+struct Foo { x: Box<Foo> } // error\n+```\n+\n+One fix is to use `Option`, like so:\n+\n+```\n+struct Foo { x: Option<Box<Foo>> }\n+```\n+\n+Now it's possible to create at least one instance of `Foo`: `Foo { x: None }`.\n+\"##,\n+\n E0081: r##\"\n Enum discriminants are used to differentiate enum variants stored in memory.\n This error indicates that the same value was used for two or more variants,\n@@ -327,6 +384,19 @@ RFC. It is, however, [currently unimplemented][iss15872].\n [iss15872]: https://github.com/rust-lang/rust/issues/15872\n \"##,\n \n+E0121: r##\"\n+In order to be consistent with Rust's lack of global type inference, type\n+placeholders are disallowed by design in item signatures.\n+\n+Examples of this error include:\n+\n+```\n+fn foo() -> _ { 5 } // error, explicitly write out the return type instead\n+\n+static BAR: _ = \"test\"; // error, explicitly write out the type instead\n+```\n+\"##,\n+\n E0131: r##\"\n It is not possible to define `main` with type parameters, or even with function\n parameters. When `main` is present, it must take no arguments and return `()`.\n@@ -355,6 +425,28 @@ return, for example with a `loop` that never breaks or a call to another\n diverging function (such as `panic!()`).\n \"##,\n \n+E0178: r##\"\n+In types, the `+` type operator has low precedence, so it is often necessary\n+to use parentheses.\n+\n+For example:\n+\n+```\n+trait Foo {}\n+\n+struct Bar<'a> {\n+    w: &'a Foo + Copy,   // error, use &'a (Foo + Copy)\n+    x: &'a Foo + 'a,     // error, use &'a (Foo + 'a)\n+    y: &'a mut Foo + 'a, // error, use &'a mut (Foo + 'a)\n+    z: fn() -> Foo + 'a, // error, use fn() -> (Foo + 'a)\n+}\n+```\n+\n+More details can be found in [RFC 438].\n+\n+[RFC 438]: https://github.com/rust-lang/rfcs/pull/438\n+\"##,\n+\n E0184: r##\"\n Explicitly implementing both Drop and Copy for a type is currently disallowed.\n This feature can make some sense in theory, but the current implementation is\n@@ -632,6 +724,35 @@ traits, so it is not possible to overload them. See [RFC 953] for a proposal\n to change this.\n \n [RFC 953]: https://github.com/rust-lang/rfcs/pull/953\n+\"##,\n+\n+E0371: r##\"\n+When `Trait2` is a subtrait of `Trait1` (for example, when `Trait2` has a\n+definition like `trait Trait2: Trait1 { ... }`), it is not allowed to implement\n+`Trait1` for `Trait2`. This is because `Trait2` already implements `Trait1` by\n+definition, so it is not useful to do this.\n+\n+Example:\n+\n+```\n+trait Foo { fn foo(&self) { } }\n+trait Bar: Foo { }\n+trait Baz: Bar { }\n+\n+impl Bar for Baz { } // error, `Baz` implements `Bar` by definition\n+impl Foo for Baz { } // error, `Baz` implements `Bar` which implements `Foo`\n+impl Baz for Baz { } // error, `Baz` (trivially) implements `Baz`\n+impl Baz for Bar { } // Note: This is OK\n+```\n+\"##,\n+\n+E0372: r##\"\n+Trying to implement a trait for a trait object (as in `impl Trait1 for\n+Trait2 { ... }`) does not work if the trait is not object-safe. Please see the\n+[RFC 255] for more details on object safety rules.\n+\n+[RFC 255]:https://github.com/rust-lang/rfcs/blob/master/text/0255-object-\\\n+safety.md\n \"##\n \n }\n@@ -660,8 +781,6 @@ register_diagnostics! {\n     E0068,\n     E0070,\n     E0071,\n-    E0072,\n-    E0073,\n     E0074,\n     E0075,\n     E0076,\n@@ -685,7 +804,6 @@ register_diagnostics! {\n     E0118,\n     E0119,\n     E0120,\n-    E0121,\n     E0122,\n     E0123,\n     E0124,\n@@ -702,7 +820,6 @@ register_diagnostics! {\n     E0172,\n     E0173, // manual implementations of unboxed closure traits are experimental\n     E0174, // explicit use of unboxed closure methods are experimental\n-    E0178,\n     E0182,\n     E0183,\n     E0185,\n@@ -774,8 +891,6 @@ register_diagnostics! {\n     E0366, // dropck forbid specialization to concrete type or region\n     E0367, // dropck forbid specialization to predicate not in struct/enum\n     E0369, // binary operation `<op>` cannot be applied to types\n-    E0371, // impl Trait for Trait is illegal\n-    E0372, // impl Trait for Trait where Trait is not object safe\n     E0374, // the trait `CoerceUnsized` may only be implemented for a coercion\n            // between structures with one field being coerced, none found\n     E0375, // the trait `CoerceUnsized` may only be implemented for a coercion"}, {"sha": "332965cc94014ae89e9ecdb98abfe974c98d3ad9", "filename": "src/test/compile-fail/coherence-impl-trait-for-trait.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2dd5ad0be84f8d14dc357fb35a4b21fe5a34030a/src%2Ftest%2Fcompile-fail%2Fcoherence-impl-trait-for-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2dd5ad0be84f8d14dc357fb35a4b21fe5a34030a/src%2Ftest%2Fcompile-fail%2Fcoherence-impl-trait-for-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcoherence-impl-trait-for-trait.rs?ref=2dd5ad0be84f8d14dc357fb35a4b21fe5a34030a", "patch": "@@ -15,14 +15,14 @@ trait Foo { fn dummy(&self) { } }\n trait Bar: Foo { }\n trait Baz: Bar { }\n \n-// Subtraits of Baz are not legal:\n+// Supertraits of Baz are not legal:\n impl Foo for Baz { }   //~ ERROR E0371\n impl Bar for Baz { }   //~ ERROR E0371\n impl Baz for Baz { }   //~ ERROR E0371\n \n // But other random traits are:\n trait Other { }\n-impl Other for Baz { } // OK, Bar not a subtrait of Baz\n+impl Other for Baz { } // OK, Other not a supertrait of Baz\n \n // If the trait is not object-safe, we give a more tailored message\n // because we're such schnuckels:"}]}