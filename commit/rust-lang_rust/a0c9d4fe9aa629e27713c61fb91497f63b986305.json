{"sha": "a0c9d4fe9aa629e27713c61fb91497f63b986305", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEwYzlkNGZlOWFhNjI5ZTI3NzEzYzYxZmI5MTQ5N2Y2M2I5ODYzMDU=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2010-07-01T16:37:28Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2010-07-01T16:37:28Z"}, "message": "Strip out over-aggressive pagination in manual.", "tree": {"sha": "8a950d5b8fb677af7ee61478eeb3030e2c726f4a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8a950d5b8fb677af7ee61478eeb3030e2c726f4a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a0c9d4fe9aa629e27713c61fb91497f63b986305", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a0c9d4fe9aa629e27713c61fb91497f63b986305", "html_url": "https://github.com/rust-lang/rust/commit/a0c9d4fe9aa629e27713c61fb91497f63b986305", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a0c9d4fe9aa629e27713c61fb91497f63b986305/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8bf6ae99f4874bcc8ae97b6173528e5fad649838", "url": "https://api.github.com/repos/rust-lang/rust/commits/8bf6ae99f4874bcc8ae97b6173528e5fad649838", "html_url": "https://github.com/rust-lang/rust/commit/8bf6ae99f4874bcc8ae97b6173528e5fad649838"}], "stats": {"total": 83, "additions": 0, "deletions": 83}, "files": [{"sha": "8a6a8b1b5da7f065c15c57ff67e7fd0ae6572a0d", "filename": "doc/rust.texi", "status": "modified", "additions": 0, "deletions": 83, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/a0c9d4fe9aa629e27713c61fb91497f63b986305/doc%2Frust.texi", "raw_url": "https://github.com/rust-lang/rust/raw/a0c9d4fe9aa629e27713c61fb91497f63b986305/doc%2Frust.texi", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Frust.texi?ref=a0c9d4fe9aa629e27713c61fb91497f63b986305", "patch": "@@ -551,7 +551,6 @@ Additional specific influences can be seen from the following languages:\n * Ref.Run::                     Organization of runtime services.\n @end menu\n \n-@page\n @node    Ref.Lex\n @section Ref.Lex\n @c * Ref.Lex::                     Lexical structure.\n@@ -700,7 +699,6 @@ The keywords are:\n @tab @code{be}\n @end multitable\n \n-@page\n @node       Ref.Lex.Num\n @subsection Ref.Lex.Num\n @c * Ref.Lex.Num::                 Numeric tokens.\n@@ -793,7 +791,6 @@ region). @xref{Ref.Comp.Syntax}.\n \n @emph{TODO: formalize those terms more}.\n \n-@page\n @node       Ref.Lex.Sym\n @subsection Ref.Lex.Sym\n @c * Ref.Lex.Sym::                 Special symbol tokens.\n@@ -953,7 +950,6 @@ successful produces a single crate in executable form.\n * Ref.Comp.Syntax::             Syntax extensions.\n @end menu\n \n-@page\n @node       Ref.Comp.Crate\n @subsection Ref.Comp.Crate\n @c * Ref.Comp.Crate::              Units of compilation and linking.\n@@ -1044,7 +1040,6 @@ mod bar @{\n @}\n @end example\n \n-@page\n @node       Ref.Comp.Meta\n @subsection Ref.Comp.Meta\n \n@@ -1055,7 +1050,6 @@ directives, denoted by @code{syntax} and @code{use} keywords respectively.\n \n Alternatively, metadata can serve as a simple form of documentation.\n \n-@page\n @node          Ref.Comp.Syntax\n @subsection    Ref.Comp.Syntax\n @c * Ref.Comp.Syntax::        Syntax extension.\n@@ -1123,7 +1117,6 @@ consist of @emph{boxes}.\n * Ref.Mem.Acct::                Memory accounting model.\n @end menu\n \n-@page\n @node       Ref.Mem.Alloc\n @subsection Ref.Mem.Alloc\n @c * Ref.Mem.Alloc::               Memory allocation model.\n@@ -1156,8 +1149,6 @@ heap allocation, so executing a long-running destructor does not interrupt\n execution of other tasks.\n \n \n-\n-@page\n @node       Ref.Mem.Own\n @subsection Ref.Mem.Own\n @c * Ref.Mem.Own::                 Memory ownership model.\n@@ -1180,7 +1171,6 @@ references to boxes (both shared and owned) are dropped.\n When a task finishes, its stack is necessarily empty and it therefore has no\n references to any boxes.\n \n-@page\n @node       Ref.Mem.Slot\n @subsection Ref.Mem.Slot\n @c * Ref.Mem.Slot::                Stack memory model.\n@@ -1228,7 +1218,6 @@ fn incr(& mutable int i) @{\n @}\n @end example\n \n-@page\n @node       Ref.Mem.Box\n @subsection Ref.Mem.Box\n @c * Ref.Mem.Box::                 Heap memory model.\n@@ -1284,7 +1273,6 @@ fn main() @{\n @end example\n \n \n-@page\n @node       Ref.Mem.Acct\n @subsection Ref.Mem.Acct\n @c * Ref.Mem.Acct::                Memory accounting model.\n@@ -1330,7 +1318,6 @@ operating-system processes.\n * Ref.Task.Sched::              Task scheduling model.\n @end menu\n \n-@page\n @node       Ref.Task.Comm\n @subsection Ref.Task.Comm\n @c * Ref.Task.Comm::               Inter-task communication.\n@@ -1384,7 +1371,6 @@ The asynchronous message-send operator is @code{<+}. The semi-synchronous\n message-send operator is @code{<|}. @xref{Ref.Stmt.Send}. The message-receive\n operator is @code{<-}. @xref{Ref.Stmt.Recv}.\n \n-@page\n @node       Ref.Task.Life\n @subsection Ref.Task.Life\n @c * Ref.Task.Life::               Task lifecycle and state transitions.\n@@ -1426,7 +1412,6 @@ A task in the @emph{dead} state cannot transition to other states; it exists\n only to have its termination status inspected by other tasks, and/or to await\n reclamation when the last reference to it drops.\n \n-@page\n @node       Ref.Task.Dom\n @subsection Ref.Task.Dom\n @c * Ref.Task.Dom::                Task domains\n@@ -1448,7 +1433,6 @@ Tasks can own sub-domains, which in turn own their own tasks. Every domain\n owns one @emph{root task}, which is the root of the tree of tasks owned by the\n domain.\n \n-@page\n @node       Ref.Task.Sched\n @subsection Ref.Task.Sched\n @c * Ref.Task.Sched::              Task scheduling model.\n@@ -1502,7 +1486,6 @@ are no general parametric types.\n * Ref.Item.Type::               Items defining the types of values and slots.\n @end menu\n \n-@page\n @node       Ref.Item.Mod\n @subsection Ref.Item.Mod\n @c * Ref.Item.Mod::           Items defining sub-modules.\n@@ -1540,7 +1523,6 @@ and outside of it.\n * Ref.Item.Mod.Export::            Declarations for restricting visibility.\n @end menu\n \n-@page\n @node          Ref.Item.Mod.Import\n @subsubsection Ref.Item.Mod.Import\n @c * Ref.Item.Mod.Import::     Declarations for module-local synonyms.\n@@ -1563,7 +1545,6 @@ fn main() @{\n @}\n @end example\n \n-@page\n @node          Ref.Item.Mod.Export\n @subsubsection Ref.Item.Mod.Export\n @c * Ref.Item.Mod.Import::     Declarations for restricting visibility.\n@@ -1596,8 +1577,6 @@ fn main() @{\n @end example\n \n \n-\n-@page\n @node       Ref.Item.Fn\n @subsection Ref.Item.Fn\n @c * Ref.Item.Fn::            Items defining functions.\n@@ -1633,7 +1612,6 @@ fn add(int x, int y) -> int @{\n @}\n @end example\n \n-@page\n @node          Ref.Item.Iter\n @subsection    Ref.Item.Iter\n @c * Ref.Item.Iter::          Items defining iterators.\n@@ -1672,7 +1650,6 @@ for each (int x = range(0,100)) @{\n @end example\n \n \n-@page\n @node       Ref.Item.Obj\n @subsection Ref.Item.Obj\n @c * Ref.Item.Obj::          Items defining objects.\n@@ -1704,7 +1681,6 @@ c.incr();\n check (c.get() == 3);\n @end example\n \n-@page\n @node       Ref.Item.Type\n @subsection Ref.Item.Type\n @c * Ref.Item.Type::          Items defining the types of values and slots.\n@@ -1769,7 +1745,6 @@ Rust; they cannot be used as user-defined identifiers in any context.\n * Ref.Type.Type::               Types describing types.\n @end menu\n \n-@page\n @node       Ref.Type.Any\n @subsection Ref.Type.Any\n \n@@ -1781,7 +1756,6 @@ Values of type @code{any} can be used in an @code{alt type} statement, in\n which the reflection is used to select a block corresponding to a particular\n type extraction. @xref{Ref.Stmt.Alt}.\n \n-@page\n @node       Ref.Type.Mach\n @subsection Ref.Type.Mach\n \n@@ -1829,7 +1803,6 @@ The IEEE 754 single-precision and double-precision floating point types:\n @code{f32} and @code{f64}, respectively.\n @end itemize\n \n-@page\n @node       Ref.Type.Int\n @subsection Ref.Type.Int\n \n@@ -1881,7 +1854,6 @@ The machine-dependent integer and floating-point types.\n @end itemize\n \n \n-@page\n @node       Ref.Type.Big\n @subsection Ref.Type.Big\n \n@@ -1895,7 +1867,6 @@ A Rust @code{big} grows to accommodate extra binary digits as they are needed,\n by taking extra memory from the memory budget available to each Rust task, and\n should only exhaust its range due to memory exhaustion.\n \n-@page\n @node       Ref.Type.Text\n @subsection Ref.Type.Text\n \n@@ -1907,7 +1878,6 @@ unsigned word holding a UCS-4 codepoint.\n A value of type @code{str} is a Unicode string, represented as a vector of\n 8-bit unsigned bytes holding a sequence of UTF-8 codepoints.\n \n-@page\n @node       Ref.Type.Rec\n @subsection Ref.Type.Rec\n \n@@ -1925,7 +1895,6 @@ let point p = rec(x=10, y=11);\n let int px = p.x;\n @end example\n \n-@page\n @node       Ref.Type.Tup\n @subsection Ref.Type.Tup\n \n@@ -1946,7 +1915,6 @@ check (p._1 == \"world\");\n @end example\n \n \n-@page\n @node       Ref.Type.Vec\n @subsection Ref.Type.Vec\n \n@@ -1985,7 +1953,6 @@ All accessible elements of a vector are always initialized, and access to a\n vector is always bounds-checked.\n \n \n-@page\n @node       Ref.Type.Tag\n @subsection Ref.Type.Tag\n \n@@ -2024,7 +1991,6 @@ let list[int] a = cons(7, cons(13, nil));\n @end example\n \n \n-@page\n @node       Ref.Type.Fn\n @subsection Ref.Type.Fn\n \n@@ -2046,7 +2012,6 @@ let binop bo = add;\n x = bo(5,7);\n @end example\n \n-@page\n @node       Ref.Type.Iter\n @subsection Ref.Type.Iter\n \n@@ -2069,7 +2034,6 @@ for each (int i = range(5,7)) @{\n @end example\n \n \n-@page\n @node       Ref.Type.Port\n @subsection Ref.Type.Port\n \n@@ -2091,7 +2055,6 @@ let vec[str] v;\n v <- p;\n @end example\n \n-@page\n @node       Ref.Type.Chan\n @subsection Ref.Type.Chan\n \n@@ -2126,7 +2089,6 @@ let vec[str] v = vec(\"hello\", \"world\");\n c <| v;\n @end example\n \n-@page\n @node       Ref.Type.Task\n @subsection Ref.Type.Task\n \n@@ -2147,7 +2109,6 @@ holding those references), the released task immediately fails.\n @xref{Ref.Task.Life}.\n \n \n-@page\n @node       Ref.Type.Obj\n @subsection Ref.Type.Obj\n @c * Ref.Type.Obj::                Object types.\n@@ -2213,7 +2174,6 @@ give_ints(t2);\n \n \n \n-@page\n @node       Ref.Type.Constr\n @subsection Ref.Type.Constr\n @c * Ref.Type.Constr::             Constrained types.\n@@ -2239,7 +2199,6 @@ let ordered_range rng2 = rec(low=15, high=17);\n // implicit: 'check less_than(rng2.low, rng2.high);'\n @end example\n \n-@page\n @node       Ref.Type.Type\n @subsection Ref.Type.Type\n @c * Ref.Type.Type::               Types describing types.\n@@ -2302,7 +2261,6 @@ actions.\n * Ref.Stmt.IfCheck::            Statement for dynamic testing of typestate.\n @end menu\n \n-@page\n @node       Ref.Stmt.Stat\n @subsection Ref.Stmt.Stat\n @c * Ref.Stmt.Stat::         The static typestate system of statement analysis.\n@@ -2326,7 +2284,6 @@ system.\n * Ref.Stmt.Stat.Check::         Relating dynamic state to static typestate.\n @end menu\n \n-@page\n @node          Ref.Stmt.Stat.Point\n @subsubsection Ref.Stmt.Stat.Point\n @c * Ref.Stmt.Stat.Point::         Inter-statement positions of logical judgements.\n@@ -2358,7 +2315,6 @@ concerned with constraining the possible states of a task's memory at\n ``at'' a statement, as each statement is likely to change the contents of\n memory.\n \n-@page\n @node          Ref.Stmt.Stat.CFG\n @subsubsection Ref.Stmt.Stat.CFG\n @c * Ref.Stmt.Stat.CFG::           The control flow graph formed by statements.\n@@ -2372,7 +2328,6 @@ might occur during execution.\n \n This implicit graph is called the @dfn{control flow graph}, or @dfn{CFG}.\n \n-@page\n @node          Ref.Stmt.Stat.Constr\n @subsubsection Ref.Stmt.Stat.Constr\n @c * Ref.Stmt.Stat.Constr::          Predicates applied to slots.\n@@ -2403,7 +2358,6 @@ Predicates can only apply to slots holding immutable values. The slots a\n predicate applies to can themselves be mutable, but the types of values held\n in those slots must be immutable.\n \n-@page\n @node          Ref.Stmt.Stat.Cond\n @subsubsection Ref.Stmt.Stat.Cond\n @c * Ref.Stmt.Stat.Cond::          Constraints required and implied by a statement.\n@@ -2422,7 +2376,6 @@ enforces in the point after the statement.\n Any constraint present in the precondition and @emph{absent} in the\n postcondition is considered to be @emph{dropped} by the statement.\n \n-@page\n @node          Ref.Stmt.Stat.Typestate\n @subsubsection Ref.Stmt.Stat.Typestate\n @c * Ref.Stmt.Stat.Typestate::     Constraints that hold at points.\n@@ -2471,7 +2424,6 @@ prestate. If any preconditions are not satisfied, the mismatch is considered a\n static (compile-time) error.\n \n \n-@page\n @node          Ref.Stmt.Stat.Check\n @subsubsection Ref.Stmt.Stat.Check\n @c * Ref.Stmt.Stat.Check::         Relating dynamic state to static typestate.\n@@ -2503,7 +2455,6 @@ and constrained types, and the responsibility to @code{check} a constraint\n pushed further and further away from the site at which the program requires it\n to hold in order to execute properly.\n \n-@page\n @node       Ref.Stmt.Decl\n @subsection Ref.Stmt.Decl\n @c * Ref.Stmt.Decl::                Statement declaring an item or slot.\n@@ -2518,7 +2469,6 @@ before and after the declaration.\n * Ref.Stmt.Decl.Slot::              Statement declaring a slot.\n @end menu\n \n-@page\n @node          Ref.Stmt.Decl.Item\n @subsubsection Ref.Stmt.Decl.Item\n @c * Ref.Stmt.Decl.Item::                Statement declaring an item.\n@@ -2533,7 +2483,6 @@ block.\n Note: there is no implicit capture of the function's dynamic environment when\n declaring a function-local item.\n \n-@page\n @node          Ref.Stmt.Decl.Slot\n @subsubsection Ref.Stmt.Decl.Slot\n @c * Ref.Stmt.Decl.Slot::                Statement declaring an slot.\n@@ -2562,7 +2511,6 @@ object signatures must always declared types for all argument slots.\n \n \n \n-@page\n @node       Ref.Stmt.Copy\n @subsection Ref.Stmt.Copy\n @c * Ref.Stmt.Copy::                Statement for copying a value.\n@@ -2587,7 +2535,6 @@ x.y = z;\n x.y = z + 2;\n @end example\n \n-@page\n @node       Ref.Stmt.Spawn\n @subsection Ref.Stmt.Spawn\n @c * Ref.Stmt.Spawn::               Statements creating new tasks.\n@@ -2618,7 +2565,6 @@ auto result <- out;\n \n @end example\n \n-@page\n @node       Ref.Stmt.Send\n @subsection Ref.Stmt.Send\n @c * Ref.Stmt.Send::            Statements for sending a value into a channel.\n@@ -2649,7 +2595,6 @@ chan[str] c = @dots{};\n c <| \"hello, world\";\n @end example\n \n-@page\n @node       Ref.Stmt.Flush\n @subsection Ref.Stmt.Flush\n @c * Ref.Stmt.Flush::              Statement for flushing a channel queue.\n@@ -2666,7 +2611,6 @@ flush c;\n @end example\n \n \n-@page\n @node       Ref.Stmt.Recv\n @subsection Ref.Stmt.Recv\n @c * Ref.Stmt.Recv::           Statement for receiving a value from a channel.\n@@ -2686,7 +2630,6 @@ port[str] p = @dots{};\n let str s <- p;\n @end example\n \n-@page\n @node       Ref.Stmt.Call\n @subsection Ref.Stmt.Call\n @c * Ref.Stmt.Call::               Statement for calling a function.\n@@ -2705,7 +2648,6 @@ An example of a call statement:\n let int x = add(1, 2);\n @end example\n \n-@page\n @node       Ref.Stmt.Bind\n @subsection Ref.Stmt.Bind\n @c * Ref.Stmt.Bind::          Statement for binding arguments to functions.\n@@ -2751,7 +2693,6 @@ languages. Rust has no support for lexical closures, but many realistic uses\n of them can be achieved with @code{bind} statements.\n \n \n-@page\n @node       Ref.Stmt.Ret\n @subsection Ref.Stmt.Ret\n @c * Ref.Stmt.Ret::                Statement for stopping and producing a value.\n@@ -2771,7 +2712,6 @@ fn max(int a, int b) -> int @{\n @}\n @end example\n \n-@page\n @node       Ref.Stmt.Be\n @subsection Ref.Stmt.Be\n @c * Ref.Stmt.Be::                 Statement for stopping and executing a tail call.\n@@ -2801,7 +2741,6 @@ copy of itself.\n \n \n \n-@page\n @node       Ref.Stmt.Put\n @subsection Ref.Stmt.Put\n @c * Ref.Stmt.Put::                Statement for pausing and producing a value.\n@@ -2821,7 +2760,6 @@ either continuing execution after the @code{put} statement, or terminating its\n execution and destroying the iterator frame.\n \n \n-@page\n @node       Ref.Stmt.Fail\n @subsection Ref.Stmt.Fail\n @c * Ref.Stmt.Fail::               Statement for causing task failure.\n@@ -2831,7 +2769,6 @@ state. In the @emph{failing} state, a task unwinds its stack, destroying all\n frames and freeing all resources until it reaches its entry frame, at which\n point it halts execution in the @emph{dead} state.\n \n-@page\n @node       Ref.Stmt.Log\n @subsection Ref.Stmt.Log\n @c * Ref.Stmt.Log::                Statement for logging values to diagnostic buffers.\n@@ -2849,7 +2786,6 @@ contains a log statement.\n @example\n @end example\n \n-@page\n @node       Ref.Stmt.Note\n @subsection Ref.Stmt.Note\n @c * Ref.Stmt.Note::                Statement for logging values during failure.\n@@ -2893,7 +2829,6 @@ slot, and then a subsequent failure occurs, the @emph{mutated} value will be\n logged during unwinding, @emph{not} the original value that was denoted by the\n @var{lval} at the moment control passed through the @code{note} statement.\n \n-@page\n @node       Ref.Stmt.While\n @subsection Ref.Stmt.While\n @c * Ref.Stmt.While::              Statement for simple conditional looping.\n@@ -2928,15 +2863,13 @@ do @{\n @} while (i < 10);\n @end example\n \n-@page\n @node       Ref.Stmt.Break\n @subsection Ref.Stmt.Break\n @c * Ref.Stmt.Break::              Statement for terminating a loop.\n \n Executing a @code{break} statement immediately terminates the innermost loop\n enclosing it. It is only permitted in the body of a loop.\n \n-@page\n @node       Ref.Stmt.Cont\n @subsection Ref.Stmt.Cont\n @c * Ref.Stmt.Cont::               Statement for terminating a single loop iteration.\n@@ -2951,7 +2884,6 @@ loop.\n A @code{cont} statement is only permitted in the body of a loop.\n \n \n-@page\n @node       Ref.Stmt.For\n @subsection Ref.Stmt.For\n @c * Ref.Stmt.For::                Statement for looping over strings and vectors.\n@@ -2984,7 +2916,6 @@ for (&foo e in v) @{\n @}\n @end example\n \n-@page\n @node          Ref.Stmt.Foreach\n @subsection    Ref.Stmt.Foreach\n @c * Ref.Stmt.Foreach::           Statement for general conditional looping.\n@@ -3003,7 +2934,6 @@ for each (&str s = _str.split(txt, \"\\n\")) @{\n @end example\n \n \n-@page\n @node       Ref.Stmt.If\n @subsection Ref.Stmt.If\n @c * Ref.Stmt.If::                 Statement for simple conditional branching.\n@@ -3016,7 +2946,6 @@ to @code{true}, the consequent block is executed and any @code{else} block is\n skipped. If the condition expression evaluates to @code{false}, the consequent\n block is skipped and any @code{else} block is executed.\n \n-@page\n @node       Ref.Stmt.Alt\n @subsection Ref.Stmt.Alt\n @c * Ref.Stmt.Alt::                Statement for complex conditional branching.\n@@ -3039,7 +2968,6 @@ statement following the @code{alt} when the case block completes.\n * Ref.Stmt.Alt.Type::         Statement for branching on types.\n @end menu\n \n-@page\n @node          Ref.Stmt.Alt.Comm\n @subsubsection Ref.Stmt.Alt.Comm\n @c * Ref.Stmt.Alt.Comm::           Statement for branching on communication events.\n@@ -3073,7 +3001,6 @@ alt @{\n @}\n @end example\n \n-@page\n @node          Ref.Stmt.Alt.Pat\n @subsubsection Ref.Stmt.Alt.Pat\n @c * Ref.Stmt.Alt.Pat::            Statement for branching on pattern matches.\n@@ -3113,7 +3040,6 @@ alt (x) @{\n @end example\n \n \n-@page\n @node          Ref.Stmt.Alt.Type\n @subsubsection Ref.Stmt.Alt.Type\n @c * Ref.Stmt.Alt.Type::           Statement for branching on type.\n@@ -3147,7 +3073,6 @@ alt type (x) @{\n @end example\n \n \n-@page\n @node       Ref.Stmt.Prove\n @subsection Ref.Stmt.Prove\n @c * Ref.Stmt.Prove::              Statement for static assertion of typestate.\n@@ -3157,7 +3082,6 @@ check (and document) that its argument constraint holds at its statement entry\n point. If its argument typestate does not hold, under the typestate algorithm,\n the program containing it will fail to compile.\n \n-@page\n @node       Ref.Stmt.Check\n @subsection Ref.Stmt.Check\n @c * Ref.Stmt.Check::              Statement for dynamic assertion of typestate.\n@@ -3199,7 +3123,6 @@ fn test() @{\n @}\n @end example\n \n-@page\n @node       Ref.Stmt.IfCheck\n @subsection Ref.Stmt.IfCheck\n @c * Ref.Stmt.IfCheck::            Statement for dynamic testing of typestate.\n@@ -3249,7 +3172,6 @@ communication, reflection, logging and signal handling.\n * Ref.Run.Sig::                 Runtime signal handler.\n @end menu\n \n-@page\n @node       Ref.Run.Mem\n @subsection Ref.Run.Mem\n @c * Ref.Run.Mem::                 Runtime memory management service.\n@@ -3264,7 +3186,6 @@ The runtime memory-management system in turn supplies Rust tasks with\n facilities for allocating, extending and releasing stacks, as well as\n allocating and freeing boxed values.\n \n-@page\n @node       Ref.Run.Type\n @subsection Ref.Run.Type\n @c * Ref.Run.Mem::                 Runtime built-in type services.\n@@ -3281,7 +3202,6 @@ The runtime provides C and Rust code to manage several built-in types:\n Support for other built-in types such as simple types, tuples,\n records, and tags is open-coded by the Rust compiler.\n \n-@page\n @node       Ref.Run.Comm\n @subsection Ref.Run.Comm\n @c * Ref.Run.Comm::                Runtime communication service.\n@@ -3292,7 +3212,6 @@ queues, as well as code to copy values between queues and their recipients and\n to serialize values for transmission over operating-system inter-process\n communication facilities.\n \n-@page\n @node       Ref.Run.Refl\n @subsection Ref.Run.Refl\n @c * Ref.Run.Refl::                Runtime reflection system.\n@@ -3301,7 +3220,6 @@ The runtime reflection system is driven by the DWARF tables emitted into a\n crate at compile-time. Reflecting on a slot or item allocates a Rust data\n structure corresponding to the DWARF DIE for that slot or item.\n \n-@page\n @node       Ref.Run.Log\n @subsection Ref.Run.Log\n @c * Ref.Run.Log::                 Runtime logging system.\n@@ -3332,7 +3250,6 @@ ownership-path-prefix basis.\n Logging is integrated into the language for efficiency reasons, as well as the\n need to filter logs based on these two built-in dimensions.\n \n-@page\n @node       Ref.Run.Sig\n @subsection Ref.Run.Sig\n @c * Ref.Run.Sig::               Runtime signal handler."}]}