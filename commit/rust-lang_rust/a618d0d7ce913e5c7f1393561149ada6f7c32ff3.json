{"sha": "a618d0d7ce913e5c7f1393561149ada6f7c32ff3", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE2MThkMGQ3Y2U5MTNlNWM3ZjEzOTM1NjExNDlhZGE2ZjdjMzJmZjM=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-09-05T01:05:57Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-09-05T01:26:30Z"}, "message": "std: Convert test to camel case", "tree": {"sha": "061cd30043e29543eb1f05d0eabaa07f85508f4c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/061cd30043e29543eb1f05d0eabaa07f85508f4c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a618d0d7ce913e5c7f1393561149ada6f7c32ff3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a618d0d7ce913e5c7f1393561149ada6f7c32ff3", "html_url": "https://github.com/rust-lang/rust/commit/a618d0d7ce913e5c7f1393561149ada6f7c32ff3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a618d0d7ce913e5c7f1393561149ada6f7c32ff3/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9c988eb40dae850d40171b887153f1d67142032b", "url": "https://api.github.com/repos/rust-lang/rust/commits/9c988eb40dae850d40171b887153f1d67142032b", "html_url": "https://github.com/rust-lang/rust/commit/9c988eb40dae850d40171b887153f1d67142032b"}], "stats": {"total": 141, "additions": 70, "deletions": 71}, "files": [{"sha": "121cf9df669c6f46b89c9795248b8894d467afc2", "filename": "src/compiletest/compiletest.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a618d0d7ce913e5c7f1393561149ada6f7c32ff3/src%2Fcompiletest%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a618d0d7ce913e5c7f1393561149ada6f7c32ff3/src%2Fcompiletest%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcompiletest.rs?ref=a618d0d7ce913e5c7f1393561149ada6f7c32ff3", "patch": "@@ -122,7 +122,7 @@ fn run_tests(config: config) {\n     if !res { fail ~\"Some tests failed\"; }\n }\n \n-fn test_opts(config: config) -> test::test_opts {\n+fn test_opts(config: config) -> test::TestOpts {\n     {filter:\n          match config.filter {\n            option::Some(s) => option::Some(s),\n@@ -137,7 +137,7 @@ fn test_opts(config: config) -> test::test_opts {\n     }\n }\n \n-fn make_tests(config: config) -> ~[test::test_desc] {\n+fn make_tests(config: config) -> ~[test::TestDesc] {\n     debug!(\"making tests from %s\",\n            config.src_base.to_str());\n     let mut tests = ~[];\n@@ -175,7 +175,7 @@ fn is_test(config: config, testfile: &Path) -> bool {\n }\n \n fn make_test(config: config, testfile: &Path) ->\n-   test::test_desc {\n+   test::TestDesc {\n     {\n         name: make_test_name(config, testfile),\n         fn: make_test_closure(config, testfile),\n@@ -188,7 +188,7 @@ fn make_test_name(config: config, testfile: &Path) -> ~str {\n     fmt!(\"[%s] %s\", mode_str(config.mode), testfile.to_str())\n }\n \n-fn make_test_closure(config: config, testfile: &Path) -> test::test_fn {\n+fn make_test_closure(config: config, testfile: &Path) -> test::TestFn {\n     let testfile = testfile.to_str();\n     fn~() { runtest::run(config, testfile) }\n }"}, {"sha": "d2c6f41317b24816138d2b31692ba302e4860f42", "filename": "src/libstd/std.rc", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a618d0d7ce913e5c7f1393561149ada6f7c32ff3/src%2Flibstd%2Fstd.rc", "raw_url": "https://github.com/rust-lang/rust/raw/a618d0d7ce913e5c7f1393561149ada6f7c32ff3/src%2Flibstd%2Fstd.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstd.rc?ref=a618d0d7ce913e5c7f1393561149ada6f7c32ff3", "patch": "@@ -92,7 +92,6 @@ mod unicode;\n \n // Compiler support modules\n \n-#[allow(non_camel_case_types)] // XXX\n mod test;\n #[allow(non_camel_case_types)] // XXX\n mod serialization;"}, {"sha": "8c76c316be4395859c10ea99172b3e8806d5f1c6", "filename": "src/libstd/test.rs", "status": "modified", "additions": 65, "deletions": 65, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/a618d0d7ce913e5c7f1393561149ada6f7c32ff3/src%2Flibstd%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a618d0d7ce913e5c7f1393561149ada6f7c32ff3/src%2Flibstd%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftest.rs?ref=a618d0d7ce913e5c7f1393561149ada6f7c32ff3", "patch": "@@ -13,15 +13,15 @@ use libc::size_t;\n use task::TaskBuilder;\n use comm = core::comm;\n \n-export test_name;\n-export test_fn;\n-export test_desc;\n+export TestName;\n+export TestFn;\n+export TestDesc;\n export test_main;\n-export test_result;\n-export test_opts;\n-export tr_ok;\n-export tr_failed;\n-export tr_ignored;\n+export TestResult;\n+export TestOpts;\n+export TrOk;\n+export TrFailed;\n+export TrIgnored;\n export run_tests_console;\n \n #[abi = \"cdecl\"]\n@@ -33,26 +33,26 @@ extern mod rustrt {\n // paths; i.e. it should be a series of identifiers seperated by double\n // colons. This way if some test runner wants to arrange the tests\n // hierarchically it may.\n-type test_name = ~str;\n+type TestName = ~str;\n \n // A function that runs a test. If the function returns successfully,\n // the test succeeds; if the function fails then the test fails. We\n // may need to come up with a more clever definition of test in order\n // to support isolation of tests into tasks.\n-type test_fn = fn~();\n+type TestFn = fn~();\n \n // The definition of a single test. A test runner will run a list of\n // these.\n-type test_desc = {\n-    name: test_name,\n-    fn: test_fn,\n+type TestDesc = {\n+    name: TestName,\n+    fn: TestFn,\n     ignore: bool,\n     should_fail: bool\n };\n \n // The default console test runner. It accepts the command line\n // arguments and a vector of test_descs (generated at compile time).\n-fn test_main(args: ~[~str], tests: ~[test_desc]) {\n+fn test_main(args: ~[~str], tests: ~[TestDesc]) {\n     let opts =\n         match parse_opts(args) {\n           either::Left(o) => o,\n@@ -61,13 +61,13 @@ fn test_main(args: ~[~str], tests: ~[test_desc]) {\n     if !run_tests_console(opts, tests) { fail ~\"Some tests failed\"; }\n }\n \n-type test_opts = {filter: Option<~str>, run_ignored: bool,\n+type TestOpts = {filter: Option<~str>, run_ignored: bool,\n                   logfile: Option<~str>};\n \n-type opt_res = Either<test_opts, ~str>;\n+type OptRes = Either<TestOpts, ~str>;\n \n // Parses command line arguments into test options\n-fn parse_opts(args: ~[~str]) -> opt_res {\n+fn parse_opts(args: ~[~str]) -> OptRes {\n     let args_ = vec::tail(args);\n     let opts = ~[getopts::optflag(~\"ignored\"), getopts::optopt(~\"logfile\")];\n     let matches =\n@@ -90,55 +90,55 @@ fn parse_opts(args: ~[~str]) -> opt_res {\n     return either::Left(test_opts);\n }\n \n-enum test_result { tr_ok, tr_failed, tr_ignored, }\n+enum TestResult { TrOk, TrFailed, TrIgnored, }\n \n-impl test_result : Eq {\n-    pure fn eq(&&other: test_result) -> bool {\n+impl TestResult : Eq {\n+    pure fn eq(&&other: TestResult) -> bool {\n         (self as uint) == (other as uint)\n     }\n }\n \n-type console_test_state =\n+type ConsoleTestState =\n     @{out: io::Writer,\n       log_out: Option<io::Writer>,\n       use_color: bool,\n       mut total: uint,\n       mut passed: uint,\n       mut failed: uint,\n       mut ignored: uint,\n-      mut failures: ~[test_desc]};\n+      mut failures: ~[TestDesc]};\n \n // A simple console test runner\n-fn run_tests_console(opts: test_opts,\n-                     tests: ~[test_desc]) -> bool {\n+fn run_tests_console(opts: TestOpts,\n+                     tests: ~[TestDesc]) -> bool {\n \n-    fn callback(event: testevent, st: console_test_state) {\n+    fn callback(event: TestEvent, st: ConsoleTestState) {\n         debug!(\"callback(event=%?)\", event);\n         match event {\n-          te_filtered(filtered_tests) => {\n+          TeFiltered(filtered_tests) => {\n             st.total = vec::len(filtered_tests);\n             let noun = if st.total != 1u { ~\"tests\" } else { ~\"test\" };\n             st.out.write_line(fmt!(\"\\nrunning %u %s\", st.total, noun));\n           }\n-          te_wait(test) => st.out.write_str(fmt!(\"test %s ... \", test.name)),\n-          te_result(test, result) => {\n+          TeWait(test) => st.out.write_str(fmt!(\"test %s ... \", test.name)),\n+          TeResult(test, result) => {\n             match st.log_out {\n                 Some(f) => write_log(f, result, test),\n                 None => ()\n             }\n             match result {\n-              tr_ok => {\n+              TrOk => {\n                 st.passed += 1u;\n                 write_ok(st.out, st.use_color);\n                 st.out.write_line(~\"\");\n               }\n-              tr_failed => {\n+              TrFailed => {\n                 st.failed += 1u;\n                 write_failed(st.out, st.use_color);\n                 st.out.write_line(~\"\");\n                 vec::push(st.failures, copy test);\n               }\n-              tr_ignored => {\n+              TrIgnored => {\n                 st.ignored += 1u;\n                 write_ignored(st.out, st.use_color);\n                 st.out.write_line(~\"\");\n@@ -188,12 +188,12 @@ fn run_tests_console(opts: test_opts,\n \n     return success;\n \n-    fn write_log(out: io::Writer, result: test_result, test: test_desc) {\n+    fn write_log(out: io::Writer, result: TestResult, test: TestDesc) {\n         out.write_line(fmt!(\"%s %s\",\n                     match result {\n-                        tr_ok => ~\"ok\",\n-                        tr_failed => ~\"failed\",\n-                        tr_ignored => ~\"ignored\"\n+                        TrOk => ~\"ok\",\n+                        TrFailed => ~\"failed\",\n+                        TrIgnored => ~\"ignored\"\n                     }, test.name));\n     }\n \n@@ -220,7 +220,7 @@ fn run_tests_console(opts: test_opts,\n     }\n }\n \n-fn print_failures(st: console_test_state) {\n+fn print_failures(st: ConsoleTestState) {\n     st.out.write_line(~\"\\nfailures:\");\n     let failures = copy st.failures;\n     let failures = vec::map(failures, |test| test.name);\n@@ -270,19 +270,19 @@ fn should_sort_failures_before_printing_them() {\n \n fn use_color() -> bool { return get_concurrency() == 1u; }\n \n-enum testevent {\n-    te_filtered(~[test_desc]),\n-    te_wait(test_desc),\n-    te_result(test_desc, test_result),\n+enum TestEvent {\n+    TeFiltered(~[TestDesc]),\n+    TeWait(TestDesc),\n+    TeResult(TestDesc, TestResult),\n }\n \n-type monitor_msg = (test_desc, test_result);\n+type MonitorMsg = (TestDesc, TestResult);\n \n-fn run_tests(opts: test_opts, tests: ~[test_desc],\n-             callback: fn@(testevent)) {\n+fn run_tests(opts: TestOpts, tests: ~[TestDesc],\n+             callback: fn@(TestEvent)) {\n \n     let mut filtered_tests = filter_tests(opts, tests);\n-    callback(te_filtered(copy filtered_tests));\n+    callback(TeFiltered(copy filtered_tests));\n \n     // It's tempting to just spawn all the tests at once, but since we have\n     // many tests that run in other processes we would be making a big mess.\n@@ -304,7 +304,7 @@ fn run_tests(opts: test_opts, tests: ~[test_desc],\n                 // We are doing one test at a time so we can print the name\n                 // of the test before we run it. Useful for debugging tests\n                 // that hang forever.\n-                callback(te_wait(copy test));\n+                callback(TeWait(copy test));\n             }\n             run_test(test, ch);\n             wait_idx += 1u;\n@@ -313,9 +313,9 @@ fn run_tests(opts: test_opts, tests: ~[test_desc],\n \n         let (test, result) = core::comm::recv(p);\n         if concurrency != 1u {\n-            callback(te_wait(copy test));\n+            callback(TeWait(copy test));\n         }\n-        callback(te_result(test, result));\n+        callback(TeResult(test, result));\n         wait_idx -= 1u;\n         done_idx += 1u;\n     }\n@@ -335,8 +335,8 @@ fn get_concurrency() -> uint {\n }\n \n #[allow(non_implicitly_copyable_typarams)]\n-fn filter_tests(opts: test_opts,\n-                tests: ~[test_desc]) -> ~[test_desc] {\n+fn filter_tests(opts: TestOpts,\n+                tests: ~[TestDesc]) -> ~[TestDesc] {\n     let mut filtered = copy tests;\n \n     // Remove tests that don't match the test filter\n@@ -349,8 +349,8 @@ fn filter_tests(opts: test_opts,\n           option::None => ~\"\"\n         };\n \n-        fn filter_fn(test: test_desc, filter_str: ~str) ->\n-            Option<test_desc> {\n+        fn filter_fn(test: TestDesc, filter_str: ~str) ->\n+            Option<TestDesc> {\n             if str::contains(test.name, filter_str) {\n                 return option::Some(copy test);\n             } else { return option::None; }\n@@ -363,7 +363,7 @@ fn filter_tests(opts: test_opts,\n     filtered = if !opts.run_ignored {\n         filtered\n     } else {\n-        fn filter(test: test_desc) -> Option<test_desc> {\n+        fn filter(test: TestDesc) -> Option<TestDesc> {\n             if test.ignore {\n                 return option::Some({name: test.name,\n                                   fn: copy test.fn,\n@@ -377,7 +377,7 @@ fn filter_tests(opts: test_opts,\n \n     // Sort the tests alphabetically\n     filtered = {\n-        pure fn lteq(t1: &test_desc, t2: &test_desc) -> bool {\n+        pure fn lteq(t1: &TestDesc, t2: &TestDesc) -> bool {\n             str::le(t1.name, t2.name)\n         }\n         sort::merge_sort(lteq, filtered)\n@@ -386,11 +386,11 @@ fn filter_tests(opts: test_opts,\n     return filtered;\n }\n \n-type test_future = {test: test_desc, wait: fn@() -> test_result};\n+type TestFuture = {test: TestDesc, wait: fn@() -> TestResult};\n \n-fn run_test(+test: test_desc, monitor_ch: comm::Chan<monitor_msg>) {\n+fn run_test(+test: TestDesc, monitor_ch: comm::Chan<MonitorMsg>) {\n     if test.ignore {\n-        core::comm::send(monitor_ch, (copy test, tr_ignored));\n+        core::comm::send(monitor_ch, (copy test, TrIgnored));\n         return;\n     }\n \n@@ -406,13 +406,13 @@ fn run_test(+test: test_desc, monitor_ch: comm::Chan<monitor_msg>) {\n     };\n }\n \n-fn calc_result(test: test_desc, task_succeeded: bool) -> test_result {\n+fn calc_result(test: TestDesc, task_succeeded: bool) -> TestResult {\n     if task_succeeded {\n-        if test.should_fail { tr_failed }\n-        else { tr_ok }\n+        if test.should_fail { TrFailed }\n+        else { TrOk }\n     } else {\n-        if test.should_fail { tr_ok }\n-        else { tr_failed }\n+        if test.should_fail { TrOk }\n+        else { TrFailed }\n     }\n }\n \n@@ -432,7 +432,7 @@ mod tests {\n         let ch = core::comm::Chan(p);\n         run_test(desc, ch);\n         let (_, res) = core::comm::recv(p);\n-        assert res != tr_ok;\n+        assert res != TrOk;\n     }\n \n     #[test]\n@@ -448,7 +448,7 @@ mod tests {\n         let ch = core::comm::Chan(p);\n         run_test(desc, ch);\n         let (_, res) = core::comm::recv(p);\n-        assert res == tr_ignored;\n+        assert res == TrIgnored;\n     }\n \n     #[test]\n@@ -465,7 +465,7 @@ mod tests {\n         let ch = core::comm::Chan(p);\n         run_test(desc, ch);\n         let (_, res) = core::comm::recv(p);\n-        assert res == tr_ok;\n+        assert res == TrOk;\n     }\n \n     #[test]\n@@ -481,7 +481,7 @@ mod tests {\n         let ch = core::comm::Chan(p);\n         run_test(desc, ch);\n         let (_, res) = core::comm::recv(p);\n-        assert res == tr_failed;\n+        assert res == TrFailed;\n     }\n \n     #[test]"}, {"sha": "e5245febbe88e386f28caa3fdb8c46a2f5593de3", "filename": "src/rustc/front/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a618d0d7ce913e5c7f1393561149ada6f7c32ff3/src%2Frustc%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a618d0d7ce913e5c7f1393561149ada6f7c32ff3/src%2Frustc%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Ffront%2Ftest.rs?ref=a618d0d7ce913e5c7f1393561149ada6f7c32ff3", "patch": "@@ -264,7 +264,7 @@ fn mk_path(cx: test_ctxt, path: ~[ast::ident]) -> ~[ast::ident] {\n fn mk_test_desc_vec_ty(cx: test_ctxt) -> @ast::ty {\n     let test_desc_ty_path =\n         path_node(mk_path(cx, ~[cx.sess.ident_of(~\"test\"),\n-                                cx.sess.ident_of(~\"test_desc\")]));\n+                                cx.sess.ident_of(~\"TestDesc\")]));\n \n     let test_desc_ty: ast::ty =\n         {id: cx.sess.next_node_id(),"}]}