{"sha": "073c8f10fc40b07596fd1018a2002db8e6d5222a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA3M2M4ZjEwZmM0MGIwNzU5NmZkMTAxOGEyMDAyZGI4ZTZkNTIyMmE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-06-05T05:21:43Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-06-05T05:21:43Z"}, "message": "auto merge of #14592 : alexcrichton/rust/rustdoc-links, r=huonw\n\nThese are a few assorted fixes for some issues I found this morning (details in the commits).", "tree": {"sha": "783b1bbf3428ae680f52c366ed66ef49451daadc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/783b1bbf3428ae680f52c366ed66ef49451daadc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/073c8f10fc40b07596fd1018a2002db8e6d5222a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/073c8f10fc40b07596fd1018a2002db8e6d5222a", "html_url": "https://github.com/rust-lang/rust/commit/073c8f10fc40b07596fd1018a2002db8e6d5222a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/073c8f10fc40b07596fd1018a2002db8e6d5222a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "422d54bed212b4f0356fb56bbc31c8deef7a6b77", "url": "https://api.github.com/repos/rust-lang/rust/commits/422d54bed212b4f0356fb56bbc31c8deef7a6b77", "html_url": "https://github.com/rust-lang/rust/commit/422d54bed212b4f0356fb56bbc31c8deef7a6b77"}, {"sha": "1827241840656ffe7adcfb83a0f29c8deda759bd", "url": "https://api.github.com/repos/rust-lang/rust/commits/1827241840656ffe7adcfb83a0f29c8deda759bd", "html_url": "https://github.com/rust-lang/rust/commit/1827241840656ffe7adcfb83a0f29c8deda759bd"}], "stats": {"total": 176, "additions": 122, "deletions": 54}, "files": [{"sha": "90f85079464bb2743758afa957a194460f5fc488", "filename": "mk/docs.mk", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/073c8f10fc40b07596fd1018a2002db8e6d5222a/mk%2Fdocs.mk", "raw_url": "https://github.com/rust-lang/rust/raw/073c8f10fc40b07596fd1018a2002db8e6d5222a/mk%2Fdocs.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fdocs.mk?ref=073c8f10fc40b07596fd1018a2002db8e6d5222a", "patch": "@@ -110,7 +110,7 @@ HTML_DEPS += doc/version_info.html\n doc/version_info.html: $(D)/version_info.html.template $(MKFILE_DEPS) \\\n                        $(wildcard $(D)/*.*) | doc/\n \t@$(call E, version-info: $@)\n-\tsed -e \"s/VERSION/$(CFG_RELEASE)/; s/SHORT_HASH/$(shell echo \\\n+\t$(Q)sed -e \"s/VERSION/$(CFG_RELEASE)/; s/SHORT_HASH/$(shell echo \\\n                     $(CFG_VER_HASH) | head -c 8)/;\\\n                 s/STAMP/$(CFG_VER_HASH)/;\" $< >$@\n \n@@ -156,15 +156,17 @@ doc/footer.tex: $(D)/footer.inc | doc/\n # HTML (rustdoc)\n DOC_TARGETS += doc/not_found.html\n doc/not_found.html: $(D)/not_found.md $(HTML_DEPS) | doc/\n-\t$(RUSTDOC) $(RUSTDOC_HTML_OPTS_NO_CSS) --markdown-css http://doc.rust-lang.org/rust.css $<\n+\t@$(call E, rustdoc: $@)\n+\t$(Q)$(RUSTDOC) $(RUSTDOC_HTML_OPTS_NO_CSS) \\\n+\t\t--markdown-css http://doc.rust-lang.org/rust.css $<\n \n define DEF_DOC\n \n # HTML (rustdoc)\n DOC_TARGETS += doc/$(1).html\n doc/$(1).html: $$(D)/$(1).md $$(HTML_DEPS) $$(RUSTDOC_DEPS_$(1)) | doc/\n \t@$$(call E, rustdoc: $$@)\n-\t$$(RUSTDOC) $$(RUSTDOC_HTML_OPTS) $$(RUSTDOC_FLAGS_$(1)) $$<\n+\t$$(Q)$$(RUSTDOC) $$(RUSTDOC_HTML_OPTS) $$(RUSTDOC_FLAGS_$(1)) $$<\n \n ifneq ($(ONLY_HTML_DOCS),1)\n "}, {"sha": "df43e0850a457d6a51012c1c9806d83782a227a4", "filename": "src/doc/index.md", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/073c8f10fc40b07596fd1018a2002db8e6d5222a/src%2Fdoc%2Findex.md", "raw_url": "https://github.com/rust-lang/rust/raw/073c8f10fc40b07596fd1018a2002db8e6d5222a/src%2Fdoc%2Findex.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Findex.md?ref=073c8f10fc40b07596fd1018a2002db8e6d5222a", "patch": "@@ -61,7 +61,6 @@ li {list-style-type: none; }\n * [The `time` library](time/index.html)\n * [The `uuid` 128-bit universally unique identifier library](uuid/index.html)\n * [The `url` library](url/index.html)\n-* [The `workcache` library](workcache/index.html)\n * [The `log` library](log/index.html)\n \n # Tooling"}, {"sha": "1feebbb35b69ea6c602cdcc2ad6732f544ce7c9f", "filename": "src/libcore/fmt/rt.rs", "status": "modified", "additions": 27, "deletions": 3, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/073c8f10fc40b07596fd1018a2002db8e6d5222a/src%2Flibcore%2Ffmt%2Frt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/073c8f10fc40b07596fd1018a2002db8e6d5222a/src%2Flibcore%2Ffmt%2Frt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Frt.rs?ref=073c8f10fc40b07596fd1018a2002db8e6d5222a", "patch": "@@ -14,24 +14,24 @@\n //! These definitions are similar to their `ct` equivalents, but differ in that\n //! these can be statically allocated and are slightly optimized for the runtime\n \n-#![allow(missing_doc)]\n-#![doc(hidden)]\n-\n use option::Option;\n \n+#[doc(hidden)]\n pub enum Piece<'a> {\n     String(&'a str),\n     // FIXME(#8259): this shouldn't require the unit-value here\n     CurrentArgument(()),\n     Argument(Argument<'a>),\n }\n \n+#[doc(hidden)]\n pub struct Argument<'a> {\n     pub position: Position,\n     pub format: FormatSpec,\n     pub method: Option<&'a Method<'a>>\n }\n \n+#[doc(hidden)]\n pub struct FormatSpec {\n     pub fill: char,\n     pub align: Alignment,\n@@ -40,38 +40,60 @@ pub struct FormatSpec {\n     pub width: Count,\n }\n \n+/// Possible alignments that can be requested as part of a formatting directive.\n #[deriving(PartialEq)]\n pub enum Alignment {\n+    /// Indication that contents should be left-aligned.\n     AlignLeft,\n+    /// Indication that contents should be right-aligned.\n     AlignRight,\n+    /// No alignment was requested.\n     AlignUnknown,\n }\n \n+#[doc(hidden)]\n pub enum Count {\n     CountIs(uint), CountIsParam(uint), CountIsNextParam, CountImplied,\n }\n \n+#[doc(hidden)]\n pub enum Position {\n     ArgumentNext, ArgumentIs(uint)\n }\n \n+/// Flags which can be passed to formatting via a directive.\n+///\n+/// These flags are discovered through the `flags` field of the `Formatter`\n+/// structure. The flag in that structure is a union of these flags into a\n+/// `uint` where each flag's discriminant is the corresponding bit.\n pub enum Flag {\n+    /// A flag which enables number formatting to always print the sign of a\n+    /// number.\n     FlagSignPlus,\n+    /// Currently not a used flag\n     FlagSignMinus,\n+    /// Indicates that the \"alternate formatting\" for a type should be used.\n+    ///\n+    /// The meaning of this flag is type-specific.\n     FlagAlternate,\n+    /// Indicates that padding should be done with a `0` character as well as\n+    /// being aware of the sign to be printed.\n     FlagSignAwareZeroPad,\n }\n \n+#[doc(hidden)]\n pub enum Method<'a> {\n     Plural(Option<uint>, &'a [PluralArm<'a>], &'a [Piece<'a>]),\n     Select(&'a [SelectArm<'a>], &'a [Piece<'a>]),\n }\n \n+#[doc(hidden)]\n pub enum PluralSelector {\n     Keyword(PluralKeyword),\n     Literal(uint),\n }\n \n+#[doc(hidden)]\n pub enum PluralKeyword {\n     Zero,\n     One,\n@@ -80,11 +102,13 @@ pub enum PluralKeyword {\n     Many,\n }\n \n+#[doc(hidden)]\n pub struct PluralArm<'a> {\n     pub selector: PluralSelector,\n     pub result: &'a [Piece<'a>],\n }\n \n+#[doc(hidden)]\n pub struct SelectArm<'a> {\n     pub selector: &'a str,\n     pub result: &'a [Piece<'a>],"}, {"sha": "575dd057867fb24b7e7df3d5ce3058c5aa7ba5f2", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 36, "deletions": 19, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/073c8f10fc40b07596fd1018a2002db8e6d5222a/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/073c8f10fc40b07596fd1018a2002db8e6d5222a/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=073c8f10fc40b07596fd1018a2002db8e6d5222a", "patch": "@@ -129,7 +129,7 @@ pub fn record_extern_fqn(cx: &core::DocContext,\n     match cx.maybe_typed {\n         core::Typed(ref tcx) => {\n             let fqn = csearch::get_item_path(tcx, did);\n-            let fqn = fqn.move_iter().map(|i| i.to_str().to_string()).collect();\n+            let fqn = fqn.move_iter().map(|i| i.to_str()).collect();\n             cx.external_paths.borrow_mut().get_mut_ref().insert(did, (fqn, kind));\n         }\n         core::NotTyped(..) => {}\n@@ -138,10 +138,18 @@ pub fn record_extern_fqn(cx: &core::DocContext,\n \n pub fn build_external_trait(tcx: &ty::ctxt, did: ast::DefId) -> clean::Trait {\n     let def = ty::lookup_trait_def(tcx, did);\n-    let methods = ty::trait_methods(tcx, did);\n+    let methods = ty::trait_methods(tcx, did).clean();\n+    let provided = ty::provided_trait_methods(tcx, did);\n+    let mut methods = methods.move_iter().map(|meth| {\n+        if provided.iter().any(|a| a.def_id == meth.def_id) {\n+            clean::Provided(meth)\n+        } else {\n+            clean::Required(meth)\n+        }\n+    });\n     clean::Trait {\n         generics: def.generics.clean(),\n-        methods: methods.iter().map(|i| i.clean()).collect(),\n+        methods: methods.collect(),\n         parents: Vec::new(), // FIXME: this is likely wrong\n     }\n }\n@@ -207,7 +215,7 @@ fn build_impls(cx: &core::DocContext,\n     match tcx.inherent_impls.borrow().find(&did) {\n         None => {}\n         Some(i) => {\n-            impls.extend(i.borrow().iter().map(|&did| { build_impl(tcx, did) }));\n+            impls.extend(i.borrow().iter().map(|&did| { build_impl(cx, tcx, did) }));\n         }\n     }\n \n@@ -223,38 +231,47 @@ fn build_impls(cx: &core::DocContext,\n         csearch::each_top_level_item_of_crate(&tcx.sess.cstore,\n                                               did.krate,\n                                               |def, _, _| {\n-            populate_impls(tcx, def, &mut impls)\n+            populate_impls(cx, tcx, def, &mut impls)\n         });\n \n-        fn populate_impls(tcx: &ty::ctxt,\n+        fn populate_impls(cx: &core::DocContext,\n+                          tcx: &ty::ctxt,\n                           def: decoder::DefLike,\n-                          impls: &mut Vec<clean::Item>) {\n+                          impls: &mut Vec<Option<clean::Item>>) {\n             match def {\n-                decoder::DlImpl(did) => impls.push(build_impl(tcx, did)),\n+                decoder::DlImpl(did) => impls.push(build_impl(cx, tcx, did)),\n                 decoder::DlDef(ast::DefMod(did)) => {\n                     csearch::each_child_of_item(&tcx.sess.cstore,\n                                                 did,\n                                                 |def, _, _| {\n-                        populate_impls(tcx, def, impls)\n+                        populate_impls(cx, tcx, def, impls)\n                     })\n                 }\n                 _ => {}\n             }\n         }\n     }\n \n-    impls\n+    impls.move_iter().filter_map(|a| a).collect()\n }\n \n-fn build_impl(tcx: &ty::ctxt, did: ast::DefId) -> clean::Item {\n+fn build_impl(cx: &core::DocContext,\n+              tcx: &ty::ctxt,\n+              did: ast::DefId) -> Option<clean::Item> {\n+    if !cx.inlined.borrow_mut().get_mut_ref().insert(did) {\n+        return None\n+    }\n+\n     let associated_trait = csearch::get_impl_trait(tcx, did);\n     let attrs = load_attrs(tcx, did);\n     let ty = ty::lookup_item_type(tcx, did);\n-    let methods = csearch::get_impl_methods(&tcx.sess.cstore, did).iter().map(|did| {\n-        let mut item = match ty::method(tcx, *did).clean() {\n-            clean::Provided(item) => item,\n-            clean::Required(item) => item,\n-        };\n+    let methods = csearch::get_impl_methods(&tcx.sess.cstore,\n+                                            did).iter().filter_map(|did| {\n+        let method = ty::method(tcx, *did);\n+        if method.vis != ast::Public && associated_trait.is_none() {\n+            return None\n+        }\n+        let mut item = ty::method(tcx, *did).clean();\n         item.inner = match item.inner.clone() {\n             clean::TyMethodItem(clean::TyMethod {\n                 fn_style, decl, self_, generics\n@@ -268,9 +285,9 @@ fn build_impl(tcx: &ty::ctxt, did: ast::DefId) -> clean::Item {\n             }\n             _ => fail!(\"not a tymethod\"),\n         };\n-        item\n+        Some(item)\n     }).collect();\n-    clean::Item {\n+    Some(clean::Item {\n         inner: clean::ImplItem(clean::Impl {\n             derived: clean::detect_derived(attrs.as_slice()),\n             trait_: associated_trait.clean().map(|bound| {\n@@ -288,7 +305,7 @@ fn build_impl(tcx: &ty::ctxt, did: ast::DefId) -> clean::Item {\n         attrs: attrs,\n         visibility: Some(ast::Inherited),\n         def_id: did,\n-    }\n+    })\n }\n \n fn build_module(cx: &core::DocContext, tcx: &ty::ctxt,"}, {"sha": "1992c102e474e5f748a47942adbaedc85c9e1f6d", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 22, "deletions": 13, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/073c8f10fc40b07596fd1018a2002db8e6d5222a/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/073c8f10fc40b07596fd1018a2002db8e6d5222a/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=073c8f10fc40b07596fd1018a2002db8e6d5222a", "patch": "@@ -93,6 +93,7 @@ impl<'a> Clean<Crate> for visit_ast::RustdocVisitor<'a> {\n         cx.sess().cstore.iter_crate_data(|n, meta| {\n             externs.push((n, meta.clean()));\n         });\n+        externs.sort_by(|&(a, _), &(b, _)| a.cmp(&b));\n \n         // Figure out the name of this crate\n         let input = driver::FileInput(cx.src.clone());\n@@ -132,24 +133,33 @@ impl<'a> Clean<Crate> for visit_ast::RustdocVisitor<'a> {\n                 _ => unreachable!(),\n             };\n             let mut tmp = Vec::new();\n-            for child in m.items.iter() {\n-                match child.inner {\n-                    ModuleItem(..) => {},\n+            for child in m.items.mut_iter() {\n+                let inner = match child.inner {\n+                    ModuleItem(ref mut m) => m,\n                     _ => continue,\n-                }\n+                };\n                 let prim = match Primitive::find(child.attrs.as_slice()) {\n                     Some(prim) => prim,\n                     None => continue,\n                 };\n                 primitives.push(prim);\n-                tmp.push(Item {\n+                let mut i = Item {\n                     source: Span::empty(),\n                     name: Some(prim.to_url_str().to_string()),\n-                    attrs: child.attrs.clone(),\n-                    visibility: Some(ast::Public),\n+                    attrs: Vec::new(),\n+                    visibility: None,\n                     def_id: ast_util::local_def(prim.to_node_id()),\n                     inner: PrimitiveItem(prim),\n-                });\n+                };\n+                // Push one copy to get indexed for the whole crate, and push a\n+                // another copy in the proper location which will actually get\n+                // documented. The first copy will also serve as a redirect to\n+                // the other copy.\n+                tmp.push(i.clone());\n+                i.visibility = Some(ast::Public);\n+                i.attrs = child.attrs.clone();\n+                inner.items.push(i);\n+\n             }\n             m.items.extend(tmp.move_iter());\n         }\n@@ -942,9 +952,8 @@ impl Clean<TraitMethod> for ast::TraitMethod {\n     }\n }\n \n-impl Clean<TraitMethod> for ty::Method {\n-    fn clean(&self) -> TraitMethod {\n-        let m = if self.provided_source.is_some() {Provided} else {Required};\n+impl Clean<Item> for ty::Method {\n+    fn clean(&self) -> Item {\n         let cx = super::ctxtkey.get().unwrap();\n         let tcx = match cx.maybe_typed {\n             core::Typed(ref tcx) => tcx,\n@@ -972,7 +981,7 @@ impl Clean<TraitMethod> for ty::Method {\n             }\n         };\n \n-        m(Item {\n+        Item {\n             name: Some(self.ident.clean()),\n             visibility: Some(ast::Inherited),\n             def_id: self.def_id,\n@@ -984,7 +993,7 @@ impl Clean<TraitMethod> for ty::Method {\n                 self_: self_,\n                 decl: (self.def_id, &sig).clean(),\n             })\n-        })\n+        }\n     }\n }\n "}, {"sha": "86a883bbff679a8fdc9df95f81b43701e166fa89", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 28, "deletions": 14, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/073c8f10fc40b07596fd1018a2002db8e6d5222a/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/073c8f10fc40b07596fd1018a2002db8e6d5222a/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=073c8f10fc40b07596fd1018a2002db8e6d5222a", "patch": "@@ -108,6 +108,7 @@ pub enum ExternalLocation {\n \n /// Metadata about an implementor of a trait.\n pub struct Implementor {\n+    def_id: ast::DefId,\n     generics: clean::Generics,\n     trait_: clean::Type,\n     for_: clean::Type,\n@@ -531,6 +532,11 @@ fn write_shared(cx: &Context,\n \n         try!(write!(&mut f, r\"implementors['{}'] = [\", krate.name));\n         for imp in imps.iter() {\n+            // If the trait and implementation are in the same crate, then\n+            // there's no need to emit information about it (there's inlining\n+            // going on). If they're in different crates then the crate defining\n+            // the trait will be interested in our implementation.\n+            if imp.def_id.krate == did.krate { continue }\n             try!(write!(&mut f, r#\"\"impl{} {} for {}\",\"#,\n                         imp.generics, imp.trait_, imp.for_));\n         }\n@@ -759,6 +765,7 @@ impl DocFolder for Cache {\n                             Vec::new()\n                         });\n                         v.push(Implementor {\n+                            def_id: item.def_id,\n                             generics: i.generics.clone(),\n                             trait_: i.trait_.get_ref().clone(),\n                             for_: i.for_.clone(),\n@@ -860,6 +867,12 @@ impl DocFolder for Cache {\n                 stack.pop();\n                 self.paths.insert(item.def_id, (stack, item_type::Enum));\n             }\n+\n+            clean::PrimitiveItem(..) if item.visibility.is_some() => {\n+                self.paths.insert(item.def_id, (self.stack.clone(),\n+                                                shortty(&item)));\n+            }\n+\n             _ => {}\n         }\n \n@@ -1075,21 +1088,21 @@ impl Context {\n             writer.flush()\n         }\n \n+        // Private modules may survive the strip-private pass if they\n+        // contain impls for public types. These modules can also\n+        // contain items such as publicly reexported structures.\n+        //\n+        // External crates will provide links to these structures, so\n+        // these modules are recursed into, but not rendered normally (a\n+        // flag on the context).\n+        if !self.render_redirect_pages {\n+            self.render_redirect_pages = ignore_private_item(&item);\n+        }\n+\n         match item.inner {\n             // modules are special because they add a namespace. We also need to\n             // recurse into the items of the module as well.\n             clean::ModuleItem(..) => {\n-                // Private modules may survive the strip-private pass if they\n-                // contain impls for public types. These modules can also\n-                // contain items such as publicly reexported structures.\n-                //\n-                // External crates will provide links to these structures, so\n-                // these modules are recursed into, but not rendered normally (a\n-                // flag on the context).\n-                if !self.render_redirect_pages {\n-                    self.render_redirect_pages = ignore_private_module(&item);\n-                }\n-\n                 let name = item.name.get_ref().to_string();\n                 let mut item = Some(item);\n                 self.recurse(name, |this| {\n@@ -1323,7 +1336,7 @@ fn item_module(w: &mut fmt::Formatter, cx: &Context,\n                item: &clean::Item, items: &[clean::Item]) -> fmt::Result {\n     try!(document(w, item));\n     let mut indices = range(0, items.len()).filter(|i| {\n-        !ignore_private_module(&items[*i])\n+        !ignore_private_item(&items[*i])\n     }).collect::<Vec<uint>>();\n \n     fn cmp(i1: &clean::Item, i2: &clean::Item, idx1: uint, idx2: uint) -> Ordering {\n@@ -2009,7 +2022,7 @@ impl<'a> fmt::Show for Sidebar<'a> {\n fn build_sidebar(m: &clean::Module) -> HashMap<String, Vec<String>> {\n     let mut map = HashMap::new();\n     for item in m.items.iter() {\n-        if ignore_private_module(item) { continue }\n+        if ignore_private_item(item) { continue }\n \n         let short = shortty(item).to_static_str();\n         let myname = match item.name {\n@@ -2059,12 +2072,13 @@ fn item_primitive(w: &mut fmt::Formatter,\n     render_methods(w, it)\n }\n \n-fn ignore_private_module(it: &clean::Item) -> bool {\n+fn ignore_private_item(it: &clean::Item) -> bool {\n     match it.inner {\n         clean::ModuleItem(ref m) => {\n             (m.items.len() == 0 && it.doc_value().is_none()) ||\n                it.visibility != Some(ast::Public)\n         }\n+        clean::PrimitiveItem(..) => it.visibility != Some(ast::Public),\n         _ => false,\n     }\n }"}, {"sha": "440b829c80c4dfb98a1f021ee124b0e5a5f10349", "filename": "src/librustdoc/html/static/main.js", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/073c8f10fc40b07596fd1018a2002db8e6d5222a/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "raw_url": "https://github.com/rust-lang/rust/raw/073c8f10fc40b07596fd1018a2002db8e6d5222a/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js?ref=073c8f10fc40b07596fd1018a2002db8e6d5222a", "patch": "@@ -664,7 +664,10 @@\n             for (var j = 0; j < structs.length; j++) {\n                 var code = $('<code>').append(structs[j]);\n                 $.each(code.find('a'), function(idx, a) {\n-                    $(a).attr('href', rootPath + $(a).attr('href'));\n+                    var href = $(a).attr('href');\n+                    if (!href.startsWith('http')) {\n+                        $(a).attr('href', rootPath + $(a).attr('href'));\n+                    }\n                 });\n                 var li = $('<li>').append(code);\n                 list.append(li);"}]}