{"sha": "b8607653556b4022d08cead0df4e21cf15120bef", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI4NjA3NjUzNTU2YjQwMjJkMDhjZWFkMGRmNGUyMWNmMTUxMjBiZWY=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2018-10-20T20:15:39Z"}, "committer": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2018-10-20T20:15:39Z"}, "message": "Rollup merge of #55073 - alexcrichton:demote-simd, r=nagisa\n\nThe issue of passing around SIMD types as values between functions has\nseen [quite a lot] of [discussion], and although we thought [we fixed\nit][quite a lot] it [wasn't]! This PR is a change to rustc to, again,\ntry to fix this issue.\n\nThe fundamental problem here remains the same, if a SIMD vector argument\nis passed by-value in LLVM's function type, then if the caller and\ncallee disagree on target features a miscompile happens. We solve this\nby never passing SIMD vectors by-value, but LLVM will still thwart us\nwith its argument promotion pass to promote by-ref SIMD arguments to\nby-val SIMD arguments.\n\nThis commit is an attempt to thwart LLVM thwarting us. We, just before\ncodegen, will take yet another look at the LLVM module and demote any\nby-value SIMD arguments we see. This is a very manual attempt by us to\nensure the codegen for a module keeps working, and it unfortunately is\nlikely producing suboptimal code, even in release mode. The saving grace\nfor this, in theory, is that if SIMD types are passed by-value across\na boundary in release mode it's pretty unlikely to be performance\nsensitive (as it's already doing a load/store, and otherwise\nperf-sensitive bits should be inlined).\n\nThe implementation here is basically a big wad of C++. It was largely\ncopied from LLVM's own argument promotion pass, only doing the reverse.\nIn local testing this...\n\nCloses #50154\nCloses #52636\nCloses #54583\nCloses #55059\n\n[quite a lot]: https://github.com/rust-lang/rust/pull/47743\n[discussion]: https://github.com/rust-lang/rust/issues/44367\n[wasn't]: https://github.com/rust-lang/rust/issues/50154", "tree": {"sha": "e6e8097c6a2a7b33ec9743246e251f5f9ed2d232", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e6e8097c6a2a7b33ec9743246e251f5f9ed2d232"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b8607653556b4022d08cead0df4e21cf15120bef", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b8607653556b4022d08cead0df4e21cf15120bef", "html_url": "https://github.com/rust-lang/rust/commit/b8607653556b4022d08cead0df4e21cf15120bef", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b8607653556b4022d08cead0df4e21cf15120bef/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "22cc2ae8057d14e980b7c784e1eb2eee26b59e7d", "url": "https://api.github.com/repos/rust-lang/rust/commits/22cc2ae8057d14e980b7c784e1eb2eee26b59e7d", "html_url": "https://github.com/rust-lang/rust/commit/22cc2ae8057d14e980b7c784e1eb2eee26b59e7d"}, {"sha": "3cc8f738d4247a9b475d8e074b621e602ac2b7be", "url": "https://api.github.com/repos/rust-lang/rust/commits/3cc8f738d4247a9b475d8e074b621e602ac2b7be", "html_url": "https://github.com/rust-lang/rust/commit/3cc8f738d4247a9b475d8e074b621e602ac2b7be"}], "stats": {"total": 341, "additions": 332, "deletions": 9}, "files": [{"sha": "a3704d1154e0800bf004bf894b10e6142a9eb5b4", "filename": "src/librustc_codegen_llvm/back/lto.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b8607653556b4022d08cead0df4e21cf15120bef/src%2Flibrustc_codegen_llvm%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8607653556b4022d08cead0df4e21cf15120bef/src%2Flibrustc_codegen_llvm%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Flto.rs?ref=b8607653556b4022d08cead0df4e21cf15120bef", "patch": "@@ -80,9 +80,7 @@ impl LtoModuleCodegen {\n                 let module = module.take().unwrap();\n                 {\n                     let config = cgcx.config(module.kind);\n-                    let llmod = module.module_llvm.llmod();\n-                    let tm = &*module.module_llvm.tm;\n-                    run_pass_manager(cgcx, tm, llmod, config, false);\n+                    run_pass_manager(cgcx, &module, config, false);\n                     timeline.record(\"fat-done\");\n                 }\n                 Ok(module)\n@@ -557,8 +555,7 @@ fn thin_lto(cgcx: &CodegenContext,\n }\n \n fn run_pass_manager(cgcx: &CodegenContext,\n-                    tm: &llvm::TargetMachine,\n-                    llmod: &llvm::Module,\n+                    module: &ModuleCodegen,\n                     config: &ModuleConfig,\n                     thin: bool) {\n     // Now we have one massive module inside of llmod. Time to run the\n@@ -569,7 +566,8 @@ fn run_pass_manager(cgcx: &CodegenContext,\n     debug!(\"running the pass manager\");\n     unsafe {\n         let pm = llvm::LLVMCreatePassManager();\n-        llvm::LLVMRustAddAnalysisPasses(tm, pm, llmod);\n+        let llmod = module.module_llvm.llmod();\n+        llvm::LLVMRustAddAnalysisPasses(module.module_llvm.tm, pm, llmod);\n \n         if config.verify_llvm_ir {\n             let pass = llvm::LLVMRustFindAndCreatePass(\"verify\\0\".as_ptr() as *const _);\n@@ -864,7 +862,7 @@ impl ThinModule {\n             // little differently.\n             info!(\"running thin lto passes over {}\", module.name);\n             let config = cgcx.config(module.kind);\n-            run_pass_manager(cgcx, module.module_llvm.tm, llmod, config, true);\n+            run_pass_manager(cgcx, &module, config, true);\n             cgcx.save_temp_bitcode(&module, \"thin-lto-after-pm\");\n             timeline.record(\"thin-done\");\n         }"}, {"sha": "ba1315956fb2caa859cb156a49031f42566f4578", "filename": "src/librustc_codegen_llvm/back/write.rs", "status": "modified", "additions": 33, "deletions": 1, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/b8607653556b4022d08cead0df4e21cf15120bef/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8607653556b4022d08cead0df4e21cf15120bef/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs?ref=b8607653556b4022d08cead0df4e21cf15120bef", "patch": "@@ -633,7 +633,7 @@ unsafe fn optimize(cgcx: &CodegenContext,\n                  None,\n                  &format!(\"llvm module passes [{}]\", module_name.unwrap()),\n                  || {\n-            llvm::LLVMRunPassManager(mpm, llmod)\n+            llvm::LLVMRunPassManager(mpm, llmod);\n         });\n \n         // Deallocate managers that we're now done with\n@@ -691,6 +691,38 @@ unsafe fn codegen(cgcx: &CodegenContext,\n             create_msvc_imps(cgcx, llcx, llmod);\n         }\n \n+        // Ok now this one's a super interesting invocations. SIMD in rustc is\n+        // difficult where we want some parts of the program to be able to use\n+        // some SIMD features while other parts of the program don't. The real\n+        // tough part is that we want this to actually work correctly!\n+        //\n+        // We go to great lengths to make sure this works, and one crucial\n+        // aspect is that vector arguments (simd types) are never passed by\n+        // value in the ABI of functions. It turns out, however, that LLVM will\n+        // undo our \"clever work\" of passing vector types by reference. Its\n+        // argument promotion pass will promote these by-ref arguments to\n+        // by-val. That, however, introduces codegen errors!\n+        //\n+        // The upstream LLVM bug [1] has unfortunatey not really seen a lot of\n+        // activity. The Rust bug [2], however, has seen quite a lot of reports\n+        // of this in the wild. As a result, this is worked around locally here.\n+        // We have a custom transformation, `LLVMRustDemoteSimdArguments`, which\n+        // does the opposite of argument promotion by demoting any by-value SIMD\n+        // arguments in function signatures to pointers intead of being\n+        // by-value.\n+        //\n+        // This operates at the LLVM IR layer because LLVM is thwarting our\n+        // codegen and this is the only chance we get to make sure it's correct\n+        // before we hit codegen.\n+        //\n+        // Hopefully one day the upstream LLVM bug will be fixed and we'll no\n+        // longer need this!\n+        //\n+        // [1]: https://bugs.llvm.org/show_bug.cgi?id=37358\n+        // [2]: https://github.com/rust-lang/rust/issues/50154\n+        llvm::LLVMRustDemoteSimdArguments(llmod);\n+        cgcx.save_temp_bitcode(&module, \"simd-demoted\");\n+\n         // A codegen-specific pass manager is used to generate object\n         // files for an LLVM module.\n         //"}, {"sha": "e2b0142490933cbbc912d1bef2e2604382033179", "filename": "src/librustc_codegen_llvm/llvm/ffi.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b8607653556b4022d08cead0df4e21cf15120bef/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8607653556b4022d08cead0df4e21cf15120bef/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs?ref=b8607653556b4022d08cead0df4e21cf15120bef", "patch": "@@ -1138,6 +1138,8 @@ extern \"C\" {\n     /// Runs a pass manager on a module.\n     pub fn LLVMRunPassManager(PM: &PassManager<'a>, M: &'a Module) -> Bool;\n \n+    pub fn LLVMRustDemoteSimdArguments(M: &'a Module);\n+\n     pub fn LLVMInitializePasses();\n \n     pub fn LLVMPassManagerBuilderCreate() -> &'static mut PassManagerBuilder;"}, {"sha": "ad5db19839ef0234476e43c1ef9b3859bd13f552", "filename": "src/librustc_llvm/build.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b8607653556b4022d08cead0df4e21cf15120bef/src%2Flibrustc_llvm%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8607653556b4022d08cead0df4e21cf15120bef/src%2Flibrustc_llvm%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Fbuild.rs?ref=b8607653556b4022d08cead0df4e21cf15120bef", "patch": "@@ -162,7 +162,9 @@ fn main() {\n     }\n \n     build_helper::rerun_if_changed_anything_in_dir(Path::new(\"../rustllvm\"));\n-    cfg.file(\"../rustllvm/PassWrapper.cpp\")\n+    cfg\n+       .file(\"../rustllvm/DemoteSimd.cpp\")\n+       .file(\"../rustllvm/PassWrapper.cpp\")\n        .file(\"../rustllvm/RustWrapper.cpp\")\n        .file(\"../rustllvm/ArchiveWrapper.cpp\")\n        .file(\"../rustllvm/Linker.cpp\")"}, {"sha": "e9203baa0d7b13e899584609efcaaa2e62d99ccc", "filename": "src/rustllvm/DemoteSimd.cpp", "status": "added", "additions": 189, "deletions": 0, "changes": 189, "blob_url": "https://github.com/rust-lang/rust/blob/b8607653556b4022d08cead0df4e21cf15120bef/src%2Frustllvm%2FDemoteSimd.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/b8607653556b4022d08cead0df4e21cf15120bef/src%2Frustllvm%2FDemoteSimd.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FDemoteSimd.cpp?ref=b8607653556b4022d08cead0df4e21cf15120bef", "patch": "@@ -0,0 +1,189 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#include <vector>\n+#include <set>\n+\n+#include \"rustllvm.h\"\n+\n+#if LLVM_VERSION_GE(5, 0)\n+\n+#include \"llvm/IR/CallSite.h\"\n+#include \"llvm/IR/Module.h\"\n+#include \"llvm/ADT/STLExtras.h\"\n+\n+using namespace llvm;\n+\n+static std::vector<Function*>\n+GetFunctionsWithSimdArgs(Module *M) {\n+  std::vector<Function*> Ret;\n+\n+  for (auto &F : M->functions()) {\n+    // Skip all intrinsic calls as these are always tightly controlled to \"work\n+    // correctly\", so no need to fixup any of these.\n+    if (F.isIntrinsic())\n+      continue;\n+\n+    // We're only interested in rustc-defined functions, not unstably-defined\n+    // imported SIMD ffi functions.\n+    if (F.isDeclaration())\n+      continue;\n+\n+    // Argument promotion only happens on internal functions, so skip demoting\n+    // arguments in external functions like FFI shims and such.\n+    if (!F.hasLocalLinkage())\n+      continue;\n+\n+    // If any argument to this function is a by-value vector type, then that's\n+    // bad! The compiler didn't generate any functions that looked like this,\n+    // and we try to rely on LLVM to not do this! Argument promotion may,\n+    // however, promote arguments from behind references. In any case, figure\n+    // out if we're interested in demoting this argument.\n+    if (any_of(F.args(), [](Argument &arg) { return arg.getType()->isVectorTy(); }))\n+      Ret.push_back(&F);\n+  }\n+\n+  return Ret;\n+}\n+\n+extern \"C\" void\n+LLVMRustDemoteSimdArguments(LLVMModuleRef Mod) {\n+  Module *M = unwrap(Mod);\n+\n+  auto Functions = GetFunctionsWithSimdArgs(M);\n+\n+  for (auto F : Functions) {\n+    // Build up our list of new parameters and new argument attributes.\n+    // We're only changing those arguments which are vector types.\n+    SmallVector<Type*, 8> Params;\n+    SmallVector<AttributeSet, 8> ArgAttrVec;\n+    auto PAL = F->getAttributes();\n+    for (auto &Arg : F->args()) {\n+      auto *Ty = Arg.getType();\n+      if (Ty->isVectorTy()) {\n+        Params.push_back(PointerType::get(Ty, 0));\n+        ArgAttrVec.push_back(AttributeSet());\n+      } else {\n+        Params.push_back(Ty);\n+        ArgAttrVec.push_back(PAL.getParamAttributes(Arg.getArgNo()));\n+      }\n+    }\n+\n+    // Replace `F` with a new function with our new signature. I'm... not really\n+    // sure how this works, but this is all the steps `ArgumentPromotion` does\n+    // to replace a signature as well.\n+    assert(!F->isVarArg()); // ArgumentPromotion should skip these fns\n+    FunctionType *NFTy = FunctionType::get(F->getReturnType(), Params, false);\n+    Function *NF = Function::Create(NFTy, F->getLinkage(), F->getName());\n+    NF->copyAttributesFrom(F);\n+    NF->setSubprogram(F->getSubprogram());\n+    F->setSubprogram(nullptr);\n+    NF->setAttributes(AttributeList::get(F->getContext(),\n+                                         PAL.getFnAttributes(),\n+                                         PAL.getRetAttributes(),\n+                                         ArgAttrVec));\n+    ArgAttrVec.clear();\n+    F->getParent()->getFunctionList().insert(F->getIterator(), NF);\n+    NF->takeName(F);\n+\n+    // Iterate over all invocations of `F`, updating all `call` instructions to\n+    // store immediate vector types in a local `alloc` instead of a by-value\n+    // vector.\n+    //\n+    // Like before, much of this is copied from the `ArgumentPromotion` pass in\n+    // LLVM.\n+    SmallVector<Value*, 16> Args;\n+    while (!F->use_empty()) {\n+      CallSite CS(F->user_back());\n+      assert(CS.getCalledFunction() == F);\n+      Instruction *Call = CS.getInstruction();\n+      const AttributeList &CallPAL = CS.getAttributes();\n+\n+      // Loop over the operands, inserting an `alloca` and a store for any\n+      // argument we're demoting to be by reference\n+      //\n+      // FIXME: we probably want to figure out an LLVM pass to run and clean up\n+      // this function and instructions we're generating, we should in theory\n+      // only generate a maximum number of `alloca` instructions rather than\n+      // one-per-variable unconditionally.\n+      CallSite::arg_iterator AI = CS.arg_begin();\n+      size_t ArgNo = 0;\n+      for (Function::arg_iterator I = F->arg_begin(), E = F->arg_end(); I != E;\n+           ++I, ++AI, ++ArgNo) {\n+        if (I->getType()->isVectorTy()) {\n+          AllocaInst *AllocA = new AllocaInst(I->getType(), 0, nullptr, \"\", Call);\n+          new StoreInst(*AI, AllocA, Call);\n+          Args.push_back(AllocA);\n+          ArgAttrVec.push_back(AttributeSet());\n+        } else {\n+          Args.push_back(*AI);\n+          ArgAttrVec.push_back(CallPAL.getParamAttributes(ArgNo));\n+        }\n+      }\n+      assert(AI == CS.arg_end());\n+\n+      // Create a new call instructions which we'll use to replace the old call\n+      // instruction, copying over as many attributes and such as possible.\n+      SmallVector<OperandBundleDef, 1> OpBundles;\n+      CS.getOperandBundlesAsDefs(OpBundles);\n+\n+      CallSite NewCS;\n+      if (InvokeInst *II = dyn_cast<InvokeInst>(Call)) {\n+        InvokeInst::Create(NF, II->getNormalDest(), II->getUnwindDest(),\n+                           Args, OpBundles, \"\", Call);\n+      } else {\n+        auto *NewCall = CallInst::Create(NF, Args, OpBundles, \"\", Call);\n+        NewCall->setTailCallKind(cast<CallInst>(Call)->getTailCallKind());\n+        NewCS = NewCall;\n+      }\n+      NewCS.setCallingConv(CS.getCallingConv());\n+      NewCS.setAttributes(\n+          AttributeList::get(F->getContext(), CallPAL.getFnAttributes(),\n+                             CallPAL.getRetAttributes(), ArgAttrVec));\n+      NewCS->setDebugLoc(Call->getDebugLoc());\n+      Args.clear();\n+      ArgAttrVec.clear();\n+      Call->replaceAllUsesWith(NewCS.getInstruction());\n+      NewCS->takeName(Call);\n+      Call->eraseFromParent();\n+    }\n+\n+    // Splice the body of the old function right into the new function.\n+    NF->getBasicBlockList().splice(NF->begin(), F->getBasicBlockList());\n+\n+    // Update our new function to replace all uses of the by-value argument with\n+    // loads of the pointer argument we've generated.\n+    //\n+    // FIXME: we probably want to only generate one load instruction per\n+    // function? Or maybe run an LLVM pass to clean up this function?\n+    for (Function::arg_iterator I = F->arg_begin(),\n+                                E = F->arg_end(),\n+                                I2 = NF->arg_begin();\n+         I != E;\n+         ++I, ++I2) {\n+      if (I->getType()->isVectorTy()) {\n+        I->replaceAllUsesWith(new LoadInst(&*I2, \"\", &NF->begin()->front()));\n+      } else {\n+        I->replaceAllUsesWith(&*I2);\n+      }\n+      I2->takeName(&*I);\n+    }\n+\n+    // Delete all references to the old function, it should be entirely dead\n+    // now.\n+    M->getFunctionList().remove(F);\n+  }\n+}\n+\n+#else // LLVM_VERSION_GE(8, 0)\n+extern \"C\" void\n+LLVMRustDemoteSimdArguments(LLVMModuleRef Mod) {\n+}\n+#endif // LLVM_VERSION_GE(8, 0)"}, {"sha": "3095432d0fe6965cc88171e506a9fd0021f0f8e3", "filename": "src/test/run-make/simd-argument-promotion-thwarted/Makefile", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/b8607653556b4022d08cead0df4e21cf15120bef/src%2Ftest%2Frun-make%2Fsimd-argument-promotion-thwarted%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/b8607653556b4022d08cead0df4e21cf15120bef/src%2Ftest%2Frun-make%2Fsimd-argument-promotion-thwarted%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fsimd-argument-promotion-thwarted%2FMakefile?ref=b8607653556b4022d08cead0df4e21cf15120bef", "patch": "@@ -0,0 +1,13 @@\n+-include ../../run-make-fulldeps/tools.mk\n+\n+ifeq ($(TARGET),x86_64-unknown-linux-gnu)\n+all:\n+\t$(RUSTC) t1.rs -C opt-level=3\n+\t$(TMPDIR)/t1\n+\t$(RUSTC) t2.rs -C opt-level=3\n+\t$(TMPDIR)/t2\n+\t$(RUSTC) t3.rs -C opt-level=3\n+\t$(TMPDIR)/t3\n+else\n+all:\n+endif"}, {"sha": "cb4a3dd7d4a7cb978380cce0bafd0cfc9e2499cf", "filename": "src/test/run-make/simd-argument-promotion-thwarted/t1.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/b8607653556b4022d08cead0df4e21cf15120bef/src%2Ftest%2Frun-make%2Fsimd-argument-promotion-thwarted%2Ft1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8607653556b4022d08cead0df4e21cf15120bef/src%2Ftest%2Frun-make%2Fsimd-argument-promotion-thwarted%2Ft1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fsimd-argument-promotion-thwarted%2Ft1.rs?ref=b8607653556b4022d08cead0df4e21cf15120bef", "patch": "@@ -0,0 +1,21 @@\n+use std::arch::x86_64;\n+\n+fn main() {\n+    if !is_x86_feature_detected!(\"avx2\") {\n+        return println!(\"AVX2 is not supported on this machine/build.\");\n+    }\n+    let load_bytes: [u8; 32] = [0x0f; 32];\n+    let lb_ptr = load_bytes.as_ptr();\n+    let reg_load = unsafe {\n+        x86_64::_mm256_loadu_si256(\n+            lb_ptr as *const x86_64::__m256i\n+        )\n+    };\n+    println!(\"{:?}\", reg_load);\n+    let mut store_bytes: [u8; 32] = [0; 32];\n+    let sb_ptr = store_bytes.as_mut_ptr();\n+    unsafe {\n+        x86_64::_mm256_storeu_si256(sb_ptr as *mut x86_64::__m256i, reg_load);\n+    }\n+    assert_eq!(load_bytes, store_bytes);\n+}"}, {"sha": "0e42b82a223d0aeab89c1880ab387c9f62dc9145", "filename": "src/test/run-make/simd-argument-promotion-thwarted/t2.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b8607653556b4022d08cead0df4e21cf15120bef/src%2Ftest%2Frun-make%2Fsimd-argument-promotion-thwarted%2Ft2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8607653556b4022d08cead0df4e21cf15120bef/src%2Ftest%2Frun-make%2Fsimd-argument-promotion-thwarted%2Ft2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fsimd-argument-promotion-thwarted%2Ft2.rs?ref=b8607653556b4022d08cead0df4e21cf15120bef", "patch": "@@ -0,0 +1,14 @@\n+use std::arch::x86_64::*;\n+\n+fn main() {\n+    if !is_x86_feature_detected!(\"avx\") {\n+        return println!(\"AVX is not supported on this machine/build.\");\n+    }\n+    unsafe {\n+        let f = _mm256_set_pd(2.0, 2.0, 2.0, 2.0);\n+        let r = _mm256_mul_pd(f, f);\n+\n+        union A { a: __m256d, b: [f64; 4] }\n+        assert_eq!(A { a: r }.b, [4.0, 4.0, 4.0, 4.0]);\n+    }\n+}"}, {"sha": "10062ab3e46438ce341da4dfc696f711eadf0aa8", "filename": "src/test/run-make/simd-argument-promotion-thwarted/t3.rs", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/b8607653556b4022d08cead0df4e21cf15120bef/src%2Ftest%2Frun-make%2Fsimd-argument-promotion-thwarted%2Ft3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8607653556b4022d08cead0df4e21cf15120bef/src%2Ftest%2Frun-make%2Fsimd-argument-promotion-thwarted%2Ft3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fsimd-argument-promotion-thwarted%2Ft3.rs?ref=b8607653556b4022d08cead0df4e21cf15120bef", "patch": "@@ -0,0 +1,52 @@\n+use std::arch::x86_64::*;\n+\n+#[target_feature(enable = \"avx\")]\n+unsafe fn avx_mul(a: __m256, b: __m256) -> __m256 {\n+    _mm256_mul_ps(a, b)\n+}\n+\n+#[target_feature(enable = \"avx\")]\n+unsafe fn avx_store(p: *mut f32, a: __m256) {\n+    _mm256_storeu_ps(p, a)\n+}\n+\n+#[target_feature(enable = \"avx\")]\n+unsafe fn avx_setr(a: f32, b: f32, c: f32, d: f32, e: f32, f: f32, g: f32, h: f32) -> __m256 {\n+    _mm256_setr_ps(a, b, c, d, e, f, g, h)\n+}\n+\n+#[target_feature(enable = \"avx\")]\n+unsafe fn avx_set1(a: f32) -> __m256 {\n+    _mm256_set1_ps(a)\n+}\n+\n+struct Avx(__m256);\n+\n+fn mul(a: Avx, b: Avx) -> Avx {\n+    unsafe { Avx(avx_mul(a.0, b.0)) }\n+}\n+\n+fn set1(a: f32) -> Avx {\n+    unsafe { Avx(avx_set1(a)) }\n+}\n+\n+fn setr(a: f32, b: f32, c: f32, d: f32, e: f32, f: f32, g: f32, h: f32) -> Avx {\n+    unsafe { Avx(avx_setr(a, b, c, d, e, f, g, h)) }\n+}\n+\n+unsafe fn store(p: *mut f32, a: Avx) {\n+    avx_store(p, a.0);\n+}\n+\n+fn main() {\n+    if !is_x86_feature_detected!(\"avx\") {\n+        return println!(\"AVX is not supported on this machine/build.\");\n+    }\n+    let mut result = [0.0f32; 8];\n+    let a = mul(setr(0.0, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0), set1(0.25));\n+    unsafe {\n+        store(result.as_mut_ptr(), a);\n+    }\n+\n+    assert_eq!(result, [0.0, 0.25, 0.5, 0.75, 1.0, 1.25, 1.50, 1.75]);\n+}"}]}