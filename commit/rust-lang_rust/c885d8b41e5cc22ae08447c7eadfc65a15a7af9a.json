{"sha": "c885d8b41e5cc22ae08447c7eadfc65a15a7af9a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM4ODVkOGI0MWU1Y2MyMmFlMDg0NDdjN2VhZGZjNjVhMTVhN2FmOWE=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-10-17T15:36:26Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-10-18T10:09:00Z"}, "message": "don't do any work towards ptr provenance in const mode", "tree": {"sha": "283f40bb8e7482b511dc91ccd6a52246c72f94f9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/283f40bb8e7482b511dc91ccd6a52246c72f94f9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c885d8b41e5cc22ae08447c7eadfc65a15a7af9a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c885d8b41e5cc22ae08447c7eadfc65a15a7af9a", "html_url": "https://github.com/rust-lang/rust/commit/c885d8b41e5cc22ae08447c7eadfc65a15a7af9a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c885d8b41e5cc22ae08447c7eadfc65a15a7af9a/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2af11f743331f995fde87dd2bcc77e7c77229d0a", "url": "https://api.github.com/repos/rust-lang/rust/commits/2af11f743331f995fde87dd2bcc77e7c77229d0a", "html_url": "https://github.com/rust-lang/rust/commit/2af11f743331f995fde87dd2bcc77e7c77229d0a"}], "stats": {"total": 18, "additions": 13, "deletions": 5}, "files": [{"sha": "bc917140bbd679a7907d8ffdc54b63ba21499bc7", "filename": "src/librustc_mir/const_eval.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c885d8b41e5cc22ae08447c7eadfc65a15a7af9a/src%2Flibrustc_mir%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c885d8b41e5cc22ae08447c7eadfc65a15a7af9a/src%2Flibrustc_mir%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval.rs?ref=c885d8b41e5cc22ae08447c7eadfc65a15a7af9a", "patch": "@@ -348,6 +348,7 @@ impl<'a, 'mir, 'tcx> interpret::Machine<'a, 'mir, 'tcx>\n     type MemoryMap = FxHashMap<AllocId, (MemoryKind<!>, Allocation)>;\n \n     const STATIC_KIND: Option<!> = None; // no copying of statics allowed\n+    const ENABLE_PTR_TRACKING_HOOKS: bool = false; // we don't have no provenance\n \n     #[inline(always)]\n     fn enforce_validity(_ecx: &EvalContext<'a, 'mir, 'tcx, Self>) -> bool {"}, {"sha": "62c42c4a49380e208e4fccc4aa28dd10457dfd46", "filename": "src/librustc_mir/interpret/cast.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c885d8b41e5cc22ae08447c7eadfc65a15a7af9a/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c885d8b41e5cc22ae08447c7eadfc65a15a7af9a/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fcast.rs?ref=c885d8b41e5cc22ae08447c7eadfc65a15a7af9a", "patch": "@@ -47,7 +47,9 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n             Misc => {\n                 let src = self.read_value(src)?;\n \n-                if src.layout.ty.is_region_ptr() && dest.layout.ty.is_unsafe_ptr() {\n+                if M::ENABLE_PTR_TRACKING_HOOKS &&\n+                    src.layout.ty.is_region_ptr() && dest.layout.ty.is_unsafe_ptr()\n+                {\n                     // For the purpose of the \"ptr tag hooks\", treat this as creating\n                     // a new, raw reference.\n                     let place = self.ref_to_mplace(src)?;"}, {"sha": "1318bbe1c2bf286d22ec255726afd7e001061f9c", "filename": "src/librustc_mir/interpret/machine.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c885d8b41e5cc22ae08447c7eadfc65a15a7af9a/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c885d8b41e5cc22ae08447c7eadfc65a15a7af9a/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs?ref=c885d8b41e5cc22ae08447c7eadfc65a15a7af9a", "patch": "@@ -101,6 +101,11 @@ pub trait Machine<'a, 'mir, 'tcx>: Sized {\n     /// that is added to the memory so that the work is not done twice.\n     const STATIC_KIND: Option<Self::MemoryKinds>;\n \n+    /// As an optimization, you can prevent the pointer tracking hooks from ever being\n+    /// called.  You should only do this if you do not care about provenance tracking.\n+    /// This controls the `tag_reference` and `tag_dereference` hooks.\n+    const ENABLE_PTR_TRACKING_HOOKS: bool;\n+\n     /// Whether to enforce the validity invariant\n     fn enforce_validity(ecx: &EvalContext<'a, 'mir, 'tcx, Self>) -> bool;\n "}, {"sha": "af3d6948628398cb7b8134bf4fc17b6a18c6a3fb", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c885d8b41e5cc22ae08447c7eadfc65a15a7af9a/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c885d8b41e5cc22ae08447c7eadfc65a15a7af9a/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=c885d8b41e5cc22ae08447c7eadfc65a15a7af9a", "patch": "@@ -265,12 +265,12 @@ where\n         val: ValTy<'tcx, M::PointerTag>,\n     ) -> EvalResult<'tcx, MPlaceTy<'tcx, M::PointerTag>> {\n         let ptr = match val.to_scalar_ptr()? {\n-            Scalar::Ptr(ptr) => {\n+            Scalar::Ptr(ptr) if M::ENABLE_PTR_TRACKING_HOOKS => {\n                 // Machine might want to track the `*` operator\n                 let tag = M::tag_dereference(self, ptr, val.layout.ty)?;\n                 Scalar::Ptr(Pointer::new_with_tag(ptr.alloc_id, ptr.offset, tag))\n             }\n-            scalar @ Scalar::Bits { .. } => scalar,\n+            other => other,\n         };\n \n         let pointee_type = val.layout.ty.builtin_deref(true).unwrap().ty;\n@@ -294,14 +294,14 @@ where\n         borrow_kind: Option<mir::BorrowKind>,\n     ) -> EvalResult<'tcx, Value<M::PointerTag>> {\n         let ptr = match place.ptr {\n-            Scalar::Ptr(ptr) => {\n+            Scalar::Ptr(ptr) if M::ENABLE_PTR_TRACKING_HOOKS => {\n                 // Machine might want to track the `&` operator\n                 let (size, _) = self.size_and_align_of_mplace(place)?\n                     .expect(\"create_ref cannot determine size\");\n                 let tag = M::tag_reference(self, ptr, place.layout.ty, size, borrow_kind)?;\n                 Scalar::Ptr(Pointer::new_with_tag(ptr.alloc_id, ptr.offset, tag))\n             },\n-            scalar @ Scalar::Bits { .. } => scalar,\n+            other => other,\n         };\n         Ok(match place.meta {\n             None => Value::Scalar(ptr.into()),"}]}