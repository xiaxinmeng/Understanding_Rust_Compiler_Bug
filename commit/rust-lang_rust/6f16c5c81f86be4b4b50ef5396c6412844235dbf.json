{"sha": "6f16c5c81f86be4b4b50ef5396c6412844235dbf", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZmMTZjNWM4MWY4NmJlNGI0YjUwZWY1Mzk2YzY0MTI4NDQyMzVkYmY=", "commit": {"author": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-02-25T02:11:29Z"}, "committer": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-03-30T21:26:35Z"}, "message": "Autoderef privacy for methods", "tree": {"sha": "d6603e853b6a62d4e4b07f075fb315166b8bdff7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d6603e853b6a62d4e4b07f075fb315166b8bdff7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6f16c5c81f86be4b4b50ef5396c6412844235dbf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6f16c5c81f86be4b4b50ef5396c6412844235dbf", "html_url": "https://github.com/rust-lang/rust/commit/6f16c5c81f86be4b4b50ef5396c6412844235dbf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6f16c5c81f86be4b4b50ef5396c6412844235dbf/comments", "author": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "62d181f474f5d3bb99ff157a9f27ec9f7e87938f", "url": "https://api.github.com/repos/rust-lang/rust/commits/62d181f474f5d3bb99ff157a9f27ec9f7e87938f", "html_url": "https://github.com/rust-lang/rust/commit/62d181f474f5d3bb99ff157a9f27ec9f7e87938f"}], "stats": {"total": 60, "additions": 46, "deletions": 14}, "files": [{"sha": "8c8d02bd3e6d68eb03ae664729f0179d95b0d15c", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6f16c5c81f86be4b4b50ef5396c6412844235dbf/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f16c5c81f86be4b4b50ef5396c6412844235dbf/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=6f16c5c81f86be4b4b50ef5396c6412844235dbf", "patch": "@@ -43,6 +43,9 @@ pub enum MethodError<'tcx> {\n \n     // Using a `Fn`/`FnMut`/etc method on a raw closure type before we have inferred its kind.\n     ClosureAmbiguity(/* DefId of fn trait */ DefId),\n+\n+    // Found an applicable method, but it is not visible.\n+    PrivateMatch(Def),\n }\n \n // Contains a list of static methods that may apply, a list of unsatisfied trait predicates which\n@@ -90,6 +93,7 @@ pub fn exists<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         Err(NoMatch(..)) => false,\n         Err(Ambiguity(..)) => true,\n         Err(ClosureAmbiguity(..)) => true,\n+        Err(PrivateMatch(..)) => true,\n     }\n }\n "}, {"sha": "477b46ce4cef4f41c334708b7b18e22ed389add6", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/6f16c5c81f86be4b4b50ef5396c6412844235dbf/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f16c5c81f86be4b4b50ef5396c6412844235dbf/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=6f16c5c81f86be4b4b50ef5396c6412844235dbf", "patch": "@@ -16,6 +16,7 @@ use super::suggest;\n use check;\n use check::{FnCtxt, UnresolvedTypeAction};\n use middle::def_id::DefId;\n+use middle::def::Def;\n use rustc::ty::subst;\n use rustc::ty::subst::Subst;\n use rustc::traits;\n@@ -47,6 +48,9 @@ struct ProbeContext<'a, 'tcx:'a> {\n     /// used for error reporting\n     static_candidates: Vec<CandidateSource>,\n \n+    /// Some(candidate) if there is a private candidate\n+    private_candidate: Option<Def>,\n+\n     /// Collects near misses when trait bounds for type parameters are unsatisfied and is only used\n     /// for error reporting\n     unsatisfied_predicates: Vec<TraitRef<'tcx>>\n@@ -247,6 +251,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n             steps: Rc::new(steps),\n             opt_simplified_steps: opt_simplified_steps,\n             static_candidates: Vec::new(),\n+            private_candidate: None,\n             unsatisfied_predicates: Vec::new(),\n         }\n     }\n@@ -256,6 +261,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n         self.extension_candidates.clear();\n         self.impl_dups.clear();\n         self.static_candidates.clear();\n+        self.private_candidate = None;\n     }\n \n     fn tcx(&self) -> &'a TyCtxt<'tcx> {\n@@ -407,6 +413,11 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n             return self.record_static_candidate(ImplSource(impl_def_id));\n         }\n \n+        if item.vis() != hir::Public && !self.fcx.private_item_is_visible(item.def_id()) {\n+            self.private_candidate = Some(item.def());\n+            return\n+        }\n+\n         let (impl_ty, impl_substs) = self.impl_ty_and_substs(impl_def_id);\n         let impl_ty = impl_ty.subst(self.tcx(), &impl_substs);\n \n@@ -846,6 +857,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n         }\n \n         let static_candidates = mem::replace(&mut self.static_candidates, vec![]);\n+        let private_candidate = mem::replace(&mut self.private_candidate, None);\n         let unsatisfied_predicates = mem::replace(&mut self.unsatisfied_predicates, vec![]);\n \n         // things failed, so lets look at all traits, for diagnostic purposes now:\n@@ -879,9 +891,13 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n                 // this error only occurs when assembling candidates\n                 tcx.sess.span_bug(span, \"encountered ClosureAmbiguity from pick_core\");\n             }\n-            None => vec![],\n+            _ => vec![],\n         };\n \n+        if let Some(def) = private_candidate {\n+            return Err(MethodError::PrivateMatch(def));\n+        }\n+\n         Err(MethodError::NoMatch(NoMatchData::new(static_candidates, unsatisfied_predicates,\n                                                   out_of_scope_traits, self.mode)))\n     }"}, {"sha": "f1d67883117ec0595b4baf01bc3d72c7ceae3ebb", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6f16c5c81f86be4b4b50ef5396c6412844235dbf/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f16c5c81f86be4b4b50ef5396c6412844235dbf/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=6f16c5c81f86be4b4b50ef5396c6412844235dbf", "patch": "@@ -91,7 +91,7 @@ pub fn report_error<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         MethodError::NoMatch(NoMatchData { static_candidates: static_sources,\n                                            unsatisfied_predicates,\n                                            out_of_scope_traits,\n-                                           mode }) => {\n+                                           mode, .. }) => {\n             let cx = fcx.tcx();\n \n             let mut err = fcx.type_error_struct(\n@@ -208,6 +208,11 @@ pub fn report_error<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n             };\n             fcx.sess().span_err(span, &msg);\n         }\n+\n+        MethodError::PrivateMatch(def) => {\n+            let msg = format!(\"{} `{}` is private\", def.kind_name(), item_name);\n+            fcx.tcx().sess.span_err(span, &msg);\n+        }\n     }\n \n     fn report_candidates(fcx: &FnCtxt,"}, {"sha": "78694b2e96f8a199510418efdf8c7da717db5efc", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 19, "deletions": 12, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/6f16c5c81f86be4b4b50ef5396c6412844235dbf/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f16c5c81f86be4b4b50ef5396c6412844235dbf/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=6f16c5c81f86be4b4b50ef5396c6412844235dbf", "patch": "@@ -3757,23 +3757,30 @@ pub fn resolve_ty_and_def_ufcs<'a, 'b, 'tcx>(fcx: &FnCtxt<'b, 'tcx>,\n                                                      &ty_segments[base_ty_end..]);\n         let item_segment = path.segments.last().unwrap();\n         let item_name = item_segment.identifier.name;\n-        match method::resolve_ufcs(fcx, span, item_name, ty, node_id) {\n-            Ok(def) => {\n-                // Write back the new resolution.\n-                fcx.ccx.tcx.def_map.borrow_mut()\n-                       .insert(node_id, def::PathResolution {\n-                   base_def: def,\n-                   depth: 0\n-                });\n-                Some((Some(ty), slice::ref_slice(item_segment), def))\n-            }\n+        let def = match method::resolve_ufcs(fcx, span, item_name, ty, node_id) {\n+            Ok(def) => Some(def),\n             Err(error) => {\n+                let def = match error {\n+                    method::MethodError::PrivateMatch(def) => Some(def),\n+                    _ => None,\n+                };\n                 if item_name != special_idents::invalid.name {\n                     method::report_error(fcx, span, ty, item_name, None, error);\n                 }\n-                fcx.write_error(node_id);\n-                None\n+                def\n             }\n+        };\n+\n+        if let Some(def) = def {\n+            // Write back the new resolution.\n+            fcx.ccx.tcx.def_map.borrow_mut().insert(node_id, def::PathResolution {\n+                base_def: def,\n+                depth: 0,\n+            });\n+            Some((Some(ty), slice::ref_slice(item_segment), def))\n+        } else {\n+            fcx.write_error(node_id);\n+            None\n         }\n     }\n }"}]}