{"sha": "226156f673ecf52cf1bc337c92a1b79a98252d36", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIyNjE1NmY2NzNlY2Y1MmNmMWJjMzM3YzkyYTFiNzlhOTgyNTJkMzY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-07-06T08:26:10Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-07-06T08:26:10Z"}, "message": "Auto merge of #808 - RalfJung:extra-fn, r=RalfJung\n\nuse Dlsym support to implement getentropy (and better thread spawn error)\n\nThis is the Miri side of https://github.com/rust-lang/rust/pull/62245.\n\nFixes https://github.com/rust-lang/miri/issues/789", "tree": {"sha": "7e624b508cd5bff4bcd9ca02f292a311bc4e882a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7e624b508cd5bff4bcd9ca02f292a311bc4e882a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/226156f673ecf52cf1bc337c92a1b79a98252d36", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/226156f673ecf52cf1bc337c92a1b79a98252d36", "html_url": "https://github.com/rust-lang/rust/commit/226156f673ecf52cf1bc337c92a1b79a98252d36", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/226156f673ecf52cf1bc337c92a1b79a98252d36/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cb09fab5ffc8f204f59c887ad4fb7c75c3d95c30", "url": "https://api.github.com/repos/rust-lang/rust/commits/cb09fab5ffc8f204f59c887ad4fb7c75c3d95c30", "html_url": "https://github.com/rust-lang/rust/commit/cb09fab5ffc8f204f59c887ad4fb7c75c3d95c30"}, {"sha": "fbf3f5e0c97f1cf6fffeabb824327ab8cc9030d6", "url": "https://api.github.com/repos/rust-lang/rust/commits/fbf3f5e0c97f1cf6fffeabb824327ab8cc9030d6", "html_url": "https://github.com/rust-lang/rust/commit/fbf3f5e0c97f1cf6fffeabb824327ab8cc9030d6"}], "stats": {"total": 310, "additions": 186, "deletions": 124}, "files": [{"sha": "e70f05a0090dd1edabc686b1993fe5795b614ed3", "filename": "rust-version", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/226156f673ecf52cf1bc337c92a1b79a98252d36/rust-version", "raw_url": "https://github.com/rust-lang/rust/raw/226156f673ecf52cf1bc337c92a1b79a98252d36/rust-version", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/rust-version?ref=226156f673ecf52cf1bc337c92a1b79a98252d36", "patch": "@@ -1 +1 @@\n-481068a707679257e2a738b40987246e0420e787\n+b820c761744db080ff7a4ba3ac88d259065cb836"}, {"sha": "bf99d3e61166b2069f56c740cbff7760e3aedfee", "filename": "src/eval.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/226156f673ecf52cf1bc337c92a1b79a98252d36/src%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/226156f673ecf52cf1bc337c92a1b79a98252d36/src%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Feval.rs?ref=226156f673ecf52cf1bc337c92a1b79a98252d36", "patch": "@@ -11,7 +11,7 @@ use rustc::mir;\n \n use crate::{\n     InterpResult, InterpError, InterpCx, StackPopCleanup, struct_error,\n-    Scalar, Tag, Pointer,\n+    Scalar, Tag, Pointer, FnVal,\n     MemoryExtra, MiriMemoryKind, Evaluator, TlsEvalContextExt,\n };\n \n@@ -93,7 +93,7 @@ pub fn create_ecx<'mir, 'tcx: 'mir>(\n     let mut args = ecx.frame().body.args_iter();\n \n     // First argument: pointer to `main()`.\n-    let main_ptr = ecx.memory_mut().create_fn_alloc(main_instance);\n+    let main_ptr = ecx.memory_mut().create_fn_alloc(FnVal::Instance(main_instance));\n     let dest = ecx.eval_place(&mir::Place::Base(mir::PlaceBase::Local(args.next().unwrap())))?;\n     ecx.write_scalar(Scalar::Ptr(main_ptr), dest)?;\n "}, {"sha": "b9fa7bc2a77a4951f35ad11969e84fe507b2b526", "filename": "src/helpers.rs", "status": "modified", "additions": 37, "deletions": 1, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/226156f673ecf52cf1bc337c92a1b79a98252d36/src%2Fhelpers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/226156f673ecf52cf1bc337c92a1b79a98252d36/src%2Fhelpers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fhelpers.rs?ref=226156f673ecf52cf1bc337c92a1b79a98252d36", "patch": "@@ -1,8 +1,10 @@\n use std::mem;\n \n-use rustc::ty::{self, layout::{self, Size}};\n+use rustc::ty::{self, layout::{self, Size, Align}};\n use rustc::hir::def_id::{DefId, CRATE_DEF_INDEX};\n \n+use rand::RngCore;\n+\n use crate::*;\n \n impl<'mir, 'tcx> EvalContextExt<'mir, 'tcx> for crate::MiriEvalContext<'mir, 'tcx> {}\n@@ -65,6 +67,40 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         })\n     }\n \n+    /// Generate some random bytes, and write them to `dest`.\n+    fn gen_random(\n+        &mut self,\n+        len: usize,\n+        ptr: Scalar<Tag>,\n+    ) -> InterpResult<'tcx>  {\n+        let this = self.eval_context_mut();\n+\n+        let ptr = match this.memory().check_ptr_access(ptr, Size::from_bytes(len as u64), Align::from_bytes(1).unwrap())? {\n+            Some(ptr) => ptr,\n+            None => return Ok(()), // zero-sized access\n+        };\n+\n+        let data = match &mut this.memory_mut().extra.rng {\n+            Some(rng) => {\n+                let mut rng = rng.borrow_mut();\n+                let mut data = vec![0; len];\n+                rng.fill_bytes(&mut data);\n+                data\n+            }\n+            None => {\n+                return err!(Unimplemented(\n+                    \"miri does not support gathering system entropy in deterministic mode!\n+                    Use '-Zmiri-seed=<seed>' to enable random number generation.\n+                    WARNING: Miri does *not* generate cryptographically secure entropy -\n+                    do not use Miri to run any program that needs secure random number generation\".to_owned(),\n+                ));\n+            }\n+        };\n+        let tcx = &{this.tcx.tcx};\n+        this.memory_mut().get_mut(ptr.alloc_id)?\n+            .write_bytes(tcx, ptr, &data)\n+    }\n+\n     /// Visits the memory covered by `place`, sensitive to freezing: the 3rd parameter\n     /// will be true if this is frozen, false if this is in an `UnsafeCell`.\n     fn visit_freeze_sensitive("}, {"sha": "20c24ad54fe846a62b4fd89fd3963b3c53f3d576", "filename": "src/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/226156f673ecf52cf1bc337c92a1b79a98252d36/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/226156f673ecf52cf1bc337c92a1b79a98252d36/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=226156f673ecf52cf1bc337c92a1b79a98252d36", "patch": "@@ -31,13 +31,14 @@ pub use crate::shims::{EvalContextExt as ShimsEvalContextExt};\n pub use crate::shims::foreign_items::EvalContextExt as ForeignItemsEvalContextExt;\n pub use crate::shims::intrinsics::EvalContextExt as IntrinsicsEvalContextExt;\n pub use crate::shims::tls::{EvalContextExt as TlsEvalContextExt, TlsData};\n+pub use crate::shims::dlsym::{Dlsym, EvalContextExt as DlsymEvalContextExt};\n pub use crate::operator::EvalContextExt as OperatorEvalContextExt;\n pub use crate::range_map::RangeMap;\n pub use crate::helpers::{EvalContextExt as HelpersEvalContextExt};\n pub use crate::mono_hash_map::MonoHashMap;\n pub use crate::stacked_borrows::{EvalContextExt as StackedBorEvalContextExt, Tag, Permission, Stack, Stacks, Item};\n pub use crate::machine::{\n-    PAGE_SIZE, STACK_ADDR, NUM_CPUS,\n+    PAGE_SIZE, STACK_ADDR, STACK_SIZE, NUM_CPUS,\n     MemoryExtra, AllocExtra, MiriMemoryKind, Evaluator, MiriEvalContext, MiriEvalContextExt,\n };\n pub use crate::eval::{eval_main, create_ecx, MiriConfig};"}, {"sha": "d1cf913a75bfd9c1e07618579b36fa7ce12ec66e", "filename": "src/machine.rs", "status": "modified", "additions": 27, "deletions": 15, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/226156f673ecf52cf1bc337c92a1b79a98252d36/src%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/226156f673ecf52cf1bc337c92a1b79a98252d36/src%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmachine.rs?ref=226156f673ecf52cf1bc337c92a1b79a98252d36", "patch": "@@ -11,14 +11,15 @@ use rand::rngs::StdRng;\n use syntax::attr;\n use syntax::symbol::sym;\n use rustc::hir::def_id::DefId;\n-use rustc::ty::{self, layout::{Size, LayoutOf}, query::TyCtxtAt};\n+use rustc::ty::{self, layout::{Size, LayoutOf}, TyCtxt};\n use rustc::mir;\n \n use crate::*;\n \n // Some global facts about the emulated machine.\n pub const PAGE_SIZE: u64 = 4*1024; // FIXME: adjust to target architecture\n-pub const STACK_ADDR: u64 = 16*PAGE_SIZE; // not really about the \"stack\", but where we start assigning integer addresses to allocations\n+pub const STACK_ADDR: u64 = 32*PAGE_SIZE; // not really about the \"stack\", but where we start assigning integer addresses to allocations\n+pub const STACK_SIZE: u64 = 16*PAGE_SIZE; // whatever\n pub const NUM_CPUS: u64 = 1;\n \n /// Extra memory kinds\n@@ -135,6 +136,7 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'tcx> {\n     type MemoryExtra = MemoryExtra;\n     type AllocExtra = AllocExtra;\n     type PointerTag = Tag;\n+    type ExtraFnVal = Dlsym;\n \n     type MemoryMap = MonoHashMap<AllocId, (MemoryKind<MiriMemoryKind>, Allocation<Tag, Self::AllocExtra>)>;\n \n@@ -145,7 +147,6 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'tcx> {\n         ecx.memory().extra.validate\n     }\n \n-    /// Returns `Ok()` when the function was handled; fail otherwise.\n     #[inline(always)]\n     fn find_fn(\n         ecx: &mut InterpCx<'mir, 'tcx, Self>,\n@@ -157,6 +158,17 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'tcx> {\n         ecx.find_fn(instance, args, dest, ret)\n     }\n \n+    #[inline(always)]\n+    fn call_extra_fn(\n+        ecx: &mut InterpCx<'mir, 'tcx, Self>,\n+        fn_val: Dlsym,\n+        args: &[OpTy<'tcx, Tag>],\n+        dest: Option<PlaceTy<'tcx, Tag>>,\n+        ret: Option<mir::BasicBlock>,\n+    ) -> InterpResult<'tcx> {\n+        ecx.call_dlsym(fn_val, args, dest, ret)\n+    }\n+\n     #[inline(always)]\n     fn call_intrinsic(\n         ecx: &mut rustc_mir::interpret::InterpCx<'mir, 'tcx, Self>,\n@@ -220,8 +232,8 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'tcx> {\n     }\n \n     fn find_foreign_static(\n+        tcx: TyCtxt<'tcx>,\n         def_id: DefId,\n-        tcx: TyCtxtAt<'tcx>,\n     ) -> InterpResult<'tcx, Cow<'tcx, Allocation>> {\n         let attrs = tcx.get_attrs(def_id);\n         let link_name = match attr::first_attr_value_str_by_name(&attrs, sym::link_name) {\n@@ -251,20 +263,20 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'tcx> {\n     }\n \n     fn tag_allocation<'b>(\n+        memory_extra: &MemoryExtra,\n         id: AllocId,\n         alloc: Cow<'b, Allocation>,\n         kind: Option<MemoryKind<Self::MemoryKinds>>,\n-        memory: &Memory<'mir, 'tcx, Self>,\n     ) -> (Cow<'b, Allocation<Self::PointerTag, Self::AllocExtra>>, Self::PointerTag) {\n         let kind = kind.expect(\"we set our STATIC_KIND so this cannot be None\");\n         let alloc = alloc.into_owned();\n-        let (stacks, base_tag) = if !memory.extra.validate {\n+        let (stacks, base_tag) = if !memory_extra.validate {\n             (None, Tag::Untagged)\n         } else {\n             let (stacks, base_tag) = Stacks::new_allocation(\n                 id,\n                 Size::from_bytes(alloc.bytes.len() as u64),\n-                Rc::clone(&memory.extra.stacked_borrows),\n+                Rc::clone(&memory_extra.stacked_borrows),\n                 kind,\n             );\n             (Some(stacks), base_tag)\n@@ -273,18 +285,18 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'tcx> {\n             assert!(alloc.relocations.is_empty(), \"Only statics can come initialized with inner pointers\");\n             // Now we can rely on the inner pointers being static, too.\n         }\n-        let mut memory_extra = memory.extra.stacked_borrows.borrow_mut();\n+        let mut stacked_borrows = memory_extra.stacked_borrows.borrow_mut();\n         let alloc: Allocation<Tag, Self::AllocExtra> = Allocation {\n             bytes: alloc.bytes,\n             relocations: Relocations::from_presorted(\n                 alloc.relocations.iter()\n                     // The allocations in the relocations (pointers stored *inside* this allocation)\n                     // all get the base pointer tag.\n                     .map(|&(offset, ((), alloc))| {\n-                        let tag = if !memory.extra.validate {\n+                        let tag = if !memory_extra.validate {\n                             Tag::Untagged\n                         } else {\n-                            memory_extra.static_base_ptr(alloc)\n+                            stacked_borrows.static_base_ptr(alloc)\n                         };\n                         (offset, (tag, alloc))\n                     })\n@@ -302,13 +314,13 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'tcx> {\n \n     #[inline(always)]\n     fn tag_static_base_pointer(\n+        memory_extra: &MemoryExtra,\n         id: AllocId,\n-        memory: &Memory<'mir, 'tcx, Self>,\n     ) -> Self::PointerTag {\n-        if !memory.extra.validate {\n+        if !memory_extra.validate {\n             Tag::Untagged\n         } else {\n-            memory.extra.stacked_borrows.borrow_mut().static_base_ptr(id)\n+            memory_extra.stacked_borrows.borrow_mut().static_base_ptr(id)\n         }\n     }\n \n@@ -342,8 +354,8 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'tcx> {\n     }\n \n     fn int_to_ptr(\n-        int: u64,\n         memory: &Memory<'mir, 'tcx, Self>,\n+        int: u64,\n     ) -> InterpResult<'tcx, Pointer<Self::PointerTag>> {\n         if int == 0 {\n             err!(InvalidNullPointerUsage)\n@@ -355,8 +367,8 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'tcx> {\n     }\n \n     fn ptr_to_int(\n-        ptr: Pointer<Self::PointerTag>,\n         memory: &Memory<'mir, 'tcx, Self>,\n+        ptr: Pointer<Self::PointerTag>,\n     ) -> InterpResult<'tcx, u64> {\n         if memory.extra.rng.is_none() {\n             err!(ReadPointerAsBytes)"}, {"sha": "602d8064e82ef5aa419a300856cc599d8ffeb7db", "filename": "src/shims/dlsym.rs", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/226156f673ecf52cf1bc337c92a1b79a98252d36/src%2Fshims%2Fdlsym.rs", "raw_url": "https://github.com/rust-lang/rust/raw/226156f673ecf52cf1bc337c92a1b79a98252d36/src%2Fshims%2Fdlsym.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fdlsym.rs?ref=226156f673ecf52cf1bc337c92a1b79a98252d36", "patch": "@@ -0,0 +1,55 @@\n+use rustc::mir;\n+\n+use crate::*;\n+\n+#[derive(Debug, Copy, Clone)]\n+pub enum Dlsym {\n+    GetEntropy,\n+}\n+\n+impl Dlsym {\n+    // Returns an error for unsupported symbols, and None if this symbol\n+    // should become a NULL pointer (pretend it does not exist).\n+    pub fn from_str(name: &str) -> InterpResult<'static, Option<Dlsym>> {\n+        use self::Dlsym::*;\n+        Ok(match name {\n+            \"getentropy\" => Some(GetEntropy),\n+            \"__pthread_get_minstack\" => None,\n+            _ =>\n+                return err!(Unimplemented(format!(\n+                    \"Unsupported dlsym: {}\", name\n+                ))),\n+        })\n+    }\n+}\n+\n+impl<'mir, 'tcx> EvalContextExt<'mir, 'tcx> for crate::MiriEvalContext<'mir, 'tcx> {}\n+pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx> {\n+    fn call_dlsym(\n+        &mut self,\n+        dlsym: Dlsym,\n+        args: &[OpTy<'tcx, Tag>],\n+        dest: Option<PlaceTy<'tcx, Tag>>,\n+        ret: Option<mir::BasicBlock>,\n+    ) -> InterpResult<'tcx> {\n+        use self::Dlsym::*;\n+\n+        let this = self.eval_context_mut();\n+\n+        let dest = dest.expect(\"we don't support any diverging dlsym\");\n+        let ret = ret.expect(\"dest is `Some` but ret is `None`\");\n+\n+        match dlsym {\n+            GetEntropy => {\n+                let ptr = this.read_scalar(args[0])?.not_undef()?;\n+                let len = this.read_scalar(args[1])?.to_usize(this)?;\n+                this.gen_random(len as usize, ptr)?;\n+                this.write_null(dest)?;\n+            }\n+        }\n+\n+        this.goto_block(Some(ret))?;\n+        this.dump_place(*dest);\n+        Ok(())\n+    }\n+}"}, {"sha": "9dbb55668ef35dc707ab4fdbce71e8877250a7eb", "filename": "src/shims/foreign_items.rs", "status": "modified", "additions": 43, "deletions": 57, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/226156f673ecf52cf1bc337c92a1b79a98252d36/src%2Fshims%2Fforeign_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/226156f673ecf52cf1bc337c92a1b79a98252d36/src%2Fshims%2Fforeign_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fforeign_items.rs?ref=226156f673ecf52cf1bc337c92a1b79a98252d36", "patch": "@@ -4,8 +4,6 @@ use rustc::mir;\n use syntax::attr;\n use syntax::symbol::sym;\n \n-use rand::RngCore;\n-\n use crate::*;\n \n impl<'mir, 'tcx> EvalContextExt<'mir, 'tcx> for crate::MiriEvalContext<'mir, 'tcx> {}\n@@ -307,7 +305,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                         // neither of which have any effect on our current PRNG\n                         let _flags = this.read_scalar(args[3])?.to_i32()?;\n \n-                        gen_random(this, len as usize, ptr)?;\n+                        this.gen_random(len as usize, ptr)?;\n                         this.write_scalar(Scalar::from_uint(len, dest.layout.size), dest)?;\n                     }\n                     id => {\n@@ -324,10 +322,12 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 let symbol_name = this.memory().get(symbol.alloc_id)?.read_c_str(tcx, symbol)?;\n                 let err = format!(\"bad c unicode symbol: {:?}\", symbol_name);\n                 let symbol_name = ::std::str::from_utf8(symbol_name).unwrap_or(&err);\n-                return err!(Unimplemented(format!(\n-                    \"miri does not support dynamically loading libraries (requested symbol: {})\",\n-                    symbol_name\n-                )));\n+                if let Some(dlsym) = Dlsym::from_str(symbol_name)? {\n+                    let ptr = this.memory_mut().create_fn_alloc(FnVal::Other(dlsym));\n+                    this.write_scalar(Scalar::from(ptr), dest)?;\n+                } else {\n+                    this.write_null(dest)?;\n+                }\n             }\n \n             \"__rust_maybe_catch_panic\" => {\n@@ -338,9 +338,9 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 //     vtable_ptr: *mut usize,\n                 // ) -> u32\n                 // We abort on panic, so not much is going on here, but we still have to call the closure.\n-                let f = this.read_scalar(args[0])?.to_ptr()?;\n+                let f = this.read_scalar(args[0])?.not_undef()?;\n                 let data = this.read_scalar(args[1])?.not_undef()?;\n-                let f_instance = this.memory().get_fn(f)?;\n+                let f_instance = this.memory().get_fn(f)?.as_instance()?;\n                 this.write_null(dest)?;\n                 trace!(\"__rust_maybe_catch_panic: {:?}\", f_instance);\n \n@@ -659,7 +659,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n                 // Extract the function type out of the signature (that seems easier than constructing it ourselves).\n                 let dtor = match this.test_null(this.read_scalar(args[1])?.not_undef()?)? {\n-                    Some(dtor_ptr) => Some(this.memory().get_fn(dtor_ptr.to_ptr()?)?),\n+                    Some(dtor_ptr) => Some(this.memory().get_fn(dtor_ptr)?.as_instance()?),\n                     None => None,\n                 };\n \n@@ -709,24 +709,31 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 this.write_null(dest)?;\n             }\n \n-            // Determine stack base address.\n-            \"pthread_attr_init\" | \"pthread_attr_destroy\" | \"pthread_attr_get_np\" |\n-            \"pthread_getattr_np\" | \"pthread_self\" | \"pthread_get_stacksize_np\" => {\n+            // Stack size/address stuff.\n+            \"pthread_attr_init\" | \"pthread_attr_destroy\" | \"pthread_self\" |\n+            \"pthread_attr_setstacksize\" => {\n                 this.write_null(dest)?;\n             }\n             \"pthread_attr_getstack\" => {\n-                // Second argument is where we are supposed to write the stack size.\n-                let ptr = this.deref_operand(args[1])?;\n-                // Just any address.\n-                let stack_addr = Scalar::from_uint(STACK_ADDR, args[1].layout.size);\n-                this.write_scalar(stack_addr, ptr.into())?;\n+                let addr_place = this.deref_operand(args[1])?;\n+                let size_place = this.deref_operand(args[2])?;\n+\n+                this.write_scalar(\n+                    Scalar::from_uint(STACK_ADDR, addr_place.layout.size),\n+                    addr_place.into(),\n+                )?;\n+                this.write_scalar(\n+                    Scalar::from_uint(STACK_SIZE, size_place.layout.size),\n+                    size_place.into(),\n+                )?;\n+\n                 // Return success (`0`).\n                 this.write_null(dest)?;\n             }\n-            \"pthread_get_stackaddr_np\" => {\n-                // Just any address.\n-                let stack_addr = Scalar::from_uint(STACK_ADDR, dest.layout.size);\n-                this.write_scalar(stack_addr, dest)?;\n+\n+            // We don't support threading.\n+            \"pthread_create\" => {\n+                return err!(Unimplemented(format!(\"Miri does not support threading\")));\n             }\n \n             // Stub out calls for condvar, mutex and rwlock, to just return `0`.\n@@ -754,6 +761,17 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             }\n \n             // macOS API stubs.\n+            \"pthread_attr_get_np\" | \"pthread_getattr_np\" => {\n+                this.write_null(dest)?;\n+            }\n+            \"pthread_get_stackaddr_np\" => {\n+                let stack_addr = Scalar::from_uint(STACK_ADDR, dest.layout.size);\n+                this.write_scalar(stack_addr, dest)?;\n+            }\n+            \"pthread_get_stacksize_np\" => {\n+                let stack_size = Scalar::from_uint(STACK_SIZE, dest.layout.size);\n+                this.write_scalar(stack_size, dest)?;\n+            }\n             \"_tlv_atexit\" => {\n                 // FIXME: register the destructor.\n             },\n@@ -766,7 +784,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             \"SecRandomCopyBytes\" => {\n                 let len = this.read_scalar(args[1])?.to_usize(this)?;\n                 let ptr = this.read_scalar(args[2])?.not_undef()?;\n-                gen_random(this, len as usize, ptr)?;\n+                this.gen_random(len as usize, ptr)?;\n                 this.write_null(dest)?;\n             }\n \n@@ -934,7 +952,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             \"SystemFunction036\" => {\n                 let ptr = this.read_scalar(args[0])?.not_undef()?;\n                 let len = this.read_scalar(args[1])?.to_u32()?;\n-                gen_random(this, len as usize, ptr)?;\n+                this.gen_random(len as usize, ptr)?;\n                 this.write_scalar(Scalar::from_bool(true), dest)?;\n             }\n \n@@ -966,36 +984,4 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         }\n         return Ok(None);\n     }\n-}\n-\n-fn gen_random<'mir, 'tcx>(\n-    this: &mut MiriEvalContext<'mir, 'tcx>,\n-    len: usize,\n-    dest: Scalar<Tag>,\n-) -> InterpResult<'tcx>  {\n-    if len == 0 {\n-        // Nothing to do\n-        return Ok(());\n-    }\n-    let ptr = dest.to_ptr()?;\n-\n-    let data = match &mut this.memory_mut().extra.rng {\n-        Some(rng) => {\n-            let mut rng = rng.borrow_mut();\n-            let mut data = vec![0; len];\n-            rng.fill_bytes(&mut data);\n-            data\n-        }\n-        None => {\n-            return err!(Unimplemented(\n-                \"miri does not support gathering system entropy in deterministic mode!\n-                Use '-Zmiri-seed=<seed>' to enable random number generation.\n-                WARNING: Miri does *not* generate cryptographically secure entropy -\n-                do not use Miri to run any program that needs secure random number generation\".to_owned(),\n-            ));\n-        }\n-    };\n-    let tcx = &{this.tcx.tcx};\n-    this.memory_mut().get_mut(ptr.alloc_id)?\n-        .write_bytes(tcx, ptr, &data)\n-}\n+}\n\\ No newline at end of file"}, {"sha": "c06373005ff9919155009afa5b2f1964f37da7e4", "filename": "src/shims/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/226156f673ecf52cf1bc337c92a1b79a98252d36/src%2Fshims%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/226156f673ecf52cf1bc337c92a1b79a98252d36/src%2Fshims%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fmod.rs?ref=226156f673ecf52cf1bc337c92a1b79a98252d36", "patch": "@@ -1,6 +1,7 @@\n pub mod foreign_items;\n pub mod intrinsics;\n pub mod tls;\n+pub mod dlsym;\n \n use rustc::{ty, mir};\n "}, {"sha": "55e5a3dfc185db436482aa8baffb9dea1b609a55", "filename": "test-cargo-miri/Cargo.lock", "status": "modified", "additions": 11, "deletions": 47, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/226156f673ecf52cf1bc337c92a1b79a98252d36/test-cargo-miri%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/226156f673ecf52cf1bc337c92a1b79a98252d36/test-cargo-miri%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/test-cargo-miri%2FCargo.lock?ref=226156f673ecf52cf1bc337c92a1b79a98252d36", "patch": "@@ -5,11 +5,6 @@ name = \"autocfg\"\n version = \"0.1.4\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n-[[package]]\n-name = \"bitflags\"\n-version = \"1.1.0\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-\n [[package]]\n name = \"byteorder\"\n version = \"1.3.2\"\n@@ -33,34 +28,22 @@ dependencies = [\n  \"rand 0.7.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n-[[package]]\n-name = \"cloudabi\"\n-version = \"0.0.3\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-dependencies = [\n- \"bitflags 1.1.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n-]\n-\n-[[package]]\n-name = \"fuchsia-cprng\"\n-version = \"0.1.1\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-\n [[package]]\n name = \"getrandom\"\n-version = \"0.1.3\"\n+version = \"0.1.6\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"cloudabi 0.0.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"fuchsia-cprng 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"lazy_static 1.3.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"libc 0.2.58 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"winapi 0.3.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"lazy_static\"\n version = \"1.3.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"spin 0.5.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n \n [[package]]\n name = \"libc\"\n@@ -85,7 +68,7 @@ name = \"rand\"\n version = \"0.7.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"getrandom 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"getrandom 0.1.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"libc 0.2.58 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rand_chacha 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rand_core 0.5.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -108,7 +91,7 @@ name = \"rand_core\"\n version = \"0.5.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"getrandom 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"getrandom 0.1.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -129,32 +112,15 @@ dependencies = [\n ]\n \n [[package]]\n-name = \"winapi\"\n-version = \"0.3.7\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-dependencies = [\n- \"winapi-i686-pc-windows-gnu 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"winapi-x86_64-pc-windows-gnu 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n-]\n-\n-[[package]]\n-name = \"winapi-i686-pc-windows-gnu\"\n-version = \"0.4.0\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-\n-[[package]]\n-name = \"winapi-x86_64-pc-windows-gnu\"\n-version = \"0.4.0\"\n+name = \"spin\"\n+version = \"0.5.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [metadata]\n \"checksum autocfg 0.1.4 (registry+https://github.com/rust-lang/crates.io-index)\" = \"0e49efa51329a5fd37e7c79db4621af617cd4e3e5bc224939808d076077077bf\"\n-\"checksum bitflags 1.1.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"3d155346769a6855b86399e9bc3814ab343cd3d62c7e985113d46a0ec3c281fd\"\n \"checksum byteorder 1.3.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"a7c3dd8985a7111efc5c80b44e23ecdd8c007de8ade3b96595387e812b957cf5\"\n \"checksum c2-chacha 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"7d64d04786e0f528460fc884753cf8dddcc466be308f6026f8e355c41a0e4101\"\n-\"checksum cloudabi 0.0.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ddfc5b9aa5d4507acaf872de71051dfd0e309860e88966e1051e462a077aac4f\"\n-\"checksum fuchsia-cprng 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"a06f77d526c1a601b7c4cdd98f54b5eaabffc14d5f2f0296febdc7f357c6d3ba\"\n-\"checksum getrandom 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"8d1dffef07351aafe6ef177e4dd2b8dcf503e6bc765dea3b0de9ed149a3db1ec\"\n+\"checksum getrandom 0.1.6 (registry+https://github.com/rust-lang/crates.io-index)\" = \"e65cce4e5084b14874c4e7097f38cab54f47ee554f9194673456ea379dcc4c55\"\n \"checksum lazy_static 1.3.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"bc5729f27f159ddd61f4df6228e827e86643d4d3e7c32183cb30a1c08f604a14\"\n \"checksum libc 0.2.58 (registry+https://github.com/rust-lang/crates.io-index)\" = \"6281b86796ba5e4366000be6e9e18bf35580adf9e63fbe2294aadb587613a319\"\n \"checksum num_cpus 1.10.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"bcef43580c035376c0705c42792c294b66974abbfd2789b511784023f71f3273\"\n@@ -164,6 +130,4 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum rand_core 0.5.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"615e683324e75af5d43d8f7a39ffe3ee4a9dc42c5c701167a71dc59c3a493aca\"\n \"checksum rand_hc 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ca3129af7b92a17112d59ad498c6f81eaf463253766b90396d39ea7a39d6613c\"\n \"checksum rand_pcg 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"3e196346cbbc5c70c77e7b4926147ee8e383a38ee4d15d58a08098b169e492b6\"\n-\"checksum winapi 0.3.7 (registry+https://github.com/rust-lang/crates.io-index)\" = \"f10e386af2b13e47c89e7236a7a14a086791a2b88ebad6df9bf42040195cf770\"\n-\"checksum winapi-i686-pc-windows-gnu 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ac3b87c63620426dd9b991e5ce0329eff545bccbbb34f3be09ff6fb6ab51b7b6\"\n-\"checksum winapi-x86_64-pc-windows-gnu 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"712e227841d057c1ee1cd2fb22fa7e5a5461ae8e48fa2ca79ec42cfc1931183f\"\n+\"checksum spin 0.5.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"44363f6f51401c34e7be73db0db371c04705d35efbe9f7d6082e03a921a32c55\""}, {"sha": "450dea99f552f78b0f4c472fad1c8ccf7962f2b0", "filename": "tests/compile-fail/thread-spawn.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/226156f673ecf52cf1bc337c92a1b79a98252d36/tests%2Fcompile-fail%2Fthread-spawn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/226156f673ecf52cf1bc337c92a1b79a98252d36/tests%2Fcompile-fail%2Fthread-spawn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fthread-spawn.rs?ref=226156f673ecf52cf1bc337c92a1b79a98252d36", "patch": "@@ -0,0 +1,7 @@\n+use std::thread;\n+\n+// error-pattern: Miri does not support threading\n+\n+fn main() {\n+    thread::spawn(|| {});\n+}"}]}