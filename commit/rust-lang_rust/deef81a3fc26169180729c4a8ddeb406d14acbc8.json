{"sha": "deef81a3fc26169180729c4a8ddeb406d14acbc8", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRlZWY4MWEzZmMyNjE2OTE4MDcyOWM0YThkZGViNDA2ZDE0YWNiYzg=", "commit": {"author": {"name": "scott-linder", "email": "scott.b.linder@wmich.edu", "date": "2017-06-11T03:51:37Z"}, "committer": {"name": "scott-linder", "email": "scott.b.linder@wmich.edu", "date": "2017-06-11T16:19:11Z"}, "message": "Use span_suggestion in borrowed_box lint", "tree": {"sha": "318ce5248d657d659e6741a3ad248c107ae69c11", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/318ce5248d657d659e6741a3ad248c107ae69c11"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/deef81a3fc26169180729c4a8ddeb406d14acbc8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/deef81a3fc26169180729c4a8ddeb406d14acbc8", "html_url": "https://github.com/rust-lang/rust/commit/deef81a3fc26169180729c4a8ddeb406d14acbc8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/deef81a3fc26169180729c4a8ddeb406d14acbc8/comments", "author": null, "committer": null, "parents": [{"sha": "663688f70db1e1c4df764de1c0d07037f1a96e9c", "url": "https://api.github.com/repos/rust-lang/rust/commits/663688f70db1e1c4df764de1c0d07037f1a96e9c", "html_url": "https://github.com/rust-lang/rust/commit/663688f70db1e1c4df764de1c0d07037f1a96e9c"}], "stats": {"total": 38, "additions": 30, "deletions": 8}, "files": [{"sha": "85f4ea8b7b9aed8c373555754ff8ff76a72a4a42", "filename": "clippy_lints/src/types.rs", "status": "modified", "additions": 30, "deletions": 8, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/deef81a3fc26169180729c4a8ddeb406d14acbc8/clippy_lints%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/deef81a3fc26169180729c4a8ddeb406d14acbc8/clippy_lints%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftypes.rs?ref=deef81a3fc26169180729c4a8ddeb406d14acbc8", "patch": "@@ -8,7 +8,7 @@ use std::cmp::Ordering;\n use syntax::ast::{IntTy, UintTy, FloatTy};\n use syntax::attr::IntType;\n use syntax::codemap::Span;\n-use utils::{comparisons, higher, in_external_macro, in_macro, match_def_path, snippet, span_help_and_lint, span_lint,\n+use utils::{comparisons, higher, in_external_macro, in_macro, match_def_path, snippet, span_help_and_lint, span_lint, span_lint_and_then,\n             opt_def_id, last_path_segment, type_size};\n use utils::paths;\n \n@@ -177,18 +177,40 @@ fn check_ty(cx: &LateContext, ast_ty: &hir::Ty) {\n                 },\n             }\n         },\n-        TyRptr(_, MutTy { ref ty, .. }) => {\n+        TyRptr(ref lt, MutTy { ref ty, ref mutbl }) => {\n             match ty.node {\n                 TyPath(ref qpath) => {\n                     let def = cx.tables.qpath_def(qpath, ast_ty.id);\n                     if let Some(def_id) = opt_def_id(def) {\n                         if Some(def_id) == cx.tcx.lang_items.owned_box() {\n-                            span_help_and_lint(cx,\n-                                               BORROWED_BOX,\n-                                               ast_ty.span,\n-                                               \"you seem to be trying to use `&Box<T>`. Consider using just `&T`\",\n-                                               \"replace `&Box<T>` with simply `&T`\");\n-                            return; // don't recurse into the type\n+                            if_let_chain! {[\n+                                let &QPath::Resolved(None, ref path) = qpath,\n+                                let [ref bx] = *path.segments,\n+                                let PathParameters::AngleBracketedParameters(ref ab_data) = bx.parameters,\n+                                let [ref inner] = *ab_data.types\n+                            ], {\n+                                let ltopt = if lt.is_elided() {\n+                                    \"\".to_owned()\n+                                } else {\n+                                    format!(\"{} \", lt.name.as_str())\n+                                };\n+                                let mutopt = if *mutbl == Mutability::MutMutable {\n+                                    \"mut \"\n+                                } else {\n+                                    \"\"\n+                                };\n+                                span_lint_and_then(cx,\n+                                    BORROWED_BOX,\n+                                    ast_ty.span,\n+                                    \"you seem to be trying to use `&Box<T>`. Consider using just `&T`\",\n+                                    |db| {\n+                                        db.span_suggestion(ast_ty.span,\n+                                            \"try\",\n+                                            format!(\"&{}{}{}\", ltopt, mutopt, &snippet(cx, inner.span, \"..\")));\n+                                    }\n+                                );\n+                                return; // don't recurse into the type\n+                            }};\n                         }\n                     }\n                     check_ty(cx, ty);"}]}