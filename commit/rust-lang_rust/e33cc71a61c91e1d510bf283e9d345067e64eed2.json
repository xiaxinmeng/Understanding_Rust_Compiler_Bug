{"sha": "e33cc71a61c91e1d510bf283e9d345067e64eed2", "node_id": "C_kwDOAAsO6NoAKGUzM2NjNzFhNjFjOTFlMWQ1MTBiZjI4M2U5ZDM0NTA2N2U2NGVlZDI", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-07-27T04:18:49Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-07-27T04:18:49Z"}, "message": "Auto merge of #99792 - JohnTitor:rollup-20i7ewx, r=JohnTitor\n\nRollup of 8 pull requests\n\nSuccessful merges:\n\n - #98583 (Stabilize Windows `FileTypeExt` with `is_symlink_dir` and `is_symlink_file`)\n - #99698 (Prefer visibility map parents that are not `doc(hidden)` first)\n - #99700 (Add a clickable link to the layout section)\n - #99712 (passes: port more of `check_attr` module)\n - #99759 (Remove dead code from cg_llvm)\n - #99765 (Don't build std for *-uefi targets)\n - #99771 (Update pulldown-cmark version to 0.9.2 (fixes url encoding for some chars))\n - #99775 (rustdoc: do not allocate String when writing path full name)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "17c9c1bf9b1c7f77be51a944a515a275f4b3ac6f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/17c9c1bf9b1c7f77be51a944a515a275f4b3ac6f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e33cc71a61c91e1d510bf283e9d345067e64eed2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e33cc71a61c91e1d510bf283e9d345067e64eed2", "html_url": "https://github.com/rust-lang/rust/commit/e33cc71a61c91e1d510bf283e9d345067e64eed2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e33cc71a61c91e1d510bf283e9d345067e64eed2/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b573e10d21b69ebfadf41aa9c2f0a27919fe4480", "url": "https://api.github.com/repos/rust-lang/rust/commits/b573e10d21b69ebfadf41aa9c2f0a27919fe4480", "html_url": "https://github.com/rust-lang/rust/commit/b573e10d21b69ebfadf41aa9c2f0a27919fe4480"}, {"sha": "0d5bdcac5ff0c5cbc6ed0a04663788a23cc62adf", "url": "https://api.github.com/repos/rust-lang/rust/commits/0d5bdcac5ff0c5cbc6ed0a04663788a23cc62adf", "html_url": "https://github.com/rust-lang/rust/commit/0d5bdcac5ff0c5cbc6ed0a04663788a23cc62adf"}], "stats": {"total": 1021, "additions": 622, "deletions": 399}, "files": [{"sha": "2325d0f3bf263a8e8f43b2f2d5570767fc023021", "filename": "Cargo.lock", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e33cc71a61c91e1d510bf283e9d345067e64eed2/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/e33cc71a61c91e1d510bf283e9d345067e64eed2/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=e33cc71a61c91e1d510bf283e9d345067e64eed2", "patch": "@@ -202,9 +202,9 @@ dependencies = [\n \n [[package]]\n name = \"bitflags\"\n-version = \"1.2.1\"\n+version = \"1.3.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"cf1de2fe8c75bc145a2f577add951f8134889b4795d47466a54a5c846d691693\"\n+checksum = \"bef38d45163c2f1dde094a7dfd33ccf595c92905c8f8f4fdc18d06fb1037718a\"\n \n [[package]]\n name = \"bitmaps\"\n@@ -2394,9 +2394,9 @@ dependencies = [\n \n [[package]]\n name = \"memchr\"\n-version = \"2.4.1\"\n+version = \"2.5.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"308cc39be01b73d0d18f82a0e7b2a3df85245f84af96fdddc5d202d27e47b86a\"\n+checksum = \"2dffe52ecf27772e601905b7522cb4ef790d2cc203488bbd0e2fe85fcb74566d\"\n dependencies = [\n  \"compiler_builtins\",\n  \"rustc-std-workspace-core\",\n@@ -3044,9 +3044,9 @@ dependencies = [\n \n [[package]]\n name = \"pulldown-cmark\"\n-version = \"0.9.1\"\n+version = \"0.9.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"34f197a544b0c9ab3ae46c359a7ec9cbbb5c7bf97054266fecb7ead794a181d6\"\n+checksum = \"2d9cc634bc78768157b5cbfe988ffcd1dcba95cd2b2f03a88316c08c6d00ed63\"\n dependencies = [\n  \"bitflags\",\n  \"memchr\","}, {"sha": "45de284d22a6735bafb39d1d8eead2604de9cf95", "filename": "compiler/rustc_codegen_llvm/src/llvm/diagnostic.rs", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/e33cc71a61c91e1d510bf283e9d345067e64eed2/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e33cc71a61c91e1d510bf283e9d345067e64eed2/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fdiagnostic.rs?ref=e33cc71a61c91e1d510bf283e9d345067e64eed2", "patch": "@@ -20,19 +20,6 @@ pub enum OptimizationDiagnosticKind {\n     OptimizationRemarkOther,\n }\n \n-impl OptimizationDiagnosticKind {\n-    pub fn describe(self) -> &'static str {\n-        match self {\n-            OptimizationRemark | OptimizationRemarkOther => \"remark\",\n-            OptimizationMissed => \"missed\",\n-            OptimizationAnalysis => \"analysis\",\n-            OptimizationAnalysisFPCommute => \"floating-point\",\n-            OptimizationAnalysisAliasing => \"aliasing\",\n-            OptimizationFailure => \"failure\",\n-        }\n-    }\n-}\n-\n pub struct OptimizationDiagnostic<'ll> {\n     pub kind: OptimizationDiagnosticKind,\n     pub pass_name: String,"}, {"sha": "9ee6d39fdc9bf95095f14d1a86cb0086db1b52a7", "filename": "compiler/rustc_codegen_llvm/src/llvm/ffi.rs", "status": "modified", "additions": 0, "deletions": 27, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/e33cc71a61c91e1d510bf283e9d345067e64eed2/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e33cc71a61c91e1d510bf283e9d345067e64eed2/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs?ref=e33cc71a61c91e1d510bf283e9d345067e64eed2", "patch": "@@ -572,16 +572,6 @@ pub enum ArchiveKind {\n     K_COFF,\n }\n \n-/// LLVMRustPassKind\n-#[derive(Copy, Clone, PartialEq, Debug)]\n-#[repr(C)]\n-#[allow(dead_code)] // Variants constructed by C++.\n-pub enum PassKind {\n-    Other,\n-    Function,\n-    Module,\n-}\n-\n // LLVMRustThinLTOData\n extern \"C\" {\n     pub type ThinLTOData;\n@@ -592,10 +582,6 @@ extern \"C\" {\n     pub type ThinLTOBuffer;\n }\n \n-// LLVMRustModuleNameCallback\n-pub type ThinLTOModuleNameCallback =\n-    unsafe extern \"C\" fn(*mut c_void, *const c_char, *const c_char);\n-\n /// LLVMRustThinLTOModule\n #[repr(C)]\n pub struct ThinLTOModule {\n@@ -661,9 +647,6 @@ extern \"C\" {\n }\n #[repr(C)]\n pub struct Builder<'a>(InvariantOpaque<'a>);\n-extern \"C\" {\n-    pub type MemoryBuffer;\n-}\n #[repr(C)]\n pub struct PassManager<'a>(InvariantOpaque<'a>);\n extern \"C\" {\n@@ -1032,7 +1015,6 @@ extern \"C\" {\n     pub fn LLVMSetDataLayout(M: &Module, Triple: *const c_char);\n \n     /// See Module::setModuleInlineAsm.\n-    pub fn LLVMSetModuleInlineAsm2(M: &Module, Asm: *const c_char, AsmLen: size_t);\n     pub fn LLVMRustAppendModuleInlineAsm(M: &Module, Asm: *const c_char, AsmLen: size_t);\n \n     /// See llvm::LLVMTypeKind::getTypeID.\n@@ -1186,7 +1168,6 @@ extern \"C\" {\n     pub fn LLVMGetInitializer(GlobalVar: &Value) -> Option<&Value>;\n     pub fn LLVMSetInitializer<'a>(GlobalVar: &'a Value, ConstantVal: &'a Value);\n     pub fn LLVMIsThreadLocal(GlobalVar: &Value) -> Bool;\n-    pub fn LLVMSetThreadLocal(GlobalVar: &Value, IsThreadLocal: Bool);\n     pub fn LLVMSetThreadLocalMode(GlobalVar: &Value, Mode: ThreadLocalMode);\n     pub fn LLVMIsGlobalConstant(GlobalVar: &Value) -> Bool;\n     pub fn LLVMSetGlobalConstant(GlobalVar: &Value, IsConstant: Bool);\n@@ -2267,7 +2248,6 @@ extern \"C\" {\n \n     pub fn LLVMIsAConstantInt(value_ref: &Value) -> Option<&ConstantInt>;\n \n-    pub fn LLVMRustPassKind(Pass: &Pass) -> PassKind;\n     pub fn LLVMRustFindAndCreatePass(Pass: *const c_char) -> Option<&'static mut Pass>;\n     pub fn LLVMRustCreateAddressSanitizerFunctionPass(Recover: bool) -> &'static mut Pass;\n     pub fn LLVMRustCreateModuleAddressSanitizerPass(Recover: bool) -> &'static mut Pass;\n@@ -2384,7 +2364,6 @@ extern \"C\" {\n     ) -> LLVMRustResult;\n     pub fn LLVMRustSetLLVMOptions(Argc: c_int, Argv: *const *const c_char);\n     pub fn LLVMRustPrintPasses();\n-    pub fn LLVMRustGetInstructionCount(M: &Module) -> u32;\n     pub fn LLVMRustSetNormalizedTarget(M: &Module, triple: *const c_char);\n     pub fn LLVMRustAddAlwaysInlinePass(P: &PassManagerBuilder, AddLifetimes: bool);\n     pub fn LLVMRustRunRestrictionPass(M: &Module, syms: *const *const c_char, len: size_t);\n@@ -2482,7 +2461,6 @@ extern \"C\" {\n     pub fn LLVMRustPositionBuilderAtStart<'a>(B: &Builder<'a>, BB: &'a BasicBlock);\n \n     pub fn LLVMRustSetComdat<'a>(M: &'a Module, V: &'a Value, Name: *const c_char, NameLen: size_t);\n-    pub fn LLVMRustUnsetComdat(V: &Value);\n     pub fn LLVMRustSetModulePICLevel(M: &Module);\n     pub fn LLVMRustSetModulePIELevel(M: &Module);\n     pub fn LLVMRustSetModuleCodeModel(M: &Module, Model: CodeModel);\n@@ -2514,11 +2492,6 @@ extern \"C\" {\n         Module: &Module,\n         Target: &TargetMachine,\n     ) -> bool;\n-    pub fn LLVMRustGetThinLTOModuleImports(\n-        Data: *const ThinLTOData,\n-        ModuleNameCallback: ThinLTOModuleNameCallback,\n-        CallbackPayload: *mut c_void,\n-    );\n     pub fn LLVMRustFreeThinLTOData(Data: &'static mut ThinLTOData);\n     pub fn LLVMRustParseBitcodeForLTO(\n         Context: &Context,"}, {"sha": "6602a4ab8636cc0be034fbbaacabbef009b94667", "filename": "compiler/rustc_codegen_llvm/src/llvm/mod.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e33cc71a61c91e1d510bf283e9d345067e64eed2/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e33cc71a61c91e1d510bf283e9d345067e64eed2/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fmod.rs?ref=e33cc71a61c91e1d510bf283e9d345067e64eed2", "patch": "@@ -166,12 +166,6 @@ pub fn SetUniqueComdat(llmod: &Module, val: &Value) {\n     }\n }\n \n-pub fn UnsetComdat(val: &Value) {\n-    unsafe {\n-        LLVMRustUnsetComdat(val);\n-    }\n-}\n-\n pub fn SetUnnamedAddress(global: &Value, unnamed: UnnamedAddr) {\n     unsafe {\n         LLVMSetUnnamedAddress(global, unnamed);"}, {"sha": "f95e33cd16a7ddfcb48434e0fd1c6f01a81ba22e", "filename": "compiler/rustc_error_messages/locales/en-US/passes.ftl", "status": "modified", "additions": 107, "deletions": 0, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/e33cc71a61c91e1d510bf283e9d345067e64eed2/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fpasses.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/e33cc71a61c91e1d510bf283e9d345067e64eed2/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fpasses.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fpasses.ftl?ref=e33cc71a61c91e1d510bf283e9d345067e64eed2", "patch": "@@ -149,3 +149,110 @@ passes-cold = {passes-should-be-applied-to-fn}\n passes-link = attribute should be applied to an `extern` block with non-Rust ABI\n     .warn = {-passes-previously-accepted}\n     .label = not an `extern` block\n+\n+passes-link-name = attribute should be applied to a foreign function or static\n+    .warn = {-passes-previously-accepted}\n+    .label = not a foreign function or static\n+    .help = try `#[link(name = \"{$value}\")]` instead\n+\n+passes-no-link = attribute should be applied to an `extern crate` item\n+    .label = not an `extern crate` item\n+\n+passes-export-name = attribute should be applied to a free function, impl method or static\n+    .label = not a free function, impl method or static\n+\n+passes-rustc-layout-scalar-valid-range-not-struct = attribute should be applied to a struct\n+    .label = not a struct\n+\n+passes-rustc-layout-scalar-valid-range-arg = expected exactly one integer literal argument\n+\n+passes-rustc-legacy-const-generics-only = #[rustc_legacy_const_generics] functions must only have const generics\n+    .label = non-const generic parameter\n+\n+passes-rustc-legacy-const-generics-index = #[rustc_legacy_const_generics] must have one index for each generic parameter\n+    .label = generic parameters\n+\n+passes-rustc-legacy-const-generics-index-exceed = index exceeds number of arguments\n+    .label = there {$arg_count ->\n+        [one] is\n+        *[other] are\n+    } only {$arg_count} {$arg_count ->\n+        [one] argument\n+        *[other] arguments\n+    }\n+\n+passes-rustc-legacy-const-generics-index-negative = arguments should be non-negative integers\n+\n+passes-rustc-dirty-clean = attribute requires -Z query-dep-graph to be enabled\n+\n+passes-link-section = attribute should be applied to a function or static\n+    .warn = {-passes-previously-accepted}\n+    .label = not a function or static\n+\n+passes-no-mangle-foreign = `#[no_mangle]` has no effect on a foreign {$foreign_item_kind}\n+    .warn = {-passes-previously-accepted}\n+    .label = foreign {$foreign_item_kind}\n+    .note = symbol names in extern blocks are not mangled\n+    .suggestion = remove this attribute\n+\n+passes-no-mangle = attribute should be applied to a free function, impl method or static\n+    .warn = {-passes-previously-accepted}\n+    .label = not a free function, impl method or static\n+\n+passes-repr-ident = meta item in `repr` must be an identifier\n+\n+passes-repr-conflicting = conflicting representation hints\n+\n+passes-used-static = attribute must be applied to a `static` variable\n+\n+passes-used-compiler-linker = `used(compiler)` and `used(linker)` can't be used together\n+\n+passes-allow-internal-unstable = attribute should be applied to a macro\n+    .label = not a macro\n+\n+passes-debug-visualizer-placement = attribute should be applied to a module\n+\n+passes-debug-visualizer-invalid = invalid argument\n+    .note-1 = expected: `natvis_file = \"...\"`\n+    .note-2 = OR\n+    .note-3 = expected: `gdb_script_file = \"...\"`\n+\n+passes-rustc-allow-const-fn-unstable = attribute should be applied to `const fn`\n+    .label = not a `const fn`\n+\n+passes-rustc-std-internal-symbol = attribute should be applied to functions or statics\n+    .label = not a function or static\n+\n+passes-const-trait = attribute should be applied to a trait\n+\n+passes-stability-promotable = attribute cannot be applied to an expression\n+\n+passes-deprecated = attribute is ignored here\n+\n+passes-macro-use = `#[{$name}]` only has an effect on `extern crate` and modules\n+\n+passes-macro-export = `#[macro_export]` only has an effect on macro definitions\n+\n+passes-plugin-registrar = `#[plugin_registrar]` only has an effect on functions\n+\n+passes-unused-empty-lints-note = attribute `{$name}` with an empty list has no effect\n+\n+passes-unused-no-lints-note = attribute `{$name}` without any lints has no effect\n+\n+passes-unused-default-method-body-const-note =\n+    `default_method_body_is_const` has been replaced with `#[const_trait]` on traits\n+\n+passes-unused = unused attribute\n+    .suggestion = remove this attribute\n+\n+passes-non-exported-macro-invalid-attrs = attribute should be applied to function or closure\n+    .label = not a function or closure\n+\n+passes-unused-duplicate = unused attribute\n+    .suggestion = remove this attribute\n+    .note = attribute also specified here\n+    .warn = {-passes-previously-accepted}\n+\n+passes-unused-multiple = multiple `{$name}` attributes\n+    .suggestion = remove this attribute\n+    .note = attribute also specified here"}, {"sha": "0a6bd49992d9932f37326f75cfba45d046ed6e1e", "filename": "compiler/rustc_llvm/llvm-wrapper/PassWrapper.cpp", "status": "modified", "additions": 0, "deletions": 45, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/e33cc71a61c91e1d510bf283e9d345067e64eed2/compiler%2Frustc_llvm%2Fllvm-wrapper%2FPassWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/e33cc71a61c91e1d510bf283e9d345067e64eed2/compiler%2Frustc_llvm%2Fllvm-wrapper%2FPassWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_llvm%2Fllvm-wrapper%2FPassWrapper.cpp?ref=e33cc71a61c91e1d510bf283e9d345067e64eed2", "patch": "@@ -90,23 +90,6 @@ extern \"C\" void LLVMTimeTraceProfilerFinish(const char* FileName) {\n   timeTraceProfilerCleanup();\n }\n \n-enum class LLVMRustPassKind {\n-  Other,\n-  Function,\n-  Module,\n-};\n-\n-static LLVMRustPassKind toRust(PassKind Kind) {\n-  switch (Kind) {\n-  case PT_Function:\n-    return LLVMRustPassKind::Function;\n-  case PT_Module:\n-    return LLVMRustPassKind::Module;\n-  default:\n-    return LLVMRustPassKind::Other;\n-  }\n-}\n-\n extern \"C\" LLVMPassRef LLVMRustFindAndCreatePass(const char *PassName) {\n #if LLVM_VERSION_LT(15, 0)\n   StringRef SR(PassName);\n@@ -172,12 +155,6 @@ extern \"C\" LLVMPassRef LLVMRustCreateHWAddressSanitizerPass(bool Recover) {\n #endif\n }\n \n-extern \"C\" LLVMRustPassKind LLVMRustPassKind(LLVMPassRef RustPass) {\n-  assert(RustPass);\n-  Pass *Pass = unwrap(RustPass);\n-  return toRust(Pass->getPassKind());\n-}\n-\n extern \"C\" void LLVMRustAddPass(LLVMPassManagerRef PMR, LLVMPassRef RustPass) {\n #if LLVM_VERSION_LT(15, 0)\n   assert(RustPass);\n@@ -1604,28 +1581,6 @@ LLVMRustPrepareThinLTOImport(const LLVMRustThinLTOData *Data, LLVMModuleRef M,\n   return true;\n }\n \n-extern \"C\" typedef void (*LLVMRustModuleNameCallback)(void*, // payload\n-                                                      const char*, // importing module name\n-                                                      const char*); // imported module name\n-\n-// Calls `module_name_callback` for each module import done by ThinLTO.\n-// The callback is provided with regular null-terminated C strings.\n-extern \"C\" void\n-LLVMRustGetThinLTOModules(const LLVMRustThinLTOData *data,\n-                                LLVMRustModuleNameCallback module_name_callback,\n-                                void* callback_payload) {\n-  for (const auto& importing_module : data->ImportLists) {\n-    const std::string importing_module_id = importing_module.getKey().str();\n-    const auto& imports = importing_module.getValue();\n-    for (const auto& imported_module : imports) {\n-      const std::string imported_module_id = imported_module.getKey().str();\n-      module_name_callback(callback_payload,\n-                           importing_module_id.c_str(),\n-                           imported_module_id.c_str());\n-    }\n-  }\n-}\n-\n // This struct and various functions are sort of a hack right now, but the\n // problem is that we've got in-memory LLVM modules after we generate and\n // optimize all codegen-units for one compilation in rustc. To be compatible"}, {"sha": "ef1a65488e2e4fff51f64b3e3bde106dac51c4ee", "filename": "compiler/rustc_llvm/llvm-wrapper/RustWrapper.cpp", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e33cc71a61c91e1d510bf283e9d345067e64eed2/compiler%2Frustc_llvm%2Fllvm-wrapper%2FRustWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/e33cc71a61c91e1d510bf283e9d345067e64eed2/compiler%2Frustc_llvm%2Fllvm-wrapper%2FRustWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_llvm%2Fllvm-wrapper%2FRustWrapper.cpp?ref=e33cc71a61c91e1d510bf283e9d345067e64eed2", "patch": "@@ -88,10 +88,6 @@ extern \"C\" char *LLVMRustGetLastError(void) {\n   return Ret;\n }\n \n-extern \"C\" unsigned int LLVMRustGetInstructionCount(LLVMModuleRef M) {\n-  return unwrap(M)->getInstructionCount();\n-}\n-\n extern \"C\" void LLVMRustSetLastError(const char *Err) {\n   free((void *)LastError);\n   LastError = strdup(Err);\n@@ -1529,11 +1525,6 @@ extern \"C\" void LLVMRustSetComdat(LLVMModuleRef M, LLVMValueRef V,\n   }\n }\n \n-extern \"C\" void LLVMRustUnsetComdat(LLVMValueRef V) {\n-  GlobalObject *GV = unwrap<GlobalObject>(V);\n-  GV->setComdat(nullptr);\n-}\n-\n enum class LLVMRustLinkage {\n   ExternalLinkage = 0,\n   AvailableExternallyLinkage = 1,"}, {"sha": "6bf237b8ed5dfc5482e3fa76b1408b050768980b", "filename": "compiler/rustc_metadata/src/rmeta/decoder/cstore_impl.rs", "status": "modified", "additions": 15, "deletions": 5, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/e33cc71a61c91e1d510bf283e9d345067e64eed2/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e33cc71a61c91e1d510bf283e9d345067e64eed2/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs?ref=e33cc71a61c91e1d510bf283e9d345067e64eed2", "patch": "@@ -375,9 +375,13 @@ pub(in crate::rmeta) fn provide(providers: &mut Providers) {\n             use std::collections::vec_deque::VecDeque;\n \n             let mut visible_parent_map: DefIdMap<DefId> = Default::default();\n-            // This is a secondary visible_parent_map, storing the DefId of parents that re-export\n-            // the child as `_`. Since we prefer parents that don't do this, merge this map at the\n-            // end, only if we're missing any keys from the former.\n+            // This is a secondary visible_parent_map, storing the DefId of\n+            // parents that re-export the child as `_` or module parents\n+            // which are `#[doc(hidden)]`. Since we prefer paths that don't\n+            // do this, merge this map at the end, only if we're missing\n+            // keys from the former.\n+            // This is a rudimentary check that does not catch all cases,\n+            // just the easiest.\n             let mut fallback_map: DefIdMap<DefId> = Default::default();\n \n             // Issue 46112: We want the map to prefer the shortest\n@@ -412,6 +416,11 @@ pub(in crate::rmeta) fn provide(providers: &mut Providers) {\n                         return;\n                     }\n \n+                    if ty::util::is_doc_hidden(tcx, parent) {\n+                        fallback_map.insert(def_id, parent);\n+                        return;\n+                    }\n+\n                     match visible_parent_map.entry(def_id) {\n                         Entry::Occupied(mut entry) => {\n                             // If `child` is defined in crate `cnum`, ensure\n@@ -439,8 +448,9 @@ pub(in crate::rmeta) fn provide(providers: &mut Providers) {\n                 }\n             }\n \n-            // Fill in any missing entries with the (less preferable) path ending in `::_`.\n-            // We still use this path in a diagnostic that suggests importing `::*`.\n+            // Fill in any missing entries with the less preferable path.\n+            // If this path re-exports the child as `_`, we still use this\n+            // path in a diagnostic that suggests importing `::*`.\n             for (child, parent) in fallback_map {\n                 visible_parent_map.entry(child).or_insert(parent);\n             }"}, {"sha": "f3ccbbb56792dc3493c88a2487fec396a6ecb669", "filename": "compiler/rustc_passes/src/check_attr.rs", "status": "modified", "additions": 125, "deletions": 267, "changes": 392, "blob_url": "https://github.com/rust-lang/rust/blob/e33cc71a61c91e1d510bf283e9d345067e64eed2/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e33cc71a61c91e1d510bf283e9d345067e64eed2/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs?ref=e33cc71a61c91e1d510bf283e9d345067e64eed2", "patch": "@@ -7,7 +7,7 @@\n use crate::errors;\n use rustc_ast::{ast, AttrStyle, Attribute, Lit, LitKind, MetaItemKind, NestedMetaItem};\n use rustc_data_structures::fx::FxHashMap;\n-use rustc_errors::{fluent, pluralize, struct_span_err, Applicability, MultiSpan};\n+use rustc_errors::{fluent, struct_span_err, Applicability, MultiSpan};\n use rustc_expand::base::resolve_path;\n use rustc_feature::{AttributeDuplicates, AttributeType, BuiltinAttribute, BUILTIN_ATTRIBUTE_MAP};\n use rustc_hir as hir;\n@@ -1180,30 +1180,22 @@ impl CheckAttrVisitor<'_> {\n             _ => {\n                 // FIXME: #[cold] was previously allowed on non-functions/statics and some crates\n                 // used this, so only emit a warning.\n-                self.tcx.struct_span_lint_hir(UNUSED_ATTRIBUTES, hir_id, attr.span, |lint| {\n-                    let mut diag =\n-                        lint.build(\"attribute should be applied to a foreign function or static\");\n-                    diag.warn(\n-                        \"this was previously accepted by the compiler but is \\\n-                         being phased out; it will become a hard error in \\\n-                         a future release!\",\n+                let attr_span = matches!(target, Target::ForeignMod).then_some(attr.span);\n+                if let Some(s) = attr.value_str() {\n+                    self.tcx.emit_spanned_lint(\n+                        UNUSED_ATTRIBUTES,\n+                        hir_id,\n+                        attr.span,\n+                        errors::LinkName { span, attr_span, value: s.as_str() },\n                     );\n-\n-                    // See issue #47725\n-                    if let Target::ForeignMod = target {\n-                        if let Some(value) = attr.value_str() {\n-                            diag.span_help(\n-                                attr.span,\n-                                &format!(r#\"try `#[link(name = \"{value}\")]` instead\"#),\n-                            );\n-                        } else {\n-                            diag.span_help(attr.span, r#\"try `#[link(name = \"...\")]` instead\"#);\n-                        }\n-                    }\n-\n-                    diag.span_label(span, \"not a foreign function or static\");\n-                    diag.emit();\n-                });\n+                } else {\n+                    self.tcx.emit_spanned_lint(\n+                        UNUSED_ATTRIBUTES,\n+                        hir_id,\n+                        attr.span,\n+                        errors::LinkName { span, attr_span, value: \"...\" },\n+                    );\n+                };\n             }\n         }\n     }\n@@ -1221,14 +1213,7 @@ impl CheckAttrVisitor<'_> {\n                 true\n             }\n             _ => {\n-                self.tcx\n-                    .sess\n-                    .struct_span_err(\n-                        attr.span,\n-                        \"attribute should be applied to an `extern crate` item\",\n-                    )\n-                    .span_label(span, \"not an `extern crate` item\")\n-                    .emit();\n+                self.tcx.sess.emit_err(errors::NoLink { attr_span: attr.span, span });\n                 false\n             }\n         }\n@@ -1258,14 +1243,7 @@ impl CheckAttrVisitor<'_> {\n                 true\n             }\n             _ => {\n-                self.tcx\n-                    .sess\n-                    .struct_span_err(\n-                        attr.span,\n-                        \"attribute should be applied to a free function, impl method or static\",\n-                    )\n-                    .span_label(span, \"not a free function, impl method or static\")\n-                    .emit();\n+                self.tcx.sess.emit_err(errors::ExportName { attr_span: attr.span, span });\n                 false\n             }\n         }\n@@ -1278,11 +1256,10 @@ impl CheckAttrVisitor<'_> {\n         target: Target,\n     ) -> bool {\n         if target != Target::Struct {\n-            self.tcx\n-                .sess\n-                .struct_span_err(attr.span, \"attribute should be applied to a struct\")\n-                .span_label(span, \"not a struct\")\n-                .emit();\n+            self.tcx.sess.emit_err(errors::RustcLayoutScalarValidRangeNotStruct {\n+                attr_span: attr.span,\n+                span,\n+            });\n             return false;\n         }\n \n@@ -1293,10 +1270,7 @@ impl CheckAttrVisitor<'_> {\n         if matches!(&list[..], &[NestedMetaItem::Literal(Lit { kind: LitKind::Int(..), .. })]) {\n             true\n         } else {\n-            self.tcx\n-                .sess\n-                .struct_span_err(attr.span, \"expected exactly one integer literal argument\")\n-                .emit();\n+            self.tcx.sess.emit_err(errors::RustcLayoutScalarValidRangeArg { attr_span: attr.span });\n             false\n         }\n     }\n@@ -1311,11 +1285,10 @@ impl CheckAttrVisitor<'_> {\n     ) -> bool {\n         let is_function = matches!(target, Target::Fn);\n         if !is_function {\n-            self.tcx\n-                .sess\n-                .struct_span_err(attr.span, \"attribute should be applied to a function\")\n-                .span_label(span, \"not a function\")\n-                .emit();\n+            self.tcx.sess.emit_err(errors::AttrShouldBeAppliedToFn {\n+                attr_span: attr.span,\n+                defn_span: span,\n+            });\n             return false;\n         }\n \n@@ -1335,29 +1308,20 @@ impl CheckAttrVisitor<'_> {\n             match param.kind {\n                 hir::GenericParamKind::Const { .. } => {}\n                 _ => {\n-                    self.tcx\n-                        .sess\n-                        .struct_span_err(\n-                            attr.span,\n-                            \"#[rustc_legacy_const_generics] functions must \\\n-                             only have const generics\",\n-                        )\n-                        .span_label(param.span, \"non-const generic parameter\")\n-                        .emit();\n+                    self.tcx.sess.emit_err(errors::RustcLegacyConstGenericsOnly {\n+                        attr_span: attr.span,\n+                        param_span: param.span,\n+                    });\n                     return false;\n                 }\n             }\n         }\n \n         if list.len() != generics.params.len() {\n-            self.tcx\n-                .sess\n-                .struct_span_err(\n-                    attr.span,\n-                    \"#[rustc_legacy_const_generics] must have one index for each generic parameter\",\n-                )\n-                .span_label(generics.span, \"generic parameters\")\n-                .emit();\n+            self.tcx.sess.emit_err(errors::RustcLegacyConstGenericsIndex {\n+                attr_span: attr.span,\n+                generics_span: generics.span,\n+            });\n             return false;\n         }\n \n@@ -1367,19 +1331,10 @@ impl CheckAttrVisitor<'_> {\n             if let Some(LitKind::Int(val, _)) = meta.literal().map(|lit| &lit.kind) {\n                 if *val >= arg_count {\n                     let span = meta.span();\n-                    self.tcx\n-                        .sess\n-                        .struct_span_err(span, \"index exceeds number of arguments\")\n-                        .span_label(\n-                            span,\n-                            format!(\n-                                \"there {} only {} argument{}\",\n-                                pluralize!(\"is\", arg_count),\n-                                arg_count,\n-                                pluralize!(arg_count)\n-                            ),\n-                        )\n-                        .emit();\n+                    self.tcx.sess.emit_err(errors::RustcLegacyConstGenericsIndexExceed {\n+                        span,\n+                        arg_count: arg_count as usize,\n+                    });\n                     return false;\n                 }\n             } else {\n@@ -1388,10 +1343,7 @@ impl CheckAttrVisitor<'_> {\n         }\n \n         if !invalid_args.is_empty() {\n-            self.tcx\n-                .sess\n-                .struct_span_err(invalid_args, \"arguments should be non-negative integers\")\n-                .emit();\n+            self.tcx.sess.emit_err(errors::RustcLegacyConstGenericsIndexNegative { invalid_args });\n             false\n         } else {\n             true\n@@ -1403,11 +1355,10 @@ impl CheckAttrVisitor<'_> {\n     fn check_applied_to_fn_or_method(&self, attr: &Attribute, span: Span, target: Target) -> bool {\n         let is_function = matches!(target, Target::Fn | Target::Method(..));\n         if !is_function {\n-            self.tcx\n-                .sess\n-                .struct_span_err(attr.span, \"attribute should be applied to a function\")\n-                .span_label(span, \"not a function\")\n-                .emit();\n+            self.tcx.sess.emit_err(errors::AttrShouldBeAppliedToFn {\n+                attr_span: attr.span,\n+                defn_span: span,\n+            });\n             false\n         } else {\n             true\n@@ -1437,10 +1388,7 @@ impl CheckAttrVisitor<'_> {\n         if self.tcx.sess.opts.unstable_opts.query_dep_graph {\n             true\n         } else {\n-            self.tcx\n-                .sess\n-                .struct_span_err(attr.span, \"attribute requires -Z query-dep-graph to be enabled\")\n-                .emit();\n+            self.tcx.sess.emit_err(errors::RustcDirtyClean { span: attr.span });\n             false\n         }\n     }\n@@ -1459,16 +1407,12 @@ impl CheckAttrVisitor<'_> {\n             _ => {\n                 // FIXME: #[link_section] was previously allowed on non-functions/statics and some\n                 // crates used this, so only emit a warning.\n-                self.tcx.struct_span_lint_hir(UNUSED_ATTRIBUTES, hir_id, attr.span, |lint| {\n-                    lint.build(\"attribute should be applied to a function or static\")\n-                        .warn(\n-                            \"this was previously accepted by the compiler but is \\\n-                             being phased out; it will become a hard error in \\\n-                             a future release!\",\n-                        )\n-                        .span_label(span, \"not a function or static\")\n-                        .emit();\n-                });\n+                self.tcx.emit_spanned_lint(\n+                    UNUSED_ATTRIBUTES,\n+                    hir_id,\n+                    attr.span,\n+                    errors::LinkSection { span },\n+                );\n             }\n         }\n     }\n@@ -1494,41 +1438,22 @@ impl CheckAttrVisitor<'_> {\n                     Target::ForeignStatic => \"static\",\n                     _ => unreachable!(),\n                 };\n-                self.tcx.struct_span_lint_hir(UNUSED_ATTRIBUTES, hir_id, attr.span, |lint| {\n-                    lint.build(&format!(\n-                        \"`#[no_mangle]` has no effect on a foreign {foreign_item_kind}\"\n-                    ))\n-                    .warn(\n-                        \"this was previously accepted by the compiler but is \\\n-                            being phased out; it will become a hard error in \\\n-                            a future release!\",\n-                    )\n-                    .span_label(span, format!(\"foreign {foreign_item_kind}\"))\n-                    .note(\"symbol names in extern blocks are not mangled\")\n-                    .span_suggestion(\n-                        attr.span,\n-                        \"remove this attribute\",\n-                        \"\",\n-                        Applicability::MachineApplicable,\n-                    )\n-                    .emit();\n-                });\n+                self.tcx.emit_spanned_lint(\n+                    UNUSED_ATTRIBUTES,\n+                    hir_id,\n+                    attr.span,\n+                    errors::NoMangleForeign { span, attr_span: attr.span, foreign_item_kind },\n+                );\n             }\n             _ => {\n                 // FIXME: #[no_mangle] was previously allowed on non-functions/statics and some\n                 // crates used this, so only emit a warning.\n-                self.tcx.struct_span_lint_hir(UNUSED_ATTRIBUTES, hir_id, attr.span, |lint| {\n-                    lint.build(\n-                        \"attribute should be applied to a free function, impl method or static\",\n-                    )\n-                    .warn(\n-                        \"this was previously accepted by the compiler but is \\\n-                         being phased out; it will become a hard error in \\\n-                         a future release!\",\n-                    )\n-                    .span_label(span, \"not a free function, impl method or static\")\n-                    .emit();\n-                });\n+                self.tcx.emit_spanned_lint(\n+                    UNUSED_ATTRIBUTES,\n+                    hir_id,\n+                    attr.span,\n+                    errors::NoMangle { span },\n+                );\n             }\n         }\n     }\n@@ -1561,13 +1486,7 @@ impl CheckAttrVisitor<'_> {\n \n         for hint in &hints {\n             if !hint.is_meta_item() {\n-                struct_span_err!(\n-                    self.tcx.sess,\n-                    hint.span(),\n-                    E0565,\n-                    \"meta item in `repr` must be an identifier\"\n-                )\n-                .emit();\n+                self.tcx.sess.emit_err(errors::ReprIdent { span: hint.span() });\n                 continue;\n             }\n \n@@ -1688,15 +1607,11 @@ impl CheckAttrVisitor<'_> {\n                     return false;\n                 }))\n         {\n-            self.tcx.struct_span_lint_hir(\n+            self.tcx.emit_spanned_lint(\n                 CONFLICTING_REPR_HINTS,\n                 hir_id,\n                 hint_spans.collect::<Vec<Span>>(),\n-                |lint| {\n-                    lint.build(\"conflicting representation hints\")\n-                        .code(rustc_errors::error_code!(E0566))\n-                        .emit();\n-                },\n+                errors::ReprConflicting,\n             );\n         }\n     }\n@@ -1706,9 +1621,7 @@ impl CheckAttrVisitor<'_> {\n         let mut used_compiler_span = None;\n         for attr in attrs.iter().filter(|attr| attr.has_name(sym::used)) {\n             if target != Target::Static {\n-                self.tcx\n-                    .sess\n-                    .span_err(attr.span, \"attribute must be applied to a `static` variable\");\n+                self.tcx.sess.emit_err(errors::UsedStatic { span: attr.span });\n             }\n             let inner = attr.meta_item_list();\n             match inner.as_deref() {\n@@ -1734,14 +1647,9 @@ impl CheckAttrVisitor<'_> {\n             }\n         }\n         if let (Some(linker_span), Some(compiler_span)) = (used_linker_span, used_compiler_span) {\n-            let spans = vec![linker_span, compiler_span];\n             self.tcx\n                 .sess\n-                .struct_span_err(\n-                    spans,\n-                    \"`used(compiler)` and `used(linker)` can't be used together\",\n-                )\n-                .emit();\n+                .emit_err(errors::UsedCompilerLinker { spans: vec![linker_span, compiler_span] });\n         }\n     }\n \n@@ -1783,9 +1691,7 @@ impl CheckAttrVisitor<'_> {\n             _ => {\n                 self.tcx\n                     .sess\n-                    .struct_span_err(attr.span, \"attribute should be applied to a macro\")\n-                    .span_label(span, \"not a macro\")\n-                    .emit();\n+                    .emit_err(errors::AllowInternalUnstable { attr_span: attr.span, span });\n                 false\n             }\n         }\n@@ -1796,37 +1702,34 @@ impl CheckAttrVisitor<'_> {\n         match target {\n             Target::Mod => {}\n             _ => {\n-                self.tcx\n-                    .sess\n-                    .struct_span_err(attr.span, \"attribute should be applied to a module\")\n-                    .emit();\n+                self.tcx.sess.emit_err(errors::DebugVisualizerPlacement { span: attr.span });\n                 return false;\n             }\n         }\n \n         let Some(hints) = attr.meta_item_list() else {\n-            self.emit_debugger_visualizer_err(attr.span);\n+            self.tcx.sess.emit_err(errors::DebugVisualizerInvalid { span: attr.span });\n             return false;\n         };\n \n         let hint = match hints.len() {\n             1 => &hints[0],\n             _ => {\n-                self.emit_debugger_visualizer_err(attr.span);\n+                self.tcx.sess.emit_err(errors::DebugVisualizerInvalid { span: attr.span });\n                 return false;\n             }\n         };\n \n         let Some(meta_item) = hint.meta_item() else {\n-            self.emit_debugger_visualizer_err(attr.span);\n+            self.tcx.sess.emit_err(errors::DebugVisualizerInvalid { span: attr.span });\n             return false;\n         };\n \n         let visualizer_path = match (meta_item.name_or_empty(), meta_item.value_str()) {\n             (sym::natvis_file, Some(value)) => value,\n             (sym::gdb_script_file, Some(value)) => value,\n             (_, _) => {\n-                self.emit_debugger_visualizer_err(meta_item.span);\n+                self.tcx.sess.emit_err(errors::DebugVisualizerInvalid { span: meta_item.span });\n                 return false;\n             }\n         };\n@@ -1855,16 +1758,6 @@ impl CheckAttrVisitor<'_> {\n         }\n     }\n \n-    fn emit_debugger_visualizer_err(&self, span: Span) {\n-        self.tcx\n-            .sess\n-            .struct_span_err(span, \"invalid argument\")\n-            .note(r#\"expected: `natvis_file = \"...\"`\"#)\n-            .note(r#\"OR\"#)\n-            .note(r#\"expected: `gdb_script_file = \"...\"`\"#)\n-            .emit();\n-    }\n-\n     /// Outputs an error for `#[allow_internal_unstable]` which can only be applied to macros.\n     /// (Allows proc_macro functions)\n     fn check_rustc_allow_const_fn_unstable(\n@@ -1891,9 +1784,7 @@ impl CheckAttrVisitor<'_> {\n             _ => {\n                 self.tcx\n                     .sess\n-                    .struct_span_err(attr.span, \"attribute should be applied to `const fn`\")\n-                    .span_label(span, \"not a `const fn`\")\n-                    .emit();\n+                    .emit_err(errors::RustcAllowConstFnUnstable { attr_span: attr.span, span });\n                 false\n             }\n         }\n@@ -1910,9 +1801,7 @@ impl CheckAttrVisitor<'_> {\n             _ => {\n                 self.tcx\n                     .sess\n-                    .struct_span_err(attr.span, \"attribute should be applied functions or statics\")\n-                    .span_label(span, \"not a function or static\")\n-                    .emit();\n+                    .emit_err(errors::RustcStdInternalSymbol { attr_span: attr.span, span });\n                 false\n             }\n         }\n@@ -1923,10 +1812,7 @@ impl CheckAttrVisitor<'_> {\n         match target {\n             Target::Trait => true,\n             _ => {\n-                self.tcx\n-                    .sess\n-                    .struct_span_err(attr.span, \"attribute should be applied to a trait\")\n-                    .emit();\n+                self.tcx.sess.emit_err(errors::ConstTrait { attr_span: attr.span });\n                 false\n             }\n         }\n@@ -1935,10 +1821,7 @@ impl CheckAttrVisitor<'_> {\n     fn check_stability_promotable(&self, attr: &Attribute, _span: Span, target: Target) -> bool {\n         match target {\n             Target::Expression => {\n-                self.tcx\n-                    .sess\n-                    .struct_span_err(attr.span, \"attribute cannot be applied to an expression\")\n-                    .emit();\n+                self.tcx.sess.emit_err(errors::StabilityPromotable { attr_span: attr.span });\n                 false\n             }\n             _ => true,\n@@ -1948,9 +1831,12 @@ impl CheckAttrVisitor<'_> {\n     fn check_deprecated(&self, hir_id: HirId, attr: &Attribute, _span: Span, target: Target) {\n         match target {\n             Target::Closure | Target::Expression | Target::Statement | Target::Arm => {\n-                self.tcx.struct_span_lint_hir(UNUSED_ATTRIBUTES, hir_id, attr.span, |lint| {\n-                    lint.build(\"attribute is ignored here\").emit();\n-                });\n+                self.tcx.emit_spanned_lint(\n+                    UNUSED_ATTRIBUTES,\n+                    hir_id,\n+                    attr.span,\n+                    errors::Deprecated,\n+                );\n             }\n             _ => {}\n         }\n@@ -1961,29 +1847,30 @@ impl CheckAttrVisitor<'_> {\n         match target {\n             Target::ExternCrate | Target::Mod => {}\n             _ => {\n-                self.tcx.struct_span_lint_hir(UNUSED_ATTRIBUTES, hir_id, attr.span, |lint| {\n-                    lint.build(&format!(\n-                        \"`#[{name}]` only has an effect on `extern crate` and modules\"\n-                    ))\n-                    .emit();\n-                });\n+                self.tcx.emit_spanned_lint(\n+                    UNUSED_ATTRIBUTES,\n+                    hir_id,\n+                    attr.span,\n+                    errors::MacroUse { name },\n+                );\n             }\n         }\n     }\n \n     fn check_macro_export(&self, hir_id: HirId, attr: &Attribute, target: Target) {\n         if target != Target::MacroDef {\n-            self.tcx.struct_span_lint_hir(UNUSED_ATTRIBUTES, hir_id, attr.span, |lint| {\n-                lint.build(\"`#[macro_export]` only has an effect on macro definitions\").emit();\n-            });\n+            self.tcx.emit_spanned_lint(UNUSED_ATTRIBUTES, hir_id, attr.span, errors::MacroExport);\n         }\n     }\n \n     fn check_plugin_registrar(&self, hir_id: HirId, attr: &Attribute, target: Target) {\n         if target != Target::Fn {\n-            self.tcx.struct_span_lint_hir(UNUSED_ATTRIBUTES, hir_id, attr.span, |lint| {\n-                lint.build(\"`#[plugin_registrar]` only has an effect on functions\").emit();\n-            });\n+            self.tcx.emit_spanned_lint(\n+                UNUSED_ATTRIBUTES,\n+                hir_id,\n+                attr.span,\n+                errors::PluginRegistrar,\n+            );\n         }\n     }\n \n@@ -2002,10 +1889,7 @@ impl CheckAttrVisitor<'_> {\n                 | sym::target_feature\n         ) && attr.meta_item_list().map_or(false, |list| list.is_empty())\n         {\n-            format!(\n-                \"attribute `{}` with an empty list has no effect\",\n-                attr.name_or_empty()\n-            )\n+            errors::UnusedNote::EmptyList { name: attr.name_or_empty() }\n         } else if matches!(\n                 attr.name_or_empty(),\n                 sym::allow | sym::warn | sym::deny | sym::forbid | sym::expect\n@@ -2015,27 +1899,19 @@ impl CheckAttrVisitor<'_> {\n             && let MetaItemKind::NameValue(_) = &item.kind\n             && item.path == sym::reason\n         {\n-            format!(\n-                \"attribute `{}` without any lints has no effect\",\n-                attr.name_or_empty()\n-            )\n+            errors::UnusedNote::NoLints { name: attr.name_or_empty() }\n         } else if attr.name_or_empty() == sym::default_method_body_is_const {\n-            format!(\"`default_method_body_is_const` has been replaced with `#[const_trait]` on traits\")\n+            errors::UnusedNote::DefaultMethodBodyConst\n         } else {\n             return;\n         };\n \n-        self.tcx.struct_span_lint_hir(UNUSED_ATTRIBUTES, hir_id, attr.span, |lint| {\n-            lint.build(\"unused attribute\")\n-                .span_suggestion(\n-                    attr.span,\n-                    \"remove this attribute\",\n-                    \"\",\n-                    Applicability::MachineApplicable,\n-                )\n-                .note(&note)\n-                .emit();\n-        });\n+        self.tcx.emit_spanned_lint(\n+            UNUSED_ATTRIBUTES,\n+            hir_id,\n+            attr.span,\n+            errors::Unused { attr_span: attr.span, note },\n+        );\n     }\n }\n \n@@ -2206,14 +2082,7 @@ fn check_non_exported_macro_for_invalid_attrs(tcx: TyCtxt<'_>, item: &Item<'_>)\n \n     for attr in attrs {\n         if attr.has_name(sym::inline) {\n-            struct_span_err!(\n-                tcx.sess,\n-                attr.span,\n-                E0518,\n-                \"attribute should be applied to function or closure\",\n-            )\n-            .span_label(attr.span, \"not a function or closure\")\n-            .emit();\n+            tcx.sess.emit_err(errors::NonExportedMacroInvalidAttrs { attr_span: attr.span });\n         }\n     }\n }\n@@ -2253,23 +2122,20 @@ fn check_duplicates(\n                     } else {\n                         (attr.span, *entry.get())\n                     };\n-                    tcx.struct_span_lint_hir(UNUSED_ATTRIBUTES, hir_id, this, |lint| {\n-                        let mut db = lint.build(\"unused attribute\");\n-                        db.span_note(other, \"attribute also specified here\").span_suggestion(\n+                    tcx.emit_spanned_lint(\n+                        UNUSED_ATTRIBUTES,\n+                        hir_id,\n+                        this,\n+                        errors::UnusedDuplicate {\n                             this,\n-                            \"remove this attribute\",\n-                            \"\",\n-                            Applicability::MachineApplicable,\n-                        );\n-                        if matches!(duplicates, FutureWarnFollowing | FutureWarnPreceding) {\n-                            db.warn(\n-                                \"this was previously accepted by the compiler but is \\\n-                                 being phased out; it will become a hard error in \\\n-                                 a future release!\",\n-                            );\n-                        }\n-                        db.emit();\n-                    });\n+                            other,\n+                            warning: matches!(\n+                                duplicates,\n+                                FutureWarnFollowing | FutureWarnPreceding\n+                            )\n+                            .then_some(()),\n+                        },\n+                    );\n                 }\n                 Entry::Vacant(entry) => {\n                     entry.insert(attr.span);\n@@ -2284,19 +2150,11 @@ fn check_duplicates(\n                 } else {\n                     (attr.span, *entry.get())\n                 };\n-                tcx.sess\n-                    .struct_span_err(\n-                        this,\n-                        &format!(\"multiple `{}` attributes\", attr.name_or_empty()),\n-                    )\n-                    .span_note(other, \"attribute also specified here\")\n-                    .span_suggestion(\n-                        this,\n-                        \"remove this attribute\",\n-                        \"\",\n-                        Applicability::MachineApplicable,\n-                    )\n-                    .emit();\n+                tcx.sess.emit_err(errors::UnusedMultiple {\n+                    this,\n+                    other,\n+                    name: attr.name_or_empty(),\n+                });\n             }\n             Entry::Vacant(entry) => {\n                 entry.insert(attr.span);"}, {"sha": "0d4317f6b8881e1dbaff8c9234d49e6e351d3be8", "filename": "compiler/rustc_passes/src/errors.rs", "status": "modified", "additions": 266, "deletions": 1, "changes": 267, "blob_url": "https://github.com/rust-lang/rust/blob/e33cc71a61c91e1d510bf283e9d345067e64eed2/compiler%2Frustc_passes%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e33cc71a61c91e1d510bf283e9d345067e64eed2/compiler%2Frustc_passes%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Ferrors.rs?ref=e33cc71a61c91e1d510bf283e9d345067e64eed2", "patch": "@@ -1,5 +1,5 @@\n use rustc_errors::{Applicability, MultiSpan};\n-use rustc_macros::{LintDiagnostic, SessionDiagnostic};\n+use rustc_macros::{LintDiagnostic, SessionDiagnostic, SessionSubdiagnostic};\n use rustc_span::{Span, Symbol};\n \n #[derive(LintDiagnostic)]\n@@ -360,3 +360,268 @@ pub struct Link {\n     #[label]\n     pub span: Option<Span>,\n }\n+\n+#[derive(LintDiagnostic)]\n+#[lint(passes::link_name)]\n+#[warn_]\n+pub struct LinkName<'a> {\n+    #[help]\n+    pub attr_span: Option<Span>,\n+    #[label]\n+    pub span: Span,\n+    pub value: &'a str,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[error(passes::no_link)]\n+pub struct NoLink {\n+    #[primary_span]\n+    pub attr_span: Span,\n+    #[label]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[error(passes::export_name)]\n+pub struct ExportName {\n+    #[primary_span]\n+    pub attr_span: Span,\n+    #[label]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[error(passes::rustc_layout_scalar_valid_range_not_struct)]\n+pub struct RustcLayoutScalarValidRangeNotStruct {\n+    #[primary_span]\n+    pub attr_span: Span,\n+    #[label]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[error(passes::rustc_layout_scalar_valid_range_arg)]\n+pub struct RustcLayoutScalarValidRangeArg {\n+    #[primary_span]\n+    pub attr_span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[error(passes::rustc_legacy_const_generics_only)]\n+pub struct RustcLegacyConstGenericsOnly {\n+    #[primary_span]\n+    pub attr_span: Span,\n+    #[label]\n+    pub param_span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[error(passes::rustc_legacy_const_generics_index)]\n+pub struct RustcLegacyConstGenericsIndex {\n+    #[primary_span]\n+    pub attr_span: Span,\n+    #[label]\n+    pub generics_span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[error(passes::rustc_legacy_const_generics_index_exceed)]\n+pub struct RustcLegacyConstGenericsIndexExceed {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+    pub arg_count: usize,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[error(passes::rustc_legacy_const_generics_index_negative)]\n+pub struct RustcLegacyConstGenericsIndexNegative {\n+    #[primary_span]\n+    pub invalid_args: Vec<Span>,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[error(passes::rustc_dirty_clean)]\n+pub struct RustcDirtyClean {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[lint(passes::link_section)]\n+#[warn_]\n+pub struct LinkSection {\n+    #[label]\n+    pub span: Span,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[lint(passes::no_mangle_foreign)]\n+#[warn_]\n+#[note]\n+pub struct NoMangleForeign {\n+    #[label]\n+    pub span: Span,\n+    #[suggestion(applicability = \"machine-applicable\")]\n+    pub attr_span: Span,\n+    pub foreign_item_kind: &'static str,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[lint(passes::no_mangle)]\n+#[warn_]\n+pub struct NoMangle {\n+    #[label]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[error(passes::repr_ident, code = \"E0565\")]\n+pub struct ReprIdent {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[lint(passes::repr_conflicting, code = \"E0566\")]\n+pub struct ReprConflicting;\n+\n+#[derive(SessionDiagnostic)]\n+#[error(passes::used_static)]\n+pub struct UsedStatic {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[error(passes::used_compiler_linker)]\n+pub struct UsedCompilerLinker {\n+    #[primary_span]\n+    pub spans: Vec<Span>,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[error(passes::allow_internal_unstable)]\n+pub struct AllowInternalUnstable {\n+    #[primary_span]\n+    pub attr_span: Span,\n+    #[label]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[error(passes::debug_visualizer_placement)]\n+pub struct DebugVisualizerPlacement {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[error(passes::debug_visualizer_invalid)]\n+#[note(passes::note_1)]\n+#[note(passes::note_2)]\n+#[note(passes::note_3)]\n+pub struct DebugVisualizerInvalid {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[error(passes::rustc_allow_const_fn_unstable)]\n+pub struct RustcAllowConstFnUnstable {\n+    #[primary_span]\n+    pub attr_span: Span,\n+    #[label]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[error(passes::rustc_std_internal_symbol)]\n+pub struct RustcStdInternalSymbol {\n+    #[primary_span]\n+    pub attr_span: Span,\n+    #[label]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[error(passes::const_trait)]\n+pub struct ConstTrait {\n+    #[primary_span]\n+    pub attr_span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[error(passes::stability_promotable)]\n+pub struct StabilityPromotable {\n+    #[primary_span]\n+    pub attr_span: Span,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[lint(passes::deprecated)]\n+pub struct Deprecated;\n+\n+#[derive(LintDiagnostic)]\n+#[lint(passes::macro_use)]\n+pub struct MacroUse {\n+    pub name: Symbol,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[lint(passes::macro_export)]\n+pub struct MacroExport;\n+\n+#[derive(LintDiagnostic)]\n+#[lint(passes::plugin_registrar)]\n+pub struct PluginRegistrar;\n+\n+#[derive(SessionSubdiagnostic)]\n+pub enum UnusedNote {\n+    #[note(passes::unused_empty_lints_note)]\n+    EmptyList { name: Symbol },\n+    #[note(passes::unused_no_lints_note)]\n+    NoLints { name: Symbol },\n+    #[note(passes::unused_default_method_body_const_note)]\n+    DefaultMethodBodyConst,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[lint(passes::unused)]\n+pub struct Unused {\n+    #[suggestion(applicability = \"machine-applicable\")]\n+    pub attr_span: Span,\n+    #[subdiagnostic]\n+    pub note: UnusedNote,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[error(passes::non_exported_macro_invalid_attrs, code = \"E0518\")]\n+pub struct NonExportedMacroInvalidAttrs {\n+    #[primary_span]\n+    #[label]\n+    pub attr_span: Span,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[lint(passes::unused_duplicate)]\n+pub struct UnusedDuplicate {\n+    #[primary_span]\n+    #[suggestion(code = \"\", applicability = \"machine-applicable\")]\n+    pub this: Span,\n+    #[note]\n+    pub other: Span,\n+    #[warn_]\n+    pub warning: Option<()>,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[error(passes::unused_multiple)]\n+pub struct UnusedMultiple {\n+    #[primary_span]\n+    #[suggestion(code = \"\", applicability = \"machine-applicable\")]\n+    pub this: Span,\n+    #[note]\n+    pub other: Span,\n+    pub name: Symbol,\n+}"}, {"sha": "a091f06dd532cc14aaa5f4f75cae8c43264f8256", "filename": "library/std/src/os/windows/fs.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e33cc71a61c91e1d510bf283e9d345067e64eed2/library%2Fstd%2Fsrc%2Fos%2Fwindows%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e33cc71a61c91e1d510bf283e9d345067e64eed2/library%2Fstd%2Fsrc%2Fos%2Fwindows%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Fwindows%2Ffs.rs?ref=e33cc71a61c91e1d510bf283e9d345067e64eed2", "patch": "@@ -7,6 +7,7 @@\n use crate::fs::{self, Metadata, OpenOptions};\n use crate::io;\n use crate::path::Path;\n+use crate::sealed::Sealed;\n use crate::sys;\n use crate::sys_common::{AsInner, AsInnerMut};\n \n@@ -502,17 +503,20 @@ impl MetadataExt for Metadata {\n /// Windows-specific extensions to [`fs::FileType`].\n ///\n /// On Windows, a symbolic link knows whether it is a file or directory.\n-#[unstable(feature = \"windows_file_type_ext\", issue = \"none\")]\n-pub trait FileTypeExt {\n+#[stable(feature = \"windows_file_type_ext\", since = \"1.64.0\")]\n+pub trait FileTypeExt: Sealed {\n     /// Returns `true` if this file type is a symbolic link that is also a directory.\n-    #[unstable(feature = \"windows_file_type_ext\", issue = \"none\")]\n+    #[stable(feature = \"windows_file_type_ext\", since = \"1.64.0\")]\n     fn is_symlink_dir(&self) -> bool;\n     /// Returns `true` if this file type is a symbolic link that is also a file.\n-    #[unstable(feature = \"windows_file_type_ext\", issue = \"none\")]\n+    #[stable(feature = \"windows_file_type_ext\", since = \"1.64.0\")]\n     fn is_symlink_file(&self) -> bool;\n }\n \n-#[unstable(feature = \"windows_file_type_ext\", issue = \"none\")]\n+#[stable(feature = \"windows_file_type_ext\", since = \"1.64.0\")]\n+impl Sealed for fs::FileType {}\n+\n+#[stable(feature = \"windows_file_type_ext\", since = \"1.64.0\")]\n impl FileTypeExt for fs::FileType {\n     fn is_symlink_dir(&self) -> bool {\n         self.as_inner().is_symlink_dir()"}, {"sha": "c7212ad2c21665160df2edf44b1aa5509b110d5a", "filename": "src/bootstrap/config.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e33cc71a61c91e1d510bf283e9d345067e64eed2/src%2Fbootstrap%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e33cc71a61c91e1d510bf283e9d345067e64eed2/src%2Fbootstrap%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfig.rs?ref=e33cc71a61c91e1d510bf283e9d345067e64eed2", "patch": "@@ -411,7 +411,11 @@ pub struct Target {\n impl Target {\n     pub fn from_triple(triple: &str) -> Self {\n         let mut target: Self = Default::default();\n-        if triple.contains(\"-none\") || triple.contains(\"nvptx\") || triple.contains(\"switch\") {\n+        if triple.contains(\"-none\")\n+            || triple.contains(\"nvptx\")\n+            || triple.contains(\"switch\")\n+            || triple.contains(\"-uefi\")\n+        {\n             target.no_std = true;\n         }\n         target"}, {"sha": "ddaa7438e1778e5b32d743faa1b05f62fe8c1e05", "filename": "src/librustdoc/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e33cc71a61c91e1d510bf283e9d345067e64eed2/src%2Flibrustdoc%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/e33cc71a61c91e1d510bf283e9d345067e64eed2/src%2Flibrustdoc%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2FCargo.toml?ref=e33cc71a61c91e1d510bf283e9d345067e64eed2", "patch": "@@ -10,7 +10,7 @@ path = \"lib.rs\"\n arrayvec = { version = \"0.7\", default-features = false }\n askama = { version = \"0.11\", default-features = false, features = [\"config\"] }\n atty = \"0.2\"\n-pulldown-cmark = { version = \"0.9\", default-features = false }\n+pulldown-cmark = { version = \"0.9.2\", default-features = false }\n minifier = \"0.2.1\"\n serde = { version = \"1.0\", features = [\"derive\"] }\n serde_json = \"1.0\""}, {"sha": "83d8ed3fc87fb6a0d8cf112f6c9def6b5ee0db24", "filename": "src/librustdoc/clean/types.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e33cc71a61c91e1d510bf283e9d345067e64eed2/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e33cc71a61c91e1d510bf283e9d345067e64eed2/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Ftypes.rs?ref=e33cc71a61c91e1d510bf283e9d345067e64eed2", "patch": "@@ -2175,8 +2175,8 @@ impl Path {\n     pub(crate) fn whole_name(&self) -> String {\n         self.segments\n             .iter()\n-            .map(|s| if s.name == kw::PathRoot { String::new() } else { s.name.to_string() })\n-            .intersperse(\"::\".into())\n+            .map(|s| if s.name == kw::PathRoot { \"\" } else { s.name.as_str() })\n+            .intersperse(\"::\")\n             .collect()\n     }\n "}, {"sha": "52a2effca0ff7957db687d69d1a8eae9df941269", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e33cc71a61c91e1d510bf283e9d345067e64eed2/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e33cc71a61c91e1d510bf283e9d345067e64eed2/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=e33cc71a61c91e1d510bf283e9d345067e64eed2", "patch": "@@ -1485,6 +1485,7 @@ fn init_id_map() -> FxHashMap<Cow<'static, str>, usize> {\n     map.insert(\"synthetic-implementations-list\".into(), 1);\n     map.insert(\"blanket-implementations-list\".into(), 1);\n     map.insert(\"deref-methods\".into(), 1);\n+    map.insert(\"layout\".into(), 1);\n     map\n }\n "}, {"sha": "69d66693f752e92b9528917f15f82aad73c22696", "filename": "src/librustdoc/html/render/print_item.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e33cc71a61c91e1d510bf283e9d345067e64eed2/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e33cc71a61c91e1d510bf283e9d345067e64eed2/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs?ref=e33cc71a61c91e1d510bf283e9d345067e64eed2", "patch": "@@ -1880,7 +1880,11 @@ fn document_type_layout(w: &mut Buffer, cx: &Context<'_>, ty_def_id: DefId) {\n         return;\n     }\n \n-    writeln!(w, \"<h2 class=\\\"small-section-header\\\">Layout</h2>\");\n+    writeln!(\n+        w,\n+        \"<h2 id=\\\"layout\\\" class=\\\"small-section-header\\\"> \\\n+        Layout<a href=\\\"#layout\\\" class=\\\"anchor\\\"></a></h2>\"\n+    );\n     writeln!(w, \"<div class=\\\"docblock\\\">\");\n \n     let tcx = cx.tcx();"}, {"sha": "e5c6e9dc3f9ed30f29c95cf134d565ed1ef7e386", "filename": "src/test/rustdoc/type-layout.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e33cc71a61c91e1d510bf283e9d345067e64eed2/src%2Ftest%2Frustdoc%2Ftype-layout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e33cc71a61c91e1d510bf283e9d345067e64eed2/src%2Ftest%2Frustdoc%2Ftype-layout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Ftype-layout.rs?ref=e33cc71a61c91e1d510bf283e9d345067e64eed2", "patch": "@@ -2,6 +2,7 @@\n \n // @has type_layout/struct.Foo.html 'Size: '\n // @has - ' bytes'\n+// @has - '//*[@id=\"layout\"]/a[@href=\"#layout\"]' ''\n pub struct Foo {\n     pub a: usize,\n     b: Vec<String>,"}, {"sha": "e849ca2829e434c5532471666df115c9612498e4", "filename": "src/test/ui-fulldeps/internal-lints/diagnostics_incorrect.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e33cc71a61c91e1d510bf283e9d345067e64eed2/src%2Ftest%2Fui-fulldeps%2Finternal-lints%2Fdiagnostics_incorrect.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e33cc71a61c91e1d510bf283e9d345067e64eed2/src%2Ftest%2Fui-fulldeps%2Finternal-lints%2Fdiagnostics_incorrect.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Finternal-lints%2Fdiagnostics_incorrect.stderr?ref=e33cc71a61c91e1d510bf283e9d345067e64eed2", "patch": "@@ -4,14 +4,14 @@ error: malformed `rustc_lint_diagnostics` attribute input\n LL |     #[rustc_lint_diagnostics(a)]\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: must be of the form: `#[rustc_lint_diagnostics]`\n \n-error: attribute should be applied to a function\n+error: attribute should be applied to a function definition\n   --> $DIR/diagnostics_incorrect.rs:5:1\n    |\n LL | #[rustc_lint_diagnostics]\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^\n LL |\n LL | struct Foo;\n-   | ----------- not a function\n+   | ----------- not a function definition\n \n error: aborting due to 2 previous errors\n "}, {"sha": "3f78b39edd96a3adcddf933de7e810ca03798eac", "filename": "src/test/ui-fulldeps/internal-lints/query_stability_incorrect.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e33cc71a61c91e1d510bf283e9d345067e64eed2/src%2Ftest%2Fui-fulldeps%2Finternal-lints%2Fquery_stability_incorrect.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e33cc71a61c91e1d510bf283e9d345067e64eed2/src%2Ftest%2Fui-fulldeps%2Finternal-lints%2Fquery_stability_incorrect.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Finternal-lints%2Fquery_stability_incorrect.stderr?ref=e33cc71a61c91e1d510bf283e9d345067e64eed2", "patch": "@@ -4,14 +4,14 @@ error: malformed `rustc_lint_query_instability` attribute input\n LL |     #[rustc_lint_query_instability(a)]\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: must be of the form: `#[rustc_lint_query_instability]`\n \n-error: attribute should be applied to a function\n+error: attribute should be applied to a function definition\n   --> $DIR/query_stability_incorrect.rs:5:1\n    |\n LL | #[rustc_lint_query_instability]\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n LL |\n LL | struct Foo;\n-   | ----------- not a function\n+   | ----------- not a function definition\n \n error: aborting due to 2 previous errors\n "}, {"sha": "1ced1433fe955c395c2760262ce1559f88e96a88", "filename": "src/test/ui/invalid/invalid-rustc_legacy_const_generics-arguments.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e33cc71a61c91e1d510bf283e9d345067e64eed2/src%2Ftest%2Fui%2Finvalid%2Finvalid-rustc_legacy_const_generics-arguments.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e33cc71a61c91e1d510bf283e9d345067e64eed2/src%2Ftest%2Fui%2Finvalid%2Finvalid-rustc_legacy_const_generics-arguments.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finvalid%2Finvalid-rustc_legacy_const_generics-arguments.stderr?ref=e33cc71a61c91e1d510bf283e9d345067e64eed2", "patch": "@@ -50,13 +50,13 @@ error: arguments should be non-negative integers\n LL | #[rustc_legacy_const_generics(1, a, 2, b)]\n    |                                  ^     ^\n \n-error: attribute should be applied to a function\n+error: attribute should be applied to a function definition\n   --> $DIR/invalid-rustc_legacy_const_generics-arguments.rs:18:1\n    |\n LL | #[rustc_legacy_const_generics(0)]\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n LL | struct S;\n-   | --------- not a function\n+   | --------- not a function definition\n \n error: #[rustc_legacy_const_generics] functions must only have const generics\n   --> $DIR/invalid-rustc_legacy_const_generics-arguments.rs:29:1\n@@ -66,21 +66,21 @@ LL | #[rustc_legacy_const_generics(0)]\n LL | fn foo8<X>() {}\n    |         - non-const generic parameter\n \n-error: attribute should be applied to a function\n+error: attribute should be applied to a function definition\n   --> $DIR/invalid-rustc_legacy_const_generics-arguments.rs:33:5\n    |\n LL |     #[rustc_legacy_const_generics(0)]\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n LL |     fn foo9<const X: usize>() {}\n-   |     ---------------------------- not a function\n+   |     ---------------------------- not a function definition\n \n-error: attribute should be applied to a function\n+error: attribute should be applied to a function definition\n   --> $DIR/invalid-rustc_legacy_const_generics-arguments.rs:25:5\n    |\n LL |     #[rustc_legacy_const_generics(1)]\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n LL |     fn foo7<const X: usize>();\n-   |     -------------------------- not a function\n+   |     -------------------------- not a function definition\n \n error[E0044]: foreign items may not have const parameters\n   --> $DIR/invalid-rustc_legacy_const_generics-arguments.rs:26:5"}, {"sha": "15e0af1de6446e9e0685e13e27396c87633da0d8", "filename": "src/test/ui/suggestions/dont-suggest-doc-hidden-variant-for-enum/auxiliary/hidden-child.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e33cc71a61c91e1d510bf283e9d345067e64eed2/src%2Ftest%2Fui%2Fsuggestions%2Fdont-suggest-doc-hidden-variant-for-enum%2Fauxiliary%2Fhidden-child.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e33cc71a61c91e1d510bf283e9d345067e64eed2/src%2Ftest%2Fui%2Fsuggestions%2Fdont-suggest-doc-hidden-variant-for-enum%2Fauxiliary%2Fhidden-child.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fdont-suggest-doc-hidden-variant-for-enum%2Fauxiliary%2Fhidden-child.rs?ref=e33cc71a61c91e1d510bf283e9d345067e64eed2", "patch": "@@ -0,0 +1,8 @@\n+#![crate_type = \"lib\"]\n+\n+extern crate core;\n+\n+pub mod __private {\n+    #[doc(hidden)]\n+    pub use core::option::Option::{self, None, Some};\n+}"}, {"sha": "5a5079d8204ac980a988d93235b6af1eabafc9b7", "filename": "src/test/ui/suggestions/dont-suggest-doc-hidden-variant-for-enum/auxiliary/hidden-parent.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e33cc71a61c91e1d510bf283e9d345067e64eed2/src%2Ftest%2Fui%2Fsuggestions%2Fdont-suggest-doc-hidden-variant-for-enum%2Fauxiliary%2Fhidden-parent.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e33cc71a61c91e1d510bf283e9d345067e64eed2/src%2Ftest%2Fui%2Fsuggestions%2Fdont-suggest-doc-hidden-variant-for-enum%2Fauxiliary%2Fhidden-parent.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fdont-suggest-doc-hidden-variant-for-enum%2Fauxiliary%2Fhidden-parent.rs?ref=e33cc71a61c91e1d510bf283e9d345067e64eed2", "patch": "@@ -0,0 +1,8 @@\n+#![crate_type = \"lib\"]\n+\n+extern crate core;\n+\n+#[doc(hidden)]\n+pub mod __private {\n+    pub use core::option::Option::{self, None, Some};\n+}"}, {"sha": "38dabc9d71ff7de70c3efb51c0a15638f60be22a", "filename": "src/test/ui/suggestions/dont-suggest-doc-hidden-variant-for-enum/hidden-child.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e33cc71a61c91e1d510bf283e9d345067e64eed2/src%2Ftest%2Fui%2Fsuggestions%2Fdont-suggest-doc-hidden-variant-for-enum%2Fhidden-child.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e33cc71a61c91e1d510bf283e9d345067e64eed2/src%2Ftest%2Fui%2Fsuggestions%2Fdont-suggest-doc-hidden-variant-for-enum%2Fhidden-child.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fdont-suggest-doc-hidden-variant-for-enum%2Fhidden-child.rs?ref=e33cc71a61c91e1d510bf283e9d345067e64eed2", "patch": "@@ -0,0 +1,10 @@\n+// aux-build:hidden-child.rs\n+\n+// FIXME(compiler-errors): This currently suggests the wrong thing.\n+// UI test exists to track the problem.\n+\n+extern crate hidden_child;\n+\n+fn main() {\n+    let x: Option<i32> = 1i32; //~ ERROR mismatched types\n+}"}, {"sha": "67f4ac08de2c58b0e2189c9f581aa489b4b97bbc", "filename": "src/test/ui/suggestions/dont-suggest-doc-hidden-variant-for-enum/hidden-child.stderr", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/e33cc71a61c91e1d510bf283e9d345067e64eed2/src%2Ftest%2Fui%2Fsuggestions%2Fdont-suggest-doc-hidden-variant-for-enum%2Fhidden-child.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e33cc71a61c91e1d510bf283e9d345067e64eed2/src%2Ftest%2Fui%2Fsuggestions%2Fdont-suggest-doc-hidden-variant-for-enum%2Fhidden-child.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fdont-suggest-doc-hidden-variant-for-enum%2Fhidden-child.stderr?ref=e33cc71a61c91e1d510bf283e9d345067e64eed2", "patch": "@@ -0,0 +1,18 @@\n+error[E0308]: mismatched types\n+  --> $DIR/hidden-child.rs:9:26\n+   |\n+LL |     let x: Option<i32> = 1i32;\n+   |            -----------   ^^^^ expected enum `Option`, found `i32`\n+   |            |\n+   |            expected due to this\n+   |\n+   = note: expected enum `Option<i32>`\n+              found type `i32`\n+help: try wrapping the expression in `hidden_child::__private::Some`\n+   |\n+LL |     let x: Option<i32> = hidden_child::__private::Some(1i32);\n+   |                          ++++++++++++++++++++++++++++++    +\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "4d96d6c16cba0f5e2ddcc2b862fcb158977286b4", "filename": "src/test/ui/suggestions/dont-suggest-doc-hidden-variant-for-enum/hidden-parent.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e33cc71a61c91e1d510bf283e9d345067e64eed2/src%2Ftest%2Fui%2Fsuggestions%2Fdont-suggest-doc-hidden-variant-for-enum%2Fhidden-parent.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e33cc71a61c91e1d510bf283e9d345067e64eed2/src%2Ftest%2Fui%2Fsuggestions%2Fdont-suggest-doc-hidden-variant-for-enum%2Fhidden-parent.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fdont-suggest-doc-hidden-variant-for-enum%2Fhidden-parent.rs?ref=e33cc71a61c91e1d510bf283e9d345067e64eed2", "patch": "@@ -0,0 +1,7 @@\n+// aux-build:hidden-parent.rs\n+\n+extern crate hidden_parent;\n+\n+fn main() {\n+    let x: Option<i32> = 1i32; //~ ERROR mismatched types\n+}"}, {"sha": "d92b8127910141c9a703d6afd543a1148dfa8773", "filename": "src/test/ui/suggestions/dont-suggest-doc-hidden-variant-for-enum/hidden-parent.stderr", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/e33cc71a61c91e1d510bf283e9d345067e64eed2/src%2Ftest%2Fui%2Fsuggestions%2Fdont-suggest-doc-hidden-variant-for-enum%2Fhidden-parent.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e33cc71a61c91e1d510bf283e9d345067e64eed2/src%2Ftest%2Fui%2Fsuggestions%2Fdont-suggest-doc-hidden-variant-for-enum%2Fhidden-parent.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fdont-suggest-doc-hidden-variant-for-enum%2Fhidden-parent.stderr?ref=e33cc71a61c91e1d510bf283e9d345067e64eed2", "patch": "@@ -0,0 +1,18 @@\n+error[E0308]: mismatched types\n+  --> $DIR/hidden-parent.rs:6:26\n+   |\n+LL |     let x: Option<i32> = 1i32;\n+   |            -----------   ^^^^ expected enum `Option`, found `i32`\n+   |            |\n+   |            expected due to this\n+   |\n+   = note: expected enum `Option<i32>`\n+              found type `i32`\n+help: try wrapping the expression in `Some`\n+   |\n+LL |     let x: Option<i32> = Some(1i32);\n+   |                          +++++    +\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0308`."}]}