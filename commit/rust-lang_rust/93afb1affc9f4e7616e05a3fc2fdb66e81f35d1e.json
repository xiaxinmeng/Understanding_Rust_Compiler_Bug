{"sha": "93afb1affc9f4e7616e05a3fc2fdb66e81f35d1e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkzYWZiMWFmZmM5ZjRlNzYxNmUwNWEzZmMyZmRiNjZlODFmMzVkMWU=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-12-10T15:23:45Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-12-20T19:04:52Z"}, "message": "connect NLL type checker to the impl trait code\n\nWe now add the suitable `impl Trait` constraints.", "tree": {"sha": "2c2364727393a6c76b90666c4aa7c2051871dea0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2c2364727393a6c76b90666c4aa7c2051871dea0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/93afb1affc9f4e7616e05a3fc2fdb66e81f35d1e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/93afb1affc9f4e7616e05a3fc2fdb66e81f35d1e", "html_url": "https://github.com/rust-lang/rust/commit/93afb1affc9f4e7616e05a3fc2fdb66e81f35d1e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/93afb1affc9f4e7616e05a3fc2fdb66e81f35d1e/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "da63aaa7ab71ad5ba75340f3719591f370b847e2", "url": "https://api.github.com/repos/rust-lang/rust/commits/da63aaa7ab71ad5ba75340f3719591f370b847e2", "html_url": "https://github.com/rust-lang/rust/commit/da63aaa7ab71ad5ba75340f3719591f370b847e2"}], "stats": {"total": 377, "additions": 339, "deletions": 38}, "files": [{"sha": "a3d236ac1b6cd32746c8deab225dc8c7ce1a7eb1", "filename": "src/librustc/infer/anon_types/mod.rs", "status": "modified", "additions": 42, "deletions": 5, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/93afb1affc9f4e7616e05a3fc2fdb66e81f35d1e/src%2Flibrustc%2Finfer%2Fanon_types%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93afb1affc9f4e7616e05a3fc2fdb66e81f35d1e/src%2Flibrustc%2Finfer%2Fanon_types%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fanon_types%2Fmod.rs?ref=93afb1affc9f4e7616e05a3fc2fdb66e81f35d1e", "patch": "@@ -93,20 +93,34 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     /// Moreover, it returns a `AnonTypeMap` that would map `?0` to\n     /// info about the `impl Iterator<..>` type and `?1` to info about\n     /// the `impl Debug` type.\n+    ///\n+    /// # Parameters\n+    ///\n+    /// - `parent_def_id` -- we will only instantiate anonymous types\n+    ///   with this parent. This is typically the def-id of the function\n+    ///   in whose return type anon types are being instantiated.\n+    /// - `body_id` -- the body-id with which the resulting obligations should\n+    ///   be associated\n+    /// - `param_env` -- the in-scope parameter environment to be used for\n+    ///   obligations\n+    /// - `value` -- the value within which we are instantiating anon types\n     pub fn instantiate_anon_types<T: TypeFoldable<'tcx>>(\n         &self,\n+        parent_def_id: DefId,\n         body_id: ast::NodeId,\n         param_env: ty::ParamEnv<'tcx>,\n         value: &T,\n     ) -> InferOk<'tcx, (T, AnonTypeMap<'tcx>)> {\n         debug!(\n-            \"instantiate_anon_types(value={:?}, body_id={:?}, param_env={:?})\",\n+            \"instantiate_anon_types(value={:?}, parent_def_id={:?}, body_id={:?}, param_env={:?})\",\n             value,\n+            parent_def_id,\n             body_id,\n             param_env,\n         );\n         let mut instantiator = Instantiator {\n             infcx: self,\n+            parent_def_id,\n             body_id,\n             param_env,\n             anon_types: DefIdMap(),\n@@ -480,6 +494,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n \n struct Instantiator<'a, 'gcx: 'tcx, 'tcx: 'a> {\n     infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n+    parent_def_id: DefId,\n     body_id: ast::NodeId,\n     param_env: ty::ParamEnv<'tcx>,\n     anon_types: AnonTypeMap<'tcx>,\n@@ -489,11 +504,33 @@ struct Instantiator<'a, 'gcx: 'tcx, 'tcx: 'a> {\n impl<'a, 'gcx, 'tcx> Instantiator<'a, 'gcx, 'tcx> {\n     fn instantiate_anon_types_in_map<T: TypeFoldable<'tcx>>(&mut self, value: &T) -> T {\n         debug!(\"instantiate_anon_types_in_map(value={:?})\", value);\n+        let tcx = self.infcx.tcx;\n         value.fold_with(&mut BottomUpFolder {\n-            tcx: self.infcx.tcx,\n-            fldop: |ty| if let ty::TyAnon(def_id, substs) = ty.sty {\n-                self.fold_anon_ty(ty, def_id, substs)\n-            } else {\n+            tcx,\n+            fldop: |ty| {\n+                if let ty::TyAnon(def_id, substs) = ty.sty {\n+                    // Check that this is `impl Trait` type is declared by\n+                    // `parent_def_id`. During the first phase of type-check, this\n+                    // is true, but during NLL type-check, we sometimes encounter\n+                    // `impl Trait` types in e.g. inferred closure signatures that\n+                    // are not 'local' to the current function and hence which\n+                    // ought not to be instantiated.\n+                    if let Some(anon_node_id) = tcx.hir.as_local_node_id(def_id) {\n+                        let anon_parent_node_id = tcx.hir.get_parent(anon_node_id);\n+                        let anon_parent_def_id = tcx.hir.local_def_id(anon_parent_node_id);\n+                        if self.parent_def_id == anon_parent_def_id {\n+                            return self.fold_anon_ty(ty, def_id, substs);\n+                        }\n+\n+                        debug!(\"instantiate_anon_types_in_map: \\\n+                                encountered anon with wrong parent \\\n+                                def_id={:?} \\\n+                                anon_parent_def_id={:?}\",\n+                               def_id,\n+                               anon_parent_def_id);\n+                    }\n+                }\n+\n                 ty\n             },\n         })"}, {"sha": "51841836698ebbe8e837950bded19eb61566ecc9", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/93afb1affc9f4e7616e05a3fc2fdb66e81f35d1e/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93afb1affc9f4e7616e05a3fc2fdb66e81f35d1e/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=93afb1affc9f4e7616e05a3fc2fdb66e81f35d1e", "patch": "@@ -865,13 +865,17 @@ impl fmt::Debug for ty::RegionVid {\n define_print! {\n     () ty::InferTy, (self, f, cx) {\n         display {\n-            match *self {\n-                ty::TyVar(_) => write!(f, \"_\"),\n-                ty::IntVar(_) => write!(f, \"{}\", \"{integer}\"),\n-                ty::FloatVar(_) => write!(f, \"{}\", \"{float}\"),\n-                ty::FreshTy(v) => write!(f, \"FreshTy({})\", v),\n-                ty::FreshIntTy(v) => write!(f, \"FreshIntTy({})\", v),\n-                ty::FreshFloatTy(v) => write!(f, \"FreshFloatTy({})\", v)\n+            if cx.is_verbose {\n+                print!(f, cx, print_debug(self))\n+            } else {\n+                match *self {\n+                    ty::TyVar(_) => write!(f, \"_\"),\n+                    ty::IntVar(_) => write!(f, \"{}\", \"{integer}\"),\n+                    ty::FloatVar(_) => write!(f, \"{}\", \"{float}\"),\n+                    ty::FreshTy(v) => write!(f, \"FreshTy({})\", v),\n+                    ty::FreshIntTy(v) => write!(f, \"FreshIntTy({})\", v),\n+                    ty::FreshFloatTy(v) => write!(f, \"FreshFloatTy({})\", v)\n+                }\n             }\n         }\n         debug {"}, {"sha": "98a74f06703d3e630d0172f24af1e079cfe86f9f", "filename": "src/librustc_mir/borrow_check/nll/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/93afb1affc9f4e7616e05a3fc2fdb66e81f35d1e/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93afb1affc9f4e7616e05a3fc2fdb66e81f35d1e/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs?ref=93afb1affc9f4e7616e05a3fc2fdb66e81f35d1e", "patch": "@@ -77,13 +77,12 @@ pub(in borrow_check) fn compute_regions<'cx, 'gcx, 'tcx>(\n     Option<ClosureRegionRequirements<'gcx>>,\n ) {\n     // Run the MIR type-checker.\n-    let mir_node_id = infcx.tcx.hir.as_local_node_id(def_id).unwrap();\n     let liveness = &LivenessResults::compute(mir);\n     let constraint_sets = &type_check::type_check(\n         infcx,\n-        mir_node_id,\n         param_env,\n         mir,\n+        def_id,\n         &universal_regions,\n         &liveness,\n         flow_inits,"}, {"sha": "6f3e6cb1ec512abb934e9cb0f3e5e116c6ad5ce7", "filename": "src/librustc_mir/borrow_check/nll/region_infer/mod.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/93afb1affc9f4e7616e05a3fc2fdb66e81f35d1e/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93afb1affc9f4e7616e05a3fc2fdb66e81f35d1e/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs?ref=93afb1affc9f4e7616e05a3fc2fdb66e81f35d1e", "patch": "@@ -246,13 +246,15 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             .map(|origin| RegionDefinition::new(origin))\n             .collect();\n \n+        let nll_dump_cause = ty::tls::with(|tcx| tcx.sess.opts.debugging_opts.nll_dump_cause);\n+\n         let mut result = Self {\n             definitions,\n             elements: elements.clone(),\n             liveness_constraints: RegionValues::new(\n                 elements,\n                 num_region_variables,\n-                TrackCauses(true),\n+                TrackCauses(nll_dump_cause),\n             ),\n             inferred_values: None,\n             constraints: Vec::new(),"}, {"sha": "4aee48b979d6150541087aef8e85d8ba65a0ebd4", "filename": "src/librustc_mir/borrow_check/nll/renumber.rs", "status": "modified", "additions": 22, "deletions": 12, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/93afb1affc9f4e7616e05a3fc2fdb66e81f35d1e/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Frenumber.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93afb1affc9f4e7616e05a3fc2fdb66e81f35d1e/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Frenumber.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Frenumber.rs?ref=93afb1affc9f4e7616e05a3fc2fdb66e81f35d1e", "patch": "@@ -16,34 +16,44 @@ use rustc::infer::{InferCtxt, NLLRegionVariableOrigin};\n \n /// Replaces all free regions appearing in the MIR with fresh\n /// inference variables, returning the number of variables created.\n-pub fn renumber_mir<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>, mir: &mut Mir<'tcx>) {\n+pub fn renumber_mir<'tcx>(infcx: &InferCtxt<'_, '_, 'tcx>, mir: &mut Mir<'tcx>) {\n     debug!(\"renumber_mir()\");\n     debug!(\"renumber_mir: mir.arg_count={:?}\", mir.arg_count);\n \n     let mut visitor = NLLVisitor { infcx };\n     visitor.visit_mir(mir);\n }\n \n+/// Replaces all regions appearing in `value` with fresh inference\n+/// variables.\n+pub fn renumber_regions<'tcx, T>(\n+    infcx: &InferCtxt<'_, '_, 'tcx>,\n+    ty_context: TyContext,\n+    value: &T,\n+) -> T\n+where\n+    T: TypeFoldable<'tcx>,\n+{\n+    debug!(\"renumber_regions(value={:?})\", value);\n+\n+    infcx\n+        .tcx\n+        .fold_regions(value, &mut false, |_region, _depth| {\n+            let origin = NLLRegionVariableOrigin::Inferred(ty_context);\n+            infcx.next_nll_region_var(origin)\n+        })\n+}\n+\n struct NLLVisitor<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n     infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n }\n \n impl<'a, 'gcx, 'tcx> NLLVisitor<'a, 'gcx, 'tcx> {\n-    /// Replaces all regions appearing in `value` with fresh inference\n-    /// variables. This is what we do for almost the entire MIR, with\n-    /// the exception of the declared types of our arguments.\n     fn renumber_regions<T>(&mut self, ty_context: TyContext, value: &T) -> T\n     where\n         T: TypeFoldable<'tcx>,\n     {\n-        debug!(\"renumber_regions(value={:?})\", value);\n-\n-        self.infcx\n-            .tcx\n-            .fold_regions(value, &mut false, |_region, _depth| {\n-                let origin = NLLRegionVariableOrigin::Inferred(ty_context);\n-                self.infcx.next_nll_region_var(origin)\n-            })\n+        renumber_regions(self.infcx, ty_context, value)\n     }\n }\n "}, {"sha": "4db8e3c793dc401ddd31f554d2af05d33b566aad", "filename": "src/librustc_mir/borrow_check/nll/type_check/input_output.rs", "status": "modified", "additions": 107, "deletions": 2, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/93afb1affc9f4e7616e05a3fc2fdb66e81f35d1e/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Finput_output.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93afb1affc9f4e7616e05a3fc2fdb66e81f35d1e/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Finput_output.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Finput_output.rs?ref=93afb1affc9f4e7616e05a3fc2fdb66e81f35d1e", "patch": "@@ -17,9 +17,15 @@\n //! `RETURN_PLACE` the MIR arguments) are always fully normalize (and\n //! contain revealed `impl Trait` values).\n \n+use borrow_check::nll::renumber;\n use borrow_check::nll::universal_regions::UniversalRegions;\n+use rustc::hir::def_id::DefId;\n+use rustc::infer::InferOk;\n use rustc::ty::Ty;\n+use rustc::ty::subst::Subst;\n use rustc::mir::*;\n+use rustc::mir::visit::TyContext;\n+use rustc::traits::PredicateObligations;\n \n use rustc_data_structures::indexed_vec::Idx;\n \n@@ -29,13 +35,17 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n     pub(super) fn equate_inputs_and_outputs(\n         &mut self,\n         mir: &Mir<'tcx>,\n+        mir_def_id: DefId,\n         universal_regions: &UniversalRegions<'tcx>,\n     ) {\n+        let tcx = self.infcx.tcx;\n+\n         let &UniversalRegions {\n             unnormalized_output_ty,\n             unnormalized_input_tys,\n             ..\n         } = universal_regions;\n+        let infcx = self.infcx;\n \n         let start_position = Location {\n             block: START_BLOCK,\n@@ -52,10 +62,88 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n \n         // Return types are a bit more complex. They may contain existential `impl Trait`\n         // types.\n-\n+        debug!(\n+            \"equate_inputs_and_outputs: unnormalized_output_ty={:?}\",\n+            unnormalized_output_ty\n+        );\n         let output_ty = self.normalize(&unnormalized_output_ty, start_position);\n+        debug!(\n+            \"equate_inputs_and_outputs: normalized output_ty={:?}\",\n+            output_ty\n+        );\n         let mir_output_ty = mir.local_decls[RETURN_PLACE].ty;\n-        self.equate_normalized_input_or_output(start_position, output_ty, mir_output_ty);\n+        let anon_type_map = self.fully_perform_op(start_position.at_self(), |cx| {\n+            let mut obligations = ObligationAccumulator::default();\n+\n+            let (output_ty, anon_type_map) = obligations.add(infcx.instantiate_anon_types(\n+                mir_def_id,\n+                cx.body_id,\n+                cx.param_env,\n+                &output_ty,\n+            ));\n+            debug!(\n+                \"equate_inputs_and_outputs: instantiated output_ty={:?}\",\n+                output_ty\n+            );\n+            debug!(\n+                \"equate_inputs_and_outputs: anon_type_map={:#?}\",\n+                anon_type_map\n+            );\n+\n+            debug!(\n+                \"equate_inputs_and_outputs: mir_output_ty={:?}\",\n+                mir_output_ty\n+            );\n+            obligations.add(infcx\n+                .at(&cx.misc(cx.last_span), cx.param_env)\n+                .eq(output_ty, mir_output_ty)?);\n+\n+            for (&anon_def_id, anon_decl) in &anon_type_map {\n+                let anon_defn_ty = tcx.type_of(anon_def_id);\n+                let anon_defn_ty = anon_defn_ty.subst(tcx, anon_decl.substs);\n+                let anon_defn_ty = renumber::renumber_regions(\n+                    cx.infcx,\n+                    TyContext::Location(start_position),\n+                    &anon_defn_ty,\n+                );\n+                debug!(\n+                    \"equate_inputs_and_outputs: concrete_ty={:?}\",\n+                    anon_decl.concrete_ty\n+                );\n+                debug!(\"equate_inputs_and_outputs: anon_defn_ty={:?}\", anon_defn_ty);\n+                obligations.add(infcx\n+                    .at(&cx.misc(cx.last_span), cx.param_env)\n+                    .eq(anon_decl.concrete_ty, anon_defn_ty)?);\n+            }\n+\n+            debug!(\"equate_inputs_and_outputs: equated\");\n+\n+            Ok(InferOk {\n+                value: Some(anon_type_map),\n+                obligations: obligations.into_vec(),\n+            })\n+        }).unwrap_or_else(|terr| {\n+                span_mirbug!(\n+                    self,\n+                    start_position,\n+                    \"equate_inputs_and_outputs: `{:?}=={:?}` failed with `{:?}`\",\n+                    output_ty,\n+                    mir_output_ty,\n+                    terr\n+                );\n+                None\n+            });\n+\n+        // Finally\n+        if let Some(anon_type_map) = anon_type_map {\n+            self.fully_perform_op(start_position.at_self(), |_cx| {\n+                infcx.constrain_anon_types(&anon_type_map, universal_regions);\n+                Ok(InferOk {\n+                    value: (),\n+                    obligations: vec![],\n+                })\n+            }).unwrap();\n+        }\n     }\n \n     fn equate_normalized_input_or_output(&mut self, location: Location, a: Ty<'tcx>, b: Ty<'tcx>) {\n@@ -73,3 +161,20 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         }\n     }\n }\n+\n+#[derive(Debug, Default)]\n+struct ObligationAccumulator<'tcx> {\n+    obligations: PredicateObligations<'tcx>,\n+}\n+\n+impl<'tcx> ObligationAccumulator<'tcx> {\n+    fn add<T>(&mut self, value: InferOk<'tcx, T>) -> T {\n+        let InferOk { value, obligations } = value;\n+        self.obligations.extend(obligations);\n+        value\n+    }\n+\n+    fn into_vec(self) -> PredicateObligations<'tcx> {\n+        self.obligations\n+    }\n+}"}, {"sha": "4c8a171299f2c84c7845436c77d661616e157a8c", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/93afb1affc9f4e7616e05a3fc2fdb66e81f35d1e/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93afb1affc9f4e7616e05a3fc2fdb66e81f35d1e/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=93afb1affc9f4e7616e05a3fc2fdb66e81f35d1e", "patch": "@@ -17,6 +17,7 @@ use borrow_check::nll::universal_regions::UniversalRegions;\n use dataflow::FlowAtLocation;\n use dataflow::MaybeInitializedLvals;\n use dataflow::move_paths::MoveData;\n+use rustc::hir::def_id::DefId;\n use rustc::infer::{InferCtxt, InferOk, InferResult, LateBoundRegionConversionTime, UnitResult};\n use rustc::infer::region_constraints::{GenericKind, RegionConstraintData};\n use rustc::traits::{self, FulfillmentContext};\n@@ -77,9 +78,9 @@ mod input_output;\n /// # Parameters\n ///\n /// - `infcx` -- inference context to use\n-/// - `body_id` -- body-id of the MIR being checked\n /// - `param_env` -- parameter environment to use for trait solving\n /// - `mir` -- MIR to type-check\n+/// - `mir_def_id` -- DefId from which the MIR is derived (must be local)\n /// - `region_bound_pairs` -- the implied outlives obligations between type parameters\n ///   and lifetimes (e.g., `&'a T` implies `T: 'a`)\n /// - `implicit_region_bound` -- a region which all generic parameters are assumed\n@@ -94,14 +95,15 @@ mod input_output;\n /// - `move_data` -- move-data constructed when performing the maybe-init dataflow analysis\n pub(crate) fn type_check<'gcx, 'tcx>(\n     infcx: &InferCtxt<'_, 'gcx, 'tcx>,\n-    body_id: ast::NodeId,\n     param_env: ty::ParamEnv<'gcx>,\n     mir: &Mir<'tcx>,\n+    mir_def_id: DefId,\n     universal_regions: &UniversalRegions<'tcx>,\n     liveness: &LivenessResults,\n     flow_inits: &mut FlowAtLocation<MaybeInitializedLvals<'_, 'gcx, 'tcx>>,\n     move_data: &MoveData<'tcx>,\n ) -> MirTypeckRegionConstraints<'tcx> {\n+    let body_id = infcx.tcx.hir.as_local_node_id(mir_def_id).unwrap();\n     let implicit_region_bound = infcx.tcx.mk_region(ty::ReVar(universal_regions.fr_fn_body));\n     type_check_internal(\n         infcx,\n@@ -113,7 +115,7 @@ pub(crate) fn type_check<'gcx, 'tcx>(\n         &mut |cx| {\n             liveness::generate(cx, mir, liveness, flow_inits, move_data);\n \n-            cx.equate_inputs_and_outputs(mir, universal_regions);\n+            cx.equate_inputs_and_outputs(mir, mir_def_id, universal_regions);\n         },\n     )\n }"}, {"sha": "6eca1b0a14609560fd131ed549f41cb7e60186fe", "filename": "src/librustc_mir/borrow_check/nll/universal_regions.rs", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/93afb1affc9f4e7616e05a3fc2fdb66e81f35d1e/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Funiversal_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93afb1affc9f4e7616e05a3fc2fdb66e81f35d1e/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Funiversal_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Funiversal_regions.rs?ref=93afb1affc9f4e7616e05a3fc2fdb66e81f35d1e", "patch": "@@ -27,6 +27,7 @@ use rustc::hir::def_id::DefId;\n use rustc::infer::{InferCtxt, NLLRegionVariableOrigin};\n use rustc::infer::region_constraints::GenericKind;\n use rustc::infer::outlives::bounds::{self, OutlivesBound};\n+use rustc::infer::outlives::free_region_map::FreeRegionRelations;\n use rustc::ty::{self, RegionVid, Ty, TyCtxt};\n use rustc::ty::fold::TypeFoldable;\n use rustc::ty::subst::Substs;\n@@ -484,9 +485,6 @@ impl<'cx, 'gcx, 'tcx> UniversalRegionsBuilder<'cx, 'gcx, 'tcx> {\n         let (unnormalized_output_ty, unnormalized_input_tys) =\n             inputs_and_output.split_last().unwrap();\n \n-        // we should not have created any more variables\n-        assert_eq!(self.infcx.num_region_vars(), num_universals);\n-\n         debug!(\n             \"build: global regions = {}..{}\",\n             FIRST_GLOBAL_INDEX,\n@@ -793,3 +791,16 @@ impl<'tcx> UniversalRegionIndices<'tcx> {\n         })\n     }\n }\n+\n+/// This trait is used by the `impl-trait` constraint code to abstract\n+/// over the `FreeRegionMap` from lexical regions and\n+/// `UniversalRegions` (from NLL)`.\n+impl<'tcx> FreeRegionRelations<'tcx> for UniversalRegions<'tcx> {\n+    fn sub_free_regions(&self, shorter: ty::Region<'tcx>, longer: ty::Region<'tcx>) -> bool {\n+        let shorter = shorter.to_region_vid();\n+        assert!(self.is_universal_region(shorter));\n+        let longer = longer.to_region_vid();\n+        assert!(self.is_universal_region(longer));\n+        self.outlives(longer, shorter)\n+    }\n+}"}, {"sha": "14296e78ddd1c6c2fa55777c4a2072f85beac2a9", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/93afb1affc9f4e7616e05a3fc2fdb66e81f35d1e/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93afb1affc9f4e7616e05a3fc2fdb66e81f35d1e/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=93afb1affc9f4e7616e05a3fc2fdb66e81f35d1e", "patch": "@@ -985,7 +985,7 @@ fn check_fn<'a, 'gcx, 'tcx>(inherited: &'a Inherited<'a, 'gcx, 'tcx>,\n \n     let ret_ty = fn_sig.output();\n     fcx.require_type_is_sized(ret_ty, decl.output.span(), traits::SizedReturnType);\n-    let ret_ty = fcx.instantiate_anon_types_from_return_value(&ret_ty);\n+    let ret_ty = fcx.instantiate_anon_types_from_return_value(fn_id, &ret_ty);\n     fcx.ret_coercion = Some(RefCell::new(CoerceMany::new(ret_ty)));\n     fn_sig = fcx.tcx.mk_fn_sig(\n         fn_sig.inputs().iter().cloned(),\n@@ -1880,11 +1880,21 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     /// function with type variables and records the `AnonTypeMap` for\n     /// later use during writeback. See\n     /// `InferCtxt::instantiate_anon_types` for more details.\n-    fn instantiate_anon_types_from_return_value<T: TypeFoldable<'tcx>>(&self, value: &T) -> T {\n-        debug!(\"instantiate_anon_types_from_return_value(value={:?})\", value);\n+    fn instantiate_anon_types_from_return_value<T: TypeFoldable<'tcx>>(\n+        &self,\n+        fn_id: ast::NodeId,\n+        value: &T,\n+    ) -> T {\n+        let fn_def_id = self.tcx.hir.local_def_id(fn_id);\n+        debug!(\n+            \"instantiate_anon_types_from_return_value(fn_def_id={:?}, value={:?})\",\n+            fn_def_id,\n+            value\n+        );\n \n         let (value, anon_type_map) = self.register_infer_ok_obligations(\n             self.instantiate_anon_types(\n+                fn_def_id,\n                 self.body_id,\n                 self.param_env,\n                 value,"}, {"sha": "8d035bafab78d6df6bf4184f0a0b213df76782fc", "filename": "src/test/run-pass/impl-trait/example-calendar.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/93afb1affc9f4e7616e05a3fc2fdb66e81f35d1e/src%2Ftest%2Frun-pass%2Fimpl-trait%2Fexample-calendar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93afb1affc9f4e7616e05a3fc2fdb66e81f35d1e/src%2Ftest%2Frun-pass%2Fimpl-trait%2Fexample-calendar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fimpl-trait%2Fexample-calendar.rs?ref=93afb1affc9f4e7616e05a3fc2fdb66e81f35d1e", "patch": "@@ -8,6 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// revisions: normal nll\n+//[nll] compile-flags: -Znll -Zborrowck=mir\n+\n #![feature(conservative_impl_trait,\n            universal_impl_trait,\n            fn_traits,"}, {"sha": "896b74b579b60143334620f76f350777e28287d8", "filename": "src/test/ui/nll/ty-outlives/impl-trait-captures.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/93afb1affc9f4e7616e05a3fc2fdb66e81f35d1e/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fimpl-trait-captures.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93afb1affc9f4e7616e05a3fc2fdb66e81f35d1e/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fimpl-trait-captures.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fimpl-trait-captures.rs?ref=93afb1affc9f4e7616e05a3fc2fdb66e81f35d1e", "patch": "@@ -0,0 +1,27 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags:-Znll -Zborrowck=mir -Zverbose\n+\n+#![allow(warnings)]\n+#![feature(conservative_impl_trait)]\n+\n+trait Foo<'a> {\n+}\n+\n+impl<'a, T> Foo<'a> for T { }\n+\n+fn foo<'a, T>(x: &T) -> impl Foo<'a> {\n+    x\n+        //~^ WARNING not reporting region error due to -Znll\n+        //~| ERROR free region `'_#2r` does not outlive free region `ReEarlyBound(0, 'a)`\n+}\n+\n+fn main() {}"}, {"sha": "7de994dae888d9b1fe1d1f141d46596c4d639833", "filename": "src/test/ui/nll/ty-outlives/impl-trait-captures.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/93afb1affc9f4e7616e05a3fc2fdb66e81f35d1e/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fimpl-trait-captures.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/93afb1affc9f4e7616e05a3fc2fdb66e81f35d1e/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fimpl-trait-captures.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fimpl-trait-captures.stderr?ref=93afb1affc9f4e7616e05a3fc2fdb66e81f35d1e", "patch": "@@ -0,0 +1,14 @@\n+warning: not reporting region error due to -Znll\n+  --> $DIR/impl-trait-captures.rs:22:5\n+   |\n+22 |     x\n+   |     ^\n+\n+error: free region `'_#2r` does not outlive free region `ReEarlyBound(0, 'a)`\n+  --> $DIR/impl-trait-captures.rs:22:5\n+   |\n+22 |     x\n+   |     ^\n+\n+error: aborting due to previous error\n+"}, {"sha": "c03ec839808bb42f9de1483203a1aa889cd08ff4", "filename": "src/test/ui/nll/ty-outlives/impl-trait-outlives.rs", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/93afb1affc9f4e7616e05a3fc2fdb66e81f35d1e/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fimpl-trait-outlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93afb1affc9f4e7616e05a3fc2fdb66e81f35d1e/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fimpl-trait-outlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fimpl-trait-outlives.rs?ref=93afb1affc9f4e7616e05a3fc2fdb66e81f35d1e", "patch": "@@ -0,0 +1,51 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags:-Znll -Zborrowck=mir -Zverbose\n+\n+#![allow(warnings)]\n+#![feature(conservative_impl_trait)]\n+\n+use std::fmt::Debug;\n+\n+fn no_region<'a, T>(x: Box<T>) -> impl Debug + 'a\n+    //~^ WARNING not reporting region error due to -Znll\n+where\n+    T: Debug,\n+{\n+    x\n+    //~^ ERROR `T` does not outlive\n+}\n+\n+fn correct_region<'a, T>(x: Box<T>) -> impl Debug + 'a\n+where\n+    T: 'a + Debug,\n+{\n+    x\n+}\n+\n+fn wrong_region<'a, 'b, T>(x: Box<T>) -> impl Debug + 'a\n+    //~^ WARNING not reporting region error due to -Znll\n+where\n+    T: 'b + Debug,\n+{\n+    x\n+    //~^ ERROR `T` does not outlive\n+}\n+\n+fn outlives_region<'a, 'b, T>(x: Box<T>) -> impl Debug + 'a\n+where\n+    T: 'b + Debug,\n+    'b: 'a,\n+{\n+    x\n+}\n+\n+fn main() {}"}, {"sha": "4ebd2c7fc434664cd53f8fb7cd40335b3d182a33", "filename": "src/test/ui/nll/ty-outlives/impl-trait-outlives.stderr", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/93afb1affc9f4e7616e05a3fc2fdb66e81f35d1e/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fimpl-trait-outlives.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/93afb1affc9f4e7616e05a3fc2fdb66e81f35d1e/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fimpl-trait-outlives.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fimpl-trait-outlives.stderr?ref=93afb1affc9f4e7616e05a3fc2fdb66e81f35d1e", "patch": "@@ -0,0 +1,26 @@\n+warning: not reporting region error due to -Znll\n+  --> $DIR/impl-trait-outlives.rs:18:35\n+   |\n+18 | fn no_region<'a, T>(x: Box<T>) -> impl Debug + 'a\n+   |                                   ^^^^^^^^^^^^^^^\n+\n+warning: not reporting region error due to -Znll\n+  --> $DIR/impl-trait-outlives.rs:34:42\n+   |\n+34 | fn wrong_region<'a, 'b, T>(x: Box<T>) -> impl Debug + 'a\n+   |                                          ^^^^^^^^^^^^^^^\n+\n+error: `T` does not outlive `'_#1r`\n+  --> $DIR/impl-trait-outlives.rs:23:5\n+   |\n+23 |     x\n+   |     ^\n+\n+error: `T` does not outlive `'_#1r`\n+  --> $DIR/impl-trait-outlives.rs:39:5\n+   |\n+39 |     x\n+   |     ^\n+\n+error: aborting due to 2 previous errors\n+"}]}