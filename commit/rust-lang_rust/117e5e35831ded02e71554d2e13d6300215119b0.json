{"sha": "117e5e35831ded02e71554d2e13d6300215119b0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjExN2U1ZTM1ODMxZGVkMDJlNzE1NTRkMmUxM2Q2MzAwMjE1MTE5YjA=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-11-01T22:16:46Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-11-24T14:53:39Z"}, "message": "Implement LUB algorithm and add new unit-testing infrastructure for infer.\n\nr=brson", "tree": {"sha": "de2eca3a7261d842b8d0608cdeb746ee7b31ef76", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/de2eca3a7261d842b8d0608cdeb746ee7b31ef76"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/117e5e35831ded02e71554d2e13d6300215119b0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/117e5e35831ded02e71554d2e13d6300215119b0", "html_url": "https://github.com/rust-lang/rust/commit/117e5e35831ded02e71554d2e13d6300215119b0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/117e5e35831ded02e71554d2e13d6300215119b0/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dc34fb9219d2d5c3f55175fb44404ba0f71976d1", "url": "https://api.github.com/repos/rust-lang/rust/commits/dc34fb9219d2d5c3f55175fb44404ba0f71976d1", "html_url": "https://github.com/rust-lang/rust/commit/dc34fb9219d2d5c3f55175fb44404ba0f71976d1"}], "stats": {"total": 846, "additions": 727, "deletions": 119}, "files": [{"sha": "864619f2759171cabb43a712c1afc8af7b9df0dc", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/117e5e35831ded02e71554d2e13d6300215119b0/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/117e5e35831ded02e71554d2e13d6300215119b0/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=117e5e35831ded02e71554d2e13d6300215119b0", "patch": "@@ -41,6 +41,7 @@ export expr_is_lval, expr_kind;\n export ExprKind, LvalueExpr, RvalueDatumExpr, RvalueDpsExpr, RvalueStmtExpr;\n export field_ty;\n export fold_ty, fold_sty_to_ty, fold_region, fold_regions;\n+export apply_op_on_t_to_ty_fn;\n export fold_regions_and_ty, walk_regions_and_ty;\n export field;\n export field_idx, field_idx_strict;\n@@ -1482,6 +1483,30 @@ fn fold_regions_and_ty(\n     }\n }\n \n+/* A little utility: it often happens that I have a `fn_ty`,\n+ * but I want to use some function like `fold_regions_and_ty()`\n+ * that is defined over all types.  This utility converts to\n+ * a full type and back.  It's not the best way to do this (somewhat\n+ * inefficient to do the conversion), it would be better to refactor\n+ * all this folding business.  However, I've been waiting on that\n+ * until trait support is improved. */\n+fn apply_op_on_t_to_ty_fn(\n+    cx: ctxt,\n+    f: &FnTy,\n+    t_op: fn(t) -> t) -> FnTy\n+{\n+    let t0 = ty::mk_fn(cx, *f);\n+    let t1 = t_op(t0);\n+    match ty::get(t1).sty {\n+        ty::ty_fn(copy f) => {\n+            move f\n+        }\n+        _ => {\n+            cx.sess.bug(~\"`t_op` did not return a function type\");\n+        }\n+    }\n+}\n+\n // n.b. this function is intended to eventually replace fold_region() below,\n // that is why its name is so similar.\n fn fold_regions("}, {"sha": "421c68fa9a21ee7add90dd267ec657af37cd23c4", "filename": "src/librustc/middle/typeck.rs", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/117e5e35831ded02e71554d2e13d6300215119b0/src%2Flibrustc%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/117e5e35831ded02e71554d2e13d6300215119b0/src%2Flibrustc%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck.rs?ref=117e5e35831ded02e71554d2e13d6300215119b0", "patch": "@@ -251,6 +251,29 @@ fn require_same_types(\n     }\n }\n \n+// a list of mapping from in-scope-region-names (\"isr\") to the\n+// corresponding ty::Region\n+type isr_alist = @List<(ty::bound_region, ty::Region)>;\n+\n+trait get_and_find_region {\n+    fn get(br: ty::bound_region) -> ty::Region;\n+    fn find(br: ty::bound_region) -> Option<ty::Region>;\n+}\n+\n+impl isr_alist: get_and_find_region {\n+    fn get(br: ty::bound_region) -> ty::Region {\n+        self.find(br).get()\n+    }\n+\n+    fn find(br: ty::bound_region) -> Option<ty::Region> {\n+        for list::each(self) |isr| {\n+            let (isr_br, isr_r) = *isr;\n+            if isr_br == br { return Some(isr_r); }\n+        }\n+        return None;\n+    }\n+}\n+\n fn arg_is_argv_ty(tcx: ty::ctxt, a: ty::arg) -> bool {\n     match ty::resolved_mode(tcx, a.mode) {\n         ast::by_val => { /*ok*/ }"}, {"sha": "ee93c7fccef9207c53617b9901aacab1b90b41dd", "filename": "src/librustc/middle/typeck/check.rs", "status": "modified", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/117e5e35831ded02e71554d2e13d6300215119b0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/117e5e35831ded02e71554d2e13d6300215119b0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck.rs?ref=117e5e35831ded02e71554d2e13d6300215119b0", "patch": "@@ -166,29 +166,6 @@ fn blank_fn_ctxt(ccx: @crate_ctxt, rty: ty::t,\n     }\n }\n \n-// a list of mapping from in-scope-region-names (\"isr\") to the\n-// corresponding ty::Region\n-type isr_alist = @List<(ty::bound_region, ty::Region)>;\n-\n-trait get_and_find_region {\n-    fn get(br: ty::bound_region) -> ty::Region;\n-    fn find(br: ty::bound_region) -> Option<ty::Region>;\n-}\n-\n-impl isr_alist: get_and_find_region {\n-    fn get(br: ty::bound_region) -> ty::Region {\n-        self.find(br).get()\n-    }\n-\n-    fn find(br: ty::bound_region) -> Option<ty::Region> {\n-        for list::each(self) |isr| {\n-            let (isr_br, isr_r) = *isr;\n-            if isr_br == br { return Some(isr_r); }\n-        }\n-        return None;\n-    }\n-}\n-\n fn check_item_types(ccx: @crate_ctxt, crate: @ast::crate) {\n     let visit = visit::mk_simple_visitor(@{\n         visit_item: |a| check_item(ccx, a),"}, {"sha": "b4ffd92c0a8cb5d37f790335936dbb91e1862fad", "filename": "src/librustc/middle/typeck/infer.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/117e5e35831ded02e71554d2e13d6300215119b0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/117e5e35831ded02e71554d2e13d6300215119b0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer.rs?ref=117e5e35831ded02e71554d2e13d6300215119b0", "patch": "@@ -722,5 +722,24 @@ impl infer_ctxt {\n         self.type_error_message(sp, mk_msg, a, Some(err));\n     }\n \n+    fn replace_bound_regions_with_fresh_regions(\n+        &self, span: span,\n+        fty: &ty::FnTy) -> (ty::FnTy, isr_alist)\n+    {\n+        let {fn_ty, isr, _} =\n+            replace_bound_regions_in_fn_ty(self.tcx, @Nil, None, fty, |br| {\n+                // N.B.: The name of the bound region doesn't have anything to\n+                // do with the region variable that's created for it.  The\n+                // only thing we're doing with `br` here is using it in the\n+                // debug message.\n+                let rvar = self.next_region_var_nb(span);\n+                debug!(\"Bound region %s maps to %?\",\n+                       bound_region_to_str(self.tcx, br),\n+                       rvar);\n+                rvar\n+            });\n+        (fn_ty, isr)\n+    }\n+\n }\n "}, {"sha": "10fc0db0f7b55deacacf878d461d5b7fb02d0c64", "filename": "src/librustc/middle/typeck/infer/combine.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/117e5e35831ded02e71554d2e13d6300215119b0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/117e5e35831ded02e71554d2e13d6300215119b0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs?ref=117e5e35831ded02e71554d2e13d6300215119b0", "patch": "@@ -290,7 +290,9 @@ fn super_args<C:combine>(\n \n fn super_vstores<C:combine>(\n     self: &C, vk: ty::terr_vstore_kind,\n-    a: ty::vstore, b: ty::vstore) -> cres<ty::vstore> {\n+    a: ty::vstore, b: ty::vstore) -> cres<ty::vstore>\n+{\n+    debug!(\"%s.super_vstores(a=%?, b=%?)\", self.tag(), a, b);\n \n     match (a, b) {\n       (ty::vstore_slice(a_r), ty::vstore_slice(b_r)) => {\n@@ -517,4 +519,3 @@ fn super_tys<C:combine>(\n       _ => Err(ty::terr_sorts(expected_found(self, a, b)))\n     }\n }\n-"}, {"sha": "8c3357190f7b6e97f90639e8744129a9d67543ef", "filename": "src/librustc/middle/typeck/infer/lub.rs", "status": "modified", "additions": 96, "deletions": 12, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/117e5e35831ded02e71554d2e13d6300215119b0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/117e5e35831ded02e71554d2e13d6300215119b0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs?ref=117e5e35831ded02e71554d2e13d6300215119b0", "patch": "@@ -3,6 +3,8 @@ use lattice::*;\n use to_str::ToStr;\n use syntax::ast::{Many, Once};\n \n+fn macros() { include!(\"macros.rs\"); } // FIXME(#3114): Macro import/export.\n+\n enum Lub = combine_fields;  // \"subtype\", \"subregion\" etc\n \n impl Lub: combine {\n@@ -102,6 +104,100 @@ impl Lub: combine {\n         }\n     }\n \n+    fn fns(a: &ty::FnTy, b: &ty::FnTy) -> cres<ty::FnTy> {\n+        // Note: this is a subtle algorithm.  For a full explanation,\n+        // please see the large comment in `region_inference.rs`.\n+\n+        // Take a snapshot.  We'll never roll this back, but in later\n+        // phases we do want to be able to examine \"all bindings that\n+        // were created as part of this type comparison\", and making a\n+        // snapshot is a convenient way to do that.\n+        let snapshot = self.infcx.region_vars.start_snapshot();\n+\n+        // Instantiate each bound region with a fresh region variable.\n+        let (a_with_fresh, a_isr) =\n+            self.infcx.replace_bound_regions_with_fresh_regions(\n+                self.span, a);\n+        let (b_with_fresh, _) =\n+            self.infcx.replace_bound_regions_with_fresh_regions(\n+                self.span, b);\n+\n+        // Collect constraints.\n+        let fn_ty0 = if_ok!(super_fns(&self, &a_with_fresh, &b_with_fresh));\n+        debug!(\"fn_ty0 = %s\", fn_ty0.to_str(self.infcx));\n+\n+        // Generalize the regions appearing in fn_ty0 if possible\n+        let new_vars =\n+            self.infcx.region_vars.vars_created_since_snapshot(snapshot);\n+        let fn_ty1 =\n+            ty::apply_op_on_t_to_ty_fn(\n+                self.infcx.tcx, &fn_ty0,\n+                |t| ty::fold_regions(\n+                    self.infcx.tcx, t,\n+                    |r, _in_fn| generalize_region(&self, snapshot,\n+                                                  new_vars, a_isr, r)));\n+        return Ok(move fn_ty1);\n+\n+        fn generalize_region(self: &Lub,\n+                             snapshot: uint,\n+                             new_vars: &[RegionVid],\n+                             a_isr: isr_alist,\n+                             r0: ty::Region) -> ty::Region {\n+            // Regions that pre-dated the LUB computation stay as they are.\n+            if !is_new_var(new_vars, r0) {\n+                debug!(\"generalize_region(r0=%?): not new variable\", r0);\n+                return r0;\n+            }\n+\n+            let tainted = self.infcx.region_vars.tainted(snapshot, r0);\n+\n+            // Variables created during LUB computation which are\n+            // *related* to regions that pre-date the LUB computation\n+            // stay as they are.\n+            if !tainted.all(|r| is_new_var(new_vars, *r)) {\n+                debug!(\"generalize_region(r0=%?): \\\n+                        non-new-variables found in %?\",\n+                       r0, tainted);\n+                return r0;\n+            }\n+\n+            // Otherwise, the variable must be associated with at\n+            // least one of the variables representing bound regions\n+            // in both A and B.  Replace the variable with the \"first\"\n+            // bound region from A that we find it to be associated\n+            // with.\n+            for list::each(a_isr) |pair| {\n+                let (a_br, a_r) = *pair;\n+                if tainted.contains(&a_r) {\n+                    debug!(\"generalize_region(r0=%?): \\\n+                            replacing with %?, tainted=%?\",\n+                           r0, a_br, tainted);\n+                    return ty::re_bound(a_br);\n+                }\n+            }\n+\n+            self.infcx.tcx.sess.span_bug(\n+                self.span,\n+                fmt!(\"Region %? is not associated with \\\n+                      any bound region from A!\", r0));\n+        }\n+\n+        fn is_new_var(new_vars: &[RegionVid], r: ty::Region) -> bool {\n+            match r {\n+                ty::re_infer(ty::ReVar(ref v)) => new_vars.contains(v),\n+                _ => false\n+            }\n+        }\n+    }\n+\n+    fn fn_metas(a: &ty::FnMeta, b: &ty::FnMeta) -> cres<ty::FnMeta> {\n+        super_fn_metas(&self, a, b)\n+    }\n+\n+    fn fn_sigs(a: &ty::FnSig, b: &ty::FnSig) -> cres<ty::FnSig> {\n+        super_fn_sigs(&self, a, b)\n+    }\n+\n     // Traits please (FIXME: #2794):\n \n     fn tys(a: ty::t, b: ty::t) -> cres<ty::t> {\n@@ -125,18 +221,6 @@ impl Lub: combine {\n         super_args(&self, a, b)\n     }\n \n-    fn fns(a: &ty::FnTy, b: &ty::FnTy) -> cres<ty::FnTy> {\n-        super_fns(&self, a, b)\n-    }\n-\n-    fn fn_metas(a: &ty::FnMeta, b: &ty::FnMeta) -> cres<ty::FnMeta> {\n-        super_fn_metas(&self, a, b)\n-    }\n-\n-    fn fn_sigs(a: &ty::FnSig, b: &ty::FnSig) -> cres<ty::FnSig> {\n-        super_fn_sigs(&self, a, b)\n-    }\n-\n     fn substs(did: ast::def_id,\n               as_: &ty::substs,\n               bs: &ty::substs) -> cres<ty::substs> {"}, {"sha": "923e29cf8632a391818c5b095285edddd4114e90", "filename": "src/librustc/middle/typeck/infer/region_inference.rs", "status": "modified", "additions": 221, "deletions": 51, "changes": 272, "blob_url": "https://github.com/rust-lang/rust/blob/117e5e35831ded02e71554d2e13d6300215119b0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/117e5e35831ded02e71554d2e13d6300215119b0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference.rs?ref=117e5e35831ded02e71554d2e13d6300215119b0", "patch": "@@ -320,6 +320,124 @@ set of all things reachable from a skolemized variable `x`.\n step at which the skolemization was performed.  So this case here\n would fail because `&x` was created alone, but is relatable to `&A`.\n \n+## Computing the LUB and GLB\n+\n+The paper I pointed you at is written for Haskell.  It does not\n+therefore considering subtyping and in particular does not consider\n+LUB or GLB computation.  We have to consider this.  Here is the\n+algorithm I implemented.\n+\n+### LUB\n+\n+The LUB algorithm proceeds in three steps:\n+\n+1. Replace all bound regions (on both sides) with fresh region\n+   inference variables.\n+2. Compute the LUB \"as normal\", meaning compute the GLB of each\n+   pair of argument types and the LUB of the return types and\n+   so forth.  Combine those to a new function type F.\n+3. Map the regions appearing in `F` using the procedure described below.\n+\n+For each region `R` that appears in `F`, we may need to replace it\n+with a bound region.  Let `V` be the set of fresh variables created as\n+part of the LUB procedure (either in step 1 or step 2).  You may be\n+wondering how variables can be created in step 2.  The answer is that\n+when we are asked to compute the LUB or GLB of two region variables,\n+we do so by producing a new region variable that is related to those\n+two variables.  i.e., The LUB of two variables `$x` and `$y` is a\n+fresh variable `$z` that is constrained such that `$x <= $z` and `$y\n+<= $z`.\n+\n+To decide how to replace a region `R`, we must examine `Tainted(R)`.\n+This function searches through the constraints which were generated\n+when computing the bounds of all the argument and return types and\n+produces a list of all regions to which `R` is related, directly or\n+indirectly.\n+\n+If `R` is not in `V` or `Tainted(R)` contains any region that is not\n+in `V`, then `R` is not replaced (that is, `R` is mapped to itself).\n+Otherwise, if `Tainted(R)` is a subset of `V`, then we select the\n+earliest variable in `Tainted(R)` that originates from the left-hand\n+side and replace `R` with a bound version of that variable.\n+\n+So, let's work through the simplest example: `fn(&A)` and `fn(&a)`.\n+In this case, `&a` will be replaced with `$a` (the $ indicates an\n+inference variable) which will be linked to the free region `&A`, and\n+hence `V = { $a }` and `Tainted($a) = { &A }`.  Since `$a` is not a\n+member of `V`, we leave `$a` as is.  When region inference happens,\n+`$a` will be resolved to `&A`, as we wanted.\n+\n+So, let's work through the simplest example: `fn(&A)` and `fn(&a)`.\n+In this case, `&a` will be replaced with `$a` (the $ indicates an\n+inference variable) which will be linked to the free region `&A`, and\n+hence `V = { $a }` and `Tainted($a) = { $a, &A }`.  Since `&A` is not a\n+member of `V`, we leave `$a` as is.  When region inference happens,\n+`$a` will be resolved to `&A`, as we wanted.\n+\n+Let's look at a more complex one: `fn(&a, &b)` and `fn(&x, &x)`.\n+In this case, we'll end up with a graph that looks like:\n+\n+```\n+     $a        $b     *--$x\n+       \\        \\    /  /\n+        \\        $h-*  /\n+         $g-----------*\n+```\n+\n+Here `$g` and `$h` are fresh variables that are created to represent\n+the LUB/GLB of things requiring inference.  This means that `V` and\n+`Tainted` will look like:\n+\n+```\n+V = {$a, $b, $x}\n+Tainted($g) = Tainted($h) = { $a, $b, $h, $x }\n+```\n+\n+Therefore we replace both `$g` and `$h` with `$a`, and end up\n+with the type `fn(&a, &a)`.\n+\n+### GLB\n+\n+The procedure for computing the GLB is similar.  The difference lies\n+in computing the replacements for the various variables. For each\n+region `R` that appears in the type `F`, we again compute `Tainted(R)`\n+and examine the results:\n+\n+1. If `Tainted(R) = {R}` is a singleton set, replace `R` with itself.\n+2. Else, if `Tainted(R)` contains only variables in `V`, and it\n+   contains exactly one variable from the LHS and one variable from\n+   the RHS, then `R` can be mapped to the bound version of the\n+   variable from the LHS.\n+3. Else, `R` is mapped to a fresh bound variable.\n+\n+These rules are pretty complex.  Let's look at some examples to see\n+how they play out.\n+\n+Out first example was `fn(&a)` and `fn(&X)`---in\n+this case, the LUB will be a variable `$g`, and `Tainted($g) =\n+{$g,$a,$x}`.  By these rules, we'll replace `$g` with a fresh bound\n+variable, so the result is `fn(&z)`, which is fine.\n+\n+The next example is `fn(&A)` and `fn(&Z)`. XXX\n+\n+The next example is `fn(&a, &b)` and `fn(&x, &x)`. In this case, as\n+before, we'll end up with `F=fn(&g, &h)` where `Tainted($g) =\n+Tainted($h) = {$g, $a, $b, $x}`.  This means that we'll select fresh\n+bound varibales `g` and `h` and wind up with `fn(&g, &h)`.\n+\n+For the last example, let's consider what may seem trivial, but is\n+not: `fn(&a, &a)` and `fn(&x, &x)`.  In this case, we'll get `F=fn(&g,\n+&h)` where `Tainted($g) = {$g, $a, $x}` and `Tainted($h) = {$h, $a,\n+$x}`.  Both of these sets contain exactly one bound variable from each\n+side, so we'll map them both to `&a`, resulting in `fn(&a, &a)`.\n+Horray!\n+\n+### Why are these correct?\n+\n+You may be wondering whether this algorithm is correct.  So am I.  But\n+I believe it is.  (Justification forthcoming, haven't had time to\n+write it)\n+\n */\n \n #[warn(deprecated_mode)];\n@@ -448,7 +566,6 @@ type CombineMap = HashMap<TwoRegions, RegionVid>;\n struct RegionVarBindings {\n     tcx: ty::ctxt,\n     var_spans: DVec<span>,\n-    values: Cell<~[Region]>,\n     constraints: HashMap<Constraint, span>,\n     lubs: CombineMap,\n     glbs: CombineMap,\n@@ -462,7 +579,12 @@ struct RegionVarBindings {\n     // actively snapshotting.  The reason for this is that otherwise\n     // we end up adding entries for things like the lower bound on\n     // a variable and so forth, which can never be rolled back.\n-    mut undo_log: ~[UndoLogEntry]\n+    mut undo_log: ~[UndoLogEntry],\n+\n+    // This contains the results of inference.  It begins as an empty\n+    // cell and only acquires a value after inference is complete.\n+    // We use a cell vs a mutable option to circumvent borrowck errors.\n+    values: Cell<~[GraphNodeValue]>,\n }\n \n fn RegionVarBindings(tcx: ty::ctxt) -> RegionVarBindings {\n@@ -646,7 +768,37 @@ impl RegionVarBindings {\n                       been computed!\"));\n         }\n \n-        self.values.with_ref(|values| values[*rid])\n+        let v = self.values.with_ref(|values| values[*rid]);\n+        match v {\n+            Value(r) => r,\n+\n+            NoValue => {\n+                // No constraints, report an error.  It is plausible\n+                // that we could select an arbitrary region here\n+                // instead.  At the moment I am not doing this because\n+                // this generally masks bugs in the inference\n+                // algorithm, and given our syntax one cannot create\n+                // generally create a lifetime variable that isn't\n+                // used in some type, and hence all lifetime variables\n+                // should ultimately have some bounds.\n+\n+                self.tcx.sess.span_err(\n+                    self.var_spans[*rid],\n+                    fmt!(\"Unconstrained region variable #%u\", *rid));\n+\n+                // Touch of a hack: to suppress duplicate messages,\n+                // replace the NoValue entry with ErrorValue.\n+                let mut values = self.values.take();\n+                values[*rid] = ErrorValue;\n+                self.values.put_back(move values);\n+                re_static\n+            }\n+\n+            ErrorValue => {\n+                // An error that has previously been reported.\n+                re_static\n+            }\n+        }\n     }\n \n     fn combine_vars(&self,\n@@ -676,31 +828,32 @@ impl RegionVarBindings {\n         }\n     }\n \n+    fn vars_created_since_snapshot(&self, snapshot: uint) -> ~[RegionVid] {\n+        do vec::build |push| {\n+            for uint::range(snapshot, self.undo_log.len()) |i| {\n+                match self.undo_log[i] {\n+                    AddVar(vid) => push(vid),\n+                    _ => ()\n+                }\n+            }\n+        }\n+    }\n+\n     fn tainted(&self, snapshot: uint, r0: Region) -> ~[Region] {\n         /*!\n          *\n          * Computes all regions that have been related to `r0` in any\n-         * way since the snapshot `snapshot` was taken---excluding\n-         * `r0` itself and any region variables added as part of the\n-         * snapshot.  This is used when checking whether skolemized\n-         * regions are being improperly related to other regions.\n+         * way since the snapshot `snapshot` was taken---`r0` itself\n+         * will be the first entry. This is used when checking whether\n+         * skolemized regions are being improperly related to other\n+         * regions.\n          */\n \n         debug!(\"tainted(snapshot=%u, r0=%?)\", snapshot, r0);\n         let _indenter = indenter();\n \n         let undo_len = self.undo_log.len();\n \n-        // collect variables added since the snapshot was taken\n-        let new_vars = do vec::build |push| {\n-            for uint::range(snapshot, undo_len) |i| {\n-                match self.undo_log[i] {\n-                    AddVar(vid) => push(vid),\n-                    _ => ()\n-                }\n-            }\n-        };\n-\n         // `result_set` acts as a worklist: we explore all outgoing\n         // edges and add any new regions we find to result_set.  This\n         // is not a terribly efficient implementation.\n@@ -746,15 +899,6 @@ impl RegionVarBindings {\n             result_index += 1;\n         }\n \n-        // Drop `r0` itself and any region variables that were created\n-        // since the snapshot.\n-        result_set.retain(|r| {\n-            match *r {\n-                re_infer(ReVar(ref vid)) => !new_vars.contains(vid),\n-                _ => *r != r0\n-            }\n-        });\n-\n         return result_set;\n \n         fn consider_adding_edge(+result_set: ~[Region],\n@@ -991,11 +1135,11 @@ fn TwoRegionsMap() -> TwoRegionsMap {\n }\n \n impl RegionVarBindings {\n-    fn infer_variable_values(&self) -> ~[Region] {\n+    fn infer_variable_values(&self) -> ~[GraphNodeValue] {\n         let graph = self.construct_graph();\n         self.expansion(&graph);\n         self.contraction(&graph);\n-        self.extract_regions_and_report_errors(&graph)\n+        self.extract_values_and_report_conflicts(&graph)\n     }\n \n     fn construct_graph(&self) -> Graph {\n@@ -1231,34 +1375,60 @@ impl RegionVarBindings {\n         debug!(\"---- %s Complete after %u iteration(s)\", tag, iteration);\n     }\n \n-    fn extract_regions_and_report_errors(&self, graph: &Graph) -> ~[Region] {\n+    fn extract_values_and_report_conflicts(\n+        &self,\n+        graph: &Graph) -> ~[GraphNodeValue]\n+    {\n         let dup_map = TwoRegionsMap();\n         graph.nodes.mapi(|idx, node| {\n             match node.value {\n-              Value(v) => v,\n-\n-              NoValue => {\n-                self.tcx.sess.span_err(\n-                    node.span,\n-                    fmt!(\"Unconstrained region variable #%u\", idx));\n-                re_static\n-              }\n-\n-              ErrorValue => {\n-                let node_vid = RegionVid(idx);\n-                match node.classification {\n-                  Expanding => {\n-                    self.report_error_for_expanding_node(\n-                        graph, dup_map, node_vid);\n-                  }\n-                  Contracting => {\n-                    self.report_error_for_contracting_node(\n-                        graph, dup_map, node_vid);\n-                  }\n+                Value(_) => {\n+                    /* Inference successful */\n+                }\n+                NoValue => {\n+                    /* Unconstrained inference: do not report an error\n+                       until the value of this variable is requested.\n+                       After all, sometimes we make region variables but never\n+                       really use their values. */\n+                }\n+                ErrorValue => {\n+                    /* Inference impossible, this value contains\n+                       inconsistent constraints.\n+\n+                       I think that in this case we should report an\n+                       error now---unlike the case above, we can't\n+                       wait to see whether the user needs the result\n+                       of this variable.  The reason is that the mere\n+                       existence of this variable implies that the\n+                       region graph is inconsistent, whether or not it\n+                       is used.\n+\n+                       For example, we may have created a region\n+                       variable that is the GLB of two other regions\n+                       which do not have a GLB.  Even if that variable\n+                       is not used, it implies that those two regions\n+                       *should* have a GLB.\n+\n+                       At least I think this is true. It may be that\n+                       the mere existence of a conflict in a region variable\n+                       that is not used is not a problem, so if this rule\n+                       starts to create problems we'll have to revisit\n+                       this portion of the code and think hard about it. =) */\n+                    let node_vid = RegionVid(idx);\n+                    match node.classification {\n+                        Expanding => {\n+                            self.report_error_for_expanding_node(\n+                                graph, dup_map, node_vid);\n+                        }\n+                        Contracting => {\n+                            self.report_error_for_contracting_node(\n+                                graph, dup_map, node_vid);\n+                        }\n+                    }\n                 }\n-                re_static\n-              }\n             }\n+\n+            node.value\n         })\n     }\n "}, {"sha": "0bd53a3e80002a9a82280c94779fa8a633aefca5", "filename": "src/librustc/middle/typeck/infer/sub.rs", "status": "modified", "additions": 18, "deletions": 16, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/117e5e35831ded02e71554d2e13d6300215119b0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/117e5e35831ded02e71554d2e13d6300215119b0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs?ref=117e5e35831ded02e71554d2e13d6300215119b0", "patch": "@@ -125,8 +125,8 @@ impl Sub: combine {\n         // as-is, we need to do some extra work here in order to make sure\n         // that function subtyping works correctly with respect to regions\n         //\n-        // A rather detailed discussion of what's going on here can be\n-        // found in the region_inference.rs module.\n+        // Note: this is a subtle algorithm.  For a full explanation,\n+        // please see the large comment in `region_inference.rs`.\n \n         // Take a snapshot.  We'll never roll this back, but in later\n         // phases we do want to be able to examine \"all bindings that\n@@ -136,20 +136,9 @@ impl Sub: combine {\n \n         // First, we instantiate each bound region in the subtype with a fresh\n         // region variable.\n-        let {fn_ty: a_fn_ty, _} = {\n-            do replace_bound_regions_in_fn_ty(self.infcx.tcx, @Nil,\n-                                              None, a) |br| {\n-                // N.B.: The name of the bound region doesn't have\n-                // anything to do with the region variable that's created\n-                // for it.  The only thing we're doing with `br` here is\n-                // using it in the debug message.\n-                let rvar = self.infcx.next_region_var_nb(self.span);\n-                debug!(\"Bound region %s maps to %?\",\n-                       bound_region_to_str(self.infcx.tcx, br),\n-                       rvar);\n-                rvar\n-            }\n-        };\n+        let (a_fn_ty, _) =\n+            self.infcx.replace_bound_regions_with_fresh_regions(\n+                self.span, a);\n \n         // Second, we instantiate each bound region in the supertype with a\n         // fresh concrete region.\n@@ -172,10 +161,23 @@ impl Sub: combine {\n \n         // Presuming type comparison succeeds, we need to check\n         // that the skolemized regions do not \"leak\".\n+        let new_vars =\n+            self.infcx.region_vars.vars_created_since_snapshot(snapshot);\n         for list::each(skol_isr) |pair| {\n             let (skol_br, skol) = *pair;\n             let tainted = self.infcx.region_vars.tainted(snapshot, skol);\n             for tainted.each |tainted_region| {\n+                // Each skolemized should only be relatable to itself\n+                // or new variables:\n+                match *tainted_region {\n+                    ty::re_infer(ty::ReVar(ref vid)) => {\n+                        if new_vars.contains(vid) { loop; }\n+                    }\n+                    _ => {\n+                        if *tainted_region == skol { loop; }\n+                    }\n+                };\n+\n                 // A is not as polymorphic as B:\n                 if self.a_is_expected {\n                     return Err(ty::terr_regions_insufficiently_polymorphic("}, {"sha": "53cc59fc1b0632972dc82c5241fad3705c6fecbd", "filename": "src/librustc/middle/typeck/infer/test.rs", "status": "added", "additions": 301, "deletions": 0, "changes": 301, "blob_url": "https://github.com/rust-lang/rust/blob/117e5e35831ded02e71554d2e13d6300215119b0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/117e5e35831ded02e71554d2e13d6300215119b0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ftest.rs?ref=117e5e35831ded02e71554d2e13d6300215119b0", "patch": "@@ -0,0 +1,301 @@\n+/**\n+\n+# Standalone Tests for the Inference Module\n+\n+Note: This module is only compiled when doing unit testing.\n+\n+*/\n+\n+use std::getopts;\n+use std::map::HashMap;\n+use std::getopts;\n+use std::getopts::{opt_present};\n+use std::getopts::groups;\n+use std::getopts::groups::{optopt, optmulti, optflag, optflagopt, getopts};\n+use driver::driver::{optgroups, build_session_options, build_session,\n+                     str_input, build_configuration};\n+use driver::diagnostic;\n+use syntax::{ast, attr, parse};\n+use syntax::parse::parse_crate_from_source_str;\n+use middle::lang_items::{LanguageItems, language_items};\n+use util::ppaux::ty_to_str;\n+use syntax::ast_util::dummy_sp;\n+use middle::ty::{FnTyBase, FnMeta, FnSig};\n+\n+struct Env {\n+    crate: @ast::crate,\n+    tcx: ty::ctxt,\n+    infcx: infer::infer_ctxt\n+}\n+\n+struct RH {\n+    id: ast::node_id,\n+    sub: &[RH]\n+}\n+\n+fn setup_env(test_name: &str, source_string: &str) -> Env {\n+    let matches = getopts(~[~\"-Z\", ~\"verbose\"], optgroups()).get();\n+    let sessopts = build_session_options(~\"rustc\", matches, diagnostic::emit);\n+    let sess = build_session(sessopts, diagnostic::emit);\n+    let cfg = build_configuration(sess, ~\"whatever\", str_input(~\"\"));\n+    let dm = HashMap();\n+    let amap = HashMap();\n+    let freevars = HashMap();\n+    let region_paramd_items = HashMap();\n+    let region_map = HashMap();\n+    let lang_items = language_items::make();\n+\n+    let parse_sess = parse::new_parse_sess(None);\n+    let crate = parse_crate_from_source_str(\n+        test_name.to_str(), @source_string.to_str(),\n+        cfg, parse_sess);\n+\n+    let tcx = ty::mk_ctxt(sess, dm, amap, freevars, region_map,\n+                          region_paramd_items, move lang_items, crate);\n+\n+    let infcx = infer::new_infer_ctxt(tcx);\n+\n+    return Env { crate: crate, tcx: tcx, infcx: infcx };\n+}\n+\n+impl Env {\n+    fn create_region_hierarchy(&self, rh: &RH) {\n+        for rh.sub.each |child_rh| {\n+            self.create_region_hierarchy(child_rh);\n+            self.tcx.region_map.insert(child_rh.id, rh.id);\n+        }\n+    }\n+\n+    fn create_simple_region_hierarchy(&self) {\n+        // creates a region hierarchy where 1 is root, 10 and 11 are\n+        // children of 1, etc\n+        self.create_region_hierarchy(\n+            &RH {id: 1,\n+                 sub: &[RH {id: 10,\n+                            sub: &[]},\n+                        RH {id: 11,\n+                            sub: &[]}]});\n+    }\n+\n+    fn lookup_item(&self, names: &[~str]) -> ast::node_id {\n+        return match search_mod(self, &self.crate.node.module, 0, names) {\n+            Some(id) => id,\n+            None => {\n+                fail fmt!(\"No item found: `%s`\", str::connect(names, \"::\"));\n+            }\n+        };\n+\n+        fn search_mod(self: &Env,\n+                      m: &ast::_mod,\n+                      idx: uint,\n+                      names: &[~str]) -> Option<ast::node_id> {\n+            assert idx < names.len();\n+            for m.items.each |item| {\n+                if self.tcx.sess.str_of(item.ident) == names[idx] {\n+                    return search(self, *item, idx+1, names);\n+                }\n+            }\n+            return None;\n+        }\n+\n+        fn search(self: &Env,\n+                  it: @ast::item,\n+                  idx: uint,\n+                  names: &[~str]) -> Option<ast::node_id> {\n+            if idx == names.len() {\n+                return Some(it.id);\n+            }\n+\n+            return match it.node {\n+                ast::item_const(*) | ast::item_fn(*) |\n+                ast::item_foreign_mod(*) | ast::item_ty(*) => {\n+                    None\n+                }\n+\n+                ast::item_enum(*) | ast::item_class(*) |\n+                ast::item_trait(*) | ast::item_impl(*) |\n+                ast::item_mac(*) => {\n+                    None\n+                }\n+\n+                ast::item_mod(ref m) => {\n+                    search_mod(self, m, idx, names)\n+                }\n+            };\n+        }\n+    }\n+\n+    fn is_subtype(&self, a: ty::t, b: ty::t) -> bool {\n+        match infer::can_mk_subty(self.infcx, a, b) {\n+            Ok(_) => true,\n+            Err(_) => false\n+        }\n+    }\n+\n+    fn assert_subtype(&self, a: ty::t, b: ty::t) {\n+        if !self.is_subtype(a, b) {\n+            fail fmt!(\"%s is not a subtype of %s, but it should be\",\n+                      self.ty_to_str(a),\n+                      self.ty_to_str(b));\n+        }\n+    }\n+\n+    fn assert_not_subtype(&self, a: ty::t, b: ty::t) {\n+        if self.is_subtype(a, b) {\n+            fail fmt!(\"%s is a subtype of %s, but it shouldn't be\",\n+                      self.ty_to_str(a),\n+                      self.ty_to_str(b));\n+        }\n+    }\n+\n+    fn assert_strict_subtype(&self, a: ty::t, b: ty::t) {\n+        self.assert_subtype(a, b);\n+        self.assert_not_subtype(b, a);\n+    }\n+\n+    fn assert_eq(&self, a: ty::t, b: ty::t) {\n+        self.assert_subtype(a, b);\n+        self.assert_subtype(b, a);\n+    }\n+\n+    fn ty_to_str(&self, a: ty::t) -> ~str {\n+        ty_to_str(self.tcx, a)\n+    }\n+\n+    fn t_fn(&self, input_tys: &[ty::t], output_ty: ty::t) -> ty::t {\n+        let inputs = input_tys.map(|t| {mode: ast::expl(ast::by_copy),\n+                                        ty: *t});\n+        ty::mk_fn(self.tcx, FnTyBase {\n+            meta: FnMeta {purity: ast::impure_fn,\n+                          proto: ast::ProtoBare,\n+                          onceness: ast::Many,\n+                          region: ty::re_static,\n+                          bounds: @~[],\n+                          ret_style: ast::return_val},\n+            sig: FnSig {inputs: move inputs,\n+                        output: output_ty}\n+        })\n+    }\n+\n+    fn t_int(&self) -> ty::t {\n+        ty::mk_int(self.tcx)\n+    }\n+\n+    fn t_rptr_bound(&self, id: uint) -> ty::t {\n+        ty::mk_imm_rptr(self.tcx, ty::re_bound(ty::br_anon(id)), self.t_int())\n+    }\n+\n+    fn t_rptr_scope(&self, id: ast::node_id) -> ty::t {\n+        ty::mk_imm_rptr(self.tcx, ty::re_scope(id), self.t_int())\n+    }\n+\n+    fn t_rptr_free(&self, nid: ast::node_id, id: uint) -> ty::t {\n+        ty::mk_imm_rptr(self.tcx, ty::re_free(nid, ty::br_anon(id)),\n+                        self.t_int())\n+    }\n+\n+    fn t_rptr_static(&self) -> ty::t {\n+        ty::mk_imm_rptr(self.tcx, ty::re_static, self.t_int())\n+    }\n+\n+    fn lub() -> Lub { Lub(self.infcx.combine_fields(true, dummy_sp())) }\n+\n+    /// Checks that `LUB(t1,t2) == t_lub`\n+    fn check_lub(&self, t1: ty::t, t2: ty::t, t_lub: ty::t) {\n+        match self.lub().tys(t1, t2) {\n+            Err(e) => {\n+                fail fmt!(\"Unexpected error computing LUB: %?\", e)\n+            }\n+            Ok(t) => {\n+                self.assert_eq(t, t_lub);\n+\n+                // sanity check for good measure:\n+                self.assert_subtype(t1, t);\n+                self.assert_subtype(t2, t);\n+            }\n+        }\n+    }\n+\n+    /// Checks that `LUB(t1,t2)` is undefined\n+    fn check_no_lub(&self, t1: ty::t, t2: ty::t) {\n+        match self.lub().tys(t1, t2) {\n+            Err(_) => {}\n+            Ok(t) => {\n+                fail fmt!(\"Unexpected success computing LUB: %?\",\n+                          self.ty_to_str(t))\n+            }\n+        }\n+    }\n+}\n+\n+#[test]\n+fn contravariant_region_ptr() {\n+    let env = setup_env(\"contravariant_region_ptr\", \"\");\n+    env.create_simple_region_hierarchy();\n+    let t_rptr1 = env.t_rptr_scope(1);\n+    let t_rptr10 = env.t_rptr_scope(10);\n+    env.assert_eq(t_rptr1, t_rptr1);\n+    env.assert_eq(t_rptr10, t_rptr10);\n+    env.assert_strict_subtype(t_rptr1, t_rptr10);\n+}\n+\n+#[test]\n+fn lub_bound_bound() {\n+    let env = setup_env(\"lub_bound_bound\", \"\");\n+    let t_rptr_bound1 = env.t_rptr_bound(1);\n+    let t_rptr_bound2 = env.t_rptr_bound(2);\n+    env.check_lub(env.t_fn([t_rptr_bound1], env.t_int()),\n+                  env.t_fn([t_rptr_bound2], env.t_int()),\n+                  env.t_fn([t_rptr_bound1], env.t_int()));\n+}\n+\n+#[test]\n+fn lub_bound_free() {\n+    let env = setup_env(\"lub_bound_free\", \"\");\n+    let t_rptr_bound1 = env.t_rptr_bound(1);\n+    let t_rptr_free1 = env.t_rptr_free(0, 1);\n+    env.check_lub(env.t_fn([t_rptr_bound1], env.t_int()),\n+                  env.t_fn([t_rptr_free1], env.t_int()),\n+                  env.t_fn([t_rptr_free1], env.t_int()));\n+}\n+\n+#[test]\n+fn lub_bound_static() {\n+    let env = setup_env(\"lub_bound_static\", \"\");\n+    let t_rptr_bound1 = env.t_rptr_bound(1);\n+    let t_rptr_static = env.t_rptr_static();\n+    env.check_lub(env.t_fn([t_rptr_bound1], env.t_int()),\n+                  env.t_fn([t_rptr_static], env.t_int()),\n+                  env.t_fn([t_rptr_static], env.t_int()));\n+}\n+\n+#[test]\n+fn lub_bound_bound_inverse_order() {\n+    let env = setup_env(\"lub_bound_bound_inverse_order\", \"\");\n+    let t_rptr_bound1 = env.t_rptr_bound(1);\n+    let t_rptr_bound2 = env.t_rptr_bound(2);\n+    env.check_lub(env.t_fn([t_rptr_bound1, t_rptr_bound2], t_rptr_bound1),\n+                  env.t_fn([t_rptr_bound2, t_rptr_bound1], t_rptr_bound1),\n+                  env.t_fn([t_rptr_bound1, t_rptr_bound1], t_rptr_bound1));\n+}\n+\n+#[test]\n+fn lub_free_free() {\n+    let env = setup_env(\"lub_free_free\", \"\");\n+    let t_rptr_free1 = env.t_rptr_free(0, 1);\n+    let t_rptr_free2 = env.t_rptr_free(0, 2);\n+    let t_rptr_static = env.t_rptr_static();\n+    env.check_lub(env.t_fn([t_rptr_free1], env.t_int()),\n+                  env.t_fn([t_rptr_free2], env.t_int()),\n+                  env.t_fn([t_rptr_static], env.t_int()));\n+}\n+\n+#[test]\n+fn lub_returning_scope() {\n+    let env = setup_env(\"lub_returning_scope\", \"\");\n+    let t_rptr_scope10 = env.t_rptr_scope(10);\n+    let t_rptr_scope11 = env.t_rptr_scope(11);\n+    env.check_no_lub(env.t_fn([], t_rptr_scope10),\n+                     env.t_fn([], t_rptr_scope11));\n+}\n+"}, {"sha": "28b21693a515d85fcf21a3ede20b9d8a8f00549a", "filename": "src/librustc/rustc.rc", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/117e5e35831ded02e71554d2e13d6300215119b0/src%2Flibrustc%2Frustc.rc", "raw_url": "https://github.com/rust-lang/rust/raw/117e5e35831ded02e71554d2e13d6300215119b0/src%2Flibrustc%2Frustc.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Frustc.rc?ref=117e5e35831ded02e71554d2e13d6300215119b0", "patch": "@@ -143,6 +143,9 @@ mod middle {\n             mod to_str;\n             #[legacy_exports]\n             mod unify;\n+            #[cfg(test)]\n+            #[legacy_exports]\n+            mod test;\n         }\n         #[legacy_exports]\n         mod collect;"}, {"sha": "b3234ca1d6b4c1208cea3fc3cd4b802440169010", "filename": "src/test/compile-fail/regions-fns.rs", "status": "modified", "additions": 5, "deletions": 15, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/117e5e35831ded02e71554d2e13d6300215119b0/src%2Ftest%2Fcompile-fail%2Fregions-fns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/117e5e35831ded02e71554d2e13d6300215119b0/src%2Ftest%2Fcompile-fail%2Fregions-fns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-fns.rs?ref=117e5e35831ded02e71554d2e13d6300215119b0", "patch": "@@ -1,21 +1,11 @@\n-// Should fail region checking, because g can only accept a pointer\n-// with lifetime r, and a is a pointer with unspecified lifetime.\n-fn not_ok_1(a: &uint) {\n-    let mut g: fn@(x: &uint) = fn@(x: &r/uint) {};\n-    //~^ ERROR mismatched types\n-    g(a);\n-}\n+// Before fn subtyping was properly implemented,\n+// we reported errors in this case:\n \n-// Should fail region checking, because g can only accept a pointer\n-// with lifetime r, and a is a pointer with lifetime s.\n-fn not_ok_2(s: &s/uint)\n-{\n-    let mut g: fn@(x: &uint) = fn@(x: &r/uint) {};\n+fn not_ok(a: &uint, b: &b/uint) {\n+    let mut g: fn@(x: &uint) = fn@(x: &b/uint) {};\n     //~^ ERROR mismatched types\n-    g(s);\n+    g(a);\n }\n \n fn main() {\n }\n-\n-"}, {"sha": "07ce81ab7777b4375e1d85b91c119e2d75ba8f6a", "filename": "src/test/run-pass/regions-equiv-fns.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/117e5e35831ded02e71554d2e13d6300215119b0/src%2Ftest%2Frun-pass%2Fregions-equiv-fns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/117e5e35831ded02e71554d2e13d6300215119b0/src%2Ftest%2Frun-pass%2Fregions-equiv-fns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-equiv-fns.rs?ref=117e5e35831ded02e71554d2e13d6300215119b0", "patch": "@@ -0,0 +1,13 @@\n+// Before fn subtyping was properly implemented,\n+// we reported errors in this case:\n+\n+fn ok(a: &uint) {\n+    // Here &r is an alias for &:\n+    let mut g: fn@(x: &uint) = fn@(x: &r/uint) {};\n+    g(a);\n+}\n+\n+fn main() {\n+}\n+\n+"}]}