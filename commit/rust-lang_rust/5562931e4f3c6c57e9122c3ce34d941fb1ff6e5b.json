{"sha": "5562931e4f3c6c57e9122c3ce34d941fb1ff6e5b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU1NjI5MzFlNGYzYzZjNTdlOTEyMmMzY2UzNGQ5NDFmYjFmZjZlNWI=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2018-01-07T18:09:05Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2018-01-07T18:09:05Z"}, "message": "Introduce EOF token", "tree": {"sha": "0e87cba8e91d4bf96d752ada65b4d4a73e4e0ac9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0e87cba8e91d4bf96d752ada65b4d4a73e4e0ac9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5562931e4f3c6c57e9122c3ce34d941fb1ff6e5b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5562931e4f3c6c57e9122c3ce34d941fb1ff6e5b", "html_url": "https://github.com/rust-lang/rust/commit/5562931e4f3c6c57e9122c3ce34d941fb1ff6e5b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5562931e4f3c6c57e9122c3ce34d941fb1ff6e5b/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fc4d6cc298fe901d2bf92a30a3efd67233c67a3a", "url": "https://api.github.com/repos/rust-lang/rust/commits/fc4d6cc298fe901d2bf92a30a3efd67233c67a3a", "html_url": "https://github.com/rust-lang/rust/commit/fc4d6cc298fe901d2bf92a30a3efd67233c67a3a"}], "stats": {"total": 276, "additions": 136, "deletions": 140}, "files": [{"sha": "64c6718cb46c3b612a29ff565023814fb5cda9cc", "filename": "src/parser/event_parser/grammar.rs", "status": "modified", "additions": 8, "deletions": 15, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/5562931e4f3c6c57e9122c3ce34d941fb1ff6e5b/src%2Fparser%2Fevent_parser%2Fgrammar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5562931e4f3c6c57e9122c3ce34d941fb1ff6e5b/src%2Fparser%2Fevent_parser%2Fgrammar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fparser%2Fevent_parser%2Fgrammar.rs?ref=5562931e4f3c6c57e9122c3ce34d941fb1ff6e5b", "patch": "@@ -1,5 +1,6 @@\n use super::parser::Parser;\n use {SyntaxKind};\n+use tree::EOF;\n use syntax_kinds::*;\n \n // Items //\n@@ -18,11 +19,7 @@ pub(crate) fn file(p: &mut Parser) {\n }\n \n fn item_first(p: &Parser) -> bool {\n-    let current = match p.current() {\n-        Some(c) => c,\n-        None => return false,\n-    };\n-    match current {\n+    match p.current() {\n         STRUCT_KW | FN_KW => true,\n         _ => false,\n     }\n@@ -79,7 +76,7 @@ fn visibility(_: &mut Parser) {\n // Error recovery and high-order utils //\n \n fn node_if<F: FnOnce(&mut Parser)>(p: &mut Parser, first: SyntaxKind, node_kind: SyntaxKind, rest: F) -> bool {\n-    p.current_is(first) && { node(p, node_kind, |p| { p.bump(); rest(p); }); true }\n+    p.current() == first && { node(p, node_kind, |p| { p.bump(); rest(p); }); true }\n }\n \n fn node<F: FnOnce(&mut Parser)>(p: &mut Parser, node_kind: SyntaxKind, rest: F) {\n@@ -95,7 +92,7 @@ fn many<F: Fn(&mut Parser) -> bool>(p: &mut Parser, f: F) {\n fn comma_list<F: Fn(&mut Parser) -> bool>(p: &mut Parser, f: F) {\n     many(p, |p| {\n         f(p);\n-        if p.is_eof() {\n+        if p.current() == EOF {\n             false\n         } else {\n             p.expect(COMMA);\n@@ -119,7 +116,7 @@ where\n             f(p);\n             return true;\n         }\n-        if p.is_eof() {\n+        if p.current() == EOF {\n             if skipped {\n                 p.finish();\n             }\n@@ -131,18 +128,14 @@ where\n                 .message(message)\n                 .emit();\n         }\n-        p.bump().unwrap();\n+        p.bump();\n         skipped = true;\n     }\n }\n \n impl<'p> Parser<'p> {\n-    fn current_is(&self, kind: SyntaxKind) -> bool {\n-        self.current() == Some(kind)\n-    }\n-\n     pub(crate) fn expect(&mut self, kind: SyntaxKind) -> bool {\n-        if self.current_is(kind) {\n+        if self.current() == kind {\n             self.bump();\n             true\n         } else {\n@@ -154,7 +147,7 @@ impl<'p> Parser<'p> {\n     }\n \n     fn optional(&mut self, kind: SyntaxKind) {\n-        if self.current_is(kind) {\n+        if self.current() == kind {\n             self.bump();\n         }\n     }"}, {"sha": "bec9dbab48ad6e50b9510f7338d69e489b2d3119", "filename": "src/parser/event_parser/parser.rs", "status": "modified", "additions": 15, "deletions": 20, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/5562931e4f3c6c57e9122c3ce34d941fb1ff6e5b/src%2Fparser%2Fevent_parser%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5562931e4f3c6c57e9122c3ce34d941fb1ff6e5b/src%2Fparser%2Fevent_parser%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fparser%2Fevent_parser%2Fparser.rs?ref=5562931e4f3c6c57e9122c3ce34d941fb1ff6e5b", "patch": "@@ -2,8 +2,7 @@ use {Token, SyntaxKind, TextUnit};\n use super::{Event};\n use super::super::is_insignificant;\n use syntax_kinds::{L_CURLY, R_CURLY, ERROR};\n-\n-pub(crate) const EOF: SyntaxKind = SyntaxKind(10000);\n+use tree::EOF;\n \n \n pub(crate) struct Parser<'t> {\n@@ -46,19 +45,22 @@ impl<'t> Parser<'t> {\n     }\n \n     pub(crate) fn into_events(self) -> Vec<Event> {\n-        assert!(self.is_eof());\n+        assert!(self.curly_limit.is_none());\n+        assert!(self.current() == EOF);\n         self.events\n     }\n \n-    pub(crate) fn is_eof(&self) -> bool {\n+    pub(crate) fn current(&self) -> SyntaxKind {\n         if self.pos == self.tokens.len() {\n-            return true\n+            return EOF;\n         }\n+        let token = self.tokens[self.pos];\n         if let Some(limit) = self.curly_limit {\n-            let token = self.tokens[self.pos];\n-            return limit == self.curly_level && token.kind == R_CURLY;\n+            if limit == self.curly_level && token.kind == R_CURLY {\n+                return EOF\n+            }\n         }\n-        false\n+        token.kind\n     }\n \n     pub(crate) fn start(&mut self, kind: SyntaxKind) {\n@@ -73,24 +75,17 @@ impl<'t> Parser<'t> {\n         ErrorBuilder::new(self)\n     }\n \n-    pub(crate) fn current(&self) -> Option<SyntaxKind> {\n-        if self.is_eof() {\n-            return None;\n-        }\n-        let token = self.tokens[self.pos];\n-        Some(token.kind)\n-    }\n-\n-    pub(crate) fn bump(&mut self) -> Option<SyntaxKind> {\n-        let kind = self.current()?;\n+    pub(crate) fn bump(&mut self) -> SyntaxKind {\n+        let kind = self.current();\n         match kind {\n             L_CURLY => self.curly_level += 1,\n             R_CURLY => self.curly_level -= 1,\n+            EOF => return EOF,\n             _ => (),\n         }\n         self.pos += 1;\n         self.event(Event::Token { kind, n_raw_tokens: 1 });\n-        Some(kind)\n+        kind\n     }\n \n     pub(crate) fn lookahead(&self, kinds: &[SyntaxKind]) -> bool {\n@@ -114,7 +109,7 @@ impl<'t> Parser<'t> {\n         if !self.expect(R_CURLY) {\n             self.start(ERROR);\n             while self.curly_level > old_level {\n-                if self.bump().is_none() {\n+                if self.bump() == EOF {\n                     break;\n                 }\n             }"}, {"sha": "d8f8437374caccb7a492093f1e115413d0cef12c", "filename": "src/tree/mod.rs", "status": "modified", "additions": 113, "deletions": 105, "changes": 218, "blob_url": "https://github.com/rust-lang/rust/blob/5562931e4f3c6c57e9122c3ce34d941fb1ff6e5b/src%2Ftree%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5562931e4f3c6c57e9122c3ce34d941fb1ff6e5b/src%2Ftree%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftree%2Fmod.rs?ref=5562931e4f3c6c57e9122c3ce34d941fb1ff6e5b", "patch": "@@ -10,8 +10,16 @@ pub use self::file_builder::{FileBuilder, Sink};\n #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\n pub struct SyntaxKind(pub(crate) u32);\n \n+pub(crate) const EOF: SyntaxKind = SyntaxKind(10000);\n+pub(crate) const EOF_INFO: SyntaxInfo = SyntaxInfo {\n+    name: \"EOF\"\n+};\n+\n impl SyntaxKind {\n     fn info(self) -> &'static SyntaxInfo {\n+        if self == EOF {\n+            return &EOF_INFO;\n+        }\n         syntax_info(self)\n     }\n }\n@@ -35,180 +43,180 @@ pub struct Token {\n }\n \n pub struct File {\n-\ttext: String,\n-\tnodes: Vec<NodeData>,\n-\terrors: Vec<SyntaxErrorData>,\n+    text: String,\n+    nodes: Vec<NodeData>,\n+    errors: Vec<SyntaxErrorData>,\n }\n \n impl File {\n-\tpub fn root<'f>(&'f self) -> Node<'f> {\n-\t\tassert!(!self.nodes.is_empty());\n-\t\tNode { file: self, idx: NodeIdx(0) }\n-\t}\n+    pub fn root<'f>(&'f self) -> Node<'f> {\n+        assert!(!self.nodes.is_empty());\n+        Node { file: self, idx: NodeIdx(0) }\n+    }\n }\n \n #[derive(Clone, Copy)]\n pub struct Node<'f> {\n-\tfile: &'f File,\n-\tidx: NodeIdx,\n+    file: &'f File,\n+    idx: NodeIdx,\n }\n \n impl<'f> Node<'f> {\n-\tpub fn kind(&self) -> SyntaxKind {\n-\t\tself.data().kind\n-\t}\n+    pub fn kind(&self) -> SyntaxKind {\n+        self.data().kind\n+    }\n \n-\tpub fn range(&self) -> TextRange {\n-\t\tself.data().range\n-\t}\n+    pub fn range(&self) -> TextRange {\n+        self.data().range\n+    }\n \n-\tpub fn text(&self) -> &'f str {\n-\t\t&self.file.text.as_str()[self.range()]\n-\t}\n+    pub fn text(&self) -> &'f str {\n+        &self.file.text.as_str()[self.range()]\n+    }\n \n-\tpub fn parent(&self) -> Option<Node<'f>> {\n-\t\tself.as_node(self.data().parent)\n-\t}\n+    pub fn parent(&self) -> Option<Node<'f>> {\n+        self.as_node(self.data().parent)\n+    }\n \n-\tpub fn children(&self) -> Children<'f> {\n-\t\tChildren { next: self.as_node(self.data().first_child) }\n-\t}\n+    pub fn children(&self) -> Children<'f> {\n+        Children { next: self.as_node(self.data().first_child) }\n+    }\n \n-\tpub fn errors(&self) -> SyntaxErrors<'f> {\n-\t\tlet pos = self.file.errors.iter().position(|e| e.node == self.idx);\n-\t\tlet next = pos\n-\t\t\t.map(|i| ErrorIdx(i as u32))\n-\t\t\t.map(|idx| SyntaxError { file: self.file, idx });\n-\t\tSyntaxErrors { next }\n-\t}\n+    pub fn errors(&self) -> SyntaxErrors<'f> {\n+        let pos = self.file.errors.iter().position(|e| e.node == self.idx);\n+        let next = pos\n+            .map(|i| ErrorIdx(i as u32))\n+            .map(|idx| SyntaxError { file: self.file, idx });\n+        SyntaxErrors { next }\n+    }\n \n-\tfn data(&self) -> &'f NodeData {\n-\t\t&self.file.nodes[self.idx]\n-\t}\n+    fn data(&self) -> &'f NodeData {\n+        &self.file.nodes[self.idx]\n+    }\n \n-\tfn as_node(&self, idx: Option<NodeIdx>) -> Option<Node<'f>> {\n-\t\tidx.map(|idx| Node { file: self.file, idx })\n-\t}\n+    fn as_node(&self, idx: Option<NodeIdx>) -> Option<Node<'f>> {\n+        idx.map(|idx| Node { file: self.file, idx })\n+    }\n }\n \n impl<'f> fmt::Debug for Node<'f> {\n-\tfn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n-\t\twrite!(fmt, \"{:?}@{:?}\", self.kind(), self.range())\n-\t}\n+    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+        write!(fmt, \"{:?}@{:?}\", self.kind(), self.range())\n+    }\n }\n \n impl<'f> cmp::PartialEq<Node<'f>> for Node<'f> {\n-\tfn eq(&self, other: &Node<'f>) -> bool {\n-\t\tself.idx == other.idx && ::std::ptr::eq(self.file, other.file)\n-\t}\n+    fn eq(&self, other: &Node<'f>) -> bool {\n+        self.idx == other.idx && ::std::ptr::eq(self.file, other.file)\n+    }\n }\n \n impl<'f> cmp::Eq for Node<'f> {\n }\n \n #[derive(Clone, Copy)]\n pub struct SyntaxError<'f> {\n-\tfile: &'f File,\n-\tidx: ErrorIdx,\n+    file: &'f File,\n+    idx: ErrorIdx,\n }\n \n impl<'f> SyntaxError<'f> {\n-\tpub fn message(&self) -> &'f str {\n-\t\tself.data().message.as_str()\n-\t}\n-\n-\tpub fn after_child(&self) -> Option<Node<'f>> {\n-\t\tlet idx = self.data().after_child?;\n-\t\tSome(Node { file: self.file, idx })\n-\t}\n-\n-\tfn data(&self) -> &'f SyntaxErrorData {\n-\t\t&self.file.errors[self.idx]\n-\t}\n-\n-\tfn next(&self) -> Option<SyntaxError<'f>> {\n-\t\tlet next_idx = self.idx.0 + 1;\n-\t\tif !((next_idx as usize) < self.file.errors.len()) {\n-\t\t\treturn None;\n-\t\t}\n-\t\tlet result = SyntaxError {\n-\t\t\tfile: self.file,\n-\t\t\tidx: ErrorIdx(next_idx)\n-\t\t};\n-\t\tif result.data().node != self.data().node {\n-\t\t\treturn None;\n-\t\t}\n-\t\tSome(result)\n-\t}\n+    pub fn message(&self) -> &'f str {\n+        self.data().message.as_str()\n+    }\n+\n+    pub fn after_child(&self) -> Option<Node<'f>> {\n+        let idx = self.data().after_child?;\n+        Some(Node { file: self.file, idx })\n+    }\n+\n+    fn data(&self) -> &'f SyntaxErrorData {\n+        &self.file.errors[self.idx]\n+    }\n+\n+    fn next(&self) -> Option<SyntaxError<'f>> {\n+        let next_idx = self.idx.0 + 1;\n+        if !((next_idx as usize) < self.file.errors.len()) {\n+            return None;\n+        }\n+        let result = SyntaxError {\n+            file: self.file,\n+            idx: ErrorIdx(next_idx)\n+        };\n+        if result.data().node != self.data().node {\n+            return None;\n+        }\n+        Some(result)\n+    }\n }\n \n pub struct Children<'f> {\n-\tnext: Option<Node<'f>>,\n+    next: Option<Node<'f>>,\n }\n \n impl<'f> Iterator for Children<'f> {\n-\ttype Item = Node<'f>;\n+    type Item = Node<'f>;\n \n-\tfn next(&mut self) -> Option<Node<'f>> {\n-\t\tlet next = self.next;\n-\t\tself.next = next.and_then(|node| node.as_node(node.data().next_sibling));\n-\t\tnext\n-\t}\n+    fn next(&mut self) -> Option<Node<'f>> {\n+        let next = self.next;\n+        self.next = next.and_then(|node| node.as_node(node.data().next_sibling));\n+        next\n+    }\n }\n \n pub struct SyntaxErrors<'f> {\n-\tnext: Option<SyntaxError<'f>>,\n+    next: Option<SyntaxError<'f>>,\n }\n \n impl<'f> Iterator for SyntaxErrors<'f> {\n-\ttype Item = SyntaxError<'f>;\n+    type Item = SyntaxError<'f>;\n \n-\tfn next(&mut self) -> Option<SyntaxError<'f>> {\n-\t\tlet next = self.next;\n-\t\tself.next = next.as_ref().and_then(SyntaxError::next);\n-\t\tnext\n-\t}\n+    fn next(&mut self) -> Option<SyntaxError<'f>> {\n+        let next = self.next;\n+        self.next = next.as_ref().and_then(SyntaxError::next);\n+        next\n+    }\n }\n \n \n #[derive(Clone, Copy, PartialEq, Eq)]\n struct NodeIdx(u32);\n \n struct NodeData {\n-\tkind: SyntaxKind,\n-\trange: TextRange,\n-\tparent: Option<NodeIdx>,\n-\tfirst_child: Option<NodeIdx>,\n-\tnext_sibling: Option<NodeIdx>,\n+    kind: SyntaxKind,\n+    range: TextRange,\n+    parent: Option<NodeIdx>,\n+    first_child: Option<NodeIdx>,\n+    next_sibling: Option<NodeIdx>,\n }\n \n impl ::std::ops::Index<NodeIdx> for Vec<NodeData> {\n-\ttype Output = NodeData;\n+    type Output = NodeData;\n \n-\tfn index(&self, NodeIdx(idx): NodeIdx) -> &NodeData {\n-\t\t&self[idx as usize]\n-\t}\n+    fn index(&self, NodeIdx(idx): NodeIdx) -> &NodeData {\n+        &self[idx as usize]\n+    }\n }\n \n impl ::std::ops::IndexMut<NodeIdx> for Vec<NodeData> {\n-\tfn index_mut(&mut self, NodeIdx(idx): NodeIdx) -> &mut NodeData {\n-\t\t&mut self[idx as usize]\n-\t}\n+    fn index_mut(&mut self, NodeIdx(idx): NodeIdx) -> &mut NodeData {\n+        &mut self[idx as usize]\n+    }\n }\n \n #[derive(Clone, Copy)]\n struct ErrorIdx(u32);\n \n struct SyntaxErrorData {\n-\tnode: NodeIdx,\n-\tmessage: String,\n-\tafter_child: Option<NodeIdx>,\n+    node: NodeIdx,\n+    message: String,\n+    after_child: Option<NodeIdx>,\n }\n \n impl ::std::ops::Index<ErrorIdx> for Vec<SyntaxErrorData> {\n-\ttype Output = SyntaxErrorData;\n+    type Output = SyntaxErrorData;\n \n-\tfn index(&self, ErrorIdx(idx): ErrorIdx) -> &SyntaxErrorData {\n-\t\t&self[idx as usize]\n-\t}\n+    fn index(&self, ErrorIdx(idx): ErrorIdx) -> &SyntaxErrorData {\n+        &self[idx as usize]\n+    }\n }"}]}