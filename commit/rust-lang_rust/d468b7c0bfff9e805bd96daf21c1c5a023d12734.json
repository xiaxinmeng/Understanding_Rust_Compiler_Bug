{"sha": "d468b7c0bfff9e805bd96daf21c1c5a023d12734", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ0NjhiN2MwYmZmZjllODA1YmQ5NmRhZjIxYzFjNWEwMjNkMTI3MzQ=", "commit": {"author": {"name": "Ben Blum", "email": "bblum@andrew.cmu.edu", "date": "2013-08-23T23:55:03Z"}, "committer": {"name": "Ben Blum", "email": "bblum@andrew.cmu.edu", "date": "2013-08-23T23:55:03Z"}, "message": "Document the task watching / exit code propagation implementation.", "tree": {"sha": "4e0945bf9898670d19b4cc90d3459f2f208fc652", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4e0945bf9898670d19b4cc90d3459f2f208fc652"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d468b7c0bfff9e805bd96daf21c1c5a023d12734", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d468b7c0bfff9e805bd96daf21c1c5a023d12734", "html_url": "https://github.com/rust-lang/rust/commit/d468b7c0bfff9e805bd96daf21c1c5a023d12734", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d468b7c0bfff9e805bd96daf21c1c5a023d12734/comments", "author": {"login": "bblum", "id": 1820515, "node_id": "MDQ6VXNlcjE4MjA1MTU=", "avatar_url": "https://avatars.githubusercontent.com/u/1820515?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bblum", "html_url": "https://github.com/bblum", "followers_url": "https://api.github.com/users/bblum/followers", "following_url": "https://api.github.com/users/bblum/following{/other_user}", "gists_url": "https://api.github.com/users/bblum/gists{/gist_id}", "starred_url": "https://api.github.com/users/bblum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bblum/subscriptions", "organizations_url": "https://api.github.com/users/bblum/orgs", "repos_url": "https://api.github.com/users/bblum/repos", "events_url": "https://api.github.com/users/bblum/events{/privacy}", "received_events_url": "https://api.github.com/users/bblum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bblum", "id": 1820515, "node_id": "MDQ6VXNlcjE4MjA1MTU=", "avatar_url": "https://avatars.githubusercontent.com/u/1820515?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bblum", "html_url": "https://github.com/bblum", "followers_url": "https://api.github.com/users/bblum/followers", "following_url": "https://api.github.com/users/bblum/following{/other_user}", "gists_url": "https://api.github.com/users/bblum/gists{/gist_id}", "starred_url": "https://api.github.com/users/bblum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bblum/subscriptions", "organizations_url": "https://api.github.com/users/bblum/orgs", "repos_url": "https://api.github.com/users/bblum/repos", "events_url": "https://api.github.com/users/bblum/events{/privacy}", "received_events_url": "https://api.github.com/users/bblum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c678b22276137afff71baeef9ccd7ba23765705e", "url": "https://api.github.com/repos/rust-lang/rust/commits/c678b22276137afff71baeef9ccd7ba23765705e", "html_url": "https://github.com/rust-lang/rust/commit/c678b22276137afff71baeef9ccd7ba23765705e"}], "stats": {"total": 86, "additions": 85, "deletions": 1}, "files": [{"sha": "b0b425e3aee4ad587b966fb2ba8adbeb817db771", "filename": "src/libstd/rt/kill.rs", "status": "modified", "additions": 85, "deletions": 1, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/d468b7c0bfff9e805bd96daf21c1c5a023d12734/src%2Flibstd%2Frt%2Fkill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d468b7c0bfff9e805bd96daf21c1c5a023d12734/src%2Flibstd%2Frt%2Fkill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fkill.rs?ref=d468b7c0bfff9e805bd96daf21c1c5a023d12734", "patch": "@@ -20,6 +20,7 @@ observed by the parent of a task::try task that itself spawns child tasks\n (such as any #[test] function). In both cases the data structures live in\n KillHandle.\n \n+\n I. Task killing.\n \n The model for killing involves two atomic flags, the \"kill flag\" and the\n@@ -60,9 +61,92 @@ killer does perform both writes, it means it saw a KILL_RUNNING in the\n unkillable flag, which means an unkillable task will see KILL_KILLED and fail\n immediately (rendering the subsequent write to the kill flag unnecessary).\n \n+\n II. Exit code propagation.\n \n-FIXME(#7544): Decide on the ultimate model for this and document it.\n+The basic model for exit code propagation, which is used with the \"watched\"\n+spawn mode (on by default for linked spawns, off for supervised and unlinked\n+spawns), is that a parent will wait for all its watched children to exit\n+before reporting whether it succeeded or failed. A watching parent will only\n+report success if it succeeded and all its children also reported success;\n+otherwise, it will report failure. This is most useful for writing test cases:\n+\n+~~~\n+#[test]\n+fn test_something_in_another_task {\n+    do spawn {\n+        assert!(collatz_conjecture_is_false());\n+    }\n+}\n+~~~\n+\n+Here, as the child task will certainly outlive the parent task, we might miss\n+the failure of the child when deciding whether or not the test case passed.\n+The watched spawn mode avoids this problem.\n+\n+In order to propagate exit codes from children to their parents, any\n+'watching' parent must wait for all of its children to exit before it can\n+report its final exit status. We achieve this by using an UnsafeArc, using the\n+reference counting to track how many children are still alive, and using the\n+unwrap() operation in the parent's exit path to wait for all children to exit.\n+The UnsafeArc referred to here is actually the KillHandle itself.\n+\n+This also works transitively, as if a \"middle\" watched child task is itself\n+watching a grandchild task, the \"middle\" task will do unwrap() on its own\n+KillHandle (thereby waiting for the grandchild to exit) before dropping its\n+reference to its watching parent (which will alert the parent).\n+\n+While UnsafeArc::unwrap() accomplishes the synchronization, there remains the\n+matter of reporting the exit codes themselves. This is easiest when an exiting\n+watched task has no watched children of its own:\n+\n+- If the task with no watched children exits successfully, it need do nothing.\n+- If the task with no watched children has failed, it sets a flag in the\n+  parent's KillHandle (\"any_child_failed\") to false. It then stays false forever.\n+\n+However, if a \"middle\" watched task with watched children of its own exits\n+before its child exits, we need to ensure that the grandparent task may still\n+see a failure from the grandchild task. While we could achieve this by having\n+each intermediate task block on its handle, this keeps around the other resources\n+the task was using. To be more efficient, this is accomplished via \"tombstones\".\n+\n+A tombstone is a closure, ~fn() -> bool, which will perform any waiting necessary\n+to collect the exit code of descendant tasks. In its environment is captured\n+the KillHandle of whichever task created the tombstone, and perhaps also any\n+tombstones that that task itself had, and finally also another tombstone,\n+effectively creating a lazy-list of heap closures.\n+\n+When a child wishes to exit early and leave tombstones behind for its parent,\n+it must use a LittleLock (pthread mutex) to synchronize with any possible\n+sibling tasks which are trying to do the same thing with the same parent.\n+However, on the other side, when the parent is ready to pull on the tombstones,\n+it need not use this lock, because the unwrap() serves as a barrier that ensures\n+no children will remain with references to the handle.\n+\n+The main logic for creating and assigning tombstones can be found in the\n+function reparent_children_to() in the impl for KillHandle.\n+\n+\n+IIA. Issues with exit code propagation.\n+\n+There are two known issues with the current scheme for exit code propagation.\n+\n+- As documented in issue #8136, the structure mandates the possibility for stack\n+  overflow when collecting tombstones that are very deeply nested. This cannot\n+  be avoided with the closure representation, as tombstones end up structured in\n+  a sort of tree. However, notably, the tombstones do not actually need to be\n+  collected in any particular order, and so a doubly-linked list may be used.\n+  However we do not do this yet because DList is in libextra.\n+\n+- A discussion with Graydon made me realize that if we decoupled the exit code\n+  propagation from the parents-waiting action, this could result in a simpler\n+  implementation as the exit codes themselves would not have to be propagated,\n+  and could instead be propagated implicitly through the taskgroup mechanism\n+  that we already have. The tombstoning scheme would still be required. I have\n+  not implemented this because currently we can't receive a linked failure kill\n+  signal during the task cleanup activity, as that is currently \"unkillable\",\n+  and occurs outside the task's unwinder's \"try\" block, so would require some\n+  restructuring.\n \n */\n "}]}