{"sha": "edeb631ad0cd6fdf31e2e31ec90e105d1768be28", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVkZWI2MzFhZDBjZDZmZGYzMWUyZTMxZWM5MGUxMDVkMTc2OGJlMjg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-01-17T14:50:24Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-01-17T14:50:24Z"}, "message": "Auto merge of #81113 - m-ou-se:rollup-a1unz4x, r=m-ou-se\n\nRollup of 13 pull requests\n\nSuccessful merges:\n\n - #79298 (correctly deal with late-bound lifetimes in anon consts)\n - #80031 (resolve: Reject ambiguity built-in attr vs different built-in attr)\n - #80201 (Add benchmark and fast path for BufReader::read_exact)\n - #80635 (Improve diagnostics when closure doesn't meet trait bound)\n - #80765 (resolve: Simplify collection of traits in scope)\n - #80932 (Allow downloading LLVM on Windows and MacOS)\n - #80983 (Remove is_dllimport_foreign_item definition from cg_ssa)\n - #81064 (Support non-stage0 check)\n - #81080 (Force vec![] to expression position only)\n - #81082 (BTreeMap: clean up a few more comments)\n - #81084 (Use Option::map instead of open-coding it)\n - #81095 (Use Option::unwrap_or instead of open-coding it)\n - #81107 (Add NonZeroUn::is_power_of_two)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "48c316c067559b3c58d2b652aa836953f0dced5b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/48c316c067559b3c58d2b652aa836953f0dced5b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/edeb631ad0cd6fdf31e2e31ec90e105d1768be28", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/edeb631ad0cd6fdf31e2e31ec90e105d1768be28", "html_url": "https://github.com/rust-lang/rust/commit/edeb631ad0cd6fdf31e2e31ec90e105d1768be28", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/edeb631ad0cd6fdf31e2e31ec90e105d1768be28/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7d3818152d8ab5649d2e5cc6d7851ed7c03055fe", "url": "https://api.github.com/repos/rust-lang/rust/commits/7d3818152d8ab5649d2e5cc6d7851ed7c03055fe", "html_url": "https://github.com/rust-lang/rust/commit/7d3818152d8ab5649d2e5cc6d7851ed7c03055fe"}, {"sha": "801684620bd4e0bc12b98a071851e3d3064429e4", "url": "https://api.github.com/repos/rust-lang/rust/commits/801684620bd4e0bc12b98a071851e3d3064429e4", "html_url": "https://github.com/rust-lang/rust/commit/801684620bd4e0bc12b98a071851e3d3064429e4"}], "stats": {"total": 1211, "additions": 812, "deletions": 399}, "files": [{"sha": "544ef38c12c6d8d4286de41c82207fbf7f52c2c5", "filename": "compiler/rustc_codegen_llvm/src/llvm_util.rs", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/edeb631ad0cd6fdf31e2e31ec90e105d1768be28/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edeb631ad0cd6fdf31e2e31ec90e105d1768be28/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm_util.rs?ref=edeb631ad0cd6fdf31e2e31ec90e105d1768be28", "patch": "@@ -214,11 +214,7 @@ fn handle_native(name: &str) -> &str {\n }\n \n pub fn target_cpu(sess: &Session) -> &str {\n-    let name = match sess.opts.cg.target_cpu {\n-        Some(ref s) => &**s,\n-        None => &*sess.target.cpu,\n-    };\n-\n+    let name = sess.opts.cg.target_cpu.as_ref().unwrap_or(&sess.target.cpu);\n     handle_native(name)\n }\n \n@@ -254,8 +250,6 @@ pub fn handle_native_features(sess: &Session) -> Vec<String> {\n }\n \n pub fn tune_cpu(sess: &Session) -> Option<&str> {\n-    match sess.opts.debugging_opts.tune_cpu {\n-        Some(ref s) => Some(handle_native(&**s)),\n-        None => None,\n-    }\n+    let name = sess.opts.debugging_opts.tune_cpu.as_ref()?;\n+    Some(handle_native(name))\n }"}, {"sha": "2ce5fe5ad504b75d2f8ed59061a4bd4b1e23f91f", "filename": "compiler/rustc_codegen_ssa/src/base.rs", "status": "modified", "additions": 0, "deletions": 27, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/edeb631ad0cd6fdf31e2e31ec90e105d1768be28/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edeb631ad0cd6fdf31e2e31ec90e105d1768be28/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs?ref=edeb631ad0cd6fdf31e2e31ec90e105d1768be28", "patch": "@@ -29,7 +29,6 @@ use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::{self, Instance, Ty, TyCtxt};\n use rustc_session::cgu_reuse_tracker::CguReuse;\n use rustc_session::config::{self, EntryFnType};\n-use rustc_session::utils::NativeLibKind;\n use rustc_session::Session;\n use rustc_target::abi::{Align, LayoutOf, VariantIdx};\n \n@@ -817,32 +816,6 @@ pub fn provide_both(providers: &mut Providers) {\n         }\n         tcx.sess.opts.optimize\n     };\n-\n-    providers.dllimport_foreign_items = |tcx, krate| {\n-        let module_map = tcx.foreign_modules(krate);\n-\n-        let dllimports = tcx\n-            .native_libraries(krate)\n-            .iter()\n-            .filter(|lib| {\n-                if !matches!(lib.kind, NativeLibKind::Dylib | NativeLibKind::Unspecified) {\n-                    return false;\n-                }\n-                let cfg = match lib.cfg {\n-                    Some(ref cfg) => cfg,\n-                    None => return true,\n-                };\n-                attr::cfg_matches(cfg, &tcx.sess.parse_sess, None)\n-            })\n-            .filter_map(|lib| lib.foreign_module)\n-            .map(|id| &module_map[&id])\n-            .flat_map(|module| module.foreign_items.iter().cloned())\n-            .collect();\n-        dllimports\n-    };\n-\n-    providers.is_dllimport_foreign_item =\n-        |tcx, def_id| tcx.dllimport_foreign_items(def_id.krate).contains(&def_id);\n }\n \n fn determine_cgu_reuse<'tcx>(tcx: TyCtxt<'tcx>, cgu: &CodegenUnit<'tcx>) -> CguReuse {"}, {"sha": "e8c711cae64ef30498a941651ee4ef2003623c55", "filename": "compiler/rustc_expand/src/mbe/macro_rules.rs", "status": "modified", "additions": 1, "deletions": 29, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/edeb631ad0cd6fdf31e2e31ec90e105d1768be28/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edeb631ad0cd6fdf31e2e31ec90e105d1768be28/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs?ref=edeb631ad0cd6fdf31e2e31ec90e105d1768be28", "patch": "@@ -56,36 +56,11 @@ crate fn annotate_err_with_kind(\n     };\n }\n \n-/// Instead of e.g. `vec![a, b, c]` in a pattern context, suggest `[a, b, c]`.\n-fn suggest_slice_pat(e: &mut DiagnosticBuilder<'_>, site_span: Span, parser: &Parser<'_>) {\n-    let mut suggestion = None;\n-    if let Ok(code) = parser.sess.source_map().span_to_snippet(site_span) {\n-        if let Some(bang) = code.find('!') {\n-            suggestion = Some(code[bang + 1..].to_string());\n-        }\n-    }\n-    if let Some(suggestion) = suggestion {\n-        e.span_suggestion(\n-            site_span,\n-            \"use a slice pattern here instead\",\n-            suggestion,\n-            Applicability::MachineApplicable,\n-        );\n-    } else {\n-        e.span_label(site_span, \"use a slice pattern here instead\");\n-    }\n-    e.help(\n-        \"for more information, see https://doc.rust-lang.org/edition-guide/\\\n-        rust-2018/slice-patterns.html\",\n-    );\n-}\n-\n fn emit_frag_parse_err(\n     mut e: DiagnosticBuilder<'_>,\n     parser: &Parser<'_>,\n     orig_parser: &mut Parser<'_>,\n     site_span: Span,\n-    macro_ident: Ident,\n     arm_span: Span,\n     kind: AstFragmentKind,\n ) {\n@@ -113,9 +88,6 @@ fn emit_frag_parse_err(\n         e.span_label(site_span, \"in this macro invocation\");\n     }\n     match kind {\n-        AstFragmentKind::Pat if macro_ident.name == sym::vec => {\n-            suggest_slice_pat(&mut e, site_span, parser);\n-        }\n         // Try a statement if an expression is wanted but failed and suggest adding `;` to call.\n         AstFragmentKind::Expr => match parse_ast_fragment(orig_parser, AstFragmentKind::Stmts) {\n             Err(mut err) => err.cancel(),\n@@ -143,7 +115,7 @@ impl<'a> ParserAnyMacro<'a> {\n         let fragment = match parse_ast_fragment(parser, kind) {\n             Ok(f) => f,\n             Err(err) => {\n-                emit_frag_parse_err(err, parser, snapshot, site_span, macro_ident, arm_span, kind);\n+                emit_frag_parse_err(err, parser, snapshot, site_span, arm_span, kind);\n                 return kind.dummy(site_span);\n             }\n         };"}, {"sha": "a81eb747a335a48de92e185d6c698b90806af56b", "filename": "compiler/rustc_hir/src/def.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/edeb631ad0cd6fdf31e2e31ec90e105d1768be28/compiler%2Frustc_hir%2Fsrc%2Fdef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edeb631ad0cd6fdf31e2e31ec90e105d1768be28/compiler%2Frustc_hir%2Fsrc%2Fdef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fdef.rs?ref=edeb631ad0cd6fdf31e2e31ec90e105d1768be28", "patch": "@@ -5,6 +5,7 @@ use rustc_ast as ast;\n use rustc_ast::NodeId;\n use rustc_macros::HashStable_Generic;\n use rustc_span::hygiene::MacroKind;\n+use rustc_span::Symbol;\n \n use std::array::IntoIter;\n use std::fmt::Debug;\n@@ -34,7 +35,7 @@ pub enum CtorKind {\n #[derive(HashStable_Generic)]\n pub enum NonMacroAttrKind {\n     /// Single-segment attribute defined by the language (`#[inline]`)\n-    Builtin,\n+    Builtin(Symbol),\n     /// Multi-segment custom attribute living in a \"tool module\" (`#[rustfmt::skip]`).\n     Tool,\n     /// Single-segment custom attribute registered by a derive macro (`#[serde(default)]`).\n@@ -371,7 +372,7 @@ impl CtorKind {\n impl NonMacroAttrKind {\n     pub fn descr(self) -> &'static str {\n         match self {\n-            NonMacroAttrKind::Builtin => \"built-in attribute\",\n+            NonMacroAttrKind::Builtin(..) => \"built-in attribute\",\n             NonMacroAttrKind::Tool => \"tool attribute\",\n             NonMacroAttrKind::DeriveHelper | NonMacroAttrKind::DeriveHelperCompat => {\n                 \"derive helper attribute\"\n@@ -393,7 +394,7 @@ impl NonMacroAttrKind {\n             NonMacroAttrKind::Tool\n             | NonMacroAttrKind::DeriveHelper\n             | NonMacroAttrKind::DeriveHelperCompat => true,\n-            NonMacroAttrKind::Builtin | NonMacroAttrKind::Registered => false,\n+            NonMacroAttrKind::Builtin(..) | NonMacroAttrKind::Registered => false,\n         }\n     }\n }"}, {"sha": "00ee7b8ec77093c18d0069a98440f6ddba5c4a81", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/edeb631ad0cd6fdf31e2e31ec90e105d1768be28/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edeb631ad0cd6fdf31e2e31ec90e105d1768be28/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=edeb631ad0cd6fdf31e2e31ec90e105d1768be28", "patch": "@@ -1281,11 +1281,6 @@ rustc_queries! {\n     }\n \n     Other {\n-        query dllimport_foreign_items(_: CrateNum)\n-            -> FxHashSet<DefId> {\n-            storage(ArenaCacheSelector<'tcx>)\n-            desc { \"dllimport_foreign_items\" }\n-        }\n         query is_dllimport_foreign_item(def_id: DefId) -> bool {\n             desc { |tcx| \"is_dllimport_foreign_item({})\", tcx.def_path_str(def_id) }\n         }\n@@ -1316,7 +1311,7 @@ rustc_queries! {\n             desc { \"looking up a named region\" }\n         }\n         query is_late_bound_map(_: LocalDefId) ->\n-            Option<&'tcx FxHashSet<ItemLocalId>> {\n+            Option<(LocalDefId, &'tcx FxHashSet<ItemLocalId>)> {\n             desc { \"testing if a region is late bound\" }\n         }\n         query object_lifetime_defaults_map(_: LocalDefId)"}, {"sha": "1f7dc7bb79dfee07ba01a9d6cf1c25342873e0b5", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/edeb631ad0cd6fdf31e2e31ec90e105d1768be28/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edeb631ad0cd6fdf31e2e31ec90e105d1768be28/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=edeb631ad0cd6fdf31e2e31ec90e105d1768be28", "patch": "@@ -3,6 +3,7 @@\n use crate::arena::Arena;\n use crate::dep_graph::DepGraph;\n use crate::hir::exports::ExportMap;\n+use crate::hir::place::Place as HirPlace;\n use crate::ich::{NodeIdHashingMode, StableHashingContext};\n use crate::infer::canonical::{Canonical, CanonicalVarInfo, CanonicalVarInfos};\n use crate::lint::{struct_lint_level, LintDiagnosticBuilder, LintLevelSource};\n@@ -379,7 +380,7 @@ pub struct TypeckResults<'tcx> {\n \n     /// Records the reasons that we picked the kind of each closure;\n     /// not all closures are present in the map.\n-    closure_kind_origins: ItemLocalMap<(Span, Symbol)>,\n+    closure_kind_origins: ItemLocalMap<(Span, HirPlace<'tcx>)>,\n \n     /// For each fn, records the \"liberated\" types of its arguments\n     /// and return type. Liberated means that all bound regions\n@@ -642,11 +643,13 @@ impl<'tcx> TypeckResults<'tcx> {\n         self.upvar_capture_map[&upvar_id]\n     }\n \n-    pub fn closure_kind_origins(&self) -> LocalTableInContext<'_, (Span, Symbol)> {\n+    pub fn closure_kind_origins(&self) -> LocalTableInContext<'_, (Span, HirPlace<'tcx>)> {\n         LocalTableInContext { hir_owner: self.hir_owner, data: &self.closure_kind_origins }\n     }\n \n-    pub fn closure_kind_origins_mut(&mut self) -> LocalTableInContextMut<'_, (Span, Symbol)> {\n+    pub fn closure_kind_origins_mut(\n+        &mut self,\n+    ) -> LocalTableInContextMut<'_, (Span, HirPlace<'tcx>)> {\n         LocalTableInContextMut { hir_owner: self.hir_owner, data: &mut self.closure_kind_origins }\n     }\n \n@@ -2578,7 +2581,8 @@ impl<'tcx> TyCtxt<'tcx> {\n     }\n \n     pub fn is_late_bound(self, id: HirId) -> bool {\n-        self.is_late_bound_map(id.owner).map_or(false, |set| set.contains(&id.local_id))\n+        self.is_late_bound_map(id.owner)\n+            .map_or(false, |(owner, set)| owner == id.owner && set.contains(&id.local_id))\n     }\n \n     pub fn object_lifetime_defaults(self, id: HirId) -> Option<&'tcx [ObjectLifetimeDefault]> {"}, {"sha": "b1769b17b42b5fbc84825827b5a30ed8430bc955", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 40, "deletions": 1, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/edeb631ad0cd6fdf31e2e31ec90e105d1768be28/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edeb631ad0cd6fdf31e2e31ec90e105d1768be28/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=edeb631ad0cd6fdf31e2e31ec90e105d1768be28", "patch": "@@ -17,7 +17,9 @@ pub use self::IntVarValue::*;\n pub use self::Variance::*;\n \n use crate::hir::exports::ExportMap;\n-use crate::hir::place::Place as HirPlace;\n+use crate::hir::place::{\n+    Place as HirPlace, PlaceBase as HirPlaceBase, ProjectionKind as HirProjectionKind,\n+};\n use crate::ich::StableHashingContext;\n use crate::middle::cstore::CrateStoreDyn;\n use crate::middle::resolve_lifetime::ObjectLifetimeDefault;\n@@ -734,6 +736,43 @@ pub struct CapturedPlace<'tcx> {\n     pub info: CaptureInfo<'tcx>,\n }\n \n+pub fn place_to_string_for_capture(tcx: TyCtxt<'tcx>, place: &HirPlace<'tcx>) -> String {\n+    let name = match place.base {\n+        HirPlaceBase::Upvar(upvar_id) => tcx.hir().name(upvar_id.var_path.hir_id).to_string(),\n+        _ => bug!(\"Capture_information should only contain upvars\"),\n+    };\n+    let mut curr_string = name;\n+\n+    for (i, proj) in place.projections.iter().enumerate() {\n+        match proj.kind {\n+            HirProjectionKind::Deref => {\n+                curr_string = format!(\"*{}\", curr_string);\n+            }\n+            HirProjectionKind::Field(idx, variant) => match place.ty_before_projection(i).kind() {\n+                ty::Adt(def, ..) => {\n+                    curr_string = format!(\n+                        \"{}.{}\",\n+                        curr_string,\n+                        def.variants[variant].fields[idx as usize].ident.name.as_str()\n+                    );\n+                }\n+                ty::Tuple(_) => {\n+                    curr_string = format!(\"{}.{}\", curr_string, idx);\n+                }\n+                _ => {\n+                    bug!(\n+                        \"Field projection applied to a type other than Adt or Tuple: {:?}.\",\n+                        place.ty_before_projection(i).kind()\n+                    )\n+                }\n+            },\n+            proj => bug!(\"{:?} unexpected because it isn't captured\", proj),\n+        }\n+    }\n+\n+    curr_string.to_string()\n+}\n+\n /// Part of `MinCaptureInformationMap`; describes the capture kind (&, &mut, move)\n /// for a particular capture as well as identifying the part of the source code\n /// that triggered this capture to occur."}, {"sha": "9f97d5c9af7d8edfa54ba7db1d9a7bc0edb500e2", "filename": "compiler/rustc_mir/src/borrow_check/diagnostics/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/edeb631ad0cd6fdf31e2e31ec90e105d1768be28/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edeb631ad0cd6fdf31e2e31ec90e105d1768be28/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fmod.rs?ref=edeb631ad0cd6fdf31e2e31ec90e105d1768be28", "patch": "@@ -103,15 +103,15 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                         let did = did.expect_local();\n                         let hir_id = self.infcx.tcx.hir().local_def_id_to_hir_id(did);\n \n-                        if let Some((span, name)) =\n+                        if let Some((span, hir_place)) =\n                             self.infcx.tcx.typeck(did).closure_kind_origins().get(hir_id)\n                         {\n                             diag.span_note(\n                                 *span,\n                                 &format!(\n                                     \"closure cannot be invoked more than once because it moves the \\\n                                     variable `{}` out of its environment\",\n-                                    name,\n+                                    ty::place_to_string_for_capture(self.infcx.tcx, hir_place)\n                                 ),\n                             );\n                             return;\n@@ -127,15 +127,15 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 let did = did.expect_local();\n                 let hir_id = self.infcx.tcx.hir().local_def_id_to_hir_id(did);\n \n-                if let Some((span, name)) =\n+                if let Some((span, hir_place)) =\n                     self.infcx.tcx.typeck(did).closure_kind_origins().get(hir_id)\n                 {\n                     diag.span_note(\n                         *span,\n                         &format!(\n                             \"closure cannot be moved more than once as it is not `Copy` due to \\\n                              moving the variable `{}` out of its environment\",\n-                            name\n+                            ty::place_to_string_for_capture(self.infcx.tcx, hir_place)\n                         ),\n                     );\n                 }"}, {"sha": "157959b115947fad19da82cdff593fa8f92bf937", "filename": "compiler/rustc_mir/src/borrow_check/type_check/input_output.rs", "status": "modified", "additions": 12, "deletions": 16, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/edeb631ad0cd6fdf31e2e31ec90e105d1768be28/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Ftype_check%2Finput_output.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edeb631ad0cd6fdf31e2e31ec90e105d1768be28/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Ftype_check%2Finput_output.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Ftype_check%2Finput_output.rs?ref=edeb631ad0cd6fdf31e2e31ec90e105d1768be28", "patch": "@@ -39,10 +39,8 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n             user_provided_sig = None;\n         } else {\n             let typeck_results = self.tcx().typeck(mir_def_id);\n-            user_provided_sig = match typeck_results.user_provided_sigs.get(&mir_def_id.to_def_id())\n-            {\n-                None => None,\n-                Some(user_provided_poly_sig) => {\n+            user_provided_sig = typeck_results.user_provided_sigs.get(&mir_def_id.to_def_id()).map(\n+                |user_provided_poly_sig| {\n                     // Instantiate the canonicalized variables from\n                     // user-provided signature (e.g., the `_` in the code\n                     // above) with fresh variables.\n@@ -54,18 +52,16 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                     // Replace the bound items in the fn sig with fresh\n                     // variables, so that they represent the view from\n                     // \"inside\" the closure.\n-                    Some(\n-                        self.infcx\n-                            .replace_bound_vars_with_fresh_vars(\n-                                body.span,\n-                                LateBoundRegionConversionTime::FnCall,\n-                                poly_sig,\n-                            )\n-                            .0,\n-                    )\n-                }\n-            }\n-        };\n+                    self.infcx\n+                        .replace_bound_vars_with_fresh_vars(\n+                            body.span,\n+                            LateBoundRegionConversionTime::FnCall,\n+                            poly_sig,\n+                        )\n+                        .0\n+                },\n+            );\n+        }\n \n         debug!(\n             \"equate_inputs_and_outputs: normalized_input_tys = {:?}, local_decls = {:?}\","}, {"sha": "02d951b70e28d4c29402e63bff6d3d17c2b96692", "filename": "compiler/rustc_mir/src/borrow_check/universal_regions.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/edeb631ad0cd6fdf31e2e31ec90e105d1768be28/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Funiversal_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edeb631ad0cd6fdf31e2e31ec90e105d1768be28/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Funiversal_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Funiversal_regions.rs?ref=edeb631ad0cd6fdf31e2e31ec90e105d1768be28", "patch": "@@ -788,13 +788,13 @@ fn for_each_late_bound_region_defined_on<'tcx>(\n     fn_def_id: DefId,\n     mut f: impl FnMut(ty::Region<'tcx>),\n ) {\n-    if let Some(late_bounds) = tcx.is_late_bound_map(fn_def_id.expect_local()) {\n-        for late_bound in late_bounds.iter() {\n-            let hir_id = HirId { owner: fn_def_id.expect_local(), local_id: *late_bound };\n+    if let Some((owner, late_bounds)) = tcx.is_late_bound_map(fn_def_id.expect_local()) {\n+        for &late_bound in late_bounds.iter() {\n+            let hir_id = HirId { owner, local_id: late_bound };\n             let name = tcx.hir().name(hir_id);\n             let region_def_id = tcx.hir().local_def_id(hir_id);\n             let liberated_region = tcx.mk_region(ty::ReFree(ty::FreeRegion {\n-                scope: fn_def_id,\n+                scope: owner.to_def_id(),\n                 bound_region: ty::BoundRegionKind::BrNamed(region_def_id.to_def_id(), name),\n             }));\n             f(liberated_region);"}, {"sha": "4ab14c158d337835fce8661db6534596602e17d3", "filename": "compiler/rustc_resolve/src/build_reduced_graph.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/edeb631ad0cd6fdf31e2e31ec90e105d1768be28/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edeb631ad0cd6fdf31e2e31ec90e105d1768be28/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs?ref=edeb631ad0cd6fdf31e2e31ec90e105d1768be28", "patch": "@@ -115,7 +115,7 @@ impl<'a> Resolver<'a> {\n         self.get_module(parent_id)\n     }\n \n-    crate fn get_module(&mut self, def_id: DefId) -> Module<'a> {\n+    pub fn get_module(&mut self, def_id: DefId) -> Module<'a> {\n         // If this is a local module, it will be in `module_map`, no need to recalculate it.\n         if let Some(def_id) = def_id.as_local() {\n             return self.module_map[&def_id];"}, {"sha": "69fb6870d2c671e5b10f81435b2eb3f1521ddef2", "filename": "compiler/rustc_resolve/src/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/edeb631ad0cd6fdf31e2e31ec90e105d1768be28/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edeb631ad0cd6fdf31e2e31ec90e105d1768be28/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs?ref=edeb631ad0cd6fdf31e2e31ec90e105d1768be28", "patch": "@@ -683,7 +683,7 @@ impl<'a> Resolver<'a> {\n                     ));\n                 }\n                 Scope::BuiltinAttrs => {\n-                    let res = Res::NonMacroAttr(NonMacroAttrKind::Builtin);\n+                    let res = Res::NonMacroAttr(NonMacroAttrKind::Builtin(kw::Empty));\n                     if filter_fn(res) {\n                         suggestions.extend(\n                             BUILTIN_ATTRIBUTES"}, {"sha": "97e556f5a338dcdc49cf32d3c5f13b42543e43ed", "filename": "compiler/rustc_resolve/src/late.rs", "status": "modified", "additions": 10, "deletions": 62, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/edeb631ad0cd6fdf31e2e31ec90e105d1768be28/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edeb631ad0cd6fdf31e2e31ec90e105d1768be28/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate.rs?ref=edeb631ad0cd6fdf31e2e31ec90e105d1768be28", "patch": "@@ -14,7 +14,6 @@ use crate::{ResolutionError, Resolver, Segment, UseError};\n use rustc_ast::ptr::P;\n use rustc_ast::visit::{self, AssocCtxt, FnCtxt, FnKind, Visitor};\n use rustc_ast::*;\n-use rustc_ast::{unwrap_or, walk_list};\n use rustc_ast_lowering::ResolverAstLowering;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_errors::DiagnosticId;\n@@ -1911,7 +1910,7 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                 // it needs to be added to the trait map.\n                 if ns == ValueNS {\n                     let item_name = path.last().unwrap().ident;\n-                    let traits = self.get_traits_containing_item(item_name, ns);\n+                    let traits = self.traits_in_scope(item_name, ns);\n                     self.r.trait_map.insert(id, traits);\n                 }\n \n@@ -2371,12 +2370,12 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                 // field, we need to add any trait methods we find that match\n                 // the field name so that we can do some nice error reporting\n                 // later on in typeck.\n-                let traits = self.get_traits_containing_item(ident, ValueNS);\n+                let traits = self.traits_in_scope(ident, ValueNS);\n                 self.r.trait_map.insert(expr.id, traits);\n             }\n             ExprKind::MethodCall(ref segment, ..) => {\n                 debug!(\"(recording candidate traits for expr) recording traits for {}\", expr.id);\n-                let traits = self.get_traits_containing_item(segment.ident, ValueNS);\n+                let traits = self.traits_in_scope(segment.ident, ValueNS);\n                 self.r.trait_map.insert(expr.id, traits);\n             }\n             _ => {\n@@ -2385,64 +2384,13 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n         }\n     }\n \n-    fn get_traits_containing_item(\n-        &mut self,\n-        mut ident: Ident,\n-        ns: Namespace,\n-    ) -> Vec<TraitCandidate> {\n-        debug!(\"(getting traits containing item) looking for '{}'\", ident.name);\n-\n-        let mut found_traits = Vec::new();\n-        // Look for the current trait.\n-        if let Some((module, _)) = self.current_trait_ref {\n-            if self\n-                .r\n-                .resolve_ident_in_module(\n-                    ModuleOrUniformRoot::Module(module),\n-                    ident,\n-                    ns,\n-                    &self.parent_scope,\n-                    false,\n-                    module.span,\n-                )\n-                .is_ok()\n-            {\n-                let def_id = module.def_id().unwrap();\n-                found_traits.push(TraitCandidate { def_id, import_ids: smallvec![] });\n-            }\n-        }\n-\n-        ident.span = ident.span.normalize_to_macros_2_0();\n-        let mut search_module = self.parent_scope.module;\n-        loop {\n-            self.r.get_traits_in_module_containing_item(\n-                ident,\n-                ns,\n-                search_module,\n-                &mut found_traits,\n-                &self.parent_scope,\n-            );\n-            let mut span_data = ident.span.data();\n-            search_module = unwrap_or!(\n-                self.r.hygienic_lexical_parent(search_module, &mut span_data.ctxt),\n-                break\n-            );\n-            ident.span = span_data.span();\n-        }\n-\n-        if let Some(prelude) = self.r.prelude {\n-            if !search_module.no_implicit_prelude {\n-                self.r.get_traits_in_module_containing_item(\n-                    ident,\n-                    ns,\n-                    prelude,\n-                    &mut found_traits,\n-                    &self.parent_scope,\n-                );\n-            }\n-        }\n-\n-        found_traits\n+    fn traits_in_scope(&mut self, ident: Ident, ns: Namespace) -> Vec<TraitCandidate> {\n+        self.r.traits_in_scope(\n+            self.current_trait_ref.as_ref().map(|(module, _)| *module),\n+            &self.parent_scope,\n+            ident.span.ctxt(),\n+            Some((ident.name, ns)),\n+        )\n     }\n }\n "}, {"sha": "1be06a446875bb9b927d9cba3ab313c464552b44", "filename": "compiler/rustc_resolve/src/late/lifetimes.rs", "status": "modified", "additions": 30, "deletions": 2, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/edeb631ad0cd6fdf31e2e31ec90e105d1768be28/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edeb631ad0cd6fdf31e2e31ec90e105d1768be28/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs?ref=edeb631ad0cd6fdf31e2e31ec90e105d1768be28", "patch": "@@ -11,7 +11,8 @@ use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_errors::{struct_span_err, Applicability, DiagnosticBuilder};\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n-use rustc_hir::def_id::{CrateNum, DefId, DefIdMap, LOCAL_CRATE};\n+use rustc_hir::def_id::{CrateNum, DefIdMap, LOCAL_CRATE};\n+use rustc_hir::hir_id::ItemLocalId;\n use rustc_hir::intravisit::{self, NestedVisitorMap, Visitor};\n use rustc_hir::{GenericArg, GenericParam, LifetimeName, Node, ParamName, QPath};\n use rustc_hir::{GenericParamKind, HirIdMap, HirIdSet, LifetimeParamKind};\n@@ -20,6 +21,7 @@ use rustc_middle::middle::resolve_lifetime::*;\n use rustc_middle::ty::{self, DefIdTree, GenericParamDefKind, TyCtxt};\n use rustc_middle::{bug, span_bug};\n use rustc_session::lint;\n+use rustc_span::def_id::{DefId, LocalDefId};\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::Span;\n use std::borrow::Cow;\n@@ -284,7 +286,7 @@ pub fn provide(providers: &mut ty::query::Providers) {\n         resolve_lifetimes,\n \n         named_region_map: |tcx, id| tcx.resolve_lifetimes(LOCAL_CRATE).defs.get(&id),\n-        is_late_bound_map: |tcx, id| tcx.resolve_lifetimes(LOCAL_CRATE).late_bound.get(&id),\n+        is_late_bound_map,\n         object_lifetime_defaults_map: |tcx, id| {\n             tcx.resolve_lifetimes(LOCAL_CRATE).object_lifetime_defaults.get(&id)\n         },\n@@ -320,6 +322,32 @@ fn resolve_lifetimes(tcx: TyCtxt<'_>, for_krate: CrateNum) -> ResolveLifetimes {\n     rl\n }\n \n+fn is_late_bound_map<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    def_id: LocalDefId,\n+) -> Option<(LocalDefId, &'tcx FxHashSet<ItemLocalId>)> {\n+    match tcx.def_kind(def_id) {\n+        DefKind::AnonConst => {\n+            let mut def_id = tcx\n+                .parent(def_id.to_def_id())\n+                .unwrap_or_else(|| bug!(\"anon const or closure without a parent\"));\n+            // We search for the next outer anon const or fn here\n+            // while skipping closures.\n+            //\n+            // Note that for `AnonConst` we still just recurse until we\n+            // find a function body, but who cares :shrug:\n+            while tcx.is_closure(def_id) {\n+                def_id = tcx\n+                    .parent(def_id)\n+                    .unwrap_or_else(|| bug!(\"anon const or closure without a parent\"));\n+            }\n+\n+            tcx.is_late_bound_map(def_id.expect_local())\n+        }\n+        _ => tcx.resolve_lifetimes(LOCAL_CRATE).late_bound.get(&def_id).map(|lt| (def_id, lt)),\n+    }\n+}\n+\n fn krate(tcx: TyCtxt<'_>) -> NamedRegionMap {\n     let krate = tcx.hir().krate();\n     let mut map = NamedRegionMap {"}, {"sha": "af5341623758a076e0481efa6ca0b5560cffc03c", "filename": "compiler/rustc_resolve/src/lib.rs", "status": "modified", "additions": 63, "deletions": 64, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/edeb631ad0cd6fdf31e2e31ec90e105d1768be28/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edeb631ad0cd6fdf31e2e31ec90e105d1768be28/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flib.rs?ref=edeb631ad0cd6fdf31e2e31ec90e105d1768be28", "patch": "@@ -44,9 +44,9 @@ use rustc_index::vec::IndexVec;\n use rustc_metadata::creader::{CStore, CrateLoader};\n use rustc_middle::hir::exports::ExportMap;\n use rustc_middle::middle::cstore::{CrateStore, MetadataLoaderDyn};\n+use rustc_middle::span_bug;\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::{self, DefIdTree, ResolverOutputs};\n-use rustc_middle::{bug, span_bug};\n use rustc_session::lint;\n use rustc_session::lint::{BuiltinLintDiagnostics, LintBuffer};\n use rustc_session::Session;\n@@ -1477,49 +1477,76 @@ impl<'a> Resolver<'a> {\n         self.crate_loader.postprocess(krate);\n     }\n \n-    fn get_traits_in_module_containing_item(\n+    pub fn traits_in_scope(\n+        &mut self,\n+        current_trait: Option<Module<'a>>,\n+        parent_scope: &ParentScope<'a>,\n+        ctxt: SyntaxContext,\n+        assoc_item: Option<(Symbol, Namespace)>,\n+    ) -> Vec<TraitCandidate> {\n+        let mut found_traits = Vec::new();\n+\n+        if let Some(module) = current_trait {\n+            if self.trait_may_have_item(Some(module), assoc_item) {\n+                let def_id = module.def_id().unwrap();\n+                found_traits.push(TraitCandidate { def_id, import_ids: smallvec![] });\n+            }\n+        }\n+\n+        self.visit_scopes(ScopeSet::All(TypeNS, false), parent_scope, ctxt, |this, scope, _, _| {\n+            match scope {\n+                Scope::Module(module) => {\n+                    this.traits_in_module(module, assoc_item, &mut found_traits);\n+                }\n+                Scope::StdLibPrelude => {\n+                    if let Some(module) = this.prelude {\n+                        this.traits_in_module(module, assoc_item, &mut found_traits);\n+                    }\n+                }\n+                Scope::ExternPrelude | Scope::ToolPrelude | Scope::BuiltinTypes => {}\n+                _ => unreachable!(),\n+            }\n+            None::<()>\n+        });\n+\n+        found_traits\n+    }\n+\n+    fn traits_in_module(\n         &mut self,\n-        ident: Ident,\n-        ns: Namespace,\n         module: Module<'a>,\n+        assoc_item: Option<(Symbol, Namespace)>,\n         found_traits: &mut Vec<TraitCandidate>,\n-        parent_scope: &ParentScope<'a>,\n     ) {\n-        assert!(ns == TypeNS || ns == ValueNS);\n         module.ensure_traits(self);\n         let traits = module.traits.borrow();\n+        for (trait_name, trait_binding) in traits.as_ref().unwrap().iter() {\n+            if self.trait_may_have_item(trait_binding.module(), assoc_item) {\n+                let def_id = trait_binding.res().def_id();\n+                let import_ids = self.find_transitive_imports(&trait_binding.kind, *trait_name);\n+                found_traits.push(TraitCandidate { def_id, import_ids });\n+            }\n+        }\n+    }\n \n-        for &(trait_name, binding) in traits.as_ref().unwrap().iter() {\n-            // Traits have pseudo-modules that can be used to search for the given ident.\n-            if let Some(module) = binding.module() {\n-                let mut ident = ident;\n-                if ident.span.glob_adjust(module.expansion, binding.span).is_none() {\n-                    continue;\n-                }\n-                if self\n-                    .resolve_ident_in_module_unadjusted(\n-                        ModuleOrUniformRoot::Module(module),\n-                        ident,\n-                        ns,\n-                        parent_scope,\n-                        false,\n-                        module.span,\n-                    )\n-                    .is_ok()\n-                {\n-                    let import_ids = self.find_transitive_imports(&binding.kind, trait_name);\n-                    let trait_def_id = module.def_id().unwrap();\n-                    found_traits.push(TraitCandidate { def_id: trait_def_id, import_ids });\n-                }\n-            } else if let Res::Def(DefKind::TraitAlias, _) = binding.res() {\n-                // For now, just treat all trait aliases as possible candidates, since we don't\n-                // know if the ident is somewhere in the transitive bounds.\n-                let import_ids = self.find_transitive_imports(&binding.kind, trait_name);\n-                let trait_def_id = binding.res().def_id();\n-                found_traits.push(TraitCandidate { def_id: trait_def_id, import_ids });\n-            } else {\n-                bug!(\"candidate is not trait or trait alias?\")\n+    // List of traits in scope is pruned on best effort basis. We reject traits not having an\n+    // associated item with the given name and namespace (if specified). This is a conservative\n+    // optimization, proper hygienic type-based resolution of associated items is done in typeck.\n+    // We don't reject trait aliases (`trait_module == None`) because we don't have access to their\n+    // associated items.\n+    fn trait_may_have_item(\n+        &mut self,\n+        trait_module: Option<Module<'a>>,\n+        assoc_item: Option<(Symbol, Namespace)>,\n+    ) -> bool {\n+        match (trait_module, assoc_item) {\n+            (Some(trait_module), Some((name, ns))) => {\n+                self.resolutions(trait_module).borrow().iter().any(|resolution| {\n+                    let (&BindingKey { ident: assoc_ident, ns: assoc_ns, .. }, _) = resolution;\n+                    assoc_ns == ns && assoc_ident.name == name\n+                })\n             }\n+            _ => true,\n         }\n     }\n \n@@ -3227,34 +3254,6 @@ impl<'a> Resolver<'a> {\n         })\n     }\n \n-    /// This is equivalent to `get_traits_in_module_containing_item`, but without filtering by the associated item.\n-    ///\n-    /// This is used by rustdoc for intra-doc links.\n-    pub fn traits_in_scope(&mut self, module_id: DefId) -> Vec<TraitCandidate> {\n-        let module = self.get_module(module_id);\n-        module.ensure_traits(self);\n-        let traits = module.traits.borrow();\n-        let to_candidate =\n-            |this: &mut Self, &(trait_name, binding): &(Ident, &NameBinding<'_>)| TraitCandidate {\n-                def_id: binding.res().def_id(),\n-                import_ids: this.find_transitive_imports(&binding.kind, trait_name),\n-            };\n-\n-        let mut candidates: Vec<_> =\n-            traits.as_ref().unwrap().iter().map(|x| to_candidate(self, x)).collect();\n-\n-        if let Some(prelude) = self.prelude {\n-            if !module.no_implicit_prelude {\n-                prelude.ensure_traits(self);\n-                candidates.extend(\n-                    prelude.traits.borrow().as_ref().unwrap().iter().map(|x| to_candidate(self, x)),\n-                );\n-            }\n-        }\n-\n-        candidates\n-    }\n-\n     /// Rustdoc uses this to resolve things in a recoverable way. `ResolutionError<'a>`\n     /// isn't something that can be returned because it can't be made to live that long,\n     /// and also it's a private type. Fortunately rustdoc doesn't need to know the error,"}, {"sha": "5d6120cd310761ecbee0257a1011c34721368d0c", "filename": "compiler/rustc_resolve/src/macros.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/edeb631ad0cd6fdf31e2e31ec90e105d1768be28/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edeb631ad0cd6fdf31e2e31ec90e105d1768be28/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs?ref=edeb631ad0cd6fdf31e2e31ec90e105d1768be28", "patch": "@@ -757,7 +757,11 @@ impl<'a> Resolver<'a> {\n                     }\n                     Scope::BuiltinAttrs => {\n                         if is_builtin_attr_name(ident.name) {\n-                            ok(Res::NonMacroAttr(NonMacroAttrKind::Builtin), DUMMY_SP, this.arenas)\n+                            ok(\n+                                Res::NonMacroAttr(NonMacroAttrKind::Builtin(ident.name)),\n+                                DUMMY_SP,\n+                                this.arenas,\n+                            )\n                         } else {\n                             Err(Determinacy::Determined)\n                         }\n@@ -810,13 +814,15 @@ impl<'a> Resolver<'a> {\n                             // Found another solution, if the first one was \"weak\", report an error.\n                             let (res, innermost_res) = (binding.res(), innermost_binding.res());\n                             if res != innermost_res {\n-                                let builtin = Res::NonMacroAttr(NonMacroAttrKind::Builtin);\n+                                let is_builtin = |res| {\n+                                    matches!(res, Res::NonMacroAttr(NonMacroAttrKind::Builtin(..)))\n+                                };\n                                 let derive_helper_compat =\n                                     Res::NonMacroAttr(NonMacroAttrKind::DeriveHelperCompat);\n \n                                 let ambiguity_error_kind = if is_import {\n                                     Some(AmbiguityKind::Import)\n-                                } else if innermost_res == builtin || res == builtin {\n+                                } else if is_builtin(innermost_res) || is_builtin(res) {\n                                     Some(AmbiguityKind::BuiltinAttr)\n                                 } else if innermost_res == derive_helper_compat\n                                     || res == derive_helper_compat"}, {"sha": "e78ccb3521914efd68fdca6629ea0012e84ed2b2", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/edeb631ad0cd6fdf31e2e31ec90e105d1768be28/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edeb631ad0cd6fdf31e2e31ec90e105d1768be28/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=edeb631ad0cd6fdf31e2e31ec90e105d1768be28", "patch": "@@ -589,23 +589,23 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                         if let Some(typeck_results) = self.in_progress_typeck_results {\n                             let typeck_results = typeck_results.borrow();\n                             match (found_kind, typeck_results.closure_kind_origins().get(hir_id)) {\n-                                (ty::ClosureKind::FnOnce, Some((span, name))) => {\n+                                (ty::ClosureKind::FnOnce, Some((span, place))) => {\n                                     err.span_label(\n                                         *span,\n                                         format!(\n                                             \"closure is `FnOnce` because it moves the \\\n                                          variable `{}` out of its environment\",\n-                                            name\n+                                            ty::place_to_string_for_capture(tcx, place)\n                                         ),\n                                     );\n                                 }\n-                                (ty::ClosureKind::FnMut, Some((span, name))) => {\n+                                (ty::ClosureKind::FnMut, Some((span, place))) => {\n                                     err.span_label(\n                                         *span,\n                                         format!(\n                                             \"closure is `FnMut` because it mutates the \\\n                                          variable `{}` here\",\n-                                            name\n+                                            ty::place_to_string_for_capture(tcx, place)\n                                         ),\n                                     );\n                                 }"}, {"sha": "d37d6bc4f2df657465a80a083abdbb90cfa1a4b6", "filename": "compiler/rustc_typeck/src/check/compare_method.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/edeb631ad0cd6fdf31e2e31ec90e105d1768be28/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edeb631ad0cd6fdf31e2e31ec90e105d1768be28/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcompare_method.rs?ref=edeb631ad0cd6fdf31e2e31ec90e105d1768be28", "patch": "@@ -365,12 +365,10 @@ fn check_region_bounds_on_impl_item<'tcx>(\n         let item_kind = assoc_item_kind_str(impl_m);\n         let def_span = tcx.sess.source_map().guess_head_span(span);\n         let span = tcx.hir().get_generics(impl_m.def_id).map_or(def_span, |g| g.span);\n-        let generics_span = if let Some(sp) = tcx.hir().span_if_local(trait_m.def_id) {\n+        let generics_span = tcx.hir().span_if_local(trait_m.def_id).map(|sp| {\n             let def_sp = tcx.sess.source_map().guess_head_span(sp);\n-            Some(tcx.hir().get_generics(trait_m.def_id).map_or(def_sp, |g| g.span))\n-        } else {\n-            None\n-        };\n+            tcx.hir().get_generics(trait_m.def_id).map_or(def_sp, |g| g.span)\n+        });\n \n         tcx.sess.emit_err(LifetimesOrBoundsMismatchOnTrait {\n             span,"}, {"sha": "feda35daa617d09b298f600fd7b97e3a4f836f2e", "filename": "compiler/rustc_typeck/src/check/upvar.rs", "status": "modified", "additions": 18, "deletions": 8, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/edeb631ad0cd6fdf31e2e31ec90e105d1768be28/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edeb631ad0cd6fdf31e2e31ec90e105d1768be28/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs?ref=edeb631ad0cd6fdf31e2e31ec90e105d1768be28", "patch": "@@ -176,7 +176,17 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             self.demand_eqtype(span, inferred_kind.to_ty(self.tcx), closure_kind_ty);\n \n             // If we have an origin, store it.\n-            if let Some(origin) = delegate.current_origin {\n+            if let Some(origin) = delegate.current_origin.clone() {\n+                let origin = if self.tcx.features().capture_disjoint_fields {\n+                    origin\n+                } else {\n+                    // FIXME(project-rfc-2229#26): Once rust-lang#80092 is merged, we should restrict the\n+                    // precision of origin as well. Otherwise, this will cause issues when project-rfc-2229#26\n+                    // is fixed as we might see Index projections in the origin, which we can't print because\n+                    // we don't store enough information.\n+                    (origin.0, Place { projections: vec![], ..origin.1 })\n+                };\n+\n                 self.typeck_results\n                     .borrow_mut()\n                     .closure_kind_origins_mut()\n@@ -563,7 +573,7 @@ struct InferBorrowKind<'a, 'tcx> {\n \n     // If we modified `current_closure_kind`, this field contains a `Some()` with the\n     // variable access that caused us to do so.\n-    current_origin: Option<(Span, Symbol)>,\n+    current_origin: Option<(Span, Place<'tcx>)>,\n \n     /// For each Place that is captured by the closure, we track the minimal kind of\n     /// access we need (ref, ref mut, move, etc) and the expression that resulted in such access.\n@@ -628,7 +638,7 @@ impl<'a, 'tcx> InferBorrowKind<'a, 'tcx> {\n             upvar_id.closure_expr_id,\n             ty::ClosureKind::FnOnce,\n             usage_span,\n-            var_name(tcx, upvar_id.var_path.hir_id),\n+            place_with_id.place.clone(),\n         );\n \n         let capture_info = ty::CaptureInfo {\n@@ -720,7 +730,7 @@ impl<'a, 'tcx> InferBorrowKind<'a, 'tcx> {\n                 upvar_id.closure_expr_id,\n                 ty::ClosureKind::FnMut,\n                 tcx.hir().span(diag_expr_id),\n-                var_name(tcx, upvar_id.var_path.hir_id),\n+                place_with_id.place.clone(),\n             );\n         }\n     }\n@@ -765,11 +775,11 @@ impl<'a, 'tcx> InferBorrowKind<'a, 'tcx> {\n         closure_id: LocalDefId,\n         new_kind: ty::ClosureKind,\n         upvar_span: Span,\n-        var_name: Symbol,\n+        place: Place<'tcx>,\n     ) {\n         debug!(\n-            \"adjust_closure_kind(closure_id={:?}, new_kind={:?}, upvar_span={:?}, var_name={})\",\n-            closure_id, new_kind, upvar_span, var_name\n+            \"adjust_closure_kind(closure_id={:?}, new_kind={:?}, upvar_span={:?}, place={:?})\",\n+            closure_id, new_kind, upvar_span, place\n         );\n \n         // Is this the closure whose kind is currently being inferred?\n@@ -797,7 +807,7 @@ impl<'a, 'tcx> InferBorrowKind<'a, 'tcx> {\n             | (ty::ClosureKind::FnMut, ty::ClosureKind::FnOnce) => {\n                 // new kind is stronger than the old kind\n                 self.current_closure_kind = new_kind;\n-                self.current_origin = Some((upvar_span, var_name));\n+                self.current_origin = Some((upvar_span, place));\n             }\n         }\n     }"}, {"sha": "6edce62f76bc92aa4c63f9e5eda7920d5350b3db", "filename": "compiler/rustc_typeck/src/check/writeback.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/edeb631ad0cd6fdf31e2e31ec90e105d1768be28/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edeb631ad0cd6fdf31e2e31ec90e105d1768be28/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwriteback.rs?ref=edeb631ad0cd6fdf31e2e31ec90e105d1768be28", "patch": "@@ -384,9 +384,11 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n         assert_eq!(fcx_typeck_results.hir_owner, self.typeck_results.hir_owner);\n         let common_hir_owner = fcx_typeck_results.hir_owner;\n \n-        for (&id, &origin) in fcx_typeck_results.closure_kind_origins().iter() {\n-            let hir_id = hir::HirId { owner: common_hir_owner, local_id: id };\n-            self.typeck_results.closure_kind_origins_mut().insert(hir_id, origin);\n+        for (id, origin) in fcx_typeck_results.closure_kind_origins().iter() {\n+            let hir_id = hir::HirId { owner: common_hir_owner, local_id: *id };\n+            let place_span = origin.0;\n+            let place = self.resolve(origin.1.clone(), &place_span);\n+            self.typeck_results.closure_kind_origins_mut().insert(hir_id, (place_span, place));\n         }\n     }\n "}, {"sha": "55b20adabd0451d4dac3312ff5c3da080ceda7f6", "filename": "config.toml.example", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/edeb631ad0cd6fdf31e2e31ec90e105d1768be28/config.toml.example", "raw_url": "https://github.com/rust-lang/rust/raw/edeb631ad0cd6fdf31e2e31ec90e105d1768be28/config.toml.example", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/config.toml.example?ref=edeb631ad0cd6fdf31e2e31ec90e105d1768be28", "patch": "@@ -35,9 +35,11 @@ changelog-seen = 2\n # Unless you're developing for a target where Rust CI doesn't build a compiler\n # toolchain or changing LLVM locally, you probably want to set this to true.\n #\n-# It's currently false by default due to being newly added; please file bugs if\n-# enabling this did not work for you on x86_64-unknown-linux-gnu.\n-# Other target triples are currently not supported; see #77084.\n+# This is false by default so that distributions don't unexpectedly download\n+# LLVM from the internet.\n+#\n+# All tier 1 targets are currently supported; set this to `\"if-supported\"` if\n+# you are not sure whether you're on a tier 1 target.\n #\n # We also currently only support this when building LLVM for the build triple.\n #"}, {"sha": "928c6f9a3a88d41b35eed9d42880c97662261ed2", "filename": "library/alloc/src/collections/btree/node.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/edeb631ad0cd6fdf31e2e31ec90e105d1768be28/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edeb631ad0cd6fdf31e2e31ec90e105d1768be28/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs?ref=edeb631ad0cd6fdf31e2e31ec90e105d1768be28", "patch": "@@ -184,7 +184,7 @@ impl<K, V> NodeRef<marker::Owned, K, V, marker::LeafOrInternal> {\n \n     /// Removes the internal root node, using its first child as the new root node.\n     /// As it is intended only to be called when the root node has only one child,\n-    /// no cleanup is done on any of the other children.\n+    /// no cleanup is done on any of the keys, values and other children.\n     /// This decreases the height by 1 and is the opposite of `push_internal_level`.\n     ///\n     /// Requires exclusive access to the `Root` object but not to the root node;\n@@ -225,7 +225,7 @@ impl<K, V> NodeRef<marker::Owned, K, V, marker::LeafOrInternal> {\n ///    - When this is `Owned`, the `NodeRef` acts roughly like `Box<Node>`,\n ///      but does not have a destructor, and must be cleaned up manually.\n ///   Since any `NodeRef` allows navigating through the tree, `BorrowType`\n-///   effectively applies to the entire tree, not just the node itself.\n+///   effectively applies to the entire tree, not just to the node itself.\n /// - `K` and `V`: These are the types of keys and values stored in the nodes.\n /// - `Type`: This can be `Leaf`, `Internal`, or `LeafOrInternal`. When this is\n ///   `Leaf`, the `NodeRef` points to a leaf node, when this is `Internal` the\n@@ -425,7 +425,7 @@ impl<'a, K: 'a, V: 'a, Type> NodeRef<marker::Immut<'a>, K, V, Type> {\n \n impl<K, V> NodeRef<marker::Owned, K, V, marker::LeafOrInternal> {\n     /// Similar to `ascend`, gets a reference to a node's parent node, but also\n-    /// deallocate the current node in the process. This is unsafe because the\n+    /// deallocates the current node in the process. This is unsafe because the\n     /// current node will still be accessible despite being deallocated.\n     pub unsafe fn deallocate_and_ascend(\n         self,\n@@ -661,7 +661,10 @@ impl<'a, K: 'a, V: 'a> NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal> {\n     /// Removes a key-value pair from the end of the node and returns the pair.\n     /// Also removes the edge that was to the right of that pair and, if the node\n     /// is internal, returns the orphaned subtree that this edge owned.\n-    fn pop(&mut self) -> (K, V, Option<Root<K, V>>) {\n+    ///\n+    /// # Safety\n+    /// The node must not be empty.\n+    unsafe fn pop(&mut self) -> (K, V, Option<Root<K, V>>) {\n         debug_assert!(self.len() > 0);\n \n         let idx = self.len() - 1;"}, {"sha": "efe94ef175ce756204585fc36c3701d14b0e8b9b", "filename": "library/alloc/src/collections/btree/search.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/edeb631ad0cd6fdf31e2e31ec90e105d1768be28/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edeb631ad0cd6fdf31e2e31ec90e105d1768be28/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fsearch.rs?ref=edeb631ad0cd6fdf31e2e31ec90e105d1768be28", "patch": "@@ -12,8 +12,7 @@ pub enum SearchResult<BorrowType, K, V, FoundType, GoDownType> {\n \n /// Looks up a given key in a (sub)tree headed by the given node, recursively.\n /// Returns a `Found` with the handle of the matching KV, if any. Otherwise,\n-/// returns a `GoDown` with the handle of the possible leaf edge where the key\n-/// belongs.\n+/// returns a `GoDown` with the handle of the leaf edge where the key belongs.\n ///\n /// The result is meaningful only if the tree is ordered by key, like the tree\n /// in a `BTreeMap` is."}, {"sha": "14a10aac061a4bb4ed519bf52e2d15a56f400016", "filename": "library/alloc/src/lib.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/edeb631ad0cd6fdf31e2e31ec90e105d1768be28/library%2Falloc%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edeb631ad0cd6fdf31e2e31ec90e105d1768be28/library%2Falloc%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Flib.rs?ref=edeb631ad0cd6fdf31e2e31ec90e105d1768be28", "patch": "@@ -140,6 +140,7 @@\n #![feature(type_alias_impl_trait)]\n #![feature(associated_type_bounds)]\n #![feature(slice_group_by)]\n+#![feature(decl_macro)]\n // Allow testing this library\n \n #[cfg(test)]\n@@ -193,4 +194,11 @@ mod std {\n #[unstable(feature = \"liballoc_internals\", issue = \"none\", reason = \"implementation detail\")]\n pub mod __export {\n     pub use core::format_args;\n+\n+    /// Force AST node to an expression to improve diagnostics in pattern position.\n+    #[rustc_macro_transparency = \"semitransparent\"]\n+    #[unstable(feature = \"liballoc_internals\", issue = \"none\", reason = \"implementation detail\")]\n+    pub macro force_expr($e:expr) {\n+        $e\n+    }\n }"}, {"sha": "3a46763c3f608ddf8625c06647b0a049a1c3f78a", "filename": "library/alloc/src/macros.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/edeb631ad0cd6fdf31e2e31ec90e105d1768be28/library%2Falloc%2Fsrc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edeb631ad0cd6fdf31e2e31ec90e105d1768be28/library%2Falloc%2Fsrc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fmacros.rs?ref=edeb631ad0cd6fdf31e2e31ec90e105d1768be28", "patch": "@@ -37,16 +37,16 @@\n #[cfg(not(test))]\n #[macro_export]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[allow_internal_unstable(box_syntax)]\n+#[allow_internal_unstable(box_syntax, liballoc_internals)]\n macro_rules! vec {\n     () => (\n-        $crate::vec::Vec::new()\n+        $crate::__export::force_expr!($crate::vec::Vec::new())\n     );\n     ($elem:expr; $n:expr) => (\n-        $crate::vec::from_elem($elem, $n)\n+        $crate::__export::force_expr!($crate::vec::from_elem($elem, $n))\n     );\n     ($($x:expr),+ $(,)?) => (\n-        <[_]>::into_vec(box [$($x),+])\n+        $crate::__export::force_expr!(<[_]>::into_vec(box [$($x),+]))\n     );\n }\n "}, {"sha": "111feb7dbec69c24a7295298858423bf69b0d9c6", "filename": "library/core/src/num/nonzero.rs", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/edeb631ad0cd6fdf31e2e31ec90e105d1768be28/library%2Fcore%2Fsrc%2Fnum%2Fnonzero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edeb631ad0cd6fdf31e2e31ec90e105d1768be28/library%2Fcore%2Fsrc%2Fnum%2Fnonzero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fnonzero.rs?ref=edeb631ad0cd6fdf31e2e31ec90e105d1768be28", "patch": "@@ -286,3 +286,43 @@ nonzero_integers_div! {\n     NonZeroU128(u128);\n     NonZeroUsize(usize);\n }\n+\n+macro_rules! nonzero_unsigned_is_power_of_two {\n+    ( $( $Ty: ident )+ ) => {\n+        $(\n+            impl $Ty {\n+\n+                /// Returns `true` if and only if `self == (1 << k)` for some `k`.\n+                ///\n+                /// On many architectures, this function can perform better than `is_power_of_two()`\n+                /// on the underlying integer type, as special handling of zero can be avoided.\n+                ///\n+                /// # Examples\n+                ///\n+                /// Basic usage:\n+                ///\n+                /// ```\n+                /// #![feature(nonzero_is_power_of_two)]\n+                ///\n+                #[doc = concat!(\"let eight = std::num::\", stringify!($Ty), \"::new(8).unwrap();\")]\n+                /// assert!(eight.is_power_of_two());\n+                #[doc = concat!(\"let ten = std::num::\", stringify!($Ty), \"::new(10).unwrap();\")]\n+                /// assert!(!ten.is_power_of_two());\n+                /// ```\n+                #[unstable(feature = \"nonzero_is_power_of_two\", issue = \"81106\")]\n+                #[inline]\n+                pub const fn is_power_of_two(self) -> bool {\n+                    // LLVM 11 normalizes `unchecked_sub(x, 1) & x == 0` to the implementation seen here.\n+                    // On the basic x86-64 target, this saves 3 instructions for the zero check.\n+                    // On x86_64 with BMI1, being nonzero lets it codegen to `BLSR`, which saves an instruction\n+                    // compared to the `POPCNT` implementation on the underlying integer type.\n+\n+                    intrinsics::ctpop(self.get()) < 2\n+                }\n+\n+            }\n+        )+\n+    }\n+}\n+\n+nonzero_unsigned_is_power_of_two! { NonZeroU8 NonZeroU16 NonZeroU32 NonZeroU64 NonZeroU128 NonZeroUsize }"}, {"sha": "8bae3da1273eb62b71719d1f5d67189846d9a225", "filename": "library/std/src/io/buffered/bufreader.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/edeb631ad0cd6fdf31e2e31ec90e105d1768be28/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Fbufreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edeb631ad0cd6fdf31e2e31ec90e105d1768be28/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Fbufreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Fbufreader.rs?ref=edeb631ad0cd6fdf31e2e31ec90e105d1768be28", "patch": "@@ -271,6 +271,20 @@ impl<R: Read> Read for BufReader<R> {\n         Ok(nread)\n     }\n \n+    // Small read_exacts from a BufReader are extremely common when used with a deserializer.\n+    // The default implementation calls read in a loop, which results in surprisingly poor code\n+    // generation for the common path where the buffer has enough bytes to fill the passed-in\n+    // buffer.\n+    fn read_exact(&mut self, buf: &mut [u8]) -> io::Result<()> {\n+        if self.buffer().len() >= buf.len() {\n+            buf.copy_from_slice(&self.buffer()[..buf.len()]);\n+            self.consume(buf.len());\n+            return Ok(());\n+        }\n+\n+        crate::io::default_read_exact(self, buf)\n+    }\n+\n     fn read_vectored(&mut self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n         let total_len = bufs.iter().map(|b| b.len()).sum::<usize>();\n         if self.pos == self.cap && total_len >= self.buf.len() {"}, {"sha": "f6c2b499567abf9b245c42903ec5c98bd10cf780", "filename": "library/std/src/io/buffered/tests.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/edeb631ad0cd6fdf31e2e31ec90e105d1768be28/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edeb631ad0cd6fdf31e2e31ec90e105d1768be28/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Ftests.rs?ref=edeb631ad0cd6fdf31e2e31ec90e105d1768be28", "patch": "@@ -443,6 +443,18 @@ fn bench_buffered_reader(b: &mut test::Bencher) {\n     b.iter(|| BufReader::new(io::empty()));\n }\n \n+#[bench]\n+fn bench_buffered_reader_small_reads(b: &mut test::Bencher) {\n+    let data = (0..u8::MAX).cycle().take(1024 * 4).collect::<Vec<_>>();\n+    b.iter(|| {\n+        let mut reader = BufReader::new(&data[..]);\n+        let mut buf = [0u8; 4];\n+        for _ in 0..1024 {\n+            reader.read_exact(&mut buf).unwrap();\n+        }\n+    });\n+}\n+\n #[bench]\n fn bench_buffered_writer(b: &mut test::Bencher) {\n     b.iter(|| BufWriter::new(io::sink()));"}, {"sha": "c87a56586c65e61aaf2a6a999b28bf513f2f7713", "filename": "library/std/src/io/mod.rs", "status": "modified", "additions": 21, "deletions": 17, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/edeb631ad0cd6fdf31e2e31ec90e105d1768be28/library%2Fstd%2Fsrc%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edeb631ad0cd6fdf31e2e31ec90e105d1768be28/library%2Fstd%2Fsrc%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fmod.rs?ref=edeb631ad0cd6fdf31e2e31ec90e105d1768be28", "patch": "@@ -416,6 +416,25 @@ where\n     write(buf)\n }\n \n+pub(crate) fn default_read_exact<R: Read + ?Sized>(this: &mut R, mut buf: &mut [u8]) -> Result<()> {\n+    while !buf.is_empty() {\n+        match this.read(buf) {\n+            Ok(0) => break,\n+            Ok(n) => {\n+                let tmp = buf;\n+                buf = &mut tmp[n..];\n+            }\n+            Err(ref e) if e.kind() == ErrorKind::Interrupted => {}\n+            Err(e) => return Err(e),\n+        }\n+    }\n+    if !buf.is_empty() {\n+        Err(Error::new(ErrorKind::UnexpectedEof, \"failed to fill whole buffer\"))\n+    } else {\n+        Ok(())\n+    }\n+}\n+\n /// The `Read` trait allows for reading bytes from a source.\n ///\n /// Implementors of the `Read` trait are called 'readers'.\n@@ -766,23 +785,8 @@ pub trait Read {\n     /// }\n     /// ```\n     #[stable(feature = \"read_exact\", since = \"1.6.0\")]\n-    fn read_exact(&mut self, mut buf: &mut [u8]) -> Result<()> {\n-        while !buf.is_empty() {\n-            match self.read(buf) {\n-                Ok(0) => break,\n-                Ok(n) => {\n-                    let tmp = buf;\n-                    buf = &mut tmp[n..];\n-                }\n-                Err(ref e) if e.kind() == ErrorKind::Interrupted => {}\n-                Err(e) => return Err(e),\n-            }\n-        }\n-        if !buf.is_empty() {\n-            Err(Error::new(ErrorKind::UnexpectedEof, \"failed to fill whole buffer\"))\n-        } else {\n-            Ok(())\n-        }\n+    fn read_exact(&mut self, buf: &mut [u8]) -> Result<()> {\n+        default_read_exact(self, buf)\n     }\n \n     /// Creates a \"by reference\" adaptor for this instance of `Read`."}, {"sha": "5350c9eefe75353837d397101b13397cda3dd5d6", "filename": "src/bootstrap/bootstrap.py", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/edeb631ad0cd6fdf31e2e31ec90e105d1768be28/src%2Fbootstrap%2Fbootstrap.py", "raw_url": "https://github.com/rust-lang/rust/raw/edeb631ad0cd6fdf31e2e31ec90e105d1768be28/src%2Fbootstrap%2Fbootstrap.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbootstrap.py?ref=edeb631ad0cd6fdf31e2e31ec90e105d1768be28", "patch": "@@ -465,8 +465,21 @@ def download_stage0(self):\n \n     def downloading_llvm(self):\n         opt = self.get_toml('download-ci-llvm', 'llvm')\n+        # This is currently all tier 1 targets (since others may not have CI\n+        # artifacts)\n+        # https://doc.rust-lang.org/rustc/platform-support.html#tier-1\n+        supported_platforms = [\n+            \"aarch64-unknown-linux-gnu\",\n+            \"i686-pc-windows-gnu\",\n+            \"i686-pc-windows-msvc\",\n+            \"i686-unknown-linux-gnu\",\n+            \"x86_64-unknown-linux-gnu\",\n+            \"x86_64-apple-darwin\",\n+            \"x86_64-pc-windows-gnu\",\n+            \"x86_64-pc-windows-msvc\",\n+        ]\n         return opt == \"true\" \\\n-            or (opt == \"if-available\" and self.build == \"x86_64-unknown-linux-gnu\")\n+            or (opt == \"if-available\" and self.build in supported_platforms)\n \n     def _download_stage0_helper(self, filename, pattern, tarball_suffix, date=None):\n         if date is None:"}, {"sha": "c19bb536ce83c25c3397ed1235fd7fb6bc19cbc5", "filename": "src/bootstrap/check.rs", "status": "modified", "additions": 36, "deletions": 15, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/edeb631ad0cd6fdf31e2e31ec90e105d1768be28/src%2Fbootstrap%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edeb631ad0cd6fdf31e2e31ec90e105d1768be28/src%2Fbootstrap%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcheck.rs?ref=edeb631ad0cd6fdf31e2e31ec90e105d1768be28", "patch": "@@ -73,7 +73,7 @@ impl Step for Std {\n \n     fn run(self, builder: &Builder<'_>) {\n         let target = self.target;\n-        let compiler = builder.compiler(0, builder.config.build);\n+        let compiler = builder.compiler(builder.top_stage, builder.config.build);\n \n         let mut cargo = builder.cargo(\n             compiler,\n@@ -84,7 +84,10 @@ impl Step for Std {\n         );\n         std_cargo(builder, target, compiler.stage, &mut cargo);\n \n-        builder.info(&format!(\"Checking std artifacts ({} -> {})\", &compiler.host, target));\n+        builder.info(&format!(\n+            \"Checking stage{} std artifacts ({} -> {})\",\n+            builder.top_stage, &compiler.host, target\n+        ));\n         run_cargo(\n             builder,\n             cargo,\n@@ -94,9 +97,13 @@ impl Step for Std {\n             true,\n         );\n \n-        let libdir = builder.sysroot_libdir(compiler, target);\n-        let hostdir = builder.sysroot_libdir(compiler, compiler.host);\n-        add_to_sysroot(&builder, &libdir, &hostdir, &libstd_stamp(builder, compiler, target));\n+        // We skip populating the sysroot in non-zero stage because that'll lead\n+        // to rlib/rmeta conflicts if std gets built during this session.\n+        if compiler.stage == 0 {\n+            let libdir = builder.sysroot_libdir(compiler, target);\n+            let hostdir = builder.sysroot_libdir(compiler, compiler.host);\n+            add_to_sysroot(&builder, &libdir, &hostdir, &libstd_stamp(builder, compiler, target));\n+        }\n \n         // Then run cargo again, once we've put the rmeta files for the library\n         // crates into the sysroot. This is needed because e.g., core's tests\n@@ -124,8 +131,8 @@ impl Step for Std {\n             }\n \n             builder.info(&format!(\n-                \"Checking std test/bench/example targets ({} -> {})\",\n-                &compiler.host, target\n+                \"Checking stage{} std test/bench/example targets ({} -> {})\",\n+                builder.top_stage, &compiler.host, target\n             ));\n             run_cargo(\n                 builder,\n@@ -163,10 +170,20 @@ impl Step for Rustc {\n     /// the `compiler` targeting the `target` architecture. The artifacts\n     /// created will also be linked into the sysroot directory.\n     fn run(self, builder: &Builder<'_>) {\n-        let compiler = builder.compiler(0, builder.config.build);\n+        let compiler = builder.compiler(builder.top_stage, builder.config.build);\n         let target = self.target;\n \n-        builder.ensure(Std { target });\n+        if compiler.stage != 0 {\n+            // If we're not in stage 0, then we won't have a std from the beta\n+            // compiler around. That means we need to make sure there's one in\n+            // the sysroot for the compiler to find. Otherwise, we're going to\n+            // fail when building crates that need to generate code (e.g., build\n+            // scripts and their dependencies).\n+            builder.ensure(crate::compile::Std { target: compiler.host, compiler });\n+            builder.ensure(crate::compile::Std { target, compiler });\n+        } else {\n+            builder.ensure(Std { target });\n+        }\n \n         let mut cargo = builder.cargo(\n             compiler,\n@@ -187,7 +204,10 @@ impl Step for Rustc {\n             cargo.arg(\"-p\").arg(krate.name);\n         }\n \n-        builder.info(&format!(\"Checking compiler artifacts ({} -> {})\", &compiler.host, target));\n+        builder.info(&format!(\n+            \"Checking stage{} compiler artifacts ({} -> {})\",\n+            builder.top_stage, &compiler.host, target\n+        ));\n         run_cargo(\n             builder,\n             cargo,\n@@ -225,7 +245,7 @@ impl Step for CodegenBackend {\n     }\n \n     fn run(self, builder: &Builder<'_>) {\n-        let compiler = builder.compiler(0, builder.config.build);\n+        let compiler = builder.compiler(builder.top_stage, builder.config.build);\n         let target = self.target;\n         let backend = self.backend;\n \n@@ -244,8 +264,8 @@ impl Step for CodegenBackend {\n         rustc_cargo_env(builder, &mut cargo, target);\n \n         builder.info(&format!(\n-            \"Checking {} artifacts ({} -> {})\",\n-            backend, &compiler.host.triple, target.triple\n+            \"Checking stage{} {} artifacts ({} -> {})\",\n+            builder.top_stage, backend, &compiler.host.triple, target.triple\n         ));\n \n         run_cargo(\n@@ -280,7 +300,7 @@ macro_rules! tool_check_step {\n             }\n \n             fn run(self, builder: &Builder<'_>) {\n-                let compiler = builder.compiler(0, builder.config.build);\n+                let compiler = builder.compiler(builder.top_stage, builder.config.build);\n                 let target = self.target;\n \n                 builder.ensure(Rustc { target });\n@@ -301,7 +321,8 @@ macro_rules! tool_check_step {\n                 }\n \n                 builder.info(&format!(\n-                    \"Checking {} artifacts ({} -> {})\",\n+                    \"Checking stage{} {} artifacts ({} -> {})\",\n+                    builder.top_stage,\n                     stringify!($name).to_lowercase(),\n                     &compiler.host.triple,\n                     target.triple"}, {"sha": "ec1308ab82b51ac21fe4fe2f6567b31e1d7541fa", "filename": "src/bootstrap/config.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/edeb631ad0cd6fdf31e2e31ec90e105d1768be28/src%2Fbootstrap%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edeb631ad0cd6fdf31e2e31ec90e105d1768be28/src%2Fbootstrap%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfig.rs?ref=edeb631ad0cd6fdf31e2e31ec90e105d1768be28", "patch": "@@ -377,6 +377,7 @@ struct Build {\n     configure_args: Option<Vec<String>>,\n     local_rebuild: Option<bool>,\n     print_step_timings: Option<bool>,\n+    check_stage: Option<u32>,\n     doc_stage: Option<u32>,\n     build_stage: Option<u32>,\n     test_stage: Option<u32>,\n@@ -676,6 +677,7 @@ impl Config {\n \n         // See https://github.com/rust-lang/compiler-team/issues/326\n         config.stage = match config.cmd {\n+            Subcommand::Check { .. } => flags.stage.or(build.check_stage).unwrap_or(0),\n             Subcommand::Doc { .. } => flags.stage.or(build.doc_stage).unwrap_or(0),\n             Subcommand::Build { .. } => flags.stage.or(build.build_stage).unwrap_or(1),\n             Subcommand::Test { .. } => flags.stage.or(build.test_stage).unwrap_or(1),\n@@ -685,7 +687,6 @@ impl Config {\n             // These are all bootstrap tools, which don't depend on the compiler.\n             // The stage we pass shouldn't matter, but use 0 just in case.\n             Subcommand::Clean { .. }\n-            | Subcommand::Check { .. }\n             | Subcommand::Clippy { .. }\n             | Subcommand::Fix { .. }\n             | Subcommand::Run { .. }\n@@ -816,8 +817,10 @@ impl Config {\n                 check_ci_llvm!(llvm.allow_old_toolchain);\n                 check_ci_llvm!(llvm.polly);\n \n-                // CI-built LLVM is shared\n-                config.llvm_link_shared = true;\n+                // CI-built LLVM can be either dynamic or static.\n+                let ci_llvm = config.out.join(&*config.build.triple).join(\"ci-llvm\");\n+                let link_type = t!(std::fs::read_to_string(ci_llvm.join(\"link-type.txt\")));\n+                config.llvm_link_shared = link_type == \"dynamic\";\n             }\n \n             if config.llvm_thin_lto {"}, {"sha": "af9c0fb04bc9d4858bc2e053f1747a61c0764d81", "filename": "src/bootstrap/dist.rs", "status": "modified", "additions": 30, "deletions": 18, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/edeb631ad0cd6fdf31e2e31ec90e105d1768be28/src%2Fbootstrap%2Fdist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edeb631ad0cd6fdf31e2e31ec90e105d1768be28/src%2Fbootstrap%2Fdist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdist.rs?ref=edeb631ad0cd6fdf31e2e31ec90e105d1768be28", "patch": "@@ -1800,19 +1800,11 @@ fn add_env(builder: &Builder<'_>, cmd: &mut Command, target: TargetSelection) {\n     }\n }\n \n-/// Maybe add libLLVM.so to the given destination lib-dir. It will only have\n-/// been built if LLVM tools are linked dynamically.\n+/// Maybe add LLVM object files to the given destination lib-dir. Allows either static or dynamic linking.\n ///\n-/// Note: This function does not yet support Windows, but we also don't support\n-///       linking LLVM tools dynamically on Windows yet.\n-fn maybe_install_llvm(builder: &Builder<'_>, target: TargetSelection, dst_libdir: &Path) {\n-    if !builder.config.llvm_link_shared {\n-        // We do not need to copy LLVM files into the sysroot if it is not\n-        // dynamically linked; it is already included into librustc_llvm\n-        // statically.\n-        return;\n-    }\n \n+/// Returns whether the files were actually copied.\n+fn maybe_install_llvm(builder: &Builder<'_>, target: TargetSelection, dst_libdir: &Path) -> bool {\n     if let Some(config) = builder.config.target_config.get(&target) {\n         if config.llvm_config.is_some() && !builder.config.llvm_from_ci {\n             // If the LLVM was externally provided, then we don't currently copy\n@@ -1828,7 +1820,7 @@ fn maybe_install_llvm(builder: &Builder<'_>, target: TargetSelection, dst_libdir\n             //\n             // If the LLVM is coming from ourselves (just from CI) though, we\n             // still want to install it, as it otherwise won't be available.\n-            return;\n+            return false;\n         }\n     }\n \n@@ -1837,31 +1829,48 @@ fn maybe_install_llvm(builder: &Builder<'_>, target: TargetSelection, dst_libdir\n     // clear why this is the case, though. llvm-config will emit the versioned\n     // paths and we don't want those in the sysroot (as we're expecting\n     // unversioned paths).\n-    if target.contains(\"apple-darwin\") {\n+    if target.contains(\"apple-darwin\") && builder.config.llvm_link_shared {\n         let src_libdir = builder.llvm_out(target).join(\"lib\");\n         let llvm_dylib_path = src_libdir.join(\"libLLVM.dylib\");\n         if llvm_dylib_path.exists() {\n             builder.install(&llvm_dylib_path, dst_libdir, 0o644);\n         }\n+        !builder.config.dry_run\n     } else if let Ok(llvm_config) = crate::native::prebuilt_llvm_config(builder, target) {\n-        let files = output(Command::new(llvm_config).arg(\"--libfiles\"));\n-        for file in files.lines() {\n+        let mut cmd = Command::new(llvm_config);\n+        cmd.arg(\"--libfiles\");\n+        builder.verbose(&format!(\"running {:?}\", cmd));\n+        let files = output(&mut cmd);\n+        for file in files.trim_end().split(' ') {\n             builder.install(Path::new(file), dst_libdir, 0o644);\n         }\n+        !builder.config.dry_run\n+    } else {\n+        false\n     }\n }\n \n /// Maybe add libLLVM.so to the target lib-dir for linking.\n pub fn maybe_install_llvm_target(builder: &Builder<'_>, target: TargetSelection, sysroot: &Path) {\n     let dst_libdir = sysroot.join(\"lib/rustlib\").join(&*target.triple).join(\"lib\");\n-    maybe_install_llvm(builder, target, &dst_libdir);\n+    // We do not need to copy LLVM files into the sysroot if it is not\n+    // dynamically linked; it is already included into librustc_llvm\n+    // statically.\n+    if builder.config.llvm_link_shared {\n+        maybe_install_llvm(builder, target, &dst_libdir);\n+    }\n }\n \n /// Maybe add libLLVM.so to the runtime lib-dir for rustc itself.\n pub fn maybe_install_llvm_runtime(builder: &Builder<'_>, target: TargetSelection, sysroot: &Path) {\n     let dst_libdir =\n         sysroot.join(builder.sysroot_libdir_relative(Compiler { stage: 1, host: target }));\n-    maybe_install_llvm(builder, target, &dst_libdir);\n+    // We do not need to copy LLVM files into the sysroot if it is not\n+    // dynamically linked; it is already included into librustc_llvm\n+    // statically.\n+    if builder.config.llvm_link_shared {\n+        maybe_install_llvm(builder, target, &dst_libdir);\n+    }\n }\n \n #[derive(Clone, Debug, Eq, Hash, PartialEq)]\n@@ -1973,7 +1982,10 @@ impl Step for RustDev {\n         // `$ORIGIN/../lib` can find it. It may also be used as a dependency\n         // of `rustc-dev` to support the inherited `-lLLVM` when using the\n         // compiler libraries.\n-        maybe_install_llvm(builder, target, &tarball.image_dir().join(\"lib\"));\n+        let dst_libdir = tarball.image_dir().join(\"lib\");\n+        maybe_install_llvm(builder, target, &dst_libdir);\n+        let link_type = if builder.config.llvm_link_shared { \"dynamic\" } else { \"static\" };\n+        t!(std::fs::write(tarball.image_dir().join(\"link-type.txt\"), link_type), dst_libdir);\n \n         Some(tarball.generate())\n     }"}, {"sha": "fb5b058cb4d74a46c6e4de30695d020f9a834a93", "filename": "src/bootstrap/download-ci-llvm-stamp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/edeb631ad0cd6fdf31e2e31ec90e105d1768be28/src%2Fbootstrap%2Fdownload-ci-llvm-stamp", "raw_url": "https://github.com/rust-lang/rust/raw/edeb631ad0cd6fdf31e2e31ec90e105d1768be28/src%2Fbootstrap%2Fdownload-ci-llvm-stamp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdownload-ci-llvm-stamp?ref=edeb631ad0cd6fdf31e2e31ec90e105d1768be28", "patch": "@@ -1,4 +1,4 @@\n Change this file to make users of the `download-ci-llvm` configuration download\n a new version of LLVM from CI, even if the LLVM submodule hasn\u2019t changed.\n \n-Last change is for: https://github.com/rust-lang/rust/pull/80087\n+Last change is for: https://github.com/rust-lang/rust/pull/80932"}, {"sha": "55062e11e029a75b7fee5e020cee491f5ed6e638", "filename": "src/bootstrap/flags.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/edeb631ad0cd6fdf31e2e31ec90e105d1768be28/src%2Fbootstrap%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edeb631ad0cd6fdf31e2e31ec90e105d1768be28/src%2Fbootstrap%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fflags.rs?ref=edeb631ad0cd6fdf31e2e31ec90e105d1768be28", "patch": "@@ -614,14 +614,10 @@ Arguments:\n         };\n \n         if let Subcommand::Check { .. } = &cmd {\n-            if matches.opt_str(\"stage\").is_some() {\n-                println!(\"--stage not supported for x.py check, always treated as stage 0\");\n-                process::exit(1);\n-            }\n             if matches.opt_str(\"keep-stage\").is_some()\n                 || matches.opt_str(\"keep-stage-std\").is_some()\n             {\n-                println!(\"--keep-stage not supported for x.py check, only one stage available\");\n+                println!(\"--keep-stage not yet supported for x.py check\");\n                 process::exit(1);\n             }\n         }"}, {"sha": "609ac8b366952113bfb3be057b628a7107bdbd36", "filename": "src/bootstrap/native.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/edeb631ad0cd6fdf31e2e31ec90e105d1768be28/src%2Fbootstrap%2Fnative.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edeb631ad0cd6fdf31e2e31ec90e105d1768be28/src%2Fbootstrap%2Fnative.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fnative.rs?ref=edeb631ad0cd6fdf31e2e31ec90e105d1768be28", "patch": "@@ -171,7 +171,6 @@ impl Step for Llvm {\n             .define(\"LLVM_TARGETS_TO_BUILD\", llvm_targets)\n             .define(\"LLVM_EXPERIMENTAL_TARGETS_TO_BUILD\", llvm_exp_targets)\n             .define(\"LLVM_INCLUDE_EXAMPLES\", \"OFF\")\n-            .define(\"LLVM_INCLUDE_TESTS\", \"OFF\")\n             .define(\"LLVM_INCLUDE_DOCS\", \"OFF\")\n             .define(\"LLVM_INCLUDE_BENCHMARKS\", \"OFF\")\n             .define(\"LLVM_ENABLE_TERMINFO\", \"OFF\")"}, {"sha": "280984088a94e5e47fea204315edbc6a480e9f08", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/edeb631ad0cd6fdf31e2e31ec90e105d1768be28/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edeb631ad0cd6fdf31e2e31ec90e105d1768be28/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=edeb631ad0cd6fdf31e2e31ec90e105d1768be28", "patch": "@@ -19,7 +19,7 @@ use rustc_session::lint::{\n     builtin::{BROKEN_INTRA_DOC_LINKS, PRIVATE_INTRA_DOC_LINKS},\n     Lint,\n };\n-use rustc_span::hygiene::MacroKind;\n+use rustc_span::hygiene::{MacroKind, SyntaxContext};\n use rustc_span::symbol::Ident;\n use rustc_span::symbol::Symbol;\n use rustc_span::DUMMY_SP;\n@@ -770,7 +770,12 @@ fn traits_implemented_by(cx: &DocContext<'_>, type_: DefId, module: DefId) -> Fx\n     let mut cache = cx.module_trait_cache.borrow_mut();\n     let in_scope_traits = cache.entry(module).or_insert_with(|| {\n         cx.enter_resolver(|resolver| {\n-            resolver.traits_in_scope(module).into_iter().map(|candidate| candidate.def_id).collect()\n+            let parent_scope = &ParentScope::module(resolver.get_module(module), resolver);\n+            resolver\n+                .traits_in_scope(None, parent_scope, SyntaxContext::root(), None)\n+                .into_iter()\n+                .map(|candidate| candidate.def_id)\n+                .collect()\n         })\n     });\n "}, {"sha": "2916d8c794f22e22b8b7f4c455077e21e14ea086", "filename": "src/test/ui/closures/2229_closure_analysis/diagnostics/closure-origin-multi-variant-diagnostics.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/edeb631ad0cd6fdf31e2e31ec90e105d1768be28/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Fclosure-origin-multi-variant-diagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edeb631ad0cd6fdf31e2e31ec90e105d1768be28/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Fclosure-origin-multi-variant-diagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Fclosure-origin-multi-variant-diagnostics.rs?ref=edeb631ad0cd6fdf31e2e31ec90e105d1768be28", "patch": "@@ -0,0 +1,31 @@\n+#![feature(capture_disjoint_fields)]\n+//~^ WARNING: the feature `capture_disjoint_fields` is incomplete\n+//~| `#[warn(incomplete_features)]` on by default\n+//~| see issue #53488 <https://github.com/rust-lang/rust/issues/53488>\n+\n+// Check that precise paths are being reported back in the error message.\n+\n+\n+enum MultiVariant {\n+    Point(i32, i32),\n+    Meta(i32)\n+}\n+\n+fn main() {\n+    let mut point = MultiVariant::Point(10, -10,);\n+\n+    let mut meta = MultiVariant::Meta(1);\n+\n+    let c = || {\n+        if let MultiVariant::Point(ref mut x, _) = point {\n+            *x += 1;\n+        }\n+\n+        if let MultiVariant::Meta(ref mut v) = meta {\n+            *v += 1;\n+        }\n+    };\n+\n+    let a = c;\n+    let b = c; //~ ERROR use of moved value: `c` [E0382]\n+}"}, {"sha": "de0bfe3bd769fb035af319882b6fbfafa13e2fe4", "filename": "src/test/ui/closures/2229_closure_analysis/diagnostics/closure-origin-multi-variant-diagnostics.stderr", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/edeb631ad0cd6fdf31e2e31ec90e105d1768be28/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Fclosure-origin-multi-variant-diagnostics.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/edeb631ad0cd6fdf31e2e31ec90e105d1768be28/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Fclosure-origin-multi-variant-diagnostics.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Fclosure-origin-multi-variant-diagnostics.stderr?ref=edeb631ad0cd6fdf31e2e31ec90e105d1768be28", "patch": "@@ -0,0 +1,26 @@\n+warning: the feature `capture_disjoint_fields` is incomplete and may not be safe to use and/or cause compiler crashes\n+  --> $DIR/closure-origin-multi-variant-diagnostics.rs:1:12\n+   |\n+LL | #![feature(capture_disjoint_fields)]\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `#[warn(incomplete_features)]` on by default\n+   = note: see issue #53488 <https://github.com/rust-lang/rust/issues/53488> for more information\n+\n+error[E0382]: use of moved value: `c`\n+  --> $DIR/closure-origin-multi-variant-diagnostics.rs:30:13\n+   |\n+LL |     let a = c;\n+   |             - value moved here\n+LL |     let b = c;\n+   |             ^ value used here after move\n+   |\n+note: closure cannot be moved more than once as it is not `Copy` due to moving the variable `point.0` out of its environment\n+  --> $DIR/closure-origin-multi-variant-diagnostics.rs:20:52\n+   |\n+LL |         if let MultiVariant::Point(ref mut x, _) = point {\n+   |                                                    ^^^^^\n+\n+error: aborting due to previous error; 1 warning emitted\n+\n+For more information about this error, try `rustc --explain E0382`."}, {"sha": "8486f03f2eb8e8502082b2384232430e1a757d61", "filename": "src/test/ui/closures/2229_closure_analysis/diagnostics/closure-origin-single-variant-diagnostics.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/edeb631ad0cd6fdf31e2e31ec90e105d1768be28/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Fclosure-origin-single-variant-diagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edeb631ad0cd6fdf31e2e31ec90e105d1768be28/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Fclosure-origin-single-variant-diagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Fclosure-origin-single-variant-diagnostics.rs?ref=edeb631ad0cd6fdf31e2e31ec90e105d1768be28", "patch": "@@ -0,0 +1,26 @@\n+#![feature(capture_disjoint_fields)]\n+//~^ WARNING: the feature `capture_disjoint_fields` is incomplete\n+//~| `#[warn(incomplete_features)]` on by default\n+//~| see issue #53488 <https://github.com/rust-lang/rust/issues/53488>\n+\n+// Check that precise paths are being reported back in the error message.\n+\n+enum SingleVariant {\n+    Point(i32, i32),\n+}\n+\n+fn main() {\n+    let mut point = SingleVariant::Point(10, -10);\n+\n+    let c = || {\n+        // FIXME(project-rfc-2229#24): Change this to be a destructure pattern\n+        // once this is fixed, to remove the warning.\n+        if let SingleVariant::Point(ref mut x, _) = point {\n+            //~^ WARNING: irrefutable if-let pattern\n+            *x += 1;\n+        }\n+    };\n+\n+    let b = c;\n+    let a = c; //~ ERROR use of moved value: `c` [E0382]\n+}"}, {"sha": "ad66f6d7ffcaa6c37baeb6bd1a17b187f2723dba", "filename": "src/test/ui/closures/2229_closure_analysis/diagnostics/closure-origin-single-variant-diagnostics.stderr", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/edeb631ad0cd6fdf31e2e31ec90e105d1768be28/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Fclosure-origin-single-variant-diagnostics.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/edeb631ad0cd6fdf31e2e31ec90e105d1768be28/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Fclosure-origin-single-variant-diagnostics.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Fclosure-origin-single-variant-diagnostics.stderr?ref=edeb631ad0cd6fdf31e2e31ec90e105d1768be28", "patch": "@@ -0,0 +1,37 @@\n+warning: the feature `capture_disjoint_fields` is incomplete and may not be safe to use and/or cause compiler crashes\n+  --> $DIR/closure-origin-single-variant-diagnostics.rs:1:12\n+   |\n+LL | #![feature(capture_disjoint_fields)]\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `#[warn(incomplete_features)]` on by default\n+   = note: see issue #53488 <https://github.com/rust-lang/rust/issues/53488> for more information\n+\n+warning: irrefutable if-let pattern\n+  --> $DIR/closure-origin-single-variant-diagnostics.rs:18:9\n+   |\n+LL | /         if let SingleVariant::Point(ref mut x, _) = point {\n+LL | |\n+LL | |             *x += 1;\n+LL | |         }\n+   | |_________^\n+   |\n+   = note: `#[warn(irrefutable_let_patterns)]` on by default\n+\n+error[E0382]: use of moved value: `c`\n+  --> $DIR/closure-origin-single-variant-diagnostics.rs:25:13\n+   |\n+LL |     let b = c;\n+   |             - value moved here\n+LL |     let a = c;\n+   |             ^ value used here after move\n+   |\n+note: closure cannot be moved more than once as it is not `Copy` due to moving the variable `point.0` out of its environment\n+  --> $DIR/closure-origin-single-variant-diagnostics.rs:18:53\n+   |\n+LL |         if let SingleVariant::Point(ref mut x, _) = point {\n+   |                                                     ^^^^^\n+\n+error: aborting due to previous error; 2 warnings emitted\n+\n+For more information about this error, try `rustc --explain E0382`."}, {"sha": "103890f1f353754a8de003296c63d1c3a4d370e7", "filename": "src/test/ui/closures/2229_closure_analysis/diagnostics/closure-origin-struct-diagnostics.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/edeb631ad0cd6fdf31e2e31ec90e105d1768be28/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Fclosure-origin-struct-diagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edeb631ad0cd6fdf31e2e31ec90e105d1768be28/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Fclosure-origin-struct-diagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Fclosure-origin-struct-diagnostics.rs?ref=edeb631ad0cd6fdf31e2e31ec90e105d1768be28", "patch": "@@ -0,0 +1,25 @@\n+#![feature(capture_disjoint_fields)]\n+//~^ WARNING: the feature `capture_disjoint_fields` is incomplete\n+//~| `#[warn(incomplete_features)]` on by default\n+//~| see issue #53488 <https://github.com/rust-lang/rust/issues/53488>\n+\n+// Check that precise paths are being reported back in the error message.\n+\n+struct Y {\n+    y: X\n+}\n+\n+struct X {\n+    a: u32,\n+    b: u32,\n+}\n+\n+fn main() {\n+    let mut x = Y { y: X { a: 5, b: 0 } };\n+    let hello = || {\n+        x.y.a += 1;\n+    };\n+\n+    let b = hello;\n+    let c = hello; //~ ERROR use of moved value: `hello` [E0382]\n+}"}, {"sha": "474d77b7cd2086a541c11ff28f70ae845384f1ee", "filename": "src/test/ui/closures/2229_closure_analysis/diagnostics/closure-origin-struct-diagnostics.stderr", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/edeb631ad0cd6fdf31e2e31ec90e105d1768be28/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Fclosure-origin-struct-diagnostics.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/edeb631ad0cd6fdf31e2e31ec90e105d1768be28/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Fclosure-origin-struct-diagnostics.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Fclosure-origin-struct-diagnostics.stderr?ref=edeb631ad0cd6fdf31e2e31ec90e105d1768be28", "patch": "@@ -0,0 +1,26 @@\n+warning: the feature `capture_disjoint_fields` is incomplete and may not be safe to use and/or cause compiler crashes\n+  --> $DIR/closure-origin-struct-diagnostics.rs:1:12\n+   |\n+LL | #![feature(capture_disjoint_fields)]\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `#[warn(incomplete_features)]` on by default\n+   = note: see issue #53488 <https://github.com/rust-lang/rust/issues/53488> for more information\n+\n+error[E0382]: use of moved value: `hello`\n+  --> $DIR/closure-origin-struct-diagnostics.rs:24:13\n+   |\n+LL |     let b = hello;\n+   |             ----- value moved here\n+LL |     let c = hello;\n+   |             ^^^^^ value used here after move\n+   |\n+note: closure cannot be moved more than once as it is not `Copy` due to moving the variable `x.y.a` out of its environment\n+  --> $DIR/closure-origin-struct-diagnostics.rs:20:9\n+   |\n+LL |         x.y.a += 1;\n+   |         ^^^^^\n+\n+error: aborting due to previous error; 1 warning emitted\n+\n+For more information about this error, try `rustc --explain E0382`."}, {"sha": "6b078d2329c2ffbf8d3c96a8812179e85d8debd3", "filename": "src/test/ui/closures/2229_closure_analysis/diagnostics/closure-origin-tuple-diagnostics-1.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/edeb631ad0cd6fdf31e2e31ec90e105d1768be28/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Fclosure-origin-tuple-diagnostics-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edeb631ad0cd6fdf31e2e31ec90e105d1768be28/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Fclosure-origin-tuple-diagnostics-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Fclosure-origin-tuple-diagnostics-1.rs?ref=edeb631ad0cd6fdf31e2e31ec90e105d1768be28", "patch": "@@ -0,0 +1,16 @@\n+#![feature(capture_disjoint_fields)]\n+//~^ WARNING: the feature `capture_disjoint_fields` is incomplete\n+//~| `#[warn(incomplete_features)]` on by default\n+//~| see issue #53488 <https://github.com/rust-lang/rust/issues/53488>\n+\n+// Check that precise paths are being reported back in the error message.\n+\n+fn main() {\n+    let mut x = (5, 0);\n+    let hello = || {\n+        x.0 += 1;\n+    };\n+\n+    let b = hello;\n+    let c = hello; //~ ERROR use of moved value: `hello` [E0382]\n+}"}, {"sha": "716728e96ecbbb101c67e9d9089208711b6dfeb9", "filename": "src/test/ui/closures/2229_closure_analysis/diagnostics/closure-origin-tuple-diagnostics-1.stderr", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/edeb631ad0cd6fdf31e2e31ec90e105d1768be28/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Fclosure-origin-tuple-diagnostics-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/edeb631ad0cd6fdf31e2e31ec90e105d1768be28/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Fclosure-origin-tuple-diagnostics-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Fclosure-origin-tuple-diagnostics-1.stderr?ref=edeb631ad0cd6fdf31e2e31ec90e105d1768be28", "patch": "@@ -0,0 +1,26 @@\n+warning: the feature `capture_disjoint_fields` is incomplete and may not be safe to use and/or cause compiler crashes\n+  --> $DIR/closure-origin-tuple-diagnostics-1.rs:1:12\n+   |\n+LL | #![feature(capture_disjoint_fields)]\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `#[warn(incomplete_features)]` on by default\n+   = note: see issue #53488 <https://github.com/rust-lang/rust/issues/53488> for more information\n+\n+error[E0382]: use of moved value: `hello`\n+  --> $DIR/closure-origin-tuple-diagnostics-1.rs:15:13\n+   |\n+LL |     let b = hello;\n+   |             ----- value moved here\n+LL |     let c = hello;\n+   |             ^^^^^ value used here after move\n+   |\n+note: closure cannot be moved more than once as it is not `Copy` due to moving the variable `x.0` out of its environment\n+  --> $DIR/closure-origin-tuple-diagnostics-1.rs:11:9\n+   |\n+LL |         x.0 += 1;\n+   |         ^^^\n+\n+error: aborting due to previous error; 1 warning emitted\n+\n+For more information about this error, try `rustc --explain E0382`."}, {"sha": "0638db607690fda2987ba416a85ddffd90691fef", "filename": "src/test/ui/closures/2229_closure_analysis/diagnostics/closure-origin-tuple-diagnostics.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/edeb631ad0cd6fdf31e2e31ec90e105d1768be28/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Fclosure-origin-tuple-diagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edeb631ad0cd6fdf31e2e31ec90e105d1768be28/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Fclosure-origin-tuple-diagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Fclosure-origin-tuple-diagnostics.rs?ref=edeb631ad0cd6fdf31e2e31ec90e105d1768be28", "patch": "@@ -0,0 +1,15 @@\n+#![feature(capture_disjoint_fields)]\n+//~^ WARNING: the feature `capture_disjoint_fields` is incomplete\n+//~| `#[warn(incomplete_features)]` on by default\n+//~| see issue #53488 <https://github.com/rust-lang/rust/issues/53488>\n+struct S(String, String);\n+\n+fn expect_fn<F: Fn()>(_f: F) {}\n+\n+fn main() {\n+    let s = S(format!(\"s\"), format!(\"s\"));\n+    let c = || { //~ ERROR expected a closure that implements the `Fn`\n+        let s = s.1;\n+    };\n+    expect_fn(c);\n+}"}, {"sha": "77eb2a94ffb4d7ba01bfb5aae7dfb3029043a995", "filename": "src/test/ui/closures/2229_closure_analysis/diagnostics/closure-origin-tuple-diagnostics.stderr", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/edeb631ad0cd6fdf31e2e31ec90e105d1768be28/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Fclosure-origin-tuple-diagnostics.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/edeb631ad0cd6fdf31e2e31ec90e105d1768be28/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Fclosure-origin-tuple-diagnostics.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Fclosure-origin-tuple-diagnostics.stderr?ref=edeb631ad0cd6fdf31e2e31ec90e105d1768be28", "patch": "@@ -0,0 +1,23 @@\n+warning: the feature `capture_disjoint_fields` is incomplete and may not be safe to use and/or cause compiler crashes\n+  --> $DIR/closure-origin-tuple-diagnostics.rs:1:12\n+   |\n+LL | #![feature(capture_disjoint_fields)]\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `#[warn(incomplete_features)]` on by default\n+   = note: see issue #53488 <https://github.com/rust-lang/rust/issues/53488> for more information\n+\n+error[E0525]: expected a closure that implements the `Fn` trait, but this closure only implements `FnOnce`\n+  --> $DIR/closure-origin-tuple-diagnostics.rs:11:13\n+   |\n+LL |     let c = || {\n+   |             ^^ this closure implements `FnOnce`, not `Fn`\n+LL |         let s = s.1;\n+   |                 --- closure is `FnOnce` because it moves the variable `s.1` out of its environment\n+LL |     };\n+LL |     expect_fn(c);\n+   |     --------- the requirement to implement `Fn` derives from here\n+\n+error: aborting due to previous error; 1 warning emitted\n+\n+For more information about this error, try `rustc --explain E0525`."}, {"sha": "0aaeaffb4cb9db43a0459a46fb56378cb5c86ca8", "filename": "src/test/ui/const-generics/late-bound-vars/in_closure.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/edeb631ad0cd6fdf31e2e31ec90e105d1768be28/src%2Ftest%2Fui%2Fconst-generics%2Flate-bound-vars%2Fin_closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edeb631ad0cd6fdf31e2e31ec90e105d1768be28/src%2Ftest%2Fui%2Fconst-generics%2Flate-bound-vars%2Fin_closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Flate-bound-vars%2Fin_closure.rs?ref=edeb631ad0cd6fdf31e2e31ec90e105d1768be28", "patch": "@@ -0,0 +1,18 @@\n+// run-pass\n+#![feature(const_generics)]\n+#![allow(incomplete_features)]\n+\n+const fn inner<'a>() -> usize where &'a (): Sized {\n+    3\n+}\n+\n+fn test<'a>() {\n+    let _ = || {\n+        let _: [u8; inner::<'a>()];\n+        let _ = [0; inner::<'a>()];\n+    };\n+}\n+\n+fn main() {\n+    test();\n+}"}, {"sha": "2c411a3bdc5f36cd2273f535202c4611a35fe7c0", "filename": "src/test/ui/const-generics/late-bound-vars/simple.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/edeb631ad0cd6fdf31e2e31ec90e105d1768be28/src%2Ftest%2Fui%2Fconst-generics%2Flate-bound-vars%2Fsimple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edeb631ad0cd6fdf31e2e31ec90e105d1768be28/src%2Ftest%2Fui%2Fconst-generics%2Flate-bound-vars%2Fsimple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Flate-bound-vars%2Fsimple.rs?ref=edeb631ad0cd6fdf31e2e31ec90e105d1768be28", "patch": "@@ -0,0 +1,16 @@\n+// run-pass\n+#![feature(const_generics)]\n+#![allow(incomplete_features)]\n+\n+const fn inner<'a>() -> usize where &'a (): Sized {\n+    3\n+}\n+\n+fn test<'a>() {\n+    let _: [u8; inner::<'a>()];\n+    let _ = [0; inner::<'a>()];\n+}\n+\n+fn main() {\n+    test();\n+}"}, {"sha": "548bb226b713cf7479b74b044e637eba479e5686", "filename": "src/test/ui/hygiene/traits-in-scope.rs", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/edeb631ad0cd6fdf31e2e31ec90e105d1768be28/src%2Ftest%2Fui%2Fhygiene%2Ftraits-in-scope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edeb631ad0cd6fdf31e2e31ec90e105d1768be28/src%2Ftest%2Fui%2Fhygiene%2Ftraits-in-scope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhygiene%2Ftraits-in-scope.rs?ref=edeb631ad0cd6fdf31e2e31ec90e105d1768be28", "patch": "@@ -0,0 +1,53 @@\n+// Macros with def-site hygiene still bring traits into scope.\n+// It is not clear whether this is desirable behavior or not.\n+// It is also not clear how to prevent it if it is not desirable.\n+\n+// check-pass\n+\n+#![feature(decl_macro)]\n+#![feature(trait_alias)]\n+\n+mod traits {\n+    pub trait Trait1 {\n+        fn simple_import(&self) {}\n+    }\n+    pub trait Trait2 {\n+        fn renamed_import(&self) {}\n+    }\n+    pub trait Trait3 {\n+        fn underscore_import(&self) {}\n+    }\n+    pub trait Trait4 {\n+        fn trait_alias(&self) {}\n+    }\n+\n+    impl Trait1 for () {}\n+    impl Trait2 for () {}\n+    impl Trait3 for () {}\n+    impl Trait4 for () {}\n+}\n+\n+macro m1() {\n+    use traits::Trait1;\n+}\n+macro m2() {\n+    use traits::Trait2 as Alias;\n+}\n+macro m3() {\n+    use traits::Trait3 as _;\n+}\n+macro m4() {\n+    trait Alias = traits::Trait4;\n+}\n+\n+fn main() {\n+    m1!();\n+    m2!();\n+    m3!();\n+    m4!();\n+\n+    ().simple_import();\n+    ().renamed_import();\n+    ().underscore_import();\n+    ().trait_alias();\n+}"}, {"sha": "ce4298b8bb3347ada138f0ff73c94e00dfb9b94e", "filename": "src/test/ui/macros/vec-macro-in-pattern.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/edeb631ad0cd6fdf31e2e31ec90e105d1768be28/src%2Ftest%2Fui%2Fmacros%2Fvec-macro-in-pattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edeb631ad0cd6fdf31e2e31ec90e105d1768be28/src%2Ftest%2Fui%2Fmacros%2Fvec-macro-in-pattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fvec-macro-in-pattern.rs?ref=edeb631ad0cd6fdf31e2e31ec90e105d1768be28", "patch": "@@ -0,0 +1,10 @@\n+// This is a regression test for #61933\n+// Verify that the vec![] macro may not be used in patterns\n+// and that the resulting diagnostic is actually helpful.\n+\n+fn main() {\n+    match Some(vec![42]) {\n+        Some(vec![43]) => {} //~ ERROR arbitrary expressions aren't allowed in patterns\n+        _ => {}\n+    }\n+}"}, {"sha": "3dabebfdaa25346b427478adc93c4a9dc9343849", "filename": "src/test/ui/macros/vec-macro-in-pattern.stderr", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/edeb631ad0cd6fdf31e2e31ec90e105d1768be28/src%2Ftest%2Fui%2Fmacros%2Fvec-macro-in-pattern.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/edeb631ad0cd6fdf31e2e31ec90e105d1768be28/src%2Ftest%2Fui%2Fmacros%2Fvec-macro-in-pattern.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fvec-macro-in-pattern.stderr?ref=edeb631ad0cd6fdf31e2e31ec90e105d1768be28", "patch": "@@ -0,0 +1,10 @@\n+error: arbitrary expressions aren't allowed in patterns\n+  --> $DIR/vec-macro-in-pattern.rs:7:14\n+   |\n+LL |         Some(vec![43]) => {}\n+   |              ^^^^^^^^\n+   |\n+   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: aborting due to previous error\n+"}, {"sha": "5f45f6892d2e3dd49335632ef061877cb4182246", "filename": "src/test/ui/proc-macro/ambiguous-builtin-attrs.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/edeb631ad0cd6fdf31e2e31ec90e105d1768be28/src%2Ftest%2Fui%2Fproc-macro%2Fambiguous-builtin-attrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edeb631ad0cd6fdf31e2e31ec90e105d1768be28/src%2Ftest%2Fui%2Fproc-macro%2Fambiguous-builtin-attrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fambiguous-builtin-attrs.rs?ref=edeb631ad0cd6fdf31e2e31ec90e105d1768be28", "patch": "@@ -1,5 +1,5 @@\n+// edition:2018\n // aux-build:builtin-attrs.rs\n-\n #![feature(decl_macro)] //~ ERROR `feature` is ambiguous\n \n extern crate builtin_attrs;\n@@ -31,3 +31,7 @@ fn main() {\n     Bench;\n     NonExistent; //~ ERROR cannot find value `NonExistent` in this scope\n }\n+\n+use deny as allow;\n+#[allow(unused)] //~ ERROR `allow` is ambiguous (built-in attribute vs any other name)\n+fn builtin_renamed() {}"}, {"sha": "dfd60dc92cc35945f84db2156741606ac8bb503a", "filename": "src/test/ui/proc-macro/ambiguous-builtin-attrs.stderr", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/edeb631ad0cd6fdf31e2e31ec90e105d1768be28/src%2Ftest%2Fui%2Fproc-macro%2Fambiguous-builtin-attrs.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/edeb631ad0cd6fdf31e2e31ec90e105d1768be28/src%2Ftest%2Fui%2Fproc-macro%2Fambiguous-builtin-attrs.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fambiguous-builtin-attrs.stderr?ref=edeb631ad0cd6fdf31e2e31ec90e105d1768be28", "patch": "@@ -60,6 +60,20 @@ LL | use builtin_attrs::*;\n    |     ^^^^^^^^^^^^^^^^\n    = help: use `crate::repr` to refer to this attribute macro unambiguously\n \n+error[E0659]: `allow` is ambiguous (built-in attribute vs any other name)\n+  --> $DIR/ambiguous-builtin-attrs.rs:36:3\n+   |\n+LL | #[allow(unused)]\n+   |   ^^^^^ ambiguous name\n+   |\n+   = note: `allow` could refer to a built-in attribute\n+note: `allow` could also refer to the built-in attribute imported here\n+  --> $DIR/ambiguous-builtin-attrs.rs:35:5\n+   |\n+LL | use deny as allow;\n+   |     ^^^^^^^^^^^^^\n+   = help: use `crate::allow` to refer to this built-in attribute unambiguously\n+\n error[E0659]: `feature` is ambiguous (built-in attribute vs any other name)\n   --> $DIR/ambiguous-builtin-attrs.rs:3:4\n    |\n@@ -80,7 +94,7 @@ error[E0517]: attribute should be applied to a struct, enum, or union\n LL | fn non_macro_expanded_location<#[repr(C)] T>() {\n    |                                       ^   - not a struct, enum, or union\n \n-error: aborting due to 7 previous errors\n+error: aborting due to 8 previous errors\n \n Some errors have detailed explanations: E0425, E0517, E0659.\n For more information about an error, try `rustc --explain E0425`."}, {"sha": "e1695d6820a817d3ba6d5e4501484872579886c6", "filename": "src/test/ui/suggestions/vec-macro-in-pattern.fixed", "status": "removed", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7d3818152d8ab5649d2e5cc6d7851ed7c03055fe/src%2Ftest%2Fui%2Fsuggestions%2Fvec-macro-in-pattern.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/7d3818152d8ab5649d2e5cc6d7851ed7c03055fe/src%2Ftest%2Fui%2Fsuggestions%2Fvec-macro-in-pattern.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fvec-macro-in-pattern.fixed?ref=7d3818152d8ab5649d2e5cc6d7851ed7c03055fe", "patch": "@@ -1,8 +0,0 @@\n-// run-rustfix\n-fn main() {\n-    // everything after `.as_ref` should be suggested\n-    match Some(vec![3]).as_ref().map(|v| v.as_slice()) {\n-        Some([_x]) => (), //~ ERROR unexpected `(` after qualified path\n-        _ => (),\n-    }\n-}"}, {"sha": "4843629fbcf904788e0567d86717418ce7005794", "filename": "src/test/ui/suggestions/vec-macro-in-pattern.rs", "status": "removed", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7d3818152d8ab5649d2e5cc6d7851ed7c03055fe/src%2Ftest%2Fui%2Fsuggestions%2Fvec-macro-in-pattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d3818152d8ab5649d2e5cc6d7851ed7c03055fe/src%2Ftest%2Fui%2Fsuggestions%2Fvec-macro-in-pattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fvec-macro-in-pattern.rs?ref=7d3818152d8ab5649d2e5cc6d7851ed7c03055fe", "patch": "@@ -1,8 +0,0 @@\n-// run-rustfix\n-fn main() {\n-    // everything after `.as_ref` should be suggested\n-    match Some(vec![3]).as_ref().map(|v| v.as_slice()) {\n-        Some(vec![_x]) => (), //~ ERROR unexpected `(` after qualified path\n-        _ => (),\n-    }\n-}"}, {"sha": "f9d0464ac88b1f33e8dc7fe4fcf57cbc12a657ce", "filename": "src/test/ui/suggestions/vec-macro-in-pattern.stderr", "status": "removed", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/7d3818152d8ab5649d2e5cc6d7851ed7c03055fe/src%2Ftest%2Fui%2Fsuggestions%2Fvec-macro-in-pattern.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7d3818152d8ab5649d2e5cc6d7851ed7c03055fe/src%2Ftest%2Fui%2Fsuggestions%2Fvec-macro-in-pattern.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fvec-macro-in-pattern.stderr?ref=7d3818152d8ab5649d2e5cc6d7851ed7c03055fe", "patch": "@@ -1,16 +0,0 @@\n-error: unexpected `(` after qualified path\n-  --> $DIR/vec-macro-in-pattern.rs:5:14\n-   |\n-LL |         Some(vec![_x]) => (),\n-   |              ^^^^^^^^\n-   |              |\n-   |              unexpected `(` after qualified path\n-   |              the qualified path\n-   |              in this macro invocation\n-   |              help: use a slice pattern here instead: `[_x]`\n-   |\n-   = help: for more information, see https://doc.rust-lang.org/edition-guide/rust-2018/slice-patterns.html\n-   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n-\n-error: aborting due to previous error\n-"}, {"sha": "755eec23c2ee33e886d8b835f651b2be4c95ecef", "filename": "src/test/ui/type/ascription/issue-47666.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/edeb631ad0cd6fdf31e2e31ec90e105d1768be28/src%2Ftest%2Fui%2Ftype%2Fascription%2Fissue-47666.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/edeb631ad0cd6fdf31e2e31ec90e105d1768be28/src%2Ftest%2Fui%2Ftype%2Fascription%2Fissue-47666.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype%2Fascription%2Fissue-47666.stderr?ref=edeb631ad0cd6fdf31e2e31ec90e105d1768be28", "patch": "@@ -1,4 +1,4 @@\n-error: expected type, found reserved keyword `box`\n+error: expected type, found `<[_]>::into_vec(box [0, 1])`\n   --> $DIR/issue-47666.rs:3:25\n    |\n LL |     let _ = Option:Some(vec![0, 1]);"}, {"sha": "c4db65245386f6641c8b6e156d22ba395b14f60a", "filename": "src/test/ui/underscore-imports/hygiene.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/edeb631ad0cd6fdf31e2e31ec90e105d1768be28/src%2Ftest%2Fui%2Funderscore-imports%2Fhygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edeb631ad0cd6fdf31e2e31ec90e105d1768be28/src%2Ftest%2Fui%2Funderscore-imports%2Fhygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funderscore-imports%2Fhygiene.rs?ref=edeb631ad0cd6fdf31e2e31ec90e105d1768be28", "patch": "@@ -1,13 +1,13 @@\n-// Make sure that underscore imports have the same hygiene considerations as\n-// other imports.\n+// Make sure that underscore imports have the same hygiene considerations as other imports.\n+\n+// check-pass\n \n #![feature(decl_macro)]\n \n mod x {\n     pub use std::ops::Deref as _;\n }\n \n-\n macro glob_import() {\n     pub use crate::x::*;\n }\n@@ -35,6 +35,6 @@ fn main() {\n     use crate::z::*;\n     glob_import!();\n     underscore_import!();\n-    (&()).deref();              //~ ERROR no method named `deref`\n-    (&mut ()).deref_mut();      //~ ERROR no method named `deref_mut`\n+    (&()).deref();\n+    (&mut ()).deref_mut();\n }"}, {"sha": "2983613786038ec12c506d3085c3e29d4392ac3b", "filename": "src/test/ui/underscore-imports/hygiene.stderr", "status": "removed", "additions": 0, "deletions": 27, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/7d3818152d8ab5649d2e5cc6d7851ed7c03055fe/src%2Ftest%2Fui%2Funderscore-imports%2Fhygiene.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7d3818152d8ab5649d2e5cc6d7851ed7c03055fe/src%2Ftest%2Fui%2Funderscore-imports%2Fhygiene.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funderscore-imports%2Fhygiene.stderr?ref=7d3818152d8ab5649d2e5cc6d7851ed7c03055fe", "patch": "@@ -1,27 +0,0 @@\n-error[E0599]: no method named `deref` found for reference `&()` in the current scope\n-  --> $DIR/hygiene.rs:38:11\n-   |\n-LL |     (&()).deref();\n-   |           ^^^^^ method not found in `&()`\n-   |\n-   = help: items from traits can only be used if the trait is in scope\n-help: the following trait is implemented but not in scope; perhaps add a `use` for it:\n-   |\n-LL | use std::ops::Deref;\n-   |\n-\n-error[E0599]: no method named `deref_mut` found for mutable reference `&mut ()` in the current scope\n-  --> $DIR/hygiene.rs:39:15\n-   |\n-LL |     (&mut ()).deref_mut();\n-   |               ^^^^^^^^^ method not found in `&mut ()`\n-   |\n-   = help: items from traits can only be used if the trait is in scope\n-help: the following trait is implemented but not in scope; perhaps add a `use` for it:\n-   |\n-LL | use std::ops::DerefMut;\n-   |\n-\n-error: aborting due to 2 previous errors\n-\n-For more information about this error, try `rustc --explain E0599`."}]}