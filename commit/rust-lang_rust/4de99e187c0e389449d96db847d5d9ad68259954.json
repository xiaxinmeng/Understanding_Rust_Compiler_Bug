{"sha": "4de99e187c0e389449d96db847d5d9ad68259954", "node_id": "C_kwDOAAsO6NoAKDRkZTk5ZTE4N2MwZTM4OTQ0OWQ5NmRiODQ3ZDVkOWFkNjgyNTk5NTQ", "commit": {"author": {"name": "Jubilee Young", "email": "workingjubilee@gmail.com", "date": "2022-02-28T18:17:40Z"}, "committer": {"name": "Jubilee Young", "email": "workingjubilee@gmail.com", "date": "2022-02-28T18:17:40Z"}, "message": "Sync rust-lang/portable-simd@5f49d4c8435a25d804b2f375e949cb25479f5be9", "tree": {"sha": "80225b283ee39b36f93fc43e9f89fe834d45cf38", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/80225b283ee39b36f93fc43e9f89fe834d45cf38"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4de99e187c0e389449d96db847d5d9ad68259954", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4de99e187c0e389449d96db847d5d9ad68259954", "html_url": "https://github.com/rust-lang/rust/commit/4de99e187c0e389449d96db847d5d9ad68259954", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4de99e187c0e389449d96db847d5d9ad68259954/comments", "author": {"login": "workingjubilee", "id": 46493976, "node_id": "MDQ6VXNlcjQ2NDkzOTc2", "avatar_url": "https://avatars.githubusercontent.com/u/46493976?v=4", "gravatar_id": "", "url": "https://api.github.com/users/workingjubilee", "html_url": "https://github.com/workingjubilee", "followers_url": "https://api.github.com/users/workingjubilee/followers", "following_url": "https://api.github.com/users/workingjubilee/following{/other_user}", "gists_url": "https://api.github.com/users/workingjubilee/gists{/gist_id}", "starred_url": "https://api.github.com/users/workingjubilee/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/workingjubilee/subscriptions", "organizations_url": "https://api.github.com/users/workingjubilee/orgs", "repos_url": "https://api.github.com/users/workingjubilee/repos", "events_url": "https://api.github.com/users/workingjubilee/events{/privacy}", "received_events_url": "https://api.github.com/users/workingjubilee/received_events", "type": "User", "site_admin": false}, "committer": {"login": "workingjubilee", "id": 46493976, "node_id": "MDQ6VXNlcjQ2NDkzOTc2", "avatar_url": "https://avatars.githubusercontent.com/u/46493976?v=4", "gravatar_id": "", "url": "https://api.github.com/users/workingjubilee", "html_url": "https://github.com/workingjubilee", "followers_url": "https://api.github.com/users/workingjubilee/followers", "following_url": "https://api.github.com/users/workingjubilee/following{/other_user}", "gists_url": "https://api.github.com/users/workingjubilee/gists{/gist_id}", "starred_url": "https://api.github.com/users/workingjubilee/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/workingjubilee/subscriptions", "organizations_url": "https://api.github.com/users/workingjubilee/orgs", "repos_url": "https://api.github.com/users/workingjubilee/repos", "events_url": "https://api.github.com/users/workingjubilee/events{/privacy}", "received_events_url": "https://api.github.com/users/workingjubilee/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "68369a041cea809a87e5bd80701da90e0e0a4799", "url": "https://api.github.com/repos/rust-lang/rust/commits/68369a041cea809a87e5bd80701da90e0e0a4799", "html_url": "https://github.com/rust-lang/rust/commit/68369a041cea809a87e5bd80701da90e0e0a4799"}, {"sha": "5f49d4c8435a25d804b2f375e949cb25479f5be9", "url": "https://api.github.com/repos/rust-lang/rust/commits/5f49d4c8435a25d804b2f375e949cb25479f5be9", "html_url": "https://github.com/rust-lang/rust/commit/5f49d4c8435a25d804b2f375e949cb25479f5be9"}], "stats": {"total": 561, "additions": 438, "deletions": 123}, "files": [{"sha": "c515dad4deabd455396d7d17ed4a30859ce1252b", "filename": "library/portable-simd/crates/core_simd/examples/spectral_norm.rs", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/4de99e187c0e389449d96db847d5d9ad68259954/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fexamples%2Fspectral_norm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4de99e187c0e389449d96db847d5d9ad68259954/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fexamples%2Fspectral_norm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fexamples%2Fspectral_norm.rs?ref=4de99e187c0e389449d96db847d5d9ad68259954", "patch": "@@ -0,0 +1,77 @@\n+#![feature(portable_simd)]\n+\n+use core_simd::simd::*;\n+\n+fn a(i: usize, j: usize) -> f64 {\n+    ((i + j) * (i + j + 1) / 2 + i + 1) as f64\n+}\n+\n+fn mult_av(v: &[f64], out: &mut [f64]) {\n+    assert!(v.len() == out.len());\n+    assert!(v.len() % 2 == 0);\n+\n+    for (i, out) in out.iter_mut().enumerate() {\n+        let mut sum = f64x2::splat(0.0);\n+\n+        let mut j = 0;\n+        while j < v.len() {\n+            let b = f64x2::from_slice(&v[j..]);\n+            let a = f64x2::from_array([a(i, j), a(i, j + 1)]);\n+            sum += b / a;\n+            j += 2\n+        }\n+        *out = sum.horizontal_sum();\n+    }\n+}\n+\n+fn mult_atv(v: &[f64], out: &mut [f64]) {\n+    assert!(v.len() == out.len());\n+    assert!(v.len() % 2 == 0);\n+\n+    for (i, out) in out.iter_mut().enumerate() {\n+        let mut sum = f64x2::splat(0.0);\n+\n+        let mut j = 0;\n+        while j < v.len() {\n+            let b = f64x2::from_slice(&v[j..]);\n+            let a = f64x2::from_array([a(j, i), a(j + 1, i)]);\n+            sum += b / a;\n+            j += 2\n+        }\n+        *out = sum.horizontal_sum();\n+    }\n+}\n+\n+fn mult_atav(v: &[f64], out: &mut [f64], tmp: &mut [f64]) {\n+    mult_av(v, tmp);\n+    mult_atv(tmp, out);\n+}\n+\n+pub fn spectral_norm(n: usize) -> f64 {\n+    assert!(n % 2 == 0, \"only even lengths are accepted\");\n+\n+    let mut u = vec![1.0; n];\n+    let mut v = u.clone();\n+    let mut tmp = u.clone();\n+\n+    for _ in 0..10 {\n+        mult_atav(&u, &mut v, &mut tmp);\n+        mult_atav(&v, &mut u, &mut tmp);\n+    }\n+    (dot(&u, &v) / dot(&v, &v)).sqrt()\n+}\n+\n+fn dot(x: &[f64], y: &[f64]) -> f64 {\n+    // This is auto-vectorized:\n+    x.iter().zip(y).map(|(&x, &y)| x * y).sum()\n+}\n+\n+#[cfg(test)]\n+#[test]\n+fn test() {\n+    assert_eq!(&format!(\"{:.9}\", spectral_norm(100)), \"1.274219991\");\n+}\n+\n+fn main() {\n+    // Empty main to make cargo happy\n+}"}, {"sha": "d024cf4ddbe30b04211e4460e2e0d831a1b6746d", "filename": "library/portable-simd/crates/core_simd/src/comparisons.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4de99e187c0e389449d96db847d5d9ad68259954/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fcomparisons.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4de99e187c0e389449d96db847d5d9ad68259954/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fcomparisons.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fcomparisons.rs?ref=4de99e187c0e389449d96db847d5d9ad68259954", "patch": "@@ -10,13 +10,17 @@ where\n     #[inline]\n     #[must_use = \"method returns a new mask and does not mutate the original value\"]\n     pub fn lanes_eq(self, other: Self) -> Mask<T::Mask, LANES> {\n+        // Safety: `self` is a vector, and the result of the comparison\n+        // is always a valid mask.\n         unsafe { Mask::from_int_unchecked(intrinsics::simd_eq(self, other)) }\n     }\n \n     /// Test if each lane is not equal to the corresponding lane in `other`.\n     #[inline]\n     #[must_use = \"method returns a new mask and does not mutate the original value\"]\n     pub fn lanes_ne(self, other: Self) -> Mask<T::Mask, LANES> {\n+        // Safety: `self` is a vector, and the result of the comparison\n+        // is always a valid mask.\n         unsafe { Mask::from_int_unchecked(intrinsics::simd_ne(self, other)) }\n     }\n }\n@@ -30,27 +34,35 @@ where\n     #[inline]\n     #[must_use = \"method returns a new mask and does not mutate the original value\"]\n     pub fn lanes_lt(self, other: Self) -> Mask<T::Mask, LANES> {\n+        // Safety: `self` is a vector, and the result of the comparison\n+        // is always a valid mask.\n         unsafe { Mask::from_int_unchecked(intrinsics::simd_lt(self, other)) }\n     }\n \n     /// Test if each lane is greater than the corresponding lane in `other`.\n     #[inline]\n     #[must_use = \"method returns a new mask and does not mutate the original value\"]\n     pub fn lanes_gt(self, other: Self) -> Mask<T::Mask, LANES> {\n+        // Safety: `self` is a vector, and the result of the comparison\n+        // is always a valid mask.\n         unsafe { Mask::from_int_unchecked(intrinsics::simd_gt(self, other)) }\n     }\n \n     /// Test if each lane is less than or equal to the corresponding lane in `other`.\n     #[inline]\n     #[must_use = \"method returns a new mask and does not mutate the original value\"]\n     pub fn lanes_le(self, other: Self) -> Mask<T::Mask, LANES> {\n+        // Safety: `self` is a vector, and the result of the comparison\n+        // is always a valid mask.\n         unsafe { Mask::from_int_unchecked(intrinsics::simd_le(self, other)) }\n     }\n \n     /// Test if each lane is greater than or equal to the corresponding lane in `other`.\n     #[inline]\n     #[must_use = \"method returns a new mask and does not mutate the original value\"]\n     pub fn lanes_ge(self, other: Self) -> Mask<T::Mask, LANES> {\n+        // Safety: `self` is a vector, and the result of the comparison\n+        // is always a valid mask.\n         unsafe { Mask::from_int_unchecked(intrinsics::simd_ge(self, other)) }\n     }\n }"}, {"sha": "e150946c705c964b15ca5e718527833bbb4d7b05", "filename": "library/portable-simd/crates/core_simd/src/intrinsics.rs", "status": "modified", "additions": 57, "deletions": 11, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/4de99e187c0e389449d96db847d5d9ad68259954/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4de99e187c0e389449d96db847d5d9ad68259954/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fintrinsics.rs?ref=4de99e187c0e389449d96db847d5d9ad68259954", "patch": "@@ -2,31 +2,55 @@\n //! crate.\n //!\n //! The LLVM assembly language is documented here: <https://llvm.org/docs/LangRef.html>\n+//!\n+//! A quick glossary of jargon that may appear in this module, mostly paraphrasing LLVM's LangRef:\n+//! - poison: \"undefined behavior as a value\". specifically, it is like uninit memory (such as padding bytes). it is \"safe\" to create poison, BUT\n+//!   poison MUST NOT be observed from safe code, as operations on poison return poison, like NaN. unlike NaN, which has defined comparisons,\n+//!   poison is neither true nor false, and LLVM may also convert it to undef (at which point it is both). so, it can't be conditioned on, either.\n+//! - undef: \"a value that is every value\". functionally like poison, insofar as Rust is concerned. poison may become this. note:\n+//!   this means that division by poison or undef is like division by zero, which means it inflicts...\n+//! - \"UB\": poison and undef cover most of what people call \"UB\". \"UB\" means this operation immediately invalidates the program:\n+//!   LLVM is allowed to lower it to `ud2` or other opcodes that may cause an illegal instruction exception, and this is the \"good end\".\n+//!   The \"bad end\" is that LLVM may reverse time to the moment control flow diverged on a path towards undefined behavior,\n+//!   and destroy the other branch, potentially deleting safe code and violating Rust's `unsafe` contract.\n+//!\n+//! Note that according to LLVM, vectors are not arrays, but they are equivalent when stored to and loaded from memory.\n+//!\n+//! Unless stated otherwise, all intrinsics for binary operations require SIMD vectors of equal types and lengths.\n \n /// These intrinsics aren't linked directly from LLVM and are mostly undocumented, however they are\n-/// simply lowered to the matching LLVM instructions by the compiler.  The associated instruction\n-/// is documented alongside each intrinsic.\n+/// mostly lowered to the matching LLVM instructions by the compiler in a fairly straightforward manner.\n+/// The associated LLVM instruction or intrinsic is documented alongside each Rust intrinsic function.\n extern \"platform-intrinsic\" {\n     /// add/fadd\n     pub(crate) fn simd_add<T>(x: T, y: T) -> T;\n \n     /// sub/fsub\n-    pub(crate) fn simd_sub<T>(x: T, y: T) -> T;\n+    pub(crate) fn simd_sub<T>(lhs: T, rhs: T) -> T;\n \n     /// mul/fmul\n     pub(crate) fn simd_mul<T>(x: T, y: T) -> T;\n \n     /// udiv/sdiv/fdiv\n-    pub(crate) fn simd_div<T>(x: T, y: T) -> T;\n+    /// ints and uints: {s,u}div incur UB if division by zero occurs.\n+    /// ints: sdiv is UB for int::MIN / -1.\n+    /// floats: fdiv is never UB, but may create NaNs or infinities.\n+    pub(crate) fn simd_div<T>(lhs: T, rhs: T) -> T;\n \n     /// urem/srem/frem\n-    pub(crate) fn simd_rem<T>(x: T, y: T) -> T;\n+    /// ints and uints: {s,u}rem incur UB if division by zero occurs.\n+    /// ints: srem is UB for int::MIN / -1.\n+    /// floats: frem is equivalent to libm::fmod in the \"default\" floating point environment, sans errno.\n+    pub(crate) fn simd_rem<T>(lhs: T, rhs: T) -> T;\n \n     /// shl\n-    pub(crate) fn simd_shl<T>(x: T, y: T) -> T;\n+    /// for (u)ints. poison if rhs >= lhs::BITS\n+    pub(crate) fn simd_shl<T>(lhs: T, rhs: T) -> T;\n \n-    /// lshr/ashr\n-    pub(crate) fn simd_shr<T>(x: T, y: T) -> T;\n+    /// ints: ashr\n+    /// uints: lshr\n+    /// poison if rhs >= lhs::BITS\n+    pub(crate) fn simd_shr<T>(lhs: T, rhs: T) -> T;\n \n     /// and\n     pub(crate) fn simd_and<T>(x: T, y: T) -> T;\n@@ -38,13 +62,19 @@ extern \"platform-intrinsic\" {\n     pub(crate) fn simd_xor<T>(x: T, y: T) -> T;\n \n     /// fptoui/fptosi/uitofp/sitofp\n+    /// casting floats to integers is truncating, so it is safe to convert values like e.g. 1.5\n+    /// but the truncated value must fit in the target type or the result is poison.\n+    /// use `simd_as` instead for a cast that performs a saturating conversion.\n     pub(crate) fn simd_cast<T, U>(x: T) -> U;\n     /// follows Rust's `T as U` semantics, including saturating float casts\n     /// which amounts to the same as `simd_cast` for many cases\n     #[cfg(not(bootstrap))]\n     pub(crate) fn simd_as<T, U>(x: T) -> U;\n \n     /// neg/fneg\n+    /// ints: ultimately becomes a call to cg_ssa's BuilderMethods::neg. cg_llvm equates this to `simd_sub(Simd::splat(0), x)`.\n+    /// floats: LLVM's fneg, which changes the floating point sign bit. Some arches have instructions for it.\n+    /// Rust panics for Neg::neg(int::MIN) due to overflow, but it is not UB in LLVM without `nsw`.\n     pub(crate) fn simd_neg<T>(x: T) -> T;\n \n     /// fabs\n@@ -54,6 +84,7 @@ extern \"platform-intrinsic\" {\n     pub(crate) fn simd_fmin<T>(x: T, y: T) -> T;\n     pub(crate) fn simd_fmax<T>(x: T, y: T) -> T;\n \n+    // these return Simd<int, N> with the same BITS size as the inputs\n     pub(crate) fn simd_eq<T, U>(x: T, y: T) -> U;\n     pub(crate) fn simd_ne<T, U>(x: T, y: T) -> U;\n     pub(crate) fn simd_lt<T, U>(x: T, y: T) -> U;\n@@ -62,19 +93,31 @@ extern \"platform-intrinsic\" {\n     pub(crate) fn simd_ge<T, U>(x: T, y: T) -> U;\n \n     // shufflevector\n+    // idx: LLVM calls it a \"shuffle mask vector constant\", a vector of i32s\n     pub(crate) fn simd_shuffle<T, U, V>(x: T, y: T, idx: U) -> V;\n \n+    /// llvm.masked.gather\n+    /// like a loop of pointer reads\n+    /// val: vector of values to select if a lane is masked\n+    /// ptr: vector of pointers to read from\n+    /// mask: a \"wide\" mask of integers, selects as if simd_select(mask, read(ptr), val)\n+    /// note, the LLVM intrinsic accepts a mask vector of <N x i1>\n+    /// FIXME: review this if/when we fix up our mask story in general?\n     pub(crate) fn simd_gather<T, U, V>(val: T, ptr: U, mask: V) -> T;\n+    /// llvm.masked.scatter\n+    /// like gather, but more spicy, as it writes instead of reads\n     pub(crate) fn simd_scatter<T, U, V>(val: T, ptr: U, mask: V);\n \n     // {s,u}add.sat\n     pub(crate) fn simd_saturating_add<T>(x: T, y: T) -> T;\n \n     // {s,u}sub.sat\n-    pub(crate) fn simd_saturating_sub<T>(x: T, y: T) -> T;\n+    pub(crate) fn simd_saturating_sub<T>(lhs: T, rhs: T) -> T;\n \n     // reductions\n+    // llvm.vector.reduce.{add,fadd}\n     pub(crate) fn simd_reduce_add_ordered<T, U>(x: T, y: U) -> U;\n+    // llvm.vector.reduce.{mul,fmul}\n     pub(crate) fn simd_reduce_mul_ordered<T, U>(x: T, y: U) -> U;\n     #[allow(unused)]\n     pub(crate) fn simd_reduce_all<T>(x: T) -> bool;\n@@ -91,7 +134,10 @@ extern \"platform-intrinsic\" {\n     pub(crate) fn simd_bitmask<T, U>(x: T) -> U;\n \n     // select\n-    pub(crate) fn simd_select<M, T>(m: M, a: T, b: T) -> T;\n+    // first argument is a vector of integers, -1 (all bits 1) is \"true\"\n+    // logically equivalent to (yes & m) | (no & (m^-1),\n+    // but you can use it on floats.\n+    pub(crate) fn simd_select<M, T>(m: M, yes: T, no: T) -> T;\n     #[allow(unused)]\n-    pub(crate) fn simd_select_bitmask<M, T>(m: M, a: T, b: T) -> T;\n+    pub(crate) fn simd_select_bitmask<M, T>(m: M, yes: T, no: T) -> T;\n }"}, {"sha": "91ae34c05e095884169824f1f0b0ab461e1d6c7d", "filename": "library/portable-simd/crates/core_simd/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4de99e187c0e389449d96db847d5d9ad68259954/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4de99e187c0e389449d96db847d5d9ad68259954/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Flib.rs?ref=4de99e187c0e389449d96db847d5d9ad68259954", "patch": "@@ -1,7 +1,9 @@\n #![cfg_attr(not(feature = \"std\"), no_std)]\n #![feature(\n     const_fn_trait_bound,\n+    convert_float_to_int,\n     decl_macro,\n+    intra_doc_pointers,\n     platform_intrinsics,\n     repr_simd,\n     simd_ffi,"}, {"sha": "e1cd793045046b1963e3613802290cbd5f8ad1b8", "filename": "library/portable-simd/crates/core_simd/src/masks.rs", "status": "modified", "additions": 13, "deletions": 18, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/4de99e187c0e389449d96db847d5d9ad68259954/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fmasks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4de99e187c0e389449d96db847d5d9ad68259954/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fmasks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fmasks.rs?ref=4de99e187c0e389449d96db847d5d9ad68259954", "patch": "@@ -12,8 +12,10 @@\n )]\n mod mask_impl;\n \n-use crate::simd::intrinsics;\n-use crate::simd::{LaneCount, Simd, SimdElement, SupportedLaneCount};\n+mod to_bitmask;\n+pub use to_bitmask::ToBitMask;\n+\n+use crate::simd::{intrinsics, LaneCount, Simd, SimdElement, SupportedLaneCount};\n use core::cmp::Ordering;\n use core::{fmt, mem};\n \n@@ -42,6 +44,9 @@ mod sealed {\n use sealed::Sealed;\n \n /// Marker trait for types that may be used as SIMD mask elements.\n+///\n+/// # Safety\n+/// Type must be a signed integer.\n pub unsafe trait MaskElement: SimdElement + Sealed {}\n \n macro_rules! impl_element {\n@@ -149,6 +154,7 @@ where\n     #[inline]\n     #[must_use = \"method returns a new mask and does not mutate the original value\"]\n     pub unsafe fn from_int_unchecked(value: Simd<T, LANES>) -> Self {\n+        // Safety: the caller must confirm this invariant\n         unsafe { Self(mask_impl::Mask::from_int_unchecked(value)) }\n     }\n \n@@ -161,6 +167,7 @@ where\n     #[must_use = \"method returns a new mask and does not mutate the original value\"]\n     pub fn from_int(value: Simd<T, LANES>) -> Self {\n         assert!(T::valid(value), \"all values must be either 0 or -1\",);\n+        // Safety: the validity has been checked\n         unsafe { Self::from_int_unchecked(value) }\n     }\n \n@@ -179,6 +186,7 @@ where\n     #[inline]\n     #[must_use = \"method returns a new bool and does not mutate the original value\"]\n     pub unsafe fn test_unchecked(&self, lane: usize) -> bool {\n+        // Safety: the caller must confirm this invariant\n         unsafe { self.0.test_unchecked(lane) }\n     }\n \n@@ -190,6 +198,7 @@ where\n     #[must_use = \"method returns a new bool and does not mutate the original value\"]\n     pub fn test(&self, lane: usize) -> bool {\n         assert!(lane < LANES, \"lane index out of range\");\n+        // Safety: the lane index has been checked\n         unsafe { self.test_unchecked(lane) }\n     }\n \n@@ -199,6 +208,7 @@ where\n     /// `lane` must be less than `LANES`.\n     #[inline]\n     pub unsafe fn set_unchecked(&mut self, lane: usize, value: bool) {\n+        // Safety: the caller must confirm this invariant\n         unsafe {\n             self.0.set_unchecked(lane, value);\n         }\n@@ -211,27 +221,12 @@ where\n     #[inline]\n     pub fn set(&mut self, lane: usize, value: bool) {\n         assert!(lane < LANES, \"lane index out of range\");\n+        // Safety: the lane index has been checked\n         unsafe {\n             self.set_unchecked(lane, value);\n         }\n     }\n \n-    /// Convert this mask to a bitmask, with one bit set per lane.\n-    #[cfg(feature = \"generic_const_exprs\")]\n-    #[inline]\n-    #[must_use = \"method returns a new array and does not mutate the original value\"]\n-    pub fn to_bitmask(self) -> [u8; LaneCount::<LANES>::BITMASK_LEN] {\n-        self.0.to_bitmask()\n-    }\n-\n-    /// Convert a bitmask to a mask.\n-    #[cfg(feature = \"generic_const_exprs\")]\n-    #[inline]\n-    #[must_use = \"method returns a new mask and does not mutate the original value\"]\n-    pub fn from_bitmask(bitmask: [u8; LaneCount::<LANES>::BITMASK_LEN]) -> Self {\n-        Self(mask_impl::Mask::from_bitmask(bitmask))\n-    }\n-\n     /// Returns true if any lane is set, or false otherwise.\n     #[inline]\n     #[must_use = \"method returns a new bool and does not mutate the original value\"]"}, {"sha": "ec4dd357ee98c5b4660e3173053679d30dceecce", "filename": "library/portable-simd/crates/core_simd/src/masks/bitmask.rs", "status": "modified", "additions": 13, "deletions": 10, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/4de99e187c0e389449d96db847d5d9ad68259954/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fmasks%2Fbitmask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4de99e187c0e389449d96db847d5d9ad68259954/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fmasks%2Fbitmask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fmasks%2Fbitmask.rs?ref=4de99e187c0e389449d96db847d5d9ad68259954", "patch": "@@ -1,7 +1,7 @@\n #![allow(unused_imports)]\n use super::MaskElement;\n use crate::simd::intrinsics;\n-use crate::simd::{LaneCount, Simd, SupportedLaneCount};\n+use crate::simd::{LaneCount, Simd, SupportedLaneCount, ToBitMask};\n use core::marker::PhantomData;\n \n /// A mask where each lane is represented by a single bit.\n@@ -115,20 +115,22 @@ where\n         unsafe { Self(intrinsics::simd_bitmask(value), PhantomData) }\n     }\n \n-    #[cfg(feature = \"generic_const_exprs\")]\n     #[inline]\n-    #[must_use = \"method returns a new array and does not mutate the original value\"]\n-    pub fn to_bitmask(self) -> [u8; LaneCount::<LANES>::BITMASK_LEN] {\n-        // Safety: these are the same type and we are laundering the generic\n+    pub fn to_bitmask_integer<U>(self) -> U\n+    where\n+        super::Mask<T, LANES>: ToBitMask<BitMask = U>,\n+    {\n+        // Safety: these are the same types\n         unsafe { core::mem::transmute_copy(&self.0) }\n     }\n \n-    #[cfg(feature = \"generic_const_exprs\")]\n     #[inline]\n-    #[must_use = \"method returns a new mask and does not mutate the original value\"]\n-    pub fn from_bitmask(bitmask: [u8; LaneCount::<LANES>::BITMASK_LEN]) -> Self {\n-        // Safety: these are the same type and we are laundering the generic\n-        Self(unsafe { core::mem::transmute_copy(&bitmask) }, PhantomData)\n+    pub fn from_bitmask_integer<U>(bitmask: U) -> Self\n+    where\n+        super::Mask<T, LANES>: ToBitMask<BitMask = U>,\n+    {\n+        // Safety: these are the same types\n+        unsafe { Self(core::mem::transmute_copy(&bitmask), PhantomData) }\n     }\n \n     #[inline]\n@@ -137,6 +139,7 @@ where\n     where\n         U: MaskElement,\n     {\n+        // Safety: bitmask layout does not depend on the element width\n         unsafe { core::mem::transmute_copy(&self) }\n     }\n "}, {"sha": "8bbdf637de84defcc23f1e3a8afc07d0eb2538a7", "filename": "library/portable-simd/crates/core_simd/src/masks/full_masks.rs", "status": "modified", "additions": 46, "deletions": 28, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/4de99e187c0e389449d96db847d5d9ad68259954/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fmasks%2Ffull_masks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4de99e187c0e389449d96db847d5d9ad68259954/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fmasks%2Ffull_masks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fmasks%2Ffull_masks.rs?ref=4de99e187c0e389449d96db847d5d9ad68259954", "patch": "@@ -2,7 +2,7 @@\n \n use super::MaskElement;\n use crate::simd::intrinsics;\n-use crate::simd::{LaneCount, Simd, SupportedLaneCount};\n+use crate::simd::{LaneCount, Simd, SupportedLaneCount, ToBitMask};\n \n #[repr(transparent)]\n pub struct Mask<T, const LANES: usize>(Simd<T, LANES>)\n@@ -66,6 +66,23 @@ where\n     }\n }\n \n+// Used for bitmask bit order workaround\n+pub(crate) trait ReverseBits {\n+    fn reverse_bits(self) -> Self;\n+}\n+\n+macro_rules! impl_reverse_bits {\n+    { $($int:ty),* } => {\n+        $(\n+        impl ReverseBits for $int {\n+            fn reverse_bits(self) -> Self { <$int>::reverse_bits(self) }\n+        }\n+        )*\n+    }\n+}\n+\n+impl_reverse_bits! { u8, u16, u32, u64 }\n+\n impl<T, const LANES: usize> Mask<T, LANES>\n where\n     T: MaskElement,\n@@ -106,44 +123,40 @@ where\n     where\n         U: MaskElement,\n     {\n+        // Safety: masks are simply integer vectors of 0 and -1, and we can cast the element type.\n         unsafe { Mask(intrinsics::simd_cast(self.0)) }\n     }\n \n-    #[cfg(feature = \"generic_const_exprs\")]\n     #[inline]\n-    #[must_use = \"method returns a new array and does not mutate the original value\"]\n-    pub fn to_bitmask(self) -> [u8; LaneCount::<LANES>::BITMASK_LEN] {\n-        unsafe {\n-            let mut bitmask: [u8; LaneCount::<LANES>::BITMASK_LEN] =\n-                intrinsics::simd_bitmask(self.0);\n-\n-            // There is a bug where LLVM appears to implement this operation with the wrong\n-            // bit order.\n-            // TODO fix this in a better way\n-            if cfg!(target_endian = \"big\") {\n-                for x in bitmask.as_mut() {\n-                    *x = x.reverse_bits();\n-                }\n-            }\n+    pub(crate) fn to_bitmask_integer<U: ReverseBits>(self) -> U\n+    where\n+        super::Mask<T, LANES>: ToBitMask<BitMask = U>,\n+    {\n+        // Safety: U is required to be the appropriate bitmask type\n+        let bitmask: U = unsafe { intrinsics::simd_bitmask(self.0) };\n \n+        // LLVM assumes bit order should match endianness\n+        if cfg!(target_endian = \"big\") {\n+            bitmask.reverse_bits()\n+        } else {\n             bitmask\n         }\n     }\n \n-    #[cfg(feature = \"generic_const_exprs\")]\n     #[inline]\n-    #[must_use = \"method returns a new mask and does not mutate the original value\"]\n-    pub fn from_bitmask(mut bitmask: [u8; LaneCount::<LANES>::BITMASK_LEN]) -> Self {\n-        unsafe {\n-            // There is a bug where LLVM appears to implement this operation with the wrong\n-            // bit order.\n-            // TODO fix this in a better way\n-            if cfg!(target_endian = \"big\") {\n-                for x in bitmask.as_mut() {\n-                    *x = x.reverse_bits();\n-                }\n-            }\n+    pub(crate) fn from_bitmask_integer<U: ReverseBits>(bitmask: U) -> Self\n+    where\n+        super::Mask<T, LANES>: ToBitMask<BitMask = U>,\n+    {\n+        // LLVM assumes bit order should match endianness\n+        let bitmask = if cfg!(target_endian = \"big\") {\n+            bitmask.reverse_bits()\n+        } else {\n+            bitmask\n+        };\n \n+        // Safety: U is required to be the appropriate bitmask type\n+        unsafe {\n             Self::from_int_unchecked(intrinsics::simd_select_bitmask(\n                 bitmask,\n                 Self::splat(true).to_int(),\n@@ -155,12 +168,14 @@ where\n     #[inline]\n     #[must_use = \"method returns a new bool and does not mutate the original value\"]\n     pub fn any(self) -> bool {\n+        // Safety: use `self` as an integer vector\n         unsafe { intrinsics::simd_reduce_any(self.to_int()) }\n     }\n \n     #[inline]\n     #[must_use = \"method returns a new vector and does not mutate the original value\"]\n     pub fn all(self) -> bool {\n+        // Safety: use `self` as an integer vector\n         unsafe { intrinsics::simd_reduce_all(self.to_int()) }\n     }\n }\n@@ -184,6 +199,7 @@ where\n     #[inline]\n     #[must_use = \"method returns a new mask and does not mutate the original value\"]\n     fn bitand(self, rhs: Self) -> Self {\n+        // Safety: `self` is an integer vector\n         unsafe { Self(intrinsics::simd_and(self.0, rhs.0)) }\n     }\n }\n@@ -197,6 +213,7 @@ where\n     #[inline]\n     #[must_use = \"method returns a new mask and does not mutate the original value\"]\n     fn bitor(self, rhs: Self) -> Self {\n+        // Safety: `self` is an integer vector\n         unsafe { Self(intrinsics::simd_or(self.0, rhs.0)) }\n     }\n }\n@@ -210,6 +227,7 @@ where\n     #[inline]\n     #[must_use = \"method returns a new mask and does not mutate the original value\"]\n     fn bitxor(self, rhs: Self) -> Self {\n+        // Safety: `self` is an integer vector\n         unsafe { Self(intrinsics::simd_xor(self.0, rhs.0)) }\n     }\n }"}, {"sha": "1c2037764c1e45af1960550df93cc290af05eaee", "filename": "library/portable-simd/crates/core_simd/src/masks/to_bitmask.rs", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/4de99e187c0e389449d96db847d5d9ad68259954/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fmasks%2Fto_bitmask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4de99e187c0e389449d96db847d5d9ad68259954/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fmasks%2Fto_bitmask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fmasks%2Fto_bitmask.rs?ref=4de99e187c0e389449d96db847d5d9ad68259954", "patch": "@@ -0,0 +1,57 @@\n+use super::{mask_impl, Mask, MaskElement};\n+use crate::simd::{LaneCount, SupportedLaneCount};\n+\n+mod sealed {\n+    pub trait Sealed {}\n+}\n+pub use sealed::Sealed;\n+\n+impl<T, const LANES: usize> Sealed for Mask<T, LANES>\n+where\n+    T: MaskElement,\n+    LaneCount<LANES>: SupportedLaneCount,\n+{\n+}\n+\n+/// Converts masks to and from integer bitmasks.\n+///\n+/// Each bit of the bitmask corresponds to a mask lane, starting with the LSB.\n+///\n+/// # Safety\n+/// This trait is `unsafe` and sealed, since the `BitMask` type must match the number of lanes in\n+/// the mask.\n+pub unsafe trait ToBitMask: Sealed {\n+    /// The integer bitmask type.\n+    type BitMask;\n+\n+    /// Converts a mask to a bitmask.\n+    fn to_bitmask(self) -> Self::BitMask;\n+\n+    /// Converts a bitmask to a mask.\n+    fn from_bitmask(bitmask: Self::BitMask) -> Self;\n+}\n+\n+macro_rules! impl_integer_intrinsic {\n+    { $(unsafe impl ToBitMask<BitMask=$int:ty> for Mask<_, $lanes:literal>)* } => {\n+        $(\n+        unsafe impl<T: MaskElement> ToBitMask for Mask<T, $lanes> {\n+            type BitMask = $int;\n+\n+            fn to_bitmask(self) -> $int {\n+                self.0.to_bitmask_integer()\n+            }\n+\n+            fn from_bitmask(bitmask: $int) -> Self {\n+                Self(mask_impl::Mask::from_bitmask_integer(bitmask))\n+            }\n+        }\n+        )*\n+    }\n+}\n+\n+impl_integer_intrinsic! {\n+    unsafe impl ToBitMask<BitMask=u8> for Mask<_, 8>\n+    unsafe impl ToBitMask<BitMask=u16> for Mask<_, 16>\n+    unsafe impl ToBitMask<BitMask=u32> for Mask<_, 32>\n+    unsafe impl ToBitMask<BitMask=u64> for Mask<_, 64>\n+}"}, {"sha": "0b4e40983af53e8a54eb11d902850aef0fb53fb1", "filename": "library/portable-simd/crates/core_simd/src/math.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4de99e187c0e389449d96db847d5d9ad68259954/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fmath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4de99e187c0e389449d96db847d5d9ad68259954/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fmath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fmath.rs?ref=4de99e187c0e389449d96db847d5d9ad68259954", "patch": "@@ -22,6 +22,7 @@ macro_rules! impl_uint_arith {\n             /// ```\n             #[inline]\n             pub fn saturating_add(self, second: Self) -> Self {\n+                // Safety: `self` is a vector\n                 unsafe { simd_saturating_add(self, second) }\n             }\n \n@@ -41,6 +42,7 @@ macro_rules! impl_uint_arith {\n             /// assert_eq!(sat, Simd::splat(0));\n             #[inline]\n             pub fn saturating_sub(self, second: Self) -> Self {\n+                // Safety: `self` is a vector\n                 unsafe { simd_saturating_sub(self, second) }\n             }\n         })+\n@@ -68,6 +70,7 @@ macro_rules! impl_int_arith {\n             /// ```\n             #[inline]\n             pub fn saturating_add(self, second: Self) -> Self {\n+                // Safety: `self` is a vector\n                 unsafe { simd_saturating_add(self, second) }\n             }\n \n@@ -87,6 +90,7 @@ macro_rules! impl_int_arith {\n             /// assert_eq!(sat, Simd::from_array([MIN, MIN, MIN, 0]));\n             #[inline]\n             pub fn saturating_sub(self, second: Self) -> Self {\n+                // Safety: `self` is a vector\n                 unsafe { simd_saturating_sub(self, second) }\n             }\n "}, {"sha": "1b35b3e717a3259591b84c1d15bd1fdff24a40d8", "filename": "library/portable-simd/crates/core_simd/src/ops.rs", "status": "modified", "additions": 24, "deletions": 15, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/4de99e187c0e389449d96db847d5d9ad68259954/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4de99e187c0e389449d96db847d5d9ad68259954/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fops.rs?ref=4de99e187c0e389449d96db847d5d9ad68259954", "patch": "@@ -57,29 +57,40 @@ macro_rules! wrap_bitshift {\n     };\n }\n \n-// Division by zero is poison, according to LLVM.\n-// So is dividing the MIN value of a signed integer by -1,\n-// since that would return MAX + 1.\n-// FIXME: Rust allows <SInt>::MIN / -1,\n-// so we should probably figure out how to make that safe.\n+/// SAFETY: This macro must only be used to impl Div or Rem and given the matching intrinsic.\n+/// It guards against LLVM's UB conditions for integer div or rem using masks and selects,\n+/// thus guaranteeing a Rust value returns instead.\n+///\n+/// |                  | LLVM | Rust\n+/// | :--------------: | :--- | :----------\n+/// | N {/,%} 0        | UB   | panic!()\n+/// | <$int>::MIN / -1 | UB   | <$int>::MIN\n+/// | <$int>::MIN % -1 | UB   | 0\n+///\n macro_rules! int_divrem_guard {\n     (   $lhs:ident,\n         $rhs:ident,\n         {   const PANIC_ZERO: &'static str = $zero:literal;\n-            const PANIC_OVERFLOW: &'static str = $overflow:literal;\n             $simd_call:ident\n         },\n         $int:ident ) => {\n         if $rhs.lanes_eq(Simd::splat(0)).any() {\n             panic!($zero);\n-        } else if <$int>::MIN != 0\n-            && ($lhs.lanes_eq(Simd::splat(<$int>::MIN))\n-                // type inference can break here, so cut an SInt to size\n-                & $rhs.lanes_eq(Simd::splat(-1i64 as _))).any()\n-        {\n-            panic!($overflow);\n         } else {\n-            unsafe { $crate::simd::intrinsics::$simd_call($lhs, $rhs) }\n+            // Prevent otherwise-UB overflow on the MIN / -1 case.\n+            let rhs = if <$int>::MIN != 0 {\n+                // This should, at worst, optimize to a few branchless logical ops\n+                // Ideally, this entire conditional should evaporate\n+                // Fire LLVM and implement those manually if it doesn't get the hint\n+                ($lhs.lanes_eq(Simd::splat(<$int>::MIN))\n+                // type inference can break here, so cut an SInt to size\n+                & $rhs.lanes_eq(Simd::splat(-1i64 as _)))\n+                .select(Simd::splat(1), $rhs)\n+            } else {\n+                // Nice base case to make it easy to const-fold away the other branch.\n+                $rhs\n+            };\n+            unsafe { $crate::simd::intrinsics::$simd_call($lhs, rhs) }\n         }\n     };\n }\n@@ -183,15 +194,13 @@ for_base_ops! {\n     impl Div::div {\n         int_divrem_guard {\n             const PANIC_ZERO: &'static str = \"attempt to divide by zero\";\n-            const PANIC_OVERFLOW: &'static str = \"attempt to divide with overflow\";\n             simd_div\n         }\n     }\n \n     impl Rem::rem {\n         int_divrem_guard {\n             const PANIC_ZERO: &'static str = \"attempt to calculate the remainder with a divisor of zero\";\n-            const PANIC_OVERFLOW: &'static str = \"attempt to calculate the remainder with overflow\";\n             simd_rem\n         }\n     }"}, {"sha": "e1cd743e44247d55c4c9f49f6f004a60d981a7cb", "filename": "library/portable-simd/crates/core_simd/src/reduction.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4de99e187c0e389449d96db847d5d9ad68259954/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Freduction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4de99e187c0e389449d96db847d5d9ad68259954/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Freduction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Freduction.rs?ref=4de99e187c0e389449d96db847d5d9ad68259954", "patch": "@@ -14,24 +14,28 @@ macro_rules! impl_integer_reductions {\n             /// Horizontal wrapping add.  Returns the sum of the lanes of the vector, with wrapping addition.\n             #[inline]\n             pub fn horizontal_sum(self) -> $scalar {\n+                // Safety: `self` is an integer vector\n                 unsafe { simd_reduce_add_ordered(self, 0) }\n             }\n \n             /// Horizontal wrapping multiply.  Returns the product of the lanes of the vector, with wrapping multiplication.\n             #[inline]\n             pub fn horizontal_product(self) -> $scalar {\n+                // Safety: `self` is an integer vector\n                 unsafe { simd_reduce_mul_ordered(self, 1) }\n             }\n \n             /// Horizontal maximum.  Returns the maximum lane in the vector.\n             #[inline]\n             pub fn horizontal_max(self) -> $scalar {\n+                // Safety: `self` is an integer vector\n                 unsafe { simd_reduce_max(self) }\n             }\n \n             /// Horizontal minimum.  Returns the minimum lane in the vector.\n             #[inline]\n             pub fn horizontal_min(self) -> $scalar {\n+                // Safety: `self` is an integer vector\n                 unsafe { simd_reduce_min(self) }\n             }\n         }\n@@ -63,6 +67,7 @@ macro_rules! impl_float_reductions {\n                 if cfg!(all(target_arch = \"x86\", not(target_feature = \"sse2\"))) {\n                     self.as_array().iter().sum()\n                 } else {\n+                    // Safety: `self` is a float vector\n                     unsafe { simd_reduce_add_ordered(self, 0.) }\n                 }\n             }\n@@ -74,6 +79,7 @@ macro_rules! impl_float_reductions {\n                 if cfg!(all(target_arch = \"x86\", not(target_feature = \"sse2\"))) {\n                     self.as_array().iter().product()\n                 } else {\n+                    // Safety: `self` is a float vector\n                     unsafe { simd_reduce_mul_ordered(self, 1.) }\n                 }\n             }\n@@ -84,6 +90,7 @@ macro_rules! impl_float_reductions {\n             /// return either.  This function will not return `NaN` unless all lanes are `NaN`.\n             #[inline]\n             pub fn horizontal_max(self) -> $scalar {\n+                // Safety: `self` is a float vector\n                 unsafe { simd_reduce_max(self) }\n             }\n \n@@ -93,6 +100,7 @@ macro_rules! impl_float_reductions {\n             /// return either.  This function will not return `NaN` unless all lanes are `NaN`.\n             #[inline]\n             pub fn horizontal_min(self) -> $scalar {\n+                // Safety: `self` is a float vector\n                 unsafe { simd_reduce_min(self) }\n             }\n         }"}, {"sha": "556bc2cc1feee8a114253cdb99d464a5438b3bba", "filename": "library/portable-simd/crates/core_simd/src/round.rs", "status": "modified", "additions": 15, "deletions": 12, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/4de99e187c0e389449d96db847d5d9ad68259954/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fround.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4de99e187c0e389449d96db847d5d9ad68259954/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fround.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fround.rs?ref=4de99e187c0e389449d96db847d5d9ad68259954", "patch": "@@ -1,9 +1,10 @@\n use crate::simd::intrinsics;\n-use crate::simd::{LaneCount, Simd, SupportedLaneCount};\n+use crate::simd::{LaneCount, Simd, SimdElement, SupportedLaneCount};\n+use core::convert::FloatToInt;\n \n macro_rules! implement {\n     {\n-        $type:ty, $int_type:ty\n+        $type:ty\n     } => {\n         impl<const LANES: usize> Simd<$type, LANES>\n         where\n@@ -18,20 +19,22 @@ macro_rules! implement {\n             /// * Not be NaN\n             /// * Not be infinite\n             /// * Be representable in the return type, after truncating off its fractional part\n+            ///\n+            /// If these requirements are infeasible or costly, consider using the safe function [cast],\n+            /// which saturates on conversion.\n+            ///\n+            /// [cast]: Simd::cast\n             #[inline]\n-            pub unsafe fn to_int_unchecked(self) -> Simd<$int_type, LANES> {\n+            pub unsafe fn to_int_unchecked<I>(self) -> Simd<I, LANES>\n+            where\n+                $type: FloatToInt<I>,\n+                I: SimdElement,\n+            {\n                 unsafe { intrinsics::simd_cast(self) }\n             }\n-\n-            /// Creates a floating-point vector from an integer vector.  Rounds values that are\n-            /// not exactly representable.\n-            #[inline]\n-            pub fn round_from_int(value: Simd<$int_type, LANES>) -> Self {\n-                unsafe { intrinsics::simd_cast(value) }\n-            }\n         }\n     }\n }\n \n-implement! { f32, i32 }\n-implement! { f64, i64 }\n+implement! { f32 }\n+implement! { f64 }"}, {"sha": "3acf07260e12b058ec3bb1532c24d1d77cfac312", "filename": "library/portable-simd/crates/core_simd/src/select.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4de99e187c0e389449d96db847d5d9ad68259954/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4de99e187c0e389449d96db847d5d9ad68259954/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fselect.rs?ref=4de99e187c0e389449d96db847d5d9ad68259954", "patch": "@@ -11,6 +11,7 @@ where\n     /// For each lane in the mask, choose the corresponding lane from `true_values` if\n     /// that lane mask is true, and `false_values` if that lane mask is false.\n     ///\n+    /// # Examples\n     /// ```\n     /// # #![feature(portable_simd)]\n     /// # #[cfg(feature = \"std\")] use core_simd::{Simd, Mask};\n@@ -31,6 +32,8 @@ where\n     where\n         U: SimdElement<Mask = T>,\n     {\n+        // Safety: The mask has been cast to a vector of integers,\n+        // and the operands to select between are vectors of the same type and length.\n         unsafe { intrinsics::simd_select(self.to_int(), true_values, false_values) }\n     }\n \n@@ -39,6 +42,7 @@ where\n     /// For each lane in the mask, choose the corresponding lane from `true_values` if\n     /// that lane mask is true, and `false_values` if that lane mask is false.\n     ///\n+    /// # Examples\n     /// ```\n     /// # #![feature(portable_simd)]\n     /// # #[cfg(feature = \"std\")] use core_simd::Mask;"}, {"sha": "08b2add11667a77e94444459bb37c06effa67e33", "filename": "library/portable-simd/crates/core_simd/src/swizzle.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4de99e187c0e389449d96db847d5d9ad68259954/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fswizzle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4de99e187c0e389449d96db847d5d9ad68259954/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fswizzle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fswizzle.rs?ref=4de99e187c0e389449d96db847d5d9ad68259954", "patch": "@@ -95,6 +95,7 @@ pub trait Swizzle<const INPUT_LANES: usize, const OUTPUT_LANES: usize> {\n         LaneCount<INPUT_LANES>: SupportedLaneCount,\n         LaneCount<OUTPUT_LANES>: SupportedLaneCount,\n     {\n+        // Safety: `vector` is a vector, and `INDEX_IMPL` is a const array of u32.\n         unsafe { intrinsics::simd_shuffle(vector, vector, Self::INDEX_IMPL) }\n     }\n }\n@@ -119,6 +120,7 @@ pub trait Swizzle2<const INPUT_LANES: usize, const OUTPUT_LANES: usize> {\n         LaneCount<INPUT_LANES>: SupportedLaneCount,\n         LaneCount<OUTPUT_LANES>: SupportedLaneCount,\n     {\n+        // Safety: `first` and `second` are vectors, and `INDEX_IMPL` is a const array of u32.\n         unsafe { intrinsics::simd_shuffle(first, second, Self::INDEX_IMPL) }\n     }\n }"}, {"sha": "b36b1a347b226866431060589d157a5d6bfee197", "filename": "library/portable-simd/crates/core_simd/src/to_bytes.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4de99e187c0e389449d96db847d5d9ad68259954/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fto_bytes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4de99e187c0e389449d96db847d5d9ad68259954/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fto_bytes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fto_bytes.rs?ref=4de99e187c0e389449d96db847d5d9ad68259954", "patch": "@@ -8,12 +8,14 @@ macro_rules! impl_to_bytes {\n             /// Return the memory representation of this integer as a byte array in native byte\n             /// order.\n             pub fn to_ne_bytes(self) -> crate::simd::Simd<u8, {{ $size * LANES }}> {\n+                // Safety: transmuting between vectors is safe\n                 unsafe { core::mem::transmute_copy(&self) }\n             }\n \n             /// Create a native endian integer value from its memory representation as a byte array\n             /// in native endianness.\n             pub fn from_ne_bytes(bytes: crate::simd::Simd<u8, {{ $size * LANES }}>) -> Self {\n+                // Safety: transmuting between vectors is safe\n                 unsafe { core::mem::transmute_copy(&bytes) }\n             }\n         }"}, {"sha": "ff1b2c756ad4025bb208502eb5f0db6bb2f5c0b0", "filename": "library/portable-simd/crates/core_simd/src/vector.rs", "status": "modified", "additions": 81, "deletions": 6, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/4de99e187c0e389449d96db847d5d9ad68259954/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fvector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4de99e187c0e389449d96db847d5d9ad68259954/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fvector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fvector.rs?ref=4de99e187c0e389449d96db847d5d9ad68259954", "patch": "@@ -12,7 +12,79 @@ pub(crate) mod ptr;\n use crate::simd::intrinsics;\n use crate::simd::{LaneCount, Mask, MaskElement, SupportedLaneCount};\n \n-/// A SIMD vector of `LANES` elements of type `T`.\n+/// A SIMD vector of `LANES` elements of type `T`. `Simd<T, N>` has the same shape as [`[T; N]`](array), but operates like `T`.\n+///\n+/// Two vectors of the same type and length will, by convention, support the operators (+, *, etc.) that `T` does.\n+/// These take the lanes at each index on the left-hand side and right-hand side, perform the operation,\n+/// and return the result in the same lane in a vector of equal size. For a given operator, this is equivalent to zipping\n+/// the two arrays together and mapping the operator over each lane.\n+///\n+/// ```rust\n+/// # #![feature(array_zip, portable_simd)]\n+/// # use core::simd::{Simd};\n+/// let a0: [i32; 4] = [-2, 0, 2, 4];\n+/// let a1 = [10, 9, 8, 7];\n+/// let zm_add = a0.zip(a1).map(|(lhs, rhs)| lhs + rhs);\n+/// let zm_mul = a0.zip(a1).map(|(lhs, rhs)| lhs * rhs);\n+///\n+/// // `Simd<T, N>` implements `From<[T; N]>\n+/// let (v0, v1) = (Simd::from(a0), Simd::from(a1));\n+/// // Which means arrays implement `Into<Simd<T, N>>`.\n+/// assert_eq!(v0 + v1, zm_add.into());\n+/// assert_eq!(v0 * v1, zm_mul.into());\n+/// ```\n+///\n+/// `Simd` with integers has the quirk that these operations are also inherently wrapping, as if `T` was [`Wrapping<T>`].\n+/// Thus, `Simd` does not implement `wrapping_add`, because that is the default behavior.\n+/// This means there is no warning on overflows, even in \"debug\" builds.\n+/// For most applications where `Simd` is appropriate, it is \"not a bug\" to wrap,\n+/// and even \"debug builds\" are unlikely to tolerate the loss of performance.\n+/// You may want to consider using explicitly checked arithmetic if such is required.\n+/// Division by zero still causes a panic, so you may want to consider using floating point numbers if that is unacceptable.\n+///\n+/// [`Wrapping<T>`]: core::num::Wrapping\n+///\n+/// # Layout\n+/// `Simd<T, N>` has a layout similar to `[T; N]` (identical \"shapes\"), but with a greater alignment.\n+/// `[T; N]` is aligned to `T`, but `Simd<T, N>` will have an alignment based on both `T` and `N`.\n+/// It is thus sound to [`transmute`] `Simd<T, N>` to `[T; N]`, and will typically optimize to zero cost,\n+/// but the reverse transmutation is more likely to require a copy the compiler cannot simply elide.\n+///\n+/// # ABI \"Features\"\n+/// Due to Rust's safety guarantees, `Simd<T, N>` is currently passed to and from functions via memory, not SIMD registers,\n+/// except as an optimization. `#[inline]` hints are recommended on functions that accept `Simd<T, N>` or return it.\n+/// The need for this may be corrected in the future.\n+///\n+/// # Safe SIMD with Unsafe Rust\n+///\n+/// Operations with `Simd` are typically safe, but there are many reasons to want to combine SIMD with `unsafe` code.\n+/// Care must be taken to respect differences between `Simd` and other types it may be transformed into or derived from.\n+/// In particular, the layout of `Simd<T, N>` may be similar to `[T; N]`, and may allow some transmutations,\n+/// but references to `[T; N]` are not interchangeable with those to `Simd<T, N>`.\n+/// Thus, when using `unsafe` Rust to read and write `Simd<T, N>` through [raw pointers], it is a good idea to first try with\n+/// [`read_unaligned`] and [`write_unaligned`]. This is because:\n+/// - [`read`] and [`write`] require full alignment (in this case, `Simd<T, N>`'s alignment)\n+/// - the likely source for reading or destination for writing `Simd<T, N>` is [`[T]`](slice) and similar types, aligned to `T`\n+/// - combining these actions would violate the `unsafe` contract and explode the program into a puff of **undefined behavior**\n+/// - the compiler can implicitly adjust layouts to make unaligned reads or writes fully aligned if it sees the optimization\n+/// - most contemporary processors suffer no performance penalty for \"unaligned\" reads and writes that are aligned at runtime\n+///\n+/// By imposing less obligations, unaligned functions are less likely to make the program unsound,\n+/// and may be just as fast as stricter alternatives.\n+/// When trying to guarantee alignment, [`[T]::as_simd`][as_simd] is an option for converting `[T]` to `[Simd<T, N>]`,\n+/// and allows soundly operating on an aligned SIMD body, but it may cost more time when handling the scalar head and tail.\n+/// If these are not sufficient, then it is most ideal to design data structures to be already aligned\n+/// to the `Simd<T, N>` you wish to use before using `unsafe` Rust to read or write.\n+/// More conventional ways to compensate for these facts, like materializing `Simd` to or from an array first,\n+/// are handled by safe methods like [`Simd::from_array`] and [`Simd::from_slice`].\n+///\n+/// [`transmute`]: core::mem::transmute\n+/// [raw pointers]: pointer\n+/// [`read_unaligned`]: pointer::read_unaligned\n+/// [`write_unaligned`]: pointer::write_unaligned\n+/// [`read`]: pointer::read\n+/// [`write`]: pointer::write\n+/// [as_simd]: slice::as_simd\n #[repr(simd)]\n pub struct Simd<T, const LANES: usize>([T; LANES])\n where\n@@ -102,6 +174,7 @@ where\n     #[inline]\n     #[cfg(not(bootstrap))]\n     pub fn cast<U: SimdElement>(self) -> Simd<U, LANES> {\n+        // Safety: The input argument is a vector of a known SIMD type.\n         unsafe { intrinsics::simd_as(self) }\n     }\n \n@@ -175,7 +248,7 @@ where\n         or: Self,\n     ) -> Self {\n         let enable: Mask<isize, LANES> = enable & idxs.lanes_lt(Simd::splat(slice.len()));\n-        // SAFETY: We have masked-off out-of-bounds lanes.\n+        // Safety: We have masked-off out-of-bounds lanes.\n         unsafe { Self::gather_select_unchecked(slice, enable, idxs, or) }\n     }\n \n@@ -216,7 +289,7 @@ where\n         let base_ptr = crate::simd::ptr::SimdConstPtr::splat(slice.as_ptr());\n         // Ferris forgive me, I have done pointer arithmetic here.\n         let ptrs = base_ptr.wrapping_add(idxs);\n-        // SAFETY: The ptrs have been bounds-masked to prevent memory-unsafe reads insha'allah\n+        // Safety: The ptrs have been bounds-masked to prevent memory-unsafe reads insha'allah\n         unsafe { intrinsics::simd_gather(or, ptrs, enable.to_int()) }\n     }\n \n@@ -268,7 +341,7 @@ where\n         idxs: Simd<usize, LANES>,\n     ) {\n         let enable: Mask<isize, LANES> = enable & idxs.lanes_lt(Simd::splat(slice.len()));\n-        // SAFETY: We have masked-off out-of-bounds lanes.\n+        // Safety: We have masked-off out-of-bounds lanes.\n         unsafe { self.scatter_select_unchecked(slice, enable, idxs) }\n     }\n \n@@ -307,7 +380,7 @@ where\n         enable: Mask<isize, LANES>,\n         idxs: Simd<usize, LANES>,\n     ) {\n-        // SAFETY: This block works with *mut T derived from &mut 'a [T],\n+        // Safety: This block works with *mut T derived from &mut 'a [T],\n         // which means it is delicate in Rust's borrowing model, circa 2021:\n         // &mut 'a [T] asserts uniqueness, so deriving &'a [T] invalidates live *mut Ts!\n         // Even though this block is largely safe methods, it must be exactly this way\n@@ -487,7 +560,9 @@ mod sealed {\n use sealed::Sealed;\n \n /// Marker trait for types that may be used as SIMD vector elements.\n-/// SAFETY: This trait, when implemented, asserts the compiler can monomorphize\n+///\n+/// # Safety\n+/// This trait, when implemented, asserts the compiler can monomorphize\n /// `#[repr(simd)]` structs with the marked type as an element.\n /// Strictly, it is valid to impl if the vector will not be miscompiled.\n /// Practically, it is user-unfriendly to impl it if the vector won't compile,"}, {"sha": "417d255c28d63b26db02107d73a650d2566aebf2", "filename": "library/portable-simd/crates/core_simd/src/vector/ptr.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4de99e187c0e389449d96db847d5d9ad68259954/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fvector%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4de99e187c0e389449d96db847d5d9ad68259954/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fvector%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fvector%2Fptr.rs?ref=4de99e187c0e389449d96db847d5d9ad68259954", "patch": "@@ -21,6 +21,8 @@ where\n     #[inline]\n     #[must_use]\n     pub fn wrapping_add(self, addend: Simd<usize, LANES>) -> Self {\n+        // Safety: converting pointers to usize and vice-versa is safe\n+        // (even if using that pointer is not)\n         unsafe {\n             let x: Simd<usize, LANES> = mem::transmute_copy(&self);\n             mem::transmute_copy(&{ x + (addend * Simd::splat(mem::size_of::<T>())) })\n@@ -47,6 +49,8 @@ where\n     #[inline]\n     #[must_use]\n     pub fn wrapping_add(self, addend: Simd<usize, LANES>) -> Self {\n+        // Safety: converting pointers to usize and vice-versa is safe\n+        // (even if using that pointer is not)\n         unsafe {\n             let x: Simd<usize, LANES> = mem::transmute_copy(&self);\n             mem::transmute_copy(&{ x + (addend * Simd::splat(mem::size_of::<T>())) })"}, {"sha": "9fb70218c954374b71caa1a34e8c76871d48963f", "filename": "library/portable-simd/crates/core_simd/src/vendor.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4de99e187c0e389449d96db847d5d9ad68259954/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fvendor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4de99e187c0e389449d96db847d5d9ad68259954/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fvendor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fvendor.rs?ref=4de99e187c0e389449d96db847d5d9ad68259954", "patch": "@@ -9,6 +9,8 @@ macro_rules! from_transmute {\n         impl core::convert::From<$from> for $to {\n             #[inline]\n             fn from(value: $from) -> $to {\n+                // Safety: transmuting between vectors is safe, but the caller of this macro\n+                // checks the invariants\n                 unsafe { core::mem::transmute(value) }\n             }\n         }"}, {"sha": "3aec36ca7b7468b89f9a23401c85bbfd7a7b6151", "filename": "library/portable-simd/crates/core_simd/tests/masks.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4de99e187c0e389449d96db847d5d9ad68259954/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Ftests%2Fmasks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4de99e187c0e389449d96db847d5d9ad68259954/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Ftests%2Fmasks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Ftests%2Fmasks.rs?ref=4de99e187c0e389449d96db847d5d9ad68259954", "patch": "@@ -68,16 +68,16 @@ macro_rules! test_mask_api {\n                 assert_eq!(core_simd::Mask::<$type, 8>::from_int(int), mask);\n             }\n \n-            #[cfg(feature = \"generic_const_exprs\")]\n             #[test]\n             fn roundtrip_bitmask_conversion() {\n+                use core_simd::ToBitMask;\n                 let values = [\n                     true, false, false, true, false, false, true, false,\n                     true, true, false, false, false, false, false, true,\n                 ];\n                 let mask = core_simd::Mask::<$type, 16>::from_array(values);\n                 let bitmask = mask.to_bitmask();\n-                assert_eq!(bitmask, [0b01001001, 0b10000011]);\n+                assert_eq!(bitmask, 0b1000001101001001);\n                 assert_eq!(core_simd::Mask::<$type, 16>::from_bitmask(bitmask), mask);\n             }\n         }"}, {"sha": "50f7a4ca170db983187a26dfc251a9aafacb91b0", "filename": "library/portable-simd/crates/core_simd/tests/ops_macros.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/4de99e187c0e389449d96db847d5d9ad68259954/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Ftests%2Fops_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4de99e187c0e389449d96db847d5d9ad68259954/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Ftests%2Fops_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Ftests%2Fops_macros.rs?ref=4de99e187c0e389449d96db847d5d9ad68259954", "patch": "@@ -210,15 +210,21 @@ macro_rules! impl_signed_tests {\n                     )\n                 }\n \n-            }\n+                fn div_min_may_overflow<const LANES: usize>() {\n+                    let a = Vector::<LANES>::splat(Scalar::MIN);\n+                    let b = Vector::<LANES>::splat(-1);\n+                    assert_eq!(a / b, a);\n+                }\n \n-            test_helpers::test_lanes_panic! {\n-                fn div_min_overflow_panics<const LANES: usize>() {\n+                fn rem_min_may_overflow<const LANES: usize>() {\n                     let a = Vector::<LANES>::splat(Scalar::MIN);\n                     let b = Vector::<LANES>::splat(-1);\n-                    let _ = a / b;\n+                    assert_eq!(a % b, Vector::<LANES>::splat(0));\n                 }\n \n+            }\n+\n+            test_helpers::test_lanes_panic! {\n                 fn div_by_all_zeros_panics<const LANES: usize>() {\n                     let a = Vector::<LANES>::splat(42);\n                     let b = Vector::<LANES>::splat(0);\n@@ -232,12 +238,6 @@ macro_rules! impl_signed_tests {\n                     let _ = a / b;\n                 }\n \n-                fn rem_min_overflow_panic<const LANES: usize>() {\n-                    let a = Vector::<LANES>::splat(Scalar::MIN);\n-                    let b = Vector::<LANES>::splat(-1);\n-                    let _ = a % b;\n-                }\n-\n                 fn rem_zero_panic<const LANES: usize>() {\n                     let a = Vector::<LANES>::splat(42);\n                     let b = Vector::<LANES>::splat(0);"}, {"sha": "537323292376043cf4794f66d6f982e607c5697d", "filename": "library/portable-simd/crates/core_simd/tests/round.rs", "status": "modified", "additions": 3, "deletions": 11, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/4de99e187c0e389449d96db847d5d9ad68259954/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Ftests%2Fround.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4de99e187c0e389449d96db847d5d9ad68259954/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Ftests%2Fround.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Ftests%2Fround.rs?ref=4de99e187c0e389449d96db847d5d9ad68259954", "patch": "@@ -53,14 +53,6 @@ macro_rules! float_rounding_test {\n             }\n \n             test_helpers::test_lanes! {\n-                fn from_int<const LANES: usize>() {\n-                    test_helpers::test_unary_elementwise(\n-                        &Vector::<LANES>::round_from_int,\n-                        &|x| x as Scalar,\n-                        &|_| true,\n-                    )\n-                }\n-\n                 fn to_int_unchecked<const LANES: usize>() {\n                     // The maximum integer that can be represented by the equivalently sized float has\n                     // all of the mantissa digits set to 1, pushed up to the MSB.\n@@ -72,11 +64,11 @@ macro_rules! float_rounding_test {\n                     runner.run(\n                         &test_helpers::array::UniformArrayStrategy::new(-MAX_REPRESENTABLE_VALUE..MAX_REPRESENTABLE_VALUE),\n                         |x| {\n-                            let result_1 = unsafe { Vector::from_array(x).to_int_unchecked().to_array() };\n+                            let result_1 = unsafe { Vector::from_array(x).to_int_unchecked::<IntScalar>().to_array() };\n                             let result_2 = {\n-                                let mut result = [0; LANES];\n+                                let mut result: [IntScalar; LANES] = [0; LANES];\n                                 for (i, o) in x.iter().zip(result.iter_mut()) {\n-                                    *o = unsafe { i.to_int_unchecked() };\n+                                    *o = unsafe { i.to_int_unchecked::<IntScalar>() };\n                                 }\n                                 result\n                             };"}]}