{"sha": "909bfa31ededd013472080860502608bbe9b2e2a", "node_id": "C_kwDOAAsO6NoAKDkwOWJmYTMxZWRlZGQwMTM0NzIwODA4NjA1MDI2MDhiYmU5YjJlMmE", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2023-06-08T10:36:19Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2023-06-08T10:36:19Z"}, "message": "Rollup merge of #112410 - compiler-errors:writeback, r=lcnr\n\nDo `fix_*_builtin_expr` hacks on the writeback results\n\nDuring writeback, we do `fix_{scalar,index}_builtin_expr` so that during MIR build we generate built-in MIR instructions instead of method calls for certain built-in arithmetic operations. We do this by checking the types of these built-in operations are scalar types, and remove the method def-id to essentially mark the operation as built-in and not \"overloaded\".\n\nFor lazy norm and the new trait solver, this is a problem, because we don't actually normalize all the types we end up seeing in the typeck results until they're copied over writeback's copy of the typeck results. To fix this, delay these fixup calls until after this normalization has been done.\n\nThis doesn't affect the old trait solver, but does simplify the code a bit IMO, since we can remove a few sets of calls to `resolve_vars_if_possible` and some `borrow_mut`s.\n\nr? `@lcnr`", "tree": {"sha": "038ad1d1297e14ba4fd0f898df0de625eb879524", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/038ad1d1297e14ba4fd0f898df0de625eb879524"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/909bfa31ededd013472080860502608bbe9b2e2a", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJkga8jCRBK7hj4Ov3rIwAABwIIAFfXcMGrSJ9UEUv0XtXnohWV\nJ8MEJMUzAvO7eoUN9B8wyfWHRn9eGIo6Ha6p1C8Kdw9O8t7In+57t6bUr3fP11LV\n9u6i/JqBg1FTxilF6yzC9JUAnD2a96Ys+hYvAiG3LkDvw2UAAW4PIrgimlFG8oJj\nd/kx5E2jokPsV0WXSRlAU3c5/vNduxlJBmzNa6jUg4LxVFjQAn5A81Wofl8gip4i\nHkXY6BlO8cpZddn46JuwW0QwcVeq98w7QLdB0rGaOWtkZm6aec33seJgoaqnZk6F\nkxZyzOijGJ3vMv5bWIUx6HLt9fhm6/SNB8uB6Ef9kvCwAbe2P+oRc0cC80p5ABQ=\n=J9vg\n-----END PGP SIGNATURE-----\n", "payload": "tree 038ad1d1297e14ba4fd0f898df0de625eb879524\nparent c71daaac1ff63d26e84331579b5feb70cf66101d\nparent 8efcb28d3c3b804544e9a0a990b8abff6705a2bc\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1686220579 +0200\ncommitter GitHub <noreply@github.com> 1686220579 +0200\n\nRollup merge of #112410 - compiler-errors:writeback, r=lcnr\n\nDo `fix_*_builtin_expr` hacks on the writeback results\n\nDuring writeback, we do `fix_{scalar,index}_builtin_expr` so that during MIR build we generate built-in MIR instructions instead of method calls for certain built-in arithmetic operations. We do this by checking the types of these built-in operations are scalar types, and remove the method def-id to essentially mark the operation as built-in and not \"overloaded\".\n\nFor lazy norm and the new trait solver, this is a problem, because we don't actually normalize all the types we end up seeing in the typeck results until they're copied over writeback's copy of the typeck results. To fix this, delay these fixup calls until after this normalization has been done.\n\nThis doesn't affect the old trait solver, but does simplify the code a bit IMO, since we can remove a few sets of calls to `resolve_vars_if_possible` and some `borrow_mut`s.\n\nr? `@lcnr`\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/909bfa31ededd013472080860502608bbe9b2e2a", "html_url": "https://github.com/rust-lang/rust/commit/909bfa31ededd013472080860502608bbe9b2e2a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/909bfa31ededd013472080860502608bbe9b2e2a/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c71daaac1ff63d26e84331579b5feb70cf66101d", "url": "https://api.github.com/repos/rust-lang/rust/commits/c71daaac1ff63d26e84331579b5feb70cf66101d", "html_url": "https://github.com/rust-lang/rust/commit/c71daaac1ff63d26e84331579b5feb70cf66101d"}, {"sha": "8efcb28d3c3b804544e9a0a990b8abff6705a2bc", "url": "https://api.github.com/repos/rust-lang/rust/commits/8efcb28d3c3b804544e9a0a990b8abff6705a2bc", "html_url": "https://github.com/rust-lang/rust/commit/8efcb28d3c3b804544e9a0a990b8abff6705a2bc"}], "stats": {"total": 94, "additions": 46, "deletions": 48}, "files": [{"sha": "a395858262f04b3970ffc1041db84d6f50f5d31d", "filename": "compiler/rustc_hir_typeck/src/writeback.rs", "status": "modified", "additions": 35, "deletions": 48, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/909bfa31ededd013472080860502608bbe9b2e2a/compiler%2Frustc_hir_typeck%2Fsrc%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/909bfa31ededd013472080860502608bbe9b2e2a/compiler%2Frustc_hir_typeck%2Fsrc%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fwriteback.rs?ref=909bfa31ededd013472080860502608bbe9b2e2a", "patch": "@@ -14,7 +14,6 @@ use rustc_middle::mir::FakeReadCause;\n use rustc_middle::ty::adjustment::{Adjust, Adjustment, PointerCast};\n use rustc_middle::ty::fold::{TypeFoldable, TypeFolder, TypeSuperFoldable};\n use rustc_middle::ty::visit::{TypeSuperVisitable, TypeVisitable, TypeVisitableExt};\n-use rustc_middle::ty::TypeckResults;\n use rustc_middle::ty::{self, ClosureSizeProfileData, Ty, TyCtxt};\n use rustc_span::symbol::sym;\n use rustc_span::Span;\n@@ -148,31 +147,25 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n     fn fix_scalar_builtin_expr(&mut self, e: &hir::Expr<'_>) {\n         match e.kind {\n             hir::ExprKind::Unary(hir::UnOp::Neg | hir::UnOp::Not, inner) => {\n-                let inner_ty = self.fcx.node_ty(inner.hir_id);\n-                let inner_ty = self.fcx.resolve_vars_if_possible(inner_ty);\n+                let inner_ty = self.typeck_results.node_type(inner.hir_id);\n \n                 if inner_ty.is_scalar() {\n-                    let mut typeck_results = self.fcx.typeck_results.borrow_mut();\n-                    typeck_results.type_dependent_defs_mut().remove(e.hir_id);\n-                    typeck_results.node_substs_mut().remove(e.hir_id);\n+                    self.typeck_results.type_dependent_defs_mut().remove(e.hir_id);\n+                    self.typeck_results.node_substs_mut().remove(e.hir_id);\n                 }\n             }\n             hir::ExprKind::Binary(ref op, lhs, rhs) | hir::ExprKind::AssignOp(ref op, lhs, rhs) => {\n-                let lhs_ty = self.fcx.node_ty(lhs.hir_id);\n-                let lhs_ty = self.fcx.resolve_vars_if_possible(lhs_ty);\n-\n-                let rhs_ty = self.fcx.node_ty(rhs.hir_id);\n-                let rhs_ty = self.fcx.resolve_vars_if_possible(rhs_ty);\n+                let lhs_ty = self.typeck_results.node_type(lhs.hir_id);\n+                let rhs_ty = self.typeck_results.node_type(rhs.hir_id);\n \n                 if lhs_ty.is_scalar() && rhs_ty.is_scalar() {\n-                    let mut typeck_results = self.fcx.typeck_results.borrow_mut();\n-                    typeck_results.type_dependent_defs_mut().remove(e.hir_id);\n-                    typeck_results.node_substs_mut().remove(e.hir_id);\n+                    self.typeck_results.type_dependent_defs_mut().remove(e.hir_id);\n+                    self.typeck_results.node_substs_mut().remove(e.hir_id);\n \n                     match e.kind {\n                         hir::ExprKind::Binary(..) => {\n                             if !op.node.is_by_value() {\n-                                let mut adjustments = typeck_results.adjustments_mut();\n+                                let mut adjustments = self.typeck_results.adjustments_mut();\n                                 if let Some(a) = adjustments.get_mut(lhs.hir_id) {\n                                     a.pop();\n                                 }\n@@ -182,7 +175,7 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n                             }\n                         }\n                         hir::ExprKind::AssignOp(..)\n-                            if let Some(a) = typeck_results.adjustments_mut().get_mut(lhs.hir_id) =>\n+                            if let Some(a) = self.typeck_results.adjustments_mut().get_mut(lhs.hir_id) =>\n                         {\n                             a.pop();\n                         }\n@@ -200,16 +193,14 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n     // if they are not we don't modify the expr, hence we bypass the ICE\n     fn is_builtin_index(\n         &mut self,\n-        typeck_results: &TypeckResults<'tcx>,\n         e: &hir::Expr<'_>,\n         base_ty: Ty<'tcx>,\n         index_ty: Ty<'tcx>,\n     ) -> bool {\n-        if let Some(elem_ty) = base_ty.builtin_index() {\n-            let Some(exp_ty) = typeck_results.expr_ty_opt(e) else {return false;};\n-            let resolved_exp_ty = self.resolve(exp_ty, &e.span);\n-\n-            elem_ty == resolved_exp_ty && index_ty == self.fcx.tcx.types.usize\n+        if let Some(elem_ty) = base_ty.builtin_index()\n+            && let Some(exp_ty) = self.typeck_results.expr_ty_opt(e)\n+        {\n+            elem_ty == exp_ty && index_ty == self.fcx.tcx.types.usize\n         } else {\n             false\n         }\n@@ -221,38 +212,34 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n     // usize-ish\n     fn fix_index_builtin_expr(&mut self, e: &hir::Expr<'_>) {\n         if let hir::ExprKind::Index(ref base, ref index) = e.kind {\n-            let mut typeck_results = self.fcx.typeck_results.borrow_mut();\n-\n             // All valid indexing looks like this; might encounter non-valid indexes at this point.\n-            let base_ty = typeck_results\n-                .expr_ty_adjusted_opt(base)\n-                .map(|t| self.fcx.resolve_vars_if_possible(t).kind());\n+            let base_ty = self.typeck_results.expr_ty_adjusted_opt(base);\n             if base_ty.is_none() {\n                 // When encountering `return [0][0]` outside of a `fn` body we can encounter a base\n                 // that isn't in the type table. We assume more relevant errors have already been\n                 // emitted, so we delay an ICE if none have. (#64638)\n                 self.tcx().sess.delay_span_bug(e.span, format!(\"bad base: `{:?}`\", base));\n             }\n-            if let Some(ty::Ref(_, base_ty, _)) = base_ty {\n-                let index_ty = typeck_results.expr_ty_adjusted_opt(index).unwrap_or_else(|| {\n-                    // When encountering `return [0][0]` outside of a `fn` body we would attempt\n-                    // to access an nonexistent index. We assume that more relevant errors will\n-                    // already have been emitted, so we only gate on this with an ICE if no\n-                    // error has been emitted. (#64638)\n-                    self.fcx.tcx.ty_error_with_message(\n-                        e.span,\n-                        format!(\"bad index {:?} for base: `{:?}`\", index, base),\n-                    )\n-                });\n-                let index_ty = self.fcx.resolve_vars_if_possible(index_ty);\n-                let resolved_base_ty = self.resolve(*base_ty, &base.span);\n-\n-                if self.is_builtin_index(&typeck_results, e, resolved_base_ty, index_ty) {\n+            if let Some(base_ty) = base_ty\n+                && let ty::Ref(_, base_ty_inner, _) = *base_ty.kind()\n+            {\n+                let index_ty =\n+                    self.typeck_results.expr_ty_adjusted_opt(index).unwrap_or_else(|| {\n+                        // When encountering `return [0][0]` outside of a `fn` body we would attempt\n+                        // to access an nonexistent index. We assume that more relevant errors will\n+                        // already have been emitted, so we only gate on this with an ICE if no\n+                        // error has been emitted. (#64638)\n+                        self.fcx.tcx.ty_error_with_message(\n+                            e.span,\n+                            format!(\"bad index {:?} for base: `{:?}`\", index, base),\n+                        )\n+                    });\n+                if self.is_builtin_index(e, base_ty_inner, index_ty) {\n                     // Remove the method call record\n-                    typeck_results.type_dependent_defs_mut().remove(e.hir_id);\n-                    typeck_results.node_substs_mut().remove(e.hir_id);\n+                    self.typeck_results.type_dependent_defs_mut().remove(e.hir_id);\n+                    self.typeck_results.node_substs_mut().remove(e.hir_id);\n \n-                    if let Some(a) = typeck_results.adjustments_mut().get_mut(base.hir_id) {\n+                    if let Some(a) = self.typeck_results.adjustments_mut().get_mut(base.hir_id) {\n                         // Discard the need for a mutable borrow\n \n                         // Extra adjustment made when indexing causes a drop\n@@ -283,9 +270,6 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n \n impl<'cx, 'tcx> Visitor<'tcx> for WritebackCx<'cx, 'tcx> {\n     fn visit_expr(&mut self, e: &'tcx hir::Expr<'tcx>) {\n-        self.fix_scalar_builtin_expr(e);\n-        self.fix_index_builtin_expr(e);\n-\n         match e.kind {\n             hir::ExprKind::Closure(&hir::Closure { body, .. }) => {\n                 let body = self.fcx.tcx.hir().body(body);\n@@ -314,6 +298,9 @@ impl<'cx, 'tcx> Visitor<'tcx> for WritebackCx<'cx, 'tcx> {\n \n         self.visit_node_id(e.span, e.hir_id);\n         intravisit::walk_expr(self, e);\n+\n+        self.fix_scalar_builtin_expr(e);\n+        self.fix_index_builtin_expr(e);\n     }\n \n     fn visit_generic_param(&mut self, p: &'tcx hir::GenericParam<'tcx>) {"}, {"sha": "2443e517813917f2ca42b0cbe0e360876b553fa7", "filename": "tests/ui/traits/new-solver/normalized-const-built-in-op.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/909bfa31ededd013472080860502608bbe9b2e2a/tests%2Fui%2Ftraits%2Fnew-solver%2Fnormalized-const-built-in-op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/909bfa31ededd013472080860502608bbe9b2e2a/tests%2Fui%2Ftraits%2Fnew-solver%2Fnormalized-const-built-in-op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fnew-solver%2Fnormalized-const-built-in-op.rs?ref=909bfa31ededd013472080860502608bbe9b2e2a", "patch": "@@ -0,0 +1,11 @@\n+// compile-flags: -Ztrait-solver=next\n+// check-pass\n+\n+const fn foo() {\n+    let mut x = [1, 2, 3];\n+    // We need to fix up `<<[i32; 3] as Index<usize>>::Output as AddAssign>`\n+    // to be treated like a built-in operation.\n+    x[1] += 5;\n+}\n+\n+fn main() {}"}]}