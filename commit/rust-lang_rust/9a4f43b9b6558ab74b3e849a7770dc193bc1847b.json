{"sha": "9a4f43b9b6558ab74b3e849a7770dc193bc1847b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlhNGY0M2I5YjY1NThhYjc0YjNlODQ5YTc3NzBkYzE5M2JjMTg0N2I=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2016-01-15T18:07:52Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2016-01-16T19:03:10Z"}, "message": "std: Stabilize APIs for the 1.7 release\n\nThis commit stabilizes and deprecates the FCP (final comment period) APIs for\nthe upcoming 1.7 beta release. The specific APIs which changed were:\n\nStabilized\n\n* `Path::strip_prefix` (renamed from `relative_from`)\n* `path::StripPrefixError` (new error type returned from `strip_prefix`)\n* `Ipv4Addr::is_loopback`\n* `Ipv4Addr::is_private`\n* `Ipv4Addr::is_link_local`\n* `Ipv4Addr::is_multicast`\n* `Ipv4Addr::is_broadcast`\n* `Ipv4Addr::is_documentation`\n* `Ipv6Addr::is_unspecified`\n* `Ipv6Addr::is_loopback`\n* `Ipv6Addr::is_unique_local`\n* `Ipv6Addr::is_multicast`\n* `Vec::as_slice`\n* `Vec::as_mut_slice`\n* `String::as_str`\n* `String::as_mut_str`\n* `<[T]>::clone_from_slice` - the `usize` return value is removed\n* `<[T]>::sort_by_key`\n* `i32::checked_rem` (and other signed types)\n* `i32::checked_neg` (and other signed types)\n* `i32::checked_shl` (and other signed types)\n* `i32::checked_shr` (and other signed types)\n* `i32::saturating_mul` (and other signed types)\n* `i32::overflowing_add` (and other signed types)\n* `i32::overflowing_sub` (and other signed types)\n* `i32::overflowing_mul` (and other signed types)\n* `i32::overflowing_div` (and other signed types)\n* `i32::overflowing_rem` (and other signed types)\n* `i32::overflowing_neg` (and other signed types)\n* `i32::overflowing_shl` (and other signed types)\n* `i32::overflowing_shr` (and other signed types)\n* `u32::checked_rem` (and other unsigned types)\n* `u32::checked_neg` (and other unsigned types)\n* `u32::checked_shl` (and other unsigned types)\n* `u32::saturating_mul` (and other unsigned types)\n* `u32::overflowing_add` (and other unsigned types)\n* `u32::overflowing_sub` (and other unsigned types)\n* `u32::overflowing_mul` (and other unsigned types)\n* `u32::overflowing_div` (and other unsigned types)\n* `u32::overflowing_rem` (and other unsigned types)\n* `u32::overflowing_neg` (and other unsigned types)\n* `u32::overflowing_shl` (and other unsigned types)\n* `u32::overflowing_shr` (and other unsigned types)\n* `ffi::IntoStringError`\n* `CString::into_string`\n* `CString::into_bytes`\n* `CString::into_bytes_with_nul`\n* `From<CString> for Vec<u8>`\n* `From<CString> for Vec<u8>`\n* `IntoStringError::into_cstring`\n* `IntoStringError::utf8_error`\n* `Error for IntoStringError`\n\nDeprecated\n\n* `Path::relative_from` - renamed to `strip_prefix`\n* `Path::prefix` - use `components().next()` instead\n* `os::unix::fs` constants - moved to the `libc` crate\n* `fmt::{radix, Radix, RadixFmt}` - not used enough to stabilize\n* `IntoCow` - conflicts with `Into` and may come back later\n* `i32::{BITS, BYTES}` (and other integers) - not pulling their weight\n* `DebugTuple::formatter` - will be removed\n* `sync::Semaphore` - not used enough and confused with system semaphores\n\nCloses #23284\ncc #27709 (still lots more methods though)\nCloses #27712\nCloses #27722\nCloses #27728\nCloses #27735\nCloses #27729\nCloses #27755\nCloses #27782\nCloses #27798", "tree": {"sha": "2bd3ab2adb8e8312ad3384b108f2ae8e1b589055", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2bd3ab2adb8e8312ad3384b108f2ae8e1b589055"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9a4f43b9b6558ab74b3e849a7770dc193bc1847b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9a4f43b9b6558ab74b3e849a7770dc193bc1847b", "html_url": "https://github.com/rust-lang/rust/commit/9a4f43b9b6558ab74b3e849a7770dc193bc1847b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9a4f43b9b6558ab74b3e849a7770dc193bc1847b/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c14b615534ebcd5667f594c86d18eebff6afc7cb", "url": "https://api.github.com/repos/rust-lang/rust/commits/c14b615534ebcd5667f594c86d18eebff6afc7cb", "html_url": "https://github.com/rust-lang/rust/commit/c14b615534ebcd5667f594c86d18eebff6afc7cb"}], "stats": {"total": 591, "additions": 356, "deletions": 235}, "files": [{"sha": "0a232ed0620d4a25106e5679b7c20e2462ab55a8", "filename": "src/liballoc/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9a4f43b9b6558ab74b3e849a7770dc193bc1847b/src%2Fliballoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a4f43b9b6558ab74b3e849a7770dc193bc1847b/src%2Fliballoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flib.rs?ref=9a4f43b9b6558ab74b3e849a7770dc193bc1847b", "patch": "@@ -78,7 +78,6 @@\n #![feature(custom_attribute)]\n #![feature(fundamental)]\n #![feature(lang_items)]\n-#![feature(num_bits_bytes)]\n #![feature(optin_builtin_traits)]\n #![feature(placement_in_syntax)]\n #![feature(placement_new_protocol)]"}, {"sha": "c407cef25e74c30be2217e6f8e612273257f537d", "filename": "src/liballoc/raw_vec.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9a4f43b9b6558ab74b3e849a7770dc193bc1847b/src%2Fliballoc%2Fraw_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a4f43b9b6558ab74b3e849a7770dc193bc1847b/src%2Fliballoc%2Fraw_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fraw_vec.rs?ref=9a4f43b9b6558ab74b3e849a7770dc193bc1847b", "patch": "@@ -16,7 +16,6 @@ use super::oom;\n use super::boxed::Box;\n use core::ops::Drop;\n use core::cmp;\n-use core;\n \n /// A low-level utility for more ergonomically allocating, reallocating, and deallocating a\n /// a buffer of memory on the heap without having to worry about all the corner cases\n@@ -584,7 +583,7 @@ impl<T> Drop for RawVec<T> {\n \n #[inline]\n fn alloc_guard(alloc_size: usize) {\n-    if core::usize::BITS < 64 {\n+    if mem::size_of::<usize>() < 8 {\n         assert!(alloc_size <= ::core::isize::MAX as usize,\n                 \"capacity overflow\");\n     }"}, {"sha": "f174cc09bcd3525a324bf64635912b9fd7742c91", "filename": "src/libcollections/borrow.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9a4f43b9b6558ab74b3e849a7770dc193bc1847b/src%2Flibcollections%2Fborrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a4f43b9b6558ab74b3e849a7770dc193bc1847b/src%2Flibcollections%2Fborrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fborrow.rs?ref=9a4f43b9b6558ab74b3e849a7770dc193bc1847b", "patch": "@@ -247,19 +247,23 @@ impl<'a, B: ?Sized> Hash for Cow<'a, B> where B: Hash + ToOwned {\n /// Trait for moving into a `Cow`.\n #[unstable(feature = \"into_cow\", reason = \"may be replaced by `convert::Into`\",\n            issue = \"27735\")]\n+#[rustc_deprecated(since = \"1.7.0\",\n+                   reason = \"conflicts with Into, may return with specialization\")]\n pub trait IntoCow<'a, B: ?Sized> where B: ToOwned {\n     /// Moves `self` into `Cow`\n     fn into_cow(self) -> Cow<'a, B>;\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[allow(deprecated)]\n impl<'a, B: ?Sized> IntoCow<'a, B> for Cow<'a, B> where B: ToOwned {\n     fn into_cow(self) -> Cow<'a, B> {\n         self\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[allow(deprecated)]\n impl<'a, T: ?Sized + ToOwned> AsRef<T> for Cow<'a, T> {\n     fn as_ref(&self) -> &T {\n         self"}, {"sha": "8b8ccd526c90f854c7fd0c8b360eda4ebeb7bf14", "filename": "src/libcollections/enum_set.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9a4f43b9b6558ab74b3e849a7770dc193bc1847b/src%2Flibcollections%2Fenum_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a4f43b9b6558ab74b3e849a7770dc193bc1847b/src%2Flibcollections%2Fenum_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fenum_set.rs?ref=9a4f43b9b6558ab74b3e849a7770dc193bc1847b", "patch": "@@ -81,6 +81,7 @@ pub trait CLike {\n     fn from_usize(usize) -> Self;\n }\n \n+#[allow(deprecated)]\n fn bit<E: CLike>(e: &E) -> usize {\n     use core::usize;\n     let value = e.to_usize();"}, {"sha": "d46a3e7e89e88565c12d2d13b79e795be432a61d", "filename": "src/libcollections/fmt.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9a4f43b9b6558ab74b3e849a7770dc193bc1847b/src%2Flibcollections%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a4f43b9b6558ab74b3e849a7770dc193bc1847b/src%2Flibcollections%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Ffmt.rs?ref=9a4f43b9b6558ab74b3e849a7770dc193bc1847b", "patch": "@@ -490,7 +490,11 @@ pub use core::fmt::{LowerExp, UpperExp};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use core::fmt::Error;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use core::fmt::{ArgumentV1, Arguments, write, radix, Radix, RadixFmt};\n+pub use core::fmt::{ArgumentV1, Arguments, write};\n+#[unstable(feature = \"fmt_radix\", issue = \"27728\")]\n+#[rustc_deprecated(since = \"1.7.0\", reason = \"not used enough to stabilize\")]\n+#[allow(deprecated)]\n+pub use core::fmt::{radix, Radix, RadixFmt};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use core::fmt::{DebugList, DebugMap, DebugSet, DebugStruct, DebugTuple};\n "}, {"sha": "0b13717e8a0cb96fb3bbec9e96a5ee6a36749f57", "filename": "src/libcollections/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9a4f43b9b6558ab74b3e849a7770dc193bc1847b/src%2Flibcollections%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a4f43b9b6558ab74b3e849a7770dc193bc1847b/src%2Flibcollections%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flib.rs?ref=9a4f43b9b6558ab74b3e849a7770dc193bc1847b", "patch": "@@ -32,7 +32,6 @@\n #![feature(alloc)]\n #![feature(box_patterns)]\n #![feature(box_syntax)]\n-#![feature(clone_from_slice)]\n #![feature(core_intrinsics)]\n #![feature(decode_utf16)]\n #![feature(drop_in_place)]"}, {"sha": "8b4497e6f037e2ee3216073e1f952f73c3696e4c", "filename": "src/libcollections/slice.rs", "status": "modified", "additions": 13, "deletions": 20, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/9a4f43b9b6558ab74b3e849a7770dc193bc1847b/src%2Flibcollections%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a4f43b9b6558ab74b3e849a7770dc193bc1847b/src%2Flibcollections%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fslice.rs?ref=9a4f43b9b6558ab74b3e849a7770dc193bc1847b", "patch": "@@ -788,15 +788,12 @@ impl<T> [T] {\n     /// # Examples\n     ///\n     /// ```rust\n-    /// #![feature(slice_sort_by_key)]\n-    ///\n     /// let mut v = [-5i32, 4, 1, -3, 2];\n     ///\n     /// v.sort_by_key(|k| k.abs());\n     /// assert!(v == [1, 2, -3, 4, -5]);\n     /// ```\n-    #[unstable(feature = \"slice_sort_by_key\", reason = \"recently added\",\n-               issue = \"27724\")]\n+    #[stable(feature = \"slice_sort_by_key\", since = \"1.7.0\")]\n     #[inline]\n     pub fn sort_by_key<B, F>(&mut self, mut f: F)\n         where F: FnMut(&T) -> B, B: Ord\n@@ -829,29 +826,25 @@ impl<T> [T] {\n         merge_sort(self, compare)\n     }\n \n-    /// Copies as many elements from `src` as it can into `self` (the\n-    /// shorter of `self.len()` and `src.len()`). Returns the number\n-    /// of elements copied.\n+    /// Copies the elements from `src` into `self`.\n+    ///\n+    /// The length of this slice must be the same as the slice passed in.\n+    ///\n+    /// # Panics\n+    ///\n+    /// This function will panic if the two slices have different lengths.\n     ///\n     /// # Example\n     ///\n     /// ```rust\n-    /// #![feature(clone_from_slice)]\n-    ///\n     /// let mut dst = [0, 0, 0];\n-    /// let src = [1, 2];\n-    ///\n-    /// assert!(dst.clone_from_slice(&src) == 2);\n-    /// assert!(dst == [1, 2, 0]);\n+    /// let src = [1, 2, 3];\n     ///\n-    /// let src2 = [3, 4, 5, 6];\n-    /// assert!(dst.clone_from_slice(&src2) == 3);\n-    /// assert!(dst == [3, 4, 5]);\n+    /// dst.clone_from_slice(&src);\n+    /// assert!(dst == [1, 2, 3]);\n     /// ```\n-    #[unstable(feature = \"clone_from_slice\", issue = \"27750\")]\n-    pub fn clone_from_slice(&mut self, src: &[T]) -> usize\n-        where T: Clone\n-    {\n+    #[stable(feature = \"clone_from_slice\", since = \"1.7.0\")]\n+    pub fn clone_from_slice(&mut self, src: &[T]) where T: Clone {\n         core_slice::SliceExt::clone_from_slice(self, src)\n     }\n "}, {"sha": "ad9c770a5a5cafa037fbbe2e29a6a214b9bc342b", "filename": "src/libcollections/string.rs", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9a4f43b9b6558ab74b3e849a7770dc193bc1847b/src%2Flibcollections%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a4f43b9b6558ab74b3e849a7770dc193bc1847b/src%2Flibcollections%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstring.rs?ref=9a4f43b9b6558ab74b3e849a7770dc193bc1847b", "patch": "@@ -66,6 +66,7 @@ use core::str::pattern::Pattern;\n use rustc_unicode::char::{decode_utf16, REPLACEMENT_CHARACTER};\n use rustc_unicode::str as unicode_str;\n \n+#[allow(deprecated)]\n use borrow::{Cow, IntoCow};\n use range::RangeArgument;\n use str::{self, FromStr, Utf8Error, Chars};\n@@ -783,13 +784,18 @@ impl String {\n \n     /// Extracts a string slice containing the entire string.\n     #[inline]\n-    #[unstable(feature = \"convert\",\n-               reason = \"waiting on RFC revision\",\n-               issue = \"27729\")]\n+    #[stable(feature = \"string_as_str\", since = \"1.7.0\")]\n     pub fn as_str(&self) -> &str {\n         self\n     }\n \n+    /// Extracts a string slice containing the entire string.\n+    #[inline]\n+    #[stable(feature = \"string_as_str\", since = \"1.7.0\")]\n+    pub fn as_mut_str(&mut self) -> &mut str {\n+        self\n+    }\n+\n     /// Appends a given string slice onto the end of this `String`.\n     ///\n     /// # Examples\n@@ -1794,6 +1800,7 @@ impl Into<Vec<u8>> for String {\n \n #[unstable(feature = \"into_cow\", reason = \"may be replaced by `convert::Into`\",\n            issue= \"27735\")]\n+#[allow(deprecated)]\n impl IntoCow<'static, str> for String {\n     #[inline]\n     fn into_cow(self) -> Cow<'static, str> {\n@@ -1803,6 +1810,7 @@ impl IntoCow<'static, str> for String {\n \n #[unstable(feature = \"into_cow\", reason = \"may be replaced by `convert::Into`\",\n            issue = \"27735\")]\n+#[allow(deprecated)]\n impl<'a> IntoCow<'a, str> for &'a str {\n     #[inline]\n     fn into_cow(self) -> Cow<'a, str> {"}, {"sha": "a49b7304643ccaa2e9c5fba8301242dc9371bdad", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/9a4f43b9b6558ab74b3e849a7770dc193bc1847b/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a4f43b9b6558ab74b3e849a7770dc193bc1847b/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=9a4f43b9b6558ab74b3e849a7770dc193bc1847b", "patch": "@@ -73,6 +73,7 @@ use core::ops;\n use core::ptr;\n use core::slice;\n \n+#[allow(deprecated)]\n use borrow::{Cow, IntoCow};\n \n use super::range::RangeArgument;\n@@ -464,9 +465,7 @@ impl<T> Vec<T> {\n     ///\n     /// Equivalent to `&s[..]`.\n     #[inline]\n-    #[unstable(feature = \"convert\",\n-               reason = \"waiting on RFC revision\",\n-               issue = \"27729\")]\n+    #[stable(feature = \"vec_as_slice\", since = \"1.7.0\")]\n     pub fn as_slice(&self) -> &[T] {\n         self\n     }\n@@ -475,9 +474,7 @@ impl<T> Vec<T> {\n     ///\n     /// Equivalent to `&mut s[..]`.\n     #[inline]\n-    #[unstable(feature = \"convert\",\n-               reason = \"waiting on RFC revision\",\n-               issue = \"27729\")]\n+    #[stable(feature = \"vec_as_slice\", since = \"1.7.0\")]\n     pub fn as_mut_slice(&mut self) -> &mut [T] {\n         &mut self[..]\n     }\n@@ -1516,13 +1513,15 @@ impl<'a, T> FromIterator<T> for Cow<'a, [T]> where T: Clone {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[allow(deprecated)]\n impl<'a, T: 'a> IntoCow<'a, [T]> for Vec<T> where T: Clone {\n     fn into_cow(self) -> Cow<'a, [T]> {\n         Cow::Owned(self)\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[allow(deprecated)]\n impl<'a, T> IntoCow<'a, [T]> for &'a [T] where T: Clone {\n     fn into_cow(self) -> Cow<'a, [T]> {\n         Cow::Borrowed(self)"}, {"sha": "ba78acc28bccbd88f5c6293f4deca8810466ba47", "filename": "src/libcollections/vec_deque.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9a4f43b9b6558ab74b3e849a7770dc193bc1847b/src%2Flibcollections%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a4f43b9b6558ab74b3e849a7770dc193bc1847b/src%2Flibcollections%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec_deque.rs?ref=9a4f43b9b6558ab74b3e849a7770dc193bc1847b", "patch": "@@ -25,7 +25,6 @@ use core::mem;\n use core::ops::{Index, IndexMut};\n use core::ptr;\n use core::slice;\n-use core::usize;\n \n use core::hash::{Hash, Hasher};\n use core::cmp;\n@@ -36,7 +35,10 @@ use super::range::RangeArgument;\n \n const INITIAL_CAPACITY: usize = 7; // 2^3 - 1\n const MINIMUM_CAPACITY: usize = 1; // 2 - 1\n-const MAXIMUM_ZST_CAPACITY: usize = 1 << (usize::BITS - 1); // Largest possible power of two\n+#[cfg(target_pointer_width = \"32\")]\n+const MAXIMUM_ZST_CAPACITY: usize = 1 << (32 - 1); // Largest possible power of two\n+#[cfg(target_pointer_width = \"64\")]\n+const MAXIMUM_ZST_CAPACITY: usize = 1 << (64 - 1); // Largest possible power of two\n \n /// `VecDeque` is a growable ring buffer, which can be used as a double-ended\n /// queue efficiently."}, {"sha": "7c986131a52858dd357c48b0f6ec02208635878e", "filename": "src/libcore/fmt/builders.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9a4f43b9b6558ab74b3e849a7770dc193bc1847b/src%2Flibcore%2Ffmt%2Fbuilders.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a4f43b9b6558ab74b3e849a7770dc193bc1847b/src%2Flibcore%2Ffmt%2Fbuilders.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fbuilders.rs?ref=9a4f43b9b6558ab74b3e849a7770dc193bc1847b", "patch": "@@ -181,6 +181,7 @@ impl<'a, 'b: 'a> DebugTuple<'a, 'b> {\n     /// Returns the wrapped `Formatter`.\n     #[unstable(feature = \"debug_builder_formatter\", reason = \"recently added\",\n                issue = \"27782\")]\n+    #[rustc_deprecated(since = \"1.7.0\", reason = \"will be removed\")]\n     pub fn formatter(&mut self) -> &mut fmt::Formatter<'b> {\n         &mut self.fmt\n     }"}, {"sha": "37f03d731dc72e0259050cbbd2aef75e8697be35", "filename": "src/libcore/fmt/mod.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9a4f43b9b6558ab74b3e849a7770dc193bc1847b/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a4f43b9b6558ab74b3e849a7770dc193bc1847b/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=9a4f43b9b6558ab74b3e849a7770dc193bc1847b", "patch": "@@ -25,10 +25,16 @@ use str;\n use self::rt::v1::Alignment;\n \n #[unstable(feature = \"fmt_radix\", issue = \"27728\")]\n+#[rustc_deprecated(since = \"1.7.0\", reason = \"not used enough to stabilize\")]\n+#[allow(deprecated)]\n pub use self::num::radix;\n #[unstable(feature = \"fmt_radix\", issue = \"27728\")]\n+#[rustc_deprecated(since = \"1.7.0\", reason = \"not used enough to stabilize\")]\n+#[allow(deprecated)]\n pub use self::num::Radix;\n #[unstable(feature = \"fmt_radix\", issue = \"27728\")]\n+#[rustc_deprecated(since = \"1.7.0\", reason = \"not used enough to stabilize\")]\n+#[allow(deprecated)]\n pub use self::num::RadixFmt;\n #[stable(feature = \"debug_builders\", since = \"1.2.0\")]\n pub use self::builders::{DebugStruct, DebugTuple, DebugSet, DebugList, DebugMap};\n@@ -1391,7 +1397,7 @@ impl<T> Pointer for *const T {\n             f.flags |= 1 << (FlagV1::SignAwareZeroPad as u32);\n \n             if let None = f.width {\n-                f.width = Some((::usize::BITS/4) + 2);\n+                f.width = Some(((mem::size_of::<usize>() * 8) / 4) + 2);\n             }\n         }\n         f.flags |= 1 << (FlagV1::Alternate as u32);\n@@ -1532,7 +1538,7 @@ macro_rules! tuple {\n     ( $($name:ident,)+ ) => (\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         impl<$($name:Debug),*> Debug for ($($name,)*) {\n-            #[allow(non_snake_case, unused_assignments)]\n+            #[allow(non_snake_case, unused_assignments, deprecated)]\n             fn fmt(&self, f: &mut Formatter) -> Result {\n                 let mut builder = f.debug_tuple(\"\");\n                 let ($(ref $name,)*) = *self;"}, {"sha": "263e03dcc78393a87b428d59a0d029cfd32e40b1", "filename": "src/libcore/fmt/num.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9a4f43b9b6558ab74b3e849a7770dc193bc1847b/src%2Flibcore%2Ffmt%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a4f43b9b6558ab74b3e849a7770dc193bc1847b/src%2Flibcore%2Ffmt%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fnum.rs?ref=9a4f43b9b6558ab74b3e849a7770dc193bc1847b", "patch": "@@ -10,6 +10,8 @@\n \n //! Integer and floating-point number formatting\n \n+#![allow(deprecated)]\n+\n // FIXME: #6220 Implement floating point formatting\n \n use prelude::v1::*;\n@@ -143,6 +145,7 @@ radix! { UpperHex, 16, \"0x\", x @  0 ...  9 => b'0' + x,\n #[unstable(feature = \"fmt_radix\",\n            reason = \"may be renamed or move to a different module\",\n            issue = \"27728\")]\n+#[rustc_deprecated(since = \"1.7.0\", reason = \"not used enough to stabilize\")]\n pub struct Radix {\n     base: u8,\n }\n@@ -173,6 +176,7 @@ impl GenericRadix for Radix {\n #[unstable(feature = \"fmt_radix\",\n            reason = \"may be renamed or move to a different module\",\n            issue = \"27728\")]\n+#[rustc_deprecated(since = \"1.7.0\", reason = \"not used enough to stabilize\")]\n #[derive(Copy, Clone)]\n pub struct RadixFmt<T, R>(T, R);\n \n@@ -189,6 +193,7 @@ pub struct RadixFmt<T, R>(T, R);\n #[unstable(feature = \"fmt_radix\",\n            reason = \"may be renamed or move to a different module\",\n            issue = \"27728\")]\n+#[rustc_deprecated(since = \"1.7.0\", reason = \"not used enough to stabilize\")]\n pub fn radix<T>(x: T, base: u8) -> RadixFmt<T, Radix> {\n     RadixFmt(x, Radix::new(base))\n }"}, {"sha": "0781dd3b7742f9d54611f78aae1705a83e65e8da", "filename": "src/libcore/hash/mod.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9a4f43b9b6558ab74b3e849a7770dc193bc1847b/src%2Flibcore%2Fhash%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a4f43b9b6558ab74b3e849a7770dc193bc1847b/src%2Flibcore%2Fhash%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhash%2Fmod.rs?ref=9a4f43b9b6558ab74b3e849a7770dc193bc1847b", "patch": "@@ -195,6 +195,7 @@ pub trait Hasher {\n mod impls {\n     use prelude::v1::*;\n \n+    use mem;\n     use slice;\n     use super::*;\n \n@@ -207,9 +208,7 @@ mod impls {\n                 }\n \n                 fn hash_slice<H: Hasher>(data: &[$ty], state: &mut H) {\n-                    // FIXME(#23542) Replace with type ascription.\n-                    #![allow(trivial_casts)]\n-                    let newlen = data.len() * ::$ty::BYTES;\n+                    let newlen = data.len() * mem::size_of::<$ty>();\n                     let ptr = data.as_ptr() as *const u8;\n                     state.write(unsafe { slice::from_raw_parts(ptr, newlen) })\n                 }"}, {"sha": "9f7672a52a1832d6d572b69be20c7410dbb1e86a", "filename": "src/libcore/num/flt2dec/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9a4f43b9b6558ab74b3e849a7770dc193bc1847b/src%2Flibcore%2Fnum%2Fflt2dec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a4f43b9b6558ab74b3e849a7770dc193bc1847b/src%2Flibcore%2Fnum%2Fflt2dec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fflt2dec%2Fmod.rs?ref=9a4f43b9b6558ab74b3e849a7770dc193bc1847b", "patch": "@@ -210,7 +210,7 @@ impl<'a> Part<'a> {\n                     }\n                 }\n                 Part::Copy(buf) => {\n-                    out.clone_from_slice(buf);\n+                    out[..buf.len()].clone_from_slice(buf);\n                 }\n             }\n             Some(len)\n@@ -245,7 +245,7 @@ impl<'a> Formatted<'a> {\n     /// (It may still leave partially written bytes in the buffer; do not rely on that.)\n     pub fn write(&self, out: &mut [u8]) -> Option<usize> {\n         if out.len() < self.sign.len() { return None; }\n-        out.clone_from_slice(self.sign);\n+        out[..self.sign.len()].clone_from_slice(self.sign);\n \n         let mut written = self.sign.len();\n         for part in self.parts {"}, {"sha": "77f662723c86dab6f3ca7868a12960aa09efbca3", "filename": "src/libcore/num/int_macros.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9a4f43b9b6558ab74b3e849a7770dc193bc1847b/src%2Flibcore%2Fnum%2Fint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a4f43b9b6558ab74b3e849a7770dc193bc1847b/src%2Flibcore%2Fnum%2Fint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fint_macros.rs?ref=9a4f43b9b6558ab74b3e849a7770dc193bc1847b", "patch": "@@ -17,21 +17,25 @@ macro_rules! int_module { ($T:ty, $bits:expr) => (\n #[unstable(feature = \"num_bits_bytes\",\n            reason = \"may want to be an associated function\",\n            issue = \"27753\")]\n+#[rustc_deprecated(since = \"1.7.0\",\n+                   reason = \"will be replaced via const fn or associated constants\")]\n #[allow(missing_docs)]\n pub const BITS : usize = $bits;\n // FIXME(#11621): Should be deprecated once CTFE is implemented in favour of\n // calling the `mem::size_of` function.\n #[unstable(feature = \"num_bits_bytes\",\n            reason = \"may want to be an associated function\",\n            issue = \"27753\")]\n+#[rustc_deprecated(since = \"1.7.0\",\n+                   reason = \"will be replaced via const fn or associated constants\")]\n #[allow(missing_docs)]\n pub const BYTES : usize = ($bits / 8);\n \n // FIXME(#11621): Should be deprecated once CTFE is implemented in favour of\n // calling the `Bounded::min_value` function.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[allow(missing_docs)]\n-pub const MIN: $T = (-1 as $T) << (BITS - 1);\n+pub const MIN: $T = (-1 as $T) << ($bits - 1);\n // FIXME(#9837): Compute MIN like this so the high bits that shouldn't exist are 0.\n // FIXME(#11621): Should be deprecated once CTFE is implemented in favour of\n // calling the `Bounded::max_value` function."}, {"sha": "e3e8bcab4f1d71d75697f78662e09f5de07f897f", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 45, "deletions": 77, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/9a4f43b9b6558ab74b3e849a7770dc193bc1847b/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a4f43b9b6558ab74b3e849a7770dc193bc1847b/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=9a4f43b9b6558ab74b3e849a7770dc193bc1847b", "patch": "@@ -13,8 +13,6 @@\n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n #![allow(missing_docs)]\n \n-use self::wrapping::OverflowingOps;\n-\n use char::CharExt;\n use cmp::{Eq, PartialOrd};\n use convert::From;\n@@ -464,15 +462,13 @@ macro_rules! int_impl {\n         /// Basic usage:\n         ///\n         /// ```\n-        /// #![feature(wrapping)]\n-        ///\n         /// use std::i32;\n         ///\n         /// assert_eq!(5i32.checked_rem(2), Some(1));\n         /// assert_eq!(5i32.checked_rem(0), None);\n         /// assert_eq!(i32::MIN.checked_rem(-1), None);\n         /// ```\n-        #[unstable(feature = \"wrapping\", issue = \"27755\")]\n+        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n         #[inline]\n         pub fn checked_rem(self, other: Self) -> Option<Self> {\n             if other == 0 {\n@@ -491,14 +487,12 @@ macro_rules! int_impl {\n         /// Basic usage:\n         ///\n         /// ```\n-        /// #![feature(wrapping)]\n-        ///\n         /// use std::i32;\n         ///\n         /// assert_eq!(5i32.checked_neg(), Some(-5));\n         /// assert_eq!(i32::MIN.checked_neg(), None);\n         /// ```\n-        #[unstable(feature = \"wrapping\", issue = \"27755\")]\n+        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n         #[inline]\n         pub fn checked_neg(self) -> Option<Self> {\n             let (a, b) = self.overflowing_neg();\n@@ -513,12 +507,10 @@ macro_rules! int_impl {\n         /// Basic usage:\n         ///\n         /// ```\n-        /// #![feature(wrapping)]\n-        ///\n         /// assert_eq!(0x10i32.checked_shl(4), Some(0x100));\n         /// assert_eq!(0x10i32.checked_shl(33), None);\n         /// ```\n-        #[unstable(feature = \"wrapping\", issue = \"27755\")]\n+        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n         #[inline]\n         pub fn checked_shl(self, rhs: u32) -> Option<Self> {\n             let (a, b) = self.overflowing_shl(rhs);\n@@ -533,12 +525,10 @@ macro_rules! int_impl {\n         /// Basic usage:\n         ///\n         /// ```\n-        /// #![feature(wrapping)]\n-        ///\n         /// assert_eq!(0x10i32.checked_shr(4), Some(0x1));\n         /// assert_eq!(0x10i32.checked_shr(33), None);\n         /// ```\n-        #[unstable(feature = \"wrapping\", issue = \"27755\")]\n+        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n         #[inline]\n         pub fn checked_shr(self, rhs: u32) -> Option<Self> {\n             let (a, b) = self.overflowing_shr(rhs);\n@@ -595,15 +585,13 @@ macro_rules! int_impl {\n         /// Basic usage:\n         ///\n         /// ```\n-        /// #![feature(wrapping)]\n-        ///\n         /// use std::i32;\n         ///\n         /// assert_eq!(100i32.saturating_mul(127), 12700);\n         /// assert_eq!((1i32 << 23).saturating_mul(1 << 23), i32::MAX);\n         /// assert_eq!((-1i32 << 23).saturating_mul(1 << 23), i32::MIN);\n         /// ```\n-        #[unstable(feature = \"wrapping\", issue = \"27755\")]\n+        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n         #[inline]\n         pub fn saturating_mul(self, other: Self) -> Self {\n             self.checked_mul(other).unwrap_or_else(|| {\n@@ -796,15 +784,13 @@ macro_rules! int_impl {\n         /// Basic usage\n         ///\n         /// ```\n-        /// #![feature(wrapping)]\n-        ///\n         /// use std::i32;\n         ///\n         /// assert_eq!(5i32.overflowing_add(2), (7, false));\n         /// assert_eq!(i32::MAX.overflowing_add(1), (i32::MIN, true));\n         /// ```\n         #[inline]\n-        #[unstable(feature = \"wrapping\", issue = \"27755\")]\n+        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n         pub fn overflowing_add(self, rhs: Self) -> (Self, bool) {\n             unsafe {\n                 let (a, b) = $add_with_overflow(self as $ActualT,\n@@ -824,15 +810,13 @@ macro_rules! int_impl {\n         /// Basic usage\n         ///\n         /// ```\n-        /// #![feature(wrapping)]\n-        ///\n         /// use std::i32;\n         ///\n         /// assert_eq!(5i32.overflowing_sub(2), (3, false));\n         /// assert_eq!(i32::MIN.overflowing_sub(1), (i32::MAX, true));\n         /// ```\n         #[inline]\n-        #[unstable(feature = \"wrapping\", issue = \"27755\")]\n+        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n         pub fn overflowing_sub(self, rhs: Self) -> (Self, bool) {\n             unsafe {\n                 let (a, b) = $sub_with_overflow(self as $ActualT,\n@@ -852,13 +836,11 @@ macro_rules! int_impl {\n         /// Basic usage\n         ///\n         /// ```\n-        /// #![feature(wrapping)]\n-        ///\n         /// assert_eq!(5i32.overflowing_mul(2), (10, false));\n         /// assert_eq!(1_000_000_000i32.overflowing_mul(10), (1410065408, true));\n         /// ```\n         #[inline]\n-        #[unstable(feature = \"wrapping\", issue = \"27755\")]\n+        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n         pub fn overflowing_mul(self, rhs: Self) -> (Self, bool) {\n             unsafe {\n                 let (a, b) = $mul_with_overflow(self as $ActualT,\n@@ -882,15 +864,13 @@ macro_rules! int_impl {\n         /// Basic usage\n         ///\n         /// ```\n-        /// #![feature(wrapping)]\n-        ///\n         /// use std::i32;\n         ///\n         /// assert_eq!(5i32.overflowing_div(2), (2, false));\n         /// assert_eq!(i32::MIN.overflowing_div(-1), (i32::MIN, true));\n         /// ```\n         #[inline]\n-        #[unstable(feature = \"wrapping\", issue = \"27755\")]\n+        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n         pub fn overflowing_div(self, rhs: Self) -> (Self, bool) {\n             if self == Self::min_value() && rhs == -1 {\n                 (self, true)\n@@ -914,15 +894,13 @@ macro_rules! int_impl {\n         /// Basic usage\n         ///\n         /// ```\n-        /// #![feature(wrapping)]\n-        ///\n         /// use std::i32;\n         ///\n         /// assert_eq!(5i32.overflowing_rem(2), (1, false));\n         /// assert_eq!(i32::MIN.overflowing_rem(-1), (0, true));\n         /// ```\n         #[inline]\n-        #[unstable(feature = \"wrapping\", issue = \"27755\")]\n+        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n         pub fn overflowing_rem(self, rhs: Self) -> (Self, bool) {\n             if self == Self::min_value() && rhs == -1 {\n                 (0, true)\n@@ -944,15 +922,13 @@ macro_rules! int_impl {\n         /// Basic usage\n         ///\n         /// ```\n-        /// #![feature(wrapping)]\n-        ///\n         /// use std::i32;\n         ///\n         /// assert_eq!(2i32.overflowing_neg(), (-2, false));\n         /// assert_eq!(i32::MIN.overflowing_neg(), (i32::MIN, true));\n         /// ```\n         #[inline]\n-        #[unstable(feature = \"wrapping\", issue = \"27755\")]\n+        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n         pub fn overflowing_neg(self) -> (Self, bool) {\n             if self == Self::min_value() {\n                 (Self::min_value(), true)\n@@ -974,13 +950,11 @@ macro_rules! int_impl {\n         /// Basic usage\n         ///\n         /// ```\n-        /// #![feature(wrapping)]\n-        ///\n         /// assert_eq!(0x10i32.overflowing_shl(4), (0x100, false));\n         /// assert_eq!(0x10i32.overflowing_shl(36), (0x100, true));\n         /// ```\n         #[inline]\n-        #[unstable(feature = \"wrapping\", issue = \"27755\")]\n+        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n         pub fn overflowing_shl(self, rhs: u32) -> (Self, bool) {\n             (self << (rhs & ($BITS - 1)), (rhs > ($BITS - 1)))\n         }\n@@ -998,13 +972,11 @@ macro_rules! int_impl {\n         /// Basic usage\n         ///\n         /// ```\n-        /// #![feature(wrapping)]\n-        ///\n         /// assert_eq!(0x10i32.overflowing_shr(4), (0x1, false));\n         /// assert_eq!(0x10i32.overflowing_shr(36), (0x1, true));\n         /// ```\n         #[inline]\n-        #[unstable(feature = \"wrapping\", issue = \"27755\")]\n+        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n         pub fn overflowing_shr(self, rhs: u32) -> (Self, bool) {\n             (self >> (rhs & ($BITS - 1)), (rhs > ($BITS - 1)))\n         }\n@@ -1542,12 +1514,10 @@ macro_rules! uint_impl {\n         /// Basic usage:\n         ///\n         /// ```\n-        /// #![feature(wrapping)]\n-        ///\n         /// assert_eq!(5u32.checked_rem(2), Some(1));\n         /// assert_eq!(5u32.checked_rem(0), None);\n         /// ```\n-        #[unstable(feature = \"wrapping\", issue = \"27755\")]\n+        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n         #[inline]\n         pub fn checked_rem(self, other: Self) -> Option<Self> {\n             if other == 0 {\n@@ -1557,6 +1527,26 @@ macro_rules! uint_impl {\n             }\n         }\n \n+        /// Checked negation. Computes `-self`, returning `None` unless `self ==\n+        /// 0`.\n+        ///\n+        /// Note that negating any positive integer will overflow.\n+        ///\n+        /// # Examples\n+        ///\n+        /// Basic usage:\n+        ///\n+        /// ```\n+        /// assert_eq!(0u32.checked_neg(), Some(0));\n+        /// assert_eq!(1u32.checked_neg(), None);\n+        /// ```\n+        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n+        #[inline]\n+        pub fn checked_neg(self) -> Option<Self> {\n+            let (a, b) = self.overflowing_neg();\n+            if b {None} else {Some(a)}\n+        }\n+\n         /// Checked shift left. Computes `self << rhs`, returning `None`\n         /// if `rhs` is larger than or equal to the number of bits in `self`.\n         ///\n@@ -1565,12 +1555,10 @@ macro_rules! uint_impl {\n         /// Basic usage:\n         ///\n         /// ```\n-        /// #![feature(wrapping)]\n-        ///\n         /// assert_eq!(0x10u32.checked_shl(4), Some(0x100));\n         /// assert_eq!(0x10u32.checked_shl(33), None);\n         /// ```\n-        #[unstable(feature = \"wrapping\", issue = \"27755\")]\n+        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n         #[inline]\n         pub fn checked_shl(self, rhs: u32) -> Option<Self> {\n             let (a, b) = self.overflowing_shl(rhs);\n@@ -1585,12 +1573,10 @@ macro_rules! uint_impl {\n         /// Basic usage:\n         ///\n         /// ```\n-        /// #![feature(wrapping)]\n-        ///\n         /// assert_eq!(0x10u32.checked_shr(4), Some(0x1));\n         /// assert_eq!(0x10u32.checked_shr(33), None);\n         /// ```\n-        #[unstable(feature = \"wrapping\", issue = \"27755\")]\n+        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n         #[inline]\n         pub fn checked_shr(self, rhs: u32) -> Option<Self> {\n             let (a, b) = self.overflowing_shr(rhs);\n@@ -1647,14 +1633,12 @@ macro_rules! uint_impl {\n         /// Basic usage:\n         ///\n         /// ```\n-        /// #![feature(wrapping)]\n-        ///\n         /// use std::u32;\n         ///\n         /// assert_eq!(100u32.saturating_mul(127), 12700);\n         /// assert_eq!((1u32 << 23).saturating_mul(1 << 23), u32::MAX);\n         /// ```\n-        #[unstable(feature = \"wrapping\", issue = \"27755\")]\n+        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n         #[inline]\n         pub fn saturating_mul(self, other: Self) -> Self {\n             self.checked_mul(other).unwrap_or(Self::max_value())\n@@ -1833,15 +1817,13 @@ macro_rules! uint_impl {\n         /// Basic usage\n         ///\n         /// ```\n-        /// #![feature(wrapping)]\n-        ///\n         /// use std::u32;\n         ///\n         /// assert_eq!(5u32.overflowing_add(2), (7, false));\n         /// assert_eq!(u32::MAX.overflowing_add(1), (0, true));\n         /// ```\n         #[inline]\n-        #[unstable(feature = \"wrapping\", issue = \"27755\")]\n+        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n         pub fn overflowing_add(self, rhs: Self) -> (Self, bool) {\n             unsafe {\n                 let (a, b) = $add_with_overflow(self as $ActualT,\n@@ -1861,15 +1843,13 @@ macro_rules! uint_impl {\n         /// Basic usage\n         ///\n         /// ```\n-        /// #![feature(wrapping)]\n-        ///\n         /// use std::u32;\n         ///\n         /// assert_eq!(5u32.overflowing_sub(2), (3, false));\n         /// assert_eq!(0u32.overflowing_sub(1), (u32::MAX, true));\n         /// ```\n         #[inline]\n-        #[unstable(feature = \"wrapping\", issue = \"27755\")]\n+        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n         pub fn overflowing_sub(self, rhs: Self) -> (Self, bool) {\n             unsafe {\n                 let (a, b) = $sub_with_overflow(self as $ActualT,\n@@ -1889,13 +1869,11 @@ macro_rules! uint_impl {\n         /// Basic usage\n         ///\n         /// ```\n-        /// #![feature(wrapping)]\n-        ///\n         /// assert_eq!(5u32.overflowing_mul(2), (10, false));\n         /// assert_eq!(1_000_000_000u32.overflowing_mul(10), (1410065408, true));\n         /// ```\n         #[inline]\n-        #[unstable(feature = \"wrapping\", issue = \"27755\")]\n+        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n         pub fn overflowing_mul(self, rhs: Self) -> (Self, bool) {\n             unsafe {\n                 let (a, b) = $mul_with_overflow(self as $ActualT,\n@@ -1920,12 +1898,10 @@ macro_rules! uint_impl {\n         /// Basic usage\n         ///\n         /// ```\n-        /// #![feature(wrapping)]\n-        ///\n         /// assert_eq!(5u32.overflowing_div(2), (2, false));\n         /// ```\n         #[inline]\n-        #[unstable(feature = \"wrapping\", issue = \"27755\")]\n+        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n         pub fn overflowing_div(self, rhs: Self) -> (Self, bool) {\n             (self / rhs, false)\n         }\n@@ -1946,12 +1922,10 @@ macro_rules! uint_impl {\n         /// Basic usage\n         ///\n         /// ```\n-        /// #![feature(wrapping)]\n-        ///\n         /// assert_eq!(5u32.overflowing_rem(2), (1, false));\n         /// ```\n         #[inline]\n-        #[unstable(feature = \"wrapping\", issue = \"27755\")]\n+        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n         pub fn overflowing_rem(self, rhs: Self) -> (Self, bool) {\n             (self % rhs, false)\n         }\n@@ -1968,13 +1942,11 @@ macro_rules! uint_impl {\n         /// Basic usage\n         ///\n         /// ```\n-        /// #![feature(wrapping)]\n-        ///\n         /// assert_eq!(0u32.overflowing_neg(), (0, false));\n         /// assert_eq!(2u32.overflowing_neg(), (-2i32 as u32, true));\n         /// ```\n         #[inline]\n-        #[unstable(feature = \"wrapping\", issue = \"27755\")]\n+        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n         pub fn overflowing_neg(self) -> (Self, bool) {\n             ((!self).wrapping_add(1), self != 0)\n         }\n@@ -1992,13 +1964,11 @@ macro_rules! uint_impl {\n         /// Basic usage\n         ///\n         /// ```\n-        /// #![feature(wrapping)]\n-        ///\n         /// assert_eq!(0x10u32.overflowing_shl(4), (0x100, false));\n         /// assert_eq!(0x10u32.overflowing_shl(36), (0x100, true));\n         /// ```\n         #[inline]\n-        #[unstable(feature = \"wrapping\", issue = \"27755\")]\n+        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n         pub fn overflowing_shl(self, rhs: u32) -> (Self, bool) {\n             (self << (rhs & ($BITS - 1)), (rhs > ($BITS - 1)))\n         }\n@@ -2016,13 +1986,11 @@ macro_rules! uint_impl {\n         /// Basic usage\n         ///\n         /// ```\n-        /// #![feature(wrapping)]\n-        ///\n         /// assert_eq!(0x10u32.overflowing_shr(4), (0x1, false));\n         /// assert_eq!(0x10u32.overflowing_shr(36), (0x1, true));\n         /// ```\n         #[inline]\n-        #[unstable(feature = \"wrapping\", issue = \"27755\")]\n+        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n         pub fn overflowing_shr(self, rhs: u32) -> (Self, bool) {\n             (self >> (rhs & ($BITS - 1)), (rhs > ($BITS - 1)))\n         }"}, {"sha": "16d84cf81e11db8a74608c2ebd9f3404476e65fa", "filename": "src/libcore/num/uint_macros.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9a4f43b9b6558ab74b3e849a7770dc193bc1847b/src%2Flibcore%2Fnum%2Fuint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a4f43b9b6558ab74b3e849a7770dc193bc1847b/src%2Flibcore%2Fnum%2Fuint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fuint_macros.rs?ref=9a4f43b9b6558ab74b3e849a7770dc193bc1847b", "patch": "@@ -15,11 +15,15 @@ macro_rules! uint_module { ($T:ty, $T_SIGNED:ty, $bits:expr) => (\n #[unstable(feature = \"num_bits_bytes\",\n            reason = \"may want to be an associated function\",\n            issue = \"27753\")]\n+#[rustc_deprecated(since = \"1.7.0\",\n+                   reason = \"will be replaced via const fn or associated constants\")]\n #[allow(missing_docs)]\n pub const BITS : usize = $bits;\n #[unstable(feature = \"num_bits_bytes\",\n            reason = \"may want to be an associated function\",\n            issue = \"27753\")]\n+#[rustc_deprecated(since = \"1.7.0\",\n+                   reason = \"will be replaced via const fn or associated constants\")]\n #[allow(missing_docs)]\n pub const BYTES : usize = ($bits / 8);\n "}, {"sha": "a6a7be023ebf4e3851fff0372f51090f54b21e7a", "filename": "src/libcore/num/usize.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9a4f43b9b6558ab74b3e849a7770dc193bc1847b/src%2Flibcore%2Fnum%2Fusize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a4f43b9b6558ab74b3e849a7770dc193bc1847b/src%2Flibcore%2Fnum%2Fusize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fusize.rs?ref=9a4f43b9b6558ab74b3e849a7770dc193bc1847b", "patch": "@@ -14,4 +14,7 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n-uint_module! { usize, isize, ::isize::BITS }\n+#[cfg(target_pointer_width = \"32\")]\n+uint_module! { usize, isize, 32 }\n+#[cfg(target_pointer_width = \"64\")]\n+uint_module! { usize, isize, 64 }"}, {"sha": "a6b3dc744699a3b1238e19dc18c4f3b981ca4c36", "filename": "src/libcore/num/wrapping.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9a4f43b9b6558ab74b3e849a7770dc193bc1847b/src%2Flibcore%2Fnum%2Fwrapping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a4f43b9b6558ab74b3e849a7770dc193bc1847b/src%2Flibcore%2Fnum%2Fwrapping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fwrapping.rs?ref=9a4f43b9b6558ab74b3e849a7770dc193bc1847b", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n #![allow(missing_docs)]\n-#![unstable(feature = \"wrapping\", reason = \"may be removed or relocated\",\n+#![unstable(feature = \"old_wrapping\", reason = \"may be removed or relocated\",\n             issue = \"27755\")]\n \n use intrinsics::{add_with_overflow, sub_with_overflow, mul_with_overflow};\n@@ -20,6 +20,9 @@ use ops::*;\n \n use ::{i8, i16, i32, i64, isize};\n \n+#[unstable(feature = \"old_wrapping\", reason = \"may be removed or relocated\",\n+           issue = \"27755\")]\n+#[rustc_deprecated(since = \"1.7.0\", reason = \"moved to inherent methods\")]\n pub trait OverflowingOps {\n     fn overflowing_add(self, rhs: Self) -> (Self, bool);\n     fn overflowing_sub(self, rhs: Self) -> (Self, bool);\n@@ -331,6 +334,7 @@ mod shift_max {\n \n macro_rules! signed_overflowing_impl {\n     ($($t:ident)*) => ($(\n+        #[allow(deprecated)]\n         impl OverflowingOps for $t {\n             #[inline(always)]\n             fn overflowing_add(self, rhs: $t) -> ($t, bool) {\n@@ -393,6 +397,7 @@ macro_rules! signed_overflowing_impl {\n \n macro_rules! unsigned_overflowing_impl {\n     ($($t:ident)*) => ($(\n+        #[allow(deprecated)]\n         impl OverflowingOps for $t {\n             #[inline(always)]\n             fn overflowing_add(self, rhs: $t) -> ($t, bool) {"}, {"sha": "583bb57a4a6f172c19ebd53a72926724c2b065d1", "filename": "src/libcore/slice.rs", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/9a4f43b9b6558ab74b3e849a7770dc193bc1847b/src%2Flibcore%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a4f43b9b6558ab74b3e849a7770dc193bc1847b/src%2Flibcore%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice.rs?ref=9a4f43b9b6558ab74b3e849a7770dc193bc1847b", "patch": "@@ -49,7 +49,6 @@ use result::Result::{Ok, Err};\n use ptr;\n use mem;\n use marker::{Send, Sync, self};\n-use num::wrapping::OverflowingOps;\n use raw::Repr;\n // Avoid conflicts with *both* the Slice trait (buggy) and the `slice::raw` module.\n use raw::Slice as RawSlice;\n@@ -151,8 +150,8 @@ pub trait SliceExt {\n     #[stable(feature = \"core\", since = \"1.6.0\")]\n     fn ends_with(&self, needle: &[Self::Item]) -> bool where Self::Item: PartialEq;\n \n-    #[unstable(feature = \"clone_from_slice\", issue= \"27750\")]\n-    fn clone_from_slice(&mut self, &[Self::Item]) -> usize where Self::Item: Clone;\n+    #[stable(feature = \"clone_from_slice\", since = \"1.7.0\")]\n+    fn clone_from_slice(&mut self, &[Self::Item]) where Self::Item: Clone;\n }\n \n // Use macros to be generic over const/mut\n@@ -476,14 +475,12 @@ impl<T> SliceExt for [T] {\n     }\n \n     #[inline]\n-    fn clone_from_slice(&mut self, src: &[T]) -> usize where T: Clone {\n-        let min = cmp::min(self.len(), src.len());\n-        let dst = &mut self[.. min];\n-        let src = &src[.. min];\n-        for i in 0..min {\n-            dst[i].clone_from(&src[i]);\n+    fn clone_from_slice(&mut self, src: &[T]) where T: Clone {\n+        assert!(self.len() == src.len(),\n+                \"destination and source slices have different lengths\");\n+        for (dst, src) in self.iter_mut().zip(src) {\n+            dst.clone_from(src);\n         }\n-        min\n     }\n }\n "}, {"sha": "dd111981f0e57814064d77754150b802347d74db", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9a4f43b9b6558ab74b3e849a7770dc193bc1847b/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a4f43b9b6558ab74b3e849a7770dc193bc1847b/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=9a4f43b9b6558ab74b3e849a7770dc193bc1847b", "patch": "@@ -32,7 +32,6 @@ use option::Option::{self, None, Some};\n use raw::{Repr, Slice};\n use result::Result::{self, Ok, Err};\n use slice::{self, SliceExt};\n-use usize;\n \n pub mod pattern;\n \n@@ -1160,15 +1159,16 @@ fn run_utf8_validation(v: &[u8]) -> Result<(), Utf8Error> {\n             // Ascii case, try to skip forward quickly.\n             // When the pointer is aligned, read 2 words of data per iteration\n             // until we find a word containing a non-ascii byte.\n-            const BYTES_PER_ITERATION: usize = 2 * usize::BYTES;\n+            let usize_bytes = mem::size_of::<usize>();\n+            let bytes_per_iteration = 2 * usize_bytes;\n             let ptr = v.as_ptr();\n-            let align = (ptr as usize + offset) & (usize::BYTES - 1);\n+            let align = (ptr as usize + offset) & (usize_bytes - 1);\n             if align == 0 {\n-                if len >= BYTES_PER_ITERATION {\n-                    while offset <= len - BYTES_PER_ITERATION {\n+                if len >= bytes_per_iteration {\n+                    while offset <= len - bytes_per_iteration {\n                         unsafe {\n                             let u = *(ptr.offset(offset as isize) as *const usize);\n-                            let v = *(ptr.offset((offset + usize::BYTES) as isize) as *const usize);\n+                            let v = *(ptr.offset((offset + usize_bytes) as isize) as *const usize);\n \n                             // break if there is a nonascii byte\n                             let zu = contains_nonascii(u);\n@@ -1177,7 +1177,7 @@ fn run_utf8_validation(v: &[u8]) -> Result<(), Utf8Error> {\n                                 break;\n                             }\n                         }\n-                        offset += BYTES_PER_ITERATION;\n+                        offset += bytes_per_iteration;\n                     }\n                 }\n                 // step from the point where the wordwise loop stopped"}, {"sha": "48a5501acb79114c92e91bb4aef2e865ec2057d1", "filename": "src/libcoretest/num/flt2dec/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9a4f43b9b6558ab74b3e849a7770dc193bc1847b/src%2Flibcoretest%2Fnum%2Fflt2dec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a4f43b9b6558ab74b3e849a7770dc193bc1847b/src%2Flibcoretest%2Fnum%2Fflt2dec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fnum%2Fflt2dec%2Fmod.rs?ref=9a4f43b9b6558ab74b3e849a7770dc193bc1847b", "patch": "@@ -100,7 +100,7 @@ fn check_exact<F, T>(mut f: F, v: T, vstr: &str, expected: &[u8], expectedk: i16\n \n     // check significant digits\n     for i in 1..cut.unwrap_or(expected.len() - 1) {\n-        expected_.clone_from_slice(&expected[..i]);\n+        expected_[..i].clone_from_slice(&expected[..i]);\n         let mut expectedk_ = expectedk;\n         if expected[i] >= b'5' {\n             // check if this is a rounding-to-even case.\n@@ -147,7 +147,7 @@ fn check_exact<F, T>(mut f: F, v: T, vstr: &str, expected: &[u8], expectedk: i16\n     // check infinite zero digits\n     if let Some(cut) = cut {\n         for i in cut..expected.len()-1 {\n-            expected_.clone_from_slice(&expected[..cut]);\n+            expected_[..cut].clone_from_slice(&expected[..cut]);\n             for c in &mut expected_[cut..i] { *c = b'0'; }\n \n             try_exact!(f(&decoded) => &mut buf, &expected_[..i], expectedk;"}, {"sha": "38b45ec0feaedacbcd9294e710b36d20b66d4e0c", "filename": "src/libgraphviz/lib.rs", "status": "modified", "additions": 32, "deletions": 5, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/9a4f43b9b6558ab74b3e849a7770dc193bc1847b/src%2Flibgraphviz%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a4f43b9b6558ab74b3e849a7770dc193bc1847b/src%2Flibgraphviz%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgraphviz%2Flib.rs?ref=9a4f43b9b6558ab74b3e849a7770dc193bc1847b", "patch": "@@ -47,9 +47,9 @@\n //! which is cyclic.\n //!\n //! ```rust\n-//! #![feature(rustc_private, into_cow)]\n+//! #![feature(rustc_private)]\n //!\n-//! use std::borrow::IntoCow;\n+//! use graphviz::IntoCow;\n //! use std::io::Write;\n //! use graphviz as dot;\n //!\n@@ -281,12 +281,11 @@\n        html_root_url = \"https://doc.rust-lang.org/nightly/\",\n        test(attr(allow(unused_variables), deny(warnings))))]\n \n-#![feature(into_cow)]\n #![feature(str_escape)]\n \n use self::LabelText::*;\n \n-use std::borrow::{IntoCow, Cow};\n+use std::borrow::{Cow, ToOwned};\n use std::io::prelude::*;\n use std::io;\n \n@@ -719,14 +718,42 @@ pub fn render_opts<'a,\n     writeln(w, &[\"}\"])\n }\n \n+pub trait IntoCow<'a, B: ?Sized> where B: ToOwned {\n+    fn into_cow(self) -> Cow<'a, B>;\n+}\n+\n+impl<'a> IntoCow<'a, str> for String {\n+    fn into_cow(self) -> Cow<'a, str> {\n+        Cow::Owned(self)\n+    }\n+}\n+\n+impl<'a> IntoCow<'a, str> for &'a str {\n+    fn into_cow(self) -> Cow<'a, str> {\n+        Cow::Borrowed(self)\n+    }\n+}\n+\n+impl<'a, T: Clone> IntoCow<'a, [T]> for Vec<T> {\n+    fn into_cow(self) -> Cow<'a, [T]> {\n+        Cow::Owned(self)\n+    }\n+}\n+\n+impl<'a, T: Clone> IntoCow<'a, [T]> for &'a [T] {\n+    fn into_cow(self) -> Cow<'a, [T]> {\n+        Cow::Borrowed(self)\n+    }\n+}\n+\n #[cfg(test)]\n mod tests {\n     use self::NodeLabels::*;\n     use super::{Id, Labeller, Nodes, Edges, GraphWalk, render, Style};\n     use super::LabelText::{self, LabelStr, EscStr, HtmlStr};\n     use std::io;\n     use std::io::prelude::*;\n-    use std::borrow::IntoCow;\n+    use IntoCow;\n \n     /// each node is an index in a vector in the graph.\n     type Node = usize;"}, {"sha": "fe15f1c53f99257f126d2230fa3fcc87a06d61b7", "filename": "src/librbml/lib.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9a4f43b9b6558ab74b3e849a7770dc193bc1847b/src%2Flibrbml%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a4f43b9b6558ab74b3e849a7770dc193bc1847b/src%2Flibrbml%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrbml%2Flib.rs?ref=9a4f43b9b6558ab74b3e849a7770dc193bc1847b", "patch": "@@ -123,7 +123,6 @@\n \n #![feature(rustc_private)]\n #![feature(staged_api)]\n-#![feature(clone_from_slice)]\n \n #![cfg_attr(test, feature(test))]\n \n@@ -972,7 +971,7 @@ pub mod writer {\n                 {\n                     let last_size_pos = last_size_pos as usize;\n                     let data = &self.writer.get_ref()[last_size_pos+4..cur_pos as usize];\n-                    buf.clone_from_slice(data);\n+                    buf[..size].clone_from_slice(data);\n                 }\n \n                 // overwrite the size and data and continue"}, {"sha": "501a03f128664ad3ebd0e9bb81700ebb29ed0975", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9a4f43b9b6558ab74b3e849a7770dc193bc1847b/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a4f43b9b6558ab74b3e849a7770dc193bc1847b/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=9a4f43b9b6558ab74b3e849a7770dc193bc1847b", "patch": "@@ -26,16 +26,13 @@\n #![feature(box_patterns)]\n #![feature(box_syntax)]\n #![feature(cell_extras)]\n-#![feature(clone_from_slice)]\n #![feature(collections)]\n #![feature(const_fn)]\n #![feature(enumset)]\n #![feature(hashmap_hasher)]\n-#![feature(into_cow)]\n #![feature(iter_arith)]\n #![feature(libc)]\n #![feature(nonzero)]\n-#![feature(num_bits_bytes)]\n #![feature(quote)]\n #![feature(rustc_diagnostic_macros)]\n #![feature(rustc_private)]\n@@ -44,7 +41,6 @@\n #![feature(staged_api)]\n #![feature(str_char)]\n #![feature(time2)]\n-#![feature(wrapping)]\n #![cfg_attr(test, feature(test))]\n \n #![allow(trivial_casts)]"}, {"sha": "e807092507082156781aab3edb6619d801daabb8", "filename": "src/librustc/middle/cfg/graphviz.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9a4f43b9b6558ab74b3e849a7770dc193bc1847b/src%2Flibrustc%2Fmiddle%2Fcfg%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a4f43b9b6558ab74b3e849a7770dc193bc1847b/src%2Flibrustc%2Fmiddle%2Fcfg%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcfg%2Fgraphviz.rs?ref=9a4f43b9b6558ab74b3e849a7770dc193bc1847b", "patch": "@@ -11,10 +11,9 @@\n /// This module provides linkage between rustc::middle::graph and\n /// libgraphviz traits.\n \n-use std::borrow::IntoCow;\n-\n // For clarity, rename the graphviz crate locally to dot.\n use graphviz as dot;\n+use graphviz::IntoCow;\n \n use syntax::ast;\n "}, {"sha": "55c9111325d7490ee73777637b24db181c1c4f17", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9a4f43b9b6558ab74b3e849a7770dc193bc1847b/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a4f43b9b6558ab74b3e849a7770dc193bc1847b/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=9a4f43b9b6558ab74b3e849a7770dc193bc1847b", "patch": "@@ -26,6 +26,7 @@ use middle::astconv_util::ast_ty_to_prim_ty;\n use util::num::ToPrimitive;\n use util::nodemap::NodeMap;\n \n+use graphviz::IntoCow;\n use syntax::{ast, abi};\n use rustc_front::hir::Expr;\n use rustc_front::hir;\n@@ -35,8 +36,7 @@ use syntax::parse::token::InternedString;\n use syntax::ptr::P;\n use syntax::codemap;\n \n-use std::borrow::{Cow, IntoCow};\n-use std::num::wrapping::OverflowingOps;\n+use std::borrow::Cow;\n use std::cmp::Ordering;\n use std::collections::hash_map::Entry::Vacant;\n use std::hash;"}, {"sha": "e9029958880bd73ced7005c7c81598f49bb6a6cf", "filename": "src/librustc/middle/dataflow.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/9a4f43b9b6558ab74b3e849a7770dc193bc1847b/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a4f43b9b6558ab74b3e849a7770dc193bc1847b/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdataflow.rs?ref=9a4f43b9b6558ab74b3e849a7770dc193bc1847b", "patch": "@@ -18,6 +18,7 @@ use middle::cfg;\n use middle::cfg::CFGIndex;\n use middle::ty;\n use std::io;\n+use std::mem;\n use std::usize;\n use syntax::ast;\n use syntax::ast_util::IdRange;\n@@ -229,7 +230,8 @@ impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n                oper: O,\n                id_range: IdRange,\n                bits_per_id: usize) -> DataFlowContext<'a, 'tcx, O> {\n-        let words_per_id = (bits_per_id + usize::BITS - 1) / usize::BITS;\n+        let usize_bits = mem::size_of::<usize>() * 8;\n+        let words_per_id = (bits_per_id + usize_bits - 1) / usize_bits;\n         let num_nodes = cfg.graph.all_nodes().len();\n \n         debug!(\"DataFlowContext::new(analysis_name: {}, id_range={:?}, \\\n@@ -408,10 +410,11 @@ impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n         //! Returns false on the first call to `f` that returns false;\n         //! if all calls to `f` return true, then returns true.\n \n+        let usize_bits = mem::size_of::<usize>() * 8;\n         for (word_index, &word) in words.iter().enumerate() {\n             if word != 0 {\n-                let base_index = word_index * usize::BITS;\n-                for offset in 0..usize::BITS {\n+                let base_index = word_index * usize_bits;\n+                for offset in 0..usize_bits {\n                     let bit = 1 << offset;\n                     if (word & bit) != 0 {\n                         // NB: we round up the total number of bits\n@@ -618,7 +621,7 @@ fn bits_to_string(words: &[usize]) -> String {\n \n     for &word in words {\n         let mut v = word;\n-        for _ in 0..usize::BYTES {\n+        for _ in 0..mem::size_of::<usize>() {\n             result.push(sep);\n             result.push_str(&format!(\"{:02x}\", v & 0xFF));\n             v >>= 8;\n@@ -647,8 +650,9 @@ fn bitwise<Op:BitwiseOperator>(out_vec: &mut [usize],\n fn set_bit(words: &mut [usize], bit: usize) -> bool {\n     debug!(\"set_bit: words={} bit={}\",\n            mut_bits_to_string(words), bit_str(bit));\n-    let word = bit / usize::BITS;\n-    let bit_in_word = bit % usize::BITS;\n+    let usize_bits = mem::size_of::<usize>() * 8;\n+    let word = bit / usize_bits;\n+    let bit_in_word = bit % usize_bits;\n     let bit_mask = 1 << bit_in_word;\n     debug!(\"word={} bit_in_word={} bit_mask={}\", word, bit_in_word, word);\n     let oldv = words[word];"}, {"sha": "8496f606b7b87caf8b15e043ee5571786b5e5fe4", "filename": "src/librustc/mir/repr.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9a4f43b9b6558ab74b3e849a7770dc193bc1847b/src%2Flibrustc%2Fmir%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a4f43b9b6558ab74b3e849a7770dc193bc1847b/src%2Flibrustc%2Fmir%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Frepr.rs?ref=9a4f43b9b6558ab74b3e849a7770dc193bc1847b", "patch": "@@ -17,8 +17,9 @@ use rustc_data_structures::tuple_slice::TupleSlice;\n use rustc_front::hir::InlineAsm;\n use syntax::ast::{self, Name};\n use syntax::codemap::Span;\n+use graphviz::IntoCow;\n use std::ascii;\n-use std::borrow::{Cow, IntoCow};\n+use std::borrow::Cow;\n use std::fmt::{self, Debug, Formatter, Write};\n use std::{iter, u32};\n use std::ops::{Index, IndexMut};"}, {"sha": "746d3ba07d6011383da92eaa73e3b22fad55fe60", "filename": "src/librustc_back/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9a4f43b9b6558ab74b3e849a7770dc193bc1847b/src%2Flibrustc_back%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a4f43b9b6558ab74b3e849a7770dc193bc1847b/src%2Flibrustc_back%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Flib.rs?ref=9a4f43b9b6558ab74b3e849a7770dc193bc1847b", "patch": "@@ -33,7 +33,6 @@\n #![feature(libc)]\n #![feature(rand)]\n #![feature(rustc_private)]\n-#![feature(clone_from_slice)]\n #![feature(staged_api)]\n #![feature(step_by)]\n #![cfg_attr(test, feature(test, rand))]"}, {"sha": "eb63f572649a3fada48619c3de97780c4f7f941d", "filename": "src/librustc_borrowck/graphviz.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9a4f43b9b6558ab74b3e849a7770dc193bc1847b/src%2Flibrustc_borrowck%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a4f43b9b6558ab74b3e849a7770dc193bc1847b/src%2Flibrustc_borrowck%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fgraphviz.rs?ref=9a4f43b9b6558ab74b3e849a7770dc193bc1847b", "patch": "@@ -23,7 +23,7 @@ use dot;\n use rustc::middle::cfg::CFGIndex;\n use rustc::middle::dataflow::{DataFlowOperator, DataFlowContext, EntryOrExit};\n use std::rc::Rc;\n-use std::borrow::IntoCow;\n+use dot::IntoCow;\n \n #[derive(Debug, Copy, Clone)]\n pub enum Variant {"}, {"sha": "d730b383a80499d7e52f05a8fe2c17f2a144b19d", "filename": "src/librustc_borrowck/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9a4f43b9b6558ab74b3e849a7770dc193bc1847b/src%2Flibrustc_borrowck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a4f43b9b6558ab74b3e849a7770dc193bc1847b/src%2Flibrustc_borrowck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Flib.rs?ref=9a4f43b9b6558ab74b3e849a7770dc193bc1847b", "patch": "@@ -22,7 +22,6 @@\n #![feature(rustc_diagnostic_macros)]\n #![feature(rustc_private)]\n #![feature(staged_api)]\n-#![feature(into_cow)]\n \n #[macro_use] extern crate log;\n #[macro_use] extern crate syntax;"}, {"sha": "78252c491ecfe72818d60ce33be5c97a04c38a38", "filename": "src/librustc_lint/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9a4f43b9b6558ab74b3e849a7770dc193bc1847b/src%2Flibrustc_lint%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a4f43b9b6558ab74b3e849a7770dc193bc1847b/src%2Flibrustc_lint%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Flib.rs?ref=9a4f43b9b6558ab74b3e849a7770dc193bc1847b", "patch": "@@ -30,7 +30,6 @@\n #![cfg_attr(test, feature(test))]\n #![feature(box_patterns)]\n #![feature(box_syntax)]\n-#![feature(num_bits_bytes)]\n #![feature(quote)]\n #![feature(rustc_diagnostic_macros)]\n #![feature(rustc_private)]"}, {"sha": "c3dfca44349eb6f9b6a84538cdd662abc82845b6", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/9a4f43b9b6558ab74b3e849a7770dc193bc1847b/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a4f43b9b6558ab74b3e849a7770dc193bc1847b/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=9a4f43b9b6558ab74b3e849a7770dc193bc1847b", "patch": "@@ -275,20 +275,20 @@ impl LateLintPass for TypeLimits {\n         fn int_ty_bits(int_ty: ast::IntTy, target_int_ty: ast::IntTy) -> u64 {\n             match int_ty {\n                 ast::TyIs => int_ty_bits(target_int_ty, target_int_ty),\n-                ast::TyI8 =>    i8::BITS  as u64,\n-                ast::TyI16 =>   i16::BITS as u64,\n-                ast::TyI32 =>   i32::BITS as u64,\n-                ast::TyI64 =>   i64::BITS as u64\n+                ast::TyI8 => 8,\n+                ast::TyI16 => 16 as u64,\n+                ast::TyI32 => 32,\n+                ast::TyI64 => 64,\n             }\n         }\n \n         fn uint_ty_bits(uint_ty: ast::UintTy, target_uint_ty: ast::UintTy) -> u64 {\n             match uint_ty {\n                 ast::TyUs => uint_ty_bits(target_uint_ty, target_uint_ty),\n-                ast::TyU8 =>    u8::BITS  as u64,\n-                ast::TyU16 =>   u16::BITS as u64,\n-                ast::TyU32 =>   u32::BITS as u64,\n-                ast::TyU64 =>   u64::BITS as u64\n+                ast::TyU8 => 8,\n+                ast::TyU16 => 16,\n+                ast::TyU32 => 32,\n+                ast::TyU64 => 64,\n             }\n         }\n "}, {"sha": "c1ab0284ade5235e226f30237eb8fc30652499eb", "filename": "src/librustc_trans/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9a4f43b9b6558ab74b3e849a7770dc193bc1847b/src%2Flibrustc_trans%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a4f43b9b6558ab74b3e849a7770dc193bc1847b/src%2Flibrustc_trans%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Flib.rs?ref=9a4f43b9b6558ab74b3e849a7770dc193bc1847b", "patch": "@@ -27,10 +27,8 @@\n #![feature(const_fn)]\n #![feature(custom_attribute)]\n #![allow(unused_attributes)]\n-#![feature(into_cow)]\n #![feature(iter_arith)]\n #![feature(libc)]\n-#![feature(path_relative_from)]\n #![feature(quote)]\n #![feature(rustc_diagnostic_macros)]\n #![feature(rustc_private)]"}, {"sha": "3d6a6a8fa77709136aaba50627978cf87516c4b8", "filename": "src/librustc_trans/trans/assert_dep_graph.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9a4f43b9b6558ab74b3e849a7770dc193bc1847b/src%2Flibrustc_trans%2Ftrans%2Fassert_dep_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a4f43b9b6558ab74b3e849a7770dc193bc1847b/src%2Flibrustc_trans%2Ftrans%2Fassert_dep_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fassert_dep_graph.rs?ref=9a4f43b9b6558ab74b3e849a7770dc193bc1847b", "patch": "@@ -45,7 +45,7 @@ use rustc_data_structures::fnv::{FnvHashMap, FnvHashSet};\n use rustc_data_structures::graph::{Direction, INCOMING, OUTGOING, NodeIndex};\n use rustc_front::hir;\n use rustc_front::intravisit::Visitor;\n-use std::borrow::IntoCow;\n+use graphviz::IntoCow;\n use std::env;\n use std::fs::File;\n use std::io::Write;"}, {"sha": "2e3f4326b877588eded7a2586a839179cd530b88", "filename": "src/librustc_trans/trans/debuginfo/metadata.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9a4f43b9b6558ab74b3e849a7770dc193bc1847b/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a4f43b9b6558ab74b3e849a7770dc193bc1847b/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmetadata.rs?ref=9a4f43b9b6558ab74b3e849a7770dc193bc1847b", "patch": "@@ -990,8 +990,8 @@ pub fn compile_unit_metadata(cx: &CrateContext) -> DIDescriptor {\n                 cx.sess().warn(\"debuginfo: Invalid path to crate's local root source file!\");\n                 fallback_path(cx)\n             } else {\n-                match abs_path.relative_from(work_dir) {\n-                    Some(ref p) if p.is_relative() => {\n+                match abs_path.strip_prefix(work_dir) {\n+                    Ok(ref p) if p.is_relative() => {\n                         if p.starts_with(Path::new(\"./\")) {\n                             path2cstr(p)\n                         } else {"}, {"sha": "850045382e1f2c95d1f30d75557f403a352ffa49", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9a4f43b9b6558ab74b3e849a7770dc193bc1847b/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a4f43b9b6558ab74b3e849a7770dc193bc1847b/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=9a4f43b9b6558ab74b3e849a7770dc193bc1847b", "patch": "@@ -819,7 +819,7 @@ fn clean_srcpath<F>(src_root: &Path, p: &Path, keep_filename: bool, mut f: F) wh\n     F: FnMut(&str),\n {\n     // make it relative, if possible\n-    let p = p.relative_from(src_root).unwrap_or(p);\n+    let p = p.strip_prefix(src_root).unwrap_or(p);\n \n     let mut iter = p.iter().map(|x| x.to_str().unwrap()).peekable();\n     while let Some(c) = iter.next() {"}, {"sha": "ac5b64f37aafedf9e940823ef1d6d8b5391a157d", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9a4f43b9b6558ab74b3e849a7770dc193bc1847b/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a4f43b9b6558ab74b3e849a7770dc193bc1847b/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=9a4f43b9b6558ab74b3e849a7770dc193bc1847b", "patch": "@@ -21,7 +21,6 @@\n #![feature(box_syntax)]\n #![feature(dynamic_lib)]\n #![feature(libc)]\n-#![feature(path_relative_from)]\n #![feature(rustc_private)]\n #![feature(set_stdio)]\n #![feature(slice_patterns)]"}, {"sha": "e21307cc75292cd9be71a494ebb057a71c7bbf8a", "filename": "src/libserialize/collection_impls.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9a4f43b9b6558ab74b3e849a7770dc193bc1847b/src%2Flibserialize%2Fcollection_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a4f43b9b6558ab74b3e849a7770dc193bc1847b/src%2Flibserialize%2Fcollection_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fcollection_impls.rs?ref=9a4f43b9b6558ab74b3e849a7770dc193bc1847b", "patch": "@@ -10,10 +10,9 @@\n \n //! Implementations of serialization for structures found in libcollections\n \n-use std::usize;\n-use std::default::Default;\n use std::hash::Hash;\n use std::collections::hash_state::HashState;\n+use std::mem;\n \n use {Decodable, Encodable, Decoder, Encoder};\n use std::collections::{LinkedList, VecDeque, BTreeMap, BTreeSet, HashMap, HashSet};\n@@ -148,7 +147,7 @@ impl<\n     fn decode<D: Decoder>(d: &mut D) -> Result<EnumSet<T>, D::Error> {\n         let bits = try!(d.read_uint());\n         let mut set = EnumSet::new();\n-        for bit in 0..usize::BITS {\n+        for bit in 0..(mem::size_of::<usize>()*8) {\n             if bits & (1 << bit) != 0 {\n                 set.insert(CLike::from_usize(1 << bit));\n             }"}, {"sha": "910600d91e45605ff519d8c07518dbb85ab9c0b9", "filename": "src/libserialize/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9a4f43b9b6558ab74b3e849a7770dc193bc1847b/src%2Flibserialize%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a4f43b9b6558ab74b3e849a7770dc193bc1847b/src%2Flibserialize%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Flib.rs?ref=9a4f43b9b6558ab74b3e849a7770dc193bc1847b", "patch": "@@ -30,7 +30,6 @@ Core encoding and decoding interfaces.\n #![feature(collections)]\n #![feature(enumset)]\n #![feature(hashmap_hasher)]\n-#![feature(num_bits_bytes)]\n #![feature(rustc_private)]\n #![feature(staged_api)]\n #![feature(str_char)]"}, {"sha": "f8550fd8842e1de54920eafd9b4e1b1561f4792a", "filename": "src/libstd/collections/hash/table.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9a4f43b9b6558ab74b3e849a7770dc193bc1847b/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a4f43b9b6558ab74b3e849a7770dc193bc1847b/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs?ref=9a4f43b9b6558ab74b3e849a7770dc193bc1847b", "patch": "@@ -15,7 +15,6 @@ use hash::{Hash, Hasher};\n use marker;\n use mem::{align_of, size_of};\n use mem;\n-use num::wrapping::OverflowingOps;\n use ops::{Deref, DerefMut};\n use ptr::{self, Unique};\n use collections::hash_state::HashState;"}, {"sha": "d6aa746f4cb5333ed1eec65adf8dd0cb1872be13", "filename": "src/libstd/ffi/c_str.rs", "status": "modified", "additions": 21, "deletions": 11, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/9a4f43b9b6558ab74b3e849a7770dc193bc1847b/src%2Flibstd%2Fffi%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a4f43b9b6558ab74b3e849a7770dc193bc1847b/src%2Flibstd%2Fffi%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fffi%2Fc_str.rs?ref=9a4f43b9b6558ab74b3e849a7770dc193bc1847b", "patch": "@@ -150,7 +150,7 @@ pub struct NulError(usize, Vec<u8>);\n /// An error returned from `CString::into_string` to indicate that a UTF-8 error\n /// was encountered during the conversion.\n #[derive(Clone, PartialEq, Debug)]\n-#[unstable(feature = \"cstring_into\", reason = \"recently added\", issue = \"29157\")]\n+#[stable(feature = \"cstring_into\", since = \"1.7.0\")]\n pub struct IntoStringError {\n     inner: CString,\n     error: Utf8Error,\n@@ -235,7 +235,7 @@ impl CString {\n     /// Converts the `CString` into a `String` if it contains valid Unicode data.\n     ///\n     /// On failure, ownership of the original `CString` is returned.\n-    #[unstable(feature = \"cstring_into\", reason = \"recently added\", issue = \"29157\")]\n+    #[stable(feature = \"cstring_into\", since = \"1.7.0\")]\n     pub fn into_string(self) -> Result<String, IntoStringError> {\n         String::from_utf8(self.into_bytes())\n             .map_err(|e| IntoStringError {\n@@ -248,9 +248,8 @@ impl CString {\n     ///\n     /// The returned buffer does **not** contain the trailing nul separator and\n     /// it is guaranteed to not have any interior nul bytes.\n-    #[unstable(feature = \"cstring_into\", reason = \"recently added\", issue = \"29157\")]\n+    #[stable(feature = \"cstring_into\", since = \"1.7.0\")]\n     pub fn into_bytes(self) -> Vec<u8> {\n-        // FIXME: Once this method becomes stable, add an `impl Into<Vec<u8>> for CString`\n         let mut vec = self.inner.into_vec();\n         let _nul = vec.pop();\n         debug_assert_eq!(_nul, Some(0u8));\n@@ -259,7 +258,7 @@ impl CString {\n \n     /// Equivalent to the `into_bytes` function except that the returned vector\n     /// includes the trailing nul byte.\n-    #[unstable(feature = \"cstring_into\", reason = \"recently added\", issue = \"29157\")]\n+    #[stable(feature = \"cstring_into\", since = \"1.7.0\")]\n     pub fn into_bytes_with_nul(self) -> Vec<u8> {\n         self.inner.into_vec()\n     }\n@@ -297,6 +296,13 @@ impl fmt::Debug for CString {\n     }\n }\n \n+#[stable(feature = \"cstring_into\", since = \"1.7.0\")]\n+impl From<CString> for Vec<u8> {\n+    fn from(s: CString) -> Vec<u8> {\n+        s.into_bytes()\n+    }\n+}\n+\n #[stable(feature = \"cstr_debug\", since = \"1.3.0\")]\n impl fmt::Debug for CStr {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n@@ -348,29 +354,33 @@ impl From<NulError> for io::Error {\n impl IntoStringError {\n     /// Consumes this error, returning original `CString` which generated the\n     /// error.\n-    #[unstable(feature = \"cstring_into\", reason = \"recently added\", issue = \"29157\")]\n+    #[stable(feature = \"cstring_into\", since = \"1.7.0\")]\n     pub fn into_cstring(self) -> CString {\n         self.inner\n     }\n \n     /// Access the underlying UTF-8 error that was the cause of this error.\n-    #[unstable(feature = \"cstring_into\", reason = \"recently added\", issue = \"29157\")]\n+    #[stable(feature = \"cstring_into\", since = \"1.7.0\")]\n     pub fn utf8_error(&self) -> Utf8Error {\n         self.error\n     }\n }\n \n-#[unstable(feature = \"cstring_into\", reason = \"recently added\", issue = \"29157\")]\n+#[stable(feature = \"cstring_into\", since = \"1.7.0\")]\n impl Error for IntoStringError {\n     fn description(&self) -> &str {\n-        Error::description(&self.error)\n+        \"C string contained non-utf8 bytes\"\n+    }\n+\n+    fn cause(&self) -> Option<&Error> {\n+        Some(&self.error)\n     }\n }\n \n-#[unstable(feature = \"cstring_into\", reason = \"recently added\", issue = \"29157\")]\n+#[stable(feature = \"cstring_into\", since = \"1.7.0\")]\n impl fmt::Display for IntoStringError {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        fmt::Display::fmt(&self.error, f)\n+        self.description().fmt(f)\n     }\n }\n "}, {"sha": "4573f46581969f767a2b4edbf528d3354b858aab", "filename": "src/libstd/io/cursor.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/9a4f43b9b6558ab74b3e849a7770dc193bc1847b/src%2Flibstd%2Fio%2Fcursor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a4f43b9b6558ab74b3e849a7770dc193bc1847b/src%2Flibstd%2Fio%2Fcursor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fcursor.rs?ref=9a4f43b9b6558ab74b3e849a7770dc193bc1847b", "patch": "@@ -252,10 +252,13 @@ impl Write for Cursor<Vec<u8>> {\n \n         // Figure out what bytes will be used to overwrite what's currently\n         // there (left), and what will be appended on the end (right)\n-        let space = self.inner.len() - pos as usize;\n-        let (left, right) = buf.split_at(cmp::min(space, buf.len()));\n-        self.inner[(pos as usize)..].clone_from_slice(left);\n-        self.inner.extend_from_slice(right);\n+        {\n+            let pos = pos as usize;\n+            let space = self.inner.len() - pos;\n+            let (left, right) = buf.split_at(cmp::min(space, buf.len()));\n+            self.inner[pos..pos + left.len()].clone_from_slice(left);\n+            self.inner.extend_from_slice(right);\n+        }\n \n         // Bump us forward\n         self.set_position(pos + buf.len() as u64);"}, {"sha": "592e16b0a3c090f54d456276864d5c0ee646c164", "filename": "src/libstd/io/impls.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9a4f43b9b6558ab74b3e849a7770dc193bc1847b/src%2Flibstd%2Fio%2Fimpls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a4f43b9b6558ab74b3e849a7770dc193bc1847b/src%2Flibstd%2Fio%2Fimpls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fimpls.rs?ref=9a4f43b9b6558ab74b3e849a7770dc193bc1847b", "patch": "@@ -156,7 +156,7 @@ impl<'a> Read for &'a [u8] {\n     fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n         let amt = cmp::min(buf.len(), self.len());\n         let (a, b) = self.split_at(amt);\n-        buf.clone_from_slice(a);\n+        buf[..amt].clone_from_slice(a);\n         *self = b;\n         Ok(amt)\n     }"}, {"sha": "9adea351e3d0e4d148dde9c78f2df1d5931fa310", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9a4f43b9b6558ab74b3e849a7770dc193bc1847b/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a4f43b9b6558ab74b3e849a7770dc193bc1847b/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=9a4f43b9b6558ab74b3e849a7770dc193bc1847b", "patch": "@@ -219,7 +219,6 @@\n #![feature(cfg_target_vendor)]\n #![feature(cfg_target_thread_local)]\n #![feature(char_internals)]\n-#![feature(clone_from_slice)]\n #![feature(collections)]\n #![feature(collections_bound)]\n #![feature(const_fn)]\n@@ -240,6 +239,7 @@\n #![feature(linkage)]\n #![feature(macro_reexport)]\n #![feature(num_bits_bytes)]\n+#![feature(old_wrapping)]\n #![feature(on_unimplemented)]\n #![feature(oom)]\n #![feature(optin_builtin_traits)]\n@@ -266,7 +266,6 @@\n #![feature(unsafe_no_drop_flag, filling_drop)]\n #![feature(unwind_attributes)]\n #![feature(vec_push_all)]\n-#![feature(wrapping)]\n #![feature(zero_one)]\n \n // Don't link to std. We are std."}, {"sha": "c043b41ed21f0e3403a5dd2ef76acb4606cc3346", "filename": "src/libstd/memchr.rs", "status": "modified", "additions": 15, "deletions": 13, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/9a4f43b9b6558ab74b3e849a7770dc193bc1847b/src%2Flibstd%2Fmemchr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a4f43b9b6558ab74b3e849a7770dc193bc1847b/src%2Flibstd%2Fmemchr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmemchr.rs?ref=9a4f43b9b6558ab74b3e849a7770dc193bc1847b", "patch": "@@ -107,7 +107,7 @@ pub fn memrchr(needle: u8, haystack: &[u8]) -> Option<usize> {\n #[allow(dead_code)]\n mod fallback {\n     use cmp;\n-    use usize;\n+    use mem;\n \n     const LO_U64: u64 = 0x0101010101010101;\n     const HI_U64: u64 = 0x8080808080808080;\n@@ -155,12 +155,13 @@ mod fallback {\n         // - the last remaining part, < 2 word size\n         let len = text.len();\n         let ptr = text.as_ptr();\n+        let usize_bytes = mem::size_of::<usize>();\n \n         // search up to an aligned boundary\n-        let align = (ptr as usize) & (usize::BYTES- 1);\n+        let align = (ptr as usize) & (usize_bytes- 1);\n         let mut offset;\n         if align > 0 {\n-            offset = cmp::min(usize::BYTES - align, len);\n+            offset = cmp::min(usize_bytes - align, len);\n             if let Some(index) = text[..offset].iter().position(|elt| *elt == x) {\n                 return Some(index);\n             }\n@@ -171,11 +172,11 @@ mod fallback {\n         // search the body of the text\n         let repeated_x = repeat_byte(x);\n \n-        if len >= 2 * usize::BYTES {\n-            while offset <= len - 2 * usize::BYTES {\n+        if len >= 2 * usize_bytes {\n+            while offset <= len - 2 * usize_bytes {\n                 unsafe {\n                     let u = *(ptr.offset(offset as isize) as *const usize);\n-                    let v = *(ptr.offset((offset + usize::BYTES) as isize) as *const usize);\n+                    let v = *(ptr.offset((offset + usize_bytes) as isize) as *const usize);\n \n                     // break if there is a matching byte\n                     let zu = contains_zero_byte(u ^ repeated_x);\n@@ -184,7 +185,7 @@ mod fallback {\n                         break;\n                     }\n                 }\n-                offset += usize::BYTES * 2;\n+                offset += usize_bytes * 2;\n             }\n         }\n \n@@ -202,12 +203,13 @@ mod fallback {\n         // - the first remaining bytes, < 2 word size\n         let len = text.len();\n         let ptr = text.as_ptr();\n+        let usize_bytes = mem::size_of::<usize>();\n \n         // search to an aligned boundary\n-        let end_align = (ptr as usize + len) & (usize::BYTES - 1);\n+        let end_align = (ptr as usize + len) & (usize_bytes - 1);\n         let mut offset;\n         if end_align > 0 {\n-            offset = len - cmp::min(usize::BYTES - end_align, len);\n+            offset = len - cmp::min(usize_bytes - end_align, len);\n             if let Some(index) = text[offset..].iter().rposition(|elt| *elt == x) {\n                 return Some(offset + index);\n             }\n@@ -218,10 +220,10 @@ mod fallback {\n         // search the body of the text\n         let repeated_x = repeat_byte(x);\n \n-        while offset >= 2 * usize::BYTES {\n+        while offset >= 2 * usize_bytes {\n             unsafe {\n-                let u = *(ptr.offset(offset as isize - 2 * usize::BYTES as isize) as *const usize);\n-                let v = *(ptr.offset(offset as isize - usize::BYTES as isize) as *const usize);\n+                let u = *(ptr.offset(offset as isize - 2 * usize_bytes as isize) as *const usize);\n+                let v = *(ptr.offset(offset as isize - usize_bytes as isize) as *const usize);\n \n                 // break if there is a matching byte\n                 let zu = contains_zero_byte(u ^ repeated_x);\n@@ -230,7 +232,7 @@ mod fallback {\n                     break;\n                 }\n             }\n-            offset -= 2 * usize::BYTES;\n+            offset -= 2 * usize_bytes;\n         }\n \n         // find the byte before the point the body loop stopped"}, {"sha": "341ba98191ae97f425473e2585938ddbeb87089b", "filename": "src/libstd/net/ip.rs", "status": "modified", "additions": 21, "deletions": 2, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/9a4f43b9b6558ab74b3e849a7770dc193bc1847b/src%2Flibstd%2Fnet%2Fip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a4f43b9b6558ab74b3e849a7770dc193bc1847b/src%2Flibstd%2Fnet%2Fip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Fip.rs?ref=9a4f43b9b6558ab74b3e849a7770dc193bc1847b", "patch": "@@ -89,6 +89,9 @@ impl Ipv4Addr {\n     }\n \n     /// Returns true if this is a loopback address (127.0.0.0/8).\n+    ///\n+    /// This property is defined by RFC 6890\n+    #[stable(since = \"1.7.0\", feature = \"ip_17\")]\n     pub fn is_loopback(&self) -> bool {\n         self.octets()[0] == 127\n     }\n@@ -100,6 +103,7 @@ impl Ipv4Addr {\n     ///  - 10.0.0.0/8\n     ///  - 172.16.0.0/12\n     ///  - 192.168.0.0/16\n+    #[stable(since = \"1.7.0\", feature = \"ip_17\")]\n     pub fn is_private(&self) -> bool {\n         match (self.octets()[0], self.octets()[1]) {\n             (10, _) => true,\n@@ -110,6 +114,9 @@ impl Ipv4Addr {\n     }\n \n     /// Returns true if the address is link-local (169.254.0.0/16).\n+    ///\n+    /// This property is defined by RFC 6890\n+    #[stable(since = \"1.7.0\", feature = \"ip_17\")]\n     pub fn is_link_local(&self) -> bool {\n         self.octets()[0] == 169 && self.octets()[1] == 254\n     }\n@@ -130,14 +137,17 @@ impl Ipv4Addr {\n \n     /// Returns true if this is a multicast address.\n     ///\n-    /// Multicast addresses have a most significant octet between 224 and 239.\n+    /// Multicast addresses have a most significant octet between 224 and 239,\n+    /// and is defined by RFC 5771\n+    #[stable(since = \"1.7.0\", feature = \"ip_17\")]\n     pub fn is_multicast(&self) -> bool {\n         self.octets()[0] >= 224 && self.octets()[0] <= 239\n     }\n \n     /// Returns true if this is a broadcast address.\n     ///\n     /// A broadcast address has all octets set to 255 as defined in RFC 919.\n+    #[stable(since = \"1.7.0\", feature = \"ip_17\")]\n     pub fn is_broadcast(&self) -> bool {\n         self.octets()[0] == 255 && self.octets()[1] == 255 &&\n         self.octets()[2] == 255 && self.octets()[3] == 255\n@@ -150,6 +160,7 @@ impl Ipv4Addr {\n     /// - 192.0.2.0/24 (TEST-NET-1)\n     /// - 198.51.100.0/24 (TEST-NET-2)\n     /// - 203.0.113.0/24 (TEST-NET-3)\n+    #[stable(since = \"1.7.0\", feature = \"ip_17\")]\n     pub fn is_documentation(&self) -> bool {\n         match(self.octets()[0], self.octets()[1], self.octets()[2], self.octets()[3]) {\n             (192, 0, 2, _) => true,\n@@ -302,11 +313,17 @@ impl Ipv6Addr {\n     }\n \n     /// Returns true for the special 'unspecified' address ::.\n+    ///\n+    /// This property is defined in RFC 6890.\n+    #[stable(since = \"1.7.0\", feature = \"ip_17\")]\n     pub fn is_unspecified(&self) -> bool {\n         self.segments() == [0, 0, 0, 0, 0, 0, 0, 0]\n     }\n \n     /// Returns true if this is a loopback address (::1).\n+    ///\n+    /// This property is defined in RFC 6890.\n+    #[stable(since = \"1.7.0\", feature = \"ip_17\")]\n     pub fn is_loopback(&self) -> bool {\n         self.segments() == [0, 0, 0, 0, 0, 0, 0, 1]\n     }\n@@ -378,7 +395,9 @@ impl Ipv6Addr {\n \n     /// Returns true if this is a multicast address.\n     ///\n-    /// Multicast addresses have the form ff00::/8.\n+    /// Multicast addresses have the form ff00::/8, and this property is defined\n+    /// by RFC 3956.\n+    #[stable(since = \"1.7.0\", feature = \"ip_17\")]\n     pub fn is_multicast(&self) -> bool {\n         (self.segments()[0] & 0xff00) == 0xff00\n     }"}, {"sha": "91401c8e4fd2c0e3b2d12f5f905059548182a817", "filename": "src/libstd/net/parser.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9a4f43b9b6558ab74b3e849a7770dc193bc1847b/src%2Flibstd%2Fnet%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a4f43b9b6558ab74b3e849a7770dc193bc1847b/src%2Flibstd%2Fnet%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Fparser.rs?ref=9a4f43b9b6558ab74b3e849a7770dc193bc1847b", "patch": "@@ -193,7 +193,7 @@ impl<'a> Parser<'a> {\n         fn ipv6_addr_from_head_tail(head: &[u16], tail: &[u16]) -> Ipv6Addr {\n             assert!(head.len() + tail.len() <= 8);\n             let mut gs = [0; 8];\n-            gs.clone_from_slice(head);\n+            gs[..head.len()].clone_from_slice(head);\n             gs[(8 - tail.len()) .. 8].clone_from_slice(tail);\n             Ipv6Addr::new(gs[0], gs[1], gs[2], gs[3], gs[4], gs[5], gs[6], gs[7])\n         }"}, {"sha": "e398a5a28c9043de5c46fc4a859912d03b56c91e", "filename": "src/libstd/path.rs", "status": "modified", "additions": 46, "deletions": 3, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/9a4f43b9b6558ab74b3e849a7770dc193bc1847b/src%2Flibstd%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a4f43b9b6558ab74b3e849a7770dc193bc1847b/src%2Flibstd%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath.rs?ref=9a4f43b9b6558ab74b3e849a7770dc193bc1847b", "patch": "@@ -100,8 +100,10 @@\n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n use ascii::*;\n+#[allow(deprecated)]\n use borrow::{Borrow, IntoCow, ToOwned, Cow};\n use cmp;\n+use error::Error;\n use fmt;\n use fs;\n use hash::{Hash, Hasher};\n@@ -1043,6 +1045,7 @@ impl PathBuf {\n         self._push(path.as_ref())\n     }\n \n+    #[allow(deprecated)]\n     fn _push(&mut self, path: &Path) {\n         // in general, a separator is needed if the rightmost byte is not a separator\n         let mut need_sep = self.as_mut_vec().last().map(|c| !is_sep_byte(*c)).unwrap_or(false);\n@@ -1219,13 +1222,15 @@ impl Borrow<Path> for PathBuf {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[allow(deprecated)]\n impl IntoCow<'static, Path> for PathBuf {\n     fn into_cow(self) -> Cow<'static, Path> {\n         Cow::Owned(self)\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[allow(deprecated)]\n impl<'a> IntoCow<'a, Path> for &'a Path {\n     fn into_cow(self) -> Cow<'a, Path> {\n         Cow::Borrowed(self)\n@@ -1328,6 +1333,12 @@ pub struct Path {\n     inner: OsStr,\n }\n \n+/// An error returned from the `Path::strip_prefix` method indicating that the\n+/// prefix was not found in `self`.\n+#[derive(Debug, Clone, PartialEq, Eq)]\n+#[stable(since = \"1.7.0\", feature = \"strip_prefix\")]\n+pub struct StripPrefixError(());\n+\n impl Path {\n     // The following (private!) function allows construction of a path from a u8\n     // slice, which is only safe when it is known to follow the OsStr encoding.\n@@ -1447,6 +1458,7 @@ impl Path {\n     /// assert!(!Path::new(\"foo.txt\").is_absolute());\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[allow(deprecated)]\n     pub fn is_absolute(&self) -> bool {\n         self.has_root() && (cfg!(unix) || self.prefix().is_some())\n     }\n@@ -1473,6 +1485,8 @@ impl Path {\n     #[unstable(feature = \"path_prefix\",\n                reason = \"uncertain whether to expose this convenience\",\n                issue = \"27722\")]\n+    #[rustc_deprecated(since = \"1.7.0\",\n+                       reason = \"inspect components().next() instead\")]\n     pub fn prefix(&self) -> Option<Prefix> {\n         self.components().prefix\n     }\n@@ -1561,12 +1575,28 @@ impl Path {\n     /// returns false), then `relative_from` returns `None`.\n     #[unstable(feature = \"path_relative_from\", reason = \"see #23284\",\n                issue = \"23284\")]\n+    #[rustc_deprecated(since = \"1.7.0\", reason = \"renamed to strip_prefix\")]\n     pub fn relative_from<'a, P: ?Sized + AsRef<Path>>(&'a self, base: &'a P) -> Option<&Path> {\n-        self._relative_from(base.as_ref())\n+        self._strip_prefix(base.as_ref()).ok()\n+    }\n+\n+    /// Returns a path that, when joined onto `base`, yields `self`.\n+    ///\n+    /// If `base` is not a prefix of `self` (i.e. `starts_with`\n+    /// returns false), then `relative_from` returns `None`.\n+    #[stable(since = \"1.7.0\", feature = \"path_strip_prefix\")]\n+    pub fn strip_prefix<'a, P: ?Sized>(&'a self, base: &'a P)\n+                                       -> Result<&'a Path, StripPrefixError>\n+        where P: AsRef<Path>\n+    {\n+        self._strip_prefix(base.as_ref())\n     }\n \n-    fn _relative_from<'a>(&'a self, base: &'a Path) -> Option<&'a Path> {\n-        iter_after(self.components(), base.components()).map(|c| c.as_path())\n+    fn _strip_prefix<'a>(&'a self, base: &'a Path)\n+                         -> Result<&'a Path, StripPrefixError> {\n+        iter_after(self.components(), base.components())\n+            .map(|c| c.as_path())\n+            .ok_or(StripPrefixError(()))\n     }\n \n     /// Determines whether `base` is a prefix of `self`.\n@@ -2015,6 +2045,18 @@ impl_eq!(Cow<'a, Path>, Path);\n impl_eq!(Cow<'a, Path>, &'b Path);\n impl_eq!(Cow<'a, Path>, PathBuf);\n \n+#[stable(since = \"1.7.0\", feature = \"strip_prefix\")]\n+impl fmt::Display for StripPrefixError {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        self.description().fmt(f)\n+    }\n+}\n+\n+#[stable(since = \"1.7.0\", feature = \"strip_prefix\")]\n+impl Error for StripPrefixError {\n+    fn description(&self) -> &str { \"prefix not found\" }\n+}\n+\n #[cfg(test)]\n mod tests {\n     use super::*;\n@@ -2105,6 +2147,7 @@ mod tests {\n     );\n \n     #[test]\n+    #[allow(deprecated)]\n     fn into_cow() {\n         use borrow::{Cow, IntoCow};\n "}, {"sha": "9c9aa20eff5c0e292b95a6a368e8c63f9bceaaf1", "filename": "src/libstd/sync/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9a4f43b9b6558ab74b3e849a7770dc193bc1847b/src%2Flibstd%2Fsync%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a4f43b9b6558ab74b3e849a7770dc193bc1847b/src%2Flibstd%2Fsync%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmod.rs?ref=9a4f43b9b6558ab74b3e849a7770dc193bc1847b", "patch": "@@ -39,6 +39,7 @@ pub use self::rwlock::{RwLockReadGuard, RwLockWriteGuard};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use self::rwlock::{RwLock, StaticRwLock, RW_LOCK_INIT};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[allow(deprecated)]\n pub use self::semaphore::{Semaphore, SemaphoreGuard};\n \n pub mod mpsc;"}, {"sha": "8f08c840c218bca20e55765f5138924e90e24439", "filename": "src/libstd/sync/semaphore.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9a4f43b9b6558ab74b3e849a7770dc193bc1847b/src%2Flibstd%2Fsync%2Fsemaphore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a4f43b9b6558ab74b3e849a7770dc193bc1847b/src%2Flibstd%2Fsync%2Fsemaphore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fsemaphore.rs?ref=9a4f43b9b6558ab74b3e849a7770dc193bc1847b", "patch": "@@ -12,6 +12,10 @@\n             reason = \"the interaction between semaphores and the acquisition/release \\\n                       of resources is currently unclear\",\n             issue = \"27798\")]\n+#![rustc_deprecated(since = \"1.7.0\",\n+                    reason = \"easily confused with system sempahores and not \\\n+                              used enough to pull its weight\")]\n+#![allow(deprecated)]\n \n use ops::Drop;\n use sync::{Mutex, Condvar};"}, {"sha": "8d21ba8f661c80f53c5e8d694b8f919c77c11ea2", "filename": "src/libstd/sys/unix/ext/fs.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/9a4f43b9b6558ab74b3e849a7770dc193bc1847b/src%2Flibstd%2Fsys%2Funix%2Fext%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a4f43b9b6558ab74b3e849a7770dc193bc1847b/src%2Flibstd%2Fsys%2Funix%2Fext%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fext%2Ffs.rs?ref=9a4f43b9b6558ab74b3e849a7770dc193bc1847b", "patch": "@@ -23,42 +23,61 @@ use sys;\n use sys_common::{FromInner, AsInner, AsInnerMut};\n \n #[unstable(feature = \"fs_mode\", reason = \"recently added API\", issue = \"27712\")]\n+#[rustc_deprecated(since = \"1.7.0\", reason = \"moved to the libc crate instead\")]\n pub const USER_READ: raw::mode_t = 0o400;\n #[unstable(feature = \"fs_mode\", reason = \"recently added API\", issue = \"27712\")]\n+#[rustc_deprecated(since = \"1.7.0\", reason = \"moved to the libc crate instead\")]\n pub const USER_WRITE: raw::mode_t = 0o200;\n #[unstable(feature = \"fs_mode\", reason = \"recently added API\", issue = \"27712\")]\n+#[rustc_deprecated(since = \"1.7.0\", reason = \"moved to the libc crate instead\")]\n pub const USER_EXECUTE: raw::mode_t = 0o100;\n #[unstable(feature = \"fs_mode\", reason = \"recently added API\", issue = \"27712\")]\n+#[rustc_deprecated(since = \"1.7.0\", reason = \"moved to the libc crate instead\")]\n pub const USER_RWX: raw::mode_t = 0o700;\n #[unstable(feature = \"fs_mode\", reason = \"recently added API\", issue = \"27712\")]\n+#[rustc_deprecated(since = \"1.7.0\", reason = \"moved to the libc crate instead\")]\n pub const GROUP_READ: raw::mode_t = 0o040;\n #[unstable(feature = \"fs_mode\", reason = \"recently added API\", issue = \"27712\")]\n+#[rustc_deprecated(since = \"1.7.0\", reason = \"moved to the libc crate instead\")]\n pub const GROUP_WRITE: raw::mode_t = 0o020;\n #[unstable(feature = \"fs_mode\", reason = \"recently added API\", issue = \"27712\")]\n+#[rustc_deprecated(since = \"1.7.0\", reason = \"moved to the libc crate instead\")]\n pub const GROUP_EXECUTE: raw::mode_t = 0o010;\n #[unstable(feature = \"fs_mode\", reason = \"recently added API\", issue = \"27712\")]\n+#[rustc_deprecated(since = \"1.7.0\", reason = \"moved to the libc crate instead\")]\n pub const GROUP_RWX: raw::mode_t = 0o070;\n #[unstable(feature = \"fs_mode\", reason = \"recently added API\", issue = \"27712\")]\n+#[rustc_deprecated(since = \"1.7.0\", reason = \"moved to the libc crate instead\")]\n pub const OTHER_READ: raw::mode_t = 0o004;\n #[unstable(feature = \"fs_mode\", reason = \"recently added API\", issue = \"27712\")]\n+#[rustc_deprecated(since = \"1.7.0\", reason = \"moved to the libc crate instead\")]\n pub const OTHER_WRITE: raw::mode_t = 0o002;\n #[unstable(feature = \"fs_mode\", reason = \"recently added API\", issue = \"27712\")]\n+#[rustc_deprecated(since = \"1.7.0\", reason = \"moved to the libc crate instead\")]\n pub const OTHER_EXECUTE: raw::mode_t = 0o001;\n #[unstable(feature = \"fs_mode\", reason = \"recently added API\", issue = \"27712\")]\n+#[rustc_deprecated(since = \"1.7.0\", reason = \"moved to the libc crate instead\")]\n pub const OTHER_RWX: raw::mode_t = 0o007;\n #[unstable(feature = \"fs_mode\", reason = \"recently added API\", issue = \"27712\")]\n+#[rustc_deprecated(since = \"1.7.0\", reason = \"moved to the libc crate instead\")]\n pub const ALL_READ: raw::mode_t = 0o444;\n #[unstable(feature = \"fs_mode\", reason = \"recently added API\", issue = \"27712\")]\n+#[rustc_deprecated(since = \"1.7.0\", reason = \"moved to the libc crate instead\")]\n pub const ALL_WRITE: raw::mode_t = 0o222;\n #[unstable(feature = \"fs_mode\", reason = \"recently added API\", issue = \"27712\")]\n+#[rustc_deprecated(since = \"1.7.0\", reason = \"moved to the libc crate instead\")]\n pub const ALL_EXECUTE: raw::mode_t = 0o111;\n #[unstable(feature = \"fs_mode\", reason = \"recently added API\", issue = \"27712\")]\n+#[rustc_deprecated(since = \"1.7.0\", reason = \"moved to the libc crate instead\")]\n pub const ALL_RWX: raw::mode_t = 0o777;\n #[unstable(feature = \"fs_mode\", reason = \"recently added API\", issue = \"27712\")]\n+#[rustc_deprecated(since = \"1.7.0\", reason = \"moved to the libc crate instead\")]\n pub const SETUID: raw::mode_t = 0o4000;\n #[unstable(feature = \"fs_mode\", reason = \"recently added API\", issue = \"27712\")]\n+#[rustc_deprecated(since = \"1.7.0\", reason = \"moved to the libc crate instead\")]\n pub const SETGID: raw::mode_t = 0o2000;\n #[unstable(feature = \"fs_mode\", reason = \"recently added API\", issue = \"27712\")]\n+#[rustc_deprecated(since = \"1.7.0\", reason = \"moved to the libc crate instead\")]\n pub const STICKY_BIT: raw::mode_t = 0o1000;\n \n /// Unix-specific extensions to `Permissions`"}, {"sha": "36a37dba1fa0f7cf4df405b9d520aa7057551805", "filename": "src/rustbook/book.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9a4f43b9b6558ab74b3e849a7770dc193bc1847b/src%2Frustbook%2Fbook.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a4f43b9b6558ab74b3e849a7770dc193bc1847b/src%2Frustbook%2Fbook.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustbook%2Fbook.rs?ref=9a4f43b9b6558ab74b3e849a7770dc193bc1847b", "patch": "@@ -126,9 +126,9 @@ pub fn parse_summary(input: &mut Read, src: &Path) -> Result<Book, Vec<String>>\n         let title = line[start_bracket + 1..end_bracket].to_string();\n         let indent = &line[..star_idx];\n \n-        let path_from_root = match src.join(given_path).relative_from(src) {\n-            Some(p) => p.to_path_buf(),\n-            None => {\n+        let path_from_root = match src.join(given_path).strip_prefix(src) {\n+            Ok(p) => p.to_path_buf(),\n+            Err(..) => {\n                 errors.push(format!(\"paths in SUMMARY.md must be relative, \\\n                                      but path '{}' for section '{}' is not.\",\n                                      given_path, title));"}, {"sha": "e8345dc9586d179f2ac740e5b72b5729787daac3", "filename": "src/rustbook/main.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9a4f43b9b6558ab74b3e849a7770dc193bc1847b/src%2Frustbook%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a4f43b9b6558ab74b3e849a7770dc193bc1847b/src%2Frustbook%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustbook%2Fmain.rs?ref=9a4f43b9b6558ab74b3e849a7770dc193bc1847b", "patch": "@@ -11,7 +11,6 @@\n #![deny(warnings)]\n \n #![feature(iter_arith)]\n-#![feature(path_relative_from)]\n #![feature(rustc_private)]\n #![feature(rustdoc)]\n "}, {"sha": "e1ed21877c9f6e6e19a008a2099679ba71372973", "filename": "src/test/compile-fail/lint-exceeding-bitshifts.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/9a4f43b9b6558ab74b3e849a7770dc193bc1847b/src%2Ftest%2Fcompile-fail%2Flint-exceeding-bitshifts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a4f43b9b6558ab74b3e849a7770dc193bc1847b/src%2Ftest%2Fcompile-fail%2Flint-exceeding-bitshifts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-exceeding-bitshifts.rs?ref=9a4f43b9b6558ab74b3e849a7770dc193bc1847b", "patch": "@@ -11,7 +11,7 @@\n #![deny(exceeding_bitshifts)]\n #![allow(unused_variables)]\n #![allow(dead_code)]\n-#![feature(num_bits_bytes, const_indexing)]\n+#![feature(const_indexing)]\n \n fn main() {\n       let n = 1u8 << 7;\n@@ -57,8 +57,13 @@ fn main() {\n       let n = 1u8 << (4+3);\n       let n = 1u8 << (4+4); //~ ERROR: bitshift exceeds the type's number of bits\n \n-      let n = 1_isize << std::isize::BITS; //~ ERROR: bitshift exceeds the type's number of bits\n-      let n = 1_usize << std::usize::BITS; //~ ERROR: bitshift exceeds the type's number of bits\n+      #[cfg(target_pointer_width = \"32\")]\n+      const BITS: usize = 32;\n+      #[cfg(target_pointer_width = \"64\")]\n+      const BITS: usize = 64;\n+\n+      let n = 1_isize << BITS; //~ ERROR: bitshift exceeds the type's number of bits\n+      let n = 1_usize << BITS; //~ ERROR: bitshift exceeds the type's number of bits\n \n \n       let n = 1i8<<(1isize+-1);"}, {"sha": "c729f736115a9a2a81bcabc412ba817cd1c2233b", "filename": "src/test/run-pass/method-mut-self-modifies-mut-slice-lvalue.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9a4f43b9b6558ab74b3e849a7770dc193bc1847b/src%2Ftest%2Frun-pass%2Fmethod-mut-self-modifies-mut-slice-lvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a4f43b9b6558ab74b3e849a7770dc193bc1847b/src%2Ftest%2Frun-pass%2Fmethod-mut-self-modifies-mut-slice-lvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmethod-mut-self-modifies-mut-slice-lvalue.rs?ref=9a4f43b9b6558ab74b3e849a7770dc193bc1847b", "patch": "@@ -12,17 +12,17 @@\n // type is `&mut [u8]`, passes in a pointer to the lvalue and not a\n // temporary. Issue #19147.\n \n-#![feature(clone_from_slice)]\n-\n use std::slice;\n+use std::cmp;\n \n trait MyWriter {\n     fn my_write(&mut self, buf: &[u8]) -> Result<(), ()>;\n }\n \n impl<'a> MyWriter for &'a mut [u8] {\n     fn my_write(&mut self, buf: &[u8]) -> Result<(), ()> {\n-        self.clone_from_slice(buf);\n+        let amt = cmp::min(self.len(), buf.len());\n+        self[..amt].clone_from_slice(&buf[..amt]);\n \n         let write_len = buf.len();\n         unsafe {"}]}