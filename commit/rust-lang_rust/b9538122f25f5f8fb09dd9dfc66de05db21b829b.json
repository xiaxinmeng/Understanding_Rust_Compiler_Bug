{"sha": "b9538122f25f5f8fb09dd9dfc66de05db21b829b", "node_id": "C_kwDOAAsO6NoAKGI5NTM4MTIyZjI1ZjVmOGZiMDlkZDlkZmM2NmRlMDVkYjIxYjgyOWI", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2022-03-06T16:56:29Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-03-06T16:56:29Z"}, "message": "Merge #11637\n\n11637: minor: Simplify r=Veykril a=Veykril\n\nbors r+\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>", "tree": {"sha": "9b25bf37aa2a968629c0524b069b39094a23a3d5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9b25bf37aa2a968629c0524b069b39094a23a3d5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b9538122f25f5f8fb09dd9dfc66de05db21b829b", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJiJOe9CRBK7hj4Ov3rIwAAePQIAFQM/UeDBQaxjs550ED3b8eg\nzMqb1F8q5zX1ySNd6PO94jdxT+lhUGhqiBuN/r1huIeUsidfFnbHC6kZNbMVPyvf\nVYTkYIdJiwTGlCegLYSM4qRROisatHGXYk7Cjgm325dbSkHoUoz4/XDUBB5iR6ql\nli+geaIYwaJVTa7CFBwXipqHb2tgScsWtj6Gvo7qmeQDUUazNK8HvtFaOt+CEItl\nHX8cEr38xNrNE504RmC2ChyMlKMjxS0B1fJQTed7B1qUjxlaeE+suogkDqCylsWr\ndbEhSilUMTOEMSWgQCzui0iBjbN0/xiLZTHNQ7C4APumIb3HtVZ06ZcSGLQnO/g=\n=00YN\n-----END PGP SIGNATURE-----\n", "payload": "tree 9b25bf37aa2a968629c0524b069b39094a23a3d5\nparent 5b9e46b960c37f04a26742c186e0a26b7bc131b3\nparent c1f91c93b2b92301f4ac9d90fd7f22e9519bbd7b\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1646585789 +0000\ncommitter GitHub <noreply@github.com> 1646585789 +0000\n\nMerge #11637\n\n11637: minor: Simplify r=Veykril a=Veykril\n\nbors r+\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b9538122f25f5f8fb09dd9dfc66de05db21b829b", "html_url": "https://github.com/rust-lang/rust/commit/b9538122f25f5f8fb09dd9dfc66de05db21b829b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b9538122f25f5f8fb09dd9dfc66de05db21b829b/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5b9e46b960c37f04a26742c186e0a26b7bc131b3", "url": "https://api.github.com/repos/rust-lang/rust/commits/5b9e46b960c37f04a26742c186e0a26b7bc131b3", "html_url": "https://github.com/rust-lang/rust/commit/5b9e46b960c37f04a26742c186e0a26b7bc131b3"}, {"sha": "c1f91c93b2b92301f4ac9d90fd7f22e9519bbd7b", "url": "https://api.github.com/repos/rust-lang/rust/commits/c1f91c93b2b92301f4ac9d90fd7f22e9519bbd7b", "html_url": "https://github.com/rust-lang/rust/commit/c1f91c93b2b92301f4ac9d90fd7f22e9519bbd7b"}], "stats": {"total": 160, "additions": 77, "deletions": 83}, "files": [{"sha": "1d8c984d11618020e26d22ef6d6a1ed6363574f4", "filename": "crates/hir/src/semantics/source_to_def.rs", "status": "modified", "additions": 58, "deletions": 66, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/b9538122f25f5f8fb09dd9dfc66de05db21b829b/crates%2Fhir%2Fsrc%2Fsemantics%2Fsource_to_def.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9538122f25f5f8fb09dd9dfc66de05db21b829b/crates%2Fhir%2Fsrc%2Fsemantics%2Fsource_to_def.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fsemantics%2Fsource_to_def.rs?ref=b9538122f25f5f8fb09dd9dfc66de05db21b829b", "patch": "@@ -102,7 +102,7 @@ use smallvec::SmallVec;\n use stdx::impl_from;\n use syntax::{\n     ast::{self, HasName},\n-    match_ast, AstNode, SyntaxNode,\n+    AstNode, SyntaxNode,\n };\n \n use crate::{db::HirDatabase, InFile};\n@@ -132,13 +132,10 @@ impl SourceToDefCtx<'_, '_> {\n \n     pub(super) fn module_to_def(&mut self, src: InFile<ast::Module>) -> Option<ModuleId> {\n         let _p = profile::span(\"module_to_def\");\n-        let parent_declaration =\n-            src.syntax().ancestors_with_macros_skip_attr_item(self.db.upcast()).skip(1).find_map(\n-                |it| {\n-                    let m = ast::Module::cast(it.value.clone())?;\n-                    Some(it.with_value(m))\n-                },\n-            );\n+        let parent_declaration = src\n+            .syntax()\n+            .ancestors_with_macros_skip_attr_item(self.db.upcast())\n+            .find_map(|it| it.map(ast::Module::cast).transpose());\n \n         let parent_module = match parent_declaration {\n             Some(parent_declaration) => self.module_to_def(parent_declaration),\n@@ -150,7 +147,7 @@ impl SourceToDefCtx<'_, '_> {\n \n         let child_name = src.value.name()?.as_name();\n         let def_map = parent_module.def_map(self.db.upcast());\n-        let child_id = *def_map[parent_module.local_id].children.get(&child_name)?;\n+        let &child_id = def_map[parent_module.local_id].children.get(&child_name)?;\n         Some(def_map.module_id(child_id))\n     }\n \n@@ -337,7 +334,7 @@ impl SourceToDefCtx<'_, '_> {\n     }\n \n     pub(super) fn find_container(&mut self, src: InFile<&SyntaxNode>) -> Option<ChildContainer> {\n-        for container in src.ancestors_with_macros_skip_attr_item(self.db.upcast()).skip(1) {\n+        for container in src.ancestors_with_macros_skip_attr_item(self.db.upcast()) {\n             if let Some(res) = self.container_to_def(container) {\n                 return Some(res);\n             }\n@@ -348,85 +345,80 @@ impl SourceToDefCtx<'_, '_> {\n     }\n \n     fn container_to_def(&mut self, container: InFile<SyntaxNode>) -> Option<ChildContainer> {\n-        let cont = match_ast! {\n-            match (container.value) {\n-                ast::Module(it) => {\n-                    let def = self.module_to_def(container.with_value(it))?;\n-                    def.into()\n-                },\n-                ast::Trait(it) => {\n-                    let def = self.trait_to_def(container.with_value(it))?;\n-                    def.into()\n-                },\n-                ast::Impl(it) => {\n-                    let def = self.impl_to_def(container.with_value(it))?;\n-                    def.into()\n-                },\n-                ast::Fn(it) => {\n-                    let def = self.fn_to_def(container.with_value(it))?;\n-                    DefWithBodyId::from(def).into()\n-                },\n-                ast::Struct(it) => {\n+        let cont = if let Some(item) = ast::Item::cast(container.value.clone()) {\n+            match item {\n+                ast::Item::Module(it) => self.module_to_def(container.with_value(it))?.into(),\n+                ast::Item::Trait(it) => self.trait_to_def(container.with_value(it))?.into(),\n+                ast::Item::Impl(it) => self.impl_to_def(container.with_value(it))?.into(),\n+                ast::Item::Enum(it) => self.enum_to_def(container.with_value(it))?.into(),\n+                ast::Item::TypeAlias(it) => {\n+                    self.type_alias_to_def(container.with_value(it))?.into()\n+                }\n+                ast::Item::Struct(it) => {\n                     let def = self.struct_to_def(container.with_value(it))?;\n                     VariantId::from(def).into()\n-                },\n-                ast::Enum(it) => {\n-                    let def = self.enum_to_def(container.with_value(it))?;\n-                    def.into()\n-                },\n-                ast::Union(it) => {\n+                }\n+                ast::Item::Union(it) => {\n                     let def = self.union_to_def(container.with_value(it))?;\n                     VariantId::from(def).into()\n-                },\n-                ast::Static(it) => {\n+                }\n+                ast::Item::Fn(it) => {\n+                    let def = self.fn_to_def(container.with_value(it))?;\n+                    DefWithBodyId::from(def).into()\n+                }\n+                ast::Item::Static(it) => {\n                     let def = self.static_to_def(container.with_value(it))?;\n                     DefWithBodyId::from(def).into()\n-                },\n-                ast::Const(it) => {\n+                }\n+                ast::Item::Const(it) => {\n                     let def = self.const_to_def(container.with_value(it))?;\n                     DefWithBodyId::from(def).into()\n-                },\n-                ast::TypeAlias(it) => {\n-                    let def = self.type_alias_to_def(container.with_value(it))?;\n-                    def.into()\n-                },\n-                ast::Variant(it) => {\n-                    let def = self.enum_variant_to_def(container.with_value(it))?;\n-                    VariantId::from(def).into()\n-                },\n+                }\n                 _ => return None,\n             }\n+        } else {\n+            let it = ast::Variant::cast(container.value)?;\n+            let def = self.enum_variant_to_def(InFile::new(container.file_id, it))?;\n+            VariantId::from(def).into()\n         };\n         Some(cont)\n     }\n \n     fn find_generic_param_container(&mut self, src: InFile<&SyntaxNode>) -> Option<GenericDefId> {\n-        for container in src.ancestors_with_macros_skip_attr_item(self.db.upcast()).skip(1) {\n-            let res: GenericDefId = match_ast! {\n-                match (container.value) {\n-                    ast::Fn(it) => self.fn_to_def(container.with_value(it))?.into(),\n-                    ast::Struct(it) => self.struct_to_def(container.with_value(it))?.into(),\n-                    ast::Enum(it) => self.enum_to_def(container.with_value(it))?.into(),\n-                    ast::Trait(it) => self.trait_to_def(container.with_value(it))?.into(),\n-                    ast::TypeAlias(it) => self.type_alias_to_def(container.with_value(it))?.into(),\n-                    ast::Impl(it) => self.impl_to_def(container.with_value(it))?.into(),\n-                    _ => continue,\n+        let ancestors = src.ancestors_with_macros_skip_attr_item(self.db.upcast());\n+        for InFile { file_id, value } in ancestors {\n+            let item = match ast::Item::cast(value) {\n+                Some(it) => it,\n+                None => continue,\n+            };\n+            let res: GenericDefId = match item {\n+                ast::Item::Fn(it) => self.fn_to_def(InFile::new(file_id, it))?.into(),\n+                ast::Item::Struct(it) => self.struct_to_def(InFile::new(file_id, it))?.into(),\n+                ast::Item::Enum(it) => self.enum_to_def(InFile::new(file_id, it))?.into(),\n+                ast::Item::Trait(it) => self.trait_to_def(InFile::new(file_id, it))?.into(),\n+                ast::Item::TypeAlias(it) => {\n+                    self.type_alias_to_def(InFile::new(file_id, it))?.into()\n                 }\n+                ast::Item::Impl(it) => self.impl_to_def(InFile::new(file_id, it))?.into(),\n+                _ => continue,\n             };\n             return Some(res);\n         }\n         None\n     }\n \n     fn find_pat_or_label_container(&mut self, src: InFile<&SyntaxNode>) -> Option<DefWithBodyId> {\n-        for container in src.ancestors_with_macros_skip_attr_item(self.db.upcast()).skip(1) {\n-            let res: DefWithBodyId = match_ast! {\n-                match (container.value) {\n-                    ast::Const(it) => self.const_to_def(container.with_value(it))?.into(),\n-                    ast::Static(it) => self.static_to_def(container.with_value(it))?.into(),\n-                    ast::Fn(it) => self.fn_to_def(container.with_value(it))?.into(),\n-                    _ => continue,\n-                }\n+        let ancestors = src.ancestors_with_macros_skip_attr_item(self.db.upcast());\n+        for InFile { file_id, value } in ancestors {\n+            let item = match ast::Item::cast(value) {\n+                Some(it) => it,\n+                None => continue,\n+            };\n+            let res: DefWithBodyId = match item {\n+                ast::Item::Const(it) => self.const_to_def(InFile::new(file_id, it))?.into(),\n+                ast::Item::Static(it) => self.static_to_def(InFile::new(file_id, it))?.into(),\n+                ast::Item::Fn(it) => self.fn_to_def(InFile::new(file_id, it))?.into(),\n+                _ => continue,\n             };\n             return Some(res);\n         }"}, {"sha": "f69742971e33a0878bcb9fdf693303779911887a", "filename": "crates/hir_expand/src/builtin_fn_macro.rs", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/b9538122f25f5f8fb09dd9dfc66de05db21b829b/crates%2Fhir_expand%2Fsrc%2Fbuiltin_fn_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9538122f25f5f8fb09dd9dfc66de05db21b829b/crates%2Fhir_expand%2Fsrc%2Fbuiltin_fn_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_expand%2Fsrc%2Fbuiltin_fn_macro.rs?ref=b9538122f25f5f8fb09dd9dfc66de05db21b829b", "patch": "@@ -4,7 +4,10 @@ use base_db::{AnchoredPath, Edition, FileId};\n use cfg::CfgExpr;\n use either::Either;\n use mbe::{parse_exprs_with_sep, parse_to_token_tree};\n-use syntax::ast::{self, AstToken};\n+use syntax::{\n+    ast::{self, AstToken},\n+    SmolStr,\n+};\n \n use crate::{\n     db::AstDatabase, name, quote, AstId, CrateId, ExpandError, ExpandResult, MacroCallId,\n@@ -130,6 +133,9 @@ register_builtin! {\n     (option_env, OptionEnv) => option_env_expand\n }\n \n+const DOLLAR_CRATE: tt::Ident =\n+    tt::Ident { text: SmolStr::new_inline(\"$crate\"), id: tt::TokenId::unspecified() };\n+\n fn module_path_expand(\n     _db: &dyn AstDatabase,\n     _id: MacroCallId,\n@@ -202,7 +208,6 @@ fn assert_expand(\n     _id: MacroCallId,\n     tt: &tt::Subtree,\n ) -> ExpandResult<tt::Subtree> {\n-    let krate = tt::Ident { text: \"$crate\".into(), id: tt::TokenId::unspecified() };\n     let args = parse_exprs_with_sep(tt, ',');\n     let expanded = match &*args {\n         [cond, panic_args @ ..] => {\n@@ -218,7 +223,7 @@ fn assert_expand(\n             let panic_args = itertools::Itertools::intersperse(panic_args.iter().cloned(), comma);\n             quote! {{\n                 if !#cond {\n-                    #krate::panic!(##panic_args);\n+                    #DOLLAR_CRATE::panic!(##panic_args);\n                 }\n             }}\n         }\n@@ -293,15 +298,13 @@ fn asm_expand(\n     // We expand all assembly snippets to `format_args!` invocations to get format syntax\n     // highlighting for them.\n \n-    let krate = tt::Ident { text: \"$crate\".into(), id: tt::TokenId::unspecified() };\n-\n     let mut literals = Vec::new();\n     for tt in tt.token_trees.chunks(2) {\n         match tt {\n             [tt::TokenTree::Leaf(tt::Leaf::Literal(lit))]\n             | [tt::TokenTree::Leaf(tt::Leaf::Literal(lit)), tt::TokenTree::Leaf(tt::Leaf::Punct(tt::Punct { char: ',', id: _, spacing: _ }))] =>\n             {\n-                let krate = krate.clone();\n+                let krate = DOLLAR_CRATE.clone();\n                 literals.push(quote!(#krate::format_args!(#lit);));\n             }\n             _ => break,\n@@ -343,11 +346,10 @@ fn panic_expand(\n ) -> ExpandResult<tt::Subtree> {\n     let loc: MacroCallLoc = db.lookup_intern_macro_call(id);\n     // Expand to a macro call `$crate::panic::panic_{edition}`\n-    let krate = tt::Ident { text: \"$crate\".into(), id: tt::TokenId::unspecified() };\n     let mut call = if db.crate_graph()[loc.krate].edition >= Edition::Edition2021 {\n-        quote!(#krate::panic::panic_2021!)\n+        quote!(#DOLLAR_CRATE::panic::panic_2021!)\n     } else {\n-        quote!(#krate::panic::panic_2015!)\n+        quote!(#DOLLAR_CRATE::panic::panic_2015!)\n     };\n \n     // Pass the original arguments\n@@ -362,11 +364,10 @@ fn unreachable_expand(\n ) -> ExpandResult<tt::Subtree> {\n     let loc: MacroCallLoc = db.lookup_intern_macro_call(id);\n     // Expand to a macro call `$crate::panic::unreachable_{edition}`\n-    let krate = tt::Ident { text: \"$crate\".into(), id: tt::TokenId::unspecified() };\n     let mut call = if db.crate_graph()[loc.krate].edition >= Edition::Edition2021 {\n-        quote!(#krate::panic::unreachable_2021!)\n+        quote!(#DOLLAR_CRATE::panic::unreachable_2021!)\n     } else {\n-        quote!(#krate::panic::unreachable_2015!)\n+        quote!(#DOLLAR_CRATE::panic::unreachable_2015!)\n     };\n \n     // Pass the original arguments"}, {"sha": "99cb493f327dbb2c53bbc03b6e445c44cf231719", "filename": "crates/hir_expand/src/lib.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b9538122f25f5f8fb09dd9dfc66de05db21b829b/crates%2Fhir_expand%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9538122f25f5f8fb09dd9dfc66de05db21b829b/crates%2Fhir_expand%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_expand%2Fsrc%2Flib.rs?ref=b9538122f25f5f8fb09dd9dfc66de05db21b829b", "patch": "@@ -712,7 +712,7 @@ impl<'a> InFile<&'a SyntaxNode> {\n         self,\n         db: &dyn db::AstDatabase,\n     ) -> impl Iterator<Item = InFile<SyntaxNode>> + '_ {\n-        iter::successors(Some(self.cloned()), move |node| match node.value.parent() {\n+        let succ = move |node: &InFile<SyntaxNode>| match node.value.parent() {\n             Some(parent) => Some(node.with_value(parent)),\n             None => {\n                 let parent_node = node.file_id.call_node(db)?;\n@@ -724,7 +724,8 @@ impl<'a> InFile<&'a SyntaxNode> {\n                     Some(parent_node)\n                 }\n             }\n-        })\n+        };\n+        iter::successors(succ(&self.cloned()), succ)\n     }\n \n     /// Falls back to the macro call range if the node cannot be mapped up fully."}, {"sha": "c83193580fb98c4001536a32768ac437fe8a9519", "filename": "crates/ide_db/src/defs.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b9538122f25f5f8fb09dd9dfc66de05db21b829b/crates%2Fide_db%2Fsrc%2Fdefs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9538122f25f5f8fb09dd9dfc66de05db21b829b/crates%2Fide_db%2Fsrc%2Fdefs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fdefs.rs?ref=b9538122f25f5f8fb09dd9dfc66de05db21b829b", "patch": "@@ -150,9 +150,9 @@ impl IdentClass {\n         sema: &Semantics<RootDatabase>,\n         lifetime: &ast::Lifetime,\n     ) -> Option<IdentClass> {\n-        NameClass::classify_lifetime(sema, &lifetime).map(IdentClass::NameClass).or_else(|| {\n-            NameRefClass::classify_lifetime(sema, &lifetime).map(IdentClass::NameRefClass)\n-        })\n+        NameRefClass::classify_lifetime(sema, &lifetime)\n+            .map(IdentClass::NameRefClass)\n+            .or_else(|| NameClass::classify_lifetime(sema, &lifetime).map(IdentClass::NameClass))\n     }\n \n     pub fn definitions(self) -> ArrayVec<Definition, 2> {"}]}