{"sha": "fc3a4058cefc09bebe98039c7fb8d74d1be9c6e6", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZjM2E0MDU4Y2VmYzA5YmViZTk4MDM5YzdmYjhkNzRkMWJlOWM2ZTY=", "commit": {"author": {"name": "max-heller", "email": "max.a.heller@gmail.com", "date": "2021-01-04T01:35:18Z"}, "committer": {"name": "max-heller", "email": "max.a.heller@gmail.com", "date": "2021-01-04T01:45:08Z"}, "message": "still verify disambiguators for primitives", "tree": {"sha": "4b01a2ff50cd2929401bc9227b609041585f4d27", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4b01a2ff50cd2929401bc9227b609041585f4d27"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fc3a4058cefc09bebe98039c7fb8d74d1be9c6e6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fc3a4058cefc09bebe98039c7fb8d74d1be9c6e6", "html_url": "https://github.com/rust-lang/rust/commit/fc3a4058cefc09bebe98039c7fb8d74d1be9c6e6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fc3a4058cefc09bebe98039c7fb8d74d1be9c6e6/comments", "author": {"login": "max-heller", "id": 25730408, "node_id": "MDQ6VXNlcjI1NzMwNDA4", "avatar_url": "https://avatars.githubusercontent.com/u/25730408?v=4", "gravatar_id": "", "url": "https://api.github.com/users/max-heller", "html_url": "https://github.com/max-heller", "followers_url": "https://api.github.com/users/max-heller/followers", "following_url": "https://api.github.com/users/max-heller/following{/other_user}", "gists_url": "https://api.github.com/users/max-heller/gists{/gist_id}", "starred_url": "https://api.github.com/users/max-heller/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/max-heller/subscriptions", "organizations_url": "https://api.github.com/users/max-heller/orgs", "repos_url": "https://api.github.com/users/max-heller/repos", "events_url": "https://api.github.com/users/max-heller/events{/privacy}", "received_events_url": "https://api.github.com/users/max-heller/received_events", "type": "User", "site_admin": false}, "committer": {"login": "max-heller", "id": 25730408, "node_id": "MDQ6VXNlcjI1NzMwNDA4", "avatar_url": "https://avatars.githubusercontent.com/u/25730408?v=4", "gravatar_id": "", "url": "https://api.github.com/users/max-heller", "html_url": "https://github.com/max-heller", "followers_url": "https://api.github.com/users/max-heller/followers", "following_url": "https://api.github.com/users/max-heller/following{/other_user}", "gists_url": "https://api.github.com/users/max-heller/gists{/gist_id}", "starred_url": "https://api.github.com/users/max-heller/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/max-heller/subscriptions", "organizations_url": "https://api.github.com/users/max-heller/orgs", "repos_url": "https://api.github.com/users/max-heller/repos", "events_url": "https://api.github.com/users/max-heller/events{/privacy}", "received_events_url": "https://api.github.com/users/max-heller/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e33a205bdfb0fbbbad80f49e4d39180dc78087bf", "url": "https://api.github.com/repos/rust-lang/rust/commits/e33a205bdfb0fbbbad80f49e4d39180dc78087bf", "html_url": "https://github.com/rust-lang/rust/commit/e33a205bdfb0fbbbad80f49e4d39180dc78087bf"}], "stats": {"total": 104, "additions": 57, "deletions": 47}, "files": [{"sha": "090c45b30ff5fa3afe7ed45dc9e95aeffee46c69", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 57, "deletions": 47, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/fc3a4058cefc09bebe98039c7fb8d74d1be9c6e6/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc3a4058cefc09bebe98039c7fb8d74d1be9c6e6/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=fc3a4058cefc09bebe98039c7fb8d74d1be9c6e6", "patch": "@@ -1146,60 +1146,70 @@ impl LinkCollector<'_, '_> {\n                 callback,\n             );\n         };\n-        match res {\n-            Res::Primitive(_) if self.kind_side_channel.get().is_none() => match disambiguator {\n-                Some(Disambiguator::Primitive | Disambiguator::Namespace(_)) | None => {\n-                    Some(ItemLink { link: ori_link.link, link_text, did: None, fragment })\n-                }\n-                Some(other) => {\n-                    report_mismatch(other, Disambiguator::Primitive);\n-                    None\n-                }\n-            },\n-            Res::Primitive(_) => Some(ItemLink { link: ori_link, link_text, did: None, fragment }),\n-            Res::Def(kind, id) => {\n-                debug!(\"intra-doc link to {} resolved to {:?}\", path_str, res);\n-\n-                // Disallow e.g. linking to enums with `struct@`\n-                debug!(\"saw kind {:?} with disambiguator {:?}\", kind, disambiguator);\n-                match (self.kind_side_channel.take().map(|(kind, _)| kind).unwrap_or(kind), disambiguator) {\n-                    | (DefKind::Const | DefKind::ConstParam | DefKind::AssocConst | DefKind::AnonConst, Some(Disambiguator::Kind(DefKind::Const)))\n-                    // NOTE: this allows 'method' to mean both normal functions and associated functions\n-                    // This can't cause ambiguity because both are in the same namespace.\n-                    | (DefKind::Fn | DefKind::AssocFn, Some(Disambiguator::Kind(DefKind::Fn)))\n-                    // These are namespaces; allow anything in the namespace to match\n-                    | (_, Some(Disambiguator::Namespace(_)))\n-                    // If no disambiguator given, allow anything\n-                    | (_, None)\n-                    // All of these are valid, so do nothing\n-                    => {}\n-                    (actual, Some(Disambiguator::Kind(expected))) if actual == expected => {}\n-                    (_, Some(specified @ Disambiguator::Kind(_) | specified @ Disambiguator::Primitive)) => {\n-                        report_mismatch(specified, Disambiguator::Kind(kind));\n-                        return None;\n+\n+        let (kind, id) = match res {\n+            Res::Primitive(_) => {\n+                if let Some((kind, id)) = self.kind_side_channel.take() {\n+                    (kind, id)\n+                } else {\n+                    match disambiguator {\n+                        Some(Disambiguator::Primitive | Disambiguator::Namespace(_)) | None => {\n+                            return Some(ItemLink {\n+                                link: ori_link.link,\n+                                link_text,\n+                                did: None,\n+                                fragment,\n+                            });\n+                        }\n+                        Some(other) => {\n+                            report_mismatch(other, Disambiguator::Primitive);\n+                            return None;\n+                        }\n                     }\n                 }\n+            }\n+            Res::Def(kind, id) => (kind, id),\n+        };\n \n-                // item can be non-local e.g. when using #[doc(primitive = \"pointer\")]\n-                if let Some((src_id, dst_id)) = id\n-                    .as_local()\n-                    .and_then(|dst_id| item.def_id.as_local().map(|src_id| (src_id, dst_id)))\n-                {\n-                    use rustc_hir::def_id::LOCAL_CRATE;\n+        debug!(\"intra-doc link to {} resolved to {:?}\", path_str, res);\n+\n+        // Disallow e.g. linking to enums with `struct@`\n+        debug!(\"saw kind {:?} with disambiguator {:?}\", kind, disambiguator);\n+        match (self.kind_side_channel.take().map(|(kind, _)| kind).unwrap_or(kind), disambiguator) {\n+            | (DefKind::Const | DefKind::ConstParam | DefKind::AssocConst | DefKind::AnonConst, Some(Disambiguator::Kind(DefKind::Const)))\n+            // NOTE: this allows 'method' to mean both normal functions and associated functions\n+            // This can't cause ambiguity because both are in the same namespace.\n+            | (DefKind::Fn | DefKind::AssocFn, Some(Disambiguator::Kind(DefKind::Fn)))\n+            // These are namespaces; allow anything in the namespace to match\n+            | (_, Some(Disambiguator::Namespace(_)))\n+            // If no disambiguator given, allow anything\n+            | (_, None)\n+            // All of these are valid, so do nothing\n+            => {}\n+            (actual, Some(Disambiguator::Kind(expected))) if actual == expected => {}\n+            (_, Some(specified @ Disambiguator::Kind(_) | specified @ Disambiguator::Primitive)) => {\n+                report_mismatch(specified, Disambiguator::Kind(kind));\n+                return None;\n+            }\n+        }\n \n-                    let hir_src = self.cx.tcx.hir().local_def_id_to_hir_id(src_id);\n-                    let hir_dst = self.cx.tcx.hir().local_def_id_to_hir_id(dst_id);\n+        // item can be non-local e.g. when using #[doc(primitive = \"pointer\")]\n+        if let Some((src_id, dst_id)) =\n+            id.as_local().and_then(|dst_id| item.def_id.as_local().map(|src_id| (src_id, dst_id)))\n+        {\n+            use rustc_hir::def_id::LOCAL_CRATE;\n \n-                    if self.cx.tcx.privacy_access_levels(LOCAL_CRATE).is_exported(hir_src)\n-                        && !self.cx.tcx.privacy_access_levels(LOCAL_CRATE).is_exported(hir_dst)\n-                    {\n-                        privacy_error(cx, &item, &path_str, dox, &ori_link);\n-                    }\n-                }\n-                let id = clean::register_res(cx, rustc_hir::def::Res::Def(kind, id));\n-                Some(ItemLink { link: ori_link.link, link_text, did: Some(id), fragment })\n+            let hir_src = self.cx.tcx.hir().local_def_id_to_hir_id(src_id);\n+            let hir_dst = self.cx.tcx.hir().local_def_id_to_hir_id(dst_id);\n+\n+            if self.cx.tcx.privacy_access_levels(LOCAL_CRATE).is_exported(hir_src)\n+                && !self.cx.tcx.privacy_access_levels(LOCAL_CRATE).is_exported(hir_dst)\n+            {\n+                privacy_error(cx, &item, &path_str, dox, &ori_link);\n             }\n         }\n+        let id = clean::register_res(cx, rustc_hir::def::Res::Def(kind, id));\n+        Some(ItemLink { link: ori_link.link, link_text, did: Some(id), fragment })\n     }\n \n     fn resolve_with_disambiguator_cached("}]}