{"sha": "549756bef89fa7f9e39cf5e3d04553076ca952ae", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU0OTc1NmJlZjg5ZmE3ZjllMzljZjVlM2QwNDU1MzA3NmNhOTUyYWU=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-09-15T18:54:38Z"}, "committer": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-09-16T01:13:02Z"}, "message": "or-patterns: check_match: nix `top_pats_hack` passed to `check_patterns`.", "tree": {"sha": "5e51aea546eaa40e1c987bda4113af5e96f7abb2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5e51aea546eaa40e1c987bda4113af5e96f7abb2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/549756bef89fa7f9e39cf5e3d04553076ca952ae", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/549756bef89fa7f9e39cf5e3d04553076ca952ae", "html_url": "https://github.com/rust-lang/rust/commit/549756bef89fa7f9e39cf5e3d04553076ca952ae", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/549756bef89fa7f9e39cf5e3d04553076ca952ae/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6bd8c6d4f44884a756471dda6ff3e5c66dbbd042", "url": "https://api.github.com/repos/rust-lang/rust/commits/6bd8c6d4f44884a756471dda6ff3e5c66dbbd042", "html_url": "https://github.com/rust-lang/rust/commit/6bd8c6d4f44884a756471dda6ff3e5c66dbbd042"}], "stats": {"total": 70, "additions": 30, "deletions": 40}, "files": [{"sha": "6301d9c390b028c9c910b08a67d0b6b820c4f222", "filename": "src/librustc_mir/hair/pattern/check_match.rs", "status": "modified", "additions": 30, "deletions": 40, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/549756bef89fa7f9e39cf5e3d04553076ca952ae/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/549756bef89fa7f9e39cf5e3d04553076ca952ae/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs?ref=549756bef89fa7f9e39cf5e3d04553076ca952ae", "patch": "@@ -14,7 +14,6 @@ use rustc_errors::{Applicability, DiagnosticBuilder};\n use rustc::hir::def::*;\n use rustc::hir::def_id::DefId;\n use rustc::hir::intravisit::{self, Visitor, NestedVisitorMap};\n-use rustc::hir::ptr::P;\n use rustc::hir::{self, Pat, PatKind};\n \n use smallvec::smallvec;\n@@ -76,15 +75,15 @@ impl<'tcx> Visitor<'tcx> for MatchVisitor<'_, 'tcx> {\n         });\n \n         // Check legality of move bindings and `@` patterns.\n-        self.check_patterns(false, slice::from_ref(&loc.pat));\n+        self.check_patterns(false, &loc.pat);\n     }\n \n     fn visit_body(&mut self, body: &'tcx hir::Body) {\n         intravisit::walk_body(self, body);\n \n         for param in &body.params {\n             self.check_irrefutable(&param.pat, \"function argument\");\n-            self.check_patterns(false, slice::from_ref(&param.pat));\n+            self.check_patterns(false, &param.pat);\n         }\n     }\n }\n@@ -122,11 +121,9 @@ impl PatternContext<'_, '_> {\n }\n \n impl<'tcx> MatchVisitor<'_, 'tcx> {\n-    fn check_patterns(&mut self, has_guard: bool, pats: &[P<Pat>]) {\n-        check_legality_of_move_bindings(self, has_guard, pats);\n-        for pat in pats {\n-            check_legality_of_bindings_in_at_patterns(self, pat);\n-        }\n+    fn check_patterns(&mut self, has_guard: bool, pat: &Pat) {\n+        check_legality_of_move_bindings(self, has_guard, pat);\n+        check_legality_of_bindings_in_at_patterns(self, pat);\n     }\n \n     fn check_match(\n@@ -137,7 +134,7 @@ impl<'tcx> MatchVisitor<'_, 'tcx> {\n     ) {\n         for arm in arms {\n             // First, check legality of move bindings.\n-            self.check_patterns(arm.guard.is_some(), &arm.top_pats_hack());\n+            self.check_patterns(arm.guard.is_some(), &arm.pat);\n \n             // Second, if there is a guard on each arm, make sure it isn't\n             // assigning or borrowing anything mutably.\n@@ -543,24 +540,18 @@ fn maybe_point_at_variant(ty: Ty<'_>, patterns: &[Pattern<'_>]) -> Vec<Span> {\n     covered\n }\n \n-// Legality of move bindings checking\n-fn check_legality_of_move_bindings(\n-    cx: &mut MatchVisitor<'_, '_>,\n-    has_guard: bool,\n-    pats: &[P<Pat>],\n-) {\n+// Check the legality of legality of by-move bindings.\n+fn check_legality_of_move_bindings(cx: &mut MatchVisitor<'_, '_>, has_guard: bool, pat: &Pat) {\n     let mut by_ref_span = None;\n-    for pat in pats {\n-        pat.each_binding(|_, hir_id, span, _path| {\n-            if let Some(&bm) = cx.tables.pat_binding_modes().get(hir_id) {\n-                if let ty::BindByReference(..) = bm {\n-                    by_ref_span = Some(span);\n-                }\n-            } else {\n-                cx.tcx.sess.delay_span_bug(pat.span, \"missing binding mode\");\n+    pat.each_binding(|_, hir_id, span, _| {\n+        if let Some(&bm) = cx.tables.pat_binding_modes().get(hir_id) {\n+            if let ty::BindByReference(..) = bm {\n+                by_ref_span = Some(span);\n             }\n-        })\n-    }\n+        } else {\n+            cx.tcx.sess.delay_span_bug(pat.span, \"missing binding mode\");\n+        }\n+    });\n \n     let span_vec = &mut Vec::new();\n     let mut check_move = |p: &Pat, sub: Option<&Pat>| {\n@@ -576,23 +567,22 @@ fn check_legality_of_move_bindings(\n         }\n     };\n \n-    for pat in pats {\n-        pat.walk(|p| {\n-            if let PatKind::Binding(.., sub) = &p.node {\n-                if let Some(&bm) = cx.tables.pat_binding_modes().get(p.hir_id) {\n-                    if let ty::BindByValue(..) = bm {\n-                        let pat_ty = cx.tables.node_type(p.hir_id);\n-                        if !pat_ty.is_copy_modulo_regions(cx.tcx, cx.param_env, pat.span) {\n-                            check_move(p, sub.as_deref());\n-                        }\n+    pat.walk(|p| {\n+        if let PatKind::Binding(.., sub) = &p.node {\n+            if let Some(&bm) = cx.tables.pat_binding_modes().get(p.hir_id) {\n+                if let ty::BindByValue(..) = bm {\n+                    let pat_ty = cx.tables.node_type(p.hir_id);\n+                    if !pat_ty.is_copy_modulo_regions(cx.tcx, cx.param_env, pat.span) {\n+                        check_move(p, sub.as_deref());\n                     }\n-                } else {\n-                    cx.tcx.sess.delay_span_bug(pat.span, \"missing binding mode\");\n                 }\n+            } else {\n+                cx.tcx.sess.delay_span_bug(pat.span, \"missing binding mode\");\n             }\n-            true\n-        });\n-    }\n+        }\n+        true\n+    });\n+\n     if !span_vec.is_empty() {\n         let mut err = struct_span_err!(\n             cx.tcx.sess,\n@@ -603,7 +593,7 @@ fn check_legality_of_move_bindings(\n         if let Some(by_ref_span) = by_ref_span {\n             err.span_label(by_ref_span, \"both by-ref and by-move used\");\n         }\n-        for span in span_vec.iter(){\n+        for span in span_vec.iter() {\n             err.span_label(*span, \"by-move pattern here\");\n         }\n         err.emit();"}]}