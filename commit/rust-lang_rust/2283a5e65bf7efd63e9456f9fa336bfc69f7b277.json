{"sha": "2283a5e65bf7efd63e9456f9fa336bfc69f7b277", "node_id": "C_kwDOAAsO6NoAKDIyODNhNWU2NWJmN2VmZDYzZTk0NTZmOWZhMzM2YmZjNjlmN2IyNzc", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2022-10-25T12:13:02Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2022-10-25T14:11:50Z"}, "message": "rustc_metadata: Add constructors to module children at encoding time\n\ninstead of decoding time.", "tree": {"sha": "3edd11271a9371854e59b3820f240e7b9b6a7d2c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3edd11271a9371854e59b3820f240e7b9b6a7d2c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2283a5e65bf7efd63e9456f9fa336bfc69f7b277", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2283a5e65bf7efd63e9456f9fa336bfc69f7b277", "html_url": "https://github.com/rust-lang/rust/commit/2283a5e65bf7efd63e9456f9fa336bfc69f7b277", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2283a5e65bf7efd63e9456f9fa336bfc69f7b277/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c6bd7e21c6239f4bcc3892ead298641ec1422f20", "url": "https://api.github.com/repos/rust-lang/rust/commits/c6bd7e21c6239f4bcc3892ead298641ec1422f20", "html_url": "https://github.com/rust-lang/rust/commit/c6bd7e21c6239f4bcc3892ead298641ec1422f20"}], "stats": {"total": 103, "additions": 53, "deletions": 50}, "files": [{"sha": "691e3d0f8f9026aafc0b2fde5040962be4e7e1fe", "filename": "compiler/rustc_metadata/src/rmeta/decoder.rs", "status": "modified", "additions": 35, "deletions": 44, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/2283a5e65bf7efd63e9456f9fa336bfc69f7b277/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2283a5e65bf7efd63e9456f9fa336bfc69f7b277/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs?ref=2283a5e65bf7efd63e9456f9fa336bfc69f7b277", "patch": "@@ -773,7 +773,15 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n     }\n \n     fn opt_item_name(self, item_index: DefIndex) -> Option<Symbol> {\n-        self.def_key(item_index).disambiguated_data.data.get_opt_name()\n+        let def_key = self.def_key(item_index);\n+        def_key.disambiguated_data.data.get_opt_name().or_else(|| {\n+            if def_key.disambiguated_data.data == DefPathData::Ctor {\n+                let parent_index = def_key.parent.expect(\"no parent for a constructor\");\n+                self.def_key(parent_index).disambiguated_data.data.get_opt_name()\n+            } else {\n+                None\n+            }\n+        })\n     }\n \n     fn item_name(self, item_index: DefIndex) -> Symbol {\n@@ -905,7 +913,13 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n                 .get(self, item_id)\n                 .unwrap_or_else(LazyArray::empty)\n                 .decode(self)\n-                .map(|index| self.get_variant(&self.def_kind(index), index, did))\n+                .filter_map(|index| {\n+                    let kind = self.def_kind(index);\n+                    match kind {\n+                        DefKind::Ctor(..) => None,\n+                        _ => Some(self.get_variant(&kind, index, did)),\n+                    }\n+                })\n                 .collect()\n         } else {\n             std::iter::once(self.get_variant(&kind, item_id, did)).collect()\n@@ -1029,50 +1043,27 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n \n                 callback(ModChild { ident, res, vis, span, macro_rules });\n \n-                // For non-re-export structs and variants add their constructors to children.\n-                // Re-export lists automatically contain constructors when necessary.\n-                match kind {\n-                    DefKind::Struct => {\n-                        if let Some((ctor_def_id, ctor_kind)) =\n-                            self.get_ctor_def_id_and_kind(child_index)\n-                        {\n-                            let ctor_res =\n-                                Res::Def(DefKind::Ctor(CtorOf::Struct, ctor_kind), ctor_def_id);\n-                            let vis = self.get_visibility(ctor_def_id.index);\n-                            callback(ModChild {\n-                                ident,\n-                                res: ctor_res,\n-                                vis,\n-                                span,\n-                                macro_rules: false,\n-                            });\n-                        }\n-                    }\n-                    DefKind::Variant => {\n-                        // Braced variants, unlike structs, generate unusable names in\n-                        // value namespace, they are reserved for possible future use.\n-                        // It's ok to use the variant's id as a ctor id since an\n-                        // error will be reported on any use of such resolution anyway.\n-                        let (ctor_def_id, ctor_kind) = self\n-                            .get_ctor_def_id_and_kind(child_index)\n-                            .unwrap_or((def_id, CtorKind::Fictive));\n-                        let ctor_res =\n-                            Res::Def(DefKind::Ctor(CtorOf::Variant, ctor_kind), ctor_def_id);\n-                        let mut vis = self.get_visibility(ctor_def_id.index);\n-                        if ctor_def_id == def_id && vis.is_public() {\n-                            // For non-exhaustive variants lower the constructor visibility to\n-                            // within the crate. We only need this for fictive constructors,\n-                            // for other constructors correct visibilities\n-                            // were already encoded in metadata.\n-                            let mut attrs = self.get_item_attrs(def_id.index, sess);\n-                            if attrs.any(|item| item.has_name(sym::non_exhaustive)) {\n-                                let crate_def_id = self.local_def_id(CRATE_DEF_INDEX);\n-                                vis = ty::Visibility::Restricted(crate_def_id);\n-                            }\n+                // For non-reexport variants add their fictive constructors to children.\n+                // Braced variants, unlike structs, generate unusable names in value namespace,\n+                // they are reserved for possible future use. It's ok to use the variant's id as\n+                // a ctor id since an error will be reported on any use of such resolution anyway.\n+                // Reexport lists automatically contain such constructors when necessary.\n+                if kind == DefKind::Variant && self.get_ctor_def_id_and_kind(child_index).is_none()\n+                {\n+                    let ctor_res =\n+                        Res::Def(DefKind::Ctor(CtorOf::Variant, CtorKind::Fictive), def_id);\n+                    let mut vis = vis;\n+                    if vis.is_public() {\n+                        // For non-exhaustive variants lower the constructor visibility to\n+                        // within the crate. We only need this for fictive constructors,\n+                        // for other constructors correct visibilities\n+                        // were already encoded in metadata.\n+                        let mut attrs = self.get_item_attrs(def_id.index, sess);\n+                        if attrs.any(|item| item.has_name(sym::non_exhaustive)) {\n+                            vis = ty::Visibility::Restricted(self.local_def_id(CRATE_DEF_INDEX));\n                         }\n-                        callback(ModChild { ident, res: ctor_res, vis, span, macro_rules: false });\n                     }\n-                    _ => {}\n+                    callback(ModChild { ident, res: ctor_res, vis, span, macro_rules: false });\n                 }\n             }\n         }"}, {"sha": "61e84a5a01ddbc5500885c0b3bd96ccc4f9fcefa", "filename": "compiler/rustc_metadata/src/rmeta/encoder.rs", "status": "modified", "additions": 18, "deletions": 6, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/2283a5e65bf7efd63e9456f9fa336bfc69f7b277/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2283a5e65bf7efd63e9456f9fa336bfc69f7b277/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs?ref=2283a5e65bf7efd63e9456f9fa336bfc69f7b277", "patch": "@@ -1335,6 +1335,13 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                         // Only encode named non-reexport children, reexports are encoded\n                         // separately and unnamed items are not used by name resolution.\n                         hir::ItemKind::ExternCrate(..) => continue,\n+                        hir::ItemKind::Struct(ref vdata, _) => {\n+                            yield item_id.def_id.def_id.local_def_index;\n+                            // Encode constructors which take a separate slot in value namespace.\n+                            if let Some(ctor_hir_id) = vdata.ctor_hir_id() {\n+                                yield tcx.hir().local_def_id(ctor_hir_id).local_def_index;\n+                            }\n+                        }\n                         _ if tcx.def_key(item_id.def_id.to_def_id()).get_opt_name().is_some() => {\n                             yield item_id.def_id.def_id.local_def_index;\n                         }\n@@ -1646,12 +1653,17 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         };\n         // FIXME(eddyb) there should be a nicer way to do this.\n         match item.kind {\n-            hir::ItemKind::Enum(..) => record_array!(self.tables.children[def_id] <-\n-                self.tcx.adt_def(def_id).variants().iter().map(|v| {\n-                    assert!(v.def_id.is_local());\n-                    v.def_id.index\n-                })\n-            ),\n+            hir::ItemKind::Enum(..) => {\n+                record_array!(self.tables.children[def_id] <- iter::from_generator(||\n+                    for variant in tcx.adt_def(def_id).variants() {\n+                        yield variant.def_id.index;\n+                        // Encode constructors which take a separate slot in value namespace.\n+                        if let Some(ctor_def_id) = variant.ctor_def_id {\n+                            yield ctor_def_id.index;\n+                        }\n+                    }\n+                ))\n+            }\n             hir::ItemKind::Struct(..) | hir::ItemKind::Union(..) => {\n                 record_array!(self.tables.children[def_id] <-\n                     self.tcx.adt_def(def_id).non_enum_variant().fields.iter().map(|f| {"}]}