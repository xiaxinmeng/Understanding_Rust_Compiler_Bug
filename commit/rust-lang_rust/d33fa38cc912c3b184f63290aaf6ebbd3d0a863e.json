{"sha": "d33fa38cc912c3b184f63290aaf6ebbd3d0a863e", "node_id": "C_kwDOAAsO6NoAKGQzM2ZhMzhjYzkxMmMzYjE4NGY2MzI5MGFhZjZlYmJkM2QwYTg2M2U", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-01-09T14:37:40Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-01-09T14:37:40Z"}, "message": "Auto merge of #13825 - WaffleLapkin:ufcs_to_method_call_and_back, r=Veykril\n\nfeat: Add `unqualify_method_call` assist\n\n...which is the inverse of `qualify_method_call` assist.\n\n![Peek 2022-12-22 22-47](https://user-images.githubusercontent.com/38225716/209206554-8f067206-6fa6-48f8-849e-f6d36ee2e5a1.gif)\n\nOptional future work:\n- import the trait if needed\n- remove excess references when auto-ref is possible", "tree": {"sha": "5f529344d1ac8ef0fea438dbd6684c95d330e018", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5f529344d1ac8ef0fea438dbd6684c95d330e018"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d33fa38cc912c3b184f63290aaf6ebbd3d0a863e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d33fa38cc912c3b184f63290aaf6ebbd3d0a863e", "html_url": "https://github.com/rust-lang/rust/commit/d33fa38cc912c3b184f63290aaf6ebbd3d0a863e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d33fa38cc912c3b184f63290aaf6ebbd3d0a863e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "336608aa924e1dfe38810997f81368a2d5df1213", "url": "https://api.github.com/repos/rust-lang/rust/commits/336608aa924e1dfe38810997f81368a2d5df1213", "html_url": "https://github.com/rust-lang/rust/commit/336608aa924e1dfe38810997f81368a2d5df1213"}, {"sha": "c782353a907ea121dcae670a5f0d8e14b8865b19", "url": "https://api.github.com/repos/rust-lang/rust/commits/c782353a907ea121dcae670a5f0d8e14b8865b19", "html_url": "https://github.com/rust-lang/rust/commit/c782353a907ea121dcae670a5f0d8e14b8865b19"}], "stats": {"total": 232, "additions": 232, "deletions": 0}, "files": [{"sha": "e9d4e270cdcfb8c93f5bada2a50fc74ce5763492", "filename": "crates/ide-assists/src/handlers/unqualify_method_call.rs", "status": "added", "additions": 211, "deletions": 0, "changes": 211, "blob_url": "https://github.com/rust-lang/rust/blob/d33fa38cc912c3b184f63290aaf6ebbd3d0a863e/crates%2Fide-assists%2Fsrc%2Fhandlers%2Funqualify_method_call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d33fa38cc912c3b184f63290aaf6ebbd3d0a863e/crates%2Fide-assists%2Fsrc%2Fhandlers%2Funqualify_method_call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Funqualify_method_call.rs?ref=d33fa38cc912c3b184f63290aaf6ebbd3d0a863e", "patch": "@@ -0,0 +1,211 @@\n+use syntax::{\n+    ast::{self, make, AstNode, HasArgList},\n+    TextRange,\n+};\n+\n+use crate::{AssistContext, AssistId, AssistKind, Assists};\n+\n+// Assist: unqualify_method_call\n+//\n+// Transforms universal function call syntax into a method call.\n+//\n+// ```\n+// fn main() {\n+//     std::ops::Add::add$0(1, 2);\n+// }\n+// # mod std { pub mod ops { pub trait Add { fn add(self, _: Self) {} } impl Add for i32 {} } }\n+// ```\n+// ->\n+// ```\n+// fn main() {\n+//     1.add(2);\n+// }\n+// # mod std { pub mod ops { pub trait Add { fn add(self, _: Self) {} } impl Add for i32 {} } }\n+// ```\n+pub(crate) fn unqualify_method_call(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {\n+    let call = ctx.find_node_at_offset::<ast::CallExpr>()?;\n+    let ast::Expr::PathExpr(path_expr) = call.expr()? else { return None };\n+    let path = path_expr.path()?;\n+\n+    let cursor_in_range = path.syntax().text_range().contains_range(ctx.selection_trimmed());\n+    if !cursor_in_range {\n+        return None;\n+    }\n+\n+    let args = call.arg_list()?;\n+    let l_paren = args.l_paren_token()?;\n+    let mut args_iter = args.args();\n+    let first_arg = args_iter.next()?;\n+    let second_arg = args_iter.next();\n+\n+    _ = path.qualifier()?;\n+    let method_name = path.segment()?.name_ref()?;\n+\n+    let res = ctx.sema.resolve_path(&path)?;\n+    let hir::PathResolution::Def(hir::ModuleDef::Function(fun)) = res else { return None };\n+    if !fun.has_self_param(ctx.sema.db) {\n+        return None;\n+    }\n+\n+    // `core::ops::Add::add(` -> ``\n+    let delete_path =\n+        TextRange::new(path.syntax().text_range().start(), l_paren.text_range().end());\n+\n+    // Parens around `expr` if needed\n+    let parens = needs_parens_as_receiver(&first_arg).then(|| {\n+        let range = first_arg.syntax().text_range();\n+        (range.start(), range.end())\n+    });\n+\n+    // `, ` -> `.add(`\n+    let replace_comma = TextRange::new(\n+        first_arg.syntax().text_range().end(),\n+        second_arg\n+            .map(|a| a.syntax().text_range().start())\n+            .unwrap_or_else(|| first_arg.syntax().text_range().end()),\n+    );\n+\n+    acc.add(\n+        AssistId(\"unqualify_method_call\", AssistKind::RefactorRewrite),\n+        \"Unqualify method call\",\n+        call.syntax().text_range(),\n+        |edit| {\n+            edit.delete(delete_path);\n+            if let Some((open, close)) = parens {\n+                edit.insert(open, \"(\");\n+                edit.insert(close, \")\");\n+            }\n+            edit.replace(replace_comma, format!(\".{method_name}(\"));\n+        },\n+    )\n+}\n+\n+fn needs_parens_as_receiver(expr: &ast::Expr) -> bool {\n+    // Make `(expr).dummy()`\n+    let dummy_call = make::expr_method_call(\n+        make::expr_paren(expr.clone()),\n+        make::name_ref(\"dummy\"),\n+        make::arg_list([]),\n+    );\n+\n+    // Get the `expr` clone with the right parent back\n+    // (unreachable!s are fine since we've just constructed the expression)\n+    let ast::Expr::MethodCallExpr(call) = &dummy_call else { unreachable!() };\n+    let Some(receiver) = call.receiver() else { unreachable!() };\n+    let ast::Expr::ParenExpr(parens) = receiver else { unreachable!() };\n+    let Some(expr) = parens.expr() else { unreachable!() };\n+\n+    expr.needs_parens_in(dummy_call.syntax().clone())\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use crate::tests::{check_assist, check_assist_not_applicable};\n+\n+    use super::*;\n+\n+    #[test]\n+    fn unqualify_method_call_simple() {\n+        check_assist(\n+            unqualify_method_call,\n+            r#\"\n+struct S;\n+impl S { fn f(self, S: S) {} }\n+fn f() { S::$0f(S, S); }\"#,\n+            r#\"\n+struct S;\n+impl S { fn f(self, S: S) {} }\n+fn f() { S.f(S); }\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn unqualify_method_call_trait() {\n+        check_assist(\n+            unqualify_method_call,\n+            r#\"\n+//- minicore: add\n+fn f() { <u32 as core::ops::Add>::$0add(2, 2); }\"#,\n+            r#\"\n+fn f() { 2.add(2); }\"#,\n+        );\n+\n+        check_assist(\n+            unqualify_method_call,\n+            r#\"\n+//- minicore: add\n+fn f() { core::ops::Add::$0add(2, 2); }\"#,\n+            r#\"\n+fn f() { 2.add(2); }\"#,\n+        );\n+\n+        check_assist(\n+            unqualify_method_call,\n+            r#\"\n+//- minicore: add\n+use core::ops::Add;\n+fn f() { <_>::$0add(2, 2); }\"#,\n+            r#\"\n+use core::ops::Add;\n+fn f() { 2.add(2); }\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn unqualify_method_call_single_arg() {\n+        check_assist(\n+            unqualify_method_call,\n+            r#\"\n+        struct S;\n+        impl S { fn f(self) {} }\n+        fn f() { S::$0f(S); }\"#,\n+            r#\"\n+        struct S;\n+        impl S { fn f(self) {} }\n+        fn f() { S.f(); }\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn unqualify_method_call_parens() {\n+        check_assist(\n+            unqualify_method_call,\n+            r#\"\n+//- minicore: deref\n+struct S;\n+impl core::ops::Deref for S {\n+    type Target = S;\n+    fn deref(&self) -> &S { self }\n+}\n+fn f() { core::ops::Deref::$0deref(&S); }\"#,\n+            r#\"\n+struct S;\n+impl core::ops::Deref for S {\n+    type Target = S;\n+    fn deref(&self) -> &S { self }\n+}\n+fn f() { (&S).deref(); }\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn unqualify_method_call_doesnt_apply_with_cursor_not_on_path() {\n+        check_assist_not_applicable(\n+            unqualify_method_call,\n+            r#\"\n+//- minicore: add\n+fn f() { core::ops::Add::add(2,$0 2); }\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn unqualify_method_call_doesnt_apply_with_no_self() {\n+        check_assist_not_applicable(\n+            unqualify_method_call,\n+            r#\"\n+struct S;\n+impl S { fn assoc(S: S, S: S) {} }\n+fn f() { S::assoc$0(S, S); }\"#,\n+        );\n+    }\n+}"}, {"sha": "7813c9f9cbe801eb2b3fd99bf32b311aaa382074", "filename": "crates/ide-assists/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d33fa38cc912c3b184f63290aaf6ebbd3d0a863e/crates%2Fide-assists%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d33fa38cc912c3b184f63290aaf6ebbd3d0a863e/crates%2Fide-assists%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Flib.rs?ref=d33fa38cc912c3b184f63290aaf6ebbd3d0a863e", "patch": "@@ -202,6 +202,7 @@ mod handlers {\n     mod unnecessary_async;\n     mod unwrap_block;\n     mod unwrap_result_return_type;\n+    mod unqualify_method_call;\n     mod wrap_return_type_in_result;\n \n     pub(crate) fn all() -> &'static [Handler] {\n@@ -308,6 +309,7 @@ mod handlers {\n             unwrap_block::unwrap_block,\n             unwrap_result_return_type::unwrap_result_return_type,\n             unwrap_tuple::unwrap_tuple,\n+            unqualify_method_call::unqualify_method_call,\n             wrap_return_type_in_result::wrap_return_type_in_result,\n             // These are manually sorted for better priorities. By default,\n             // priority is determined by the size of the target range (smaller"}, {"sha": "006ae4b3034180a32b2514d457c4b0bd96f356df", "filename": "crates/ide-assists/src/tests/generated.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/d33fa38cc912c3b184f63290aaf6ebbd3d0a863e/crates%2Fide-assists%2Fsrc%2Ftests%2Fgenerated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d33fa38cc912c3b184f63290aaf6ebbd3d0a863e/crates%2Fide-assists%2Fsrc%2Ftests%2Fgenerated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Ftests%2Fgenerated.rs?ref=d33fa38cc912c3b184f63290aaf6ebbd3d0a863e", "patch": "@@ -2566,6 +2566,25 @@ pub async fn bar() { foo() }\n     )\n }\n \n+#[test]\n+fn doctest_unqualify_method_call() {\n+    check_doc_test(\n+        \"unqualify_method_call\",\n+        r#####\"\n+fn main() {\n+    std::ops::Add::add$0(1, 2);\n+}\n+mod std { pub mod ops { pub trait Add { fn add(self, _: Self) {} } impl Add for i32 {} } }\n+\"#####,\n+        r#####\"\n+fn main() {\n+    1.add(2);\n+}\n+mod std { pub mod ops { pub trait Add { fn add(self, _: Self) {} } impl Add for i32 {} } }\n+\"#####,\n+    )\n+}\n+\n #[test]\n fn doctest_unwrap_block() {\n     check_doc_test("}]}