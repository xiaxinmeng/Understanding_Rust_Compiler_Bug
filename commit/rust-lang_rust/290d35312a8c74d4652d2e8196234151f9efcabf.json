{"sha": "290d35312a8c74d4652d2e8196234151f9efcabf", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI5MGQzNTMxMmE4Yzc0ZDQ2NTJkMmU4MTk2MjM0MTUxZjllZmNhYmY=", "commit": {"author": {"name": "Michael Woerister", "email": "michaelwoerister@gmail", "date": "2013-06-18T11:06:41Z"}, "committer": {"name": "Michael Woerister", "email": "michaelwoerister@gmail", "date": "2013-06-20T09:50:09Z"}, "message": "Reordered debuginfo.rs and commented public fns", "tree": {"sha": "a66bb14d809b637a3a7fd6e9701ea147b64450dc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a66bb14d809b637a3a7fd6e9701ea147b64450dc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/290d35312a8c74d4652d2e8196234151f9efcabf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/290d35312a8c74d4652d2e8196234151f9efcabf", "html_url": "https://github.com/rust-lang/rust/commit/290d35312a8c74d4652d2e8196234151f9efcabf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/290d35312a8c74d4652d2e8196234151f9efcabf/comments", "author": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "committer": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f1bd3e7ca2c5094c1e197c3276e5759ce0e73b91", "url": "https://api.github.com/repos/rust-lang/rust/commits/f1bd3e7ca2c5094c1e197c3276e5759ce0e73b91", "html_url": "https://github.com/rust-lang/rust/commit/f1bd3e7ca2c5094c1e197c3276e5759ce0e73b91"}], "stats": {"total": 435, "additions": 240, "deletions": 195}, "files": [{"sha": "a5dd89a1cbc006a39b152973994de68e9a890ed2", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 240, "deletions": 195, "changes": 435, "blob_url": "https://github.com/rust-lang/rust/blob/290d35312a8c74d4652d2e8196234151f9efcabf/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/290d35312a8c74d4652d2e8196234151f9efcabf/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=290d35312a8c74d4652d2e8196234151f9efcabf", "patch": "@@ -32,6 +32,13 @@ function like `debuginfo::create_local_var(bcx: block, local: @ast::local)`.\n Internally the module will try to reuse already created metadata by utilizing a cache. All private\n state used by the module is stored within a DebugContext struct, which in turn is contained in the\n CrateContext.\n+\n+\n+This file consists of three conceptual sections:\n+1. The public interface of the module\n+2. Module-internal metadata creation functions\n+3. Minor utility functions\n+\n */\n \n use core::prelude::*;\n@@ -82,8 +89,14 @@ static DW_ATE_signed_char: int = 0x06;\n static DW_ATE_unsigned: int = 0x07;\n static DW_ATE_unsigned_char: int = 0x08;\n \n-////////////////\n \n+\n+\n+//=-------------------------------------------------------------------------------------------------\n+//  Public Interface of debuginfo module\n+//=-------------------------------------------------------------------------------------------------\n+\n+/// A context object for maintaining all state needed by the debuginfo module.\n pub struct DebugContext {\n     names: namegen,\n     crate_file: ~str,\n@@ -116,16 +129,6 @@ impl DebugContext {\n     }\n }\n \n-#[inline]\n-fn dbg_cx<'a>(cx: &'a mut CrateContext) -> &'a mut DebugContext {\n-    cx.dbg_cx.get_mut_ref()\n-}\n-\n-#[inline]\n-fn DIB(cx: &CrateContext) -> DIBuilderRef {\n-    cx.dbg_cx.get_ref().builder\n-}\n-\n /// Create any deferred debug metadata nodes\n pub fn finalize(cx: @mut CrateContext) {\n     debug!(\"finalize\");\n@@ -136,6 +139,207 @@ pub fn finalize(cx: @mut CrateContext) {\n     };\n }\n \n+/// Creates debug information for the given local variable.\n+///\n+/// Adds the created metadata nodes directly to the crate's IR. \n+/// The return value should be ignored if called from outside of the debuginfo module.\n+pub fn create_local_var(bcx: block, local: @ast::local) -> DIVariable {\n+    let cx = bcx.ccx();\n+\n+    let ident = match local.node.pat.node {\n+      ast::pat_ident(_, pth, _) => ast_util::path_to_ident(pth),\n+      // FIXME this should be handled (#2533)\n+      _ => {\n+        bcx.sess().span_note(local.span, \"debuginfo for pattern bindings NYI\");\n+        return ptr::null();\n+      }\n+    };\n+    let name: &str = cx.sess.str_of(ident);\n+    debug!(\"create_local_var: %s\", name);\n+\n+    let loc = span_start(cx, local.span);\n+    let ty = node_id_type(bcx, local.node.id);\n+    let tymd = create_ty(cx, ty, local.node.ty.span);\n+    let filemd = create_file(cx, loc.file.name);\n+    let context = match bcx.parent {\n+        None => create_function(bcx.fcx),\n+        Some(_) => create_block(bcx)\n+    };\n+\n+    let var_md = do as_c_str(name) |name| { unsafe {\n+        llvm::LLVMDIBuilderCreateLocalVariable(\n+            DIB(cx), AutoVariableTag as u32,\n+            context, name, filemd,\n+            loc.line as c_uint, tymd, false, 0, 0)\n+        }};\n+\n+    // FIXME(#6814) Should use `pat_util::pat_bindings` for pats like (a, b) etc\n+    let llptr = match bcx.fcx.lllocals.find_copy(&local.node.pat.id) {\n+        Some(v) => v,\n+        None => {\n+            bcx.tcx().sess.span_bug(\n+                local.span,\n+                fmt!(\"No entry in lllocals table for %?\", local.node.id));\n+        }\n+    };\n+\n+    set_debug_location(cx, create_block(bcx), loc.line, loc.col.to_uint());\n+    unsafe {\n+        let instr = llvm::LLVMDIBuilderInsertDeclareAtEnd(DIB(cx), llptr, var_md, bcx.llbb);\n+        llvm::LLVMSetInstDebugLocation(trans::build::B(bcx), instr);\n+    }\n+\n+    return var_md;\n+}\n+\n+/// Creates debug information for the given function argument.\n+///\n+/// Adds the created metadata nodes directly to the crate's IR. \n+/// The return value should be ignored if called from outside of the debuginfo module.\n+pub fn create_arg(bcx: block, arg: ast::arg, span: span) -> Option<DIVariable> {\n+    debug!(\"create_arg\");\n+    if true {\n+        // XXX create_arg disabled for now because \"node_id_type(bcx, arg.id)\" below blows\n+        // up: \"error: internal compiler error: node_id_to_type: no type for node `arg (id=10)`\"\n+        return None;\n+    }\n+\n+    let fcx = bcx.fcx;\n+    let cx = fcx.ccx;\n+\n+    let loc = span_start(cx, span);\n+    if \"<intrinsic>\" == loc.file.name {\n+        return None;\n+    }\n+\n+    let ty = node_id_type(bcx, arg.id);\n+    let tymd = create_ty(cx, ty, arg.ty.span);\n+    let filemd = create_file(cx, loc.file.name);\n+    let context = create_function(fcx);\n+\n+    match arg.pat.node {\n+        ast::pat_ident(_, path, _) => {\n+            // XXX: This is wrong; it should work for multiple bindings.\n+            let ident = path.idents.last();\n+            let name: &str = cx.sess.str_of(*ident);\n+            let mdnode = do as_c_str(name) |name| { unsafe {\n+                llvm::LLVMDIBuilderCreateLocalVariable(DIB(cx),\n+                    ArgVariableTag as u32, context, name,\n+                    filemd, loc.line as c_uint, tymd, false, 0, 0)\n+                    // XXX need to pass in a real argument number\n+            }};\n+\n+            let llptr = fcx.llargs.get_copy(&arg.id);\n+            set_debug_location(cx, create_block(bcx), loc.line, loc.col.to_uint());\n+            unsafe {\n+                let instr = llvm::LLVMDIBuilderInsertDeclareAtEnd(\n+                        DIB(cx), llptr, mdnode, bcx.llbb);\n+                llvm::LLVMSetInstDebugLocation(trans::build::B(bcx), instr);\n+            }\n+            return Some(mdnode);\n+        }\n+        _ => {\n+            return None;\n+        }\n+    }\n+}\n+\n+/// Sets the current debug location at the beginning of the span\n+///\n+/// Maps to a call to llvm::LLVMSetCurrentDebugLocation(...)\n+pub fn update_source_pos(bcx: block, span: span) {\n+    if !bcx.sess().opts.debuginfo || (*span.lo == 0 && *span.hi == 0) {\n+        return;\n+    }\n+    debug!(\"update_source_pos: %s\", bcx.sess().codemap.span_to_str(span));\n+    let loc = span_start(bcx.ccx(), span);\n+    set_debug_location(bcx.ccx(), create_block(bcx), loc.line, loc.col.to_uint())\n+}\n+\n+/// Creates debug information for the given function.\n+///\n+/// Adds the created metadata nodes directly to the crate's IR. \n+/// The return value should be ignored if called from outside of the debuginfo module.\n+pub fn create_function(fcx: fn_ctxt) -> DISubprogram {\n+    let cx = fcx.ccx;\n+    let fcx = &mut *fcx;\n+    let span = fcx.span.get();\n+\n+    let (ident, ret_ty, id) = match cx.tcx.items.get_copy(&fcx.id) {\n+      ast_map::node_item(item, _) => {\n+        match item.node {\n+          ast::item_fn(ref decl, _, _, _, _) => {\n+            (item.ident, decl.output, item.id)\n+          }\n+          _ => fcx.ccx.sess.span_bug(item.span, \"create_function: item bound to non-function\")\n+        }\n+      }\n+      ast_map::node_method(method, _, _) => {\n+          (method.ident, method.decl.output, method.id)\n+      }\n+      ast_map::node_expr(expr) => {\n+        match expr.node {\n+          ast::expr_fn_block(ref decl, _) => {\n+            ((dbg_cx(cx).names)(\"fn\"), decl.output, expr.id)\n+          }\n+          _ => fcx.ccx.sess.span_bug(expr.span,\n+                  \"create_function: expected an expr_fn_block here\")\n+        }\n+      }\n+      _ => fcx.ccx.sess.bug(\"create_function: unexpected sort of node\")\n+    };\n+\n+    match dbg_cx(cx).created_functions.find(&id) {\n+        Some(fn_md) => return *fn_md,\n+        None => ()\n+    }\n+\n+    debug!(\"create_function: %s, %s\", cx.sess.str_of(ident), cx.sess.codemap.span_to_str(span));\n+\n+    let loc = span_start(cx, span);\n+    let file_md = create_file(cx, loc.file.name);\n+\n+    let ret_ty_md = if cx.sess.opts.extra_debuginfo {\n+        match ret_ty.node {\n+          ast::ty_nil => ptr::null(),\n+          _ => create_ty(cx, ty::node_id_to_type(cx.tcx, id),\n+                         ret_ty.span)\n+        }\n+    } else {\n+        ptr::null()\n+    };\n+\n+    let fn_ty = unsafe {\n+        llvm::LLVMDIBuilderCreateSubroutineType(DIB(cx),\n+            file_md, create_DIArray(DIB(cx), [ret_ty_md]))\n+    };\n+\n+    let fn_md =\n+        do as_c_str(cx.sess.str_of(ident)) |name| {\n+        do as_c_str(cx.sess.str_of(ident)) |linkage| { unsafe {\n+            llvm::LLVMDIBuilderCreateFunction(\n+                DIB(cx),\n+                file_md,\n+                name, linkage,\n+                file_md, loc.line as c_uint,\n+                fn_ty, false, true,\n+                loc.line as c_uint,\n+                FlagPrototyped as c_uint,\n+                cx.sess.opts.optimize != session::No,\n+                fcx.llfn, ptr::null(), ptr::null())\n+            }}};\n+\n+    dbg_cx(cx).created_functions.insert(id, fn_md);\n+    return fn_md;\n+}\n+\n+\n+\n+\n+//=-------------------------------------------------------------------------------------------------\n+// Module-Internal debug info creation functions\n+//=-------------------------------------------------------------------------------------------------\n+\n fn create_DIArray(builder: DIBuilderRef, arr: &[DIDescriptor]) -> DIArray {\n     return unsafe {\n         llvm::LLVMDIBuilderGetOrCreateArray(builder, vec::raw::to_ptr(arr), arr.len() as u32)\n@@ -186,10 +390,7 @@ fn create_file(cx: @mut CrateContext, full_path: &str) -> DIFile {\n     return file_md;\n }\n \n-/// Return codemap::Loc corresponding to the beginning of the span\n-fn span_start(cx: &CrateContext, span: span) -> codemap::Loc {\n-    return cx.sess.codemap.lookup_char_pos(span.lo);\n-}\n+\n \n fn create_block(bcx: block) -> DILexicalBlock {\n     let mut bcx = bcx;\n@@ -231,10 +432,7 @@ fn create_block(bcx: block) -> DILexicalBlock {\n     return block_md;\n }\n \n-fn size_and_align_of(cx: @mut CrateContext, t: ty::t) -> (uint, uint) {\n-    let llty = type_of::type_of(cx, t);\n-    (machine::llsize_of_real(cx, llty), machine::llalign_of_min(cx, llty))\n-}\n+\n \n fn create_basic_type(cx: @mut CrateContext, t: ty::t, _span: span) -> DIType {\n     let ty_id = ty::type_id(t);\n@@ -350,11 +548,6 @@ impl StructContext {\n     }\n }\n \n-#[inline]\n-fn roundup(x: uint, a: uint) -> uint {\n-    ((x + (a - 1)) / a) * a\n-}\n-\n fn create_struct(cx: @mut CrateContext, t: ty::t, fields: ~[ty::field], span: span)\n                 -> DICompositeType {\n     let loc = span_start(cx, span);\n@@ -605,103 +798,6 @@ fn create_ty(cx: @mut CrateContext, t: ty::t, span: span) -> DIType {\n     return ty_md;\n }\n \n-pub fn create_local_var(bcx: block, local: @ast::local) -> DIVariable {\n-    let cx = bcx.ccx();\n-\n-    let ident = match local.node.pat.node {\n-      ast::pat_ident(_, pth, _) => ast_util::path_to_ident(pth),\n-      // FIXME this should be handled (#2533)\n-      _ => {\n-        bcx.sess().span_note(local.span, \"debuginfo for pattern bindings NYI\");\n-        return ptr::null();\n-      }\n-    };\n-    let name: &str = cx.sess.str_of(ident);\n-    debug!(\"create_local_var: %s\", name);\n-\n-    let loc = span_start(cx, local.span);\n-    let ty = node_id_type(bcx, local.node.id);\n-    let tymd = create_ty(cx, ty, local.node.ty.span);\n-    let filemd = create_file(cx, loc.file.name);\n-    let context = match bcx.parent {\n-        None => create_function(bcx.fcx),\n-        Some(_) => create_block(bcx)\n-    };\n-\n-    let var_md = do as_c_str(name) |name| { unsafe {\n-        llvm::LLVMDIBuilderCreateLocalVariable(\n-            DIB(cx), AutoVariableTag as u32,\n-            context, name, filemd,\n-            loc.line as c_uint, tymd, false, 0, 0)\n-        }};\n-\n-    // FIXME(#6814) Should use `pat_util::pat_bindings` for pats like (a, b) etc\n-    let llptr = match bcx.fcx.lllocals.find_copy(&local.node.pat.id) {\n-        Some(v) => v,\n-        None => {\n-            bcx.tcx().sess.span_bug(\n-                local.span,\n-                fmt!(\"No entry in lllocals table for %?\", local.node.id));\n-        }\n-    };\n-\n-    set_debug_location(cx, create_block(bcx), loc.line, loc.col.to_uint());\n-    unsafe {\n-        let instr = llvm::LLVMDIBuilderInsertDeclareAtEnd(DIB(cx), llptr, var_md, bcx.llbb);\n-        llvm::LLVMSetInstDebugLocation(trans::build::B(bcx), instr);\n-    }\n-\n-    return var_md;\n-}\n-\n-pub fn create_arg(bcx: block, arg: ast::arg, span: span) -> Option<DIVariable> {\n-    debug!(\"create_arg\");\n-    if true {\n-        // XXX create_arg disabled for now because \"node_id_type(bcx, arg.id)\" below blows\n-        // up: \"error: internal compiler error: node_id_to_type: no type for node `arg (id=10)`\"\n-        return None;\n-    }\n-\n-    let fcx = bcx.fcx;\n-    let cx = fcx.ccx;\n-\n-    let loc = span_start(cx, span);\n-    if \"<intrinsic>\" == loc.file.name {\n-        return None;\n-    }\n-\n-    let ty = node_id_type(bcx, arg.id);\n-    let tymd = create_ty(cx, ty, arg.ty.span);\n-    let filemd = create_file(cx, loc.file.name);\n-    let context = create_function(fcx);\n-\n-    match arg.pat.node {\n-        ast::pat_ident(_, path, _) => {\n-            // XXX: This is wrong; it should work for multiple bindings.\n-            let ident = path.idents.last();\n-            let name: &str = cx.sess.str_of(*ident);\n-            let mdnode = do as_c_str(name) |name| { unsafe {\n-                llvm::LLVMDIBuilderCreateLocalVariable(DIB(cx),\n-                    ArgVariableTag as u32, context, name,\n-                    filemd, loc.line as c_uint, tymd, false, 0, 0)\n-                    // XXX need to pass in a real argument number\n-            }};\n-\n-            let llptr = fcx.llargs.get_copy(&arg.id);\n-            set_debug_location(cx, create_block(bcx), loc.line, loc.col.to_uint());\n-            unsafe {\n-                let instr = llvm::LLVMDIBuilderInsertDeclareAtEnd(\n-                        DIB(cx), llptr, mdnode, bcx.llbb);\n-                llvm::LLVMSetInstDebugLocation(trans::build::B(bcx), instr);\n-            }\n-            return Some(mdnode);\n-        }\n-        _ => {\n-            return None;\n-        }\n-    }\n-}\n-\n fn set_debug_location(cx: @mut CrateContext, scope: DIScope, line: uint, col: uint) {\n     if dbg_cx(cx).curr_loc == (line, col) {\n         return;\n@@ -718,85 +814,34 @@ fn set_debug_location(cx: @mut CrateContext, scope: DIScope, line: uint, col: ui\n     }\n }\n \n-/// Set current debug location at the beginning of the span\n-pub fn update_source_pos(bcx: block, span: span) {\n-    if !bcx.sess().opts.debuginfo || (*span.lo == 0 && *span.hi == 0) {\n-        return;\n-    }\n-    debug!(\"update_source_pos: %s\", bcx.sess().codemap.span_to_str(span));\n-    let loc = span_start(bcx.ccx(), span);\n-    set_debug_location(bcx.ccx(), create_block(bcx), loc.line, loc.col.to_uint())\n-}\n-\n-pub fn create_function(fcx: fn_ctxt) -> DISubprogram {\n-    let cx = fcx.ccx;\n-    let fcx = &mut *fcx;\n-    let span = fcx.span.get();\n-\n-    let (ident, ret_ty, id) = match cx.tcx.items.get_copy(&fcx.id) {\n-      ast_map::node_item(item, _) => {\n-        match item.node {\n-          ast::item_fn(ref decl, _, _, _, _) => {\n-            (item.ident, decl.output, item.id)\n-          }\n-          _ => fcx.ccx.sess.span_bug(item.span, \"create_function: item bound to non-function\")\n-        }\n-      }\n-      ast_map::node_method(method, _, _) => {\n-          (method.ident, method.decl.output, method.id)\n-      }\n-      ast_map::node_expr(expr) => {\n-        match expr.node {\n-          ast::expr_fn_block(ref decl, _) => {\n-            ((dbg_cx(cx).names)(\"fn\"), decl.output, expr.id)\n-          }\n-          _ => fcx.ccx.sess.span_bug(expr.span,\n-                  \"create_function: expected an expr_fn_block here\")\n-        }\n-      }\n-      _ => fcx.ccx.sess.bug(\"create_function: unexpected sort of node\")\n-    };\n \n-    match dbg_cx(cx).created_functions.find(&id) {\n-        Some(fn_md) => return *fn_md,\n-        None => ()\n-    }\n \n-    debug!(\"create_function: %s, %s\", cx.sess.str_of(ident), cx.sess.codemap.span_to_str(span));\n \n-    let loc = span_start(cx, span);\n-    let file_md = create_file(cx, loc.file.name);\n+//=-------------------------------------------------------------------------------------------------\n+//  Utility Functions\n+//=-------------------------------------------------------------------------------------------------\n \n-    let ret_ty_md = if cx.sess.opts.extra_debuginfo {\n-        match ret_ty.node {\n-          ast::ty_nil => ptr::null(),\n-          _ => create_ty(cx, ty::node_id_to_type(cx.tcx, id),\n-                         ret_ty.span)\n-        }\n-    } else {\n-        ptr::null()\n-    };\n+#[inline]\n+fn roundup(x: uint, a: uint) -> uint {\n+    ((x + (a - 1)) / a) * a\n+}\n \n-    let fn_ty = unsafe {\n-        llvm::LLVMDIBuilderCreateSubroutineType(DIB(cx),\n-            file_md, create_DIArray(DIB(cx), [ret_ty_md]))\n-    };\n+/// Return codemap::Loc corresponding to the beginning of the span\n+fn span_start(cx: &CrateContext, span: span) -> codemap::Loc {\n+    return cx.sess.codemap.lookup_char_pos(span.lo);\n+}\n \n-    let fn_md =\n-        do as_c_str(cx.sess.str_of(ident)) |name| {\n-        do as_c_str(cx.sess.str_of(ident)) |linkage| { unsafe {\n-            llvm::LLVMDIBuilderCreateFunction(\n-                DIB(cx),\n-                file_md,\n-                name, linkage,\n-                file_md, loc.line as c_uint,\n-                fn_ty, false, true,\n-                loc.line as c_uint,\n-                FlagPrototyped as c_uint,\n-                cx.sess.opts.optimize != session::No,\n-                fcx.llfn, ptr::null(), ptr::null())\n-            }}};\n+fn size_and_align_of(cx: @mut CrateContext, t: ty::t) -> (uint, uint) {\n+    let llty = type_of::type_of(cx, t);\n+    (machine::llsize_of_real(cx, llty), machine::llalign_of_min(cx, llty))\n+}\n \n-    dbg_cx(cx).created_functions.insert(id, fn_md);\n-    return fn_md;\n+#[inline]\n+fn dbg_cx<'a>(cx: &'a mut CrateContext) -> &'a mut DebugContext {\n+    cx.dbg_cx.get_mut_ref()\n }\n+\n+#[inline]\n+fn DIB(cx: &CrateContext) -> DIBuilderRef {\n+    cx.dbg_cx.get_ref().builder\n+}\n\\ No newline at end of file"}]}