{"sha": "d6058820237893566670d828c900de61c8e8f8af", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ2MDU4ODIwMjM3ODkzNTY2NjcwZDgyOGM5MDBkZTYxYzhlOGY4YWY=", "commit": {"author": {"name": "flip1995", "email": "philipp.krones@embecosm.com", "date": "2021-05-06T09:51:22Z"}, "committer": {"name": "flip1995", "email": "philipp.krones@embecosm.com", "date": "2021-05-06T10:20:44Z"}, "message": "Merge commit 'b71f3405606d49b9735606b479c3415a0ca9810f' into clippyup", "tree": {"sha": "92ee6c884fcec7b9d661841c910b97ec4f8a292c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/92ee6c884fcec7b9d661841c910b97ec4f8a292c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d6058820237893566670d828c900de61c8e8f8af", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d6058820237893566670d828c900de61c8e8f8af", "html_url": "https://github.com/rust-lang/rust/commit/d6058820237893566670d828c900de61c8e8f8af", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d6058820237893566670d828c900de61c8e8f8af/comments", "author": {"login": "flip1995", "id": 9744647, "node_id": "MDQ6VXNlcjk3NDQ2NDc=", "avatar_url": "https://avatars.githubusercontent.com/u/9744647?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flip1995", "html_url": "https://github.com/flip1995", "followers_url": "https://api.github.com/users/flip1995/followers", "following_url": "https://api.github.com/users/flip1995/following{/other_user}", "gists_url": "https://api.github.com/users/flip1995/gists{/gist_id}", "starred_url": "https://api.github.com/users/flip1995/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flip1995/subscriptions", "organizations_url": "https://api.github.com/users/flip1995/orgs", "repos_url": "https://api.github.com/users/flip1995/repos", "events_url": "https://api.github.com/users/flip1995/events{/privacy}", "received_events_url": "https://api.github.com/users/flip1995/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flip1995", "id": 9744647, "node_id": "MDQ6VXNlcjk3NDQ2NDc=", "avatar_url": "https://avatars.githubusercontent.com/u/9744647?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flip1995", "html_url": "https://github.com/flip1995", "followers_url": "https://api.github.com/users/flip1995/followers", "following_url": "https://api.github.com/users/flip1995/following{/other_user}", "gists_url": "https://api.github.com/users/flip1995/gists{/gist_id}", "starred_url": "https://api.github.com/users/flip1995/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flip1995/subscriptions", "organizations_url": "https://api.github.com/users/flip1995/orgs", "repos_url": "https://api.github.com/users/flip1995/repos", "events_url": "https://api.github.com/users/flip1995/events{/privacy}", "received_events_url": "https://api.github.com/users/flip1995/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "45d4e61098f9e0593fd0d28ba07a738d7e909212", "url": "https://api.github.com/repos/rust-lang/rust/commits/45d4e61098f9e0593fd0d28ba07a738d7e909212", "html_url": "https://github.com/rust-lang/rust/commit/45d4e61098f9e0593fd0d28ba07a738d7e909212"}], "stats": {"total": 3380, "additions": 2323, "deletions": 1057}, "files": [{"sha": "523bab1882836e9ddc5c0c6c81db7c0733f2bfdf", "filename": ".gitignore", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d6058820237893566670d828c900de61c8e8f8af/.gitignore", "raw_url": "https://github.com/rust-lang/rust/raw/d6058820237893566670d828c900de61c8e8f8af/.gitignore", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.gitignore?ref=d6058820237893566670d828c900de61c8e8f8af", "patch": "@@ -29,6 +29,7 @@ out\n \n # gh pages docs\n util/gh-pages/lints.json\n+**/metadata_collection.json\n \n # rustfmt backups\n *.rs.bk"}, {"sha": "7265d1b832376401f9a8997a9b5c4b8e2a2a8209", "filename": "CONTRIBUTING.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d6058820237893566670d828c900de61c8e8f8af/CONTRIBUTING.md", "raw_url": "https://github.com/rust-lang/rust/raw/d6058820237893566670d828c900de61c8e8f8af/CONTRIBUTING.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CONTRIBUTING.md?ref=d6058820237893566670d828c900de61c8e8f8af", "patch": "@@ -118,7 +118,7 @@ which `IntelliJ Rust` will be able to understand.\n Run `cargo dev ide_setup --repo-path <repo-path>` where `<repo-path>` is a path to the rustc repo\n you just cloned.\n The command will add path-dependencies pointing towards rustc-crates inside the rustc repo to\n-Clippys `Cargo.toml`s and should allow rust-analyzer to understand most of the types that Clippy uses.\n+Clippys `Cargo.toml`s and should allow `IntelliJ Rust` to understand most of the types that Clippy uses.\n Just make sure to remove the dependencies again before finally making a pull request!\n \n [rustc_repo]: https://github.com/rust-lang/rust/"}, {"sha": "f010e6096049170c4a89256f9308da67bdfa8760", "filename": "Cargo.toml", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d6058820237893566670d828c900de61c8e8f8af/Cargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/d6058820237893566670d828c900de61c8e8f8af/Cargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.toml?ref=d6058820237893566670d828c900de61c8e8f8af", "patch": "@@ -1,6 +1,6 @@\n [package]\n name = \"clippy\"\n-version = \"0.1.53\"\n+version = \"0.1.54\"\n authors = [\"The Rust Clippy Developers\"]\n description = \"A bunch of helpful lints to avoid common pitfalls in Rust\"\n repository = \"https://github.com/rust-lang/rust-clippy\"\n@@ -52,6 +52,7 @@ rustc_tools_util = { version = \"0.2.0\", path = \"rustc_tools_util\" }\n deny-warnings = []\n integration = [\"tempfile\"]\n internal-lints = [\"clippy_lints/internal-lints\"]\n+metadata-collector-lint = [\"internal-lints\", \"clippy_lints/metadata-collector-lint\"]\n \n [package.metadata.rust-analyzer]\n # This package uses #[feature(rustc_private)]"}, {"sha": "7ceb1da6a6ebb6712ad48e0d6dd981ea3fdf8709", "filename": "clippy_lints/Cargo.toml", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d6058820237893566670d828c900de61c8e8f8af/clippy_lints%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/d6058820237893566670d828c900de61c8e8f8af/clippy_lints%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2FCargo.toml?ref=d6058820237893566670d828c900de61c8e8f8af", "patch": "@@ -1,7 +1,7 @@\n [package]\n name = \"clippy_lints\"\n # begin automatic update\n-version = \"0.1.53\"\n+version = \"0.1.54\"\n # end automatic update\n authors = [\"The Rust Clippy Developers\"]\n description = \"A bunch of helpful lints to avoid common pitfalls in Rust\"\n@@ -20,6 +20,7 @@ pulldown-cmark = { version = \"0.8\", default-features = false }\n quine-mc_cluskey = \"0.2.2\"\n regex-syntax = \"0.6\"\n serde = { version = \"1.0\", features = [\"derive\"] }\n+serde_json = { version = \"1.0\", optional = true }\n toml = \"0.5.3\"\n unicode-normalization = \"0.1\"\n semver = \"0.11\"\n@@ -32,6 +33,7 @@ url = { version = \"2.1.0\", features = [\"serde\"] }\n deny-warnings = []\n # build clippy with internal lints enabled, off by default\n internal-lints = [\"clippy_utils/internal-lints\"]\n+metadata-collector-lint = [\"serde_json\", \"clippy_utils/metadata-collector-lint\"]\n \n [package.metadata.rust-analyzer]\n # This crate uses #[feature(rustc_private)]"}, {"sha": "2a61d58e6537db119a1053ad4845cdf835fc0c39", "filename": "clippy_lints/src/comparison_chain.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d6058820237893566670d828c900de61c8e8f8af/clippy_lints%2Fsrc%2Fcomparison_chain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6058820237893566670d828c900de61c8e8f8af/clippy_lints%2Fsrc%2Fcomparison_chain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcomparison_chain.rs?ref=d6058820237893566670d828c900de61c8e8f8af", "patch": "@@ -1,6 +1,6 @@\n use clippy_utils::diagnostics::span_lint_and_help;\n use clippy_utils::ty::implements_trait;\n-use clippy_utils::{get_trait_def_id, if_sequence, is_else_clause, paths, SpanlessEq};\n+use clippy_utils::{get_trait_def_id, if_sequence, in_constant, is_else_clause, paths, SpanlessEq};\n use rustc_hir::{BinOpKind, Expr, ExprKind};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n@@ -64,6 +64,10 @@ impl<'tcx> LateLintPass<'tcx> for ComparisonChain {\n             return;\n         }\n \n+        if in_constant(cx, expr.hir_id) {\n+            return;\n+        }\n+\n         // Check that there exists at least one explicit else condition\n         let (conds, _) = if_sequence(expr);\n         if conds.len() < 2 {"}, {"sha": "7a53d390bb45f00159ce682c485377c7f80b6504", "filename": "clippy_lints/src/default.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d6058820237893566670d828c900de61c8e8f8af/clippy_lints%2Fsrc%2Fdefault.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6058820237893566670d828c900de61c8e8f8af/clippy_lints%2Fsrc%2Fdefault.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdefault.rs?ref=d6058820237893566670d828c900de61c8e8f8af", "patch": "@@ -1,6 +1,6 @@\n use clippy_utils::diagnostics::{span_lint_and_note, span_lint_and_sugg};\n use clippy_utils::source::snippet_with_macro_callsite;\n-use clippy_utils::{any_parent_is_automatically_derived, contains_name, match_def_path, paths};\n+use clippy_utils::{any_parent_is_automatically_derived, contains_name, in_macro, match_def_path, paths};\n use if_chain::if_chain;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_errors::Applicability;\n@@ -75,6 +75,7 @@ impl_lint_pass!(Default => [DEFAULT_TRAIT_ACCESS, FIELD_REASSIGN_WITH_DEFAULT]);\n impl LateLintPass<'_> for Default {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n         if_chain! {\n+            if !in_macro(expr.span);\n             // Avoid cases already linted by `field_reassign_with_default`\n             if !self.reassigned_linted.contains(&expr.span);\n             if let ExprKind::Call(path, ..) = expr.kind;"}, {"sha": "41acf55dd7d572ec8a75994ec4e924ad4e0c70be", "filename": "clippy_lints/src/eval_order_dependence.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/d6058820237893566670d828c900de61c8e8f8af/clippy_lints%2Fsrc%2Feval_order_dependence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6058820237893566670d828c900de61c8e8f8af/clippy_lints%2Fsrc%2Feval_order_dependence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Feval_order_dependence.rs?ref=d6058820237893566670d828c900de61c8e8f8af", "patch": "@@ -1,5 +1,6 @@\n use clippy_utils::diagnostics::{span_lint, span_lint_and_note};\n use clippy_utils::{get_parent_expr, path_to_local, path_to_local_id};\n+use if_chain::if_chain;\n use rustc_hir::intravisit::{walk_expr, NestedVisitorMap, Visitor};\n use rustc_hir::{BinOpKind, Block, Expr, ExprKind, Guard, HirId, Local, Node, Stmt, StmtKind};\n use rustc_lint::{LateContext, LateLintPass};\n@@ -70,20 +71,19 @@ declare_lint_pass!(EvalOrderDependence => [EVAL_ORDER_DEPENDENCE, DIVERGING_SUB_\n impl<'tcx> LateLintPass<'tcx> for EvalOrderDependence {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n         // Find a write to a local variable.\n-        match expr.kind {\n-            ExprKind::Assign(lhs, ..) | ExprKind::AssignOp(_, lhs, _) => {\n-                if let Some(var) = path_to_local(lhs) {\n-                    let mut visitor = ReadVisitor {\n-                        cx,\n-                        var,\n-                        write_expr: expr,\n-                        last_expr: expr,\n-                    };\n-                    check_for_unsequenced_reads(&mut visitor);\n-                }\n-            },\n-            _ => {},\n-        }\n+        let var = if_chain! {\n+            if let ExprKind::Assign(lhs, ..) | ExprKind::AssignOp(_, lhs, _) = expr.kind;\n+            if let Some(var) = path_to_local(lhs);\n+            if expr.span.desugaring_kind().is_none();\n+            then { var } else { return; }\n+        };\n+        let mut visitor = ReadVisitor {\n+            cx,\n+            var,\n+            write_expr: expr,\n+            last_expr: expr,\n+        };\n+        check_for_unsequenced_reads(&mut visitor);\n     }\n     fn check_stmt(&mut self, cx: &LateContext<'tcx>, stmt: &'tcx Stmt<'_>) {\n         match stmt.kind {\n@@ -305,7 +305,7 @@ impl<'a, 'tcx> Visitor<'tcx> for ReadVisitor<'a, 'tcx> {\n                     self.cx,\n                     EVAL_ORDER_DEPENDENCE,\n                     expr.span,\n-                    \"unsequenced read of a variable\",\n+                    &format!(\"unsequenced read of `{}`\", self.cx.tcx.hir().name(self.var)),\n                     Some(self.write_expr.span),\n                     \"whether read occurs before this write depends on evaluation order\",\n                 );"}, {"sha": "30174fa2100dbbd2f259bbb7e8de3e9ac2ebed87", "filename": "clippy_lints/src/implicit_return.rs", "status": "modified", "additions": 169, "deletions": 82, "changes": 251, "blob_url": "https://github.com/rust-lang/rust/blob/d6058820237893566670d828c900de61c8e8f8af/clippy_lints%2Fsrc%2Fimplicit_return.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6058820237893566670d828c900de61c8e8f8af/clippy_lints%2Fsrc%2Fimplicit_return.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fimplicit_return.rs?ref=d6058820237893566670d828c900de61c8e8f8af", "patch": "@@ -1,13 +1,16 @@\n-use clippy_utils::diagnostics::span_lint_and_then;\n-use clippy_utils::match_panic_def_id;\n-use clippy_utils::source::snippet_opt;\n-use if_chain::if_chain;\n+use clippy_utils::{\n+    diagnostics::span_lint_and_sugg,\n+    get_async_fn_body, is_async_fn,\n+    source::{snippet_with_applicability, snippet_with_context, walk_span_to_context},\n+    visitors::visit_break_exprs,\n+};\n use rustc_errors::Applicability;\n use rustc_hir::intravisit::FnKind;\n-use rustc_hir::{Body, Expr, ExprKind, FnDecl, HirId, MatchSource, StmtKind};\n-use rustc_lint::{LateContext, LateLintPass};\n+use rustc_hir::{Block, Body, Expr, ExprKind, FnDecl, FnRetTy, HirId};\n+use rustc_lint::{LateContext, LateLintPass, LintContext};\n+use rustc_middle::lint::in_external_macro;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n-use rustc_span::source_map::Span;\n+use rustc_span::{Span, SyntaxContext};\n \n declare_clippy_lint! {\n     /// **What it does:** Checks for missing return statements at the end of a block.\n@@ -39,109 +42,193 @@ declare_clippy_lint! {\n \n declare_lint_pass!(ImplicitReturn => [IMPLICIT_RETURN]);\n \n-static LINT_BREAK: &str = \"change `break` to `return` as shown\";\n-static LINT_RETURN: &str = \"add `return` as shown\";\n-\n-fn lint(cx: &LateContext<'_>, outer_span: Span, inner_span: Span, msg: &str) {\n-    let outer_span = outer_span.source_callsite();\n-    let inner_span = inner_span.source_callsite();\n-\n-    span_lint_and_then(cx, IMPLICIT_RETURN, outer_span, \"missing `return` statement\", |diag| {\n-        if let Some(snippet) = snippet_opt(cx, inner_span) {\n-            diag.span_suggestion(\n-                outer_span,\n-                msg,\n-                format!(\"return {}\", snippet),\n-                Applicability::MachineApplicable,\n-            );\n-        }\n-    });\n+fn lint_return(cx: &LateContext<'_>, span: Span) {\n+    let mut app = Applicability::MachineApplicable;\n+    let snip = snippet_with_applicability(cx, span, \"..\", &mut app);\n+    span_lint_and_sugg(\n+        cx,\n+        IMPLICIT_RETURN,\n+        span,\n+        \"missing `return` statement\",\n+        \"add `return` as shown\",\n+        format!(\"return {}\", snip),\n+        app,\n+    );\n+}\n+\n+fn lint_break(cx: &LateContext<'_>, break_span: Span, expr_span: Span) {\n+    let mut app = Applicability::MachineApplicable;\n+    let snip = snippet_with_context(cx, expr_span, break_span.ctxt(), \"..\", &mut app).0;\n+    span_lint_and_sugg(\n+        cx,\n+        IMPLICIT_RETURN,\n+        break_span,\n+        \"missing `return` statement\",\n+        \"change `break` to `return` as shown\",\n+        format!(\"return {}\", snip),\n+        app,\n+    )\n+}\n+\n+#[derive(Clone, Copy, PartialEq, Eq)]\n+enum LintLocation {\n+    /// The lint was applied to a parent expression.\n+    Parent,\n+    /// The lint was applied to this expression, a child, or not applied.\n+    Inner,\n+}\n+impl LintLocation {\n+    fn still_parent(self, b: bool) -> Self {\n+        if b { self } else { Self::Inner }\n+    }\n+\n+    fn is_parent(self) -> bool {\n+        self == Self::Parent\n+    }\n+}\n+\n+// Gets the call site if the span is in a child context. Otherwise returns `None`.\n+fn get_call_site(span: Span, ctxt: SyntaxContext) -> Option<Span> {\n+    (span.ctxt() != ctxt).then(|| walk_span_to_context(span, ctxt).unwrap_or(span))\n }\n \n-fn expr_match(cx: &LateContext<'_>, expr: &Expr<'_>) {\n+fn lint_implicit_returns(\n+    cx: &LateContext<'tcx>,\n+    expr: &'tcx Expr<'_>,\n+    // The context of the function body.\n+    ctxt: SyntaxContext,\n+    // Whether the expression is from a macro expansion.\n+    call_site_span: Option<Span>,\n+) -> LintLocation {\n     match expr.kind {\n-        // loops could be using `break` instead of `return`\n-        ExprKind::Block(block, ..) | ExprKind::Loop(block, ..) => {\n-            if let Some(expr) = &block.expr {\n-                expr_match(cx, expr);\n-            }\n-            // only needed in the case of `break` with `;` at the end\n-            else if let Some(stmt) = block.stmts.last() {\n-                if_chain! {\n-                    if let StmtKind::Semi(expr, ..) = &stmt.kind;\n-                    // make sure it's a break, otherwise we want to skip\n-                    if let ExprKind::Break(.., Some(break_expr)) = &expr.kind;\n-                    then {\n-                            lint(cx, expr.span, break_expr.span, LINT_BREAK);\n-                    }\n-                }\n-            }\n-        },\n-        // use `return` instead of `break`\n-        ExprKind::Break(.., break_expr) => {\n-            if let Some(break_expr) = break_expr {\n-                lint(cx, expr.span, break_expr.span, LINT_BREAK);\n+        ExprKind::Block(\n+            Block {\n+                expr: Some(block_expr), ..\n+            },\n+            _,\n+        ) => lint_implicit_returns(\n+            cx,\n+            block_expr,\n+            ctxt,\n+            call_site_span.or_else(|| get_call_site(block_expr.span, ctxt)),\n+        )\n+        .still_parent(call_site_span.is_some()),\n+\n+        ExprKind::If(_, then_expr, Some(else_expr)) => {\n+            // Both `then_expr` or `else_expr` are required to be blocks in the same context as the `if`. Don't\n+            // bother checking.\n+            let res = lint_implicit_returns(cx, then_expr, ctxt, call_site_span).still_parent(call_site_span.is_some());\n+            if res.is_parent() {\n+                // The return was added as a parent of this if expression.\n+                return res;\n             }\n+            lint_implicit_returns(cx, else_expr, ctxt, call_site_span).still_parent(call_site_span.is_some())\n         },\n-        ExprKind::If(.., if_expr, else_expr) => {\n-            expr_match(cx, if_expr);\n \n-            if let Some(else_expr) = else_expr {\n-                expr_match(cx, else_expr);\n+        ExprKind::Match(_, arms, _) => {\n+            for arm in arms {\n+                let res = lint_implicit_returns(\n+                    cx,\n+                    arm.body,\n+                    ctxt,\n+                    call_site_span.or_else(|| get_call_site(arm.body.span, ctxt)),\n+                )\n+                .still_parent(call_site_span.is_some());\n+                if res.is_parent() {\n+                    // The return was added as a parent of this match expression.\n+                    return res;\n+                }\n             }\n+            LintLocation::Inner\n         },\n-        ExprKind::Match(.., arms, source) => {\n-            let check_all_arms = match source {\n-                MatchSource::IfLetDesugar {\n-                    contains_else_clause: has_else,\n-                } => has_else,\n-                _ => true,\n-            };\n-\n-            if check_all_arms {\n-                for arm in arms {\n-                    expr_match(cx, arm.body);\n+\n+        ExprKind::Loop(block, ..) => {\n+            let mut add_return = false;\n+            visit_break_exprs(block, |break_expr, dest, sub_expr| {\n+                if dest.target_id.ok() == Some(expr.hir_id) {\n+                    if call_site_span.is_none() && break_expr.span.ctxt() == ctxt {\n+                        lint_break(cx, break_expr.span, sub_expr.unwrap().span);\n+                    } else {\n+                        // the break expression is from a macro call, add a return to the loop\n+                        add_return = true;\n+                    }\n+                }\n+            });\n+            if add_return {\n+                #[allow(clippy::option_if_let_else)]\n+                if let Some(span) = call_site_span {\n+                    lint_return(cx, span);\n+                    LintLocation::Parent\n+                } else {\n+                    lint_return(cx, expr.span);\n+                    LintLocation::Inner\n                 }\n             } else {\n-                expr_match(cx, arms.first().expect(\"`if let` doesn't have a single arm\").body);\n+                LintLocation::Inner\n             }\n         },\n-        // skip if it already has a return statement\n-        ExprKind::Ret(..) => (),\n-        // make sure it's not a call that panics\n-        ExprKind::Call(expr, ..) => {\n-            if_chain! {\n-                if let ExprKind::Path(qpath) = &expr.kind;\n-                if let Some(path_def_id) = cx.qpath_res(qpath, expr.hir_id).opt_def_id();\n-                if match_panic_def_id(cx, path_def_id);\n-                then { }\n-                else {\n-                    lint(cx, expr.span, expr.span, LINT_RETURN)\n-                }\n+\n+        // If expressions without an else clause, and blocks without a final expression can only be the final expression\n+        // if they are divergent, or return the unit type.\n+        ExprKind::If(_, _, None) | ExprKind::Block(Block { expr: None, .. }, _) | ExprKind::Ret(_) => {\n+            LintLocation::Inner\n+        },\n+\n+        // Any divergent expression doesn't need a return statement.\n+        ExprKind::MethodCall(..)\n+        | ExprKind::Call(..)\n+        | ExprKind::Binary(..)\n+        | ExprKind::Unary(..)\n+        | ExprKind::Index(..)\n+            if cx.typeck_results().expr_ty(expr).is_never() =>\n+        {\n+            LintLocation::Inner\n+        },\n+\n+        _ =>\n+        {\n+            #[allow(clippy::option_if_let_else)]\n+            if let Some(span) = call_site_span {\n+                lint_return(cx, span);\n+                LintLocation::Parent\n+            } else {\n+                lint_return(cx, expr.span);\n+                LintLocation::Inner\n             }\n         },\n-        // everything else is missing `return`\n-        _ => lint(cx, expr.span, expr.span, LINT_RETURN),\n     }\n }\n \n impl<'tcx> LateLintPass<'tcx> for ImplicitReturn {\n     fn check_fn(\n         &mut self,\n         cx: &LateContext<'tcx>,\n-        _: FnKind<'tcx>,\n-        _: &'tcx FnDecl<'_>,\n+        kind: FnKind<'tcx>,\n+        decl: &'tcx FnDecl<'_>,\n         body: &'tcx Body<'_>,\n         span: Span,\n         _: HirId,\n     ) {\n-        if span.from_expansion() {\n+        if (!matches!(kind, FnKind::Closure) && matches!(decl.output, FnRetTy::DefaultReturn(_)))\n+            || span.ctxt() != body.value.span.ctxt()\n+            || in_external_macro(cx.sess(), span)\n+        {\n             return;\n         }\n-        let body = cx.tcx.hir().body(body.id());\n-        if cx.typeck_results().expr_ty(&body.value).is_unit() {\n+\n+        let res_ty = cx.typeck_results().expr_ty(&body.value);\n+        if res_ty.is_unit() || res_ty.is_never() {\n             return;\n         }\n-        expr_match(cx, &body.value);\n+\n+        let expr = if is_async_fn(kind) {\n+            match get_async_fn_body(cx.tcx, body) {\n+                Some(e) => e,\n+                None => return,\n+            }\n+        } else {\n+            &body.value\n+        };\n+        lint_implicit_returns(cx, expr, expr.span.ctxt(), None);\n     }\n }"}, {"sha": "725aa54157ecf4a352c5cfd119f83993b0330b77", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 38, "deletions": 46, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/d6058820237893566670d828c900de61c8e8f8af/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6058820237893566670d828c900de61c8e8f8af/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=d6058820237893566670d828c900de61c8e8f8af", "patch": "@@ -383,6 +383,7 @@ mod zero_sized_map_values;\n // end lints modules, do not remove this comment, it\u2019s used in `update_lints`\n \n pub use crate::utils::conf::Conf;\n+use crate::utils::conf::TryConf;\n \n /// Register all pre expansion lints\n ///\n@@ -400,56 +401,40 @@ pub fn register_pre_expansion_lints(store: &mut rustc_lint::LintStore) {\n }\n \n #[doc(hidden)]\n-pub fn read_conf(args: &[rustc_ast::NestedMetaItem], sess: &Session) -> Conf {\n+pub fn read_conf(sess: &Session) -> Conf {\n     use std::path::Path;\n-    match utils::conf::file_from_args(args) {\n-        Ok(file_name) => {\n-            // if the user specified a file, it must exist, otherwise default to `clippy.toml` but\n-            // do not require the file to exist\n-            let file_name = match file_name {\n-                Some(file_name) => file_name,\n-                None => match utils::conf::lookup_conf_file() {\n-                    Ok(Some(path)) => path,\n-                    Ok(None) => return Conf::default(),\n-                    Err(error) => {\n-                        sess.struct_err(&format!(\"error finding Clippy's configuration file: {}\", error))\n-                            .emit();\n-                        return Conf::default();\n-                    },\n-                },\n-            };\n-\n-            let file_name = if file_name.is_relative() {\n-                sess.local_crate_source_file\n-                    .as_deref()\n-                    .and_then(Path::parent)\n-                    .unwrap_or_else(|| Path::new(\"\"))\n-                    .join(file_name)\n-            } else {\n-                file_name\n-            };\n-\n-            let (conf, errors) = utils::conf::read(&file_name);\n-\n-            // all conf errors are non-fatal, we just use the default conf in case of error\n-            for error in errors {\n-                sess.struct_err(&format!(\n-                    \"error reading Clippy's configuration file `{}`: {}\",\n-                    file_name.display(),\n-                    error\n-                ))\n-                .emit();\n-            }\n-\n-            conf\n-        },\n-        Err((err, span)) => {\n-            sess.struct_span_err(span, err)\n-                .span_note(span, \"Clippy will use default configuration\")\n+    let file_name = match utils::conf::lookup_conf_file() {\n+        Ok(Some(path)) => path,\n+        Ok(None) => return Conf::default(),\n+        Err(error) => {\n+            sess.struct_err(&format!(\"error finding Clippy's configuration file: {}\", error))\n                 .emit();\n-            Conf::default()\n+            return Conf::default();\n         },\n+    };\n+\n+    let file_name = if file_name.is_relative() {\n+        sess.local_crate_source_file\n+            .as_deref()\n+            .and_then(Path::parent)\n+            .unwrap_or_else(|| Path::new(\"\"))\n+            .join(file_name)\n+    } else {\n+        file_name\n+    };\n+\n+    let TryConf { conf, errors } = utils::conf::read(&file_name);\n+    // all conf errors are non-fatal, we just use the default conf in case of error\n+    for error in errors {\n+        sess.struct_err(&format!(\n+            \"error reading Clippy's configuration file `{}`: {}\",\n+            file_name.display(),\n+            error\n+        ))\n+        .emit();\n     }\n+\n+    conf\n }\n \n /// Register all lints and lint groups with the rustc plugin registry\n@@ -1020,6 +1005,13 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         store.register_late_pass(|| box utils::internal_lints::MatchTypeOnDiagItem);\n         store.register_late_pass(|| box utils::internal_lints::OuterExpnDataPass);\n     }\n+    #[cfg(feature = \"metadata-collector-lint\")]\n+    {\n+        if std::env::var(\"ENABLE_METADATA_COLLECTION\").eq(&Ok(\"1\".to_string())) {\n+            store.register_late_pass(|| box utils::internal_lints::metadata_collector::MetadataCollector::default());\n+        }\n+    }\n+\n     store.register_late_pass(|| box utils::author::Author);\n     store.register_late_pass(|| box await_holding_invalid::AwaitHolding);\n     store.register_late_pass(|| box serde_api::SerdeApi);"}, {"sha": "9662a0b22a3ab563629a4b9e5e79f56395efb399", "filename": "clippy_lints/src/loops/needless_collect.rs", "status": "modified", "additions": 20, "deletions": 6, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/d6058820237893566670d828c900de61c8e8f8af/clippy_lints%2Fsrc%2Floops%2Fneedless_collect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6058820237893566670d828c900de61c8e8f8af/clippy_lints%2Fsrc%2Floops%2Fneedless_collect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fneedless_collect.rs?ref=d6058820237893566670d828c900de61c8e8f8af", "patch": "@@ -7,9 +7,10 @@ use clippy_utils::{is_trait_method, path_to_local_id, paths};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir::intravisit::{walk_block, walk_expr, NestedVisitorMap, Visitor};\n-use rustc_hir::{Block, Expr, ExprKind, GenericArg, HirId, Local, Pat, PatKind, QPath, StmtKind};\n+use rustc_hir::{Block, Expr, ExprKind, GenericArg, GenericArgs, HirId, Local, Pat, PatKind, QPath, StmtKind, Ty};\n use rustc_lint::LateContext;\n use rustc_middle::hir::map::Map;\n+\n use rustc_span::symbol::{sym, Ident};\n use rustc_span::{MultiSpan, Span};\n \n@@ -26,7 +27,7 @@ fn check_needless_collect_direct_usage<'tcx>(expr: &'tcx Expr<'_>, cx: &LateCont\n         if chain_method.ident.name == sym!(collect) && is_trait_method(cx, &args[0], sym::Iterator);\n         if let Some(generic_args) = chain_method.args;\n         if let Some(GenericArg::Type(ref ty)) = generic_args.args.get(0);\n-        let ty = cx.typeck_results().node_type(ty.hir_id);\n+        if let Some(ty) = cx.typeck_results().node_type_opt(ty.hir_id);\n         if is_type_diagnostic_item(cx, ty, sym::vec_type)\n             || is_type_diagnostic_item(cx, ty, sym::vecdeque_type)\n             || match_type(cx, ty, &paths::BTREEMAP)\n@@ -58,20 +59,33 @@ fn check_needless_collect_direct_usage<'tcx>(expr: &'tcx Expr<'_>, cx: &LateCont\n }\n \n fn check_needless_collect_indirect_usage<'tcx>(expr: &'tcx Expr<'_>, cx: &LateContext<'tcx>) {\n+    fn get_hir_id<'tcx>(ty: Option<&Ty<'tcx>>, method_args: Option<&GenericArgs<'tcx>>) -> Option<HirId> {\n+        if let Some(ty) = ty {\n+            return Some(ty.hir_id);\n+        }\n+\n+        if let Some(generic_args) = method_args {\n+            if let Some(GenericArg::Type(ref ty)) = generic_args.args.get(0) {\n+                return Some(ty.hir_id);\n+            }\n+        }\n+\n+        None\n+    }\n     if let ExprKind::Block(block, _) = expr.kind {\n         for stmt in block.stmts {\n             if_chain! {\n                 if let StmtKind::Local(\n                     Local { pat: Pat { hir_id: pat_id, kind: PatKind::Binding(_, _, ident, .. ), .. },\n-                    init: Some(init_expr), .. }\n+                    init: Some(init_expr), ty, .. }\n                 ) = stmt.kind;\n                 if let ExprKind::MethodCall(method_name, collect_span, &[ref iter_source], ..) = init_expr.kind;\n                 if method_name.ident.name == sym!(collect) && is_trait_method(cx, init_expr, sym::Iterator);\n-                if let Some(generic_args) = method_name.args;\n-                if let Some(GenericArg::Type(ref ty)) = generic_args.args.get(0);\n-                if let ty = cx.typeck_results().node_type(ty.hir_id);\n+                if let Some(hir_id) = get_hir_id(*ty, method_name.args);\n+                if let Some(ty) = cx.typeck_results().node_type_opt(hir_id);\n                 if is_type_diagnostic_item(cx, ty, sym::vec_type) ||\n                     is_type_diagnostic_item(cx, ty, sym::vecdeque_type) ||\n+                    is_type_diagnostic_item(cx, ty, sym::BinaryHeap) ||\n                     match_type(cx, ty, &paths::LINKED_LIST);\n                 if let Some(iter_calls) = detect_iter_and_into_iters(block, *ident);\n                 if let [iter_call] = &*iter_calls;"}, {"sha": "55404b87ec9ce60400bf8137ac93a8dbe8a09e23", "filename": "clippy_lints/src/loops/while_immutable_condition.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/d6058820237893566670d828c900de61c8e8f8af/clippy_lints%2Fsrc%2Floops%2Fwhile_immutable_condition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6058820237893566670d828c900de61c8e8f8af/clippy_lints%2Fsrc%2Floops%2Fwhile_immutable_condition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fwhile_immutable_condition.rs?ref=d6058820237893566670d828c900de61c8e8f8af", "patch": "@@ -28,11 +28,14 @@ pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, cond: &'tcx Expr<'_>, expr: &'\n         return;\n     }\n     let used_in_condition = &var_visitor.ids;\n-    let no_cond_variable_mutated = if let Some(used_mutably) = mutated_variables(expr, cx) {\n-        used_in_condition.is_disjoint(&used_mutably)\n-    } else {\n-        return;\n-    };\n+    let mutated_in_body = mutated_variables(expr, cx);\n+    let mutated_in_condition = mutated_variables(cond, cx);\n+    let no_cond_variable_mutated =\n+        if let (Some(used_mutably_body), Some(used_mutably_cond)) = (mutated_in_body, mutated_in_condition) {\n+            used_in_condition.is_disjoint(&used_mutably_body) && used_in_condition.is_disjoint(&used_mutably_cond)\n+        } else {\n+            return;\n+        };\n     let mutable_static_in_cond = var_visitor.def_ids.iter().any(|(_, v)| *v);\n \n     let mut has_break_or_return_visitor = HasBreakOrReturnVisitor {"}, {"sha": "a70e8b26087efc1aa5bb2e0d346fe6eeb3789701", "filename": "clippy_lints/src/matches.rs", "status": "modified", "additions": 14, "deletions": 6, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/d6058820237893566670d828c900de61c8e8f8af/clippy_lints%2Fsrc%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6058820237893566670d828c900de61c8e8f8af/clippy_lints%2Fsrc%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches.rs?ref=d6058820237893566670d828c900de61c8e8f8af", "patch": "@@ -1590,9 +1590,9 @@ fn is_none_arm(cx: &LateContext<'_>, arm: &Arm<'_>) -> bool {\n // Checks if arm has the form `Some(ref v) => Some(v)` (checks for `ref` and `ref mut`)\n fn is_ref_some_arm(cx: &LateContext<'_>, arm: &Arm<'_>) -> Option<BindingAnnotation> {\n     if_chain! {\n-        if let PatKind::TupleStruct(ref qpath, pats, _) = arm.pat.kind;\n+        if let PatKind::TupleStruct(ref qpath, [first_pat, ..], _) = arm.pat.kind;\n         if is_lang_ctor(cx, qpath, OptionSome);\n-        if let PatKind::Binding(rb, .., ident, _) = pats[0].kind;\n+        if let PatKind::Binding(rb, .., ident, _) = first_pat.kind;\n         if rb == BindingAnnotation::Ref || rb == BindingAnnotation::RefMut;\n         if let ExprKind::Call(e, args) = remove_blocks(arm.body).kind;\n         if let ExprKind::Path(ref some_path) = e.kind;\n@@ -1712,6 +1712,7 @@ mod redundant_pattern_match {\n     use clippy_utils::{is_lang_ctor, is_qpath_def_path, is_trait_method, paths};\n     use if_chain::if_chain;\n     use rustc_ast::ast::LitKind;\n+    use rustc_data_structures::fx::FxHashSet;\n     use rustc_errors::Applicability;\n     use rustc_hir::LangItem::{OptionNone, OptionSome, PollPending, PollReady, ResultErr, ResultOk};\n     use rustc_hir::{\n@@ -1739,6 +1740,13 @@ mod redundant_pattern_match {\n     /// deallocate memory. For these types, and composites containing them, changing the drop order\n     /// won't result in any observable side effects.\n     fn type_needs_ordered_drop(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> bool {\n+        type_needs_ordered_drop_inner(cx, ty, &mut FxHashSet::default())\n+    }\n+\n+    fn type_needs_ordered_drop_inner(cx: &LateContext<'tcx>, ty: Ty<'tcx>, seen: &mut FxHashSet<Ty<'tcx>>) -> bool {\n+        if !seen.insert(ty) {\n+            return false;\n+        }\n         if !ty.needs_drop(cx.tcx, cx.param_env) {\n             false\n         } else if !cx\n@@ -1750,12 +1758,12 @@ mod redundant_pattern_match {\n             // This type doesn't implement drop, so no side effects here.\n             // Check if any component type has any.\n             match ty.kind() {\n-                ty::Tuple(_) => ty.tuple_fields().any(|ty| type_needs_ordered_drop(cx, ty)),\n-                ty::Array(ty, _) => type_needs_ordered_drop(cx, ty),\n+                ty::Tuple(_) => ty.tuple_fields().any(|ty| type_needs_ordered_drop_inner(cx, ty, seen)),\n+                ty::Array(ty, _) => type_needs_ordered_drop_inner(cx, ty, seen),\n                 ty::Adt(adt, subs) => adt\n                     .all_fields()\n                     .map(|f| f.ty(cx.tcx, subs))\n-                    .any(|ty| type_needs_ordered_drop(cx, ty)),\n+                    .any(|ty| type_needs_ordered_drop_inner(cx, ty, seen)),\n                 _ => true,\n             }\n         }\n@@ -1772,7 +1780,7 @@ mod redundant_pattern_match {\n         {\n             // Check all of the generic arguments.\n             if let ty::Adt(_, subs) = ty.kind() {\n-                subs.types().any(|ty| type_needs_ordered_drop(cx, ty))\n+                subs.types().any(|ty| type_needs_ordered_drop_inner(cx, ty, seen))\n             } else {\n                 true\n             }"}, {"sha": "0b1b6304defcb9246352a05df39c46239f23a312", "filename": "clippy_lints/src/methods/mod.rs", "status": "modified", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/d6058820237893566670d828c900de61c8e8f8af/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6058820237893566670d828c900de61c8e8f8af/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs?ref=d6058820237893566670d828c900de61c8e8f8af", "patch": "@@ -2189,27 +2189,6 @@ const TRAIT_METHODS: [ShouldImplTraitCase; 30] = [\n     ShouldImplTraitCase::new(\"std::ops::Sub\", \"sub\",  2,  FN_HEADER,  SelfKind::Value,  OutType::Any, true),\n ];\n \n-#[rustfmt::skip]\n-const PATTERN_METHODS: [(&str, usize); 17] = [\n-    (\"contains\", 1),\n-    (\"starts_with\", 1),\n-    (\"ends_with\", 1),\n-    (\"find\", 1),\n-    (\"rfind\", 1),\n-    (\"split\", 1),\n-    (\"rsplit\", 1),\n-    (\"split_terminator\", 1),\n-    (\"rsplit_terminator\", 1),\n-    (\"splitn\", 2),\n-    (\"rsplitn\", 2),\n-    (\"matches\", 1),\n-    (\"rmatches\", 1),\n-    (\"match_indices\", 1),\n-    (\"rmatch_indices\", 1),\n-    (\"trim_start_matches\", 1),\n-    (\"trim_end_matches\", 1),\n-];\n-\n #[derive(Clone, Copy, PartialEq, Debug)]\n enum SelfKind {\n     Value,"}, {"sha": "d313a3db479de6d51c5797985804403272cf32f0", "filename": "clippy_lints/src/methods/single_char_pattern.rs", "status": "modified", "additions": 23, "deletions": 1, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/d6058820237893566670d828c900de61c8e8f8af/clippy_lints%2Fsrc%2Fmethods%2Fsingle_char_pattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6058820237893566670d828c900de61c8e8f8af/clippy_lints%2Fsrc%2Fmethods%2Fsingle_char_pattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fsingle_char_pattern.rs?ref=d6058820237893566670d828c900de61c8e8f8af", "patch": "@@ -9,9 +9,31 @@ use rustc_span::symbol::Symbol;\n \n use super::SINGLE_CHAR_PATTERN;\n \n+const PATTERN_METHODS: [(&str, usize); 19] = [\n+    (\"contains\", 1),\n+    (\"starts_with\", 1),\n+    (\"ends_with\", 1),\n+    (\"find\", 1),\n+    (\"rfind\", 1),\n+    (\"split\", 1),\n+    (\"rsplit\", 1),\n+    (\"split_terminator\", 1),\n+    (\"rsplit_terminator\", 1),\n+    (\"splitn\", 2),\n+    (\"rsplitn\", 2),\n+    (\"matches\", 1),\n+    (\"rmatches\", 1),\n+    (\"match_indices\", 1),\n+    (\"rmatch_indices\", 1),\n+    (\"strip_prefix\", 1),\n+    (\"strip_suffix\", 1),\n+    (\"trim_start_matches\", 1),\n+    (\"trim_end_matches\", 1),\n+];\n+\n /// lint for length-1 `str`s for methods in `PATTERN_METHODS`\n pub(super) fn check(cx: &LateContext<'_>, _expr: &hir::Expr<'_>, method_name: Symbol, args: &[hir::Expr<'_>]) {\n-    for &(method, pos) in &crate::methods::PATTERN_METHODS {\n+    for &(method, pos) in &PATTERN_METHODS {\n         if_chain! {\n             if let ty::Ref(_, ty, _) = cx.typeck_results().expr_ty_adjusted(&args[0]).kind();\n             if *ty.kind() == ty::Str;"}, {"sha": "8b66587bfd1620910db1411507609967275976c9", "filename": "clippy_lints/src/methods/unnecessary_filter_map.rs", "status": "modified", "additions": 22, "deletions": 18, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/d6058820237893566670d828c900de61c8e8f8af/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_filter_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6058820237893566670d828c900de61c8e8f8af/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_filter_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_filter_map.rs?ref=d6058820237893566670d828c900de61c8e8f8af", "patch": "@@ -6,6 +6,7 @@ use rustc_hir::intravisit::{walk_expr, NestedVisitorMap, Visitor};\n use rustc_hir::LangItem::{OptionNone, OptionSome};\n use rustc_lint::LateContext;\n use rustc_middle::hir::map::Map;\n+use rustc_middle::ty::{self, TyS};\n use rustc_span::sym;\n \n use super::UNNECESSARY_FILTER_MAP;\n@@ -28,25 +29,28 @@ pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, arg: &hir::Expr<\n         found_mapping |= return_visitor.found_mapping;\n         found_filtering |= return_visitor.found_filtering;\n \n-        if !found_filtering {\n-            span_lint(\n-                cx,\n-                UNNECESSARY_FILTER_MAP,\n-                expr.span,\n-                \"this `.filter_map` can be written more simply using `.map`\",\n-            );\n-            return;\n-        }\n-\n-        if !found_mapping && !mutates_arg {\n-            span_lint(\n-                cx,\n-                UNNECESSARY_FILTER_MAP,\n-                expr.span,\n-                \"this `.filter_map` can be written more simply using `.filter`\",\n-            );\n+        let sugg = if !found_filtering {\n+            \"map\"\n+        } else if !found_mapping && !mutates_arg {\n+            let in_ty = cx.typeck_results().node_type(body.params[0].hir_id);\n+            match cx.typeck_results().expr_ty(&body.value).kind() {\n+                ty::Adt(adt, subst)\n+                    if cx.tcx.is_diagnostic_item(sym::option_type, adt.did)\n+                        && TyS::same_type(in_ty, subst.type_at(0)) =>\n+                {\n+                    \"filter\"\n+                },\n+                _ => return,\n+            }\n+        } else {\n             return;\n-        }\n+        };\n+        span_lint(\n+            cx,\n+            UNNECESSARY_FILTER_MAP,\n+            expr.span,\n+            &format!(\"this `.filter_map` can be written more simply using `.{}`\", sugg),\n+        );\n     }\n }\n "}, {"sha": "3c6a7071c24a7e62cab0d4b2b49c7564e6ee57a3", "filename": "clippy_lints/src/misc_early.rs", "status": "removed", "additions": 0, "deletions": 569, "changes": 569, "blob_url": "https://github.com/rust-lang/rust/blob/45d4e61098f9e0593fd0d28ba07a738d7e909212/clippy_lints%2Fsrc%2Fmisc_early.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45d4e61098f9e0593fd0d28ba07a738d7e909212/clippy_lints%2Fsrc%2Fmisc_early.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmisc_early.rs?ref=45d4e61098f9e0593fd0d28ba07a738d7e909212", "patch": "@@ -1,569 +0,0 @@\n-use clippy_utils::diagnostics::{span_lint, span_lint_and_help, span_lint_and_sugg, span_lint_and_then};\n-use clippy_utils::source::snippet_opt;\n-use rustc_ast::ast::{\n-    BindingMode, Expr, ExprKind, GenericParamKind, Generics, Lit, LitFloatType, LitIntType, LitKind, Mutability,\n-    NodeId, Pat, PatKind, UnOp,\n-};\n-use rustc_ast::visit::FnKind;\n-use rustc_data_structures::fx::FxHashMap;\n-use rustc_errors::Applicability;\n-use rustc_hir::PrimTy;\n-use rustc_lint::{EarlyContext, EarlyLintPass, LintContext};\n-use rustc_middle::lint::in_external_macro;\n-use rustc_session::{declare_lint_pass, declare_tool_lint};\n-use rustc_span::source_map::Span;\n-\n-declare_clippy_lint! {\n-    /// **What it does:** Checks for structure field patterns bound to wildcards.\n-    ///\n-    /// **Why is this bad?** Using `..` instead is shorter and leaves the focus on\n-    /// the fields that are actually bound.\n-    ///\n-    /// **Known problems:** None.\n-    ///\n-    /// **Example:**\n-    /// ```rust\n-    /// # struct Foo {\n-    /// #     a: i32,\n-    /// #     b: i32,\n-    /// #     c: i32,\n-    /// # }\n-    /// let f = Foo { a: 0, b: 0, c: 0 };\n-    ///\n-    /// // Bad\n-    /// match f {\n-    ///     Foo { a: _, b: 0, .. } => {},\n-    ///     Foo { a: _, b: _, c: _ } => {},\n-    /// }\n-    ///\n-    /// // Good\n-    /// match f {\n-    ///     Foo { b: 0, .. } => {},\n-    ///     Foo { .. } => {},\n-    /// }\n-    /// ```\n-    pub UNNEEDED_FIELD_PATTERN,\n-    restriction,\n-    \"struct fields bound to a wildcard instead of using `..`\"\n-}\n-\n-declare_clippy_lint! {\n-    /// **What it does:** Checks for function arguments having the similar names\n-    /// differing by an underscore.\n-    ///\n-    /// **Why is this bad?** It affects code readability.\n-    ///\n-    /// **Known problems:** None.\n-    ///\n-    /// **Example:**\n-    /// ```rust\n-    /// // Bad\n-    /// fn foo(a: i32, _a: i32) {}\n-    ///\n-    /// // Good\n-    /// fn bar(a: i32, _b: i32) {}\n-    /// ```\n-    pub DUPLICATE_UNDERSCORE_ARGUMENT,\n-    style,\n-    \"function arguments having names which only differ by an underscore\"\n-}\n-\n-declare_clippy_lint! {\n-    /// **What it does:** Detects expressions of the form `--x`.\n-    ///\n-    /// **Why is this bad?** It can mislead C/C++ programmers to think `x` was\n-    /// decremented.\n-    ///\n-    /// **Known problems:** None.\n-    ///\n-    /// **Example:**\n-    /// ```rust\n-    /// let mut x = 3;\n-    /// --x;\n-    /// ```\n-    pub DOUBLE_NEG,\n-    style,\n-    \"`--x`, which is a double negation of `x` and not a pre-decrement as in C/C++\"\n-}\n-\n-declare_clippy_lint! {\n-    /// **What it does:** Warns on hexadecimal literals with mixed-case letter\n-    /// digits.\n-    ///\n-    /// **Why is this bad?** It looks confusing.\n-    ///\n-    /// **Known problems:** None.\n-    ///\n-    /// **Example:**\n-    /// ```rust\n-    /// // Bad\n-    /// let y = 0x1a9BAcD;\n-    ///\n-    /// // Good\n-    /// let y = 0x1A9BACD;\n-    /// ```\n-    pub MIXED_CASE_HEX_LITERALS,\n-    style,\n-    \"hex literals whose letter digits are not consistently upper- or lowercased\"\n-}\n-\n-declare_clippy_lint! {\n-    /// **What it does:** Warns if literal suffixes are not separated by an\n-    /// underscore.\n-    ///\n-    /// **Why is this bad?** It is much less readable.\n-    ///\n-    /// **Known problems:** None.\n-    ///\n-    /// **Example:**\n-    /// ```rust\n-    /// // Bad\n-    /// let y = 123832i32;\n-    ///\n-    /// // Good\n-    /// let y = 123832_i32;\n-    /// ```\n-    pub UNSEPARATED_LITERAL_SUFFIX,\n-    pedantic,\n-    \"literals whose suffix is not separated by an underscore\"\n-}\n-\n-declare_clippy_lint! {\n-    /// **What it does:** Warns if an integral constant literal starts with `0`.\n-    ///\n-    /// **Why is this bad?** In some languages (including the infamous C language\n-    /// and most of its\n-    /// family), this marks an octal constant. In Rust however, this is a decimal\n-    /// constant. This could\n-    /// be confusing for both the writer and a reader of the constant.\n-    ///\n-    /// **Known problems:** None.\n-    ///\n-    /// **Example:**\n-    ///\n-    /// In Rust:\n-    /// ```rust\n-    /// fn main() {\n-    ///     let a = 0123;\n-    ///     println!(\"{}\", a);\n-    /// }\n-    /// ```\n-    ///\n-    /// prints `123`, while in C:\n-    ///\n-    /// ```c\n-    /// #include <stdio.h>\n-    ///\n-    /// int main() {\n-    ///     int a = 0123;\n-    ///     printf(\"%d\\n\", a);\n-    /// }\n-    /// ```\n-    ///\n-    /// prints `83` (as `83 == 0o123` while `123 == 0o173`).\n-    pub ZERO_PREFIXED_LITERAL,\n-    complexity,\n-    \"integer literals starting with `0`\"\n-}\n-\n-declare_clippy_lint! {\n-    /// **What it does:** Warns if a generic shadows a built-in type.\n-    ///\n-    /// **Why is this bad?** This gives surprising type errors.\n-    ///\n-    /// **Known problems:** None.\n-    ///\n-    /// **Example:**\n-    ///\n-    /// ```ignore\n-    /// impl<u32> Foo<u32> {\n-    ///     fn impl_func(&self) -> u32 {\n-    ///         42\n-    ///     }\n-    /// }\n-    /// ```\n-    pub BUILTIN_TYPE_SHADOW,\n-    style,\n-    \"shadowing a builtin type\"\n-}\n-\n-declare_clippy_lint! {\n-    /// **What it does:** Checks for patterns in the form `name @ _`.\n-    ///\n-    /// **Why is this bad?** It's almost always more readable to just use direct\n-    /// bindings.\n-    ///\n-    /// **Known problems:** None.\n-    ///\n-    /// **Example:**\n-    /// ```rust\n-    /// # let v = Some(\"abc\");\n-    ///\n-    /// // Bad\n-    /// match v {\n-    ///     Some(x) => (),\n-    ///     y @ _ => (),\n-    /// }\n-    ///\n-    /// // Good\n-    /// match v {\n-    ///     Some(x) => (),\n-    ///     y => (),\n-    /// }\n-    /// ```\n-    pub REDUNDANT_PATTERN,\n-    style,\n-    \"using `name @ _` in a pattern\"\n-}\n-\n-declare_clippy_lint! {\n-    /// **What it does:** Checks for tuple patterns with a wildcard\n-    /// pattern (`_`) is next to a rest pattern (`..`).\n-    ///\n-    /// _NOTE_: While `_, ..` means there is at least one element left, `..`\n-    /// means there are 0 or more elements left. This can make a difference\n-    /// when refactoring, but shouldn't result in errors in the refactored code,\n-    /// since the wildcard pattern isn't used anyway.\n-    /// **Why is this bad?** The wildcard pattern is unneeded as the rest pattern\n-    /// can match that element as well.\n-    ///\n-    /// **Known problems:** None.\n-    ///\n-    /// **Example:**\n-    /// ```rust\n-    /// # struct TupleStruct(u32, u32, u32);\n-    /// # let t = TupleStruct(1, 2, 3);\n-    /// // Bad\n-    /// match t {\n-    ///     TupleStruct(0, .., _) => (),\n-    ///     _ => (),\n-    /// }\n-    ///\n-    /// // Good\n-    /// match t {\n-    ///     TupleStruct(0, ..) => (),\n-    ///     _ => (),\n-    /// }\n-    /// ```\n-    pub UNNEEDED_WILDCARD_PATTERN,\n-    complexity,\n-    \"tuple patterns with a wildcard pattern (`_`) is next to a rest pattern (`..`)\"\n-}\n-\n-declare_lint_pass!(MiscEarlyLints => [\n-    UNNEEDED_FIELD_PATTERN,\n-    DUPLICATE_UNDERSCORE_ARGUMENT,\n-    DOUBLE_NEG,\n-    MIXED_CASE_HEX_LITERALS,\n-    UNSEPARATED_LITERAL_SUFFIX,\n-    ZERO_PREFIXED_LITERAL,\n-    BUILTIN_TYPE_SHADOW,\n-    REDUNDANT_PATTERN,\n-    UNNEEDED_WILDCARD_PATTERN,\n-]);\n-\n-impl EarlyLintPass for MiscEarlyLints {\n-    fn check_generics(&mut self, cx: &EarlyContext<'_>, gen: &Generics) {\n-        for param in &gen.params {\n-            if let GenericParamKind::Type { .. } = param.kind {\n-                if let Some(prim_ty) = PrimTy::from_name(param.ident.name) {\n-                    span_lint(\n-                        cx,\n-                        BUILTIN_TYPE_SHADOW,\n-                        param.ident.span,\n-                        &format!(\"this generic shadows the built-in type `{}`\", prim_ty.name()),\n-                    );\n-                }\n-            }\n-        }\n-    }\n-\n-    fn check_pat(&mut self, cx: &EarlyContext<'_>, pat: &Pat) {\n-        if let PatKind::Struct(ref npat, ref pfields, _) = pat.kind {\n-            let mut wilds = 0;\n-            let type_name = npat\n-                .segments\n-                .last()\n-                .expect(\"A path must have at least one segment\")\n-                .ident\n-                .name;\n-\n-            for field in pfields {\n-                if let PatKind::Wild = field.pat.kind {\n-                    wilds += 1;\n-                }\n-            }\n-            if !pfields.is_empty() && wilds == pfields.len() {\n-                span_lint_and_help(\n-                    cx,\n-                    UNNEEDED_FIELD_PATTERN,\n-                    pat.span,\n-                    \"all the struct fields are matched to a wildcard pattern, consider using `..`\",\n-                    None,\n-                    &format!(\"try with `{} {{ .. }}` instead\", type_name),\n-                );\n-                return;\n-            }\n-            if wilds > 0 {\n-                for field in pfields {\n-                    if let PatKind::Wild = field.pat.kind {\n-                        wilds -= 1;\n-                        if wilds > 0 {\n-                            span_lint(\n-                                cx,\n-                                UNNEEDED_FIELD_PATTERN,\n-                                field.span,\n-                                \"you matched a field with a wildcard pattern, consider using `..` instead\",\n-                            );\n-                        } else {\n-                            let mut normal = vec![];\n-\n-                            for field in pfields {\n-                                match field.pat.kind {\n-                                    PatKind::Wild => {},\n-                                    _ => {\n-                                        if let Ok(n) = cx.sess().source_map().span_to_snippet(field.span) {\n-                                            normal.push(n);\n-                                        }\n-                                    },\n-                                }\n-                            }\n-\n-                            span_lint_and_help(\n-                                cx,\n-                                UNNEEDED_FIELD_PATTERN,\n-                                field.span,\n-                                \"you matched a field with a wildcard pattern, consider using `..` \\\n-                                 instead\",\n-                                None,\n-                                &format!(\"try with `{} {{ {}, .. }}`\", type_name, normal[..].join(\", \")),\n-                            );\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-\n-        if let PatKind::Ident(left, ident, Some(ref right)) = pat.kind {\n-            let left_binding = match left {\n-                BindingMode::ByRef(Mutability::Mut) => \"ref mut \",\n-                BindingMode::ByRef(Mutability::Not) => \"ref \",\n-                BindingMode::ByValue(..) => \"\",\n-            };\n-\n-            if let PatKind::Wild = right.kind {\n-                span_lint_and_sugg(\n-                    cx,\n-                    REDUNDANT_PATTERN,\n-                    pat.span,\n-                    &format!(\n-                        \"the `{} @ _` pattern can be written as just `{}`\",\n-                        ident.name, ident.name,\n-                    ),\n-                    \"try\",\n-                    format!(\"{}{}\", left_binding, ident.name),\n-                    Applicability::MachineApplicable,\n-                );\n-            }\n-        }\n-\n-        check_unneeded_wildcard_pattern(cx, pat);\n-    }\n-\n-    fn check_fn(&mut self, cx: &EarlyContext<'_>, fn_kind: FnKind<'_>, _: Span, _: NodeId) {\n-        let mut registered_names: FxHashMap<String, Span> = FxHashMap::default();\n-\n-        for arg in &fn_kind.decl().inputs {\n-            if let PatKind::Ident(_, ident, None) = arg.pat.kind {\n-                let arg_name = ident.to_string();\n-\n-                if let Some(arg_name) = arg_name.strip_prefix('_') {\n-                    if let Some(correspondence) = registered_names.get(arg_name) {\n-                        span_lint(\n-                            cx,\n-                            DUPLICATE_UNDERSCORE_ARGUMENT,\n-                            *correspondence,\n-                            &format!(\n-                                \"`{}` already exists, having another argument having almost the same \\\n-                                 name makes code comprehension and documentation more difficult\",\n-                                arg_name\n-                            ),\n-                        );\n-                    }\n-                } else {\n-                    registered_names.insert(arg_name, arg.pat.span);\n-                }\n-            }\n-        }\n-    }\n-\n-    fn check_expr(&mut self, cx: &EarlyContext<'_>, expr: &Expr) {\n-        if in_external_macro(cx.sess(), expr.span) {\n-            return;\n-        }\n-        match expr.kind {\n-            ExprKind::Unary(UnOp::Neg, ref inner) => {\n-                if let ExprKind::Unary(UnOp::Neg, _) = inner.kind {\n-                    span_lint(\n-                        cx,\n-                        DOUBLE_NEG,\n-                        expr.span,\n-                        \"`--x` could be misinterpreted as pre-decrement by C programmers, is usually a no-op\",\n-                    );\n-                }\n-            },\n-            ExprKind::Lit(ref lit) => Self::check_lit(cx, lit),\n-            _ => (),\n-        }\n-    }\n-}\n-\n-impl MiscEarlyLints {\n-    fn check_lit(cx: &EarlyContext<'_>, lit: &Lit) {\n-        // We test if first character in snippet is a number, because the snippet could be an expansion\n-        // from a built-in macro like `line!()` or a proc-macro like `#[wasm_bindgen]`.\n-        // Note that this check also covers special case that `line!()` is eagerly expanded by compiler.\n-        // See <https://github.com/rust-lang/rust-clippy/issues/4507> for a regression.\n-        // FIXME: Find a better way to detect those cases.\n-        let lit_snip = match snippet_opt(cx, lit.span) {\n-            Some(snip) if snip.chars().next().map_or(false, |c| c.is_digit(10)) => snip,\n-            _ => return,\n-        };\n-\n-        if let LitKind::Int(value, lit_int_type) = lit.kind {\n-            let suffix = match lit_int_type {\n-                LitIntType::Signed(ty) => ty.name_str(),\n-                LitIntType::Unsigned(ty) => ty.name_str(),\n-                LitIntType::Unsuffixed => \"\",\n-            };\n-\n-            let maybe_last_sep_idx = if let Some(val) = lit_snip.len().checked_sub(suffix.len() + 1) {\n-                val\n-            } else {\n-                return; // It's useless so shouldn't lint.\n-            };\n-            // Do not lint when literal is unsuffixed.\n-            if !suffix.is_empty() && lit_snip.as_bytes()[maybe_last_sep_idx] != b'_' {\n-                span_lint_and_sugg(\n-                    cx,\n-                    UNSEPARATED_LITERAL_SUFFIX,\n-                    lit.span,\n-                    \"integer type suffix should be separated by an underscore\",\n-                    \"add an underscore\",\n-                    format!(\"{}_{}\", &lit_snip[..=maybe_last_sep_idx], suffix),\n-                    Applicability::MachineApplicable,\n-                );\n-            }\n-\n-            if lit_snip.starts_with(\"0x\") {\n-                if maybe_last_sep_idx <= 2 {\n-                    // It's meaningless or causes range error.\n-                    return;\n-                }\n-                let mut seen = (false, false);\n-                for ch in lit_snip.as_bytes()[2..=maybe_last_sep_idx].iter() {\n-                    match ch {\n-                        b'a'..=b'f' => seen.0 = true,\n-                        b'A'..=b'F' => seen.1 = true,\n-                        _ => {},\n-                    }\n-                    if seen.0 && seen.1 {\n-                        span_lint(\n-                            cx,\n-                            MIXED_CASE_HEX_LITERALS,\n-                            lit.span,\n-                            \"inconsistent casing in hexadecimal literal\",\n-                        );\n-                        break;\n-                    }\n-                }\n-            } else if lit_snip.starts_with(\"0b\") || lit_snip.starts_with(\"0o\") {\n-                /* nothing to do */\n-            } else if value != 0 && lit_snip.starts_with('0') {\n-                span_lint_and_then(\n-                    cx,\n-                    ZERO_PREFIXED_LITERAL,\n-                    lit.span,\n-                    \"this is a decimal constant\",\n-                    |diag| {\n-                        diag.span_suggestion(\n-                            lit.span,\n-                            \"if you mean to use a decimal constant, remove the `0` to avoid confusion\",\n-                            lit_snip.trim_start_matches(|c| c == '_' || c == '0').to_string(),\n-                            Applicability::MaybeIncorrect,\n-                        );\n-                        diag.span_suggestion(\n-                            lit.span,\n-                            \"if you mean to use an octal constant, use `0o`\",\n-                            format!(\"0o{}\", lit_snip.trim_start_matches(|c| c == '_' || c == '0')),\n-                            Applicability::MaybeIncorrect,\n-                        );\n-                    },\n-                );\n-            }\n-        } else if let LitKind::Float(_, LitFloatType::Suffixed(float_ty)) = lit.kind {\n-            let suffix = float_ty.name_str();\n-            let maybe_last_sep_idx = if let Some(val) = lit_snip.len().checked_sub(suffix.len() + 1) {\n-                val\n-            } else {\n-                return; // It's useless so shouldn't lint.\n-            };\n-            if lit_snip.as_bytes()[maybe_last_sep_idx] != b'_' {\n-                span_lint_and_sugg(\n-                    cx,\n-                    UNSEPARATED_LITERAL_SUFFIX,\n-                    lit.span,\n-                    \"float type suffix should be separated by an underscore\",\n-                    \"add an underscore\",\n-                    format!(\"{}_{}\", &lit_snip[..=maybe_last_sep_idx], suffix),\n-                    Applicability::MachineApplicable,\n-                );\n-            }\n-        }\n-    }\n-}\n-\n-fn check_unneeded_wildcard_pattern(cx: &EarlyContext<'_>, pat: &Pat) {\n-    if let PatKind::TupleStruct(_, ref patterns) | PatKind::Tuple(ref patterns) = pat.kind {\n-        fn span_lint(cx: &EarlyContext<'_>, span: Span, only_one: bool) {\n-            span_lint_and_sugg(\n-                cx,\n-                UNNEEDED_WILDCARD_PATTERN,\n-                span,\n-                if only_one {\n-                    \"this pattern is unneeded as the `..` pattern can match that element\"\n-                } else {\n-                    \"these patterns are unneeded as the `..` pattern can match those elements\"\n-                },\n-                if only_one { \"remove it\" } else { \"remove them\" },\n-                \"\".to_string(),\n-                Applicability::MachineApplicable,\n-            );\n-        }\n-\n-        if let Some(rest_index) = patterns.iter().position(|pat| pat.is_rest()) {\n-            if let Some((left_index, left_pat)) = patterns[..rest_index]\n-                .iter()\n-                .rev()\n-                .take_while(|pat| matches!(pat.kind, PatKind::Wild))\n-                .enumerate()\n-                .last()\n-            {\n-                span_lint(cx, left_pat.span.until(patterns[rest_index].span), left_index == 0);\n-            }\n-\n-            if let Some((right_index, right_pat)) = patterns[rest_index + 1..]\n-                .iter()\n-                .take_while(|pat| matches!(pat.kind, PatKind::Wild))\n-                .enumerate()\n-                .last()\n-            {\n-                span_lint(\n-                    cx,\n-                    patterns[rest_index].span.shrink_to_hi().to(right_pat.span),\n-                    right_index == 0,\n-                );\n-            }\n-        }\n-    }\n-}"}, {"sha": "9f6b0bdc7a45a83335b51dbce36113e537ec7f80", "filename": "clippy_lints/src/misc_early/builtin_type_shadow.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/d6058820237893566670d828c900de61c8e8f8af/clippy_lints%2Fsrc%2Fmisc_early%2Fbuiltin_type_shadow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6058820237893566670d828c900de61c8e8f8af/clippy_lints%2Fsrc%2Fmisc_early%2Fbuiltin_type_shadow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmisc_early%2Fbuiltin_type_shadow.rs?ref=d6058820237893566670d828c900de61c8e8f8af", "patch": "@@ -0,0 +1,19 @@\n+use clippy_utils::diagnostics::span_lint;\n+use rustc_ast::ast::{GenericParam, GenericParamKind};\n+use rustc_hir::PrimTy;\n+use rustc_lint::EarlyContext;\n+\n+use super::BUILTIN_TYPE_SHADOW;\n+\n+pub(super) fn check(cx: &EarlyContext<'_>, param: &GenericParam) {\n+    if let GenericParamKind::Type { .. } = param.kind {\n+        if let Some(prim_ty) = PrimTy::from_name(param.ident.name) {\n+            span_lint(\n+                cx,\n+                BUILTIN_TYPE_SHADOW,\n+                param.ident.span,\n+                &format!(\"this generic shadows the built-in type `{}`\", prim_ty.name()),\n+            );\n+        }\n+    }\n+}"}, {"sha": "6f65778e1193cfc08d011e0eec606f08e683bf6a", "filename": "clippy_lints/src/misc_early/double_neg.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/d6058820237893566670d828c900de61c8e8f8af/clippy_lints%2Fsrc%2Fmisc_early%2Fdouble_neg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6058820237893566670d828c900de61c8e8f8af/clippy_lints%2Fsrc%2Fmisc_early%2Fdouble_neg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmisc_early%2Fdouble_neg.rs?ref=d6058820237893566670d828c900de61c8e8f8af", "patch": "@@ -0,0 +1,23 @@\n+use super::MiscEarlyLints;\n+use clippy_utils::diagnostics::span_lint;\n+use rustc_ast::ast::{Expr, ExprKind, UnOp};\n+use rustc_lint::EarlyContext;\n+\n+use super::DOUBLE_NEG;\n+\n+pub(super) fn check(cx: &EarlyContext<'_>, expr: &Expr) {\n+    match expr.kind {\n+        ExprKind::Unary(UnOp::Neg, ref inner) => {\n+            if let ExprKind::Unary(UnOp::Neg, _) = inner.kind {\n+                span_lint(\n+                    cx,\n+                    DOUBLE_NEG,\n+                    expr.span,\n+                    \"`--x` could be misinterpreted as pre-decrement by C programmers, is usually a no-op\",\n+                );\n+            }\n+        },\n+        ExprKind::Lit(ref lit) => MiscEarlyLints::check_lit(cx, lit),\n+        _ => (),\n+    }\n+}"}, {"sha": "80e24213100787f572d6e237b1d86f223ed6034a", "filename": "clippy_lints/src/misc_early/mixed_case_hex_literals.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/d6058820237893566670d828c900de61c8e8f8af/clippy_lints%2Fsrc%2Fmisc_early%2Fmixed_case_hex_literals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6058820237893566670d828c900de61c8e8f8af/clippy_lints%2Fsrc%2Fmisc_early%2Fmixed_case_hex_literals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmisc_early%2Fmixed_case_hex_literals.rs?ref=d6058820237893566670d828c900de61c8e8f8af", "patch": "@@ -0,0 +1,34 @@\n+use clippy_utils::diagnostics::span_lint;\n+use rustc_ast::ast::Lit;\n+use rustc_lint::EarlyContext;\n+\n+use super::MIXED_CASE_HEX_LITERALS;\n+\n+pub(super) fn check(cx: &EarlyContext<'_>, lit: &Lit, suffix: &str, lit_snip: &str) {\n+    let maybe_last_sep_idx = if let Some(val) = lit_snip.len().checked_sub(suffix.len() + 1) {\n+        val\n+    } else {\n+        return; // It's useless so shouldn't lint.\n+    };\n+    if maybe_last_sep_idx <= 2 {\n+        // It's meaningless or causes range error.\n+        return;\n+    }\n+    let mut seen = (false, false);\n+    for ch in lit_snip.as_bytes()[2..=maybe_last_sep_idx].iter() {\n+        match ch {\n+            b'a'..=b'f' => seen.0 = true,\n+            b'A'..=b'F' => seen.1 = true,\n+            _ => {},\n+        }\n+        if seen.0 && seen.1 {\n+            span_lint(\n+                cx,\n+                MIXED_CASE_HEX_LITERALS,\n+                lit.span,\n+                \"inconsistent casing in hexadecimal literal\",\n+            );\n+            break;\n+        }\n+    }\n+}"}, {"sha": "dd38316fa25b0cea0f8334e76a2a8ae20d1351a1", "filename": "clippy_lints/src/misc_early/mod.rs", "status": "added", "additions": 348, "deletions": 0, "changes": 348, "blob_url": "https://github.com/rust-lang/rust/blob/d6058820237893566670d828c900de61c8e8f8af/clippy_lints%2Fsrc%2Fmisc_early%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6058820237893566670d828c900de61c8e8f8af/clippy_lints%2Fsrc%2Fmisc_early%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmisc_early%2Fmod.rs?ref=d6058820237893566670d828c900de61c8e8f8af", "patch": "@@ -0,0 +1,348 @@\n+mod builtin_type_shadow;\n+mod double_neg;\n+mod mixed_case_hex_literals;\n+mod redundant_pattern;\n+mod unneeded_field_pattern;\n+mod unneeded_wildcard_pattern;\n+mod unseparated_literal_suffix;\n+mod zero_prefixed_literal;\n+\n+use clippy_utils::diagnostics::span_lint;\n+use clippy_utils::source::snippet_opt;\n+use rustc_ast::ast::{Expr, Generics, Lit, LitFloatType, LitIntType, LitKind, NodeId, Pat, PatKind};\n+use rustc_ast::visit::FnKind;\n+use rustc_data_structures::fx::FxHashMap;\n+use rustc_lint::{EarlyContext, EarlyLintPass, LintContext};\n+use rustc_middle::lint::in_external_macro;\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::source_map::Span;\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for structure field patterns bound to wildcards.\n+    ///\n+    /// **Why is this bad?** Using `..` instead is shorter and leaves the focus on\n+    /// the fields that are actually bound.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// # struct Foo {\n+    /// #     a: i32,\n+    /// #     b: i32,\n+    /// #     c: i32,\n+    /// # }\n+    /// let f = Foo { a: 0, b: 0, c: 0 };\n+    ///\n+    /// // Bad\n+    /// match f {\n+    ///     Foo { a: _, b: 0, .. } => {},\n+    ///     Foo { a: _, b: _, c: _ } => {},\n+    /// }\n+    ///\n+    /// // Good\n+    /// match f {\n+    ///     Foo { b: 0, .. } => {},\n+    ///     Foo { .. } => {},\n+    /// }\n+    /// ```\n+    pub UNNEEDED_FIELD_PATTERN,\n+    restriction,\n+    \"struct fields bound to a wildcard instead of using `..`\"\n+}\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for function arguments having the similar names\n+    /// differing by an underscore.\n+    ///\n+    /// **Why is this bad?** It affects code readability.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// // Bad\n+    /// fn foo(a: i32, _a: i32) {}\n+    ///\n+    /// // Good\n+    /// fn bar(a: i32, _b: i32) {}\n+    /// ```\n+    pub DUPLICATE_UNDERSCORE_ARGUMENT,\n+    style,\n+    \"function arguments having names which only differ by an underscore\"\n+}\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Detects expressions of the form `--x`.\n+    ///\n+    /// **Why is this bad?** It can mislead C/C++ programmers to think `x` was\n+    /// decremented.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// let mut x = 3;\n+    /// --x;\n+    /// ```\n+    pub DOUBLE_NEG,\n+    style,\n+    \"`--x`, which is a double negation of `x` and not a pre-decrement as in C/C++\"\n+}\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Warns on hexadecimal literals with mixed-case letter\n+    /// digits.\n+    ///\n+    /// **Why is this bad?** It looks confusing.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// // Bad\n+    /// let y = 0x1a9BAcD;\n+    ///\n+    /// // Good\n+    /// let y = 0x1A9BACD;\n+    /// ```\n+    pub MIXED_CASE_HEX_LITERALS,\n+    style,\n+    \"hex literals whose letter digits are not consistently upper- or lowercased\"\n+}\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Warns if literal suffixes are not separated by an\n+    /// underscore.\n+    ///\n+    /// **Why is this bad?** It is much less readable.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// // Bad\n+    /// let y = 123832i32;\n+    ///\n+    /// // Good\n+    /// let y = 123832_i32;\n+    /// ```\n+    pub UNSEPARATED_LITERAL_SUFFIX,\n+    pedantic,\n+    \"literals whose suffix is not separated by an underscore\"\n+}\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Warns if an integral constant literal starts with `0`.\n+    ///\n+    /// **Why is this bad?** In some languages (including the infamous C language\n+    /// and most of its\n+    /// family), this marks an octal constant. In Rust however, this is a decimal\n+    /// constant. This could\n+    /// be confusing for both the writer and a reader of the constant.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    ///\n+    /// In Rust:\n+    /// ```rust\n+    /// fn main() {\n+    ///     let a = 0123;\n+    ///     println!(\"{}\", a);\n+    /// }\n+    /// ```\n+    ///\n+    /// prints `123`, while in C:\n+    ///\n+    /// ```c\n+    /// #include <stdio.h>\n+    ///\n+    /// int main() {\n+    ///     int a = 0123;\n+    ///     printf(\"%d\\n\", a);\n+    /// }\n+    /// ```\n+    ///\n+    /// prints `83` (as `83 == 0o123` while `123 == 0o173`).\n+    pub ZERO_PREFIXED_LITERAL,\n+    complexity,\n+    \"integer literals starting with `0`\"\n+}\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Warns if a generic shadows a built-in type.\n+    ///\n+    /// **Why is this bad?** This gives surprising type errors.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    ///\n+    /// ```ignore\n+    /// impl<u32> Foo<u32> {\n+    ///     fn impl_func(&self) -> u32 {\n+    ///         42\n+    ///     }\n+    /// }\n+    /// ```\n+    pub BUILTIN_TYPE_SHADOW,\n+    style,\n+    \"shadowing a builtin type\"\n+}\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for patterns in the form `name @ _`.\n+    ///\n+    /// **Why is this bad?** It's almost always more readable to just use direct\n+    /// bindings.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// # let v = Some(\"abc\");\n+    ///\n+    /// // Bad\n+    /// match v {\n+    ///     Some(x) => (),\n+    ///     y @ _ => (),\n+    /// }\n+    ///\n+    /// // Good\n+    /// match v {\n+    ///     Some(x) => (),\n+    ///     y => (),\n+    /// }\n+    /// ```\n+    pub REDUNDANT_PATTERN,\n+    style,\n+    \"using `name @ _` in a pattern\"\n+}\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for tuple patterns with a wildcard\n+    /// pattern (`_`) is next to a rest pattern (`..`).\n+    ///\n+    /// _NOTE_: While `_, ..` means there is at least one element left, `..`\n+    /// means there are 0 or more elements left. This can make a difference\n+    /// when refactoring, but shouldn't result in errors in the refactored code,\n+    /// since the wildcard pattern isn't used anyway.\n+    /// **Why is this bad?** The wildcard pattern is unneeded as the rest pattern\n+    /// can match that element as well.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// # struct TupleStruct(u32, u32, u32);\n+    /// # let t = TupleStruct(1, 2, 3);\n+    /// // Bad\n+    /// match t {\n+    ///     TupleStruct(0, .., _) => (),\n+    ///     _ => (),\n+    /// }\n+    ///\n+    /// // Good\n+    /// match t {\n+    ///     TupleStruct(0, ..) => (),\n+    ///     _ => (),\n+    /// }\n+    /// ```\n+    pub UNNEEDED_WILDCARD_PATTERN,\n+    complexity,\n+    \"tuple patterns with a wildcard pattern (`_`) is next to a rest pattern (`..`)\"\n+}\n+\n+declare_lint_pass!(MiscEarlyLints => [\n+    UNNEEDED_FIELD_PATTERN,\n+    DUPLICATE_UNDERSCORE_ARGUMENT,\n+    DOUBLE_NEG,\n+    MIXED_CASE_HEX_LITERALS,\n+    UNSEPARATED_LITERAL_SUFFIX,\n+    ZERO_PREFIXED_LITERAL,\n+    BUILTIN_TYPE_SHADOW,\n+    REDUNDANT_PATTERN,\n+    UNNEEDED_WILDCARD_PATTERN,\n+]);\n+\n+impl EarlyLintPass for MiscEarlyLints {\n+    fn check_generics(&mut self, cx: &EarlyContext<'_>, gen: &Generics) {\n+        for param in &gen.params {\n+            builtin_type_shadow::check(cx, param);\n+        }\n+    }\n+\n+    fn check_pat(&mut self, cx: &EarlyContext<'_>, pat: &Pat) {\n+        unneeded_field_pattern::check(cx, pat);\n+        redundant_pattern::check(cx, pat);\n+        unneeded_wildcard_pattern::check(cx, pat);\n+    }\n+\n+    fn check_fn(&mut self, cx: &EarlyContext<'_>, fn_kind: FnKind<'_>, _: Span, _: NodeId) {\n+        let mut registered_names: FxHashMap<String, Span> = FxHashMap::default();\n+\n+        for arg in &fn_kind.decl().inputs {\n+            if let PatKind::Ident(_, ident, None) = arg.pat.kind {\n+                let arg_name = ident.to_string();\n+\n+                if let Some(arg_name) = arg_name.strip_prefix('_') {\n+                    if let Some(correspondence) = registered_names.get(arg_name) {\n+                        span_lint(\n+                            cx,\n+                            DUPLICATE_UNDERSCORE_ARGUMENT,\n+                            *correspondence,\n+                            &format!(\n+                                \"`{}` already exists, having another argument having almost the same \\\n+                                 name makes code comprehension and documentation more difficult\",\n+                                arg_name\n+                            ),\n+                        );\n+                    }\n+                } else {\n+                    registered_names.insert(arg_name, arg.pat.span);\n+                }\n+            }\n+        }\n+    }\n+\n+    fn check_expr(&mut self, cx: &EarlyContext<'_>, expr: &Expr) {\n+        if in_external_macro(cx.sess(), expr.span) {\n+            return;\n+        }\n+        double_neg::check(cx, expr)\n+    }\n+}\n+\n+impl MiscEarlyLints {\n+    fn check_lit(cx: &EarlyContext<'_>, lit: &Lit) {\n+        // We test if first character in snippet is a number, because the snippet could be an expansion\n+        // from a built-in macro like `line!()` or a proc-macro like `#[wasm_bindgen]`.\n+        // Note that this check also covers special case that `line!()` is eagerly expanded by compiler.\n+        // See <https://github.com/rust-lang/rust-clippy/issues/4507> for a regression.\n+        // FIXME: Find a better way to detect those cases.\n+        let lit_snip = match snippet_opt(cx, lit.span) {\n+            Some(snip) if snip.chars().next().map_or(false, |c| c.is_digit(10)) => snip,\n+            _ => return,\n+        };\n+\n+        if let LitKind::Int(value, lit_int_type) = lit.kind {\n+            let suffix = match lit_int_type {\n+                LitIntType::Signed(ty) => ty.name_str(),\n+                LitIntType::Unsigned(ty) => ty.name_str(),\n+                LitIntType::Unsuffixed => \"\",\n+            };\n+            unseparated_literal_suffix::check(cx, lit, &lit_snip, suffix, \"integer\");\n+            if lit_snip.starts_with(\"0x\") {\n+                mixed_case_hex_literals::check(cx, lit, suffix, &lit_snip)\n+            } else if lit_snip.starts_with(\"0b\") || lit_snip.starts_with(\"0o\") {\n+                /* nothing to do */\n+            } else if value != 0 && lit_snip.starts_with('0') {\n+                zero_prefixed_literal::check(cx, lit, &lit_snip)\n+            }\n+        } else if let LitKind::Float(_, LitFloatType::Suffixed(float_ty)) = lit.kind {\n+            let suffix = float_ty.name_str();\n+            unseparated_literal_suffix::check(cx, lit, &lit_snip, suffix, \"float\")\n+        }\n+    }\n+}"}, {"sha": "525dbf7757c14c3c7e97cbffad764fca4d51a442", "filename": "clippy_lints/src/misc_early/redundant_pattern.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/d6058820237893566670d828c900de61c8e8f8af/clippy_lints%2Fsrc%2Fmisc_early%2Fredundant_pattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6058820237893566670d828c900de61c8e8f8af/clippy_lints%2Fsrc%2Fmisc_early%2Fredundant_pattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmisc_early%2Fredundant_pattern.rs?ref=d6058820237893566670d828c900de61c8e8f8af", "patch": "@@ -0,0 +1,31 @@\n+use clippy_utils::diagnostics::span_lint_and_sugg;\n+use rustc_ast::ast::{BindingMode, Mutability, Pat, PatKind};\n+use rustc_errors::Applicability;\n+use rustc_lint::EarlyContext;\n+\n+use super::REDUNDANT_PATTERN;\n+\n+pub(super) fn check(cx: &EarlyContext<'_>, pat: &Pat) {\n+    if let PatKind::Ident(left, ident, Some(ref right)) = pat.kind {\n+        let left_binding = match left {\n+            BindingMode::ByRef(Mutability::Mut) => \"ref mut \",\n+            BindingMode::ByRef(Mutability::Not) => \"ref \",\n+            BindingMode::ByValue(..) => \"\",\n+        };\n+\n+        if let PatKind::Wild = right.kind {\n+            span_lint_and_sugg(\n+                cx,\n+                REDUNDANT_PATTERN,\n+                pat.span,\n+                &format!(\n+                    \"the `{} @ _` pattern can be written as just `{}`\",\n+                    ident.name, ident.name,\n+                ),\n+                \"try\",\n+                format!(\"{}{}\", left_binding, ident.name),\n+                Applicability::MachineApplicable,\n+            );\n+        }\n+    }\n+}"}, {"sha": "329a0009a3e2cfc014aa00a1a92f8b37996926ed", "filename": "clippy_lints/src/misc_early/unneeded_field_pattern.rs", "status": "added", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/d6058820237893566670d828c900de61c8e8f8af/clippy_lints%2Fsrc%2Fmisc_early%2Funneeded_field_pattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6058820237893566670d828c900de61c8e8f8af/clippy_lints%2Fsrc%2Fmisc_early%2Funneeded_field_pattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmisc_early%2Funneeded_field_pattern.rs?ref=d6058820237893566670d828c900de61c8e8f8af", "patch": "@@ -0,0 +1,72 @@\n+use clippy_utils::diagnostics::{span_lint, span_lint_and_help};\n+use rustc_ast::ast::{Pat, PatKind};\n+use rustc_lint::{EarlyContext, LintContext};\n+\n+use super::UNNEEDED_FIELD_PATTERN;\n+\n+pub(super) fn check(cx: &EarlyContext<'_>, pat: &Pat) {\n+    if let PatKind::Struct(ref npat, ref pfields, _) = pat.kind {\n+        let mut wilds = 0;\n+        let type_name = npat\n+            .segments\n+            .last()\n+            .expect(\"A path must have at least one segment\")\n+            .ident\n+            .name;\n+\n+        for field in pfields {\n+            if let PatKind::Wild = field.pat.kind {\n+                wilds += 1;\n+            }\n+        }\n+        if !pfields.is_empty() && wilds == pfields.len() {\n+            span_lint_and_help(\n+                cx,\n+                UNNEEDED_FIELD_PATTERN,\n+                pat.span,\n+                \"all the struct fields are matched to a wildcard pattern, consider using `..`\",\n+                None,\n+                &format!(\"try with `{} {{ .. }}` instead\", type_name),\n+            );\n+            return;\n+        }\n+        if wilds > 0 {\n+            for field in pfields {\n+                if let PatKind::Wild = field.pat.kind {\n+                    wilds -= 1;\n+                    if wilds > 0 {\n+                        span_lint(\n+                            cx,\n+                            UNNEEDED_FIELD_PATTERN,\n+                            field.span,\n+                            \"you matched a field with a wildcard pattern, consider using `..` instead\",\n+                        );\n+                    } else {\n+                        let mut normal = vec![];\n+\n+                        for field in pfields {\n+                            match field.pat.kind {\n+                                PatKind::Wild => {},\n+                                _ => {\n+                                    if let Ok(n) = cx.sess().source_map().span_to_snippet(field.span) {\n+                                        normal.push(n);\n+                                    }\n+                                },\n+                            }\n+                        }\n+\n+                        span_lint_and_help(\n+                            cx,\n+                            UNNEEDED_FIELD_PATTERN,\n+                            field.span,\n+                            \"you matched a field with a wildcard pattern, consider using `..` \\\n+                             instead\",\n+                            None,\n+                            &format!(\"try with `{} {{ {}, .. }}`\", type_name, normal[..].join(\", \")),\n+                        );\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}"}, {"sha": "4dd032d78f1d55f2651b43114036634c99e5bcf7", "filename": "clippy_lints/src/misc_early/unneeded_wildcard_pattern.rs", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/d6058820237893566670d828c900de61c8e8f8af/clippy_lints%2Fsrc%2Fmisc_early%2Funneeded_wildcard_pattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6058820237893566670d828c900de61c8e8f8af/clippy_lints%2Fsrc%2Fmisc_early%2Funneeded_wildcard_pattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmisc_early%2Funneeded_wildcard_pattern.rs?ref=d6058820237893566670d828c900de61c8e8f8af", "patch": "@@ -0,0 +1,52 @@\n+use clippy_utils::diagnostics::span_lint_and_sugg;\n+use rustc_ast::ast::{Pat, PatKind};\n+use rustc_errors::Applicability;\n+use rustc_lint::EarlyContext;\n+use rustc_span::source_map::Span;\n+\n+use super::UNNEEDED_WILDCARD_PATTERN;\n+\n+pub(super) fn check(cx: &EarlyContext<'_>, pat: &Pat) {\n+    if let PatKind::TupleStruct(_, ref patterns) | PatKind::Tuple(ref patterns) = pat.kind {\n+        if let Some(rest_index) = patterns.iter().position(|pat| pat.is_rest()) {\n+            if let Some((left_index, left_pat)) = patterns[..rest_index]\n+                .iter()\n+                .rev()\n+                .take_while(|pat| matches!(pat.kind, PatKind::Wild))\n+                .enumerate()\n+                .last()\n+            {\n+                span_lint(cx, left_pat.span.until(patterns[rest_index].span), left_index == 0);\n+            }\n+\n+            if let Some((right_index, right_pat)) = patterns[rest_index + 1..]\n+                .iter()\n+                .take_while(|pat| matches!(pat.kind, PatKind::Wild))\n+                .enumerate()\n+                .last()\n+            {\n+                span_lint(\n+                    cx,\n+                    patterns[rest_index].span.shrink_to_hi().to(right_pat.span),\n+                    right_index == 0,\n+                );\n+            }\n+        }\n+    }\n+}\n+\n+fn span_lint(cx: &EarlyContext<'_>, span: Span, only_one: bool) {\n+    span_lint_and_sugg(\n+        cx,\n+        UNNEEDED_WILDCARD_PATTERN,\n+        span,\n+        if only_one {\n+            \"this pattern is unneeded as the `..` pattern can match that element\"\n+        } else {\n+            \"these patterns are unneeded as the `..` pattern can match those elements\"\n+        },\n+        if only_one { \"remove it\" } else { \"remove them\" },\n+        \"\".to_string(),\n+        Applicability::MachineApplicable,\n+    );\n+}"}, {"sha": "2018aa6184a8db4568f751017d6e5514cbcda95f", "filename": "clippy_lints/src/misc_early/unseparated_literal_suffix.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/d6058820237893566670d828c900de61c8e8f8af/clippy_lints%2Fsrc%2Fmisc_early%2Funseparated_literal_suffix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6058820237893566670d828c900de61c8e8f8af/clippy_lints%2Fsrc%2Fmisc_early%2Funseparated_literal_suffix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmisc_early%2Funseparated_literal_suffix.rs?ref=d6058820237893566670d828c900de61c8e8f8af", "patch": "@@ -0,0 +1,26 @@\n+use clippy_utils::diagnostics::span_lint_and_sugg;\n+use rustc_ast::ast::Lit;\n+use rustc_errors::Applicability;\n+use rustc_lint::EarlyContext;\n+\n+use super::UNSEPARATED_LITERAL_SUFFIX;\n+\n+pub(super) fn check(cx: &EarlyContext<'_>, lit: &Lit, lit_snip: &str, suffix: &str, sugg_type: &str) {\n+    let maybe_last_sep_idx = if let Some(val) = lit_snip.len().checked_sub(suffix.len() + 1) {\n+        val\n+    } else {\n+        return; // It's useless so shouldn't lint.\n+    };\n+    // Do not lint when literal is unsuffixed.\n+    if !suffix.is_empty() && lit_snip.as_bytes()[maybe_last_sep_idx] != b'_' {\n+        span_lint_and_sugg(\n+            cx,\n+            UNSEPARATED_LITERAL_SUFFIX,\n+            lit.span,\n+            &format!(\"{} type suffix should be separated by an underscore\", sugg_type),\n+            \"add an underscore\",\n+            format!(\"{}_{}\", &lit_snip[..=maybe_last_sep_idx], suffix),\n+            Applicability::MachineApplicable,\n+        );\n+    }\n+}"}, {"sha": "4963bba82f2da169887da3f88a3a5c7641a64000", "filename": "clippy_lints/src/misc_early/zero_prefixed_literal.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/d6058820237893566670d828c900de61c8e8f8af/clippy_lints%2Fsrc%2Fmisc_early%2Fzero_prefixed_literal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6058820237893566670d828c900de61c8e8f8af/clippy_lints%2Fsrc%2Fmisc_early%2Fzero_prefixed_literal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmisc_early%2Fzero_prefixed_literal.rs?ref=d6058820237893566670d828c900de61c8e8f8af", "patch": "@@ -0,0 +1,29 @@\n+use clippy_utils::diagnostics::span_lint_and_then;\n+use rustc_ast::ast::Lit;\n+use rustc_errors::Applicability;\n+use rustc_lint::EarlyContext;\n+\n+use super::ZERO_PREFIXED_LITERAL;\n+\n+pub(super) fn check(cx: &EarlyContext<'_>, lit: &Lit, lit_snip: &str) {\n+    span_lint_and_then(\n+        cx,\n+        ZERO_PREFIXED_LITERAL,\n+        lit.span,\n+        \"this is a decimal constant\",\n+        |diag| {\n+            diag.span_suggestion(\n+                lit.span,\n+                \"if you mean to use a decimal constant, remove the `0` to avoid confusion\",\n+                lit_snip.trim_start_matches(|c| c == '_' || c == '0').to_string(),\n+                Applicability::MaybeIncorrect,\n+            );\n+            diag.span_suggestion(\n+                lit.span,\n+                \"if you mean to use an octal constant, use `0o`\",\n+                format!(\"0o{}\", lit_snip.trim_start_matches(|c| c == '_' || c == '0')),\n+                Applicability::MaybeIncorrect,\n+            );\n+        },\n+    );\n+}"}, {"sha": "a9ae2b77119bcaa1bda2f9d9d6bfa4264c2b2899", "filename": "clippy_lints/src/slow_vector_initialization.rs", "status": "modified", "additions": 6, "deletions": 16, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/d6058820237893566670d828c900de61c8e8f8af/clippy_lints%2Fsrc%2Fslow_vector_initialization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6058820237893566670d828c900de61c8e8f8af/clippy_lints%2Fsrc%2Fslow_vector_initialization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fslow_vector_initialization.rs?ref=d6058820237893566670d828c900de61c8e8f8af", "patch": "@@ -7,7 +7,7 @@ use rustc_ast::ast::LitKind;\n use rustc_errors::Applicability;\n use rustc_hir::intravisit::{walk_block, walk_expr, walk_stmt, NestedVisitorMap, Visitor};\n use rustc_hir::{BindingAnnotation, Block, Expr, ExprKind, HirId, PatKind, QPath, Stmt, StmtKind};\n-use rustc_lint::{LateContext, LateLintPass, Lint};\n+use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::hir::map::Map;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::symbol::sym;\n@@ -157,26 +157,16 @@ impl SlowVectorInit {\n         vec_alloc: &VecAllocation<'_>,\n     ) {\n         match initialization {\n-            InitializationType::Extend(e) | InitializationType::Resize(e) => Self::emit_lint(\n-                cx,\n-                e,\n-                vec_alloc,\n-                \"slow zero-filling initialization\",\n-                SLOW_VECTOR_INITIALIZATION,\n-            ),\n+            InitializationType::Extend(e) | InitializationType::Resize(e) => {\n+                Self::emit_lint(cx, e, vec_alloc, \"slow zero-filling initialization\")\n+            },\n         };\n     }\n \n-    fn emit_lint<'tcx>(\n-        cx: &LateContext<'tcx>,\n-        slow_fill: &Expr<'_>,\n-        vec_alloc: &VecAllocation<'_>,\n-        msg: &str,\n-        lint: &'static Lint,\n-    ) {\n+    fn emit_lint<'tcx>(cx: &LateContext<'tcx>, slow_fill: &Expr<'_>, vec_alloc: &VecAllocation<'_>, msg: &str) {\n         let len_expr = Sugg::hir(cx, vec_alloc.len_expr, \"len\");\n \n-        span_lint_and_then(cx, lint, slow_fill.span, msg, |diag| {\n+        span_lint_and_then(cx, SLOW_VECTOR_INITIALIZATION, slow_fill.span, msg, |diag| {\n             diag.span_suggestion(\n                 vec_alloc.allocation_expr.span,\n                 \"consider replace allocation with\","}, {"sha": "e14945651f5010551820308a272693951cc992ab", "filename": "clippy_lints/src/unused_unit.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d6058820237893566670d828c900de61c8e8f8af/clippy_lints%2Fsrc%2Funused_unit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6058820237893566670d828c900de61c8e8f8af/clippy_lints%2Fsrc%2Funused_unit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funused_unit.rs?ref=d6058820237893566670d828c900de61c8e8f8af", "patch": "@@ -47,7 +47,9 @@ impl EarlyLintPass for UnusedUnit {\n         if_chain! {\n             if let Some(stmt) = block.stmts.last();\n             if let ast::StmtKind::Expr(ref expr) = stmt.kind;\n-            if is_unit_expr(expr) && !stmt.span.from_expansion();\n+            if is_unit_expr(expr);\n+            let ctxt = block.span.ctxt();\n+            if stmt.span.ctxt() == ctxt && expr.span.ctxt() == ctxt;\n             then {\n                 let sp = expr.span;\n                 span_lint_and_sugg("}, {"sha": "52c1dc3bdd239335438e40463066087a52d6b35f", "filename": "clippy_lints/src/utils/conf.rs", "status": "modified", "additions": 103, "deletions": 151, "changes": 254, "blob_url": "https://github.com/rust-lang/rust/blob/d6058820237893566670d828c900de61c8e8f8af/clippy_lints%2Fsrc%2Futils%2Fconf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6058820237893566670d828c900de61c8e8f8af/clippy_lints%2Fsrc%2Futils%2Fconf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fconf.rs?ref=d6058820237893566670d828c900de61c8e8f8af", "patch": "@@ -1,121 +1,110 @@\n //! Read configurations files.\n \n-#![deny(clippy::missing_docs_in_private_items)]\n+#![allow(clippy::module_name_repetitions)]\n \n-use rustc_ast::ast::{LitKind, MetaItemKind, NestedMetaItem};\n-use rustc_span::source_map;\n-use source_map::Span;\n-use std::lazy::SyncLazy;\n+use serde::de::{Deserializer, IgnoredAny, IntoDeserializer, MapAccess, Visitor};\n+use serde::Deserialize;\n+use std::error::Error;\n use std::path::{Path, PathBuf};\n-use std::sync::Mutex;\n use std::{env, fmt, fs, io};\n \n-/// Gets the configuration file from arguments.\n-pub fn file_from_args(args: &[NestedMetaItem]) -> Result<Option<PathBuf>, (&'static str, Span)> {\n-    for arg in args.iter().filter_map(NestedMetaItem::meta_item) {\n-        if arg.has_name(sym!(conf_file)) {\n-            return match arg.kind {\n-                MetaItemKind::Word | MetaItemKind::List(_) => Err((\"`conf_file` must be a named value\", arg.span)),\n-                MetaItemKind::NameValue(ref value) => {\n-                    if let LitKind::Str(ref file, _) = value.kind {\n-                        Ok(Some(file.to_string().into()))\n-                    } else {\n-                        Err((\"`conf_file` value must be a string\", value.span))\n-                    }\n-                },\n-            };\n-        }\n-    }\n-\n-    Ok(None)\n-}\n-\n-/// Error from reading a configuration file.\n-#[derive(Debug)]\n-pub enum Error {\n-    /// An I/O error.\n-    Io(io::Error),\n-    /// Not valid toml or doesn't fit the expected config format\n-    Toml(String),\n+/// Conf with parse errors\n+#[derive(Default)]\n+pub struct TryConf {\n+    pub conf: Conf,\n+    pub errors: Vec<String>,\n }\n \n-impl fmt::Display for Error {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        match self {\n-            Self::Io(err) => err.fmt(f),\n-            Self::Toml(err) => err.fmt(f),\n+impl TryConf {\n+    fn from_error(error: impl Error) -> Self {\n+        Self {\n+            conf: Conf::default(),\n+            errors: vec![error.to_string()],\n         }\n     }\n }\n \n-impl From<io::Error> for Error {\n-    fn from(e: io::Error) -> Self {\n-        Self::Io(e)\n-    }\n-}\n+macro_rules! define_Conf {\n+    ($(\n+        #[$doc:meta]\n+        $(#[conf_deprecated($dep:literal)])?\n+        ($name:ident: $ty:ty = $default:expr),\n+    )*) => {\n+        /// Clippy lint configuration\n+        pub struct Conf {\n+            $(#[$doc] pub $name: $ty,)*\n+        }\n \n-/// Vec of errors that might be collected during config toml parsing\n-static ERRORS: SyncLazy<Mutex<Vec<Error>>> = SyncLazy::new(|| Mutex::new(Vec::new()));\n+        mod defaults {\n+            $(pub fn $name() -> $ty { $default })*\n+        }\n \n-macro_rules! define_Conf {\n-    ($(#[$doc:meta] ($config:ident, $config_str:literal: $Ty:ty, $default:expr),)+) => {\n-        mod helpers {\n-            use serde::Deserialize;\n-            /// Type used to store lint configuration.\n-            #[derive(Deserialize)]\n-            #[serde(rename_all = \"kebab-case\", deny_unknown_fields)]\n-            pub struct Conf {\n-                $(\n-                    #[$doc]\n-                    #[serde(default = $config_str)]\n-                    #[serde(with = $config_str)]\n-                    pub $config: $Ty,\n-                )+\n-                #[allow(dead_code)]\n-                #[serde(default)]\n-                third_party: Option<::toml::Value>,\n+        impl Default for Conf {\n+            fn default() -> Self {\n+                Self { $($name: defaults::$name(),)* }\n             }\n+        }\n \n-            $(\n-                mod $config {\n-                    use serde::Deserialize;\n-                    pub fn deserialize<'de, D: serde::Deserializer<'de>>(deserializer: D) -> Result<$Ty, D::Error> {\n-                        use super::super::{ERRORS, Error};\n+        impl<'de> Deserialize<'de> for TryConf {\n+            fn deserialize<D>(deserializer: D) -> Result<Self, D::Error> where D: Deserializer<'de> {\n+                deserializer.deserialize_map(ConfVisitor)\n+            }\n+        }\n \n-                        Ok(\n-                            <$Ty>::deserialize(deserializer).unwrap_or_else(|e| {\n-                                ERRORS\n-                                    .lock()\n-                                    .expect(\"no threading here\")\n-                                    .push(Error::Toml(e.to_string()));\n-                                super::$config()\n-                            })\n-                        )\n-                    }\n-                }\n+        #[derive(Deserialize)]\n+        #[serde(field_identifier, rename_all = \"kebab-case\")]\n+        #[allow(non_camel_case_types)]\n+        enum Field { $($name,)* third_party, }\n+\n+        struct ConfVisitor;\n+\n+        impl<'de> Visitor<'de> for ConfVisitor {\n+            type Value = TryConf;\n \n-                #[must_use]\n-                fn $config() -> $Ty {\n-                    let x = $default;\n-                    x\n+            fn expecting(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {\n+                formatter.write_str(\"Conf\")\n+            }\n+\n+            fn visit_map<V>(self, mut map: V) -> Result<Self::Value, V::Error> where V: MapAccess<'de> {\n+                let mut errors = Vec::new();\n+                $(let mut $name = None;)*\n+                // could get `Field` here directly, but get `str` first for diagnostics\n+                while let Some(name) = map.next_key::<&str>()? {\n+                    match Field::deserialize(name.into_deserializer())? {\n+                        $(Field::$name => {\n+                            $(errors.push(format!(\"deprecated field `{}`. {}\", name, $dep));)?\n+                            match map.next_value() {\n+                                Err(e) => errors.push(e.to_string()),\n+                                Ok(value) => match $name {\n+                                    Some(_) => errors.push(format!(\"duplicate field `{}`\", name)),\n+                                    None => $name = Some(value),\n+                                }\n+                            }\n+                        })*\n+                        // white-listed; ignore\n+                        Field::third_party => drop(map.next_value::<IgnoredAny>())\n+                    }\n                 }\n-            )+\n+                let conf = Conf { $($name: $name.unwrap_or_else(defaults::$name),)* };\n+                Ok(TryConf { conf, errors })\n+            }\n         }\n     };\n }\n \n-pub use self::helpers::Conf;\n+// N.B., this macro is parsed by util/lintlib.py\n define_Conf! {\n-    /// Lint: CLONED_INSTEAD_OF_COPIED, REDUNDANT_FIELD_NAMES, REDUNDANT_STATIC_LIFETIMES, FILTER_MAP_NEXT, CHECKED_CONVERSIONS, MANUAL_RANGE_CONTAINS, USE_SELF, MEM_REPLACE_WITH_DEFAULT, MANUAL_NON_EXHAUSTIVE, OPTION_AS_REF_DEREF, MAP_UNWRAP_OR, MATCH_LIKE_MATCHES_MACRO, MANUAL_STRIP, MISSING_CONST_FOR_FN, UNNESTED_OR_PATTERNS, FROM_OVER_INTO, PTR_AS_PTR. The minimum rust version that the project supports\n-    (msrv, \"msrv\": Option<String>, None),\n+    /// Lint: CLONED_INSTEAD_OF_COPIED, REDUNDANT_FIELD_NAMES, REDUNDANT_STATIC_LIFETIMES, FILTER_MAP_NEXT, CHECKED_CONVERSIONS, MANUAL_RANGE_CONTAINS, USE_SELF, MEM_REPLACE_WITH_DEFAULT, MANUAL_NON_EXHAUSTIVE, OPTION_AS_REF_DEREF, MAP_UNWRAP_OR, MATCH_LIKE_MATCHES_MACRO, MANUAL_STRIP, MISSING_CONST_FOR_FN, UNNESTED_OR_PATTERNS, FROM_OVER_INTO, PTR_AS_PTR, IF_THEN_SOME_ELSE_NONE. The minimum rust version that the project supports\n+    (msrv: Option<String> = None),\n     /// Lint: BLACKLISTED_NAME. The list of blacklisted names to lint about. NB: `bar` is not here since it has legitimate uses\n-    (blacklisted_names, \"blacklisted_names\": Vec<String>, [\"foo\", \"baz\", \"quux\"].iter().map(ToString::to_string).collect()),\n+    (blacklisted_names: Vec<String> = [\"foo\", \"baz\", \"quux\"].iter().map(ToString::to_string).collect()),\n     /// Lint: COGNITIVE_COMPLEXITY. The maximum cognitive complexity a function can have\n-    (cognitive_complexity_threshold, \"cognitive_complexity_threshold\": u64, 25),\n+    (cognitive_complexity_threshold: u64 = 25),\n     /// DEPRECATED LINT: CYCLOMATIC_COMPLEXITY. Use the Cognitive Complexity lint instead.\n-    (cyclomatic_complexity_threshold, \"cyclomatic_complexity_threshold\": Option<u64>, None),\n+    #[conf_deprecated(\"Please use `cognitive-complexity-threshold` instead\")]\n+    (cyclomatic_complexity_threshold: Option<u64> = None),\n     /// Lint: DOC_MARKDOWN. The list of words this lint should not consider as identifiers needing ticks\n-    (doc_valid_idents, \"doc_valid_idents\": Vec<String>, [\n+    (doc_valid_idents: Vec<String> = [\n         \"KiB\", \"MiB\", \"GiB\", \"TiB\", \"PiB\", \"EiB\",\n         \"DirectX\",\n         \"ECMAScript\",\n@@ -136,54 +125,47 @@ define_Conf! {\n         \"CamelCase\",\n     ].iter().map(ToString::to_string).collect()),\n     /// Lint: TOO_MANY_ARGUMENTS. The maximum number of argument a function or method can have\n-    (too_many_arguments_threshold, \"too_many_arguments_threshold\": u64, 7),\n+    (too_many_arguments_threshold: u64 = 7),\n     /// Lint: TYPE_COMPLEXITY. The maximum complexity a type can have\n-    (type_complexity_threshold, \"type_complexity_threshold\": u64, 250),\n+    (type_complexity_threshold: u64 = 250),\n     /// Lint: MANY_SINGLE_CHAR_NAMES. The maximum number of single char bindings a scope may have\n-    (single_char_binding_names_threshold, \"single_char_binding_names_threshold\": u64, 4),\n+    (single_char_binding_names_threshold: u64 = 4),\n     /// Lint: BOXED_LOCAL, USELESS_VEC. The maximum size of objects (in bytes) that will be linted. Larger objects are ok on the heap\n-    (too_large_for_stack, \"too_large_for_stack\": u64, 200),\n+    (too_large_for_stack: u64 = 200),\n     /// Lint: ENUM_VARIANT_NAMES. The minimum number of enum variants for the lints about variant names to trigger\n-    (enum_variant_name_threshold, \"enum_variant_name_threshold\": u64, 3),\n+    (enum_variant_name_threshold: u64 = 3),\n     /// Lint: LARGE_ENUM_VARIANT. The maximum size of a enum's variant to avoid box suggestion\n-    (enum_variant_size_threshold, \"enum_variant_size_threshold\": u64, 200),\n+    (enum_variant_size_threshold: u64 = 200),\n     /// Lint: VERBOSE_BIT_MASK. The maximum allowed size of a bit mask before suggesting to use 'trailing_zeros'\n-    (verbose_bit_mask_threshold, \"verbose_bit_mask_threshold\": u64, 1),\n+    (verbose_bit_mask_threshold: u64 = 1),\n     /// Lint: DECIMAL_LITERAL_REPRESENTATION. The lower bound for linting decimal literals\n-    (literal_representation_threshold, \"literal_representation_threshold\": u64, 16384),\n+    (literal_representation_threshold: u64 = 16384),\n     /// Lint: TRIVIALLY_COPY_PASS_BY_REF. The maximum size (in bytes) to consider a `Copy` type for passing by value instead of by reference.\n-    (trivial_copy_size_limit, \"trivial_copy_size_limit\": Option<u64>, None),\n+    (trivial_copy_size_limit: Option<u64> = None),\n     /// Lint: LARGE_TYPE_PASS_BY_MOVE. The minimum size (in bytes) to consider a type for passing by reference instead of by value.\n-    (pass_by_value_size_limit, \"pass_by_value_size_limit\": u64, 256),\n+    (pass_by_value_size_limit: u64 = 256),\n     /// Lint: TOO_MANY_LINES. The maximum number of lines a function or method can have\n-    (too_many_lines_threshold, \"too_many_lines_threshold\": u64, 100),\n+    (too_many_lines_threshold: u64 = 100),\n     /// Lint: LARGE_STACK_ARRAYS, LARGE_CONST_ARRAYS. The maximum allowed size for arrays on the stack\n-    (array_size_threshold, \"array_size_threshold\": u64, 512_000),\n+    (array_size_threshold: u64 = 512_000),\n     /// Lint: VEC_BOX. The size of the boxed type in bytes, where boxing in a `Vec` is allowed\n-    (vec_box_size_threshold, \"vec_box_size_threshold\": u64, 4096),\n+    (vec_box_size_threshold: u64 = 4096),\n     /// Lint: TYPE_REPETITION_IN_BOUNDS. The maximum number of bounds a trait can have to be linted\n-    (max_trait_bounds, \"max_trait_bounds\": u64, 3),\n+    (max_trait_bounds: u64 = 3),\n     /// Lint: STRUCT_EXCESSIVE_BOOLS. The maximum number of bools a struct can have\n-    (max_struct_bools, \"max_struct_bools\": u64, 3),\n+    (max_struct_bools: u64 = 3),\n     /// Lint: FN_PARAMS_EXCESSIVE_BOOLS. The maximum number of bools function parameters can have\n-    (max_fn_params_bools, \"max_fn_params_bools\": u64, 3),\n+    (max_fn_params_bools: u64 = 3),\n     /// Lint: WILDCARD_IMPORTS. Whether to allow certain wildcard imports (prelude, super in tests).\n-    (warn_on_all_wildcard_imports, \"warn_on_all_wildcard_imports\": bool, false),\n+    (warn_on_all_wildcard_imports: bool = false),\n     /// Lint: DISALLOWED_METHOD. The list of disallowed methods, written as fully qualified paths.\n-    (disallowed_methods, \"disallowed_methods\": Vec<String>, Vec::<String>::new()),\n+    (disallowed_methods: Vec<String> = Vec::new()),\n     /// Lint: UNREADABLE_LITERAL. Should the fraction of a decimal be linted to include separators.\n-    (unreadable_literal_lint_fractions, \"unreadable_literal_lint_fractions\": bool, true),\n+    (unreadable_literal_lint_fractions: bool = true),\n     /// Lint: UPPER_CASE_ACRONYMS. Enables verbose mode. Triggers if there is more than one uppercase char next to each other\n-    (upper_case_acronyms_aggressive, \"upper_case_acronyms_aggressive\": bool, false),\n+    (upper_case_acronyms_aggressive: bool = false),\n     /// Lint: _CARGO_COMMON_METADATA. For internal testing only, ignores the current `publish` settings in the Cargo manifest.\n-    (cargo_ignore_publish, \"cargo_ignore_publish\": bool, false),\n-}\n-\n-impl Default for Conf {\n-    #[must_use]\n-    fn default() -> Self {\n-        toml::from_str(\"\").expect(\"we never error on empty config files\")\n-    }\n+    (cargo_ignore_publish: bool = false),\n }\n \n /// Search for the configuration file.\n@@ -217,43 +199,13 @@ pub fn lookup_conf_file() -> io::Result<Option<PathBuf>> {\n     }\n }\n \n-/// Produces a `Conf` filled with the default values and forwards the errors\n-///\n-/// Used internally for convenience\n-fn default(errors: Vec<Error>) -> (Conf, Vec<Error>) {\n-    (Conf::default(), errors)\n-}\n-\n /// Read the `toml` configuration file.\n ///\n /// In case of error, the function tries to continue as much as possible.\n-pub fn read(path: &Path) -> (Conf, Vec<Error>) {\n+pub fn read(path: &Path) -> TryConf {\n     let content = match fs::read_to_string(path) {\n+        Err(e) => return TryConf::from_error(e),\n         Ok(content) => content,\n-        Err(err) => return default(vec![err.into()]),\n     };\n-\n-    assert!(ERRORS.lock().expect(\"no threading -> mutex always safe\").is_empty());\n-    match toml::from_str(&content) {\n-        Ok(toml) => {\n-            let mut errors = ERRORS.lock().expect(\"no threading -> mutex always safe\").split_off(0);\n-\n-            let toml_ref: &Conf = &toml;\n-\n-            let cyc_field: Option<u64> = toml_ref.cyclomatic_complexity_threshold;\n-\n-            if cyc_field.is_some() {\n-                let cyc_err = \"found deprecated field `cyclomatic-complexity-threshold`. Please use `cognitive-complexity-threshold` instead.\".to_string();\n-                errors.push(Error::Toml(cyc_err));\n-            }\n-\n-            (toml, errors)\n-        },\n-        Err(e) => {\n-            let mut errors = ERRORS.lock().expect(\"no threading -> mutex always safe\").split_off(0);\n-            errors.push(Error::Toml(e.to_string()));\n-\n-            default(errors)\n-        },\n-    }\n+    toml::from_str(&content).unwrap_or_else(TryConf::from_error)\n }"}, {"sha": "ee7be24eae8013f05680ef3b7056aae0a2c973a3", "filename": "clippy_lints/src/utils/internal_lints.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d6058820237893566670d828c900de61c8e8f8af/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6058820237893566670d828c900de61c8e8f8af/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs?ref=d6058820237893566670d828c900de61c8e8f8af", "patch": "@@ -32,6 +32,9 @@ use rustc_typeck::hir_ty_to_ty;\n \n use std::borrow::{Borrow, Cow};\n \n+#[cfg(feature = \"metadata-collector-lint\")]\n+pub mod metadata_collector;\n+\n declare_clippy_lint! {\n     /// **What it does:** Checks for various things we like to keep tidy in clippy.\n     ///"}, {"sha": "e85637ca758884abee452581dfea267e164c905a", "filename": "clippy_lints/src/utils/internal_lints/metadata_collector.rs", "status": "added", "additions": 632, "deletions": 0, "changes": 632, "blob_url": "https://github.com/rust-lang/rust/blob/d6058820237893566670d828c900de61c8e8f8af/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Fmetadata_collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6058820237893566670d828c900de61c8e8f8af/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Fmetadata_collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Fmetadata_collector.rs?ref=d6058820237893566670d828c900de61c8e8f8af", "patch": "@@ -0,0 +1,632 @@\n+//! This lint is used to collect metadata about clippy lints. This metadata is exported as a json\n+//! file and then used to generate the [clippy lint list](https://rust-lang.github.io/rust-clippy/master/index.html)\n+//!\n+//! This module and therefor the entire lint is guarded by a feature flag called\n+//! `metadata-collector-lint`\n+//!\n+//! The module transforms all lint names to ascii lowercase to ensure that we don't have mismatches\n+//! during any comparison or mapping. (Please take care of this, it's not fun to spend time on such\n+//! a simple mistake)\n+\n+// # NITs\n+// - TODO xFrednet 2021-02-13: Collect depreciations and maybe renames\n+\n+use if_chain::if_chain;\n+use rustc_data_structures::fx::FxHashMap;\n+use rustc_hir::{\n+    self as hir, def::DefKind, intravisit, intravisit::Visitor, ExprKind, Item, ItemKind, Mutability, QPath,\n+};\n+use rustc_lint::{CheckLintNameResult, LateContext, LateLintPass, LintContext, LintId};\n+use rustc_middle::hir::map::Map;\n+use rustc_session::{declare_tool_lint, impl_lint_pass};\n+use rustc_span::{sym, Loc, Span, Symbol};\n+use serde::{ser::SerializeStruct, Serialize, Serializer};\n+use std::collections::BinaryHeap;\n+use std::fs::{self, OpenOptions};\n+use std::io::prelude::*;\n+use std::path::Path;\n+\n+use crate::utils::internal_lints::is_lint_ref_type;\n+use clippy_utils::{\n+    diagnostics::span_lint, last_path_segment, match_function_call, match_path, paths, ty::match_type,\n+    ty::walk_ptrs_ty_depth,\n+};\n+\n+/// This is the output file of the lint collector.\n+const OUTPUT_FILE: &str = \"../util/gh-pages/metadata_collection.json\";\n+/// These lints are excluded from the export.\n+const BLACK_LISTED_LINTS: [&str; 3] = [\"lint_author\", \"deep_code_inspection\", \"internal_metadata_collector\"];\n+/// These groups will be ignored by the lint group matcher. This is useful for collections like\n+/// `clippy::all`\n+const IGNORED_LINT_GROUPS: [&str; 1] = [\"clippy::all\"];\n+/// Lints within this group will be excluded from the collection\n+const EXCLUDED_LINT_GROUPS: [&str; 1] = [\"clippy::internal\"];\n+\n+const LINT_EMISSION_FUNCTIONS: [&[&str]; 7] = [\n+    &[\"clippy_utils\", \"diagnostics\", \"span_lint\"],\n+    &[\"clippy_utils\", \"diagnostics\", \"span_lint_and_help\"],\n+    &[\"clippy_utils\", \"diagnostics\", \"span_lint_and_note\"],\n+    &[\"clippy_utils\", \"diagnostics\", \"span_lint_hir\"],\n+    &[\"clippy_utils\", \"diagnostics\", \"span_lint_and_sugg\"],\n+    &[\"clippy_utils\", \"diagnostics\", \"span_lint_and_then\"],\n+    &[\"clippy_utils\", \"diagnostics\", \"span_lint_hir_and_then\"],\n+];\n+const SUGGESTION_DIAGNOSTIC_BUILDER_METHODS: [(&str, bool); 9] = [\n+    (\"span_suggestion\", false),\n+    (\"span_suggestion_short\", false),\n+    (\"span_suggestion_verbose\", false),\n+    (\"span_suggestion_hidden\", false),\n+    (\"tool_only_span_suggestion\", false),\n+    (\"multipart_suggestion\", true),\n+    (\"multipart_suggestions\", true),\n+    (\"tool_only_multipart_suggestion\", true),\n+    (\"span_suggestions\", true),\n+];\n+const SUGGESTION_FUNCTIONS: [&[&str]; 2] = [\n+    &[\"clippy_utils\", \"diagnostics\", \"multispan_sugg\"],\n+    &[\"clippy_utils\", \"diagnostics\", \"multispan_sugg_with_applicability\"],\n+];\n+\n+/// The index of the applicability name of `paths::APPLICABILITY_VALUES`\n+const APPLICABILITY_NAME_INDEX: usize = 2;\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Collects metadata about clippy lints for the website.\n+    ///\n+    /// This lint will be used to report problems of syntax parsing. You should hopefully never\n+    /// see this but never say never I guess ^^\n+    ///\n+    /// **Why is this bad?** This is not a bad thing but definitely a hacky way to do it. See\n+    /// issue [#4310](https://github.com/rust-lang/rust-clippy/issues/4310) for a discussion\n+    /// about the implementation.\n+    ///\n+    /// **Known problems:** Hopefully none. It would be pretty uncool to have a problem here :)\n+    ///\n+    /// **Example output:**\n+    /// ```json,ignore\n+    /// {\n+    ///     \"id\": \"internal_metadata_collector\",\n+    ///     \"id_span\": {\n+    ///         \"path\": \"clippy_lints/src/utils/internal_lints/metadata_collector.rs\",\n+    ///         \"line\": 1\n+    ///     },\n+    ///     \"group\": \"clippy::internal\",\n+    ///     \"docs\": \" **What it does:** Collects metadata about clippy lints for the website. [...] \"\n+    /// }\n+    /// ```\n+    pub INTERNAL_METADATA_COLLECTOR,\n+    internal_warn,\n+    \"A busy bee collection metadata about lints\"\n+}\n+\n+impl_lint_pass!(MetadataCollector => [INTERNAL_METADATA_COLLECTOR]);\n+\n+#[allow(clippy::module_name_repetitions)]\n+#[derive(Debug, Clone, Default)]\n+pub struct MetadataCollector {\n+    /// All collected lints\n+    ///\n+    /// We use a Heap here to have the lints added in alphabetic order in the export\n+    lints: BinaryHeap<LintMetadata>,\n+    applicability_info: FxHashMap<String, ApplicabilityInfo>,\n+}\n+\n+impl Drop for MetadataCollector {\n+    /// You might ask: How hacky is this?\n+    /// My answer:     YES\n+    fn drop(&mut self) {\n+        // The metadata collector gets dropped twice, this makes sure that we only write\n+        // when the list is full\n+        if self.lints.is_empty() {\n+            return;\n+        }\n+\n+        let mut applicability_info = std::mem::take(&mut self.applicability_info);\n+\n+        // Mapping the final data\n+        let mut lints = std::mem::take(&mut self.lints).into_sorted_vec();\n+        lints\n+            .iter_mut()\n+            .for_each(|x| x.applicability = applicability_info.remove(&x.id));\n+\n+        // Outputting\n+        if Path::new(OUTPUT_FILE).exists() {\n+            fs::remove_file(OUTPUT_FILE).unwrap();\n+        }\n+        let mut file = OpenOptions::new().write(true).create(true).open(OUTPUT_FILE).unwrap();\n+        writeln!(file, \"{}\", serde_json::to_string_pretty(&lints).unwrap()).unwrap();\n+    }\n+}\n+\n+#[derive(Debug, Clone, Serialize, PartialEq, Eq, PartialOrd, Ord)]\n+struct LintMetadata {\n+    id: String,\n+    id_span: SerializableSpan,\n+    group: String,\n+    docs: String,\n+    /// This field is only used in the output and will only be\n+    /// mapped shortly before the actual output.\n+    applicability: Option<ApplicabilityInfo>,\n+}\n+\n+impl LintMetadata {\n+    fn new(id: String, id_span: SerializableSpan, group: String, docs: String) -> Self {\n+        Self {\n+            id,\n+            id_span,\n+            group,\n+            docs,\n+            applicability: None,\n+        }\n+    }\n+}\n+\n+#[derive(Debug, Clone, Serialize, PartialEq, Eq, PartialOrd, Ord)]\n+struct SerializableSpan {\n+    path: String,\n+    line: usize,\n+}\n+\n+impl std::fmt::Display for SerializableSpan {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n+        write!(f, \"{}:{}\", self.path.rsplit('/').next().unwrap_or_default(), self.line)\n+    }\n+}\n+\n+impl SerializableSpan {\n+    fn from_item(cx: &LateContext<'_>, item: &Item<'_>) -> Self {\n+        Self::from_span(cx, item.ident.span)\n+    }\n+\n+    fn from_span(cx: &LateContext<'_>, span: Span) -> Self {\n+        let loc: Loc = cx.sess().source_map().lookup_char_pos(span.lo());\n+\n+        Self {\n+            path: format!(\"{}\", loc.file.name),\n+            line: loc.line,\n+        }\n+    }\n+}\n+\n+#[derive(Debug, Clone, Default, PartialEq, Eq, PartialOrd, Ord)]\n+struct ApplicabilityInfo {\n+    /// Indicates if any of the lint emissions uses multiple spans. This is related to\n+    /// [rustfix#141](https://github.com/rust-lang/rustfix/issues/141) as such suggestions can\n+    /// currently not be applied automatically.\n+    is_multi_part_suggestion: bool,\n+    applicability: Option<usize>,\n+}\n+\n+impl Serialize for ApplicabilityInfo {\n+    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n+    where\n+        S: Serializer,\n+    {\n+        let index = self.applicability.unwrap_or_default();\n+\n+        let mut s = serializer.serialize_struct(\"ApplicabilityInfo\", 2)?;\n+        s.serialize_field(\"is_multi_part_suggestion\", &self.is_multi_part_suggestion)?;\n+        s.serialize_field(\n+            \"applicability\",\n+            &paths::APPLICABILITY_VALUES[index][APPLICABILITY_NAME_INDEX],\n+        )?;\n+        s.end()\n+    }\n+}\n+\n+impl<'hir> LateLintPass<'hir> for MetadataCollector {\n+    /// Collecting lint declarations like:\n+    /// ```rust, ignore\n+    /// declare_clippy_lint! {\n+    ///     /// **What it does:** Something IDK.\n+    ///     pub SOME_LINT,\n+    ///     internal,\n+    ///     \"Who am I?\"\n+    /// }\n+    /// ```\n+    fn check_item(&mut self, cx: &LateContext<'hir>, item: &'hir Item<'_>) {\n+        if_chain! {\n+            // item validation\n+            if let ItemKind::Static(ref ty, Mutability::Not, _) = item.kind;\n+            if is_lint_ref_type(cx, ty);\n+            // blacklist check\n+            let lint_name = sym_to_string(item.ident.name).to_ascii_lowercase();\n+            if !BLACK_LISTED_LINTS.contains(&lint_name.as_str());\n+            // metadata extraction\n+            if let Some(group) = get_lint_group_or_lint(cx, &lint_name, item);\n+            if let Some(docs) = extract_attr_docs_or_lint(cx, item);\n+            then {\n+                self.lints.push(LintMetadata::new(\n+                    lint_name,\n+                    SerializableSpan::from_item(cx, item),\n+                    group,\n+                    docs,\n+                ));\n+            }\n+        }\n+    }\n+\n+    /// Collecting constant applicability from the actual lint emissions\n+    ///\n+    /// Example:\n+    /// ```rust, ignore\n+    /// span_lint_and_sugg(\n+    ///     cx,\n+    ///     SOME_LINT,\n+    ///     item.span,\n+    ///     \"Le lint message\",\n+    ///     \"Here comes help:\",\n+    ///     \"#![allow(clippy::all)]\",\n+    ///     Applicability::MachineApplicable, // <-- Extracts this constant value\n+    /// );\n+    /// ```\n+    fn check_expr(&mut self, cx: &LateContext<'hir>, expr: &'hir hir::Expr<'_>) {\n+        if let Some(args) = match_lint_emission(cx, expr) {\n+            let mut emission_info = extract_emission_info(cx, args);\n+            if emission_info.is_empty() {\n+                // See:\n+                // - src/misc.rs:734:9\n+                // - src/methods/mod.rs:3545:13\n+                // - src/methods/mod.rs:3496:13\n+                // We are basically unable to resolve the lint name it self.\n+                return;\n+            }\n+\n+            for (lint_name, applicability, is_multi_part) in emission_info.drain(..) {\n+                let app_info = self.applicability_info.entry(lint_name).or_default();\n+                app_info.applicability = applicability;\n+                app_info.is_multi_part_suggestion = is_multi_part;\n+            }\n+        }\n+    }\n+}\n+\n+// ==================================================================\n+// Lint definition extraction\n+// ==================================================================\n+fn sym_to_string(sym: Symbol) -> String {\n+    sym.as_str().to_string()\n+}\n+\n+fn extract_attr_docs_or_lint(cx: &LateContext<'_>, item: &Item<'_>) -> Option<String> {\n+    extract_attr_docs(cx, item).or_else(|| {\n+        lint_collection_error_item(cx, item, \"could not collect the lint documentation\");\n+        None\n+    })\n+}\n+\n+/// This function collects all documentation that has been added to an item using\n+/// `#[doc = r\"\"]` attributes. Several attributes are aggravated using line breaks\n+///\n+/// ```ignore\n+/// #[doc = r\"Hello world!\"]\n+/// #[doc = r\"=^.^=\"]\n+/// struct SomeItem {}\n+/// ```\n+///\n+/// Would result in `Hello world!\\n=^.^=\\n`\n+fn extract_attr_docs(cx: &LateContext<'_>, item: &Item<'_>) -> Option<String> {\n+    cx.tcx\n+        .hir()\n+        .attrs(item.hir_id())\n+        .iter()\n+        .filter_map(|ref x| x.doc_str().map(|sym| sym.as_str().to_string()))\n+        .reduce(|mut acc, sym| {\n+            acc.push_str(&sym);\n+            acc.push('\\n');\n+            acc\n+        })\n+}\n+\n+fn get_lint_group_or_lint(cx: &LateContext<'_>, lint_name: &str, item: &'hir Item<'_>) -> Option<String> {\n+    let result = cx.lint_store.check_lint_name(lint_name, Some(sym::clippy));\n+    if let CheckLintNameResult::Tool(Ok(lint_lst)) = result {\n+        get_lint_group(cx, lint_lst[0])\n+            .or_else(|| {\n+                lint_collection_error_item(cx, item, \"Unable to determine lint group\");\n+                None\n+            })\n+            .filter(|group| !EXCLUDED_LINT_GROUPS.contains(&group.as_str()))\n+    } else {\n+        lint_collection_error_item(cx, item, \"Unable to find lint in lint_store\");\n+        None\n+    }\n+}\n+\n+fn get_lint_group(cx: &LateContext<'_>, lint_id: LintId) -> Option<String> {\n+    for (group_name, lints, _) in &cx.lint_store.get_lint_groups() {\n+        if IGNORED_LINT_GROUPS.contains(group_name) {\n+            continue;\n+        }\n+\n+        if lints.iter().any(|x| *x == lint_id) {\n+            return Some((*group_name).to_string());\n+        }\n+    }\n+\n+    None\n+}\n+\n+// ==================================================================\n+// Lint emission\n+// ==================================================================\n+fn lint_collection_error_item(cx: &LateContext<'_>, item: &Item<'_>, message: &str) {\n+    span_lint(\n+        cx,\n+        INTERNAL_METADATA_COLLECTOR,\n+        item.ident.span,\n+        &format!(\"metadata collection error for `{}`: {}\", item.ident.name, message),\n+    );\n+}\n+\n+// ==================================================================\n+// Applicability\n+// ==================================================================\n+/// This function checks if a given expression is equal to a simple lint emission function call.\n+/// It will return the function arguments if the emission matched any function.\n+fn match_lint_emission<'hir>(cx: &LateContext<'hir>, expr: &'hir hir::Expr<'_>) -> Option<&'hir [hir::Expr<'hir>]> {\n+    LINT_EMISSION_FUNCTIONS\n+        .iter()\n+        .find_map(|emission_fn| match_function_call(cx, expr, emission_fn))\n+}\n+\n+fn take_higher_applicability(a: Option<usize>, b: Option<usize>) -> Option<usize> {\n+    a.map_or(b, |a| a.max(b.unwrap_or_default()).into())\n+}\n+\n+fn extract_emission_info<'hir>(\n+    cx: &LateContext<'hir>,\n+    args: &'hir [hir::Expr<'hir>],\n+) -> Vec<(String, Option<usize>, bool)> {\n+    let mut lints = Vec::new();\n+    let mut applicability = None;\n+    let mut multi_part = false;\n+\n+    for arg in args {\n+        let (arg_ty, _) = walk_ptrs_ty_depth(cx.typeck_results().expr_ty(&arg));\n+\n+        if match_type(cx, arg_ty, &paths::LINT) {\n+            // If we found the lint arg, extract the lint name\n+            let mut resolved_lints = resolve_lints(cx, arg);\n+            lints.append(&mut resolved_lints);\n+        } else if match_type(cx, arg_ty, &paths::APPLICABILITY) {\n+            applicability = resolve_applicability(cx, arg);\n+        } else if arg_ty.is_closure() {\n+            multi_part |= check_is_multi_part(cx, arg);\n+            // TODO xFrednet 2021-03-01: don't use or_else but rather a comparison\n+            applicability = applicability.or_else(|| resolve_applicability(cx, arg));\n+        }\n+    }\n+\n+    lints\n+        .drain(..)\n+        .map(|lint_name| (lint_name, applicability, multi_part))\n+        .collect()\n+}\n+\n+/// Resolves the possible lints that this expression could reference\n+fn resolve_lints(cx: &LateContext<'hir>, expr: &'hir hir::Expr<'hir>) -> Vec<String> {\n+    let mut resolver = LintResolver::new(cx);\n+    resolver.visit_expr(expr);\n+    resolver.lints\n+}\n+\n+/// This function tries to resolve the linked applicability to the given expression.\n+fn resolve_applicability(cx: &LateContext<'hir>, expr: &'hir hir::Expr<'hir>) -> Option<usize> {\n+    let mut resolver = ApplicabilityResolver::new(cx);\n+    resolver.visit_expr(expr);\n+    resolver.complete()\n+}\n+\n+fn check_is_multi_part(cx: &LateContext<'hir>, closure_expr: &'hir hir::Expr<'hir>) -> bool {\n+    if let ExprKind::Closure(_, _, body_id, _, _) = closure_expr.kind {\n+        let mut scanner = IsMultiSpanScanner::new(cx);\n+        intravisit::walk_body(&mut scanner, cx.tcx.hir().body(body_id));\n+        return scanner.is_multi_part();\n+    } else if let Some(local) = get_parent_local(cx, closure_expr) {\n+        if let Some(local_init) = local.init {\n+            return check_is_multi_part(cx, local_init);\n+        }\n+    }\n+\n+    false\n+}\n+\n+struct LintResolver<'a, 'hir> {\n+    cx: &'a LateContext<'hir>,\n+    lints: Vec<String>,\n+}\n+\n+impl<'a, 'hir> LintResolver<'a, 'hir> {\n+    fn new(cx: &'a LateContext<'hir>) -> Self {\n+        Self {\n+            cx,\n+            lints: Vec::<String>::default(),\n+        }\n+    }\n+}\n+\n+impl<'a, 'hir> intravisit::Visitor<'hir> for LintResolver<'a, 'hir> {\n+    type Map = Map<'hir>;\n+\n+    fn nested_visit_map(&mut self) -> intravisit::NestedVisitorMap<Self::Map> {\n+        intravisit::NestedVisitorMap::All(self.cx.tcx.hir())\n+    }\n+\n+    fn visit_expr(&mut self, expr: &'hir hir::Expr<'hir>) {\n+        if_chain! {\n+            if let ExprKind::Path(qpath) = &expr.kind;\n+            if let QPath::Resolved(_, path) = qpath;\n+\n+            let (expr_ty, _) = walk_ptrs_ty_depth(self.cx.typeck_results().expr_ty(&expr));\n+            if match_type(self.cx, expr_ty, &paths::LINT);\n+            then {\n+                if let hir::def::Res::Def(DefKind::Static, _) = path.res {\n+                    let lint_name = last_path_segment(qpath).ident.name;\n+                    self.lints.push(sym_to_string(lint_name).to_ascii_lowercase());\n+                } else if let Some(local) = get_parent_local(self.cx, expr) {\n+                    if let Some(local_init) = local.init {\n+                        intravisit::walk_expr(self, local_init);\n+                    }\n+                }\n+            }\n+        }\n+\n+        intravisit::walk_expr(self, expr);\n+    }\n+}\n+\n+/// This visitor finds the highest applicability value in the visited expressions\n+struct ApplicabilityResolver<'a, 'hir> {\n+    cx: &'a LateContext<'hir>,\n+    /// This is the index of hightest `Applicability` for `paths::APPLICABILITY_VALUES`\n+    applicability_index: Option<usize>,\n+}\n+\n+impl<'a, 'hir> ApplicabilityResolver<'a, 'hir> {\n+    fn new(cx: &'a LateContext<'hir>) -> Self {\n+        Self {\n+            cx,\n+            applicability_index: None,\n+        }\n+    }\n+\n+    fn add_new_index(&mut self, new_index: usize) {\n+        self.applicability_index = take_higher_applicability(self.applicability_index, Some(new_index));\n+    }\n+\n+    fn complete(self) -> Option<usize> {\n+        self.applicability_index\n+    }\n+}\n+\n+impl<'a, 'hir> intravisit::Visitor<'hir> for ApplicabilityResolver<'a, 'hir> {\n+    type Map = Map<'hir>;\n+\n+    fn nested_visit_map(&mut self) -> intravisit::NestedVisitorMap<Self::Map> {\n+        intravisit::NestedVisitorMap::All(self.cx.tcx.hir())\n+    }\n+\n+    fn visit_path(&mut self, path: &'hir hir::Path<'hir>, _id: hir::HirId) {\n+        for (index, enum_value) in paths::APPLICABILITY_VALUES.iter().enumerate() {\n+            if match_path(path, enum_value) {\n+                self.add_new_index(index);\n+                return;\n+            }\n+        }\n+    }\n+\n+    fn visit_expr(&mut self, expr: &'hir hir::Expr<'hir>) {\n+        let (expr_ty, _) = walk_ptrs_ty_depth(self.cx.typeck_results().expr_ty(&expr));\n+\n+        if_chain! {\n+            if match_type(self.cx, expr_ty, &paths::APPLICABILITY);\n+            if let Some(local) = get_parent_local(self.cx, expr);\n+            if let Some(local_init) = local.init;\n+            then {\n+                intravisit::walk_expr(self, local_init);\n+            }\n+        };\n+\n+        // TODO xFrednet 2021-03-01: support function arguments?\n+\n+        intravisit::walk_expr(self, expr);\n+    }\n+}\n+\n+/// This returns the parent local node if the expression is a reference one\n+fn get_parent_local(cx: &LateContext<'hir>, expr: &'hir hir::Expr<'hir>) -> Option<&'hir hir::Local<'hir>> {\n+    if let ExprKind::Path(QPath::Resolved(_, path)) = expr.kind {\n+        if let hir::def::Res::Local(local_hir) = path.res {\n+            return get_parent_local_hir_id(cx, local_hir);\n+        }\n+    }\n+\n+    None\n+}\n+\n+fn get_parent_local_hir_id(cx: &LateContext<'hir>, hir_id: hir::HirId) -> Option<&'hir hir::Local<'hir>> {\n+    let map = cx.tcx.hir();\n+\n+    match map.find(map.get_parent_node(hir_id)) {\n+        Some(hir::Node::Local(local)) => Some(local),\n+        Some(hir::Node::Pat(pattern)) => get_parent_local_hir_id(cx, pattern.hir_id),\n+        _ => None,\n+    }\n+}\n+\n+/// This visitor finds the highest applicability value in the visited expressions\n+struct IsMultiSpanScanner<'a, 'hir> {\n+    cx: &'a LateContext<'hir>,\n+    suggestion_count: usize,\n+}\n+\n+impl<'a, 'hir> IsMultiSpanScanner<'a, 'hir> {\n+    fn new(cx: &'a LateContext<'hir>) -> Self {\n+        Self {\n+            cx,\n+            suggestion_count: 0,\n+        }\n+    }\n+\n+    /// Add a new single expression suggestion to the counter\n+    fn add_single_span_suggestion(&mut self) {\n+        self.suggestion_count += 1;\n+    }\n+\n+    /// Signals that a suggestion with possible multiple spans was found\n+    fn add_multi_part_suggestion(&mut self) {\n+        self.suggestion_count += 2;\n+    }\n+\n+    /// Checks if the suggestions include multiple spanns\n+    fn is_multi_part(&self) -> bool {\n+        self.suggestion_count > 1\n+    }\n+}\n+\n+impl<'a, 'hir> intravisit::Visitor<'hir> for IsMultiSpanScanner<'a, 'hir> {\n+    type Map = Map<'hir>;\n+\n+    fn nested_visit_map(&mut self) -> intravisit::NestedVisitorMap<Self::Map> {\n+        intravisit::NestedVisitorMap::All(self.cx.tcx.hir())\n+    }\n+\n+    fn visit_expr(&mut self, expr: &'hir hir::Expr<'hir>) {\n+        // Early return if the lint is already multi span\n+        if self.is_multi_part() {\n+            return;\n+        }\n+\n+        match &expr.kind {\n+            ExprKind::Call(fn_expr, _args) => {\n+                let found_function = SUGGESTION_FUNCTIONS\n+                    .iter()\n+                    .any(|func_path| match_function_call(self.cx, fn_expr, func_path).is_some());\n+                if found_function {\n+                    // These functions are all multi part suggestions\n+                    self.add_single_span_suggestion()\n+                }\n+            },\n+            ExprKind::MethodCall(path, _path_span, arg, _arg_span) => {\n+                let (self_ty, _) = walk_ptrs_ty_depth(self.cx.typeck_results().expr_ty(&arg[0]));\n+                if match_type(self.cx, self_ty, &paths::DIAGNOSTIC_BUILDER) {\n+                    let called_method = path.ident.name.as_str().to_string();\n+                    for (method_name, is_multi_part) in &SUGGESTION_DIAGNOSTIC_BUILDER_METHODS {\n+                        if *method_name == called_method {\n+                            if *is_multi_part {\n+                                self.add_multi_part_suggestion();\n+                            } else {\n+                                self.add_single_span_suggestion();\n+                            }\n+                            break;\n+                        }\n+                    }\n+                }\n+            },\n+            _ => {},\n+        }\n+\n+        intravisit::walk_expr(self, expr);\n+    }\n+}"}, {"sha": "b67448e3a57406be07c7589baec3e72f17a964b2", "filename": "clippy_lints/src/utils/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d6058820237893566670d828c900de61c8e8f8af/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6058820237893566670d828c900de61c8e8f8af/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fmod.rs?ref=d6058820237893566670d828c900de61c8e8f8af", "patch": "@@ -1,5 +1,5 @@\n pub mod author;\n pub mod conf;\n pub mod inspector;\n-#[cfg(feature = \"internal-lints\")]\n+#[cfg(any(feature = \"internal-lints\", feature = \"metadata-collector-lint\"))]\n pub mod internal_lints;"}, {"sha": "0a1d4e1114285b18640658a9eaa0c48bd359aa64", "filename": "clippy_utils/Cargo.toml", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d6058820237893566670d828c900de61c8e8f8af/clippy_utils%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/d6058820237893566670d828c900de61c8e8f8af/clippy_utils%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2FCargo.toml?ref=d6058820237893566670d828c900de61c8e8f8af", "patch": "@@ -1,6 +1,6 @@\n [package]\n name = \"clippy_utils\"\n-version = \"0.1.53\"\n+version = \"0.1.54\"\n authors = [\"The Rust Clippy Developers\"]\n edition = \"2018\"\n publish = false\n@@ -15,6 +15,7 @@ rustc-semver=\"1.1.0\"\n \n [features]\n internal-lints = []\n+metadata-collector-lint = []\n \n [package.metadata.rust-analyzer]\n # This crate uses #[feature(rustc_private)]"}, {"sha": "a4efae54894fb10463ba54f745c594830604b047", "filename": "clippy_utils/src/diagnostics.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d6058820237893566670d828c900de61c8e8f8af/clippy_utils%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6058820237893566670d828c900de61c8e8f8af/clippy_utils%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fdiagnostics.rs?ref=d6058820237893566670d828c900de61c8e8f8af", "patch": "@@ -1,4 +1,12 @@\n //! Clippy wrappers around rustc's diagnostic functions.\n+//!\n+//! These functions are used by the `INTERNAL_METADATA_COLLECTOR` lint to collect the corresponding\n+//! lint applicability. Please make sure that you update the `LINT_EMISSION_FUNCTIONS` variable in\n+//! `clippy_lints::utils::internal_lints::metadata_collector` when a new function is added\n+//! or renamed.\n+//!\n+//! Thank you!\n+//! ~The `INTERNAL_METADATA_COLLECTOR` lint\n \n use rustc_errors::{Applicability, DiagnosticBuilder};\n use rustc_hir::HirId;"}, {"sha": "3b01158acd91f972a634b652afeebd6e28a3f7cb", "filename": "clippy_utils/src/hir_utils.rs", "status": "modified", "additions": 78, "deletions": 15, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/d6058820237893566670d828c900de61c8e8f8af/clippy_utils%2Fsrc%2Fhir_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6058820237893566670d828c900de61c8e8f8af/clippy_utils%2Fsrc%2Fhir_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fhir_utils.rs?ref=d6058820237893566670d828c900de61c8e8f8af", "patch": "@@ -713,7 +713,7 @@ impl<'a, 'tcx> SpanlessHash<'a, 'tcx> {\n                 self.hash_expr(e);\n \n                 for arm in arms {\n-                    // TODO: arm.pat?\n+                    self.hash_pat(arm.pat);\n                     if let Some(ref e) = arm.guard {\n                         self.hash_guard(e);\n                     }\n@@ -791,6 +791,72 @@ impl<'a, 'tcx> SpanlessHash<'a, 'tcx> {\n         // self.maybe_typeck_results.unwrap().qpath_res(p, id).hash(&mut self.s);\n     }\n \n+    pub fn hash_pat(&mut self, pat: &Pat<'_>) {\n+        std::mem::discriminant(&pat.kind).hash(&mut self.s);\n+        match pat.kind {\n+            PatKind::Binding(ann, _, _, pat) => {\n+                ann.hash_stable(&mut self.cx.tcx.get_stable_hashing_context(), &mut self.s);\n+                if let Some(pat) = pat {\n+                    self.hash_pat(pat);\n+                }\n+            },\n+            PatKind::Box(pat) => self.hash_pat(pat),\n+            PatKind::Lit(expr) => self.hash_expr(expr),\n+            PatKind::Or(pats) => {\n+                for pat in pats {\n+                    self.hash_pat(pat);\n+                }\n+            },\n+            PatKind::Path(ref qpath) => self.hash_qpath(qpath),\n+            PatKind::Range(s, e, i) => {\n+                if let Some(s) = s {\n+                    self.hash_expr(s);\n+                }\n+                if let Some(e) = e {\n+                    self.hash_expr(e);\n+                }\n+                i.hash_stable(&mut self.cx.tcx.get_stable_hashing_context(), &mut self.s);\n+            },\n+            PatKind::Ref(pat, m) => {\n+                self.hash_pat(pat);\n+                m.hash(&mut self.s);\n+            },\n+            PatKind::Slice(l, m, r) => {\n+                for pat in l {\n+                    self.hash_pat(pat);\n+                }\n+                if let Some(pat) = m {\n+                    self.hash_pat(pat);\n+                }\n+                for pat in r {\n+                    self.hash_pat(pat);\n+                }\n+            },\n+            PatKind::Struct(ref qpath, fields, e) => {\n+                self.hash_qpath(qpath);\n+                for f in fields {\n+                    self.hash_name(f.ident.name);\n+                    self.hash_pat(f.pat);\n+                }\n+                e.hash(&mut self.s)\n+            },\n+            PatKind::Tuple(pats, e) => {\n+                for pat in pats {\n+                    self.hash_pat(pat);\n+                }\n+                e.hash(&mut self.s);\n+            },\n+            PatKind::TupleStruct(ref qpath, pats, e) => {\n+                self.hash_qpath(qpath);\n+                for pat in pats {\n+                    self.hash_pat(pat);\n+                }\n+                e.hash(&mut self.s);\n+            },\n+            PatKind::Wild => {},\n+        }\n+    }\n+\n     pub fn hash_path(&mut self, path: &Path<'_>) {\n         match path.res {\n             // constant hash since equality is dependant on inter-expression context\n@@ -808,6 +874,7 @@ impl<'a, 'tcx> SpanlessHash<'a, 'tcx> {\n \n         match &b.kind {\n             StmtKind::Local(local) => {\n+                self.hash_pat(local.pat);\n                 if let Some(ref init) = local.init {\n                     self.hash_expr(init);\n                 }\n@@ -827,7 +894,7 @@ impl<'a, 'tcx> SpanlessHash<'a, 'tcx> {\n         }\n     }\n \n-    pub fn hash_lifetime(&mut self, lifetime: &Lifetime) {\n+    pub fn hash_lifetime(&mut self, lifetime: Lifetime) {\n         std::mem::discriminant(&lifetime.name).hash(&mut self.s);\n         if let LifetimeName::Param(ref name) = lifetime.name {\n             std::mem::discriminant(name).hash(&mut self.s);\n@@ -844,24 +911,20 @@ impl<'a, 'tcx> SpanlessHash<'a, 'tcx> {\n     }\n \n     pub fn hash_ty(&mut self, ty: &Ty<'_>) {\n-        self.hash_tykind(&ty.kind);\n-    }\n-\n-    pub fn hash_tykind(&mut self, ty: &TyKind<'_>) {\n-        std::mem::discriminant(ty).hash(&mut self.s);\n-        match ty {\n+        std::mem::discriminant(&ty.kind).hash(&mut self.s);\n+        match ty.kind {\n             TyKind::Slice(ty) => {\n                 self.hash_ty(ty);\n             },\n             TyKind::Array(ty, anon_const) => {\n                 self.hash_ty(ty);\n                 self.hash_body(anon_const.body);\n             },\n-            TyKind::Ptr(mut_ty) => {\n+            TyKind::Ptr(ref mut_ty) => {\n                 self.hash_ty(&mut_ty.ty);\n                 mut_ty.mutbl.hash(&mut self.s);\n             },\n-            TyKind::Rptr(lifetime, mut_ty) => {\n+            TyKind::Rptr(lifetime, ref mut_ty) => {\n                 self.hash_lifetime(lifetime);\n                 self.hash_ty(&mut_ty.ty);\n                 mut_ty.mutbl.hash(&mut self.s);\n@@ -883,11 +946,11 @@ impl<'a, 'tcx> SpanlessHash<'a, 'tcx> {\n                 bfn.decl.c_variadic.hash(&mut self.s);\n             },\n             TyKind::Tup(ty_list) => {\n-                for ty in *ty_list {\n+                for ty in ty_list {\n                     self.hash_ty(ty);\n                 }\n             },\n-            TyKind::Path(qpath) => match qpath {\n+            TyKind::Path(ref qpath) => match qpath {\n                 QPath::Resolved(ref maybe_ty, ref path) => {\n                     if let Some(ref ty) = maybe_ty {\n                         self.hash_ty(ty);\n@@ -927,9 +990,9 @@ impl<'a, 'tcx> SpanlessHash<'a, 'tcx> {\n \n     fn hash_generic_args(&mut self, arg_list: &[GenericArg<'_>]) {\n         for arg in arg_list {\n-            match arg {\n-                GenericArg::Lifetime(ref l) => self.hash_lifetime(l),\n-                GenericArg::Type(ref ty) => self.hash_ty(&ty),\n+            match *arg {\n+                GenericArg::Lifetime(l) => self.hash_lifetime(l),\n+                GenericArg::Type(ref ty) => self.hash_ty(ty),\n                 GenericArg::Const(ref ca) => self.hash_body(ca.value.body),\n             }\n         }"}, {"sha": "f5ee49c7d5f99f31f3cc4d912451fd99c8eabc0c", "filename": "clippy_utils/src/lib.rs", "status": "modified", "additions": 44, "deletions": 4, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/d6058820237893566670d828c900de61c8e8f8af/clippy_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6058820237893566670d828c900de61c8e8f8af/clippy_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Flib.rs?ref=d6058820237893566670d828c900de61c8e8f8af", "patch": "@@ -61,12 +61,12 @@ use rustc_data_structures::fx::FxHashMap;\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n use rustc_hir::def_id::{DefId, LOCAL_CRATE};\n-use rustc_hir::intravisit::{self, walk_expr, ErasedMap, NestedVisitorMap, Visitor};\n+use rustc_hir::intravisit::{self, walk_expr, ErasedMap, FnKind, NestedVisitorMap, Visitor};\n use rustc_hir::LangItem::{ResultErr, ResultOk};\n use rustc_hir::{\n     def, Arm, BindingAnnotation, Block, Body, Constness, Destination, Expr, ExprKind, FnDecl, GenericArgs, HirId, Impl,\n-    ImplItem, ImplItemKind, Item, ItemKind, LangItem, Local, MatchSource, Node, Param, Pat, PatKind, Path, PathSegment,\n-    QPath, Stmt, StmtKind, TraitItem, TraitItemKind, TraitRef, TyKind,\n+    ImplItem, ImplItemKind, IsAsync, Item, ItemKind, LangItem, Local, MatchSource, Node, Param, Pat, PatKind, Path,\n+    PathSegment, QPath, Stmt, StmtKind, TraitItem, TraitItemKind, TraitRef, TyKind,\n };\n use rustc_lint::{LateContext, Level, Lint, LintContext};\n use rustc_middle::hir::exports::Export;\n@@ -821,7 +821,13 @@ pub fn get_parent_node(tcx: TyCtxt<'_>, id: HirId) -> Option<Node<'_>> {\n \n /// Gets the parent expression, if any \u2013- this is useful to constrain a lint.\n pub fn get_parent_expr<'tcx>(cx: &LateContext<'tcx>, e: &Expr<'_>) -> Option<&'tcx Expr<'tcx>> {\n-    match get_parent_node(cx.tcx, e.hir_id) {\n+    get_parent_expr_for_hir(cx, e.hir_id)\n+}\n+\n+/// This retrieves the parent for the given `HirId` if it's an expression. This is useful for\n+/// constraint lints\n+pub fn get_parent_expr_for_hir<'tcx>(cx: &LateContext<'tcx>, hir_id: hir::HirId) -> Option<&'tcx Expr<'tcx>> {\n+    match get_parent_node(cx.tcx, hir_id) {\n         Some(Node::Expr(parent)) => Some(parent),\n         _ => None,\n     }\n@@ -1301,6 +1307,40 @@ pub fn if_sequence<'tcx>(mut expr: &'tcx Expr<'tcx>) -> (Vec<&'tcx Expr<'tcx>>,\n     (conds, blocks)\n }\n \n+/// Checks if the given function kind is an async function.\n+pub fn is_async_fn(kind: FnKind<'_>) -> bool {\n+    matches!(kind, FnKind::ItemFn(_, _, header, _) if header.asyncness == IsAsync::Async)\n+}\n+\n+/// Peels away all the compiler generated code surrounding the body of an async function,\n+pub fn get_async_fn_body(tcx: TyCtxt<'tcx>, body: &Body<'_>) -> Option<&'tcx Expr<'tcx>> {\n+    if let ExprKind::Call(\n+        _,\n+        &[Expr {\n+            kind: ExprKind::Closure(_, _, body, _, _),\n+            ..\n+        }],\n+    ) = body.value.kind\n+    {\n+        if let ExprKind::Block(\n+            Block {\n+                stmts: [],\n+                expr:\n+                    Some(Expr {\n+                        kind: ExprKind::DropTemps(expr),\n+                        ..\n+                    }),\n+                ..\n+            },\n+            _,\n+        ) = tcx.hir().body(body).value.kind\n+        {\n+            return Some(expr);\n+        }\n+    };\n+    None\n+}\n+\n // Finds the `#[must_use]` attribute, if any\n pub fn must_use_attr(attrs: &[Attribute]) -> Option<&Attribute> {\n     attrs.iter().find(|a| a.has_name(sym::must_use))"}, {"sha": "8037d670500be736973135845d9592dc8424742f", "filename": "clippy_utils/src/paths.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/d6058820237893566670d828c900de61c8e8f8af/clippy_utils%2Fsrc%2Fpaths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6058820237893566670d828c900de61c8e8f8af/clippy_utils%2Fsrc%2Fpaths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fpaths.rs?ref=d6058820237893566670d828c900de61c8e8f8af", "patch": "@@ -5,6 +5,17 @@\n //! See <https://github.com/rust-lang/rust-clippy/issues/5393> for more information.\n \n pub const ANY_TRAIT: [&str; 3] = [\"core\", \"any\", \"Any\"];\n+#[cfg(feature = \"metadata-collector-lint\")]\n+pub const APPLICABILITY: [&str; 2] = [\"rustc_lint_defs\", \"Applicability\"];\n+#[cfg(feature = \"metadata-collector-lint\")]\n+pub const APPLICABILITY_VALUES: [[&str; 3]; 4] = [\n+    [\"rustc_lint_defs\", \"Applicability\", \"Unspecified\"],\n+    [\"rustc_lint_defs\", \"Applicability\", \"HasPlaceholders\"],\n+    [\"rustc_lint_defs\", \"Applicability\", \"MaybeIncorrect\"],\n+    [\"rustc_lint_defs\", \"Applicability\", \"MachineApplicable\"],\n+];\n+#[cfg(feature = \"metadata-collector-lint\")]\n+pub const DIAGNOSTIC_BUILDER: [&str; 3] = [\"rustc_errors\", \"diagnostic_builder\", \"DiagnosticBuilder\"];\n pub const ARC_PTR_EQ: [&str; 4] = [\"alloc\", \"sync\", \"Arc\", \"ptr_eq\"];\n pub const ASMUT_TRAIT: [&str; 3] = [\"core\", \"convert\", \"AsMut\"];\n pub const ASREF_TRAIT: [&str; 3] = [\"core\", \"convert\", \"AsRef\"];\n@@ -72,7 +83,7 @@ pub const KW_MODULE: [&str; 3] = [\"rustc_span\", \"symbol\", \"kw\"];\n #[cfg(feature = \"internal-lints\")]\n pub const LATE_CONTEXT: [&str; 2] = [\"rustc_lint\", \"LateContext\"];\n pub const LINKED_LIST: [&str; 4] = [\"alloc\", \"collections\", \"linked_list\", \"LinkedList\"];\n-#[cfg(feature = \"internal-lints\")]\n+#[cfg(any(feature = \"internal-lints\", feature = \"metadata-collector-lint\"))]\n pub const LINT: [&str; 2] = [\"rustc_lint_defs\", \"Lint\"];\n pub const MEM_DISCRIMINANT: [&str; 3] = [\"core\", \"mem\", \"discriminant\"];\n pub const MEM_FORGET: [&str; 3] = [\"core\", \"mem\", \"forget\"];"}, {"sha": "4d49b43bde9ecd9751bc825b55afad614e5f1fd7", "filename": "clippy_utils/src/source.rs", "status": "modified", "additions": 42, "deletions": 11, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/d6058820237893566670d828c900de61c8e8f8af/clippy_utils%2Fsrc%2Fsource.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6058820237893566670d828c900de61c8e8f8af/clippy_utils%2Fsrc%2Fsource.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fsource.rs?ref=d6058820237893566670d828c900de61c8e8f8af", "patch": "@@ -280,24 +280,55 @@ pub fn snippet_with_context(\n     default: &'a str,\n     applicability: &mut Applicability,\n ) -> (Cow<'a, str>, bool) {\n-    let outer_span = hygiene::walk_chain(span, outer);\n-    let (span, is_macro_call) = if outer_span.ctxt() == outer {\n-        (outer_span, span.ctxt() != outer)\n-    } else {\n-        // The span is from a macro argument, and the outer context is the macro using the argument\n-        if *applicability != Applicability::Unspecified {\n-            *applicability = Applicability::MaybeIncorrect;\n-        }\n-        // TODO: get the argument span.\n-        (span, false)\n-    };\n+    let (span, is_macro_call) = walk_span_to_context(span, outer).map_or_else(\n+        || {\n+            // The span is from a macro argument, and the outer context is the macro using the argument\n+            if *applicability != Applicability::Unspecified {\n+                *applicability = Applicability::MaybeIncorrect;\n+            }\n+            // TODO: get the argument span.\n+            (span, false)\n+        },\n+        |outer_span| (outer_span, span.ctxt() != outer),\n+    );\n \n     (\n         snippet_with_applicability(cx, span, default, applicability),\n         is_macro_call,\n     )\n }\n \n+/// Walks the span up to the target context, thereby returning the macro call site if the span is\n+/// inside a macro expansion, or the original span if it is not. Note this will return `None` in the\n+/// case of the span being in a macro expansion, but the target context is from expanding a macro\n+/// argument.\n+///\n+/// Given the following\n+///\n+/// ```rust,ignore\n+/// macro_rules! m { ($e:expr) => { f($e) }; }\n+/// g(m!(0))\n+/// ```\n+///\n+/// If called with a span of the call to `f` and a context of the call to `g` this will return a\n+/// span containing `m!(0)`. However, if called with a span of the literal `0` this will give a span\n+/// containing `0` as the context is the same as the outer context.\n+///\n+/// This will traverse through multiple macro calls. Given the following:\n+///\n+/// ```rust,ignore\n+/// macro_rules! m { ($e:expr) => { n!($e, 0) }; }\n+/// macro_rules! n { ($e:expr, $f:expr) => { f($e, $f) }; }\n+/// g(m!(0))\n+/// ```\n+///\n+/// If called with a span of the call to `f` and a context of the call to `g` this will return a\n+/// span containing `m!(0)`.\n+pub fn walk_span_to_context(span: Span, outer: SyntaxContext) -> Option<Span> {\n+    let outer_span = hygiene::walk_chain(span, outer);\n+    (outer_span.ctxt() == outer).then(|| outer_span)\n+}\n+\n /// Removes block comments from the given `Vec` of lines.\n ///\n /// # Examples"}, {"sha": "d431bdf34eeeea2c62f0662f8ca562df16e35ac2", "filename": "clippy_utils/src/visitors.rs", "status": "modified", "additions": 53, "deletions": 2, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/d6058820237893566670d828c900de61c8e8f8af/clippy_utils%2Fsrc%2Fvisitors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6058820237893566670d828c900de61c8e8f8af/clippy_utils%2Fsrc%2Fvisitors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fvisitors.rs?ref=d6058820237893566670d828c900de61c8e8f8af", "patch": "@@ -1,7 +1,7 @@\n use crate::path_to_local_id;\n use rustc_hir as hir;\n-use rustc_hir::intravisit::{self, walk_expr, NestedVisitorMap, Visitor};\n-use rustc_hir::{Arm, Body, Expr, HirId, Stmt};\n+use rustc_hir::intravisit::{self, walk_expr, ErasedMap, NestedVisitorMap, Visitor};\n+use rustc_hir::{Arm, Block, Body, Destination, Expr, ExprKind, HirId, Stmt};\n use rustc_lint::LateContext;\n use rustc_middle::hir::map::Map;\n \n@@ -188,3 +188,54 @@ impl<'v> Visitor<'v> for LocalUsedVisitor<'v> {\n         NestedVisitorMap::OnlyBodies(self.hir)\n     }\n }\n+\n+pub trait Visitable<'tcx> {\n+    fn visit<V: Visitor<'tcx>>(self, v: &mut V);\n+}\n+impl Visitable<'tcx> for &'tcx Expr<'tcx> {\n+    fn visit<V: Visitor<'tcx>>(self, v: &mut V) {\n+        v.visit_expr(self)\n+    }\n+}\n+impl Visitable<'tcx> for &'tcx Block<'tcx> {\n+    fn visit<V: Visitor<'tcx>>(self, v: &mut V) {\n+        v.visit_block(self)\n+    }\n+}\n+impl<'tcx> Visitable<'tcx> for &'tcx Stmt<'tcx> {\n+    fn visit<V: Visitor<'tcx>>(self, v: &mut V) {\n+        v.visit_stmt(self)\n+    }\n+}\n+impl<'tcx> Visitable<'tcx> for &'tcx Body<'tcx> {\n+    fn visit<V: Visitor<'tcx>>(self, v: &mut V) {\n+        v.visit_body(self)\n+    }\n+}\n+impl<'tcx> Visitable<'tcx> for &'tcx Arm<'tcx> {\n+    fn visit<V: Visitor<'tcx>>(self, v: &mut V) {\n+        v.visit_arm(self)\n+    }\n+}\n+\n+pub fn visit_break_exprs<'tcx>(\n+    node: impl Visitable<'tcx>,\n+    f: impl FnMut(&'tcx Expr<'tcx>, Destination, Option<&'tcx Expr<'tcx>>),\n+) {\n+    struct V<F>(F);\n+    impl<'tcx, F: FnMut(&'tcx Expr<'tcx>, Destination, Option<&'tcx Expr<'tcx>>)> Visitor<'tcx> for V<F> {\n+        type Map = ErasedMap<'tcx>;\n+        fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n+            NestedVisitorMap::None\n+        }\n+\n+        fn visit_expr(&mut self, e: &'tcx Expr<'_>) {\n+            if let ExprKind::Break(dest, sub_expr) = e.kind {\n+                self.0(e, dest, sub_expr)\n+            }\n+            walk_expr(self, e);\n+        }\n+    }\n+\n+    node.visit(&mut V(f));\n+}"}, {"sha": "5a06afedbf4c2e7b86afff20847a30456b7a6d41", "filename": "doc/adding_lints.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d6058820237893566670d828c900de61c8e8f8af/doc%2Fadding_lints.md", "raw_url": "https://github.com/rust-lang/rust/raw/d6058820237893566670d828c900de61c8e8f8af/doc%2Fadding_lints.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Fadding_lints.md?ref=d6058820237893566670d828c900de61c8e8f8af", "patch": "@@ -454,7 +454,7 @@ in `clippy_lints/src/utils/conf.rs`:\n ```rust\n define_Conf! {\n     /// Lint: LIST, OF, LINTS, <THE_NEWLY_ADDED_LINT>. The minimum rust version that the project supports\n-    (msrv, \"msrv\": Option<String>, None),\n+    (msrv: Option<String> = None),\n     ...\n }\n ```\n@@ -562,7 +562,7 @@ in the following steps:\n     like this:\n     ```rust\n     /// Lint: LINT_NAME. <The configuration field doc comment>\n-    (configuration_ident, \"configuration_value\": Type, DefaultValue),\n+    (configuration_ident: Type = DefaultValue),\n     ```\n     The configuration value and identifier should usually be the same. The doc comment will be\n     automatically added to the lint documentation."}, {"sha": "593162f09a788ca221c0abda08d1fa589ff44a88", "filename": "rust-toolchain", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d6058820237893566670d828c900de61c8e8f8af/rust-toolchain", "raw_url": "https://github.com/rust-lang/rust/raw/d6058820237893566670d828c900de61c8e8f8af/rust-toolchain", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/rust-toolchain?ref=d6058820237893566670d828c900de61c8e8f8af", "patch": "@@ -1,3 +1,3 @@\n [toolchain]\n-channel = \"nightly-2021-04-22\"\n+channel = \"nightly-2021-05-06\"\n components = [\"llvm-tools-preview\", \"rustc-dev\", \"rust-src\"]"}, {"sha": "0c82f37d6a22e32572c15956bdf6ecd7e0c32d80", "filename": "src/driver.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d6058820237893566670d828c900de61c8e8f8af/src%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6058820237893566670d828c900de61c8e8f8af/src%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdriver.rs?ref=d6058820237893566670d828c900de61c8e8f8af", "patch": "@@ -106,7 +106,7 @@ impl rustc_driver::Callbacks for ClippyCallbacks {\n                 (previous)(sess, lint_store);\n             }\n \n-            let conf = clippy_lints::read_conf(&[], sess);\n+            let conf = clippy_lints::read_conf(sess);\n             clippy_lints::register_plugins(lint_store, sess, &conf);\n             clippy_lints::register_pre_expansion_lints(lint_store);\n             clippy_lints::register_renamed(lint_store);"}, {"sha": "6524fd4706ce13f37694cff7407c8515cfeec45c", "filename": "tests/dogfood.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d6058820237893566670d828c900de61c8e8f8af/tests%2Fdogfood.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6058820237893566670d828c900de61c8e8f8af/tests%2Fdogfood.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fdogfood.rs?ref=d6058820237893566670d828c900de61c8e8f8af", "patch": "@@ -1,3 +1,8 @@\n+//! This test is a part of quality control and makes clippy eat what it produces. Awesome lints and\n+//! long error messages\n+//!\n+//! See [Eating your own dog food](https://en.wikipedia.org/wiki/Eating_your_own_dog_food) for context\n+\n // Dogfood cannot run on Windows\n #![cfg(not(windows))]\n #![feature(once_cell)]\n@@ -17,12 +22,14 @@ fn dogfood_clippy() {\n         return;\n     }\n     let root_dir = PathBuf::from(env!(\"CARGO_MANIFEST_DIR\"));\n+    let enable_metadata_collection = std::env::var(\"ENABLE_METADATA_COLLECTION\").unwrap_or_else(|_| \"0\".to_string());\n \n     let mut command = Command::new(&*CLIPPY_PATH);\n     command\n         .current_dir(root_dir)\n         .env(\"CLIPPY_DOGFOOD\", \"1\")\n         .env(\"CARGO_INCREMENTAL\", \"0\")\n+        .env(\"ENABLE_METADATA_COLLECTION\", &enable_metadata_collection)\n         .arg(\"clippy\")\n         .arg(\"--all-targets\")\n         .arg(\"--all-features\")"}, {"sha": "c7bc261de6c5a3f8c10af3ffc10ae0a47df5d579", "filename": "tests/ui-toml/bad_toml_type/conf_bad_type.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d6058820237893566670d828c900de61c8e8f8af/tests%2Fui-toml%2Fbad_toml_type%2Fconf_bad_type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d6058820237893566670d828c900de61c8e8f8af/tests%2Fui-toml%2Fbad_toml_type%2Fconf_bad_type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-toml%2Fbad_toml_type%2Fconf_bad_type.stderr?ref=d6058820237893566670d828c900de61c8e8f8af", "patch": "@@ -1,4 +1,4 @@\n-error: error reading Clippy's configuration file `$DIR/clippy.toml`: invalid type: integer `42`, expected a sequence\n+error: error reading Clippy's configuration file `$DIR/clippy.toml`: invalid type: integer `42`, expected a sequence for key `blacklisted-names`\n \n error: aborting due to previous error\n "}, {"sha": "90021a034a3d3b358ae1eb472f733904ee8649d1", "filename": "tests/ui-toml/conf_deprecated_key/conf_deprecated_key.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d6058820237893566670d828c900de61c8e8f8af/tests%2Fui-toml%2Fconf_deprecated_key%2Fconf_deprecated_key.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d6058820237893566670d828c900de61c8e8f8af/tests%2Fui-toml%2Fconf_deprecated_key%2Fconf_deprecated_key.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-toml%2Fconf_deprecated_key%2Fconf_deprecated_key.stderr?ref=d6058820237893566670d828c900de61c8e8f8af", "patch": "@@ -1,4 +1,4 @@\n-error: error reading Clippy's configuration file `$DIR/clippy.toml`: found deprecated field `cyclomatic-complexity-threshold`. Please use `cognitive-complexity-threshold` instead.\n+error: error reading Clippy's configuration file `$DIR/clippy.toml`: deprecated field `cyclomatic-complexity-threshold`. Please use `cognitive-complexity-threshold` instead\n \n error: aborting due to previous error\n "}, {"sha": "69b8b6a0e68c3af97530ff3316c953e96c2d4efc", "filename": "tests/ui/builtin_type_shadow.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/d6058820237893566670d828c900de61c8e8f8af/tests%2Fui%2Fbuiltin_type_shadow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6058820237893566670d828c900de61c8e8f8af/tests%2Fui%2Fbuiltin_type_shadow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fbuiltin_type_shadow.rs?ref=d6058820237893566670d828c900de61c8e8f8af", "previous_filename": "tests/ui/builtin-type-shadow.rs"}, {"sha": "47a8a1e623e8aa0592b2abb24c8f4e88373543c6", "filename": "tests/ui/builtin_type_shadow.stderr", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d6058820237893566670d828c900de61c8e8f8af/tests%2Fui%2Fbuiltin_type_shadow.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d6058820237893566670d828c900de61c8e8f8af/tests%2Fui%2Fbuiltin_type_shadow.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fbuiltin_type_shadow.stderr?ref=d6058820237893566670d828c900de61c8e8f8af", "patch": "@@ -1,13 +1,13 @@\n error: this generic shadows the built-in type `u32`\n-  --> $DIR/builtin-type-shadow.rs:4:8\n+  --> $DIR/builtin_type_shadow.rs:4:8\n    |\n LL | fn foo<u32>(a: u32) -> u32 {\n    |        ^^^\n    |\n    = note: `-D clippy::builtin-type-shadow` implied by `-D warnings`\n \n error[E0308]: mismatched types\n-  --> $DIR/builtin-type-shadow.rs:5:5\n+  --> $DIR/builtin_type_shadow.rs:5:5\n    |\n LL | fn foo<u32>(a: u32) -> u32 {\n    |        ---             --- expected `u32` because of return type", "previous_filename": "tests/ui/builtin-type-shadow.stderr"}, {"sha": "c12c6a310275db9c77d39849235c02058c5ee4bb", "filename": "tests/ui/comparison_chain.rs", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/d6058820237893566670d828c900de61c8e8f8af/tests%2Fui%2Fcomparison_chain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6058820237893566670d828c900de61c8e8f8af/tests%2Fui%2Fcomparison_chain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcomparison_chain.rs?ref=d6058820237893566670d828c900de61c8e8f8af", "patch": "@@ -203,4 +203,32 @@ mod issue_5212 {\n     }\n }\n \n+enum Sign {\n+    Negative,\n+    Positive,\n+    Zero,\n+}\n+\n+impl Sign {\n+    const fn sign_i8(n: i8) -> Self {\n+        if n == 0 {\n+            Sign::Zero\n+        } else if n > 0 {\n+            Sign::Positive\n+        } else {\n+            Sign::Negative\n+        }\n+    }\n+}\n+\n+const fn sign_i8(n: i8) -> Sign {\n+    if n == 0 {\n+        Sign::Zero\n+    } else if n > 0 {\n+        Sign::Positive\n+    } else {\n+        Sign::Negative\n+    }\n+}\n+\n fn main() {}"}, {"sha": "ae67ebded437496e0d3e40c23c21a490e2b2901a", "filename": "tests/ui/copy_iterator.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d6058820237893566670d828c900de61c8e8f8af/tests%2Fui%2Fcopy_iterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6058820237893566670d828c900de61c8e8f8af/tests%2Fui%2Fcopy_iterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcopy_iterator.rs?ref=d6058820237893566670d828c900de61c8e8f8af", "patch": "@@ -16,8 +16,6 @@ impl Iterator for Countdown {\n \n fn main() {\n     let my_iterator = Countdown(5);\n-    let a: Vec<_> = my_iterator.take(1).collect();\n-    assert_eq!(a.len(), 1);\n-    let b: Vec<_> = my_iterator.collect();\n-    assert_eq!(b.len(), 5);\n+    assert_eq!(my_iterator.take(1).count(), 1);\n+    assert_eq!(my_iterator.count(), 5);\n }"}, {"sha": "82095febc194aefc5ca5237007bc26f762bee6ba", "filename": "tests/ui/crashes/ice-7169.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d6058820237893566670d828c900de61c8e8f8af/tests%2Fui%2Fcrashes%2Fice-7169.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6058820237893566670d828c900de61c8e8f8af/tests%2Fui%2Fcrashes%2Fice-7169.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcrashes%2Fice-7169.rs?ref=d6058820237893566670d828c900de61c8e8f8af", "patch": "@@ -0,0 +1,9 @@\n+#[derive(Default)]\n+struct A<T> {\n+    a: Vec<A<T>>,\n+    b: T,\n+}\n+\n+fn main() {\n+    if let Ok(_) = Ok::<_, ()>(A::<String>::default()) {}\n+}"}, {"sha": "5a9cd32380a19700ab44dc1a67c89934c8f1c19a", "filename": "tests/ui/crashes/ice-7169.stderr", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d6058820237893566670d828c900de61c8e8f8af/tests%2Fui%2Fcrashes%2Fice-7169.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d6058820237893566670d828c900de61c8e8f8af/tests%2Fui%2Fcrashes%2Fice-7169.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcrashes%2Fice-7169.stderr?ref=d6058820237893566670d828c900de61c8e8f8af", "patch": "@@ -0,0 +1,10 @@\n+error: redundant pattern matching, consider using `is_ok()`\n+  --> $DIR/ice-7169.rs:8:12\n+   |\n+LL |     if let Ok(_) = Ok::<_, ()>(A::<String>::default()) {}\n+   |     -------^^^^^-------------------------------------- help: try this: `if Ok::<_, ()>(A::<String>::default()).is_ok()`\n+   |\n+   = note: `-D clippy::redundant-pattern-matching` implied by `-D warnings`\n+\n+error: aborting due to previous error\n+"}, {"sha": "d742856bc4163af0999ad145af09e9a6d6dc942d", "filename": "tests/ui/eval_order_dependence.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d6058820237893566670d828c900de61c8e8f8af/tests%2Fui%2Feval_order_dependence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6058820237893566670d828c900de61c8e8f8af/tests%2Fui%2Feval_order_dependence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Feval_order_dependence.rs?ref=d6058820237893566670d828c900de61c8e8f8af", "patch": "@@ -1,3 +1,5 @@\n+// edition:2018\n+\n #[warn(clippy::eval_order_dependence)]\n #[allow(\n     unused_assignments,\n@@ -107,3 +109,7 @@ fn main() {\n         },\n     );\n }\n+\n+async fn issue_6925() {\n+    let _ = vec![async { true }.await, async { false }.await];\n+}"}, {"sha": "35eb85e95a320bf72497178054bf1a1a312bc20c", "filename": "tests/ui/eval_order_dependence.stderr", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/d6058820237893566670d828c900de61c8e8f8af/tests%2Fui%2Feval_order_dependence.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d6058820237893566670d828c900de61c8e8f8af/tests%2Fui%2Feval_order_dependence.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Feval_order_dependence.stderr?ref=d6058820237893566670d828c900de61c8e8f8af", "patch": "@@ -1,48 +1,48 @@\n-error: unsequenced read of a variable\n-  --> $DIR/eval_order_dependence.rs:15:9\n+error: unsequenced read of `x`\n+  --> $DIR/eval_order_dependence.rs:17:9\n    |\n LL |     } + x;\n    |         ^\n    |\n    = note: `-D clippy::eval-order-dependence` implied by `-D warnings`\n note: whether read occurs before this write depends on evaluation order\n-  --> $DIR/eval_order_dependence.rs:13:9\n+  --> $DIR/eval_order_dependence.rs:15:9\n    |\n LL |         x = 1;\n    |         ^^^^^\n \n-error: unsequenced read of a variable\n-  --> $DIR/eval_order_dependence.rs:18:5\n+error: unsequenced read of `x`\n+  --> $DIR/eval_order_dependence.rs:20:5\n    |\n LL |     x += {\n    |     ^\n    |\n note: whether read occurs before this write depends on evaluation order\n-  --> $DIR/eval_order_dependence.rs:19:9\n+  --> $DIR/eval_order_dependence.rs:21:9\n    |\n LL |         x = 20;\n    |         ^^^^^^\n \n-error: unsequenced read of a variable\n-  --> $DIR/eval_order_dependence.rs:31:12\n+error: unsequenced read of `x`\n+  --> $DIR/eval_order_dependence.rs:33:12\n    |\n LL |         a: x,\n    |            ^\n    |\n note: whether read occurs before this write depends on evaluation order\n-  --> $DIR/eval_order_dependence.rs:33:13\n+  --> $DIR/eval_order_dependence.rs:35:13\n    |\n LL |             x = 6;\n    |             ^^^^^\n \n-error: unsequenced read of a variable\n-  --> $DIR/eval_order_dependence.rs:40:9\n+error: unsequenced read of `x`\n+  --> $DIR/eval_order_dependence.rs:42:9\n    |\n LL |         x += {\n    |         ^\n    |\n note: whether read occurs before this write depends on evaluation order\n-  --> $DIR/eval_order_dependence.rs:41:13\n+  --> $DIR/eval_order_dependence.rs:43:13\n    |\n LL |             x = 20;\n    |             ^^^^^^"}, {"sha": "7698b88a88c8aa80a143ac27ab11e145a880ef51", "filename": "tests/ui/implicit_return.fixed", "status": "modified", "additions": 51, "deletions": 17, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/d6058820237893566670d828c900de61c8e8f8af/tests%2Fui%2Fimplicit_return.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/d6058820237893566670d828c900de61c8e8f8af/tests%2Fui%2Fimplicit_return.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimplicit_return.fixed?ref=d6058820237893566670d828c900de61c8e8f8af", "patch": "@@ -1,7 +1,8 @@\n+// edition:2018\n // run-rustfix\n \n #![warn(clippy::implicit_return)]\n-#![allow(clippy::needless_return, unused)]\n+#![allow(clippy::needless_return, clippy::needless_bool, unused, clippy::never_loop)]\n \n fn test_end_of_fn() -> bool {\n     if true {\n@@ -12,7 +13,6 @@ fn test_end_of_fn() -> bool {\n     return true\n }\n \n-#[allow(clippy::needless_bool)]\n fn test_if_block() -> bool {\n     if true { return true } else { return false }\n }\n@@ -25,22 +25,19 @@ fn test_match(x: bool) -> bool {\n     }\n }\n \n-#[allow(clippy::needless_return)]\n fn test_match_with_unreachable(x: bool) -> bool {\n     match x {\n         true => return false,\n         false => unreachable!(),\n     }\n }\n \n-#[allow(clippy::never_loop)]\n fn test_loop() -> bool {\n     loop {\n         return true;\n     }\n }\n \n-#[allow(clippy::never_loop)]\n fn test_loop_with_block() -> bool {\n     loop {\n         {\n@@ -49,7 +46,6 @@ fn test_loop_with_block() -> bool {\n     }\n }\n \n-#[allow(clippy::never_loop)]\n fn test_loop_with_nests() -> bool {\n     loop {\n         if true {\n@@ -83,15 +79,53 @@ fn test_return_macro() -> String {\n     return format!(\"test {}\", \"test\")\n }\n \n-fn main() {\n-    let _ = test_end_of_fn();\n-    let _ = test_if_block();\n-    let _ = test_match(true);\n-    let _ = test_match_with_unreachable(true);\n-    let _ = test_loop();\n-    let _ = test_loop_with_block();\n-    let _ = test_loop_with_nests();\n-    let _ = test_loop_with_if_let();\n-    test_closure();\n-    let _ = test_return_macro();\n+fn macro_branch_test() -> bool {\n+    macro_rules! m {\n+        ($t:expr, $f:expr) => {\n+            if true { $t } else { $f }\n+        };\n+    }\n+    return m!(true, false)\n+}\n+\n+fn loop_test() -> bool {\n+    'outer: loop {\n+        if true {\n+            return true;\n+        }\n+\n+        let _ = loop {\n+            if false {\n+                return false;\n+            }\n+            if true {\n+                break true;\n+            }\n+        };\n+    }\n }\n+\n+fn loop_macro_test() -> bool {\n+    macro_rules! m {\n+        ($e:expr) => {\n+            break $e\n+        };\n+    }\n+    return loop {\n+        m!(true);\n+    }\n+}\n+\n+fn divergent_test() -> bool {\n+    fn diverge() -> ! {\n+        panic!()\n+    }\n+    diverge()\n+}\n+\n+// issue #6940\n+async fn foo() -> bool {\n+    return true\n+}\n+\n+fn main() {}"}, {"sha": "45bbc2ec670e05463d1a0f8d6f8d5fc557561cfe", "filename": "tests/ui/implicit_return.rs", "status": "modified", "additions": 51, "deletions": 17, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/d6058820237893566670d828c900de61c8e8f8af/tests%2Fui%2Fimplicit_return.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6058820237893566670d828c900de61c8e8f8af/tests%2Fui%2Fimplicit_return.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimplicit_return.rs?ref=d6058820237893566670d828c900de61c8e8f8af", "patch": "@@ -1,7 +1,8 @@\n+// edition:2018\n // run-rustfix\n \n #![warn(clippy::implicit_return)]\n-#![allow(clippy::needless_return, unused)]\n+#![allow(clippy::needless_return, clippy::needless_bool, unused, clippy::never_loop)]\n \n fn test_end_of_fn() -> bool {\n     if true {\n@@ -12,7 +13,6 @@ fn test_end_of_fn() -> bool {\n     true\n }\n \n-#[allow(clippy::needless_bool)]\n fn test_if_block() -> bool {\n     if true { true } else { false }\n }\n@@ -25,22 +25,19 @@ fn test_match(x: bool) -> bool {\n     }\n }\n \n-#[allow(clippy::needless_return)]\n fn test_match_with_unreachable(x: bool) -> bool {\n     match x {\n         true => return false,\n         false => unreachable!(),\n     }\n }\n \n-#[allow(clippy::never_loop)]\n fn test_loop() -> bool {\n     loop {\n         break true;\n     }\n }\n \n-#[allow(clippy::never_loop)]\n fn test_loop_with_block() -> bool {\n     loop {\n         {\n@@ -49,7 +46,6 @@ fn test_loop_with_block() -> bool {\n     }\n }\n \n-#[allow(clippy::never_loop)]\n fn test_loop_with_nests() -> bool {\n     loop {\n         if true {\n@@ -83,15 +79,53 @@ fn test_return_macro() -> String {\n     format!(\"test {}\", \"test\")\n }\n \n-fn main() {\n-    let _ = test_end_of_fn();\n-    let _ = test_if_block();\n-    let _ = test_match(true);\n-    let _ = test_match_with_unreachable(true);\n-    let _ = test_loop();\n-    let _ = test_loop_with_block();\n-    let _ = test_loop_with_nests();\n-    let _ = test_loop_with_if_let();\n-    test_closure();\n-    let _ = test_return_macro();\n+fn macro_branch_test() -> bool {\n+    macro_rules! m {\n+        ($t:expr, $f:expr) => {\n+            if true { $t } else { $f }\n+        };\n+    }\n+    m!(true, false)\n+}\n+\n+fn loop_test() -> bool {\n+    'outer: loop {\n+        if true {\n+            break true;\n+        }\n+\n+        let _ = loop {\n+            if false {\n+                break 'outer false;\n+            }\n+            if true {\n+                break true;\n+            }\n+        };\n+    }\n+}\n+\n+fn loop_macro_test() -> bool {\n+    macro_rules! m {\n+        ($e:expr) => {\n+            break $e\n+        };\n+    }\n+    loop {\n+        m!(true);\n+    }\n+}\n+\n+fn divergent_test() -> bool {\n+    fn diverge() -> ! {\n+        panic!()\n+    }\n+    diverge()\n }\n+\n+// issue #6940\n+async fn foo() -> bool {\n+    true\n+}\n+\n+fn main() {}"}, {"sha": "16fe9ed444ff696d20c0c3411cb56913a631a6d2", "filename": "tests/ui/implicit_return.stderr", "status": "modified", "additions": 47, "deletions": 8, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/d6058820237893566670d828c900de61c8e8f8af/tests%2Fui%2Fimplicit_return.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d6058820237893566670d828c900de61c8e8f8af/tests%2Fui%2Fimplicit_return.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimplicit_return.stderr?ref=d6058820237893566670d828c900de61c8e8f8af", "patch": "@@ -1,5 +1,5 @@\n error: missing `return` statement\n-  --> $DIR/implicit_return.rs:12:5\n+  --> $DIR/implicit_return.rs:13:5\n    |\n LL |     true\n    |     ^^^^ help: add `return` as shown: `return true`\n@@ -31,40 +31,79 @@ LL |         false => { true },\n    |                    ^^^^ help: add `return` as shown: `return true`\n \n error: missing `return` statement\n-  --> $DIR/implicit_return.rs:39:9\n+  --> $DIR/implicit_return.rs:37:9\n    |\n LL |         break true;\n    |         ^^^^^^^^^^ help: change `break` to `return` as shown: `return true`\n \n error: missing `return` statement\n-  --> $DIR/implicit_return.rs:47:13\n+  --> $DIR/implicit_return.rs:44:13\n    |\n LL |             break true;\n    |             ^^^^^^^^^^ help: change `break` to `return` as shown: `return true`\n \n error: missing `return` statement\n-  --> $DIR/implicit_return.rs:56:13\n+  --> $DIR/implicit_return.rs:52:13\n    |\n LL |             break true;\n    |             ^^^^^^^^^^ help: change `break` to `return` as shown: `return true`\n \n error: missing `return` statement\n-  --> $DIR/implicit_return.rs:74:18\n+  --> $DIR/implicit_return.rs:70:18\n    |\n LL |     let _ = || { true };\n    |                  ^^^^ help: add `return` as shown: `return true`\n \n error: missing `return` statement\n-  --> $DIR/implicit_return.rs:75:16\n+  --> $DIR/implicit_return.rs:71:16\n    |\n LL |     let _ = || true;\n    |                ^^^^ help: add `return` as shown: `return true`\n \n error: missing `return` statement\n-  --> $DIR/implicit_return.rs:83:5\n+  --> $DIR/implicit_return.rs:79:5\n    |\n LL |     format!(\"test {}\", \"test\")\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: add `return` as shown: `return format!(\"test {}\", \"test\")`\n \n-error: aborting due to 11 previous errors\n+error: missing `return` statement\n+  --> $DIR/implicit_return.rs:88:5\n+   |\n+LL |     m!(true, false)\n+   |     ^^^^^^^^^^^^^^^ help: add `return` as shown: `return m!(true, false)`\n+\n+error: missing `return` statement\n+  --> $DIR/implicit_return.rs:94:13\n+   |\n+LL |             break true;\n+   |             ^^^^^^^^^^ help: change `break` to `return` as shown: `return true`\n+\n+error: missing `return` statement\n+  --> $DIR/implicit_return.rs:99:17\n+   |\n+LL |                 break 'outer false;\n+   |                 ^^^^^^^^^^^^^^^^^^ help: change `break` to `return` as shown: `return false`\n+\n+error: missing `return` statement\n+  --> $DIR/implicit_return.rs:114:5\n+   |\n+LL | /     loop {\n+LL | |         m!(true);\n+LL | |     }\n+   | |_____^\n+   |\n+help: add `return` as shown\n+   |\n+LL |     return loop {\n+LL |         m!(true);\n+LL |     }\n+   |\n+\n+error: missing `return` statement\n+  --> $DIR/implicit_return.rs:128:5\n+   |\n+LL |     true\n+   |     ^^^^ help: add `return` as shown: `return true`\n+\n+error: aborting due to 16 previous errors\n "}, {"sha": "3d8fb8507e515c470a8ff1d2a59d5002b7ef3fd1", "filename": "tests/ui/infinite_loop.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d6058820237893566670d828c900de61c8e8f8af/tests%2Fui%2Finfinite_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6058820237893566670d828c900de61c8e8f8af/tests%2Fui%2Finfinite_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Finfinite_loop.rs?ref=d6058820237893566670d828c900de61c8e8f8af", "patch": "@@ -192,11 +192,23 @@ fn while_loop_with_break_and_return() {\n     }\n }\n \n+fn immutable_condition_false_positive(mut n: u64) -> u32 {\n+    let mut count = 0;\n+    while {\n+        n >>= 1;\n+        n != 0\n+    } {\n+        count += 1;\n+    }\n+    count\n+}\n+\n fn main() {\n     immutable_condition();\n     unused_var();\n     used_immutable();\n     internally_mutable();\n+    immutable_condition_false_positive(5);\n \n     let mut c = Counter { count: 0 };\n     c.inc_n(5);"}, {"sha": "2458bf1e490bbf9c672de2987677c9157ed9b0a5", "filename": "tests/ui/needless_collect_indirect.rs", "status": "modified", "additions": 33, "deletions": 1, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/d6058820237893566670d828c900de61c8e8f8af/tests%2Fui%2Fneedless_collect_indirect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6058820237893566670d828c900de61c8e8f8af/tests%2Fui%2Fneedless_collect_indirect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_collect_indirect.rs?ref=d6058820237893566670d828c900de61c8e8f8af", "patch": "@@ -1,4 +1,4 @@\n-use std::collections::{HashMap, VecDeque};\n+use std::collections::{BinaryHeap, HashMap, LinkedList, VecDeque};\n \n fn main() {\n     let sample = [1; 5];\n@@ -43,3 +43,35 @@ fn main() {\n             .collect::<Vec<_>>();\n     }\n }\n+\n+mod issue7110 {\n+    // #7110 - lint for type annotation cases\n+    use super::*;\n+\n+    fn lint_vec(string: &str) -> usize {\n+        let buffer: Vec<&str> = string.split('/').collect();\n+        buffer.len()\n+    }\n+    fn lint_vec_deque() -> usize {\n+        let sample = [1; 5];\n+        let indirect_len: VecDeque<_> = sample.iter().collect();\n+        indirect_len.len()\n+    }\n+    fn lint_linked_list() -> usize {\n+        let sample = [1; 5];\n+        let indirect_len: LinkedList<_> = sample.iter().collect();\n+        indirect_len.len()\n+    }\n+    fn lint_binary_heap() -> usize {\n+        let sample = [1; 5];\n+        let indirect_len: BinaryHeap<_> = sample.iter().collect();\n+        indirect_len.len()\n+    }\n+    fn dont_lint(string: &str) -> usize {\n+        let buffer: Vec<&str> = string.split('/').collect();\n+        for buff in &buffer {\n+            println!(\"{}\", buff);\n+        }\n+        buffer.len()\n+    }\n+}"}, {"sha": "f094e182a48f31eb1cb9e945581f7cf32613829d", "filename": "tests/ui/needless_collect_indirect.stderr", "status": "modified", "additions": 57, "deletions": 1, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/d6058820237893566670d828c900de61c8e8f8af/tests%2Fui%2Fneedless_collect_indirect.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d6058820237893566670d828c900de61c8e8f8af/tests%2Fui%2Fneedless_collect_indirect.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_collect_indirect.stderr?ref=d6058820237893566670d828c900de61c8e8f8af", "patch": "@@ -69,5 +69,61 @@ LL |\n LL |     sample.into_iter().any(|x| x == a);\n    |\n \n-error: aborting due to 5 previous errors\n+error: avoid using `collect()` when not needed\n+  --> $DIR/needless_collect_indirect.rs:52:51\n+   |\n+LL |         let buffer: Vec<&str> = string.split('/').collect();\n+   |                                                   ^^^^^^^\n+LL |         buffer.len()\n+   |         ------------ the iterator could be used here instead\n+   |\n+help: take the original Iterator's count instead of collecting it and finding the length\n+   |\n+LL |         \n+LL |         string.split('/').count()\n+   |\n+\n+error: avoid using `collect()` when not needed\n+  --> $DIR/needless_collect_indirect.rs:57:55\n+   |\n+LL |         let indirect_len: VecDeque<_> = sample.iter().collect();\n+   |                                                       ^^^^^^^\n+LL |         indirect_len.len()\n+   |         ------------------ the iterator could be used here instead\n+   |\n+help: take the original Iterator's count instead of collecting it and finding the length\n+   |\n+LL |         \n+LL |         sample.iter().count()\n+   |\n+\n+error: avoid using `collect()` when not needed\n+  --> $DIR/needless_collect_indirect.rs:62:57\n+   |\n+LL |         let indirect_len: LinkedList<_> = sample.iter().collect();\n+   |                                                         ^^^^^^^\n+LL |         indirect_len.len()\n+   |         ------------------ the iterator could be used here instead\n+   |\n+help: take the original Iterator's count instead of collecting it and finding the length\n+   |\n+LL |         \n+LL |         sample.iter().count()\n+   |\n+\n+error: avoid using `collect()` when not needed\n+  --> $DIR/needless_collect_indirect.rs:67:57\n+   |\n+LL |         let indirect_len: BinaryHeap<_> = sample.iter().collect();\n+   |                                                         ^^^^^^^\n+LL |         indirect_len.len()\n+   |         ------------------ the iterator could be used here instead\n+   |\n+help: take the original Iterator's count instead of collecting it and finding the length\n+   |\n+LL |         \n+LL |         sample.iter().count()\n+   |\n+\n+error: aborting due to 9 previous errors\n "}, {"sha": "fcbe9af9f5616c177b860960e5276fd2e735b86e", "filename": "tests/ui/single_char_pattern.fixed", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d6058820237893566670d828c900de61c8e8f8af/tests%2Fui%2Fsingle_char_pattern.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/d6058820237893566670d828c900de61c8e8f8af/tests%2Fui%2Fsingle_char_pattern.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsingle_char_pattern.fixed?ref=d6058820237893566670d828c900de61c8e8f8af", "patch": "@@ -33,6 +33,8 @@ fn main() {\n     x.rmatch_indices('x');\n     x.trim_start_matches('x');\n     x.trim_end_matches('x');\n+    x.strip_prefix('x');\n+    x.strip_suffix('x');\n     // Make sure we escape characters correctly.\n     x.split('\\n');\n     x.split('\\'');"}, {"sha": "b8bc20f4070fc4a91f797a8d3d6dc51c85223f6b", "filename": "tests/ui/single_char_pattern.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d6058820237893566670d828c900de61c8e8f8af/tests%2Fui%2Fsingle_char_pattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6058820237893566670d828c900de61c8e8f8af/tests%2Fui%2Fsingle_char_pattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsingle_char_pattern.rs?ref=d6058820237893566670d828c900de61c8e8f8af", "patch": "@@ -33,6 +33,8 @@ fn main() {\n     x.rmatch_indices(\"x\");\n     x.trim_start_matches(\"x\");\n     x.trim_end_matches(\"x\");\n+    x.strip_prefix(\"x\");\n+    x.strip_suffix(\"x\");\n     // Make sure we escape characters correctly.\n     x.split(\"\\n\");\n     x.split(\"'\");"}, {"sha": "6d94d8a34e39095dfe8c4086e5c8e05929d7e0ac", "filename": "tests/ui/single_char_pattern.stderr", "status": "modified", "additions": 23, "deletions": 11, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/d6058820237893566670d828c900de61c8e8f8af/tests%2Fui%2Fsingle_char_pattern.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d6058820237893566670d828c900de61c8e8f8af/tests%2Fui%2Fsingle_char_pattern.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsingle_char_pattern.stderr?ref=d6058820237893566670d828c900de61c8e8f8af", "patch": "@@ -121,64 +121,76 @@ LL |     x.trim_end_matches(\"x\");\n    |                        ^^^ help: try using a `char` instead: `'x'`\n \n error: single-character string constant used as pattern\n-  --> $DIR/single_char_pattern.rs:37:13\n+  --> $DIR/single_char_pattern.rs:36:20\n+   |\n+LL |     x.strip_prefix(\"x\");\n+   |                    ^^^ help: try using a `char` instead: `'x'`\n+\n+error: single-character string constant used as pattern\n+  --> $DIR/single_char_pattern.rs:37:20\n+   |\n+LL |     x.strip_suffix(\"x\");\n+   |                    ^^^ help: try using a `char` instead: `'x'`\n+\n+error: single-character string constant used as pattern\n+  --> $DIR/single_char_pattern.rs:39:13\n    |\n LL |     x.split(\"/n\");\n    |             ^^^^ help: try using a `char` instead: `'/n'`\n \n error: single-character string constant used as pattern\n-  --> $DIR/single_char_pattern.rs:38:13\n+  --> $DIR/single_char_pattern.rs:40:13\n    |\n LL |     x.split(\"'\");\n    |             ^^^ help: try using a `char` instead: `'/''`\n \n error: single-character string constant used as pattern\n-  --> $DIR/single_char_pattern.rs:39:13\n+  --> $DIR/single_char_pattern.rs:41:13\n    |\n LL |     x.split(\"/'\");\n    |             ^^^^ help: try using a `char` instead: `'/''`\n \n error: single-character string constant used as pattern\n-  --> $DIR/single_char_pattern.rs:44:31\n+  --> $DIR/single_char_pattern.rs:46:31\n    |\n LL |     x.replace(\";\", \",\").split(\",\"); // issue #2978\n    |                               ^^^ help: try using a `char` instead: `','`\n \n error: single-character string constant used as pattern\n-  --> $DIR/single_char_pattern.rs:45:19\n+  --> $DIR/single_char_pattern.rs:47:19\n    |\n LL |     x.starts_with(\"/x03\"); // issue #2996\n    |                   ^^^^^^ help: try using a `char` instead: `'/x03'`\n \n error: single-character string constant used as pattern\n-  --> $DIR/single_char_pattern.rs:52:13\n+  --> $DIR/single_char_pattern.rs:54:13\n    |\n LL |     x.split(r\"a\");\n    |             ^^^^ help: try using a `char` instead: `'a'`\n \n error: single-character string constant used as pattern\n-  --> $DIR/single_char_pattern.rs:53:13\n+  --> $DIR/single_char_pattern.rs:55:13\n    |\n LL |     x.split(r#\"a\"#);\n    |             ^^^^^^ help: try using a `char` instead: `'a'`\n \n error: single-character string constant used as pattern\n-  --> $DIR/single_char_pattern.rs:54:13\n+  --> $DIR/single_char_pattern.rs:56:13\n    |\n LL |     x.split(r###\"a\"###);\n    |             ^^^^^^^^^^ help: try using a `char` instead: `'a'`\n \n error: single-character string constant used as pattern\n-  --> $DIR/single_char_pattern.rs:55:13\n+  --> $DIR/single_char_pattern.rs:57:13\n    |\n LL |     x.split(r###\"'\"###);\n    |             ^^^^^^^^^^ help: try using a `char` instead: `'/''`\n \n error: single-character string constant used as pattern\n-  --> $DIR/single_char_pattern.rs:56:13\n+  --> $DIR/single_char_pattern.rs:58:13\n    |\n LL |     x.split(r###\"#\"###);\n    |             ^^^^^^^^^^ help: try using a `char` instead: `'#'`\n \n-error: aborting due to 30 previous errors\n+error: aborting due to 32 previous errors\n "}, {"sha": "c58181f518d58e10fdc42e9267a14012c549a858", "filename": "tests/ui/unnecessary_filter_map.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d6058820237893566670d828c900de61c8e8f8af/tests%2Fui%2Funnecessary_filter_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6058820237893566670d828c900de61c8e8f8af/tests%2Fui%2Funnecessary_filter_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funnecessary_filter_map.rs?ref=d6058820237893566670d828c900de61c8e8f8af", "patch": "@@ -15,3 +15,7 @@ fn main() {\n \n     let _ = (0..4).filter_map(i32::checked_abs);\n }\n+\n+fn filter_map_none_changes_item_type() -> impl Iterator<Item = bool> {\n+    \"\".chars().filter_map(|_| None)\n+}"}, {"sha": "7bb43cf7ae82ded49dc035f3e03f798993547cc6", "filename": "tests/ui/unused_unit.fixed", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d6058820237893566670d828c900de61c8e8f8af/tests%2Fui%2Funused_unit.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/d6058820237893566670d828c900de61c8e8f8af/tests%2Fui%2Funused_unit.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funused_unit.fixed?ref=d6058820237893566670d828c900de61c8e8f8af", "patch": "@@ -80,3 +80,10 @@ fn test2(){}\n \n #[rustfmt::skip]\n fn test3(){}\n+\n+fn macro_expr() {\n+    macro_rules! e {\n+        () => (());\n+    }\n+    e!()\n+}"}, {"sha": "21073fb802adab910d8832a307472ef04cafd341", "filename": "tests/ui/unused_unit.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d6058820237893566670d828c900de61c8e8f8af/tests%2Fui%2Funused_unit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6058820237893566670d828c900de61c8e8f8af/tests%2Fui%2Funused_unit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funused_unit.rs?ref=d6058820237893566670d828c900de61c8e8f8af", "patch": "@@ -80,3 +80,10 @@ fn test2() ->(){}\n \n #[rustfmt::skip]\n fn test3()-> (){}\n+\n+fn macro_expr() {\n+    macro_rules! e {\n+        () => (());\n+    }\n+    e!()\n+}"}, {"sha": "5707cf0ce0f8c08177f68866b7065c6c9feb2182", "filename": "util/lintlib.py", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d6058820237893566670d828c900de61c8e8f8af/util%2Flintlib.py", "raw_url": "https://github.com/rust-lang/rust/raw/d6058820237893566670d828c900de61c8e8f8af/util%2Flintlib.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/util%2Flintlib.py?ref=d6058820237893566670d828c900de61c8e8f8af", "patch": "@@ -14,7 +14,7 @@\n group_re = re.compile(r'''\\s*([a-z_][a-z_0-9]+)''')\n conf_re = re.compile(r'''define_Conf! {\\n([^}]*)\\n}''', re.MULTILINE)\n confvar_re = re.compile(\n-    r'''/// Lint: ([\\w,\\s]+)\\. (.*)\\n\\s*\\([^,]+,\\s+\"([^\"]+)\":\\s+([^,]+),\\s+([^\\.\\)]+).*\\),''', re.MULTILINE)\n+    r'''/// Lint: ([\\w,\\s]+)\\. (.*)\\n\\s*\\(([^:]+):\\s*([^\\s=]+)\\s*=\\s*([^\\.\\)]+).*\\),''', re.MULTILINE)\n comment_re = re.compile(r'''\\s*/// ?(.*)''')\n \n lint_levels = {"}]}