{"sha": "6d4c2141b5042bd9469005444987f5fb3f20fa73", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZkNGMyMTQxYjUwNDJiZDk0NjkwMDU0NDQ5ODdmNWZiM2YyMGZhNzM=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-05-07T16:57:51Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-05-13T14:42:59Z"}, "message": "rustc: use DefId instead of CodeExtent for FreeRegion's scope.", "tree": {"sha": "1f2498d292f97387a74968adcc580a1456d76d48", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1f2498d292f97387a74968adcc580a1456d76d48"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6d4c2141b5042bd9469005444987f5fb3f20fa73", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6d4c2141b5042bd9469005444987f5fb3f20fa73", "html_url": "https://github.com/rust-lang/rust/commit/6d4c2141b5042bd9469005444987f5fb3f20fa73", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6d4c2141b5042bd9469005444987f5fb3f20fa73/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "72aab7ade4e333896f4a553ad59b73346dcd8f43", "url": "https://api.github.com/repos/rust-lang/rust/commits/72aab7ade4e333896f4a553ad59b73346dcd8f43", "html_url": "https://github.com/rust-lang/rust/commit/72aab7ade4e333896f4a553ad59b73346dcd8f43"}], "stats": {"total": 383, "additions": 149, "deletions": 234}, "files": [{"sha": "f822361198ffee5247774f179facc4bd2c6514b4", "filename": "src/librustc/ich/impls_ty.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6d4c2141b5042bd9469005444987f5fb3f20fa73/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d4c2141b5042bd9469005444987f5fb3f20fa73/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_ty.rs?ref=6d4c2141b5042bd9469005444987f5fb3f20fa73", "patch": "@@ -409,11 +409,6 @@ impl_stable_hash_for!(enum ::middle::resolve_lifetime::Region {\n     Free(call_site_scope_data, decl)\n });\n \n-impl_stable_hash_for!(struct ::middle::region::CallSiteScopeData {\n-    fn_id,\n-    body_id\n-});\n-\n impl_stable_hash_for!(struct ty::DebruijnIndex {\n     depth\n });\n@@ -466,7 +461,7 @@ impl_stable_hash_for!(struct ty::adjustment::CoerceUnsizedInfo {\n     custom_kind\n });\n \n-impl_stable_hash_for!(struct ty::FreeRegion<'tcx> {\n+impl_stable_hash_for!(struct ty::FreeRegion {\n     scope,\n     bound_region\n });"}, {"sha": "389103e203e219ea08868aa2e5388e98f3dfcb04", "filename": "src/librustc/infer/error_reporting/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6d4c2141b5042bd9469005444987f5fb3f20fa73/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d4c2141b5042bd9469005444987f5fb3f20fa73/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=6d4c2141b5042bd9469005444987f5fb3f20fa73", "patch": "@@ -184,7 +184,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                     }\n                 };\n \n-                let node = fr.scope.map(|s| s.node_id())\n+                let node = self.hir.as_local_node_id(fr.scope)\n                                    .unwrap_or(DUMMY_NODE_ID);\n                 let unknown;\n                 let tag = match self.hir.find(node) {"}, {"sha": "23d720433c28227c3e5dcddc2893003d90c630b3", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6d4c2141b5042bd9469005444987f5fb3f20fa73/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d4c2141b5042bd9469005444987f5fb3f20fa73/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=6d4c2141b5042bd9469005444987f5fb3f20fa73", "patch": "@@ -1009,7 +1009,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn add_given(&self,\n-                     sub: ty::FreeRegion<'tcx>,\n+                     sub: ty::FreeRegion,\n                      sup: ty::RegionVid)\n     {\n         self.region_vars.add_given(sub, sup);"}, {"sha": "4c82c3bfb85f60a0341fbefd464b498c43d3daef", "filename": "src/librustc/infer/region_inference/mod.rs", "status": "modified", "additions": 13, "deletions": 14, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/6d4c2141b5042bd9469005444987f5fb3f20fa73/src%2Flibrustc%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d4c2141b5042bd9469005444987f5fb3f20fa73/src%2Flibrustc%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fregion_inference%2Fmod.rs?ref=6d4c2141b5042bd9469005444987f5fb3f20fa73", "patch": "@@ -127,7 +127,7 @@ pub enum UndoLogEntry<'tcx> {\n     AddVerify(usize),\n \n     /// We added the given `given`\n-    AddGiven(ty::FreeRegion<'tcx>, ty::RegionVid),\n+    AddGiven(ty::FreeRegion, ty::RegionVid),\n \n     /// We added a GLB/LUB \"combinaton variable\"\n     AddCombination(CombineMapType, TwoRegions<'tcx>),\n@@ -213,7 +213,7 @@ pub struct RegionVarBindings<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     // record the fact that `'a <= 'b` is implied by the fn signature,\n     // and then ignore the constraint when solving equations. This is\n     // a bit of a hack but seems to work.\n-    givens: RefCell<FxHashSet<(ty::FreeRegion<'tcx>, ty::RegionVid)>>,\n+    givens: RefCell<FxHashSet<(ty::FreeRegion, ty::RegionVid)>>,\n \n     lubs: RefCell<CombineMap<'tcx>>,\n     glbs: RefCell<CombineMap<'tcx>>,\n@@ -661,7 +661,7 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    pub fn add_given(&self, sub: ty::FreeRegion<'tcx>, sup: ty::RegionVid) {\n+    pub fn add_given(&self, sub: ty::FreeRegion, sup: ty::RegionVid) {\n         // cannot add givens once regions are resolved\n         assert!(self.values_are_none());\n \n@@ -931,19 +931,18 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n                           b);\n             }\n \n-            (&ReFree(fr), &ReScope(s_id)) |\n-            (&ReScope(s_id), &ReFree(fr)) => {\n+            (&ReFree(ref fr), &ReScope(s_id)) |\n+            (&ReScope(s_id), &ReFree(ref fr)) => {\n                 // A \"free\" region can be interpreted as \"some region\n-                // at least as big as the block fr.scope_id\".  So, we can\n+                // at least as big as fr.scope\".  So, we can\n                 // reasonably compare free regions and scopes:\n-                if let Some(fr_scope) = fr.scope {\n-                    let r_id = region_rels.region_maps.nearest_common_ancestor(fr_scope, s_id);\n-                    if r_id == fr_scope {\n-                        // if the free region's scope `fr.scope_id` is bigger than\n-                        // the scope region `s_id`, then the LUB is the free\n-                        // region itself:\n-                        return self.tcx.mk_region(ReFree(fr));\n-                    }\n+                let fr_scope = region_rels.region_maps.free_extent(self.tcx, fr);\n+                let r_id = region_rels.region_maps.nearest_common_ancestor(fr_scope, s_id);\n+                if r_id == fr_scope {\n+                    // if the free region's scope `fr.scope` is bigger than\n+                    // the scope region `s_id`, then the LUB is the free\n+                    // region itself:\n+                    return self.tcx.mk_region(ReFree(*fr));\n                 }\n \n                 // otherwise, we don't know what the free region is,"}, {"sha": "e0d13878f14f750f3c9cb736fed296541ff762c0", "filename": "src/librustc/middle/free_region.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/6d4c2141b5042bd9469005444987f5fb3f20fa73/src%2Flibrustc%2Fmiddle%2Ffree_region.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d4c2141b5042bd9469005444987f5fb3f20fa73/src%2Flibrustc%2Fmiddle%2Ffree_region.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ffree_region.rs?ref=6d4c2141b5042bd9469005444987f5fb3f20fa73", "patch": "@@ -71,12 +71,9 @@ impl<'a, 'gcx, 'tcx> RegionRelations<'a, 'gcx, 'tcx> {\n                 (&ty::ReScope(sub_scope), &ty::ReScope(super_scope)) =>\n                     self.region_maps.is_subscope_of(sub_scope, super_scope),\n \n-                (&ty::ReScope(sub_scope), &ty::ReFree(fr)) => {\n-                    // 1. It is safe to unwrap `fr.scope` because we\n-                    // should only ever wind up comparing against\n-                    // `ReScope` in the context of a method or\n-                    // body, where `fr.scope` should be `Some`.\n-                    self.region_maps.is_subscope_of(sub_scope, fr.scope.unwrap() /*1*/) ||\n+                (&ty::ReScope(sub_scope), &ty::ReFree(ref fr)) => {\n+                    let fr_scope = self.region_maps.free_extent(self.tcx, fr);\n+                    self.region_maps.is_subscope_of(sub_scope, fr_scope) ||\n                         self.is_static(super_region)\n                 }\n "}, {"sha": "732fb054bc42daa345f5221f2a7621615ecaf040", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6d4c2141b5042bd9469005444987f5fb3f20fa73/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d4c2141b5042bd9469005444987f5fb3f20fa73/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=6d4c2141b5042bd9469005444987f5fb3f20fa73", "patch": "@@ -1440,9 +1440,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         // within the fn body, late-bound regions are liberated\n         // and must outlive the *call-site* of the function.\n         let fn_ret =\n-            self.ir.tcx.liberate_late_bound_regions(\n-                Some(self.ir.tcx.call_site_extent(id)),\n-                &fn_ret);\n+            self.ir.tcx.liberate_late_bound_regions(def_id, &fn_ret);\n \n         if !fn_ret.is_never() && self.live_on_entry(entry_ln, self.s.no_ret_var).is_some() {\n             let param_env = self.ir.tcx.parameter_environment(def_id);"}, {"sha": "8e25c6facf24d7432a83b73e68f1ad172ac1007e", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6d4c2141b5042bd9469005444987f5fb3f20fa73/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d4c2141b5042bd9469005444987f5fb3f20fa73/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=6d4c2141b5042bd9469005444987f5fb3f20fa73", "patch": "@@ -790,7 +790,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n             // The environment of a closure is guaranteed to\n             // outlive any bindings introduced in the body of the\n             // closure itself.\n-            scope: Some(self.tcx().call_site_extent(upvar_id.closure_expr_id)),\n+            scope: self.tcx().hir.local_def_id(upvar_id.closure_expr_id),\n             bound_region: ty::BrEnv\n         }));\n "}, {"sha": "3f707ac95f73a516be8baa7d17198cfb4773afc2", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 8, "deletions": 17, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/6d4c2141b5042bd9469005444987f5fb3f20fa73/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d4c2141b5042bd9469005444987f5fb3f20fa73/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=6d4c2141b5042bd9469005444987f5fb3f20fa73", "patch": "@@ -120,23 +120,6 @@ pub enum CodeExtentData {\n     Remainder(BlockRemainder)\n }\n \n-/// extent of call-site for a function/method.\n-#[derive(Clone, PartialEq, PartialOrd, Eq, Ord, Hash, RustcEncodable,\n-           RustcDecodable, Debug, Copy)]\n-pub struct CallSiteScopeData {\n-    pub fn_id: ast::NodeId, pub body_id: ast::NodeId,\n-}\n-\n-impl CallSiteScopeData {\n-    pub fn to_code_extent<'a, 'tcx, 'gcx>(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> CodeExtent<'tcx> {\n-        tcx.intern_code_extent(\n-            match *self {\n-                CallSiteScopeData { fn_id, body_id } =>\n-                    CodeExtentData::CallSiteScope { fn_id: fn_id, body_id: body_id },\n-            })\n-    }\n-}\n-\n /// Represents a subscope of `block` for a binding that is introduced\n /// by `block.stmts[first_statement_index]`. Such subscopes represent\n /// a suffix of the block. Note that each subscope does not include\n@@ -612,6 +595,14 @@ impl<'tcx> RegionMaps<'tcx> {\n             }\n         }\n     }\n+\n+    /// Assuming that the provided region was defined within this `RegionMaps`,\n+    /// returns the outermost `CodeExtent` that the region outlives.\n+    pub fn free_extent<'a, 'gcx>(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>, fr: &ty::FreeRegion)\n+                                 -> CodeExtent<'tcx> {\n+        let scope_id = tcx.hir.as_local_node_id(fr.scope).unwrap();\n+        tcx.call_site_extent(scope_id)\n+    }\n }\n \n /// Records the lifetime of a local variable as `cx.var_parent`"}, {"sha": "55770efa9ad9f8209322b5ecf331f4a7e3fcdc6e", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/6d4c2141b5042bd9469005444987f5fb3f20fa73/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d4c2141b5042bd9469005444987f5fb3f20fa73/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=6d4c2141b5042bd9469005444987f5fb3f20fa73", "patch": "@@ -19,7 +19,6 @@ use hir::map::Map;\n use session::Session;\n use hir::def::Def;\n use hir::def_id::DefId;\n-use middle::region;\n use ty;\n \n use std::cell::Cell;\n@@ -42,7 +41,7 @@ pub enum Region {\n     EarlyBound(/* index */ u32, /* lifetime decl */ ast::NodeId),\n     LateBound(ty::DebruijnIndex, /* lifetime decl */ ast::NodeId),\n     LateBoundAnon(ty::DebruijnIndex, /* anon index */ u32),\n-    Free(region::CallSiteScopeData, /* lifetime decl */ ast::NodeId),\n+    Free(DefId, /* lifetime decl */ ast::NodeId),\n }\n \n impl Region {\n@@ -897,9 +896,6 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         if let Some(mut def) = result {\n             if let Some(body_id) = outermost_body {\n                 let fn_id = self.hir_map.body_owner(body_id);\n-                let scope_data = region::CallSiteScopeData {\n-                    fn_id: fn_id, body_id: body_id.node_id\n-                };\n                 match self.hir_map.get(fn_id) {\n                     hir::map::NodeItem(&hir::Item {\n                         node: hir::ItemFn(..), ..\n@@ -910,7 +906,8 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                     hir::map::NodeImplItem(&hir::ImplItem {\n                         node: hir::ImplItemKind::Method(..), ..\n                     }) => {\n-                        def = Region::Free(scope_data, def.id().unwrap());\n+                        let scope = self.hir_map.local_def_id(fn_id);\n+                        def = Region::Free(scope, def.id().unwrap());\n                     }\n                     _ => {}\n                 }"}, {"sha": "dbc1f070af89e5b97fa47e75dc311c8096f92fff", "filename": "src/librustc/traits/object_safety.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6d4c2141b5042bd9469005444987f5fb3f20fa73/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d4c2141b5042bd9469005444987f5fb3f20fa73/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fobject_safety.rs?ref=6d4c2141b5042bd9469005444987f5fb3f20fa73", "patch": "@@ -206,7 +206,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         };\n \n         // Search for a predicate like `Self : Sized` amongst the trait bounds.\n-        let free_substs = self.construct_free_substs(def_id, None);\n+        let free_substs = self.construct_free_substs(def_id);\n         let predicates = self.predicates_of(def_id);\n         let predicates = predicates.instantiate(self, free_substs).predicates;\n         elaborate_predicates(self, predicates)"}, {"sha": "d69a9b3a8ce4ebf70ec46b5125092297fd5468dc", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6d4c2141b5042bd9469005444987f5fb3f20fa73/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d4c2141b5042bd9469005444987f5fb3f20fa73/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=6d4c2141b5042bd9469005444987f5fb3f20fa73", "patch": "@@ -655,11 +655,6 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         self.intern_code_extent(CodeExtentData::Misc(n))\n     }\n \n-    // Returns the code extent for an item - the destruction scope.\n-    pub fn item_extent(self, n: ast::NodeId) -> CodeExtent<'gcx> {\n-        self.intern_code_extent(CodeExtentData::DestructionScope(n))\n-    }\n-\n     pub fn call_site_extent(self, fn_id: ast::NodeId) -> CodeExtent<'gcx> {\n         self.intern_code_extent(CodeExtentData::CallSiteScope {\n             fn_id,\n@@ -852,15 +847,6 @@ impl<'a, 'tcx> Lift<'tcx> for &'a Substs<'a> {\n     }\n }\n \n-impl<'a, 'tcx> Lift<'tcx> for ty::FreeRegion<'a> {\n-    type Lifted = ty::FreeRegion<'tcx>;\n-    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n-        let scope = self.scope.map(|code_extent| tcx.intern_code_extent(*code_extent));\n-        let bound_region = self.bound_region;\n-        Some(ty::FreeRegion { scope, bound_region })\n-    }\n-}\n-\n impl<'a, 'tcx> Lift<'tcx> for Region<'a> {\n     type Lifted = Region<'tcx>;\n     fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Region<'tcx>> {"}, {"sha": "fc20b1bee4ef5b38567e5b280a8dc9fb4fd609e9", "filename": "src/librustc/ty/fold.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6d4c2141b5042bd9469005444987f5fb3f20fa73/src%2Flibrustc%2Fty%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d4c2141b5042bd9469005444987f5fb3f20fa73/src%2Flibrustc%2Fty%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ffold.rs?ref=6d4c2141b5042bd9469005444987f5fb3f20fa73", "patch": "@@ -39,7 +39,7 @@\n //! These methods return true to indicate that the visitor has found what it is looking for\n //! and does not need to visit anything else.\n \n-use middle::region;\n+use hir::def_id::DefId;\n use ty::subst::Substs;\n use ty::adjustment;\n use ty::{self, Binder, Ty, TyCtxt, TypeFlags};\n@@ -330,7 +330,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     /// Replace any late-bound regions bound in `value` with free variants attached to scope-id\n     /// `scope_id`.\n     pub fn liberate_late_bound_regions<T>(self,\n-        all_outlive_scope: Option<region::CodeExtent<'tcx>>,\n+        all_outlive_scope: DefId,\n         value: &Binder<T>)\n         -> T\n         where T : TypeFoldable<'tcx>"}, {"sha": "4b10ec67def0a97eb3784e9a40f1785b260c9b7a", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 8, "deletions": 41, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/6d4c2141b5042bd9469005444987f5fb3f20fa73/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d4c2141b5042bd9469005444987f5fb3f20fa73/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=6d4c2141b5042bd9469005444987f5fb3f20fa73", "patch": "@@ -23,7 +23,6 @@ use ich::StableHashingContext;\n use middle::const_val::ConstVal;\n use middle::lang_items::{FnTraitLangItem, FnMutTraitLangItem, FnOnceTraitLangItem};\n use middle::privacy::AccessLevels;\n-use middle::region::CodeExtent;\n use middle::resolve_lifetime::ObjectLifetimeDefault;\n use mir::Mir;\n use traits;\n@@ -1244,28 +1243,11 @@ pub struct ParameterEnvironment<'tcx> {\n     /// See `construct_free_substs` for details.\n     pub free_substs: &'tcx Substs<'tcx>,\n \n-    /// Each type parameter has an implicit region bound that\n-    /// indicates it must outlive at least the function body (the user\n-    /// may specify stronger requirements). This field indicates the\n-    /// region of the callee. If it is `None`, then the parameter\n-    /// environment is for an item or something where the \"callee\" is\n-    /// not clear.\n-    pub implicit_region_bound: Option<ty::Region<'tcx>>,\n-\n     /// Obligations that the caller must satisfy. This is basically\n     /// the set of bounds on the in-scope type parameters, translated\n     /// into Obligations, and elaborated and normalized.\n     pub caller_bounds: &'tcx [ty::Predicate<'tcx>],\n \n-    /// Scope that is attached to free regions for this scope. This is\n-    /// usually the id of the fn body, but for more abstract scopes\n-    /// like structs we use None or the item extent.\n-    ///\n-    /// FIXME(#3696). It would be nice to refactor so that free\n-    /// regions don't have this implicit scope and instead introduce\n-    /// relationships in the environment.\n-    pub free_id_outlive: Option<CodeExtent<'tcx>>,\n-\n     /// A cache for `moves_by_default`.\n     pub is_copy_cache: RefCell<FxHashMap<Ty<'tcx>, bool>>,\n \n@@ -1283,9 +1265,7 @@ impl<'a, 'tcx> ParameterEnvironment<'tcx> {\n     {\n         ParameterEnvironment {\n             free_substs: self.free_substs,\n-            implicit_region_bound: self.implicit_region_bound,\n             caller_bounds: caller_bounds,\n-            free_id_outlive: self.free_id_outlive,\n             is_copy_cache: RefCell::new(FxHashMap()),\n             is_sized_cache: RefCell::new(FxHashMap()),\n             is_freeze_cache: RefCell::new(FxHashMap()),\n@@ -2394,8 +2374,6 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         ty::ParameterEnvironment {\n             free_substs: self.intern_substs(&[]),\n             caller_bounds: Slice::empty(),\n-            implicit_region_bound: None,\n-            free_id_outlive: None,\n             is_copy_cache: RefCell::new(FxHashMap()),\n             is_sized_cache: RefCell::new(FxHashMap()),\n             is_freeze_cache: RefCell::new(FxHashMap()),\n@@ -2407,15 +2385,12 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     /// In general, this means converting from bound parameters to\n     /// free parameters. Since we currently represent bound/free type\n     /// parameters in the same way, this only has an effect on regions.\n-    pub fn construct_free_substs(self,\n-                                 def_id: DefId,\n-                                 free_id_outlive: Option<CodeExtent<'gcx>>)\n-                                 -> &'gcx Substs<'gcx> {\n+    pub fn construct_free_substs(self, def_id: DefId) -> &'gcx Substs<'gcx> {\n \n         let substs = Substs::for_item(self.global_tcx(), def_id, |def, _| {\n             // map bound 'a => free 'a\n             self.global_tcx().mk_region(ReFree(FreeRegion {\n-                scope: free_id_outlive,\n+                scope: def_id,\n                 bound_region: def.to_bound_region()\n             }))\n         }, |def, _| {\n@@ -2433,14 +2408,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         // Construct the free substs.\n         //\n \n-        let free_id_outlive = self.hir.as_local_node_id(def_id).map(|id| {\n-            if self.hir.maybe_body_owned_by(id).is_some() {\n-                self.call_site_extent(id)\n-            } else {\n-                self.item_extent(id)\n-            }\n-        });\n-        let free_substs = self.construct_free_substs(def_id, free_id_outlive);\n+        let free_substs = self.construct_free_substs(def_id);\n \n         //\n         // Compute the bounds on Self and the type parameters.\n@@ -2449,7 +2417,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         let tcx = self.global_tcx();\n         let generic_predicates = tcx.predicates_of(def_id);\n         let bounds = generic_predicates.instantiate(tcx, free_substs);\n-        let bounds = tcx.liberate_late_bound_regions(free_id_outlive, &ty::Binder(bounds));\n+        let bounds = tcx.liberate_late_bound_regions(def_id, &ty::Binder(bounds));\n         let predicates = bounds.predicates;\n \n         // Finally, we have to normalize the bounds in the environment, in\n@@ -2466,17 +2434,16 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         //\n \n         let unnormalized_env = ty::ParameterEnvironment {\n-            free_substs: free_substs,\n-            implicit_region_bound: free_id_outlive.map(|f| tcx.mk_region(ty::ReScope(f))),\n+            free_substs,\n             caller_bounds: tcx.intern_predicates(&predicates),\n-            free_id_outlive: free_id_outlive,\n             is_copy_cache: RefCell::new(FxHashMap()),\n             is_sized_cache: RefCell::new(FxHashMap()),\n             is_freeze_cache: RefCell::new(FxHashMap()),\n         };\n \n-        let body_id = free_id_outlive.map(|f| f.node_id())\n-                                     .unwrap_or(DUMMY_NODE_ID);\n+        let body_id = self.hir.as_local_node_id(def_id).map_or(DUMMY_NODE_ID, |id| {\n+            self.hir.maybe_body_owned_by(id).map_or(id, |body| body.node_id)\n+        });\n         let cause = traits::ObligationCause::misc(tcx.def_span(def_id), body_id);\n         traits::normalize_param_env_or_error(tcx, def_id, unnormalized_env, cause)\n     }"}, {"sha": "1b09baccadbe859b81770632f87ffe2eb45b8b3a", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6d4c2141b5042bd9469005444987f5fb3f20fa73/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d4c2141b5042bd9469005444987f5fb3f20fa73/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=6d4c2141b5042bd9469005444987f5fb3f20fa73", "patch": "@@ -43,12 +43,8 @@ pub struct TypeAndMut<'tcx> {\n          RustcEncodable, RustcDecodable, Copy)]\n /// A \"free\" region `fr` can be interpreted as \"some region\n /// at least as big as the scope `fr.scope`\".\n-///\n-/// If `fr.scope` is None, then this is in some context (e.g., an\n-/// impl) where lifetimes are more abstract and the notion of the\n-/// caller/callee stack frames are not applicable.\n-pub struct FreeRegion<'tcx> {\n-    pub scope: Option<region::CodeExtent<'tcx>>,\n+pub struct FreeRegion {\n+    pub scope: DefId,\n     pub bound_region: BoundRegion,\n }\n \n@@ -760,7 +756,7 @@ pub enum RegionKind<'tcx> {\n     /// When checking a function body, the types of all arguments and so forth\n     /// that refer to bound region parameters are modified to refer to free\n     /// region parameters.\n-    ReFree(FreeRegion<'tcx>),\n+    ReFree(FreeRegion),\n \n     /// A concrete region naming some statically determined extent\n     /// (e.g. an expression or sequence of statements) within the"}, {"sha": "307897c4eb4206bae60d316cfd661240398bc540", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6d4c2141b5042bd9469005444987f5fb3f20fa73/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d4c2141b5042bd9469005444987f5fb3f20fa73/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=6d4c2141b5042bd9469005444987f5fb3f20fa73", "patch": "@@ -508,10 +508,8 @@ impl<'tcx> fmt::Debug for ty::ParameterEnvironment<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         write!(f, \"ParameterEnvironment(\\\n             free_substs={:?}, \\\n-            implicit_region_bound={:?}, \\\n             caller_bounds={:?})\",\n             self.free_substs,\n-            self.implicit_region_bound,\n             self.caller_bounds)\n     }\n }\n@@ -544,7 +542,7 @@ impl<'tcx> fmt::Display for ty::RegionKind<'tcx> {\n     }\n }\n \n-impl<'tcx> fmt::Debug for ty::FreeRegion<'tcx> {\n+impl fmt::Debug for ty::FreeRegion {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         write!(f, \"ReFree({:?}, {:?})\",\n                self.scope, self.bound_region)"}, {"sha": "ca0e5dad65b26ecbb6981ddf9a1f3bd26ef364a4", "filename": "src/librustc_borrowck/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6d4c2141b5042bd9469005444987f5fb3f20fa73/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d4c2141b5042bd9469005444987f5fb3f20fa73/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=6d4c2141b5042bd9469005444987f5fb3f20fa73", "patch": "@@ -353,7 +353,9 @@ impl<'a, 'tcx> GatherLoanCtxt<'a, 'tcx> {\n                 let loan_scope = match *loan_region {\n                     ty::ReScope(scope) => scope,\n \n-                    ty::ReFree(ref fr) => fr.scope.unwrap_or(self.item_ub),\n+                    ty::ReFree(ref fr) => {\n+                        self.bccx.region_maps.free_extent(self.tcx(), fr)\n+                    }\n \n                     ty::ReStatic => self.item_ub,\n "}, {"sha": "e8885626151f0e0f3f243bd804b4974900c60d73", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/6d4c2141b5042bd9469005444987f5fb3f20fa73/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d4c2141b5042bd9469005444987f5fb3f20fa73/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=6d4c2141b5042bd9469005444987f5fb3f20fa73", "patch": "@@ -330,15 +330,15 @@ impl<'a, 'gcx, 'tcx> Env<'a, 'gcx, 'tcx> {\n         self.infcx.tcx.mk_imm_ref(self.infcx.tcx.mk_region(r), self.tcx().types.isize)\n     }\n \n-    pub fn re_free(&self, nid: ast::NodeId, id: u32) -> ty::Region<'tcx> {\n+    pub fn re_free(&self, id: u32) -> ty::Region<'tcx> {\n         self.infcx.tcx.mk_region(ty::ReFree(ty::FreeRegion {\n-            scope: Some(self.tcx().node_extent(nid)),\n+            scope: self.infcx.tcx.hir.local_def_id(ast::CRATE_NODE_ID),\n             bound_region: ty::BrAnon(id),\n         }))\n     }\n \n-    pub fn t_rptr_free(&self, nid: u32, id: u32) -> Ty<'tcx> {\n-        let r = self.re_free(ast::NodeId::from_u32(nid), id);\n+    pub fn t_rptr_free(&self, id: u32) -> Ty<'tcx> {\n+        let r = self.re_free(id);\n         self.infcx.tcx.mk_imm_ref(r, self.tcx().types.isize)\n     }\n \n@@ -464,7 +464,7 @@ fn sub_free_bound_false() {\n \n     test_env(EMPTY_SOURCE_STR, errors(&[]), |mut env| {\n         env.create_simple_region_hierarchy();\n-        let t_rptr_free1 = env.t_rptr_free(1, 1);\n+        let t_rptr_free1 = env.t_rptr_free(1);\n         let t_rptr_bound1 = env.t_rptr_late_bound(1);\n         env.check_not_sub(env.t_fn(&[t_rptr_free1], env.tcx().types.isize),\n                           env.t_fn(&[t_rptr_bound1], env.tcx().types.isize));\n@@ -482,7 +482,7 @@ fn sub_bound_free_true() {\n     test_env(EMPTY_SOURCE_STR, errors(&[]), |mut env| {\n         env.create_simple_region_hierarchy();\n         let t_rptr_bound1 = env.t_rptr_late_bound(1);\n-        let t_rptr_free1 = env.t_rptr_free(1, 1);\n+        let t_rptr_free1 = env.t_rptr_free(1);\n         env.check_sub(env.t_fn(&[t_rptr_bound1], env.tcx().types.isize),\n                       env.t_fn(&[t_rptr_free1], env.tcx().types.isize));\n     })\n@@ -518,7 +518,7 @@ fn lub_free_bound_infer() {\n         env.create_simple_region_hierarchy();\n         let t_infer1 = env.infcx.next_ty_var(TypeVariableOrigin::MiscVariable(DUMMY_SP));\n         let t_rptr_bound1 = env.t_rptr_late_bound(1);\n-        let t_rptr_free1 = env.t_rptr_free(1, 1);\n+        let t_rptr_free1 = env.t_rptr_free(1);\n         env.check_lub(env.t_fn(&[t_infer1], env.tcx().types.isize),\n                       env.t_fn(&[t_rptr_bound1], env.tcx().types.isize),\n                       env.t_fn(&[t_rptr_free1], env.tcx().types.isize));\n@@ -541,7 +541,7 @@ fn lub_bound_free() {\n     test_env(EMPTY_SOURCE_STR, errors(&[]), |mut env| {\n         env.create_simple_region_hierarchy();\n         let t_rptr_bound1 = env.t_rptr_late_bound(1);\n-        let t_rptr_free1 = env.t_rptr_free(1, 1);\n+        let t_rptr_free1 = env.t_rptr_free(1);\n         env.check_lub(env.t_fn(&[t_rptr_bound1], env.tcx().types.isize),\n                       env.t_fn(&[t_rptr_free1], env.tcx().types.isize),\n                       env.t_fn(&[t_rptr_free1], env.tcx().types.isize));\n@@ -574,8 +574,8 @@ fn lub_bound_bound_inverse_order() {\n fn lub_free_free() {\n     test_env(EMPTY_SOURCE_STR, errors(&[]), |mut env| {\n         env.create_simple_region_hierarchy();\n-        let t_rptr_free1 = env.t_rptr_free(1, 1);\n-        let t_rptr_free2 = env.t_rptr_free(1, 2);\n+        let t_rptr_free1 = env.t_rptr_free(1);\n+        let t_rptr_free2 = env.t_rptr_free(2);\n         let t_rptr_static = env.t_rptr_static();\n         env.check_lub(env.t_fn(&[t_rptr_free1], env.tcx().types.isize),\n                       env.t_fn(&[t_rptr_free2], env.tcx().types.isize),\n@@ -600,8 +600,8 @@ fn lub_returning_scope() {\n fn glb_free_free_with_common_scope() {\n     test_env(EMPTY_SOURCE_STR, errors(&[]), |mut env| {\n         env.create_simple_region_hierarchy();\n-        let t_rptr_free1 = env.t_rptr_free(1, 1);\n-        let t_rptr_free2 = env.t_rptr_free(1, 2);\n+        let t_rptr_free1 = env.t_rptr_free(1);\n+        let t_rptr_free2 = env.t_rptr_free(2);\n         let t_rptr_scope = env.t_rptr_scope(1);\n         env.check_glb(env.t_fn(&[t_rptr_free1], env.tcx().types.isize),\n                       env.t_fn(&[t_rptr_free2], env.tcx().types.isize),\n@@ -625,7 +625,7 @@ fn glb_bound_free() {\n     test_env(EMPTY_SOURCE_STR, errors(&[]), |mut env| {\n         env.create_simple_region_hierarchy();\n         let t_rptr_bound1 = env.t_rptr_late_bound(1);\n-        let t_rptr_free1 = env.t_rptr_free(1, 1);\n+        let t_rptr_free1 = env.t_rptr_free(1);\n         env.check_glb(env.t_fn(&[t_rptr_bound1], env.tcx().types.isize),\n                       env.t_fn(&[t_rptr_free1], env.tcx().types.isize),\n                       env.t_fn(&[t_rptr_bound1], env.tcx().types.isize));\n@@ -751,7 +751,7 @@ fn escaping() {\n \n         assert!(!env.t_nil().has_escaping_regions());\n \n-        let t_rptr_free1 = env.t_rptr_free(1, 1);\n+        let t_rptr_free1 = env.t_rptr_free(1);\n         assert!(!t_rptr_free1.has_escaping_regions());\n \n         let t_rptr_bound1 = env.t_rptr_late_bound_with_debruijn(1, ty::DebruijnIndex::new(1));"}, {"sha": "a3b1b24f20af9f419da0e4a9e34ac9d0ef7bf923", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6d4c2141b5042bd9469005444987f5fb3f20fa73/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d4c2141b5042bd9469005444987f5fb3f20fa73/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=6d4c2141b5042bd9469005444987f5fb3f20fa73", "patch": "@@ -206,13 +206,14 @@ fn closure_self_ty<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                              -> Ty<'tcx> {\n     let closure_ty = tcx.body_tables(body_id).node_id_to_type(closure_expr_id);\n \n+    let closure_def_id = tcx.hir.local_def_id(closure_expr_id);\n     let region = ty::ReFree(ty::FreeRegion {\n-        scope: Some(tcx.call_site_extent(closure_expr_id)),\n+        scope: closure_def_id,\n         bound_region: ty::BoundRegion::BrEnv,\n     });\n     let region = tcx.mk_region(region);\n \n-    match tcx.closure_kind(tcx.hir.local_def_id(closure_expr_id)) {\n+    match tcx.closure_kind(closure_def_id) {\n         ty::ClosureKind::Fn =>\n             tcx.mk_ref(region,\n                        ty::TypeAndMut { ty: closure_ty,"}, {"sha": "a692e987761babda69681f6addf6ddb79c405185", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 3, "deletions": 17, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/6d4c2141b5042bd9469005444987f5fb3f20fa73/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d4c2141b5042bd9469005444987f5fb3f20fa73/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=6d4c2141b5042bd9469005444987f5fb3f20fa73", "patch": "@@ -14,7 +14,6 @@ use rustc_const_math::ConstInt;\n use hair::cx::Cx;\n use hair::cx::block;\n use hair::cx::to_ref::ToRef;\n-use rustc::hir::map;\n use rustc::hir::def::{Def, CtorKind};\n use rustc::middle::const_val::ConstVal;\n use rustc::ty::{self, AdtKind, VariantDef, Ty};\n@@ -807,33 +806,20 @@ fn convert_var<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                    closure_expr_id);\n             let var_ty = cx.tables().node_id_to_type(id_var);\n \n-            let body_id = match cx.tcx.hir.find(closure_expr_id) {\n-                Some(map::NodeExpr(expr)) => {\n-                    match expr.node {\n-                        hir::ExprClosure(.., body, _) => body.node_id,\n-                        _ => {\n-                            span_bug!(expr.span, \"closure expr is not a closure expr\");\n-                        }\n-                    }\n-                }\n-                _ => {\n-                    span_bug!(expr.span, \"ast-map has garbage for closure expr\");\n-                }\n-            };\n-\n             // FIXME free regions in closures are not right\n             let closure_ty = cx.tables().node_id_to_type(closure_expr_id);\n \n             // FIXME we're just hard-coding the idea that the\n             // signature will be &self or &mut self and hence will\n             // have a bound region with number 0\n+            let closure_def_id = cx.tcx.hir.local_def_id(closure_expr_id);\n             let region = ty::ReFree(ty::FreeRegion {\n-                scope: Some(cx.tcx.node_extent(body_id)),\n+                scope: closure_def_id,\n                 bound_region: ty::BoundRegion::BrAnon(0),\n             });\n             let region = cx.tcx.mk_region(region);\n \n-            let self_expr = match cx.tcx.closure_kind(cx.tcx.hir.local_def_id(closure_expr_id)) {\n+            let self_expr = match cx.tcx.closure_kind(closure_def_id) {\n                 ty::ClosureKind::Fn => {\n                     let ref_closure_ty = cx.tcx.mk_ref(region,\n                                                        ty::TypeAndMut {"}, {"sha": "dfcc68bf390ffba2fda77cc12e19b2cbcdcfd57f", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6d4c2141b5042bd9469005444987f5fb3f20fa73/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d4c2141b5042bd9469005444987f5fb3f20fa73/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=6d4c2141b5042bd9469005444987f5fb3f20fa73", "patch": "@@ -129,7 +129,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n             Some(&rl::Region::Free(scope, id)) => {\n                 let name = tcx.hir.name(id);\n                 tcx.mk_region(ty::ReFree(ty::FreeRegion {\n-                    scope: Some(scope.to_code_extent(tcx)),\n+                    scope,\n                     bound_region: ty::BrNamed(tcx.hir.local_def_id(id), name)\n                 }))\n "}, {"sha": "dc1aa9f8592ee20d13d4c799e199755d7a6c2fdb", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6d4c2141b5042bd9469005444987f5fb3f20fa73/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d4c2141b5042bd9469005444987f5fb3f20fa73/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=6d4c2141b5042bd9469005444987f5fb3f20fa73", "patch": "@@ -73,8 +73,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n         debug!(\"check_closure: expr.id={:?} closure_type={:?}\", expr.id, closure_type);\n \n-        let extent = self.tcx.call_site_extent(expr.id);\n-        let fn_sig = self.tcx.liberate_late_bound_regions(Some(extent), &sig);\n+        let fn_sig = self.tcx.liberate_late_bound_regions(expr_def_id, &sig);\n         let fn_sig = self.inh.normalize_associated_types_in(body.value.span,\n                                                             body.value.id, &fn_sig);\n "}, {"sha": "9248415ad5b460f093b7b7bf7a00eabe1cf0b246", "filename": "src/librustc_typeck/check/compare_method.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6d4c2141b5042bd9469005444987f5fb3f20fa73/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d4c2141b5042bd9469005444987f5fb3f20fa73/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs?ref=6d4c2141b5042bd9469005444987f5fb3f20fa73", "patch": "@@ -226,7 +226,7 @@ fn compare_predicate_entailment<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                                                normalize_cause.clone());\n \n     tcx.infer_ctxt(trait_param_env, Reveal::UserFacing).enter(|infcx| {\n-        let inh = Inherited::new(infcx);\n+        let inh = Inherited::new(infcx, impl_m.def_id);\n         let infcx = &inh.infcx;\n \n         debug!(\"compare_impl_method: caller_bounds={:?}\",\n@@ -283,7 +283,7 @@ fn compare_predicate_entailment<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         debug!(\"compare_impl_method: impl_fty={:?}\", impl_fty);\n \n         let trait_sig = tcx.liberate_late_bound_regions(\n-            infcx.parameter_environment.free_id_outlive,\n+            impl_m.def_id,\n             &m_sig(trait_m));\n         let trait_sig =\n             trait_sig.subst(tcx, trait_to_skol_substs);\n@@ -726,7 +726,7 @@ pub fn compare_const_impl<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     debug!(\"compare_const_impl(impl_trait_ref={:?})\", impl_trait_ref);\n \n     tcx.infer_ctxt((), Reveal::UserFacing).enter(|infcx| {\n-        let inh = Inherited::new(infcx);\n+        let inh = Inherited::new(infcx, impl_c.def_id);\n         let infcx = &inh.infcx;\n \n         // The below is for the most part highly similar to the procedure"}, {"sha": "7861aa09d0f92d77fa178d4982ceeea7e3b5cc90", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 28, "deletions": 6, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/6d4c2141b5042bd9469005444987f5fb3f20fa73/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d4c2141b5042bd9469005444987f5fb3f20fa73/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=6d4c2141b5042bd9469005444987f5fb3f20fa73", "patch": "@@ -176,6 +176,14 @@ pub struct Inherited<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     // variables to get the concrete type, which can be used to\n     // deanonymize TyAnon, after typeck is done with all functions.\n     anon_types: RefCell<NodeMap<Ty<'tcx>>>,\n+\n+    /// Each type parameter has an implicit region bound that\n+    /// indicates it must outlive at least the function body (the user\n+    /// may specify stronger requirements). This field indicates the\n+    /// region of the callee. If it is `None`, then the parameter\n+    /// environment is for an item or something where the \"callee\" is\n+    /// not clear.\n+    implicit_region_bound: Option<ty::Region<'tcx>>,\n }\n \n impl<'a, 'gcx, 'tcx> Deref for Inherited<'a, 'gcx, 'tcx> {\n@@ -522,7 +530,8 @@ impl<'a, 'gcx, 'tcx> Deref for FnCtxt<'a, 'gcx, 'tcx> {\n /// Necessary because we can't write the following bound:\n /// F: for<'b, 'tcx> where 'gcx: 'tcx FnOnce(Inherited<'b, 'gcx, 'tcx>).\n pub struct InheritedBuilder<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n-    infcx: infer::InferCtxtBuilder<'a, 'gcx, 'tcx>\n+    infcx: infer::InferCtxtBuilder<'a, 'gcx, 'tcx>,\n+    def_id: DefId,\n }\n \n impl<'a, 'gcx, 'tcx> Inherited<'a, 'gcx, 'tcx> {\n@@ -531,7 +540,8 @@ impl<'a, 'gcx, 'tcx> Inherited<'a, 'gcx, 'tcx> {\n         let tables = ty::TypeckTables::empty();\n         let param_env = tcx.parameter_environment(def_id);\n         InheritedBuilder {\n-            infcx: tcx.infer_ctxt((tables, param_env), Reveal::UserFacing)\n+            infcx: tcx.infer_ctxt((tables, param_env), Reveal::UserFacing),\n+            def_id,\n         }\n     }\n }\n@@ -540,19 +550,32 @@ impl<'a, 'gcx, 'tcx> InheritedBuilder<'a, 'gcx, 'tcx> {\n     fn enter<F, R>(&'tcx mut self, f: F) -> R\n         where F: for<'b> FnOnce(Inherited<'b, 'gcx, 'tcx>) -> R\n     {\n-        self.infcx.enter(|infcx| f(Inherited::new(infcx)))\n+        let def_id = self.def_id;\n+        self.infcx.enter(|infcx| f(Inherited::new(infcx, def_id)))\n     }\n }\n \n impl<'a, 'gcx, 'tcx> Inherited<'a, 'gcx, 'tcx> {\n-    fn new(infcx: InferCtxt<'a, 'gcx, 'tcx>) -> Self {\n+    fn new(infcx: InferCtxt<'a, 'gcx, 'tcx>, def_id: DefId) -> Self {\n+        let tcx = infcx.tcx;\n+        let item_id = tcx.hir.as_local_node_id(def_id);\n+        let body_id = item_id.and_then(|id| tcx.hir.maybe_body_owned_by(id));\n+        let implicit_region_bound = item_id.and_then(|id| {\n+            if body_id.is_some() {\n+                Some(tcx.mk_region(ty::ReScope(tcx.call_site_extent(id))))\n+            } else {\n+                None\n+            }\n+        });\n+\n         Inherited {\n             infcx: infcx,\n             fulfillment_cx: RefCell::new(traits::FulfillmentContext::new()),\n             locals: RefCell::new(NodeMap()),\n             deferred_call_resolutions: RefCell::new(DefIdMap()),\n             deferred_cast_checks: RefCell::new(Vec::new()),\n             anon_types: RefCell::new(NodeMap()),\n+            implicit_region_bound,\n         }\n     }\n \n@@ -778,11 +801,10 @@ fn typeck_tables_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             check_abi(tcx, span, fn_sig.abi());\n \n             // Compute the fty from point of view of inside fn.\n-            let fn_scope = inh.tcx.call_site_extent(id);\n             let fn_sig =\n                 fn_sig.subst(inh.tcx, &inh.parameter_environment.free_substs);\n             let fn_sig =\n-                inh.tcx.liberate_late_bound_regions(Some(fn_scope), &fn_sig);\n+                inh.tcx.liberate_late_bound_regions(def_id, &fn_sig);\n             let fn_sig =\n                 inh.normalize_associated_types_in(body.value.span, body_id.node_id, &fn_sig);\n "}, {"sha": "bdaf3db8780257005db68708ee02f3ac030cbe3f", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6d4c2141b5042bd9469005444987f5fb3f20fa73/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d4c2141b5042bd9469005444987f5fb3f20fa73/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=6d4c2141b5042bd9469005444987f5fb3f20fa73", "patch": "@@ -1612,16 +1612,14 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     fn param_bound(&self, param_ty: ty::ParamTy) -> VerifyBound<'tcx> {\n-        let param_env = &self.parameter_environment;\n-\n         debug!(\"param_bound(param_ty={:?})\",\n                param_ty);\n \n         let mut param_bounds = self.declared_generic_bounds_from_env(GenericKind::Param(param_ty));\n \n         // Add in the default bound of fn body that applies to all in\n         // scope type parameters:\n-        param_bounds.extend(param_env.implicit_region_bound);\n+        param_bounds.extend(self.implicit_region_bound);\n \n         VerifyBound::AnyRegion(param_bounds)\n     }"}, {"sha": "225d0ce07658551d5689461b21b293e09f4db7cb", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 7, "deletions": 12, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/6d4c2141b5042bd9469005444987f5fb3f20fa73/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d4c2141b5042bd9469005444987f5fb3f20fa73/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=6d4c2141b5042bd9469005444987f5fb3f20fa73", "patch": "@@ -13,7 +13,6 @@ use check::{Inherited, FnCtxt};\n use constrained_type_params::{identify_constrained_type_params, Parameter};\n \n use hir::def_id::DefId;\n-use middle::region::{CodeExtent};\n use rustc::traits::{self, ObligationCauseCode};\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::util::nodemap::{FxHashSet, FxHashMap};\n@@ -161,7 +160,6 @@ impl<'a, 'gcx> CheckTypeWellFormedVisitor<'a, 'gcx> {\n         let code = self.code.clone();\n         self.for_id(item_id, span).with_fcx(|fcx, this| {\n             let free_substs = &fcx.parameter_environment.free_substs;\n-            let free_id_outlive = fcx.parameter_environment.free_id_outlive;\n \n             let item = fcx.tcx.associated_item(fcx.tcx.hir.local_def_id(item_id));\n \n@@ -184,10 +182,9 @@ impl<'a, 'gcx> CheckTypeWellFormedVisitor<'a, 'gcx> {\n                     let predicates = fcx.instantiate_bounds(span, item.def_id, free_substs);\n                     let sig = method_ty.fn_sig();\n                     this.check_fn_or_method(fcx, span, sig, &predicates,\n-                                            free_id_outlive, &mut implied_bounds);\n+                                            item.def_id, &mut implied_bounds);\n                     let sig_if_method = sig_if_method.expect(\"bad signature for method\");\n-                    this.check_method_receiver(fcx, sig_if_method, &item,\n-                                               free_id_outlive, self_ty);\n+                    this.check_method_receiver(fcx, sig_if_method, &item, self_ty);\n                 }\n                 ty::AssociatedKind::Type => {\n                     if item.defaultness.has_value() {\n@@ -338,9 +335,8 @@ impl<'a, 'gcx> CheckTypeWellFormedVisitor<'a, 'gcx> {\n             let predicates = fcx.instantiate_bounds(item.span, def_id, free_substs);\n \n             let mut implied_bounds = vec![];\n-            let free_id_outlive = fcx.tcx.call_site_extent(item.id);\n             this.check_fn_or_method(fcx, item.span, sig, &predicates,\n-                                    Some(free_id_outlive), &mut implied_bounds);\n+                                    def_id, &mut implied_bounds);\n             implied_bounds\n         })\n     }\n@@ -426,12 +422,12 @@ impl<'a, 'gcx> CheckTypeWellFormedVisitor<'a, 'gcx> {\n                                       span: Span,\n                                       sig: ty::PolyFnSig<'tcx>,\n                                       predicates: &ty::InstantiatedPredicates<'tcx>,\n-                                      free_id_outlive: Option<CodeExtent<'tcx>>,\n+                                      def_id: DefId,\n                                       implied_bounds: &mut Vec<Ty<'tcx>>)\n     {\n         let free_substs = &fcx.parameter_environment.free_substs;\n         let sig = fcx.instantiate_type_scheme(span, free_substs, &sig);\n-        let sig = fcx.tcx.liberate_late_bound_regions(free_id_outlive, &sig);\n+        let sig = fcx.tcx.liberate_late_bound_regions(def_id, &sig);\n \n         for input_ty in sig.inputs() {\n             fcx.register_wf_obligation(&input_ty, span, self.code.clone());\n@@ -450,7 +446,6 @@ impl<'a, 'gcx> CheckTypeWellFormedVisitor<'a, 'gcx> {\n                                          fcx: &FnCtxt<'fcx, 'gcx, 'tcx>,\n                                          method_sig: &hir::MethodSig,\n                                          method: &ty::AssociatedItem,\n-                                         free_id_outlive: Option<CodeExtent<'tcx>>,\n                                          self_ty: ty::Ty<'tcx>)\n     {\n         // check that the type of the method's receiver matches the\n@@ -467,7 +462,7 @@ impl<'a, 'gcx> CheckTypeWellFormedVisitor<'a, 'gcx> {\n         let free_substs = &fcx.parameter_environment.free_substs;\n         let method_ty = fcx.tcx.type_of(method.def_id);\n         let fty = fcx.instantiate_type_scheme(span, free_substs, &method_ty);\n-        let sig = fcx.tcx.liberate_late_bound_regions(free_id_outlive, &fty.fn_sig());\n+        let sig = fcx.tcx.liberate_late_bound_regions(method.def_id, &fty.fn_sig());\n \n         debug!(\"check_method_receiver: sig={:?}\", sig);\n \n@@ -483,7 +478,7 @@ impl<'a, 'gcx> CheckTypeWellFormedVisitor<'a, 'gcx> {\n             ExplicitSelf::ByBox => fcx.tcx.mk_box(self_ty)\n         };\n         let rcvr_ty = fcx.instantiate_type_scheme(span, free_substs, &rcvr_ty);\n-        let rcvr_ty = fcx.tcx.liberate_late_bound_regions(free_id_outlive,\n+        let rcvr_ty = fcx.tcx.liberate_late_bound_regions(method.def_id,\n                                                           &ty::Binder(rcvr_ty));\n \n         debug!(\"check_method_receiver: receiver ty = {:?}\", rcvr_ty);"}, {"sha": "28ce79ab5aae341995e84833b68d6ff5d2a947e1", "filename": "src/test/compile-fail/issue-37884.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6d4c2141b5042bd9469005444987f5fb3f20fa73/src%2Ftest%2Fcompile-fail%2Fissue-37884.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d4c2141b5042bd9469005444987f5fb3f20fa73/src%2Ftest%2Fcompile-fail%2Fissue-37884.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-37884.rs?ref=6d4c2141b5042bd9469005444987f5fb3f20fa73", "patch": "@@ -16,9 +16,9 @@ impl<'a, T: 'a> Iterator for RepeatMut<'a, T> {\n     //~^ ERROR method not compatible with trait\n     //~| lifetime mismatch\n     //~| NOTE expected type `fn(&mut RepeatMut<'a, T>) -> std::option::Option<&mut T>`\n+    //~| NOTE the anonymous lifetime #1 defined on the method body\n+    //~| NOTE ...does not necessarily outlive the lifetime 'a as defined on the method body\n     {\n-    //~^ NOTE the anonymous lifetime #1 defined on the body\n-    //~| NOTE ...does not necessarily outlive the lifetime 'a as defined on the body\n         Some(&mut self.0)\n     }\n }"}, {"sha": "55723ee8cd96416c7bcc572eff46b387c77519a4", "filename": "src/test/ui/lifetime-errors/ex1-return-one-existing-name-if-else.stderr", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6d4c2141b5042bd9469005444987f5fb3f20fa73/src%2Ftest%2Fui%2Flifetime-errors%2Fex1-return-one-existing-name-if-else.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6d4c2141b5042bd9469005444987f5fb3f20fa73/src%2Ftest%2Fui%2Flifetime-errors%2Fex1-return-one-existing-name-if-else.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetime-errors%2Fex1-return-one-existing-name-if-else.stderr?ref=6d4c2141b5042bd9469005444987f5fb3f20fa73", "patch": "@@ -4,19 +4,17 @@ error[E0312]: lifetime of reference outlives lifetime of borrowed content...\n 12 |     if x > y { x } else { y }\n    |                           ^\n    |\n-note: ...the reference is valid for the lifetime 'a as defined on the body at 11:43...\n-  --> $DIR/ex1-return-one-existing-name-if-else.rs:11:44\n+note: ...the reference is valid for the lifetime 'a as defined on the function body at 11:0...\n+  --> $DIR/ex1-return-one-existing-name-if-else.rs:11:1\n    |\n-11 |   fn foo<'a>(x: &'a i32, y: &i32) -> &'a i32 {\n-   |  ____________________________________________^\n+11 | / fn foo<'a>(x: &'a i32, y: &i32) -> &'a i32 {\n 12 | |     if x > y { x } else { y }\n 13 | | }\n    | |_^\n-note: ...but the borrowed content is only valid for the anonymous lifetime #1 defined on the body at 11:43\n-  --> $DIR/ex1-return-one-existing-name-if-else.rs:11:44\n+note: ...but the borrowed content is only valid for the anonymous lifetime #1 defined on the function body at 11:0\n+  --> $DIR/ex1-return-one-existing-name-if-else.rs:11:1\n    |\n-11 |   fn foo<'a>(x: &'a i32, y: &i32) -> &'a i32 {\n-   |  ____________________________________________^\n+11 | / fn foo<'a>(x: &'a i32, y: &i32) -> &'a i32 {\n 12 | |     if x > y { x } else { y }\n 13 | | }\n    | |_^"}, {"sha": "b7d985feca9f27dfd29ebd6556b4d2184677976d", "filename": "src/test/ui/lifetime-errors/ex2a-push-one-existing-name.stderr", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6d4c2141b5042bd9469005444987f5fb3f20fa73/src%2Ftest%2Fui%2Flifetime-errors%2Fex2a-push-one-existing-name.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6d4c2141b5042bd9469005444987f5fb3f20fa73/src%2Ftest%2Fui%2Flifetime-errors%2Fex2a-push-one-existing-name.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetime-errors%2Fex2a-push-one-existing-name.stderr?ref=6d4c2141b5042bd9469005444987f5fb3f20fa73", "patch": "@@ -6,19 +6,17 @@ error[E0308]: mismatched types\n    |\n    = note: expected type `Ref<'a, _>`\n               found type `Ref<'_, _>`\n-note: the anonymous lifetime #2 defined on the body at 15:51...\n-  --> $DIR/ex2a-push-one-existing-name.rs:15:52\n+note: the anonymous lifetime #2 defined on the function body at 15:0...\n+  --> $DIR/ex2a-push-one-existing-name.rs:15:1\n    |\n-15 |   fn foo<'a>(x: &mut Vec<Ref<'a, i32>>, y: Ref<i32>) {\n-   |  ____________________________________________________^\n+15 | / fn foo<'a>(x: &mut Vec<Ref<'a, i32>>, y: Ref<i32>) {\n 16 | |     x.push(y);\n 17 | | }\n    | |_^\n-note: ...does not necessarily outlive the lifetime 'a as defined on the body at 15:51\n-  --> $DIR/ex2a-push-one-existing-name.rs:15:52\n+note: ...does not necessarily outlive the lifetime 'a as defined on the function body at 15:0\n+  --> $DIR/ex2a-push-one-existing-name.rs:15:1\n    |\n-15 |   fn foo<'a>(x: &mut Vec<Ref<'a, i32>>, y: Ref<i32>) {\n-   |  ____________________________________________________^\n+15 | / fn foo<'a>(x: &mut Vec<Ref<'a, i32>>, y: Ref<i32>) {\n 16 | |     x.push(y);\n 17 | | }\n    | |_^"}, {"sha": "3a6e94f2b1c2e2da70127c5a631a22516b19a026", "filename": "src/test/ui/lifetime-errors/ex2b-push-no-existing-names.stderr", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6d4c2141b5042bd9469005444987f5fb3f20fa73/src%2Ftest%2Fui%2Flifetime-errors%2Fex2b-push-no-existing-names.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6d4c2141b5042bd9469005444987f5fb3f20fa73/src%2Ftest%2Fui%2Flifetime-errors%2Fex2b-push-no-existing-names.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetime-errors%2Fex2b-push-no-existing-names.stderr?ref=6d4c2141b5042bd9469005444987f5fb3f20fa73", "patch": "@@ -6,19 +6,17 @@ error[E0308]: mismatched types\n    |\n    = note: expected type `Ref<'_, _>`\n               found type `Ref<'_, _>`\n-note: the anonymous lifetime #3 defined on the body at 15:43...\n-  --> $DIR/ex2b-push-no-existing-names.rs:15:44\n+note: the anonymous lifetime #3 defined on the function body at 15:0...\n+  --> $DIR/ex2b-push-no-existing-names.rs:15:1\n    |\n-15 |   fn foo(x: &mut Vec<Ref<i32>>, y: Ref<i32>) {\n-   |  ____________________________________________^\n+15 | / fn foo(x: &mut Vec<Ref<i32>>, y: Ref<i32>) {\n 16 | |     x.push(y);\n 17 | | }\n    | |_^\n-note: ...does not necessarily outlive the anonymous lifetime #2 defined on the body at 15:43\n-  --> $DIR/ex2b-push-no-existing-names.rs:15:44\n+note: ...does not necessarily outlive the anonymous lifetime #2 defined on the function body at 15:0\n+  --> $DIR/ex2b-push-no-existing-names.rs:15:1\n    |\n-15 |   fn foo(x: &mut Vec<Ref<i32>>, y: Ref<i32>) {\n-   |  ____________________________________________^\n+15 | / fn foo(x: &mut Vec<Ref<i32>>, y: Ref<i32>) {\n 16 | |     x.push(y);\n 17 | | }\n    | |_^"}, {"sha": "3d7064a4f71a3b45423590caebeabea3619316ae", "filename": "src/test/ui/lifetime-errors/ex2c-push-inference-variable.stderr", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6d4c2141b5042bd9469005444987f5fb3f20fa73/src%2Ftest%2Fui%2Flifetime-errors%2Fex2c-push-inference-variable.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6d4c2141b5042bd9469005444987f5fb3f20fa73/src%2Ftest%2Fui%2Flifetime-errors%2Fex2c-push-inference-variable.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetime-errors%2Fex2c-push-inference-variable.stderr?ref=6d4c2141b5042bd9469005444987f5fb3f20fa73", "patch": "@@ -4,11 +4,10 @@ error[E0495]: cannot infer an appropriate lifetime for lifetime parameter `'a` d\n 16 |     let z = Ref { data: y.data };\n    |             ^^^\n    |\n-note: first, the lifetime cannot outlive the lifetime 'c as defined on the body at 15:66...\n-  --> $DIR/ex2c-push-inference-variable.rs:15:67\n+note: first, the lifetime cannot outlive the lifetime 'c as defined on the function body at 15:0...\n+  --> $DIR/ex2c-push-inference-variable.rs:15:1\n    |\n-15 |   fn foo<'a, 'b, 'c>(x: &'a mut Vec<Ref<'b, i32>>, y: Ref<'c, i32>) {\n-   |  ___________________________________________________________________^\n+15 | / fn foo<'a, 'b, 'c>(x: &'a mut Vec<Ref<'b, i32>>, y: Ref<'c, i32>) {\n 16 | |     let z = Ref { data: y.data };\n 17 | |     x.push(z);\n 18 | | }\n@@ -18,11 +17,10 @@ note: ...so that reference does not outlive borrowed content\n    |\n 16 |     let z = Ref { data: y.data };\n    |                         ^^^^^^\n-note: but, the lifetime must be valid for the lifetime 'b as defined on the body at 15:66...\n-  --> $DIR/ex2c-push-inference-variable.rs:15:67\n+note: but, the lifetime must be valid for the lifetime 'b as defined on the function body at 15:0...\n+  --> $DIR/ex2c-push-inference-variable.rs:15:1\n    |\n-15 |   fn foo<'a, 'b, 'c>(x: &'a mut Vec<Ref<'b, i32>>, y: Ref<'c, i32>) {\n-   |  ___________________________________________________________________^\n+15 | / fn foo<'a, 'b, 'c>(x: &'a mut Vec<Ref<'b, i32>>, y: Ref<'c, i32>) {\n 16 | |     let z = Ref { data: y.data };\n 17 | |     x.push(z);\n 18 | | }"}, {"sha": "aced855bf669bdca7e839fe0bdebb45f939827cb", "filename": "src/test/ui/lifetime-errors/ex2d-push-inference-variable-2.stderr", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6d4c2141b5042bd9469005444987f5fb3f20fa73/src%2Ftest%2Fui%2Flifetime-errors%2Fex2d-push-inference-variable-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6d4c2141b5042bd9469005444987f5fb3f20fa73/src%2Ftest%2Fui%2Flifetime-errors%2Fex2d-push-inference-variable-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetime-errors%2Fex2d-push-inference-variable-2.stderr?ref=6d4c2141b5042bd9469005444987f5fb3f20fa73", "patch": "@@ -4,11 +4,10 @@ error[E0495]: cannot infer an appropriate lifetime for lifetime parameter `'a` d\n 17 |     let b = Ref { data: y.data };\n    |             ^^^\n    |\n-note: first, the lifetime cannot outlive the lifetime 'c as defined on the body at 15:66...\n-  --> $DIR/ex2d-push-inference-variable-2.rs:15:67\n+note: first, the lifetime cannot outlive the lifetime 'c as defined on the function body at 15:0...\n+  --> $DIR/ex2d-push-inference-variable-2.rs:15:1\n    |\n-15 |   fn foo<'a, 'b, 'c>(x: &'a mut Vec<Ref<'b, i32>>, y: Ref<'c, i32>) {\n-   |  ___________________________________________________________________^\n+15 | / fn foo<'a, 'b, 'c>(x: &'a mut Vec<Ref<'b, i32>>, y: Ref<'c, i32>) {\n 16 | |     let a: &mut Vec<Ref<i32>> = x;\n 17 | |     let b = Ref { data: y.data };\n 18 | |     a.push(b);\n@@ -19,11 +18,10 @@ note: ...so that reference does not outlive borrowed content\n    |\n 17 |     let b = Ref { data: y.data };\n    |                         ^^^^^^\n-note: but, the lifetime must be valid for the lifetime 'b as defined on the body at 15:66...\n-  --> $DIR/ex2d-push-inference-variable-2.rs:15:67\n+note: but, the lifetime must be valid for the lifetime 'b as defined on the function body at 15:0...\n+  --> $DIR/ex2d-push-inference-variable-2.rs:15:1\n    |\n-15 |   fn foo<'a, 'b, 'c>(x: &'a mut Vec<Ref<'b, i32>>, y: Ref<'c, i32>) {\n-   |  ___________________________________________________________________^\n+15 | / fn foo<'a, 'b, 'c>(x: &'a mut Vec<Ref<'b, i32>>, y: Ref<'c, i32>) {\n 16 | |     let a: &mut Vec<Ref<i32>> = x;\n 17 | |     let b = Ref { data: y.data };\n 18 | |     a.push(b);"}, {"sha": "07e2316b63d8c61a8a1ed90b9cf59cbcd9cbe345", "filename": "src/test/ui/lifetime-errors/ex2e-push-inference-variable-3.stderr", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6d4c2141b5042bd9469005444987f5fb3f20fa73/src%2Ftest%2Fui%2Flifetime-errors%2Fex2e-push-inference-variable-3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6d4c2141b5042bd9469005444987f5fb3f20fa73/src%2Ftest%2Fui%2Flifetime-errors%2Fex2e-push-inference-variable-3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetime-errors%2Fex2e-push-inference-variable-3.stderr?ref=6d4c2141b5042bd9469005444987f5fb3f20fa73", "patch": "@@ -4,11 +4,10 @@ error[E0495]: cannot infer an appropriate lifetime for lifetime parameter `'a` d\n 17 |     let b = Ref { data: y.data };\n    |             ^^^\n    |\n-note: first, the lifetime cannot outlive the lifetime 'c as defined on the body at 15:66...\n-  --> $DIR/ex2e-push-inference-variable-3.rs:15:67\n+note: first, the lifetime cannot outlive the lifetime 'c as defined on the function body at 15:0...\n+  --> $DIR/ex2e-push-inference-variable-3.rs:15:1\n    |\n-15 |   fn foo<'a, 'b, 'c>(x: &'a mut Vec<Ref<'b, i32>>, y: Ref<'c, i32>) {\n-   |  ___________________________________________________________________^\n+15 | / fn foo<'a, 'b, 'c>(x: &'a mut Vec<Ref<'b, i32>>, y: Ref<'c, i32>) {\n 16 | |     let a: &mut Vec<Ref<i32>> = x;\n 17 | |     let b = Ref { data: y.data };\n 18 | |     Vec::push(a, b);\n@@ -19,11 +18,10 @@ note: ...so that reference does not outlive borrowed content\n    |\n 17 |     let b = Ref { data: y.data };\n    |                         ^^^^^^\n-note: but, the lifetime must be valid for the lifetime 'b as defined on the body at 15:66...\n-  --> $DIR/ex2e-push-inference-variable-3.rs:15:67\n+note: but, the lifetime must be valid for the lifetime 'b as defined on the function body at 15:0...\n+  --> $DIR/ex2e-push-inference-variable-3.rs:15:1\n    |\n-15 |   fn foo<'a, 'b, 'c>(x: &'a mut Vec<Ref<'b, i32>>, y: Ref<'c, i32>) {\n-   |  ___________________________________________________________________^\n+15 | / fn foo<'a, 'b, 'c>(x: &'a mut Vec<Ref<'b, i32>>, y: Ref<'c, i32>) {\n 16 | |     let a: &mut Vec<Ref<i32>> = x;\n 17 | |     let b = Ref { data: y.data };\n 18 | |     Vec::push(a, b);"}]}