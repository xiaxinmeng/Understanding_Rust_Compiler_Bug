{"sha": "5ca83553bc499e677a49b97075938abb5c70b4fd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVjYTgzNTUzYmM0OTllNjc3YTQ5Yjk3MDc1OTM4YWJiNWM3MGI0ZmQ=", "commit": {"author": {"name": "Haitao Li", "email": "lihaitao@gmail.com", "date": "2011-11-20T18:15:40Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-11-21T12:49:52Z"}, "message": "rustc: Remove abi from ast::native_mod", "tree": {"sha": "014110df635577ae09e5df641e869f8b61daf43d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/014110df635577ae09e5df641e869f8b61daf43d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5ca83553bc499e677a49b97075938abb5c70b4fd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5ca83553bc499e677a49b97075938abb5c70b4fd", "html_url": "https://github.com/rust-lang/rust/commit/5ca83553bc499e677a49b97075938abb5c70b4fd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5ca83553bc499e677a49b97075938abb5c70b4fd/comments", "author": {"login": "lht", "id": 19508, "node_id": "MDQ6VXNlcjE5NTA4", "avatar_url": "https://avatars.githubusercontent.com/u/19508?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lht", "html_url": "https://github.com/lht", "followers_url": "https://api.github.com/users/lht/followers", "following_url": "https://api.github.com/users/lht/following{/other_user}", "gists_url": "https://api.github.com/users/lht/gists{/gist_id}", "starred_url": "https://api.github.com/users/lht/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lht/subscriptions", "organizations_url": "https://api.github.com/users/lht/orgs", "repos_url": "https://api.github.com/users/lht/repos", "events_url": "https://api.github.com/users/lht/events{/privacy}", "received_events_url": "https://api.github.com/users/lht/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7a7f0604f4aff935f2b2ad4ad9c66f77c581dc93", "url": "https://api.github.com/repos/rust-lang/rust/commits/7a7f0604f4aff935f2b2ad4ad9c66f77c581dc93", "html_url": "https://github.com/rust-lang/rust/commit/7a7f0604f4aff935f2b2ad4ad9c66f77c581dc93"}], "stats": {"total": 254, "additions": 126, "deletions": 128}, "files": [{"sha": "86864dc450e283fef3c6903adfb7bc8507484f1b", "filename": "src/comp/front/attr.rs", "status": "modified", "additions": 22, "deletions": 1, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/5ca83553bc499e677a49b97075938abb5c70b4fd/src%2Fcomp%2Ffront%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ca83553bc499e677a49b97075938abb5c70b4fd/src%2Fcomp%2Ffront%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fattr.rs?ref=5ca83553bc499e677a49b97075938abb5c70b4fd", "patch": "@@ -1,6 +1,6 @@\n // Functions dealing with attributes and meta_items\n \n-import std::{vec, map, option};\n+import std::{either, vec, map, option};\n import syntax::{ast, ast_util};\n import driver::session;\n \n@@ -24,6 +24,7 @@ export mk_name_value_item;\n export mk_list_item;\n export mk_word_item;\n export mk_attr;\n+export native_abi;\n \n // From a list of crate attributes get only the meta_items that impact crate\n // linkage\n@@ -199,6 +200,26 @@ fn require_unique_names(sess: session::session, metas: [@ast::meta_item]) {\n     }\n }\n \n+fn native_abi(attrs: [ast::attribute]) -> either::t<str, ast::native_abi> {\n+    ret alt attr::get_meta_item_value_str_by_name(attrs, \"abi\") {\n+      option::none. {\n+        either::right(ast::native_abi_cdecl)\n+      }\n+      option::some(\"rust-intrinsic\") {\n+        either::right(ast::native_abi_rust_intrinsic)\n+      }\n+      option::some(\"cdecl\") {\n+        either::right(ast::native_abi_cdecl)\n+      }\n+      option::some(\"stdcall\") {\n+        either::right(ast::native_abi_stdcall)\n+      }\n+      option::some(t) {\n+        either::left(\"unsupported abi: \" + t)\n+      }\n+    };\n+}\n+\n fn span<copy T>(item: T) -> ast::spanned<T> {\n     ret {node: item, span: ast_util::dummy_sp()};\n }"}, {"sha": "c227ca2c50f430d7426212268077e7c1d410388d", "filename": "src/comp/front/config.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5ca83553bc499e677a49b97075938abb5c70b4fd/src%2Fcomp%2Ffront%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ca83553bc499e677a49b97075938abb5c70b4fd/src%2Fcomp%2Ffront%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fconfig.rs?ref=5ca83553bc499e677a49b97075938abb5c70b4fd", "patch": "@@ -45,8 +45,7 @@ fn fold_native_mod(cfg: ast::crate_cfg, nm: ast::native_mod,\n                    fld: fold::ast_fold) -> ast::native_mod {\n     let filter = bind filter_native_item(cfg, _);\n     let filtered_items = vec::filter_map(filter, nm.items);\n-    ret {abi: nm.abi,\n-         view_items: vec::map(fld.fold_view_item, nm.view_items),\n+    ret {view_items: vec::map(fld.fold_view_item, nm.view_items),\n          items: filtered_items};\n }\n "}, {"sha": "cb1273ec4898f8d2a8cc1e8091f8bb0278e943a1", "filename": "src/comp/metadata/creader.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/5ca83553bc499e677a49b97075938abb5c70b4fd/src%2Fcomp%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ca83553bc499e677a49b97075938abb5c70b4fd/src%2Fcomp%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fcreader.rs?ref=5ca83553bc499e677a49b97075938abb5c70b4fd", "patch": "@@ -7,7 +7,7 @@ import front::attr;\n import syntax::visit;\n import syntax::codemap::span;\n import util::{filesearch};\n-import std::{vec, str, fs, io, option};\n+import std::{either, vec, str, fs, io, option};\n import std::option::{none, some};\n import std::map::{hashmap, new_int_hash};\n import syntax::print::pprust;\n@@ -49,9 +49,12 @@ fn visit_view_item(e: env, i: @ast::view_item) {\n fn visit_item(e: env, i: @ast::item) {\n     alt i.node {\n       ast::item_native_mod(m) {\n-        if m.abi != ast::native_abi_cdecl &&\n-                m.abi != ast::native_abi_stdcall {\n-            ret;\n+        alt attr::native_abi(i.attrs) {\n+          either::right(abi) {\n+            if abi != ast::native_abi_cdecl &&\n+               abi != ast::native_abi_stdcall { ret; }\n+          }\n+          either::left(msg) { e.sess.span_fatal(i.span, msg); }\n         }\n         let cstore = e.sess.get_cstore();\n         let native_name = i.ident;"}, {"sha": "3a09f6db883ff2b4e301284668ec9fdc5211836a", "filename": "src/comp/metadata/tydecode.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5ca83553bc499e677a49b97075938abb5c70b4fd/src%2Fcomp%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ca83553bc499e677a49b97075938abb5c70b4fd/src%2Fcomp%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Ftydecode.rs?ref=5ca83553bc499e677a49b97075938abb5c70b4fd", "patch": "@@ -257,14 +257,8 @@ fn parse_ty(st: @pstate, sd: str_def) -> ty::t {\n                       func.cs);\n       }\n       'N' {\n-        let abi;\n-        alt next(st) as char {\n-          'i' { abi = ast::native_abi_rust_intrinsic; }\n-          'C' { abi = ast::native_abi_cdecl; }\n-          'S' { abi = ast::native_abi_stdcall; }\n-        }\n         let func = parse_ty_fn(st, sd);\n-        ret ty::mk_native_fn(st.tcx, abi, func.args, func.ty);\n+        ret ty::mk_native_fn(st.tcx, func.args, func.ty);\n       }\n       'O' {\n         assert (next(st) as char == '[');"}, {"sha": "029127445d0fd56f6d2f54dd605079bf68088b61", "filename": "src/comp/metadata/tyencode.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5ca83553bc499e677a49b97075938abb5c70b4fd/src%2Fcomp%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ca83553bc499e677a49b97075938abb5c70b4fd/src%2Fcomp%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Ftyencode.rs?ref=5ca83553bc499e677a49b97075938abb5c70b4fd", "patch": "@@ -138,13 +138,8 @@ fn enc_sty(w: io::writer, cx: @ctxt, st: ty::sty) {\n         enc_proto(w, proto);\n         enc_ty_fn(w, cx, args, out, cf, constrs);\n       }\n-      ty::ty_native_fn(abi, args, out) {\n+      ty::ty_native_fn(args, out) {\n         w.write_char('N');\n-        alt abi {\n-          native_abi_rust_intrinsic. { w.write_char('i'); }\n-          native_abi_cdecl. { w.write_char('C'); }\n-          native_abi_stdcall. { w.write_char('S'); }\n-        }\n         enc_ty_fn(w, cx, args, out, return_val, []);\n       }\n       ty::ty_obj(methods) {"}, {"sha": "7e05e9186c3e7f2171e71b1454de3cc014ced713", "filename": "src/comp/middle/alias.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5ca83553bc499e677a49b97075938abb5c70b4fd/src%2Fcomp%2Fmiddle%2Falias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ca83553bc499e677a49b97075938abb5c70b4fd/src%2Fcomp%2Fmiddle%2Falias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Falias.rs?ref=5ca83553bc499e677a49b97075938abb5c70b4fd", "patch": "@@ -651,7 +651,7 @@ fn copy_is_expensive(tcx: ty::ctxt, ty: ty::t) -> bool {\n           ty::ty_ptr(_) { 1u }\n           ty::ty_box(_) { 3u }\n           ty::ty_constr(t, _) | ty::ty_res(_, t, _) { score_ty(tcx, t) }\n-          ty::ty_fn(_, _, _, _, _) | ty::ty_native_fn(_, _, _) |\n+          ty::ty_fn(_, _, _, _, _) | ty::ty_native_fn(_, _) |\n           ty::ty_obj(_) { 4u }\n           ty::ty_str. | ty::ty_vec(_) | ty::ty_param(_, _) { 50u }\n           ty::ty_uniq(mt) { 1u + score_ty(tcx, mt.ty) }"}, {"sha": "fcdbb8be29f7cd35253d424d0a4f78cb2b5f6e0c", "filename": "src/comp/middle/gc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5ca83553bc499e677a49b97075938abb5c70b4fd/src%2Fcomp%2Fmiddle%2Fgc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ca83553bc499e677a49b97075938abb5c70b4fd/src%2Fcomp%2Fmiddle%2Fgc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fgc.rs?ref=5ca83553bc499e677a49b97075938abb5c70b4fd", "patch": "@@ -151,7 +151,7 @@ fn type_is_gc_relevant(cx: ty::ctxt, ty: ty::t) -> bool {\n \n \n       ty::ty_box(_) | ty::ty_uniq(_) | ty::ty_fn(_, _, _, _, _) |\n-      ty::ty_native_fn(_, _, _) | ty::ty_obj(_) | ty::ty_param(_, _) |\n+      ty::ty_native_fn(_, _) | ty::ty_obj(_) | ty::ty_param(_, _) |\n       ty::ty_res(_, _, _) {\n         ret true;\n       }"}, {"sha": "9321e30f49432d131dd2321c9fae264917335155", "filename": "src/comp/middle/shape.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5ca83553bc499e677a49b97075938abb5c70b4fd/src%2Fcomp%2Fmiddle%2Fshape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ca83553bc499e677a49b97075938abb5c70b4fd/src%2Fcomp%2Fmiddle%2Fshape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fshape.rs?ref=5ca83553bc499e677a49b97075938abb5c70b4fd", "patch": "@@ -419,7 +419,7 @@ fn shape_of(ccx: @crate_ctxt, t: ty::t, ty_param_map: [uint],\n       ty::ty_fn(_, _, _, _, _) {\n         s += [shape_fn];\n       }\n-      ty::ty_native_fn(_, _, _) { s += [shape_u32]; }\n+      ty::ty_native_fn(_, _) { s += [shape_u32]; }\n       ty::ty_obj(_) { s += [shape_obj]; }\n \n "}, {"sha": "9da71ee8e14839228d49e102578de6b290123ee7", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 48, "deletions": 20, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/5ca83553bc499e677a49b97075938abb5c70b4fd/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ca83553bc499e677a49b97075938abb5c70b4fd/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=5ca83553bc499e677a49b97075938abb5c70b4fd", "patch": "@@ -12,7 +12,7 @@\n //     pcwalton).  You can, instead, find out its TypeRef by calling val_ty,\n //     but many TypeRefs correspond to one ty::t; for instance, tup(int, int,\n //     int) and rec(x=int, y=int, z=int) will have the same TypeRef.\n-import std::{str, uint, map, option, time, vec};\n+import std::{either, str, uint, map, option, time, vec};\n import std::map::hashmap;\n import std::map::{new_int_hash, new_str_hash};\n import std::option::{some, none};\n@@ -182,7 +182,7 @@ fn type_of_inner(cx: @crate_ctxt, sp: span, t: ty::t)\n         check returns_non_ty_var(cx, t);\n         T_fn_pair(cx, type_of_fn_from_ty(cx, sp, t, 0u))\n       }\n-      ty::ty_native_fn(abi, args, out) {\n+      ty::ty_native_fn(args, out) {\n         let nft = native_fn_wrapper_type(cx, sp, 0u, t);\n         T_fn_pair(cx, nft)\n       }\n@@ -235,7 +235,7 @@ fn type_of_ty_param_kinds_and_ty(lcx: @local_ctxt, sp: span,\n     let cx = lcx.ccx;\n     let t = tpt.ty;\n     alt ty::struct(cx.tcx, t) {\n-      ty::ty_fn(_, _, _, _, _) | ty::ty_native_fn(_, _, _) {\n+      ty::ty_fn(_, _, _, _, _) | ty::ty_native_fn(_, _) {\n         check returns_non_ty_var(cx, t);\n         ret type_of_fn_from_ty(cx, sp, t, std::vec::len(tpt.kinds));\n       }\n@@ -1727,7 +1727,7 @@ fn iter_structural_ty(cx: @block_ctxt, av: ValueRef, t: ty::t,\n         }\n         ret next_cx;\n       }\n-      ty::ty_fn(_, _, _, _, _) | ty::ty_native_fn(_, _, _) {\n+      ty::ty_fn(_, _, _, _, _) | ty::ty_native_fn(_, _) {\n         let box_cell_a = GEPi(cx, av, [0, abi::fn_field_box]);\n         ret iter_boxpp(cx, box_cell_a, f);\n       }\n@@ -5305,7 +5305,7 @@ fn c_stack_tys(ccx: @crate_ctxt,\n                sp: span,\n                id: ast::node_id) -> @c_stack_tys {\n     alt ty::struct(ccx.tcx, ty::node_id_to_type(ccx.tcx, id)) {\n-      ty::ty_native_fn(_, arg_tys, ret_ty) {\n+      ty::ty_native_fn(arg_tys, ret_ty) {\n         let tcx = ccx.tcx;\n         let llargtys = type_of_explicit_args(ccx, sp, arg_tys);\n         check non_ty_var(ccx, ret_ty); // NDM does this truly hold?\n@@ -5365,7 +5365,8 @@ fn c_stack_tys(ccx: @crate_ctxt,\n // stack pointer appropriately to avoid a round of copies.  (In fact, the shim\n // function itself is unnecessary). We used to do this, in fact, and will\n // perhaps do so in the future.\n-fn trans_native_mod(lcx: @local_ctxt, native_mod: ast::native_mod) {\n+fn trans_native_mod(lcx: @local_ctxt, native_mod: ast::native_mod,\n+                    abi: ast::native_abi) {\n     fn build_shim_fn(lcx: @local_ctxt,\n                      native_item: @ast::native_item,\n                      tys: @c_stack_tys,\n@@ -5448,7 +5449,7 @@ fn trans_native_mod(lcx: @local_ctxt, native_mod: ast::native_mod) {\n \n     let ccx = lcx_ccx(lcx);\n     let cc: uint = lib::llvm::LLVMCCallConv;\n-    alt native_mod.abi {\n+    alt abi {\n       ast::native_abi_rust_intrinsic. { ret; }\n       ast::native_abi_cdecl. { cc = lib::llvm::LLVMCCallConv; }\n       ast::native_abi_stdcall. { cc = lib::llvm::LLVMX86StdcallCallConv; }\n@@ -5529,13 +5530,16 @@ fn trans_item(cx: @local_ctxt, item: ast::item) {\n       }\n       ast::item_const(_, expr) { trans_const(cx.ccx, expr, item.id); }\n       ast::item_native_mod(native_mod) {\n-        trans_native_mod(cx, native_mod);\n+        let abi = alt attr::native_abi(item.attrs) {\n+          either::right(abi_) { abi_ }\n+          either::left(msg) { cx.ccx.sess.span_fatal(item.span, msg) }\n+        };\n+        trans_native_mod(cx, native_mod, abi);\n       }\n       _ {/* fall through */ }\n     }\n }\n \n-\n // Translate a module.  Doing this amounts to translating the items in the\n // module; there ends up being no artifact (aside from linkage names) of\n // separate modules in the compiled program.  That's because modules exist\n@@ -5697,7 +5701,7 @@ fn native_fn_ty_param_count(cx: @crate_ctxt, id: ast::node_id) -> uint {\n fn native_fn_wrapper_type(cx: @crate_ctxt, sp: span, ty_param_count: uint,\n                           x: ty::t) -> TypeRef {\n     alt ty::struct(cx.tcx, x) {\n-      ty::ty_native_fn(abi, args, out) {\n+      ty::ty_native_fn(args, out) {\n         check non_ty_var(cx, out);\n         ret type_of_fn(cx, sp, false, false, args, out, ty_param_count);\n       }\n@@ -5719,18 +5723,32 @@ fn link_name(i: @ast::native_item) -> str {\n     }\n }\n \n-fn collect_native_item(ccx: @crate_ctxt, i: @ast::native_item, &&pt: [str],\n+fn collect_native_item(ccx: @crate_ctxt,\n+                       abi: @mutable option::t<ast::native_abi>,\n+                       i: @ast::native_item,\n+                       &&pt: [str],\n                        _v: vt<[str]>) {\n     alt i.node {\n       ast::native_item_fn(_, tps) {\n         if !ccx.obj_methods.contains_key(i.id) {\n             let sp = i.span;\n             let id = i.id;\n             let node_type = node_id_type(ccx, id);\n-            // FIXME NDM abi should come from attr\n-            let abi = ty::ty_fn_abi(ccx.tcx, node_type);\n-\n-            alt abi {\n+            let fn_abi =\n+                alt attr::get_meta_item_value_str_by_name(i.attrs, \"abi\") {\n+              option::none. {\n+                // if abi isn't specified for this function, inherit from\n+                // its enclosing native module\n+                option::get(*abi)\n+              }\n+              _ {\n+                alt attr::native_abi(i.attrs) {\n+                  either::right(abi_) { abi_ }\n+                  either::left(msg) { ccx.sess.span_fatal(i.span, msg) }\n+                }\n+              }\n+            };\n+            alt fn_abi {\n               ast::native_abi_rust_intrinsic. {\n                 // For intrinsics: link the function directly to the intrinsic\n                 // function itself.\n@@ -5760,9 +5778,8 @@ fn collect_native_item(ccx: @crate_ctxt, i: @ast::native_item, &&pt: [str],\n     }\n }\n \n-fn collect_item_1(ccx: @crate_ctxt, i: @ast::item, &&pt: [str],\n-                  v: vt<[str]>) {\n-    visit::visit_item(i, pt + item_path(i), v);\n+fn collect_item_1(ccx: @crate_ctxt, abi: @mutable option::t<ast::native_abi>,\n+                  i: @ast::item, &&pt: [str], v: vt<[str]>) {\n     alt i.node {\n       ast::item_const(_, _) {\n         let typ = node_id_type(ccx, i.id);\n@@ -5778,8 +5795,18 @@ fn collect_item_1(ccx: @crate_ctxt, i: @ast::item, &&pt: [str],\n         ccx.item_symbols.insert(i.id, s);\n         ccx.consts.insert(i.id, g);\n       }\n+      ast::item_native_mod(native_mod) {\n+        // Propagate the native ABI down to collect_native_item(),\n+        alt attr::native_abi(i.attrs) {\n+          either::left(msg) { ccx.sess.span_fatal(i.span, msg); }\n+          either::right(abi_) {\n+            *abi = option::some(abi_);\n+          }\n+        }\n+      }\n       _ { }\n     }\n+    visit::visit_item(i, pt + item_path(i), v);\n }\n \n fn collect_item_2(ccx: @crate_ctxt, i: @ast::item, &&pt: [str],\n@@ -5814,10 +5841,11 @@ fn collect_item_2(ccx: @crate_ctxt, i: @ast::item, &&pt: [str],\n }\n \n fn collect_items(ccx: @crate_ctxt, crate: @ast::crate) {\n+    let abi = @mutable none::<ast::native_abi>;\n     let visitor0 = visit::default_visitor();\n     let visitor1 =\n-        @{visit_native_item: bind collect_native_item(ccx, _, _, _),\n-          visit_item: bind collect_item_1(ccx, _, _, _) with *visitor0};\n+        @{visit_native_item: bind collect_native_item(ccx, abi, _, _, _),\n+          visit_item: bind collect_item_1(ccx, abi, _, _, _) with *visitor0};\n     let visitor2 =\n         @{visit_item: bind collect_item_2(ccx, _, _, _) with *visitor0};\n     visit::visit_crate(*crate, [], visit::mk_vt(visitor1));"}, {"sha": "6e35aabf03266ac38beb42567a583e8b2ac39da7", "filename": "src/comp/middle/tstate/auxiliary.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5ca83553bc499e677a49b97075938abb5c70b4fd/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ca83553bc499e677a49b97075938abb5c70b4fd/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs?ref=5ca83553bc499e677a49b97075938abb5c70b4fd", "patch": "@@ -1070,7 +1070,7 @@ fn callee_modes(fcx: fn_ctxt, callee: node_id) -> [ty::mode] {\n         ty::type_autoderef(fcx.ccx.tcx,\n                            ty::node_id_to_type(fcx.ccx.tcx, callee));\n     alt ty::struct(fcx.ccx.tcx, ty) {\n-      ty::ty_fn(_, args, _, _, _) | ty::ty_native_fn(_, args, _) {\n+      ty::ty_fn(_, args, _, _, _) | ty::ty_native_fn(args, _) {\n         let modes = [];\n         for arg: ty::arg in args { modes += [arg.mode]; }\n         ret modes;"}, {"sha": "9471c4e01c5dcbee37835d3711f33707eb2d01af", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 21, "deletions": 31, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/5ca83553bc499e677a49b97075938abb5c70b4fd/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ca83553bc499e677a49b97075938abb5c70b4fd/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=5ca83553bc499e677a49b97075938abb5c70b4fd", "patch": "@@ -113,7 +113,6 @@ export ty_constr;\n export ty_constr_arg;\n export ty_float;\n export ty_fn;\n-export ty_fn_abi;\n export ty_fn_proto;\n export ty_fn_ret;\n export ty_fn_ret_style;\n@@ -259,7 +258,7 @@ tag sty {\n     ty_ptr(mt);\n     ty_rec([field]);\n     ty_fn(ast::proto, [arg], t, ret_style, [@constr]);\n-    ty_native_fn(ast::native_abi, [arg], t);\n+    ty_native_fn([arg], t);\n     ty_obj([method]);\n     ty_res(def_id, t, [t]);\n     ty_tup([t]);\n@@ -465,7 +464,7 @@ fn mk_raw_ty(cx: ctxt, st: sty, _in_cname: option::t<str>) -> @raw_t {\n       ty_fn(_, args, tt, _, _) {\n         derive_flags_sig(cx, has_params, has_vars, args, tt);\n       }\n-      ty_native_fn(_, args, tt) {\n+      ty_native_fn(args, tt) {\n         derive_flags_sig(cx, has_params, has_vars, args, tt);\n       }\n       ty_obj(meths) {\n@@ -568,8 +567,8 @@ fn mk_fn(cx: ctxt, proto: ast::proto, args: [arg], ty: t, cf: ret_style,\n     ret gen_ty(cx, ty_fn(proto, args, ty, cf, constrs));\n }\n \n-fn mk_native_fn(cx: ctxt, abi: ast::native_abi, args: [arg], ty: t) -> t {\n-    ret gen_ty(cx, ty_native_fn(abi, args, ty));\n+fn mk_native_fn(cx: ctxt, args: [arg], ty: t) -> t {\n+    ret gen_ty(cx, ty_native_fn(args, ty));\n }\n \n fn mk_obj(cx: ctxt, meths: [method]) -> t { ret gen_ty(cx, ty_obj(meths)); }\n@@ -628,7 +627,7 @@ fn walk_ty(cx: ctxt, walker: ty_walk, ty: t) {\n         for a: arg in args { walk_ty(cx, walker, a.ty); }\n         walk_ty(cx, walker, ret_ty);\n       }\n-      ty_native_fn(abi, args, ret_ty) {\n+      ty_native_fn(args, ret_ty) {\n         for a: arg in args { walk_ty(cx, walker, a.ty); }\n         walk_ty(cx, walker, ret_ty);\n       }\n@@ -719,15 +718,15 @@ fn fold_ty(cx: ctxt, fld: fold_mode, ty_0: t) -> t {\n                        mk_fn(cx, proto, new_args, fold_ty(cx, fld, ret_ty),\n                              cf, constrs), ty);\n       }\n-      ty_native_fn(abi, args, ret_ty) {\n+      ty_native_fn(args, ret_ty) {\n         let new_args: [arg] = [];\n         for a: arg in args {\n             let new_ty = fold_ty(cx, fld, a.ty);\n             new_args += [{mode: a.mode, ty: new_ty}];\n         }\n         ty =\n             copy_cname(cx,\n-                       mk_native_fn(cx, abi, new_args,\n+                       mk_native_fn(cx, new_args,\n                                     fold_ty(cx, fld, ret_ty)), ty);\n       }\n       ty_obj(methods) {\n@@ -802,7 +801,7 @@ fn type_is_structural(cx: ctxt, ty: t) -> bool {\n       ty_tup(_) { ret true; }\n       ty_tag(_, _) { ret true; }\n       ty_fn(_, _, _, _, _) { ret true; }\n-      ty_native_fn(_, _, _) { ret true; }\n+      ty_native_fn(_, _) { ret true; }\n       ty_obj(_) { ret true; }\n       ty_res(_, _, _) { ret true; }\n       _ { ret false; }\n@@ -1008,7 +1007,7 @@ fn type_kind(cx: ctxt, ty: t) -> ast::kind {\n       // Scalar and unique types are sendable\n       ty_nil. | ty_bot. | ty_bool. | ty_int. | ty_uint. | ty_float. |\n       ty_machine(_) | ty_char. | ty_native(_) |\n-      ty_type. | ty_str. | ty_native_fn(_, _, _) { ast::kind_sendable }\n+      ty_type. | ty_str. | ty_native_fn(_, _) { ast::kind_sendable }\n       // FIXME: obj is broken for now, since we aren't asserting\n       // anything about its fields.\n       ty_obj(_) { kind_copyable }\n@@ -1221,7 +1220,7 @@ fn type_is_pod(cx: ctxt, ty: t) -> bool {\n       }\n       // Boxed types\n       ty_str. | ty_box(_) | ty_uniq(_) | ty_vec(_) | ty_fn(_, _, _, _, _) |\n-      ty_native_fn(_, _, _) | ty_obj(_) {\n+      ty_native_fn(_, _) | ty_obj(_) {\n         result = false;\n       }\n       // Structural types\n@@ -1390,7 +1389,7 @@ fn hash_type_structure(st: sty) -> uint {\n       ty_fn(_, args, rty, _, _) {\n         ret hash_fn(27u, args, rty);\n       }\n-      ty_native_fn(_, args, rty) { ret hash_fn(28u, args, rty); }\n+      ty_native_fn(args, rty) { ret hash_fn(28u, args, rty); }\n       ty_obj(methods) {\n         let h = 29u;\n         for m: method in methods { h += h << 5u + str::hash(m.ident); }\n@@ -1584,34 +1583,27 @@ fn type_contains_params(cx: ctxt, typ: t) -> bool {\n fn ty_fn_args(cx: ctxt, fty: t) -> [arg] {\n     alt struct(cx, fty) {\n       ty::ty_fn(_, a, _, _, _) { ret a; }\n-      ty::ty_native_fn(_, a, _) { ret a; }\n+      ty::ty_native_fn(a, _) { ret a; }\n       _ { cx.sess.bug(\"ty_fn_args() called on non-fn type\"); }\n     }\n }\n \n fn ty_fn_proto(cx: ctxt, fty: t) -> ast::proto {\n     alt struct(cx, fty) {\n       ty::ty_fn(p, _, _, _, _) { ret p; }\n-      ty::ty_native_fn(_, _, _) {\n+      ty::ty_native_fn(_, _) {\n         // FIXME: This should probably be proto_bare\n         ret ast::proto_shared(ast::sugar_normal);\n       }\n       _ { cx.sess.bug(\"ty_fn_proto() called on non-fn type\"); }\n     }\n }\n \n-fn ty_fn_abi(cx: ctxt, fty: t) -> ast::native_abi {\n-    alt struct(cx, fty) {\n-      ty::ty_native_fn(a, _, _) { ret a; }\n-      _ { cx.sess.bug(\"ty_fn_abi() called on non-native-fn type\"); }\n-    }\n-}\n-\n pure fn ty_fn_ret(cx: ctxt, fty: t) -> t {\n     let sty = struct(cx, fty);\n     alt sty {\n       ty::ty_fn(_, _, r, _, _) { ret r; }\n-      ty::ty_native_fn(_, _, r) { ret r; }\n+      ty::ty_native_fn(_, r) { ret r; }\n       _ {\n         // Unchecked is ok since we diverge here\n         // (might want to change the typechecker to allow\n@@ -1626,15 +1618,15 @@ pure fn ty_fn_ret(cx: ctxt, fty: t) -> t {\n fn ty_fn_ret_style(cx: ctxt, fty: t) -> ast::ret_style {\n     alt struct(cx, fty) {\n       ty::ty_fn(_, _, _, rs, _) { rs }\n-      ty::ty_native_fn(_, _, _) { ast::return_val }\n+      ty::ty_native_fn(_, _) { ast::return_val }\n       _ { cx.sess.bug(\"ty_fn_ret_style() called on non-fn type\"); }\n     }\n }\n \n fn is_fn_ty(cx: ctxt, fty: t) -> bool {\n     alt struct(cx, fty) {\n       ty::ty_fn(_, _, _, _, _) { ret true; }\n-      ty::ty_native_fn(_, _, _) { ret true; }\n+      ty::ty_native_fn(_, _) { ret true; }\n       _ { ret false; }\n     }\n }\n@@ -2097,20 +2089,18 @@ mod unify {\n           }\n         }\n     }\n-    fn unify_native_fn(cx: @ctxt, e_abi: ast::native_abi,\n-                       a_abi: ast::native_abi, expected: t, actual: t,\n+    fn unify_native_fn(cx: @ctxt, expected: t, actual: t,\n                        expected_inputs: [arg], expected_output: t,\n                        actual_inputs: [arg], actual_output: t,\n                        variance: variance) -> result {\n-        if e_abi != a_abi { ret ures_err(terr_mismatch); }\n         let t =\n             unify_fn_common(cx, expected, actual, expected_inputs,\n                             expected_output, actual_inputs, actual_output,\n                             variance);\n         alt t {\n           fn_common_res_err(r) { ret r; }\n           fn_common_res_ok(result_ins, result_out) {\n-            let t2 = mk_native_fn(cx.tcx, e_abi, result_ins, result_out);\n+            let t2 = mk_native_fn(cx.tcx, result_ins, result_out);\n             ret ures_ok(t2);\n           }\n         }\n@@ -2521,10 +2511,10 @@ mod unify {\n               _ { ret ures_err(terr_mismatch); }\n             }\n           }\n-          ty::ty_native_fn(e_abi, expected_inputs, expected_output) {\n+          ty::ty_native_fn(expected_inputs, expected_output) {\n             alt struct(cx.tcx, actual) {\n-              ty::ty_native_fn(a_abi, actual_inputs, actual_output) {\n-                ret unify_native_fn(cx, e_abi, a_abi, expected, actual,\n+              ty::ty_native_fn(actual_inputs, actual_output) {\n+                ret unify_native_fn(cx, expected, actual,\n                                     expected_inputs, expected_output,\n                                     actual_inputs, actual_output, variance);\n               }"}, {"sha": "156c1cf1138144c209310a938820dd92614a644a", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 15, "deletions": 25, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/5ca83553bc499e677a49b97075938abb5c70b4fd/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ca83553bc499e677a49b97075938abb5c70b4fd/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=5ca83553bc499e677a49b97075938abb5c70b4fd", "patch": "@@ -524,14 +524,14 @@ mod collect {\n     }\n     fn ty_of_native_fn_decl(cx: @ctxt, convert: fn@(&&@ast::ty) -> ty::t,\n                             ty_of_arg: fn@(ast::arg) -> arg,\n-                            decl: ast::fn_decl, abi: ast::native_abi,\n+                            decl: ast::fn_decl,\n                             ty_params: [ast::ty_param], def_id: ast::def_id)\n        -> ty::ty_param_kinds_and_ty {\n         let input_tys = [];\n         for a: ast::arg in decl.inputs { input_tys += [ty_of_arg(a)]; }\n         let output_ty = convert(decl.output);\n \n-        let t_fn = ty::mk_native_fn(cx.tcx, abi, input_tys, output_ty);\n+        let t_fn = ty::mk_native_fn(cx.tcx, input_tys, output_ty);\n         let tpt = {kinds: ty_param_kinds(ty_params), ty: t_fn};\n         cx.tcx.tcache.insert(def_id, tpt);\n         ret tpt;\n@@ -546,8 +546,7 @@ mod collect {\n         alt it {\n           some(ast_map::node_item(item)) { tpt = ty_of_item(cx, item); }\n           some(ast_map::node_native_item(native_item)) {\n-            tpt = ty_of_native_item(cx, native_item,\n-                                    ast::native_abi_cdecl);\n+            tpt = ty_of_native_item(cx, native_item);\n           }\n           _ { cx.tcx.sess.fatal(\"internal error \" + std::int::str(id.node)); }\n         }\n@@ -661,15 +660,15 @@ mod collect {\n           ast::item_native_mod(_) { fail; }\n         }\n     }\n-    fn ty_of_native_item(cx: @ctxt, it: @ast::native_item,\n-                         abi: ast::native_abi) -> ty::ty_param_kinds_and_ty {\n+    fn ty_of_native_item(cx: @ctxt, it: @ast::native_item)\n+        -> ty::ty_param_kinds_and_ty {\n         let no_kinds: [ast::kind] = [];\n         alt it.node {\n           ast::native_item_fn(fn_decl, params) {\n             let get = bind getter(cx, _);\n             let convert = bind ast_ty_to_ty(cx.tcx, get, _);\n             let f = bind ty_of_arg(cx, _);\n-            ret ty_of_native_fn_decl(cx, convert, f, fn_decl, abi, params,\n+            ret ty_of_native_fn_decl(cx, convert, f, fn_decl, params,\n                                      ast_util::local_def(it.id));\n           }\n           ast::native_item_ty. {\n@@ -726,16 +725,13 @@ mod collect {\n         }\n         ret meths;\n     }\n-    fn convert(cx: @ctxt, abi: @mutable option::t<ast::native_abi>,\n-               it: @ast::item) {\n+    fn convert(cx: @ctxt, it: @ast::item) {\n         alt it.node {\n           ast::item_mod(_) {\n             // ignore item_mod, it has no type.\n           }\n           ast::item_native_mod(native_mod) {\n-            // Propagate the native ABI down to convert_native() below,\n-            // but otherwise do nothing, as native modules have no types.\n-            *abi = some::<ast::native_abi>(native_mod.abi);\n+            // do nothing, as native modules have no types.\n           }\n           ast::item_tag(variants, ty_params) {\n             let tpt = ty_of_item(cx, it);\n@@ -804,14 +800,11 @@ mod collect {\n           }\n         }\n     }\n-    fn convert_native(cx: @ctxt, abi: @mutable option::t<ast::native_abi>,\n-                      i: @ast::native_item) {\n+    fn convert_native(cx: @ctxt, i: @ast::native_item) {\n         // As above, this call populates the type table with the converted\n         // type of the native item. We simply write it into the node type\n         // table.\n-        let tpt =\n-            ty_of_native_item(cx, i,\n-                              option::get::<ast::native_abi>({ *abi }));\n+        let tpt = ty_of_native_item(cx, i);\n         alt i.node {\n           ast::native_item_ty. {\n             // FIXME: Native types have no annotation. Should they? --pcw\n@@ -822,14 +815,11 @@ mod collect {\n         }\n     }\n     fn collect_item_types(tcx: ty::ctxt, crate: @ast::crate) {\n-        // We have to propagate the surrounding ABI to the native items\n-        // contained within the native module.\n-        let abi = @mutable none::<ast::native_abi>;\n         let cx = @{tcx: tcx};\n         let visit =\n-            visit::mk_simple_visitor(@{visit_item: bind convert(cx, abi, _),\n+            visit::mk_simple_visitor(@{visit_item: bind convert(cx, _),\n                                        visit_native_item:\n-                                           bind convert_native(cx, abi, _)\n+                                           bind convert_native(cx, _)\n                                        with\n                                           *visit::default_simple_visitor()});\n         visit::visit_crate(*crate, (), visit);\n@@ -1567,7 +1557,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n         // Grab the argument types\n         let arg_tys =\n             alt sty {\n-              ty::ty_fn(_, arg_tys, _, _, _) | ty::ty_native_fn(_, arg_tys, _)\n+              ty::ty_fn(_, arg_tys, _, _, _) | ty::ty_native_fn(arg_tys, _)\n               {\n                 arg_tys\n               }\n@@ -1676,7 +1666,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n             bot |= cf == ast::noreturn;\n             rt_1 = rt;\n           }\n-          ty::ty_native_fn(_, _, rt) { rt_1 = rt; }\n+          ty::ty_native_fn(_, rt) { rt_1 = rt; }\n           _ { fcx.ccx.tcx.sess.span_fatal(sp, \"calling non-function\"); }\n         }\n         write::ty_only_fixup(fcx, id, rt_1);\n@@ -2031,7 +2021,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n             cf = cf_;\n             constrs = constrs_;\n           }\n-          ty::ty_native_fn(_, arg_tys_, rt_) {\n+          ty::ty_native_fn(arg_tys_, rt_) {\n             proto = ast::proto_bare;\n             arg_tys = arg_tys_;\n             rt = rt_;"}, {"sha": "24bb3e8d68b3f5600502c719824939af848a9659", "filename": "src/comp/syntax/ast.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5ca83553bc499e677a49b97075938abb5c70b4fd/src%2Fcomp%2Fsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ca83553bc499e677a49b97075938abb5c70b4fd/src%2Fcomp%2Fsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fast.rs?ref=5ca83553bc499e677a49b97075938abb5c70b4fd", "patch": "@@ -431,9 +431,7 @@ tag native_abi {\n }\n \n type native_mod =\n-    {// FIXME: Removing abi from AST. Depends on Issue #1179.\n-     abi: native_abi,\n-     view_items: [@view_item],\n+    {view_items: [@view_item],\n      items: [@native_item]};\n \n type variant_arg = {ty: @ty, id: node_id};"}, {"sha": "0eab97481bc3515429cd6175701274e085442990", "filename": "src/comp/syntax/fold.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5ca83553bc499e677a49b97075938abb5c70b4fd/src%2Fcomp%2Fsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ca83553bc499e677a49b97075938abb5c70b4fd/src%2Fcomp%2Fsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Ffold.rs?ref=5ca83553bc499e677a49b97075938abb5c70b4fd", "patch": "@@ -452,8 +452,7 @@ fn noop_fold_mod(m: _mod, fld: ast_fold) -> _mod {\n }\n \n fn noop_fold_native_mod(nm: native_mod, fld: ast_fold) -> native_mod {\n-    ret {abi: nm.abi,\n-         view_items: vec::map(fld.fold_view_item, nm.view_items),\n+    ret {view_items: vec::map(fld.fold_view_item, nm.view_items),\n          items: vec::map(fld.fold_native_item, nm.items)}\n }\n "}, {"sha": "8d7a3bcc4141de25449da2e307a7999bc0daaeb8", "filename": "src/comp/syntax/parse/parser.rs", "status": "modified", "additions": 3, "deletions": 22, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/5ca83553bc499e677a49b97075938abb5c70b4fd/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ca83553bc499e677a49b97075938abb5c70b4fd/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs?ref=5ca83553bc499e677a49b97075938abb5c70b4fd", "patch": "@@ -1981,8 +1981,7 @@ fn parse_native_item(p: parser, attrs: [ast::attribute]) ->\n     } else { unexpected(p, p.peek()); }\n }\n \n-fn parse_native_mod_items(p: parser, abi: ast::native_abi,\n-                          first_item_attrs: [ast::attribute]) ->\n+fn parse_native_mod_items(p: parser, first_item_attrs: [ast::attribute]) ->\n    ast::native_mod {\n     // Shouldn't be any view items since we've already parsed an item attr\n     let view_items =\n@@ -1996,8 +1995,7 @@ fn parse_native_mod_items(p: parser, abi: ast::native_abi,\n         initial_attrs = [];\n         items += [parse_native_item(p, attrs)];\n     }\n-    ret {abi: abi,\n-         view_items: view_items,\n+    ret {view_items: view_items,\n          items: items};\n }\n \n@@ -2009,24 +2007,7 @@ fn parse_item_native_mod(p: parser, attrs: [ast::attribute]) -> @ast::item {\n     let more_attrs = parse_inner_attrs_and_next(p);\n     let inner_attrs = more_attrs.inner;\n     let first_item_outer_attrs = more_attrs.next;\n-    let abi =\n-        alt attr::get_meta_item_value_str_by_name(\n-                attrs + inner_attrs, \"abi\") {\n-          none. { ast::native_abi_cdecl }\n-          some(\"rust-intrinsic\") {\n-            ast::native_abi_rust_intrinsic\n-          }\n-          some(\"cdecl\") {\n-            ast::native_abi_cdecl\n-          }\n-          some(\"stdcall\") {\n-            ast::native_abi_stdcall\n-          }\n-          some(t) {\n-            p.fatal(\"unsupported abi: \" + t);\n-          }\n-        };\n-    let m = parse_native_mod_items(p, abi, first_item_outer_attrs);\n+    let m = parse_native_mod_items(p, first_item_outer_attrs);\n     let hi = p.get_hi_pos();\n     expect(p, token::RBRACE);\n     ret mk_item(p, lo, hi, id, ast::item_native_mod(m), attrs + inner_attrs);"}, {"sha": "03af32428bb90c7737ed3b54dc858ca1091e1ba2", "filename": "src/comp/util/ppaux.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5ca83553bc499e677a49b97075938abb5c70b4fd/src%2Fcomp%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ca83553bc499e677a49b97075938abb5c70b4fd/src%2Fcomp%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Futil%2Fppaux.rs?ref=5ca83553bc499e677a49b97075938abb5c70b4fd", "patch": "@@ -127,7 +127,7 @@ fn ty_to_str(cx: ctxt, typ: t) -> str {\n           ty_fn(proto, inputs, output, cf, constrs) {\n             fn_to_str(cx, proto, none, inputs, output, cf, constrs)\n           }\n-          ty_native_fn(_, inputs, output) {\n+          ty_native_fn(inputs, output) {\n             fn_to_str(cx, ast::proto_bare, none, inputs, output,\n                       ast::return_val, [])\n           }"}]}