{"sha": "e2631208b1888d6a340938314457446a7f8ed2fc", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUyNjMxMjA4YjE4ODhkNmEzNDA5MzgzMTQ0NTc0NDZhN2Y4ZWQyZmM=", "commit": {"author": {"name": "Nicholas Nethercote", "email": "nnethercote@mozilla.com", "date": "2016-10-04T00:55:58Z"}, "committer": {"name": "Nicholas Nethercote", "email": "nnethercote@mozilla.com", "date": "2016-10-04T21:57:35Z"}, "message": "Rename StringReader::curr as ch.\n\nLikewise, rename StringReader::curr_is as ch_is.\n\nThis is a [breaking-change] for libsyntax.", "tree": {"sha": "6f35a5c1450bac43dc0d5e7b8d408afbf29a8567", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6f35a5c1450bac43dc0d5e7b8d408afbf29a8567"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e2631208b1888d6a340938314457446a7f8ed2fc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e2631208b1888d6a340938314457446a7f8ed2fc", "html_url": "https://github.com/rust-lang/rust/commit/e2631208b1888d6a340938314457446a7f8ed2fc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e2631208b1888d6a340938314457446a7f8ed2fc/comments", "author": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cb92f5c6d6e09a7c1575241a05df15c96ca3b531", "url": "https://api.github.com/repos/rust-lang/rust/commits/cb92f5c6d6e09a7c1575241a05df15c96ca3b531", "html_url": "https://github.com/rust-lang/rust/commit/cb92f5c6d6e09a7c1575241a05df15c96ca3b531"}], "stats": {"total": 198, "additions": 99, "deletions": 99}, "files": [{"sha": "38f811d54dab83adcfb0cfc46296736083d601d1", "filename": "src/libsyntax/parse/lexer/comments.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/e2631208b1888d6a340938314457446a7f8ed2fc/src%2Flibsyntax%2Fparse%2Flexer%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2631208b1888d6a340938314457446a7f8ed2fc/src%2Flibsyntax%2Fparse%2Flexer%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fcomments.rs?ref=e2631208b1888d6a340938314457446a7f8ed2fc", "patch": "@@ -154,8 +154,8 @@ fn push_blank_line_comment(rdr: &StringReader, comments: &mut Vec<Comment>) {\n }\n \n fn consume_whitespace_counting_blank_lines(rdr: &mut StringReader, comments: &mut Vec<Comment>) {\n-    while is_pattern_whitespace(rdr.curr) && !rdr.is_eof() {\n-        if rdr.col == CharPos(0) && rdr.curr_is('\\n') {\n+    while is_pattern_whitespace(rdr.ch) && !rdr.is_eof() {\n+        if rdr.col == CharPos(0) && rdr.ch_is('\\n') {\n             push_blank_line_comment(rdr, &mut *comments);\n         }\n         rdr.bump();\n@@ -182,7 +182,7 @@ fn read_line_comments(rdr: &mut StringReader,\n     debug!(\">>> line comments\");\n     let p = rdr.pos;\n     let mut lines: Vec<String> = Vec::new();\n-    while rdr.curr_is('/') && rdr.nextch_is('/') {\n+    while rdr.ch_is('/') && rdr.nextch_is('/') {\n         let line = rdr.read_one_line_comment();\n         debug!(\"{}\", line);\n         // Doc comments are not put in comments.\n@@ -249,9 +249,9 @@ fn read_block_comment(rdr: &mut StringReader,\n     let mut curr_line = String::from(\"/*\");\n \n     // doc-comments are not really comments, they are attributes\n-    if (rdr.curr_is('*') && !rdr.nextch_is('*')) || rdr.curr_is('!') {\n-        while !(rdr.curr_is('*') && rdr.nextch_is('/')) && !rdr.is_eof() {\n-            curr_line.push(rdr.curr.unwrap());\n+    if (rdr.ch_is('*') && !rdr.nextch_is('*')) || rdr.ch_is('!') {\n+        while !(rdr.ch_is('*') && rdr.nextch_is('/')) && !rdr.is_eof() {\n+            curr_line.push(rdr.ch.unwrap());\n             rdr.bump();\n         }\n         if !rdr.is_eof() {\n@@ -271,19 +271,19 @@ fn read_block_comment(rdr: &mut StringReader,\n             if rdr.is_eof() {\n                 panic!(rdr.fatal(\"unterminated block comment\"));\n             }\n-            if rdr.curr_is('\\n') {\n+            if rdr.ch_is('\\n') {\n                 trim_whitespace_prefix_and_push_line(&mut lines, curr_line, col);\n                 curr_line = String::new();\n                 rdr.bump();\n             } else {\n-                curr_line.push(rdr.curr.unwrap());\n-                if rdr.curr_is('/') && rdr.nextch_is('*') {\n+                curr_line.push(rdr.ch.unwrap());\n+                if rdr.ch_is('/') && rdr.nextch_is('*') {\n                     rdr.bump();\n                     rdr.bump();\n                     curr_line.push('*');\n                     level += 1;\n                 } else {\n-                    if rdr.curr_is('*') && rdr.nextch_is('/') {\n+                    if rdr.ch_is('*') && rdr.nextch_is('/') {\n                         rdr.bump();\n                         rdr.bump();\n                         curr_line.push('/');\n@@ -305,7 +305,7 @@ fn read_block_comment(rdr: &mut StringReader,\n         Isolated\n     };\n     rdr.consume_non_eol_whitespace();\n-    if !rdr.is_eof() && !rdr.curr_is('\\n') && lines.len() == 1 {\n+    if !rdr.is_eof() && !rdr.ch_is('\\n') && lines.len() == 1 {\n         style = Mixed;\n     }\n     debug!(\"<<< block comment\");\n@@ -319,11 +319,11 @@ fn read_block_comment(rdr: &mut StringReader,\n \n fn consume_comment(rdr: &mut StringReader, code_to_the_left: bool, comments: &mut Vec<Comment>) {\n     debug!(\">>> consume comment\");\n-    if rdr.curr_is('/') && rdr.nextch_is('/') {\n+    if rdr.ch_is('/') && rdr.nextch_is('/') {\n         read_line_comments(rdr, code_to_the_left, comments);\n-    } else if rdr.curr_is('/') && rdr.nextch_is('*') {\n+    } else if rdr.ch_is('/') && rdr.nextch_is('*') {\n         read_block_comment(rdr, code_to_the_left, comments);\n-    } else if rdr.curr_is('#') && rdr.nextch_is('!') {\n+    } else if rdr.ch_is('#') && rdr.nextch_is('!') {\n         read_shebang_comment(rdr, code_to_the_left, comments);\n     } else {\n         panic!();\n@@ -357,7 +357,7 @@ pub fn gather_comments_and_literals(span_diagnostic: &errors::Handler,\n         loop {\n             let mut code_to_the_left = !first_read;\n             rdr.consume_non_eol_whitespace();\n-            if rdr.curr_is('\\n') {\n+            if rdr.ch_is('\\n') {\n                 code_to_the_left = false;\n                 consume_whitespace_counting_blank_lines(&mut rdr, &mut comments);\n             }"}, {"sha": "04d5f3a1ee427b8eeb1ea8f6562353393d805dde", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 84, "deletions": 84, "changes": 168, "blob_url": "https://github.com/rust-lang/rust/blob/e2631208b1888d6a340938314457446a7f8ed2fc/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2631208b1888d6a340938314457446a7f8ed2fc/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=e2631208b1888d6a340938314457446a7f8ed2fc", "patch": "@@ -82,8 +82,8 @@ pub struct StringReader<'a> {\n     pub pos: BytePos,\n     /// The column of the next character to read\n     pub col: CharPos,\n-    /// The last character to be read\n-    pub curr: Option<char>,\n+    /// The current character (which has been read from self.pos)\n+    pub ch: Option<char>,\n     pub filemap: Rc<syntax_pos::FileMap>,\n     /// If Some, stop reading the source at this position (inclusive).\n     pub terminator: Option<BytePos>,\n@@ -102,7 +102,7 @@ pub struct StringReader<'a> {\n \n impl<'a> Reader for StringReader<'a> {\n     fn is_eof(&self) -> bool {\n-        if self.curr.is_none() {\n+        if self.ch.is_none() {\n             return true;\n         }\n \n@@ -173,7 +173,7 @@ impl<'a> Reader for TtReader<'a> {\n }\n \n impl<'a> StringReader<'a> {\n-    /// For comments.rs, which hackily pokes into next_pos and curr\n+    /// For comments.rs, which hackily pokes into next_pos and ch\n     pub fn new_raw<'b>(span_diagnostic: &'b Handler,\n                        filemap: Rc<syntax_pos::FileMap>)\n                        -> StringReader<'b> {\n@@ -198,7 +198,7 @@ impl<'a> StringReader<'a> {\n             next_pos: filemap.start_pos,\n             pos: filemap.start_pos,\n             col: CharPos(0),\n-            curr: Some('\\n'),\n+            ch: Some('\\n'),\n             filemap: filemap,\n             terminator: None,\n             save_new_lines: true,\n@@ -221,8 +221,8 @@ impl<'a> StringReader<'a> {\n         sr\n     }\n \n-    pub fn curr_is(&self, c: char) -> bool {\n-        self.curr == Some(c)\n+    pub fn ch_is(&self, c: char) -> bool {\n+        self.ch == Some(c)\n     }\n \n     /// Report a fatal lexical error with a given span.\n@@ -332,7 +332,7 @@ impl<'a> StringReader<'a> {\n \n     /// Calls `f` with a string slice of the source text spanning from `start`\n     /// up to but excluding `self.pos`, meaning the slice does not include\n-    /// the character `self.curr`.\n+    /// the character `self.ch`.\n     pub fn with_str_from<T, F>(&self, start: BytePos, f: F) -> T\n         where F: FnOnce(&str) -> T\n     {\n@@ -417,11 +417,11 @@ impl<'a> StringReader<'a> {\n         self.pos = self.next_pos;\n         let current_byte_offset = self.byte_offset(self.next_pos).to_usize();\n         if current_byte_offset < self.source_text.len() {\n-            let last_char = self.curr.unwrap();\n+            let last_char = self.ch.unwrap();\n             let ch = char_at(&self.source_text, current_byte_offset);\n             let byte_offset_diff = ch.len_utf8();\n             self.next_pos = self.next_pos + Pos::from_usize(byte_offset_diff);\n-            self.curr = Some(ch);\n+            self.ch = Some(ch);\n             self.col = self.col + CharPos(1);\n             if last_char == '\\n' {\n                 if self.save_new_lines {\n@@ -434,7 +434,7 @@ impl<'a> StringReader<'a> {\n                 self.filemap.record_multibyte_char(self.pos, byte_offset_diff);\n             }\n         } else {\n-            self.curr = None;\n+            self.ch = None;\n         }\n     }\n \n@@ -471,11 +471,11 @@ impl<'a> StringReader<'a> {\n \n     /// Eats <XID_start><XID_continue>*, if possible.\n     fn scan_optional_raw_name(&mut self) -> Option<ast::Name> {\n-        if !ident_start(self.curr) {\n+        if !ident_start(self.ch) {\n             return None;\n         }\n         let start = self.pos;\n-        while ident_continue(self.curr) {\n+        while ident_continue(self.ch) {\n             self.bump();\n         }\n \n@@ -488,29 +488,29 @@ impl<'a> StringReader<'a> {\n         })\n     }\n \n-    /// PRECONDITION: self.curr is not whitespace\n+    /// PRECONDITION: self.ch is not whitespace\n     /// Eats any kind of comment.\n     fn scan_comment(&mut self) -> Option<TokenAndSpan> {\n-        if let Some(c) = self.curr {\n+        if let Some(c) = self.ch {\n             if c.is_whitespace() {\n                 self.span_diagnostic.span_err(syntax_pos::mk_sp(self.pos, self.pos),\n                                               \"called consume_any_line_comment, but there \\\n                                                was whitespace\");\n             }\n         }\n \n-        if self.curr_is('/') {\n+        if self.ch_is('/') {\n             match self.nextch() {\n                 Some('/') => {\n                     self.bump();\n                     self.bump();\n \n                     // line comments starting with \"///\" or \"//!\" are doc-comments\n-                    let doc_comment = self.curr_is('/') || self.curr_is('!');\n+                    let doc_comment = self.ch_is('/') || self.ch_is('!');\n                     let start_bpos = self.pos - BytePos(2);\n \n                     while !self.is_eof() {\n-                        match self.curr.unwrap() {\n+                        match self.ch.unwrap() {\n                             '\\n' => break,\n                             '\\r' => {\n                                 if self.nextch_is('\\n') {\n@@ -555,7 +555,7 @@ impl<'a> StringReader<'a> {\n                 }\n                 _ => None,\n             }\n-        } else if self.curr_is('#') {\n+        } else if self.ch_is('#') {\n             if self.nextch_is('!') {\n \n                 // Parse an inner attribute.\n@@ -572,7 +572,7 @@ impl<'a> StringReader<'a> {\n                 if loc.line == 1 && loc.col == CharPos(0) {\n                     // FIXME: Add shebang \"token\", return it\n                     let start = self.pos;\n-                    while !self.curr_is('\\n') && !self.is_eof() {\n+                    while !self.ch_is('\\n') && !self.is_eof() {\n                         self.bump();\n                     }\n                     return Some(TokenAndSpan {\n@@ -590,7 +590,7 @@ impl<'a> StringReader<'a> {\n     /// If there is whitespace, shebang, or a comment, scan it. Otherwise,\n     /// return None.\n     fn scan_whitespace_or_comment(&mut self) -> Option<TokenAndSpan> {\n-        match self.curr.unwrap_or('\\0') {\n+        match self.ch.unwrap_or('\\0') {\n             // # to handle shebang at start of file -- this is the entry point\n             // for skipping over all \"junk\"\n             '/' | '#' => {\n@@ -600,7 +600,7 @@ impl<'a> StringReader<'a> {\n             },\n             c if is_pattern_whitespace(Some(c)) => {\n                 let start_bpos = self.pos;\n-                while is_pattern_whitespace(self.curr) {\n+                while is_pattern_whitespace(self.ch) {\n                     self.bump();\n                 }\n                 let c = Some(TokenAndSpan {\n@@ -617,7 +617,7 @@ impl<'a> StringReader<'a> {\n     /// Might return a sugared-doc-attr\n     fn scan_block_comment(&mut self) -> Option<TokenAndSpan> {\n         // block comments starting with \"/**\" or \"/*!\" are doc-comments\n-        let is_doc_comment = self.curr_is('*') || self.curr_is('!');\n+        let is_doc_comment = self.ch_is('*') || self.ch_is('!');\n         let start_bpos = self.pos - BytePos(2);\n \n         let mut level: isize = 1;\n@@ -632,7 +632,7 @@ impl<'a> StringReader<'a> {\n                 let last_bpos = self.pos;\n                 panic!(self.fatal_span_(start_bpos, last_bpos, msg));\n             }\n-            let n = self.curr.unwrap();\n+            let n = self.ch.unwrap();\n             match n {\n                 '/' if self.nextch_is('*') => {\n                     level += 1;\n@@ -682,7 +682,7 @@ impl<'a> StringReader<'a> {\n         assert!(real_radix <= scan_radix);\n         let mut len = 0;\n         loop {\n-            let c = self.curr;\n+            let c = self.ch;\n             if c == Some('_') {\n                 debug!(\"skipping a _\");\n                 self.bump();\n@@ -715,7 +715,7 @@ impl<'a> StringReader<'a> {\n         self.bump();\n \n         if c == '0' {\n-            match self.curr.unwrap_or('\\0') {\n+            match self.ch.unwrap_or('\\0') {\n                 'b' => {\n                     self.bump();\n                     base = 2;\n@@ -755,14 +755,14 @@ impl<'a> StringReader<'a> {\n         // might be a float, but don't be greedy if this is actually an\n         // integer literal followed by field/method access or a range pattern\n         // (`0..2` and `12.foo()`)\n-        if self.curr_is('.') && !self.nextch_is('.') &&\n+        if self.ch_is('.') && !self.nextch_is('.') &&\n            !self.nextch()\n                 .unwrap_or('\\0')\n                 .is_xid_start() {\n             // might have stuff after the ., and if it does, it needs to start\n             // with a number\n             self.bump();\n-            if self.curr.unwrap_or('\\0').is_digit(10) {\n+            if self.ch.unwrap_or('\\0').is_digit(10) {\n                 self.scan_digits(10, 10);\n                 self.scan_float_exponent();\n             }\n@@ -771,7 +771,7 @@ impl<'a> StringReader<'a> {\n             return token::Float(self.name_from(start_bpos));\n         } else {\n             // it might be a float if it has an exponent\n-            if self.curr_is('e') || self.curr_is('E') {\n+            if self.ch_is('e') || self.ch_is('E') {\n                 self.scan_float_exponent();\n                 let pos = self.pos;\n                 self.check_float_base(start_bpos, pos, base);\n@@ -797,15 +797,15 @@ impl<'a> StringReader<'a> {\n                                         last_bpos,\n                                         \"unterminated numeric character escape\"));\n             }\n-            if self.curr_is(delim) {\n+            if self.ch_is(delim) {\n                 let last_bpos = self.pos;\n                 self.err_span_(start_bpos,\n                                last_bpos,\n                                \"numeric character escape is too short\");\n                 valid = false;\n                 break;\n             }\n-            let c = self.curr.unwrap_or('\\x00');\n+            let c = self.ch.unwrap_or('\\x00');\n             accum_int *= 16;\n             accum_int += c.to_digit(16).unwrap_or_else(|| {\n                 self.err_span_char(self.pos,\n@@ -851,7 +851,7 @@ impl<'a> StringReader<'a> {\n         match first_source_char {\n             '\\\\' => {\n                 // '\\X' for some X must be a character constant:\n-                let escaped = self.curr;\n+                let escaped = self.ch;\n                 let escaped_pos = self.pos;\n                 self.bump();\n                 match escaped {\n@@ -861,7 +861,7 @@ impl<'a> StringReader<'a> {\n                             'n' | 'r' | 't' | '\\\\' | '\\'' | '\"' | '0' => true,\n                             'x' => self.scan_byte_escape(delim, !ascii_only),\n                             'u' => {\n-                                let valid = if self.curr_is('{') {\n+                                let valid = if self.ch_is('{') {\n                                     self.scan_unicode_escape(delim) && !ascii_only\n                                 } else {\n                                     let span = syntax_pos::mk_sp(start, self.pos);\n@@ -886,7 +886,7 @@ impl<'a> StringReader<'a> {\n                                 self.consume_whitespace();\n                                 true\n                             }\n-                            '\\r' if delim == '\"' && self.curr_is('\\n') => {\n+                            '\\r' if delim == '\"' && self.ch_is('\\n') => {\n                                 self.consume_whitespace();\n                                 true\n                             }\n@@ -932,7 +932,7 @@ impl<'a> StringReader<'a> {\n                 return false;\n             }\n             '\\r' => {\n-                if self.curr_is('\\n') {\n+                if self.ch_is('\\n') {\n                     self.bump();\n                     return true;\n                 } else {\n@@ -967,8 +967,8 @@ impl<'a> StringReader<'a> {\n         let mut accum_int = 0;\n         let mut valid = true;\n \n-        while !self.curr_is('}') && count <= 6 {\n-            let c = match self.curr {\n+        while !self.ch_is('}') && count <= 6 {\n+            let c = match self.ch {\n                 Some(c) => c,\n                 None => {\n                     panic!(self.fatal_span_(start_bpos,\n@@ -1015,9 +1015,9 @@ impl<'a> StringReader<'a> {\n \n     /// Scan over a float exponent.\n     fn scan_float_exponent(&mut self) {\n-        if self.curr_is('e') || self.curr_is('E') {\n+        if self.ch_is('e') || self.ch_is('E') {\n             self.bump();\n-            if self.curr_is('-') || self.curr_is('+') {\n+            if self.ch_is('-') || self.ch_is('+') {\n                 self.bump();\n             }\n             if self.scan_digits(10, 10) == 0 {\n@@ -1053,7 +1053,7 @@ impl<'a> StringReader<'a> {\n \n     fn binop(&mut self, op: token::BinOpToken) -> token::Token {\n         self.bump();\n-        if self.curr_is('=') {\n+        if self.ch_is('=') {\n             self.bump();\n             return token::BinOpEq(op);\n         } else {\n@@ -1064,7 +1064,7 @@ impl<'a> StringReader<'a> {\n     /// Return the next token from the string, advances the input past that\n     /// token, and updates the interner\n     fn next_token_inner(&mut self) -> Result<token::Token, ()> {\n-        let c = self.curr;\n+        let c = self.ch;\n         if ident_start(c) &&\n            match (c.unwrap(), self.nextch(), self.nextnextch()) {\n             // Note: r as in r\" or r#\" is part of a raw string literal,\n@@ -1079,7 +1079,7 @@ impl<'a> StringReader<'a> {\n             _ => true,\n         } {\n             let start = self.pos;\n-            while ident_continue(self.curr) {\n+            while ident_continue(self.ch) {\n                 self.bump();\n             }\n \n@@ -1112,9 +1112,9 @@ impl<'a> StringReader<'a> {\n             }\n             '.' => {\n                 self.bump();\n-                return if self.curr_is('.') {\n+                return if self.ch_is('.') {\n                     self.bump();\n-                    if self.curr_is('.') {\n+                    if self.ch_is('.') {\n                         self.bump();\n                         Ok(token::DotDotDot)\n                     } else {\n@@ -1166,7 +1166,7 @@ impl<'a> StringReader<'a> {\n             }\n             ':' => {\n                 self.bump();\n-                if self.curr_is(':') {\n+                if self.ch_is(':') {\n                     self.bump();\n                     return Ok(token::ModSep);\n                 } else {\n@@ -1182,10 +1182,10 @@ impl<'a> StringReader<'a> {\n             // Multi-byte tokens.\n             '=' => {\n                 self.bump();\n-                if self.curr_is('=') {\n+                if self.ch_is('=') {\n                     self.bump();\n                     return Ok(token::EqEq);\n-                } else if self.curr_is('>') {\n+                } else if self.ch_is('>') {\n                     self.bump();\n                     return Ok(token::FatArrow);\n                 } else {\n@@ -1194,7 +1194,7 @@ impl<'a> StringReader<'a> {\n             }\n             '!' => {\n                 self.bump();\n-                if self.curr_is('=') {\n+                if self.ch_is('=') {\n                     self.bump();\n                     return Ok(token::Ne);\n                 } else {\n@@ -1203,7 +1203,7 @@ impl<'a> StringReader<'a> {\n             }\n             '<' => {\n                 self.bump();\n-                match self.curr.unwrap_or('\\x00') {\n+                match self.ch.unwrap_or('\\x00') {\n                     '=' => {\n                         self.bump();\n                         return Ok(token::Le);\n@@ -1213,7 +1213,7 @@ impl<'a> StringReader<'a> {\n                     }\n                     '-' => {\n                         self.bump();\n-                        match self.curr.unwrap_or('\\x00') {\n+                        match self.ch.unwrap_or('\\x00') {\n                             _ => {\n                                 return Ok(token::LArrow);\n                             }\n@@ -1226,7 +1226,7 @@ impl<'a> StringReader<'a> {\n             }\n             '>' => {\n                 self.bump();\n-                match self.curr.unwrap_or('\\x00') {\n+                match self.ch.unwrap_or('\\x00') {\n                     '=' => {\n                         self.bump();\n                         return Ok(token::Ge);\n@@ -1246,18 +1246,18 @@ impl<'a> StringReader<'a> {\n                 let start = self.pos;\n \n                 // the eof will be picked up by the final `'` check below\n-                let c2 = self.curr.unwrap_or('\\x00');\n+                let c2 = self.ch.unwrap_or('\\x00');\n                 self.bump();\n \n                 // If the character is an ident start not followed by another single\n                 // quote, then this is a lifetime name:\n-                if ident_start(Some(c2)) && !self.curr_is('\\'') {\n-                    while ident_continue(self.curr) {\n+                if ident_start(Some(c2)) && !self.ch_is('\\'') {\n+                    while ident_continue(self.ch) {\n                         self.bump();\n                     }\n                     // lifetimes shouldn't end with a single quote\n                     // if we find one, then this is an invalid character literal\n-                    if self.curr_is('\\'') {\n+                    if self.ch_is('\\'') {\n                         panic!(self.fatal_span_verbose(\n                                start_with_quote, self.next_pos,\n                                String::from(\"character literal may only contain one codepoint\")));\n@@ -1292,7 +1292,7 @@ impl<'a> StringReader<'a> {\n                                                    false,\n                                                    '\\'');\n \n-                if !self.curr_is('\\'') {\n+                if !self.ch_is('\\'') {\n                     panic!(self.fatal_span_verbose(\n                            start_with_quote, self.pos,\n                            String::from(\"character literal may only contain one codepoint\")));\n@@ -1303,13 +1303,13 @@ impl<'a> StringReader<'a> {\n                 } else {\n                     token::intern(\"0\")\n                 };\n-                self.bump(); // advance curr past token\n+                self.bump(); // advance ch past token\n                 let suffix = self.scan_optional_raw_name();\n                 return Ok(token::Literal(token::Char(id), suffix));\n             }\n             'b' => {\n                 self.bump();\n-                let lit = match self.curr {\n+                let lit = match self.ch {\n                     Some('\\'') => self.scan_byte(),\n                     Some('\"') => self.scan_byte_string(),\n                     Some('r') => self.scan_raw_byte_string(),\n@@ -1322,7 +1322,7 @@ impl<'a> StringReader<'a> {\n                 let start_bpos = self.pos;\n                 let mut valid = true;\n                 self.bump();\n-                while !self.curr_is('\"') {\n+                while !self.ch_is('\"') {\n                     if self.is_eof() {\n                         let last_bpos = self.pos;\n                         panic!(self.fatal_span_(start_bpos,\n@@ -1331,7 +1331,7 @@ impl<'a> StringReader<'a> {\n                     }\n \n                     let ch_start = self.pos;\n-                    let ch = self.curr.unwrap();\n+                    let ch = self.ch.unwrap();\n                     self.bump();\n                     valid &= self.scan_char_or_byte(ch_start,\n                                                     ch,\n@@ -1353,17 +1353,17 @@ impl<'a> StringReader<'a> {\n                 let start_bpos = self.pos;\n                 self.bump();\n                 let mut hash_count = 0;\n-                while self.curr_is('#') {\n+                while self.ch_is('#') {\n                     self.bump();\n                     hash_count += 1;\n                 }\n \n                 if self.is_eof() {\n                     let last_bpos = self.pos;\n                     panic!(self.fatal_span_(start_bpos, last_bpos, \"unterminated raw string\"));\n-                } else if !self.curr_is('\"') {\n+                } else if !self.ch_is('\"') {\n                     let last_bpos = self.pos;\n-                    let curr_char = self.curr.unwrap();\n+                    let curr_char = self.ch.unwrap();\n                     panic!(self.fatal_span_char(start_bpos,\n                                                 last_bpos,\n                                                 \"found invalid character; only `#` is allowed \\\n@@ -1379,19 +1379,19 @@ impl<'a> StringReader<'a> {\n                         let last_bpos = self.pos;\n                         panic!(self.fatal_span_(start_bpos, last_bpos, \"unterminated raw string\"));\n                     }\n-                    // if self.curr_is('\"') {\n+                    // if self.ch_is('\"') {\n                     // content_end_bpos = self.pos;\n                     // for _ in 0..hash_count {\n                     // self.bump();\n-                    // if !self.curr_is('#') {\n+                    // if !self.ch_is('#') {\n                     // continue 'outer;\n-                    let c = self.curr.unwrap();\n+                    let c = self.ch.unwrap();\n                     match c {\n                         '\"' => {\n                             content_end_bpos = self.pos;\n                             for _ in 0..hash_count {\n                                 self.bump();\n-                                if !self.curr_is('#') {\n+                                if !self.ch_is('#') {\n                                     continue 'outer;\n                                 }\n                             }\n@@ -1480,18 +1480,18 @@ impl<'a> StringReader<'a> {\n     }\n \n     fn consume_whitespace(&mut self) {\n-        while is_pattern_whitespace(self.curr) && !self.is_eof() {\n+        while is_pattern_whitespace(self.ch) && !self.is_eof() {\n             self.bump();\n         }\n     }\n \n     fn read_to_eol(&mut self) -> String {\n         let mut val = String::new();\n-        while !self.curr_is('\\n') && !self.is_eof() {\n-            val.push(self.curr.unwrap());\n+        while !self.ch_is('\\n') && !self.is_eof() {\n+            val.push(self.ch.unwrap());\n             self.bump();\n         }\n-        if self.curr_is('\\n') {\n+        if self.ch_is('\\n') {\n             self.bump();\n         }\n         return val;\n@@ -1505,31 +1505,31 @@ impl<'a> StringReader<'a> {\n     }\n \n     fn consume_non_eol_whitespace(&mut self) {\n-        while is_pattern_whitespace(self.curr) && !self.curr_is('\\n') && !self.is_eof() {\n+        while is_pattern_whitespace(self.ch) && !self.ch_is('\\n') && !self.is_eof() {\n             self.bump();\n         }\n     }\n \n     fn peeking_at_comment(&self) -> bool {\n-        (self.curr_is('/') && self.nextch_is('/')) || (self.curr_is('/') && self.nextch_is('*')) ||\n+        (self.ch_is('/') && self.nextch_is('/')) || (self.ch_is('/') && self.nextch_is('*')) ||\n         // consider shebangs comments, but not inner attributes\n-        (self.curr_is('#') && self.nextch_is('!') && !self.nextnextch_is('['))\n+        (self.ch_is('#') && self.nextch_is('!') && !self.nextnextch_is('['))\n     }\n \n     fn scan_byte(&mut self) -> token::Lit {\n         self.bump();\n         let start = self.pos;\n \n         // the eof will be picked up by the final `'` check below\n-        let c2 = self.curr.unwrap_or('\\x00');\n+        let c2 = self.ch.unwrap_or('\\x00');\n         self.bump();\n \n         let valid = self.scan_char_or_byte(start,\n                                            c2,\n                                            // ascii_only =\n                                            true,\n                                            '\\'');\n-        if !self.curr_is('\\'') {\n+        if !self.ch_is('\\'') {\n             // Byte offsetting here is okay because the\n             // character before position `start` are an\n             // ascii single quote and ascii 'b'.\n@@ -1544,7 +1544,7 @@ impl<'a> StringReader<'a> {\n         } else {\n             token::intern(\"?\")\n         };\n-        self.bump(); // advance curr past token\n+        self.bump(); // advance ch past token\n         return token::Byte(id);\n     }\n \n@@ -1557,14 +1557,14 @@ impl<'a> StringReader<'a> {\n         let start = self.pos;\n         let mut valid = true;\n \n-        while !self.curr_is('\"') {\n+        while !self.ch_is('\"') {\n             if self.is_eof() {\n                 let pos = self.pos;\n                 panic!(self.fatal_span_(start, pos, \"unterminated double quote byte string\"));\n             }\n \n             let ch_start = self.pos;\n-            let ch = self.curr.unwrap();\n+            let ch = self.ch.unwrap();\n             self.bump();\n             valid &= self.scan_char_or_byte(ch_start,\n                                             ch,\n@@ -1585,17 +1585,17 @@ impl<'a> StringReader<'a> {\n         let start_bpos = self.pos;\n         self.bump();\n         let mut hash_count = 0;\n-        while self.curr_is('#') {\n+        while self.ch_is('#') {\n             self.bump();\n             hash_count += 1;\n         }\n \n         if self.is_eof() {\n             let pos = self.pos;\n             panic!(self.fatal_span_(start_bpos, pos, \"unterminated raw string\"));\n-        } else if !self.curr_is('\"') {\n+        } else if !self.ch_is('\"') {\n             let pos = self.pos;\n-            let ch = self.curr.unwrap();\n+            let ch = self.ch.unwrap();\n             panic!(self.fatal_span_char(start_bpos,\n                                         pos,\n                                         \"found invalid character; only `#` is allowed in raw \\\n@@ -1606,7 +1606,7 @@ impl<'a> StringReader<'a> {\n         let content_start_bpos = self.pos;\n         let mut content_end_bpos;\n         'outer: loop {\n-            match self.curr {\n+            match self.ch {\n                 None => {\n                     let pos = self.pos;\n                     panic!(self.fatal_span_(start_bpos, pos, \"unterminated raw string\"))\n@@ -1615,7 +1615,7 @@ impl<'a> StringReader<'a> {\n                     content_end_bpos = self.pos;\n                     for _ in 0..hash_count {\n                         self.bump();\n-                        if !self.curr_is('#') {\n+                        if !self.ch_is('#') {\n                             continue 'outer;\n                         }\n                     }"}]}