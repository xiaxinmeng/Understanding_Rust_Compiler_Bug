{"sha": "39f8289e38b6fc289395c8c83b7d60a611c787f5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM5ZjgyODllMzhiNmZjMjg5Mzk1YzhjODNiN2Q2MGE2MTFjNzg3ZjU=", "commit": {"author": {"name": "Yuki Okushi", "email": "huyuumi.dev@gmail.com", "date": "2020-10-23T09:26:26Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-10-23T09:26:26Z"}, "message": "Rollup merge of #77969 - ryan-scott-dev:bigo-notation-consistency, r=m-ou-se\n\nDoc formating consistency between slice sort and sort_unstable, and big O notation consistency\n\nUpdated documentation for slice sorting methods to be consistent between stable and unstable versions, which just ended up being minor formatting differences.\n\nI also went through and updated any doc comments with big O notation to be consistent with #74010 by italicizing them rather than having them in a code block.", "tree": {"sha": "044b24ac74b7192406e30e4502c8299df459ccde", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/044b24ac74b7192406e30e4502c8299df459ccde"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/39f8289e38b6fc289395c8c83b7d60a611c787f5", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfkqHDCRBK7hj4Ov3rIwAAdHIIAE/QuCOYHedJ18kPgBSQYCMs\ne88+mltmh9nx/1Xl7SzngVJnJnDITB/KjwjX1ERVjgL7vJch5+13gah0RvUNMCDM\nMCLHGzvqPITT+cGf+9P8iU9r88Noy53Ujc7ADZS5f56ehAQeIpBDBWqJpaoGxfoQ\n7pQ7vKhIg87J28Q8VW+qcI7o7cUrrF+mQzh+PS/lqtUe4+pTw/kHOUer7E57ZD7d\nwqVQh5S84m3GrGruPyaCfN4kcNbIxrar4PoUFgUEAvBQ/tbmnekz5WKvXdnm5Txy\nm5IW08cPzkkC/szy7eKzJ4pA3m03lIzqOl5/vkoMaH/Wd/fP8iKgCKhBqivYRgg=\n=K5sf\n-----END PGP SIGNATURE-----\n", "payload": "tree 044b24ac74b7192406e30e4502c8299df459ccde\nparent 47042594cb9dee4801c9fc36d378617b8d0c67ad\nparent 8446d949f1d53b2c7ee4155f8fbf3d1390e3f203\nauthor Yuki Okushi <huyuumi.dev@gmail.com> 1603445186 +0900\ncommitter GitHub <noreply@github.com> 1603445186 +0900\n\nRollup merge of #77969 - ryan-scott-dev:bigo-notation-consistency, r=m-ou-se\n\nDoc formating consistency between slice sort and sort_unstable, and big O notation consistency\n\nUpdated documentation for slice sorting methods to be consistent between stable and unstable versions, which just ended up being minor formatting differences.\n\nI also went through and updated any doc comments with big O notation to be consistent with #74010 by italicizing them rather than having them in a code block.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/39f8289e38b6fc289395c8c83b7d60a611c787f5", "html_url": "https://github.com/rust-lang/rust/commit/39f8289e38b6fc289395c8c83b7d60a611c787f5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/39f8289e38b6fc289395c8c83b7d60a611c787f5/comments", "author": {"login": "JohnTitor", "id": 25030997, "node_id": "MDQ6VXNlcjI1MDMwOTk3", "avatar_url": "https://avatars.githubusercontent.com/u/25030997?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JohnTitor", "html_url": "https://github.com/JohnTitor", "followers_url": "https://api.github.com/users/JohnTitor/followers", "following_url": "https://api.github.com/users/JohnTitor/following{/other_user}", "gists_url": "https://api.github.com/users/JohnTitor/gists{/gist_id}", "starred_url": "https://api.github.com/users/JohnTitor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JohnTitor/subscriptions", "organizations_url": "https://api.github.com/users/JohnTitor/orgs", "repos_url": "https://api.github.com/users/JohnTitor/repos", "events_url": "https://api.github.com/users/JohnTitor/events{/privacy}", "received_events_url": "https://api.github.com/users/JohnTitor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "47042594cb9dee4801c9fc36d378617b8d0c67ad", "url": "https://api.github.com/repos/rust-lang/rust/commits/47042594cb9dee4801c9fc36d378617b8d0c67ad", "html_url": "https://github.com/rust-lang/rust/commit/47042594cb9dee4801c9fc36d378617b8d0c67ad"}, {"sha": "8446d949f1d53b2c7ee4155f8fbf3d1390e3f203", "url": "https://api.github.com/repos/rust-lang/rust/commits/8446d949f1d53b2c7ee4155f8fbf3d1390e3f203", "html_url": "https://github.com/rust-lang/rust/commit/8446d949f1d53b2c7ee4155f8fbf3d1390e3f203"}], "stats": {"total": 36, "additions": 18, "deletions": 18}, "files": [{"sha": "7c834f034c1f157d1035caba65bfe49b14df201d", "filename": "library/alloc/src/raw_vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/39f8289e38b6fc289395c8c83b7d60a611c787f5/library%2Falloc%2Fsrc%2Fraw_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39f8289e38b6fc289395c8c83b7d60a611c787f5/library%2Falloc%2Fsrc%2Fraw_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fraw_vec.rs?ref=39f8289e38b6fc289395c8c83b7d60a611c787f5", "patch": "@@ -259,7 +259,7 @@ impl<T, A: AllocRef> RawVec<T, A> {\n     /// Ensures that the buffer contains at least enough space to hold `len +\n     /// additional` elements. If it doesn't already have enough capacity, will\n     /// reallocate enough space plus comfortable slack space to get amortized\n-    /// `O(1)` behavior. Will limit this behavior if it would needlessly cause\n+    /// *O*(1) behavior. Will limit this behavior if it would needlessly cause\n     /// itself to panic.\n     ///\n     /// If `len` exceeds `self.capacity()`, this may fail to actually allocate"}, {"sha": "3db66964941c3dbd679115f5d6d259ee242aa9ec", "filename": "library/alloc/src/slice.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/39f8289e38b6fc289395c8c83b7d60a611c787f5/library%2Falloc%2Fsrc%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39f8289e38b6fc289395c8c83b7d60a611c787f5/library%2Falloc%2Fsrc%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fslice.rs?ref=39f8289e38b6fc289395c8c83b7d60a611c787f5", "patch": "@@ -167,7 +167,7 @@ mod hack {\n impl<T> [T] {\n     /// Sorts the slice.\n     ///\n-    /// This sort is stable (i.e., does not reorder equal elements) and `O(n * log(n))` worst-case.\n+    /// This sort is stable (i.e., does not reorder equal elements) and *O*(*n* \\* log(*n*)) worst-case.\n     ///\n     /// When applicable, unstable sorting is preferred because it is generally faster than stable\n     /// sorting and it doesn't allocate auxiliary memory.\n@@ -202,7 +202,7 @@ impl<T> [T] {\n \n     /// Sorts the slice with a comparator function.\n     ///\n-    /// This sort is stable (i.e., does not reorder equal elements) and `O(n * log(n))` worst-case.\n+    /// This sort is stable (i.e., does not reorder equal elements) and *O*(*n* \\* log(*n*)) worst-case.\n     ///\n     /// The comparator function must define a total ordering for the elements in the slice. If\n     /// the ordering is not total, the order of the elements is unspecified. An order is a\n@@ -256,8 +256,8 @@ impl<T> [T] {\n \n     /// Sorts the slice with a key extraction function.\n     ///\n-    /// This sort is stable (i.e., does not reorder equal elements) and `O(m * n * log(n))`\n-    /// worst-case, where the key function is `O(m)`.\n+    /// This sort is stable (i.e., does not reorder equal elements) and *O*(*m* \\* *n* \\* log(*n*))\n+    /// worst-case, where the key function is *O*(*m*).\n     ///\n     /// For expensive key functions (e.g. functions that are not simple property accesses or\n     /// basic operations), [`sort_by_cached_key`](#method.sort_by_cached_key) is likely to be\n@@ -299,8 +299,8 @@ impl<T> [T] {\n     ///\n     /// During sorting, the key function is called only once per element.\n     ///\n-    /// This sort is stable (i.e., does not reorder equal elements) and `O(m * n + n * log(n))`\n-    /// worst-case, where the key function is `O(m)`.\n+    /// This sort is stable (i.e., does not reorder equal elements) and *O*(*m* \\* *n* + *n* \\* log(*n*))\n+    /// worst-case, where the key function is *O*(*m*).\n     ///\n     /// For simple key functions (e.g., functions that are property accesses or\n     /// basic operations), [`sort_by_key`](#method.sort_by_key) is likely to be\n@@ -944,7 +944,7 @@ where\n /// 1. for every `i` in `1..runs.len()`: `runs[i - 1].len > runs[i].len`\n /// 2. for every `i` in `2..runs.len()`: `runs[i - 2].len > runs[i - 1].len + runs[i].len`\n ///\n-/// The invariants ensure that the total running time is `O(n * log(n))` worst-case.\n+/// The invariants ensure that the total running time is *O*(*n* \\* log(*n*)) worst-case.\n fn merge_sort<T, F>(v: &mut [T], mut is_less: F)\n where\n     F: FnMut(&T, &T) -> bool,"}, {"sha": "5b3604db563c6092549d6f654c73dda99122bda0", "filename": "library/alloc/src/vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/39f8289e38b6fc289395c8c83b7d60a611c787f5/library%2Falloc%2Fsrc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39f8289e38b6fc289395c8c83b7d60a611c787f5/library%2Falloc%2Fsrc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fvec.rs?ref=39f8289e38b6fc289395c8c83b7d60a611c787f5", "patch": "@@ -259,7 +259,7 @@ use crate::raw_vec::RawVec;\n /// `Vec` does not guarantee any particular growth strategy when reallocating\n /// when full, nor when [`reserve`] is called. The current strategy is basic\n /// and it may prove desirable to use a non-constant growth factor. Whatever\n-/// strategy is used will of course guarantee `O(1)` amortized [`push`].\n+/// strategy is used will of course guarantee *O*(1) amortized [`push`].\n ///\n /// `vec![x; n]`, `vec![a, b, c, d]`, and\n /// [`Vec::with_capacity(n)`][`Vec::with_capacity`], will all produce a `Vec`"}, {"sha": "376ad321f64a3f2f99906979421e870dba7cd3d0", "filename": "library/core/src/slice/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/39f8289e38b6fc289395c8c83b7d60a611c787f5/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39f8289e38b6fc289395c8c83b7d60a611c787f5/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs?ref=39f8289e38b6fc289395c8c83b7d60a611c787f5", "patch": "@@ -1945,10 +1945,10 @@ impl<T> [T] {\n     ///\n     /// The comparator function must define a total ordering for the elements in the slice. If\n     /// the ordering is not total, the order of the elements is unspecified. An order is a\n-    /// total order if it is (for all a, b and c):\n+    /// total order if it is (for all `a`, `b` and `c`):\n     ///\n-    /// * total and antisymmetric: exactly one of a < b, a == b or a > b is true; and\n-    /// * transitive, a < b and b < c implies a < c. The same must hold for both == and >.\n+    /// * total and antisymmetric: exactly one of `a < b`, `a == b` or `a > b` is true, and\n+    /// * transitive, `a < b` and `b < c` implies `a < c`. The same must hold for both `==` and `>`.\n     ///\n     /// For example, while [`f64`] doesn't implement [`Ord`] because `NaN != NaN`, we can use\n     /// `partial_cmp` as our sort function when we know the slice doesn't contain a `NaN`."}, {"sha": "af1ce007e8b7c826ab8e827f67151b6a2dfda532", "filename": "library/core/src/str/traits.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/39f8289e38b6fc289395c8c83b7d60a611c787f5/library%2Fcore%2Fsrc%2Fstr%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39f8289e38b6fc289395c8c83b7d60a611c787f5/library%2Fcore%2Fsrc%2Fstr%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fstr%2Ftraits.rs?ref=39f8289e38b6fc289395c8c83b7d60a611c787f5", "patch": "@@ -89,7 +89,7 @@ fn str_index_overflow_fail() -> ! {\n /// self`. Equivalent to `&self[0 .. len]` or `&mut self[0 .. len]`. Unlike\n /// other indexing operations, this can never panic.\n ///\n-/// This operation is `O(1)`.\n+/// This operation is *O*(1).\n ///\n /// Prior to 1.20.0, these indexing operations were still supported by\n /// direct implementation of `Index` and `IndexMut`.\n@@ -130,7 +130,7 @@ unsafe impl SliceIndex<str> for ops::RangeFull {\n /// Returns a slice of the given string from the byte range\n /// [`begin`, `end`).\n ///\n-/// This operation is `O(1)`.\n+/// This operation is *O*(1).\n ///\n /// Prior to 1.20.0, these indexing operations were still supported by\n /// direct implementation of `Index` and `IndexMut`.\n@@ -237,7 +237,7 @@ unsafe impl SliceIndex<str> for ops::Range<usize> {\n /// Returns a slice of the given string from the byte range [`0`, `end`).\n /// Equivalent to `&self[0 .. end]` or `&mut self[0 .. end]`.\n ///\n-/// This operation is `O(1)`.\n+/// This operation is *O*(1).\n ///\n /// Prior to 1.20.0, these indexing operations were still supported by\n /// direct implementation of `Index` and `IndexMut`.\n@@ -308,7 +308,7 @@ unsafe impl SliceIndex<str> for ops::RangeTo<usize> {\n /// `len`). Equivalent to `&self[begin .. len]` or `&mut self[begin ..\n /// len]`.\n ///\n-/// This operation is `O(1)`.\n+/// This operation is *O*(1).\n ///\n /// Prior to 1.20.0, these indexing operations were still supported by\n /// direct implementation of `Index` and `IndexMut`.\n@@ -385,7 +385,7 @@ unsafe impl SliceIndex<str> for ops::RangeFrom<usize> {\n /// self[begin .. end + 1]`, except if `end` has the maximum value for\n /// `usize`.\n ///\n-/// This operation is `O(1)`.\n+/// This operation is *O*(1).\n ///\n /// # Panics\n ///\n@@ -441,7 +441,7 @@ unsafe impl SliceIndex<str> for ops::RangeInclusive<usize> {\n /// Equivalent to `&self [0 .. end + 1]`, except if `end` has the maximum\n /// value for `usize`.\n ///\n-/// This operation is `O(1)`.\n+/// This operation is *O*(1).\n ///\n /// # Panics\n ///"}]}