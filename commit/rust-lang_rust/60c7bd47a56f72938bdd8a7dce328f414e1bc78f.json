{"sha": "60c7bd47a56f72938bdd8a7dce328f414e1bc78f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYwYzdiZDQ3YTU2ZjcyOTM4YmRkOGE3ZGNlMzI4ZjQxNGUxYmM3OGY=", "commit": {"author": {"name": "cgm616", "email": "cgm616@me.com", "date": "2017-10-21T11:53:57Z"}, "committer": {"name": "cgm616", "email": "cgm616@me.com", "date": "2017-10-21T11:53:57Z"}, "message": "Prevent should_implement_trait on private method\n\nThis should close #2159.", "tree": {"sha": "05c60a603f720aa6cb6214eb1ec0cc907c4f309c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/05c60a603f720aa6cb6214eb1ec0cc907c4f309c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/60c7bd47a56f72938bdd8a7dce328f414e1bc78f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/60c7bd47a56f72938bdd8a7dce328f414e1bc78f", "html_url": "https://github.com/rust-lang/rust/commit/60c7bd47a56f72938bdd8a7dce328f414e1bc78f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/60c7bd47a56f72938bdd8a7dce328f414e1bc78f/comments", "author": {"login": "cgm616", "id": 2502394, "node_id": "MDQ6VXNlcjI1MDIzOTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/2502394?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cgm616", "html_url": "https://github.com/cgm616", "followers_url": "https://api.github.com/users/cgm616/followers", "following_url": "https://api.github.com/users/cgm616/following{/other_user}", "gists_url": "https://api.github.com/users/cgm616/gists{/gist_id}", "starred_url": "https://api.github.com/users/cgm616/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cgm616/subscriptions", "organizations_url": "https://api.github.com/users/cgm616/orgs", "repos_url": "https://api.github.com/users/cgm616/repos", "events_url": "https://api.github.com/users/cgm616/events{/privacy}", "received_events_url": "https://api.github.com/users/cgm616/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cgm616", "id": 2502394, "node_id": "MDQ6VXNlcjI1MDIzOTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/2502394?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cgm616", "html_url": "https://github.com/cgm616", "followers_url": "https://api.github.com/users/cgm616/followers", "following_url": "https://api.github.com/users/cgm616/following{/other_user}", "gists_url": "https://api.github.com/users/cgm616/gists{/gist_id}", "starred_url": "https://api.github.com/users/cgm616/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cgm616/subscriptions", "organizations_url": "https://api.github.com/users/cgm616/orgs", "repos_url": "https://api.github.com/users/cgm616/repos", "events_url": "https://api.github.com/users/cgm616/events{/privacy}", "received_events_url": "https://api.github.com/users/cgm616/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0e489f322155113fe911352895a8fee68a9751d7", "url": "https://api.github.com/repos/rust-lang/rust/commits/0e489f322155113fe911352895a8fee68a9751d7", "html_url": "https://github.com/rust-lang/rust/commit/0e489f322155113fe911352895a8fee68a9751d7"}], "stats": {"total": 490, "additions": 271, "deletions": 219}, "files": [{"sha": "54523841b096e091d7bbf81af298aa4bb5894e3a", "filename": "clippy_lints/src/methods.rs", "status": "modified", "additions": 93, "deletions": 50, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/60c7bd47a56f72938bdd8a7dce328f414e1bc78f/clippy_lints%2Fsrc%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60c7bd47a56f72938bdd8a7dce328f414e1bc78f/clippy_lints%2Fsrc%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods.rs?ref=60c7bd47a56f72938bdd8a7dce328f414e1bc78f", "patch": "@@ -335,7 +335,8 @@ declare_lint! {\n /// the corresponding trait instead.\n ///\n /// **Why is this bad?**: Calling '.clone()' on an Rc, Arc, or Weak\n-/// can obscure the fact that only the pointer is being cloned, not the underlying\n+/// can obscure the fact that only the pointer is being cloned, not the\n+/// underlying\n /// data.\n ///\n /// **Example:**\n@@ -714,15 +715,18 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n             let Some(first_arg) = iter_input_pats(&sig.decl, cx.tcx.hir.body(id)).next(),\n             let hir::ItemImpl(_, _, _, _, None, ref self_ty, _) = item.node,\n         ], {\n-            // check missing trait implementations\n-            for &(method_name, n_args, self_kind, out_type, trait_name) in &TRAIT_METHODS {\n-                if name == method_name &&\n-                   sig.decl.inputs.len() == n_args &&\n-                   out_type.matches(&sig.decl.output) &&\n-                   self_kind.matches(first_arg_ty, first_arg, self_ty, false, &sig.generics) {\n-                    span_lint(cx, SHOULD_IMPLEMENT_TRAIT, implitem.span, &format!(\n-                        \"defining a method called `{}` on this type; consider implementing \\\n-                         the `{}` trait or choosing a less ambiguous name\", name, trait_name));\n+            if implitem.vis == hir::Visibility::Public ||\n+            implitem.vis.is_pub_restricted() {\n+                 // check missing trait implementations\n+                for &(method_name, n_args, self_kind, out_type, trait_name) in &TRAIT_METHODS {\n+                    if name == method_name &&\n+                    sig.decl.inputs.len() == n_args &&\n+                    out_type.matches(&sig.decl.output) &&\n+                    self_kind.matches(first_arg_ty, first_arg, self_ty, false, &sig.generics) {\n+                        span_lint(cx, SHOULD_IMPLEMENT_TRAIT, implitem.span, &format!(\n+                            \"defining a method called `{}` on this type; consider implementing \\\n+                            the `{}` trait or choosing a less ambiguous name\", name, trait_name));\n+                    }\n                 }\n             }\n \n@@ -941,12 +945,8 @@ fn lint_clone_on_ref_ptr(cx: &LateContext, expr: &hir::Expr, arg: &hir::Expr) {\n         expr.span,\n         \"using '.clone()' on a ref-counted pointer\",\n         \"try this\",\n-        format!(\"{}::clone(&{})\",\n-            caller_type,\n-            snippet(cx, arg.span, \"_\")\n-        )\n+        format!(\"{}::clone(&{})\", caller_type, snippet(cx, arg.span, \"_\")),\n     );\n-\n }\n \n \n@@ -1004,8 +1004,8 @@ fn lint_cstring_as_ptr(cx: &LateContext, expr: &hir::Expr, new: &hir::Expr, unwr\n }\n \n fn lint_iter_cloned_collect(cx: &LateContext, expr: &hir::Expr, iter_args: &[hir::Expr]) {\n-    if match_type(cx, cx.tables.expr_ty(expr), &paths::VEC) &&\n-        derefs_to_slice(cx, &iter_args[0], cx.tables.expr_ty(&iter_args[0])).is_some()\n+    if match_type(cx, cx.tables.expr_ty(expr), &paths::VEC)\n+        && derefs_to_slice(cx, &iter_args[0], cx.tables.expr_ty(&iter_args[0])).is_some()\n     {\n         span_lint(\n             cx,\n@@ -1180,8 +1180,16 @@ fn lint_map_unwrap_or(cx: &LateContext, expr: &hir::Expr, map_args: &[hir::Expr]\n         // lint message\n         // comparing the snippet from source to raw text (\"None\") below is safe\n         // because we already have checked the type.\n-        let arg = if unwrap_snippet == \"None\" { \"None\" } else { \"a\" };\n-        let suggest = if unwrap_snippet == \"None\" { \"and_then(f)\" } else { \"map_or(a, f)\" };\n+        let arg = if unwrap_snippet == \"None\" {\n+            \"None\"\n+        } else {\n+            \"a\"\n+        };\n+        let suggest = if unwrap_snippet == \"None\" {\n+            \"and_then(f)\"\n+        } else {\n+            \"map_or(a, f)\"\n+        };\n         let msg = &format!(\n             \"called `map(f).unwrap_or({})` on an Option value. \\\n              This can be done more directly by calling `{}` instead\",\n@@ -1212,7 +1220,12 @@ fn lint_map_unwrap_or(cx: &LateContext, expr: &hir::Expr, map_args: &[hir::Expr]\n }\n \n /// lint use of `map().unwrap_or_else()` for `Option`s\n-fn lint_map_unwrap_or_else<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx hir::Expr, map_args: &'tcx [hir::Expr], unwrap_args: &'tcx [hir::Expr]) {\n+fn lint_map_unwrap_or_else<'a, 'tcx>(\n+    cx: &LateContext<'a, 'tcx>,\n+    expr: &'tcx hir::Expr,\n+    map_args: &'tcx [hir::Expr],\n+    unwrap_args: &'tcx [hir::Expr],\n+) {\n     // lint if the caller of `map()` is an `Option`\n     if match_type(cx, cx.tables.expr_ty(&map_args[0]), &paths::OPTION) {\n         // lint message\n@@ -1246,7 +1259,6 @@ fn lint_map_unwrap_or_else<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx hir\n \n /// lint use of `_.map_or(None, _)` for `Option`s\n fn lint_map_or_none<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx hir::Expr, map_or_args: &'tcx [hir::Expr]) {\n-\n     if match_type(cx, cx.tables.expr_ty(&map_or_args[0]), &paths::OPTION) {\n         // check if the first non-self argument to map_or() is None\n         let map_or_arg_is_none = if let hir::Expr_::ExprPath(ref qpath) = map_or_args[1].node {\n@@ -1262,13 +1274,9 @@ fn lint_map_or_none<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx hir::Expr,\n             let map_or_self_snippet = snippet(cx, map_or_args[0].span, \"..\");\n             let map_or_func_snippet = snippet(cx, map_or_args[2].span, \"..\");\n             let hint = format!(\"{0}.and_then({1})\", map_or_self_snippet, map_or_func_snippet);\n-            span_lint_and_then(\n-                cx,\n-                OPTION_MAP_OR_NONE,\n-                expr.span,\n-                msg,\n-                |db| { db.span_suggestion(expr.span, \"try using and_then instead\", hint); },\n-            );\n+            span_lint_and_then(cx, OPTION_MAP_OR_NONE, expr.span, msg, |db| {\n+                db.span_suggestion(expr.span, \"try using and_then instead\", hint);\n+            });\n         }\n     }\n }\n@@ -1297,7 +1305,12 @@ fn lint_filter_next<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx hir::Expr,\n }\n \n /// lint use of `filter().map()` for `Iterators`\n-fn lint_filter_map<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx hir::Expr, _filter_args: &'tcx [hir::Expr], _map_args: &'tcx [hir::Expr]) {\n+fn lint_filter_map<'a, 'tcx>(\n+    cx: &LateContext<'a, 'tcx>,\n+    expr: &'tcx hir::Expr,\n+    _filter_args: &'tcx [hir::Expr],\n+    _map_args: &'tcx [hir::Expr],\n+) {\n     // lint if caller of `.filter().map()` is an Iterator\n     if match_trait_method(cx, expr, &paths::ITERATOR) {\n         let msg = \"called `filter(p).map(q)` on an `Iterator`. \\\n@@ -1307,7 +1320,12 @@ fn lint_filter_map<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx hir::Expr,\n }\n \n /// lint use of `filter().map()` for `Iterators`\n-fn lint_filter_map_map<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx hir::Expr, _filter_args: &'tcx [hir::Expr], _map_args: &'tcx [hir::Expr]) {\n+fn lint_filter_map_map<'a, 'tcx>(\n+    cx: &LateContext<'a, 'tcx>,\n+    expr: &'tcx hir::Expr,\n+    _filter_args: &'tcx [hir::Expr],\n+    _map_args: &'tcx [hir::Expr],\n+) {\n     // lint if caller of `.filter().map()` is an Iterator\n     if match_trait_method(cx, expr, &paths::ITERATOR) {\n         let msg = \"called `filter_map(p).map(q)` on an `Iterator`. \\\n@@ -1317,7 +1335,12 @@ fn lint_filter_map_map<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx hir::Ex\n }\n \n /// lint use of `filter().flat_map()` for `Iterators`\n-fn lint_filter_flat_map<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx hir::Expr, _filter_args: &'tcx [hir::Expr], _map_args: &'tcx [hir::Expr]) {\n+fn lint_filter_flat_map<'a, 'tcx>(\n+    cx: &LateContext<'a, 'tcx>,\n+    expr: &'tcx hir::Expr,\n+    _filter_args: &'tcx [hir::Expr],\n+    _map_args: &'tcx [hir::Expr],\n+) {\n     // lint if caller of `.filter().flat_map()` is an Iterator\n     if match_trait_method(cx, expr, &paths::ITERATOR) {\n         let msg = \"called `filter(p).flat_map(q)` on an `Iterator`. \\\n@@ -1328,7 +1351,12 @@ fn lint_filter_flat_map<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx hir::E\n }\n \n /// lint use of `filter_map().flat_map()` for `Iterators`\n-fn lint_filter_map_flat_map<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx hir::Expr, _filter_args: &'tcx [hir::Expr], _map_args: &'tcx [hir::Expr]) {\n+fn lint_filter_map_flat_map<'a, 'tcx>(\n+    cx: &LateContext<'a, 'tcx>,\n+    expr: &'tcx hir::Expr,\n+    _filter_args: &'tcx [hir::Expr],\n+    _map_args: &'tcx [hir::Expr],\n+) {\n     // lint if caller of `.filter_map().flat_map()` is an Iterator\n     if match_trait_method(cx, expr, &paths::ITERATOR) {\n         let msg = \"called `filter_map(p).flat_map(q)` on an `Iterator`. \\\n@@ -1399,7 +1427,13 @@ fn lint_binary_expr_with_method_call<'a, 'tcx: 'a>(cx: &LateContext<'a, 'tcx>, i\n }\n \n /// Wrapper fn for `CHARS_NEXT_CMP` and `CHARS_NEXT_CMP` lints.\n-fn lint_chars_cmp<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, info: &BinaryExprInfo, chain_methods: &[&str], lint: &'static Lint, suggest: &str) -> bool {\n+fn lint_chars_cmp<'a, 'tcx>(\n+    cx: &LateContext<'a, 'tcx>,\n+    info: &BinaryExprInfo,\n+    chain_methods: &[&str],\n+    lint: &'static Lint,\n+    suggest: &str,\n+) -> bool {\n     if_let_chain! {[\n         let Some(args) = method_chain_args(info.chain, chain_methods),\n         let hir::ExprCall(ref fun, ref arg_char) = info.other.node,\n@@ -1446,7 +1480,13 @@ fn lint_chars_last_cmp<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, info: &BinaryExprIn\n }\n \n /// Wrapper fn for `CHARS_NEXT_CMP` and `CHARS_LAST_CMP` lints with `unwrap()`.\n-fn lint_chars_cmp_with_unwrap<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, info: &BinaryExprInfo, chain_methods: &[&str], lint: &'static Lint, suggest: &str) -> bool {\n+fn lint_chars_cmp_with_unwrap<'a, 'tcx>(\n+    cx: &LateContext<'a, 'tcx>,\n+    info: &BinaryExprInfo,\n+    chain_methods: &[&str],\n+    lint: &'static Lint,\n+    suggest: &str,\n+) -> bool {\n     if_let_chain! {[\n         let Some(args) = method_chain_args(info.chain, chain_methods),\n         let hir::ExprLit(ref lit) = info.other.node,\n@@ -1490,15 +1530,21 @@ fn lint_single_char_pattern<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx hi\n     let parent_item = cx.tcx.hir.get_parent(arg.id);\n     let parent_def_id = cx.tcx.hir.local_def_id(parent_item);\n     let substs = Substs::identity_for_item(cx.tcx, parent_def_id);\n-    if let Ok(&ty::Const { val: ConstVal::Str(r), .. }) = ConstContext::new(cx.tcx, cx.param_env.and(substs), cx.tables).eval(arg) {\n+    if let Ok(&ty::Const {\n+        val: ConstVal::Str(r),\n+        ..\n+    }) = ConstContext::new(cx.tcx, cx.param_env.and(substs), cx.tables).eval(arg)\n+    {\n         if r.len() == 1 {\n             let hint = snippet(cx, expr.span, \"..\").replace(&format!(\"\\\"{}\\\"\", r), &format!(\"'{}'\", r));\n             span_lint_and_then(\n                 cx,\n                 SINGLE_CHAR_PATTERN,\n                 arg.span,\n                 \"single-character string constant used as pattern\",\n-                |db| { db.span_suggestion(expr.span, \"try using a char instead\", hint); },\n+                |db| {\n+                    db.span_suggestion(expr.span, \"try using a char instead\", hint);\n+                },\n             );\n         }\n     }\n@@ -1669,27 +1715,24 @@ impl SelfKind {\n fn is_as_ref_or_mut_trait(ty: &hir::Ty, self_ty: &hir::Ty, generics: &hir::Generics, name: &[&str]) -> bool {\n     single_segment_ty(ty).map_or(false, |seg| {\n         generics.ty_params.iter().any(|param| {\n-            param.name == seg.name &&\n-                param\n+            param.name == seg.name\n+                && param\n                     .bounds\n                     .iter()\n                     .any(|bound| if let hir::TyParamBound::TraitTyParamBound(ref ptr, ..) = *bound {\n                         let path = &ptr.trait_ref.path;\n-                        match_path(path, name) &&\n-                            path.segments\n+                        match_path(path, name)\n+                            && path.segments\n                                 .last()\n-                                .map_or(false, |s| {\n-                                    if let Some(ref params) = s.parameters {\n-                                        if params.parenthesized {\n-                                            false\n-                                        } else {\n-                                            params.types.len() == 1 &&\n-                                                (is_self_ty(&params.types[0])\n-                                                  || is_ty(&*params.types[0], self_ty))\n-                                        }\n-                                    } else {\n+                                .map_or(false, |s| if let Some(ref params) = s.parameters {\n+                                    if params.parenthesized {\n                                         false\n+                                    } else {\n+                                        params.types.len() == 1\n+                                            && (is_self_ty(&params.types[0]) || is_ty(&*params.types[0], self_ty))\n                                     }\n+                                } else {\n+                                    false\n                                 })\n                     } else {\n                         false"}, {"sha": "c13caf84b9830a69c84b0cb78de83e64bb889aa9", "filename": "tests/ui/methods.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/60c7bd47a56f72938bdd8a7dce328f414e1bc78f/tests%2Fui%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60c7bd47a56f72938bdd8a7dce328f414e1bc78f/tests%2Fui%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmethods.rs?ref=60c7bd47a56f72938bdd8a7dce328f414e1bc78f", "patch": "@@ -17,8 +17,11 @@ use std::sync::{self, Arc};\n struct T;\n \n impl T {\n-    fn add(self, other: T) -> T { self }\n-    fn drop(&mut self) { }\n+    pub fn add(self, other: T) -> T { self }\n+    pub fn drop(&mut self) { }\n+\n+    fn neg(self) -> Self { self } // no error, private function\n+    fn eq(&self, other: T) -> bool { true } // no error, private function\n \n     fn sub(&self, other: T) -> &T { self } // no error, self is a ref\n     fn div(self) -> T { self } // no error, different #arguments"}, {"sha": "9591d1f4fb403ca0d7347a8773dc0be9f0e3fa3a", "filename": "tests/ui/methods.stderr", "status": "modified", "additions": 173, "deletions": 167, "changes": 340, "blob_url": "https://github.com/rust-lang/rust/blob/60c7bd47a56f72938bdd8a7dce328f414e1bc78f/tests%2Fui%2Fmethods.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/60c7bd47a56f72938bdd8a7dce328f414e1bc78f/tests%2Fui%2Fmethods.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmethods.stderr?ref=60c7bd47a56f72938bdd8a7dce328f414e1bc78f", "patch": "@@ -1,471 +1,477 @@\n error: unnecessary structure name repetition\n-  --> $DIR/methods.rs:20:25\n+  --> $DIR/methods.rs:20:29\n    |\n-20 |     fn add(self, other: T) -> T { self }\n-   |                         ^ help: use the applicable keyword: `Self`\n+20 |     pub fn add(self, other: T) -> T { self }\n+   |                             ^ help: use the applicable keyword: `Self`\n    |\n    = note: `-D use-self` implied by `-D warnings`\n \n error: unnecessary structure name repetition\n-  --> $DIR/methods.rs:20:31\n+  --> $DIR/methods.rs:20:35\n    |\n-20 |     fn add(self, other: T) -> T { self }\n-   |                               ^ help: use the applicable keyword: `Self`\n+20 |     pub fn add(self, other: T) -> T { self }\n+   |                                   ^ help: use the applicable keyword: `Self`\n+\n+error: unnecessary structure name repetition\n+  --> $DIR/methods.rs:24:25\n+   |\n+24 |     fn eq(&self, other: T) -> bool { true } // no error, private function\n+   |                         ^ help: use the applicable keyword: `Self`\n \n error: unnecessary structure name repetition\n-  --> $DIR/methods.rs:23:26\n+  --> $DIR/methods.rs:26:26\n    |\n-23 |     fn sub(&self, other: T) -> &T { self } // no error, self is a ref\n+26 |     fn sub(&self, other: T) -> &T { self } // no error, self is a ref\n    |                          ^ help: use the applicable keyword: `Self`\n \n error: unnecessary structure name repetition\n-  --> $DIR/methods.rs:23:33\n+  --> $DIR/methods.rs:26:33\n    |\n-23 |     fn sub(&self, other: T) -> &T { self } // no error, self is a ref\n+26 |     fn sub(&self, other: T) -> &T { self } // no error, self is a ref\n    |                                 ^ help: use the applicable keyword: `Self`\n \n error: unnecessary structure name repetition\n-  --> $DIR/methods.rs:24:21\n+  --> $DIR/methods.rs:27:21\n    |\n-24 |     fn div(self) -> T { self } // no error, different #arguments\n+27 |     fn div(self) -> T { self } // no error, different #arguments\n    |                     ^ help: use the applicable keyword: `Self`\n \n error: unnecessary structure name repetition\n-  --> $DIR/methods.rs:25:25\n+  --> $DIR/methods.rs:28:25\n    |\n-25 |     fn rem(self, other: T) { } // no error, wrong return type\n+28 |     fn rem(self, other: T) { } // no error, wrong return type\n    |                         ^ help: use the applicable keyword: `Self`\n \n error: defining a method called `add` on this type; consider implementing the `std::ops::Add` trait or choosing a less ambiguous name\n   --> $DIR/methods.rs:20:5\n    |\n-20 |     fn add(self, other: T) -> T { self }\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+20 |     pub fn add(self, other: T) -> T { self }\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: `-D should-implement-trait` implied by `-D warnings`\n \n error: defining a method called `drop` on this type; consider implementing the `std::ops::Drop` trait or choosing a less ambiguous name\n   --> $DIR/methods.rs:21:5\n    |\n-21 |     fn drop(&mut self) { }\n-   |     ^^^^^^^^^^^^^^^^^^^^^^\n+21 |     pub fn drop(&mut self) { }\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: methods called `into_*` usually take self by value; consider choosing a less ambiguous name\n-  --> $DIR/methods.rs:28:17\n+  --> $DIR/methods.rs:31:17\n    |\n-28 |     fn into_u16(&self) -> u16 { 0 }\n+31 |     fn into_u16(&self) -> u16 { 0 }\n    |                 ^^^^^\n    |\n    = note: `-D wrong-self-convention` implied by `-D warnings`\n \n error: methods called `to_*` usually take self by reference; consider choosing a less ambiguous name\n-  --> $DIR/methods.rs:30:21\n+  --> $DIR/methods.rs:33:21\n    |\n-30 |     fn to_something(self) -> u32 { 0 }\n+33 |     fn to_something(self) -> u32 { 0 }\n    |                     ^^^^\n \n error: methods called `new` usually take no self; consider choosing a less ambiguous name\n-  --> $DIR/methods.rs:32:12\n+  --> $DIR/methods.rs:35:12\n    |\n-32 |     fn new(self) {}\n+35 |     fn new(self) {}\n    |            ^^^^\n \n error: methods called `new` usually return `Self`\n-  --> $DIR/methods.rs:32:5\n+  --> $DIR/methods.rs:35:5\n    |\n-32 |     fn new(self) {}\n+35 |     fn new(self) {}\n    |     ^^^^^^^^^^^^^^^\n    |\n    = note: `-D new-ret-no-self` implied by `-D warnings`\n \n error: unnecessary structure name repetition\n-  --> $DIR/methods.rs:76:24\n+  --> $DIR/methods.rs:79:24\n    |\n-76 |     fn new() -> Option<V<T>> { None }\n+79 |     fn new() -> Option<V<T>> { None }\n    |                        ^^^^ help: use the applicable keyword: `Self`\n \n error: unnecessary structure name repetition\n-  --> $DIR/methods.rs:80:19\n+  --> $DIR/methods.rs:83:19\n    |\n-80 |     type Output = T;\n+83 |     type Output = T;\n    |                   ^ help: use the applicable keyword: `Self`\n \n error: unnecessary structure name repetition\n-  --> $DIR/methods.rs:81:25\n+  --> $DIR/methods.rs:84:25\n    |\n-81 |     fn mul(self, other: T) -> T { self } // no error, obviously\n+84 |     fn mul(self, other: T) -> T { self } // no error, obviously\n    |                         ^ help: use the applicable keyword: `Self`\n \n error: unnecessary structure name repetition\n-  --> $DIR/methods.rs:81:31\n+  --> $DIR/methods.rs:84:31\n    |\n-81 |     fn mul(self, other: T) -> T { self } // no error, obviously\n+84 |     fn mul(self, other: T) -> T { self } // no error, obviously\n    |                               ^ help: use the applicable keyword: `Self`\n \n error: called `map(f).unwrap_or(a)` on an Option value. This can be done more directly by calling `map_or(a, f)` instead\n-   --> $DIR/methods.rs:100:13\n+   --> $DIR/methods.rs:103:13\n     |\n-100 |       let _ = opt.map(|x| x + 1)\n+103 |       let _ = opt.map(|x| x + 1)\n     |  _____________^\n-101 | |\n-102 | |                .unwrap_or(0); // should lint even though this call is on a separate line\n+104 | |\n+105 | |                .unwrap_or(0); // should lint even though this call is on a separate line\n     | |____________________________^\n     |\n     = note: `-D option-map-unwrap-or` implied by `-D warnings`\n     = note: replace `map(|x| x + 1).unwrap_or(0)` with `map_or(0, |x| x + 1)`\n \n error: called `map(f).unwrap_or(a)` on an Option value. This can be done more directly by calling `map_or(a, f)` instead\n-   --> $DIR/methods.rs:104:13\n+   --> $DIR/methods.rs:107:13\n     |\n-104 |       let _ = opt.map(|x| {\n+107 |       let _ = opt.map(|x| {\n     |  _____________^\n-105 | |                         x + 1\n-106 | |                     }\n-107 | |               ).unwrap_or(0);\n+108 | |                         x + 1\n+109 | |                     }\n+110 | |               ).unwrap_or(0);\n     | |____________________________^\n \n error: called `map(f).unwrap_or(a)` on an Option value. This can be done more directly by calling `map_or(a, f)` instead\n-   --> $DIR/methods.rs:108:13\n+   --> $DIR/methods.rs:111:13\n     |\n-108 |       let _ = opt.map(|x| x + 1)\n+111 |       let _ = opt.map(|x| x + 1)\n     |  _____________^\n-109 | |                .unwrap_or({\n-110 | |                     0\n-111 | |                 });\n+112 | |                .unwrap_or({\n+113 | |                     0\n+114 | |                 });\n     | |__________________^\n \n error: called `map(f).unwrap_or(None)` on an Option value. This can be done more directly by calling `and_then(f)` instead\n-   --> $DIR/methods.rs:113:13\n+   --> $DIR/methods.rs:116:13\n     |\n-113 |     let _ = opt.map(|x| Some(x + 1)).unwrap_or(None);\n+116 |     let _ = opt.map(|x| Some(x + 1)).unwrap_or(None);\n     |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: replace `map(|x| Some(x + 1)).unwrap_or(None)` with `and_then(|x| Some(x + 1))`\n \n error: called `map(f).unwrap_or(None)` on an Option value. This can be done more directly by calling `and_then(f)` instead\n-   --> $DIR/methods.rs:115:13\n+   --> $DIR/methods.rs:118:13\n     |\n-115 |       let _ = opt.map(|x| {\n+118 |       let _ = opt.map(|x| {\n     |  _____________^\n-116 | |         Some(x + 1)\n-117 | |     }\n-118 | |     ).unwrap_or(None);\n+119 | |         Some(x + 1)\n+120 | |     }\n+121 | |     ).unwrap_or(None);\n     | |_____________________^\n \n error: called `map(f).unwrap_or(None)` on an Option value. This can be done more directly by calling `and_then(f)` instead\n-   --> $DIR/methods.rs:119:13\n+   --> $DIR/methods.rs:122:13\n     |\n-119 |       let _ = opt\n+122 |       let _ = opt\n     |  _____________^\n-120 | |         .map(|x| Some(x + 1))\n-121 | |         .unwrap_or(None);\n+123 | |         .map(|x| Some(x + 1))\n+124 | |         .unwrap_or(None);\n     | |________________________^\n     |\n     = note: replace `map(|x| Some(x + 1)).unwrap_or(None)` with `and_then(|x| Some(x + 1))`\n \n error: called `map(f).unwrap_or_else(g)` on an Option value. This can be done more directly by calling `map_or_else(g, f)` instead\n-   --> $DIR/methods.rs:127:13\n+   --> $DIR/methods.rs:130:13\n     |\n-127 |       let _ = opt.map(|x| x + 1)\n+130 |       let _ = opt.map(|x| x + 1)\n     |  _____________^\n-128 | |\n-129 | |                .unwrap_or_else(|| 0); // should lint even though this call is on a separate line\n+131 | |\n+132 | |                .unwrap_or_else(|| 0); // should lint even though this call is on a separate line\n     | |____________________________________^\n     |\n     = note: `-D option-map-unwrap-or-else` implied by `-D warnings`\n     = note: replace `map(|x| x + 1).unwrap_or_else(|| 0)` with `map_or_else(|| 0, |x| x + 1)`\n \n error: called `map(f).unwrap_or_else(g)` on an Option value. This can be done more directly by calling `map_or_else(g, f)` instead\n-   --> $DIR/methods.rs:131:13\n+   --> $DIR/methods.rs:134:13\n     |\n-131 |       let _ = opt.map(|x| {\n+134 |       let _ = opt.map(|x| {\n     |  _____________^\n-132 | |                         x + 1\n-133 | |                     }\n-134 | |               ).unwrap_or_else(|| 0);\n+135 | |                         x + 1\n+136 | |                     }\n+137 | |               ).unwrap_or_else(|| 0);\n     | |____________________________________^\n \n error: called `map(f).unwrap_or_else(g)` on an Option value. This can be done more directly by calling `map_or_else(g, f)` instead\n-   --> $DIR/methods.rs:135:13\n+   --> $DIR/methods.rs:138:13\n     |\n-135 |       let _ = opt.map(|x| x + 1)\n+138 |       let _ = opt.map(|x| x + 1)\n     |  _____________^\n-136 | |                .unwrap_or_else(||\n-137 | |                     0\n-138 | |                 );\n+139 | |                .unwrap_or_else(||\n+140 | |                     0\n+141 | |                 );\n     | |_________________^\n \n error: called `map_or(None, f)` on an Option value. This can be done more directly by calling `and_then(f)` instead\n-   --> $DIR/methods.rs:144:13\n+   --> $DIR/methods.rs:147:13\n     |\n-144 |     let _ = opt.map_or(None, |x| Some(x + 1));\n+147 |     let _ = opt.map_or(None, |x| Some(x + 1));\n     |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try using and_then instead: `opt.and_then(|x| Some(x + 1))`\n     |\n     = note: `-D option-map-or-none` implied by `-D warnings`\n \n error: called `map_or(None, f)` on an Option value. This can be done more directly by calling `and_then(f)` instead\n-   --> $DIR/methods.rs:146:13\n+   --> $DIR/methods.rs:149:13\n     |\n-146 |       let _ = opt.map_or(None, |x| {\n+149 |       let _ = opt.map_or(None, |x| {\n     |  _____________^\n-147 | |                         Some(x + 1)\n-148 | |                        }\n-149 | |                 );\n+150 | |                         Some(x + 1)\n+151 | |                        }\n+152 | |                 );\n     | |_________________^\n     |\n help: try using and_then instead\n     |\n-146 |     let _ = opt.and_then(|x| {\n-147 |                         Some(x + 1)\n-148 |                        });\n+149 |     let _ = opt.and_then(|x| {\n+150 |                         Some(x + 1)\n+151 |                        });\n     |\n \n error: unnecessary structure name repetition\n-   --> $DIR/methods.rs:173:24\n+   --> $DIR/methods.rs:176:24\n     |\n-173 |     fn filter(self) -> IteratorFalsePositives {\n+176 |     fn filter(self) -> IteratorFalsePositives {\n     |                        ^^^^^^^^^^^^^^^^^^^^^^ help: use the applicable keyword: `Self`\n \n error: unnecessary structure name repetition\n-   --> $DIR/methods.rs:177:22\n+   --> $DIR/methods.rs:180:22\n     |\n-177 |     fn next(self) -> IteratorFalsePositives {\n+180 |     fn next(self) -> IteratorFalsePositives {\n     |                      ^^^^^^^^^^^^^^^^^^^^^^ help: use the applicable keyword: `Self`\n \n error: unnecessary structure name repetition\n-   --> $DIR/methods.rs:197:32\n+   --> $DIR/methods.rs:200:32\n     |\n-197 |     fn skip(self, _: usize) -> IteratorFalsePositives {\n+200 |     fn skip(self, _: usize) -> IteratorFalsePositives {\n     |                                ^^^^^^^^^^^^^^^^^^^^^^ help: use the applicable keyword: `Self`\n \n error: called `filter(p).next()` on an `Iterator`. This is more succinctly expressed by calling `.find(p)` instead.\n-   --> $DIR/methods.rs:207:13\n+   --> $DIR/methods.rs:210:13\n     |\n-207 |     let _ = v.iter().filter(|&x| *x < 0).next();\n+210 |     let _ = v.iter().filter(|&x| *x < 0).next();\n     |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `-D filter-next` implied by `-D warnings`\n     = note: replace `filter(|&x| *x < 0).next()` with `find(|&x| *x < 0)`\n \n error: called `filter(p).next()` on an `Iterator`. This is more succinctly expressed by calling `.find(p)` instead.\n-   --> $DIR/methods.rs:210:13\n+   --> $DIR/methods.rs:213:13\n     |\n-210 |       let _ = v.iter().filter(|&x| {\n+213 |       let _ = v.iter().filter(|&x| {\n     |  _____________^\n-211 | |                                 *x < 0\n-212 | |                             }\n-213 | |                    ).next();\n+214 | |                                 *x < 0\n+215 | |                             }\n+216 | |                    ).next();\n     | |___________________________^\n \n error: called `is_some()` after searching an `Iterator` with find. This is more succinctly expressed by calling `any()`.\n-   --> $DIR/methods.rs:225:13\n+   --> $DIR/methods.rs:228:13\n     |\n-225 |     let _ = v.iter().find(|&x| *x < 0).is_some();\n+228 |     let _ = v.iter().find(|&x| *x < 0).is_some();\n     |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `-D search-is-some` implied by `-D warnings`\n     = note: replace `find(|&x| *x < 0).is_some()` with `any(|&x| *x < 0)`\n \n error: called `is_some()` after searching an `Iterator` with find. This is more succinctly expressed by calling `any()`.\n-   --> $DIR/methods.rs:228:13\n+   --> $DIR/methods.rs:231:13\n     |\n-228 |       let _ = v.iter().find(|&x| {\n+231 |       let _ = v.iter().find(|&x| {\n     |  _____________^\n-229 | |                               *x < 0\n-230 | |                           }\n-231 | |                    ).is_some();\n+232 | |                               *x < 0\n+233 | |                           }\n+234 | |                    ).is_some();\n     | |______________________________^\n \n error: called `is_some()` after searching an `Iterator` with position. This is more succinctly expressed by calling `any()`.\n-   --> $DIR/methods.rs:234:13\n+   --> $DIR/methods.rs:237:13\n     |\n-234 |     let _ = v.iter().position(|&x| x < 0).is_some();\n+237 |     let _ = v.iter().position(|&x| x < 0).is_some();\n     |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: replace `position(|&x| x < 0).is_some()` with `any(|&x| x < 0)`\n \n error: called `is_some()` after searching an `Iterator` with position. This is more succinctly expressed by calling `any()`.\n-   --> $DIR/methods.rs:237:13\n+   --> $DIR/methods.rs:240:13\n     |\n-237 |       let _ = v.iter().position(|&x| {\n+240 |       let _ = v.iter().position(|&x| {\n     |  _____________^\n-238 | |                                   x < 0\n-239 | |                               }\n-240 | |                    ).is_some();\n+241 | |                                   x < 0\n+242 | |                               }\n+243 | |                    ).is_some();\n     | |______________________________^\n \n error: called `is_some()` after searching an `Iterator` with rposition. This is more succinctly expressed by calling `any()`.\n-   --> $DIR/methods.rs:243:13\n+   --> $DIR/methods.rs:246:13\n     |\n-243 |     let _ = v.iter().rposition(|&x| x < 0).is_some();\n+246 |     let _ = v.iter().rposition(|&x| x < 0).is_some();\n     |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: replace `rposition(|&x| x < 0).is_some()` with `any(|&x| x < 0)`\n \n error: called `is_some()` after searching an `Iterator` with rposition. This is more succinctly expressed by calling `any()`.\n-   --> $DIR/methods.rs:246:13\n+   --> $DIR/methods.rs:249:13\n     |\n-246 |       let _ = v.iter().rposition(|&x| {\n+249 |       let _ = v.iter().rposition(|&x| {\n     |  _____________^\n-247 | |                                    x < 0\n-248 | |                                }\n-249 | |                    ).is_some();\n+250 | |                                    x < 0\n+251 | |                                }\n+252 | |                    ).is_some();\n     | |______________________________^\n \n error: unnecessary structure name repetition\n-   --> $DIR/methods.rs:263:21\n+   --> $DIR/methods.rs:266:21\n     |\n-263 |         fn new() -> Foo { Foo }\n+266 |         fn new() -> Foo { Foo }\n     |                     ^^^ help: use the applicable keyword: `Self`\n \n error: use of `unwrap_or` followed by a function call\n-   --> $DIR/methods.rs:281:5\n+   --> $DIR/methods.rs:284:5\n     |\n-281 |     with_constructor.unwrap_or(make());\n+284 |     with_constructor.unwrap_or(make());\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `with_constructor.unwrap_or_else(make)`\n     |\n     = note: `-D or-fun-call` implied by `-D warnings`\n \n error: use of `unwrap_or` followed by a call to `new`\n-   --> $DIR/methods.rs:284:5\n+   --> $DIR/methods.rs:287:5\n     |\n-284 |     with_new.unwrap_or(Vec::new());\n+287 |     with_new.unwrap_or(Vec::new());\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `with_new.unwrap_or_default()`\n \n error: use of `unwrap_or` followed by a function call\n-   --> $DIR/methods.rs:287:5\n+   --> $DIR/methods.rs:290:5\n     |\n-287 |     with_const_args.unwrap_or(Vec::with_capacity(12));\n+290 |     with_const_args.unwrap_or(Vec::with_capacity(12));\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `with_const_args.unwrap_or_else(|| Vec::with_capacity(12))`\n \n error: use of `unwrap_or` followed by a function call\n-   --> $DIR/methods.rs:290:5\n+   --> $DIR/methods.rs:293:5\n     |\n-290 |     with_err.unwrap_or(make());\n+293 |     with_err.unwrap_or(make());\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `with_err.unwrap_or_else(|_| make())`\n \n error: use of `unwrap_or` followed by a function call\n-   --> $DIR/methods.rs:293:5\n+   --> $DIR/methods.rs:296:5\n     |\n-293 |     with_err_args.unwrap_or(Vec::with_capacity(12));\n+296 |     with_err_args.unwrap_or(Vec::with_capacity(12));\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `with_err_args.unwrap_or_else(|_| Vec::with_capacity(12))`\n \n error: use of `unwrap_or` followed by a call to `default`\n-   --> $DIR/methods.rs:296:5\n+   --> $DIR/methods.rs:299:5\n     |\n-296 |     with_default_trait.unwrap_or(Default::default());\n+299 |     with_default_trait.unwrap_or(Default::default());\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `with_default_trait.unwrap_or_default()`\n \n error: use of `unwrap_or` followed by a call to `default`\n-   --> $DIR/methods.rs:299:5\n+   --> $DIR/methods.rs:302:5\n     |\n-299 |     with_default_type.unwrap_or(u64::default());\n+302 |     with_default_type.unwrap_or(u64::default());\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `with_default_type.unwrap_or_default()`\n \n error: use of `unwrap_or` followed by a function call\n-   --> $DIR/methods.rs:302:5\n+   --> $DIR/methods.rs:305:5\n     |\n-302 |     with_vec.unwrap_or(vec![]);\n+305 |     with_vec.unwrap_or(vec![]);\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `with_vec.unwrap_or_else(|| < [ _ ] > :: into_vec ( box [ $ ( $ x ) , * ] ))`\n \n error: use of `unwrap_or` followed by a function call\n-   --> $DIR/methods.rs:307:5\n+   --> $DIR/methods.rs:310:5\n     |\n-307 |     without_default.unwrap_or(Foo::new());\n+310 |     without_default.unwrap_or(Foo::new());\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `without_default.unwrap_or_else(Foo::new)`\n \n error: use of `or_insert` followed by a function call\n-   --> $DIR/methods.rs:310:5\n+   --> $DIR/methods.rs:313:5\n     |\n-310 |     map.entry(42).or_insert(String::new());\n+313 |     map.entry(42).or_insert(String::new());\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `map.entry(42).or_insert_with(String::new)`\n \n error: use of `or_insert` followed by a function call\n-   --> $DIR/methods.rs:313:5\n+   --> $DIR/methods.rs:316:5\n     |\n-313 |     btree.entry(42).or_insert(String::new());\n+316 |     btree.entry(42).or_insert(String::new());\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `btree.entry(42).or_insert_with(String::new)`\n \n error: use of `unwrap_or` followed by a function call\n-   --> $DIR/methods.rs:316:13\n+   --> $DIR/methods.rs:319:13\n     |\n-316 |     let _ = stringy.unwrap_or(\"\".to_owned());\n+319 |     let _ = stringy.unwrap_or(\"\".to_owned());\n     |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `stringy.unwrap_or_else(|| \"\".to_owned())`\n \n error: called `.iter().nth()` on a Vec. Calling `.get()` is both faster and more readable\n-   --> $DIR/methods.rs:327:23\n+   --> $DIR/methods.rs:330:23\n     |\n-327 |         let bad_vec = some_vec.iter().nth(3);\n+330 |         let bad_vec = some_vec.iter().nth(3);\n     |                       ^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `-D iter-nth` implied by `-D warnings`\n \n error: called `.iter().nth()` on a slice. Calling `.get()` is both faster and more readable\n-   --> $DIR/methods.rs:328:26\n+   --> $DIR/methods.rs:331:26\n     |\n-328 |         let bad_slice = &some_vec[..].iter().nth(3);\n+331 |         let bad_slice = &some_vec[..].iter().nth(3);\n     |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: called `.iter().nth()` on a slice. Calling `.get()` is both faster and more readable\n-   --> $DIR/methods.rs:329:31\n+   --> $DIR/methods.rs:332:31\n     |\n-329 |         let bad_boxed_slice = boxed_slice.iter().nth(3);\n+332 |         let bad_boxed_slice = boxed_slice.iter().nth(3);\n     |                               ^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: called `.iter().nth()` on a VecDeque. Calling `.get()` is both faster and more readable\n-   --> $DIR/methods.rs:330:29\n+   --> $DIR/methods.rs:333:29\n     |\n-330 |         let bad_vec_deque = some_vec_deque.iter().nth(3);\n+333 |         let bad_vec_deque = some_vec_deque.iter().nth(3);\n     |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: called `.iter_mut().nth()` on a Vec. Calling `.get_mut()` is both faster and more readable\n-   --> $DIR/methods.rs:335:23\n+   --> $DIR/methods.rs:338:23\n     |\n-335 |         let bad_vec = some_vec.iter_mut().nth(3);\n+338 |         let bad_vec = some_vec.iter_mut().nth(3);\n     |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: called `.iter_mut().nth()` on a slice. Calling `.get_mut()` is both faster and more readable\n-   --> $DIR/methods.rs:338:26\n+   --> $DIR/methods.rs:341:26\n     |\n-338 |         let bad_slice = &some_vec[..].iter_mut().nth(3);\n+341 |         let bad_slice = &some_vec[..].iter_mut().nth(3);\n     |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: called `.iter_mut().nth()` on a VecDeque. Calling `.get_mut()` is both faster and more readable\n-   --> $DIR/methods.rs:341:29\n+   --> $DIR/methods.rs:344:29\n     |\n-341 |         let bad_vec_deque = some_vec_deque.iter_mut().nth(3);\n+344 |         let bad_vec_deque = some_vec_deque.iter_mut().nth(3);\n     |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: called `skip(x).next()` on an iterator. This is more succinctly expressed by calling `nth(x)`\n-   --> $DIR/methods.rs:353:13\n+   --> $DIR/methods.rs:356:13\n     |\n-353 |     let _ = some_vec.iter().skip(42).next();\n+356 |     let _ = some_vec.iter().skip(42).next();\n     |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |\n     = note: `-D iter-skip-next` implied by `-D warnings`\n \n error: called `skip(x).next()` on an iterator. This is more succinctly expressed by calling `nth(x)`\n-   --> $DIR/methods.rs:354:13\n+   --> $DIR/methods.rs:357:13\n     |\n-354 |     let _ = some_vec.iter().cycle().skip(42).next();\n+357 |     let _ = some_vec.iter().cycle().skip(42).next();\n     |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: called `skip(x).next()` on an iterator. This is more succinctly expressed by calling `nth(x)`\n-   --> $DIR/methods.rs:355:13\n+   --> $DIR/methods.rs:358:13\n     |\n-355 |     let _ = (1..10).skip(10).next();\n+358 |     let _ = (1..10).skip(10).next();\n     |             ^^^^^^^^^^^^^^^^^^^^^^^\n \n error: called `skip(x).next()` on an iterator. This is more succinctly expressed by calling `nth(x)`\n-   --> $DIR/methods.rs:356:14\n+   --> $DIR/methods.rs:359:14\n     |\n-356 |     let _ = &some_vec[..].iter().skip(3).next();\n+359 |     let _ = &some_vec[..].iter().skip(3).next();\n     |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: used unwrap() on an Option value. If you don't want to handle the None case gracefully, consider using expect() to provide a better panic message\n-   --> $DIR/methods.rs:365:13\n+   --> $DIR/methods.rs:368:13\n     |\n-365 |     let _ = opt.unwrap();\n+368 |     let _ = opt.unwrap();\n     |             ^^^^^^^^^^^^\n     |\n     = note: `-D option-unwrap-used` implied by `-D warnings`"}]}