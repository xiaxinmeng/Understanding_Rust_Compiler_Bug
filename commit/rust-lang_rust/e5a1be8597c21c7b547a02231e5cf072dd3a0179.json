{"sha": "e5a1be8597c21c7b547a02231e5cf072dd3a0179", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU1YTFiZTg1OTdjMjFjN2I1NDdhMDIyMzFlNWNmMDcyZGQzYTAxNzk=", "commit": {"author": {"name": "marmeladema", "email": "xademax@gmail.com", "date": "2020-05-02T17:42:36Z"}, "committer": {"name": "marmeladema", "email": "xademax@gmail.com", "date": "2020-05-03T11:44:57Z"}, "message": "Use `LocalDefId` in `DumpVisitor::nest_tables`\n\nThis is a partial fix for #71104", "tree": {"sha": "613b5e34e43586dd4812810fd445ac1f91ef83b7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/613b5e34e43586dd4812810fd445ac1f91ef83b7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e5a1be8597c21c7b547a02231e5cf072dd3a0179", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e5a1be8597c21c7b547a02231e5cf072dd3a0179", "html_url": "https://github.com/rust-lang/rust/commit/e5a1be8597c21c7b547a02231e5cf072dd3a0179", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e5a1be8597c21c7b547a02231e5cf072dd3a0179/comments", "author": {"login": "marmeladema", "id": 1629419, "node_id": "MDQ6VXNlcjE2Mjk0MTk=", "avatar_url": "https://avatars.githubusercontent.com/u/1629419?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marmeladema", "html_url": "https://github.com/marmeladema", "followers_url": "https://api.github.com/users/marmeladema/followers", "following_url": "https://api.github.com/users/marmeladema/following{/other_user}", "gists_url": "https://api.github.com/users/marmeladema/gists{/gist_id}", "starred_url": "https://api.github.com/users/marmeladema/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marmeladema/subscriptions", "organizations_url": "https://api.github.com/users/marmeladema/orgs", "repos_url": "https://api.github.com/users/marmeladema/repos", "events_url": "https://api.github.com/users/marmeladema/events{/privacy}", "received_events_url": "https://api.github.com/users/marmeladema/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marmeladema", "id": 1629419, "node_id": "MDQ6VXNlcjE2Mjk0MTk=", "avatar_url": "https://avatars.githubusercontent.com/u/1629419?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marmeladema", "html_url": "https://github.com/marmeladema", "followers_url": "https://api.github.com/users/marmeladema/followers", "following_url": "https://api.github.com/users/marmeladema/following{/other_user}", "gists_url": "https://api.github.com/users/marmeladema/gists{/gist_id}", "starred_url": "https://api.github.com/users/marmeladema/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marmeladema/subscriptions", "organizations_url": "https://api.github.com/users/marmeladema/orgs", "repos_url": "https://api.github.com/users/marmeladema/repos", "events_url": "https://api.github.com/users/marmeladema/events{/privacy}", "received_events_url": "https://api.github.com/users/marmeladema/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7184d137f65bb8d143ce8b5b664e50d33c4b5fbd", "url": "https://api.github.com/repos/rust-lang/rust/commits/7184d137f65bb8d143ce8b5b664e50d33c4b5fbd", "html_url": "https://github.com/rust-lang/rust/commit/7184d137f65bb8d143ce8b5b664e50d33c4b5fbd"}], "stats": {"total": 77, "additions": 41, "deletions": 36}, "files": [{"sha": "e2eb39c3e1cbd6cfe63c3aa4b75f41d98e06473a", "filename": "src/librustc_save_analysis/dump_visitor.rs", "status": "modified", "additions": 41, "deletions": 29, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/e5a1be8597c21c7b547a02231e5cf072dd3a0179/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5a1be8597c21c7b547a02231e5cf072dd3a0179/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdump_visitor.rs?ref=e5a1be8597c21c7b547a02231e5cf072dd3a0179", "patch": "@@ -21,7 +21,7 @@ use rustc_ast::walk_list;\n use rustc_ast_pretty::pprust::{bounds_to_string, generic_params_to_string, ty_to_string};\n use rustc_data_structures::fx::FxHashSet;\n use rustc_hir::def::{DefKind as HirDefKind, Res};\n-use rustc_hir::def_id::DefId;\n+use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_middle::span_bug;\n use rustc_middle::ty::{self, DefIdTree, TyCtxt};\n use rustc_session::config::Input;\n@@ -103,12 +103,10 @@ impl<'l, 'tcx> DumpVisitor<'l, 'tcx> {\n         self.dumper.analysis()\n     }\n \n-    fn nest_tables<F>(&mut self, item_id: NodeId, f: F)\n+    fn nest_tables<F>(&mut self, item_def_id: LocalDefId, f: F)\n     where\n         F: FnOnce(&mut Self),\n     {\n-        let item_def_id = self.tcx.hir().local_def_id_from_node_id(item_id);\n-\n         let tables = if self.tcx.has_typeck_tables(item_def_id) {\n             self.tcx.typeck_tables_of(item_def_id)\n         } else {\n@@ -271,8 +269,9 @@ impl<'l, 'tcx> DumpVisitor<'l, 'tcx> {\n     ) {\n         debug!(\"process_method: {}:{}\", id, ident);\n \n-        let hir_id = self.tcx.hir().node_id_to_hir_id(id);\n-        self.nest_tables(id, |v| {\n+        let map = &self.tcx.hir();\n+        let hir_id = map.node_id_to_hir_id(id);\n+        self.nest_tables(map.local_def_id(hir_id), |v| {\n             if let Some(mut method_data) = v.save_ctxt.get_method_data(id, ident, span) {\n                 v.process_formals(&sig.decl.inputs, &method_data.qualname);\n                 v.process_generic_params(&generics, &method_data.qualname, id);\n@@ -295,7 +294,8 @@ impl<'l, 'tcx> DumpVisitor<'l, 'tcx> {\n                 // start walking from the newly-created definition.\n                 match sig.header.asyncness {\n                     ast::Async::Yes { return_impl_trait_id, .. } => {\n-                        v.nest_tables(return_impl_trait_id, |v| v.visit_ty(ret_ty))\n+                        let hir_id = map.node_id_to_hir_id(return_impl_trait_id);\n+                        v.nest_tables(map.local_def_id(hir_id), |v| v.visit_ty(ret_ty))\n                     }\n                     _ => v.visit_ty(ret_ty),\n                 }\n@@ -363,8 +363,9 @@ impl<'l, 'tcx> DumpVisitor<'l, 'tcx> {\n         ty_params: &'l ast::Generics,\n         body: Option<&'l ast::Block>,\n     ) {\n-        let hir_id = self.tcx.hir().node_id_to_hir_id(item.id);\n-        self.nest_tables(item.id, |v| {\n+        let map = &self.tcx.hir();\n+        let hir_id = map.node_id_to_hir_id(item.id);\n+        self.nest_tables(map.local_def_id(hir_id), |v| {\n             if let Some(fn_data) = v.save_ctxt.get_item_data(item) {\n                 down_cast_data!(fn_data, DefData, item.span);\n                 v.process_formals(&decl.inputs, &fn_data.qualname);\n@@ -388,7 +389,8 @@ impl<'l, 'tcx> DumpVisitor<'l, 'tcx> {\n                     // start walking from the newly-created definition.\n                     match header.asyncness {\n                         ast::Async::Yes { return_impl_trait_id, .. } => {\n-                            v.nest_tables(return_impl_trait_id, |v| v.visit_ty(ret_ty))\n+                            let hir_id = map.node_id_to_hir_id(return_impl_trait_id);\n+                            v.nest_tables(map.local_def_id(hir_id), |v| v.visit_ty(ret_ty))\n                         }\n                         _ => v.visit_ty(ret_ty),\n                     }\n@@ -406,7 +408,7 @@ impl<'l, 'tcx> DumpVisitor<'l, 'tcx> {\n         expr: Option<&'l ast::Expr>,\n     ) {\n         let hir_id = self.tcx.hir().node_id_to_hir_id(item.id);\n-        self.nest_tables(item.id, |v| {\n+        self.nest_tables(self.tcx.hir().local_def_id(hir_id), |v| {\n             if let Some(var_data) = v.save_ctxt.get_item_data(item) {\n                 down_cast_data!(var_data, DefData, item.span);\n                 v.dumper.dump_def(&access_from!(v.save_ctxt, item, hir_id), var_data);\n@@ -426,15 +428,13 @@ impl<'l, 'tcx> DumpVisitor<'l, 'tcx> {\n         vis: ast::Visibility,\n         attrs: &'l [Attribute],\n     ) {\n-        let qualname = format!(\n-            \"::{}\",\n-            self.tcx.def_path_str(self.tcx.hir().local_def_id_from_node_id(id).to_def_id())\n-        );\n+        let hir_id = self.tcx.hir().node_id_to_hir_id(id);\n+        let qualname =\n+            format!(\"::{}\", self.tcx.def_path_str(self.tcx.hir().local_def_id(hir_id).to_def_id()));\n \n         if !self.span.filter_generated(ident.span) {\n             let sig = sig::assoc_const_signature(id, ident.name, typ, expr, &self.save_ctxt);\n             let span = self.span_from_span(ident.span);\n-            let hir_id = self.tcx.hir().node_id_to_hir_id(id);\n \n             self.dumper.dump_def(\n                 &access_from_vis!(self.save_ctxt, vis, hir_id),\n@@ -456,7 +456,7 @@ impl<'l, 'tcx> DumpVisitor<'l, 'tcx> {\n         }\n \n         // walk type and init value\n-        self.nest_tables(id, |v| {\n+        self.nest_tables(self.tcx.hir().local_def_id(hir_id), |v| {\n             v.visit_ty(typ);\n             if let Some(expr) = expr {\n                 v.visit_expr(expr);\n@@ -473,10 +473,9 @@ impl<'l, 'tcx> DumpVisitor<'l, 'tcx> {\n     ) {\n         debug!(\"process_struct {:?} {:?}\", item, item.span);\n         let name = item.ident.to_string();\n-        let qualname = format!(\n-            \"::{}\",\n-            self.tcx.def_path_str(self.tcx.hir().local_def_id_from_node_id(item.id).to_def_id())\n-        );\n+        let hir_id = self.tcx.hir().node_id_to_hir_id(item.id);\n+        let qualname =\n+            format!(\"::{}\", self.tcx.def_path_str(self.tcx.hir().local_def_id(hir_id).to_def_id()));\n \n         let kind = match item.kind {\n             ast::ItemKind::Struct(_, _) => DefKind::Struct,\n@@ -508,7 +507,6 @@ impl<'l, 'tcx> DumpVisitor<'l, 'tcx> {\n \n         if !self.span.filter_generated(item.ident.span) {\n             let span = self.span_from_span(item.ident.span);\n-            let hir_id = self.tcx.hir().node_id_to_hir_id(item.id);\n             self.dumper.dump_def(\n                 &access_from!(self.save_ctxt, item, hir_id),\n                 Def {\n@@ -528,7 +526,7 @@ impl<'l, 'tcx> DumpVisitor<'l, 'tcx> {\n             );\n         }\n \n-        self.nest_tables(item.id, |v| {\n+        self.nest_tables(self.tcx.hir().local_def_id(hir_id), |v| {\n             for field in def.fields() {\n                 v.process_struct_field_def(field, item.id);\n                 v.visit_ty(&field.ty);\n@@ -668,14 +666,15 @@ impl<'l, 'tcx> DumpVisitor<'l, 'tcx> {\n         }\n \n         let map = &self.tcx.hir();\n-        self.nest_tables(item.id, |v| {\n+        let hir_id = map.node_id_to_hir_id(item.id);\n+        self.nest_tables(map.local_def_id(hir_id), |v| {\n             v.visit_ty(&typ);\n             if let &Some(ref trait_ref) = trait_ref {\n                 v.process_path(trait_ref.ref_id, &trait_ref.path);\n             }\n             v.process_generic_params(generics, \"\", item.id);\n             for impl_item in impl_items {\n-                v.process_impl_item(impl_item, map.local_def_id_from_node_id(item.id).to_def_id());\n+                v.process_impl_item(impl_item, map.local_def_id(hir_id).to_def_id());\n             }\n         });\n     }\n@@ -1410,7 +1409,10 @@ impl<'l, 'tcx> Visitor<'l> for DumpVisitor<'l, 'tcx> {\n             }\n             ast::TyKind::Array(ref element, ref length) => {\n                 self.visit_ty(element);\n-                self.nest_tables(length.id, |v| v.visit_expr(&length.value));\n+                let hir_id = self.tcx.hir().node_id_to_hir_id(length.id);\n+                self.nest_tables(self.tcx.hir().local_def_id(hir_id), |v| {\n+                    v.visit_expr(&length.value)\n+                });\n             }\n             ast::TyKind::ImplTrait(id, ref bounds) => {\n                 // FIXME: As of writing, the opaque type lowering introduces\n@@ -1422,7 +1424,13 @@ impl<'l, 'tcx> Visitor<'l> for DumpVisitor<'l, 'tcx> {\n                 // bounds...\n                 // This will panic if called on return type `impl Trait`, which\n                 // we guard against in `process_fn`.\n-                self.nest_tables(id, |v| v.process_bounds(bounds));\n+                // FIXME(#71104) Should really be using just `node_id_to_hir_id` but\n+                // some `NodeId` do not seem to have a corresponding HirId.\n+                if let Some(hir_id) = self.tcx.hir().opt_node_id_to_hir_id(id) {\n+                    self.nest_tables(self.tcx.hir().local_def_id(hir_id), |v| {\n+                        v.process_bounds(bounds)\n+                    });\n+                }\n             }\n             _ => visit::walk_ty(self, t),\n         }\n@@ -1470,7 +1478,8 @@ impl<'l, 'tcx> Visitor<'l> for DumpVisitor<'l, 'tcx> {\n                 }\n \n                 // walk the body\n-                self.nest_tables(ex.id, |v| {\n+                let hir_id = self.tcx.hir().node_id_to_hir_id(ex.id);\n+                self.nest_tables(self.tcx.hir().local_def_id(hir_id), |v| {\n                     v.process_formals(&decl.inputs, &id);\n                     v.visit_expr(body)\n                 });\n@@ -1487,7 +1496,10 @@ impl<'l, 'tcx> Visitor<'l> for DumpVisitor<'l, 'tcx> {\n             }\n             ast::ExprKind::Repeat(ref element, ref count) => {\n                 self.visit_expr(element);\n-                self.nest_tables(count.id, |v| v.visit_expr(&count.value));\n+                let hir_id = self.tcx.hir().node_id_to_hir_id(count.id);\n+                self.nest_tables(self.tcx.hir().local_def_id(hir_id), |v| {\n+                    v.visit_expr(&count.value)\n+                });\n             }\n             // In particular, we take this branch for call and path expressions,\n             // where we'll index the idents involved just by continuing to walk."}, {"sha": "d95eb5f28fe1bbcd3fb5e0aca7bc4bf2ff3bfd38", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e5a1be8597c21c7b547a02231e5cf072dd3a0179/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5a1be8597c21c7b547a02231e5cf072dd3a0179/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=e5a1be8597c21c7b547a02231e5cf072dd3a0179", "patch": "@@ -831,13 +831,6 @@ fn primary_body_of(\n }\n \n fn has_typeck_tables(tcx: TyCtxt<'_>, def_id: DefId) -> bool {\n-    // FIXME(#71104) some `LocalDefId` do not seem to have a corresponding `HirId`.\n-    if let Some(def_id) = def_id.as_local() {\n-        if tcx.hir().opt_local_def_id_to_hir_id(def_id).is_none() {\n-            return false;\n-        }\n-    }\n-\n     // Closures' tables come from their outermost function,\n     // as they are part of the same \"inference environment\".\n     let outer_def_id = tcx.closure_base_def_id(def_id);"}]}