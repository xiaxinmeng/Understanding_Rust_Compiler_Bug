{"sha": "fc2549b5769d044bf6b16b1ca833785969dc318b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZjMjU0OWI1NzY5ZDA0NGJmNmIxNmIxY2E4MzM3ODU5NjlkYzMxOGI=", "commit": {"author": {"name": "Nick Cameron", "email": "nrc@ncameron.org", "date": "2016-05-06T02:02:56Z"}, "committer": {"name": "Nick Cameron", "email": "nrc@ncameron.org", "date": "2016-05-06T02:02:56Z"}, "message": "Merge pull request #981 from DanielJCampbell/generated\n\nAltered FmtVisitor to function correctly on generated code", "tree": {"sha": "d976d07e7a278d8bf5abf38566bf21c06aad29e2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d976d07e7a278d8bf5abf38566bf21c06aad29e2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fc2549b5769d044bf6b16b1ca833785969dc318b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fc2549b5769d044bf6b16b1ca833785969dc318b", "html_url": "https://github.com/rust-lang/rust/commit/fc2549b5769d044bf6b16b1ca833785969dc318b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fc2549b5769d044bf6b16b1ca833785969dc318b/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b59b0497d3b2afe1d0109db0ac4474ed9b457a65", "url": "https://api.github.com/repos/rust-lang/rust/commits/b59b0497d3b2afe1d0109db0ac4474ed9b457a65", "html_url": "https://github.com/rust-lang/rust/commit/b59b0497d3b2afe1d0109db0ac4474ed9b457a65"}, {"sha": "238fc500ae7425b183fe72e8a3aee4c9cb640d3a", "url": "https://api.github.com/repos/rust-lang/rust/commits/238fc500ae7425b183fe72e8a3aee4c9cb640d3a", "html_url": "https://github.com/rust-lang/rust/commit/238fc500ae7425b183fe72e8a3aee4c9cb640d3a"}], "stats": {"total": 87, "additions": 48, "deletions": 39}, "files": [{"sha": "83108897684f3e1ae08cd93e391af5989a453ac1", "filename": "src/visitor.rs", "status": "modified", "additions": 48, "deletions": 39, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/fc2549b5769d044bf6b16b1ca833785969dc318b/src%2Fvisitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc2549b5769d044bf6b16b1ca833785969dc318b/src%2Fvisitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvisitor.rs?ref=fc2549b5769d044bf6b16b1ca833785969dc318b", "patch": "@@ -22,6 +22,14 @@ use comment::rewrite_comment;\n use macros::rewrite_macro;\n use items::{rewrite_static, rewrite_associated_type, rewrite_type_alias, format_impl, format_trait};\n \n+// For format_missing and last_pos, need to use the source callsite (if applicable).\n+// Required as generated code spans aren't guaranteed to follow on from the last span.\n+macro_rules! source {\n+    ($this:ident, $sp: expr) => {\n+        $this.codemap.source_callsite($sp)\n+    }\n+}\n+\n pub struct FmtVisitor<'a> {\n     pub parse_session: &'a ParseSess,\n     pub codemap: &'a CodeMap,\n@@ -55,7 +63,7 @@ impl<'a> FmtVisitor<'a> {\n                 self.push_rewrite(stmt.span, rewrite);\n             }\n             ast::StmtKind::Mac(ref mac, _macro_style, _) => {\n-                self.format_missing_with_indent(stmt.span.lo);\n+                self.format_missing_with_indent(source!(self, stmt.span).lo);\n                 self.visit_mac(mac, None);\n             }\n         }\n@@ -84,24 +92,24 @@ impl<'a> FmtVisitor<'a> {\n         }\n \n         if let Some(ref e) = b.expr {\n-            self.format_missing_with_indent(e.span.lo);\n+            self.format_missing_with_indent(source!(self, e.span).lo);\n             let rewrite = e.rewrite(&self.get_context(),\n                          self.config.max_width - self.block_indent.width(),\n                          self.block_indent)\n                 .unwrap_or_else(|| self.snippet(e.span));\n \n             self.buffer.push_str(&rewrite);\n-            self.last_pos = e.span.hi;\n+            self.last_pos = source!(self, e.span).hi;\n \n             if utils::semicolon_for_expr(e) {\n                 self.buffer.push_str(\";\");\n             }\n         }\n \n         // FIXME: we should compress any newlines here to just one\n-        self.format_missing_with_indent(b.span.hi - brace_compensation);\n+        self.format_missing_with_indent(source!(self, b.span).hi - brace_compensation);\n         self.close_block();\n-        self.last_pos = b.span.hi;\n+        self.last_pos = source!(self, b.span).hi;\n     }\n \n     // FIXME: this is a terrible hack to indent the comments between the last\n@@ -160,19 +168,19 @@ impl<'a> FmtVisitor<'a> {\n         };\n \n         if let Some(fn_str) = rewrite {\n-            self.format_missing_with_indent(s.lo);\n+            self.format_missing_with_indent(source!(self, s).lo);\n             self.buffer.push_str(&fn_str);\n             if let Some(c) = fn_str.chars().last() {\n                 if c == '}' {\n-                    self.last_pos = b.span.hi;\n+                    self.last_pos = source!(self, b.span).hi;\n                     return;\n                 }\n             }\n         } else {\n-            self.format_missing(b.span.lo);\n+            self.format_missing(source!(self, b.span).lo);\n         }\n \n-        self.last_pos = b.span.lo;\n+        self.last_pos = source!(self, b.span).lo;\n         self.visit_block(b)\n     }\n \n@@ -206,10 +214,10 @@ impl<'a> FmtVisitor<'a> {\n                 self.format_import(&item.vis, vp, item.span);\n             }\n             ast::ItemKind::Impl(..) => {\n-                self.format_missing_with_indent(item.span.lo);\n+                self.format_missing_with_indent(source!(self, item.span).lo);\n                 if let Some(impl_str) = format_impl(&self.get_context(), item, self.block_indent) {\n                     self.buffer.push_str(&impl_str);\n-                    self.last_pos = item.span.hi;\n+                    self.last_pos = source!(self, item.span).hi;\n                 }\n             }\n             ast::ItemKind::Trait(..) => {\n@@ -218,14 +226,14 @@ impl<'a> FmtVisitor<'a> {\n                                                       item,\n                                                       self.block_indent) {\n                     self.buffer.push_str(&trait_str);\n-                    self.last_pos = item.span.hi;\n+                    self.last_pos = source!(self, item.span).hi;\n                 }\n             }\n             ast::ItemKind::ExternCrate(_) => {\n-                self.format_missing_with_indent(item.span.lo);\n+                self.format_missing_with_indent(source!(self, item.span).lo);\n                 let new_str = self.snippet(item.span);\n                 self.buffer.push_str(&new_str);\n-                self.last_pos = item.span.hi;\n+                self.last_pos = source!(self, item.span).hi;\n             }\n             ast::ItemKind::Struct(ref def, ref generics) => {\n                 let rewrite = {\n@@ -249,20 +257,20 @@ impl<'a> FmtVisitor<'a> {\n                 self.push_rewrite(item.span, rewrite);\n             }\n             ast::ItemKind::Enum(ref def, ref generics) => {\n-                self.format_missing_with_indent(item.span.lo);\n+                self.format_missing_with_indent(source!(self, item.span).lo);\n                 self.visit_enum(item.ident, &item.vis, def, generics, item.span);\n-                self.last_pos = item.span.hi;\n+                self.last_pos = source!(self, item.span).hi;\n             }\n             ast::ItemKind::Mod(ref module) => {\n-                self.format_missing_with_indent(item.span.lo);\n+                self.format_missing_with_indent(source!(self, item.span).lo);\n                 self.format_mod(module, &item.vis, item.span, item.ident);\n             }\n             ast::ItemKind::Mac(ref mac) => {\n-                self.format_missing_with_indent(item.span.lo);\n+                self.format_missing_with_indent(source!(self, item.span).lo);\n                 self.visit_mac(mac, Some(item.ident));\n             }\n             ast::ItemKind::ForeignMod(ref foreign_mod) => {\n-                self.format_missing_with_indent(item.span.lo);\n+                self.format_missing_with_indent(source!(self, item.span).lo);\n                 self.format_foreign_mod(foreign_mod, item.span);\n             }\n             ast::ItemKind::Static(ref ty, mutability, ref expr) => {\n@@ -384,7 +392,7 @@ impl<'a> FmtVisitor<'a> {\n                 self.push_rewrite(ii.span, rewrite);\n             }\n             ast::ImplItemKind::Macro(ref mac) => {\n-                self.format_missing_with_indent(ii.span.lo);\n+                self.format_missing_with_indent(source!(self, ii.span).lo);\n                 self.visit_mac(mac, Some(ii.ident));\n             }\n         }\n@@ -397,15 +405,15 @@ impl<'a> FmtVisitor<'a> {\n \n         if let Some(res) = rewrite {\n             self.buffer.push_str(&res);\n-            self.last_pos = mac.span.hi;\n+            self.last_pos = source!(self, mac.span).hi;\n         }\n     }\n \n     fn push_rewrite(&mut self, span: Span, rewrite: Option<String>) {\n-        self.format_missing_with_indent(span.lo);\n+        self.format_missing_with_indent(source!(self, span).lo);\n         let result = rewrite.unwrap_or_else(|| self.snippet(span));\n         self.buffer.push_str(&result);\n-        self.last_pos = span.hi;\n+        self.last_pos = source!(self, span).hi;\n     }\n \n     pub fn from_codemap(parse_session: &'a ParseSess, config: &'a Config) -> FmtVisitor<'a> {\n@@ -449,15 +457,15 @@ impl<'a> FmtVisitor<'a> {\n         }\n \n         let first = &outers[0];\n-        self.format_missing_with_indent(first.span.lo);\n+        self.format_missing_with_indent(source!(self, first.span).lo);\n \n         let rewrite = outers.rewrite(&self.get_context(),\n                      self.config.max_width - self.block_indent.width(),\n                      self.block_indent)\n             .unwrap();\n         self.buffer.push_str(&rewrite);\n         let last = outers.last().unwrap();\n-        self.last_pos = last.span.hi;\n+        self.last_pos = source!(self, last.span).hi;\n         false\n     }\n \n@@ -470,7 +478,7 @@ impl<'a> FmtVisitor<'a> {\n     fn format_mod(&mut self, m: &ast::Mod, vis: &ast::Visibility, s: Span, ident: ast::Ident) {\n         // Decide whether this is an inline mod or an external mod.\n         let local_file_name = self.codemap.span_to_filename(s);\n-        let is_internal = local_file_name == self.codemap.span_to_filename(m.inner);\n+        let is_internal = local_file_name == self.codemap.span_to_filename(source!(self, m.inner));\n \n         if let Some(vis) = utils::format_visibility(vis) {\n             self.buffer.push_str(vis);\n@@ -481,27 +489,28 @@ impl<'a> FmtVisitor<'a> {\n         if is_internal {\n             self.buffer.push_str(\" {\");\n             // Hackery to account for the closing }.\n-            let mod_lo = self.codemap.span_after(s, \"{\");\n-            let body_snippet = self.snippet(codemap::mk_sp(mod_lo, m.inner.hi - BytePos(1)));\n+            let mod_lo = self.codemap.span_after(source!(self, s), \"{\");\n+            let body_snippet =\n+                self.snippet(codemap::mk_sp(mod_lo, source!(self, m.inner).hi - BytePos(1)));\n             let body_snippet = body_snippet.trim();\n             if body_snippet.is_empty() {\n                 self.buffer.push_str(\"}\");\n             } else {\n                 self.last_pos = mod_lo;\n                 self.block_indent = self.block_indent.block_indent(self.config);\n                 self.walk_mod_items(m);\n-                self.format_missing_with_indent(m.inner.hi - BytePos(1));\n+                self.format_missing_with_indent(source!(self, m.inner).hi - BytePos(1));\n                 self.close_block();\n             }\n-            self.last_pos = m.inner.hi;\n+            self.last_pos = source!(self, m.inner).hi;\n         } else {\n             self.buffer.push_str(\";\");\n-            self.last_pos = s.hi;\n+            self.last_pos = source!(self, s).hi;\n         }\n     }\n \n     pub fn format_separate_mod(&mut self, m: &ast::Mod) {\n-        let filemap = self.codemap.lookup_char_pos(m.inner.lo).file;\n+        let filemap = self.codemap.lookup_char_pos(source!(self, m.inner).lo).file;\n         self.last_pos = filemap.start_pos;\n         self.block_indent = Indent::empty();\n         self.walk_mod_items(m);\n@@ -521,23 +530,23 @@ impl<'a> FmtVisitor<'a> {\n                          offset) {\n             Some(ref s) if s.is_empty() => {\n                 // Format up to last newline\n-                let prev_span = codemap::mk_sp(self.last_pos, span.lo);\n+                let prev_span = codemap::mk_sp(self.last_pos, source!(self, span).lo);\n                 let span_end = match self.snippet(prev_span).rfind('\\n') {\n                     Some(offset) => self.last_pos + BytePos(offset as u32),\n-                    None => span.lo,\n+                    None => source!(self, span).lo,\n                 };\n                 self.format_missing(span_end);\n-                self.last_pos = span.hi;\n+                self.last_pos = source!(self, span).hi;\n             }\n             Some(ref s) => {\n                 let s = format!(\"{}use {};\", vis, s);\n-                self.format_missing_with_indent(span.lo);\n+                self.format_missing_with_indent(source!(self, span).lo);\n                 self.buffer.push_str(&s);\n-                self.last_pos = span.hi;\n+                self.last_pos = source!(self, span).hi;\n             }\n             None => {\n-                self.format_missing_with_indent(span.lo);\n-                self.format_missing(span.hi);\n+                self.format_missing_with_indent(source!(self, span).lo);\n+                self.format_missing(source!(self, span).hi);\n             }\n         }\n     }"}]}