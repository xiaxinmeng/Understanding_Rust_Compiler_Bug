{"sha": "0047dbe59c41b951d34ce6324f3a8c0e15d523e9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAwNDdkYmU1OWM0MWI5NTFkMzRjZTYzMjRmM2E4YzBlMTVkNTIzZTk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-11-17T11:22:00Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-11-17T11:22:00Z"}, "message": "auto merge of #19027 : nick29581/rust/coercions-4, r=alexcrichton\n\nThe forwards compatible parts of #18645, rebased. Converts implicit coercions from `[T, ..n]` to `&[T]` into explicit references.", "tree": {"sha": "e4f717adb4830ca6e737a23c81abbab3bb3a80b5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e4f717adb4830ca6e737a23c81abbab3bb3a80b5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0047dbe59c41b951d34ce6324f3a8c0e15d523e9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0047dbe59c41b951d34ce6324f3a8c0e15d523e9", "html_url": "https://github.com/rust-lang/rust/commit/0047dbe59c41b951d34ce6324f3a8c0e15d523e9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "edfb83c9e28df2a8f326d688f3d5b1f6faa72db8", "url": "https://api.github.com/repos/rust-lang/rust/commits/edfb83c9e28df2a8f326d688f3d5b1f6faa72db8", "html_url": "https://github.com/rust-lang/rust/commit/edfb83c9e28df2a8f326d688f3d5b1f6faa72db8"}, {"sha": "ca08540a0039e827114752d11166ea8cb1387068", "url": "https://api.github.com/repos/rust-lang/rust/commits/ca08540a0039e827114752d11166ea8cb1387068", "html_url": "https://github.com/rust-lang/rust/commit/ca08540a0039e827114752d11166ea8cb1387068"}], "stats": {"total": 2556, "additions": 1271, "deletions": 1285}, "files": [{"sha": "c56424159f4832f9a3d10bb8698723efba598535", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=0047dbe59c41b951d34ce6324f3a8c0e15d523e9", "patch": "@@ -399,7 +399,7 @@ fn run_debuginfo_gdb_test(config: &Config, props: &TestProps, testfile: &Path) {\n             procsrv::run(\"\",\n                          config.adb_path.as_slice(),\n                          None,\n-                         [\n+                         &[\n                             \"push\".to_string(),\n                             exe_file.as_str().unwrap().to_string(),\n                             config.adb_test_dir.clone()\n@@ -411,7 +411,7 @@ fn run_debuginfo_gdb_test(config: &Config, props: &TestProps, testfile: &Path) {\n             procsrv::run(\"\",\n                          config.adb_path.as_slice(),\n                          None,\n-                         [\n+                         &[\n                             \"forward\".to_string(),\n                             \"tcp:5039\".to_string(),\n                             \"tcp:5039\".to_string()\n@@ -432,7 +432,7 @@ fn run_debuginfo_gdb_test(config: &Config, props: &TestProps, testfile: &Path) {\n                                                       config.adb_path\n                                                             .as_slice(),\n                                                       None,\n-                                                      [\n+                                                      &[\n                                                         \"shell\".to_string(),\n                                                         adb_arg.clone()\n                                                       ],\n@@ -746,7 +746,7 @@ fn run_debuginfo_lldb_test(config: &Config, props: &TestProps, testfile: &Path)\n         cmd.arg(lldb_script_path)\n            .arg(test_executable)\n            .arg(debugger_script)\n-           .env_set_all([(\"PYTHONPATH\", config.lldb_python_dir.clone().unwrap().as_slice())]);\n+           .env_set_all(&[(\"PYTHONPATH\", config.lldb_python_dir.clone().unwrap().as_slice())]);\n \n         let (status, out, err) = match cmd.spawn() {\n             Ok(process) => {\n@@ -1142,11 +1142,11 @@ struct ProcRes {\n \n fn compile_test(config: &Config, props: &TestProps,\n                 testfile: &Path) -> ProcRes {\n-    compile_test_(config, props, testfile, [])\n+    compile_test_(config, props, testfile, &[])\n }\n \n fn jit_test(config: &Config, props: &TestProps, testfile: &Path) -> ProcRes {\n-    compile_test_(config, props, testfile, [\"--jit\".to_string()])\n+    compile_test_(config, props, testfile, &[\"--jit\".to_string()])\n }\n \n fn compile_test_(config: &Config, props: &TestProps,\n@@ -1507,7 +1507,7 @@ fn _arm_exec_compiled_test(config: &Config,\n     let copy_result = procsrv::run(\"\",\n                                    config.adb_path.as_slice(),\n                                    None,\n-                                   [\n+                                   &[\n                                     \"push\".to_string(),\n                                     args.prog.clone(),\n                                     config.adb_test_dir.clone()\n@@ -1624,7 +1624,7 @@ fn _arm_push_aux_shared_library(config: &Config, testfile: &Path) {\n             let copy_result = procsrv::run(\"\",\n                                            config.adb_path.as_slice(),\n                                            None,\n-                                           [\n+                                           &[\n                                             \"push\".to_string(),\n                                             file.as_str()\n                                                 .unwrap()"}, {"sha": "a3bf810dde180f46081420ab0d21c8931d7b54df", "filename": "src/doc/guide-testing.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Fdoc%2Fguide-testing.md", "raw_url": "https://github.com/rust-lang/rust/raw/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Fdoc%2Fguide-testing.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide-testing.md?ref=0047dbe59c41b951d34ce6324f3a8c0e15d523e9", "patch": "@@ -84,7 +84,7 @@ will be counted as a failure. For example:\n #[test]\n #[should_fail]\n fn test_out_of_bounds_failure() {\n-    let v: &[int] = [];\n+    let v: &[int] = &[];\n     v[0];\n }\n ~~~"}, {"sha": "76b929746d653f65cf26b8e476b81e6a1f118806", "filename": "src/libcollections/bit.rs", "status": "modified", "additions": 159, "deletions": 159, "changes": 318, "blob_url": "https://github.com/rust-lang/rust/blob/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibcollections%2Fbit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibcollections%2Fbit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbit.rs?ref=0047dbe59c41b951d34ce6324f3a8c0e15d523e9", "patch": "@@ -267,7 +267,7 @@ impl Bitv {\n     /// ```\n     /// use std::collections::bitv;\n     ///\n-    /// let bv = bitv::from_bytes([0b01100000]);\n+    /// let bv = bitv::from_bytes(&[0b01100000]);\n     /// assert_eq!(bv.get(0), false);\n     /// assert_eq!(bv.get(1), true);\n     ///\n@@ -319,9 +319,9 @@ impl Bitv {\n     /// let before = 0b01100000;\n     /// let after  = 0b11111111;\n     ///\n-    /// let mut bv = bitv::from_bytes([before]);\n+    /// let mut bv = bitv::from_bytes(&[before]);\n     /// bv.set_all();\n-    /// assert_eq!(bv, bitv::from_bytes([after]));\n+    /// assert_eq!(bv, bitv::from_bytes(&[after]));\n     /// ```\n     #[inline]\n     pub fn set_all(&mut self) {\n@@ -338,9 +338,9 @@ impl Bitv {\n     /// let before = 0b01100000;\n     /// let after  = 0b10011111;\n     ///\n-    /// let mut bv = bitv::from_bytes([before]);\n+    /// let mut bv = bitv::from_bytes(&[before]);\n     /// bv.negate();\n-    /// assert_eq!(bv, bitv::from_bytes([after]));\n+    /// assert_eq!(bv, bitv::from_bytes(&[after]));\n     /// ```\n     #[inline]\n     pub fn negate(&mut self) {\n@@ -366,11 +366,11 @@ impl Bitv {\n     /// let b   = 0b01011010;\n     /// let res = 0b01111110;\n     ///\n-    /// let mut a = bitv::from_bytes([a]);\n-    /// let b = bitv::from_bytes([b]);\n+    /// let mut a = bitv::from_bytes(&[a]);\n+    /// let b = bitv::from_bytes(&[b]);\n     ///\n     /// assert!(a.union(&b));\n-    /// assert_eq!(a, bitv::from_bytes([res]));\n+    /// assert_eq!(a, bitv::from_bytes(&[res]));\n     /// ```\n     #[inline]\n     pub fn union(&mut self, other: &Bitv) -> bool {\n@@ -396,11 +396,11 @@ impl Bitv {\n     /// let b   = 0b01011010;\n     /// let res = 0b01000000;\n     ///\n-    /// let mut a = bitv::from_bytes([a]);\n-    /// let b = bitv::from_bytes([b]);\n+    /// let mut a = bitv::from_bytes(&[a]);\n+    /// let b = bitv::from_bytes(&[b]);\n     ///\n     /// assert!(a.intersect(&b));\n-    /// assert_eq!(a, bitv::from_bytes([res]));\n+    /// assert_eq!(a, bitv::from_bytes(&[res]));\n     /// ```\n     #[inline]\n     pub fn intersect(&mut self, other: &Bitv) -> bool {\n@@ -427,17 +427,17 @@ impl Bitv {\n     /// let a_b = 0b00100100; // a - b\n     /// let b_a = 0b00011010; // b - a\n     ///\n-    /// let mut bva = bitv::from_bytes([a]);\n-    /// let bvb = bitv::from_bytes([b]);\n+    /// let mut bva = bitv::from_bytes(&[a]);\n+    /// let bvb = bitv::from_bytes(&[b]);\n     ///\n     /// assert!(bva.difference(&bvb));\n-    /// assert_eq!(bva, bitv::from_bytes([a_b]));\n+    /// assert_eq!(bva, bitv::from_bytes(&[a_b]));\n     ///\n-    /// let bva = bitv::from_bytes([a]);\n-    /// let mut bvb = bitv::from_bytes([b]);\n+    /// let bva = bitv::from_bytes(&[a]);\n+    /// let mut bvb = bitv::from_bytes(&[b]);\n     ///\n     /// assert!(bvb.difference(&bva));\n-    /// assert_eq!(bvb, bitv::from_bytes([b_a]));\n+    /// assert_eq!(bvb, bitv::from_bytes(&[b_a]));\n     /// ```\n     #[inline]\n     pub fn difference(&mut self, other: &Bitv) -> bool {\n@@ -474,7 +474,7 @@ impl Bitv {\n     /// ```\n     /// use std::collections::bitv;\n     ///\n-    /// let bv = bitv::from_bytes([0b01110100, 0b10010010]);\n+    /// let bv = bitv::from_bytes(&[0b01110100, 0b10010010]);\n     /// assert_eq!(bv.iter().filter(|x| *x).count(), 7);\n     /// ```\n     #[inline]\n@@ -569,7 +569,7 @@ impl Bitv {\n     /// ```\n     /// use std::collections::bitv;\n     ///\n-    /// let bv = bitv::from_bytes([0b10100000]);\n+    /// let bv = bitv::from_bytes(&[0b10100000]);\n     /// assert_eq!(bv.to_bools(), vec!(true, false, true, false,\n     ///                                false, false, false, false));\n     /// ```\n@@ -589,10 +589,10 @@ impl Bitv {\n     /// ```\n     /// use std::collections::bitv;\n     ///\n-    /// let bv = bitv::from_bytes([0b10100000]);\n+    /// let bv = bitv::from_bytes(&[0b10100000]);\n     ///\n-    /// assert!(bv.eq_vec([true, false, true, false,\n-    ///                    false, false, false, false]));\n+    /// assert!(bv.eq_vec(&[true, false, true, false,\n+    ///                     false, false, false, false]));\n     /// ```\n     pub fn eq_vec(&self, v: &[bool]) -> bool {\n         assert_eq!(self.nbits, v.len());\n@@ -614,9 +614,9 @@ impl Bitv {\n     /// ```\n     /// use std::collections::bitv;\n     ///\n-    /// let mut bv = bitv::from_bytes([0b01001011]);\n+    /// let mut bv = bitv::from_bytes(&[0b01001011]);\n     /// bv.truncate(2);\n-    /// assert!(bv.eq_vec([false, true]));\n+    /// assert!(bv.eq_vec(&[false, true]));\n     /// ```\n     #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n     pub fn truncate(&mut self, len: uint) {\n@@ -675,7 +675,7 @@ impl Bitv {\n     /// ```\n     /// use std::collections::bitv;\n     ///\n-    /// let mut bv = bitv::from_bytes([0b01001011]);\n+    /// let mut bv = bitv::from_bytes(&[0b01001011]);\n     /// bv.grow(2, true);\n     /// assert_eq!(bv.len(), 10);\n     /// assert_eq!(bv.to_bytes(), vec!(0b01001011, 0b11000000));\n@@ -727,7 +727,7 @@ impl Bitv {\n     /// ```\n     /// use std::collections::bitv;\n     ///\n-    /// let mut bv = bitv::from_bytes([0b01001001]);\n+    /// let mut bv = bitv::from_bytes(&[0b01001001]);\n     /// assert_eq!(bv.pop(), true);\n     /// assert_eq!(bv.pop(), false);\n     /// assert_eq!(bv.len(), 6);\n@@ -753,7 +753,7 @@ impl Bitv {\n     /// let mut bv = Bitv::new();\n     /// bv.push(true);\n     /// bv.push(false);\n-    /// assert!(bv.eq_vec([true, false]));\n+    /// assert!(bv.eq_vec(&[true, false]));\n     /// ```\n     pub fn push(&mut self, elem: bool) {\n         let insert_pos = self.nbits;\n@@ -791,11 +791,11 @@ impl Bitv {\n /// ```\n /// use std::collections::bitv;\n ///\n-/// let bv = bitv::from_bytes([0b10100000, 0b00010010]);\n-/// assert!(bv.eq_vec([true, false, true, false,\n-///                    false, false, false, false,\n-///                    false, false, false, true,\n-///                    false, false, true, false]));\n+/// let bv = bitv::from_bytes(&[0b10100000, 0b00010010]);\n+/// assert!(bv.eq_vec(&[true, false, true, false,\n+///                     false, false, false, false,\n+///                     false, false, false, true,\n+///                     false, false, true, false]));\n /// ```\n pub fn from_bytes(bytes: &[u8]) -> Bitv {\n     from_fn(bytes.len() * 8, |i| {\n@@ -814,7 +814,7 @@ pub fn from_bytes(bytes: &[u8]) -> Bitv {\n /// use std::collections::bitv::from_fn;\n ///\n /// let bv = from_fn(5, |i| { i % 2 == 0 });\n-/// assert!(bv.eq_vec([true, false, true, false, true]));\n+/// assert!(bv.eq_vec(&[true, false, true, false, true]));\n /// ```\n pub fn from_fn(len: uint, f: |index: uint| -> bool) -> Bitv {\n     let mut bitv = Bitv::with_capacity(len, false);\n@@ -987,7 +987,7 @@ impl<'a> RandomAccessIterator<bool> for Bits<'a> {\n /// }\n ///\n /// // Can initialize from a `Bitv`\n-/// let other = BitvSet::from_bitv(bitv::from_bytes([0b11010000]));\n+/// let other = BitvSet::from_bitv(bitv::from_bytes(&[0b11010000]));\n ///\n /// s.union_with(&other);\n ///\n@@ -1089,7 +1089,7 @@ impl BitvSet {\n     /// ```\n     /// use std::collections::{bitv, BitvSet};\n     ///\n-    /// let bv = bitv::from_bytes([0b01100000]);\n+    /// let bv = bitv::from_bytes(&[0b01100000]);\n     /// let s = BitvSet::from_bitv(bv);\n     ///\n     /// // Print 1, 2 in arbitrary order\n@@ -1244,7 +1244,7 @@ impl BitvSet {\n     /// use std::collections::BitvSet;\n     /// use std::collections::bitv;\n     ///\n-    /// let s = BitvSet::from_bitv(bitv::from_bytes([0b01001010]));\n+    /// let s = BitvSet::from_bitv(bitv::from_bytes(&[0b01001010]));\n     ///\n     /// // Print 1, 4, 6 in arbitrary order\n     /// for x in s.iter() {\n@@ -1266,8 +1266,8 @@ impl BitvSet {\n     /// use std::collections::BitvSet;\n     /// use std::collections::bitv;\n     ///\n-    /// let a = BitvSet::from_bitv(bitv::from_bytes([0b01101000]));\n-    /// let b = BitvSet::from_bitv(bitv::from_bytes([0b10100000]));\n+    /// let a = BitvSet::from_bitv(bitv::from_bytes(&[0b01101000]));\n+    /// let b = BitvSet::from_bitv(bitv::from_bytes(&[0b10100000]));\n     ///\n     /// // Print 0, 1, 2, 4 in arbitrary order\n     /// for x in a.union(&b) {\n@@ -1295,8 +1295,8 @@ impl BitvSet {\n     /// use std::collections::BitvSet;\n     /// use std::collections::bitv;\n     ///\n-    /// let a = BitvSet::from_bitv(bitv::from_bytes([0b01101000]));\n-    /// let b = BitvSet::from_bitv(bitv::from_bytes([0b10100000]));\n+    /// let a = BitvSet::from_bitv(bitv::from_bytes(&[0b01101000]));\n+    /// let b = BitvSet::from_bitv(bitv::from_bytes(&[0b10100000]));\n     ///\n     /// // Print 2\n     /// for x in a.intersection(&b) {\n@@ -1325,8 +1325,8 @@ impl BitvSet {\n     /// use std::collections::BitvSet;\n     /// use std::collections::bitv;\n     ///\n-    /// let a = BitvSet::from_bitv(bitv::from_bytes([0b01101000]));\n-    /// let b = BitvSet::from_bitv(bitv::from_bytes([0b10100000]));\n+    /// let a = BitvSet::from_bitv(bitv::from_bytes(&[0b01101000]));\n+    /// let b = BitvSet::from_bitv(bitv::from_bytes(&[0b10100000]));\n     ///\n     /// // Print 1, 4 in arbitrary order\n     /// for x in a.difference(&b) {\n@@ -1362,8 +1362,8 @@ impl BitvSet {\n     /// use std::collections::BitvSet;\n     /// use std::collections::bitv;\n     ///\n-    /// let a = BitvSet::from_bitv(bitv::from_bytes([0b01101000]));\n-    /// let b = BitvSet::from_bitv(bitv::from_bytes([0b10100000]));\n+    /// let a = BitvSet::from_bitv(bitv::from_bytes(&[0b01101000]));\n+    /// let b = BitvSet::from_bitv(bitv::from_bytes(&[0b10100000]));\n     ///\n     /// // Print 0, 1, 4 in arbitrary order\n     /// for x in a.symmetric_difference(&b) {\n@@ -1394,9 +1394,9 @@ impl BitvSet {\n     /// let b   = 0b10100000;\n     /// let res = 0b11101000;\n     ///\n-    /// let mut a = BitvSet::from_bitv(bitv::from_bytes([a]));\n-    /// let b = BitvSet::from_bitv(bitv::from_bytes([b]));\n-    /// let res = BitvSet::from_bitv(bitv::from_bytes([res]));\n+    /// let mut a = BitvSet::from_bitv(bitv::from_bytes(&[a]));\n+    /// let b = BitvSet::from_bitv(bitv::from_bytes(&[b]));\n+    /// let res = BitvSet::from_bitv(bitv::from_bytes(&[res]));\n     ///\n     /// a.union_with(&b);\n     /// assert_eq!(a, res);\n@@ -1418,9 +1418,9 @@ impl BitvSet {\n     /// let b   = 0b10100000;\n     /// let res = 0b00100000;\n     ///\n-    /// let mut a = BitvSet::from_bitv(bitv::from_bytes([a]));\n-    /// let b = BitvSet::from_bitv(bitv::from_bytes([b]));\n-    /// let res = BitvSet::from_bitv(bitv::from_bytes([res]));\n+    /// let mut a = BitvSet::from_bitv(bitv::from_bytes(&[a]));\n+    /// let b = BitvSet::from_bitv(bitv::from_bytes(&[b]));\n+    /// let res = BitvSet::from_bitv(bitv::from_bytes(&[res]));\n     ///\n     /// a.intersect_with(&b);\n     /// assert_eq!(a, res);\n@@ -1444,16 +1444,16 @@ impl BitvSet {\n     /// let a_b = 0b01001000; // a - b\n     /// let b_a = 0b10000000; // b - a\n     ///\n-    /// let mut bva = BitvSet::from_bitv(bitv::from_bytes([a]));\n-    /// let bvb = BitvSet::from_bitv(bitv::from_bytes([b]));\n-    /// let bva_b = BitvSet::from_bitv(bitv::from_bytes([a_b]));\n-    /// let bvb_a = BitvSet::from_bitv(bitv::from_bytes([b_a]));\n+    /// let mut bva = BitvSet::from_bitv(bitv::from_bytes(&[a]));\n+    /// let bvb = BitvSet::from_bitv(bitv::from_bytes(&[b]));\n+    /// let bva_b = BitvSet::from_bitv(bitv::from_bytes(&[a_b]));\n+    /// let bvb_a = BitvSet::from_bitv(bitv::from_bytes(&[b_a]));\n     ///\n     /// bva.difference_with(&bvb);\n     /// assert_eq!(bva, bva_b);\n     ///\n-    /// let bva = BitvSet::from_bitv(bitv::from_bytes([a]));\n-    /// let mut bvb = BitvSet::from_bitv(bitv::from_bytes([b]));\n+    /// let bva = BitvSet::from_bitv(bitv::from_bytes(&[a]));\n+    /// let mut bvb = BitvSet::from_bitv(bitv::from_bytes(&[b]));\n     ///\n     /// bvb.difference_with(&bva);\n     /// assert_eq!(bvb, bvb_a);\n@@ -1476,9 +1476,9 @@ impl BitvSet {\n     /// let b   = 0b10100000;\n     /// let res = 0b11001000;\n     ///\n-    /// let mut a = BitvSet::from_bitv(bitv::from_bytes([a]));\n-    /// let b = BitvSet::from_bitv(bitv::from_bytes([b]));\n-    /// let res = BitvSet::from_bitv(bitv::from_bytes([res]));\n+    /// let mut a = BitvSet::from_bitv(bitv::from_bytes(&[a]));\n+    /// let b = BitvSet::from_bitv(bitv::from_bytes(&[b]));\n+    /// let res = BitvSet::from_bitv(bitv::from_bytes(&[res]));\n     ///\n     /// a.symmetric_difference_with(&b);\n     /// assert_eq!(a, res);\n@@ -1708,9 +1708,9 @@ mod tests {\n     #[test]\n     fn test_1_element() {\n         let mut act = Bitv::with_capacity(1u, false);\n-        assert!(act.eq_vec([false]));\n+        assert!(act.eq_vec(&[false]));\n         act = Bitv::with_capacity(1u, true);\n-        assert!(act.eq_vec([true]));\n+        assert!(act.eq_vec(&[true]));\n     }\n \n     #[test]\n@@ -1728,11 +1728,11 @@ mod tests {\n \n         act = Bitv::with_capacity(10u, false);\n         assert!((act.eq_vec(\n-                    [false, false, false, false, false, false, false, false, false, false])));\n+                    &[false, false, false, false, false, false, false, false, false, false])));\n         // all 1\n \n         act = Bitv::with_capacity(10u, true);\n-        assert!((act.eq_vec([true, true, true, true, true, true, true, true, true, true])));\n+        assert!((act.eq_vec(&[true, true, true, true, true, true, true, true, true, true])));\n         // mixed\n \n         act = Bitv::with_capacity(10u, false);\n@@ -1741,7 +1741,7 @@ mod tests {\n         act.set(2u, true);\n         act.set(3u, true);\n         act.set(4u, true);\n-        assert!((act.eq_vec([true, true, true, true, true, false, false, false, false, false])));\n+        assert!((act.eq_vec(&[true, true, true, true, true, false, false, false, false, false])));\n         // mixed\n \n         act = Bitv::with_capacity(10u, false);\n@@ -1750,15 +1750,15 @@ mod tests {\n         act.set(7u, true);\n         act.set(8u, true);\n         act.set(9u, true);\n-        assert!((act.eq_vec([false, false, false, false, false, true, true, true, true, true])));\n+        assert!((act.eq_vec(&[false, false, false, false, false, true, true, true, true, true])));\n         // mixed\n \n         act = Bitv::with_capacity(10u, false);\n         act.set(0u, true);\n         act.set(3u, true);\n         act.set(6u, true);\n         act.set(9u, true);\n-        assert!((act.eq_vec([true, false, false, true, false, false, true, false, false, true])));\n+        assert!((act.eq_vec(&[true, false, false, true, false, false, true, false, false, true])));\n     }\n \n     #[test]\n@@ -1768,16 +1768,16 @@ mod tests {\n \n         act = Bitv::with_capacity(31u, false);\n         assert!(act.eq_vec(\n-                [false, false, false, false, false, false, false, false, false, false, false,\n-                false, false, false, false, false, false, false, false, false, false, false, false,\n-                false, false, false, false, false, false, false, false]));\n+                &[false, false, false, false, false, false, false, false, false, false, false,\n+                  false, false, false, false, false, false, false, false, false, false, false,\n+                  false, false, false, false, false, false, false, false, false]));\n         // all 1\n \n         act = Bitv::with_capacity(31u, true);\n         assert!(act.eq_vec(\n-                [true, true, true, true, true, true, true, true, true, true, true, true, true,\n-                true, true, true, true, true, true, true, true, true, true, true, true, true, true,\n-                true, true, true, true]));\n+                &[true, true, true, true, true, true, true, true, true, true, true, true, true,\n+                  true, true, true, true, true, true, true, true, true, true, true, true, true,\n+                  true, true, true, true, true]));\n         // mixed\n \n         act = Bitv::with_capacity(31u, false);\n@@ -1790,9 +1790,9 @@ mod tests {\n         act.set(6u, true);\n         act.set(7u, true);\n         assert!(act.eq_vec(\n-                [true, true, true, true, true, true, true, true, false, false, false, false, false,\n-                false, false, false, false, false, false, false, false, false, false, false, false,\n-                false, false, false, false, false, false]));\n+                &[true, true, true, true, true, true, true, true, false, false, false, false, false,\n+                  false, false, false, false, false, false, false, false, false, false, false,\n+                  false, false, false, false, false, false, false]));\n         // mixed\n \n         act = Bitv::with_capacity(31u, false);\n@@ -1805,9 +1805,9 @@ mod tests {\n         act.set(22u, true);\n         act.set(23u, true);\n         assert!(act.eq_vec(\n-                [false, false, false, false, false, false, false, false, false, false, false,\n-                false, false, false, false, false, true, true, true, true, true, true, true, true,\n-                false, false, false, false, false, false, false]));\n+                &[false, false, false, false, false, false, false, false, false, false, false,\n+                  false, false, false, false, false, true, true, true, true, true, true, true, true,\n+                  false, false, false, false, false, false, false]));\n         // mixed\n \n         act = Bitv::with_capacity(31u, false);\n@@ -1819,19 +1819,19 @@ mod tests {\n         act.set(29u, true);\n         act.set(30u, true);\n         assert!(act.eq_vec(\n-                [false, false, false, false, false, false, false, false, false, false, false,\n-                false, false, false, false, false, false, false, false, false, false, false, false,\n-                false, true, true, true, true, true, true, true]));\n+                &[false, false, false, false, false, false, false, false, false, false, false,\n+                  false, false, false, false, false, false, false, false, false, false, false,\n+                  false, false, true, true, true, true, true, true, true]));\n         // mixed\n \n         act = Bitv::with_capacity(31u, false);\n         act.set(3u, true);\n         act.set(17u, true);\n         act.set(30u, true);\n         assert!(act.eq_vec(\n-                [false, false, false, true, false, false, false, false, false, false, false, false,\n-                false, false, false, false, false, true, false, false, false, false, false, false,\n-                false, false, false, false, false, false, true]));\n+                &[false, false, false, true, false, false, false, false, false, false, false, false,\n+                  false, false, false, false, false, true, false, false, false, false, false, false,\n+                  false, false, false, false, false, false, true]));\n     }\n \n     #[test]\n@@ -1841,16 +1841,16 @@ mod tests {\n \n         act = Bitv::with_capacity(32u, false);\n         assert!(act.eq_vec(\n-                [false, false, false, false, false, false, false, false, false, false, false,\n-                false, false, false, false, false, false, false, false, false, false, false, false,\n-                false, false, false, false, false, false, false, false, false]));\n+                &[false, false, false, false, false, false, false, false, false, false, false,\n+                  false, false, false, false, false, false, false, false, false, false, false,\n+                  false, false, false, false, false, false, false, false, false, false]));\n         // all 1\n \n         act = Bitv::with_capacity(32u, true);\n         assert!(act.eq_vec(\n-                [true, true, true, true, true, true, true, true, true, true, true, true, true,\n-                true, true, true, true, true, true, true, true, true, true, true, true, true, true,\n-                true, true, true, true, true]));\n+                &[true, true, true, true, true, true, true, true, true, true, true, true, true,\n+                  true, true, true, true, true, true, true, true, true, true, true, true, true,\n+                  true, true, true, true, true, true]));\n         // mixed\n \n         act = Bitv::with_capacity(32u, false);\n@@ -1863,9 +1863,9 @@ mod tests {\n         act.set(6u, true);\n         act.set(7u, true);\n         assert!(act.eq_vec(\n-                [true, true, true, true, true, true, true, true, false, false, false, false, false,\n-                false, false, false, false, false, false, false, false, false, false, false, false,\n-                false, false, false, false, false, false, false]));\n+                &[true, true, true, true, true, true, true, true, false, false, false, false, false,\n+                  false, false, false, false, false, false, false, false, false, false, false,\n+                  false, false, false, false, false, false, false, false]));\n         // mixed\n \n         act = Bitv::with_capacity(32u, false);\n@@ -1878,9 +1878,9 @@ mod tests {\n         act.set(22u, true);\n         act.set(23u, true);\n         assert!(act.eq_vec(\n-                [false, false, false, false, false, false, false, false, false, false, false,\n-                false, false, false, false, false, true, true, true, true, true, true, true, true,\n-                false, false, false, false, false, false, false, false]));\n+                &[false, false, false, false, false, false, false, false, false, false, false,\n+                  false, false, false, false, false, true, true, true, true, true, true, true, true,\n+                  false, false, false, false, false, false, false, false]));\n         // mixed\n \n         act = Bitv::with_capacity(32u, false);\n@@ -1893,9 +1893,9 @@ mod tests {\n         act.set(30u, true);\n         act.set(31u, true);\n         assert!(act.eq_vec(\n-                [false, false, false, false, false, false, false, false, false, false, false,\n-                false, false, false, false, false, false, false, false, false, false, false, false,\n-                false, true, true, true, true, true, true, true, true]));\n+                &[false, false, false, false, false, false, false, false, false, false, false,\n+                  false, false, false, false, false, false, false, false, false, false, false,\n+                  false, false, true, true, true, true, true, true, true, true]));\n         // mixed\n \n         act = Bitv::with_capacity(32u, false);\n@@ -1904,9 +1904,9 @@ mod tests {\n         act.set(30u, true);\n         act.set(31u, true);\n         assert!(act.eq_vec(\n-                [false, false, false, true, false, false, false, false, false, false, false, false,\n-                false, false, false, false, false, true, false, false, false, false, false, false,\n-                false, false, false, false, false, false, true, true]));\n+                &[false, false, false, true, false, false, false, false, false, false, false, false,\n+                  false, false, false, false, false, true, false, false, false, false, false, false,\n+                  false, false, false, false, false, false, true, true]));\n     }\n \n     #[test]\n@@ -1916,16 +1916,16 @@ mod tests {\n \n         act = Bitv::with_capacity(33u, false);\n         assert!(act.eq_vec(\n-                [false, false, false, false, false, false, false, false, false, false, false,\n-                false, false, false, false, false, false, false, false, false, false, false, false,\n-                false, false, false, false, false, false, false, false, false, false]));\n+                &[false, false, false, false, false, false, false, false, false, false, false,\n+                  false, false, false, false, false, false, false, false, false, false, false,\n+                  false, false, false, false, false, false, false, false, false, false, false]));\n         // all 1\n \n         act = Bitv::with_capacity(33u, true);\n         assert!(act.eq_vec(\n-                [true, true, true, true, true, true, true, true, true, true, true, true, true,\n-                true, true, true, true, true, true, true, true, true, true, true, true, true, true,\n-                true, true, true, true, true, true]));\n+                &[true, true, true, true, true, true, true, true, true, true, true, true, true,\n+                  true, true, true, true, true, true, true, true, true, true, true, true, true,\n+                  true, true, true, true, true, true, true]));\n         // mixed\n \n         act = Bitv::with_capacity(33u, false);\n@@ -1938,9 +1938,9 @@ mod tests {\n         act.set(6u, true);\n         act.set(7u, true);\n         assert!(act.eq_vec(\n-                [true, true, true, true, true, true, true, true, false, false, false, false, false,\n-                false, false, false, false, false, false, false, false, false, false, false, false,\n-                false, false, false, false, false, false, false, false]));\n+                &[true, true, true, true, true, true, true, true, false, false, false, false, false,\n+                  false, false, false, false, false, false, false, false, false, false, false,\n+                  false, false, false, false, false, false, false, false, false]));\n         // mixed\n \n         act = Bitv::with_capacity(33u, false);\n@@ -1953,9 +1953,9 @@ mod tests {\n         act.set(22u, true);\n         act.set(23u, true);\n         assert!(act.eq_vec(\n-                [false, false, false, false, false, false, false, false, false, false, false,\n-                false, false, false, false, false, true, true, true, true, true, true, true, true,\n-                false, false, false, false, false, false, false, false, false]));\n+                &[false, false, false, false, false, false, false, false, false, false, false,\n+                  false, false, false, false, false, true, true, true, true, true, true, true, true,\n+                  false, false, false, false, false, false, false, false, false]));\n         // mixed\n \n         act = Bitv::with_capacity(33u, false);\n@@ -1968,9 +1968,9 @@ mod tests {\n         act.set(30u, true);\n         act.set(31u, true);\n         assert!(act.eq_vec(\n-                [false, false, false, false, false, false, false, false, false, false, false,\n-                false, false, false, false, false, false, false, false, false, false, false, false,\n-                false, true, true, true, true, true, true, true, true, false]));\n+                &[false, false, false, false, false, false, false, false, false, false, false,\n+                  false, false, false, false, false, false, false, false, false, false, false,\n+                  false, false, true, true, true, true, true, true, true, true, false]));\n         // mixed\n \n         act = Bitv::with_capacity(33u, false);\n@@ -1980,9 +1980,9 @@ mod tests {\n         act.set(31u, true);\n         act.set(32u, true);\n         assert!(act.eq_vec(\n-                [false, false, false, true, false, false, false, false, false, false, false, false,\n-                false, false, false, false, false, true, false, false, false, false, false, false,\n-                false, false, false, false, false, false, true, true, true]));\n+                &[false, false, false, true, false, false, false, false, false, false, false, false,\n+                  false, false, false, false, false, true, false, false, false, false, false, false,\n+                  false, false, false, false, false, false, true, true, true]));\n     }\n \n     #[test]\n@@ -2027,7 +2027,7 @@ mod tests {\n \n     #[test]\n     fn test_from_bytes() {\n-        let bitv = from_bytes([0b10110110, 0b00000000, 0b11111111]);\n+        let bitv = from_bytes(&[0b10110110, 0b00000000, 0b11111111]);\n         let str = format!(\"{}{}{}\", \"10110110\", \"00000000\", \"11111111\");\n         assert_eq!(bitv.to_string().as_slice(), str.as_slice());\n     }\n@@ -2065,7 +2065,7 @@ mod tests {\n     #[test]\n     fn test_to_bools() {\n         let bools = vec!(false, false, true, false, false, true, true, false);\n-        assert_eq!(from_bytes([0b00100110]).iter().collect::<Vec<bool>>(), bools);\n+        assert_eq!(from_bytes(&[0b00100110]).iter().collect::<Vec<bool>>(), bools);\n     }\n \n     #[test]\n@@ -2303,10 +2303,10 @@ mod tests {\n \n     #[test]\n     fn test_bitv_set_is_disjoint() {\n-        let a = BitvSet::from_bitv(from_bytes([0b10100010]));\n-        let b = BitvSet::from_bitv(from_bytes([0b01000000]));\n+        let a = BitvSet::from_bitv(from_bytes(&[0b10100010]));\n+        let b = BitvSet::from_bitv(from_bytes(&[0b01000000]));\n         let c = BitvSet::new();\n-        let d = BitvSet::from_bitv(from_bytes([0b00110000]));\n+        let d = BitvSet::from_bitv(from_bytes(&[0b00110000]));\n \n         assert!(!a.is_disjoint(&d));\n         assert!(!d.is_disjoint(&a));\n@@ -2326,13 +2326,13 @@ mod tests {\n         a.insert(0);\n         let mut b = BitvSet::new();\n         b.insert(5);\n-        let expected = BitvSet::from_bitv(from_bytes([0b10000100]));\n+        let expected = BitvSet::from_bitv(from_bytes(&[0b10000100]));\n         a.union_with(&b);\n         assert_eq!(a, expected);\n \n         // Standard\n-        let mut a = BitvSet::from_bitv(from_bytes([0b10100010]));\n-        let mut b = BitvSet::from_bitv(from_bytes([0b01100010]));\n+        let mut a = BitvSet::from_bitv(from_bytes(&[0b10100010]));\n+        let mut b = BitvSet::from_bitv(from_bytes(&[0b01100010]));\n         let c = a.clone();\n         a.union_with(&b);\n         b.union_with(&c);\n@@ -2343,16 +2343,16 @@ mod tests {\n     #[test]\n     fn test_bitv_set_intersect_with() {\n         // Explicitly 0'ed bits\n-        let mut a = BitvSet::from_bitv(from_bytes([0b10100010]));\n-        let mut b = BitvSet::from_bitv(from_bytes([0b00000000]));\n+        let mut a = BitvSet::from_bitv(from_bytes(&[0b10100010]));\n+        let mut b = BitvSet::from_bitv(from_bytes(&[0b00000000]));\n         let c = a.clone();\n         a.intersect_with(&b);\n         b.intersect_with(&c);\n         assert!(a.is_empty());\n         assert!(b.is_empty());\n \n         // Uninitialized bits should behave like 0's\n-        let mut a = BitvSet::from_bitv(from_bytes([0b10100010]));\n+        let mut a = BitvSet::from_bitv(from_bytes(&[0b10100010]));\n         let mut b = BitvSet::new();\n         let c = a.clone();\n         a.intersect_with(&b);\n@@ -2361,8 +2361,8 @@ mod tests {\n         assert!(b.is_empty());\n \n         // Standard\n-        let mut a = BitvSet::from_bitv(from_bytes([0b10100010]));\n-        let mut b = BitvSet::from_bitv(from_bytes([0b01100010]));\n+        let mut a = BitvSet::from_bitv(from_bytes(&[0b10100010]));\n+        let mut b = BitvSet::from_bitv(from_bytes(&[0b01100010]));\n         let c = a.clone();\n         a.intersect_with(&b);\n         b.intersect_with(&c);\n@@ -2373,20 +2373,20 @@ mod tests {\n     #[test]\n     fn test_bitv_set_difference_with() {\n         // Explicitly 0'ed bits\n-        let mut a = BitvSet::from_bitv(from_bytes([0b00000000]));\n-        let b = BitvSet::from_bitv(from_bytes([0b10100010]));\n+        let mut a = BitvSet::from_bitv(from_bytes(&[0b00000000]));\n+        let b = BitvSet::from_bitv(from_bytes(&[0b10100010]));\n         a.difference_with(&b);\n         assert!(a.is_empty());\n \n         // Uninitialized bits should behave like 0's\n         let mut a = BitvSet::new();\n-        let b = BitvSet::from_bitv(from_bytes([0b11111111]));\n+        let b = BitvSet::from_bitv(from_bytes(&[0b11111111]));\n         a.difference_with(&b);\n         assert!(a.is_empty());\n \n         // Standard\n-        let mut a = BitvSet::from_bitv(from_bytes([0b10100010]));\n-        let mut b = BitvSet::from_bitv(from_bytes([0b01100010]));\n+        let mut a = BitvSet::from_bitv(from_bytes(&[0b10100010]));\n+        let mut b = BitvSet::from_bitv(from_bytes(&[0b01100010]));\n         let c = a.clone();\n         a.difference_with(&b);\n         b.difference_with(&c);\n@@ -2403,19 +2403,19 @@ mod tests {\n         let mut b = BitvSet::new();\n         b.insert(1);\n         b.insert(5);\n-        let expected = BitvSet::from_bitv(from_bytes([0b10000100]));\n+        let expected = BitvSet::from_bitv(from_bytes(&[0b10000100]));\n         a.symmetric_difference_with(&b);\n         assert_eq!(a, expected);\n \n-        let mut a = BitvSet::from_bitv(from_bytes([0b10100010]));\n+        let mut a = BitvSet::from_bitv(from_bytes(&[0b10100010]));\n         let b = BitvSet::new();\n         let c = a.clone();\n         a.symmetric_difference_with(&b);\n         assert_eq!(a, c);\n \n         // Standard\n-        let mut a = BitvSet::from_bitv(from_bytes([0b11100010]));\n-        let mut b = BitvSet::from_bitv(from_bytes([0b01101010]));\n+        let mut a = BitvSet::from_bitv(from_bytes(&[0b11100010]));\n+        let mut b = BitvSet::from_bitv(from_bytes(&[0b01101010]));\n         let c = a.clone();\n         a.symmetric_difference_with(&b);\n         b.symmetric_difference_with(&c);\n@@ -2425,8 +2425,8 @@ mod tests {\n \n     #[test]\n     fn test_bitv_set_eq() {\n-        let a = BitvSet::from_bitv(from_bytes([0b10100010]));\n-        let b = BitvSet::from_bitv(from_bytes([0b00000000]));\n+        let a = BitvSet::from_bitv(from_bytes(&[0b10100010]));\n+        let b = BitvSet::from_bitv(from_bytes(&[0b00000000]));\n         let c = BitvSet::new();\n \n         assert!(a == a);\n@@ -2439,8 +2439,8 @@ mod tests {\n \n     #[test]\n     fn test_bitv_set_cmp() {\n-        let a = BitvSet::from_bitv(from_bytes([0b10100010]));\n-        let b = BitvSet::from_bitv(from_bytes([0b00000000]));\n+        let a = BitvSet::from_bitv(from_bytes(&[0b10100010]));\n+        let b = BitvSet::from_bitv(from_bytes(&[0b00000000]));\n         let c = BitvSet::new();\n \n         assert_eq!(a.cmp(&b), Greater);\n@@ -2519,41 +2519,41 @@ mod tests {\n \n     #[test]\n     fn test_small_bitv_tests() {\n-        let v = from_bytes([0]);\n+        let v = from_bytes(&[0]);\n         assert!(!v.all());\n         assert!(!v.any());\n         assert!(v.none());\n \n-        let v = from_bytes([0b00010100]);\n+        let v = from_bytes(&[0b00010100]);\n         assert!(!v.all());\n         assert!(v.any());\n         assert!(!v.none());\n \n-        let v = from_bytes([0xFF]);\n+        let v = from_bytes(&[0xFF]);\n         assert!(v.all());\n         assert!(v.any());\n         assert!(!v.none());\n     }\n \n     #[test]\n     fn test_big_bitv_tests() {\n-        let v = from_bytes([ // 88 bits\n+        let v = from_bytes(&[ // 88 bits\n             0, 0, 0, 0,\n             0, 0, 0, 0,\n             0, 0, 0]);\n         assert!(!v.all());\n         assert!(!v.any());\n         assert!(v.none());\n \n-        let v = from_bytes([ // 88 bits\n+        let v = from_bytes(&[ // 88 bits\n             0, 0, 0b00010100, 0,\n             0, 0, 0, 0b00110100,\n             0, 0, 0]);\n         assert!(!v.all());\n         assert!(v.any());\n         assert!(!v.none());\n \n-        let v = from_bytes([ // 88 bits\n+        let v = from_bytes(&[ // 88 bits\n             0xFF, 0xFF, 0xFF, 0xFF,\n             0xFF, 0xFF, 0xFF, 0xFF,\n             0xFF, 0xFF, 0xFF]);\n@@ -2632,24 +2632,24 @@ mod tests {\n \n     #[test]\n     fn test_bitv_grow() {\n-        let mut bitv = from_bytes([0b10110110, 0b00000000, 0b10101010]);\n+        let mut bitv = from_bytes(&[0b10110110, 0b00000000, 0b10101010]);\n         bitv.grow(32, true);\n-        assert_eq!(bitv, from_bytes([0b10110110, 0b00000000, 0b10101010,\n+        assert_eq!(bitv, from_bytes(&[0b10110110, 0b00000000, 0b10101010,\n                                      0xFF, 0xFF, 0xFF, 0xFF]));\n         bitv.grow(64, false);\n-        assert_eq!(bitv, from_bytes([0b10110110, 0b00000000, 0b10101010,\n+        assert_eq!(bitv, from_bytes(&[0b10110110, 0b00000000, 0b10101010,\n                                      0xFF, 0xFF, 0xFF, 0xFF, 0, 0, 0, 0, 0, 0, 0, 0]));\n         bitv.grow(16, true);\n-        assert_eq!(bitv, from_bytes([0b10110110, 0b00000000, 0b10101010,\n+        assert_eq!(bitv, from_bytes(&[0b10110110, 0b00000000, 0b10101010,\n                                      0xFF, 0xFF, 0xFF, 0xFF, 0, 0, 0, 0, 0, 0, 0, 0, 0xFF, 0xFF]));\n     }\n \n     #[test]\n     fn test_bitv_extend() {\n-        let mut bitv = from_bytes([0b10110110, 0b00000000, 0b11111111]);\n-        let ext = from_bytes([0b01001001, 0b10010010, 0b10111101]);\n+        let mut bitv = from_bytes(&[0b10110110, 0b00000000, 0b11111111]);\n+        let ext = from_bytes(&[0b01001001, 0b10010010, 0b10111101]);\n         bitv.extend(ext.iter());\n-        assert_eq!(bitv, from_bytes([0b10110110, 0b00000000, 0b11111111,\n+        assert_eq!(bitv, from_bytes(&[0b10110110, 0b00000000, 0b11111111,\n                                      0b01001001, 0b10010010, 0b10111101]));\n     }\n "}, {"sha": "56edf7719bb22f8146f10215cc9eb22fca08cb66", "filename": "src/libcollections/btree/set.rs", "status": "modified", "additions": 29, "deletions": 29, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibcollections%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibcollections%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fset.rs?ref=0047dbe59c41b951d34ce6324f3a8c0e15d523e9", "patch": "@@ -467,14 +467,14 @@ mod test {\n             check(a, b, expected, |x, y, f| x.intersection(y).all(f))\n         }\n \n-        check_intersection([], [], []);\n-        check_intersection([1, 2, 3], [], []);\n-        check_intersection([], [1, 2, 3], []);\n-        check_intersection([2], [1, 2, 3], [2]);\n-        check_intersection([1, 2, 3], [2], [2]);\n-        check_intersection([11, 1, 3, 77, 103, 5, -5],\n-                           [2, 11, 77, -9, -42, 5, 3],\n-                           [3, 5, 11, 77]);\n+        check_intersection(&[], &[], &[]);\n+        check_intersection(&[1, 2, 3], &[], &[]);\n+        check_intersection(&[], &[1, 2, 3], &[]);\n+        check_intersection(&[2], &[1, 2, 3], &[2]);\n+        check_intersection(&[1, 2, 3], &[2], &[2]);\n+        check_intersection(&[11, 1, 3, 77, 103, 5, -5],\n+                           &[2, 11, 77, -9, -42, 5, 3],\n+                           &[3, 5, 11, 77]);\n     }\n \n     #[test]\n@@ -483,15 +483,15 @@ mod test {\n             check(a, b, expected, |x, y, f| x.difference(y).all(f))\n         }\n \n-        check_difference([], [], []);\n-        check_difference([1, 12], [], [1, 12]);\n-        check_difference([], [1, 2, 3, 9], []);\n-        check_difference([1, 3, 5, 9, 11],\n-                         [3, 9],\n-                         [1, 5, 11]);\n-        check_difference([-5, 11, 22, 33, 40, 42],\n-                         [-12, -5, 14, 23, 34, 38, 39, 50],\n-                         [11, 22, 33, 40, 42]);\n+        check_difference(&[], &[], &[]);\n+        check_difference(&[1, 12], &[], &[1, 12]);\n+        check_difference(&[], &[1, 2, 3, 9], &[]);\n+        check_difference(&[1, 3, 5, 9, 11],\n+                         &[3, 9],\n+                         &[1, 5, 11]);\n+        check_difference(&[-5, 11, 22, 33, 40, 42],\n+                         &[-12, -5, 14, 23, 34, 38, 39, 50],\n+                         &[11, 22, 33, 40, 42]);\n     }\n \n     #[test]\n@@ -501,12 +501,12 @@ mod test {\n             check(a, b, expected, |x, y, f| x.symmetric_difference(y).all(f))\n         }\n \n-        check_symmetric_difference([], [], []);\n-        check_symmetric_difference([1, 2, 3], [2], [1, 3]);\n-        check_symmetric_difference([2], [1, 2, 3], [1, 3]);\n-        check_symmetric_difference([1, 3, 5, 9, 11],\n-                                   [-2, 3, 9, 14, 22],\n-                                   [-2, 1, 5, 11, 14, 22]);\n+        check_symmetric_difference(&[], &[], &[]);\n+        check_symmetric_difference(&[1, 2, 3], &[2], &[1, 3]);\n+        check_symmetric_difference(&[2], &[1, 2, 3], &[1, 3]);\n+        check_symmetric_difference(&[1, 3, 5, 9, 11],\n+                                   &[-2, 3, 9, 14, 22],\n+                                   &[-2, 1, 5, 11, 14, 22]);\n     }\n \n     #[test]\n@@ -516,12 +516,12 @@ mod test {\n             check(a, b, expected, |x, y, f| x.union(y).all(f))\n         }\n \n-        check_union([], [], []);\n-        check_union([1, 2, 3], [2], [1, 2, 3]);\n-        check_union([2], [1, 2, 3], [1, 2, 3]);\n-        check_union([1, 3, 5, 9, 11, 16, 19, 24],\n-                    [-2, 1, 5, 9, 13, 19],\n-                    [-2, 1, 3, 5, 9, 11, 13, 16, 19, 24]);\n+        check_union(&[], &[], &[]);\n+        check_union(&[1, 2, 3], &[2], &[1, 2, 3]);\n+        check_union(&[2], &[1, 2, 3], &[1, 2, 3]);\n+        check_union(&[1, 3, 5, 9, 11, 16, 19, 24],\n+                    &[-2, 1, 5, 9, 13, 19],\n+                    &[-2, 1, 3, 5, 9, 11, 13, 16, 19, 24]);\n     }\n \n     #[test]"}, {"sha": "19216b32ce77f971dc56d7f457a6a66d8ffb707c", "filename": "src/libcollections/dlist.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibcollections%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibcollections%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fdlist.rs?ref=0047dbe59c41b951d34ce6324f3a8c0e15d523e9", "patch": "@@ -1088,8 +1088,8 @@ mod tests {\n \n     #[test]\n     fn test_merge() {\n-        let mut m = list_from([0i, 1, 3, 5, 6, 7, 2]);\n-        let n = list_from([-1i, 0, 0, 7, 7, 9]);\n+        let mut m = list_from(&[0i, 1, 3, 5, 6, 7, 2]);\n+        let n = list_from(&[-1i, 0, 0, 7, 7, 9]);\n         let len = m.len() + n.len();\n         m.merge(n, |a, b| a <= b);\n         assert_eq!(m.len(), len);\n@@ -1129,7 +1129,7 @@ mod tests {\n \n     #[test]\n     fn test_send() {\n-        let n = list_from([1i,2,3]);\n+        let n = list_from(&[1i,2,3]);\n         spawn(proc() {\n             check_links(&n);\n             let a: &[_] = &[&1,&2,&3];\n@@ -1139,16 +1139,16 @@ mod tests {\n \n     #[test]\n     fn test_eq() {\n-        let mut n: DList<u8> = list_from([]);\n-        let mut m = list_from([]);\n+        let mut n: DList<u8> = list_from(&[]);\n+        let mut m = list_from(&[]);\n         assert!(n == m);\n         n.push_front(1);\n         assert!(n != m);\n         m.push_back(1);\n         assert!(n == m);\n \n-        let n = list_from([2i,3,4]);\n-        let m = list_from([1i,2,3]);\n+        let n = list_from(&[2i,3,4]);\n+        let m = list_from(&[1i,2,3]);\n         assert!(n != m);\n     }\n \n@@ -1172,8 +1172,8 @@ mod tests {\n \n     #[test]\n     fn test_ord() {\n-        let n: DList<int> = list_from([]);\n-        let m = list_from([1i,2,3]);\n+        let n: DList<int> = list_from(&[]);\n+        let m = list_from(&[1i,2,3]);\n         assert!(n < m);\n         assert!(m > n);\n         assert!(n <= n);\n@@ -1183,29 +1183,29 @@ mod tests {\n     #[test]\n     fn test_ord_nan() {\n         let nan = 0.0f64/0.0;\n-        let n = list_from([nan]);\n-        let m = list_from([nan]);\n+        let n = list_from(&[nan]);\n+        let m = list_from(&[nan]);\n         assert!(!(n < m));\n         assert!(!(n > m));\n         assert!(!(n <= m));\n         assert!(!(n >= m));\n \n-        let n = list_from([nan]);\n-        let one = list_from([1.0f64]);\n+        let n = list_from(&[nan]);\n+        let one = list_from(&[1.0f64]);\n         assert!(!(n < one));\n         assert!(!(n > one));\n         assert!(!(n <= one));\n         assert!(!(n >= one));\n \n-        let u = list_from([1.0f64,2.0,nan]);\n-        let v = list_from([1.0f64,2.0,3.0]);\n+        let u = list_from(&[1.0f64,2.0,nan]);\n+        let v = list_from(&[1.0f64,2.0,3.0]);\n         assert!(!(u < v));\n         assert!(!(u > v));\n         assert!(!(u <= v));\n         assert!(!(u >= v));\n \n-        let s = list_from([1.0f64,2.0,4.0,2.0]);\n-        let t = list_from([1.0f64,2.0,3.0,2.0]);\n+        let s = list_from(&[1.0f64,2.0,4.0,2.0]);\n+        let t = list_from(&[1.0f64,2.0,3.0,2.0]);\n         assert!(!(s < t));\n         assert!(s > one);\n         assert!(!(s <= one));"}, {"sha": "b1ff3da947b70b96fa4dd83d030494c3db5918a6", "filename": "src/libcollections/hash/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibcollections%2Fhash%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibcollections%2Fhash%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fhash%2Fmod.rs?ref=0047dbe59c41b951d34ce6324f3a8c0e15d523e9", "patch": "@@ -151,7 +151,7 @@ macro_rules! impl_hash_tuple(\n         impl<S: Writer> Hash<S> for () {\n             #[inline]\n             fn hash(&self, state: &mut S) {\n-                state.write([]);\n+                state.write(&[]);\n             }\n         }\n     );"}, {"sha": "67ac73bf0b9f6b4b385d233e85ab31dee67e5497", "filename": "src/libcollections/hash/sip.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibcollections%2Fhash%2Fsip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibcollections%2Fhash%2Fsip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fhash%2Fsip.rs?ref=0047dbe59c41b951d34ce6324f3a8c0e15d523e9", "patch": "@@ -414,7 +414,7 @@ mod tests {\n             assert_eq!(f, v);\n \n             buf.push(t as u8);\n-            state_inc.write([t as u8]);\n+            state_inc.write(&[t as u8]);\n \n             t += 1;\n         }"}, {"sha": "09a26a1caacd44038f2cd6035404c41035c81739", "filename": "src/libcollections/slice.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibcollections%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibcollections%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fslice.rs?ref=0047dbe59c41b951d34ce6324f3a8c0e15d523e9", "patch": "@@ -18,15 +18,15 @@\n //! let vec = vec!(1i, 2, 3);\n //! let int_slice = vec.as_slice();\n //! // coercing an array to a slice\n-//! let str_slice: &[&str] = [\"one\", \"two\", \"three\"];\n+//! let str_slice: &[&str] = &[\"one\", \"two\", \"three\"];\n //! ```\n //!\n //! Slices are either mutable or shared. The shared slice type is `&[T]`,\n //! while the mutable slice type is `&mut[T]`. For example, you can mutate the\n //! block of memory that a mutable slice points to:\n //!\n //! ```rust\n-//! let x: &mut[int] = [1i, 2, 3];\n+//! let x: &mut[int] = &mut [1i, 2, 3];\n //! x[1] = 7;\n //! assert_eq!(x[0], 1);\n //! assert_eq!(x[1], 7);\n@@ -1962,7 +1962,7 @@ mod tests {\n         assert!(!b\"foo\".starts_with(b\"foobar\"));\n         assert!(!b\"bar\".starts_with(b\"foobar\"));\n         assert!(b\"foobar\".starts_with(b\"foobar\"));\n-        let empty: &[u8] = [];\n+        let empty: &[u8] = &[];\n         assert!(empty.starts_with(empty));\n         assert!(!empty.starts_with(b\"foo\"));\n         assert!(b\"foobar\".starts_with(empty));\n@@ -1976,7 +1976,7 @@ mod tests {\n         assert!(!b\"foo\".ends_with(b\"foobar\"));\n         assert!(!b\"bar\".ends_with(b\"foobar\"));\n         assert!(b\"foobar\".ends_with(b\"foobar\"));\n-        let empty: &[u8] = [];\n+        let empty: &[u8] = &[];\n         assert!(empty.ends_with(empty));\n         assert!(!empty.ends_with(b\"foo\"));\n         assert!(b\"foobar\".ends_with(empty));\n@@ -2054,7 +2054,7 @@ mod tests {\n         let h = x.last_mut();\n         assert_eq!(*h.unwrap(), 5);\n \n-        let y: &mut [int] = [];\n+        let y: &mut [int] = &mut [];\n         assert!(y.last_mut().is_none());\n     }\n "}, {"sha": "1a57479c8119cf85027610019f795d10ac68290a", "filename": "src/libcollections/str.rs", "status": "modified", "additions": 95, "deletions": 95, "changes": 190, "blob_url": "https://github.com/rust-lang/rust/blob/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibcollections%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibcollections%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstr.rs?ref=0047dbe59c41b951d34ce6324f3a8c0e15d523e9", "patch": "@@ -923,49 +923,49 @@ mod tests {\n         fn t(v: &[String], s: &str) {\n             assert_eq!(v.concat().as_slice(), s);\n         }\n-        t([String::from_str(\"you\"), String::from_str(\"know\"),\n-           String::from_str(\"I'm\"),\n-           String::from_str(\"no\"), String::from_str(\"good\")],\n+        t(&[String::from_str(\"you\"), String::from_str(\"know\"),\n+            String::from_str(\"I'm\"),\n+            String::from_str(\"no\"), String::from_str(\"good\")],\n           \"youknowI'mnogood\");\n-        let v: &[String] = [];\n+        let v: &[String] = &[];\n         t(v, \"\");\n-        t([String::from_str(\"hi\")], \"hi\");\n+        t(&[String::from_str(\"hi\")], \"hi\");\n     }\n \n     #[test]\n     fn test_connect() {\n         fn t(v: &[String], sep: &str, s: &str) {\n             assert_eq!(v.connect(sep).as_slice(), s);\n         }\n-        t([String::from_str(\"you\"), String::from_str(\"know\"),\n-           String::from_str(\"I'm\"),\n-           String::from_str(\"no\"), String::from_str(\"good\")],\n+        t(&[String::from_str(\"you\"), String::from_str(\"know\"),\n+            String::from_str(\"I'm\"),\n+            String::from_str(\"no\"), String::from_str(\"good\")],\n           \" \", \"you know I'm no good\");\n-        let v: &[String] = [];\n+        let v: &[String] = &[];\n         t(v, \" \", \"\");\n-        t([String::from_str(\"hi\")], \" \", \"hi\");\n+        t(&[String::from_str(\"hi\")], \" \", \"hi\");\n     }\n \n     #[test]\n     fn test_concat_slices() {\n         fn t(v: &[&str], s: &str) {\n             assert_eq!(v.concat().as_slice(), s);\n         }\n-        t([\"you\", \"know\", \"I'm\", \"no\", \"good\"], \"youknowI'mnogood\");\n-        let v: &[&str] = [];\n+        t(&[\"you\", \"know\", \"I'm\", \"no\", \"good\"], \"youknowI'mnogood\");\n+        let v: &[&str] = &[];\n         t(v, \"\");\n-        t([\"hi\"], \"hi\");\n+        t(&[\"hi\"], \"hi\");\n     }\n \n     #[test]\n     fn test_connect_slices() {\n         fn t(v: &[&str], sep: &str, s: &str) {\n             assert_eq!(v.connect(sep).as_slice(), s);\n         }\n-        t([\"you\", \"know\", \"I'm\", \"no\", \"good\"],\n+        t(&[\"you\", \"know\", \"I'm\", \"no\", \"good\"],\n           \" \", \"you know I'm no good\");\n-        t([], \" \", \"\");\n-        t([\"hi\"], \" \", \"hi\");\n+        t(&[], \" \", \"\");\n+        t(&[\"hi\"], \" \", \"hi\");\n     }\n \n     #[test]\n@@ -1266,85 +1266,85 @@ mod tests {\n     #[test]\n     fn test_is_utf8() {\n         // deny overlong encodings\n-        assert!(!is_utf8([0xc0, 0x80]));\n-        assert!(!is_utf8([0xc0, 0xae]));\n-        assert!(!is_utf8([0xe0, 0x80, 0x80]));\n-        assert!(!is_utf8([0xe0, 0x80, 0xaf]));\n-        assert!(!is_utf8([0xe0, 0x81, 0x81]));\n-        assert!(!is_utf8([0xf0, 0x82, 0x82, 0xac]));\n-        assert!(!is_utf8([0xf4, 0x90, 0x80, 0x80]));\n+        assert!(!is_utf8(&[0xc0, 0x80]));\n+        assert!(!is_utf8(&[0xc0, 0xae]));\n+        assert!(!is_utf8(&[0xe0, 0x80, 0x80]));\n+        assert!(!is_utf8(&[0xe0, 0x80, 0xaf]));\n+        assert!(!is_utf8(&[0xe0, 0x81, 0x81]));\n+        assert!(!is_utf8(&[0xf0, 0x82, 0x82, 0xac]));\n+        assert!(!is_utf8(&[0xf4, 0x90, 0x80, 0x80]));\n \n         // deny surrogates\n-        assert!(!is_utf8([0xED, 0xA0, 0x80]));\n-        assert!(!is_utf8([0xED, 0xBF, 0xBF]));\n+        assert!(!is_utf8(&[0xED, 0xA0, 0x80]));\n+        assert!(!is_utf8(&[0xED, 0xBF, 0xBF]));\n \n-        assert!(is_utf8([0xC2, 0x80]));\n-        assert!(is_utf8([0xDF, 0xBF]));\n-        assert!(is_utf8([0xE0, 0xA0, 0x80]));\n-        assert!(is_utf8([0xED, 0x9F, 0xBF]));\n-        assert!(is_utf8([0xEE, 0x80, 0x80]));\n-        assert!(is_utf8([0xEF, 0xBF, 0xBF]));\n-        assert!(is_utf8([0xF0, 0x90, 0x80, 0x80]));\n-        assert!(is_utf8([0xF4, 0x8F, 0xBF, 0xBF]));\n+        assert!(is_utf8(&[0xC2, 0x80]));\n+        assert!(is_utf8(&[0xDF, 0xBF]));\n+        assert!(is_utf8(&[0xE0, 0xA0, 0x80]));\n+        assert!(is_utf8(&[0xED, 0x9F, 0xBF]));\n+        assert!(is_utf8(&[0xEE, 0x80, 0x80]));\n+        assert!(is_utf8(&[0xEF, 0xBF, 0xBF]));\n+        assert!(is_utf8(&[0xF0, 0x90, 0x80, 0x80]));\n+        assert!(is_utf8(&[0xF4, 0x8F, 0xBF, 0xBF]));\n     }\n \n     #[test]\n     fn test_is_utf16() {\n         macro_rules! pos ( ($($e:expr),*) => { { $(assert!(is_utf16($e));)* } });\n \n         // non-surrogates\n-        pos!([0x0000],\n-             [0x0001, 0x0002],\n-             [0xD7FF],\n-             [0xE000]);\n+        pos!(&[0x0000],\n+             &[0x0001, 0x0002],\n+             &[0xD7FF],\n+             &[0xE000]);\n \n         // surrogate pairs (randomly generated with Python 3's\n         // .encode('utf-16be'))\n-        pos!([0xdb54, 0xdf16, 0xd880, 0xdee0, 0xdb6a, 0xdd45],\n-             [0xd91f, 0xdeb1, 0xdb31, 0xdd84, 0xd8e2, 0xde14],\n-             [0xdb9f, 0xdc26, 0xdb6f, 0xde58, 0xd850, 0xdfae]);\n+        pos!(&[0xdb54, 0xdf16, 0xd880, 0xdee0, 0xdb6a, 0xdd45],\n+             &[0xd91f, 0xdeb1, 0xdb31, 0xdd84, 0xd8e2, 0xde14],\n+             &[0xdb9f, 0xdc26, 0xdb6f, 0xde58, 0xd850, 0xdfae]);\n \n         // mixtures (also random)\n-        pos!([0xd921, 0xdcc2, 0x002d, 0x004d, 0xdb32, 0xdf65],\n-             [0xdb45, 0xdd2d, 0x006a, 0xdacd, 0xddfe, 0x0006],\n-             [0x0067, 0xd8ff, 0xddb7, 0x000f, 0xd900, 0xdc80]);\n+        pos!(&[0xd921, 0xdcc2, 0x002d, 0x004d, 0xdb32, 0xdf65],\n+             &[0xdb45, 0xdd2d, 0x006a, 0xdacd, 0xddfe, 0x0006],\n+             &[0x0067, 0xd8ff, 0xddb7, 0x000f, 0xd900, 0xdc80]);\n \n         // negative tests\n         macro_rules! neg ( ($($e:expr),*) => { { $(assert!(!is_utf16($e));)* } });\n \n         neg!(\n             // surrogate + regular unit\n-            [0xdb45, 0x0000],\n+            &[0xdb45, 0x0000],\n             // surrogate + lead surrogate\n-            [0xd900, 0xd900],\n+            &[0xd900, 0xd900],\n             // unterminated surrogate\n-            [0xd8ff],\n+            &[0xd8ff],\n             // trail surrogate without a lead\n-            [0xddb7]);\n+            &[0xddb7]);\n \n         // random byte sequences that Python 3's .decode('utf-16be')\n         // failed on\n-        neg!([0x5b3d, 0x0141, 0xde9e, 0x8fdc, 0xc6e7],\n-             [0xdf5a, 0x82a5, 0x62b9, 0xb447, 0x92f3],\n-             [0xda4e, 0x42bc, 0x4462, 0xee98, 0xc2ca],\n-             [0xbe00, 0xb04a, 0x6ecb, 0xdd89, 0xe278],\n-             [0x0465, 0xab56, 0xdbb6, 0xa893, 0x665e],\n-             [0x6b7f, 0x0a19, 0x40f4, 0xa657, 0xdcc5],\n-             [0x9b50, 0xda5e, 0x24ec, 0x03ad, 0x6dee],\n-             [0x8d17, 0xcaa7, 0xf4ae, 0xdf6e, 0xbed7],\n-             [0xdaee, 0x2584, 0x7d30, 0xa626, 0x121a],\n-             [0xd956, 0x4b43, 0x7570, 0xccd6, 0x4f4a],\n-             [0x9dcf, 0x1b49, 0x4ba5, 0xfce9, 0xdffe],\n-             [0x6572, 0xce53, 0xb05a, 0xf6af, 0xdacf],\n-             [0x1b90, 0x728c, 0x9906, 0xdb68, 0xf46e],\n-             [0x1606, 0xbeca, 0xbe76, 0x860f, 0xdfa5],\n-             [0x8b4f, 0xde7a, 0xd220, 0x9fac, 0x2b6f],\n-             [0xb8fe, 0xebbe, 0xda32, 0x1a5f, 0x8b8b],\n-             [0x934b, 0x8956, 0xc434, 0x1881, 0xddf7],\n-             [0x5a95, 0x13fc, 0xf116, 0xd89b, 0x93f9],\n-             [0xd640, 0x71f1, 0xdd7d, 0x77eb, 0x1cd8],\n-             [0x348b, 0xaef0, 0xdb2c, 0xebf1, 0x1282],\n-             [0x50d7, 0xd824, 0x5010, 0xb369, 0x22ea]);\n+        neg!(&[0x5b3d, 0x0141, 0xde9e, 0x8fdc, 0xc6e7],\n+             &[0xdf5a, 0x82a5, 0x62b9, 0xb447, 0x92f3],\n+             &[0xda4e, 0x42bc, 0x4462, 0xee98, 0xc2ca],\n+             &[0xbe00, 0xb04a, 0x6ecb, 0xdd89, 0xe278],\n+             &[0x0465, 0xab56, 0xdbb6, 0xa893, 0x665e],\n+             &[0x6b7f, 0x0a19, 0x40f4, 0xa657, 0xdcc5],\n+             &[0x9b50, 0xda5e, 0x24ec, 0x03ad, 0x6dee],\n+             &[0x8d17, 0xcaa7, 0xf4ae, 0xdf6e, 0xbed7],\n+             &[0xdaee, 0x2584, 0x7d30, 0xa626, 0x121a],\n+             &[0xd956, 0x4b43, 0x7570, 0xccd6, 0x4f4a],\n+             &[0x9dcf, 0x1b49, 0x4ba5, 0xfce9, 0xdffe],\n+             &[0x6572, 0xce53, 0xb05a, 0xf6af, 0xdacf],\n+             &[0x1b90, 0x728c, 0x9906, 0xdb68, 0xf46e],\n+             &[0x1606, 0xbeca, 0xbe76, 0x860f, 0xdfa5],\n+             &[0x8b4f, 0xde7a, 0xd220, 0x9fac, 0x2b6f],\n+             &[0xb8fe, 0xebbe, 0xda32, 0x1a5f, 0x8b8b],\n+             &[0x934b, 0x8956, 0xc434, 0x1881, 0xddf7],\n+             &[0x5a95, 0x13fc, 0xf116, 0xd89b, 0x93f9],\n+             &[0xd640, 0x71f1, 0xdd7d, 0x77eb, 0x1cd8],\n+             &[0x348b, 0xaef0, 0xdb2c, 0xebf1, 0x1282],\n+             &[0x50d7, 0xd824, 0x5010, 0xb369, 0x22ea]);\n     }\n \n     #[test]\n@@ -1456,22 +1456,22 @@ mod tests {\n     fn test_truncate_utf16_at_nul() {\n         let v = [];\n         let b: &[u16] = &[];\n-        assert_eq!(truncate_utf16_at_nul(v), b);\n+        assert_eq!(truncate_utf16_at_nul(&v), b);\n \n         let v = [0, 2, 3];\n-        assert_eq!(truncate_utf16_at_nul(v), b);\n+        assert_eq!(truncate_utf16_at_nul(&v), b);\n \n         let v = [1, 0, 3];\n         let b: &[u16] = &[1];\n-        assert_eq!(truncate_utf16_at_nul(v), b);\n+        assert_eq!(truncate_utf16_at_nul(&v), b);\n \n         let v = [1, 2, 0];\n         let b: &[u16] = &[1, 2];\n-        assert_eq!(truncate_utf16_at_nul(v), b);\n+        assert_eq!(truncate_utf16_at_nul(&v), b);\n \n         let v = [1, 2, 3];\n         let b: &[u16] = &[1, 2, 3];\n-        assert_eq!(truncate_utf16_at_nul(v), b);\n+        assert_eq!(truncate_utf16_at_nul(&v), b);\n     }\n \n     #[test]\n@@ -1585,7 +1585,7 @@ mod tests {\n     fn test_chars_decoding() {\n         let mut bytes = [0u8, ..4];\n         for c in range(0u32, 0x110000).filter_map(|c| ::core::char::from_u32(c)) {\n-            let len = c.encode_utf8(bytes).unwrap_or(0);\n+            let len = c.encode_utf8(&mut bytes).unwrap_or(0);\n             let s = ::core::str::from_utf8(bytes[..len]).unwrap();\n             if Some(c) != s.chars().next() {\n                 panic!(\"character {:x}={} does not decode correctly\", c as u32, c);\n@@ -1597,7 +1597,7 @@ mod tests {\n     fn test_chars_rev_decoding() {\n         let mut bytes = [0u8, ..4];\n         for c in range(0u32, 0x110000).filter_map(|c| ::core::char::from_u32(c)) {\n-            let len = c.encode_utf8(bytes).unwrap_or(0);\n+            let len = c.encode_utf8(&mut bytes).unwrap_or(0);\n             let s = ::core::str::from_utf8(bytes[..len]).unwrap();\n             if Some(c) != s.chars().rev().next() {\n                 panic!(\"character {:x}={} does not decode correctly\", c as u32, c);\n@@ -2114,20 +2114,20 @@ mod tests {\n             let v: Vec<&str> = s.split_str(sep).collect();\n             assert_eq!(v.as_slice(), u.as_slice());\n         }\n-        t(\"--1233345--\", \"12345\", [\"--1233345--\"]);\n-        t(\"abc::hello::there\", \"::\", [\"abc\", \"hello\", \"there\"]);\n-        t(\"::hello::there\", \"::\", [\"\", \"hello\", \"there\"]);\n-        t(\"hello::there::\", \"::\", [\"hello\", \"there\", \"\"]);\n-        t(\"::hello::there::\", \"::\", [\"\", \"hello\", \"there\", \"\"]);\n-        t(\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\", \"\u4e2d\u534e\", [\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\", \"Vi\u1ec7t Nam\"]);\n-        t(\"zzXXXzzYYYzz\", \"zz\", [\"\", \"XXX\", \"YYY\", \"\"]);\n-        t(\"zzXXXzYYYz\", \"XXX\", [\"zz\", \"zYYYz\"]);\n-        t(\".XXX.YYY.\", \".\", [\"\", \"XXX\", \"YYY\", \"\"]);\n-        t(\"\", \".\", [\"\"]);\n-        t(\"zz\", \"zz\", [\"\",\"\"]);\n-        t(\"ok\", \"z\", [\"ok\"]);\n-        t(\"zzz\", \"zz\", [\"\",\"z\"]);\n-        t(\"zzzzz\", \"zz\", [\"\",\"\",\"z\"]);\n+        t(\"--1233345--\", \"12345\", &[\"--1233345--\"]);\n+        t(\"abc::hello::there\", \"::\", &[\"abc\", \"hello\", \"there\"]);\n+        t(\"::hello::there\", \"::\", &[\"\", \"hello\", \"there\"]);\n+        t(\"hello::there::\", \"::\", &[\"hello\", \"there\", \"\"]);\n+        t(\"::hello::there::\", \"::\", &[\"\", \"hello\", \"there\", \"\"]);\n+        t(\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\", \"\u4e2d\u534e\", &[\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\", \"Vi\u1ec7t Nam\"]);\n+        t(\"zzXXXzzYYYzz\", \"zz\", &[\"\", \"XXX\", \"YYY\", \"\"]);\n+        t(\"zzXXXzYYYz\", \"XXX\", &[\"zz\", \"zYYYz\"]);\n+        t(\".XXX.YYY.\", \".\", &[\"\", \"XXX\", \"YYY\", \"\"]);\n+        t(\"\", \".\", &[\"\"]);\n+        t(\"zz\", \"zz\", &[\"\",\"\"]);\n+        t(\"ok\", \"z\", &[\"ok\"]);\n+        t(\"zzz\", \"zz\", &[\"\",\"z\"]);\n+        t(\"zzzzz\", \"zz\", &[\"\",\"\",\"z\"]);\n     }\n \n     #[test]\n@@ -2149,12 +2149,12 @@ mod tests {\n         }\n \n         let s = String::from_str(\"01234\");\n-        assert_eq!(5, sum_len([\"012\", \"\", \"34\"]));\n-        assert_eq!(5, sum_len([String::from_str(\"01\").as_slice(),\n-                               String::from_str(\"2\").as_slice(),\n-                               String::from_str(\"34\").as_slice(),\n-                               String::from_str(\"\").as_slice()]));\n-        assert_eq!(5, sum_len([s.as_slice()]));\n+        assert_eq!(5, sum_len(&[\"012\", \"\", \"34\"]));\n+        assert_eq!(5, sum_len(&[String::from_str(\"01\").as_slice(),\n+                                String::from_str(\"2\").as_slice(),\n+                                String::from_str(\"34\").as_slice(),\n+                                String::from_str(\"\").as_slice()]));\n+        assert_eq!(5, sum_len(&[s.as_slice()]));\n     }\n \n     #[test]"}, {"sha": "c0c3af6d2d80285e1daf783442a72eb96957f61b", "filename": "src/libcollections/string.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibcollections%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibcollections%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstring.rs?ref=0047dbe59c41b951d34ce6324f3a8c0e15d523e9", "patch": "@@ -244,8 +244,8 @@ impl String {\n     ///\n     /// ```rust\n     /// // \ud834\udd1emusic\n-    /// let mut v = [0xD834, 0xDD1E, 0x006d, 0x0075,\n-    ///              0x0073, 0x0069, 0x0063];\n+    /// let mut v = &mut [0xD834, 0xDD1E, 0x006d, 0x0075,\n+    ///                   0x0073, 0x0069, 0x0063];\n     /// assert_eq!(String::from_utf16(v), Some(\"\ud834\udd1emusic\".to_string()));\n     ///\n     /// // \ud834\udd1emu<invalid>ic\n@@ -270,9 +270,9 @@ impl String {\n     /// # Example\n     /// ```rust\n     /// // \ud834\udd1emus<invalid>ic<invalid>\n-    /// let v = [0xD834, 0xDD1E, 0x006d, 0x0075,\n-    ///          0x0073, 0xDD1E, 0x0069, 0x0063,\n-    ///          0xD834];\n+    /// let v = &[0xD834, 0xDD1E, 0x006d, 0x0075,\n+    ///           0x0073, 0xDD1E, 0x0069, 0x0063,\n+    ///           0xD834];\n     ///\n     /// assert_eq!(String::from_utf16_lossy(v),\n     ///            \"\ud834\udd1emus\\uFFFDic\\uFFFD\".to_string());\n@@ -287,7 +287,7 @@ impl String {\n     /// # Example\n     ///\n     /// ```rust\n-    /// let chars = ['h', 'e', 'l', 'l', 'o'];\n+    /// let chars = &['h', 'e', 'l', 'l', 'o'];\n     /// let s = String::from_chars(chars);\n     /// assert_eq!(s.as_slice(), \"hello\");\n     /// ```\n@@ -600,7 +600,7 @@ impl String {\n         assert!(self.as_slice().is_char_boundary(idx));\n         self.vec.reserve(4);\n         let mut bits = [0, ..4];\n-        let amt = ch.encode_utf8(bits).unwrap();\n+        let amt = ch.encode_utf8(&mut bits).unwrap();\n \n         unsafe {\n             ptr::copy_memory(self.vec.as_mut_ptr().offset((idx + amt) as int),\n@@ -1016,30 +1016,30 @@ mod tests {\n     fn test_utf16_invalid() {\n         // completely positive cases tested above.\n         // lead + eof\n-        assert_eq!(String::from_utf16([0xD800]), None);\n+        assert_eq!(String::from_utf16(&[0xD800]), None);\n         // lead + lead\n-        assert_eq!(String::from_utf16([0xD800, 0xD800]), None);\n+        assert_eq!(String::from_utf16(&[0xD800, 0xD800]), None);\n \n         // isolated trail\n-        assert_eq!(String::from_utf16([0x0061, 0xDC00]), None);\n+        assert_eq!(String::from_utf16(&[0x0061, 0xDC00]), None);\n \n         // general\n-        assert_eq!(String::from_utf16([0xD800, 0xd801, 0xdc8b, 0xD800]), None);\n+        assert_eq!(String::from_utf16(&[0xD800, 0xd801, 0xdc8b, 0xD800]), None);\n     }\n \n     #[test]\n     fn test_from_utf16_lossy() {\n         // completely positive cases tested above.\n         // lead + eof\n-        assert_eq!(String::from_utf16_lossy([0xD800]), String::from_str(\"\\uFFFD\"));\n+        assert_eq!(String::from_utf16_lossy(&[0xD800]), String::from_str(\"\\uFFFD\"));\n         // lead + lead\n-        assert_eq!(String::from_utf16_lossy([0xD800, 0xD800]), String::from_str(\"\\uFFFD\\uFFFD\"));\n+        assert_eq!(String::from_utf16_lossy(&[0xD800, 0xD800]), String::from_str(\"\\uFFFD\\uFFFD\"));\n \n         // isolated trail\n-        assert_eq!(String::from_utf16_lossy([0x0061, 0xDC00]), String::from_str(\"a\\uFFFD\"));\n+        assert_eq!(String::from_utf16_lossy(&[0x0061, 0xDC00]), String::from_str(\"a\\uFFFD\"));\n \n         // general\n-        assert_eq!(String::from_utf16_lossy([0xD800, 0xd801, 0xdc8b, 0xD800]),\n+        assert_eq!(String::from_utf16_lossy(&[0xD800, 0xd801, 0xdc8b, 0xD800]),\n                    String::from_str(\"\\uFFFD\ud801\udc8b\\uFFFD\"));\n     }\n \n@@ -1066,7 +1066,7 @@ mod tests {\n         let mut s = String::from_str(\"ABC\");\n         unsafe {\n             let mv = s.as_mut_vec();\n-            mv.push_all([b'D']);\n+            mv.push_all(&[b'D']);\n         }\n         assert_eq!(s.as_slice(), \"ABCD\");\n     }"}, {"sha": "abfaeed7e7ed0499a79db5092640e35b4c8bc2c1", "filename": "src/libcollections/tree/set.rs", "status": "modified", "additions": 29, "deletions": 29, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibcollections%2Ftree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibcollections%2Ftree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Ftree%2Fset.rs?ref=0047dbe59c41b951d34ce6324f3a8c0e15d523e9", "patch": "@@ -860,14 +860,14 @@ mod test {\n             check(a, b, expected, |x, y, f| x.intersection(y).all(f))\n         }\n \n-        check_intersection([], [], []);\n-        check_intersection([1, 2, 3], [], []);\n-        check_intersection([], [1, 2, 3], []);\n-        check_intersection([2], [1, 2, 3], [2]);\n-        check_intersection([1, 2, 3], [2], [2]);\n-        check_intersection([11, 1, 3, 77, 103, 5, -5],\n-                           [2, 11, 77, -9, -42, 5, 3],\n-                           [3, 5, 11, 77]);\n+        check_intersection(&[], &[], &[]);\n+        check_intersection(&[1, 2, 3], &[], &[]);\n+        check_intersection(&[], &[1, 2, 3], &[]);\n+        check_intersection(&[2], &[1, 2, 3], &[2]);\n+        check_intersection(&[1, 2, 3], &[2], &[2]);\n+        check_intersection(&[11, 1, 3, 77, 103, 5, -5],\n+                           &[2, 11, 77, -9, -42, 5, 3],\n+                           &[3, 5, 11, 77]);\n     }\n \n     #[test]\n@@ -876,15 +876,15 @@ mod test {\n             check(a, b, expected, |x, y, f| x.difference(y).all(f))\n         }\n \n-        check_difference([], [], []);\n-        check_difference([1, 12], [], [1, 12]);\n-        check_difference([], [1, 2, 3, 9], []);\n-        check_difference([1, 3, 5, 9, 11],\n-                         [3, 9],\n-                         [1, 5, 11]);\n-        check_difference([-5, 11, 22, 33, 40, 42],\n-                         [-12, -5, 14, 23, 34, 38, 39, 50],\n-                         [11, 22, 33, 40, 42]);\n+        check_difference(&[], &[], &[]);\n+        check_difference(&[1, 12], &[], &[1, 12]);\n+        check_difference(&[], &[1, 2, 3, 9], &[]);\n+        check_difference(&[1, 3, 5, 9, 11],\n+                         &[3, 9],\n+                         &[1, 5, 11]);\n+        check_difference(&[-5, 11, 22, 33, 40, 42],\n+                         &[-12, -5, 14, 23, 34, 38, 39, 50],\n+                         &[11, 22, 33, 40, 42]);\n     }\n \n     #[test]\n@@ -894,12 +894,12 @@ mod test {\n             check(a, b, expected, |x, y, f| x.symmetric_difference(y).all(f))\n         }\n \n-        check_symmetric_difference([], [], []);\n-        check_symmetric_difference([1, 2, 3], [2], [1, 3]);\n-        check_symmetric_difference([2], [1, 2, 3], [1, 3]);\n-        check_symmetric_difference([1, 3, 5, 9, 11],\n-                                   [-2, 3, 9, 14, 22],\n-                                   [-2, 1, 5, 11, 14, 22]);\n+        check_symmetric_difference(&[], &[], &[]);\n+        check_symmetric_difference(&[1, 2, 3], &[2], &[1, 3]);\n+        check_symmetric_difference(&[2], &[1, 2, 3], &[1, 3]);\n+        check_symmetric_difference(&[1, 3, 5, 9, 11],\n+                                   &[-2, 3, 9, 14, 22],\n+                                   &[-2, 1, 5, 11, 14, 22]);\n     }\n \n     #[test]\n@@ -909,12 +909,12 @@ mod test {\n             check(a, b, expected, |x, y, f| x.union(y).all(f))\n         }\n \n-        check_union([], [], []);\n-        check_union([1, 2, 3], [2], [1, 2, 3]);\n-        check_union([2], [1, 2, 3], [1, 2, 3]);\n-        check_union([1, 3, 5, 9, 11, 16, 19, 24],\n-                    [-2, 1, 5, 9, 13, 19],\n-                    [-2, 1, 3, 5, 9, 11, 13, 16, 19, 24]);\n+        check_union(&[], &[], &[]);\n+        check_union(&[1, 2, 3], &[2], &[1, 2, 3]);\n+        check_union(&[2], &[1, 2, 3], &[1, 2, 3]);\n+        check_union(&[1, 3, 5, 9, 11, 16, 19, 24],\n+                    &[-2, 1, 5, 9, 13, 19],\n+                    &[-2, 1, 3, 5, 9, 11, 13, 16, 19, 24]);\n     }\n \n     #[test]"}, {"sha": "7111a0776307a976045ebb6df22f90825620ef74", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=0047dbe59c41b951d34ce6324f3a8c0e15d523e9", "patch": "@@ -47,7 +47,7 @@ use slice::{CloneSliceAllocPrelude};\n /// vec[0] = 7i;\n /// assert_eq!(vec[0], 7);\n ///\n-/// vec.push_all([1, 2, 3]);\n+/// vec.push_all(&[1, 2, 3]);\n ///\n /// for x in vec.iter() {\n ///     println!(\"{}\", x);\n@@ -306,7 +306,7 @@ impl<T: Clone> Vec<T> {\n     ///\n     /// ```\n     /// let mut vec = vec![1i];\n-    /// vec.push_all([2i, 3, 4]);\n+    /// vec.push_all(&[2i, 3, 4]);\n     /// assert_eq!(vec, vec![1, 2, 3, 4]);\n     /// ```\n     #[inline]\n@@ -639,7 +639,7 @@ impl<T> Vec<T> {\n     ///\n     /// ```\n     /// let mut vec: Vec<int> = Vec::with_capacity(10);\n-    /// vec.push_all([1, 2, 3]);\n+    /// vec.push_all(&[1, 2, 3]);\n     /// assert_eq!(vec.capacity(), 10);\n     /// vec.shrink_to_fit();\n     /// assert!(vec.capacity() >= 3);\n@@ -1682,7 +1682,7 @@ mod tests {\n     #[test]\n     fn test_as_vec() {\n         let xs = [1u8, 2u8, 3u8];\n-        assert_eq!(as_vec(xs).as_slice(), xs.as_slice());\n+        assert_eq!(as_vec(&xs).as_slice(), xs.as_slice());\n     }\n \n     #[test]\n@@ -1772,27 +1772,27 @@ mod tests {\n         let mut values = vec![1u8,2,3,4,5];\n         {\n             let slice = values.slice_from_mut(2);\n-            assert!(slice == [3, 4, 5]);\n+            assert!(slice == &mut [3, 4, 5]);\n             for p in slice.iter_mut() {\n                 *p += 2;\n             }\n         }\n \n-        assert!(values.as_slice() == [1, 2, 5, 6, 7]);\n+        assert!(values.as_slice() == &[1, 2, 5, 6, 7]);\n     }\n \n     #[test]\n     fn test_slice_to_mut() {\n         let mut values = vec![1u8,2,3,4,5];\n         {\n             let slice = values.slice_to_mut(2);\n-            assert!(slice == [1, 2]);\n+            assert!(slice == &mut [1, 2]);\n             for p in slice.iter_mut() {\n                 *p += 1;\n             }\n         }\n \n-        assert!(values.as_slice() == [2, 3, 3, 4, 5]);\n+        assert!(values.as_slice() == &[2, 3, 3, 4, 5]);\n     }\n \n     #[test]"}, {"sha": "2e358e7a74b648dd0667ae6b052a6601f48c2d14", "filename": "src/libcore/finally.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibcore%2Ffinally.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibcore%2Ffinally.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffinally.rs?ref=0047dbe59c41b951d34ce6324f3a8c0e15d523e9", "patch": "@@ -79,7 +79,7 @@ impl<T> Finally<T> for fn() -> T {\n  *\n  * struct State<'a> { buffer: &'a mut [u8], len: uint }\n  * # let mut buf = [];\n- * let mut state = State { buffer: buf, len: 0 };\n+ * let mut state = State { buffer: &mut buf, len: 0 };\n  * try_finally(\n  *     &mut state, (),\n  *     |state, ()| {"}, {"sha": "bb3c8e71a52ca28e47dab192b25a15247c83fe41", "filename": "src/libcore/fmt/float.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibcore%2Ffmt%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibcore%2Ffmt%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Ffloat.rs?ref=0047dbe59c41b951d34ce6324f3a8c0e15d523e9", "patch": "@@ -315,7 +315,7 @@ pub fn float_to_str_bytes_common<T: Float, U>(\n                 }\n             }\n \n-            let mut filler = Filler { buf: buf, end: &mut end };\n+            let mut filler = Filler { buf: &mut buf, end: &mut end };\n             match sign {\n                 SignNeg => {\n                     let _ = format_args!(|args| {"}, {"sha": "2d33d5b5525fd04275d8575ddf45e6eca2173bc9", "filename": "src/libcore/fmt/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=0047dbe59c41b951d34ce6324f3a8c0e15d523e9", "patch": "@@ -392,7 +392,7 @@ impl<'a> Formatter<'a> {\n         let write_prefix = |f: &mut Formatter| {\n             for c in sign.into_iter() {\n                 let mut b = [0, ..4];\n-                let n = c.encode_utf8(b).unwrap_or(0);\n+                let n = c.encode_utf8(&mut b).unwrap_or(0);\n                 try!(f.buf.write(b[..n]));\n             }\n             if prefixed { f.buf.write(prefix.as_bytes()) }\n@@ -497,7 +497,7 @@ impl<'a> Formatter<'a> {\n         };\n \n         let mut fill = [0u8, ..4];\n-        let len = self.fill.encode_utf8(fill).unwrap_or(0);\n+        let len = self.fill.encode_utf8(&mut fill).unwrap_or(0);\n \n         for _ in range(0, pre_pad) {\n             try!(self.buf.write(fill[..len]));\n@@ -586,7 +586,7 @@ impl Char for char {\n         use char::Char;\n \n         let mut utf8 = [0u8, ..4];\n-        let amt = self.encode_utf8(utf8).unwrap_or(0);\n+        let amt = self.encode_utf8(&mut utf8).unwrap_or(0);\n         let s: &str = unsafe { mem::transmute(utf8[..amt]) };\n         String::fmt(s, f)\n     }"}, {"sha": "067ef47a86b9f9a44bc35ba7bae49310971892d5", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=0047dbe59c41b951d34ce6324f3a8c0e15d523e9", "patch": "@@ -228,7 +228,7 @@ extern \"rust-intrinsic\" {\n     /// use std::mem;\n     ///\n     /// let v: &[u8] = unsafe { mem::transmute(\"L\") };\n-    /// assert!(v == [76u8]);\n+    /// assert!(v == &[76u8]);\n     /// ```\n     pub fn transmute<T,U>(e: T) -> U;\n "}, {"sha": "0c30c4f749a81c9c34b12e5a212866783b7d289f", "filename": "src/libcore/option.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=0047dbe59c41b951d34ce6324f3a8c0e15d523e9", "patch": "@@ -271,9 +271,9 @@ impl<T> Option<T> {\n     /// let mut x = Some(\"Diamonds\");\n     /// {\n     ///     let v = x.as_mut_slice();\n-    ///     assert!(v == [\"Diamonds\"]);\n+    ///     assert!(v == &mut [\"Diamonds\"]);\n     ///     v[0] = \"Dirt\";\n-    ///     assert!(v == [\"Dirt\"]);\n+    ///     assert!(v == &mut [\"Dirt\"]);\n     /// }\n     /// assert_eq!(x, Some(\"Dirt\"));\n     /// ```"}, {"sha": "e88b6b2cf03d8915afdd72818e66b39daf7ad6a9", "filename": "src/libcore/result.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=0047dbe59c41b951d34ce6324f3a8c0e15d523e9", "patch": "@@ -451,14 +451,14 @@ impl<T, E> Result<T, E> {\n     /// let mut x: Result<&str, uint> = Ok(\"Gold\");\n     /// {\n     ///     let v = x.as_mut_slice();\n-    ///     assert!(v == [\"Gold\"]);\n+    ///     assert!(v == &mut [\"Gold\"]);\n     ///     v[0] = \"Silver\";\n-    ///     assert!(v == [\"Silver\"]);\n+    ///     assert!(v == &mut [\"Silver\"]);\n     /// }\n     /// assert_eq!(x, Ok(\"Silver\"));\n     ///\n     /// let mut x: Result<&str, uint> = Err(45);\n-    /// assert!(x.as_mut_slice() == []);\n+    /// assert!(x.as_mut_slice() == &mut []);\n     /// ```\n     #[inline]\n     #[unstable = \"waiting for mut conventions\"]"}, {"sha": "a7730b67f1f8dfaec28b52d537d6b34eebb4fb0d", "filename": "src/libcore/slice.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibcore%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibcore%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice.rs?ref=0047dbe59c41b951d34ce6324f3a8c0e15d523e9", "patch": "@@ -973,11 +973,11 @@ pub trait CloneSlicePrelude<T> for Sized? {\n     /// let mut dst = [0i, 0, 0];\n     /// let src = [1i, 2];\n     ///\n-    /// assert!(dst.clone_from_slice(src) == 2);\n+    /// assert!(dst.clone_from_slice(&src) == 2);\n     /// assert!(dst == [1, 2, 0]);\n     ///\n     /// let src2 = [3i, 4, 5, 6];\n-    /// assert!(dst.clone_from_slice(src2) == 3);\n+    /// assert!(dst.clone_from_slice(&src2) == 3);\n     /// assert!(dst == [3i, 4, 5]);\n     /// ```\n     fn clone_from_slice(&mut self, &[T]) -> uint;"}, {"sha": "cde255f10f4711d5e5e7024ba47030d68c6777da", "filename": "src/libcore/str.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=0047dbe59c41b951d34ce6324f3a8c0e15d523e9", "patch": "@@ -1008,7 +1008,7 @@ impl<'a> Iterator<Utf16Item> for Utf16Items<'a> {\n ///          0x0073, 0xDD1E, 0x0069, 0x0063,\n ///          0xD834];\n ///\n-/// assert_eq!(str::utf16_items(v).collect::<Vec<_>>(),\n+/// assert_eq!(str::utf16_items(&v).collect::<Vec<_>>(),\n ///            vec![ScalarValue('\ud834\udd1e'),\n ///                 ScalarValue('m'), ScalarValue('u'), ScalarValue('s'),\n ///                 LoneSurrogate(0xDD1E),\n@@ -1030,12 +1030,12 @@ pub fn utf16_items<'a>(v: &'a [u16]) -> Utf16Items<'a> {\n /// // \"abcd\"\n /// let mut v = ['a' as u16, 'b' as u16, 'c' as u16, 'd' as u16];\n /// // no NULs so no change\n-/// assert_eq!(str::truncate_utf16_at_nul(v), v.as_slice());\n+/// assert_eq!(str::truncate_utf16_at_nul(&v), v.as_slice());\n ///\n /// // \"ab\\0d\"\n /// v[2] = 0;\n /// let b: &[_] = &['a' as u16, 'b' as u16];\n-/// assert_eq!(str::truncate_utf16_at_nul(v), b);\n+/// assert_eq!(str::truncate_utf16_at_nul(&v), b);\n /// ```\n pub fn truncate_utf16_at_nul<'a>(v: &'a [u16]) -> &'a [u16] {\n     match v.iter().position(|c| *c == 0) {"}, {"sha": "8ec3c59da4e00fe1cf1841f4370b87c25a0214a2", "filename": "src/libcoretest/char.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibcoretest%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibcoretest%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fchar.rs?ref=0047dbe59c41b951d34ce6324f3a8c0e15d523e9", "patch": "@@ -177,10 +177,10 @@ fn test_encode_utf8() {\n         assert_eq!(buf[..n], expect);\n     }\n \n-    check('x', [0x78]);\n-    check('\\u00e9', [0xc3, 0xa9]);\n-    check('\\ua66e', [0xea, 0x99, 0xae]);\n-    check('\\U0001f4a9', [0xf0, 0x9f, 0x92, 0xa9]);\n+    check('x', &[0x78]);\n+    check('\\u00e9', &[0xc3, 0xa9]);\n+    check('\\ua66e', &[0xea, 0x99, 0xae]);\n+    check('\\U0001f4a9', &[0xf0, 0x9f, 0x92, 0xa9]);\n }\n \n #[test]\n@@ -191,10 +191,10 @@ fn test_encode_utf16() {\n         assert_eq!(buf[..n], expect);\n     }\n \n-    check('x', [0x0078]);\n-    check('\\u00e9', [0x00e9]);\n-    check('\\ua66e', [0xa66e]);\n-    check('\\U0001f4a9', [0xd83d, 0xdca9]);\n+    check('x', &[0x0078]);\n+    check('\\u00e9', &[0x00e9]);\n+    check('\\ua66e', &[0xa66e]);\n+    check('\\U0001f4a9', &[0xd83d, 0xdca9]);\n }\n \n #[test]"}, {"sha": "32aff498ba109fe91ce7c446dc62f720b46012aa", "filename": "src/libcoretest/iter.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibcoretest%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibcoretest%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fiter.rs?ref=0047dbe59c41b951d34ce6324f3a8c0e15d523e9", "patch": "@@ -627,7 +627,7 @@ fn test_random_access_zip() {\n #[test]\n fn test_random_access_take() {\n     let xs = [1i, 2, 3, 4, 5];\n-    let empty: &[int] = [];\n+    let empty: &[int] = &[];\n     check_randacc_iter(xs.iter().take(3), 3);\n     check_randacc_iter(xs.iter().take(20), xs.len());\n     check_randacc_iter(xs.iter().take(0), 0);\n@@ -637,7 +637,7 @@ fn test_random_access_take() {\n #[test]\n fn test_random_access_skip() {\n     let xs = [1i, 2, 3, 4, 5];\n-    let empty: &[int] = [];\n+    let empty: &[int] = &[];\n     check_randacc_iter(xs.iter().skip(2), xs.len() - 2);\n     check_randacc_iter(empty.iter().skip(2), 0);\n }\n@@ -669,7 +669,7 @@ fn test_random_access_map() {\n #[test]\n fn test_random_access_cycle() {\n     let xs = [1i, 2, 3, 4, 5];\n-    let empty: &[int] = [];\n+    let empty: &[int] = &[];\n     check_randacc_iter(xs.iter().cycle().take(27), 27);\n     check_randacc_iter(empty.iter().cycle(), 0);\n }"}, {"sha": "2dd9d00ca1f23ad64e406250d490a98713c18ed0", "filename": "src/libfmt_macros/lib.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibfmt_macros%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibfmt_macros%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfmt_macros%2Flib.rs?ref=0047dbe59c41b951d34ce6324f3a8c0e15d523e9", "patch": "@@ -454,12 +454,12 @@ mod tests {\n \n     #[test]\n     fn simple() {\n-        same(\"asdf\", [String(\"asdf\")]);\n-        same(\"a{{b\", [String(\"a\"), String(\"{b\")]);\n-        same(\"a}}b\", [String(\"a\"), String(\"}b\")]);\n-        same(\"a}}\", [String(\"a\"), String(\"}\")]);\n-        same(\"}}\", [String(\"}\")]);\n-        same(\"\\\\}}\", [String(\"\\\\\"), String(\"}\")]);\n+        same(\"asdf\", &[String(\"asdf\")]);\n+        same(\"a{{b\", &[String(\"a\"), String(\"{b\")]);\n+        same(\"a}}b\", &[String(\"a\"), String(\"}b\")]);\n+        same(\"a}}\", &[String(\"a\"), String(\"}\")]);\n+        same(\"}}\", &[String(\"}\")]);\n+        same(\"\\\\}}\", &[String(\"\\\\\"), String(\"}\")]);\n     }\n \n     #[test] fn invalid01() { musterr(\"{\") }\n@@ -470,28 +470,28 @@ mod tests {\n \n     #[test]\n     fn format_nothing() {\n-        same(\"{}\", [NextArgument(Argument {\n+        same(\"{}\", &[NextArgument(Argument {\n             position: ArgumentNext,\n             format: fmtdflt(),\n         })]);\n     }\n     #[test]\n     fn format_position() {\n-        same(\"{3}\", [NextArgument(Argument {\n+        same(\"{3}\", &[NextArgument(Argument {\n             position: ArgumentIs(3),\n             format: fmtdflt(),\n         })]);\n     }\n     #[test]\n     fn format_position_nothing_else() {\n-        same(\"{3:}\", [NextArgument(Argument {\n+        same(\"{3:}\", &[NextArgument(Argument {\n             position: ArgumentIs(3),\n             format: fmtdflt(),\n         })]);\n     }\n     #[test]\n     fn format_type() {\n-        same(\"{3:a}\", [NextArgument(Argument {\n+        same(\"{3:a}\", &[NextArgument(Argument {\n             position: ArgumentIs(3),\n             format: FormatSpec {\n                 fill: None,\n@@ -505,7 +505,7 @@ mod tests {\n     }\n     #[test]\n     fn format_align_fill() {\n-        same(\"{3:>}\", [NextArgument(Argument {\n+        same(\"{3:>}\", &[NextArgument(Argument {\n             position: ArgumentIs(3),\n             format: FormatSpec {\n                 fill: None,\n@@ -516,7 +516,7 @@ mod tests {\n                 ty: \"\",\n             },\n         })]);\n-        same(\"{3:0<}\", [NextArgument(Argument {\n+        same(\"{3:0<}\", &[NextArgument(Argument {\n             position: ArgumentIs(3),\n             format: FormatSpec {\n                 fill: Some('0'),\n@@ -527,7 +527,7 @@ mod tests {\n                 ty: \"\",\n             },\n         })]);\n-        same(\"{3:*<abcd}\", [NextArgument(Argument {\n+        same(\"{3:*<abcd}\", &[NextArgument(Argument {\n             position: ArgumentIs(3),\n             format: FormatSpec {\n                 fill: Some('*'),\n@@ -541,7 +541,7 @@ mod tests {\n     }\n     #[test]\n     fn format_counts() {\n-        same(\"{:10s}\", [NextArgument(Argument {\n+        same(\"{:10s}\", &[NextArgument(Argument {\n             position: ArgumentNext,\n             format: FormatSpec {\n                 fill: None,\n@@ -552,7 +552,7 @@ mod tests {\n                 ty: \"s\",\n             },\n         })]);\n-        same(\"{:10$.10s}\", [NextArgument(Argument {\n+        same(\"{:10$.10s}\", &[NextArgument(Argument {\n             position: ArgumentNext,\n             format: FormatSpec {\n                 fill: None,\n@@ -563,7 +563,7 @@ mod tests {\n                 ty: \"s\",\n             },\n         })]);\n-        same(\"{:.*s}\", [NextArgument(Argument {\n+        same(\"{:.*s}\", &[NextArgument(Argument {\n             position: ArgumentNext,\n             format: FormatSpec {\n                 fill: None,\n@@ -574,7 +574,7 @@ mod tests {\n                 ty: \"s\",\n             },\n         })]);\n-        same(\"{:.10$s}\", [NextArgument(Argument {\n+        same(\"{:.10$s}\", &[NextArgument(Argument {\n             position: ArgumentNext,\n             format: FormatSpec {\n                 fill: None,\n@@ -585,7 +585,7 @@ mod tests {\n                 ty: \"s\",\n             },\n         })]);\n-        same(\"{:a$.b$s}\", [NextArgument(Argument {\n+        same(\"{:a$.b$s}\", &[NextArgument(Argument {\n             position: ArgumentNext,\n             format: FormatSpec {\n                 fill: None,\n@@ -599,7 +599,7 @@ mod tests {\n     }\n     #[test]\n     fn format_flags() {\n-        same(\"{:-}\", [NextArgument(Argument {\n+        same(\"{:-}\", &[NextArgument(Argument {\n             position: ArgumentNext,\n             format: FormatSpec {\n                 fill: None,\n@@ -610,7 +610,7 @@ mod tests {\n                 ty: \"\",\n             },\n         })]);\n-        same(\"{:+#}\", [NextArgument(Argument {\n+        same(\"{:+#}\", &[NextArgument(Argument {\n             position: ArgumentNext,\n             format: FormatSpec {\n                 fill: None,\n@@ -624,7 +624,7 @@ mod tests {\n     }\n     #[test]\n     fn format_mixture() {\n-        same(\"abcd {3:a} efg\", [String(\"abcd \"), NextArgument(Argument {\n+        same(\"abcd {3:a} efg\", &[String(\"abcd \"), NextArgument(Argument {\n             position: ArgumentIs(3),\n             format: FormatSpec {\n                 fill: None,"}, {"sha": "c2fb52e5c5deaba59583114116201c7bc48c2066", "filename": "src/libgetopts/lib.rs", "status": "modified", "additions": 35, "deletions": 35, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibgetopts%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibgetopts%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgetopts%2Flib.rs?ref=0047dbe59c41b951d34ce6324f3a8c0e15d523e9", "patch": "@@ -55,7 +55,7 @@\n //!\n //!     let program = args[0].clone();\n //!\n-//!     let opts = [\n+//!     let opts = &[\n //!         optopt(\"o\", \"\", \"set output file name\", \"NAME\"),\n //!         optflag(\"h\", \"help\", \"print this help menu\")\n //!     ];\n@@ -942,16 +942,16 @@ fn test_split_within() {\n         each_split_within(s, i, |s| { v.push(s.to_string()); true });\n         assert!(v.iter().zip(u.iter()).all(|(a,b)| a == b));\n     }\n-    t(\"\", 0, []);\n-    t(\"\", 15, []);\n-    t(\"hello\", 15, [\"hello\".to_string()]);\n-    t(\"\\nMary had a little lamb\\nLittle lamb\\n\", 15, [\n+    t(\"\", 0, &[]);\n+    t(\"\", 15, &[]);\n+    t(\"hello\", 15, &[\"hello\".to_string()]);\n+    t(\"\\nMary had a little lamb\\nLittle lamb\\n\", 15, &[\n         \"Mary had a\".to_string(),\n         \"little lamb\".to_string(),\n         \"Little lamb\".to_string()\n     ]);\n     t(\"\\nMary had a little lamb\\nLittle lamb\\n\", ::std::uint::MAX,\n-        [\"Mary had a little lamb\\nLittle lamb\".to_string()]);\n+        &[\"Mary had a little lamb\\nLittle lamb\".to_string()]);\n }\n \n #[cfg(test)]\n@@ -1414,17 +1414,17 @@ mod tests {\n           result::Ok(m) => m,\n           result::Err(_) => panic!()\n         };\n-        assert!(matches_single.opts_present([\"e\".to_string()]));\n-        assert!(matches_single.opts_present([\"encrypt\".to_string(), \"e\".to_string()]));\n-        assert!(matches_single.opts_present([\"e\".to_string(), \"encrypt\".to_string()]));\n-        assert!(!matches_single.opts_present([\"encrypt\".to_string()]));\n-        assert!(!matches_single.opts_present([\"thing\".to_string()]));\n-        assert!(!matches_single.opts_present([]));\n-\n-        assert_eq!(matches_single.opts_str([\"e\".to_string()]).unwrap(), \"foo\".to_string());\n-        assert_eq!(matches_single.opts_str([\"e\".to_string(), \"encrypt\".to_string()]).unwrap(),\n+        assert!(matches_single.opts_present(&[\"e\".to_string()]));\n+        assert!(matches_single.opts_present(&[\"encrypt\".to_string(), \"e\".to_string()]));\n+        assert!(matches_single.opts_present(&[\"e\".to_string(), \"encrypt\".to_string()]));\n+        assert!(!matches_single.opts_present(&[\"encrypt\".to_string()]));\n+        assert!(!matches_single.opts_present(&[\"thing\".to_string()]));\n+        assert!(!matches_single.opts_present(&[]));\n+\n+        assert_eq!(matches_single.opts_str(&[\"e\".to_string()]).unwrap(), \"foo\".to_string());\n+        assert_eq!(matches_single.opts_str(&[\"e\".to_string(), \"encrypt\".to_string()]).unwrap(),\n                    \"foo\".to_string());\n-        assert_eq!(matches_single.opts_str([\"encrypt\".to_string(), \"e\".to_string()]).unwrap(),\n+        assert_eq!(matches_single.opts_str(&[\"encrypt\".to_string(), \"e\".to_string()]).unwrap(),\n                    \"foo\".to_string());\n \n         let args_both = vec!(\"-e\".to_string(), \"foo\".to_string(), \"--encrypt\".to_string(),\n@@ -1434,19 +1434,19 @@ mod tests {\n           result::Ok(m) => m,\n           result::Err(_) => panic!()\n         };\n-        assert!(matches_both.opts_present([\"e\".to_string()]));\n-        assert!(matches_both.opts_present([\"encrypt\".to_string()]));\n-        assert!(matches_both.opts_present([\"encrypt\".to_string(), \"e\".to_string()]));\n-        assert!(matches_both.opts_present([\"e\".to_string(), \"encrypt\".to_string()]));\n-        assert!(!matches_both.opts_present([\"f\".to_string()]));\n-        assert!(!matches_both.opts_present([\"thing\".to_string()]));\n-        assert!(!matches_both.opts_present([]));\n-\n-        assert_eq!(matches_both.opts_str([\"e\".to_string()]).unwrap(), \"foo\".to_string());\n-        assert_eq!(matches_both.opts_str([\"encrypt\".to_string()]).unwrap(), \"foo\".to_string());\n-        assert_eq!(matches_both.opts_str([\"e\".to_string(), \"encrypt\".to_string()]).unwrap(),\n+        assert!(matches_both.opts_present(&[\"e\".to_string()]));\n+        assert!(matches_both.opts_present(&[\"encrypt\".to_string()]));\n+        assert!(matches_both.opts_present(&[\"encrypt\".to_string(), \"e\".to_string()]));\n+        assert!(matches_both.opts_present(&[\"e\".to_string(), \"encrypt\".to_string()]));\n+        assert!(!matches_both.opts_present(&[\"f\".to_string()]));\n+        assert!(!matches_both.opts_present(&[\"thing\".to_string()]));\n+        assert!(!matches_both.opts_present(&[]));\n+\n+        assert_eq!(matches_both.opts_str(&[\"e\".to_string()]).unwrap(), \"foo\".to_string());\n+        assert_eq!(matches_both.opts_str(&[\"encrypt\".to_string()]).unwrap(), \"foo\".to_string());\n+        assert_eq!(matches_both.opts_str(&[\"e\".to_string(), \"encrypt\".to_string()]).unwrap(),\n                    \"foo\".to_string());\n-        assert_eq!(matches_both.opts_str([\"encrypt\".to_string(), \"e\".to_string()]).unwrap(),\n+        assert_eq!(matches_both.opts_str(&[\"encrypt\".to_string(), \"e\".to_string()]).unwrap(),\n                    \"foo\".to_string());\n     }\n \n@@ -1459,10 +1459,10 @@ mod tests {\n           result::Ok(m) => m,\n           result::Err(_) => panic!()\n         };\n-        assert!(matches.opts_present([\"L\".to_string()]));\n-        assert_eq!(matches.opts_str([\"L\".to_string()]).unwrap(), \"foo\".to_string());\n-        assert!(matches.opts_present([\"M\".to_string()]));\n-        assert_eq!(matches.opts_str([\"M\".to_string()]).unwrap(), \".\".to_string());\n+        assert!(matches.opts_present(&[\"L\".to_string()]));\n+        assert_eq!(matches.opts_str(&[\"L\".to_string()]).unwrap(), \"foo\".to_string());\n+        assert!(matches.opts_present(&[\"M\".to_string()]));\n+        assert_eq!(matches.opts_str(&[\"M\".to_string()]).unwrap(), \".\".to_string());\n \n     }\n \n@@ -1475,9 +1475,9 @@ mod tests {\n           result::Ok(m) => m,\n           result::Err(e) => panic!( \"{}\", e )\n         };\n-        assert!(matches.opts_present([\"L\".to_string()]));\n-        assert_eq!(matches.opts_str([\"L\".to_string()]).unwrap(), \"verbose\".to_string());\n-        assert!(matches.opts_present([\"v\".to_string()]));\n+        assert!(matches.opts_present(&[\"L\".to_string()]));\n+        assert_eq!(matches.opts_str(&[\"L\".to_string()]).unwrap(), \"verbose\".to_string());\n+        assert!(matches.opts_present(&[\"v\".to_string()]));\n         assert_eq!(3, matches.opt_count(\"v\"));\n     }\n "}, {"sha": "7035809640d4a82ef6603707ea727aed6513054d", "filename": "src/libgraphviz/lib.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibgraphviz%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibgraphviz%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgraphviz%2Flib.rs?ref=0047dbe59c41b951d34ce6324f3a8c0e15d523e9", "patch": "@@ -514,13 +514,13 @@ pub fn render<'a, N:'a, E:'a, G:Labeller<'a,N,E>+GraphWalk<'a,N,E>, W:Writer>(\n         w.write_str(\"    \")\n     }\n \n-    try!(writeln(w, [\"digraph \", g.graph_id().as_slice(), \" {\"]));\n+    try!(writeln(w, &[\"digraph \", g.graph_id().as_slice(), \" {\"]));\n     for n in g.nodes().iter() {\n         try!(indent(w));\n         let id = g.node_id(n);\n         let escaped = g.node_label(n).escape();\n-        try!(writeln(w, [id.as_slice(),\n-                         \"[label=\\\"\", escaped.as_slice(), \"\\\"];\"]));\n+        try!(writeln(w, &[id.as_slice(),\n+                          \"[label=\\\"\", escaped.as_slice(), \"\\\"];\"]));\n     }\n \n     for e in g.edges().iter() {\n@@ -530,11 +530,11 @@ pub fn render<'a, N:'a, E:'a, G:Labeller<'a,N,E>+GraphWalk<'a,N,E>, W:Writer>(\n         let target = g.target(e);\n         let source_id = g.node_id(&source);\n         let target_id = g.node_id(&target);\n-        try!(writeln(w, [source_id.as_slice(), \" -> \", target_id.as_slice(),\n-                         \"[label=\\\"\", escaped_label.as_slice(), \"\\\"];\"]));\n+        try!(writeln(w, &[source_id.as_slice(), \" -> \", target_id.as_slice(),\n+                          \"[label=\\\"\", escaped_label.as_slice(), \"\\\"];\"]));\n     }\n \n-    writeln(w, [\"}\"])\n+    writeln(w, &[\"}\"])\n }\n \n #[cfg(test)]"}, {"sha": "5d8c1745723463d6f47f8e8d0b48d475ce7cf351", "filename": "src/libgreen/stack.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibgreen%2Fstack.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibgreen%2Fstack.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Fstack.rs?ref=0047dbe59c41b951d34ce6324f3a8c0e15d523e9", "patch": "@@ -44,8 +44,8 @@ impl Stack {\n         // allocation failure, which would fail to spawn the task. But there's\n         // not many sensible things to do on OOM.  Failure seems fine (and is\n         // what the old stack allocation did).\n-        let stack = match MemoryMap::new(size, [MapReadable, MapWritable,\n-                                         MapNonStandardFlags(STACK_FLAGS)]) {\n+        let stack = match MemoryMap::new(size, &[MapReadable, MapWritable,\n+                                                 MapNonStandardFlags(STACK_FLAGS)]) {\n             Ok(map) => map,\n             Err(e) => panic!(\"mmap for stack of size {} failed: {}\", size, e)\n         };"}, {"sha": "c777b8db31369291cb41e90ea9b2a529d6ce4ff7", "filename": "src/librand/distributions/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibrand%2Fdistributions%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibrand%2Fdistributions%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fdistributions%2Fmod.rs?ref=0047dbe59c41b951d34ce6324f3a8c0e15d523e9", "patch": "@@ -349,7 +349,7 @@ mod tests {\n \n     #[test] #[should_fail]\n     fn test_weighted_choice_no_items() {\n-        WeightedChoice::<int>::new([]);\n+        WeightedChoice::<int>::new(&mut []);\n     }\n     #[test] #[should_fail]\n     fn test_weighted_choice_zero_weight() {"}, {"sha": "24ad917c250cd4943b9f0c46d95c35fe85b47ea4", "filename": "src/librand/distributions/range.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibrand%2Fdistributions%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibrand%2Fdistributions%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fdistributions%2Frange.rs?ref=0047dbe59c41b951d34ce6324f3a8c0e15d523e9", "patch": "@@ -185,9 +185,9 @@ mod tests {\n         macro_rules! t (\n             ($($ty:ty),*) => {{\n                 $(\n-                   let v: &[($ty, $ty)] = [(0, 10),\n-                                           (10, 127),\n-                                           (Int::min_value(), Int::max_value())];\n+                   let v: &[($ty, $ty)] = &[(0, 10),\n+                                            (10, 127),\n+                                            (Int::min_value(), Int::max_value())];\n                    for &(low, high) in v.iter() {\n                         let mut sampler: Range<$ty> = Range::new(low, high);\n                         for _ in range(0u, 1000) {\n@@ -210,10 +210,10 @@ mod tests {\n         macro_rules! t (\n             ($($ty:ty),*) => {{\n                 $(\n-                   let v: &[($ty, $ty)] = [(0.0, 100.0),\n-                                           (-1e35, -1e25),\n-                                           (1e-35, 1e-25),\n-                                           (-1e35, 1e35)];\n+                   let v: &[($ty, $ty)] = &[(0.0, 100.0),\n+                                            (-1e35, -1e25),\n+                                            (1e-35, 1e-25),\n+                                            (-1e35, 1e35)];\n                    for &(low, high) in v.iter() {\n                         let mut sampler: Range<$ty> = Range::new(low, high);\n                         for _ in range(0u, 1000) {"}, {"sha": "117cca1b8b572c396509d0115a90f5d4b46e537f", "filename": "src/librand/lib.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibrand%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibrand%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Flib.rs?ref=0047dbe59c41b951d34ce6324f3a8c0e15d523e9", "patch": "@@ -142,7 +142,7 @@ pub trait Rng {\n     /// use std::rand::{task_rng, Rng};\n     ///\n     /// let mut v = [0u8, .. 13579];\n-    /// task_rng().fill_bytes(v);\n+    /// task_rng().fill_bytes(&mut v);\n     /// println!(\"{}\", v.as_slice());\n     /// ```\n     fn fill_bytes(&mut self, dest: &mut [u8]) {\n@@ -268,7 +268,7 @@ pub trait Rng {\n     ///\n     /// let choices = [1i, 2, 4, 8, 16, 32];\n     /// let mut rng = task_rng();\n-    /// println!(\"{}\", rng.choose(choices));\n+    /// println!(\"{}\", rng.choose(&choices));\n     /// assert_eq!(rng.choose(choices[..0]), None);\n     /// ```\n     fn choose<'a, T>(&mut self, values: &'a [T]) -> Option<&'a T> {\n@@ -288,9 +288,9 @@ pub trait Rng {\n     ///\n     /// let mut rng = task_rng();\n     /// let mut y = [1i, 2, 3];\n-    /// rng.shuffle(y);\n+    /// rng.shuffle(&mut y);\n     /// println!(\"{}\", y.as_slice());\n-    /// rng.shuffle(y);\n+    /// rng.shuffle(&mut y);\n     /// println!(\"{}\", y.as_slice());\n     /// ```\n     fn shuffle<T>(&mut self, values: &mut [T]) {\n@@ -347,7 +347,7 @@ pub trait SeedableRng<Seed>: Rng {\n     /// let seed: &[_] = &[1, 2, 3, 4];\n     /// let mut rng: StdRng = SeedableRng::from_seed(seed);\n     /// println!(\"{}\", rng.gen::<f64>());\n-    /// rng.reseed([5, 6, 7, 8]);\n+    /// rng.reseed(&[5, 6, 7, 8]);\n     /// println!(\"{}\", rng.gen::<f64>());\n     /// ```\n     fn reseed(&mut self, Seed);"}, {"sha": "b46b977d7012dca1c9d2e62352fd4af32c878bee", "filename": "src/librbml/io.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibrbml%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibrbml%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrbml%2Fio.rs?ref=0047dbe59c41b951d34ce6324f3a8c0e15d523e9", "patch": "@@ -42,7 +42,7 @@ fn combine(seek: SeekStyle, cur: uint, end: uint, offset: i64) -> IoResult<u64>\n /// use rbml::io::SeekableMemWriter;\n ///\n /// let mut w = SeekableMemWriter::new();\n-/// w.write([0, 1, 2]);\n+/// w.write(&[0, 1, 2]);\n ///\n /// assert_eq!(w.unwrap(), vec!(0, 1, 2));\n /// ```\n@@ -138,32 +138,32 @@ mod tests {\n     fn test_seekable_mem_writer() {\n         let mut writer = SeekableMemWriter::new();\n         assert_eq!(writer.tell(), Ok(0));\n-        writer.write([0]).unwrap();\n+        writer.write(&[0]).unwrap();\n         assert_eq!(writer.tell(), Ok(1));\n-        writer.write([1, 2, 3]).unwrap();\n-        writer.write([4, 5, 6, 7]).unwrap();\n+        writer.write(&[1, 2, 3]).unwrap();\n+        writer.write(&[4, 5, 6, 7]).unwrap();\n         assert_eq!(writer.tell(), Ok(8));\n         let b: &[_] = &[0, 1, 2, 3, 4, 5, 6, 7];\n         assert_eq!(writer.get_ref(), b);\n \n         writer.seek(0, io::SeekSet).unwrap();\n         assert_eq!(writer.tell(), Ok(0));\n-        writer.write([3, 4]).unwrap();\n+        writer.write(&[3, 4]).unwrap();\n         let b: &[_] = &[3, 4, 2, 3, 4, 5, 6, 7];\n         assert_eq!(writer.get_ref(), b);\n \n         writer.seek(1, io::SeekCur).unwrap();\n-        writer.write([0, 1]).unwrap();\n+        writer.write(&[0, 1]).unwrap();\n         let b: &[_] = &[3, 4, 2, 0, 1, 5, 6, 7];\n         assert_eq!(writer.get_ref(), b);\n \n         writer.seek(-1, io::SeekEnd).unwrap();\n-        writer.write([1, 2]).unwrap();\n+        writer.write(&[1, 2]).unwrap();\n         let b: &[_] = &[3, 4, 2, 0, 1, 5, 6, 1, 2];\n         assert_eq!(writer.get_ref(), b);\n \n         writer.seek(1, io::SeekEnd).unwrap();\n-        writer.write([1]).unwrap();\n+        writer.write(&[1]).unwrap();\n         let b: &[_] = &[3, 4, 2, 0, 1, 5, 6, 1, 2, 0, 1];\n         assert_eq!(writer.get_ref(), b);\n     }\n@@ -172,7 +172,7 @@ mod tests {\n     fn seek_past_end() {\n         let mut r = SeekableMemWriter::new();\n         r.seek(10, io::SeekSet).unwrap();\n-        assert!(r.write([3]).is_ok());\n+        assert!(r.write(&[3]).is_ok());\n     }\n \n     #[test]"}, {"sha": "5658fde12044e7962fe547bab2ef3ec42ff7aa6d", "filename": "src/librbml/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibrbml%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibrbml%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrbml%2Flib.rs?ref=0047dbe59c41b951d34ce6324f3a8c0e15d523e9", "patch": "@@ -599,7 +599,7 @@ pub mod reader {\n                           f: |&mut Decoder<'doc>, bool| -> DecodeResult<T>) -> DecodeResult<T> {\n             debug!(\"read_option()\");\n             self.read_enum(\"Option\", |this| {\n-                this.read_enum_variant([\"None\", \"Some\"], |this, idx| {\n+                this.read_enum_variant(&[\"None\", \"Some\"], |this, idx| {\n                     match idx {\n                         0 => f(this, false),\n                         1 => f(this, true),\n@@ -1062,7 +1062,7 @@ mod tests {\n \n     #[test]\n     fn test_vuint_at() {\n-        let data = [\n+        let data = &[\n             0x80,\n             0xff,\n             0x40, 0x00,"}, {"sha": "97ab3209d28f8e577ffd62d01ab5820406d8c06f", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=0047dbe59c41b951d34ce6324f3a8c0e15d523e9", "patch": "@@ -879,7 +879,7 @@ fn link_args(cmd: &mut Command,\n             v.push_all(morestack.as_vec());\n             cmd.arg(v.as_slice());\n         } else {\n-            cmd.args([\"-Wl,--whole-archive\", \"-lmorestack\", \"-Wl,--no-whole-archive\"]);\n+            cmd.args(&[\"-Wl,--whole-archive\", \"-lmorestack\", \"-Wl,--no-whole-archive\"]);\n         }\n     }\n \n@@ -997,7 +997,7 @@ fn link_args(cmd: &mut Command,\n     if dylib {\n         // On mac we need to tell the linker to let this library be rpathed\n         if sess.target.target.options.is_like_osx {\n-            cmd.args([\"-dynamiclib\", \"-Wl,-dylib\"]);\n+            cmd.args(&[\"-dynamiclib\", \"-Wl,-dylib\"]);\n \n             if sess.opts.cg.rpath {\n                 let mut v = \"-Wl,-install_name,@rpath/\".as_bytes().to_vec();"}, {"sha": "e42d17c119f8ab593f8be7e7024e87634e5f21c7", "filename": "src/librustc/driver/config.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibrustc%2Fdriver%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibrustc%2Fdriver%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fconfig.rs?ref=0047dbe59c41b951d34ce6324f3a8c0e15d523e9", "patch": "@@ -886,11 +886,11 @@ mod test {\n     #[test]\n     fn test_switch_implies_cfg_test() {\n         let matches =\n-            &match getopts([\"--test\".to_string()], optgroups().as_slice()) {\n+            &match getopts(&[\"--test\".to_string()], optgroups().as_slice()) {\n               Ok(m) => m,\n               Err(f) => panic!(\"test_switch_implies_cfg_test: {}\", f)\n             };\n-        let registry = diagnostics::registry::Registry::new([]);\n+        let registry = diagnostics::registry::Registry::new(&[]);\n         let sessopts = build_session_options(matches);\n         let sess = build_session(sessopts, None, registry);\n         let cfg = build_configuration(&sess);\n@@ -902,14 +902,14 @@ mod test {\n     #[test]\n     fn test_switch_implies_cfg_test_unless_cfg_test() {\n         let matches =\n-            &match getopts([\"--test\".to_string(), \"--cfg=test\".to_string()],\n+            &match getopts(&[\"--test\".to_string(), \"--cfg=test\".to_string()],\n                            optgroups().as_slice()) {\n               Ok(m) => m,\n               Err(f) => {\n                 panic!(\"test_switch_implies_cfg_test_unless_cfg_test: {}\", f)\n               }\n             };\n-        let registry = diagnostics::registry::Registry::new([]);\n+        let registry = diagnostics::registry::Registry::new(&[]);\n         let sessopts = build_session_options(matches);\n         let sess = build_session(sessopts, None, registry);\n         let cfg = build_configuration(&sess);"}, {"sha": "79a65ac5795424b16c9094fb63efc74c6a4b4975", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=0047dbe59c41b951d34ce6324f3a8c0e15d523e9", "patch": "@@ -543,7 +543,7 @@ pub fn phase_5_run_llvm_passes(sess: &Session,\n         let output_type = write::OutputTypeAssembly;\n \n         time(sess.time_passes(), \"LLVM passes\", (), |_|\n-            write::run_passes(sess, trans, [output_type], outputs));\n+            write::run_passes(sess, trans, &[output_type], outputs));\n \n         write::run_assembler(sess, outputs);\n "}, {"sha": "2087434ccd92769adc773bf792c235fe106a6aff", "filename": "src/librustc/driver/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibrustc%2Fdriver%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibrustc%2Fdriver%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fmod.rs?ref=0047dbe59c41b951d34ce6324f3a8c0e15d523e9", "patch": "@@ -48,7 +48,7 @@ fn run_compiler(args: &[String]) {\n         None => return\n     };\n \n-    let descriptions = diagnostics::registry::Registry::new(super::DIAGNOSTICS);\n+    let descriptions = diagnostics::registry::Registry::new(&super::DIAGNOSTICS);\n     match matches.opt_str(\"explain\") {\n         Some(ref code) => {\n             match descriptions.find_description(code.as_slice()) {"}, {"sha": "6ef970b9986bbd639c73f6dee669eb373c1a5d1b", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=0047dbe59c41b951d34ce6324f3a8c0e15d523e9", "patch": "@@ -345,7 +345,7 @@ fn parse_str(st: &mut PState, term: char) -> String {\n     let mut result = String::new();\n     while peek(st) != term {\n         unsafe {\n-            result.as_mut_vec().push_all([next_byte(st)])\n+            result.as_mut_vec().push_all(&[next_byte(st)])\n         }\n     }\n     next(st);"}, {"sha": "926197ad7d27c612659cbc1e6f7c066a5458d222", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=0047dbe59c41b951d34ce6324f3a8c0e15d523e9", "patch": "@@ -748,10 +748,10 @@ impl<'a> vtable_decoder_helpers for reader::Decoder<'a> {\n                           tcx: &ty::ctxt, cdata: &cstore::crate_metadata)\n         -> typeck::vtable_origin {\n         self.read_enum(\"vtable_origin\", |this| {\n-            this.read_enum_variant([\"vtable_static\",\n-                                    \"vtable_param\",\n-                                    \"vtable_error\",\n-                                    \"vtable_unboxed_closure\"],\n+            this.read_enum_variant(&[\"vtable_static\",\n+                                     \"vtable_param\",\n+                                     \"vtable_error\",\n+                                     \"vtable_unboxed_closure\"],\n                                    |this, i| {\n                 Ok(match i {\n                   0 => {\n@@ -1401,8 +1401,8 @@ impl<'a> rbml_decoder_decoder_helpers for reader::Decoder<'a> {\n                           -> typeck::MethodOrigin\n     {\n         self.read_enum(\"MethodOrigin\", |this| {\n-            let variants = [\"MethodStatic\", \"MethodStaticUnboxedClosure\",\n-                            \"MethodTypeParam\", \"MethodTraitObject\"];\n+            let variants = &[\"MethodStatic\", \"MethodStaticUnboxedClosure\",\n+                             \"MethodTypeParam\", \"MethodTraitObject\"];\n             this.read_enum_variant(variants, |this, i| {\n                 Ok(match i {\n                     0 => {\n@@ -1576,7 +1576,7 @@ impl<'a> rbml_decoder_decoder_helpers for reader::Decoder<'a> {\n     fn read_auto_adjustment(&mut self, dcx: &DecodeContext) -> ty::AutoAdjustment {\n         self.read_enum(\"AutoAdjustment\", |this| {\n             let variants = [\"AutoAddEnv\", \"AutoDerefRef\"];\n-            this.read_enum_variant(variants, |this, i| {\n+            this.read_enum_variant(&variants, |this, i| {\n                 Ok(match i {\n                     0 => {\n                         let store: ty::TraitStore =\n@@ -1622,7 +1622,7 @@ impl<'a> rbml_decoder_decoder_helpers for reader::Decoder<'a> {\n                             \"AutoUnsize\",\n                             \"AutoUnsizeUniq\",\n                             \"AutoUnsafe\"];\n-            this.read_enum_variant(variants, |this, i| {\n+            this.read_enum_variant(&variants, |this, i| {\n                 Ok(match i {\n                     0 => {\n                         let r: ty::Region =\n@@ -1676,7 +1676,7 @@ impl<'a> rbml_decoder_decoder_helpers for reader::Decoder<'a> {\n \n     fn read_unsize_kind(&mut self, dcx: &DecodeContext) -> ty::UnsizeKind {\n         self.read_enum(\"UnsizeKind\", |this| {\n-            let variants = [\"UnsizeLength\", \"UnsizeStruct\", \"UnsizeVtable\"];\n+            let variants = &[\"UnsizeLength\", \"UnsizeStruct\", \"UnsizeVtable\"];\n             this.read_enum_variant(variants, |this, i| {\n                 Ok(match i {\n                     0 => {\n@@ -1726,7 +1726,7 @@ impl<'a> rbml_decoder_decoder_helpers for reader::Decoder<'a> {\n                 dcx.tcx,\n                 |s, a| this.convert_def_id(dcx, s, a)))\n         }).unwrap();\n-        let variants = [\n+        let variants = &[\n             \"FnUnboxedClosureKind\",\n             \"FnMutUnboxedClosureKind\",\n             \"FnOnceUnboxedClosureKind\""}, {"sha": "e84e70e2cd994c3fb1f2c5fa888be96b89d29914", "filename": "src/librustc/middle/cfg/construct.rs", "status": "modified", "additions": 33, "deletions": 33, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs?ref=0047dbe59c41b951d34ce6324f3a8c0e15d523e9", "patch": "@@ -73,19 +73,19 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n \n         let expr_exit = self.opt_expr(&blk.expr, stmts_exit);\n \n-        self.add_node(blk.id, [expr_exit])\n+        self.add_node(blk.id, &[expr_exit])\n     }\n \n     fn stmt(&mut self, stmt: &ast::Stmt, pred: CFGIndex) -> CFGIndex {\n         match stmt.node {\n             ast::StmtDecl(ref decl, id) => {\n                 let exit = self.decl(&**decl, pred);\n-                self.add_node(id, [exit])\n+                self.add_node(id, &[exit])\n             }\n \n             ast::StmtExpr(ref expr, id) | ast::StmtSemi(ref expr, id) => {\n                 let exit = self.expr(&**expr, pred);\n-                self.add_node(id, [exit])\n+                self.add_node(id, &[exit])\n             }\n \n             ast::StmtMac(..) => {\n@@ -114,33 +114,33 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n             ast::PatLit(..) |\n             ast::PatRange(..) |\n             ast::PatWild(_) => {\n-                self.add_node(pat.id, [pred])\n+                self.add_node(pat.id, &[pred])\n             }\n \n             ast::PatBox(ref subpat) |\n             ast::PatRegion(ref subpat) |\n             ast::PatIdent(_, _, Some(ref subpat)) => {\n                 let subpat_exit = self.pat(&**subpat, pred);\n-                self.add_node(pat.id, [subpat_exit])\n+                self.add_node(pat.id, &[subpat_exit])\n             }\n \n             ast::PatEnum(_, Some(ref subpats)) |\n             ast::PatTup(ref subpats) => {\n                 let pats_exit = self.pats_all(subpats.iter(), pred);\n-                self.add_node(pat.id, [pats_exit])\n+                self.add_node(pat.id, &[pats_exit])\n             }\n \n             ast::PatStruct(_, ref subpats, _) => {\n                 let pats_exit =\n                     self.pats_all(subpats.iter().map(|f| &f.node.pat), pred);\n-                self.add_node(pat.id, [pats_exit])\n+                self.add_node(pat.id, &[pats_exit])\n             }\n \n             ast::PatVec(ref pre, ref vec, ref post) => {\n                 let pre_exit = self.pats_all(pre.iter(), pred);\n                 let vec_exit = self.pats_all(vec.iter(), pre_exit);\n                 let post_exit = self.pats_all(post.iter(), vec_exit);\n-                self.add_node(pat.id, [post_exit])\n+                self.add_node(pat.id, &[post_exit])\n             }\n \n             ast::PatMac(_) => {\n@@ -165,7 +165,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n         if pats.len() == 1 {\n             self.pat(&*pats[0], pred)\n         } else {\n-            let collect = self.add_dummy_node([]);\n+            let collect = self.add_dummy_node(&[]);\n             for pat in pats.iter() {\n                 let pat_exit = self.pat(&**pat, pred);\n                 self.add_contained_edge(pat_exit, collect);\n@@ -178,7 +178,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n         match expr.node {\n             ast::ExprBlock(ref blk) => {\n                 let blk_exit = self.block(&**blk, pred);\n-                self.add_node(expr.id, [blk_exit])\n+                self.add_node(expr.id, &[blk_exit])\n             }\n \n             ast::ExprIf(ref cond, ref then, None) => {\n@@ -198,7 +198,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n                 //\n                 let cond_exit = self.expr(&**cond, pred);                // 1\n                 let then_exit = self.block(&**then, cond_exit);          // 2\n-                self.add_node(expr.id, [cond_exit, then_exit])           // 3,4\n+                self.add_node(expr.id, &[cond_exit, then_exit])          // 3,4\n             }\n \n             ast::ExprIf(ref cond, ref then, Some(ref otherwise)) => {\n@@ -219,7 +219,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n                 let cond_exit = self.expr(&**cond, pred);                // 1\n                 let then_exit = self.block(&**then, cond_exit);          // 2\n                 let else_exit = self.expr(&**otherwise, cond_exit);      // 3\n-                self.add_node(expr.id, [then_exit, else_exit])           // 4, 5\n+                self.add_node(expr.id, &[then_exit, else_exit])          // 4, 5\n             }\n \n             ast::ExprIfLet(..) => {\n@@ -245,9 +245,9 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n                 // may cause additional edges.\n \n                 // Is the condition considered part of the loop?\n-                let loopback = self.add_dummy_node([pred]);              // 1\n-                let cond_exit = self.expr(&**cond, loopback);            // 2\n-                let expr_exit = self.add_node(expr.id, [cond_exit]);     // 3\n+                let loopback = self.add_dummy_node(&[pred]);              // 1\n+                let cond_exit = self.expr(&**cond, loopback);             // 2\n+                let expr_exit = self.add_node(expr.id, &[cond_exit]);     // 3\n                 self.loop_scopes.push(LoopScope {\n                     loop_id: expr.id,\n                     continue_index: loopback,\n@@ -286,10 +286,10 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n                 // Note that `break` and `continue` statements\n                 // may cause additional edges.\n \n-                let head = self.expr(&**head, pred);            // 1\n-                let loopback = self.add_dummy_node([head]);     // 2\n-                let cond = self.add_dummy_node([loopback]);     // 3\n-                let expr_exit = self.add_node(expr.id, [cond]); // 4\n+                let head = self.expr(&**head, pred);             // 1\n+                let loopback = self.add_dummy_node(&[head]);     // 2\n+                let cond = self.add_dummy_node(&[loopback]);     // 3\n+                let expr_exit = self.add_node(expr.id, &[cond]); // 4\n                 self.loop_scopes.push(LoopScope {\n                     loop_id: expr.id,\n                     continue_index: loopback,\n@@ -317,8 +317,8 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n                 // Note that `break` and `loop` statements\n                 // may cause additional edges.\n \n-                let loopback = self.add_dummy_node([pred]);              // 1\n-                let expr_exit = self.add_node(expr.id, []);              // 2\n+                let loopback = self.add_dummy_node(&[pred]);              // 1\n+                let expr_exit = self.add_node(expr.id, &[]);              // 2\n                 self.loop_scopes.push(LoopScope {\n                     loop_id: expr.id,\n                     continue_index: loopback,\n@@ -358,10 +358,10 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n                 //\n                 let discr_exit = self.expr(&**discr, pred);              // 1\n \n-                let expr_exit = self.add_node(expr.id, []);\n+                let expr_exit = self.add_node(expr.id, &[]);\n                 let mut cond_exit = discr_exit;\n                 for arm in arms.iter() {\n-                    cond_exit = self.add_dummy_node([cond_exit]);        // 2\n+                    cond_exit = self.add_dummy_node(&[cond_exit]);        // 2\n                     let pats_exit = self.pats_any(arm.pats.as_slice(),\n                                                   cond_exit);            // 3\n                     let guard_exit = self.opt_expr(&arm.guard,\n@@ -389,30 +389,30 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n                 //\n                 let l_exit = self.expr(&**l, pred);                      // 1\n                 let r_exit = self.expr(&**r, l_exit);                    // 2\n-                self.add_node(expr.id, [l_exit, r_exit])                 // 3,4\n+                self.add_node(expr.id, &[l_exit, r_exit])                 // 3,4\n             }\n \n             ast::ExprRet(ref v) => {\n                 let v_exit = self.opt_expr(v, pred);\n-                let b = self.add_node(expr.id, [v_exit]);\n+                let b = self.add_node(expr.id, &[v_exit]);\n                 self.add_returning_edge(expr, b);\n-                self.add_node(ast::DUMMY_NODE_ID, [])\n+                self.add_node(ast::DUMMY_NODE_ID, &[])\n             }\n \n             ast::ExprBreak(label) => {\n                 let loop_scope = self.find_scope(expr, label);\n-                let b = self.add_node(expr.id, [pred]);\n+                let b = self.add_node(expr.id, &[pred]);\n                 self.add_exiting_edge(expr, b,\n                                       loop_scope, loop_scope.break_index);\n-                self.add_node(ast::DUMMY_NODE_ID, [])\n+                self.add_node(ast::DUMMY_NODE_ID, &[])\n             }\n \n             ast::ExprAgain(label) => {\n                 let loop_scope = self.find_scope(expr, label);\n-                let a = self.add_node(expr.id, [pred]);\n+                let a = self.add_node(expr.id, &[pred]);\n                 self.add_exiting_edge(expr, a,\n                                       loop_scope, loop_scope.continue_index);\n-                self.add_node(ast::DUMMY_NODE_ID, [])\n+                self.add_node(ast::DUMMY_NODE_ID, &[])\n             }\n \n             ast::ExprVec(ref elems) => {\n@@ -492,7 +492,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n                     let &(_, ref expr, _) = a;\n                     &**expr\n                 }), post_inputs);\n-                self.add_node(expr.id, [post_outputs])\n+                self.add_node(expr.id, &[post_outputs])\n             }\n \n             ast::ExprMac(..) |\n@@ -520,7 +520,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n         let func_or_rcvr_exit = self.expr(func_or_rcvr, pred);\n         let ret = self.straightline(call_expr, func_or_rcvr_exit, args);\n         if return_ty == ty::FnDiverging {\n-            self.add_node(ast::DUMMY_NODE_ID, [])\n+            self.add_node(ast::DUMMY_NODE_ID, &[])\n         } else {\n             ret\n         }\n@@ -547,7 +547,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n         //! Handles case of an expression that evaluates `subexprs` in order\n \n         let subexprs_exit = self.exprs(subexprs, pred);\n-        self.add_node(expr.id, [subexprs_exit])\n+        self.add_node(expr.id, &[subexprs_exit])\n     }\n \n     fn add_dummy_node(&mut self, preds: &[CFGIndex]) -> CFGIndex {"}, {"sha": "1feca05e4499d052f8e0bc96e5581380aa818927", "filename": "src/librustc/middle/cfg/graphviz.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibrustc%2Fmiddle%2Fcfg%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibrustc%2Fmiddle%2Fcfg%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcfg%2Fgraphviz.rs?ref=0047dbe59c41b951d34ce6324f3a8c0e15d523e9", "patch": "@@ -40,7 +40,7 @@ fn replace_newline_with_backslash_l(s: String) -> String {\n         let mut last_two: Vec<_> =\n             s.as_slice().chars().rev().take(2).collect();\n         last_two.reverse();\n-        if last_two.as_slice() != ['\\\\', 'l'] {\n+        if last_two.as_slice() != &['\\\\', 'l'] {\n             s.push_str(\"\\\\l\");\n         }\n         s"}, {"sha": "e20a67eeb8b1ea0cbe1a38642b03c90bc78f11c9", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=0047dbe59c41b951d34ce6324f3a8c0e15d523e9", "patch": "@@ -932,7 +932,7 @@ fn check_fn(cx: &mut MatchCheckCtxt,\n \n fn is_refutable<A>(cx: &MatchCheckCtxt, pat: &Pat, refutable: |&Pat| -> A) -> Option<A> {\n     let pats = Matrix(vec!(vec!(pat)));\n-    match is_useful(cx, &pats, [DUMMY_WILD_PAT], ConstructWitness) {\n+    match is_useful(cx, &pats, &[DUMMY_WILD_PAT], ConstructWitness) {\n         UsefulWithWitness(pats) => {\n             assert_eq!(pats.len(), 1);\n             Some(refutable(&*pats[0]))"}, {"sha": "d2a7ec1e186e15e43c1511fe85821fdc948e05f2", "filename": "src/librustc/middle/graph.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibrustc%2Fmiddle%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibrustc%2Fmiddle%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fgraph.rs?ref=0047dbe59c41b951d34ce6324f3a8c0e15d523e9", "patch": "@@ -419,31 +419,31 @@ mod test {\n     fn each_adjacent_from_a() {\n         let graph = create_graph();\n         test_adjacent_edges(&graph, NodeIndex(0), \"A\",\n-                            [],\n-                            [(\"AB\", \"B\")]);\n+                            &[],\n+                            &[(\"AB\", \"B\")]);\n     }\n \n     #[test]\n     fn each_adjacent_from_b() {\n         let graph = create_graph();\n         test_adjacent_edges(&graph, NodeIndex(1), \"B\",\n-                            [(\"FB\", \"F\"), (\"AB\", \"A\"),],\n-                            [(\"BD\", \"D\"), (\"BC\", \"C\"),]);\n+                            &[(\"FB\", \"F\"), (\"AB\", \"A\"),],\n+                            &[(\"BD\", \"D\"), (\"BC\", \"C\"),]);\n     }\n \n     #[test]\n     fn each_adjacent_from_c() {\n         let graph = create_graph();\n         test_adjacent_edges(&graph, NodeIndex(2), \"C\",\n-                            [(\"EC\", \"E\"), (\"BC\", \"B\")],\n-                            []);\n+                            &[(\"EC\", \"E\"), (\"BC\", \"B\")],\n+                            &[]);\n     }\n \n     #[test]\n     fn each_adjacent_from_d() {\n         let graph = create_graph();\n         test_adjacent_edges(&graph, NodeIndex(3), \"D\",\n-                            [(\"BD\", \"B\")],\n-                            [(\"DE\", \"E\")]);\n+                            &[(\"BD\", \"B\")],\n+                            &[(\"DE\", \"E\")]);\n     }\n }"}, {"sha": "d8043fc2aab41f5e9c9eba426d2f288ff9074553", "filename": "src/librustc/middle/traits/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs?ref=0047dbe59c41b951d34ce6324f3a8c0e15d523e9", "patch": "@@ -57,7 +57,7 @@ pub fn supertraits<'cx, 'tcx>(tcx: &'cx ty::ctxt<'tcx>,\n      * `supertraits(Baz)` yields `[Baz, Bar, Foo, Foo]` in some order.\n      */\n \n-    transitive_bounds(tcx, [trait_ref])\n+    transitive_bounds(tcx, &[trait_ref])\n }\n \n pub fn transitive_bounds<'cx, 'tcx>(tcx: &'cx ty::ctxt<'tcx>,"}, {"sha": "962cbd86c5b27a1c3ab89b6030f7f057dedccee1", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=0047dbe59c41b951d34ce6324f3a8c0e15d523e9", "patch": "@@ -643,8 +643,8 @@ fn bind_subslice_pat(bcx: Block,\n                                 ty::mt {ty: vt.unit_ty, mutbl: ast::MutImmutable});\n     let scratch = rvalue_scratch_datum(bcx, slice_ty, \"\");\n     Store(bcx, slice_begin,\n-          GEPi(bcx, scratch.val, [0u, abi::slice_elt_base]));\n-    Store(bcx, slice_len, GEPi(bcx, scratch.val, [0u, abi::slice_elt_len]));\n+          GEPi(bcx, scratch.val, &[0u, abi::slice_elt_base]));\n+    Store(bcx, slice_len, GEPi(bcx, scratch.val, &[0u, abi::slice_elt_len]));\n     scratch.val\n }\n \n@@ -658,9 +658,9 @@ fn extract_vec_elems<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let vec_datum = match_datum(val, left_ty);\n     let (base, len) = vec_datum.get_vec_base_and_len(bcx);\n     let mut elems = vec![];\n-    elems.extend(range(0, before).map(|i| GEPi(bcx, base, [i])));\n+    elems.extend(range(0, before).map(|i| GEPi(bcx, base, &[i])));\n     elems.extend(range(0, after).rev().map(|i| {\n-        InBoundsGEP(bcx, base, [\n+        InBoundsGEP(bcx, base, &[\n             Sub(bcx, len, C_uint(bcx.ccx(), i + 1))\n         ])\n     }));\n@@ -796,7 +796,7 @@ fn compare_values<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n                            format!(\"comparison of `{}`\",\n                                    cx.ty_to_string(rhs_t)).as_slice(),\n                            StrEqFnLangItem);\n-        callee::trans_lang_call(cx, did, [lhs, rhs], None)\n+        callee::trans_lang_call(cx, did, &[lhs, rhs], None)\n     }\n \n     let _icx = push_ctxt(\"compare_values\");\n@@ -1390,7 +1390,7 @@ fn trans_match_inner<'blk, 'tcx>(scope_cx: Block<'blk, 'tcx>,\n         && arm.pats.last().unwrap().node == ast::PatWild(ast::PatWildSingle)\n     });\n \n-    compile_submatch(bcx, matches.as_slice(), [discr_datum.val], &chk, has_default);\n+    compile_submatch(bcx, matches.as_slice(), &[discr_datum.val], &chk, has_default);\n \n     let mut arm_cxs = Vec::new();\n     for arm_data in arm_datas.iter() {"}, {"sha": "6cad5b5c2e0810d3eb204f7ebce55f4d51fd9a6d", "filename": "src/librustc/middle/trans/adt.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs?ref=0047dbe59c41b951d34ce6324f3a8c0e15d523e9", "patch": "@@ -635,7 +635,7 @@ pub fn trans_get_discr(bcx: Block, r: &Repr, scrutinee: ValueRef, cast_to: Optio\n             signed = ity.is_signed();\n         }\n         General(ity, ref cases, _) => {\n-            let ptr = GEPi(bcx, scrutinee, [0, 0]);\n+            let ptr = GEPi(bcx, scrutinee, &[0, 0]);\n             val = load_discr(bcx, ity, ptr, 0, (cases.len() - 1) as Disr);\n             signed = ity.is_signed();\n         }\n@@ -663,8 +663,8 @@ pub fn trans_get_discr(bcx: Block, r: &Repr, scrutinee: ValueRef, cast_to: Optio\n fn struct_wrapped_nullable_bitdiscr(bcx: Block, nndiscr: Disr, ptrfield: PointerField,\n                                     scrutinee: ValueRef) -> ValueRef {\n     let llptrptr = match ptrfield {\n-        ThinPointer(field) => GEPi(bcx, scrutinee, [0, field]),\n-        FatPointer(field) => GEPi(bcx, scrutinee, [0, field, slice_elt_base])\n+        ThinPointer(field) => GEPi(bcx, scrutinee, &[0, field]),\n+        FatPointer(field) => GEPi(bcx, scrutinee, &[0, field, slice_elt_base])\n     };\n     let llptr = Load(bcx, llptrptr);\n     let cmp = if nndiscr == 0 { IntEQ } else { IntNE };\n@@ -739,13 +739,13 @@ pub fn trans_set_discr(bcx: Block, r: &Repr, val: ValueRef, discr: Disr) {\n                 Store(bcx, C_u8(bcx.ccx(), 1), ptr);\n             }\n             Store(bcx, C_integral(ll_inttype(bcx.ccx(), ity), discr as u64, true),\n-                  GEPi(bcx, val, [0, 0]))\n+                  GEPi(bcx, val, &[0, 0]))\n         }\n         Univariant(ref st, dtor) => {\n             assert_eq!(discr, 0);\n             if dtor {\n                 Store(bcx, C_u8(bcx.ccx(), 1),\n-                    GEPi(bcx, val, [0, st.fields.len() - 1]));\n+                    GEPi(bcx, val, &[0, st.fields.len() - 1]));\n             }\n         }\n         RawNullablePointer { nndiscr, nnty, ..} => {\n@@ -758,10 +758,10 @@ pub fn trans_set_discr(bcx: Block, r: &Repr, val: ValueRef, discr: Disr) {\n             if discr != nndiscr {\n                 let (llptrptr, llptrty) = match ptrfield {\n                     ThinPointer(field) =>\n-                        (GEPi(bcx, val, [0, field]),\n+                        (GEPi(bcx, val, &[0, field]),\n                          type_of::type_of(bcx.ccx(), nonnull.fields[field])),\n                     FatPointer(field) => {\n-                        let v = GEPi(bcx, val, [0, field, slice_elt_base]);\n+                        let v = GEPi(bcx, val, &[0, field, slice_elt_base]);\n                         (v, val_ty(v).element_type())\n                     }\n                 };\n@@ -853,7 +853,7 @@ pub fn struct_field_ptr(bcx: Block, st: &Struct, val: ValueRef,\n         val\n     };\n \n-    GEPi(bcx, val, [0, ix])\n+    GEPi(bcx, val, &[0, ix])\n }\n \n pub fn fold_variants<'blk, 'tcx>(\n@@ -902,7 +902,7 @@ pub fn trans_drop_flag_ptr<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>, r: &Repr, val\n     let ptr_ty = ty::mk_imm_ptr(bcx.tcx(), ty::mk_bool());\n     match *r {\n         Univariant(ref st, true) => {\n-            let flag_ptr = GEPi(bcx, val, [0, st.fields.len() - 1]);\n+            let flag_ptr = GEPi(bcx, val, &[0, st.fields.len() - 1]);\n             datum::immediate_rvalue_bcx(bcx, flag_ptr, ptr_ty).to_expr_datumblock()\n         }\n         General(_, _, true) => {\n@@ -961,7 +961,7 @@ pub fn trans_const(ccx: &CrateContext, r: &Repr, discr: Disr,\n             let mut f = vec![lldiscr];\n             f.push_all(vals);\n             let mut contents = build_const_struct(ccx, case, f.as_slice());\n-            contents.push_all([padding(ccx, max_sz - case.size)]);\n+            contents.push_all(&[padding(ccx, max_sz - case.size)]);\n             C_struct(ccx, contents.as_slice(), false)\n         }\n         Univariant(ref st, _dro) => {\n@@ -1079,8 +1079,8 @@ pub fn const_get_discrim(ccx: &CrateContext, r: &Repr, val: ValueRef)\n         }\n         General(ity, _, _) => {\n             match ity {\n-                attr::SignedInt(..) => const_to_int(const_get_elt(ccx, val, [0])) as Disr,\n-                attr::UnsignedInt(..) => const_to_uint(const_get_elt(ccx, val, [0])) as Disr\n+                attr::SignedInt(..) => const_to_int(const_get_elt(ccx, val, &[0])) as Disr,\n+                attr::UnsignedInt(..) => const_to_uint(const_get_elt(ccx, val, &[0])) as Disr\n             }\n         }\n         Univariant(..) => 0,\n@@ -1138,8 +1138,8 @@ fn const_struct_field(ccx: &CrateContext, val: ValueRef, ix: uint, sub_idx: Opti\n     loop {\n         loop {\n             field = match sub_idx {\n-                Some(si) => const_get_elt(ccx, val, [real_ix, si as u32]),\n-                None => const_get_elt(ccx, val, [real_ix])\n+                Some(si) => const_get_elt(ccx, val, &[real_ix, si as u32]),\n+                None => const_get_elt(ccx, val, &[real_ix])\n             };\n             if !is_undef(field) {\n                 break;"}, {"sha": "b2ec36f03d9b067331dade3a170acc8283ff3243", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=0047dbe59c41b951d34ce6324f3a8c0e15d523e9", "patch": "@@ -337,7 +337,7 @@ pub fn at_box_body(bcx: Block, body_t: ty::t, boxptr: ValueRef) -> ValueRef {\n     let ccx = bcx.ccx();\n     let ty = Type::at_box(ccx, type_of(ccx, body_t));\n     let boxptr = PointerCast(bcx, boxptr, ty.ptr_to());\n-    GEPi(bcx, boxptr, [0u, abi::box_field_body])\n+    GEPi(bcx, boxptr, &[0u, abi::box_field_body])\n }\n \n fn require_alloc_fn(bcx: Block, info_ty: ty::t, it: LangItem) -> ast::DefId {\n@@ -365,7 +365,7 @@ pub fn malloc_raw_dyn<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     // Allocate space:\n     let r = callee::trans_lang_call(bcx,\n         require_alloc_fn(bcx, info_ty, ExchangeMallocFnLangItem),\n-        [size, align],\n+        &[size, align],\n         None);\n \n     Result::new(r.bcx, PointerCast(r.bcx, r.val, llty_ptr))\n@@ -385,7 +385,7 @@ pub fn malloc_raw_dyn_proc<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, t: ty::t) -> Resu\n \n     // Allocate space and store the destructor pointer:\n     let Result {bcx, val: llbox} = malloc_raw_dyn(bcx, ptr_llty, t, size, llalign);\n-    let dtor_ptr = GEPi(bcx, llbox, [0u, abi::box_field_drop_glue]);\n+    let dtor_ptr = GEPi(bcx, llbox, &[0u, abi::box_field_drop_glue]);\n     let drop_glue_field_ty = type_of(ccx, ty::mk_nil_ptr(bcx.tcx()));\n     let drop_glue = PointerCast(bcx, glue::get_drop_glue(ccx, ty::mk_uniq(bcx.tcx(), t)),\n                                 drop_glue_field_ty);\n@@ -517,7 +517,7 @@ pub fn get_res_dtor(ccx: &CrateContext,\n         let class_ty = ty::lookup_item_type(tcx, parent_id).ty.subst(tcx, substs);\n         let llty = type_of_dtor(ccx, class_ty);\n         let dtor_ty = ty::mk_ctor_fn(ccx.tcx(), ast::DUMMY_NODE_ID,\n-                                     [glue::get_drop_glue_type(ccx, t)], ty::mk_nil(ccx.tcx()));\n+                                     &[glue::get_drop_glue_type(ccx, t)], ty::mk_nil(ccx.tcx()));\n         get_extern_fn(ccx,\n                       &mut *ccx.externs().borrow_mut(),\n                       name.as_slice(),\n@@ -694,8 +694,8 @@ pub fn iter_structural_ty<'a, 'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n     let (data_ptr, info) = if ty::type_is_sized(cx.tcx(), t) {\n         (av, None)\n     } else {\n-        let data = GEPi(cx, av, [0, abi::slice_elt_base]);\n-        let info = GEPi(cx, av, [0, abi::slice_elt_len]);\n+        let data = GEPi(cx, av, &[0, abi::slice_elt_base]);\n+        let info = GEPi(cx, av, &[0, abi::slice_elt_len]);\n         (Load(cx, data), Some(Load(cx, info)))\n     };\n \n@@ -713,8 +713,8 @@ pub fn iter_structural_ty<'a, 'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n                   } else {\n                       let boxed_ty = ty::mk_open(cx.tcx(), field_ty);\n                       let scratch = datum::rvalue_scratch_datum(cx, boxed_ty, \"__fat_ptr_iter\");\n-                      Store(cx, llfld_a, GEPi(cx, scratch.val, [0, abi::slice_elt_base]));\n-                      Store(cx, info.unwrap(), GEPi(cx, scratch.val, [0, abi::slice_elt_len]));\n+                      Store(cx, llfld_a, GEPi(cx, scratch.val, &[0, abi::slice_elt_base]));\n+                      Store(cx, info.unwrap(), GEPi(cx, scratch.val, &[0, abi::slice_elt_len]));\n                       scratch.val\n                   };\n                   cx = f(cx, val, field_ty);\n@@ -1110,7 +1110,7 @@ pub fn call_lifetime_start(cx: Block, ptr: ValueRef) {\n     let llsize = C_u64(ccx, machine::llsize_of_alloc(ccx, val_ty(ptr).element_type()));\n     let ptr = PointerCast(cx, ptr, Type::i8p(ccx));\n     let lifetime_start = ccx.get_intrinsic(&\"llvm.lifetime.start\");\n-    Call(cx, lifetime_start, [llsize, ptr], None);\n+    Call(cx, lifetime_start, &[llsize, ptr], None);\n }\n \n pub fn call_lifetime_end(cx: Block, ptr: ValueRef) {\n@@ -1124,7 +1124,7 @@ pub fn call_lifetime_end(cx: Block, ptr: ValueRef) {\n     let llsize = C_u64(ccx, machine::llsize_of_alloc(ccx, val_ty(ptr).element_type()));\n     let ptr = PointerCast(cx, ptr, Type::i8p(ccx));\n     let lifetime_end = ccx.get_intrinsic(&\"llvm.lifetime.end\");\n-    Call(cx, lifetime_end, [llsize, ptr], None);\n+    Call(cx, lifetime_end, &[llsize, ptr], None);\n }\n \n pub fn call_memcpy(cx: Block, dst: ValueRef, src: ValueRef, n_bytes: ValueRef, align: u32) {\n@@ -1141,7 +1141,7 @@ pub fn call_memcpy(cx: Block, dst: ValueRef, src: ValueRef, n_bytes: ValueRef, a\n     let size = IntCast(cx, n_bytes, ccx.int_type());\n     let align = C_i32(ccx, align as i32);\n     let volatile = C_bool(ccx, false);\n-    Call(cx, memcpy, [dst_ptr, src_ptr, size, align, volatile], None);\n+    Call(cx, memcpy, &[dst_ptr, src_ptr, size, align, volatile], None);\n }\n \n pub fn memcpy_ty(bcx: Block, dst: ValueRef, src: ValueRef, t: ty::t) {\n@@ -1187,7 +1187,7 @@ fn memzero(b: &Builder, llptr: ValueRef, ty: ty::t) {\n     let size = machine::llsize_of(ccx, llty);\n     let align = C_i32(ccx, type_of::align_of(ccx, ty) as i32);\n     let volatile = C_bool(ccx, false);\n-    b.call(llintrinsicfn, [llptr, llzeroval, size, align, volatile], None);\n+    b.call(llintrinsicfn, &[llptr, llzeroval, size, align, volatile], None);\n }\n \n pub fn alloc_ty(bcx: Block, t: ty::t, name: &str) -> ValueRef {\n@@ -1563,7 +1563,7 @@ fn create_datums_for_fn_args_under_call_abi(\n                             let llarg =\n                                 get_param(bcx.fcx.llfn,\n                                           bcx.fcx.arg_pos(i + j) as c_uint);\n-                            let lldest = GEPi(bcx, llval, [0, j]);\n+                            let lldest = GEPi(bcx, llval, &[0, j]);\n                             let datum = datum::Datum::new(\n                                 llarg,\n                                 tupled_arg_ty,\n@@ -1654,7 +1654,7 @@ fn copy_unboxed_closure_args_to_allocas<'blk, 'tcx>(\n         let tuple_element_datum =\n             tuple_datum.get_element(bcx,\n                                     tuple_element_type,\n-                                    |llval| GEPi(bcx, llval, [0, j]));\n+                                    |llval| GEPi(bcx, llval, &[0, j]));\n         let tuple_element_datum = tuple_element_datum.to_expr_datum();\n         let tuple_element_datum =\n             unpack_datum!(bcx,\n@@ -2551,7 +2551,7 @@ pub fn create_entry_wrapper(ccx: &CrateContext,\n     fn create_entry_fn(ccx: &CrateContext,\n                        rust_main: ValueRef,\n                        use_start_lang_item: bool) {\n-        let llfty = Type::func([ccx.int_type(), Type::i8p(ccx).ptr_to()],\n+        let llfty = Type::func(&[ccx.int_type(), Type::i8p(ccx).ptr_to()],\n                                &ccx.int_type());\n \n         let llfn = decl_cdecl_fn(ccx, \"main\", llfty, ty::mk_nil(ccx.tcx()));\n@@ -2908,7 +2908,7 @@ pub fn write_metadata(cx: &SharedCrateContext, krate: &ast::Crate) -> Vec<u8> {\n         None => cx.sess().fatal(\"failed to compress metadata\"),\n     }.as_slice());\n     let llmeta = C_bytes_in_context(cx.metadata_llcx(), compressed.as_slice());\n-    let llconst = C_struct_in_context(cx.metadata_llcx(), [llmeta], false);\n+    let llconst = C_struct_in_context(cx.metadata_llcx(), &[llmeta], false);\n     let name = format!(\"rust_metadata_{}_{}\",\n                        cx.link_meta().crate_name,\n                        cx.link_meta().crate_hash);"}, {"sha": "36d156d70e536e16955c234c360059bb41faf403", "filename": "src/librustc/middle/trans/builder.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs?ref=0047dbe59c41b951d34ce6324f3a8c0e15d523e9", "patch": "@@ -776,11 +776,11 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             self.count_insn(\"inlineasm\");\n             let asm = comment_text.as_slice().with_c_str(|c| {\n                 unsafe {\n-                    llvm::LLVMConstInlineAsm(Type::func([], &Type::void(self.ccx)).to_ref(),\n+                    llvm::LLVMConstInlineAsm(Type::func(&[], &Type::void(self.ccx)).to_ref(),\n                                              c, noname(), False, False)\n                 }\n             });\n-            self.call(asm, [], None);\n+            self.call(asm, &[], None);\n         }\n     }\n \n@@ -930,7 +930,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 llvm::LLVMGetNamedFunction(m, buf)\n             });\n             assert!((t as int != 0));\n-            let args: &[ValueRef] = [];\n+            let args: &[ValueRef] = &[];\n             self.count_insn(\"trap\");\n             llvm::LLVMBuildCall(\n                 self.llbuilder, t, args.as_ptr(), args.len() as c_uint, noname());"}, {"sha": "2781a688ca54269bfc8edee2db5268c7431e9d57", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=0047dbe59c41b951d34ce6324f3a8c0e15d523e9", "patch": "@@ -721,9 +721,9 @@ pub fn trans_call_inner<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             // Closures are represented as (llfn, llclosure) pair:\n             // load the requisite values out.\n             let pair = d.to_llref();\n-            let llfn = GEPi(bcx, pair, [0u, abi::fn_field_code]);\n+            let llfn = GEPi(bcx, pair, &[0u, abi::fn_field_code]);\n             let llfn = Load(bcx, llfn);\n-            let llenv = GEPi(bcx, pair, [0u, abi::fn_field_box]);\n+            let llenv = GEPi(bcx, pair, &[0u, abi::fn_field_box]);\n             let llenv = Load(bcx, llenv);\n             (llfn, Some(llenv), None)\n         }"}, {"sha": "fbdefe6ab948a341d656b56c3321e1a6fa73ef7c", "filename": "src/librustc/middle/trans/cleanup.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcleanup.rs?ref=0047dbe59c41b951d34ce6324f3a8c0e15d523e9", "patch": "@@ -785,7 +785,7 @@ impl<'blk, 'tcx> CleanupHelperMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx\n         // this represents but it's determined by the personality function and\n         // this is what the EH proposal example uses.\n         let llretty = Type::struct_(self.ccx,\n-                                    [Type::i8p(self.ccx), Type::i32(self.ccx)],\n+                                    &[Type::i8p(self.ccx), Type::i32(self.ccx)],\n                                     false);\n \n         // The exception handling personality function."}, {"sha": "ab7b1aa33e7694bbadde636be93de3f07b166fb1", "filename": "src/librustc/middle/trans/closure.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs?ref=0047dbe59c41b951d34ce6324f3a8c0e15d523e9", "patch": "@@ -207,7 +207,7 @@ pub fn store_environment<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                      bv.to_string(ccx)).as_slice());\n         }\n \n-        let bound_data = GEPi(bcx, llbox, [0u, abi::box_field_body, i]);\n+        let bound_data = GEPi(bcx, llbox, &[0u, abi::box_field_body, i]);\n \n         match bv.action {\n             ast::CaptureByValue => {\n@@ -275,7 +275,7 @@ fn load_environment<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     // Populate the upvars from the environment\n     let mut i = 0u;\n     for freevar in freevars.iter() {\n-        let mut upvarptr = GEPi(bcx, llcdata, [0u, i]);\n+        let mut upvarptr = GEPi(bcx, llcdata, &[0u, i]);\n         match store {\n             ty::RegionTraitStore(..) => { upvarptr = Load(bcx, upvarptr); }\n             ty::UniqTraitStore => {}\n@@ -329,7 +329,7 @@ fn load_unboxed_closure_environment<'blk, 'tcx>(\n     };\n \n     for (i, freevar) in freevars.iter().enumerate() {\n-        let mut upvar_ptr = GEPi(bcx, llenv, [0, i]);\n+        let mut upvar_ptr = GEPi(bcx, llenv, &[0, i]);\n         if freevar_mode == ast::CaptureByRef {\n             upvar_ptr = Load(bcx, upvar_ptr);\n         }\n@@ -347,9 +347,9 @@ fn load_unboxed_closure_environment<'blk, 'tcx>(\n }\n \n fn fill_fn_pair(bcx: Block, pair: ValueRef, llfn: ValueRef, llenvptr: ValueRef) {\n-    Store(bcx, llfn, GEPi(bcx, pair, [0u, abi::fn_field_code]));\n+    Store(bcx, llfn, GEPi(bcx, pair, &[0u, abi::fn_field_code]));\n     let llenvptr = PointerCast(bcx, llenvptr, Type::i8p(bcx.ccx()));\n-    Store(bcx, llenvptr, GEPi(bcx, pair, [0u, abi::fn_field_box]));\n+    Store(bcx, llenvptr, GEPi(bcx, pair, &[0u, abi::fn_field_box]));\n }\n \n pub fn trans_expr_fn<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n@@ -407,7 +407,7 @@ pub fn trans_expr_fn<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                   llfn,\n                   bcx.fcx.param_substs,\n                   id,\n-                  [],\n+                  &[],\n                   ty::ty_fn_ret(fty),\n                   ty::ty_fn_abi(fty),\n                   true,\n@@ -504,7 +504,7 @@ pub fn trans_unboxed_closure<'blk, 'tcx>(\n                   llfn,\n                   bcx.fcx.param_substs,\n                   id,\n-                  [],\n+                  &[],\n                   ty::ty_fn_ret(function_type),\n                   ty::ty_fn_abi(function_type),\n                   true,"}, {"sha": "7926f09523f781ba8197ec879d3cd85a55175b89", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=0047dbe59c41b951d34ce6324f3a8c0e15d523e9", "patch": "@@ -581,7 +581,7 @@ pub fn C_floating(s: &str, t: Type) -> ValueRef {\n }\n \n pub fn C_nil(ccx: &CrateContext) -> ValueRef {\n-    C_struct(ccx, [], false)\n+    C_struct(ccx, &[], false)\n }\n \n pub fn C_bool(ccx: &CrateContext, val: bool) -> ValueRef {\n@@ -676,7 +676,7 @@ pub fn C_str_slice(cx: &CrateContext, s: InternedString) -> ValueRef {\n         let len = s.get().len();\n         let cs = llvm::LLVMConstPointerCast(C_cstr(cx, s, false),\n                                             Type::i8p(cx).to_ref());\n-        C_named_struct(cx.tn().find_type(\"str_slice\").unwrap(), [cs, C_uint(cx, len)])\n+        C_named_struct(cx.tn().find_type(\"str_slice\").unwrap(), &[cs, C_uint(cx, len)])\n     }\n }\n \n@@ -694,7 +694,7 @@ pub fn C_binary_slice(cx: &CrateContext, data: &[u8]) -> ValueRef {\n         llvm::SetLinkage(g, llvm::InternalLinkage);\n \n         let cs = llvm::LLVMConstPointerCast(g, Type::i8p(cx).to_ref());\n-        C_struct(cx, [cs, C_uint(cx, len)], false)\n+        C_struct(cx, &[cs, C_uint(cx, len)], false)\n     }\n }\n "}, {"sha": "18c9ef98244d95e0c3b0756c4c22380c903b927c", "filename": "src/librustc/middle/trans/consts.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs?ref=0047dbe59c41b951d34ce6324f3a8c0e15d523e9", "patch": "@@ -204,7 +204,7 @@ pub fn const_expr(cx: &CrateContext, e: &ast::Expr) -> (ValueRef, ty::t) {\n                                                                    def,\n                                                                    llconst,\n                                                                    true);\n-                    llconst = C_struct(cx, [wrapper, C_null(Type::i8p(cx))], false)\n+                    llconst = C_struct(cx, &[wrapper, C_null(Type::i8p(cx))], false)\n                 }\n                 ty::AdjustAddEnv(store) => {\n                     cx.sess()\n@@ -264,7 +264,7 @@ pub fn const_expr(cx: &CrateContext, e: &ast::Expr) -> (ValueRef, ty::t) {\n                                             let llptr = const_ptrcast(cx, llconst, llunitty);\n                                             assert_eq!(abi::slice_elt_base, 0);\n                                             assert_eq!(abi::slice_elt_len, 1);\n-                                            llconst = C_struct(cx, [\n+                                            llconst = C_struct(cx, &[\n                                                 llptr,\n                                                 C_uint(cx, len)\n                                             ], false);\n@@ -444,8 +444,8 @@ fn const_expr_unadjusted(cx: &CrateContext, e: &ast::Expr) -> ValueRef {\n                   ty::ty_vec(_, Some(u)) => (bv, C_uint(cx, u)),\n                   ty::ty_open(ty) => match ty::get(ty).sty {\n                       ty::ty_vec(_, None) | ty::ty_str => {\n-                          let e1 = const_get_elt(cx, bv, [0]);\n-                          (const_deref_ptr(cx, e1), const_get_elt(cx, bv, [1]))\n+                          let e1 = const_get_elt(cx, bv, &[0]);\n+                          (const_deref_ptr(cx, e1), const_get_elt(cx, bv, &[1]))\n                       },\n                       _ => cx.sess().span_bug(base.span,\n                                               format!(\"index-expr base must be a vector \\\n@@ -484,7 +484,7 @@ fn const_expr_unadjusted(cx: &CrateContext, e: &ast::Expr) -> ValueRef {\n                   cx.sess().span_err(e.span,\n                                      \"const index-expr is out of bounds\");\n               }\n-              const_get_elt(cx, arr, [iv as c_uint])\n+              const_get_elt(cx, arr, &[iv as c_uint])\n           }\n           ast::ExprCast(ref base, _) => {\n             let ety = ty::expr_ty(cx.tcx(), e);\n@@ -646,7 +646,7 @@ fn const_expr_unadjusted(cx: &CrateContext, e: &ast::Expr) -> ValueRef {\n                     let vinfo = ty::enum_variant_with_id(cx.tcx(),\n                                                          enum_did,\n                                                          variant_did);\n-                    adt::trans_const(cx, &*repr, vinfo.disr_val, [])\n+                    adt::trans_const(cx, &*repr, vinfo.disr_val, &[])\n                 }\n                 Some(def::DefStruct(_)) => {\n                     let ety = ty::expr_ty(cx.tcx(), e);"}, {"sha": "ded41e56a169d94123cd7e3ea24b6f217de9af82", "filename": "src/librustc/middle/trans/context.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs?ref=0047dbe59c41b951d34ce6324f3a8c0e15d523e9", "patch": "@@ -434,7 +434,7 @@ impl LocalCrateContext {\n                 let ccx = local_ccx.dummy_ccx(shared);\n \n                 let mut str_slice_ty = Type::named_struct(&ccx, \"str_slice\");\n-                str_slice_ty.set_struct_body([Type::i8p(&ccx), ccx.int_type()], false);\n+                str_slice_ty.set_struct_body(&[Type::i8p(&ccx), ccx.int_type()], false);\n                 ccx.tn().associate_type(\"str_slice\", &str_slice_ty);\n \n                 ccx.tn().associate_type(\"tydesc\", &Type::tydesc(&ccx, str_slice_ty));\n@@ -719,7 +719,7 @@ fn declare_intrinsic(ccx: &CrateContext, key: & &'static str) -> Option<ValueRef\n         ($name:expr fn() -> $ret:expr) => (\n             if *key == $name {\n                 let f = base::decl_cdecl_fn(\n-                    ccx, $name, Type::func([], &$ret),\n+                    ccx, $name, Type::func(&[], &$ret),\n                     ty::mk_nil(ccx.tcx()));\n                 ccx.intrinsics().borrow_mut().insert($name, f.clone());\n                 return Some(f);\n@@ -728,14 +728,14 @@ fn declare_intrinsic(ccx: &CrateContext, key: & &'static str) -> Option<ValueRef\n         ($name:expr fn($($arg:expr),*) -> $ret:expr) => (\n             if *key == $name {\n                 let f = base::decl_cdecl_fn(ccx, $name,\n-                                  Type::func([$($arg),*], &$ret), ty::mk_nil(ccx.tcx()));\n+                                  Type::func(&[$($arg),*], &$ret), ty::mk_nil(ccx.tcx()));\n                 ccx.intrinsics().borrow_mut().insert($name, f.clone());\n                 return Some(f);\n             }\n         )\n     )\n     macro_rules! mk_struct (\n-        ($($field_ty:expr),*) => (Type::struct_(ccx, [$($field_ty),*], false))\n+        ($($field_ty:expr),*) => (Type::struct_(ccx, &[$($field_ty),*], false))\n     )\n \n     let i8p = Type::i8p(ccx);\n@@ -864,7 +864,7 @@ fn declare_intrinsic(ccx: &CrateContext, key: & &'static str) -> Option<ValueRef\n                 ifn!($name fn($($arg),*) -> $ret);\n             } else if *key == $name {\n                 let f = base::decl_cdecl_fn(ccx, stringify!($cname),\n-                                      Type::func([$($arg),*], &$ret),\n+                                      Type::func(&[$($arg),*], &$ret),\n                                       ty::mk_nil(ccx.tcx()));\n                 ccx.intrinsics().borrow_mut().insert($name, f.clone());\n                 return Some(f);"}, {"sha": "d1908eb62f8efd0e7af053d573f347f4866f8ebc", "filename": "src/librustc/middle/trans/controlflow.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs?ref=0047dbe59c41b951d34ce6324f3a8c0e15d523e9", "patch": "@@ -189,7 +189,7 @@ pub fn trans_if<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             let else_bcx_in = bcx.fcx.new_id_block(\"else-block\", elexpr.id);\n             let else_bcx_out = expr::trans_into(else_bcx_in, &*elexpr, dest);\n             next_bcx = bcx.fcx.join_blocks(if_id,\n-                                           [then_bcx_out, else_bcx_out]);\n+                                           &[then_bcx_out, else_bcx_out]);\n             CondBr(bcx, cond_val, then_bcx_in.llbb, else_bcx_in.llbb);\n         }\n \n@@ -324,7 +324,7 @@ pub fn trans_for<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                                              None,\n                                              arg_cleanup_scope)\n                                      },\n-                                     callee::ArgVals([lliterator]),\n+                                     callee::ArgVals(&[lliterator]),\n                                      Some(expr::SaveIn(lloption)));\n         bcx\n     }));"}, {"sha": "94096d23b3d1f06fdf445eda09efe3760e55edfc", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=0047dbe59c41b951d34ce6324f3a8c0e15d523e9", "patch": "@@ -985,7 +985,7 @@ pub fn create_match_binding_metadata(bcx: Block,\n         },\n         TrByMove => IndirectVariable {\n             alloca: binding.llmatch,\n-            address_operations: aops\n+            address_operations: &aops\n         },\n         TrByRef => DirectVariable {\n             alloca: binding.llmatch\n@@ -1368,7 +1368,7 @@ pub fn create_function_debug_context(cx: &CrateContext,\n                               param_substs: &param_substs,\n                               error_reporting_span: Span) -> DIArray {\n         if cx.sess().opts.debuginfo == LimitedDebugInfo {\n-            return create_DIArray(DIB(cx), []);\n+            return create_DIArray(DIB(cx), &[]);\n         }\n \n         let mut signature = Vec::with_capacity(fn_decl.inputs.len() + 1);\n@@ -1409,7 +1409,7 @@ pub fn create_function_debug_context(cx: &CrateContext,\n         let has_self_type = self_type.is_some();\n \n         if !generics.is_type_parameterized() && !has_self_type {\n-            return create_DIArray(DIB(cx), []);\n+            return create_DIArray(DIB(cx), &[]);\n         }\n \n         name_to_append_suffix_to.push('<');\n@@ -2645,7 +2645,7 @@ fn create_struct_stub(cx: &CrateContext,\n                 // LLVMDIBuilderCreateStructType() wants an empty array. A null\n                 // pointer will lead to hard to trace and debug LLVM assertions\n                 // later on in llvm/lib/IR/Value.cpp.\n-                let empty_array = create_DIArray(DIB(cx), []);\n+                let empty_array = create_DIArray(DIB(cx), &[]);\n \n                 llvm::LLVMDIBuilderCreateStructType(\n                     DIB(cx),\n@@ -2688,7 +2688,7 @@ fn fixed_vec_metadata(cx: &CrateContext,\n             len as i64)\n     };\n \n-    let subscripts = create_DIArray(DIB(cx), [subrange]);\n+    let subscripts = create_DIArray(DIB(cx), &[subrange]);\n     let metadata = unsafe {\n         llvm::LLVMDIBuilderCreateArrayType(\n             DIB(cx),\n@@ -2749,7 +2749,7 @@ fn vec_slice_metadata(cx: &CrateContext,\n                                            slice_llvm_type,\n                                            slice_type_name.as_slice(),\n                                            unique_type_id,\n-                                           member_descriptions,\n+                                           &member_descriptions,\n                                            UNKNOWN_SCOPE_METADATA,\n                                            file_metadata,\n                                            span);\n@@ -2835,7 +2835,7 @@ fn trait_pointer_metadata(cx: &CrateContext,\n                             trait_llvm_type,\n                             trait_type_name.as_slice(),\n                             unique_type_id,\n-                            [],\n+                            &[],\n                             containing_scope,\n                             UNKNOWN_FILE_METADATA,\n                             codemap::DUMMY_SP)"}, {"sha": "86a33a02a679803f9337382a583a34492314e60f", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=0047dbe59c41b951d34ce6324f3a8c0e15d523e9", "patch": "@@ -166,11 +166,11 @@ pub fn trans<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n }\n \n pub fn get_len(bcx: Block, fat_ptr: ValueRef) -> ValueRef {\n-    GEPi(bcx, fat_ptr, [0u, abi::slice_elt_len])\n+    GEPi(bcx, fat_ptr, &[0u, abi::slice_elt_len])\n }\n \n pub fn get_dataptr(bcx: Block, fat_ptr: ValueRef) -> ValueRef {\n-    GEPi(bcx, fat_ptr, [0u, abi::slice_elt_base])\n+    GEPi(bcx, fat_ptr, &[0u, abi::slice_elt_base])\n }\n \n fn apply_adjustments<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n@@ -356,7 +356,7 @@ fn apply_adjustments<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                        val,\n                                        type_of::type_of(bcx.ccx(), unsized_ty).ptr_to()),\n             &ty::UnsizeLength(..) =>\n-                |bcx, val| GEPi(bcx, val, [0u, 0u]),\n+                |bcx, val| GEPi(bcx, val, &[0u, 0u]),\n             &ty::UnsizeVtable(..) =>\n                 |_bcx, val| PointerCast(bcx, val, Type::i8p(bcx.ccx()))\n         };\n@@ -814,15 +814,15 @@ fn trans_index<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             let expect = ccx.get_intrinsic(&(\"llvm.expect.i1\"));\n             let expected = Call(bcx,\n                                 expect,\n-                                [bounds_check, C_bool(ccx, false)],\n+                                &[bounds_check, C_bool(ccx, false)],\n                                 None);\n             bcx = with_cond(bcx, expected, |bcx| {\n                 controlflow::trans_fail_bounds_check(bcx,\n                                                      index_expr.span,\n                                                      ix_val,\n                                                      len)\n             });\n-            let elt = InBoundsGEP(bcx, base, [ix_val]);\n+            let elt = InBoundsGEP(bcx, base, &[ix_val]);\n             let elt = PointerCast(bcx, elt, vt.llunit_ty.ptr_to());\n             Datum::new(elt, vt.unit_ty, LvalueExpr)\n         }\n@@ -1758,8 +1758,8 @@ fn trans_lazy_binop<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     }\n \n     Br(past_rhs, join.llbb);\n-    let phi = Phi(join, Type::i1(bcx.ccx()), [lhs, rhs],\n-                  [past_lhs.llbb, past_rhs.llbb]);\n+    let phi = Phi(join, Type::i1(bcx.ccx()), &[lhs, rhs],\n+                  &[past_lhs.llbb, past_rhs.llbb]);\n \n     return immediate_rvalue_bcx(join, phi, binop_ty).to_expr_datumblock();\n }"}, {"sha": "1afb73b08f7b88d22af5c0954564f4958c4ed1c3", "filename": "src/librustc/middle/trans/foreign.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=0047dbe59c41b951d34ce6324f3a8c0e15d523e9", "patch": "@@ -610,7 +610,7 @@ pub fn trans_rust_fn_with_foreign_abi(ccx: &CrateContext,\n \n         let llfn = base::decl_internal_rust_fn(ccx, t, ps.as_slice());\n         base::set_llvm_fn_attrs(ccx, attrs, llfn);\n-        base::trans_fn(ccx, decl, body, llfn, param_substs, id, []);\n+        base::trans_fn(ccx, decl, body, llfn, param_substs, id, &[]);\n         llfn\n     }\n "}, {"sha": "6c3e3f4364e3f3f37fef99b67608811e119109f3", "filename": "src/librustc/middle/trans/glue.rs", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs?ref=0047dbe59c41b951d34ce6324f3a8c0e15d523e9", "patch": "@@ -51,7 +51,7 @@ pub fn trans_exchange_free_dyn<'blk, 'tcx>(cx: Block<'blk, 'tcx>, v: ValueRef,\n     let ccx = cx.ccx();\n     callee::trans_lang_call(cx,\n         langcall(cx, None, \"\", ExchangeFreeFnLangItem),\n-        [PointerCast(cx, v, Type::i8p(ccx)), size, align],\n+        &[PointerCast(cx, v, Type::i8p(ccx)), size, align],\n         Some(expr::Ignore)).bcx\n }\n \n@@ -124,7 +124,7 @@ pub fn drop_ty<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             None => debuginfo::clear_source_location(bcx.fcx)\n         };\n \n-        Call(bcx, glue, [ptr], None);\n+        Call(bcx, glue, &[ptr], None);\n     }\n     bcx\n }\n@@ -195,7 +195,7 @@ fn trans_struct_drop_flag<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n     let struct_data = if ty::type_is_sized(bcx.tcx(), t) {\n         v0\n     } else {\n-        let llval = GEPi(bcx, v0, [0, abi::slice_elt_base]);\n+        let llval = GEPi(bcx, v0, &[0, abi::slice_elt_base]);\n         Load(bcx, llval)\n     };\n     let drop_flag = unpack_datum!(bcx, adt::trans_drop_flag_ptr(bcx, &*repr, struct_data));\n@@ -236,8 +236,8 @@ fn trans_struct_drop<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let (struct_data, info) = if ty::type_is_sized(bcx.tcx(), t) {\n         (v0, None)\n     } else {\n-        let data = GEPi(bcx, v0, [0, abi::slice_elt_base]);\n-        let info = GEPi(bcx, v0, [0, abi::slice_elt_len]);\n+        let data = GEPi(bcx, v0, &[0, abi::slice_elt_base]);\n+        let info = GEPi(bcx, v0, &[0, abi::slice_elt_len]);\n         (Load(bcx, data), Some(Load(bcx, info)))\n     };\n \n@@ -254,14 +254,14 @@ fn trans_struct_drop<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             // The dtor expects a fat pointer, so make one, even if we have to fake it.\n             let boxed_ty = ty::mk_open(bcx.tcx(), t);\n             let scratch = datum::rvalue_scratch_datum(bcx, boxed_ty, \"__fat_ptr_drop_self\");\n-            Store(bcx, value, GEPi(bcx, scratch.val, [0, abi::slice_elt_base]));\n+            Store(bcx, value, GEPi(bcx, scratch.val, &[0, abi::slice_elt_base]));\n             Store(bcx,\n                   // If we just had a thin pointer, make a fat pointer by sticking\n                   // null where we put the unsizing info. This works because t\n                   // is a sized type, so we will only unpack the fat pointer, never\n                   // use the fake info.\n                   info.unwrap_or(C_null(Type::i8p(bcx.ccx()))),\n-                  GEPi(bcx, scratch.val, [0, abi::slice_elt_len]));\n+                  GEPi(bcx, scratch.val, &[0, abi::slice_elt_len]));\n             PointerCast(variant_cx, scratch.val, params[0])\n         } else {\n             PointerCast(variant_cx, value, params[0])\n@@ -279,16 +279,16 @@ fn trans_struct_drop<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             } else {\n                 let boxed_ty = ty::mk_open(bcx.tcx(), *ty);\n                 let scratch = datum::rvalue_scratch_datum(bcx, boxed_ty, \"__fat_ptr_drop_field\");\n-                Store(bcx, llfld_a, GEPi(bcx, scratch.val, [0, abi::slice_elt_base]));\n-                Store(bcx, info.unwrap(), GEPi(bcx, scratch.val, [0, abi::slice_elt_len]));\n+                Store(bcx, llfld_a, GEPi(bcx, scratch.val, &[0, abi::slice_elt_base]));\n+                Store(bcx, info.unwrap(), GEPi(bcx, scratch.val, &[0, abi::slice_elt_len]));\n                 scratch.val\n             };\n             variant_cx.fcx.schedule_drop_mem(cleanup::CustomScope(field_scope),\n                                              val, *ty);\n         }\n \n         let dtor_ty = ty::mk_ctor_fn(variant_cx.tcx(), ast::DUMMY_NODE_ID,\n-                                     [get_drop_glue_type(bcx.ccx(), t)], ty::mk_nil(bcx.tcx()));\n+                                     &[get_drop_glue_type(bcx.ccx(), t)], ty::mk_nil(bcx.tcx()));\n         let (_, variant_cx) = invoke(variant_cx, dtor_addr, args, dtor_ty, None, false);\n \n         variant_cx.fcx.pop_and_trans_custom_cleanup_scope(variant_cx, field_scope);\n@@ -335,8 +335,8 @@ fn size_and_align_of_dst(bcx: Block, t :ty::t, info: ValueRef) -> (ValueRef, Val\n             // info points to the vtable and the second entry in the vtable is the\n             // dynamic size of the object.\n             let info = PointerCast(bcx, info, Type::int(bcx.ccx()).ptr_to());\n-            let size_ptr = GEPi(bcx, info, [1u]);\n-            let align_ptr = GEPi(bcx, info, [2u]);\n+            let size_ptr = GEPi(bcx, info, &[1u]);\n+            let align_ptr = GEPi(bcx, info, &[2u]);\n             (Load(bcx, size_ptr), Load(bcx, align_ptr))\n         }\n         ty::ty_vec(unit_ty, None) => {\n@@ -366,26 +366,26 @@ fn make_drop_glue<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, v0: ValueRef, t: ty::t)\n                     tvec::make_drop_glue_unboxed(bcx, v0, unit_ty, true)\n                 }\n                 ty::ty_trait(..) => {\n-                    let lluniquevalue = GEPi(bcx, v0, [0, abi::trt_field_box]);\n+                    let lluniquevalue = GEPi(bcx, v0, &[0, abi::trt_field_box]);\n                     // Only drop the value when it is non-null\n                     let concrete_ptr = Load(bcx, lluniquevalue);\n                     with_cond(bcx, IsNotNull(bcx, concrete_ptr), |bcx| {\n-                        let dtor_ptr = Load(bcx, GEPi(bcx, v0, [0, abi::trt_field_vtable]));\n+                        let dtor_ptr = Load(bcx, GEPi(bcx, v0, &[0, abi::trt_field_vtable]));\n                         let dtor = Load(bcx, dtor_ptr);\n                         Call(bcx,\n                              dtor,\n-                             [PointerCast(bcx, lluniquevalue, Type::i8p(bcx.ccx()))],\n+                             &[PointerCast(bcx, lluniquevalue, Type::i8p(bcx.ccx()))],\n                              None);\n                         bcx\n                     })\n                 }\n                 ty::ty_struct(..) if !ty::type_is_sized(bcx.tcx(), content_ty) => {\n-                    let llval = GEPi(bcx, v0, [0, abi::slice_elt_base]);\n+                    let llval = GEPi(bcx, v0, &[0, abi::slice_elt_base]);\n                     let llbox = Load(bcx, llval);\n                     let not_null = IsNotNull(bcx, llbox);\n                     with_cond(bcx, not_null, |bcx| {\n                         let bcx = drop_ty(bcx, v0, content_ty, None);\n-                        let info = GEPi(bcx, v0, [0, abi::slice_elt_len]);\n+                        let info = GEPi(bcx, v0, &[0, abi::slice_elt_len]);\n                         let info = Load(bcx, info);\n                         let (llsize, llalign) = size_and_align_of_dst(bcx, content_ty, info);\n                         trans_exchange_free_dyn(bcx, llbox, llsize, llalign)\n@@ -437,14 +437,14 @@ fn make_drop_glue<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, v0: ValueRef, t: ty::t)\n                                                          t,\n                                                          |bb, vv, tt| drop_ty(bb, vv, tt, None)),\n         ty::ty_closure(ref f) if f.store == ty::UniqTraitStore => {\n-            let box_cell_v = GEPi(bcx, v0, [0u, abi::fn_field_box]);\n+            let box_cell_v = GEPi(bcx, v0, &[0u, abi::fn_field_box]);\n             let env = Load(bcx, box_cell_v);\n             let env_ptr_ty = Type::at_box(bcx.ccx(), Type::i8(bcx.ccx())).ptr_to();\n             let env = PointerCast(bcx, env, env_ptr_ty);\n             with_cond(bcx, IsNotNull(bcx, env), |bcx| {\n-                let dtor_ptr = GEPi(bcx, env, [0u, abi::box_field_drop_glue]);\n+                let dtor_ptr = GEPi(bcx, env, &[0u, abi::box_field_drop_glue]);\n                 let dtor = Load(bcx, dtor_ptr);\n-                Call(bcx, dtor, [PointerCast(bcx, box_cell_v, Type::i8p(bcx.ccx()))], None);\n+                Call(bcx, dtor, &[PointerCast(bcx, box_cell_v, Type::i8p(bcx.ccx()))], None);\n                 bcx\n             })\n         }\n@@ -453,12 +453,12 @@ fn make_drop_glue<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, v0: ValueRef, t: ty::t)\n             // above), because this happens for a trait field in an unsized\n             // struct. If anything is null, it is the whole struct and we won't\n             // get here.\n-            let lluniquevalue = GEPi(bcx, v0, [0, abi::trt_field_box]);\n-            let dtor_ptr = Load(bcx, GEPi(bcx, v0, [0, abi::trt_field_vtable]));\n+            let lluniquevalue = GEPi(bcx, v0, &[0, abi::trt_field_box]);\n+            let dtor_ptr = Load(bcx, GEPi(bcx, v0, &[0, abi::trt_field_vtable]));\n             let dtor = Load(bcx, dtor_ptr);\n             Call(bcx,\n                  dtor,\n-                 [PointerCast(bcx, Load(bcx, lluniquevalue), Type::i8p(bcx.ccx()))],\n+                 &[PointerCast(bcx, Load(bcx, lluniquevalue), Type::i8p(bcx.ccx()))],\n                  None);\n             bcx\n         }\n@@ -578,10 +578,10 @@ pub fn emit_tydescs(ccx: &CrateContext) {\n         ccx.stats().n_real_glues.set(ccx.stats().n_real_glues.get() + 1);\n \n         let tydesc = C_named_struct(ccx.tydesc_type(),\n-                                    [ti.size, // size\n-                                     ti.align, // align\n-                                     drop_glue, // drop_glue\n-                                     ti.name]); // name\n+                                    &[ti.size, // size\n+                                      ti.align, // align\n+                                      drop_glue, // drop_glue\n+                                      ti.name]); // name\n \n         unsafe {\n             let gvar = ti.tydesc;"}, {"sha": "2b54ac68ffa8f15f00c46d9c615810a1eaefb20b", "filename": "src/librustc/middle/trans/inline.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs?ref=0047dbe59c41b951d34ce6324f3a8c0e15d523e9", "patch": "@@ -166,7 +166,7 @@ fn instantiate_inline(ccx: &CrateContext, fn_id: ast::DefId)\n                                  llfn,\n                                  &param_substs::empty(),\n                                  mth.id,\n-                                 []);\n+                                 &[]);\n                         // Use InternalLinkage so LLVM can optimize more\n                         // aggressively.\n                         SetLinkage(llfn, InternalLinkage);"}, {"sha": "13a10258f806f9bd43649f78c66561c06565fb92", "filename": "src/librustc/middle/trans/intrinsic.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs?ref=0047dbe59c41b951d34ce6324f3a8c0e15d523e9", "patch": "@@ -207,7 +207,7 @@ pub fn trans_intrinsic_call<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>, node: ast::N\n     // These are the only intrinsic functions that diverge.\n     if name.get() == \"abort\" {\n         let llfn = ccx.get_intrinsic(&(\"llvm.trap\"));\n-        Call(bcx, llfn, [], None);\n+        Call(bcx, llfn, &[], None);\n         Unreachable(bcx);\n         return Result::new(bcx, C_undef(Type::nil(ccx).ptr_to()));\n     } else if name.get() == \"unreachable\" {\n@@ -242,7 +242,7 @@ pub fn trans_intrinsic_call<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>, node: ast::N\n         }\n         (_, \"breakpoint\") => {\n             let llfn = ccx.get_intrinsic(&(\"llvm.debugtrap\"));\n-            Call(bcx, llfn, [], None)\n+            Call(bcx, llfn, &[], None)\n         }\n         (_, \"size_of\") => {\n             let tp_ty = *substs.types.get(FnSpace, 0);\n@@ -291,7 +291,7 @@ pub fn trans_intrinsic_call<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>, node: ast::N\n                 &ccx.link_meta().crate_hash);\n             // NB: This needs to be kept in lockstep with the TypeId struct in\n             //     the intrinsic module\n-            C_named_struct(llret_ty, [C_u64(ccx, hash)])\n+            C_named_struct(llret_ty, &[C_u64(ccx, hash)])\n         }\n         (_, \"init\") => {\n             let tp_ty = *substs.types.get(FnSpace, 0);\n@@ -317,7 +317,7 @@ pub fn trans_intrinsic_call<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>, node: ast::N\n         (_, \"offset\") => {\n             let ptr = llargs[0];\n             let offset = llargs[1];\n-            InBoundsGEP(bcx, ptr, [offset])\n+            InBoundsGEP(bcx, ptr, &[offset])\n         }\n \n         (_, \"copy_nonoverlapping_memory\") => {\n@@ -578,8 +578,8 @@ fn copy_intrinsic(bcx: Block, allow_overlap: bool, volatile: bool,\n     let src_ptr = PointerCast(bcx, src, Type::i8p(ccx));\n     let llfn = ccx.get_intrinsic(&name);\n \n-    Call(bcx, llfn, [dst_ptr, src_ptr, Mul(bcx, size, count), align,\n-                     C_bool(ccx, volatile)], None)\n+    Call(bcx, llfn, &[dst_ptr, src_ptr, Mul(bcx, size, count), align,\n+                      C_bool(ccx, volatile)], None)\n }\n \n fn memset_intrinsic(bcx: Block, volatile: bool, tp_ty: ty::t,\n@@ -597,22 +597,22 @@ fn memset_intrinsic(bcx: Block, volatile: bool, tp_ty: ty::t,\n     let dst_ptr = PointerCast(bcx, dst, Type::i8p(ccx));\n     let llfn = ccx.get_intrinsic(&name);\n \n-    Call(bcx, llfn, [dst_ptr, val, Mul(bcx, size, count), align,\n-                     C_bool(ccx, volatile)], None)\n+    Call(bcx, llfn, &[dst_ptr, val, Mul(bcx, size, count), align,\n+                      C_bool(ccx, volatile)], None)\n }\n \n fn count_zeros_intrinsic(bcx: Block, name: &'static str, val: ValueRef) -> ValueRef {\n     let y = C_bool(bcx.ccx(), false);\n     let llfn = bcx.ccx().get_intrinsic(&name);\n-    Call(bcx, llfn, [val, y], None)\n+    Call(bcx, llfn, &[val, y], None)\n }\n \n fn with_overflow_intrinsic(bcx: Block, name: &'static str, t: ty::t,\n                            a: ValueRef, b: ValueRef) -> ValueRef {\n     let llfn = bcx.ccx().get_intrinsic(&name);\n \n     // Convert `i1` to a `bool`, and write it to the out parameter\n-    let val = Call(bcx, llfn, [a, b], None);\n+    let val = Call(bcx, llfn, &[a, b], None);\n     let result = ExtractValue(bcx, val, 0);\n     let overflow = ZExt(bcx, ExtractValue(bcx, val, 1), Type::bool(bcx.ccx()));\n     let ret = C_undef(type_of::type_of(bcx.ccx(), t));"}, {"sha": "3cd16d3b0183f1f1d59ed941a4157729714b6437", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=0047dbe59c41b951d34ce6324f3a8c0e15d523e9", "patch": "@@ -89,7 +89,7 @@ pub fn trans_impl(ccx: &CrateContext,\n                                  llfn,\n                                  &param_substs::empty(),\n                                  method.id,\n-                                 []);\n+                                 &[]);\n                         update_linkage(ccx,\n                                        llfn,\n                                        Some(method.id),\n@@ -479,7 +479,7 @@ pub fn trans_trait_callee_from_llval<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n     // Load the data pointer from the object.\n     debug!(\"(translating trait callee) loading second index from pair\");\n-    let llboxptr = GEPi(bcx, llpair, [0u, abi::trt_field_box]);\n+    let llboxptr = GEPi(bcx, llpair, &[0u, abi::trt_field_box]);\n     let llbox = Load(bcx, llboxptr);\n     let llself = PointerCast(bcx, llbox, Type::i8p(ccx));\n \n@@ -501,9 +501,9 @@ pub fn trans_trait_callee_from_llval<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let llvtable = Load(bcx,\n                         PointerCast(bcx,\n                                     GEPi(bcx, llpair,\n-                                         [0u, abi::trt_field_vtable]),\n+                                         &[0u, abi::trt_field_vtable]),\n                                     Type::vtable(ccx).ptr_to().ptr_to()));\n-    let mptr = Load(bcx, GEPi(bcx, llvtable, [0u, n_method + VTABLE_OFFSET]));\n+    let mptr = Load(bcx, GEPi(bcx, llvtable, &[0u, n_method + VTABLE_OFFSET]));\n     let mptr = PointerCast(bcx, mptr, llcallee_ty.ptr_to());\n \n     return Callee {\n@@ -764,13 +764,13 @@ pub fn trans_trait_cast<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let llbox_ty = type_of(bcx.ccx(), datum_ty);\n \n     // Store the pointer into the first half of pair.\n-    let llboxdest = GEPi(bcx, lldest, [0u, abi::trt_field_box]);\n+    let llboxdest = GEPi(bcx, lldest, &[0u, abi::trt_field_box]);\n     let llboxdest = PointerCast(bcx, llboxdest, llbox_ty.ptr_to());\n     bcx = datum.store_to(bcx, llboxdest);\n \n     // Store the vtable into the second half of pair.\n     let vtable = get_vtable(bcx, datum_ty, trait_ref);\n-    let llvtabledest = GEPi(bcx, lldest, [0u, abi::trt_field_vtable]);\n+    let llvtabledest = GEPi(bcx, lldest, &[0u, abi::trt_field_vtable]);\n     let llvtabledest = PointerCast(bcx, llvtabledest, val_ty(vtable).ptr_to());\n     Store(bcx, vtable, llvtabledest);\n "}, {"sha": "1e8d54b249fb2b86df280c10ed7d499b62618b5a", "filename": "src/librustc/middle/trans/monomorphize.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs?ref=0047dbe59c41b951d34ce6324f3a8c0e15d523e9", "patch": "@@ -179,10 +179,10 @@ pub fn monomorphic_fn(ccx: &CrateContext,\n                   if needs_body {\n                       if abi != abi::Rust {\n                           foreign::trans_rust_fn_with_foreign_abi(\n-                              ccx, &**decl, &**body, [], d, &psubsts, fn_id.node,\n+                              ccx, &**decl, &**body, &[], d, &psubsts, fn_id.node,\n                               Some(hash.as_slice()));\n                       } else {\n-                          trans_fn(ccx, &**decl, &**body, d, &psubsts, fn_id.node, []);\n+                          trans_fn(ccx, &**decl, &**body, d, &psubsts, fn_id.node, &[]);\n                       }\n                   }\n \n@@ -226,7 +226,7 @@ pub fn monomorphic_fn(ccx: &CrateContext,\n                                  d,\n                                  &psubsts,\n                                  mth.id,\n-                                 []);\n+                                 &[]);\n                     }\n                     d\n                 }\n@@ -242,7 +242,7 @@ pub fn monomorphic_fn(ccx: &CrateContext,\n                     let needs_body = setup_lldecl(d, mth.attrs.as_slice());\n                     if needs_body {\n                         trans_fn(ccx, mth.pe_fn_decl(), mth.pe_body(), d,\n-                                 &psubsts, mth.id, []);\n+                                 &psubsts, mth.id, &[]);\n                     }\n                     d\n                 }"}, {"sha": "cf1aeca79168e2255de9e7184cc0e90fb3f7a0ab", "filename": "src/librustc/middle/trans/tvec.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs?ref=0047dbe59c41b951d34ce6324f3a8c0e15d523e9", "patch": "@@ -47,7 +47,7 @@ pub fn pointer_add_byte(bcx: Block, ptr: ValueRef, bytes: ValueRef) -> ValueRef\n     let _icx = push_ctxt(\"tvec::pointer_add_byte\");\n     let old_ty = val_ty(ptr);\n     let bptr = PointerCast(bcx, ptr, Type::i8p(bcx.ccx()));\n-    return PointerCast(bcx, InBoundsGEP(bcx, bptr, [bytes]), old_ty);\n+    return PointerCast(bcx, InBoundsGEP(bcx, bptr, &[bytes]), old_ty);\n }\n \n pub fn make_drop_glue_unboxed<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n@@ -128,7 +128,7 @@ pub fn trans_fixed_vstore<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         SaveIn(lldest) => {\n             // lldest will have type *[T x N], but we want the type *T,\n             // so use GEP to convert:\n-            let lldest = GEPi(bcx, lldest, [0, 0]);\n+            let lldest = GEPi(bcx, lldest, &[0, 0]);\n             write_content(bcx, &vt, expr, expr, SaveIn(lldest))\n         }\n     };\n@@ -231,8 +231,8 @@ pub fn trans_lit_str<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 let llbytes = C_uint(bcx.ccx(), bytes);\n                 let llcstr = C_cstr(bcx.ccx(), str_lit, false);\n                 let llcstr = llvm::LLVMConstPointerCast(llcstr, Type::i8p(bcx.ccx()).to_ref());\n-                Store(bcx, llcstr, GEPi(bcx, lldest, [0u, abi::slice_elt_base]));\n-                Store(bcx, llbytes, GEPi(bcx, lldest, [0u, abi::slice_elt_len]));\n+                Store(bcx, llcstr, GEPi(bcx, lldest, &[0u, abi::slice_elt_base]));\n+                Store(bcx, llbytes, GEPi(bcx, lldest, &[0u, abi::slice_elt_len]));\n                 bcx\n             }\n         }\n@@ -290,7 +290,7 @@ pub fn write_content<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 SaveIn(lldest) => {\n                     let temp_scope = fcx.push_custom_cleanup_scope();\n                     for (i, element) in elements.iter().enumerate() {\n-                        let lleltptr = GEPi(bcx, lldest, [i]);\n+                        let lleltptr = GEPi(bcx, lldest, &[i]);\n                         debug!(\"writing index {} with lleltptr={}\",\n                                i, bcx.val_to_string(lleltptr));\n                         bcx = expr::trans_into(bcx, &**element,\n@@ -397,8 +397,8 @@ pub fn get_fixed_base_and_len(bcx: Block,\n fn get_slice_base_and_len(bcx: Block,\n                           llval: ValueRef)\n                           -> (ValueRef, ValueRef) {\n-    let base = Load(bcx, GEPi(bcx, llval, [0u, abi::slice_elt_base]));\n-    let len = Load(bcx, GEPi(bcx, llval, [0u, abi::slice_elt_len]));\n+    let base = Load(bcx, GEPi(bcx, llval, &[0u, abi::slice_elt_base]));\n+    let len = Load(bcx, GEPi(bcx, llval, &[0u, abi::slice_elt_len]));\n     (base, len)\n }\n \n@@ -427,7 +427,7 @@ pub fn get_base_and_len(bcx: Block,\n         ty::ty_uniq(ty) | ty::ty_rptr(_, ty::mt{ty, ..}) => match ty::get(ty).sty {\n             ty::ty_vec(_, None) | ty::ty_str => get_slice_base_and_len(bcx, llval),\n             ty::ty_vec(_, Some(n)) => {\n-                let base = GEPi(bcx, Load(bcx, llval), [0u, 0u]);\n+                let base = GEPi(bcx, Load(bcx, llval), &[0u, 0u]);\n                 (base, C_uint(ccx, n))\n             }\n             _ => ccx.sess().bug(\"unexpected type in get_base_and_len\"),\n@@ -477,7 +477,7 @@ pub fn iter_vec_loop<'a, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         let lleltptr = if vt.llunit_alloc_size == 0 {\n             data_ptr\n         } else {\n-            InBoundsGEP(body_bcx, data_ptr, [i])\n+            InBoundsGEP(body_bcx, data_ptr, &[i])\n         };\n         let body_bcx = f(body_bcx, lleltptr, vt.unit_ty);\n \n@@ -521,15 +521,15 @@ pub fn iter_vec_raw<'a, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         let header_bcx = fcx.new_temp_block(\"iter_vec_loop_header\");\n         Br(bcx, header_bcx.llbb);\n         let data_ptr =\n-            Phi(header_bcx, val_ty(data_ptr), [data_ptr], [bcx.llbb]);\n+            Phi(header_bcx, val_ty(data_ptr), &[data_ptr], &[bcx.llbb]);\n         let not_yet_at_end =\n             ICmp(header_bcx, llvm::IntULT, data_ptr, data_end_ptr);\n         let body_bcx = fcx.new_temp_block(\"iter_vec_loop_body\");\n         let next_bcx = fcx.new_temp_block(\"iter_vec_next\");\n         CondBr(header_bcx, not_yet_at_end, body_bcx.llbb, next_bcx.llbb);\n         let body_bcx = f(body_bcx, data_ptr, vt.unit_ty);\n         AddIncomingToPhi(data_ptr, InBoundsGEP(body_bcx, data_ptr,\n-                                               [C_int(bcx.ccx(), 1i)]),\n+                                               &[C_int(bcx.ccx(), 1i)]),\n                          body_bcx.llbb);\n         Br(body_bcx, header_bcx.llbb);\n         next_bcx"}, {"sha": "d6a2d0c86a11149185fbf138c003cd94b2e807f7", "filename": "src/librustc/middle/trans/type_.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_.rs?ref=0047dbe59c41b951d34ce6324f3a8c0e15d523e9", "patch": "@@ -162,7 +162,7 @@ impl Type {\n     }\n \n     pub fn empty_struct(ccx: &CrateContext) -> Type {\n-        Type::struct_(ccx, [], false)\n+        Type::struct_(ccx, &[], false)\n     }\n \n     pub fn vtable(ccx: &CrateContext) -> Type {\n@@ -182,7 +182,7 @@ impl Type {\n     }\n \n     pub fn glue_fn(ccx: &CrateContext, t: Type) -> Type {\n-        Type::func([t], &Type::void(ccx))\n+        Type::func(&[t], &Type::void(ccx))\n     }\n \n     pub fn tydesc(ccx: &CrateContext, str_slice_ty: Type) -> Type {\n@@ -199,7 +199,7 @@ impl Type {\n                      int_ty,     // align\n                      glue_fn_ty, // drop\n                      str_slice_ty]; // name\n-        tydesc.set_struct_body(elems, false);\n+        tydesc.set_struct_body(&elems, false);\n \n         tydesc\n     }\n@@ -214,7 +214,7 @@ impl Type {\n \n     pub fn vec(ccx: &CrateContext, ty: &Type) -> Type {\n         Type::struct_(ccx,\n-            [Type::array(ty, 0), Type::int(ccx)],\n+            &[Type::array(ty, 0), Type::int(ccx)],\n         false)\n     }\n \n@@ -224,7 +224,7 @@ impl Type {\n \n     // The box pointed to by @T.\n     pub fn at_box(ccx: &CrateContext, ty: Type) -> Type {\n-        Type::struct_(ccx, [\n+        Type::struct_(ccx, &[\n             ccx.int_type(), Type::glue_fn(ccx, Type::i8p(ccx)).ptr_to(),\n             Type::i8p(ccx), Type::i8p(ccx), ty\n         ], false)\n@@ -235,7 +235,7 @@ impl Type {\n     }\n \n     pub fn opaque_trait(ccx: &CrateContext) -> Type {\n-        Type::struct_(ccx, [Type::opaque_trait_data(ccx).ptr_to(), Type::vtable_ptr(ccx)], false)\n+        Type::struct_(ccx, &[Type::opaque_trait_data(ccx).ptr_to(), Type::vtable_ptr(ccx)], false)\n     }\n \n     pub fn opaque_trait_data(ccx: &CrateContext) -> Type {"}, {"sha": "c871dbc8d29a92a0a544db521c34a355bc04ecaf", "filename": "src/librustc/middle/trans/type_of.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs?ref=0047dbe59c41b951d34ce6324f3a8c0e15d523e9", "patch": "@@ -195,12 +195,12 @@ pub fn sizing_type_of(cx: &CrateContext, t: ty::t) -> Type {\n             if ty::type_is_sized(cx.tcx(), ty) {\n                 Type::i8p(cx)\n             } else {\n-                Type::struct_(cx, [Type::i8p(cx), Type::i8p(cx)], false)\n+                Type::struct_(cx, &[Type::i8p(cx), Type::i8p(cx)], false)\n             }\n         }\n \n         ty::ty_bare_fn(..) => Type::i8p(cx),\n-        ty::ty_closure(..) => Type::struct_(cx, [Type::i8p(cx), Type::i8p(cx)], false),\n+        ty::ty_closure(..) => Type::struct_(cx, &[Type::i8p(cx), Type::i8p(cx)], false),\n \n         ty::ty_vec(ty, Some(size)) => {\n             let llty = sizing_type_of(cx, ty);\n@@ -231,7 +231,7 @@ pub fn sizing_type_of(cx: &CrateContext, t: ty::t) -> Type {\n         }\n \n         ty::ty_open(_) => {\n-            Type::struct_(cx, [Type::i8p(cx), Type::i8p(cx)], false)\n+            Type::struct_(cx, &[Type::i8p(cx), Type::i8p(cx)], false)\n         }\n \n         ty::ty_infer(..) | ty::ty_param(..) | ty::ty_err(..) => {\n@@ -337,7 +337,7 @@ pub fn type_of(cx: &CrateContext, t: ty::t) -> Type {\n               ty::ty_trait(..) => Type::opaque_trait(cx),\n               _ if !ty::type_is_sized(cx.tcx(), ty) => {\n                   let p_ty = type_of(cx, ty).ptr_to();\n-                  Type::struct_(cx, [p_ty, type_of_unsize_info(cx, ty)], false)\n+                  Type::struct_(cx, &[p_ty, type_of_unsize_info(cx, ty)], false)\n               }\n               _ => type_of(cx, ty).ptr_to(),\n           }\n@@ -364,7 +364,7 @@ pub fn type_of(cx: &CrateContext, t: ty::t) -> Type {\n       }\n       ty::ty_closure(_) => {\n           let fn_ty = type_of_fn_from_ty(cx, t).ptr_to();\n-          Type::struct_(cx, [fn_ty, Type::i8p(cx)], false)\n+          Type::struct_(cx, &[fn_ty, Type::i8p(cx)], false)\n       }\n       ty::ty_tup(ref tys) if tys.is_empty() => Type::nil(cx),\n       ty::ty_tup(..) => {\n@@ -391,15 +391,15 @@ pub fn type_of(cx: &CrateContext, t: ty::t) -> Type {\n       ty::ty_open(t) => match ty::get(t).sty {\n           ty::ty_struct(..) => {\n               let p_ty = type_of(cx, t).ptr_to();\n-              Type::struct_(cx, [p_ty, type_of_unsize_info(cx, t)], false)\n+              Type::struct_(cx, &[p_ty, type_of_unsize_info(cx, t)], false)\n           }\n           ty::ty_vec(ty, None) => {\n               let p_ty = type_of(cx, ty).ptr_to();\n-              Type::struct_(cx, [p_ty, type_of_unsize_info(cx, t)], false)\n+              Type::struct_(cx, &[p_ty, type_of_unsize_info(cx, t)], false)\n           }\n           ty::ty_str => {\n               let p_ty = Type::i8p(cx);\n-              Type::struct_(cx, [p_ty, type_of_unsize_info(cx, t)], false)\n+              Type::struct_(cx, &[p_ty, type_of_unsize_info(cx, t)], false)\n           }\n           ty::ty_trait(..) => Type::opaque_trait(cx),\n           _ => cx.sess().bug(format!(\"ty_open with sized type: {}\",\n@@ -472,5 +472,5 @@ pub fn llvm_type_name(cx: &CrateContext,\n \n pub fn type_of_dtor(ccx: &CrateContext, self_ty: ty::t) -> Type {\n     let self_ty = type_of(ccx, self_ty).ptr_to();\n-    Type::func([self_ty], &Type::void(ccx))\n+    Type::func(&[self_ty], &Type::void(ccx))\n }"}, {"sha": "f3cc33df0bc8624ccea41a0dfde16f9bad911a5e", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=0047dbe59c41b951d34ce6324f3a8c0e15d523e9", "patch": "@@ -2656,7 +2656,7 @@ pub fn type_contents(cx: &ctxt, ty: t) -> TypeContents {\n                        bounds: ExistentialBounds)\n                        -> TypeContents {\n         // These are the type contents of the (opaque) interior\n-        kind_bounds_to_contents(cx, bounds.builtin_bounds, [])\n+        kind_bounds_to_contents(cx, bounds.builtin_bounds, &[])\n     }\n \n     fn kind_bounds_to_contents(cx: &ctxt,\n@@ -4850,7 +4850,7 @@ pub fn required_region_bounds(tcx: &ctxt,\n \n     all_bounds.push_all(region_bounds);\n \n-    push_region_bounds([],\n+    push_region_bounds(&[],\n                        builtin_bounds,\n                        &mut all_bounds);\n "}, {"sha": "17959e2507a85a4e42abda92c8423915d78279b3", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=0047dbe59c41b951d34ce6324f3a8c0e15d523e9", "patch": "@@ -1442,7 +1442,7 @@ pub fn compute_opt_region_bound(tcx: &ty::ctxt,\n     let derived_region_bounds =\n         ty::required_region_bounds(\n             tcx,\n-            [],\n+            &[],\n             builtin_bounds,\n             trait_bounds);\n "}, {"sha": "750013a47e8723c44467987a403d1d8ab13d80f1", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=0047dbe59c41b951d34ce6324f3a8c0e15d523e9", "patch": "@@ -1064,7 +1064,7 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n \n         // First try to borrow to a slice\n         let entry = self.search_for_some_kind_of_autorefd_method(\n-            |r, m| AutoPtr(r, m, None), autoderefs, [MutImmutable, MutMutable],\n+            |r, m| AutoPtr(r, m, None), autoderefs, &[MutImmutable, MutMutable],\n             |m,r| ty::mk_slice(tcx, r,\n                                ty::mt {ty:ty, mutbl:m}));\n \n@@ -1075,7 +1075,7 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n         // Then try to borrow to a slice *and* borrow a pointer.\n         self.search_for_some_kind_of_autorefd_method(\n             |r, m| AutoPtr(r, ast::MutImmutable, Some( box AutoPtr(r, m, None))),\n-            autoderefs, [MutImmutable, MutMutable],\n+            autoderefs, &[MutImmutable, MutMutable],\n             |m, r| {\n                 let slice_ty = ty::mk_slice(tcx, r,\n                                             ty::mt {ty:ty, mutbl:m});\n@@ -1096,7 +1096,7 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n         // First try to borrow to an unsized vec.\n         let entry = self.search_for_some_kind_of_autorefd_method(\n             |_r, _m| AutoUnsize(ty::UnsizeLength(len)),\n-            autoderefs, [MutImmutable, MutMutable],\n+            autoderefs, &[MutImmutable, MutMutable],\n             |_m, _r| ty::mk_vec(tcx, ty, None));\n \n         if entry.is_some() {\n@@ -1106,7 +1106,7 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n         // Then try to borrow to a slice.\n         let entry = self.search_for_some_kind_of_autorefd_method(\n             |r, m| AutoPtr(r, m, Some(box AutoUnsize(ty::UnsizeLength(len)))),\n-            autoderefs, [MutImmutable, MutMutable],\n+            autoderefs, &[MutImmutable, MutMutable],\n             |m, r|  ty::mk_slice(tcx, r, ty::mt {ty:ty, mutbl:m}));\n \n         if entry.is_some() {\n@@ -1118,7 +1118,7 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n             |r, m| AutoPtr(r, m,\n                            Some(box AutoPtr(r, m,\n                                             Some(box AutoUnsize(ty::UnsizeLength(len)))))),\n-            autoderefs, [MutImmutable, MutMutable],\n+            autoderefs, &[MutImmutable, MutMutable],\n             |m, r| {\n                 let slice_ty = ty::mk_slice(tcx, r, ty::mt {ty:ty, mutbl:m});\n                 ty::mk_rptr(tcx, r, ty::mt {ty:slice_ty, mutbl:MutImmutable})\n@@ -1130,7 +1130,7 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n         debug!(\"auto_slice_str\");\n \n         let entry = self.search_for_some_kind_of_autorefd_method(\n-            |r, m| AutoPtr(r, m, None), autoderefs, [MutImmutable],\n+            |r, m| AutoPtr(r, m, None), autoderefs, &[MutImmutable],\n             |_m, r| ty::mk_str_slice(tcx, r, MutImmutable));\n \n         if entry.is_some() {\n@@ -1139,7 +1139,7 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n \n         self.search_for_some_kind_of_autorefd_method(\n             |r, m| AutoPtr(r, ast::MutImmutable, Some( box AutoPtr(r, m, None))),\n-            autoderefs, [MutImmutable],\n+            autoderefs, &[MutImmutable],\n             |m, r| {\n                 let slice_ty = ty::mk_str_slice(tcx, r, m);\n                 ty::mk_rptr(tcx, r, ty::mt {ty:slice_ty, mutbl:m})\n@@ -1158,7 +1158,7 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n                 let tcx = self.tcx();\n                 self.search_for_some_kind_of_autorefd_method(\n                     |r, m| AutoPtr(r, m, None),\n-                    autoderefs, [MutImmutable, MutMutable],\n+                    autoderefs, &[MutImmutable, MutMutable],\n                     |m, r| {\n                         let principal = ty::TraitRef::new(trt_did,\n                                                           trt_substs.clone());\n@@ -1220,7 +1220,7 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n             ty_unboxed_closure(..) | ty_tup(..) | ty_open(..) |\n             ty_str | ty_vec(..) | ty_trait(..) | ty_closure(..) => {\n                 self.search_for_some_kind_of_autorefd_method(\n-                    |r, m| AutoPtr(r, m, None), autoderefs, [MutImmutable, MutMutable],\n+                    |r, m| AutoPtr(r, m, None), autoderefs, &[MutImmutable, MutMutable],\n                     |m,r| ty::mk_rptr(tcx, r, ty::mt {ty:self_ty, mutbl:m}))\n             }\n "}, {"sha": "64ae16f61d24bb25f52cec63a2ede54793c97e53", "filename": "src/librustc/middle/typeck/check/regionmanip.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs?ref=0047dbe59c41b951d34ce6324f3a8c0e15d523e9", "patch": "@@ -412,9 +412,9 @@ impl<'a, 'tcx> Wf<'a, 'tcx> {\n         // region bounds required from all of the trait types:\n         let required_region_bounds =\n             ty::required_region_bounds(self.tcx,\n-                                       [],\n+                                       &[],\n                                        bounds.builtin_bounds,\n-                                       []);\n+                                       &[]);\n         for &r_d in required_region_bounds.iter() {\n             // Each of these is an instance of the `'c <= 'b`\n             // constraint above"}, {"sha": "09b2be2854508c5a9381f7af4ceb5d4048c97265", "filename": "src/librustc/middle/typeck/coherence/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence%2Fmod.rs?ref=0047dbe59c41b951d34ce6324f3a8c0e15d523e9", "patch": "@@ -152,9 +152,9 @@ impl<'a, 'tcx, 'v> visit::Visitor<'v> for CoherenceCheckVisitor<'a, 'tcx> {\n             ItemImpl(_, ref opt_trait, _, _) => {\n                 match opt_trait.clone() {\n                     Some(opt_trait) => {\n-                        self.cc.check_implementation(item, [opt_trait]);\n+                        self.cc.check_implementation(item, &[opt_trait]);\n                     }\n-                    None => self.cc.check_implementation(item, [])\n+                    None => self.cc.check_implementation(item, &[])\n                 }\n             }\n             _ => {"}, {"sha": "769fdef06253ff475a2609bd84014f66bd871cc0", "filename": "src/librustc/middle/typeck/infer/test.rs", "status": "modified", "additions": 41, "deletions": 41, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ftest.rs?ref=0047dbe59c41b951d34ce6324f3a8c0e15d523e9", "patch": "@@ -376,7 +376,7 @@ impl<'a, 'tcx> Env<'a, 'tcx> {\n \n #[test]\n fn contravariant_region_ptr_ok() {\n-    test_env(\"contravariant_region_ptr\", EMPTY_SOURCE_STR, errors([]), |env| {\n+    test_env(\"contravariant_region_ptr\", EMPTY_SOURCE_STR, errors(&[]), |env| {\n         env.create_simple_region_hierarchy();\n         let t_rptr1 = env.t_rptr_scope(1);\n         let t_rptr10 = env.t_rptr_scope(10);\n@@ -390,7 +390,7 @@ fn contravariant_region_ptr_ok() {\n fn contravariant_region_ptr_err() {\n     test_env(\"contravariant_region_ptr\",\n              EMPTY_SOURCE_STR,\n-             errors([\"lifetime mismatch\"]),\n+             errors(&[\"lifetime mismatch\"]),\n              |env| {\n                  env.create_simple_region_hierarchy();\n                  let t_rptr1 = env.t_rptr_scope(1);\n@@ -405,114 +405,114 @@ fn contravariant_region_ptr_err() {\n \n #[test]\n fn lub_bound_bound() {\n-    test_env(\"contravariant_region_ptr\", EMPTY_SOURCE_STR, errors([]), |env| {\n+    test_env(\"contravariant_region_ptr\", EMPTY_SOURCE_STR, errors(&[]), |env| {\n         let t_rptr_bound1 = env.t_rptr_late_bound(22, 1);\n         let t_rptr_bound2 = env.t_rptr_late_bound(22, 2);\n-        env.check_lub(env.t_fn(22, [t_rptr_bound1], env.t_int()),\n-                      env.t_fn(22, [t_rptr_bound2], env.t_int()),\n-                      env.t_fn(22, [t_rptr_bound1], env.t_int()));\n+        env.check_lub(env.t_fn(22, &[t_rptr_bound1], env.t_int()),\n+                      env.t_fn(22, &[t_rptr_bound2], env.t_int()),\n+                      env.t_fn(22, &[t_rptr_bound1], env.t_int()));\n     })\n }\n \n #[test]\n fn lub_bound_free() {\n-    test_env(\"contravariant_region_ptr\", EMPTY_SOURCE_STR, errors([]), |env| {\n+    test_env(\"contravariant_region_ptr\", EMPTY_SOURCE_STR, errors(&[]), |env| {\n         let t_rptr_bound1 = env.t_rptr_late_bound(22, 1);\n         let t_rptr_free1 = env.t_rptr_free(0, 1);\n-        env.check_lub(env.t_fn(22, [t_rptr_bound1], env.t_int()),\n-                      env.t_fn(22, [t_rptr_free1], env.t_int()),\n-                      env.t_fn(22, [t_rptr_free1], env.t_int()));\n+        env.check_lub(env.t_fn(22, &[t_rptr_bound1], env.t_int()),\n+                      env.t_fn(22, &[t_rptr_free1], env.t_int()),\n+                      env.t_fn(22, &[t_rptr_free1], env.t_int()));\n     })\n }\n \n #[test]\n fn lub_bound_static() {\n-    test_env(\"contravariant_region_ptr\", EMPTY_SOURCE_STR, errors([]), |env| {\n+    test_env(\"contravariant_region_ptr\", EMPTY_SOURCE_STR, errors(&[]), |env| {\n         let t_rptr_bound1 = env.t_rptr_late_bound(22, 1);\n         let t_rptr_static = env.t_rptr_static();\n-        env.check_lub(env.t_fn(22, [t_rptr_bound1], env.t_int()),\n-                      env.t_fn(22, [t_rptr_static], env.t_int()),\n-                      env.t_fn(22, [t_rptr_static], env.t_int()));\n+        env.check_lub(env.t_fn(22, &[t_rptr_bound1], env.t_int()),\n+                      env.t_fn(22, &[t_rptr_static], env.t_int()),\n+                      env.t_fn(22, &[t_rptr_static], env.t_int()));\n     })\n }\n \n #[test]\n fn lub_bound_bound_inverse_order() {\n-    test_env(\"contravariant_region_ptr\", EMPTY_SOURCE_STR, errors([]), |env| {\n+    test_env(\"contravariant_region_ptr\", EMPTY_SOURCE_STR, errors(&[]), |env| {\n         let t_rptr_bound1 = env.t_rptr_late_bound(22, 1);\n         let t_rptr_bound2 = env.t_rptr_late_bound(22, 2);\n-        env.check_lub(env.t_fn(22, [t_rptr_bound1, t_rptr_bound2], t_rptr_bound1),\n-                      env.t_fn(22, [t_rptr_bound2, t_rptr_bound1], t_rptr_bound1),\n-                      env.t_fn(22, [t_rptr_bound1, t_rptr_bound1], t_rptr_bound1));\n+        env.check_lub(env.t_fn(22, &[t_rptr_bound1, t_rptr_bound2], t_rptr_bound1),\n+                      env.t_fn(22, &[t_rptr_bound2, t_rptr_bound1], t_rptr_bound1),\n+                      env.t_fn(22, &[t_rptr_bound1, t_rptr_bound1], t_rptr_bound1));\n     })\n }\n \n #[test]\n fn lub_free_free() {\n-    test_env(\"contravariant_region_ptr\", EMPTY_SOURCE_STR, errors([]), |env| {\n+    test_env(\"contravariant_region_ptr\", EMPTY_SOURCE_STR, errors(&[]), |env| {\n         let t_rptr_free1 = env.t_rptr_free(0, 1);\n         let t_rptr_free2 = env.t_rptr_free(0, 2);\n         let t_rptr_static = env.t_rptr_static();\n-        env.check_lub(env.t_fn(22, [t_rptr_free1], env.t_int()),\n-                      env.t_fn(22, [t_rptr_free2], env.t_int()),\n-                      env.t_fn(22, [t_rptr_static], env.t_int()));\n+        env.check_lub(env.t_fn(22, &[t_rptr_free1], env.t_int()),\n+                      env.t_fn(22, &[t_rptr_free2], env.t_int()),\n+                      env.t_fn(22, &[t_rptr_static], env.t_int()));\n     })\n }\n \n #[test]\n fn lub_returning_scope() {\n     test_env(\"contravariant_region_ptr\", EMPTY_SOURCE_STR,\n-             errors([\"cannot infer an appropriate lifetime\"]), |env| {\n+             errors(&[\"cannot infer an appropriate lifetime\"]), |env| {\n                  let t_rptr_scope10 = env.t_rptr_scope(10);\n                  let t_rptr_scope11 = env.t_rptr_scope(11);\n \n                  // this should generate an error when regions are resolved\n-                 env.make_lub_ty(env.t_fn(22, [], t_rptr_scope10),\n-                                 env.t_fn(22, [], t_rptr_scope11));\n+                 env.make_lub_ty(env.t_fn(22, &[], t_rptr_scope10),\n+                                 env.t_fn(22, &[], t_rptr_scope11));\n              })\n }\n \n #[test]\n fn glb_free_free_with_common_scope() {\n-    test_env(\"contravariant_region_ptr\", EMPTY_SOURCE_STR, errors([]), |env| {\n+    test_env(\"contravariant_region_ptr\", EMPTY_SOURCE_STR, errors(&[]), |env| {\n         let t_rptr_free1 = env.t_rptr_free(0, 1);\n         let t_rptr_free2 = env.t_rptr_free(0, 2);\n         let t_rptr_scope = env.t_rptr_scope(0);\n-        env.check_glb(env.t_fn(22, [t_rptr_free1], env.t_int()),\n-                      env.t_fn(22, [t_rptr_free2], env.t_int()),\n-                      env.t_fn(22, [t_rptr_scope], env.t_int()));\n+        env.check_glb(env.t_fn(22, &[t_rptr_free1], env.t_int()),\n+                      env.t_fn(22, &[t_rptr_free2], env.t_int()),\n+                      env.t_fn(22, &[t_rptr_scope], env.t_int()));\n     })\n }\n \n #[test]\n fn glb_bound_bound() {\n-    test_env(\"contravariant_region_ptr\", EMPTY_SOURCE_STR, errors([]), |env| {\n+    test_env(\"contravariant_region_ptr\", EMPTY_SOURCE_STR, errors(&[]), |env| {\n         let t_rptr_bound1 = env.t_rptr_late_bound(22, 1);\n         let t_rptr_bound2 = env.t_rptr_late_bound(22, 2);\n-        env.check_glb(env.t_fn(22, [t_rptr_bound1], env.t_int()),\n-                      env.t_fn(22, [t_rptr_bound2], env.t_int()),\n-                      env.t_fn(22, [t_rptr_bound1], env.t_int()));\n+        env.check_glb(env.t_fn(22, &[t_rptr_bound1], env.t_int()),\n+                      env.t_fn(22, &[t_rptr_bound2], env.t_int()),\n+                      env.t_fn(22, &[t_rptr_bound1], env.t_int()));\n     })\n }\n \n #[test]\n fn glb_bound_free() {\n-    test_env(\"contravariant_region_ptr\", EMPTY_SOURCE_STR, errors([]), |env| {\n+    test_env(\"contravariant_region_ptr\", EMPTY_SOURCE_STR, errors(&[]), |env| {\n         let t_rptr_bound1 = env.t_rptr_late_bound(22, 1);\n         let t_rptr_free1 = env.t_rptr_free(0, 1);\n-        env.check_glb(env.t_fn(22, [t_rptr_bound1], env.t_int()),\n-                      env.t_fn(22, [t_rptr_free1], env.t_int()),\n-                      env.t_fn(22, [t_rptr_bound1], env.t_int()));\n+        env.check_glb(env.t_fn(22, &[t_rptr_bound1], env.t_int()),\n+                      env.t_fn(22, &[t_rptr_free1], env.t_int()),\n+                      env.t_fn(22, &[t_rptr_bound1], env.t_int()));\n     })\n }\n \n #[test]\n fn glb_bound_static() {\n-    test_env(\"contravariant_region_ptr\", EMPTY_SOURCE_STR, errors([]), |env| {\n+    test_env(\"contravariant_region_ptr\", EMPTY_SOURCE_STR, errors(&[]), |env| {\n         let t_rptr_bound1 = env.t_rptr_late_bound(22, 1);\n         let t_rptr_static = env.t_rptr_static();\n-        env.check_glb(env.t_fn(22, [t_rptr_bound1], env.t_int()),\n-                      env.t_fn(22, [t_rptr_static], env.t_int()),\n-                      env.t_fn(22, [t_rptr_bound1], env.t_int()));\n+        env.check_glb(env.t_fn(22, &[t_rptr_bound1], env.t_int()),\n+                      env.t_fn(22, &[t_rptr_static], env.t_int()),\n+                      env.t_fn(22, &[t_rptr_bound1], env.t_int()));\n     })\n }"}, {"sha": "369cef43622c79ed13d4dd6ff6305e0daca8c49e", "filename": "src/librustc_back/archive.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibrustc_back%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibrustc_back%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Farchive.rs?ref=0047dbe59c41b951d34ce6324f3a8c0e15d523e9", "patch": "@@ -141,12 +141,12 @@ impl<'a> Archive<'a> {\n \n     /// Removes a file from this archive\n     pub fn remove_file(&mut self, file: &str) {\n-        run_ar(self.handler, &self.maybe_ar_prog, \"d\", None, [&self.dst, &Path::new(file)]);\n+        run_ar(self.handler, &self.maybe_ar_prog, \"d\", None, &[&self.dst, &Path::new(file)]);\n     }\n \n     /// Lists all files in an archive\n     pub fn files(&self) -> Vec<String> {\n-        let output = run_ar(self.handler, &self.maybe_ar_prog, \"t\", None, [&self.dst]);\n+        let output = run_ar(self.handler, &self.maybe_ar_prog, \"t\", None, &[&self.dst]);\n         let output = str::from_utf8(output.output.as_slice()).unwrap();\n         // use lines_any because windows delimits output with `\\r\\n` instead of\n         // just `\\n`\n@@ -288,7 +288,7 @@ impl<'a> ArchiveBuilder<'a> {\n         // of filename collisions.\n         let archive = os::make_absolute(archive);\n         run_ar(self.archive.handler, &self.archive.maybe_ar_prog,\n-               \"x\", Some(loc.path()), [&archive]);\n+               \"x\", Some(loc.path()), &[&archive]);\n \n         // Next, we must rename all of the inputs to \"guaranteed unique names\".\n         // We move each file into `self.work_dir` under its new unique name."}, {"sha": "974d8f889c95e7b98af3162885e1d741be5739cf", "filename": "src/librustc_back/rpath.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibrustc_back%2Frpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibrustc_back%2Frpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Frpath.rs?ref=0047dbe59c41b951d34ce6324f3a8c0e15d523e9", "patch": "@@ -140,7 +140,7 @@ mod test {\n \n     #[test]\n     fn test_rpaths_to_flags() {\n-        let flags = rpaths_to_flags([\n+        let flags = rpaths_to_flags(&[\n             \"path1\".to_string(),\n             \"path2\".to_string()\n         ]);\n@@ -151,20 +151,20 @@ mod test {\n \n     #[test]\n     fn test_minimize1() {\n-        let res = minimize_rpaths([\n+        let res = minimize_rpaths(&[\n             \"rpath1\".to_string(),\n             \"rpath2\".to_string(),\n             \"rpath1\".to_string()\n         ]);\n-        assert!(res.as_slice() == [\n+        assert!(res.as_slice() == &[\n             \"rpath1\".to_string(),\n             \"rpath2\".to_string()\n         ]);\n     }\n \n     #[test]\n     fn test_minimize2() {\n-        let res = minimize_rpaths([\n+        let res = minimize_rpaths(&[\n             \"1a\".to_string(),\n             \"2\".to_string(),\n             \"2\".to_string(),\n@@ -176,7 +176,7 @@ mod test {\n             \"4a\".to_string(),\n             \"3\".to_string()\n         ]);\n-        assert!(res.as_slice() == [\n+        assert!(res.as_slice() == &[\n             \"1a\".to_string(),\n             \"2\".to_string(),\n             \"4a\".to_string(),"}, {"sha": "4c08c82ecac5a42cb4ff2d07308bbbbc0996b0a8", "filename": "src/librustc_back/sha2.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibrustc_back%2Fsha2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibrustc_back%2Fsha2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Fsha2.rs?ref=0047dbe59c41b951d34ce6324f3a8c0e15d523e9", "patch": "@@ -139,7 +139,7 @@ impl FixedBuffer for FixedBuffer64 {\n                         self.buffer[mut self.buffer_idx..size],\n                         input[..buffer_remaining]);\n                 self.buffer_idx = 0;\n-                func(self.buffer);\n+                func(&self.buffer);\n                 i += buffer_remaining;\n             } else {\n                 copy_memory(\n@@ -657,7 +657,7 @@ mod bench {\n         let mut sh = Sha256::new();\n         let bytes = [1u8, ..10];\n         b.iter(|| {\n-            sh.input(bytes);\n+            sh.input(&bytes);\n         });\n         b.bytes = bytes.len() as u64;\n     }\n@@ -667,7 +667,7 @@ mod bench {\n         let mut sh = Sha256::new();\n         let bytes = [1u8, ..1024];\n         b.iter(|| {\n-            sh.input(bytes);\n+            sh.input(&bytes);\n         });\n         b.bytes = bytes.len() as u64;\n     }\n@@ -677,7 +677,7 @@ mod bench {\n         let mut sh = Sha256::new();\n         let bytes = [1u8, ..65536];\n         b.iter(|| {\n-            sh.input(bytes);\n+            sh.input(&bytes);\n         });\n         b.bytes = bytes.len() as u64;\n     }"}, {"sha": "bfcd290628248000cb42f44404eccb6d424223be", "filename": "src/librustrt/c_str.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibrustrt%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibrustrt%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Fc_str.rs?ref=0047dbe59c41b951d34ce6324f3a8c0e15d523e9", "patch": "@@ -432,7 +432,7 @@ unsafe fn with_c_str<T>(v: &[u8], checked: bool,\n                         f: |*const libc::c_char| -> T) -> T {\n     let c_str = if v.len() < BUF_LEN {\n         let mut buf: [u8, .. BUF_LEN] = mem::uninitialized();\n-        slice::bytes::copy_memory(buf, v);\n+        slice::bytes::copy_memory(&mut buf, v);\n         buf[v.len()] = 0;\n \n         let buf = buf.as_mut_ptr();\n@@ -554,7 +554,7 @@ mod tests {\n \n     #[test]\n     fn test_vec_to_c_str() {\n-        let b: &[u8] = [];\n+        let b: &[u8] = &[];\n         let c_str = b.to_c_str();\n         unsafe {\n             assert_eq!(*c_str.as_ptr().offset(0), 0);\n@@ -646,7 +646,7 @@ mod tests {\n         let c_str = \"hello\".to_c_str();\n         assert_eq!(c_str.as_bytes_no_nul(), b\"hello\");\n         let c_str = \"\".to_c_str();\n-        let exp: &[u8] = [];\n+        let exp: &[u8] = &[];\n         assert_eq!(c_str.as_bytes_no_nul(), exp);\n         let c_str = b\"foo\\xFF\".to_c_str();\n         assert_eq!(c_str.as_bytes_no_nul(), b\"foo\\xFF\");"}, {"sha": "c77fbd4aee06752c7eed9df49623c6f425b0dd3d", "filename": "src/librustrt/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibrustrt%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibrustrt%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Futil.rs?ref=0047dbe59c41b951d34ce6324f3a8c0e15d523e9", "patch": "@@ -74,7 +74,7 @@ pub fn abort(args: &fmt::Arguments) -> ! {\n \n     // Convert the arguments into a stack-allocated string\n     let mut msg = [0u8, ..512];\n-    let mut w = BufWriter { buf: msg, pos: 0 };\n+    let mut w = BufWriter { buf: &mut msg, pos: 0 };\n     let _ = write!(&mut w, \"{}\", args);\n     let msg = str::from_utf8(w.buf[mut ..w.pos]).unwrap_or(\"aborted\");\n     let msg = if msg.is_empty() {\"aborted\"} else {msg};"}, {"sha": "79778a85fddde0d7335955b0316d70e2fda1478a", "filename": "src/libserialize/json.rs", "status": "modified", "additions": 41, "deletions": 41, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibserialize%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibserialize%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson.rs?ref=0047dbe59c41b951d34ce6324f3a8c0e15d523e9", "patch": "@@ -361,16 +361,16 @@ fn escape_str(writer: &mut io::Writer, v: &str) -> Result<(), io::IoError> {\n \n fn escape_char(writer: &mut io::Writer, v: char) -> Result<(), io::IoError> {\n     let mut buf = [0, .. 4];\n-    v.encode_utf8(buf);\n-    escape_bytes(writer, buf)\n+    v.encode_utf8(&mut buf);\n+    escape_bytes(writer, &mut buf)\n }\n \n fn spaces(wr: &mut io::Writer, mut n: uint) -> Result<(), io::IoError> {\n     const LEN: uint = 16;\n     static BUF: [u8, ..LEN] = [b' ', ..LEN];\n \n     while n >= LEN {\n-        try!(wr.write(BUF));\n+        try!(wr.write(&BUF));\n         n -= LEN;\n     }\n \n@@ -2584,27 +2584,27 @@ mod tests {\n \n     #[test]\n     fn test_write_object() {\n-        assert_eq!(mk_object([]).to_string().into_string(), \"{}\".to_string());\n-        assert_eq!(mk_object([]).to_pretty_str().into_string(), \"{}\".to_string());\n+        assert_eq!(mk_object(&[]).to_string().into_string(), \"{}\".to_string());\n+        assert_eq!(mk_object(&[]).to_pretty_str().into_string(), \"{}\".to_string());\n \n         assert_eq!(\n-            mk_object([\n+            mk_object(&[\n                 (\"a\".to_string(), Boolean(true))\n             ]).to_string().into_string(),\n             \"{\\\"a\\\":true}\".to_string()\n         );\n         assert_eq!(\n-            mk_object([(\"a\".to_string(), Boolean(true))]).to_pretty_str(),\n+            mk_object(&[(\"a\".to_string(), Boolean(true))]).to_pretty_str(),\n             \"\\\n             {\\n  \\\n                 \\\"a\\\": true\\n\\\n             }\".to_string()\n         );\n \n-        let complex_obj = mk_object([\n+        let complex_obj = mk_object(&[\n                 (\"b\".to_string(), List(vec![\n-                    mk_object([(\"c\".to_string(), String(\"\\x0c\\r\".to_string()))]),\n-                    mk_object([(\"d\".to_string(), String(\"\".to_string()))])\n+                    mk_object(&[(\"c\".to_string(), String(\"\\x0c\\r\".to_string()))]),\n+                    mk_object(&[(\"d\".to_string(), String(\"\".to_string()))])\n                 ]))\n             ]);\n \n@@ -2632,11 +2632,11 @@ mod tests {\n             }\".to_string()\n         );\n \n-        let a = mk_object([\n+        let a = mk_object(&[\n             (\"a\".to_string(), Boolean(true)),\n             (\"b\".to_string(), List(vec![\n-                mk_object([(\"c\".to_string(), String(\"\\x0c\\r\".to_string()))]),\n-                mk_object([(\"d\".to_string(), String(\"\".to_string()))])\n+                mk_object(&[(\"c\".to_string(), String(\"\\x0c\\r\".to_string()))]),\n+                mk_object(&[(\"d\".to_string(), String(\"\".to_string()))])\n             ]))\n         ]);\n \n@@ -2941,22 +2941,22 @@ mod tests {\n         assert_eq!(from_str(\"{\\\"a\\\":1 1\"), Err(SyntaxError(InvalidSyntax,         1, 8)));\n         assert_eq!(from_str(\"{\\\"a\\\":1,\"),  Err(SyntaxError(EOFWhileParsingObject, 1, 8)));\n \n-        assert_eq!(from_str(\"{}\").unwrap(), mk_object([]));\n+        assert_eq!(from_str(\"{}\").unwrap(), mk_object(&[]));\n         assert_eq!(from_str(\"{\\\"a\\\": 3}\").unwrap(),\n-                  mk_object([(\"a\".to_string(), U64(3))]));\n+                  mk_object(&[(\"a\".to_string(), U64(3))]));\n \n         assert_eq!(from_str(\n                       \"{ \\\"a\\\": null, \\\"b\\\" : true }\").unwrap(),\n-                  mk_object([\n+                  mk_object(&[\n                       (\"a\".to_string(), Null),\n                       (\"b\".to_string(), Boolean(true))]));\n         assert_eq!(from_str(\"\\n{ \\\"a\\\": null, \\\"b\\\" : true }\\n\").unwrap(),\n-                  mk_object([\n+                  mk_object(&[\n                       (\"a\".to_string(), Null),\n                       (\"b\".to_string(), Boolean(true))]));\n         assert_eq!(from_str(\n                       \"{\\\"a\\\" : 1.0 ,\\\"b\\\": [ true ]}\").unwrap(),\n-                  mk_object([\n+                  mk_object(&[\n                       (\"a\".to_string(), F64(1.0)),\n                       (\"b\".to_string(), List(vec![Boolean(true)]))\n                   ]));\n@@ -2969,13 +2969,13 @@ mod tests {\n                               { \\\"c\\\": {\\\"d\\\": null} } \\\n                           ]\\\n                       }\").unwrap(),\n-                  mk_object([\n+                  mk_object(&[\n                       (\"a\".to_string(), F64(1.0)),\n                       (\"b\".to_string(), List(vec![\n                           Boolean(true),\n                           String(\"foo\\nbar\".to_string()),\n-                          mk_object([\n-                              (\"c\".to_string(), mk_object([(\"d\".to_string(), Null)]))\n+                          mk_object(&[\n+                              (\"c\".to_string(), mk_object(&[(\"d\".to_string(), Null)]))\n                           ])\n                       ]))\n                   ]));\n@@ -3639,34 +3639,34 @@ mod tests {\n         stack.bump_index();\n \n         assert!(stack.len() == 1);\n-        assert!(stack.is_equal_to([Index(1)]));\n-        assert!(stack.starts_with([Index(1)]));\n-        assert!(stack.ends_with([Index(1)]));\n+        assert!(stack.is_equal_to(&[Index(1)]));\n+        assert!(stack.starts_with(&[Index(1)]));\n+        assert!(stack.ends_with(&[Index(1)]));\n         assert!(stack.last_is_index());\n         assert!(stack.get(0) == Index(1));\n \n         stack.push_key(\"foo\".to_string());\n \n         assert!(stack.len() == 2);\n-        assert!(stack.is_equal_to([Index(1), Key(\"foo\")]));\n-        assert!(stack.starts_with([Index(1), Key(\"foo\")]));\n-        assert!(stack.starts_with([Index(1)]));\n-        assert!(stack.ends_with([Index(1), Key(\"foo\")]));\n-        assert!(stack.ends_with([Key(\"foo\")]));\n+        assert!(stack.is_equal_to(&[Index(1), Key(\"foo\")]));\n+        assert!(stack.starts_with(&[Index(1), Key(\"foo\")]));\n+        assert!(stack.starts_with(&[Index(1)]));\n+        assert!(stack.ends_with(&[Index(1), Key(\"foo\")]));\n+        assert!(stack.ends_with(&[Key(\"foo\")]));\n         assert!(!stack.last_is_index());\n         assert!(stack.get(0) == Index(1));\n         assert!(stack.get(1) == Key(\"foo\"));\n \n         stack.push_key(\"bar\".to_string());\n \n         assert!(stack.len() == 3);\n-        assert!(stack.is_equal_to([Index(1), Key(\"foo\"), Key(\"bar\")]));\n-        assert!(stack.starts_with([Index(1)]));\n-        assert!(stack.starts_with([Index(1), Key(\"foo\")]));\n-        assert!(stack.starts_with([Index(1), Key(\"foo\"), Key(\"bar\")]));\n-        assert!(stack.ends_with([Key(\"bar\")]));\n-        assert!(stack.ends_with([Key(\"foo\"), Key(\"bar\")]));\n-        assert!(stack.ends_with([Index(1), Key(\"foo\"), Key(\"bar\")]));\n+        assert!(stack.is_equal_to(&[Index(1), Key(\"foo\"), Key(\"bar\")]));\n+        assert!(stack.starts_with(&[Index(1)]));\n+        assert!(stack.starts_with(&[Index(1), Key(\"foo\")]));\n+        assert!(stack.starts_with(&[Index(1), Key(\"foo\"), Key(\"bar\")]));\n+        assert!(stack.ends_with(&[Key(\"bar\")]));\n+        assert!(stack.ends_with(&[Key(\"foo\"), Key(\"bar\")]));\n+        assert!(stack.ends_with(&[Index(1), Key(\"foo\"), Key(\"bar\")]));\n         assert!(!stack.last_is_index());\n         assert!(stack.get(0) == Index(1));\n         assert!(stack.get(1) == Key(\"foo\"));\n@@ -3675,11 +3675,11 @@ mod tests {\n         stack.pop();\n \n         assert!(stack.len() == 2);\n-        assert!(stack.is_equal_to([Index(1), Key(\"foo\")]));\n-        assert!(stack.starts_with([Index(1), Key(\"foo\")]));\n-        assert!(stack.starts_with([Index(1)]));\n-        assert!(stack.ends_with([Index(1), Key(\"foo\")]));\n-        assert!(stack.ends_with([Key(\"foo\")]));\n+        assert!(stack.is_equal_to(&[Index(1), Key(\"foo\")]));\n+        assert!(stack.starts_with(&[Index(1), Key(\"foo\")]));\n+        assert!(stack.starts_with(&[Index(1)]));\n+        assert!(stack.ends_with(&[Index(1), Key(\"foo\")]));\n+        assert!(stack.ends_with(&[Key(\"foo\")]));\n         assert!(!stack.last_is_index());\n         assert!(stack.get(0) == Index(1));\n         assert!(stack.get(1) == Key(\"foo\"));"}, {"sha": "81dc7c8a3eef272b9ddf7a3f580cb969fbffb048", "filename": "src/libstd/io/buffered.rs", "status": "modified", "additions": 32, "deletions": 32, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibstd%2Fio%2Fbuffered.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibstd%2Fio%2Fbuffered.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fbuffered.rs?ref=0047dbe59c41b951d34ce6324f3a8c0e15d523e9", "patch": "@@ -38,7 +38,7 @@ use vec::Vec;\n /// let mut reader = BufferedReader::new(file);\n ///\n /// let mut buf = [0, ..100];\n-/// match reader.read(buf) {\n+/// match reader.read(&mut buf) {\n ///     Ok(nread) => println!(\"Read {} bytes\", nread),\n ///     Err(e) => println!(\"error reading: {}\", e)\n /// }\n@@ -300,7 +300,7 @@ impl<W: Reader> Reader for InternalBufferedWriter<W> {\n /// stream.flush();\n ///\n /// let mut buf = [0, ..100];\n-/// match stream.read(buf) {\n+/// match stream.read(&mut buf) {\n ///     Ok(nread) => println!(\"Read {} bytes\", nread),\n ///     Err(e) => println!(\"error reading: {}\", e)\n /// }\n@@ -414,72 +414,72 @@ mod test {\n         let mut reader = BufferedReader::with_capacity(2, inner);\n \n         let mut buf = [0, 0, 0];\n-        let nread = reader.read(buf);\n+        let nread = reader.read(&mut buf);\n         assert_eq!(Ok(3), nread);\n         let b: &[_] = &[5, 6, 7];\n         assert_eq!(buf.as_slice(), b);\n \n         let mut buf = [0, 0];\n-        let nread = reader.read(buf);\n+        let nread = reader.read(&mut buf);\n         assert_eq!(Ok(2), nread);\n         let b: &[_] = &[0, 1];\n         assert_eq!(buf.as_slice(), b);\n \n         let mut buf = [0];\n-        let nread = reader.read(buf);\n+        let nread = reader.read(&mut buf);\n         assert_eq!(Ok(1), nread);\n         let b: &[_] = &[2];\n         assert_eq!(buf.as_slice(), b);\n \n         let mut buf = [0, 0, 0];\n-        let nread = reader.read(buf);\n+        let nread = reader.read(&mut buf);\n         assert_eq!(Ok(1), nread);\n         let b: &[_] = &[3, 0, 0];\n         assert_eq!(buf.as_slice(), b);\n \n-        let nread = reader.read(buf);\n+        let nread = reader.read(&mut buf);\n         assert_eq!(Ok(1), nread);\n         let b: &[_] = &[4, 0, 0];\n         assert_eq!(buf.as_slice(), b);\n \n-        assert!(reader.read(buf).is_err());\n+        assert!(reader.read(&mut buf).is_err());\n     }\n \n     #[test]\n     fn test_buffered_writer() {\n         let inner = MemWriter::new();\n         let mut writer = BufferedWriter::with_capacity(2, inner);\n \n-        writer.write([0, 1]).unwrap();\n+        writer.write(&[0, 1]).unwrap();\n         let b: &[_] = &[];\n         assert_eq!(writer.get_ref().get_ref(), b);\n \n-        writer.write([2]).unwrap();\n+        writer.write(&[2]).unwrap();\n         let b: &[_] = &[0, 1];\n         assert_eq!(writer.get_ref().get_ref(), b);\n \n-        writer.write([3]).unwrap();\n+        writer.write(&[3]).unwrap();\n         assert_eq!(writer.get_ref().get_ref(), b);\n \n         writer.flush().unwrap();\n         let a: &[_] = &[0, 1, 2, 3];\n         assert_eq!(a, writer.get_ref().get_ref());\n \n-        writer.write([4]).unwrap();\n-        writer.write([5]).unwrap();\n+        writer.write(&[4]).unwrap();\n+        writer.write(&[5]).unwrap();\n         assert_eq!(a, writer.get_ref().get_ref());\n \n-        writer.write([6]).unwrap();\n+        writer.write(&[6]).unwrap();\n         let a: &[_] = &[0, 1, 2, 3, 4, 5];\n         assert_eq!(a,\n                    writer.get_ref().get_ref());\n \n-        writer.write([7, 8]).unwrap();\n+        writer.write(&[7, 8]).unwrap();\n         let a: &[_] = &[0, 1, 2, 3, 4, 5, 6];\n         assert_eq!(a,\n                    writer.get_ref().get_ref());\n \n-        writer.write([9, 10, 11]).unwrap();\n+        writer.write(&[9, 10, 11]).unwrap();\n         let a: &[_] = &[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11];\n         assert_eq!(a,\n                    writer.get_ref().get_ref());\n@@ -492,7 +492,7 @@ mod test {\n     #[test]\n     fn test_buffered_writer_inner_flushes() {\n         let mut w = BufferedWriter::with_capacity(3, MemWriter::new());\n-        w.write([0, 1]).unwrap();\n+        w.write(&[0, 1]).unwrap();\n         let a: &[_] = &[];\n         assert_eq!(a, w.get_ref().get_ref());\n         let w = w.unwrap();\n@@ -518,8 +518,8 @@ mod test {\n \n         let mut stream = BufferedStream::new(S);\n         let mut buf = [];\n-        assert!(stream.read(buf).is_err());\n-        stream.write(buf).unwrap();\n+        assert!(stream.read(&mut buf).is_err());\n+        stream.write(&buf).unwrap();\n         stream.flush().unwrap();\n     }\n \n@@ -537,21 +537,21 @@ mod test {\n     #[test]\n     fn test_line_buffer() {\n         let mut writer = LineBufferedWriter::new(MemWriter::new());\n-        writer.write([0]).unwrap();\n+        writer.write(&[0]).unwrap();\n         let b: &[_] = &[];\n         assert_eq!(writer.get_ref().get_ref(), b);\n-        writer.write([1]).unwrap();\n+        writer.write(&[1]).unwrap();\n         assert_eq!(writer.get_ref().get_ref(), b);\n         writer.flush().unwrap();\n         let b: &[_] = &[0, 1];\n         assert_eq!(writer.get_ref().get_ref(), b);\n-        writer.write([0, b'\\n', 1, b'\\n', 2]).unwrap();\n+        writer.write(&[0, b'\\n', 1, b'\\n', 2]).unwrap();\n         let b: &[_] = &[0, 1, 0, b'\\n', 1, b'\\n'];\n         assert_eq!(writer.get_ref().get_ref(), b);\n         writer.flush().unwrap();\n         let b: &[_] = &[0, 1, 0, b'\\n', 1, b'\\n', 2];\n         assert_eq!(writer.get_ref().get_ref(), b);\n-        writer.write([3, b'\\n']).unwrap();\n+        writer.write(&[3, b'\\n']).unwrap();\n         let b: &[_] = &[0, 1, 0, b'\\n', 1, b'\\n', 2, 3, b'\\n'];\n         assert_eq!(writer.get_ref().get_ref(), b);\n     }\n@@ -582,26 +582,26 @@ mod test {\n         let inner = ShortReader{lengths: vec![0, 1, 2, 0, 1, 0]};\n         let mut reader = BufferedReader::new(inner);\n         let mut buf = [0, 0];\n-        assert_eq!(reader.read(buf), Ok(0));\n-        assert_eq!(reader.read(buf), Ok(1));\n-        assert_eq!(reader.read(buf), Ok(2));\n-        assert_eq!(reader.read(buf), Ok(0));\n-        assert_eq!(reader.read(buf), Ok(1));\n-        assert_eq!(reader.read(buf), Ok(0));\n-        assert!(reader.read(buf).is_err());\n+        assert_eq!(reader.read(&mut buf), Ok(0));\n+        assert_eq!(reader.read(&mut buf), Ok(1));\n+        assert_eq!(reader.read(&mut buf), Ok(2));\n+        assert_eq!(reader.read(&mut buf), Ok(0));\n+        assert_eq!(reader.read(&mut buf), Ok(1));\n+        assert_eq!(reader.read(&mut buf), Ok(0));\n+        assert!(reader.read(&mut buf).is_err());\n     }\n \n     #[test]\n     fn read_char_buffered() {\n         let buf = [195u8, 159u8];\n-        let mut reader = BufferedReader::with_capacity(1, BufReader::new(buf));\n+        let mut reader = BufferedReader::with_capacity(1, BufReader::new(&buf));\n         assert_eq!(reader.read_char(), Ok('\u00df'));\n     }\n \n     #[test]\n     fn test_chars() {\n         let buf = [195u8, 159u8, b'a'];\n-        let mut reader = BufferedReader::with_capacity(1, BufReader::new(buf));\n+        let mut reader = BufferedReader::with_capacity(1, BufReader::new(&buf));\n         let mut it = reader.chars();\n         assert_eq!(it.next(), Some(Ok('\u00df')));\n         assert_eq!(it.next(), Some(Ok('a')));"}, {"sha": "a90b6bbbb8e8e4188f7b82097a2e39b84fac82f8", "filename": "src/libstd/io/comm_adapters.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibstd%2Fio%2Fcomm_adapters.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibstd%2Fio%2Fcomm_adapters.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fcomm_adapters.rs?ref=0047dbe59c41b951d34ce6324f3a8c0e15d523e9", "patch": "@@ -30,7 +30,7 @@ use vec::Vec;\n /// let mut reader = ChanReader::new(rx);\n ///\n /// let mut buf = [0u8, ..100];\n-/// match reader.read(buf) {\n+/// match reader.read(&mut buf) {\n ///     Ok(nread) => println!(\"Read {} bytes\", nread),\n ///     Err(e) => println!(\"read error: {}\", e),\n /// }\n@@ -172,17 +172,17 @@ mod test {\n         let mut reader = ChanReader::new(rx);\n         let mut buf = [0u8, ..3];\n \n-        assert_eq!(Ok(0), reader.read([]));\n+        assert_eq!(Ok(0), reader.read(&mut []));\n \n-        assert_eq!(Ok(3), reader.read(buf));\n+        assert_eq!(Ok(3), reader.read(&mut buf));\n         let a: &[u8] = &[1,2,3];\n         assert_eq!(a, buf.as_slice());\n \n-        assert_eq!(Ok(3), reader.read(buf));\n+        assert_eq!(Ok(3), reader.read(&mut buf));\n         let a: &[u8] = &[4,5,6];\n         assert_eq!(a, buf.as_slice());\n \n-        assert_eq!(Ok(2), reader.read(buf));\n+        assert_eq!(Ok(2), reader.read(&mut buf));\n         let a: &[u8] = &[7,8,6];\n         assert_eq!(a, buf.as_slice());\n "}, {"sha": "70bf90eef9382ce6d59d5f6c2407d7746a022dec", "filename": "src/libstd/io/extensions.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibstd%2Fio%2Fextensions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibstd%2Fio%2Fextensions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fextensions.rs?ref=0047dbe59c41b951d34ce6324f3a8c0e15d523e9", "patch": "@@ -82,9 +82,9 @@ pub fn u64_to_le_bytes<T>(n: u64, size: uint, f: |v: &[u8]| -> T) -> T {\n     assert!(size <= 8u);\n     match size {\n       1u => f(&[n as u8]),\n-      2u => f(unsafe { transmute::<_, [u8, ..2]>((n as u16).to_le()) }),\n-      4u => f(unsafe { transmute::<_, [u8, ..4]>((n as u32).to_le()) }),\n-      8u => f(unsafe { transmute::<_, [u8, ..8]>(n.to_le()) }),\n+      2u => f(unsafe { & transmute::<_, [u8, ..2]>((n as u16).to_le()) }),\n+      4u => f(unsafe { & transmute::<_, [u8, ..4]>((n as u32).to_le()) }),\n+      8u => f(unsafe { & transmute::<_, [u8, ..8]>(n.to_le()) }),\n       _ => {\n \n         let mut bytes = vec!();\n@@ -121,9 +121,9 @@ pub fn u64_to_be_bytes<T>(n: u64, size: uint, f: |v: &[u8]| -> T) -> T {\n     assert!(size <= 8u);\n     match size {\n       1u => f(&[n as u8]),\n-      2u => f(unsafe { transmute::<_, [u8, ..2]>((n as u16).to_be()) }),\n-      4u => f(unsafe { transmute::<_, [u8, ..4]>((n as u32).to_be()) }),\n-      8u => f(unsafe { transmute::<_, [u8, ..8]>(n.to_be()) }),\n+      2u => f(unsafe { & transmute::<_, [u8, ..2]>((n as u16).to_be()) }),\n+      4u => f(unsafe { & transmute::<_, [u8, ..4]>((n as u32).to_be()) }),\n+      8u => f(unsafe { & transmute::<_, [u8, ..8]>(n.to_be()) }),\n       _ => {\n         let mut bytes = vec!();\n         let mut i = size;\n@@ -474,26 +474,26 @@ mod test {\n         let buf = [0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09];\n \n         // Aligned access\n-        assert_eq!(u64_from_be_bytes(buf, 0, 0), 0);\n-        assert_eq!(u64_from_be_bytes(buf, 0, 1), 0x01);\n-        assert_eq!(u64_from_be_bytes(buf, 0, 2), 0x0102);\n-        assert_eq!(u64_from_be_bytes(buf, 0, 3), 0x010203);\n-        assert_eq!(u64_from_be_bytes(buf, 0, 4), 0x01020304);\n-        assert_eq!(u64_from_be_bytes(buf, 0, 5), 0x0102030405);\n-        assert_eq!(u64_from_be_bytes(buf, 0, 6), 0x010203040506);\n-        assert_eq!(u64_from_be_bytes(buf, 0, 7), 0x01020304050607);\n-        assert_eq!(u64_from_be_bytes(buf, 0, 8), 0x0102030405060708);\n+        assert_eq!(u64_from_be_bytes(&buf, 0, 0), 0);\n+        assert_eq!(u64_from_be_bytes(&buf, 0, 1), 0x01);\n+        assert_eq!(u64_from_be_bytes(&buf, 0, 2), 0x0102);\n+        assert_eq!(u64_from_be_bytes(&buf, 0, 3), 0x010203);\n+        assert_eq!(u64_from_be_bytes(&buf, 0, 4), 0x01020304);\n+        assert_eq!(u64_from_be_bytes(&buf, 0, 5), 0x0102030405);\n+        assert_eq!(u64_from_be_bytes(&buf, 0, 6), 0x010203040506);\n+        assert_eq!(u64_from_be_bytes(&buf, 0, 7), 0x01020304050607);\n+        assert_eq!(u64_from_be_bytes(&buf, 0, 8), 0x0102030405060708);\n \n         // Unaligned access\n-        assert_eq!(u64_from_be_bytes(buf, 1, 0), 0);\n-        assert_eq!(u64_from_be_bytes(buf, 1, 1), 0x02);\n-        assert_eq!(u64_from_be_bytes(buf, 1, 2), 0x0203);\n-        assert_eq!(u64_from_be_bytes(buf, 1, 3), 0x020304);\n-        assert_eq!(u64_from_be_bytes(buf, 1, 4), 0x02030405);\n-        assert_eq!(u64_from_be_bytes(buf, 1, 5), 0x0203040506);\n-        assert_eq!(u64_from_be_bytes(buf, 1, 6), 0x020304050607);\n-        assert_eq!(u64_from_be_bytes(buf, 1, 7), 0x02030405060708);\n-        assert_eq!(u64_from_be_bytes(buf, 1, 8), 0x0203040506070809);\n+        assert_eq!(u64_from_be_bytes(&buf, 1, 0), 0);\n+        assert_eq!(u64_from_be_bytes(&buf, 1, 1), 0x02);\n+        assert_eq!(u64_from_be_bytes(&buf, 1, 2), 0x0203);\n+        assert_eq!(u64_from_be_bytes(&buf, 1, 3), 0x020304);\n+        assert_eq!(u64_from_be_bytes(&buf, 1, 4), 0x02030405);\n+        assert_eq!(u64_from_be_bytes(&buf, 1, 5), 0x0203040506);\n+        assert_eq!(u64_from_be_bytes(&buf, 1, 6), 0x020304050607);\n+        assert_eq!(u64_from_be_bytes(&buf, 1, 7), 0x02030405060708);\n+        assert_eq!(u64_from_be_bytes(&buf, 1, 8), 0x0203040506070809);\n     }\n }\n "}, {"sha": "3f39dda650aff9260d79cb8eac37bffd204a64b0", "filename": "src/libstd/io/fs.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibstd%2Fio%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibstd%2Fio%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ffs.rs?ref=0047dbe59c41b951d34ce6324f3a8c0e15d523e9", "patch": "@@ -384,7 +384,7 @@ pub fn copy(from: &Path, to: &Path) -> IoResult<()> {\n     let mut buf = [0, ..io::DEFAULT_BUF_SIZE];\n \n     loop {\n-        let amt = match reader.read(buf) {\n+        let amt = match reader.read(&mut buf) {\n             Ok(n) => n,\n             Err(ref e) if e.kind == io::EndOfFile => { break }\n             Err(e) => return update_err(Err(e), from, to)\n@@ -881,7 +881,7 @@ mod test {\n         {\n             let mut read_stream = File::open_mode(filename, Open, Read);\n             let mut read_buf = [0, .. 1028];\n-            let read_str = match check!(read_stream.read(read_buf)) {\n+            let read_str = match check!(read_stream.read(&mut read_buf)) {\n                 -1|0 => panic!(\"shouldn't happen\"),\n                 n => str::from_utf8(read_buf[..n]).unwrap().to_string()\n             };\n@@ -939,7 +939,7 @@ mod test {\n             }\n         }\n         check!(unlink(filename));\n-        let read_str = str::from_utf8(read_mem).unwrap();\n+        let read_str = str::from_utf8(&read_mem).unwrap();\n         assert_eq!(read_str, message);\n     }\n \n@@ -960,11 +960,11 @@ mod test {\n             let mut read_stream = File::open_mode(filename, Open, Read);\n             check!(read_stream.seek(set_cursor as i64, SeekSet));\n             tell_pos_pre_read = check!(read_stream.tell());\n-            check!(read_stream.read(read_mem));\n+            check!(read_stream.read(&mut read_mem));\n             tell_pos_post_read = check!(read_stream.tell());\n         }\n         check!(unlink(filename));\n-        let read_str = str::from_utf8(read_mem).unwrap();\n+        let read_str = str::from_utf8(&read_mem).unwrap();\n         assert_eq!(read_str, message.slice(4, 8));\n         assert_eq!(tell_pos_pre_read, set_cursor);\n         assert_eq!(tell_pos_post_read, message.len() as u64);\n@@ -987,10 +987,10 @@ mod test {\n         }\n         {\n             let mut read_stream = File::open_mode(filename, Open, Read);\n-            check!(read_stream.read(read_mem));\n+            check!(read_stream.read(&mut read_mem));\n         }\n         check!(unlink(filename));\n-        let read_str = str::from_utf8(read_mem).unwrap();\n+        let read_str = str::from_utf8(&read_mem).unwrap();\n         assert!(read_str.as_slice() == final_msg.as_slice());\n     }\n \n@@ -1012,16 +1012,16 @@ mod test {\n             let mut read_stream = File::open_mode(filename, Open, Read);\n \n             check!(read_stream.seek(-4, SeekEnd));\n-            check!(read_stream.read(read_mem));\n-            assert_eq!(str::from_utf8(read_mem).unwrap(), chunk_three);\n+            check!(read_stream.read(&mut read_mem));\n+            assert_eq!(str::from_utf8(&read_mem).unwrap(), chunk_three);\n \n             check!(read_stream.seek(-9, SeekCur));\n-            check!(read_stream.read(read_mem));\n-            assert_eq!(str::from_utf8(read_mem).unwrap(), chunk_two);\n+            check!(read_stream.read(&mut read_mem));\n+            assert_eq!(str::from_utf8(&read_mem).unwrap(), chunk_two);\n \n             check!(read_stream.seek(0, SeekSet));\n-            check!(read_stream.read(read_mem));\n-            assert_eq!(str::from_utf8(read_mem).unwrap(), chunk_one);\n+            check!(read_stream.read(&mut read_mem));\n+            assert_eq!(str::from_utf8(&read_mem).unwrap(), chunk_one);\n         }\n         check!(unlink(filename));\n     }\n@@ -1107,8 +1107,8 @@ mod test {\n         for f in files.iter() {\n             {\n                 let n = f.filestem_str();\n-                check!(File::open(f).read(mem));\n-                let read_str = str::from_utf8(mem).unwrap();\n+                check!(File::open(f).read(&mut mem));\n+                let read_str = str::from_utf8(&mem).unwrap();\n                 let expected = match n {\n                     None|Some(\"\") => panic!(\"really shouldn't happen..\"),\n                     Some(n) => format!(\"{}{}\", prefix, n),\n@@ -1532,13 +1532,13 @@ mod test {\n         use rand::{StdRng, Rng};\n \n         let mut bytes = [0, ..1024];\n-        StdRng::new().ok().unwrap().fill_bytes(bytes);\n+        StdRng::new().ok().unwrap().fill_bytes(&mut bytes);\n \n         let tmpdir = tmpdir();\n \n-        check!(File::create(&tmpdir.join(\"test\")).write(bytes));\n+        check!(File::create(&tmpdir.join(\"test\")).write(&bytes));\n         let actual = check!(File::open(&tmpdir.join(\"test\")).read_to_end());\n-        assert!(actual.as_slice() == bytes);\n+        assert!(actual.as_slice() == &bytes);\n     }\n \n     #[test]"}, {"sha": "66ae88cfe5125ce97dc9364a66ac0394612999c2", "filename": "src/libstd/io/mem.rs", "status": "modified", "additions": 46, "deletions": 46, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibstd%2Fio%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibstd%2Fio%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmem.rs?ref=0047dbe59c41b951d34ce6324f3a8c0e15d523e9", "patch": "@@ -50,7 +50,7 @@ fn combine(seek: SeekStyle, cur: uint, end: uint, offset: i64) -> IoResult<u64>\n /// use std::io::MemWriter;\n ///\n /// let mut w = MemWriter::new();\n-/// w.write([0, 1, 2]);\n+/// w.write(&[0, 1, 2]);\n ///\n /// assert_eq!(w.unwrap(), vec!(0, 1, 2));\n /// ```\n@@ -200,8 +200,8 @@ impl Buffer for MemReader {\n ///\n /// let mut buf = [0, ..4];\n /// {\n-///     let mut w = BufWriter::new(buf);\n-///     w.write([0, 1, 2]);\n+///     let mut w = BufWriter::new(&mut buf);\n+///     w.write(&[0, 1, 2]);\n /// }\n /// assert!(buf == [0, 1, 2, 0]);\n /// ```\n@@ -262,7 +262,7 @@ impl<'a> Seek for BufWriter<'a> {\n /// use std::io::BufReader;\n ///\n /// let mut buf = [0, 1, 2, 3];\n-/// let mut r = BufReader::new(buf);\n+/// let mut r = BufReader::new(&mut buf);\n ///\n /// assert_eq!(r.read_to_end().unwrap(), vec!(0, 1, 2, 3));\n /// ```\n@@ -346,9 +346,9 @@ mod test {\n     #[test]\n     fn test_mem_writer() {\n         let mut writer = MemWriter::new();\n-        writer.write([0]).unwrap();\n-        writer.write([1, 2, 3]).unwrap();\n-        writer.write([4, 5, 6, 7]).unwrap();\n+        writer.write(&[0]).unwrap();\n+        writer.write(&[1, 2, 3]).unwrap();\n+        writer.write(&[4, 5, 6, 7]).unwrap();\n         let b: &[_] = &[0, 1, 2, 3, 4, 5, 6, 7];\n         assert_eq!(writer.get_ref(), b);\n     }\n@@ -357,14 +357,14 @@ mod test {\n     fn test_buf_writer() {\n         let mut buf = [0 as u8, ..8];\n         {\n-            let mut writer = BufWriter::new(buf);\n+            let mut writer = BufWriter::new(&mut buf);\n             assert_eq!(writer.tell(), Ok(0));\n-            writer.write([0]).unwrap();\n+            writer.write(&[0]).unwrap();\n             assert_eq!(writer.tell(), Ok(1));\n-            writer.write([1, 2, 3]).unwrap();\n-            writer.write([4, 5, 6, 7]).unwrap();\n+            writer.write(&[1, 2, 3]).unwrap();\n+            writer.write(&[4, 5, 6, 7]).unwrap();\n             assert_eq!(writer.tell(), Ok(8));\n-            writer.write([]).unwrap();\n+            writer.write(&[]).unwrap();\n             assert_eq!(writer.tell(), Ok(8));\n         }\n         let b: &[_] = &[0, 1, 2, 3, 4, 5, 6, 7];\n@@ -375,24 +375,24 @@ mod test {\n     fn test_buf_writer_seek() {\n         let mut buf = [0 as u8, ..8];\n         {\n-            let mut writer = BufWriter::new(buf);\n+            let mut writer = BufWriter::new(&mut buf);\n             assert_eq!(writer.tell(), Ok(0));\n-            writer.write([1]).unwrap();\n+            writer.write(&[1]).unwrap();\n             assert_eq!(writer.tell(), Ok(1));\n \n             writer.seek(2, SeekSet).unwrap();\n             assert_eq!(writer.tell(), Ok(2));\n-            writer.write([2]).unwrap();\n+            writer.write(&[2]).unwrap();\n             assert_eq!(writer.tell(), Ok(3));\n \n             writer.seek(-2, SeekCur).unwrap();\n             assert_eq!(writer.tell(), Ok(1));\n-            writer.write([3]).unwrap();\n+            writer.write(&[3]).unwrap();\n             assert_eq!(writer.tell(), Ok(2));\n \n             writer.seek(-1, SeekEnd).unwrap();\n             assert_eq!(writer.tell(), Ok(7));\n-            writer.write([4]).unwrap();\n+            writer.write(&[4]).unwrap();\n             assert_eq!(writer.tell(), Ok(8));\n \n         }\n@@ -403,10 +403,10 @@ mod test {\n     #[test]\n     fn test_buf_writer_error() {\n         let mut buf = [0 as u8, ..2];\n-        let mut writer = BufWriter::new(buf);\n-        writer.write([0]).unwrap();\n+        let mut writer = BufWriter::new(&mut buf);\n+        writer.write(&[0]).unwrap();\n \n-        match writer.write([0, 0]) {\n+        match writer.write(&[0, 0]) {\n             Ok(..) => panic!(),\n             Err(e) => assert_eq!(e.kind, io::OtherIoError),\n         }\n@@ -416,53 +416,53 @@ mod test {\n     fn test_mem_reader() {\n         let mut reader = MemReader::new(vec!(0, 1, 2, 3, 4, 5, 6, 7));\n         let mut buf = [];\n-        assert_eq!(reader.read(buf), Ok(0));\n+        assert_eq!(reader.read(&mut buf), Ok(0));\n         assert_eq!(reader.tell(), Ok(0));\n         let mut buf = [0];\n-        assert_eq!(reader.read(buf), Ok(1));\n+        assert_eq!(reader.read(&mut buf), Ok(1));\n         assert_eq!(reader.tell(), Ok(1));\n         let b: &[_] = &[0];\n         assert_eq!(buf.as_slice(), b);\n         let mut buf = [0, ..4];\n-        assert_eq!(reader.read(buf), Ok(4));\n+        assert_eq!(reader.read(&mut buf), Ok(4));\n         assert_eq!(reader.tell(), Ok(5));\n         let b: &[_] = &[1, 2, 3, 4];\n         assert_eq!(buf.as_slice(), b);\n-        assert_eq!(reader.read(buf), Ok(3));\n+        assert_eq!(reader.read(&mut buf), Ok(3));\n         let b: &[_] = &[5, 6, 7];\n         assert_eq!(buf[0..3], b);\n-        assert!(reader.read(buf).is_err());\n+        assert!(reader.read(&mut buf).is_err());\n         let mut reader = MemReader::new(vec!(0, 1, 2, 3, 4, 5, 6, 7));\n         assert_eq!(reader.read_until(3).unwrap(), vec!(0, 1, 2, 3));\n         assert_eq!(reader.read_until(3).unwrap(), vec!(4, 5, 6, 7));\n-        assert!(reader.read(buf).is_err());\n+        assert!(reader.read(&mut buf).is_err());\n     }\n \n     #[test]\n     fn test_buf_reader() {\n         let in_buf = vec![0, 1, 2, 3, 4, 5, 6, 7];\n         let mut reader = BufReader::new(in_buf.as_slice());\n         let mut buf = [];\n-        assert_eq!(reader.read(buf), Ok(0));\n+        assert_eq!(reader.read(&mut buf), Ok(0));\n         assert_eq!(reader.tell(), Ok(0));\n         let mut buf = [0];\n-        assert_eq!(reader.read(buf), Ok(1));\n+        assert_eq!(reader.read(&mut buf), Ok(1));\n         assert_eq!(reader.tell(), Ok(1));\n         let b: &[_] = &[0];\n         assert_eq!(buf.as_slice(), b);\n         let mut buf = [0, ..4];\n-        assert_eq!(reader.read(buf), Ok(4));\n+        assert_eq!(reader.read(&mut buf), Ok(4));\n         assert_eq!(reader.tell(), Ok(5));\n         let b: &[_] = &[1, 2, 3, 4];\n         assert_eq!(buf.as_slice(), b);\n-        assert_eq!(reader.read(buf), Ok(3));\n+        assert_eq!(reader.read(&mut buf), Ok(3));\n         let b: &[_] = &[5, 6, 7];\n         assert_eq!(buf[0..3], b);\n-        assert!(reader.read(buf).is_err());\n+        assert!(reader.read(&mut buf).is_err());\n         let mut reader = BufReader::new(in_buf.as_slice());\n         assert_eq!(reader.read_until(3).unwrap(), vec!(0, 1, 2, 3));\n         assert_eq!(reader.read_until(3).unwrap(), vec!(4, 5, 6, 7));\n-        assert!(reader.read(buf).is_err());\n+        assert!(reader.read(&mut buf).is_err());\n     }\n \n     #[test]\n@@ -506,7 +506,7 @@ mod test {\n     #[test]\n     fn test_read_whole_string_bad() {\n         let buf = [0xff];\n-        let mut r = BufReader::new(buf);\n+        let mut r = BufReader::new(&buf);\n         match r.read_to_string() {\n             Ok(..) => panic!(),\n             Err(..) => {}\n@@ -516,7 +516,7 @@ mod test {\n     #[test]\n     fn seek_past_end() {\n         let buf = [0xff];\n-        let mut r = BufReader::new(buf);\n+        let mut r = BufReader::new(&buf);\n         r.seek(10, SeekSet).unwrap();\n         assert!(r.read(&mut []).is_err());\n \n@@ -525,38 +525,38 @@ mod test {\n         assert!(r.read(&mut []).is_err());\n \n         let mut buf = [0];\n-        let mut r = BufWriter::new(buf);\n+        let mut r = BufWriter::new(&mut buf);\n         r.seek(10, SeekSet).unwrap();\n-        assert!(r.write([3]).is_err());\n+        assert!(r.write(&[3]).is_err());\n     }\n \n     #[test]\n     fn seek_before_0() {\n         let buf = [0xff];\n-        let mut r = BufReader::new(buf);\n+        let mut r = BufReader::new(&buf);\n         assert!(r.seek(-1, SeekSet).is_err());\n \n         let mut r = MemReader::new(vec!(10));\n         assert!(r.seek(-1, SeekSet).is_err());\n \n         let mut buf = [0];\n-        let mut r = BufWriter::new(buf);\n+        let mut r = BufWriter::new(&mut buf);\n         assert!(r.seek(-1, SeekSet).is_err());\n     }\n \n     #[test]\n     fn io_read_at_least() {\n         let mut r = MemReader::new(vec![1, 2, 3, 4, 5, 6, 7, 8]);\n         let mut buf = [0, ..3];\n-        assert!(r.read_at_least(buf.len(), buf).is_ok());\n+        assert!(r.read_at_least(buf.len(), &mut buf).is_ok());\n         let b: &[_] = &[1, 2, 3];\n         assert_eq!(buf.as_slice(), b);\n         assert!(r.read_at_least(0, buf[mut ..0]).is_ok());\n         assert_eq!(buf.as_slice(), b);\n-        assert!(r.read_at_least(buf.len(), buf).is_ok());\n+        assert!(r.read_at_least(buf.len(), &mut buf).is_ok());\n         let b: &[_] = &[4, 5, 6];\n         assert_eq!(buf.as_slice(), b);\n-        assert!(r.read_at_least(buf.len(), buf).is_err());\n+        assert!(r.read_at_least(buf.len(), &mut buf).is_err());\n         let b: &[_] = &[7, 8, 6];\n         assert_eq!(buf.as_slice(), b);\n     }\n@@ -625,7 +625,7 @@ mod test {\n                 let mut rdr = MemReader::new(buf);\n                 for _i in range(0u, 10) {\n                     let mut buf = [0 as u8, .. 10];\n-                    rdr.read(buf).unwrap();\n+                    rdr.read(&mut buf).unwrap();\n                     assert_eq!(buf.as_slice(), [5, .. 10].as_slice());\n                 }\n             }\n@@ -637,9 +637,9 @@ mod test {\n         b.iter(|| {\n             let mut buf = [0 as u8, ..100];\n             {\n-                let mut wr = BufWriter::new(buf);\n+                let mut wr = BufWriter::new(&mut buf);\n                 for _i in range(0u, 10) {\n-                    wr.write([5, .. 10]).unwrap();\n+                    wr.write(&[5, .. 10]).unwrap();\n                 }\n             }\n             assert_eq!(buf.as_slice(), [5, .. 100].as_slice());\n@@ -651,10 +651,10 @@ mod test {\n         b.iter(|| {\n             let buf = [5 as u8, ..100];\n             {\n-                let mut rdr = BufReader::new(buf);\n+                let mut rdr = BufReader::new(&buf);\n                 for _i in range(0u, 10) {\n                     let mut buf = [0 as u8, .. 10];\n-                    rdr.read(buf).unwrap();\n+                    rdr.read(&mut buf).unwrap();\n                     assert_eq!(buf.as_slice(), [5, .. 10].as_slice());\n                 }\n             }"}, {"sha": "66c29db0455926abd79fc1d014d28318c50a8909", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=0047dbe59c41b951d34ce6324f3a8c0e15d523e9", "patch": "@@ -521,7 +521,7 @@ pub trait Reader {\n     /// Reads a single byte. Returns `Err` on EOF.\n     fn read_byte(&mut self) -> IoResult<u8> {\n         let mut buf = [0];\n-        try!(self.read_at_least(1, buf));\n+        try!(self.read_at_least(1, &mut buf));\n         Ok(buf[0])\n     }\n \n@@ -1061,7 +1061,7 @@ pub trait Writer {\n     /// that the `write` method is used specifically instead.\n     #[inline]\n     fn write_line(&mut self, s: &str) -> IoResult<()> {\n-        self.write_str(s).and_then(|()| self.write([b'\\n']))\n+        self.write_str(s).and_then(|()| self.write(&[b'\\n']))\n     }\n \n     /// Write a single char, encoded as UTF-8.\n@@ -1217,13 +1217,13 @@ pub trait Writer {\n     /// Write a u8 (1 byte).\n     #[inline]\n     fn write_u8(&mut self, n: u8) -> IoResult<()> {\n-        self.write([n])\n+        self.write(&[n])\n     }\n \n     /// Write an i8 (1 byte).\n     #[inline]\n     fn write_i8(&mut self, n: i8) -> IoResult<()> {\n-        self.write([n as u8])\n+        self.write(&[n as u8])\n     }\n }\n \n@@ -1949,7 +1949,7 @@ mod tests {\n     fn test_read_at_least() {\n         let mut r = BadReader::new(MemReader::new(b\"hello, world!\".to_vec()),\n                                    vec![GoodBehavior(uint::MAX)]);\n-        let mut buf = [0u8, ..5];\n+        let buf = &mut [0u8, ..5];\n         assert!(r.read_at_least(1, buf).unwrap() >= 1);\n         assert!(r.read_exact(5).unwrap().len() == 5); // read_exact uses read_at_least\n         assert!(r.read_at_least(0, buf).is_ok());"}, {"sha": "8e934d221d22c7795faa658480883869576ea197", "filename": "src/libstd/io/net/pipe.rs", "status": "modified", "additions": 43, "deletions": 43, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibstd%2Fio%2Fnet%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibstd%2Fio%2Fnet%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Fpipe.rs?ref=0047dbe59c41b951d34ce6324f3a8c0e15d523e9", "patch": "@@ -53,7 +53,7 @@ impl UnixStream {\n     ///\n     /// let server = Path::new(\"path/to/my/socket\");\n     /// let mut stream = UnixStream::connect(&server);\n-    /// stream.write([1, 2, 3]);\n+    /// stream.write(&[1, 2, 3]);\n     /// ```\n     pub fn connect<P: ToCStr>(path: &P) -> IoResult<UnixStream> {\n         UnixStreamImp::connect(&path.to_c_str(), None)\n@@ -169,7 +169,7 @@ impl UnixListener {\n     /// let server = Path::new(\"/path/to/my/socket\");\n     /// let stream = UnixListener::bind(&server);\n     /// for mut client in stream.listen().incoming() {\n-    ///     client.write([1, 2, 3, 4]);\n+    ///     client.write(&[1, 2, 3, 4]);\n     /// }\n     /// # }\n     /// ```\n@@ -307,10 +307,10 @@ mod tests {\n     fn smoke() {\n         smalltest(proc(mut server) {\n             let mut buf = [0];\n-            server.read(buf).unwrap();\n+            server.read(&mut buf).unwrap();\n             assert!(buf[0] == 99);\n         }, proc(mut client) {\n-            client.write([99]).unwrap();\n+            client.write(&[99]).unwrap();\n         })\n     }\n \n@@ -319,8 +319,8 @@ mod tests {\n     fn read_eof() {\n         smalltest(proc(mut server) {\n             let mut buf = [0];\n-            assert!(server.read(buf).is_err());\n-            assert!(server.read(buf).is_err());\n+            assert!(server.read(&mut buf).is_err());\n+            assert!(server.read(&mut buf).is_err());\n         }, proc(_client) {\n             // drop the client\n         })\n@@ -331,7 +331,7 @@ mod tests {\n         smalltest(proc(mut server) {\n             let buf = [0];\n             loop {\n-                match server.write(buf) {\n+                match server.write(&buf) {\n                     Ok(..) => {}\n                     Err(e) => {\n                         assert!(e.kind == BrokenPipe ||\n@@ -361,7 +361,7 @@ mod tests {\n         spawn(proc() {\n             for _ in range(0u, times) {\n                 let mut stream = UnixStream::connect(&path2);\n-                match stream.write([100]) {\n+                match stream.write(&[100]) {\n                     Ok(..) => {}\n                     Err(e) => panic!(\"failed write: {}\", e)\n                 }\n@@ -371,7 +371,7 @@ mod tests {\n         for _ in range(0, times) {\n             let mut client = acceptor.accept();\n             let mut buf = [0];\n-            match client.read(buf) {\n+            match client.read(&mut buf) {\n                 Ok(..) => {}\n                 Err(e) => panic!(\"failed read/accept: {}\", e),\n             }\n@@ -396,10 +396,10 @@ mod tests {\n             let mut s = UnixStream::connect(&addr);\n             let mut buf = [0, 0];\n             debug!(\"client reading\");\n-            assert_eq!(s.read(buf), Ok(1));\n+            assert_eq!(s.read(&mut buf), Ok(1));\n             assert_eq!(buf[0], 1);\n             debug!(\"client writing\");\n-            s.write([2]).unwrap();\n+            s.write(&[2]).unwrap();\n             debug!(\"client dropping\");\n         });\n \n@@ -412,14 +412,14 @@ mod tests {\n             let mut s2 = s2;\n             rx1.recv();\n             debug!(\"writer writing\");\n-            s2.write([1]).unwrap();\n+            s2.write(&[1]).unwrap();\n             debug!(\"writer done\");\n             tx2.send(());\n         });\n         tx1.send(());\n         let mut buf = [0, 0];\n         debug!(\"reader reading\");\n-        assert_eq!(s1.read(buf), Ok(1));\n+        assert_eq!(s1.read(&mut buf), Ok(1));\n         debug!(\"reader done\");\n         rx2.recv();\n     }\n@@ -433,9 +433,9 @@ mod tests {\n \n         spawn(proc() {\n             let mut s = UnixStream::connect(&addr);\n-            s.write([1]).unwrap();\n+            s.write(&[1]).unwrap();\n             rx.recv();\n-            s.write([2]).unwrap();\n+            s.write(&[2]).unwrap();\n             rx.recv();\n         });\n \n@@ -446,12 +446,12 @@ mod tests {\n         spawn(proc() {\n             let mut s2 = s2;\n             let mut buf = [0, 0];\n-            s2.read(buf).unwrap();\n+            s2.read(&mut buf).unwrap();\n             tx2.send(());\n             done.send(());\n         });\n         let mut buf = [0, 0];\n-        s1.read(buf).unwrap();\n+        s1.read(&mut buf).unwrap();\n         tx1.send(());\n \n         rx.recv();\n@@ -464,7 +464,7 @@ mod tests {\n \n         spawn(proc() {\n             let mut s = UnixStream::connect(&addr);\n-            let mut buf = [0, 1];\n+            let buf = &mut [0, 1];\n             s.read(buf).unwrap();\n             s.read(buf).unwrap();\n         });\n@@ -475,10 +475,10 @@ mod tests {\n         let (tx, rx) = channel();\n         spawn(proc() {\n             let mut s2 = s2;\n-            s2.write([1]).unwrap();\n+            s2.write(&[1]).unwrap();\n             tx.send(());\n         });\n-        s1.write([2]).unwrap();\n+        s1.write(&[2]).unwrap();\n \n         rx.recv();\n     }\n@@ -588,18 +588,18 @@ mod tests {\n \n         // closing should prevent reads/writes\n         s.close_write().unwrap();\n-        assert!(s.write([0]).is_err());\n+        assert!(s.write(&[0]).is_err());\n         s.close_read().unwrap();\n-        assert!(s.read(b).is_err());\n+        assert!(s.read(&mut b).is_err());\n \n         // closing should affect previous handles\n-        assert!(s2.write([0]).is_err());\n-        assert!(s2.read(b).is_err());\n+        assert!(s2.write(&[0]).is_err());\n+        assert!(s2.read(&mut b).is_err());\n \n         // closing should affect new handles\n         let mut s3 = s.clone();\n-        assert!(s3.write([0]).is_err());\n-        assert!(s3.read(b).is_err());\n+        assert!(s3.write(&[0]).is_err());\n+        assert!(s3.read(&mut b).is_err());\n \n         // make sure these don't die\n         let _ = s2.close_read();\n@@ -624,7 +624,7 @@ mod tests {\n         let (tx, rx) = channel();\n         spawn(proc() {\n             let mut s2 = s2;\n-            assert!(s2.read([0]).is_err());\n+            assert!(s2.read(&mut [0]).is_err());\n             tx.send(());\n         });\n         // this should wake up the child task\n@@ -642,18 +642,18 @@ mod tests {\n         spawn(proc() {\n             let mut s = UnixStream::connect(&addr).unwrap();\n             rx.recv();\n-            assert!(s.write([0]).is_ok());\n+            assert!(s.write(&[0]).is_ok());\n             let _ = rx.recv_opt();\n         });\n \n         let mut s = a.accept().unwrap();\n         s.set_timeout(Some(20));\n-        assert_eq!(s.read([0]).err().unwrap().kind, TimedOut);\n-        assert_eq!(s.read([0]).err().unwrap().kind, TimedOut);\n+        assert_eq!(s.read(&mut [0]).err().unwrap().kind, TimedOut);\n+        assert_eq!(s.read(&mut [0]).err().unwrap().kind, TimedOut);\n \n         s.set_timeout(Some(20));\n         for i in range(0u, 1001) {\n-            match s.write([0, .. 128 * 1024]) {\n+            match s.write(&[0, .. 128 * 1024]) {\n                 Ok(()) | Err(IoError { kind: ShortWrite(..), .. }) => {},\n                 Err(IoError { kind: TimedOut, .. }) => break,\n                 Err(e) => panic!(\"{}\", e),\n@@ -664,12 +664,12 @@ mod tests {\n         // I'm not sure as to why, but apparently the write on windows always\n         // succeeds after the previous timeout. Who knows?\n         if !cfg!(windows) {\n-            assert_eq!(s.write([0]).err().unwrap().kind, TimedOut);\n+            assert_eq!(s.write(&[0]).err().unwrap().kind, TimedOut);\n         }\n \n         tx.send(());\n         s.set_timeout(None);\n-        assert_eq!(s.read([0, 0]), Ok(1));\n+        assert_eq!(s.read(&mut [0, 0]), Ok(1));\n     }\n \n     #[test]\n@@ -682,7 +682,7 @@ mod tests {\n             rx.recv();\n             let mut amt = 0;\n             while amt < 100 * 128 * 1024 {\n-                match s.read([0, ..128 * 1024]) {\n+                match s.read(&mut [0, ..128 * 1024]) {\n                     Ok(n) => { amt += n; }\n                     Err(e) => panic!(\"{}\", e),\n                 }\n@@ -692,12 +692,12 @@ mod tests {\n \n         let mut s = a.accept().unwrap();\n         s.set_read_timeout(Some(20));\n-        assert_eq!(s.read([0]).err().unwrap().kind, TimedOut);\n-        assert_eq!(s.read([0]).err().unwrap().kind, TimedOut);\n+        assert_eq!(s.read(&mut [0]).err().unwrap().kind, TimedOut);\n+        assert_eq!(s.read(&mut [0]).err().unwrap().kind, TimedOut);\n \n         tx.send(());\n         for _ in range(0u, 100) {\n-            assert!(s.write([0, ..128 * 1024]).is_ok());\n+            assert!(s.write(&[0, ..128 * 1024]).is_ok());\n         }\n     }\n \n@@ -709,14 +709,14 @@ mod tests {\n         spawn(proc() {\n             let mut s = UnixStream::connect(&addr).unwrap();\n             rx.recv();\n-            assert!(s.write([0]).is_ok());\n+            assert!(s.write(&[0]).is_ok());\n             let _ = rx.recv_opt();\n         });\n \n         let mut s = a.accept().unwrap();\n         s.set_write_timeout(Some(20));\n         for i in range(0u, 1001) {\n-            match s.write([0, .. 128 * 1024]) {\n+            match s.write(&[0, .. 128 * 1024]) {\n                 Ok(()) | Err(IoError { kind: ShortWrite(..), .. }) => {},\n                 Err(IoError { kind: TimedOut, .. }) => break,\n                 Err(e) => panic!(\"{}\", e),\n@@ -725,7 +725,7 @@ mod tests {\n         }\n \n         tx.send(());\n-        assert!(s.read([0]).is_ok());\n+        assert!(s.read(&mut [0]).is_ok());\n     }\n \n     #[test]\n@@ -736,7 +736,7 @@ mod tests {\n         spawn(proc() {\n             let mut s = UnixStream::connect(&addr).unwrap();\n             rx.recv();\n-            assert!(s.write([0]).is_ok());\n+            assert!(s.write(&[0]).is_ok());\n             let _ = rx.recv_opt();\n         });\n \n@@ -745,12 +745,12 @@ mod tests {\n         let (tx2, rx2) = channel();\n         spawn(proc() {\n             let mut s2 = s2;\n-            assert!(s2.read([0]).is_ok());\n+            assert!(s2.read(&mut [0]).is_ok());\n             tx2.send(());\n         });\n \n         s.set_read_timeout(Some(20));\n-        assert_eq!(s.read([0]).err().unwrap().kind, TimedOut);\n+        assert_eq!(s.read(&mut [0]).err().unwrap().kind, TimedOut);\n         tx.send(());\n \n         rx2.recv();"}, {"sha": "cab54d82e1c5f915c7a7b66539625c4efeca175d", "filename": "src/libstd/io/net/tcp.rs", "status": "modified", "additions": 77, "deletions": 77, "changes": 154, "blob_url": "https://github.com/rust-lang/rust/blob/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs?ref=0047dbe59c41b951d34ce6324f3a8c0e15d523e9", "patch": "@@ -42,9 +42,9 @@ use sys::tcp::TcpAcceptor as TcpAcceptorImp;\n ///\n /// let mut stream = TcpStream::connect(\"127.0.0.1:34254\");\n ///\n-/// stream.write([1]);\n+/// stream.write(&[1]);\n /// let mut buf = [0];\n-/// stream.read(buf);\n+/// stream.read(&mut buf);\n /// drop(stream); // close the connection\n /// ```\n pub struct TcpStream {\n@@ -143,7 +143,7 @@ impl TcpStream {\n     ///\n     /// // wait for some data, will get canceled after one second\n     /// let mut buf = [0];\n-    /// stream.read(buf);\n+    /// stream.read(&mut buf);\n     /// ```\n     ///\n     /// Note that this method affects all cloned handles associated with this\n@@ -487,12 +487,12 @@ mod test {\n \n         spawn(proc() {\n             let mut stream = TcpStream::connect((\"localhost\", socket_addr.port));\n-            stream.write([144]).unwrap();\n+            stream.write(&[144]).unwrap();\n         });\n \n         let mut stream = acceptor.accept();\n         let mut buf = [0];\n-        stream.read(buf).unwrap();\n+        stream.read(&mut buf).unwrap();\n         assert!(buf[0] == 144);\n     }\n \n@@ -503,12 +503,12 @@ mod test {\n \n         spawn(proc() {\n             let mut stream = TcpStream::connect((\"localhost\", addr.port));\n-            stream.write([64]).unwrap();\n+            stream.write(&[64]).unwrap();\n         });\n \n         let mut stream = acceptor.accept();\n         let mut buf = [0];\n-        stream.read(buf).unwrap();\n+        stream.read(&mut buf).unwrap();\n         assert!(buf[0] == 64);\n     }\n \n@@ -519,12 +519,12 @@ mod test {\n \n         spawn(proc() {\n             let mut stream = TcpStream::connect((\"127.0.0.1\", addr.port));\n-            stream.write([44]).unwrap();\n+            stream.write(&[44]).unwrap();\n         });\n \n         let mut stream = acceptor.accept();\n         let mut buf = [0];\n-        stream.read(buf).unwrap();\n+        stream.read(&mut buf).unwrap();\n         assert!(buf[0] == 44);\n     }\n \n@@ -535,12 +535,12 @@ mod test {\n \n         spawn(proc() {\n             let mut stream = TcpStream::connect((\"::1\", addr.port));\n-            stream.write([66]).unwrap();\n+            stream.write(&[66]).unwrap();\n         });\n \n         let mut stream = acceptor.accept();\n         let mut buf = [0];\n-        stream.read(buf).unwrap();\n+        stream.read(&mut buf).unwrap();\n         assert!(buf[0] == 66);\n     }\n \n@@ -551,12 +551,12 @@ mod test {\n \n         spawn(proc() {\n             let mut stream = TcpStream::connect(addr);\n-            stream.write([99]).unwrap();\n+            stream.write(&[99]).unwrap();\n         });\n \n         let mut stream = acceptor.accept();\n         let mut buf = [0];\n-        stream.read(buf).unwrap();\n+        stream.read(&mut buf).unwrap();\n         assert!(buf[0] == 99);\n     }\n \n@@ -567,12 +567,12 @@ mod test {\n \n         spawn(proc() {\n             let mut stream = TcpStream::connect(addr);\n-            stream.write([99]).unwrap();\n+            stream.write(&[99]).unwrap();\n         });\n \n         let mut stream = acceptor.accept();\n         let mut buf = [0];\n-        stream.read(buf).unwrap();\n+        stream.read(&mut buf).unwrap();\n         assert!(buf[0] == 99);\n     }\n \n@@ -588,7 +588,7 @@ mod test {\n \n         let mut stream = acceptor.accept();\n         let mut buf = [0];\n-        let nread = stream.read(buf);\n+        let nread = stream.read(&mut buf);\n         assert!(nread.is_err());\n     }\n \n@@ -604,7 +604,7 @@ mod test {\n \n         let mut stream = acceptor.accept();\n         let mut buf = [0];\n-        let nread = stream.read(buf);\n+        let nread = stream.read(&mut buf);\n         assert!(nread.is_err());\n     }\n \n@@ -620,10 +620,10 @@ mod test {\n \n         let mut stream = acceptor.accept();\n         let mut buf = [0];\n-        let nread = stream.read(buf);\n+        let nread = stream.read(&mut buf);\n         assert!(nread.is_err());\n \n-        match stream.read(buf) {\n+        match stream.read(&mut buf) {\n             Ok(..) => panic!(),\n             Err(ref e) => {\n                 assert!(e.kind == NotConnected || e.kind == EndOfFile,\n@@ -644,10 +644,10 @@ mod test {\n \n         let mut stream = acceptor.accept();\n         let mut buf = [0];\n-        let nread = stream.read(buf);\n+        let nread = stream.read(&mut buf);\n         assert!(nread.is_err());\n \n-        match stream.read(buf) {\n+        match stream.read(&mut buf) {\n             Ok(..) => panic!(),\n             Err(ref e) => {\n                 assert!(e.kind == NotConnected || e.kind == EndOfFile,\n@@ -670,7 +670,7 @@ mod test {\n         let mut stream = acceptor.accept();\n         rx.recv();\n         let buf = [0];\n-        match stream.write(buf) {\n+        match stream.write(&buf) {\n             Ok(..) => {}\n             Err(e) => {\n                 assert!(e.kind == ConnectionReset ||\n@@ -695,7 +695,7 @@ mod test {\n         let mut stream = acceptor.accept();\n         rx.recv();\n         let buf = [0];\n-        match stream.write(buf) {\n+        match stream.write(&buf) {\n             Ok(..) => {}\n             Err(e) => {\n                 assert!(e.kind == ConnectionReset ||\n@@ -715,13 +715,13 @@ mod test {\n         spawn(proc() {\n             for _ in range(0, max) {\n                 let mut stream = TcpStream::connect(addr);\n-                stream.write([99]).unwrap();\n+                stream.write(&[99]).unwrap();\n             }\n         });\n \n         for ref mut stream in acceptor.incoming().take(max) {\n             let mut buf = [0];\n-            stream.read(buf).unwrap();\n+            stream.read(&mut buf).unwrap();\n             assert_eq!(buf[0], 99);\n         }\n     }\n@@ -735,13 +735,13 @@ mod test {\n         spawn(proc() {\n             for _ in range(0, max) {\n                 let mut stream = TcpStream::connect(addr);\n-                stream.write([99]).unwrap();\n+                stream.write(&[99]).unwrap();\n             }\n         });\n \n         for ref mut stream in acceptor.incoming().take(max) {\n             let mut buf = [0];\n-            stream.read(buf).unwrap();\n+            stream.read(&mut buf).unwrap();\n             assert_eq!(buf[0], 99);\n         }\n     }\n@@ -759,7 +759,7 @@ mod test {\n                 spawn(proc() {\n                     let mut stream = stream;\n                     let mut buf = [0];\n-                    stream.read(buf).unwrap();\n+                    stream.read(&mut buf).unwrap();\n                     assert!(buf[0] == i as u8);\n                     debug!(\"read\");\n                 });\n@@ -777,7 +777,7 @@ mod test {\n                 // Connect again before writing\n                 connect(i + 1, addr);\n                 debug!(\"writing\");\n-                stream.write([i as u8]).unwrap();\n+                stream.write(&[i as u8]).unwrap();\n             });\n         }\n     }\n@@ -795,7 +795,7 @@ mod test {\n                 spawn(proc() {\n                     let mut stream = stream;\n                     let mut buf = [0];\n-                    stream.read(buf).unwrap();\n+                    stream.read(&mut buf).unwrap();\n                     assert!(buf[0] == i as u8);\n                     debug!(\"read\");\n                 });\n@@ -813,7 +813,7 @@ mod test {\n                 // Connect again before writing\n                 connect(i + 1, addr);\n                 debug!(\"writing\");\n-                stream.write([i as u8]).unwrap();\n+                stream.write(&[i as u8]).unwrap();\n             });\n         }\n     }\n@@ -831,7 +831,7 @@ mod test {\n                 spawn(proc() {\n                     let mut stream = stream;\n                     let mut buf = [0];\n-                    stream.read(buf).unwrap();\n+                    stream.read(&mut buf).unwrap();\n                     assert!(buf[0] == 99);\n                     debug!(\"read\");\n                 });\n@@ -849,7 +849,7 @@ mod test {\n                 // Connect again before writing\n                 connect(i + 1, addr);\n                 debug!(\"writing\");\n-                stream.write([99]).unwrap();\n+                stream.write(&[99]).unwrap();\n             });\n         }\n     }\n@@ -867,7 +867,7 @@ mod test {\n                 spawn(proc() {\n                     let mut stream = stream;\n                     let mut buf = [0];\n-                    stream.read(buf).unwrap();\n+                    stream.read(&mut buf).unwrap();\n                     assert!(buf[0] == 99);\n                     debug!(\"read\");\n                 });\n@@ -885,7 +885,7 @@ mod test {\n                 // Connect again before writing\n                 connect(i + 1, addr);\n                 debug!(\"writing\");\n-                stream.write([99]).unwrap();\n+                stream.write(&[99]).unwrap();\n             });\n         }\n     }\n@@ -941,17 +941,17 @@ mod test {\n             let mut srv = TcpListener::bind(addr).listen().unwrap();\n             tx.send(());\n             let mut cl = srv.accept().unwrap();\n-            cl.write([10]).unwrap();\n+            cl.write(&[10]).unwrap();\n             let mut b = [0];\n-            cl.read(b).unwrap();\n+            cl.read(&mut b).unwrap();\n             tx.send(());\n         });\n \n         rx.recv();\n         let mut c = TcpStream::connect(addr).unwrap();\n         let mut b = [0, ..10];\n-        assert_eq!(c.read(b), Ok(1));\n-        c.write([1]).unwrap();\n+        assert_eq!(c.read(&mut b), Ok(1));\n+        c.write(&[1]).unwrap();\n         rx.recv();\n     }\n \n@@ -1002,9 +1002,9 @@ mod test {\n         spawn(proc() {\n             let mut s = TcpStream::connect(addr);\n             let mut buf = [0, 0];\n-            assert_eq!(s.read(buf), Ok(1));\n+            assert_eq!(s.read(&mut buf), Ok(1));\n             assert_eq!(buf[0], 1);\n-            s.write([2]).unwrap();\n+            s.write(&[2]).unwrap();\n         });\n \n         let mut s1 = acceptor.accept().unwrap();\n@@ -1015,12 +1015,12 @@ mod test {\n         spawn(proc() {\n             let mut s2 = s2;\n             rx1.recv();\n-            s2.write([1]).unwrap();\n+            s2.write(&[1]).unwrap();\n             tx2.send(());\n         });\n         tx1.send(());\n         let mut buf = [0, 0];\n-        assert_eq!(s1.read(buf), Ok(1));\n+        assert_eq!(s1.read(&mut buf), Ok(1));\n         rx2.recv();\n     }\n \n@@ -1033,9 +1033,9 @@ mod test {\n \n         spawn(proc() {\n             let mut s = TcpStream::connect(addr);\n-            s.write([1]).unwrap();\n+            s.write(&[1]).unwrap();\n             rx.recv();\n-            s.write([2]).unwrap();\n+            s.write(&[2]).unwrap();\n             rx.recv();\n         });\n \n@@ -1046,12 +1046,12 @@ mod test {\n         spawn(proc() {\n             let mut s2 = s2;\n             let mut buf = [0, 0];\n-            s2.read(buf).unwrap();\n+            s2.read(&mut buf).unwrap();\n             tx2.send(());\n             done.send(());\n         });\n         let mut buf = [0, 0];\n-        s1.read(buf).unwrap();\n+        s1.read(&mut buf).unwrap();\n         tx1.send(());\n \n         rx.recv();\n@@ -1065,8 +1065,8 @@ mod test {\n         spawn(proc() {\n             let mut s = TcpStream::connect(addr);\n             let mut buf = [0, 1];\n-            s.read(buf).unwrap();\n-            s.read(buf).unwrap();\n+            s.read(&mut buf).unwrap();\n+            s.read(&mut buf).unwrap();\n         });\n \n         let mut s1 = acceptor.accept().unwrap();\n@@ -1075,10 +1075,10 @@ mod test {\n         let (done, rx) = channel();\n         spawn(proc() {\n             let mut s2 = s2;\n-            s2.write([1]).unwrap();\n+            s2.write(&[1]).unwrap();\n             done.send(());\n         });\n-        s1.write([2]).unwrap();\n+        s1.write(&[2]).unwrap();\n \n         rx.recv();\n     }\n@@ -1091,12 +1091,12 @@ mod test {\n             let mut a = a;\n             let mut c = a.accept().unwrap();\n             assert_eq!(c.read_to_end(), Ok(vec!()));\n-            c.write([1]).unwrap();\n+            c.write(&[1]).unwrap();\n         });\n \n         let mut s = TcpStream::connect(addr).unwrap();\n         assert!(s.inner.close_write().is_ok());\n-        assert!(s.write([1]).is_err());\n+        assert!(s.write(&[1]).is_err());\n         assert_eq!(s.read_to_end(), Ok(vec!(1)));\n     }\n \n@@ -1161,18 +1161,18 @@ mod test {\n \n         // closing should prevent reads/writes\n         s.close_write().unwrap();\n-        assert!(s.write([0]).is_err());\n+        assert!(s.write(&[0]).is_err());\n         s.close_read().unwrap();\n-        assert!(s.read(b).is_err());\n+        assert!(s.read(&mut b).is_err());\n \n         // closing should affect previous handles\n-        assert!(s2.write([0]).is_err());\n-        assert!(s2.read(b).is_err());\n+        assert!(s2.write(&[0]).is_err());\n+        assert!(s2.read(&mut b).is_err());\n \n         // closing should affect new handles\n         let mut s3 = s.clone();\n-        assert!(s3.write([0]).is_err());\n-        assert!(s3.read(b).is_err());\n+        assert!(s3.write(&[0]).is_err());\n+        assert!(s3.read(&mut b).is_err());\n \n         // make sure these don't die\n         let _ = s2.close_read();\n@@ -1197,7 +1197,7 @@ mod test {\n         let (tx, rx) = channel();\n         spawn(proc() {\n             let mut s2 = s2;\n-            assert!(s2.read([0]).is_err());\n+            assert!(s2.read(&mut [0]).is_err());\n             tx.send(());\n         });\n         // this should wake up the child task\n@@ -1215,29 +1215,29 @@ mod test {\n         spawn(proc() {\n             let mut s = TcpStream::connect(addr).unwrap();\n             rx.recv();\n-            assert!(s.write([0]).is_ok());\n+            assert!(s.write(&[0]).is_ok());\n             let _ = rx.recv_opt();\n         });\n \n         let mut s = a.accept().unwrap();\n         s.set_timeout(Some(20));\n-        assert_eq!(s.read([0]).err().unwrap().kind, TimedOut);\n-        assert_eq!(s.read([0]).err().unwrap().kind, TimedOut);\n+        assert_eq!(s.read(&mut [0]).err().unwrap().kind, TimedOut);\n+        assert_eq!(s.read(&mut [0]).err().unwrap().kind, TimedOut);\n \n         s.set_timeout(Some(20));\n         for i in range(0i, 1001) {\n-            match s.write([0, .. 128 * 1024]) {\n+            match s.write(&[0, .. 128 * 1024]) {\n                 Ok(()) | Err(IoError { kind: ShortWrite(..), .. }) => {},\n                 Err(IoError { kind: TimedOut, .. }) => break,\n                 Err(e) => panic!(\"{}\", e),\n            }\n            if i == 1000 { panic!(\"should have filled up?!\"); }\n         }\n-        assert_eq!(s.write([0]).err().unwrap().kind, TimedOut);\n+        assert_eq!(s.write(&[0]).err().unwrap().kind, TimedOut);\n \n         tx.send(());\n         s.set_timeout(None);\n-        assert_eq!(s.read([0, 0]), Ok(1));\n+        assert_eq!(s.read(&mut [0, 0]), Ok(1));\n     }\n \n     #[test]\n@@ -1250,7 +1250,7 @@ mod test {\n             rx.recv();\n             let mut amt = 0;\n             while amt < 100 * 128 * 1024 {\n-                match s.read([0, ..128 * 1024]) {\n+                match s.read(&mut [0, ..128 * 1024]) {\n                     Ok(n) => { amt += n; }\n                     Err(e) => panic!(\"{}\", e),\n                 }\n@@ -1260,12 +1260,12 @@ mod test {\n \n         let mut s = a.accept().unwrap();\n         s.set_read_timeout(Some(20));\n-        assert_eq!(s.read([0]).err().unwrap().kind, TimedOut);\n-        assert_eq!(s.read([0]).err().unwrap().kind, TimedOut);\n+        assert_eq!(s.read(&mut [0]).err().unwrap().kind, TimedOut);\n+        assert_eq!(s.read(&mut [0]).err().unwrap().kind, TimedOut);\n \n         tx.send(());\n         for _ in range(0i, 100) {\n-            assert!(s.write([0, ..128 * 1024]).is_ok());\n+            assert!(s.write(&[0, ..128 * 1024]).is_ok());\n         }\n     }\n \n@@ -1277,24 +1277,24 @@ mod test {\n         spawn(proc() {\n             let mut s = TcpStream::connect(addr).unwrap();\n             rx.recv();\n-            assert!(s.write([0]).is_ok());\n+            assert!(s.write(&[0]).is_ok());\n             let _ = rx.recv_opt();\n         });\n \n         let mut s = a.accept().unwrap();\n         s.set_write_timeout(Some(20));\n         for i in range(0i, 1001) {\n-            match s.write([0, .. 128 * 1024]) {\n+            match s.write(&[0, .. 128 * 1024]) {\n                 Ok(()) | Err(IoError { kind: ShortWrite(..), .. }) => {},\n                 Err(IoError { kind: TimedOut, .. }) => break,\n                 Err(e) => panic!(\"{}\", e),\n            }\n            if i == 1000 { panic!(\"should have filled up?!\"); }\n         }\n-        assert_eq!(s.write([0]).err().unwrap().kind, TimedOut);\n+        assert_eq!(s.write(&[0]).err().unwrap().kind, TimedOut);\n \n         tx.send(());\n-        assert!(s.read([0]).is_ok());\n+        assert!(s.read(&mut [0]).is_ok());\n     }\n \n     #[test]\n@@ -1305,7 +1305,7 @@ mod test {\n         spawn(proc() {\n             let mut s = TcpStream::connect(addr).unwrap();\n             rx.recv();\n-            assert_eq!(s.write([0]), Ok(()));\n+            assert_eq!(s.write(&[0]), Ok(()));\n             let _ = rx.recv_opt();\n         });\n \n@@ -1314,12 +1314,12 @@ mod test {\n         let (tx2, rx2) = channel();\n         spawn(proc() {\n             let mut s2 = s2;\n-            assert_eq!(s2.read([0]), Ok(1));\n+            assert_eq!(s2.read(&mut [0]), Ok(1));\n             tx2.send(());\n         });\n \n         s.set_read_timeout(Some(20));\n-        assert_eq!(s.read([0]).err().unwrap().kind, TimedOut);\n+        assert_eq!(s.read(&mut [0]).err().unwrap().kind, TimedOut);\n         tx.send(());\n \n         rx2.recv();"}, {"sha": "567e7da0c000aa187ef954331772f0833e3eeb4b", "filename": "src/libstd/io/net/udp.rs", "status": "modified", "additions": 30, "deletions": 30, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibstd%2Fio%2Fnet%2Fudp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibstd%2Fio%2Fnet%2Fudp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Fudp.rs?ref=0047dbe59c41b951d34ce6324f3a8c0e15d523e9", "patch": "@@ -44,7 +44,7 @@ use sys::udp::UdpSocket as UdpSocketImp;\n ///     };\n ///\n ///     let mut buf = [0, ..10];\n-///     match socket.recv_from(buf) {\n+///     match socket.recv_from(&mut buf) {\n ///         Ok((amt, src)) => {\n ///             // Send a reply to the socket we received data from\n ///             let buf = buf[mut ..amt];\n@@ -266,7 +266,7 @@ mod test {\n             match UdpSocket::bind(client_ip) {\n                 Ok(ref mut client) => {\n                     rx1.recv();\n-                    client.send_to([99], server_ip).unwrap()\n+                    client.send_to(&[99], server_ip).unwrap()\n                 }\n                 Err(..) => panic!()\n             }\n@@ -277,7 +277,7 @@ mod test {\n             Ok(ref mut server) => {\n                 tx1.send(());\n                 let mut buf = [0];\n-                match server.recv_from(buf) {\n+                match server.recv_from(&mut buf) {\n                     Ok((nread, src)) => {\n                         assert_eq!(nread, 1);\n                         assert_eq!(buf[0], 99);\n@@ -301,7 +301,7 @@ mod test {\n             match UdpSocket::bind(client_ip) {\n                 Ok(ref mut client) => {\n                     rx.recv();\n-                    client.send_to([99], server_ip).unwrap()\n+                    client.send_to(&[99], server_ip).unwrap()\n                 }\n                 Err(..) => panic!()\n             }\n@@ -311,7 +311,7 @@ mod test {\n             Ok(ref mut server) => {\n                 tx.send(());\n                 let mut buf = [0];\n-                match server.recv_from(buf) {\n+                match server.recv_from(&mut buf) {\n                     Ok((nread, src)) => {\n                         assert_eq!(nread, 1);\n                         assert_eq!(buf[0], 99);\n@@ -345,8 +345,8 @@ mod test {\n                 }\n             };\n             rx1.recv();\n-            send_as(dummy_ip, [98]);\n-            send_as(client_ip, [99]);\n+            send_as(dummy_ip, &[98]);\n+            send_as(client_ip, &[99]);\n             tx2.send(());\n         });\n \n@@ -356,7 +356,7 @@ mod test {\n                 let mut stream = server.connect(client_ip);\n                 tx1.send(());\n                 let mut buf = [0];\n-                match stream.read(buf) {\n+                match stream.read(&mut buf) {\n                     Ok(nread) => {\n                         assert_eq!(nread, 1);\n                         assert_eq!(buf[0], 99);\n@@ -383,7 +383,7 @@ mod test {\n                     let client = box client;\n                     let mut stream = client.connect(server_ip);\n                     rx1.recv();\n-                    stream.write([99]).unwrap();\n+                    stream.write(&[99]).unwrap();\n                 }\n                 Err(..) => panic!()\n             }\n@@ -396,7 +396,7 @@ mod test {\n                 let mut stream = server.connect(client_ip);\n                 tx1.send(());\n                 let mut buf = [0];\n-                match stream.read(buf) {\n+                match stream.read(&mut buf) {\n                     Ok(nread) => {\n                         assert_eq!(nread, 1);\n                         assert_eq!(buf[0], 99);\n@@ -442,9 +442,9 @@ mod test {\n         spawn(proc() {\n             let mut sock2 = sock2;\n             let mut buf = [0, 0];\n-            assert_eq!(sock2.recv_from(buf), Ok((1, addr1)));\n+            assert_eq!(sock2.recv_from(&mut buf), Ok((1, addr1)));\n             assert_eq!(buf[0], 1);\n-            sock2.send_to([2], addr1).unwrap();\n+            sock2.send_to(&[2], addr1).unwrap();\n         });\n \n         let sock3 = sock1.clone();\n@@ -454,12 +454,12 @@ mod test {\n         spawn(proc() {\n             let mut sock3 = sock3;\n             rx1.recv();\n-            sock3.send_to([1], addr2).unwrap();\n+            sock3.send_to(&[1], addr2).unwrap();\n             tx2.send(());\n         });\n         tx1.send(());\n         let mut buf = [0, 0];\n-        assert_eq!(sock1.recv_from(buf), Ok((1, addr2)));\n+        assert_eq!(sock1.recv_from(&mut buf), Ok((1, addr2)));\n         rx2.recv();\n     }\n \n@@ -474,9 +474,9 @@ mod test {\n \n         spawn(proc() {\n             let mut sock2 = sock2;\n-            sock2.send_to([1], addr1).unwrap();\n+            sock2.send_to(&[1], addr1).unwrap();\n             rx.recv();\n-            sock2.send_to([2], addr1).unwrap();\n+            sock2.send_to(&[2], addr1).unwrap();\n             rx.recv();\n         });\n \n@@ -486,12 +486,12 @@ mod test {\n         spawn(proc() {\n             let mut sock3 = sock3;\n             let mut buf = [0, 0];\n-            sock3.recv_from(buf).unwrap();\n+            sock3.recv_from(&mut buf).unwrap();\n             tx2.send(());\n             done.send(());\n         });\n         let mut buf = [0, 0];\n-        sock1.recv_from(buf).unwrap();\n+        sock1.recv_from(&mut buf).unwrap();\n         tx1.send(());\n \n         rx.recv();\n@@ -512,7 +512,7 @@ mod test {\n             let mut buf = [0, 1];\n \n             rx.recv();\n-            match sock2.recv_from(buf) {\n+            match sock2.recv_from(&mut buf) {\n                 Ok(..) => {}\n                 Err(e) => panic!(\"failed receive: {}\", e),\n             }\n@@ -525,13 +525,13 @@ mod test {\n         let tx2 = tx.clone();\n         spawn(proc() {\n             let mut sock3 = sock3;\n-            match sock3.send_to([1], addr2) {\n+            match sock3.send_to(&[1], addr2) {\n                 Ok(..) => { let _ = tx2.send_opt(()); }\n                 Err(..) => {}\n             }\n             done.send(());\n         });\n-        match sock1.send_to([2], addr2) {\n+        match sock1.send_to(&[2], addr2) {\n             Ok(..) => { let _ = tx.send_opt(()); }\n             Err(..) => {}\n         }\n@@ -552,28 +552,28 @@ mod test {\n         let (tx2, rx2) = channel();\n         spawn(proc() {\n             let mut a = UdpSocket::bind(addr2).unwrap();\n-            assert_eq!(a.recv_from([0]), Ok((1, addr1)));\n-            assert_eq!(a.send_to([0], addr1), Ok(()));\n+            assert_eq!(a.recv_from(&mut [0]), Ok((1, addr1)));\n+            assert_eq!(a.send_to(&[0], addr1), Ok(()));\n             rx.recv();\n-            assert_eq!(a.send_to([0], addr1), Ok(()));\n+            assert_eq!(a.send_to(&[0], addr1), Ok(()));\n \n             tx2.send(());\n         });\n \n         // Make sure that reads time out, but writes can continue\n         a.set_read_timeout(Some(20));\n-        assert_eq!(a.recv_from([0]).err().unwrap().kind, TimedOut);\n-        assert_eq!(a.recv_from([0]).err().unwrap().kind, TimedOut);\n-        assert_eq!(a.send_to([0], addr2), Ok(()));\n+        assert_eq!(a.recv_from(&mut [0]).err().unwrap().kind, TimedOut);\n+        assert_eq!(a.recv_from(&mut [0]).err().unwrap().kind, TimedOut);\n+        assert_eq!(a.send_to(&[0], addr2), Ok(()));\n \n         // Cloned handles should be able to block\n         let mut a2 = a.clone();\n-        assert_eq!(a2.recv_from([0]), Ok((1, addr2)));\n+        assert_eq!(a2.recv_from(&mut [0]), Ok((1, addr2)));\n \n         // Clearing the timeout should allow for receiving\n         a.set_timeout(None);\n         tx.send(());\n-        assert_eq!(a2.recv_from([0]), Ok((1, addr2)));\n+        assert_eq!(a2.recv_from(&mut [0]), Ok((1, addr2)));\n \n         // Make sure the child didn't die\n         rx2.recv();\n@@ -588,7 +588,7 @@ mod test {\n \n         a.set_write_timeout(Some(1000));\n         for _ in range(0u, 100) {\n-            match a.send_to([0, ..4*1024], addr2) {\n+            match a.send_to(&[0, ..4*1024], addr2) {\n                 Ok(()) | Err(IoError { kind: ShortWrite(..), .. }) => {},\n                 Err(IoError { kind: TimedOut, .. }) => break,\n                 Err(e) => panic!(\"other error: {}\", e),"}, {"sha": "5137db305f0d39299bbc6ac03c265f00867ab71f", "filename": "src/libstd/io/pipe.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibstd%2Fio%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibstd%2Fio%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fpipe.rs?ref=0047dbe59c41b951d34ce6324f3a8c0e15d523e9", "patch": "@@ -125,12 +125,12 @@ mod test {\n         let (tx, rx) = channel();\n         spawn(proc() {\n             let mut out = out;\n-            out.write([10]).unwrap();\n+            out.write(&[10]).unwrap();\n             rx.recv(); // don't close the pipe until the other read has finished\n         });\n \n         let mut buf = [0, ..10];\n-        input.read(buf).unwrap();\n+        input.read(&mut buf).unwrap();\n         tx.send(());\n     }\n }"}, {"sha": "ec856e662e33c22c1279627d66a2a73c9a954595", "filename": "src/libstd/io/result.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibstd%2Fio%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibstd%2Fio%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fresult.rs?ref=0047dbe59c41b951d34ce6324f3a8c0e15d523e9", "patch": "@@ -85,7 +85,7 @@ mod test {\n     #[test]\n     fn test_option_writer() {\n         let mut writer: io::IoResult<MemWriter> = Ok(MemWriter::new());\n-        writer.write([0, 1, 2]).unwrap();\n+        writer.write(&[0, 1, 2]).unwrap();\n         writer.flush().unwrap();\n         assert_eq!(writer.unwrap().unwrap(), vec!(0, 1, 2));\n     }\n@@ -95,7 +95,7 @@ mod test {\n         let mut writer: io::IoResult<MemWriter> =\n             Err(io::standard_error(io::EndOfFile));\n \n-        match writer.write([0, 0, 0]) {\n+        match writer.write(&[0, 0, 0]) {\n             Ok(..) => panic!(),\n             Err(e) => assert_eq!(e.kind, io::EndOfFile),\n         }\n@@ -110,7 +110,7 @@ mod test {\n         let mut reader: io::IoResult<MemReader> =\n             Ok(MemReader::new(vec!(0, 1, 2, 3)));\n         let mut buf = [0, 0];\n-        reader.read(buf).unwrap();\n+        reader.read(&mut buf).unwrap();\n         let b: &[_] = &[0, 1];\n         assert_eq!(buf.as_slice(), b);\n     }\n@@ -121,7 +121,7 @@ mod test {\n             Err(io::standard_error(io::EndOfFile));\n         let mut buf = [];\n \n-        match reader.read(buf) {\n+        match reader.read(&mut buf) {\n             Ok(..) => panic!(),\n             Err(e) => assert_eq!(e.kind, io::EndOfFile),\n         }"}, {"sha": "00d62f389cae654fdc923f0c71fadda76640f253", "filename": "src/libstd/io/stdio.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibstd%2Fio%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibstd%2Fio%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fstdio.rs?ref=0047dbe59c41b951d34ce6324f3a8c0e15d523e9", "patch": "@@ -237,7 +237,7 @@ pub fn print(s: &str) {\n /// `\\n` character is printed to the console after the string.\n pub fn println(s: &str) {\n     with_task_stdout(|io| {\n-        io.write(s.as_bytes()).and_then(|()| io.write([b'\\n']))\n+        io.write(s.as_bytes()).and_then(|()| io.write(&[b'\\n']))\n     })\n }\n "}, {"sha": "e7598611ec8ae1201837dc79b68696abf9c4310a", "filename": "src/libstd/io/util.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibstd%2Fio%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibstd%2Fio%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Futil.rs?ref=0047dbe59c41b951d34ce6324f3a8c0e15d523e9", "patch": "@@ -225,7 +225,7 @@ impl<R: Reader, W: Writer> Reader for TeeReader<R, W> {\n pub fn copy<R: Reader, W: Writer>(r: &mut R, w: &mut W) -> io::IoResult<()> {\n     let mut buf = [0, ..super::DEFAULT_BUF_SIZE];\n     loop {\n-        let len = match r.read(buf) {\n+        let len = match r.read(&mut buf) {\n             Ok(len) => len,\n             Err(ref e) if e.kind == io::EndOfFile => return Ok(()),\n             Err(e) => return Err(e),\n@@ -352,7 +352,7 @@ mod test {\n \n         let mut multi = MultiWriter::new(vec!(box TestWriter as Box<Writer>,\n                                               box TestWriter as Box<Writer>));\n-        multi.write([1, 2, 3]).unwrap();\n+        multi.write(&[1, 2, 3]).unwrap();\n         assert_eq!(2, unsafe { writes });\n         assert_eq!(0, unsafe { flushes });\n         multi.flush().unwrap();\n@@ -413,25 +413,25 @@ mod test {\n     fn test_iter_reader() {\n         let mut r = IterReader::new(range(0u8, 8));\n         let mut buf = [0, 0, 0];\n-        let len = r.read(buf).unwrap();\n+        let len = r.read(&mut buf).unwrap();\n         assert_eq!(len, 3);\n         assert!(buf == [0, 1, 2]);\n \n-        let len = r.read(buf).unwrap();\n+        let len = r.read(&mut buf).unwrap();\n         assert_eq!(len, 3);\n         assert!(buf == [3, 4, 5]);\n \n-        let len = r.read(buf).unwrap();\n+        let len = r.read(&mut buf).unwrap();\n         assert_eq!(len, 2);\n         assert!(buf == [6, 7, 5]);\n \n-        assert_eq!(r.read(buf).unwrap_err().kind, io::EndOfFile);\n+        assert_eq!(r.read(&mut buf).unwrap_err().kind, io::EndOfFile);\n     }\n \n     #[test]\n     fn iter_reader_zero_length() {\n         let mut r = IterReader::new(range(0u8, 8));\n         let mut buf = [];\n-        assert_eq!(Ok(0), r.read(buf));\n+        assert_eq!(Ok(0), r.read(&mut buf));\n     }\n }"}, {"sha": "7b79e53520140e6dbfaab7260a10308a71c0037c", "filename": "src/libstd/num/uint_macros.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibstd%2Fnum%2Fuint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibstd%2Fnum%2Fuint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fuint_macros.rs?ref=0047dbe59c41b951d34ce6324f3a8c0e15d523e9", "patch": "@@ -38,7 +38,7 @@ pub fn to_str_bytes<U>(n: $T, radix: uint, f: |v: &[u8]| -> U) -> U {\n     // base 2 number, and then we need another for a possible '-' character.\n     let mut buf = [0u8, ..65];\n     let amt = {\n-        let mut wr = ::io::BufWriter::new(buf);\n+        let mut wr = ::io::BufWriter::new(&mut buf);\n         (write!(&mut wr, \"{}\", ::fmt::radix(n, radix as u8))).unwrap();\n         wr.tell().unwrap() as uint\n     };"}, {"sha": "d1df2ed9967d6cc04a7c5e2437f7ae38d216c027", "filename": "src/libstd/os.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=0047dbe59c41b951d34ce6324f3a8c0e15d523e9", "patch": "@@ -1936,7 +1936,7 @@ mod tests {\n     fn memory_map_rw() {\n         use result::{Ok, Err};\n \n-        let chunk = match os::MemoryMap::new(16, [\n+        let chunk = match os::MemoryMap::new(16, &[\n             os::MapReadable,\n             os::MapWritable\n         ]) {\n@@ -1983,7 +1983,7 @@ mod tests {\n             \"x\".with_c_str(|x| assert!(write(fd, x as *const c_void, 1) == 1));\n             fd\n         };\n-        let chunk = match MemoryMap::new(size / 2, [\n+        let chunk = match MemoryMap::new(size / 2, &[\n             MapReadable,\n             MapWritable,\n             MapFd(fd),\n@@ -2012,16 +2012,16 @@ mod tests {\n                 parsed.iter().map(|s| Path::new(*s)).collect()\n         }\n \n-        assert!(check_parse(\"\", [\"\"]));\n-        assert!(check_parse(r#\"\"\"\"#, [\"\"]));\n-        assert!(check_parse(\";;\", [\"\", \"\", \"\"]));\n-        assert!(check_parse(r\"c:\\\", [r\"c:\\\"]));\n-        assert!(check_parse(r\"c:\\;\", [r\"c:\\\", \"\"]));\n+        assert!(check_parse(\"\", &mut [\"\"]));\n+        assert!(check_parse(r#\"\"\"\"#, &mut [\"\"]));\n+        assert!(check_parse(\";;\", &mut [\"\", \"\", \"\"]));\n+        assert!(check_parse(r\"c:\\\", &mut [r\"c:\\\"]));\n+        assert!(check_parse(r\"c:\\;\", &mut [r\"c:\\\", \"\"]));\n         assert!(check_parse(r\"c:\\;c:\\Program Files\\\",\n-                            [r\"c:\\\", r\"c:\\Program Files\\\"]));\n-        assert!(check_parse(r#\"c:\\;c:\\\"foo\"\\\"#, [r\"c:\\\", r\"c:\\foo\\\"]));\n+                            &mut [r\"c:\\\", r\"c:\\Program Files\\\"]));\n+        assert!(check_parse(r#\"c:\\;c:\\\"foo\"\\\"#, &mut [r\"c:\\\", r\"c:\\foo\\\"]));\n         assert!(check_parse(r#\"c:\\;c:\\\"foo;bar\"\\;c:\\baz\"#,\n-                            [r\"c:\\\", r\"c:\\foo;bar\\\", r\"c:\\baz\"]));\n+                            &mut [r\"c:\\\", r\"c:\\foo;bar\\\", r\"c:\\baz\"]));\n     }\n \n     #[test]\n@@ -2032,11 +2032,11 @@ mod tests {\n                 parsed.iter().map(|s| Path::new(*s)).collect()\n         }\n \n-        assert!(check_parse(\"\", [\"\"]));\n-        assert!(check_parse(\"::\", [\"\", \"\", \"\"]));\n-        assert!(check_parse(\"/\", [\"/\"]));\n-        assert!(check_parse(\"/:\", [\"/\", \"\"]));\n-        assert!(check_parse(\"/:/usr/local\", [\"/\", \"/usr/local\"]));\n+        assert!(check_parse(\"\", &mut [\"\"]));\n+        assert!(check_parse(\"::\", &mut [\"\", \"\", \"\"]));\n+        assert!(check_parse(\"/\", &mut [\"/\"]));\n+        assert!(check_parse(\"/:\", &mut [\"/\", \"\"]));\n+        assert!(check_parse(\"/:/usr/local\", &mut [\"/\", \"/usr/local\"]));\n     }\n \n     #[test]\n@@ -2046,12 +2046,12 @@ mod tests {\n             join_paths(input).unwrap().as_slice() == output.as_bytes()\n         }\n \n-        assert!(test_eq([], \"\"));\n-        assert!(test_eq([\"/bin\", \"/usr/bin\", \"/usr/local/bin\"],\n-                        \"/bin:/usr/bin:/usr/local/bin\"));\n-        assert!(test_eq([\"\", \"/bin\", \"\", \"\", \"/usr/bin\", \"\"],\n-                        \":/bin:::/usr/bin:\"));\n-        assert!(join_paths([\"/te:st\"]).is_err());\n+        assert!(test_eq(&[], \"\"));\n+        assert!(test_eq(&[\"/bin\", \"/usr/bin\", \"/usr/local/bin\"],\n+                         \"/bin:/usr/bin:/usr/local/bin\"));\n+        assert!(test_eq(&[\"\", \"/bin\", \"\", \"\", \"/usr/bin\", \"\"],\n+                         \":/bin:::/usr/bin:\"));\n+        assert!(join_paths(&[\"/te:st\"]).is_err());\n     }\n \n     #[test]\n@@ -2068,7 +2068,7 @@ mod tests {\n                         r\";c:\\windows;;;c:\\;\"));\n         assert!(test_eq([r\"c:\\te;st\", r\"c:\\\"],\n                         r#\"\"c:\\te;st\";c:\\\"#));\n-        assert!(join_paths([r#\"c:\\te\"st\"#]).is_err());\n+        assert!(join_paths(&[r#\"c:\\te\"st\"#]).is_err());\n     }\n \n     // More recursive_mkdir tests are in extra::tempfile"}, {"sha": "3e013ba20c462ad5d65c5151431b2e95754de914", "filename": "src/libstd/path/posix.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibstd%2Fpath%2Fposix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibstd%2Fpath%2Fposix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fposix.rs?ref=0047dbe59c41b951d34ce6324f3a8c0e15d523e9", "patch": "@@ -462,7 +462,7 @@ mod tests {\n \n     #[test]\n     fn test_paths() {\n-        let empty: &[u8] = [];\n+        let empty: &[u8] = &[];\n         t!(v: Path::new(empty), b\".\");\n         t!(v: Path::new(b\"/\"), b\"/\");\n         t!(v: Path::new(b\"a/b/c\"), b\"a/b/c\");\n@@ -731,14 +731,14 @@ mod tests {\n             (s: $path:expr, $push:expr, $exp:expr) => (\n                 {\n                     let mut p = Path::new($path);\n-                    p.push_many($push);\n+                    p.push_many(&$push);\n                     assert!(p.as_str() == Some($exp));\n                 }\n             );\n             (v: $path:expr, $push:expr, $exp:expr) => (\n                 {\n                     let mut p = Path::new($path);\n-                    p.push_many($push);\n+                    p.push_many(&$push);\n                     assert!(p.as_vec() == $exp);\n                 }\n             )\n@@ -836,14 +836,14 @@ mod tests {\n             (s: $path:expr, $join:expr, $exp:expr) => (\n                 {\n                     let path = Path::new($path);\n-                    let res = path.join_many($join);\n+                    let res = path.join_many(&$join);\n                     assert!(res.as_str() == Some($exp));\n                 }\n             );\n             (v: $path:expr, $join:expr, $exp:expr) => (\n                 {\n                     let path = Path::new($path);\n-                    let res = path.join_many($join);\n+                    let res = path.join_many(&$join);\n                     assert!(res.as_vec() == $exp);\n                 }\n             )\n@@ -859,7 +859,7 @@ mod tests {\n \n     #[test]\n     fn test_with_helpers() {\n-        let empty: &[u8] = [];\n+        let empty: &[u8] = &[];\n \n         t!(v: Path::new(b\"a/b/c\").with_filename(b\"d\"), b\"a/b/d\");\n         t!(v: Path::new(b\"a/b/c\\xFF\").with_filename(b\"\\x80\"), b\"a/b/\\x80\");\n@@ -1173,7 +1173,7 @@ mod tests {\n                 {\n                     let path = Path::new($path);\n                     let comps = path.components().collect::<Vec<&[u8]>>();\n-                    let exp: &[&str] = $exp;\n+                    let exp: &[&str] = &$exp;\n                     let exps = exp.iter().map(|x| x.as_bytes()).collect::<Vec<&[u8]>>();\n                     assert!(comps == exps, \"components: Expected {}, found {}\",\n                             comps, exps);\n@@ -1187,7 +1187,7 @@ mod tests {\n                 {\n                     let path = Path::new($arg);\n                     let comps = path.components().collect::<Vec<&[u8]>>();\n-                    let exp: &[&[u8]] = [$($exp),*];\n+                    let exp: &[&[u8]] = &[$($exp),*];\n                     assert_eq!(comps.as_slice(), exp);\n                     let comps = path.components().rev().collect::<Vec<&[u8]>>();\n                     let exp = exp.iter().rev().map(|&x|x).collect::<Vec<&[u8]>>();\n@@ -1219,7 +1219,7 @@ mod tests {\n                 {\n                     let path = Path::new($arg);\n                     let comps = path.str_components().collect::<Vec<Option<&str>>>();\n-                    let exp: &[Option<&str>] = $exp;\n+                    let exp: &[Option<&str>] = &$exp;\n                     assert_eq!(comps.as_slice(), exp);\n                     let comps = path.str_components().rev().collect::<Vec<Option<&str>>>();\n                     let exp = exp.iter().rev().map(|&x|x).collect::<Vec<Option<&str>>>();"}, {"sha": "a053f57bf127570b7a0185101b81ebb720dcf602", "filename": "src/libstd/path/windows.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibstd%2Fpath%2Fwindows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibstd%2Fpath%2Fwindows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fwindows.rs?ref=0047dbe59c41b951d34ce6324f3a8c0e15d523e9", "patch": "@@ -1195,7 +1195,7 @@ mod tests {\n \n     #[test]\n     fn test_paths() {\n-        let empty: &[u8] = [];\n+        let empty: &[u8] = &[];\n         t!(v: Path::new(empty), b\".\");\n         t!(v: Path::new(b\"\\\\\"), b\"\\\\\");\n         t!(v: Path::new(b\"a\\\\b\\\\c\"), b\"a\\\\b\\\\c\");\n@@ -1571,14 +1571,14 @@ mod tests {\n             (s: $path:expr, $push:expr, $exp:expr) => (\n                 {\n                     let mut p = Path::new($path);\n-                    p.push_many($push);\n+                    p.push_many(&$push);\n                     assert_eq!(p.as_str(), Some($exp));\n                 }\n             );\n             (v: $path:expr, $push:expr, $exp:expr) => (\n                 {\n                     let mut p = Path::new($path);\n-                    p.push_many($push);\n+                    p.push_many(&$push);\n                     assert_eq!(p.as_vec(), $exp);\n                 }\n             )\n@@ -1712,14 +1712,14 @@ mod tests {\n             (s: $path:expr, $join:expr, $exp:expr) => (\n                 {\n                     let path = Path::new($path);\n-                    let res = path.join_many($join);\n+                    let res = path.join_many(&$join);\n                     assert_eq!(res.as_str(), Some($exp));\n                 }\n             );\n             (v: $path:expr, $join:expr, $exp:expr) => (\n                 {\n                     let path = Path::new($path);\n-                    let res = path.join_many($join);\n+                    let res = path.join_many(&$join);\n                     assert_eq!(res.as_vec(), $exp);\n                 }\n             )\n@@ -2252,7 +2252,7 @@ mod tests {\n                     let path = Path::new($path);\n                     let comps = path.str_components().map(|x|x.unwrap())\n                                 .collect::<Vec<&str>>();\n-                    let exp: &[&str] = $exp;\n+                    let exp: &[&str] = &$exp;\n                     assert_eq!(comps.as_slice(), exp);\n                     let comps = path.str_components().rev().map(|x|x.unwrap())\n                                 .collect::<Vec<&str>>();\n@@ -2309,7 +2309,7 @@ mod tests {\n                 {\n                     let path = Path::new($path);\n                     let comps = path.components().collect::<Vec<&[u8]>>();\n-                    let exp: &[&[u8]] = $exp;\n+                    let exp: &[&[u8]] = &$exp;\n                     assert_eq!(comps.as_slice(), exp);\n                     let comps = path.components().rev().collect::<Vec<&[u8]>>();\n                     let exp = exp.iter().rev().map(|&x|x).collect::<Vec<&[u8]>>();"}, {"sha": "08eb7350bcf385c6618947cc26e57eb41b5c0ba7", "filename": "src/libstd/rand/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibstd%2Frand%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibstd%2Frand%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fmod.rs?ref=0047dbe59c41b951d34ce6324f3a8c0e15d523e9", "patch": "@@ -522,7 +522,7 @@ mod test {\n     #[test]\n     fn test_choose() {\n         let mut r = task_rng();\n-        assert_eq!(r.choose([1i, 1, 1]).map(|&x|x), Some(1));\n+        assert_eq!(r.choose(&[1i, 1, 1]).map(|&x|x), Some(1));\n \n         let v: &[int] = &[];\n         assert_eq!(r.choose(v), None);\n@@ -534,16 +534,16 @@ mod test {\n         let empty: &mut [int] = &mut [];\n         r.shuffle(empty);\n         let mut one = [1i];\n-        r.shuffle(one);\n+        r.shuffle(&mut one);\n         let b: &[_] = &[1];\n         assert_eq!(one.as_slice(), b);\n \n         let mut two = [1i, 2];\n-        r.shuffle(two);\n+        r.shuffle(&mut two);\n         assert!(two == [1, 2] || two == [2, 1]);\n \n         let mut x = [1i, 1, 1];\n-        r.shuffle(x);\n+        r.shuffle(&mut x);\n         let b: &[_] = &[1, 1, 1];\n         assert_eq!(x.as_slice(), b);\n     }\n@@ -553,7 +553,7 @@ mod test {\n         let mut r = task_rng();\n         r.gen::<int>();\n         let mut v = [1i, 1, 1];\n-        r.shuffle(v);\n+        r.shuffle(&mut v);\n         let b: &[_] = &[1, 1, 1];\n         assert_eq!(v.as_slice(), b);\n         assert_eq!(r.gen_range(0u, 1u), 0u);\n@@ -673,7 +673,7 @@ mod bench {\n     #[bench]\n     fn rand_shuffle_100(b: &mut Bencher) {\n         let mut rng = weak_rng();\n-        let x : &mut[uint] = [1,..100];\n+        let x : &mut[uint] = &mut [1,..100];\n         b.iter(|| {\n             rng.shuffle(x);\n         })"}, {"sha": "83ea57e5538959ef01f744bbb8cb0758d9d0ddf5", "filename": "src/libstd/rand/os.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibstd%2Frand%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibstd%2Frand%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fos.rs?ref=0047dbe59c41b951d34ce6324f3a8c0e15d523e9", "patch": "@@ -343,7 +343,7 @@ mod test {\n         r.next_u64();\n \n         let mut v = [0u8, .. 1000];\n-        r.fill_bytes(v);\n+        r.fill_bytes(&mut v);\n     }\n \n     #[test]\n@@ -368,7 +368,7 @@ mod test {\n                     task::deschedule();\n                     r.next_u64();\n                     task::deschedule();\n-                    r.fill_bytes(v);\n+                    r.fill_bytes(&mut v);\n                     task::deschedule();\n                 }\n             })"}, {"sha": "796bf7853f73bbb3d2b95f8ea1883a25f8f8d7ff", "filename": "src/libstd/rand/reader.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibstd%2Frand%2Freader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibstd%2Frand%2Freader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Freader.rs?ref=0047dbe59c41b951d34ce6324f3a8c0e15d523e9", "patch": "@@ -108,7 +108,7 @@ mod test {\n         let mut w = [0u8, .. 8];\n \n         let mut rng = ReaderRng::new(MemReader::new(v.as_slice().to_vec()));\n-        rng.fill_bytes(w);\n+        rng.fill_bytes(&mut w);\n \n         assert!(v == w);\n     }\n@@ -118,6 +118,6 @@ mod test {\n     fn test_reader_rng_insufficient_bytes() {\n         let mut rng = ReaderRng::new(MemReader::new(vec!()));\n         let mut v = [0u8, .. 3];\n-        rng.fill_bytes(v);\n+        rng.fill_bytes(&mut v);\n     }\n }"}, {"sha": "59a10f79d93c3c10915ca629d741a294b30c526d", "filename": "src/libstd/rt/backtrace.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibstd%2Frt%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibstd%2Frt%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fbacktrace.rs?ref=0047dbe59c41b951d34ce6324f3a8c0e15d523e9", "patch": "@@ -527,7 +527,7 @@ mod imp {\n             Some(string) => try!(super::demangle(w, string)),\n             None => try!(write!(w, \"<unknown>\")),\n         }\n-        w.write(['\\n' as u8])\n+        w.write(&['\\n' as u8])\n     }\n \n     /// Unwind library interface used for backtraces"}, {"sha": "fc3a8230c4c789b3edd5676bdaa02a7abe13f7b8", "filename": "src/libstd/sys/common/net.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibstd%2Fsys%2Fcommon%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibstd%2Fsys%2Fcommon%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fnet.rs?ref=0047dbe59c41b951d34ce6324f3a8c0e15d523e9", "patch": "@@ -359,7 +359,7 @@ pub fn read<T>(fd: sock_t,\n             // With a timeout, first we wait for the socket to become\n             // readable using select(), specifying the relevant timeout for\n             // our previously set deadline.\n-            try!(await([fd], deadline, Readable));\n+            try!(await(&[fd], deadline, Readable));\n \n             // At this point, we're still within the timeout, and we've\n             // determined that the socket is readable (as returned by\n@@ -411,7 +411,7 @@ pub fn write<T>(fd: sock_t,\n         while written < buf.len() && (write_everything || written == 0) {\n             // As with read(), first wait for the socket to be ready for\n             // the I/O operation.\n-            match await([fd], deadline, Writable) {\n+            match await(&[fd], deadline, Writable) {\n                 Err(ref e) if e.kind == io::EndOfFile && written > 0 => {\n                     assert!(deadline.is_some());\n                     return Err(short_write(written, \"short write\"))"}, {"sha": "816876b5e4ad900d7346ad35a4ee5a58df665d72", "filename": "src/libstd/sys/unix/fs.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibstd%2Fsys%2Funix%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibstd%2Fsys%2Funix%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ffs.rs?ref=0047dbe59c41b951d34ce6324f3a8c0e15d523e9", "patch": "@@ -376,7 +376,7 @@ mod tests {\n \n         writer.write(b\"test\").ok().unwrap();\n         let mut buf = [0u8, ..4];\n-        match reader.read(buf) {\n+        match reader.read(&mut buf) {\n             Ok(4) => {\n                 assert_eq!(buf[0], 't' as u8);\n                 assert_eq!(buf[1], 'e' as u8);\n@@ -386,7 +386,7 @@ mod tests {\n             r => panic!(\"invalid read: {}\", r),\n         }\n \n-        assert!(writer.read(buf).is_err());\n-        assert!(reader.write(buf).is_err());\n+        assert!(writer.read(&mut buf).is_err());\n+        assert!(reader.write(&buf).is_err());\n     }\n }"}, {"sha": "ed9bd0a239f11b30056db8ad240ce397a2f5c740", "filename": "src/libstd/sys/unix/helper_signal.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibstd%2Fsys%2Funix%2Fhelper_signal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibstd%2Fsys%2Funix%2Fhelper_signal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fhelper_signal.rs?ref=0047dbe59c41b951d34ce6324f3a8c0e15d523e9", "patch": "@@ -21,7 +21,7 @@ pub fn new() -> (signal, signal) {\n }\n \n pub fn signal(fd: libc::c_int) {\n-    FileDesc::new(fd, false).write([0]).ok().unwrap();\n+    FileDesc::new(fd, false).write(&[0]).ok().unwrap();\n }\n \n pub fn close(fd: libc::c_int) {"}, {"sha": "3fba06e0c7f1c4f6c159c9bbd1e0c062127075d4", "filename": "src/libstd/sys/unix/pipe.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibstd%2Fsys%2Funix%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibstd%2Fsys%2Funix%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fpipe.rs?ref=0047dbe59c41b951d34ce6324f3a8c0e15d523e9", "patch": "@@ -281,8 +281,8 @@ impl UnixAcceptor {\n                     fd => return Ok(UnixStream::new(Arc::new(Inner::new(fd)))),\n                 }\n             }\n-            try!(await([self.fd(), self.inner.reader.fd()],\n-                             deadline, Readable));\n+            try!(await(&[self.fd(), self.inner.reader.fd()],\n+                       deadline, Readable));\n         }\n \n         Err(eof())\n@@ -295,7 +295,7 @@ impl UnixAcceptor {\n     pub fn close_accept(&mut self) -> IoResult<()> {\n         self.inner.closed.store(true, atomic::SeqCst);\n         let fd = FileDesc::new(self.inner.writer.fd(), false);\n-        match fd.write([0]) {\n+        match fd.write(&[0]) {\n             Ok(..) => Ok(()),\n             Err(..) if wouldblock() => Ok(()),\n             Err(e) => Err(e),"}, {"sha": "d7de841f95836c20b4c1db0a316a7c4e570931ea", "filename": "src/libstd/sys/unix/process.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibstd%2Fsys%2Funix%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibstd%2Fsys%2Funix%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fprocess.rs?ref=0047dbe59c41b951d34ce6324f3a8c0e15d523e9", "patch": "@@ -107,7 +107,7 @@ impl Process {\n                 } else if pid > 0 {\n                     drop(output);\n                     let mut bytes = [0, ..4];\n-                    return match input.read(bytes) {\n+                    return match input.read(&mut bytes) {\n                         Ok(4) => {\n                             let errno = (bytes[0] as i32 << 24) |\n                                         (bytes[1] as i32 << 16) |\n@@ -160,7 +160,7 @@ impl Process {\n                         (errno >>  8) as u8,\n                         (errno >>  0) as u8,\n                     ];\n-                    assert!(output.write(bytes).is_ok());\n+                    assert!(output.write(&bytes).is_ok());\n                     unsafe { libc::_exit(1) }\n                 }\n "}, {"sha": "00643ac0a79f259be77f10f9ca0bb66a04bdd985", "filename": "src/libstd/sys/unix/tcp.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibstd%2Fsys%2Funix%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibstd%2Fsys%2Funix%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ftcp.rs?ref=0047dbe59c41b951d34ce6324f3a8c0e15d523e9", "patch": "@@ -121,8 +121,8 @@ impl TcpAcceptor {\n                 -1 => return Err(last_net_error()),\n                 fd => return Ok(TcpStream::new(fd as sock_t)),\n             }\n-            try!(await([self.fd(), self.inner.reader.fd()],\n-                             deadline, Readable));\n+            try!(await(&[self.fd(), self.inner.reader.fd()],\n+                       deadline, Readable));\n         }\n \n         Err(sys_common::eof())\n@@ -139,7 +139,7 @@ impl TcpAcceptor {\n     pub fn close_accept(&mut self) -> IoResult<()> {\n         self.inner.closed.store(true, atomic::SeqCst);\n         let fd = FileDesc::new(self.inner.writer.fd(), false);\n-        match fd.write([0]) {\n+        match fd.write(&[0]) {\n             Ok(..) => Ok(()),\n             Err(..) if wouldblock() => Ok(()),\n             Err(e) => Err(e),"}, {"sha": "184ef3adce1b62a261072fc2ec7d2f2445e6a9c7", "filename": "src/libstd/sys/unix/timer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibstd%2Fsys%2Funix%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibstd%2Fsys%2Funix%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ftimer.rs?ref=0047dbe59c41b951d34ce6324f3a8c0e15d523e9", "patch": "@@ -193,7 +193,7 @@ fn helper(input: libc::c_int, messages: Receiver<Req>, _: ()) {\n \n                 // drain the file descriptor\n                 let mut buf = [0];\n-                assert_eq!(fd.read(buf).ok().unwrap(), 1);\n+                assert_eq!(fd.read(&mut buf).ok().unwrap(), 1);\n             }\n \n             -1 if os::errno() == libc::EINTR as uint => {}"}, {"sha": "9e4dbf930dbae22f0cad477775d40aeee1924f61", "filename": "src/libsyntax/ext/deriving/decodable.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs?ref=0047dbe59c41b951d34ce6324f3a8c0e15d523e9", "patch": "@@ -136,6 +136,7 @@ fn decodable_substructure(cx: &mut ExtCtxt, trait_span: Span,\n                                                   cx.expr_ident(trait_span, variant), arms));\n             let lambda = cx.lambda_expr(trait_span, vec!(blkarg, variant), result);\n             let variant_vec = cx.expr_vec(trait_span, variants);\n+            let variant_vec = cx.expr_addr_of(trait_span, variant_vec);\n             let result = cx.expr_method_call(trait_span, blkdecoder,\n                                              cx.ident_of(\"read_enum_variant\"),\n                                              vec!(variant_vec, lambda));"}, {"sha": "d4248a2c77d90ba93ad721096b75b2da2488a46f", "filename": "src/libsyntax/ext/format.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibsyntax%2Fext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibsyntax%2Fext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fformat.rs?ref=0047dbe59c41b951d34ce6324f3a8c0e15d523e9", "patch": "@@ -14,7 +14,7 @@ use ext::base::*;\n use ext::base;\n use ext::build::AstBuilder;\n use fmt_macros as parse;\n-use parse::token::InternedString;\n+use parse::token::{InternedString, special_idents};\n use parse::token;\n use ptr::P;\n \n@@ -476,12 +476,11 @@ impl<'a, 'b> Context<'a, 'b> {\n                          pieces: Vec<P<ast::Expr>>)\n                          -> P<ast::Stmt> {\n         let fmtsp = piece_ty.span;\n-        let pieces_len = ecx.expr_uint(fmtsp, pieces.len());\n         let fmt = ecx.expr_vec(fmtsp, pieces);\n-        let ty = ast::TyFixedLengthVec(\n-            piece_ty,\n-            pieces_len\n-        );\n+        let fmt = ecx.expr_addr_of(fmtsp, fmt);\n+        let ty = ast::TyVec(piece_ty);\n+        let ty = ast::TyRptr(Some(ecx.lifetime(fmtsp, special_idents::static_lifetime.name)),\n+                             ast::MutTy{ mutbl: ast::MutImmutable, ty: ecx.ty(fmtsp, ty) });\n         let ty = ecx.ty(fmtsp, ty);\n         let st = ast::ItemStatic(ty, ast::MutImmutable, fmt);\n         let item = ecx.item(fmtsp, name, Context::static_attrs(ecx, fmtsp), st);"}, {"sha": "08ada3e4435903a8990e0432cd94c40d45b97b27", "filename": "src/libsyntax/util/interner.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibsyntax%2Futil%2Finterner.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibsyntax%2Futil%2Finterner.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Finterner.rs?ref=0047dbe59c41b951d34ce6324f3a8c0e15d523e9", "patch": "@@ -247,7 +247,7 @@ mod tests {\n \n     #[test]\n     fn i3 () {\n-        let i : Interner<RcStr> = Interner::prefill([\n+        let i : Interner<RcStr> = Interner::prefill(&[\n             RcStr::new(\"Alan\"),\n             RcStr::new(\"Bob\"),\n             RcStr::new(\"Carol\")"}, {"sha": "0b5092a64d0f33294f154f16a6426a0b09c1e5cf", "filename": "src/libterm/terminfo/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibterm%2Fterminfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibterm%2Fterminfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fterminfo%2Fmod.rs?ref=0047dbe59c41b951d34ce6324f3a8c0e15d523e9", "patch": "@@ -81,7 +81,7 @@ impl<T: Writer+Send> Terminal<T> for TerminfoTerminal<T> {\n                                .find_equiv(\"setaf\")\n                                .unwrap()\n                                .as_slice(),\n-                           [Number(color as int)], &mut Variables::new());\n+                           &[Number(color as int)], &mut Variables::new());\n             if s.is_ok() {\n                 try!(self.out.write(s.unwrap().as_slice()));\n                 return Ok(true)\n@@ -98,7 +98,7 @@ impl<T: Writer+Send> Terminal<T> for TerminfoTerminal<T> {\n                                .find_equiv(\"setab\")\n                                .unwrap()\n                                .as_slice(),\n-                           [Number(color as int)], &mut Variables::new());\n+                           &[Number(color as int)], &mut Variables::new());\n             if s.is_ok() {\n                 try!(self.out.write(s.unwrap().as_slice()));\n                 return Ok(true)\n@@ -116,7 +116,7 @@ impl<T: Writer+Send> Terminal<T> for TerminfoTerminal<T> {\n                 let parm = self.ti.strings.find_equiv(cap);\n                 if parm.is_some() {\n                     let s = expand(parm.unwrap().as_slice(),\n-                                   [],\n+                                   &[],\n                                    &mut Variables::new());\n                     if s.is_ok() {\n                         try!(self.out.write(s.unwrap().as_slice()));\n@@ -151,7 +151,7 @@ impl<T: Writer+Send> Terminal<T> for TerminfoTerminal<T> {\n             }\n         }\n         let s = cap.map_or(Err(\"can't find terminfo capability `sgr0`\".to_string()), |op| {\n-            expand(op.as_slice(), [], &mut Variables::new())\n+            expand(op.as_slice(), &[], &mut Variables::new())\n         });\n         if s.is_ok() {\n             return self.out.write(s.unwrap().as_slice())"}, {"sha": "b492a5321ce070602ecdd70e902734b12f9fc7e5", "filename": "src/libterm/terminfo/parm.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibterm%2Fterminfo%2Fparm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibterm%2Fterminfo%2Fparm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fterminfo%2Fparm.rs?ref=0047dbe59c41b951d34ce6324f3a8c0e15d523e9", "patch": "@@ -581,23 +581,23 @@ mod test {\n     #[test]\n     fn test_basic_setabf() {\n         let s = b\"\\\\E[48;5;%p1%dm\";\n-        assert_eq!(expand(s, [Number(1)], &mut Variables::new()).unwrap(),\n+        assert_eq!(expand(s, &[Number(1)], &mut Variables::new()).unwrap(),\n                    \"\\\\E[48;5;1m\".bytes().collect());\n     }\n \n     #[test]\n     fn test_multiple_int_constants() {\n-        assert_eq!(expand(b\"%{1}%{2}%d%d\", [], &mut Variables::new()).unwrap(),\n+        assert_eq!(expand(b\"%{1}%{2}%d%d\", &[], &mut Variables::new()).unwrap(),\n                    \"21\".bytes().collect());\n     }\n \n     #[test]\n     fn test_op_i() {\n         let mut vars = Variables::new();\n         assert_eq!(expand(b\"%p1%d%p2%d%p3%d%i%p1%d%p2%d%p3%d\",\n-                          [Number(1),Number(2),Number(3)], &mut vars),\n+                          &[Number(1),Number(2),Number(3)], &mut vars),\n                    Ok(\"123233\".bytes().collect()));\n-        assert_eq!(expand(b\"%p1%d%p2%d%i%p1%d%p2%d\", [], &mut vars),\n+        assert_eq!(expand(b\"%p1%d%p2%d%i%p1%d%p2%d\", &[], &mut vars),\n                    Ok(\"0011\".bytes().collect()));\n     }\n \n@@ -615,51 +615,51 @@ mod test {\n \n         let caps = [\"%d\", \"%c\", \"%s\", \"%Pa\", \"%l\", \"%!\", \"%~\"];\n         for &cap in caps.iter() {\n-            let res = get_res(\"\", cap, [], vars);\n+            let res = get_res(\"\", cap, &[], vars);\n             assert!(res.is_err(),\n                     \"Op {} succeeded incorrectly with 0 stack entries\", cap);\n             let p = if cap == \"%s\" || cap == \"%l\" {\n                 Words(\"foo\".to_string())\n             } else {\n                 Number(97)\n             };\n-            let res = get_res(\"%p1\", cap, [p], vars);\n+            let res = get_res(\"%p1\", cap, &[p], vars);\n             assert!(res.is_ok(),\n                     \"Op {} failed with 1 stack entry: {}\", cap, res.unwrap_err());\n         }\n         let caps = [\"%+\", \"%-\", \"%*\", \"%/\", \"%m\", \"%&\", \"%|\", \"%A\", \"%O\"];\n         for &cap in caps.iter() {\n-            let res = expand(cap.as_bytes(), [], vars);\n+            let res = expand(cap.as_bytes(), &[], vars);\n             assert!(res.is_err(),\n                     \"Binop {} succeeded incorrectly with 0 stack entries\", cap);\n-            let res = get_res(\"%{1}\", cap, [], vars);\n+            let res = get_res(\"%{1}\", cap, &[], vars);\n             assert!(res.is_err(),\n                     \"Binop {} succeeded incorrectly with 1 stack entry\", cap);\n-            let res = get_res(\"%{1}%{2}\", cap, [], vars);\n+            let res = get_res(\"%{1}%{2}\", cap, &[], vars);\n             assert!(res.is_ok(),\n                     \"Binop {} failed with 2 stack entries: {}\", cap, res.unwrap_err());\n         }\n     }\n \n     #[test]\n     fn test_push_bad_param() {\n-        assert!(expand(b\"%pa\", [], &mut Variables::new()).is_err());\n+        assert!(expand(b\"%pa\", &[], &mut Variables::new()).is_err());\n     }\n \n     #[test]\n     fn test_comparison_ops() {\n         let v = [('<', [1u8, 0u8, 0u8]), ('=', [0u8, 1u8, 0u8]), ('>', [0u8, 0u8, 1u8])];\n         for &(op, bs) in v.iter() {\n             let s = format!(\"%{{1}}%{{2}}%{}%d\", op);\n-            let res = expand(s.as_bytes(), [], &mut Variables::new());\n+            let res = expand(s.as_bytes(), &[], &mut Variables::new());\n             assert!(res.is_ok(), res.unwrap_err());\n             assert_eq!(res.unwrap(), vec!(b'0' + bs[0]));\n             let s = format!(\"%{{1}}%{{1}}%{}%d\", op);\n-            let res = expand(s.as_bytes(), [], &mut Variables::new());\n+            let res = expand(s.as_bytes(), &[], &mut Variables::new());\n             assert!(res.is_ok(), res.unwrap_err());\n             assert_eq!(res.unwrap(), vec!(b'0' + bs[1]));\n             let s = format!(\"%{{2}}%{{1}}%{}%d\", op);\n-            let res = expand(s.as_bytes(), [], &mut Variables::new());\n+            let res = expand(s.as_bytes(), &[], &mut Variables::new());\n             assert!(res.is_ok(), res.unwrap_err());\n             assert_eq!(res.unwrap(), vec!(b'0' + bs[2]));\n         }\n@@ -669,15 +669,15 @@ mod test {\n     fn test_conditionals() {\n         let mut vars = Variables::new();\n         let s = b\"\\\\E[%?%p1%{8}%<%t3%p1%d%e%p1%{16}%<%t9%p1%{8}%-%d%e38;5;%p1%d%;m\";\n-        let res = expand(s, [Number(1)], &mut vars);\n+        let res = expand(s, &[Number(1)], &mut vars);\n         assert!(res.is_ok(), res.unwrap_err());\n         assert_eq!(res.unwrap(),\n                    \"\\\\E[31m\".bytes().collect());\n-        let res = expand(s, [Number(8)], &mut vars);\n+        let res = expand(s, &[Number(8)], &mut vars);\n         assert!(res.is_ok(), res.unwrap_err());\n         assert_eq!(res.unwrap(),\n                    \"\\\\E[90m\".bytes().collect());\n-        let res = expand(s, [Number(42)], &mut vars);\n+        let res = expand(s, &[Number(42)], &mut vars);\n         assert!(res.is_ok(), res.unwrap_err());\n         assert_eq!(res.unwrap(),\n                    \"\\\\E[38;5;42m\".bytes().collect());\n@@ -688,17 +688,17 @@ mod test {\n         let mut varstruct = Variables::new();\n         let vars = &mut varstruct;\n         assert_eq!(expand(b\"%p1%s%p2%2s%p3%2s%p4%.2s\",\n-                          [Words(\"foo\".to_string()),\n-                           Words(\"foo\".to_string()),\n-                           Words(\"f\".to_string()),\n-                           Words(\"foo\".to_string())], vars),\n+                          &[Words(\"foo\".to_string()),\n+                            Words(\"foo\".to_string()),\n+                            Words(\"f\".to_string()),\n+                            Words(\"foo\".to_string())], vars),\n                    Ok(\"foofoo ffo\".bytes().collect()));\n-        assert_eq!(expand(b\"%p1%:-4.2s\", [Words(\"foo\".to_string())], vars),\n+        assert_eq!(expand(b\"%p1%:-4.2s\", &[Words(\"foo\".to_string())], vars),\n                    Ok(\"fo  \".bytes().collect()));\n \n-        assert_eq!(expand(b\"%p1%d%p1%.3d%p1%5d%p1%:+d\", [Number(1)], vars),\n+        assert_eq!(expand(b\"%p1%d%p1%.3d%p1%5d%p1%:+d\", &[Number(1)], vars),\n                    Ok(\"1001    1+1\".bytes().collect()));\n-        assert_eq!(expand(b\"%p1%o%p1%#o%p2%6.4x%p2%#6.4X\", [Number(15), Number(27)], vars),\n+        assert_eq!(expand(b\"%p1%o%p1%#o%p2%6.4x%p2%#6.4X\", &[Number(15), Number(27)], vars),\n                    Ok(\"17017  001b0X001B\".bytes().collect()));\n     }\n }"}, {"sha": "94e234291af98fd664b362cdba4e8d505185c9bb", "filename": "src/libterm/terminfo/searcher.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibterm%2Fterminfo%2Fsearcher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibterm%2Fterminfo%2Fsearcher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fterminfo%2Fsearcher.rs?ref=0047dbe59c41b951d34ce6324f3a8c0e15d523e9", "patch": "@@ -61,13 +61,13 @@ pub fn get_dbpath_for_term(term: &str) -> Option<Box<Path>> {\n     for p in dirs_to_search.iter() {\n         if p.exists() {\n             let f = first_char.to_string();\n-            let newp = p.join_many([f.as_slice(), term]);\n+            let newp = p.join_many(&[f.as_slice(), term]);\n             if newp.exists() {\n                 return Some(box newp);\n             }\n             // on some installations the dir is named after the hex of the char (e.g. OS X)\n             let f = format!(\"{:x}\", first_char as uint);\n-            let newp = p.join_many([f.as_slice(), term]);\n+            let newp = p.join_many(&[f.as_slice(), term]);\n             if newp.exists() {\n                 return Some(box newp);\n             }"}, {"sha": "aa4934fa87a5930b14217670a6e3a54030e08259", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=0047dbe59c41b951d34ce6324f3a8c0e15d523e9", "patch": "@@ -1317,7 +1317,7 @@ impl Bencher {\n         if n == 0 { n = 1; }\n \n         let mut total_run = Duration::nanoseconds(0);\n-        let samples : &mut [f64] = [0.0_f64, ..50];\n+        let samples : &mut [f64] = &mut [0.0_f64, ..50];\n         loop {\n             let mut summ = None;\n             let mut summ5 = None;"}, {"sha": "daef41666af3c7974f6df44c1cc8d0bac05303cb", "filename": "src/libtest/stats.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibtest%2Fstats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibtest%2Fstats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Fstats.rs?ref=0047dbe59c41b951d34ce6324f3a8c0e15d523e9", "patch": "@@ -1034,11 +1034,11 @@ mod tests {\n             assert_eq!(out, expected);\n         }\n \n-        t(&Summary::new([-2.0f64, -1.0f64]),\n+        t(&Summary::new(&[-2.0f64, -1.0f64]),\n                         \"-2 |[------******#*****---]| -1\".to_string());\n-        t(&Summary::new([0.0f64, 2.0f64]),\n+        t(&Summary::new(&[0.0f64, 2.0f64]),\n                         \"0 |[-------*****#*******---]| 2\".to_string());\n-        t(&Summary::new([-2.0f64, 0.0f64]),\n+        t(&Summary::new(&[-2.0f64, 0.0f64]),\n                         \"-2 |[------******#******---]| 0\".to_string());\n \n     }"}, {"sha": "18302d4a9146f7dc6b736a68ff40f2c64f3ca949", "filename": "src/libtime/lib.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibtime%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Flibtime%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtime%2Flib.rs?ref=0047dbe59c41b951d34ce6324f3a8c0e15d523e9", "patch": "@@ -904,7 +904,7 @@ pub fn strptime(s: &str, format: &str) -> Result<Tm, ParseError> {\n     fn parse_type(s: &str, pos: uint, ch: char, tm: &mut Tm)\n       -> Result<uint, ParseError> {\n         match ch {\n-          'A' => match match_strs(s, pos, [\n+          'A' => match match_strs(s, pos, &[\n               (\"Sunday\", 0_i32),\n               (\"Monday\", 1_i32),\n               (\"Tuesday\", 2_i32),\n@@ -916,7 +916,7 @@ pub fn strptime(s: &str, format: &str) -> Result<Tm, ParseError> {\n             Some(item) => { let (v, pos) = item; tm.tm_wday = v; Ok(pos) }\n             None => Err(InvalidDay)\n           },\n-          'a' => match match_strs(s, pos, [\n+          'a' => match match_strs(s, pos, &[\n               (\"Sun\", 0_i32),\n               (\"Mon\", 1_i32),\n               (\"Tue\", 2_i32),\n@@ -928,7 +928,7 @@ pub fn strptime(s: &str, format: &str) -> Result<Tm, ParseError> {\n             Some(item) => { let (v, pos) = item; tm.tm_wday = v; Ok(pos) }\n             None => Err(InvalidDay)\n           },\n-          'B' => match match_strs(s, pos, [\n+          'B' => match match_strs(s, pos, &[\n               (\"January\", 0_i32),\n               (\"February\", 1_i32),\n               (\"March\", 2_i32),\n@@ -945,7 +945,7 @@ pub fn strptime(s: &str, format: &str) -> Result<Tm, ParseError> {\n             Some(item) => { let (v, pos) = item; tm.tm_mon = v; Ok(pos) }\n             None => Err(InvalidMonth)\n           },\n-          'b' | 'h' => match match_strs(s, pos, [\n+          'b' | 'h' => match match_strs(s, pos, &[\n               (\"Jan\", 0_i32),\n               (\"Feb\", 1_i32),\n               (\"Mar\", 2_i32),\n@@ -1071,13 +1071,13 @@ pub fn strptime(s: &str, format: &str) -> Result<Tm, ParseError> {\n           }\n           'n' => parse_char(s, pos, '\\n'),\n           'P' => match match_strs(s, pos,\n-                                  [(\"am\", 0_i32), (\"pm\", 12_i32)]) {\n+                                  &[(\"am\", 0_i32), (\"pm\", 12_i32)]) {\n \n             Some(item) => { let (v, pos) = item; tm.tm_hour += v; Ok(pos) }\n             None => Err(InvalidHour)\n           },\n           'p' => match match_strs(s, pos,\n-                                  [(\"AM\", 0_i32), (\"PM\", 12_i32)]) {\n+                                  &[(\"AM\", 0_i32), (\"PM\", 12_i32)]) {\n \n             Some(item) => { let (v, pos) = item; tm.tm_hour += v; Ok(pos) }\n             None => Err(InvalidHour)\n@@ -1225,13 +1225,13 @@ pub fn strptime(s: &str, format: &str) -> Result<Tm, ParseError> {\n         let next = range.next;\n \n         let mut buf = [0];\n-        let c = match rdr.read(buf) {\n+        let c = match rdr.read(&mut buf) {\n             Ok(..) => buf[0] as char,\n             Err(..) => break\n         };\n         match c {\n             '%' => {\n-                let ch = match rdr.read(buf) {\n+                let ch = match rdr.read(&mut buf) {\n                     Ok(..) => buf[0] as char,\n                     Err(..) => break\n                 };"}, {"sha": "1c530e3851e189cc187a33a7dbead6da60a8bfa7", "filename": "src/test/bench/noise.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Ftest%2Fbench%2Fnoise.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Ftest%2Fbench%2Fnoise.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fnoise.rs?ref=0047dbe59c41b951d34ce6324f3a8c0e15d523e9", "patch": "@@ -52,7 +52,7 @@ impl Noise2DContext {\n         for (i, x) in permutations.iter_mut().enumerate() {\n             *x = i as i32;\n         }\n-        rng.shuffle(permutations);\n+        rng.shuffle(&mut permutations);\n \n         Noise2DContext { rgradients: rgradients, permutations: permutations }\n     }"}, {"sha": "b38b8e66d7dbdb980d6a86a1077186b55df394f1", "filename": "src/test/bench/shootout-fannkuch-redux.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Ftest%2Fbench%2Fshootout-fannkuch-redux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Ftest%2Fbench%2Fshootout-fannkuch-redux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fannkuch-redux.rs?ref=0047dbe59c41b951d34ce6324f3a8c0e15d523e9", "patch": "@@ -118,7 +118,7 @@ impl Perm {\n     fn max(&self) -> u32 { self.fact[self.n as uint] }\n \n     fn next(&mut self) -> P {\n-        next_permutation(self.perm.p, self.cnt);\n+        next_permutation(&mut self.perm.p, &mut self.cnt);\n         self.permcount += 1;\n \n         self.perm\n@@ -141,7 +141,7 @@ fn work(mut perm: Perm, n: uint, max: uint) -> (i32, i32) {\n \n         while p.p[0] != 1 {\n             let k = p.p[0] as uint;\n-            reverse(p.p, k);\n+            reverse(&mut p.p, k);\n             flips += 1;\n         }\n "}, {"sha": "0b4a1d91968d28555d1be56b08ef2128624237d8", "filename": "src/test/bench/shootout-fasta-redux.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Ftest%2Fbench%2Fshootout-fasta-redux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Ftest%2Fbench%2Fshootout-fasta-redux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fasta-redux.rs?ref=0047dbe59c41b951d34ce6324f3a8c0e15d523e9", "patch": "@@ -198,7 +198,7 @@ impl<'a, W: Writer> RandomFasta<'a, W> {\n                 buf[i] = self.nextc();\n             }\n             buf[LINE_LEN] = '\\n' as u8;\n-            try!(self.out.write(buf));\n+            try!(self.out.write(&buf));\n         }\n         for i in range(0u, chars_left) {\n             buf[i] = self.nextc();\n@@ -225,12 +225,12 @@ fn main() {\n     }\n \n     out.write_line(\">TWO IUB ambiguity codes\").unwrap();\n-    let iub = sum_and_scale(IUB);\n+    let iub = sum_and_scale(&IUB);\n     let mut random = RandomFasta::new(&mut out, iub.as_slice());\n     random.make(n * 3).unwrap();\n \n     random.out.write_line(\">THREE Homo sapiens frequency\").unwrap();\n-    let homo_sapiens = sum_and_scale(HOMO_SAPIENS);\n+    let homo_sapiens = sum_and_scale(&HOMO_SAPIENS);\n     random.lookup = make_lookup(homo_sapiens.as_slice());\n     random.make(n * 5).unwrap();\n "}, {"sha": "2f840ee0761b1eaabf08869eefe05be2cc279d7f", "filename": "src/test/compile-fail/lint-uppercase-variables.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Ftest%2Fcompile-fail%2Flint-uppercase-variables.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Ftest%2Fcompile-fail%2Flint-uppercase-variables.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-uppercase-variables.rs?ref=0047dbe59c41b951d34ce6324f3a8c0e15d523e9", "patch": "@@ -30,7 +30,7 @@ fn main() {\n \n     let mut f = File::open(&Path::new(\"something.txt\"));\n     let mut buff = [0u8, ..16];\n-    match f.read(buff) {\n+    match f.read(&mut buff) {\n         Ok(cnt) => println!(\"read this many bytes: {}\", cnt),\n         Err(IoError{ kind: EndOfFile, .. }) => println!(\"Got end of file: {}\", EndOfFile.to_string()),\n         //~^ ERROR variable `EndOfFile` should have a snake case name such as `end_of_file`"}, {"sha": "55cdcdce82ca5aca4b9c5a7c84696801d7d92648", "filename": "src/test/compile-fail/non-exhaustive-pattern-witness.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Ftest%2Fcompile-fail%2Fnon-exhaustive-pattern-witness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Ftest%2Fcompile-fail%2Fnon-exhaustive-pattern-witness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnon-exhaustive-pattern-witness.rs?ref=0047dbe59c41b951d34ce6324f3a8c0e15d523e9", "patch": "@@ -54,7 +54,7 @@ enum Enum {\n }\n \n fn vectors_with_nested_enums() {\n-    let x: &'static [Enum] = [First, Second(false)];\n+    let x: &'static [Enum] = &[First, Second(false)];\n     match x {\n     //~^ ERROR non-exhaustive patterns: `[Second(true), Second(false)]` not covered\n         [] => (),"}, {"sha": "f3c749da95fe48874f1f2c8721cdac8614e9cb9b", "filename": "src/test/pretty/issue-4264.pp", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Ftest%2Fpretty%2Fissue-4264.pp", "raw_url": "https://github.com/rust-lang/rust/raw/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Ftest%2Fpretty%2Fissue-4264.pp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fissue-4264.pp?ref=0047dbe59c41b951d34ce6324f3a8c0e15d523e9", "patch": "@@ -39,8 +39,9 @@\n          () => {\n              #[inline]\n              #[allow(dead_code)]\n-             static __STATIC_FMTSTR: [&'static str, ..(1u as uint)] =\n-                 ([(\"test\" as &'static str)] as [&'static str, ..1]);\n+             static __STATIC_FMTSTR: &'static [&'static str] =\n+                 (&([(\"test\" as &'static str)] as [&'static str, ..1]) as\n+                     &'static [&'static str, ..1]);\n              let __args_vec =\n                  (&([] as [core::fmt::Argument<'_>, ..0]) as\n                      &[core::fmt::Argument<'_>, ..0]);\n@@ -49,7 +50,7 @@\n                       ((::std::fmt::Arguments::new as\n                            unsafe fn(&'static [&'static str], &'a [core::fmt::Argument<'a>]) -> core::fmt::Arguments<'a>)((__STATIC_FMTSTR\n                                                                                                                               as\n-                                                                                                                              [&'static str, ..1]),\n+                                                                                                                              &'static [&'static str]),\n                                                                                                                           (__args_vec\n                                                                                                                               as\n                                                                                                                               &[core::fmt::Argument<'_>, ..0]))"}, {"sha": "f822da4cdcfcfea32474881355dabfe0f23d5f43", "filename": "src/test/run-pass/assignability-trait.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Ftest%2Frun-pass%2Fassignability-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Ftest%2Frun-pass%2Fassignability-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassignability-trait.rs?ref=0047dbe59c41b951d34ce6324f3a8c0e15d523e9", "patch": "@@ -53,5 +53,5 @@ pub fn main() {\n     // Call a method\n     z.iterate(|y| { assert!(z[*y as uint] == *y); true });\n     // Call a parameterized function\n-    assert_eq!(length::<int, &[int]>(z), z.len());\n+    assert_eq!(length::<int, &[int]>(&z), z.len());\n }"}, {"sha": "21f5d0e6c1448753db554c5b33aa7c35b1bb5b09", "filename": "src/test/run-pass/borrowck-freeze-frozen-mut.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Ftest%2Frun-pass%2Fborrowck-freeze-frozen-mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Ftest%2Frun-pass%2Fborrowck-freeze-frozen-mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-freeze-frozen-mut.rs?ref=0047dbe59c41b951d34ce6324f3a8c0e15d523e9", "patch": "@@ -21,7 +21,7 @@ fn get<'a, T>(ms: &'a MutSlice<'a, T>, index: uint) -> &'a T {\n pub fn main() {\n     let mut data = [1i, 2, 3];\n     {\n-        let slice = MutSlice { data: data };\n+        let slice = MutSlice { data: &mut data };\n         slice.data[0] += 4;\n         let index0 = get(&slice, 0);\n         let index1 = get(&slice, 1);"}, {"sha": "d24b9332917bf9ee96da2d9f0ef1b8751c5f60cd", "filename": "src/test/run-pass/capture-clauses-boxed-closures.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Ftest%2Frun-pass%2Fcapture-clauses-boxed-closures.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Ftest%2Frun-pass%2Fcapture-clauses-boxed-closures.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcapture-clauses-boxed-closures.rs?ref=0047dbe59c41b951d34ce6324f3a8c0e15d523e9", "patch": "@@ -17,7 +17,7 @@ fn each<T>(x: &[T], f: |&T|) {\n fn main() {\n     let mut sum = 0u;\n     let elems = [ 1u, 2, 3, 4, 5 ];\n-    each(elems, |val| sum += *val);\n+    each(&elems, |val| sum += *val);\n     assert_eq!(sum, 15);\n }\n "}, {"sha": "9f333fd043f0718c6fcb162eb3f9526bc9e0d8bf", "filename": "src/test/run-pass/capture-clauses-unboxed-closures.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Ftest%2Frun-pass%2Fcapture-clauses-unboxed-closures.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Ftest%2Frun-pass%2Fcapture-clauses-unboxed-closures.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcapture-clauses-unboxed-closures.rs?ref=0047dbe59c41b951d34ce6324f3a8c0e15d523e9", "patch": "@@ -19,6 +19,6 @@ fn each<'a,T,F:FnMut(&'a T)>(x: &'a [T], mut f: F) {\n fn main() {\n     let mut sum = 0u;\n     let elems = [ 1u, 2, 3, 4, 5 ];\n-    each(elems, |&mut: val: &uint| sum += *val);\n+    each(&elems, |&mut: val: &uint| sum += *val);\n     assert_eq!(sum, 15);\n }"}, {"sha": "7191d5078b81c1198303ac9c53582067d7543d53", "filename": "src/test/run-pass/cci_iter_exe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Ftest%2Frun-pass%2Fcci_iter_exe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Ftest%2Frun-pass%2Fcci_iter_exe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcci_iter_exe.rs?ref=0047dbe59c41b951d34ce6324f3a8c0e15d523e9", "patch": "@@ -15,7 +15,7 @@ extern crate cci_iter_lib;\n pub fn main() {\n     //let bt0 = sys::rusti::frame_address(1u32);\n     //println!(\"%?\", bt0);\n-    cci_iter_lib::iter([1i, 2, 3], |i| {\n+    cci_iter_lib::iter(&[1i, 2, 3], |i| {\n         println!(\"{}\", *i);\n         //assert!(bt0 == sys::rusti::frame_address(2u32));\n     })"}, {"sha": "47d59eca26316c07b16a2b6f4e1df929c776e0e4", "filename": "src/test/run-pass/const-str-ptr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Ftest%2Frun-pass%2Fconst-str-ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Ftest%2Frun-pass%2Fconst-str-ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-str-ptr.rs?ref=0047dbe59c41b951d34ce6324f3a8c0e15d523e9", "patch": "@@ -17,13 +17,13 @@ const C: *const u8 = B as *const u8;\n pub fn main() {\n     unsafe {\n         let foo = &A as *const u8;\n-        assert_eq!(str::raw::from_utf8(A), \"hi\");\n+        assert_eq!(str::raw::from_utf8(&A), \"hi\");\n         assert_eq!(string::raw::from_buf_len(foo, A.len()), \"hi\".to_string());\n         assert_eq!(string::raw::from_buf_len(C, B.len()), \"hi\".to_string());\n         assert!(*C == A[0]);\n         assert!(*(&B[0] as *const u8) == A[0]);\n \n-        let bar = str::raw::from_utf8(A).to_c_str();\n+        let bar = str::raw::from_utf8(&A).to_c_str();\n         assert_eq!(bar.as_str(), \"hi\".to_c_str().as_str());\n     }\n }"}, {"sha": "c0566277e4eb16e330b57f9b83638c07409d395d", "filename": "src/test/run-pass/const-vec-syntax.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Ftest%2Frun-pass%2Fconst-vec-syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Ftest%2Frun-pass%2Fconst-vec-syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-vec-syntax.rs?ref=0047dbe59c41b951d34ce6324f3a8c0e15d523e9", "patch": "@@ -12,5 +12,5 @@ fn f(_: &[int]) {}\n \n pub fn main() {\n     let v = [ 1, 2, 3 ];\n-    f(v);\n+    f(&v);\n }"}, {"sha": "1a2a3e36e874672cdc7cfd34fa91b0bcbc6c3a79", "filename": "src/test/run-pass/const-vecs-and-slices.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Ftest%2Frun-pass%2Fconst-vecs-and-slices.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Ftest%2Frun-pass%2Fconst-vecs-and-slices.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-vecs-and-slices.rs?ref=0047dbe59c41b951d34ce6324f3a8c0e15d523e9", "patch": "@@ -11,7 +11,7 @@\n static x : [int, ..4] = [1,2,3,4];\n static y : &'static [int] = &[1,2,3,4];\n static z : &'static [int, ..4] = &[1,2,3,4];\n-static zz : &'static [int] = [1,2,3,4];\n+static zz : &'static [int] = &[1,2,3,4];\n \n pub fn main() {\n     println!(\"{}\", x[1]);"}, {"sha": "89224e1fb12c4c6ab58816c4034bac289e6b3008", "filename": "src/test/run-pass/issue-11205.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Ftest%2Frun-pass%2Fissue-11205.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Ftest%2Frun-pass%2Fissue-11205.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-11205.rs?ref=0047dbe59c41b951d34ce6324f3a8c0e15d523e9", "patch": "@@ -72,11 +72,11 @@ fn main() {\n     let r = &1i;\n     let r: [&Foo, ..2] = [r, ..2];\n     let _n = F {\n-        t: r\n+        t: &r\n     };\n     let x: [&Foo, ..2] = [&1i, &2i];\n     let _n = F {\n-        t: x\n+        t: &x\n     };\n \n     struct M<'a> {\n@@ -87,6 +87,6 @@ fn main() {\n     };\n     let x: [Box<Foo>, ..2] = [box 1i, box 2i];\n     let _n = M {\n-        t: x\n+        t: &x\n     };\n }"}, {"sha": "dbfa330d33d9ef85e39c003bf9c0c0948c0ce70c", "filename": "src/test/run-pass/issue-12028.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Ftest%2Frun-pass%2Fissue-12028.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Ftest%2Frun-pass%2Fissue-12028.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-12028.rs?ref=0047dbe59c41b951d34ce6324f3a8c0e15d523e9", "patch": "@@ -37,7 +37,7 @@ impl<S: Stream, H: StreamHasher<S>> Hash<H> for u8 {\n \n impl<S: Stream, H: StreamHasher<S>> StreamHash<S, H> for u8 {\n     fn input_stream(&self, stream: &mut S) {\n-        stream.input([*self]);\n+        stream.input(&[*self]);\n     }\n }\n "}, {"sha": "cef09af1fcff2ff4db304255ac274c0bbafe756e", "filename": "src/test/run-pass/issue-14940.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Ftest%2Frun-pass%2Fissue-14940.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Ftest%2Frun-pass%2Fissue-14940.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-14940.rs?ref=0047dbe59c41b951d34ce6324f3a8c0e15d523e9", "patch": "@@ -15,7 +15,7 @@ fn main() {\n     let args = os::args();\n     if args.len() > 1 {\n         let mut out = stdio::stdout();\n-        out.write(['a' as u8, ..128 * 1024]).unwrap();\n+        out.write(&['a' as u8, ..128 * 1024]).unwrap();\n     } else {\n         let out = Command::new(args[0].as_slice()).arg(\"child\").output();\n         let out = out.unwrap();"}, {"sha": "c2c370ae504c70d61f326bbd860abbaf91a57350", "filename": "src/test/run-pass/issue-15080.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Ftest%2Frun-pass%2Fissue-15080.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Ftest%2Frun-pass%2Fissue-15080.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-15080.rs?ref=0047dbe59c41b951d34ce6324f3a8c0e15d523e9", "patch": "@@ -26,5 +26,5 @@ fn main() {\n                 break\n         }\n     }\n-    assert!(result.as_slice() == [2, 4]);\n+    assert!(result.as_slice() == &[2, 4]);\n }"}, {"sha": "f4206312edb06e77e741df9abd52e0e9d8bbff65", "filename": "src/test/run-pass/issue-2904.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Ftest%2Frun-pass%2Fissue-2904.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Ftest%2Frun-pass%2Fissue-2904.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2904.rs?ref=0047dbe59c41b951d34ce6324f3a8c0e15d523e9", "patch": "@@ -63,7 +63,7 @@ fn read_board_grid<rdr:'static + io::Reader>(mut input: rdr)\n     let mut input: &mut io::Reader = &mut input;\n     let mut grid = Vec::new();\n     let mut line = [0, ..10];\n-    input.read(line);\n+    input.read(&mut line);\n     let mut row = Vec::new();\n     for c in line.iter() {\n         row.push(square_from_char(*c as char))"}, {"sha": "f0310cd8df3c8d5f537d8649cd2e45210d2ab978", "filename": "src/test/run-pass/issue-7784.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Ftest%2Frun-pass%2Fissue-7784.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Ftest%2Frun-pass%2Fissue-7784.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-7784.rs?ref=0047dbe59c41b951d34ce6324f3a8c0e15d523e9", "patch": "@@ -33,6 +33,6 @@ fn main() {\n     let out = bar(\"baz\", \"foo\");\n     let [a, xs.., d] = out;\n     assert_eq!(a, \"baz\");\n-    assert!(xs == [\"foo\", \"foo\"]);\n+    assert!(xs == &[\"foo\", \"foo\"]);\n     assert_eq!(d, \"baz\");\n }"}, {"sha": "185d75743a41e89cedb7e48b9201b0fcdb37998c", "filename": "src/test/run-pass/issue-8398.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Ftest%2Frun-pass%2Fissue-8398.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Ftest%2Frun-pass%2Fissue-8398.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-8398.rs?ref=0047dbe59c41b951d34ce6324f3a8c0e15d523e9", "patch": "@@ -11,7 +11,7 @@\n use std::io;\n \n fn foo(a: &mut io::Writer) {\n-    a.write([]).unwrap();\n+    a.write(&[]).unwrap();\n }\n \n pub fn main(){}"}, {"sha": "2795fd59c0c0d7cf156a3f64abd63a886888786b", "filename": "src/test/run-pass/issue-9249.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Ftest%2Frun-pass%2Fissue-9249.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Ftest%2Frun-pass%2Fissue-9249.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-9249.rs?ref=0047dbe59c41b951d34ce6324f3a8c0e15d523e9", "patch": "@@ -8,5 +8,5 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-static DATA:&'static [&'static str] = [\"my string\"];\n+static DATA:&'static [&'static str] = &[\"my string\"];\n fn main() { }"}, {"sha": "0264e64f70d2a4ef659fe3df13cecde2863752f5", "filename": "src/test/run-pass/regions-borrow-evec-fixed.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Ftest%2Frun-pass%2Fregions-borrow-evec-fixed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Ftest%2Frun-pass%2Fregions-borrow-evec-fixed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-borrow-evec-fixed.rs?ref=0047dbe59c41b951d34ce6324f3a8c0e15d523e9", "patch": "@@ -13,6 +13,6 @@ fn foo(x: &[int]) -> int {\n }\n \n pub fn main() {\n-    let p = [1,2,3,4,5];\n+    let p = &[1,2,3,4,5];\n     assert_eq!(foo(p), 1);\n }"}, {"sha": "b5cee20232b632a301857a71c07eab59926b638b", "filename": "src/test/run-pass/rename-directory.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Ftest%2Frun-pass%2Frename-directory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Ftest%2Frun-pass%2Frename-directory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frename-directory.rs?ref=0047dbe59c41b951d34ce6324f3a8c0e15d523e9", "patch": "@@ -25,7 +25,7 @@ fn rename_directory() {\n \n         let tmpdir = TempDir::new(\"rename_directory\").ok().expect(\"rename_directory failed\");\n         let tmpdir = tmpdir.path();\n-        let old_path = tmpdir.join_many([\"foo\", \"bar\", \"baz\"]);\n+        let old_path = tmpdir.join_many(&[\"foo\", \"bar\", \"baz\"]);\n         fs::mkdir_recursive(&old_path, io::USER_RWX);\n         let test_file = &old_path.join(\"temp.txt\");\n \n@@ -46,11 +46,11 @@ fn rename_directory() {\n         });\n         assert_eq!(libc::fclose(ostream), (0u as libc::c_int));\n \n-        let new_path = tmpdir.join_many([\"quux\", \"blat\"]);\n+        let new_path = tmpdir.join_many(&[\"quux\", \"blat\"]);\n         fs::mkdir_recursive(&new_path, io::USER_RWX);\n         fs::rename(&old_path, &new_path.join(\"newdir\"));\n         assert!(new_path.join(\"newdir\").is_dir());\n-        assert!(new_path.join_many([\"newdir\", \"temp.txt\"]).exists());\n+        assert!(new_path.join_many(&[\"newdir\", \"temp.txt\"]).exists());\n     }\n }\n "}, {"sha": "1804dd2e1358a19d2a78e5f7afd6ddf3079f2534", "filename": "src/test/run-pass/sigpipe-should-be-ignored.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Ftest%2Frun-pass%2Fsigpipe-should-be-ignored.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Ftest%2Frun-pass%2Fsigpipe-should-be-ignored.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsigpipe-should-be-ignored.rs?ref=0047dbe59c41b951d34ce6324f3a8c0e15d523e9", "patch": "@@ -21,7 +21,7 @@ fn test() {\n     let mut writer = PipeStream::open(writer);\n     drop(reader);\n \n-    let _ = writer.write([1]);\n+    let _ = writer.write(&[1]);\n }\n \n fn main() {"}, {"sha": "250eafa2f49d5fd6aeb781d9b550da0ee9bd9382", "filename": "src/test/run-pass/stat.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Ftest%2Frun-pass%2Fstat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Ftest%2Frun-pass%2Fstat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstat.rs?ref=0047dbe59c41b951d34ce6324f3a8c0e15d523e9", "patch": "@@ -21,7 +21,7 @@ pub fn main() {\n             Ok(f) => {\n                 let mut f = f;\n                 for _ in range(0u, 1000) {\n-                    f.write([0]);\n+                    f.write(&[0]);\n                 }\n             }\n         }"}, {"sha": "d343e485b24819e7085aa70e834734dd574870cc", "filename": "src/test/run-pass/utf8_chars.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Ftest%2Frun-pass%2Futf8_chars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Ftest%2Frun-pass%2Futf8_chars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Futf8_chars.rs?ref=0047dbe59c41b951d34ce6324f3a8c0e15d523e9", "patch": "@@ -27,17 +27,17 @@ pub fn main() {\n \n     assert!((str::is_utf8(s.as_bytes())));\n     // invalid prefix\n-    assert!((!str::is_utf8([0x80_u8])));\n+    assert!((!str::is_utf8(&[0x80_u8])));\n     // invalid 2 byte prefix\n-    assert!((!str::is_utf8([0xc0_u8])));\n-    assert!((!str::is_utf8([0xc0_u8, 0x10_u8])));\n+    assert!((!str::is_utf8(&[0xc0_u8])));\n+    assert!((!str::is_utf8(&[0xc0_u8, 0x10_u8])));\n     // invalid 3 byte prefix\n-    assert!((!str::is_utf8([0xe0_u8])));\n-    assert!((!str::is_utf8([0xe0_u8, 0x10_u8])));\n-    assert!((!str::is_utf8([0xe0_u8, 0xff_u8, 0x10_u8])));\n+    assert!((!str::is_utf8(&[0xe0_u8])));\n+    assert!((!str::is_utf8(&[0xe0_u8, 0x10_u8])));\n+    assert!((!str::is_utf8(&[0xe0_u8, 0xff_u8, 0x10_u8])));\n     // invalid 4 byte prefix\n-    assert!((!str::is_utf8([0xf0_u8])));\n-    assert!((!str::is_utf8([0xf0_u8, 0x10_u8])));\n-    assert!((!str::is_utf8([0xf0_u8, 0xff_u8, 0x10_u8])));\n-    assert!((!str::is_utf8([0xf0_u8, 0xff_u8, 0xff_u8, 0x10_u8])));\n+    assert!((!str::is_utf8(&[0xf0_u8])));\n+    assert!((!str::is_utf8(&[0xf0_u8, 0x10_u8])));\n+    assert!((!str::is_utf8(&[0xf0_u8, 0xff_u8, 0x10_u8])));\n+    assert!((!str::is_utf8(&[0xf0_u8, 0xff_u8, 0xff_u8, 0x10_u8])));\n }"}, {"sha": "d8bf0a5c627f68f29fd3358512fe7263fd862a64", "filename": "src/test/run-pass/vec-dst.rs", "status": "modified", "additions": 1, "deletions": 16, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Ftest%2Frun-pass%2Fvec-dst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Ftest%2Frun-pass%2Fvec-dst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fvec-dst.rs?ref=0047dbe59c41b951d34ce6324f3a8c0e15d523e9", "patch": "@@ -8,17 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-fn sub_expr() {\n-    // Test for a &[T] => &&[T] coercion in sub-expression position\n-    // (surprisingly, this can cause errors which are not caused by either of:\n-    //    `let x = vec.slice_mut(0, 2);`\n-    //    `foo(vec.slice_mut(0, 2));` ).\n-    let mut vec: Vec<int> = vec!(1, 2, 3, 4);\n-    let b: &mut [int] = [1, 2];\n-    assert!(vec.slice_mut(0, 2) == b);\n-}\n-\n-fn index() {\n+pub fn main() {\n     // Tests for indexing into box/& [T, ..n]\n     let x: [int, ..3] = [1, 2, 3];\n     let mut x: Box<[int, ..3]> = box x;\n@@ -40,8 +30,3 @@ fn index() {\n     assert!(x[1] == 45);\n     assert!(x[2] == 3);\n }\n-\n-pub fn main() {\n-    sub_expr();\n-    index();\n-}"}, {"sha": "cc2061c3cf38535901ba58d1a60a367525e0e62e", "filename": "src/test/run-pass/vec-matching-fold.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Ftest%2Frun-pass%2Fvec-matching-fold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0047dbe59c41b951d34ce6324f3a8c0e15d523e9/src%2Ftest%2Frun-pass%2Fvec-matching-fold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fvec-matching-fold.rs?ref=0047dbe59c41b951d34ce6324f3a8c0e15d523e9", "patch": "@@ -33,7 +33,7 @@ fn foldr<T,U:Clone>(values: &[T],\n }\n \n pub fn main() {\n-    let x = [1i, 2, 3, 4, 5];\n+    let x = &[1i, 2, 3, 4, 5];\n \n     let product = foldl(x, 1i, |a, b| a * *b);\n     assert_eq!(product, 120);"}]}