{"sha": "3245a475ab92b5ab77cf69e336279420c86a83eb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMyNDVhNDc1YWI5MmI1YWI3N2NmNjllMzM2Mjc5NDIwYzg2YTgzZWI=", "commit": {"author": {"name": "moxian", "email": "moxian@google.com", "date": "2018-05-13T04:38:43Z"}, "committer": {"name": "moxian", "email": "moxian@google.com", "date": "2018-06-28T21:56:48Z"}, "message": "Split separate stackwalk variants into their own functions\n\n.. rather than having them be one giant match statement.", "tree": {"sha": "58636f02c381d690a2ad0f99e05a3935d39b3115", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/58636f02c381d690a2ad0f99e05a3935d39b3115"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3245a475ab92b5ab77cf69e336279420c86a83eb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3245a475ab92b5ab77cf69e336279420c86a83eb", "html_url": "https://github.com/rust-lang/rust/commit/3245a475ab92b5ab77cf69e336279420c86a83eb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3245a475ab92b5ab77cf69e336279420c86a83eb/comments", "author": {"login": "moxian", "id": 7831163, "node_id": "MDQ6VXNlcjc4MzExNjM=", "avatar_url": "https://avatars.githubusercontent.com/u/7831163?v=4", "gravatar_id": "", "url": "https://api.github.com/users/moxian", "html_url": "https://github.com/moxian", "followers_url": "https://api.github.com/users/moxian/followers", "following_url": "https://api.github.com/users/moxian/following{/other_user}", "gists_url": "https://api.github.com/users/moxian/gists{/gist_id}", "starred_url": "https://api.github.com/users/moxian/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/moxian/subscriptions", "organizations_url": "https://api.github.com/users/moxian/orgs", "repos_url": "https://api.github.com/users/moxian/repos", "events_url": "https://api.github.com/users/moxian/events{/privacy}", "received_events_url": "https://api.github.com/users/moxian/received_events", "type": "User", "site_admin": false}, "committer": {"login": "moxian", "id": 7831163, "node_id": "MDQ6VXNlcjc4MzExNjM=", "avatar_url": "https://avatars.githubusercontent.com/u/7831163?v=4", "gravatar_id": "", "url": "https://api.github.com/users/moxian", "html_url": "https://github.com/moxian", "followers_url": "https://api.github.com/users/moxian/followers", "following_url": "https://api.github.com/users/moxian/following{/other_user}", "gists_url": "https://api.github.com/users/moxian/gists{/gist_id}", "starred_url": "https://api.github.com/users/moxian/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/moxian/subscriptions", "organizations_url": "https://api.github.com/users/moxian/orgs", "repos_url": "https://api.github.com/users/moxian/repos", "events_url": "https://api.github.com/users/moxian/events{/privacy}", "received_events_url": "https://api.github.com/users/moxian/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d39c66bf4ff2b49957edadf10afcc4050c3fc60b", "url": "https://api.github.com/repos/rust-lang/rust/commits/d39c66bf4ff2b49957edadf10afcc4050c3fc60b", "html_url": "https://github.com/rust-lang/rust/commit/d39c66bf4ff2b49957edadf10afcc4050c3fc60b"}], "stats": {"total": 442, "additions": 238, "deletions": 204}, "files": [{"sha": "884ec4e9fade4eb0113e039b6d4abfba74f1969e", "filename": "src/libstd/sys/windows/backtrace/mod.rs", "status": "modified", "additions": 118, "deletions": 76, "changes": 194, "blob_url": "https://github.com/rust-lang/rust/blob/3245a475ab92b5ab77cf69e336279420c86a83eb/src%2Flibstd%2Fsys%2Fwindows%2Fbacktrace%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3245a475ab92b5ab77cf69e336279420c86a83eb/src%2Flibstd%2Fsys%2Fwindows%2Fbacktrace%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fbacktrace%2Fmod.rs?ref=3245a475ab92b5ab77cf69e336279420c86a83eb", "patch": "@@ -46,27 +46,38 @@ mod printing;\n #[path = \"backtrace_gnu.rs\"]\n pub mod gnu;\n \n-pub use self::printing::{resolve_symname, foreach_symbol_fileline};\n+pub use self::printing::{foreach_symbol_fileline, resolve_symname};\n \n pub fn unwind_backtrace(frames: &mut [Frame]) -> io::Result<(usize, BacktraceContext)> {\n     let dbghelp = DynamicLibrary::open(\"dbghelp.dll\")?;\n \n     // Fetch the symbols necessary from dbghelp.dll\n     let SymInitialize = sym!(dbghelp, \"SymInitialize\", SymInitializeFn)?;\n     let SymCleanup = sym!(dbghelp, \"SymCleanup\", SymCleanupFn)?;\n+\n+    // enum for holding the StackWalk function. Different from StackWalkVariant\n+    // below, since there's no need to pass the function itself into\n+    // the BacktraceContext\n+    enum sw_fn_local {\n+        SWExFn(StackWalkExFn),\n+        SW64Fn(StackWalk64Fn),\n+    }\n     // StackWalkEx might not be present and we'll fall back to StackWalk64\n-    let ResStackWalkEx = sym!(dbghelp, \"StackWalkEx\", StackWalkExFn);\n-    let ResStackWalk64 = sym!(dbghelp, \"StackWalk64\", StackWalk64Fn);\n+    let (StackWalkFn, variant) =\n+        sym!(dbghelp, \"StackWalkEx\", StackWalkExFn)\n+        .map(|f| (sw_fn_local::SWExFn(f), StackWalkVariant::StackWalkEx))\n+        .or_else(|_|\n+            sym!(dbghelp, \"StackWalk64\", StackWalk64Fn)\n+            .map(|f| (sw_fn_local::SW64Fn(f), StackWalkVariant::StackWalk64))\n+        )?;\n \n     // Allocate necessary structures for doing the stack walk\n     let process = unsafe { c::GetCurrentProcess() };\n-    let thread = unsafe { c::GetCurrentThread() };\n-    let mut context: c::CONTEXT = unsafe { mem::zeroed() };\n-    unsafe { c::RtlCaptureContext(&mut context) };\n \n     let backtrace_context = BacktraceContext {\n         handle: process,\n         SymCleanup,\n+        StackWalkVariant: variant,\n         dbghelp,\n     };\n \n@@ -77,81 +88,102 @@ pub fn unwind_backtrace(frames: &mut [Frame]) -> io::Result<(usize, BacktraceCon\n     }\n \n     // And now that we're done with all the setup, do the stack walking!\n-    match (ResStackWalkEx, ResStackWalk64) {\n-        (Ok(StackWalkEx), _) => {\n-            let mut frame: c::STACKFRAME_EX = unsafe { mem::zeroed() };\n-            frame.StackFrameSize = mem::size_of_val(&frame) as c::DWORD;\n-            let image = init_frame_ex(&mut frame, &context);\n-\n-            let mut i = 0;\n-            unsafe {\n-                while i < frames.len()\n-                    && StackWalkEx(\n-                        image,\n-                        process,\n-                        thread,\n-                        &mut frame,\n-                        &mut context,\n-                        ptr::null_mut(),\n-                        ptr::null_mut(),\n-                        ptr::null_mut(),\n-                        ptr::null_mut(),\n-                        0,\n-                    ) == c::TRUE\n-                {\n-                    let addr = (frame.AddrPC.Offset - 1) as *const u8;\n-\n-                    frames[i] = Frame {\n-                        symbol_addr: addr,\n-                        exact_position: addr,\n-                        inline_context: frame.InlineFrameContext,\n-                    };\n-                    i += 1;\n-                }\n-            }\n+    match StackWalkFn {\n+        sw_fn_local::SWExFn(f) => set_frames_ex(f, frames, backtrace_context, process),\n+        sw_fn_local::SW64Fn(f) => set_frames_64(f, frames, backtrace_context, process),\n+    }\n+}\n \n-            Ok((i, backtrace_context))\n+fn set_frames_ex(\n+    StackWalkEx: StackWalkExFn,\n+    frames: &mut [Frame],\n+    backtrace_context: BacktraceContext,\n+    process: c::HANDLE,\n+) -> io::Result<(usize, BacktraceContext)> {\n+    let thread = unsafe { c::GetCurrentProcess() };\n+    let mut context: c::CONTEXT = unsafe { mem::zeroed() };\n+    unsafe { c::RtlCaptureContext(&mut context) };\n+\n+    let mut frame: c::STACKFRAME_EX = unsafe { mem::zeroed() };\n+    frame.StackFrameSize = mem::size_of_val(&frame) as c::DWORD;\n+    let image = init_frame_ex(&mut frame, &context);\n+\n+    let mut i = 0;\n+    unsafe {\n+        while i < frames.len()\n+            && StackWalkEx(\n+                image,\n+                process,\n+                thread,\n+                &mut frame,\n+                &mut context,\n+                ptr::null_mut(),\n+                ptr::null_mut(),\n+                ptr::null_mut(),\n+                ptr::null_mut(),\n+                0,\n+            ) == c::TRUE\n+        {\n+            let addr = (frame.AddrPC.Offset - 1) as *const u8;\n+\n+            frames[i] = Frame {\n+                symbol_addr: addr,\n+                exact_position: addr,\n+                inline_context: frame.InlineFrameContext,\n+            };\n+            i += 1;\n         }\n-        (_, Ok(StackWalk64)) => {\n-            let mut frame: c::STACKFRAME64 = unsafe { mem::zeroed() };\n-            let image = init_frame_64(&mut frame, &context);\n-\n-            // Start from -1 to avoid printing this stack frame, which will\n-            // always be exactly the same.\n-            let mut i = 0;\n-            unsafe {\n-                while i < frames.len()\n-                    && StackWalk64(\n-                        image,\n-                        process,\n-                        thread,\n-                        &mut frame,\n-                        &mut context,\n-                        ptr::null_mut(),\n-                        ptr::null_mut(),\n-                        ptr::null_mut(),\n-                        ptr::null_mut(),\n-                    ) == c::TRUE\n-                {\n-                    let addr = frame.AddrPC.Offset;\n-                    if addr == frame.AddrReturn.Offset || addr == 0 || frame.AddrReturn.Offset == 0\n-                    {\n-                        break;\n-                    }\n-\n-                    frames[i] = Frame {\n-                        symbol_addr: (addr - 1) as *const u8,\n-                        exact_position: (addr - 1) as *const u8,\n-                        inline_context: 0,\n-                    };\n-                    i += 1;\n-                }\n+    }\n+\n+    Ok((i, backtrace_context))\n+}\n+\n+fn set_frames_64(\n+    StackWalk64: StackWalk64Fn,\n+    frames: &mut [Frame],\n+    backtrace_context: BacktraceContext,\n+    process: c::HANDLE,\n+) -> io::Result<(usize, BacktraceContext)> {\n+    let thread = unsafe { c::GetCurrentProcess() };\n+    let mut context: c::CONTEXT = unsafe { mem::zeroed() };\n+    unsafe { c::RtlCaptureContext(&mut context) };\n+\n+    let mut frame: c::STACKFRAME64 = unsafe { mem::zeroed() };\n+    let image = init_frame_64(&mut frame, &context);\n+\n+    // Start from -1 to avoid printing this stack frame, which will\n+    // always be exactly the same.\n+    let mut i = 0;\n+    unsafe {\n+        while i < frames.len()\n+            && StackWalk64(\n+                image,\n+                process,\n+                thread,\n+                &mut frame,\n+                &mut context,\n+                ptr::null_mut(),\n+                ptr::null_mut(),\n+                ptr::null_mut(),\n+                ptr::null_mut(),\n+            ) == c::TRUE\n+        {\n+            let addr = frame.AddrPC.Offset;\n+            if addr == frame.AddrReturn.Offset || addr == 0 || frame.AddrReturn.Offset == 0\n+            {\n+                break;\n             }\n \n-            Ok((i, backtrace_context))\n+            frames[i] = Frame {\n+                symbol_addr: (addr - 1) as *const u8,\n+                exact_position: (addr - 1) as *const u8,\n+                inline_context: 0,\n+            };\n+            i += 1;\n         }\n-        (Err(e), _) => Err(e),\n     }\n+\n+    Ok((i, backtrace_context))\n }\n \n type SymInitializeFn = unsafe extern \"system\" fn(c::HANDLE, *mut c_void, c::BOOL) -> c::BOOL;\n@@ -226,16 +258,26 @@ fn init_frame_64(frame: &mut c::STACKFRAME64, ctx: &c::CONTEXT) -> c::DWORD {\n     c::IMAGE_FILE_MACHINE_AMD64\n }\n \n+enum StackWalkVariant {\n+    StackWalkEx,\n+    StackWalk64,\n+}\n+\n+\n pub struct BacktraceContext {\n     handle: c::HANDLE,\n     SymCleanup: SymCleanupFn,\n     // Only used in printing for msvc and not gnu\n     #[allow(dead_code)]\n+    StackWalkVariant: StackWalkVariant,\n+    #[allow(dead_code)]\n     dbghelp: DynamicLibrary,\n }\n \n impl Drop for BacktraceContext {\n     fn drop(&mut self) {\n-        unsafe { (self.SymCleanup)(self.handle); }\n+        unsafe {\n+            (self.SymCleanup)(self.handle);\n+        }\n     }\n }"}, {"sha": "9d7accb7ad77a842f7396bf6c4c8a7dac0db44a7", "filename": "src/libstd/sys/windows/backtrace/printing/msvc.rs", "status": "modified", "additions": 120, "deletions": 128, "changes": 248, "blob_url": "https://github.com/rust-lang/rust/blob/3245a475ab92b5ab77cf69e336279420c86a83eb/src%2Flibstd%2Fsys%2Fwindows%2Fbacktrace%2Fprinting%2Fmsvc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3245a475ab92b5ab77cf69e336279420c86a83eb/src%2Flibstd%2Fsys%2Fwindows%2Fbacktrace%2Fprinting%2Fmsvc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fbacktrace%2Fprinting%2Fmsvc.rs?ref=3245a475ab92b5ab77cf69e336279420c86a83eb", "patch": "@@ -13,11 +13,10 @@ use io;\n use libc::{c_char, c_ulong};\n use mem;\n use sys::backtrace::BacktraceContext;\n+use sys::backtrace::StackWalkVariant;\n use sys::c;\n use sys_common::backtrace::Frame;\n \n-type SymFromInlineContextFn =\n-    unsafe extern \"system\" fn(c::HANDLE, u64, c::ULONG, *mut u64, *mut c::SYMBOL_INFO) -> c::BOOL;\n type SymFromInlineContextFn =\n     unsafe extern \"system\" fn(c::HANDLE, u64, c::ULONG, *mut u64, *mut c::SYMBOL_INFO) -> c::BOOL;\n type SymGetLineFromInlineContextFn = unsafe extern \"system\" fn(\n@@ -39,57 +38,26 @@ pub fn resolve_symname<F>(frame: Frame, callback: F, context: &BacktraceContext)\n where\n     F: FnOnce(Option<&str>) -> io::Result<()>,\n {\n-    match (\n-        sym!(\n-            &context.dbghelp,\n-            \"SymFromInlineContext\",\n-            SymFromInlineContextFn\n-        ),\n-        sym!(&context.dbghelp, \"SymFromAddr\", SymFromAddrFn),\n-    ) {\n-        (Ok(SymFromInlineContext), _) => unsafe {\n-            let mut info: c::SYMBOL_INFO = mem::zeroed();\n-            info.MaxNameLen = c::MAX_SYM_NAME as c_ulong;\n-            // the struct size in C.  the value is different to\n-            // `size_of::<SYMBOL_INFO>() - MAX_SYM_NAME + 1` (== 81)\n-            // due to struct alignment.\n-            info.SizeOfStruct = 88;\n+    match context.StackWalkVariant {\n+        StackWalkVariant::StackWalkEx => {\n+            let SymFromInlineContext =\n+                sym!(&context.dbghelp, \"SymFromInlineContext\",SymFromInlineContextFn)?;\n+            resolve_symname_from_inline_context(SymFromInlineContext, frame, callback, context)\n+        },\n+        StackWalkVariant::StackWalk64 => {\n+            let SymFromAddr = sym!(&context.dbghelp, \"SymFromAddr\", SymFromAddrFn)?;\n+            resolve_symname_from_addr(SymFromAddr, frame, callback, context)\n+        }\n+    }\n+}\n \n-            let mut displacement = 0u64;\n-            let ret = SymFromInlineContext(\n-                context.handle,\n-                frame.symbol_addr as u64,\n-                frame.inline_context,\n-                &mut displacement,\n-                &mut info,\n-            );\n-            let valid_range =\n-                if ret == c::TRUE && frame.symbol_addr as usize >= info.Address as usize {\n-                    if info.Size != 0 {\n-                        (frame.symbol_addr as usize) < info.Address as usize + info.Size as usize\n-                    } else {\n-                        true\n-                    }\n-                } else {\n-                    false\n-                };\n-            let symname = if valid_range {\n-                let ptr = info.Name.as_ptr() as *const c_char;\n-                CStr::from_ptr(ptr).to_str().ok()\n-            } else {\n-                None\n-            };\n-            callback(symname)\n+fn resolve_symname_from_inline_context<F>(\n+    SymFromInlineContext: SymFromInlineContextFn,\n+    frame: Frame, callback: F, context: &BacktraceContext) -> io::Result<()>\n+where\n+    F: FnOnce(Option<&str>) -> io::Result<()>,\n {\n-    match (\n-        sym!(\n-            &context.dbghelp,\n-            \"SymFromInlineContext\",\n-            SymFromInlineContextFn\n-        ),\n-        sym!(&context.dbghelp, \"SymFromAddr\", SymFromAddrFn),\n-    ) {\n-        (Ok(SymFromInlineContext), _) => unsafe {\n+    unsafe {\n             let mut info: c::SYMBOL_INFO = mem::zeroed();\n             info.MaxNameLen = c::MAX_SYM_NAME as c_ulong;\n             // the struct size in C.  the value is different to\n@@ -122,97 +90,121 @@ where\n                 None\n             };\n             callback(symname)\n-        },\n-        (_, Ok(SymFromAddr)) => unsafe {\n-            } else {\n-                None\n-            };\n-            callback(symname)\n-        },\n-        (_, Ok(SymFromAddr)) => unsafe {\n-            let mut info: c::SYMBOL_INFO = mem::zeroed();\n-            info.MaxNameLen = c::MAX_SYM_NAME as c_ulong;\n-            // the struct size in C.  the value is different to\n-            // `size_of::<SYMBOL_INFO>() - MAX_SYM_NAME + 1` (== 81)\n-            // due to struct alignment.\n-            info.SizeOfStruct = 88;\n+        }\n+}\n \n-            let mut displacement = 0u64;\n-            let ret = SymFromAddr(\n-                context.handle,\n-                frame.symbol_addr as u64,\n-                &mut displacement,\n-                &mut info,\n-            );\n+fn resolve_symname_from_addr<F>(\n+    SymFromAddr: SymFromAddrFn,\n+    frame: Frame, callback: F, context: &BacktraceContext) -> io::Result<()>\n+where\n+    F: FnOnce(Option<&str>) -> io::Result<()>,\n+{\n+    unsafe {\n+        let mut info: c::SYMBOL_INFO = mem::zeroed();\n+        info.MaxNameLen = c::MAX_SYM_NAME as c_ulong;\n+        // the struct size in C.  the value is different to\n+        // `size_of::<SYMBOL_INFO>() - MAX_SYM_NAME + 1` (== 81)\n+        // due to struct alignment.\n+        info.SizeOfStruct = 88;\n \n-            let symname = if ret == c::TRUE {\n-                let ptr = info.Name.as_ptr() as *const c_char;\n-                CStr::from_ptr(ptr).to_str().ok()\n-            } else {\n-                None\n-            };\n-            callback(symname)\n-        },\n-        (Err(e), _) => Err(e),\n+        let mut displacement = 0u64;\n+        let ret = SymFromAddr(\n+            context.handle,\n+            frame.symbol_addr as u64,\n+            &mut displacement,\n+            &mut info,\n+        );\n+\n+        let symname = if ret == c::TRUE {\n+            let ptr = info.Name.as_ptr() as *const c_char;\n+            CStr::from_ptr(ptr).to_str().ok()\n+        } else {\n+            None\n+        };\n+        callback(symname)\n     }\n }\n \n pub fn foreach_symbol_fileline<F>(\n+    frame: Frame,\n+    f: F,\n+    context: &BacktraceContext,\n+) -> io::Result<bool>\n+where\n+    F: FnMut(&[u8], u32) -> io::Result<()>,\n+{\n+    match context.StackWalkVariant {\n+        StackWalkVariant::StackWalkEx => {\n+            let SymGetLineFromInlineContext =\n+                sym!(&context.dbghelp, \"SymGetLineFromInlineContext\",\n+                     SymGetLineFromInlineContextFn)?;\n+            foreach_symbol_fileline_ex(SymGetLineFromInlineContext,\n+                frame, f, context)\n+        },\n+        StackWalkVariant::StackWalk64 => {\n+            let SymGetLineFromAddr64 =\n+                sym!(&context.dbghelp, \"SymGetLineFromAddr64\",\n+                     SymGetLineFromAddr64Fn)?;\n+            foreach_symbol_fileline_64(SymGetLineFromAddr64,\n+                frame, f, context)\n+        }\n+    }\n+}\n+\n+fn foreach_symbol_fileline_ex<F>(\n+    SymGetLineFromInlineContext: SymGetLineFromInlineContextFn,\n     frame: Frame,\n     mut f: F,\n     context: &BacktraceContext,\n ) -> io::Result<bool>\n where\n     F: FnMut(&[u8], u32) -> io::Result<()>,\n {\n-    match (\n-        sym!(\n-            &context.dbghelp,\n-            \"SymGetLineFromInlineContext\",\n-            SymGetLineFromInlineContextFn\n-        ),\n-        sym!(\n-            &context.dbghelp,\n-            \"SymGetLineFromAddr64\",\n-            SymGetLineFromAddr64Fn\n-        ),\n-    ) {\n-        (Ok(SymGetLineFromInlineContext), _) => unsafe {\n-            let mut line: c::IMAGEHLP_LINE64 = mem::zeroed();\n-            line.SizeOfStruct = ::mem::size_of::<c::IMAGEHLP_LINE64>() as u32;\n+    unsafe {\n+        let mut line: c::IMAGEHLP_LINE64 = mem::zeroed();\n+        line.SizeOfStruct = ::mem::size_of::<c::IMAGEHLP_LINE64>() as u32;\n \n-            let mut displacement = 0u32;\n-            let ret = SymGetLineFromInlineContext(\n-                context.handle,\n-                frame.exact_position as u64,\n-                frame.inline_context,\n-                0,\n-                &mut displacement,\n-                &mut line,\n-            );\n-            if ret == c::TRUE {\n-                let name = CStr::from_ptr(line.Filename).to_bytes();\n-                f(name, line.LineNumber as u32)?;\n-            }\n-            Ok(false)\n-        },\n-        (_, Ok(SymGetLineFromAddr64)) => unsafe {\n-            let mut line: c::IMAGEHLP_LINE64 = mem::zeroed();\n-            line.SizeOfStruct = ::mem::size_of::<c::IMAGEHLP_LINE64>() as u32;\n+        let mut displacement = 0u32;\n+        let ret = SymGetLineFromInlineContext(\n+            context.handle,\n+            frame.exact_position as u64,\n+            frame.inline_context,\n+            0,\n+            &mut displacement,\n+            &mut line,\n+        );\n+        if ret == c::TRUE {\n+            let name = CStr::from_ptr(line.Filename).to_bytes();\n+            f(name, line.LineNumber as u32)?;\n+        }\n+        Ok(false)\n+    }\n+}\n \n-            let mut displacement = 0u32;\n-            let ret = SymGetLineFromAddr64(\n-                context.handle,\n-                frame.exact_position as u64,\n-                &mut displacement,\n-                &mut line,\n-            );\n-            if ret == c::TRUE {\n-                let name = CStr::from_ptr(line.Filename).to_bytes();\n-                f(name, line.LineNumber as u32)?;\n-            }\n-            Ok(false)\n-        },\n-        (Err(e), _) => Err(e),\n+fn foreach_symbol_fileline_64<F>(\n+    SymGetLineFromAddr64: SymGetLineFromAddr64Fn,\n+    frame: Frame,\n+    mut f: F,\n+    context: &BacktraceContext,\n+) -> io::Result<bool>\n+where\n+    F: FnMut(&[u8], u32) -> io::Result<()>,\n+{\n+    unsafe {\n+        let mut line: c::IMAGEHLP_LINE64 = mem::zeroed();\n+        line.SizeOfStruct = ::mem::size_of::<c::IMAGEHLP_LINE64>() as u32;\n+\n+        let mut displacement = 0u32;\n+        let ret = SymGetLineFromAddr64(\n+            context.handle,\n+            frame.exact_position as u64,\n+            &mut displacement,\n+            &mut line,\n+        );\n+        if ret == c::TRUE {\n+            let name = CStr::from_ptr(line.Filename).to_bytes();\n+            f(name, line.LineNumber as u32)?;\n+        }\n+        Ok(false)\n     }\n }"}]}