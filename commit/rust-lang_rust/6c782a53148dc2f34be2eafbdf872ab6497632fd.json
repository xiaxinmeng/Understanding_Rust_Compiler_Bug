{"sha": "6c782a53148dc2f34be2eafbdf872ab6497632fd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZjNzgyYTUzMTQ4ZGMyZjM0YmUyZWFmYmRmODcyYWI2NDk3NjMyZmQ=", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-03-15T09:11:48Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-03-15T11:10:18Z"}, "message": "Power up goto_implementation\n\nby allowing it to be invoked on references of names, showing all (trait)\nimplementations of the given type in all crates including builtin types", "tree": {"sha": "634e4bc975861908b0c79028eedfcc4e87a2ecfa", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/634e4bc975861908b0c79028eedfcc4e87a2ecfa"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6c782a53148dc2f34be2eafbdf872ab6497632fd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6c782a53148dc2f34be2eafbdf872ab6497632fd", "html_url": "https://github.com/rust-lang/rust/commit/6c782a53148dc2f34be2eafbdf872ab6497632fd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6c782a53148dc2f34be2eafbdf872ab6497632fd/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "de360275416ca095102f2b17d6ca1de3bd091fdb", "url": "https://api.github.com/repos/rust-lang/rust/commits/de360275416ca095102f2b17d6ca1de3bd091fdb", "html_url": "https://github.com/rust-lang/rust/commit/de360275416ca095102f2b17d6ca1de3bd091fdb"}], "stats": {"total": 185, "additions": 123, "deletions": 62}, "files": [{"sha": "a9d3c915665fea84273d7a1994e705189d39fc67", "filename": "crates/hir/src/lib.rs", "status": "modified", "additions": 40, "deletions": 13, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/6c782a53148dc2f34be2eafbdf872ab6497632fd/crates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c782a53148dc2f34be2eafbdf872ab6497632fd/crates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Flib.rs?ref=6c782a53148dc2f34be2eafbdf872ab6497632fd", "patch": "@@ -696,8 +696,8 @@ impl Adt {\n         }\n     }\n \n-    pub fn krate(self, db: &dyn HirDatabase) -> Option<Crate> {\n-        Some(self.module(db).krate())\n+    pub fn krate(self, db: &dyn HirDatabase) -> Crate {\n+        self.module(db).krate()\n     }\n \n     pub fn name(self, db: &dyn HirDatabase) -> Name {\n@@ -1019,8 +1019,8 @@ impl TypeAlias {\n         Module { id: self.id.lookup(db.upcast()).module(db.upcast()) }\n     }\n \n-    pub fn krate(self, db: &dyn HirDatabase) -> Option<Crate> {\n-        Some(self.module(db).krate())\n+    pub fn krate(self, db: &dyn HirDatabase) -> Crate {\n+        self.module(db).krate()\n     }\n \n     pub fn type_ref(self, db: &dyn HirDatabase) -> Option<TypeRef> {\n@@ -1483,9 +1483,42 @@ impl Impl {\n \n         inherent.all_impls().chain(trait_.all_impls()).map(Self::from).collect()\n     }\n-    pub fn for_trait(db: &dyn HirDatabase, krate: Crate, trait_: Trait) -> Vec<Impl> {\n-        let impls = db.trait_impls_in_crate(krate.id);\n-        impls.for_trait(trait_.id).map(Self::from).collect()\n+\n+    pub fn all_for_type(db: &dyn HirDatabase, Type { krate, ty }: Type) -> Vec<Impl> {\n+        let def_crates = match ty.value.def_crates(db, krate) {\n+            Some(def_crates) => def_crates,\n+            None => return vec![],\n+        };\n+\n+        let filter = |impl_def: &Impl| {\n+            let target_ty = impl_def.target_ty(db);\n+            let rref = target_ty.remove_ref();\n+            ty.value.equals_ctor(rref.as_ref().map_or(&target_ty.ty.value, |it| &it.ty.value))\n+        };\n+\n+        let mut all = Vec::new();\n+        def_crates.iter().for_each(|&id| {\n+            all.extend(db.inherent_impls_in_crate(id).all_impls().map(Self::from).filter(filter))\n+        });\n+        for id in def_crates\n+            .iter()\n+            .flat_map(|&id| Crate { id }.reverse_dependencies(db))\n+            .map(|Crate { id }| id)\n+            .chain(def_crates.iter().copied())\n+        {\n+            all.extend(db.trait_impls_in_crate(id).all_impls().map(Self::from).filter(filter));\n+        }\n+        all\n+    }\n+\n+    pub fn all_for_trait(db: &dyn HirDatabase, trait_: Trait) -> Vec<Impl> {\n+        let krate = trait_.module(db).krate();\n+        let mut all = Vec::new();\n+        for Crate { id } in krate.reverse_dependencies(db).into_iter().chain(Some(krate)) {\n+            let impls = db.trait_impls_in_crate(id);\n+            all.extend(impls.for_trait(trait_.id).map(Self::from))\n+        }\n+        all\n     }\n \n     // FIXME: the return type is wrong. This should be a hir version of\n@@ -1913,12 +1946,6 @@ impl Type {\n         self.ty.value.associated_type_parent_trait(db).map(Into::into)\n     }\n \n-    // FIXME: provide required accessors such that it becomes implementable from outside.\n-    pub fn is_equal_for_find_impls(&self, other: &Type) -> bool {\n-        let rref = other.remove_ref();\n-        self.ty.value.equals_ctor(rref.as_ref().map_or(&other.ty.value, |it| &it.ty.value))\n-    }\n-\n     fn derived(&self, ty: Ty) -> Type {\n         Type {\n             krate: self.krate,"}, {"sha": "f4d7c14a62e11c2cd48db7865c9cc203fe6cd060", "filename": "crates/ide/src/goto_implementation.rs", "status": "modified", "additions": 82, "deletions": 48, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/6c782a53148dc2f34be2eafbdf872ab6497632fd/crates%2Fide%2Fsrc%2Fgoto_implementation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c782a53148dc2f34be2eafbdf872ab6497632fd/crates%2Fide%2Fsrc%2Fgoto_implementation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fgoto_implementation.rs?ref=6c782a53148dc2f34be2eafbdf872ab6497632fd", "patch": "@@ -1,6 +1,9 @@\n-use hir::{Crate, Impl, Semantics};\n-use ide_db::RootDatabase;\n-use syntax::{algo::find_node_at_offset, ast, AstNode};\n+use hir::{Impl, Semantics};\n+use ide_db::{\n+    defs::{Definition, NameClass, NameRefClass},\n+    RootDatabase,\n+};\n+use syntax::{ast, AstNode};\n \n use crate::{display::TryToNav, FilePosition, NavigationTarget, RangeInfo};\n \n@@ -21,55 +24,42 @@ pub(crate) fn goto_implementation(\n     let source_file = sema.parse(position.file_id);\n     let syntax = source_file.syntax().clone();\n \n-    let krate = sema.to_module_def(position.file_id)?.krate();\n-\n-    if let Some(nominal_def) = find_node_at_offset::<ast::Adt>(&syntax, position.offset) {\n-        return Some(RangeInfo::new(\n-            nominal_def.syntax().text_range(),\n-            impls_for_def(&sema, &nominal_def, krate)?,\n-        ));\n-    } else if let Some(trait_def) = find_node_at_offset::<ast::Trait>(&syntax, position.offset) {\n-        return Some(RangeInfo::new(\n-            trait_def.syntax().text_range(),\n-            impls_for_trait(&sema, &trait_def, krate)?,\n-        ));\n-    }\n-\n-    None\n-}\n-\n-fn impls_for_def(\n-    sema: &Semantics<RootDatabase>,\n-    node: &ast::Adt,\n-    krate: Crate,\n-) -> Option<Vec<NavigationTarget>> {\n-    let ty = match node {\n-        ast::Adt::Struct(def) => sema.to_def(def)?.ty(sema.db),\n-        ast::Adt::Enum(def) => sema.to_def(def)?.ty(sema.db),\n-        ast::Adt::Union(def) => sema.to_def(def)?.ty(sema.db),\n+    let node = sema.find_node_at_offset_with_descend(&syntax, position.offset)?;\n+    let def = match &node {\n+        ast::NameLike::Name(name) => {\n+            NameClass::classify(&sema, name).map(|class| class.referenced_or_defined(sema.db))\n+        }\n+        ast::NameLike::NameRef(name_ref) => {\n+            NameRefClass::classify(&sema, name_ref).map(|class| class.referenced(sema.db))\n+        }\n+        ast::NameLike::Lifetime(_) => None,\n+    }?;\n+    let def = match def {\n+        Definition::ModuleDef(def) => def,\n+        _ => return None,\n     };\n-\n-    let impls = Impl::all_in_crate(sema.db, krate);\n-\n-    Some(\n-        impls\n-            .into_iter()\n-            .filter(|impl_def| ty.is_equal_for_find_impls(&impl_def.target_ty(sema.db)))\n-            .filter_map(|imp| imp.try_to_nav(sema.db))\n-            .collect(),\n-    )\n+    let navs = match def {\n+        hir::ModuleDef::Trait(trait_) => impls_for_trait(&sema, trait_),\n+        hir::ModuleDef::Adt(adt) => impls_for_ty(&sema, adt.ty(sema.db)),\n+        hir::ModuleDef::TypeAlias(alias) => impls_for_ty(&sema, alias.ty(sema.db)),\n+        hir::ModuleDef::BuiltinType(builtin) => {\n+            let module = sema.to_module_def(position.file_id)?;\n+            impls_for_ty(&sema, builtin.ty(sema.db, module))\n+        }\n+        _ => return None,\n+    };\n+    Some(RangeInfo { range: node.syntax().text_range(), info: navs })\n }\n \n-fn impls_for_trait(\n-    sema: &Semantics<RootDatabase>,\n-    node: &ast::Trait,\n-    krate: Crate,\n-) -> Option<Vec<NavigationTarget>> {\n-    let tr = sema.to_def(node)?;\n-\n-    let impls = Impl::for_trait(sema.db, krate, tr);\n+fn impls_for_ty(sema: &Semantics<RootDatabase>, ty: hir::Type) -> Vec<NavigationTarget> {\n+    Impl::all_for_type(sema.db, ty).into_iter().filter_map(|imp| imp.try_to_nav(sema.db)).collect()\n+}\n \n-    Some(impls.into_iter().filter_map(|imp| imp.try_to_nav(sema.db)).collect())\n+fn impls_for_trait(sema: &Semantics<RootDatabase>, trait_: hir::Trait) -> Vec<NavigationTarget> {\n+    Impl::all_for_trait(sema.db, trait_)\n+        .into_iter()\n+        .filter_map(|imp| imp.try_to_nav(sema.db))\n+        .collect()\n }\n \n #[cfg(test)]\n@@ -223,6 +213,50 @@ mod marker {\n }\n #[rustc_builtin_macro]\n macro Copy {}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn goto_implementation_type_alias() {\n+        check(\n+            r#\"\n+struct Foo;\n+\n+type Bar$0 = Foo;\n+\n+impl Foo {}\n+   //^^^\n+impl Bar {}\n+   //^^^\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn goto_implementation_adt_generic() {\n+        check(\n+            r#\"\n+struct Foo$0<T>;\n+\n+impl<T> Foo<T> {}\n+      //^^^^^^\n+impl Foo<str> {}\n+   //^^^^^^^^\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn goto_implementation_builtin() {\n+        check(\n+            r#\"\n+//- /lib.rs crate:main deps:core\n+fn foo(_: bool$0) {{}}\n+//- /libcore.rs crate:core\n+#[lang = \"bool\"]\n+impl bool {}\n+   //^^^^\n \"#,\n         );\n     }"}, {"sha": "16c04eeeeece33b273681c0435a71644adf522ce", "filename": "crates/ide/src/inlay_hints.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c782a53148dc2f34be2eafbdf872ab6497632fd/crates%2Fide%2Fsrc%2Finlay_hints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c782a53148dc2f34be2eafbdf872ab6497632fd/crates%2Fide%2Fsrc%2Finlay_hints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Finlay_hints.rs?ref=6c782a53148dc2f34be2eafbdf872ab6497632fd", "patch": "@@ -219,7 +219,7 @@ fn hint_iterator(\n     let strukt = std::iter::successors(Some(ty.clone()), |ty| ty.remove_ref())\n         .last()\n         .and_then(|strukt| strukt.as_adt())?;\n-    let krate = strukt.krate(db)?;\n+    let krate = strukt.krate(db);\n     if krate != famous_defs.core()? {\n         return None;\n     }"}]}