{"sha": "9cc8d8619062278046e678bbc08401b733a17236", "node_id": "C_kwDOAAsO6NoAKDljYzhkODYxOTA2MjI3ODA0NmU2NzhiYmMwODQwMWI3MzNhMTcyMzY", "commit": {"author": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2023-01-04T04:20:31Z"}, "committer": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2023-01-05T16:51:16Z"}, "message": "Tweak output\n\n- Only point at a the single expression where the found type was first\n  inferred.\n- Find method call argument that might have caused the found type to be\n  inferred.\n- Provide structured suggestion.\n- Apply some review comments.\n- Tweak wording.", "tree": {"sha": "d066f880488aeddab487ea88a3140d122b66369b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d066f880488aeddab487ea88a3140d122b66369b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9cc8d8619062278046e678bbc08401b733a17236", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9cc8d8619062278046e678bbc08401b733a17236", "html_url": "https://github.com/rust-lang/rust/commit/9cc8d8619062278046e678bbc08401b733a17236", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9cc8d8619062278046e678bbc08401b733a17236/comments", "author": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "committer": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6b0cce4b5018bcd1c7aed1f84cb0b86e3cc03f9f", "url": "https://api.github.com/repos/rust-lang/rust/commits/6b0cce4b5018bcd1c7aed1f84cb0b86e3cc03f9f", "html_url": "https://github.com/rust-lang/rust/commit/6b0cce4b5018bcd1c7aed1f84cb0b86e3cc03f9f"}], "stats": {"total": 301, "additions": 242, "deletions": 59}, "files": [{"sha": "317e9b5a7a1ec8fa82be8f8fae39d6ab592578c2", "filename": "compiler/rustc_hir_typeck/src/demand.rs", "status": "modified", "additions": 118, "deletions": 47, "changes": 165, "blob_url": "https://github.com/rust-lang/rust/blob/9cc8d8619062278046e678bbc08401b733a17236/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc8d8619062278046e678bbc08401b733a17236/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs?ref=9cc8d8619062278046e678bbc08401b733a17236", "patch": "@@ -1,5 +1,6 @@\n use crate::FnCtxt;\n use rustc_ast::util::parser::PREC_POSTFIX;\n+use rustc_data_structures::fx::FxHashMap;\n use rustc_errors::MultiSpan;\n use rustc_errors::{Applicability, Diagnostic, DiagnosticBuilder, ErrorGuaranteed};\n use rustc_hir as hir;\n@@ -14,12 +15,14 @@ use rustc_middle::ty::adjustment::AllowTwoPhase;\n use rustc_middle::ty::error::{ExpectedFound, TypeError};\n use rustc_middle::ty::fold::TypeFolder;\n use rustc_middle::ty::print::{with_forced_trimmed_paths, with_no_trimmed_paths};\n+use rustc_middle::ty::relate::TypeRelation;\n use rustc_middle::ty::{\n     self, Article, AssocItem, Ty, TyCtxt, TypeAndMut, TypeSuperFoldable, TypeVisitable,\n };\n use rustc_span::symbol::{sym, Symbol};\n use rustc_span::{BytePos, Span};\n use rustc_trait_selection::infer::InferCtxtExt as _;\n+use rustc_trait_selection::traits::error_reporting::method_chain::CollectAllMismatches;\n use rustc_trait_selection::traits::ObligationCause;\n \n use super::method::probe;\n@@ -44,7 +47,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         self.annotate_alternative_method_deref(err, expr, error);\n \n         // Use `||` to give these suggestions a precedence\n-        let _ = self.suggest_missing_parentheses(err, expr)\n+        let suggested = self.suggest_missing_parentheses(err, expr)\n             || self.suggest_remove_last_method_call(err, expr, expected)\n             || self.suggest_associated_const(err, expr, expected)\n             || self.suggest_deref_ref_or_into(err, expr, expected, expr_ty, expected_ty_expr)\n@@ -57,8 +60,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             || self.suggest_block_to_brackets_peeling_refs(err, expr, expr_ty, expected)\n             || self.suggest_copied_or_cloned(err, expr, expr_ty, expected)\n             || self.suggest_into(err, expr, expr_ty, expected)\n-            || self.suggest_floating_point_literal(err, expr, expected)\n-            || self.point_inference_types(err, expr);\n+            || self.suggest_floating_point_literal(err, expr, expected);\n+        if !suggested {\n+            self.point_at_expr_source_of_inferred_type(err, expr, expr_ty, expected);\n+        }\n     }\n \n     pub fn emit_coerce_suggestions(\n@@ -210,7 +215,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         (expected, Some(err))\n     }\n \n-    fn point_inference_types(&self, err: &mut Diagnostic, expr: &hir::Expr<'_>) -> bool {\n+    fn point_at_expr_source_of_inferred_type(\n+        &self,\n+        err: &mut Diagnostic,\n+        expr: &hir::Expr<'_>,\n+        found: Ty<'tcx>,\n+        expected: Ty<'tcx>,\n+    ) -> bool {\n         let tcx = self.tcx;\n         let map = self.tcx.hir();\n \n@@ -250,25 +261,17 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let hir::ExprKind::Path(hir::QPath::Resolved(None, p)) = expr.kind else { return false; };\n         let [hir::PathSegment { ident, args: None, .. }] = p.segments else { return false; };\n         let hir::def::Res::Local(hir_id) = p.res else { return false; };\n-        let Some(node) = map.find(hir_id) else { return false; };\n-        let hir::Node::Pat(pat) = node else { return false; };\n+        let Some(hir::Node::Pat(pat)) = map.find(hir_id) else { return false; };\n         let parent = map.get_parent_node(pat.hir_id);\n         let Some(hir::Node::Local(hir::Local {\n             ty: None,\n             init: Some(init),\n             ..\n         })) = map.find(parent) else { return false; };\n-\n-        let ty = self.node_ty(init.hir_id);\n+        let Some(ty) = self.node_ty_opt(init.hir_id) else { return false; };\n         if ty.is_closure() || init.span.overlaps(expr.span) || pat.span.from_expansion() {\n             return false;\n         }\n-        let mut span_labels = vec![(\n-            init.span,\n-            with_forced_trimmed_paths!(format!(\n-                \"here the type of `{ident}` is inferred to be `{ty}`\",\n-            )),\n-        )];\n \n         // Locate all the usages of the relevant binding.\n         struct FindExprs<'hir> {\n@@ -296,71 +299,139 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             expr_finder.visit_expr(body.value);\n             let mut eraser = TypeEraser { tcx };\n             let mut prev = eraser.fold_ty(ty);\n+            let mut prev_span = None;\n \n-            for ex in expr_finder.uses {\n-                if ex.span.overlaps(expr.span) { break; }\n-                let parent = map.get_parent_node(ex.hir_id);\n+            for binding in expr_finder.uses {\n+                // In every expression where the binding is referenced, we will look at that\n+                // expression's type and see if it is where the incorrect found type was fully\n+                // \"materialized\" and point at it. We will also try to provide a suggestion there.\n+                let parent = map.get_parent_node(binding.hir_id);\n                 if let Some(hir::Node::Expr(expr))\n                 | Some(hir::Node::Stmt(hir::Stmt {\n                     kind: hir::StmtKind::Expr(expr) | hir::StmtKind::Semi(expr),\n                     ..\n                 })) = &map.find(parent)\n-                    && let hir::ExprKind::MethodCall(s, rcvr, args, span) = expr.kind\n-                    && rcvr.hir_id == ex.hir_id\n+                    && let hir::ExprKind::MethodCall(s, rcvr, args, _span) = expr.kind\n+                    && rcvr.hir_id == binding.hir_id\n+                    && let Some(def_id) = self.typeck_results.borrow().type_dependent_def_id(expr.hir_id)\n                 {\n-                    let ty = if let Ok(m) = self.lookup_method(ty, s, span, expr, rcvr, args) {\n-                        // We get the self type from `lookup_method` because the `rcvr` node\n-                        // type will not have had any adjustments from the fn arguments.\n-                        let ty = m.sig.inputs_and_output[0];\n-                        match ty.kind() {\n-                            // Remove one layer of references to account for `&mut self` and\n-                            // `&self`, so that we can compare it against the binding.\n-                            ty::Ref(_, ty, _) => *ty,\n-                            _ => ty,\n+                    // We special case methods, because they can influence inference through the\n+                    // call's arguments and we can provide a more explicit span.\n+                    let sig = self.tcx.fn_sig(def_id);\n+                    let def_self_ty = sig.input(0).skip_binder();\n+                    let rcvr_ty = self.node_ty(rcvr.hir_id);\n+                    // Get the evaluated type *after* calling the method call, so that the influence\n+                    // of the arguments can be reflected in the receiver type. The receiver\n+                    // expression has the type *before* theis analysis is done.\n+                    let ty = match self.lookup_probe(s.ident, rcvr_ty, expr, probe::ProbeScope::TraitsInScope) {\n+                        Ok(pick) => pick.self_ty,\n+                        Err(_) => rcvr_ty,\n+                    };\n+                    // Remove one layer of references to account for `&mut self` and\n+                    // `&self`, so that we can compare it against the binding.\n+                    let (ty, def_self_ty) = match (ty.kind(), def_self_ty.kind()) {\n+                        (ty::Ref(_, ty, a), ty::Ref(_, self_ty, b)) if a == b => (*ty, *self_ty),\n+                        _ => (ty, def_self_ty),\n+                    };\n+                    let mut param_args = FxHashMap::default();\n+                    let mut param_expected = FxHashMap::default();\n+                    let mut param_found = FxHashMap::default();\n+                    if self.can_eq(self.param_env, ty, found).is_ok() {\n+                        // We only point at the first place where the found type was inferred.\n+                        for (i, param_ty) in sig.inputs().skip_binder().iter().skip(1).enumerate() {\n+                            if def_self_ty.contains(*param_ty) && let ty::Param(_) = param_ty.kind() {\n+                                // We found an argument that references a type parameter in `Self`,\n+                                // so we assume that this is the argument that caused the found\n+                                // type, which we know already because of `can_eq` above was first\n+                                // inferred in this method call.\n+                                let arg = &args[i];\n+                                let arg_ty = self.node_ty(arg.hir_id);\n+                                err.span_label(\n+                                    arg.span,\n+                                    &format!(\n+                                        \"this is of type `{arg_ty}`, which makes `{ident}` to be \\\n+                                         inferred as `{ty}`\",\n+                                    ),\n+                                );\n+                                param_args.insert(param_ty, (arg, arg_ty));\n+                            }\n                         }\n-                    } else {\n-                        self.node_ty(rcvr.hir_id)\n+                    }\n+\n+                    // Here we find, for a type param `T`, the type that `T` is in the current\n+                    // method call *and* in the original expected type. That way, we can see if we\n+                    // can give any structured suggestion for the function argument.\n+                    let mut c = CollectAllMismatches {\n+                        infcx: &self.infcx,\n+                        param_env: self.param_env,\n+                        errors: vec![],\n                     };\n+                    let _ = c.relate(def_self_ty, ty);\n+                    for error in c.errors {\n+                        if let TypeError::Sorts(error) = error {\n+                            param_found.insert(error.expected, error.found);\n+                        }\n+                    }\n+                    c.errors = vec![];\n+                    let _ = c.relate(def_self_ty, expected);\n+                    for error in c.errors {\n+                        if let TypeError::Sorts(error) = error {\n+                            param_expected.insert(error.expected, error.found);\n+                        }\n+                    }\n+                    for (param, (arg,arg_ty)) in param_args.iter() {\n+                        let Some(expected) = param_expected.get(param) else { continue; };\n+                        let Some(found) = param_found.get(param) else { continue; };\n+                        if self.can_eq(self.param_env, *arg_ty, *found).is_err() { continue; }\n+                        self.suggest_deref_ref_or_into(err, arg, *expected, *found, None);\n+                    }\n+\n                     let ty = eraser.fold_ty(ty);\n                     if ty.references_error() {\n                         break;\n                     }\n-                    if ty != prev {\n-                        span_labels.push((\n+                    if ty != prev\n+                        && param_args.is_empty()\n+                        && self.can_eq(self.param_env, ty, found).is_ok()\n+                    {\n+                        // We only point at the first place where the found type was inferred.\n+                        err.span_label(\n                             s.ident.span,\n                             with_forced_trimmed_paths!(format!(\n                                 \"here the type of `{ident}` is inferred to be `{ty}`\",\n                             )),\n-                        ));\n-                        prev = ty;\n+                        );\n+                        break;\n                     }\n+                    prev = ty;\n                 } else {\n-                    let ty = eraser.fold_ty(self.node_ty(ex.hir_id));\n+                    let ty = eraser.fold_ty(self.node_ty(binding.hir_id));\n                     if ty.references_error() {\n                         break;\n                     }\n-                    if ty != prev {\n-                        span_labels.push((\n-                            ex.span,\n+                    if ty != prev && let Some(span) = prev_span && self.can_eq(self.param_env, ty, found).is_ok() {\n+                        // We only point at the first place where the found type was inferred.\n+                        // We use the *previous* span because if the type is known *here* it means\n+                        // it was *evaluated earlier*. We don't do this for method calls because we\n+                        // evaluate the method's self type eagerly, but not in any other case.\n+                        err.span_label(\n+                            span,\n                             with_forced_trimmed_paths!(format!(\n                                 \"here the type of `{ident}` is inferred to be `{ty}`\",\n                             )),\n-                        ));\n+                        );\n+                        break;\n                     }\n                     prev = ty;\n                 }\n-                if ex.hir_id == expr.hir_id {\n-                    // Stop showing spans after the error type was emitted.\n+                if binding.hir_id == expr.hir_id {\n+                    // Do not look at expressions that come after the expression we were originally\n+                    // evaluating and had a type error.\n                     break;\n                 }\n+                prev_span = Some(binding.span);\n             }\n         }\n-        if span_labels.len() < 2 {\n-            return false;\n-        }\n-        for (sp, label) in span_labels {\n-            err.span_label(sp, &label);\n-        }\n         true\n     }\n "}, {"sha": "de133e5599cf96fb8d0efce000d83a58eb5f957f", "filename": "src/test/ui/type/type-check/assignment-in-if.stderr", "status": "modified", "additions": 3, "deletions": 12, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/9cc8d8619062278046e678bbc08401b733a17236/src%2Ftest%2Fui%2Ftype%2Ftype-check%2Fassignment-in-if.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9cc8d8619062278046e678bbc08401b733a17236/src%2Ftest%2Fui%2Ftype%2Ftype-check%2Fassignment-in-if.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype%2Ftype-check%2Fassignment-in-if.stderr?ref=9cc8d8619062278046e678bbc08401b733a17236", "patch": "@@ -67,10 +67,7 @@ LL |             x == 5\n error[E0308]: mismatched types\n   --> $DIR/assignment-in-if.rs:44:18\n    |\n-LL |     let x = 1;\n-   |             - here the type of `x` is inferred to be `{integer}`\n-...\n-LL |         println!(\"{}\", x);\n+LL |     if y = (Foo { foo: x }) {\n    |                        - here the type of `x` is inferred to be `usize`\n ...\n LL |     if x == x && x = x && x == x {\n@@ -81,10 +78,7 @@ LL |     if x == x && x = x && x == x {\n error[E0308]: mismatched types\n   --> $DIR/assignment-in-if.rs:44:22\n    |\n-LL |     let x = 1;\n-   |             - here the type of `x` is inferred to be `{integer}`\n-...\n-LL |         println!(\"{}\", x);\n+LL |     if y = (Foo { foo: x }) {\n    |                        - here the type of `x` is inferred to be `usize`\n ...\n LL |     if x == x && x = x && x == x {\n@@ -104,10 +98,7 @@ LL |     if x == x && x == x && x == x {\n error[E0308]: mismatched types\n   --> $DIR/assignment-in-if.rs:51:28\n    |\n-LL |     let x = 1;\n-   |             - here the type of `x` is inferred to be `{integer}`\n-...\n-LL |         println!(\"{}\", x);\n+LL |     if y = (Foo { foo: x }) {\n    |                        - here the type of `x` is inferred to be `usize`\n ...\n LL |     if x == x && x == x && x = x {"}, {"sha": "6557d7fa1911afc3fa5ea3a871c762b3fffdf468", "filename": "src/test/ui/type/type-check/point-at-inference-2.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/9cc8d8619062278046e678bbc08401b733a17236/src%2Ftest%2Fui%2Ftype%2Ftype-check%2Fpoint-at-inference-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc8d8619062278046e678bbc08401b733a17236/src%2Ftest%2Fui%2Ftype%2Ftype-check%2Fpoint-at-inference-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype%2Ftype-check%2Fpoint-at-inference-2.rs?ref=9cc8d8619062278046e678bbc08401b733a17236", "patch": "@@ -0,0 +1,13 @@\n+fn bar(_: Vec<i32>) {}\n+fn baz(_: &Vec<&i32>) {}\n+fn main() {\n+    let v = vec![&1];\n+    bar(v); //~ ERROR E0308\n+    let v = vec![];\n+    baz(&v);\n+    baz(&v);\n+    bar(v); //~ ERROR E0308\n+    let v = vec![];\n+    baz(&v);\n+    bar(v); //~ ERROR E0308\n+}"}, {"sha": "13227c5e245bdf9748ab3a4f4f398e09d5ce05b2", "filename": "src/test/ui/type/type-check/point-at-inference-2.stderr", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/9cc8d8619062278046e678bbc08401b733a17236/src%2Ftest%2Fui%2Ftype%2Ftype-check%2Fpoint-at-inference-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9cc8d8619062278046e678bbc08401b733a17236/src%2Ftest%2Fui%2Ftype%2Ftype-check%2Fpoint-at-inference-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype%2Ftype-check%2Fpoint-at-inference-2.stderr?ref=9cc8d8619062278046e678bbc08401b733a17236", "patch": "@@ -0,0 +1,56 @@\n+error[E0308]: mismatched types\n+  --> $DIR/point-at-inference-2.rs:5:9\n+   |\n+LL |     bar(v);\n+   |     --- ^ expected `i32`, found `&{integer}`\n+   |     |\n+   |     arguments to this function are incorrect\n+   |\n+   = note: expected struct `Vec<i32>`\n+              found struct `Vec<&{integer}>`\n+note: function defined here\n+  --> $DIR/point-at-inference-2.rs:1:4\n+   |\n+LL | fn bar(_: Vec<i32>) {}\n+   |    ^^^ -----------\n+\n+error[E0308]: mismatched types\n+  --> $DIR/point-at-inference-2.rs:9:9\n+   |\n+LL |     baz(&v);\n+   |          - here the type of `v` is inferred to be `Vec<&i32>`\n+LL |     baz(&v);\n+LL |     bar(v);\n+   |     --- ^ expected `i32`, found `&i32`\n+   |     |\n+   |     arguments to this function are incorrect\n+   |\n+   = note: expected struct `Vec<i32>`\n+              found struct `Vec<&i32>`\n+note: function defined here\n+  --> $DIR/point-at-inference-2.rs:1:4\n+   |\n+LL | fn bar(_: Vec<i32>) {}\n+   |    ^^^ -----------\n+\n+error[E0308]: mismatched types\n+  --> $DIR/point-at-inference-2.rs:12:9\n+   |\n+LL |     baz(&v);\n+   |          - here the type of `v` is inferred to be `Vec<&i32>`\n+LL |     bar(v);\n+   |     --- ^ expected `i32`, found `&i32`\n+   |     |\n+   |     arguments to this function are incorrect\n+   |\n+   = note: expected struct `Vec<i32>`\n+              found struct `Vec<&i32>`\n+note: function defined here\n+  --> $DIR/point-at-inference-2.rs:1:4\n+   |\n+LL | fn bar(_: Vec<i32>) {}\n+   |    ^^^ -----------\n+\n+error: aborting due to 3 previous errors\n+\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "f41fbe59fba6c26b67786c9791f1bebc0d930273", "filename": "src/test/ui/type/type-check/point-at-inference.fixed", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/9cc8d8619062278046e678bbc08401b733a17236/src%2Ftest%2Fui%2Ftype%2Ftype-check%2Fpoint-at-inference.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/9cc8d8619062278046e678bbc08401b733a17236/src%2Ftest%2Fui%2Ftype%2Ftype-check%2Fpoint-at-inference.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype%2Ftype-check%2Fpoint-at-inference.fixed?ref=9cc8d8619062278046e678bbc08401b733a17236", "patch": "@@ -0,0 +1,13 @@\n+// run-rustfix\n+fn bar(_: Vec<i32>) {}\n+fn baz(_: &impl std::any::Any) {}\n+fn main() {\n+    let v = vec![1, 2, 3, 4, 5];\n+    let mut foo = vec![];\n+    baz(&foo);\n+    for i in &v {\n+        foo.push(*i);\n+    }\n+    baz(&foo);\n+    bar(foo); //~ ERROR E0308\n+}"}, {"sha": "6419e42e70d12512c8bab82eac5d40f5f6a79e7a", "filename": "src/test/ui/type/type-check/point-at-inference.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/9cc8d8619062278046e678bbc08401b733a17236/src%2Ftest%2Fui%2Ftype%2Ftype-check%2Fpoint-at-inference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc8d8619062278046e678bbc08401b733a17236/src%2Ftest%2Fui%2Ftype%2Ftype-check%2Fpoint-at-inference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype%2Ftype-check%2Fpoint-at-inference.rs?ref=9cc8d8619062278046e678bbc08401b733a17236", "patch": "@@ -0,0 +1,13 @@\n+// run-rustfix\n+fn bar(_: Vec<i32>) {}\n+fn baz(_: &impl std::any::Any) {}\n+fn main() {\n+    let v = vec![1, 2, 3, 4, 5];\n+    let mut foo = vec![];\n+    baz(&foo);\n+    for i in &v {\n+        foo.push(i);\n+    }\n+    baz(&foo);\n+    bar(foo); //~ ERROR E0308\n+}"}, {"sha": "197511bf64ef22aedddc0a214d8634cb61359f13", "filename": "src/test/ui/type/type-check/point-at-inference.stderr", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/9cc8d8619062278046e678bbc08401b733a17236/src%2Ftest%2Fui%2Ftype%2Ftype-check%2Fpoint-at-inference.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9cc8d8619062278046e678bbc08401b733a17236/src%2Ftest%2Fui%2Ftype%2Ftype-check%2Fpoint-at-inference.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype%2Ftype-check%2Fpoint-at-inference.stderr?ref=9cc8d8619062278046e678bbc08401b733a17236", "patch": "@@ -0,0 +1,26 @@\n+error[E0308]: mismatched types\n+  --> $DIR/point-at-inference.rs:12:9\n+   |\n+LL |         foo.push(i);\n+   |                  - this is of type `&{integer}`, which makes `foo` to be inferred as `Vec<&{integer}>`\n+...\n+LL |     bar(foo);\n+   |     --- ^^^ expected `i32`, found `&{integer}`\n+   |     |\n+   |     arguments to this function are incorrect\n+   |\n+   = note: expected struct `Vec<i32>`\n+              found struct `Vec<&{integer}>`\n+note: function defined here\n+  --> $DIR/point-at-inference.rs:2:4\n+   |\n+LL | fn bar(_: Vec<i32>) {}\n+   |    ^^^ -----------\n+help: consider dereferencing the borrow\n+   |\n+LL |         foo.push(*i);\n+   |                  +\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0308`."}]}