{"sha": "3ca6ad922eb6d8c3139d961c844a0194eaf58770", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNjYTZhZDkyMmViNmQ4YzMxMzlkOTYxYzg0NGEwMTk0ZWFmNTg3NzA=", "commit": {"author": {"name": "Anthony Ramine", "email": "n.oxyde@gmail.com", "date": "2018-03-27T14:44:03Z"}, "committer": {"name": "Anthony Ramine", "email": "n.oxyde@gmail.com", "date": "2018-04-26T07:30:28Z"}, "message": "Use ScalarPair for tagged enums", "tree": {"sha": "f0de8bfeefb091683dbd0f7d2f4398a9fc79fe21", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f0de8bfeefb091683dbd0f7d2f4398a9fc79fe21"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3ca6ad922eb6d8c3139d961c844a0194eaf58770", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3ca6ad922eb6d8c3139d961c844a0194eaf58770", "html_url": "https://github.com/rust-lang/rust/commit/3ca6ad922eb6d8c3139d961c844a0194eaf58770", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3ca6ad922eb6d8c3139d961c844a0194eaf58770/comments", "author": {"login": "nox", "id": 123095, "node_id": "MDQ6VXNlcjEyMzA5NQ==", "avatar_url": "https://avatars.githubusercontent.com/u/123095?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nox", "html_url": "https://github.com/nox", "followers_url": "https://api.github.com/users/nox/followers", "following_url": "https://api.github.com/users/nox/following{/other_user}", "gists_url": "https://api.github.com/users/nox/gists{/gist_id}", "starred_url": "https://api.github.com/users/nox/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nox/subscriptions", "organizations_url": "https://api.github.com/users/nox/orgs", "repos_url": "https://api.github.com/users/nox/repos", "events_url": "https://api.github.com/users/nox/events{/privacy}", "received_events_url": "https://api.github.com/users/nox/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nox", "id": 123095, "node_id": "MDQ6VXNlcjEyMzA5NQ==", "avatar_url": "https://avatars.githubusercontent.com/u/123095?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nox", "html_url": "https://github.com/nox", "followers_url": "https://api.github.com/users/nox/followers", "following_url": "https://api.github.com/users/nox/following{/other_user}", "gists_url": "https://api.github.com/users/nox/gists{/gist_id}", "starred_url": "https://api.github.com/users/nox/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nox/subscriptions", "organizations_url": "https://api.github.com/users/nox/orgs", "repos_url": "https://api.github.com/users/nox/repos", "events_url": "https://api.github.com/users/nox/events{/privacy}", "received_events_url": "https://api.github.com/users/nox/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "65d201f7d682ad921ac6e67ac07f922aa63a8ce4", "url": "https://api.github.com/repos/rust-lang/rust/commits/65d201f7d682ad921ac6e67ac07f922aa63a8ce4", "html_url": "https://github.com/rust-lang/rust/commit/65d201f7d682ad921ac6e67ac07f922aa63a8ce4"}], "stats": {"total": 104, "additions": 90, "deletions": 14}, "files": [{"sha": "cfed0839acbdb13482de0e4b331bd243536ab00f", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 73, "deletions": 8, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/3ca6ad922eb6d8c3139d961c844a0194eaf58770/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ca6ad922eb6d8c3139d961c844a0194eaf58770/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=3ca6ad922eb6d8c3139d961c844a0194eaf58770", "patch": "@@ -1622,7 +1622,7 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n                 }\n \n                 // Create the set of structs that represent each variant.\n-                let mut variants = variants.into_iter().enumerate().map(|(i, field_layouts)| {\n+                let mut layout_variants = variants.iter().enumerate().map(|(i, field_layouts)| {\n                     let mut st = univariant_uninterned(&field_layouts,\n                         &def.repr, StructKind::Prefixed(min_ity.size(), prefix_align))?;\n                     st.variants = Variants::Single { index: i };\n@@ -1683,7 +1683,7 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n                     // Patch up the variants' first few fields.\n                     let old_ity_size = min_ity.size();\n                     let new_ity_size = ity.size();\n-                    for variant in &mut variants {\n+                    for variant in &mut layout_variants {\n                         if variant.abi == Abi::Uninhabited {\n                             continue;\n                         }\n@@ -1710,15 +1710,80 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n                     value: Int(ity, signed),\n                     valid_range: (min as u128 & tag_mask)..=(max as u128 & tag_mask),\n                 };\n-                let abi = if tag.value.size(dl) == size {\n-                    Abi::Scalar(tag.clone())\n-                } else {\n-                    Abi::Aggregate { sized: true }\n-                };\n+                let mut abi = Abi::Aggregate { sized: true };\n+                if tag.value.size(dl) == size {\n+                    abi = Abi::Scalar(tag.clone());\n+                } else if !tag.is_bool() {\n+                    // HACK(nox): Blindly using ScalarPair for all tagged enums\n+                    // where applicable leads to Option<u8> being handled as {i1, i8},\n+                    // which later confuses SROA and some loop optimisations,\n+                    // ultimately leading to the repeat-trusted-len test\n+                    // failing. We make the trade-off of using ScalarPair only\n+                    // for types where the tag isn't a boolean.\n+                    let mut common_prim = None;\n+                    for (field_layouts, layout_variant) in variants.iter().zip(&layout_variants) {\n+                        let offsets = match layout_variant.fields {\n+                            FieldPlacement::Arbitrary { ref offsets, .. } => offsets,\n+                            _ => bug!(),\n+                        };\n+                        let mut fields = field_layouts\n+                            .iter()\n+                            .zip(offsets)\n+                            .filter(|p| !p.0.is_zst());\n+                        let (field, offset) = match (fields.next(), fields.next()) {\n+                            (None, None) => continue,\n+                            (Some(pair), None) => pair,\n+                            _ => {\n+                                common_prim = None;\n+                                break;\n+                            }\n+                        };\n+                        let prim = match field.details.abi {\n+                            Abi::Scalar(ref scalar) => scalar.value,\n+                            _ => {\n+                                common_prim = None;\n+                                break;\n+                            }\n+                        };\n+                        if let Some(pair) = common_prim {\n+                            // This is pretty conservative. We could go fancier\n+                            // by conflating things like i32 and u32, or even\n+                            // realising that (u8, u8) could just cohabit with\n+                            // u16 or even u32.\n+                            if pair != (prim, offset) {\n+                                common_prim = None;\n+                                break;\n+                            }\n+                        } else {\n+                            common_prim = Some((prim, offset));\n+                        }\n+                    }\n+                    if let Some((prim, offset)) = common_prim {\n+                        let pair = scalar_pair(tag.clone(), scalar_unit(prim));\n+                        let pair_offsets = match pair.fields {\n+                            FieldPlacement::Arbitrary {\n+                                ref offsets,\n+                                ref memory_index\n+                            } => {\n+                                assert_eq!(memory_index, &[0, 1]);\n+                                offsets\n+                            }\n+                            _ => bug!()\n+                        };\n+                        if pair_offsets[0] == Size::from_bytes(0) &&\n+                            pair_offsets[1] == *offset &&\n+                            align == pair.align &&\n+                            size == pair.size {\n+                            // We can use `ScalarPair` only when it matches our\n+                            // already computed layout (including `#[repr(C)]`).\n+                            abi = pair.abi;\n+                        }\n+                    }\n+                }\n                 tcx.intern_layout(LayoutDetails {\n                     variants: Variants::Tagged {\n                         discr: tag,\n-                        variants\n+                        variants: layout_variants,\n                     },\n                     fields: FieldPlacement::Arbitrary {\n                         offsets: vec![Size::from_bytes(0)],"}, {"sha": "f306608f4328eca67009df4d9ed38b54bcae8bd7", "filename": "src/test/codegen/align-struct.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3ca6ad922eb6d8c3139d961c844a0194eaf58770/src%2Ftest%2Fcodegen%2Falign-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ca6ad922eb6d8c3139d961c844a0194eaf58770/src%2Ftest%2Fcodegen%2Falign-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Falign-struct.rs?ref=3ca6ad922eb6d8c3139d961c844a0194eaf58770", "patch": "@@ -29,7 +29,6 @@ pub enum Enum4 {\n     A(i32),\n     B(i32),\n }\n-// CHECK: %Enum4 = type { [0 x i32], i32, [1 x i32] }\n // CHECK: %\"Enum4::A\" = type { [1 x i32], i32, [0 x i32] }\n \n pub enum Enum64 {\n@@ -59,7 +58,7 @@ pub fn nested64(a: Align64, b: i32, c: i32, d: i8) -> Nested64 {\n // CHECK-LABEL: @enum4\n #[no_mangle]\n pub fn enum4(a: i32) -> Enum4 {\n-// CHECK: %e4 = alloca %Enum4, align 4\n+// CHECK: %e4 = alloca { i32, i32 }, align 4\n     let e4 = Enum4::A(a);\n     e4\n }"}, {"sha": "40a9ea5a181392313fa415910297f5a107a6b39c", "filename": "src/test/codegen/function-arguments.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3ca6ad922eb6d8c3139d961c844a0194eaf58770/src%2Ftest%2Fcodegen%2Ffunction-arguments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ca6ad922eb6d8c3139d961c844a0194eaf58770/src%2Ftest%2Fcodegen%2Ffunction-arguments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Ffunction-arguments.rs?ref=3ca6ad922eb6d8c3139d961c844a0194eaf58770", "patch": "@@ -145,6 +145,18 @@ pub fn return_slice(x: &[u16]) -> &[u16] {\n   x\n }\n \n+// CHECK: { i16, i16 } @enum_id_1(i16 %x.0, i16 %x.1)\n+#[no_mangle]\n+pub fn enum_id_1(x: Option<Result<u16, u16>>) -> Option<Result<u16, u16>> {\n+  x\n+}\n+\n+// CHECK: i16 @enum_id_2(i16)\n+#[no_mangle]\n+pub fn enum_id_2(x: Option<u8>) -> Option<u8> {\n+  x\n+}\n+\n // CHECK: noalias i8* @allocator()\n #[no_mangle]\n #[allocator]"}, {"sha": "ea3f0de5d082ecf114fc4c0dae9d18ab1f3f4370", "filename": "src/test/codegen/lifetime_start_end.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3ca6ad922eb6d8c3139d961c844a0194eaf58770/src%2Ftest%2Fcodegen%2Flifetime_start_end.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ca6ad922eb6d8c3139d961c844a0194eaf58770/src%2Ftest%2Fcodegen%2Flifetime_start_end.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Flifetime_start_end.rs?ref=3ca6ad922eb6d8c3139d961c844a0194eaf58770", "patch": "@@ -25,16 +25,16 @@ pub fn test() {\n         let b = &Some(a);\n         &b; // keep variable in an alloca\n \n-// CHECK: [[S_b:%[0-9]+]] = bitcast %\"core::option::Option<i32>\"** %b to i8*\n+// CHECK: [[S_b:%[0-9]+]] = bitcast { i32, i32 }** %b to i8*\n // CHECK: call void @llvm.lifetime.start{{.*}}(i{{[0-9 ]+}}, i8* [[S_b]])\n \n-// CHECK: [[S__4:%[0-9]+]] = bitcast %\"core::option::Option<i32>\"* %_4 to i8*\n+// CHECK: [[S__4:%[0-9]+]] = bitcast { i32, i32 }* %_4 to i8*\n // CHECK: call void @llvm.lifetime.start{{.*}}(i{{[0-9 ]+}}, i8* [[S__4]])\n \n-// CHECK: [[E_b:%[0-9]+]] = bitcast %\"core::option::Option<i32>\"** %b to i8*\n+// CHECK: [[E_b:%[0-9]+]] = bitcast { i32, i32 }** %b to i8*\n // CHECK: call void @llvm.lifetime.end{{.*}}(i{{[0-9 ]+}}, i8* [[E_b]])\n \n-// CHECK: [[E__4:%[0-9]+]] = bitcast %\"core::option::Option<i32>\"* %_4 to i8*\n+// CHECK: [[E__4:%[0-9]+]] = bitcast { i32, i32 }* %_4 to i8*\n // CHECK: call void @llvm.lifetime.end{{.*}}(i{{[0-9 ]+}}, i8* [[E__4]])\n     }\n "}]}