{"sha": "a849da626d8e47265e6a70e1ff24997b935626bd", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE4NDlkYTYyNmQ4ZTQ3MjY1ZTZhNzBlMWZmMjQ5OTdiOTM1NjI2YmQ=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-04-07T09:53:44Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-04-15T11:06:29Z"}, "message": "remove `ReserveOrActivateIndex`", "tree": {"sha": "414749359602d60bfb7cc0c86dcf1971becf0392", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/414749359602d60bfb7cc0c86dcf1971becf0392"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a849da626d8e47265e6a70e1ff24997b935626bd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a849da626d8e47265e6a70e1ff24997b935626bd", "html_url": "https://github.com/rust-lang/rust/commit/a849da626d8e47265e6a70e1ff24997b935626bd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a849da626d8e47265e6a70e1ff24997b935626bd/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d32e5aac3d517ae4c8709a3a865260a88316bed2", "url": "https://api.github.com/repos/rust-lang/rust/commits/d32e5aac3d517ae4c8709a3a865260a88316bed2", "html_url": "https://github.com/rust-lang/rust/commit/d32e5aac3d517ae4c8709a3a865260a88316bed2"}], "stats": {"total": 108, "additions": 28, "deletions": 80}, "files": [{"sha": "b5cfdee6a454c4bc717abd187f2fd8b8fce72dee", "filename": "src/librustc_mir/borrow_check/flows.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a849da626d8e47265e6a70e1ff24997b935626bd/src%2Flibrustc_mir%2Fborrow_check%2Fflows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a849da626d8e47265e6a70e1ff24997b935626bd/src%2Flibrustc_mir%2Fborrow_check%2Fflows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fflows.rs?ref=a849da626d8e47265e6a70e1ff24997b935626bd", "patch": "@@ -88,9 +88,8 @@ impl<'b, 'gcx, 'tcx> fmt::Display for Flows<'b, 'gcx, 'tcx> {\n                 s.push_str(\", \");\n             };\n             saw_one = true;\n-            let borrow_data = &self.borrows.operator().borrows()[borrow.borrow_index()];\n-            s.push_str(&format!(\"{}{}\", borrow_data,\n-                                if borrow.is_activation() { \"@active\" } else { \"\" }));\n+            let borrow_data = &self.borrows.operator().borrows()[borrow];\n+            s.push_str(&format!(\"{}\", borrow_data));\n         });\n         s.push_str(\"] \");\n \n@@ -101,7 +100,7 @@ impl<'b, 'gcx, 'tcx> fmt::Display for Flows<'b, 'gcx, 'tcx> {\n                 s.push_str(\", \");\n             };\n             saw_one = true;\n-            let borrow_data = &self.borrows.operator().borrows()[borrow.borrow_index()];\n+            let borrow_data = &self.borrows.operator().borrows()[borrow];\n             s.push_str(&format!(\"{}\", borrow_data));\n         });\n         s.push_str(\"] \");"}, {"sha": "962356c64010e06c72d410d00e77f5d1e387595a", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 5, "deletions": 14, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/a849da626d8e47265e6a70e1ff24997b935626bd/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a849da626d8e47265e6a70e1ff24997b935626bd/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=a849da626d8e47265e6a70e1ff24997b935626bd", "patch": "@@ -220,9 +220,7 @@ fn do_mir_borrowck<'a, 'gcx, 'tcx>(\n         &attributes,\n         &dead_unwinds,\n         Borrows::new(tcx, mir, opt_regioncx.clone(), def_id, body_id, borrow_set),\n-        |rs, i| {\n-            DebugFormatted::new(&(i.kind(), rs.location(i.borrow_index())))\n-        }\n+        |rs, i| DebugFormatted::new(&rs.location(i)),\n     ));\n \n     let movable_generator = !match tcx.hir.get(id) {\n@@ -549,7 +547,7 @@ impl<'cx, 'gcx, 'tcx> DataflowResultsConsumer<'cx, 'tcx> for MirBorrowckCtxt<'cx\n                     let data = domain.borrows();\n                     flow_state.borrows.with_iter_outgoing(|borrows| {\n                         for i in borrows {\n-                            let borrow = &data[i.borrow_index()];\n+                            let borrow = &data[i];\n                             self.check_for_local_borrow(borrow, span);\n                         }\n                     });\n@@ -565,7 +563,7 @@ impl<'cx, 'gcx, 'tcx> DataflowResultsConsumer<'cx, 'tcx> for MirBorrowckCtxt<'cx\n                 let data = domain.borrows();\n                 flow_state.borrows.with_iter_outgoing(|borrows| {\n                     for i in borrows {\n-                        let borrow = &data[i.borrow_index()];\n+                        let borrow = &data[i];\n                         let context = ContextKind::StorageDead.new(loc);\n                         self.check_for_invalidation_at_exit(context, borrow, span, flow_state);\n                     }\n@@ -2245,21 +2243,14 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         // borrows of P, P.a.b, etc.\n         let mut iter_incoming = flow_state.borrows.iter_incoming();\n         while let Some(i) = iter_incoming.next() {\n-            // TODO -- for now, just skip activations, since\n-            // everywhere that activation is set, reservation should\n-            // be set\n-            if i.is_activation() {\n-                continue;\n-            }\n-\n-            let borrowed = &data[i.borrow_index()];\n+            let borrowed = &data[i];\n \n             if self.places_conflict(&borrowed.borrowed_place, place, access) {\n                 debug!(\n                     \"each_borrow_involving_path: {:?} @ {:?} vs. {:?}/{:?}\",\n                     i, borrowed, place, access\n                 );\n-                let ctrl = op(self, i.borrow_index(), borrowed);\n+                let ctrl = op(self, i, borrowed);\n                 if ctrl == Control::Break {\n                     return;\n                 }"}, {"sha": "19f5ad5589e8832251dc7326ee48935a3c9d9d5b", "filename": "src/librustc_mir/dataflow/impls/borrows.rs", "status": "modified", "additions": 20, "deletions": 59, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/a849da626d8e47265e6a70e1ff24997b935626bd/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a849da626d8e47265e6a70e1ff24997b935626bd/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs?ref=a849da626d8e47265e6a70e1ff24997b935626bd", "patch": "@@ -20,13 +20,13 @@ use rustc::ty::{Region, TyCtxt};\n use rustc::ty::RegionKind;\n use rustc::ty::RegionKind::ReScope;\n \n-use rustc_data_structures::bitslice::{BitwiseOperator};\n-use rustc_data_structures::indexed_set::{IdxSet};\n-use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n+use rustc_data_structures::bitslice::BitwiseOperator;\n+use rustc_data_structures::indexed_set::IdxSet;\n+use rustc_data_structures::indexed_vec::IndexVec;\n use rustc_data_structures::sync::Lrc;\n \n use dataflow::{BitDenotation, BlockSets, InitialFlow};\n-pub use dataflow::indexes::{BorrowIndex, ReserveOrActivateIndex};\n+pub use dataflow::indexes::BorrowIndex;\n use borrow_check::nll::region_infer::RegionInferenceContext;\n use borrow_check::nll::ToRegionVid;\n \n@@ -53,21 +53,6 @@ pub struct Borrows<'a, 'gcx: 'tcx, 'tcx: 'a> {\n     nonlexical_regioncx: Option<Rc<RegionInferenceContext<'tcx>>>,\n }\n \n-impl ReserveOrActivateIndex {\n-    fn reserved(i: BorrowIndex) -> Self { ReserveOrActivateIndex::new(i.index() * 2) }\n-    fn active(i: BorrowIndex) -> Self { ReserveOrActivateIndex::new((i.index() * 2) + 1) }\n-\n-    pub(crate) fn is_reservation(self) -> bool { self.index() % 2 == 0 }\n-    pub(crate) fn is_activation(self) -> bool { self.index() % 2 == 1}\n-\n-    pub(crate) fn kind(self) -> &'static str {\n-        if self.is_reservation() { \"reserved\" } else { \"active\" }\n-    }\n-    pub(crate) fn borrow_index(self) -> BorrowIndex {\n-        BorrowIndex::new(self.index() / 2)\n-    }\n-}\n-\n impl<'a, 'gcx, 'tcx> Borrows<'a, 'gcx, 'tcx> {\n     crate fn new(\n         tcx: TyCtxt<'a, 'gcx, 'tcx>,\n@@ -120,7 +105,7 @@ impl<'a, 'gcx, 'tcx> Borrows<'a, 'gcx, 'tcx> {\n     /// That means either they went out of either a nonlexical scope, if we care about those\n     /// at the moment, or the location represents a lexical EndRegion\n     fn kill_loans_out_of_scope_at_location(&self,\n-                                           sets: &mut BlockSets<ReserveOrActivateIndex>,\n+                                           sets: &mut BlockSets<BorrowIndex>,\n                                            location: Location) {\n         if let Some(ref regioncx) = self.nonlexical_regioncx {\n             // NOTE: The state associated with a given `location`\n@@ -137,22 +122,18 @@ impl<'a, 'gcx, 'tcx> Borrows<'a, 'gcx, 'tcx> {\n             for (borrow_index, borrow_data) in self.borrow_set.borrows.iter_enumerated() {\n                 let borrow_region = borrow_data.region.to_region_vid();\n                 if !regioncx.region_contains_point(borrow_region, location) {\n-                    sets.kill(&ReserveOrActivateIndex::reserved(borrow_index));\n-                    sets.kill(&ReserveOrActivateIndex::active(borrow_index));\n+                    sets.kill(&borrow_index);\n                 }\n             }\n         }\n     }\n \n     fn kill_borrows_on_local(&self,\n-                             sets: &mut BlockSets<ReserveOrActivateIndex>,\n+                             sets: &mut BlockSets<BorrowIndex>,\n                              local: &rustc::mir::Local)\n     {\n         if let Some(borrow_indexes) = self.borrow_set.local_map.get(local) {\n-            sets.kill_all(borrow_indexes.iter()\n-                          .map(|b| ReserveOrActivateIndex::reserved(*b)));\n-            sets.kill_all(borrow_indexes.iter()\n-                          .map(|b| ReserveOrActivateIndex::active(*b)));\n+            sets.kill_all(borrow_indexes);\n         }\n     }\n \n@@ -162,45 +143,29 @@ impl<'a, 'gcx, 'tcx> Borrows<'a, 'gcx, 'tcx> {\n             .map(|activations| &activations[..])\n             .unwrap_or(&[])\n     }\n-\n-    /// Performs the activations for a given location\n-    fn perform_activations_at_location(&self,\n-                                       sets: &mut BlockSets<ReserveOrActivateIndex>,\n-                                       location: Location) {\n-        // Handle activations\n-        match self.borrow_set.activation_map.get(&location) {\n-            Some(activations) => {\n-                for activated in activations {\n-                    debug!(\"activating borrow {:?}\", activated);\n-                    sets.gen(&ReserveOrActivateIndex::active(*activated))\n-                }\n-            }\n-            None => {}\n-        }\n-    }\n }\n \n impl<'a, 'gcx, 'tcx> BitDenotation for Borrows<'a, 'gcx, 'tcx> {\n-    type Idx = ReserveOrActivateIndex;\n+    type Idx = BorrowIndex;\n     fn name() -> &'static str { \"borrows\" }\n     fn bits_per_block(&self) -> usize {\n         self.borrow_set.borrows.len() * 2\n     }\n \n-    fn start_block_effect(&self, _entry_set: &mut IdxSet<ReserveOrActivateIndex>) {\n+    fn start_block_effect(&self, _entry_set: &mut IdxSet<BorrowIndex>) {\n         // no borrows of code region_scopes have been taken prior to\n         // function execution, so this method has no effect on\n         // `_sets`.\n     }\n \n     fn before_statement_effect(&self,\n-                               sets: &mut BlockSets<ReserveOrActivateIndex>,\n+                               sets: &mut BlockSets<BorrowIndex>,\n                                location: Location) {\n         debug!(\"Borrows::before_statement_effect sets: {:?} location: {:?}\", sets, location);\n         self.kill_loans_out_of_scope_at_location(sets, location);\n     }\n \n-    fn statement_effect(&self, sets: &mut BlockSets<ReserveOrActivateIndex>, location: Location) {\n+    fn statement_effect(&self, sets: &mut BlockSets<BorrowIndex>, location: Location) {\n         debug!(\"Borrows::statement_effect sets: {:?} location: {:?}\", sets, location);\n \n         let block = &self.mir.basic_blocks().get(location.block).unwrap_or_else(|| {\n@@ -210,7 +175,6 @@ impl<'a, 'gcx, 'tcx> BitDenotation for Borrows<'a, 'gcx, 'tcx> {\n             panic!(\"could not find statement at location {:?}\");\n         });\n \n-        self.perform_activations_at_location(sets, location);\n         self.kill_loans_out_of_scope_at_location(sets, location);\n \n         match stmt.kind {\n@@ -221,8 +185,7 @@ impl<'a, 'gcx, 'tcx> BitDenotation for Borrows<'a, 'gcx, 'tcx> {\n                 {\n                     assert!(self.nonlexical_regioncx.is_none());\n                     for idx in borrow_indexes {\n-                        sets.kill(&ReserveOrActivateIndex::reserved(*idx));\n-                        sets.kill(&ReserveOrActivateIndex::active(*idx));\n+                        sets.kill(idx);\n                     }\n                 } else {\n                     // (if there is no entry, then there are no borrows to be tracked)\n@@ -252,14 +215,14 @@ impl<'a, 'gcx, 'tcx> BitDenotation for Borrows<'a, 'gcx, 'tcx> {\n                     if let RegionKind::ReEmpty = region {\n                         // If the borrowed value dies before the borrow is used, the region for\n                         // the borrow can be empty. Don't track the borrow in that case.\n-                        sets.kill(&ReserveOrActivateIndex::active(*index));\n+                        sets.kill(&index);\n                         return\n                     }\n \n                     assert!(self.borrow_set.region_map.get(region).unwrap_or_else(|| {\n                         panic!(\"could not find BorrowIndexs for region {:?}\", region);\n                     }).contains(&index));\n-                    sets.gen(&ReserveOrActivateIndex::reserved(*index));\n+                    sets.gen(&index);\n \n                     // Issue #46746: Two-phase borrows handles\n                     // stmts of form `Tmp = &mut Borrow` ...\n@@ -270,7 +233,7 @@ impl<'a, 'gcx, 'tcx> BitDenotation for Borrows<'a, 'gcx, 'tcx> {\n                             // e.g. `box (&mut _)`. Current\n                             // conservative solution: force\n                             // immediate activation here.\n-                            sets.gen(&ReserveOrActivateIndex::active(*index));\n+                            sets.gen(&index);\n                         }\n                     }\n                 }\n@@ -306,21 +269,20 @@ impl<'a, 'gcx, 'tcx> BitDenotation for Borrows<'a, 'gcx, 'tcx> {\n     }\n \n     fn before_terminator_effect(&self,\n-                                sets: &mut BlockSets<ReserveOrActivateIndex>,\n+                                sets: &mut BlockSets<BorrowIndex>,\n                                 location: Location) {\n         debug!(\"Borrows::before_terminator_effect sets: {:?} location: {:?}\", sets, location);\n         self.kill_loans_out_of_scope_at_location(sets, location);\n     }\n \n-    fn terminator_effect(&self, sets: &mut BlockSets<ReserveOrActivateIndex>, location: Location) {\n+    fn terminator_effect(&self, sets: &mut BlockSets<BorrowIndex>, location: Location) {\n         debug!(\"Borrows::terminator_effect sets: {:?} location: {:?}\", sets, location);\n \n         let block = &self.mir.basic_blocks().get(location.block).unwrap_or_else(|| {\n             panic!(\"could not find block at location {:?}\", location);\n         });\n \n         let term = block.terminator();\n-        self.perform_activations_at_location(sets, location);\n         self.kill_loans_out_of_scope_at_location(sets, location);\n \n \n@@ -343,8 +305,7 @@ impl<'a, 'gcx, 'tcx> BitDenotation for Borrows<'a, 'gcx, 'tcx> {\n                             if *scope != root_scope &&\n                                 self.scope_tree.is_subscope_of(*scope, root_scope)\n                             {\n-                                sets.kill(&ReserveOrActivateIndex::reserved(borrow_index));\n-                                sets.kill(&ReserveOrActivateIndex::active(borrow_index));\n+                                sets.kill(&borrow_index);\n                             }\n                         }\n                     }\n@@ -365,7 +326,7 @@ impl<'a, 'gcx, 'tcx> BitDenotation for Borrows<'a, 'gcx, 'tcx> {\n     }\n \n     fn propagate_call_return(&self,\n-                             _in_out: &mut IdxSet<ReserveOrActivateIndex>,\n+                             _in_out: &mut IdxSet<BorrowIndex>,\n                              _call_bb: mir::BasicBlock,\n                              _dest_bb: mir::BasicBlock,\n                              _dest_place: &mir::Place) {"}, {"sha": "3a49e28f04187dbaf71b8e4e1bf7cd0cd1421f45", "filename": "src/librustc_mir/dataflow/move_paths/mod.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a849da626d8e47265e6a70e1ff24997b935626bd/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a849da626d8e47265e6a70e1ff24997b935626bd/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs?ref=a849da626d8e47265e6a70e1ff24997b935626bd", "patch": "@@ -65,9 +65,6 @@ pub(crate) mod indexes {\n \n     /// Index into Borrows.locations\n     new_index!(BorrowIndex, \"bw\");\n-\n-    /// Index into Reservations/Activations bitvector\n-    new_index!(ReserveOrActivateIndex, \"ra\");\n }\n \n pub use self::indexes::MovePathIndex;"}]}