{"sha": "865bbae685fbf9bd1583a3f1715dd8093c0cbda2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg2NWJiYWU2ODVmYmY5YmQxNTgzYTNmMTcxNWRkODA5M2MwY2JkYTI=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2010-10-18T23:15:25Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2010-10-18T23:15:25Z"}, "message": "More work on resolving names in rustc. Basic expr_name lookup working on items and args.", "tree": {"sha": "76ccfd49924368ddebaabe535ec02e9b654f7247", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/76ccfd49924368ddebaabe535ec02e9b654f7247"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/865bbae685fbf9bd1583a3f1715dd8093c0cbda2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/865bbae685fbf9bd1583a3f1715dd8093c0cbda2", "html_url": "https://github.com/rust-lang/rust/commit/865bbae685fbf9bd1583a3f1715dd8093c0cbda2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/865bbae685fbf9bd1583a3f1715dd8093c0cbda2/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "23a00fd09211e83be2c21ca944f5f6c11b6c665b", "url": "https://api.github.com/repos/rust-lang/rust/commits/23a00fd09211e83be2c21ca944f5f6c11b6c665b", "html_url": "https://github.com/rust-lang/rust/commit/23a00fd09211e83be2c21ca944f5f6c11b6c665b"}], "stats": {"total": 216, "additions": 123, "deletions": 93}, "files": [{"sha": "69030f3c8084ddaf86fced794a9d69e028226821", "filename": "src/comp/driver/rustc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/865bbae685fbf9bd1583a3f1715dd8093c0cbda2/src%2Fcomp%2Fdriver%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/865bbae685fbf9bd1583a3f1715dd8093c0cbda2/src%2Fcomp%2Fdriver%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fdriver%2Frustc.rs?ref=865bbae685fbf9bd1583a3f1715dd8093c0cbda2", "patch": "@@ -16,7 +16,7 @@ io fn main(vec[str] args) {\n   auto sess = session.session();\n   for (str filename in args) {\n       if (i > 0) {\n-          auto p = parser.new_parser(sess, filename);\n+          auto p = parser.new_parser(sess, 0, filename);\n           auto crate = parser.parse_crate(p);\n           crate = resolve.resolve_crate(sess, crate);\n           trans.trans_crate(sess, crate);"}, {"sha": "04c64bea0b170fb470d1247fe3357c5147cad7e5", "filename": "src/comp/front/ast.rs", "status": "modified", "additions": 18, "deletions": 23, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/865bbae685fbf9bd1583a3f1715dd8093c0cbda2/src%2Fcomp%2Ffront%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/865bbae685fbf9bd1583a3f1715dd8093c0cbda2/src%2Fcomp%2Ffront%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fast.rs?ref=865bbae685fbf9bd1583a3f1715dd8093c0cbda2", "patch": "@@ -12,20 +12,17 @@ type name = spanned[name_];\n type path = vec[name];\n \n type crate_num = int;\n-type slot_num = int;\n-type item_num = int;\n-\n-tag slot_id {\n-    id_slot(crate_num, slot_num);\n-}\n-\n-tag item_id {\n-    id_item(crate_num, slot_num);\n-}\n-\n-tag referent {\n-    ref_slot(slot_id);\n-    ref_item(item_id);\n+type def_num = int;\n+type def_id = tup(crate_num, def_num);\n+\n+tag def {\n+    def_fn(def_id);\n+    def_mod(def_id);\n+    def_const(def_id);\n+    def_arg(def_id);\n+    def_local(def_id);\n+    def_ty(def_id);\n+    def_ty_arg(def_id);\n }\n \n type crate = spanned[crate_];\n@@ -93,7 +90,7 @@ tag expr_ {\n     expr_assign(@expr /* TODO: @expr : is_lval(@expr) */, @expr);\n     expr_field(@expr, ident);\n     expr_index(@expr, @expr);\n-    expr_name(name, option[referent]);\n+    expr_name(name, option[def]);\n }\n \n type lit = spanned[lit_];\n@@ -118,28 +115,26 @@ tag ty_ {\n     ty_box(@ty);\n     ty_vec(@ty);\n     ty_tup(vec[tup(bool /* mutability */, @ty)]);\n-    ty_path(path, option[referent]);\n+    ty_path(path, option[def]);\n }\n \n tag mode {\n     val;\n     alias;\n }\n \n-type slot = rec(@ty ty, mode mode, option[slot_id] id);\n-type input = rec(slot slot, ident ident);\n-\n-type _fn = rec(vec[input] inputs,\n+type arg = rec(mode mode, @ty ty, ident ident, def_id id);\n+type _fn = rec(vec[arg] inputs,\n                ty output,\n                block body);\n \n type _mod = hashmap[ident,@item];\n \n type item = spanned[item_];\n tag item_ {\n-    item_fn(_fn, item_id);\n-    item_mod(_mod);\n-    item_ty(@ty, item_id);\n+    item_fn(_fn, def_id);\n+    item_mod(_mod, def_id);\n+    item_ty(@ty, def_id);\n }\n \n "}, {"sha": "1d07299b9a86b2a8c37a3fd33f9af3d44d838ab6", "filename": "src/comp/front/parser.rs", "status": "modified", "additions": 28, "deletions": 17, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/865bbae685fbf9bd1583a3f1715dd8093c0cbda2/src%2Fcomp%2Ffront%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/865bbae685fbf9bd1583a3f1715dd8093c0cbda2/src%2Fcomp%2Ffront%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fparser.rs?ref=865bbae685fbf9bd1583a3f1715dd8093c0cbda2", "patch": "@@ -15,13 +15,17 @@ state type parser =\n           io fn err(str s);\n           fn get_session() -> session.session;\n           fn get_span() -> common.span;\n+          fn next_def_id() -> ast.def_id;\n     };\n \n-io fn new_parser(session.session sess, str path) -> parser {\n+io fn new_parser(session.session sess,\n+                 ast.crate_num crate, str path) -> parser {\n     state obj stdio_parser(session.session sess,\n                            mutable token.token tok,\n                            mutable common.pos lo,\n                            mutable common.pos hi,\n+                           mutable ast.def_num def,\n+                           ast.crate_num crate,\n                            lexer.reader rdr)\n         {\n             fn peek() -> token.token {\n@@ -49,11 +53,17 @@ io fn new_parser(session.session sess, str path) -> parser {\n                 ret rec(filename = rdr.get_filename(),\n                         lo = lo, hi = hi);\n             }\n+\n+            fn next_def_id() -> ast.def_id {\n+                def += 1;\n+                ret tup(crate, def);\n+            }\n         }\n     auto srdr = _io.new_stdio_reader(path);\n     auto rdr = lexer.new_reader(srdr, path);\n     auto npos = rdr.get_curr_pos();\n-    ret stdio_parser(sess, lexer.next_token(rdr), npos, npos, rdr);\n+    ret stdio_parser(sess, lexer.next_token(rdr),\n+                     npos, npos, 0, crate, rdr);\n }\n \n io fn expect(parser p, token.token t) {\n@@ -132,14 +142,15 @@ io fn parse_ty(parser p) -> @ast.ty {\n     ret @spanned(lo, lo, t);\n }\n \n-io fn parse_slot(parser p) -> ast.slot {\n+io fn parse_arg(parser p) -> ast.arg {\n     let ast.mode m = ast.val;\n     if (p.peek() == token.BINOP(token.AND)) {\n         m = ast.alias;\n         p.bump();\n     }\n     let @ast.ty t = parse_ty(p);\n-    ret rec(ty=t, mode=m, id=none[ast.slot_id]);\n+    let ast.ident i = parse_ident(p);\n+    ret rec(mode=m, ty=t, ident=i, id=p.next_def_id());\n }\n \n io fn parse_seq[T](token.token bra,\n@@ -249,6 +260,13 @@ io fn parse_bottom_expr(parser p) -> @ast.expr {\n     let ast.expr_ ex = ast.expr_lit(@spanned(lo, lo, ast.lit_nil));\n \n     alt (p.peek()) {\n+\n+        case (token.IDENT(?i)) {\n+            auto n = parse_name(p, i);\n+            hi = n.span;\n+            ex = ast.expr_name(n, none[ast.def]);\n+        }\n+\n         case (token.LPAREN) {\n             p.bump();\n             auto e = parse_expr(p);\n@@ -665,22 +683,15 @@ io fn parse_block(parser p) -> ast.block {\n                              f, p);\n }\n \n-io fn parse_slot_ident_pair(parser p) ->\n-    rec(ast.slot slot, ast.ident ident) {\n-    auto s = parse_slot(p);\n-    auto i = parse_ident(p);\n-    ret rec(slot=s, ident=i);\n-}\n-\n io fn parse_fn(parser p) -> tup(ast.ident, @ast.item) {\n     auto lo = p.get_span();\n     expect(p, token.FN);\n     auto id = parse_ident(p);\n-    auto pf = parse_slot_ident_pair;\n-    let util.common.spanned[vec[rec(ast.slot slot, ast.ident ident)]] inputs =\n-        // FIXME: passing parse_slot_ident_pair as an lval doesn't work at the\n+    auto pf = parse_arg;\n+    let util.common.spanned[vec[ast.arg]] inputs =\n+        // FIXME: passing parse_arg as an lval doesn't work at the\n         // moment.\n-        parse_seq[rec(ast.slot slot, ast.ident ident)]\n+        parse_seq[ast.arg]\n         (token.LPAREN,\n          token.RPAREN,\n          some(token.COMMA),\n@@ -701,7 +712,7 @@ io fn parse_fn(parser p) -> tup(ast.ident, @ast.item) {\n                         body = body);\n \n     let @ast.item i = @spanned(lo, body.span,\n-                               ast.item_fn(f, ast.id_item(0,0)));\n+                               ast.item_fn(f, p.next_def_id()));\n     ret tup(id, i);\n }\n \n@@ -717,7 +728,7 @@ io fn parse_mod(parser p) -> tup(ast.ident, @ast.item) {\n     }\n     auto hi = p.get_span();\n     expect(p, token.RBRACE);\n-    ret tup(id, @spanned(lo, hi, ast.item_mod(m)));\n+    ret tup(id, @spanned(lo, hi, ast.item_mod(m, p.next_def_id())));\n }\n \n io fn parse_item(parser p) -> tup(ast.ident, @ast.item) {"}, {"sha": "53614754bb93af8e00dc1fe02754ed7a81ed5baf", "filename": "src/comp/middle/fold.rs", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/865bbae685fbf9bd1583a3f1715dd8093c0cbda2/src%2Fcomp%2Fmiddle%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/865bbae685fbf9bd1583a3f1715dd8093c0cbda2/src%2Fcomp%2Fmiddle%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ffold.rs?ref=865bbae685fbf9bd1583a3f1715dd8093c0cbda2", "patch": "@@ -17,9 +17,9 @@ import front.ast.expr;\n import front.ast.stmt;\n import front.ast.block;\n import front.ast.item;\n-import front.ast.slot;\n+import front.ast.arg;\n import front.ast.decl;\n-import front.ast.referent;\n+import front.ast.def;\n \n import std._vec;\n \n@@ -44,7 +44,7 @@ type ast_fold[ENV] =\n          vec[tup(bool, @ty)] elts) -> @ty)        fold_ty_tup,\n \n      (fn(&ENV e, &span sp, ast.path p,\n-         &option[referent] r) -> @ty)             fold_ty_path,\n+         &option[def] d) -> @ty)                  fold_ty_path,\n \n      // Expr folds.\n      (fn(&ENV e, &span sp,\n@@ -87,7 +87,7 @@ type ast_fold[ENV] =\n \n      (fn(&ENV e, &span sp,\n          &name n,\n-         &option[referent] r) -> @expr)           fold_expr_name,\n+         &option[def] d) -> @expr)                fold_expr_name,\n \n      // Decl folds.\n      (fn(&ENV e, &span sp,\n@@ -113,19 +113,19 @@ type ast_fold[ENV] =\n \n      // Item folds.\n      (fn(&ENV e, &span sp,\n-         &ast._fn f, ast.item_id id) -> @item)    fold_item_fn,\n+         &ast._fn f, ast.def_id id) -> @item)     fold_item_fn,\n \n      (fn(&ENV e, &span sp,\n-         &ast._mod m) -> @item)                   fold_item_mod,\n+         &ast._mod m, ast.def_id id) -> @item)    fold_item_mod,\n \n      (fn(&ENV e, &span sp,\n-         @ty t, ast.item_id id) -> @item)         fold_item_ty,\n+         @ty t, ast.def_id id) -> @item)          fold_item_ty,\n \n      // Additional nodes.\n      (fn(&ENV e, &span sp,\n          vec[@stmt] stmts) -> block)              fold_block,\n \n-     (fn(&ENV e, vec[ast.input] inputs,\n+     (fn(&ENV e, vec[arg] inputs,\n          &ty output, block body) -> ast._fn)      fold_fn,\n \n      (fn(&ENV e, &ast._mod m) -> ast._mod)        fold_mod,\n@@ -412,18 +412,17 @@ fn fold_block[ENV](&ENV env, ast_fold[ENV] fld, &block blk) -> block {\n     ret respan(blk.span, stmts);\n }\n \n-fn fold_slot[ENV](&ENV env, ast_fold[ENV] fld, &slot s) -> slot {\n-    auto ty = fold_ty(env, fld, s.ty);\n-    ret rec(ty=ty, mode=s.mode, id=s.id);\n+fn fold_arg[ENV](&ENV env, ast_fold[ENV] fld, &arg a) -> arg {\n+    auto ty = fold_ty(env, fld, a.ty);\n+    ret rec(ty=ty with a);\n }\n \n \n fn fold_fn[ENV](&ENV env, ast_fold[ENV] fld, &ast._fn f) -> ast._fn {\n \n-    let vec[ast.input] inputs = vec();\n-    for (ast.input i in f.inputs) {\n-        inputs += rec(slot=fold_slot(env, fld, i.slot),\n-                      ident=i.ident);\n+    let vec[ast.arg] inputs = vec();\n+    for (ast.arg a in f.inputs) {\n+        inputs += fold_arg(env, fld, a);\n     }\n     auto output = fold_ty[ENV](env, fld, @f.output);\n     auto body = fold_block[ENV](env, fld, f.body);\n@@ -446,9 +445,9 @@ fn fold_item[ENV](&ENV env, ast_fold[ENV] fld, @item i) -> @item {\n             ret fld.fold_item_fn(env_, i.span, ff_, id);\n         }\n \n-        case (ast.item_mod(?mm)) {\n+        case (ast.item_mod(?mm, ?id)) {\n             let ast._mod mm_ = fold_mod[ENV](env_, fld, mm);\n-            ret fld.fold_item_mod(env_, i.span, mm_);\n+            ret fld.fold_item_mod(env_, i.span, mm_, id);\n         }\n \n         case (ast.item_ty(?ty, ?id)) {\n@@ -537,8 +536,8 @@ fn identity_fold_ty_tup[ENV](&ENV env, &span sp, vec[tup(bool,@ty)] elts)\n }\n \n fn identity_fold_ty_path[ENV](&ENV env, &span sp, ast.path p,\n-                        &option[referent] r) -> @ty {\n-    ret @respan(sp, ast.ty_path(p, r));\n+                        &option[def] d) -> @ty {\n+    ret @respan(sp, ast.ty_path(p, d));\n }\n \n \n@@ -604,8 +603,8 @@ fn identity_fold_expr_index[ENV](&ENV env, &span sp,\n }\n \n fn identity_fold_expr_name[ENV](&ENV env, &span sp,\n-                                &name n, &option[referent] r) -> @expr {\n-    ret @respan(sp, ast.expr_name(n, r));\n+                                &name n, &option[def] d) -> @expr {\n+    ret @respan(sp, ast.expr_name(n, d));\n }\n \n \n@@ -646,16 +645,17 @@ fn identity_fold_stmt_expr[ENV](&ENV e, &span sp, @expr x) -> @stmt {\n // Item identities.\n \n fn identity_fold_item_fn[ENV](&ENV e, &span sp, &ast._fn f,\n-                              ast.item_id id) -> @item {\n+                              ast.def_id id) -> @item {\n     ret @respan(sp, ast.item_fn(f, id));\n }\n \n-fn identity_fold_item_mod[ENV](&ENV e, &span sp, &ast._mod m) -> @item {\n-    ret @respan(sp, ast.item_mod(m));\n+fn identity_fold_item_mod[ENV](&ENV e, &span sp, &ast._mod m,\n+                               ast.def_id id) -> @item {\n+    ret @respan(sp, ast.item_mod(m, id));\n }\n \n fn identity_fold_item_ty[ENV](&ENV e, &span sp, @ty t,\n-                              ast.item_id id) -> @item {\n+                              ast.def_id id) -> @item {\n     ret @respan(sp, ast.item_ty(t, id));\n }\n \n@@ -667,7 +667,7 @@ fn identity_fold_block[ENV](&ENV e, &span sp, vec[@stmt] stmts) -> block {\n }\n \n fn identity_fold_fn[ENV](&ENV e,\n-                         vec[ast.input] inputs,\n+                         vec[arg] inputs,\n                          &ast.ty output,\n                          block body) -> ast._fn {\n     ret rec(inputs=inputs, output=output, body=body);\n@@ -760,7 +760,7 @@ fn new_identity_fold[ENV]() -> ast_fold[ENV] {\n          fold_stmt_expr   = bind identity_fold_stmt_expr[ENV](_,_,_),\n \n          fold_item_fn   = bind identity_fold_item_fn[ENV](_,_,_,_),\n-         fold_item_mod  = bind identity_fold_item_mod[ENV](_,_,_),\n+         fold_item_mod  = bind identity_fold_item_mod[ENV](_,_,_,_),\n          fold_item_ty   = bind identity_fold_item_ty[ENV](_,_,_,_),\n \n          fold_block = bind identity_fold_block[ENV](_,_,_),"}, {"sha": "ded63bb5fcb9247646aee6e9211d4bfaa928ed7d", "filename": "src/comp/middle/resolve.rs", "status": "modified", "additions": 48, "deletions": 24, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/865bbae685fbf9bd1583a3f1715dd8093c0cbda2/src%2Fcomp%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/865bbae685fbf9bd1583a3f1715dd8093c0cbda2/src%2Fcomp%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fresolve.rs?ref=865bbae685fbf9bd1583a3f1715dd8093c0cbda2", "patch": "@@ -1,4 +1,6 @@\n import front.ast;\n+import front.ast.ident;\n+import front.ast.def;\n import driver.session;\n import util.common.span;\n import std.map.hashmap;\n@@ -18,67 +20,89 @@ tag scope {\n \n type env = list[scope];\n \n-fn resolve_name(&env e, &span sp, ast.name_ n) -> ast.name {\n+fn lookup_name(&env e, ast.ident i) -> option[def] {\n \n-    log \"resolving name \" + n.ident;\n+    log \"resolving name \" + i;\n \n-    fn in_scope(ast.ident i, &scope s) -> option[scope] {\n+    fn check_mod(ast.ident i, ast._mod m) -> option[def] {\n+        alt (m.find(i)) {\n+            case (some[@ast.item](?it)) {\n+                alt (it.node) {\n+                    case (ast.item_fn(_, ?id)) {\n+                        ret some[def](ast.def_fn(id));\n+                    }\n+                    case (ast.item_mod(_, ?id)) {\n+                        ret some[def](ast.def_mod(id));\n+                    }\n+                    case (ast.item_ty(_, ?id)) {\n+                        ret some[def](ast.def_ty(id));\n+                    }\n+                }\n+            }\n+        }\n+        ret none[def];\n+    }\n+\n+    fn in_scope(ast.ident i, &scope s) -> option[def] {\n         alt (s) {\n+\n             case (scope_crate(?c)) {\n-                if (c.node.module.contains_key(i)) {\n-                    ret some[scope](s);\n-                }\n+                ret check_mod(i, c.node.module);\n             }\n+\n             case (scope_item(?it)) {\n                 alt (it.node) {\n                     case (ast.item_fn(?f, _)) {\n-                        for (ast.input inp in f.inputs) {\n-                            if (_str.eq(inp.ident, i)) {\n-                                ret some[scope](s);\n+                        for (ast.arg a in f.inputs) {\n+                            if (_str.eq(a.ident, i)) {\n+                                ret some[def](ast.def_arg(a.id));\n                             }\n                         }\n                     }\n-                    case (ast.item_mod(?m)) {\n-                        if (m.contains_key(i)) {\n-                            ret some[scope](s);\n-                        }\n+                    case (ast.item_mod(?m, _)) {\n+                        ret check_mod(i, m);\n                     }\n                 }\n             }\n         }\n-        ret none[scope];\n+        ret none[def];\n     }\n \n-    alt (std.list.find[scope](e, bind in_scope(n.ident, _))) {\n-        case (some[scope](?s)) {\n-            log \"resolved name \" + n.ident;\n+    ret std.list.find[scope,def](e, bind in_scope(i, _));\n+}\n+\n+fn fold_expr_name(&env e, &span sp, &ast.name n,\n+                  &option[def] d) -> @ast.expr {\n+\n+    auto d_ = lookup_name(e, n.node.ident);\n+\n+    alt (d_) {\n+        case (some[def](_)) {\n+            log \"resolved name \" + n.node.ident;\n         }\n-        case (none[scope]) {\n-            log \"unresolved name \" + n.ident;\n+        case (none[def]) {\n+            log \"unresolved name \" + n.node.ident;\n         }\n     }\n \n-    ret fold.respan[ast.name_](sp, n);\n+    ret @fold.respan[ast.expr_](sp, ast.expr_name(n, d_));\n }\n \n fn update_env_for_crate(&env e, @ast.crate c) -> env {\n-    log \"updating env with crate\";\n     ret cons[scope](scope_crate(c), @e);\n }\n \n fn update_env_for_item(&env e, @ast.item i) -> env {\n-    log \"updating env with item\";\n     ret cons[scope](scope_item(i), @e);\n }\n \n fn update_env_for_block(&env e, ast.block b) -> env {\n-    log \"updating env with block\";\n     ret cons[scope](scope_block(b), @e);\n }\n \n fn resolve_crate(session.session sess, @ast.crate crate) -> @ast.crate {\n     let fold.ast_fold[env] fld = fold.new_identity_fold[env]();\n-    fld = @rec( fold_name = bind resolve_name(_,_,_),\n+    fld = @rec( fold_expr_name = bind fold_expr_name(_,_,_,_),\n                 update_env_for_crate = bind update_env_for_crate(_,_),\n                 update_env_for_item = bind update_env_for_item(_,_),\n                 update_env_for_block = bind update_env_for_block(_,_)"}, {"sha": "a8bb23acde897372b59e30af724b4231c6271703", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/865bbae685fbf9bd1583a3f1715dd8093c0cbda2/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/865bbae685fbf9bd1583a3f1715dd8093c0cbda2/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=865bbae685fbf9bd1583a3f1715dd8093c0cbda2", "patch": "@@ -730,7 +730,7 @@ fn trans_item(@trans_ctxt cx, &str name, &ast.item item) {\n         case (ast.item_fn(?f, _)) {\n             trans_fn(sub_cx, f);\n         }\n-        case (ast.item_mod(?m)) {\n+        case (ast.item_mod(?m, _)) {\n             trans_mod(sub_cx, m);\n         }\n     }"}]}