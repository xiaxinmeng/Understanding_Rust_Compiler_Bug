{"sha": "2c7712b3f11ad18fbe907e520276385432f5bb10", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJjNzcxMmIzZjExYWQxOGZiZTkwN2U1MjAyNzYzODU0MzJmNWJiMTA=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2019-05-05T19:37:30Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-05-05T19:37:30Z"}, "message": "Rollup merge of #60530 - eddyb:unfreevars, r=oli-obk\n\nrustc: rename all occurences of \"freevar\" to \"upvar\".\n\nMost of the more recent code talks about \"(closure) upvars\", so I believe that's the name we want to use.\nThere's also the possibility of using \"capture\" which is more user-facing, but I'd rather not change *both* \"freevar\" and \"upvar\" to something else in this one PR.\n\ncc @nikomatsakis @petrochenkov", "tree": {"sha": "6ba8ff5a83b0358f2354a3dfc351542d71f60563", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6ba8ff5a83b0358f2354a3dfc351542d71f60563"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2c7712b3f11ad18fbe907e520276385432f5bb10", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJczzt6CRBK7hj4Ov3rIwAAdHIIAA2RVgPu2FKJz4sNhcl03k1/\nGZD+s8OSwZaLI2pF625O4ztllhRp2audGMcGpYgaziWcA/0pOkockas2+WuLgAaR\nwULf+dwMZj0aQSLsdrvmjPWKqDkbEn3twJTPbuX93NHW1Jzd+9FUFS4OI8SPhcE6\nS74DWq0C1UY9wAdhSRi8usjNO9N7pgjghR5u4yv7yaWx9r70T+u5eKX0H4l/26WY\n36TZpJ2h83cP7TtLHgnYXYfq/Yb9yXuZEEmp2fAj6HzB9eznB4qeEsZ3KMM9p5xG\nFk76WRJiBUeEz1hSnX/7WZYHcmJ8/dUdb8A6s+1ehHa0jeNEKDINoyqFHwBre1Y=\n=Lu6m\n-----END PGP SIGNATURE-----\n", "payload": "tree 6ba8ff5a83b0358f2354a3dfc351542d71f60563\nparent d475c4e8537c1eac6e81f83b32180eef03b83a8c\nparent 8d9f4a128c4cfb15cf61a5c4b87a042d496d11cf\nauthor Manish Goregaokar <manishsmail@gmail.com> 1557085050 -0700\ncommitter GitHub <noreply@github.com> 1557085050 -0700\n\nRollup merge of #60530 - eddyb:unfreevars, r=oli-obk\n\nrustc: rename all occurences of \"freevar\" to \"upvar\".\n\nMost of the more recent code talks about \"(closure) upvars\", so I believe that's the name we want to use.\nThere's also the possibility of using \"capture\" which is more user-facing, but I'd rather not change *both* \"freevar\" and \"upvar\" to something else in this one PR.\n\ncc @nikomatsakis @petrochenkov\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2c7712b3f11ad18fbe907e520276385432f5bb10", "html_url": "https://github.com/rust-lang/rust/commit/2c7712b3f11ad18fbe907e520276385432f5bb10", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2c7712b3f11ad18fbe907e520276385432f5bb10/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d475c4e8537c1eac6e81f83b32180eef03b83a8c", "url": "https://api.github.com/repos/rust-lang/rust/commits/d475c4e8537c1eac6e81f83b32180eef03b83a8c", "html_url": "https://github.com/rust-lang/rust/commit/d475c4e8537c1eac6e81f83b32180eef03b83a8c"}, {"sha": "8d9f4a128c4cfb15cf61a5c4b87a042d496d11cf", "url": "https://api.github.com/repos/rust-lang/rust/commits/8d9f4a128c4cfb15cf61a5c4b87a042d496d11cf", "html_url": "https://github.com/rust-lang/rust/commit/8d9f4a128c4cfb15cf61a5c4b87a042d496d11cf"}], "stats": {"total": 265, "additions": 120, "deletions": 145}, "files": [{"sha": "91256385232a9b32da2de83e6bd50e34650e9e5a", "filename": "src/librustc/hir/def.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2c7712b3f11ad18fbe907e520276385432f5bb10/src%2Flibrustc%2Fhir%2Fdef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c7712b3f11ad18fbe907e520276385432f5bb10/src%2Flibrustc%2Fhir%2Fdef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fdef.rs?ref=2c7712b3f11ad18fbe907e520276385432f5bb10", "patch": "@@ -140,7 +140,7 @@ pub enum Res<Id = hir::HirId> {\n     SelfCtor(DefId /* impl */),  // `DefId` refers to the impl\n     Local(Id),\n     Upvar(Id,           // `HirId` of closed over local\n-          usize,        // index in the `freevars` list of the closure\n+          usize,        // index in the `upvars` list of the closure\n           ast::NodeId), // expr node that creates the closure\n \n     // Macro namespace"}, {"sha": "1e357e1341710578392e22fab8e635db9cca9be9", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/2c7712b3f11ad18fbe907e520276385432f5bb10/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c7712b3f11ad18fbe907e520276385432f5bb10/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=2c7712b3f11ad18fbe907e520276385432f5bb10", "patch": "@@ -2476,19 +2476,19 @@ impl ForeignItemKind {\n     }\n }\n \n-/// A free variable referred to in a function.\n+/// A variable captured by a closure.\n #[derive(Debug, Copy, Clone, RustcEncodable, RustcDecodable, HashStable)]\n-pub struct Freevar<Id = HirId> {\n-    /// The variable being accessed free.\n+pub struct Upvar<Id = HirId> {\n+    /// The variable being captured.\n     pub res: Res<Id>,\n \n     // First span where it is accessed (there can be multiple).\n     pub span: Span\n }\n \n-impl<Id: fmt::Debug + Copy> Freevar<Id> {\n-    pub fn map_id<R>(self, map: impl FnMut(Id) -> R) -> Freevar<R> {\n-        Freevar {\n+impl<Id: fmt::Debug + Copy> Upvar<Id> {\n+    pub fn map_id<R>(self, map: impl FnMut(Id) -> R) -> Upvar<R> {\n+        Upvar {\n             res: self.res.map_id(map),\n             span: self.span,\n         }\n@@ -2497,12 +2497,12 @@ impl<Id: fmt::Debug + Copy> Freevar<Id> {\n     pub fn var_id(&self) -> Id {\n         match self.res {\n             Res::Local(id) | Res::Upvar(id, ..) => id,\n-            _ => bug!(\"Freevar::var_id: bad res ({:?})\", self.res)\n+            _ => bug!(\"Upvar::var_id: bad res ({:?})\", self.res)\n         }\n     }\n }\n \n-pub type FreevarMap = NodeMap<Vec<Freevar<ast::NodeId>>>;\n+pub type UpvarMap = NodeMap<Vec<Upvar<ast::NodeId>>>;\n \n pub type CaptureModeMap = NodeMap<CaptureClause>;\n "}, {"sha": "9eb46aa3779d9079d398ec00912b756e773fc04f", "filename": "src/librustc/infer/error_reporting/note.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2c7712b3f11ad18fbe907e520276385432f5bb10/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c7712b3f11ad18fbe907e520276385432f5bb10/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnote.rs?ref=2c7712b3f11ad18fbe907e520276385432f5bb10", "patch": "@@ -46,7 +46,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 err.span_note(span,\n                               \"...so that pointer is not dereferenced outside its lifetime\");\n             }\n-            infer::FreeVariable(span, id) => {\n+            infer::ClosureCapture(span, id) => {\n                 err.span_note(span,\n                               &format!(\"...so that captured variable `{}` does not outlive the \\\n                                         enclosing closure\",\n@@ -214,7 +214,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                     \"the reference is only valid for \", sup, \"\");\n                 err\n             }\n-            infer::FreeVariable(span, id) => {\n+            infer::ClosureCapture(span, id) => {\n                 let mut err = struct_span_err!(self.tcx.sess,\n                                                span,\n                                                E0474,"}, {"sha": "5846e604cfc09b046d1f0c75a791f199572cac0d", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2c7712b3f11ad18fbe907e520276385432f5bb10/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c7712b3f11ad18fbe907e520276385432f5bb10/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=2c7712b3f11ad18fbe907e520276385432f5bb10", "patch": "@@ -264,8 +264,8 @@ pub enum SubregionOrigin<'tcx> {\n     /// Dereference of reference must be within its lifetime\n     DerefPointer(Span),\n \n-    /// Closure bound must not outlive captured free variables\n-    FreeVariable(Span, ast::NodeId),\n+    /// Closure bound must not outlive captured variables\n+    ClosureCapture(Span, ast::NodeId),\n \n     /// Index into slice must be within its lifetime\n     IndexSlice(Span),\n@@ -1660,7 +1660,7 @@ impl<'tcx> SubregionOrigin<'tcx> {\n             InfStackClosure(a) => a,\n             InvokeClosure(a) => a,\n             DerefPointer(a) => a,\n-            FreeVariable(a, _) => a,\n+            ClosureCapture(a, _) => a,\n             IndexSlice(a) => a,\n             RelateObjectBound(a) => a,\n             RelateParamBound(a, _) => a,"}, {"sha": "93ba4241c472540b251a9fcabe15c804377ed336", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/2c7712b3f11ad18fbe907e520276385432f5bb10/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c7712b3f11ad18fbe907e520276385432f5bb10/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=2c7712b3f11ad18fbe907e520276385432f5bb10", "patch": "@@ -931,42 +931,42 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n         debug!(\"walk_captures({:?})\", closure_expr);\n \n         let closure_def_id = self.tcx().hir().local_def_id_from_hir_id(closure_expr.hir_id);\n-        self.tcx().with_freevars(closure_expr.hir_id, |freevars| {\n-            for freevar in freevars {\n-                let var_hir_id = freevar.var_id();\n+        if let Some(upvars) = self.tcx().upvars(closure_def_id) {\n+            for upvar in upvars.iter() {\n+                let var_hir_id = upvar.var_id();\n                 let upvar_id = ty::UpvarId {\n                     var_path: ty::UpvarPath { hir_id: var_hir_id },\n                     closure_expr_id: closure_def_id.to_local(),\n                 };\n                 let upvar_capture = self.mc.tables.upvar_capture(upvar_id);\n                 let cmt_var = return_if_err!(self.cat_captured_var(closure_expr.hir_id,\n                                                                    fn_decl_span,\n-                                                                   freevar));\n+                                                                   upvar));\n                 match upvar_capture {\n                     ty::UpvarCapture::ByValue => {\n                         let mode = copy_or_move(&self.mc,\n                                                 self.param_env,\n                                                 &cmt_var,\n                                                 CaptureMove);\n-                        self.delegate.consume(closure_expr.hir_id, freevar.span, &cmt_var, mode);\n+                        self.delegate.consume(closure_expr.hir_id, upvar.span, &cmt_var, mode);\n                     }\n                     ty::UpvarCapture::ByRef(upvar_borrow) => {\n                         self.delegate.borrow(closure_expr.hir_id,\n                                              fn_decl_span,\n                                              &cmt_var,\n                                              upvar_borrow.region,\n                                              upvar_borrow.kind,\n-                                             ClosureCapture(freevar.span));\n+                                             ClosureCapture(upvar.span));\n                     }\n                 }\n             }\n-        });\n+        }\n     }\n \n     fn cat_captured_var(&mut self,\n                         closure_hir_id: hir::HirId,\n                         closure_span: Span,\n-                        upvar: &hir::Freevar)\n+                        upvar: &hir::Upvar)\n                         -> mc::McResult<mc::cmt_<'tcx>> {\n         // Create the cmt for the variable being borrowed, from the\n         // caller's perspective"}, {"sha": "4b458e474b299815c6fd79bff4ebbdd2bad544d7", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/2c7712b3f11ad18fbe907e520276385432f5bb10/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c7712b3f11ad18fbe907e520276385432f5bb10/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=2c7712b3f11ad18fbe907e520276385432f5bb10", "patch": "@@ -144,7 +144,7 @@ impl LiveNode {\n \n #[derive(Copy, Clone, PartialEq, Debug)]\n enum LiveNodeKind {\n-    FreeVarNode(Span),\n+    UpvarNode(Span),\n     ExprNode(Span),\n     VarDefNode(Span),\n     ExitNode\n@@ -153,8 +153,8 @@ enum LiveNodeKind {\n fn live_node_kind_to_string(lnk: LiveNodeKind, tcx: TyCtxt<'_, '_, '_>) -> String {\n     let cm = tcx.sess.source_map();\n     match lnk {\n-        FreeVarNode(s) => {\n-            format!(\"Free var node [{}]\", cm.span_to_string(s))\n+        UpvarNode(s) => {\n+            format!(\"Upvar node [{}]\", cm.span_to_string(s))\n         }\n         ExprNode(s) => {\n             format!(\"Expr node [{}]\", cm.span_to_string(s))\n@@ -483,16 +483,17 @@ fn visit_expr<'a, 'tcx>(ir: &mut IrMaps<'a, 'tcx>, expr: &'tcx Expr) {\n         // in better error messages than just pointing at the closure\n         // construction site.\n         let mut call_caps = Vec::new();\n-        ir.tcx.with_freevars(expr.hir_id, |freevars| {\n-            call_caps.extend(freevars.iter().filter_map(|fv| {\n-                if let Res::Local(rv) = fv.res {\n-                    let fv_ln = ir.add_live_node(FreeVarNode(fv.span));\n-                    Some(CaptureInfo { ln: fv_ln, var_hid: rv })\n+        let closure_def_id = ir.tcx.hir().local_def_id_from_hir_id(expr.hir_id);\n+        if let Some(upvars) = ir.tcx.upvars(closure_def_id) {\n+            call_caps.extend(upvars.iter().filter_map(|upvar| {\n+                if let Res::Local(rv) = upvar.res {\n+                    let upvar_ln = ir.add_live_node(UpvarNode(upvar.span));\n+                    Some(CaptureInfo { ln: upvar_ln, var_hid: rv })\n                 } else {\n                     None\n                 }\n             }));\n-        });\n+        }\n         ir.set_captures(expr.hir_id, call_caps);\n \n         intravisit::walk_expr(ir, expr);"}, {"sha": "bd67aabfe8e5f77b5688231077929dad626236f6", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/2c7712b3f11ad18fbe907e520276385432f5bb10/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c7712b3f11ad18fbe907e520276385432f5bb10/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=2c7712b3f11ad18fbe907e520276385432f5bb10", "patch": "@@ -2572,12 +2572,12 @@ impl<'tcx> Debug for Rvalue<'tcx> {\n                             };\n                             let mut struct_fmt = fmt.debug_struct(&name);\n \n-                            tcx.with_freevars(hir_id, |freevars| {\n-                                for (freevar, place) in freevars.iter().zip(places) {\n-                                    let var_name = tcx.hir().name_by_hir_id(freevar.var_id());\n+                            if let Some(upvars) = tcx.upvars(def_id) {\n+                                for (upvar, place) in upvars.iter().zip(places) {\n+                                    let var_name = tcx.hir().name_by_hir_id(upvar.var_id());\n                                     struct_fmt.field(&var_name.as_str(), place);\n                                 }\n-                            });\n+                            }\n \n                             struct_fmt.finish()\n                         } else {\n@@ -2591,12 +2591,12 @@ impl<'tcx> Debug for Rvalue<'tcx> {\n                                                tcx.hir().span_by_hir_id(hir_id));\n                             let mut struct_fmt = fmt.debug_struct(&name);\n \n-                            tcx.with_freevars(hir_id, |freevars| {\n-                                for (freevar, place) in freevars.iter().zip(places) {\n-                                    let var_name = tcx.hir().name_by_hir_id(freevar.var_id());\n+                            if let Some(upvars) = tcx.upvars(def_id) {\n+                                for (upvar, place) in upvars.iter().zip(places) {\n+                                    let var_name = tcx.hir().name_by_hir_id(upvar.var_id());\n                                     struct_fmt.field(&var_name.as_str(), place);\n                                 }\n-                            });\n+                            }\n \n                             struct_fmt.finish()\n                         } else {"}, {"sha": "0e7b66b744499d595d2812626b8bf0c8735f67d9", "filename": "src/librustc/query/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2c7712b3f11ad18fbe907e520276385432f5bb10/src%2Flibrustc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c7712b3f11ad18fbe907e520276385432f5bb10/src%2Flibrustc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fquery%2Fmod.rs?ref=2c7712b3f11ad18fbe907e520276385432f5bb10", "patch": "@@ -824,7 +824,7 @@ rustc_queries! {\n             desc { \"generating a postorder list of CrateNums\" }\n         }\n \n-        query freevars(_: DefId) -> Option<Lrc<Vec<hir::Freevar>>> {\n+        query upvars(_: DefId) -> Option<Lrc<Vec<hir::Upvar>>> {\n             eval_always\n         }\n         query maybe_unused_trait_import(_: DefId) -> bool {"}, {"sha": "19440d0bc64ea3456a4d5c8efeab23154034efb0", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2c7712b3f11ad18fbe907e520276385432f5bb10/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c7712b3f11ad18fbe907e520276385432f5bb10/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=2c7712b3f11ad18fbe907e520276385432f5bb10", "patch": "@@ -1071,10 +1071,10 @@ pub struct GlobalCtxt<'tcx> {\n \n     pub queries: query::Queries<'tcx>,\n \n-    // Records the free variables referenced by every closure\n+    // Records the captured variables referenced by every closure\n     // expression. Do not track deps for this, just recompute it from\n     // scratch every time.\n-    freevars: FxHashMap<DefId, Lrc<Vec<hir::Freevar>>>,\n+    upvars: FxHashMap<DefId, Lrc<Vec<hir::Upvar>>>,\n \n     maybe_unused_trait_imports: FxHashSet<DefId>,\n     maybe_unused_extern_crates: Vec<(DefId, Span)>,\n@@ -1317,7 +1317,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                 }).collect();\n                 (k, Lrc::new(exports))\n             }).collect(),\n-            freevars: resolutions.freevars.into_iter().map(|(k, v)| {\n+            upvars: resolutions.upvars.into_iter().map(|(k, v)| {\n                 let vars: Vec<_> = v.into_iter().map(|e| {\n                     e.map_id(|id| hir.node_to_hir_id(id))\n                 }).collect();\n@@ -3055,7 +3055,7 @@ pub fn provide(providers: &mut ty::query::Providers<'_>) {\n         assert_eq!(id, LOCAL_CRATE);\n         Lrc::new(middle::lang_items::collect(tcx))\n     };\n-    providers.freevars = |tcx, id| tcx.gcx.freevars.get(&id).cloned();\n+    providers.upvars = |tcx, id| tcx.gcx.upvars.get(&id).cloned();\n     providers.maybe_unused_trait_import = |tcx, id| {\n         tcx.maybe_unused_trait_imports.contains(&id)\n     };"}, {"sha": "cb92e4b7470a58640d2625c44fd61325ea5148e7", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 3, "deletions": 15, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/2c7712b3f11ad18fbe907e520276385432f5bb10/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c7712b3f11ad18fbe907e520276385432f5bb10/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=2c7712b3f11ad18fbe907e520276385432f5bb10", "patch": "@@ -8,8 +8,8 @@ pub use self::BorrowKind::*;\n pub use self::IntVarValue::*;\n pub use self::fold::TypeFoldable;\n \n-use crate::hir::{map as hir_map, FreevarMap, GlobMap, TraitMap};\n-use crate::hir::{HirId, Node};\n+use crate::hir::{map as hir_map, UpvarMap, GlobMap, TraitMap};\n+use crate::hir::Node;\n use crate::hir::def::{Res, DefKind, CtorOf, CtorKind, ExportMap};\n use crate::hir::def_id::{CrateNum, DefId, LocalDefId, CRATE_DEF_INDEX, LOCAL_CRATE};\n use rustc_data_structures::svh::Svh;\n@@ -122,7 +122,7 @@ mod sty;\n \n #[derive(Clone)]\n pub struct Resolutions {\n-    pub freevars: FreevarMap,\n+    pub upvars: UpvarMap,\n     pub trait_map: TraitMap,\n     pub maybe_unused_trait_imports: NodeSet,\n     pub maybe_unused_extern_crates: Vec<(NodeId, Span)>,\n@@ -3120,18 +3120,6 @@ impl Iterator for AssociatedItemsIterator<'_, '_, '_> {\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n-    pub fn with_freevars<T, F>(self, fid: HirId, f: F) -> T where\n-        F: FnOnce(&[hir::Freevar]) -> T,\n-    {\n-        let def_id = self.hir().local_def_id_from_hir_id(fid);\n-        match self.freevars(def_id) {\n-            None => f(&[]),\n-            Some(d) => f(&d),\n-        }\n-    }\n-}\n-\n fn associated_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> AssociatedItem {\n     let id = tcx.hir().as_local_hir_id(def_id).unwrap();\n     let parent_id = tcx.hir().get_parent_item(id);"}, {"sha": "8e98d4d85b9cc04d437fc2d24d014575ae819de4", "filename": "src/librustc/ty/print/pretty.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2c7712b3f11ad18fbe907e520276385432f5bb10/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c7712b3f11ad18fbe907e520276385432f5bb10/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs?ref=2c7712b3f11ad18fbe907e520276385432f5bb10", "patch": "@@ -582,16 +582,16 @@ pub trait PrettyPrinter<'gcx: 'tcx, 'tcx>:\n                 if let Some(hir_id) = self.tcx().hir().as_local_hir_id(did) {\n                     p!(write(\"@{:?}\", self.tcx().hir().span_by_hir_id(hir_id)));\n                     let mut sep = \" \";\n-                    for (freevar, upvar_ty) in self.tcx().freevars(did)\n+                    for (upvar, upvar_ty) in self.tcx().upvars(did)\n                         .as_ref()\n-                        .map_or(&[][..], |fv| &fv[..])\n+                        .map_or(&[][..], |v| &v[..])\n                         .iter()\n                         .zip(upvar_tys)\n                     {\n                         p!(\n                             write(\"{}{}:\",\n                                     sep,\n-                                    self.tcx().hir().name_by_hir_id(freevar.var_id())),\n+                                    self.tcx().hir().name_by_hir_id(upvar.var_id())),\n                             print(upvar_ty));\n                         sep = \", \";\n                     }\n@@ -625,16 +625,16 @@ pub trait PrettyPrinter<'gcx: 'tcx, 'tcx>:\n                         p!(write(\"@{:?}\", self.tcx().hir().span_by_hir_id(hir_id)));\n                     }\n                     let mut sep = \" \";\n-                    for (freevar, upvar_ty) in self.tcx().freevars(did)\n+                    for (upvar, upvar_ty) in self.tcx().upvars(did)\n                         .as_ref()\n-                        .map_or(&[][..], |fv| &fv[..])\n+                        .map_or(&[][..], |v| &v[..])\n                         .iter()\n                         .zip(upvar_tys)\n                     {\n                         p!(\n                             write(\"{}{}:\",\n                                     sep,\n-                                    self.tcx().hir().name_by_hir_id(freevar.var_id())),\n+                                    self.tcx().hir().name_by_hir_id(upvar.var_id())),\n                             print(upvar_ty));\n                         sep = \", \";\n                     }"}, {"sha": "8543cca1dd54502f9131521f67bf0c81d80c40c8", "filename": "src/librustc_interface/passes.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2c7712b3f11ad18fbe907e520276385432f5bb10/src%2Flibrustc_interface%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c7712b3f11ad18fbe907e520276385432f5bb10/src%2Flibrustc_interface%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Fpasses.rs?ref=2c7712b3f11ad18fbe907e520276385432f5bb10", "patch": "@@ -180,7 +180,7 @@ impl ExpansionResult {\n         ExpansionResult {\n             defs: Steal::new(resolver.definitions),\n             resolutions: Steal::new(Resolutions {\n-                freevars: resolver.freevars,\n+                upvars: resolver.upvars,\n                 export_map: resolver.export_map,\n                 trait_map: resolver.trait_map,\n                 glob_map: resolver.glob_map,\n@@ -199,7 +199,7 @@ impl ExpansionResult {\n         ExpansionResult {\n             defs: Steal::new(resolver.definitions.clone()),\n             resolutions: Steal::new(Resolutions {\n-                freevars: resolver.freevars.clone(),\n+                upvars: resolver.upvars.clone(),\n                 export_map: resolver.export_map.clone(),\n                 trait_map: resolver.trait_map.clone(),\n                 glob_map: resolver.glob_map.clone(),"}, {"sha": "8aa6456ebe77b8cbeef657d92c82d7238945b26b", "filename": "src/librustc_mir/borrow_check/error_reporting.rs", "status": "modified", "additions": 14, "deletions": 27, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/2c7712b3f11ad18fbe907e520276385432f5bb10/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c7712b3f11ad18fbe907e520276385432f5bb10/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs?ref=2c7712b3f11ad18fbe907e520276385432f5bb10", "patch": "@@ -1814,16 +1814,12 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 ty::Array(ty, _) | ty::Slice(ty) =>\n                     self.describe_field_from_ty(&ty, field, variant_index),\n                 ty::Closure(def_id, _) | ty::Generator(def_id, _, _) => {\n-                    // Convert the def-id into a node-id. node-ids are only valid for\n-                    // the local code in the current crate, so this returns an `Option` in case\n+                    // `tcx.upvars(def_id)` returns an `Option`, which is `None` in case\n                     // the closure comes from another crate. But in that case we wouldn't\n                     // be borrowck'ing it, so we can just unwrap:\n-                    let hir_id = self.infcx.tcx.hir().as_local_hir_id(def_id).unwrap();\n-                    let freevar = self.infcx\n-                        .tcx\n-                        .with_freevars(hir_id, |fv| fv[field.index()]);\n+                    let upvar = self.infcx.tcx.upvars(def_id).unwrap()[field.index()];\n \n-                    self.infcx.tcx.hir().name_by_hir_id(freevar.var_id()).to_string()\n+                    self.infcx.tcx.hir().name_by_hir_id(upvar.var_id()).to_string()\n                 }\n                 _ => {\n                     // Might need a revision when the fields in trait RFC is implemented\n@@ -2613,28 +2609,19 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         if let hir::ExprKind::Closure(\n             .., args_span, _\n         ) = expr {\n-            let var_span = self.infcx.tcx.with_freevars(\n-                hir_id,\n-                |freevars| {\n-                    for (v, place) in freevars.iter().zip(places) {\n-                        match place {\n-                            Operand::Copy(place) |\n-                            Operand::Move(place) if target_place == place => {\n-                                debug!(\"closure_span: found captured local {:?}\", place);\n-                                return Some(v.span);\n-                            },\n-                            _ => {}\n-                        }\n-                    }\n-\n-                    None\n-                },\n-            )?;\n+            for (v, place) in self.infcx.tcx.upvars(def_id)?.iter().zip(places) {\n+                match place {\n+                    Operand::Copy(place) |\n+                    Operand::Move(place) if target_place == place => {\n+                        debug!(\"closure_span: found captured local {:?}\", place);\n+                        return Some((*args_span, v.span));\n+                    },\n+                    _ => {}\n+                }\n+            }\n \n-            Some((*args_span, var_span))\n-        } else {\n-            None\n         }\n+        None\n     }\n \n     /// Helper to retrieve span(s) of given borrow from the current MIR"}, {"sha": "5e646a49e0e4293ed3c70118f3e1e06677c7c723", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/2c7712b3f11ad18fbe907e520276385432f5bb10/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c7712b3f11ad18fbe907e520276385432f5bb10/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=2c7712b3f11ad18fbe907e520276385432f5bb10", "patch": "@@ -516,12 +516,11 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                     span_bug!(expr.span, \"closure expr w/o closure type: {:?}\", closure_ty);\n                 }\n             };\n-            let upvars = cx.tcx.with_freevars(expr.hir_id, |freevars| {\n-                freevars.iter()\n-                    .zip(substs.upvar_tys(def_id, cx.tcx))\n-                    .map(|(fv, ty)| capture_freevar(cx, expr, fv, ty))\n-                    .collect()\n-            });\n+            let upvars = cx.tcx.upvars(def_id).iter()\n+                .flat_map(|upvars| upvars.iter())\n+                .zip(substs.upvar_tys(def_id, cx.tcx))\n+                .map(|(upvar, ty)| capture_upvar(cx, expr, upvar, ty))\n+                .collect();\n             ExprKind::Closure {\n                 closure_id: def_id,\n                 substs,\n@@ -1185,12 +1184,12 @@ fn overloaded_place<'a, 'gcx, 'tcx>(\n     ExprKind::Deref { arg: ref_expr.to_ref() }\n }\n \n-fn capture_freevar<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n+fn capture_upvar<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                                    closure_expr: &'tcx hir::Expr,\n-                                   freevar: &hir::Freevar,\n-                                   freevar_ty: Ty<'tcx>)\n+                                   upvar: &hir::Upvar,\n+                                   upvar_ty: Ty<'tcx>)\n                                    -> ExprRef<'tcx> {\n-    let var_hir_id = freevar.var_id();\n+    let var_hir_id = upvar.var_id();\n     let upvar_id = ty::UpvarId {\n         var_path: ty::UpvarPath { hir_id: var_hir_id },\n         closure_expr_id: cx.tcx.hir().local_def_id_from_hir_id(closure_expr.hir_id).to_local(),\n@@ -1202,7 +1201,7 @@ fn capture_freevar<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n         temp_lifetime,\n         ty: var_ty,\n         span: closure_expr.span,\n-        kind: convert_var(cx, closure_expr, freevar.res),\n+        kind: convert_var(cx, closure_expr, upvar.res),\n     };\n     match upvar_capture {\n         ty::UpvarCapture::ByValue => captured_var.to_ref(),\n@@ -1214,7 +1213,7 @@ fn capture_freevar<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n             };\n             Expr {\n                 temp_lifetime,\n-                ty: freevar_ty,\n+                ty: upvar_ty,\n                 span: closure_expr.span,\n                 kind: ExprKind::Borrow {\n                     borrow_kind,"}, {"sha": "1ab612a2f7dd7d5e546986f158e6a4a6bd683e39", "filename": "src/librustc_mir/interpret/validity.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2c7712b3f11ad18fbe907e520276385432f5bb10/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c7712b3f11ad18fbe907e520276385432f5bb10/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs?ref=2c7712b3f11ad18fbe907e520276385432f5bb10", "patch": "@@ -172,7 +172,7 @@ impl<'rt, 'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> ValidityVisitor<'rt, 'a, '\n                 if def_id.is_local() {\n                     let tables = self.ecx.tcx.typeck_tables_of(def_id);\n                     if let Some(upvars) = tables.upvar_list.get(&def_id) {\n-                        // Sometimes the index is beyond the number of freevars (seen\n+                        // Sometimes the index is beyond the number of upvars (seen\n                         // for a generator).\n                         if let Some(upvar_id) = upvars.get(field) {\n                             let var_hir_id = upvar_id.var_path.hir_id;"}, {"sha": "0f651fafcd2ac487bf92d6871e3854dacb34fce5", "filename": "src/librustc_passes/rvalue_promotion.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2c7712b3f11ad18fbe907e520276385432f5bb10/src%2Flibrustc_passes%2Frvalue_promotion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c7712b3f11ad18fbe907e520276385432f5bb10/src%2Flibrustc_passes%2Frvalue_promotion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Frvalue_promotion.rs?ref=2c7712b3f11ad18fbe907e520276385432f5bb10", "patch": "@@ -449,7 +449,8 @@ fn check_expr_kind<'a, 'tcx>(\n             let nested_body_promotable = v.check_nested_body(body_id);\n             // Paths in constant contexts cannot refer to local variables,\n             // as there are none, and thus closures can't have upvars there.\n-            if v.tcx.with_freevars(e.hir_id, |fv| !fv.is_empty()) {\n+            let closure_def_id = v.tcx.hir().local_def_id_from_hir_id(e.hir_id);\n+            if !v.tcx.upvars(closure_def_id).map_or(true, |v| v.is_empty()) {\n                 NotPromotable\n             } else {\n                 nested_body_promotable"}, {"sha": "f8f6e5b1cd012f2d338f9d891108e5ef1f7164cd", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/2c7712b3f11ad18fbe907e520276385432f5bb10/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c7712b3f11ad18fbe907e520276385432f5bb10/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=2c7712b3f11ad18fbe907e520276385432f5bb10", "patch": "@@ -29,7 +29,7 @@ use rustc::hir::def::{\n };\n use rustc::hir::def::Namespace::*;\n use rustc::hir::def_id::{CRATE_DEF_INDEX, LOCAL_CRATE, DefId};\n-use rustc::hir::{Freevar, FreevarMap, TraitCandidate, TraitMap, GlobMap};\n+use rustc::hir::{Upvar, UpvarMap, TraitCandidate, TraitMap, GlobMap};\n use rustc::ty::{self, DefIdTree};\n use rustc::util::nodemap::{NodeMap, NodeSet, FxHashMap, FxHashSet, DefIdMap};\n use rustc::{bug, span_bug};\n@@ -1668,8 +1668,8 @@ pub struct Resolver<'a> {\n     /// Resolutions for labels (node IDs of their corresponding blocks or loops).\n     label_res_map: NodeMap<NodeId>,\n \n-    pub freevars: FreevarMap,\n-    freevars_seen: NodeMap<NodeMap<usize>>,\n+    pub upvars: UpvarMap,\n+    upvars_seen: NodeMap<NodeMap<usize>>,\n     pub export_map: ExportMap<NodeId>,\n     pub trait_map: TraitMap,\n \n@@ -2033,8 +2033,8 @@ impl<'a> Resolver<'a> {\n             partial_res_map: Default::default(),\n             import_res_map: Default::default(),\n             label_res_map: Default::default(),\n-            freevars: Default::default(),\n-            freevars_seen: Default::default(),\n+            upvars: Default::default(),\n+            upvars_seen: Default::default(),\n             export_map: FxHashMap::default(),\n             trait_map: Default::default(),\n             module_map,\n@@ -4054,21 +4054,21 @@ impl<'a> Resolver<'a> {\n                         ClosureRibKind(function_id) => {\n                             let prev_res = res;\n \n-                            let seen = self.freevars_seen\n+                            let seen = self.upvars_seen\n                                            .entry(function_id)\n                                            .or_default();\n                             if let Some(&index) = seen.get(&node_id) {\n                                 res = Res::Upvar(node_id, index, function_id);\n                                 continue;\n                             }\n-                            let vec = self.freevars\n+                            let vec = self.upvars\n                                           .entry(function_id)\n                                           .or_default();\n                             let depth = vec.len();\n                             res = Res::Upvar(node_id, depth, function_id);\n \n                             if record_used {\n-                                vec.push(Freevar {\n+                                vec.push(Upvar {\n                                     res: prev_res,\n                                     span,\n                                 });"}, {"sha": "d21ceb983f8f4cf6f2ef0843a2199ef68270a822", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2c7712b3f11ad18fbe907e520276385432f5bb10/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c7712b3f11ad18fbe907e520276385432f5bb10/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=2c7712b3f11ad18fbe907e520276385432f5bb10", "patch": "@@ -721,9 +721,8 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n \n         let b = self.shallow_resolve(b);\n \n-        let hir_id_a = self.tcx.hir().as_local_hir_id(def_id_a).unwrap();\n         match b.sty {\n-            ty::FnPtr(fn_ty) if self.tcx.with_freevars(hir_id_a, |v| v.is_empty()) => {\n+            ty::FnPtr(fn_ty) if self.tcx.upvars(def_id_a).map_or(true, |v| v.is_empty()) => {\n                 // We coerce the closure, which has fn type\n                 //     `extern \"rust-call\" fn((arg0,arg1,...)) -> _`\n                 // to"}, {"sha": "c3861f964e4534dfe39e7363ea07a2ec73ed0463", "filename": "src/librustc_typeck/check/upvar.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/2c7712b3f11ad18fbe907e520276385432f5bb10/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c7712b3f11ad18fbe907e520276385432f5bb10/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs?ref=2c7712b3f11ad18fbe907e520276385432f5bb10", "patch": "@@ -121,28 +121,28 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             None\n         };\n \n-        self.tcx.with_freevars(closure_hir_id, |freevars| {\n-            let mut freevar_list: Vec<ty::UpvarId> = Vec::with_capacity(freevars.len());\n-            for freevar in freevars {\n+        if let Some(upvars) = self.tcx.upvars(closure_def_id) {\n+            let mut upvar_list: Vec<ty::UpvarId> = Vec::with_capacity(upvars.len());\n+            for upvar in upvars.iter() {\n                 let upvar_id = ty::UpvarId {\n                     var_path: ty::UpvarPath {\n-                        hir_id: freevar.var_id(),\n+                        hir_id: upvar.var_id(),\n                     },\n                     closure_expr_id: LocalDefId::from_def_id(closure_def_id),\n                 };\n                 debug!(\"seed upvar_id {:?}\", upvar_id);\n                 // Adding the upvar Id to the list of Upvars, which will be added\n                 // to the map for the closure at the end of the for loop.\n-                freevar_list.push(upvar_id);\n+                upvar_list.push(upvar_id);\n \n                 let capture_kind = match capture_clause {\n                     hir::CaptureByValue => ty::UpvarCapture::ByValue,\n                     hir::CaptureByRef => {\n                         let origin = UpvarRegion(upvar_id, span);\n-                        let freevar_region = self.next_region_var(origin);\n+                        let upvar_region = self.next_region_var(origin);\n                         let upvar_borrow = ty::UpvarBorrow {\n                             kind: ty::ImmBorrow,\n-                            region: freevar_region,\n+                            region: upvar_region,\n                         };\n                         ty::UpvarCapture::ByRef(upvar_borrow)\n                     }\n@@ -153,16 +153,16 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     .upvar_capture_map\n                     .insert(upvar_id, capture_kind);\n             }\n-            // Add the vector of freevars to the map keyed with the closure id.\n+            // Add the vector of upvars to the map keyed with the closure id.\n             // This gives us an easier access to them without having to call\n-            // with_freevars again..\n-            if !freevar_list.is_empty() {\n+            // tcx.upvars again..\n+            if !upvar_list.is_empty() {\n                 self.tables\n                     .borrow_mut()\n                     .upvar_list\n-                    .insert(closure_def_id, freevar_list);\n+                    .insert(closure_def_id, upvar_list);\n             }\n-        });\n+        }\n \n         let body_owner_def_id = self.tcx.hir().body_owner_def_id(body.id());\n         let region_scope_tree = &self.tcx.region_scope_tree(body_owner_def_id);\n@@ -244,38 +244,38 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // This may change if abstract return types of some sort are\n         // implemented.\n         let tcx = self.tcx;\n-        let closure_def_index = tcx.hir().local_def_id_from_hir_id(closure_id);\n+        let closure_def_id = tcx.hir().local_def_id_from_hir_id(closure_id);\n \n-        tcx.with_freevars(closure_id, |freevars| {\n-            freevars\n+        tcx.upvars(closure_def_id).iter().flat_map(|upvars| {\n+            upvars\n                 .iter()\n-                .map(|freevar| {\n-                    let var_hir_id = freevar.var_id();\n-                    let freevar_ty = self.node_ty(var_hir_id);\n+                .map(|upvar| {\n+                    let var_hir_id = upvar.var_id();\n+                    let upvar_ty = self.node_ty(var_hir_id);\n                     let upvar_id = ty::UpvarId {\n                         var_path: ty::UpvarPath { hir_id: var_hir_id },\n-                        closure_expr_id: LocalDefId::from_def_id(closure_def_index),\n+                        closure_expr_id: LocalDefId::from_def_id(closure_def_id),\n                     };\n                     let capture = self.tables.borrow().upvar_capture(upvar_id);\n \n                     debug!(\n-                        \"var_id={:?} freevar_ty={:?} capture={:?}\",\n-                        var_hir_id, freevar_ty, capture\n+                        \"var_id={:?} upvar_ty={:?} capture={:?}\",\n+                        var_hir_id, upvar_ty, capture\n                     );\n \n                     match capture {\n-                        ty::UpvarCapture::ByValue => freevar_ty,\n+                        ty::UpvarCapture::ByValue => upvar_ty,\n                         ty::UpvarCapture::ByRef(borrow) => tcx.mk_ref(\n                             borrow.region,\n                             ty::TypeAndMut {\n-                                ty: freevar_ty,\n+                                ty: upvar_ty,\n                                 mutbl: borrow.kind.to_mutbl_lossy(),\n                             },\n                         ),\n                     }\n                 })\n-                .collect()\n         })\n+            .collect()\n     }\n }\n "}, {"sha": "4185999fdd6d734e8c9acae0ff4d1df9dbb4826d", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2c7712b3f11ad18fbe907e520276385432f5bb10/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c7712b3f11ad18fbe907e520276385432f5bb10/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=2c7712b3f11ad18fbe907e520276385432f5bb10", "patch": "@@ -1093,8 +1093,8 @@ fn generics_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> &'tcx ty\n                 }),\n         );\n \n-        tcx.with_freevars(hir_id, |fv| {\n-            params.extend(fv.iter().zip((dummy_args.len() as u32)..).map(|(_, i)| {\n+        if let Some(upvars) = tcx.upvars(def_id) {\n+            params.extend(upvars.iter().zip((dummy_args.len() as u32)..).map(|(_, i)| {\n                 ty::GenericParamDef {\n                     index: type_start + i,\n                     name: Symbol::intern(\"<upvar>\").as_interned_str(),\n@@ -1107,7 +1107,7 @@ fn generics_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> &'tcx ty\n                     },\n                 }\n             }));\n-        });\n+        }\n     }\n \n     let param_def_id_to_index = params"}]}