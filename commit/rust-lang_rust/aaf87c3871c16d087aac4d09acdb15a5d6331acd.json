{"sha": "aaf87c3871c16d087aac4d09acdb15a5d6331acd", "node_id": "C_kwDOAAsO6NoAKGFhZjg3YzM4NzFjMTZkMDg3YWFjNGQwOWFjZGIxNWE1ZDYzMzFhY2Q", "commit": {"author": {"name": "tamaron", "email": "tamaron1203@gmail.com", "date": "2022-05-10T14:08:18Z"}, "committer": {"name": "tamaron", "email": "tamaron1203@gmail.com", "date": "2022-05-10T14:54:42Z"}, "message": "fix", "tree": {"sha": "9e4626002c9c3e6aa375f62dc73971107d05e7bf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9e4626002c9c3e6aa375f62dc73971107d05e7bf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/aaf87c3871c16d087aac4d09acdb15a5d6331acd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/aaf87c3871c16d087aac4d09acdb15a5d6331acd", "html_url": "https://github.com/rust-lang/rust/commit/aaf87c3871c16d087aac4d09acdb15a5d6331acd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/aaf87c3871c16d087aac4d09acdb15a5d6331acd/comments", "author": {"login": "tamaroning", "id": 20992019, "node_id": "MDQ6VXNlcjIwOTkyMDE5", "avatar_url": "https://avatars.githubusercontent.com/u/20992019?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tamaroning", "html_url": "https://github.com/tamaroning", "followers_url": "https://api.github.com/users/tamaroning/followers", "following_url": "https://api.github.com/users/tamaroning/following{/other_user}", "gists_url": "https://api.github.com/users/tamaroning/gists{/gist_id}", "starred_url": "https://api.github.com/users/tamaroning/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tamaroning/subscriptions", "organizations_url": "https://api.github.com/users/tamaroning/orgs", "repos_url": "https://api.github.com/users/tamaroning/repos", "events_url": "https://api.github.com/users/tamaroning/events{/privacy}", "received_events_url": "https://api.github.com/users/tamaroning/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tamaroning", "id": 20992019, "node_id": "MDQ6VXNlcjIwOTkyMDE5", "avatar_url": "https://avatars.githubusercontent.com/u/20992019?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tamaroning", "html_url": "https://github.com/tamaroning", "followers_url": "https://api.github.com/users/tamaroning/followers", "following_url": "https://api.github.com/users/tamaroning/following{/other_user}", "gists_url": "https://api.github.com/users/tamaroning/gists{/gist_id}", "starred_url": "https://api.github.com/users/tamaroning/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tamaroning/subscriptions", "organizations_url": "https://api.github.com/users/tamaroning/orgs", "repos_url": "https://api.github.com/users/tamaroning/repos", "events_url": "https://api.github.com/users/tamaroning/events{/privacy}", "received_events_url": "https://api.github.com/users/tamaroning/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8d8588941ea4dfcbd67b4682ef40d7b409df63e6", "url": "https://api.github.com/repos/rust-lang/rust/commits/8d8588941ea4dfcbd67b4682ef40d7b409df63e6", "html_url": "https://github.com/rust-lang/rust/commit/8d8588941ea4dfcbd67b4682ef40d7b409df63e6"}], "stats": {"total": 218, "additions": 176, "deletions": 42}, "files": [{"sha": "1992f61bdb4343b466461c4a31f895c53ec63549", "filename": "clippy_lints/src/undocumented_unsafe_blocks.rs", "status": "modified", "additions": 67, "deletions": 34, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/aaf87c3871c16d087aac4d09acdb15a5d6331acd/clippy_lints%2Fsrc%2Fundocumented_unsafe_blocks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aaf87c3871c16d087aac4d09acdb15a5d6331acd/clippy_lints%2Fsrc%2Fundocumented_unsafe_blocks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fundocumented_unsafe_blocks.rs?ref=aaf87c3871c16d087aac4d09acdb15a5d6331acd", "patch": "@@ -140,55 +140,59 @@ fn block_has_safety_comment(cx: &LateContext<'_>, block: &hir::Block<'_>) -> boo\n }\n \n /// Checks if the lines immediately preceding the item contain a safety comment.\n+#[allow(clippy::collapsible_match)]\n fn item_has_safety_comment(cx: &LateContext<'_>, item: &hir::Item<'_>) -> bool {\n     if span_from_macro_expansion_has_safety_comment(cx, item.span) || span_in_body_has_safety_comment(cx, item.span) {\n         return true;\n     }\n \n     if item.span.ctxt() == SyntaxContext::root() {\n         if let Some(parent_node) = get_parent_node(cx.tcx, item.hir_id()) {\n-            let mut span_before_item = None;\n-            let mut hi = false;\n-            if let Node::Item(parent_item) = parent_node {\n-                if let ItemKind::Mod(parent_mod) = &parent_item.kind {\n-                    for (idx, item_id) in parent_mod.item_ids.iter().enumerate() {\n-                        if *item_id == item.item_id() {\n-                            if idx == 0 {\n-                                // mod A { /* comment */ unsafe impl T {} ... }\n-                                // ^------------------------------------------^ gets this span\n-                                // ^---------------------^ finally checks the text in this range\n-                                hi = false;\n-                                span_before_item = Some(parent_item.span);\n-                            } else {\n-                                let prev_item = cx.tcx.hir().item(parent_mod.item_ids[idx - 1]);\n-                                // some_item /* comment */ unsafe impl T {}\n-                                // ^-------^ gets this span\n-                                //         ^---------------^ finally checks the text in this range\n-                                hi = true;\n-                                span_before_item = Some(prev_item.span);\n-                            }\n-                            break;\n+            let comment_start;\n+            match parent_node {\n+                Node::Crate(parent_mod) => {\n+                    comment_start = comment_start_before_impl_in_mod(cx, parent_mod, parent_mod.spans.inner_span, item);\n+                },\n+                Node::Item(parent_item) => {\n+                    if let ItemKind::Mod(parent_mod) = &parent_item.kind {\n+                        comment_start = comment_start_before_impl_in_mod(cx, parent_mod, parent_item.span, item);\n+                    } else {\n+                        // Doesn't support impls in this position. Pretend a comment was found.\n+                        return true;\n+                    }\n+                },\n+                Node::Stmt(stmt) => {\n+                    if let Some(stmt_parent) = get_parent_node(cx.tcx, stmt.hir_id) {\n+                        match stmt_parent {\n+                            Node::Block(block) => {\n+                                comment_start = walk_span_to_context(block.span, SyntaxContext::root()).map(Span::lo);\n+                            },\n+                            _ => {\n+                                // Doesn't support impls in this position. Pretend a comment was found.\n+                                return true;\n+                            },\n                         }\n+                    } else {\n+                        // Doesn't support impls in this position. Pretend a comment was found.\n+                        return true;\n                     }\n-                }\n+                },\n+                _ => {\n+                    // Doesn't support impls in this position. Pretend a comment was found.\n+                    return true;\n+                },\n             }\n-            let span_before_item = span_before_item.unwrap();\n \n             let source_map = cx.sess().source_map();\n-            if let Some(item_span) = walk_span_to_context(item.span, SyntaxContext::root())\n-                && let Some(span_before_item) = walk_span_to_context(span_before_item, SyntaxContext::root())\n-                && let Ok(unsafe_line) = source_map.lookup_line(item_span.lo())\n-                && let Ok(line_before_unsafe) = source_map.lookup_line(if hi {\n-                    span_before_item.hi()\n-                } else {\n-                    span_before_item.lo()\n-                })\n-                && Lrc::ptr_eq(&unsafe_line.sf, &line_before_unsafe.sf)\n+            if let Some(comment_start) = comment_start\n+                && let Ok(unsafe_line) = source_map.lookup_line(item.span.lo())\n+                && let Ok(comment_start_line) = source_map.lookup_line(comment_start)\n+                && Lrc::ptr_eq(&unsafe_line.sf, &comment_start_line.sf)\n                 && let Some(src) = unsafe_line.sf.src.as_deref()\n             {\n-                line_before_unsafe.line < unsafe_line.line && text_has_safety_comment(\n+                comment_start_line.line < unsafe_line.line && text_has_safety_comment(\n                     src,\n-                    &unsafe_line.sf.lines[line_before_unsafe.line + 1..=unsafe_line.line],\n+                    &unsafe_line.sf.lines[comment_start_line.line + 1..=unsafe_line.line],\n                     unsafe_line.sf.start_pos.to_usize(),\n                 )\n             } else {\n@@ -204,6 +208,35 @@ fn item_has_safety_comment(cx: &LateContext<'_>, item: &hir::Item<'_>) -> bool {\n     }\n }\n \n+fn comment_start_before_impl_in_mod(\n+    cx: &LateContext<'_>,\n+    parent_mod: &hir::Mod<'_>,\n+    parent_mod_span: Span,\n+    imple: &hir::Item<'_>,\n+) -> Option<BytePos> {\n+    parent_mod.item_ids.iter().enumerate().find_map(|(idx, item_id)| {\n+        if *item_id == imple.item_id() {\n+            if idx == 0 {\n+                // mod A { /* comment */ unsafe impl T {} ... }\n+                // ^------------------------------------------^ returns the start of this span\n+                //       ^---------------^ finally checks comments in this range\n+                if let Some(sp) = walk_span_to_context(parent_mod_span, SyntaxContext::root()) {\n+                    return Some(sp.lo());\n+                }\n+            } else {\n+                // some_item /* comment */ unsafe impl T {}\n+                // ^-------^ returns the end of this span\n+                //         ^---------------^ finally checks comments in this range\n+                let prev_item = cx.tcx.hir().item(parent_mod.item_ids[idx - 1]);\n+                if let Some(sp) = walk_span_to_context(prev_item.span, SyntaxContext::root()) {\n+                    return Some(sp.hi());\n+                }\n+            }\n+        }\n+        None\n+    })\n+}\n+\n fn span_from_macro_expansion_has_safety_comment(cx: &LateContext<'_>, span: Span) -> bool {\n     let source_map = cx.sess().source_map();\n     let ctxt = span.ctxt();"}, {"sha": "33b6a82f9d2c32cefabdc09ca2c4ec6786039e4b", "filename": "tests/ui/undocumented_unsafe_blocks.rs", "status": "modified", "additions": 47, "deletions": 2, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/aaf87c3871c16d087aac4d09acdb15a5d6331acd/tests%2Fui%2Fundocumented_unsafe_blocks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aaf87c3871c16d087aac4d09acdb15a5d6331acd/tests%2Fui%2Fundocumented_unsafe_blocks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fundocumented_unsafe_blocks.rs?ref=aaf87c3871c16d087aac4d09acdb15a5d6331acd", "patch": "@@ -344,7 +344,7 @@ mod unsafe_impl_smoke_test {\n     unsafe impl A for (i32) {}\n \n     mod sub_mod {\n-        // error: also works for the first item\n+        // error:\n         unsafe impl B for (u32) {}\n         unsafe trait B {}\n     }\n@@ -363,24 +363,51 @@ mod unsafe_impl_smoke_test {\n mod unsafe_impl_from_macro {\n     unsafe trait T {}\n \n+    // error\n     macro_rules! no_safety_comment {\n         ($t:ty) => {\n             unsafe impl T for $t {}\n         };\n     }\n-    // error\n+\n+    // ok\n     no_safety_comment!(());\n \n+    // ok\n     macro_rules! with_safety_comment {\n         ($t:ty) => {\n             // SAFETY:\n             unsafe impl T for $t {}\n         };\n     }\n+\n     // ok\n     with_safety_comment!((i32));\n }\n \n+mod unsafe_impl_macro_and_not_macro {\n+    unsafe trait T {}\n+\n+    // error\n+    macro_rules! no_safety_comment {\n+        ($t:ty) => {\n+            unsafe impl T for $t {}\n+        };\n+    }\n+\n+    // ok\n+    no_safety_comment!(());\n+\n+    // error\n+    unsafe impl T for (i32) {}\n+\n+    // ok\n+    no_safety_comment!(u32);\n+\n+    // error\n+    unsafe impl T for (bool) {}\n+}\n+\n #[rustfmt::skip]\n mod unsafe_impl_valid_comment {\n     unsafe trait SaFety {}\n@@ -440,4 +467,22 @@ mod unsafe_impl_invalid_comment {\n     unsafe impl Interference for () {}\n }\n \n+unsafe trait ImplInFn {}\n+\n+fn impl_in_fn() {\n+    // error\n+    unsafe impl ImplInFn for () {}\n+\n+    // SAFETY: ok\n+    unsafe impl ImplInFn for (i32) {}\n+}\n+\n+unsafe trait CrateRoot {}\n+\n+// error\n+unsafe impl CrateRoot for () {}\n+\n+// SAFETY: ok\n+unsafe impl CrateRoot for (i32) {}\n+\n fn main() {}"}, {"sha": "b79949e9d06d6af18a3602f980fe15f5fe30a6ec", "filename": "tests/ui/undocumented_unsafe_blocks.stderr", "status": "modified", "additions": 62, "deletions": 6, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/aaf87c3871c16d087aac4d09acdb15a5d6331acd/tests%2Fui%2Fundocumented_unsafe_blocks.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/aaf87c3871c16d087aac4d09acdb15a5d6331acd/tests%2Fui%2Fundocumented_unsafe_blocks.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fundocumented_unsafe_blocks.stderr?ref=aaf87c3871c16d087aac4d09acdb15a5d6331acd", "patch": "@@ -164,7 +164,7 @@ LL |         unsafe impl B for (u32) {}\n    = help: consider adding a safety comment on the preceding line\n \n error: unsafe impl missing a safety comment\n-  --> $DIR/undocumented_unsafe_blocks.rs:368:13\n+  --> $DIR/undocumented_unsafe_blocks.rs:369:13\n    |\n LL |             unsafe impl T for $t {}\n    |             ^^^^^^^^^^^^^^^^^^^^^^^\n@@ -176,36 +176,92 @@ LL |     no_safety_comment!(());\n    = note: this error originates in the macro `no_safety_comment` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: unsafe impl missing a safety comment\n-  --> $DIR/undocumented_unsafe_blocks.rs:427:5\n+  --> $DIR/undocumented_unsafe_blocks.rs:394:13\n+   |\n+LL |             unsafe impl T for $t {}\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^\n+...\n+LL |     no_safety_comment!(());\n+   |     ---------------------- in this macro invocation\n+   |\n+   = help: consider adding a safety comment on the preceding line\n+   = note: this error originates in the macro `no_safety_comment` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: unsafe impl missing a safety comment\n+  --> $DIR/undocumented_unsafe_blocks.rs:402:5\n+   |\n+LL |     unsafe impl T for (i32) {}\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider adding a safety comment on the preceding line\n+\n+error: unsafe impl missing a safety comment\n+  --> $DIR/undocumented_unsafe_blocks.rs:394:13\n+   |\n+LL |             unsafe impl T for $t {}\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^\n+...\n+LL |     no_safety_comment!(u32);\n+   |     ----------------------- in this macro invocation\n+   |\n+   = help: consider adding a safety comment on the preceding line\n+   = note: this error originates in the macro `no_safety_comment` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: unsafe impl missing a safety comment\n+  --> $DIR/undocumented_unsafe_blocks.rs:408:5\n+   |\n+LL |     unsafe impl T for (bool) {}\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider adding a safety comment on the preceding line\n+\n+error: unsafe impl missing a safety comment\n+  --> $DIR/undocumented_unsafe_blocks.rs:454:5\n    |\n LL |     unsafe impl NoComment for () {}\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: consider adding a safety comment on the preceding line\n \n error: unsafe impl missing a safety comment\n-  --> $DIR/undocumented_unsafe_blocks.rs:431:19\n+  --> $DIR/undocumented_unsafe_blocks.rs:458:19\n    |\n LL |     /* SAFETY: */ unsafe impl InlineComment for () {}\n    |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: consider adding a safety comment on the preceding line\n \n error: unsafe impl missing a safety comment\n-  --> $DIR/undocumented_unsafe_blocks.rs:435:5\n+  --> $DIR/undocumented_unsafe_blocks.rs:462:5\n    |\n LL |     unsafe impl TrailingComment for () {} // SAFETY:\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: consider adding a safety comment on the preceding line\n \n error: unsafe impl missing a safety comment\n-  --> $DIR/undocumented_unsafe_blocks.rs:440:5\n+  --> $DIR/undocumented_unsafe_blocks.rs:467:5\n    |\n LL |     unsafe impl Interference for () {}\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: consider adding a safety comment on the preceding line\n \n-error: aborting due to 25 previous errors\n+error: unsafe impl missing a safety comment\n+  --> $DIR/undocumented_unsafe_blocks.rs:474:5\n+   |\n+LL |     unsafe impl ImplInFn for () {}\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider adding a safety comment on the preceding line\n+\n+error: unsafe impl missing a safety comment\n+  --> $DIR/undocumented_unsafe_blocks.rs:483:1\n+   |\n+LL | unsafe impl CrateRoot for () {}\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider adding a safety comment on the preceding line\n+\n+error: aborting due to 31 previous errors\n "}]}