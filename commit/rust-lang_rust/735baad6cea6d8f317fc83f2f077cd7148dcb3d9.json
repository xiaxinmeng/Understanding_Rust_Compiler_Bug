{"sha": "735baad6cea6d8f317fc83f2f077cd7148dcb3d9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjczNWJhYWQ2Y2VhNmQ4ZjMxN2ZjODNmMmYwNzdjZDcxNDhkY2IzZDk=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-07-14T11:13:58Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-07-14T11:13:58Z"}, "message": "Merge #5368\n\n5368: Compress match checking tests r=matklad a=matklad\n\n\n\nbors r+\n\ud83e\udd16\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "fc82048ad3ff5103f19fc27206e0fcf1353e17a6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fc82048ad3ff5103f19fc27206e0fcf1353e17a6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/735baad6cea6d8f317fc83f2f077cd7148dcb3d9", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfDZN2CRBK7hj4Ov3rIwAAdHIIAGmoKNwWqxCB7A/aJF+9ooIB\nkaoJ1hieXQkbS7PLLHwP1r9juK0hvbWYckvMbBovsgsuXupH48p6ym3i1OFOxQRZ\nvY9b8tg0usxt14ThFOsqrcdSkx72oDvxh8ODYOaEiM4WgVNyiWzktoOSCIUNO8Mg\nitUL4Ijx9d86DTejw2BhQls4DKbDluvB+sQNhRcsKO7DY1F8pKKN2Pt0kvK9KgFy\nuY+DmMAYMTExICudUZkU9mx1XcdbNyOAAWz1GRTAk59eyFIZyBudHjmrTY8oNH4p\nR0lLqhSRjgT9UKaH28XEGRgH05Y8Rbm7L+KBwMz9HKsup4zV7Ob062qDOVsoUrQ=\n=wFXN\n-----END PGP SIGNATURE-----\n", "payload": "tree fc82048ad3ff5103f19fc27206e0fcf1353e17a6\nparent 510866b4a1a812414568bd96f1d197587ead78c0\nparent b031899dac6ad5847cc2f5551766a567657f095d\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1594725238 +0000\ncommitter GitHub <noreply@github.com> 1594725238 +0000\n\nMerge #5368\n\n5368: Compress match checking tests r=matklad a=matklad\n\n\n\nbors r+\n\ud83e\udd16\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/735baad6cea6d8f317fc83f2f077cd7148dcb3d9", "html_url": "https://github.com/rust-lang/rust/commit/735baad6cea6d8f317fc83f2f077cd7148dcb3d9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/735baad6cea6d8f317fc83f2f077cd7148dcb3d9/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "510866b4a1a812414568bd96f1d197587ead78c0", "url": "https://api.github.com/repos/rust-lang/rust/commits/510866b4a1a812414568bd96f1d197587ead78c0", "html_url": "https://github.com/rust-lang/rust/commit/510866b4a1a812414568bd96f1d197587ead78c0"}, {"sha": "b031899dac6ad5847cc2f5551766a567657f095d", "url": "https://api.github.com/repos/rust-lang/rust/commits/b031899dac6ad5847cc2f5551766a567657f095d", "html_url": "https://github.com/rust-lang/rust/commit/b031899dac6ad5847cc2f5551766a567657f095d"}], "stats": {"total": 1778, "additions": 511, "deletions": 1267}, "files": [{"sha": "3016ca3bd5839294392992aa0f75cab3282bdef3", "filename": "crates/ra_hir_ty/src/diagnostics.rs", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/735baad6cea6d8f317fc83f2f077cd7148dcb3d9/crates%2Fra_hir_ty%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/735baad6cea6d8f317fc83f2f077cd7148dcb3d9/crates%2Fra_hir_ty%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Fdiagnostics.rs?ref=735baad6cea6d8f317fc83f2f077cd7148dcb3d9", "patch": "@@ -244,3 +244,28 @@ impl AstDiagnostic for MismatchedArgCount {\n         ast::CallExpr::cast(node).unwrap()\n     }\n }\n+\n+#[cfg(test)]\n+fn check_diagnostics(ra_fixture: &str) {\n+    use ra_db::{fixture::WithFixture, FileId};\n+    use ra_syntax::TextRange;\n+    use rustc_hash::FxHashMap;\n+\n+    use crate::test_db::TestDB;\n+\n+    let db = TestDB::with_files(ra_fixture);\n+    let annotations = db.extract_annotations();\n+\n+    let mut actual: FxHashMap<FileId, Vec<(TextRange, String)>> = FxHashMap::default();\n+    db.diag(|d| {\n+        // FXIME: macros...\n+        let file_id = d.source().file_id.original_file(&db);\n+        let range = d.syntax_node(&db).text_range();\n+        // FIXME: support multi-line messages in annotations\n+        let message = d.message().lines().next().unwrap().to_owned();\n+        actual.entry(file_id).or_default().push((range, message));\n+    });\n+    actual.values_mut().for_each(|diags| diags.sort_by_key(|it| it.0.start()));\n+\n+    assert_eq!(annotations, actual);\n+}"}, {"sha": "277ace1802a67c8663bf3c75491aed9f23821d1f", "filename": "crates/ra_hir_ty/src/diagnostics/expr.rs", "status": "modified", "additions": 70, "deletions": 99, "changes": 169, "blob_url": "https://github.com/rust-lang/rust/blob/735baad6cea6d8f317fc83f2f077cd7148dcb3d9/crates%2Fra_hir_ty%2Fsrc%2Fdiagnostics%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/735baad6cea6d8f317fc83f2f077cd7148dcb3d9/crates%2Fra_hir_ty%2Fsrc%2Fdiagnostics%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Fdiagnostics%2Fexpr.rs?ref=735baad6cea6d8f317fc83f2f077cd7148dcb3d9", "patch": "@@ -376,146 +376,117 @@ pub fn record_pattern_missing_fields(\n \n #[cfg(test)]\n mod tests {\n-    use expect::{expect, Expect};\n-    use ra_db::fixture::WithFixture;\n-\n-    use crate::{diagnostics::MismatchedArgCount, test_db::TestDB};\n-\n-    fn check_diagnostic(ra_fixture: &str, expect: Expect) {\n-        let msg = TestDB::with_single_file(ra_fixture).0.diagnostic::<MismatchedArgCount>().0;\n-        expect.assert_eq(&msg);\n-    }\n-\n-    fn check_no_diagnostic(ra_fixture: &str) {\n-        let (s, diagnostic_count) =\n-            TestDB::with_single_file(ra_fixture).0.diagnostic::<MismatchedArgCount>();\n-\n-        assert_eq!(0, diagnostic_count, \"expected no diagnostic, found one: {}\", s);\n-    }\n+    use crate::diagnostics::check_diagnostics;\n \n     #[test]\n     fn simple_free_fn_zero() {\n-        check_diagnostic(\n-            r\"\n-            fn zero() {}\n-            fn f() { zero(1); }\n-            \",\n-            expect![[\"\\\"zero(1)\\\": Expected 0 arguments, found 1\\n\"]],\n+        check_diagnostics(\n+            r#\"\n+fn zero() {}\n+fn f() { zero(1); }\n+       //^^^^^^^ Expected 0 arguments, found 1\n+\"#,\n         );\n \n-        check_no_diagnostic(\n-            r\"\n-            fn zero() {}\n-            fn f() { zero(); }\n-            \",\n+        check_diagnostics(\n+            r#\"\n+fn zero() {}\n+fn f() { zero(); }\n+\"#,\n         );\n     }\n \n     #[test]\n     fn simple_free_fn_one() {\n-        check_diagnostic(\n-            r\"\n-            fn one(arg: u8) {}\n-            fn f() { one(); }\n-            \",\n-            expect![[\"\\\"one()\\\": Expected 1 argument, found 0\\n\"]],\n+        check_diagnostics(\n+            r#\"\n+fn one(arg: u8) {}\n+fn f() { one(); }\n+       //^^^^^ Expected 1 argument, found 0\n+\"#,\n         );\n \n-        check_no_diagnostic(\n-            r\"\n-            fn one(arg: u8) {}\n-            fn f() { one(1); }\n-            \",\n+        check_diagnostics(\n+            r#\"\n+fn one(arg: u8) {}\n+fn f() { one(1); }\n+\"#,\n         );\n     }\n \n     #[test]\n     fn method_as_fn() {\n-        check_diagnostic(\n-            r\"\n-            struct S;\n-            impl S {\n-                fn method(&self) {}\n-            }\n-\n-            fn f() {\n-                S::method();\n-            }\n-            \",\n-            expect![[\"\\\"S::method()\\\": Expected 1 argument, found 0\\n\"]],\n+        check_diagnostics(\n+            r#\"\n+struct S;\n+impl S { fn method(&self) {} }\n+\n+fn f() {\n+    S::method();\n+} //^^^^^^^^^^^ Expected 1 argument, found 0\n+\"#,\n         );\n \n-        check_no_diagnostic(\n-            r\"\n-            struct S;\n-            impl S {\n-                fn method(&self) {}\n-            }\n+        check_diagnostics(\n+            r#\"\n+struct S;\n+impl S { fn method(&self) {} }\n \n-            fn f() {\n-                S::method(&S);\n-                S.method();\n-            }\n-            \",\n+fn f() {\n+    S::method(&S);\n+    S.method();\n+}\n+\"#,\n         );\n     }\n \n     #[test]\n     fn method_with_arg() {\n-        check_diagnostic(\n-            r\"\n-            struct S;\n-            impl S {\n-                fn method(&self, arg: u8) {}\n-            }\n+        check_diagnostics(\n+            r#\"\n+struct S;\n+impl S { fn method(&self, arg: u8) {} }\n \n             fn f() {\n                 S.method();\n-            }\n-            \",\n-            expect![[\"\\\"S.method()\\\": Expected 1 argument, found 0\\n\"]],\n+            } //^^^^^^^^^^ Expected 1 argument, found 0\n+            \"#,\n         );\n \n-        check_no_diagnostic(\n-            r\"\n-            struct S;\n-            impl S {\n-                fn method(&self, arg: u8) {}\n-            }\n+        check_diagnostics(\n+            r#\"\n+struct S;\n+impl S { fn method(&self, arg: u8) {} }\n \n-            fn f() {\n-                S::method(&S, 0);\n-                S.method(1);\n-            }\n-            \",\n+fn f() {\n+    S::method(&S, 0);\n+    S.method(1);\n+}\n+\"#,\n         );\n     }\n \n     #[test]\n     fn tuple_struct() {\n-        check_diagnostic(\n-            r\"\n-            struct Tup(u8, u16);\n-            fn f() {\n-                Tup(0);\n-            }\n-            \",\n-            expect![[\"\\\"Tup(0)\\\": Expected 2 arguments, found 1\\n\"]],\n+        check_diagnostics(\n+            r#\"\n+struct Tup(u8, u16);\n+fn f() {\n+    Tup(0);\n+} //^^^^^^ Expected 2 arguments, found 1\n+\"#,\n         )\n     }\n \n     #[test]\n     fn enum_variant() {\n-        check_diagnostic(\n-            r\"\n-            enum En {\n-                Variant(u8, u16),\n-            }\n-            fn f() {\n-                En::Variant(0);\n-            }\n-            \",\n-            expect![[\"\\\"En::Variant(0)\\\": Expected 2 arguments, found 1\\n\"]],\n+        check_diagnostics(\n+            r#\"\n+enum En { Variant(u8, u16), }\n+fn f() {\n+    En::Variant(0);\n+} //^^^^^^^^^^^^^^ Expected 2 arguments, found 1\n+\"#,\n         )\n     }\n }"}, {"sha": "ba48b51b5ea85538ccc3c6bbb0fccf6666143e85", "filename": "crates/ra_hir_ty/src/diagnostics/match_check.rs", "status": "modified", "additions": 412, "deletions": 1149, "changes": 1561, "blob_url": "https://github.com/rust-lang/rust/blob/735baad6cea6d8f317fc83f2f077cd7148dcb3d9/crates%2Fra_hir_ty%2Fsrc%2Fdiagnostics%2Fmatch_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/735baad6cea6d8f317fc83f2f077cd7148dcb3d9/crates%2Fra_hir_ty%2Fsrc%2Fdiagnostics%2Fmatch_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Fdiagnostics%2Fmatch_check.rs?ref=735baad6cea6d8f317fc83f2f077cd7148dcb3d9", "patch": "@@ -41,9 +41,9 @@\n //! ```ignore\n //! // x: (Option<bool>, Result<()>)\n //! match x {\n-//!     (Some(true), _) => {}\n-//!     (None, Err(())) => {}\n-//!     (None, Err(_)) => {}\n+//!     (Some(true), _) => (),\n+//!     (None, Err(())) => (),\n+//!     (None, Err(_)) => (),\n //! }\n //! ```\n //!\n@@ -837,1203 +837,499 @@ fn enum_variant_matches(cx: &MatchCheckCtx, pat_id: PatId, enum_variant_id: Enum\n \n #[cfg(test)]\n mod tests {\n-    use insta::assert_snapshot;\n-    use ra_db::fixture::WithFixture;\n-\n-    use crate::{diagnostics::MissingMatchArms, test_db::TestDB};\n-\n-    fn check_diagnostic_message(ra_fixture: &str) -> String {\n-        TestDB::with_single_file(ra_fixture).0.diagnostic::<MissingMatchArms>().0\n-    }\n-\n-    fn check_diagnostic(ra_fixture: &str) {\n-        let diagnostic_count =\n-            TestDB::with_single_file(ra_fixture).0.diagnostic::<MissingMatchArms>().1;\n-\n-        assert_eq!(1, diagnostic_count, \"no diagnostic reported\");\n-    }\n-\n-    fn check_no_diagnostic(ra_fixture: &str) {\n-        let (s, diagnostic_count) =\n-            TestDB::with_single_file(ra_fixture).0.diagnostic::<MissingMatchArms>();\n-\n-        assert_eq!(0, diagnostic_count, \"expected no diagnostic, found one: {}\", s);\n-    }\n-\n-    #[test]\n-    fn empty_tuple_no_arms_diagnostic_message() {\n-        assert_snapshot!(\n-            check_diagnostic_message(r\"\n-                fn test_fn() {\n-                    match () {\n-                    }\n-                }\n-            \"),\n-            @\"\\\"()\\\": Missing match arm\\n\"\n-        );\n-    }\n-\n-    #[test]\n-    fn empty_tuple_no_arms() {\n-        check_diagnostic(\n-            r\"\n-            fn test_fn() {\n-                match () {\n-                }\n-            }\n-        \",\n-        );\n-    }\n-\n-    #[test]\n-    fn empty_tuple_wild() {\n-        check_no_diagnostic(\n-            r\"\n-            fn test_fn() {\n-                match () {\n-                    _ => {}\n-                }\n-            }\n-        \",\n-        );\n-    }\n+    use crate::diagnostics::check_diagnostics;\n \n     #[test]\n-    fn empty_tuple_no_diagnostic() {\n-        check_no_diagnostic(\n-            r\"\n-            fn test_fn() {\n-                match () {\n-                    () => {}\n-                }\n-            }\n-        \",\n-        );\n-    }\n-\n-    #[test]\n-    fn tuple_of_empty_tuple_no_arms() {\n-        check_diagnostic(\n-            r\"\n-            fn test_fn() {\n-                match (()) {\n-                }\n-            }\n-        \",\n-        );\n-    }\n+    fn empty_tuple() {\n+        check_diagnostics(\n+            r#\"\n+fn main() {\n+    match () { }\n+        //^^ Missing match arm\n+   match (()) { }\n+       //^^^^ Missing match arm\n \n-    #[test]\n-    fn tuple_of_empty_tuple_no_diagnostic() {\n-        check_no_diagnostic(\n-            r\"\n-            fn test_fn() {\n-                match (()) {\n-                    (()) => {}\n-                }\n-            }\n-        \",\n-        );\n-    }\n-\n-    #[test]\n-    fn tuple_of_two_empty_tuple_no_arms() {\n-        check_diagnostic(\n-            r\"\n-            fn test_fn() {\n-                match ((), ()) {\n-                }\n-            }\n-        \",\n-        );\n-    }\n-\n-    #[test]\n-    fn tuple_of_two_empty_tuple_no_diagnostic() {\n-        check_no_diagnostic(\n-            r\"\n-            fn test_fn() {\n-                match ((), ()) {\n-                    ((), ()) => {}\n-                }\n-            }\n-        \",\n-        );\n-    }\n-\n-    #[test]\n-    fn bool_no_arms() {\n-        check_diagnostic(\n-            r\"\n-            fn test_fn() {\n-                match false {\n-                }\n-            }\n-        \",\n-        );\n-    }\n-\n-    #[test]\n-    fn bool_missing_arm() {\n-        check_diagnostic(\n-            r\"\n-            fn test_fn() {\n-                match false {\n-                    true => {}\n-                }\n-            }\n-        \",\n-        );\n-    }\n-\n-    #[test]\n-    fn bool_no_diagnostic() {\n-        check_no_diagnostic(\n-            r\"\n-            fn test_fn() {\n-                match false {\n-                    true => {}\n-                    false => {}\n-                }\n-            }\n-        \",\n-        );\n-    }\n-\n-    #[test]\n-    fn tuple_of_bools_no_arms() {\n-        check_diagnostic(\n-            r\"\n-            fn test_fn() {\n-                match (false, true) {\n-                }\n-            }\n-        \",\n-        );\n-    }\n-\n-    #[test]\n-    fn tuple_of_bools_missing_arms() {\n-        check_diagnostic(\n-            r\"\n-            fn test_fn() {\n-                match (false, true) {\n-                    (true, true) => {},\n-                }\n-            }\n-        \",\n-        );\n-    }\n-\n-    #[test]\n-    fn tuple_of_bools_missing_arm() {\n-        check_diagnostic(\n-            r\"\n-            fn test_fn() {\n-                match (false, true) {\n-                    (false, true) => {},\n-                    (false, false) => {},\n-                    (true, false) => {},\n-                }\n-            }\n-        \",\n-        );\n-    }\n-\n-    #[test]\n-    fn tuple_of_bools_with_wilds() {\n-        check_no_diagnostic(\n-            r\"\n-            fn test_fn() {\n-                match (false, true) {\n-                    (false, _) => {},\n-                    (true, false) => {},\n-                    (_, true) => {},\n-                }\n-            }\n-        \",\n+    match () { _ => (), }\n+    match () { () => (), }\n+    match (()) { (()) => (), }\n+}\n+\"#,\n         );\n     }\n \n     #[test]\n-    fn tuple_of_bools_no_diagnostic() {\n-        check_no_diagnostic(\n-            r\"\n-            fn test_fn() {\n-                match (false, true) {\n-                    (true, true) => {},\n-                    (true, false) => {},\n-                    (false, true) => {},\n-                    (false, false) => {},\n-                }\n-            }\n-        \",\n-        );\n-    }\n+    fn tuple_of_two_empty_tuple() {\n+        check_diagnostics(\n+            r#\"\n+fn main() {\n+    match ((), ()) { }\n+        //^^^^^^^^ Missing match arm\n \n-    #[test]\n-    fn tuple_of_bools_binding_missing_arms() {\n-        check_diagnostic(\n-            r\"\n-            fn test_fn() {\n-                match (false, true) {\n-                    (true, _x) => {},\n-                }\n-            }\n-        \",\n-        );\n-    }\n-\n-    #[test]\n-    fn tuple_of_bools_binding_no_diagnostic() {\n-        check_no_diagnostic(\n-            r\"\n-            fn test_fn() {\n-                match (false, true) {\n-                    (true, _x) => {},\n-                    (false, true) => {},\n-                    (false, false) => {},\n-                }\n-            }\n-        \",\n+    match ((), ()) { ((), ()) => (), }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn boolean() {\n+        check_diagnostics(\n+            r#\"\n+fn test_main() {\n+    match false { }\n+        //^^^^^ Missing match arm\n+    match false { true => (), }\n+        //^^^^^ Missing match arm\n+    match (false, true) {}\n+        //^^^^^^^^^^^^^ Missing match arm\n+    match (false, true) { (true, true) => (), }\n+        //^^^^^^^^^^^^^ Missing match arm\n+    match (false, true) {\n+        //^^^^^^^^^^^^^ Missing match arm\n+        (false, true) => (),\n+        (false, false) => (),\n+        (true, false) => (),\n+    }\n+    match (false, true) { (true, _x) => (), }\n+        //^^^^^^^^^^^^^ Missing match arm\n+\n+    match false { true => (), false => (), }\n+    match (false, true) {\n+        (false, _) => (),\n+        (true, false) => (),\n+        (_, true) => (),\n+    }\n+    match (false, true) {\n+        (true, true) => (),\n+        (true, false) => (),\n+        (false, true) => (),\n+        (false, false) => (),\n+    }\n+    match (false, true) {\n+        (true, _x) => (),\n+        (false, true) => (),\n+        (false, false) => (),\n+    }\n+    match (false, true, false) {\n+        (false, ..) => (),\n+        (true, ..) => (),\n+    }\n+    match (false, true, false) {\n+        (.., false) => (),\n+        (.., true) => (),\n+    }\n+    match (false, true, false) { (..) => (), }\n+}\n+\"#,\n         );\n     }\n \n     #[test]\n-    fn tuple_of_bools_with_ellipsis_at_end_no_diagnostic() {\n-        check_no_diagnostic(\n-            r\"\n-            fn test_fn() {\n-                match (false, true, false) {\n-                    (false, ..) => {},\n-                    (true, ..) => {},\n-                }\n-            }\n-        \",\n-        );\n-    }\n+    fn tuple_of_tuple_and_bools() {\n+        check_diagnostics(\n+            r#\"\n+fn main() {\n+    match (false, ((), false)) {}\n+        //^^^^^^^^^^^^^^^^^^^^ Missing match arm\n+    match (false, ((), false)) { (true, ((), true)) => (), }\n+        //^^^^^^^^^^^^^^^^^^^^ Missing match arm\n+    match (false, ((), false)) { (true, _) => (), }\n+        //^^^^^^^^^^^^^^^^^^^^ Missing match arm\n \n-    #[test]\n-    fn tuple_of_bools_with_ellipsis_at_beginning_no_diagnostic() {\n-        check_no_diagnostic(\n-            r\"\n-            fn test_fn() {\n-                match (false, true, false) {\n-                    (.., false) => {},\n-                    (.., true) => {},\n-                }\n-            }\n-        \",\n-        );\n+    match (false, ((), false)) {\n+        (true, ((), true)) => (),\n+        (true, ((), false)) => (),\n+        (false, ((), true)) => (),\n+        (false, ((), false)) => (),\n     }\n-\n-    #[test]\n-    fn tuple_of_bools_with_ellipsis_no_diagnostic() {\n-        check_no_diagnostic(\n-            r\"\n-            fn test_fn() {\n-                match (false, true, false) {\n-                    (..) => {},\n-                }\n-            }\n-        \",\n-        );\n+    match (false, ((), false)) {\n+        (true, ((), true)) => (),\n+        (true, ((), false)) => (),\n+        (false, _) => (),\n     }\n-\n-    #[test]\n-    fn tuple_of_tuple_and_bools_no_arms() {\n-        check_diagnostic(\n-            r\"\n-            fn test_fn() {\n-                match (false, ((), false)) {\n-                }\n-            }\n-        \",\n+}\n+\"#,\n         );\n     }\n \n     #[test]\n-    fn tuple_of_tuple_and_bools_missing_arms() {\n-        check_diagnostic(\n-            r\"\n-            fn test_fn() {\n-                match (false, ((), false)) {\n-                    (true, ((), true)) => {},\n-                }\n-            }\n-        \",\n-        );\n-    }\n+    fn enums() {\n+        check_diagnostics(\n+            r#\"\n+enum Either { A, B, }\n \n-    #[test]\n-    fn tuple_of_tuple_and_bools_no_diagnostic() {\n-        check_no_diagnostic(\n-            r\"\n-            fn test_fn() {\n-                match (false, ((), false)) {\n-                    (true, ((), true)) => {},\n-                    (true, ((), false)) => {},\n-                    (false, ((), true)) => {},\n-                    (false, ((), false)) => {},\n-                }\n-            }\n-        \",\n-        );\n-    }\n+fn main() {\n+    match Either::A { }\n+        //^^^^^^^^^ Missing match arm\n+    match Either::B { Either::A => (), }\n+        //^^^^^^^^^ Missing match arm\n \n-    #[test]\n-    fn tuple_of_tuple_and_bools_wildcard_missing_arms() {\n-        check_diagnostic(\n-            r\"\n-            fn test_fn() {\n-                match (false, ((), false)) {\n-                    (true, _) => {},\n-                }\n-            }\n-        \",\n-        );\n+    match &Either::B {\n+        //^^^^^^^^^^ Missing match arm\n+        Either::A => (),\n     }\n \n-    #[test]\n-    fn tuple_of_tuple_and_bools_wildcard_no_diagnostic() {\n-        check_no_diagnostic(\n-            r\"\n-            fn test_fn() {\n-                match (false, ((), false)) {\n-                    (true, ((), true)) => {},\n-                    (true, ((), false)) => {},\n-                    (false, _) => {},\n-                }\n-            }\n-        \",\n-        );\n+    match Either::B {\n+        Either::A => (), Either::B => (),\n     }\n-\n-    #[test]\n-    fn enum_no_arms() {\n-        check_diagnostic(\n-            r\"\n-            enum Either {\n-                A,\n-                B,\n-            }\n-            fn test_fn() {\n-                match Either::A {\n-                }\n-            }\n-        \",\n-        );\n+    match &Either::B {\n+        Either::A => (), Either::B => (),\n     }\n-\n-    #[test]\n-    fn enum_missing_arms() {\n-        check_diagnostic(\n-            r\"\n-            enum Either {\n-                A,\n-                B,\n-            }\n-            fn test_fn() {\n-                match Either::B {\n-                    Either::A => {},\n-                }\n-            }\n-        \",\n+}\n+\"#,\n         );\n     }\n \n     #[test]\n-    fn enum_no_diagnostic() {\n-        check_no_diagnostic(\n-            r\"\n-            enum Either {\n-                A,\n-                B,\n-            }\n-            fn test_fn() {\n-                match Either::B {\n-                    Either::A => {},\n-                    Either::B => {},\n-                }\n-            }\n-        \",\n-        );\n-    }\n+    fn enum_containing_bool() {\n+        check_diagnostics(\n+            r#\"\n+enum Either { A(bool), B }\n \n-    #[test]\n-    fn enum_ref_missing_arms() {\n-        check_diagnostic(\n-            r\"\n-            enum Either {\n-                A,\n-                B,\n-            }\n-            fn test_fn() {\n-                match &Either::B {\n-                    Either::A => {},\n-                }\n-            }\n-        \",\n-        );\n+fn main() {\n+    match Either::B { }\n+        //^^^^^^^^^ Missing match arm\n+    match Either::B {\n+        //^^^^^^^^^ Missing match arm\n+        Either::A(true) => (), Either::B => ()\n     }\n \n-    #[test]\n-    fn enum_ref_no_diagnostic() {\n-        check_no_diagnostic(\n-            r\"\n-            enum Either {\n-                A,\n-                B,\n-            }\n-            fn test_fn() {\n-                match &Either::B {\n-                    Either::A => {},\n-                    Either::B => {},\n-                }\n-            }\n-        \",\n-        );\n+    match Either::B {\n+        Either::A(true) => (),\n+        Either::A(false) => (),\n+        Either::B => (),\n     }\n-\n-    #[test]\n-    fn enum_containing_bool_no_arms() {\n-        check_diagnostic(\n-            r\"\n-            enum Either {\n-                A(bool),\n-                B,\n-            }\n-            fn test_fn() {\n-                match Either::B {\n-                }\n-            }\n-        \",\n-        );\n+    match Either::B {\n+        Either::B => (),\n+        _ => (),\n     }\n-\n-    #[test]\n-    fn enum_containing_bool_missing_arms() {\n-        check_diagnostic(\n-            r\"\n-            enum Either {\n-                A(bool),\n-                B,\n-            }\n-            fn test_fn() {\n-                match Either::B {\n-                    Either::A(true) => (),\n-                    Either::B => (),\n-                }\n-            }\n-        \",\n-        );\n+    match Either::B {\n+        Either::A(_) => (),\n+        Either::B => (),\n     }\n \n-    #[test]\n-    fn enum_containing_bool_no_diagnostic() {\n-        check_no_diagnostic(\n-            r\"\n-            enum Either {\n-                A(bool),\n-                B,\n-            }\n-            fn test_fn() {\n-                match Either::B {\n-                    Either::A(true) => (),\n-                    Either::A(false) => (),\n-                    Either::B => (),\n-                }\n-            }\n-        \",\n+}\n+        \"#,\n         );\n     }\n \n     #[test]\n-    fn enum_containing_bool_with_wild_no_diagnostic() {\n-        check_no_diagnostic(\n-            r\"\n-            enum Either {\n-                A(bool),\n-                B,\n-            }\n-            fn test_fn() {\n-                match Either::B {\n-                    Either::B => (),\n-                    _ => (),\n-                }\n-            }\n-        \",\n-        );\n-    }\n+    fn enum_different_sizes() {\n+        check_diagnostics(\n+            r#\"\n+enum Either { A(bool), B(bool, bool) }\n \n-    #[test]\n-    fn enum_containing_bool_with_wild_2_no_diagnostic() {\n-        check_no_diagnostic(\n-            r\"\n-            enum Either {\n-                A(bool),\n-                B,\n-            }\n-            fn test_fn() {\n-                match Either::B {\n-                    Either::A(_) => (),\n-                    Either::B => (),\n-                }\n-            }\n-        \",\n-        );\n+fn main() {\n+    match Either::A(false) {\n+        //^^^^^^^^^^^^^^^^ Missing match arm\n+        Either::A(_) => (),\n+        Either::B(false, _) => (),\n     }\n \n-    #[test]\n-    fn enum_different_sizes_missing_arms() {\n-        check_diagnostic(\n-            r\"\n-            enum Either {\n-                A(bool),\n-                B(bool, bool),\n-            }\n-            fn test_fn() {\n-                match Either::A(false) {\n-                    Either::A(_) => (),\n-                    Either::B(false, _) => (),\n-                }\n-            }\n-        \",\n-        );\n+    match Either::A(false) {\n+        Either::A(_) => (),\n+        Either::B(true, _) => (),\n+        Either::B(false, _) => (),\n     }\n-\n-    #[test]\n-    fn enum_different_sizes_no_diagnostic() {\n-        check_no_diagnostic(\n-            r\"\n-            enum Either {\n-                A(bool),\n-                B(bool, bool),\n-            }\n-            fn test_fn() {\n-                match Either::A(false) {\n-                    Either::A(_) => (),\n-                    Either::B(true, _) => (),\n-                    Either::B(false, _) => (),\n-                }\n-            }\n-        \",\n-        );\n+    match Either::A(false) {\n+        Either::A(true) | Either::A(false) => (),\n+        Either::B(true, _) => (),\n+        Either::B(false, _) => (),\n     }\n-\n-    #[test]\n-    fn or_no_diagnostic() {\n-        check_no_diagnostic(\n-            r\"\n-            enum Either {\n-                A(bool),\n-                B(bool, bool),\n-            }\n-            fn test_fn() {\n-                match Either::A(false) {\n-                    Either::A(true) | Either::A(false) => (),\n-                    Either::B(true, _) => (),\n-                    Either::B(false, _) => (),\n-                }\n-            }\n-        \",\n+}\n+\"#,\n         );\n     }\n \n     #[test]\n     fn tuple_of_enum_no_diagnostic() {\n-        check_no_diagnostic(\n-            r\"\n-            enum Either {\n-                A(bool),\n-                B(bool, bool),\n-            }\n-            enum Either2 {\n-                C,\n-                D,\n-            }\n-            fn test_fn() {\n-                match (Either::A(false), Either2::C) {\n-                    (Either::A(true), _) | (Either::A(false), _) => (),\n-                    (Either::B(true, _), Either2::C) => (),\n-                    (Either::B(false, _), Either2::C) => (),\n-                    (Either::B(_, _), Either2::D) => (),\n-                }\n-            }\n-        \",\n-        );\n+        check_diagnostics(\n+            r#\"\n+enum Either { A(bool), B(bool, bool) }\n+enum Either2 { C, D }\n+\n+fn main() {\n+    match (Either::A(false), Either2::C) {\n+        (Either::A(true), _) | (Either::A(false), _) => (),\n+        (Either::B(true, _), Either2::C) => (),\n+        (Either::B(false, _), Either2::C) => (),\n+        (Either::B(_, _), Either2::D) => (),\n     }\n-\n-    #[test]\n-    fn mismatched_types() {\n-        // Match statements with arms that don't match the\n-        // expression pattern do not fire this diagnostic.\n-        check_no_diagnostic(\n-            r\"\n-            enum Either {\n-                A,\n-                B,\n-            }\n-            enum Either2 {\n-                C,\n-                D,\n-            }\n-            fn test_fn() {\n-                match Either::A {\n-                    Either2::C => (),\n-                    Either2::D => (),\n-                }\n-            }\n-        \",\n-        );\n-    }\n-\n-    #[test]\n-    fn mismatched_types_with_different_arity() {\n-        // Match statements with arms that don't match the\n-        // expression pattern do not fire this diagnostic.\n-        check_no_diagnostic(\n-            r\"\n-            fn test_fn() {\n-                match (true, false) {\n-                    (true, false, true) => (),\n-                    (true) => (),\n-                }\n-            }\n-        \",\n+}\n+\"#,\n         );\n     }\n \n     #[test]\n-    fn malformed_match_arm_tuple_missing_pattern() {\n+    fn mismatched_types() {\n         // Match statements with arms that don't match the\n         // expression pattern do not fire this diagnostic.\n-        check_no_diagnostic(\n-            r\"\n-            fn test_fn() {\n-                match (0) {\n-                    () => (),\n-                }\n-            }\n-        \",\n+        check_diagnostics(\n+            r#\"\n+enum Either { A, B }\n+enum Either2 { C, D }\n+\n+fn main() {\n+    match Either::A {\n+        Either2::C => (),\n+        Either2::D => (),\n+    }\n+    match (true, false) {\n+        (true, false, true) => (),\n+        (true) => (),\n+    }\n+    match (0) { () => () }\n+    match Unresolved::Bar { Unresolved::Baz => () }\n+}\n+        \"#,\n         );\n     }\n \n     #[test]\n     fn malformed_match_arm_tuple_enum_missing_pattern() {\n         // We are testing to be sure we don't panic here when the match\n         // arm `Either::B` is missing its pattern.\n-        check_no_diagnostic(\n-            r\"\n-            enum Either {\n-                A,\n-                B(u32),\n-            }\n-            fn test_fn() {\n-                match Either::A {\n-                    Either::A => (),\n-                    Either::B() => (),\n-                }\n-            }\n-        \",\n-        );\n-    }\n+        check_diagnostics(\n+            r#\"\n+enum Either { A, B(u32) }\n \n-    #[test]\n-    fn enum_not_in_scope() {\n-        // The enum is not in scope so we don't perform exhaustiveness\n-        // checking, but we want to be sure we don't panic here (and\n-        // we don't create a diagnostic).\n-        check_no_diagnostic(\n-            r\"\n-            fn test_fn() {\n-                match Foo::Bar {\n-                    Foo::Baz => (),\n-                }\n-            }\n-        \",\n+fn main() {\n+    match Either::A {\n+        Either::A => (),\n+        Either::B() => (),\n+    }\n+}\n+\"#,\n         );\n     }\n \n     #[test]\n     fn expr_diverges() {\n-        check_no_diagnostic(\n-            r\"\n-            enum Either {\n-                A,\n-                B,\n-            }\n-            fn test_fn() {\n-                match loop {} {\n-                    Either::A => (),\n-                    Either::B => (),\n-                }\n-            }\n-        \",\n-        );\n-    }\n+        check_diagnostics(\n+            r#\"\n+enum Either { A, B }\n \n-    #[test]\n-    fn expr_loop_with_break() {\n-        check_no_diagnostic(\n-            r\"\n-            enum Either {\n-                A,\n-                B,\n-            }\n-            fn test_fn() {\n-                match loop { break Foo::A } {\n-                    Either::A => (),\n-                    Either::B => (),\n-                }\n-            }\n-        \",\n+fn main() {\n+    match loop {} {\n+        Either::A => (),\n+        Either::B => (),\n+    }\n+    match loop {} {\n+        Either::A => (),\n+    }\n+    match loop { break Foo::A } {\n+        //^^^^^^^^^^^^^^^^^^^^^ Missing match arm\n+        Either::A => (),\n+    }\n+    match loop { break Foo::A } {\n+        Either::A => (),\n+        Either::B => (),\n+    }\n+}\n+\"#,\n         );\n     }\n \n     #[test]\n     fn expr_partially_diverges() {\n-        check_no_diagnostic(\n-            r\"\n-            enum Either<T> {\n-                A(T),\n-                B,\n-            }\n-            fn foo() -> Either<!> {\n-                Either::B\n-            }\n-            fn test_fn() -> u32 {\n-                match foo() {\n-                    Either::A(val) => val,\n-                    Either::B => 0,\n-                }\n-            }\n-        \",\n-        );\n-    }\n+        check_diagnostics(\n+            r#\"\n+enum Either<T> { A(T), B }\n \n-    #[test]\n-    fn enum_record_no_arms() {\n-        check_diagnostic(\n-            r\"\n-            enum Either {\n-                A { foo: bool },\n-                B,\n-            }\n-            fn test_fn() {\n-                let a = Either::A { foo: true };\n-                match a {\n-                }\n-            }\n-        \",\n-        );\n+fn foo() -> Either<!> { Either::B }\n+fn main() -> u32 {\n+    match foo() {\n+        Either::A(val) => val,\n+        Either::B => 0,\n     }\n-\n-    #[test]\n-    fn enum_record_missing_arms() {\n-        check_diagnostic(\n-            r\"\n-            enum Either {\n-                A { foo: bool },\n-                B,\n-            }\n-            fn test_fn() {\n-                let a = Either::A { foo: true };\n-                match a {\n-                    Either::A { foo: true } => (),\n-                }\n-            }\n-        \",\n+}\n+\"#,\n         );\n     }\n \n     #[test]\n-    fn enum_record_no_diagnostic() {\n-        check_no_diagnostic(\n-            r\"\n-            enum Either {\n-                A { foo: bool },\n-                B,\n-            }\n-            fn test_fn() {\n-                let a = Either::A { foo: true };\n-                match a {\n-                    Either::A { foo: true } => (),\n-                    Either::A { foo: false } => (),\n-                    Either::B => (),\n-                }\n-            }\n-        \",\n-        );\n-    }\n+    fn enum_record() {\n+        check_diagnostics(\n+            r#\"\n+enum Either { A { foo: bool }, B }\n \n-    #[test]\n-    fn enum_record_missing_field_no_diagnostic() {\n-        // When `Either::A` is missing a struct member, we don't want\n-        // to fire the missing match arm diagnostic. This should fire\n-        // some other diagnostic.\n-        check_no_diagnostic(\n-            r\"\n-            enum Either {\n-                A { foo: bool },\n-                B,\n-            }\n-            fn test_fn() {\n-                let a = Either::B;\n-                match a {\n-                    Either::A { } => (),\n-                    Either::B => (),\n-                }\n-            }\n-        \",\n-        );\n+fn main() {\n+    let a = Either::A { foo: true };\n+    match a { }\n+        //^ Missing match arm\n+    match a { Either::A { foo: true } => () }\n+        //^ Missing match arm\n+    match a {\n+        Either::A { } => (),\n+                //^^^ Missing structure fields:\n+        Either::B => (),\n     }\n+    match a {\n+        //^ Missing match arm\n+        Either::A { } => (),\n+    }           //^^^ Missing structure fields:\n \n-    #[test]\n-    fn enum_record_missing_field_missing_match_arm() {\n-        // Even though `Either::A` is missing fields, we still want to fire\n-        // the missing arm diagnostic here, since we know `Either::B` is missing.\n-        check_diagnostic(\n-            r\"\n-            enum Either {\n-                A { foo: bool },\n-                B,\n-            }\n-            fn test_fn() {\n-                let a = Either::B;\n-                match a {\n-                    Either::A { } => (),\n-                }\n-            }\n-        \",\n-        );\n+    match a {\n+        Either::A { foo: true } => (),\n+        Either::A { foo: false } => (),\n+        Either::B => (),\n     }\n-\n-    #[test]\n-    fn enum_record_no_diagnostic_wild() {\n-        check_no_diagnostic(\n-            r\"\n-            enum Either {\n-                A { foo: bool },\n-                B,\n-            }\n-            fn test_fn() {\n-                let a = Either::A { foo: true };\n-                match a {\n-                    Either::A { foo: _ } => (),\n-                    Either::B => (),\n-                }\n-            }\n-        \",\n-        );\n+    match a {\n+        Either::A { foo: _ } => (),\n+        Either::B => (),\n     }\n-\n-    #[test]\n-    fn enum_record_fields_out_of_order_missing_arm() {\n-        check_diagnostic(\n-            r\"\n-            enum Either {\n-                A { foo: bool, bar: () },\n-                B,\n-            }\n-            fn test_fn() {\n-                let a = Either::A { foo: true };\n-                match a {\n-                    Either::A { bar: (), foo: false } => (),\n-                    Either::A { foo: true, bar: () } => (),\n-                }\n-            }\n-        \",\n+}\n+\"#,\n         );\n     }\n \n     #[test]\n-    fn enum_record_fields_out_of_order_no_diagnostic() {\n-        check_no_diagnostic(\n-            r\"\n-            enum Either {\n-                A { foo: bool, bar: () },\n-                B,\n-            }\n-            fn test_fn() {\n-                let a = Either::A { foo: true };\n-                match a {\n-                    Either::A { bar: (), foo: false } => (),\n-                    Either::A { foo: true, bar: () } => (),\n-                    Either::B => (),\n-                }\n-            }\n-        \",\n-        );\n-    }\n+    fn enum_record_fields_out_of_order() {\n+        check_diagnostics(\n+            r#\"\n+enum Either {\n+    A { foo: bool, bar: () },\n+    B,\n+}\n \n-    #[test]\n-    fn enum_record_ellipsis_missing_arm() {\n-        check_diagnostic(\n-            r\"\n-            enum Either {\n-                A { foo: bool, bar: bool },\n-                B,\n-            }\n-            fn test_fn() {\n-                match Either::B {\n-                    Either::A { foo: true, .. } => (),\n-                    Either::B => (),\n-                }\n-            }\n-        \",\n-        );\n+fn main() {\n+    let a = Either::A { foo: true, bar: () };\n+    match a {\n+        //^ Missing match arm\n+        Either::A { bar: (), foo: false } => (),\n+        Either::A { foo: true, bar: () } => (),\n     }\n \n-    #[test]\n-    fn enum_record_ellipsis_no_diagnostic() {\n-        check_no_diagnostic(\n-            r\"\n-            enum Either {\n-                A { foo: bool, bar: bool },\n-                B,\n-            }\n-            fn test_fn() {\n-                let a = Either::A { foo: true };\n-                match a {\n-                    Either::A { foo: true, .. } => (),\n-                    Either::A { foo: false, .. } => (),\n-                    Either::B => (),\n-                }\n-            }\n-        \",\n-        );\n+    match a {\n+        Either::A { bar: (), foo: false } => (),\n+        Either::A { foo: true, bar: () } => (),\n+        Either::B => (),\n     }\n-\n-    #[test]\n-    fn enum_record_ellipsis_all_fields_missing_arm() {\n-        check_diagnostic(\n-            r\"\n-            enum Either {\n-                A { foo: bool, bar: bool },\n-                B,\n-            }\n-            fn test_fn() {\n-                let a = Either::B;\n-                match a {\n-                    Either::A { .. } => (),\n-                }\n-            }\n-        \",\n+}\n+\"#,\n         );\n     }\n \n     #[test]\n-    fn enum_record_ellipsis_all_fields_no_diagnostic() {\n-        check_no_diagnostic(\n-            r\"\n-            enum Either {\n-                A { foo: bool, bar: bool },\n-                B,\n-            }\n-            fn test_fn() {\n-                let a = Either::B;\n-                match a {\n-                    Either::A { .. } => (),\n-                    Either::B => (),\n-                }\n-            }\n-        \",\n-        );\n-    }\n+    fn enum_record_ellipsis() {\n+        check_diagnostics(\n+            r#\"\n+enum Either {\n+    A { foo: bool, bar: bool },\n+    B,\n+}\n \n-    #[test]\n-    fn enum_tuple_partial_ellipsis_no_diagnostic() {\n-        check_no_diagnostic(\n-            r\"\n-            enum Either {\n-                A(bool, bool, bool, bool),\n-                B,\n-            }\n-            fn test_fn() {\n-                match Either::B {\n-                    Either::A(true, .., true) => {},\n-                    Either::A(true, .., false) => {},\n-                    Either::A(false, .., true) => {},\n-                    Either::A(false, .., false) => {},\n-                    Either::B => {},\n-                }\n-            }\n-        \",\n-        );\n+fn main() {\n+    let a = Either::B;\n+    match a {\n+        //^ Missing match arm\n+        Either::A { foo: true, .. } => (),\n+        Either::B => (),\n     }\n-\n-    #[test]\n-    fn enum_tuple_partial_ellipsis_2_no_diagnostic() {\n-        check_no_diagnostic(\n-            r\"\n-            enum Either {\n-                A(bool, bool, bool, bool),\n-                B,\n-            }\n-            fn test_fn() {\n-                match Either::B {\n-                    Either::A(true, .., true) => {},\n-                    Either::A(true, .., false) => {},\n-                    Either::A(.., true) => {},\n-                    Either::A(.., false) => {},\n-                    Either::B => {},\n-                }\n-            }\n-        \",\n-        );\n+    match a {\n+        //^ Missing match arm\n+        Either::A { .. } => (),\n     }\n \n-    #[test]\n-    fn enum_tuple_partial_ellipsis_missing_arm() {\n-        check_diagnostic(\n-            r\"\n-            enum Either {\n-                A(bool, bool, bool, bool),\n-                B,\n-            }\n-            fn test_fn() {\n-                match Either::B {\n-                    Either::A(true, .., true) => {},\n-                    Either::A(true, .., false) => {},\n-                    Either::A(false, .., false) => {},\n-                    Either::B => {},\n-                }\n-            }\n-        \",\n-        );\n+    match a {\n+        Either::A { foo: true, .. } => (),\n+        Either::A { foo: false, .. } => (),\n+        Either::B => (),\n     }\n \n-    #[test]\n-    fn enum_tuple_partial_ellipsis_2_missing_arm() {\n-        check_diagnostic(\n-            r\"\n-            enum Either {\n-                A(bool, bool, bool, bool),\n-                B,\n-            }\n-            fn test_fn() {\n-                match Either::B {\n-                    Either::A(true, .., true) => {},\n-                    Either::A(true, .., false) => {},\n-                    Either::A(.., true) => {},\n-                    Either::B => {},\n-                }\n-            }\n-        \",\n-        );\n+    match a {\n+        Either::A { .. } => (),\n+        Either::B => (),\n     }\n-\n-    #[test]\n-    fn enum_tuple_ellipsis_no_diagnostic() {\n-        check_no_diagnostic(\n-            r\"\n-            enum Either {\n-                A(bool, bool, bool, bool),\n-                B,\n-            }\n-            fn test_fn() {\n-                match Either::B {\n-                    Either::A(..) => {},\n-                    Either::B => {},\n-                }\n-            }\n-        \",\n+}\n+\"#,\n         );\n     }\n \n     #[test]\n-    fn enum_never() {\n-        check_no_diagnostic(\n-            r\"\n-            enum Never {}\n+    fn enum_tuple_partial_ellipsis() {\n+        check_diagnostics(\n+            r#\"\n+enum Either {\n+    A(bool, bool, bool, bool),\n+    B,\n+}\n \n-            fn test_fn(never: Never) {\n-                match never {}\n-            }\n-        \",\n-        );\n+fn main() {\n+    match Either::B {\n+        //^^^^^^^^^ Missing match arm\n+        Either::A(true, .., true) => (),\n+        Either::A(true, .., false) => (),\n+        Either::A(false, .., false) => (),\n+        Either::B => (),\n+    }\n+    match Either::B {\n+        //^^^^^^^^^ Missing match arm\n+        Either::A(true, .., true) => (),\n+        Either::A(true, .., false) => (),\n+        Either::A(.., true) => (),\n+        Either::B => (),\n+    }\n+\n+    match Either::B {\n+        Either::A(true, .., true) => (),\n+        Either::A(true, .., false) => (),\n+        Either::A(false, .., true) => (),\n+        Either::A(false, .., false) => (),\n+        Either::B => (),\n+    }\n+    match Either::B {\n+        Either::A(true, .., true) => (),\n+        Either::A(true, .., false) => (),\n+        Either::A(.., true) => (),\n+        Either::A(.., false) => (),\n+        Either::B => (),\n     }\n-\n-    #[test]\n-    fn type_never() {\n-        check_no_diagnostic(\n-            r\"\n-            fn test_fn(never: !) {\n-                match never {}\n-            }\n-        \",\n+}\n+\"#,\n         );\n     }\n \n     #[test]\n-    fn enum_never_ref() {\n-        check_no_diagnostic(\n-            r\"\n-            enum Never {}\n+    fn never() {\n+        check_diagnostics(\n+            r#\"\n+enum Never {}\n \n-            fn test_fn(never: &Never) {\n-                match never {}\n-            }\n-        \",\n-        );\n-    }\n-\n-    #[test]\n-    fn expr_diverges_missing_arm() {\n-        check_no_diagnostic(\n-            r\"\n-            enum Either {\n-                A,\n-                B,\n-            }\n-            fn test_fn() {\n-                match loop {} {\n-                    Either::A => (),\n-                }\n-            }\n-        \",\n+fn enum_(never: Never) {\n+    match never {}\n+}\n+fn enum_ref(never: &Never) {\n+    match never {}\n+}\n+fn bang(never: !) {\n+    match never {}\n+}\n+\"#,\n         );\n     }\n \n     #[test]\n     fn or_pattern_panic() {\n-        check_no_diagnostic(\n-            r\"\n-            pub enum Category {\n-                Infinity,\n-                Zero,\n-            }\n+        check_diagnostics(\n+            r#\"\n+pub enum Category { Infinity, Zero }\n \n-            fn panic(a: Category, b: Category) {\n-                match (a, b) {\n-                    (Category::Zero | Category::Infinity, _) => {}\n-                    (_, Category::Zero | Category::Infinity) => {}\n-                }\n-            }\n-        \",\n-        );\n+fn panic(a: Category, b: Category) {\n+    match (a, b) {\n+        (Category::Zero | Category::Infinity, _) => (),\n+        (_, Category::Zero | Category::Infinity) => (),\n     }\n \n-    #[test]\n-    fn or_pattern_panic_2() {\n-        // FIXME: This is a false positive, but the code used to cause a panic in the match checker,\n-        // so this acts as a regression test for that.\n-        check_diagnostic(\n-            r\"\n-            pub enum Category {\n-                Infinity,\n-                Zero,\n-            }\n-\n-            fn panic(a: Category, b: Category) {\n-                match (a, b) {\n-                    (Category::Infinity, Category::Infinity) | (Category::Zero, Category::Zero) => {}\n-\n-                    (Category::Infinity | Category::Zero, _) => {}\n-                }\n-            }\n-        \",\n+    // FIXME: This is a false positive, but the code used to cause a panic in the match checker,\n+    // so this acts as a regression test for that.\n+    match (a, b) {\n+        //^^^^^^ Missing match arm\n+        (Category::Infinity, Category::Infinity) | (Category::Zero, Category::Zero) => (),\n+        (Category::Infinity | Category::Zero, _) => (),\n+    }\n+}\n+\"#,\n         );\n     }\n \n@@ -2051,105 +1347,72 @@ mod tests {\n \n         #[test]\n         fn integers() {\n-            // This is a false negative.\n             // We don't currently check integer exhaustiveness.\n-            check_no_diagnostic(\n-                r\"\n-            fn test_fn() {\n-                match 5 {\n-                    10 => (),\n-                    11..20 => (),\n-                }\n-            }\n-        \",\n+            check_diagnostics(\n+                r#\"\n+fn main() {\n+    match 5 {\n+        10 => (),\n+        11..20 => (),\n+    }\n+}\n+\"#,\n             );\n         }\n \n         #[test]\n         fn internal_or() {\n-            // This is a false negative.\n             // We do not currently handle patterns with internal `or`s.\n-            check_no_diagnostic(\n-                r\"\n-            fn test_fn() {\n-                enum Either {\n-                    A(bool),\n-                    B,\n-                }\n-                match Either::B {\n-                    Either::A(true | false) => (),\n-                }\n-            }\n-        \",\n-            );\n-        }\n-\n-        #[test]\n-        fn expr_loop_missing_arm() {\n-            // This is a false negative.\n-            // We currently infer the type of `loop { break Foo::A }` to `!`, which\n-            // causes us to skip the diagnostic since `Either::A` doesn't type check\n-            // with `!`.\n-            check_diagnostic(\n-                r\"\n-            enum Either {\n-                A,\n-                B,\n-            }\n-            fn test_fn() {\n-                match loop { break Foo::A } {\n-                    Either::A => (),\n-                }\n-            }\n-        \",\n+            check_diagnostics(\n+                r#\"\n+fn main() {\n+    enum Either { A(bool), B }\n+    match Either::B {\n+        Either::A(true | false) => (),\n+    }\n+}\n+\"#,\n             );\n         }\n \n         #[test]\n         fn tuple_of_bools_with_ellipsis_at_end_missing_arm() {\n-            // This is a false negative.\n             // We don't currently handle tuple patterns with ellipsis.\n-            check_no_diagnostic(\n-                r\"\n-            fn test_fn() {\n-                match (false, true, false) {\n-                    (false, ..) => {},\n-                }\n-            }\n-        \",\n+            check_diagnostics(\n+                r#\"\n+fn main() {\n+    match (false, true, false) {\n+        (false, ..) => (),\n+    }\n+}\n+\"#,\n             );\n         }\n \n         #[test]\n         fn tuple_of_bools_with_ellipsis_at_beginning_missing_arm() {\n-            // This is a false negative.\n             // We don't currently handle tuple patterns with ellipsis.\n-            check_no_diagnostic(\n-                r\"\n-            fn test_fn() {\n-                match (false, true, false) {\n-                    (.., false) => {},\n-                }\n-            }\n-        \",\n+            check_diagnostics(\n+                r#\"\n+fn main() {\n+    match (false, true, false) {\n+        (.., false) => (),\n+    }\n+}\n+\"#,\n             );\n         }\n \n         #[test]\n         fn struct_missing_arm() {\n-            // This is a false negative.\n             // We don't currently handle structs.\n-            check_no_diagnostic(\n-                r\"\n-            struct Foo {\n-                a: bool,\n-            }\n-            fn test_fn(f: Foo) {\n-                match f {\n-                    Foo { a: true } => {},\n-                }\n-            }\n-        \",\n+            check_diagnostics(\n+                r#\"\n+struct Foo { a: bool }\n+fn main(f: Foo) {\n+    match f { Foo { a: true } => () }\n+}\n+\"#,\n             );\n         }\n     }"}, {"sha": "fb8723fb78f4c26634c4b2f9e42cb824bba91d9d", "filename": "crates/ra_hir_ty/src/test_db.rs", "status": "modified", "additions": 4, "deletions": 19, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/735baad6cea6d8f317fc83f2f077cd7148dcb3d9/crates%2Fra_hir_ty%2Fsrc%2Ftest_db.rs", "raw_url": "https://github.com/rust-lang/rust/raw/735baad6cea6d8f317fc83f2f077cd7148dcb3d9/crates%2Fra_hir_ty%2Fsrc%2Ftest_db.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftest_db.rs?ref=735baad6cea6d8f317fc83f2f077cd7148dcb3d9", "patch": "@@ -82,7 +82,7 @@ impl FileLoader for TestDB {\n }\n \n impl TestDB {\n-    pub fn module_for_file(&self, file_id: FileId) -> ModuleId {\n+    pub(crate) fn module_for_file(&self, file_id: FileId) -> ModuleId {\n         for &krate in self.relevant_crates(file_id).iter() {\n             let crate_def_map = self.crate_def_map(krate);\n             for (local_id, data) in crate_def_map.modules.iter() {\n@@ -94,7 +94,7 @@ impl TestDB {\n         panic!(\"Can't find module for file\")\n     }\n \n-    fn diag<F: FnMut(&dyn Diagnostic)>(&self, mut cb: F) {\n+    pub(crate) fn diag<F: FnMut(&dyn Diagnostic)>(&self, mut cb: F) {\n         let crate_graph = self.crate_graph();\n         for krate in crate_graph.iter() {\n             let crate_def_map = self.crate_def_map(krate);\n@@ -124,7 +124,7 @@ impl TestDB {\n         }\n     }\n \n-    pub fn diagnostics(&self) -> (String, u32) {\n+    pub(crate) fn diagnostics(&self) -> (String, u32) {\n         let mut buf = String::new();\n         let mut count = 0;\n         self.diag(|d| {\n@@ -134,22 +134,7 @@ impl TestDB {\n         (buf, count)\n     }\n \n-    /// Like `diagnostics`, but filtered for a single diagnostic.\n-    pub fn diagnostic<D: Diagnostic>(&self) -> (String, u32) {\n-        let mut buf = String::new();\n-        let mut count = 0;\n-        self.diag(|d| {\n-            // We want to filter diagnostics by the particular one we are testing for, to\n-            // avoid surprising results in tests.\n-            if d.downcast_ref::<D>().is_some() {\n-                format_to!(buf, \"{:?}: {}\\n\", d.syntax_node(self).text(), d.message());\n-                count += 1;\n-            };\n-        });\n-        (buf, count)\n-    }\n-\n-    pub fn extract_annotations(&self) -> FxHashMap<FileId, Vec<(TextRange, String)>> {\n+    pub(crate) fn extract_annotations(&self) -> FxHashMap<FileId, Vec<(TextRange, String)>> {\n         let mut files = Vec::new();\n         let crate_graph = self.crate_graph();\n         for krate in crate_graph.iter() {"}]}