{"sha": "9a6c04f5d0e6ec47bf150187cffcb7f737799db4", "node_id": "C_kwDOAAsO6NoAKDlhNmMwNGY1ZDBlNmVjNDdiZjE1MDE4N2NmZmNiN2Y3Mzc3OTlkYjQ", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2023-01-21T22:28:54Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2023-02-06T21:51:47Z"}, "message": "Handle discriminants in dataflow-const-prop.", "tree": {"sha": "71aca309dbdcc2eca1326b71c471ef1ac442a775", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/71aca309dbdcc2eca1326b71c471ef1ac442a775"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9a6c04f5d0e6ec47bf150187cffcb7f737799db4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9a6c04f5d0e6ec47bf150187cffcb7f737799db4", "html_url": "https://github.com/rust-lang/rust/commit/9a6c04f5d0e6ec47bf150187cffcb7f737799db4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9a6c04f5d0e6ec47bf150187cffcb7f737799db4/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cd3649b2a595da17dcff983b6d5f74a28a98dd00", "url": "https://api.github.com/repos/rust-lang/rust/commits/cd3649b2a595da17dcff983b6d5f74a28a98dd00", "html_url": "https://github.com/rust-lang/rust/commit/cd3649b2a595da17dcff983b6d5f74a28a98dd00"}], "stats": {"total": 364, "additions": 305, "deletions": 59}, "files": [{"sha": "3e382f500afbe0bc27a2e63ef313afda907b3ca7", "filename": "compiler/rustc_mir_dataflow/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9a6c04f5d0e6ec47bf150187cffcb7f737799db4/compiler%2Frustc_mir_dataflow%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a6c04f5d0e6ec47bf150187cffcb7f737799db4/compiler%2Frustc_mir_dataflow%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_dataflow%2Fsrc%2Flib.rs?ref=9a6c04f5d0e6ec47bf150187cffcb7f737799db4", "patch": "@@ -1,6 +1,7 @@\n #![feature(associated_type_defaults)]\n #![feature(box_patterns)]\n #![feature(exact_size_is_empty)]\n+#![feature(let_chains)]\n #![feature(min_specialization)]\n #![feature(once_cell)]\n #![feature(stmt_expr_attributes)]"}, {"sha": "03b6c182062db4ddd178db58a93e67a76d71d9a3", "filename": "compiler/rustc_mir_dataflow/src/value_analysis.rs", "status": "modified", "additions": 142, "deletions": 31, "changes": 173, "blob_url": "https://github.com/rust-lang/rust/blob/9a6c04f5d0e6ec47bf150187cffcb7f737799db4/compiler%2Frustc_mir_dataflow%2Fsrc%2Fvalue_analysis.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a6c04f5d0e6ec47bf150187cffcb7f737799db4/compiler%2Frustc_mir_dataflow%2Fsrc%2Fvalue_analysis.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_dataflow%2Fsrc%2Fvalue_analysis.rs?ref=9a6c04f5d0e6ec47bf150187cffcb7f737799db4", "patch": "@@ -65,10 +65,8 @@ pub trait ValueAnalysis<'tcx> {\n             StatementKind::Assign(box (place, rvalue)) => {\n                 self.handle_assign(*place, rvalue, state);\n             }\n-            StatementKind::SetDiscriminant { .. } => {\n-                // Could treat this as writing a constant to a pseudo-place.\n-                // But discriminants are currently not tracked, so we do nothing.\n-                // Related: https://github.com/rust-lang/unsafe-code-guidelines/issues/84\n+            StatementKind::SetDiscriminant { box ref place, .. } => {\n+                state.flood_discr(place.as_ref(), self.map());\n             }\n             StatementKind::Intrinsic(box intrinsic) => {\n                 self.handle_intrinsic(intrinsic, state);\n@@ -447,34 +445,39 @@ impl<V: Clone + HasTop + HasBottom> State<V> {\n     }\n \n     pub fn flood_with(&mut self, place: PlaceRef<'_>, map: &Map, value: V) {\n-        if let Some(root) = map.find(place) {\n-            self.flood_idx_with(root, map, value);\n-        }\n+        let StateData::Reachable(values) = &mut self.0 else { return };\n+        map.for_each_aliasing_place(place, None, &mut |place| {\n+            if let Some(vi) = map.places[place].value_index {\n+                values[vi] = value.clone();\n+            }\n+        });\n     }\n \n     pub fn flood(&mut self, place: PlaceRef<'_>, map: &Map) {\n         self.flood_with(place, map, V::top())\n     }\n \n-    pub fn flood_idx_with(&mut self, place: PlaceIndex, map: &Map, value: V) {\n+    pub fn flood_discr_with(&mut self, place: PlaceRef<'_>, map: &Map, value: V) {\n         let StateData::Reachable(values) = &mut self.0 else { return };\n-        map.preorder_invoke(place, &mut |place| {\n+        map.for_each_aliasing_place(place, Some(TrackElem::Discriminant), &mut |place| {\n             if let Some(vi) = map.places[place].value_index {\n                 values[vi] = value.clone();\n             }\n         });\n     }\n \n-    pub fn flood_idx(&mut self, place: PlaceIndex, map: &Map) {\n-        self.flood_idx_with(place, map, V::top())\n+    pub fn flood_discr(&mut self, place: PlaceRef<'_>, map: &Map) {\n+        self.flood_discr_with(place, map, V::top())\n     }\n \n     /// Copies `source` to `target`, including all tracked places beneath.\n     ///\n     /// If `target` contains a place that is not contained in `source`, it will be overwritten with\n     /// Top. Also, because this will copy all entries one after another, it may only be used for\n     /// places that are non-overlapping or identical.\n-    pub fn assign_place_idx(&mut self, target: PlaceIndex, source: PlaceIndex, map: &Map) {\n+    ///\n+    /// The target place must have been flooded before calling this method.\n+    fn assign_place_idx(&mut self, target: PlaceIndex, source: PlaceIndex, map: &Map) {\n         let StateData::Reachable(values) = &mut self.0 else { return };\n \n         // If both places are tracked, we copy the value to the target. If the target is tracked,\n@@ -492,26 +495,28 @@ impl<V: Clone + HasTop + HasBottom> State<V> {\n             let projection = map.places[target_child].proj_elem.unwrap();\n             if let Some(source_child) = map.projections.get(&(source, projection)) {\n                 self.assign_place_idx(target_child, *source_child, map);\n-            } else {\n-                self.flood_idx(target_child, map);\n             }\n         }\n     }\n \n     pub fn assign(&mut self, target: PlaceRef<'_>, result: ValueOrPlace<V>, map: &Map) {\n+        self.flood(target, map);\n         if let Some(target) = map.find(target) {\n             self.assign_idx(target, result, map);\n-        } else {\n-            // We don't track this place nor any projections, assignment can be ignored.\n         }\n     }\n \n+    pub fn assign_discr(&mut self, target: PlaceRef<'_>, result: ValueOrPlace<V>, map: &Map) {\n+        self.flood_discr(target, map);\n+        if let Some(target) = map.find_discr(target) {\n+            self.assign_idx(target, result, map);\n+        }\n+    }\n+\n+    /// The target place must have been flooded before calling this method.\n     pub fn assign_idx(&mut self, target: PlaceIndex, result: ValueOrPlace<V>, map: &Map) {\n         match result {\n             ValueOrPlace::Value(value) => {\n-                // First flood the target place in case we also track any projections (although\n-                // this scenario is currently not well-supported by the API).\n-                self.flood_idx(target, map);\n                 let StateData::Reachable(values) = &mut self.0 else { return };\n                 if let Some(value_index) = map.places[target].value_index {\n                     values[value_index] = value;\n@@ -526,6 +531,14 @@ impl<V: Clone + HasTop + HasBottom> State<V> {\n         map.find(place).map(|place| self.get_idx(place, map)).unwrap_or(V::top())\n     }\n \n+    /// Retrieve the value stored for a place, or \u22a4 if it is not tracked.\n+    pub fn get_discr(&self, place: PlaceRef<'_>, map: &Map) -> V {\n+        match map.find_discr(place) {\n+            Some(place) => self.get_idx(place, map),\n+            None => V::top(),\n+        }\n+    }\n+\n     /// Retrieve the value stored for a place index, or \u22a4 if it is not tracked.\n     pub fn get_idx(&self, place: PlaceIndex, map: &Map) -> V {\n         match &self.0 {\n@@ -582,7 +595,6 @@ impl Map {\n     /// This is currently the only way to create a [`Map`]. The way in which the tracked places are\n     /// chosen is an implementation detail and may not be relied upon (other than that their type\n     /// passes the filter).\n-    #[instrument(skip_all, level = \"debug\")]\n     pub fn from_filter<'tcx>(\n         tcx: TyCtxt<'tcx>,\n         body: &Body<'tcx>,\n@@ -614,7 +626,7 @@ impl Map {\n \n     /// Potentially register the (local, projection) place and its fields, recursively.\n     ///\n-    /// Invariant: The projection must only contain fields.\n+    /// Invariant: The projection must only contain trackable elements.\n     fn register_with_filter_rec<'tcx>(\n         &mut self,\n         tcx: TyCtxt<'tcx>,\n@@ -623,21 +635,46 @@ impl Map {\n         ty: Ty<'tcx>,\n         filter: &mut impl FnMut(Ty<'tcx>) -> bool,\n     ) {\n-        if filter(ty) {\n-            // We know that the projection only contains trackable elements.\n-            let place = self.make_place(local, projection).unwrap();\n+        // We know that the projection only contains trackable elements.\n+        let place = self.make_place(local, projection).unwrap();\n \n-            // Allocate a value slot if it doesn't have one.\n-            if self.places[place].value_index.is_none() {\n-                self.places[place].value_index = Some(self.value_count.into());\n-                self.value_count += 1;\n+        // Allocate a value slot if it doesn't have one, and the user requested one.\n+        if self.places[place].value_index.is_none() && filter(ty) {\n+            self.places[place].value_index = Some(self.value_count.into());\n+            self.value_count += 1;\n+        }\n+\n+        if ty.is_enum() {\n+            let discr_ty = ty.discriminant_ty(tcx);\n+            if filter(discr_ty) {\n+                let discr = *self\n+                    .projections\n+                    .entry((place, TrackElem::Discriminant))\n+                    .or_insert_with(|| {\n+                        // Prepend new child to the linked list.\n+                        let next = self.places.push(PlaceInfo::new(Some(TrackElem::Discriminant)));\n+                        self.places[next].next_sibling = self.places[place].first_child;\n+                        self.places[place].first_child = Some(next);\n+                        next\n+                    });\n+\n+                // Allocate a value slot if it doesn't have one.\n+                if self.places[discr].value_index.is_none() {\n+                    self.places[discr].value_index = Some(self.value_count.into());\n+                    self.value_count += 1;\n+                }\n             }\n         }\n \n         // Recurse with all fields of this place.\n         iter_fields(ty, tcx, |variant, field, ty| {\n-            if variant.is_some() {\n-                // Downcasts are currently not supported.\n+            if let Some(variant) = variant {\n+                projection.push(PlaceElem::Downcast(None, variant));\n+                let _ = self.make_place(local, projection);\n+                projection.push(PlaceElem::Field(field, ty));\n+                self.register_with_filter_rec(tcx, local, projection, ty, filter);\n+                projection.pop();\n+                projection.pop();\n                 return;\n             }\n             projection.push(PlaceElem::Field(field, ty));\n@@ -694,13 +731,77 @@ impl Map {\n         Some(index)\n     }\n \n+    /// Locates the given place, if it exists in the tree.\n+    pub fn find_discr(&self, place: PlaceRef<'_>) -> Option<PlaceIndex> {\n+        let index = self.find(place)?;\n+        self.apply(index, TrackElem::Discriminant)\n+    }\n+\n     /// Iterate over all direct children.\n     pub fn children(&self, parent: PlaceIndex) -> impl Iterator<Item = PlaceIndex> + '_ {\n         Children::new(self, parent)\n     }\n \n+    /// Invoke a function on the given place and all places that may alias it.\n+    ///\n+    /// In particular, when the given place has a variant downcast, we invoke the function on all\n+    /// the other variants.\n+    ///\n+    /// `tail_elem` allows to support discriminants that are not a place in MIR, but that we track\n+    /// as such.\n+    fn for_each_aliasing_place(\n+        &self,\n+        place: PlaceRef<'_>,\n+        tail_elem: Option<TrackElem>,\n+        f: &mut impl FnMut(PlaceIndex),\n+    ) {\n+        let Some(&Some(mut index)) = self.locals.get(place.local) else {\n+            // The local is not tracked at all, nothing to invalidate.\n+            return;\n+        };\n+        let elems = place\n+            .projection\n+            .iter()\n+            .map(|&elem| elem.try_into())\n+            .chain(tail_elem.map(Ok).into_iter());\n+        for elem in elems {\n+            let Ok(elem) = elem else { return };\n+            let sub = self.apply(index, elem);\n+            if let TrackElem::Variant(..) | TrackElem::Discriminant = elem {\n+                // Writing to an enum variant field invalidates the other variants and the discriminant.\n+                self.for_each_variant_sibling(index, sub, f);\n+            }\n+            if let Some(sub) = sub {\n+                index = sub\n+            } else {\n+                return;\n+            }\n+        }\n+        self.preorder_invoke(index, f);\n+    }\n+\n+    /// Invoke the given function on all the descendants of the given place, except one branch.\n+    pub fn for_each_variant_sibling(\n+        &self,\n+        parent: PlaceIndex,\n+        preserved_child: Option<PlaceIndex>,\n+        f: &mut impl FnMut(PlaceIndex),\n+    ) {\n+        for sibling in self.children(parent) {\n+            let elem = self.places[sibling].proj_elem;\n+            // Only invalidate variants and discriminant. Fields (for generators) are not\n+            // invalidated by assignment to a variant.\n+            if let Some(TrackElem::Variant(..) | TrackElem::Discriminant) = elem\n+                // Only invalidate the other variants, the current one is fine.\n+                && Some(sibling) != preserved_child\n+            {\n+                self.preorder_invoke(sibling, f);\n+            }\n+        }\n+    }\n+\n     /// Invoke a function on the given place and all descendants.\n-    pub fn preorder_invoke(&self, root: PlaceIndex, f: &mut impl FnMut(PlaceIndex)) {\n+    fn preorder_invoke(&self, root: PlaceIndex, f: &mut impl FnMut(PlaceIndex)) {\n         f(root);\n         for child in self.children(root) {\n             self.preorder_invoke(child, f);\n@@ -759,6 +860,7 @@ impl<'a> Iterator for Children<'a> {\n }\n \n /// Used as the result of an operand or r-value.\n+#[derive(Debug)]\n pub enum ValueOrPlace<V> {\n     Value(V),\n     Place(PlaceIndex),\n@@ -776,6 +878,8 @@ impl<V: HasTop> ValueOrPlace<V> {\n #[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n pub enum TrackElem {\n     Field(Field),\n+    Variant(VariantIdx),\n+    Discriminant,\n }\n \n impl<V, T> TryFrom<ProjectionElem<V, T>> for TrackElem {\n@@ -784,6 +888,7 @@ impl<V, T> TryFrom<ProjectionElem<V, T>> for TrackElem {\n     fn try_from(value: ProjectionElem<V, T>) -> Result<Self, Self::Error> {\n         match value {\n             ProjectionElem::Field(field, _) => Ok(TrackElem::Field(field)),\n+            ProjectionElem::Downcast(_, idx) => Ok(TrackElem::Variant(idx)),\n             _ => Err(()),\n         }\n     }\n@@ -900,6 +1005,12 @@ fn debug_with_context_rec<V: Debug + Eq>(\n     for child in map.children(place) {\n         let info_elem = map.places[child].proj_elem.unwrap();\n         let child_place_str = match info_elem {\n+            TrackElem::Discriminant => {\n+                format!(\"discriminant({})\", place_str)\n+            }\n+            TrackElem::Variant(idx) => {\n+                format!(\"({} as {:?})\", place_str, idx)\n+            }\n             TrackElem::Field(field) => {\n                 if place_str.starts_with('*') {\n                     format!(\"({}).{}\", place_str, field.index())"}, {"sha": "f10f208f5de3c4ad409b743135587862260e74a7", "filename": "compiler/rustc_mir_transform/src/dataflow_const_prop.rs", "status": "modified", "additions": 85, "deletions": 18, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/9a6c04f5d0e6ec47bf150187cffcb7f737799db4/compiler%2Frustc_mir_transform%2Fsrc%2Fdataflow_const_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a6c04f5d0e6ec47bf150187cffcb7f737799db4/compiler%2Frustc_mir_transform%2Fsrc%2Fdataflow_const_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fdataflow_const_prop.rs?ref=9a6c04f5d0e6ec47bf150187cffcb7f737799db4", "patch": "@@ -13,6 +13,7 @@ use rustc_mir_dataflow::value_analysis::{Map, State, TrackElem, ValueAnalysis, V\n use rustc_mir_dataflow::{lattice::FlatSet, Analysis, ResultsVisitor, SwitchIntEdgeEffects};\n use rustc_span::DUMMY_SP;\n use rustc_target::abi::Align;\n+use rustc_target::abi::VariantIdx;\n \n use crate::MirPass;\n \n@@ -30,6 +31,7 @@ impl<'tcx> MirPass<'tcx> for DataflowConstProp {\n \n     #[instrument(skip_all level = \"debug\")]\n     fn run_pass(&self, tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n+        debug!(def_id = ?body.source.def_id());\n         if tcx.sess.mir_opt_level() < 4 && body.basic_blocks.len() > BLOCK_LIMIT {\n             debug!(\"aborted dataflow const prop due too many basic blocks\");\n             return;\n@@ -63,14 +65,31 @@ impl<'tcx> MirPass<'tcx> for DataflowConstProp {\n     }\n }\n \n-struct ConstAnalysis<'tcx> {\n+struct ConstAnalysis<'a, 'tcx> {\n     map: Map,\n     tcx: TyCtxt<'tcx>,\n+    local_decls: &'a LocalDecls<'tcx>,\n     ecx: InterpCx<'tcx, 'tcx, DummyMachine>,\n     param_env: ty::ParamEnv<'tcx>,\n }\n \n-impl<'tcx> ValueAnalysis<'tcx> for ConstAnalysis<'tcx> {\n+impl<'tcx> ConstAnalysis<'_, 'tcx> {\n+    fn eval_disciminant(\n+        &self,\n+        enum_ty: Ty<'tcx>,\n+        variant_index: VariantIdx,\n+    ) -> Option<ScalarTy<'tcx>> {\n+        if !enum_ty.is_enum() {\n+            return None;\n+        }\n+        let discr = enum_ty.discriminant_for_variant(self.tcx, variant_index)?;\n+        let discr_layout = self.tcx.layout_of(self.param_env.and(discr.ty)).ok()?;\n+        let discr_value = Scalar::try_from_uint(discr.val, discr_layout.size)?;\n+        Some(ScalarTy(discr_value, discr.ty))\n+    }\n+}\n+\n+impl<'tcx> ValueAnalysis<'tcx> for ConstAnalysis<'_, 'tcx> {\n     type Value = FlatSet<ScalarTy<'tcx>>;\n \n     const NAME: &'static str = \"ConstAnalysis\";\n@@ -79,6 +98,25 @@ impl<'tcx> ValueAnalysis<'tcx> for ConstAnalysis<'tcx> {\n         &self.map\n     }\n \n+    fn handle_statement(&self, statement: &Statement<'tcx>, state: &mut State<Self::Value>) {\n+        match statement.kind {\n+            StatementKind::SetDiscriminant { box ref place, variant_index } => {\n+                state.flood_discr(place.as_ref(), &self.map);\n+                if self.map.find_discr(place.as_ref()).is_some() {\n+                    let enum_ty = place.ty(self.local_decls, self.tcx).ty;\n+                    if let Some(discr) = self.eval_disciminant(enum_ty, variant_index) {\n+                        state.assign_discr(\n+                            place.as_ref(),\n+                            ValueOrPlace::Value(FlatSet::Elem(discr)),\n+                            &self.map,\n+                        );\n+                    }\n+                }\n+            }\n+            _ => self.super_statement(statement, state),\n+        }\n+    }\n+\n     fn handle_assign(\n         &self,\n         target: Place<'tcx>,\n@@ -87,17 +125,22 @@ impl<'tcx> ValueAnalysis<'tcx> for ConstAnalysis<'tcx> {\n     ) {\n         match rvalue {\n             Rvalue::Aggregate(kind, operands) => {\n-                let target = self.map().find(target.as_ref());\n-                if let Some(target) = target {\n-                    state.flood_idx_with(target, self.map(), FlatSet::Bottom);\n-                    let field_based = match **kind {\n-                        AggregateKind::Tuple | AggregateKind::Closure(..) => true,\n-                        AggregateKind::Adt(def_id, ..) => {\n-                            matches!(self.tcx.def_kind(def_id), DefKind::Struct)\n+                state.flood_with(target.as_ref(), self.map(), FlatSet::Bottom);\n+                if let Some(target_idx) = self.map().find(target.as_ref()) {\n+                    let (variant_target, variant_index) = match **kind {\n+                        AggregateKind::Tuple | AggregateKind::Closure(..) => {\n+                            (Some(target_idx), None)\n+                        }\n+                        AggregateKind::Adt(def_id, variant_index, ..) => {\n+                            match self.tcx.def_kind(def_id) {\n+                                DefKind::Struct => (Some(target_idx), None),\n+                                DefKind::Enum => (Some(target_idx), Some(variant_index)),\n+                                _ => (None, None),\n+                            }\n                         }\n-                        _ => false,\n+                        _ => (None, None),\n                     };\n-                    if field_based {\n+                    if let Some(target) = variant_target {\n                         for (field_index, operand) in operands.iter().enumerate() {\n                             if let Some(field) = self\n                                 .map()\n@@ -108,15 +151,20 @@ impl<'tcx> ValueAnalysis<'tcx> for ConstAnalysis<'tcx> {\n                             }\n                         }\n                     }\n+                    if let Some(variant_index) = variant_index\n+                        && let Some(discr_idx) = self.map().apply(target_idx, TrackElem::Discriminant)\n+                    {\n+                        let enum_ty = target.ty(self.local_decls, self.tcx).ty;\n+                        if let Some(discr_val) = self.eval_disciminant(enum_ty, variant_index) {\n+                            state.assign_idx(discr_idx, ValueOrPlace::Value(FlatSet::Elem(discr_val)), &self.map);\n+                        }\n+                    }\n                 }\n             }\n             Rvalue::CheckedBinaryOp(op, box (left, right)) => {\n+                state.flood(target.as_ref(), self.map());\n+\n                 let target = self.map().find(target.as_ref());\n-                if let Some(target) = target {\n-                    // We should not track any projections other than\n-                    // what is overwritten below, but just in case...\n-                    state.flood_idx(target, self.map());\n-                }\n \n                 let value_target = target\n                     .and_then(|target| self.map().apply(target, TrackElem::Field(0_u32.into())));\n@@ -195,6 +243,9 @@ impl<'tcx> ValueAnalysis<'tcx> for ConstAnalysis<'tcx> {\n                 FlatSet::Bottom => ValueOrPlace::Value(FlatSet::Bottom),\n                 FlatSet::Top => ValueOrPlace::Value(FlatSet::Top),\n             },\n+            Rvalue::Discriminant(place) => {\n+                ValueOrPlace::Value(state.get_discr(place.as_ref(), self.map()))\n+            }\n             _ => self.super_rvalue(rvalue, state),\n         }\n     }\n@@ -268,12 +319,13 @@ impl<'tcx> std::fmt::Debug for ScalarTy<'tcx> {\n     }\n }\n \n-impl<'tcx> ConstAnalysis<'tcx> {\n-    pub fn new(tcx: TyCtxt<'tcx>, body: &Body<'tcx>, map: Map) -> Self {\n+impl<'a, 'tcx> ConstAnalysis<'a, 'tcx> {\n+    pub fn new(tcx: TyCtxt<'tcx>, body: &'a Body<'tcx>, map: Map) -> Self {\n         let param_env = tcx.param_env(body.source.def_id());\n         Self {\n             map,\n             tcx,\n+            local_decls: &body.local_decls,\n             ecx: InterpCx::new(tcx, DUMMY_SP, param_env, DummyMachine),\n             param_env: param_env,\n         }\n@@ -466,6 +518,21 @@ impl<'tcx, 'map, 'a> Visitor<'tcx> for OperandCollector<'tcx, 'map, 'a> {\n             _ => (),\n         }\n     }\n+\n+    fn visit_rvalue(&mut self, rvalue: &Rvalue<'tcx>, location: Location) {\n+        match rvalue {\n+            Rvalue::Discriminant(place) => {\n+                match self.state.get_discr(place.as_ref(), self.visitor.map) {\n+                    FlatSet::Top => (),\n+                    FlatSet::Elem(value) => {\n+                        self.visitor.before_effect.insert((location, *place), value);\n+                    }\n+                    FlatSet::Bottom => (),\n+                }\n+            }\n+            _ => self.super_rvalue(rvalue, location),\n+        }\n+    }\n }\n \n struct DummyMachine;"}, {"sha": "038e6c6bd900596a0ca54886a4f1c9e89c8c0133", "filename": "tests/mir-opt/dataflow-const-prop/enum.mutate_discriminant.DataflowConstProp.diff", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/9a6c04f5d0e6ec47bf150187cffcb7f737799db4/tests%2Fmir-opt%2Fdataflow-const-prop%2Fenum.mutate_discriminant.DataflowConstProp.diff", "raw_url": "https://github.com/rust-lang/rust/raw/9a6c04f5d0e6ec47bf150187cffcb7f737799db4/tests%2Fmir-opt%2Fdataflow-const-prop%2Fenum.mutate_discriminant.DataflowConstProp.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fdataflow-const-prop%2Fenum.mutate_discriminant.DataflowConstProp.diff?ref=9a6c04f5d0e6ec47bf150187cffcb7f737799db4", "patch": "@@ -0,0 +1,26 @@\n+- // MIR for `mutate_discriminant` before DataflowConstProp\n++ // MIR for `mutate_discriminant` after DataflowConstProp\n+  \n+  fn mutate_discriminant() -> u8 {\n+      let mut _0: u8;                      // return place in scope 0 at $DIR/enum.rs:+0:29: +0:31\n+      let mut _1: std::option::Option<NonZeroUsize>; // in scope 0 at $SRC_DIR/core/src/intrinsics/mir.rs:LL:COL\n+      let mut _2: isize;                   // in scope 0 at $SRC_DIR/core/src/intrinsics/mir.rs:LL:COL\n+  \n+      bb0: {\n+          discriminant(_1) = 1;            // scope 0 at $DIR/enum.rs:+4:13: +4:34\n+          (((_1 as variant#1).0: NonZeroUsize).0: usize) = const 0_usize; // scope 0 at $DIR/enum.rs:+6:13: +6:64\n+          _2 = discriminant(_1);           // scope 0 at $SRC_DIR/core/src/intrinsics/mir.rs:LL:COL\n+          switchInt(_2) -> [0: bb1, otherwise: bb2]; // scope 0 at $DIR/enum.rs:+9:13: +12:14\n+      }\n+  \n+      bb1: {\n+          _0 = const 1_u8;                 // scope 0 at $DIR/enum.rs:+15:13: +15:20\n+          return;                          // scope 0 at $DIR/enum.rs:+16:13: +16:21\n+      }\n+  \n+      bb2: {\n+          _0 = const 2_u8;                 // scope 0 at $DIR/enum.rs:+19:13: +19:20\n+          unreachable;                     // scope 0 at $DIR/enum.rs:+20:13: +20:26\n+      }\n+  }\n+  "}, {"sha": "7ea405bd9c408057f5cec1bdae6486d3f05ed16d", "filename": "tests/mir-opt/dataflow-const-prop/enum.rs", "status": "modified", "additions": 42, "deletions": 3, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/9a6c04f5d0e6ec47bf150187cffcb7f737799db4/tests%2Fmir-opt%2Fdataflow-const-prop%2Fenum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a6c04f5d0e6ec47bf150187cffcb7f737799db4/tests%2Fmir-opt%2Fdataflow-const-prop%2Fenum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fdataflow-const-prop%2Fenum.rs?ref=9a6c04f5d0e6ec47bf150187cffcb7f737799db4", "patch": "@@ -1,13 +1,52 @@\n // unit-test: DataflowConstProp\n \n-// Not trackable, because variants could be aliased.\n+#![feature(custom_mir, core_intrinsics, rustc_attrs)]\n+\n+use std::intrinsics::mir::*;\n+\n enum E {\n     V1(i32),\n     V2(i32)\n }\n \n-// EMIT_MIR enum.main.DataflowConstProp.diff\n-fn main() {\n+// EMIT_MIR enum.simple.DataflowConstProp.diff\n+fn simple() {\n     let e = E::V1(0);\n     let x = match e { E::V1(x) => x, E::V2(x) => x };\n }\n+\n+#[rustc_layout_scalar_valid_range_start(1)]\n+#[rustc_nonnull_optimization_guaranteed]\n+struct NonZeroUsize(usize);\n+\n+// EMIT_MIR enum.mutate_discriminant.DataflowConstProp.diff\n+#[custom_mir(dialect = \"runtime\", phase = \"post-cleanup\")]\n+fn mutate_discriminant() -> u8 {\n+    mir!(\n+        let x: Option<NonZeroUsize>;\n+        {\n+            SetDiscriminant(x, 1);\n+            // This assignment overwrites the niche in which the discriminant is stored.\n+            place!(Field(Field(Variant(x, 1), 0), 0)) = 0_usize;\n+            // So we cannot know the value of this discriminant.\n+            let a = Discriminant(x);\n+            match a {\n+                0 => bb1,\n+                _ => bad,\n+            }\n+        }\n+        bb1 = {\n+            RET = 1;\n+            Return()\n+        }\n+        bad = {\n+            RET = 2;\n+            Unreachable()\n+        }\n+    )\n+}\n+\n+fn main() {\n+    simple();\n+    mutate_discriminant();\n+}"}, {"sha": "1fb65e6584525dacb6507da722d147def7dc3dba", "filename": "tests/mir-opt/dataflow-const-prop/enum.simple.DataflowConstProp.diff", "status": "renamed", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/9a6c04f5d0e6ec47bf150187cffcb7f737799db4/tests%2Fmir-opt%2Fdataflow-const-prop%2Fenum.simple.DataflowConstProp.diff", "raw_url": "https://github.com/rust-lang/rust/raw/9a6c04f5d0e6ec47bf150187cffcb7f737799db4/tests%2Fmir-opt%2Fdataflow-const-prop%2Fenum.simple.DataflowConstProp.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fdataflow-const-prop%2Fenum.simple.DataflowConstProp.diff?ref=9a6c04f5d0e6ec47bf150187cffcb7f737799db4", "patch": "@@ -1,8 +1,8 @@\n-- // MIR for `main` before DataflowConstProp\n-+ // MIR for `main` after DataflowConstProp\n+- // MIR for `simple` before DataflowConstProp\n++ // MIR for `simple` after DataflowConstProp\n   \n-  fn main() -> () {\n-      let mut _0: ();                      // return place in scope 0 at $DIR/enum.rs:+0:11: +0:11\n+  fn simple() -> () {\n+      let mut _0: ();                      // return place in scope 0 at $DIR/enum.rs:+0:13: +0:13\n       let _1: E;                           // in scope 0 at $DIR/enum.rs:+1:9: +1:10\n       let mut _3: isize;                   // in scope 0 at $DIR/enum.rs:+2:23: +2:31\n       scope 1 {\n@@ -25,8 +25,10 @@\n           StorageLive(_1);                 // scope 0 at $DIR/enum.rs:+1:9: +1:10\n           _1 = E::V1(const 0_i32);         // scope 0 at $DIR/enum.rs:+1:13: +1:21\n           StorageLive(_2);                 // scope 1 at $DIR/enum.rs:+2:9: +2:10\n-          _3 = discriminant(_1);           // scope 1 at $DIR/enum.rs:+2:19: +2:20\n-          switchInt(move _3) -> [0: bb3, 1: bb1, otherwise: bb2]; // scope 1 at $DIR/enum.rs:+2:13: +2:20\n+-         _3 = discriminant(_1);           // scope 1 at $DIR/enum.rs:+2:19: +2:20\n+-         switchInt(move _3) -> [0: bb3, 1: bb1, otherwise: bb2]; // scope 1 at $DIR/enum.rs:+2:13: +2:20\n++         _3 = const 0_isize;              // scope 1 at $DIR/enum.rs:+2:19: +2:20\n++         switchInt(const 0_isize) -> [0: bb3, 1: bb1, otherwise: bb2]; // scope 1 at $DIR/enum.rs:+2:13: +2:20\n       }\n   \n       bb1: {\n@@ -50,7 +52,7 @@\n       }\n   \n       bb4: {\n-          _0 = const ();                   // scope 0 at $DIR/enum.rs:+0:11: +3:2\n+          _0 = const ();                   // scope 0 at $DIR/enum.rs:+0:13: +3:2\n           StorageDead(_2);                 // scope 1 at $DIR/enum.rs:+3:1: +3:2\n           StorageDead(_1);                 // scope 0 at $DIR/enum.rs:+3:1: +3:2\n           return;                          // scope 0 at $DIR/enum.rs:+3:2: +3:2", "previous_filename": "tests/mir-opt/dataflow-const-prop/enum.main.DataflowConstProp.diff"}]}