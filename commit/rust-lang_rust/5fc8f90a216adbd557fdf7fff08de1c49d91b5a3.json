{"sha": "5fc8f90a216adbd557fdf7fff08de1c49d91b5a3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVmYzhmOTBhMjE2YWRiZDU1N2ZkZjdmZmYwOGRlMWM0OWQ5MWI1YTM=", "commit": {"author": {"name": "Edwin Cheng", "email": "edwin0cheng@gmail.com", "date": "2020-04-10T11:06:53Z"}, "committer": {"name": "Edwin Cheng", "email": "edwin0cheng@gmail.com", "date": "2020-04-10T11:08:15Z"}, "message": "tidy up a bit", "tree": {"sha": "cab8b54d3d147d478fb325f08ece58b991833fa0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cab8b54d3d147d478fb325f08ece58b991833fa0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5fc8f90a216adbd557fdf7fff08de1c49d91b5a3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5fc8f90a216adbd557fdf7fff08de1c49d91b5a3", "html_url": "https://github.com/rust-lang/rust/commit/5fc8f90a216adbd557fdf7fff08de1c49d91b5a3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5fc8f90a216adbd557fdf7fff08de1c49d91b5a3/comments", "author": {"login": "edwin0cheng", "id": 11014119, "node_id": "MDQ6VXNlcjExMDE0MTE5", "avatar_url": "https://avatars.githubusercontent.com/u/11014119?v=4", "gravatar_id": "", "url": "https://api.github.com/users/edwin0cheng", "html_url": "https://github.com/edwin0cheng", "followers_url": "https://api.github.com/users/edwin0cheng/followers", "following_url": "https://api.github.com/users/edwin0cheng/following{/other_user}", "gists_url": "https://api.github.com/users/edwin0cheng/gists{/gist_id}", "starred_url": "https://api.github.com/users/edwin0cheng/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/edwin0cheng/subscriptions", "organizations_url": "https://api.github.com/users/edwin0cheng/orgs", "repos_url": "https://api.github.com/users/edwin0cheng/repos", "events_url": "https://api.github.com/users/edwin0cheng/events{/privacy}", "received_events_url": "https://api.github.com/users/edwin0cheng/received_events", "type": "User", "site_admin": false}, "committer": {"login": "edwin0cheng", "id": 11014119, "node_id": "MDQ6VXNlcjExMDE0MTE5", "avatar_url": "https://avatars.githubusercontent.com/u/11014119?v=4", "gravatar_id": "", "url": "https://api.github.com/users/edwin0cheng", "html_url": "https://github.com/edwin0cheng", "followers_url": "https://api.github.com/users/edwin0cheng/followers", "following_url": "https://api.github.com/users/edwin0cheng/following{/other_user}", "gists_url": "https://api.github.com/users/edwin0cheng/gists{/gist_id}", "starred_url": "https://api.github.com/users/edwin0cheng/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/edwin0cheng/subscriptions", "organizations_url": "https://api.github.com/users/edwin0cheng/orgs", "repos_url": "https://api.github.com/users/edwin0cheng/repos", "events_url": "https://api.github.com/users/edwin0cheng/events{/privacy}", "received_events_url": "https://api.github.com/users/edwin0cheng/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "857c03df079f919ddc0ea1c7c0a24313a66f2e2f", "url": "https://api.github.com/repos/rust-lang/rust/commits/857c03df079f919ddc0ea1c7c0a24313a66f2e2f", "html_url": "https://github.com/rust-lang/rust/commit/857c03df079f919ddc0ea1c7c0a24313a66f2e2f"}], "stats": {"total": 68, "additions": 18, "deletions": 50}, "files": [{"sha": "8403187b99daf53603992dc4ea51e2e45e949186", "filename": "crates/ra_proc_macro_srv/src/dylib.rs", "status": "modified", "additions": 18, "deletions": 50, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/5fc8f90a216adbd557fdf7fff08de1c49d91b5a3/crates%2Fra_proc_macro_srv%2Fsrc%2Fdylib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fc8f90a216adbd557fdf7fff08de1c49d91b5a3/crates%2Fra_proc_macro_srv%2Fsrc%2Fdylib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_proc_macro_srv%2Fsrc%2Fdylib.rs?ref=5fc8f90a216adbd557fdf7fff08de1c49d91b5a3", "patch": "@@ -1,54 +1,50 @@\n //! Handles dynamic library loading for proc macro\n \n use crate::{proc_macro::bridge, rustc_server::TokenStream};\n-use std::fs::File;\n-use std::io::Read;\n use std::path::Path;\n \n use goblin::{mach::Mach, Object};\n use libloading::Library;\n use ra_proc_macro::ProcMacroKind;\n \n-static NEW_REGISTRAR_SYMBOL: &str = \"__rustc_proc_macro_decls_\";\n-static _OLD_REGISTRAR_SYMBOL: &str = \"__rustc_derive_registrar_\";\n-\n-fn read_bytes(file: &Path) -> Option<Vec<u8>> {\n-    let mut fd = File::open(file).ok()?;\n-    let mut buffer = Vec::new();\n-    fd.read_to_end(&mut buffer).ok()?;\n-\n-    Some(buffer)\n-}\n+static NEW_REGISTRAR_SYMBOL: &str = \"_rustc_proc_macro_decls_\";\n \n fn get_symbols_from_lib(file: &Path) -> Option<Vec<String>> {\n-    let buffer = read_bytes(file)?;\n+    let buffer = std::fs::read(file).ok()?;\n     let object = Object::parse(&buffer).ok()?;\n \n     return match object {\n         Object::Elf(elf) => {\n             let symbols = elf.dynstrtab.to_vec().ok()?;\n             let names = symbols.iter().map(|s| s.to_string()).collect();\n-\n             Some(names)\n         }\n-\n         Object::PE(pe) => {\n             let symbol_names =\n                 pe.exports.iter().flat_map(|s| s.name).map(|n| n.to_string()).collect();\n             Some(symbol_names)\n         }\n-\n         Object::Mach(mach) => match mach {\n             Mach::Binary(binary) => {\n                 let exports = binary.exports().ok()?;\n-                let names = exports.iter().map(|s| s.name.clone()).collect();\n-\n+                let names = exports\n+                    .iter()\n+                    .map(|s| {\n+                        // In macos doc:\n+                        // https://developer.apple.com/library/archive/documentation/System/Conceptual/ManPages_iPhoneOS/man3/dlsym.3.html\n+                        // Unlike other dyld API's, the symbol name passed to dlsym() must NOT be\n+                        // prepended with an underscore.\n+                        if s.name.starts_with(\"_\") {\n+                            s.name[1..].to_string()\n+                        } else {\n+                            s.name.to_string()\n+                        }\n+                    })\n+                    .collect();\n                 Some(names)\n             }\n-\n             Mach::Fat(_) => None,\n         },\n-\n         Object::Archive(_) | Object::Unknown(_) => None,\n     };\n }\n@@ -57,28 +53,10 @@ fn is_derive_registrar_symbol(symbol: &str) -> bool {\n     symbol.contains(NEW_REGISTRAR_SYMBOL)\n }\n \n-#[cfg(not(target_os = \"macos\"))]\n-fn adjust_symbol_name(name: &str) -> String {\n-    name.to_string()\n-}\n-\n-#[cfg(target_os = \"macos\")]\n-fn adjust_symbol_name(s: &str) -> String {\n-    // In macos doc:\n-    // https://developer.apple.com/library/archive/documentation/System/Conceptual/ManPages_iPhoneOS/man3/dlsym.3.html\n-    // Unlike other dyld API's, the symbol name passed to dlsym() must NOT be\n-    // prepended with an underscore.\n-    if s.starts_with(\"_\") {\n-        s[1..s.len()].to_string()\n-    } else {\n-        s.to_string()\n-    }\n-}\n-\n fn find_registrar_symbol(file: &Path) -> Option<String> {\n     let symbols = get_symbols_from_lib(file)?;\n \n-    symbols.iter().find(|s| is_derive_registrar_symbol(s)).map(|s| adjust_symbol_name(&s))\n+    symbols.iter().find(|s| is_derive_registrar_symbol(s)).map(|s| s.clone())\n }\n \n /// Loads dynamic library in platform dependent manner.\n@@ -119,11 +97,9 @@ impl ProcMacroLibraryLibloading {\n             .ok_or(format!(\"Cannot find registrar symbol in file {:?}\", file))?;\n \n         let lib = load_library(file).map_err(|e| e.to_string())?;\n-\n         let exported_macros = {\n             let macros: libloading::Symbol<&&[bridge::client::ProcMacro]> =\n                 unsafe { lib.get(symbol_name.as_bytes()) }.map_err(|e| e.to_string())?;\n-\n             macros.to_vec()\n         };\n \n@@ -140,7 +116,6 @@ pub struct Expander {\n impl Expander {\n     pub fn new<P: AsRef<Path>>(lib: &P) -> Result<Expander, String> {\n         let mut libs = vec![];\n-\n         /* Some libraries for dynamic loading require canonicalized path (even when it is\n         already absolute\n         */\n@@ -177,20 +152,16 @@ impl Expander {\n                             crate::rustc_server::Rustc::default(),\n                             parsed_body,\n                         );\n-\n                         return res.map(|it| it.subtree);\n                     }\n-\n                     bridge::client::ProcMacro::Bang { name, client } if *name == macro_name => {\n                         let res = client.run(\n                             &crate::proc_macro::bridge::server::SameThread,\n                             crate::rustc_server::Rustc::default(),\n                             parsed_body,\n                         );\n-\n                         return res.map(|it| it.subtree);\n                     }\n-\n                     bridge::client::ProcMacro::Attr { name, client } if *name == macro_name => {\n                         let res = client.run(\n                             &crate::proc_macro::bridge::server::SameThread,\n@@ -201,10 +172,7 @@ impl Expander {\n \n                         return res.map(|it| it.subtree);\n                     }\n-\n-                    _ => {\n-                        continue;\n-                    }\n+                    _ => continue,\n                 }\n             }\n         }"}]}