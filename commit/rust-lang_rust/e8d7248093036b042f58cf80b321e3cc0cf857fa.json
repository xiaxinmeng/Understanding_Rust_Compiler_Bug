{"sha": "e8d7248093036b042f58cf80b321e3cc0cf857fa", "node_id": "C_kwDOAAsO6NoAKGU4ZDcyNDgwOTMwMzZiMDQyZjU4Y2Y4MGIzMjFlM2NjMGNmODU3ZmE", "commit": {"author": {"name": "Mark Rousskov", "email": "mark.simulacrum@gmail.com", "date": "2021-05-06T21:24:09Z"}, "committer": {"name": "Mark Rousskov", "email": "mark.simulacrum@gmail.com", "date": "2021-12-06T20:03:09Z"}, "message": "Implement the simple Lengauer-Tarjan algorithm\n\nThis replaces the previous implementation with the simple variant of\nLengauer-Tarjan, which performs better in the general case. Performance on the\nkeccak benchmark is about equivalent between the two, but we don't see\nregressions (and indeed see improvements) on other benchmarks, even on a\npartially optimized implementation.\n\nThe implementation here follows that of the pseudocode in \"Linear-Time\nAlgorithms for Dominators and Related Problems\" thesis by Loukas Georgiadis. The\nnext few commits will optimize the implementation as suggested in the thesis.\nSeveral related works are cited in the comments within the implementation, as\nwell.\n\nImplement the simple Lengauer-Tarjan algorithm\n\nThis replaces the previous implementation (from #34169), which has not been\noptimized since, with the simple variant of Lengauer-Tarjan which performs\nbetter in the general case. A previous attempt -- not kept in commit history --\nattempted a replacement with a bitset-based implementation, but this led to\nregressions on perf.rust-lang.org benchmarks and equivalent wins for the keccak\nbenchmark, so was rejected.\n\nThe implementation here follows that of the pseudocode in \"Linear-Time\nAlgorithms for Dominators and Related Problems\" thesis by Loukas Georgiadis. The\nnext few commits will optimize the implementation as suggested in the thesis.\nSeveral related works are cited in the comments within the implementation, as\nwell.\n\nOn the keccak benchmark, we were previously spending 15% of our cycles computing\nthe NCA / intersect function; this function is quite expensive, especially on\nmodern CPUs, as it chases pointers on every iteration in a tight loop. With this\ncommit, we spend ~0.05% of our time in dominator computation.", "tree": {"sha": "5dc74b7adfeddcd46682b66c517a2d44c5b8f2b2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5dc74b7adfeddcd46682b66c517a2d44c5b8f2b2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e8d7248093036b042f58cf80b321e3cc0cf857fa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e8d7248093036b042f58cf80b321e3cc0cf857fa", "html_url": "https://github.com/rust-lang/rust/commit/e8d7248093036b042f58cf80b321e3cc0cf857fa", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e8d7248093036b042f58cf80b321e3cc0cf857fa/comments", "author": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0fb1c371d4a14f9ce7a721d8aea683a6e6774f6c", "url": "https://api.github.com/repos/rust-lang/rust/commits/0fb1c371d4a14f9ce7a721d8aea683a6e6774f6c", "html_url": "https://github.com/rust-lang/rust/commit/0fb1c371d4a14f9ce7a721d8aea683a6e6774f6c"}], "stats": {"total": 155, "additions": 116, "deletions": 39}, "files": [{"sha": "b1f62636b8977b834d28e543ae4ad2a8f4e4add4", "filename": "compiler/rustc_data_structures/src/graph/dominators/mod.rs", "status": "modified", "additions": 105, "deletions": 39, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/e8d7248093036b042f58cf80b321e3cc0cf857fa/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fdominators%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8d7248093036b042f58cf80b321e3cc0cf857fa/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fdominators%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fdominators%2Fmod.rs?ref=e8d7248093036b042f58cf80b321e3cc0cf857fa", "patch": "@@ -1,9 +1,8 @@\n //! Finding the dominators in a control-flow graph.\n //!\n-//! Algorithm based on Keith D. Cooper, Timothy J. Harvey, and Ken Kennedy,\n-//! \"A Simple, Fast Dominance Algorithm\",\n-//! Rice Computer Science TS-06-33870,\n-//! <https://www.cs.rice.edu/~keith/EMBED/dom.pdf>.\n+//! Algorithm based on Loukas Georgiadis,\n+//! \"Linear-Time Algorithms for Dominators and Related Problems\",\n+//! ftp://ftp.cs.princeton.edu/techreports/2005/737.pdf\n \n use super::iterate::reverse_post_order;\n use super::ControlFlowGraph;\n@@ -19,6 +18,11 @@ pub fn dominators<G: ControlFlowGraph>(graph: G) -> Dominators<G::Node> {\n     dominators_given_rpo(graph, &rpo)\n }\n \n+struct PreOrderFrame<Node, Iter> {\n+    node: Node,\n+    iter: Iter,\n+}\n+\n fn dominators_given_rpo<G: ControlFlowGraph>(graph: G, rpo: &[G::Node]) -> Dominators<G::Node> {\n     let start_node = graph.start_node();\n     assert_eq!(rpo[0], start_node);\n@@ -29,53 +33,115 @@ fn dominators_given_rpo<G: ControlFlowGraph>(graph: G, rpo: &[G::Node]) -> Domin\n         post_order_rank[node] = index;\n     }\n \n-    let mut immediate_dominators = IndexVec::from_elem_n(None, graph.num_nodes());\n-    immediate_dominators[start_node] = Some(start_node);\n-\n-    let mut changed = true;\n-    while changed {\n-        changed = false;\n-\n-        for &node in &rpo[1..] {\n-            let mut new_idom = None;\n-            for pred in graph.predecessors(node) {\n-                if immediate_dominators[pred].is_some() {\n-                    // (*) dominators for `pred` have been calculated\n-                    new_idom = Some(if let Some(new_idom) = new_idom {\n-                        intersect(&post_order_rank, &immediate_dominators, new_idom, pred)\n-                    } else {\n-                        pred\n-                    });\n-                }\n+    let mut visited = BitSet::new_empty(graph.num_nodes());\n+    let mut parent: IndexVec<G::Node, Option<G::Node>> =\n+        IndexVec::from_elem_n(None, graph.num_nodes());\n+    let mut pre_order_index: IndexVec<G::Node, Option<usize>> =\n+        IndexVec::from_elem_n(None, graph.num_nodes());\n+    let mut pre_order_nodes = Vec::with_capacity(rpo.len());\n+\n+    let mut stack = vec![PreOrderFrame {\n+        node: graph.start_node(),\n+        iter: graph.successors(graph.start_node()),\n+    }];\n+    visited.insert(graph.start_node());\n+    let mut idx = 0;\n+    pre_order_index[graph.start_node()] = Some(0);\n+    idx += 1;\n+    pre_order_nodes.push(graph.start_node());\n+\n+    'recurse: while let Some(frame) = stack.last_mut() {\n+        while let Some(successor) = frame.iter.next() {\n+            if visited.insert(successor) {\n+                parent[successor] = Some(frame.node);\n+                pre_order_index[successor] = Some(idx);\n+                pre_order_nodes.push(successor);\n+                idx += 1;\n+\n+                stack.push(PreOrderFrame { node: successor, iter: graph.successors(successor) });\n+                continue 'recurse;\n             }\n+        }\n+        stack.pop();\n+    }\n \n-            if new_idom != immediate_dominators[node] {\n-                immediate_dominators[node] = new_idom;\n-                changed = true;\n-            }\n+    let mut ancestor = IndexVec::from_elem_n(None, graph.num_nodes());\n+    let mut idom = IndexVec::from_elem_n(graph.start_node(), graph.num_nodes());\n+    let mut semi = IndexVec::from_fn_n(std::convert::identity, graph.num_nodes());\n+    let mut label = semi.clone();\n+    let mut bucket = IndexVec::from_elem_n(vec![], graph.num_nodes());\n+\n+    for &w in pre_order_nodes[1..].iter().rev() {\n+        semi[w] = w;\n+        for v in graph.predecessors(w) {\n+            let x = eval(&pre_order_index, &mut ancestor, &semi, &mut label, v);\n+            semi[w] = if pre_order_index[semi[w]].unwrap() < pre_order_index[semi[x]].unwrap() {\n+                semi[w]\n+            } else {\n+                semi[x]\n+            };\n+        }\n+        // semi[w] is now semidominator(w).\n+\n+        bucket[semi[w]].push(w);\n+\n+        link(&mut ancestor, &parent, w);\n+        let z = parent[w].unwrap();\n+        for v in std::mem::take(&mut bucket[z]) {\n+            let y = eval(&pre_order_index, &mut ancestor, &semi, &mut label, v);\n+            idom[v] = if pre_order_index[semi[y]] < pre_order_index[z] { y } else { z };\n+        }\n+    }\n+    for &w in pre_order_nodes.iter().skip(1) {\n+        if idom[w] != semi[w] {\n+            idom[w] = idom[idom[w]];\n+        }\n+    }\n+\n+    let mut immediate_dominators = IndexVec::from_elem_n(None, graph.num_nodes());\n+    for (node, idom_slot) in immediate_dominators.iter_enumerated_mut() {\n+        if pre_order_index[node].is_some() {\n+            *idom_slot = Some(idom[node]);\n         }\n     }\n \n     Dominators { post_order_rank, immediate_dominators }\n }\n \n-fn intersect<Node: Idx>(\n-    post_order_rank: &IndexVec<Node, usize>,\n-    immediate_dominators: &IndexVec<Node, Option<Node>>,\n-    mut node1: Node,\n-    mut node2: Node,\n-) -> Node {\n-    while node1 != node2 {\n-        while post_order_rank[node1] < post_order_rank[node2] {\n-            node1 = immediate_dominators[node1].unwrap();\n-        }\n+fn eval<N: Idx>(\n+    pre_order_index: &IndexVec<N, Option<usize>>,\n+    ancestor: &mut IndexVec<N, Option<N>>,\n+    semi: &IndexVec<N, N>,\n+    label: &mut IndexVec<N, N>,\n+    node: N,\n+) -> N {\n+    if ancestor[node].is_some() {\n+        compress(pre_order_index, ancestor, semi, label, node);\n+        label[node]\n+    } else {\n+        node\n+    }\n+}\n \n-        while post_order_rank[node2] < post_order_rank[node1] {\n-            node2 = immediate_dominators[node2].unwrap();\n+fn compress<N: Idx>(\n+    pre_order_index: &IndexVec<N, Option<usize>>,\n+    ancestor: &mut IndexVec<N, Option<N>>,\n+    semi: &IndexVec<N, N>,\n+    label: &mut IndexVec<N, N>,\n+    v: N,\n+) {\n+    let u = ancestor[v].unwrap();\n+    if ancestor[u].is_some() {\n+        compress(pre_order_index, ancestor, semi, label, u);\n+        if pre_order_index[semi[label[u]]] < pre_order_index[semi[label[v]]] {\n+            label[v] = label[u];\n         }\n+        ancestor[v] = ancestor[u];\n     }\n+}\n \n-    node1\n+fn link<N: Idx>(ancestor: &mut IndexVec<N, Option<N>>, parent: &IndexVec<N, Option<N>>, w: N) {\n+    ancestor[w] = Some(parent[w].unwrap());\n }\n \n #[derive(Clone, Debug)]"}, {"sha": "ff31d8f7fdcf6d5148c01a219464e6a0bb4fe22d", "filename": "compiler/rustc_data_structures/src/graph/dominators/tests.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e8d7248093036b042f58cf80b321e3cc0cf857fa/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fdominators%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8d7248093036b042f58cf80b321e3cc0cf857fa/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fdominators%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fdominators%2Ftests.rs?ref=e8d7248093036b042f58cf80b321e3cc0cf857fa", "patch": "@@ -32,3 +32,14 @@ fn paper() {\n     assert_eq!(immediate_dominators[5], Some(6));\n     assert_eq!(immediate_dominators[6], Some(6));\n }\n+\n+#[test]\n+fn paper_slt() {\n+    // example from the paper:\n+    let graph = TestGraph::new(\n+        1,\n+        &[(1, 2), (1, 3), (2, 3), (2, 7), (3, 4), (3, 6), (4, 5), (5, 4), (6, 7), (7, 8), (8, 5)],\n+    );\n+\n+    dominators(&graph);\n+}"}]}