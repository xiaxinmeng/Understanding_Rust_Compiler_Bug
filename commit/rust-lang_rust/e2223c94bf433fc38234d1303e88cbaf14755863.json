{"sha": "e2223c94bf433fc38234d1303e88cbaf14755863", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUyMjIzYzk0YmY0MzNmYzM4MjM0ZDEzMDNlODhjYmFmMTQ3NTU4NjM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-02-28T09:32:34Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-02-28T09:32:34Z"}, "message": "Auto merge of #68827 - ssomers:btree_navigation_revisited, r=Mark-Simulacrum\n\nBTreeMap navigation done safer & faster\n\nIt turns out that there was a faster way to do the tree navigation code bundled in #67073, by moving from edge to KV and from KV to next edge separately. It extracts most of the code as safe functions, and contains the duplication of handles within the short wrapper functions.\n\nThis somehow hits a sweet spot in the compiler because it reports boosts all over the board:\n```\n>cargo benchcmp pre3.txt posz4.txt --threshold 5\n name                                           pre3.txt ns/iter  posz4.txt ns/iter  diff ns/iter   diff %  speedup\n btree::map::first_and_last_0                   40                37                           -3   -7.50%   x 1.08\n btree::map::first_and_last_100                 58                44                          -14  -24.14%   x 1.32\n btree::map::iter_1000                          8,920             3,419                    -5,501  -61.67%   x 2.61\n btree::map::iter_100000                        1,069,290         411,615                -657,675  -61.51%   x 2.60\n btree::map::iter_20                            169               58                         -111  -65.68%   x 2.91\n btree::map::iter_mut_1000                      8,701             3,303                    -5,398  -62.04%   x 2.63\n btree::map::iter_mut_100000                    1,034,560         405,975                -628,585  -60.76%   x 2.55\n btree::map::iter_mut_20                        165               58                         -107  -64.85%   x 2.84\n btree::set::clone_100                          1,831             1,562                      -269  -14.69%   x 1.17\n btree::set::clone_100_and_clear                1,831             1,565                      -266  -14.53%   x 1.17\n btree::set::clone_100_and_into_iter            1,917             1,541                      -376  -19.61%   x 1.24\n btree::set::clone_100_and_pop_all              2,609             2,441                      -168   -6.44%   x 1.07\n btree::set::clone_100_and_remove_all           4,598             3,927                      -671  -14.59%   x 1.17\n btree::set::clone_100_and_remove_half          2,765             2,551                      -214   -7.74%   x 1.08\n btree::set::clone_10k                          191,610           164,616                 -26,994  -14.09%   x 1.16\n btree::set::clone_10k_and_clear                192,003           164,616                 -27,387  -14.26%   x 1.17\n btree::set::clone_10k_and_into_iter            200,037           163,010                 -37,027  -18.51%   x 1.23\n btree::set::clone_10k_and_pop_all              267,023           250,913                 -16,110   -6.03%   x 1.06\n btree::set::clone_10k_and_remove_all           536,230           464,100                 -72,130  -13.45%   x 1.16\n btree::set::clone_10k_and_remove_half          453,350           430,545                 -22,805   -5.03%   x 1.05\n btree::set::difference_random_100_vs_100       1,787             801                        -986  -55.18%   x 2.23\n btree::set::difference_random_100_vs_10k       2,978             2,696                      -282   -9.47%   x 1.10\n btree::set::difference_random_10k_vs_100       111,075           54,734                  -56,341  -50.72%   x 2.03\n btree::set::difference_random_10k_vs_10k       246,380           175,980                 -70,400  -28.57%   x 1.40\n btree::set::difference_staggered_100_vs_100    1,789             951                        -838  -46.84%   x 1.88\n btree::set::difference_staggered_100_vs_10k    2,798             2,606                      -192   -6.86%   x 1.07\n btree::set::difference_staggered_10k_vs_10k    176,452           97,401                  -79,051  -44.80%   x 1.81\n btree::set::intersection_100_neg_vs_10k_pos    34                32                           -2   -5.88%   x 1.06\n btree::set::intersection_100_pos_vs_100_neg    30                27                           -3  -10.00%   x 1.11\n btree::set::intersection_random_100_vs_100     1,537             613                        -924  -60.12%   x 2.51\n btree::set::intersection_random_100_vs_10k     2,793             2,649                      -144   -5.16%   x 1.05\n btree::set::intersection_random_10k_vs_10k     222,127           147,166                 -74,961  -33.75%   x 1.51\n btree::set::intersection_staggered_100_vs_100  1,447             622                        -825  -57.01%   x 2.33\n btree::set::intersection_staggered_100_vs_10k  2,606             2,382                      -224   -8.60%   x 1.09\n btree::set::intersection_staggered_10k_vs_10k  143,620           58,790                  -84,830  -59.07%   x 2.44\n btree::set::is_subset_100_vs_100               1,349             488                        -861  -63.83%   x 2.76\n btree::set::is_subset_100_vs_10k               1,720             1,428                      -292  -16.98%   x 1.20\n btree::set::is_subset_10k_vs_10k               135,984           48,527                  -87,457  -64.31%   x 2.80\n```\nThe `first_and_last` ones are noise (they don't do iteration), the others seem genuine.\nAs always, approved by Miri.\n\nAlso, a separate commit with some more benchmarks of mutable behaviour (which also benefit).\n\nr? @cuviper", "tree": {"sha": "7519f5483820ae89b8f48581dfeca25c5c81e55c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7519f5483820ae89b8f48581dfeca25c5c81e55c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e2223c94bf433fc38234d1303e88cbaf14755863", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e2223c94bf433fc38234d1303e88cbaf14755863", "html_url": "https://github.com/rust-lang/rust/commit/e2223c94bf433fc38234d1303e88cbaf14755863", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e2223c94bf433fc38234d1303e88cbaf14755863/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bfc32dd106f0fe191b8bcd9b76348a8875c30a60", "url": "https://api.github.com/repos/rust-lang/rust/commits/bfc32dd106f0fe191b8bcd9b76348a8875c30a60", "html_url": "https://github.com/rust-lang/rust/commit/bfc32dd106f0fe191b8bcd9b76348a8875c30a60"}, {"sha": "9f7b58f3c94708f344237f826b4f96a659b5fc82", "url": "https://api.github.com/repos/rust-lang/rust/commits/9f7b58f3c94708f344237f826b4f96a659b5fc82", "html_url": "https://github.com/rust-lang/rust/commit/9f7b58f3c94708f344237f826b4f96a659b5fc82"}], "stats": {"total": 399, "additions": 233, "deletions": 166}, "files": [{"sha": "d9e75ab7fa4ef6cefd68e85afea59bae35e149ad", "filename": "src/liballoc/benches/btree/set.rs", "status": "modified", "additions": 85, "deletions": 16, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/e2223c94bf433fc38234d1303e88cbaf14755863/src%2Fliballoc%2Fbenches%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2223c94bf433fc38234d1303e88cbaf14755863/src%2Fliballoc%2Fbenches%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fbenches%2Fbtree%2Fset.rs?ref=e2223c94bf433fc38234d1303e88cbaf14755863", "patch": "@@ -50,43 +50,112 @@ macro_rules! set_bench {\n     };\n }\n \n-const BUILD_SET_SIZE: usize = 100;\n+#[bench]\n+pub fn clone_100(b: &mut Bencher) {\n+    let src = pos(100);\n+    b.iter(|| src.clone())\n+}\n \n #[bench]\n-pub fn build_and_clear(b: &mut Bencher) {\n-    b.iter(|| pos(BUILD_SET_SIZE).clear())\n+pub fn clone_100_and_clear(b: &mut Bencher) {\n+    let src = pos(100);\n+    b.iter(|| src.clone().clear())\n }\n \n #[bench]\n-pub fn build_and_drop(b: &mut Bencher) {\n-    b.iter(|| pos(BUILD_SET_SIZE))\n+pub fn clone_100_and_into_iter(b: &mut Bencher) {\n+    let src = pos(100);\n+    b.iter(|| src.clone().into_iter().count())\n }\n \n #[bench]\n-pub fn build_and_into_iter(b: &mut Bencher) {\n-    b.iter(|| pos(BUILD_SET_SIZE).into_iter().count())\n+pub fn clone_100_and_pop_all(b: &mut Bencher) {\n+    let src = pos(100);\n+    b.iter(|| {\n+        let mut set = src.clone();\n+        while set.pop_first().is_some() {}\n+        set\n+    });\n }\n \n #[bench]\n-pub fn build_and_pop_all(b: &mut Bencher) {\n+pub fn clone_100_and_remove_all(b: &mut Bencher) {\n+    let src = pos(100);\n     b.iter(|| {\n-        let mut s = pos(BUILD_SET_SIZE);\n-        while s.pop_first().is_some() {}\n-        s\n+        let mut set = src.clone();\n+        while let Some(elt) = set.iter().copied().next() {\n+            set.remove(&elt);\n+        }\n+        set\n     });\n }\n \n #[bench]\n-pub fn build_and_remove_all(b: &mut Bencher) {\n+pub fn clone_100_and_remove_half(b: &mut Bencher) {\n+    let src = pos(100);\n     b.iter(|| {\n-        let mut s = pos(BUILD_SET_SIZE);\n-        while let Some(elt) = s.iter().copied().next() {\n-            s.remove(&elt);\n+        let mut set = src.clone();\n+        for i in (2..=100 as i32).step_by(2) {\n+            set.remove(&i);\n         }\n-        s\n+        assert_eq!(set.len(), 100 / 2);\n+        set\n+    })\n+}\n+\n+#[bench]\n+pub fn clone_10k(b: &mut Bencher) {\n+    let src = pos(10_000);\n+    b.iter(|| src.clone())\n+}\n+\n+#[bench]\n+pub fn clone_10k_and_clear(b: &mut Bencher) {\n+    let src = pos(10_000);\n+    b.iter(|| src.clone().clear())\n+}\n+\n+#[bench]\n+pub fn clone_10k_and_into_iter(b: &mut Bencher) {\n+    let src = pos(10_000);\n+    b.iter(|| src.clone().into_iter().count())\n+}\n+\n+#[bench]\n+pub fn clone_10k_and_pop_all(b: &mut Bencher) {\n+    let src = pos(10_000);\n+    b.iter(|| {\n+        let mut set = src.clone();\n+        while set.pop_first().is_some() {}\n+        set\n+    });\n+}\n+\n+#[bench]\n+pub fn clone_10k_and_remove_all(b: &mut Bencher) {\n+    let src = pos(10_000);\n+    b.iter(|| {\n+        let mut set = src.clone();\n+        while let Some(elt) = set.iter().copied().next() {\n+            set.remove(&elt);\n+        }\n+        set\n     });\n }\n \n+#[bench]\n+pub fn clone_10k_and_remove_half(b: &mut Bencher) {\n+    let src = pos(10_000);\n+    b.iter(|| {\n+        let mut set = src.clone();\n+        for i in (2..=10_000 as i32).step_by(2) {\n+            set.remove(&i);\n+        }\n+        assert_eq!(set.len(), 10_000 / 2);\n+        set\n+    })\n+}\n+\n set_bench! {intersection_100_neg_vs_100_pos, intersection, count, [neg(100), pos(100)]}\n set_bench! {intersection_100_neg_vs_10k_pos, intersection, count, [neg(100), pos(10_000)]}\n set_bench! {intersection_100_pos_vs_100_neg, intersection, count, [pos(100), neg(100)]}"}, {"sha": "8b9ffdfb49b4676cce2b7edb907445c22a37679c", "filename": "src/liballoc/collections/btree/map.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e2223c94bf433fc38234d1303e88cbaf14755863/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2223c94bf433fc38234d1303e88cbaf14755863/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs?ref=e2223c94bf433fc38234d1303e88cbaf14755863", "patch": "@@ -1487,16 +1487,13 @@ impl<K, V> Drop for IntoIter<K, V> {\n         }\n \n         unsafe {\n-            let leaf_node = ptr::read(&self.front).into_node();\n-            if leaf_node.is_shared_root() {\n+            let mut node = ptr::read(&self.front).into_node().forget_type();\n+            if node.is_shared_root() {\n                 return;\n             }\n \n-            if let Some(first_parent) = leaf_node.deallocate_and_ascend() {\n-                let mut cur_internal_node = first_parent.into_node();\n-                while let Some(parent) = cur_internal_node.deallocate_and_ascend() {\n-                    cur_internal_node = parent.into_node()\n-                }\n+            while let Some(parent) = node.deallocate_and_ascend() {\n+                node = parent.into_node().forget_type();\n             }\n         }\n     }"}, {"sha": "5e8dcf247ae5996af8fde8a55ceea5d5bcb464e1", "filename": "src/liballoc/collections/btree/navigate.rs", "status": "modified", "additions": 122, "deletions": 123, "changes": 245, "blob_url": "https://github.com/rust-lang/rust/blob/e2223c94bf433fc38234d1303e88cbaf14755863/src%2Fliballoc%2Fcollections%2Fbtree%2Fnavigate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2223c94bf433fc38234d1303e88cbaf14755863/src%2Fliballoc%2Fcollections%2Fbtree%2Fnavigate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fnavigate.rs?ref=e2223c94bf433fc38234d1303e88cbaf14755863", "patch": "@@ -3,151 +3,112 @@ use core::ptr;\n use super::node::{marker, ForceResult::*, Handle, NodeRef};\n use super::unwrap_unchecked;\n \n-macro_rules! def_next {\n-    { unsafe fn $name:ident : $next_kv:ident $next_edge:ident $initial_leaf_edge:ident } => {\n-        /// Given a leaf edge handle into an immutable tree, returns a handle to the next\n-        /// leaf edge and references to the key and value between these edges.\n-        /// Unsafe because the caller must ensure that the given leaf edge has a successor.\n-        unsafe fn $name <'a, K: 'a, V: 'a>(\n-            leaf_edge: Handle<NodeRef<marker::Immut<'a>, K, V, marker::Leaf>, marker::Edge>,\n-        ) -> (Handle<NodeRef<marker::Immut<'a>, K, V, marker::Leaf>, marker::Edge>, &'a K, &'a V) {\n-            let mut cur_handle = match leaf_edge.$next_kv() {\n-                Ok(leaf_kv) => {\n-                    let (k, v) = leaf_kv.into_kv();\n-                    let next_leaf_edge = leaf_kv.$next_edge();\n-                    return (next_leaf_edge, k, v);\n-                }\n-                Err(last_edge) => {\n-                    let next_level = last_edge.into_node().ascend().ok();\n-                    unwrap_unchecked(next_level)\n-                }\n-            };\n-\n-            loop {\n-                cur_handle = match cur_handle.$next_kv() {\n-                    Ok(internal_kv) => {\n-                        let (k, v) = internal_kv.into_kv();\n-                        let next_internal_edge = internal_kv.$next_edge();\n-                        let next_leaf_edge = next_internal_edge.descend().$initial_leaf_edge();\n-                        return (next_leaf_edge, k, v);\n-                    }\n-                    Err(last_edge) => {\n-                        let next_level = last_edge.into_node().ascend().ok();\n-                        unwrap_unchecked(next_level)\n-                    }\n-                }\n+impl<BorrowType, K, V> Handle<NodeRef<BorrowType, K, V, marker::Leaf>, marker::Edge> {\n+    /// Given a leaf edge handle, returns [`Result::Ok`] with a handle to the neighboring KV\n+    /// on the right side, which is either in the same leaf node or in an ancestor node.\n+    /// If the leaf edge is the last one in the tree, returns [`Result::Err`] with the root node.\n+    pub fn next_kv(\n+        self,\n+    ) -> Result<\n+        Handle<NodeRef<BorrowType, K, V, marker::LeafOrInternal>, marker::KV>,\n+        NodeRef<BorrowType, K, V, marker::LeafOrInternal>,\n+    > {\n+        let mut edge = self.forget_node_type();\n+        loop {\n+            edge = match edge.right_kv() {\n+                Ok(internal_kv) => return Ok(internal_kv),\n+                Err(last_edge) => match last_edge.into_node().ascend() {\n+                    Ok(parent_edge) => parent_edge.forget_node_type(),\n+                    Err(root) => return Err(root.forget_type()),\n+                },\n             }\n         }\n-    };\n-}\n-\n-macro_rules! def_next_mut {\n-    { unsafe fn $name:ident : $next_kv:ident $next_edge:ident $initial_leaf_edge:ident } => {\n-        /// Given a leaf edge handle into a mutable tree, returns handles to the next\n-        /// leaf edge and to the KV between these edges.\n-        /// Unsafe for two reasons:\n-        /// - the caller must ensure that the given leaf edge has a successor;\n-        /// - both returned handles represent mutable references into the same tree\n-        ///   that can easily invalidate each other, even on immutable use.\n-        unsafe fn $name <'a, K: 'a, V: 'a>(\n-            leaf_edge: Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge>,\n-        ) -> (Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge>,\n-              Handle<NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal>, marker::KV>) {\n-            let mut cur_handle = match leaf_edge.$next_kv() {\n-                Ok(leaf_kv) => {\n-                    let next_leaf_edge = ptr::read(&leaf_kv).$next_edge();\n-                    return (next_leaf_edge, leaf_kv.forget_node_type());\n-                }\n-                Err(last_edge) => {\n-                    let next_level = last_edge.into_node().ascend().ok();\n-                    unwrap_unchecked(next_level)\n-                }\n-            };\n+    }\n \n-            loop {\n-                cur_handle = match cur_handle.$next_kv() {\n-                    Ok(internal_kv) => {\n-                        let next_internal_edge = ptr::read(&internal_kv).$next_edge();\n-                        let next_leaf_edge = next_internal_edge.descend().$initial_leaf_edge();\n-                        return (next_leaf_edge, internal_kv.forget_node_type());\n-                    }\n-                    Err(last_edge) => {\n-                        let next_level = last_edge.into_node().ascend().ok();\n-                        unwrap_unchecked(next_level)\n-                    }\n-                }\n+    /// Given a leaf edge handle, returns [`Result::Ok`] with a handle to the neighboring KV\n+    /// on the left side, which is either in the same leaf node or in an ancestor node.\n+    /// If the leaf edge is the first one in the tree, returns [`Result::Err`] with the root node.\n+    pub fn next_back_kv(\n+        self,\n+    ) -> Result<\n+        Handle<NodeRef<BorrowType, K, V, marker::LeafOrInternal>, marker::KV>,\n+        NodeRef<BorrowType, K, V, marker::LeafOrInternal>,\n+    > {\n+        let mut edge = self.forget_node_type();\n+        loop {\n+            edge = match edge.left_kv() {\n+                Ok(internal_kv) => return Ok(internal_kv),\n+                Err(last_edge) => match last_edge.into_node().ascend() {\n+                    Ok(parent_edge) => parent_edge.forget_node_type(),\n+                    Err(root) => return Err(root.forget_type()),\n+                },\n             }\n         }\n-    };\n+    }\n }\n \n-macro_rules! def_next_dealloc {\n-    { unsafe fn $name:ident : $next_kv:ident $next_edge:ident $initial_leaf_edge:ident } => {\n-        /// Given a leaf edge handle into an owned tree, returns a handle to the next\n-        /// leaf edge and the key and value between these edges, while deallocating\n-        /// any node left behind.\n+macro_rules! def_next_kv_uncheched_dealloc {\n+    { unsafe fn $name:ident : $adjacent_kv:ident } => {\n+        /// Given a leaf edge handle into an owned tree, returns a handle to the next KV,\n+        /// while deallocating any node left behind.\n         /// Unsafe for two reasons:\n-        /// - the caller must ensure that the given leaf edge has a successor;\n-        /// - the node pointed at by the given handle, and its ancestors, may be deallocated,\n+        /// - The caller must ensure that the leaf edge is not the last one in the tree.\n+        /// - The node pointed at by the given handle, and its ancestors, may be deallocated,\n         ///   while the reference to those nodes in the surviving ancestors is left dangling;\n-        ///   thus using the returned handle is dangerous.\n+        ///   thus using the returned handle to navigate further is dangerous.\n         unsafe fn $name <K, V>(\n             leaf_edge: Handle<NodeRef<marker::Owned, K, V, marker::Leaf>, marker::Edge>,\n-        ) -> (Handle<NodeRef<marker::Owned, K, V, marker::Leaf>, marker::Edge>, K, V) {\n-            let mut cur_handle = match leaf_edge.$next_kv() {\n-                Ok(leaf_kv) => {\n-                    let k = ptr::read(leaf_kv.reborrow().into_kv().0);\n-                    let v = ptr::read(leaf_kv.reborrow().into_kv().1);\n-                    let next_leaf_edge = leaf_kv.$next_edge();\n-                    return (next_leaf_edge, k, v);\n-                }\n-                Err(last_edge) => {\n-                    unwrap_unchecked(last_edge.into_node().deallocate_and_ascend())\n-                }\n-            };\n-\n+        ) -> Handle<NodeRef<marker::Owned, K, V, marker::LeafOrInternal>, marker::KV> {\n+            let mut edge = leaf_edge.forget_node_type();\n             loop {\n-                cur_handle = match cur_handle.$next_kv() {\n-                    Ok(internal_kv) => {\n-                        let k = ptr::read(internal_kv.reborrow().into_kv().0);\n-                        let v = ptr::read(internal_kv.reborrow().into_kv().1);\n-                        let next_internal_edge = internal_kv.$next_edge();\n-                        let next_leaf_edge = next_internal_edge.descend().$initial_leaf_edge();\n-                        return (next_leaf_edge, k, v);\n-                    }\n+                edge = match edge.$adjacent_kv() {\n+                    Ok(internal_kv) => return internal_kv,\n                     Err(last_edge) => {\n-                        unwrap_unchecked(last_edge.into_node().deallocate_and_ascend())\n+                        let parent_edge = last_edge.into_node().deallocate_and_ascend();\n+                        unwrap_unchecked(parent_edge).forget_node_type()\n                     }\n                 }\n             }\n         }\n     };\n }\n \n-def_next! {unsafe fn next_unchecked: right_kv right_edge first_leaf_edge}\n-def_next! {unsafe fn next_back_unchecked: left_kv left_edge last_leaf_edge}\n-def_next_mut! {unsafe fn next_unchecked_mut: right_kv right_edge first_leaf_edge}\n-def_next_mut! {unsafe fn next_back_unchecked_mut: left_kv left_edge last_leaf_edge}\n-def_next_dealloc! {unsafe fn next_unchecked_deallocating: right_kv right_edge first_leaf_edge}\n-def_next_dealloc! {unsafe fn next_back_unchecked_deallocating: left_kv left_edge last_leaf_edge}\n+def_next_kv_uncheched_dealloc! {unsafe fn next_kv_unchecked_dealloc: right_kv}\n+def_next_kv_uncheched_dealloc! {unsafe fn next_back_kv_unchecked_dealloc: left_kv}\n+\n+/// This replaces the value behind the `v` unique reference by calling the\n+/// relevant function.\n+///\n+/// Safety: The change closure must not panic.\n+#[inline]\n+unsafe fn replace<T, R>(v: &mut T, change: impl FnOnce(T) -> (T, R)) -> R {\n+    let value = ptr::read(v);\n+    let (new_value, ret) = change(value);\n+    ptr::write(v, new_value);\n+    ret\n+}\n \n impl<'a, K, V> Handle<NodeRef<marker::Immut<'a>, K, V, marker::Leaf>, marker::Edge> {\n     /// Moves the leaf edge handle to the next leaf edge and returns references to the\n     /// key and value in between.\n     /// Unsafe because the caller must ensure that the leaf edge is not the last one in the tree.\n     pub unsafe fn next_unchecked(&mut self) -> (&'a K, &'a V) {\n-        let (next_edge, k, v) = next_unchecked(*self);\n-        *self = next_edge;\n-        (k, v)\n+        replace(self, |leaf_edge| {\n+            let kv = leaf_edge.next_kv();\n+            let kv = unwrap_unchecked(kv.ok());\n+            (kv.next_leaf_edge(), kv.into_kv())\n+        })\n     }\n \n     /// Moves the leaf edge handle to the previous leaf edge and returns references to the\n     /// key and value in between.\n     /// Unsafe because the caller must ensure that the leaf edge is not the first one in the tree.\n     pub unsafe fn next_back_unchecked(&mut self) -> (&'a K, &'a V) {\n-        let (next_edge, k, v) = next_back_unchecked(*self);\n-        *self = next_edge;\n-        (k, v)\n+        replace(self, |leaf_edge| {\n+            let kv = leaf_edge.next_back_kv();\n+            let kv = unwrap_unchecked(kv.ok());\n+            (kv.next_back_leaf_edge(), kv.into_kv())\n+        })\n     }\n }\n \n@@ -158,8 +119,11 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge\n     /// - The caller must ensure that the leaf edge is not the last one in the tree.\n     /// - Using the updated handle may well invalidate the returned references.\n     pub unsafe fn next_unchecked(&mut self) -> (&'a mut K, &'a mut V) {\n-        let (next_edge, kv) = next_unchecked_mut(ptr::read(self));\n-        *self = next_edge;\n+        let kv = replace(self, |leaf_edge| {\n+            let kv = leaf_edge.next_kv();\n+            let kv = unwrap_unchecked(kv.ok());\n+            (ptr::read(&kv).next_leaf_edge(), kv)\n+        });\n         // Doing the descend (and perhaps another move) invalidates the references\n         // returned by `into_kv_mut`, so we have to do this last.\n         kv.into_kv_mut()\n@@ -171,8 +135,11 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge\n     /// - The caller must ensure that the leaf edge is not the first one in the tree.\n     /// - Using the updated handle may well invalidate the returned references.\n     pub unsafe fn next_back_unchecked(&mut self) -> (&'a mut K, &'a mut V) {\n-        let (next_edge, kv) = next_back_unchecked_mut(ptr::read(self));\n-        *self = next_edge;\n+        let kv = replace(self, |leaf_edge| {\n+            let kv = leaf_edge.next_back_kv();\n+            let kv = unwrap_unchecked(kv.ok());\n+            (ptr::read(&kv).next_back_leaf_edge(), kv)\n+        });\n         // Doing the descend (and perhaps another move) invalidates the references\n         // returned by `into_kv_mut`, so we have to do this last.\n         kv.into_kv_mut()\n@@ -192,9 +159,12 @@ impl<K, V> Handle<NodeRef<marker::Owned, K, V, marker::Leaf>, marker::Edge> {\n     ///   if the two preconditions above hold.\n     /// - Using the updated handle may well invalidate the returned references.\n     pub unsafe fn next_unchecked(&mut self) -> (K, V) {\n-        let (next_edge, k, v) = next_unchecked_deallocating(ptr::read(self));\n-        *self = next_edge;\n-        (k, v)\n+        replace(self, |leaf_edge| {\n+            let kv = next_kv_unchecked_dealloc(leaf_edge);\n+            let k = ptr::read(kv.reborrow().into_kv().0);\n+            let v = ptr::read(kv.reborrow().into_kv().1);\n+            (kv.next_leaf_edge(), (k, v))\n+        })\n     }\n \n     /// Moves the leaf edge handle to the previous leaf edge and returns the key\n@@ -209,9 +179,12 @@ impl<K, V> Handle<NodeRef<marker::Owned, K, V, marker::Leaf>, marker::Edge> {\n     ///   if the two preconditions above hold.\n     /// - Using the updated handle may well invalidate the returned references.\n     pub unsafe fn next_back_unchecked(&mut self) -> (K, V) {\n-        let (next_edge, k, v) = next_back_unchecked_deallocating(ptr::read(self));\n-        *self = next_edge;\n-        (k, v)\n+        replace(self, |leaf_edge| {\n+            let kv = next_back_kv_unchecked_dealloc(leaf_edge);\n+            let k = ptr::read(kv.reborrow().into_kv().0);\n+            let v = ptr::read(kv.reborrow().into_kv().1);\n+            (kv.next_back_leaf_edge(), (k, v))\n+        })\n     }\n }\n \n@@ -242,3 +215,29 @@ impl<BorrowType, K, V> NodeRef<BorrowType, K, V, marker::LeafOrInternal> {\n         }\n     }\n }\n+\n+impl<BorrowType, K, V> Handle<NodeRef<BorrowType, K, V, marker::LeafOrInternal>, marker::KV> {\n+    /// Returns the leaf edge closest to a KV for forward navigation.\n+    pub fn next_leaf_edge(self) -> Handle<NodeRef<BorrowType, K, V, marker::Leaf>, marker::Edge> {\n+        match self.force() {\n+            Leaf(leaf_kv) => leaf_kv.right_edge(),\n+            Internal(internal_kv) => {\n+                let next_internal_edge = internal_kv.right_edge();\n+                next_internal_edge.descend().first_leaf_edge()\n+            }\n+        }\n+    }\n+\n+    /// Returns the leaf edge closest to a KV for backward navigation.\n+    pub fn next_back_leaf_edge(\n+        self,\n+    ) -> Handle<NodeRef<BorrowType, K, V, marker::Leaf>, marker::Edge> {\n+        match self.force() {\n+            Leaf(leaf_kv) => leaf_kv.left_edge(),\n+            Internal(internal_kv) => {\n+                let next_internal_edge = internal_kv.left_edge();\n+                next_internal_edge.descend().last_leaf_edge()\n+            }\n+        }\n+    }\n+}"}, {"sha": "c1bd68a020a688e200f76fe4463f602cd1edcfee", "filename": "src/liballoc/collections/btree/node.rs", "status": "modified", "additions": 22, "deletions": 20, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/e2223c94bf433fc38234d1303e88cbaf14755863/src%2Fliballoc%2Fcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2223c94bf433fc38234d1303e88cbaf14755863/src%2Fliballoc%2Fcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fnode.rs?ref=e2223c94bf433fc38234d1303e88cbaf14755863", "patch": "@@ -452,31 +452,25 @@ impl<BorrowType, K, V, Type> NodeRef<BorrowType, K, V, Type> {\n     }\n }\n \n-impl<K, V> NodeRef<marker::Owned, K, V, marker::Leaf> {\n+impl<K, V> NodeRef<marker::Owned, K, V, marker::LeafOrInternal> {\n     /// Similar to `ascend`, gets a reference to a node's parent node, but also\n     /// deallocate the current node in the process. This is unsafe because the\n     /// current node will still be accessible despite being deallocated.\n     pub unsafe fn deallocate_and_ascend(\n         self,\n     ) -> Option<Handle<NodeRef<marker::Owned, K, V, marker::Internal>, marker::Edge>> {\n         assert!(!self.is_shared_root());\n+        let height = self.height;\n         let node = self.node;\n         let ret = self.ascend().ok();\n-        Global.dealloc(node.cast(), Layout::new::<LeafNode<K, V>>());\n-        ret\n-    }\n-}\n-\n-impl<K, V> NodeRef<marker::Owned, K, V, marker::Internal> {\n-    /// Similar to `ascend`, gets a reference to a node's parent node, but also\n-    /// deallocate the current node in the process. This is unsafe because the\n-    /// current node will still be accessible despite being deallocated.\n-    pub unsafe fn deallocate_and_ascend(\n-        self,\n-    ) -> Option<Handle<NodeRef<marker::Owned, K, V, marker::Internal>, marker::Edge>> {\n-        let node = self.node;\n-        let ret = self.ascend().ok();\n-        Global.dealloc(node.cast(), Layout::new::<InternalNode<K, V>>());\n+        Global.dealloc(\n+            node.cast(),\n+            if height > 0 {\n+                Layout::new::<InternalNode<K, V>>()\n+            } else {\n+                Layout::new::<LeafNode<K, V>>()\n+            },\n+        );\n         ret\n     }\n }\n@@ -1427,15 +1421,23 @@ unsafe fn move_edges<K, V>(\n     dest.correct_childrens_parent_links(dest_offset, dest_offset + count);\n }\n \n-impl<BorrowType, K, V> Handle<NodeRef<BorrowType, K, V, marker::Leaf>, marker::KV> {\n+impl<BorrowType, K, V> Handle<NodeRef<BorrowType, K, V, marker::Leaf>, marker::Edge> {\n     pub fn forget_node_type(\n         self,\n-    ) -> Handle<NodeRef<BorrowType, K, V, marker::LeafOrInternal>, marker::KV> {\n-        unsafe { Handle::new_kv(self.node.forget_type(), self.idx) }\n+    ) -> Handle<NodeRef<BorrowType, K, V, marker::LeafOrInternal>, marker::Edge> {\n+        unsafe { Handle::new_edge(self.node.forget_type(), self.idx) }\n+    }\n+}\n+\n+impl<BorrowType, K, V> Handle<NodeRef<BorrowType, K, V, marker::Internal>, marker::Edge> {\n+    pub fn forget_node_type(\n+        self,\n+    ) -> Handle<NodeRef<BorrowType, K, V, marker::LeafOrInternal>, marker::Edge> {\n+        unsafe { Handle::new_edge(self.node.forget_type(), self.idx) }\n     }\n }\n \n-impl<BorrowType, K, V> Handle<NodeRef<BorrowType, K, V, marker::Internal>, marker::KV> {\n+impl<BorrowType, K, V> Handle<NodeRef<BorrowType, K, V, marker::Leaf>, marker::KV> {\n     pub fn forget_node_type(\n         self,\n     ) -> Handle<NodeRef<BorrowType, K, V, marker::LeafOrInternal>, marker::KV> {"}]}