{"sha": "2e172473daefd24631faf3906bd411798d7d8a17", "node_id": "C_kwDOAAsO6NoAKDJlMTcyNDczZGFlZmQyNDYzMWZhZjM5MDZiZDQxMTc5OGQ3ZDhhMTc", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-08-27T18:54:02Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-08-27T22:37:44Z"}, "message": "interpret: make read-pointer-as-bytes *always* work in Miri\n\nand show some extra information when it happens in CTFE", "tree": {"sha": "4bbfce7ca26338ca0db6ac3821acafd58b479d5c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4bbfce7ca26338ca0db6ac3821acafd58b479d5c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2e172473daefd24631faf3906bd411798d7d8a17", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2e172473daefd24631faf3906bd411798d7d8a17", "html_url": "https://github.com/rust-lang/rust/commit/2e172473daefd24631faf3906bd411798d7d8a17", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2e172473daefd24631faf3906bd411798d7d8a17/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e63a6257118effd270223ae38306013dfd477516", "url": "https://api.github.com/repos/rust-lang/rust/commits/e63a6257118effd270223ae38306013dfd477516", "html_url": "https://github.com/rust-lang/rust/commit/e63a6257118effd270223ae38306013dfd477516"}], "stats": {"total": 298, "additions": 153, "deletions": 145}, "files": [{"sha": "1f358b1bbb96edb89a2893cf9bc526f6dbcc79b9", "filename": "compiler/rustc_codegen_cranelift/src/intrinsics/simd.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2e172473daefd24631faf3906bd411798d7d8a17/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fsimd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e172473daefd24631faf3906bd411798d7d8a17/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fsimd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fsimd.rs?ref=2e172473daefd24631faf3906bd411798d7d8a17", "patch": "@@ -186,7 +186,10 @@ pub(super) fn codegen_simd_intrinsic_call<'tcx>(\n                         let size = Size::from_bytes(\n                             4 * ret_lane_count, /* size_of([u32; ret_lane_count]) */\n                         );\n-                        alloc.inner().get_bytes(fx, alloc_range(offset, size)).unwrap()\n+                        alloc\n+                            .inner()\n+                            .get_bytes_strip_provenance(fx, alloc_range(offset, size))\n+                            .unwrap()\n                     }\n                     _ => unreachable!(\"{:?}\", idx_const),\n                 };"}, {"sha": "63a3fef2e626371fe4c0e0d286b3faf07a12e267", "filename": "compiler/rustc_const_eval/src/const_eval/error.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/2e172473daefd24631faf3906bd411798d7d8a17/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e172473daefd24631faf3906bd411798d7d8a17/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Ferror.rs?ref=2e172473daefd24631faf3906bd411798d7d8a17", "patch": "@@ -10,6 +10,7 @@ use rustc_span::{Span, Symbol};\n use super::InterpCx;\n use crate::interpret::{\n     struct_error, ErrorHandled, FrameInfo, InterpError, InterpErrorInfo, Machine, MachineStopType,\n+    UnsupportedOpInfo,\n };\n \n /// The CTFE machine has some custom error kinds.\n@@ -153,6 +154,18 @@ impl<'tcx> ConstEvalErr<'tcx> {\n             if let Some(span_msg) = span_msg {\n                 err.span_label(self.span, span_msg);\n             }\n+            // Add some more context for select error types.\n+            match self.error {\n+                InterpError::Unsupported(\n+                    UnsupportedOpInfo::ReadPointerAsBytes\n+                    | UnsupportedOpInfo::PartialPointerOverwrite(_)\n+                    | UnsupportedOpInfo::PartialPointerCopy(_),\n+                ) => {\n+                    err.help(\"this code performed an operation that depends on the underlying bytes representing a pointer\");\n+                    err.help(\"the absolute address of a pointer is not known at compile-time, so such operations are not supported\");\n+                }\n+                _ => {}\n+            }\n             // Add spans for the stacktrace. Don't print a single-line backtrace though.\n             if self.stacktrace.len() > 1 {\n                 // Helper closure to print duplicated lines."}, {"sha": "6a737d120e26248d58831fa5739ea384e2a7f99e", "filename": "compiler/rustc_const_eval/src/const_eval/eval_queries.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2e172473daefd24631faf3906bd411798d7d8a17/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Feval_queries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e172473daefd24631faf3906bd411798d7d8a17/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Feval_queries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Feval_queries.rs?ref=2e172473daefd24631faf3906bd411798d7d8a17", "patch": "@@ -2,8 +2,8 @@ use super::{CompileTimeEvalContext, CompileTimeInterpreter, ConstEvalErr};\n use crate::interpret::eval_nullary_intrinsic;\n use crate::interpret::{\n     intern_const_alloc_recursive, Allocation, ConstAlloc, ConstValue, CtfeValidationMode, GlobalId,\n-    Immediate, InternKind, InterpCx, InterpResult, MPlaceTy, MemoryKind, OpTy, RefTracking,\n-    StackPopCleanup,\n+    Immediate, InternKind, InterpCx, InterpError, InterpResult, MPlaceTy, MemoryKind, OpTy,\n+    RefTracking, StackPopCleanup,\n };\n \n use rustc_hir::def::DefKind;\n@@ -385,7 +385,9 @@ pub fn eval_to_allocation_raw_provider<'tcx>(\n                     ecx.tcx,\n                     \"it is undefined behavior to use this value\",\n                     |diag| {\n-                        diag.note(NOTE_ON_UNDEFINED_BEHAVIOR_ERROR);\n+                        if matches!(err.error, InterpError::UndefinedBehavior(_)) {\n+                            diag.note(NOTE_ON_UNDEFINED_BEHAVIOR_ERROR);\n+                        }\n                         diag.note(&format!(\n                             \"the raw bytes of the constant ({}\",\n                             display_allocation("}, {"sha": "a8ec8447f64a4d1206fdf16aead8229ad09c38dd", "filename": "compiler/rustc_const_eval/src/interpret/intrinsics.rs", "status": "modified", "additions": 17, "deletions": 4, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/2e172473daefd24631faf3906bd411798d7d8a17/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e172473daefd24631faf3906bd411798d7d8a17/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics.rs?ref=2e172473daefd24631faf3906bd411798d7d8a17", "patch": "@@ -687,10 +687,23 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         let layout = self.layout_of(lhs.layout.ty.builtin_deref(true).unwrap().ty)?;\n         assert!(!layout.is_unsized());\n \n-        let lhs = self.read_pointer(lhs)?;\n-        let rhs = self.read_pointer(rhs)?;\n-        let lhs_bytes = self.read_bytes_ptr(lhs, layout.size)?;\n-        let rhs_bytes = self.read_bytes_ptr(rhs, layout.size)?;\n+        let get_bytes = |this: &InterpCx<'mir, 'tcx, M>,\n+                         op: &OpTy<'tcx, <M as Machine<'mir, 'tcx>>::Provenance>,\n+                         size|\n+         -> InterpResult<'tcx, &[u8]> {\n+            let ptr = this.read_pointer(op)?;\n+            let Some(alloc_ref) = self.get_ptr_alloc(ptr, size, Align::ONE)? else {\n+                // zero-sized access\n+                return Ok(&[]);\n+            };\n+            if alloc_ref.has_provenance() {\n+                throw_ub_format!(\"`raw_eq` on bytes with provenance\");\n+            }\n+            alloc_ref.get_bytes_strip_provenance()\n+        };\n+\n+        let lhs_bytes = get_bytes(self, lhs, layout.size)?;\n+        let rhs_bytes = get_bytes(self, rhs, layout.size)?;\n         Ok(Scalar::from_bool(lhs_bytes == rhs_bytes))\n     }\n }"}, {"sha": "69dbc9592fa87a73bd11b0a4e38805260e30c8df", "filename": "compiler/rustc_const_eval/src/interpret/memory.rs", "status": "modified", "additions": 14, "deletions": 10, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/2e172473daefd24631faf3906bd411798d7d8a17/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e172473daefd24631faf3906bd411798d7d8a17/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmemory.rs?ref=2e172473daefd24631faf3906bd411798d7d8a17", "patch": "@@ -953,10 +953,10 @@ impl<'tcx, 'a, Prov: Provenance, Extra> AllocRef<'a, 'tcx, Prov, Extra> {\n     }\n \n     /// `range` is relative to this allocation reference, not the base of the allocation.\n-    pub fn check_bytes(&self, range: AllocRange) -> InterpResult<'tcx> {\n+    pub fn get_bytes_strip_provenance<'b>(&'b self) -> InterpResult<'tcx, &'a [u8]> {\n         Ok(self\n             .alloc\n-            .check_bytes(&self.tcx, self.range.subrange(range))\n+            .get_bytes_strip_provenance(&self.tcx, self.range)\n             .map_err(|e| e.to_interp_error(self.alloc_id))?)\n     }\n \n@@ -967,10 +967,11 @@ impl<'tcx, 'a, Prov: Provenance, Extra> AllocRef<'a, 'tcx, Prov, Extra> {\n }\n \n impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n-    /// Reads the given number of bytes from memory. Returns them as a slice.\n+    /// Reads the given number of bytes from memory, and strips their provenance if possible.\n+    /// Returns them as a slice.\n     ///\n     /// Performs appropriate bounds checks.\n-    pub fn read_bytes_ptr(\n+    pub fn read_bytes_ptr_strip_provenance(\n         &self,\n         ptr: Pointer<Option<M::Provenance>>,\n         size: Size,\n@@ -983,7 +984,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         // (We are staying inside the bounds here so all is good.)\n         Ok(alloc_ref\n             .alloc\n-            .get_bytes(&alloc_ref.tcx, alloc_ref.range)\n+            .get_bytes_strip_provenance(&alloc_ref.tcx, alloc_ref.range)\n             .map_err(|e| e.to_interp_error(alloc_ref.alloc_id))?)\n     }\n \n@@ -1078,12 +1079,15 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             return Ok(());\n         };\n \n-        // This checks provenance edges on the src, which needs to happen before\n+        // Checks provenance edges on the src, which needs to happen before\n         // `prepare_provenance_copy`.\n-        let src_bytes = src_alloc\n-            .get_bytes_with_uninit_and_ptr(&tcx, src_range)\n-            .map_err(|e| e.to_interp_error(src_alloc_id))?\n-            .as_ptr(); // raw ptr, so we can also get a ptr to the destination allocation\n+        if src_alloc.range_has_provenance(&tcx, alloc_range(src_range.start, Size::ZERO)) {\n+            throw_unsup!(PartialPointerCopy(Pointer::new(src_alloc_id, src_range.start)));\n+        }\n+        if src_alloc.range_has_provenance(&tcx, alloc_range(src_range.end(), Size::ZERO)) {\n+            throw_unsup!(PartialPointerCopy(Pointer::new(src_alloc_id, src_range.end())));\n+        }\n+        let src_bytes = src_alloc.get_bytes_unchecked(src_range).as_ptr(); // raw ptr, so we can also get a ptr to the destination allocation\n         // first copy the provenance to a temporary buffer, because\n         // `get_bytes_mut` will clear the provenance, which is correct,\n         // since we don't want to keep any provenance at the target."}, {"sha": "6ec9b174f82ae2778923b334df30b2162190425d", "filename": "compiler/rustc_const_eval/src/interpret/operand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2e172473daefd24631faf3906bd411798d7d8a17/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e172473daefd24631faf3906bd411798d7d8a17/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs?ref=2e172473daefd24631faf3906bd411798d7d8a17", "patch": "@@ -415,7 +415,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     /// Turn the wide MPlace into a string (must already be dereferenced!)\n     pub fn read_str(&self, mplace: &MPlaceTy<'tcx, M::Provenance>) -> InterpResult<'tcx, &str> {\n         let len = mplace.len(self)?;\n-        let bytes = self.read_bytes_ptr(mplace.ptr, Size::from_bytes(len))?;\n+        let bytes = self.read_bytes_ptr_strip_provenance(mplace.ptr, Size::from_bytes(len))?;\n         let str = std::str::from_utf8(bytes).map_err(|err| err_ub!(InvalidStr(err)))?;\n         Ok(str)\n     }"}, {"sha": "d7841ba6670a117fcebda73368fa8b5ac6cbdd6c", "filename": "compiler/rustc_const_eval/src/interpret/place.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2e172473daefd24631faf3906bd411798d7d8a17/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e172473daefd24631faf3906bd411798d7d8a17/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs?ref=2e172473daefd24631faf3906bd411798d7d8a17", "patch": "@@ -2,8 +2,6 @@\n //! into a place.\n //! All high-level functions to write to memory work on places as destinations.\n \n-use std::hash::Hash;\n-\n use rustc_ast::Mutability;\n use rustc_middle::mir;\n use rustc_middle::ty;\n@@ -290,7 +288,7 @@ impl<'tcx, Prov: Provenance> PlaceTy<'tcx, Prov> {\n // FIXME: Working around https://github.com/rust-lang/rust/issues/54385\n impl<'mir, 'tcx: 'mir, Prov, M> InterpCx<'mir, 'tcx, M>\n where\n-    Prov: Provenance + Eq + Hash + 'static,\n+    Prov: Provenance + 'static,\n     M: Machine<'mir, 'tcx, Provenance = Prov>,\n {\n     /// Take a value, which represents a (thin or wide) reference, and make it a place."}, {"sha": "a800553f34e24df9b9e6c1696c3263b3bfcbe9b6", "filename": "compiler/rustc_const_eval/src/interpret/projection.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2e172473daefd24631faf3906bd411798d7d8a17/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fprojection.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e172473daefd24631faf3906bd411798d7d8a17/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fprojection.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fprojection.rs?ref=2e172473daefd24631faf3906bd411798d7d8a17", "patch": "@@ -7,8 +7,6 @@\n //! but we still need to do bounds checking and adjust the layout. To not duplicate that with MPlaceTy, we actually\n //! implement the logic on OpTy, and MPlaceTy calls that.\n \n-use std::hash::Hash;\n-\n use rustc_middle::mir;\n use rustc_middle::ty;\n use rustc_middle::ty::layout::LayoutOf;\n@@ -22,7 +20,7 @@ use super::{\n // FIXME: Working around https://github.com/rust-lang/rust/issues/54385\n impl<'mir, 'tcx: 'mir, Prov, M> InterpCx<'mir, 'tcx, M>\n where\n-    Prov: Provenance + Eq + Hash + 'static,\n+    Prov: Provenance + 'static,\n     M: Machine<'mir, 'tcx, Provenance = Prov>,\n {\n     //# Field access"}, {"sha": "ee55b4a0750f6e47aa7fc2660be8aed177047b14", "filename": "compiler/rustc_const_eval/src/interpret/validity.rs", "status": "modified", "additions": 12, "deletions": 23, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/2e172473daefd24631faf3906bd411798d7d8a17/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e172473daefd24631faf3906bd411798d7d8a17/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs?ref=2e172473daefd24631faf3906bd411798d7d8a17", "patch": "@@ -20,8 +20,8 @@ use rustc_target::abi::{Abi, Scalar as ScalarAbi, Size, VariantIdx, Variants, Wr\n use std::hash::Hash;\n \n use super::{\n-    alloc_range, CheckInAllocMsg, GlobalAlloc, ImmTy, Immediate, InterpCx, InterpResult, MPlaceTy,\n-    Machine, MemPlaceMeta, OpTy, Scalar, ValueVisitor,\n+    CheckInAllocMsg, GlobalAlloc, ImmTy, Immediate, InterpCx, InterpResult, MPlaceTy, Machine,\n+    MemPlaceMeta, OpTy, Scalar, ValueVisitor,\n };\n \n macro_rules! throw_validation_failure {\n@@ -312,7 +312,6 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n         Ok(try_validation!(\n             self.ecx.read_immediate(op),\n             self.path,\n-            err_unsup!(ReadPointerAsBytes) => { \"(potentially part of) a pointer\" } expected { \"{expected}\" },\n             err_ub!(InvalidUninitBytes(None)) => { \"uninitialized memory\" } expected { \"{expected}\" }\n         ))\n     }\n@@ -345,11 +344,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n                 // FIXME: check if the type/trait match what ty::Dynamic says?\n             }\n             ty::Slice(..) | ty::Str => {\n-                let _len = try_validation!(\n-                    meta.unwrap_meta().to_machine_usize(self.ecx),\n-                    self.path,\n-                    err_unsup!(ReadPointerAsBytes) => { \"non-integer slice length in wide pointer\" },\n-                );\n+                let _len = meta.unwrap_meta().to_machine_usize(self.ecx)?;\n                 // We do not check that `len * elem_size <= isize::MAX`:\n                 // that is only required for references, and there it falls out of the\n                 // \"dereferenceable\" check performed by Stacked Borrows.\n@@ -669,8 +664,6 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n                     { \"{:x}\", val } expected { \"a valid enum tag\" },\n                 err_ub!(InvalidUninitBytes(None)) =>\n                     { \"uninitialized bytes\" } expected { \"a valid enum tag\" },\n-                err_unsup!(ReadPointerAsBytes) =>\n-                    { \"a pointer\" } expected { \"a valid enum tag\" },\n             )\n             .1)\n         })\n@@ -810,10 +803,9 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n                 let mplace = op.assert_mem_place(); // strings are unsized and hence never immediate\n                 let len = mplace.len(self.ecx)?;\n                 try_validation!(\n-                    self.ecx.read_bytes_ptr(mplace.ptr, Size::from_bytes(len)),\n+                    self.ecx.read_bytes_ptr_strip_provenance(mplace.ptr, Size::from_bytes(len)),\n                     self.path,\n                     err_ub!(InvalidUninitBytes(..)) => { \"uninitialized data in `str`\" },\n-                    err_unsup!(ReadPointerAsBytes) => { \"a pointer in `str`\" },\n                 );\n             }\n             ty::Array(tys, ..) | ty::Slice(tys)\n@@ -861,9 +853,9 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n                 // We also accept uninit, for consistency with the slow path.\n                 let alloc = self.ecx.get_ptr_alloc(mplace.ptr, size, mplace.align)?.expect(\"we already excluded size 0\");\n \n-                match alloc.check_bytes(alloc_range(Size::ZERO, size)) {\n+                match alloc.get_bytes_strip_provenance() {\n                     // In the happy case, we needn't check anything else.\n-                    Ok(()) => {}\n+                    Ok(_) => {}\n                     // Some error happened, try to provide a more detailed description.\n                     Err(err) => {\n                         // For some errors we might be able to provide extra information.\n@@ -881,9 +873,6 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n \n                                 throw_validation_failure!(self.path, { \"uninitialized bytes\" })\n                             }\n-                            err_unsup!(ReadPointerAsBytes) => {\n-                                throw_validation_failure!(self.path, { \"a pointer\" } expected { \"plain (non-pointer) bytes\" })\n-                            }\n \n                             // Propagate upwards (that will also check for unexpected errors).\n                             _ => return Err(err),\n@@ -924,14 +913,14 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             Ok(()) => Ok(()),\n             // Pass through validation failures.\n             Err(err) if matches!(err.kind(), err_ub!(ValidationFailure { .. })) => Err(err),\n-            // Also pass through InvalidProgram, those just indicate that we could not\n-            // validate and each caller will know best what to do with them.\n-            Err(err) if matches!(err.kind(), InterpError::InvalidProgram(_)) => Err(err),\n-            // Avoid other errors as those do not show *where* in the value the issue lies.\n-            Err(err) => {\n+            // Complain about any other kind of UB error -- those are bad because we'd like to\n+            // report them in a way that shows *where* in the value the issue lies.\n+            Err(err) if matches!(err.kind(), InterpError::UndefinedBehavior(_)) => {\n                 err.print_backtrace();\n-                bug!(\"Unexpected error during validation: {}\", err);\n+                bug!(\"Unexpected Undefined Behavior error during validation: {}\", err);\n             }\n+            // Pass through everything else.\n+            Err(err) => Err(err),\n         }\n     }\n "}, {"sha": "37ec04b07f847bc009814d04c51059e1594e247b", "filename": "compiler/rustc_middle/src/mir/interpret/allocation.rs", "status": "modified", "additions": 65, "deletions": 91, "changes": 156, "blob_url": "https://github.com/rust-lang/rust/blob/2e172473daefd24631faf3906bd411798d7d8a17/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e172473daefd24631faf3906bd411798d7d8a17/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation.rs?ref=2e172473daefd24631faf3906bd411798d7d8a17", "patch": "@@ -130,6 +130,8 @@ pub enum AllocError {\n     ReadPointerAsBytes,\n     /// Partially overwriting a pointer.\n     PartialPointerOverwrite(Size),\n+    /// Partially copying a pointer.\n+    PartialPointerCopy(Size),\n     /// Using uninitialized data where it is not allowed.\n     InvalidUninitBytes(Option<UninitBytesAccess>),\n }\n@@ -152,6 +154,9 @@ impl AllocError {\n             PartialPointerOverwrite(offset) => InterpError::Unsupported(\n                 UnsupportedOpInfo::PartialPointerOverwrite(Pointer::new(alloc_id, offset)),\n             ),\n+            PartialPointerCopy(offset) => InterpError::Unsupported(\n+                UnsupportedOpInfo::PartialPointerCopy(Pointer::new(alloc_id, offset)),\n+            ),\n             InvalidUninitBytes(info) => InterpError::UndefinedBehavior(\n                 UndefinedBehaviorInfo::InvalidUninitBytes(info.map(|b| (alloc_id, b))),\n             ),\n@@ -322,62 +327,35 @@ impl<Prov, Extra> Allocation<Prov, Extra> {\n /// Byte accessors.\n impl<Prov: Provenance, Extra> Allocation<Prov, Extra> {\n     /// This is the entirely abstraction-violating way to just grab the raw bytes without\n-    /// caring about provenance. It just deduplicates some code between `read_scalar`\n-    /// and `get_bytes_internal`.\n-    fn get_bytes_even_more_internal(&self, range: AllocRange) -> &[u8] {\n-        &self.bytes[range.start.bytes_usize()..range.end().bytes_usize()]\n-    }\n-\n-    /// The last argument controls whether we error out when there are uninitialized or pointer\n-    /// bytes. However, we *always* error when there is provenance overlapping the edges of the\n-    /// range.\n-    ///\n-    /// You should never call this, call `get_bytes` or `get_bytes_with_uninit_and_ptr` instead,\n+    /// caring about provenance or initialization.\n     ///\n     /// This function also guarantees that the resulting pointer will remain stable\n     /// even when new allocations are pushed to the `HashMap`. `mem_copy_repeatedly` relies\n     /// on that.\n-    ///\n-    /// It is the caller's responsibility to check bounds and alignment beforehand.\n-    fn get_bytes_internal(\n-        &self,\n-        cx: &impl HasDataLayout,\n-        range: AllocRange,\n-        check_init_and_ptr: bool,\n-    ) -> AllocResult<&[u8]> {\n-        if check_init_and_ptr {\n-            self.check_init(range)?;\n-            self.check_provenance(cx, range)?;\n-        } else {\n-            // We still don't want provenance on the *edges*.\n-            self.check_provenance_edges(cx, range)?;\n-        }\n-\n-        Ok(self.get_bytes_even_more_internal(range))\n+    #[inline]\n+    pub fn get_bytes_unchecked(&self, range: AllocRange) -> &[u8] {\n+        &self.bytes[range.start.bytes_usize()..range.end().bytes_usize()]\n     }\n \n-    /// Checks that these bytes are initialized and not pointer bytes, and then return them\n-    /// as a slice.\n+    /// Checks that these bytes are initialized, and then strip provenance (if possible) and return\n+    /// them.\n     ///\n     /// It is the caller's responsibility to check bounds and alignment beforehand.\n     /// Most likely, you want to use the `PlaceTy` and `OperandTy`-based methods\n     /// on `InterpCx` instead.\n     #[inline]\n-    pub fn get_bytes(&self, cx: &impl HasDataLayout, range: AllocRange) -> AllocResult<&[u8]> {\n-        self.get_bytes_internal(cx, range, true)\n-    }\n-\n-    /// It is the caller's responsibility to handle uninitialized and pointer bytes.\n-    /// However, this still checks that there is no provenance on the *edges*.\n-    ///\n-    /// It is the caller's responsibility to check bounds and alignment beforehand.\n-    #[inline]\n-    pub fn get_bytes_with_uninit_and_ptr(\n+    pub fn get_bytes_strip_provenance(\n         &self,\n         cx: &impl HasDataLayout,\n         range: AllocRange,\n     ) -> AllocResult<&[u8]> {\n-        self.get_bytes_internal(cx, range, false)\n+        self.check_init(range)?;\n+        if !Prov::OFFSET_IS_ADDR {\n+            if self.range_has_provenance(cx, range) {\n+                return Err(AllocError::ReadPointerAsBytes);\n+            }\n+        }\n+        Ok(self.get_bytes_unchecked(range))\n     }\n \n     /// Just calling this already marks everything as defined and removes provenance,\n@@ -415,13 +393,6 @@ impl<Prov: Provenance, Extra> Allocation<Prov, Extra> {\n \n /// Reading and writing.\n impl<Prov: Provenance, Extra> Allocation<Prov, Extra> {\n-    /// Validates that this memory range is initiailized and contains no provenance.\n-    pub fn check_bytes(&self, cx: &impl HasDataLayout, range: AllocRange) -> AllocResult {\n-        // This implicitly does all the checking we are asking for.\n-        self.get_bytes(cx, range)?;\n-        Ok(())\n-    }\n-\n     /// Reads a *non-ZST* scalar.\n     ///\n     /// If `read_provenance` is `true`, this will also read provenance; otherwise (if the machine\n@@ -438,43 +409,53 @@ impl<Prov: Provenance, Extra> Allocation<Prov, Extra> {\n         range: AllocRange,\n         read_provenance: bool,\n     ) -> AllocResult<Scalar<Prov>> {\n-        if read_provenance {\n-            assert_eq!(range.size, cx.data_layout().pointer_size);\n-        }\n-\n         // First and foremost, if anything is uninit, bail.\n         if self.is_init(range).is_err() {\n             return Err(AllocError::InvalidUninitBytes(None));\n         }\n \n-        // If we are doing a pointer read, and there is provenance exactly where we\n-        // are reading, then we can put data and provenance back together and return that.\n-        if read_provenance && let Some(&prov) = self.provenance.get(&range.start) {\n-            // We already checked init and provenance, so we can use this function.\n-            let bytes = self.get_bytes_even_more_internal(range);\n-            let bits = read_target_uint(cx.data_layout().endian, bytes).unwrap();\n-            let ptr = Pointer::new(prov, Size::from_bytes(bits));\n-            return Ok(Scalar::from_pointer(ptr, cx));\n-        }\n+        // Get the integer part of the result. We HAVE TO check provenance before returning this!\n+        let bytes = self.get_bytes_unchecked(range);\n+        let bits = read_target_uint(cx.data_layout().endian, bytes).unwrap();\n \n-        // If we are *not* reading a pointer, and we can just ignore provenance,\n-        // then do exactly that.\n-        if !read_provenance && Prov::OFFSET_IS_ADDR {\n-            // We just strip provenance.\n-            let bytes = self.get_bytes_even_more_internal(range);\n-            let bits = read_target_uint(cx.data_layout().endian, bytes).unwrap();\n-            return Ok(Scalar::from_uint(bits, range.size));\n+        if read_provenance {\n+            assert_eq!(range.size, cx.data_layout().pointer_size);\n+\n+            // When reading data with provenance, the easy case is finding provenance exactly where we\n+            // are reading, then we can put data and provenance back together and return that.\n+            if let Some(&prov) = self.provenance.get(&range.start) {\n+                // Now we can return the bits, with their appropriate provenance.\n+                let ptr = Pointer::new(prov, Size::from_bytes(bits));\n+                return Ok(Scalar::from_pointer(ptr, cx));\n+            }\n+\n+            // If we can work on pointers byte-wise, join the byte-wise provenances.\n+            if Prov::OFFSET_IS_ADDR {\n+                let mut prov = self.offset_get_provenance(cx, range.start);\n+                for offset in 1..range.size.bytes() {\n+                    let this_prov =\n+                        self.offset_get_provenance(cx, range.start + Size::from_bytes(offset));\n+                    prov = Prov::join(prov, this_prov);\n+                }\n+                // Now use this provenance.\n+                let ptr = Pointer::new(prov, Size::from_bytes(bits));\n+                return Ok(Scalar::from_maybe_pointer(ptr, cx));\n+            }\n+        } else {\n+            // We are *not* reading a pointer.\n+            // If we can just ignore provenance, do exactly that.\n+            if Prov::OFFSET_IS_ADDR {\n+                // We just strip provenance.\n+                return Ok(Scalar::from_uint(bits, range.size));\n+            }\n         }\n \n-        // It's complicated. Better make sure there is no provenance anywhere.\n-        // FIXME: If !OFFSET_IS_ADDR, this is the best we can do. But if OFFSET_IS_ADDR, then\n-        // `read_pointer` is true and we ideally would distinguish the following two cases:\n-        // - The entire `range` is covered by the same provenance, stored in two separate entries of\n-        //   the provenance map. Then we should return a pointer with that provenance.\n-        // - The range has inhomogeneous provenance. Then we should return just the\n-        //   underlying bits.\n-        let bytes = self.get_bytes(cx, range)?;\n-        let bits = read_target_uint(cx.data_layout().endian, bytes).unwrap();\n+        // Fallback path for when we cannot treat provenance bytewise or ignore it.\n+        assert!(!Prov::OFFSET_IS_ADDR);\n+        if self.range_has_provenance(cx, range) {\n+            return Err(AllocError::ReadPointerAsBytes);\n+        }\n+        // There is no provenance, we can just return the bits.\n         Ok(Scalar::from_uint(bits, range.size))\n     }\n \n@@ -534,6 +515,13 @@ impl<Prov: Copy, Extra> Allocation<Prov, Extra> {\n         self.provenance.range(Size::from_bytes(start)..range.end())\n     }\n \n+    /// Get the provenance of a single byte.\n+    fn offset_get_provenance(&self, cx: &impl HasDataLayout, offset: Size) -> Option<Prov> {\n+        let prov = self.range_get_provenance(cx, alloc_range(offset, Size::from_bytes(1)));\n+        assert!(prov.len() <= 1);\n+        prov.first().map(|(_offset, prov)| *prov)\n+    }\n+\n     /// Returns whether this allocation has progrnance overlapping with the given range.\n     ///\n     /// Note: this function exists to allow `range_get_provenance` to be private, in order to somewhat\n@@ -543,12 +531,6 @@ impl<Prov: Copy, Extra> Allocation<Prov, Extra> {\n         !self.range_get_provenance(cx, range).is_empty()\n     }\n \n-    /// Checks that there is no provenance overlapping with the given range.\n-    #[inline(always)]\n-    fn check_provenance(&self, cx: &impl HasDataLayout, range: AllocRange) -> AllocResult {\n-        if self.range_has_provenance(cx, range) { Err(AllocError::ReadPointerAsBytes) } else { Ok(()) }\n-    }\n-\n     /// Removes all provenance inside the given range.\n     /// If there is provenance overlapping with the edges, it\n     /// are removed as well *and* the bytes they cover are marked as\n@@ -606,14 +588,6 @@ impl<Prov: Copy, Extra> Allocation<Prov, Extra> {\n \n         Ok(())\n     }\n-\n-    /// Errors if there is provenance overlapping with the edges of the given memory range.\n-    #[inline]\n-    fn check_provenance_edges(&self, cx: &impl HasDataLayout, range: AllocRange) -> AllocResult {\n-        self.check_provenance(cx, alloc_range(range.start, Size::ZERO))?;\n-        self.check_provenance(cx, alloc_range(range.end(), Size::ZERO))?;\n-        Ok(())\n-    }\n }\n \n /// Stores the provenance information of pointers stored in memory."}, {"sha": "e4039cc7c685ad0c635f15420582b72f3c486a8e", "filename": "compiler/rustc_middle/src/mir/interpret/error.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/2e172473daefd24631faf3906bd411798d7d8a17/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e172473daefd24631faf3906bd411798d7d8a17/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Ferror.rs?ref=2e172473daefd24631faf3906bd411798d7d8a17", "patch": "@@ -401,14 +401,18 @@ impl fmt::Display for UndefinedBehaviorInfo {\n pub enum UnsupportedOpInfo {\n     /// Free-form case. Only for errors that are never caught!\n     Unsupported(String),\n-    /// Encountered a pointer where we needed raw bytes.\n-    ReadPointerAsBytes,\n     /// Overwriting parts of a pointer; the resulting state cannot be represented in our\n     /// `Allocation` data structure. See <https://github.com/rust-lang/miri/issues/2181>.\n     PartialPointerOverwrite(Pointer<AllocId>),\n+    /// Attempting to `copy` parts of a pointer to somewhere else; the resulting state cannot be\n+    /// represented in our `Allocation` data structure. See\n+    /// <https://github.com/rust-lang/miri/issues/2181>.\n+    PartialPointerCopy(Pointer<AllocId>),\n     //\n     // The variants below are only reachable from CTFE/const prop, miri will never emit them.\n     //\n+    /// Encountered a pointer where we needed raw bytes.\n+    ReadPointerAsBytes,\n     /// Accessing thread local statics\n     ThreadLocalStatic(DefId),\n     /// Accessing an unsupported extern static.\n@@ -420,10 +424,13 @@ impl fmt::Display for UnsupportedOpInfo {\n         use UnsupportedOpInfo::*;\n         match self {\n             Unsupported(ref msg) => write!(f, \"{msg}\"),\n-            ReadPointerAsBytes => write!(f, \"unable to turn pointer into raw bytes\"),\n             PartialPointerOverwrite(ptr) => {\n                 write!(f, \"unable to overwrite parts of a pointer in memory at {ptr:?}\")\n             }\n+            PartialPointerCopy(ptr) => {\n+                write!(f, \"unable to copy parts of a pointer from memory at {ptr:?}\")\n+            }\n+            ReadPointerAsBytes => write!(f, \"unable to turn pointer into raw bytes\"),\n             ThreadLocalStatic(did) => write!(f, \"cannot access thread local static ({did:?})\"),\n             ReadExternStatic(did) => write!(f, \"cannot read from extern static ({did:?})\"),\n         }"}, {"sha": "5fa802236edd307def377e7c33d8e63d87062fb7", "filename": "compiler/rustc_middle/src/mir/interpret/pointer.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2e172473daefd24631faf3906bd411798d7d8a17/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fpointer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e172473daefd24631faf3906bd411798d7d8a17/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fpointer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fpointer.rs?ref=2e172473daefd24631faf3906bd411798d7d8a17", "patch": "@@ -125,6 +125,9 @@ pub trait Provenance: Copy + fmt::Debug {\n     /// Otherwise this function is best-effort (but must agree with `Machine::ptr_get_alloc`).\n     /// (Identifying the offset in that allocation, however, is harder -- use `Memory::ptr_get_alloc` for that.)\n     fn get_alloc_id(self) -> Option<AllocId>;\n+\n+    /// Defines the 'join' of provenance: what happens when doing a pointer load and different bytes have different provenance.\n+    fn join(left: Option<Self>, right: Option<Self>) -> Option<Self>;\n }\n \n impl Provenance for AllocId {\n@@ -152,6 +155,10 @@ impl Provenance for AllocId {\n     fn get_alloc_id(self) -> Option<AllocId> {\n         Some(self)\n     }\n+\n+    fn join(_left: Option<Self>, _right: Option<Self>) -> Option<Self> {\n+        panic!(\"merging provenance is not supported when `OFFSET_IS_ADDR` is false\")\n+    }\n }\n \n /// Represents a pointer in the Miri engine."}, {"sha": "d4fad7f1ecdd9fc656e762831ff5c937d11d7964", "filename": "compiler/rustc_middle/src/mir/interpret/value.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2e172473daefd24631faf3906bd411798d7d8a17/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e172473daefd24631faf3906bd411798d7d8a17/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fvalue.rs?ref=2e172473daefd24631faf3906bd411798d7d8a17", "patch": "@@ -507,7 +507,7 @@ pub fn get_slice_bytes<'tcx>(cx: &impl HasDataLayout, val: ConstValue<'tcx>) ->\n     if let ConstValue::Slice { data, start, end } = val {\n         let len = end - start;\n         data.inner()\n-            .get_bytes(\n+            .get_bytes_strip_provenance(\n                 cx,\n                 AllocRange { start: Size::from_bytes(start), size: Size::from_bytes(len) },\n             )"}, {"sha": "75327cff368d3fd5796f3cb82f2b19daf2cab973", "filename": "compiler/rustc_middle/src/mir/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2e172473daefd24631faf3906bd411798d7d8a17/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e172473daefd24631faf3906bd411798d7d8a17/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs?ref=2e172473daefd24631faf3906bd411798d7d8a17", "patch": "@@ -2719,7 +2719,7 @@ fn pretty_print_const_value<'tcx>(\n                 let n = n.kind().try_to_bits(tcx.data_layout.pointer_size).unwrap();\n                 // cast is ok because we already checked for pointer size (32 or 64 bit) above\n                 let range = AllocRange { start: offset, size: Size::from_bytes(n) };\n-                let byte_str = alloc.inner().get_bytes(&tcx, range).unwrap();\n+                let byte_str = alloc.inner().get_bytes_strip_provenance(&tcx, range).unwrap();\n                 fmt.write_str(\"*\")?;\n                 pretty_print_byte_str(fmt, byte_str)?;\n                 return Ok(());"}, {"sha": "2dfbcb7fa318f8b735de37fbb0ce0eb80d8df732", "filename": "compiler/rustc_middle/src/ty/print/pretty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2e172473daefd24631faf3906bd411798d7d8a17/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e172473daefd24631faf3906bd411798d7d8a17/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs?ref=2e172473daefd24631faf3906bd411798d7d8a17", "patch": "@@ -1275,7 +1275,7 @@ pub trait PrettyPrinter<'tcx>:\n                                     let range =\n                                         AllocRange { start: offset, size: Size::from_bytes(len) };\n                                     if let Ok(byte_str) =\n-                                        alloc.inner().get_bytes(&self.tcx(), range)\n+                                        alloc.inner().get_bytes_strip_provenance(&self.tcx(), range)\n                                     {\n                                         p!(pretty_print_byte_str(byte_str))\n                                     } else {"}]}