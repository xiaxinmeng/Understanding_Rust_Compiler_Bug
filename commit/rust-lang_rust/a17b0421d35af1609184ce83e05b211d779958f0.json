{"sha": "a17b0421d35af1609184ce83e05b211d779958f0", "node_id": "MDY6Q29tbWl0NzI0NzEyOmExN2IwNDIxZDM1YWYxNjA5MTg0Y2U4M2UwNWIyMTFkNzc5OTU4ZjA=", "commit": {"author": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2014-06-19T12:38:01Z"}, "committer": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2014-06-19T12:45:20Z"}, "message": "rustdoc: refactor code block language info into a struct.\n\nFields have names, unlike an anonymous tuple.", "tree": {"sha": "e1c5f55d0f5921dd3314d5efdbf3944877699695", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e1c5f55d0f5921dd3314d5efdbf3944877699695"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a17b0421d35af1609184ce83e05b211d779958f0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a17b0421d35af1609184ce83e05b211d779958f0", "html_url": "https://github.com/rust-lang/rust/commit/a17b0421d35af1609184ce83e05b211d779958f0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a17b0421d35af1609184ce83e05b211d779958f0/comments", "author": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "af622a491a18c27764199608f927a408af2f317c", "url": "https://api.github.com/repos/rust-lang/rust/commits/af622a491a18c27764199608f927a408af2f317c", "html_url": "https://github.com/rust-lang/rust/commit/af622a491a18c27764199608f927a408af2f317c"}], "stats": {"total": 110, "additions": 68, "deletions": 42}, "files": [{"sha": "625dd3b4810a957d58953c25a19ad79b11d92a80", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 68, "deletions": 42, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/a17b0421d35af1609184ce83e05b211d779958f0/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a17b0421d35af1609184ce83e05b211d779958f0/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=a17b0421d35af1609184ce83e05b211d779958f0", "patch": "@@ -174,8 +174,7 @@ pub fn render(w: &mut fmt::Formatter, s: &str, print_toc: bool) -> fmt::Result {\n                     slice::raw::buf_as_slice((*lang).data,\n                                            (*lang).size as uint, |rlang| {\n                         let rlang = str::from_utf8(rlang).unwrap();\n-                        let (_,_,_,notrust) = parse_lang_string(rlang);\n-                        if notrust {\n+                        if LangString::parse(rlang).notrust {\n                             (my_opaque.dfltblk)(ob, &buf, lang,\n                                                 opaque as *mut libc::c_void);\n                             true\n@@ -309,16 +308,16 @@ pub fn find_testable_code(doc: &str, tests: &mut ::test::Collector) {\n                     lang: *hoedown_buffer, opaque: *mut libc::c_void) {\n         unsafe {\n             if text.is_null() { return }\n-            let (should_fail, no_run, ignore, notrust) = if lang.is_null() {\n-                (false, false, false, false)\n+            let block_info = if lang.is_null() {\n+                LangString::all_false()\n             } else {\n                 slice::raw::buf_as_slice((*lang).data,\n                                        (*lang).size as uint, |lang| {\n                     let s = str::from_utf8(lang).unwrap();\n-                    parse_lang_string(s)\n+                    LangString::parse(s)\n                 })\n             };\n-            if notrust { return }\n+            if block_info.notrust { return }\n             slice::raw::buf_as_slice((*text).data, (*text).size as uint, |text| {\n                 let opaque = opaque as *mut hoedown_html_renderer_state;\n                 let tests = &mut *((*opaque).opaque as *mut ::test::Collector);\n@@ -327,7 +326,9 @@ pub fn find_testable_code(doc: &str, tests: &mut ::test::Collector) {\n                     stripped_filtered_line(l).unwrap_or(l)\n                 });\n                 let text = lines.collect::<Vec<&str>>().connect(\"\\n\");\n-                tests.add_test(text.to_string(), should_fail, no_run, ignore);\n+                tests.add_test(text.to_string(),\n+                               block_info.should_fail, block_info.no_run,\n+                               block_info.ignore);\n             })\n         }\n     }\n@@ -365,33 +366,49 @@ pub fn find_testable_code(doc: &str, tests: &mut ::test::Collector) {\n     }\n }\n \n-fn parse_lang_string(string: &str) -> (bool,bool,bool,bool) {\n-    let mut seen_rust_tags = false;\n-    let mut seen_other_tags = false;\n-    let mut should_fail = false;\n-    let mut no_run = false;\n-    let mut ignore = false;\n-    let mut notrust = false;\n-\n-    let mut tokens = string.as_slice().split(|c: char|\n-      !(c == '_' || c == '-' || c.is_alphanumeric())\n-    );\n-\n-    for token in tokens {\n-        match token {\n-            \"\" => {},\n-            \"should_fail\" => { should_fail = true; seen_rust_tags = true; },\n-            \"no_run\" => { no_run = true; seen_rust_tags = true; },\n-            \"ignore\" => { ignore = true; seen_rust_tags = true; },\n-            \"notrust\" => { notrust = true; seen_rust_tags = true; },\n-            \"rust\" => { notrust = false; seen_rust_tags = true; },\n-            _ => { seen_other_tags = true }\n+#[deriving(Eq, PartialEq, Clone, Show)]\n+struct LangString {\n+    should_fail: bool,\n+    no_run: bool,\n+    ignore: bool,\n+    notrust: bool,\n+}\n+\n+impl LangString {\n+    fn all_false() -> LangString {\n+        LangString {\n+            should_fail: false,\n+            no_run: false,\n+            ignore: false,\n+            notrust: false,\n         }\n     }\n \n-    let notrust = notrust || (seen_other_tags && !seen_rust_tags);\n+    fn parse(string: &str) -> LangString {\n+        let mut seen_rust_tags = false;\n+        let mut seen_other_tags = false;\n+        let mut data = LangString::all_false();\n+\n+        let mut tokens = string.as_slice().split(|c: char|\n+            !(c == '_' || c == '-' || c.is_alphanumeric())\n+        );\n+\n+        for token in tokens {\n+            match token {\n+                \"\" => {},\n+                \"should_fail\" => { data.should_fail = true; seen_rust_tags = true; },\n+                \"no_run\" => { data.no_run = true; seen_rust_tags = true; },\n+                \"ignore\" => { data.ignore = true; seen_rust_tags = true; },\n+                \"notrust\" => { data.notrust = true; seen_rust_tags = true; },\n+                \"rust\" => { data.notrust = false; seen_rust_tags = true; },\n+                _ => { seen_other_tags = true }\n+            }\n+        }\n+\n+        data.notrust |= seen_other_tags && !seen_rust_tags;\n \n-    (should_fail, no_run, ignore, notrust)\n+        data\n+    }\n }\n \n /// By default this markdown renderer generates anchors for each header in the\n@@ -425,19 +442,28 @@ impl<'a> fmt::Show for MarkdownWithToc<'a> {\n \n #[cfg(test)]\n mod tests {\n-    use super::parse_lang_string;\n+    use super::LangString;\n \n     #[test]\n-    fn test_parse_lang_string() {\n-        assert_eq!(parse_lang_string(\"\"), (false,false,false,false))\n-        assert_eq!(parse_lang_string(\"rust\"), (false,false,false,false))\n-        assert_eq!(parse_lang_string(\"sh\"), (false,false,false,true))\n-        assert_eq!(parse_lang_string(\"notrust\"), (false,false,false,true))\n-        assert_eq!(parse_lang_string(\"ignore\"), (false,false,true,false))\n-        assert_eq!(parse_lang_string(\"should_fail\"), (true,false,false,false))\n-        assert_eq!(parse_lang_string(\"no_run\"), (false,true,false,false))\n-        assert_eq!(parse_lang_string(\"{.no_run .example}\"), (false,true,false,false))\n-        assert_eq!(parse_lang_string(\"{.sh .should_fail}\"), (true,false,false,false))\n-        assert_eq!(parse_lang_string(\"{.example .rust}\"), (false,false,false,false))\n+    fn test_lang_string_parse() {\n+        fn t(s: &str, should_fail: bool, no_run: bool, ignore: bool, notrust: bool) {\n+            assert_eq!(LangString::parse(s), LangString {\n+                should_fail: should_fail,\n+                no_run: no_run,\n+                ignore: ignore,\n+                notrust: notrust,\n+            })\n+        }\n+\n+        t(\"\", false,false,false,false);\n+        t(\"rust\", false,false,false,false);\n+        t(\"sh\", false,false,false,true);\n+        t(\"notrust\", false,false,false,true);\n+        t(\"ignore\", false,false,true,false);\n+        t(\"should_fail\", true,false,false,false);\n+        t(\"no_run\", false,true,false,false);\n+        t(\"{.no_run .example}\", false,true,false,false);\n+        t(\"{.sh .should_fail}\", true,false,false,false);\n+        t(\"{.example .rust}\", false,false,false,false);\n     }\n }"}]}