{"sha": "17a14fe0e9402cf0883f5957879646a9ef359769", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE3YTE0ZmUwZTk0MDJjZjA4ODNmNTk1Nzg3OTY0NmE5ZWYzNTk3Njk=", "commit": {"author": {"name": "Brendan Zabarauskas", "email": "bjzaba@yahoo.com.au", "date": "2013-02-07T11:55:23Z"}, "committer": {"name": "Brendan Zabarauskas", "email": "bjzaba@yahoo.com.au", "date": "2013-02-07T11:55:23Z"}, "message": "Merge branch 'incoming' of https://github.com/mozilla/rust into incoming", "tree": {"sha": "9cc140d6789c512931733b4f6d9ae8aee2f42496", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9cc140d6789c512931733b4f6d9ae8aee2f42496"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/17a14fe0e9402cf0883f5957879646a9ef359769", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/17a14fe0e9402cf0883f5957879646a9ef359769", "html_url": "https://github.com/rust-lang/rust/commit/17a14fe0e9402cf0883f5957879646a9ef359769", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/17a14fe0e9402cf0883f5957879646a9ef359769/comments", "author": {"login": "brendanzab", "id": 695077, "node_id": "MDQ6VXNlcjY5NTA3Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/695077?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brendanzab", "html_url": "https://github.com/brendanzab", "followers_url": "https://api.github.com/users/brendanzab/followers", "following_url": "https://api.github.com/users/brendanzab/following{/other_user}", "gists_url": "https://api.github.com/users/brendanzab/gists{/gist_id}", "starred_url": "https://api.github.com/users/brendanzab/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brendanzab/subscriptions", "organizations_url": "https://api.github.com/users/brendanzab/orgs", "repos_url": "https://api.github.com/users/brendanzab/repos", "events_url": "https://api.github.com/users/brendanzab/events{/privacy}", "received_events_url": "https://api.github.com/users/brendanzab/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brendanzab", "id": 695077, "node_id": "MDQ6VXNlcjY5NTA3Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/695077?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brendanzab", "html_url": "https://github.com/brendanzab", "followers_url": "https://api.github.com/users/brendanzab/followers", "following_url": "https://api.github.com/users/brendanzab/following{/other_user}", "gists_url": "https://api.github.com/users/brendanzab/gists{/gist_id}", "starred_url": "https://api.github.com/users/brendanzab/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brendanzab/subscriptions", "organizations_url": "https://api.github.com/users/brendanzab/orgs", "repos_url": "https://api.github.com/users/brendanzab/repos", "events_url": "https://api.github.com/users/brendanzab/events{/privacy}", "received_events_url": "https://api.github.com/users/brendanzab/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e4c7d8ec8764d1daf8b247c359d564daea1c113c", "url": "https://api.github.com/repos/rust-lang/rust/commits/e4c7d8ec8764d1daf8b247c359d564daea1c113c", "html_url": "https://github.com/rust-lang/rust/commit/e4c7d8ec8764d1daf8b247c359d564daea1c113c"}, {"sha": "b3e182568f9f1fdbb598e8fcc95c64dd922d255e", "url": "https://api.github.com/repos/rust-lang/rust/commits/b3e182568f9f1fdbb598e8fcc95c64dd922d255e", "html_url": "https://github.com/rust-lang/rust/commit/b3e182568f9f1fdbb598e8fcc95c64dd922d255e"}], "stats": {"total": 522, "additions": 369, "deletions": 153}, "files": [{"sha": "64120f66351e6d4baea74d4af3fa4a30c5aad022", "filename": "RELEASES.txt", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/17a14fe0e9402cf0883f5957879646a9ef359769/RELEASES.txt", "raw_url": "https://github.com/rust-lang/rust/raw/17a14fe0e9402cf0883f5957879646a9ef359769/RELEASES.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/RELEASES.txt?ref=17a14fe0e9402cf0883f5957879646a9ef359769", "patch": "@@ -1,3 +1,9 @@\n+Version 0.6 (?)\n+---------------------------\n+\n+   * Libraries\n+     * `core::send_map` renamed to `core::hashmap`\n+\n Version 0.5 (December 2012)\n ---------------------------\n "}, {"sha": "88981f514cff35ee823d987dd9f75b25d6fff502", "filename": "src/libcore/hashmap.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/17a14fe0e9402cf0883f5957879646a9ef359769/src%2Flibcore%2Fhashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17a14fe0e9402cf0883f5957879646a9ef359769/src%2Flibcore%2Fhashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhashmap.rs?ref=17a14fe0e9402cf0883f5957879646a9ef359769", "patch": "@@ -49,9 +49,8 @@ pub mod linear {\n         buckets: ~[Option<Bucket<K, V>>],\n     }\n \n-    // FIXME(#3148) -- we could rewrite FoundEntry\n-    // to have type Option<&Bucket<K, V>> which would be nifty\n-    // However, that won't work until #3148 is fixed\n+    // We could rewrite FoundEntry to have type Option<&Bucket<K, V>>\n+    // which would be nifty\n     enum SearchResult {\n         FoundEntry(uint), FoundHole(uint), TableFull\n     }\n@@ -296,8 +295,6 @@ pub mod linear {\n                 FoundEntry(idx) => {\n                     match self.buckets[idx] {\n                         Some(ref bkt) => {\n-                            // FIXME(#3148)---should be inferred\n-                            let bkt: &self/Bucket<K, V> = bkt;\n                             Some(&bkt.value)\n                         }\n                         None => {"}, {"sha": "50232f99f85ab66b2611f04673d489be653edeb1", "filename": "src/libcore/rand.rs", "status": "modified", "additions": 100, "deletions": 0, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/17a14fe0e9402cf0883f5957879646a9ef359769/src%2Flibcore%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17a14fe0e9402cf0883f5957879646a9ef359769/src%2Flibcore%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frand.rs?ref=17a14fe0e9402cf0883f5957879646a9ef359769", "patch": "@@ -23,6 +23,102 @@ use uint;\n use util;\n use vec;\n \n+/// A type that can be randomly generated using an RNG\n+pub trait Rand {\n+    static fn rand(rng: rand::Rng) -> Self;\n+}\n+\n+impl int: Rand {\n+    static fn rand(rng: rand::Rng) -> int {\n+        rng.gen_int()\n+    }\n+}\n+\n+impl i8: Rand {\n+    static fn rand(rng: rand::Rng) -> i8 {\n+        rng.gen_i8()\n+    }\n+}\n+\n+impl i16: Rand {\n+    static fn rand(rng: rand::Rng) -> i16 {\n+        rng.gen_i16()\n+    }\n+}\n+\n+impl i32: Rand {\n+    static fn rand(rng: rand::Rng) -> i32 {\n+        rng.gen_i32()\n+    }\n+}\n+\n+impl i64: Rand {\n+    static fn rand(rng: rand::Rng) -> i64 {\n+        rng.gen_i64()\n+    }\n+}\n+\n+impl u8: Rand {\n+    static fn rand(rng: rand::Rng) -> u8 {\n+        rng.gen_u8()\n+    }\n+}\n+\n+impl u16: Rand {\n+    static fn rand(rng: rand::Rng) -> u16 {\n+        rng.gen_u16()\n+    }\n+}\n+\n+impl u32: Rand {\n+    static fn rand(rng: rand::Rng) -> u32 {\n+        rng.gen_u32()\n+    }\n+}\n+\n+impl u64: Rand {\n+    static fn rand(rng: rand::Rng) -> u64 {\n+        rng.gen_u64()\n+    }\n+}\n+\n+impl float: Rand {\n+    static fn rand(rng: rand::Rng) -> float {\n+        rng.gen_float()\n+    }\n+}\n+\n+impl f32: Rand {\n+    static fn rand(rng: rand::Rng) -> f32 {\n+        rng.gen_f32()\n+    }\n+}\n+\n+impl f64: Rand {\n+    static fn rand(rng: rand::Rng) -> f64 {\n+        rng.gen_f64()\n+    }\n+}\n+\n+impl char: Rand {\n+    static fn rand(rng: rand::Rng) -> char {\n+        rng.gen_char()\n+    }\n+}\n+\n+impl bool: Rand {\n+    static fn rand(rng: rand::Rng) -> bool {\n+        rng.gen_bool()\n+    }\n+}\n+\n+impl<T: Rand> Option<T>: Rand {\n+    static fn rand(rng: rand::Rng) -> Option<T> {\n+        if rng.gen_bool() { Some(Rand::rand(rng)) }\n+        else { None }\n+    }\n+}\n+\n #[allow(non_camel_case_types)] // runtime type\n enum rctx {}\n \n@@ -49,6 +145,10 @@ pub struct Weighted<T> {\n \n /// Extension methods for random number generators\n impl Rng {\n+    /// Return a random value for a Rand type\n+    fn gen<T: Rand>() -> T {\n+        Rand::rand(self)\n+    }\n \n     /// Return a random int\n     fn gen_int() -> int {"}, {"sha": "2e3967021c1d3398bf69484fe5efed26b1469a82", "filename": "src/librustc/lib/llvm.rs", "status": "modified", "additions": 19, "deletions": 14, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/17a14fe0e9402cf0883f5957879646a9ef359769/src%2Flibrustc%2Flib%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17a14fe0e9402cf0883f5957879646a9ef359769/src%2Flibrustc%2Flib%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib%2Fllvm.rs?ref=17a14fe0e9402cf0883f5957879646a9ef359769", "patch": "@@ -445,14 +445,19 @@ pub extern mod llvm {\n                                            Count: c_uint,\n                                            Packed: Bool) -> ValueRef;\n \n-    pub unsafe fn LLVMConstString(Str: *c_char, Length: c_uint,\n-                       DontNullTerminate: Bool) -> ValueRef;\n-    pub unsafe fn LLVMConstArray(ElementTy: TypeRef, ConstantVals: *ValueRef,\n-                      Length: c_uint) -> ValueRef;\n+    pub unsafe fn LLVMConstString(Str: *c_char,\n+                                  Length: c_uint,\n+                                  DontNullTerminate: Bool)\n+                               -> ValueRef;\n+    pub unsafe fn LLVMConstArray(ElementTy: TypeRef,\n+                                 ConstantVals: *ValueRef,\n+                                 Length: c_uint)\n+                              -> ValueRef;\n     pub unsafe fn LLVMConstStruct(ConstantVals: *ValueRef,\n-                       Count: c_uint, Packed: Bool) -> ValueRef;\n+                                  Count: c_uint,\n+                                  Packed: Bool) -> ValueRef;\n     pub unsafe fn LLVMConstVector(ScalarConstantVals: *ValueRef,\n-                       Size: c_uint) -> ValueRef;\n+                                  Size: c_uint) -> ValueRef;\n \n     /* Constant expressions */\n     pub unsafe fn LLVMAlignOf(Ty: TypeRef) -> ValueRef;\n@@ -463,8 +468,8 @@ pub extern mod llvm {\n     pub unsafe fn LLVMConstFNeg(ConstantVal: ValueRef) -> ValueRef;\n     pub unsafe fn LLVMConstNot(ConstantVal: ValueRef) -> ValueRef;\n     pub unsafe fn LLVMConstAdd(LHSConstant: ValueRef,\n-                           RHSConstant: ValueRef)\n-                        -> ValueRef;\n+                               RHSConstant: ValueRef)\n+                            -> ValueRef;\n     pub unsafe fn LLVMConstNSWAdd(LHSConstant: ValueRef,\n                               RHSConstant: ValueRef)\n                            -> ValueRef;\n@@ -475,14 +480,14 @@ pub extern mod llvm {\n                             RHSConstant: ValueRef)\n                          -> ValueRef;\n     pub unsafe fn LLVMConstSub(LHSConstant: ValueRef,\n-                           RHSConstant: ValueRef)\n-                        -> ValueRef;\n+                               RHSConstant: ValueRef)\n+                            -> ValueRef;\n     pub unsafe fn LLVMConstNSWSub(LHSConstant: ValueRef,\n-                              RHSConstant: ValueRef)\n-                           -> ValueRef;\n+                                  RHSConstant: ValueRef)\n+                               -> ValueRef;\n     pub unsafe fn LLVMConstNUWSub(LHSConstant: ValueRef,\n-                              RHSConstant: ValueRef)\n-                           -> ValueRef;\n+                                  RHSConstant: ValueRef)\n+                               -> ValueRef;\n     pub unsafe fn LLVMConstFSub(LHSConstant: ValueRef,\n                                 RHSConstant: ValueRef)\n                              -> ValueRef;"}, {"sha": "99b5641ac6adc315b8bbddd5c6b3135aa708b88a", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/17a14fe0e9402cf0883f5957879646a9ef359769/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17a14fe0e9402cf0883f5957879646a9ef359769/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=17a14fe0e9402cf0883f5957879646a9ef359769", "patch": "@@ -1028,6 +1028,8 @@ pub fn pick_col(m: &[@Match]) -> uint {\n pub enum branch_kind { no_branch, single, switch, compare, compare_vec_len, }\n \n // Compiles a comparison between two things.\n+//\n+// NB: This must produce an i1, not a Rust bool (i8).\n pub fn compare_values(cx: block,\n                       lhs: ValueRef,\n                       rhs: ValueRef,\n@@ -1053,7 +1055,11 @@ pub fn compare_values(cx: block,\n                                                           scratch_rhs],\n                                                         expr::SaveIn(\n                                                          scratch_result.val));\n-            return scratch_result.to_result(bcx);\n+            let result = scratch_result.to_result(bcx);\n+            Result {\n+                bcx: result.bcx,\n+                val: bool_to_i1(result.bcx, result.val)\n+            }\n         }\n         ty::ty_estr(_) => {\n             let scratch_result = scratch_datum(cx, ty::mk_bool(cx.tcx()),\n@@ -1063,7 +1069,11 @@ pub fn compare_values(cx: block,\n                                                         ~[lhs, rhs],\n                                                         expr::SaveIn(\n                                                          scratch_result.val));\n-            return scratch_result.to_result(bcx);\n+            let result = scratch_result.to_result(bcx);\n+            Result {\n+                bcx: result.bcx,\n+                val: bool_to_i1(result.bcx, result.val)\n+            }\n         }\n         _ => {\n             cx.tcx().sess.bug(~\"only scalars and strings supported in \\\n@@ -1176,6 +1186,7 @@ pub fn compile_guard(bcx: block,\n             expr::trans_to_datum(bcx, guard_expr).to_result()\n         }\n     });\n+    let val = bool_to_i1(bcx, val);\n \n     // Revoke the temp cleanups now that the guard successfully executed.\n     for temp_cleanups.each |llval| {"}, {"sha": "1c6d824eb6059c94d28d816312907131618d5a89", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 30, "deletions": 21, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/17a14fe0e9402cf0883f5957879646a9ef359769/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17a14fe0e9402cf0883f5957879646a9ef359769/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=17a14fe0e9402cf0883f5957879646a9ef359769", "patch": "@@ -137,7 +137,7 @@ pub fn log_fn_time(ccx: @crate_ctxt, +name: ~str, start: time::Timespec,\n     ccx.stats.fn_times.push({ident: name, time: elapsed});\n }\n \n-pub fn decl_fn(llmod: ModuleRef, name: ~str, cc: lib::llvm::CallConv,\n+pub fn decl_fn(llmod: ModuleRef, name: &str, cc: lib::llvm::CallConv,\n                llty: TypeRef) -> ValueRef {\n     let llfn: ValueRef = str::as_c_str(name, |buf| {\n         unsafe {\n@@ -150,7 +150,7 @@ pub fn decl_fn(llmod: ModuleRef, name: ~str, cc: lib::llvm::CallConv,\n     return llfn;\n }\n \n-pub fn decl_cdecl_fn(llmod: ModuleRef, +name: ~str, llty: TypeRef)\n+pub fn decl_cdecl_fn(llmod: ModuleRef, name: &str, llty: TypeRef)\n                   -> ValueRef {\n     return decl_fn(llmod, name, lib::llvm::CCallConv, llty);\n }\n@@ -164,20 +164,19 @@ pub fn decl_internal_cdecl_fn(llmod: ModuleRef, +name: ~str, llty: TypeRef) ->\n     return llfn;\n }\n \n-pub fn get_extern_fn(externs: HashMap<~str, ValueRef>,\n+pub fn get_extern_fn(externs: ExternMap,\n                      llmod: ModuleRef,\n-                     +name: ~str,\n+                     name: @str,\n                      cc: lib::llvm::CallConv,\n                      ty: TypeRef) -> ValueRef {\n     if externs.contains_key_ref(&name) { return externs.get(&name); }\n-    // XXX: Bad copy.\n-    let f = decl_fn(llmod, copy name, cc, ty);\n+    let f = decl_fn(llmod, name, cc, ty);\n     externs.insert(name, f);\n     return f;\n }\n \n-pub fn get_extern_const(externs: HashMap<~str, ValueRef>, llmod: ModuleRef,\n-                        +name: ~str, ty: TypeRef) -> ValueRef {\n+pub fn get_extern_const(externs: ExternMap, llmod: ModuleRef,\n+                        name: @str, ty: TypeRef) -> ValueRef {\n     unsafe {\n         if externs.contains_key_ref(&name) { return externs.get(&name); }\n         let c = str::as_c_str(name, |buf| {\n@@ -189,9 +188,9 @@ pub fn get_extern_const(externs: HashMap<~str, ValueRef>, llmod: ModuleRef,\n }\n \n     fn get_simple_extern_fn(cx: block,\n-                            externs: HashMap<~str, ValueRef>,\n+                            externs: ExternMap,\n                             llmod: ModuleRef,\n-                            +name: ~str,\n+                            name: @str,\n                             n_args: int) -> ValueRef {\n     let _icx = cx.insn_ctxt(\"get_simple_extern_fn\");\n     let ccx = cx.fcx.ccx;\n@@ -201,8 +200,8 @@ pub fn get_extern_const(externs: HashMap<~str, ValueRef>, llmod: ModuleRef,\n     return get_extern_fn(externs, llmod, name, lib::llvm::CCallConv, t);\n }\n \n-pub fn trans_foreign_call(cx: block, externs: HashMap<~str, ValueRef>,\n-                          llmod: ModuleRef, +name: ~str, args: ~[ValueRef]) ->\n+pub fn trans_foreign_call(cx: block, externs: ExternMap,\n+                          llmod: ModuleRef, name: @str, args: ~[ValueRef]) ->\n    ValueRef {\n     let _icx = cx.insn_ctxt(\"trans_foreign_call\");\n     let n = args.len() as int;\n@@ -474,6 +473,7 @@ pub fn get_res_dtor(ccx: @crate_ctxt, did: ast::def_id,\n         let class_ty = ty::subst_tps(tcx, substs, None,\n                           ty::lookup_item_type(tcx, parent_id).ty);\n         let llty = type_of_dtor(ccx, class_ty);\n+        let name = name.to_managed(); // :-(\n         get_extern_fn(ccx.externs, ccx.llmod, name, lib::llvm::CCallConv,\n                       llty)\n     }\n@@ -494,8 +494,13 @@ pub fn maybe_name_value(cx: @crate_ctxt, v: ValueRef, s: ~str) {\n // Used only for creating scalar comparison glue.\n pub enum scalar_type { nil_type, signed_int, unsigned_int, floating_point, }\n \n-pub fn compare_scalar_types(cx: block, lhs: ValueRef, rhs: ValueRef,\n-                            t: ty::t, op: ast::binop) -> Result {\n+// NB: This produces an i1, not a Rust bool (i8).\n+pub fn compare_scalar_types(cx: block,\n+                            lhs: ValueRef,\n+                            rhs: ValueRef,\n+                            t: ty::t,\n+                            op: ast::binop)\n+                         -> Result {\n     let f = |a| compare_scalar_values(cx, lhs, rhs, a, op);\n \n     match ty::get(t).sty {\n@@ -521,8 +526,12 @@ pub fn compare_scalar_types(cx: block, lhs: ValueRef, rhs: ValueRef,\n \n \n // A helper function to do the actual comparison of scalar values.\n-pub fn compare_scalar_values(cx: block, lhs: ValueRef, rhs: ValueRef,\n-                             nt: scalar_type, op: ast::binop) -> ValueRef {\n+pub fn compare_scalar_values(cx: block,\n+                             lhs: ValueRef,\n+                             rhs: ValueRef,\n+                             nt: scalar_type,\n+                             op: ast::binop)\n+                          -> ValueRef {\n     let _icx = cx.insn_ctxt(\"compare_scalar_values\");\n     fn die(cx: block) -> ! {\n         cx.tcx().sess.bug(~\"compare_scalar_values: must be a\\\n@@ -533,8 +542,8 @@ pub fn compare_scalar_values(cx: block, lhs: ValueRef, rhs: ValueRef,\n         // We don't need to do actual comparisons for nil.\n         // () == () holds but () < () does not.\n         match op {\n-          ast::eq | ast::le | ast::ge => return C_bool(true),\n-          ast::ne | ast::lt | ast::gt => return C_bool(false),\n+          ast::eq | ast::le | ast::ge => return C_i1(true),\n+          ast::ne | ast::lt | ast::gt => return C_i1(false),\n           // refinements would be nice\n           _ => die(cx)\n         }\n@@ -766,7 +775,7 @@ pub fn null_env_ptr(bcx: block) -> ValueRef {\n \n pub fn trans_external_path(ccx: @crate_ctxt, did: ast::def_id, t: ty::t)\n     -> ValueRef {\n-    let name = csearch::get_symbol(ccx.sess.cstore, did);\n+    let name = csearch::get_symbol(ccx.sess.cstore, did).to_managed(); // Sad\n     match ty::get(t).sty {\n       ty::ty_fn(_) => {\n         let llty = type_of_fn_from_ty(ccx, t);\n@@ -1442,7 +1451,7 @@ pub fn call_memcpy(cx: block, dst: ValueRef, src: ValueRef,\n     let dst_ptr = PointerCast(cx, dst, T_ptr(T_i8()));\n     let size = IntCast(cx, n_bytes, ccx.int_type);\n     let align = C_i32(1i32);\n-    let volatile = C_bool(false);\n+    let volatile = C_i1(false);\n     Call(cx, memcpy, ~[dst_ptr, src_ptr, size, align, volatile]);\n }\n \n@@ -1489,7 +1498,7 @@ pub fn memzero(cx: block, llptr: ValueRef, llty: TypeRef) {\n     let llzeroval = C_u8(0);\n     let size = IntCast(cx, machine::llsize_of(ccx, llty), ccx.int_type);\n     let align = C_i32(1i32);\n-    let volatile = C_bool(false);\n+    let volatile = C_i1(false);\n     Call(cx, llintrinsicfn, ~[llptr, llzeroval, size, align, volatile]);\n }\n "}, {"sha": "4bd5ae969f206dc4dadaf0c86c5d8dbc776ff881", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/17a14fe0e9402cf0883f5957879646a9ef359769/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17a14fe0e9402cf0883f5957879646a9ef359769/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=17a14fe0e9402cf0883f5957879646a9ef359769", "patch": "@@ -438,7 +438,9 @@ pub fn trans_call_inner(\n             let flag = alloca(bcx, T_bool());\n             Store(bcx, C_bool(false), flag);\n             Some(flag)\n-        } else { None };\n+        } else {\n+            None\n+        };\n \n         let (llfn, llenv) = unsafe {\n             match callee.data {\n@@ -506,7 +508,8 @@ pub fn trans_call_inner(\n         if ty::type_is_bot(ret_ty) {\n             Unreachable(bcx);\n         } else if ret_in_loop {\n-            bcx = do with_cond(bcx, Load(bcx, ret_flag.get())) |bcx| {\n+            let ret_flag_result = bool_to_i1(bcx, Load(bcx, ret_flag.get()));\n+            bcx = do with_cond(bcx, ret_flag_result) |bcx| {\n                 do option::iter(&copy bcx.fcx.loop_ret) |lret| {\n                     Store(bcx, C_bool(true), lret.flagptr);\n                     Store(bcx, C_bool(false), bcx.fcx.llretptr);"}, {"sha": "f12bb0eb0a647c8a3725bec4d2fe166904200c2c", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/17a14fe0e9402cf0883f5957879646a9ef359769/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17a14fe0e9402cf0883f5957879646a9ef359769/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=17a14fe0e9402cf0883f5957879646a9ef359769", "patch": "@@ -152,13 +152,15 @@ pub fn BuilderRef_res(B: BuilderRef) -> BuilderRef_res {\n     }\n }\n \n+type ExternMap = HashMap<@str, ValueRef>;\n+\n // Crate context.  Every crate we compile has one of these.\n pub struct crate_ctxt {\n      sess: session::Session,\n      llmod: ModuleRef,\n      td: target_data,\n      tn: type_names,\n-     externs: HashMap<~str, ValueRef>,\n+     externs: ExternMap,\n      intrinsics: HashMap<~str, ValueRef>,\n      item_vals: HashMap<ast::node_id, ValueRef>,\n      exp_map2: resolve::ExportMap2,\n@@ -759,7 +761,7 @@ pub fn T_f32() -> TypeRef { unsafe { return llvm::LLVMFloatType(); } }\n \n pub fn T_f64() -> TypeRef { unsafe { return llvm::LLVMDoubleType(); } }\n \n-pub fn T_bool() -> TypeRef { return T_i1(); }\n+pub fn T_bool() -> TypeRef { return T_i8(); }\n \n pub fn T_int(targ_cfg: @session::config) -> TypeRef {\n     return match targ_cfg.arch {\n@@ -1109,6 +1111,10 @@ pub fn C_bool(b: bool) -> ValueRef {\n     C_integral(T_bool(), if b { 1u64 } else { 0u64 }, False)\n }\n \n+pub fn C_i1(b: bool) -> ValueRef {\n+    return C_integral(T_i1(), if b { 1 } else { 0 }, False);\n+}\n+\n pub fn C_i32(i: i32) -> ValueRef {\n     return C_integral(T_i32(), i as u64, True);\n }\n@@ -1435,6 +1441,11 @@ pub fn struct_dtor() -> [uint * 2] {\n     [0, 1]\n }\n \n+// Casts a Rust bool value to an i1.\n+pub fn bool_to_i1(bcx: block, llval: ValueRef) -> ValueRef {\n+    build::ICmp(bcx, lib::llvm::IntNE, llval, C_bool(false))\n+}\n+\n //\n // Local Variables:\n // mode: rust"}, {"sha": "34f1f1f2314fb8b8ce3d306e6c848d78d718306e", "filename": "src/librustc/middle/trans/consts.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/17a14fe0e9402cf0883f5957879646a9ef359769/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17a14fe0e9402cf0883f5957879646a9ef359769/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs?ref=17a14fe0e9402cf0883f5957879646a9ef359769", "patch": "@@ -204,7 +204,18 @@ pub fn const_expr(cx: @crate_ctxt, e: @ast::expr) -> ValueRef {\n               ast::box(_)  |\n               ast::uniq(_) |\n               ast::deref  => const_deref(cx, te),\n-              ast::not    => llvm::LLVMConstNot(te),\n+              ast::not    => {\n+                match ty::get(ty).sty {\n+                    ty::ty_bool => {\n+                        // Somewhat questionable, but I believe this is\n+                        // correct.\n+                        let te = llvm::LLVMConstTrunc(te, T_i1());\n+                        let te = llvm::LLVMConstNot(te);\n+                        llvm::LLVMConstZExt(te, T_bool())\n+                    }\n+                    _ => llvm::LLVMConstNot(te),\n+                }\n+              }\n               ast::neg    => {\n                 if is_float { llvm::LLVMConstFNeg(te) }\n                 else        { llvm::LLVMConstNeg(te) }"}, {"sha": "a1505dd2f11c3b7b57d09b03e5c78d6e882dab8d", "filename": "src/librustc/middle/trans/controlflow.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/17a14fe0e9402cf0883f5957879646a9ef359769/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17a14fe0e9402cf0883f5957879646a9ef359769/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs?ref=17a14fe0e9402cf0883f5957879646a9ef359769", "patch": "@@ -62,6 +62,8 @@ pub fn trans_if(bcx: block,\n \n     let then_bcx_in = scope_block(bcx, thn.info(), ~\"then\");\n     let else_bcx_in = scope_block(bcx, els.info(), ~\"else\");\n+\n+    let cond_val = bool_to_i1(bcx, cond_val);\n     CondBr(bcx, cond_val, then_bcx_in.llbb, else_bcx_in.llbb);\n \n     debug!(\"then_bcx_in=%s, else_bcx_in=%s\",\n@@ -139,6 +141,7 @@ pub fn trans_while(bcx: block, cond: @ast::expr, body: ast::blk) -> block {\n     // compile the condition\n     let Result {bcx: cond_bcx_out, val: cond_val} =\n         expr::trans_to_datum(cond_bcx_in, cond).to_result();\n+    let cond_val = bool_to_i1(cond_bcx_out, cond_val);\n     let cond_bcx_out =\n         trans_block_cleanups(cond_bcx_out, block_cleanups(cond_bcx_in));\n     CondBr(cond_bcx_out, cond_val, body_bcx_in.llbb, next_bcx.llbb);\n@@ -324,6 +327,7 @@ pub fn trans_check_expr(bcx: block,\n             expr::trans_to_datum(bcx, pred_expr).to_result()\n         }\n     };\n+    let val = bool_to_i1(bcx, val);\n     do with_cond(bcx, Not(bcx, val)) |bcx| {\n         trans_fail(bcx, Some(pred_expr.span), /*bad*/copy expr_str)\n     }"}, {"sha": "ff842b5b4bed0c97be1132585506c6928e88f525", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/17a14fe0e9402cf0883f5957879646a9ef359769/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17a14fe0e9402cf0883f5957879646a9ef359769/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=17a14fe0e9402cf0883f5957879646a9ef359769", "patch": "@@ -77,7 +77,7 @@ fn lli64(val: int) -> ValueRef {\n     C_i64(val as i64)\n }\n fn lli1(bval: bool) -> ValueRef {\n-    C_bool(bval)\n+    C_i1(bval)\n }\n fn llmdnode(elems: ~[ValueRef]) -> ValueRef {\n     unsafe {"}, {"sha": "61204fe4e07e0416f23d46530b8ad352b019ae74", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 23, "deletions": 9, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/17a14fe0e9402cf0883f5957879646a9ef359769/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17a14fe0e9402cf0883f5957879646a9ef359769/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=17a14fe0e9402cf0883f5957879646a9ef359769", "patch": "@@ -1236,7 +1236,6 @@ fn trans_unary_datum(bcx: block,\n                      un_expr: @ast::expr,\n                      op: ast::unop,\n                      sub_expr: @ast::expr) -> DatumBlock {\n-\n     let _icx = bcx.insn_ctxt(\"trans_unary_datum\");\n \n     // if deref, would be LvalueExpr\n@@ -1251,7 +1250,21 @@ fn trans_unary_datum(bcx: block,\n     return match op {\n         ast::not => {\n             let Result {bcx, val} = trans_to_datum(bcx, sub_expr).to_result();\n-            immediate_rvalue_bcx(bcx, Not(bcx, val), un_ty)\n+\n+            // If this is a boolean type, we must not use the LLVM Not\n+            // instruction, as that is a *bitwise* not and we want *logical*\n+            // not on our 8-bit boolean values.\n+            let llresult = match ty::get(un_ty).sty {\n+                ty::ty_bool => {\n+                    let llcond = ICmp(bcx,\n+                                      lib::llvm::IntEQ,\n+                                      val,\n+                                      C_bool(false));\n+                    Select(bcx, llcond, C_bool(true), C_bool(false))\n+                }\n+                _ => Not(bcx, val)\n+            };\n+            immediate_rvalue_bcx(bcx, llresult, un_ty)\n         }\n         ast::neg => {\n             let Result {bcx, val} = trans_to_datum(bcx, sub_expr).to_result();\n@@ -1308,8 +1321,8 @@ fn trans_eager_binop(bcx: block,\n                      binop_ty: ty::t,\n                      op: ast::binop,\n                      lhs_datum: &Datum,\n-                     rhs_datum: &Datum) -> DatumBlock\n-{\n+                     rhs_datum: &Datum)\n+                  -> DatumBlock {\n     let mut bcx = bcx;\n     let _icx = bcx.insn_ctxt(\"trans_eager_binop\");\n \n@@ -1388,7 +1401,7 @@ fn trans_eager_binop(bcx: block,\n             }\n             let cmpr = base::compare_scalar_types(bcx, lhs, rhs, rhs_t, op);\n             bcx = cmpr.bcx;\n-            cmpr.val\n+            ZExt(bcx, cmpr.val, T_i8())\n         }\n       }\n       _ => {\n@@ -1406,8 +1419,7 @@ fn trans_lazy_binop(bcx: block,\n                     binop_expr: @ast::expr,\n                     op: lazy_binop_ty,\n                     a: @ast::expr,\n-                    b: @ast::expr) -> DatumBlock\n-{\n+                    b: @ast::expr) -> DatumBlock {\n     let _icx = bcx.insn_ctxt(\"trans_lazy_binop\");\n     let binop_ty = expr_ty(bcx, binop_expr);\n     let mut bcx = bcx;\n@@ -1425,10 +1437,12 @@ fn trans_lazy_binop(bcx: block,\n     let join = base::sub_block(bcx, ~\"join\");\n     let before_rhs = base::sub_block(bcx, ~\"rhs\");\n \n+    let lhs_i1 = bool_to_i1(past_lhs, lhs);\n     match op {\n-      lazy_and => CondBr(past_lhs, lhs, before_rhs.llbb, join.llbb),\n-      lazy_or => CondBr(past_lhs, lhs, join.llbb, before_rhs.llbb)\n+      lazy_and => CondBr(past_lhs, lhs_i1, before_rhs.llbb, join.llbb),\n+      lazy_or => CondBr(past_lhs, lhs_i1, join.llbb, before_rhs.llbb)\n     }\n+\n     let Result {bcx: past_rhs, val: rhs} = {\n         do base::with_scope_result(before_rhs, b.info(), ~\"rhs\") |bcx| {\n             trans_to_datum(bcx, b).to_result()"}, {"sha": "ae05ceb1ec57059f2738edd0572576d7f44e3c8e", "filename": "src/librustc/middle/trans/foreign.rs", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/17a14fe0e9402cf0883f5957879646a9ef359769/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17a14fe0e9402cf0883f5957879646a9ef359769/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=17a14fe0e9402cf0883f5957879646a9ef359769", "patch": "@@ -524,7 +524,8 @@ pub fn trans_intrinsic(ccx: @crate_ctxt,\n         }\n         ~\"needs_drop\" => {\n             let tp_ty = substs.tys[0];\n-            Store(bcx, C_bool(ty::type_needs_drop(ccx.tcx, tp_ty)),\n+            Store(bcx,\n+                  C_bool(ty::type_needs_drop(ccx.tcx, tp_ty)),\n                   fcx.llretptr);\n         }\n         ~\"visit_tydesc\" => {\n@@ -574,7 +575,7 @@ pub fn trans_intrinsic(ccx: @crate_ctxt,\n             let src_ptr = get_param(decl, first_real_arg + 1);\n             let size = get_param(decl, first_real_arg + 2);\n             let align = C_i32(1);\n-            let volatile = C_bool(false);\n+            let volatile = C_i1(false);\n             let llfn = bcx.ccx().intrinsics.get(\n                 &~\"llvm.memmove.p0i8.p0i8.i32\");\n             Call(bcx, llfn, ~[dst_ptr, src_ptr, size, align, volatile]);\n@@ -584,7 +585,7 @@ pub fn trans_intrinsic(ccx: @crate_ctxt,\n             let src_ptr = get_param(decl, first_real_arg + 1);\n             let size = get_param(decl, first_real_arg + 2);\n             let align = C_i32(1);\n-            let volatile = C_bool(false);\n+            let volatile = C_i1(false);\n             let llfn = bcx.ccx().intrinsics.get(\n                 &~\"llvm.memmove.p0i8.p0i8.i64\");\n             Call(bcx, llfn, ~[dst_ptr, src_ptr, size, align, volatile]);\n@@ -769,49 +770,49 @@ pub fn trans_intrinsic(ccx: @crate_ctxt,\n         }\n         ~\"ctlz8\" => {\n             let x = get_param(decl, first_real_arg);\n-            let y = C_bool(false);\n+            let y = C_i1(false);\n             let ctlz = ccx.intrinsics.get(&~\"llvm.ctlz.i8\");\n             Store(bcx, Call(bcx, ctlz, ~[x, y]), fcx.llretptr)\n         }\n         ~\"ctlz16\" => {\n             let x = get_param(decl, first_real_arg);\n-            let y = C_bool(false);\n+            let y = C_i1(false);\n             let ctlz = ccx.intrinsics.get(&~\"llvm.ctlz.i16\");\n             Store(bcx, Call(bcx, ctlz, ~[x, y]), fcx.llretptr)\n         }\n         ~\"ctlz32\" => {\n             let x = get_param(decl, first_real_arg);\n-            let y = C_bool(false);\n+            let y = C_i1(false);\n             let ctlz = ccx.intrinsics.get(&~\"llvm.ctlz.i32\");\n             Store(bcx, Call(bcx, ctlz, ~[x, y]), fcx.llretptr)\n         }\n         ~\"ctlz64\" => {\n             let x = get_param(decl, first_real_arg);\n-            let y = C_bool(false);\n+            let y = C_i1(false);\n             let ctlz = ccx.intrinsics.get(&~\"llvm.ctlz.i64\");\n             Store(bcx, Call(bcx, ctlz, ~[x, y]), fcx.llretptr)\n         }\n         ~\"cttz8\" => {\n             let x = get_param(decl, first_real_arg);\n-            let y = C_bool(false);\n+            let y = C_i1(false);\n             let cttz = ccx.intrinsics.get(&~\"llvm.cttz.i8\");\n             Store(bcx, Call(bcx, cttz, ~[x, y]), fcx.llretptr)\n         }\n         ~\"cttz16\" => {\n             let x = get_param(decl, first_real_arg);\n-            let y = C_bool(false);\n+            let y = C_i1(false);\n             let cttz = ccx.intrinsics.get(&~\"llvm.cttz.i16\");\n             Store(bcx, Call(bcx, cttz, ~[x, y]), fcx.llretptr)\n         }\n         ~\"cttz32\" => {\n             let x = get_param(decl, first_real_arg);\n-            let y = C_bool(false);\n+            let y = C_i1(false);\n             let cttz = ccx.intrinsics.get(&~\"llvm.cttz.i32\");\n             Store(bcx, Call(bcx, cttz, ~[x, y]), fcx.llretptr)\n         }\n         ~\"cttz64\" => {\n             let x = get_param(decl, first_real_arg);\n-            let y = C_bool(false);\n+            let y = C_i1(false);\n             let cttz = ccx.intrinsics.get(&~\"llvm.cttz.i64\");\n             Store(bcx, Call(bcx, cttz, ~[x, y]), fcx.llretptr)\n         }"}, {"sha": "7380fa2e562693087759549520cc308d425ee3b0", "filename": "src/librustc/middle/trans/reflect.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/17a14fe0e9402cf0883f5957879646a9ef359769/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17a14fe0e9402cf0883f5957879646a9ef359769/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs?ref=17a14fe0e9402cf0883f5957879646a9ef359769", "patch": "@@ -109,6 +109,7 @@ pub impl reflector {\n                                                         ast::m_imm)),\n             ArgVals(args), SaveIn(scratch.val), DontAutorefArg);\n         let result = scratch.to_value_llval(bcx);\n+        let result = bool_to_i1(bcx, result);\n         let next_bcx = sub_block(bcx, ~\"next\");\n         CondBr(bcx, result, next_bcx.llbb, self.final_bcx.llbb);\n         self.bcx = next_bcx"}, {"sha": "13b58c433006ef82fa066332a6700a59dc6a19d6", "filename": "src/libstd/json.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/17a14fe0e9402cf0883f5957879646a9ef359769/src%2Flibstd%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17a14fe0e9402cf0883f5957879646a9ef359769/src%2Flibstd%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fjson.rs?ref=17a14fe0e9402cf0883f5957879646a9ef359769", "patch": "@@ -856,9 +856,6 @@ pub impl Decoder: serialize::Decoder {\n         debug!(\"read_vec_elt(idx=%u)\", idx);\n         match *self.peek() {\n             List(ref list) => {\n-                // FIXME(#3148)---should be inferred\n-                let list: &self/~[Json] = list;\n-\n                 self.stack.push(&list[idx]);\n                 f()\n             }\n@@ -885,9 +882,6 @@ pub impl Decoder: serialize::Decoder {\n         let top = self.peek();\n         match *top {\n             Object(ref obj) => {\n-                // FIXME(#3148) This hint should not be necessary.\n-                let obj: &self/~Object = obj;\n-\n                 match obj.find(&name.to_owned()) {\n                     None => die!(fmt!(\"no such field: %s\", name)),\n                     Some(json) => {\n@@ -917,8 +911,6 @@ pub impl Decoder: serialize::Decoder {\n         debug!(\"read_tup_elt(idx=%u)\", idx);\n         match *self.peek() {\n             List(ref list) => {\n-                // FIXME(#3148)---should be inferred\n-                let list: &self/~[Json] = list;\n                 self.stack.push(&list[idx]);\n                 f()\n             }"}, {"sha": "1cd35722ab466655d9a76b5147bdf89d9066553c", "filename": "src/libstd/smallintmap.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/17a14fe0e9402cf0883f5957879646a9ef359769/src%2Flibstd%2Fsmallintmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17a14fe0e9402cf0883f5957879646a9ef359769/src%2Flibstd%2Fsmallintmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsmallintmap.rs?ref=17a14fe0e9402cf0883f5957879646a9ef359769", "patch": "@@ -116,8 +116,6 @@ pub impl<V> SmallIntMap<V> {\n }\n \n pub impl<V: Copy> SmallIntMap<V> {\n-    // FIXME: #4733, remove after the next snapshot\n-    #[cfg(stage2)]\n     fn update_with_key(&mut self, key: uint, val: V,\n                        ff: fn(uint, V, V) -> V) -> bool {\n         match self.find(&key) {\n@@ -126,8 +124,6 @@ pub impl<V: Copy> SmallIntMap<V> {\n         }\n     }\n \n-    // FIXME: #4733, remove after the next snapshot\n-    #[cfg(stage2)]\n     fn update(&mut self, key: uint, newval: V, ff: fn(V, V) -> V) -> bool {\n         self.update_with_key(key, newval, |_k, v, v1| ff(v,v1))\n     }"}, {"sha": "3cc287b16a32eab2d074e70a72e708916f06f1ce", "filename": "src/libstd/treemap.rs", "status": "modified", "additions": 70, "deletions": 73, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/17a14fe0e9402cf0883f5957879646a9ef359769/src%2Flibstd%2Ftreemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17a14fe0e9402cf0883f5957879646a9ef359769/src%2Flibstd%2Ftreemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftreemap.rs?ref=17a14fe0e9402cf0883f5957879646a9ef359769", "patch": "@@ -49,8 +49,8 @@ impl <K: Eq Ord, V: Eq> TreeMap<K, V>: Eq {\n             let mut y = other.iter();\n             for self.len().times {\n                 unsafe { // unsafe as a purity workaround\n-                    x = x.next();\n-                    y = y.next();\n+                    map_next(&mut x);\n+                    map_next(&mut y);\n                     // FIXME: #4492 (ICE), x.get() == y.get()\n                     let (x1, x2) = x.get().unwrap();\n                     let (y1, y2) = y.get().unwrap();\n@@ -74,8 +74,8 @@ pure fn lt<K: Ord, V>(a: &TreeMap<K, V>, b: &TreeMap<K, V>) -> bool {\n     let (a_len, b_len) = (a.len(), b.len());\n     for uint::min(a_len, b_len).times {\n         unsafe { // purity workaround\n-            x = x.next();\n-            y = y.next();\n+            map_next(&mut x);\n+            map_next(&mut y);\n             let (key_a,_) = x.get().unwrap();\n             let (key_b,_) = y.get().unwrap();\n             if *key_a < *key_b { return true; }\n@@ -142,7 +142,6 @@ impl <K: Ord, V> TreeMap<K, V>: Map<K, V> {\n         loop {\n             match *current {\n               Some(ref r) => {\n-                let r: &self/~TreeNode<K, V> = r; // FIXME: #3148\n                 if *key < r.key {\n                     current = &r.left;\n                 } else if r.key < *key {\n@@ -211,32 +210,30 @@ impl <K: Ord, V> TreeMapIterator<K, V> {\n     // Returns the current node, or None if this iterator is at the end.\n     fn get(&const self) -> Option<(&self/K, &self/V)> {\n         match self.current {\n-            Some(res) => Some((&res.key, &res.value)),\n-            None => None\n+          Some(res) => Some((&res.key, &res.value)),\n+          None => None\n         }\n     }\n+}\n \n-    /// Advance the iterator to the next node (in order). If this iterator\n-    /// is finished, does nothing.\n-    fn next(self) -> TreeMapIterator/&self<K, V> {\n-        let mut this = self;\n-        while !this.stack.is_empty() || this.node.is_some() {\n-            match *this.node {\n-              Some(ref x) => {\n-                this.stack.push(x);\n-                this.node = &x.left;\n-              }\n-              None => {\n-                let res = this.stack.pop();\n-                this.node = &res.right;\n-                this.current = Some(res);\n-                return this;\n-              }\n-            }\n+/// Advance the iterator to the next node (in order). If this iterator\n+/// is finished, does nothing.\n+pub fn map_next<K: Ord, V>(iter: &mut TreeMapIterator/&a<K, V>) {\n+    while !iter.stack.is_empty() || iter.node.is_some() {\n+        match *iter.node {\n+          Some(ref x) => {\n+            iter.stack.push(x);\n+            iter.node = &x.left;\n+          }\n+          None => {\n+            let res = iter.stack.pop();\n+            iter.node = &res.right;\n+            iter.current = Some(res);\n+            return;\n+          }\n         }\n-        this.current = None;\n-        return this;\n     }\n+    iter.current = None;\n }\n \n pub struct TreeSet<T> {\n@@ -298,18 +295,18 @@ impl <T: Ord> TreeSet<T>: Set<T> {\n         let mut x = self.iter();\n         let mut y = other.iter();\n         unsafe { // purity workaround\n-            x = x.next();\n-            y = y.next();\n+            set_next(&mut x);\n+            set_next(&mut y);\n             let mut a = x.get();\n             let mut b = y.get();\n             while a.is_some() && b.is_some() {\n                 let a1 = a.unwrap();\n                 let b1 = b.unwrap();\n                 if a1 < b1 {\n-                    x = x.next();\n+                    set_next(&mut x);\n                     a = x.get();\n                 } else if b1 < a1 {\n-                    y = y.next();\n+                    set_next(&mut y);\n                     b = y.get();\n                 } else {\n                     return false;\n@@ -329,8 +326,8 @@ impl <T: Ord> TreeSet<T>: Set<T> {\n         let mut x = self.iter();\n         let mut y = other.iter();\n         unsafe { // purity workaround\n-            x = x.next();\n-            y = y.next();\n+            set_next(&mut x);\n+            set_next(&mut y);\n             let mut a = x.get();\n             let mut b = y.get();\n             while b.is_some() {\n@@ -346,10 +343,10 @@ impl <T: Ord> TreeSet<T>: Set<T> {\n                 }\n \n                 if !(a1 < b1) {\n-                    y = y.next();\n+                    set_next(&mut y);\n                     b = y.get();\n                 }\n-                x = x.next();\n+                set_next(&mut x);\n                 a = x.get();\n             }\n         }\n@@ -362,15 +359,15 @@ impl <T: Ord> TreeSet<T>: Set<T> {\n         let mut y = other.iter();\n \n         unsafe { // purity workaround\n-            x = x.next();\n-            y = y.next();\n+            set_next(&mut x);\n+            set_next(&mut y);\n             let mut a = x.get();\n             let mut b = y.get();\n \n             while a.is_some() {\n                 if b.is_none() {\n                     return do a.while_some() |a1| {\n-                        if f(a1) { x = x.next(); x.get() } else { None }\n+                        if f(a1) { set_next(&mut x); x.get() } else { None }\n                     }\n                 }\n \n@@ -379,11 +376,11 @@ impl <T: Ord> TreeSet<T>: Set<T> {\n \n                 if a1 < b1 {\n                     if !f(a1) { return }\n-                    x = x.next();\n+                    set_next(&mut x);\n                     a = x.get();\n                 } else {\n-                    if !(b1 < a1) { x = x.next(); a = x.get() }\n-                    y = y.next();\n+                    if !(b1 < a1) { set_next(&mut x); a = x.get() }\n+                    set_next(&mut y);\n                     b = y.get();\n                 }\n             }\n@@ -397,15 +394,15 @@ impl <T: Ord> TreeSet<T>: Set<T> {\n         let mut y = other.iter();\n \n         unsafe { // purity workaround\n-            x = x.next();\n-            y = y.next();\n+            set_next(&mut x);\n+            set_next(&mut y);\n             let mut a = x.get();\n             let mut b = y.get();\n \n             while a.is_some() {\n                 if b.is_none() {\n                     return do a.while_some() |a1| {\n-                        if f(a1) { x.next(); x.get() } else { None }\n+                        if f(a1) { set_next(&mut x); x.get() } else { None }\n                     }\n                 }\n \n@@ -414,21 +411,21 @@ impl <T: Ord> TreeSet<T>: Set<T> {\n \n                 if a1 < b1 {\n                     if !f(a1) { return }\n-                    x = x.next();\n+                    set_next(&mut x);\n                     a = x.get();\n                 } else {\n                     if b1 < a1 {\n                         if !f(b1) { return }\n                     } else {\n-                        x = x.next();\n+                        set_next(&mut x);\n                         a = x.get();\n                     }\n-                    y = y.next();\n+                    set_next(&mut y);\n                     b = y.get();\n                 }\n             }\n             do b.while_some |b1| {\n-                if f(b1) { y = y.next(); y.get() } else { None }\n+                if f(b1) { set_next(&mut y); y.get() } else { None }\n             }\n         }\n     }\n@@ -439,22 +436,22 @@ impl <T: Ord> TreeSet<T>: Set<T> {\n         let mut y = other.iter();\n \n         unsafe { // purity workaround\n-            x = x.next();\n-            y = y.next();\n+            set_next(&mut x);\n+            set_next(&mut y);\n             let mut a = x.get();\n             let mut b = y.get();\n \n             while a.is_some() && b.is_some() {\n                 let a1 = a.unwrap();\n                 let b1 = b.unwrap();\n                 if a1 < b1 {\n-                    x = x.next();\n+                    set_next(&mut x);\n                     a = x.get();\n                 } else {\n                     if !(b1 < a1) {\n                         if !f(a1) { return }\n                     }\n-                    y = y.next();\n+                    set_next(&mut y);\n                     b = y.get();\n                 }\n             }\n@@ -467,15 +464,15 @@ impl <T: Ord> TreeSet<T>: Set<T> {\n         let mut y = other.iter();\n \n         unsafe { // purity workaround\n-            x = x.next();\n-            y = y.next();\n+            set_next(&mut x);\n+            set_next(&mut y);\n             let mut a = x.get();\n             let mut b = y.get();\n \n             while a.is_some() {\n                 if b.is_none() {\n                     return do a.while_some() |a1| {\n-                        if f(a1) { x = x.next(); x.get() } else { None }\n+                        if f(a1) { set_next(&mut x); x.get() } else { None }\n                     }\n                 }\n \n@@ -484,15 +481,15 @@ impl <T: Ord> TreeSet<T>: Set<T> {\n \n                 if b1 < a1 {\n                     if !f(b1) { return }\n-                    y = y.next();\n+                    set_next(&mut y);\n                     b = y.get();\n                 } else {\n                     if !f(a1) { return }\n                     if !(a1 < b1) {\n-                        y = y.next();\n+                        set_next(&mut y);\n                         b = y.get()\n                     }\n-                    x = x.next();\n+                    set_next(&mut x);\n                     a = x.get();\n                 }\n             }\n@@ -525,16 +522,16 @@ impl <T: Ord> TreeSetIterator<T> {\n     /// Returns the current node, or None if this iterator is at the end.\n     fn get(&const self) -> Option<&self/T> {\n         match self.iter.get() {\n-            None => None,\n-            Some((k, _)) => Some(k)\n+          None => None,\n+          Some((k, _)) => Some(k)\n         }\n     }\n+}\n \n-    /// Advance the iterator to the next node (in order). If this iterator is\n-    /// finished, does nothing.\n-    fn next(self) -> TreeSetIterator/&self<T> {\n-        TreeSetIterator { iter: self.iter.next() }\n-    }\n+/// Advance the iterator to the next node (in order). If this iterator is\n+/// finished, does nothing.\n+pub fn set_next<T: Ord>(iter: &mut TreeSetIterator/&a<T>) {\n+    map_next(&mut iter.iter);\n }\n \n // Nodes keep track of their level in the tree, starting at 1 in the\n@@ -746,8 +743,8 @@ mod test_treemap {\n         let v1 = str::to_bytes(~\"baz\");\n         let v2 = str::to_bytes(~\"foobar\");\n \n-        m.insert(k1, v1);\n-        m.insert(k2, v2);\n+        m.insert(copy k1, copy v1);\n+        m.insert(copy k2, copy v2);\n \n         assert m.find(&k2) == Some(&v2);\n         assert m.find(&k1) == Some(&v1);\n@@ -966,20 +963,20 @@ mod test_treemap {\n         let m = m;\n         let mut iter = m.iter();\n \n-        // FIXME: #4492 (ICE): iter.next() == Some((&x1, &y1))\n+        // FIXME: #4492 (ICE): iter.get() == Some((&x1, &y1))\n \n-        iter = iter.next();\n+        map_next(&mut iter);\n         assert iter.get().unwrap() == (&x1, &y1);\n-        iter = iter.next();\n+        map_next(&mut iter);\n         assert iter.get().unwrap() == (&x2, &y2);\n-        iter = iter.next();\n+        map_next(&mut iter);\n         assert iter.get().unwrap() == (&x3, &y3);\n-        iter = iter.next();\n+        map_next(&mut iter);\n         assert iter.get().unwrap() == (&x4, &y4);\n-        iter = iter.next();\n+        map_next(&mut iter);\n         assert iter.get().unwrap() == (&x5, &y5);\n \n-        iter = iter.next();\n+        map_next(&mut iter);\n         assert iter.get().is_none();\n     }\n }"}, {"sha": "0f672d1de81fdb9a4cc15bea86787f898fe06ad8", "filename": "src/libsyntax/parse/lexer.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/17a14fe0e9402cf0883f5957879646a9ef359769/src%2Flibsyntax%2Fparse%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17a14fe0e9402cf0883f5957879646a9ef359769/src%2Flibsyntax%2Fparse%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer.rs?ref=17a14fe0e9402cf0883f5957879646a9ef359769", "patch": "@@ -431,6 +431,13 @@ fn scan_number(c: char, rdr: string_reader) -> token::Token {\n         let dec_part = scan_digits(rdr, 10u);\n         num_str += ~\".\" + dec_part;\n     }\n+    if is_float {\n+        match base {\n+          16u => rdr.fatal(~\"hexadecimal float literal is not supported\"),\n+          2u => rdr.fatal(~\"binary float literal is not supported\"),\n+          _ => ()\n+        }\n+    }\n     match scan_exponent(rdr) {\n       Some(ref s) => {\n         is_float = true;"}, {"sha": "e72b73f8fa4c6836efa40130f809d1fc83d5764d", "filename": "src/test/compile-fail/issue-4523.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/17a14fe0e9402cf0883f5957879646a9ef359769/src%2Ftest%2Fcompile-fail%2Fissue-4523.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17a14fe0e9402cf0883f5957879646a9ef359769/src%2Ftest%2Fcompile-fail%2Fissue-4523.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-4523.rs?ref=17a14fe0e9402cf0883f5957879646a9ef359769", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn foopy() {}\n+\n+const f: fn() = foopy; //~ ERROR mismatched types: expected `&static/fn()`\n+\n+fn main () {\n+    f();\n+}\n\\ No newline at end of file"}, {"sha": "0fa61b1af52ef404ddd68f9939c33c199b921e3b", "filename": "src/test/compile-fail/no-binary-float-literal.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/17a14fe0e9402cf0883f5957879646a9ef359769/src%2Ftest%2Fcompile-fail%2Fno-binary-float-literal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17a14fe0e9402cf0883f5957879646a9ef359769/src%2Ftest%2Fcompile-fail%2Fno-binary-float-literal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fno-binary-float-literal.rs?ref=17a14fe0e9402cf0883f5957879646a9ef359769", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// error-pattern:binary float literal is not supported\n+\n+fn main() {\n+    0b101010f;\n+    0b101.010;\n+    0b101p4f;\n+}"}, {"sha": "4abb6093b2443a221fb691aeed8f9ada8a2c0250", "filename": "src/test/compile-fail/no-hex-float-literal.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/17a14fe0e9402cf0883f5957879646a9ef359769/src%2Ftest%2Fcompile-fail%2Fno-hex-float-literal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17a14fe0e9402cf0883f5957879646a9ef359769/src%2Ftest%2Fcompile-fail%2Fno-hex-float-literal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fno-hex-float-literal.rs?ref=17a14fe0e9402cf0883f5957879646a9ef359769", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// error-pattern:hexadecimal float literal is not supported\n+\n+fn main() {\n+    0xABC.Df;\n+    0x567.89;\n+    0xDEAD.BEEFp-2f;\n+}"}]}