{"sha": "4e07864f591c76265639725762b3b6ad9e9d8bb1", "node_id": "C_kwDOAAsO6NoAKDRlMDc4NjRmNTkxYzc2MjY1NjM5NzI1NzYyYjNiNmFkOWU5ZDhiYjE", "commit": {"author": {"name": "Jonas Schievink", "email": "jonas.schievink@ferrous-systems.com", "date": "2022-03-22T15:44:27Z"}, "committer": {"name": "Jonas Schievink", "email": "jonas.schievink@ferrous-systems.com", "date": "2022-03-22T15:44:27Z"}, "message": "signature help: skip lifetimes when non-lifetime arguments are present", "tree": {"sha": "87c8eef9f4a7927db0c33aeee177e6af3e28c37c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/87c8eef9f4a7927db0c33aeee177e6af3e28c37c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4e07864f591c76265639725762b3b6ad9e9d8bb1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4e07864f591c76265639725762b3b6ad9e9d8bb1", "html_url": "https://github.com/rust-lang/rust/commit/4e07864f591c76265639725762b3b6ad9e9d8bb1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4e07864f591c76265639725762b3b6ad9e9d8bb1/comments", "author": {"login": "jonas-schievink", "id": 1786438, "node_id": "MDQ6VXNlcjE3ODY0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1786438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonas-schievink", "html_url": "https://github.com/jonas-schievink", "followers_url": "https://api.github.com/users/jonas-schievink/followers", "following_url": "https://api.github.com/users/jonas-schievink/following{/other_user}", "gists_url": "https://api.github.com/users/jonas-schievink/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonas-schievink/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonas-schievink/subscriptions", "organizations_url": "https://api.github.com/users/jonas-schievink/orgs", "repos_url": "https://api.github.com/users/jonas-schievink/repos", "events_url": "https://api.github.com/users/jonas-schievink/events{/privacy}", "received_events_url": "https://api.github.com/users/jonas-schievink/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jonas-schievink", "id": 1786438, "node_id": "MDQ6VXNlcjE3ODY0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1786438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonas-schievink", "html_url": "https://github.com/jonas-schievink", "followers_url": "https://api.github.com/users/jonas-schievink/followers", "following_url": "https://api.github.com/users/jonas-schievink/following{/other_user}", "gists_url": "https://api.github.com/users/jonas-schievink/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonas-schievink/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonas-schievink/subscriptions", "organizations_url": "https://api.github.com/users/jonas-schievink/orgs", "repos_url": "https://api.github.com/users/jonas-schievink/repos", "events_url": "https://api.github.com/users/jonas-schievink/events{/privacy}", "received_events_url": "https://api.github.com/users/jonas-schievink/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b7cc9a727525a7729a84204e8ca6f744a4e7c355", "url": "https://api.github.com/repos/rust-lang/rust/commits/b7cc9a727525a7729a84204e8ca6f744a4e7c355", "html_url": "https://github.com/rust-lang/rust/commit/b7cc9a727525a7729a84204e8ca6f744a4e7c355"}], "stats": {"total": 148, "additions": 84, "deletions": 64}, "files": [{"sha": "f33b09ed578964b836351ddf5dc546bffd6ae54e", "filename": "crates/ide/src/signature_help.rs", "status": "modified", "additions": 84, "deletions": 14, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/4e07864f591c76265639725762b3b6ad9e9d8bb1/crates%2Fide%2Fsrc%2Fsignature_help.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e07864f591c76265639725762b3b6ad9e9d8bb1/crates%2Fide%2Fsrc%2Fsignature_help.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fsignature_help.rs?ref=4e07864f591c76265639725762b3b6ad9e9d8bb1", "patch": "@@ -2,11 +2,8 @@\n //! a call or use-site.\n \n use either::Either;\n-use hir::{HasAttrs, HirDisplay, Semantics};\n-use ide_db::{\n-    active_parameter::{callable_for_node, generics_for_token},\n-    base_db::FilePosition,\n-};\n+use hir::{GenericParam, HasAttrs, HirDisplay, Semantics};\n+use ide_db::{active_parameter::callable_for_node, base_db::FilePosition};\n use stdx::format_to;\n use syntax::{\n     algo,\n@@ -73,8 +70,8 @@ pub(crate) fn signature_help(db: &RootDatabase, position: FilePosition) -> Optio\n         return Some(help);\n     }\n \n-    if let Some((generic_def, active_parameter)) = generics_for_token(&sema, token.clone()) {\n-        return signature_help_for_generics(db, generic_def, active_parameter);\n+    if let Some(help) = signature_help_for_generics(&sema, &token) {\n+        return Some(help);\n     }\n \n     None\n@@ -167,17 +164,69 @@ fn signature_help_for_call(\n }\n \n fn signature_help_for_generics(\n-    db: &RootDatabase,\n-    mut generics_def: hir::GenericDef,\n-    active_parameter: usize,\n+    sema: &Semantics<RootDatabase>,\n+    token: &SyntaxToken,\n ) -> Option<SignatureHelp> {\n+    let parent = token.parent()?;\n+    let arg_list = parent\n+        .ancestors()\n+        .filter_map(ast::GenericArgList::cast)\n+        .find(|list| list.syntax().text_range().contains(token.text_range().start()))?;\n+\n+    let mut active_parameter = arg_list\n+        .generic_args()\n+        .take_while(|arg| arg.syntax().text_range().end() <= token.text_range().start())\n+        .count();\n+\n+    let first_arg_is_non_lifetime = arg_list\n+        .generic_args()\n+        .next()\n+        .map_or(false, |arg| !matches!(arg, ast::GenericArg::LifetimeArg(_)));\n+\n+    let mut generics_def = if let Some(path) =\n+        arg_list.syntax().ancestors().find_map(ast::Path::cast)\n+    {\n+        let res = sema.resolve_path(&path)?;\n+        let generic_def: hir::GenericDef = match res {\n+            hir::PathResolution::Def(hir::ModuleDef::Adt(it)) => it.into(),\n+            hir::PathResolution::Def(hir::ModuleDef::Function(it)) => it.into(),\n+            hir::PathResolution::Def(hir::ModuleDef::Trait(it)) => it.into(),\n+            hir::PathResolution::Def(hir::ModuleDef::TypeAlias(it)) => it.into(),\n+            hir::PathResolution::Def(hir::ModuleDef::Variant(it)) => it.into(),\n+            hir::PathResolution::Def(hir::ModuleDef::BuiltinType(_))\n+            | hir::PathResolution::Def(hir::ModuleDef::Const(_))\n+            | hir::PathResolution::Def(hir::ModuleDef::Macro(_))\n+            | hir::PathResolution::Def(hir::ModuleDef::Module(_))\n+            | hir::PathResolution::Def(hir::ModuleDef::Static(_)) => return None,\n+            hir::PathResolution::AssocItem(hir::AssocItem::Function(it)) => it.into(),\n+            hir::PathResolution::AssocItem(hir::AssocItem::TypeAlias(it)) => it.into(),\n+            hir::PathResolution::AssocItem(hir::AssocItem::Const(_)) => return None,\n+            hir::PathResolution::BuiltinAttr(_)\n+            | hir::PathResolution::ToolModule(_)\n+            | hir::PathResolution::Local(_)\n+            | hir::PathResolution::TypeParam(_)\n+            | hir::PathResolution::ConstParam(_)\n+            | hir::PathResolution::SelfType(_) => return None,\n+        };\n+\n+        generic_def\n+    } else if let Some(method_call) = arg_list.syntax().parent().and_then(ast::MethodCallExpr::cast)\n+    {\n+        // recv.method::<$0>()\n+        let method = sema.resolve_method_call(&method_call)?;\n+        method.into()\n+    } else {\n+        return None;\n+    };\n+\n     let mut res = SignatureHelp {\n         doc: None,\n         signature: String::new(),\n         parameters: vec![],\n-        active_parameter: Some(active_parameter),\n+        active_parameter: None,\n     };\n \n+    let db = sema.db;\n     match generics_def {\n         hir::GenericDef::Function(it) => {\n             res.doc = it.docs(db).map(|it| it.into());\n@@ -216,8 +265,16 @@ fn signature_help_for_generics(\n         hir::GenericDef::Impl(_) | hir::GenericDef::Const(_) => return None,\n     }\n \n+    let params = generics_def.params(sema.db);\n+    let num_lifetime_params =\n+        params.iter().take_while(|param| matches!(param, GenericParam::LifetimeParam(_))).count();\n+    if first_arg_is_non_lifetime {\n+        // Lifetime parameters were omitted.\n+        active_parameter += num_lifetime_params;\n+    }\n+    res.active_parameter = Some(active_parameter);\n+\n     res.signature.push('<');\n-    let params = generics_def.params(db);\n     let mut buf = String::new();\n     for param in params {\n         if let hir::GenericParam::TypeParam(ty) = param {\n@@ -976,14 +1033,27 @@ fn f() {\n     fn test_generic_kinds() {\n         check(\n             r#\"\n-fn callee<'a, const A: (), T, const C: u8>() {}\n+fn callee<'a, const A: u8, T, const C: u8>() {}\n \n fn f() {\n     callee::<'static, $0\n }\n         \"#,\n             expect![[r#\"\n-                fn callee<'a, const A: (), T, const C: u8>\n+                fn callee<'a, const A: u8, T, const C: u8>\n+                          --  ^^^^^^^^^^^  -  -----------\n+            \"#]],\n+        );\n+        check(\n+            r#\"\n+fn callee<'a, const A: u8, T, const C: u8>() {}\n+\n+fn f() {\n+    callee::<NON_LIFETIME$0\n+}\n+        \"#,\n+            expect![[r#\"\n+                fn callee<'a, const A: u8, T, const C: u8>\n                           --  ^^^^^^^^^^^  -  -----------\n             \"#]],\n         );"}, {"sha": "788a5ed17e63e8f06ec9a24b7f616ded62a5f262", "filename": "crates/ide_db/src/active_parameter.rs", "status": "modified", "additions": 0, "deletions": 50, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/4e07864f591c76265639725762b3b6ad9e9d8bb1/crates%2Fide_db%2Fsrc%2Factive_parameter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e07864f591c76265639725762b3b6ad9e9d8bb1/crates%2Fide_db%2Fsrc%2Factive_parameter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Factive_parameter.rs?ref=4e07864f591c76265639725762b3b6ad9e9d8bb1", "patch": "@@ -76,53 +76,3 @@ pub fn callable_for_node(\n     };\n     Some((callable, active_param))\n }\n-\n-pub fn generics_for_token(\n-    sema: &Semantics<RootDatabase>,\n-    token: SyntaxToken,\n-) -> Option<(hir::GenericDef, usize)> {\n-    let parent = token.parent()?;\n-    let arg_list = parent\n-        .ancestors()\n-        .filter_map(ast::GenericArgList::cast)\n-        .find(|list| list.syntax().text_range().contains(token.text_range().start()))?;\n-\n-    let active_param = arg_list\n-        .generic_args()\n-        .take_while(|arg| arg.syntax().text_range().end() <= token.text_range().start())\n-        .count();\n-\n-    if let Some(path) = arg_list.syntax().ancestors().find_map(ast::Path::cast) {\n-        let res = sema.resolve_path(&path)?;\n-        let generic_def: hir::GenericDef = match res {\n-            hir::PathResolution::Def(hir::ModuleDef::Adt(it)) => it.into(),\n-            hir::PathResolution::Def(hir::ModuleDef::Function(it)) => it.into(),\n-            hir::PathResolution::Def(hir::ModuleDef::Trait(it)) => it.into(),\n-            hir::PathResolution::Def(hir::ModuleDef::TypeAlias(it)) => it.into(),\n-            hir::PathResolution::Def(hir::ModuleDef::Variant(it)) => it.into(),\n-            hir::PathResolution::Def(hir::ModuleDef::BuiltinType(_))\n-            | hir::PathResolution::Def(hir::ModuleDef::Const(_))\n-            | hir::PathResolution::Def(hir::ModuleDef::Macro(_))\n-            | hir::PathResolution::Def(hir::ModuleDef::Module(_))\n-            | hir::PathResolution::Def(hir::ModuleDef::Static(_)) => return None,\n-            hir::PathResolution::AssocItem(hir::AssocItem::Function(it)) => it.into(),\n-            hir::PathResolution::AssocItem(hir::AssocItem::TypeAlias(it)) => it.into(),\n-            hir::PathResolution::AssocItem(hir::AssocItem::Const(_)) => return None,\n-            hir::PathResolution::BuiltinAttr(_)\n-            | hir::PathResolution::ToolModule(_)\n-            | hir::PathResolution::Local(_)\n-            | hir::PathResolution::TypeParam(_)\n-            | hir::PathResolution::ConstParam(_)\n-            | hir::PathResolution::SelfType(_) => return None,\n-        };\n-\n-        Some((generic_def, active_param))\n-    } else if let Some(method_call) = arg_list.syntax().parent().and_then(ast::MethodCallExpr::cast)\n-    {\n-        // recv.method::<$0>()\n-        let method = sema.resolve_method_call(&method_call)?;\n-        Some((method.into(), active_param))\n-    } else {\n-        None\n-    }\n-}"}]}