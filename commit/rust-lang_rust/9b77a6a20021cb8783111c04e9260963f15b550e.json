{"sha": "9b77a6a20021cb8783111c04e9260963f15b550e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjliNzdhNmEyMDAyMWNiODc4MzExMWMwNGU5MjYwOTYzZjE1YjU1MGU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-09-29T16:41:53Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-09-29T16:41:53Z"}, "message": "Auto merge of #77145 - pietroalbini:refactor-build-manifest-versions, r=Mark-Simulacrum\n\nRefactor versions detection in build-manifest\n\nThis PR refactors how `build-manifest` handles versions, making the following changes:\n\n* `build-manifest` now detects the \"package releases\" on its own, without relying on rustbuild providing them through CLI arguments. This drastically simplifies calling the tool outside of `x.py`, and will allow to ship the prebuilt tool in a tarball in the future, with the goal of stopping to invoke `x.py` during `promote-release`.\n* The `tar` command is not used to extract the version and the git hash from tarballs anymore. The `flate2` and `tar` crates are used instead. This makes detecting those pieces of data way faster, as the archive is decompressed just once and we stop parsing the archive once all the information is retrieved.\n* The code to extract the version and the git hash now stores all the collected data dynamically, without requiring to add new fields to the `Builder` struct every time.\n\nI tested the changes locally and it should behave the same as before.\n\nr? `@Mark-Simulacrum`", "tree": {"sha": "96f09089b91b1ae5fe02df21a6e029da69d7d02a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/96f09089b91b1ae5fe02df21a6e029da69d7d02a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9b77a6a20021cb8783111c04e9260963f15b550e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9b77a6a20021cb8783111c04e9260963f15b550e", "html_url": "https://github.com/rust-lang/rust/commit/9b77a6a20021cb8783111c04e9260963f15b550e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9b77a6a20021cb8783111c04e9260963f15b550e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4d52dc4790cfaf3f23ff219c9a9932be2bfcd53e", "url": "https://api.github.com/repos/rust-lang/rust/commits/4d52dc4790cfaf3f23ff219c9a9932be2bfcd53e", "html_url": "https://github.com/rust-lang/rust/commit/4d52dc4790cfaf3f23ff219c9a9932be2bfcd53e"}, {"sha": "0749ad02d0b8429e2a3a50158994268c0b0af044", "url": "https://api.github.com/repos/rust-lang/rust/commits/0749ad02d0b8429e2a3a50158994268c0b0af044", "html_url": "https://github.com/rust-lang/rust/commit/0749ad02d0b8429e2a3a50158994268c0b0af044"}], "stats": {"total": 510, "additions": 293, "deletions": 217}, "files": [{"sha": "28bd57ef6735caffc20e9d261d0416d7ae6eab02", "filename": "Cargo.lock", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9b77a6a20021cb8783111c04e9260963f15b550e/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/9b77a6a20021cb8783111c04e9260963f15b550e/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=9b77a6a20021cb8783111c04e9260963f15b550e", "patch": "@@ -231,8 +231,11 @@ dependencies = [\n name = \"build-manifest\"\n version = \"0.1.0\"\n dependencies = [\n+ \"anyhow\",\n+ \"flate2\",\n  \"serde\",\n  \"serde_json\",\n+ \"tar\",\n  \"toml\",\n ]\n "}, {"sha": "c846662fd51266c863716164afa29636914d17a6", "filename": "src/bootstrap/dist.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9b77a6a20021cb8783111c04e9260963f15b550e/src%2Fbootstrap%2Fdist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b77a6a20021cb8783111c04e9260963f15b550e/src%2Fbootstrap%2Fdist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdist.rs?ref=9b77a6a20021cb8783111c04e9260963f15b550e", "patch": "@@ -2368,15 +2368,9 @@ impl Step for HashSign {\n         cmd.arg(sign);\n         cmd.arg(distdir(builder));\n         cmd.arg(today.trim());\n-        cmd.arg(builder.rust_package_vers());\n         cmd.arg(addr);\n-        cmd.arg(builder.package_vers(&builder.release_num(\"cargo\")));\n-        cmd.arg(builder.package_vers(&builder.release_num(\"rls\")));\n-        cmd.arg(builder.package_vers(&builder.release_num(\"rust-analyzer/crates/rust-analyzer\")));\n-        cmd.arg(builder.package_vers(&builder.release_num(\"clippy\")));\n-        cmd.arg(builder.package_vers(&builder.release_num(\"miri\")));\n-        cmd.arg(builder.package_vers(&builder.release_num(\"rustfmt\")));\n-        cmd.arg(builder.llvm_tools_package_vers());\n+        cmd.arg(&builder.config.channel);\n+        cmd.arg(&builder.src);\n \n         builder.create_dir(&distdir(builder));\n "}, {"sha": "4f89c31936ddacecda6cf1b740174e5f44826c94", "filename": "src/tools/build-manifest/Cargo.toml", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9b77a6a20021cb8783111c04e9260963f15b550e/src%2Ftools%2Fbuild-manifest%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/9b77a6a20021cb8783111c04e9260963f15b550e/src%2Ftools%2Fbuild-manifest%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fbuild-manifest%2FCargo.toml?ref=9b77a6a20021cb8783111c04e9260963f15b550e", "patch": "@@ -8,3 +8,6 @@ edition = \"2018\"\n toml = \"0.5\"\n serde = { version = \"1.0\", features = [\"derive\"] }\n serde_json = \"1.0\"\n+anyhow = \"1.0.32\"\n+flate2 = \"1.0.16\"\n+tar = \"0.4.29\""}, {"sha": "4d7d9f7da1874e4f45e57de6c3041d4ef2224e33", "filename": "src/tools/build-manifest/README.md", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9b77a6a20021cb8783111c04e9260963f15b550e/src%2Ftools%2Fbuild-manifest%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/9b77a6a20021cb8783111c04e9260963f15b550e/src%2Ftools%2Fbuild-manifest%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fbuild-manifest%2FREADME.md?ref=9b77a6a20021cb8783111c04e9260963f15b550e", "patch": "@@ -21,10 +21,9 @@ Then, you can generate the manifest and all the packages from `path/to/dist` to\n \n ```\n $ BUILD_MANIFEST_DISABLE_SIGNING=1 cargo +nightly run \\\n-    path/to/dist path/to/output 1970-01-01 \\\n-    nightly nightly nightly nightly nightly nightly nightly nightly \\\n-    http://example.com\n+    path/to/dist path/to/output 1970-01-01 http://example.com \\\n+    CHANNEL path/to/rust/repo\n ```\n \n-In the future, if the tool complains about missing arguments just add more\n-`nightly`s in the middle.\n+Remember to replace `CHANNEL` with the channel you produced dist artifacts of\n+and `path/to/rust/repo` with the path to your checkout of the Rust repository."}, {"sha": "be3e862e7aecde248cc7bccd69c5600f366be485", "filename": "src/tools/build-manifest/src/main.rs", "status": "modified", "additions": 29, "deletions": 204, "changes": 233, "blob_url": "https://github.com/rust-lang/rust/blob/9b77a6a20021cb8783111c04e9260963f15b550e/src%2Ftools%2Fbuild-manifest%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b77a6a20021cb8783111c04e9260963f15b550e/src%2Ftools%2Fbuild-manifest%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fbuild-manifest%2Fsrc%2Fmain.rs?ref=9b77a6a20021cb8783111c04e9260963f15b550e", "patch": "@@ -4,8 +4,10 @@\n //! via `x.py dist hash-and-sign`; the cmdline arguments are set up\n //! by rustbuild (in `src/bootstrap/dist.rs`).\n \n-use serde::Serialize;\n+mod versions;\n \n+use crate::versions::{PkgType, Versions};\n+use serde::Serialize;\n use std::collections::BTreeMap;\n use std::collections::HashMap;\n use std::env;\n@@ -226,14 +228,7 @@ macro_rules! t {\n }\n \n struct Builder {\n-    rust_release: String,\n-    cargo_release: String,\n-    rls_release: String,\n-    rust_analyzer_release: String,\n-    clippy_release: String,\n-    rustfmt_release: String,\n-    llvm_tools_release: String,\n-    miri_release: String,\n+    versions: Versions,\n \n     input: PathBuf,\n     output: PathBuf,\n@@ -242,24 +237,6 @@ struct Builder {\n     s3_address: String,\n     date: String,\n \n-    rust_version: Option<String>,\n-    cargo_version: Option<String>,\n-    rls_version: Option<String>,\n-    rust_analyzer_version: Option<String>,\n-    clippy_version: Option<String>,\n-    rustfmt_version: Option<String>,\n-    llvm_tools_version: Option<String>,\n-    miri_version: Option<String>,\n-\n-    rust_git_commit_hash: Option<String>,\n-    cargo_git_commit_hash: Option<String>,\n-    rls_git_commit_hash: Option<String>,\n-    rust_analyzer_git_commit_hash: Option<String>,\n-    clippy_git_commit_hash: Option<String>,\n-    rustfmt_git_commit_hash: Option<String>,\n-    llvm_tools_git_commit_hash: Option<String>,\n-    miri_git_commit_hash: Option<String>,\n-\n     should_sign: bool,\n }\n \n@@ -280,15 +257,9 @@ fn main() {\n     let input = PathBuf::from(args.next().unwrap());\n     let output = PathBuf::from(args.next().unwrap());\n     let date = args.next().unwrap();\n-    let rust_release = args.next().unwrap();\n     let s3_address = args.next().unwrap();\n-    let cargo_release = args.next().unwrap();\n-    let rls_release = args.next().unwrap();\n-    let rust_analyzer_release = args.next().unwrap();\n-    let clippy_release = args.next().unwrap();\n-    let miri_release = args.next().unwrap();\n-    let rustfmt_release = args.next().unwrap();\n-    let llvm_tools_release = args.next().unwrap();\n+    let channel = args.next().unwrap();\n+    let monorepo_path = args.next().unwrap();\n \n     // Do not ask for a passphrase while manually testing\n     let mut passphrase = String::new();\n@@ -298,14 +269,7 @@ fn main() {\n     }\n \n     Builder {\n-        rust_release,\n-        cargo_release,\n-        rls_release,\n-        rust_analyzer_release,\n-        clippy_release,\n-        rustfmt_release,\n-        llvm_tools_release,\n-        miri_release,\n+        versions: Versions::new(&channel, &input, Path::new(&monorepo_path)).unwrap(),\n \n         input,\n         output,\n@@ -314,87 +278,21 @@ fn main() {\n         s3_address,\n         date,\n \n-        rust_version: None,\n-        cargo_version: None,\n-        rls_version: None,\n-        rust_analyzer_version: None,\n-        clippy_version: None,\n-        rustfmt_version: None,\n-        llvm_tools_version: None,\n-        miri_version: None,\n-\n-        rust_git_commit_hash: None,\n-        cargo_git_commit_hash: None,\n-        rls_git_commit_hash: None,\n-        rust_analyzer_git_commit_hash: None,\n-        clippy_git_commit_hash: None,\n-        rustfmt_git_commit_hash: None,\n-        llvm_tools_git_commit_hash: None,\n-        miri_git_commit_hash: None,\n-\n         should_sign,\n     }\n     .build();\n }\n \n-enum PkgType {\n-    RustSrc,\n-    Cargo,\n-    Rls,\n-    RustAnalyzer,\n-    Clippy,\n-    Rustfmt,\n-    LlvmTools,\n-    Miri,\n-    Other,\n-}\n-\n-impl PkgType {\n-    fn from_component(component: &str) -> Self {\n-        use PkgType::*;\n-        match component {\n-            \"rust-src\" => RustSrc,\n-            \"cargo\" => Cargo,\n-            \"rls\" | \"rls-preview\" => Rls,\n-            \"rust-analyzer\" | \"rust-analyzer-preview\" => RustAnalyzer,\n-            \"clippy\" | \"clippy-preview\" => Clippy,\n-            \"rustfmt\" | \"rustfmt-preview\" => Rustfmt,\n-            \"llvm-tools\" | \"llvm-tools-preview\" => LlvmTools,\n-            \"miri\" | \"miri-preview\" => Miri,\n-            _ => Other,\n-        }\n-    }\n-}\n-\n impl Builder {\n     fn build(&mut self) {\n-        self.rust_version = self.version(\"rust\", \"x86_64-unknown-linux-gnu\");\n-        self.cargo_version = self.version(\"cargo\", \"x86_64-unknown-linux-gnu\");\n-        self.rls_version = self.version(\"rls\", \"x86_64-unknown-linux-gnu\");\n-        self.rust_analyzer_version = self.version(\"rust-analyzer\", \"x86_64-unknown-linux-gnu\");\n-        self.clippy_version = self.version(\"clippy\", \"x86_64-unknown-linux-gnu\");\n-        self.rustfmt_version = self.version(\"rustfmt\", \"x86_64-unknown-linux-gnu\");\n-        self.llvm_tools_version = self.version(\"llvm-tools\", \"x86_64-unknown-linux-gnu\");\n-        self.miri_version = self.version(\"miri\", \"x86_64-unknown-linux-gnu\");\n-\n-        self.rust_git_commit_hash = self.git_commit_hash(\"rust\", \"x86_64-unknown-linux-gnu\");\n-        self.cargo_git_commit_hash = self.git_commit_hash(\"cargo\", \"x86_64-unknown-linux-gnu\");\n-        self.rls_git_commit_hash = self.git_commit_hash(\"rls\", \"x86_64-unknown-linux-gnu\");\n-        self.rust_analyzer_git_commit_hash =\n-            self.git_commit_hash(\"rust-analyzer\", \"x86_64-unknown-linux-gnu\");\n-        self.clippy_git_commit_hash = self.git_commit_hash(\"clippy\", \"x86_64-unknown-linux-gnu\");\n-        self.rustfmt_git_commit_hash = self.git_commit_hash(\"rustfmt\", \"x86_64-unknown-linux-gnu\");\n-        self.llvm_tools_git_commit_hash =\n-            self.git_commit_hash(\"llvm-tools\", \"x86_64-unknown-linux-gnu\");\n-        self.miri_git_commit_hash = self.git_commit_hash(\"miri\", \"x86_64-unknown-linux-gnu\");\n-\n         self.check_toolstate();\n         self.digest_and_sign();\n         let manifest = self.build_manifest();\n-        self.write_channel_files(&self.rust_release, &manifest);\n \n-        if self.rust_release != \"beta\" && self.rust_release != \"nightly\" {\n-            self.write_channel_files(\"stable\", &manifest);\n+        let rust_version = self.versions.package_version(&PkgType::Rust).unwrap();\n+        self.write_channel_files(self.versions.channel(), &manifest);\n+        if self.versions.channel() != rust_version {\n+            self.write_channel_files(&rust_version, &manifest);\n         }\n     }\n \n@@ -415,8 +313,7 @@ impl Builder {\n         // Mark some tools as missing based on toolstate.\n         if toolstates.get(\"miri\").map(|s| &*s as &str) != Some(\"test-pass\") {\n             println!(\"Miri tests are not passing, removing component\");\n-            self.miri_version = None;\n-            self.miri_git_commit_hash = None;\n+            self.versions.disable_version(&PkgType::Miri);\n         }\n     }\n \n@@ -501,7 +398,7 @@ impl Builder {\n         // The compiler libraries are not stable for end users, and they're also huge, so we only\n         // `rustc-dev` for nightly users, and only in the \"complete\" profile. It's still possible\n         // for users to install the additional component manually, if needed.\n-        if self.rust_release == \"nightly\" {\n+        if self.versions.channel() == \"nightly\" {\n             self.extend_profile(\"complete\", &mut manifest.profiles, &[\"rustc-dev\"]);\n             self.extend_profile(\"complete\", &mut manifest.profiles, &[\"rustc-docs\"]);\n         }\n@@ -518,13 +415,10 @@ impl Builder {\n     }\n \n     fn rust_package(&mut self, manifest: &Manifest) -> Package {\n+        let version_info = self.versions.version(&PkgType::Rust).expect(\"missing Rust tarball\");\n         let mut pkg = Package {\n-            version: self\n-                .cached_version(\"rust\")\n-                .as_ref()\n-                .expect(\"Couldn't find Rust version\")\n-                .clone(),\n-            git_commit_hash: self.cached_git_commit_hash(\"rust\").clone(),\n+            version: version_info.version.expect(\"missing Rust version\"),\n+            git_commit_hash: version_info.git_commit,\n             target: BTreeMap::new(),\n         };\n         for host in HOSTS {\n@@ -539,7 +433,7 @@ impl Builder {\n     }\n \n     fn target_host_combination(&mut self, host: &str, manifest: &Manifest) -> Option<Target> {\n-        let filename = self.filename(\"rust\", host);\n+        let filename = self.versions.tarball_name(&PkgType::Rust, host).unwrap();\n         let digest = self.digests.remove(&filename)?;\n         let xz_filename = filename.replace(\".tar.gz\", \".tar.xz\");\n         let xz_digest = self.digests.remove(&xz_filename);\n@@ -630,15 +524,14 @@ impl Builder {\n     }\n \n     fn package(&mut self, pkgname: &str, dst: &mut BTreeMap<String, Package>, targets: &[&str]) {\n-        let (version, mut is_present) = self\n-            .cached_version(pkgname)\n-            .as_ref()\n-            .cloned()\n-            .map(|version| (version, true))\n-            .unwrap_or_default(); // `is_present` defaults to `false` here.\n+        let version_info = self\n+            .versions\n+            .version(&PkgType::from_component(pkgname))\n+            .expect(\"failed to load package version\");\n+        let mut is_present = version_info.present;\n \n         // Never ship nightly-only components for other trains.\n-        if self.rust_release != \"nightly\" && NIGHTLY_ONLY_COMPONENTS.contains(&pkgname) {\n+        if self.versions.channel() != \"nightly\" && NIGHTLY_ONLY_COMPONENTS.contains(&pkgname) {\n             is_present = false; // Pretend the component is entirely missing.\n         }\n \n@@ -647,7 +540,10 @@ impl Builder {\n             .map(|name| {\n                 if is_present {\n                     // The component generally exists, but it might still be missing for this target.\n-                    let filename = self.filename(pkgname, name);\n+                    let filename = self\n+                        .versions\n+                        .tarball_name(&PkgType::from_component(pkgname), name)\n+                        .unwrap();\n                     let digest = match self.digests.remove(&filename) {\n                         Some(digest) => digest,\n                         // This component does not exist for this target -- skip it.\n@@ -679,8 +575,8 @@ impl Builder {\n         dst.insert(\n             pkgname.to_string(),\n             Package {\n-                version,\n-                git_commit_hash: self.cached_git_commit_hash(pkgname).clone(),\n+                version: version_info.version.unwrap_or_default(),\n+                git_commit_hash: version_info.git_commit,\n                 target: targets,\n             },\n         );\n@@ -690,77 +586,6 @@ impl Builder {\n         format!(\"{}/{}/{}\", self.s3_address, self.date, filename)\n     }\n \n-    fn filename(&self, component: &str, target: &str) -> String {\n-        use PkgType::*;\n-        match PkgType::from_component(component) {\n-            RustSrc => format!(\"rust-src-{}.tar.gz\", self.rust_release),\n-            Cargo => format!(\"cargo-{}-{}.tar.gz\", self.cargo_release, target),\n-            Rls => format!(\"rls-{}-{}.tar.gz\", self.rls_release, target),\n-            RustAnalyzer => {\n-                format!(\"rust-analyzer-{}-{}.tar.gz\", self.rust_analyzer_release, target)\n-            }\n-            Clippy => format!(\"clippy-{}-{}.tar.gz\", self.clippy_release, target),\n-            Rustfmt => format!(\"rustfmt-{}-{}.tar.gz\", self.rustfmt_release, target),\n-            LlvmTools => format!(\"llvm-tools-{}-{}.tar.gz\", self.llvm_tools_release, target),\n-            Miri => format!(\"miri-{}-{}.tar.gz\", self.miri_release, target),\n-            Other => format!(\"{}-{}-{}.tar.gz\", component, self.rust_release, target),\n-        }\n-    }\n-\n-    fn cached_version(&self, component: &str) -> &Option<String> {\n-        use PkgType::*;\n-        match PkgType::from_component(component) {\n-            Cargo => &self.cargo_version,\n-            Rls => &self.rls_version,\n-            RustAnalyzer => &self.rust_analyzer_version,\n-            Clippy => &self.clippy_version,\n-            Rustfmt => &self.rustfmt_version,\n-            LlvmTools => &self.llvm_tools_version,\n-            Miri => &self.miri_version,\n-            _ => &self.rust_version,\n-        }\n-    }\n-\n-    fn cached_git_commit_hash(&self, component: &str) -> &Option<String> {\n-        use PkgType::*;\n-        match PkgType::from_component(component) {\n-            Cargo => &self.cargo_git_commit_hash,\n-            Rls => &self.rls_git_commit_hash,\n-            RustAnalyzer => &self.rust_analyzer_git_commit_hash,\n-            Clippy => &self.clippy_git_commit_hash,\n-            Rustfmt => &self.rustfmt_git_commit_hash,\n-            LlvmTools => &self.llvm_tools_git_commit_hash,\n-            Miri => &self.miri_git_commit_hash,\n-            _ => &self.rust_git_commit_hash,\n-        }\n-    }\n-\n-    fn version(&self, component: &str, target: &str) -> Option<String> {\n-        self.untar(component, target, |filename| format!(\"{}/version\", filename))\n-    }\n-\n-    fn git_commit_hash(&self, component: &str, target: &str) -> Option<String> {\n-        self.untar(component, target, |filename| format!(\"{}/git-commit-hash\", filename))\n-    }\n-\n-    fn untar<F>(&self, component: &str, target: &str, dir: F) -> Option<String>\n-    where\n-        F: FnOnce(String) -> String,\n-    {\n-        let mut cmd = Command::new(\"tar\");\n-        let filename = self.filename(component, target);\n-        cmd.arg(\"xf\")\n-            .arg(self.input.join(&filename))\n-            .arg(dir(filename.replace(\".tar.gz\", \"\")))\n-            .arg(\"-O\");\n-        let output = t!(cmd.output());\n-        if output.status.success() {\n-            Some(String::from_utf8_lossy(&output.stdout).trim().to_string())\n-        } else {\n-            None\n-        }\n-    }\n-\n     fn hash(&self, path: &Path) -> String {\n         let sha = t!(Command::new(\"shasum\")\n             .arg(\"-a\")"}, {"sha": "d949dff72798b35160271ae169db8771f77c0f9d", "filename": "src/tools/build-manifest/src/versions.rs", "status": "added", "additions": 252, "deletions": 0, "changes": 252, "blob_url": "https://github.com/rust-lang/rust/blob/9b77a6a20021cb8783111c04e9260963f15b550e/src%2Ftools%2Fbuild-manifest%2Fsrc%2Fversions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b77a6a20021cb8783111c04e9260963f15b550e/src%2Ftools%2Fbuild-manifest%2Fsrc%2Fversions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fbuild-manifest%2Fsrc%2Fversions.rs?ref=9b77a6a20021cb8783111c04e9260963f15b550e", "patch": "@@ -0,0 +1,252 @@\n+use anyhow::{Context, Error};\n+use flate2::read::GzDecoder;\n+use std::collections::HashMap;\n+use std::fs::File;\n+use std::io::Read;\n+use std::path::{Path, PathBuf};\n+use tar::Archive;\n+\n+const DEFAULT_TARGET: &str = \"x86_64-unknown-linux-gnu\";\n+\n+#[derive(Debug, Hash, Eq, PartialEq, Clone)]\n+pub(crate) enum PkgType {\n+    Rust,\n+    RustSrc,\n+    Cargo,\n+    Rls,\n+    RustAnalyzer,\n+    Clippy,\n+    Rustfmt,\n+    LlvmTools,\n+    Miri,\n+    Other(String),\n+}\n+\n+impl PkgType {\n+    pub(crate) fn from_component(component: &str) -> Self {\n+        match component {\n+            \"rust\" => PkgType::Rust,\n+            \"rust-src\" => PkgType::RustSrc,\n+            \"cargo\" => PkgType::Cargo,\n+            \"rls\" | \"rls-preview\" => PkgType::Rls,\n+            \"rust-analyzer\" | \"rust-analyzer-preview\" => PkgType::RustAnalyzer,\n+            \"clippy\" | \"clippy-preview\" => PkgType::Clippy,\n+            \"rustfmt\" | \"rustfmt-preview\" => PkgType::Rustfmt,\n+            \"llvm-tools\" | \"llvm-tools-preview\" => PkgType::LlvmTools,\n+            \"miri\" | \"miri-preview\" => PkgType::Miri,\n+            other => PkgType::Other(other.into()),\n+        }\n+    }\n+\n+    /// The directory containing the `Cargo.toml` of this component inside the monorepo, to\n+    /// retrieve the source code version. If `None` is returned Rust's version will be used.\n+    fn rust_monorepo_path(&self) -> Option<&'static str> {\n+        match self {\n+            PkgType::Cargo => Some(\"src/tools/cargo\"),\n+            PkgType::Rls => Some(\"src/tools/rls\"),\n+            PkgType::RustAnalyzer => Some(\"src/tools/rust-analyzer/crates/rust-analyzer\"),\n+            PkgType::Clippy => Some(\"src/tools/clippy\"),\n+            PkgType::Rustfmt => Some(\"src/tools/rustfmt\"),\n+            PkgType::Miri => Some(\"src/tools/miri\"),\n+            PkgType::Rust => None,\n+            PkgType::RustSrc => None,\n+            PkgType::LlvmTools => None,\n+            PkgType::Other(_) => None,\n+        }\n+    }\n+\n+    /// First part of the tarball name.\n+    fn tarball_component_name(&self) -> &str {\n+        match self {\n+            PkgType::Rust => \"rust\",\n+            PkgType::RustSrc => \"rust-src\",\n+            PkgType::Cargo => \"cargo\",\n+            PkgType::Rls => \"rls\",\n+            PkgType::RustAnalyzer => \"rust-analyzer\",\n+            PkgType::Clippy => \"clippy\",\n+            PkgType::Rustfmt => \"rustfmt\",\n+            PkgType::LlvmTools => \"llvm-tools\",\n+            PkgType::Miri => \"miri\",\n+            PkgType::Other(component) => component,\n+        }\n+    }\n+\n+    /// Whether this package has the same version as Rust itself, or has its own `version` and\n+    /// `git-commit-hash` files inside the tarball.\n+    fn should_use_rust_version(&self) -> bool {\n+        match self {\n+            PkgType::Cargo => false,\n+            PkgType::Rls => false,\n+            PkgType::RustAnalyzer => false,\n+            PkgType::Clippy => false,\n+            PkgType::Rustfmt => false,\n+            PkgType::LlvmTools => false,\n+            PkgType::Miri => false,\n+\n+            PkgType::Rust => true,\n+            PkgType::RustSrc => true,\n+            PkgType::Other(_) => true,\n+        }\n+    }\n+\n+    /// Whether this package is target-independent or not.\n+    fn target_independent(&self) -> bool {\n+        *self == PkgType::RustSrc\n+    }\n+}\n+\n+#[derive(Debug, Default, Clone)]\n+pub(crate) struct VersionInfo {\n+    pub(crate) version: Option<String>,\n+    pub(crate) git_commit: Option<String>,\n+    pub(crate) present: bool,\n+}\n+\n+pub(crate) struct Versions {\n+    channel: String,\n+    rustc_version: String,\n+    monorepo_root: PathBuf,\n+    dist_path: PathBuf,\n+    package_versions: HashMap<PkgType, String>,\n+    versions: HashMap<PkgType, VersionInfo>,\n+}\n+\n+impl Versions {\n+    pub(crate) fn new(\n+        channel: &str,\n+        dist_path: &Path,\n+        monorepo_root: &Path,\n+    ) -> Result<Self, Error> {\n+        Ok(Self {\n+            channel: channel.into(),\n+            rustc_version: std::fs::read_to_string(monorepo_root.join(\"src\").join(\"version\"))\n+                .context(\"failed to read the rustc version from src/version\")?\n+                .trim()\n+                .to_string(),\n+            monorepo_root: monorepo_root.into(),\n+            dist_path: dist_path.into(),\n+            package_versions: HashMap::new(),\n+            versions: HashMap::new(),\n+        })\n+    }\n+\n+    pub(crate) fn channel(&self) -> &str {\n+        &self.channel\n+    }\n+\n+    pub(crate) fn version(&mut self, mut package: &PkgType) -> Result<VersionInfo, Error> {\n+        if package.should_use_rust_version() {\n+            package = &PkgType::Rust;\n+        }\n+\n+        match self.versions.get(package) {\n+            Some(version) => Ok(version.clone()),\n+            None => {\n+                let version_info = self.load_version_from_tarball(package)?;\n+                self.versions.insert(package.clone(), version_info.clone());\n+                Ok(version_info)\n+            }\n+        }\n+    }\n+\n+    fn load_version_from_tarball(&mut self, package: &PkgType) -> Result<VersionInfo, Error> {\n+        let tarball_name = self.tarball_name(package, DEFAULT_TARGET)?;\n+        let tarball = self.dist_path.join(tarball_name);\n+\n+        let file = match File::open(&tarball) {\n+            Ok(file) => file,\n+            Err(err) if err.kind() == std::io::ErrorKind::NotFound => {\n+                // Missing tarballs do not return an error, but return empty data.\n+                return Ok(VersionInfo::default());\n+            }\n+            Err(err) => return Err(err.into()),\n+        };\n+        let mut tar = Archive::new(GzDecoder::new(file));\n+\n+        let mut version = None;\n+        let mut git_commit = None;\n+        for entry in tar.entries()? {\n+            let mut entry = entry?;\n+\n+            let dest;\n+            match entry.path()?.components().nth(1).and_then(|c| c.as_os_str().to_str()) {\n+                Some(\"version\") => dest = &mut version,\n+                Some(\"git-commit-hash\") => dest = &mut git_commit,\n+                _ => continue,\n+            }\n+            let mut buf = String::new();\n+            entry.read_to_string(&mut buf)?;\n+            *dest = Some(buf);\n+\n+            // Short circuit to avoid reading the whole tar file if not necessary.\n+            if version.is_some() && git_commit.is_some() {\n+                break;\n+            }\n+        }\n+\n+        Ok(VersionInfo { version, git_commit, present: true })\n+    }\n+\n+    pub(crate) fn disable_version(&mut self, package: &PkgType) {\n+        match self.versions.get_mut(package) {\n+            Some(version) => {\n+                *version = VersionInfo::default();\n+            }\n+            None => {\n+                self.versions.insert(package.clone(), VersionInfo::default());\n+            }\n+        }\n+    }\n+\n+    pub(crate) fn tarball_name(\n+        &mut self,\n+        package: &PkgType,\n+        target: &str,\n+    ) -> Result<String, Error> {\n+        let component_name = package.tarball_component_name();\n+        let version = self.package_version(package).with_context(|| {\n+            format!(\"failed to get the package version for component {:?}\", package,)\n+        })?;\n+        if package.target_independent() {\n+            Ok(format!(\"{}-{}.tar.gz\", component_name, version))\n+        } else {\n+            Ok(format!(\"{}-{}-{}.tar.gz\", component_name, version, target))\n+        }\n+    }\n+\n+    pub(crate) fn package_version(&mut self, package: &PkgType) -> Result<String, Error> {\n+        match self.package_versions.get(package) {\n+            Some(release) => Ok(release.clone()),\n+            None => {\n+                let version = match package.rust_monorepo_path() {\n+                    Some(path) => {\n+                        let path = self.monorepo_root.join(path).join(\"Cargo.toml\");\n+                        let cargo_toml: CargoToml = toml::from_slice(&std::fs::read(path)?)?;\n+                        cargo_toml.package.version\n+                    }\n+                    None => self.rustc_version.clone(),\n+                };\n+\n+                let release = match self.channel.as_str() {\n+                    \"stable\" => version,\n+                    \"beta\" => \"beta\".into(),\n+                    \"nightly\" => \"nightly\".into(),\n+                    _ => format!(\"{}-dev\", version),\n+                };\n+\n+                self.package_versions.insert(package.clone(), release.clone());\n+                Ok(release)\n+            }\n+        }\n+    }\n+}\n+\n+#[derive(serde::Deserialize)]\n+struct CargoToml {\n+    package: CargoTomlPackage,\n+}\n+\n+#[derive(serde::Deserialize)]\n+struct CargoTomlPackage {\n+    version: String,\n+}"}]}