{"sha": "43c5fef47dcaebea4c77771cc6f187b2a72b3639", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQzYzVmZWY0N2RjYWViZWE0Yzc3NzcxY2M2ZjE4N2IyYTcyYjM2Mzk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-05-03T04:37:18Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-05-03T04:37:18Z"}, "message": "Auto merge of #33354 - Manishearth:rollup, r=Manishearth\n\nRollup of 14 pull requests\n\n- Successful merges: #32756, #33129, #33225, #33260, #33309, #33320, #33323, #33324, #33325, #33330, #33332, #33334, #33335, #33346\n- Failed merges:", "tree": {"sha": "4d740e1808a7d721e17781274bd8b07632b6b433", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4d740e1808a7d721e17781274bd8b07632b6b433"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/43c5fef47dcaebea4c77771cc6f187b2a72b3639", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/43c5fef47dcaebea4c77771cc6f187b2a72b3639", "html_url": "https://github.com/rust-lang/rust/commit/43c5fef47dcaebea4c77771cc6f187b2a72b3639", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/43c5fef47dcaebea4c77771cc6f187b2a72b3639/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "44b3cd8c462a420ab64a44ef8f70c007001a1f44", "url": "https://api.github.com/repos/rust-lang/rust/commits/44b3cd8c462a420ab64a44ef8f70c007001a1f44", "html_url": "https://github.com/rust-lang/rust/commit/44b3cd8c462a420ab64a44ef8f70c007001a1f44"}, {"sha": "638cf9f675174316ba5ecfaf2913c9d60da9772c", "url": "https://api.github.com/repos/rust-lang/rust/commits/638cf9f675174316ba5ecfaf2913c9d60da9772c", "html_url": "https://github.com/rust-lang/rust/commit/638cf9f675174316ba5ecfaf2913c9d60da9772c"}], "stats": {"total": 281, "additions": 167, "deletions": 114}, "files": [{"sha": "8a9f662bf83aa08d537cbf2931e1e0abbb027c8c", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/43c5fef47dcaebea4c77771cc6f187b2a72b3639/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c5fef47dcaebea4c77771cc6f187b2a72b3639/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=43c5fef47dcaebea4c77771cc6f187b2a72b3639", "patch": "@@ -192,11 +192,8 @@ extern \"rust-intrinsic\" {\n \n     /// The size of a type in bytes.\n     ///\n-    /// This is the exact number of bytes in memory taken up by a\n-    /// value of the given type. In other words, a memset of this size\n-    /// would *exactly* overwrite a value. When laid out in vectors\n-    /// and structures there may be additional padding between\n-    /// elements.\n+    /// More specifically, this is the offset in bytes between successive\n+    /// items of the same type, including alignment padding.\n     pub fn size_of<T>() -> usize;\n \n     /// Moves a value to an uninitialized memory location."}, {"sha": "56d268bf37c664100ea8458cf86e4593c96804cf", "filename": "src/libcore/mem.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/43c5fef47dcaebea4c77771cc6f187b2a72b3639/src%2Flibcore%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c5fef47dcaebea4c77771cc6f187b2a72b3639/src%2Flibcore%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem.rs?ref=43c5fef47dcaebea4c77771cc6f187b2a72b3639", "patch": "@@ -117,6 +117,9 @@ pub fn forget<T>(t: T) {\n \n /// Returns the size of a type in bytes.\n ///\n+/// More specifically, this is the offset in bytes between successive\n+/// items of the same type, including alignment padding.\n+///\n /// # Examples\n ///\n /// ```"}, {"sha": "5ee8a79f621de35bdb5aac3b208e54aa8162cac7", "filename": "src/librustc/diagnostics.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/43c5fef47dcaebea4c77771cc6f187b2a72b3639/src%2Flibrustc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c5fef47dcaebea4c77771cc6f187b2a72b3639/src%2Flibrustc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdiagnostics.rs?ref=43c5fef47dcaebea4c77771cc6f187b2a72b3639", "patch": "@@ -635,7 +635,17 @@ fn foo(x: u8) -> u8 {\n ```\n \n It is advisable to find out what the unhandled cases are and check for them,\n-returning an appropriate value or panicking if necessary.\n+returning an appropriate value or panicking if necessary. Check if you need\n+to remove a semicolon from the last expression, like in this case:\n+\n+```ignore\n+fn foo(x: u8) -> u8 {\n+    inner(2*x + 1);\n+}\n+```\n+\n+The semicolon discards the return value of `inner`, instead of returning\n+it from `foo`.\n \"##,\n \n E0270: r##\""}, {"sha": "0207fa52d8de5ae91b5342f7e330101352fa556b", "filename": "src/librustc_const_eval/check_match.rs", "status": "modified", "additions": 21, "deletions": 2, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/43c5fef47dcaebea4c77771cc6f187b2a72b3639/src%2Flibrustc_const_eval%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c5fef47dcaebea4c77771cc6f187b2a72b3639/src%2Flibrustc_const_eval%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fcheck_match.rs?ref=43c5fef47dcaebea4c77771cc6f187b2a72b3639", "patch": "@@ -341,7 +341,15 @@ fn check_arms(cx: &MatchCheckCtxt,\n                         },\n \n                         hir::MatchSource::Normal => {\n-                            span_err!(cx.tcx.sess, pat.span, E0001, \"unreachable pattern\")\n+                            let mut err = struct_span_err!(cx.tcx.sess, pat.span, E0001,\n+                                                           \"unreachable pattern\");\n+                            // if we had a catchall pattern, hint at that\n+                            for row in &seen.0 {\n+                                if pat_is_catchall(&cx.tcx.def_map.borrow(), row[0]) {\n+                                    span_note!(err, row[0].span, \"this pattern matches any value\");\n+                                }\n+                            }\n+                            err.emit();\n                         },\n \n                         hir::MatchSource::TryDesugar => {\n@@ -361,7 +369,18 @@ fn check_arms(cx: &MatchCheckCtxt,\n     }\n }\n \n-fn raw_pat<'a>(p: &'a Pat) -> &'a Pat {\n+/// Checks for common cases of \"catchall\" patterns that may not be intended as such.\n+fn pat_is_catchall(dm: &DefMap, p: &Pat) -> bool {\n+    match p.node {\n+        PatKind::Ident(_, _, None) => pat_is_binding(dm, p),\n+        PatKind::Ident(_, _, Some(ref s)) => pat_is_catchall(dm, &s),\n+        PatKind::Ref(ref s, _) => pat_is_catchall(dm, &s),\n+        PatKind::Tup(ref v) => v.iter().all(|p| pat_is_catchall(dm, &p)),\n+        _ => false\n+    }\n+}\n+\n+fn raw_pat(p: &Pat) -> &Pat {\n     match p.node {\n         PatKind::Ident(_, _, Some(ref s)) => raw_pat(&s),\n         _ => p"}, {"sha": "5b4e88def018b4539d18f9fac0a4a28474cebea0", "filename": "src/librustc_incremental/persist/util.rs", "status": "modified", "additions": 24, "deletions": 2, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/43c5fef47dcaebea4c77771cc6f187b2a72b3639/src%2Flibrustc_incremental%2Fpersist%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c5fef47dcaebea4c77771cc6f187b2a72b3639/src%2Flibrustc_incremental%2Fpersist%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Futil.rs?ref=43c5fef47dcaebea4c77771cc6f187b2a72b3639", "patch": "@@ -9,14 +9,16 @@\n // except according to those terms.\n \n use rustc::ty;\n+\n use std::fs;\n-use std::path::PathBuf;\n+use std::io;\n+use std::path::{PathBuf, Path};\n \n pub fn dep_graph_path<'tcx>(tcx: &ty::TyCtxt<'tcx>) -> Option<PathBuf> {\n     // For now, just save/load dep-graph from\n     // directory/dep_graph.rbml\n     tcx.sess.opts.incremental.as_ref().and_then(|incr_dir| {\n-        match fs::create_dir_all(&incr_dir){\n+        match create_dir_racy(&incr_dir) {\n             Ok(()) => {}\n             Err(err) => {\n                 tcx.sess.err(\n@@ -30,3 +32,23 @@ pub fn dep_graph_path<'tcx>(tcx: &ty::TyCtxt<'tcx>) -> Option<PathBuf> {\n     })\n }\n \n+// Like std::fs::create_dir_all, except handles concurrent calls among multiple\n+// threads or processes.\n+fn create_dir_racy(path: &Path) -> io::Result<()> {\n+    match fs::create_dir(path) {\n+        Ok(()) => return Ok(()),\n+        Err(ref e) if e.kind() == io::ErrorKind::AlreadyExists => return Ok(()),\n+        Err(ref e) if e.kind() == io::ErrorKind::NotFound => {}\n+        Err(e) => return Err(e),\n+    }\n+    match path.parent() {\n+        Some(p) => try!(create_dir_racy(p)),\n+        None => return Err(io::Error::new(io::ErrorKind::Other,\n+                                          \"failed to create whole tree\")),\n+    }\n+    match fs::create_dir(path) {\n+        Ok(()) => Ok(()),\n+        Err(ref e) if e.kind() == io::ErrorKind::AlreadyExists => Ok(()),\n+        Err(e) => Err(e),\n+    }\n+}"}, {"sha": "56d3b927dc592e282c59c3460f7b92f928c1c215", "filename": "src/librustc_resolve/diagnostics.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/43c5fef47dcaebea4c77771cc6f187b2a72b3639/src%2Flibrustc_resolve%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c5fef47dcaebea4c77771cc6f187b2a72b3639/src%2Flibrustc_resolve%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fdiagnostics.rs?ref=43c5fef47dcaebea4c77771cc6f187b2a72b3639", "patch": "@@ -916,19 +916,22 @@ An import was unresolved. Erroneous code example:\n use something::Foo; // error: unresolved import `something::Foo`.\n ```\n \n-Please verify you didn't misspell the import name or the import does exist\n-in the module from where you tried to import it. Example:\n+Paths in `use` statements are relative to the crate root. To import items\n+relative to the current and parent modules, use the `self::` and `super::`\n+prefixes, respectively. Also verify that you didn't misspell the import\n+name and that the import exists in the module from where you tried to\n+import it. Example:\n \n ```ignore\n-use something::Foo; // ok!\n+use self::something::Foo; // ok!\n \n mod something {\n     pub struct Foo;\n }\n ```\n \n Or, if you tried to use a module from an external crate, you may have missed\n-the `extern crate` declaration:\n+the `extern crate` declaration (which is usually placed in the crate root):\n \n ```ignore\n extern crate homura; // Required to use the `homura` crate"}, {"sha": "4ba8f2c9d62514ad0193b46308ee77a18c7ae349", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/43c5fef47dcaebea4c77771cc6f187b2a72b3639/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c5fef47dcaebea4c77771cc6f187b2a72b3639/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=43c5fef47dcaebea4c77771cc6f187b2a72b3639", "patch": "@@ -156,10 +156,6 @@ pub fn report_error<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                 if let Some(expr) = rcvr_expr {\n                     if let Ok (expr_string) = cx.sess.codemap().span_to_snippet(expr.span) {\n                         report_function!(expr.span, expr_string);\n-                        err.span_suggestion(expr.span,\n-                                            \"try calling the base function:\",\n-                                            format!(\"{}()\",\n-                                                    expr_string));\n                     }\n                     else if let Expr_::ExprPath(_, path) = expr.node.clone() {\n                         if let Some(segment) = path.segments.last() {"}, {"sha": "ca15aa2d56c4937c21a0e3377bbe5bf83d1c76b4", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/43c5fef47dcaebea4c77771cc6f187b2a72b3639/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c5fef47dcaebea4c77771cc6f187b2a72b3639/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=43c5fef47dcaebea4c77771cc6f187b2a72b3639", "patch": "@@ -195,7 +195,7 @@\n //!\n //! ## Functions\n //!\n-//! There are a number of [functions][functions] that offer access to various\n+//! There are a number of [functions][functions-list] that offer access to various\n //! features. For example, we can use three of these functions to copy everything\n //! from standard input to standard output:\n //!\n@@ -208,7 +208,7 @@\n //! # }\n //! ```\n //!\n-//! [functions]: #functions\n+//! [functions-list]: #functions-1\n //!\n //! ## io::Result\n //!"}, {"sha": "da62e5286d4e7ef99688ba812a26e854f5908878", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/43c5fef47dcaebea4c77771cc6f187b2a72b3639/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c5fef47dcaebea4c77771cc6f187b2a72b3639/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=43c5fef47dcaebea4c77771cc6f187b2a72b3639", "patch": "@@ -931,11 +931,10 @@ impl<'a> StringReader<'a> {\n             _ => {\n                 if ascii_only && first_source_char > '\\x7F' {\n                     let last_pos = self.last_pos;\n-                    self.err_span_char(start,\n-                                       last_pos,\n-                                       \"byte constant must be ASCII. Use a \\\\xHH escape for a \\\n-                                        non-ASCII byte\",\n-                                       first_source_char);\n+                    self.err_span_(start,\n+                                   last_pos,\n+                                   \"byte constant must be ASCII. Use a \\\\xHH escape for a \\\n+                                    non-ASCII byte\");\n                     return false;\n                 }\n             }"}, {"sha": "4a92ad8ddb26d8c20f55fe45dbfa9ae9de17f475", "filename": "src/libsyntax/print/pp.rs", "status": "modified", "additions": 44, "deletions": 85, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/43c5fef47dcaebea4c77771cc6f187b2a72b3639/src%2Flibsyntax%2Fprint%2Fpp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c5fef47dcaebea4c77771cc6f187b2a72b3639/src%2Flibsyntax%2Fprint%2Fpp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpp.rs?ref=43c5fef47dcaebea4c77771cc6f187b2a72b3639", "patch": "@@ -61,8 +61,9 @@\n //! line (which it can't) and so naturally place the content on its own line to\n //! avoid combining it with other lines and making matters even worse.\n \n+use std::collections::VecDeque;\n+use std::fmt;\n use std::io;\n-use std::string;\n \n #[derive(Clone, Copy, PartialEq)]\n pub enum Breaks {\n@@ -112,35 +113,30 @@ impl Token {\n     }\n }\n \n-pub fn tok_str(token: &Token) -> String {\n-    match *token {\n-        Token::String(ref s, len) => format!(\"STR({},{})\", s, len),\n-        Token::Break(_) => \"BREAK\".to_string(),\n-        Token::Begin(_) => \"BEGIN\".to_string(),\n-        Token::End => \"END\".to_string(),\n-        Token::Eof => \"EOF\".to_string()\n+impl fmt::Display for Token {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        match *self {\n+            Token::String(ref s, len) => write!(f, \"STR({},{})\", s, len),\n+            Token::Break(_) => f.write_str(\"BREAK\"),\n+            Token::Begin(_) => f.write_str(\"BEGIN\"),\n+            Token::End => f.write_str(\"END\"),\n+            Token::Eof => f.write_str(\"EOF\"),\n+        }\n     }\n }\n \n-pub fn buf_str(toks: &[Token],\n-               szs: &[isize],\n-               left: usize,\n-               right: usize,\n-               lim: usize)\n-               -> String {\n+fn buf_str(toks: &[Token], szs: &[isize], left: usize, right: usize, lim: usize) -> String {\n     let n = toks.len();\n     assert_eq!(n, szs.len());\n     let mut i = left;\n     let mut l = lim;\n-    let mut s = string::String::from(\"[\");\n+    let mut s = String::from(\"[\");\n     while i != right && l != 0 {\n         l -= 1;\n         if i != left {\n             s.push_str(\", \");\n         }\n-        s.push_str(&format!(\"{}={}\",\n-                           szs[i],\n-                           tok_str(&toks[i])));\n+        s.push_str(&format!(\"{}={}\", szs[i], &toks[i]));\n         i += 1;\n         i %= n;\n     }\n@@ -169,7 +165,7 @@ pub fn mk_printer<'a>(out: Box<io::Write+'a>, linewidth: usize) -> Printer<'a> {\n     debug!(\"mk_printer {}\", linewidth);\n     let token = vec![Token::Eof; n];\n     let size = vec![0; n];\n-    let scan_stack = vec![0; n];\n+    let scan_stack = VecDeque::with_capacity(n);\n     Printer {\n         out: out,\n         buf_len: n,\n@@ -182,9 +178,6 @@ pub fn mk_printer<'a>(out: Box<io::Write+'a>, linewidth: usize) -> Printer<'a> {\n         left_total: 0,\n         right_total: 0,\n         scan_stack: scan_stack,\n-        scan_stack_empty: true,\n-        top: 0,\n-        bottom: 0,\n         print_stack: Vec::new(),\n         pending_indentation: 0\n     }\n@@ -246,9 +239,8 @@ pub fn mk_printer<'a>(out: Box<io::Write+'a>, linewidth: usize) -> Printer<'a> {\n /// approximation for purposes of line breaking).\n ///\n /// The \"input side\" of the printer is managed as an abstract process called\n-/// SCAN, which uses 'scan_stack', 'scan_stack_empty', 'top' and 'bottom', to\n-/// manage calculating 'size'. SCAN is, in other words, the process of\n-/// calculating 'size' entries.\n+/// SCAN, which uses 'scan_stack', to manage calculating 'size'. SCAN is, in\n+/// other words, the process of calculating 'size' entries.\n ///\n /// The \"output side\" of the printer is managed by an abstract process called\n /// PRINT, which uses 'print_stack', 'margin' and 'space' to figure out what to\n@@ -291,13 +283,7 @@ pub struct Printer<'a> {\n     /// Begin (if there is any) on top of it. Stuff is flushed off the\n     /// bottom as it becomes irrelevant due to the primary ring-buffer\n     /// advancing.\n-    scan_stack: Vec<usize> ,\n-    /// Top==bottom disambiguator\n-    scan_stack_empty: bool,\n-    /// Index of top of scan_stack\n-    top: usize,\n-    /// Index of bottom of scan_stack\n-    bottom: usize,\n+    scan_stack: VecDeque<usize> ,\n     /// Stack of blocks-in-progress being flushed by print\n     print_stack: Vec<PrintStackElem> ,\n     /// Buffered indentation to avoid writing trailing whitespace\n@@ -316,15 +302,15 @@ impl<'a> Printer<'a> {\n         debug!(\"pp Vec<{},{}>\", self.left, self.right);\n         match token {\n           Token::Eof => {\n-            if !self.scan_stack_empty {\n+            if !self.scan_stack.is_empty() {\n                 self.check_stack(0);\n                 self.advance_left()?;\n             }\n             self.indent(0);\n             Ok(())\n           }\n           Token::Begin(b) => {\n-            if self.scan_stack_empty {\n+            if self.scan_stack.is_empty() {\n                 self.left_total = 1;\n                 self.right_total = 1;\n                 self.left = 0;\n@@ -339,7 +325,7 @@ impl<'a> Printer<'a> {\n             Ok(())\n           }\n           Token::End => {\n-            if self.scan_stack_empty {\n+            if self.scan_stack.is_empty() {\n                 debug!(\"pp End/print Vec<{},{}>\", self.left, self.right);\n                 self.print(token, 0)\n             } else {\n@@ -353,7 +339,7 @@ impl<'a> Printer<'a> {\n             }\n           }\n           Token::Break(b) => {\n-            if self.scan_stack_empty {\n+            if self.scan_stack.is_empty() {\n                 self.left_total = 1;\n                 self.right_total = 1;\n                 self.left = 0;\n@@ -370,7 +356,7 @@ impl<'a> Printer<'a> {\n             Ok(())\n           }\n           Token::String(s, len) => {\n-            if self.scan_stack_empty {\n+            if self.scan_stack.is_empty() {\n                 debug!(\"pp String('{}')/print Vec<{},{}>\",\n                        s, self.left, self.right);\n                 self.print(Token::String(s, len), len)\n@@ -392,12 +378,10 @@ impl<'a> Printer<'a> {\n         if self.right_total - self.left_total > self.space {\n             debug!(\"scan window is {}, longer than space on line ({})\",\n                    self.right_total - self.left_total, self.space);\n-            if !self.scan_stack_empty {\n-                if self.left == self.scan_stack[self.bottom] {\n-                    debug!(\"setting {} to infinity and popping\", self.left);\n-                    let scanned = self.scan_pop_bottom();\n-                    self.size[scanned] = SIZE_INFINITY;\n-                }\n+            if Some(&self.left) == self.scan_stack.back() {\n+                debug!(\"setting {} to infinity and popping\", self.left);\n+                let scanned = self.scan_pop_bottom();\n+                self.size[scanned] = SIZE_INFINITY;\n             }\n             self.advance_left()?;\n             if self.left != self.right {\n@@ -408,43 +392,21 @@ impl<'a> Printer<'a> {\n     }\n     pub fn scan_push(&mut self, x: usize) {\n         debug!(\"scan_push {}\", x);\n-        if self.scan_stack_empty {\n-            self.scan_stack_empty = false;\n-        } else {\n-            self.top += 1;\n-            self.top %= self.buf_len;\n-            assert!((self.top != self.bottom));\n-        }\n-        self.scan_stack[self.top] = x;\n+        self.scan_stack.push_front(x);\n     }\n     pub fn scan_pop(&mut self) -> usize {\n-        assert!((!self.scan_stack_empty));\n-        let x = self.scan_stack[self.top];\n-        if self.top == self.bottom {\n-            self.scan_stack_empty = true;\n-        } else {\n-            self.top += self.buf_len - 1; self.top %= self.buf_len;\n-        }\n-        return x;\n+        self.scan_stack.pop_front().unwrap()\n     }\n     pub fn scan_top(&mut self) -> usize {\n-        assert!((!self.scan_stack_empty));\n-        return self.scan_stack[self.top];\n+        *self.scan_stack.front().unwrap()\n     }\n     pub fn scan_pop_bottom(&mut self) -> usize {\n-        assert!((!self.scan_stack_empty));\n-        let x = self.scan_stack[self.bottom];\n-        if self.top == self.bottom {\n-            self.scan_stack_empty = true;\n-        } else {\n-            self.bottom += 1; self.bottom %= self.buf_len;\n-        }\n-        return x;\n+        self.scan_stack.pop_back().unwrap()\n     }\n     pub fn advance_right(&mut self) {\n         self.right += 1;\n         self.right %= self.buf_len;\n-        assert!((self.right != self.left));\n+        assert!(self.right != self.left);\n     }\n     pub fn advance_left(&mut self) -> io::Result<()> {\n         debug!(\"advance_left Vec<{},{}>, sizeof({})={}\", self.left, self.right,\n@@ -481,7 +443,7 @@ impl<'a> Printer<'a> {\n         Ok(())\n     }\n     pub fn check_stack(&mut self, k: isize) {\n-        if !self.scan_stack_empty {\n+        if !self.scan_stack.is_empty() {\n             let x = self.scan_top();\n             match self.token[x] {\n                 Token::Begin(_) => {\n@@ -512,19 +474,16 @@ impl<'a> Printer<'a> {\n         let ret = write!(self.out, \"\\n\");\n         self.pending_indentation = 0;\n         self.indent(amount);\n-        return ret;\n+        ret\n     }\n     pub fn indent(&mut self, amount: isize) {\n         debug!(\"INDENT {}\", amount);\n         self.pending_indentation += amount;\n     }\n     pub fn get_top(&mut self) -> PrintStackElem {\n-        let print_stack = &mut self.print_stack;\n-        let n = print_stack.len();\n-        if n != 0 {\n-            (*print_stack)[n - 1]\n-        } else {\n-            PrintStackElem {\n+        match self.print_stack.last() {\n+            Some(el) => *el,\n+            None => PrintStackElem {\n                 offset: 0,\n                 pbreak: PrintStackBreak::Broken(Breaks::Inconsistent)\n             }\n@@ -538,7 +497,7 @@ impl<'a> Printer<'a> {\n         write!(self.out, \"{}\", s)\n     }\n     pub fn print(&mut self, token: Token, l: isize) -> io::Result<()> {\n-        debug!(\"print {} {} (remaining line space={})\", tok_str(&token), l,\n+        debug!(\"print {} {} (remaining line space={})\", token, l,\n                self.space);\n         debug!(\"{}\", buf_str(&self.token,\n                              &self.size,\n@@ -566,7 +525,7 @@ impl<'a> Printer<'a> {\n           Token::End => {\n             debug!(\"print End -> pop End\");\n             let print_stack = &mut self.print_stack;\n-            assert!((!print_stack.is_empty()));\n+            assert!(!print_stack.is_empty());\n             print_stack.pop().unwrap();\n             Ok(())\n           }\n@@ -603,12 +562,12 @@ impl<'a> Printer<'a> {\n               }\n             }\n           }\n-          Token::String(s, len) => {\n+          Token::String(ref s, len) => {\n             debug!(\"print String({})\", s);\n             assert_eq!(l, len);\n             // assert!(l <= space);\n             self.space -= len;\n-            self.print_str(&s[..])\n+            self.print_str(s)\n           }\n           Token::Eof => {\n             // Eof should never get here.\n@@ -652,15 +611,15 @@ pub fn eof(p: &mut Printer) -> io::Result<()> {\n }\n \n pub fn word(p: &mut Printer, wrd: &str) -> io::Result<()> {\n-    p.pretty_print(Token::String(/* bad */ wrd.to_string(), wrd.len() as isize))\n+    p.pretty_print(Token::String(wrd.to_string(), wrd.len() as isize))\n }\n \n pub fn huge_word(p: &mut Printer, wrd: &str) -> io::Result<()> {\n-    p.pretty_print(Token::String(/* bad */ wrd.to_string(), SIZE_INFINITY))\n+    p.pretty_print(Token::String(wrd.to_string(), SIZE_INFINITY))\n }\n \n pub fn zero_word(p: &mut Printer, wrd: &str) -> io::Result<()> {\n-    p.pretty_print(Token::String(/* bad */ wrd.to_string(), 0))\n+    p.pretty_print(Token::String(wrd.to_string(), 0))\n }\n \n pub fn spaces(p: &mut Printer, n: usize) -> io::Result<()> {"}, {"sha": "a72dac0d5dd68bbefee3e89b1be95a7b134fd61e", "filename": "src/test/compile-fail/issue-29124.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/43c5fef47dcaebea4c77771cc6f187b2a72b3639/src%2Ftest%2Fcompile-fail%2Fissue-29124.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c5fef47dcaebea4c77771cc6f187b2a72b3639/src%2Ftest%2Fcompile-fail%2Fissue-29124.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-29124.rs?ref=43c5fef47dcaebea4c77771cc6f187b2a72b3639", "patch": "@@ -25,11 +25,7 @@ fn main() {\n     obj::func.x();\n     //~^ ERROR no method named `x` found for type `fn() -> ret {obj::func}` in the current scope\n     //~^^ NOTE obj::func is a function, perhaps you wish to call it\n-    //~^^^ HELP try calling the base function:\n-    //~| SUGGESTION obj::func().x();\n     func.x();\n     //~^ ERROR no method named `x` found for type `fn() -> ret {func}` in the current scope\n     //~^^ NOTE func is a function, perhaps you wish to call it\n-    //~^^^ HELP try calling the base function:\n-    //~| SUGGESTION func().x();\n }"}, {"sha": "2b3df9ad1d83b7fe8dc02bb3fff1c65fec2bdfbd", "filename": "src/test/compile-fail/issue-31221.rs", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/43c5fef47dcaebea4c77771cc6f187b2a72b3639/src%2Ftest%2Fcompile-fail%2Fissue-31221.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c5fef47dcaebea4c77771cc6f187b2a72b3639/src%2Ftest%2Fcompile-fail%2Fissue-31221.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-31221.rs?ref=43c5fef47dcaebea4c77771cc6f187b2a72b3639", "patch": "@@ -0,0 +1,49 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+enum Enum {\n+    Var1,\n+    Var2,\n+}\n+\n+fn main() {\n+    use Enum::*;\n+    let s = Var1;\n+    match s {\n+        Var1 => (),\n+        Var3 => (),\n+        //~^ NOTE this pattern matches any value\n+        Var2 => (),\n+        //~^ ERROR unreachable pattern\n+    };\n+    match &s {\n+        &Var1 => (),\n+        &Var3 => (),\n+        //~^ NOTE this pattern matches any value\n+        &Var2 => (),\n+        //~^ ERROR unreachable pattern\n+    };\n+    let t = (Var1, Var1);\n+    match t {\n+        (Var1, b) => (),\n+        (c, d) => (),\n+        //~^ NOTE this pattern matches any value\n+        anything => ()\n+        //~^ ERROR unreachable pattern\n+    };\n+    // `_` need not emit a note, it is pretty obvious already.\n+    let t = (Var1, Var1);\n+    match t {\n+        (Var1, b) => (),\n+        _ => (),\n+        anything => ()\n+        //~^ ERROR unreachable pattern\n+    };\n+}"}]}