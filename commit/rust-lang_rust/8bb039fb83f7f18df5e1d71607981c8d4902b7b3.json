{"sha": "8bb039fb83f7f18df5e1d71607981c8d4902b7b3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhiYjAzOWZiODNmN2YxOGRmNWUxZDcxNjA3OTgxYzhkNDkwMmI3YjM=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-10-25T11:12:46Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-10-25T11:12:46Z"}, "message": "Rollup merge of #65315 - spastorino:intern-place-projection, r=oli-obk\n\nIntern place projection\n\nThis should sit on top of https://github.com/rust-lang/rust/pull/65197. After that one merged, I'm gonna rebase on top of it.\n\nThe important commits are the last three and there's a bunch of code repetition that I'm going to remove but for that I need to refactor some things that probably need to be added before this PR.\n\nAnyway this work helps as is because we can run perf tests :).\n\nr? @oli-obk /cc @nikomatsakis", "tree": {"sha": "a513250d67d60597678687ad0333f9aec9503e90", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a513250d67d60597678687ad0333f9aec9503e90"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8bb039fb83f7f18df5e1d71607981c8d4902b7b3", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdstivCRBK7hj4Ov3rIwAAdHIIAJUnnJUvpCv/liixCtdhl9cB\nQHHdwxiN4dko4iFOW3H1kDBK0Sgt8QARZ+mjOjFqQBfRqikFhZ9TLrnRDRRzVV5D\nAj+icT6o8iys1Nsz6n0tacFdKBOKn8M24fZJvBc7s0YbIJzSnzjyQ7vKrpj7/j4d\nqBf29TjEph3XDS5PZ1TAyvXaZuRRjlth0ift0f70Ua/lG9oCXsRROqmD7OwuQhT0\nAiq5/fgTajucb12tZuihYorSeOyPdQpcI4cw7s90NbVLS15cx8xYuA/uN3NOJrPM\nxPtQX+6pAi7urKHG5P3J5NjRgVfleJ6obSnbh3QDZAyLDMERx3OcHeO62M3yfbU=\n=RKx6\n-----END PGP SIGNATURE-----\n", "payload": "tree a513250d67d60597678687ad0333f9aec9503e90\nparent 1f93be1bb3f89d6b30a3ddc39e8a462924ccd503\nparent 5f5903df31ae1beea85fc49e765ed57212d5346a\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1572001966 +0200\ncommitter GitHub <noreply@github.com> 1572001966 +0200\n\nRollup merge of #65315 - spastorino:intern-place-projection, r=oli-obk\n\nIntern place projection\n\nThis should sit on top of https://github.com/rust-lang/rust/pull/65197. After that one merged, I'm gonna rebase on top of it.\n\nThe important commits are the last three and there's a bunch of code repetition that I'm going to remove but for that I need to refactor some things that probably need to be added before this PR.\n\nAnyway this work helps as is because we can run perf tests :).\n\nr? @oli-obk /cc @nikomatsakis\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8bb039fb83f7f18df5e1d71607981c8d4902b7b3", "html_url": "https://github.com/rust-lang/rust/commit/8bb039fb83f7f18df5e1d71607981c8d4902b7b3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8bb039fb83f7f18df5e1d71607981c8d4902b7b3/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1f93be1bb3f89d6b30a3ddc39e8a462924ccd503", "url": "https://api.github.com/repos/rust-lang/rust/commits/1f93be1bb3f89d6b30a3ddc39e8a462924ccd503", "html_url": "https://github.com/rust-lang/rust/commit/1f93be1bb3f89d6b30a3ddc39e8a462924ccd503"}, {"sha": "5f5903df31ae1beea85fc49e765ed57212d5346a", "url": "https://api.github.com/repos/rust-lang/rust/commits/5f5903df31ae1beea85fc49e765ed57212d5346a", "html_url": "https://github.com/rust-lang/rust/commit/5f5903df31ae1beea85fc49e765ed57212d5346a"}], "stats": {"total": 2204, "additions": 1147, "deletions": 1057}, "files": [{"sha": "fb9c95724c955e90e1225c6a5d9db99147c33dca", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 39, "deletions": 58, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/8bb039fb83f7f18df5e1d71607981c8d4902b7b3/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb039fb83f7f18df5e1d71607981c8d4902b7b3/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=8bb039fb83f7f18df5e1d71607981c8d4902b7b3", "patch": "@@ -15,8 +15,7 @@ use crate::ty::layout::VariantIdx;\n use crate::ty::print::{FmtPrinter, Printer};\n use crate::ty::subst::{Subst, SubstsRef};\n use crate::ty::{\n-    self, AdtDef, CanonicalUserTypeAnnotations, Region, Ty, TyCtxt,\n-    UserTypeAnnotationIndex,\n+    self, AdtDef, CanonicalUserTypeAnnotations, List, Region, Ty, TyCtxt, UserTypeAnnotationIndex,\n };\n \n use polonius_engine::Atom;\n@@ -1712,15 +1711,17 @@ impl Debug for Statement<'_> {\n /// A path to a value; something that can be evaluated without\n /// changing or disturbing program state.\n #[derive(\n-    Clone, PartialEq, Eq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable, HashStable,\n+    Clone, PartialEq, Eq, PartialOrd, Ord, Hash, RustcEncodable, HashStable,\n )]\n pub struct Place<'tcx> {\n     pub base: PlaceBase<'tcx>,\n \n     /// projection out of a place (access a field, deref a pointer, etc)\n-    pub projection: Box<[PlaceElem<'tcx>]>,\n+    pub projection: &'tcx List<PlaceElem<'tcx>>,\n }\n \n+impl<'tcx> rustc_serialize::UseSpecializedDecodable for Place<'tcx> {}\n+\n #[derive(\n     Clone, PartialEq, Eq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable, HashStable,\n )]\n@@ -1824,6 +1825,8 @@ impl<V, T> ProjectionElem<V, T> {\n /// and the index is a local.\n pub type PlaceElem<'tcx> = ProjectionElem<Local, Ty<'tcx>>;\n \n+impl<'tcx> Copy for PlaceElem<'tcx> { }\n+\n // At least on 64 bit systems, `PlaceElem` should not be larger than two pointers.\n #[cfg(target_arch = \"x86_64\")]\n static_assert_size!(PlaceElem<'_>, 16);\n@@ -1846,50 +1849,11 @@ pub struct PlaceRef<'a, 'tcx> {\n }\n \n impl<'tcx> Place<'tcx> {\n-    // FIXME change this back to a const when projection is a shared slice.\n-    //\n-    // pub const RETURN_PLACE: Place<'tcx> = Place {\n-    //     base: PlaceBase::Local(RETURN_PLACE),\n-    //     projection: &[],\n-    // };\n+    // FIXME change this to a const fn by also making List::empty a const fn.\n     pub fn return_place() -> Place<'tcx> {\n         Place {\n             base: PlaceBase::Local(RETURN_PLACE),\n-            projection: Box::new([]),\n-        }\n-    }\n-\n-    pub fn field(self, f: Field, ty: Ty<'tcx>) -> Place<'tcx> {\n-        self.elem(ProjectionElem::Field(f, ty))\n-    }\n-\n-    pub fn deref(self) -> Place<'tcx> {\n-        self.elem(ProjectionElem::Deref)\n-    }\n-\n-    pub fn downcast(self, adt_def: &'tcx AdtDef, variant_index: VariantIdx) -> Place<'tcx> {\n-        self.elem(ProjectionElem::Downcast(\n-            Some(adt_def.variants[variant_index].ident.name),\n-            variant_index,\n-        ))\n-    }\n-\n-    pub fn downcast_unnamed(self, variant_index: VariantIdx) -> Place<'tcx> {\n-        self.elem(ProjectionElem::Downcast(None, variant_index))\n-    }\n-\n-    pub fn index(self, index: Local) -> Place<'tcx> {\n-        self.elem(ProjectionElem::Index(index))\n-    }\n-\n-    pub fn elem(self, elem: PlaceElem<'tcx>) -> Place<'tcx> {\n-        // FIXME(spastorino): revisit this again once projection is not a Box<[T]> anymore\n-        let mut projection = self.projection.into_vec();\n-        projection.push(elem);\n-\n-        Place {\n-            base: self.base,\n-            projection: projection.into_boxed_slice(),\n+            projection: List::empty(),\n         }\n     }\n \n@@ -1906,26 +1870,23 @@ impl<'tcx> Place<'tcx> {\n     //\n     // FIXME: can we safely swap the semantics of `fn base_local` below in here instead?\n     pub fn local_or_deref_local(&self) -> Option<Local> {\n-        match self {\n-            Place {\n-                base: PlaceBase::Local(local),\n-                projection: box [],\n+        match self.as_ref() {\n+            PlaceRef {\n+                base: &PlaceBase::Local(local),\n+                projection: &[],\n             } |\n-            Place {\n-                base: PlaceBase::Local(local),\n-                projection: box [ProjectionElem::Deref],\n-            } => Some(*local),\n+            PlaceRef {\n+                base: &PlaceBase::Local(local),\n+                projection: &[ProjectionElem::Deref],\n+            } => Some(local),\n             _ => None,\n         }\n     }\n \n     /// If this place represents a local variable like `_X` with no\n     /// projections, return `Some(_X)`.\n     pub fn as_local(&self) -> Option<Local> {\n-        match self {\n-            Place { projection: box [], base: PlaceBase::Local(l) } => Some(*l),\n-            _ => None,\n-        }\n+        self.as_ref().as_local()\n     }\n \n     pub fn as_ref(&self) -> PlaceRef<'_, 'tcx> {\n@@ -1940,7 +1901,7 @@ impl From<Local> for Place<'_> {\n     fn from(local: Local) -> Self {\n         Place {\n             base: local.into(),\n-            projection: Box::new([]),\n+            projection: List::empty(),\n         }\n     }\n }\n@@ -1969,6 +1930,15 @@ impl<'a, 'tcx> PlaceRef<'a, 'tcx> {\n             _ => None,\n         }\n     }\n+\n+    /// If this place represents a local variable like `_X` with no\n+    /// projections, return `Some(_X)`.\n+    pub fn as_local(&self) -> Option<Local> {\n+        match self {\n+            PlaceRef { base: PlaceBase::Local(l), projection: [] } => Some(*l),\n+            _ => None,\n+        }\n+    }\n }\n \n impl Debug for Place<'_> {\n@@ -3182,6 +3152,17 @@ impl<'tcx> TypeFoldable<'tcx> for PlaceBase<'tcx> {\n     }\n }\n \n+impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::List<PlaceElem<'tcx>> {\n+    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+        let v = self.iter().map(|t| t.fold_with(folder)).collect::<Vec<_>>();\n+        folder.tcx().intern_place_elems(&v)\n+    }\n+\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+        self.iter().any(|t| t.visit_with(visitor))\n+    }\n+}\n+\n impl<'tcx> TypeFoldable<'tcx> for Static<'tcx> {\n     fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n         Static {"}, {"sha": "6a41b843e5794dd2ee0b2eadd57b75cfb8112379", "filename": "src/librustc/mir/visit.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8bb039fb83f7f18df5e1d71607981c8d4902b7b3/src%2Flibrustc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb039fb83f7f18df5e1d71607981c8d4902b7b3/src%2Flibrustc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fvisit.rs?ref=8bb039fb83f7f18df5e1d71607981c8d4902b7b3", "patch": "@@ -784,6 +784,8 @@ macro_rules! make_mir_visitor {\n \n macro_rules! visit_place_fns {\n     (mut) => (\n+        fn tcx<'a>(&'a self) -> TyCtxt<'tcx>;\n+\n         fn super_place(\n             &mut self,\n             place: &mut Place<'tcx>,\n@@ -793,19 +795,21 @@ macro_rules! visit_place_fns {\n             self.visit_place_base(&mut place.base, context, location);\n \n             if let Some(new_projection) = self.process_projection(&place.projection) {\n-                place.projection = new_projection;\n+                place.projection = self.tcx().intern_place_elems(&new_projection);\n             }\n         }\n \n         fn process_projection(\n             &mut self,\n             projection: &'a [PlaceElem<'tcx>],\n-        ) -> Option<Box<[PlaceElem<'tcx>]>> {\n+        ) -> Option<Vec<PlaceElem<'tcx>>> {\n             let mut projection = Cow::Borrowed(projection);\n \n             for i in 0..projection.len() {\n                 if let Some(elem) = projection.get(i) {\n                     if let Some(elem) = self.process_projection_elem(elem) {\n+                        // This converts the borrowed projection into `Cow::Owned(_)` and returns a\n+                        // clone of the projection so we can mutate and reintern later.\n                         let vec = projection.to_mut();\n                         vec[i] = elem;\n                     }\n@@ -814,7 +818,7 @@ macro_rules! visit_place_fns {\n \n             match projection {\n                 Cow::Borrowed(_) => None,\n-                Cow::Owned(vec) => Some(vec.into_boxed_slice()),\n+                Cow::Owned(vec) => Some(vec),\n             }\n         }\n "}, {"sha": "d5e7ac19263a0c13f2080b3d3a93f7619f790eb1", "filename": "src/librustc/ty/codec.rs", "status": "modified", "additions": 23, "deletions": 2, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/8bb039fb83f7f18df5e1d71607981c8d4902b7b3/src%2Flibrustc%2Fty%2Fcodec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb039fb83f7f18df5e1d71607981c8d4902b7b3/src%2Flibrustc%2Fty%2Fcodec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcodec.rs?ref=8bb039fb83f7f18df5e1d71607981c8d4902b7b3", "patch": "@@ -13,9 +13,9 @@ use rustc_data_structures::fx::FxHashMap;\n use rustc_serialize::{Decodable, Decoder, Encoder, Encodable, opaque};\n use std::hash::Hash;\n use std::intrinsics;\n-use crate::ty::{self, Ty, TyCtxt};\n+use crate::ty::{self, List, Ty, TyCtxt};\n use crate::ty::subst::SubstsRef;\n-use crate::mir::interpret::Allocation;\n+use crate::mir::{self, interpret::Allocation};\n use syntax_pos::Span;\n \n /// The shorthand encoding uses an enum's variant index `usize`\n@@ -218,6 +218,18 @@ where\n     Ok(tcx.mk_substs((0..len).map(|_| Decodable::decode(decoder)))?)\n }\n \n+#[inline]\n+pub fn decode_place<D>(decoder: &mut D) -> Result<mir::Place<'tcx>, D::Error>\n+where\n+    D: TyDecoder<'tcx>,\n+{\n+    let base: mir::PlaceBase<'tcx> = Decodable::decode(decoder)?;\n+    let len = decoder.read_usize()?;\n+    let projection: &'tcx List<mir::PlaceElem<'tcx>> =\n+        decoder.tcx().mk_place_elems((0..len).map(|_| Decodable::decode(decoder)))?;\n+    Ok(mir::Place { base, projection })\n+}\n+\n #[inline]\n pub fn decode_region<D>(decoder: &mut D) -> Result<ty::Region<'tcx>, D::Error>\n where\n@@ -413,6 +425,15 @@ macro_rules! implement_ty_decoder {\n                 }\n             }\n \n+            impl<$($typaram),*> SpecializedDecoder<$crate::mir::Place<'tcx>>\n+            for $DecoderName<$($typaram),*> {\n+                fn specialized_decode(\n+                    &mut self\n+                ) -> Result<$crate::mir::Place<'tcx>, Self::Error> {\n+                    decode_place(self)\n+                }\n+            }\n+\n             impl<$($typaram),*> SpecializedDecoder<ty::Region<'tcx>>\n             for $DecoderName<$($typaram),*> {\n                 fn specialized_decode(&mut self) -> Result<ty::Region<'tcx>, Self::Error> {"}, {"sha": "f958a7e357b398736682d5de5a904e98ef826797", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 68, "deletions": 2, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/8bb039fb83f7f18df5e1d71607981c8d4902b7b3/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb039fb83f7f18df5e1d71607981c8d4902b7b3/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=8bb039fb83f7f18df5e1d71607981c8d4902b7b3", "patch": "@@ -1,3 +1,4 @@\n+// ignore-tidy-filelength\n //! Type context book-keeping.\n \n use crate::arena::Arena;\n@@ -21,7 +22,7 @@ use crate::middle::cstore::EncodedMetadata;\n use crate::middle::lang_items;\n use crate::middle::resolve_lifetime::{self, ObjectLifetimeDefault};\n use crate::middle::stability;\n-use crate::mir::{Body, interpret, ProjectionKind, Promoted};\n+use crate::mir::{Body, Field, interpret, Local, Place, PlaceElem, ProjectionKind, Promoted};\n use crate::mir::interpret::{ConstValue, Allocation, Scalar};\n use crate::ty::subst::{GenericArg, InternalSubsts, SubstsRef, Subst};\n use crate::ty::ReprOptions;\n@@ -106,6 +107,7 @@ pub struct CtxtInterners<'tcx> {\n     goal: InternedSet<'tcx, GoalKind<'tcx>>,\n     goal_list: InternedSet<'tcx, List<Goal<'tcx>>>,\n     projs: InternedSet<'tcx, List<ProjectionKind>>,\n+    place_elems: InternedSet<'tcx, List<PlaceElem<'tcx>>>,\n     const_: InternedSet<'tcx, Const<'tcx>>,\n }\n \n@@ -124,6 +126,7 @@ impl<'tcx> CtxtInterners<'tcx> {\n             goal: Default::default(),\n             goal_list: Default::default(),\n             projs: Default::default(),\n+            place_elems: Default::default(),\n             const_: Default::default(),\n         }\n     }\n@@ -2142,6 +2145,13 @@ impl<'tcx> Borrow<[ProjectionKind]>\n     }\n }\n \n+impl<'tcx> Borrow<[PlaceElem<'tcx>]>\n+    for Interned<'tcx, List<PlaceElem<'tcx>>> {\n+    fn borrow(&self) -> &[PlaceElem<'tcx>] {\n+        &self.0[..]\n+    }\n+}\n+\n impl<'tcx> Borrow<RegionKind> for Interned<'tcx, RegionKind> {\n     fn borrow(&self) -> &RegionKind {\n         &self.0\n@@ -2242,7 +2252,8 @@ slice_interners!(\n     predicates: _intern_predicates(Predicate<'tcx>),\n     clauses: _intern_clauses(Clause<'tcx>),\n     goal_list: _intern_goals(Goal<'tcx>),\n-    projs: _intern_projs(ProjectionKind)\n+    projs: _intern_projs(ProjectionKind),\n+    place_elems: _intern_place_elems(PlaceElem<'tcx>)\n );\n \n impl<'tcx> TyCtxt<'tcx> {\n@@ -2584,6 +2595,48 @@ impl<'tcx> TyCtxt<'tcx> {\n         self.mk_ty(Opaque(def_id, substs))\n     }\n \n+    pub fn mk_place_field(self, place: Place<'tcx>, f: Field, ty: Ty<'tcx>) -> Place<'tcx> {\n+        self.mk_place_elem(place, PlaceElem::Field(f, ty))\n+    }\n+\n+    pub fn mk_place_deref(self, place: Place<'tcx>) -> Place<'tcx> {\n+        self.mk_place_elem(place, PlaceElem::Deref)\n+    }\n+\n+    pub fn mk_place_downcast(\n+        self,\n+        place: Place<'tcx>,\n+        adt_def: &'tcx AdtDef,\n+        variant_index: VariantIdx,\n+    ) -> Place<'tcx> {\n+        self.mk_place_elem(\n+            place,\n+            PlaceElem::Downcast(Some(adt_def.variants[variant_index].ident.name), variant_index),\n+        )\n+    }\n+\n+    pub fn mk_place_downcast_unnamed(\n+        self,\n+        place: Place<'tcx>,\n+        variant_index: VariantIdx,\n+    ) -> Place<'tcx> {\n+        self.mk_place_elem(place, PlaceElem::Downcast(None, variant_index))\n+    }\n+\n+    pub fn mk_place_index(self, place: Place<'tcx>, index: Local) -> Place<'tcx> {\n+        self.mk_place_elem(place, PlaceElem::Index(index))\n+    }\n+\n+    /// This method copies `Place`'s projection, add an element and reintern it. Should not be used\n+    /// to build a full `Place` it's just a convenient way to grab a projection and modify it in\n+    /// flight.\n+    pub fn mk_place_elem(self, place: Place<'tcx>, elem: PlaceElem<'tcx>) -> Place<'tcx> {\n+        let mut projection = place.projection.to_vec();\n+        projection.push(elem);\n+\n+        Place { base: place.base, projection: self.intern_place_elems(&projection) }\n+    }\n+\n     pub fn intern_existential_predicates(self, eps: &[ExistentialPredicate<'tcx>])\n         -> &'tcx List<ExistentialPredicate<'tcx>> {\n         assert!(!eps.is_empty());\n@@ -2628,6 +2681,14 @@ impl<'tcx> TyCtxt<'tcx> {\n         }\n     }\n \n+    pub fn intern_place_elems(self, ts: &[PlaceElem<'tcx>]) -> &'tcx List<PlaceElem<'tcx>> {\n+        if ts.len() == 0 {\n+            List::empty()\n+        } else {\n+            self._intern_place_elems(ts)\n+        }\n+    }\n+\n     pub fn intern_canonical_var_infos(self, ts: &[CanonicalVarInfo]) -> CanonicalVarInfos<'tcx> {\n         if ts.len() == 0 {\n             List::empty()\n@@ -2690,6 +2751,11 @@ impl<'tcx> TyCtxt<'tcx> {\n         iter.intern_with(|xs| self.intern_substs(xs))\n     }\n \n+    pub fn mk_place_elems<I: InternAs<[PlaceElem<'tcx>],\n+                          &'tcx List<PlaceElem<'tcx>>>>(self, iter: I) -> I::Output {\n+        iter.intern_with(|xs| self.intern_place_elems(xs))\n+    }\n+\n     pub fn mk_substs_trait(self,\n                      self_ty: Ty<'tcx>,\n                      rest: &[GenericArg<'tcx>])"}, {"sha": "604deffcf949bd7ffad5df2bc583f34ccb310f04", "filename": "src/librustc_codegen_ssa/mir/analyze.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8bb039fb83f7f18df5e1d71607981c8d4902b7b3/src%2Flibrustc_codegen_ssa%2Fmir%2Fanalyze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb039fb83f7f18df5e1d71607981c8d4902b7b3/src%2Flibrustc_codegen_ssa%2Fmir%2Fanalyze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fanalyze.rs?ref=8bb039fb83f7f18df5e1d71607981c8d4902b7b3", "patch": "@@ -191,10 +191,7 @@ impl<'mir, 'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> Visitor<'tcx>\n                     location: Location) {\n         debug!(\"visit_assign(place={:?}, rvalue={:?})\", place, rvalue);\n \n-        if let mir::Place {\n-            base: mir::PlaceBase::Local(index),\n-            projection: box [],\n-        } = *place {\n+        if let Some(index) = place.as_local() {\n             self.assign(index, location);\n             let decl_span = self.fx.mir.local_decls[index].source_info.span;\n             if !self.fx.rvalue_creates_operand(rvalue, decl_span) {"}, {"sha": "28441cae26e3fb3025bd085071b2374d05995690", "filename": "src/librustc_codegen_ssa/mir/block.rs", "status": "modified", "additions": 34, "deletions": 50, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/8bb039fb83f7f18df5e1d71607981c8d4902b7b3/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb039fb83f7f18df5e1d71607981c8d4902b7b3/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs?ref=8bb039fb83f7f18df5e1d71607981c8d4902b7b3", "patch": "@@ -2,7 +2,7 @@ use rustc_index::vec::Idx;\n use rustc::middle::lang_items;\n use rustc::ty::{self, Ty, TypeFoldable, Instance};\n use rustc::ty::layout::{self, LayoutOf, HasTyCtxt, FnTypeExt};\n-use rustc::mir::{self, Place, PlaceBase, Static, StaticKind};\n+use rustc::mir::{self, PlaceBase, Static, StaticKind};\n use rustc::mir::interpret::PanicInfo;\n use rustc_target::abi::call::{ArgType, FnType, PassMode};\n use rustc_target::spec::abi::Abi;\n@@ -630,53 +630,43 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 // checked by const-qualification, which also\n                 // promotes any complex rvalues to constants.\n                 if i == 2 && intrinsic.unwrap().starts_with(\"simd_shuffle\") {\n-                    match *arg {\n+                    match arg {\n                         // The shuffle array argument is usually not an explicit constant,\n                         // but specified directly in the code. This means it gets promoted\n                         // and we can then extract the value by evaluating the promoted.\n-                        mir::Operand::Copy(\n-                            Place {\n-                                base: PlaceBase::Static(box Static {\n-                                    kind: StaticKind::Promoted(promoted, _),\n+                        mir::Operand::Copy(place) | mir::Operand::Move(place) => {\n+                            if let mir::PlaceRef {\n+                                base:\n+                                    &PlaceBase::Static(box Static {\n+                                        kind: StaticKind::Promoted(promoted, _),\n+                                        ty,\n+                                        def_id: _,\n+                                    }),\n+                                projection: &[],\n+                            } = place.as_ref()\n+                            {\n+                                let param_env = ty::ParamEnv::reveal_all();\n+                                let cid = mir::interpret::GlobalId {\n+                                    instance: self.instance,\n+                                    promoted: Some(promoted),\n+                                };\n+                                let c = bx.tcx().const_eval(param_env.and(cid));\n+                                let (llval, ty) = self.simd_shuffle_indices(\n+                                    &bx,\n+                                    terminator.source_info.span,\n                                     ty,\n-                                    def_id: _,\n-                                }),\n-                                projection: box [],\n+                                    c,\n+                                );\n+                                return OperandRef {\n+                                    val: Immediate(llval),\n+                                    layout: bx.layout_of(ty),\n+                                };\n+                            } else {\n+                                span_bug!(span, \"shuffle indices must be constant\");\n                             }\n-                        ) |\n-                        mir::Operand::Move(\n-                            Place {\n-                                base: PlaceBase::Static(box Static {\n-                                    kind: StaticKind::Promoted(promoted, _),\n-                                    ty,\n-                                    def_id: _,\n-                                }),\n-                                projection: box [],\n-                            }\n-                        ) => {\n-                            let param_env = ty::ParamEnv::reveal_all();\n-                            let cid = mir::interpret::GlobalId {\n-                                instance: self.instance,\n-                                promoted: Some(promoted),\n-                            };\n-                            let c = bx.tcx().const_eval(param_env.and(cid));\n-                            let (llval, ty) = self.simd_shuffle_indices(\n-                                &bx,\n-                                terminator.source_info.span,\n-                                ty,\n-                                c,\n-                            );\n-                            return OperandRef {\n-                                val: Immediate(llval),\n-                                layout: bx.layout_of(ty),\n-                            };\n-\n-                        }\n-                        mir::Operand::Copy(_) |\n-                        mir::Operand::Move(_) => {\n-                            span_bug!(span, \"shuffle indices must be constant\");\n                         }\n-                        mir::Operand::Constant(ref constant) => {\n+\n+                        mir::Operand::Constant(constant) => {\n                             let c = self.eval_mir_constant(constant);\n                             let (llval, ty) = self.simd_shuffle_indices(\n                                 &bx,\n@@ -1117,10 +1107,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         if fn_ret.is_ignore() {\n             return ReturnDest::Nothing;\n         }\n-        let dest = if let mir::Place {\n-            base: mir::PlaceBase::Local(index),\n-            projection: box [],\n-        } = *dest {\n+        let dest = if let Some(index) = dest.as_local() {\n             match self.locals[index] {\n                 LocalRef::Place(dest) => dest,\n                 LocalRef::UnsizedPlace(_) => bug!(\"return type must be sized\"),\n@@ -1178,10 +1165,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         src: &mir::Operand<'tcx>,\n         dst: &mir::Place<'tcx>\n     ) {\n-        if let mir::Place {\n-            base: mir::PlaceBase::Local(index),\n-            projection: box [],\n-        } = *dst {\n+        if let Some(index) = dst.as_local() {\n             match self.locals[index] {\n                 LocalRef::Place(place) => self.codegen_transmute_into(bx, src, place),\n                 LocalRef::UnsizedPlace(_) => bug!(\"transmute must not involve unsized locals\"),"}, {"sha": "1608f222bc614f6de0606052719af0bc00427c05", "filename": "src/librustc_codegen_ssa/mir/rvalue.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8bb039fb83f7f18df5e1d71607981c8d4902b7b3/src%2Flibrustc_codegen_ssa%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb039fb83f7f18df5e1d71607981c8d4902b7b3/src%2Flibrustc_codegen_ssa%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Frvalue.rs?ref=8bb039fb83f7f18df5e1d71607981c8d4902b7b3", "patch": "@@ -530,10 +530,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n     ) -> Bx::Value {\n         // ZST are passed as operands and require special handling\n         // because codegen_place() panics if Local is operand.\n-        if let mir::Place {\n-            base: mir::PlaceBase::Local(index),\n-            projection: box [],\n-        } = *place {\n+        if let Some(index) = place.as_local() {\n             if let LocalRef::Operand(Some(op)) = self.locals[index] {\n                 if let ty::Array(_, n) = op.layout.ty.kind {\n                     let n = n.eval_usize(bx.cx().tcx(), ty::ParamEnv::reveal_all());"}, {"sha": "43d5c2570b705e4f66cd4a68deec17679bd90c84", "filename": "src/librustc_codegen_ssa/mir/statement.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/8bb039fb83f7f18df5e1d71607981c8d4902b7b3/src%2Flibrustc_codegen_ssa%2Fmir%2Fstatement.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb039fb83f7f18df5e1d71607981c8d4902b7b3/src%2Flibrustc_codegen_ssa%2Fmir%2Fstatement.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fstatement.rs?ref=8bb039fb83f7f18df5e1d71607981c8d4902b7b3", "patch": "@@ -17,11 +17,8 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         self.set_debug_loc(&mut bx, statement.source_info);\n         match statement.kind {\n             mir::StatementKind::Assign(box(ref place, ref rvalue)) => {\n-                if let mir::Place {\n-                    base: mir::PlaceBase::Local(index),\n-                    projection: box [],\n-                } = place {\n-                    match self.locals[*index] {\n+                if let Some(index) = place.as_local() {\n+                    match self.locals[index] {\n                         LocalRef::Place(cg_dest) => {\n                             self.codegen_rvalue(bx, cg_dest, rvalue)\n                         }\n@@ -30,7 +27,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                         }\n                         LocalRef::Operand(None) => {\n                             let (mut bx, operand) = self.codegen_rvalue_operand(bx, rvalue);\n-                            if let Some(name) = self.mir.local_decls[*index].name {\n+                            if let Some(name) = self.mir.local_decls[index].name {\n                                 match operand.val {\n                                     OperandValue::Ref(x, ..) |\n                                     OperandValue::Immediate(x) => {\n@@ -44,7 +41,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                                     }\n                                 }\n                             }\n-                            self.locals[*index] = LocalRef::Operand(Some(operand));\n+                            self.locals[index] = LocalRef::Operand(Some(operand));\n                             bx\n                         }\n                         LocalRef::Operand(Some(op)) => {"}, {"sha": "98641031c1787514ca2e461d5bf8b36f3cf5e588", "filename": "src/librustc_mir/borrow_check/borrow_set.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8bb039fb83f7f18df5e1d71607981c8d4902b7b3/src%2Flibrustc_mir%2Fborrow_check%2Fborrow_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb039fb83f7f18df5e1d71607981c8d4902b7b3/src%2Flibrustc_mir%2Fborrow_check%2Fborrow_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fborrow_set.rs?ref=8bb039fb83f7f18df5e1d71607981c8d4902b7b3", "patch": "@@ -315,10 +315,7 @@ impl<'a, 'tcx> GatherBorrows<'a, 'tcx> {\n         //    TEMP = &foo\n         //\n         // so extract `temp`.\n-        let temp = if let &mir::Place {\n-            base: mir::PlaceBase::Local(temp),\n-            projection: box [],\n-        } = assigned_place {\n+        let temp = if let Some(temp) = assigned_place.as_local() {\n             temp\n         } else {\n             span_bug!("}, {"sha": "36db68a3372eb9ef9a4afdfcb5498c3432637a32", "filename": "src/librustc_mir/borrow_check/conflict_errors.rs", "status": "modified", "additions": 151, "deletions": 168, "changes": 319, "blob_url": "https://github.com/rust-lang/rust/blob/8bb039fb83f7f18df5e1d71607981c8d4902b7b3/src%2Flibrustc_mir%2Fborrow_check%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb039fb83f7f18df5e1d71607981c8d4902b7b3/src%2Flibrustc_mir%2Fborrow_check%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fconflict_errors.rs?ref=8bb039fb83f7f18df5e1d71607981c8d4902b7b3", "patch": "@@ -239,11 +239,8 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                         );\n                     }\n                 }\n-                let span = if let Place {\n-                    base: PlaceBase::Local(local),\n-                    projection: box [],\n-                } = place {\n-                    let decl = &self.body.local_decls[*local];\n+                let span = if let Some(local) = place.as_local() {\n+                    let decl = &self.body.local_decls[local];\n                     Some(decl.source_info.span)\n                 } else {\n                     None\n@@ -611,7 +608,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                     projection,\n                 } = first_borrowed_place;\n \n-                let mut cursor = &**projection;\n+                let mut cursor = projection.as_ref();\n                 while let [proj_base @ .., elem] = cursor {\n                     cursor = proj_base;\n \n@@ -635,7 +632,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                     projection,\n                 } = second_borrowed_place;\n \n-                let mut cursor = &**projection;\n+                let mut cursor = projection.as_ref();\n                 while let [proj_base @ .., elem] = cursor {\n                     cursor = proj_base;\n \n@@ -710,10 +707,12 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             _ => drop_span,\n         };\n \n+        let root_place_projection = self.infcx.tcx.intern_place_elems(root_place.projection);\n+\n         if self.access_place_error_reported\n             .contains(&(Place {\n                 base: root_place.base.clone(),\n-                projection: root_place.projection.to_vec().into_boxed_slice(),\n+                projection: root_place_projection,\n             }, borrow_span))\n         {\n             debug!(\n@@ -726,7 +725,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         self.access_place_error_reported\n             .insert((Place {\n                 base: root_place.base.clone(),\n-                projection: root_place.projection.to_vec().into_boxed_slice(),\n+                projection: root_place_projection,\n             }, borrow_span));\n \n         if let StorageDeadOrDrop::Destructor(dropped_ty) =\n@@ -1124,26 +1123,22 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         };\n \n         let (place_desc, note) = if let Some(place_desc) = opt_place_desc {\n-            let local_kind = match borrow.borrowed_place {\n-                Place {\n-                    base: PlaceBase::Local(local),\n-                    projection: box [],\n-                } => {\n-                    match self.body.local_kind(local) {\n-                        LocalKind::ReturnPointer\n-                        | LocalKind::Temp => bug!(\"temporary or return pointer with a name\"),\n-                        LocalKind::Var => \"local variable \",\n-                        LocalKind::Arg\n-                        if !self.upvars.is_empty()\n-                            && local == Local::new(1) => {\n-                            \"variable captured by `move` \"\n-                        }\n-                        LocalKind::Arg => {\n-                            \"function parameter \"\n-                        }\n+            let local_kind = if let Some(local) = borrow.borrowed_place.as_local() {\n+                match self.body.local_kind(local) {\n+                    LocalKind::ReturnPointer\n+                    | LocalKind::Temp => bug!(\"temporary or return pointer with a name\"),\n+                    LocalKind::Var => \"local variable \",\n+                    LocalKind::Arg\n+                    if !self.upvars.is_empty()\n+                        && local == Local::new(1) => {\n+                        \"variable captured by `move` \"\n+                    }\n+                    LocalKind::Arg => {\n+                        \"function parameter \"\n                     }\n                 }\n-                _ => \"local data \",\n+            } else {\n+                \"local data \"\n             };\n             (\n                 format!(\"{}`{}`\", local_kind, place_desc),\n@@ -1480,10 +1475,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         assigned_span: Span,\n         err_place: &Place<'tcx>,\n     ) {\n-        let (from_arg, local_decl) = if let Place {\n-            base: PlaceBase::Local(local),\n-            projection: box [],\n-        } = *err_place {\n+        let (from_arg, local_decl) = if let Some(local) = err_place.as_local() {\n             if let LocalKind::Arg = self.body.local_kind(local) {\n                 (true, Some(&self.body.local_decls[local]))\n             } else {\n@@ -1643,11 +1635,8 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 reservation\n             );\n             // Check that the initial assignment of the reserve location is into a temporary.\n-            let mut target = *match reservation {\n-                Place {\n-                    base: PlaceBase::Local(local),\n-                    projection: box [],\n-                } if self.body.local_kind(*local) == LocalKind::Temp => local,\n+            let mut target = match reservation.as_local() {\n+                Some(local) if self.body.local_kind(local) == LocalKind::Temp => local,\n                 _ => return None,\n             };\n \n@@ -1659,127 +1648,122 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                     \"annotate_argument_and_return_for_borrow: target={:?} stmt={:?}\",\n                     target, stmt\n                 );\n-                if let StatementKind::Assign(\n-                    box(\n-                        Place {\n-                            base: PlaceBase::Local(assigned_to),\n-                            projection: box [],\n-                        },\n-                        rvalue\n-                    )\n-                ) = &stmt.kind {\n-                    debug!(\n-                        \"annotate_argument_and_return_for_borrow: assigned_to={:?} \\\n-                         rvalue={:?}\",\n-                        assigned_to, rvalue\n-                    );\n-                    // Check if our `target` was captured by a closure.\n-                    if let Rvalue::Aggregate(\n-                        box AggregateKind::Closure(def_id, substs),\n-                        operands,\n-                    ) = rvalue\n-                    {\n-                        for operand in operands {\n-                            let assigned_from = match operand {\n-                                Operand::Copy(assigned_from) | Operand::Move(assigned_from) => {\n+                if let StatementKind::Assign(box(place, rvalue)) = &stmt.kind {\n+                    if let Some(assigned_to) = place.as_local() {\n+                        debug!(\n+                            \"annotate_argument_and_return_for_borrow: assigned_to={:?} \\\n+                             rvalue={:?}\",\n+                            assigned_to, rvalue\n+                        );\n+                        // Check if our `target` was captured by a closure.\n+                        if let Rvalue::Aggregate(\n+                            box AggregateKind::Closure(def_id, substs),\n+                            operands,\n+                        ) = rvalue\n+                        {\n+                            for operand in operands {\n+                                let assigned_from = match operand {\n+                                    Operand::Copy(assigned_from) | Operand::Move(assigned_from) => {\n+                                        assigned_from\n+                                    }\n+                                    _ => continue,\n+                                };\n+                                debug!(\n+                                    \"annotate_argument_and_return_for_borrow: assigned_from={:?}\",\n                                     assigned_from\n-                                }\n-                                _ => continue,\n-                            };\n-                            debug!(\n-                                \"annotate_argument_and_return_for_borrow: assigned_from={:?}\",\n-                                assigned_from\n-                            );\n+                                );\n \n-                            // Find the local from the operand.\n-                            let assigned_from_local = match assigned_from.local_or_deref_local() {\n-                                Some(local) => local,\n-                                None => continue,\n-                            };\n+                                // Find the local from the operand.\n+                                let assigned_from_local = match assigned_from.local_or_deref_local()\n+                                {\n+                                    Some(local) => local,\n+                                    None => continue,\n+                                };\n \n-                            if assigned_from_local != target {\n-                                continue;\n-                            }\n-\n-                            // If a closure captured our `target` and then assigned\n-                            // into a place then we should annotate the closure in\n-                            // case it ends up being assigned into the return place.\n-                            annotated_closure = self.annotate_fn_sig(\n-                                *def_id,\n-                                self.infcx.closure_sig(*def_id, *substs),\n-                            );\n-                            debug!(\n-                                \"annotate_argument_and_return_for_borrow: \\\n-                                 annotated_closure={:?} assigned_from_local={:?} \\\n-                                 assigned_to={:?}\",\n-                                annotated_closure, assigned_from_local, assigned_to\n-                            );\n+                                if assigned_from_local != target {\n+                                    continue;\n+                                }\n \n-                            if *assigned_to == mir::RETURN_PLACE {\n-                                // If it was assigned directly into the return place, then\n-                                // return now.\n-                                return annotated_closure;\n-                            } else {\n-                                // Otherwise, update the target.\n-                                target = *assigned_to;\n+                                // If a closure captured our `target` and then assigned\n+                                // into a place then we should annotate the closure in\n+                                // case it ends up being assigned into the return place.\n+                                annotated_closure = self.annotate_fn_sig(\n+                                    *def_id,\n+                                    self.infcx.closure_sig(*def_id, *substs),\n+                                );\n+                                debug!(\n+                                    \"annotate_argument_and_return_for_borrow: \\\n+                                     annotated_closure={:?} assigned_from_local={:?} \\\n+                                     assigned_to={:?}\",\n+                                    annotated_closure, assigned_from_local, assigned_to\n+                                );\n+\n+                                if assigned_to == mir::RETURN_PLACE {\n+                                    // If it was assigned directly into the return place, then\n+                                    // return now.\n+                                    return annotated_closure;\n+                                } else {\n+                                    // Otherwise, update the target.\n+                                    target = assigned_to;\n+                                }\n                             }\n-                        }\n \n-                        // If none of our closure's operands matched, then skip to the next\n-                        // statement.\n-                        continue;\n-                    }\n+                            // If none of our closure's operands matched, then skip to the next\n+                            // statement.\n+                            continue;\n+                        }\n \n-                    // Otherwise, look at other types of assignment.\n-                    let assigned_from = match rvalue {\n-                        Rvalue::Ref(_, _, assigned_from) => assigned_from,\n-                        Rvalue::Use(operand) => match operand {\n-                            Operand::Copy(assigned_from) | Operand::Move(assigned_from) => {\n-                                assigned_from\n-                            }\n+                        // Otherwise, look at other types of assignment.\n+                        let assigned_from = match rvalue {\n+                            Rvalue::Ref(_, _, assigned_from) => assigned_from,\n+                            Rvalue::Use(operand) => match operand {\n+                                Operand::Copy(assigned_from) | Operand::Move(assigned_from) => {\n+                                    assigned_from\n+                                }\n+                                _ => continue,\n+                            },\n                             _ => continue,\n-                        },\n-                        _ => continue,\n-                    };\n-                    debug!(\n-                        \"annotate_argument_and_return_for_borrow: \\\n-                         assigned_from={:?}\",\n-                        assigned_from,\n-                    );\n+                        };\n+                        debug!(\n+                            \"annotate_argument_and_return_for_borrow: \\\n+                             assigned_from={:?}\",\n+                            assigned_from,\n+                        );\n \n-                    // Find the local from the rvalue.\n-                    let assigned_from_local = match assigned_from.local_or_deref_local() {\n-                        Some(local) => local,\n-                        None => continue,\n-                    };\n-                    debug!(\n-                        \"annotate_argument_and_return_for_borrow: \\\n-                         assigned_from_local={:?}\",\n-                        assigned_from_local,\n-                    );\n+                        // Find the local from the rvalue.\n+                        let assigned_from_local = match assigned_from.local_or_deref_local() {\n+                            Some(local) => local,\n+                            None => continue,\n+                        };\n+                        debug!(\n+                            \"annotate_argument_and_return_for_borrow: \\\n+                             assigned_from_local={:?}\",\n+                            assigned_from_local,\n+                        );\n \n-                    // Check if our local matches the target - if so, we've assigned our\n-                    // borrow to a new place.\n-                    if assigned_from_local != target {\n-                        continue;\n-                    }\n+                        // Check if our local matches the target - if so, we've assigned our\n+                        // borrow to a new place.\n+                        if assigned_from_local != target {\n+                            continue;\n+                        }\n \n-                    // If we assigned our `target` into a new place, then we should\n-                    // check if it was the return place.\n-                    debug!(\n-                        \"annotate_argument_and_return_for_borrow: \\\n-                         assigned_from_local={:?} assigned_to={:?}\",\n-                        assigned_from_local, assigned_to\n-                    );\n-                    if *assigned_to == mir::RETURN_PLACE {\n-                        // If it was then return the annotated closure if there was one,\n-                        // else, annotate this function.\n-                        return annotated_closure.or_else(fallback);\n-                    }\n+                        // If we assigned our `target` into a new place, then we should\n+                        // check if it was the return place.\n+                        debug!(\n+                            \"annotate_argument_and_return_for_borrow: \\\n+                             assigned_from_local={:?} assigned_to={:?}\",\n+                            assigned_from_local, assigned_to\n+                        );\n+                        if assigned_to == mir::RETURN_PLACE {\n+                            // If it was then return the annotated closure if there was one,\n+                            // else, annotate this function.\n+                            return annotated_closure.or_else(fallback);\n+                        }\n \n-                    // If we didn't assign into the return place, then we just update\n-                    // the target.\n-                    target = *assigned_to;\n+                        // If we didn't assign into the return place, then we just update\n+                        // the target.\n+                        target = assigned_to;\n+                    }\n                 }\n             }\n \n@@ -1790,38 +1774,37 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 target, terminator\n             );\n             if let TerminatorKind::Call {\n-                destination: Some((Place {\n-                    base: PlaceBase::Local(assigned_to),\n-                    projection: box [],\n-                }, _)),\n+                destination: Some((place, _)),\n                 args,\n                 ..\n             } = &terminator.kind\n             {\n-                debug!(\n-                    \"annotate_argument_and_return_for_borrow: assigned_to={:?} args={:?}\",\n-                    assigned_to, args\n-                );\n-                for operand in args {\n-                    let assigned_from = match operand {\n-                        Operand::Copy(assigned_from) | Operand::Move(assigned_from) => {\n-                            assigned_from\n-                        }\n-                        _ => continue,\n-                    };\n+                if let Some(assigned_to) = place.as_local() {\n                     debug!(\n-                        \"annotate_argument_and_return_for_borrow: assigned_from={:?}\",\n-                        assigned_from,\n+                        \"annotate_argument_and_return_for_borrow: assigned_to={:?} args={:?}\",\n+                        assigned_to, args\n                     );\n-\n-                    if let Some(assigned_from_local) = assigned_from.local_or_deref_local() {\n+                    for operand in args {\n+                        let assigned_from = match operand {\n+                            Operand::Copy(assigned_from) | Operand::Move(assigned_from) => {\n+                                assigned_from\n+                            }\n+                            _ => continue,\n+                        };\n                         debug!(\n-                            \"annotate_argument_and_return_for_borrow: assigned_from_local={:?}\",\n-                            assigned_from_local,\n+                            \"annotate_argument_and_return_for_borrow: assigned_from={:?}\",\n+                            assigned_from,\n                         );\n \n-                        if *assigned_to == mir::RETURN_PLACE && assigned_from_local == target {\n-                            return annotated_closure.or_else(fallback);\n+                        if let Some(assigned_from_local) = assigned_from.local_or_deref_local() {\n+                            debug!(\n+                                \"annotate_argument_and_return_for_borrow: assigned_from_local={:?}\",\n+                                assigned_from_local,\n+                            );\n+\n+                            if assigned_to == mir::RETURN_PLACE && assigned_from_local == target {\n+                                return annotated_closure.or_else(fallback);\n+                            }\n                         }\n                     }\n                 }"}, {"sha": "4036e9db33b34ca7cadad224c5407279b10634d3", "filename": "src/librustc_mir/borrow_check/error_reporting.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/8bb039fb83f7f18df5e1d71607981c8d4902b7b3/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb039fb83f7f18df5e1d71607981c8d4902b7b3/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs?ref=8bb039fb83f7f18df5e1d71607981c8d4902b7b3", "patch": "@@ -838,12 +838,15 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             .get(location.statement_index)\n         {\n             Some(&Statement {\n-                kind: StatementKind::Assign(box(Place {\n-                    base: PlaceBase::Local(local),\n-                    projection: box [],\n-                }, _)),\n+                kind: StatementKind::Assign(box(ref place, _)),\n                 ..\n-            }) => local,\n+            }) => {\n+                if let Some(local) = place.as_local() {\n+                    local\n+                } else {\n+                    return OtherUse(use_span);\n+                }\n+            }\n             _ => return OtherUse(use_span),\n         };\n "}, {"sha": "c3369e872151a1b7e6d4c524b5dfc43fd5107454", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 54, "deletions": 59, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/8bb039fb83f7f18df5e1d71607981c8d4902b7b3/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb039fb83f7f18df5e1d71607981c8d4902b7b3/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=8bb039fb83f7f18df5e1d71607981c8d4902b7b3", "patch": "@@ -1133,15 +1133,12 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         // Special case: you can assign a immutable local variable\n         // (e.g., `x = ...`) so long as it has never been initialized\n         // before (at this point in the flow).\n-        if let Place {\n-            base: PlaceBase::Local(local),\n-            projection: box [],\n-        } = place_span.0 {\n-            if let Mutability::Not = self.body.local_decls[*local].mutability {\n+        if let Some(local) = place_span.0.as_local() {\n+            if let Mutability::Not = self.body.local_decls[local].mutability {\n                 // check for reassignments to immutable local variables\n                 self.check_if_reassignment_to_immutable_state(\n                     location,\n-                    *local,\n+                    local,\n                     place_span,\n                     flow_state,\n                 );\n@@ -1288,60 +1285,58 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         // captures of a closure are copied/moved directly\n         // when generating MIR.\n         match *operand {\n-            Operand::Move(Place {\n-                base: PlaceBase::Local(local),\n-                projection: box [],\n-            }) |\n-            Operand::Copy(Place {\n-                base: PlaceBase::Local(local),\n-                projection: box [],\n-            }) if self.body.local_decls[local].is_user_variable.is_none() => {\n-                if self.body.local_decls[local].ty.is_mutable_ptr() {\n-                    // The variable will be marked as mutable by the borrow.\n-                    return;\n-                }\n-                // This is an edge case where we have a `move` closure\n-                // inside a non-move closure, and the inner closure\n-                // contains a mutation:\n-                //\n-                // let mut i = 0;\n-                // || { move || { i += 1; }; };\n-                //\n-                // In this case our usual strategy of assuming that the\n-                // variable will be captured by mutable reference is\n-                // wrong, since `i` can be copied into the inner\n-                // closure from a shared reference.\n-                //\n-                // As such we have to search for the local that this\n-                // capture comes from and mark it as being used as mut.\n-\n-                let temp_mpi = self.move_data.rev_lookup.find_local(local);\n-                let init = if let [init_index] = *self.move_data.init_path_map[temp_mpi] {\n-                    &self.move_data.inits[init_index]\n-                } else {\n-                    bug!(\"temporary should be initialized exactly once\")\n-                };\n-\n-                let loc = match init.location {\n-                    InitLocation::Statement(stmt) => stmt,\n-                    _ => bug!(\"temporary initialized in arguments\"),\n-                };\n-\n-                let bbd = &self.body[loc.block];\n-                let stmt = &bbd.statements[loc.statement_index];\n-                debug!(\"temporary assigned in: stmt={:?}\", stmt);\n-\n-                if let StatementKind::Assign(box(_, Rvalue::Ref(_, _, ref source))) = stmt.kind {\n-                    propagate_closure_used_mut_place(self, source);\n-                } else {\n-                    bug!(\"closures should only capture user variables \\\n-                        or references to user variables\");\n+            Operand::Move(ref place) | Operand::Copy(ref place) => {\n+                match place.as_local() {\n+                    Some(local) if self.body.local_decls[local].is_user_variable.is_none() => {\n+                        if self.body.local_decls[local].ty.is_mutable_ptr() {\n+                            // The variable will be marked as mutable by the borrow.\n+                            return;\n+                        }\n+                        // This is an edge case where we have a `move` closure\n+                        // inside a non-move closure, and the inner closure\n+                        // contains a mutation:\n+                        //\n+                        // let mut i = 0;\n+                        // || { move || { i += 1; }; };\n+                        //\n+                        // In this case our usual strategy of assuming that the\n+                        // variable will be captured by mutable reference is\n+                        // wrong, since `i` can be copied into the inner\n+                        // closure from a shared reference.\n+                        //\n+                        // As such we have to search for the local that this\n+                        // capture comes from and mark it as being used as mut.\n+\n+                        let temp_mpi = self.move_data.rev_lookup.find_local(local);\n+                        let init = if let [init_index] = *self.move_data.init_path_map[temp_mpi] {\n+                            &self.move_data.inits[init_index]\n+                        } else {\n+                            bug!(\"temporary should be initialized exactly once\")\n+                        };\n+\n+                        let loc = match init.location {\n+                            InitLocation::Statement(stmt) => stmt,\n+                            _ => bug!(\"temporary initialized in arguments\"),\n+                        };\n+\n+                        let bbd = &self.body[loc.block];\n+                        let stmt = &bbd.statements[loc.statement_index];\n+                        debug!(\"temporary assigned in: stmt={:?}\", stmt);\n+\n+                        if let StatementKind::Assign(box (_, Rvalue::Ref(_, _, ref source))) =\n+                            stmt.kind\n+                        {\n+                            propagate_closure_used_mut_place(self, source);\n+                        } else {\n+                            bug!(\n+                                \"closures should only capture user variables \\\n+                                 or references to user variables\"\n+                            );\n+                        }\n+                    }\n+                    _ => propagate_closure_used_mut_place(self, place),\n                 }\n             }\n-            Operand::Move(ref place)\n-            | Operand::Copy(ref place) => {\n-                propagate_closure_used_mut_place(self, place);\n-            }\n             Operand::Constant(..) => {}\n         }\n     }\n@@ -1702,7 +1697,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         debug!(\"check_if_assigned_path_is_moved place: {:?}\", place);\n \n         // None case => assigning to `x` does not require `x` be initialized.\n-        let mut cursor = &*place.projection;\n+        let mut cursor = &*place.projection.as_ref();\n         while let [proj_base @ .., elem] = cursor {\n             cursor = proj_base;\n "}, {"sha": "d9e958d9450017fec5973fab06b1e5844aea54f8", "filename": "src/librustc_mir/borrow_check/move_errors.rs", "status": "modified", "additions": 33, "deletions": 37, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/8bb039fb83f7f18df5e1d71607981c8d4902b7b3/src%2Flibrustc_mir%2Fborrow_check%2Fmove_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb039fb83f7f18df5e1d71607981c8d4902b7b3/src%2Flibrustc_mir%2Fborrow_check%2Fmove_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmove_errors.rs?ref=8bb039fb83f7f18df5e1d71607981c8d4902b7b3", "patch": "@@ -89,45 +89,41 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                 // If that ever stops being the case, then the ever initialized\n                 // flow could be used.\n                 if let Some(StatementKind::Assign(\n-                    box(\n-                        Place {\n-                            base: PlaceBase::Local(local),\n-                            projection: box [],\n-                        },\n-                        Rvalue::Use(Operand::Move(move_from))\n-                    )\n+                    box(place, Rvalue::Use(Operand::Move(move_from)))\n                 )) = self.body.basic_blocks()[location.block]\n                     .statements\n                     .get(location.statement_index)\n                     .map(|stmt| &stmt.kind)\n                 {\n-                    let local_decl = &self.body.local_decls[*local];\n-                    // opt_match_place is the\n-                    // match_span is the span of the expression being matched on\n-                    // match *x.y { ... }        match_place is Some(*x.y)\n-                    //       ^^^^                match_span is the span of *x.y\n-                    //\n-                    // opt_match_place is None for let [mut] x = ... statements,\n-                    // whether or not the right-hand side is a place expression\n-                    if let Some(ClearCrossCrate::Set(BindingForm::Var(VarBindingForm {\n-                        opt_match_place: Some((ref opt_match_place, match_span)),\n-                        binding_mode: _,\n-                        opt_ty_info: _,\n-                        pat_span: _,\n-                    }))) = local_decl.is_user_variable\n-                    {\n-                        let stmt_source_info = self.body.source_info(location);\n-                        self.append_binding_error(\n-                            grouped_errors,\n-                            kind,\n-                            original_path,\n-                            move_from,\n-                            *local,\n-                            opt_match_place,\n-                            match_span,\n-                            stmt_source_info.span,\n-                        );\n-                        return;\n+                    if let Some(local) = place.as_local() {\n+                        let local_decl = &self.body.local_decls[local];\n+                        // opt_match_place is the\n+                        // match_span is the span of the expression being matched on\n+                        // match *x.y { ... }        match_place is Some(*x.y)\n+                        //       ^^^^                match_span is the span of *x.y\n+                        //\n+                        // opt_match_place is None for let [mut] x = ... statements,\n+                        // whether or not the right-hand side is a place expression\n+                        if let Some(ClearCrossCrate::Set(BindingForm::Var(VarBindingForm {\n+                            opt_match_place: Some((ref opt_match_place, match_span)),\n+                            binding_mode: _,\n+                            opt_ty_info: _,\n+                            pat_span: _,\n+                        }))) = local_decl.is_user_variable\n+                        {\n+                            let stmt_source_info = self.body.source_info(location);\n+                            self.append_binding_error(\n+                                grouped_errors,\n+                                kind,\n+                                original_path,\n+                                move_from,\n+                                local,\n+                                opt_match_place,\n+                                match_span,\n+                                stmt_source_info.span,\n+                            );\n+                            return;\n+                        }\n                     }\n                 }\n \n@@ -307,11 +303,11 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n         let upvar_field = self.prefixes(move_place.as_ref(), PrefixSet::All)\n             .find_map(|p| self.is_upvar_field_projection(p));\n \n-        let deref_base = match &deref_target_place.projection {\n-            box [proj_base @ .., ProjectionElem::Deref] => {\n+        let deref_base = match deref_target_place.projection.as_ref() {\n+            &[ref proj_base @ .., ProjectionElem::Deref] => {\n                 PlaceRef {\n                     base: &deref_target_place.base,\n-                    projection: proj_base,\n+                    projection: &proj_base,\n                 }\n             }\n             _ => bug!(\"deref_target_place is not a deref projection\"),"}, {"sha": "68b33331a1ffbfa64bce4b197ea65338c68c8ba1", "filename": "src/librustc_mir/borrow_check/mutability_errors.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/8bb039fb83f7f18df5e1d71607981c8d4902b7b3/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb039fb83f7f18df5e1d71607981c8d4902b7b3/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs?ref=8bb039fb83f7f18df5e1d71607981c8d4902b7b3", "patch": "@@ -49,10 +49,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                 projection: [],\n             } => {\n                 item_msg = format!(\"`{}`\", access_place_desc.unwrap());\n-                if let Place {\n-                    base: PlaceBase::Local(_),\n-                    projection: box [],\n-                } = access_place {\n+                if access_place.as_local().is_some() {\n                     reason = \", as it is not declared as mutable\".to_string();\n                 } else {\n                     let name = self.body.local_decls[*local]\n@@ -153,10 +150,10 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                     }),\n                 projection: [],\n             } => {\n-                if let Place {\n-                    base: PlaceBase::Static(_),\n-                    projection: box [],\n-                } = access_place {\n+                if let PlaceRef {\n+                    base: &PlaceBase::Static(_),\n+                    projection: &[],\n+                } = access_place.as_ref() {\n                     item_msg = format!(\"immutable static item `{}`\", access_place_desc.unwrap());\n                     reason = String::new();\n                 } else {"}, {"sha": "cae303039a19430e5f371da8de73e362d4ced40e", "filename": "src/librustc_mir/borrow_check/nll/constraint_generation.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/8bb039fb83f7f18df5e1d71607981c8d4902b7b3/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraint_generation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb039fb83f7f18df5e1d71607981c8d4902b7b3/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraint_generation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraint_generation.rs?ref=8bb039fb83f7f18df5e1d71607981c8d4902b7b3", "patch": "@@ -8,8 +8,8 @@ use rustc::infer::InferCtxt;\n use rustc::mir::visit::TyContext;\n use rustc::mir::visit::Visitor;\n use rustc::mir::{\n-    BasicBlock, BasicBlockData, Body, Local, Location, Place, PlaceBase, ProjectionElem, Rvalue,\n-    SourceInfo, Statement, StatementKind, Terminator, TerminatorKind, UserTypeProjection,\n+    BasicBlock, BasicBlockData, Body, Local, Location, Place, PlaceBase, PlaceRef, ProjectionElem,\n+    Rvalue, SourceInfo, Statement, StatementKind, Terminator, TerminatorKind, UserTypeProjection,\n };\n use rustc::ty::fold::TypeFoldable;\n use rustc::ty::{self, RegionVid, Ty};\n@@ -211,14 +211,14 @@ impl<'cx, 'cg, 'tcx> ConstraintGeneration<'cx, 'cg, 'tcx> {\n             // - if it's a deeper projection, we have to filter which\n             //   of the borrows are killed: the ones whose `borrowed_place`\n             //   conflicts with the `place`.\n-            match place {\n-                Place {\n-                    base: PlaceBase::Local(local),\n-                    projection: box [],\n+            match place.as_ref() {\n+                PlaceRef {\n+                    base: &PlaceBase::Local(local),\n+                    projection: &[],\n                 } |\n-                Place {\n-                    base: PlaceBase::Local(local),\n-                    projection: box [ProjectionElem::Deref],\n+                PlaceRef {\n+                    base: &PlaceBase::Local(local),\n+                    projection: &[ProjectionElem::Deref],\n                 } => {\n                     debug!(\n                         \"Recording `killed` facts for borrows of local={:?} at location={:?}\",\n@@ -229,21 +229,21 @@ impl<'cx, 'cg, 'tcx> ConstraintGeneration<'cx, 'cg, 'tcx> {\n                         all_facts,\n                         self.borrow_set,\n                         self.location_table,\n-                        local,\n+                        &local,\n                         location,\n                     );\n                 }\n \n-                Place {\n-                    base: PlaceBase::Static(_),\n+                PlaceRef {\n+                    base: &PlaceBase::Static(_),\n                     ..\n                 } => {\n                     // Ignore kills of static or static mut variables.\n                 }\n \n-                Place {\n-                    base: PlaceBase::Local(local),\n-                    projection: box [.., _],\n+                PlaceRef {\n+                    base: &PlaceBase::Local(local),\n+                    projection: &[.., _],\n                 } => {\n                     // Kill conflicting borrows of the innermost local.\n                     debug!(\n@@ -252,7 +252,7 @@ impl<'cx, 'cg, 'tcx> ConstraintGeneration<'cx, 'cg, 'tcx> {\n                         local, location\n                     );\n \n-                    if let Some(borrow_indices) = self.borrow_set.local_map.get(local) {\n+                    if let Some(borrow_indices) = self.borrow_set.local_map.get(&local) {\n                         for &borrow_index in borrow_indices {\n                             let places_conflict = places_conflict::places_conflict(\n                                 self.infcx.tcx,"}, {"sha": "26bead3047d5d3ce62bde8df861e120f94256182", "filename": "src/librustc_mir/borrow_check/nll/explain_borrow/mod.rs", "status": "modified", "additions": 71, "deletions": 85, "changes": 156, "blob_url": "https://github.com/rust-lang/rust/blob/8bb039fb83f7f18df5e1d71607981c8d4902b7b3/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb039fb83f7f18df5e1d71607981c8d4902b7b3/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Fmod.rs?ref=8bb039fb83f7f18df5e1d71607981c8d4902b7b3", "patch": "@@ -6,8 +6,8 @@ use crate::borrow_check::nll::region_infer::{Cause, RegionName};\n use crate::borrow_check::nll::ConstraintDescription;\n use crate::borrow_check::{MirBorrowckCtxt, WriteKind};\n use rustc::mir::{\n-    CastKind, ConstraintCategory, FakeReadCause, Local, Location, Body, Operand, Place, PlaceBase,\n-    Rvalue, Statement, StatementKind, TerminatorKind,\n+    CastKind, ConstraintCategory, FakeReadCause, Local, Location, Body, Operand, Place, Rvalue,\n+    Statement, StatementKind, TerminatorKind,\n };\n use rustc::ty::{self, TyCtxt};\n use rustc::ty::adjustment::{PointerCast};\n@@ -273,12 +273,9 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 let mut should_note_order = false;\n                 if body.local_decls[local].name.is_some() {\n                     if let Some((WriteKind::StorageDeadOrDrop, place)) = kind_place {\n-                        if let Place {\n-                            base: PlaceBase::Local(borrowed_local),\n-                            projection: box [],\n-                        } = place {\n-                             if body.local_decls[*borrowed_local].name.is_some()\n-                                && local != *borrowed_local\n+                        if let Some(borrowed_local) = place.as_local() {\n+                             if body.local_decls[borrowed_local].name.is_some()\n+                                && local != borrowed_local\n                             {\n                                 should_note_order = true;\n                             }\n@@ -494,22 +491,19 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                         // Just point to the function, to reduce the chance of overlapping spans.\n                         let function_span = match func {\n                             Operand::Constant(c) => c.span,\n-                            Operand::Copy(Place {\n-                                base: PlaceBase::Local(l),\n-                                projection: box [],\n-                            }) |\n-                            Operand::Move(Place {\n-                                base: PlaceBase::Local(l),\n-                                projection: box [],\n-                            }) => {\n-                                let local_decl = &self.body.local_decls[*l];\n-                                if local_decl.name.is_none() {\n-                                    local_decl.source_info.span\n+                            Operand::Copy(place) |\n+                            Operand::Move(place) => {\n+                                if let Some(l) = place.as_local() {\n+                                    let local_decl = &self.body.local_decls[l];\n+                                    if local_decl.name.is_none() {\n+                                        local_decl.source_info.span\n+                                    } else {\n+                                        span\n+                                    }\n                                 } else {\n                                     span\n                                 }\n                             }\n-                            _ => span,\n                         };\n                         return (LaterUseKind::Call, function_span);\n                     } else {\n@@ -542,14 +536,14 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         // it which simplifies the termination logic.\n         let mut queue = vec![location];\n         let mut target = if let Some(&Statement {\n-            kind: StatementKind::Assign(box(Place {\n-                base: PlaceBase::Local(local),\n-                projection: box [],\n-            }, _)),\n+            kind: StatementKind::Assign(box(ref place, _)),\n             ..\n-        }) = stmt\n-        {\n-            local\n+        }) = stmt {\n+            if let Some(local) = place.as_local() {\n+                local\n+            } else {\n+                return false;\n+            }\n         } else {\n             return false;\n         };\n@@ -582,17 +576,13 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                         // If we see a use, we should check whether it is our data, and if so\n                         // update the place that we're looking for to that new place.\n                         Rvalue::Use(operand) => match operand {\n-                            Operand::Copy(Place {\n-                                base: PlaceBase::Local(from),\n-                                projection: box [],\n-                            })\n-                            | Operand::Move(Place {\n-                                base: PlaceBase::Local(from),\n-                                projection: box [],\n-                            })\n-                                if *from == target =>\n-                            {\n-                                target = into;\n+                            Operand::Copy(place)\n+                            | Operand::Move(place) => {\n+                                if let Some(from) = place.as_local() {\n+                                    if from == target {\n+                                        target = into;\n+                                    }\n+                                }\n                             }\n                             _ => {}\n                         },\n@@ -601,28 +591,25 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                         Rvalue::Cast(\n                             CastKind::Pointer(PointerCast::Unsize), operand, ty\n                         ) => match operand {\n-                            Operand::Copy(Place {\n-                                base: PlaceBase::Local(from),\n-                                projection: box [],\n-                            })\n-                            | Operand::Move(Place {\n-                                base: PlaceBase::Local(from),\n-                                projection: box [],\n-                            })\n-                                if *from == target =>\n-                            {\n-                                debug!(\"was_captured_by_trait_object: ty={:?}\", ty);\n-                                // Check the type for a trait object.\n-                                return match ty.kind {\n-                                    // `&dyn Trait`\n-                                    ty::Ref(_, ty, _) if ty.is_trait() => true,\n-                                    // `Box<dyn Trait>`\n-                                    _ if ty.is_box() && ty.boxed_ty().is_trait() => true,\n-                                    // `dyn Trait`\n-                                    _ if ty.is_trait() => true,\n-                                    // Anything else.\n-                                    _ => false,\n-                                };\n+                            Operand::Copy(place)\n+                            | Operand::Move(place) => {\n+                                if let Some(from) = place.as_local() {\n+                                    if from == target {\n+                                        debug!(\"was_captured_by_trait_object: ty={:?}\", ty);\n+                                        // Check the type for a trait object.\n+                                        return match ty.kind {\n+                                            // `&dyn Trait`\n+                                            ty::Ref(_, ty, _) if ty.is_trait() => true,\n+                                            // `Box<dyn Trait>`\n+                                            _ if ty.is_box() && ty.boxed_ty().is_trait() => true,\n+                                            // `dyn Trait`\n+                                            _ if ty.is_trait() => true,\n+                                            // Anything else.\n+                                            _ => false,\n+                                        };\n+                                    }\n+                                }\n+                                return false;\n                             }\n                             _ => return false,\n                         },\n@@ -638,34 +625,33 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 debug!(\"was_captured_by_trait_object: terminator={:?}\", terminator);\n \n                 if let TerminatorKind::Call {\n-                    destination: Some((Place {\n-                        base: PlaceBase::Local(dest),\n-                        projection: box [],\n-                    }, block)),\n+                    destination: Some((place, block)),\n                     args,\n                     ..\n-                } = &terminator.kind\n-                {\n-                    debug!(\n-                        \"was_captured_by_trait_object: target={:?} dest={:?} args={:?}\",\n-                        target, dest, args\n-                    );\n-                    // Check if one of the arguments to this function is the target place.\n-                    let found_target = args.iter().any(|arg| {\n-                        if let Operand::Move(Place {\n-                            base: PlaceBase::Local(potential),\n-                            projection: box [],\n-                        }) = arg {\n-                            *potential == target\n-                        } else {\n-                            false\n-                        }\n-                    });\n+                } = &terminator.kind {\n+                    if let Some(dest) = place.as_local() {\n+                        debug!(\n+                            \"was_captured_by_trait_object: target={:?} dest={:?} args={:?}\",\n+                            target, dest, args\n+                        );\n+                        // Check if one of the arguments to this function is the target place.\n+                        let found_target = args.iter().any(|arg| {\n+                            if let Operand::Move(place) = arg {\n+                                if let Some(potential) = place.as_local() {\n+                                    potential == target\n+                                } else {\n+                                    false\n+                                }\n+                            } else {\n+                                false\n+                            }\n+                        });\n \n-                    // If it is, follow this to the next block and update the target.\n-                    if found_target {\n-                        target = *dest;\n-                        queue.push(block.start_location());\n+                        // If it is, follow this to the next block and update the target.\n+                        if found_target {\n+                            target = dest;\n+                            queue.push(block.start_location());\n+                        }\n                     }\n                 }\n             }"}, {"sha": "d949c7e01aab730447d91c3c88b41463fbb92e23", "filename": "src/librustc_mir/borrow_check/nll/renumber.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8bb039fb83f7f18df5e1d71607981c8d4902b7b3/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Frenumber.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb039fb83f7f18df5e1d71607981c8d4902b7b3/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Frenumber.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Frenumber.rs?ref=8bb039fb83f7f18df5e1d71607981c8d4902b7b3", "patch": "@@ -1,5 +1,5 @@\n use rustc::ty::subst::SubstsRef;\n-use rustc::ty::{self, Ty, TypeFoldable};\n+use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n use rustc::mir::{Body, Location, PlaceElem, Promoted};\n use rustc::mir::visit::{MutVisitor, TyContext};\n use rustc::infer::{InferCtxt, NLLRegionVariableOrigin};\n@@ -54,6 +54,10 @@ impl<'a, 'tcx> NLLVisitor<'a, 'tcx> {\n }\n \n impl<'a, 'tcx> MutVisitor<'tcx> for NLLVisitor<'a, 'tcx> {\n+    fn tcx(&self) -> TyCtxt<'tcx> {\n+        self.infcx.tcx\n+    }\n+\n     fn visit_ty(&mut self, ty: &mut Ty<'tcx>, ty_context: TyContext) {\n         debug!(\"visit_ty(ty={:?}, ty_context={:?})\", ty, ty_context);\n "}, {"sha": "b5560fe6751bd9be3120baa66a030578f139a2b4", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 11, "deletions": 23, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/8bb039fb83f7f18df5e1d71607981c8d4902b7b3/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb039fb83f7f18df5e1d71607981c8d4902b7b3/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=8bb039fb83f7f18df5e1d71607981c8d4902b7b3", "patch": "@@ -480,13 +480,13 @@ impl<'a, 'b, 'tcx> TypeVerifier<'a, 'b, 'tcx> {\n \n         if place.projection.is_empty() {\n             if let PlaceContext::NonMutatingUse(NonMutatingUseContext::Copy) = context {\n-                let is_promoted = match place {\n-                    Place {\n-                        base: PlaceBase::Static(box Static {\n+                let is_promoted = match place.as_ref() {\n+                    PlaceRef {\n+                        base: &PlaceBase::Static(box Static {\n                             kind: StaticKind::Promoted(..),\n                             ..\n                         }),\n-                        projection: box [],\n+                        projection: &[],\n                     } => true,\n                     _ => false,\n                 };\n@@ -1366,11 +1366,8 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                 // they are not caused by the user, but rather artifacts\n                 // of lowering. Assignments to other sorts of places *are* interesting\n                 // though.\n-                let category = match *place {\n-                    Place {\n-                        base: PlaceBase::Local(RETURN_PLACE),\n-                        projection: box [],\n-                    } => if let BorrowCheckContext {\n+                let category = match place.as_local() {\n+                    Some(RETURN_PLACE) => if let BorrowCheckContext {\n                         universal_regions:\n                             UniversalRegions {\n                                 defining_ty: DefiningTy::Const(def_id, _),\n@@ -1386,10 +1383,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                     } else {\n                         ConstraintCategory::Return\n                     },\n-                    Place {\n-                        base: PlaceBase::Local(l),\n-                        projection: box [],\n-                    } if !body.local_decls[l].is_user_variable.is_some() => {\n+                    Some(l) if !body.local_decls[l].is_user_variable.is_some() => {\n                         ConstraintCategory::Boring\n                     }\n                     _ => ConstraintCategory::Assignment,\n@@ -1675,11 +1669,8 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n             Some((ref dest, _target_block)) => {\n                 let dest_ty = dest.ty(body, tcx).ty;\n                 let dest_ty = self.normalize(dest_ty, term_location);\n-                let category = match *dest {\n-                    Place {\n-                        base: PlaceBase::Local(RETURN_PLACE),\n-                        projection: box [],\n-                    } => {\n+                let category = match dest.as_local() {\n+                    Some(RETURN_PLACE) => {\n                         if let BorrowCheckContext {\n                             universal_regions:\n                                 UniversalRegions {\n@@ -1698,10 +1689,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                             ConstraintCategory::Return\n                         }\n                     }\n-                    Place {\n-                        base: PlaceBase::Local(l),\n-                        projection: box [],\n-                    } if !body.local_decls[l].is_user_variable.is_some() => {\n+                    Some(l) if !body.local_decls[l].is_user_variable.is_some() => {\n                         ConstraintCategory::Boring\n                     }\n                     _ => ConstraintCategory::Assignment,\n@@ -2432,7 +2420,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n             location, borrow_region, borrowed_place\n         );\n \n-        let mut cursor = &*borrowed_place.projection;\n+        let mut cursor = borrowed_place.projection.as_ref();\n         while let [proj_base @ .., elem] = cursor {\n             cursor = proj_base;\n "}, {"sha": "264e4807af07e9c9e8056a296035c722ff0ef5fb", "filename": "src/librustc_mir/borrow_check/places_conflict.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8bb039fb83f7f18df5e1d71607981c8d4902b7b3/src%2Flibrustc_mir%2Fborrow_check%2Fplaces_conflict.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb039fb83f7f18df5e1d71607981c8d4902b7b3/src%2Flibrustc_mir%2Fborrow_check%2Fplaces_conflict.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fplaces_conflict.rs?ref=8bb039fb83f7f18df5e1d71607981c8d4902b7b3", "patch": "@@ -64,14 +64,8 @@ pub(super) fn borrow_conflicts_with_place<'tcx>(\n \n     // This Local/Local case is handled by the more general code below, but\n     // it's so common that it's a speed win to check for it first.\n-    if let Place {\n-        base: PlaceBase::Local(l1),\n-        projection: box [],\n-    } = borrow_place {\n-        if let PlaceRef {\n-            base: PlaceBase::Local(l2),\n-            projection: [],\n-        } = access_place {\n+    if let Some(l1) = borrow_place.as_local() {\n+        if let Some(l2) = access_place.as_local() {\n             return l1 == l2;\n         }\n     }"}, {"sha": "95471afb7884f74d06c8cb67450b01b5b22086ba", "filename": "src/librustc_mir/borrow_check/used_muts.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8bb039fb83f7f18df5e1d71607981c8d4902b7b3/src%2Flibrustc_mir%2Fborrow_check%2Fused_muts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb039fb83f7f18df5e1d71607981c8d4902b7b3/src%2Flibrustc_mir%2Fborrow_check%2Fused_muts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fused_muts.rs?ref=8bb039fb83f7f18df5e1d71607981c8d4902b7b3", "patch": "@@ -1,7 +1,5 @@\n use rustc::mir::visit::{PlaceContext, Visitor};\n-use rustc::mir::{\n-    Local, Location, Place, PlaceBase, Statement, StatementKind, TerminatorKind\n-};\n+use rustc::mir::{Local, Location, Place, PlaceBase, Statement, StatementKind, TerminatorKind};\n \n use rustc_data_structures::fx::FxHashSet;\n \n@@ -118,10 +116,7 @@ impl<'visit, 'cx, 'tcx> Visitor<'tcx> for GatherUsedMutsVisitor<'visit, 'cx, 'tc\n                     \"assignment of {:?} to {:?}, adding {:?} to used mutable set\",\n                     path.place, local, path.place\n                 );\n-                if let Place {\n-                    base: PlaceBase::Local(user_local),\n-                    projection: box [],\n-                } = path.place {\n+                if let Some(user_local) = path.place.as_local() {\n                     self.mbcx.used_mut.insert(user_local);\n                 }\n             }"}, {"sha": "8d2bef39bed4269fd65b0c8ed90a625c2bafe674", "filename": "src/librustc_mir/build/expr/as_place.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8bb039fb83f7f18df5e1d71607981c8d4902b7b3/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb039fb83f7f18df5e1d71607981c8d4902b7b3/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_place.rs?ref=8bb039fb83f7f18df5e1d71607981c8d4902b7b3", "patch": "@@ -6,7 +6,7 @@ use crate::build::{BlockAnd, BlockAndExtension, Builder};\n use crate::hair::*;\n use rustc::mir::interpret::{PanicInfo::BoundsCheck};\n use rustc::mir::*;\n-use rustc::ty::{CanonicalUserTypeAnnotation, Ty, Variance};\n+use rustc::ty::{CanonicalUserTypeAnnotation, Ty, TyCtxt, Variance};\n \n use rustc_index::vec::Idx;\n \n@@ -23,10 +23,10 @@ struct PlaceBuilder<'tcx> {\n }\n \n impl PlaceBuilder<'tcx> {\n-    fn into_place(self) -> Place<'tcx> {\n+    fn into_place(self, tcx: TyCtxt<'tcx>) -> Place<'tcx> {\n         Place {\n             base: self.base,\n-            projection: self.projection.into_boxed_slice(),\n+            projection: tcx.intern_place_elems(&self.projection),\n         }\n     }\n \n@@ -73,7 +73,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         M: Mirror<'tcx, Output = Expr<'tcx>>,\n     {\n         let place_builder = unpack!(block = self.as_place_builder(block, expr));\n-        block.and(place_builder.into_place())\n+        block.and(place_builder.into_place(self.hir.tcx()))\n     }\n \n     /// This is used when constructing a compound `Place`, so that we can avoid creating\n@@ -96,7 +96,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         M: Mirror<'tcx, Output = Expr<'tcx>>,\n     {\n         let place_builder = unpack!(block = self.as_read_only_place_builder(block, expr));\n-        block.and(place_builder.into_place())\n+        block.and(place_builder.into_place(self.hir.tcx()))\n     }\n \n     /// This is used when constructing a compound `Place`, so that we can avoid creating\n@@ -165,7 +165,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     Mutability::Not,\n                 ));\n \n-                let slice = place_builder.clone().into_place();\n+                let slice = place_builder.clone().into_place(this.hir.tcx());\n                 // bounds check:\n                 let (len, lt) = (\n                     this.temp(usize_ty.clone(), expr_span),\n@@ -225,7 +225,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                         }\n                     );\n \n-                    let place = place_builder.clone().into_place();\n+                    let place = place_builder.clone().into_place(this.hir.tcx());\n                     this.cfg.push(\n                         block,\n                         Statement {"}, {"sha": "4f1ac8e51dc208e14c8d6c22ebb2f1368b8caccd", "filename": "src/librustc_mir/build/expr/as_rvalue.rs", "status": "modified", "additions": 22, "deletions": 16, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/8bb039fb83f7f18df5e1d71607981c8d4902b7b3/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb039fb83f7f18df5e1d71607981c8d4902b7b3/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=8bb039fb83f7f18df5e1d71607981c8d4902b7b3", "patch": "@@ -139,7 +139,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 // initialize the box contents:\n                 unpack!(\n                     block = this.into(\n-                        &Place::from(result).deref(),\n+                        &this.hir.tcx().mk_place_deref(Place::from(result)),\n                         block, value\n                     )\n                 );\n@@ -296,8 +296,13 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                         .zip(field_types.into_iter())\n                         .map(|(n, ty)| match fields_map.get(&n) {\n                             Some(v) => v.clone(),\n-                            None => this.consume_by_copy_or_move(base.clone().field(n, ty)),\n-                        }).collect()\n+                            None => this.consume_by_copy_or_move(this.hir.tcx().mk_place_field(\n+                                base.clone(),\n+                                n,\n+                                ty,\n+                            )),\n+                        })\n+                        .collect()\n                 } else {\n                     field_names\n                         .iter()\n@@ -397,8 +402,9 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             let val_fld = Field::new(0);\n             let of_fld = Field::new(1);\n \n-            let val = result_value.clone().field(val_fld, ty);\n-            let of = result_value.field(of_fld, bool_ty);\n+            let tcx = self.hir.tcx();\n+            let val = tcx.mk_place_field(result_value.clone(), val_fld, ty);\n+            let of = tcx.mk_place_field(result_value, of_fld, bool_ty);\n \n             let err = PanicInfo::Overflow(op);\n \n@@ -496,28 +502,28 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n         let arg_place = unpack!(block = this.as_place(block, arg));\n \n-        let mutability = match arg_place {\n-            Place {\n-                base: PlaceBase::Local(local),\n-                projection: box [],\n+        let mutability = match arg_place.as_ref() {\n+            PlaceRef {\n+                base: &PlaceBase::Local(local),\n+                projection: &[],\n             } => this.local_decls[local].mutability,\n-            Place {\n-                base: PlaceBase::Local(local),\n-                projection: box [ProjectionElem::Deref],\n+            PlaceRef {\n+                base: &PlaceBase::Local(local),\n+                projection: &[ProjectionElem::Deref],\n             } => {\n                 debug_assert!(\n                     this.local_decls[local].is_ref_for_guard(),\n                     \"Unexpected capture place\",\n                 );\n                 this.local_decls[local].mutability\n             }\n-            Place {\n+            PlaceRef {\n                 ref base,\n-                projection: box [ref proj_base @ .., ProjectionElem::Field(upvar_index, _)],\n+                projection: &[ref proj_base @ .., ProjectionElem::Field(upvar_index, _)],\n             }\n-            | Place {\n+            | PlaceRef {\n                 ref base,\n-                projection: box [\n+                projection: &[\n                     ref proj_base @ ..,\n                     ProjectionElem::Field(upvar_index, _),\n                     ProjectionElem::Deref"}, {"sha": "e7388b920548b731bdb603a0f72d782d65efd52d", "filename": "src/librustc_mir/build/expr/into.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8bb039fb83f7f18df5e1d71607981c8d4902b7b3/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb039fb83f7f18df5e1d71607981c8d4902b7b3/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs?ref=8bb039fb83f7f18df5e1d71607981c8d4902b7b3", "patch": "@@ -235,7 +235,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     });\n                     let ptr_temp = Place::from(ptr_temp);\n                     let block = unpack!(this.into(&ptr_temp, block, ptr));\n-                    this.into(&ptr_temp.deref(), block, val)\n+                    this.into(&this.hir.tcx().mk_place_deref(ptr_temp), block, val)\n                 } else {\n                     let args: Vec<_> = args\n                         .into_iter()"}, {"sha": "667b37bbd80c83bf991f5120017c92f900cf34ba", "filename": "src/librustc_mir/build/matches/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8bb039fb83f7f18df5e1d71607981c8d4902b7b3/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb039fb83f7f18df5e1d71607981c8d4902b7b3/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs?ref=8bb039fb83f7f18df5e1d71607981c8d4902b7b3", "patch": "@@ -948,7 +948,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n                     fake_borrows.insert(Place {\n                         base: source.base.clone(),\n-                        projection: proj_base.to_vec().into_boxed_slice(),\n+                        projection: self.hir.tcx().intern_place_elems(proj_base),\n                     });\n                 }\n             }\n@@ -1293,7 +1293,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         // Insert a Shallow borrow of the prefixes of any fake borrows.\n         for place in fake_borrows\n         {\n-            let mut cursor = &*place.projection;\n+            let mut cursor = place.projection.as_ref();\n             while let [proj_base @ .., elem] = cursor {\n                 cursor = proj_base;\n \n@@ -1488,7 +1488,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     BorrowKind::Shallow,\n                     Place {\n                         base: place.base.clone(),\n-                        projection: place.projection.to_vec().into_boxed_slice(),\n+                        projection: tcx.intern_place_elems(place.projection),\n                     },\n                 );\n                 self.cfg.push_assign("}, {"sha": "9b7bccca2ddf3268aaac4602d48d15dd0e2c557a", "filename": "src/librustc_mir/build/matches/simplify.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8bb039fb83f7f18df5e1d71607981c8d4902b7b3/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb039fb83f7f18df5e1d71607981c8d4902b7b3/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fsimplify.rs?ref=8bb039fb83f7f18df5e1d71607981c8d4902b7b3", "patch": "@@ -166,7 +166,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     }\n                 });\n                 if irrefutable {\n-                    let place = match_pair.place.downcast(adt_def, variant_index);\n+                    let place = tcx.mk_place_downcast(match_pair.place, adt_def, variant_index);\n                     candidate.match_pairs.extend(self.field_match_pairs(place, subpatterns));\n                     Ok(())\n                 } else {\n@@ -191,7 +191,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             }\n \n             PatKind::Deref { ref subpattern } => {\n-                let place = match_pair.place.deref();\n+                let place = tcx.mk_place_deref(match_pair.place);\n                 candidate.match_pairs.push(MatchPair::new(place, subpattern));\n                 Ok(())\n             }"}, {"sha": "5c2f72c0a061fec79401d4fde1d5d964b42c025a", "filename": "src/librustc_mir/build/matches/test.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/8bb039fb83f7f18df5e1d71607981c8d4902b7b3/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb039fb83f7f18df5e1d71607981c8d4902b7b3/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs?ref=8bb039fb83f7f18df5e1d71607981c8d4902b7b3", "patch": "@@ -743,22 +743,21 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         candidate: &mut Candidate<'pat, 'tcx>,\n     ) {\n         let match_pair = candidate.match_pairs.remove(match_pair_index);\n+        let tcx = self.hir.tcx();\n \n         // So, if we have a match-pattern like `x @ Enum::Variant(P1, P2)`,\n         // we want to create a set of derived match-patterns like\n         // `(x as Variant).0 @ P1` and `(x as Variant).1 @ P1`.\n         let elem = ProjectionElem::Downcast(\n             Some(adt_def.variants[variant_index].ident.name), variant_index);\n-        let downcast_place = match_pair.place.elem(elem); // `(x as Variant)`\n-        let consequent_match_pairs =\n-            subpatterns.iter()\n-                       .map(|subpattern| {\n-                           // e.g., `(x as Variant).0`\n-                           let place = downcast_place.clone().field(subpattern.field,\n-                                                                      subpattern.pattern.ty);\n-                           // e.g., `(x as Variant).0 @ P1`\n-                           MatchPair::new(place, &subpattern.pattern)\n-                       });\n+        let downcast_place = tcx.mk_place_elem(match_pair.place, elem); // `(x as Variant)`\n+        let consequent_match_pairs = subpatterns.iter().map(|subpattern| {\n+            // e.g., `(x as Variant).0`\n+            let place =\n+                tcx.mk_place_field(downcast_place.clone(), subpattern.field, subpattern.pattern.ty);\n+            // e.g., `(x as Variant).0 @ P1`\n+            MatchPair::new(place, &subpattern.pattern)\n+        });\n \n         candidate.match_pairs.extend(consequent_match_pairs);\n     }"}, {"sha": "917535f31dc4b06eda62d08dc7361b7f7e8b6fbf", "filename": "src/librustc_mir/build/matches/util.rs", "status": "modified", "additions": 20, "deletions": 14, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/8bb039fb83f7f18df5e1d71607981c8d4902b7b3/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb039fb83f7f18df5e1d71607981c8d4902b7b3/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Futil.rs?ref=8bb039fb83f7f18df5e1d71607981c8d4902b7b3", "patch": "@@ -6,17 +6,22 @@ use std::u32;\n use std::convert::TryInto;\n \n impl<'a, 'tcx> Builder<'a, 'tcx> {\n-    pub fn field_match_pairs<'pat>(&mut self,\n-                                   place: Place<'tcx>,\n-                                   subpatterns: &'pat [FieldPat<'tcx>])\n-                                   -> Vec<MatchPair<'pat, 'tcx>> {\n-        subpatterns.iter()\n-                   .map(|fieldpat| {\n-                       let place = place.clone().field(fieldpat.field,\n-                                                       fieldpat.pattern.ty);\n-                       MatchPair::new(place, &fieldpat.pattern)\n-                   })\n-                   .collect()\n+    pub fn field_match_pairs<'pat>(\n+        &mut self,\n+        place: Place<'tcx>,\n+        subpatterns: &'pat [FieldPat<'tcx>],\n+    ) -> Vec<MatchPair<'pat, 'tcx>> {\n+        subpatterns\n+            .iter()\n+            .map(|fieldpat| {\n+                let place = self.hir.tcx().mk_place_field(\n+                    place.clone(),\n+                    fieldpat.field,\n+                    fieldpat.pattern.ty,\n+                );\n+                MatchPair::new(place, &fieldpat.pattern)\n+            })\n+            .collect()\n     }\n \n     pub fn prefix_slice_suffix<'pat>(&mut self,\n@@ -27,6 +32,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                                      suffix: &'pat [Pat<'tcx>]) {\n         let min_length = prefix.len() + suffix.len();\n         let min_length = min_length.try_into().unwrap();\n+        let tcx = self.hir.tcx();\n \n         match_pairs.extend(\n             prefix.iter()\n@@ -37,13 +43,13 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                           min_length,\n                           from_end: false,\n                       };\n-                      let place = place.clone().elem(elem);\n+                      let place = tcx.mk_place_elem(place.clone(), elem);\n                       MatchPair::new(place, subpattern)\n                   })\n         );\n \n         if let Some(subslice_pat) = opt_slice {\n-            let subslice = place.clone().elem(ProjectionElem::Subslice {\n+            let subslice = tcx.mk_place_elem(place.clone(),ProjectionElem::Subslice {\n                 from: prefix.len() as u32,\n                 to: suffix.len() as u32\n             });\n@@ -60,7 +66,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                           min_length,\n                           from_end: true,\n                       };\n-                      let place = place.clone().elem(elem);\n+                      let place = tcx.mk_place_elem(place.clone(), elem);\n                       MatchPair::new(place, subpattern)\n                   })\n         );"}, {"sha": "1b3d8641f204e32cb25786f4ba2cd2b5f588ee05", "filename": "src/librustc_mir/build/scope.rs", "status": "modified", "additions": 34, "deletions": 37, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/8bb039fb83f7f18df5e1d71607981c8d4902b7b3/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb039fb83f7f18df5e1d71607981c8d4902b7b3/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fscope.rs?ref=8bb039fb83f7f18df5e1d71607981c8d4902b7b3", "patch": "@@ -926,46 +926,43 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             // If constants and statics, we don't generate StorageLive for this\n             // temporary, so don't try to generate StorageDead for it either.\n             _ if self.local_scope().is_none() => (),\n-            Operand::Copy(Place {\n-                base: PlaceBase::Local(cond_temp),\n-                projection: box [],\n-            })\n-            | Operand::Move(Place {\n-                base: PlaceBase::Local(cond_temp),\n-                projection: box [],\n-            }) => {\n-                // Manually drop the condition on both branches.\n-                let top_scope = self.scopes.scopes.last_mut().unwrap();\n-                let top_drop_data = top_scope.drops.pop().unwrap();\n-\n-                match top_drop_data.kind {\n-                    DropKind::Value { .. } => {\n-                        bug!(\"Drop scheduled on top of condition variable\")\n-                    }\n-                    DropKind::Storage => {\n-                        let source_info = top_scope.source_info(top_drop_data.span);\n-                        let local = top_drop_data.local;\n-                        assert_eq!(local, cond_temp, \"Drop scheduled on top of condition\");\n-                        self.cfg.push(\n-                            true_block,\n-                            Statement {\n-                                source_info,\n-                                kind: StatementKind::StorageDead(local)\n-                            },\n-                        );\n-                        self.cfg.push(\n-                            false_block,\n-                            Statement {\n-                                source_info,\n-                                kind: StatementKind::StorageDead(local)\n-                            },\n-                        );\n+            Operand::Copy(place)\n+            | Operand::Move(place) => {\n+                if let Some(cond_temp) = place.as_local() {\n+                    // Manually drop the condition on both branches.\n+                    let top_scope = self.scopes.scopes.last_mut().unwrap();\n+                    let top_drop_data = top_scope.drops.pop().unwrap();\n+\n+                    match top_drop_data.kind {\n+                        DropKind::Value { .. } => {\n+                            bug!(\"Drop scheduled on top of condition variable\")\n+                        }\n+                        DropKind::Storage => {\n+                            let source_info = top_scope.source_info(top_drop_data.span);\n+                            let local = top_drop_data.local;\n+                            assert_eq!(local, cond_temp, \"Drop scheduled on top of condition\");\n+                            self.cfg.push(\n+                                true_block,\n+                                Statement {\n+                                    source_info,\n+                                    kind: StatementKind::StorageDead(local)\n+                                },\n+                            );\n+                            self.cfg.push(\n+                                false_block,\n+                                Statement {\n+                                    source_info,\n+                                    kind: StatementKind::StorageDead(local)\n+                                },\n+                            );\n+                        }\n                     }\n-                }\n \n-                top_scope.invalidate_cache(true, self.is_generator, true);\n+                    top_scope.invalidate_cache(true, self.is_generator, true);\n+                } else {\n+                    bug!(\"Expected as_local_operand to produce a temporary\");\n+                }\n             }\n-            _ => bug!(\"Expected as_local_operand to produce a temporary\"),\n         }\n \n         (true_block, false_block)"}, {"sha": "1b81032bfe62fd62306bf7c4df629013cc1ce09d", "filename": "src/librustc_mir/dataflow/impls/storage_liveness.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8bb039fb83f7f18df5e1d71607981c8d4902b7b3/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fstorage_liveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb039fb83f7f18df5e1d71607981c8d4902b7b3/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fstorage_liveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fstorage_liveness.rs?ref=8bb039fb83f7f18df5e1d71607981c8d4902b7b3", "patch": "@@ -157,10 +157,12 @@ impl<'mir, 'tcx> BitDenotation<'tcx> for RequiresStorage<'mir, 'tcx> {\n         // Since `propagate_call_unwind` doesn't exist, we have to kill the\n         // destination here, and then gen it again in `propagate_call_return`.\n         if let TerminatorKind::Call {\n-            destination: Some((Place { base: PlaceBase::Local(local), projection: box [] }, _)),\n+            destination: Some((ref place, _)),\n             ..\n         } = self.body[loc.block].terminator().kind {\n-            sets.kill(local);\n+            if let Some(local) = place.as_local() {\n+                sets.kill(local);\n+            }\n         }\n         self.check_for_move(sets, loc);\n     }"}, {"sha": "52016d4c9363ab55768b70983359a1391e483975", "filename": "src/librustc_mir/dataflow/move_paths/builder.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8bb039fb83f7f18df5e1d71607981c8d4902b7b3/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb039fb83f7f18df5e1d71607981c8d4902b7b3/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs?ref=8bb039fb83f7f18df5e1d71607981c8d4902b7b3", "patch": "@@ -114,7 +114,7 @@ impl<'b, 'a, 'tcx> Gatherer<'b, 'a, 'tcx> {\n                         BorrowedContent {\n                             target_place: Place {\n                                 base: place.base.clone(),\n-                                projection: proj.to_vec().into_boxed_slice(),\n+                                projection: tcx.intern_place_elems(proj),\n                             },\n                         },\n                     ));\n@@ -172,7 +172,7 @@ impl<'b, 'a, 'tcx> Gatherer<'b, 'a, 'tcx> {\n                             Some(base),\n                             Place {\n                                 base: place.base.clone(),\n-                                projection: proj.to_vec().into_boxed_slice(),\n+                                projection: tcx.intern_place_elems(proj),\n                             },\n                         );\n                         ent.insert(path);\n@@ -274,7 +274,7 @@ impl<'b, 'a, 'tcx> Gatherer<'b, 'a, 'tcx> {\n                     // Box starts out uninitialized - need to create a separate\n                     // move-path for the interior so it will be separate from\n                     // the exterior.\n-                    self.create_move_path(&place.clone().deref());\n+                    self.create_move_path(&self.builder.tcx.mk_place_deref(place.clone()));\n                     self.gather_init(place.as_ref(), InitKind::Shallow);\n                 } else {\n                     self.gather_init(place.as_ref(), InitKind::Deep);"}, {"sha": "b599f4799446df4669651f91f306004ac1cac176", "filename": "src/librustc_mir/dataflow/move_paths/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8bb039fb83f7f18df5e1d71607981c8d4902b7b3/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb039fb83f7f18df5e1d71607981c8d4902b7b3/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs?ref=8bb039fb83f7f18df5e1d71607981c8d4902b7b3", "patch": "@@ -327,7 +327,7 @@ impl<'tcx> MoveData<'tcx> {\n     pub fn base_local(&self, mut mpi: MovePathIndex) -> Option<Local> {\n         loop {\n             let path = &self.move_paths[mpi];\n-            if let Place { base: PlaceBase::Local(l), projection: box [] } = path.place {\n+            if let Some(l) = path.place.as_local() {\n                 return Some(l);\n             }\n             if let Some(parent) = path.parent {"}, {"sha": "177639956f7175ff8645f5daaf28ee46d905151e", "filename": "src/librustc_mir/shim.rs", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/8bb039fb83f7f18df5e1d71607981c8d4902b7b3/src%2Flibrustc_mir%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb039fb83f7f18df5e1d71607981c8d4902b7b3/src%2Flibrustc_mir%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fshim.rs?ref=8bb039fb83f7f18df5e1d71607981c8d4902b7b3", "patch": "@@ -117,7 +117,7 @@ fn make_shim<'tcx>(tcx: TyCtxt<'tcx>, instance: ty::InstanceDef<'tcx>) -> &'tcx\n \n     run_passes(tcx, &mut result, instance, None, MirPhase::Const, &[\n         &add_moves_for_packed_drops::AddMovesForPackedDrops,\n-        &no_landing_pads::NoLandingPads,\n+        &no_landing_pads::NoLandingPads::new(tcx),\n         &remove_noop_landing_pads::RemoveNoopLandingPads,\n         &simplify::SimplifyCfg::new(\"make_shim\"),\n         &add_call_guards::CriticalCallEdges,\n@@ -231,7 +231,7 @@ fn build_drop_shim<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId, ty: Option<Ty<'tcx>>)\n                 tcx,\n                 param_env\n             };\n-            let dropee = dropee_ptr.deref();\n+            let dropee = tcx.mk_place_deref(dropee_ptr);\n             let resume_block = elaborator.patch.resume_block();\n             elaborate_drops::elaborate_drop(\n                 &mut elaborator,\n@@ -312,7 +312,7 @@ fn build_clone_shim<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId, self_ty: Ty<'tcx>) -\n     let is_copy = self_ty.is_copy_modulo_regions(tcx, param_env, builder.span);\n \n     let dest = Place::return_place();\n-    let src = Place::from(Local::new(1+0)).deref();\n+    let src = tcx.mk_place_deref(Place::from(Local::new(1+0)));\n \n     match self_ty.kind {\n         _ if is_copy => builder.copy_shim(),\n@@ -415,7 +415,7 @@ impl CloneShimBuilder<'tcx> {\n     }\n \n     fn copy_shim(&mut self) {\n-        let rcvr = Place::from(Local::new(1+0)).deref();\n+        let rcvr = self.tcx.mk_place_deref(Place::from(Local::new(1+0)));\n         let ret_statement = self.make_statement(\n             StatementKind::Assign(\n                 box(\n@@ -561,8 +561,8 @@ impl CloneShimBuilder<'tcx> {\n         // BB #2\n         // `dest[i] = Clone::clone(src[beg])`;\n         // Goto #3 if ok, #5 if unwinding happens.\n-        let dest_field = dest.clone().index(beg);\n-        let src_field = src.index(beg);\n+        let dest_field = self.tcx.mk_place_index(dest.clone(), beg);\n+        let src_field = self.tcx.mk_place_index(src, beg);\n         self.make_clone_call(dest_field, src_field, ty, BasicBlock::new(3),\n                              BasicBlock::new(5));\n \n@@ -616,7 +616,7 @@ impl CloneShimBuilder<'tcx> {\n         // BB #7 (cleanup)\n         // `drop(dest[beg])`;\n         self.block(vec![], TerminatorKind::Drop {\n-            location: dest.index(beg),\n+            location: self.tcx.mk_place_index(dest, beg),\n             target: BasicBlock::new(8),\n             unwind: None,\n         }, true);\n@@ -648,9 +648,9 @@ impl CloneShimBuilder<'tcx> {\n         let mut previous_field = None;\n         for (i, ity) in tys.enumerate() {\n             let field = Field::new(i);\n-            let src_field = src.clone().field(field, ity);\n+            let src_field = self.tcx.mk_place_field(src.clone(), field, ity);\n \n-            let dest_field = dest.clone().field(field, ity);\n+            let dest_field = self.tcx.mk_place_field(dest.clone(), field, ity);\n \n             // #(2i + 1) is the cleanup block for the previous clone operation\n             let cleanup_block = self.block_index_offset(1);\n@@ -721,14 +721,14 @@ fn build_call_shim<'tcx>(\n \n     let rcvr = match rcvr_adjustment {\n         Adjustment::Identity => Operand::Move(rcvr_l),\n-        Adjustment::Deref => Operand::Copy(rcvr_l.deref()),\n+        Adjustment::Deref => Operand::Copy(tcx.mk_place_deref(rcvr_l)),\n         Adjustment::DerefMove => {\n             // fn(Self, ...) -> fn(*mut Self, ...)\n             let arg_ty = local_decls[rcvr_arg].ty;\n             debug_assert!(tcx.generics_of(def_id).has_self && arg_ty == tcx.types.self_param);\n             local_decls[rcvr_arg].ty = tcx.mk_mut_ptr(arg_ty);\n \n-            Operand::Move(rcvr_l.deref())\n+            Operand::Move(tcx.mk_place_deref(rcvr_l))\n         }\n         Adjustment::RefMut => {\n             // let rcvr = &mut rcvr;\n@@ -772,7 +772,7 @@ fn build_call_shim<'tcx>(\n     if let Some(untuple_args) = untuple_args {\n         args.extend(untuple_args.iter().enumerate().map(|(i, ity)| {\n             let arg_place = Place::from(Local::new(1+1));\n-            Operand::Move(arg_place.field(Field::new(i), *ity))\n+            Operand::Move(tcx.mk_place_field(arg_place, Field::new(i), *ity))\n         }));\n     } else {\n         args.extend((1..sig.inputs().len()).map(|i| {\n@@ -901,6 +901,7 @@ pub fn build_adt_ctor(tcx: TyCtxt<'_>, ctor_id: DefId) -> &Body<'_> {\n             )),\n         AggregateKind::Adt(adt_def, variant_index, substs, None, None),\n         source_info,\n+        tcx,\n     ).collect();\n \n     let start_block = BasicBlockData {"}, {"sha": "c8605e22e1084b2b445c663671177c3f4776ff5c", "filename": "src/librustc_mir/transform/check_consts/qualifs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8bb039fb83f7f18df5e1d71607981c8d4902b7b3/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fqualifs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb039fb83f7f18df5e1d71607981c8d4902b7b3/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fqualifs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fqualifs.rs?ref=8bb039fb83f7f18df5e1d71607981c8d4902b7b3", "patch": "@@ -164,8 +164,8 @@ pub trait Qualif {\n \n             Rvalue::Ref(_, _, ref place) => {\n                 // Special-case reborrows to be more like a copy of the reference.\n-                if let box [proj_base @ .., elem] = &place.projection {\n-                    if ProjectionElem::Deref == *elem {\n+                if let &[ref proj_base @ .., elem] = place.projection.as_ref() {\n+                    if ProjectionElem::Deref == elem {\n                         let base_ty = Place::ty_from(&place.base, proj_base, cx.body, cx.tcx).ty;\n                         if let ty::Ref(..) = base_ty.kind {\n                             return Self::in_place(cx, per_local, PlaceRef {"}, {"sha": "fc9290d638018372d89578686a83ac0c13493c3a", "filename": "src/librustc_mir/transform/check_consts/resolver.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/8bb039fb83f7f18df5e1d71607981c8d4902b7b3/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fresolver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb039fb83f7f18df5e1d71607981c8d4902b7b3/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fresolver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fresolver.rs?ref=8bb039fb83f7f18df5e1d71607981c8d4902b7b3", "patch": "@@ -56,16 +56,16 @@ where\n     fn assign_qualif_direct(&mut self, place: &mir::Place<'tcx>, value: bool) {\n         debug_assert!(!place.is_indirect());\n \n-        match (value, place) {\n-            (true, mir::Place { base: mir::PlaceBase::Local(local), .. }) => {\n-                self.qualifs_per_local.insert(*local);\n+        match (value, place.as_ref()) {\n+            (true, mir::PlaceRef { base: &mir::PlaceBase::Local(local), .. }) => {\n+                self.qualifs_per_local.insert(local);\n             }\n \n             // For now, we do not clear the qualif if a local is overwritten in full by\n             // an unqualified rvalue (e.g. `y = 5`). This is to be consistent\n             // with aggregates where we overwrite all fields with assignments, which would not\n             // get this feature.\n-            (false, mir::Place { base: mir::PlaceBase::Local(_local), projection: box [] }) => {\n+            (false, mir::PlaceRef { base: &mir::PlaceBase::Local(_local), projection: &[] }) => {\n                 // self.qualifs_per_local.remove(*local);\n             }\n \n@@ -101,11 +101,10 @@ where\n \n         // If a local with no projections is moved from (e.g. `x` in `y = x`), record that\n         // it no longer needs to be dropped.\n-        if let mir::Operand::Move(mir::Place {\n-            base: mir::PlaceBase::Local(local),\n-            projection: box [],\n-        }) = *operand {\n-            self.qualifs_per_local.remove(local);\n+        if let mir::Operand::Move(place) = operand {\n+            if let Some(local) = place.as_local() {\n+                self.qualifs_per_local.remove(local);\n+            }\n         }\n     }\n "}, {"sha": "76a73adf03836368e96935659505a089016ffe31", "filename": "src/librustc_mir/transform/check_consts/validation.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/8bb039fb83f7f18df5e1d71607981c8d4902b7b3/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb039fb83f7f18df5e1d71607981c8d4902b7b3/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs?ref=8bb039fb83f7f18df5e1d71607981c8d4902b7b3", "patch": "@@ -244,8 +244,8 @@ impl Visitor<'tcx> for Validator<'_, 'mir, 'tcx> {\n         if let Rvalue::Ref(_, kind, ref place) = *rvalue {\n             // Special-case reborrows to be more like a copy of a reference.\n             let mut reborrow_place = None;\n-            if let box [proj_base @ .., elem] = &place.projection {\n-                if *elem == ProjectionElem::Deref {\n+            if let &[ref proj_base @ .., elem] = place.projection.as_ref() {\n+                if elem == ProjectionElem::Deref {\n                     let base_ty = Place::ty_from(&place.base, proj_base, self.body, self.tcx).ty;\n                     if let ty::Ref(..) = base_ty.kind {\n                         reborrow_place = Some(proj_base);\n@@ -376,12 +376,15 @@ impl Visitor<'tcx> for Validator<'_, 'mir, 'tcx> {\n             );\n \n             if rvalue_has_mut_interior {\n-                let is_derived_from_illegal_borrow = match *borrowed_place {\n+                let is_derived_from_illegal_borrow = match borrowed_place.as_local() {\n                     // If an unprojected local was borrowed and its value was the result of an\n                     // illegal borrow, suppress this error and mark the result of this borrow as\n                     // illegal as well.\n-                    Place { base: PlaceBase::Local(borrowed_local), projection: box [] }\n-                        if self.derived_from_illegal_borrow.contains(borrowed_local) => true,\n+                    Some(borrowed_local)\n+                        if self.derived_from_illegal_borrow.contains(borrowed_local) =>\n+                    {\n+                        true\n+                    }\n \n                     // Otherwise proceed normally: check the legality of a mutable borrow in this\n                     // context.\n@@ -394,7 +397,7 @@ impl Visitor<'tcx> for Validator<'_, 'mir, 'tcx> {\n                 // FIXME: should we also clear `derived_from_illegal_borrow` when a local is\n                 // assigned a new value?\n                 if is_derived_from_illegal_borrow {\n-                    if let Place { base: PlaceBase::Local(dest), projection: box [] } = *dest {\n+                    if let Some(dest) = dest.as_local() {\n                         self.derived_from_illegal_borrow.insert(dest);\n                     }\n                 }\n@@ -571,10 +574,7 @@ impl Visitor<'tcx> for Validator<'_, 'mir, 'tcx> {\n                     return;\n                 }\n \n-                let needs_drop = if let Place {\n-                    base: PlaceBase::Local(local),\n-                    projection: box [],\n-                } = *dropped_place {\n+                let needs_drop = if let Some(local) = dropped_place.as_local() {\n                     // Use the span where the local was declared as the span of the drop error.\n                     err_span = self.body.local_decls[local].source_info.span;\n                     self.qualifs.needs_drop.contains(local)"}, {"sha": "d9b983ab790c2b5d74f15804a43db6b4ba86af9b", "filename": "src/librustc_mir/transform/check_unsafety.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8bb039fb83f7f18df5e1d71607981c8d4902b7b3/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb039fb83f7f18df5e1d71607981c8d4902b7b3/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs?ref=8bb039fb83f7f18df5e1d71607981c8d4902b7b3", "patch": "@@ -406,8 +406,8 @@ impl<'a, 'tcx> UnsafetyChecker<'a, 'tcx> {\n         place: &Place<'tcx>,\n         is_mut_use: bool,\n     ) {\n-        let mut cursor = &*place.projection;\n-        while let [proj_base @ .., elem] = cursor {\n+        let mut cursor = place.projection.as_ref();\n+        while let &[ref proj_base @ .., elem] = cursor {\n             cursor = proj_base;\n \n             match elem {"}, {"sha": "4fd4fe45cd4f135cb1f1161e34cb9a7c8670538a", "filename": "src/librustc_mir/transform/cleanup_post_borrowck.rs", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8bb039fb83f7f18df5e1d71607981c8d4902b7b3/src%2Flibrustc_mir%2Ftransform%2Fcleanup_post_borrowck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb039fb83f7f18df5e1d71607981c8d4902b7b3/src%2Flibrustc_mir%2Ftransform%2Fcleanup_post_borrowck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcleanup_post_borrowck.rs?ref=8bb039fb83f7f18df5e1d71607981c8d4902b7b3", "patch": "@@ -24,16 +24,22 @@ use crate::transform::{MirPass, MirSource};\n \n pub struct CleanupNonCodegenStatements;\n \n-pub struct DeleteNonCodegenStatements;\n+pub struct DeleteNonCodegenStatements<'tcx> {\n+    tcx: TyCtxt<'tcx>,\n+}\n \n impl<'tcx> MirPass<'tcx> for CleanupNonCodegenStatements {\n-    fn run_pass(&self, _tcx: TyCtxt<'tcx>, _source: MirSource<'tcx>, body: &mut Body<'tcx>) {\n-        let mut delete = DeleteNonCodegenStatements;\n+    fn run_pass(&self, tcx: TyCtxt<'tcx>, _source: MirSource<'tcx>, body: &mut Body<'tcx>) {\n+        let mut delete = DeleteNonCodegenStatements { tcx };\n         delete.visit_body(body);\n     }\n }\n \n-impl<'tcx> MutVisitor<'tcx> for DeleteNonCodegenStatements {\n+impl<'tcx> MutVisitor<'tcx> for DeleteNonCodegenStatements<'tcx> {\n+    fn tcx(&self) -> TyCtxt<'tcx> {\n+        self.tcx\n+    }\n+\n     fn visit_statement(&mut self,\n                        statement: &mut Statement<'tcx>,\n                        location: Location) {"}, {"sha": "13097a2156167475e6a95fa8094da1d238631f6a", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 22, "deletions": 19, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/8bb039fb83f7f18df5e1d71607981c8d4902b7b3/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb039fb83f7f18df5e1d71607981c8d4902b7b3/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=8bb039fb83f7f18df5e1d71607981c8d4902b7b3", "patch": "@@ -7,10 +7,9 @@ use std::cell::Cell;\n use rustc::hir::def::DefKind;\n use rustc::hir::def_id::DefId;\n use rustc::mir::{\n-    AggregateKind, Constant, Location, Place, PlaceBase, Body, Operand, Rvalue,\n-    Local, UnOp, StatementKind, Statement, LocalKind,\n-    TerminatorKind, Terminator,  ClearCrossCrate, SourceInfo, BinOp,\n-    SourceScope, SourceScopeLocalData, LocalDecl, BasicBlock,\n+    AggregateKind, Constant, Location, Place, PlaceBase, Body, Operand, Rvalue, Local, UnOp,\n+    StatementKind, Statement, LocalKind, TerminatorKind, Terminator,  ClearCrossCrate, SourceInfo,\n+    BinOp, SourceScope, SourceScopeLocalData, LocalDecl, BasicBlock,\n };\n use rustc::mir::visit::{\n     Visitor, PlaceContext, MutatingUseContext, MutVisitor, NonMutatingUseContext,\n@@ -525,18 +524,21 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n             // (e.g. for CTFE) it can never happen. But here in const_prop\n             // unknown data is uninitialized, so if e.g. a function argument is unsized\n             // and has a reference taken, we get an ICE.\n-            Rvalue::Ref(_, _, Place { base: PlaceBase::Local(local), projection: box [] }) => {\n-                trace!(\"checking Ref({:?})\", place);\n-                let alive =\n-                    if let LocalValue::Live(_) = self.ecx.frame().locals[*local].value {\n-                        true\n-                    } else {\n-                        false\n-                    };\n+            Rvalue::Ref(_, _, place_ref) => {\n+                trace!(\"checking Ref({:?})\", place_ref);\n \n-                if !alive {\n-                    trace!(\"skipping Ref({:?}) to uninitialized local\", place);\n-                    return None;\n+                if let Some(local) = place_ref.as_local() {\n+                    let alive =\n+                        if let LocalValue::Live(_) = self.ecx.frame().locals[local].value {\n+                            true\n+                        } else {\n+                            false\n+                        };\n+\n+                    if !alive {\n+                        trace!(\"skipping Ref({:?}) to uninitialized local\", place);\n+                        return None;\n+                    }\n                 }\n             }\n \n@@ -685,6 +687,10 @@ impl<'tcx> Visitor<'tcx> for CanConstProp {\n }\n \n impl<'mir, 'tcx> MutVisitor<'tcx> for ConstPropagator<'mir, 'tcx> {\n+    fn tcx(&self) -> TyCtxt<'tcx> {\n+        self.tcx\n+    }\n+\n     fn visit_constant(\n         &mut self,\n         constant: &mut Constant<'tcx>,\n@@ -706,10 +712,7 @@ impl<'mir, 'tcx> MutVisitor<'tcx> for ConstPropagator<'mir, 'tcx> {\n                 .ty(&self.local_decls, self.tcx)\n                 .ty;\n             if let Ok(place_layout) = self.tcx.layout_of(self.param_env.and(place_ty)) {\n-                if let Place {\n-                    base: PlaceBase::Local(local),\n-                    projection: box [],\n-                } = *place {\n+                if let Some(local) = place.as_local() {\n                     let source = statement.source_info;\n                     if let Some(()) = self.const_prop(rval, place_layout, source, place) {\n                         if self.can_const_prop[local] {"}, {"sha": "4c26feac4af79f1e5fe432cad92f50cd6fdcd21e", "filename": "src/librustc_mir/transform/copy_prop.rs", "status": "modified", "additions": 67, "deletions": 67, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/8bb039fb83f7f18df5e1d71607981c8d4902b7b3/src%2Flibrustc_mir%2Ftransform%2Fcopy_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb039fb83f7f18df5e1d71607981c8d4902b7b3/src%2Flibrustc_mir%2Ftransform%2Fcopy_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcopy_prop.rs?ref=8bb039fb83f7f18df5e1d71607981c8d4902b7b3", "patch": "@@ -19,9 +19,7 @@\n //! (non-mutating) use of `SRC`. These restrictions are conservative and may be relaxed in the\n //! future.\n \n-use rustc::mir::{\n-    Constant, Local, LocalKind, Location, Place, PlaceBase, Body, Operand, Rvalue, StatementKind\n-};\n+use rustc::mir::{Constant, Local, LocalKind, Location, Place, Body, Operand, Rvalue, StatementKind};\n use rustc::mir::visit::MutVisitor;\n use rustc::ty::TyCtxt;\n use crate::transform::{MirPass, MirSource};\n@@ -92,28 +90,32 @@ impl<'tcx> MirPass<'tcx> for CopyPropagation {\n                     };\n \n                     // That use of the source must be an assignment.\n-                    match statement.kind {\n-                        StatementKind::Assign(\n-                            box(\n-                                Place {\n-                                    base: PlaceBase::Local(local),\n-                                    projection: box [],\n-                                },\n-                                Rvalue::Use(ref operand)\n-                            )\n-                        ) if local == dest_local => {\n-                            let maybe_action = match *operand {\n-                                Operand::Copy(ref src_place) |\n-                                Operand::Move(ref src_place) => {\n-                                    Action::local_copy(&body, &def_use_analysis, src_place)\n-                                }\n-                                Operand::Constant(ref src_constant) => {\n-                                    Action::constant(src_constant)\n+                    match &statement.kind {\n+                        StatementKind::Assign(box(place, Rvalue::Use(operand))) => {\n+                            if let Some(local) = place.as_local() {\n+                                if local == dest_local {\n+                                    let maybe_action = match operand {\n+                                        Operand::Copy(ref src_place) |\n+                                        Operand::Move(ref src_place) => {\n+                                            Action::local_copy(&body, &def_use_analysis, src_place)\n+                                        }\n+                                        Operand::Constant(ref src_constant) => {\n+                                            Action::constant(src_constant)\n+                                        }\n+                                    };\n+                                    match maybe_action {\n+                                        Some(this_action) => action = this_action,\n+                                        None => continue,\n+                                    }\n+                                } else {\n+                                    debug!(\"  Can't copy-propagate local: source use is not an \\\n+                                    assignment\");\n+                                    continue\n                                 }\n-                            };\n-                            match maybe_action {\n-                                Some(this_action) => action = this_action,\n-                                None => continue,\n+                            } else {\n+                                debug!(\"  Can't copy-propagate local: source use is not an \\\n+                                    assignment\");\n+                                continue\n                             }\n                         }\n                         _ => {\n@@ -124,7 +126,8 @@ impl<'tcx> MirPass<'tcx> for CopyPropagation {\n                     }\n                 }\n \n-                changed = action.perform(body, &def_use_analysis, dest_local, location) || changed;\n+                changed =\n+                    action.perform(body, &def_use_analysis, dest_local, location, tcx) || changed;\n                 // FIXME(pcwalton): Update the use-def chains to delete the instructions instead of\n                 // regenerating the chains.\n                 break\n@@ -148,31 +151,20 @@ fn eliminate_self_assignments(\n         for def in dest_use_info.defs_not_including_drop() {\n             let location = def.location;\n             if let Some(stmt) = body[location.block].statements.get(location.statement_index) {\n-                match stmt.kind {\n-                    StatementKind::Assign(\n-                        box(\n-                            Place {\n-                                base: PlaceBase::Local(local),\n-                                projection: box [],\n-                            },\n-                            Rvalue::Use(Operand::Copy(Place {\n-                                base: PlaceBase::Local(src_local),\n-                                projection: box [],\n-                            })),\n-                        )\n-                    ) |\n-                    StatementKind::Assign(\n-                        box(\n-                            Place {\n-                                base: PlaceBase::Local(local),\n-                                projection: box [],\n-                            },\n-                            Rvalue::Use(Operand::Move(Place {\n-                                base: PlaceBase::Local(src_local),\n-                                projection: box [],\n-                            })),\n-                        )\n-                    ) if local == dest_local && dest_local == src_local => {}\n+                match &stmt.kind {\n+                    StatementKind::Assign(box (place, Rvalue::Use(Operand::Copy(src_place))))\n+                    | StatementKind::Assign(box (place, Rvalue::Use(Operand::Move(src_place)))) => {\n+                        if let (Some(local), Some(src_local)) =\n+                            (place.as_local(), src_place.as_local())\n+                        {\n+                            if local == dest_local && dest_local == src_local {\n+                            } else {\n+                                continue;\n+                            }\n+                        } else {\n+                            continue;\n+                        }\n+                    }\n                     _ => {\n                         continue;\n                     }\n@@ -198,10 +190,7 @@ impl<'tcx> Action<'tcx> {\n     fn local_copy(body: &Body<'tcx>, def_use_analysis: &DefUseAnalysis, src_place: &Place<'tcx>)\n                   -> Option<Action<'tcx>> {\n         // The source must be a local.\n-        let src_local = if let Place {\n-            base: PlaceBase::Local(local),\n-            projection: box [],\n-        } = *src_place {\n+        let src_local = if let Some(local) = src_place.as_local() {\n             local\n         } else {\n             debug!(\"  Can't copy-propagate local: source is not a local\");\n@@ -256,7 +245,8 @@ impl<'tcx> Action<'tcx> {\n                body: &mut Body<'tcx>,\n                def_use_analysis: &DefUseAnalysis,\n                dest_local: Local,\n-               location: Location)\n+               location: Location,\n+               tcx: TyCtxt<'tcx>)\n                -> bool {\n         match self {\n             Action::PropagateLocalCopy(src_local) => {\n@@ -280,7 +270,7 @@ impl<'tcx> Action<'tcx> {\n                 }\n \n                 // Replace all uses of the destination local with the source local.\n-                def_use_analysis.replace_all_defs_and_uses_with(dest_local, body, src_local);\n+                def_use_analysis.replace_all_defs_and_uses_with(dest_local, body, src_local, tcx);\n \n                 // Finally, zap the now-useless assignment instruction.\n                 debug!(\"  Deleting assignment\");\n@@ -304,7 +294,8 @@ impl<'tcx> Action<'tcx> {\n \n                 // Replace all uses of the destination local with the constant.\n                 let mut visitor = ConstantPropagationVisitor::new(dest_local,\n-                                                                  src_constant);\n+                                                                  src_constant,\n+                                                                  tcx);\n                 for dest_place_use in &dest_local_info.defs_and_uses {\n                     visitor.visit_location(body, dest_place_use.location)\n                 }\n@@ -336,33 +327,42 @@ impl<'tcx> Action<'tcx> {\n struct ConstantPropagationVisitor<'tcx> {\n     dest_local: Local,\n     constant: Constant<'tcx>,\n+    tcx: TyCtxt<'tcx>,\n     uses_replaced: usize,\n }\n \n impl<'tcx> ConstantPropagationVisitor<'tcx> {\n-    fn new(dest_local: Local, constant: Constant<'tcx>)\n+    fn new(dest_local: Local, constant: Constant<'tcx>, tcx: TyCtxt<'tcx>)\n            -> ConstantPropagationVisitor<'tcx> {\n         ConstantPropagationVisitor {\n             dest_local,\n             constant,\n+            tcx,\n             uses_replaced: 0,\n         }\n     }\n }\n \n impl<'tcx> MutVisitor<'tcx> for ConstantPropagationVisitor<'tcx> {\n+    fn tcx(&self) -> TyCtxt<'tcx> {\n+        self.tcx\n+    }\n+\n     fn visit_operand(&mut self, operand: &mut Operand<'tcx>, location: Location) {\n         self.super_operand(operand, location);\n \n-        match *operand {\n-            Operand::Copy(Place {\n-                base: PlaceBase::Local(local),\n-                projection: box [],\n-            }) |\n-            Operand::Move(Place {\n-                base: PlaceBase::Local(local),\n-                projection: box [],\n-            }) if local == self.dest_local => {}\n+        match operand {\n+            Operand::Copy(place) |\n+            Operand::Move(place) => {\n+                if let Some(local) = place.as_local() {\n+                    if local == self.dest_local {\n+                    } else {\n+                        return;\n+                    }\n+                } else {\n+                    return;\n+                }\n+            }\n             _ => return,\n         }\n "}, {"sha": "cdde9e12edcbb37097aec269ba46714bd46c0714", "filename": "src/librustc_mir/transform/deaggregator.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8bb039fb83f7f18df5e1d71607981c8d4902b7b3/src%2Flibrustc_mir%2Ftransform%2Fdeaggregator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb039fb83f7f18df5e1d71607981c8d4902b7b3/src%2Flibrustc_mir%2Ftransform%2Fdeaggregator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fdeaggregator.rs?ref=8bb039fb83f7f18df5e1d71607981c8d4902b7b3", "patch": "@@ -45,6 +45,7 @@ impl<'tcx> MirPass<'tcx> for Deaggregator {\n                     }),\n                     *kind,\n                     source_info,\n+                    tcx,\n                 ))\n             });\n         }"}, {"sha": "b30e2de4ca0bcaa525084ae96edfca706e8dbfaa", "filename": "src/librustc_mir/transform/erase_regions.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8bb039fb83f7f18df5e1d71607981c8d4902b7b3/src%2Flibrustc_mir%2Ftransform%2Ferase_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb039fb83f7f18df5e1d71607981c8d4902b7b3/src%2Flibrustc_mir%2Ftransform%2Ferase_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Ferase_regions.rs?ref=8bb039fb83f7f18df5e1d71607981c8d4902b7b3", "patch": "@@ -23,6 +23,10 @@ impl EraseRegionsVisitor<'tcx> {\n }\n \n impl MutVisitor<'tcx> for EraseRegionsVisitor<'tcx> {\n+    fn tcx(&self) -> TyCtxt<'tcx> {\n+        self.tcx\n+    }\n+\n     fn visit_ty(&mut self, ty: &mut Ty<'tcx>, _: TyContext) {\n         *ty = self.tcx.erase_regions(ty);\n     }"}, {"sha": "911901be36b242f4562d600ce18da3b72c92b41b", "filename": "src/librustc_mir/transform/generator.rs", "status": "modified", "additions": 63, "deletions": 30, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/8bb039fb83f7f18df5e1d71607981c8d4902b7b3/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb039fb83f7f18df5e1d71607981c8d4902b7b3/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs?ref=8bb039fb83f7f18df5e1d71607981c8d4902b7b3", "patch": "@@ -74,12 +74,17 @@ use crate::util::liveness;\n \n pub struct StateTransform;\n \n-struct RenameLocalVisitor {\n+struct RenameLocalVisitor<'tcx> {\n     from: Local,\n     to: Local,\n+    tcx: TyCtxt<'tcx>,\n }\n \n-impl<'tcx> MutVisitor<'tcx> for RenameLocalVisitor {\n+impl<'tcx> MutVisitor<'tcx> for RenameLocalVisitor<'tcx> {\n+    fn tcx(&self) -> TyCtxt<'tcx> {\n+        self.tcx\n+    }\n+\n     fn visit_local(&mut self,\n                    local: &mut Local,\n                    _: PlaceContext,\n@@ -102,9 +107,15 @@ impl<'tcx> MutVisitor<'tcx> for RenameLocalVisitor {\n     }\n }\n \n-struct DerefArgVisitor;\n+struct DerefArgVisitor<'tcx> {\n+    tcx: TyCtxt<'tcx>,\n+}\n+\n+impl<'tcx> MutVisitor<'tcx> for DerefArgVisitor<'tcx> {\n+    fn tcx(&self) -> TyCtxt<'tcx> {\n+        self.tcx\n+    }\n \n-impl<'tcx> MutVisitor<'tcx> for DerefArgVisitor {\n     fn visit_local(&mut self,\n                    local: &mut Local,\n                    _: PlaceContext,\n@@ -119,8 +130,8 @@ impl<'tcx> MutVisitor<'tcx> for DerefArgVisitor {\n         if place.base == PlaceBase::Local(self_arg()) {\n             replace_base(place, Place {\n                 base: PlaceBase::Local(self_arg()),\n-                projection: Box::new([ProjectionElem::Deref]),\n-            });\n+                projection: self.tcx().intern_place_elems(&vec![ProjectionElem::Deref]),\n+            }, self.tcx);\n         } else {\n             self.visit_place_base(&mut place.base, context, location);\n \n@@ -135,25 +146,34 @@ impl<'tcx> MutVisitor<'tcx> for DerefArgVisitor {\n \n struct PinArgVisitor<'tcx> {\n     ref_gen_ty: Ty<'tcx>,\n+    tcx: TyCtxt<'tcx>,\n }\n \n impl<'tcx> MutVisitor<'tcx> for PinArgVisitor<'tcx> {\n+    fn tcx(&self) -> TyCtxt<'tcx> {\n+        self.tcx\n+    }\n+\n     fn visit_local(&mut self,\n                    local: &mut Local,\n                    _: PlaceContext,\n                    _: Location) {\n         assert_ne!(*local, self_arg());\n     }\n \n-    fn visit_place(&mut self,\n-                    place: &mut Place<'tcx>,\n-                    context: PlaceContext,\n-                    location: Location) {\n+    fn visit_place(&mut self, place: &mut Place<'tcx>, context: PlaceContext, location: Location) {\n         if place.base == PlaceBase::Local(self_arg()) {\n-            replace_base(place, Place {\n-                base: PlaceBase::Local(self_arg()),\n-                projection: Box::new([ProjectionElem::Field(Field::new(0), self.ref_gen_ty)]),\n-            });\n+            replace_base(\n+                place,\n+                Place {\n+                    base: PlaceBase::Local(self_arg()),\n+                    projection: self.tcx().intern_place_elems(&vec![ProjectionElem::Field(\n+                            Field::new(0),\n+                            self.ref_gen_ty,\n+                    )]),\n+                },\n+                self.tcx,\n+            );\n         } else {\n             self.visit_place_base(&mut place.base, context, location);\n \n@@ -166,13 +186,13 @@ impl<'tcx> MutVisitor<'tcx> for PinArgVisitor<'tcx> {\n     }\n }\n \n-fn replace_base(place: &mut Place<'tcx>, new_base: Place<'tcx>) {\n+fn replace_base<'tcx>(place: &mut Place<'tcx>, new_base: Place<'tcx>, tcx: TyCtxt<'tcx>) {\n     place.base = new_base.base;\n \n     let mut new_projection = new_base.projection.to_vec();\n     new_projection.append(&mut place.projection.to_vec());\n \n-    place.projection = new_projection.into_boxed_slice();\n+    place.projection = tcx.intern_place_elems(&new_projection);\n }\n \n fn self_arg() -> Local {\n@@ -226,13 +246,13 @@ impl TransformVisitor<'tcx> {\n     // Create a Place referencing a generator struct field\n     fn make_field(&self, variant_index: VariantIdx, idx: usize, ty: Ty<'tcx>) -> Place<'tcx> {\n         let self_place = Place::from(self_arg());\n-        let base = self_place.downcast_unnamed(variant_index);\n+        let base = self.tcx.mk_place_downcast_unnamed(self_place, variant_index);\n         let mut projection = base.projection.to_vec();\n         projection.push(ProjectionElem::Field(Field::new(idx), ty));\n \n         Place {\n             base: base.base,\n-            projection: projection.into_boxed_slice(),\n+            projection: self.tcx.intern_place_elems(&projection),\n         }\n     }\n \n@@ -264,6 +284,10 @@ impl TransformVisitor<'tcx> {\n }\n \n impl MutVisitor<'tcx> for TransformVisitor<'tcx> {\n+    fn tcx(&self) -> TyCtxt<'tcx> {\n+        self.tcx\n+    }\n+\n     fn visit_local(&mut self,\n                    local: &mut Local,\n                    _: PlaceContext,\n@@ -280,7 +304,7 @@ impl MutVisitor<'tcx> for TransformVisitor<'tcx> {\n         if let PlaceBase::Local(l) = place.base {\n             // Replace an Local in the remap with a generator struct access\n             if let Some(&(ty, variant_index, idx)) = self.remap.get(&l) {\n-                replace_base(place, self.make_field(variant_index, idx, ty));\n+                replace_base(place, self.make_field(variant_index, idx, ty), self.tcx);\n             }\n         } else {\n             self.visit_place_base(&mut place.base, context, location);\n@@ -375,7 +399,7 @@ fn make_generator_state_argument_indirect<'tcx>(\n     body.local_decls.raw[1].ty = ref_gen_ty;\n \n     // Add a deref to accesses of the generator state\n-    DerefArgVisitor.visit_body(body);\n+    DerefArgVisitor { tcx }.visit_body(body);\n }\n \n fn make_generator_state_argument_pinned<'tcx>(tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n@@ -390,12 +414,13 @@ fn make_generator_state_argument_pinned<'tcx>(tcx: TyCtxt<'tcx>, body: &mut Body\n     body.local_decls.raw[1].ty = pin_ref_gen_ty;\n \n     // Add the Pin field access to accesses of the generator state\n-    PinArgVisitor { ref_gen_ty }.visit_body(body);\n+    PinArgVisitor { ref_gen_ty, tcx }.visit_body(body);\n }\n \n fn replace_result_variable<'tcx>(\n     ret_ty: Ty<'tcx>,\n     body: &mut Body<'tcx>,\n+    tcx: TyCtxt<'tcx>,\n ) -> Local {\n     let source_info = source_info(body);\n     let new_ret = LocalDecl {\n@@ -416,6 +441,7 @@ fn replace_result_variable<'tcx>(\n     RenameLocalVisitor {\n         from: RETURN_PLACE,\n         to: new_ret_local,\n+        tcx,\n     }.visit_body(body);\n \n     new_ret_local\n@@ -864,17 +890,24 @@ fn elaborate_generator_drops<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId, body: &mut\n \n     for (block, block_data) in body.basic_blocks().iter_enumerated() {\n         let (target, unwind, source_info) = match block_data.terminator() {\n-            &Terminator {\n+            Terminator {\n                 source_info,\n                 kind: TerminatorKind::Drop {\n-                    location: Place {\n-                        base: PlaceBase::Local(local),\n-                        projection: box [],\n-                    },\n+                    location,\n                     target,\n                     unwind\n                 }\n-            } if local == gen => (target, unwind, source_info),\n+            } => {\n+                if let Some(local) = location.as_local() {\n+                    if local == gen {\n+                        (target, unwind, source_info)\n+                    } else {\n+                        continue;\n+                    }\n+                } else {\n+                    continue;\n+                }\n+            }\n             _ => continue,\n         };\n         let unwind = if block_data.is_cleanup {\n@@ -884,10 +917,10 @@ fn elaborate_generator_drops<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId, body: &mut\n         };\n         elaborate_drop(\n             &mut elaborator,\n-            source_info,\n+            *source_info,\n             &Place::from(gen),\n             (),\n-            target,\n+            *target,\n             unwind,\n             block,\n         );\n@@ -1175,7 +1208,7 @@ impl<'tcx> MirPass<'tcx> for StateTransform {\n \n         // We rename RETURN_PLACE which has type mir.return_ty to new_ret_local\n         // RETURN_PLACE then is a fresh unused local with type ret_ty.\n-        let new_ret_local = replace_result_variable(ret_ty, body);\n+        let new_ret_local = replace_result_variable(ret_ty, body, tcx);\n \n         // Extract locals which are live across suspension point into `layout`\n         // `remap` gives a mapping from local indices onto generator struct indices"}, {"sha": "5a34e3f471f666dc426f653029901cc7deb82d99", "filename": "src/librustc_mir/transform/inline.rs", "status": "modified", "additions": 23, "deletions": 28, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/8bb039fb83f7f18df5e1d71607981c8d4902b7b3/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb039fb83f7f18df5e1d71607981c8d4902b7b3/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Finline.rs?ref=8bb039fb83f7f18df5e1d71607981c8d4902b7b3", "patch": "@@ -461,7 +461,7 @@ impl Inliner<'tcx> {\n                     };\n                     caller_body[callsite.bb]\n                         .statements.push(stmt);\n-                    tmp.deref()\n+                    self.tcx.mk_place_deref(tmp)\n                 } else {\n                     destination.0\n                 };\n@@ -481,6 +481,7 @@ impl Inliner<'tcx> {\n                     return_block,\n                     cleanup_block: cleanup,\n                     in_cleanup_block: false,\n+                    tcx: self.tcx,\n                 };\n \n \n@@ -559,7 +560,8 @@ impl Inliner<'tcx> {\n             let tuple_tmp_args =\n                 tuple_tys.iter().enumerate().map(|(i, ty)| {\n                     // This is e.g., `tuple_tmp.0` in our example above.\n-                    let tuple_field = Operand::Move(tuple.clone().field(\n+                    let tuple_field = Operand::Move(tcx.mk_place_field(\n+                        tuple.clone(),\n                         Field::new(i),\n                         ty.expect_ty(),\n                     ));\n@@ -587,13 +589,12 @@ impl Inliner<'tcx> {\n         // FIXME: Analysis of the usage of the arguments to avoid\n         // unnecessary temporaries.\n \n-        if let Operand::Move(Place {\n-            base: PlaceBase::Local(local),\n-            projection: box [],\n-        }) = arg {\n-            if caller_body.local_kind(local) == LocalKind::Temp {\n-                // Reuse the operand if it's a temporary already\n-                return local;\n+        if let Operand::Move(place) = &arg {\n+            if let Some(local) = place.as_local() {\n+                if caller_body.local_kind(local) == LocalKind::Temp {\n+                    // Reuse the operand if it's a temporary already\n+                    return local;\n+                }\n             }\n         }\n \n@@ -639,6 +640,7 @@ struct Integrator<'a, 'tcx> {\n     return_block: BasicBlock,\n     cleanup_block: Option<BasicBlock>,\n     in_cleanup_block: bool,\n+    tcx: TyCtxt<'tcx>,\n }\n \n impl<'a, 'tcx> Integrator<'a, 'tcx> {\n@@ -650,14 +652,9 @@ impl<'a, 'tcx> Integrator<'a, 'tcx> {\n \n     fn make_integrate_local(&self, local: &Local) -> Local {\n         if *local == RETURN_PLACE {\n-            match self.destination {\n-                Place {\n-                    base: PlaceBase::Local(l),\n-                    projection: box [],\n-                } => {\n-                    return l;\n-                },\n-                ref place => bug!(\"Return place is {:?}, not local\", place)\n+            match self.destination.as_local() {\n+                Some(l) => return l,\n+                ref place => bug!(\"Return place is {:?}, not local\", place),\n             }\n         }\n \n@@ -671,6 +668,10 @@ impl<'a, 'tcx> Integrator<'a, 'tcx> {\n }\n \n impl<'a, 'tcx> MutVisitor<'tcx> for Integrator<'a, 'tcx> {\n+    fn tcx(&self) -> TyCtxt<'tcx> {\n+        self.tcx\n+    }\n+\n     fn visit_local(\n         &mut self,\n         local: &mut Local,\n@@ -686,17 +687,11 @@ impl<'a, 'tcx> MutVisitor<'tcx> for Integrator<'a, 'tcx> {\n         context: PlaceContext,\n         location: Location,\n     ) {\n-        match place {\n-            Place {\n-                base: PlaceBase::Local(RETURN_PLACE),\n-                projection: box [],\n-            } => {\n-                // Return pointer; update the place itself\n-                *place = self.destination.clone();\n-            },\n-            _ => {\n-                self.super_place(place, context, location);\n-            }\n+        if let Some(RETURN_PLACE) = place.as_local() {\n+            // Return pointer; update the place itself\n+            *place = self.destination.clone();\n+        } else {\n+            self.super_place(place, context, location);\n         }\n     }\n "}, {"sha": "a567ed668bfa584058c0472aa612ae980d745c3f", "filename": "src/librustc_mir/transform/instcombine.rs", "status": "modified", "additions": 26, "deletions": 22, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/8bb039fb83f7f18df5e1d71607981c8d4902b7b3/src%2Flibrustc_mir%2Ftransform%2Finstcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb039fb83f7f18df5e1d71607981c8d4902b7b3/src%2Flibrustc_mir%2Ftransform%2Finstcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Finstcombine.rs?ref=8bb039fb83f7f18df5e1d71607981c8d4902b7b3", "patch": "@@ -1,7 +1,8 @@\n //! Performs various peephole optimizations.\n \n-use rustc::mir::{Constant, Location, Place, PlaceBase, Body, Operand, ProjectionElem, Rvalue,\n-    Local};\n+use rustc::mir::{\n+    Constant, Location, Place, PlaceBase, PlaceRef, Body, Operand, ProjectionElem, Rvalue, Local\n+};\n use rustc::mir::visit::{MutVisitor, Visitor};\n use rustc::ty::{self, TyCtxt};\n use rustc::util::nodemap::{FxHashMap, FxHashSet};\n@@ -28,32 +29,33 @@ impl<'tcx> MirPass<'tcx> for InstCombine {\n         };\n \n         // Then carry out those optimizations.\n-        MutVisitor::visit_body(&mut InstCombineVisitor { optimizations }, body);\n+        MutVisitor::visit_body(&mut InstCombineVisitor { optimizations, tcx }, body);\n     }\n }\n \n pub struct InstCombineVisitor<'tcx> {\n     optimizations: OptimizationList<'tcx>,\n+    tcx: TyCtxt<'tcx>,\n }\n \n impl<'tcx> MutVisitor<'tcx> for InstCombineVisitor<'tcx> {\n+    fn tcx(&self) -> TyCtxt<'tcx> {\n+        self.tcx\n+    }\n+\n     fn visit_rvalue(&mut self, rvalue: &mut Rvalue<'tcx>, location: Location) {\n         if self.optimizations.and_stars.remove(&location) {\n             debug!(\"replacing `&*`: {:?}\", rvalue);\n-            let new_place = match *rvalue {\n-                Rvalue::Ref(_, _, Place {\n-                    ref mut base,\n-                    projection: ref mut projection @ box [.., _],\n-                }) => {\n-                    if let box [proj_l @ .., proj_r] = projection {\n-                        let place = Place {\n-                            // Replace with dummy\n-                            base: mem::replace(base, PlaceBase::Local(Local::new(0))),\n-                            projection: proj_l.to_vec().into_boxed_slice(),\n-                        };\n-                        *projection = vec![proj_r.clone()].into_boxed_slice();\n+            let new_place = match rvalue {\n+                Rvalue::Ref(_, _, place) => {\n+                    if let &[ref proj_l @ .., proj_r] = place.projection.as_ref() {\n+                        place.projection = self.tcx().intern_place_elems(&vec![proj_r.clone()]);\n \n-                        place\n+                        Place {\n+                            // Replace with dummy\n+                            base: mem::replace(&mut place.base, PlaceBase::Local(Local::new(0))),\n+                            projection: self.tcx().intern_place_elems(proj_l),\n+                        }\n                     } else {\n                         unreachable!();\n                     }\n@@ -91,12 +93,14 @@ impl OptimizationFinder<'b, 'tcx> {\n \n impl Visitor<'tcx> for OptimizationFinder<'b, 'tcx> {\n     fn visit_rvalue(&mut self, rvalue: &Rvalue<'tcx>, location: Location) {\n-        if let Rvalue::Ref(_, _, Place {\n-            base,\n-            projection: box [proj_base @ .., ProjectionElem::Deref],\n-        }) = rvalue {\n-            if Place::ty_from(base, proj_base, self.body, self.tcx).ty.is_region_ptr() {\n-                self.optimizations.and_stars.insert(location);\n+        if let Rvalue::Ref(_, _, place) = rvalue {\n+            if let PlaceRef {\n+                base,\n+                projection: &[ref proj_base @ .., ProjectionElem::Deref],\n+            } = place.as_ref() {\n+                if Place::ty_from(base, proj_base, self.body, self.tcx).ty.is_region_ptr() {\n+                    self.optimizations.and_stars.insert(location);\n+                }\n             }\n         }\n "}, {"sha": "dbe6c7845926dcbe39097d3f5458be25b1ae3fa4", "filename": "src/librustc_mir/transform/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8bb039fb83f7f18df5e1d71607981c8d4902b7b3/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb039fb83f7f18df5e1d71607981c8d4902b7b3/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fmod.rs?ref=8bb039fb83f7f18df5e1d71607981c8d4902b7b3", "patch": "@@ -228,7 +228,7 @@ fn run_optimization_passes<'tcx>(\n ) {\n     run_passes(tcx, body, InstanceDef::Item(def_id), promoted, MirPhase::Optimized, &[\n         // Remove all things only needed by analysis\n-        &no_landing_pads::NoLandingPads,\n+        &no_landing_pads::NoLandingPads::new(tcx),\n         &simplify_branches::SimplifyBranches::new(\"initial\"),\n         &remove_noop_landing_pads::RemoveNoopLandingPads,\n         &cleanup_post_borrowck::CleanupNonCodegenStatements,\n@@ -238,7 +238,7 @@ fn run_optimization_passes<'tcx>(\n         // These next passes must be executed together\n         &add_call_guards::CriticalCallEdges,\n         &elaborate_drops::ElaborateDrops,\n-        &no_landing_pads::NoLandingPads,\n+        &no_landing_pads::NoLandingPads::new(tcx),\n         // AddMovesForPackedDrops needs to run after drop\n         // elaboration.\n         &add_moves_for_packed_drops::AddMovesForPackedDrops,\n@@ -257,7 +257,7 @@ fn run_optimization_passes<'tcx>(\n \n \n         // Optimizations begin.\n-        &uniform_array_move_out::RestoreSubsliceArrayMoveOut,\n+        &uniform_array_move_out::RestoreSubsliceArrayMoveOut::new(tcx),\n         &inline::Inline,\n \n         // Lowering generator control-flow and variables"}, {"sha": "fbd14d9ef61704006fe9c3f6258992c0e086c4d0", "filename": "src/librustc_mir/transform/no_landing_pads.rs", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/8bb039fb83f7f18df5e1d71607981c8d4902b7b3/src%2Flibrustc_mir%2Ftransform%2Fno_landing_pads.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb039fb83f7f18df5e1d71607981c8d4902b7b3/src%2Flibrustc_mir%2Ftransform%2Fno_landing_pads.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fno_landing_pads.rs?ref=8bb039fb83f7f18df5e1d71607981c8d4902b7b3", "patch": "@@ -6,21 +6,33 @@ use rustc::mir::*;\n use rustc::mir::visit::MutVisitor;\n use crate::transform::{MirPass, MirSource};\n \n-pub struct NoLandingPads;\n+pub struct NoLandingPads<'tcx> {\n+    tcx: TyCtxt<'tcx>,\n+}\n+\n+impl<'tcx> NoLandingPads<'tcx> {\n+    pub fn new(tcx: TyCtxt<'tcx>) -> Self {\n+        NoLandingPads { tcx }\n+    }\n+}\n \n-impl<'tcx> MirPass<'tcx> for NoLandingPads {\n+impl<'tcx> MirPass<'tcx> for NoLandingPads<'tcx> {\n     fn run_pass(&self, tcx: TyCtxt<'tcx>, _: MirSource<'tcx>, body: &mut Body<'tcx>) {\n         no_landing_pads(tcx, body)\n     }\n }\n \n pub fn no_landing_pads<'tcx>(tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n     if tcx.sess.no_landing_pads() {\n-        NoLandingPads.visit_body(body);\n+        NoLandingPads::new(tcx).visit_body(body);\n     }\n }\n \n-impl<'tcx> MutVisitor<'tcx> for NoLandingPads {\n+impl<'tcx> MutVisitor<'tcx> for NoLandingPads<'tcx> {\n+    fn tcx(&self) -> TyCtxt<'tcx> {\n+        self.tcx\n+    }\n+\n     fn visit_terminator_kind(&mut self,\n                         kind: &mut TerminatorKind<'tcx>,\n                         location: Location) {"}, {"sha": "7a9c489fa791e3faf1606ded4e5163e68a3ff3eb", "filename": "src/librustc_mir/transform/promote_consts.rs", "status": "modified", "additions": 31, "deletions": 26, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/8bb039fb83f7f18df5e1d71607981c8d4902b7b3/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb039fb83f7f18df5e1d71607981c8d4902b7b3/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs?ref=8bb039fb83f7f18df5e1d71607981c8d4902b7b3", "patch": "@@ -17,7 +17,7 @@ use rustc::mir::*;\n use rustc::mir::visit::{PlaceContext, MutatingUseContext, MutVisitor, Visitor};\n use rustc::mir::traversal::ReversePostorder;\n use rustc::ty::subst::InternalSubsts;\n-use rustc::ty::TyCtxt;\n+use rustc::ty::{List, TyCtxt};\n use syntax_pos::Span;\n \n use rustc_index::vec::{IndexVec, Idx};\n@@ -321,7 +321,7 @@ impl<'a, 'tcx> Promoter<'a, 'tcx> {\n                         ty,\n                         def_id,\n                     }),\n-                    projection: box [],\n+                    projection: List::empty(),\n                 }\n             };\n             let (blocks, local_decls) = self.source.basic_blocks_and_local_decls_mut();\n@@ -339,7 +339,7 @@ impl<'a, 'tcx> Promoter<'a, 'tcx> {\n                                     &mut place.base,\n                                     promoted_place(ty, span).base,\n                                 ),\n-                                projection: box [],\n+                                projection: List::empty(),\n                             })\n                         }\n                         _ => bug!()\n@@ -396,6 +396,10 @@ impl<'a, 'tcx> Promoter<'a, 'tcx> {\n \n /// Replaces all temporaries with their promoted counterparts.\n impl<'a, 'tcx> MutVisitor<'tcx> for Promoter<'a, 'tcx> {\n+    fn tcx(&self) -> TyCtxt<'tcx> {\n+        self.tcx\n+    }\n+\n     fn visit_local(&mut self,\n                    local: &mut Local,\n                    _: PlaceContext,\n@@ -434,14 +438,13 @@ pub fn promote_candidates<'tcx>(\n         match candidate {\n             Candidate::Repeat(Location { block, statement_index }) |\n             Candidate::Ref(Location { block, statement_index }) => {\n-                match body[block].statements[statement_index].kind {\n-                    StatementKind::Assign(box(Place {\n-                        base: PlaceBase::Local(local),\n-                        projection: box [],\n-                    }, _)) => {\n-                        if temps[local] == TempState::PromotedOut {\n-                            // Already promoted.\n-                            continue;\n+                match &body[block].statements[statement_index].kind {\n+                    StatementKind::Assign(box(place, _)) => {\n+                        if let Some(local) = place.as_local() {\n+                            if temps[local] == TempState::PromotedOut {\n+                                // Already promoted.\n+                                continue;\n+                            }\n                         }\n                     }\n                     _ => {}\n@@ -487,28 +490,30 @@ pub fn promote_candidates<'tcx>(\n     let promoted = |index: Local| temps[index] == TempState::PromotedOut;\n     for block in body.basic_blocks_mut() {\n         block.statements.retain(|statement| {\n-            match statement.kind {\n-                StatementKind::Assign(box(Place {\n-                    base: PlaceBase::Local(index),\n-                    projection: box [],\n-                }, _)) |\n+            match &statement.kind {\n+                StatementKind::Assign(box(place, _)) => {\n+                    if let Some(index) = place.as_local() {\n+                        !promoted(index)\n+                    } else {\n+                        true\n+                    }\n+                }\n                 StatementKind::StorageLive(index) |\n                 StatementKind::StorageDead(index) => {\n-                    !promoted(index)\n+                    !promoted(*index)\n                 }\n                 _ => true\n             }\n         });\n         let terminator = block.terminator_mut();\n-        match terminator.kind {\n-            TerminatorKind::Drop { location: Place {\n-                base: PlaceBase::Local(index),\n-                projection: box [],\n-            }, target, .. } => {\n-                if promoted(index) {\n-                    terminator.kind = TerminatorKind::Goto {\n-                        target,\n-                    };\n+        match &terminator.kind {\n+            TerminatorKind::Drop { location: place, target, .. } => {\n+                if let Some(index) = place.as_local() {\n+                    if promoted(index) {\n+                        terminator.kind = TerminatorKind::Goto {\n+                            target: *target,\n+                        };\n+                    }\n                 }\n             }\n             _ => {}"}, {"sha": "6aba91f416299ebc3743592b1838b511f8b34d95", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 24, "deletions": 31, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/8bb039fb83f7f18df5e1d71607981c8d4902b7b3/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb039fb83f7f18df5e1d71607981c8d4902b7b3/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=8bb039fb83f7f18df5e1d71607981c8d4902b7b3", "patch": "@@ -292,8 +292,8 @@ trait Qualif {\n \n             Rvalue::Ref(_, _, ref place) => {\n                 // Special-case reborrows to be more like a copy of the reference.\n-                if let box [proj_base @ .., elem] = &place.projection {\n-                    if ProjectionElem::Deref == *elem {\n+                if let &[ref proj_base @ .., elem] = place.projection.as_ref() {\n+                    if ProjectionElem::Deref == elem {\n                         let base_ty = Place::ty_from(&place.base, proj_base, cx.body, cx.tcx).ty;\n                         if let ty::Ref(..) = base_ty.kind {\n                             return Self::in_place(cx, PlaceRef {\n@@ -1041,26 +1041,24 @@ impl<'a, 'tcx> Checker<'a, 'tcx> {\n             match *candidate {\n                 Candidate::Repeat(Location { block: bb, statement_index: stmt_idx }) => {\n                     if let StatementKind::Assign(box(_, Rvalue::Repeat(\n-                        Operand::Move(Place {\n-                            base: PlaceBase::Local(index),\n-                            projection: box [],\n-                        }),\n+                        Operand::Move(place),\n                         _\n-                    ))) = self.body[bb].statements[stmt_idx].kind {\n-                        promoted_temps.insert(index);\n+                    ))) = &self.body[bb].statements[stmt_idx].kind {\n+                        if let Some(index) = place.as_local() {\n+                            promoted_temps.insert(index);\n+                        }\n                     }\n                 }\n                 Candidate::Ref(Location { block: bb, statement_index: stmt_idx }) => {\n                     if let StatementKind::Assign(\n                         box(\n                             _,\n-                            Rvalue::Ref(_, _, Place {\n-                                base: PlaceBase::Local(index),\n-                                projection: box [],\n-                            })\n+                            Rvalue::Ref(_, _, place)\n                         )\n-                    ) = self.body[bb].statements[stmt_idx].kind {\n-                        promoted_temps.insert(index);\n+                    ) = &self.body[bb].statements[stmt_idx].kind {\n+                        if let Some(index) = place.as_local() {\n+                            promoted_temps.insert(index);\n+                        }\n                     }\n                 }\n                 Candidate::Argument { .. } => {}\n@@ -1237,10 +1235,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n         match *operand {\n             Operand::Move(ref place) => {\n                 // Mark the consumed locals to indicate later drops are noops.\n-                if let Place {\n-                    base: PlaceBase::Local(local),\n-                    projection: box [],\n-                } = *place {\n+                if let Some(local) = place.as_local() {\n                     self.cx.per_local[NeedsDrop].remove(local);\n                 }\n             }\n@@ -1256,8 +1251,8 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n         if let Rvalue::Ref(_, kind, ref place) = *rvalue {\n             // Special-case reborrows.\n             let mut reborrow_place = None;\n-            if let box [proj_base @ .., elem] = &place.projection {\n-                if *elem == ProjectionElem::Deref {\n+            if let &[ref proj_base @ .., elem] = place.projection.as_ref() {\n+                if elem == ProjectionElem::Deref {\n                     let base_ty = Place::ty_from(&place.base, proj_base, self.body, self.tcx).ty;\n                     if let ty::Ref(..) = base_ty.kind {\n                         reborrow_place = Some(proj_base);\n@@ -1568,10 +1563,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n                 unleash_miri!(self);\n                 // HACK(eddyb): emulate a bit of dataflow analysis,\n                 // conservatively, that drop elaboration will do.\n-                let needs_drop = if let Place {\n-                    base: PlaceBase::Local(local),\n-                    projection: box [],\n-                } = *place {\n+                let needs_drop = if let Some(local) = place.as_local() {\n                     if NeedsDrop::in_local(self, local) {\n                         Some(self.body.local_decls[local].source_info.span)\n                     } else {\n@@ -1817,16 +1809,17 @@ fn remove_drop_and_storage_dead_on_promoted_locals(\n             }\n         });\n         let terminator = block.terminator_mut();\n-        match terminator.kind {\n+        match &terminator.kind {\n             TerminatorKind::Drop {\n-                location: Place {\n-                    base: PlaceBase::Local(index),\n-                    projection: box [],\n-                },\n+                location,\n                 target,\n                 ..\n-            } if promoted_temps.contains(index) => {\n-                terminator.kind = TerminatorKind::Goto { target };\n+            } => {\n+                if let Some(index) = location.as_local() {\n+                    if promoted_temps.contains(index) {\n+                        terminator.kind = TerminatorKind::Goto { target: *target };\n+                    }\n+                }\n             }\n             _ => {}\n         }"}, {"sha": "c4e44091bc90d8f0049e3911ac751616768c4b03", "filename": "src/librustc_mir/transform/qualify_min_const_fn.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8bb039fb83f7f18df5e1d71607981c8d4902b7b3/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb039fb83f7f18df5e1d71607981c8d4902b7b3/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs?ref=8bb039fb83f7f18df5e1d71607981c8d4902b7b3", "patch": "@@ -259,8 +259,8 @@ fn check_place(\n     def_id: DefId,\n     body: &Body<'tcx>\n ) -> McfResult {\n-    let mut cursor = &*place.projection;\n-    while let [proj_base @ .., elem] = cursor {\n+    let mut cursor = place.projection.as_ref();\n+    while let &[ref proj_base @ .., elem] = cursor {\n         cursor = proj_base;\n         match elem {\n             ProjectionElem::Downcast(..) => {"}, {"sha": "130393e2c4c865f359586ca96cf75f88374ce139", "filename": "src/librustc_mir/transform/remove_noop_landing_pads.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/8bb039fb83f7f18df5e1d71607981c8d4902b7b3/src%2Flibrustc_mir%2Ftransform%2Fremove_noop_landing_pads.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb039fb83f7f18df5e1d71607981c8d4902b7b3/src%2Flibrustc_mir%2Ftransform%2Fremove_noop_landing_pads.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fremove_noop_landing_pads.rs?ref=8bb039fb83f7f18df5e1d71607981c8d4902b7b3", "patch": "@@ -32,7 +32,7 @@ impl RemoveNoopLandingPads {\n         nop_landing_pads: &BitSet<BasicBlock>,\n     ) -> bool {\n         for stmt in &body[bb].statements {\n-            match stmt.kind {\n+            match &stmt.kind {\n                 StatementKind::FakeRead(..) |\n                 StatementKind::StorageLive(_) |\n                 StatementKind::StorageDead(_) |\n@@ -41,12 +41,13 @@ impl RemoveNoopLandingPads {\n                     // These are all nops in a landing pad\n                 }\n \n-                StatementKind::Assign(box(Place {\n-                    base: PlaceBase::Local(_),\n-                    projection: box [],\n-                }, Rvalue::Use(_))) => {\n-                    // Writing to a local (e.g., a drop flag) does not\n-                    // turn a landing pad to a non-nop\n+                StatementKind::Assign(box(place, Rvalue::Use(_))) => {\n+                    if place.as_local().is_some() {\n+                        // Writing to a local (e.g., a drop flag) does not\n+                        // turn a landing pad to a non-nop\n+                    } else {\n+                        return false;\n+                    }\n                 }\n \n                 StatementKind::Assign { .. } |"}, {"sha": "aada7641df67ac616b712585a8fb489e4a41e7f5", "filename": "src/librustc_mir/transform/rustc_peek.rs", "status": "modified", "additions": 23, "deletions": 15, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/8bb039fb83f7f18df5e1d71607981c8d4902b7b3/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb039fb83f7f18df5e1d71607981c8d4902b7b3/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs?ref=8bb039fb83f7f18df5e1d71607981c8d4902b7b3", "patch": "@@ -155,8 +155,8 @@ fn value_assigned_to_local<'a, 'tcx>(\n     local: Local,\n ) -> Option<&'a mir::Rvalue<'tcx>> {\n     if let mir::StatementKind::Assign(box (place, rvalue)) = &stmt.kind {\n-        if let mir::Place { base: mir::PlaceBase::Local(l), projection: box [] } = place {\n-            if local == *l {\n+        if let Some(l) = place.as_local() {\n+            if local == l {\n                 return Some(&*rvalue);\n             }\n         }\n@@ -192,7 +192,7 @@ impl PeekCall {\n         tcx: TyCtxt<'tcx>,\n         terminator: &mir::Terminator<'tcx>,\n     ) -> Option<Self> {\n-        use mir::{Operand, Place, PlaceBase};\n+        use mir::Operand;\n \n         let span = terminator.source_info.span;\n         if let mir::TerminatorKind::Call { func: Operand::Constant(func), args, .. } =\n@@ -207,14 +207,23 @@ impl PeekCall {\n \n                 assert_eq!(args.len(), 1);\n                 let kind = PeekCallKind::from_arg_ty(substs.type_at(0));\n-                let arg = match args[0] {\n-                    | Operand::Copy(Place { base: PlaceBase::Local(local), projection: box [] })\n-                    | Operand::Move(Place { base: PlaceBase::Local(local), projection: box [] })\n-                    => local,\n-\n+                let arg = match &args[0] {\n+                    Operand::Copy(place) | Operand::Move(place) => {\n+                        if let Some(local) = place.as_local() {\n+                            local\n+                        } else {\n+                            tcx.sess.diagnostic().span_err(\n+                                span,\n+                                \"dataflow::sanity_check cannot feed a non-temp to rustc_peek.\",\n+                            );\n+                            return None;\n+                        }\n+                    }\n                     _ => {\n                         tcx.sess.diagnostic().span_err(\n-                            span, \"dataflow::sanity_check cannot feed a non-temp to rustc_peek.\");\n+                            span,\n+                            \"dataflow::sanity_check cannot feed a non-temp to rustc_peek.\",\n+                        );\n                         return None;\n                     }\n                 };\n@@ -277,12 +286,11 @@ impl<'tcx> RustcPeekAt<'tcx> for IndirectlyMutableLocals<'_, 'tcx> {\n         call: PeekCall,\n     ) {\n         warn!(\"peek_at: place={:?}\", place);\n-        let local = match place {\n-            mir::Place { base: mir::PlaceBase::Local(l), projection: box [] } => *l,\n-            _ => {\n-                tcx.sess.span_err(call.span, \"rustc_peek: argument was not a local\");\n-                return;\n-            }\n+        let local = if let Some(l) = place.as_local() {\n+            l\n+        } else {\n+            tcx.sess.span_err(call.span, \"rustc_peek: argument was not a local\");\n+            return;\n         };\n \n         if !flow_state.contains(local) {"}, {"sha": "1b90ea78c6450c353c996f01b2e11579a8417bc6", "filename": "src/librustc_mir/transform/simplify.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/8bb039fb83f7f18df5e1d71607981c8d4902b7b3/src%2Flibrustc_mir%2Ftransform%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb039fb83f7f18df5e1d71607981c8d4902b7b3/src%2Flibrustc_mir%2Ftransform%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fsimplify.rs?ref=8bb039fb83f7f18df5e1d71607981c8d4902b7b3", "patch": "@@ -319,7 +319,7 @@ impl<'tcx> MirPass<'tcx> for SimplifyLocals {\n \n         let map = make_local_map(&mut body.local_decls, locals);\n         // Update references to all vars and tmps now\n-        LocalUpdater { map }.visit_body(body);\n+        LocalUpdater { map, tcx }.visit_body(body);\n         body.local_decls.shrink_to_fit();\n     }\n }\n@@ -374,11 +374,16 @@ impl<'a, 'tcx> Visitor<'tcx> for DeclMarker<'a, 'tcx> {\n     }\n }\n \n-struct LocalUpdater {\n+struct LocalUpdater<'tcx> {\n     map: IndexVec<Local, Option<Local>>,\n+    tcx: TyCtxt<'tcx>,\n }\n \n-impl<'tcx> MutVisitor<'tcx> for LocalUpdater {\n+impl<'tcx> MutVisitor<'tcx> for LocalUpdater<'tcx> {\n+    fn tcx(&self) -> TyCtxt<'tcx> {\n+        self.tcx\n+    }\n+\n     fn visit_basic_block_data(&mut self, block: BasicBlock, data: &mut BasicBlockData<'tcx>) {\n         // Remove unnecessary StorageLive and StorageDead annotations.\n         data.statements.retain(|stmt| {"}, {"sha": "e4c2f7d389b502d1a5f7f61cbcff7271ea47e634", "filename": "src/librustc_mir/transform/uniform_array_move_out.rs", "status": "modified", "additions": 66, "deletions": 70, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/8bb039fb83f7f18df5e1d71607981c8d4902b7b3/src%2Flibrustc_mir%2Ftransform%2Funiform_array_move_out.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb039fb83f7f18df5e1d71607981c8d4902b7b3/src%2Flibrustc_mir%2Ftransform%2Funiform_array_move_out.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Funiform_array_move_out.rs?ref=8bb039fb83f7f18df5e1d71607981c8d4902b7b3", "patch": "@@ -61,7 +61,7 @@ impl<'a, 'tcx> Visitor<'tcx> for UniformArrayMoveOutVisitor<'a, 'tcx> {\n                     rvalue: &Rvalue<'tcx>,\n                     location: Location) {\n         if let Rvalue::Use(Operand::Move(ref src_place)) = rvalue {\n-            if let box [proj_base @ .., elem] = &src_place.projection {\n+            if let &[ref proj_base @ .., elem] = src_place.projection.as_ref() {\n                 if let ProjectionElem::ConstantIndex{offset: _,\n                                                      min_length: _,\n                                                      from_end: false} = elem {\n@@ -116,16 +116,13 @@ impl<'a, 'tcx> UniformArrayMoveOutVisitor<'a, 'tcx> {\n                             min_length: size,\n                             from_end: false,\n                         });\n-                        self.patch.add_assign(location,\n-                                              Place::from(temp),\n-                                              Rvalue::Use(\n-                                                  Operand::Move(\n-                                                      Place {\n-                                                          base: base.clone(),\n-                                                          projection: projection.into_boxed_slice(),\n-                                                      }\n-                                                  )\n-                                              )\n+                        self.patch.add_assign(\n+                            location,\n+                            Place::from(temp),\n+                            Rvalue::Use(Operand::Move(Place {\n+                                base: base.clone(),\n+                                projection: self.tcx.intern_place_elems(&projection),\n+                            })),\n                         );\n                         temp\n                     }).collect();\n@@ -153,16 +150,13 @@ impl<'a, 'tcx> UniformArrayMoveOutVisitor<'a, 'tcx> {\n                         min_length: size,\n                         from_end: false,\n                     });\n-                    self.patch.add_assign(location,\n-                                          dst_place.clone(),\n-                                          Rvalue::Use(\n-                                              Operand::Move(\n-                                                  Place {\n-                                                      base: base.clone(),\n-                                                      projection: projection.into_boxed_slice(),\n-                                                  }\n-                                              )\n-                                          )\n+                    self.patch.add_assign(\n+                        location,\n+                        dst_place.clone(),\n+                        Rvalue::Use(Operand::Move(Place {\n+                            base: base.clone(),\n+                            projection: self.tcx.intern_place_elems(&projection),\n+                        })),\n                     );\n                 }\n                 _ => {}\n@@ -185,9 +179,11 @@ impl<'a, 'tcx> UniformArrayMoveOutVisitor<'a, 'tcx> {\n //\n // replaced by _10 = move _2[:-1];\n \n-pub struct RestoreSubsliceArrayMoveOut;\n+pub struct RestoreSubsliceArrayMoveOut<'tcx> {\n+    tcx: TyCtxt<'tcx>\n+}\n \n-impl<'tcx> MirPass<'tcx> for RestoreSubsliceArrayMoveOut {\n+impl<'tcx> MirPass<'tcx> for RestoreSubsliceArrayMoveOut<'tcx> {\n     fn run_pass(&self, tcx: TyCtxt<'tcx>, src: MirSource<'tcx>, body: &mut Body<'tcx>) {\n         let mut patch = MirPatch::new(body);\n         let param_env = tcx.param_env(src.def_id());\n@@ -203,18 +199,17 @@ impl<'tcx> MirPass<'tcx> for RestoreSubsliceArrayMoveOut {\n                 if let StatementKind::Assign(box(ref dst_place, ref rval)) = statement.kind {\n                     if let Rvalue::Aggregate(box AggregateKind::Array(_), ref items) = *rval {\n                         let items : Vec<_> = items.iter().map(|item| {\n-                            if let Operand::Move(Place {\n-                                base: PlaceBase::Local(local),\n-                                projection: box [],\n-                            }) = item {\n-                                let local_use = &visitor.locals_use[*local];\n-                                let opt_index_and_place =\n-                                    Self::try_get_item_source(local_use, body);\n-                                // each local should be used twice:\n-                                //  in assign and in aggregate statements\n-                                if local_use.use_count == 2 && opt_index_and_place.is_some() {\n-                                    let (index, src_place) = opt_index_and_place.unwrap();\n-                                    return Some((local_use, index, src_place));\n+                            if let Operand::Move(place) = item {\n+                                if let Some(local) = place.as_local() {\n+                                    let local_use = &visitor.locals_use[local];\n+                                    let opt_index_and_place =\n+                                        Self::try_get_item_source(local_use, body);\n+                                    // each local should be used twice:\n+                                    //  in assign and in aggregate statements\n+                                    if local_use.use_count == 2 && opt_index_and_place.is_some() {\n+                                        let (index, src_place) = opt_index_and_place.unwrap();\n+                                        return Some((local_use, index, src_place));\n+                                    }\n                                 }\n                             }\n                             None\n@@ -230,7 +225,9 @@ impl<'tcx> MirPass<'tcx> for RestoreSubsliceArrayMoveOut {\n                                 None\n                             }\n                         });\n-                        Self::check_and_patch(*candidate, &items, opt_size, &mut patch, dst_place);\n+                        let restore_subslice = RestoreSubsliceArrayMoveOut { tcx };\n+                        restore_subslice\n+                            .check_and_patch(*candidate, &items, opt_size, &mut patch, dst_place);\n                     }\n                 }\n             }\n@@ -239,15 +236,20 @@ impl<'tcx> MirPass<'tcx> for RestoreSubsliceArrayMoveOut {\n     }\n }\n \n-impl RestoreSubsliceArrayMoveOut {\n+impl RestoreSubsliceArrayMoveOut<'tcx> {\n+    pub fn new(tcx: TyCtxt<'tcx>) -> Self {\n+        RestoreSubsliceArrayMoveOut { tcx }\n+    }\n+\n     // Checks that source has size, all locals are inited from same source place and\n     // indices is an integer interval. If all checks pass do the replacent.\n     // items are Vec<Option<LocalUse, index in source array, source place for init local>>\n-    fn check_and_patch<'tcx>(candidate: Location,\n-                             items: &[Option<(&LocalUse, u32, PlaceRef<'_, 'tcx>)>],\n-                             opt_size: Option<u64>,\n-                             patch: &mut MirPatch<'tcx>,\n-                             dst_place: &Place<'tcx>) {\n+    fn check_and_patch(&self,\n+                       candidate: Location,\n+                       items: &[Option<(&LocalUse, u32, PlaceRef<'_, 'tcx>)>],\n+                       opt_size: Option<u64>,\n+                       patch: &mut MirPatch<'tcx>,\n+                       dst_place: &Place<'tcx>) {\n         let opt_src_place = items.first().and_then(|x| *x).map(|x| x.2);\n \n         if opt_size.is_some() && items.iter().all(\n@@ -280,46 +282,40 @@ impl RestoreSubsliceArrayMoveOut {\n                 dst_place.clone(),\n                 Rvalue::Use(Operand::Move(Place {\n                     base: src_place.base.clone(),\n-                    projection: projection.into_boxed_slice(),\n+                    projection: self.tcx.intern_place_elems(&projection),\n                 })),\n             );\n         }\n     }\n \n-    fn try_get_item_source<'a, 'tcx>(local_use: &LocalUse,\n-                                     body: &'a Body<'tcx>) -> Option<(u32, PlaceRef<'a, 'tcx>)> {\n+    fn try_get_item_source<'a>(local_use: &LocalUse,\n+                               body: &'a Body<'tcx>) -> Option<(u32, PlaceRef<'a, 'tcx>)> {\n         if let Some(location) = local_use.first_use {\n             let block = &body[location.block];\n             if block.statements.len() > location.statement_index {\n                 let statement = &block.statements[location.statement_index];\n                 if let StatementKind::Assign(\n-                    box(\n-                        Place {\n-                            base: PlaceBase::Local(_),\n-                            projection: box [],\n-                        },\n-                        Rvalue::Use(Operand::Move(Place {\n-                            base: _,\n-                            projection: box [.., ProjectionElem::ConstantIndex {\n-                                offset, min_length: _, from_end: false\n-                            }],\n-                        })),\n-                    )\n+                    box(place, Rvalue::Use(Operand::Move(src_place)))\n                 ) = &statement.kind {\n-                    // FIXME remove once we can use slices patterns\n-                    if let StatementKind::Assign(\n-                        box(\n-                            _,\n-                            Rvalue::Use(Operand::Move(Place {\n+                    if let (Some(_), PlaceRef {\n+                        base: _,\n+                        projection: &[.., ProjectionElem::ConstantIndex {\n+                            offset, min_length: _, from_end: false\n+                        }],\n+                    }) = (place.as_local(), src_place.as_ref()) {\n+                        if let StatementKind::Assign(\n+                            box(_, Rvalue::Use(Operand::Move(place)))\n+                        ) = &statement.kind {\n+                            if let PlaceRef {\n                                 base,\n-                                projection: box [proj_base @ .., _],\n-                            })),\n-                        )\n-                    ) = &statement.kind {\n-                        return Some((*offset, PlaceRef {\n-                            base,\n-                            projection: proj_base,\n-                        }))\n+                                projection: &[ref proj_base @ .., _],\n+                            } = place.as_ref() {\n+                                return Some((offset, PlaceRef {\n+                                    base,\n+                                    projection: proj_base,\n+                                }))\n+                            }\n+                        }\n                     }\n                 }\n             }"}, {"sha": "e6c3e4384d7aeb189fc5583dbf366d40b02d95d9", "filename": "src/librustc_mir/util/aggregate.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8bb039fb83f7f18df5e1d71607981c8d4902b7b3/src%2Flibrustc_mir%2Futil%2Faggregate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb039fb83f7f18df5e1d71607981c8d4902b7b3/src%2Flibrustc_mir%2Futil%2Faggregate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Faggregate.rs?ref=8bb039fb83f7f18df5e1d71607981c8d4902b7b3", "patch": "@@ -1,5 +1,5 @@\n use rustc::mir::*;\n-use rustc::ty::Ty;\n+use rustc::ty::{Ty, TyCtxt};\n use rustc::ty::layout::VariantIdx;\n use rustc_index::vec::Idx;\n \n@@ -17,6 +17,7 @@ pub fn expand_aggregate<'tcx>(\n     operands: impl Iterator<Item=(Operand<'tcx>, Ty<'tcx>)> + TrustedLen,\n     kind: AggregateKind<'tcx>,\n     source_info: SourceInfo,\n+    tcx: TyCtxt<'tcx>,\n ) -> impl Iterator<Item=Statement<'tcx>> + TrustedLen {\n     let mut set_discriminant = None;\n     let active_field_index = match kind {\n@@ -29,7 +30,7 @@ pub fn expand_aggregate<'tcx>(\n                     },\n                     source_info,\n                 });\n-                lhs = lhs.downcast(adt_def, variant_index);\n+                lhs = tcx.mk_place_downcast(lhs, adt_def, variant_index);\n             }\n             active_field_index\n         }\n@@ -58,15 +59,15 @@ pub fn expand_aggregate<'tcx>(\n             // FIXME(eddyb) `offset` should be u64.\n             let offset = i as u32;\n             assert_eq!(offset as usize, i);\n-            lhs.clone().elem(ProjectionElem::ConstantIndex {\n+            tcx.mk_place_elem(lhs.clone(), ProjectionElem::ConstantIndex {\n                 offset,\n                 // FIXME(eddyb) `min_length` doesn't appear to be used.\n                 min_length: offset + 1,\n                 from_end: false\n             })\n         } else {\n             let field = Field::new(active_field_index.unwrap_or(i));\n-            lhs.clone().field(field, ty)\n+            tcx.mk_place_field(lhs.clone(), field, ty)\n         };\n         Statement {\n             source_info,"}, {"sha": "f949fcf0745f01cf95cb07dd3ec9ffb6268f8481", "filename": "src/librustc_mir/util/alignment.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8bb039fb83f7f18df5e1d71607981c8d4902b7b3/src%2Flibrustc_mir%2Futil%2Falignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb039fb83f7f18df5e1d71607981c8d4902b7b3/src%2Flibrustc_mir%2Futil%2Falignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Falignment.rs?ref=8bb039fb83f7f18df5e1d71607981c8d4902b7b3", "patch": "@@ -38,8 +38,8 @@ fn is_within_packed<'tcx, L>(tcx: TyCtxt<'tcx>, local_decls: &L, place: &Place<'\n where\n     L: HasLocalDecls<'tcx>,\n {\n-    let mut cursor = &*place.projection;\n-    while let [proj_base @ .., elem] = cursor {\n+    let mut cursor = place.projection.as_ref();\n+    while let &[ref proj_base @ .., elem] = cursor {\n         cursor = proj_base;\n \n         match elem {"}, {"sha": "725ec84ca62370682bac1276583acf0c7ce11bb6", "filename": "src/librustc_mir/util/def_use.rs", "status": "modified", "additions": 29, "deletions": 15, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/8bb039fb83f7f18df5e1d71607981c8d4902b7b3/src%2Flibrustc_mir%2Futil%2Fdef_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb039fb83f7f18df5e1d71607981c8d4902b7b3/src%2Flibrustc_mir%2Futil%2Fdef_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fdef_use.rs?ref=8bb039fb83f7f18df5e1d71607981c8d4902b7b3", "patch": "@@ -2,6 +2,7 @@\n \n use rustc::mir::{Body, Local, Location, PlaceElem};\n use rustc::mir::visit::{PlaceContext, MutVisitor, Visitor};\n+use rustc::ty::TyCtxt;\n use rustc_index::vec::IndexVec;\n use std::mem;\n \n@@ -47,20 +48,26 @@ impl DefUseAnalysis {\n         &self.info[local]\n     }\n \n-    fn mutate_defs_and_uses(&self, local: Local, body: &mut Body<'_>, new_local: Local) {\n+    fn mutate_defs_and_uses(\n+        &self,\n+        local: Local,\n+        body: &mut Body<'tcx>,\n+        new_local: Local,\n+        tcx: TyCtxt<'tcx>,\n+    ) {\n         for place_use in &self.info[local].defs_and_uses {\n-            MutateUseVisitor::new(local,\n-                                  new_local,\n-                                  body).visit_location(body, place_use.location)\n+            MutateUseVisitor::new(local, new_local, body, tcx)\n+                .visit_location(body, place_use.location)\n         }\n     }\n \n     // FIXME(pcwalton): this should update the def-use chains.\n     pub fn replace_all_defs_and_uses_with(&self,\n                                           local: Local,\n-                                          body: &mut Body<'_>,\n-                                          new_local: Local) {\n-        self.mutate_defs_and_uses(local, body, new_local)\n+                                          body: &mut Body<'tcx>,\n+                                          new_local: Local,\n+                                          tcx: TyCtxt<'tcx>) {\n+        self.mutate_defs_and_uses(local, body, new_local, tcx)\n     }\n }\n \n@@ -114,21 +121,28 @@ impl Info {\n     }\n }\n \n-struct MutateUseVisitor {\n+struct MutateUseVisitor<'tcx> {\n     query: Local,\n     new_local: Local,\n+    tcx: TyCtxt<'tcx>,\n }\n \n-impl MutateUseVisitor {\n-    fn new(query: Local, new_local: Local, _: &Body<'_>) -> MutateUseVisitor {\n-        MutateUseVisitor {\n-            query,\n-            new_local,\n-        }\n+impl MutateUseVisitor<'tcx> {\n+    fn new(\n+        query: Local,\n+        new_local: Local,\n+        _: &Body<'tcx>,\n+        tcx: TyCtxt<'tcx>,\n+    ) -> MutateUseVisitor<'tcx> {\n+        MutateUseVisitor { query, new_local, tcx }\n     }\n }\n \n-impl MutVisitor<'_> for MutateUseVisitor {\n+impl MutVisitor<'tcx> for MutateUseVisitor<'tcx> {\n+    fn tcx(&self) -> TyCtxt<'tcx> {\n+        self.tcx\n+    }\n+\n     fn visit_local(&mut self,\n                     local: &mut Local,\n                     _context: PlaceContext,"}, {"sha": "a1846a1fb5eaf594f5ff4e5b8e2a357128cde8a8", "filename": "src/librustc_mir/util/elaborate_drops.rs", "status": "modified", "additions": 37, "deletions": 23, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/8bb039fb83f7f18df5e1d71607981c8d4902b7b3/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bb039fb83f7f18df5e1d71607981c8d4902b7b3/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs?ref=8bb039fb83f7f18df5e1d71607981c8d4902b7b3", "patch": "@@ -200,13 +200,14 @@ where\n         variant.fields.iter().enumerate().map(|(i, f)| {\n             let field = Field::new(i);\n             let subpath = self.elaborator.field_subpath(variant_path, field);\n+            let tcx = self.tcx();\n \n             assert_eq!(self.elaborator.param_env().reveal, Reveal::All);\n-            let field_ty = self.tcx().normalize_erasing_regions(\n+            let field_ty = tcx.normalize_erasing_regions(\n                 self.elaborator.param_env(),\n-                f.ty(self.tcx(), substs),\n+                f.ty(tcx, substs),\n             );\n-            (base_place.clone().field(field, field_ty), subpath)\n+            (tcx.mk_place_field(base_place.clone(), field, field_ty), subpath)\n         }).collect()\n     }\n \n@@ -323,7 +324,7 @@ where\n         debug!(\"open_drop_for_tuple({:?}, {:?})\", self, tys);\n \n         let fields = tys.iter().enumerate().map(|(i, &ty)| {\n-            (self.place.clone().field(Field::new(i), ty),\n+            (self.tcx().mk_place_field(self.place.clone(), Field::new(i), ty),\n              self.elaborator.field_subpath(self.path, Field::new(i)))\n         }).collect();\n \n@@ -334,7 +335,7 @@ where\n     fn open_drop_for_box(&mut self, adt: &'tcx ty::AdtDef, substs: SubstsRef<'tcx>) -> BasicBlock {\n         debug!(\"open_drop_for_box({:?}, {:?}, {:?})\", self, adt, substs);\n \n-        let interior = self.place.clone().deref();\n+        let interior = self.tcx().mk_place_deref(self.place.clone());\n         let interior_path = self.elaborator.deref_subpath(self.path);\n \n         let succ = self.succ; // FIXME(#43234)\n@@ -406,14 +407,19 @@ where\n         };\n \n         let mut have_otherwise = false;\n+        let tcx = self.tcx();\n \n-        for (variant_index, discr) in adt.discriminants(self.tcx()) {\n+        for (variant_index, discr) in adt.discriminants(tcx) {\n             let subpath = self.elaborator.downcast_subpath(\n                 self.path, variant_index);\n             if let Some(variant_path) = subpath {\n-                let base_place = self.place.clone().elem(\n-                    ProjectionElem::Downcast(Some(adt.variants[variant_index].ident.name),\n-                                             variant_index));\n+                let base_place = tcx.mk_place_elem(\n+                    self.place.clone(),\n+                    ProjectionElem::Downcast(\n+                        Some(adt.variants[variant_index].ident.name),\n+                        variant_index,\n+                    ),\n+                );\n                 let fields = self.move_paths_for_fields(\n                     &base_place,\n                     variant_path,\n@@ -586,15 +592,15 @@ where\n                 BorrowKind::Mut { allow_two_phase_borrow: false },\n                 Place {\n                     base: PlaceBase::Local(cur),\n-                    projection: Box::new([ProjectionElem::Deref]),\n+                    projection: tcx.intern_place_elems(&vec![ProjectionElem::Deref]),\n                 }\n              ),\n              Rvalue::BinaryOp(BinOp::Offset, move_(&Place::from(cur)), one))\n         } else {\n             (Rvalue::Ref(\n                  tcx.lifetimes.re_erased,\n                  BorrowKind::Mut { allow_two_phase_borrow: false },\n-                 self.place.clone().index(cur)),\n+                 tcx.mk_place_index(self.place.clone(), cur)),\n              Rvalue::BinaryOp(BinOp::Add, move_(&Place::from(cur)), one))\n         };\n \n@@ -627,7 +633,7 @@ where\n         let loop_block = self.elaborator.patch().new_block(loop_block);\n \n         self.elaborator.patch().patch_terminator(drop_block, TerminatorKind::Drop {\n-            location: ptr.clone().deref(),\n+            location: tcx.mk_place_deref(ptr.clone()),\n             target: loop_block,\n             unwind: unwind.into_option()\n         });\n@@ -644,18 +650,27 @@ where\n         //     ptr_based_loop\n         // }\n \n+        let tcx = self.tcx();\n+\n         if let Some(size) = opt_size {\n             let size: u32 = size.try_into().unwrap_or_else(|_| {\n                 bug!(\"move out check isn't implemented for array sizes bigger than u32::MAX\");\n             });\n-            let fields: Vec<(Place<'tcx>, Option<D::Path>)> = (0..size).map(|i| {\n-                (self.place.clone().elem(ProjectionElem::ConstantIndex{\n-                    offset: i,\n-                    min_length: size,\n-                    from_end: false\n-                }),\n-                 self.elaborator.array_subpath(self.path, i, size))\n-            }).collect();\n+            let fields: Vec<(Place<'tcx>, Option<D::Path>)> = (0..size)\n+                .map(|i| {\n+                    (\n+                        tcx.mk_place_elem(\n+                            self.place.clone(),\n+                            ProjectionElem::ConstantIndex {\n+                                offset: i,\n+                                min_length: size,\n+                                from_end: false,\n+                            },\n+                        ),\n+                        self.elaborator.array_subpath(self.path, i, size),\n+                    )\n+                })\n+                .collect();\n \n             if fields.iter().any(|(_,path)| path.is_some()) {\n                 let (succ, unwind) = self.drop_ladder_bottom();\n@@ -664,7 +679,6 @@ where\n         }\n \n         let move_ = |place: &Place<'tcx>| Operand::Move(place.clone());\n-        let tcx = self.tcx();\n         let elem_size = &Place::from(self.new_temp(tcx.types.usize));\n         let len = &Place::from(self.new_temp(tcx.types.usize));\n \n@@ -900,8 +914,8 @@ where\n         );\n         let args = adt.variants[VariantIdx::new(0)].fields.iter().enumerate().map(|(i, f)| {\n             let field = Field::new(i);\n-            let field_ty = f.ty(self.tcx(), substs);\n-            Operand::Move(self.place.clone().field(field, field_ty))\n+            let field_ty = f.ty(tcx, substs);\n+            Operand::Move(tcx.mk_place_field(self.place.clone(), field, field_ty))\n         }).collect();\n \n         let call = TerminatorKind::Call {"}]}