{"sha": "9932870833a3d2c13431c0454a4a91bf54a0e5ab", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk5MzI4NzA4MzNhM2QyYzEzNDMxYzA0NTRhNGE5MWJmNTRhMGU1YWI=", "commit": {"author": {"name": "Paul Faria", "email": "Nashenas88@gmail.com", "date": "2015-06-15T00:07:05Z"}, "committer": {"name": "Paul Faria", "email": "Nashenas88@gmail.com", "date": "2015-06-20T01:04:12Z"}, "message": "Finished implementing proper function check (through FnOnce) and moved tests to new file and updated tests", "tree": {"sha": "44f985edf4892d8478f99daca15c551c93c7f300", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/44f985edf4892d8478f99daca15c551c93c7f300"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9932870833a3d2c13431c0454a4a91bf54a0e5ab", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9932870833a3d2c13431c0454a4a91bf54a0e5ab", "html_url": "https://github.com/rust-lang/rust/commit/9932870833a3d2c13431c0454a4a91bf54a0e5ab", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9932870833a3d2c13431c0454a4a91bf54a0e5ab/comments", "author": {"login": "Nashenas88", "id": 1673130, "node_id": "MDQ6VXNlcjE2NzMxMzA=", "avatar_url": "https://avatars.githubusercontent.com/u/1673130?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nashenas88", "html_url": "https://github.com/Nashenas88", "followers_url": "https://api.github.com/users/Nashenas88/followers", "following_url": "https://api.github.com/users/Nashenas88/following{/other_user}", "gists_url": "https://api.github.com/users/Nashenas88/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nashenas88/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nashenas88/subscriptions", "organizations_url": "https://api.github.com/users/Nashenas88/orgs", "repos_url": "https://api.github.com/users/Nashenas88/repos", "events_url": "https://api.github.com/users/Nashenas88/events{/privacy}", "received_events_url": "https://api.github.com/users/Nashenas88/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Nashenas88", "id": 1673130, "node_id": "MDQ6VXNlcjE2NzMxMzA=", "avatar_url": "https://avatars.githubusercontent.com/u/1673130?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nashenas88", "html_url": "https://github.com/Nashenas88", "followers_url": "https://api.github.com/users/Nashenas88/followers", "following_url": "https://api.github.com/users/Nashenas88/following{/other_user}", "gists_url": "https://api.github.com/users/Nashenas88/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nashenas88/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nashenas88/subscriptions", "organizations_url": "https://api.github.com/users/Nashenas88/orgs", "repos_url": "https://api.github.com/users/Nashenas88/repos", "events_url": "https://api.github.com/users/Nashenas88/events{/privacy}", "received_events_url": "https://api.github.com/users/Nashenas88/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3f8a70b613d9e41dc6db11f1d267025bb26bf73d", "url": "https://api.github.com/repos/rust-lang/rust/commits/3f8a70b613d9e41dc6db11f1d267025bb26bf73d", "html_url": "https://github.com/rust-lang/rust/commit/3f8a70b613d9e41dc6db11f1d267025bb26bf73d"}], "stats": {"total": 146, "additions": 99, "deletions": 47}, "files": [{"sha": "b6bb9d67a318eb2366c4e0ffebbc5724f08ddc08", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 33, "deletions": 23, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/9932870833a3d2c13431c0454a4a91bf54a0e5ab/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9932870833a3d2c13431c0454a4a91bf54a0e5ab/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=9932870833a3d2c13431c0454a4a91bf54a0e5ab", "patch": "@@ -15,8 +15,11 @@ use CrateCtxt;\n \n use astconv::AstConv;\n use check::{self, FnCtxt};\n-use middle::ty::{self, Ty};\n+use middle::ty::{self, Ty, ToPolyTraitRef, AsPredicate};\n use middle::def;\n+use middle::lang_items::FnOnceTraitLangItem;\n+use middle::subst::Substs;\n+use middle::traits::{Obligation, SelectionContext};\n use metadata::{csearch, cstore, decoder};\n \n use syntax::{ast, ast_util};\n@@ -65,31 +68,38 @@ pub fn report_error<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                 if let Some(field) = fields.iter().find(|f| f.name == item_name) {\n                     let expr_string = match cx.sess.codemap().span_to_snippet(expr.span) {\n                         Ok(expr_string) => expr_string,\n-                        _ => \"s\".into() // default to generic placeholder for expression\n+                        _ => \"s\".into() // Default to a generic placeholder for the\n+                                        // expression when we can't generate a string\n+                                        // snippet\n                     };\n \n-                    // TODO Fix when closure note is displayed\n-                    // below commented code from eddyb on irc\n-                    // let substs = subst::Substs::new_trait(vec![fcx.inh.infcx.next_ty_var()], Vec::new(), field_ty);\n-                    // let trait_ref = ty::TraitRef::new(trait_def_id, fcx.tcx().mk_substs(substs));\n-                    // let poly_trait_ref = trait_ref.to_poly_trait_ref();\n-                    // let obligation = traits::Obligation::misc(span, fcx.body_id, poly_trait_ref.as_predicate());\n-                    // let mut selcx = traits::SelectionContext::new(fcx.infcx(), fcx);\n-                    // if selcx.evaluate_obligation(&obligation) { /* suggest */ }\n-                    \n-                    match ty::lookup_field_type(cx, did, field.id, substs).sty {\n-                        ty::TyClosure(_, _) | ty::TyBareFn(_,_) => {\n-                            cx.sess.span_note(span,\n-                                &format!(\"use `({0}.{1})(...)` if you meant to call the \\\n-                                          function stored in the `{1}` field\",\n-                                    expr_string, item_name));\n-                        },\n-                        _ => {\n-                            cx.sess.span_note(span,\n-                                &format!(\"did you mean to write `{0}.{1}`?\",\n-                                    expr_string, item_name));\n-                        },\n+                    // Determine if the field can be used as a function in some way\n+                    let fn_once_trait_did = match cx.lang_items.require(FnOnceTraitLangItem) {\n+                        Ok(trait_did) => trait_did,\n+                        Err(err) => cx.sess.fatal(&err[..])\n                     };\n+\n+                    let field_ty = ty::lookup_field_type(cx, did, field.id, substs);\n+                    let field_ty_substs = Substs::new_trait(vec![fcx.inh.infcx.next_ty_var()],\n+                                                            Vec::new(),\n+                                                            field_ty);\n+                    let trait_ref = ty::TraitRef::new(fn_once_trait_did,\n+                                                      cx.mk_substs(field_ty_substs));\n+                    let poly_trait_ref = trait_ref.to_poly_trait_ref();\n+                    let obligation = Obligation::misc(span,\n+                                                      fcx.body_id,\n+                                                      poly_trait_ref.as_predicate());\n+                    let mut selcx = SelectionContext::new(fcx.infcx(), fcx);\n+\n+                    if selcx.evaluate_obligation(&obligation) {\n+                        cx.sess.span_note(span,\n+                            &format!(\"use `({0}.{1})(...)` if you meant to call the \\\n+                                      function stored in the `{1}` field\",\n+                                expr_string, item_name));\n+                    } else {\n+                        cx.sess.span_note(span, &format!(\"did you mean to write `{0}.{1}`?\",\n+                                                         expr_string, item_name));\n+                    }\n                 }\n             }\n "}, {"sha": "4601db9dba0fc11fdc741eb0d9ce3702de4abf65", "filename": "src/test/compile-fail/issue-18343.rs", "status": "modified", "additions": 1, "deletions": 24, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/9932870833a3d2c13431c0454a4a91bf54a0e5ab/src%2Ftest%2Fcompile-fail%2Fissue-18343.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9932870833a3d2c13431c0454a4a91bf54a0e5ab/src%2Ftest%2Fcompile-fail%2Fissue-18343.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-18343.rs?ref=9932870833a3d2c13431c0454a4a91bf54a0e5ab", "patch": "@@ -10,33 +10,10 @@\n \n struct Obj<F> where F: FnMut() -> u32 {\n     closure: F,\n-    nfn: usize,\n-}\n-\n-struct S<F> where F: FnMut() -> u32 {\n-    v: Obj<F>,\n-}\n-\n-fn func() -> u32 {\n-    0\n }\n \n fn main() {\n-    let o = Obj { closure: || 42, nfn: 42 };\n+    let o = Obj { closure: || 42 };\n     o.closure(); //~ ERROR no method named `closure` found\n     //~^ NOTE use `(o.closure)(...)` if you meant to call the function stored in the `closure` field\n-\n-    // TODO move these to a new test for #2392\n-    let x = o.nfn(); //~ ERROR no method named `nfn` found\n-    //~^ NOTE did you mean to write `o.nfn`?\n-\n-    let b = Obj { closure: func, nfn: 5 };\n-    b.closure(); //~ ERROR no method named `closure` found\n-    //~^ NOTE use `(b.closure)(...)` if you meant to call the function stored in the `closure` field\n-\n-    let s = S { v: b };\n-    s.v.closure();//~ ERROR no method named `closure` found\n-    //~^ NOTE use `(s.v.closure)(...)` if you meant to call the function stored in the `closure` field\n-    s.v.nfn();//~ ERROR no method named `nfn` found\n-    //~^ NOTE did you mean to write `s.v.nfn`?\n }"}, {"sha": "2e1fbdf6394f842867f017a4b0d46af052b4f478", "filename": "src/test/compile-fail/issue-2392.rs", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/9932870833a3d2c13431c0454a4a91bf54a0e5ab/src%2Ftest%2Fcompile-fail%2Fissue-2392.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9932870833a3d2c13431c0454a4a91bf54a0e5ab/src%2Ftest%2Fcompile-fail%2Fissue-2392.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2392.rs?ref=9932870833a3d2c13431c0454a4a91bf54a0e5ab", "patch": "@@ -0,0 +1,65 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(core)]\n+use std::boxed::FnBox;\n+\n+struct Obj<F> where F: FnOnce() -> u32 {\n+    closure: F,\n+    not_closure: usize,\n+}\n+\n+struct BoxedObj {\n+    boxed_closure: Box<FnBox() -> u32>,\n+}\n+\n+struct Wrapper<F> where F: FnMut() -> u32 {\n+    wrap: Obj<F>,\n+}\n+\n+fn func() -> u32 {\n+    0\n+}\n+\n+fn check_expression() -> Obj<Box<FnBox() -> u32>> {\n+    Obj { closure: Box::new(|| 42_u32) as Box<FnBox() -> u32>, not_closure: 42 }\n+}\n+\n+fn main() {\n+    // test variations of function\n+    let o_closure = Obj { closure: || 42, not_closure: 42 };\n+    o_closure.closure(); //~ ERROR no method named `closure` found\n+    //~^ NOTE use `(o_closure.closure)(...)` if you meant to call the function stored in the `closure` field\n+\n+    o_closure.not_closure(); //~ ERROR no method named `not_closure` found\n+    //~^ NOTE did you mean to write `o_closure.not_closure`?\n+\n+    let o_func = Obj { closure: func, not_closure: 5 };\n+    o_func.closure(); //~ ERROR no method named `closure` found\n+    //~^ NOTE use `(o_func.closure)(...)` if you meant to call the function stored in the `closure` field\n+\n+    let boxed_fn = BoxedObj { boxed_closure: Box::new(func) };\n+    boxed_fn.boxed_closure();//~ ERROR no method named `boxed_closure` found\n+    //~^ NOTE use `(boxed_fn.boxed_closure)(...)` if you meant to call the function stored in the `boxed_closure` field\n+\n+    let boxed_closure = BoxedObj { boxed_closure: Box::new(|| 42_u32) as Box<FnBox() -> u32> };\n+    boxed_closure.boxed_closure();//~ ERROR no method named `boxed_closure` found\n+    //~^ NOTE use `(boxed_closure.boxed_closure)(...)` if you meant to call the function stored in the `boxed_closure` field\n+\n+    // test expression writing in the notes\n+    let w = Wrapper { wrap: o_func };\n+    w.wrap.closure();//~ ERROR no method named `closure` found\n+    //~^ NOTE use `(w.wrap.closure)(...)` if you meant to call the function stored in the `closure` field\n+    w.wrap.not_closure();//~ ERROR no method named `not_closure` found\n+    //~^ NOTE did you mean to write `w.wrap.not_closure`?\n+\n+    check_expression().closure();//~ ERROR no method named `closure` found\n+    //~^ NOTE use `(check_expression().closure)(...)` if you meant to call the function stored in the `closure` field\n+}"}]}