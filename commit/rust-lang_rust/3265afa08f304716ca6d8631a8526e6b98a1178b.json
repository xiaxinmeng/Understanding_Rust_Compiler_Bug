{"sha": "3265afa08f304716ca6d8631a8526e6b98a1178b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMyNjVhZmEwOGYzMDQ3MTZjYTZkODYzMWE4NTI2ZTZiOThhMTE3OGI=", "commit": {"author": {"name": "Mark-Simulacrum", "email": "mark.simulacrum@gmail.com", "date": "2016-12-14T23:41:00Z"}, "committer": {"name": "Mark Simulacrum", "email": "mark.simulacrum@gmail.com", "date": "2016-12-21T03:02:50Z"}, "message": "Inline and simplify Callee::call duplicates.", "tree": {"sha": "7c6bbf92d6244a07c0bf754b2a7c4ade30ce062d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7c6bbf92d6244a07c0bf754b2a7c4ade30ce062d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3265afa08f304716ca6d8631a8526e6b98a1178b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3265afa08f304716ca6d8631a8526e6b98a1178b", "html_url": "https://github.com/rust-lang/rust/commit/3265afa08f304716ca6d8631a8526e6b98a1178b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3265afa08f304716ca6d8631a8526e6b98a1178b/comments", "author": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cd57bbe27abac8ece0b927f9ab830ef98f7927e3", "url": "https://api.github.com/repos/rust-lang/rust/commits/cd57bbe27abac8ece0b927f9ab830ef98f7927e3", "html_url": "https://github.com/rust-lang/rust/commit/cd57bbe27abac8ece0b927f9ab830ef98f7927e3"}], "stats": {"total": 165, "additions": 44, "deletions": 121}, "files": [{"sha": "2e09f7273f1c5b1820f308a82adf09fb267b233c", "filename": "src/librustc_trans/callee.rs", "status": "modified", "additions": 34, "deletions": 68, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/3265afa08f304716ca6d8631a8526e6b98a1178b/src%2Flibrustc_trans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3265afa08f304716ca6d8631a8526e6b98a1178b/src%2Flibrustc_trans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcallee.rs?ref=3265afa08f304716ca6d8631a8526e6b98a1178b", "patch": "@@ -27,7 +27,6 @@ use base::*;\n use common::{\n     self, BlockAndBuilder, CrateContext, FunctionContext, SharedCrateContext\n };\n-use cleanup::CleanupScope;\n use consts;\n use declare;\n use value::Value;\n@@ -351,7 +350,7 @@ fn trans_fn_once_adapter_shim<'a, 'tcx>(\n     attributes::set_frame_pointer_elimination(ccx, lloncefn);\n \n     let fcx = FunctionContext::new(ccx, lloncefn, fn_ty, None);\n-    let bcx = fcx.init(false);\n+    let mut bcx = fcx.init(false);\n \n     // the first argument (`self`) will be the (by value) closure env.\n \n@@ -391,8 +390,39 @@ fn trans_fn_once_adapter_shim<'a, 'tcx>(\n     // Call the by-ref closure body with `self` in a cleanup scope,\n     // to drop `self` when the body returns, or in case it unwinds.\n     let mut self_scope = fcx.schedule_drop_mem(llenv, closure_ty);\n-    let bcx = trans_call_fn_once_adapter_shim(\n-        bcx, callee, &llargs[self_idx..], dest, &mut self_scope);\n+    let fn_ret = callee.ty.fn_ret();\n+    let fn_ty = callee.direct_fn_type(bcx.ccx(), &[]);\n+\n+    let first_llarg = if fn_ty.ret.is_indirect() {\n+        dest\n+    } else {\n+        None\n+    };\n+    let llargs = first_llarg.into_iter().chain(llargs[self_idx..].iter().cloned())\n+        .collect::<Vec<_>>();\n+\n+    let llfn = callee.reify(bcx.ccx());\n+    let llret;\n+    if self_scope.is_some() && !bcx.sess().no_landing_pads() {\n+        let normal_bcx = bcx.fcx().build_new_block(\"normal-return\");\n+        let landing_pad = bcx.fcx().get_landing_pad(self_scope.as_mut().unwrap());\n+\n+        llret = bcx.invoke(llfn, &llargs[..], normal_bcx.llbb(), landing_pad, None);\n+        bcx = normal_bcx;\n+    } else {\n+        llret = bcx.call(llfn, &llargs[..], None);\n+    }\n+    fn_ty.apply_attrs_callsite(llret);\n+\n+    if !fn_ty.ret.is_indirect() {\n+        if let Some(llretslot) = dest {\n+            fn_ty.ret.store(&bcx, llret, llretslot);\n+        }\n+    }\n+\n+    if fn_ret.0.is_never() {\n+        bcx.unreachable();\n+    }\n     fcx.trans_scope(&bcx, self_scope);\n     fcx.finish(&bcx);\n \n@@ -706,67 +736,3 @@ fn trans_call_inner<'a, 'blk, 'tcx>(bcx: BlockAndBuilder<'blk, 'tcx>,\n \n     (bcx, llret)\n }\n-\n-// This is a cleaned up version of trans_call_inner.\n-fn trans_call_fn_once_adapter_shim<'a, 'blk, 'tcx>(\n-    bcx: BlockAndBuilder<'blk, 'tcx>,\n-    callee: Callee<'tcx>,\n-    args: &[ValueRef],\n-    opt_llretslot: Option<ValueRef>,\n-    cleanup_scope: &mut Option<CleanupScope<'tcx>>,\n-) -> BlockAndBuilder<'blk, 'tcx> {\n-    let fn_ret = callee.ty.fn_ret();\n-    let fn_ty = callee.direct_fn_type(bcx.ccx(), &[]);\n-\n-    // If there no destination, return must be direct, with no cast.\n-    if opt_llretslot.is_none() {\n-        assert!(!fn_ty.ret.is_indirect() && fn_ty.ret.cast.is_none());\n-    }\n-\n-    let mut llargs = Vec::new();\n-\n-    if fn_ty.ret.is_indirect() {\n-        let mut llretslot = opt_llretslot.unwrap();\n-        if let Some(ty) = fn_ty.ret.cast {\n-            llretslot = bcx.pointercast(llretslot, ty.ptr_to());\n-        }\n-        llargs.push(llretslot);\n-    }\n-\n-    llargs.extend_from_slice(args);\n-\n-    let llfn = match callee.data {\n-        Fn(f) => f,\n-        _ => bug!(\"expected fn pointer callee, found {:?}\", callee)\n-    };\n-\n-    let _icx = push_ctxt(\"invoke_\");\n-    let (llret, bcx) = if cleanup_scope.is_some() && !bcx.sess().no_landing_pads() {\n-        let normal_bcx = bcx.fcx().build_new_block(\"normal-return\");\n-        let landing_pad = bcx.fcx().get_landing_pad(cleanup_scope.as_mut().unwrap());\n-\n-        let llresult = bcx.invoke(llfn, &llargs[..], normal_bcx.llbb(), landing_pad, None);\n-        (llresult, normal_bcx)\n-    } else {\n-        let llresult = bcx.call(llfn, &llargs[..], None);\n-        (llresult, bcx)\n-    };\n-    fn_ty.apply_attrs_callsite(llret);\n-\n-    // If the function we just called does not use an outpointer,\n-    // store the result into the rust outpointer. Cast the outpointer\n-    // type to match because some ABIs will use a different type than\n-    // the Rust type. e.g., a {u32,u32} struct could be returned as\n-    // u64.\n-    if !fn_ty.ret.is_indirect() {\n-        if let Some(llretslot) = opt_llretslot {\n-            fn_ty.ret.store(&bcx, llret, llretslot);\n-        }\n-    }\n-\n-    if fn_ret.0.is_never() {\n-        bcx.unreachable();\n-    }\n-\n-    bcx\n-}"}, {"sha": "a6e9af57aaedf0da72e76586037699cea51d1de1", "filename": "src/librustc_trans/glue.rs", "status": "modified", "additions": 10, "deletions": 53, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/3265afa08f304716ca6d8631a8526e6b98a1178b/src%2Flibrustc_trans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3265afa08f304716ca6d8631a8526e6b98a1178b/src%2Flibrustc_trans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fglue.rs?ref=3265afa08f304716ca6d8631a8526e6b98a1178b", "patch": "@@ -22,9 +22,7 @@ use rustc::traits;\n use rustc::ty::{self, AdtKind, Ty, TyCtxt, TypeFoldable};\n use adt;\n use base::*;\n-use callee::{Callee, CalleeData};\n-use cleanup::CleanupScope;\n-use meth;\n+use callee::Callee;\n use common::*;\n use machine::*;\n use monomorphize;\n@@ -224,7 +222,7 @@ pub fn implement_drop_glue<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     fcx.finish(&bcx);\n }\n \n-fn trans_custom_dtor<'blk, 'tcx>(bcx: BlockAndBuilder<'blk, 'tcx>,\n+fn trans_custom_dtor<'blk, 'tcx>(mut bcx: BlockAndBuilder<'blk, 'tcx>,\n                                  t: Ty<'tcx>,\n                                  v0: ValueRef,\n                                  shallow_drop: bool)\n@@ -272,60 +270,19 @@ fn trans_custom_dtor<'blk, 'tcx>(bcx: BlockAndBuilder<'blk, 'tcx>,\n     };\n     let dtor_did = def.destructor().unwrap();\n     let callee = Callee::def(bcx.ccx(), dtor_did, vtbl.substs);\n-    let bcx = trans_call_custom_dtor(bcx, callee, args, &mut contents_scope);\n-    bcx.fcx().trans_scope(&bcx, contents_scope);\n-    bcx\n-}\n-\n-// Inlined and simplified version of callee::trans_call_inner\n-fn trans_call_custom_dtor<'a, 'blk, 'tcx>(\n-    bcx: BlockAndBuilder<'blk, 'tcx>,\n-    callee: Callee<'tcx>,\n-    args: &[ValueRef],\n-    cleanup_scope: &mut Option<CleanupScope<'tcx>>,\n-) -> BlockAndBuilder<'blk, 'tcx> {\n-    let fn_ret = callee.ty.fn_ret();\n     let fn_ty = callee.direct_fn_type(bcx.ccx(), &[]);\n-\n-    // Return must be direct, with no cast.\n-    assert!(!fn_ty.ret.is_indirect() && fn_ty.ret.cast.is_none());\n-\n-    let mut llargs = Vec::new();\n-\n-    let llfn = match callee.data {\n-        CalleeData::Virtual(idx) => {\n-            llargs.push(args[0]);\n-\n-            let fn_ptr = meth::get_virtual_method(&bcx, args[1], idx);\n-            let llty = fn_ty.llvm_type(&bcx.ccx()).ptr_to();\n-            let llfn = bcx.pointercast(fn_ptr, llty);\n-            llargs.extend_from_slice(&args[2..]);\n-            llfn\n-        }\n-        CalleeData::Fn(f) => {\n-            llargs.extend_from_slice(args);\n-            f\n-        }\n-        _ => bug!(\"Expected virtual or fn pointer callee, found {:?}\", callee)\n-    };\n-\n-    let _icx = push_ctxt(\"invoke_\");\n-    let (llret, bcx) = if cleanup_scope.is_some() && !bcx.sess().no_landing_pads() {\n+    let llret;\n+    if contents_scope.is_some() && !bcx.sess().no_landing_pads() {\n         let normal_bcx = bcx.fcx().build_new_block(\"normal-return\");\n-        let landing_pad = bcx.fcx().get_landing_pad(cleanup_scope.as_mut().unwrap());\n+        let landing_pad = bcx.fcx().get_landing_pad(contents_scope.as_mut().unwrap());\n \n-        let llresult = bcx.invoke(llfn, &llargs[..], normal_bcx.llbb(), landing_pad, None);\n-        (llresult, normal_bcx)\n+        llret = bcx.invoke(callee.reify(bcx.ccx()), args, normal_bcx.llbb(), landing_pad, None);\n+        bcx = normal_bcx;\n     } else {\n-        let llresult = bcx.call(llfn, &llargs[..], None);\n-        (llresult, bcx)\n-    };\n-    fn_ty.apply_attrs_callsite(llret);\n-\n-    if fn_ret.0.is_never() {\n-        bcx.unreachable();\n+        llret = bcx.call(callee.reify(bcx.ccx()), args, None);\n     }\n-\n+    fn_ty.apply_attrs_callsite(llret);\n+    bcx.fcx().trans_scope(&bcx, contents_scope);\n     bcx\n }\n "}]}