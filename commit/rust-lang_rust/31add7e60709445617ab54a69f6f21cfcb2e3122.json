{"sha": "31add7e60709445617ab54a69f6f21cfcb2e3122", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMxYWRkN2U2MDcwOTQ0NTYxN2FiNTRhNjlmNmYyMWNmY2IyZTMxMjI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-05-16T10:32:46Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-05-16T10:32:46Z"}, "message": "Auto merge of #71872 - nnethercote:less-aggressive-arena-growth, r=oli-obk\n\nBe less aggressive with `DroplessArena`/`TypedArena` growth.\n\n`DroplessArena` and `TypedArena` use an aggressive growth strategy: the first chunk is 4 KiB, the second is 8 KiB, and it keeps on doubling indefinitely. DHAT profiles show that sometimes this results in large chunks (e.g. 16-128 MiB) that are barely filled.\n\nThis commit changes things so that the doubling stops at 2 MiB. This is large enough that chunk allocations are still rare (you might get 100s instead of 10s of them) but avoids lots of unused space in the worst case. It makes the same change to `TypedArena`, too.", "tree": {"sha": "607f8911bd26fb7f4269f0f6f1e208fcb73d8a5b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/607f8911bd26fb7f4269f0f6f1e208fcb73d8a5b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/31add7e60709445617ab54a69f6f21cfcb2e3122", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/31add7e60709445617ab54a69f6f21cfcb2e3122", "html_url": "https://github.com/rust-lang/rust/commit/31add7e60709445617ab54a69f6f21cfcb2e3122", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/31add7e60709445617ab54a69f6f21cfcb2e3122/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "584252bfb053149b1405da0951cd855561694990", "url": "https://api.github.com/repos/rust-lang/rust/commits/584252bfb053149b1405da0951cd855561694990", "html_url": "https://github.com/rust-lang/rust/commit/584252bfb053149b1405da0951cd855561694990"}, {"sha": "40d4868b3949c60de42e400baabe281a00a8c615", "url": "https://api.github.com/repos/rust-lang/rust/commits/40d4868b3949c60de42e400baabe281a00a8c615", "html_url": "https://github.com/rust-lang/rust/commit/40d4868b3949c60de42e400baabe281a00a8c615"}], "stats": {"total": 39, "additions": 26, "deletions": 13}, "files": [{"sha": "bbe80c26dcbf98d9c2612e15eb6b4670fdd4c274", "filename": "src/libarena/lib.rs", "status": "modified", "additions": 26, "deletions": 13, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/31add7e60709445617ab54a69f6f21cfcb2e3122/src%2Flibarena%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31add7e60709445617ab54a69f6f21cfcb2e3122/src%2Flibarena%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibarena%2Flib.rs?ref=31add7e60709445617ab54a69f6f21cfcb2e3122", "patch": "@@ -5,8 +5,7 @@\n //! of individual objects while the arena itself is still alive. The benefit\n //! of an arena is very fast allocation; just a pointer bump.\n //!\n-//! This crate implements `TypedArena`, a simple arena that can only hold\n-//! objects of a single type.\n+//! This crate implements several kinds of arena.\n \n #![doc(\n     html_root_url = \"https://doc.rust-lang.org/nightly/\",\n@@ -98,7 +97,13 @@ impl<T> TypedArenaChunk<T> {\n     }\n }\n \n+// The arenas start with PAGE-sized chunks, and then each new chunk is twice as\n+// big as its predecessor, up until we reach HUGE_PAGE-sized chunks, whereupon\n+// we stop growing. This scales well, from arenas that are barely used up to\n+// arenas that are used for 100s of MiBs. Note also that the chosen sizes match\n+// the usual sizes of pages and huge pages on Linux.\n const PAGE: usize = 4096;\n+const HUGE_PAGE: usize = 2 * 1024 * 1024;\n \n impl<T> Default for TypedArena<T> {\n     /// Creates a new `TypedArena`.\n@@ -211,6 +216,9 @@ impl<T> TypedArena<T> {\n     #[cold]\n     fn grow(&self, n: usize) {\n         unsafe {\n+            // We need the element size in to convert chunk sizes (ranging from\n+            // PAGE to HUGE_PAGE bytes) to element counts.\n+            let elem_size = cmp::max(1, mem::size_of::<T>());\n             let mut chunks = self.chunks.borrow_mut();\n             let (chunk, mut new_capacity);\n             if let Some(last_chunk) = chunks.last_mut() {\n@@ -221,18 +229,20 @@ impl<T> TypedArena<T> {\n                     self.end.set(last_chunk.end());\n                     return;\n                 } else {\n+                    // If the previous chunk's capacity is less than HUGE_PAGE\n+                    // bytes, then this chunk will be least double the previous\n+                    // chunk's size.\n                     new_capacity = last_chunk.storage.capacity();\n-                    loop {\n+                    if new_capacity < HUGE_PAGE / elem_size {\n                         new_capacity = new_capacity.checked_mul(2).unwrap();\n-                        if new_capacity >= currently_used_cap + n {\n-                            break;\n-                        }\n                     }\n                 }\n             } else {\n-                let elem_size = cmp::max(1, mem::size_of::<T>());\n-                new_capacity = cmp::max(n, PAGE / elem_size);\n+                new_capacity = PAGE / elem_size;\n             }\n+            // Also ensure that this chunk can fit `n`.\n+            new_capacity = cmp::max(n, new_capacity);\n+\n             chunk = TypedArenaChunk::<T>::new(new_capacity);\n             self.ptr.set(chunk.start());\n             self.end.set(chunk.end());\n@@ -347,17 +357,20 @@ impl DroplessArena {\n                     self.end.set(last_chunk.end());\n                     return;\n                 } else {\n+                    // If the previous chunk's capacity is less than HUGE_PAGE\n+                    // bytes, then this chunk will be least double the previous\n+                    // chunk's size.\n                     new_capacity = last_chunk.storage.capacity();\n-                    loop {\n+                    if new_capacity < HUGE_PAGE {\n                         new_capacity = new_capacity.checked_mul(2).unwrap();\n-                        if new_capacity >= used_bytes + needed_bytes {\n-                            break;\n-                        }\n                     }\n                 }\n             } else {\n-                new_capacity = cmp::max(needed_bytes, PAGE);\n+                new_capacity = PAGE;\n             }\n+            // Also ensure that this chunk can fit `needed_bytes`.\n+            new_capacity = cmp::max(needed_bytes, new_capacity);\n+\n             chunk = TypedArenaChunk::<u8>::new(new_capacity);\n             self.ptr.set(chunk.start());\n             self.end.set(chunk.end());"}]}