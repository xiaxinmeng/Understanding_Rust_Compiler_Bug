{"sha": "0967d28be787b281c0364aca8fb9c25124029b30", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA5NjdkMjhiZTc4N2IyODFjMDM2NGFjYThmYjljMjUxMjQwMjliMzA=", "commit": {"author": {"name": "Matthias Geier", "email": "Matthias.Geier@gmail.com", "date": "2019-04-27T19:28:40Z"}, "committer": {"name": "Matthias Geier", "email": "Matthias.Geier@gmail.com", "date": "2019-04-27T20:43:10Z"}, "message": "Rename .cap() methods to .capacity()\n\n... but leave the old names in there for backwards compatibility.", "tree": {"sha": "c2967660dad38fb753d1d540d22d1a0045e2ea4b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c2967660dad38fb753d1d540d22d1a0045e2ea4b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0967d28be787b281c0364aca8fb9c25124029b30", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0967d28be787b281c0364aca8fb9c25124029b30", "html_url": "https://github.com/rust-lang/rust/commit/0967d28be787b281c0364aca8fb9c25124029b30", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0967d28be787b281c0364aca8fb9c25124029b30/comments", "author": {"login": "mgeier", "id": 705404, "node_id": "MDQ6VXNlcjcwNTQwNA==", "avatar_url": "https://avatars.githubusercontent.com/u/705404?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mgeier", "html_url": "https://github.com/mgeier", "followers_url": "https://api.github.com/users/mgeier/followers", "following_url": "https://api.github.com/users/mgeier/following{/other_user}", "gists_url": "https://api.github.com/users/mgeier/gists{/gist_id}", "starred_url": "https://api.github.com/users/mgeier/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mgeier/subscriptions", "organizations_url": "https://api.github.com/users/mgeier/orgs", "repos_url": "https://api.github.com/users/mgeier/repos", "events_url": "https://api.github.com/users/mgeier/events{/privacy}", "received_events_url": "https://api.github.com/users/mgeier/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mgeier", "id": 705404, "node_id": "MDQ6VXNlcjcwNTQwNA==", "avatar_url": "https://avatars.githubusercontent.com/u/705404?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mgeier", "html_url": "https://github.com/mgeier", "followers_url": "https://api.github.com/users/mgeier/followers", "following_url": "https://api.github.com/users/mgeier/following{/other_user}", "gists_url": "https://api.github.com/users/mgeier/gists{/gist_id}", "starred_url": "https://api.github.com/users/mgeier/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mgeier/subscriptions", "organizations_url": "https://api.github.com/users/mgeier/orgs", "repos_url": "https://api.github.com/users/mgeier/repos", "events_url": "https://api.github.com/users/mgeier/events{/privacy}", "received_events_url": "https://api.github.com/users/mgeier/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c751c7a4f47ddc3a9076d1fd45e5d3e557748280", "url": "https://api.github.com/repos/rust-lang/rust/commits/c751c7a4f47ddc3a9076d1fd45e5d3e557748280", "html_url": "https://github.com/rust-lang/rust/commit/c751c7a4f47ddc3a9076d1fd45e5d3e557748280"}], "stats": {"total": 191, "additions": 99, "deletions": 92}, "files": [{"sha": "793da97a083f923c4d5d60c669ecd33eb38950f3", "filename": "src/liballoc/collections/vec_deque.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/0967d28be787b281c0364aca8fb9c25124029b30/src%2Fliballoc%2Fcollections%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0967d28be787b281c0364aca8fb9c25124029b30/src%2Fliballoc%2Fcollections%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fvec_deque.rs?ref=0967d28be787b281c0364aca8fb9c25124029b30", "patch": "@@ -98,7 +98,7 @@ impl<T> VecDeque<T> {\n             // For zero sized types, we are always at maximum capacity\n             MAXIMUM_ZST_CAPACITY\n         } else {\n-            self.buf.cap()\n+            self.buf.capacity()\n         }\n     }\n \n@@ -314,10 +314,10 @@ impl<T> VecDeque<T> {\n     }\n \n     /// Frobs the head and tail sections around to handle the fact that we\n-    /// just reallocated. Unsafe because it trusts old_cap.\n+    /// just reallocated. Unsafe because it trusts old_capacity.\n     #[inline]\n-    unsafe fn handle_cap_increase(&mut self, old_cap: usize) {\n-        let new_cap = self.cap();\n+    unsafe fn handle_capacity_increase(&mut self, old_capacity: usize) {\n+        let new_capacity = self.cap();\n \n         // Move the shortest contiguous section of the ring buffer\n         //    T             H\n@@ -336,15 +336,15 @@ impl<T> VecDeque<T> {\n         if self.tail <= self.head {\n             // A\n             // Nop\n-        } else if self.head < old_cap - self.tail {\n+        } else if self.head < old_capacity - self.tail {\n             // B\n-            self.copy_nonoverlapping(old_cap, 0, self.head);\n-            self.head += old_cap;\n+            self.copy_nonoverlapping(old_capacity, 0, self.head);\n+            self.head += old_capacity;\n             debug_assert!(self.head > self.tail);\n         } else {\n             // C\n-            let new_tail = new_cap - (old_cap - self.tail);\n-            self.copy_nonoverlapping(new_tail, self.tail, old_cap - self.tail);\n+            let new_tail = new_capacity - (old_capacity - self.tail);\n+            self.copy_nonoverlapping(new_tail, self.tail, old_capacity - self.tail);\n             self.tail = new_tail;\n             debug_assert!(self.head < self.tail);\n         }\n@@ -551,7 +551,7 @@ impl<T> VecDeque<T> {\n         if new_cap > old_cap {\n             self.buf.reserve_exact(used_cap, new_cap - used_cap);\n             unsafe {\n-                self.handle_cap_increase(old_cap);\n+                self.handle_capacity_increase(old_cap);\n             }\n         }\n     }\n@@ -641,7 +641,7 @@ impl<T> VecDeque<T> {\n         if new_cap > old_cap {\n             self.buf.try_reserve_exact(used_cap, new_cap - used_cap)?;\n             unsafe {\n-                self.handle_cap_increase(old_cap);\n+                self.handle_capacity_increase(old_cap);\n             }\n         }\n         Ok(())\n@@ -1873,7 +1873,7 @@ impl<T> VecDeque<T> {\n             let old_cap = self.cap();\n             self.buf.double();\n             unsafe {\n-                self.handle_cap_increase(old_cap);\n+                self.handle_capacity_increase(old_cap);\n             }\n             debug_assert!(!self.is_full());\n         }\n@@ -2708,9 +2708,9 @@ impl<T> From<Vec<T>> for VecDeque<T> {\n \n             // We need to extend the buf if it's not a power of two, too small\n             // or doesn't have at least one free space\n-            if !buf.cap().is_power_of_two() || (buf.cap() < (MINIMUM_CAPACITY + 1)) ||\n-               (buf.cap() == len) {\n-                let cap = cmp::max(buf.cap() + 1, MINIMUM_CAPACITY + 1).next_power_of_two();\n+            if !buf.capacity().is_power_of_two() || (buf.capacity() < (MINIMUM_CAPACITY + 1)) ||\n+               (buf.capacity() == len) {\n+                let cap = cmp::max(buf.capacity() + 1, MINIMUM_CAPACITY + 1).next_power_of_two();\n                 buf.reserve_exact(len, cap - len);\n             }\n \n@@ -3096,8 +3096,8 @@ mod tests {\n     fn test_vec_from_vecdeque() {\n         use crate::vec::Vec;\n \n-        fn create_vec_and_test_convert(cap: usize, offset: usize, len: usize) {\n-            let mut vd = VecDeque::with_capacity(cap);\n+        fn create_vec_and_test_convert(capacity: usize, offset: usize, len: usize) {\n+            let mut vd = VecDeque::with_capacity(capacity);\n             for _ in 0..offset {\n                 vd.push_back(0);\n                 vd.pop_front();"}, {"sha": "e5a8a522fbc18b67355642d424d9c0dc1aaf49e1", "filename": "src/liballoc/raw_vec.rs", "status": "modified", "additions": 66, "deletions": 59, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/0967d28be787b281c0364aca8fb9c25124029b30/src%2Fliballoc%2Fraw_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0967d28be787b281c0364aca8fb9c25124029b30/src%2Fliballoc%2Fraw_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fraw_vec.rs?ref=0967d28be787b281c0364aca8fb9c25124029b30", "patch": "@@ -34,7 +34,7 @@ use crate::boxed::Box;\n /// that might occur with zero-sized types.\n ///\n /// However this means that you need to be careful when round-tripping this type\n-/// with a `Box<[T]>`: `cap()` won't yield the len. However `with_capacity`,\n+/// with a `Box<[T]>`: `capacity()` won't yield the len. However `with_capacity`,\n /// `shrink_to_fit`, and `from_box` will actually set RawVec's private capacity\n /// field. This allows zero-sized types to not be special-cased by consumers of\n /// this type.\n@@ -65,25 +65,25 @@ impl<T, A: Alloc> RawVec<T, A> {\n     /// Like `with_capacity` but parameterized over the choice of\n     /// allocator for the returned RawVec.\n     #[inline]\n-    pub fn with_capacity_in(cap: usize, a: A) -> Self {\n-        RawVec::allocate_in(cap, false, a)\n+    pub fn with_capacity_in(capacity: usize, a: A) -> Self {\n+        RawVec::allocate_in(capacity, false, a)\n     }\n \n     /// Like `with_capacity_zeroed` but parameterized over the choice\n     /// of allocator for the returned RawVec.\n     #[inline]\n-    pub fn with_capacity_zeroed_in(cap: usize, a: A) -> Self {\n-        RawVec::allocate_in(cap, true, a)\n+    pub fn with_capacity_zeroed_in(capacity: usize, a: A) -> Self {\n+        RawVec::allocate_in(capacity, true, a)\n     }\n \n-    fn allocate_in(cap: usize, zeroed: bool, mut a: A) -> Self {\n+    fn allocate_in(capacity: usize, zeroed: bool, mut a: A) -> Self {\n         unsafe {\n             let elem_size = mem::size_of::<T>();\n \n-            let alloc_size = cap.checked_mul(elem_size).unwrap_or_else(|| capacity_overflow());\n+            let alloc_size = capacity.checked_mul(elem_size).unwrap_or_else(|| capacity_overflow());\n             alloc_guard(alloc_size).unwrap_or_else(|_| capacity_overflow());\n \n-            // handles ZSTs and `cap = 0` alike\n+            // handles ZSTs and `capacity = 0` alike\n             let ptr = if alloc_size == 0 {\n                 NonNull::<T>::dangling()\n             } else {\n@@ -102,7 +102,7 @@ impl<T, A: Alloc> RawVec<T, A> {\n \n             RawVec {\n                 ptr: ptr.into(),\n-                cap,\n+                cap: capacity,\n                 a,\n             }\n         }\n@@ -120,8 +120,8 @@ impl<T> RawVec<T, Global> {\n     }\n \n     /// Creates a RawVec (on the system heap) with exactly the\n-    /// capacity and alignment requirements for a `[T; cap]`. This is\n-    /// equivalent to calling RawVec::new when `cap` is 0 or T is\n+    /// capacity and alignment requirements for a `[T; capacity]`. This is\n+    /// equivalent to calling RawVec::new when `capacity` is 0 or T is\n     /// zero-sized. Note that if `T` is zero-sized this means you will\n     /// *not* get a RawVec with the requested capacity!\n     ///\n@@ -135,14 +135,14 @@ impl<T> RawVec<T, Global> {\n     ///\n     /// Aborts on OOM\n     #[inline]\n-    pub fn with_capacity(cap: usize) -> Self {\n-        RawVec::allocate_in(cap, false, Global)\n+    pub fn with_capacity(capacity: usize) -> Self {\n+        RawVec::allocate_in(capacity, false, Global)\n     }\n \n     /// Like `with_capacity` but guarantees the buffer is zeroed.\n     #[inline]\n-    pub fn with_capacity_zeroed(cap: usize) -> Self {\n-        RawVec::allocate_in(cap, true, Global)\n+    pub fn with_capacity_zeroed(capacity: usize) -> Self {\n+        RawVec::allocate_in(capacity, true, Global)\n     }\n }\n \n@@ -154,10 +154,10 @@ impl<T, A: Alloc> RawVec<T, A> {\n     /// The ptr must be allocated (via the given allocator `a`), and with the given capacity. The\n     /// capacity cannot exceed `isize::MAX` (only a concern on 32-bit systems).\n     /// If the ptr and capacity come from a RawVec created via `a`, then this is guaranteed.\n-    pub unsafe fn from_raw_parts_in(ptr: *mut T, cap: usize, a: A) -> Self {\n+    pub unsafe fn from_raw_parts_in(ptr: *mut T, capacity: usize, a: A) -> Self {\n         RawVec {\n             ptr: Unique::new_unchecked(ptr),\n-            cap,\n+            cap: capacity,\n             a,\n         }\n     }\n@@ -171,10 +171,10 @@ impl<T> RawVec<T, Global> {\n     /// The ptr must be allocated (on the system heap), and with the given capacity. The\n     /// capacity cannot exceed `isize::MAX` (only a concern on 32-bit systems).\n     /// If the ptr and capacity come from a RawVec, then this is guaranteed.\n-    pub unsafe fn from_raw_parts(ptr: *mut T, cap: usize) -> Self {\n+    pub unsafe fn from_raw_parts(ptr: *mut T, capacity: usize) -> Self {\n         RawVec {\n             ptr: Unique::new_unchecked(ptr),\n-            cap,\n+            cap: capacity,\n             a: Global,\n         }\n     }\n@@ -191,7 +191,7 @@ impl<T> RawVec<T, Global> {\n \n impl<T, A: Alloc> RawVec<T, A> {\n     /// Gets a raw pointer to the start of the allocation. Note that this is\n-    /// Unique::empty() if `cap = 0` or T is zero-sized. In the former case, you must\n+    /// Unique::empty() if `capacity = 0` or T is zero-sized. In the former case, you must\n     /// be careful.\n     pub fn ptr(&self) -> *mut T {\n         self.ptr.as_ptr()\n@@ -201,14 +201,20 @@ impl<T, A: Alloc> RawVec<T, A> {\n     ///\n     /// This will always be `usize::MAX` if `T` is zero-sized.\n     #[inline(always)]\n-    pub fn cap(&self) -> usize {\n+    pub fn capacity(&self) -> usize {\n         if mem::size_of::<T>() == 0 {\n             !0\n         } else {\n             self.cap\n         }\n     }\n \n+    // For backwards compatibility\n+    #[inline(always)]\n+    pub fn cap(&self) -> usize {\n+        self.capacity()\n+    }\n+\n     /// Returns a shared reference to the allocator backing this RawVec.\n     pub fn alloc(&self) -> &A {\n         &self.a\n@@ -240,7 +246,7 @@ impl<T, A: Alloc> RawVec<T, A> {\n     /// This function is ideal for when pushing elements one-at-a-time because\n     /// you don't need to incur the costs of the more general computations\n     /// reserve needs to do to guard against overflow. You do however need to\n-    /// manually check if your `len == cap`.\n+    /// manually check if your `len == capacity`.\n     ///\n     /// # Panics\n     ///\n@@ -267,7 +273,7 @@ impl<T, A: Alloc> RawVec<T, A> {\n     ///\n     /// impl<T> MyVec<T> {\n     ///     pub fn push(&mut self, elem: T) {\n-    ///         if self.len == self.buf.cap() { self.buf.double(); }\n+    ///         if self.len == self.buf.capacity() { self.buf.double(); }\n     ///         // double would have aborted or panicked if the len exceeded\n     ///         // `isize::MAX` so this is safe to do unchecked now.\n     ///         unsafe {\n@@ -381,20 +387,20 @@ impl<T, A: Alloc> RawVec<T, A> {\n     }\n \n     /// The same as `reserve_exact`, but returns on errors instead of panicking or aborting.\n-    pub fn try_reserve_exact(&mut self, used_cap: usize, needed_extra_cap: usize)\n+    pub fn try_reserve_exact(&mut self, used_capacity: usize, needed_extra_capacity: usize)\n            -> Result<(), CollectionAllocErr> {\n \n-        self.reserve_internal(used_cap, needed_extra_cap, Fallible, Exact)\n+        self.reserve_internal(used_capacity, needed_extra_capacity, Fallible, Exact)\n     }\n \n     /// Ensures that the buffer contains at least enough space to hold\n-    /// `used_cap + needed_extra_cap` elements. If it doesn't already,\n+    /// `used_capacity + needed_extra_capacity` elements. If it doesn't already,\n     /// will reallocate the minimum possible amount of memory necessary.\n     /// Generally this will be exactly the amount of memory necessary,\n     /// but in principle the allocator is free to give back more than\n     /// we asked for.\n     ///\n-    /// If `used_cap` exceeds `self.cap()`, this may fail to actually allocate\n+    /// If `used_capacity` exceeds `self.capacity()`, this may fail to actually allocate\n     /// the requested space. This is not really unsafe, but the unsafe\n     /// code *you* write that relies on the behavior of this function may break.\n     ///\n@@ -407,41 +413,42 @@ impl<T, A: Alloc> RawVec<T, A> {\n     /// # Aborts\n     ///\n     /// Aborts on OOM\n-    pub fn reserve_exact(&mut self, used_cap: usize, needed_extra_cap: usize) {\n-        match self.reserve_internal(used_cap, needed_extra_cap, Infallible, Exact) {\n+    pub fn reserve_exact(&mut self, used_capacity: usize, needed_extra_capacity: usize) {\n+        match self.reserve_internal(used_capacity, needed_extra_capacity, Infallible, Exact) {\n             Err(CapacityOverflow) => capacity_overflow(),\n             Err(AllocErr) => unreachable!(),\n             Ok(()) => { /* yay */ }\n          }\n      }\n \n-    /// Calculates the buffer's new size given that it'll hold `used_cap +\n-    /// needed_extra_cap` elements. This logic is used in amortized reserve methods.\n+    /// Calculates the buffer's new size given that it'll hold `used_capacity +\n+    /// needed_extra_capacity` elements. This logic is used in amortized reserve methods.\n     /// Returns `(new_capacity, new_alloc_size)`.\n-    fn amortized_new_size(&self, used_cap: usize, needed_extra_cap: usize)\n+    fn amortized_new_size(&self, used_capacity: usize, needed_extra_capacity: usize)\n         -> Result<usize, CollectionAllocErr> {\n \n         // Nothing we can really do about these checks :(\n-        let required_cap = used_cap.checked_add(needed_extra_cap).ok_or(CapacityOverflow)?;\n+        let required_cap = used_capacity.checked_add(needed_extra_capacity)\n+            .ok_or(CapacityOverflow)?;\n         // Cannot overflow, because `cap <= isize::MAX`, and type of `cap` is `usize`.\n         let double_cap = self.cap * 2;\n         // `double_cap` guarantees exponential growth.\n         Ok(cmp::max(double_cap, required_cap))\n     }\n \n     /// The same as `reserve`, but returns on errors instead of panicking or aborting.\n-    pub fn try_reserve(&mut self, used_cap: usize, needed_extra_cap: usize)\n+    pub fn try_reserve(&mut self, used_capacity: usize, needed_extra_capacity: usize)\n         -> Result<(), CollectionAllocErr> {\n-        self.reserve_internal(used_cap, needed_extra_cap, Fallible, Amortized)\n+        self.reserve_internal(used_capacity, needed_extra_capacity, Fallible, Amortized)\n     }\n \n     /// Ensures that the buffer contains at least enough space to hold\n-    /// `used_cap + needed_extra_cap` elements. If it doesn't already have\n+    /// `used_capacity + needed_extra_capacity` elements. If it doesn't already have\n     /// enough capacity, will reallocate enough space plus comfortable slack\n     /// space to get amortized `O(1)` behavior. Will limit this behavior\n     /// if it would needlessly cause itself to panic.\n     ///\n-    /// If `used_cap` exceeds `self.cap()`, this may fail to actually allocate\n+    /// If `used_capacity` exceeds `self.capacity()`, this may fail to actually allocate\n     /// the requested space. This is not really unsafe, but the unsafe\n     /// code *you* write that relies on the behavior of this function may break.\n     ///\n@@ -487,20 +494,20 @@ impl<T, A: Alloc> RawVec<T, A> {\n     /// #   vector.push_all(&[1, 3, 5, 7, 9]);\n     /// # }\n     /// ```\n-    pub fn reserve(&mut self, used_cap: usize, needed_extra_cap: usize) {\n-        match self.reserve_internal(used_cap, needed_extra_cap, Infallible, Amortized) {\n+    pub fn reserve(&mut self, used_capacity: usize, needed_extra_capacity: usize) {\n+        match self.reserve_internal(used_capacity, needed_extra_capacity, Infallible, Amortized) {\n             Err(CapacityOverflow) => capacity_overflow(),\n             Err(AllocErr) => unreachable!(),\n             Ok(()) => { /* yay */ }\n         }\n     }\n     /// Attempts to ensure that the buffer contains at least enough space to hold\n-    /// `used_cap + needed_extra_cap` elements. If it doesn't already have\n+    /// `used_capacity + needed_extra_capacity` elements. If it doesn't already have\n     /// enough capacity, will reallocate in place enough space plus comfortable slack\n     /// space to get amortized `O(1)` behavior. Will limit this behaviour\n     /// if it would needlessly cause itself to panic.\n     ///\n-    /// If `used_cap` exceeds `self.cap()`, this may fail to actually allocate\n+    /// If `used_capacity` exceeds `self.capacity()`, this may fail to actually allocate\n     /// the requested space. This is not really unsafe, but the unsafe\n     /// code *you* write that relies on the behavior of this function may break.\n     ///\n@@ -511,7 +518,7 @@ impl<T, A: Alloc> RawVec<T, A> {\n     /// * Panics if the requested capacity exceeds `usize::MAX` bytes.\n     /// * Panics on 32-bit platforms if the requested capacity exceeds\n     ///   `isize::MAX` bytes.\n-    pub fn reserve_in_place(&mut self, used_cap: usize, needed_extra_cap: usize) -> bool {\n+    pub fn reserve_in_place(&mut self, used_capacity: usize, needed_extra_capacity: usize) -> bool {\n         unsafe {\n             // NOTE: we don't early branch on ZSTs here because we want this\n             // to actually catch \"asking for more than usize::MAX\" in that case.\n@@ -520,20 +527,20 @@ impl<T, A: Alloc> RawVec<T, A> {\n \n             // Don't actually need any more capacity. If the current `cap` is 0, we can't\n             // reallocate in place.\n-            // Wrapping in case they give a bad `used_cap`\n+            // Wrapping in case they give a bad `used_capacity`\n             let old_layout = match self.current_layout() {\n                 Some(layout) => layout,\n                 None => return false,\n             };\n-            if self.cap().wrapping_sub(used_cap) >= needed_extra_cap {\n+            if self.capacity().wrapping_sub(used_capacity) >= needed_extra_capacity {\n                 return false;\n             }\n \n-            let new_cap = self.amortized_new_size(used_cap, needed_extra_cap)\n+            let new_cap = self.amortized_new_size(used_capacity, needed_extra_capacity)\n                 .unwrap_or_else(|_| capacity_overflow());\n \n-            // Here, `cap < used_cap + needed_extra_cap <= new_cap`\n-            // (regardless of whether `self.cap - used_cap` wrapped).\n+            // Here, `cap < used_capacity + needed_extra_capacity <= new_cap`\n+            // (regardless of whether `self.cap - used_capacity` wrapped).\n             // Therefore we can safely call grow_in_place.\n \n             let new_layout = Layout::new::<T>().repeat(new_cap).unwrap().0;\n@@ -632,8 +639,8 @@ use ReserveStrategy::*;\n impl<T, A: Alloc> RawVec<T, A> {\n     fn reserve_internal(\n         &mut self,\n-        used_cap: usize,\n-        needed_extra_cap: usize,\n+        used_capacity: usize,\n+        needed_extra_capacity: usize,\n         fallibility: Fallibility,\n         strategy: ReserveStrategy,\n     ) -> Result<(), CollectionAllocErr> {\n@@ -646,15 +653,15 @@ impl<T, A: Alloc> RawVec<T, A> {\n             // panic.\n \n             // Don't actually need any more capacity.\n-            // Wrapping in case they gave a bad `used_cap`.\n-            if self.cap().wrapping_sub(used_cap) >= needed_extra_cap {\n+            // Wrapping in case they gave a bad `used_capacity`.\n+            if self.capacity().wrapping_sub(used_capacity) >= needed_extra_capacity {\n                 return Ok(());\n             }\n \n             // Nothing we can really do about these checks :(\n             let new_cap = match strategy {\n-                Exact => used_cap.checked_add(needed_extra_cap).ok_or(CapacityOverflow)?,\n-                Amortized => self.amortized_new_size(used_cap, needed_extra_cap)?,\n+                Exact => used_capacity.checked_add(needed_extra_capacity).ok_or(CapacityOverflow)?,\n+                Amortized => self.amortized_new_size(used_capacity, needed_extra_capacity)?,\n             };\n             let new_layout = Layout::array::<T>(new_cap).map_err(|_| CapacityOverflow)?;\n \n@@ -692,7 +699,7 @@ impl<T> RawVec<T, Global> {\n     /// Note that this will correctly reconstitute any `cap` changes\n     /// that may have been performed. (see description of type for details)\n     pub unsafe fn into_box(self) -> Box<[T]> {\n-        // NOTE: not calling `cap()` here, actually using the real `cap` field!\n+        // NOTE: not calling `capacity()` here, actually using the real `cap` field!\n         let slice = slice::from_raw_parts_mut(self.ptr(), self.cap);\n         let output: Box<[T]> = Box::from_raw(slice);\n         mem::forget(self);\n@@ -796,29 +803,29 @@ mod tests {\n             let mut v: RawVec<u32> = RawVec::new();\n             // First `reserve` allocates like `reserve_exact`\n             v.reserve(0, 9);\n-            assert_eq!(9, v.cap());\n+            assert_eq!(9, v.capacity());\n         }\n \n         {\n             let mut v: RawVec<u32> = RawVec::new();\n             v.reserve(0, 7);\n-            assert_eq!(7, v.cap());\n+            assert_eq!(7, v.capacity());\n             // 97 if more than double of 7, so `reserve` should work\n             // like `reserve_exact`.\n             v.reserve(7, 90);\n-            assert_eq!(97, v.cap());\n+            assert_eq!(97, v.capacity());\n         }\n \n         {\n             let mut v: RawVec<u32> = RawVec::new();\n             v.reserve(0, 12);\n-            assert_eq!(12, v.cap());\n+            assert_eq!(12, v.capacity());\n             v.reserve(12, 3);\n             // 3 is less than half of 12, so `reserve` must grow\n             // exponentially. At the time of writing this test grow\n             // factor is 2, so new capacity is 24, however, grow factor\n             // of 1.5 is OK too. Hence `>= 18` in assert.\n-            assert!(v.cap() >= 12 + 12 / 2);\n+            assert!(v.capacity() >= 12 + 12 / 2);\n         }\n     }\n "}, {"sha": "72b702de875e387f14291571409dd75e24641c86", "filename": "src/liballoc/vec.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0967d28be787b281c0364aca8fb9c25124029b30/src%2Fliballoc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0967d28be787b281c0364aca8fb9c25124029b30/src%2Fliballoc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fvec.rs?ref=0967d28be787b281c0364aca8fb9c25124029b30", "patch": "@@ -432,7 +432,7 @@ impl<T> Vec<T> {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn capacity(&self) -> usize {\n-        self.buf.cap()\n+        self.buf.capacity()\n     }\n \n     /// Reserves capacity for at least `additional` more elements to be inserted\n@@ -878,7 +878,7 @@ impl<T> Vec<T> {\n         assert!(index <= len);\n \n         // space for the new element\n-        if len == self.buf.cap() {\n+        if len == self.buf.capacity() {\n             self.reserve(1);\n         }\n \n@@ -1019,7 +1019,7 @@ impl<T> Vec<T> {\n     pub fn push(&mut self, value: T) {\n         // This will panic or abort if we would allocate > isize::MAX bytes\n         // or if the length increment would overflow for zero-sized types.\n-        if self.len == self.buf.cap() {\n+        if self.len == self.buf.capacity() {\n             self.reserve(1);\n         }\n         unsafe {\n@@ -1750,7 +1750,7 @@ impl<T> IntoIterator for Vec<T> {\n             } else {\n                 begin.add(self.len()) as *const T\n             };\n-            let cap = self.buf.cap();\n+            let cap = self.buf.capacity();\n             mem::forget(self);\n             IntoIter {\n                 buf: NonNull::new_unchecked(begin),"}, {"sha": "619b25c790534e6670cbf8e8a1fba83dbd67da97", "filename": "src/libarena/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0967d28be787b281c0364aca8fb9c25124029b30/src%2Flibarena%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0967d28be787b281c0364aca8fb9c25124029b30/src%2Flibarena%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibarena%2Flib.rs?ref=0967d28be787b281c0364aca8fb9c25124029b30", "patch": "@@ -99,7 +99,7 @@ impl<T> TypedArenaChunk<T> {\n                 // A pointer as large as possible for zero-sized elements.\n                 !0 as *mut T\n             } else {\n-                self.start().add(self.storage.cap())\n+                self.start().add(self.storage.capacity())\n             }\n         }\n     }\n@@ -270,7 +270,7 @@ impl<T> TypedArena<T> {\n                     self.end.set(last_chunk.end());\n                     return;\n                 } else {\n-                    new_capacity = last_chunk.storage.cap();\n+                    new_capacity = last_chunk.storage.capacity();\n                     loop {\n                         new_capacity = new_capacity.checked_mul(2).unwrap();\n                         if new_capacity >= currently_used_cap + n {\n@@ -405,7 +405,7 @@ impl DroplessArena {\n                     self.end.set(last_chunk.end());\n                     return;\n                 } else {\n-                    new_capacity = last_chunk.storage.cap();\n+                    new_capacity = last_chunk.storage.capacity();\n                     loop {\n                         new_capacity = new_capacity.checked_mul(2).unwrap();\n                         if new_capacity >= used_bytes + needed_bytes {"}, {"sha": "0437937d769b7c435712796a34f8c1b9b8b92bde", "filename": "src/libcore/slice/rotate.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0967d28be787b281c0364aca8fb9c25124029b30/src%2Flibcore%2Fslice%2Frotate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0967d28be787b281c0364aca8fb9c25124029b30/src%2Flibcore%2Fslice%2Frotate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Frotate.rs?ref=0967d28be787b281c0364aca8fb9c25124029b30", "patch": "@@ -16,7 +16,7 @@ union RawArray<T> {\n }\n \n impl<T> RawArray<T> {\n-    fn cap() -> usize {\n+    fn capacity() -> usize {\n         if mem::size_of::<T>() == 0 {\n             usize::max_value()\n         } else {\n@@ -55,7 +55,7 @@ impl<T> RawArray<T> {\n pub unsafe fn ptr_rotate<T>(mut left: usize, mid: *mut T, mut right: usize) {\n     loop {\n         let delta = cmp::min(left, right);\n-        if delta <= RawArray::<T>::cap() {\n+        if delta <= RawArray::<T>::capacity() {\n             // We will always hit this immediately for ZST.\n             break;\n         }"}, {"sha": "36eafa50c9b49e70bebdd6c20fb50a01a0d9c005", "filename": "src/libstd/sync/mpsc/sync.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0967d28be787b281c0364aca8fb9c25124029b30/src%2Flibstd%2Fsync%2Fmpsc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0967d28be787b281c0364aca8fb9c25124029b30/src%2Flibstd%2Fsync%2Fmpsc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fsync.rs?ref=0967d28be787b281c0364aca8fb9c25124029b30", "patch": "@@ -161,20 +161,20 @@ fn wakeup<T>(token: SignalToken, guard: MutexGuard<'_, State<T>>) {\n }\n \n impl<T> Packet<T> {\n-    pub fn new(cap: usize) -> Packet<T> {\n+    pub fn new(capacity: usize) -> Packet<T> {\n         Packet {\n             channels: AtomicUsize::new(1),\n             lock: Mutex::new(State {\n                 disconnected: false,\n                 blocker: NoneBlocked,\n-                cap,\n+                cap: capacity,\n                 canceled: None,\n                 queue: Queue {\n                     head: ptr::null_mut(),\n                     tail: ptr::null_mut(),\n                 },\n                 buf: Buffer {\n-                    buf: (0..cap + if cap == 0 {1} else {0}).map(|_| None).collect(),\n+                    buf: (0..capacity + if capacity == 0 {1} else {0}).map(|_| None).collect(),\n                     start: 0,\n                     size: 0,\n                 },\n@@ -189,7 +189,7 @@ impl<T> Packet<T> {\n         loop {\n             let mut guard = self.lock.lock().unwrap();\n             // are we ready to go?\n-            if guard.disconnected || guard.buf.size() < guard.buf.cap() {\n+            if guard.disconnected || guard.buf.size() < guard.buf.capacity() {\n                 return guard;\n             }\n             // no room; actually block\n@@ -231,7 +231,7 @@ impl<T> Packet<T> {\n         let mut guard = self.lock.lock().unwrap();\n         if guard.disconnected {\n             Err(super::TrySendError::Disconnected(t))\n-        } else if guard.buf.size() == guard.buf.cap() {\n+        } else if guard.buf.size() == guard.buf.capacity() {\n             Err(super::TrySendError::Full(t))\n         } else if guard.cap == 0 {\n             // With capacity 0, even though we have buffer space we can't\n@@ -249,7 +249,7 @@ impl<T> Packet<T> {\n             // If the buffer has some space and the capacity isn't 0, then we\n             // just enqueue the data for later retrieval, ensuring to wake up\n             // any blocked receiver if there is one.\n-            assert!(guard.buf.size() < guard.buf.cap());\n+            assert!(guard.buf.size() < guard.buf.capacity());\n             guard.buf.enqueue(t);\n             match mem::replace(&mut guard.blocker, NoneBlocked) {\n                 BlockedReceiver(token) => wakeup(token, guard),\n@@ -475,7 +475,7 @@ impl<T> Buffer<T> {\n     }\n \n     fn size(&self) -> usize { self.size }\n-    fn cap(&self) -> usize { self.buf.len() }\n+    fn capacity(&self) -> usize { self.buf.len() }\n }\n \n ////////////////////////////////////////////////////////////////////////////////"}]}