{"sha": "1da26c8a70c13a0b897f70209c7c33f993d178f9", "node_id": "C_kwDOAAsO6NoAKDFkYTI2YzhhNzBjMTNhMGI4OTdmNzAyMDljN2MzM2Y5OTNkMTc4Zjk", "commit": {"author": {"name": "Jason Newcomb", "email": "jsnewcomb@pm.me", "date": "2022-02-06T21:38:34Z"}, "committer": {"name": "Jason Newcomb", "email": "jsnewcomb@pm.me", "date": "2022-02-07T17:22:27Z"}, "message": "Split out `match_single_binding`", "tree": {"sha": "993ea67fa014644923be501691ca8f7a986dd9fa", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/993ea67fa014644923be501691ca8f7a986dd9fa"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1da26c8a70c13a0b897f70209c7c33f993d178f9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1da26c8a70c13a0b897f70209c7c33f993d178f9", "html_url": "https://github.com/rust-lang/rust/commit/1da26c8a70c13a0b897f70209c7c33f993d178f9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1da26c8a70c13a0b897f70209c7c33f993d178f9/comments", "author": {"login": "Jarcho", "id": 7761774, "node_id": "MDQ6VXNlcjc3NjE3NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7761774?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Jarcho", "html_url": "https://github.com/Jarcho", "followers_url": "https://api.github.com/users/Jarcho/followers", "following_url": "https://api.github.com/users/Jarcho/following{/other_user}", "gists_url": "https://api.github.com/users/Jarcho/gists{/gist_id}", "starred_url": "https://api.github.com/users/Jarcho/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Jarcho/subscriptions", "organizations_url": "https://api.github.com/users/Jarcho/orgs", "repos_url": "https://api.github.com/users/Jarcho/repos", "events_url": "https://api.github.com/users/Jarcho/events{/privacy}", "received_events_url": "https://api.github.com/users/Jarcho/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Jarcho", "id": 7761774, "node_id": "MDQ6VXNlcjc3NjE3NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7761774?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Jarcho", "html_url": "https://github.com/Jarcho", "followers_url": "https://api.github.com/users/Jarcho/followers", "following_url": "https://api.github.com/users/Jarcho/following{/other_user}", "gists_url": "https://api.github.com/users/Jarcho/gists{/gist_id}", "starred_url": "https://api.github.com/users/Jarcho/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Jarcho/subscriptions", "organizations_url": "https://api.github.com/users/Jarcho/orgs", "repos_url": "https://api.github.com/users/Jarcho/repos", "events_url": "https://api.github.com/users/Jarcho/events{/privacy}", "received_events_url": "https://api.github.com/users/Jarcho/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bccf06f60184cedc780e3936799d2aa63cf28b7e", "url": "https://api.github.com/repos/rust-lang/rust/commits/bccf06f60184cedc780e3936799d2aa63cf28b7e", "html_url": "https://github.com/rust-lang/rust/commit/bccf06f60184cedc780e3936799d2aa63cf28b7e"}], "stats": {"total": 334, "additions": 171, "deletions": 163}, "files": [{"sha": "8ae19e03f1a6a5afbfb1016ebd066c4da9d76d0c", "filename": "clippy_lints/src/matches/match_single_binding.rs", "status": "added", "additions": 166, "deletions": 0, "changes": 166, "blob_url": "https://github.com/rust-lang/rust/blob/1da26c8a70c13a0b897f70209c7c33f993d178f9/clippy_lints%2Fsrc%2Fmatches%2Fmatch_single_binding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1da26c8a70c13a0b897f70209c7c33f993d178f9/clippy_lints%2Fsrc%2Fmatches%2Fmatch_single_binding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches%2Fmatch_single_binding.rs?ref=1da26c8a70c13a0b897f70209c7c33f993d178f9", "patch": "@@ -0,0 +1,166 @@\n+use clippy_utils::diagnostics::span_lint_and_sugg;\n+use clippy_utils::source::{indent_of, snippet_block, snippet_opt, snippet_with_applicability};\n+use clippy_utils::sugg::Sugg;\n+use clippy_utils::{get_parent_expr, is_refutable, peel_blocks};\n+use rustc_errors::Applicability;\n+use rustc_hir::{Arm, Expr, ExprKind, Local, Node, PatKind};\n+use rustc_lint::LateContext;\n+\n+use super::MATCH_SINGLE_BINDING;\n+\n+#[allow(clippy::too_many_lines)]\n+pub(crate) fn check<'a>(cx: &LateContext<'a>, ex: &Expr<'a>, arms: &[Arm<'_>], expr: &Expr<'_>) {\n+    if expr.span.from_expansion() || arms.len() != 1 || is_refutable(cx, arms[0].pat) {\n+        return;\n+    }\n+\n+    // HACK:\n+    // This is a hack to deal with arms that are excluded by macros like `#[cfg]`. It is only used here\n+    // to prevent false positives as there is currently no better way to detect if code was excluded by\n+    // a macro. See PR #6435\n+    if_chain! {\n+        if let Some(match_snippet) = snippet_opt(cx, expr.span);\n+        if let Some(arm_snippet) = snippet_opt(cx, arms[0].span);\n+        if let Some(ex_snippet) = snippet_opt(cx, ex.span);\n+        let rest_snippet = match_snippet.replace(&arm_snippet, \"\").replace(&ex_snippet, \"\");\n+        if rest_snippet.contains(\"=>\");\n+        then {\n+            // The code it self contains another thick arrow \"=>\"\n+            // -> Either another arm or a comment\n+            return;\n+        }\n+    }\n+\n+    let matched_vars = ex.span;\n+    let bind_names = arms[0].pat.span;\n+    let match_body = peel_blocks(arms[0].body);\n+    let mut snippet_body = if match_body.span.from_expansion() {\n+        Sugg::hir_with_macro_callsite(cx, match_body, \"..\").to_string()\n+    } else {\n+        snippet_block(cx, match_body.span, \"..\", Some(expr.span)).to_string()\n+    };\n+\n+    // Do we need to add ';' to suggestion ?\n+    match match_body.kind {\n+        ExprKind::Block(block, _) => {\n+            // macro + expr_ty(body) == ()\n+            if block.span.from_expansion() && cx.typeck_results().expr_ty(match_body).is_unit() {\n+                snippet_body.push(';');\n+            }\n+        },\n+        _ => {\n+            // expr_ty(body) == ()\n+            if cx.typeck_results().expr_ty(match_body).is_unit() {\n+                snippet_body.push(';');\n+            }\n+        },\n+    }\n+\n+    let mut applicability = Applicability::MaybeIncorrect;\n+    match arms[0].pat.kind {\n+        PatKind::Binding(..) | PatKind::Tuple(_, _) | PatKind::Struct(..) => {\n+            // If this match is in a local (`let`) stmt\n+            let (target_span, sugg) = if let Some(parent_let_node) = opt_parent_let(cx, ex) {\n+                (\n+                    parent_let_node.span,\n+                    format!(\n+                        \"let {} = {};\\n{}let {} = {};\",\n+                        snippet_with_applicability(cx, bind_names, \"..\", &mut applicability),\n+                        snippet_with_applicability(cx, matched_vars, \"..\", &mut applicability),\n+                        \" \".repeat(indent_of(cx, expr.span).unwrap_or(0)),\n+                        snippet_with_applicability(cx, parent_let_node.pat.span, \"..\", &mut applicability),\n+                        snippet_body\n+                    ),\n+                )\n+            } else {\n+                // If we are in closure, we need curly braces around suggestion\n+                let mut indent = \" \".repeat(indent_of(cx, ex.span).unwrap_or(0));\n+                let (mut cbrace_start, mut cbrace_end) = (\"\".to_string(), \"\".to_string());\n+                if let Some(parent_expr) = get_parent_expr(cx, expr) {\n+                    if let ExprKind::Closure(..) = parent_expr.kind {\n+                        cbrace_end = format!(\"\\n{}}}\", indent);\n+                        // Fix body indent due to the closure\n+                        indent = \" \".repeat(indent_of(cx, bind_names).unwrap_or(0));\n+                        cbrace_start = format!(\"{{\\n{}\", indent);\n+                    }\n+                }\n+                // If the parent is already an arm, and the body is another match statement,\n+                // we need curly braces around suggestion\n+                let parent_node_id = cx.tcx.hir().get_parent_node(expr.hir_id);\n+                if let Node::Arm(arm) = &cx.tcx.hir().get(parent_node_id) {\n+                    if let ExprKind::Match(..) = arm.body.kind {\n+                        cbrace_end = format!(\"\\n{}}}\", indent);\n+                        // Fix body indent due to the match\n+                        indent = \" \".repeat(indent_of(cx, bind_names).unwrap_or(0));\n+                        cbrace_start = format!(\"{{\\n{}\", indent);\n+                    }\n+                }\n+                (\n+                    expr.span,\n+                    format!(\n+                        \"{}let {} = {};\\n{}{}{}\",\n+                        cbrace_start,\n+                        snippet_with_applicability(cx, bind_names, \"..\", &mut applicability),\n+                        snippet_with_applicability(cx, matched_vars, \"..\", &mut applicability),\n+                        indent,\n+                        snippet_body,\n+                        cbrace_end\n+                    ),\n+                )\n+            };\n+            span_lint_and_sugg(\n+                cx,\n+                MATCH_SINGLE_BINDING,\n+                target_span,\n+                \"this match could be written as a `let` statement\",\n+                \"consider using `let` statement\",\n+                sugg,\n+                applicability,\n+            );\n+        },\n+        PatKind::Wild => {\n+            if ex.can_have_side_effects() {\n+                let indent = \" \".repeat(indent_of(cx, expr.span).unwrap_or(0));\n+                let sugg = format!(\n+                    \"{};\\n{}{}\",\n+                    snippet_with_applicability(cx, ex.span, \"..\", &mut applicability),\n+                    indent,\n+                    snippet_body\n+                );\n+                span_lint_and_sugg(\n+                    cx,\n+                    MATCH_SINGLE_BINDING,\n+                    expr.span,\n+                    \"this match could be replaced by its scrutinee and body\",\n+                    \"consider using the scrutinee and body instead\",\n+                    sugg,\n+                    applicability,\n+                );\n+            } else {\n+                span_lint_and_sugg(\n+                    cx,\n+                    MATCH_SINGLE_BINDING,\n+                    expr.span,\n+                    \"this match could be replaced by its body itself\",\n+                    \"consider using the match body instead\",\n+                    snippet_body,\n+                    Applicability::MachineApplicable,\n+                );\n+            }\n+        },\n+        _ => (),\n+    }\n+}\n+\n+/// Returns true if the `ex` match expression is in a local (`let`) statement\n+fn opt_parent_let<'a>(cx: &LateContext<'a>, ex: &Expr<'a>) -> Option<&'a Local<'a>> {\n+    let map = &cx.tcx.hir();\n+    if_chain! {\n+        if let Some(Node::Expr(parent_arm_expr)) = map.find(map.get_parent_node(ex.hir_id));\n+        if let Some(Node::Local(parent_let_expr)) = map.find(map.get_parent_node(parent_arm_expr.hir_id));\n+        then {\n+            return Some(parent_let_expr);\n+        }\n+    }\n+    None\n+}"}, {"sha": "c2bf2aa6c9d1d888b6962a577bf75e74ea7d349c", "filename": "clippy_lints/src/matches/mod.rs", "status": "modified", "additions": 5, "deletions": 163, "changes": 168, "blob_url": "https://github.com/rust-lang/rust/blob/1da26c8a70c13a0b897f70209c7c33f993d178f9/clippy_lints%2Fsrc%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1da26c8a70c13a0b897f70209c7c33f993d178f9/clippy_lints%2Fsrc%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches%2Fmod.rs?ref=1da26c8a70c13a0b897f70209c7c33f993d178f9", "patch": "@@ -1,13 +1,11 @@\n use clippy_utils::diagnostics::{multispan_sugg, span_lint_and_help, span_lint_and_sugg, span_lint_and_then};\n-use clippy_utils::source::{indent_of, snippet, snippet_block, snippet_opt, snippet_with_applicability};\n+use clippy_utils::source::{snippet, snippet_with_applicability};\n use clippy_utils::sugg::Sugg;\n-use clippy_utils::{\n-    get_parent_expr, is_refutable, is_wild, meets_msrv, msrvs, path_to_local_id, peel_blocks, strip_pat_refs,\n-};\n+use clippy_utils::{is_wild, meets_msrv, msrvs, path_to_local_id, peel_blocks, strip_pat_refs};\n use core::iter::once;\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n-use rustc_hir::{Arm, BorrowKind, Expr, ExprKind, Local, MatchSource, Mutability, Node, Pat, PatKind, QPath};\n+use rustc_hir::{Arm, BorrowKind, Expr, ExprKind, Local, MatchSource, Mutability, Pat, PatKind, QPath};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::ty;\n use rustc_semver::RustcVersion;\n@@ -17,6 +15,7 @@ mod match_as_ref;\n mod match_bool;\n mod match_like_matches;\n mod match_same_arms;\n+mod match_single_binding;\n mod match_wild_enum;\n mod match_wild_err_arm;\n mod overlapping_arms;\n@@ -630,7 +629,7 @@ impl<'tcx> LateLintPass<'tcx> for Matches {\n             if self.infallible_destructuring_match_linted {\n                 self.infallible_destructuring_match_linted = false;\n             } else {\n-                check_match_single_binding(cx, ex, arms, expr);\n+                match_single_binding::check(cx, ex, arms, expr);\n             }\n         }\n         if let ExprKind::Match(ex, arms, _) = expr.kind {\n@@ -753,163 +752,6 @@ fn check_wild_in_or_pats(cx: &LateContext<'_>, arms: &[Arm<'_>]) {\n     }\n }\n \n-#[allow(clippy::too_many_lines)]\n-fn check_match_single_binding<'a>(cx: &LateContext<'a>, ex: &Expr<'a>, arms: &[Arm<'_>], expr: &Expr<'_>) {\n-    if expr.span.from_expansion() || arms.len() != 1 || is_refutable(cx, arms[0].pat) {\n-        return;\n-    }\n-\n-    // HACK:\n-    // This is a hack to deal with arms that are excluded by macros like `#[cfg]`. It is only used here\n-    // to prevent false positives as there is currently no better way to detect if code was excluded by\n-    // a macro. See PR #6435\n-    if_chain! {\n-        if let Some(match_snippet) = snippet_opt(cx, expr.span);\n-        if let Some(arm_snippet) = snippet_opt(cx, arms[0].span);\n-        if let Some(ex_snippet) = snippet_opt(cx, ex.span);\n-        let rest_snippet = match_snippet.replace(&arm_snippet, \"\").replace(&ex_snippet, \"\");\n-        if rest_snippet.contains(\"=>\");\n-        then {\n-            // The code it self contains another thick arrow \"=>\"\n-            // -> Either another arm or a comment\n-            return;\n-        }\n-    }\n-\n-    let matched_vars = ex.span;\n-    let bind_names = arms[0].pat.span;\n-    let match_body = peel_blocks(arms[0].body);\n-    let mut snippet_body = if match_body.span.from_expansion() {\n-        Sugg::hir_with_macro_callsite(cx, match_body, \"..\").to_string()\n-    } else {\n-        snippet_block(cx, match_body.span, \"..\", Some(expr.span)).to_string()\n-    };\n-\n-    // Do we need to add ';' to suggestion ?\n-    match match_body.kind {\n-        ExprKind::Block(block, _) => {\n-            // macro + expr_ty(body) == ()\n-            if block.span.from_expansion() && cx.typeck_results().expr_ty(match_body).is_unit() {\n-                snippet_body.push(';');\n-            }\n-        },\n-        _ => {\n-            // expr_ty(body) == ()\n-            if cx.typeck_results().expr_ty(match_body).is_unit() {\n-                snippet_body.push(';');\n-            }\n-        },\n-    }\n-\n-    let mut applicability = Applicability::MaybeIncorrect;\n-    match arms[0].pat.kind {\n-        PatKind::Binding(..) | PatKind::Tuple(_, _) | PatKind::Struct(..) => {\n-            // If this match is in a local (`let`) stmt\n-            let (target_span, sugg) = if let Some(parent_let_node) = opt_parent_let(cx, ex) {\n-                (\n-                    parent_let_node.span,\n-                    format!(\n-                        \"let {} = {};\\n{}let {} = {};\",\n-                        snippet_with_applicability(cx, bind_names, \"..\", &mut applicability),\n-                        snippet_with_applicability(cx, matched_vars, \"..\", &mut applicability),\n-                        \" \".repeat(indent_of(cx, expr.span).unwrap_or(0)),\n-                        snippet_with_applicability(cx, parent_let_node.pat.span, \"..\", &mut applicability),\n-                        snippet_body\n-                    ),\n-                )\n-            } else {\n-                // If we are in closure, we need curly braces around suggestion\n-                let mut indent = \" \".repeat(indent_of(cx, ex.span).unwrap_or(0));\n-                let (mut cbrace_start, mut cbrace_end) = (\"\".to_string(), \"\".to_string());\n-                if let Some(parent_expr) = get_parent_expr(cx, expr) {\n-                    if let ExprKind::Closure(..) = parent_expr.kind {\n-                        cbrace_end = format!(\"\\n{}}}\", indent);\n-                        // Fix body indent due to the closure\n-                        indent = \" \".repeat(indent_of(cx, bind_names).unwrap_or(0));\n-                        cbrace_start = format!(\"{{\\n{}\", indent);\n-                    }\n-                }\n-                // If the parent is already an arm, and the body is another match statement,\n-                // we need curly braces around suggestion\n-                let parent_node_id = cx.tcx.hir().get_parent_node(expr.hir_id);\n-                if let Node::Arm(arm) = &cx.tcx.hir().get(parent_node_id) {\n-                    if let ExprKind::Match(..) = arm.body.kind {\n-                        cbrace_end = format!(\"\\n{}}}\", indent);\n-                        // Fix body indent due to the match\n-                        indent = \" \".repeat(indent_of(cx, bind_names).unwrap_or(0));\n-                        cbrace_start = format!(\"{{\\n{}\", indent);\n-                    }\n-                }\n-                (\n-                    expr.span,\n-                    format!(\n-                        \"{}let {} = {};\\n{}{}{}\",\n-                        cbrace_start,\n-                        snippet_with_applicability(cx, bind_names, \"..\", &mut applicability),\n-                        snippet_with_applicability(cx, matched_vars, \"..\", &mut applicability),\n-                        indent,\n-                        snippet_body,\n-                        cbrace_end\n-                    ),\n-                )\n-            };\n-            span_lint_and_sugg(\n-                cx,\n-                MATCH_SINGLE_BINDING,\n-                target_span,\n-                \"this match could be written as a `let` statement\",\n-                \"consider using `let` statement\",\n-                sugg,\n-                applicability,\n-            );\n-        },\n-        PatKind::Wild => {\n-            if ex.can_have_side_effects() {\n-                let indent = \" \".repeat(indent_of(cx, expr.span).unwrap_or(0));\n-                let sugg = format!(\n-                    \"{};\\n{}{}\",\n-                    snippet_with_applicability(cx, ex.span, \"..\", &mut applicability),\n-                    indent,\n-                    snippet_body\n-                );\n-                span_lint_and_sugg(\n-                    cx,\n-                    MATCH_SINGLE_BINDING,\n-                    expr.span,\n-                    \"this match could be replaced by its scrutinee and body\",\n-                    \"consider using the scrutinee and body instead\",\n-                    sugg,\n-                    applicability,\n-                );\n-            } else {\n-                span_lint_and_sugg(\n-                    cx,\n-                    MATCH_SINGLE_BINDING,\n-                    expr.span,\n-                    \"this match could be replaced by its body itself\",\n-                    \"consider using the match body instead\",\n-                    snippet_body,\n-                    Applicability::MachineApplicable,\n-                );\n-            }\n-        },\n-        _ => (),\n-    }\n-}\n-\n-/// Returns true if the `ex` match expression is in a local (`let`) statement\n-fn opt_parent_let<'a>(cx: &LateContext<'a>, ex: &Expr<'a>) -> Option<&'a Local<'a>> {\n-    let map = &cx.tcx.hir();\n-    if_chain! {\n-        if let Some(Node::Expr(parent_arm_expr)) = map.find(map.get_parent_node(ex.hir_id));\n-        if let Some(Node::Local(parent_let_expr)) = map.find(map.get_parent_node(parent_arm_expr.hir_id));\n-        then {\n-            return Some(parent_let_expr);\n-        }\n-    }\n-    None\n-}\n-\n fn has_multiple_ref_pats<'a, 'b, I>(pats: I) -> bool\n where\n     'b: 'a,"}]}