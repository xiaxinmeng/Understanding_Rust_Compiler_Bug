{"sha": "4209022e5b8dc185b098d76fd6701cd046b7c37d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQyMDkwMjJlNWI4ZGMxODViMDk4ZDc2ZmQ2NzAxY2QwNDZiN2MzN2Q=", "commit": {"author": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-01-13T16:59:35Z"}, "committer": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-01-13T16:59:35Z"}, "message": "Merge #527\n\n527: goto defenition works for type-inferred methods r=flodiebold a=matklad\n\nThis uses type inference results for `goto method` functionality.\r\n\r\nThis is achieved by adding another map to `InferenceResult`. I wonder how we should handle this long-term... The pattern seems to be \"we are doing some analysis, and we produce some stuff as a by-product, and IDE would like to use the stuff\". Ideally, adding an additional bit of info shouldn't require threading it through all data structures. \r\n\r\nI kinda like how Kotlin deals with this problem. They have this [`BindingContext`](https://github.com/JetBrains/kotlin/blob/72e351a0e3610051fe4222dca4e1eeedf7ae45da/compiler/frontend/src/org/jetbrains/kotlin/resolve/BindingContext.java#L122) thing, which is basically an [`AnyMap`](https://github.com/JetBrains/kotlin/blob/72e351a0e3610051fe4222dca4e1eeedf7ae45da/compiler/frontend/src/org/jetbrains/kotlin/resolve/BindingContext.java#L122) of HashMaps. \r\n\r\nDeep in the compiler guts, they [record the info](https://github.com/JetBrains/kotlin/blob/ba6da7c40a6cc502508faf6e04fa105b96bc7777/compiler/frontend/src/org/jetbrains/kotlin/resolve/calls/tasks/TracingStrategyForInvoke.java#L70-L75) into the map, using a type key, a value key and a value. \r\n\r\nThen the IDE [reads this map](https://github.com/JetBrains/kotlin/blob/ba6da7c40a6cc502508faf6e04fa105b96bc7777/idea/src/org/jetbrains/kotlin/idea/inspections/RedundantNotNullExtensionReceiverOfInlineInspection.kt#L64) (via a [helper](https://github.com/JetBrains/kotlin/blob/ba6da7c40a6cc502508faf6e04fa105b96bc7777/compiler/frontend/src/org/jetbrains/kotlin/resolve/calls/util/callUtil.kt#L178-L180)). The stuff in between does not know that this type-key exists, unless it inspects it. \n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "98a579f8c0fd7a0738862937ec32a7dc62172e1a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/98a579f8c0fd7a0738862937ec32a7dc62172e1a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4209022e5b8dc185b098d76fd6701cd046b7c37d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4209022e5b8dc185b098d76fd6701cd046b7c37d", "html_url": "https://github.com/rust-lang/rust/commit/4209022e5b8dc185b098d76fd6701cd046b7c37d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4209022e5b8dc185b098d76fd6701cd046b7c37d/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "parents": [{"sha": "8b985b427c4e67d6833745258bfdf1c4e9eb62ca", "url": "https://api.github.com/repos/rust-lang/rust/commits/8b985b427c4e67d6833745258bfdf1c4e9eb62ca", "html_url": "https://github.com/rust-lang/rust/commit/8b985b427c4e67d6833745258bfdf1c4e9eb62ca"}, {"sha": "eedc08300c427b854db56f8fe1f1866ed398d5ee", "url": "https://api.github.com/repos/rust-lang/rust/commits/eedc08300c427b854db56f8fe1f1866ed398d5ee", "html_url": "https://github.com/rust-lang/rust/commit/eedc08300c427b854db56f8fe1f1866ed398d5ee"}], "stats": {"total": 76, "additions": 71, "deletions": 5}, "files": [{"sha": "fa46ddfe9eee33f9510ca97338fda65d1f2b691f", "filename": "crates/ra_hir/src/ty.rs", "status": "modified", "additions": 22, "deletions": 3, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/4209022e5b8dc185b098d76fd6701cd046b7c37d/crates%2Fra_hir%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4209022e5b8dc185b098d76fd6701cd046b7c37d/crates%2Fra_hir%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty.rs?ref=4209022e5b8dc185b098d76fd6701cd046b7c37d", "patch": "@@ -28,6 +28,7 @@ use log;\n use ena::unify::{InPlaceUnificationTable, UnifyKey, UnifyValue, NoError};\n use ra_arena::map::ArenaMap;\n use join_to_string::join;\n+use rustc_hash::FxHashMap;\n \n use ra_db::Cancelable;\n \n@@ -448,14 +449,14 @@ fn type_for_struct(db: &impl HirDatabase, s: Struct) -> Cancelable<Ty> {\n     })\n }\n \n-pub fn type_for_enum(db: &impl HirDatabase, s: Enum) -> Cancelable<Ty> {\n+pub(crate) fn type_for_enum(db: &impl HirDatabase, s: Enum) -> Cancelable<Ty> {\n     Ok(Ty::Adt {\n         def_id: s.def_id(),\n         name: s.name(db)?.unwrap_or_else(Name::missing),\n     })\n }\n \n-pub fn type_for_enum_variant(db: &impl HirDatabase, ev: EnumVariant) -> Cancelable<Ty> {\n+pub(crate) fn type_for_enum_variant(db: &impl HirDatabase, ev: EnumVariant) -> Cancelable<Ty> {\n     let enum_parent = ev.parent_enum(db)?;\n \n     type_for_enum(db, enum_parent)\n@@ -512,10 +513,18 @@ pub(super) fn type_for_field(\n /// The result of type inference: A mapping from expressions and patterns to types.\n #[derive(Clone, PartialEq, Eq, Debug)]\n pub struct InferenceResult {\n+    /// For each method call expr, record the function it resolved to.\n+    method_resolutions: FxHashMap<ExprId, DefId>,\n     type_of_expr: ArenaMap<ExprId, Ty>,\n     type_of_pat: ArenaMap<PatId, Ty>,\n }\n \n+impl InferenceResult {\n+    pub fn method_resolution(&self, expr: ExprId) -> Option<DefId> {\n+        self.method_resolutions.get(&expr).map(|it| *it)\n+    }\n+}\n+\n impl Index<ExprId> for InferenceResult {\n     type Output = Ty;\n \n@@ -541,6 +550,7 @@ struct InferenceContext<'a, D: HirDatabase> {\n     module: Module,\n     impl_block: Option<ImplBlock>,\n     var_unification_table: InPlaceUnificationTable<TypeVarId>,\n+    method_resolutions: FxHashMap<ExprId, DefId>,\n     type_of_expr: ArenaMap<ExprId, Ty>,\n     type_of_pat: ArenaMap<PatId, Ty>,\n     /// The return type of the function being inferred.\n@@ -631,6 +641,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         impl_block: Option<ImplBlock>,\n     ) -> Self {\n         InferenceContext {\n+            method_resolutions: FxHashMap::default(),\n             type_of_expr: ArenaMap::default(),\n             type_of_pat: ArenaMap::default(),\n             var_unification_table: InPlaceUnificationTable::new(),\n@@ -655,6 +666,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n             *ty = resolved;\n         }\n         InferenceResult {\n+            method_resolutions: mem::replace(&mut self.method_resolutions, Default::default()),\n             type_of_expr: expr_types,\n             type_of_pat: pat_types,\n         }\n@@ -664,6 +676,10 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         self.type_of_expr.insert(expr, ty);\n     }\n \n+    fn write_method_resolution(&mut self, expr: ExprId, def_id: DefId) {\n+        self.method_resolutions.insert(expr, def_id);\n+    }\n+\n     fn write_pat_ty(&mut self, pat: PatId, ty: Ty) {\n         self.type_of_pat.insert(pat, ty);\n     }\n@@ -900,7 +916,10 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                 let receiver_ty = self.infer_expr(*receiver, &Expectation::none())?;\n                 let resolved = receiver_ty.clone().lookup_method(self.db, method_name)?;\n                 let method_ty = match resolved {\n-                    Some(def_id) => self.db.type_for_def(def_id)?,\n+                    Some(def_id) => {\n+                        self.write_method_resolution(expr, def_id);\n+                        self.db.type_for_def(def_id)?\n+                    }\n                     None => Ty::Unknown,\n                 };\n                 let method_ty = self.insert_type_vars(method_ty);"}, {"sha": "332a2fb8d3ed2710556c4bea12895e8110741224", "filename": "crates/ra_ide_api/src/goto_definition.rs", "status": "modified", "additions": 49, "deletions": 2, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/4209022e5b8dc185b098d76fd6701cd046b7c37d/crates%2Fra_ide_api%2Fsrc%2Fgoto_definition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4209022e5b8dc185b098d76fd6701cd046b7c37d/crates%2Fra_ide_api%2Fsrc%2Fgoto_definition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fgoto_definition.rs?ref=4209022e5b8dc185b098d76fd6701cd046b7c37d", "patch": "@@ -47,15 +47,34 @@ pub(crate) fn reference_definition(\n     name_ref: &ast::NameRef,\n ) -> Cancelable<ReferenceResult> {\n     use self::ReferenceResult::*;\n-    if let Some(fn_descr) =\n+    if let Some(function) =\n         hir::source_binder::function_from_child_node(db, file_id, name_ref.syntax())?\n     {\n-        let scope = fn_descr.scopes(db)?;\n+        let scope = function.scopes(db)?;\n         // First try to resolve the symbol locally\n         if let Some(entry) = scope.resolve_local_name(name_ref) {\n             let nav = NavigationTarget::from_scope_entry(file_id, &entry);\n             return Ok(Exact(nav));\n         };\n+\n+        // Next check if it is a method\n+        if let Some(method_call) = name_ref\n+            .syntax()\n+            .parent()\n+            .and_then(ast::MethodCallExpr::cast)\n+        {\n+            let infer_result = function.infer(db)?;\n+            let syntax_mapping = function.body_syntax_mapping(db)?;\n+            let expr = ast::Expr::cast(method_call.syntax()).unwrap();\n+            if let Some(def_id) = syntax_mapping\n+                .node_expr(expr)\n+                .and_then(|it| infer_result.method_resolution(it))\n+            {\n+                if let Some(target) = NavigationTarget::from_def(db, def_id.resolve(db)?)? {\n+                    return Ok(Exact(target));\n+                }\n+            };\n+        }\n     }\n     // Then try module name resolution\n     if let Some(module) =\n@@ -167,4 +186,32 @@ mod tests {\n             \"foo SOURCE_FILE FileId(2) [0; 10)\",\n         );\n     }\n+\n+    #[test]\n+    fn goto_definition_works_for_methods() {\n+        check_goto(\n+            \"\n+            //- /lib.rs\n+            struct Foo;\n+            impl Foo {\n+                fn frobnicate(&self) {  }\n+            }\n+\n+            fn bar(foo: &Foo) {\n+                foo.frobnicate<|>();\n+            }\n+            \",\n+            \"frobnicate FN_DEF FileId(1) [27; 52) [30; 40)\",\n+        );\n+\n+        check_goto(\n+            \"\n+            //- /lib.rs\n+            mod <|>foo;\n+            //- /foo/mod.rs\n+            // empty\n+            \",\n+            \"foo SOURCE_FILE FileId(2) [0; 10)\",\n+        );\n+    }\n }"}]}