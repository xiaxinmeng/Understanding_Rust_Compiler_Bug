{"sha": "555119fa146640c24104e79ec32beeec9d5f738a", "node_id": "C_kwDOAAsO6NoAKDU1NTExOWZhMTQ2NjQwYzI0MTA0ZTc5ZWMzMmJlZWVjOWQ1ZjczOGE", "commit": {"author": {"name": "Jack Huey", "email": "31162821+jackh726@users.noreply.github.com", "date": "2021-12-25T04:34:26Z"}, "committer": {"name": "Jack Huey", "email": "31162821+jackh726@users.noreply.github.com", "date": "2021-12-28T17:58:31Z"}, "message": "Introduce demand_compatible", "tree": {"sha": "b4f85dbec6b2fafa570bbafa7facead4db053cc9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b4f85dbec6b2fafa570bbafa7facead4db053cc9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/555119fa146640c24104e79ec32beeec9d5f738a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/555119fa146640c24104e79ec32beeec9d5f738a", "html_url": "https://github.com/rust-lang/rust/commit/555119fa146640c24104e79ec32beeec9d5f738a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/555119fa146640c24104e79ec32beeec9d5f738a/comments", "author": {"login": "jackh726", "id": 31162821, "node_id": "MDQ6VXNlcjMxMTYyODIx", "avatar_url": "https://avatars.githubusercontent.com/u/31162821?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jackh726", "html_url": "https://github.com/jackh726", "followers_url": "https://api.github.com/users/jackh726/followers", "following_url": "https://api.github.com/users/jackh726/following{/other_user}", "gists_url": "https://api.github.com/users/jackh726/gists{/gist_id}", "starred_url": "https://api.github.com/users/jackh726/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jackh726/subscriptions", "organizations_url": "https://api.github.com/users/jackh726/orgs", "repos_url": "https://api.github.com/users/jackh726/repos", "events_url": "https://api.github.com/users/jackh726/events{/privacy}", "received_events_url": "https://api.github.com/users/jackh726/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jackh726", "id": 31162821, "node_id": "MDQ6VXNlcjMxMTYyODIx", "avatar_url": "https://avatars.githubusercontent.com/u/31162821?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jackh726", "html_url": "https://github.com/jackh726", "followers_url": "https://api.github.com/users/jackh726/followers", "following_url": "https://api.github.com/users/jackh726/following{/other_user}", "gists_url": "https://api.github.com/users/jackh726/gists{/gist_id}", "starred_url": "https://api.github.com/users/jackh726/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jackh726/subscriptions", "organizations_url": "https://api.github.com/users/jackh726/orgs", "repos_url": "https://api.github.com/users/jackh726/repos", "events_url": "https://api.github.com/users/jackh726/events{/privacy}", "received_events_url": "https://api.github.com/users/jackh726/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "45341a6cbf07e93960feede6f78a0a3f441d6d89", "url": "https://api.github.com/repos/rust-lang/rust/commits/45341a6cbf07e93960feede6f78a0a3f441d6d89", "html_url": "https://github.com/rust-lang/rust/commit/45341a6cbf07e93960feede6f78a0a3f441d6d89"}], "stats": {"total": 91, "additions": 50, "deletions": 41}, "files": [{"sha": "7664c52a3410542897e71f04405db5a0fcf1332f", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/checks.rs", "status": "modified", "additions": 50, "deletions": 41, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/555119fa146640c24104e79ec32beeec9d5f738a/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/555119fa146640c24104e79ec32beeec9d5f738a/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs?ref=555119fa146640c24104e79ec32beeec9d5f738a", "patch": "@@ -321,6 +321,55 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         let mut final_arg_types: Vec<(usize, Ty<'_>, Ty<'_>)> = vec![];\n \n+        // We introduce a helper function to demand that a given argument satisfy a given input\n+        // This is more complicated than just checking type equality, as arguments could be coerced\n+        // This version writes those types back so further type checking uses the narrowed types\n+        let demand_compatible = |idx, final_arg_types: &mut Vec<(usize, Ty<'tcx>, Ty<'tcx>)>| {\n+            let formal_input_ty: Ty<'tcx> = formal_input_tys[idx];\n+            let expected_input_ty: Ty<'tcx> = expected_input_tys[idx];\n+            let provided_arg = &provided_args[idx];\n+\n+            debug!(\"checking argument {}: {:?} = {:?}\", idx, provided_arg, formal_input_ty);\n+\n+            // The special-cased logic below has three functions:\n+            // 1. Provide as good of an expected type as possible.\n+            let expectation = Expectation::rvalue_hint(self, expected_input_ty);\n+\n+            let checked_ty = self.check_expr_with_expectation(provided_arg, expectation);\n+\n+            // 2. Coerce to the most detailed type that could be coerced\n+            //    to, which is `expected_ty` if `rvalue_hint` returns an\n+            //    `ExpectHasType(expected_ty)`, or the `formal_ty` otherwise.\n+            let coerced_ty = expectation.only_has_type(self).unwrap_or(formal_input_ty);\n+\n+            // Keep track of these for below\n+            final_arg_types.push((idx, checked_ty, coerced_ty));\n+\n+            // Cause selection errors caused by resolving a single argument to point at the\n+            // argument and not the call. This is otherwise redundant with the `demand_coerce`\n+            // call immediately after, but it lets us customize the span pointed to in the\n+            // fulfillment error to be more accurate.\n+            let _ =\n+                self.resolve_vars_with_obligations_and_mutate_fulfillment(coerced_ty, |errors| {\n+                    self.point_at_type_arg_instead_of_call_if_possible(errors, call_expr);\n+                    self.point_at_arg_instead_of_call_if_possible(\n+                        errors,\n+                        &final_arg_types,\n+                        call_expr,\n+                        call_span,\n+                        provided_args,\n+                    );\n+                });\n+\n+            // We're processing function arguments so we definitely want to use\n+            // two-phase borrows.\n+            self.demand_coerce(&provided_arg, checked_ty, coerced_ty, None, AllowTwoPhase::Yes);\n+\n+            // 3. Relate the expected type and the formal one,\n+            //    if the expected type was used for the coercion.\n+            self.demand_suptype(provided_arg.span, formal_input_ty, coerced_ty);\n+        };\n+\n         // Check the arguments.\n         // We do this in a pretty awful way: first we type-check any arguments\n         // that are not closures, then we type-check the closures. This is so\n@@ -369,47 +418,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     continue;\n                 }\n \n-                let formal_ty = formal_input_tys[i];\n-                debug!(\"checking argument {}: {:?} = {:?}\", i, arg, formal_ty);\n-\n-                // The special-cased logic below has three functions:\n-                // 1. Provide as good of an expected type as possible.\n-                let expected = Expectation::rvalue_hint(self, expected_input_tys[i]);\n-\n-                let checked_ty = self.check_expr_with_expectation(&arg, expected);\n-\n-                // 2. Coerce to the most detailed type that could be coerced\n-                //    to, which is `expected_ty` if `rvalue_hint` returns an\n-                //    `ExpectHasType(expected_ty)`, or the `formal_ty` otherwise.\n-                let coerce_ty = expected.only_has_type(self).unwrap_or(formal_ty);\n-\n-                final_arg_types.push((i, checked_ty, coerce_ty));\n-\n-                // Cause selection errors caused by resolving a single argument to point at the\n-                // argument and not the call. This is otherwise redundant with the `demand_coerce`\n-                // call immediately after, but it lets us customize the span pointed to in the\n-                // fulfillment error to be more accurate.\n-                let _ = self.resolve_vars_with_obligations_and_mutate_fulfillment(\n-                    coerce_ty,\n-                    |errors| {\n-                        self.point_at_type_arg_instead_of_call_if_possible(errors, call_expr);\n-                        self.point_at_arg_instead_of_call_if_possible(\n-                            errors,\n-                            &final_arg_types,\n-                            call_expr,\n-                            call_span,\n-                            provided_args,\n-                        );\n-                    },\n-                );\n-\n-                // We're processing function arguments so we definitely want to use\n-                // two-phase borrows.\n-                self.demand_coerce(&arg, checked_ty, coerce_ty, None, AllowTwoPhase::Yes);\n-\n-                // 3. Relate the expected type and the formal one,\n-                //    if the expected type was used for the coercion.\n-                self.demand_suptype(arg.span, formal_ty, coerce_ty);\n+                demand_compatible(i, &mut final_arg_types);\n             }\n         }\n "}]}