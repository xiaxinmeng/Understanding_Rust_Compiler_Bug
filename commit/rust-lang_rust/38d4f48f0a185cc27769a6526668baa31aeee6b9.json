{"sha": "38d4f48f0a185cc27769a6526668baa31aeee6b9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM4ZDRmNDhmMGExODVjYzI3NzY5YTY1MjY2NjhiYWEzMWFlZWU2Yjk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-09-16T22:50:47Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-09-16T22:50:47Z"}, "message": "auto merge of #9109 : thestinger/rust/function, r=alexcrichton", "tree": {"sha": "201aeeb50bc5d31de0a709ac281a4cd82f50d5b3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/201aeeb50bc5d31de0a709ac281a4cd82f50d5b3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/38d4f48f0a185cc27769a6526668baa31aeee6b9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/38d4f48f0a185cc27769a6526668baa31aeee6b9", "html_url": "https://github.com/rust-lang/rust/commit/38d4f48f0a185cc27769a6526668baa31aeee6b9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/38d4f48f0a185cc27769a6526668baa31aeee6b9/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bc89ade401e637fcb7d4d1d0b7f356ca359b0e7d", "url": "https://api.github.com/repos/rust-lang/rust/commits/bc89ade401e637fcb7d4d1d0b7f356ca359b0e7d", "html_url": "https://github.com/rust-lang/rust/commit/bc89ade401e637fcb7d4d1d0b7f356ca359b0e7d"}, {"sha": "1afaf0b308618c7c33fb13684105e98671b82c4b", "url": "https://api.github.com/repos/rust-lang/rust/commits/1afaf0b308618c7c33fb13684105e98671b82c4b", "html_url": "https://github.com/rust-lang/rust/commit/1afaf0b308618c7c33fb13684105e98671b82c4b"}], "stats": {"total": 284, "additions": 172, "deletions": 112}, "files": [{"sha": "e8c2388a383ae000fc5f8e22899d2e2f0b636418", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 109, "deletions": 62, "changes": 171, "blob_url": "https://github.com/rust-lang/rust/blob/38d4f48f0a185cc27769a6526668baa31aeee6b9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38d4f48f0a185cc27769a6526668baa31aeee6b9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=38d4f48f0a185cc27769a6526668baa31aeee6b9", "patch": "@@ -174,6 +174,7 @@ impl<'self> Drop for StatRecorder<'self> {\n     }\n }\n \n+// only use this for foreign function ABIs and glue, use `decl_rust_fn` for Rust functions\n pub fn decl_fn(llmod: ModuleRef, name: &str, cc: lib::llvm::CallConv, ty: Type) -> ValueRef {\n     let llfn: ValueRef = do name.with_c_str |buf| {\n         unsafe {\n@@ -185,18 +186,12 @@ pub fn decl_fn(llmod: ModuleRef, name: &str, cc: lib::llvm::CallConv, ty: Type)\n     return llfn;\n }\n \n+// only use this for foreign function ABIs and glue, use `decl_rust_fn` for Rust functions\n pub fn decl_cdecl_fn(llmod: ModuleRef, name: &str, ty: Type) -> ValueRef {\n     return decl_fn(llmod, name, lib::llvm::CCallConv, ty);\n }\n \n-// Only use this if you are going to actually define the function. It's\n-// not valid to simply declare a function as internal.\n-pub fn decl_internal_cdecl_fn(llmod: ModuleRef, name: &str, ty: Type) -> ValueRef {\n-    let llfn = decl_cdecl_fn(llmod, name, ty);\n-    lib::llvm::SetLinkage(llfn, lib::llvm::InternalLinkage);\n-    return llfn;\n-}\n-\n+// only use this for foreign function ABIs and glue, use `get_extern_rust_fn` for Rust functions\n pub fn get_extern_fn(externs: &mut ExternMap, llmod: ModuleRef, name: &str,\n                      cc: lib::llvm::CallConv, ty: Type) -> ValueRef {\n     match externs.find_equiv(&name) {\n@@ -205,7 +200,73 @@ pub fn get_extern_fn(externs: &mut ExternMap, llmod: ModuleRef, name: &str,\n     }\n     let f = decl_fn(llmod, name, cc, ty);\n     externs.insert(name.to_owned(), f);\n-    return f;\n+    f\n+}\n+\n+pub fn get_extern_rust_fn(ccx: &mut CrateContext, inputs: &[ty::t], output: ty::t,\n+                          name: &str) -> ValueRef {\n+    match ccx.externs.find_equiv(&name) {\n+        Some(n) => return *n,\n+        None => ()\n+    }\n+    let f = decl_rust_fn(ccx, inputs, output, name);\n+    ccx.externs.insert(name.to_owned(), f);\n+    f\n+}\n+\n+pub fn decl_rust_fn(ccx: &mut CrateContext, inputs: &[ty::t], output: ty::t,\n+                    name: &str) -> ValueRef {\n+    let llfty = type_of_rust_fn(ccx, inputs, output);\n+    let llfn = decl_cdecl_fn(ccx.llmod, name, llfty);\n+\n+    match ty::get(output).sty {\n+        // `~` pointer return values never alias because ownership is transferred\n+        ty::ty_uniq(*) |\n+        ty::ty_evec(_, ty::vstore_uniq) => {\n+            unsafe {\n+                llvm::LLVMAddReturnAttribute(llfn, lib::llvm::NoAliasAttribute as c_uint);\n+            }\n+        }\n+        _ => ()\n+    }\n+\n+    let uses_outptr = type_of::return_uses_outptr(ccx.tcx, output);\n+    let offset = if uses_outptr { 2 } else { 1 };\n+\n+    for (i, &arg_ty) in inputs.iter().enumerate() {\n+        let llarg = unsafe { llvm::LLVMGetParam(llfn, (offset + i) as c_uint) };\n+        match ty::get(arg_ty).sty {\n+            // `~` pointer parameters never alias because ownership is transferred\n+            ty::ty_uniq(*) |\n+            ty::ty_evec(_, ty::vstore_uniq) |\n+            ty::ty_closure(ty::ClosureTy {sigil: ast::OwnedSigil, _}) => {\n+                unsafe {\n+                    llvm::LLVMAddAttribute(llarg, lib::llvm::NoAliasAttribute as c_uint);\n+                }\n+            }\n+            _ => ()\n+        }\n+    }\n+\n+    // The out pointer will never alias with any other pointers, as the object only exists at a\n+    // language level after the call. It can also be tagged with SRet to indicate that it is\n+    // guaranteed to point to a usable block of memory for the type.\n+    if uses_outptr {\n+        unsafe {\n+            let outptr = llvm::LLVMGetParam(llfn, 0);\n+            llvm::LLVMAddAttribute(outptr, lib::llvm::StructRetAttribute as c_uint);\n+            llvm::LLVMAddAttribute(outptr, lib::llvm::NoAliasAttribute as c_uint);\n+        }\n+    }\n+\n+    llfn\n+}\n+\n+pub fn decl_internal_rust_fn(ccx: &mut CrateContext, inputs: &[ty::t], output: ty::t,\n+                             name: &str) -> ValueRef {\n+    let llfn = decl_rust_fn(ccx, inputs, output, name);\n+    lib::llvm::SetLinkage(llfn, lib::llvm::InternalLinkage);\n+    llfn\n }\n \n pub fn get_extern_const(externs: &mut ExternMap, llmod: ModuleRef,\n@@ -809,33 +870,30 @@ pub fn null_env_ptr(ccx: &CrateContext) -> ValueRef {\n     C_null(Type::opaque_box(ccx).ptr_to())\n }\n \n-pub fn trans_external_path(ccx: &mut CrateContext, did: ast::DefId, t: ty::t)\n-    -> ValueRef {\n+pub fn trans_external_path(ccx: &mut CrateContext, did: ast::DefId, t: ty::t) -> ValueRef {\n     let name = csearch::get_symbol(ccx.sess.cstore, did);\n     match ty::get(t).sty {\n         ty::ty_bare_fn(ref fn_ty) => {\n-            // Currently llvm_calling_convention triggers unimpl/bug on\n-            // Rust/RustIntrinsic, so those two are handled specially here.\n-            let cconv = match fn_ty.abis.for_arch(ccx.sess.targ_cfg.arch) {\n-                Some(Rust) | Some(RustIntrinsic) => lib::llvm::CCallConv,\n+            match fn_ty.abis.for_arch(ccx.sess.targ_cfg.arch) {\n+                Some(Rust) | Some(RustIntrinsic) => {\n+                    get_extern_rust_fn(ccx, fn_ty.sig.inputs, fn_ty.sig.output, name)\n+                }\n                 Some(*) | None => {\n                     let c = foreign::llvm_calling_convention(ccx, fn_ty.abis);\n-                    c.unwrap_or(lib::llvm::CCallConv)\n+                    let cconv = c.unwrap_or(lib::llvm::CCallConv);\n+                    let llty = type_of_fn_from_ty(ccx, t);\n+                    get_extern_fn(&mut ccx.externs, ccx.llmod, name, cconv, llty)\n                 }\n-            };\n-            let llty = type_of_fn_from_ty(ccx, t);\n-            return get_extern_fn(&mut ccx.externs, ccx.llmod, name, cconv, llty);\n+            }\n         }\n-        ty::ty_closure(_) => {\n-            let llty = type_of_fn_from_ty(ccx, t);\n-            return get_extern_fn(&mut ccx.externs, ccx.llmod, name,\n-            lib::llvm::CCallConv, llty);\n+        ty::ty_closure(ref f) => {\n+            get_extern_rust_fn(ccx, f.sig.inputs, f.sig.output, name)\n         }\n         _ => {\n             let llty = type_of(ccx, t);\n-            return get_extern_const(&mut ccx.externs, ccx.llmod, name, llty);\n+            get_extern_const(&mut ccx.externs, ccx.llmod, name, llty)\n         }\n-    };\n+    }\n }\n \n pub fn invoke(bcx: @mut Block, llfn: ValueRef, llargs: ~[ValueRef],\n@@ -868,7 +926,8 @@ pub fn invoke(bcx: @mut Block, llfn: ValueRef, llargs: ~[ValueRef],\n                               llfn,\n                               llargs,\n                               normal_bcx.llbb,\n-                              get_landing_pad(bcx));\n+                              get_landing_pad(bcx),\n+                              attributes);\n         return (llresult, normal_bcx);\n     } else {\n         unsafe {\n@@ -1707,8 +1766,7 @@ pub fn new_fn_ctxt(ccx: @mut CrateContext,\n // field of the fn_ctxt with\n pub fn create_llargs_for_fn_args(cx: @mut FunctionContext,\n                                  self_arg: self_arg,\n-                                 args: &[ast::arg],\n-                                 arg_tys: &[ty::t])\n+                                 args: &[ast::arg])\n                               -> ~[ValueRef] {\n     let _icx = push_ctxt(\"create_llargs_for_fn_args\");\n \n@@ -1726,23 +1784,7 @@ pub fn create_llargs_for_fn_args(cx: @mut FunctionContext,\n     // Return an array containing the ValueRefs that we get from\n     // llvm::LLVMGetParam for each argument.\n     do vec::from_fn(args.len()) |i| {\n-        let arg_n = cx.arg_pos(i);\n-        let arg_ty = arg_tys[i];\n-        let llarg = unsafe {llvm::LLVMGetParam(cx.llfn, arg_n as c_uint) };\n-\n-        match ty::get(arg_ty).sty {\n-            // `~` pointer parameters never alias because ownership is transferred\n-            ty::ty_uniq(*) |\n-            ty::ty_evec(_, ty::vstore_uniq) |\n-            ty::ty_closure(ty::ClosureTy {sigil: ast::OwnedSigil, _}) => {\n-                unsafe {\n-                    llvm::LLVMAddAttribute(llarg, lib::llvm::NoAliasAttribute as c_uint);\n-                }\n-            }\n-            _ => ()\n-        }\n-\n-        llarg\n+        unsafe { llvm::LLVMGetParam(cx.llfn, cx.arg_pos(i) as c_uint) }\n     }\n }\n \n@@ -1896,8 +1938,7 @@ pub fn trans_closure(ccx: @mut CrateContext,\n \n     // Set up arguments to the function.\n     let arg_tys = ty::ty_fn_args(node_id_type(bcx, id));\n-    let raw_llargs = create_llargs_for_fn_args(fcx, self_arg,\n-                                               decl.inputs, arg_tys);\n+    let raw_llargs = create_llargs_for_fn_args(fcx, self_arg, decl.inputs);\n \n     // Set the fixed stack segment flag if necessary.\n     if attr::contains_name(attributes, \"fixed_stack_segment\") {\n@@ -1961,18 +2002,6 @@ pub fn trans_fn(ccx: @mut CrateContext,\n            param_substs.repr(ccx.tcx));\n     let _icx = push_ctxt(\"trans_fn\");\n     let output_type = ty::ty_fn_ret(ty::node_id_to_type(ccx.tcx, id));\n-\n-    match ty::get(output_type).sty {\n-        // `~` pointer return values never alias because ownership is transferred\n-        ty::ty_uniq(*) |\n-        ty::ty_evec(_, ty::vstore_uniq) => {\n-            unsafe {\n-                llvm::LLVMAddReturnAttribute(llfndecl, lib::llvm::NoAliasAttribute as c_uint);\n-            }\n-        }\n-        _ => ()\n-    }\n-\n     trans_closure(ccx,\n                   path.clone(),\n                   decl,\n@@ -2120,7 +2149,7 @@ pub fn trans_enum_variant_or_tuple_like_struct<A:IdAndTy>(\n \n     let arg_tys = ty::ty_fn_args(ctor_ty);\n \n-    let raw_llargs = create_llargs_for_fn_args(fcx, no_self, fn_args, arg_tys);\n+    let raw_llargs = create_llargs_for_fn_args(fcx, no_self, fn_args);\n \n     let bcx = fcx.entry_bcx.unwrap();\n \n@@ -2298,10 +2327,28 @@ pub fn register_fn(ccx: @mut CrateContext,\n                    node_id: ast::NodeId,\n                    node_type: ty::t)\n                    -> ValueRef {\n-    let llfty = type_of_fn_from_ty(ccx, node_type);\n-    register_fn_llvmty(ccx, sp, sym, node_id, lib::llvm::CCallConv, llfty)\n+    let f = match ty::get(node_type).sty {\n+        ty::ty_bare_fn(ref f) => {\n+            assert!(f.abis.is_rust() || f.abis.is_intrinsic());\n+            f\n+        }\n+        _ => fail!(\"expected bare rust fn or an intrinsic\")\n+    };\n+\n+    let llfn = decl_rust_fn(ccx, f.sig.inputs, f.sig.output, sym);\n+    ccx.item_symbols.insert(node_id, sym);\n+\n+    // FIXME #4404 android JNI hacks\n+    let is_entry = is_entry_fn(&ccx.sess, node_id) && (!*ccx.sess.building_library ||\n+                      (*ccx.sess.building_library &&\n+                       ccx.sess.targ_cfg.os == session::OsAndroid));\n+    if is_entry {\n+        create_entry_wrapper(ccx, sp, llfn);\n+    }\n+    llfn\n }\n \n+// only use this for foreign function ABIs and glue, use `register_fn` for Rust functions\n pub fn register_fn_llvmty(ccx: @mut CrateContext,\n                           sp: Span,\n                           sym: ~str,"}, {"sha": "4b03a2cac4b3ac09cc2a5c20ef246decbee915e9", "filename": "src/librustc/middle/trans/build.rs", "status": "modified", "additions": 3, "deletions": 10, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/38d4f48f0a185cc27769a6526668baa31aeee6b9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38d4f48f0a185cc27769a6526668baa31aeee6b9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs?ref=38d4f48f0a185cc27769a6526668baa31aeee6b9", "patch": "@@ -109,7 +109,8 @@ pub fn Invoke(cx: @mut Block,\n               Fn: ValueRef,\n               Args: &[ValueRef],\n               Then: BasicBlockRef,\n-              Catch: BasicBlockRef)\n+              Catch: BasicBlockRef,\n+              attributes: &[(uint, lib::llvm::Attribute)])\n            -> ValueRef {\n     if cx.unreachable {\n         return C_null(Type::i8());\n@@ -119,15 +120,7 @@ pub fn Invoke(cx: @mut Block,\n     debug!(\"Invoke(%s with arguments (%s))\",\n            cx.val_to_str(Fn),\n            Args.map(|a| cx.val_to_str(*a)).connect(\", \"));\n-    B(cx).invoke(Fn, Args, Then, Catch)\n-}\n-\n-pub fn FastInvoke(cx: @mut Block, Fn: ValueRef, Args: &[ValueRef],\n-                  Then: BasicBlockRef, Catch: BasicBlockRef) {\n-    if cx.unreachable { return; }\n-    check_not_terminated(cx);\n-    terminate(cx, \"FastInvoke\");\n-    B(cx).fast_invoke(Fn, Args, Then, Catch);\n+    B(cx).invoke(Fn, Args, Then, Catch, attributes)\n }\n \n pub fn Unreachable(cx: @mut Block) {"}, {"sha": "d7a4dbb3510feb5e707f0369cca934fd0df0f061", "filename": "src/librustc/middle/trans/builder.rs", "status": "modified", "additions": 13, "deletions": 18, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/38d4f48f0a185cc27769a6526668baa31aeee6b9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38d4f48f0a185cc27769a6526668baa31aeee6b9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs?ref=38d4f48f0a185cc27769a6526668baa31aeee6b9", "patch": "@@ -154,30 +154,25 @@ impl Builder {\n                   llfn: ValueRef,\n                   args: &[ValueRef],\n                   then: BasicBlockRef,\n-                  catch: BasicBlockRef)\n+                  catch: BasicBlockRef,\n+                  attributes: &[(uint, lib::llvm::Attribute)])\n                   -> ValueRef {\n         self.count_insn(\"invoke\");\n         unsafe {\n-            llvm::LLVMBuildInvoke(self.llbuilder,\n-                                  llfn,\n-                                  vec::raw::to_ptr(args),\n-                                  args.len() as c_uint,\n-                                  then,\n-                                  catch,\n-                                  noname())\n+            let v = llvm::LLVMBuildInvoke(self.llbuilder,\n+                                          llfn,\n+                                          vec::raw::to_ptr(args),\n+                                          args.len() as c_uint,\n+                                          then,\n+                                          catch,\n+                                          noname());\n+            for &(idx, attr) in attributes.iter() {\n+                llvm::LLVMAddInstrAttribute(v, idx as c_uint, attr as c_uint);\n+            }\n+            v\n         }\n     }\n \n-    pub fn fast_invoke(&self,\n-                       llfn: ValueRef,\n-                       args: &[ValueRef],\n-                       then: BasicBlockRef,\n-                       catch: BasicBlockRef) {\n-        self.count_insn(\"fastinvoke\");\n-        let v = self.invoke(llfn, args, then, catch);\n-        lib::llvm::SetInstructionCallConv(v, lib::llvm::FastCallConv);\n-    }\n-\n     pub fn unreachable(&self) {\n         self.count_insn(\"unreachable\");\n         unsafe {"}, {"sha": "54c905a4c1651352ab9b90eae0c399e0e3c84be5", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 20, "deletions": 2, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/38d4f48f0a185cc27769a6526668baa31aeee6b9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38d4f48f0a185cc27769a6526668baa31aeee6b9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=38d4f48f0a185cc27769a6526668baa31aeee6b9", "patch": "@@ -20,7 +20,7 @@ use std::vec;\n \n use back::abi;\n use driver::session;\n-use lib::llvm::ValueRef;\n+use lib::llvm::{ValueRef, NoAliasAttribute, StructRetAttribute};\n use lib::llvm::llvm;\n use metadata::csearch;\n use middle::trans::base;\n@@ -706,8 +706,26 @@ pub fn trans_call_inner(in_cx: @mut Block,\n                 _ => {}\n             }\n \n+            // A function pointer is called without the declaration available, so we have to apply\n+            // any attributes with ABI implications directly to the call instruction. Right now, the\n+            // only attribute we need to worry about is `sret`.\n+            let mut attrs = ~[];\n+            if type_of::return_uses_outptr(in_cx.tcx(), ret_ty) {\n+                attrs.push((1, StructRetAttribute));\n+            }\n+\n+            // The `noalias` attribute on the return value is useful to a function ptr caller.\n+            match ty::get(ret_ty).sty {\n+                // `~` pointer return values never alias because ownership is transferred\n+                ty::ty_uniq(*) |\n+                ty::ty_evec(_, ty::vstore_uniq) => {\n+                    attrs.push((0, NoAliasAttribute));\n+                }\n+                _ => ()\n+            }\n+\n             // Invoke the actual rust fn and update bcx/llresult.\n-            let (llret, b) = base::invoke(bcx, llfn, llargs, []);\n+            let (llret, b) = base::invoke(bcx, llfn, llargs, attrs);\n             bcx = b;\n             llresult = llret;\n "}, {"sha": "605032dc20c8fa0609361a1e7b3fa61976239795", "filename": "src/librustc/middle/trans/closure.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/38d4f48f0a185cc27769a6526668baa31aeee6b9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38d4f48f0a185cc27769a6526668baa31aeee6b9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs?ref=38d4f48f0a185cc27769a6526668baa31aeee6b9", "patch": "@@ -381,16 +381,18 @@ pub fn trans_expr_fn(bcx: @mut Block,\n \n     let ccx = bcx.ccx();\n     let fty = node_id_type(bcx, outer_id);\n-\n-    let llfnty = type_of_fn_from_ty(ccx, fty);\n+    let f = match ty::get(fty).sty {\n+        ty::ty_closure(ref f) => f,\n+        _ => fail!(\"expected closure\")\n+    };\n \n     let sub_path = vec::append_one(bcx.fcx.path.clone(),\n                                    path_name(special_idents::anon));\n     // XXX: Bad copy.\n     let s = mangle_internal_name_by_path_and_seq(ccx,\n                                                  sub_path.clone(),\n                                                  \"expr_fn\");\n-    let llfn = decl_internal_cdecl_fn(ccx.llmod, s, llfnty);\n+    let llfn = decl_internal_rust_fn(ccx, f.sig.inputs, f.sig.output, s);\n \n     // set an inline hint for all closures\n     set_inline_hint(llfn);"}, {"sha": "b00d77d72ddb34650df328966483b8d4246e3e7b", "filename": "src/librustc/middle/trans/foreign.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/38d4f48f0a185cc27769a6526668baa31aeee6b9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38d4f48f0a185cc27769a6526668baa31aeee6b9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=38d4f48f0a185cc27769a6526668baa31aeee6b9", "patch": "@@ -21,7 +21,6 @@ use middle::trans::cabi;\n use middle::trans::build::*;\n use middle::trans::builder::noname;\n use middle::trans::common::*;\n-use middle::trans::llrepr::LlvmRepr;\n use middle::trans::type_of::*;\n use middle::trans::type_of;\n use middle::ty;\n@@ -265,6 +264,9 @@ pub fn trans_native_call(bcx: @mut Block,\n         }\n     };\n \n+    // A function pointer is called without the declaration available, so we have to apply\n+    // any attributes with ABI implications directly to the call instruction. Right now, the\n+    // only attribute we need to worry about is `sret`.\n     let attrs;\n     if fn_type.sret {\n         attrs = &[(1, StructRetAttribute)];\n@@ -406,13 +408,12 @@ pub fn trans_rust_fn_with_foreign_abi(ccx: @mut CrateContext,\n                 special_idents::clownshoe_abi\n             )));\n \n-        // Compute the LLVM type that the function would have if it\n-        // were just a normal Rust function. This will be the type of\n-        // the wrappee fn.\n-        let llty = match ty::get(t).sty {\n+        // Compute the type that the function would have if it were just a\n+        // normal Rust function. This will be the type of the wrappee fn.\n+        let f = match ty::get(t).sty {\n             ty::ty_bare_fn(ref f) => {\n                 assert!(!f.abis.is_rust() && !f.abis.is_intrinsic());\n-                type_of_rust_fn(ccx, f.sig.inputs, f.sig.output)\n+                f\n             }\n             _ => {\n                 ccx.sess.bug(fmt!(\"build_rust_fn: extern fn %s has ty %s, \\\n@@ -422,13 +423,12 @@ pub fn trans_rust_fn_with_foreign_abi(ccx: @mut CrateContext,\n             }\n         };\n \n-        debug!(\"build_rust_fn: path=%s id=%? t=%s llty=%s\",\n+        debug!(\"build_rust_fn: path=%s id=%? t=%s\",\n                path.repr(tcx),\n                id,\n-               t.repr(tcx),\n-               llty.llrepr(ccx));\n+               t.repr(tcx));\n \n-        let llfndecl = base::decl_internal_cdecl_fn(ccx.llmod, ps, llty);\n+        let llfndecl = base::decl_internal_rust_fn(ccx, f.sig.inputs, f.sig.output, ps);\n         base::trans_fn(ccx,\n                        (*path).clone(),\n                        decl,\n@@ -500,7 +500,7 @@ pub fn trans_rust_fn_with_foreign_abi(ccx: @mut CrateContext,\n             // Rust expects to use an outpointer. If the foreign fn\n             // also uses an outpointer, we can reuse it, but the types\n             // may vary, so cast first to the Rust type. If the\n-            // foriegn fn does NOT use an outpointer, we will have to\n+            // foreign fn does NOT use an outpointer, we will have to\n             // alloca some scratch space on the stack.\n             match foreign_outptr {\n                 Some(llforeign_outptr) => {"}, {"sha": "ef055a52468c89be55e964653bf7fe9cb7289f99", "filename": "src/librustc/middle/trans/monomorphize.rs", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/38d4f48f0a185cc27769a6526668baa31aeee6b9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38d4f48f0a185cc27769a6526668baa31aeee6b9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs?ref=38d4f48f0a185cc27769a6526668baa31aeee6b9", "patch": "@@ -14,14 +14,13 @@ use driver::session;\n use lib::llvm::ValueRef;\n use middle::trans::base::{set_llvm_fn_attrs, set_inline_hint};\n use middle::trans::base::{trans_enum_variant,push_ctxt};\n-use middle::trans::base::{trans_fn, decl_internal_cdecl_fn};\n+use middle::trans::base::{trans_fn, decl_internal_rust_fn};\n use middle::trans::base::{get_item_val, no_self};\n use middle::trans::base;\n use middle::trans::common::*;\n use middle::trans::datum;\n use middle::trans::machine;\n use middle::trans::meth;\n-use middle::trans::type_of::type_of_fn_from_ty;\n use middle::trans::type_of;\n use middle::trans::type_use;\n use middle::trans::intrinsic;\n@@ -177,7 +176,14 @@ pub fn monomorphic_fn(ccx: @mut CrateContext,\n             ty::subst_tps(ccx.tcx, substs, None, llitem_ty)\n         }\n     };\n-    let llfty = type_of_fn_from_ty(ccx, mono_ty);\n+\n+    let f = match ty::get(mono_ty).sty {\n+        ty::ty_bare_fn(ref f) => {\n+            assert!(f.abis.is_rust() || f.abis.is_intrinsic());\n+            f\n+        }\n+        _ => fail!(\"expected bare rust fn or an intrinsic\")\n+    };\n \n     ccx.stats.n_monos += 1;\n \n@@ -200,7 +206,7 @@ pub fn monomorphic_fn(ccx: @mut CrateContext,\n     debug!(\"monomorphize_fn mangled to %s\", s);\n \n     let mk_lldecl = || {\n-        let lldecl = decl_internal_cdecl_fn(ccx.llmod, s, llfty);\n+        let lldecl = decl_internal_rust_fn(ccx, f.sig.inputs, f.sig.output, s);\n         ccx.monomorphized.insert(hash_id, lldecl);\n         lldecl\n     };"}, {"sha": "23b87c63d6a2c5bb1ee02117eb586d42d484e5f3", "filename": "src/librustc/middle/trans/reflect.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/38d4f48f0a185cc27769a6526668baa31aeee6b9/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38d4f48f0a185cc27769a6526668baa31aeee6b9/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs?ref=38d4f48f0a185cc27769a6526668baa31aeee6b9", "patch": "@@ -293,8 +293,7 @@ impl Reflector {\n                                                                sub_path,\n                                                                \"get_disr\");\n \n-                let llfty = type_of_rust_fn(ccx, [opaqueptrty], ty::mk_int());\n-                let llfdecl = decl_internal_cdecl_fn(ccx.llmod, sym, llfty);\n+                let llfdecl = decl_internal_rust_fn(ccx, [opaqueptrty], ty::mk_int(), sym);\n                 let fcx = new_fn_ctxt(ccx,\n                                       ~[],\n                                       llfdecl,"}]}