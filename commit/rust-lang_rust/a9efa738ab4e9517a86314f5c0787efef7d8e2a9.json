{"sha": "a9efa738ab4e9517a86314f5c0787efef7d8e2a9", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE5ZWZhNzM4YWI0ZTk1MTdhODYzMTRmNWMwNzg3ZWZlZjdkOGUyYTk=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2019-08-17T09:48:30Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2019-08-17T09:57:01Z"}, "message": "invalid_value: also detect transmute-from-0 (seen in the wild)", "tree": {"sha": "5242201c665a20398d177cc92039b1d5ed5bfdb1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5242201c665a20398d177cc92039b1d5ed5bfdb1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a9efa738ab4e9517a86314f5c0787efef7d8e2a9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a9efa738ab4e9517a86314f5c0787efef7d8e2a9", "html_url": "https://github.com/rust-lang/rust/commit/a9efa738ab4e9517a86314f5c0787efef7d8e2a9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a9efa738ab4e9517a86314f5c0787efef7d8e2a9/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9ab1d5c73a67e0936f71abe6eaccef8d0b4bd25e", "url": "https://api.github.com/repos/rust-lang/rust/commits/9ab1d5c73a67e0936f71abe6eaccef8d0b4bd25e", "html_url": "https://github.com/rust-lang/rust/commit/9ab1d5c73a67e0936f71abe6eaccef8d0b4bd25e"}], "stats": {"total": 155, "additions": 110, "deletions": 45}, "files": [{"sha": "877dc43fb7b9be10dcd8073d0bb6dbc8bc43d617", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 32, "deletions": 6, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/a9efa738ab4e9517a86314f5c0787efef7d8e2a9/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9efa738ab4e9517a86314f5c0787efef7d8e2a9/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=a9efa738ab4e9517a86314f5c0787efef7d8e2a9", "patch": "@@ -1879,12 +1879,38 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for InvalidValue {\n         #[derive(Debug, Copy, Clone, PartialEq)]\n         enum InitKind { Zeroed, Uninit };\n \n+        /// Information about why a type cannot be initialized this way.\n+        /// Contains an error message and optionally a span to point at.\n+        type InitError = (String, Option<Span>);\n+\n+        /// Test if this constant is all-0.\n+        fn is_zero(expr: &hir::Expr) -> bool {\n+            use hir::ExprKind::*;\n+            use syntax::ast::LitKind::*;\n+            match &expr.node {\n+                Lit(lit) =>\n+                    if let Int(i, _) = lit.node {\n+                        i == 0\n+                    } else {\n+                        false\n+                    },\n+                Tup(tup) =>\n+                    tup.iter().all(is_zero),\n+                _ =>\n+                    false\n+            }\n+        }\n+\n         /// Determine if this expression is a \"dangerous initialization\".\n         fn is_dangerous_init(cx: &LateContext<'_, '_>, expr: &hir::Expr) -> Option<InitKind> {\n             const ZEROED_PATH: &[Symbol] = &[sym::core, sym::mem, sym::zeroed];\n             const UININIT_PATH: &[Symbol] = &[sym::core, sym::mem, sym::uninitialized];\n+            // `transmute` is inside an anonymous module (the `extern` block?);\n+            // `Invalid` represents the empty string and matches that.\n+            const TRANSMUTE_PATH: &[Symbol] =\n+                &[sym::core, sym::intrinsics, kw::Invalid, sym::transmute];\n \n-            if let hir::ExprKind::Call(ref path_expr, ref _args) = expr.node {\n+            if let hir::ExprKind::Call(ref path_expr, ref args) = expr.node {\n                 if let hir::ExprKind::Path(ref qpath) = path_expr.node {\n                     if let Some(def_id) = cx.tables.qpath_res(qpath, path_expr.hir_id)\n                         .opt_def_id()\n@@ -1895,20 +1921,20 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for InvalidValue {\n                         if cx.match_def_path(def_id, &UININIT_PATH) {\n                             return Some(InitKind::Uninit);\n                         }\n+                        if cx.match_def_path(def_id, &TRANSMUTE_PATH) {\n+                            if is_zero(&args[0]) {\n+                                return Some(InitKind::Zeroed);\n+                            }\n+                        }\n                         // FIXME: Also detect `MaybeUninit::zeroed().assume_init()` and\n                         // `MaybeUninit::uninit().assume_init()`.\n-                        // FIXME: Also detect `transmute` from 0.\n                     }\n                 }\n             }\n \n             None\n         }\n \n-        /// Information about why a type cannot be initialized this way.\n-        /// Contains an error message and optionally a span to point at.\n-        type InitError = (String, Option<Span>);\n-\n         /// Return `Some` only if we are sure this type does *not*\n         /// allow zero initialization.\n         fn ty_find_init_error<'tcx>("}, {"sha": "54e1210768cd2b55a5950e628ac1f4b1fb46025e", "filename": "src/test/ui/lint/uninitialized-zeroed.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a9efa738ab4e9517a86314f5c0787efef7d8e2a9/src%2Ftest%2Fui%2Flint%2Funinitialized-zeroed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9efa738ab4e9517a86314f5c0787efef7d8e2a9/src%2Ftest%2Fui%2Flint%2Funinitialized-zeroed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Funinitialized-zeroed.rs?ref=a9efa738ab4e9517a86314f5c0787efef7d8e2a9", "patch": "@@ -7,6 +7,7 @@\n #![deny(invalid_value)]\n \n use std::mem::{self, MaybeUninit};\n+use std::num::NonZeroU32;\n \n enum Void {}\n \n@@ -75,6 +76,11 @@ fn main() {\n         let _val: NonBig = mem::zeroed();\n         let _val: NonBig = mem::uninitialized(); //~ ERROR: does not permit being left uninitialized\n \n+        // Transmute-from-0\n+        let _val: &'static i32 = mem::transmute(0usize); //~ ERROR: does not permit zero-initialization\n+        let _val: &'static [i32] = mem::transmute((0usize, 0usize)); //~ ERROR: does not permit zero-initialization\n+        let _val: NonZeroU32 = mem::transmute(0); //~ ERROR: does not permit zero-initialization\n+\n         // Some more types that should work just fine.\n         let _val: Option<&'static i32> = mem::zeroed();\n         let _val: Option<fn()> = mem::zeroed();"}, {"sha": "90a51ba57e96fd6263f9eaac35d534cd0be2d932", "filename": "src/test/ui/lint/uninitialized-zeroed.stderr", "status": "modified", "additions": 72, "deletions": 39, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/a9efa738ab4e9517a86314f5c0787efef7d8e2a9/src%2Ftest%2Fui%2Flint%2Funinitialized-zeroed.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a9efa738ab4e9517a86314f5c0787efef7d8e2a9/src%2Ftest%2Fui%2Flint%2Funinitialized-zeroed.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Funinitialized-zeroed.stderr?ref=a9efa738ab4e9517a86314f5c0787efef7d8e2a9", "patch": "@@ -1,5 +1,5 @@\n error: the type `&'static T` does not permit zero-initialization\n-  --> $DIR/uninitialized-zeroed.rs:27:32\n+  --> $DIR/uninitialized-zeroed.rs:28:32\n    |\n LL |         let _val: &'static T = mem::zeroed();\n    |                                ^^^^^^^^^^^^^\n@@ -15,7 +15,7 @@ LL | #![deny(invalid_value)]\n    = note: References must be non-null\n \n error: the type `&'static T` does not permit being left uninitialized\n-  --> $DIR/uninitialized-zeroed.rs:28:32\n+  --> $DIR/uninitialized-zeroed.rs:29:32\n    |\n LL |         let _val: &'static T = mem::uninitialized();\n    |                                ^^^^^^^^^^^^^^^^^^^^\n@@ -26,7 +26,7 @@ LL |         let _val: &'static T = mem::uninitialized();\n    = note: References must be non-null\n \n error: the type `Wrap<&'static T>` does not permit zero-initialization\n-  --> $DIR/uninitialized-zeroed.rs:30:38\n+  --> $DIR/uninitialized-zeroed.rs:31:38\n    |\n LL |         let _val: Wrap<&'static T> = mem::zeroed();\n    |                                      ^^^^^^^^^^^^^\n@@ -35,13 +35,13 @@ LL |         let _val: Wrap<&'static T> = mem::zeroed();\n    |                                      help: use `MaybeUninit<T>` instead\n    |\n note: References must be non-null (in this struct field)\n-  --> $DIR/uninitialized-zeroed.rs:16:18\n+  --> $DIR/uninitialized-zeroed.rs:17:18\n    |\n LL | struct Wrap<T> { wrapped: T }\n    |                  ^^^^^^^^^^\n \n error: the type `Wrap<&'static T>` does not permit being left uninitialized\n-  --> $DIR/uninitialized-zeroed.rs:31:38\n+  --> $DIR/uninitialized-zeroed.rs:32:38\n    |\n LL |         let _val: Wrap<&'static T> = mem::uninitialized();\n    |                                      ^^^^^^^^^^^^^^^^^^^^\n@@ -50,13 +50,13 @@ LL |         let _val: Wrap<&'static T> = mem::uninitialized();\n    |                                      help: use `MaybeUninit<T>` instead\n    |\n note: References must be non-null (in this struct field)\n-  --> $DIR/uninitialized-zeroed.rs:16:18\n+  --> $DIR/uninitialized-zeroed.rs:17:18\n    |\n LL | struct Wrap<T> { wrapped: T }\n    |                  ^^^^^^^^^^\n \n error: the type `!` does not permit zero-initialization\n-  --> $DIR/uninitialized-zeroed.rs:38:23\n+  --> $DIR/uninitialized-zeroed.rs:39:23\n    |\n LL |         let _val: ! = mem::zeroed();\n    |                       ^^^^^^^^^^^^^\n@@ -67,7 +67,7 @@ LL |         let _val: ! = mem::zeroed();\n    = note: The never type (`!`) has no valid value\n \n error: the type `!` does not permit being left uninitialized\n-  --> $DIR/uninitialized-zeroed.rs:39:23\n+  --> $DIR/uninitialized-zeroed.rs:40:23\n    |\n LL |         let _val: ! = mem::uninitialized();\n    |                       ^^^^^^^^^^^^^^^^^^^^\n@@ -78,7 +78,7 @@ LL |         let _val: ! = mem::uninitialized();\n    = note: The never type (`!`) has no valid value\n \n error: the type `(i32, !)` does not permit zero-initialization\n-  --> $DIR/uninitialized-zeroed.rs:41:30\n+  --> $DIR/uninitialized-zeroed.rs:42:30\n    |\n LL |         let _val: (i32, !) = mem::zeroed();\n    |                              ^^^^^^^^^^^^^\n@@ -89,7 +89,7 @@ LL |         let _val: (i32, !) = mem::zeroed();\n    = note: The never type (`!`) has no valid value\n \n error: the type `(i32, !)` does not permit being left uninitialized\n-  --> $DIR/uninitialized-zeroed.rs:42:30\n+  --> $DIR/uninitialized-zeroed.rs:43:30\n    |\n LL |         let _val: (i32, !) = mem::uninitialized();\n    |                              ^^^^^^^^^^^^^^^^^^^^\n@@ -100,7 +100,7 @@ LL |         let _val: (i32, !) = mem::uninitialized();\n    = note: The never type (`!`) has no valid value\n \n error: the type `Void` does not permit zero-initialization\n-  --> $DIR/uninitialized-zeroed.rs:44:26\n+  --> $DIR/uninitialized-zeroed.rs:45:26\n    |\n LL |         let _val: Void = mem::zeroed();\n    |                          ^^^^^^^^^^^^^\n@@ -111,7 +111,7 @@ LL |         let _val: Void = mem::zeroed();\n    = note: 0-variant enums have no valid value\n \n error: the type `Void` does not permit being left uninitialized\n-  --> $DIR/uninitialized-zeroed.rs:45:26\n+  --> $DIR/uninitialized-zeroed.rs:46:26\n    |\n LL |         let _val: Void = mem::uninitialized();\n    |                          ^^^^^^^^^^^^^^^^^^^^\n@@ -122,7 +122,7 @@ LL |         let _val: Void = mem::uninitialized();\n    = note: 0-variant enums have no valid value\n \n error: the type `&'static i32` does not permit zero-initialization\n-  --> $DIR/uninitialized-zeroed.rs:47:34\n+  --> $DIR/uninitialized-zeroed.rs:48:34\n    |\n LL |         let _val: &'static i32 = mem::zeroed();\n    |                                  ^^^^^^^^^^^^^\n@@ -133,7 +133,7 @@ LL |         let _val: &'static i32 = mem::zeroed();\n    = note: References must be non-null\n \n error: the type `&'static i32` does not permit being left uninitialized\n-  --> $DIR/uninitialized-zeroed.rs:48:34\n+  --> $DIR/uninitialized-zeroed.rs:49:34\n    |\n LL |         let _val: &'static i32 = mem::uninitialized();\n    |                                  ^^^^^^^^^^^^^^^^^^^^\n@@ -144,7 +144,7 @@ LL |         let _val: &'static i32 = mem::uninitialized();\n    = note: References must be non-null\n \n error: the type `Ref` does not permit zero-initialization\n-  --> $DIR/uninitialized-zeroed.rs:50:25\n+  --> $DIR/uninitialized-zeroed.rs:51:25\n    |\n LL |         let _val: Ref = mem::zeroed();\n    |                         ^^^^^^^^^^^^^\n@@ -153,13 +153,13 @@ LL |         let _val: Ref = mem::zeroed();\n    |                         help: use `MaybeUninit<T>` instead\n    |\n note: References must be non-null (in this struct field)\n-  --> $DIR/uninitialized-zeroed.rs:13:12\n+  --> $DIR/uninitialized-zeroed.rs:14:12\n    |\n LL | struct Ref(&'static i32);\n    |            ^^^^^^^^^^^^\n \n error: the type `Ref` does not permit being left uninitialized\n-  --> $DIR/uninitialized-zeroed.rs:51:25\n+  --> $DIR/uninitialized-zeroed.rs:52:25\n    |\n LL |         let _val: Ref = mem::uninitialized();\n    |                         ^^^^^^^^^^^^^^^^^^^^\n@@ -168,13 +168,13 @@ LL |         let _val: Ref = mem::uninitialized();\n    |                         help: use `MaybeUninit<T>` instead\n    |\n note: References must be non-null (in this struct field)\n-  --> $DIR/uninitialized-zeroed.rs:13:12\n+  --> $DIR/uninitialized-zeroed.rs:14:12\n    |\n LL | struct Ref(&'static i32);\n    |            ^^^^^^^^^^^^\n \n error: the type `fn()` does not permit zero-initialization\n-  --> $DIR/uninitialized-zeroed.rs:53:26\n+  --> $DIR/uninitialized-zeroed.rs:54:26\n    |\n LL |         let _val: fn() = mem::zeroed();\n    |                          ^^^^^^^^^^^^^\n@@ -185,7 +185,7 @@ LL |         let _val: fn() = mem::zeroed();\n    = note: Function pointers must be non-null\n \n error: the type `fn()` does not permit being left uninitialized\n-  --> $DIR/uninitialized-zeroed.rs:54:26\n+  --> $DIR/uninitialized-zeroed.rs:55:26\n    |\n LL |         let _val: fn() = mem::uninitialized();\n    |                          ^^^^^^^^^^^^^^^^^^^^\n@@ -196,7 +196,7 @@ LL |         let _val: fn() = mem::uninitialized();\n    = note: Function pointers must be non-null\n \n error: the type `Wrap<fn()>` does not permit zero-initialization\n-  --> $DIR/uninitialized-zeroed.rs:56:32\n+  --> $DIR/uninitialized-zeroed.rs:57:32\n    |\n LL |         let _val: Wrap<fn()> = mem::zeroed();\n    |                                ^^^^^^^^^^^^^\n@@ -205,13 +205,13 @@ LL |         let _val: Wrap<fn()> = mem::zeroed();\n    |                                help: use `MaybeUninit<T>` instead\n    |\n note: Function pointers must be non-null (in this struct field)\n-  --> $DIR/uninitialized-zeroed.rs:16:18\n+  --> $DIR/uninitialized-zeroed.rs:17:18\n    |\n LL | struct Wrap<T> { wrapped: T }\n    |                  ^^^^^^^^^^\n \n error: the type `Wrap<fn()>` does not permit being left uninitialized\n-  --> $DIR/uninitialized-zeroed.rs:57:32\n+  --> $DIR/uninitialized-zeroed.rs:58:32\n    |\n LL |         let _val: Wrap<fn()> = mem::uninitialized();\n    |                                ^^^^^^^^^^^^^^^^^^^^\n@@ -220,13 +220,13 @@ LL |         let _val: Wrap<fn()> = mem::uninitialized();\n    |                                help: use `MaybeUninit<T>` instead\n    |\n note: Function pointers must be non-null (in this struct field)\n-  --> $DIR/uninitialized-zeroed.rs:16:18\n+  --> $DIR/uninitialized-zeroed.rs:17:18\n    |\n LL | struct Wrap<T> { wrapped: T }\n    |                  ^^^^^^^^^^\n \n error: the type `WrapEnum<fn()>` does not permit zero-initialization\n-  --> $DIR/uninitialized-zeroed.rs:59:36\n+  --> $DIR/uninitialized-zeroed.rs:60:36\n    |\n LL |         let _val: WrapEnum<fn()> = mem::zeroed();\n    |                                    ^^^^^^^^^^^^^\n@@ -235,13 +235,13 @@ LL |         let _val: WrapEnum<fn()> = mem::zeroed();\n    |                                    help: use `MaybeUninit<T>` instead\n    |\n note: Function pointers must be non-null (in this enum field)\n-  --> $DIR/uninitialized-zeroed.rs:17:28\n+  --> $DIR/uninitialized-zeroed.rs:18:28\n    |\n LL | enum WrapEnum<T> { Wrapped(T) }\n    |                            ^\n \n error: the type `WrapEnum<fn()>` does not permit being left uninitialized\n-  --> $DIR/uninitialized-zeroed.rs:60:36\n+  --> $DIR/uninitialized-zeroed.rs:61:36\n    |\n LL |         let _val: WrapEnum<fn()> = mem::uninitialized();\n    |                                    ^^^^^^^^^^^^^^^^^^^^\n@@ -250,13 +250,13 @@ LL |         let _val: WrapEnum<fn()> = mem::uninitialized();\n    |                                    help: use `MaybeUninit<T>` instead\n    |\n note: Function pointers must be non-null (in this enum field)\n-  --> $DIR/uninitialized-zeroed.rs:17:28\n+  --> $DIR/uninitialized-zeroed.rs:18:28\n    |\n LL | enum WrapEnum<T> { Wrapped(T) }\n    |                            ^\n \n error: the type `Wrap<(RefPair, i32)>` does not permit zero-initialization\n-  --> $DIR/uninitialized-zeroed.rs:62:42\n+  --> $DIR/uninitialized-zeroed.rs:63:42\n    |\n LL |         let _val: Wrap<(RefPair, i32)> = mem::zeroed();\n    |                                          ^^^^^^^^^^^^^\n@@ -265,13 +265,13 @@ LL |         let _val: Wrap<(RefPair, i32)> = mem::zeroed();\n    |                                          help: use `MaybeUninit<T>` instead\n    |\n note: References must be non-null (in this struct field)\n-  --> $DIR/uninitialized-zeroed.rs:14:16\n+  --> $DIR/uninitialized-zeroed.rs:15:16\n    |\n LL | struct RefPair((&'static i32, i32));\n    |                ^^^^^^^^^^^^^^^^^^^\n \n error: the type `Wrap<(RefPair, i32)>` does not permit being left uninitialized\n-  --> $DIR/uninitialized-zeroed.rs:63:42\n+  --> $DIR/uninitialized-zeroed.rs:64:42\n    |\n LL |         let _val: Wrap<(RefPair, i32)> = mem::uninitialized();\n    |                                          ^^^^^^^^^^^^^^^^^^^^\n@@ -280,13 +280,13 @@ LL |         let _val: Wrap<(RefPair, i32)> = mem::uninitialized();\n    |                                          help: use `MaybeUninit<T>` instead\n    |\n note: References must be non-null (in this struct field)\n-  --> $DIR/uninitialized-zeroed.rs:14:16\n+  --> $DIR/uninitialized-zeroed.rs:15:16\n    |\n LL | struct RefPair((&'static i32, i32));\n    |                ^^^^^^^^^^^^^^^^^^^\n \n error: the type `std::vec::Vec<i32>` does not permit zero-initialization\n-  --> $DIR/uninitialized-zeroed.rs:65:30\n+  --> $DIR/uninitialized-zeroed.rs:66:30\n    |\n LL |         let _val: Vec<i32> = mem::zeroed();\n    |                              ^^^^^^^^^^^^^\n@@ -301,7 +301,7 @@ LL |     ptr: Unique<T>,\n    |     ^^^^^^^^^^^^^^\n \n error: the type `std::vec::Vec<i32>` does not permit being left uninitialized\n-  --> $DIR/uninitialized-zeroed.rs:66:30\n+  --> $DIR/uninitialized-zeroed.rs:67:30\n    |\n LL |         let _val: Vec<i32> = mem::uninitialized();\n    |                              ^^^^^^^^^^^^^^^^^^^^\n@@ -316,7 +316,7 @@ LL |     ptr: Unique<T>,\n    |     ^^^^^^^^^^^^^^\n \n error: the type `bool` does not permit being left uninitialized\n-  --> $DIR/uninitialized-zeroed.rs:70:26\n+  --> $DIR/uninitialized-zeroed.rs:71:26\n    |\n LL |         let _val: bool = mem::uninitialized();\n    |                          ^^^^^^^^^^^^^^^^^^^^\n@@ -327,7 +327,7 @@ LL |         let _val: bool = mem::uninitialized();\n    = note: Booleans must be `true` or `false`\n \n error: the type `Wrap<char>` does not permit being left uninitialized\n-  --> $DIR/uninitialized-zeroed.rs:73:32\n+  --> $DIR/uninitialized-zeroed.rs:74:32\n    |\n LL |         let _val: Wrap<char> = mem::uninitialized();\n    |                                ^^^^^^^^^^^^^^^^^^^^\n@@ -336,13 +336,13 @@ LL |         let _val: Wrap<char> = mem::uninitialized();\n    |                                help: use `MaybeUninit<T>` instead\n    |\n note: Characters must be a valid unicode codepoint (in this struct field)\n-  --> $DIR/uninitialized-zeroed.rs:16:18\n+  --> $DIR/uninitialized-zeroed.rs:17:18\n    |\n LL | struct Wrap<T> { wrapped: T }\n    |                  ^^^^^^^^^^\n \n error: the type `NonBig` does not permit being left uninitialized\n-  --> $DIR/uninitialized-zeroed.rs:76:28\n+  --> $DIR/uninitialized-zeroed.rs:77:28\n    |\n LL |         let _val: NonBig = mem::uninitialized();\n    |                            ^^^^^^^^^^^^^^^^^^^^\n@@ -352,5 +352,38 @@ LL |         let _val: NonBig = mem::uninitialized();\n    |\n    = note: NonBig must be initialized inside its custom valid range\n \n-error: aborting due to 27 previous errors\n+error: the type `&'static i32` does not permit zero-initialization\n+  --> $DIR/uninitialized-zeroed.rs:80:34\n+   |\n+LL |         let _val: &'static i32 = mem::transmute(0usize);\n+   |                                  ^^^^^^^^^^^^^^^^^^^^^^\n+   |                                  |\n+   |                                  this code causes undefined behavior when executed\n+   |                                  help: use `MaybeUninit<T>` instead\n+   |\n+   = note: References must be non-null\n+\n+error: the type `&'static [i32]` does not permit zero-initialization\n+  --> $DIR/uninitialized-zeroed.rs:81:36\n+   |\n+LL |         let _val: &'static [i32] = mem::transmute((0usize, 0usize));\n+   |                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                                    |\n+   |                                    this code causes undefined behavior when executed\n+   |                                    help: use `MaybeUninit<T>` instead\n+   |\n+   = note: References must be non-null\n+\n+error: the type `std::num::NonZeroU32` does not permit zero-initialization\n+  --> $DIR/uninitialized-zeroed.rs:82:32\n+   |\n+LL |         let _val: NonZeroU32 = mem::transmute(0);\n+   |                                ^^^^^^^^^^^^^^^^^\n+   |                                |\n+   |                                this code causes undefined behavior when executed\n+   |                                help: use `MaybeUninit<T>` instead\n+   |\n+   = note: std::num::NonZeroU32 must be non-null\n+\n+error: aborting due to 30 previous errors\n "}]}