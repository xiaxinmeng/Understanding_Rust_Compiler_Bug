{"sha": "a23511a65de7cce47aa12541de60df72b10eb2eb", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEyMzUxMWE2NWRlN2NjZTQ3YWExMjU0MWRlNjBkZjcyYjEwZWIyZWI=", "commit": {"author": {"name": "Aaron Turon", "email": "aturon@mozilla.com", "date": "2014-06-17T21:48:54Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-06-19T00:01:45Z"}, "message": "Revamp TaskBuilder API\n\nThis patch consolidates and cleans up the task spawning APIs:\n\n* Removes the problematic `future_result` method from `std::task::TaskBuilder`,\n  and adds a `try_future` that both spawns the task and returns a future\n  representing its eventual result (or failure).\n\n* Removes the public `opts` field from `TaskBuilder`, instead adding appropriate\n  builder methods to configure the task.\n\n* Adds extension traits to libgreen and libnative that add methods to\n  `TaskBuilder` for spawning the task as a green or native thread.\n\nPreviously, there was no way to benefit from the `TaskBuilder` functionality and\nalso set the scheduler to spawn within.\n\nWith this change, all task spawning scenarios are supported through the\n`TaskBuilder` interface.\n\nCloses #3725.\n\n[breaking-change]", "tree": {"sha": "4e6b9d64eee31db9a7071f752eec0c7ddce3c839", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4e6b9d64eee31db9a7071f752eec0c7ddce3c839"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a23511a65de7cce47aa12541de60df72b10eb2eb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a23511a65de7cce47aa12541de60df72b10eb2eb", "html_url": "https://github.com/rust-lang/rust/commit/a23511a65de7cce47aa12541de60df72b10eb2eb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a23511a65de7cce47aa12541de60df72b10eb2eb/comments", "author": {"login": "aturon", "id": 709807, "node_id": "MDQ6VXNlcjcwOTgwNw==", "avatar_url": "https://avatars.githubusercontent.com/u/709807?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aturon", "html_url": "https://github.com/aturon", "followers_url": "https://api.github.com/users/aturon/followers", "following_url": "https://api.github.com/users/aturon/following{/other_user}", "gists_url": "https://api.github.com/users/aturon/gists{/gist_id}", "starred_url": "https://api.github.com/users/aturon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aturon/subscriptions", "organizations_url": "https://api.github.com/users/aturon/orgs", "repos_url": "https://api.github.com/users/aturon/repos", "events_url": "https://api.github.com/users/aturon/events{/privacy}", "received_events_url": "https://api.github.com/users/aturon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8e9e17d188c2b59813b5a7d8f6ebb0c22e26ce93", "url": "https://api.github.com/repos/rust-lang/rust/commits/8e9e17d188c2b59813b5a7d8f6ebb0c22e26ce93", "html_url": "https://github.com/rust-lang/rust/commit/8e9e17d188c2b59813b5a7d8f6ebb0c22e26ce93"}], "stats": {"total": 989, "additions": 594, "deletions": 395}, "files": [{"sha": "ee25d19e324cc8e474ff5ff21057325113e5a326", "filename": "src/libgreen/lib.rs", "status": "modified", "additions": 67, "deletions": 11, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/a23511a65de7cce47aa12541de60df72b10eb2eb/src%2Flibgreen%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a23511a65de7cce47aa12541de60df72b10eb2eb/src%2Flibgreen%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Flib.rs?ref=a23511a65de7cce47aa12541de60df72b10eb2eb", "patch": "@@ -159,16 +159,19 @@\n //!\n //! # Using a scheduler pool\n //!\n+//! This library adds a `GreenTaskBuilder` trait that extends the methods\n+//! available on `std::task::TaskBuilder` to allow spawning a green task,\n+//! possibly pinned to a particular scheduler thread:\n+//!\n //! ```rust\n-//! use std::rt::task::TaskOpts;\n-//! use green::{SchedPool, PoolConfig};\n-//! use green::sched::{PinnedTask, TaskFromFriend};\n+//! use std::task::TaskBuilder;\n+//! use green::{SchedPool, PoolConfig, GreenTaskBuilder};\n //!\n //! let config = PoolConfig::new();\n //! let mut pool = SchedPool::new(config);\n //!\n //! // Spawn tasks into the pool of schedulers\n-//! pool.spawn(TaskOpts::new(), proc() {\n+//! TaskBuilder::new().green(&mut pool).spawn(proc() {\n //!     // this code is running inside the pool of schedulers\n //!\n //!     spawn(proc() {\n@@ -181,12 +184,9 @@\n //! let mut handle = pool.spawn_sched();\n //!\n //! // Pin a task to the spawned scheduler\n-//! let task = pool.task(TaskOpts::new(), proc() { /* ... */ });\n-//! handle.send(PinnedTask(task));\n-//!\n-//! // Schedule a task on this new scheduler\n-//! let task = pool.task(TaskOpts::new(), proc() { /* ... */ });\n-//! handle.send(TaskFromFriend(task));\n+//! TaskBuilder::new().green_pinned(&mut pool, &mut handle).spawn(proc() {\n+//!     /* ... */\n+//! });\n //!\n //! // Handles keep schedulers alive, so be sure to drop all handles before\n //! // destroying the sched pool\n@@ -209,6 +209,8 @@\n // NB this does *not* include globs, please keep it that way.\n #![feature(macro_rules, phase)]\n #![allow(visible_private_types)]\n+#![allow(deprecated)]\n+#![feature(default_type_params)]\n \n #[cfg(test)] #[phase(plugin, link)] extern crate log;\n #[cfg(test)] extern crate rustuv;\n@@ -224,8 +226,9 @@ use std::rt::task::TaskOpts;\n use std::rt;\n use std::sync::atomics::{SeqCst, AtomicUint, INIT_ATOMIC_UINT};\n use std::sync::deque;\n+use std::task::{TaskBuilder, Spawner};\n \n-use sched::{Shutdown, Scheduler, SchedHandle, TaskFromFriend, NewNeighbor};\n+use sched::{Shutdown, Scheduler, SchedHandle, TaskFromFriend, PinnedTask, NewNeighbor};\n use sleeper_list::SleeperList;\n use stack::StackPool;\n use task::GreenTask;\n@@ -444,6 +447,7 @@ impl SchedPool {\n     /// This is useful to create a task which can then be sent to a specific\n     /// scheduler created by `spawn_sched` (and possibly pin it to that\n     /// scheduler).\n+    #[deprecated = \"use the green and green_pinned methods of GreenTaskBuilder instead\"]\n     pub fn task(&mut self, opts: TaskOpts, f: proc():Send) -> Box<GreenTask> {\n         GreenTask::configure(&mut self.stack_pool, opts, f)\n     }\n@@ -454,6 +458,7 @@ impl SchedPool {\n     /// New tasks are spawned in a round-robin fashion to the schedulers in this\n     /// pool, but tasks can certainly migrate among schedulers once they're in\n     /// the pool.\n+    #[deprecated = \"use the green and green_pinned methods of GreenTaskBuilder instead\"]\n     pub fn spawn(&mut self, opts: TaskOpts, f: proc():Send) {\n         let task = self.task(opts, f);\n \n@@ -563,3 +568,54 @@ impl Drop for SchedPool {\n         }\n     }\n }\n+\n+/// A spawner for green tasks\n+pub struct GreenSpawner<'a>{\n+    pool: &'a mut SchedPool,\n+    handle: Option<&'a mut SchedHandle>\n+}\n+\n+impl<'a> Spawner for GreenSpawner<'a> {\n+    #[inline]\n+    fn spawn(self, opts: TaskOpts, f: proc():Send) {\n+        let GreenSpawner { pool, handle } = self;\n+        match handle {\n+            None    => pool.spawn(opts, f),\n+            Some(h) => h.send(PinnedTask(pool.task(opts, f)))\n+        }\n+    }\n+}\n+\n+/// An extension trait adding `green` configuration methods to `TaskBuilder`.\n+pub trait GreenTaskBuilder {\n+    fn green<'a>(self, &'a mut SchedPool) -> TaskBuilder<GreenSpawner<'a>>;\n+    fn green_pinned<'a>(self, &'a mut SchedPool, &'a mut SchedHandle)\n+                        -> TaskBuilder<GreenSpawner<'a>>;\n+}\n+\n+impl<S: Spawner> GreenTaskBuilder for TaskBuilder<S> {\n+    fn green<'a>(self, pool: &'a mut SchedPool) -> TaskBuilder<GreenSpawner<'a>> {\n+        self.spawner(GreenSpawner {pool: pool, handle: None})\n+    }\n+\n+    fn green_pinned<'a>(self, pool: &'a mut SchedPool, handle: &'a mut SchedHandle)\n+                        -> TaskBuilder<GreenSpawner<'a>> {\n+        self.spawner(GreenSpawner {pool: pool, handle: Some(handle)})\n+    }\n+}\n+\n+#[cfg(test)]\n+mod test {\n+    use std::task::TaskBuilder;\n+    use super::{SchedPool, PoolConfig, GreenTaskBuilder};\n+\n+    #[test]\n+    fn test_green_builder() {\n+        let mut pool = SchedPool::new(PoolConfig::new());\n+        let res = TaskBuilder::new().green(&mut pool).try(proc() {\n+            \"Success!\".to_string()\n+        });\n+        assert_eq!(res.ok().unwrap(), \"Success!\".to_string());\n+        pool.shutdown();\n+    }\n+}"}, {"sha": "40b99c5bbdb1d0bb08d4d948cf5c46e1024a959e", "filename": "src/libnative/lib.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a23511a65de7cce47aa12541de60df72b10eb2eb/src%2Flibnative%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a23511a65de7cce47aa12541de60df72b10eb2eb/src%2Flibnative%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Flib.rs?ref=a23511a65de7cce47aa12541de60df72b10eb2eb", "patch": "@@ -32,10 +32,13 @@\n //! ```rust\n //! extern crate native;\n //!\n+//! use std::task::TaskBuilder;\n+//! use native::NativeTaskBuilder;\n+//!\n //! fn main() {\n //!     // We're not sure whether this main function is run in 1:1 or M:N mode.\n //!\n-//!     native::task::spawn(proc() {\n+//!     TaskBuilder::new().native().spawn(proc() {\n //!         // this code is guaranteed to be run on a native thread\n //!     });\n //! }\n@@ -50,7 +53,8 @@\n        html_root_url = \"http://doc.rust-lang.org/\")]\n #![deny(unused_result, unused_must_use)]\n #![allow(non_camel_case_types)]\n-#![feature(macro_rules)]\n+#![allow(deprecated)]\n+#![feature(default_type_params)]\n \n // NB this crate explicitly does *not* allow glob imports, please seriously\n //    consider whether they're needed before adding that feature here (the\n@@ -65,6 +69,8 @@ use std::os;\n use std::rt;\n use std::str;\n \n+pub use task::NativeTaskBuilder;\n+\n pub mod io;\n pub mod task;\n "}, {"sha": "88e581a47913674ae1e926e3c0a001a562f30e45", "filename": "src/libnative/task.rs", "status": "modified", "additions": 33, "deletions": 1, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/a23511a65de7cce47aa12541de60df72b10eb2eb/src%2Flibnative%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a23511a65de7cce47aa12541de60df72b10eb2eb/src%2Flibnative%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Ftask.rs?ref=a23511a65de7cce47aa12541de60df72b10eb2eb", "patch": "@@ -27,6 +27,7 @@ use std::rt;\n \n use io;\n use task;\n+use std::task::{TaskBuilder, Spawner};\n \n /// Creates a new Task which is ready to execute as a 1:1 task.\n pub fn new(stack_bounds: (uint, uint)) -> Box<Task> {\n@@ -48,12 +49,14 @@ fn ops() -> Box<Ops> {\n }\n \n /// Spawns a function with the default configuration\n+#[deprecated = \"use the native method of NativeTaskBuilder instead\"]\n pub fn spawn(f: proc():Send) {\n     spawn_opts(TaskOpts { name: None, stack_size: None, on_exit: None }, f)\n }\n \n /// Spawns a new task given the configuration options and a procedure to run\n /// inside the task.\n+#[deprecated = \"use the native method of NativeTaskBuilder instead\"]\n pub fn spawn_opts(opts: TaskOpts, f: proc():Send) {\n     let TaskOpts { name, stack_size, on_exit } = opts;\n \n@@ -95,6 +98,26 @@ pub fn spawn_opts(opts: TaskOpts, f: proc():Send) {\n     })\n }\n \n+/// A spawner for native tasks\n+pub struct NativeSpawner;\n+\n+impl Spawner for NativeSpawner {\n+    fn spawn(self, opts: TaskOpts, f: proc():Send) {\n+        spawn_opts(opts, f)\n+    }\n+}\n+\n+/// An extension trait adding a `native` configuration method to `TaskBuilder`.\n+pub trait NativeTaskBuilder {\n+    fn native(self) -> TaskBuilder<NativeSpawner>;\n+}\n+\n+impl<S: Spawner> NativeTaskBuilder for TaskBuilder<S> {\n+    fn native(self) -> TaskBuilder<NativeSpawner> {\n+        self.spawner(NativeSpawner)\n+    }\n+}\n+\n // This structure is the glue between channels and the 1:1 scheduling mode. This\n // structure is allocated once per task.\n struct Ops {\n@@ -259,7 +282,8 @@ mod tests {\n     use std::rt::local::Local;\n     use std::rt::task::{Task, TaskOpts};\n     use std::task;\n-    use super::{spawn, spawn_opts, Ops};\n+    use std::task::TaskBuilder;\n+    use super::{spawn, spawn_opts, Ops, NativeTaskBuilder};\n \n     #[test]\n     fn smoke() {\n@@ -347,4 +371,12 @@ mod tests {\n         });\n         rx.recv();\n     }\n+\n+    #[test]\n+    fn test_native_builder() {\n+        let res = TaskBuilder::new().native().try(proc() {\n+            \"Success!\".to_string()\n+        });\n+        assert_eq!(res.ok().unwrap(), \"Success!\".to_string());\n+    }\n }"}, {"sha": "0ead8fa6c0c839b082c97dbaf6aa6dc9bae5b247", "filename": "src/libstd/task.rs", "status": "modified", "additions": 460, "deletions": 381, "changes": 841, "blob_url": "https://github.com/rust-lang/rust/blob/a23511a65de7cce47aa12541de60df72b10eb2eb/src%2Flibstd%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a23511a65de7cce47aa12541de60df72b10eb2eb/src%2Flibstd%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask.rs?ref=a23511a65de7cce47aa12541de60df72b10eb2eb", "patch": "@@ -8,238 +8,294 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-/*!\n- * Utilities for managing and scheduling tasks\n- *\n- * An executing Rust program consists of a collection of tasks, each with their\n- * own stack, and sole ownership of their allocated heap data. Tasks communicate\n- * with each other using channels (see `std::comm` for more info about how\n- * communication works).\n- *\n- * Failure in one task does not propagate to any others (not to parent, not to\n- * child).  Failure propagation is instead handled by using the channel send()\n- * and recv() methods which will fail if the other end has hung up already.\n- *\n- * Task Scheduling:\n- *\n- * By default, every task is created with the same \"flavor\" as the calling task.\n- * This flavor refers to the scheduling mode, with two possibilities currently\n- * being 1:1 and M:N modes. Green (M:N) tasks are cooperatively scheduled and\n- * native (1:1) tasks are scheduled by the OS kernel.\n- *\n- * # Example\n- *\n- * ```rust\n- * spawn(proc() {\n- *     println!(\"Hello, World!\");\n- * })\n- * ```\n- */\n+//! Utilities for managing and scheduling tasks\n+//!\n+//! An executing Rust program consists of a collection of lightweight tasks,\n+//! each with their own stack. Tasks communicate with each other using channels\n+//! (see `std::comm`) or other forms of synchronization (see `std::sync`) that\n+//! ensure data-race freedom.\n+//!\n+//! Failure in one task does immediately propagate to any others (not to parent,\n+//! not to child). Failure propagation is instead handled as part of task\n+//! synchronization. For example, the channel `send()` and `recv()` methods will\n+//! fail if the other end has hung up already.\n+//!\n+//! # Basic task scheduling\n+//!\n+//! By default, every task is created with the same \"flavor\" as the calling task.\n+//! This flavor refers to the scheduling mode, with two possibilities currently\n+//! being 1:1 and M:N modes. Green (M:N) tasks are cooperatively scheduled and\n+//! native (1:1) tasks are scheduled by the OS kernel.\n+//!\n+//! ## Example\n+//!\n+//! ```rust\n+//! spawn(proc() {\n+//!     println!(\"Hello, World!\");\n+//! })\n+//! ```\n+//!\n+//! # Advanced task scheduling\n+//!\n+//! Task spawning can also be configured to use a particular scheduler, to\n+//! redirect the new task's output, or to yield a `future` representing the\n+//! task's final result. The configuration is established using the\n+//! `TaskBuilder` API:\n+//!\n+//! ## Example\n+//!\n+//! ```rust\n+//! extern crate green;\n+//! extern crate native;\n+//!\n+//! use std::task::TaskBuilder;\n+//! use green::{SchedPool, PoolConfig, GreenTaskBuilder};\n+//! use native::NativeTaskBuilder;\n+//!\n+//! # fn main() {\n+//! // Create a green scheduler pool with the default configuration\n+//! let mut pool = SchedPool::new(PoolConfig::new());\n+//!\n+//! // Spawn a task in the green pool\n+//! let mut fut_green = TaskBuilder::new().green(&mut pool).try_future(proc() {\n+//!     /* ... */\n+//! });\n+//!\n+//! // Spawn a native task\n+//! let mut fut_native = TaskBuilder::new().native().try_future(proc() {\n+//!     /* ... */\n+//! });\n+//!\n+//! // Wait for both tasks to finish, recording their outcome\n+//! let res_green  = fut_green.unwrap();\n+//! let res_native = fut_native.unwrap();\n+//!\n+//! // Shut down the green scheduler pool\n+//! pool.shutdown();\n+//! # }\n+//! ```\n \n use any::Any;\n-use comm::{Sender, Receiver, channel};\n+use comm::channel;\n use io::{Writer, stdio};\n use kinds::{Send, marker};\n use option::{None, Some, Option};\n use owned::Box;\n-use result::{Result, Ok, Err};\n+use result::Result;\n use rt::local::Local;\n use rt::task;\n use rt::task::Task;\n use str::{Str, SendStr, IntoMaybeOwned};\n+use sync::Future;\n \n-#[cfg(test)] use any::AnyRefExt;\n-#[cfg(test)] use owned::AnyOwnExt;\n-#[cfg(test)] use result;\n-#[cfg(test)] use str::StrAllocating;\n-#[cfg(test)] use string::String;\n-\n-/// Task configuration options\n-pub struct TaskOpts {\n-    /// Enable lifecycle notifications on the given channel\n-    pub notify_chan: Option<Sender<task::Result>>,\n-    /// A name for the task-to-be, for identification in failure messages\n-    pub name: Option<SendStr>,\n-    /// The size of the stack for the spawned task\n-    pub stack_size: Option<uint>,\n-    /// Task-local stdout\n-    pub stdout: Option<Box<Writer + Send>>,\n-    /// Task-local stderr\n-    pub stderr: Option<Box<Writer + Send>>,\n+/// A means of spawning a task\n+pub trait Spawner {\n+    /// Spawn a task, given low-level task options.\n+    fn spawn(self, opts: task::TaskOpts, f: proc():Send);\n }\n \n-/**\n- * The task builder type.\n- *\n- * Provides detailed control over the properties and behavior of new tasks.\n- */\n+/// The default task spawner, which spawns siblings to the current task.\n+pub struct SiblingSpawner;\n+\n+impl Spawner for SiblingSpawner {\n+    fn spawn(self, opts: task::TaskOpts, f: proc():Send) {\n+        // bind tb to provide type annotation\n+        let tb: Option<Box<Task>> = Local::try_take();\n+        match tb {\n+            Some(t) => t.spawn_sibling(opts, f),\n+            None => fail!(\"need a local task to spawn a sibling task\"),\n+        };\n+    }\n+}\n+\n+/// The task builder type.\n+///\n+/// Provides detailed control over the properties and behavior of new tasks.\n+\n // NB: Builders are designed to be single-use because they do stateful\n // things that get weird when reusing - e.g. if you create a result future\n // it only applies to a single task, so then you have to maintain Some\n // potentially tricky state to ensure that everything behaves correctly\n // when you try to reuse the builder to spawn a new task. We'll just\n // sidestep that whole issue by making builders uncopyable and making\n // the run function move them in.\n-pub struct TaskBuilder {\n-    /// Options to spawn the new task with\n-    pub opts: TaskOpts,\n-    gen_body: Option<proc(v: proc(): Send): Send -> proc(): Send>,\n+pub struct TaskBuilder<S = SiblingSpawner> {\n+    // A name for the task-to-be, for identification in failure messages\n+    name: Option<SendStr>,\n+    // The size of the stack for the spawned task\n+    stack_size: Option<uint>,\n+    // Task-local stdout\n+    stdout: Option<Box<Writer + Send>>,\n+    // Task-local stderr\n+    stderr: Option<Box<Writer + Send>>,\n+    // The mechanics of actually spawning the task (i.e.: green or native)\n+    spawner: S,\n+    // Optionally wrap the eventual task body\n+    gen_body: Option<proc(v: proc():Send):Send -> proc():Send>,\n     nocopy: marker::NoCopy,\n }\n \n-impl TaskBuilder {\n-     /// Generate the base configuration for spawning a task, off of which more\n-     /// configuration methods can be chained.\n-    pub fn new() -> TaskBuilder {\n+impl TaskBuilder<SiblingSpawner> {\n+    /// Generate the base configuration for spawning a task, off of which more\n+    /// configuration methods can be chained.\n+    pub fn new() -> TaskBuilder<SiblingSpawner> {\n         TaskBuilder {\n-            opts: TaskOpts::new(),\n+            name: None,\n+            stack_size: None,\n+            stdout: None,\n+            stderr: None,\n+            spawner: SiblingSpawner,\n             gen_body: None,\n             nocopy: marker::NoCopy,\n         }\n     }\n+}\n \n-    /// Get a future representing the exit status of the task.\n-    ///\n-    /// Taking the value of the future will block until the child task\n-    /// terminates. The future result return value will be created *before* the task is\n-    /// spawned; as such, do not invoke .get() on it directly;\n-    /// rather, store it in an outer variable/list for later use.\n-    ///\n-    /// # Failure\n-    /// Fails if a future_result was already set for this task.\n-    pub fn future_result(&mut self) -> Receiver<task::Result> {\n-        // FIXME (#3725): Once linked failure and notification are\n-        // handled in the library, I can imagine implementing this by just\n-        // registering an arbitrary number of task::on_exit handlers and\n-        // sending out messages.\n-\n-        if self.opts.notify_chan.is_some() {\n-            fail!(\"Can't set multiple future_results for one task!\");\n-        }\n-\n-        // Construct the future and give it to the caller.\n-        let (tx, rx) = channel();\n+impl<S: Spawner> TaskBuilder<S> {\n+    /// Name the task-to-be. Currently the name is used for identification\n+    /// only in failure messages.\n+    pub fn named<T: IntoMaybeOwned<'static>>(mut self, name: T) -> TaskBuilder<S> {\n+        self.name = Some(name.into_maybe_owned());\n+        self\n+    }\n \n-        // Reconfigure self to use a notify channel.\n-        self.opts.notify_chan = Some(tx);\n+    /// Set the size of the stack for the new task.\n+    pub fn stack_size(mut self, size: uint) -> TaskBuilder<S> {\n+        self.stack_size = Some(size);\n+        self\n+    }\n \n-        rx\n+    /// Redirect task-local stdout.\n+    pub fn stdout(mut self, stdout: Box<Writer + Send>) -> TaskBuilder<S> {\n+        self.stdout = Some(stdout);\n+        self\n     }\n \n-    /// Name the task-to-be. Currently the name is used for identification\n-    /// only in failure messages.\n-    pub fn named<S: IntoMaybeOwned<'static>>(mut self, name: S) -> TaskBuilder {\n-        self.opts.name = Some(name.into_maybe_owned());\n+    /// Redirect task-local stderr.\n+    pub fn stderr(mut self, stderr: Box<Writer + Send>) -> TaskBuilder<S> {\n+        self.stderr = Some(stderr);\n         self\n     }\n \n-    /**\n-     * Add a wrapper to the body of the spawned task.\n-     *\n-     * Before the task is spawned it is passed through a 'body generator'\n-     * function that may perform local setup operations as well as wrap\n-     * the task body in remote setup operations. With this the behavior\n-     * of tasks can be extended in simple ways.\n-     *\n-     * This function augments the current body generator with a new body\n-     * generator by applying the task body which results from the\n-     * existing body generator to the new body generator.\n-     */\n-    pub fn with_wrapper(mut self,\n-                        wrapper: proc(v: proc(): Send): Send -> proc(): Send)\n-        -> TaskBuilder\n-    {\n+    /// Set the spawning mechanism for the task.\n+    ///\n+    /// The `TaskBuilder` API configures a task to be spawned, but defers to the\n+    /// \"spawner\" to actually create and spawn the task. The `spawner` method\n+    /// should not be called directly by `TaskBuiler` clients. It is intended\n+    /// for use by downstream crates (like `native` and `green`) that implement\n+    /// tasks. These downstream crates then add extension methods to the\n+    /// builder, like `.native()` and `.green(pool)`, that actually set the\n+    /// spawner.\n+    pub fn spawner<T: Spawner>(self, spawner: T) -> TaskBuilder<T> {\n+        // repackage the entire TaskBuilder since its type is changing.\n+        let TaskBuilder {\n+            name, stack_size, stdout, stderr, spawner: _, gen_body, nocopy\n+        } = self;\n+        TaskBuilder {\n+            name: name,\n+            stack_size: stack_size,\n+            stdout: stdout,\n+            stderr: stderr,\n+            spawner: spawner,\n+            gen_body: gen_body,\n+            nocopy: nocopy,\n+        }\n+    }\n+\n+    /// Add a wrapper to the body of the spawned task.\n+    ///\n+    /// Before the task is spawned it is passed through a 'body generator'\n+    /// function that may perform local setup operations as well as wrap\n+    /// the task body in remote setup operations. With this the behavior\n+    /// of tasks can be extended in simple ways.\n+    ///\n+    /// This function augments the current body generator with a new body\n+    /// generator by applying the task body which results from the\n+    /// existing body generator to the new body generator.\n+    #[deprecated = \"this function will be removed soon\"]\n+    pub fn with_wrapper(mut self, wrapper: proc(v: proc():Send):Send -> proc():Send)\n+                        -> TaskBuilder<S> {\n         self.gen_body = match self.gen_body.take() {\n             Some(prev) => Some(proc(body) { wrapper(prev(body)) }),\n             None => Some(wrapper)\n         };\n         self\n     }\n \n-    /**\n-     * Creates and executes a new child task\n-     *\n-     * Sets up a new task with its own call stack and schedules it to run\n-     * the provided unique closure. The task has the properties and behavior\n-     * specified by the task_builder.\n-     */\n-    pub fn spawn(mut self, f: proc(): Send) {\n-        let gen_body = self.gen_body.take();\n-        let f = match gen_body {\n+    // Where spawning actually happens (whether yielding a future or not)\n+    fn spawn_internal(self, f: proc():Send,\n+                      on_exit: Option<proc(Result<(), Box<Any + Send>>):Send>) {\n+        let TaskBuilder {\n+            name, stack_size, stdout, stderr, spawner, mut gen_body, nocopy: _\n+        } = self;\n+        let f = match gen_body.take() {\n             Some(gen) => gen(f),\n             None => f\n         };\n-        let t: Box<Task> = match Local::try_take() {\n-            Some(t) => t,\n-            None => fail!(\"need a local task to spawn a new task\"),\n-        };\n-        let TaskOpts { notify_chan, name, stack_size, stdout, stderr } = self.opts;\n-\n         let opts = task::TaskOpts {\n-            on_exit: notify_chan.map(|c| proc(r) c.send(r)),\n+            on_exit: on_exit,\n             name: name,\n             stack_size: stack_size,\n         };\n         if stdout.is_some() || stderr.is_some() {\n-            t.spawn_sibling(opts, proc() {\n+            spawner.spawn(opts, proc() {\n                 let _ = stdout.map(stdio::set_stdout);\n                 let _ = stderr.map(stdio::set_stderr);\n                 f();\n-            });\n+            })\n         } else {\n-            t.spawn_sibling(opts, f);\n+            spawner.spawn(opts, f)\n         }\n     }\n \n-    /**\n-     * Execute a function in another task and return either the return value\n-     * of the function or result::err.\n-     *\n-     * # Return value\n-     *\n-     * If the function executed successfully then try returns result::ok\n-     * containing the value returned by the function. If the function fails\n-     * then try returns result::err containing nil.\n-     *\n-     * # Failure\n-     * Fails if a future_result was already set for this task.\n-     */\n-    pub fn try<T: Send>(mut self, f: proc(): Send -> T)\n-               -> Result<T, Box<Any + Send>> {\n-        let (tx, rx) = channel();\n-\n-        let result = self.future_result();\n-\n-        self.spawn(proc() {\n-            tx.send(f());\n-        });\n-\n-        match result.recv() {\n-            Ok(())     => Ok(rx.recv()),\n-            Err(cause) => Err(cause)\n-        }\n+    /// Creates and executes a new child task.\n+    ///\n+    /// Sets up a new task with its own call stack and schedules it to run\n+    /// the provided proc. The task has the properties and behavior\n+    /// specified by the `TaskBuilder`.\n+    pub fn spawn(self, f: proc():Send) {\n+        self.spawn_internal(f, None)\n     }\n-}\n-\n-/* Task construction */\n \n-impl TaskOpts {\n-    pub fn new() -> TaskOpts {\n-        /*!\n-         * The default task options\n-         */\n+    /// Execute a proc in a newly-spawned task and return a future representing\n+    /// the task's result. The task has the properties and behavior\n+    /// specified by the `TaskBuilder`.\n+    ///\n+    /// Taking the value of the future will block until the child task\n+    /// terminates.\n+    ///\n+    /// # Return value\n+    ///\n+    /// If the child task executes successfully (without failing) then the\n+    /// future returns `result::Ok` containing the value returned by the\n+    /// function. If the child task fails then the future returns `result::Err`\n+    /// containing the argument to `fail!(...)` as an `Any` trait object.\n+    pub fn try_future<T:Send>(self, f: proc():Send -> T)\n+                              -> Future<Result<T, Box<Any + Send>>> {\n+        // currently, the on_exit proc provided by librustrt only works for unit\n+        // results, so we use an additional side-channel to communicate the\n+        // result.\n+\n+        let (tx_done, rx_done) = channel(); // signal that task has exited\n+        let (tx_retv, rx_retv) = channel(); // return value from task\n+\n+        let on_exit = proc(res) { tx_done.send(res) };\n+        self.spawn_internal(proc() { tx_retv.send(f()) },\n+                            Some(on_exit));\n+\n+        Future::from_fn(proc() {\n+            rx_done.recv().map(|_| rx_retv.recv())\n+        })\n+    }\n \n-        TaskOpts {\n-            notify_chan: None,\n-            name: None,\n-            stack_size: None,\n-            stdout: None,\n-            stderr: None,\n-        }\n+    /// Execute a function in a newly-spawnedtask and block until the task\n+    /// completes or fails. Equivalent to `.try_future(f).unwrap()`.\n+    pub fn try<T:Send>(self, f: proc():Send -> T) -> Result<T, Box<Any + Send>> {\n+        self.try_future(f).unwrap()\n     }\n }\n \n-/* Spawn convenience functions */\n+/* Convenience functions */\n \n /// Creates and executes a new child task\n ///\n@@ -251,14 +307,22 @@ pub fn spawn(f: proc(): Send) {\n     TaskBuilder::new().spawn(f)\n }\n \n-/// Execute a function in another task and return either the return value of\n-/// the function or an error if the task failed\n+/// Execute a function in a newly-spawned task and return either the return\n+/// value of the function or an error if the task failed.\n ///\n-/// This is equivalent to TaskBuilder::new().try\n+/// This is equivalent to `TaskBuilder::new().try`.\n pub fn try<T: Send>(f: proc(): Send -> T) -> Result<T, Box<Any + Send>> {\n     TaskBuilder::new().try(f)\n }\n \n+/// Execute a function in another task and return a future representing the\n+/// task's result.\n+///\n+/// This is equivalent to `TaskBuilder::new().try_future`.\n+pub fn try_future<T:Send>(f: proc():Send -> T) -> Future<Result<T, Box<Any + Send>>> {\n+    TaskBuilder::new().try_future(f)\n+}\n+\n \n /* Lifecycle functions */\n \n@@ -273,276 +337,291 @@ pub fn with_task_name<U>(blk: |Option<&str>| -> U) -> U {\n     }\n }\n \n+/// Yield control to the task scheduler.\n pub fn deschedule() {\n-    //! Yield control to the task scheduler\n-\n     use rt::local::Local;\n \n     // FIXME(#7544): Optimize this, since we know we won't block.\n     let task: Box<Task> = Local::take();\n     task.yield_now();\n }\n \n+/// True if the running task is currently failing (e.g. will return `true` inside a\n+/// destructor that is run while unwinding the stack after a call to `fail!()`).\n pub fn failing() -> bool {\n-    //! True if the running task has failed\n     use rt::task::Task;\n     Local::borrow(None::<Task>).unwinder.unwinding()\n }\n \n-// The following 8 tests test the following 2^3 combinations:\n-// {un,}linked {un,}supervised failure propagation {up,down}wards.\n-\n-// !!! These tests are dangerous. If Something is buggy, they will hang, !!!\n-// !!! instead of exiting cleanly. This might wedge the buildbots.       !!!\n-\n-#[test]\n-fn test_unnamed_task() {\n-    spawn(proc() {\n-        with_task_name(|name| {\n-            assert!(name.is_none());\n+#[cfg(test)]\n+mod test {\n+    use any::{Any, AnyRefExt};\n+    use owned::AnyOwnExt;\n+    use result;\n+    use result::{Ok, Err};\n+    use str::StrAllocating;\n+    use string::String;\n+    use std::io::{ChanReader, ChanWriter};\n+    use prelude::*;\n+    use super::*;\n+\n+    // !!! These tests are dangerous. If something is buggy, they will hang, !!!\n+    // !!! instead of exiting cleanly. This might wedge the buildbots.       !!!\n+\n+    #[test]\n+    fn test_unnamed_task() {\n+        spawn(proc() {\n+            with_task_name(|name| {\n+                assert!(name.is_none());\n+            })\n         })\n-    })\n-}\n+    }\n \n-#[test]\n-fn test_owned_named_task() {\n-    TaskBuilder::new().named(\"ada lovelace\".to_string()).spawn(proc() {\n-        with_task_name(|name| {\n-            assert!(name.unwrap() == \"ada lovelace\");\n+    #[test]\n+    fn test_owned_named_task() {\n+        TaskBuilder::new().named(\"ada lovelace\".to_string()).spawn(proc() {\n+            with_task_name(|name| {\n+                assert!(name.unwrap() == \"ada lovelace\");\n+            })\n         })\n-    })\n-}\n+    }\n \n-#[test]\n-fn test_static_named_task() {\n-    TaskBuilder::new().named(\"ada lovelace\").spawn(proc() {\n-        with_task_name(|name| {\n-            assert!(name.unwrap() == \"ada lovelace\");\n+    #[test]\n+    fn test_static_named_task() {\n+        TaskBuilder::new().named(\"ada lovelace\").spawn(proc() {\n+            with_task_name(|name| {\n+                assert!(name.unwrap() == \"ada lovelace\");\n+            })\n         })\n-    })\n-}\n+    }\n \n-#[test]\n-fn test_send_named_task() {\n-    TaskBuilder::new().named(\"ada lovelace\".into_maybe_owned()).spawn(proc() {\n-        with_task_name(|name| {\n-            assert!(name.unwrap() == \"ada lovelace\");\n+    #[test]\n+    fn test_send_named_task() {\n+        TaskBuilder::new().named(\"ada lovelace\".into_maybe_owned()).spawn(proc() {\n+            with_task_name(|name| {\n+                assert!(name.unwrap() == \"ada lovelace\");\n+            })\n         })\n-    })\n-}\n-\n-#[test]\n-fn test_run_basic() {\n-    let (tx, rx) = channel();\n-    TaskBuilder::new().spawn(proc() {\n-        tx.send(());\n-    });\n-    rx.recv();\n-}\n+    }\n \n-#[test]\n-fn test_with_wrapper() {\n-    let (tx, rx) = channel();\n-    TaskBuilder::new().with_wrapper(proc(body) {\n-        let result: proc(): Send = proc() {\n-            body();\n+    #[test]\n+    fn test_run_basic() {\n+        let (tx, rx) = channel();\n+        TaskBuilder::new().spawn(proc() {\n             tx.send(());\n-        };\n-        result\n-    }).spawn(proc() { });\n-    rx.recv();\n-}\n+        });\n+        rx.recv();\n+    }\n \n-#[test]\n-fn test_future_result() {\n-    let mut builder = TaskBuilder::new();\n-    let result = builder.future_result();\n-    builder.spawn(proc() {});\n-    assert!(result.recv().is_ok());\n-\n-    let mut builder = TaskBuilder::new();\n-    let result = builder.future_result();\n-    builder.spawn(proc() {\n-        fail!();\n-    });\n-    assert!(result.recv().is_err());\n-}\n+    #[test]\n+    fn test_with_wrapper() {\n+        let (tx, rx) = channel();\n+        TaskBuilder::new().with_wrapper(proc(body) {\n+            let result: proc():Send = proc() {\n+                body();\n+                tx.send(());\n+            };\n+            result\n+        }).spawn(proc() { });\n+        rx.recv();\n+    }\n \n-#[test] #[should_fail]\n-fn test_back_to_the_future_result() {\n-    let mut builder = TaskBuilder::new();\n-    builder.future_result();\n-    builder.future_result();\n-}\n+    #[test]\n+    fn test_try_future() {\n+        let result = TaskBuilder::new().try_future(proc() {});\n+        assert!(result.unwrap().is_ok());\n \n-#[test]\n-fn test_try_success() {\n-    match try(proc() {\n-        \"Success!\".to_string()\n-    }).as_ref().map(|s| s.as_slice()) {\n-        result::Ok(\"Success!\") => (),\n-        _ => fail!()\n+        let result = TaskBuilder::new().try_future(proc() -> () {\n+            fail!();\n+        });\n+        assert!(result.unwrap().is_err());\n     }\n-}\n \n-#[test]\n-fn test_try_fail() {\n-    match try(proc() {\n-        fail!()\n-    }) {\n-        result::Err(_) => (),\n-        result::Ok(()) => fail!()\n+    #[test]\n+    fn test_try_success() {\n+        match try(proc() {\n+            \"Success!\".to_string()\n+        }).as_ref().map(|s| s.as_slice()) {\n+            result::Ok(\"Success!\") => (),\n+            _ => fail!()\n+        }\n     }\n-}\n \n-#[test]\n-fn test_spawn_sched() {\n-    use clone::Clone;\n+    #[test]\n+    fn test_try_fail() {\n+        match try(proc() {\n+            fail!()\n+        }) {\n+            result::Err(_) => (),\n+            result::Ok(()) => fail!()\n+        }\n+    }\n \n-    let (tx, rx) = channel();\n+    #[test]\n+    fn test_spawn_sched() {\n+        use clone::Clone;\n \n-    fn f(i: int, tx: Sender<()>) {\n-        let tx = tx.clone();\n-        spawn(proc() {\n-            if i == 0 {\n-                tx.send(());\n-            } else {\n-                f(i - 1, tx);\n-            }\n-        });\n+        let (tx, rx) = channel();\n \n+        fn f(i: int, tx: Sender<()>) {\n+            let tx = tx.clone();\n+            spawn(proc() {\n+                if i == 0 {\n+                    tx.send(());\n+                } else {\n+                    f(i - 1, tx);\n+                }\n+            });\n+\n+        }\n+        f(10, tx);\n+        rx.recv();\n     }\n-    f(10, tx);\n-    rx.recv();\n-}\n \n-#[test]\n-fn test_spawn_sched_childs_on_default_sched() {\n-    let (tx, rx) = channel();\n+    #[test]\n+    fn test_spawn_sched_childs_on_default_sched() {\n+        let (tx, rx) = channel();\n \n-    spawn(proc() {\n         spawn(proc() {\n-            tx.send(());\n+            spawn(proc() {\n+                tx.send(());\n+            });\n         });\n-    });\n \n-    rx.recv();\n-}\n+        rx.recv();\n+    }\n \n-#[cfg(test)]\n-fn avoid_copying_the_body(spawnfn: |v: proc(): Send|) {\n-    let (tx, rx) = channel::<uint>();\n+    fn avoid_copying_the_body(spawnfn: |v: proc():Send|) {\n+        let (tx, rx) = channel::<uint>();\n \n-    let x = box 1;\n-    let x_in_parent = (&*x) as *int as uint;\n+        let x = box 1;\n+        let x_in_parent = (&*x) as *int as uint;\n \n-    spawnfn(proc() {\n-        let x_in_child = (&*x) as *int as uint;\n-        tx.send(x_in_child);\n-    });\n+        spawnfn(proc() {\n+            let x_in_child = (&*x) as *int as uint;\n+            tx.send(x_in_child);\n+        });\n \n-    let x_in_child = rx.recv();\n-    assert_eq!(x_in_parent, x_in_child);\n-}\n+        let x_in_child = rx.recv();\n+        assert_eq!(x_in_parent, x_in_child);\n+    }\n \n-#[test]\n-fn test_avoid_copying_the_body_spawn() {\n-    avoid_copying_the_body(spawn);\n-}\n+    #[test]\n+    fn test_avoid_copying_the_body_spawn() {\n+        avoid_copying_the_body(spawn);\n+    }\n \n-#[test]\n-fn test_avoid_copying_the_body_task_spawn() {\n-    avoid_copying_the_body(|f| {\n-        let builder = TaskBuilder::new();\n-        builder.spawn(proc() {\n-            f();\n-        });\n-    })\n-}\n+    #[test]\n+    fn test_avoid_copying_the_body_task_spawn() {\n+        avoid_copying_the_body(|f| {\n+            let builder = TaskBuilder::new();\n+            builder.spawn(proc() {\n+                f();\n+            });\n+        })\n+    }\n \n-#[test]\n-fn test_avoid_copying_the_body_try() {\n-    avoid_copying_the_body(|f| {\n-        let _ = try(proc() {\n-            f()\n-        });\n-    })\n-}\n+    #[test]\n+    fn test_avoid_copying_the_body_try() {\n+        avoid_copying_the_body(|f| {\n+            let _ = try(proc() {\n+                f()\n+            });\n+        })\n+    }\n \n-#[test]\n-fn test_child_doesnt_ref_parent() {\n-    // If the child refcounts the parent task, this will stack overflow when\n-    // climbing the task tree to dereference each ancestor. (See #1789)\n-    // (well, it would if the constant were 8000+ - I lowered it to be more\n-    // valgrind-friendly. try this at home, instead..!)\n-    static generations: uint = 16;\n-    fn child_no(x: uint) -> proc(): Send {\n-        return proc() {\n-            if x < generations {\n-                TaskBuilder::new().spawn(child_no(x+1));\n+    #[test]\n+    fn test_child_doesnt_ref_parent() {\n+        // If the child refcounts the parent task, this will stack overflow when\n+        // climbing the task tree to dereference each ancestor. (See #1789)\n+        // (well, it would if the constant were 8000+ - I lowered it to be more\n+        // valgrind-friendly. try this at home, instead..!)\n+        static generations: uint = 16;\n+        fn child_no(x: uint) -> proc(): Send {\n+            return proc() {\n+                if x < generations {\n+                    TaskBuilder::new().spawn(child_no(x+1));\n+                }\n             }\n         }\n+        TaskBuilder::new().spawn(child_no(0));\n     }\n-    TaskBuilder::new().spawn(child_no(0));\n-}\n \n-#[test]\n-fn test_simple_newsched_spawn() {\n-    spawn(proc()())\n-}\n+    #[test]\n+    fn test_simple_newsched_spawn() {\n+        spawn(proc()())\n+    }\n \n-#[test]\n-fn test_try_fail_message_static_str() {\n-    match try(proc() {\n-        fail!(\"static string\");\n-    }) {\n-        Err(e) => {\n-            type T = &'static str;\n-            assert!(e.is::<T>());\n-            assert_eq!(*e.move::<T>().unwrap(), \"static string\");\n+    #[test]\n+    fn test_try_fail_message_static_str() {\n+        match try(proc() {\n+            fail!(\"static string\");\n+        }) {\n+            Err(e) => {\n+                type T = &'static str;\n+                assert!(e.is::<T>());\n+                assert_eq!(*e.move::<T>().unwrap(), \"static string\");\n+            }\n+            Ok(()) => fail!()\n         }\n-        Ok(()) => fail!()\n     }\n-}\n \n-#[test]\n-fn test_try_fail_message_owned_str() {\n-    match try(proc() {\n-        fail!(\"owned string\".to_string());\n-    }) {\n-        Err(e) => {\n-            type T = String;\n-            assert!(e.is::<T>());\n-            assert_eq!(*e.move::<T>().unwrap(), \"owned string\".to_string());\n+    #[test]\n+    fn test_try_fail_message_owned_str() {\n+        match try(proc() {\n+            fail!(\"owned string\".to_string());\n+        }) {\n+            Err(e) => {\n+                type T = String;\n+                assert!(e.is::<T>());\n+                assert_eq!(*e.move::<T>().unwrap(), \"owned string\".to_string());\n+            }\n+            Ok(()) => fail!()\n         }\n-        Ok(()) => fail!()\n     }\n-}\n \n-#[test]\n-fn test_try_fail_message_any() {\n-    match try(proc() {\n-        fail!(box 413u16 as Box<Any + Send>);\n-    }) {\n-        Err(e) => {\n-            type T = Box<Any + Send>;\n-            assert!(e.is::<T>());\n-            let any = e.move::<T>().unwrap();\n-            assert!(any.is::<u16>());\n-            assert_eq!(*any.move::<u16>().unwrap(), 413u16);\n+    #[test]\n+    fn test_try_fail_message_any() {\n+        match try(proc() {\n+            fail!(box 413u16 as Box<Any + Send>);\n+        }) {\n+            Err(e) => {\n+                type T = Box<Any + Send>;\n+                assert!(e.is::<T>());\n+                let any = e.move::<T>().unwrap();\n+                assert!(any.is::<u16>());\n+                assert_eq!(*any.move::<u16>().unwrap(), 413u16);\n+            }\n+            Ok(()) => fail!()\n         }\n-        Ok(()) => fail!()\n     }\n-}\n \n-#[test]\n-fn test_try_fail_message_unit_struct() {\n-    struct Juju;\n+    #[test]\n+    fn test_try_fail_message_unit_struct() {\n+        struct Juju;\n+\n+        match try(proc() {\n+            fail!(Juju)\n+        }) {\n+            Err(ref e) if e.is::<Juju>() => {}\n+            Err(_) | Ok(()) => fail!()\n+        }\n+    }\n+\n+    #[test]\n+    fn test_stdout() {\n+        let (tx, rx) = channel();\n+        let mut reader = ChanReader::new(rx);\n+        let stdout = ChanWriter::new(tx);\n+\n+        TaskBuilder::new().stdout(box stdout as Box<Writer + Send>).try(proc() {\n+            print!(\"Hello, world!\");\n+        }).unwrap();\n \n-    match try(proc() {\n-        fail!(Juju)\n-    }) {\n-        Err(ref e) if e.is::<Juju>() => {}\n-        Err(_) | Ok(()) => fail!()\n+        let output = reader.read_to_str().unwrap();\n+        assert_eq!(output, \"Hello, world!\".to_string());\n     }\n+\n+    // NOTE: the corresponding test for stderr is in run-pass/task-stderr, due\n+    // to the test harness apparently interfering with stderr configuration.\n }"}, {"sha": "b3cbdb3c4c38258131a7119f9358c19f52db8fc9", "filename": "src/test/run-pass/task-stderr.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/a23511a65de7cce47aa12541de60df72b10eb2eb/src%2Ftest%2Frun-pass%2Ftask-stderr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a23511a65de7cce47aa12541de60df72b10eb2eb/src%2Ftest%2Frun-pass%2Ftask-stderr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-stderr.rs?ref=a23511a65de7cce47aa12541de60df72b10eb2eb", "patch": "@@ -0,0 +1,26 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::io::{ChanReader, ChanWriter};\n+use std::task::build;\n+\n+fn main() {\n+    let (tx, rx) = channel();\n+    let mut reader = ChanReader::new(rx);\n+    let stderr = ChanWriter::new(tx);\n+\n+    let res = build().stderr(box stderr as Box<Writer + Send>).try(proc() -> () {\n+        fail!(\"Hello, world!\")\n+    });\n+    assert!(res.is_err());\n+\n+    let output = reader.read_to_str().unwrap();\n+    assert!(output.as_slice().contains(\"Hello, world!\"));\n+}"}]}