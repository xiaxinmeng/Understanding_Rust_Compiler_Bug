{"sha": "34bc5c882481d717ea3ea261c0a9ef83647ddd20", "node_id": "C_kwDOAAsO6NoAKDM0YmM1Yzg4MjQ4MWQ3MTdlYTNlYTI2MWMwYTllZjgzNjQ3ZGRkMjA", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2022-09-24T14:11:18Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2022-10-01T14:18:54Z"}, "message": "Move lint level computation to rustc_middle::lint.", "tree": {"sha": "cfd4dd103e5bffd948fdfb8878ec0b34a1c9ab2a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cfd4dd103e5bffd948fdfb8878ec0b34a1c9ab2a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/34bc5c882481d717ea3ea261c0a9ef83647ddd20", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/34bc5c882481d717ea3ea261c0a9ef83647ddd20", "html_url": "https://github.com/rust-lang/rust/commit/34bc5c882481d717ea3ea261c0a9ef83647ddd20", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/34bc5c882481d717ea3ea261c0a9ef83647ddd20/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6977f7dbe9011f3a0e06e2e649636e02ba51fbf0", "url": "https://api.github.com/repos/rust-lang/rust/commits/6977f7dbe9011f3a0e06e2e649636e02ba51fbf0", "html_url": "https://github.com/rust-lang/rust/commit/6977f7dbe9011f3a0e06e2e649636e02ba51fbf0"}], "stats": {"total": 203, "additions": 101, "deletions": 102}, "files": [{"sha": "4698cd256a236bc74cf559678fe515d7b24ab14f", "filename": "compiler/rustc_lint/src/levels.rs", "status": "modified", "additions": 32, "deletions": 26, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/34bc5c882481d717ea3ea261c0a9ef83647ddd20/compiler%2Frustc_lint%2Fsrc%2Flevels.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34bc5c882481d717ea3ea261c0a9ef83647ddd20/compiler%2Frustc_lint%2Fsrc%2Flevels.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Flevels.rs?ref=34bc5c882481d717ea3ea261c0a9ef83647ddd20", "patch": "@@ -9,8 +9,8 @@ use rustc_hir::{intravisit, HirId};\n use rustc_index::vec::IndexVec;\n use rustc_middle::hir::nested_filter;\n use rustc_middle::lint::{\n-    reveal_actual_level, struct_lint_level, LevelAndSource, LintExpectation, LintLevelQueryMap,\n-    LintLevelSource,\n+    reveal_actual_level, struct_lint_level, LevelAndSource, LintExpectation, LintLevelSource,\n+    ShallowLintLevelMap,\n };\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::{RegisteredTools, TyCtxt};\n@@ -99,7 +99,9 @@ fn lint_expectations(tcx: TyCtxt<'_>, (): ()) -> Vec<(LintExpectationId, LintExp\n     let mut builder = LintLevelsBuilder {\n         sess: tcx.sess,\n         provider: QueryMapExpectationsWrapper {\n-            map: LintLevelQueryMap { tcx, cur: hir::CRATE_HIR_ID, specs: FxHashMap::default() },\n+            tcx,\n+            cur: hir::CRATE_HIR_ID,\n+            specs: ShallowLintLevelMap::default(),\n             expectations: Vec::new(),\n             unstable_to_stable_ids: FxHashMap::default(),\n         },\n@@ -117,12 +119,12 @@ fn lint_expectations(tcx: TyCtxt<'_>, (): ()) -> Vec<(LintExpectationId, LintExp\n     builder.provider.expectations\n }\n \n-fn lint_levels_on(tcx: TyCtxt<'_>, hir_id: HirId) -> FxHashMap<LintId, LevelAndSource> {\n+fn shallow_lint_levels_on(tcx: TyCtxt<'_>, hir_id: HirId) -> ShallowLintLevelMap {\n     let store = unerased_lint_store(tcx);\n \n     let mut levels = LintLevelsBuilder {\n         sess: tcx.sess,\n-        provider: LintLevelQueryMap { tcx, cur: hir_id, specs: FxHashMap::default() },\n+        provider: LintLevelQueryMap { tcx, cur: hir_id, specs: ShallowLintLevelMap::default() },\n         warn_about_weird_lints: false,\n         store,\n         registered_tools: &tcx.resolutions(()).registered_tools,\n@@ -143,12 +145,6 @@ pub struct TopDown {\n     cur: LintStackIndex,\n }\n \n-pub struct QueryMapExpectationsWrapper<'tcx> {\n-    map: LintLevelQueryMap<'tcx>,\n-    expectations: Vec<(LintExpectationId, LintExpectation)>,\n-    unstable_to_stable_ids: FxHashMap<LintExpectationId, LintExpectationId>,\n-}\n-\n pub trait LintLevelsProvider {\n     fn current_specs(&self) -> &FxHashMap<LintId, LevelAndSource>;\n     fn current_specs_mut(&mut self) -> &mut FxHashMap<LintId, LevelAndSource>;\n@@ -170,28 +166,42 @@ impl LintLevelsProvider for TopDown {\n     }\n }\n \n+struct LintLevelQueryMap<'tcx> {\n+    tcx: TyCtxt<'tcx>,\n+    cur: HirId,\n+    specs: ShallowLintLevelMap,\n+}\n+\n impl LintLevelsProvider for LintLevelQueryMap<'_> {\n     fn current_specs(&self) -> &FxHashMap<LintId, LevelAndSource> {\n-        &self.specs\n+        &self.specs.specs\n     }\n     fn current_specs_mut(&mut self) -> &mut FxHashMap<LintId, LevelAndSource> {\n-        &mut self.specs\n+        &mut self.specs.specs\n     }\n     fn get_lint_level(&self, lint: &'static Lint, _: &Session) -> LevelAndSource {\n-        self.lint_level(lint)\n+        self.specs.lint_level_id_at_node(self.tcx, LintId::of(lint), self.cur)\n     }\n }\n \n+struct QueryMapExpectationsWrapper<'tcx> {\n+    tcx: TyCtxt<'tcx>,\n+    cur: HirId,\n+    specs: ShallowLintLevelMap,\n+    expectations: Vec<(LintExpectationId, LintExpectation)>,\n+    unstable_to_stable_ids: FxHashMap<LintExpectationId, LintExpectationId>,\n+}\n+\n impl LintLevelsProvider for QueryMapExpectationsWrapper<'_> {\n     fn current_specs(&self) -> &FxHashMap<LintId, LevelAndSource> {\n-        &self.map.specs\n+        &self.specs.specs\n     }\n     fn current_specs_mut(&mut self) -> &mut FxHashMap<LintId, LevelAndSource> {\n-        self.map.specs.clear();\n-        &mut self.map.specs\n+        self.specs.specs.clear();\n+        &mut self.specs.specs\n     }\n     fn get_lint_level(&self, lint: &'static Lint, _: &Session) -> LevelAndSource {\n-        self.map.lint_level(lint)\n+        self.specs.lint_level_id_at_node(self.tcx, LintId::of(lint), self.cur)\n     }\n     fn push_expectation(&mut self, id: LintExpectationId, expectation: LintExpectation) {\n         let LintExpectationId::Stable { attr_id: Some(attr_id), hir_id, attr_index, .. } = id else { bug!(\"unstable expectation id should already be mapped\") };\n@@ -210,19 +220,15 @@ impl LintLevelsProvider for QueryMapExpectationsWrapper<'_> {\n \n impl<'tcx> LintLevelsBuilder<'_, QueryMapExpectationsWrapper<'tcx>> {\n     fn add_id(&mut self, hir_id: HirId) {\n-        self.add(\n-            self.provider.map.tcx.hir().attrs(hir_id),\n-            hir_id == hir::CRATE_HIR_ID,\n-            Some(hir_id),\n-        );\n+        self.add(self.provider.tcx.hir().attrs(hir_id), hir_id == hir::CRATE_HIR_ID, Some(hir_id));\n     }\n }\n \n impl<'tcx> intravisit::Visitor<'tcx> for LintLevelsBuilder<'_, QueryMapExpectationsWrapper<'tcx>> {\n     type NestedFilter = nested_filter::All;\n \n     fn nested_visit_map(&mut self) -> Self::Map {\n-        self.provider.map.tcx.hir()\n+        self.provider.tcx.hir()\n     }\n \n     fn visit_param(&mut self, param: &'tcx hir::Param<'tcx>) {\n@@ -941,6 +947,6 @@ impl<'s, P: LintLevelsProvider> LintLevelsBuilder<'s, P> {\n     }\n }\n \n-pub fn provide(providers: &mut Providers) {\n-    *providers = Providers { lint_levels_on, lint_expectations, ..*providers };\n+pub(crate) fn provide(providers: &mut Providers) {\n+    *providers = Providers { shallow_lint_levels_on, lint_expectations, ..*providers };\n }"}, {"sha": "62d123830b11c7afb8f6b590247fbaad696d7d0e", "filename": "compiler/rustc_middle/src/lint.rs", "status": "modified", "additions": 64, "deletions": 36, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/34bc5c882481d717ea3ea261c0a9ef83647ddd20/compiler%2Frustc_middle%2Fsrc%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34bc5c882481d717ea3ea261c0a9ef83647ddd20/compiler%2Frustc_middle%2Fsrc%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Flint.rs?ref=34bc5c882481d717ea3ea261c0a9ef83647ddd20", "patch": "@@ -56,15 +56,27 @@ impl LintLevelSource {\n /// A tuple of a lint level and its source.\n pub type LevelAndSource = (Level, LintLevelSource);\n \n+/// Return type for the `shallow_lint_levels_on` query.\n+///\n+/// This map represents the set of allowed lints and allowance levels given\n+/// by the attributes for *a single HirId*.\n+#[derive(Default, Debug, HashStable)]\n+pub struct ShallowLintLevelMap {\n+    pub specs: FxHashMap<LintId, LevelAndSource>,\n+}\n+\n+/// From an initial level and source, verify the effect of special annotations:\n+/// `warnings` lint level and lint caps.\n+///\n+/// The return of this function is suitable for diagnostics.\n pub fn reveal_actual_level(\n     level: Option<Level>,\n     src: &mut LintLevelSource,\n     sess: &Session,\n     lint: LintId,\n-    get_lint_id_level: impl FnOnce(LintId) -> (Option<Level>, LintLevelSource),\n+    probe_for_lint_level: impl FnOnce(LintId) -> (Option<Level>, LintLevelSource),\n ) -> Level {\n-    // If `level` is none then we actually assume the default level for this\n-    // lint.\n+    // If `level` is none then we actually assume the default level for this lint.\n     let mut level = level.unwrap_or_else(|| lint.lint.default_level(sess.edition()));\n \n     // If we're about to issue a warning, check at the last minute for any\n@@ -76,7 +88,7 @@ pub fn reveal_actual_level(\n     // and so if we turned that into an error, it'd defeat the purpose of the\n     // future compatibility warning.\n     if level == Level::Warn && lint != LintId::of(FORBIDDEN_LINT_GROUPS) {\n-        let (warnings_level, warnings_src) = get_lint_id_level(LintId::of(builtin::WARNINGS));\n+        let (warnings_level, warnings_src) = probe_for_lint_level(LintId::of(builtin::WARNINGS));\n         if let Some(configured_warning_level) = warnings_level {\n             if configured_warning_level != Level::Warn {\n                 level = configured_warning_level;\n@@ -85,8 +97,7 @@ pub fn reveal_actual_level(\n         }\n     }\n \n-    // Ensure that we never exceed the `--cap-lints` argument\n-    // unless the source is a --force-warn\n+    // Ensure that we never exceed the `--cap-lints` argument unless the source is a --force-warn\n     level = if let LintLevelSource::CommandLine(_, Level::ForceWarn(_)) = src {\n         level\n     } else {\n@@ -101,59 +112,76 @@ pub fn reveal_actual_level(\n     level\n }\n \n-pub struct LintLevelQueryMap<'tcx> {\n-    pub tcx: TyCtxt<'tcx>,\n-    pub cur: HirId,\n-    pub specs: FxHashMap<LintId, LevelAndSource>,\n-}\n-\n-impl<'tcx> LintLevelQueryMap<'tcx> {\n-    pub fn lint_id_level(&self, id: LintId) -> (Option<Level>, LintLevelSource) {\n-        Self::get_lint_id_level(id, self.cur, self.tcx, &self.specs)\n-    }\n-\n-    pub fn lint_level(&self, lint: &'static Lint) -> LevelAndSource {\n-        Self::get_lint_level(LintId::of(lint), self.cur, self.tcx, &self.specs)\n-    }\n-\n-    pub fn get_lint_id_level(\n+impl ShallowLintLevelMap {\n+    /// Perform a deep probe in the HIR tree looking for the actual level for the lint.\n+    /// This lint level is not usable for diagnostics, it needs to be corrected by\n+    /// `reveal_actual_level` beforehand.\n+    fn probe_for_lint_level(\n+        &self,\n+        tcx: TyCtxt<'_>,\n         id: LintId,\n-        cur: HirId,\n-        tcx: TyCtxt<'tcx>,\n-        specs: &FxHashMap<LintId, LevelAndSource>,\n+        start: HirId,\n     ) -> (Option<Level>, LintLevelSource) {\n-        if let Some(&(level, src)) = specs.get(&id) {\n+        if let Some(&(level, src)) = self.specs.get(&id) {\n             return (Some(level), src);\n         }\n-        let mut cur = cur;\n+        let mut cur = start;\n \n         loop {\n             let parent = tcx.hir().get_parent_node(cur);\n             if cur == parent {\n                 return (None, LintLevelSource::Default);\n             }\n-            let specs = tcx.lint_levels_on(parent);\n-            if let Some(&(level, src)) = specs.get(&id) {\n+            let specs = tcx.shallow_lint_levels_on(parent);\n+            if let Some(&(level, src)) = specs.specs.get(&id) {\n                 return (Some(level), src);\n             }\n             cur = parent\n         }\n     }\n \n-    pub fn get_lint_level(\n-        id: LintId,\n+    /// Fetch and return the user-visible lint level for the given lint at the given HirId.\n+    pub fn lint_level_id_at_node(\n+        &self,\n+        tcx: TyCtxt<'_>,\n+        lint: LintId,\n         cur: HirId,\n-        tcx: TyCtxt<'tcx>,\n-        specs: &FxHashMap<LintId, LevelAndSource>,\n     ) -> (Level, LintLevelSource) {\n-        let (level, mut src) = Self::get_lint_id_level(id, cur, tcx, specs);\n-        let level = reveal_actual_level(level, &mut src, tcx.sess, id, |id| {\n-            Self::get_lint_id_level(id, cur, tcx, specs)\n+        let (level, mut src) = self.probe_for_lint_level(tcx, lint, cur);\n+        let level = reveal_actual_level(level, &mut src, tcx.sess, lint, |lint| {\n+            self.probe_for_lint_level(tcx, lint, cur)\n         });\n         (level, src)\n     }\n }\n \n+impl TyCtxt<'_> {\n+    /// Fetch and return the user-visible lint level for the given lint at the given HirId.\n+    pub fn lint_level_at_node(self, lint: &'static Lint, id: HirId) -> (Level, LintLevelSource) {\n+        self.shallow_lint_levels_on(id).lint_level_id_at_node(self, LintId::of(lint), id)\n+    }\n+\n+    /// Walks upwards from `id` to find a node which might change lint levels with attributes.\n+    /// It stops at `bound` and just returns it if reached.\n+    pub fn maybe_lint_level_root_bounded(self, mut id: HirId, bound: HirId) -> HirId {\n+        let hir = self.hir();\n+        loop {\n+            if id == bound {\n+                return bound;\n+            }\n+\n+            if hir.attrs(id).iter().any(|attr| Level::from_attr(attr).is_some()) {\n+                return id;\n+            }\n+            let next = hir.get_parent_node(id);\n+            if next == id {\n+                bug!(\"lint traversal reached the root of the crate\");\n+            }\n+            id = next;\n+        }\n+    }\n+}\n+\n /// This struct represents a lint expectation and holds all required information\n /// to emit the `unfulfilled_lint_expectations` lint if it is unfulfilled after\n /// the `LateLintPass` has completed."}, {"sha": "11f88d95ef664d5f452fe7bf5a1bf1e694cb1fbb", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/34bc5c882481d717ea3ea261c0a9ef83647ddd20/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34bc5c882481d717ea3ea261c0a9ef83647ddd20/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=34bc5c882481d717ea3ea261c0a9ef83647ddd20", "patch": "@@ -274,7 +274,7 @@ rustc_queries! {\n         separate_provide_extern\n     }\n \n-    query lint_levels_on(key: HirId) -> FxHashMap<LintId, LevelAndSource> {\n+    query shallow_lint_levels_on(key: HirId) -> rustc_middle::lint::ShallowLintLevelMap {\n         arena_cache\n         desc { |tcx| \"looking up lint levels for `{}`\", key }\n     }"}, {"sha": "97646003e733969a9ef9ae3a3e362ce72c782a9c", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 2, "deletions": 37, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/34bc5c882481d717ea3ea261c0a9ef83647ddd20/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34bc5c882481d717ea3ea261c0a9ef83647ddd20/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=34bc5c882481d717ea3ea261c0a9ef83647ddd20", "patch": "@@ -4,7 +4,7 @@ use crate::arena::Arena;\n use crate::dep_graph::{DepGraph, DepKindStruct};\n use crate::hir::place::Place as HirPlace;\n use crate::infer::canonical::{Canonical, CanonicalVarInfo, CanonicalVarInfos};\n-use crate::lint::{struct_lint_level, LintLevelSource};\n+use crate::lint::struct_lint_level;\n use crate::middle::codegen_fn_attrs::CodegenFnAttrs;\n use crate::middle::resolve_lifetime;\n use crate::middle::stability;\n@@ -57,7 +57,7 @@ use rustc_serialize::opaque::{FileEncodeResult, FileEncoder};\n use rustc_session::config::{CrateType, OutputFilenames};\n use rustc_session::cstore::CrateStoreDyn;\n use rustc_session::errors::TargetDataLayoutErrorsWrapper;\n-use rustc_session::lint::{Level, Lint, LintId};\n+use rustc_session::lint::Lint;\n use rustc_session::Limit;\n use rustc_session::Session;\n use rustc_span::def_id::{DefPathHash, StableCrateId};\n@@ -2812,41 +2812,6 @@ impl<'tcx> TyCtxt<'tcx> {\n         iter.intern_with(|xs| self.intern_bound_variable_kinds(xs))\n     }\n \n-    /// Walks upwards from `id` to find a node which might change lint levels with attributes.\n-    /// It stops at `bound` and just returns it if reached.\n-    pub fn maybe_lint_level_root_bounded(self, mut id: HirId, bound: HirId) -> HirId {\n-        let hir = self.hir();\n-        loop {\n-            if id == bound {\n-                return bound;\n-            }\n-\n-            if hir.attrs(id).iter().any(|attr| Level::from_attr(attr).is_some()) {\n-                return id;\n-            }\n-            let next = hir.get_parent_node(id);\n-            if next == id {\n-                bug!(\"lint traversal reached the root of the crate\");\n-            }\n-            id = next;\n-        }\n-    }\n-\n-    pub fn lint_level_at_node(\n-        self,\n-        lint: &'static Lint,\n-        id: hir::HirId,\n-    ) -> (Level, LintLevelSource) {\n-        let level_and_src = crate::lint::LintLevelQueryMap::get_lint_level(\n-            LintId::of(lint),\n-            id,\n-            self,\n-            self.lint_levels_on(id),\n-        );\n-        debug!(?id, ?level_and_src);\n-        level_and_src\n-    }\n-\n     /// Emit a lint at `span` from a lint struct (some type that implements `DecorateLint`,\n     /// typically generated by `#[derive(LintDiagnostic)]`).\n     pub fn emit_spanned_lint("}, {"sha": "b4a907d697b562bb3c9593bc8bb2286b878b7657", "filename": "compiler/rustc_middle/src/ty/query.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/34bc5c882481d717ea3ea261c0a9ef83647ddd20/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34bc5c882481d717ea3ea261c0a9ef83647ddd20/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery.rs?ref=34bc5c882481d717ea3ea261c0a9ef83647ddd20", "patch": "@@ -1,6 +1,6 @@\n use crate::dep_graph;\n use crate::infer::canonical::{self, Canonical};\n-use crate::lint::{LevelAndSource, LintExpectation};\n+use crate::lint::LintExpectation;\n use crate::metadata::ModChild;\n use crate::middle::codegen_fn_attrs::CodegenFnAttrs;\n use crate::middle::exported_symbols::{ExportedSymbol, SymbolExportInfo};\n@@ -51,7 +51,7 @@ use rustc_index::{bit_set::FiniteBitSet, vec::IndexVec};\n use rustc_session::config::{EntryFnType, OptLevel, OutputFilenames, SymbolManglingVersion};\n use rustc_session::cstore::{CrateDepKind, CrateSource};\n use rustc_session::cstore::{ExternCrate, ForeignModule, LinkagePreference, NativeLib};\n-use rustc_session::lint::{LintExpectationId, LintId};\n+use rustc_session::lint::LintExpectationId;\n use rustc_session::utils::NativeLibKind;\n use rustc_session::Limits;\n use rustc_span::symbol::Symbol;"}]}