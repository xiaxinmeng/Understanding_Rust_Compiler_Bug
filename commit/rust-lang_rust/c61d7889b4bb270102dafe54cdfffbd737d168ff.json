{"sha": "c61d7889b4bb270102dafe54cdfffbd737d168ff", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM2MWQ3ODg5YjRiYjI3MDEwMmRhZmU1NGNkZmZmYmQ3MzdkMTY4ZmY=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-01-26T19:20:38Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-01-28T10:13:53Z"}, "message": "Add the notion of normalizing a parameter environment and ensure that\nall parameter environments are normalized. Correspondingly, stop\nnormalizing predicates we extract out of the environment. Fixes #21664.", "tree": {"sha": "02bed8cd9c7d8f13c4ed7df5abf081b0deb999ce", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/02bed8cd9c7d8f13c4ed7df5abf081b0deb999ce"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c61d7889b4bb270102dafe54cdfffbd737d168ff", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c61d7889b4bb270102dafe54cdfffbd737d168ff", "html_url": "https://github.com/rust-lang/rust/commit/c61d7889b4bb270102dafe54cdfffbd737d168ff", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c61d7889b4bb270102dafe54cdfffbd737d168ff/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c73a1d0a2c871c8a1591b3f383aa319f0502912b", "url": "https://api.github.com/repos/rust-lang/rust/commits/c73a1d0a2c871c8a1591b3f383aa319f0502912b", "html_url": "https://github.com/rust-lang/rust/commit/c73a1d0a2c871c8a1591b3f383aa319f0502912b"}], "stats": {"total": 266, "additions": 203, "deletions": 63}, "files": [{"sha": "cf9e97ef24d0ee8b42b836ae7c8066398fe02382", "filename": "src/librustc/middle/traits/mod.rs", "status": "modified", "additions": 47, "deletions": 1, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/c61d7889b4bb270102dafe54cdfffbd737d168ff/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c61d7889b4bb270102dafe54cdfffbd737d168ff/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs?ref=c61d7889b4bb270102dafe54cdfffbd737d168ff", "patch": "@@ -18,7 +18,7 @@ pub use self::ObligationCauseCode::*;\n use middle::mem_categorization::Typer;\n use middle::subst;\n use middle::ty::{self, Ty};\n-use middle::infer::InferCtxt;\n+use middle::infer::{self, InferCtxt};\n use std::slice::Iter;\n use std::rc::Rc;\n use syntax::ast;\n@@ -392,6 +392,52 @@ pub fn type_known_to_meet_builtin_bound<'a,'tcx>(infcx: &InferCtxt<'a,'tcx>,\n     }\n }\n \n+pub fn normalize_param_env_or_error<'a,'tcx>(unnormalized_env: ty::ParameterEnvironment<'a,'tcx>,\n+                                             cause: ObligationCause<'tcx>)\n+                                             -> ty::ParameterEnvironment<'a,'tcx>\n+{\n+    match normalize_param_env(&unnormalized_env, cause) {\n+        Ok(p) => p,\n+        Err(errors) => {\n+            // this isn't really the ideal place to report errors, but it seems ok\n+            let infcx = infer::new_infer_ctxt(unnormalized_env.tcx);\n+            report_fulfillment_errors(&infcx, &errors);\n+\n+            // normalized failed? use what they gave us, it's better than nothing\n+            unnormalized_env\n+        }\n+    }\n+}\n+\n+pub fn normalize_param_env<'a,'tcx>(param_env: &ty::ParameterEnvironment<'a,'tcx>,\n+                                    cause: ObligationCause<'tcx>)\n+                                    -> Result<ty::ParameterEnvironment<'a,'tcx>,\n+                                              Vec<FulfillmentError<'tcx>>>\n+{\n+    let tcx = param_env.tcx;\n+\n+    debug!(\"normalize_param_env(param_env={})\",\n+           param_env.repr(tcx));\n+\n+    let predicates: Vec<ty::Predicate<'tcx>> = {\n+        let infcx = infer::new_infer_ctxt(tcx);\n+        let mut selcx = &mut SelectionContext::new(&infcx, param_env);\n+        let mut fulfill_cx = FulfillmentContext::new();\n+        let Normalized { value: predicates, obligations } =\n+            project::normalize(selcx, cause, &param_env.caller_bounds);\n+        for obligation in obligations.into_iter() {\n+            fulfill_cx.register_predicate_obligation(selcx.infcx(), obligation);\n+        }\n+        try!(fulfill_cx.select_all_or_error(selcx.infcx(), param_env));\n+        predicates.iter().map(|p| infcx.resolve_type_vars_if_possible(p)).collect()\n+    };\n+\n+    debug!(\"normalize_param_env: predicates={}\",\n+           predicates.repr(tcx));\n+\n+    Ok(param_env.with_caller_bounds(predicates))\n+}\n+\n impl<'tcx,O> Obligation<'tcx,O> {\n     pub fn new(cause: ObligationCause<'tcx>,\n                trait_ref: O)"}, {"sha": "56c1419502fd0db868149db69a452c5161f2b102", "filename": "src/librustc/middle/traits/object_safety.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c61d7889b4bb270102dafe54cdfffbd737d168ff/src%2Flibrustc%2Fmiddle%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c61d7889b4bb270102dafe54cdfffbd737d168ff/src%2Flibrustc%2Fmiddle%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fobject_safety.rs?ref=c61d7889b4bb270102dafe54cdfffbd737d168ff", "patch": "@@ -122,17 +122,15 @@ fn trait_has_sized_self<'tcx>(tcx: &ty::ctxt<'tcx>,\n                               trait_def_id: ast::DefId)\n                               -> bool\n {\n-    let trait_def = ty::lookup_trait_def(tcx, trait_def_id);\n-    let param_env = ty::construct_parameter_environment(tcx,\n-                                                        &trait_def.generics,\n-                                                        ast::DUMMY_NODE_ID);\n-    let predicates = param_env.caller_bounds.clone();\n     let sized_def_id = match tcx.lang_items.sized_trait() {\n         Some(def_id) => def_id,\n         None => { return false; /* No Sized trait, can't require it! */ }\n     };\n \n     // Search for a predicate like `Self : Sized` amongst the trait bounds.\n+    let trait_def = ty::lookup_trait_def(tcx, trait_def_id);\n+    let free_substs = ty::construct_free_substs(tcx, &trait_def.generics, ast::DUMMY_NODE_ID);\n+    let predicates = trait_def.generics.to_bounds(tcx, &free_substs).predicates.into_vec();\n     elaborate_predicates(tcx, predicates)\n         .any(|predicate| {\n             match predicate {"}, {"sha": "0011603d3fa24c71adca1a87f3e3dda6156f69d7", "filename": "src/librustc/middle/traits/project.rs", "status": "modified", "additions": 25, "deletions": 2, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/c61d7889b4bb270102dafe54cdfffbd737d168ff/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c61d7889b4bb270102dafe54cdfffbd737d168ff/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs?ref=c61d7889b4bb270102dafe54cdfffbd737d168ff", "patch": "@@ -60,6 +60,11 @@ struct ProjectionTyCandidateSet<'tcx> {\n     ambiguous: bool\n }\n \n+/// Evaluates constraints of the form:\n+///\n+///     for<...> <T as Trait>::U == V\n+///\n+/// If successful, this may result in additional obligations.\n pub fn poly_project_and_unify_type<'cx,'tcx>(\n     selcx: &mut SelectionContext<'cx,'tcx>,\n     obligation: &PolyProjectionObligation<'tcx>)\n@@ -102,8 +107,11 @@ pub fn poly_project_and_unify_type<'cx,'tcx>(\n     }\n }\n \n-/// Compute result of projecting an associated type and unify it with\n-/// `obligation.predicate.ty` (if we can).\n+/// Evaluates constraints of the form:\n+///\n+///     <T as Trait>::U == V\n+///\n+/// If successful, this may result in additional obligations.\n fn project_and_unify_type<'cx,'tcx>(\n     selcx: &mut SelectionContext<'cx,'tcx>,\n     obligation: &ProjectionObligation<'tcx>)\n@@ -133,6 +141,10 @@ fn project_and_unify_type<'cx,'tcx>(\n     }\n }\n \n+/// Normalizes any associated type projections in `value`, replacing\n+/// them with a fully resolved type where possible. The return value\n+/// combines the normalized result and any additional obligations that\n+/// were incurred as result.\n pub fn normalize<'a,'b,'tcx,T>(selcx: &'a mut SelectionContext<'b,'tcx>,\n                                cause: ObligationCause<'tcx>,\n                                value: &T)\n@@ -142,6 +154,7 @@ pub fn normalize<'a,'b,'tcx,T>(selcx: &'a mut SelectionContext<'b,'tcx>,\n     normalize_with_depth(selcx, cause, 0, value)\n }\n \n+/// As `normalize`, but with a custom depth.\n pub fn normalize_with_depth<'a,'b,'tcx,T>(selcx: &'a mut SelectionContext<'b,'tcx>,\n                                           cause: ObligationCause<'tcx>,\n                                           depth: uint,\n@@ -251,6 +264,12 @@ impl<'tcx,T> Normalized<'tcx,T> {\n     }\n }\n \n+/// The guts of `normalize`: normalize a specific projection like `<T\n+/// as Trait>::Item`. The result is always a type (and possibly\n+/// additional obligations). If ambiguity arises, which implies that\n+/// there are unresolved type variables in the projection, we will\n+/// substitute a fresh type variable `$X` and generate a new\n+/// obligation `<T as Trait>::Item == $X` for later.\n pub fn normalize_projection_type<'a,'b,'tcx>(\n     selcx: &'a mut SelectionContext<'b,'tcx>,\n     projection_ty: ty::ProjectionTy<'tcx>,\n@@ -277,6 +296,10 @@ pub fn normalize_projection_type<'a,'b,'tcx>(\n         })\n }\n \n+/// The guts of `normalize`: normalize a specific projection like `<T\n+/// as Trait>::Item`. The result is always a type (and possibly\n+/// additional obligations). Returns `None` in the case of ambiguity,\n+/// which indicates that there are unbound type variables.\n fn opt_normalize_projection_type<'a,'b,'tcx>(\n     selcx: &'a mut SelectionContext<'b,'tcx>,\n     projection_ty: ty::ProjectionTy<'tcx>,"}, {"sha": "12ad56d316abacd4585c64f633104b0c5b72ccd3", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c61d7889b4bb270102dafe54cdfffbd737d168ff/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c61d7889b4bb270102dafe54cdfffbd737d168ff/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=c61d7889b4bb270102dafe54cdfffbd737d168ff", "patch": "@@ -2157,16 +2157,10 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                                     where_clause_trait_ref: ty::PolyTraitRef<'tcx>)\n                                     -> Result<Vec<PredicateObligation<'tcx>>,()>\n     {\n-        let where_clause_trait_ref =\n-            project::normalize_with_depth(self,\n-                                          obligation.cause.clone(),\n-                                          obligation.recursion_depth+1,\n-                                          &where_clause_trait_ref);\n-\n         let () =\n-            try!(self.match_poly_trait_ref(obligation, where_clause_trait_ref.value.clone()));\n+            try!(self.match_poly_trait_ref(obligation, where_clause_trait_ref));\n \n-        Ok(where_clause_trait_ref.obligations)\n+        Ok(Vec::new())\n     }\n \n     /// Returns `Ok` if `poly_trait_ref` being true implies that the"}, {"sha": "cb3894fb0858dd4e9cb761453a42fa2e15228339", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 77, "deletions": 35, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/c61d7889b4bb270102dafe54cdfffbd737d168ff/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c61d7889b4bb270102dafe54cdfffbd737d168ff/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=c61d7889b4bb270102dafe54cdfffbd737d168ff", "patch": "@@ -2084,11 +2084,7 @@ impl<'tcx> TraitRef<'tcx> {\n pub struct ParameterEnvironment<'a, 'tcx:'a> {\n     pub tcx: &'a ctxt<'tcx>,\n \n-    /// A substitution that can be applied to move from\n-    /// the \"outer\" view of a type or method to the \"inner\" view.\n-    /// In general, this means converting from bound parameters to\n-    /// free parameters. Since we currently represent bound/free type\n-    /// parameters in the same way, this only has an effect on regions.\n+    /// See `construct_free_substs` for details.\n     pub free_substs: Substs<'tcx>,\n \n     /// Each type parameter has an implicit region bound that\n@@ -2108,6 +2104,19 @@ pub struct ParameterEnvironment<'a, 'tcx:'a> {\n }\n \n impl<'a, 'tcx> ParameterEnvironment<'a, 'tcx> {\n+    pub fn with_caller_bounds(&self,\n+                              caller_bounds: Vec<ty::Predicate<'tcx>>)\n+                              -> ParameterEnvironment<'a,'tcx>\n+    {\n+        ParameterEnvironment {\n+            tcx: self.tcx,\n+            free_substs: self.free_substs.clone(),\n+            implicit_region_bound: self.implicit_region_bound,\n+            caller_bounds: caller_bounds,\n+            selection_cache: traits::SelectionCache::new(),\n+        }\n+    }\n+\n     pub fn for_item(cx: &'a ctxt<'tcx>, id: NodeId) -> ParameterEnvironment<'a, 'tcx> {\n         match cx.map.find(id) {\n             Some(ast_map::NodeImplItem(ref impl_item)) => {\n@@ -2119,6 +2128,7 @@ impl<'a, 'tcx> ParameterEnvironment<'a, 'tcx> {\n                                 let method_generics = &method_ty.generics;\n                                 construct_parameter_environment(\n                                     cx,\n+                                    method.span,\n                                     method_generics,\n                                     method.pe_body().id)\n                             }\n@@ -2153,6 +2163,7 @@ impl<'a, 'tcx> ParameterEnvironment<'a, 'tcx> {\n                                 let method_generics = &method_ty.generics;\n                                 construct_parameter_environment(\n                                     cx,\n+                                    method.span,\n                                     method_generics,\n                                     method.pe_body().id)\n                             }\n@@ -2179,6 +2190,7 @@ impl<'a, 'tcx> ParameterEnvironment<'a, 'tcx> {\n                         let fn_pty = ty::lookup_item_type(cx, fn_def_id);\n \n                         construct_parameter_environment(cx,\n+                                                        item.span,\n                                                         &fn_pty.generics,\n                                                         body.id)\n                     }\n@@ -2189,7 +2201,7 @@ impl<'a, 'tcx> ParameterEnvironment<'a, 'tcx> {\n                     ast::ItemStatic(..) => {\n                         let def_id = ast_util::local_def(id);\n                         let pty = ty::lookup_item_type(cx, def_id);\n-                        construct_parameter_environment(cx, &pty.generics, id)\n+                        construct_parameter_environment(cx, item.span, &pty.generics, id)\n                     }\n                     _ => {\n                         cx.sess.span_bug(item.span,\n@@ -6263,18 +6275,17 @@ pub fn empty_parameter_environment<'a,'tcx>(cx: &'a ctxt<'tcx>) -> ParameterEnvi\n                                selection_cache: traits::SelectionCache::new(), }\n }\n \n-/// See `ParameterEnvironment` struct def'n for details\n-pub fn construct_parameter_environment<'a,'tcx>(\n+/// Constructs and returns a substitution that can be applied to move from\n+/// the \"outer\" view of a type or method to the \"inner\" view.\n+/// In general, this means converting from bound parameters to\n+/// free parameters. Since we currently represent bound/free type\n+/// parameters in the same way, this only has an effect on regions.\n+pub fn construct_free_substs<'a,'tcx>(\n     tcx: &'a ctxt<'tcx>,\n     generics: &ty::Generics<'tcx>,\n     free_id: ast::NodeId)\n-    -> ParameterEnvironment<'a, 'tcx>\n+    -> Substs<'tcx>\n {\n-\n-    //\n-    // Construct the free substs.\n-    //\n-\n     // map T => T\n     let mut types = VecPerParamSpace::empty();\n     push_types_from_defs(tcx, &mut types, generics.types.as_slice());\n@@ -6283,11 +6294,45 @@ pub fn construct_parameter_environment<'a,'tcx>(\n     let mut regions = VecPerParamSpace::empty();\n     push_region_params(&mut regions, free_id, generics.regions.as_slice());\n \n-    let free_substs = Substs {\n+    return Substs {\n         types: types,\n         regions: subst::NonerasedRegions(regions)\n     };\n \n+    fn push_region_params(regions: &mut VecPerParamSpace<ty::Region>,\n+                          free_id: ast::NodeId,\n+                          region_params: &[RegionParameterDef])\n+    {\n+        for r in region_params.iter() {\n+            regions.push(r.space, ty::free_region_from_def(free_id, r));\n+        }\n+    }\n+\n+    fn push_types_from_defs<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                                  types: &mut VecPerParamSpace<Ty<'tcx>>,\n+                                  defs: &[TypeParameterDef<'tcx>]) {\n+        for def in defs.iter() {\n+            debug!(\"construct_parameter_environment(): push_types_from_defs: def={:?}\",\n+                   def.repr(tcx));\n+            let ty = ty::mk_param_from_def(tcx, def);\n+            types.push(def.space, ty);\n+       }\n+    }\n+}\n+\n+/// See `ParameterEnvironment` struct def'n for details\n+pub fn construct_parameter_environment<'a,'tcx>(\n+    tcx: &'a ctxt<'tcx>,\n+    span: Span,\n+    generics: &ty::Generics<'tcx>,\n+    free_id: ast::NodeId)\n+    -> ParameterEnvironment<'a, 'tcx>\n+{\n+    //\n+    // Construct the free substs.\n+    //\n+\n+    let free_substs = construct_free_substs(tcx, generics, free_id);\n     let free_id_scope = region::CodeExtent::from_node_id(free_id);\n \n     //\n@@ -6311,33 +6356,30 @@ pub fn construct_parameter_environment<'a,'tcx>(\n            free_substs.repr(tcx),\n            predicates.repr(tcx));\n \n-    return ty::ParameterEnvironment {\n+    //\n+    // Finally, we have to normalize the bounds in the environment, in\n+    // case they contain any associated type projections. This process\n+    // can yield errors if the put in illegal associated types, like\n+    // `<i32 as Foo>::Bar` where `i32` does not implement `Foo`. We\n+    // report these errors right here; this doesn't actually feel\n+    // right to me, because constructing the environment feels like a\n+    // kind of a \"idempotent\" action, but I'm not sure where would be\n+    // a better place. In practice, we construct environments for\n+    // every fn once during type checking, and we'll abort if there\n+    // are any errors at that point, so after type checking you can be\n+    // sure that this will succeed without errors anyway.\n+    //\n+\n+    let unnormalized_env = ty::ParameterEnvironment {\n         tcx: tcx,\n         free_substs: free_substs,\n         implicit_region_bound: ty::ReScope(free_id_scope),\n         caller_bounds: predicates,\n         selection_cache: traits::SelectionCache::new(),\n     };\n \n-    fn push_region_params(regions: &mut VecPerParamSpace<ty::Region>,\n-                          free_id: ast::NodeId,\n-                          region_params: &[RegionParameterDef])\n-    {\n-        for r in region_params.iter() {\n-            regions.push(r.space, ty::free_region_from_def(free_id, r));\n-        }\n-    }\n-\n-    fn push_types_from_defs<'tcx>(tcx: &ty::ctxt<'tcx>,\n-                                  types: &mut VecPerParamSpace<Ty<'tcx>>,\n-                                  defs: &[TypeParameterDef<'tcx>]) {\n-        for def in defs.iter() {\n-            debug!(\"construct_parameter_environment(): push_types_from_defs: def={:?}\",\n-                   def.repr(tcx));\n-            let ty = ty::mk_param_from_def(tcx, def);\n-            types.push(def.space, ty);\n-       }\n-    }\n+    let cause = traits::ObligationCause::misc(span, free_id);\n+    return traits::normalize_param_env_or_error(unnormalized_env, cause);\n \n     fn record_region_bounds<'tcx>(tcx: &ty::ctxt<'tcx>, predicates: &[ty::Predicate<'tcx>]) {\n         debug!(\"record_region_bounds(predicates={:?})\", predicates.repr(tcx));"}, {"sha": "31b14ea3f3dec8aba90473b559b4bed584afcd98", "filename": "src/librustc_typeck/check/compare_method.rs", "status": "modified", "additions": 4, "deletions": 11, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/c61d7889b4bb270102dafe54cdfffbd737d168ff/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c61d7889b4bb270102dafe54cdfffbd737d168ff/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs?ref=c61d7889b4bb270102dafe54cdfffbd737d168ff", "patch": "@@ -215,14 +215,8 @@ pub fn compare_impl_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n     debug!(\"compare_impl_method: impl_bounds={}\",\n            impl_bounds.repr(tcx));\n \n-    // // Normalize the associated types in the impl_bounds.\n-    // let traits::Normalized { value: impl_bounds, .. } =\n-    //     traits::normalize(&mut selcx, normalize_cause.clone(), &impl_bounds);\n-\n     // Normalize the associated types in the trait_bounds.\n     let trait_bounds = trait_m.generics.to_bounds(tcx, &trait_to_skol_substs);\n-    // let traits::Normalized { value: trait_bounds, .. } =\n-    //     traits::normalize(&mut selcx, normalize_cause, &trait_bounds);\n \n     // Obtain the predicate split predicate sets for each.\n     let trait_pred = trait_bounds.predicates.split();\n@@ -242,19 +236,18 @@ pub fn compare_impl_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n     );\n \n     // Construct trait parameter environment and then shift it into the skolemized viewpoint.\n-    let mut trait_param_env = impl_param_env.clone();\n     // The key step here is to update the caller_bounds's predicates to be\n     // the new hybrid bounds we computed.\n-    trait_param_env.caller_bounds = hybrid_preds.into_vec();\n+    let normalize_cause = traits::ObligationCause::misc(impl_m_span, impl_m_body_id);\n+    let trait_param_env = impl_param_env.with_caller_bounds(hybrid_preds.into_vec());\n+    let trait_param_env = traits::normalize_param_env_or_error(trait_param_env,\n+                                                               normalize_cause.clone());\n \n     debug!(\"compare_impl_method: trait_bounds={}\",\n         trait_param_env.caller_bounds.repr(tcx));\n \n     let mut selcx = traits::SelectionContext::new(&infcx, &trait_param_env);\n \n-    let normalize_cause =\n-        traits::ObligationCause::misc(impl_m_span, impl_m_body_id);\n-\n     for predicate in impl_pred.fns.into_iter() {\n         let traits::Normalized { value: predicate, .. } =\n             traits::normalize(&mut selcx, normalize_cause.clone(), &predicate);"}, {"sha": "fe3d9157be48b1aa806699d2677bfef3dda66e8e", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c61d7889b4bb270102dafe54cdfffbd737d168ff/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c61d7889b4bb270102dafe54cdfffbd737d168ff/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=c61d7889b4bb270102dafe54cdfffbd737d168ff", "patch": "@@ -467,7 +467,8 @@ fn check_bare_fn<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                            body: &ast::Block,\n                            id: ast::NodeId,\n                            raw_fty: Ty<'tcx>,\n-                           param_env: ty::ParameterEnvironment<'a, 'tcx>) {\n+                           param_env: ty::ParameterEnvironment<'a, 'tcx>)\n+{\n     match raw_fty.sty {\n         ty::ty_bare_fn(_, ref fn_ty) => {\n             let inh = Inherited::new(ccx.tcx, param_env);"}, {"sha": "db226295cd970f26538ddf93ee0ca89f4556402b", "filename": "src/librustc_typeck/check/wf.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c61d7889b4bb270102dafe54cdfffbd737d168ff/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c61d7889b4bb270102dafe54cdfffbd737d168ff/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs?ref=c61d7889b4bb270102dafe54cdfffbd737d168ff", "patch": "@@ -127,6 +127,7 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n         reject_non_type_param_bounds(ccx.tcx, item.span, &type_scheme.generics);\n         let param_env =\n             ty::construct_parameter_environment(ccx.tcx,\n+                                                item.span,\n                                                 &type_scheme.generics,\n                                                 item.id);\n         let inh = Inherited::new(ccx.tcx, param_env);"}, {"sha": "dd5814f875b0886e5490fed3a64bf567dc80a10e", "filename": "src/test/run-pass/associated-types-normalize-in-bounds-binding.rs", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/c61d7889b4bb270102dafe54cdfffbd737d168ff/src%2Ftest%2Frun-pass%2Fassociated-types-normalize-in-bounds-binding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c61d7889b4bb270102dafe54cdfffbd737d168ff/src%2Ftest%2Frun-pass%2Fassociated-types-normalize-in-bounds-binding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassociated-types-normalize-in-bounds-binding.rs?ref=c61d7889b4bb270102dafe54cdfffbd737d168ff", "patch": "@@ -0,0 +1,42 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that we normalize associated types that appear in a bound that\n+// contains a binding. Issue #21664.\n+\n+#![allow(dead_code)]\n+\n+pub trait Integral {\n+    type Opposite;\n+}\n+\n+impl Integral for i32 {\n+    type Opposite = u32;\n+}\n+\n+impl Integral for u32 {\n+    type Opposite = i32;\n+}\n+\n+pub trait FnLike<A> {\n+    type R;\n+}\n+\n+fn foo<T>()\n+    where T : FnLike<<i32 as Integral>::Opposite, R=bool>\n+{\n+    bar::<T>();\n+}\n+\n+fn bar<T>()\n+    where T : FnLike<u32, R=bool>\n+{}\n+\n+fn main() { }"}]}