{"sha": "366499c3be15a7bbf7914d6825e4d92fdfbddb1e", "node_id": "C_kwDOAAsO6NoAKDM2NjQ5OWMzYmUxNWE3YmJmNzkxNGQ2ODI1ZTRkOTJmZGZiZGRiMWU", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-11-16T20:32:02Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-11-16T20:32:02Z"}, "message": "Do not use reference search in runnables::related_tests", "tree": {"sha": "76b2c8751796d51e7c3b6daaa92e6df8e0f93827", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/76b2c8751796d51e7c3b6daaa92e6df8e0f93827"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/366499c3be15a7bbf7914d6825e4d92fdfbddb1e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/366499c3be15a7bbf7914d6825e4d92fdfbddb1e", "html_url": "https://github.com/rust-lang/rust/commit/366499c3be15a7bbf7914d6825e4d92fdfbddb1e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/366499c3be15a7bbf7914d6825e4d92fdfbddb1e/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0ff380fe174bf948d7fb0acc09941b03ca3cbbfe", "url": "https://api.github.com/repos/rust-lang/rust/commits/0ff380fe174bf948d7fb0acc09941b03ca3cbbfe", "html_url": "https://github.com/rust-lang/rust/commit/0ff380fe174bf948d7fb0acc09941b03ca3cbbfe"}], "stats": {"total": 90, "additions": 48, "deletions": 42}, "files": [{"sha": "281e6c65dc448b17c63b1eec17728cefc4253db3", "filename": "crates/hir/src/semantics.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/366499c3be15a7bbf7914d6825e4d92fdfbddb1e/crates%2Fhir%2Fsrc%2Fsemantics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/366499c3be15a7bbf7914d6825e4d92fdfbddb1e/crates%2Fhir%2Fsrc%2Fsemantics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fsemantics.rs?ref=366499c3be15a7bbf7914d6825e4d92fdfbddb1e", "patch": "@@ -228,6 +228,7 @@ impl<'db, DB: HirDatabase> Semantics<'db, DB> {\n         token.parent().into_iter().flat_map(move |it| self.ancestors_with_macros(it))\n     }\n \n+    /// Iterates the ancestors of the given node, climbing up macro expansions while doing so.\n     pub fn ancestors_with_macros(&self, node: SyntaxNode) -> impl Iterator<Item = SyntaxNode> + '_ {\n         self.imp.ancestors_with_macros(node)\n     }"}, {"sha": "0e3b73d23543163fc0788cc667b130c8bbfc2b8c", "filename": "crates/ide/src/references.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/366499c3be15a7bbf7914d6825e4d92fdfbddb1e/crates%2Fide%2Fsrc%2Freferences.rs", "raw_url": "https://github.com/rust-lang/rust/raw/366499c3be15a7bbf7914d6825e4d92fdfbddb1e/crates%2Fide%2Fsrc%2Freferences.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Freferences.rs?ref=366499c3be15a7bbf7914d6825e4d92fdfbddb1e", "patch": "@@ -109,7 +109,7 @@ pub(crate) fn find_all_refs(\n     }\n }\n \n-fn find_defs<'a>(\n+pub(crate) fn find_defs<'a>(\n     sema: &'a Semantics<RootDatabase>,\n     syntax: &SyntaxNode,\n     offset: TextSize,"}, {"sha": "b2111bc4ee0a409ed197fb3385f305a48e443043", "filename": "crates/ide/src/runnables.rs", "status": "modified", "additions": 46, "deletions": 41, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/366499c3be15a7bbf7914d6825e4d92fdfbddb1e/crates%2Fide%2Fsrc%2Frunnables.rs", "raw_url": "https://github.com/rust-lang/rust/raw/366499c3be15a7bbf7914d6825e4d92fdfbddb1e/crates%2Fide%2Fsrc%2Frunnables.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Frunnables.rs?ref=366499c3be15a7bbf7914d6825e4d92fdfbddb1e", "patch": "@@ -2,7 +2,7 @@ use std::fmt;\n \n use ast::HasName;\n use cfg::CfgExpr;\n-use hir::{AsAssocItem, HasAttrs, HasSource, HirDisplay, InFile, Semantics};\n+use hir::{AsAssocItem, HasAttrs, HasSource, HirDisplay, Semantics};\n use ide_assists::utils::test_related_attribute;\n use ide_db::{\n     base_db::{FilePosition, FileRange},\n@@ -14,7 +14,10 @@ use ide_db::{\n use itertools::Itertools;\n use rustc_hash::{FxHashMap, FxHashSet};\n use stdx::{always, format_to};\n-use syntax::ast::{self, AstNode, HasAttrs as _};\n+use syntax::{\n+    ast::{self, AstNode, HasAttrs as _},\n+    SmolStr, SyntaxNode,\n+};\n \n use crate::{\n     display::{ToNav, TryToNav},\n@@ -31,7 +34,7 @@ pub struct Runnable {\n \n #[derive(Debug, Clone, Hash, PartialEq, Eq)]\n pub enum TestId {\n-    Name(String),\n+    Name(SmolStr),\n     Path(String),\n }\n \n@@ -206,52 +209,52 @@ pub(crate) fn related_tests(\n ) -> Vec<Runnable> {\n     let sema = Semantics::new(db);\n     let mut res: FxHashSet<Runnable> = FxHashSet::default();\n+    let syntax = sema.parse(position.file_id).syntax().clone();\n \n-    find_related_tests(&sema, position, search_scope, &mut res);\n+    find_related_tests(&sema, &syntax, position, search_scope, &mut res);\n \n     res.into_iter().collect()\n }\n \n fn find_related_tests(\n     sema: &Semantics<RootDatabase>,\n+    syntax: &SyntaxNode,\n     position: FilePosition,\n     search_scope: Option<SearchScope>,\n     tests: &mut FxHashSet<Runnable>,\n ) {\n-    let refs = match references::find_all_refs(sema, position, search_scope) {\n-        Some(it) => it,\n-        _ => return,\n-    };\n-    for (file_id, refs) in refs.into_iter().flat_map(|refs| refs.references) {\n-        let file = sema.parse(file_id);\n-        let file = file.syntax();\n-\n-        // create flattened vec of tokens\n-        let tokens =\n-            refs.iter().flat_map(|(range, _)| match file.token_at_offset(range.start()).next() {\n-                Some(token) => sema.descend_into_macros(token),\n-                None => Default::default(),\n-            });\n-\n-        // find first suitable ancestor\n-        let functions = tokens\n-            .filter_map(|token| token.ancestors().find_map(ast::Fn::cast))\n-            .map(|f| hir::InFile::new(sema.hir_file_for(f.syntax()), f));\n-\n-        for InFile { value: fn_def, .. } in functions {\n-            if let Some(runnable) = as_test_runnable(sema, &fn_def) {\n-                // direct test\n-                tests.insert(runnable);\n-            } else if let Some(module) = parent_test_module(sema, &fn_def) {\n-                // indirect test\n-                find_related_tests_in_module(sema, &fn_def, &module, tests);\n+    let defs = references::find_defs(sema, syntax, position.offset);\n+    for def in defs {\n+        let defs = def\n+            .usages(sema)\n+            .set_scope(search_scope.clone())\n+            .all()\n+            .references\n+            .into_values()\n+            .flatten();\n+        for ref_ in defs {\n+            let name_ref = match ref_.name {\n+                ast::NameLike::NameRef(name_ref) => name_ref,\n+                _ => continue,\n+            };\n+            if let Some(fn_def) =\n+                sema.ancestors_with_macros(name_ref.syntax().clone()).find_map(ast::Fn::cast)\n+            {\n+                if let Some(runnable) = as_test_runnable(sema, &fn_def) {\n+                    // direct test\n+                    tests.insert(runnable);\n+                } else if let Some(module) = parent_test_module(sema, &fn_def) {\n+                    // indirect test\n+                    find_related_tests_in_module(sema, syntax, &fn_def, &module, tests);\n+                }\n             }\n         }\n     }\n }\n \n fn find_related_tests_in_module(\n     sema: &Semantics<RootDatabase>,\n+    syntax: &SyntaxNode,\n     fn_def: &ast::Fn,\n     parent_module: &hir::Module,\n     tests: &mut FxHashSet<Runnable>,\n@@ -270,7 +273,7 @@ fn find_related_tests_in_module(\n     let file_id = mod_source.file_id.original_file(sema.db);\n     let mod_scope = SearchScope::file_range(FileRange { file_id, range });\n     let fn_pos = FilePosition { file_id, offset: fn_name.syntax().text_range().start() };\n-    find_related_tests(sema, fn_pos, Some(mod_scope), tests)\n+    find_related_tests(sema, syntax, fn_pos, Some(mod_scope), tests)\n }\n \n fn as_test_runnable(sema: &Semantics<RootDatabase>, fn_def: &ast::Fn) -> Option<Runnable> {\n@@ -297,24 +300,26 @@ fn parent_test_module(sema: &Semantics<RootDatabase>, fn_def: &ast::Fn) -> Optio\n \n pub(crate) fn runnable_fn(sema: &Semantics<RootDatabase>, def: hir::Function) -> Option<Runnable> {\n     let func = def.source(sema.db)?;\n-    let name_string = def.name(sema.db).to_string();\n+    let name = def.name(sema.db).to_smol_str();\n \n     let root = def.module(sema.db).krate().root_module(sema.db);\n \n-    let kind = if name_string == \"main\" && def.module(sema.db) == root {\n+    let kind = if name == \"main\" && def.module(sema.db) == root {\n         RunnableKind::Bin\n     } else {\n-        let canonical_path = {\n-            let def: hir::ModuleDef = def.into();\n-            def.canonical_path(sema.db)\n+        let test_id = || {\n+            let canonical_path = {\n+                let def: hir::ModuleDef = def.into();\n+                def.canonical_path(sema.db)\n+            };\n+            canonical_path.map(TestId::Path).unwrap_or(TestId::Name(name))\n         };\n-        let test_id = canonical_path.map(TestId::Path).unwrap_or(TestId::Name(name_string));\n \n         if test_related_attribute(&func.value).is_some() {\n             let attr = TestAttr::from_fn(&func.value);\n-            RunnableKind::Test { test_id, attr }\n+            RunnableKind::Test { test_id: test_id(), attr }\n         } else if func.value.has_atom_attr(\"bench\") {\n-            RunnableKind::Bench { test_id }\n+            RunnableKind::Bench { test_id: test_id() }\n         } else {\n             return None;\n         }\n@@ -433,7 +438,7 @@ fn module_def_doctest(db: &RootDatabase, def: Definition) -> Option<Runnable> {\n         Some(path)\n     })();\n \n-    let test_id = path.map_or_else(|| TestId::Name(def_name.to_string()), TestId::Path);\n+    let test_id = path.map_or_else(|| TestId::Name(def_name.to_smol_str()), TestId::Path);\n \n     let mut nav = match def {\n         Definition::Module(def) => NavigationTarget::from_module_to_decl(db, def),"}]}