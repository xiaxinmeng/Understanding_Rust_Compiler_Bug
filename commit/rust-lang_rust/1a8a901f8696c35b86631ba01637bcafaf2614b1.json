{"sha": "1a8a901f8696c35b86631ba01637bcafaf2614b1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFhOGE5MDFmODY5NmMzNWI4NjYzMWJhMDE2MzdiY2FmYWYyNjE0YjE=", "commit": {"author": {"name": "musitdev", "email": "philippe.delrieu@free.fr", "date": "2014-01-12T17:32:57Z"}, "committer": {"name": "musitdev", "email": "philippe.delrieu@free.fr", "date": "2014-01-19T07:56:28Z"}, "message": "Squashed commit of the following:\n\ncommit d00623d60afd460755b749ad5f94935f756f29d2\nAuthor: musitdev <philippe.delrieu@free.fr>\nDate:   Sat Jan 4 22:31:40 2014 +0100\n\n    correct last comments.\n\ncommit ef09d6b6d1eebbd7c713c9dad96ed7bfc19dd884\nAuthor: musitdev <philippe.delrieu@free.fr>\nDate:   Thu Jan 2 20:28:53 2014 +0100\n\n    update with the last remarks.\n\ncommit 46a028fe1fcdc2a7dcdd78a63001793eff614349\nAuthor: musitdev <philippe.delrieu@free.fr>\nDate:   Thu Jan 2 10:17:18 2014 +0100\n\n    wrap example code in main function.\n\ncommit 2472901929bef09786b7aef8ca7c89fbe67d8e3e\nAuthor: musitdev <philippe.delrieu@free.fr>\nDate:   Mon Dec 30 19:32:46 2013 +0100\n\n    Correct code to compile.\n\ncommit ed96b2223176781743e984af0e19abcb82150f1f\nAuthor: musitdev <philippe.delrieu@free.fr>\nDate:   Thu Dec 5 11:32:28 2013 +0100\n\n    Correct the comment based on the PR comment.\n    Change init call to new to reflect last change.\n\ncommit 38b0390c3533a16f822a6df5f90b907bd8ed6edc\nAuthor: musitdev <philippe.delrieu@free.fr>\nDate:   Wed Dec 4 22:34:25 2013 +0100\n\n    correct from_utf8_owned call.\n\ncommit 08bed4c5f4fadf93ec457b605a1a1354323d2f5c\nAuthor: musitdev <philippe.delrieu@free.fr>\nDate:   Wed Dec 4 22:12:41 2013 +0100\n\n    correct code '''\n\ncommit 02fddcbe2ab37fe842872691105bc4c5cff5abb5\nAuthor: musitdev <philippe.delrieu@free.fr>\nDate:   Wed Dec 4 13:25:54 2013 +0100\n\n    correct typing error\n\ncommit b26830b8ddb49f551699e791832ed20640a0fafc\nAuthor: musitdev <philippe.delrieu@free.fr>\nDate:   Wed Dec 4 13:18:39 2013 +0100\n\n    pass make check\n\ncommit e87c4f53286122efd0d2364ea45600d4fa4d5744\nAuthor: musitdev <philippe.delrieu@free.fr>\nDate:   Wed Dec 4 10:47:24 2013 +0100\n\n    Add Json example and documentation.", "tree": {"sha": "f867763fe01a8ff67440e9605ad23ea1db009378", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f867763fe01a8ff67440e9605ad23ea1db009378"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1a8a901f8696c35b86631ba01637bcafaf2614b1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1a8a901f8696c35b86631ba01637bcafaf2614b1", "html_url": "https://github.com/rust-lang/rust/commit/1a8a901f8696c35b86631ba01637bcafaf2614b1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1a8a901f8696c35b86631ba01637bcafaf2614b1/comments", "author": {"login": "musitdev", "id": 5486375, "node_id": "MDQ6VXNlcjU0ODYzNzU=", "avatar_url": "https://avatars.githubusercontent.com/u/5486375?v=4", "gravatar_id": "", "url": "https://api.github.com/users/musitdev", "html_url": "https://github.com/musitdev", "followers_url": "https://api.github.com/users/musitdev/followers", "following_url": "https://api.github.com/users/musitdev/following{/other_user}", "gists_url": "https://api.github.com/users/musitdev/gists{/gist_id}", "starred_url": "https://api.github.com/users/musitdev/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/musitdev/subscriptions", "organizations_url": "https://api.github.com/users/musitdev/orgs", "repos_url": "https://api.github.com/users/musitdev/repos", "events_url": "https://api.github.com/users/musitdev/events{/privacy}", "received_events_url": "https://api.github.com/users/musitdev/received_events", "type": "User", "site_admin": false}, "committer": {"login": "musitdev", "id": 5486375, "node_id": "MDQ6VXNlcjU0ODYzNzU=", "avatar_url": "https://avatars.githubusercontent.com/u/5486375?v=4", "gravatar_id": "", "url": "https://api.github.com/users/musitdev", "html_url": "https://github.com/musitdev", "followers_url": "https://api.github.com/users/musitdev/followers", "following_url": "https://api.github.com/users/musitdev/following{/other_user}", "gists_url": "https://api.github.com/users/musitdev/gists{/gist_id}", "starred_url": "https://api.github.com/users/musitdev/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/musitdev/subscriptions", "organizations_url": "https://api.github.com/users/musitdev/orgs", "repos_url": "https://api.github.com/users/musitdev/repos", "events_url": "https://api.github.com/users/musitdev/events{/privacy}", "received_events_url": "https://api.github.com/users/musitdev/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6d55211700545d253dec4ebbe386832e00d2a247", "url": "https://api.github.com/repos/rust-lang/rust/commits/6d55211700545d253dec4ebbe386832e00d2a247", "html_url": "https://github.com/rust-lang/rust/commit/6d55211700545d253dec4ebbe386832e00d2a247"}], "stats": {"total": 223, "additions": 222, "deletions": 1}, "files": [{"sha": "88068f2cf7752522bcd2c4f574bbe6d022a51b9d", "filename": "src/libextra/json.rs", "status": "modified", "additions": 222, "deletions": 1, "changes": 223, "blob_url": "https://github.com/rust-lang/rust/blob/1a8a901f8696c35b86631ba01637bcafaf2614b1/src%2Flibextra%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a8a901f8696c35b86631ba01637bcafaf2614b1/src%2Flibextra%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fjson.rs?ref=1a8a901f8696c35b86631ba01637bcafaf2614b1", "patch": "@@ -14,7 +14,211 @@\n #[forbid(non_camel_case_types)];\n #[allow(missing_doc)];\n \n-//! json parsing and serialization\n+/*!\n+JSON parsing and serialization\n+\n+# What is JSON?\n+\n+JSON (JavaScript Object Notation) is a way to write data in Javascript.\n+Like XML it allows one to encode structured data in a text format that can be read by humans easily.\n+Its native compatibility with JavaScript and its simple syntax make it used widely.\n+\n+Json data are encoded in a form of \"key\":\"value\".\n+Data types that can be encoded are JavaScript types :\n+boolean (`true` or `false`), number (`f64`), string, array, object, null.\n+An object is a series of string keys mapping to values, in `\"key\": value` format.\n+Arrays are enclosed in square brackets ([ ... ]) and objects in curly brackets ({ ... }).\n+A simple JSON document encoding a person, his/her age, address and phone numbers could look like:\n+\n+```\n+{\n+    \"FirstName\": \"John\",\n+    \"LastName\": \"Doe\",\n+    \"Age\": 43,\n+    \"Address\": {\n+        \"Street\": \"Downing Street 10\",\n+        \"City\": \"London\",\n+        \"Country\": \"Great Britain\"\n+    },\n+    \"PhoneNumbers\": [\n+        \"+44 1234567\",\n+        \"+44 2345678\"\n+    ]\n+}\n+```\n+\n+# Rust Type-based Encoding and Decoding\n+\n+Rust provides a mechanism for low boilerplate encoding & decoding\n+of values to and from JSON via the serialization API.\n+To be able to encode a piece of data, it must implement the `extra::serialize::Encodable` trait.\n+To be able to decode a piece of data, it must implement the `extra::serialize::Decodable` trait.\n+The Rust compiler provides an annotation to automatically generate\n+the code for these traits: `#[deriving(Decodable, Encodable)]`\n+\n+To encode using Encodable :\n+\n+```rust\n+use extra::json;\n+use std::io;\n+use extra::serialize::Encodable;\n+\n+ #[deriving(Encodable)]\n+ pub struct TestStruct   {\n+    data_str: ~str,\n+ }\n+\n+fn main() {\n+    let to_encode_object = TestStruct{data_str:~\"example of string to encode\"};\n+    let mut m = io::mem::MemWriter::new();\n+    {\n+        let mut encoder = json::Encoder::new(&mut m as &mut std::io::Writer);\n+        to_encode_object.encode(&mut encoder);\n+    }\n+}\n+```\n+\n+Two wrapper functions are provided to encode a Encodable object\n+into a string (~str) or buffer (~[u8]): `str_encode(&m)` and `buffer_encode(&m)`.\n+\n+```rust\n+use extra::json;\n+let to_encode_object = ~\"example of string to encode\";\n+let encoded_str: ~str = json::Encoder::str_encode(&to_encode_object);\n+```\n+\n+JSON API provide an enum `json::Json` and a trait `ToJson` to encode object.\n+The trait `ToJson` encode object into a container `json::Json` and the API provide writer\n+to encode them into a stream or a string ...\n+\n+When using `ToJson` the `Encodable` trait implementation is not mandatory.\n+\n+A basic `ToJson` example using a TreeMap of attribute name / attribute value:\n+\n+\n+```rust\n+use extra::json;\n+use extra::json::ToJson;\n+use extra::treemap::TreeMap;\n+\n+pub struct MyStruct  {\n+    attr1: u8,\n+    attr2: ~str,\n+}\n+\n+impl ToJson for MyStruct {\n+    fn to_json( &self ) -> json::Json {\n+        let mut d = ~TreeMap::new();\n+        d.insert(~\"attr1\", self.attr1.to_json());\n+        d.insert(~\"attr2\", self.attr2.to_json());\n+        json::Object(d)\n+    }\n+}\n+\n+fn main() {\n+    let test2: MyStruct = MyStruct {attr1: 1, attr2:~\"test\"};\n+    let tjson: json::Json = test2.to_json();\n+    let json_str: ~str = tjson.to_str();\n+}\n+```\n+\n+To decode a json string using `Decodable` trait :\n+\n+```rust\n+use extra::serialize::Decodable;\n+\n+#[deriving(Decodable)]\n+pub struct MyStruct  {\n+     attr1: u8,\n+     attr2: ~str,\n+}\n+\n+fn main() {\n+    let json_str_to_decode: ~str =\n+            ~\"{\\\"attr1\\\":1,\\\"attr2\\\":\\\"toto\\\"}\";\n+    let json_object = extra::json::from_str(json_str_to_decode);\n+    let mut decoder = extra::json::Decoder::new(json_object.unwrap());\n+    let decoded_object: MyStruct = Decodable::decode(&mut decoder); // create the final object\n+}\n+```\n+\n+# Examples of use\n+\n+## Using Autoserialization\n+\n+Create a struct called TestStruct1 and serialize and deserialize it to and from JSON\n+using the serialization API, using the derived serialization code.\n+\n+```rust\n+use extra::json;\n+use extra::serialize::{Encodable, Decodable};\n+\n+ #[deriving(Decodable, Encodable)] //generate Decodable, Encodable impl.\n+ pub struct TestStruct1  {\n+    data_int: u8,\n+    data_str: ~str,\n+    data_vector: ~[u8],\n+ }\n+\n+// To serialize use the `json::str_encode` to encode an object in a string.\n+// It calls the generated `Encodable` impl.\n+fn main() {\n+    let to_encode_object = TestStruct1\n+         {data_int: 1, data_str:~\"toto\", data_vector:~[2,3,4,5]};\n+    let encoded_str: ~str = json::Encoder::str_encode(&to_encode_object);\n+\n+    // To unserialize use the `extra::json::from_str` and `extra::json::Decoder`\n+\n+    let json_object = extra::json::from_str(encoded_str);\n+    let mut decoder = json::Decoder::new(json_object.unwrap());\n+    let decoded1: TestStruct1 = Decodable::decode(&mut decoder); // create the final object\n+}\n+```\n+\n+## Using `ToJson`\n+\n+This example use the ToJson impl to unserialize the json string.\n+Example of `ToJson` trait implementation for TestStruct1.\n+\n+```rust\n+use extra::json;\n+use extra::json::ToJson;\n+use extra::serialize::{Encodable, Decodable};\n+use extra::treemap::TreeMap;\n+\n+#[deriving(Decodable, Encodable)] // generate Decodable, Encodable impl.\n+pub struct TestStruct1  {\n+    data_int: u8,\n+    data_str: ~str,\n+    data_vector: ~[u8],\n+}\n+\n+impl ToJson for TestStruct1 {\n+    fn to_json( &self ) -> json::Json {\n+        let mut d = ~TreeMap::new();\n+        d.insert(~\"data_int\", self.data_int.to_json());\n+        d.insert(~\"data_str\", self.data_str.to_json());\n+        d.insert(~\"data_vector\", self.data_vector.to_json());\n+        json::Object(d)\n+    }\n+}\n+\n+fn main() {\n+    // Seralization using our impl of to_json\n+\n+    let test2: TestStruct1 = TestStruct1 {data_int: 1, data_str:~\"toto\", data_vector:~[2,3,4,5]};\n+    let tjson: json::Json = test2.to_json();\n+    let json_str: ~str = tjson.to_str();\n+\n+    // Unserialize like before.\n+\n+    let mut decoder = json::Decoder::new(json::from_str(json_str).unwrap());\n+    // create the final object\n+    let decoded2: TestStruct1 = Decodable::decode(&mut decoder);\n+}\n+```\n+\n+*/\n \n use std::char;\n use std::cast::transmute;\n@@ -93,6 +297,23 @@ impl<'a> Encoder<'a> {\n     pub fn new<'a>(wr: &'a mut io::Writer) -> Encoder<'a> {\n         Encoder { wr: wr }\n     }\n+\n+    /// Encode the specified struct into a json [u8]\n+    pub fn buffer_encode<T:Encodable<Encoder<'a>>>(to_encode_object: &T) -> ~[u8]  {\n+       //Serialize the object in a string using a writer\n+        let mut m = MemWriter::new();\n+        {\n+            let mut encoder = Encoder::new(&mut m as &mut io::Writer);\n+            to_encode_object.encode(&mut encoder);\n+        }\n+        m.inner()\n+    }\n+\n+    /// Encode the specified struct into a json str\n+    pub fn str_encode<T:Encodable<Encoder<'a>>>(to_encode_object: &T) -> ~str  {\n+        let buff:~[u8] = Encoder::buffer_encode(to_encode_object);\n+        str::from_utf8_owned(buff)\n+    }\n }\n \n impl<'a> serialize::Encoder for Encoder<'a> {"}]}