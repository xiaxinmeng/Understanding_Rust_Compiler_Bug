{"sha": "caed836e417a239ae1e384f7e977352b846a3804", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNhZWQ4MzZlNDE3YTIzOWFlMWUzODRmN2U5NzczNTJiODQ2YTM4MDQ=", "commit": {"author": {"name": "Edwin Cheng", "email": "edwin0cheng@gmail.com", "date": "2020-01-08T20:03:50Z"}, "committer": {"name": "Edwin Cheng", "email": "edwin0cheng@gmail.com", "date": "2020-01-12T12:25:58Z"}, "message": "Use first and last token only", "tree": {"sha": "a820c24381d7e9cf2d1eb3a5aa87c687ffb8ac35", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a820c24381d7e9cf2d1eb3a5aa87c687ffb8ac35"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/caed836e417a239ae1e384f7e977352b846a3804", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/caed836e417a239ae1e384f7e977352b846a3804", "html_url": "https://github.com/rust-lang/rust/commit/caed836e417a239ae1e384f7e977352b846a3804", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/caed836e417a239ae1e384f7e977352b846a3804/comments", "author": {"login": "edwin0cheng", "id": 11014119, "node_id": "MDQ6VXNlcjExMDE0MTE5", "avatar_url": "https://avatars.githubusercontent.com/u/11014119?v=4", "gravatar_id": "", "url": "https://api.github.com/users/edwin0cheng", "html_url": "https://github.com/edwin0cheng", "followers_url": "https://api.github.com/users/edwin0cheng/followers", "following_url": "https://api.github.com/users/edwin0cheng/following{/other_user}", "gists_url": "https://api.github.com/users/edwin0cheng/gists{/gist_id}", "starred_url": "https://api.github.com/users/edwin0cheng/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/edwin0cheng/subscriptions", "organizations_url": "https://api.github.com/users/edwin0cheng/orgs", "repos_url": "https://api.github.com/users/edwin0cheng/repos", "events_url": "https://api.github.com/users/edwin0cheng/events{/privacy}", "received_events_url": "https://api.github.com/users/edwin0cheng/received_events", "type": "User", "site_admin": false}, "committer": {"login": "edwin0cheng", "id": 11014119, "node_id": "MDQ6VXNlcjExMDE0MTE5", "avatar_url": "https://avatars.githubusercontent.com/u/11014119?v=4", "gravatar_id": "", "url": "https://api.github.com/users/edwin0cheng", "html_url": "https://github.com/edwin0cheng", "followers_url": "https://api.github.com/users/edwin0cheng/followers", "following_url": "https://api.github.com/users/edwin0cheng/following{/other_user}", "gists_url": "https://api.github.com/users/edwin0cheng/gists{/gist_id}", "starred_url": "https://api.github.com/users/edwin0cheng/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/edwin0cheng/subscriptions", "organizations_url": "https://api.github.com/users/edwin0cheng/orgs", "repos_url": "https://api.github.com/users/edwin0cheng/repos", "events_url": "https://api.github.com/users/edwin0cheng/events{/privacy}", "received_events_url": "https://api.github.com/users/edwin0cheng/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b30e6a7b56942f31cbd7b9fdb78925bf5b65b247", "url": "https://api.github.com/repos/rust-lang/rust/commits/b30e6a7b56942f31cbd7b9fdb78925bf5b65b247", "html_url": "https://github.com/rust-lang/rust/commit/b30e6a7b56942f31cbd7b9fdb78925bf5b65b247"}], "stats": {"total": 91, "additions": 56, "deletions": 35}, "files": [{"sha": "dc1a625edc27e6b197f40e2e4a13bf2ea7f0c914", "filename": "crates/ra_ide/src/extend_selection.rs", "status": "modified", "additions": 56, "deletions": 35, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/caed836e417a239ae1e384f7e977352b846a3804/crates%2Fra_ide%2Fsrc%2Fextend_selection.rs", "raw_url": "https://github.com/rust-lang/rust/raw/caed836e417a239ae1e384f7e977352b846a3804/crates%2Fra_ide%2Fsrc%2Fextend_selection.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fextend_selection.rs?ref=caed836e417a239ae1e384f7e977352b846a3804", "patch": "@@ -110,48 +110,69 @@ fn extend_tokens_from_range(\n     macro_call: ast::MacroCall,\n     original_range: TextRange,\n ) -> Option<TextRange> {\n-    // compute original mapped token range\n-    let mut expanded = None;\n-    let range = macro_call\n+    // Find all non-whitespace tokens under MacroCall\n+    let all_tokens: Vec<_> = macro_call\n         .syntax()\n         .descendants_with_tokens()\n-        .filter_map(|n| match n {\n-            NodeOrToken::Token(token) if token.text_range().is_subrange(&original_range) => {\n-                let node = descend_into_macros(db, file_id, token);\n-                match node.file_id {\n-                    it if it == file_id.into() => None,\n-                    it if expanded.is_none() || expanded == Some(it) => {\n-                        expanded = Some(it.into());\n-                        Some(node.value.text_range())\n-                    }\n-                    _ => None,\n-                }\n+        .filter_map(|n| {\n+            let token = n.as_token()?;\n+            if token.kind() == WHITESPACE {\n+                None\n+            } else {\n+                Some(token.clone())\n             }\n-            _ => None,\n         })\n-        .fold1(|x, y| union_range(x, y))?;\n-\n-    let expanded = expanded?;\n-    let src = db.parse_or_expand(expanded)?;\n-    let parent = shallowest_node(&find_covering_element(&src, range))?.parent()?;\n-    // compute parent mapped token range\n-    let range = macro_call\n-        .syntax()\n-        .descendants_with_tokens()\n-        .filter_map(|n| match n {\n-            NodeOrToken::Token(token) => {\n-                let node = descend_into_macros(db, file_id, token.clone());\n-                if node.file_id == expanded\n-                    && node.value.text_range().is_subrange(&parent.text_range())\n-                {\n-                    Some(token.text_range())\n+        .sorted_by(|a, b| Ord::cmp(&a.text_range().start(), &b.text_range().start()))\n+        .collect();\n+\n+    // Get all indices which is in original range\n+    let indices: Vec<_> =\n+        all_tokens\n+            .iter()\n+            .enumerate()\n+            .filter_map(|(i, token)| {\n+                if token.text_range().is_subrange(&original_range) {\n+                    Some(i)\n                 } else {\n                     None\n                 }\n-            }\n-            _ => None,\n-        })\n-        .fold1(|x, y| union_range(x, y))?;\n+            })\n+            .collect();\n+\n+    // Compute the first and last token index in original_range\n+    let first_idx = *indices.iter().min_by_key(|&&idx| all_tokens[idx].text_range().start())?;\n+    let last_idx = *indices.iter().max_by_key(|&&idx| all_tokens[idx].text_range().end())?;\n+\n+    // compute original mapped token range\n+    let expanded = {\n+        let first_node = descend_into_macros(db, file_id, all_tokens[first_idx].clone());\n+        let first_node = first_node.map(|it| it.text_range());\n+\n+        let last_node = descend_into_macros(db, file_id, all_tokens[last_idx].clone());\n+        if last_node.file_id == file_id.into() || first_node.file_id != last_node.file_id {\n+            return None;\n+        }\n+        first_node.map(|it| union_range(it, last_node.value.text_range()))\n+    };\n+\n+    // Compute parent node range\n+    let src = db.parse_or_expand(expanded.file_id)?;\n+    let parent = shallowest_node(&find_covering_element(&src, expanded.value))?.parent()?;\n+\n+    let validate = |&idx: &usize| {\n+        let token: &SyntaxToken = &all_tokens[idx];\n+        let node = descend_into_macros(db, file_id, token.clone());\n+\n+        node.file_id == expanded.file_id\n+            && node.value.text_range().is_subrange(&parent.text_range())\n+    };\n+\n+    // Find the first and last text range under expanded parent\n+    let first = (0..=first_idx).rev().take_while(validate).last()?;\n+    let last = (last_idx..all_tokens.len()).take_while(validate).last()?;\n+\n+    let range = union_range(all_tokens[first].text_range(), all_tokens[last].text_range());\n+\n     if original_range.is_subrange(&range) && original_range != range {\n         Some(range)\n     } else {"}]}