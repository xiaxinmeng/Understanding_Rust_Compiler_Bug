{"sha": "98d28b688c0279b5a05620db321ca2fde78a7954", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk4ZDI4YjY4OGMwMjc5YjVhMDU2MjBkYjMyMWNhMmZkZTc4YTc5NTQ=", "commit": {"author": {"name": "Scott Olson", "email": "scott@solson.me", "date": "2017-02-10T21:29:54Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2017-02-10T21:29:54Z"}, "message": "Merge pull request #139 from oli-obk/master\n\nlvalue references into fields of ValPair locals", "tree": {"sha": "9b9c2574652a83522e436ca30f5ba676a648510c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9b9c2574652a83522e436ca30f5ba676a648510c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/98d28b688c0279b5a05620db321ca2fde78a7954", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/98d28b688c0279b5a05620db321ca2fde78a7954", "html_url": "https://github.com/rust-lang/rust/commit/98d28b688c0279b5a05620db321ca2fde78a7954", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/98d28b688c0279b5a05620db321ca2fde78a7954/comments", "author": {"login": "solson", "id": 26806, "node_id": "MDQ6VXNlcjI2ODA2", "avatar_url": "https://avatars.githubusercontent.com/u/26806?v=4", "gravatar_id": "", "url": "https://api.github.com/users/solson", "html_url": "https://github.com/solson", "followers_url": "https://api.github.com/users/solson/followers", "following_url": "https://api.github.com/users/solson/following{/other_user}", "gists_url": "https://api.github.com/users/solson/gists{/gist_id}", "starred_url": "https://api.github.com/users/solson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/solson/subscriptions", "organizations_url": "https://api.github.com/users/solson/orgs", "repos_url": "https://api.github.com/users/solson/repos", "events_url": "https://api.github.com/users/solson/events{/privacy}", "received_events_url": "https://api.github.com/users/solson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e0d635929777c77baf1527efd8c03bf6eeb90f35", "url": "https://api.github.com/repos/rust-lang/rust/commits/e0d635929777c77baf1527efd8c03bf6eeb90f35", "html_url": "https://github.com/rust-lang/rust/commit/e0d635929777c77baf1527efd8c03bf6eeb90f35"}, {"sha": "35cf19f38a5aef8657b53f15b2df69c3a7080491", "url": "https://api.github.com/repos/rust-lang/rust/commits/35cf19f38a5aef8657b53f15b2df69c3a7080491", "html_url": "https://github.com/rust-lang/rust/commit/35cf19f38a5aef8657b53f15b2df69c3a7080491"}], "stats": {"total": 152, "additions": 109, "deletions": 43}, "files": [{"sha": "d2d33610f2841198617dae5f44b525c36d6d450f", "filename": "src/eval_context.rs", "status": "modified", "additions": 70, "deletions": 18, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/98d28b688c0279b5a05620db321ca2fde78a7954/src%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98d28b688c0279b5a05620db321ca2fde78a7954/src%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Feval_context.rs?ref=98d28b688c0279b5a05620db321ca2fde78a7954", "patch": "@@ -851,17 +851,26 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         lvalue: Lvalue<'tcx>,\n     ) -> EvalResult<'tcx, Lvalue<'tcx>> {\n         let new_lvalue = match lvalue {\n-            Lvalue::Local { frame, local } => {\n-                match self.stack[frame].get_local(local) {\n-                    Value::ByRef(ptr) => Lvalue::from_ptr(ptr),\n+            Lvalue::Local { frame, local, field } => {\n+                // -1 since we don't store the return value\n+                match self.stack[frame].locals[local.index() - 1] {\n+                    Value::ByRef(ptr) => {\n+                        assert!(field.is_none());\n+                        Lvalue::from_ptr(ptr)\n+                    },\n                     val => {\n                         let ty = self.stack[frame].mir.local_decls[local].ty;\n                         let ty = self.monomorphize(ty, self.stack[frame].substs);\n                         let substs = self.stack[frame].substs;\n                         let ptr = self.alloc_ptr_with_substs(ty, substs)?;\n-                        self.stack[frame].set_local(local, Value::ByRef(ptr));\n+                        self.stack[frame].locals[local.index() - 1] = Value::ByRef(ptr);\n                         self.write_value_to_ptr(val, ptr, ty)?;\n-                        Lvalue::from_ptr(ptr)\n+                        let lval = Lvalue::from_ptr(ptr);\n+                        if let Some((field, field_ty)) = field {\n+                            self.lvalue_field(lval, field, ty, field_ty)?\n+                        } else {\n+                            lval\n+                        }\n                     }\n                 }\n             }\n@@ -924,8 +933,8 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 let size = self.type_size(dest_ty)?.expect(\"dest type must be sized\");\n                 self.memory.write_primval(ptr, val, size)\n             }\n-            Lvalue::Local { frame, local } => {\n-                self.stack[frame].set_local(local, Value::ByVal(val));\n+            Lvalue::Local { frame, local, field } => {\n+                self.stack[frame].set_local(local, field.map(|(i, _)| i), Value::ByVal(val));\n                 Ok(())\n             }\n             Lvalue::Global(cid) => {\n@@ -966,11 +975,11 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 self.write_value_to_ptr(src_val, ptr, dest_ty)\n             }\n \n-            Lvalue::Local { frame, local } => {\n-                let dest = self.stack[frame].get_local(local);\n+            Lvalue::Local { frame, local, field } => {\n+                let dest = self.stack[frame].get_local(local, field.map(|(i, _)| i));\n                 self.write_value_possibly_by_val(\n                     src_val,\n-                    |this, val| this.stack[frame].set_local(local, val),\n+                    |this, val| this.stack[frame].set_local(local, field.map(|(i, _)| i), val),\n                     dest,\n                     dest_ty,\n                 )\n@@ -1355,16 +1364,19 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n     }\n \n     pub(super) fn dump_local(&self, lvalue: Lvalue<'tcx>) {\n-        if let Lvalue::Local { frame, local } = lvalue {\n+        if let Lvalue::Local { frame, local, field } = lvalue {\n             let mut allocs = Vec::new();\n             let mut msg = format!(\"{:?}\", local);\n+            if let Some((field, _)) = field {\n+                write!(msg, \".{}\", field).unwrap();\n+            }\n             let last_frame = self.stack.len() - 1;\n             if frame != last_frame {\n                 write!(msg, \" ({} frames up)\", last_frame - frame).unwrap();\n             }\n             write!(msg, \":\").unwrap();\n \n-            match self.stack[frame].get_local(local) {\n+            match self.stack[frame].get_local(local, field.map(|(i, _)| i)) {\n                 Value::ByRef(ptr) => {\n                     allocs.push(ptr.alloc_id);\n                 }\n@@ -1402,13 +1414,14 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         &mut self,\n         frame: usize,\n         local: mir::Local,\n+        field: Option<usize>,\n         f: F,\n     ) -> EvalResult<'tcx>\n         where F: FnOnce(&mut Self, Value) -> EvalResult<'tcx, Value>,\n     {\n-        let val = self.stack[frame].get_local(local);\n+        let val = self.stack[frame].get_local(local, field);\n         let new_val = f(self, val)?;\n-        self.stack[frame].set_local(local, new_val);\n+        self.stack[frame].set_local(local, field, new_val);\n         // FIXME(solson): Run this when setting to Undef? (See previous version of this code.)\n         // if let Value::ByRef(ptr) = self.stack[frame].get_local(local) {\n         //     self.memory.deallocate(ptr)?;\n@@ -1418,14 +1431,53 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n }\n \n impl<'tcx> Frame<'tcx> {\n-    pub fn get_local(&self, local: mir::Local) -> Value {\n+    pub fn get_local(&self, local: mir::Local, field: Option<usize>) -> Value {\n         // Subtract 1 because we don't store a value for the ReturnPointer, the local with index 0.\n-        self.locals[local.index() - 1]\n+        if let Some(field) = field {\n+            match self.locals[local.index() - 1] {\n+                Value::ByRef(_) => bug!(\"can't have lvalue fields for ByRef\"),\n+                val @ Value::ByVal(_) => {\n+                    assert_eq!(field, 0);\n+                    val\n+                },\n+                Value::ByValPair(a, b) => {\n+                    match field {\n+                        0 => Value::ByVal(a),\n+                        1 => Value::ByVal(b),\n+                        _ => bug!(\"ByValPair has only two fields, tried to access {}\", field),\n+                    }\n+                },\n+            }\n+        } else {\n+            self.locals[local.index() - 1]\n+        }\n     }\n \n-    fn set_local(&mut self, local: mir::Local, value: Value) {\n+    fn set_local(&mut self, local: mir::Local, field: Option<usize>, value: Value) {\n         // Subtract 1 because we don't store a value for the ReturnPointer, the local with index 0.\n-        self.locals[local.index() - 1] = value;\n+        if let Some(field) = field {\n+            match self.locals[local.index() - 1] {\n+                Value::ByRef(_) => bug!(\"can't have lvalue fields for ByRef\"),\n+                Value::ByVal(_) => {\n+                    assert_eq!(field, 0);\n+                    self.set_local(local, None, value);\n+                },\n+                Value::ByValPair(a, b) => {\n+                    let prim = match value {\n+                        Value::ByRef(_) => bug!(\"can't set ValPair field to ByRef\"),\n+                        Value::ByVal(val) => val,\n+                        Value::ByValPair(_, _) => bug!(\"can't set ValPair field to ValPair\"),\n+                    };\n+                    match field {\n+                        0 => self.set_local(local, None, Value::ByValPair(prim, b)),\n+                        1 => self.set_local(local, None, Value::ByValPair(a, prim)),\n+                        _ => bug!(\"ByValPair has only two fields, tried to access {}\", field),\n+                    }\n+                },\n+            }\n+        } else {\n+            self.locals[local.index() - 1] = value;\n+        }\n     }\n }\n "}, {"sha": "f3f8c3fde0cc4859be1a380b9bf024697431fa89", "filename": "src/lvalue.rs", "status": "modified", "additions": 37, "deletions": 23, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/98d28b688c0279b5a05620db321ca2fde78a7954/src%2Flvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98d28b688c0279b5a05620db321ca2fde78a7954/src%2Flvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flvalue.rs?ref=98d28b688c0279b5a05620db321ca2fde78a7954", "patch": "@@ -23,6 +23,8 @@ pub enum Lvalue<'tcx> {\n     Local {\n         frame: usize,\n         local: mir::Local,\n+        /// Optionally, this lvalue can point to a field of the stack value\n+        field: Option<(usize, Ty<'tcx>)>,\n     },\n \n     /// An lvalue referring to a global\n@@ -114,16 +116,6 @@ impl<'tcx> Global<'tcx> {\n \n impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n     pub(super) fn eval_and_read_lvalue(&mut self, lvalue: &mir::Lvalue<'tcx>) -> EvalResult<'tcx, Value> {\n-        if let mir::Lvalue::Projection(ref proj) = *lvalue {\n-            if let mir::Lvalue::Local(index) = proj.base {\n-                if let Value::ByValPair(a, b) = self.frame().get_local(index) {\n-                    if let mir::ProjectionElem::Field(ref field, _) = proj.elem {\n-                        let val = [a, b][field.index()];\n-                        return Ok(Value::ByVal(val));\n-                    }\n-                }\n-            }\n-        }\n         let lvalue = self.eval_lvalue(lvalue)?;\n         Ok(self.read_lvalue(lvalue))\n     }\n@@ -134,7 +126,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 assert_eq!(extra, LvalueExtra::None);\n                 Value::ByRef(ptr)\n             }\n-            Lvalue::Local { frame, local } => self.stack[frame].get_local(local),\n+            Lvalue::Local { frame, local, field } => self.stack[frame].get_local(local, field.map(|(i, _)| i)),\n             Lvalue::Global(cid) => self.globals.get(&cid).expect(\"global not cached\").value,\n         }\n     }\n@@ -143,7 +135,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         use rustc::mir::Lvalue::*;\n         let lvalue = match *mir_lvalue {\n             Local(mir::RETURN_POINTER) => self.frame().return_lvalue,\n-            Local(local) => Lvalue::Local { frame: self.stack.len() - 1, local },\n+            Local(local) => Lvalue::Local { frame: self.stack.len() - 1, local, field: None },\n \n             Static(def_id) => {\n                 let substs = self.tcx.intern_substs(&[]);\n@@ -163,45 +155,41 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n     pub fn lvalue_field(\n         &mut self,\n         base: Lvalue<'tcx>,\n-        field: usize,\n+        field_index: usize,\n         base_ty: Ty<'tcx>,\n         field_ty: Ty<'tcx>,\n     ) -> EvalResult<'tcx, Lvalue<'tcx>> {\n         let base_layout = self.type_layout(base_ty)?;\n-        // FIXME(solson)\n-        let base = self.force_allocation(base)?;\n-        let (base_ptr, base_extra) = base.to_ptr_and_extra();\n-\n-        let field_ty = self.monomorphize(field_ty, self.substs());\n \n         use rustc::ty::layout::Layout::*;\n         let (offset, packed) = match *base_layout {\n             Univariant { ref variant, .. } => {\n-                (variant.offsets[field], variant.packed)\n+                (variant.offsets[field_index], variant.packed)\n             },\n \n             General { ref variants, .. } => {\n+                let (_, base_extra) = base.to_ptr_and_extra();\n                 if let LvalueExtra::DowncastVariant(variant_idx) = base_extra {\n                     // +1 for the discriminant, which is field 0\n-                    (variants[variant_idx].offsets[field + 1], variants[variant_idx].packed)\n+                    (variants[variant_idx].offsets[field_index + 1], variants[variant_idx].packed)\n                 } else {\n                     bug!(\"field access on enum had no variant index\");\n                 }\n             }\n \n             RawNullablePointer { .. } => {\n-                assert_eq!(field, 0);\n+                assert_eq!(field_index, 0);\n                 return Ok(base);\n             }\n \n             StructWrappedNullablePointer { ref nonnull, .. } => {\n-                (nonnull.offsets[field], nonnull.packed)\n+                (nonnull.offsets[field_index], nonnull.packed)\n             }\n \n             UntaggedUnion { .. } => return Ok(base),\n \n             Vector { element, count } => {\n-                let field = field as u64;\n+                let field = field_index as u64;\n                 assert!(field < count);\n                 let elem_size = element.size(&self.tcx.data_layout).bytes();\n                 (Size::from_bytes(field * elem_size), false)\n@@ -210,6 +198,30 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             _ => bug!(\"field access on non-product type: {:?}\", base_layout),\n         };\n \n+        let (base_ptr, base_extra) = match base {\n+            Lvalue::Ptr { ptr, extra } => (ptr, extra),\n+            Lvalue::Local { frame, local, field } => match self.stack[frame].get_local(local, field.map(|(i, _)| i)) {\n+                Value::ByRef(ptr) => {\n+                    assert!(field.is_none(), \"local can't be ByRef and have a field offset\");\n+                    (ptr, LvalueExtra::None)\n+                },\n+                Value::ByVal(_) => {\n+                    assert_eq!(offset.bytes(), 0, \"ByVal can only have 1 non zst field with offset 0\");\n+                    return Ok(base);\n+                },\n+                Value::ByValPair(_, _) => {\n+                    assert!(field_index < 2);\n+                    return Ok(Lvalue::Local {\n+                        frame,\n+                        local,\n+                        field: Some((field_index, field_ty)),\n+                    });\n+                },\n+            },\n+            // FIXME: do for globals what we did for locals\n+            Lvalue::Global(_) => self.force_allocation(base)?.to_ptr_and_extra(),\n+        };\n+\n         let offset = match base_extra {\n             LvalueExtra::Vtable(tab) => {\n                 let (_, align) = self.size_and_align_of_dst(base_ty, Value::ByValPair(PrimVal::Ptr(base_ptr), PrimVal::Ptr(tab)))?;\n@@ -220,6 +232,8 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n         let ptr = base_ptr.offset(offset);\n \n+        let field_ty = self.monomorphize(field_ty, self.substs());\n+\n         if packed {\n             let size = self.type_size(field_ty)?.expect(\"packed struct must be sized\");\n             self.memory.mark_packed(ptr, size);"}, {"sha": "c6e33b0a08e7986014ebb289f3b0ca9f3ca07d93", "filename": "src/terminator/intrinsic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/98d28b688c0279b5a05620db321ca2fde78a7954/src%2Fterminator%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98d28b688c0279b5a05620db321ca2fde78a7954/src%2Fterminator%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fterminator%2Fintrinsic.rs?ref=98d28b688c0279b5a05620db321ca2fde78a7954", "patch": "@@ -262,7 +262,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     Ok(zero_val)\n                 };\n                 match dest {\n-                    Lvalue::Local { frame, local } => self.modify_local(frame, local, init)?,\n+                    Lvalue::Local { frame, local, field } => self.modify_local(frame, local, field.map(|(i, _)| i), init)?,\n                     Lvalue::Ptr { ptr, extra: LvalueExtra::None } => self.memory.write_repeat(ptr, 0, size)?,\n                     Lvalue::Ptr { .. } => bug!(\"init intrinsic tried to write to fat ptr target\"),\n                     Lvalue::Global(cid) => self.modify_global(cid, init)?,\n@@ -394,7 +394,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     }\n                 };\n                 match dest {\n-                    Lvalue::Local { frame, local } => self.modify_local(frame, local, uninit)?,\n+                    Lvalue::Local { frame, local, field } => self.modify_local(frame, local, field.map(|(i, _)| i), uninit)?,\n                     Lvalue::Ptr { ptr, extra: LvalueExtra::None } =>\n                         self.memory.mark_definedness(ptr, size, false)?,\n                     Lvalue::Ptr { .. } => bug!(\"uninit intrinsic tried to write to fat ptr target\"),"}]}