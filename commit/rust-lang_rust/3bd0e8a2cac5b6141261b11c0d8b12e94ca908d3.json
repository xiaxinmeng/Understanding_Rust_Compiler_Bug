{"sha": "3bd0e8a2cac5b6141261b11c0d8b12e94ca908d3", "node_id": "C_kwDOAAsO6NoAKDNiZDBlOGEyY2FjNWI2MTQxMjYxYjExYzBkOGIxMmU5NGNhOTA4ZDM", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-07-04T18:53:54Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-07-13T22:07:33Z"}, "message": "move checking ptr tracking on item pop into cold helper function", "tree": {"sha": "eff00228856f1f0150cc78c7157bf9cd3a733e66", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/eff00228856f1f0150cc78c7157bf9cd3a733e66"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3bd0e8a2cac5b6141261b11c0d8b12e94ca908d3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3bd0e8a2cac5b6141261b11c0d8b12e94ca908d3", "html_url": "https://github.com/rust-lang/rust/commit/3bd0e8a2cac5b6141261b11c0d8b12e94ca908d3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3bd0e8a2cac5b6141261b11c0d8b12e94ca908d3/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4e9de3117458aa5b7e249e1aaa2e3757eaad7834", "url": "https://api.github.com/repos/rust-lang/rust/commits/4e9de3117458aa5b7e249e1aaa2e3757eaad7834", "html_url": "https://github.com/rust-lang/rust/commit/4e9de3117458aa5b7e249e1aaa2e3757eaad7834"}], "stats": {"total": 101, "additions": 62, "deletions": 39}, "files": [{"sha": "d9ccc773a01814dd1a1893a2fa64a0c496292e0c", "filename": "src/stacked_borrows.rs", "status": "modified", "additions": 62, "deletions": 39, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/3bd0e8a2cac5b6141261b11c0d8b12e94ca908d3/src%2Fstacked_borrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bd0e8a2cac5b6141261b11c0d8b12e94ca908d3/src%2Fstacked_borrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstacked_borrows.rs?ref=3bd0e8a2cac5b6141261b11c0d8b12e94ca908d3", "patch": "@@ -316,11 +316,22 @@ impl<'tcx> Stack {\n         alloc_history: &mut AllocHistory,\n         threads: &ThreadManager<'_, 'tcx>,\n     ) -> InterpResult<'tcx> {\n-        if global.tracked_pointer_tags.contains(&item.tag()) {\n-            register_diagnostic(NonHaltingDiagnostic::PoppedPointerTag(\n-                *item,\n-                provoking_access.map(|(tag, _alloc_range, _size, access)| (tag, access)),\n-            ));\n+        if !global.tracked_pointer_tags.is_empty() {\n+            check_tracked(item, &provoking_access, global);\n+\n+            #[inline(never)] // cold path\n+            fn check_tracked(\n+                item: &Item,\n+                provoking_access: &Option<(SbTagExtra, AllocRange, Size, AccessKind)>,\n+                global: &GlobalStateInner,\n+            ) {\n+                if global.tracked_pointer_tags.contains(&item.tag()) {\n+                    register_diagnostic(NonHaltingDiagnostic::PoppedPointerTag(\n+                        *item,\n+                        provoking_access.map(|(tag, _alloc_range, _size, access)| (tag, access)),\n+                    ));\n+                }\n+            }\n         }\n \n         if !item.protected() {\n@@ -341,40 +352,52 @@ impl<'tcx> Stack {\n         //    which ends up about linear in the number of protected tags in the program into a\n         //    constant time check (and a slow linear, because the tags in the frames aren't contiguous).\n         if global.protected_tags.contains(&item.tag()) {\n-            // This path is cold because it is fatal to the program. So here it is fine to do the\n-            // more expensive search to figure out which call is responsible for protecting this\n-            // tag.\n-            let call_id = threads\n-                .all_stacks()\n-                .flatten()\n-                .map(|frame| {\n-                    frame\n-                        .extra\n-                        .stacked_borrows\n-                        .as_ref()\n-                        .expect(\"we should have Stacked Borrows data\")\n-                })\n-                .find(|frame| frame.protected_tags.contains(&item.tag()))\n-                .map(|frame| frame.call_id)\n-                .unwrap(); // FIXME: Surely we should find something, but a panic seems wrong here?\n-            if let Some((tag, _alloc_range, _offset, _access)) = provoking_access {\n-                Err(err_sb_ub(\n-                    format!(\n-                        \"not granting access to tag {:?} because incompatible item {:?} is protected by call {:?}\",\n-                        tag, item, call_id\n-                    ),\n-                    None,\n-                    tag.and_then(|tag| alloc_history.get_logs_relevant_to(tag, Some(item.tag()))),\n-                ))?\n-            } else {\n-                Err(err_sb_ub(\n-                    format!(\n-                        \"deallocating while item {:?} is protected by call {:?}\",\n-                        item, call_id\n-                    ),\n-                    None,\n-                    None,\n-                ))?\n+            return Err(protector_error(item, &provoking_access, alloc_history, threads));\n+\n+            #[inline(never)] // cold path\n+            fn protector_error<'tcx>(\n+                item: &Item,\n+                provoking_access: &Option<(SbTagExtra, AllocRange, Size, AccessKind)>,\n+                alloc_history: &mut AllocHistory,\n+                threads: &ThreadManager<'_, 'tcx>,\n+            ) -> InterpErrorInfo<'tcx> {\n+                // This path is cold because it is fatal to the program. So here it is fine to do the\n+                // more expensive search to figure out which call is responsible for protecting this\n+                // tag.\n+                let call_id = threads\n+                    .all_stacks()\n+                    .flatten()\n+                    .map(|frame| {\n+                        frame\n+                            .extra\n+                            .stacked_borrows\n+                            .as_ref()\n+                            .expect(\"we should have Stacked Borrows data\")\n+                    })\n+                    .find(|frame| frame.protected_tags.contains(&item.tag()))\n+                    .map(|frame| frame.call_id)\n+                    .unwrap(); // FIXME: Surely we should find something, but a panic seems wrong here?\n+                if let Some((tag, _alloc_range, _offset, _access)) = provoking_access {\n+                    err_sb_ub(\n+                        format!(\n+                            \"not granting access to tag {:?} because incompatible item {:?} is protected by call {:?}\",\n+                            tag, item, call_id\n+                        ),\n+                        None,\n+                        tag.and_then(|tag| {\n+                            alloc_history.get_logs_relevant_to(tag, Some(item.tag()))\n+                        }),\n+                    )\n+                } else {\n+                    err_sb_ub(\n+                        format!(\n+                            \"deallocating while item {:?} is protected by call {:?}\",\n+                            item, call_id\n+                        ),\n+                        None,\n+                        None,\n+                    )\n+                }.into()\n             }\n         }\n         Ok(())"}]}