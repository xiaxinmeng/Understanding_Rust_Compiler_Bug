{"sha": "8787090964e33cd633671025d9acf20dfeaf8765", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg3ODcwOTA5NjRlMzNjZDYzMzY3MTAyNWQ5YWNmMjBkZmVhZjg3NjU=", "commit": {"author": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2020-07-02T20:45:28Z"}, "committer": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2020-10-06T10:19:31Z"}, "message": "Address review comments", "tree": {"sha": "cc0105e7b07ba2da7a859962ec29e48b7e16f08d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cc0105e7b07ba2da7a859962ec29e48b7e16f08d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8787090964e33cd633671025d9acf20dfeaf8765", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8787090964e33cd633671025d9acf20dfeaf8765", "html_url": "https://github.com/rust-lang/rust/commit/8787090964e33cd633671025d9acf20dfeaf8765", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8787090964e33cd633671025d9acf20dfeaf8765/comments", "author": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "21eccbb587d7e9cff6fc6ebbd2a8844e8993fee4", "url": "https://api.github.com/repos/rust-lang/rust/commits/21eccbb587d7e9cff6fc6ebbd2a8844e8993fee4", "html_url": "https://github.com/rust-lang/rust/commit/21eccbb587d7e9cff6fc6ebbd2a8844e8993fee4"}], "stats": {"total": 77, "additions": 69, "deletions": 8}, "files": [{"sha": "808a0793a94f4f848a596a708806ba99ba6a0a71", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 20, "deletions": 4, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/8787090964e33cd633671025d9acf20dfeaf8765/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8787090964e33cd633671025d9acf20dfeaf8765/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=8787090964e33cd633671025d9acf20dfeaf8765", "patch": "@@ -159,21 +159,37 @@ rustc_queries! {\n         /// Returns the list of bounds that can be used for\n         /// `SelectionCandidate::ProjectionCandidate` and\n         /// `ProjectionTyCandidate::TraitDef`.\n-        /// Specifically this is the bounds (equivalent to) those\n-        /// written on the trait's type definition, or those\n-        /// after the `impl` keyword\n+        /// Specifically this is the bounds written on the trait's type\n+        /// definition, or those after the `impl` keyword\n         ///\n         /// type X: Bound + 'lt\n         ///         ^^^^^^^^^^^\n         /// impl Debug + Display\n         ///      ^^^^^^^^^^^^^^^\n         ///\n         /// `key` is the `DefId` of the associated type or opaque type.\n+        ///\n+        /// Bounds from the parent (e.g. with nested impl trait) are not included.\n         query explicit_item_bounds(key: DefId) -> &'tcx [(ty::Predicate<'tcx>, Span)] {\n             desc { |tcx| \"finding item bounds for `{}`\", tcx.def_path_str(key) }\n         }\n \n-        /// Elaborated the predicates from `explicit_item_bounds`.\n+        /// Elaborated version of the predicates from `explicit_item_bounds`.\n+        ///\n+        /// Example for\n+        ///\n+        /// trait MyTrait {\n+        ///     type MyAType: Eq + ?Sized`\n+        /// }\n+        ///\n+        /// `explicit_item_bounds` returns `[<Self as MyTrait>::MyAType: Eq]`,\n+        /// and `item_bounds` returns\n+        /// [\n+        ///     <Self as Trait>::MyAType: Eq,\n+        ///     <Self as Trait>::MyAType: PartialEq<<Self as Trait>::MyAType>\n+        /// ]\n+        ///\n+        /// Bounds from the parent (e.g. with nested impl trait) are not included.\n         query item_bounds(key: DefId) -> &'tcx ty::List<ty::Predicate<'tcx>> {\n             desc { |tcx| \"elaborating item bounds for `{}`\", tcx.def_path_str(key) }\n         }"}, {"sha": "af90bc80d4d987abc428f6eb50dc854bd0037c4c", "filename": "compiler/rustc_trait_selection/src/traits/select/mod.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8787090964e33cd633671025d9acf20dfeaf8765/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8787090964e33cd633671025d9acf20dfeaf8765/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs?ref=8787090964e33cd633671025d9acf20dfeaf8765", "patch": "@@ -1156,6 +1156,11 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         self.infcx.selection_cache.insert(param_env.and(trait_ref), dep_node, candidate);\n     }\n \n+    /// Matches a predicate against the bounds of its self type.\n+    ///\n+    /// Given an obligation like `<T as Foo>::Bar: Baz` where the self type is\n+    /// a projection, look at the bounds of `T::Bar`, see if we can find a\n+    /// `Baz` bound and it there is one it returns it.\n     fn match_projection_obligation_against_definition_bounds(\n         &mut self,\n         obligation: &TraitObligation<'tcx>,"}, {"sha": "0a4ce34c7f8e00c80e98bb041bcb716198a6e248", "filename": "compiler/rustc_trait_selection/src/traits/util.rs", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/8787090964e33cd633671025d9acf20dfeaf8765/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8787090964e33cd633671025d9acf20dfeaf8765/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Futil.rs?ref=8787090964e33cd633671025d9acf20dfeaf8765", "patch": "@@ -6,7 +6,7 @@ use smallvec::SmallVec;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_hir::def_id::DefId;\n use rustc_middle::ty::subst::{GenericArg, Subst, SubstsRef};\n-use rustc_middle::ty::{self, ToPredicate, Ty, TyCtxt, WithConstness};\n+use rustc_middle::ty::{self, ToPredicate, Ty, TyCtxt, TypeFoldable, WithConstness};\n \n use super::{Normalized, Obligation, ObligationCause, PredicateObligation, SelectionContext};\n pub use rustc_infer::traits::util::*;\n@@ -365,14 +365,24 @@ pub fn impl_item_is_final(tcx: TyCtxt<'_>, assoc_item: &ty::AssocItem) -> bool {\n /// trait X<A> { type Y<'a>: PartialEq<A> }\n ///\n /// Say that we know that `<() as X<B>>::Y<'c> = i32` and we need to check that\n-/// the `PartialEq` bound applies. This function would return\n-/// `i32: PartialEq<B>`.\n+/// the `PartialEq` bound applies. We would then call this function with:\n+///\n+/// - `bound` = `<Self as X<A>>::Y<'a>: PartialEq`\n+/// - `normalized_projection_ty` = `i32`\n+/// - `assoc_item_substs` = `[(), B, 'c]`\n+///\n+/// This method would then return `i32: PartialEq<B>`.\n pub fn subst_assoc_item_bound<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     bound: ty::Predicate<'tcx>,\n     normalized_projection_ty: Ty<'tcx>,\n     assoc_item_substs: &[GenericArg<'tcx>],\n ) -> ty::Predicate<'tcx> {\n+    // We're substituting these inside the closure passed to map_bound, so they\n+    // can't have escaping bound regions.\n+    assert!(!normalized_projection_ty.has_escaping_bound_vars());\n+    assert!(!assoc_item_substs.iter().all(|arg| arg.has_escaping_bound_vars()));\n+\n     let translate_predicate_substs = move |predicate_substs: SubstsRef<'tcx>| {\n         tcx.mk_substs(\n             iter::once(normalized_projection_ty.into())"}, {"sha": "df816bbd34810c69765db38654f54d51855c3978", "filename": "compiler/rustc_trait_selection/src/traits/wf.rs", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/8787090964e33cd633671025d9acf20dfeaf8765/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8787090964e33cd633671025d9acf20dfeaf8765/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs?ref=8787090964e33cd633671025d9acf20dfeaf8765", "patch": "@@ -337,8 +337,26 @@ impl<'a, 'tcx> WfPredicates<'a, 'tcx> {\n     /// into `self.out`.\n     fn compute_projection(&mut self, data: ty::ProjectionTy<'tcx>) {\n         // A projection is well-formed if\n-        // (a) its predicates hold\n+        //\n+        // (a) its predicates hold (*)\n         // (b) its substs are wf\n+        //\n+        // (*) The predicates of an associated type include the predicates of\n+        //     the trait that it's contained in. For example, given\n+        //\n+        // trait A<T>: Clone {\n+        //     type X where T: Copy;\n+        // }\n+        //\n+        // The predicates of `<() as A<i32>>::X` are:\n+        // [\n+        //     `(): Sized`\n+        //     `(): Clone`\n+        //     `(): A<i32>`\n+        //     `i32: Sized`\n+        //     `i32: Clone`\n+        //     `i32: Copy`\n+        // ]\n         let obligations = self.nominal_obligations(data.item_def_id, data.substs);\n         self.out.extend(obligations);\n "}, {"sha": "fbb19617c7fcf1716927f83613bd2ca035130053", "filename": "compiler/rustc_typeck/src/check/check.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8787090964e33cd633671025d9acf20dfeaf8765/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8787090964e33cd633671025d9acf20dfeaf8765/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs?ref=8787090964e33cd633671025d9acf20dfeaf8765", "patch": "@@ -524,6 +524,18 @@ pub(super) fn check_opaque_for_cycles<'tcx>(\n }\n \n /// Check that the concrete type behind `impl Trait` actually implements `Trait`.\n+///\n+/// This is mostly checked at the places that specify the opaque type, but we\n+/// check those cases in the `param_env` of that function, which may have\n+/// bounds not on this opaque type:\n+///\n+/// type X<T> = impl Clone\n+/// fn f<T: Clone>(t: T) -> X<T> {\n+///     t\n+/// }\n+///\n+/// Without this check the above code is incorrectly accepted: we would ICE if\n+/// some tried, for example, to clone an `Option<X<&mut ()>>`.\n fn check_opaque_meets_bounds<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     def_id: LocalDefId,"}]}