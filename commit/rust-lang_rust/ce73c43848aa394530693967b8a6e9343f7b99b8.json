{"sha": "ce73c43848aa394530693967b8a6e9343f7b99b8", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNlNzNjNDM4NDhhYTM5NDUzMDY5Mzk2N2I4YTZlOTM0M2Y3Yjk5Yjg=", "commit": {"author": {"name": "veetaha", "email": "veetaha2@gmail.com", "date": "2020-03-21T21:30:33Z"}, "committer": {"name": "veetaha", "email": "veetaha2@gmail.com", "date": "2020-03-21T21:37:15Z"}, "message": "ra_cargo_watch: return Result<> from run_cargo(), and don't read stderr for now\n\nAs stated by matklad, reading the stderr\nshould be done alngside with\nstdout via select() (or I guess poll()),\nthere is no such implementation in stdlib,\nsince it is quite low level and platform-dependent and it\nalso requires quite a bit of unrelated code we don't use it for now.\n\nAs referenced by bjorn3, there is an implementation of the needed read2() function\nin rustc compiletest. The better solution will be to extract this function\nto a separate crate in future:\nhttps://github.com/rust-analyzer/rust-analyzer/pull/3632#discussion_r395605298", "tree": {"sha": "afc49f519ddabc5218565bde517ff6fe800e7aa0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/afc49f519ddabc5218565bde517ff6fe800e7aa0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ce73c43848aa394530693967b8a6e9343f7b99b8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ce73c43848aa394530693967b8a6e9343f7b99b8", "html_url": "https://github.com/rust-lang/rust/commit/ce73c43848aa394530693967b8a6e9343f7b99b8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ce73c43848aa394530693967b8a6e9343f7b99b8/comments", "author": {"login": "Veetaha", "id": 36276403, "node_id": "MDQ6VXNlcjM2Mjc2NDAz", "avatar_url": "https://avatars.githubusercontent.com/u/36276403?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veetaha", "html_url": "https://github.com/Veetaha", "followers_url": "https://api.github.com/users/Veetaha/followers", "following_url": "https://api.github.com/users/Veetaha/following{/other_user}", "gists_url": "https://api.github.com/users/Veetaha/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veetaha/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veetaha/subscriptions", "organizations_url": "https://api.github.com/users/Veetaha/orgs", "repos_url": "https://api.github.com/users/Veetaha/repos", "events_url": "https://api.github.com/users/Veetaha/events{/privacy}", "received_events_url": "https://api.github.com/users/Veetaha/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veetaha", "id": 36276403, "node_id": "MDQ6VXNlcjM2Mjc2NDAz", "avatar_url": "https://avatars.githubusercontent.com/u/36276403?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veetaha", "html_url": "https://github.com/Veetaha", "followers_url": "https://api.github.com/users/Veetaha/followers", "following_url": "https://api.github.com/users/Veetaha/following{/other_user}", "gists_url": "https://api.github.com/users/Veetaha/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veetaha/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veetaha/subscriptions", "organizations_url": "https://api.github.com/users/Veetaha/orgs", "repos_url": "https://api.github.com/users/Veetaha/repos", "events_url": "https://api.github.com/users/Veetaha/events{/privacy}", "received_events_url": "https://api.github.com/users/Veetaha/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "59ba386bee974b56b546eb7e8fdec6721ab0d08a", "url": "https://api.github.com/repos/rust-lang/rust/commits/59ba386bee974b56b546eb7e8fdec6721ab0d08a", "html_url": "https://github.com/rust-lang/rust/commit/59ba386bee974b56b546eb7e8fdec6721ab0d08a"}], "stats": {"total": 105, "additions": 56, "deletions": 49}, "files": [{"sha": "35b0cb608d6cbeb75fae526321cd1525933b7a24", "filename": "crates/ra_cargo_watch/src/lib.rs", "status": "modified", "additions": 43, "deletions": 35, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/ce73c43848aa394530693967b8a6e9343f7b99b8/crates%2Fra_cargo_watch%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce73c43848aa394530693967b8a6e9343f7b99b8/crates%2Fra_cargo_watch%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_cargo_watch%2Fsrc%2Flib.rs?ref=ce73c43848aa394530693967b8a6e9343f7b99b8", "patch": "@@ -8,9 +8,10 @@ use lsp_types::{\n     WorkDoneProgressEnd, WorkDoneProgressReport,\n };\n use std::{\n+    error, fmt,\n     io::{BufRead, BufReader},\n     path::{Path, PathBuf},\n-    process::{Child, Command, Stdio},\n+    process::{Command, Stdio},\n     thread::JoinHandle,\n     time::Instant,\n };\n@@ -70,10 +71,10 @@ impl std::ops::Drop for CheckWatcher {\n     fn drop(&mut self) {\n         if let Some(handle) = self.handle.take() {\n             // Take the sender out of the option\n-            let recv = self.cmd_send.take();\n+            let cmd_send = self.cmd_send.take();\n \n             // Dropping the sender finishes the thread loop\n-            drop(recv);\n+            drop(cmd_send);\n \n             // Join the thread, it should finish shortly. We don't really care\n             // whether it panicked, so it is safe to ignore the result\n@@ -246,11 +247,21 @@ enum CheckEvent {\n     End,\n }\n \n+#[derive(Debug)]\n+pub struct CargoError(String);\n+\n+impl fmt::Display for CargoError {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"Cargo failed: {}\", self.0)\n+    }\n+}\n+impl error::Error for CargoError {}\n+\n pub fn run_cargo(\n     args: &[String],\n     current_dir: Option<&Path>,\n     on_message: &mut dyn FnMut(cargo_metadata::Message) -> bool,\n-) -> Child {\n+) -> Result<(), CargoError> {\n     let mut command = Command::new(\"cargo\");\n     if let Some(current_dir) = current_dir {\n         command.current_dir(current_dir);\n@@ -259,7 +270,7 @@ pub fn run_cargo(\n     let mut child = command\n         .args(args)\n         .stdout(Stdio::piped())\n-        .stderr(Stdio::piped())\n+        .stderr(Stdio::null())\n         .stdin(Stdio::null())\n         .spawn()\n         .expect(\"couldn't launch cargo\");\n@@ -273,6 +284,8 @@ pub fn run_cargo(\n     // simply skip a line if it doesn't parse, which just ignores any\n     // erroneus output.\n     let stdout = BufReader::new(child.stdout.take().unwrap());\n+    let mut read_at_least_one_message = false;\n+\n     for line in stdout.lines() {\n         let line = match line {\n             Ok(line) => line,\n@@ -291,12 +304,27 @@ pub fn run_cargo(\n             }\n         };\n \n+        read_at_least_one_message = true;\n+\n         if !on_message(message) {\n             break;\n         }\n     }\n \n-    child\n+    // It is okay to ignore the result, as it only errors if the process is already dead\n+    let _ = child.kill();\n+\n+    let err_msg = match child.wait() {\n+        Ok(exit_code) if !exit_code.success() && !read_at_least_one_message => {\n+            // FIXME: Read the stderr to display the reason, see `read2()` reference in PR comment:\n+            // https://github.com/rust-analyzer/rust-analyzer/pull/3632#discussion_r395605298\n+            format!(\"the command produced no valid metadata:\\n cargo {}\", args.join(\" \"))\n+        }\n+        Err(err) => format!(\"io error: {:?}\", err),\n+        Ok(_) => return Ok(()),\n+    };\n+\n+    Err(CargoError(err_msg))\n }\n \n impl WatchThread {\n@@ -325,7 +353,7 @@ impl WatchThread {\n                 // which will break out of the loop, and continue the shutdown\n                 let _ = message_send.send(CheckEvent::Begin);\n \n-                let mut child = run_cargo(&args, Some(&workspace_root), &mut |message| {\n+                let res = run_cargo(&args, Some(&workspace_root), &mut |message| {\n                     // Skip certain kinds of messages to only spend time on what's useful\n                     match &message {\n                         Message::CompilerArtifact(artifact) if artifact.fresh => return true,\n@@ -334,39 +362,19 @@ impl WatchThread {\n                         _ => {}\n                     }\n \n-                    match message_send.send(CheckEvent::Msg(message)) {\n-                        Ok(()) => {}\n-                        Err(_err) => {\n-                            // The send channel was closed, so we want to shutdown\n-                            return false;\n-                        }\n-                    };\n-\n-                    true\n+                    // if the send channel was closed, so we want to shutdown\n+                    message_send.send(CheckEvent::Msg(message)).is_ok()\n                 });\n \n+                if let Err(err) = res {\n+                    // FIXME: make the `message_send` to be `Sender<Result<CheckEvent, CargoError>>`\n+                    // to display user-caused misconfiguration errors instead of just logging them here\n+                    log::error!(\"Cargo watcher failed {:?}\", err);\n+                }\n+\n                 // We can ignore any error here, as we are already in the progress\n                 // of shutting down.\n                 let _ = message_send.send(CheckEvent::End);\n-\n-                // It is okay to ignore the result, as it only errors if the process is already dead\n-                let _ = child.kill();\n-\n-                // Again, we are resilient to errors, so we don't try to panic here\n-                match child.wait_with_output() {\n-                    Ok(output) => match output.status.code() {\n-                        Some(0) | None => {}\n-                        Some(exit_code) => {\n-                            let output =\n-                                std::str::from_utf8(&output.stderr).unwrap_or(\"<bad utf8 output>\");\n-\n-                            if !output.contains(\"could not compile\") {\n-                                log::error!(\"Cargo failed with exit code {} {}\", exit_code, output);\n-                            }\n-                        }\n-                    },\n-                    Err(err) => log::error!(\"Cargo io error: {:?}\", err),\n-                }\n             }))\n         } else {\n             None"}, {"sha": "c7f9bd873e4d9b17080fcb469b6c6789254d6a99", "filename": "crates/ra_project_model/src/cargo_workspace.rs", "status": "modified", "additions": 13, "deletions": 14, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/ce73c43848aa394530693967b8a6e9343f7b99b8/crates%2Fra_project_model%2Fsrc%2Fcargo_workspace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce73c43848aa394530693967b8a6e9343f7b99b8/crates%2Fra_project_model%2Fsrc%2Fcargo_workspace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_project_model%2Fsrc%2Fcargo_workspace.rs?ref=ce73c43848aa394530693967b8a6e9343f7b99b8", "patch": "@@ -6,7 +6,7 @@ use std::{\n };\n \n use anyhow::{Context, Result};\n-use cargo_metadata::{CargoOpt, Message, MetadataCommand, PackageId};\n+use cargo_metadata::{BuildScript, CargoOpt, Message, MetadataCommand, PackageId};\n use ra_arena::{Arena, Idx};\n use ra_cargo_watch::run_cargo;\n use ra_db::Edition;\n@@ -254,7 +254,7 @@ pub fn load_out_dirs(\n         \"check\".to_string(),\n         \"--message-format=json\".to_string(),\n         \"--manifest-path\".to_string(),\n-        format!(\"{}\", cargo_toml.display()),\n+        cargo_toml.display().to_string(),\n     ];\n \n     if cargo_features.all_features {\n@@ -263,19 +263,15 @@ pub fn load_out_dirs(\n         // FIXME: `NoDefaultFeatures` is mutual exclusive with `SomeFeatures`\n         // https://github.com/oli-obk/cargo_metadata/issues/79\n         args.push(\"--no-default-features\".to_string());\n-    } else if !cargo_features.features.is_empty() {\n-        for feature in &cargo_features.features {\n-            args.push(feature.clone());\n-        }\n+    } else {\n+        args.extend(cargo_features.features.iter().cloned());\n     }\n \n-    let mut res = FxHashMap::default();\n-    let mut child = run_cargo(&args, cargo_toml.parent(), &mut |message| {\n+    let mut acc = FxHashMap::default();\n+    let res = run_cargo(&args, cargo_toml.parent(), &mut |message| {\n         match message {\n-            Message::BuildScriptExecuted(message) => {\n-                let package_id = message.package_id;\n-                let out_dir = message.out_dir;\n-                res.insert(package_id, out_dir);\n+            Message::BuildScriptExecuted(BuildScript { package_id, out_dir, .. }) => {\n+                acc.insert(package_id, out_dir);\n             }\n \n             Message::CompilerArtifact(_) => (),\n@@ -285,6 +281,9 @@ pub fn load_out_dirs(\n         true\n     });\n \n-    let _ = child.wait();\n-    res\n+    if let Err(err) = res {\n+        log::error!(\"Failed to load outdirs: {:?}\", err);\n+    }\n+\n+    acc\n }"}]}