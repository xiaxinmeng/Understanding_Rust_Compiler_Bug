{"sha": "bc364b4a0d678b29cba92ce948d948aee9d76b25", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJjMzY0YjRhMGQ2NzhiMjljYmE5MmNlOTQ4ZDk0OGFlZTlkNzZiMjU=", "commit": {"author": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2015-09-28T04:24:42Z"}, "committer": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2015-10-08T22:53:41Z"}, "message": "if let and while let", "tree": {"sha": "dd7ae97421e42072e69df6ca867c9d64b68b0a6b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dd7ae97421e42072e69df6ca867c9d64b68b0a6b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bc364b4a0d678b29cba92ce948d948aee9d76b25", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bc364b4a0d678b29cba92ce948d948aee9d76b25", "html_url": "https://github.com/rust-lang/rust/commit/bc364b4a0d678b29cba92ce948d948aee9d76b25", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bc364b4a0d678b29cba92ce948d948aee9d76b25/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "04a7675d222bcba021886bd5f21d7c6b33273811", "url": "https://api.github.com/repos/rust-lang/rust/commits/04a7675d222bcba021886bd5f21d7c6b33273811", "html_url": "https://github.com/rust-lang/rust/commit/04a7675d222bcba021886bd5f21d7c6b33273811"}], "stats": {"total": 313, "additions": 154, "deletions": 159}, "files": [{"sha": "d9b834fe9fcaba6e2246537171d9c7b2d83b24ef", "filename": "src/librustc_front/lowering.rs", "status": "modified", "additions": 150, "deletions": 19, "changes": 169, "blob_url": "https://github.com/rust-lang/rust/blob/bc364b4a0d678b29cba92ce948d948aee9d76b25/src%2Flibrustc_front%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc364b4a0d678b29cba92ce948d948aee9d76b25/src%2Flibrustc_front%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_front%2Flowering.rs?ref=bc364b4a0d678b29cba92ce948d948aee9d76b25", "patch": "@@ -786,10 +786,28 @@ pub fn lower_expr(lctx: &LoweringContext, e: &Expr) -> P<hir::Expr> {\n                 ExprAddrOf(m, ref ohs) => {\n                     hir::ExprAddrOf(lower_mutability(lctx, m), lower_expr(lctx, ohs))\n                 }\n-                ExprIf(ref cond, ref tr, ref fl) => {\n+                // More complicated than you might expect because the else branch\n+                // might be `if let`.\n+                ExprIf(ref cond, ref blk, ref else_opt) => {\n+                    let else_opt = else_opt.as_ref().map(|els| match els.node {\n+                        ExprIfLet(..) => {\n+                            // wrap the if-let expr in a block\n+                            let span = els.span;\n+                            let blk = P(hir::Block {\n+                                stmts: vec![],\n+                                expr: Some(lower_expr(lctx, els)),\n+                                id: lctx.next_id(),\n+                                rules: hir::DefaultBlock,\n+                                span: span\n+                            });\n+                            expr_block(lctx, blk)\n+                        }\n+                        _ => lower_expr(lctx, els)\n+                    });\n+\n                     hir::ExprIf(lower_expr(lctx, cond),\n-                           lower_block(lctx, tr),\n-                           fl.as_ref().map(|x| lower_expr(lctx, x)))\n+                                lower_block(lctx, blk),\n+                                else_opt)\n                 }\n                 ExprWhile(ref cond, ref body, opt_ident) => {\n                     hir::ExprWhile(lower_expr(lctx, cond),\n@@ -880,16 +898,123 @@ pub fn lower_expr(lctx: &LoweringContext, e: &Expr) -> P<hir::Expr> {\n                 ExprInPlace(..) => {\n                     panic!(\"todo\");\n                 }\n-                ExprIfLet(..) => {\n-                    panic!(\"todo\");\n+\n+                // Desugar ExprIfLet\n+                // From: `if let <pat> = <sub_expr> <body> [<else_opt>]`\n+                ExprIfLet(ref pat, ref sub_expr, ref body, ref else_opt) => {\n+                    // to:\n+                    //\n+                    //   match <sub_expr> {\n+                    //     <pat> => <body>,\n+                    //     [_ if <else_opt_if_cond> => <else_opt_if_body>,]\n+                    //     _ => [<else_opt> | ()]\n+                    //   }\n+\n+                    // `<pat> => <body>`\n+                    let pat_arm = {\n+                        let body_expr = expr_block(lctx, lower_block(lctx, body));\n+                        arm(vec![lower_pat(lctx, pat)], body_expr)\n+                    };\n+\n+                    // `[_ if <else_opt_if_cond> => <else_opt_if_body>,]`\n+                    let mut else_opt = else_opt.as_ref().map(|e| lower_expr(lctx, e));\n+                    let else_if_arms = {\n+                        let mut arms = vec![];\n+                        loop {\n+                            let else_opt_continue = else_opt\n+                                .and_then(|els| els.and_then(|els| match els.node {\n+                                // else if\n+                                hir::ExprIf(cond, then, else_opt) => {\n+                                    let pat_under = pat_wild(lctx, e.span);\n+                                    arms.push(hir::Arm {\n+                                        attrs: vec![],\n+                                        pats: vec![pat_under],\n+                                        guard: Some(cond),\n+                                        body: expr_block(lctx, then)\n+                                    });\n+                                    else_opt.map(|else_opt| (else_opt, true))\n+                                }\n+                                _ => Some((P(els), false))\n+                            }));\n+                            match else_opt_continue {\n+                                Some((e, true)) => {\n+                                    else_opt = Some(e);\n+                                }\n+                                Some((e, false)) => {\n+                                    else_opt = Some(e);\n+                                    break;\n+                                }\n+                                None => {\n+                                    else_opt = None;\n+                                    break;\n+                                }\n+                            }\n+                        }\n+                        arms\n+                    };\n+\n+                    let contains_else_clause = else_opt.is_some();\n+\n+                    // `_ => [<else_opt> | ()]`\n+                    let else_arm = {\n+                        let pat_under = pat_wild(lctx, e.span);\n+                        let else_expr = else_opt.unwrap_or_else(|| expr_tuple(lctx, e.span, vec![]));\n+                        arm(vec![pat_under], else_expr)\n+                    };\n+\n+                    let mut arms = Vec::with_capacity(else_if_arms.len() + 2);\n+                    arms.push(pat_arm);\n+                    arms.extend(else_if_arms);\n+                    arms.push(else_arm);\n+\n+                    let match_expr = expr(lctx,\n+                                          e.span,\n+                                          hir::ExprMatch(lower_expr(lctx, sub_expr), arms,\n+                                                 hir::MatchSource::IfLetDesugar {\n+                                                     contains_else_clause: contains_else_clause,\n+                                                 }));\n+                    return match_expr;\n                 }\n-                ExprWhileLet(..) => {\n-                    panic!(\"todo\");\n+\n+                // Desugar ExprWhileLet\n+                // From: `[opt_ident]: while let <pat> = <sub_expr> <body>`\n+                ExprWhileLet(ref pat, ref sub_expr, ref body, opt_ident) => {\n+                    // to:\n+                    //\n+                    //   [opt_ident]: loop {\n+                    //     match <sub_expr> {\n+                    //       <pat> => <body>,\n+                    //       _ => break\n+                    //     }\n+                    //   }\n+\n+                    // `<pat> => <body>`\n+                    let pat_arm = {\n+                        let body_expr = expr_block(lctx, lower_block(lctx, body));\n+                        arm(vec![lower_pat(lctx, pat)], body_expr)\n+                    };\n+\n+                    // `_ => break`\n+                    let break_arm = {\n+                        let pat_under = pat_wild(lctx, e.span);\n+                        let break_expr = expr_break(lctx, e.span);\n+                        arm(vec![pat_under], break_expr)\n+                    };\n+\n+                    // // `match <sub_expr> { ... }`\n+                    let arms = vec![pat_arm, break_arm];\n+                    let match_expr = expr(lctx,\n+                                          e.span,\n+                                          hir::ExprMatch(lower_expr(lctx, sub_expr), arms, hir::MatchSource::WhileLetDesugar));\n+\n+                    // `[opt_ident]: loop { ... }`\n+                    let loop_block = block_expr(lctx, match_expr);\n+                    return expr(lctx, e.span, hir::ExprLoop(loop_block, opt_ident));\n                 }\n \n                 // Desugar ExprForLoop\n                 // From: `[opt_ident]: for <pat> in <head> <body>`\n-                ExprForLoop(ref pat, ref head, ref body, ref opt_ident) => {\n+                ExprForLoop(ref pat, ref head, ref body, opt_ident) => {\n                     // to:\n                     //\n                     //   {\n@@ -952,7 +1077,7 @@ pub fn lower_expr(lctx: &LoweringContext, e: &Expr) -> P<hir::Expr> {\n \n                     // `[opt_ident]: loop { ... }`\n                     let loop_block = block_expr(lctx, match_expr);\n-                    let loop_expr = expr(lctx, e.span, hir::ExprLoop(loop_block, opt_ident.clone()));\n+                    let loop_expr = expr(lctx, e.span, hir::ExprLoop(loop_block, opt_ident));\n \n                     // `mut iter => { ... }`\n                     let iter_arm = {\n@@ -976,16 +1101,14 @@ pub fn lower_expr(lctx: &LoweringContext, e: &Expr) -> P<hir::Expr> {\n \n                     // `{ let result = ...; result }`\n                     let result_ident = token::gensym_ident(\"result\");\n-                    let result = expr_block(lctx,\n-                                            block_all(lctx,\n-                                                      e.span,\n-                                                      vec![stmt_let(lctx,\n-                                                                    e.span,\n-                                                                    false,\n-                                                                    result_ident,\n-                                                                    match_expr)],\n-                                                      Some(expr_ident(lctx, e.span, result_ident))));\n-                    return result;\n+                    return expr_block(lctx,\n+                                      block_all(lctx,\n+                                                e.span,\n+                                                vec![stmt_let(lctx, e.span,\n+                                                              false,\n+                                                              result_ident,\n+                                                              match_expr)],\n+                                                Some(expr_ident(lctx, e.span, result_ident))))\n                 }\n \n                 ExprMac(_) => panic!(\"Shouldn't exist here\"),\n@@ -1137,6 +1260,10 @@ fn expr_block(lctx: &LoweringContext, b: P<hir::Block>) -> P<hir::Expr> {\n     expr(lctx, b.span, hir::ExprBlock(b))\n }\n \n+fn expr_tuple(lctx: &LoweringContext, sp: Span, exprs: Vec<P<hir::Expr>>) -> P<hir::Expr> {\n+    expr(lctx, sp, hir::ExprTup(exprs))\n+}\n+\n fn expr(lctx: &LoweringContext, span: Span, node: hir::Expr_) -> P<hir::Expr> {\n     P(hir::Expr {\n         id: lctx.next_id(),\n@@ -1208,6 +1335,10 @@ fn pat_ident_binding_mode(lctx: &LoweringContext,\n     pat(lctx, span, pat_ident)\n }\n \n+fn pat_wild(lctx: &LoweringContext, span: Span) -> P<hir::Pat> {\n+    pat(lctx, span, hir::PatWild(hir::PatWildSingle))\n+}\n+\n fn pat(lctx: &LoweringContext, span: Span, pat: hir::Pat_) -> P<hir::Pat> {\n     P(hir::Pat { id: lctx.next_id(), node: pat, span: span })\n }"}, {"sha": "f6767bc4e476a669c7b30dbf33c90979eb53010b", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 4, "deletions": 140, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/bc364b4a0d678b29cba92ce948d948aee9d76b25/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc364b4a0d678b29cba92ce948d948aee9d76b25/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=bc364b4a0d678b29cba92ce948d948aee9d76b25", "patch": "@@ -212,147 +212,11 @@ pub fn expand_expr(e: P<ast::Expr>, fld: &mut MacroExpander) -> P<ast::Expr> {\n             fld.cx.expr(span, ast::ExprWhile(cond, body, opt_ident))\n         }\n \n-        // Desugar ExprWhileLet\n-        // From: `[opt_ident]: while let <pat> = <expr> <body>`\n         ast::ExprWhileLet(pat, expr, body, opt_ident) => {\n-            // to:\n-            //\n-            //   [opt_ident]: loop {\n-            //     match <expr> {\n-            //       <pat> => <body>,\n-            //       _ => break\n-            //     }\n-            //   }\n-\n-            push_compiler_expansion(fld, span, CompilerExpansionFormat::WhileLet);\n-\n-            // `<pat> => <body>`\n-            let pat_arm = {\n-                let body_expr = fld.cx.expr_block(body);\n-                fld.cx.arm(pat.span, vec![pat], body_expr)\n-            };\n-\n-            // `_ => break`\n-            let break_arm = {\n-                let pat_under = fld.cx.pat_wild(span);\n-                let break_expr = fld.cx.expr_break(span);\n-                fld.cx.arm(span, vec![pat_under], break_expr)\n-            };\n-\n-            // `match <expr> { ... }`\n-            let arms = vec![pat_arm, break_arm];\n-            let match_expr = fld.cx.expr(span,\n-                                    ast::ExprMatch(expr, arms, ast::MatchSource::WhileLetDesugar));\n-\n-            // `[opt_ident]: loop { ... }`\n-            let loop_block = fld.cx.block_expr(match_expr);\n-            let (loop_block, opt_ident) = expand_loop_block(loop_block, opt_ident, fld);\n-            let result = fld.cx.expr(span, ast::ExprLoop(loop_block, opt_ident));\n-            fld.cx.bt_pop();\n-            result\n-        }\n-\n-        // Desugar ExprIfLet\n-        // From: `if let <pat> = <expr> <body> [<elseopt>]`\n-        ast::ExprIfLet(pat, expr, body, mut elseopt) => {\n-            // to:\n-            //\n-            //   match <expr> {\n-            //     <pat> => <body>,\n-            //     [_ if <elseopt_if_cond> => <elseopt_if_body>,]\n-            //     _ => [<elseopt> | ()]\n-            //   }\n-\n-            push_compiler_expansion(fld, span, CompilerExpansionFormat::IfLet);\n-\n-            // `<pat> => <body>`\n-            let pat_arm = {\n-                let body_expr = fld.cx.expr_block(body);\n-                fld.cx.arm(pat.span, vec![pat], body_expr)\n-            };\n-\n-            // `[_ if <elseopt_if_cond> => <elseopt_if_body>,]`\n-            let else_if_arms = {\n-                let mut arms = vec![];\n-                loop {\n-                    let elseopt_continue = elseopt\n-                        .and_then(|els| els.and_then(|els| match els.node {\n-                        // else if\n-                        ast::ExprIf(cond, then, elseopt) => {\n-                            let pat_under = fld.cx.pat_wild(span);\n-                            arms.push(ast::Arm {\n-                                attrs: vec![],\n-                                pats: vec![pat_under],\n-                                guard: Some(cond),\n-                                body: fld.cx.expr_block(then)\n-                            });\n-                            elseopt.map(|elseopt| (elseopt, true))\n-                        }\n-                        _ => Some((P(els), false))\n-                    }));\n-                    match elseopt_continue {\n-                        Some((e, true)) => {\n-                            elseopt = Some(e);\n-                        }\n-                        Some((e, false)) => {\n-                            elseopt = Some(e);\n-                            break;\n-                        }\n-                        None => {\n-                            elseopt = None;\n-                            break;\n-                        }\n-                    }\n-                }\n-                arms\n-            };\n-\n-            let contains_else_clause = elseopt.is_some();\n-\n-            // `_ => [<elseopt> | ()]`\n-            let else_arm = {\n-                let pat_under = fld.cx.pat_wild(span);\n-                let else_expr = elseopt.unwrap_or_else(|| fld.cx.expr_tuple(span, vec![]));\n-                fld.cx.arm(span, vec![pat_under], else_expr)\n-            };\n-\n-            let mut arms = Vec::with_capacity(else_if_arms.len() + 2);\n-            arms.push(pat_arm);\n-            arms.extend(else_if_arms);\n-            arms.push(else_arm);\n-\n-            let match_expr = fld.cx.expr(span,\n-                                         ast::ExprMatch(expr, arms,\n-                                                ast::MatchSource::IfLetDesugar {\n-                                                    contains_else_clause: contains_else_clause,\n-                                                }));\n-            let result = fld.fold_expr(match_expr);\n-            fld.cx.bt_pop();\n-            result\n-        }\n-\n-        // Desugar support for ExprIfLet in the ExprIf else position\n-        ast::ExprIf(cond, blk, elseopt) => {\n-            let elseopt = elseopt.map(|els| els.and_then(|els| match els.node {\n-                ast::ExprIfLet(..) => {\n-                    push_compiler_expansion(fld, span, CompilerExpansionFormat::IfLet);\n-                    // wrap the if-let expr in a block\n-                    let span = els.span;\n-                    let blk = P(ast::Block {\n-                        stmts: vec![],\n-                        expr: Some(P(els)),\n-                        id: ast::DUMMY_NODE_ID,\n-                        rules: ast::DefaultBlock,\n-                        span: span\n-                    });\n-                    let result = fld.cx.expr_block(blk);\n-                    fld.cx.bt_pop();\n-                    result\n-                }\n-                _ => P(els)\n-            }));\n-            let if_expr = fld.cx.expr(span, ast::ExprIf(cond, blk, elseopt));\n-            if_expr.map(|e| noop_fold_expr(e, fld))\n+            let pat = fld.fold_pat(pat);\n+            let expr = fld.fold_expr(expr);\n+            let (body, opt_ident) = expand_loop_block(body, opt_ident, fld);\n+            fld.cx.expr(span, ast::ExprWhileLet(pat, expr, body, opt_ident))\n         }\n \n         ast::ExprLoop(loop_block, opt_ident) => {"}]}