{"sha": "0a1cb9b91422e38baf352993ad78446a29160ed8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBhMWNiOWI5MTQyMmUzOGJhZjM1Mjk5M2FkNzg0NDZhMjkxNjBlZDg=", "commit": {"author": {"name": "Keith Yeung", "email": "kungfukeith11@gmail.com", "date": "2018-04-22T06:41:44Z"}, "committer": {"name": "Keith Yeung", "email": "kungfukeith11@gmail.com", "date": "2018-04-29T05:25:57Z"}, "message": "Add the actual used mutable var to the set", "tree": {"sha": "4d3371cf0cbefbfd85b02df132da5bbc3a8dd3d6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4d3371cf0cbefbfd85b02df132da5bbc3a8dd3d6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0a1cb9b91422e38baf352993ad78446a29160ed8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0a1cb9b91422e38baf352993ad78446a29160ed8", "html_url": "https://github.com/rust-lang/rust/commit/0a1cb9b91422e38baf352993ad78446a29160ed8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0a1cb9b91422e38baf352993ad78446a29160ed8/comments", "author": {"login": "KiChjang", "id": 3248587, "node_id": "MDQ6VXNlcjMyNDg1ODc=", "avatar_url": "https://avatars.githubusercontent.com/u/3248587?v=4", "gravatar_id": "", "url": "https://api.github.com/users/KiChjang", "html_url": "https://github.com/KiChjang", "followers_url": "https://api.github.com/users/KiChjang/followers", "following_url": "https://api.github.com/users/KiChjang/following{/other_user}", "gists_url": "https://api.github.com/users/KiChjang/gists{/gist_id}", "starred_url": "https://api.github.com/users/KiChjang/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/KiChjang/subscriptions", "organizations_url": "https://api.github.com/users/KiChjang/orgs", "repos_url": "https://api.github.com/users/KiChjang/repos", "events_url": "https://api.github.com/users/KiChjang/events{/privacy}", "received_events_url": "https://api.github.com/users/KiChjang/received_events", "type": "User", "site_admin": false}, "committer": {"login": "KiChjang", "id": 3248587, "node_id": "MDQ6VXNlcjMyNDg1ODc=", "avatar_url": "https://avatars.githubusercontent.com/u/3248587?v=4", "gravatar_id": "", "url": "https://api.github.com/users/KiChjang", "html_url": "https://github.com/KiChjang", "followers_url": "https://api.github.com/users/KiChjang/followers", "following_url": "https://api.github.com/users/KiChjang/following{/other_user}", "gists_url": "https://api.github.com/users/KiChjang/gists{/gist_id}", "starred_url": "https://api.github.com/users/KiChjang/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/KiChjang/subscriptions", "organizations_url": "https://api.github.com/users/KiChjang/orgs", "repos_url": "https://api.github.com/users/KiChjang/repos", "events_url": "https://api.github.com/users/KiChjang/events{/privacy}", "received_events_url": "https://api.github.com/users/KiChjang/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ded06976790299c87ca3501aca23d3c74b5b0039", "url": "https://api.github.com/repos/rust-lang/rust/commits/ded06976790299c87ca3501aca23d3c74b5b0039", "html_url": "https://github.com/rust-lang/rust/commit/ded06976790299c87ca3501aca23d3c74b5b0039"}], "stats": {"total": 167, "additions": 102, "deletions": 65}, "files": [{"sha": "3145be7df851ef6dacc1f0bc096944ef00a968a1", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 102, "deletions": 65, "changes": 167, "blob_url": "https://github.com/rust-lang/rust/blob/0a1cb9b91422e38baf352993ad78446a29160ed8/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a1cb9b91422e38baf352993ad78446a29160ed8/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=0a1cb9b91422e38baf352993ad78446a29160ed8", "patch": "@@ -259,6 +259,31 @@ fn do_mir_borrowck<'a, 'gcx, 'tcx>(\n \n     mbcx.analyze_results(&mut state); // entry point for DataflowResultsConsumer\n \n+    // For each non-user used mutable variable, check if it's been assigned from\n+    // a user-declared local. If so, then put that local into the used_mut set.\n+    // Note that this set is expected to be small - only upvars from closures\n+    // would have a chance of erroneously adding non-user-defined mutable vars\n+    // to the set.\n+    let temporary_used_locals: FxHashSet<Local> =\n+        mbcx.used_mut.iter()\n+            .filter(|&local| !mbcx.mir.local_decls[*local].is_user_variable)\n+            .cloned()\n+            .collect();\n+\n+    for local in temporary_used_locals {\n+        for location in mbcx.mir.find_assignments(local) {\n+            for moi in &mbcx.move_data.loc_map[location] {\n+                let mpi = &mbcx.move_data.moves[*moi].path;\n+                let path = &mbcx.move_data.move_paths[*mpi];\n+                debug!(\"assignment of {:?} to {:?}, adding {:?} to used mutable set\",\n+                       path.place, local, path.place);\n+                if let Place::Local(user_local) = path.place {\n+                    mbcx.used_mut.insert(user_local);\n+                }\n+            }\n+        }\n+    }\n+\n     debug!(\"mbcx.used_mut: {:?}\", mbcx.used_mut);\n \n     for local in mbcx.mir.mut_vars_and_args_iter().filter(|local| !mbcx.used_mut.contains(local)) {\n@@ -731,6 +756,11 @@ enum InitializationRequiringAction {\n     Assignment,\n }\n \n+struct RootPlace<'d, 'tcx: 'd> {\n+    place: &'d Place<'tcx>,\n+    is_local_mutation_allowed: LocalMutationIsAllowed,\n+}\n+\n impl InitializationRequiringAction {\n     fn as_noun(self) -> &'static str {\n         match self {\n@@ -1687,23 +1717,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             Reservation(WriteKind::MutableBorrow(BorrowKind::Mut { .. }))\n             | Write(WriteKind::MutableBorrow(BorrowKind::Mut { .. })) => {\n                 match self.is_mutable(place, is_local_mutation_allowed) {\n-                    Ok((Place::Local(local), mut_allowed)) => {\n-                        if mut_allowed != LocalMutationIsAllowed::Yes {\n-                            // If the local may be initialized, and it is now currently being\n-                            // mutated, then it is justified to be annotated with the `mut`\n-                            // keyword, since the mutation may be a possible reassignment.\n-                            let mpi = self.move_data.rev_lookup.find_local(*local);\n-                            if flow_state.inits.contains(&mpi) {\n-                                self.used_mut.insert(*local);\n-                            }\n-                        }\n-                    }\n-                    Ok((Place::Projection(_), _mut_allowed)) => {\n-                        if let Some(field) = self.is_upvar_field_projection(&place) {\n-                            self.used_mut_upvars.push(field);\n-                        }\n-                    }\n-                    Ok((Place::Static(..), _mut_allowed)) => {}\n+                    Ok(root_place) => self.add_used_mut(root_place, flow_state),\n                     Err(place_err) => {\n                         error_reported = true;\n                         let item_msg = self.get_default_err_msg(place);\n@@ -1724,55 +1738,35 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             }\n             Reservation(WriteKind::Mutate) | Write(WriteKind::Mutate) => {\n                 match self.is_mutable(place, is_local_mutation_allowed) {\n-                    Ok((Place::Local(local), mut_allowed)) => {\n-                        if mut_allowed != LocalMutationIsAllowed::Yes {\n-                            // If the local may be initialized, and it is now currently being\n-                            // mutated, then it is justified to be annotated with the `mut`\n-                            // keyword, since the mutation may be a possible reassignment.\n-                            let mpi = self.move_data.rev_lookup.find_local(*local);\n-                            if flow_state.inits.contains(&mpi) {\n-                                self.used_mut.insert(*local);\n-                            }\n-                        }\n-                    }\n-                    Ok((Place::Projection(_), _mut_allowed)) => {\n-                        if let Some(field) = self.is_upvar_field_projection(&place) {\n-                            self.used_mut_upvars.push(field);\n-                        }\n-                    }\n-                    Ok((Place::Static(..), _mut_allowed)) => {}\n+                    Ok(root_place) => self.add_used_mut(root_place, flow_state),\n                     Err(place_err) => {\n                         error_reported = true;\n \n                         let err_info = if let Place::Projection(\n                             box Projection {\n-                                ref base,\n+                                base: Place::Local(local),\n                                 elem: ProjectionElem::Deref\n                             }\n                         ) = *place_err {\n-                            if let Place::Local(local) = *base {\n-                                let locations = self.mir.find_assignments(local);\n-                                if locations.len() > 0 {\n-                                    let item_msg = if error_reported {\n-                                        self.get_secondary_err_msg(base)\n-                                    } else {\n-                                        self.get_default_err_msg(place)\n-                                    };\n-                                    let sp = self.mir.source_info(locations[0]).span;\n-                                    let mut to_suggest_span = String::new();\n-                                    if let Ok(src) =\n-                                        self.tcx.sess.codemap().span_to_snippet(sp) {\n-                                            to_suggest_span = src[1..].to_string();\n-                                    };\n-                                    Some((sp,\n-                                          \"consider changing this to be a \\\n-                                          mutable reference\",\n-                                          to_suggest_span,\n-                                          item_msg,\n-                                          self.get_primary_err_msg(base)))\n+                            let locations = self.mir.find_assignments(local);\n+                            if locations.len() > 0 {\n+                                let item_msg = if error_reported {\n+                                    self.get_secondary_err_msg(&Place::Local(local))\n                                 } else {\n-                                    None\n-                                }\n+                                    self.get_default_err_msg(place)\n+                                };\n+                                let sp = self.mir.source_info(locations[0]).span;\n+                                let mut to_suggest_span = String::new();\n+                                if let Ok(src) =\n+                                    self.tcx.sess.codemap().span_to_snippet(sp) {\n+                                        to_suggest_span = src[1..].to_string();\n+                                };\n+                                Some((sp,\n+                                      \"consider changing this to be a \\\n+                                      mutable reference\",\n+                                      to_suggest_span,\n+                                      item_msg,\n+                                      self.get_primary_err_msg(&Place::Local(local))))\n                             } else {\n                                 None\n                             }\n@@ -1834,33 +1828,76 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         error_reported\n     }\n \n-    /// Can this value be written or borrowed mutably\n+    /// Adds the place into the used mutable variables set\n+    fn add_used_mut<'d>(\n+        &mut self,\n+        root_place: RootPlace<'d, 'tcx>,\n+        flow_state: &Flows<'cx, 'gcx, 'tcx>\n+    ) {\n+        match root_place {\n+            RootPlace {\n+                place: Place::Local(local),\n+                is_local_mutation_allowed,\n+            } => {\n+                if is_local_mutation_allowed != LocalMutationIsAllowed::Yes {\n+                    // If the local may be initialized, and it is now currently being\n+                    // mutated, then it is justified to be annotated with the `mut`\n+                    // keyword, since the mutation may be a possible reassignment.\n+                    let mpi = self.move_data.rev_lookup.find_local(*local);\n+                    if flow_state.inits.contains(&mpi) {\n+                        self.used_mut.insert(*local);\n+                    }\n+                }\n+            }\n+            RootPlace {\n+                place: place @ Place::Projection(_),\n+                is_local_mutation_allowed: _,\n+            } => {\n+                if let Some(field) = self.is_upvar_field_projection(&place) {\n+                    self.used_mut_upvars.push(field);\n+                }\n+            }\n+            RootPlace {\n+                place: Place::Static(..),\n+                is_local_mutation_allowed: _,\n+            } => {}\n+        }\n+    }\n+\n+    /// Whether this value be written or borrowed mutably.\n+    /// Returns the root place if the place passed in is a projection.\n     fn is_mutable<'d>(\n         &self,\n         place: &'d Place<'tcx>,\n         is_local_mutation_allowed: LocalMutationIsAllowed,\n-    ) -> Result<(&'d Place<'tcx>, LocalMutationIsAllowed), &'d Place<'tcx>> {\n+    ) -> Result<RootPlace<'d, 'tcx>, &'d Place<'tcx>> {\n         match *place {\n             Place::Local(local) => {\n                 let local = &self.mir.local_decls[local];\n                 match local.mutability {\n                     Mutability::Not => match is_local_mutation_allowed {\n                         LocalMutationIsAllowed::Yes => {\n-                            Ok((place, LocalMutationIsAllowed::Yes))\n+                            Ok(RootPlace {\n+                                place,\n+                                is_local_mutation_allowed: LocalMutationIsAllowed::Yes\n+                            })\n                         }\n                         LocalMutationIsAllowed::ExceptUpvars => {\n-                            Ok((place, LocalMutationIsAllowed::ExceptUpvars))\n+                            Ok(RootPlace {\n+                                place,\n+                                is_local_mutation_allowed: LocalMutationIsAllowed::ExceptUpvars\n+                            })\n                         }\n                         LocalMutationIsAllowed::No => Err(place),\n                     },\n-                    Mutability::Mut => Ok((place, is_local_mutation_allowed)),\n+                    Mutability::Mut => Ok(RootPlace { place, is_local_mutation_allowed }),\n                 }\n             }\n             Place::Static(ref static_) =>\n                 if self.tcx.is_static(static_.def_id) != Some(hir::Mutability::MutMutable) {\n                     Err(place)\n                 } else {\n-                    Ok((place, is_local_mutation_allowed))\n+                    Ok(RootPlace { place, is_local_mutation_allowed })\n                 },\n             Place::Projection(ref proj) => {\n                 match proj.elem {\n@@ -1899,7 +1936,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                                     // `*mut` raw pointers are always mutable, regardless of\n                                     // context. The users have to check by themselves.\n                                     hir::MutMutable => {\n-                                        return Ok((place, is_local_mutation_allowed));\n+                                        return Ok(RootPlace { place, is_local_mutation_allowed });\n                                     }\n                                 }\n                             }\n@@ -1958,7 +1995,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                                     // }\n                                     // ```\n                                     let _ = self.is_mutable(&proj.base, is_local_mutation_allowed)?;\n-                                    Ok((place, is_local_mutation_allowed))\n+                                    Ok(RootPlace { place, is_local_mutation_allowed })\n                                 }\n                             }\n                         } else {"}]}