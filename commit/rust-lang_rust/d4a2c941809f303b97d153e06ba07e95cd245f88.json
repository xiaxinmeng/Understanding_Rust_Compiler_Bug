{"sha": "d4a2c941809f303b97d153e06ba07e95cd245f88", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ0YTJjOTQxODA5ZjMwM2I5N2QxNTNlMDZiYTA3ZTk1Y2QyNDVmODg=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-03-30T18:00:05Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-03-31T22:49:57Z"}, "message": "std: Clean out #[deprecated] APIs\n\nThis commit cleans out a large amount of deprecated APIs from the standard\nlibrary and some of the facade crates as well, updating all users in the\ncompiler and in tests as it goes along.", "tree": {"sha": "f876f056ff60aeac3f0098deb2dbe1fabfd13091", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f876f056ff60aeac3f0098deb2dbe1fabfd13091"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d4a2c941809f303b97d153e06ba07e95cd245f88", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d4a2c941809f303b97d153e06ba07e95cd245f88", "html_url": "https://github.com/rust-lang/rust/commit/d4a2c941809f303b97d153e06ba07e95cd245f88", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d4a2c941809f303b97d153e06ba07e95cd245f88/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d754722a04b99fdcae0fd97fa2a4395521145ef2", "url": "https://api.github.com/repos/rust-lang/rust/commits/d754722a04b99fdcae0fd97fa2a4395521145ef2", "html_url": "https://github.com/rust-lang/rust/commit/d754722a04b99fdcae0fd97fa2a4395521145ef2"}], "stats": {"total": 4614, "additions": 601, "deletions": 4013}, "files": [{"sha": "b3d5ad3b55d0ff8b3d5ce7739a431ff0f5a66742", "filename": "src/doc/reference.md", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Fdoc%2Freference.md", "raw_url": "https://github.com/rust-lang/rust/raw/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Fdoc%2Freference.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference.md?ref=d4a2c941809f303b97d153e06ba07e95cd245f88", "patch": "@@ -977,17 +977,13 @@ An example of `use` declarations:\n \n ```\n # #![feature(core)]\n-use std::iter::range_step;\n use std::option::Option::{Some, None};\n use std::collections::hash_map::{self, HashMap};\n \n fn foo<T>(_: T){}\n fn bar(map1: HashMap<String, usize>, map2: hash_map::HashMap<String, usize>){}\n \n fn main() {\n-    // Equivalent to 'std::iter::range_step(0, 10, 2);'\n-    range_step(0, 10, 2);\n-\n     // Equivalent to 'foo(vec![std::option::Option::Some(1.0f64),\n     // std::option::Option::None]);'\n     foo(vec![Some(1.0f64), None]);"}, {"sha": "55776bee3b585c91e8b0e7bc02b7ca8f5f43571c", "filename": "src/doc/trpl/iterators.md", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Fdoc%2Ftrpl%2Fiterators.md", "raw_url": "https://github.com/rust-lang/rust/raw/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Fdoc%2Ftrpl%2Fiterators.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fiterators.md?ref=d4a2c941809f303b97d153e06ba07e95cd245f88", "patch": "@@ -243,11 +243,12 @@ for num in nums.iter() {\n ```\n \n These two basic iterators should serve you well. There are some more\n-advanced iterators, including ones that are infinite. Like `count`:\n+advanced iterators, including ones that are infinite. Like using range syntax\n+and `step_by`:\n \n ```rust\n-# #![feature(core)]\n-std::iter::count(1, 5);\n+# #![feature(step_by)]\n+(1..).step_by(5);\n ```\n \n This iterator counts up from one, adding five each time. It will give\n@@ -292,11 +293,11 @@ just use `for` instead.\n There are tons of interesting iterator adapters. `take(n)` will return an\n iterator over the next `n` elements of the original iterator, note that this\n has no side effect on the original iterator. Let's try it out with our infinite\n-iterator from before, `count()`:\n+iterator from before:\n \n ```rust\n-# #![feature(core)]\n-for i in std::iter::count(1, 5).take(5) {\n+# #![feature(step_by)]\n+for i in (1..).step_by(5).take(5) {\n     println!(\"{}\", i);\n }\n ```"}, {"sha": "8874ac6eb872f020c1d55de74b835dd454d6cd73", "filename": "src/libcollections/bit.rs", "status": "modified", "additions": 2, "deletions": 10, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Flibcollections%2Fbit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Flibcollections%2Fbit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbit.rs?ref=d4a2c941809f303b97d153e06ba07e95cd245f88", "patch": "@@ -38,7 +38,7 @@\n //! [sieve]: http://en.wikipedia.org/wiki/Sieve_of_Eratosthenes\n //!\n //! ```\n-//! # #![feature(collections, core)]\n+//! # #![feature(collections, core, step_by)]\n //! use std::collections::{BitSet, BitVec};\n //! use std::num::Float;\n //! use std::iter;\n@@ -60,7 +60,7 @@\n //!         if bv[i] {\n //!             // Mark all multiples of i as non-prime (any multiples below i * i\n //!             // will have been marked as non-prime previously)\n-//!             for j in iter::range_step(i * i, max_prime, i) { bv.set(j, false) }\n+//!             for j in (i * i..max_prime).step_by(i) { bv.set(j, false) }\n //!         }\n //!     }\n //!     BitSet::from_bit_vec(bv)\n@@ -1264,14 +1264,6 @@ impl BitSet {\n         BitSet { bit_vec: bit_vec }\n     }\n \n-    /// Deprecated: use `from_bit_vec`.\n-    #[inline]\n-    #[deprecated(since = \"1.0.0\", reason = \"renamed to from_bit_vec\")]\n-    #[unstable(feature = \"collections\")]\n-    pub fn from_bitv(bit_vec: BitVec) -> BitSet {\n-        BitSet { bit_vec: bit_vec }\n-    }\n-\n     /// Returns the capacity in bits for this bit vector. Inserting any\n     /// element less than this amount will not trigger a resizing.\n     ///"}, {"sha": "b955e9b71e461360fa1c248313cfb7774260713a", "filename": "src/libcollections/borrow.rs", "status": "modified", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Flibcollections%2Fborrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Flibcollections%2Fborrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fborrow.rs?ref=d4a2c941809f303b97d153e06ba07e95cd245f88", "patch": "@@ -192,26 +192,6 @@ impl<'a, B: ?Sized> Cow<'a, B> where B: ToOwned {\n             Owned(owned) => owned\n         }\n     }\n-\n-    /// Returns true if this `Cow` wraps a borrowed value\n-    #[deprecated(since = \"1.0.0\", reason = \"match on the enum instead\")]\n-    #[unstable(feature = \"std_misc\")]\n-    pub fn is_borrowed(&self) -> bool {\n-        match *self {\n-            Borrowed(_) => true,\n-            _ => false,\n-        }\n-    }\n-\n-    /// Returns true if this `Cow` wraps an owned value\n-    #[deprecated(since = \"1.0.0\", reason = \"match on the enum instead\")]\n-    #[unstable(feature = \"std_misc\")]\n-    pub fn is_owned(&self) -> bool {\n-        match *self {\n-            Owned(_) => true,\n-            _ => false,\n-        }\n-    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "bdc2cf96734f61108eada35e524c204fc8288912", "filename": "src/libcollections/lib.rs", "status": "modified", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Flibcollections%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Flibcollections%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flib.rs?ref=d4a2c941809f303b97d153e06ba07e95cd245f88", "patch": "@@ -68,22 +68,6 @@ pub use string::String;\n pub use vec::Vec;\n pub use vec_map::VecMap;\n \n-#[deprecated(since = \"1.0.0\", reason = \"renamed to vec_deque\")]\n-#[unstable(feature = \"collections\")]\n-pub use vec_deque as ring_buf;\n-\n-#[deprecated(since = \"1.0.0\", reason = \"renamed to linked_list\")]\n-#[unstable(feature = \"collections\")]\n-pub use linked_list as dlist;\n-\n-#[deprecated(since = \"1.0.0\", reason = \"renamed to bit_vec\")]\n-#[unstable(feature = \"collections\")]\n-pub use bit_vec as bitv;\n-\n-#[deprecated(since = \"1.0.0\", reason = \"renamed to bit_set\")]\n-#[unstable(feature = \"collections\")]\n-pub use bit_set as bitv_set;\n-\n // Needed for the vec! macro\n pub use alloc::boxed;\n \n@@ -108,21 +92,13 @@ pub mod vec_map;\n            reason = \"RFC 509\")]\n pub mod bit_vec {\n     pub use bit::{BitVec, Iter};\n-\n-    #[deprecated(since = \"1.0.0\", reason = \"renamed to BitVec\")]\n-    #[unstable(feature = \"collections\")]\n-    pub use bit::BitVec as Bitv;\n }\n \n #[unstable(feature = \"collections\",\n            reason = \"RFC 509\")]\n pub mod bit_set {\n     pub use bit::{BitSet, Union, Intersection, Difference, SymmetricDifference};\n     pub use bit::SetIter as Iter;\n-\n-    #[deprecated(since = \"1.0.0\", reason = \"renamed to BitSet\")]\n-    #[unstable(feature = \"collections\")]\n-    pub use bit::BitSet as BitvSet;\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "392dc7346c60d3e6ed94c795e5b53dabc3e37d38", "filename": "src/libcollections/linked_list.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Flibcollections%2Flinked_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Flibcollections%2Flinked_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flinked_list.rs?ref=d4a2c941809f303b97d153e06ba07e95cd245f88", "patch": "@@ -32,10 +32,6 @@ use core::iter::{self, FromIterator, IntoIterator};\n use core::mem;\n use core::ptr;\n \n-#[deprecated(since = \"1.0.0\", reason = \"renamed to LinkedList\")]\n-#[unstable(feature = \"collections\")]\n-pub use LinkedList as DList;\n-\n /// A doubly-linked list.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct LinkedList<T> {\n@@ -844,7 +840,7 @@ impl<A> ExactSizeIterator for IntoIter<A> {}\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A> FromIterator<A> for LinkedList<A> {\n     fn from_iter<T: IntoIterator<Item=A>>(iter: T) -> LinkedList<A> {\n-        let mut ret = DList::new();\n+        let mut ret = LinkedList::new();\n         ret.extend(iter);\n         ret\n     }"}, {"sha": "d0e86f56d262fa2dbc4f5a91bc99c62566eb49c5", "filename": "src/libcollections/slice.rs", "status": "modified", "additions": 0, "deletions": 71, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Flibcollections%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Flibcollections%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fslice.rs?ref=d4a2c941809f303b97d153e06ba07e95cd245f88", "patch": "@@ -107,7 +107,6 @@ pub use core::slice::{IntSliceExt, SplitMut, ChunksMut, Split};\n pub use core::slice::{SplitN, RSplitN, SplitNMut, RSplitNMut};\n pub use core::slice::{bytes, mut_ref_slice, ref_slice};\n pub use core::slice::{from_raw_parts, from_raw_parts_mut};\n-pub use core::slice::{from_raw_buf, from_raw_mut_buf};\n \n ////////////////////////////////////////////////////////////////////////////////\n // Basic slice extension methods\n@@ -281,33 +280,6 @@ impl<T> [T] {\n         cmp::min(self.len(), end-start)\n     }\n \n-    /// Deprecated: use `&s[start .. end]` notation instead.\n-    #[unstable(feature = \"collections\",\n-               reason = \"will be replaced by slice syntax\")]\n-    #[deprecated(since = \"1.0.0\", reason = \"use &s[start .. end] instead\")]\n-    #[inline]\n-    pub fn slice(&self, start: usize, end: usize) -> &[T] {\n-        &self[start .. end]\n-    }\n-\n-    /// Deprecated: use `&s[start..]` notation instead.\n-    #[unstable(feature = \"collections\",\n-               reason = \"will be replaced by slice syntax\")]\n-    #[deprecated(since = \"1.0.0\", reason = \"use &s[start..] instead\")]\n-    #[inline]\n-    pub fn slice_from(&self, start: usize) -> &[T] {\n-        &self[start ..]\n-    }\n-\n-    /// Deprecated: use `&s[..end]` notation instead.\n-    #[unstable(feature = \"collections\",\n-               reason = \"will be replaced by slice syntax\")]\n-    #[deprecated(since = \"1.0.0\", reason = \"use &s[..end] instead\")]\n-    #[inline]\n-    pub fn slice_to(&self, end: usize) -> &[T] {\n-        &self[.. end]\n-    }\n-\n     /// Divides one slice into two at an index.\n     ///\n     /// The first will contain all indices from `[0, mid)` (excluding\n@@ -611,42 +583,6 @@ impl<T> [T] {\n         core_slice::SliceExt::get_mut(self, index)\n     }\n \n-    /// Deprecated: use `&mut s[..]` instead.\n-    #[unstable(feature = \"collections\",\n-               reason = \"will be replaced by slice syntax\")]\n-    #[deprecated(since = \"1.0.0\", reason = \"use &mut s[..] instead\")]\n-    #[allow(deprecated)]\n-    pub fn as_mut_slice(&mut self) -> &mut [T] {\n-        core_slice::SliceExt::as_mut_slice(self)\n-    }\n-\n-    /// Deprecated: use `&mut s[start .. end]` instead.\n-    #[unstable(feature = \"collections\",\n-               reason = \"will be replaced by slice syntax\")]\n-    #[deprecated(since = \"1.0.0\", reason = \"use &mut s[start .. end] instead\")]\n-    #[inline]\n-    pub fn slice_mut(&mut self, start: usize, end: usize) -> &mut [T] {\n-        &mut self[start .. end]\n-    }\n-\n-    /// Deprecated: use `&mut s[start ..]` instead.\n-    #[unstable(feature = \"collections\",\n-               reason = \"will be replaced by slice syntax\")]\n-    #[deprecated(since = \"1.0.0\", reason = \"use &mut s[start ..] instead\")]\n-    #[inline]\n-    pub fn slice_from_mut(&mut self, start: usize) -> &mut [T] {\n-        &mut self[start ..]\n-    }\n-\n-    /// Deprecated: use `&mut s[.. end]` instead.\n-    #[unstable(feature = \"collections\",\n-               reason = \"will be replaced by slice syntax\")]\n-    #[deprecated(since = \"1.0.0\", reason = \"use &mut s[.. end] instead\")]\n-    #[inline]\n-    pub fn slice_to_mut(&mut self, end: usize) -> &mut [T] {\n-        &mut self[.. end]\n-    }\n-\n     /// Returns an iterator that allows modifying each value\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n@@ -937,13 +873,6 @@ impl<T> [T] {\n         core_slice::SliceExt::binary_search(self, x)\n     }\n \n-    /// Deprecated: use `binary_search` instead.\n-    #[unstable(feature = \"collections\")]\n-    #[deprecated(since = \"1.0.0\", reason = \"use binary_search instead\")]\n-    pub fn binary_search_elem(&self, x: &T) -> Result<usize, usize> where T: Ord {\n-        self.binary_search(x)\n-    }\n-\n     /// Mutates the slice to the next lexicographic permutation.\n     ///\n     /// Returns `true` if successful and `false` if the slice is at the"}, {"sha": "35ec8af0a45f8ea0a2962d12066deaecd74bf197", "filename": "src/libcollections/str.rs", "status": "modified", "additions": 3, "deletions": 84, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Flibcollections%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Flibcollections%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstr.rs?ref=d4a2c941809f303b97d153e06ba07e95cd245f88", "patch": "@@ -70,11 +70,11 @@ use vec::Vec;\n use slice::SliceConcatExt;\n \n pub use core::str::{FromStr, Utf8Error, Str};\n-pub use core::str::{Lines, LinesAny, MatchIndices, SplitStr, CharRange};\n+pub use core::str::{Lines, LinesAny, MatchIndices, CharRange};\n pub use core::str::{Split, SplitTerminator, SplitN};\n pub use core::str::{RSplit, RSplitN};\n-pub use core::str::{from_utf8, CharEq, Chars, CharIndices, Bytes};\n-pub use core::str::{from_utf8_unchecked, from_c_str, ParseBoolError};\n+pub use core::str::{from_utf8, Chars, CharIndices, Bytes};\n+pub use core::str::{from_utf8_unchecked, ParseBoolError};\n pub use unicode::str::{Words, Graphemes, GraphemeIndices};\n pub use core::str::Pattern;\n pub use core::str::{Searcher, ReverseSearcher, DoubleEndedSearcher, SearchStep};\n@@ -536,22 +536,6 @@ impl str {\n         core_str::StrExt::contains(&self[..], pat)\n     }\n \n-    /// Returns `true` if `self` contains a `char`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// # #![feature(collections)]\n-    /// assert!(\"hello\".contains_char('e'));\n-    ///\n-    /// assert!(!\"hello\".contains_char('z'));\n-    /// ```\n-    #[unstable(feature = \"collections\")]\n-    #[deprecated(since = \"1.0.0\", reason = \"use `contains()` with a char\")]\n-    pub fn contains_char<'a, P: Pattern<'a>>(&'a self, pat: P) -> bool {\n-        core_str::StrExt::contains_char(&self[..], pat)\n-    }\n-\n     /// An iterator over the codepoints of `self`.\n     ///\n     /// # Examples\n@@ -778,25 +762,6 @@ impl str {\n         core_str::StrExt::match_indices(&self[..], pat)\n     }\n \n-    /// An iterator over the substrings of `self` separated by a `&str`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// # #![feature(collections)]\n-    /// let v: Vec<&str> = \"abcXXXabcYYYabc\".split_str(\"abc\").collect();\n-    /// assert_eq!(v, [\"\", \"XXX\", \"YYY\", \"\"]);\n-    ///\n-    /// let v: Vec<&str> = \"1abcabc2\".split_str(\"abc\").collect();\n-    /// assert_eq!(v, [\"1\", \"\", \"2\"]);\n-    /// ```\n-    #[unstable(feature = \"collections\")]\n-    #[deprecated(since = \"1.0.0\", reason = \"use `split()` with a `&str`\")]\n-    #[allow(deprecated) /* for SplitStr */]\n-    pub fn split_str<'a, P: Pattern<'a>>(&'a self, pat: P) -> SplitStr<'a, P> {\n-        core_str::StrExt::split_str(&self[..], pat)\n-    }\n-\n     /// An iterator over the lines of a string, separated by `\\n`.\n     ///\n     /// This does not include the empty string after a trailing `\\n`.\n@@ -848,31 +813,6 @@ impl str {\n     pub fn lines_any(&self) -> LinesAny {\n         core_str::StrExt::lines_any(&self[..])\n     }\n-\n-    /// Deprecated: use `s[a .. b]` instead.\n-    #[unstable(feature = \"collections\",\n-               reason = \"use slice notation [a..b] instead\")]\n-    #[deprecated(since = \"1.0.0\", reason = \"use slice notation [a..b] instead\")]\n-    pub fn slice(&self, begin: usize, end: usize) -> &str {\n-        &self[begin..end]\n-    }\n-\n-    /// Deprecated: use `s[a..]` instead.\n-    #[unstable(feature = \"collections\",\n-               reason = \"use slice notation [a..b] instead\")]\n-    #[deprecated(since = \"1.0.0\", reason = \"use slice notation [a..] instead\")]\n-    pub fn slice_from(&self, begin: usize) -> &str {\n-        &self[begin..]\n-    }\n-\n-    /// Deprecated: use `s[..a]` instead.\n-    #[unstable(feature = \"collections\",\n-               reason = \"use slice notation [a..b] instead\")]\n-    #[deprecated(since = \"1.0.0\", reason = \"use slice notation [..a] instead\")]\n-    pub fn slice_to(&self, end: usize) -> &str {\n-        &self[..end]\n-    }\n-\n     /// Returns a slice of the string from the character range [`begin`..`end`).\n     ///\n     /// That is, start at the `begin`-th code point of the string and continue\n@@ -1306,27 +1246,6 @@ impl str {\n         core_str::StrExt::rfind(&self[..], pat)\n     }\n \n-    /// Returns the byte index of the first matching substring if it exists.\n-    ///\n-    /// Returns `None` if it doesn't exist.\n-    ///\n-    /// The pattern can be a simple `&str`, or a closure that determines the split.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// # #![feature(collections)]\n-    /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n-    ///\n-    /// assert_eq!(s.find_str(\"\u8001\u864e L\"), Some(6));\n-    /// assert_eq!(s.find_str(\"muffin man\"), None);\n-    /// ```\n-    #[unstable(feature = \"collections\")]\n-    #[deprecated(since = \"1.0.0\", reason = \"use `find()` with a `&str`\")]\n-    pub fn find_str<'a, P: Pattern<'a>>(&'a self, needle: P) -> Option<usize> {\n-        core_str::StrExt::find_str(&self[..], needle)\n-    }\n-\n     /// Retrieves the first character from a `&str` and returns it.\n     ///\n     /// This does not allocate a new string; instead, it returns a slice that points one character"}, {"sha": "7ae5c6b5e6692ab2ff6fc3e077284b259305ee29", "filename": "src/libcollections/string.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Flibcollections%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Flibcollections%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstring.rs?ref=d4a2c941809f303b97d153e06ba07e95cd245f88", "patch": "@@ -1072,11 +1072,6 @@ impl<'a> Str for Cow<'a, str> {\n     }\n }\n \n-/// A clone-on-write string\n-#[deprecated(since = \"1.0.0\", reason = \"use Cow<'a, str> instead\")]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub type CowString<'a> = Cow<'a, str>;\n-\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl fmt::Write for String {\n     #[inline]"}, {"sha": "288cfc77d8964adf1a10e3071e352de7055ffd78", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=d4a2c941809f303b97d153e06ba07e95cd245f88", "patch": "@@ -1679,11 +1679,6 @@ impl<'a> From<&'a str> for Vec<u8> {\n // Clone-on-write\n ////////////////////////////////////////////////////////////////////////////////\n \n-/// A clone-on-write vector\n-#[deprecated(since = \"1.0.0\", reason = \"use Cow<'a, [T]> instead\")]\n-#[unstable(feature = \"collections\")]\n-pub type CowVec<'a, T> = Cow<'a, [T]>;\n-\n #[unstable(feature = \"collections\")]\n impl<'a, T> FromIterator<T> for Cow<'a, [T]> where T: Clone {\n     fn from_iter<I: IntoIterator<Item=T>>(it: I) -> Cow<'a, [T]> {"}, {"sha": "99a19b2a00b3593199f16d21a91ccde2c2113620", "filename": "src/libcollections/vec_deque.rs", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Flibcollections%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Flibcollections%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec_deque.rs?ref=d4a2c941809f303b97d153e06ba07e95cd245f88", "patch": "@@ -36,10 +36,6 @@ use core::cmp;\n \n use alloc::heap;\n \n-#[deprecated(since = \"1.0.0\", reason = \"renamed to VecDeque\")]\n-#[unstable(feature = \"collections\")]\n-pub use VecDeque as RingBuf;\n-\n const INITIAL_CAPACITY: usize = 7; // 2^3 - 1\n const MINIMUM_CAPACITY: usize = 1; // 2 - 1\n \n@@ -1902,7 +1898,7 @@ mod test {\n         // len is the length *after* insertion\n         for len in 1..cap {\n             // 0, 1, 2, .., len - 1\n-            let expected = iter::count(0, 1).take(len).collect();\n+            let expected = (0..).take(len).collect();\n             for tail_pos in 0..cap {\n                 for to_insert in 0..len {\n                     tester.tail = tail_pos;\n@@ -1935,7 +1931,7 @@ mod test {\n         // len is the length *after* removal\n         for len in 0..cap - 1 {\n             // 0, 1, 2, .., len - 1\n-            let expected = iter::count(0, 1).take(len).collect();\n+            let expected = (0..).take(len).collect();\n             for tail_pos in 0..cap {\n                 for to_remove in 0..len + 1 {\n                     tester.tail = tail_pos;\n@@ -1973,7 +1969,7 @@ mod test {\n \n         for len in 0..cap + 1 {\n             // 0, 1, 2, .., len - 1\n-            let expected = iter::count(0, 1).take(len).collect();\n+            let expected = (0..).take(len).collect();\n             for tail_pos in 0..max_cap + 1 {\n                 tester.tail = tail_pos;\n                 tester.head = tail_pos;\n@@ -2006,9 +2002,9 @@ mod test {\n             // index to split at\n             for at in 0..len + 1 {\n                 // 0, 1, 2, .., at - 1 (may be empty)\n-                let expected_self = iter::count(0, 1).take(at).collect();\n+                let expected_self = (0..).take(at).collect();\n                 // at, at + 1, .., len - 1 (may be empty)\n-                let expected_other = iter::count(at, 1).take(len - at).collect();\n+                let expected_other = (at..).take(len - at).collect();\n \n                 for tail_pos in 0..cap {\n                     tester.tail = tail_pos;"}, {"sha": "19ea25ee345fae46e07067f200ab34dc9ad907d2", "filename": "src/libcollectionstest/bit/set.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Flibcollectionstest%2Fbit%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Flibcollectionstest%2Fbit%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Fbit%2Fset.rs?ref=d4a2c941809f303b97d153e06ba07e95cd245f88", "patch": "@@ -10,7 +10,6 @@\n \n use std::cmp::Ordering::{Equal, Greater, Less};\n use std::collections::{BitSet, BitVec};\n-use std::iter::range_step;\n \n #[test]\n fn test_bit_set_show() {\n@@ -42,7 +41,7 @@ fn test_bit_set_iterator() {\n     assert_eq!(idxs, [0, 2, 3]);\n \n     let long: BitSet = (0..10000).filter(|&n| n % 2 == 0).collect();\n-    let real: Vec<_> = range_step(0, 10000, 2).collect();\n+    let real: Vec<_> = (0..10000).step_by(2).collect();\n \n     let idxs: Vec<_> = long.iter().collect();\n     assert_eq!(idxs, real);"}, {"sha": "70e21c65a1806549eb10764d5bbb67ddfb616a6e", "filename": "src/libcollectionstest/fmt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Flibcollectionstest%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Flibcollectionstest%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Ffmt.rs?ref=d4a2c941809f303b97d153e06ba07e95cd245f88", "patch": "@@ -13,5 +13,5 @@ use std::fmt;\n #[test]\n fn test_format() {\n     let s = fmt::format(format_args!(\"Hello, {}!\", \"world\"));\n-    assert_eq!(s.as_slice(), \"Hello, world!\");\n+    assert_eq!(s, \"Hello, world!\");\n }"}, {"sha": "456c658a9c6dc82d03b861cd50b8cf51ad6a245b", "filename": "src/libcollectionstest/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Flibcollectionstest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Flibcollectionstest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Flib.rs?ref=d4a2c941809f303b97d153e06ba07e95cd245f88", "patch": "@@ -8,7 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![allow(deprecated)]\n #![feature(box_syntax)]\n #![feature(collections)]\n #![feature(core)]\n@@ -21,6 +20,7 @@\n #![feature(unicode)]\n #![feature(unsafe_destructor)]\n #![feature(into_cow)]\n+#![feature(step_by)]\n #![cfg_attr(test, feature(str_char))]\n \n #[macro_use] extern crate log;"}, {"sha": "041d9fba57cc35169b0e4921e7a3af053e69d9ad", "filename": "src/libcollectionstest/slice.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Flibcollectionstest%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Flibcollectionstest%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Fslice.rs?ref=d4a2c941809f303b97d153e06ba07e95cd245f88", "patch": "@@ -59,7 +59,7 @@ fn test_from_elem() {\n     // Test on-heap from_elem.\n     v = vec![20; 6];\n     {\n-        let v = v.as_slice();\n+        let v = &v[..];\n         assert_eq!(v[0], 20);\n         assert_eq!(v[1], 20);\n         assert_eq!(v[2], 20);\n@@ -685,7 +685,7 @@ fn test_capacity() {\n #[test]\n fn test_slice_2() {\n     let v = vec![1, 2, 3, 4, 5];\n-    let v = v.slice(1, 3);\n+    let v = &v[1..3];\n     assert_eq!(v.len(), 2);\n     assert_eq!(v[0], 2);\n     assert_eq!(v[1], 3);"}, {"sha": "72a9f596d884b9336e70c8933735701688d3204d", "filename": "src/libcollectionstest/str.rs", "status": "modified", "additions": 48, "deletions": 61, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Flibcollectionstest%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Flibcollectionstest%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Fstr.rs?ref=d4a2c941809f303b97d153e06ba07e95cd245f88", "patch": "@@ -89,32 +89,32 @@ fn test_into_bytes() {\n #[test]\n fn test_find_str() {\n     // byte positions\n-    assert_eq!(\"\".find_str(\"\"), Some(0));\n-    assert!(\"banana\".find_str(\"apple pie\").is_none());\n+    assert_eq!(\"\".find(\"\"), Some(0));\n+    assert!(\"banana\".find(\"apple pie\").is_none());\n \n     let data = \"abcabc\";\n-    assert_eq!(data[0..6].find_str(\"ab\"), Some(0));\n-    assert_eq!(data[2..6].find_str(\"ab\"), Some(3 - 2));\n-    assert!(data[2..4].find_str(\"ab\").is_none());\n+    assert_eq!(data[0..6].find(\"ab\"), Some(0));\n+    assert_eq!(data[2..6].find(\"ab\"), Some(3 - 2));\n+    assert!(data[2..4].find(\"ab\").is_none());\n \n     let string = \"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n     let mut data = String::from_str(string);\n     data.push_str(string);\n-    assert!(data.find_str(\"\u0e44\u0e17\u534e\").is_none());\n-    assert_eq!(data[0..43].find_str(\"\"), Some(0));\n-    assert_eq!(data[6..43].find_str(\"\"), Some(6 - 6));\n+    assert!(data.find(\"\u0e44\u0e17\u534e\").is_none());\n+    assert_eq!(data[0..43].find(\"\"), Some(0));\n+    assert_eq!(data[6..43].find(\"\"), Some(6 - 6));\n \n-    assert_eq!(data[0..43].find_str(\"\u0e1b\u0e23\u0e30\"), Some( 0));\n-    assert_eq!(data[0..43].find_str(\"\u0e17\u0e28\u0e44\"), Some(12));\n-    assert_eq!(data[0..43].find_str(\"\u0e22\u4e2d\"), Some(24));\n-    assert_eq!(data[0..43].find_str(\"i\u1ec7t\"), Some(34));\n-    assert_eq!(data[0..43].find_str(\"Nam\"), Some(40));\n+    assert_eq!(data[0..43].find(\"\u0e1b\u0e23\u0e30\"), Some( 0));\n+    assert_eq!(data[0..43].find(\"\u0e17\u0e28\u0e44\"), Some(12));\n+    assert_eq!(data[0..43].find(\"\u0e22\u4e2d\"), Some(24));\n+    assert_eq!(data[0..43].find(\"i\u1ec7t\"), Some(34));\n+    assert_eq!(data[0..43].find(\"Nam\"), Some(40));\n \n-    assert_eq!(data[43..86].find_str(\"\u0e1b\u0e23\u0e30\"), Some(43 - 43));\n-    assert_eq!(data[43..86].find_str(\"\u0e17\u0e28\u0e44\"), Some(55 - 43));\n-    assert_eq!(data[43..86].find_str(\"\u0e22\u4e2d\"), Some(67 - 43));\n-    assert_eq!(data[43..86].find_str(\"i\u1ec7t\"), Some(77 - 43));\n-    assert_eq!(data[43..86].find_str(\"Nam\"), Some(83 - 43));\n+    assert_eq!(data[43..86].find(\"\u0e1b\u0e23\u0e30\"), Some(43 - 43));\n+    assert_eq!(data[43..86].find(\"\u0e17\u0e28\u0e44\"), Some(55 - 43));\n+    assert_eq!(data[43..86].find(\"\u0e22\u4e2d\"), Some(67 - 43));\n+    assert_eq!(data[43..86].find(\"i\u1ec7t\"), Some(77 - 43));\n+    assert_eq!(data[43..86].find(\"Nam\"), Some(83 - 43));\n }\n \n #[test]\n@@ -297,16 +297,16 @@ fn test_replace_2d() {\n \n #[test]\n fn test_slice() {\n-    assert_eq!(\"ab\", \"abc\".slice(0, 2));\n-    assert_eq!(\"bc\", \"abc\".slice(1, 3));\n-    assert_eq!(\"\", \"abc\".slice(1, 1));\n-    assert_eq!(\"\\u{65e5}\", \"\\u{65e5}\\u{672c}\".slice(0, 3));\n+    assert_eq!(\"ab\", &\"abc\"[0..2]);\n+    assert_eq!(\"bc\", &\"abc\"[1..3]);\n+    assert_eq!(\"\", &\"abc\"[1..1]);\n+    assert_eq!(\"\\u{65e5}\", &\"\\u{65e5}\\u{672c}\"[0..3]);\n \n     let data = \"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534e\";\n-    assert_eq!(\"\u0e1b\", data.slice(0, 3));\n-    assert_eq!(\"\u0e23\", data.slice(3, 6));\n-    assert_eq!(\"\", data.slice(3, 3));\n-    assert_eq!(\"\u534e\", data.slice(30, 33));\n+    assert_eq!(\"\u0e1b\", &data[0..3]);\n+    assert_eq!(\"\u0e23\", &data[3..6]);\n+    assert_eq!(\"\", &data[3..3]);\n+    assert_eq!(\"\u534e\", &data[30..33]);\n \n     fn a_million_letter_x() -> String {\n         let mut i = 0;\n@@ -328,23 +328,23 @@ fn test_slice() {\n     }\n     let letters = a_million_letter_x();\n     assert!(half_a_million_letter_x() ==\n-        String::from_str(letters.slice(0, 3 * 500000)));\n+        String::from_str(&letters[0..3 * 500000]));\n }\n \n #[test]\n fn test_slice_2() {\n     let ss = \"\u4e2d\u534eVi\u1ec7t Nam\";\n \n-    assert_eq!(\"\u534e\", ss.slice(3, 6));\n-    assert_eq!(\"Vi\u1ec7t Nam\", ss.slice(6, 16));\n+    assert_eq!(\"\u534e\", &ss[3..6]);\n+    assert_eq!(\"Vi\u1ec7t Nam\", &ss[6..16]);\n \n-    assert_eq!(\"ab\", \"abc\".slice(0, 2));\n-    assert_eq!(\"bc\", \"abc\".slice(1, 3));\n-    assert_eq!(\"\", \"abc\".slice(1, 1));\n+    assert_eq!(\"ab\", &\"abc\"[0..2]);\n+    assert_eq!(\"bc\", &\"abc\"[1..3]);\n+    assert_eq!(\"\", &\"abc\"[1..1]);\n \n-    assert_eq!(\"\u4e2d\", ss.slice(0, 3));\n-    assert_eq!(\"\u534eV\", ss.slice(3, 7));\n-    assert_eq!(\"\", ss.slice(3, 3));\n+    assert_eq!(\"\u4e2d\", &ss[0..3]);\n+    assert_eq!(\"\u534eV\", &ss[3..7]);\n+    assert_eq!(\"\", &ss[3..3]);\n     /*0: \u4e2d\n       3: \u534e\n       6: V\n@@ -360,20 +360,20 @@ fn test_slice_2() {\n #[test]\n #[should_panic]\n fn test_slice_fail() {\n-    \"\u4e2d\u534eVi\u1ec7t Nam\".slice(0, 2);\n+    &\"\u4e2d\u534eVi\u1ec7t Nam\"[0..2];\n }\n \n #[test]\n fn test_slice_from() {\n-    assert_eq!(\"abcd\".slice_from(0), \"abcd\");\n-    assert_eq!(\"abcd\".slice_from(2), \"cd\");\n-    assert_eq!(\"abcd\".slice_from(4), \"\");\n+    assert_eq!(&\"abcd\"[0..], \"abcd\");\n+    assert_eq!(&\"abcd\"[2..], \"cd\");\n+    assert_eq!(&\"abcd\"[4..], \"\");\n }\n #[test]\n fn test_slice_to() {\n-    assert_eq!(\"abcd\".slice_to(0), \"\");\n-    assert_eq!(\"abcd\".slice_to(2), \"ab\");\n-    assert_eq!(\"abcd\".slice_to(4), \"abcd\");\n+    assert_eq!(&\"abcd\"[..0], \"\");\n+    assert_eq!(&\"abcd\"[..2], \"ab\");\n+    assert_eq!(&\"abcd\"[..4], \"abcd\");\n }\n \n #[test]\n@@ -660,10 +660,10 @@ fn test_contains() {\n \n #[test]\n fn test_contains_char() {\n-    assert!(\"abc\".contains_char('b'));\n-    assert!(\"a\".contains_char('a'));\n-    assert!(!\"abc\".contains_char('d'));\n-    assert!(!\"\".contains_char('a'));\n+    assert!(\"abc\".contains('b'));\n+    assert!(\"a\".contains('a'));\n+    assert!(!\"abc\".contains('d'));\n+    assert!(!\"\".contains('a'));\n }\n \n #[test]\n@@ -1445,9 +1445,9 @@ fn test_graphemes() {\n }\n \n #[test]\n-fn test_split_strator() {\n+fn test_splitator() {\n     fn t(s: &str, sep: &str, u: &[&str]) {\n-        let v: Vec<&str> = s.split_str(sep).collect();\n+        let v: Vec<&str> = s.split(sep).collect();\n         assert_eq!(v, u);\n     }\n     t(\"--1233345--\", \"12345\", &[\"--1233345--\"]);\n@@ -1466,19 +1466,6 @@ fn test_split_strator() {\n     t(\"zzzzz\", \"zz\", &[\"\",\"\",\"z\"]);\n }\n \n-#[test]\n-fn test_str_default() {\n-    use std::default::Default;\n-\n-    fn t<S: Default + Str>() {\n-        let s: S = Default::default();\n-        assert_eq!(s.as_slice(), \"\");\n-    }\n-\n-    t::<&str>();\n-    t::<String>();\n-}\n-\n #[test]\n fn test_str_container() {\n     fn sum_len(v: &[&str]) -> usize {"}, {"sha": "5d6aa8ac0dcc37aa181ad829c2e0ee0e97d6e803", "filename": "src/libcollectionstest/string.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Flibcollectionstest%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Flibcollectionstest%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Fstring.rs?ref=d4a2c941809f303b97d153e06ba07e95cd245f88", "patch": "@@ -8,10 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::borrow::IntoCow;\n+use std::borrow::{IntoCow, Cow};\n use std::iter::repeat;\n use std::str::Utf8Error;\n-use std::string::{CowString, as_string};\n+use std::string::as_string;\n \n use test::Bencher;\n \n@@ -52,11 +52,11 @@ fn test_from_utf8() {\n #[test]\n fn test_from_utf8_lossy() {\n     let xs = b\"hello\";\n-    let ys: CowString = \"hello\".into_cow();\n+    let ys: Cow<str> = \"hello\".into_cow();\n     assert_eq!(String::from_utf8_lossy(xs), ys);\n \n     let xs = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\".as_bytes();\n-    let ys: CowString = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\".into_cow();\n+    let ys: Cow<str> = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\".into_cow();\n     assert_eq!(String::from_utf8_lossy(xs), ys);\n \n     let xs = b\"Hello\\xC2 There\\xFF Goodbye\";"}, {"sha": "ec03ce620fd320a0e66aceb327df85e78e7d6806", "filename": "src/libcollectionstest/vec_deque.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Flibcollectionstest%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Flibcollectionstest%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Fvec_deque.rs?ref=d4a2c941809f303b97d153e06ba07e95cd245f88", "patch": "@@ -18,7 +18,6 @@ use self::Taggy::*;\n use self::Taggypar::*;\n \n #[test]\n-#[allow(deprecated)]\n fn test_simple() {\n     let mut d = VecDeque::new();\n     assert_eq!(d.len(), 0);\n@@ -545,7 +544,7 @@ fn test_from_iter() {\n     let u: Vec<_> = deq.iter().cloned().collect();\n     assert_eq!(u, v);\n \n-    let seq = iter::count(0, 2).take(256);\n+    let seq = (0..).step_by(2).take(256);\n     let deq: VecDeque<_> = seq.collect();\n     for (i, &x) in deq.iter().enumerate() {\n         assert_eq!(2*i, x);"}, {"sha": "8c396a4e7fbcb1768e74efb576fbb4d33b163040", "filename": "src/libcore/atomic.rs", "status": "modified", "additions": 0, "deletions": 141, "changes": 141, "blob_url": "https://github.com/rust-lang/rust/blob/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Flibcore%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Flibcore%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fatomic.rs?ref=d4a2c941809f303b97d153e06ba07e95cd245f88", "patch": "@@ -1062,144 +1062,3 @@ pub fn fence(order: Ordering) {\n         }\n     }\n }\n-\n-#[unstable(feature = \"core\")]\n-#[deprecated(since = \"1.0.0\",\n-             reason = \"renamed to AtomicIsize\")]\n-#[allow(missing_docs)]\n-pub struct AtomicInt {\n-    v: UnsafeCell<isize>,\n-}\n-\n-#[allow(deprecated)]\n-unsafe impl Sync for AtomicInt {}\n-\n-#[unstable(feature = \"core\")]\n-#[deprecated(since = \"1.0.0\",\n-             reason = \"renamed to AtomicUsize\")]\n-#[allow(missing_docs)]\n-pub struct AtomicUint {\n-    v: UnsafeCell<usize>,\n-}\n-\n-#[allow(deprecated)]\n-unsafe impl Sync for AtomicUint {}\n-\n-#[unstable(feature = \"core\")]\n-#[deprecated(since = \"1.0.0\",\n-             reason = \"use ATOMIC_ISIZE_INIT instead\")]\n-#[allow(missing_docs, deprecated)]\n-pub const ATOMIC_INT_INIT: AtomicInt =\n-        AtomicInt { v: UnsafeCell { value: 0 } };\n-#[unstable(feature = \"core\")]\n-#[deprecated(since = \"1.0.0\",\n-             reason = \"use ATOMIC_USIZE_INIT instead\")]\n-#[allow(missing_docs, deprecated)]\n-pub const ATOMIC_UINT_INIT: AtomicUint =\n-        AtomicUint { v: UnsafeCell { value: 0, } };\n-\n-#[allow(missing_docs, deprecated)]\n-impl AtomicInt {\n-    #[inline]\n-    pub fn new(v: isize) -> AtomicInt {\n-        AtomicInt {v: UnsafeCell::new(v)}\n-    }\n-\n-    #[inline]\n-    pub fn load(&self, order: Ordering) -> isize {\n-        unsafe { atomic_load(self.v.get(), order) }\n-    }\n-\n-    #[inline]\n-    pub fn store(&self, val: isize, order: Ordering) {\n-        unsafe { atomic_store(self.v.get(), val, order); }\n-    }\n-\n-    #[inline]\n-    pub fn swap(&self, val: isize, order: Ordering) -> isize {\n-        unsafe { atomic_swap(self.v.get(), val, order) }\n-    }\n-\n-    #[inline]\n-    pub fn compare_and_swap(&self, old: isize, new: isize, order: Ordering) -> isize {\n-        unsafe { atomic_compare_and_swap(self.v.get(), old, new, order) }\n-    }\n-\n-    #[inline]\n-    pub fn fetch_add(&self, val: isize, order: Ordering) -> isize {\n-        unsafe { atomic_add(self.v.get(), val, order) }\n-    }\n-\n-    #[inline]\n-    pub fn fetch_sub(&self, val: isize, order: Ordering) -> isize {\n-        unsafe { atomic_sub(self.v.get(), val, order) }\n-    }\n-\n-    #[inline]\n-    pub fn fetch_and(&self, val: isize, order: Ordering) -> isize {\n-        unsafe { atomic_and(self.v.get(), val, order) }\n-    }\n-\n-    #[inline]\n-    pub fn fetch_or(&self, val: isize, order: Ordering) -> isize {\n-        unsafe { atomic_or(self.v.get(), val, order) }\n-    }\n-\n-    #[inline]\n-    pub fn fetch_xor(&self, val: isize, order: Ordering) -> isize {\n-        unsafe { atomic_xor(self.v.get(), val, order) }\n-    }\n-}\n-\n-#[allow(missing_docs, deprecated)]\n-impl AtomicUint {\n-    #[inline]\n-    pub fn new(v: usize) -> AtomicUint {\n-        AtomicUint { v: UnsafeCell::new(v) }\n-    }\n-\n-    #[inline]\n-    pub fn load(&self, order: Ordering) -> usize {\n-        unsafe { atomic_load(self.v.get(), order) }\n-    }\n-\n-    #[inline]\n-    pub fn store(&self, val: usize, order: Ordering) {\n-        unsafe { atomic_store(self.v.get(), val, order); }\n-    }\n-\n-    #[inline]\n-    pub fn swap(&self, val: usize, order: Ordering) -> usize {\n-        unsafe { atomic_swap(self.v.get(), val, order) }\n-    }\n-\n-    #[inline]\n-    pub fn compare_and_swap(&self, old: usize, new: usize, order: Ordering) -> usize {\n-        unsafe { atomic_compare_and_swap(self.v.get(), old, new, order) }\n-    }\n-\n-    #[inline]\n-    pub fn fetch_add(&self, val: usize, order: Ordering) -> usize {\n-        unsafe { atomic_add(self.v.get(), val, order) }\n-    }\n-\n-    #[inline]\n-    pub fn fetch_sub(&self, val: usize, order: Ordering) -> usize {\n-        unsafe { atomic_sub(self.v.get(), val, order) }\n-    }\n-\n-    #[inline]\n-    pub fn fetch_and(&self, val: usize, order: Ordering) -> usize {\n-        unsafe { atomic_and(self.v.get(), val, order) }\n-    }\n-\n-    #[inline]\n-    pub fn fetch_or(&self, val: usize, order: Ordering) -> usize {\n-        unsafe { atomic_or(self.v.get(), val, order) }\n-    }\n-\n-    #[inline]\n-    pub fn fetch_xor(&self, val: usize, order: Ordering) -> usize {\n-        unsafe { atomic_xor(self.v.get(), val, order) }\n-    }\n-}"}, {"sha": "906c87f3ffda63132a2a7cce73e71447bf26016e", "filename": "src/libcore/cell.rs", "status": "modified", "additions": 0, "deletions": 34, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Flibcore%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Flibcore%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcell.rs?ref=d4a2c941809f303b97d153e06ba07e95cd245f88", "patch": "@@ -343,23 +343,6 @@ impl<T> RefCell<T> {\n         }\n     }\n \n-    /// Attempts to immutably borrow the wrapped value.\n-    ///\n-    /// The borrow lasts until the returned `Ref` exits scope. Multiple\n-    /// immutable borrows can be taken out at the same time.\n-    ///\n-    /// Returns `None` if the value is currently mutably borrowed.\n-    #[unstable(feature = \"core\", reason = \"may be renamed or removed\")]\n-    #[deprecated(since = \"1.0.0\",\n-                 reason = \"dispatch on `cell.borrow_state()` instead\")]\n-    #[inline]\n-    pub fn try_borrow<'a>(&'a self) -> Option<Ref<'a, T>> {\n-        match BorrowRef::new(&self.borrow) {\n-            Some(b) => Some(Ref { _value: unsafe { &*self.value.get() }, _borrow: b }),\n-            None => None,\n-        }\n-    }\n-\n     /// Immutably borrows the wrapped value.\n     ///\n     /// The borrow lasts until the returned `Ref` exits scope. Multiple\n@@ -407,23 +390,6 @@ impl<T> RefCell<T> {\n         }\n     }\n \n-    /// Mutably borrows the wrapped value.\n-    ///\n-    /// The borrow lasts until the returned `RefMut` exits scope. The value\n-    /// cannot be borrowed while this borrow is active.\n-    ///\n-    /// Returns `None` if the value is currently borrowed.\n-    #[unstable(feature = \"core\", reason = \"may be renamed or removed\")]\n-    #[deprecated(since = \"1.0.0\",\n-                 reason = \"dispatch on `cell.borrow_state()` instead\")]\n-    #[inline]\n-    pub fn try_borrow_mut<'a>(&'a self) -> Option<RefMut<'a, T>> {\n-        match BorrowRefMut::new(&self.borrow) {\n-            Some(b) => Some(RefMut { _value: unsafe { &mut *self.value.get() }, _borrow: b }),\n-            None => None,\n-        }\n-    }\n-\n     /// Mutably borrows the wrapped value.\n     ///\n     /// The borrow lasts until the returned `RefMut` exits scope. The value"}, {"sha": "bd5d8d32725000133597301820c13a065c6e6c30", "filename": "src/libcore/error.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Flibcore%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Flibcore%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ferror.rs?ref=d4a2c941809f303b97d153e06ba07e95cd245f88", "patch": "@@ -50,30 +50,30 @@\n //! ```\n //! #![feature(core)]\n //! use std::error::FromError;\n-//! use std::{io, str};\n //! use std::fs::File;\n+//! use std::io;\n //!\n //! enum MyError {\n //!     Io(io::Error),\n-//!     Utf8(str::Utf8Error),\n+//!     CustomError,\n //! }\n //!\n //! impl FromError<io::Error> for MyError {\n-//!     fn from_error(err: io::Error) -> MyError { MyError::Io(err) }\n+//!     fn from_error(err: io::Error) -> MyError {\n+//!         MyError::Io(err)\n+//!     }\n //! }\n //!\n-//! impl FromError<str::Utf8Error> for MyError {\n-//!     fn from_error(err: str::Utf8Error) -> MyError { MyError::Utf8(err) }\n-//! }\n-//!\n-//! #[allow(unused_variables)]\n //! fn open_and_map() -> Result<(), MyError> {\n-//!     let b = b\"foo.txt\";\n-//!     let s = try!(str::from_utf8(b));\n-//!     let f = try!(File::open(s));\n-//!\n+//!     let f = try!(File::open(\"foo.txt\"));\n+//!     let m = try!(work_with_file(&f));\n //!     // do something interesting here...\n-//!     Ok(())\n+//!     # Ok(())\n+//! }\n+//!\n+//! fn work_with_file(file: &File) -> Result<(), MyError> {\n+//!     // ...\n+//!     # return Ok(())\n //! }\n //! ```\n "}, {"sha": "93a7d2bb17b92237a305a8b5ac033060b51a12b1", "filename": "src/libcore/finally.rs", "status": "removed", "additions": 0, "deletions": 111, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/d754722a04b99fdcae0fd97fa2a4395521145ef2/src%2Flibcore%2Ffinally.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d754722a04b99fdcae0fd97fa2a4395521145ef2/src%2Flibcore%2Ffinally.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffinally.rs?ref=d754722a04b99fdcae0fd97fa2a4395521145ef2", "patch": "@@ -1,111 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! The Finally trait provides a method, `finally` on\n-//! stack closures that emulates Java-style try/finally blocks.\n-//!\n-//! Using the `finally` method is sometimes convenient, but the type rules\n-//! prohibit any shared, mutable state between the \"try\" case and the\n-//! \"finally\" case. For advanced cases, the `try_finally` function can\n-//! also be used. See that function for more details.\n-//!\n-//! # Examples\n-//!\n-//! ```\n-//! # #![feature(core)]\n-//! # #![feature(unboxed_closures)]\n-//!\n-//! use std::finally::Finally;\n-//!\n-//! (|| {\n-//!     // ...\n-//! }).finally(|| {\n-//!     // this code is always run\n-//! })\n-//! ```\n-\n-#![unstable(feature = \"core\")]\n-#![deprecated(since = \"1.0.0\",\n-              reason = \"It is unclear if this module is more robust than implementing \\\n-                        Drop on a custom type, and this module is being removed with no \\\n-                        replacement. Use a custom Drop implementation to regain existing \\\n-                        functionality.\")]\n-#![allow(deprecated)]\n-\n-use ops::{Drop, FnMut, FnOnce};\n-\n-/// A trait for executing a destructor unconditionally after a block of code,\n-/// regardless of whether the blocked fails.\n-pub trait Finally<T> {\n-    /// Executes this object, unconditionally running `dtor` after this block of\n-    /// code has run.\n-    fn finally<F>(&mut self, dtor: F) -> T where F: FnMut();\n-}\n-\n-impl<T, F> Finally<T> for F where F: FnMut() -> T {\n-    fn finally<G>(&mut self, mut dtor: G) -> T where G: FnMut() {\n-        try_finally(&mut (), self, |_, f| (*f)(), |_| dtor())\n-    }\n-}\n-\n-/// The most general form of the `finally` functions. The function\n-/// `try_fn` will be invoked first; whether or not it panics, the\n-/// function `finally_fn` will be invoked next. The two parameters\n-/// `mutate` and `drop` are used to thread state through the two\n-/// closures. `mutate` is used for any shared, mutable state that both\n-/// closures require access to; `drop` is used for any state that the\n-/// `try_fn` requires ownership of.\n-///\n-/// **WARNING:** While shared, mutable state between the try and finally\n-/// function is often necessary, one must be very careful; the `try`\n-/// function could have panicked at any point, so the values of the shared\n-/// state may be inconsistent.\n-///\n-/// # Examples\n-///\n-/// ```\n-/// # #![feature(core)]\n-/// use std::finally::try_finally;\n-///\n-/// struct State<'a> { buffer: &'a mut [u8], len: usize }\n-/// # let mut buf = [];\n-/// let mut state = State { buffer: &mut buf, len: 0 };\n-/// try_finally(\n-///     &mut state, (),\n-///     |state, ()| {\n-///         // use state.buffer, state.len\n-///     },\n-///     |state| {\n-///         // use state.buffer, state.len to cleanup\n-///     })\n-/// ```\n-pub fn try_finally<T, U, R, F, G>(mutate: &mut T, drop: U, try_fn: F, finally_fn: G) -> R where\n-    F: FnOnce(&mut T, U) -> R,\n-    G: FnMut(&mut T),\n-{\n-    let f = Finallyalizer {\n-        mutate: mutate,\n-        dtor: finally_fn,\n-    };\n-    try_fn(&mut *f.mutate, drop)\n-}\n-\n-struct Finallyalizer<'a, A:'a, F> where F: FnMut(&mut A) {\n-    mutate: &'a mut A,\n-    dtor: F,\n-}\n-\n-#[unsafe_destructor]\n-impl<'a, A, F> Drop for Finallyalizer<'a, A, F> where F: FnMut(&mut A) {\n-    #[inline]\n-    fn drop(&mut self) {\n-        (self.dtor)(self.mutate);\n-    }\n-}"}, {"sha": "6820a7025fca6f171cda155752bf60d6e258bf2d", "filename": "src/libcore/hash/sip.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Flibcore%2Fhash%2Fsip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Flibcore%2Fhash%2Fsip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhash%2Fsip.rs?ref=d4a2c941809f303b97d153e06ba07e95cd245f88", "patch": "@@ -114,11 +114,6 @@ impl SipHasher {\n         state\n     }\n \n-    /// Returns the computed hash.\n-    #[unstable(feature = \"hash\")]\n-    #[deprecated(since = \"1.0.0\", reason = \"renamed to finish\")]\n-    pub fn result(&self) -> u64 { self.finish() }\n-\n     fn reset(&mut self) {\n         self.length = 0;\n         self.v0 = self.k0 ^ 0x736f6d6570736575;"}, {"sha": "6af26e254b36d4b558e1c5d330605b6b3c55a74e", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 13, "deletions": 153, "changes": 166, "blob_url": "https://github.com/rust-lang/rust/blob/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=d4a2c941809f303b97d153e06ba07e95cd245f88", "patch": "@@ -66,8 +66,7 @@ use marker;\n use mem;\n use num::{Int, Zero, One, ToPrimitive};\n use ops::{Add, Sub, FnMut, RangeFrom};\n-use option::Option;\n-use option::Option::{Some, None};\n+use option::Option::{self, Some, None};\n use marker::Sized;\n use usize;\n \n@@ -433,7 +432,7 @@ pub trait Iterator {\n     /// # #![feature(core)]\n     /// let xs = [2, 3];\n     /// let ys = [0, 1, 0, 1, 2];\n-    /// let it = xs.iter().flat_map(|&x| std::iter::count(0, 1).take(x));\n+    /// let it = xs.iter().flat_map(|&x| (0..).take(x));\n     /// // Check that `it` has the same elements as `ys`\n     /// for (i, x) in it.enumerate() {\n     ///     assert_eq!(x, ys[i]);\n@@ -1244,10 +1243,10 @@ pub trait MultiplicativeIterator<A> {\n     ///\n     /// ```\n     /// # #![feature(core)]\n-    /// use std::iter::{count, MultiplicativeIterator};\n+    /// use std::iter::MultiplicativeIterator;\n     ///\n     /// fn factorial(n: usize) -> usize {\n-    ///     count(1, 1).take_while(|&i| i <= n).product()\n+    ///     (1..).take_while(|&i| i <= n).product()\n     /// }\n     /// assert!(factorial(0) == 1);\n     /// assert!(factorial(1) == 1);\n@@ -2544,26 +2543,6 @@ impl<A: Step> ::ops::Range<A> {\n     }\n }\n \n-/// An infinite iterator starting at `start` and advancing by `step` with each\n-/// iteration\n-#[unstable(feature = \"core\",\n-           reason = \"may be renamed or replaced by range notation adapters\")]\n-#[deprecated(since = \"1.0.0-beta\", reason = \"use range notation and step_by\")]\n-pub type Counter<A> = StepBy<A, RangeFrom<A>>;\n-\n-/// Deprecated: use `(start..).step_by(step)` instead.\n-#[inline]\n-#[unstable(feature = \"core\",\n-           reason = \"may be renamed or replaced by range notation adapters\")]\n-#[deprecated(since = \"1.0.0-beta\", reason = \"use (start..).step_by(step) instead\")]\n-#[allow(deprecated)]\n-pub fn count<A>(start: A, step: A) -> Counter<A> {\n-    StepBy {\n-        range: RangeFrom { start: start },\n-        step_by: step,\n-    }\n-}\n-\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A> Iterator for StepBy<A, RangeFrom<A>> where\n     A: Clone,\n@@ -2584,126 +2563,28 @@ impl<A> Iterator for StepBy<A, RangeFrom<A>> where\n     }\n }\n \n-/// An iterator over the range [start, stop)\n-#[allow(deprecated)]\n-#[derive(Clone)]\n-#[unstable(feature = \"core\",\n-           reason = \"will be replaced by range notation\")]\n-#[deprecated(since = \"1.0.0-beta\", reason = \"use range notation\")]\n-pub struct Range<A> {\n-    state: A,\n-    stop: A,\n-    one: A,\n-}\n-\n-/// Deprecated: use `(start..stop)` instead.\n-#[inline]\n-#[unstable(feature = \"core\", reason = \"will be replaced by range notation\")]\n-#[deprecated(since = \"1.0.0-beta\", reason = \"use (start..stop) instead\")]\n-#[allow(deprecated)]\n-pub fn range<A: Int>(start: A, stop: A) -> Range<A> {\n-    Range {\n-        state: start,\n-        stop: stop,\n-        one: Int::one(),\n-    }\n-}\n-\n-// FIXME: #10414: Unfortunate type bound\n-#[unstable(feature = \"core\",\n-           reason = \"will be replaced by range notation\")]\n-#[deprecated(since = \"1.0.0-beta\", reason = \"use range notation\")]\n-#[allow(deprecated)]\n-impl<A: Int + ToPrimitive> Iterator for Range<A> {\n-    type Item = A;\n-\n-    #[inline]\n-    fn next(&mut self) -> Option<A> {\n-        if self.state < self.stop {\n-            let result = self.state.clone();\n-            self.state = self.state + self.one;\n-            Some(result)\n-        } else {\n-            None\n-        }\n-    }\n-\n-    #[inline]\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        // This first checks if the elements are representable as i64. If they aren't, try u64 (to\n-        // handle cases like range(huge, huger)). We don't use usize/isize because the difference of\n-        // the i64/u64 might lie within their range.\n-        let bound = match self.state.to_i64() {\n-            Some(a) => {\n-                let sz = self.stop.to_i64().map(|b| b.checked_sub(a));\n-                match sz {\n-                    Some(Some(bound)) => bound.to_usize(),\n-                    _ => None,\n-                }\n-            },\n-            None => match self.state.to_u64() {\n-                Some(a) => {\n-                    let sz = self.stop.to_u64().map(|b| b.checked_sub(a));\n-                    match sz {\n-                        Some(Some(bound)) => bound.to_usize(),\n-                        _ => None\n-                    }\n-                },\n-                None => None\n-            }\n-        };\n-\n-        match bound {\n-            Some(b) => (b, Some(b)),\n-            // Standard fallback for unbounded/unrepresentable bounds\n-            None => (0, None)\n-        }\n-    }\n-}\n-\n-/// `Int` is required to ensure the range will be the same regardless of\n-/// the direction it is consumed.\n-#[unstable(feature = \"core\",\n-           reason = \"will be replaced by range notation\")]\n-#[deprecated(since = \"1.0.0-beta\", reason = \"use range notation\")]\n-#[allow(deprecated)]\n-impl<A: Int + ToPrimitive> DoubleEndedIterator for Range<A> {\n-    #[inline]\n-    fn next_back(&mut self) -> Option<A> {\n-        if self.stop > self.state {\n-            self.stop = self.stop - self.one;\n-            Some(self.stop.clone())\n-        } else {\n-            None\n-        }\n-    }\n-}\n-\n /// An iterator over the range [start, stop]\n #[derive(Clone)]\n #[unstable(feature = \"core\",\n            reason = \"likely to be replaced by range notation and adapters\")]\n-#[allow(deprecated)]\n pub struct RangeInclusive<A> {\n-    range: Range<A>,\n+    range: ops::Range<A>,\n     done: bool,\n }\n \n /// Return an iterator over the range [start, stop]\n #[inline]\n #[unstable(feature = \"core\",\n            reason = \"likely to be replaced by range notation and adapters\")]\n-#[allow(deprecated)]\n pub fn range_inclusive<A: Int>(start: A, stop: A) -> RangeInclusive<A> {\n     RangeInclusive {\n-        range: range(start, stop),\n+        range: start..stop,\n         done: false,\n     }\n }\n \n #[unstable(feature = \"core\",\n            reason = \"likely to be replaced by range notation and adapters\")]\n-#[allow(deprecated)]\n impl<A: Int + ToPrimitive> Iterator for RangeInclusive<A> {\n     type Item = A;\n \n@@ -2712,9 +2593,9 @@ impl<A: Int + ToPrimitive> Iterator for RangeInclusive<A> {\n         match self.range.next() {\n             Some(x) => Some(x),\n             None => {\n-                if !self.done && self.range.state == self.range.stop {\n+                if !self.done && self.range.start == self.range.end {\n                     self.done = true;\n-                    Some(self.range.stop.clone())\n+                    Some(self.range.end.clone())\n                 } else {\n                     None\n                 }\n@@ -2740,43 +2621,22 @@ impl<A: Int + ToPrimitive> Iterator for RangeInclusive<A> {\n \n #[unstable(feature = \"core\",\n            reason = \"likely to be replaced by range notation and adapters\")]\n-#[allow(deprecated)]\n impl<A: Int + ToPrimitive> DoubleEndedIterator for RangeInclusive<A> {\n     #[inline]\n     fn next_back(&mut self) -> Option<A> {\n-        if self.range.stop > self.range.state {\n-            let result = self.range.stop.clone();\n-            self.range.stop = self.range.stop - self.range.one;\n+        if self.range.end > self.range.start {\n+            let result = self.range.end.clone();\n+            self.range.end = self.range.end - A::one();\n             Some(result)\n-        } else if !self.done && self.range.state == self.range.stop {\n+        } else if !self.done && self.range.start == self.range.end {\n             self.done = true;\n-            Some(self.range.stop.clone())\n+            Some(self.range.end.clone())\n         } else {\n             None\n         }\n     }\n }\n \n-/// An iterator over the range [start, stop) by `step`. It handles overflow by stopping.\n-#[unstable(feature = \"core\",\n-           reason = \"likely to be replaced by range notation and adapters\")]\n-#[deprecated(since = \"1.0.0-beta\", reason = \"use range notation and step_by\")]\n-pub type RangeStep<A> = StepBy<A, ::ops::Range<A>>;\n-\n-/// Deprecated: use `(start..stop).step_by(step)` instead.\n-#[inline]\n-#[unstable(feature = \"core\",\n-           reason = \"likely to be replaced by range notation and adapters\")]\n-#[deprecated(since = \"1.0.0-beta\",\n-             reason = \"use `(start..stop).step_by(step)` instead\")]\n-#[allow(deprecated)]\n-pub fn range_step<A: Int>(start: A, stop: A, step: A) -> RangeStep<A> {\n-    StepBy {\n-        step_by: step,\n-        range: ::ops::Range { start: start, end: stop },\n-    }\n-}\n-\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[allow(deprecated)]\n impl<A: Step + Zero + Clone> Iterator for StepBy<A, ::ops::Range<A>> {"}, {"sha": "5e8b7fba1f15c92e5dd53bdfefd6b3bd9a028a31", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=d4a2c941809f303b97d153e06ba07e95cd245f88", "patch": "@@ -136,7 +136,6 @@ pub mod atomic;\n pub mod cell;\n pub mod char;\n pub mod panicking;\n-pub mod finally;\n pub mod iter;\n pub mod option;\n pub mod raw;"}, {"sha": "07fac66d41c3f485dd4a1d2cbf590f6f19b81b54", "filename": "src/libcore/macros.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Flibcore%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Flibcore%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmacros.rs?ref=d4a2c941809f303b97d153e06ba07e95cd245f88", "patch": "@@ -233,7 +233,7 @@ macro_rules! writeln {\n /// ```\n /// # #![feature(core)]\n /// fn divide_by_three(x: u32) -> u32 { // one of the poorest implementations of x/3\n-///     for i in std::iter::count(0, 1) {\n+///     for i in 0.. {\n ///         if 3*i < i { panic!(\"u32 overflow\"); }\n ///         if x < 3*i { return i-1; }\n ///     }"}, {"sha": "339670435f1829b73275f16ede972701a40b1f1e", "filename": "src/libcore/marker.rs", "status": "modified", "additions": 0, "deletions": 36, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Flibcore%2Fmarker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Flibcore%2Fmarker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmarker.rs?ref=d4a2c941809f303b97d153e06ba07e95cd245f88", "patch": "@@ -415,42 +415,6 @@ mod impls {\n     unsafe impl<'a, T: Send + ?Sized> Send for &'a mut T {}\n }\n \n-/// Old-style marker trait. Deprecated.\n-#[unstable(feature = \"core\", reason = \"deprecated\")]\n-#[deprecated(since = \"1.0.0\", reason = \"Replace with `PhantomData<&'a ()>`\")]\n-#[lang=\"contravariant_lifetime\"]\n-pub struct ContravariantLifetime<'a>;\n-\n-/// Old-style marker trait. Deprecated.\n-#[unstable(feature = \"core\", reason = \"deprecated\")]\n-#[deprecated(since = \"1.0.0\", reason = \"Replace with `PhantomData<fn(&'a ())>`\")]\n-#[lang=\"covariant_lifetime\"]\n-pub struct CovariantLifetime<'a>;\n-\n-/// Old-style marker trait. Deprecated.\n-#[unstable(feature = \"core\", reason = \"deprecated\")]\n-#[deprecated(since = \"1.0.0\", reason = \"Replace with `PhantomData<Cell<&'a ()>>`\")]\n-#[lang=\"invariant_lifetime\"]\n-pub struct InvariantLifetime<'a>;\n-\n-/// Old-style marker trait. Deprecated.\n-#[unstable(feature = \"core\", reason = \"deprecated\")]\n-#[deprecated(since = \"1.0.0\", reason = \"Replace with `PhantomData<fn(T)>`\")]\n-#[lang=\"contravariant_type\"]\n-pub struct ContravariantType<T>;\n-\n-/// Old-style marker trait. Deprecated.\n-#[unstable(feature = \"core\", reason = \"deprecated\")]\n-#[deprecated(since = \"1.0.0\", reason = \"Replace with `PhantomData<T>`\")]\n-#[lang=\"covariant_type\"]\n-pub struct CovariantType<T>;\n-\n-/// Old-style marker trait. Deprecated.\n-#[unstable(feature = \"core\", reason = \"deprecated\")]\n-#[deprecated(since = \"1.0.0\", reason = \"Replace with `PhantomData<Cell<T>>`\")]\n-#[lang=\"invariant_type\"]\n-pub struct InvariantType<T>;\n-\n /// A marker trait indicates a type that can be reflected over. This\n /// trait is implemented for all types. Its purpose is to ensure that\n /// when you write a generic function that will employ reflection,"}, {"sha": "6db7c9bd99d9b08cb02fa3e12ca5d79e84bd695a", "filename": "src/libcore/option.rs", "status": "modified", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=d4a2c941809f303b97d153e06ba07e95cd245f88", "patch": "@@ -154,8 +154,6 @@ use mem;\n use ops::FnOnce;\n use result::Result::{Ok, Err};\n use result::Result;\n-#[allow(deprecated)]\n-use slice::AsSlice;\n use slice;\n \n // Note that this is not a lang item per se, but it has a hidden dependency on\n@@ -765,25 +763,6 @@ impl<T: Default> Option<T> {\n // Trait implementations\n /////////////////////////////////////////////////////////////////////////////\n \n-#[unstable(feature = \"core\",\n-           reason = \"waiting on the stability of the trait itself\")]\n-#[deprecated(since = \"1.0.0\",\n-             reason = \"use the inherent method instead\")]\n-#[allow(deprecated)]\n-impl<T> AsSlice<T> for Option<T> {\n-    /// Convert from `Option<T>` to `&[T]` (without copying)\n-    #[inline]\n-    fn as_slice<'a>(&'a self) -> &'a [T] {\n-        match *self {\n-            Some(ref x) => slice::ref_slice(x),\n-            None => {\n-                let result: &[_] = &[];\n-                result\n-            }\n-        }\n-    }\n-}\n-\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Default for Option<T> {\n     #[inline]"}, {"sha": "e60bc49408195644c331d56e35926db606000bb0", "filename": "src/libcore/prelude.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Flibcore%2Fprelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Flibcore%2Fprelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fprelude.rs?ref=d4a2c941809f303b97d153e06ba07e95cd245f88", "patch": "@@ -37,10 +37,11 @@ pub use char::CharExt;\n pub use clone::Clone;\n pub use cmp::{PartialEq, PartialOrd, Eq, Ord};\n pub use convert::{AsRef, AsMut, Into, From};\n-pub use iter::Extend;\n-pub use iter::{Iterator, DoubleEndedIterator};\n-pub use iter::{ExactSizeIterator};\n+pub use iter::{Iterator, DoubleEndedIterator, Extend, ExactSizeIterator};\n pub use option::Option::{self, Some, None};\n pub use result::Result::{self, Ok, Err};\n-pub use slice::{AsSlice, SliceExt};\n-pub use str::{Str, StrExt};\n+pub use slice::SliceExt;\n+pub use str::StrExt;\n+\n+#[allow(deprecated)] pub use slice::AsSlice;\n+#[allow(deprecated)] pub use str::Str;"}, {"sha": "ff51e25fcbf2535f9cf81a3d0129c7dc7aa556c3", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=d4a2c941809f303b97d153e06ba07e95cd245f88", "patch": "@@ -157,21 +157,6 @@ pub fn null<T>() -> *const T { 0 as *const T }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn null_mut<T>() -> *mut T { 0 as *mut T }\n \n-/// Zeroes out `count * size_of::<T>` bytes of memory at `dst`. `count` may be\n-/// `0`.\n-///\n-/// # Safety\n-///\n-/// Beyond accepting a raw pointer, this is unsafe because it will not drop the\n-/// contents of `dst`, and may be used to create invalid instances of `T`.\n-#[inline]\n-#[unstable(feature = \"core\",\n-           reason = \"may play a larger role in std::ptr future extensions\")]\n-#[deprecated(since = \"1.0.0\", reason = \"use `write_bytes` instead\")]\n-pub unsafe fn zero_memory<T>(dst: *mut T, count: usize) {\n-    write_bytes(dst, 0, count);\n-}\n-\n /// Swaps the values at two mutable locations of the same type, without\n /// deinitialising either. They may overlap, unlike `mem::swap` which is\n /// otherwise equivalent."}, {"sha": "47d1f3a1a3ccf1ab40ef385c921bd0c8e2f8b41c", "filename": "src/libcore/raw.rs", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Flibcore%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Flibcore%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fraw.rs?ref=d4a2c941809f303b97d153e06ba07e95cd245f88", "patch": "@@ -64,19 +64,6 @@ pub struct Slice<T> {\n \n impl<T> Copy for Slice<T> {}\n \n-/// The representation of an old closure.\n-#[repr(C)]\n-#[derive(Copy)]\n-#[unstable(feature = \"core\")]\n-#[deprecated(reason = \"unboxed new closures do not have a universal representation; \\\n-                       `&Fn` (etc) trait objects should use `TraitObject` instead\",\n-             since= \"1.0.0\")]\n-#[allow(deprecated) /* for deriving Copy impl */]\n-pub struct Closure {\n-    pub code: *mut (),\n-    pub env: *mut (),\n-}\n-\n /// The representation of a trait object like `&SomeTrait`.\n ///\n /// This struct has the same layout as types like `&SomeTrait` and"}, {"sha": "d8856130fab33b1d794ede0a0a6f966f73196701", "filename": "src/libcore/slice.rs", "status": "modified", "additions": 0, "deletions": 58, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Flibcore%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Flibcore%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice.rs?ref=d4a2c941809f303b97d153e06ba07e95cd245f88", "patch": "@@ -88,10 +88,6 @@ pub trait SliceExt {\n     fn len(&self) -> usize;\n     fn is_empty(&self) -> bool { self.len() == 0 }\n     fn get_mut<'a>(&'a mut self, index: usize) -> Option<&'a mut Self::Item>;\n-    #[unstable(feature = \"core\",\n-               reason = \"will be replaced by slice syntax\")]\n-    #[deprecated(since = \"1.0.0\", reason = \"use &mut s[..] instead\")]\n-    fn as_mut_slice<'a>(&'a mut self) -> &'a mut [Self::Item];\n     fn iter_mut<'a>(&'a mut self) -> IterMut<'a, Self::Item>;\n     fn first_mut<'a>(&'a mut self) -> Option<&'a mut Self::Item>;\n     fn tail_mut<'a>(&'a mut self) -> &'a mut [Self::Item];\n@@ -263,12 +259,6 @@ impl<T> SliceExt for [T] {\n         if index < self.len() { Some(&mut self[index]) } else { None }\n     }\n \n-    #[inline]\n-    #[unstable(feature = \"core\",\n-               reason = \"will be replaced by slice syntax\")]\n-    #[deprecated(since = \"1.0.0\", reason = \"use &mut s[..] instead\")]\n-    fn as_mut_slice(&mut self) -> &mut [T] { self }\n-\n     #[inline]\n     fn split_at_mut(&mut self, mid: usize) -> (&mut [T], &mut [T]) {\n         unsafe {\n@@ -1502,54 +1492,6 @@ pub unsafe fn from_raw_parts_mut<'a, T>(p: *mut T, len: usize) -> &'a mut [T] {\n     transmute(RawSlice { data: p, len: len })\n }\n \n-/// Forms a slice from a pointer and a length.\n-///\n-/// The pointer given is actually a reference to the base of the slice. This\n-/// reference is used to give a concrete lifetime to tie the returned slice to.\n-/// Typically this should indicate that the slice is valid for as long as the\n-/// pointer itself is valid.\n-///\n-/// The `len` argument is the number of **elements**, not the number of bytes.\n-///\n-/// This function is unsafe as there is no guarantee that the given pointer is\n-/// valid for `len` elements, nor whether the lifetime provided is a suitable\n-/// lifetime for the returned slice.\n-///\n-/// # Examples\n-///\n-/// ```\n-/// #![feature(core)]\n-/// use std::slice;\n-///\n-/// // manifest a slice out of thin air!\n-/// let ptr = 0x1234 as *const usize;\n-/// let amt = 10;\n-/// unsafe {\n-///     let slice = slice::from_raw_buf(&ptr, amt);\n-/// }\n-/// ```\n-#[inline]\n-#[unstable(feature = \"core\")]\n-#[deprecated(since = \"1.0.0\",\n-             reason = \"use from_raw_parts\")]\n-pub unsafe fn from_raw_buf<'a, T>(p: &'a *const T, len: usize) -> &'a [T] {\n-    transmute(RawSlice { data: *p, len: len })\n-}\n-\n-/// Performs the same functionality as `from_raw_buf`, except that a mutable\n-/// slice is returned.\n-///\n-/// This function is unsafe for the same reasons as `from_raw_buf`, as well as\n-/// not being able to provide a non-aliasing guarantee of the returned mutable\n-/// slice.\n-#[inline]\n-#[unstable(feature = \"core\")]\n-#[deprecated(since = \"1.0.0\",\n-             reason = \"use from_raw_parts_mut\")]\n-pub unsafe fn from_raw_mut_buf<'a, T>(p: &'a *mut T, len: usize) -> &'a mut [T] {\n-    transmute(RawSlice { data: *p, len: len })\n-}\n-\n //\n // Submodules\n //"}, {"sha": "934c4515614efc52dc97d3890c60908c5f98e391", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 0, "deletions": 98, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=d4a2c941809f303b97d153e06ba07e95cd245f88", "patch": "@@ -28,8 +28,6 @@ use iter::ExactSizeIterator;\n use iter::{Map, Iterator, DoubleEndedIterator};\n use marker::Sized;\n use mem;\n-#[allow(deprecated)]\n-use num::Int;\n use ops::{Fn, FnMut, FnOnce};\n use option::Option::{self, None, Some};\n use raw::{Repr, Slice};\n@@ -243,78 +241,6 @@ pub unsafe fn from_utf8_unchecked<'a>(v: &'a [u8]) -> &'a str {\n     mem::transmute(v)\n }\n \n-/// Constructs a static string slice from a given raw pointer.\n-///\n-/// This function will read memory starting at `s` until it finds a 0, and then\n-/// transmute the memory up to that point as a string slice, returning the\n-/// corresponding `&'static str` value.\n-///\n-/// This function is unsafe because the caller must ensure the C string itself\n-/// has the static lifetime and that the memory `s` is valid up to and including\n-/// the first null byte.\n-///\n-/// # Panics\n-///\n-/// This function will panic if the string pointed to by `s` is not valid UTF-8.\n-#[unstable(feature = \"core\")]\n-#[deprecated(since = \"1.0.0\",\n-             reason = \"use std::ffi::c_str_to_bytes + str::from_utf8\")]\n-pub unsafe fn from_c_str(s: *const i8) -> &'static str {\n-    let s = s as *const u8;\n-    let mut len: usize = 0;\n-    while *s.offset(len as isize) != 0 {\n-        len += 1;\n-    }\n-    let v: &'static [u8] = ::mem::transmute(Slice { data: s, len: len });\n-    from_utf8(v).ok().expect(\"from_c_str passed invalid utf-8 data\")\n-}\n-\n-/// Something that can be used to compare against a character\n-#[unstable(feature = \"core\")]\n-#[deprecated(since = \"1.0.0\",\n-             reason = \"use `Pattern` instead\")]\n-// NB: Rather than removing it, make it private and move it into self::pattern\n-pub trait CharEq {\n-    /// Determine if the splitter should split at the given character\n-    fn matches(&mut self, char) -> bool;\n-    /// Indicate if this is only concerned about ASCII characters,\n-    /// which can allow for a faster implementation.\n-    fn only_ascii(&self) -> bool;\n-}\n-\n-#[allow(deprecated) /* for CharEq */ ]\n-impl CharEq for char {\n-    #[inline]\n-    fn matches(&mut self, c: char) -> bool { *self == c }\n-\n-    #[inline]\n-    fn only_ascii(&self) -> bool { (*self as u32) < 128 }\n-}\n-\n-#[allow(deprecated) /* for CharEq */ ]\n-impl<F> CharEq for F where F: FnMut(char) -> bool {\n-    #[inline]\n-    fn matches(&mut self, c: char) -> bool { (*self)(c) }\n-\n-    #[inline]\n-    fn only_ascii(&self) -> bool { false }\n-}\n-\n-#[allow(deprecated) /* for CharEq */ ]\n-impl<'a> CharEq for &'a [char] {\n-    #[inline]\n-    #[allow(deprecated) /* for CharEq */ ]\n-    fn matches(&mut self, c: char) -> bool {\n-        self.iter().any(|&m| { let mut m = m; m.matches(c) })\n-    }\n-\n-    #[inline]\n-    #[allow(deprecated) /* for CharEq */ ]\n-    fn only_ascii(&self) -> bool {\n-        self.iter().all(|m| m.only_ascii())\n-    }\n-}\n-\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Error for Utf8Error {\n     fn description(&self) -> &str {\n@@ -1047,22 +973,6 @@ impl<'a, P: Pattern<'a>> Iterator for MatchIndices<'a, P> {\n     }\n }\n \n-/// An iterator over the substrings of a string separated by a given\n-/// search string\n-#[unstable(feature = \"core\")]\n-#[deprecated(since = \"1.0.0\", reason = \"use `Split` with a `&str`\")]\n-pub struct SplitStr<'a, P: Pattern<'a>>(Split<'a, P>);\n-#[allow(deprecated)]\n-impl<'a, P: Pattern<'a>> Iterator for SplitStr<'a, P> {\n-    type Item = &'a str;\n-\n-    #[inline]\n-    #[allow(deprecated)]\n-    fn next(&mut self) -> Option<&'a str> {\n-        Iterator::next(&mut self.0)\n-    }\n-}\n-\n impl<'a, 'b>  OldMatchIndices<'a, 'b> {\n     #[inline]\n     #[allow(dead_code)]\n@@ -1444,8 +1354,6 @@ pub trait StrExt {\n     fn rsplitn<'a, P: Pattern<'a>>(&'a self, count: usize, pat: P) -> RSplitN<'a, P>\n         where P::Searcher: ReverseSearcher<'a>;\n     fn match_indices<'a, P: Pattern<'a>>(&'a self, pat: P) -> MatchIndices<'a, P>;\n-    #[allow(deprecated) /* for SplitStr */]\n-    fn split_str<'a, P: Pattern<'a>>(&'a self, pat: P) -> SplitStr<'a, P>;\n     fn lines<'a>(&'a self) -> Lines<'a>;\n     fn lines_any<'a>(&'a self) -> LinesAny<'a>;\n     fn char_len(&self) -> usize;\n@@ -1565,12 +1473,6 @@ impl StrExt for str {\n         MatchIndices(pat.into_searcher(self))\n     }\n \n-    #[inline]\n-    #[allow(deprecated) /* for SplitStr */ ]\n-    fn split_str<'a, P: Pattern<'a>>(&'a self, pat: P) -> SplitStr<'a, P> {\n-        SplitStr(self.split(pat))\n-    }\n-\n     #[inline]\n     fn lines(&self) -> Lines {\n         Lines { inner: self.split_terminator('\\n').0 }"}, {"sha": "922ab2c14a6b71d9b19980267af365f06e204f5b", "filename": "src/libcore/str/pattern.rs", "status": "modified", "additions": 125, "deletions": 43, "changes": 168, "blob_url": "https://github.com/rust-lang/rust/blob/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Flibcore%2Fstr%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Flibcore%2Fstr%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fpattern.rs?ref=d4a2c941809f303b97d153e06ba07e95cd245f88", "patch": "@@ -8,10 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![allow(deprecated) /* for CharEq */ ]\n-\n use prelude::*;\n-use super::CharEq;\n \n // Pattern\n \n@@ -228,6 +225,40 @@ pub trait DoubleEndedSearcher<'a>: ReverseSearcher<'a> {}\n \n // Impl for a CharEq wrapper\n \n+#[doc(hidden)]\n+trait CharEq {\n+    fn matches(&mut self, char) -> bool;\n+    fn only_ascii(&self) -> bool;\n+}\n+\n+impl CharEq for char {\n+    #[inline]\n+    fn matches(&mut self, c: char) -> bool { *self == c }\n+\n+    #[inline]\n+    fn only_ascii(&self) -> bool { (*self as u32) < 128 }\n+}\n+\n+impl<F> CharEq for F where F: FnMut(char) -> bool {\n+    #[inline]\n+    fn matches(&mut self, c: char) -> bool { (*self)(c) }\n+\n+    #[inline]\n+    fn only_ascii(&self) -> bool { false }\n+}\n+\n+impl<'a> CharEq for &'a [char] {\n+    #[inline]\n+    fn matches(&mut self, c: char) -> bool {\n+        self.iter().any(|&m| { let mut m = m; m.matches(c) })\n+    }\n+\n+    #[inline]\n+    fn only_ascii(&self) -> bool {\n+        self.iter().all(|m| m.only_ascii())\n+    }\n+}\n+\n struct CharEqPattern<C: CharEq>(C);\n \n struct CharEqSearcher<'a, C: CharEq> {\n@@ -425,65 +456,116 @@ fn str_search_step<F, G>(mut m: &mut StrSearcher,\n     }\n }\n \n-macro_rules! associated_items {\n-    ($t:ty, $s:ident, $e:expr) => {\n-        // FIXME: #22463\n-        //type Searcher = $t;\n-\n-        fn into_searcher(self, haystack: &'a str) -> $t {\n-            let $s = self;\n-            $e.into_searcher(haystack)\n+macro_rules! char_eq_pattern_impl {\n+    ($wrapper:ty, $wrapper_ident:ident) => {\n+        fn into_searcher(self, haystack: &'a str) -> $wrapper {\n+            $wrapper_ident(CharEqPattern(self).into_searcher(haystack))\n         }\n-\n         #[inline]\n         fn is_contained_in(self, haystack: &'a str) -> bool {\n-            let $s = self;\n-            $e.is_contained_in(haystack)\n+            CharEqPattern(self).is_contained_in(haystack)\n         }\n-\n         #[inline]\n         fn is_prefix_of(self, haystack: &'a str) -> bool {\n-            let $s = self;\n-            $e.is_prefix_of(haystack)\n+            CharEqPattern(self).is_prefix_of(haystack)\n         }\n-\n-        // FIXME: #21750\n-        /*#[inline]\n+        #[inline]\n         fn is_suffix_of(self, haystack: &'a str) -> bool\n-            where $t: ReverseSearcher<'a>\n+            where $wrapper: ReverseSearcher<'a>\n         {\n-            let $s = self;\n-            $e.is_suffix_of(haystack)\n-        }*/\n+            CharEqPattern(self).is_suffix_of(haystack)\n+        }\n     }\n }\n \n-// CharEq delegation impls\n+// Pattern for char\n \n-/// Searches for chars that are equal to a given char\n impl<'a> Pattern<'a> for char {\n-    type Searcher =   <CharEqPattern<Self> as Pattern<'a>>::Searcher;\n-    associated_items!(<CharEqPattern<Self> as Pattern<'a>>::Searcher,\n-                      s, CharEqPattern(s));\n+    type Searcher = CharSearcher<'a>;\n+    char_eq_pattern_impl!(CharSearcher<'a>, CharSearcher);\n+}\n+\n+pub struct CharSearcher<'a>(CharEqSearcher<'a, char>);\n+\n+unsafe impl<'a> Searcher<'a> for CharSearcher<'a> {\n+    #[inline]\n+    fn haystack(&self) -> &'a str { self.0.haystack() }\n+    #[inline]\n+    fn next(&mut self) -> SearchStep { self.0.next() }\n+}\n+unsafe impl<'a> ReverseSearcher<'a> for CharSearcher<'a> {\n+    #[inline]\n+    fn next_back(&mut self) -> SearchStep { self.0.next_back() }\n }\n+impl<'a> DoubleEndedSearcher<'a> for CharSearcher<'a> {}\n+\n+// Pattern for &[char]\n \n-/// Searches for chars that are equal to any of the chars in the array\n impl<'a, 'b> Pattern<'a> for &'b [char] {\n-    type Searcher =   <CharEqPattern<Self> as Pattern<'a>>::Searcher;\n-    associated_items!(<CharEqPattern<Self> as Pattern<'a>>::Searcher,\n-                      s, CharEqPattern(s));\n+    type Searcher = CharSliceSearcher<'a, 'b>;\n+    char_eq_pattern_impl!(CharSliceSearcher<'a, 'b>, CharSliceSearcher);\n }\n \n-/// A convenience impl that delegates to the impl for `&str`\n-impl<'a, 'b> Pattern<'a> for &'b &'b str {\n-    type Searcher =   <&'b str as Pattern<'a>>::Searcher;\n-    associated_items!(<&'b str as Pattern<'a>>::Searcher,\n-                      s, (*s));\n+pub struct CharSliceSearcher<'a, 'b>(CharEqSearcher<'a, &'b [char]>);\n+\n+unsafe impl<'a, 'b> Searcher<'a> for CharSliceSearcher<'a, 'b> {\n+    #[inline]\n+    fn haystack(&self) -> &'a str { self.0.haystack() }\n+    #[inline]\n+    fn next(&mut self) -> SearchStep { self.0.next() }\n+}\n+unsafe impl<'a, 'b> ReverseSearcher<'a> for CharSliceSearcher<'a, 'b> {\n+    #[inline]\n+    fn next_back(&mut self) -> SearchStep { self.0.next_back() }\n+}\n+impl<'a, 'b> DoubleEndedSearcher<'a> for CharSliceSearcher<'a, 'b> {}\n+\n+// Pattern for predicates\n+\n+impl<'a, F: FnMut(char) -> bool> Pattern<'a> for F {\n+    type Searcher = CharPredSearcher<'a, F>;\n+    char_eq_pattern_impl!(CharPredSearcher<'a, F>, CharPredSearcher);\n+}\n+\n+pub struct CharPredSearcher<'a, F: FnMut(char) -> bool>(CharEqSearcher<'a, F>);\n+\n+unsafe impl<'a, F> Searcher<'a> for CharPredSearcher<'a, F>\n+    where F: FnMut(char) -> bool\n+{\n+    #[inline]\n+    fn haystack(&self) -> &'a str { self.0.haystack() }\n+    #[inline]\n+    fn next(&mut self) -> SearchStep { self.0.next() }\n+}\n+unsafe impl<'a, F> ReverseSearcher<'a> for CharPredSearcher<'a, F>\n+    where F: FnMut(char) -> bool\n+{\n+    #[inline]\n+    fn next_back(&mut self) -> SearchStep { self.0.next_back() }\n }\n+impl<'a, F> DoubleEndedSearcher<'a> for CharPredSearcher<'a, F>\n+    where F: FnMut(char) -> bool\n+{}\n \n-/// Searches for chars that match the given predicate\n-impl<'a, F> Pattern<'a> for F where F: FnMut(char) -> bool {\n-    type Searcher =   <CharEqPattern<Self> as Pattern<'a>>::Searcher;\n-    associated_items!(<CharEqPattern<Self> as Pattern<'a>>::Searcher,\n-                      s, CharEqPattern(s));\n+// Pattern for &&str\n+\n+impl<'a, 'b> Pattern<'a> for &'b &'b str {\n+    type Searcher = <&'b str as Pattern<'a>>::Searcher;\n+    #[inline]\n+    fn into_searcher(self, haystack: &'a str)\n+                     -> <&'b str as Pattern<'a>>::Searcher {\n+        (*self).into_searcher(haystack)\n+    }\n+    #[inline]\n+    fn is_contained_in(self, haystack: &'a str) -> bool {\n+        (*self).is_contained_in(haystack)\n+    }\n+    #[inline]\n+    fn is_prefix_of(self, haystack: &'a str) -> bool {\n+        (*self).is_prefix_of(haystack)\n+    }\n+    #[inline]\n+    fn is_suffix_of(self, haystack: &'a str) -> bool {\n+        (*self).is_suffix_of(haystack)\n+    }\n }"}, {"sha": "85dd10390038fadc92ac4e3faf3d260d029497d3", "filename": "src/libcoretest/cell.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Flibcoretest%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Flibcoretest%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fcell.rs?ref=d4a2c941809f303b97d153e06ba07e95cd245f88", "patch": "@@ -59,15 +59,13 @@ fn double_imm_borrow() {\n fn no_mut_then_imm_borrow() {\n     let x = RefCell::new(0);\n     let _b1 = x.borrow_mut();\n-    assert!(x.try_borrow().is_none());\n     assert_eq!(x.borrow_state(), BorrowState::Writing);\n }\n \n #[test]\n fn no_imm_then_borrow_mut() {\n     let x = RefCell::new(0);\n     let _b1 = x.borrow();\n-    assert!(x.try_borrow_mut().is_none());\n     assert_eq!(x.borrow_state(), BorrowState::Reading);\n }\n \n@@ -76,7 +74,6 @@ fn no_double_borrow_mut() {\n     let x = RefCell::new(0);\n     assert_eq!(x.borrow_state(), BorrowState::Unused);\n     let _b1 = x.borrow_mut();\n-    assert!(x.try_borrow_mut().is_none());\n     assert_eq!(x.borrow_state(), BorrowState::Writing);\n }\n \n@@ -105,7 +102,7 @@ fn double_borrow_single_release_no_borrow_mut() {\n     {\n         let _b2 = x.borrow();\n     }\n-    assert!(x.try_borrow_mut().is_none());\n+    assert_eq!(x.borrow_state(), BorrowState::Reading);\n }\n \n #[test]\n@@ -122,14 +119,14 @@ fn clone_ref_updates_flag() {\n     let x = RefCell::new(0);\n     {\n         let b1 = x.borrow();\n-        assert!(x.try_borrow_mut().is_none());\n+        assert_eq!(x.borrow_state(), BorrowState::Reading);\n         {\n             let _b2 = clone_ref(&b1);\n-            assert!(x.try_borrow_mut().is_none());\n+            assert_eq!(x.borrow_state(), BorrowState::Reading);\n         }\n-        assert!(x.try_borrow_mut().is_none());\n+        assert_eq!(x.borrow_state(), BorrowState::Reading);\n     }\n-    assert!(x.try_borrow_mut().is_some());\n+    assert_eq!(x.borrow_state(), BorrowState::Unused);\n }\n \n #[test]"}, {"sha": "2a48395271db3804ccb20a0b0c6be55bc67e72f4", "filename": "src/libcoretest/finally.rs", "status": "removed", "additions": 0, "deletions": 62, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/d754722a04b99fdcae0fd97fa2a4395521145ef2/src%2Flibcoretest%2Ffinally.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d754722a04b99fdcae0fd97fa2a4395521145ef2/src%2Flibcoretest%2Ffinally.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Ffinally.rs?ref=d754722a04b99fdcae0fd97fa2a4395521145ef2", "patch": "@@ -1,62 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#![allow(deprecated)]\n-\n-use core::finally::{try_finally, Finally};\n-use std::thread;\n-\n-#[test]\n-fn test_success() {\n-    let mut i = 0;\n-    try_finally(\n-        &mut i, (),\n-        |i, ()| {\n-            *i = 10;\n-        },\n-        |i| {\n-            assert!(!thread::panicking());\n-            assert_eq!(*i, 10);\n-            *i = 20;\n-        });\n-    assert_eq!(i, 20);\n-}\n-\n-#[test]\n-#[should_panic]\n-fn test_fail() {\n-    let mut i = 0;\n-    try_finally(\n-        &mut i, (),\n-        |i, ()| {\n-            *i = 10;\n-            panic!();\n-        },\n-        |i| {\n-            assert!(thread::panicking());\n-            assert_eq!(*i, 10);\n-        })\n-}\n-\n-#[test]\n-fn test_retval() {\n-    let mut closure = || 10;\n-    // FIXME(#16640) `: i32` annotation shouldn't be necessary\n-    let i: i32 = closure.finally(|| { });\n-    assert_eq!(i, 10);\n-}\n-\n-#[test]\n-fn test_compact() {\n-    fn do_some_fallible_work() {}\n-    fn but_always_run_this_function() { }\n-    let mut f = do_some_fallible_work;\n-    f.finally(but_always_run_this_function);\n-}"}, {"sha": "af80d347f028e02b66d4b8c572993c9b4d5edda4", "filename": "src/libcoretest/iter.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Flibcoretest%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Flibcoretest%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fiter.rs?ref=d4a2c941809f303b97d153e06ba07e95cd245f88", "patch": "@@ -72,7 +72,7 @@ fn test_multi_iter() {\n \n #[test]\n fn test_counter_from_iter() {\n-    let it = count(0, 5).take(10);\n+    let it = (0..).step_by(5).take(10);\n     let xs: Vec<isize> = FromIterator::from_iter(it);\n     assert_eq!(xs, [0, 5, 10, 15, 20, 25, 30, 35, 40, 45]);\n }\n@@ -90,7 +90,7 @@ fn test_iterator_chain() {\n     }\n     assert_eq!(i, expected.len());\n \n-    let ys = count(30, 10).take(4);\n+    let ys = (30..).step_by(10).take(4);\n     let it = xs.iter().cloned().chain(ys);\n     let mut i = 0;\n     for x in it {\n@@ -102,7 +102,7 @@ fn test_iterator_chain() {\n \n #[test]\n fn test_filter_map() {\n-    let it = count(0, 1).take(10)\n+    let it = (0..).step_by(1).take(10)\n         .filter_map(|x| if x % 2 == 0 { Some(x*x) } else { None });\n     assert_eq!(it.collect::<Vec<usize>>(), [0*0, 2*2, 4*4, 6*6, 8*8]);\n }\n@@ -244,7 +244,7 @@ fn test_iterator_scan() {\n fn test_iterator_flat_map() {\n     let xs = [0, 3, 6];\n     let ys = [0, 1, 2, 3, 4, 5, 6, 7, 8];\n-    let it = xs.iter().flat_map(|&x| count(x, 1).take(3));\n+    let it = xs.iter().flat_map(|&x| (x..).step_by(1).take(3));\n     let mut i = 0;\n     for x in it {\n         assert_eq!(x, ys[i]);\n@@ -291,13 +291,13 @@ fn test_unfoldr() {\n #[test]\n fn test_cycle() {\n     let cycle_len = 3;\n-    let it = count(0, 1).take(cycle_len).cycle();\n+    let it = (0..).step_by(1).take(cycle_len).cycle();\n     assert_eq!(it.size_hint(), (usize::MAX, None));\n     for (i, x) in it.take(100).enumerate() {\n         assert_eq!(i % cycle_len, x);\n     }\n \n-    let mut it = count(0, 1).take(0).cycle();\n+    let mut it = (0..).step_by(1).take(0).cycle();\n     assert_eq!(it.size_hint(), (0, Some(0)));\n     assert_eq!(it.next(), None);\n }\n@@ -360,7 +360,7 @@ fn test_iterator_min() {\n \n #[test]\n fn test_iterator_size_hint() {\n-    let c = count(0, 1);\n+    let c = (0..).step_by(1);\n     let v: &[_] = &[0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n     let v2 = &[10, 11, 12];\n     let vi = v.iter();"}, {"sha": "7ae0dcbb5f9d4b7cae3fda5196908395db025ead", "filename": "src/libcoretest/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Flibcoretest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Flibcoretest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Flib.rs?ref=d4a2c941809f303b97d153e06ba07e95cd245f88", "patch": "@@ -39,7 +39,6 @@ mod atomic;\n mod cell;\n mod char;\n mod cmp;\n-mod finally;\n mod fmt;\n mod hash;\n mod iter;"}, {"sha": "c935b5545740c6d8c6b8b8ba438fb069f93ede75", "filename": "src/libcoretest/str.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Flibcoretest%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Flibcoretest%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fstr.rs?ref=d4a2c941809f303b97d153e06ba07e95cd245f88", "patch": "@@ -163,9 +163,9 @@ fn starts_short_long() {\n \n #[test]\n fn contains_weird_cases() {\n-    assert!(\"* \\t\".contains_char(' '));\n-    assert!(!\"* \\t\".contains_char('?'));\n-    assert!(!\"* \\t\".contains_char('\\u{1F4A9}'));\n+    assert!(\"* \\t\".contains(' '));\n+    assert!(!\"* \\t\".contains('?'));\n+    assert!(!\"* \\t\".contains('\\u{1F4A9}'));\n }\n \n #[test]\n@@ -347,11 +347,11 @@ malesuada sollicitudin quam eu fermentum!\");\n     make_test!(chars_count, s, s.chars().count());\n \n     make_test!(contains_bang_str, s, s.contains(\"!\"));\n-    make_test!(contains_bang_char, s, s.contains_char('!'));\n+    make_test!(contains_bang_char, s, s.contains('!'));\n \n     make_test!(match_indices_a_str, s, s.match_indices(\"a\").count());\n \n-    make_test!(split_str_a_str, s, s.split_str(\"a\").count());\n+    make_test!(split_a_str, s, s.split(\"a\").count());\n \n     make_test!(trim_ascii_char, s, {\n         use std::ascii::AsciiExt;\n@@ -368,18 +368,18 @@ malesuada sollicitudin quam eu fermentum!\");\n \n     make_test!(find_underscore_char, s, s.find('_'));\n     make_test!(rfind_underscore_char, s, s.rfind('_'));\n-    make_test!(find_underscore_str, s, s.find_str(\"_\"));\n+    make_test!(find_underscore_str, s, s.find(\"_\"));\n \n     make_test!(find_zzz_char, s, s.find('\\u{1F4A4}'));\n     make_test!(rfind_zzz_char, s, s.rfind('\\u{1F4A4}'));\n-    make_test!(find_zzz_str, s, s.find_str(\"\\u{1F4A4}\"));\n+    make_test!(find_zzz_str, s, s.find(\"\\u{1F4A4}\"));\n \n     make_test!(split_space_char, s, s.split(' ').count());\n     make_test!(split_terminator_space_char, s, s.split_terminator(' ').count());\n \n     make_test!(splitn_space_char, s, s.splitn(10, ' ').count());\n     make_test!(rsplitn_space_char, s, s.rsplitn(10, ' ').count());\n \n-    make_test!(split_str_space_str, s, s.split_str(\" \").count());\n-    make_test!(split_str_ad_str, s, s.split_str(\"ad\").count());\n+    make_test!(split_space_str, s, s.split(\" \").count());\n+    make_test!(split_ad_str, s, s.split(\"ad\").count());\n }"}, {"sha": "44187a4fc99429002d292e679fb4af77bc5260d7", "filename": "src/librand/chacha.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Flibrand%2Fchacha.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Flibrand%2Fchacha.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fchacha.rs?ref=d4a2c941809f303b97d153e06ba07e95cd245f88", "patch": "@@ -198,7 +198,7 @@ impl Rand for ChaChaRng {\n         for word in &mut key {\n             *word = other.gen();\n         }\n-        SeedableRng::from_seed(key.as_slice())\n+        SeedableRng::from_seed(&key[..])\n     }\n }\n "}, {"sha": "d71a68e2050524970304e1147c739ce190e88558", "filename": "src/librustc/util/common.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Flibrustc%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Flibrustc%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fcommon.rs?ref=d4a2c941809f303b97d153e06ba07e95cd245f88", "patch": "@@ -228,8 +228,9 @@ pub fn memoized<T, U, S, F>(cache: &RefCell<HashMap<T, U, S>>, arg: T, f: F) ->\n #[cfg(unix)]\n pub fn path2cstr(p: &Path) -> CString {\n     use std::os::unix::prelude::*;\n-    use std::ffi::AsOsStr;\n-    CString::new(p.as_os_str().as_bytes()).unwrap()\n+    use std::ffi::OsStr;\n+    let p: &OsStr = p.as_ref();\n+    CString::new(p.as_bytes()).unwrap()\n }\n #[cfg(windows)]\n pub fn path2cstr(p: &Path) -> CString {"}, {"sha": "d3f3b1dad7847a014984cb41bdd4cf34f3790fb3", "filename": "src/librustc_back/fs.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Flibrustc_back%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Flibrustc_back%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ffs.rs?ref=d4a2c941809f303b97d153e06ba07e95cd245f88", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n use std::io;\n+use std::env;\n #[allow(deprecated)] use std::old_path::{self, GenericPath};\n #[allow(deprecated)] use std::old_io;\n use std::path::{Path, PathBuf};\n@@ -29,9 +30,9 @@ pub fn realpath(original: &Path) -> io::Result<PathBuf> {\n #[allow(deprecated)]\n fn old_realpath(original: &old_path::Path) -> old_io::IoResult<old_path::Path> {\n     use std::old_io::fs;\n-    use std::os;\n     const MAX_LINKS_FOLLOWED: usize = 256;\n-    let original = try!(os::getcwd()).join(original);\n+    let original = old_path::Path::new(env::current_dir().unwrap()\n+                                           .to_str().unwrap()).join(original);\n \n     // Right now lstat on windows doesn't work quite well\n     if cfg!(windows) {"}, {"sha": "0814d53acd198ce3254d6a721ca8d40752c664d1", "filename": "src/librustc_back/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Flibrustc_back%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Flibrustc_back%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Flib.rs?ref=d4a2c941809f303b97d153e06ba07e95cd245f88", "patch": "@@ -39,12 +39,10 @@\n #![feature(io)]\n #![feature(old_io)]\n #![feature(old_path)]\n-#![feature(os)]\n #![feature(rustc_private)]\n #![feature(staged_api)]\n #![feature(rand)]\n #![feature(path_ext)]\n-#![feature(std_misc)]\n #![feature(step_by)]\n #![feature(convert)]\n #![cfg_attr(test, feature(test, rand))]"}, {"sha": "898f20e74518fca23d44b4912ea5da69d2d7eb47", "filename": "src/librustc_back/sha2.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Flibrustc_back%2Fsha2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Flibrustc_back%2Fsha2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Fsha2.rs?ref=d4a2c941809f303b97d153e06ba07e95cd245f88", "patch": "@@ -14,7 +14,7 @@\n \n #![allow(deprecated)] // to_be32\n \n-use std::iter::{range_step, repeat};\n+use std::iter::repeat;\n use std::num::Int;\n use std::slice::bytes::{MutableByteVector, copy_memory};\n use serialize::hex::ToHex;\n@@ -368,7 +368,7 @@ impl Engine256State {\n \n         // Putting the message schedule inside the same loop as the round calculations allows for\n         // the compiler to generate better code.\n-        for t in range_step(0, 48, 8) {\n+        for t in (0..48).step_by(8) {\n             schedule_round!(t + 16);\n             schedule_round!(t + 17);\n             schedule_round!(t + 18);\n@@ -388,7 +388,7 @@ impl Engine256State {\n             sha2_round!(b, c, d, e, f, g, h, a, K32, t + 7);\n         }\n \n-        for t in range_step(48, 64, 8) {\n+        for t in (48..64).step_by(8) {\n             sha2_round!(a, b, c, d, e, f, g, h, K32, t);\n             sha2_round!(h, a, b, c, d, e, f, g, K32, t + 1);\n             sha2_round!(g, h, a, b, c, d, e, f, K32, t + 2);"}, {"sha": "6935499f5a0d42f16efad24d82c3dbe6d280a49b", "filename": "src/librustc_back/tempdir.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Flibrustc_back%2Ftempdir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Flibrustc_back%2Ftempdir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftempdir.rs?ref=d4a2c941809f303b97d153e06ba07e95cd245f88", "patch": "@@ -11,7 +11,7 @@\n use std::env;\n use std::io::{self, Error, ErrorKind};\n use std::fs;\n-use std::path::{self, PathBuf, AsPath};\n+use std::path::{self, PathBuf, Path};\n use std::rand::{thread_rng, Rng};\n \n /// A wrapper for a path to temporary directory implementing automatic\n@@ -36,10 +36,10 @@ impl TempDir {\n     ///\n     /// If no directory can be created, `Err` is returned.\n     #[allow(deprecated)] // rand usage\n-    pub fn new_in<P: AsPath + ?Sized>(tmpdir: &P, prefix: &str)\n-                                      -> io::Result<TempDir> {\n+    pub fn new_in<P: AsRef<Path>>(tmpdir: P, prefix: &str)\n+                                  -> io::Result<TempDir> {\n         let storage;\n-        let mut tmpdir = tmpdir.as_path();\n+        let mut tmpdir = tmpdir.as_ref();\n         if !tmpdir.is_absolute() {\n             let cur_dir = try!(env::current_dir());\n             storage = cur_dir.join(tmpdir);"}, {"sha": "647f4bc6a40fdbe7118dd31349b6de4657af6bae", "filename": "src/librustc_llvm/archive_ro.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Flibrustc_llvm%2Farchive_ro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Flibrustc_llvm%2Farchive_ro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Farchive_ro.rs?ref=d4a2c941809f303b97d153e06ba07e95cd245f88", "patch": "@@ -42,8 +42,9 @@ impl ArchiveRO {\n         #[cfg(unix)]\n         fn path2cstr(p: &Path) -> CString {\n             use std::os::unix::prelude::*;\n-            use std::ffi::AsOsStr;\n-            CString::new(p.as_os_str().as_bytes()).unwrap()\n+            use std::ffi::OsStr;\n+            let p: &OsStr = p.as_ref();\n+            CString::new(p.as_bytes()).unwrap()\n         }\n         #[cfg(windows)]\n         fn path2cstr(p: &Path) -> CString {"}, {"sha": "cba2188ef79068d4e8af2c564418339e984b15bf", "filename": "src/librustc_llvm/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Flibrustc_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Flibrustc_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Flib.rs?ref=d4a2c941809f303b97d153e06ba07e95cd245f88", "patch": "@@ -30,7 +30,7 @@\n #![feature(libc)]\n #![feature(link_args)]\n #![feature(staged_api)]\n-#![cfg_attr(unix, feature(std_misc))]\n+#![cfg_attr(unix, feature(convert))]\n \n extern crate libc;\n #[macro_use] #[no_link] extern crate rustc_bitflags;"}, {"sha": "f8c56b68577b4f9afa7ac58e5497b0a9d2ffafa5", "filename": "src/librustdoc/flock.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Flibrustdoc%2Fflock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Flibrustdoc%2Fflock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fflock.rs?ref=d4a2c941809f303b97d153e06ba07e95cd245f88", "patch": "@@ -20,7 +20,7 @@ pub use self::imp::Lock;\n \n #[cfg(unix)]\n mod imp {\n-    use std::ffi::{AsOsStr, CString};\n+    use std::ffi::{CString, OsStr};\n     use std::os::unix::prelude::*;\n     use std::path::Path;\n     use std::io;\n@@ -116,7 +116,8 @@ mod imp {\n \n     impl Lock {\n         pub fn new(p: &Path) -> Lock {\n-            let buf = CString::new(p.as_os_str().as_bytes()).unwrap();\n+            let os: &OsStr = p.as_ref();\n+            let buf = CString::new(os.as_bytes()).unwrap();\n             let fd = unsafe {\n                 libc::open(buf.as_ptr(), libc::O_RDWR | libc::O_CREAT,\n                            libc::S_IRWXU)\n@@ -164,9 +165,9 @@ mod imp {\n #[cfg(windows)]\n mod imp {\n     use libc;\n-    use std::ffi::AsOsStr;\n     use std::io;\n     use std::mem;\n+    use std::ffi::OsStr;\n     use std::os::windows::prelude::*;\n     use std::path::Path;\n     use std::ptr;\n@@ -194,7 +195,8 @@ mod imp {\n \n     impl Lock {\n         pub fn new(p: &Path) -> Lock {\n-            let mut p_16: Vec<_> = p.as_os_str().encode_wide().collect();\n+            let p: &OsStr = p.as_ref();\n+            let mut p_16: Vec<_> = p.encode_wide().collect();\n             p_16.push(0);\n             let handle = unsafe {\n                 libc::CreateFileW(p_16.as_ptr(),"}, {"sha": "053ceceb49621f1525c9eb54ea11ca9382d90bbd", "filename": "src/libstd/collections/hash/table.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs?ref=d4a2c941809f303b97d153e06ba07e95cd245f88", "patch": "@@ -15,7 +15,7 @@ use self::BucketState::*;\n use clone::Clone;\n use cmp;\n use hash::{Hash, Hasher};\n-use iter::{Iterator, ExactSizeIterator, count};\n+use iter::{Iterator, ExactSizeIterator};\n use marker::{Copy, Send, Sync, Sized, self};\n use mem::{min_align_of, size_of};\n use mem;"}, {"sha": "9a68a60361c042d385c3759f43aa206b19f04cab", "filename": "src/libstd/dynamic_lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Flibstd%2Fdynamic_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Flibstd%2Fdynamic_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fdynamic_lib.rs?ref=d4a2c941809f303b97d153e06ba07e95cd245f88", "patch": "@@ -18,7 +18,7 @@\n use prelude::v1::*;\n \n use env;\n-use ffi::{AsOsStr, CString, OsString};\n+use ffi::{CString, OsString};\n use mem;\n use path::{Path, PathBuf};\n "}, {"sha": "ec0e4b6737ffcede44434ac688627061cd942d7c", "filename": "src/libstd/env.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Flibstd%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Flibstd%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fenv.rs?ref=d4a2c941809f303b97d153e06ba07e95cd245f88", "patch": "@@ -20,7 +20,7 @@ use prelude::v1::*;\n \n use iter::IntoIterator;\n use error::Error;\n-use ffi::{OsString, AsOsStr};\n+use ffi::{OsStr, OsString};\n use fmt;\n use io;\n use path::{Path, PathBuf};\n@@ -176,7 +176,7 @@ impl Iterator for VarsOs {\n /// }\n /// ```\n #[stable(feature = \"env\", since = \"1.0.0\")]\n-pub fn var<K: ?Sized>(key: &K) -> Result<String, VarError> where K: AsOsStr {\n+pub fn var<K: ?Sized>(key: &K) -> Result<String, VarError> where K: AsRef<OsStr> {\n     match var_os(key) {\n         Some(s) => s.into_string().map_err(VarError::NotUnicode),\n         None => Err(VarError::NotPresent)\n@@ -198,9 +198,9 @@ pub fn var<K: ?Sized>(key: &K) -> Result<String, VarError> where K: AsOsStr {\n /// }\n /// ```\n #[stable(feature = \"env\", since = \"1.0.0\")]\n-pub fn var_os<K: ?Sized>(key: &K) -> Option<OsString> where K: AsOsStr {\n+pub fn var_os<K: ?Sized>(key: &K) -> Option<OsString> where K: AsRef<OsStr> {\n     let _g = ENV_LOCK.lock();\n-    os_imp::getenv(key.as_os_str())\n+    os_imp::getenv(key.as_ref())\n }\n \n /// Possible errors from the `env::var` method.\n@@ -255,17 +255,17 @@ impl Error for VarError {\n /// ```\n #[stable(feature = \"env\", since = \"1.0.0\")]\n pub fn set_var<K: ?Sized, V: ?Sized>(k: &K, v: &V)\n-    where K: AsOsStr, V: AsOsStr\n+    where K: AsRef<OsStr>, V: AsRef<OsStr>\n {\n     let _g = ENV_LOCK.lock();\n-    os_imp::setenv(k.as_os_str(), v.as_os_str())\n+    os_imp::setenv(k.as_ref(), v.as_ref())\n }\n \n /// Remove a variable from the environment entirely.\n #[stable(feature = \"env\", since = \"1.0.0\")]\n-pub fn remove_var<K: ?Sized>(k: &K) where K: AsOsStr {\n+pub fn remove_var<K: ?Sized>(k: &K) where K: AsRef<OsStr> {\n     let _g = ENV_LOCK.lock();\n-    os_imp::unsetenv(k.as_os_str())\n+    os_imp::unsetenv(k.as_ref())\n }\n \n /// An iterator over `Path` instances for parsing an environment variable\n@@ -296,8 +296,8 @@ pub struct SplitPaths<'a> { inner: os_imp::SplitPaths<'a> }\n /// }\n /// ```\n #[stable(feature = \"env\", since = \"1.0.0\")]\n-pub fn split_paths<T: AsOsStr + ?Sized>(unparsed: &T) -> SplitPaths {\n-    SplitPaths { inner: os_imp::split_paths(unparsed.as_os_str()) }\n+pub fn split_paths<T: AsRef<OsStr> + ?Sized>(unparsed: &T) -> SplitPaths {\n+    SplitPaths { inner: os_imp::split_paths(unparsed.as_ref()) }\n }\n \n #[stable(feature = \"env\", since = \"1.0.0\")]\n@@ -340,7 +340,7 @@ pub struct JoinPathsError {\n /// ```\n #[stable(feature = \"env\", since = \"1.0.0\")]\n pub fn join_paths<I, T>(paths: I) -> Result<OsString, JoinPathsError>\n-    where I: IntoIterator<Item=T>, T: AsOsStr\n+    where I: IntoIterator<Item=T>, T: AsRef<OsStr>\n {\n     os_imp::join_paths(paths.into_iter()).map_err(|e| {\n         JoinPathsError { inner: e }\n@@ -740,7 +740,7 @@ mod tests {\n         let mut rng = rand::thread_rng();\n         let n = format!(\"TEST{}\", rng.gen_ascii_chars().take(10)\n                                      .collect::<String>());\n-        let n = OsString::from_string(n);\n+        let n = OsString::from(n);\n         assert!(var_os(&n).is_none());\n         n\n     }"}, {"sha": "544d6bcc2c645f83e47f25b830d122b6ad2d8550", "filename": "src/libstd/ffi/c_str.rs", "status": "modified", "additions": 0, "deletions": 95, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Flibstd%2Fffi%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Flibstd%2Fffi%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fffi%2Fc_str.rs?ref=d4a2c941809f303b97d153e06ba07e95cd245f88", "patch": "@@ -132,15 +132,6 @@ pub struct CStr {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct NulError(usize, Vec<u8>);\n \n-/// A conversion trait used by the constructor of `CString` for types that can\n-/// be converted to a vector of bytes.\n-#[deprecated(since = \"1.0.0\", reason = \"use std::convert::Into<Vec<u8>> instead\")]\n-#[unstable(feature = \"std_misc\")]\n-pub trait IntoBytes {\n-    /// Consumes this container, returning a vector of bytes.\n-    fn into_bytes(self) -> Vec<u8>;\n-}\n-\n impl CString {\n     /// Create a new C-compatible string from a container of bytes.\n     ///\n@@ -178,57 +169,6 @@ impl CString {\n         }\n     }\n \n-    /// Create a new C-compatible string from a byte slice.\n-    ///\n-    /// This method will copy the data of the slice provided into a new\n-    /// allocation, ensuring that there is a trailing 0 byte.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// # #![feature(libc)]\n-    /// extern crate libc;\n-    /// use std::ffi::CString;\n-    ///\n-    /// extern { fn puts(s: *const libc::c_char); }\n-    ///\n-    /// fn main() {\n-    ///     let to_print = CString::new(\"Hello!\").unwrap();\n-    ///     unsafe {\n-    ///         puts(to_print.as_ptr());\n-    ///     }\n-    /// }\n-    /// ```\n-    ///\n-    /// # Panics\n-    ///\n-    /// This function will panic if the provided slice contains any\n-    /// interior nul bytes.\n-    #[unstable(feature = \"std_misc\")]\n-    #[deprecated(since = \"1.0.0\", reason = \"use CString::new instead\")]\n-    #[allow(deprecated)]\n-    pub fn from_slice(v: &[u8]) -> CString {\n-        CString::from_vec(v.to_vec())\n-    }\n-\n-    /// Create a C-compatible string from a byte vector.\n-    ///\n-    /// This method will consume ownership of the provided vector, appending a 0\n-    /// byte to the end after verifying that there are no interior 0 bytes.\n-    ///\n-    /// # Panics\n-    ///\n-    /// This function will panic if the provided slice contains any\n-    /// interior nul bytes.\n-    #[unstable(feature = \"std_misc\")]\n-    #[deprecated(since = \"1.0.0\", reason = \"use CString::new instead\")]\n-    pub fn from_vec(v: Vec<u8>) -> CString {\n-        match v.iter().position(|x| *x == 0) {\n-            Some(i) => panic!(\"null byte found in slice at: {}\", i),\n-            None => unsafe { CString::from_vec_unchecked(v) },\n-        }\n-    }\n-\n     /// Create a C-compatible string from a byte vector without checking for\n     /// interior 0 bytes.\n     ///\n@@ -424,41 +364,6 @@ impl Ord for CStr {\n     }\n }\n \n-/// Deprecated in favor of `CStr`\n-#[unstable(feature = \"std_misc\")]\n-#[deprecated(since = \"1.0.0\", reason = \"use CStr::from_ptr(p).to_bytes() instead\")]\n-pub unsafe fn c_str_to_bytes<'a>(raw: &'a *const libc::c_char) -> &'a [u8] {\n-    let len = libc::strlen(*raw);\n-    slice::from_raw_parts(*(raw as *const _ as *const *const u8), len as usize)\n-}\n-\n-/// Deprecated in favor of `CStr`\n-#[unstable(feature = \"std_misc\")]\n-#[deprecated(since = \"1.0.0\",\n-             reason = \"use CStr::from_ptr(p).to_bytes_with_nul() instead\")]\n-pub unsafe fn c_str_to_bytes_with_nul<'a>(raw: &'a *const libc::c_char)\n-                                          -> &'a [u8] {\n-    let len = libc::strlen(*raw) + 1;\n-    slice::from_raw_parts(*(raw as *const _ as *const *const u8), len as usize)\n-}\n-\n-#[allow(deprecated)]\n-impl<'a> IntoBytes for &'a str {\n-    fn into_bytes(self) -> Vec<u8> { self.as_bytes().to_vec() }\n-}\n-#[allow(deprecated)]\n-impl<'a> IntoBytes for &'a [u8] {\n-    fn into_bytes(self) -> Vec<u8> { self.to_vec() }\n-}\n-#[allow(deprecated)]\n-impl IntoBytes for String {\n-    fn into_bytes(self) -> Vec<u8> { self.into_bytes() }\n-}\n-#[allow(deprecated)]\n-impl IntoBytes for Vec<u8> {\n-    fn into_bytes(self) -> Vec<u8> { self }\n-}\n-\n #[cfg(test)]\n mod tests {\n     use prelude::v1::*;"}, {"sha": "1b7e913d46cbf49120c0f2798a5135477dec53ff", "filename": "src/libstd/ffi/mod.rs", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Flibstd%2Fffi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Flibstd%2Fffi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fffi%2Fmod.rs?ref=d4a2c941809f303b97d153e06ba07e95cd245f88", "patch": "@@ -13,17 +13,10 @@\n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use self::c_str::{CString, CStr};\n-pub use self::c_str::{NulError, IntoBytes};\n-#[allow(deprecated)]\n-pub use self::c_str::c_str_to_bytes;\n-#[allow(deprecated)]\n-pub use self::c_str::c_str_to_bytes_with_nul;\n+pub use self::c_str::{CString, CStr, NulError};\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use self::os_str::OsString;\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use self::os_str::OsStr;\n+pub use self::os_str::{OsString, OsStr};\n \n mod c_str;\n mod os_str;"}, {"sha": "d9a6a1006f4e17a85f9fffce1937c90f7805769f", "filename": "src/libstd/ffi/os_str.rs", "status": "modified", "additions": 1, "deletions": 24, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Flibstd%2Fffi%2Fos_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Flibstd%2Fffi%2Fos_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fffi%2Fos_str.rs?ref=d4a2c941809f303b97d153e06ba07e95cd245f88", "patch": "@@ -29,7 +29,7 @@\n //! for conversion to/from various other string types. Eventually these types\n //! will offer a full-fledged string API.\n \n-#![unstable(feature = \"os\",\n+#![unstable(feature = \"os_str\",\n             reason = \"recently added as part of path/io reform\")]\n \n use core::prelude::*;\n@@ -61,22 +61,6 @@ pub struct OsStr {\n }\n \n impl OsString {\n-    /// Constructs an `OsString` at no cost by consuming a `String`.\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[deprecated(since = \"1.0.0\", reason = \"use `from` instead\")]\n-    pub fn from_string(s: String) -> OsString {\n-        OsString::from(s)\n-    }\n-\n-    /// Constructs an `OsString` by copying from a `&str` slice.\n-    ///\n-    /// Equivalent to: `OsString::from_string(String::from_str(s))`.\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[deprecated(since = \"1.0.0\", reason = \"use `from` instead\")]\n-    pub fn from_str(s: &str) -> OsString {\n-        OsString::from(s)\n-    }\n-\n     /// Constructs a new empty `OsString`.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn new() -> OsString {\n@@ -91,13 +75,6 @@ impl OsString {\n         self.inner.into_string().map_err(|buf| OsString { inner: buf} )\n     }\n \n-    /// Extend the string with the given `&OsStr` slice.\n-    #[deprecated(since = \"1.0.0\", reason = \"renamed to `push`\")]\n-    #[unstable(feature = \"os\")]\n-    pub fn push_os_str(&mut self, s: &OsStr) {\n-        self.inner.push_slice(&s.inner)\n-    }\n-\n     /// Extend the string with the given `&OsStr` slice.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn push<T: AsRef<OsStr>>(&mut self, s: T) {"}, {"sha": "071e5b5c28cfa420d52f67a52ce55ce5b1beb73b", "filename": "src/libstd/fs.rs", "status": "renamed", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Flibstd%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Flibstd%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffs.rs?ref=d4a2c941809f303b97d153e06ba07e95cd245f88", "patch": "@@ -25,11 +25,6 @@ use sys::fs2 as fs_imp;\n use sys_common::{AsInnerMut, FromInner, AsInner};\n use vec::Vec;\n \n-#[allow(deprecated)]\n-pub use self::tempdir::TempDir;\n-\n-mod tempdir;\n-\n /// A reference to an open file on the filesystem.\n ///\n /// An instance of a `File` can be read and/or written depending on what options\n@@ -1327,7 +1322,7 @@ mod tests {\n         check!(fs::copy(&input, &out));\n         let mut v = Vec::new();\n         check!(check!(File::open(&out)).read_to_end(&mut v));\n-        assert_eq!(v.as_slice(), b\"hello\");\n+        assert_eq!(v, b\"hello\");\n \n         assert_eq!(check!(input.metadata()).permissions(),\n                    check!(out.metadata()).permissions());\n@@ -1622,7 +1617,7 @@ mod tests {\n         check!(check!(File::create(&tmpdir.join(\"test\"))).write(&bytes));\n         let mut v = Vec::new();\n         check!(check!(File::open(&tmpdir.join(\"test\"))).read_to_end(&mut v));\n-        assert!(v == bytes.as_slice());\n+        assert!(v == &bytes[..]);\n     }\n \n     #[test]", "previous_filename": "src/libstd/fs/mod.rs"}, {"sha": "8cc1dde98a0b8bd25178874dfda8da92742d7d46", "filename": "src/libstd/fs/tempdir.rs", "status": "removed", "additions": 0, "deletions": 127, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/d754722a04b99fdcae0fd97fa2a4395521145ef2/src%2Flibstd%2Ffs%2Ftempdir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d754722a04b99fdcae0fd97fa2a4395521145ef2/src%2Flibstd%2Ffs%2Ftempdir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffs%2Ftempdir.rs?ref=d754722a04b99fdcae0fd97fa2a4395521145ef2", "patch": "@@ -1,127 +0,0 @@\n-// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#![unstable(feature = \"tempdir\", reason = \"needs an RFC before stabilization\")]\n-#![deprecated(since = \"1.0.0\",\n-              reason = \"use the `tempdir` crate from crates.io instead\")]\n-#![allow(deprecated)]\n-\n-use prelude::v1::*;\n-\n-use env;\n-use io::{self, Error, ErrorKind};\n-use fs;\n-use path::{self, PathBuf};\n-use rand::{thread_rng, Rng};\n-\n-/// A wrapper for a path to temporary directory implementing automatic\n-/// scope-based deletion.\n-pub struct TempDir {\n-    path: Option<PathBuf>,\n-}\n-\n-// How many times should we (re)try finding an unused random name? It should be\n-// enough that an attacker will run out of luck before we run out of patience.\n-const NUM_RETRIES: u32 = 1 << 31;\n-// How many characters should we include in a random file name? It needs to\n-// be enough to dissuade an attacker from trying to preemptively create names\n-// of that length, but not so huge that we unnecessarily drain the random number\n-// generator of entropy.\n-const NUM_RAND_CHARS: usize = 12;\n-\n-impl TempDir {\n-    /// Attempts to make a temporary directory inside of `tmpdir` whose name\n-    /// will have the prefix `prefix`. The directory will be automatically\n-    /// deleted once the returned wrapper is destroyed.\n-    ///\n-    /// If no directory can be created, `Err` is returned.\n-    #[allow(deprecated)] // rand usage\n-    pub fn new_in<P: AsRef<path::Path>>(tmpdir: P, prefix: &str) -> io::Result<TempDir> {\n-        let storage;\n-        let mut tmpdir = tmpdir.as_ref();\n-        if !tmpdir.is_absolute() {\n-            let cur_dir = try!(env::current_dir());\n-            storage = cur_dir.join(tmpdir);\n-            tmpdir = &storage;\n-            // return TempDir::new_in(&cur_dir.join(tmpdir), prefix);\n-        }\n-\n-        let mut rng = thread_rng();\n-        for _ in 0..NUM_RETRIES {\n-            let suffix: String = rng.gen_ascii_chars().take(NUM_RAND_CHARS).collect();\n-            let leaf = if prefix.len() > 0 {\n-                format!(\"{}.{}\", prefix, suffix)\n-            } else {\n-                // If we're given an empty string for a prefix, then creating a\n-                // directory starting with \".\" would lead to it being\n-                // semi-invisible on some systems.\n-                suffix\n-            };\n-            let path = tmpdir.join(&leaf);\n-            match fs::create_dir(&path) {\n-                Ok(_) => return Ok(TempDir { path: Some(path) }),\n-                Err(ref e) if e.kind() == ErrorKind::AlreadyExists => {}\n-                Err(e) => return Err(e)\n-            }\n-        }\n-\n-        Err(Error::new(ErrorKind::AlreadyExists,\n-                       \"too many temporary directories already exist\",\n-                       None))\n-    }\n-\n-    /// Attempts to make a temporary directory inside of `env::temp_dir()` whose\n-    /// name will have the prefix `prefix`. The directory will be automatically\n-    /// deleted once the returned wrapper is destroyed.\n-    ///\n-    /// If no directory can be created, `Err` is returned.\n-    #[allow(deprecated)]\n-    pub fn new(prefix: &str) -> io::Result<TempDir> {\n-        TempDir::new_in(&env::temp_dir(), prefix)\n-    }\n-\n-    /// Unwrap the wrapped `std::path::Path` from the `TempDir` wrapper.\n-    /// This discards the wrapper so that the automatic deletion of the\n-    /// temporary directory is prevented.\n-    pub fn into_path(mut self) -> PathBuf {\n-        self.path.take().unwrap()\n-    }\n-\n-    /// Access the wrapped `std::path::Path` to the temporary directory.\n-    pub fn path(&self) -> &path::Path {\n-        self.path.as_ref().unwrap()\n-    }\n-\n-    /// Close and remove the temporary directory\n-    ///\n-    /// Although `TempDir` removes the directory on drop, in the destructor\n-    /// any errors are ignored. To detect errors cleaning up the temporary\n-    /// directory, call `close` instead.\n-    pub fn close(mut self) -> io::Result<()> {\n-        self.cleanup_dir()\n-    }\n-\n-    fn cleanup_dir(&mut self) -> io::Result<()> {\n-        match self.path {\n-            Some(ref p) => fs::remove_dir_all(p),\n-            None => Ok(())\n-        }\n-    }\n-}\n-\n-impl Drop for TempDir {\n-    fn drop(&mut self) {\n-        let _ = self.cleanup_dir();\n-    }\n-}\n-\n-// the tests for this module need to change the path using change_dir,\n-// and this doesn't play nicely with other tests so these unit tests are located\n-// in src/test/run-pass/tempfile.rs"}, {"sha": "ad81143b7b4dccd14e80c1c25bd392cb63bd9b4b", "filename": "src/libstd/io/cursor.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Flibstd%2Fio%2Fcursor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Flibstd%2Fio%2Fcursor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fcursor.rs?ref=d4a2c941809f303b97d153e06ba07e95cd245f88", "patch": "@@ -281,19 +281,19 @@ mod tests {\n     #[test]\n     fn test_slice_reader() {\n         let in_buf = vec![0, 1, 2, 3, 4, 5, 6, 7];\n-        let mut reader = &mut in_buf.as_slice();\n+        let mut reader = &mut &in_buf[..];\n         let mut buf = [];\n         assert_eq!(reader.read(&mut buf), Ok(0));\n         let mut buf = [0];\n         assert_eq!(reader.read(&mut buf), Ok(1));\n         assert_eq!(reader.len(), 7);\n         let b: &[_] = &[0];\n-        assert_eq!(buf.as_slice(), b);\n+        assert_eq!(&buf[..], b);\n         let mut buf = [0; 4];\n         assert_eq!(reader.read(&mut buf), Ok(4));\n         assert_eq!(reader.len(), 3);\n         let b: &[_] = &[1, 2, 3, 4];\n-        assert_eq!(buf.as_slice(), b);\n+        assert_eq!(&buf[..], b);\n         assert_eq!(reader.read(&mut buf), Ok(3));\n         let b: &[_] = &[5, 6, 7];\n         assert_eq!(&buf[..3], b);\n@@ -303,7 +303,7 @@ mod tests {\n     #[test]\n     fn test_buf_reader() {\n         let in_buf = vec![0, 1, 2, 3, 4, 5, 6, 7];\n-        let mut reader = Cursor::new(in_buf.as_slice());\n+        let mut reader = Cursor::new(&in_buf[..]);\n         let mut buf = [];\n         assert_eq!(reader.read(&mut buf), Ok(0));\n         assert_eq!(reader.position(), 0);"}, {"sha": "615df771e9b44ff43f4e09c79e339a3a347bafbb", "filename": "src/libstd/io/error.rs", "status": "modified", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Flibstd%2Fio%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Flibstd%2Fio%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ferror.rs?ref=d4a2c941809f303b97d153e06ba07e95cd245f88", "patch": "@@ -9,7 +9,6 @@\n // except according to those terms.\n \n use boxed::Box;\n-use clone::Clone;\n use error;\n use fmt;\n use option::Option::{self, Some, None};\n@@ -179,27 +178,6 @@ impl Error {\n             Repr::Custom(ref c) => c.kind,\n         }\n     }\n-\n-    /// Returns a short description for this error message\n-    #[unstable(feature = \"io\")]\n-    #[deprecated(since = \"1.0.0\", reason = \"use the Error trait's description \\\n-                                            method instead\")]\n-    pub fn description(&self) -> &str {\n-        match self.repr {\n-            Repr::Os(..) => \"os error\",\n-            Repr::Custom(ref c) => c.desc,\n-        }\n-    }\n-\n-    /// Returns a detailed error message for this error (if one is available)\n-    #[unstable(feature = \"io\")]\n-    #[deprecated(since = \"1.0.0\", reason = \"use the to_string() method instead\")]\n-    pub fn detail(&self) -> Option<String> {\n-        match self.repr {\n-            Repr::Os(code) => Some(sys::os::error_string(code)),\n-            Repr::Custom(ref s) => s.detail.clone(),\n-        }\n-    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "578e057cbb642573594d3caceda16e3a3c4b2eff", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=d4a2c941809f303b97d153e06ba07e95cd245f88", "patch": "@@ -173,8 +173,6 @@ pub use core::clone;\n #[cfg(not(test))] pub use core::cmp;\n pub use core::convert;\n pub use core::default;\n-#[allow(deprecated)]\n-pub use core::finally;\n pub use core::hash;\n pub use core::intrinsics;\n pub use core::iter;"}, {"sha": "9611e40e1e955b9266477cb54e6b09d1b8bb61c9", "filename": "src/libstd/net/tcp.rs", "status": "modified", "additions": 2, "deletions": 16, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Flibstd%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Flibstd%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Ftcp.rs?ref=d4a2c941809f303b97d153e06ba07e95cd245f88", "patch": "@@ -100,13 +100,6 @@ impl TcpStream {\n         self.0.peer_addr()\n     }\n \n-    /// Returns the socket address of the local half of this TCP connection.\n-    #[unstable(feature = \"net\")]\n-    #[deprecated(since = \"1.0.0\", reason = \"renamed to local_addr\")]\n-    pub fn socket_addr(&self) -> io::Result<SocketAddr> {\n-        self.0.socket_addr()\n-    }\n-\n     /// Returns the socket address of the local half of this TCP connection.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn local_addr(&self) -> io::Result<SocketAddr> {\n@@ -195,13 +188,6 @@ impl TcpListener {\n         self.0.socket_addr()\n     }\n \n-    /// Deprecated, renamed to local_addr\n-    #[unstable(feature = \"net\")]\n-    #[deprecated(since = \"1.0.0\", reason = \"renamed to local_addr\")]\n-    pub fn socket_addr(&self) -> io::Result<SocketAddr> {\n-        self.0.socket_addr()\n-    }\n-\n     /// Create a new independently owned handle to the underlying socket.\n     ///\n     /// The returned `TcpListener` is a reference to the same socket that this\n@@ -349,7 +335,7 @@ mod tests {\n             let _t = thread::spawn(move|| {\n                 let mut stream = t!(TcpStream::connect(&addr));\n                 t!(stream.write(&[99]));\n-                tx.send(t!(stream.socket_addr())).unwrap();\n+                tx.send(t!(stream.local_addr())).unwrap();\n             });\n \n             let (mut stream, addr) = t!(acceptor.accept());\n@@ -499,7 +485,7 @@ mod tests {\n     fn socket_and_peer_name_ip4() {\n         each_ip(&mut |addr| {\n             let listener = t!(TcpListener::bind(&addr));\n-            let so_name = t!(listener.socket_addr());\n+            let so_name = t!(listener.local_addr());\n             assert_eq!(addr, so_name);\n             let _t = thread::spawn(move|| {\n                 t!(listener.accept());"}, {"sha": "85831c2de34441c4ff209964748ec5c671339394", "filename": "src/libstd/net/udp.rs", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Flibstd%2Fnet%2Fudp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Flibstd%2Fnet%2Fudp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Fudp.rs?ref=d4a2c941809f303b97d153e06ba07e95cd245f88", "patch": "@@ -80,13 +80,6 @@ impl UdpSocket {\n         }\n     }\n \n-    /// Returns the socket address that this socket was created from.\n-    #[unstable(feature = \"net\")]\n-    #[deprecated(since = \"1.0.0\", reason = \"renamed to local_addr\")]\n-    pub fn socket_addr(&self) -> io::Result<SocketAddr> {\n-        self.0.socket_addr()\n-    }\n-\n     /// Returns the socket address that this socket was created from.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn local_addr(&self) -> io::Result<SocketAddr> {\n@@ -203,7 +196,7 @@ mod tests {\n     fn socket_name_ip4() {\n         each_ip(&mut |addr, _| {\n             let server = t!(UdpSocket::bind(&addr));\n-            assert_eq!(addr, t!(server.socket_addr()));\n+            assert_eq!(addr, t!(server.local_addr()));\n         })\n     }\n "}, {"sha": "bef6ea53e5085c2dc0f68c1055917dcaaba0237f", "filename": "src/libstd/old_io/fs.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Flibstd%2Fold_io%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Flibstd%2Fold_io%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Ffs.rs?ref=d4a2c941809f303b97d153e06ba07e95cd245f88", "patch": "@@ -951,7 +951,8 @@ mod test {\n     pub fn tmpdir() -> TempDir {\n         use os;\n         use rand;\n-        let ret = os::tmpdir().join(format!(\"rust-{}\", rand::random::<u32>()));\n+        let temp = Path::new(::env::temp_dir().to_str().unwrap());\n+        let ret = temp.join(format!(\"rust-{}\", rand::random::<u32>()));\n         check!(old_io::fs::mkdir(&ret, old_io::USER_RWX));\n         TempDir(ret)\n     }\n@@ -1639,7 +1640,7 @@ mod test {\n \n         check!(File::create(&tmpdir.join(\"test\")).write(&bytes));\n         let actual = check!(File::open(&tmpdir.join(\"test\")).read_to_end());\n-        assert!(actual == bytes.as_slice());\n+        assert!(actual == &bytes[..]);\n     }\n \n     #[test]"}, {"sha": "c92e74fbc565e10b3a84aa46c67b86a630d816d8", "filename": "src/libstd/old_io/mem.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Flibstd%2Fold_io%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Flibstd%2Fold_io%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fmem.rs?ref=d4a2c941809f303b97d153e06ba07e95cd245f88", "patch": "@@ -399,7 +399,7 @@ impl<'a> Buffer for BufReader<'a> {\n mod test {\n     extern crate test as test_crate;\n     use old_io::{SeekSet, SeekCur, SeekEnd, Reader, Writer, Seek, Buffer};\n-    use prelude::v1::{Ok, Err, Vec,  AsSlice};\n+    use prelude::v1::{Ok, Err, Vec};\n     use prelude::v1::Iterator;\n     use old_io;\n     use iter::repeat;\n@@ -744,7 +744,7 @@ mod test {\n                     wr.write(&[5; 10]).unwrap();\n                 }\n             }\n-            assert_eq!(buf.as_slice(), [5; 100].as_slice());\n+            assert_eq!(&buf[..], &[5; 100][..]);\n         });\n     }\n "}, {"sha": "9d7e1082d33b14fb42e76612a3b67debd55be8c6", "filename": "src/libstd/old_io/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Flibstd%2Fold_io%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Flibstd%2Fold_io%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fmod.rs?ref=d4a2c941809f303b97d153e06ba07e95cd245f88", "patch": "@@ -274,7 +274,7 @@ use mem::transmute;\n use ops::FnOnce;\n use option::Option;\n use option::Option::{Some, None};\n-use os;\n+use sys::os;\n use boxed::Box;\n use result::Result;\n use result::Result::{Ok, Err};"}, {"sha": "fd1df49473e586d4bd6c40b8a497bf1a1937d963", "filename": "src/libstd/old_io/pipe.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Flibstd%2Fold_io%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Flibstd%2Fold_io%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fpipe.rs?ref=d4a2c941809f303b97d153e06ba07e95cd245f88", "patch": "@@ -124,9 +124,9 @@ mod test {\n         use os;\n         use old_io::pipe::PipeStream;\n \n-        let os::Pipe { reader, writer } = unsafe { os::pipe().unwrap() };\n-        let out = PipeStream::open(writer);\n-        let mut input = PipeStream::open(reader);\n+        let (reader, writer) = unsafe { ::sys::os::pipe().unwrap() };\n+        let out = PipeStream::open(writer.unwrap());\n+        let mut input = PipeStream::open(reader.unwrap());\n         let (tx, rx) = channel();\n         let _t = thread::spawn(move|| {\n             let mut out = out;"}, {"sha": "d0fa7dd6882bed6e4f956886a1a744ccd1c20d7a", "filename": "src/libstd/old_io/process.rs", "status": "modified", "additions": 15, "deletions": 21, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Flibstd%2Fold_io%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Flibstd%2Fold_io%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fprocess.rs?ref=d4a2c941809f303b97d153e06ba07e95cd245f88", "patch": "@@ -246,7 +246,7 @@ impl Command {\n             None => {\n                 // if the env is currently just inheriting from the parent's,\n                 // materialize the parent's env into a hashtable.\n-                self.env = Some(os::env_as_bytes().into_iter().map(|(k, v)| {\n+                self.env = Some(::env::vars().map(|(k, v)| {\n                     (EnvKey(CString::new(k).unwrap()),\n                      CString::new(v).unwrap())\n                 }).collect());\n@@ -764,11 +764,9 @@ impl Drop for Process {\n \n #[cfg(test)]\n mod tests {\n+    use prelude::v1::*;\n     use old_io::{Truncate, Write, TimedOut, timer, process, FileNotFound};\n     use old_io::{Reader, Writer};\n-    use prelude::v1::{Ok, Err, drop, Some, None, Vec};\n-    use prelude::v1::{String, Clone};\n-    use prelude::v1::{Str, AsSlice, ToString};\n     use old_path::{GenericPath, Path};\n     use old_io::fs::PathExtensions;\n     use old_io::timer::*;\n@@ -1003,7 +1001,7 @@ mod tests {\n         let prog = pwd_cmd().spawn().unwrap();\n \n         let output = String::from_utf8(prog.wait_with_output().unwrap().output).unwrap();\n-        let parent_dir = os::getcwd().unwrap();\n+        let parent_dir = Path::new(::env::current_dir().unwrap().to_str().unwrap());\n         let child_dir = Path::new(output.trim());\n \n         let parent_stat = parent_dir.stat().unwrap();\n@@ -1018,7 +1016,7 @@ mod tests {\n         use os;\n         // test changing to the parent of os::getcwd() because we know\n         // the path exists (and os::getcwd() is not expected to be root)\n-        let parent_dir = os::getcwd().unwrap().dir_path();\n+        let parent_dir = Path::new(::env::current_dir().unwrap().to_str().unwrap());\n         let prog = pwd_cmd().cwd(&parent_dir).spawn().unwrap();\n \n         let output = String::from_utf8(prog.wait_with_output().unwrap().output).unwrap();\n@@ -1058,11 +1056,11 @@ mod tests {\n         let prog = env_cmd().spawn().unwrap();\n         let output = String::from_utf8(prog.wait_with_output().unwrap().output).unwrap();\n \n-        let r = os::env();\n-        for &(ref k, ref v) in &r {\n+        let r = ::env::vars();\n+        for (k, v) in r {\n             // don't check windows magical empty-named variables\n             assert!(k.is_empty() ||\n-                    output.contains(&format!(\"{}={}\", *k, *v)),\n+                    output.contains(&format!(\"{}={}\", k, v)),\n                     \"output doesn't contain `{}={}`\\n{}\",\n                     k, v, output);\n         }\n@@ -1076,16 +1074,12 @@ mod tests {\n         let mut prog = env_cmd().spawn().unwrap();\n         let output = String::from_utf8(prog.wait_with_output().unwrap().output).unwrap();\n \n-        let r = os::env();\n-        for &(ref k, ref v) in &r {\n+        let r = env::vars();\n+        for (k, v) in r {\n             // don't check android RANDOM variables\n-            if *k != \"RANDOM\".to_string() {\n-                assert!(output.contains(&format!(\"{}={}\",\n-                                                 *k,\n-                                                 *v)) ||\n-                        output.contains(&format!(\"{}=\\'{}\\'\",\n-                                                 *k,\n-                                                 *v)));\n+            if k != \"RANDOM\".to_string() {\n+                assert!(output.contains(&format!(\"{}={}\", k, v)) ||\n+                        output.contains(&format!(\"{}=\\'{}\\'\", k, v)));\n             }\n         }\n     }\n@@ -1100,9 +1094,9 @@ mod tests {\n         // PATH to our sub-process.\n         let path_val: String;\n         let mut new_env = vec![(\"RUN_TEST_NEW_ENV\", \"123\")];\n-        match os::getenv(\"PATH\") {\n-            None => {}\n-            Some(val) => {\n+        match ::env::var(\"PATH\") {\n+            Err(..) => {}\n+            Ok(val) => {\n                 path_val = val;\n                 new_env.push((\"PATH\", &path_val))\n             }"}, {"sha": "94faa5540bb30d538945a8e27b8c239a61345aee", "filename": "src/libstd/old_io/tempfile.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Flibstd%2Fold_io%2Ftempfile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Flibstd%2Fold_io%2Ftempfile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Ftempfile.rs?ref=d4a2c941809f303b97d153e06ba07e95cd245f88", "patch": "@@ -100,7 +100,8 @@ impl TempDir {\n     #[allow(deprecated)]\n     pub fn new_in(tmpdir: &Path, prefix: &str) -> IoResult<TempDir> {\n         if !tmpdir.is_absolute() {\n-            let cur_dir = try!(::os::getcwd());\n+            let cur_dir = ::env::current_dir().unwrap();\n+            let cur_dir = Path::new(cur_dir.to_str().unwrap());\n             return TempDir::new_in(&cur_dir.join(tmpdir), prefix);\n         }\n \n@@ -136,7 +137,8 @@ impl TempDir {\n     /// If no directory can be created, `Err` is returned.\n     #[allow(deprecated)]\n     pub fn new(prefix: &str) -> IoResult<TempDir> {\n-        TempDir::new_in(&::os::tmpdir(), prefix)\n+        let tmp = Path::new(::env::temp_dir().to_str().unwrap());\n+        TempDir::new_in(&tmp, prefix)\n     }\n \n     /// Unwrap the wrapped `std::path::Path` from the `TempDir` wrapper."}, {"sha": "8c46e2c06b84f544e4221717499885ef979ad391", "filename": "src/libstd/old_io/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Flibstd%2Fold_io%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Flibstd%2Fold_io%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Ftest.rs?ref=d4a2c941809f303b97d153e06ba07e95cd245f88", "patch": "@@ -43,7 +43,7 @@ fn next_test_unix_socket() -> String {\n pub fn next_test_unix() -> Path {\n     let string = next_test_unix_socket();\n     if cfg!(unix) {\n-        ::os::tmpdir().join(string)\n+        Path::new(::env::temp_dir().to_str().unwrap()).join(string)\n     } else {\n         Path::new(format!(\"{}{}\", r\"\\\\.\\pipe\\\", string))\n     }"}, {"sha": "9c88533d3bac605cb55b328b7265b8cb98a9ab5b", "filename": "src/libstd/old_path/mod.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Flibstd%2Fold_path%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Flibstd%2Fold_path%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_path%2Fmod.rs?ref=d4a2c941809f303b97d153e06ba07e95cd245f88", "patch": "@@ -69,12 +69,13 @@\n use core::marker::Sized;\n use ffi::CString;\n use clone::Clone;\n+use borrow::Cow;\n use fmt;\n use iter::Iterator;\n use option::Option;\n use option::Option::{None, Some};\n use str;\n-use string::{String, CowString};\n+use string::String;\n use vec::Vec;\n \n /// Typedef for POSIX file paths.\n@@ -907,7 +908,7 @@ impl<'a, P: GenericPath> Display<'a, P> {\n     /// If the path is not UTF-8, invalid sequences will be replaced with the\n     /// Unicode replacement char. This involves allocation.\n     #[inline]\n-    pub fn as_cow(&self) -> CowString<'a> {\n+    pub fn as_cow(&self) -> Cow<'a, str> {\n         String::from_utf8_lossy(if self.filename {\n             match self.path.filename() {\n                 None => {"}, {"sha": "f215e73202c1735bcff6e386f2941ec7132ff95e", "filename": "src/libstd/old_path/posix.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Flibstd%2Fold_path%2Fposix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Flibstd%2Fold_path%2Fposix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_path%2Fposix.rs?ref=d4a2c941809f303b97d153e06ba07e95cd245f88", "patch": "@@ -20,7 +20,7 @@ use iter::{Iterator, Map};\n use marker::Sized;\n use option::Option::{self, Some, None};\n use result::Result::{self, Ok, Err};\n-use slice::{AsSlice, Split, SliceConcatExt};\n+use slice::{Split, SliceConcatExt};\n use str::{self, FromStr};\n use vec::Vec;\n \n@@ -339,11 +339,11 @@ impl Path {\n \n     /// Returns a normalized byte vector representation of a path, by removing all empty\n     /// components, and unnecessary . and .. components.\n-    fn normalize<V: ?Sized + AsSlice<u8>>(v: &V) -> Vec<u8> {\n+    fn normalize(v: &[u8]) -> Vec<u8> {\n         // borrowck is being very picky\n         let val = {\n-            let is_abs = !v.as_slice().is_empty() && v.as_slice()[0] == SEP_BYTE;\n-            let v_ = if is_abs { &v.as_slice()[1..] } else { v.as_slice() };\n+            let is_abs = !v.is_empty() && v[0] == SEP_BYTE;\n+            let v_ = if is_abs { &v[1..] } else { v };\n             let comps = normalize_helper(v_, is_abs);\n             match comps {\n                 None => None,\n@@ -371,7 +371,7 @@ impl Path {\n             }\n         };\n         match val {\n-            None => v.as_slice().to_vec(),\n+            None => v.to_vec(),\n             Some(val) => val\n         }\n     }\n@@ -446,8 +446,7 @@ mod tests {\n     use clone::Clone;\n     use option::Option::{self, Some, None};\n     use old_path::GenericPath;\n-    use slice::AsSlice;\n-    use str::{self, Str};\n+    use str;\n     use string::ToString;\n     use vec::Vec;\n     use iter::Iterator;"}, {"sha": "0b88f368b3952aa9985839ec42636dc40e88f70c", "filename": "src/libstd/old_path/windows.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Flibstd%2Fold_path%2Fwindows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Flibstd%2Fold_path%2Fwindows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_path%2Fwindows.rs?ref=d4a2c941809f303b97d153e06ba07e95cd245f88", "patch": "@@ -1129,8 +1129,6 @@ mod tests {\n     use iter::Iterator;\n     use option::Option::{self, Some, None};\n     use old_path::GenericPath;\n-    use slice::AsSlice;\n-    use str::Str;\n     use string::ToString;\n     use vec::Vec;\n "}, {"sha": "ee0f04cb9911cc8ccf55bd53e262b8cf5d0ccebf", "filename": "src/libstd/os.rs", "status": "modified", "additions": 2, "deletions": 1819, "changes": 1821, "blob_url": "https://github.com/rust-lang/rust/blob/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=d4a2c941809f303b97d153e06ba07e95cd245f88", "patch": "@@ -8,1826 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! Higher-level interfaces to libc::* functions and operating system services.\n-//!\n-//! In general these take and return rust types, use rust idioms (enums,\n-//! closures, vectors) rather than C idioms, and do more extensive safety\n-//! checks.\n-//!\n-//! This module is not meant to only contain 1:1 mappings to libc entries; any\n-//! os-interface code that is reasonably useful and broadly applicable can go\n-//! here. Including utility routines that merely build on other os code.\n-//!\n-//! We assume the general case is that users do not care, and do not want to be\n-//! made to care, which operating system they are on. While they may want to\n-//! special case various special cases -- and so we will not _hide_ the facts of\n-//! which OS the user is on -- they should be given the opportunity to write\n-//! OS-ignorant code by default.\n+//! OS-specific functionality\n \n-#![unstable(feature = \"os\")]\n-#![deprecated(since = \"1.0.0\", reason = \"replaced with std::env APIs\")]\n-\n-#![allow(missing_docs)]\n-#![allow(non_snake_case)]\n-#![allow(unused_imports)]\n-#![allow(deprecated)]\n-\n-use self::MemoryMapKind::*;\n-use self::MapOption::*;\n-use self::MapError::*;\n-\n-use boxed::Box;\n-use clone::Clone;\n-use convert::From;\n-use env;\n-use error::{FromError, Error};\n-use ffi::{OsString, OsStr};\n-use fmt;\n-use iter::Iterator;\n-use libc::{c_void, c_int, c_char};\n-use libc;\n-use marker::{Copy, Send};\n-use old_io::{IoResult, IoError};\n-use ops::{Drop, FnOnce};\n-use option::Option::{Some, None};\n-use option::Option;\n-use old_path::{Path, GenericPath, BytesContainer};\n-use path::{self, PathBuf};\n-use ptr;\n-use result::Result::{Err, Ok};\n-use result::Result;\n-use slice::AsSlice;\n-use str::Str;\n-use str;\n-use string::{String, ToString};\n-use sync::atomic::{AtomicIsize, ATOMIC_ISIZE_INIT, Ordering};\n-use sys::os as os_imp;\n-use sys;\n-use vec::Vec;\n-\n-#[cfg(unix)] use ffi::{self, CString};\n+#![stable(feature = \"os\", since = \"1.0.0\")]\n \n #[cfg(unix)] pub use sys::ext as unix;\n #[cfg(windows)] pub use sys::ext as windows;\n-\n-fn err2old(new: ::io::Error) -> IoError {\n-    IoError {\n-        kind: ::old_io::OtherIoError,\n-        desc: \"os error\",\n-        detail: Some(new.to_string()),\n-    }\n-}\n-\n-#[cfg(windows)]\n-fn path2new(path: &Path) -> PathBuf {\n-    PathBuf::from(path.as_str().unwrap())\n-}\n-#[cfg(unix)]\n-fn path2new(path: &Path) -> PathBuf {\n-    use os::unix::prelude::*;\n-    PathBuf::from(<OsStr as OsStrExt>::from_bytes(path.as_vec()))\n-}\n-\n-#[cfg(unix)]\n-fn path2old(path: &path::Path) -> Path {\n-    use os::unix::prelude::*;\n-    use ffi::AsOsStr;\n-    Path::new(path.as_os_str().as_bytes())\n-}\n-#[cfg(windows)]\n-fn path2old(path: &path::Path) -> Path {\n-    Path::new(path.to_str().unwrap())\n-}\n-\n-/// Get the number of cores available\n-pub fn num_cpus() -> usize {\n-    unsafe {\n-        return rust_get_num_cpus() as usize;\n-    }\n-\n-    extern {\n-        fn rust_get_num_cpus() -> libc::uintptr_t;\n-    }\n-}\n-\n-pub const TMPBUF_SZ : usize = 1000;\n-\n-/// Returns the current working directory as a `Path`.\n-///\n-/// # Errors\n-///\n-/// Returns an `Err` if the current working directory value is invalid.\n-/// Possible cases:\n-///\n-/// * Current directory does not exist.\n-/// * There are insufficient permissions to access the current directory.\n-/// * The internal buffer is not large enough to hold the path.\n-///\n-/// # Examples\n-///\n-/// ```\n-/// # #![feature(os, old_path)]\n-/// use std::os;\n-/// use std::old_path::{Path, GenericPath};\n-///\n-/// // We assume that we are in a valid directory.\n-/// let current_working_directory = os::getcwd().unwrap();\n-/// println!(\"The current directory is {:?}\", current_working_directory.display());\n-/// ```\n-#[unstable(feature = \"os\")]\n-pub fn getcwd() -> IoResult<Path> {\n-    env::current_dir().map_err(err2old).map(|s| path2old(&s))\n-}\n-\n-/// Returns a vector of (variable, value) pairs, for all the environment\n-/// variables of the current process.\n-///\n-/// Invalid UTF-8 bytes are replaced with \\uFFFD. See `String::from_utf8_lossy()`\n-/// for details.\n-///\n-/// # Examples\n-///\n-/// ```\n-/// # #![feature(os)]\n-/// use std::os;\n-///\n-/// // We will iterate through the references to the element returned by os::env();\n-/// for &(ref key, ref value) in os::env().iter() {\n-///     println!(\"'{}': '{}'\", key, value );\n-/// }\n-/// ```\n-#[deprecated(since = \"1.0.0\", reason = \"use env::vars instead\")]\n-#[unstable(feature = \"os\")]\n-pub fn env() -> Vec<(String,String)> {\n-    env::vars_os().map(|(k, v)| {\n-        (k.to_string_lossy().into_owned(), v.to_string_lossy().into_owned())\n-    }).collect()\n-}\n-\n-/// Returns a vector of (variable, value) byte-vector pairs for all the\n-/// environment variables of the current process.\n-#[deprecated(since = \"1.0.0\", reason = \"use env::vars_os instead\")]\n-#[unstable(feature = \"os\")]\n-pub fn env_as_bytes() -> Vec<(Vec<u8>, Vec<u8>)> {\n-    env::vars_os().map(|(k, v)| (byteify(k), byteify(v))).collect()\n-}\n-\n-/// Fetches the environment variable `n` from the current process, returning\n-/// None if the variable isn't set.\n-///\n-/// Any invalid UTF-8 bytes in the value are replaced by \\uFFFD. See\n-/// `String::from_utf8_lossy()` for details.\n-///\n-/// # Panics\n-///\n-/// Panics if `n` has any interior NULs.\n-///\n-/// # Examples\n-///\n-/// ```\n-/// # #![feature(os)]\n-/// use std::os;\n-///\n-/// let key = \"HOME\";\n-/// match os::getenv(key) {\n-///     Some(val) => println!(\"{}: {}\", key, val),\n-///     None => println!(\"{} is not defined in the environment.\", key)\n-/// }\n-/// ```\n-#[deprecated(since = \"1.0.0\", reason = \"use env::var instead\")]\n-#[unstable(feature = \"os\")]\n-pub fn getenv(n: &str) -> Option<String> {\n-    env::var(n).ok()\n-}\n-\n-/// Fetches the environment variable `n` byte vector from the current process,\n-/// returning None if the variable isn't set.\n-///\n-/// # Panics\n-///\n-/// Panics if `n` has any interior NULs.\n-#[deprecated(since = \"1.0.0\", reason = \"use env::var_os instead\")]\n-#[unstable(feature = \"os\")]\n-pub fn getenv_as_bytes(n: &str) -> Option<Vec<u8>> {\n-    env::var_os(n).map(byteify)\n-}\n-\n-#[cfg(unix)]\n-fn byteify(s: OsString) -> Vec<u8> {\n-    use os::unix::prelude::*;\n-    s.into_vec()\n-}\n-#[cfg(windows)]\n-fn byteify(s: OsString) -> Vec<u8> {\n-    s.to_string_lossy().as_bytes().to_vec()\n-}\n-\n-/// Sets the environment variable `n` to the value `v` for the currently running\n-/// process.\n-///\n-/// # Examples\n-///\n-/// ```\n-/// # #![feature(os)]\n-/// use std::os;\n-///\n-/// let key = \"KEY\";\n-/// os::setenv(key, \"VALUE\");\n-/// match os::getenv(key) {\n-///     Some(ref val) => println!(\"{}: {}\", key, val),\n-///     None => println!(\"{} is not defined in the environment.\", key)\n-/// }\n-/// ```\n-#[deprecated(since = \"1.0.0\", reason = \"renamed to env::set_var\")]\n-#[unstable(feature = \"os\")]\n-pub fn setenv<T: BytesContainer>(n: &str, v: T) {\n-    #[cfg(unix)]\n-    fn _setenv(n: &str, v: &[u8]) {\n-        use os::unix::prelude::*;\n-        let v: OsString = OsStringExt::from_vec(v.to_vec());\n-        env::set_var(n, &v)\n-    }\n-\n-    #[cfg(windows)]\n-    fn _setenv(n: &str, v: &[u8]) {\n-        let v = str::from_utf8(v).unwrap();\n-        env::set_var(n, v)\n-    }\n-\n-    _setenv(n, v.container_as_bytes())\n-}\n-\n-/// Remove a variable from the environment entirely.\n-#[deprecated(since = \"1.0.0\", reason = \"renamed to env::remove_var\")]\n-#[unstable(feature = \"os\")]\n-pub fn unsetenv(n: &str) {\n-    env::remove_var(n)\n-}\n-\n-/// Parses input according to platform conventions for the `PATH`\n-/// environment variable.\n-///\n-/// # Examples\n-///\n-/// ```\n-/// # #![feature(old_path, os)]\n-/// use std::os;\n-/// use std::old_path::{Path, GenericPath};\n-///\n-/// let key = \"PATH\";\n-/// match os::getenv_as_bytes(key) {\n-///     Some(paths) => {\n-///         for path in os::split_paths(paths).iter() {\n-///             println!(\"'{}'\", path.display());\n-///         }\n-///     }\n-///     None => println!(\"{} is not defined in the environment.\", key)\n-/// }\n-/// ```\n-#[unstable(feature = \"os\")]\n-pub fn split_paths<T: BytesContainer>(unparsed: T) -> Vec<Path> {\n-    let b = unparsed.container_as_bytes();\n-    let s = str::from_utf8(b).unwrap();\n-    env::split_paths(s).map(|s| path2old(&s)).collect()\n-}\n-\n-/// Joins a collection of `Path`s appropriately for the `PATH`\n-/// environment variable.\n-///\n-/// Returns a `Vec<u8>` on success, since `Path`s are not utf-8\n-/// encoded on all platforms.\n-///\n-/// Returns an `Err` (containing an error message) if one of the input\n-/// `Path`s contains an invalid character for constructing the `PATH`\n-/// variable (a double quote on Windows or a colon on Unix).\n-///\n-/// # Examples\n-///\n-/// ```\n-/// # #![feature(os, old_path, core)]\n-/// use std::os;\n-/// use std::old_path::Path;\n-///\n-/// let key = \"PATH\";\n-/// let mut paths = os::getenv_as_bytes(key).map_or(Vec::new(), os::split_paths);\n-/// paths.push(Path::new(\"/home/xyz/bin\"));\n-/// os::setenv(key, os::join_paths(paths.as_slice()).unwrap());\n-/// ```\n-#[unstable(feature = \"os\")]\n-pub fn join_paths<T: BytesContainer>(paths: &[T]) -> Result<Vec<u8>, &'static str> {\n-    env::join_paths(paths.iter().map(|s| {\n-        str::from_utf8(s.container_as_bytes()).unwrap()\n-    })).map(|s| {\n-        s.to_string_lossy().into_owned().into_bytes()\n-    }).map_err(|_| \"failed to join paths\")\n-}\n-\n-/// A low-level OS in-memory pipe.\n-#[derive(Copy)]\n-pub struct Pipe {\n-    /// A file descriptor representing the reading end of the pipe. Data written\n-    /// on the `out` file descriptor can be read from this file descriptor.\n-    pub reader: c_int,\n-    /// A file descriptor representing the write end of the pipe. Data written\n-    /// to this file descriptor can be read from the `input` file descriptor.\n-    pub writer: c_int,\n-}\n-\n-/// Creates a new low-level OS in-memory pipe.\n-///\n-/// This function can fail to succeed if there are no more resources available\n-/// to allocate a pipe.\n-///\n-/// This function is also unsafe as there is no destructor associated with the\n-/// `Pipe` structure will return. If it is not arranged for the returned file\n-/// descriptors to be closed, the file descriptors will leak. For safe handling\n-/// of this scenario, use `std::old_io::PipeStream` instead.\n-pub unsafe fn pipe() -> IoResult<Pipe> {\n-    let (reader, writer) = try!(sys::os::pipe());\n-    Ok(Pipe {\n-        reader: reader.unwrap(),\n-        writer: writer.unwrap(),\n-    })\n-}\n-\n-/// Returns the proper dll filename for the given basename of a file\n-/// as a String.\n-#[cfg(not(target_os=\"ios\"))]\n-#[deprecated(since = \"1.0.0\", reason = \"this function will be removed, use the constants directly\")]\n-#[unstable(feature = \"os\")]\n-#[allow(deprecated)]\n-pub fn dll_filename(base: &str) -> String {\n-    format!(\"{}{}{}\", consts::DLL_PREFIX, base, consts::DLL_SUFFIX)\n-}\n-\n-/// Optionally returns the filesystem path to the current executable which is\n-/// running but with the executable name.\n-///\n-/// # Examples\n-///\n-/// ```\n-/// # #![feature(os, old_path)]\n-/// use std::os;\n-/// use std::old_path::{Path, GenericPath};\n-///\n-/// match os::self_exe_name() {\n-///     Some(exe_path) => println!(\"Path of this executable is: {}\", exe_path.display()),\n-///     None => println!(\"Unable to get the path of this executable!\")\n-/// };\n-/// ```\n-#[unstable(feature = \"os\")]\n-pub fn self_exe_name() -> Option<Path> {\n-    env::current_exe().ok().map(|p| path2old(&p))\n-}\n-\n-/// Optionally returns the filesystem path to the current executable which is\n-/// running.\n-///\n-/// Like self_exe_name() but without the binary's name.\n-///\n-/// # Examples\n-///\n-/// ```\n-/// # #![feature(os, old_path)]\n-/// use std::os;\n-/// use std::old_path::{Path, GenericPath};\n-///\n-/// match os::self_exe_path() {\n-///     Some(exe_path) => println!(\"Executable's Path is: {}\", exe_path.display()),\n-///     None => println!(\"Impossible to fetch the path of this executable.\")\n-/// };\n-/// ```\n-#[unstable(feature = \"os\")]\n-pub fn self_exe_path() -> Option<Path> {\n-    env::current_exe().ok().map(|p| { let mut p = path2old(&p); p.pop(); p })\n-}\n-\n-/// Optionally returns the path to the current user's home directory if known.\n-///\n-/// # Unix\n-///\n-/// Returns the value of the 'HOME' environment variable if it is set\n-/// and not equal to the empty string.\n-///\n-/// # Windows\n-///\n-/// Returns the value of the 'HOME' environment variable if it is\n-/// set and not equal to the empty string. Otherwise, returns the value of the\n-/// 'USERPROFILE' environment variable if it is set and not equal to the empty\n-/// string.\n-///\n-/// # Examples\n-///\n-/// ```\n-/// # #![feature(os, old_path)]\n-/// use std::os;\n-/// use std::old_path::{Path, GenericPath};\n-///\n-/// match os::homedir() {\n-///     Some(ref p) => println!(\"{}\", p.display()),\n-///     None => println!(\"Impossible to get your home dir!\")\n-/// }\n-/// ```\n-#[unstable(feature = \"os\")]\n-#[allow(deprecated)]\n-pub fn homedir() -> Option<Path> {\n-    #[inline]\n-    #[cfg(unix)]\n-    fn _homedir() -> Option<Path> {\n-        aux_homedir(\"HOME\")\n-    }\n-\n-    #[inline]\n-    #[cfg(windows)]\n-    fn _homedir() -> Option<Path> {\n-        aux_homedir(\"HOME\").or(aux_homedir(\"USERPROFILE\"))\n-    }\n-\n-    #[inline]\n-    fn aux_homedir(home_name: &str) -> Option<Path> {\n-        match getenv_as_bytes(home_name) {\n-            Some(p)  => {\n-                if p.is_empty() { None } else { Path::new_opt(p) }\n-            },\n-            _ => None\n-        }\n-    }\n-    _homedir()\n-}\n-\n-/// Returns the path to a temporary directory.\n-///\n-/// On Unix, returns the value of the 'TMPDIR' environment variable if it is\n-/// set, otherwise for non-Android it returns '/tmp'. If Android, since there\n-/// is no global temporary folder (it is usually allocated per-app), we return\n-/// '/data/local/tmp'.\n-///\n-/// On Windows, returns the value of, in order, the 'TMP', 'TEMP',\n-/// 'USERPROFILE' environment variable  if any are set and not the empty\n-/// string. Otherwise, tmpdir returns the path to the Windows directory.\n-#[unstable(feature = \"os\")]\n-#[allow(deprecated)]\n-pub fn tmpdir() -> Path {\n-    return lookup();\n-\n-    fn getenv_nonempty(v: &str) -> Option<Path> {\n-        match getenv(v) {\n-            Some(x) =>\n-                if x.is_empty() {\n-                    None\n-                } else {\n-                    Path::new_opt(x)\n-                },\n-            _ => None\n-        }\n-    }\n-\n-    #[cfg(unix)]\n-    fn lookup() -> Path {\n-        let default = if cfg!(target_os = \"android\") {\n-            Path::new(\"/data/local/tmp\")\n-        } else {\n-            Path::new(\"/tmp\")\n-        };\n-\n-        getenv_nonempty(\"TMPDIR\").unwrap_or(default)\n-    }\n-\n-    #[cfg(windows)]\n-    fn lookup() -> Path {\n-        getenv_nonempty(\"TMP\").or(\n-            getenv_nonempty(\"TEMP\").or(\n-                getenv_nonempty(\"USERPROFILE\").or(\n-                   getenv_nonempty(\"WINDIR\")))).unwrap_or(Path::new(\"C:\\\\Windows\"))\n-    }\n-}\n-\n-/// Convert a relative path to an absolute path\n-///\n-/// If the given path is relative, return it prepended with the current working\n-/// directory. If the given path is already an absolute path, return it\n-/// as is.\n-///\n-/// # Examples\n-///\n-/// ```\n-/// # #![feature(os, old_path)]\n-/// use std::os;\n-/// use std::old_path::{Path, GenericPath};\n-///\n-/// // Assume we're in a path like /home/someuser\n-/// let rel_path = Path::new(\"..\");\n-/// let abs_path = os::make_absolute(&rel_path).unwrap();\n-/// println!(\"The absolute path is {}\", abs_path.display());\n-/// // Prints \"The absolute path is /home\"\n-/// ```\n-// NB: this is here rather than in path because it is a form of environment\n-// querying; what it does depends on the process working directory, not just\n-// the input paths.\n-#[deprecated(since = \"1.0.0\", reason = \"use env::current_dir + .join directly\")]\n-#[unstable(feature = \"os\")]\n-pub fn make_absolute(p: &Path) -> IoResult<Path> {\n-    if p.is_absolute() {\n-        Ok(p.clone())\n-    } else {\n-        env::current_dir().map_err(err2old).map(|cwd| {\n-            let mut cwd = path2old(&cwd);\n-            cwd.push(p);\n-            cwd\n-        })\n-    }\n-}\n-\n-/// Changes the current working directory to the specified path, returning\n-/// whether the change was completed successfully or not.\n-///\n-/// # Examples\n-///\n-/// ```\n-/// # #![feature(os, old_path)]\n-/// use std::os;\n-/// use std::old_path::{Path, GenericPath};\n-///\n-/// let root = Path::new(\"/\");\n-/// assert!(os::change_dir(&root).is_ok());\n-/// println!(\"Successfully changed working directory to {}!\", root.display());\n-/// ```\n-#[unstable(feature = \"os\")]\n-pub fn change_dir(p: &Path) -> IoResult<()> {\n-    sys::os::chdir(&path2new(p)).map_err(err2old)\n-}\n-\n-/// Returns the platform-specific value of errno\n-pub fn errno() -> i32 {\n-    sys::os::errno() as i32\n-}\n-\n-/// Return the string corresponding to an `errno()` value of `errnum`.\n-///\n-/// # Examples\n-///\n-/// ```\n-/// # #![feature(os)]\n-/// use std::os;\n-///\n-/// // Same as println!(\"{}\", last_os_error());\n-/// println!(\"{}\", os::error_string(os::errno() as i32));\n-/// ```\n-pub fn error_string(errnum: i32) -> String {\n-    return sys::os::error_string(errnum);\n-}\n-\n-/// Get a string representing the platform-dependent last error\n-pub fn last_os_error() -> String {\n-    error_string(errno())\n-}\n-\n-/// Sets the process exit code\n-///\n-/// Sets the exit code returned by the process if all supervised tasks\n-/// terminate successfully (without panicking). If the current root task panics\n-/// and is supervised by the scheduler then any user-specified exit status is\n-/// ignored and the process exits with the default panic status.\n-///\n-/// Note that this is not synchronized against modifications of other threads.\n-#[deprecated(since = \"1.0.0\", reason = \"renamed to env::set_exit_status\")]\n-#[unstable(feature = \"os\")]\n-pub fn set_exit_status(code: isize) {\n-    env::set_exit_status(code as i32)\n-}\n-\n-/// Fetches the process's current exit code. This defaults to 0 and can change\n-/// by calling `set_exit_status`.\n-#[deprecated(since = \"1.0.0\", reason = \"renamed to env::get_exit_status\")]\n-#[unstable(feature = \"os\")]\n-pub fn get_exit_status() -> isize {\n-    env::get_exit_status() as isize\n-}\n-\n-#[cfg(target_os = \"macos\")]\n-unsafe fn load_argc_and_argv(argc: isize,\n-                             argv: *const *const c_char) -> Vec<Vec<u8>> {\n-    use ffi::CStr;\n-\n-    (0..argc).map(|i| {\n-        CStr::from_ptr(*argv.offset(i)).to_bytes().to_vec()\n-    }).collect()\n-}\n-\n-/// Returns the command line arguments\n-///\n-/// Returns a list of the command line arguments.\n-#[cfg(target_os = \"macos\")]\n-fn real_args_as_bytes() -> Vec<Vec<u8>> {\n-    unsafe {\n-        let (argc, argv) = (*_NSGetArgc() as isize,\n-                            *_NSGetArgv() as *const *const c_char);\n-        load_argc_and_argv(argc, argv)\n-    }\n-}\n-\n-// As _NSGetArgc and _NSGetArgv aren't mentioned in iOS docs\n-// and use underscores in their names - they're most probably\n-// are considered private and therefore should be avoided\n-// Here is another way to get arguments using Objective C\n-// runtime\n-//\n-// In general it looks like:\n-// res = Vec::new()\n-// let args = [[NSProcessInfo processInfo] arguments]\n-// for i in 0..[args count]\n-//      res.push([args objectAtIndex:i])\n-// res\n-#[cfg(target_os = \"ios\")]\n-fn real_args_as_bytes() -> Vec<Vec<u8>> {\n-    use ffi::CStr;\n-    use iter::range;\n-    use mem;\n-\n-    #[link(name = \"objc\")]\n-    extern {\n-        fn sel_registerName(name: *const libc::c_uchar) -> Sel;\n-        fn objc_msgSend(obj: NsId, sel: Sel, ...) -> NsId;\n-        fn objc_getClass(class_name: *const libc::c_uchar) -> NsId;\n-    }\n-\n-    #[link(name = \"Foundation\", kind = \"framework\")]\n-    extern {}\n-\n-    type Sel = *const libc::c_void;\n-    type NsId = *const libc::c_void;\n-\n-    let mut res = Vec::new();\n-\n-    unsafe {\n-        let processInfoSel = sel_registerName(\"processInfo\\0\".as_ptr());\n-        let argumentsSel = sel_registerName(\"arguments\\0\".as_ptr());\n-        let utf8Sel = sel_registerName(\"UTF8String\\0\".as_ptr());\n-        let countSel = sel_registerName(\"count\\0\".as_ptr());\n-        let objectAtSel = sel_registerName(\"objectAtIndex:\\0\".as_ptr());\n-\n-        let klass = objc_getClass(\"NSProcessInfo\\0\".as_ptr());\n-        let info = objc_msgSend(klass, processInfoSel);\n-        let args = objc_msgSend(info, argumentsSel);\n-\n-        let cnt: isize = mem::transmute(objc_msgSend(args, countSel));\n-        for i in 0..cnt {\n-            let tmp = objc_msgSend(args, objectAtSel, i);\n-            let utf_c_str: *const libc::c_char =\n-                mem::transmute(objc_msgSend(tmp, utf8Sel));\n-            res.push(CStr::from_ptr(utf_c_str).to_bytes().to_vec());\n-        }\n-    }\n-\n-    res\n-}\n-\n-#[cfg(any(target_os = \"linux\",\n-          target_os = \"android\",\n-          target_os = \"freebsd\",\n-          target_os = \"dragonfly\",\n-          target_os = \"bitrig\",\n-          target_os = \"openbsd\"))]\n-fn real_args_as_bytes() -> Vec<Vec<u8>> {\n-    use rt;\n-    rt::args::clone().unwrap_or_else(|| vec![])\n-}\n-\n-#[cfg(not(windows))]\n-fn real_args() -> Vec<String> {\n-    real_args_as_bytes().into_iter()\n-                        .map(|v| {\n-                            String::from_utf8_lossy(&v).into_owned()\n-                        }).collect()\n-}\n-\n-#[cfg(windows)]\n-fn real_args() -> Vec<String> {\n-    use slice;\n-    use iter::range;\n-\n-    let mut nArgs: c_int = 0;\n-    let lpArgCount: *mut c_int = &mut nArgs;\n-    let lpCmdLine = unsafe { GetCommandLineW() };\n-    let szArgList = unsafe { CommandLineToArgvW(lpCmdLine, lpArgCount) };\n-\n-    let args: Vec<_> = (0..nArgs as usize).map(|i| unsafe {\n-        // Determine the length of this argument.\n-        let ptr = *szArgList.offset(i as isize);\n-        let mut len = 0;\n-        while *ptr.offset(len as isize) != 0 { len += 1; }\n-\n-        // Push it onto the list.\n-        let ptr = ptr as *const u16;\n-        let buf = slice::from_raw_parts(ptr, len);\n-        let opt_s = String::from_utf16(sys::truncate_utf16_at_nul(buf));\n-        opt_s.ok().expect(\"CommandLineToArgvW returned invalid UTF-16\")\n-    }).collect();\n-\n-    unsafe {\n-        LocalFree(szArgList as *mut c_void);\n-    }\n-\n-    return args\n-}\n-\n-#[cfg(windows)]\n-fn real_args_as_bytes() -> Vec<Vec<u8>> {\n-    real_args().into_iter().map(|s| s.into_bytes()).collect()\n-}\n-\n-type LPCWSTR = *const u16;\n-\n-#[cfg(windows)]\n-#[link_name=\"kernel32\"]\n-extern \"system\" {\n-    fn GetCommandLineW() -> LPCWSTR;\n-    fn LocalFree(ptr: *mut c_void);\n-}\n-\n-#[cfg(windows)]\n-#[link_name=\"shell32\"]\n-extern \"system\" {\n-    fn CommandLineToArgvW(lpCmdLine: LPCWSTR,\n-                          pNumArgs: *mut c_int) -> *mut *mut u16;\n-}\n-\n-/// Returns the arguments which this program was started with (normally passed\n-/// via the command line).\n-///\n-/// The first element is traditionally the path to the executable, but it can be\n-/// set to arbitrary text, and it may not even exist, so this property should not\n-/// be relied upon for security purposes.\n-///\n-/// The arguments are interpreted as utf-8, with invalid bytes replaced with \\uFFFD.\n-/// See `String::from_utf8_lossy` for details.\n-/// # Examples\n-///\n-/// ```\n-/// # #![feature(os)]\n-/// use std::os;\n-///\n-/// // Prints each argument on a separate line\n-/// for argument in os::args().iter() {\n-///     println!(\"{}\", argument);\n-/// }\n-/// ```\n-#[deprecated(since = \"1.0.0\", reason = \"use std::env::args() instead\")]\n-#[unstable(feature = \"os\")]\n-pub fn args() -> Vec<String> {\n-    real_args()\n-}\n-\n-/// Returns the arguments which this program was started with (normally passed\n-/// via the command line) as byte vectors.\n-#[deprecated(since = \"1.0.0\", reason = \"use env::args_os instead\")]\n-#[unstable(feature = \"os\")]\n-pub fn args_as_bytes() -> Vec<Vec<u8>> {\n-    real_args_as_bytes()\n-}\n-\n-#[cfg(target_os = \"macos\")]\n-extern {\n-    // These functions are in crt_externs.h.\n-    fn _NSGetArgc() -> *mut c_int;\n-    fn _NSGetArgv() -> *mut *mut *mut c_char;\n-}\n-\n-/// Returns the page size of the current architecture in bytes.\n-#[deprecated(since = \"1.0.0\", reason = \"renamed to env::page_size\")]\n-#[unstable(feature = \"os\")]\n-pub fn page_size() -> usize {\n-    sys::os::page_size()\n-}\n-\n-/// A memory mapped file or chunk of memory. This is a very system-specific\n-/// interface to the OS's memory mapping facilities (`mmap` on POSIX,\n-/// `VirtualAlloc`/`CreateFileMapping` on Windows). It makes no attempt at\n-/// abstracting platform differences, besides in error values returned. Consider\n-/// yourself warned.\n-///\n-/// The memory map is released (unmapped) when the destructor is run, so don't\n-/// let it leave scope by accident if you want it to stick around.\n-pub struct MemoryMap {\n-    data: *mut u8,\n-    len: usize,\n-    kind: MemoryMapKind,\n-}\n-\n-/// Type of memory map\n-#[allow(raw_pointer_derive)]\n-#[derive(Copy)]\n-pub enum MemoryMapKind {\n-    /// Virtual memory map. Usually used to change the permissions of a given\n-    /// chunk of memory.  Corresponds to `VirtualAlloc` on Windows.\n-    MapFile(*const u8),\n-    /// Virtual memory map. Usually used to change the permissions of a given\n-    /// chunk of memory, or for allocation. Corresponds to `VirtualAlloc` on\n-    /// Windows.\n-    MapVirtual\n-}\n-\n-/// Options the memory map is created with\n-#[allow(raw_pointer_derive)]\n-#[derive(Copy)]\n-pub enum MapOption {\n-    /// The memory should be readable\n-    MapReadable,\n-    /// The memory should be writable\n-    MapWritable,\n-    /// The memory should be executable\n-    MapExecutable,\n-    /// Create a map for a specific address range. Corresponds to `MAP_FIXED` on\n-    /// POSIX.\n-    MapAddr(*const u8),\n-    /// Create a memory mapping for a file with a given HANDLE.\n-    #[cfg(windows)]\n-    MapFd(libc::HANDLE),\n-    /// Create a memory mapping for a file with a given fd.\n-    #[cfg(not(windows))]\n-    MapFd(c_int),\n-    /// When using `MapFd`, the start of the map is `usize` bytes from the start\n-    /// of the file.\n-    MapOffset(usize),\n-    /// On POSIX, this can be used to specify the default flags passed to\n-    /// `mmap`. By default it uses `MAP_PRIVATE` and, if not using `MapFd`,\n-    /// `MAP_ANON`. This will override both of those. This is platform-specific\n-    /// (the exact values used) and ignored on Windows.\n-    MapNonStandardFlags(c_int),\n-}\n-\n-/// Possible errors when creating a map.\n-#[derive(Copy, Debug)]\n-pub enum MapError {\n-    /// # The following are POSIX-specific\n-    ///\n-    /// fd was not open for reading or, if using `MapWritable`, was not open for\n-    /// writing.\n-    ErrFdNotAvail,\n-    /// fd was not valid\n-    ErrInvalidFd,\n-    /// Either the address given by `MapAddr` or offset given by `MapOffset` was\n-    /// not a multiple of `MemoryMap::granularity` (unaligned to page size).\n-    ErrUnaligned,\n-    /// With `MapFd`, the fd does not support mapping.\n-    ErrNoMapSupport,\n-    /// If using `MapAddr`, the address + `min_len` was outside of the process's\n-    /// address space. If using `MapFd`, the target of the fd didn't have enough\n-    /// resources to fulfill the request.\n-    ErrNoMem,\n-    /// A zero-length map was requested. This is invalid according to\n-    /// [POSIX](http://pubs.opengroup.org/onlinepubs/9699919799/functions/mmap.html).\n-    /// Not all platforms obey this, but this wrapper does.\n-    ErrZeroLength,\n-    /// Unrecognized error. The inner value is the unrecognized errno.\n-    ErrUnknown(isize),\n-    /// # The following are Windows-specific\n-    ///\n-    /// Unsupported combination of protection flags\n-    /// (`MapReadable`/`MapWritable`/`MapExecutable`).\n-    ErrUnsupProt,\n-    /// When using `MapFd`, `MapOffset` was given (Windows does not support this\n-    /// at all)\n-    ErrUnsupOffset,\n-    /// When using `MapFd`, there was already a mapping to the file.\n-    ErrAlreadyExists,\n-    /// Unrecognized error from `VirtualAlloc`. The inner value is the return\n-    /// value of GetLastError.\n-    ErrVirtualAlloc(i32),\n-    /// Unrecognized error from `CreateFileMapping`. The inner value is the\n-    /// return value of `GetLastError`.\n-    ErrCreateFileMappingW(i32),\n-    /// Unrecognized error from `MapViewOfFile`. The inner value is the return\n-    /// value of `GetLastError`.\n-    ErrMapViewOfFile(i32)\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl fmt::Display for MapError {\n-    fn fmt(&self, out: &mut fmt::Formatter) -> fmt::Result {\n-        let str = match *self {\n-            ErrFdNotAvail => \"fd not available for reading or writing\",\n-            ErrInvalidFd => \"Invalid fd\",\n-            ErrUnaligned => {\n-                \"Unaligned address, invalid flags, negative length or \\\n-                 unaligned offset\"\n-            }\n-            ErrNoMapSupport=> \"File doesn't support mapping\",\n-            ErrNoMem => \"Invalid address, or not enough available memory\",\n-            ErrUnsupProt => \"Protection mode unsupported\",\n-            ErrUnsupOffset => \"Offset in virtual memory mode is unsupported\",\n-            ErrAlreadyExists => \"File mapping for specified file already exists\",\n-            ErrZeroLength => \"Zero-length mapping not allowed\",\n-            ErrUnknown(code) => {\n-                return write!(out, \"Unknown error = {}\", code)\n-            },\n-            ErrVirtualAlloc(code) => {\n-                return write!(out, \"VirtualAlloc failure = {}\", code)\n-            },\n-            ErrCreateFileMappingW(code) => {\n-                return write!(out, \"CreateFileMappingW failure = {}\", code)\n-            },\n-            ErrMapViewOfFile(code) => {\n-                return write!(out, \"MapViewOfFile failure = {}\", code)\n-            }\n-        };\n-        write!(out, \"{}\", str)\n-    }\n-}\n-\n-impl Error for MapError {\n-    fn description(&self) -> &str { \"memory map error\" }\n-}\n-\n-// Round up `from` to be divisible by `to`\n-fn round_up(from: usize, to: usize) -> usize {\n-    let r = if from % to == 0 {\n-        from\n-    } else {\n-        from + to - (from % to)\n-    };\n-    if r == 0 {\n-        to\n-    } else {\n-        r\n-    }\n-}\n-\n-#[cfg(unix)]\n-impl MemoryMap {\n-    /// Create a new mapping with the given `options`, at least `min_len` bytes\n-    /// long. `min_len` must be greater than zero; see the note on\n-    /// `ErrZeroLength`.\n-    pub fn new(min_len: usize, options: &[MapOption]) -> Result<MemoryMap, MapError> {\n-        use libc::off_t;\n-\n-        if min_len == 0 {\n-            return Err(ErrZeroLength)\n-        }\n-        let mut addr: *const u8 = ptr::null();\n-        let mut prot = 0;\n-        let mut flags = libc::MAP_PRIVATE;\n-        let mut fd = -1;\n-        let mut offset = 0;\n-        let mut custom_flags = false;\n-        let len = round_up(min_len, env::page_size());\n-\n-        for &o in options {\n-            match o {\n-                MapReadable => { prot |= libc::PROT_READ; },\n-                MapWritable => { prot |= libc::PROT_WRITE; },\n-                MapExecutable => { prot |= libc::PROT_EXEC; },\n-                MapAddr(addr_) => {\n-                    flags |= libc::MAP_FIXED;\n-                    addr = addr_;\n-                },\n-                MapFd(fd_) => {\n-                    flags |= libc::MAP_FILE;\n-                    fd = fd_;\n-                },\n-                MapOffset(offset_) => { offset = offset_ as off_t; },\n-                MapNonStandardFlags(f) => { custom_flags = true; flags = f },\n-            }\n-        }\n-        if fd == -1 && !custom_flags { flags |= libc::MAP_ANON; }\n-\n-        let r = unsafe {\n-            libc::mmap(addr as *mut c_void, len as libc::size_t, prot, flags,\n-                       fd, offset)\n-        };\n-        if r == libc::MAP_FAILED {\n-            Err(match errno() as c_int {\n-                libc::EACCES => ErrFdNotAvail,\n-                libc::EBADF => ErrInvalidFd,\n-                libc::EINVAL => ErrUnaligned,\n-                libc::ENODEV => ErrNoMapSupport,\n-                libc::ENOMEM => ErrNoMem,\n-                code => ErrUnknown(code as isize)\n-            })\n-        } else {\n-            Ok(MemoryMap {\n-               data: r as *mut u8,\n-               len: len,\n-               kind: if fd == -1 {\n-                   MapVirtual\n-               } else {\n-                   MapFile(ptr::null())\n-               }\n-            })\n-        }\n-    }\n-\n-    /// Granularity that the offset or address must be for `MapOffset` and\n-    /// `MapAddr` respectively.\n-    pub fn granularity() -> usize {\n-        env::page_size()\n-    }\n-}\n-\n-#[cfg(unix)]\n-impl Drop for MemoryMap {\n-    /// Unmap the mapping. Panics the task if `munmap` panics.\n-    fn drop(&mut self) {\n-        if self.len == 0 { /* workaround for dummy_stack */ return; }\n-\n-        unsafe {\n-            // `munmap` only panics due to logic errors\n-            libc::munmap(self.data as *mut c_void, self.len as libc::size_t);\n-        }\n-    }\n-}\n-\n-#[cfg(windows)]\n-impl MemoryMap {\n-    /// Create a new mapping with the given `options`, at least `min_len` bytes long.\n-    pub fn new(min_len: usize, options: &[MapOption]) -> Result<MemoryMap, MapError> {\n-        use libc::types::os::arch::extra::{LPVOID, DWORD, SIZE_T, HANDLE};\n-\n-        let mut lpAddress: LPVOID = ptr::null_mut();\n-        let mut readable = false;\n-        let mut writable = false;\n-        let mut executable = false;\n-        let mut handle: HANDLE = libc::INVALID_HANDLE_VALUE;\n-        let mut offset: usize = 0;\n-        let len = round_up(min_len, env::page_size());\n-\n-        for &o in options {\n-            match o {\n-                MapReadable => { readable = true; },\n-                MapWritable => { writable = true; },\n-                MapExecutable => { executable = true; }\n-                MapAddr(addr_) => { lpAddress = addr_ as LPVOID; },\n-                MapFd(handle_) => { handle = handle_; },\n-                MapOffset(offset_) => { offset = offset_; },\n-                MapNonStandardFlags(..) => {}\n-            }\n-        }\n-\n-        let flProtect = match (executable, readable, writable) {\n-            (false, false, false) if handle == libc::INVALID_HANDLE_VALUE => libc::PAGE_NOACCESS,\n-            (false, true, false) => libc::PAGE_READONLY,\n-            (false, true, true) => libc::PAGE_READWRITE,\n-            (true, false, false) if handle == libc::INVALID_HANDLE_VALUE => libc::PAGE_EXECUTE,\n-            (true, true, false) => libc::PAGE_EXECUTE_READ,\n-            (true, true, true) => libc::PAGE_EXECUTE_READWRITE,\n-            _ => return Err(ErrUnsupProt)\n-        };\n-\n-        if handle == libc::INVALID_HANDLE_VALUE {\n-            if offset != 0 {\n-                return Err(ErrUnsupOffset);\n-            }\n-            let r = unsafe {\n-                libc::VirtualAlloc(lpAddress,\n-                                   len as SIZE_T,\n-                                   libc::MEM_COMMIT | libc::MEM_RESERVE,\n-                                   flProtect)\n-            };\n-            match r as usize {\n-                0 => Err(ErrVirtualAlloc(errno())),\n-                _ => Ok(MemoryMap {\n-                   data: r as *mut u8,\n-                   len: len,\n-                   kind: MapVirtual\n-                })\n-            }\n-        } else {\n-            let dwDesiredAccess = match (executable, readable, writable) {\n-                (false, true, false) => libc::FILE_MAP_READ,\n-                (false, true, true) => libc::FILE_MAP_WRITE,\n-                (true, true, false) => libc::FILE_MAP_READ | libc::FILE_MAP_EXECUTE,\n-                (true, true, true) => libc::FILE_MAP_WRITE | libc::FILE_MAP_EXECUTE,\n-                _ => return Err(ErrUnsupProt) // Actually, because of the check above,\n-                                              // we should never get here.\n-            };\n-            unsafe {\n-                let hFile = handle;\n-                let mapping = libc::CreateFileMappingW(hFile,\n-                                                       ptr::null_mut(),\n-                                                       flProtect,\n-                                                       0,\n-                                                       0,\n-                                                       ptr::null());\n-                if mapping == ptr::null_mut() {\n-                    return Err(ErrCreateFileMappingW(errno()));\n-                }\n-                if errno() as c_int == libc::ERROR_ALREADY_EXISTS {\n-                    return Err(ErrAlreadyExists);\n-                }\n-                let r = libc::MapViewOfFile(mapping,\n-                                            dwDesiredAccess,\n-                                            ((len as u64) >> 32) as DWORD,\n-                                            (offset & 0xffff_ffff) as DWORD,\n-                                            0);\n-                match r as usize {\n-                    0 => Err(ErrMapViewOfFile(errno())),\n-                    _ => Ok(MemoryMap {\n-                       data: r as *mut u8,\n-                       len: len,\n-                       kind: MapFile(mapping as *const u8)\n-                    })\n-                }\n-            }\n-        }\n-    }\n-\n-    /// Granularity of MapAddr() and MapOffset() parameter values.\n-    /// This may be greater than the value returned by page_size().\n-    pub fn granularity() -> usize {\n-        use mem;\n-        unsafe {\n-            let mut info = mem::zeroed();\n-            libc::GetSystemInfo(&mut info);\n-\n-            return info.dwAllocationGranularity as usize;\n-        }\n-    }\n-}\n-\n-#[cfg(windows)]\n-impl Drop for MemoryMap {\n-    /// Unmap the mapping. Panics the task if any of `VirtualFree`,\n-    /// `UnmapViewOfFile`, or `CloseHandle` fail.\n-    fn drop(&mut self) {\n-        use libc::types::os::arch::extra::{LPCVOID, HANDLE};\n-        use libc::consts::os::extra::FALSE;\n-        if self.len == 0 { return }\n-\n-        unsafe {\n-            match self.kind {\n-                MapVirtual => {\n-                    if libc::VirtualFree(self.data as *mut c_void, 0,\n-                                         libc::MEM_RELEASE) == 0 {\n-                        println!(\"VirtualFree failed: {}\", errno());\n-                    }\n-                },\n-                MapFile(mapping) => {\n-                    if libc::UnmapViewOfFile(self.data as LPCVOID) == FALSE {\n-                        println!(\"UnmapViewOfFile failed: {}\", errno());\n-                    }\n-                    if libc::CloseHandle(mapping as HANDLE) == FALSE {\n-                        println!(\"CloseHandle failed: {}\", errno());\n-                    }\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-impl MemoryMap {\n-    /// Returns the pointer to the memory created or modified by this map.\n-    pub fn data(&self) -> *mut u8 { self.data }\n-    /// Returns the number of bytes this map applies to.\n-    pub fn len(&self) -> usize { self.len }\n-    /// Returns the type of mapping this represents.\n-    pub fn kind(&self) -> MemoryMapKind { self.kind }\n-}\n-\n-#[cfg(target_os = \"linux\")]\n-#[deprecated(since = \"1.0.0\", reason = \"renamed to env::consts\")]\n-#[unstable(feature = \"os\")]\n-pub mod consts {\n-    pub use os::arch_consts::ARCH;\n-\n-    pub const FAMILY: &'static str = \"unix\";\n-\n-    /// A string describing the specific operating system in use: in this\n-    /// case, `linux`.\n-    pub const SYSNAME: &'static str = \"linux\";\n-\n-    /// Specifies the filename prefix used for shared libraries on this\n-    /// platform: in this case, `lib`.\n-    pub const DLL_PREFIX: &'static str = \"lib\";\n-\n-    /// Specifies the filename suffix used for shared libraries on this\n-    /// platform: in this case, `.so`.\n-    pub const DLL_SUFFIX: &'static str = \".so\";\n-\n-    /// Specifies the file extension used for shared libraries on this\n-    /// platform that goes after the dot: in this case, `so`.\n-    pub const DLL_EXTENSION: &'static str = \"so\";\n-\n-    /// Specifies the filename suffix used for executable binaries on this\n-    /// platform: in this case, the empty string.\n-    pub const EXE_SUFFIX: &'static str = \"\";\n-\n-    /// Specifies the file extension, if any, used for executable binaries\n-    /// on this platform: in this case, the empty string.\n-    pub const EXE_EXTENSION: &'static str = \"\";\n-}\n-\n-#[cfg(target_os = \"macos\")]\n-#[deprecated(since = \"1.0.0\", reason = \"renamed to env::consts\")]\n-#[unstable(feature = \"os\")]\n-pub mod consts {\n-    pub use os::arch_consts::ARCH;\n-\n-    pub const FAMILY: &'static str = \"unix\";\n-\n-    /// A string describing the specific operating system in use: in this\n-    /// case, `macos`.\n-    pub const SYSNAME: &'static str = \"macos\";\n-\n-    /// Specifies the filename prefix used for shared libraries on this\n-    /// platform: in this case, `lib`.\n-    pub const DLL_PREFIX: &'static str = \"lib\";\n-\n-    /// Specifies the filename suffix used for shared libraries on this\n-    /// platform: in this case, `.dylib`.\n-    pub const DLL_SUFFIX: &'static str = \".dylib\";\n-\n-    /// Specifies the file extension used for shared libraries on this\n-    /// platform that goes after the dot: in this case, `dylib`.\n-    pub const DLL_EXTENSION: &'static str = \"dylib\";\n-\n-    /// Specifies the filename suffix used for executable binaries on this\n-    /// platform: in this case, the empty string.\n-    pub const EXE_SUFFIX: &'static str = \"\";\n-\n-    /// Specifies the file extension, if any, used for executable binaries\n-    /// on this platform: in this case, the empty string.\n-    pub const EXE_EXTENSION: &'static str = \"\";\n-}\n-\n-#[cfg(target_os = \"ios\")]\n-#[deprecated(since = \"1.0.0\", reason = \"renamed to env::consts\")]\n-#[unstable(feature = \"os\")]\n-pub mod consts {\n-    pub use os::arch_consts::ARCH;\n-\n-    pub const FAMILY: &'static str = \"unix\";\n-\n-    /// A string describing the specific operating system in use: in this\n-    /// case, `ios`.\n-    pub const SYSNAME: &'static str = \"ios\";\n-\n-    /// Specifies the filename suffix used for executable binaries on this\n-    /// platform: in this case, the empty string.\n-    pub const EXE_SUFFIX: &'static str = \"\";\n-\n-    /// Specifies the file extension, if any, used for executable binaries\n-    /// on this platform: in this case, the empty string.\n-    pub const EXE_EXTENSION: &'static str = \"\";\n-}\n-\n-#[cfg(target_os = \"freebsd\")]\n-#[deprecated(since = \"1.0.0\", reason = \"renamed to env::consts\")]\n-#[unstable(feature = \"os\")]\n-pub mod consts {\n-    pub use os::arch_consts::ARCH;\n-\n-    pub const FAMILY: &'static str = \"unix\";\n-\n-    /// A string describing the specific operating system in use: in this\n-    /// case, `freebsd`.\n-    pub const SYSNAME: &'static str = \"freebsd\";\n-\n-    /// Specifies the filename prefix used for shared libraries on this\n-    /// platform: in this case, `lib`.\n-    pub const DLL_PREFIX: &'static str = \"lib\";\n-\n-    /// Specifies the filename suffix used for shared libraries on this\n-    /// platform: in this case, `.so`.\n-    pub const DLL_SUFFIX: &'static str = \".so\";\n-\n-    /// Specifies the file extension used for shared libraries on this\n-    /// platform that goes after the dot: in this case, `so`.\n-    pub const DLL_EXTENSION: &'static str = \"so\";\n-\n-    /// Specifies the filename suffix used for executable binaries on this\n-    /// platform: in this case, the empty string.\n-    pub const EXE_SUFFIX: &'static str = \"\";\n-\n-    /// Specifies the file extension, if any, used for executable binaries\n-    /// on this platform: in this case, the empty string.\n-    pub const EXE_EXTENSION: &'static str = \"\";\n-}\n-\n-#[cfg(target_os = \"dragonfly\")]\n-#[deprecated(since = \"1.0.0\", reason = \"renamed to env::consts\")]\n-#[unstable(feature = \"os\")]\n-pub mod consts {\n-    pub use os::arch_consts::ARCH;\n-\n-    pub const FAMILY: &'static str = \"unix\";\n-\n-    /// A string describing the specific operating system in use: in this\n-    /// case, `dragonfly`.\n-    pub const SYSNAME: &'static str = \"dragonfly\";\n-\n-    /// Specifies the filename prefix used for shared libraries on this\n-    /// platform: in this case, `lib`.\n-    pub const DLL_PREFIX: &'static str = \"lib\";\n-\n-    /// Specifies the filename suffix used for shared libraries on this\n-    /// platform: in this case, `.so`.\n-    pub const DLL_SUFFIX: &'static str = \".so\";\n-\n-    /// Specifies the file extension used for shared libraries on this\n-    /// platform that goes after the dot: in this case, `so`.\n-    pub const DLL_EXTENSION: &'static str = \"so\";\n-\n-    /// Specifies the filename suffix used for executable binaries on this\n-    /// platform: in this case, the empty string.\n-    pub const EXE_SUFFIX: &'static str = \"\";\n-\n-    /// Specifies the file extension, if any, used for executable binaries\n-    /// on this platform: in this case, the empty string.\n-    pub const EXE_EXTENSION: &'static str = \"\";\n-}\n-\n-#[cfg(target_os = \"bitrig\")]\n-#[deprecated(since = \"1.0.0\", reason = \"renamed to env::consts\")]\n-#[unstable(feature = \"os\")]\n-pub mod consts {\n-    pub use os::arch_consts::ARCH;\n-\n-    pub const FAMILY: &'static str = \"unix\";\n-\n-    /// A string describing the specific operating system in use: in this\n-    /// case, `bitrig`.\n-    pub const SYSNAME: &'static str = \"bitrig\";\n-\n-    /// Specifies the filename prefix used for shared libraries on this\n-    /// platform: in this case, `lib`.\n-    pub const DLL_PREFIX: &'static str = \"lib\";\n-\n-    /// Specifies the filename suffix used for shared libraries on this\n-    /// platform: in this case, `.so`.\n-    pub const DLL_SUFFIX: &'static str = \".so\";\n-\n-    /// Specifies the file extension used for shared libraries on this\n-    /// platform that goes after the dot: in this case, `so`.\n-    pub const DLL_EXTENSION: &'static str = \"so\";\n-\n-    /// Specifies the filename suffix used for executable binaries on this\n-    /// platform: in this case, the empty string.\n-    pub const EXE_SUFFIX: &'static str = \"\";\n-\n-    /// Specifies the file extension, if any, used for executable binaries\n-    /// on this platform: in this case, the empty string.\n-    pub const EXE_EXTENSION: &'static str = \"\";\n-}\n-\n-#[cfg(target_os = \"openbsd\")]\n-#[deprecated(since = \"1.0.0\", reason = \"renamed to env::consts\")]\n-#[unstable(feature = \"os\")]\n-pub mod consts {\n-    pub use os::arch_consts::ARCH;\n-\n-    pub const FAMILY: &'static str = \"unix\";\n-\n-    /// A string describing the specific operating system in use: in this\n-    /// case, `openbsd`.\n-    pub const SYSNAME: &'static str = \"openbsd\";\n-\n-    /// Specifies the filename prefix used for shared libraries on this\n-    /// platform: in this case, `lib`.\n-    pub const DLL_PREFIX: &'static str = \"lib\";\n-\n-    /// Specifies the filename suffix used for shared libraries on this\n-    /// platform: in this case, `.so`.\n-    pub const DLL_SUFFIX: &'static str = \".so\";\n-\n-    /// Specifies the file extension used for shared libraries on this\n-    /// platform that goes after the dot: in this case, `so`.\n-    pub const DLL_EXTENSION: &'static str = \"so\";\n-\n-    /// Specifies the filename suffix used for executable binaries on this\n-    /// platform: in this case, the empty string.\n-    pub const EXE_SUFFIX: &'static str = \"\";\n-\n-    /// Specifies the file extension, if any, used for executable binaries\n-    /// on this platform: in this case, the empty string.\n-    pub const EXE_EXTENSION: &'static str = \"\";\n-}\n-\n-#[cfg(target_os = \"android\")]\n-#[deprecated(since = \"1.0.0\", reason = \"renamed to env::consts\")]\n-#[unstable(feature = \"os\")]\n-pub mod consts {\n-    pub use os::arch_consts::ARCH;\n-\n-    pub const FAMILY: &'static str = \"unix\";\n-\n-    /// A string describing the specific operating system in use: in this\n-    /// case, `android`.\n-    pub const SYSNAME: &'static str = \"android\";\n-\n-    /// Specifies the filename prefix used for shared libraries on this\n-    /// platform: in this case, `lib`.\n-    pub const DLL_PREFIX: &'static str = \"lib\";\n-\n-    /// Specifies the filename suffix used for shared libraries on this\n-    /// platform: in this case, `.so`.\n-    pub const DLL_SUFFIX: &'static str = \".so\";\n-\n-    /// Specifies the file extension used for shared libraries on this\n-    /// platform that goes after the dot: in this case, `so`.\n-    pub const DLL_EXTENSION: &'static str = \"so\";\n-\n-    /// Specifies the filename suffix used for executable binaries on this\n-    /// platform: in this case, the empty string.\n-    pub const EXE_SUFFIX: &'static str = \"\";\n-\n-    /// Specifies the file extension, if any, used for executable binaries\n-    /// on this platform: in this case, the empty string.\n-    pub const EXE_EXTENSION: &'static str = \"\";\n-}\n-\n-#[cfg(target_os = \"windows\")]\n-#[deprecated(since = \"1.0.0\", reason = \"renamed to env::consts\")]\n-#[unstable(feature = \"os\")]\n-pub mod consts {\n-    pub use os::arch_consts::ARCH;\n-\n-    pub const FAMILY: &'static str = \"windows\";\n-\n-    /// A string describing the specific operating system in use: in this\n-    /// case, `windows`.\n-    pub const SYSNAME: &'static str = \"windows\";\n-\n-    /// Specifies the filename prefix used for shared libraries on this\n-    /// platform: in this case, the empty string.\n-    pub const DLL_PREFIX: &'static str = \"\";\n-\n-    /// Specifies the filename suffix used for shared libraries on this\n-    /// platform: in this case, `.dll`.\n-    pub const DLL_SUFFIX: &'static str = \".dll\";\n-\n-    /// Specifies the file extension used for shared libraries on this\n-    /// platform that goes after the dot: in this case, `dll`.\n-    pub const DLL_EXTENSION: &'static str = \"dll\";\n-\n-    /// Specifies the filename suffix used for executable binaries on this\n-    /// platform: in this case, `.exe`.\n-    pub const EXE_SUFFIX: &'static str = \".exe\";\n-\n-    /// Specifies the file extension, if any, used for executable binaries\n-    /// on this platform: in this case, `exe`.\n-    pub const EXE_EXTENSION: &'static str = \"exe\";\n-}\n-\n-#[cfg(target_arch = \"x86\")]\n-mod arch_consts {\n-    pub const ARCH: &'static str = \"x86\";\n-}\n-\n-#[cfg(target_arch = \"x86_64\")]\n-mod arch_consts {\n-    pub const ARCH: &'static str = \"x86_64\";\n-}\n-\n-#[cfg(target_arch = \"arm\")]\n-mod arch_consts {\n-    pub const ARCH: &'static str = \"arm\";\n-}\n-\n-#[cfg(target_arch = \"aarch64\")]\n-mod arch_consts {\n-    pub const ARCH: &'static str = \"aarch64\";\n-}\n-\n-#[cfg(target_arch = \"mips\")]\n-mod arch_consts {\n-    pub const ARCH: &'static str = \"mips\";\n-}\n-\n-#[cfg(target_arch = \"mipsel\")]\n-mod arch_consts {\n-    pub const ARCH: &'static str = \"mipsel\";\n-}\n-\n-#[cfg(target_arch = \"powerpc\")]\n-mod arch_consts {\n-    pub const ARCH: &'static str = \"powerpc\";\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    #![allow(deprecated)] // rand\n-\n-    use prelude::v1::*;\n-\n-    use iter::repeat;\n-    use os::{env, getcwd, getenv, make_absolute};\n-    use os::{split_paths, join_paths, setenv, unsetenv};\n-    use os;\n-    use rand::Rng;\n-    use rand;\n-    use old_path::{Path, GenericPath};\n-    use old_io::{Reader, Writer, Seek};\n-\n-    #[test]\n-    pub fn last_os_error() {\n-        debug!(\"{}\", os::last_os_error());\n-    }\n-\n-    fn make_rand_name() -> String {\n-        let mut rng = rand::thread_rng();\n-        let n = format!(\"TEST{}\", rng.gen_ascii_chars().take(10)\n-                                     .collect::<String>());\n-        assert!(getenv(&n).is_none());\n-        n\n-    }\n-\n-    #[test]\n-    fn test_num_cpus() {\n-        assert!(os::num_cpus() > 0);\n-    }\n-\n-    #[test]\n-    fn test_setenv() {\n-        let n = make_rand_name();\n-        setenv(&n, \"VALUE\");\n-        assert_eq!(getenv(&n), Some(\"VALUE\".to_string()));\n-    }\n-\n-    #[test]\n-    fn test_unsetenv() {\n-        let n = make_rand_name();\n-        setenv(&n, \"VALUE\");\n-        unsetenv(&n);\n-        assert_eq!(getenv(&n), None);\n-    }\n-\n-    #[test]\n-    #[ignore]\n-    fn test_setenv_overwrite() {\n-        let n = make_rand_name();\n-        setenv(&n, \"1\");\n-        setenv(&n, \"2\");\n-        assert_eq!(getenv(&n), Some(\"2\".to_string()));\n-        setenv(&n, \"\");\n-        assert_eq!(getenv(&n), Some(\"\".to_string()));\n-    }\n-\n-    // Windows GetEnvironmentVariable requires some extra work to make sure\n-    // the buffer the variable is copied into is the right size\n-    #[test]\n-    #[ignore]\n-    fn test_getenv_big() {\n-        let mut s = \"\".to_string();\n-        let mut i = 0;\n-        while i < 100 {\n-            s.push_str(\"aaaaaaaaaa\");\n-            i += 1;\n-        }\n-        let n = make_rand_name();\n-        setenv(&n, &s);\n-        debug!(\"{}\", s.clone());\n-        assert_eq!(getenv(&n), Some(s));\n-    }\n-\n-    #[test]\n-    fn test_self_exe_name() {\n-        let path = os::self_exe_name();\n-        assert!(path.is_some());\n-        let path = path.unwrap();\n-        debug!(\"{}\", path.display());\n-\n-        // Hard to test this function\n-        assert!(path.is_absolute());\n-    }\n-\n-    #[test]\n-    fn test_self_exe_path() {\n-        let path = os::self_exe_path();\n-        assert!(path.is_some());\n-        let path = path.unwrap();\n-        debug!(\"{}\", path.display());\n-\n-        // Hard to test this function\n-        assert!(path.is_absolute());\n-    }\n-\n-    #[test]\n-    #[ignore]\n-    fn test_env_getenv() {\n-        let e = env();\n-        assert!(e.len() > 0);\n-        for p in &e {\n-            let (n, v) = (*p).clone();\n-            debug!(\"{}\", n);\n-            let v2 = getenv(&n);\n-            // MingW seems to set some funky environment variables like\n-            // \"=C:=C:\\MinGW\\msys\\1.0\\bin\" and \"!::=::\\\" that are returned\n-            // from env() but not visible from getenv().\n-            assert!(v2.is_none() || v2 == Some(v));\n-        }\n-    }\n-\n-    #[test]\n-    fn test_env_set_get_huge() {\n-        let n = make_rand_name();\n-        let s = repeat(\"x\").take(10000).collect::<String>();\n-        setenv(&n, &s);\n-        assert_eq!(getenv(&n), Some(s));\n-        unsetenv(&n);\n-        assert_eq!(getenv(&n), None);\n-    }\n-\n-    #[test]\n-    fn test_env_setenv() {\n-        let n = make_rand_name();\n-\n-        let mut e = env();\n-        setenv(&n, \"VALUE\");\n-        assert!(!e.contains(&(n.clone(), \"VALUE\".to_string())));\n-\n-        e = env();\n-        assert!(e.contains(&(n, \"VALUE\".to_string())));\n-    }\n-\n-    #[test]\n-    fn test() {\n-        assert!((!Path::new(\"test-path\").is_absolute()));\n-\n-        let cwd = getcwd().unwrap();\n-        debug!(\"Current working directory: {}\", cwd.display());\n-\n-        debug!(\"{}\", make_absolute(&Path::new(\"test-path\")).unwrap().display());\n-        debug!(\"{}\", make_absolute(&Path::new(\"/usr/bin\")).unwrap().display());\n-    }\n-\n-    #[test]\n-    #[cfg(unix)]\n-    fn homedir() {\n-        let oldhome = getenv(\"HOME\");\n-\n-        setenv(\"HOME\", \"/home/MountainView\");\n-        assert!(os::homedir() == Some(Path::new(\"/home/MountainView\")));\n-\n-        setenv(\"HOME\", \"\");\n-        assert!(os::homedir().is_none());\n-\n-        if let Some(s) = oldhome {\n-            setenv(\"HOME\", s);\n-        }\n-    }\n-\n-    #[test]\n-    #[cfg(windows)]\n-    fn homedir() {\n-\n-        let oldhome = getenv(\"HOME\");\n-        let olduserprofile = getenv(\"USERPROFILE\");\n-\n-        setenv(\"HOME\", \"\");\n-        setenv(\"USERPROFILE\", \"\");\n-\n-        assert!(os::homedir().is_none());\n-\n-        setenv(\"HOME\", \"/home/MountainView\");\n-        assert!(os::homedir() == Some(Path::new(\"/home/MountainView\")));\n-\n-        setenv(\"HOME\", \"\");\n-\n-        setenv(\"USERPROFILE\", \"/home/MountainView\");\n-        assert!(os::homedir() == Some(Path::new(\"/home/MountainView\")));\n-\n-        setenv(\"HOME\", \"/home/MountainView\");\n-        setenv(\"USERPROFILE\", \"/home/PaloAlto\");\n-        assert!(os::homedir() == Some(Path::new(\"/home/MountainView\")));\n-\n-        if let Some(s) = oldhome {\n-            setenv(\"HOME\", &s);\n-        }\n-        if let Some(s) = olduserprofile {\n-            setenv(\"USERPROFILE\", &s);\n-        }\n-    }\n-\n-    #[test]\n-    fn memory_map_rw() {\n-        use result::Result::{Ok, Err};\n-\n-        let chunk = match os::MemoryMap::new(16, &[\n-            os::MapOption::MapReadable,\n-            os::MapOption::MapWritable\n-        ]) {\n-            Ok(chunk) => chunk,\n-            Err(msg) => panic!(\"{:?}\", msg)\n-        };\n-        assert!(chunk.len >= 16);\n-\n-        unsafe {\n-            *chunk.data = 0xBE;\n-            assert!(*chunk.data == 0xBE);\n-        }\n-    }\n-\n-    #[test]\n-    fn memory_map_file() {\n-        use libc;\n-        use os::*;\n-        use old_io::fs::{File, unlink};\n-        use old_io::SeekStyle::SeekSet;\n-        use old_io::FileMode::Open;\n-        use old_io::FileAccess::ReadWrite;\n-\n-        #[cfg(not(windows))]\n-        fn get_fd(file: &File) -> libc::c_int {\n-            use os::unix::prelude::*;\n-            file.as_raw_fd()\n-        }\n-\n-        #[cfg(windows)]\n-        fn get_fd(file: &File) -> libc::HANDLE {\n-            use os::windows::prelude::*;\n-            file.as_raw_handle()\n-        }\n-\n-        let mut path = tmpdir();\n-        path.push(\"mmap_file.tmp\");\n-        let size = MemoryMap::granularity() * 2;\n-        let mut file = File::open_mode(&path, Open, ReadWrite).unwrap();\n-        file.seek(size as i64, SeekSet).unwrap();\n-        file.write_u8(0).unwrap();\n-\n-        let chunk = MemoryMap::new(size / 2, &[\n-            MapOption::MapReadable,\n-            MapOption::MapWritable,\n-            MapOption::MapFd(get_fd(&file)),\n-            MapOption::MapOffset(size / 2)\n-        ]).unwrap();\n-        assert!(chunk.len > 0);\n-\n-        unsafe {\n-            *chunk.data = 0xbe;\n-            assert!(*chunk.data == 0xbe);\n-        }\n-        drop(chunk);\n-\n-        unlink(&path).unwrap();\n-    }\n-\n-    #[test]\n-    #[cfg(windows)]\n-    fn split_paths_windows() {\n-        fn check_parse(unparsed: &str, parsed: &[&str]) -> bool {\n-            split_paths(unparsed) ==\n-                parsed.iter().map(|s| Path::new(*s)).collect::<Vec<_>>()\n-        }\n-\n-        assert!(check_parse(\"\", &mut [\"\"]));\n-        assert!(check_parse(r#\"\"\"\"#, &mut [\"\"]));\n-        assert!(check_parse(\";;\", &mut [\"\", \"\", \"\"]));\n-        assert!(check_parse(r\"c:\\\", &mut [r\"c:\\\"]));\n-        assert!(check_parse(r\"c:\\;\", &mut [r\"c:\\\", \"\"]));\n-        assert!(check_parse(r\"c:\\;c:\\Program Files\\\",\n-                            &mut [r\"c:\\\", r\"c:\\Program Files\\\"]));\n-        assert!(check_parse(r#\"c:\\;c:\\\"foo\"\\\"#, &mut [r\"c:\\\", r\"c:\\foo\\\"]));\n-        assert!(check_parse(r#\"c:\\;c:\\\"foo;bar\"\\;c:\\baz\"#,\n-                            &mut [r\"c:\\\", r\"c:\\foo;bar\\\", r\"c:\\baz\"]));\n-    }\n-\n-    #[test]\n-    #[cfg(unix)]\n-    fn split_paths_unix() {\n-        fn check_parse(unparsed: &str, parsed: &[&str]) -> bool {\n-            split_paths(unparsed) ==\n-                parsed.iter().map(|s| Path::new(*s)).collect::<Vec<_>>()\n-        }\n-\n-        assert!(check_parse(\"\", &mut [\"\"]));\n-        assert!(check_parse(\"::\", &mut [\"\", \"\", \"\"]));\n-        assert!(check_parse(\"/\", &mut [\"/\"]));\n-        assert!(check_parse(\"/:\", &mut [\"/\", \"\"]));\n-        assert!(check_parse(\"/:/usr/local\", &mut [\"/\", \"/usr/local\"]));\n-    }\n-\n-    #[test]\n-    #[cfg(unix)]\n-    fn join_paths_unix() {\n-        fn test_eq(input: &[&str], output: &str) -> bool {\n-            join_paths(input).unwrap() == output.as_bytes()\n-        }\n-\n-        assert!(test_eq(&[], \"\"));\n-        assert!(test_eq(&[\"/bin\", \"/usr/bin\", \"/usr/local/bin\"],\n-                         \"/bin:/usr/bin:/usr/local/bin\"));\n-        assert!(test_eq(&[\"\", \"/bin\", \"\", \"\", \"/usr/bin\", \"\"],\n-                         \":/bin:::/usr/bin:\"));\n-        assert!(join_paths(&[\"/te:st\"]).is_err());\n-    }\n-\n-    #[test]\n-    #[cfg(windows)]\n-    fn join_paths_windows() {\n-        fn test_eq(input: &[&str], output: &str) -> bool {\n-            join_paths(input).unwrap() == output.as_bytes()\n-        }\n-\n-        assert!(test_eq(&[], \"\"));\n-        assert!(test_eq(&[r\"c:\\windows\", r\"c:\\\"],\n-                        r\"c:\\windows;c:\\\"));\n-        assert!(test_eq(&[\"\", r\"c:\\windows\", \"\", \"\", r\"c:\\\", \"\"],\n-                        r\";c:\\windows;;;c:\\;\"));\n-        assert!(test_eq(&[r\"c:\\te;st\", r\"c:\\\"],\n-                        r#\"\"c:\\te;st\";c:\\\"#));\n-        assert!(join_paths(&[r#\"c:\\te\"st\"#]).is_err());\n-    }\n-\n-    // More recursive_mkdir tests are in extra::tempfile\n-}"}, {"sha": "44421c40901c9ca25074ebd92084a98ebcd7f10d", "filename": "src/libstd/path.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Flibstd%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Flibstd%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath.rs?ref=d4a2c941809f303b97d153e06ba07e95cd245f88", "patch": "@@ -1318,7 +1318,7 @@ impl Path {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn file_name(&self) -> Option<&OsStr> {\n         self.components().next_back().and_then(|p| match p {\n-            Component::Normal(p) => Some(p.as_os_str()),\n+            Component::Normal(p) => Some(p.as_ref()),\n             _ => None\n         })\n     }"}, {"sha": "84a450867675c814c96eff49d0873a0735ffc338", "filename": "src/libstd/prelude/v1.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Flibstd%2Fprelude%2Fv1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Flibstd%2Fprelude%2Fv1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprelude%2Fv1.rs?ref=d4a2c941809f303b97d153e06ba07e95cd245f88", "patch": "@@ -42,12 +42,11 @@\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[doc(no_inline)] pub use result::Result::{self, Ok, Err};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[allow(deprecated)]\n-#[doc(no_inline)] pub use slice::{SliceConcatExt, AsSlice};\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[allow(deprecated)]\n-#[doc(no_inline)] pub use str::Str;\n+#[doc(no_inline)] pub use slice::SliceConcatExt;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[doc(no_inline)] pub use string::{String, ToString};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[doc(no_inline)] pub use vec::Vec;\n+\n+#[allow(deprecated)] pub use slice::AsSlice;\n+#[allow(deprecated)] pub use str::Str;"}, {"sha": "ece0aa8f064d3c42d9f9a133f935d0126fefdf3b", "filename": "src/libstd/process.rs", "status": "modified", "additions": 24, "deletions": 28, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Flibstd%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Flibstd%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprocess.rs?ref=d4a2c941809f303b97d153e06ba07e95cd245f88", "patch": "@@ -16,15 +16,15 @@\n use prelude::v1::*;\n use io::prelude::*;\n \n-use ffi::AsOsStr;\n+use ffi::OsStr;\n use fmt;\n use io::{self, Error, ErrorKind};\n use libc;\n use path;\n use sync::mpsc::{channel, Receiver};\n use sys::pipe2::{self, AnonPipe};\n-use sys::process2::Process as ProcessImp;\n use sys::process2::Command as CommandImp;\n+use sys::process2::Process as ProcessImp;\n use sys::process2::ExitStatus as ExitStatusImp;\n use sys_common::{AsInner, AsInnerMut};\n use thread;\n@@ -147,9 +147,9 @@ impl Command {\n     /// Builder methods are provided to change these defaults and\n     /// otherwise configure the process.\n     #[stable(feature = \"process\", since = \"1.0.0\")]\n-    pub fn new<S: AsOsStr>(program: S) -> Command {\n+    pub fn new<S: AsRef<OsStr>>(program: S) -> Command {\n         Command {\n-            inner: CommandImp::new(program.as_os_str()),\n+            inner: CommandImp::new(program.as_ref()),\n             stdin: None,\n             stdout: None,\n             stderr: None,\n@@ -158,15 +158,15 @@ impl Command {\n \n     /// Add an argument to pass to the program.\n     #[stable(feature = \"process\", since = \"1.0.0\")]\n-    pub fn arg<S: AsOsStr>(&mut self, arg: S) -> &mut Command {\n-        self.inner.arg(arg.as_os_str());\n+    pub fn arg<S: AsRef<OsStr>>(&mut self, arg: S) -> &mut Command {\n+        self.inner.arg(arg.as_ref());\n         self\n     }\n \n     /// Add multiple arguments to pass to the program.\n     #[stable(feature = \"process\", since = \"1.0.0\")]\n-    pub fn args<S: AsOsStr>(&mut self, args: &[S]) -> &mut Command {\n-        self.inner.args(args.iter().map(AsOsStr::as_os_str));\n+    pub fn args<S: AsRef<OsStr>>(&mut self, args: &[S]) -> &mut Command {\n+        self.inner.args(args.iter().map(AsRef::as_ref));\n         self\n     }\n \n@@ -176,16 +176,16 @@ impl Command {\n     /// and case-sensitive on all other platforms.\n     #[stable(feature = \"process\", since = \"1.0.0\")]\n     pub fn env<K, V>(&mut self, key: K, val: V) -> &mut Command\n-        where K: AsOsStr, V: AsOsStr\n+        where K: AsRef<OsStr>, V: AsRef<OsStr>\n     {\n-        self.inner.env(key.as_os_str(), val.as_os_str());\n+        self.inner.env(key.as_ref(), val.as_ref());\n         self\n     }\n \n     /// Removes an environment variable mapping.\n     #[stable(feature = \"process\", since = \"1.0.0\")]\n-    pub fn env_remove<K: AsOsStr>(&mut self, key: K) -> &mut Command {\n-        self.inner.env_remove(key.as_os_str());\n+    pub fn env_remove<K: AsRef<OsStr>>(&mut self, key: K) -> &mut Command {\n+        self.inner.env_remove(key.as_ref());\n         self\n     }\n \n@@ -199,7 +199,7 @@ impl Command {\n     /// Set the working directory for the child process.\n     #[stable(feature = \"process\", since = \"1.0.0\")]\n     pub fn current_dir<P: AsRef<path::Path>>(&mut self, dir: P) -> &mut Command {\n-        self.inner.cwd(dir.as_ref().as_os_str());\n+        self.inner.cwd(dir.as_ref().as_ref());\n         self\n     }\n \n@@ -378,11 +378,6 @@ enum StdioImp {\n }\n \n impl Stdio {\n-    /// A new pipe should be arranged to connect the parent and child processes.\n-    #[unstable(feature = \"process_capture\")]\n-    #[deprecated(since = \"1.0.0\", reason = \"renamed to `Stdio::piped`\")]\n-    pub fn capture() -> Stdio { Stdio::piped() }\n-\n     /// A new pipe should be arranged to connect the parent and child processes.\n     #[stable(feature = \"process\", since = \"1.0.0\")]\n     pub fn piped() -> Stdio { Stdio(StdioImp::Piped) }\n@@ -529,11 +524,10 @@ impl Child {\n \n #[cfg(test)]\n mod tests {\n-    use io::ErrorKind;\n+    use prelude::v1::*;\n     use io::prelude::*;\n-    use prelude::v1::{Ok, Err, drop, Some, Vec};\n-    use prelude::v1::{String, Clone};\n-    use prelude::v1::{Str, AsSlice, ToString};\n+\n+    use io::ErrorKind;\n     use old_path::{self, GenericPath};\n     use old_io::fs::PathExtensions;\n     use rt::running_on_valgrind;\n@@ -678,7 +672,7 @@ mod tests {\n     fn test_process_output_output() {\n         let Output {status, stdout, stderr}\n              = Command::new(\"echo\").arg(\"hello\").output().unwrap();\n-        let output_str = str::from_utf8(stdout.as_slice()).unwrap();\n+        let output_str = str::from_utf8(&stdout).unwrap();\n \n         assert!(status.success());\n         assert_eq!(output_str.trim().to_string(), \"hello\");\n@@ -720,7 +714,7 @@ mod tests {\n         let prog = Command::new(\"echo\").arg(\"hello\").stdout(Stdio::piped())\n             .spawn().unwrap();\n         let Output {status, stdout, stderr} = prog.wait_with_output().unwrap();\n-        let output_str = str::from_utf8(stdout.as_slice()).unwrap();\n+        let output_str = str::from_utf8(&stdout).unwrap();\n \n         assert!(status.success());\n         assert_eq!(output_str.trim().to_string(), \"hello\");\n@@ -755,7 +749,8 @@ mod tests {\n         let prog = pwd_cmd().spawn().unwrap();\n \n         let output = String::from_utf8(prog.wait_with_output().unwrap().stdout).unwrap();\n-        let parent_dir = os::getcwd().unwrap();\n+        let parent_dir = ::env::current_dir().unwrap().to_str().unwrap().to_string();\n+        let parent_dir = old_path::Path::new(parent_dir);\n         let child_dir = old_path::Path::new(output.trim());\n \n         let parent_stat = parent_dir.stat().unwrap();\n@@ -770,7 +765,8 @@ mod tests {\n         use os;\n         // test changing to the parent of os::getcwd() because we know\n         // the path exists (and os::getcwd() is not expected to be root)\n-        let parent_dir = os::getcwd().unwrap().dir_path();\n+        let parent_dir = ::env::current_dir().unwrap().to_str().unwrap().to_string();\n+        let parent_dir = old_path::Path::new(parent_dir).dir_path();\n         let result = pwd_cmd().current_dir(parent_dir.as_str().unwrap()).output().unwrap();\n \n         let output = String::from_utf8(result.stdout).unwrap();\n@@ -855,7 +851,7 @@ mod tests {\n             cmd.env(\"PATH\", &p);\n         }\n         let result = cmd.output().unwrap();\n-        let output = String::from_utf8_lossy(result.stdout.as_slice()).to_string();\n+        let output = String::from_utf8_lossy(&result.stdout).to_string();\n \n         assert!(output.contains(\"RUN_TEST_NEW_ENV=123\"),\n                 \"didn't find RUN_TEST_NEW_ENV inside of:\\n\\n{}\", output);\n@@ -864,7 +860,7 @@ mod tests {\n     #[test]\n     fn test_add_to_env() {\n         let result = env_cmd().env(\"RUN_TEST_NEW_ENV\", \"123\").output().unwrap();\n-        let output = String::from_utf8_lossy(result.stdout.as_slice()).to_string();\n+        let output = String::from_utf8_lossy(&result.stdout).to_string();\n \n         assert!(output.contains(\"RUN_TEST_NEW_ENV=123\"),\n                 \"didn't find RUN_TEST_NEW_ENV inside of:\\n\\n{}\", output);"}, {"sha": "0a619ff8cd056abc3576cd053de0624940e5e90c", "filename": "src/libstd/rand/os.rs", "status": "modified", "additions": 16, "deletions": 17, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Flibstd%2Frand%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Flibstd%2Frand%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fos.rs?ref=d4a2c941809f303b97d153e06ba07e95cd245f88", "patch": "@@ -15,17 +15,16 @@ pub use self::imp::OsRng;\n \n #[cfg(all(unix, not(target_os = \"ios\")))]\n mod imp {\n-    extern crate libc;\n-\n+    use prelude::v1::*;\n     use self::OsRngInner::*;\n \n+    use libc;\n+    use mem;\n     use old_io::{IoResult, File};\n     use old_path::Path;\n     use rand::Rng;\n     use rand::reader::ReaderRng;\n-    use result::Result::Ok;\n-    use mem;\n-    use os::errno;\n+    use sys::os::errno;\n \n     #[cfg(all(target_os = \"linux\",\n               any(target_arch = \"x86_64\",\n@@ -184,14 +183,13 @@ mod imp {\n \n #[cfg(target_os = \"ios\")]\n mod imp {\n-    extern crate libc;\n+    use prelude::v1::*;\n \n-    use old_io::{IoResult};\n+    use old_io::IoResult;\n     use mem;\n     use os;\n     use rand::Rng;\n-    use result::Result::{Ok};\n-    use self::libc::{c_int, size_t};\n+    use libc::{c_int, size_t};\n \n     /// A random number generator that retrieves randomness straight from\n     /// the operating system. Platform sources:\n@@ -251,16 +249,15 @@ mod imp {\n \n #[cfg(windows)]\n mod imp {\n-    extern crate libc;\n+    use prelude::v1::*;\n \n-    use old_io::{IoResult, IoError};\n+    use io;\n     use mem;\n-    use ops::Drop;\n+    use old_io::{IoResult, IoError};\n     use os;\n     use rand::Rng;\n-    use result::Result::{Ok, Err};\n-    use self::libc::{DWORD, BYTE, LPCSTR, BOOL};\n-    use self::libc::types::os::arch::extra::{LONG_PTR};\n+    use libc::types::os::arch::extra::{LONG_PTR};\n+    use libc::{DWORD, BYTE, LPCSTR, BOOL};\n \n     type HCRYPTPROV = LONG_PTR;\n \n@@ -330,7 +327,8 @@ mod imp {\n                                v.as_mut_ptr())\n             };\n             if ret == 0 {\n-                panic!(\"couldn't generate random bytes: {}\", os::last_os_error());\n+                panic!(\"couldn't generate random bytes: {}\",\n+                       io::Error::last_os_error());\n             }\n         }\n     }\n@@ -341,7 +339,8 @@ mod imp {\n                 CryptReleaseContext(self.hcryptprov, 0)\n             };\n             if ret == 0 {\n-                panic!(\"couldn't release context: {}\", os::last_os_error());\n+                panic!(\"couldn't release context: {}\",\n+                       io::Error::last_os_error());\n             }\n         }\n     }"}, {"sha": "2329861f29bc06dc6b7428d8ecb9fc560720a573", "filename": "src/libstd/rt/args.rs", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Flibstd%2Frt%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Flibstd%2Frt%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fargs.rs?ref=d4a2c941809f303b97d153e06ba07e95cd245f88", "patch": "@@ -108,7 +108,6 @@ mod imp {\n     #[cfg(test)]\n     mod tests {\n         use prelude::v1::*;\n-        use finally::Finally;\n \n         use super::*;\n \n@@ -127,14 +126,11 @@ mod imp {\n             assert!(take() == Some(expected.clone()));\n             assert!(take() == None);\n \n-            (|| {\n-            }).finally(|| {\n-                // Restore the actual global state.\n-                match saved_value {\n-                    Some(ref args) => put(args.clone()),\n-                    None => ()\n-                }\n-            })\n+            // Restore the actual global state.\n+            match saved_value {\n+                Some(ref args) => put(args.clone()),\n+                None => ()\n+            }\n         }\n     }\n }"}, {"sha": "a5259a00390f55369a7e737781fe0f6c00f52e34", "filename": "src/libstd/sync/mod.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Flibstd%2Fsync%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Flibstd%2Fsync%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmod.rs?ref=d4a2c941809f303b97d153e06ba07e95cd245f88", "patch": "@@ -31,8 +31,6 @@ pub use self::barrier::{Barrier, BarrierWaitResult};\n pub use self::poison::{PoisonError, TryLockError, TryLockResult, LockResult};\n \n pub use self::future::Future;\n-#[allow(deprecated)]\n-pub use self::task_pool::TaskPool;\n \n pub mod mpsc;\n \n@@ -44,4 +42,3 @@ mod once;\n mod poison;\n mod rwlock;\n mod semaphore;\n-mod task_pool;"}, {"sha": "6ae8e043e051de727c04876286f062eed1ef02d8", "filename": "src/libstd/sync/poison.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Flibstd%2Fsync%2Fpoison.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Flibstd%2Fsync%2Fpoison.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fpoison.rs?ref=d4a2c941809f303b97d153e06ba07e95cd245f88", "patch": "@@ -122,12 +122,6 @@ impl<T> PoisonError<T> {\n         PoisonError { guard: guard }\n     }\n \n-    /// Consumes this error indicating that a lock is poisoned, returning the\n-    /// underlying guard to allow access regardless.\n-    #[unstable(feature = \"std_misc\")]\n-    #[deprecated(since = \"1.0.0\", reason = \"renamed to into_inner\")]\n-    pub fn into_guard(self) -> T { self.guard }\n-\n     /// Consumes this error indicating that a lock is poisoned, returning the\n     /// underlying guard to allow access regardless.\n     #[unstable(feature = \"std_misc\")]"}, {"sha": "51cf70e615bcc17eb1619a794b61c64ea595e37f", "filename": "src/libstd/sync/task_pool.rs", "status": "removed", "additions": 0, "deletions": 217, "changes": 217, "blob_url": "https://github.com/rust-lang/rust/blob/d754722a04b99fdcae0fd97fa2a4395521145ef2/src%2Flibstd%2Fsync%2Ftask_pool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d754722a04b99fdcae0fd97fa2a4395521145ef2/src%2Flibstd%2Fsync%2Ftask_pool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Ftask_pool.rs?ref=d754722a04b99fdcae0fd97fa2a4395521145ef2", "patch": "@@ -1,217 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Abstraction of a thread pool for basic parallelism.\n-\n-#![deprecated(since = \"1.0.0\",\n-              reason = \"This kind of API needs some time to bake in \\\n-                        crates.io. This functionality is available through \\\n-                        https://crates.io/crates/threadpool\")]\n-#![unstable(feature = \"std_misc\")]\n-\n-#![allow(deprecated)]\n-\n-use core::prelude::*;\n-\n-use sync::{Arc, Mutex};\n-use sync::mpsc::{channel, Sender, Receiver};\n-use thread;\n-use thunk::Thunk;\n-\n-struct Sentinel<'a> {\n-    jobs: &'a Arc<Mutex<Receiver<Thunk<'static>>>>,\n-    active: bool\n-}\n-\n-impl<'a> Sentinel<'a> {\n-    fn new(jobs: &'a Arc<Mutex<Receiver<Thunk<'static>>>>) -> Sentinel<'a> {\n-        Sentinel {\n-            jobs: jobs,\n-            active: true\n-        }\n-    }\n-\n-    // Cancel and destroy this sentinel.\n-    fn cancel(mut self) {\n-        self.active = false;\n-    }\n-}\n-\n-#[unsafe_destructor]\n-impl<'a> Drop for Sentinel<'a> {\n-    fn drop(&mut self) {\n-        if self.active {\n-            spawn_in_pool(self.jobs.clone())\n-        }\n-    }\n-}\n-\n-/// A thread pool used to execute functions in parallel.\n-///\n-/// Spawns `n` worker threads and replenishes the pool if any worker threads\n-/// panic.\n-///\n-/// # Examples\n-///\n-/// ```\n-/// # #![feature(std_misc, core)]\n-/// use std::sync::TaskPool;\n-/// use std::iter::AdditiveIterator;\n-/// use std::sync::mpsc::channel;\n-///\n-/// let pool = TaskPool::new(4);\n-///\n-/// let (tx, rx) = channel();\n-/// for _ in 0..8 {\n-///     let tx = tx.clone();\n-///     pool.execute(move|| {\n-///         tx.send(1_u32).unwrap();\n-///     });\n-/// }\n-///\n-/// assert_eq!(rx.iter().take(8).sum(), 8);\n-/// ```\n-pub struct TaskPool {\n-    // How the threadpool communicates with subthreads.\n-    //\n-    // This is the only such Sender, so when it is dropped all subthreads will\n-    // quit.\n-    jobs: Sender<Thunk<'static>>\n-}\n-\n-impl TaskPool {\n-    /// Spawns a new thread pool with `threads` threads.\n-    ///\n-    /// # Panics\n-    ///\n-    /// This function will panic if `threads` is 0.\n-    pub fn new(threads: usize) -> TaskPool {\n-        assert!(threads >= 1);\n-\n-        let (tx, rx) = channel::<Thunk>();\n-        let rx = Arc::new(Mutex::new(rx));\n-\n-        // Threadpool threads\n-        for _ in 0..threads {\n-            spawn_in_pool(rx.clone());\n-        }\n-\n-        TaskPool { jobs: tx }\n-    }\n-\n-    /// Executes the function `job` on a thread in the pool.\n-    pub fn execute<F>(&self, job: F)\n-        where F : FnOnce(), F : Send + 'static\n-    {\n-        self.jobs.send(Thunk::new(job)).unwrap();\n-    }\n-}\n-\n-fn spawn_in_pool(jobs: Arc<Mutex<Receiver<Thunk<'static>>>>) {\n-    thread::spawn(move || {\n-        // Will spawn a new thread on panic unless it is cancelled.\n-        let sentinel = Sentinel::new(&jobs);\n-\n-        loop {\n-            let message = {\n-                // Only lock jobs for the time it takes\n-                // to get a job, not run it.\n-                let lock = jobs.lock().unwrap();\n-                lock.recv()\n-            };\n-\n-            match message {\n-                Ok(job) => job.invoke(()),\n-\n-                // The Taskpool was dropped.\n-                Err(..) => break\n-            }\n-        }\n-\n-        sentinel.cancel();\n-    });\n-}\n-\n-#[cfg(test)]\n-mod test {\n-    use prelude::v1::*;\n-    use super::*;\n-    use sync::mpsc::channel;\n-\n-    const TEST_TASKS: usize = 4;\n-\n-    #[test]\n-    fn test_works() {\n-        use iter::AdditiveIterator;\n-\n-        let pool = TaskPool::new(TEST_TASKS);\n-\n-        let (tx, rx) = channel();\n-        for _ in 0..TEST_TASKS {\n-            let tx = tx.clone();\n-            pool.execute(move|| {\n-                tx.send(1).unwrap();\n-            });\n-        }\n-\n-        assert_eq!(rx.iter().take(TEST_TASKS).sum(), TEST_TASKS);\n-    }\n-\n-    #[test]\n-    #[should_panic]\n-    fn test_zero_tasks_panic() {\n-        TaskPool::new(0);\n-    }\n-\n-    #[test]\n-    fn test_recovery_from_subtask_panic() {\n-        use iter::AdditiveIterator;\n-\n-        let pool = TaskPool::new(TEST_TASKS);\n-\n-        // Panic all the existing threads.\n-        for _ in 0..TEST_TASKS {\n-            pool.execute(move|| -> () { panic!() });\n-        }\n-\n-        // Ensure new threads were spawned to compensate.\n-        let (tx, rx) = channel();\n-        for _ in 0..TEST_TASKS {\n-            let tx = tx.clone();\n-            pool.execute(move|| {\n-                tx.send(1).unwrap();\n-            });\n-        }\n-\n-        assert_eq!(rx.iter().take(TEST_TASKS).sum(), TEST_TASKS);\n-    }\n-\n-    #[test]\n-    fn test_should_not_panic_on_drop_if_subtasks_panic_after_drop() {\n-        use sync::{Arc, Barrier};\n-\n-        let pool = TaskPool::new(TEST_TASKS);\n-        let waiter = Arc::new(Barrier::new(TEST_TASKS + 1));\n-\n-        // Panic all the existing threads in a bit.\n-        for _ in 0..TEST_TASKS {\n-            let waiter = waiter.clone();\n-            pool.execute(move|| {\n-                waiter.wait();\n-                panic!();\n-            });\n-        }\n-\n-        drop(pool);\n-\n-        // Kick off the failure.\n-        waiter.wait();\n-    }\n-}"}, {"sha": "ca805ad02422ad6cda891f3a561bda0301dfebbf", "filename": "src/libstd/sys/unix/backtrace.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Flibstd%2Fsys%2Funix%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Flibstd%2Fsys%2Funix%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fbacktrace.rs?ref=d4a2c941809f303b97d153e06ba07e95cd245f88", "patch": "@@ -251,7 +251,6 @@ fn print(w: &mut Write, idx: isize, addr: *mut libc::c_void,\n fn print(w: &mut Write, idx: isize, addr: *mut libc::c_void,\n          symaddr: *mut libc::c_void) -> io::Result<()> {\n     use env;\n-    use ffi::AsOsStr;\n     use os::unix::prelude::*;\n     use ptr;\n "}, {"sha": "6b085c8eb7a85fc90b41b2239c4410e29118c5f4", "filename": "src/libstd/sys/unix/fs.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Flibstd%2Fsys%2Funix%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Flibstd%2Fsys%2Funix%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ffs.rs?ref=d4a2c941809f303b97d153e06ba07e95cd245f88", "patch": "@@ -388,9 +388,7 @@ mod tests {\n     fn test_file_desc() {\n         // Run this test with some pipes so we don't have to mess around with\n         // opening or closing files.\n-        let os::Pipe { reader, writer } = unsafe { os::pipe().unwrap() };\n-        let mut reader = FileDesc::new(reader, true);\n-        let mut writer = FileDesc::new(writer, true);\n+        let (mut reader, mut writer) = unsafe { ::sys::os::pipe().unwrap() };\n \n         writer.write(b\"test\").unwrap();\n         let mut buf = [0; 4];"}, {"sha": "f425c39667ae71b16be4eda7781297ebb92771d5", "filename": "src/libstd/sys/unix/fs2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Flibstd%2Fsys%2Funix%2Ffs2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Flibstd%2Fsys%2Funix%2Ffs2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ffs2.rs?ref=d4a2c941809f303b97d153e06ba07e95cd245f88", "patch": "@@ -12,7 +12,7 @@ use core::prelude::*;\n use io::prelude::*;\n use os::unix::prelude::*;\n \n-use ffi::{CString, CStr, OsString, AsOsStr, OsStr};\n+use ffi::{CString, CStr, OsString, OsStr};\n use io::{self, Error, SeekFrom};\n use libc::{self, c_int, size_t, off_t, c_char, mode_t};\n use mem;"}, {"sha": "fe0ede80fc663cbda1451a8cfffecb65aaecb178", "filename": "src/libstd/sys/unix/helper_signal.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Flibstd%2Fsys%2Funix%2Fhelper_signal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Flibstd%2Fsys%2Funix%2Fhelper_signal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fhelper_signal.rs?ref=d4a2c941809f303b97d153e06ba07e95cd245f88", "patch": "@@ -11,15 +11,15 @@\n #![allow(deprecated)]\n \n use libc;\n-use os;\n+use sys::os;\n \n use sys::fs::FileDesc;\n \n pub type signal = libc::c_int;\n \n pub fn new() -> (signal, signal) {\n-    let os::Pipe { reader, writer } = unsafe { os::pipe().unwrap() };\n-    (reader, writer)\n+    let (a, b) = unsafe { os::pipe().unwrap() };\n+    (a.unwrap(), b.unwrap())\n }\n \n pub fn signal(fd: libc::c_int) {"}, {"sha": "af5b40af9389263dbce47c88f8d7dc21543cf44e", "filename": "src/libstd/sys/unix/os.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Flibstd%2Fsys%2Funix%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Flibstd%2Fsys%2Funix%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fos.rs?ref=d4a2c941809f303b97d153e06ba07e95cd245f88", "patch": "@@ -16,7 +16,7 @@ use prelude::v1::*;\n use os::unix::prelude::*;\n \n use error::Error as StdError;\n-use ffi::{CString, CStr, OsString, OsStr, AsOsStr};\n+use ffi::{CString, CStr, OsString, OsStr};\n use fmt;\n use io;\n use iter;\n@@ -125,7 +125,8 @@ pub fn getcwd() -> io::Result<PathBuf> {\n }\n \n pub fn chdir(p: &path::Path) -> io::Result<()> {\n-    let p = try!(CString::new(p.as_os_str().as_bytes()));\n+    let p: &OsStr = p.as_ref();\n+    let p = try!(CString::new(p.as_bytes()));\n     unsafe {\n         match libc::chdir(p.as_ptr()) == (0 as c_int) {\n             true => Ok(()),\n@@ -158,13 +159,13 @@ impl<'a> Iterator for SplitPaths<'a> {\n pub struct JoinPathsError;\n \n pub fn join_paths<I, T>(paths: I) -> Result<OsString, JoinPathsError>\n-    where I: Iterator<Item=T>, T: AsOsStr\n+    where I: Iterator<Item=T>, T: AsRef<OsStr>\n {\n     let mut joined = Vec::new();\n     let sep = b':';\n \n     for (i, path) in paths.enumerate() {\n-        let path = path.as_os_str().as_bytes();\n+        let path = path.as_ref().as_bytes();\n         if i > 0 { joined.push(sep) }\n         if path.contains(&sep) {\n             return Err(JoinPathsError)\n@@ -464,7 +465,7 @@ pub fn page_size() -> usize {\n }\n \n pub fn temp_dir() -> PathBuf {\n-    getenv(\"TMPDIR\".as_os_str()).map(os2path).unwrap_or_else(|| {\n+    getenv(\"TMPDIR\".as_ref()).map(os2path).unwrap_or_else(|| {\n         if cfg!(target_os = \"android\") {\n             PathBuf::from(\"/data/local/tmp\")\n         } else {\n@@ -474,7 +475,7 @@ pub fn temp_dir() -> PathBuf {\n }\n \n pub fn home_dir() -> Option<PathBuf> {\n-    return getenv(\"HOME\".as_os_str()).or_else(|| unsafe {\n+    return getenv(\"HOME\".as_ref()).or_else(|| unsafe {\n         fallback()\n     }).map(os2path);\n "}, {"sha": "8095325f83d1faf553220784814a6e2f84b102a7", "filename": "src/libstd/sys/unix/process.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Flibstd%2Fsys%2Funix%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Flibstd%2Fsys%2Funix%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fprocess.rs?ref=d4a2c941809f303b97d153e06ba07e95cd245f88", "patch": "@@ -19,8 +19,9 @@ use hash::Hash;\n use old_io::process::{ProcessExit, ExitStatus, ExitSignal};\n use old_io::{IoResult, EndOfFile};\n use libc::{self, pid_t, c_void, c_int};\n+use io;\n use mem;\n-use os;\n+use sys::os;\n use old_path::BytesContainer;\n use ptr;\n use sync::mpsc::{channel, Sender, Receiver};\n@@ -496,7 +497,8 @@ impl Process {\n                     n if n > 0 => { ret = true; }\n                     0 => return true,\n                     -1 if wouldblock() => return ret,\n-                    n => panic!(\"bad read {:?} ({:?})\", os::last_os_error(), n),\n+                    n => panic!(\"bad read {} ({})\",\n+                                io::Error::last_os_error(), n),\n                 }\n             }\n         }"}, {"sha": "9309147b15c44f6bd14ae38417bf04ef010fcda2", "filename": "src/libstd/sys/unix/timer.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Flibstd%2Fsys%2Funix%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Flibstd%2Fsys%2Funix%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ftimer.rs?ref=d4a2c941809f303b97d153e06ba07e95cd245f88", "patch": "@@ -54,7 +54,8 @@ use self::Req::*;\n use old_io::IoResult;\n use libc;\n use mem;\n-use os;\n+use sys::os;\n+use io;\n use ptr;\n use sync::atomic::{self, Ordering};\n use sync::mpsc::{channel, Sender, Receiver, TryRecvError};\n@@ -209,7 +210,7 @@ fn helper(input: libc::c_int, messages: Receiver<Req>, _: ()) {\n \n             -1 if os::errno() == libc::EINTR as i32 => {}\n             n => panic!(\"helper thread failed in select() with error: {} ({})\",\n-                       n, os::last_os_error())\n+                       n, io::Error::last_os_error())\n         }\n     }\n }"}, {"sha": "1ebd4c571ac2d1205fb8ad848f4e833cec64108c", "filename": "src/libstd/sys/windows/os.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Flibstd%2Fsys%2Fwindows%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Flibstd%2Fsys%2Fwindows%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fos.rs?ref=d4a2c941809f303b97d153e06ba07e95cd245f88", "patch": "@@ -16,7 +16,7 @@ use prelude::v1::*;\n use os::windows::prelude::*;\n \n use error::Error as StdError;\n-use ffi::{OsString, OsStr, AsOsStr};\n+use ffi::{OsString, OsStr};\n use fmt;\n use io;\n use libc::types::os::arch::extra::LPWCH;\n@@ -199,13 +199,13 @@ impl<'a> Iterator for SplitPaths<'a> {\n pub struct JoinPathsError;\n \n pub fn join_paths<I, T>(paths: I) -> Result<OsString, JoinPathsError>\n-    where I: Iterator<Item=T>, T: AsOsStr\n+    where I: Iterator<Item=T>, T: AsRef<OsStr>\n {\n     let mut joined = Vec::new();\n     let sep = b';' as u16;\n \n     for (i, path) in paths.enumerate() {\n-        let path = path.as_os_str();\n+        let path = path.as_ref();\n         if i > 0 { joined.push(sep) }\n         let v = path.encode_wide().collect::<Vec<u16>>();\n         if v.contains(&(b'\"' as u16)) {\n@@ -245,7 +245,8 @@ pub fn getcwd() -> io::Result<PathBuf> {\n }\n \n pub fn chdir(p: &path::Path) -> io::Result<()> {\n-    let mut p = p.as_os_str().encode_wide().collect::<Vec<_>>();\n+    let p: &OsStr = p.as_ref();\n+    let mut p = p.encode_wide().collect::<Vec<_>>();\n     p.push(0);\n \n     unsafe {\n@@ -361,8 +362,8 @@ pub fn temp_dir() -> PathBuf {\n }\n \n pub fn home_dir() -> Option<PathBuf> {\n-    getenv(\"HOME\".as_os_str()).or_else(|| {\n-        getenv(\"USERPROFILE\".as_os_str())\n+    getenv(\"HOME\".as_ref()).or_else(|| {\n+        getenv(\"USERPROFILE\".as_ref())\n     }).map(PathBuf::from).or_else(|| unsafe {\n         let me = c::GetCurrentProcess();\n         let mut token = ptr::null_mut();"}, {"sha": "2065df4fbe35477a7b75389bbc26aafed92406db", "filename": "src/libstd/sys/windows/process.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs?ref=d4a2c941809f303b97d153e06ba07e95cd245f88", "patch": "@@ -23,6 +23,7 @@ use mem;\n use old_io::process::{ProcessExit, ExitStatus};\n use old_io::{IoResult, IoError};\n use old_io;\n+use fs::PathExt;\n use os;\n use old_path::{BytesContainer, GenericPath};\n use ptr;\n@@ -142,14 +143,19 @@ impl Process {\n         let program = cfg.env().and_then(|env| {\n             for (key, v) in env {\n                 if b\"PATH\" != key.container_as_bytes() { continue }\n+                let v = match ::str::from_utf8(v.container_as_bytes()) {\n+                    Ok(s) => s,\n+                    Err(..) => continue,\n+                };\n \n                 // Split the value and test each path to see if the\n                 // program exists.\n-                for path in os::split_paths(v.container_as_bytes()) {\n-                    let path = path.join(cfg.program().as_bytes())\n+                for path in ::env::split_paths(v) {\n+                    let program = str::from_utf8(cfg.program().as_bytes()).unwrap();\n+                    let path = path.join(program)\n                                    .with_extension(env::consts::EXE_EXTENSION);\n                     if path.exists() {\n-                        return Some(CString::from_slice(path.as_vec()))\n+                        return Some(CString::new(path.to_str().unwrap()).unwrap())\n                     }\n                 }\n                 break\n@@ -482,9 +488,9 @@ mod tests {\n     #[test]\n     fn test_make_command_line() {\n         fn test_wrapper(prog: &str, args: &[&str]) -> String {\n-            make_command_line(&CString::from_slice(prog.as_bytes()),\n+            make_command_line(&CString::new(prog),\n                               &args.iter()\n-                                   .map(|a| CString::from_slice(a.as_bytes()))\n+                                   .map(|a| CString::new(a))\n                                    .collect::<Vec<CString>>())\n         }\n "}, {"sha": "b9cbd01bed180120895dc28c1e3085a85b39b377", "filename": "src/libstd/thread/local.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Flibstd%2Fthread%2Flocal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Flibstd%2Fthread%2Flocal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread%2Flocal.rs?ref=d4a2c941809f303b97d153e06ba07e95cd245f88", "patch": "@@ -294,12 +294,6 @@ impl<T: 'static> LocalKey<T> {\n             }\n         }\n     }\n-\n-    /// Deprecated\n-    #[unstable(feature = \"std_misc\")]\n-    #[deprecated(since = \"1.0.0\",\n-                 reason = \"function renamed to state() and returns more info\")]\n-    pub fn destroyed(&'static self) -> bool { self.state() == LocalKeyState::Destroyed }\n }\n \n #[cfg(all(any(target_os = \"macos\", target_os = \"linux\"), not(target_arch = \"aarch64\")))]"}, {"sha": "b9515c9a8a103196664159560dedc677fa9e58bc", "filename": "src/libstd/thread/mod.rs", "status": "modified", "additions": 2, "deletions": 102, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Flibstd%2Fthread%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Flibstd%2Fthread%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread%2Fmod.rs?ref=d4a2c941809f303b97d153e06ba07e95cd245f88", "patch": "@@ -189,8 +189,6 @@ use sys_common::{stack, thread_info};\n use thunk::Thunk;\n use time::Duration;\n \n-#[allow(deprecated)] use old_io::Writer;\n-\n ////////////////////////////////////////////////////////////////////////////////\n // Thread-local storage\n ////////////////////////////////////////////////////////////////////////////////\n@@ -243,28 +241,6 @@ impl Builder {\n         self\n     }\n \n-    /// Redirect thread-local stdout.\n-    #[unstable(feature = \"std_misc\",\n-               reason = \"Will likely go away after proc removal\")]\n-    #[deprecated(since = \"1.0.0\",\n-                 reason = \"the old I/O module is deprecated and this function \\\n-                           will be removed with no replacement\")]\n-    #[allow(deprecated)]\n-    pub fn stdout(self, _stdout: Box<Writer + Send + 'static>) -> Builder {\n-        self\n-    }\n-\n-    /// Redirect thread-local stderr.\n-    #[unstable(feature = \"std_misc\",\n-               reason = \"Will likely go away after proc removal\")]\n-    #[deprecated(since = \"1.0.0\",\n-                 reason = \"the old I/O module is deprecated and this function \\\n-                           will be removed with no replacement\")]\n-    #[allow(deprecated)]\n-    pub fn stderr(self, _stderr: Box<Writer + Send + 'static>) -> Builder {\n-        self\n-    }\n-\n     /// Spawn a new thread, and return a join handle for it.\n     ///\n     /// The child thread may outlive the parent (unless the parent thread\n@@ -568,71 +544,6 @@ impl Thread {\n         }\n     }\n \n-    /// Deprecated: use module-level free function.\n-    #[deprecated(since = \"1.0.0\", reason = \"use module-level free function\")]\n-    #[unstable(feature = \"std_misc\",\n-               reason = \"may change with specifics of new Send semantics\")]\n-    pub fn spawn<F>(f: F) -> Thread where F: FnOnce(), F: Send + 'static {\n-        Builder::new().spawn(f).unwrap().thread().clone()\n-    }\n-\n-    /// Deprecated: use module-level free function.\n-    #[deprecated(since = \"1.0.0\", reason = \"use module-level free function\")]\n-    #[unstable(feature = \"std_misc\",\n-               reason = \"may change with specifics of new Send semantics\")]\n-    pub fn scoped<'a, T, F>(f: F) -> JoinGuard<'a, T> where\n-        T: Send + 'a, F: FnOnce() -> T, F: Send + 'a\n-    {\n-        Builder::new().scoped(f).unwrap()\n-    }\n-\n-    /// Deprecated: use module-level free function.\n-    #[deprecated(since = \"1.0.0\", reason = \"use module-level free function\")]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn current() -> Thread {\n-        thread_info::current_thread()\n-    }\n-\n-    /// Deprecated: use module-level free function.\n-    #[deprecated(since = \"1.0.0\", reason = \"use module-level free function\")]\n-    #[unstable(feature = \"std_misc\", reason = \"name may change\")]\n-    pub fn yield_now() {\n-        unsafe { imp::yield_now() }\n-    }\n-\n-    /// Deprecated: use module-level free function.\n-    #[deprecated(since = \"1.0.0\", reason = \"use module-level free function\")]\n-    #[inline]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn panicking() -> bool {\n-        unwind::panicking()\n-    }\n-\n-    /// Deprecated: use module-level free function.\n-    #[deprecated(since = \"1.0.0\", reason = \"use module-level free function\")]\n-    #[unstable(feature = \"std_misc\", reason = \"recently introduced\")]\n-    pub fn park() {\n-        let thread = current();\n-        let mut guard = thread.inner.lock.lock().unwrap();\n-        while !*guard {\n-            guard = thread.inner.cvar.wait(guard).unwrap();\n-        }\n-        *guard = false;\n-    }\n-\n-    /// Deprecated: use module-level free function.\n-    #[deprecated(since = \"1.0.0\", reason = \"use module-level free function\")]\n-    #[unstable(feature = \"std_misc\", reason = \"recently introduced\")]\n-    pub fn park_timeout(duration: Duration) {\n-        let thread = current();\n-        let mut guard = thread.inner.lock.lock().unwrap();\n-        if !*guard {\n-            let (g, _) = thread.inner.cvar.wait_timeout(guard, duration).unwrap();\n-            guard = g;\n-        }\n-        *guard = false;\n-    }\n-\n     /// Atomically makes the handle's token available if it is not already.\n     ///\n     /// See the module doc for more detail.\n@@ -762,8 +673,8 @@ impl<'a, T: Send + 'a> JoinGuard<'a, T> {\n         &self.inner.thread\n     }\n \n-    /// Wait for the associated thread to finish, returning the result of the thread's\n-    /// calculation.\n+    /// Wait for the associated thread to finish, returning the result of the\n+    /// thread's calculation.\n     ///\n     /// # Panics\n     ///\n@@ -777,17 +688,6 @@ impl<'a, T: Send + 'a> JoinGuard<'a, T> {\n     }\n }\n \n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: Send> JoinGuard<'static, T> {\n-    /// Detaches the child thread, allowing it to outlive its parent.\n-    #[deprecated(since = \"1.0.0\", reason = \"use spawn instead\")]\n-    #[unstable(feature = \"std_misc\")]\n-    pub fn detach(mut self) {\n-        unsafe { imp::detach(self.inner.native) };\n-        self.inner.joined = true; // avoid joining in the destructor\n-    }\n-}\n-\n #[unsafe_destructor]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T: Send + 'a> Drop for JoinGuard<'a, T> {"}, {"sha": "2d56d7ddf1bcd4f63c4bc071a397c83ef9a3c9fb", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=d4a2c941809f303b97d153e06ba07e95cd245f88", "patch": "@@ -43,7 +43,6 @@\n #![feature(std_misc)]\n #![feature(libc)]\n #![feature(set_stdio)]\n-#![feature(os)]\n #![feature(convert)]\n #![cfg_attr(test, feature(old_io))]\n \n@@ -857,7 +856,8 @@ fn get_concurrency() -> usize {\n             if std::rt::util::limit_thread_creation_due_to_osx_and_valgrind() {\n                 1\n             } else {\n-                std::os::num_cpus()\n+                extern { fn rust_get_num_cpus() -> libc::uintptr_t; }\n+                unsafe { rust_get_num_cpus() as usize }\n             }\n         }\n     }"}, {"sha": "ce050cc73235dfd76aced3df5d7b3fff0aeb4690", "filename": "src/test/bench/shootout-binarytrees.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Ftest%2Fbench%2Fshootout-binarytrees.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Ftest%2Fbench%2Fshootout-binarytrees.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-binarytrees.rs?ref=d4a2c941809f303b97d153e06ba07e95cd245f88", "patch": "@@ -38,11 +38,10 @@\n // ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED\n // OF THE POSSIBILITY OF SUCH DAMAGE.\n \n-#![feature(rustc_private, core)]\n+#![feature(rustc_private, core, step_by)]\n \n extern crate arena;\n \n-use std::iter::range_step;\n use std::thread;\n use arena::TypedArena;\n \n@@ -109,7 +108,7 @@ fn main() {\n     let long_lived_arena = TypedArena::new();\n     let long_lived_tree = bottom_up_tree(&long_lived_arena, 0, max_depth);\n \n-    let messages = range_step(min_depth, max_depth + 1, 2).map(|depth| {\n+    let messages = (min_depth..max_depth + 1).step_by(2).map(|depth| {\n         use std::num::Int;\n         let iterations = 2.pow((max_depth - depth + min_depth) as u32);\n         thread::scoped(move || inner(depth, iterations))"}, {"sha": "af9ef80e609bac36aff6e39eeeffa7fb3687a2f4", "filename": "src/test/bench/shootout-fannkuch-redux.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Ftest%2Fbench%2Fshootout-fannkuch-redux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Ftest%2Fbench%2Fshootout-fannkuch-redux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fannkuch-redux.rs?ref=d4a2c941809f303b97d153e06ba07e95cd245f88", "patch": "@@ -38,9 +38,9 @@\n // ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED\n // OF THE POSSIBILITY OF SUCH DAMAGE.\n \n-#![feature(core)]\n+#![feature(step_by)]\n \n-use std::{cmp, iter, mem};\n+use std::{cmp, mem};\n use std::thread;\n \n fn rotate(x: &mut [i32]) {\n@@ -163,7 +163,7 @@ fn fannkuch(n: i32) -> (i32, i32) {\n     let mut futures = vec![];\n     let k = perm.max() / N;\n \n-    for (_, j) in (0..N).zip(iter::count(0, k)) {\n+    for (_, j) in (0..N).zip((0..).step_by(k)) {\n         let max = cmp::min(j+k, perm.max());\n \n         futures.push(thread::scoped(move|| {"}, {"sha": "c190641bfbff02e468df6396c064805ad47139e9", "filename": "src/test/bench/shootout-k-nucleotide-pipes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs?ref=d4a2c941809f303b97d153e06ba07e95cd245f88", "patch": "@@ -193,7 +193,7 @@ fn main() {\n \n            // start processing if this is the one\n            ('>', false) => {\n-               match line[1..].find_str(\"THREE\") {\n+               match line[1..].find(\"THREE\") {\n                    Some(_) => { proc_mode = true; }\n                    None    => { }\n                }"}, {"sha": "c0268e816cf3e537b9c2b7653a4c89680fbebb66", "filename": "src/test/bench/shootout-spectralnorm.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs?ref=d4a2c941809f303b97d153e06ba07e95cd245f88", "patch": "@@ -118,7 +118,9 @@ fn dot(v: &[f64], u: &[f64]) -> f64 {\n fn parallel<'a,T, F>(v: &mut [T], ref f: F)\n                   where T: Send + Sync + 'a,\n                         F: Fn(usize, &mut [T]) + Sync + 'a {\n-    let size = v.len() / os::num_cpus() + 1;\n+    // FIXME: pick a more appropriate parallel factor\n+    let parallelism = 4;\n+    let size = v.len() / parallelism + 1;\n     v.chunks_mut(size).enumerate().map(|(i, chunk)| {\n         thread::scoped(move|| {\n             f(i * size, chunk)"}, {"sha": "40d992fe21f207abe22984110f44735c61fcced7", "filename": "src/test/compile-fail/dropck_arr_cycle_checked.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Ftest%2Fcompile-fail%2Fdropck_arr_cycle_checked.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Ftest%2Fcompile-fail%2Fdropck_arr_cycle_checked.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdropck_arr_cycle_checked.rs?ref=d4a2c941809f303b97d153e06ba07e95cd245f88", "patch": "@@ -20,9 +20,9 @@ use id::Id;\n \n mod s {\n     #![allow(unstable)]\n-    use std::sync::atomic::{AtomicUint, ATOMIC_UINT_INIT, Ordering};\n+    use std::sync::atomic::{AtomicUsize, ATOMIC_USIZE_INIT, Ordering};\n \n-    static S_COUNT: AtomicUint = ATOMIC_UINT_INIT;\n+    static S_COUNT: AtomicUsize = ATOMIC_USIZE_INIT;\n \n     pub fn next_count() -> usize {\n         S_COUNT.fetch_add(1, Ordering::SeqCst) + 1"}, {"sha": "9488882ca94a51421a5bf04d89d7ab0d5eb35df6", "filename": "src/test/compile-fail/dropck_tarena_cycle_checked.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Ftest%2Fcompile-fail%2Fdropck_tarena_cycle_checked.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Ftest%2Fcompile-fail%2Fdropck_tarena_cycle_checked.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdropck_tarena_cycle_checked.rs?ref=d4a2c941809f303b97d153e06ba07e95cd245f88", "patch": "@@ -27,9 +27,9 @@ use id::Id;\n \n mod s {\n     #![allow(unstable)]\n-    use std::sync::atomic::{AtomicUint, ATOMIC_UINT_INIT, Ordering};\n+    use std::sync::atomic::{AtomicUsize, ATOMIC_USIZE_INIT, Ordering};\n \n-    static S_COUNT: AtomicUint = ATOMIC_UINT_INIT;\n+    static S_COUNT: AtomicUsize = ATOMIC_USIZE_INIT;\n \n     pub fn next_count() -> usize {\n         S_COUNT.fetch_add(1, Ordering::SeqCst) + 1"}, {"sha": "9d92552244f28e651f83b1d03a639f68ce11cd32", "filename": "src/test/compile-fail/dropck_vec_cycle_checked.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Ftest%2Fcompile-fail%2Fdropck_vec_cycle_checked.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Ftest%2Fcompile-fail%2Fdropck_vec_cycle_checked.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdropck_vec_cycle_checked.rs?ref=d4a2c941809f303b97d153e06ba07e95cd245f88", "patch": "@@ -19,9 +19,9 @@ use id::Id;\n \n mod s {\n     #![allow(unstable)]\n-    use std::sync::atomic::{AtomicUint, ATOMIC_UINT_INIT, Ordering};\n+    use std::sync::atomic::{AtomicUsize, ATOMIC_USIZE_INIT, Ordering};\n \n-    static S_COUNT: AtomicUint = ATOMIC_UINT_INIT;\n+    static S_COUNT: AtomicUsize = ATOMIC_USIZE_INIT;\n \n     pub fn next_count() -> usize {\n         S_COUNT.fetch_add(1, Ordering::SeqCst) + 1"}, {"sha": "b5c6db0cea9e32767687133e5330509b1f5b3bdb", "filename": "src/test/compile-fail/estr-subtyping.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Ftest%2Fcompile-fail%2Festr-subtyping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Ftest%2Fcompile-fail%2Festr-subtyping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Festr-subtyping.rs?ref=d4a2c941809f303b97d153e06ba07e95cd245f88", "patch": "@@ -18,7 +18,7 @@ fn has_uniq(x: String) {\n \n fn has_slice(x: &str) {\n    wants_uniq(x); //~ ERROR mismatched types\n-   wants_slice(x.as_slice());\n+   wants_slice(x);\n }\n \n fn main() {"}, {"sha": "8886dd80be5039bed56eb68650bcf347efd7d6b9", "filename": "src/test/compile-fail/issue-13058.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Ftest%2Fcompile-fail%2Fissue-13058.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Ftest%2Fcompile-fail%2Fissue-13058.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-13058.rs?ref=d4a2c941809f303b97d153e06ba07e95cd245f88", "patch": "@@ -8,14 +8,14 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::iter::{Range,range};\n+use std::ops::Range;\n \n trait Itble<'r, T, I: Iterator<Item=T>> { fn iter(&'r self) -> I; }\n \n impl<'r> Itble<'r, usize, Range<usize>> for (usize, usize) {\n     fn iter(&'r self) -> Range<usize> {\n         let &(min, max) = self;\n-        range(min, max)\n+        min..max\n     }\n }\n "}, {"sha": "9e49abc463f15491906c9a402f844437ebdb980f", "filename": "src/test/compile-fail/issue-17651.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Ftest%2Fcompile-fail%2Fissue-17651.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Ftest%2Fcompile-fail%2Fissue-17651.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-17651.rs?ref=d4a2c941809f303b97d153e06ba07e95cd245f88", "patch": "@@ -13,6 +13,6 @@\n \n fn main() {\n     // FIXME (#22405): Replace `Box::new` with `box` here when/if possible.\n-    (|| Box::new(*[0].as_slice()))();\n+    (|| Box::new(*(&[0][..])))();\n     //~^ ERROR the trait `core::marker::Sized` is not implemented for the type `[_]`\n }"}, {"sha": "d2d0dbf3e981fe3fa32a24d7eb7d9bd32b8cbac4", "filename": "src/test/compile-fail/lifetime-inference-give-expl-lifetime-param-2.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Ftest%2Fcompile-fail%2Flifetime-inference-give-expl-lifetime-param-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Ftest%2Fcompile-fail%2Flifetime-inference-give-expl-lifetime-param-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flifetime-inference-give-expl-lifetime-param-2.rs?ref=d4a2c941809f303b97d153e06ba07e95cd245f88", "patch": "@@ -10,14 +10,14 @@\n \n // ignore-tidy-linelength\n \n-use std::iter::{Range,range};\n+use std::ops::Range;\n \n trait Itble<'r, T, I: Iterator<Item=T>> { fn iter(&'r self) -> I; }\n \n impl<'r> Itble<'r, usize, Range<usize>> for (usize, usize) {\n     fn iter(&'r self) -> Range<usize> {\n         let &(min, max) = self;\n-        range(min, max)\n+        min..max\n     }\n }\n "}, {"sha": "8f9d24cb132c2e4f2a475a4a540338ac5079b2ad", "filename": "src/test/compile-fail/variance-deprecated-markers.rs", "status": "removed", "additions": 0, "deletions": 35, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/d754722a04b99fdcae0fd97fa2a4395521145ef2/src%2Ftest%2Fcompile-fail%2Fvariance-deprecated-markers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d754722a04b99fdcae0fd97fa2a4395521145ef2/src%2Ftest%2Fcompile-fail%2Fvariance-deprecated-markers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvariance-deprecated-markers.rs?ref=d754722a04b99fdcae0fd97fa2a4395521145ef2", "patch": "@@ -1,35 +0,0 @@\n-// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// Test that the deprecated markers still have their old effect.\n-\n-#![feature(rustc_attrs)]\n-\n-use std::marker;\n-\n-#[rustc_variance]\n-struct A<T>(marker::CovariantType<T>); //~ ERROR types=[[+];[];[]]\n-\n-#[rustc_variance]\n-struct B<T>(marker::ContravariantType<T>); //~ ERROR types=[[-];[];[]]\n-\n-#[rustc_variance]\n-struct C<T>(marker::InvariantType<T>); //~ ERROR types=[[o];[];[]]\n-\n-#[rustc_variance]\n-struct D<'a>(marker::CovariantLifetime<'a>); //~ ERROR regions=[[+];[];[]]\n-\n-#[rustc_variance]\n-struct E<'a>(marker::ContravariantLifetime<'a>); //~ ERROR regions=[[-];[];[]]\n-\n-#[rustc_variance]\n-struct F<'a>(marker::InvariantLifetime<'a>); //~ ERROR regions=[[o];[];[]]\n-\n-fn main() { }"}, {"sha": "44a3f716e3eea4a3602cc43a5d8928d8faa9a71e", "filename": "src/test/compile-fail/vec-must-not-hide-type-from-dropck.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Ftest%2Fcompile-fail%2Fvec-must-not-hide-type-from-dropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Ftest%2Fcompile-fail%2Fvec-must-not-hide-type-from-dropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvec-must-not-hide-type-from-dropck.rs?ref=d4a2c941809f303b97d153e06ba07e95cd245f88", "patch": "@@ -30,9 +30,9 @@ use id::Id;\n \n mod s {\n     #![allow(unstable)]\n-    use std::sync::atomic::{AtomicUint, ATOMIC_UINT_INIT, Ordering};\n+    use std::sync::atomic::{AtomicUsize, ATOMIC_USIZE_INIT, Ordering};\n \n-    static S_COUNT: AtomicUint = ATOMIC_UINT_INIT;\n+    static S_COUNT: AtomicUsize = ATOMIC_USIZE_INIT;\n \n     /// generates globally unique count (global across the current\n     /// process, that is)"}, {"sha": "0025449a3dbb7f93b2ae5bfb94675b1825ac9ddb", "filename": "src/test/compile-fail/vec_refs_data_with_early_death.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Ftest%2Fcompile-fail%2Fvec_refs_data_with_early_death.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Ftest%2Fcompile-fail%2Fvec_refs_data_with_early_death.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvec_refs_data_with_early_death.rs?ref=d4a2c941809f303b97d153e06ba07e95cd245f88", "patch": "@@ -27,5 +27,5 @@ fn main() {\n     v.push(&x); //~ ERROR `x` does not live long enough\n     v.push(&y); //~ ERROR `y` does not live long enough\n \n-    assert_eq!(v.as_slice(), [&3, &4]);\n+    assert_eq!(v, [&3, &4]);\n }"}, {"sha": "249e2e1ac2d64938594f638ccbc8186a405e1bfd", "filename": "src/test/run-fail/rt-set-exit-status-panic.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Ftest%2Frun-fail%2Frt-set-exit-status-panic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Ftest%2Frun-fail%2Frt-set-exit-status-panic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Frt-set-exit-status-panic.rs?ref=d4a2c941809f303b97d153e06ba07e95cd245f88", "patch": "@@ -10,16 +10,16 @@\n \n // error-pattern:whatever\n \n-#![feature(os, rustc_private)]\n+#![feature(exit_status, rustc_private)]\n \n #[macro_use] extern crate log;\n-use std::os;\n+use std::env;\n \n fn main() {\n     error!(\"whatever\");\n     // Setting the exit status only works when the scheduler terminates\n     // normally. In this case we're going to panic, so instead of\n     // returning 50 the process will return the typical rt failure code.\n-    os::set_exit_status(50);\n+    env::set_exit_status(50);\n     panic!();\n }"}, {"sha": "fddff3c5a9f4fea67ab205b483e7f34a8b17720c", "filename": "src/test/run-fail/rt-set-exit-status-panic2.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Ftest%2Frun-fail%2Frt-set-exit-status-panic2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Ftest%2Frun-fail%2Frt-set-exit-status-panic2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Frt-set-exit-status-panic2.rs?ref=d4a2c941809f303b97d153e06ba07e95cd245f88", "patch": "@@ -10,10 +10,10 @@\n \n // error-pattern:whatever\n \n-#![feature(os, rustc_private)]\n+#![feature(exit_status, rustc_private)]\n \n #[macro_use] extern crate log;\n-use std::os;\n+use std::env;\n use std::thread;\n \n struct r {\n@@ -25,7 +25,7 @@ struct r {\n // runtime's exit code\n impl Drop for r {\n     fn drop(&mut self) {\n-        os::set_exit_status(50);\n+        env::set_exit_status(50);\n     }\n }\n "}, {"sha": "c33a8d2d03227027c976a20bb5d8782b9d4e1e4d", "filename": "src/test/run-fail/rt-set-exit-status.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Ftest%2Frun-fail%2Frt-set-exit-status.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Ftest%2Frun-fail%2Frt-set-exit-status.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Frt-set-exit-status.rs?ref=d4a2c941809f303b97d153e06ba07e95cd245f88", "patch": "@@ -10,14 +10,14 @@\n \n // error-pattern:whatever\n \n-#![feature(rustc_private, os)]\n+#![feature(rustc_private, exit_status)]\n \n #[macro_use] extern crate log;\n-use std::os;\n+use std::env;\n \n fn main() {\n     error!(\"whatever\");\n     // 101 is the code the runtime uses on task panic and the value\n     // compiletest expects run-fail tests to return.\n-    os::set_exit_status(101);\n+    env::set_exit_status(101);\n }"}, {"sha": "c1787eb03f5925a67ececa5b076df9828345c957", "filename": "src/test/run-make/link-path-order/main.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Ftest%2Frun-make%2Flink-path-order%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Ftest%2Frun-make%2Flink-path-order%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Flink-path-order%2Fmain.rs?ref=d4a2c941809f303b97d153e06ba07e95cd245f88", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(libc, os)]\n+#![feature(libc, exit_status)]\n \n extern crate libc;\n \n@@ -23,6 +23,6 @@ fn main() {\n     };\n \n     if result != 1 {\n-        std::os::set_exit_status(255);\n+        std::env::set_exit_status(255);\n     }\n }"}, {"sha": "a70a160076520aca44acdf60aa98baea8d2542dc", "filename": "src/test/run-make/unicode-input/span_length.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Ftest%2Frun-make%2Funicode-input%2Fspan_length.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Ftest%2Frun-make%2Funicode-input%2Fspan_length.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Funicode-input%2Fspan_length.rs?ref=d4a2c941809f303b97d153e06ba07e95cd245f88", "patch": "@@ -95,10 +95,10 @@ fn main() {\n     let expected_span = format!(\"\\n{}^{}\\n\",\n                                 repeat(\" \").take(offset + 7).collect::<String>(),\n                                 repeat(\"~\").take(8).collect::<String>());\n-    assert!(err.contains(expected_span.as_slice()));\n+    assert!(err.contains(&expected_span));\n     // Second snake is 8 ~s long, with 36 preceding spaces\n     let expected_span = format!(\"\\n{}^{}\\n\",\n                                 repeat(\" \").take(offset + 36).collect::<String>(),\n                                 repeat(\"~\").take(8).collect::<String>());\n-    assert!(err.contains(expected_span.as_slice()));\n+    assert!(err.contains(&expected_span));\n }"}, {"sha": "4bacde0aadf3fc67fed7a79fbef5e90361342828", "filename": "src/test/run-pass-fulldeps/compiler-calls.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Ftest%2Frun-pass-fulldeps%2Fcompiler-calls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Ftest%2Frun-pass-fulldeps%2Fcompiler-calls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fcompiler-calls.rs?ref=d4a2c941809f303b97d153e06ba07e95cd245f88", "patch": "@@ -77,6 +77,6 @@ fn main() {\n     let mut tc = TestCalls { count: 1 };\n     // we should never get use this filename, but lets make sure they are valid args.\n     let args = vec![\"compiler-calls\".to_string(), \"foo.rs\".to_string()];\n-    rustc_driver::run_compiler(args.as_slice(), &mut tc);\n+    rustc_driver::run_compiler(&args, &mut tc);\n     assert!(tc.count == 30);\n }"}, {"sha": "d09d7c55722ba5b481d2cd157f1dc5d008cc0340", "filename": "src/test/run-pass-fulldeps/create-dir-all-bare.rs", "status": "renamed", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Ftest%2Frun-pass-fulldeps%2Fcreate-dir-all-bare.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Ftest%2Frun-pass-fulldeps%2Fcreate-dir-all-bare.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fcreate-dir-all-bare.rs?ref=d4a2c941809f303b97d153e06ba07e95cd245f88", "patch": "@@ -8,10 +8,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(tempdir)]\n+#![feature(rustc_private)]\n+\n+extern crate rustc_back;\n \n use std::env;\n-use std::fs::{self, TempDir};\n+use std::fs;\n+use rustc_back::tempdir::TempDir;\n \n fn main() {\n     let td = TempDir::new(\"create-dir-all-bare\").unwrap();", "previous_filename": "src/test/run-pass/create-dir-all-bare.rs"}, {"sha": "fa810f72fcbd1583cc1d696c9864171709dbb04b", "filename": "src/test/run-pass-fulldeps/rename-directory.rs", "status": "renamed", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Ftest%2Frun-pass-fulldeps%2Frename-directory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Ftest%2Frun-pass-fulldeps%2Frename-directory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Frename-directory.rs?ref=d4a2c941809f303b97d153e06ba07e95cd245f88", "patch": "@@ -13,10 +13,13 @@\n \n // pretty-expanded FIXME #23616\n \n-#![feature(tempdir, path_ext)]\n+#![feature(rustc_private, path_ext)]\n+\n+extern crate rustc_back;\n \n use std::ffi::CString;\n-use std::fs::{self, TempDir, File, PathExt};\n+use std::fs::{self, File, PathExt};\n+use rustc_back::tempdir::TempDir;\n \n fn rename_directory() {\n     let tmpdir = TempDir::new(\"rename_directory\").ok().expect(\"rename_directory failed\");", "previous_filename": "src/test/run-pass/rename-directory.rs"}, {"sha": "14d8bce061f5aed20699783b800cd333377a08d9", "filename": "src/test/run-pass/backtrace.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Ftest%2Frun-pass%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Ftest%2Frun-pass%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbacktrace.rs?ref=d4a2c941809f303b97d153e06ba07e95cd245f88", "patch": "@@ -80,9 +80,9 @@ fn runtest(me: &str) {\n     let s = str::from_utf8(&out.error).unwrap();\n     let mut i = 0;\n     for _ in 0..2 {\n-        i += s[i + 10..].find_str(\"stack backtrace\").unwrap() + 10;\n+        i += s[i + 10..].find(\"stack backtrace\").unwrap() + 10;\n     }\n-    assert!(s[i + 10..].find_str(\"stack backtrace\").is_none(),\n+    assert!(s[i + 10..].find(\"stack backtrace\").is_none(),\n             \"bad output4: {}\", s);\n }\n "}, {"sha": "f9b429a935a6a676a553f031f29023c050cdbc5f", "filename": "src/test/run-pass/capturing-logging.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Ftest%2Frun-pass%2Fcapturing-logging.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Ftest%2Frun-pass%2Fcapturing-logging.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcapturing-logging.rs?ref=d4a2c941809f303b97d153e06ba07e95cd245f88", "patch": "@@ -22,7 +22,7 @@ use log::{set_logger, Logger, LogRecord};\n use std::sync::mpsc::channel;\n use std::fmt;\n use std::old_io::{ChanReader, ChanWriter, Reader, Writer};\n-use std::thread::Thread;\n+use std::thread;\n \n struct MyWriter(ChanWriter);\n \n@@ -36,7 +36,7 @@ impl Logger for MyWriter {\n fn main() {\n     let (tx, rx) = channel();\n     let (mut r, w) = (ChanReader::new(rx), ChanWriter::new(tx));\n-    let _t = Thread::spawn(move|| {\n+    let _t = thread::scoped(move|| {\n         set_logger(box MyWriter(w) as Box<Logger+Send>);\n         debug!(\"debug\");\n         info!(\"info\");"}, {"sha": "7da1416602f6daec46d6961d456da65febc39cc8", "filename": "src/test/run-pass/child-outlives-parent.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Ftest%2Frun-pass%2Fchild-outlives-parent.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Ftest%2Frun-pass%2Fchild-outlives-parent.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fchild-outlives-parent.rs?ref=d4a2c941809f303b97d153e06ba07e95cd245f88", "patch": "@@ -14,10 +14,10 @@\n \n #![feature(std_misc)]\n \n-use std::thread::Thread;\n+use std::thread;\n \n fn child2(_s: String) { }\n \n pub fn main() {\n-    let _x = Thread::spawn(move|| child2(\"hi\".to_string()));\n+    let _x = thread::spawn(move|| child2(\"hi\".to_string()));\n }"}, {"sha": "16efceb9d7e0e1db35803a9620b0c2639889f30c", "filename": "src/test/run-pass/clone-with-exterior.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Ftest%2Frun-pass%2Fclone-with-exterior.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Ftest%2Frun-pass%2Fclone-with-exterior.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclone-with-exterior.rs?ref=d4a2c941809f303b97d153e06ba07e95cd245f88", "patch": "@@ -13,7 +13,7 @@\n #![allow(unknown_features)]\n #![feature(box_syntax, std_misc)]\n \n-use std::thread::Thread;\n+use std::thread;\n \n struct Pair {\n     a: isize,\n@@ -23,7 +23,7 @@ struct Pair {\n pub fn main() {\n     let z: Box<_> = box Pair { a : 10, b : 12};\n \n-    let _t = Thread::spawn(move|| {\n+    let _t = thread::scoped(move|| {\n         assert_eq!(z.a, 10);\n         assert_eq!(z.b, 12);\n     });"}, {"sha": "859599596ae7bc114ad03a74968137ae96717d6a", "filename": "src/test/run-pass/comm.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Ftest%2Frun-pass%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Ftest%2Frun-pass%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcomm.rs?ref=d4a2c941809f303b97d153e06ba07e95cd245f88", "patch": "@@ -10,12 +10,12 @@\n \n #![feature(std_misc)]\n \n-use std::thread::Thread;\n+use std::thread;\n use std::sync::mpsc::{channel, Sender};\n \n pub fn main() {\n     let (tx, rx) = channel();\n-    let _t = Thread::spawn(move|| { child(&tx) });\n+    let _t = thread::scoped(move|| { child(&tx) });\n     let y = rx.recv().unwrap();\n     println!(\"received\");\n     println!(\"{}\", y);"}, {"sha": "03bf3851257dfa10c1644e751d1e55acdb7d335b", "filename": "src/test/run-pass/core-run-destroy.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Ftest%2Frun-pass%2Fcore-run-destroy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Ftest%2Frun-pass%2Fcore-run-destroy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcore-run-destroy.rs?ref=d4a2c941809f303b97d153e06ba07e95cd245f88", "patch": "@@ -24,7 +24,7 @@ use std::old_io::{Process, Command, timer};\n use std::time::Duration;\n use std::str;\n use std::sync::mpsc::channel;\n-use std::thread::Thread;\n+use std::thread;\n \n macro_rules! succeed { ($e:expr) => (\n     match $e { Ok(..) => {}, Err(e) => panic!(\"panic: {}\", e) }\n@@ -86,7 +86,7 @@ pub fn test_destroy_actually_kills(force: bool) {\n     let (tx, rx1) = channel();\n     let mut t = timer::Timer::new().unwrap();\n     let rx2 = t.oneshot(Duration::milliseconds(1000));\n-    Thread::spawn(move|| {\n+    thread::spawn(move|| {\n         select! {\n             _ = rx2.recv() => unsafe { libc::exit(1) },\n             _ = rx1.recv() => {}"}, {"sha": "3d4af80e30bb57a98a3349b07eed10ef61e7b1fa", "filename": "src/test/run-pass/drop-with-type-ascription-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Ftest%2Frun-pass%2Fdrop-with-type-ascription-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Ftest%2Frun-pass%2Fdrop-with-type-ascription-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdrop-with-type-ascription-2.rs?ref=d4a2c941809f303b97d153e06ba07e95cd245f88", "patch": "@@ -14,7 +14,7 @@\n \n fn main() {\n     let args = vec!(\"foobie\", \"asdf::asdf\");\n-    let arr: Vec<&str> = args[1].split_str(\"::\").collect();\n+    let arr: Vec<&str> = args[1].split(\"::\").collect();\n     assert_eq!(arr[0], \"asdf\");\n     assert_eq!(arr[0], \"asdf\");\n }"}, {"sha": "e8c9bc76335f7ab7500eed3b0ae0232535b22f82", "filename": "src/test/run-pass/extern-call-scrub.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Ftest%2Frun-pass%2Fextern-call-scrub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Ftest%2Frun-pass%2Fextern-call-scrub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fextern-call-scrub.rs?ref=d4a2c941809f303b97d153e06ba07e95cd245f88", "patch": "@@ -15,7 +15,7 @@\n #![feature(libc, std_misc)]\n \n extern crate libc;\n-use std::thread::Thread;\n+use std::thread;\n \n mod rustrt {\n     extern crate libc;\n@@ -46,7 +46,7 @@ fn count(n: libc::uintptr_t) -> libc::uintptr_t {\n pub fn main() {\n     // Make sure we're on a task with small Rust stacks (main currently\n     // has a large stack)\n-    let _t = Thread::spawn(move|| {\n+    let _t = thread::scoped(move|| {\n         let result = count(12);\n         println!(\"result = {}\", result);\n         assert_eq!(result, 2048);"}, {"sha": "5c96aaf4bd8902365862e4a14066d048d35ff374", "filename": "src/test/run-pass/hashmap-memory.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Ftest%2Frun-pass%2Fhashmap-memory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Ftest%2Frun-pass%2Fhashmap-memory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fhashmap-memory.rs?ref=d4a2c941809f303b97d153e06ba07e95cd245f88", "patch": "@@ -25,7 +25,7 @@ mod map_reduce {\n     use std::collections::HashMap;\n     use std::sync::mpsc::{channel, Sender};\n     use std::str;\n-    use std::thread::Thread;\n+    use std::thread;\n \n     pub type putter<'a> = Box<FnMut(String, String) + 'a>;\n \n@@ -37,7 +37,7 @@ mod map_reduce {\n         for i in &inputs {\n             let ctrl = ctrl.clone();\n             let i = i.clone();\n-            Thread::spawn(move|| map_task(ctrl.clone(), i.clone()) );\n+            thread::spawn(move|| map_task(ctrl.clone(), i.clone()) );\n         }\n     }\n "}, {"sha": "26d58d34b9dea1e4dc373adcaeaff2057590b4c9", "filename": "src/test/run-pass/init-large-type.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Ftest%2Frun-pass%2Finit-large-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Ftest%2Frun-pass%2Finit-large-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Finit-large-type.rs?ref=d4a2c941809f303b97d153e06ba07e95cd245f88", "patch": "@@ -16,7 +16,7 @@\n \n #![feature(intrinsics, std_misc)]\n \n-use std::thread::Thread;\n+use std::thread;\n \n extern \"rust-intrinsic\" {\n     pub fn init<T>() -> T;\n@@ -26,7 +26,7 @@ const SIZE: usize = 1024 * 1024;\n \n fn main() {\n     // do the test in a new thread to avoid (spurious?) stack overflows\n-    let _ = Thread::scoped(|| {\n+    let _ = thread::scoped(|| {\n         let _memory: [u8; SIZE] = unsafe { init() };\n     }).join();\n }"}, {"sha": "c260aa95b57f1d556bdf83f77826ba120ab0ea7c", "filename": "src/test/run-pass/issue-13304.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Ftest%2Frun-pass%2Fissue-13304.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Ftest%2Frun-pass%2Fissue-13304.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-13304.rs?ref=d4a2c941809f303b97d153e06ba07e95cd245f88", "patch": "@@ -29,8 +29,8 @@ fn main() {\n fn parent() {\n     let args: Vec<String> = env::args().collect();\n     let mut p = Command::new(&args[0]).arg(\"child\")\n-                        .stdout(Stdio::capture())\n-                        .stdin(Stdio::capture())\n+                        .stdout(Stdio::piped())\n+                        .stdin(Stdio::piped())\n                         .spawn().unwrap();\n     p.stdin.as_mut().unwrap().write_all(b\"test1\\ntest2\\ntest3\").unwrap();\n     let out = p.wait_with_output().unwrap();"}, {"sha": "d1b1647de7881244887f8011abd854374a4ce71a", "filename": "src/test/run-pass/issue-13494.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Ftest%2Frun-pass%2Fissue-13494.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Ftest%2Frun-pass%2Fissue-13494.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-13494.rs?ref=d4a2c941809f303b97d153e06ba07e95cd245f88", "patch": "@@ -16,7 +16,7 @@\n #![feature(std_misc)]\n \n use std::sync::mpsc::{channel, Sender, Receiver};\n-use std::thread::Thread;\n+use std::thread;\n \n fn helper(rx: Receiver<Sender<()>>) {\n     for tx in rx.iter() {\n@@ -26,7 +26,7 @@ fn helper(rx: Receiver<Sender<()>>) {\n \n fn main() {\n     let (tx, rx) = channel();\n-    let _t = Thread::spawn(move|| { helper(rx) });\n+    let _t = thread::scoped(move|| { helper(rx) });\n     let (snd, rcv) = channel::<isize>();\n     for _ in 1..100000 {\n         snd.send(1).unwrap();\n@@ -37,4 +37,5 @@ fn main() {\n             _ = rcv.recv() => ()\n         }\n     }\n+    drop(tx);\n }"}, {"sha": "ab9633ca1fe90e0ba46d921e66b16264792c5279", "filename": "src/test/run-pass/issue-14456.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Ftest%2Frun-pass%2Fissue-14456.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Ftest%2Frun-pass%2Fissue-14456.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-14456.rs?ref=d4a2c941809f303b97d153e06ba07e95cd245f88", "patch": "@@ -38,9 +38,9 @@ fn child() {\n fn test() {\n     let args: Vec<String> = env::args().collect();\n     let mut p = Command::new(&args[0]).arg(\"child\")\n-                                     .stdin(Stdio::capture())\n-                                     .stdout(Stdio::capture())\n-                                     .stderr(Stdio::capture())\n+                                     .stdin(Stdio::piped())\n+                                     .stdout(Stdio::piped())\n+                                     .stderr(Stdio::piped())\n                                      .spawn().unwrap();\n     assert!(p.wait().unwrap().success());\n }"}, {"sha": "6e93194647ad2c8aea38bbfa4e80361f5100b485", "filename": "src/test/run-pass/issue-17351.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Ftest%2Frun-pass%2Fissue-17351.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Ftest%2Frun-pass%2Fissue-17351.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-17351.rs?ref=d4a2c941809f303b97d153e06ba07e95cd245f88", "patch": "@@ -12,6 +12,10 @@\n \n #![feature(core)]\n \n+trait Str { fn foo(&self) {} }\n+impl Str for str {}\n+impl<'a, S: ?Sized> Str for &'a S where S: Str {}\n+\n fn main() {\n     let _: &Str = &\"x\";\n }"}, {"sha": "d527d9519cfbc4eee484caa8bca030b6f3c492d4", "filename": "src/test/run-pass/issue-20454.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Ftest%2Frun-pass%2Fissue-20454.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Ftest%2Frun-pass%2Fissue-20454.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-20454.rs?ref=d4a2c941809f303b97d153e06ba07e95cd245f88", "patch": "@@ -12,10 +12,12 @@\n \n use std::thread;\n \n-fn main() {\n-    thread::Thread::spawn(move || { // no need for -> ()\n+fn _foo() {\n+    let _t = thread::scoped(move || { // no need for -> ()\n         loop {\n             println!(\"hello\");\n         }\n     });\n }\n+\n+fn main() {}"}, {"sha": "71d1439dd2bc8f3f14d197137c50853a27e506fe", "filename": "src/test/run-pass/issue-2718.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Ftest%2Frun-pass%2Fissue-2718.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Ftest%2Frun-pass%2Fissue-2718.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2718.rs?ref=d4a2c941809f303b97d153e06ba07e95cd245f88", "patch": "@@ -21,7 +21,7 @@ pub mod pipes {\n     use std::mem::{forget, transmute};\n     use std::mem::{replace, swap};\n     use std::mem;\n-    use std::thread::Thread;\n+    use std::thread;\n     use std::marker::Send;\n \n     pub struct Stuff<T> {\n@@ -115,7 +115,7 @@ pub mod pipes {\n             let old_state = swap_state_acq(&mut (*p).state,\n                                            blocked);\n             match old_state {\n-              empty | blocked => { Thread::yield_now(); }\n+              empty | blocked => { thread::yield_now(); }\n               full => {\n                 let payload = replace(&mut p.payload, None);\n                 return Some(payload.unwrap())"}, {"sha": "45eb21374e2981aab7a5b84bdfc5e93f966587f0", "filename": "src/test/run-pass/issue-3609.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Ftest%2Frun-pass%2Fissue-3609.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Ftest%2Frun-pass%2Fissue-3609.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-3609.rs?ref=d4a2c941809f303b97d153e06ba07e95cd245f88", "patch": "@@ -11,7 +11,7 @@\n #![allow(unknown_features)]\n #![feature(std_misc)]\n \n-use std::thread::Thread;\n+use std::thread;\n use std::sync::mpsc::Sender;\n use std::thunk::Invoke;\n \n@@ -24,7 +24,7 @@ enum Msg\n }\n \n fn foo(name: String, samples_chan: Sender<Msg>) {\n-    let _t = Thread::spawn(move|| {\n+    let _t = thread::scoped(move|| {\n         let mut samples_chan = samples_chan;\n \n         // FIXME (#22405): Replace `Box::new` with `box` here when/if possible."}, {"sha": "280311af6fbd12ea94121129cc608f6f9a8f12f2", "filename": "src/test/run-pass/issue-8827.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Ftest%2Frun-pass%2Fissue-8827.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Ftest%2Frun-pass%2Fissue-8827.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-8827.rs?ref=d4a2c941809f303b97d153e06ba07e95cd245f88", "patch": "@@ -10,12 +10,12 @@\n \n #![feature(std_misc)]\n \n-use std::thread::Thread;\n+use std::thread;\n use std::sync::mpsc::{channel, Receiver};\n \n fn periodical(n: isize) -> Receiver<bool> {\n     let (chan, port) = channel();\n-    Thread::spawn(move|| {\n+    thread::spawn(move|| {\n         loop {\n             for _ in 1..n {\n                 match chan.send(false) {\n@@ -34,7 +34,7 @@ fn periodical(n: isize) -> Receiver<bool> {\n \n fn integers() -> Receiver<isize> {\n     let (chan, port) = channel();\n-    Thread::spawn(move|| {\n+    thread::spawn(move|| {\n         let mut i = 1;\n         loop {\n             match chan.send(i) {"}, {"sha": "bfaf060e43c30ac41d25f856663c430cbe8166c4", "filename": "src/test/run-pass/issue-9396.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Ftest%2Frun-pass%2Fissue-9396.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Ftest%2Frun-pass%2Fissue-9396.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-9396.rs?ref=d4a2c941809f303b97d153e06ba07e95cd245f88", "patch": "@@ -14,12 +14,12 @@\n \n use std::sync::mpsc::{TryRecvError, channel};\n use std::old_io::timer::Timer;\n-use std::thread::Thread;\n+use std::thread;\n use std::time::Duration;\n \n pub fn main() {\n     let (tx, rx) = channel();\n-    let _t = Thread::scoped(move||{\n+    let _t = thread::scoped(move||{\n         let mut timer = Timer::new().unwrap();\n         timer.sleep(Duration::milliseconds(10));\n         tx.send(()).unwrap();"}, {"sha": "8ae084dce8c37793a928b9deb41101647062325a", "filename": "src/test/run-pass/ivec-tag.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Ftest%2Frun-pass%2Fivec-tag.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Ftest%2Frun-pass%2Fivec-tag.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fivec-tag.rs?ref=d4a2c941809f303b97d153e06ba07e95cd245f88", "patch": "@@ -12,7 +12,7 @@\n \n #![feature(std_misc)]\n \n-use std::thread::Thread;\n+use std::thread;\n use std::sync::mpsc::{channel, Sender};\n \n fn producer(tx: &Sender<Vec<u8>>) {\n@@ -23,7 +23,7 @@ fn producer(tx: &Sender<Vec<u8>>) {\n \n pub fn main() {\n     let (tx, rx) = channel::<Vec<u8>>();\n-    let _prod = Thread::spawn(move|| {\n+    let _prod = thread::scoped(move|| {\n         producer(&tx)\n     });\n "}, {"sha": "11b1d70137deffe7046b5bf791b05bf8b3c83cfd", "filename": "src/test/run-pass/kindck-implicit-close-over-mut-var.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Ftest%2Frun-pass%2Fkindck-implicit-close-over-mut-var.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Ftest%2Frun-pass%2Fkindck-implicit-close-over-mut-var.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fkindck-implicit-close-over-mut-var.rs?ref=d4a2c941809f303b97d153e06ba07e95cd245f88", "patch": "@@ -10,15 +10,15 @@\n \n #![feature(std_misc)]\n \n-use std::thread::Thread;\n+use std::thread;\n \n fn user(_i: isize) {}\n \n fn foo() {\n     // Here, i is *copied* into the proc (heap closure).\n     // Requires allocation.  The proc's copy is not mutable.\n     let mut i = 0;\n-    let _t = Thread::spawn(move|| {\n+    let _t = thread::scoped(move|| {\n         user(i);\n         println!(\"spawned {}\", i)\n     });\n@@ -31,7 +31,7 @@ fn bar() {\n     // mutable outside of the proc.\n     let mut i = 0;\n     while i < 10 {\n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::scoped(move|| {\n             user(i);\n         });\n         i += 1;\n@@ -42,7 +42,7 @@ fn car() {\n     // Here, i must be shadowed in the proc to be mutable.\n     let mut i = 0;\n     while i < 10 {\n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::scoped(move|| {\n             let mut i = i;\n             i += 1;\n             user(i);"}, {"sha": "4881a5ab647ec0996efde72f97ad3c368aae8120", "filename": "src/test/run-pass/macro-with-braces-in-expr-position.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Ftest%2Frun-pass%2Fmacro-with-braces-in-expr-position.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Ftest%2Frun-pass%2Fmacro-with-braces-in-expr-position.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmacro-with-braces-in-expr-position.rs?ref=d4a2c941809f303b97d153e06ba07e95cd245f88", "patch": "@@ -10,13 +10,13 @@\n \n #![feature(std_misc)]\n \n-use std::thread::Thread;\n+use std::thread;\n \n macro_rules! expr { ($e: expr) => { $e } }\n \n macro_rules! spawn {\n     ($($code: tt)*) => {\n-        expr!(Thread::spawn(move|| {$($code)*}))\n+        expr!(thread::spawn(move|| {$($code)*}))\n     }\n }\n "}, {"sha": "77072bdec905190cb483a1cacd74e29c7fa49c36", "filename": "src/test/run-pass/method-two-traits-distinguished-via-where-clause.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Ftest%2Frun-pass%2Fmethod-two-traits-distinguished-via-where-clause.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Ftest%2Frun-pass%2Fmethod-two-traits-distinguished-via-where-clause.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmethod-two-traits-distinguished-via-where-clause.rs?ref=d4a2c941809f303b97d153e06ba07e95cd245f88", "patch": "@@ -33,6 +33,6 @@ impl<T> B for *const [T] {\n \n fn main() {\n     let x: [isize; 4] = [1,2,3,4];\n-    let xptr = x.as_slice() as *const [isize];\n+    let xptr = &x[..] as *const [isize];\n     xptr.foo();\n }"}, {"sha": "b6509d280366a2e295b2998a27c9be2eed7a9464", "filename": "src/test/run-pass/moves-based-on-type-capture-clause.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Ftest%2Frun-pass%2Fmoves-based-on-type-capture-clause.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Ftest%2Frun-pass%2Fmoves-based-on-type-capture-clause.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmoves-based-on-type-capture-clause.rs?ref=d4a2c941809f303b97d153e06ba07e95cd245f88", "patch": "@@ -10,11 +10,11 @@\n \n #![feature(std_misc)]\n \n-use std::thread::Thread;\n+use std::thread;\n \n pub fn main() {\n     let x = \"Hello world!\".to_string();\n-    let _t = Thread::spawn(move|| {\n+    let _t = thread::scoped(move|| {\n         println!(\"{}\", x);\n     });\n }"}, {"sha": "03ba6097cd9297ad6d120e223b749912966abfbe", "filename": "src/test/run-pass/option-ext.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Ftest%2Frun-pass%2Foption-ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Ftest%2Frun-pass%2Foption-ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Foption-ext.rs?ref=d4a2c941809f303b97d153e06ba07e95cd245f88", "patch": "@@ -12,7 +12,7 @@\n \n pub fn main() {\n     let thing = \"{{ f }}\";\n-    let f = thing.find_str(\"{{\");\n+    let f = thing.find(\"{{\");\n \n     if f.is_none() {\n         println!(\"None!\");"}, {"sha": "f08ed6e7f9cdc06cee25fd99c63689cf8488a0d2", "filename": "src/test/run-pass/out-of-stack-new-thread-no-split.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Ftest%2Frun-pass%2Fout-of-stack-new-thread-no-split.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Ftest%2Frun-pass%2Fout-of-stack-new-thread-no-split.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fout-of-stack-new-thread-no-split.rs?ref=d4a2c941809f303b97d153e06ba07e95cd245f88", "patch": "@@ -18,7 +18,7 @@\n \n use std::old_io::process::Command;\n use std::env;\n-use std::thread::Thread;\n+use std::thread;\n \n // lifted from the test module\n // Inlining to avoid llvm turning the recursive functions into tail calls,\n@@ -37,7 +37,7 @@ fn recurse() {\n fn main() {\n     let args: Vec<String> = env::args().collect();\n     if args.len() > 1 && args[1] == \"recurse\" {\n-        let _t = Thread::scoped(recurse);\n+        let _t = thread::scoped(recurse);\n     } else {\n         let recurse = Command::new(&args[0]).arg(\"recurse\").output().unwrap();\n         assert!(!recurse.status.success());"}, {"sha": "abad08c7ac6b31bc57593547184b2134c7349323", "filename": "src/test/run-pass/running-with-no-runtime.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Ftest%2Frun-pass%2Frunning-with-no-runtime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Ftest%2Frun-pass%2Frunning-with-no-runtime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frunning-with-no-runtime.rs?ref=d4a2c941809f303b97d153e06ba07e95cd245f88", "patch": "@@ -10,7 +10,7 @@\n \n #![feature(start, os, std_misc, old_io)]\n \n-use std::ffi;\n+use std::ffi::CStr;\n use std::old_io::process::{Command, ProcessOutput};\n use std::os;\n use std::rt::unwind::try;\n@@ -38,7 +38,7 @@ fn start(argc: isize, argv: *const *const u8) -> isize {\n     let args = unsafe {\n         (0..argc as usize).map(|i| {\n             let ptr = *argv.offset(i as isize) as *const _;\n-            ffi::c_str_to_bytes(&ptr).to_vec()\n+            CStr::from_ptr(ptr).to_bytes().to_vec()\n         }).collect::<Vec<_>>()\n     };\n     let me = &*args[0];"}, {"sha": "660b1e2036d3311dcd838ef12d5f25d2b37c44b6", "filename": "src/test/run-pass/rust-log-filter.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Ftest%2Frun-pass%2Frust-log-filter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Ftest%2Frun-pass%2Frust-log-filter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frust-log-filter.rs?ref=d4a2c941809f303b97d153e06ba07e95cd245f88", "patch": "@@ -19,7 +19,7 @@\n extern crate log;\n \n use std::sync::mpsc::{channel, Sender, Receiver};\n-use std::thread::Thread;\n+use std::thread;\n \n pub struct ChannelLogger {\n     tx: Sender<String>\n@@ -41,7 +41,7 @@ impl log::Logger for ChannelLogger {\n pub fn main() {\n     let (logger, rx) = ChannelLogger::new();\n \n-    let _t = Thread::spawn(move|| {\n+    let _t = thread::scoped(move|| {\n         log::set_logger(logger);\n \n         info!(\"foo\");"}, {"sha": "99ae3b7c7d87c63cf54479adf99bfc0473d3431f", "filename": "src/test/run-pass/send-is-not-static-par-for.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Ftest%2Frun-pass%2Fsend-is-not-static-par-for.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Ftest%2Frun-pass%2Fsend-is-not-static-par-for.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsend-is-not-static-par-for.rs?ref=d4a2c941809f303b97d153e06ba07e95cd245f88", "patch": "@@ -11,7 +11,7 @@\n // pretty-expanded FIXME #23616\n \n #![feature(core, std_misc)]\n-use std::thread::Thread;\n+use std::thread;\n use std::sync::Mutex;\n \n fn par_for<I, F>(iter: I, f: F)\n@@ -21,7 +21,7 @@ fn par_for<I, F>(iter: I, f: F)\n {\n     let f = &f;\n     let _guards: Vec<_> = iter.map(|elem| {\n-        Thread::scoped(move || {\n+        thread::scoped(move || {\n             f(elem)\n         })\n     }).collect();"}, {"sha": "3f64b2adb639538f490fc5a3c601606e99854175", "filename": "src/test/run-pass/send-resource.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Ftest%2Frun-pass%2Fsend-resource.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Ftest%2Frun-pass%2Fsend-resource.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsend-resource.rs?ref=d4a2c941809f303b97d153e06ba07e95cd245f88", "patch": "@@ -12,7 +12,7 @@\n \n #![feature(std_misc)]\n \n-use std::thread::Thread;\n+use std::thread;\n use std::sync::mpsc::channel;\n \n struct test {\n@@ -32,7 +32,7 @@ fn test(f: isize) -> test {\n pub fn main() {\n     let (tx, rx) = channel();\n \n-    let _t = Thread::spawn(move|| {\n+    let _t = thread::scoped(move|| {\n         let (tx2, rx2) = channel();\n         tx.send(tx2).unwrap();\n "}, {"sha": "c453f9252efe6aedd03cf9bfd704d9fb32ffe269", "filename": "src/test/run-pass/stat.rs", "status": "removed", "additions": 0, "deletions": 36, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/d754722a04b99fdcae0fd97fa2a4395521145ef2/src%2Ftest%2Frun-pass%2Fstat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d754722a04b99fdcae0fd97fa2a4395521145ef2/src%2Ftest%2Frun-pass%2Fstat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstat.rs?ref=d754722a04b99fdcae0fd97fa2a4395521145ef2", "patch": "@@ -1,36 +0,0 @@\n-// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// pretty-expanded FIXME #23616\n-\n-#![feature(tempdir, path_ext)]\n-\n-use std::fs::{File, TempDir};\n-use std::io::prelude::*;\n-\n-pub fn main() {\n-    let dir = TempDir::new_in(\".\", \"\").unwrap();\n-    let path = dir.path().join(\"file\");\n-\n-    {\n-        match File::create(&path) {\n-            Err(..) => unreachable!(),\n-            Ok(f) => {\n-                let mut f = f;\n-                for _ in 0..1000 {\n-                    f.write(&[0]);\n-                }\n-            }\n-        }\n-    }\n-\n-    assert!(path.exists());\n-    assert_eq!(path.metadata().unwrap().len(), 1000);\n-}"}, {"sha": "8834fd39d1d8845f135e14abf1bd9f56d1587e17", "filename": "src/test/run-pass/syntax-extension-source-utils.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Ftest%2Frun-pass%2Fsyntax-extension-source-utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Ftest%2Frun-pass%2Fsyntax-extension-source-utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsyntax-extension-source-utils.rs?ref=d4a2c941809f303b97d153e06ba07e95cd245f88", "patch": "@@ -36,16 +36,12 @@ pub fn main() {\n     assert!(\n         include_str!(\"syntax-extension-source-utils-files/includeme.\\\n                       fragment\").to_string()\n-        .as_slice()\n         .starts_with(\"/* this is for \"));\n     assert!(\n         include_bytes!(\"syntax-extension-source-utils-files/includeme.fragment\")\n         [1] == (42 as u8)); // '*'\n     // The Windows tests are wrapped in an extra module for some reason\n     assert!((m1::m2::where_am_i().ends_with(\"m1::m2\")));\n \n-    assert!(match (47, \"( 2 * 3 ) + 5\") {\n-        (line!(), stringify!((2*3) + 5)) => true,\n-        _ => false\n-    })\n+    assert_eq!((46, \"( 2 * 3 ) + 5\"), (line!(), stringify!((2*3) + 5)));\n }"}, {"sha": "786dd2c76123e4a02e7975ccfd26fee519593f79", "filename": "src/test/run-pass/task-comm-0.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Ftest%2Frun-pass%2Ftask-comm-0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Ftest%2Frun-pass%2Ftask-comm-0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-0.rs?ref=d4a2c941809f303b97d153e06ba07e95cd245f88", "patch": "@@ -10,7 +10,7 @@\n \n #![feature(std_misc)]\n \n-use std::thread::Thread;\n+use std::thread;\n use std::sync::mpsc::{channel, Sender};\n \n pub fn main() { test05(); }\n@@ -26,7 +26,7 @@ fn test05_start(tx : &Sender<isize>) {\n \n fn test05() {\n     let (tx, rx) = channel();\n-    let _t = Thread::spawn(move|| { test05_start(&tx) });\n+    let _t = thread::scoped(move|| { test05_start(&tx) });\n     let mut value: isize = rx.recv().unwrap();\n     println!(\"{}\", value);\n     value = rx.recv().unwrap();"}, {"sha": "9c3466f162b03f365e1dd824689c590c30cabaea", "filename": "src/test/run-pass/task-comm-1.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Ftest%2Frun-pass%2Ftask-comm-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Ftest%2Frun-pass%2Ftask-comm-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-1.rs?ref=d4a2c941809f303b97d153e06ba07e95cd245f88", "patch": "@@ -10,13 +10,13 @@\n \n #![feature(std_misc)]\n \n-use std::thread::Thread;\n+use std::thread;\n \n pub fn main() { test00(); }\n \n fn start() { println!(\"Started / Finished task.\"); }\n \n fn test00() {\n-    let _ = Thread::scoped(move|| start() ).join();\n+    let _ = thread::scoped(move|| start() ).join();\n     println!(\"Completing.\");\n }"}, {"sha": "f25bb3ff71ae8fe9803c9b58f73e4775460a5404", "filename": "src/test/run-pass/task-comm-10.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Ftest%2Frun-pass%2Ftask-comm-10.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Ftest%2Frun-pass%2Ftask-comm-10.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-10.rs?ref=d4a2c941809f303b97d153e06ba07e95cd245f88", "patch": "@@ -10,7 +10,7 @@\n \n #![feature(std_misc)]\n \n-use std::thread::Thread;\n+use std::thread;\n use std::sync::mpsc::{channel, Sender};\n \n fn start(tx: &Sender<Sender<String>>) {\n@@ -29,10 +29,10 @@ fn start(tx: &Sender<Sender<String>>) {\n \n pub fn main() {\n     let (tx, rx) = channel();\n-    let _child = Thread::spawn(move|| { start(&tx) });\n+    let _child = thread::scoped(move|| { start(&tx) });\n \n     let mut c = rx.recv().unwrap();\n     c.send(\"A\".to_string()).unwrap();\n     c.send(\"B\".to_string()).unwrap();\n-    Thread::yield_now();\n+    thread::yield_now();\n }"}, {"sha": "ec9ed53c1dca0cb21dc6c3b9ddced2b97554c6cf", "filename": "src/test/run-pass/task-comm-11.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Ftest%2Frun-pass%2Ftask-comm-11.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Ftest%2Frun-pass%2Ftask-comm-11.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-11.rs?ref=d4a2c941809f303b97d153e06ba07e95cd245f88", "patch": "@@ -13,7 +13,7 @@\n #![feature(std_misc)]\n \n use std::sync::mpsc::{channel, Sender};\n-use std::thread::Thread;\n+use std::thread;\n \n fn start(tx: &Sender<Sender<isize>>) {\n     let (tx2, _rx) = channel();\n@@ -22,7 +22,7 @@ fn start(tx: &Sender<Sender<isize>>) {\n \n pub fn main() {\n     let (tx, rx) = channel();\n-    let _child = Thread::spawn(move|| {\n+    let _child = thread::scoped(move|| {\n         start(&tx)\n     });\n     let _tx = rx.recv().unwrap();"}, {"sha": "03305091a2d074cddcece5ee5185786f1b15e3ef", "filename": "src/test/run-pass/task-comm-12.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Ftest%2Frun-pass%2Ftask-comm-12.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Ftest%2Frun-pass%2Ftask-comm-12.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-12.rs?ref=d4a2c941809f303b97d153e06ba07e95cd245f88", "patch": "@@ -10,22 +10,22 @@\n \n #![feature(std_misc)]\n \n-use std::thread::Thread;\n+use std::thread;\n \n pub fn main() { test00(); }\n \n fn start(_task_number: isize) { println!(\"Started / Finished task.\"); }\n \n fn test00() {\n     let i: isize = 0;\n-    let mut result = Thread::scoped(move|| {\n+    let mut result = thread::scoped(move|| {\n         start(i)\n     });\n \n     // Sleep long enough for the task to finish.\n     let mut i = 0_usize;\n     while i < 10000 {\n-        Thread::yield_now();\n+        thread::yield_now();\n         i += 1;\n     }\n "}, {"sha": "15ceacd672f8bb8a16a4d91f78762762227367f5", "filename": "src/test/run-pass/task-comm-13.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Ftest%2Frun-pass%2Ftask-comm-13.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Ftest%2Frun-pass%2Ftask-comm-13.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-13.rs?ref=d4a2c941809f303b97d153e06ba07e95cd245f88", "patch": "@@ -11,7 +11,7 @@\n #![feature(std_misc)]\n \n use std::sync::mpsc::{channel, Sender};\n-use std::thread::Thread;\n+use std::thread;\n \n fn start(tx: &Sender<isize>, start: isize, number_of_messages: isize) {\n     let mut i: isize = 0;\n@@ -21,6 +21,6 @@ fn start(tx: &Sender<isize>, start: isize, number_of_messages: isize) {\n pub fn main() {\n     println!(\"Check that we don't deadlock.\");\n     let (tx, rx) = channel();\n-    let _ = Thread::scoped(move|| { start(&tx, 0, 10) }).join();\n+    let _t = thread::scoped(move|| { start(&tx, 0, 10) }).join();\n     println!(\"Joined task\");\n }"}, {"sha": "1e2d9fe52df154f1869fc1abc873c1e42737fd48", "filename": "src/test/run-pass/task-comm-14.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Ftest%2Frun-pass%2Ftask-comm-14.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Ftest%2Frun-pass%2Ftask-comm-14.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-14.rs?ref=d4a2c941809f303b97d153e06ba07e95cd245f88", "patch": "@@ -11,7 +11,7 @@\n #![feature(std_misc)]\n \n use std::sync::mpsc::{channel, Sender};\n-use std::thread::Thread;\n+use std::thread;\n \n pub fn main() {\n     let (tx, rx) = channel();\n@@ -21,7 +21,7 @@ pub fn main() {\n     while (i > 0) {\n         println!(\"{}\", i);\n         let tx = tx.clone();\n-        Thread::spawn({let i = i; move|| { child(i, &tx) }});\n+        thread::scoped({let i = i; move|| { child(i, &tx) }});\n         i = i - 1;\n     }\n "}, {"sha": "2663595aecfa18570c0130436313f578ee290e65", "filename": "src/test/run-pass/task-comm-15.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Ftest%2Frun-pass%2Ftask-comm-15.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Ftest%2Frun-pass%2Ftask-comm-15.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-15.rs?ref=d4a2c941809f303b97d153e06ba07e95cd245f88", "patch": "@@ -13,7 +13,7 @@\n #![feature(std_misc)]\n \n use std::sync::mpsc::{channel, Sender};\n-use std::thread::Thread;\n+use std::thread;\n \n fn start(tx: &Sender<isize>, i0: isize) {\n     let mut i = i0;\n@@ -29,7 +29,7 @@ pub fn main() {\n     // the child's point of view the receiver may die. We should\n     // drop messages on the floor in this case, and not crash!\n     let (tx, rx) = channel();\n-    let _t = Thread::spawn(move|| {\n+    let _t = thread::scoped(move|| {\n         start(&tx, 10)\n     });\n     rx.recv();"}, {"sha": "de334c77aa310e5b947c83581f14245043648314", "filename": "src/test/run-pass/task-comm-17.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Ftest%2Frun-pass%2Ftask-comm-17.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Ftest%2Frun-pass%2Ftask-comm-17.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-17.rs?ref=d4a2c941809f303b97d153e06ba07e95cd245f88", "patch": "@@ -16,11 +16,11 @@\n \n // This test is specifically about spawning temporary closures.\n \n-use std::thread::Thread;\n+use std::thread;\n \n fn f() {\n }\n \n pub fn main() {\n-    let _t = Thread::scoped(move|| f() ).join();\n+    let _t = thread::scoped(move|| f() ).join();\n }"}, {"sha": "254ad653c48132ba6a676270774d9a60c4dea121", "filename": "src/test/run-pass/task-comm-3.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Ftest%2Frun-pass%2Ftask-comm-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Ftest%2Frun-pass%2Ftask-comm-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-3.rs?ref=d4a2c941809f303b97d153e06ba07e95cd245f88", "patch": "@@ -12,7 +12,7 @@\n \n // no-pretty-expanded FIXME #15189\n \n-use std::thread::Thread;\n+use std::thread;\n use std::sync::mpsc::{channel, Sender};\n \n pub fn main() { println!(\"===== WITHOUT THREADS =====\"); test00(); }\n@@ -42,7 +42,7 @@ fn test00() {\n     let mut results = Vec::new();\n     while i < number_of_tasks {\n         let tx = tx.clone();\n-        results.push(Thread::scoped({\n+        results.push(thread::scoped({\n             let i = i;\n             move|| {\n                 test00_start(&tx, i, number_of_messages)"}, {"sha": "b05e36552a24c16b849168c61ad775e921829f99", "filename": "src/test/run-pass/task-comm-7.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Ftest%2Frun-pass%2Ftask-comm-7.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Ftest%2Frun-pass%2Ftask-comm-7.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-7.rs?ref=d4a2c941809f303b97d153e06ba07e95cd245f88", "patch": "@@ -14,7 +14,7 @@\n #![allow(dead_assignment)]\n \n use std::sync::mpsc::{channel, Sender};\n-use std::thread::Thread;\n+use std::thread;\n \n pub fn main() { test00(); }\n \n@@ -31,19 +31,19 @@ fn test00() {\n     let number_of_messages: isize = 10;\n \n     let tx2 = tx.clone();\n-    let _t = Thread::spawn(move|| {\n+    let _t = thread::scoped(move|| {\n         test00_start(&tx2, number_of_messages * 0, number_of_messages);\n     });\n     let tx2 = tx.clone();\n-    let _t = Thread::spawn(move|| {\n+    let _t = thread::scoped(move|| {\n         test00_start(&tx2, number_of_messages * 1, number_of_messages);\n     });\n     let tx2 = tx.clone();\n-    let _t = Thread::spawn(move|| {\n+    let _t = thread::scoped(move|| {\n         test00_start(&tx2, number_of_messages * 2, number_of_messages);\n     });\n     let tx2 = tx.clone();\n-    let _t = Thread::spawn(move|| {\n+    let _t = thread::scoped(move|| {\n         test00_start(&tx2, number_of_messages * 3, number_of_messages);\n     });\n "}, {"sha": "758764aa9fdcca766ee17564cda123e36303d244", "filename": "src/test/run-pass/task-comm-9.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Ftest%2Frun-pass%2Ftask-comm-9.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Ftest%2Frun-pass%2Ftask-comm-9.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-9.rs?ref=d4a2c941809f303b97d153e06ba07e95cd245f88", "patch": "@@ -10,7 +10,7 @@\n \n #![feature(std_misc)]\n \n-use std::thread::Thread;\n+use std::thread;\n use std::sync::mpsc::{channel, Sender};\n \n pub fn main() { test00(); }\n@@ -26,7 +26,7 @@ fn test00() {\n     let (tx, rx) = channel();\n     let number_of_messages: isize = 10;\n \n-    let result = Thread::scoped(move|| {\n+    let result = thread::scoped(move|| {\n         test00_start(&tx, number_of_messages);\n     });\n "}, {"sha": "b97f4355b3ee08bb297b0d2d4f4a458628830b9a", "filename": "src/test/run-pass/task-life-0.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Ftest%2Frun-pass%2Ftask-life-0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Ftest%2Frun-pass%2Ftask-life-0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-life-0.rs?ref=d4a2c941809f303b97d153e06ba07e95cd245f88", "patch": "@@ -12,10 +12,10 @@\n \n #![feature(std_misc)]\n \n-use std::thread::Thread;\n+use std::thread;\n \n pub fn main() {\n-    let _t = Thread::spawn(move|| child(\"Hello\".to_string()) );\n+    let _t = thread::scoped(move|| child(\"Hello\".to_string()) );\n }\n \n fn child(_s: String) {"}, {"sha": "aa7b61bf112f90627cd4516e53d3d63ecd7d200a", "filename": "src/test/run-pass/task-spawn-move-and-copy.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Ftest%2Frun-pass%2Ftask-spawn-move-and-copy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Ftest%2Frun-pass%2Ftask-spawn-move-and-copy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-spawn-move-and-copy.rs?ref=d4a2c941809f303b97d153e06ba07e95cd245f88", "patch": "@@ -13,7 +13,7 @@\n #![allow(unknown_features)]\n #![feature(box_syntax, std_misc)]\n \n-use std::thread::Thread;\n+use std::thread;\n use std::sync::mpsc::channel;\n \n pub fn main() {\n@@ -22,7 +22,7 @@ pub fn main() {\n     let x: Box<isize> = box 1;\n     let x_in_parent = &(*x) as *const isize as usize;\n \n-    let _t = Thread::spawn(move || {\n+    let _t = thread::scoped(move || {\n         let x_in_child = &(*x) as *const isize as usize;\n         tx.send(x_in_child).unwrap();\n     });"}, {"sha": "00467e563347a32174c7cb5a693448d75a7b68dc", "filename": "src/test/run-pass/tcp-accept-stress.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Ftest%2Frun-pass%2Ftcp-accept-stress.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Ftest%2Frun-pass%2Ftcp-accept-stress.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftcp-accept-stress.rs?ref=d4a2c941809f303b97d153e06ba07e95cd245f88", "patch": "@@ -19,7 +19,7 @@ use std::old_io::{TcpListener, Listener, Acceptor, EndOfFile, TcpStream};\n use std::sync::Arc;\n use std::sync::atomic::{AtomicUsize, Ordering};\n use std::sync::mpsc::channel;\n-use std::thread::Thread;\n+use std::thread;\n \n static N: usize = 8;\n static M: usize = 20;\n@@ -40,7 +40,7 @@ fn test() {\n         let a = a.clone();\n         let cnt = cnt.clone();\n         let srv_tx = srv_tx.clone();\n-        Thread::scoped(move|| {\n+        thread::scoped(move|| {\n             let mut a = a;\n             loop {\n                 match a.accept() {\n@@ -59,7 +59,7 @@ fn test() {\n \n     let _t = (0..N).map(|_| {\n         let cli_tx = cli_tx.clone();\n-        Thread::scoped(move|| {\n+        thread::scoped(move|| {\n             for _ in 0..M {\n                 let _s = TcpStream::connect(addr).unwrap();\n             }"}, {"sha": "64f07a60b3503858390cadc58b92687422f0c8d9", "filename": "src/test/run-pass/tcp-connect-timeouts.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Ftest%2Frun-pass%2Ftcp-connect-timeouts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Ftest%2Frun-pass%2Ftcp-connect-timeouts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftcp-connect-timeouts.rs?ref=d4a2c941809f303b97d153e06ba07e95cd245f88", "patch": "@@ -26,15 +26,15 @@ use std::old_io::test::*;\n use std::old_io;\n use std::time::Duration;\n use std::sync::mpsc::channel;\n-use std::thread::Thread;\n+use std::thread;\n \n #[cfg_attr(target_os = \"freebsd\", ignore)]\n fn eventual_timeout() {\n     let addr = next_test_ip4();\n \n     let (tx1, rx1) = channel();\n     let (_tx2, rx2) = channel::<()>();\n-    let _t = Thread::spawn(move|| {\n+    let _t = thread::scoped(move|| {\n         let _l = TcpListener::bind(addr).unwrap().listen();\n         tx1.send(()).unwrap();\n         let _ = rx2.recv();"}, {"sha": "49fac24d0b3a5b7e921233856ad3dff79776f99a", "filename": "src/test/run-pass/tempfile.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Ftest%2Frun-pass%2Ftempfile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Ftest%2Frun-pass%2Ftempfile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftempfile.rs?ref=d4a2c941809f303b97d153e06ba07e95cd245f88", "patch": "@@ -24,7 +24,7 @@ use std::old_path::{Path, GenericPath};\n use std::old_io::fs::PathExtensions;\n use std::old_io::{fs, TempDir};\n use std::old_io;\n-use std::os;\n+use std::env;\n use std::sync::mpsc::channel;\n use std::thread;\n \n@@ -129,7 +129,7 @@ fn test_rm_tempdir_close() {\n // to depend on std\n fn recursive_mkdir_rel() {\n     let path = Path::new(\"frob\");\n-    let cwd = os::getcwd().unwrap();\n+    let cwd = Path::new(env::current_dir().unwrap().to_str().unwrap());\n     println!(\"recursive_mkdir_rel: Making: {} in cwd {} [{}]\", path.display(),\n            cwd.display(), path.exists());\n     fs::mkdir_recursive(&path, old_io::USER_RWX);\n@@ -147,7 +147,7 @@ fn recursive_mkdir_dot() {\n \n fn recursive_mkdir_rel_2() {\n     let path = Path::new(\"./frob/baz\");\n-    let cwd = os::getcwd().unwrap();\n+    let cwd = Path::new(env::current_dir().unwrap().to_str().unwrap());\n     println!(\"recursive_mkdir_rel_2: Making: {} in cwd {} [{}]\", path.display(),\n            cwd.display(), path.exists());\n     fs::mkdir_recursive(&path, old_io::USER_RWX);\n@@ -196,7 +196,7 @@ pub fn dont_double_panic() {\n \n fn in_tmpdir<F>(f: F) where F: FnOnce() {\n     let tmpdir = TempDir::new(\"test\").ok().expect(\"can't make tmpdir\");\n-    assert!(os::change_dir(tmpdir.path()).is_ok());\n+    assert!(env::set_current_dir(tmpdir.path().as_str().unwrap()).is_ok());\n \n     f();\n }"}, {"sha": "969a42a6f8715624ad3543688927b7cbcd057e08", "filename": "src/test/run-pass/threads.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Ftest%2Frun-pass%2Fthreads.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Ftest%2Frun-pass%2Fthreads.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fthreads.rs?ref=d4a2c941809f303b97d153e06ba07e95cd245f88", "patch": "@@ -10,12 +10,12 @@\n \n #![feature(std_misc)]\n \n-use std::thread::Thread;\n+use std::thread;\n \n pub fn main() {\n     let mut i = 10;\n     while i > 0 {\n-        Thread::scoped({let i = i; move|| child(i)});\n+        thread::scoped({let i = i; move|| child(i)});\n         i = i - 1;\n     }\n     println!(\"main thread exiting\");"}, {"sha": "02ea7037056051a5e2d1a1f79049f327c142f388", "filename": "src/test/run-pass/trait-bounds-in-arc.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Ftest%2Frun-pass%2Ftrait-bounds-in-arc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Ftest%2Frun-pass%2Ftrait-bounds-in-arc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-bounds-in-arc.rs?ref=d4a2c941809f303b97d153e06ba07e95cd245f88", "patch": "@@ -19,7 +19,7 @@\n \n use std::sync::Arc;\n use std::sync::mpsc::channel;\n-use std::thread::Thread;\n+use std::thread;\n \n trait Pet {\n     fn name(&self, blk: Box<FnMut(&str)>);\n@@ -83,13 +83,13 @@ pub fn main() {\n                             box dogge2 as Box<Pet+Sync+Send>));\n     let (tx1, rx1) = channel();\n     let arc1 = arc.clone();\n-    let _t1 = Thread::spawn(move|| { check_legs(arc1); tx1.send(()); });\n+    let _t1 = thread::scoped(move|| { check_legs(arc1); tx1.send(()); });\n     let (tx2, rx2) = channel();\n     let arc2 = arc.clone();\n-    let _t2 = Thread::spawn(move|| { check_names(arc2); tx2.send(()); });\n+    let _t2 = thread::scoped(move|| { check_names(arc2); tx2.send(()); });\n     let (tx3, rx3) = channel();\n     let arc3 = arc.clone();\n-    let _t3 = Thread::spawn(move|| { check_pedigree(arc3); tx3.send(()); });\n+    let _t3 = thread::scoped(move|| { check_pedigree(arc3); tx3.send(()); });\n     rx1.recv();\n     rx2.recv();\n     rx3.recv();"}, {"sha": "d81dc3afcd7af05d03d7ba52212eba2edeac57da", "filename": "src/test/run-pass/variadic-ffi.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Ftest%2Frun-pass%2Fvariadic-ffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4a2c941809f303b97d153e06ba07e95cd245f88/src%2Ftest%2Frun-pass%2Fvariadic-ffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fvariadic-ffi.rs?ref=d4a2c941809f303b97d153e06ba07e95cd245f88", "patch": "@@ -14,7 +14,7 @@\n \n extern crate libc;\n \n-use std::ffi::{self, CString};\n+use std::ffi::{CStr, CString};\n use libc::{c_char, c_int};\n \n \n@@ -25,7 +25,7 @@ extern {\n unsafe fn check<T, F>(expected: &str, f: F) where F: FnOnce(*mut c_char) -> T {\n     let mut x = [0 as c_char; 50];\n     f(&mut x[0] as *mut c_char);\n-    assert_eq!(expected.as_bytes(), ffi::c_str_to_bytes(&x.as_ptr()));\n+    assert_eq!(expected.as_bytes(), CStr::from_ptr(x.as_ptr()).to_bytes());\n }\n \n pub fn main() {"}]}