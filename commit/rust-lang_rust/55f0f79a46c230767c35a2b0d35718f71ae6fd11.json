{"sha": "55f0f79a46c230767c35a2b0d35718f71ae6fd11", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU1ZjBmNzlhNDZjMjMwNzY3YzM1YTJiMGQzNTcxOGY3MWFlNmZkMTE=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-05-10T18:50:29Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-05-10T18:50:29Z"}, "message": "Re-enable use of llvm intrinsics for memcpy, memset. Should have aligned stack now.", "tree": {"sha": "feb8e06a8c36772840940df9b488107da2312ab1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/feb8e06a8c36772840940df9b488107da2312ab1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/55f0f79a46c230767c35a2b0d35718f71ae6fd11", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/55f0f79a46c230767c35a2b0d35718f71ae6fd11", "html_url": "https://github.com/rust-lang/rust/commit/55f0f79a46c230767c35a2b0d35718f71ae6fd11", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/55f0f79a46c230767c35a2b0d35718f71ae6fd11/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1abb7a868e41003bd618b5bec75c39f90eee5ce1", "url": "https://api.github.com/repos/rust-lang/rust/commits/1abb7a868e41003bd618b5bec75c39f90eee5ce1", "html_url": "https://github.com/rust-lang/rust/commit/1abb7a868e41003bd618b5bec75c39f90eee5ce1"}], "stats": {"total": 183, "additions": 77, "deletions": 106}, "files": [{"sha": "0ae6eba11b6daaf81cc3573c939f525f42194d37", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 77, "deletions": 106, "changes": 183, "blob_url": "https://github.com/rust-lang/rust/blob/55f0f79a46c230767c35a2b0d35718f71ae6fd11/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55f0f79a46c230767c35a2b0d35718f71ae6fd11/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=55f0f79a46c230767c35a2b0d35718f71ae6fd11", "patch": "@@ -58,8 +58,6 @@ type glue_fns = rec(ValueRef activate_glue,\n                     vec[ValueRef] native_glues_pure_rust,\n                     vec[ValueRef] native_glues_cdecl,\n                     ValueRef no_op_type_glue,\n-                    ValueRef memcpy_glue,\n-                    ValueRef bzero_glue,\n                     ValueRef vec_append_glue);\n \n type tydesc_info = rec(ValueRef tydesc,\n@@ -2921,31 +2919,58 @@ fn drop_ty(@block_ctxt cx,\n fn call_memcpy(@block_ctxt cx,\n                ValueRef dst,\n                ValueRef src,\n-               ValueRef n_bytes) -> result {\n+               ValueRef n_bytes,\n+               ValueRef align_bytes) -> result {\n+    // FIXME: switch to the 64-bit variant when on such a platform.\n+    auto i = cx.fcx.lcx.ccx.intrinsics;\n+    assert (i.contains_key(\"llvm.memcpy.p0i8.p0i8.i32\"));\n+    auto memcpy = i.get(\"llvm.memcpy.p0i8.p0i8.i32\");\n     auto src_ptr = cx.build.PointerCast(src, T_ptr(T_i8()));\n     auto dst_ptr = cx.build.PointerCast(dst, T_ptr(T_i8()));\n-    auto size = cx.build.IntCast(n_bytes, T_int());\n-    ret res(cx, cx.build.FastCall(cx.fcx.lcx.ccx.glues.memcpy_glue,\n-                                  vec(dst_ptr, src_ptr, size)));\n+    auto size = cx.build.IntCast(n_bytes, T_i32());\n+    auto align =\n+        if (lib.llvm.llvm.LLVMIsConstant(align_bytes) == True)\n+            { cx.build.IntCast(align_bytes, T_i32()) }\n+        else\n+            { cx.build.IntCast(C_int(0), T_i32()) };\n+\n+    auto volatile = C_bool(false);\n+    ret res(cx, cx.build.Call(memcpy,\n+                              vec(dst_ptr, src_ptr,\n+                                  size, align, volatile)));\n }\n \n fn call_bzero(@block_ctxt cx,\n               ValueRef dst,\n-              ValueRef n_bytes) -> result {\n+              ValueRef n_bytes,\n+              ValueRef align_bytes) -> result {\n+\n+    // FIXME: switch to the 64-bit variant when on such a platform.\n+    auto i = cx.fcx.lcx.ccx.intrinsics;\n+    assert (i.contains_key(\"llvm.memset.p0i8.i32\"));\n+    auto memset = i.get(\"llvm.memset.p0i8.i32\");\n     auto dst_ptr = cx.build.PointerCast(dst, T_ptr(T_i8()));\n-    auto size = cx.build.IntCast(n_bytes, T_int());\n-    ret res(cx, cx.build.FastCall(cx.fcx.lcx.ccx.glues.bzero_glue,\n-                                  vec(dst_ptr, size)));\n+    auto size = cx.build.IntCast(n_bytes, T_i32());\n+    auto align =\n+        if (lib.llvm.llvm.LLVMIsConstant(align_bytes) == True)\n+            { cx.build.IntCast(align_bytes, T_i32()) }\n+        else\n+            { cx.build.IntCast(C_int(0), T_i32()) };\n+\n+    auto volatile = C_bool(false);\n+    ret res(cx, cx.build.Call(memset,\n+                              vec(dst_ptr, C_u8(0u),\n+                                  size, align, volatile)));\n }\n \n fn memcpy_ty(@block_ctxt cx,\n              ValueRef dst,\n              ValueRef src,\n              ty.t t) -> result {\n     if (ty.type_has_dynamic_size(cx.fcx.lcx.ccx.tcx, t)) {\n-        auto llszptr = field_of_tydesc(cx, t, false, abi.tydesc_field_size);\n-        auto llsz = llszptr.bcx.build.Load(llszptr.val);\n-        ret call_memcpy(llszptr.bcx, dst, src, llsz);\n+        auto llsz = size_of(cx, t);\n+        auto llalign = align_of(llsz.bcx, t);\n+        ret call_memcpy(llalign.bcx, dst, src, llsz.val, llalign.val);\n \n     } else {\n         ret res(cx, cx.build.Store(cx.build.Load(src), dst));\n@@ -5553,7 +5578,8 @@ fn trans_break_cont(@block_ctxt cx, bool to_end) -> result {\n                         }\n                     }\n                 }\n-                ret res(new_sub_block_ctxt(bcx, \"unreachable\"), C_nil());\n+                ret res(new_sub_block_ctxt(bcx, \"break_cont.unreachable\"),\n+                        C_nil());\n             }\n             case (_) {\n                 alt (cleanup_cx.parent) {\n@@ -5609,7 +5635,7 @@ fn trans_ret(@block_ctxt cx, &Option.t[@ast.expr] e) -> result {\n     }\n \n     bcx.build.RetVoid();\n-    ret res(new_sub_block_ctxt(bcx, \"unreachable\"), C_nil());\n+    ret res(new_sub_block_ctxt(bcx, \"ret.unreachable\"), C_nil());\n }\n \n fn trans_be(@block_ctxt cx, @ast.expr e) -> result {\n@@ -5773,7 +5799,9 @@ fn zero_alloca(@block_ctxt cx, ValueRef llptr, ty.t t) -> result {\n     auto bcx = cx;\n     if (ty.type_has_dynamic_size(cx.fcx.lcx.ccx.tcx, t)) {\n         auto llsz = size_of(bcx, t);\n-        bcx = call_bzero(llsz.bcx, llptr, llsz.val).bcx;\n+        auto llalign = align_of(llsz.bcx, t);\n+        bcx = call_bzero(llalign.bcx, llptr,\n+                         llsz.val, llalign.val).bcx;\n     } else {\n         auto llty = type_of(bcx.fcx.lcx.ccx, t);\n         auto null = lib.llvm.llvm.LLVMConstNull(llty);\n@@ -7285,11 +7313,36 @@ fn trans_main_fn(@local_ctxt cx, ValueRef llcrate, ValueRef crate_map) {\n \n fn declare_intrinsics(ModuleRef llmod) -> hashmap[str,ValueRef] {\n \n+    let vec[TypeRef] T_memcpy32_args = vec(T_ptr(T_i8()), T_ptr(T_i8()),\n+                                           T_i32(), T_i32(), T_i1());\n+    let vec[TypeRef] T_memcpy64_args = vec(T_ptr(T_i8()), T_ptr(T_i8()),\n+                                           T_i64(), T_i32(), T_i1());\n+\n+    let vec[TypeRef] T_memset32_args = vec(T_ptr(T_i8()), T_i8(),\n+                                           T_i32(), T_i32(), T_i1());\n+    let vec[TypeRef] T_memset64_args = vec(T_ptr(T_i8()), T_i8(),\n+                                           T_i64(), T_i32(), T_i1());\n+\n     let vec[TypeRef] T_trap_args = vec();\n+\n+    auto memcpy32 = decl_cdecl_fn(llmod, \"llvm.memcpy.p0i8.p0i8.i32\",\n+                                  T_fn(T_memcpy32_args, T_void()));\n+    auto memcpy64 = decl_cdecl_fn(llmod, \"llvm.memcpy.p0i8.p0i8.i64\",\n+                                  T_fn(T_memcpy64_args, T_void()));\n+\n+    auto memset32 = decl_cdecl_fn(llmod, \"llvm.memset.p0i8.i32\",\n+                                  T_fn(T_memset32_args, T_void()));\n+    auto memset64 = decl_cdecl_fn(llmod, \"llvm.memset.p0i8.i64\",\n+                                  T_fn(T_memset64_args, T_void()));\n+\n     auto trap = decl_cdecl_fn(llmod, \"llvm.trap\",\n                               T_fn(T_trap_args, T_void()));\n \n     auto intrinsics = new_str_hash[ValueRef]();\n+    intrinsics.insert(\"llvm.memcpy.p0i8.p0i8.i32\", memcpy32);\n+    intrinsics.insert(\"llvm.memcpy.p0i8.p0i8.i64\", memcpy64);\n+    intrinsics.insert(\"llvm.memset.p0i8.i32\", memset32);\n+    intrinsics.insert(\"llvm.memset.p0i8.i64\", memset64);\n     intrinsics.insert(\"llvm.trap\", trap);\n     ret intrinsics;\n }\n@@ -7324,91 +7377,6 @@ fn make_no_op_type_glue(ValueRef fun) {\n     new_builder(llbb).RetVoid();\n }\n \n-fn decl_memcpy_glue(ModuleRef llmod) -> ValueRef {\n-    auto p8 = T_ptr(T_i8());\n-\n-    auto ty = T_fn(vec(p8, p8, T_int()), T_void());\n-    ret decl_fastcall_fn(llmod, abi.memcpy_glue_name(), ty);\n-}\n-\n-fn make_memcpy_glue(ValueRef fun) {\n-    // We're not using the LLVM memcpy intrinsic. It appears to call through\n-    // to the platform memcpy in some cases, which is not terribly safe to run\n-    // on a rust stack.\n-    auto initbb = llvm.LLVMAppendBasicBlock(fun, Str.buf(\"init\"));\n-    auto hdrbb = llvm.LLVMAppendBasicBlock(fun, Str.buf(\"hdr\"));\n-    auto loopbb = llvm.LLVMAppendBasicBlock(fun, Str.buf(\"loop\"));\n-    auto endbb = llvm.LLVMAppendBasicBlock(fun, Str.buf(\"end\"));\n-\n-    auto dst = llvm.LLVMGetParam(fun, 0u);\n-    auto src = llvm.LLVMGetParam(fun, 1u);\n-    auto count = llvm.LLVMGetParam(fun, 2u);\n-\n-    // Init block.\n-    auto ib = new_builder(initbb);\n-    auto ip = ib.Alloca(T_int());\n-    ib.Store(C_int(0), ip);\n-    ib.Br(hdrbb);\n-\n-    // Loop-header block\n-    auto hb = new_builder(hdrbb);\n-    auto i = hb.Load(ip);\n-    hb.CondBr(hb.ICmp(lib.llvm.LLVMIntEQ, count, i), endbb, loopbb);\n-\n-    // Loop-body block\n-    auto lb = new_builder(loopbb);\n-    i = lb.Load(ip);\n-    lb.Store(lb.Load(lb.GEP(src, vec(i))),\n-             lb.GEP(dst, vec(i)));\n-    lb.Store(lb.Add(i, C_int(1)), ip);\n-    lb.Br(hdrbb);\n-\n-    // End block\n-    auto eb = new_builder(endbb);\n-    eb.RetVoid();\n-}\n-\n-fn decl_bzero_glue(ModuleRef llmod) -> ValueRef {\n-    auto p8 = T_ptr(T_i8());\n-\n-    auto ty = T_fn(vec(p8, T_int()), T_void());\n-    ret decl_fastcall_fn(llmod, abi.bzero_glue_name(), ty);\n-}\n-\n-fn make_bzero_glue(ValueRef fun) -> ValueRef {\n-    // We're not using the LLVM memset intrinsic. Same as with memcpy.\n-    auto initbb = llvm.LLVMAppendBasicBlock(fun, Str.buf(\"init\"));\n-    auto hdrbb = llvm.LLVMAppendBasicBlock(fun, Str.buf(\"hdr\"));\n-    auto loopbb = llvm.LLVMAppendBasicBlock(fun, Str.buf(\"loop\"));\n-    auto endbb = llvm.LLVMAppendBasicBlock(fun, Str.buf(\"end\"));\n-\n-    auto dst = llvm.LLVMGetParam(fun, 0u);\n-    auto count = llvm.LLVMGetParam(fun, 1u);\n-\n-    // Init block.\n-    auto ib = new_builder(initbb);\n-    auto ip = ib.Alloca(T_int());\n-    ib.Store(C_int(0), ip);\n-    ib.Br(hdrbb);\n-\n-    // Loop-header block\n-    auto hb = new_builder(hdrbb);\n-    auto i = hb.Load(ip);\n-    hb.CondBr(hb.ICmp(lib.llvm.LLVMIntEQ, count, i), endbb, loopbb);\n-\n-    // Loop-body block\n-    auto lb = new_builder(loopbb);\n-    i = lb.Load(ip);\n-    lb.Store(C_u8(0u), lb.GEP(dst, vec(i)));\n-    lb.Store(lb.Add(i, C_int(1)), ip);\n-    lb.Br(hdrbb);\n-\n-    // End block\n-    auto eb = new_builder(endbb);\n-    eb.RetVoid();\n-    ret fun;\n-}\n-\n fn make_vec_append_glue(ModuleRef llmod, type_names tn) -> ValueRef {\n     /*\n      * Args to vec_append_glue:\n@@ -7559,6 +7527,13 @@ fn trans_vec_append_glue(@local_ctxt cx) {\n                                            C_int(abi.tydesc_field_size))));\n         llvm.LLVMSetValueName(elt_llsz, Str.buf(\"elt_llsz\"));\n \n+        auto elt_llalign =\n+            cx.build.Load(cx.build.GEP(elt_tydesc,\n+                                       vec(C_int(0),\n+                                           C_int(abi.tydesc_field_align))));\n+        llvm.LLVMSetValueName(elt_llsz, Str.buf(\"elt_llalign\"));\n+\n+\n         fn take_one(ValueRef elt_tydesc,\n                     @block_ctxt cx,\n                     ValueRef dst, ValueRef src) -> result {\n@@ -7572,7 +7547,7 @@ fn trans_vec_append_glue(@local_ctxt cx) {\n                                      elt_llsz, bind take_one(elt_tydesc,\n                                                              _, _, _)).bcx;\n \n-        ret call_memcpy(bcx, dst, src, n_bytes);\n+        ret call_memcpy(bcx, dst, src, n_bytes, elt_llalign);\n     }\n \n     // Copy any dst elements in, omitting null if doing str.\n@@ -7637,8 +7612,6 @@ fn make_glues(ModuleRef llmod, type_names tn) -> @glue_fns {\n                  Vec.init_fn[ValueRef](bind decl_native_glue(llmod, tn,\n                     abi.ngt_cdecl, _), abi.n_native_glues + 1 as uint),\n              no_op_type_glue = decl_no_op_type_glue(llmod, tn),\n-             memcpy_glue = decl_memcpy_glue(llmod),\n-             bzero_glue = decl_bzero_glue(llmod),\n              vec_append_glue = make_vec_append_glue(llmod, tn));\n }\n \n@@ -7663,8 +7636,6 @@ fn make_common_glue(session.session sess, str output) {\n \n     auto glues = make_glues(llmod, tn);\n     create_crate_constant(crate_ptr, glues);\n-    make_memcpy_glue(glues.memcpy_glue);\n-    make_bzero_glue(glues.bzero_glue);\n \n     trans.trans_exit_task_glue(glues, new_str_hash[ValueRef](), tn,\n                                llmod);"}]}