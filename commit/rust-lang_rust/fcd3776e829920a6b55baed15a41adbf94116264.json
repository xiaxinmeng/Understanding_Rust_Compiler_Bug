{"sha": "fcd3776e829920a6b55baed15a41adbf94116264", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZjZDM3NzZlODI5OTIwYTZiNTViYWVkMTVhNDFhZGJmOTQxMTYyNjQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-09-27T03:06:09Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-09-27T03:06:09Z"}, "message": "auto merge of #9523 : huonw/rust/kud1ing-docs, r=huonw\n\nCollation of @kud1ing's work in #9511, #9512, #9513 and #9518.", "tree": {"sha": "b195aae6a0f2fdb80d875b725b6fdb2fb1a25f6d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b195aae6a0f2fdb80d875b725b6fdb2fb1a25f6d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fcd3776e829920a6b55baed15a41adbf94116264", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fcd3776e829920a6b55baed15a41adbf94116264", "html_url": "https://github.com/rust-lang/rust/commit/fcd3776e829920a6b55baed15a41adbf94116264", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fcd3776e829920a6b55baed15a41adbf94116264/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a94158ce64524b7e21e6c8ec23a6b762d45926fb", "url": "https://api.github.com/repos/rust-lang/rust/commits/a94158ce64524b7e21e6c8ec23a6b762d45926fb", "html_url": "https://github.com/rust-lang/rust/commit/a94158ce64524b7e21e6c8ec23a6b762d45926fb"}, {"sha": "3165ddeb408cb4caf42fb48954dce4a82e3b4200", "url": "https://api.github.com/repos/rust-lang/rust/commits/3165ddeb408cb4caf42fb48954dce4a82e3b4200", "html_url": "https://github.com/rust-lang/rust/commit/3165ddeb408cb4caf42fb48954dce4a82e3b4200"}], "stats": {"total": 138, "additions": 69, "deletions": 69}, "files": [{"sha": "c182a005f4b96f74033930b89eee8e83cacce0a9", "filename": "src/libextra/base64.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fcd3776e829920a6b55baed15a41adbf94116264/src%2Flibextra%2Fbase64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fcd3776e829920a6b55baed15a41adbf94116264/src%2Flibextra%2Fbase64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fbase64.rs?ref=fcd3776e829920a6b55baed15a41adbf94116264", "patch": "@@ -13,19 +13,19 @@ use std::str;\n \n /// Available encoding character sets\n pub enum CharacterSet {\n-    /// The standard character set (uses '+' and '/')\n+    /// The standard character set (uses `+` and `/`)\n     Standard,\n-    /// The URL safe character set (uses '-' and '_')\n+    /// The URL safe character set (uses `-` and `_`)\n     UrlSafe\n }\n \n-/// Contains configuration parameters for to_base64\n+/// Contains configuration parameters for `to_base64`.\n pub struct Config {\n     /// Character set to use\n     char_set: CharacterSet,\n-    /// True to pad output with '=' characters\n+    /// True to pad output with `=` characters\n     pad: bool,\n-    /// Some(len) to wrap lines at len, None to disable line wrapping\n+    /// `Some(len)` to wrap lines at `len`, `None` to disable line wrapping\n     line_length: Option<uint>\n }\n "}, {"sha": "a24f3521fea9936cf8046b6b094a21b0671a22fe", "filename": "src/libextra/bitv.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/fcd3776e829920a6b55baed15a41adbf94116264/src%2Flibextra%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fcd3776e829920a6b55baed15a41adbf94116264/src%2Flibextra%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fbitv.rs?ref=fcd3776e829920a6b55baed15a41adbf94116264", "patch": "@@ -116,7 +116,7 @@ struct BigBitv {\n }\n \n /**\n- * a mask that has a 1 for each defined bit in the nth element of a big_bitv,\n+ * A mask that has a 1 for each defined bit in the n'th element of a `BigBitv`,\n  * assuming n bits.\n  */\n #[inline]\n@@ -284,7 +284,7 @@ impl Bitv {\n      * Calculates the union of two bitvectors\n      *\n      * Sets `self` to the union of `self` and `v1`. Both bitvectors must be\n-     * the same length. Returns 'true' if `self` changed.\n+     * the same length. Returns `true` if `self` changed.\n     */\n     #[inline]\n     pub fn union(&mut self, v1: &Bitv) -> bool { self.do_op(Union, v1) }\n@@ -293,7 +293,7 @@ impl Bitv {\n      * Calculates the intersection of two bitvectors\n      *\n      * Sets `self` to the intersection of `self` and `v1`. Both bitvectors\n-     * must be the same length. Returns 'true' if `self` changed.\n+     * must be the same length. Returns `true` if `self` changed.\n     */\n     #[inline]\n     pub fn intersect(&mut self, v1: &Bitv) -> bool {\n@@ -395,7 +395,7 @@ impl Bitv {\n         self.do_op(Difference, v)\n     }\n \n-    /// Returns true if all bits are 1\n+    /// Returns `true` if all bits are 1\n     #[inline]\n     pub fn is_true(&self) -> bool {\n       match self.rep {\n@@ -417,7 +417,7 @@ impl Bitv {\n         self.iter().invert()\n     }\n \n-    /// Returns true if all bits are 0\n+    /// Returns `true` if all bits are 0\n     pub fn is_false(&self) -> bool {\n       match self.rep {\n         Small(ref b) => b.is_false(self.nbits),\n@@ -433,18 +433,18 @@ impl Bitv {\n     }\n \n     /**\n-     * Converts `self` to a vector of uint with the same length.\n+     * Converts `self` to a vector of `uint` with the same length.\n      *\n-     * Each uint in the resulting vector has either value 0u or 1u.\n+     * Each `uint` in the resulting vector has either value `0u` or `1u`.\n      */\n     pub fn to_vec(&self) -> ~[uint] {\n         vec::from_fn(self.nbits, |x| self.init_to_vec(x))\n     }\n \n     /**\n      * Organise the bits into bytes, such that the first bit in the\n-     * bitv becomes the high-order bit of the first byte. If the\n-     * size of the bitv is not a multiple of 8 then trailing bits\n+     * `Bitv` becomes the high-order bit of the first byte. If the\n+     * size of the `Bitv` is not a multiple of 8 then trailing bits\n      * will be filled-in with false/0\n      */\n     pub fn to_bytes(&self) -> ~[u8] {\n@@ -472,7 +472,7 @@ impl Bitv {\n     }\n \n     /**\n-     * Transform self into a [bool] by turning each bit into a bool\n+     * Transform `self` into a `[bool]` by turning each bit into a `bool`.\n      */\n     pub fn to_bools(&self) -> ~[bool] {\n         vec::from_fn(self.nbits, |i| self[i])\n@@ -498,7 +498,7 @@ impl Bitv {\n \n \n     /**\n-     * Compare a bitvector to a vector of bool.\n+     * Compare a bitvector to a vector of `bool`.\n      *\n      * Both the bitvector and vector must have the same length.\n      */\n@@ -519,9 +519,9 @@ impl Bitv {\n }\n \n /**\n- * Transform a byte-vector into a bitv. Each byte becomes 8 bits,\n+ * Transform a byte-vector into a `Bitv`. Each byte becomes 8 bits,\n  * with the most significant bits of each byte coming first. Each\n- * bit becomes true if equal to 1 or false if equal to 0.\n+ * bit becomes `true` if equal to 1 or `false` if equal to 0.\n  */\n pub fn from_bytes(bytes: &[u8]) -> Bitv {\n     from_fn(bytes.len() * 8, |i| {\n@@ -532,15 +532,15 @@ pub fn from_bytes(bytes: &[u8]) -> Bitv {\n }\n \n /**\n- * Transform a [bool] into a bitv by converting each bool into a bit.\n+ * Transform a `[bool]` into a `Bitv` by converting each `bool` into a bit.\n  */\n pub fn from_bools(bools: &[bool]) -> Bitv {\n     from_fn(bools.len(), |i| bools[i])\n }\n \n /**\n- * Create a bitv of the specified length where the value at each\n- * index is f(index).\n+ * Create a `Bitv` of the specified length where the value at each\n+ * index is `f(index)`.\n  */\n pub fn from_fn(len: uint, f: &fn(index: uint) -> bool) -> Bitv {\n     let mut bitv = Bitv::new(len, false);\n@@ -571,7 +571,7 @@ fn iterate_bits(base: uint, bits: uint, f: &fn(uint) -> bool) -> bool {\n     return true;\n }\n \n-/// An iterator for Bitv\n+/// An iterator for `Bitv`.\n pub struct BitvIterator<'self> {\n     priv bitv: &'self Bitv,\n     priv next_idx: uint,\n@@ -631,12 +631,12 @@ impl<'self> RandomAccessIterator<bool> for BitvIterator<'self> {\n ///\n /// It should also be noted that the amount of storage necessary for holding a\n /// set of objects is proportional to the maximum of the objects when viewed\n-/// as a uint.\n+/// as a `uint`.\n #[deriving(Clone)]\n pub struct BitvSet {\n     priv size: uint,\n \n-    // In theory this is a Bitv instead of always a BigBitv, but knowing that\n+    // In theory this is a `Bitv` instead of always a `BigBitv`, but knowing that\n     // there's an array of storage makes our lives a whole lot easier when\n     // performing union/intersection/etc operations\n     priv bitv: BigBitv\n@@ -861,7 +861,7 @@ impl MutableSet<uint> for BitvSet {\n }\n \n impl BitvSet {\n-    /// Visits each of the words that the two bit vectors (self and other)\n+    /// Visits each of the words that the two bit vectors (`self` and `other`)\n     /// both have in common. The three yielded arguments are (bit location,\n     /// w1, w2) where the bit location is the number of bits offset so far,\n     /// and w1/w2 are the words coming from the two vectors self, other.\n@@ -874,13 +874,13 @@ impl BitvSet {\n             .map(|((i, &w), o_store)| (i * uint::bits, w, o_store[i]))\n     }\n \n-    /// Visits each word in self or other that extends beyond the other. This\n+    /// Visits each word in `self` or `other` that extends beyond the other. This\n     /// will only iterate through one of the vectors, and it only iterates\n     /// over the portion that doesn't overlap with the other one.\n     ///\n-    /// The yielded arguments are a bool, the bit offset, and a word. The bool\n-    /// is true if the word comes from 'self', and false if it comes from\n-    /// 'other'.\n+    /// The yielded arguments are a `bool`, the bit offset, and a word. The `bool`\n+    /// is true if the word comes from `self`, and `false` if it comes from\n+    /// `other`.\n     fn outlier_iter<'a>(&'a self, other: &'a BitvSet)\n         -> Map<'static, ((uint, &'a uint), uint), (bool, uint, uint),\n                Zip<Enumerate<vec::VecIterator<'a, uint>>, Repeat<uint>>> {"}, {"sha": "e6ac1deeb62995d30edd70d1b42d940eda969f84", "filename": "src/libextra/getopts.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fcd3776e829920a6b55baed15a41adbf94116264/src%2Flibextra%2Fgetopts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fcd3776e829920a6b55baed15a41adbf94116264/src%2Flibextra%2Fgetopts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fgetopts.rs?ref=fcd3776e829920a6b55baed15a41adbf94116264", "patch": "@@ -10,11 +10,11 @@\n \n //! Simple getopt alternative.\n //!\n-//! Construct a vector of options, either by using reqopt, optopt, and optflag\n-//! or by building them from components yourself, and pass them to getopts,\n-//! along with a vector of actual arguments (not including argv[0]). You'll\n+//! Construct a vector of options, either by using `reqopt`, `optopt`, and `optflag`\n+//! or by building them from components yourself, and pass them to `getopts`,\n+//! along with a vector of actual arguments (not including `argv[0]`). You'll\n //! either get a failure code back, or a match. You'll have to verify whether\n-//! the amount of 'free' arguments in the match is what you expect. Use opt_*\n+//! the amount of 'free' arguments in the match is what you expect. Use `opt_*`\n //! accessors to get argument values out of the matches object.\n //!\n //! Single-character options are expected to appear on the command line with a\n@@ -27,7 +27,7 @@\n //!\n //! The following example shows simple command line parsing for an application\n //! that requires an input file to be specified, accepts an optional output\n-//! file name following -o, and accepts both -h and --help as optional flags.\n+//! file name following `-o`, and accepts both `-h` and `--help` as optional flags.\n //!\n //! ~~~{.rust}\n //! exter mod extra;"}, {"sha": "efb39f7c51e027f039c4a52ec5e389f6ad0aa6a5", "filename": "src/libextra/num/bigint.rs", "status": "modified", "additions": 35, "deletions": 35, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/fcd3776e829920a6b55baed15a41adbf94116264/src%2Flibextra%2Fnum%2Fbigint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fcd3776e829920a6b55baed15a41adbf94116264/src%2Flibextra%2Fnum%2Fbigint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fnum%2Fbigint.rs?ref=fcd3776e829920a6b55baed15a41adbf94116264", "patch": "@@ -10,10 +10,10 @@\n \n /*!\n \n-A Big integer (signed version: BigInt, unsigned version: BigUint).\n+A Big integer (signed version: `BigInt`, unsigned version: `BigUint`).\n \n-A BigUint is represented as an array of BigDigits.\n-A BigInt is a combination of BigUint and Sign.\n+A `BigUint` is represented as an array of `BigDigit`s.\n+A `BigInt` is a combination of `BigUint` and `Sign`.\n */\n \n #[allow(missing_doc)];\n@@ -29,17 +29,17 @@ use std::uint;\n use std::vec;\n \n /**\n-A BigDigit is a BigUint's composing element.\n+A `BigDigit` is a `BigUint`'s composing element.\n \n-A BigDigit is half the size of machine word size.\n+A `BigDigit` is half the size of machine word size.\n */\n #[cfg(target_word_size = \"32\")]\n pub type BigDigit = u16;\n \n /**\n-A BigDigit is a BigUint's composing element.\n+A `BigDigit` is a `BigUint`'s composing element.\n \n-A BigDigit is half the size of machine word size.\n+A `BigDigit` is half the size of machine word size.\n */\n #[cfg(target_word_size = \"64\")]\n pub type BigDigit = u32;\n@@ -64,13 +64,13 @@ pub mod BigDigit {\n     #[inline]\n     fn get_lo(n: uint) -> BigDigit { (n & lo_mask) as BigDigit }\n \n-    /// Split one machine sized unsigned integer into two BigDigits.\n+    /// Split one machine sized unsigned integer into two `BigDigit`s.\n     #[inline]\n     pub fn from_uint(n: uint) -> (BigDigit, BigDigit) {\n         (get_hi(n), get_lo(n))\n     }\n \n-    /// Join two BigDigits into one machine sized unsigned integer\n+    /// Join two `BigDigit`s into one machine sized unsigned integer\n     #[inline]\n     pub fn to_uint(hi: BigDigit, lo: BigDigit) -> uint {\n         (lo as uint) | ((hi as uint) << bits)\n@@ -80,8 +80,8 @@ pub mod BigDigit {\n /**\n A big unsigned integer type.\n \n-A BigUint-typed value BigUint { data: @[a, b, c] } represents a number\n-(a + b * BigDigit::base + c * BigDigit::base^2).\n+A `BigUint`-typed value `BigUint { data: @[a, b, c] }` represents a number\n+`(a + b * BigDigit::base + c * BigDigit::base^2)`.\n */\n #[deriving(Clone)]\n pub struct BigUint {\n@@ -550,7 +550,7 @@ impl ToStrRadix for BigUint {\n }\n \n impl FromStrRadix for BigUint {\n-    /// Creates and initializes an BigUint.\n+    /// Creates and initializes a `BigUint`.\n     #[inline]\n     fn from_str_radix(s: &str, radix: uint)\n         -> Option<BigUint> {\n@@ -559,7 +559,7 @@ impl FromStrRadix for BigUint {\n }\n \n impl BigUint {\n-    /// Creates and initializes an BigUint.\n+    /// Creates and initializes a `BigUint`.\n     #[inline]\n     pub fn new(v: ~[BigDigit]) -> BigUint {\n         // omit trailing zeros\n@@ -571,7 +571,7 @@ impl BigUint {\n         return BigUint { data: v };\n     }\n \n-    /// Creates and initializes an BigUint.\n+    /// Creates and initializes a `BigUint`.\n     #[inline]\n     pub fn from_uint(n: uint) -> BigUint {\n         match BigDigit::from_uint(n) {\n@@ -581,13 +581,13 @@ impl BigUint {\n         }\n     }\n \n-    /// Creates and initializes an BigUint.\n+    /// Creates and initializes a `BigUint`.\n     #[inline]\n     pub fn from_slice(slice: &[BigDigit]) -> BigUint {\n         return BigUint::new(slice.to_owned());\n     }\n \n-    /// Creates and initializes an BigUint.\n+    /// Creates and initializes a `BigUint`.\n     pub fn parse_bytes(buf: &[u8], radix: uint)\n         -> Option<BigUint> {\n         let (base, unit_len) = get_radix_base(radix);\n@@ -615,14 +615,14 @@ impl BigUint {\n     }\n \n \n-    /// Converts this BigUint into a uint, failing if the conversion\n+    /// Converts this `BigUint` into a `uint`, failing if the conversion\n     /// would overflow.\n     #[inline]\n     pub fn to_uint(&self) -> uint {\n         self.to_uint_opt().expect(\"BigUint conversion would overflow uint\")\n     }\n \n-    /// Converts this BigUint into a uint, unless it would overflow.\n+    /// Converts this `BigUint` into a `uint`, unless it would overflow.\n     #[inline]\n     pub fn to_uint_opt(&self) -> Option<uint> {\n         match self.data.len() {\n@@ -633,7 +633,7 @@ impl BigUint {\n         }\n     }\n \n-    // Converts this BigUint into an int, unless it would overflow.\n+    /// Converts this `BigUint` into an `int`, unless it would overflow.\n     pub fn to_int_opt(&self) -> Option<int> {\n         self.to_uint_opt().and_then(|n| {\n             // If top bit of uint is set, it's too large to convert to\n@@ -646,7 +646,7 @@ impl BigUint {\n         })\n     }\n \n-    /// Converts this BigUint into a BigInt.\n+    /// Converts this `BigUint` into a `BigInt`.\n     #[inline]\n     pub fn to_bigint(&self) -> BigInt {\n         BigInt::from_biguint(Plus, self.clone())\n@@ -698,7 +698,7 @@ impl BigUint {\n         return BigUint::new(shifted);\n     }\n \n-    /// Determines the fewest bits necessary to express the BigUint.\n+    /// Determines the fewest bits necessary to express the `BigUint`.\n     pub fn bits(&self) -> uint {\n         if self.is_zero() { return 0; }\n         let zeros = self.data.last().leading_zeros();\n@@ -754,7 +754,7 @@ fn get_radix_base(radix: uint) -> (uint, uint) {\n     }\n }\n \n-/// A Sign is a BigInt's composing element.\n+/// A Sign is a `BigInt`'s composing element.\n #[deriving(Eq, Clone)]\n pub enum Sign { Minus, Zero, Plus }\n \n@@ -1117,22 +1117,22 @@ impl FromStrRadix for BigInt {\n }\n \n trait RandBigInt {\n-    /// Generate a random BigUint of the given bit size.\n+    /// Generate a random `BigUint` of the given bit size.\n     fn gen_biguint(&mut self, bit_size: uint) -> BigUint;\n \n     /// Generate a random BigInt of the given bit size.\n     fn gen_bigint(&mut self, bit_size: uint) -> BigInt;\n \n-    /// Generate a random BigUint less than the given bound. Fails\n+    /// Generate a random `BigUint` less than the given bound. Fails\n     /// when the bound is zero.\n     fn gen_biguint_below(&mut self, bound: &BigUint) -> BigUint;\n \n-    /// Generate a random BigUint within the given range. The lower\n+    /// Generate a random `BigUint` within the given range. The lower\n     /// bound is inclusive; the upper bound is exclusive. Fails when\n     /// the upper bound is not greater than the lower bound.\n     fn gen_biguint_range(&mut self, lbound: &BigUint, ubound: &BigUint) -> BigUint;\n \n-    /// Generate a random BigInt within the given range. The lower\n+    /// Generate a random `BigInt` within the given range. The lower\n     /// bound is inclusive; the upper bound is exclusive. Fails when\n     /// the upper bound is not greater than the lower bound.\n     fn gen_bigint_range(&mut self, lbound: &BigInt, ubound: &BigInt) -> BigInt;\n@@ -1208,7 +1208,7 @@ impl BigInt {\n         BigInt::from_biguint(sign, BigUint::new(v))\n     }\n \n-    /// Creates and initializes an BigInt.\n+    /// Creates and initializes a `BigInt`.\n     #[inline]\n     pub fn from_biguint(sign: Sign, data: BigUint) -> BigInt {\n         if sign == Zero || data.is_zero() {\n@@ -1217,20 +1217,20 @@ impl BigInt {\n         return BigInt { sign: sign, data: data };\n     }\n \n-    /// Creates and initializes an BigInt.\n+    /// Creates and initializes a `BigInt`.\n     #[inline]\n     pub fn from_uint(n: uint) -> BigInt {\n         if n == 0 { return Zero::zero(); }\n         return BigInt::from_biguint(Plus, BigUint::from_uint(n));\n     }\n \n-    /// Creates and initializes an BigInt.\n+    /// Creates and initializes a `BigInt`.\n     #[inline]\n     pub fn from_slice(sign: Sign, slice: &[BigDigit]) -> BigInt {\n         BigInt::from_biguint(sign, BigUint::from_slice(slice))\n     }\n \n-    /// Creates and initializes an BigInt.\n+    /// Creates and initializes a `BigInt`.\n     pub fn parse_bytes(buf: &[u8], radix: uint)\n         -> Option<BigInt> {\n         if buf.is_empty() { return None; }\n@@ -1244,14 +1244,14 @@ impl BigInt {\n             .map_move(|bu| BigInt::from_biguint(sign, bu));\n     }\n \n-    /// Converts this BigInt into a uint, failing if the conversion\n+    /// Converts this `BigInt` into a `uint`, failing if the conversion\n     /// would overflow.\n     #[inline]\n     pub fn to_uint(&self) -> uint {\n         self.to_uint_opt().expect(\"BigInt conversion would overflow uint\")\n     }\n \n-    /// Converts this BigInt into a uint, unless it would overflow.\n+    /// Converts this `BigInt` into a `uint`, unless it would overflow.\n     #[inline]\n     pub fn to_uint_opt(&self) -> Option<uint> {\n         match self.sign {\n@@ -1261,7 +1261,7 @@ impl BigInt {\n         }\n     }\n \n-    /// Converts this BigInt into an int, unless it would overflow.\n+    /// Converts this `BigInt` into an `int`, unless it would overflow.\n     pub fn to_int_opt(&self) -> Option<int> {\n         match self.sign {\n             Plus  => self.data.to_int_opt(),\n@@ -1279,14 +1279,14 @@ impl BigInt {\n         }\n     }\n \n-    /// Converts this BigInt into a BigUint, failing if BigInt is\n+    /// Converts this `BigInt` into a `BigUint`, failing if BigInt is\n     /// negative.\n     #[inline]\n     pub fn to_biguint(&self) -> BigUint {\n         self.to_biguint_opt().expect(\"negative BigInt cannot convert to BigUint\")\n     }\n \n-    /// Converts this BigInt into a BigUint, if it's not negative.\n+    /// Converts this `BigInt` into a `BigUint`, if it's not negative.\n     #[inline]\n     pub fn to_biguint_opt(&self) -> Option<BigUint> {\n         match self.sign {"}]}