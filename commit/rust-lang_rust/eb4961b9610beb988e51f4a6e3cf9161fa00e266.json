{"sha": "eb4961b9610beb988e51f4a6e3cf9161fa00e266", "node_id": "MDY6Q29tbWl0NzI0NzEyOmViNDk2MWI5NjEwYmViOTg4ZTUxZjRhNmUzY2Y5MTYxZmEwMGUyNjY=", "commit": {"author": {"name": "James Miller", "email": "james@aatch.net", "date": "2015-02-19T19:36:25Z"}, "committer": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2015-02-22T11:43:03Z"}, "message": "Add support for mapping a single ast-node to multiple cfg-nodes.\n\nThis is necessary for e.g. supporting the cfgs we plan to construct\nfor match under aatch's plan.\n\n(Factoring of aatch CFG code, Part 3.)", "tree": {"sha": "38512b6d7eec9295e5a19cfe4f526fa5ad9c57e4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/38512b6d7eec9295e5a19cfe4f526fa5ad9c57e4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/eb4961b9610beb988e51f4a6e3cf9161fa00e266", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/eb4961b9610beb988e51f4a6e3cf9161fa00e266", "html_url": "https://github.com/rust-lang/rust/commit/eb4961b9610beb988e51f4a6e3cf9161fa00e266", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/eb4961b9610beb988e51f4a6e3cf9161fa00e266/comments", "author": {"login": "Aatch", "id": 342416, "node_id": "MDQ6VXNlcjM0MjQxNg==", "avatar_url": "https://avatars.githubusercontent.com/u/342416?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Aatch", "html_url": "https://github.com/Aatch", "followers_url": "https://api.github.com/users/Aatch/followers", "following_url": "https://api.github.com/users/Aatch/following{/other_user}", "gists_url": "https://api.github.com/users/Aatch/gists{/gist_id}", "starred_url": "https://api.github.com/users/Aatch/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Aatch/subscriptions", "organizations_url": "https://api.github.com/users/Aatch/orgs", "repos_url": "https://api.github.com/users/Aatch/repos", "events_url": "https://api.github.com/users/Aatch/events{/privacy}", "received_events_url": "https://api.github.com/users/Aatch/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a0b7bad00e5134e26fea08d2e4691360c61e68f0", "url": "https://api.github.com/repos/rust-lang/rust/commits/a0b7bad00e5134e26fea08d2e4691360c61e68f0", "html_url": "https://github.com/rust-lang/rust/commit/a0b7bad00e5134e26fea08d2e4691360c61e68f0"}], "stats": {"total": 106, "additions": 67, "deletions": 39}, "files": [{"sha": "1718df702553f0f94886f0b365fd880ad55ad439", "filename": "src/librustc/middle/dataflow.rs", "status": "modified", "additions": 67, "deletions": 39, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/eb4961b9610beb988e51f4a6e3cf9161fa00e266/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb4961b9610beb988e51f4a6e3cf9161fa00e266/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdataflow.rs?ref=eb4961b9610beb988e51f4a6e3cf9161fa00e266", "patch": "@@ -53,7 +53,7 @@ pub struct DataFlowContext<'a, 'tcx: 'a, O> {\n \n     // mapping from node to cfg node index\n     // FIXME (#6298): Shouldn't this go with CFG?\n-    nodeid_to_index: NodeMap<CFGIndex>,\n+    nodeid_to_index: NodeMap<Vec<CFGIndex>>,\n \n     // Bit sets per cfg node.  The following three fields (`gens`, `kills`,\n     // and `on_entry`) all have the same structure. For each id in\n@@ -88,11 +88,9 @@ struct PropagationContext<'a, 'b: 'a, 'tcx: 'b, O: 'a> {\n     changed: bool\n }\n \n-fn to_cfgidx_or_die(id: ast::NodeId, index: &NodeMap<CFGIndex>) -> CFGIndex {\n-    let opt_cfgindex = index.get(&id).cloned();\n-    opt_cfgindex.unwrap_or_else(|| {\n-        panic!(\"nodeid_to_index does not have entry for NodeId {}\", id);\n-    })\n+fn get_cfg_indices<'a>(id: ast::NodeId, index: &'a NodeMap<Vec<CFGIndex>>) -> &'a [CFGIndex] {\n+    let opt_indices = index.get(&id);\n+    opt_indices.map(|v| &v[..]).unwrap_or(&[])\n }\n \n impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n@@ -114,9 +112,13 @@ impl<'a, 'tcx, O:DataFlowOperator> pprust::PpAnn for DataFlowContext<'a, 'tcx, O\n             pprust::NodePat(pat) => pat.id\n         };\n \n-        if self.has_bitset_for_nodeid(id) {\n-            assert!(self.bits_per_id > 0);\n-            let cfgidx = to_cfgidx_or_die(id, &self.nodeid_to_index);\n+        if !self.has_bitset_for_nodeid(id) {\n+            return Ok(());\n+        }\n+\n+        assert!(self.bits_per_id > 0);\n+        let indices = get_cfg_indices(id, &self.nodeid_to_index);\n+        for &cfgidx in indices {\n             let (start, end) = self.compute_id_range(cfgidx);\n             let on_entry = &self.on_entry[start.. end];\n             let entry_str = bits_to_string(on_entry);\n@@ -144,7 +146,7 @@ impl<'a, 'tcx, O:DataFlowOperator> pprust::PpAnn for DataFlowContext<'a, 'tcx, O\n }\n \n fn build_nodeid_to_index(decl: Option<&ast::FnDecl>,\n-                         cfg: &cfg::CFG) -> NodeMap<CFGIndex> {\n+                         cfg: &cfg::CFG) -> NodeMap<Vec<CFGIndex>> {\n     let mut index = NodeMap();\n \n     // FIXME (#6298): Would it be better to fold formals from decl\n@@ -157,28 +159,38 @@ fn build_nodeid_to_index(decl: Option<&ast::FnDecl>,\n     }\n \n     cfg.graph.each_node(|node_idx, node| {\n-        if node.data.id() != ast::DUMMY_NODE_ID {\n-            index.insert(node.data.id(), node_idx);\n+        if let cfg::CFGNodeData::AST(id) = node.data {\n+            match index.entry(id).get() {\n+                Ok(v) => v.push(node_idx),\n+                Err(e) => {\n+                    e.insert(vec![node_idx]);\n+                }\n+            }\n         }\n         true\n     });\n \n     return index;\n \n-    fn add_entries_from_fn_decl(index: &mut NodeMap<CFGIndex>,\n+    fn add_entries_from_fn_decl(index: &mut NodeMap<Vec<CFGIndex>>,\n                                 decl: &ast::FnDecl,\n                                 entry: CFGIndex) {\n         //! add mappings from the ast nodes for the formal bindings to\n         //! the entry-node in the graph.\n         struct Formals<'a> {\n             entry: CFGIndex,\n-            index: &'a mut NodeMap<CFGIndex>,\n+            index: &'a mut NodeMap<Vec<CFGIndex>>,\n         }\n         let mut formals = Formals { entry: entry, index: index };\n         visit::walk_fn_decl(&mut formals, decl);\n         impl<'a, 'v> visit::Visitor<'v> for Formals<'a> {\n             fn visit_pat(&mut self, p: &ast::Pat) {\n-                self.index.insert(p.id, self.entry);\n+                match self.index.entry(p.id).get() {\n+                    Ok(v) => v.push(self.entry),\n+                    Err(e) => {\n+                        e.insert(vec![self.entry]);\n+                    }\n+                }\n                 visit::walk_pat(self, p)\n             }\n         }\n@@ -230,10 +242,12 @@ impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n         assert!(self.nodeid_to_index.contains_key(&id));\n         assert!(self.bits_per_id > 0);\n \n-        let cfgidx = to_cfgidx_or_die(id, &self.nodeid_to_index);\n-        let (start, end) = self.compute_id_range(cfgidx);\n-        let gens = &mut self.gens[start.. end];\n-        set_bit(gens, bit);\n+        let indices = get_cfg_indices(id, &self.nodeid_to_index);\n+        for &cfgidx in indices {\n+            let (start, end) = self.compute_id_range(cfgidx);\n+            let gens = &mut self.gens[start.. end];\n+            set_bit(gens, bit);\n+        }\n     }\n \n     pub fn add_kill(&mut self, id: ast::NodeId, bit: uint) {\n@@ -243,10 +257,12 @@ impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n         assert!(self.nodeid_to_index.contains_key(&id));\n         assert!(self.bits_per_id > 0);\n \n-        let cfgidx = to_cfgidx_or_die(id, &self.nodeid_to_index);\n-        let (start, end) = self.compute_id_range(cfgidx);\n-        let kills = &mut self.kills[start.. end];\n-        set_bit(kills, bit);\n+        let indices = get_cfg_indices(id, &self.nodeid_to_index);\n+        for &cfgidx in indices {\n+            let (start, end) = self.compute_id_range(cfgidx);\n+            let kills = &mut self.kills[start.. end];\n+            set_bit(kills, bit);\n+        }\n     }\n \n     fn apply_gen_kill(&self, cfgidx: CFGIndex, bits: &mut [uint]) {\n@@ -279,16 +295,21 @@ impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n     }\n \n \n-    pub fn each_bit_on_entry<F>(&self, id: ast::NodeId, f: F) -> bool where\n+    pub fn each_bit_on_entry<F>(&self, id: ast::NodeId, mut f: F) -> bool where\n         F: FnMut(uint) -> bool,\n     {\n         //! Iterates through each bit that is set on entry to `id`.\n         //! Only useful after `propagate()` has been called.\n         if !self.has_bitset_for_nodeid(id) {\n             return true;\n         }\n-        let cfgidx = to_cfgidx_or_die(id, &self.nodeid_to_index);\n-        self.each_bit_for_node(Entry, cfgidx, f)\n+        let indices = get_cfg_indices(id, &self.nodeid_to_index);\n+        for &cfgidx in indices {\n+            if !self.each_bit_for_node(Entry, cfgidx, |i| f(i)) {\n+                return false;\n+            }\n+        }\n+        return true;\n     }\n \n     pub fn each_bit_for_node<F>(&self, e: EntryOrExit, cfgidx: CFGIndex, f: F) -> bool where\n@@ -320,7 +341,7 @@ impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n         self.each_bit(slice, f)\n     }\n \n-    pub fn each_gen_bit<F>(&self, id: ast::NodeId, f: F) -> bool where\n+    pub fn each_gen_bit<F>(&self, id: ast::NodeId, mut f: F) -> bool where\n         F: FnMut(uint) -> bool,\n     {\n         //! Iterates through each bit in the gen set for `id`.\n@@ -334,12 +355,17 @@ impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n             return true;\n         }\n \n-        let cfgidx = to_cfgidx_or_die(id, &self.nodeid_to_index);\n-        let (start, end) = self.compute_id_range(cfgidx);\n-        let gens = &self.gens[start.. end];\n-        debug!(\"{} each_gen_bit(id={}, gens={})\",\n-               self.analysis_name, id, bits_to_string(gens));\n-        self.each_bit(gens, f)\n+        let indices = get_cfg_indices(id, &self.nodeid_to_index);\n+        for &cfgidx in indices {\n+            let (start, end) = self.compute_id_range(cfgidx);\n+            let gens = &self.gens[start.. end];\n+            debug!(\"{} each_gen_bit(id={}, gens={})\",\n+                   self.analysis_name, id, bits_to_string(gens));\n+            if !self.each_bit(gens, |i| f(i)) {\n+                return false;\n+            }\n+        }\n+        return true;\n     }\n \n     fn each_bit<F>(&self, words: &[uint], mut f: F) -> bool where\n@@ -400,13 +426,15 @@ impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n \n             let mut changed = false;\n             for &node_id in &edge.data.exiting_scopes {\n-                let opt_cfg_idx = self.nodeid_to_index.get(&node_id).cloned();\n+                let opt_cfg_idx = self.nodeid_to_index.get(&node_id);\n                 match opt_cfg_idx {\n-                    Some(cfg_idx) => {\n-                        let (start, end) = self.compute_id_range(cfg_idx);\n-                        let kills = &self.kills[start.. end];\n-                        if bitwise(&mut orig_kills, kills, &Union) {\n-                            changed = true;\n+                    Some(indices) => {\n+                        for &cfg_idx in indices {\n+                            let (start, end) = self.compute_id_range(cfg_idx);\n+                            let kills = &self.kills[start.. end];\n+                            if bitwise(&mut orig_kills, kills, &Union) {\n+                                changed = true;\n+                            }\n                         }\n                     }\n                     None => {"}]}