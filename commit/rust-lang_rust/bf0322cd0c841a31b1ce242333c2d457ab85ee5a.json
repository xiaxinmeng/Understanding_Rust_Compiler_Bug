{"sha": "bf0322cd0c841a31b1ce242333c2d457ab85ee5a", "node_id": "C_kwDOAAsO6NoAKGJmMDMyMmNkMGM4NDFhMzFiMWNlMjQyMzMzYzJkNDU3YWI4NWVlNWE", "commit": {"author": {"name": "XFFXFF", "email": "1247714429@qq.com", "date": "2023-03-11T02:35:55Z"}, "committer": {"name": "XFFXFF", "email": "1247714429@qq.com", "date": "2023-03-15T01:07:11Z"}, "message": "pick the best ancestor expr of unsafe expr to add unsafe block. Thanks! @Veykril", "tree": {"sha": "bb282efb7def55a22b6203cabd79dd36d9fb3f6a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bb282efb7def55a22b6203cabd79dd36d9fb3f6a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bf0322cd0c841a31b1ce242333c2d457ab85ee5a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bf0322cd0c841a31b1ce242333c2d457ab85ee5a", "html_url": "https://github.com/rust-lang/rust/commit/bf0322cd0c841a31b1ce242333c2d457ab85ee5a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bf0322cd0c841a31b1ce242333c2d457ab85ee5a/comments", "author": {"login": "xffxff", "id": 30254428, "node_id": "MDQ6VXNlcjMwMjU0NDI4", "avatar_url": "https://avatars.githubusercontent.com/u/30254428?v=4", "gravatar_id": "", "url": "https://api.github.com/users/xffxff", "html_url": "https://github.com/xffxff", "followers_url": "https://api.github.com/users/xffxff/followers", "following_url": "https://api.github.com/users/xffxff/following{/other_user}", "gists_url": "https://api.github.com/users/xffxff/gists{/gist_id}", "starred_url": "https://api.github.com/users/xffxff/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/xffxff/subscriptions", "organizations_url": "https://api.github.com/users/xffxff/orgs", "repos_url": "https://api.github.com/users/xffxff/repos", "events_url": "https://api.github.com/users/xffxff/events{/privacy}", "received_events_url": "https://api.github.com/users/xffxff/received_events", "type": "User", "site_admin": false}, "committer": {"login": "xffxff", "id": 30254428, "node_id": "MDQ6VXNlcjMwMjU0NDI4", "avatar_url": "https://avatars.githubusercontent.com/u/30254428?v=4", "gravatar_id": "", "url": "https://api.github.com/users/xffxff", "html_url": "https://github.com/xffxff", "followers_url": "https://api.github.com/users/xffxff/followers", "following_url": "https://api.github.com/users/xffxff/following{/other_user}", "gists_url": "https://api.github.com/users/xffxff/gists{/gist_id}", "starred_url": "https://api.github.com/users/xffxff/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/xffxff/subscriptions", "organizations_url": "https://api.github.com/users/xffxff/orgs", "repos_url": "https://api.github.com/users/xffxff/repos", "events_url": "https://api.github.com/users/xffxff/events{/privacy}", "received_events_url": "https://api.github.com/users/xffxff/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "82780d8caf7bd034d4ef0e3a62789f61a047eb81", "url": "https://api.github.com/repos/rust-lang/rust/commits/82780d8caf7bd034d4ef0e3a62789f61a047eb81", "html_url": "https://github.com/rust-lang/rust/commit/82780d8caf7bd034d4ef0e3a62789f61a047eb81"}], "stats": {"total": 266, "additions": 226, "deletions": 40}, "files": [{"sha": "c709c8c482b5131a9cdc0c9acbb2344dcdc663c2", "filename": "crates/ide-diagnostics/src/handlers/missing_unsafe.rs", "status": "modified", "additions": 226, "deletions": 40, "changes": 266, "blob_url": "https://github.com/rust-lang/rust/blob/bf0322cd0c841a31b1ce242333c2d457ab85ee5a/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fmissing_unsafe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf0322cd0c841a31b1ce242333c2d457ab85ee5a/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fmissing_unsafe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fmissing_unsafe.rs?ref=bf0322cd0c841a31b1ce242333c2d457ab85ee5a", "patch": "@@ -1,6 +1,5 @@\n use hir::db::AstDatabase;\n use ide_db::{assists::Assist, source_change::SourceChange};\n-use syntax::ast::{ExprStmt, LetStmt};\n use syntax::AstNode;\n use syntax::{ast, SyntaxNode};\n use text_edit::TextEdit;\n@@ -23,7 +22,7 @@ fn fixes(ctx: &DiagnosticsContext<'_>, d: &hir::MissingUnsafe) -> Option<Vec<Ass\n     let root = ctx.sema.db.parse_or_expand(d.expr.file_id)?;\n     let expr = d.expr.value.to_node(&root);\n \n-    let node_to_add_unsafe_block = pick_best_node_to_add_unsafe_block(ctx, &expr);\n+    let node_to_add_unsafe_block = pick_best_node_to_add_unsafe_block(&expr);\n \n     let replacement = format!(\"unsafe {{ {} }}\", node_to_add_unsafe_block.text());\n     let edit = TextEdit::replace(node_to_add_unsafe_block.text_range(), replacement);\n@@ -32,39 +31,78 @@ fn fixes(ctx: &DiagnosticsContext<'_>, d: &hir::MissingUnsafe) -> Option<Vec<Ass\n     Some(vec![fix(\"add_unsafe\", \"Add unsafe block\", source_change, expr.syntax().text_range())])\n }\n \n-// Find the let statement or expression statement closest to the `expr` in the\n-// ancestor chain.\n-//\n-// Why don't we just add an unsafe block around the `expr`?\n-//\n-// Consider this example:\n-// ```\n-// STATIC_MUT += 1;\n-// ```\n-// We can't add an unsafe block to the left-hand side of an assignment.\n-// ```\n-// unsafe { STATIC_MUT } += 1;\n-// ```\n-//\n-// Or this example:\n-// ```\n-// let z = STATIC_MUT.a;\n-// ```\n-// We can't add an unsafe block like this:\n-// ```\n-// let z = unsafe { STATIC_MUT } .a;\n-// ```\n-fn pick_best_node_to_add_unsafe_block(\n-    ctx: &DiagnosticsContext<'_>,\n-    expr: &ast::Expr,\n-) -> SyntaxNode {\n-    let Some(let_or_expr_stmt) = ctx.sema.ancestors_with_macros(expr.syntax().clone()).find(|node| {\n-        LetStmt::can_cast(node.kind()) || ExprStmt::can_cast(node.kind())\n-    }) else {\n-        // Is this reachable?\n-        return expr.syntax().clone();\n-    };\n-    let_or_expr_stmt\n+// Pick the first ancestor expression of the unsafe `expr` that is not a\n+// receiver of a method call, a field access, the left-hand side of an\n+// assignment, or a reference. As all of those cases would incur a forced move\n+// if wrapped which might not be wanted. That is:\n+// - `unsafe_expr.foo` -> `unsafe { unsafe_expr.foo }`\n+// - `unsafe_expr.foo.bar` -> `unsafe { unsafe_expr.foo.bar }`\n+// - `unsafe_expr.foo()` -> `unsafe { unsafe_expr.foo() }`\n+// - `unsafe_expr.foo.bar()` -> `unsafe { unsafe_expr.foo.bar() }`\n+// - `unsafe_expr += 1` -> `unsafe { unsafe_expr += 1 }`\n+// - `&unsafe_expr` -> `unsafe { &unsafe_expr }`\n+// - `&&unsafe_expr` -> `unsafe { &&unsafe_expr }`\n+fn pick_best_node_to_add_unsafe_block(unsafe_expr: &ast::Expr) -> SyntaxNode {\n+    // The `unsafe_expr` might be:\n+    // - `ast::CallExpr`: call an unsafe function\n+    // - `ast::MethodCallExpr`: call an unsafe method\n+    // - `ast::PrefixExpr`: dereference a raw pointer\n+    // - `ast::PathExpr`: access a static mut variable\n+    for node in unsafe_expr.syntax().ancestors() {\n+        let Some(parent) = node.parent() else {\n+            return node;\n+        };\n+        match parent.kind() {\n+            syntax::SyntaxKind::METHOD_CALL_EXPR => {\n+                // Check if the `node` is the receiver of the method call\n+                let method_call_expr = ast::MethodCallExpr::cast(parent.clone()).unwrap();\n+                if method_call_expr\n+                    .receiver()\n+                    .map(|receiver| {\n+                        receiver.syntax().text_range().contains_range(node.text_range())\n+                    })\n+                    .unwrap_or(false)\n+                {\n+                    // Actually, I think it's not necessary to check whether the\n+                    // text range of the `node` (which is the ancestor of the\n+                    // `unsafe_expr`) is contained in the text range of the\n+                    // receiver. The `node` could potentially be the receiver, the\n+                    // method name, or the argument list. Since the `node` is the\n+                    // ancestor of the unsafe_expr, it cannot be the method name.\n+                    // Additionally, if the `node` is the argument list, the loop\n+                    // would break at least when `parent` reaches the argument list.\n+                    //\n+                    // Dispite this, I still check the text range because I think it\n+                    // makes the code easier to understand.\n+                    continue;\n+                }\n+                return node;\n+            }\n+            syntax::SyntaxKind::FIELD_EXPR | syntax::SyntaxKind::REF_EXPR => continue,\n+            syntax::SyntaxKind::BIN_EXPR => {\n+                // Check if the `node` is the left-hand side of an assignment\n+                let is_left_hand_side_of_assignment = {\n+                    let bin_expr = ast::BinExpr::cast(parent.clone()).unwrap();\n+                    if let Some(ast::BinaryOp::Assignment { .. }) = bin_expr.op_kind() {\n+                        let is_left_hand_side = bin_expr\n+                            .lhs()\n+                            .map(|lhs| lhs.syntax().text_range().contains_range(node.text_range()))\n+                            .unwrap_or(false);\n+                        is_left_hand_side\n+                    } else {\n+                        false\n+                    }\n+                };\n+                if !is_left_hand_side_of_assignment {\n+                    return node;\n+                }\n+            }\n+            _ => {\n+                return node;\n+            }\n+        }\n+    }\n+    unsafe_expr.syntax().clone()\n }\n \n #[cfg(test)]\n@@ -168,7 +206,7 @@ fn main() {\n             r#\"\n fn main() {\n     let x = &5 as *const usize;\n-    unsafe { let z = *x; }\n+    let z = unsafe { *x };\n }\n \"#,\n         );\n@@ -192,7 +230,7 @@ unsafe fn func() {\n     let z = *x;\n }\n fn main() {\n-    unsafe { func(); }\n+    unsafe { func() };\n }\n \"#,\n         )\n@@ -224,7 +262,7 @@ impl S {\n }\n fn main() {\n     let s = S(5);\n-    unsafe { s.func(); }\n+    unsafe { s.func() };\n }\n \"#,\n         )\n@@ -252,7 +290,7 @@ struct Ty {\n static mut STATIC_MUT: Ty = Ty { a: 0 };\n \n fn main() {\n-    unsafe { let x = STATIC_MUT.a; }\n+    let x = unsafe { STATIC_MUT.a };\n }\n \"#,\n         )\n@@ -276,7 +314,155 @@ extern \"rust-intrinsic\" {\n }\n \n fn main() {\n-    unsafe { let _ = floorf32(12.0); }\n+    let _ = unsafe { floorf32(12.0) };\n+}\n+\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn unsafe_expr_as_a_receiver_of_a_method_call() {\n+        check_fix(\n+            r#\"\n+unsafe fn foo() -> String {\n+    \"string\".to_string()\n+}\n+\n+fn main() {\n+    foo$0().len();\n+}\n+\"#,\n+            r#\"\n+unsafe fn foo() -> String {\n+    \"string\".to_string()\n+}\n+\n+fn main() {\n+    unsafe { foo().len() };\n+}\n+\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn unsafe_expr_as_an_argument_of_a_method_call() {\n+        check_fix(\n+            r#\"\n+static mut STATIC_MUT: u8 = 0;\n+\n+fn main() {\n+    let mut v = vec![];\n+    v.push(STATIC_MUT$0);\n+}\n+\"#,\n+            r#\"\n+static mut STATIC_MUT: u8 = 0;\n+\n+fn main() {\n+    let mut v = vec![];\n+    v.push(unsafe { STATIC_MUT });\n+}\n+\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn unsafe_expr_as_left_hand_side_of_assignment() {\n+        check_fix(\n+            r#\"\n+static mut STATIC_MUT: u8 = 0;\n+\n+fn main() {\n+    STATIC_MUT$0 = 1;\n+}\n+\"#,\n+            r#\"\n+static mut STATIC_MUT: u8 = 0;\n+\n+fn main() {\n+    unsafe { STATIC_MUT = 1 };\n+}\n+\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn unsafe_expr_as_right_hand_side_of_assignment() {\n+        check_fix(\n+            r#\"\n+static mut STATIC_MUT: u8 = 0;\n+\n+fn main() {\n+    let x;\n+    x = STATIC_MUT$0;\n+}\n+\"#,\n+            r#\"\n+static mut STATIC_MUT: u8 = 0;\n+\n+fn main() {\n+    let x;\n+    x = unsafe { STATIC_MUT };\n+}\n+\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn unsafe_expr_in_binary_plus() {\n+        check_fix(\n+            r#\"\n+static mut STATIC_MUT: u8 = 0;\n+\n+fn main() {\n+    let x = STATIC_MUT$0 + 1;\n+}\n+\"#,\n+            r#\"\n+static mut STATIC_MUT: u8 = 0;\n+\n+fn main() {\n+    let x = unsafe { STATIC_MUT } + 1;\n+}\n+\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn ref_to_unsafe_expr() {\n+        check_fix(\n+            r#\"\n+static mut STATIC_MUT: u8 = 0;\n+\n+fn main() {\n+    let x = &STATIC_MUT$0;\n+}\n+\"#,\n+            r#\"\n+static mut STATIC_MUT: u8 = 0;\n+\n+fn main() {\n+    let x = unsafe { &STATIC_MUT };\n+}\n+\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn ref_ref_to_unsafe_expr() {\n+        check_fix(\n+            r#\"\n+static mut STATIC_MUT: u8 = 0;\n+\n+fn main() {\n+    let x = &&STATIC_MUT$0;\n+}\n+\"#,\n+            r#\"\n+static mut STATIC_MUT: u8 = 0;\n+\n+fn main() {\n+    let x = unsafe { &&STATIC_MUT };\n }\n \"#,\n         )"}]}