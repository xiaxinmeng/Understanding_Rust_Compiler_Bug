{"sha": "0b4ba734cbd6758948cb18210437b4768e139fa9", "node_id": "C_kwDOAAsO6NoAKDBiNGJhNzM0Y2JkNjc1ODk0OGNiMTgyMTA0MzdiNDc2OGUxMzlmYTk", "commit": {"author": {"name": "Jason Newcomb", "email": "jsnewcomb@pm.me", "date": "2022-01-29T23:06:14Z"}, "committer": {"name": "Jason Newcomb", "email": "jsnewcomb@pm.me", "date": "2022-06-28T16:48:26Z"}, "message": "Refactor `dereference.rs`\n\nMerge `Position` and `AutoDerefStability`", "tree": {"sha": "9bc02b770ff36069e67263306f6b4cd0e4b3668f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9bc02b770ff36069e67263306f6b4cd0e4b3668f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0b4ba734cbd6758948cb18210437b4768e139fa9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0b4ba734cbd6758948cb18210437b4768e139fa9", "html_url": "https://github.com/rust-lang/rust/commit/0b4ba734cbd6758948cb18210437b4768e139fa9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0b4ba734cbd6758948cb18210437b4768e139fa9/comments", "author": {"login": "Jarcho", "id": 7761774, "node_id": "MDQ6VXNlcjc3NjE3NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7761774?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Jarcho", "html_url": "https://github.com/Jarcho", "followers_url": "https://api.github.com/users/Jarcho/followers", "following_url": "https://api.github.com/users/Jarcho/following{/other_user}", "gists_url": "https://api.github.com/users/Jarcho/gists{/gist_id}", "starred_url": "https://api.github.com/users/Jarcho/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Jarcho/subscriptions", "organizations_url": "https://api.github.com/users/Jarcho/orgs", "repos_url": "https://api.github.com/users/Jarcho/repos", "events_url": "https://api.github.com/users/Jarcho/events{/privacy}", "received_events_url": "https://api.github.com/users/Jarcho/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Jarcho", "id": 7761774, "node_id": "MDQ6VXNlcjc3NjE3NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7761774?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Jarcho", "html_url": "https://github.com/Jarcho", "followers_url": "https://api.github.com/users/Jarcho/followers", "following_url": "https://api.github.com/users/Jarcho/following{/other_user}", "gists_url": "https://api.github.com/users/Jarcho/gists{/gist_id}", "starred_url": "https://api.github.com/users/Jarcho/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Jarcho/subscriptions", "organizations_url": "https://api.github.com/users/Jarcho/orgs", "repos_url": "https://api.github.com/users/Jarcho/repos", "events_url": "https://api.github.com/users/Jarcho/events{/privacy}", "received_events_url": "https://api.github.com/users/Jarcho/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0204b9535731cbaba1689b6d6ef44a93aef2dae3", "url": "https://api.github.com/repos/rust-lang/rust/commits/0204b9535731cbaba1689b6d6ef44a93aef2dae3", "html_url": "https://github.com/rust-lang/rust/commit/0204b9535731cbaba1689b6d6ef44a93aef2dae3"}], "stats": {"total": 242, "additions": 119, "deletions": 123}, "files": [{"sha": "3821beaea53b0469161c4607d7120285643e0081", "filename": "clippy_lints/src/dereference.rs", "status": "modified", "additions": 83, "deletions": 89, "changes": 172, "blob_url": "https://github.com/rust-lang/rust/blob/0b4ba734cbd6758948cb18210437b4768e139fa9/clippy_lints%2Fsrc%2Fdereference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b4ba734cbd6758948cb18210437b4768e139fa9/clippy_lints%2Fsrc%2Fdereference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdereference.rs?ref=0b4ba734cbd6758948cb18210437b4768e139fa9", "patch": "@@ -2,7 +2,7 @@ use clippy_utils::diagnostics::{span_lint_and_sugg, span_lint_hir_and_then};\n use clippy_utils::source::{snippet_with_applicability, snippet_with_context};\n use clippy_utils::sugg::has_enclosing_paren;\n use clippy_utils::ty::{expr_sig, peel_mid_ty_refs, variant_of_res};\n-use clippy_utils::{get_parent_expr, get_parent_node, is_lint_allowed, path_to_local, walk_to_expr_usage};\n+use clippy_utils::{get_parent_expr, is_lint_allowed, path_to_local, walk_to_expr_usage};\n use rustc_ast::util::parser::{PREC_POSTFIX, PREC_PREFIX};\n use rustc_data_structures::fx::FxIndexMap;\n use rustc_errors::Applicability;\n@@ -15,7 +15,7 @@ use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::ty::adjustment::{Adjust, Adjustment, AutoBorrow, AutoBorrowMutability};\n use rustc_middle::ty::{self, Ty, TyCtxt, TypeFoldable, TypeckResults};\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n-use rustc_span::{symbol::sym, Span, Symbol, SyntaxContext};\n+use rustc_span::{symbol::sym, Span, Symbol};\n \n declare_clippy_lint! {\n     /// ### What it does\n@@ -167,7 +167,6 @@ struct DerefedBorrow {\n     count: usize,\n     required_precedence: i8,\n     msg: &'static str,\n-    stability: AutoDerefStability,\n     position: Position,\n }\n \n@@ -249,8 +248,7 @@ impl<'tcx> LateLintPass<'tcx> for Dereferencing {\n         match (self.state.take(), kind) {\n             (None, kind) => {\n                 let expr_ty = typeck.expr_ty(expr);\n-                let (position, parent_ctxt) = get_expr_position(cx, expr);\n-                let (stability, adjustments) = walk_parents(cx, expr);\n+                let (position, adjustments) = walk_parents(cx, expr);\n \n                 match kind {\n                     RefOp::Deref => {\n@@ -261,7 +259,7 @@ impl<'tcx> LateLintPass<'tcx> for Dereferencing {\n                                 State::ExplicitDerefField { name },\n                                 StateData { span: expr.span, hir_id: expr.hir_id },\n                             ));\n-                        } else if stability.is_deref_stable() {\n+                        } else if position.is_deref_stable() {\n                             self.state = Some((\n                                 State::ExplicitDeref { deref_span: expr.span, deref_hir_id: expr.hir_id },\n                                 StateData { span: expr.span, hir_id: expr.hir_id },\n@@ -270,7 +268,7 @@ impl<'tcx> LateLintPass<'tcx> for Dereferencing {\n                     }\n                     RefOp::Method(target_mut)\n                         if !is_lint_allowed(cx, EXPLICIT_DEREF_METHODS, expr.hir_id)\n-                            && (position.lint_explicit_deref() || parent_ctxt != expr.span.ctxt()) =>\n+                            && position.lint_explicit_deref() =>\n                     {\n                         self.state = Some((\n                             State::DerefMethod {\n@@ -336,7 +334,7 @@ impl<'tcx> LateLintPass<'tcx> for Dereferencing {\n                         } else if let Some(&Adjust::Borrow(AutoBorrow::Ref(_, mutability))) =\n                             next_adjust.map(|a| &a.kind)\n                         {\n-                            if matches!(mutability, AutoBorrowMutability::Mut { .. }) && !stability.is_reborrow_stable()\n+                            if matches!(mutability, AutoBorrowMutability::Mut { .. }) && !position.is_reborrow_stable()\n                             {\n                                 (3, 0, deref_msg)\n                             } else {\n@@ -354,12 +352,11 @@ impl<'tcx> LateLintPass<'tcx> for Dereferencing {\n                                     count: deref_count - required_refs,\n                                     required_precedence,\n                                     msg,\n-                                    stability,\n                                     position,\n                                 }),\n                                 StateData { span: expr.span, hir_id: expr.hir_id },\n                             ));\n-                        } else if stability.is_deref_stable() {\n+                        } else if position.is_deref_stable() {\n                             self.state = Some((\n                                 State::Borrow,\n                                 StateData {\n@@ -406,9 +403,9 @@ impl<'tcx> LateLintPass<'tcx> for Dereferencing {\n                 ));\n             },\n             (Some((State::DerefedBorrow(state), data)), RefOp::AddrOf) => {\n-                let stability = state.stability;\n+                let position = state.position;\n                 report(cx, expr, State::DerefedBorrow(state), data);\n-                if stability.is_deref_stable() {\n+                if position.is_deref_stable() {\n                     self.state = Some((\n                         State::Borrow,\n                         StateData {\n@@ -419,7 +416,6 @@ impl<'tcx> LateLintPass<'tcx> for Dereferencing {\n                 }\n             },\n             (Some((State::DerefedBorrow(state), data)), RefOp::Deref) => {\n-                let stability = state.stability;\n                 let position = state.position;\n                 report(cx, expr, State::DerefedBorrow(state), data);\n                 if let Position::FieldAccess(name) = position\n@@ -429,7 +425,7 @@ impl<'tcx> LateLintPass<'tcx> for Dereferencing {\n                         State::ExplicitDerefField { name },\n                         StateData { span: expr.span, hir_id: expr.hir_id },\n                     ));\n-                } else if stability.is_deref_stable() {\n+                } else if position.is_deref_stable() {\n                     self.state = Some((\n                         State::ExplicitDeref { deref_span: expr.span, deref_hir_id: expr.hir_id },\n                         StateData { span: expr.span, hir_id: expr.hir_id },\n@@ -601,140 +597,124 @@ fn deref_method_same_type<'tcx>(result_ty: Ty<'tcx>, arg_ty: Ty<'tcx>) -> bool {\n     }\n }\n \n+/// The position of an expression relative to it's parent.\n #[derive(Clone, Copy)]\n enum Position {\n     MethodReceiver,\n-    FieldAccess(Symbol),\n     Callee,\n+    FieldAccess(Symbol),\n     Postfix,\n     Deref,\n+    /// Any other location which will trigger auto-deref to a specific time.\n+    DerefStable,\n+    /// Any other location which will trigger auto-reborrowing.\n+    ReborrowStable,\n     Other,\n }\n impl Position {\n-    fn can_auto_borrow(self) -> bool {\n-        matches!(self, Self::MethodReceiver | Self::FieldAccess(_) | Self::Callee)\n-    }\n-\n-    fn lint_explicit_deref(self) -> bool {\n-        matches!(self, Self::Other)\n+    fn is_deref_stable(self) -> bool {\n+        matches!(self, Self::DerefStable)\n     }\n-}\n \n-/// Get which position an expression is in relative to it's parent.\n-fn get_expr_position(cx: &LateContext<'_>, e: &Expr<'_>) -> (Position, SyntaxContext) {\n-    if let Some(Node::Expr(parent)) = get_parent_node(cx.tcx, e.hir_id) {\n-        let pos = match parent.kind {\n-            ExprKind::MethodCall(_, [self_arg, ..], _) if self_arg.hir_id == e.hir_id => Position::MethodReceiver,\n-            ExprKind::Field(_, name) => Position::FieldAccess(name.name),\n-            ExprKind::Call(f, _) if f.hir_id == e.hir_id => Position::Callee,\n-            ExprKind::Unary(UnOp::Deref, _) => Position::Deref,\n-            ExprKind::Match(_, _, MatchSource::TryDesugar | MatchSource::AwaitDesugar) | ExprKind::Index(..) => {\n-                Position::Postfix\n-            },\n-            _ => Position::Other,\n-        };\n-        (pos, parent.span.ctxt())\n-    } else {\n-        (Position::Other, SyntaxContext::root())\n+    fn is_reborrow_stable(self) -> bool {\n+        matches!(self, Self::DerefStable | Self::ReborrowStable)\n     }\n-}\n \n-/// How stable the result of auto-deref is.\n-#[derive(Clone, Copy)]\n-enum AutoDerefStability {\n-    /// Auto-deref will always choose the same type.\n-    Deref,\n-    /// Auto-deref will always reborrow a reference.\n-    Reborrow,\n-    /// Auto-deref will not occur, or it may select a different type.\n-    None,\n-}\n-impl AutoDerefStability {\n-    fn is_deref_stable(self) -> bool {\n-        matches!(self, Self::Deref)\n+    fn can_auto_borrow(self) -> bool {\n+        matches!(self, Self::MethodReceiver | Self::FieldAccess(_) | Self::Callee)\n     }\n \n-    fn is_reborrow_stable(self) -> bool {\n-        matches!(self, Self::Deref | Self::Reborrow)\n+    fn lint_explicit_deref(self) -> bool {\n+        matches!(self, Self::Other | Self::DerefStable | Self::ReborrowStable)\n     }\n }\n \n /// Walks up the parent expressions attempting to determine both how stable the auto-deref result\n /// is, and which adjustments will be applied to it. Note this will not consider auto-borrow\n /// locations as those follow different rules.\n #[allow(clippy::too_many_lines)]\n-fn walk_parents<'tcx>(cx: &LateContext<'tcx>, e: &'tcx Expr<'_>) -> (AutoDerefStability, &'tcx [Adjustment<'tcx>]) {\n+fn walk_parents<'tcx>(cx: &LateContext<'tcx>, e: &'tcx Expr<'_>) -> (Position, &'tcx [Adjustment<'tcx>]) {\n     let mut adjustments = [].as_slice();\n-    let stability = walk_to_expr_usage(cx, e, &mut |node, child_id| {\n+    let ctxt = e.span.ctxt();\n+    let position = walk_to_expr_usage(cx, e, &mut |parent, child_id| {\n         // LocalTableInContext returns the wrong lifetime, so go use `expr_adjustments` instead.\n         if adjustments.is_empty() && let Node::Expr(e) = cx.tcx.hir().get(child_id) {\n             adjustments = cx.typeck_results().expr_adjustments(e);\n         }\n-        match node {\n-            Node::Local(Local { ty: Some(ty), .. }) => Some(binding_ty_auto_deref_stability(ty)),\n+        match parent {\n+            Node::Local(Local { ty: Some(ty), span, .. }) if span.ctxt() == ctxt => {\n+                Some(binding_ty_auto_deref_stability(ty))\n+            },\n             Node::Item(&Item {\n                 kind: ItemKind::Static(..) | ItemKind::Const(..),\n                 def_id,\n+                span,\n                 ..\n             })\n             | Node::TraitItem(&TraitItem {\n                 kind: TraitItemKind::Const(..),\n                 def_id,\n+                span,\n                 ..\n             })\n             | Node::ImplItem(&ImplItem {\n                 kind: ImplItemKind::Const(..),\n                 def_id,\n+                span,\n                 ..\n-            }) => {\n+            }) if span.ctxt() == ctxt => {\n                 let ty = cx.tcx.type_of(def_id);\n                 Some(if ty.is_ref() {\n-                    AutoDerefStability::None\n+                    Position::Other\n                 } else {\n-                    AutoDerefStability::Deref\n+                    Position::DerefStable\n                 })\n             },\n \n             Node::Item(&Item {\n                 kind: ItemKind::Fn(..),\n                 def_id,\n+                span,\n                 ..\n             })\n             | Node::TraitItem(&TraitItem {\n                 kind: TraitItemKind::Fn(..),\n                 def_id,\n+                span,\n                 ..\n             })\n             | Node::ImplItem(&ImplItem {\n                 kind: ImplItemKind::Fn(..),\n                 def_id,\n+                span,\n                 ..\n-            }) => {\n+            }) if span.ctxt() == ctxt => {\n                 let output = cx.tcx.fn_sig(def_id.to_def_id()).skip_binder().output();\n                 Some(if !output.is_ref() {\n-                    AutoDerefStability::None\n+                    Position::Other\n                 } else if output.has_placeholders() || output.has_opaque_types() {\n-                    AutoDerefStability::Reborrow\n+                    Position::ReborrowStable\n                 } else {\n-                    AutoDerefStability::Deref\n+                    Position::DerefStable\n                 })\n             },\n \n-            Node::Expr(e) => match e.kind {\n+            Node::Expr(parent) if parent.span.ctxt() == ctxt => match parent.kind {\n                 ExprKind::Ret(_) => {\n                     let output = cx\n                         .tcx\n                         .fn_sig(cx.tcx.hir().body_owner_def_id(cx.enclosing_body.unwrap()))\n                         .skip_binder()\n                         .output();\n                     Some(if !output.is_ref() {\n-                        AutoDerefStability::None\n+                        Position::Other\n                     } else if output.has_placeholders() || output.has_opaque_types() {\n-                        AutoDerefStability::Reborrow\n+                        Position::ReborrowStable\n                     } else {\n-                        AutoDerefStability::Deref\n+                        Position::DerefStable\n                     })\n                 },\n+                ExprKind::Call(func, _) if func.hir_id == child_id => (child_id == e.hir_id).then(|| Position::Callee),\n                 ExprKind::Call(func, args) => args\n                     .iter()\n                     .position(|arg| arg.hir_id == child_id)\n@@ -746,30 +726,44 @@ fn walk_parents<'tcx>(cx: &LateContext<'tcx>, e: &'tcx Expr<'_>) -> (AutoDerefSt\n                         Some(ty) => binding_ty_auto_deref_stability(ty),\n                         None => param_auto_deref_stability(ty.skip_binder()),\n                     }),\n-                ExprKind::MethodCall(_, [_, args @ ..], _) => {\n-                    let id = cx.typeck_results().type_dependent_def_id(e.hir_id).unwrap();\n+                ExprKind::MethodCall(_, args, _) => {\n+                    let id = cx.typeck_results().type_dependent_def_id(parent.hir_id).unwrap();\n                     args.iter().position(|arg| arg.hir_id == child_id).map(|i| {\n-                        let arg = cx.tcx.fn_sig(id).skip_binder().inputs()[i + 1];\n-                        param_auto_deref_stability(arg)\n+                        if i == 0 {\n+                            if e.hir_id == child_id {\n+                                Position::MethodReceiver\n+                            } else {\n+                                Position::ReborrowStable\n+                            }\n+                        } else {\n+                            param_auto_deref_stability(cx.tcx.fn_sig(id).skip_binder().inputs()[i])\n+                        }\n                     })\n                 },\n-                ExprKind::MethodCall(..) => Some(AutoDerefStability::Reborrow),\n                 ExprKind::Struct(path, fields, _) => {\n-                    let variant = variant_of_res(cx, cx.qpath_res(path, e.hir_id));\n+                    let variant = variant_of_res(cx, cx.qpath_res(path, parent.hir_id));\n                     fields\n                         .iter()\n                         .find(|f| f.expr.hir_id == child_id)\n                         .zip(variant)\n                         .and_then(|(field, variant)| variant.fields.iter().find(|f| f.name == field.ident.name))\n                         .map(|field| param_auto_deref_stability(cx.tcx.type_of(field.did)))\n                 },\n+                ExprKind::Field(child, name) if child.hir_id == e.hir_id => Some(Position::FieldAccess(name.name)),\n+                ExprKind::Unary(UnOp::Deref, child) if child.hir_id == e.hir_id => Some(Position::Deref),\n+                ExprKind::Match(child, _, MatchSource::TryDesugar | MatchSource::AwaitDesugar)\n+                | ExprKind::Index(child, _)\n+                    if child.hir_id == e.hir_id =>\n+                {\n+                    Some(Position::Postfix)\n+                },\n                 _ => None,\n             },\n             _ => None,\n         }\n     })\n-    .unwrap_or(AutoDerefStability::None);\n-    (stability, adjustments)\n+    .unwrap_or(Position::Other);\n+    (position, adjustments)\n }\n \n // Checks the stability of auto-deref when assigned to a binding with the given explicit type.\n@@ -781,9 +775,9 @@ fn walk_parents<'tcx>(cx: &LateContext<'tcx>, e: &'tcx Expr<'_>) -> (AutoDerefSt\n //\n // Here `y1` and `y2` would resolve to different types, so the type `&Box<_>` is not stable when\n // switching to auto-dereferencing.\n-fn binding_ty_auto_deref_stability(ty: &hir::Ty<'_>) -> AutoDerefStability {\n+fn binding_ty_auto_deref_stability(ty: &hir::Ty<'_>) -> Position {\n     let TyKind::Rptr(_, ty) = &ty.kind else {\n-        return AutoDerefStability::None;\n+        return Position::Other;\n     };\n     let mut ty = ty;\n \n@@ -809,9 +803,9 @@ fn binding_ty_auto_deref_stability(ty: &hir::Ty<'_>) -> AutoDerefStability {\n                         _ => false,\n                     })\n                 {\n-                    AutoDerefStability::Reborrow\n+                    Position::ReborrowStable\n                 } else {\n-                    AutoDerefStability::Deref\n+                    Position::DerefStable\n                 }\n             },\n             TyKind::Slice(_)\n@@ -821,8 +815,8 @@ fn binding_ty_auto_deref_stability(ty: &hir::Ty<'_>) -> AutoDerefStability {\n             | TyKind::Tup(_)\n             | TyKind::Ptr(_)\n             | TyKind::TraitObject(..)\n-            | TyKind::Path(_) => AutoDerefStability::Deref,\n-            TyKind::OpaqueDef(..) | TyKind::Infer | TyKind::Typeof(..) | TyKind::Err => AutoDerefStability::Reborrow,\n+            | TyKind::Path(_) => Position::DerefStable,\n+            TyKind::OpaqueDef(..) | TyKind::Infer | TyKind::Typeof(..) | TyKind::Err => Position::ReborrowStable,\n         };\n     }\n }\n@@ -865,9 +859,9 @@ fn ty_contains_infer(ty: &hir::Ty<'_>) -> bool {\n }\n \n // Checks whether a type is stable when switching to auto dereferencing,\n-fn param_auto_deref_stability(ty: Ty<'_>) -> AutoDerefStability {\n+fn param_auto_deref_stability(ty: Ty<'_>) -> Position {\n     let ty::Ref(_, mut ty, _) = *ty.kind() else {\n-        return AutoDerefStability::None;\n+        return Position::Other;\n     };\n \n     loop {\n@@ -893,16 +887,16 @@ fn param_auto_deref_stability(ty: Ty<'_>) -> AutoDerefStability {\n             | ty::GeneratorWitness(..)\n             | ty::Never\n             | ty::Tuple(_)\n-            | ty::Projection(_) => AutoDerefStability::Deref,\n+            | ty::Projection(_) => Position::DerefStable,\n             ty::Infer(_)\n             | ty::Error(_)\n             | ty::Param(_)\n             | ty::Bound(..)\n             | ty::Opaque(..)\n             | ty::Placeholder(_)\n-            | ty::Dynamic(..) => AutoDerefStability::Reborrow,\n-            ty::Adt(..) if ty.has_placeholders() || ty.has_param_types_or_consts() => AutoDerefStability::Reborrow,\n-            ty::Adt(..) => AutoDerefStability::Deref,\n+            | ty::Dynamic(..) => Position::ReborrowStable,\n+            ty::Adt(..) if ty.has_placeholders() || ty.has_param_types_or_consts() => Position::ReborrowStable,\n+            ty::Adt(..) => Position::DerefStable,\n         };\n     }\n }"}, {"sha": "d4a9aa7e46c701acabd264e2f2b6ffc5e2f609eb", "filename": "tests/ui/explicit_auto_deref.fixed", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0b4ba734cbd6758948cb18210437b4768e139fa9/tests%2Fui%2Fexplicit_auto_deref.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/0b4ba734cbd6758948cb18210437b4768e139fa9/tests%2Fui%2Fexplicit_auto_deref.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fexplicit_auto_deref.fixed?ref=0b4ba734cbd6758948cb18210437b4768e139fa9", "patch": "@@ -10,7 +10,8 @@\n     clippy::ptr_arg,\n     clippy::redundant_field_names,\n     clippy::too_many_arguments,\n-    clippy::borrow_deref_ref\n+    clippy::borrow_deref_ref,\n+    clippy::let_unit_value\n )]\n \n trait CallableStr {"}, {"sha": "243b8e919c6a5303bbd0ca37be9cf46ee786fe39", "filename": "tests/ui/explicit_auto_deref.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0b4ba734cbd6758948cb18210437b4768e139fa9/tests%2Fui%2Fexplicit_auto_deref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b4ba734cbd6758948cb18210437b4768e139fa9/tests%2Fui%2Fexplicit_auto_deref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fexplicit_auto_deref.rs?ref=0b4ba734cbd6758948cb18210437b4768e139fa9", "patch": "@@ -10,7 +10,8 @@\n     clippy::ptr_arg,\n     clippy::redundant_field_names,\n     clippy::too_many_arguments,\n-    clippy::borrow_deref_ref\n+    clippy::borrow_deref_ref,\n+    clippy::let_unit_value\n )]\n \n trait CallableStr {"}, {"sha": "19435eab96b7c9fed55adafa0e0bf475c9e69078", "filename": "tests/ui/explicit_auto_deref.stderr", "status": "modified", "additions": 32, "deletions": 32, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/0b4ba734cbd6758948cb18210437b4768e139fa9/tests%2Fui%2Fexplicit_auto_deref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0b4ba734cbd6758948cb18210437b4768e139fa9/tests%2Fui%2Fexplicit_auto_deref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fexplicit_auto_deref.stderr?ref=0b4ba734cbd6758948cb18210437b4768e139fa9", "patch": "@@ -1,193 +1,193 @@\n error: deref which would be done by auto-deref\n-  --> $DIR/explicit_auto_deref.rs:63:20\n+  --> $DIR/explicit_auto_deref.rs:65:20\n    |\n LL |     let _: &str = &*s;\n    |                    ^^ help: try this: `s`\n    |\n    = note: `-D clippy::explicit-auto-deref` implied by `-D warnings`\n \n error: deref which would be done by auto-deref\n-  --> $DIR/explicit_auto_deref.rs:67:12\n+  --> $DIR/explicit_auto_deref.rs:69:12\n    |\n LL |     f_str(&*s);\n    |            ^^ help: try this: `s`\n \n error: deref which would be done by auto-deref\n-  --> $DIR/explicit_auto_deref.rs:71:14\n+  --> $DIR/explicit_auto_deref.rs:73:14\n    |\n LL |     f_str_t(&*s, &*s); // Don't lint second param.\n    |              ^^ help: try this: `s`\n \n error: deref which would be done by auto-deref\n-  --> $DIR/explicit_auto_deref.rs:74:25\n+  --> $DIR/explicit_auto_deref.rs:76:25\n    |\n LL |     let _: &Box<i32> = &**b;\n    |                         ^^^ help: try this: `b`\n \n error: deref which would be done by auto-deref\n-  --> $DIR/explicit_auto_deref.rs:80:8\n+  --> $DIR/explicit_auto_deref.rs:82:8\n    |\n LL |     c(&*s);\n    |        ^^ help: try this: `s`\n \n error: deref which would be done by auto-deref\n-  --> $DIR/explicit_auto_deref.rs:86:9\n+  --> $DIR/explicit_auto_deref.rs:88:9\n    |\n LL |         &**x\n    |         ^^^^ help: try this: `x`\n \n error: deref which would be done by auto-deref\n-  --> $DIR/explicit_auto_deref.rs:90:11\n+  --> $DIR/explicit_auto_deref.rs:92:11\n    |\n LL |         { &**x }\n    |           ^^^^ help: try this: `x`\n \n error: deref which would be done by auto-deref\n-  --> $DIR/explicit_auto_deref.rs:94:9\n+  --> $DIR/explicit_auto_deref.rs:96:9\n    |\n LL |         &**{ x }\n    |         ^^^^^^^^ help: try this: `{ x }`\n \n error: deref which would be done by auto-deref\n-  --> $DIR/explicit_auto_deref.rs:98:9\n+  --> $DIR/explicit_auto_deref.rs:100:9\n    |\n LL |         &***x\n    |         ^^^^^ help: try this: `x`\n \n error: deref which would be done by auto-deref\n-  --> $DIR/explicit_auto_deref.rs:115:13\n+  --> $DIR/explicit_auto_deref.rs:117:13\n    |\n LL |         f1(&*x);\n    |             ^^ help: try this: `x`\n \n error: deref which would be done by auto-deref\n-  --> $DIR/explicit_auto_deref.rs:116:13\n+  --> $DIR/explicit_auto_deref.rs:118:13\n    |\n LL |         f2(&*x);\n    |             ^^ help: try this: `x`\n \n error: deref which would be done by auto-deref\n-  --> $DIR/explicit_auto_deref.rs:117:13\n+  --> $DIR/explicit_auto_deref.rs:119:13\n    |\n LL |         f3(&*x);\n    |             ^^ help: try this: `x`\n \n error: deref which would be done by auto-deref\n-  --> $DIR/explicit_auto_deref.rs:118:28\n+  --> $DIR/explicit_auto_deref.rs:120:28\n    |\n LL |         f4.callable_str()(&*x);\n    |                            ^^ help: try this: `x`\n \n error: deref which would be done by auto-deref\n-  --> $DIR/explicit_auto_deref.rs:119:13\n+  --> $DIR/explicit_auto_deref.rs:121:13\n    |\n LL |         f5(&*x);\n    |             ^^ help: try this: `x`\n \n error: deref which would be done by auto-deref\n-  --> $DIR/explicit_auto_deref.rs:120:13\n+  --> $DIR/explicit_auto_deref.rs:122:13\n    |\n LL |         f6(&*x);\n    |             ^^ help: try this: `x`\n \n error: deref which would be done by auto-deref\n-  --> $DIR/explicit_auto_deref.rs:121:28\n+  --> $DIR/explicit_auto_deref.rs:123:28\n    |\n LL |         f7.callable_str()(&*x);\n    |                            ^^ help: try this: `x`\n \n error: deref which would be done by auto-deref\n-  --> $DIR/explicit_auto_deref.rs:122:26\n+  --> $DIR/explicit_auto_deref.rs:124:26\n    |\n LL |         f8.callable_t()(&*x);\n    |                          ^^ help: try this: `x`\n \n error: deref which would be done by auto-deref\n-  --> $DIR/explicit_auto_deref.rs:123:13\n+  --> $DIR/explicit_auto_deref.rs:125:13\n    |\n LL |         f9(&*x);\n    |             ^^ help: try this: `x`\n \n error: deref which would be done by auto-deref\n-  --> $DIR/explicit_auto_deref.rs:124:14\n+  --> $DIR/explicit_auto_deref.rs:126:14\n    |\n LL |         f10(&*x);\n    |              ^^ help: try this: `x`\n \n error: deref which would be done by auto-deref\n-  --> $DIR/explicit_auto_deref.rs:125:27\n+  --> $DIR/explicit_auto_deref.rs:127:27\n    |\n LL |         f11.callable_t()(&*x);\n    |                           ^^ help: try this: `x`\n \n error: deref which would be done by auto-deref\n-  --> $DIR/explicit_auto_deref.rs:129:17\n+  --> $DIR/explicit_auto_deref.rs:131:17\n    |\n LL |     let _ = S1(&*s);\n    |                 ^^ help: try this: `s`\n \n error: deref which would be done by auto-deref\n-  --> $DIR/explicit_auto_deref.rs:134:22\n+  --> $DIR/explicit_auto_deref.rs:136:22\n    |\n LL |     let _ = S2 { s: &*s };\n    |                      ^^ help: try this: `s`\n \n error: deref which would be done by auto-deref\n-  --> $DIR/explicit_auto_deref.rs:150:30\n+  --> $DIR/explicit_auto_deref.rs:152:30\n    |\n LL |             let _ = Self::S1(&**s);\n    |                              ^^^^ help: try this: `s`\n \n error: deref which would be done by auto-deref\n-  --> $DIR/explicit_auto_deref.rs:151:35\n+  --> $DIR/explicit_auto_deref.rs:153:35\n    |\n LL |             let _ = Self::S2 { s: &**s };\n    |                                   ^^^^ help: try this: `s`\n \n error: deref which would be done by auto-deref\n-  --> $DIR/explicit_auto_deref.rs:154:21\n+  --> $DIR/explicit_auto_deref.rs:156:21\n    |\n LL |     let _ = E1::S1(&*s);\n    |                     ^^ help: try this: `s`\n \n error: deref which would be done by auto-deref\n-  --> $DIR/explicit_auto_deref.rs:155:26\n+  --> $DIR/explicit_auto_deref.rs:157:26\n    |\n LL |     let _ = E1::S2 { s: &*s };\n    |                          ^^ help: try this: `s`\n \n error: deref which would be done by auto-deref\n-  --> $DIR/explicit_auto_deref.rs:173:13\n+  --> $DIR/explicit_auto_deref.rs:175:13\n    |\n LL |     let _ = (*b).foo;\n    |             ^^^^ help: try this: `b`\n \n error: deref which would be done by auto-deref\n-  --> $DIR/explicit_auto_deref.rs:174:13\n+  --> $DIR/explicit_auto_deref.rs:176:13\n    |\n LL |     let _ = (**b).foo;\n    |             ^^^^^ help: try this: `b`\n \n error: deref which would be done by auto-deref\n-  --> $DIR/explicit_auto_deref.rs:189:19\n+  --> $DIR/explicit_auto_deref.rs:191:19\n    |\n LL |     let _ = f_str(*ref_str);\n    |                   ^^^^^^^^ help: try this: `ref_str`\n \n error: deref which would be done by auto-deref\n-  --> $DIR/explicit_auto_deref.rs:191:19\n+  --> $DIR/explicit_auto_deref.rs:193:19\n    |\n LL |     let _ = f_str(**ref_ref_str);\n    |                   ^^^^^^^^^^^^^ help: try this: `ref_ref_str`\n \n error: deref which would be done by auto-deref\n-  --> $DIR/explicit_auto_deref.rs:201:13\n+  --> $DIR/explicit_auto_deref.rs:203:13\n    |\n LL |     f_str(&&*ref_str); // `needless_borrow` will suggest removing both references\n    |             ^^^^^^^^ help: try this: `ref_str`\n \n error: deref which would be done by auto-deref\n-  --> $DIR/explicit_auto_deref.rs:202:12\n+  --> $DIR/explicit_auto_deref.rs:204:12\n    |\n LL |     f_str(&&**ref_str); // `needless_borrow` will suggest removing only one reference\n    |            ^^^^^^^^^^ help: try this: `ref_str`"}]}