{"sha": "cf53fef0d6d4d5d8f6733a3d1e98e3b774342819", "node_id": "C_kwDOAAsO6NoAKGNmNTNmZWYwZDZkNGQ1ZDhmNjczM2EzZDFlOThlM2I3NzQzNDI4MTk", "commit": {"author": {"name": "Mara Bos", "email": "m-ou.se@m-ou.se", "date": "2022-09-06T21:15:13Z"}, "committer": {"name": "Mara Bos", "email": "m-ou.se@m-ou.se", "date": "2022-09-27T11:31:52Z"}, "message": "Turn format arguments Vec into its own struct.\n\nWith efficient lookup through a hash map.", "tree": {"sha": "d136fe75544d3958331708e06e3e50dd695c807d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d136fe75544d3958331708e06e3e50dd695c807d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cf53fef0d6d4d5d8f6733a3d1e98e3b774342819", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cf53fef0d6d4d5d8f6733a3d1e98e3b774342819", "html_url": "https://github.com/rust-lang/rust/commit/cf53fef0d6d4d5d8f6733a3d1e98e3b774342819", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cf53fef0d6d4d5d8f6733a3d1e98e3b774342819/comments", "author": {"login": "m-ou-se", "id": 783247, "node_id": "MDQ6VXNlcjc4MzI0Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/783247?v=4", "gravatar_id": "", "url": "https://api.github.com/users/m-ou-se", "html_url": "https://github.com/m-ou-se", "followers_url": "https://api.github.com/users/m-ou-se/followers", "following_url": "https://api.github.com/users/m-ou-se/following{/other_user}", "gists_url": "https://api.github.com/users/m-ou-se/gists{/gist_id}", "starred_url": "https://api.github.com/users/m-ou-se/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/m-ou-se/subscriptions", "organizations_url": "https://api.github.com/users/m-ou-se/orgs", "repos_url": "https://api.github.com/users/m-ou-se/repos", "events_url": "https://api.github.com/users/m-ou-se/events{/privacy}", "received_events_url": "https://api.github.com/users/m-ou-se/received_events", "type": "User", "site_admin": false}, "committer": {"login": "m-ou-se", "id": 783247, "node_id": "MDQ6VXNlcjc4MzI0Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/783247?v=4", "gravatar_id": "", "url": "https://api.github.com/users/m-ou-se", "html_url": "https://github.com/m-ou-se", "followers_url": "https://api.github.com/users/m-ou-se/followers", "following_url": "https://api.github.com/users/m-ou-se/following{/other_user}", "gists_url": "https://api.github.com/users/m-ou-se/gists{/gist_id}", "starred_url": "https://api.github.com/users/m-ou-se/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/m-ou-se/subscriptions", "organizations_url": "https://api.github.com/users/m-ou-se/orgs", "repos_url": "https://api.github.com/users/m-ou-se/repos", "events_url": "https://api.github.com/users/m-ou-se/events{/privacy}", "received_events_url": "https://api.github.com/users/m-ou-se/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "14065639ca9ebf29ae6563f81920d443c26fd1fb", "url": "https://api.github.com/repos/rust-lang/rust/commits/14065639ca9ebf29ae6563f81920d443c26fd1fb", "html_url": "https://github.com/rust-lang/rust/commit/14065639ca9ebf29ae6563f81920d443c26fd1fb"}], "stats": {"total": 230, "additions": 146, "deletions": 84}, "files": [{"sha": "d3e8d854c7d340e043833b4c85cdb8264fe99f4f", "filename": "compiler/rustc_builtin_macros/src/format.rs", "status": "modified", "additions": 48, "deletions": 71, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/cf53fef0d6d4d5d8f6733a3d1e98e3b774342819/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf53fef0d6d4d5d8f6733a3d1e98e3b774342819/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat.rs?ref=cf53fef0d6d4d5d8f6733a3d1e98e3b774342819", "patch": "@@ -45,14 +45,14 @@ use PositionUsedAs::*;\n /// If parsing succeeds, the return value is:\n ///\n /// ```text\n-/// Some((fmtstr, parsed arguments))\n+/// Ok((fmtstr, parsed arguments))\n /// ```\n fn parse_args<'a>(\n     ecx: &mut ExtCtxt<'a>,\n     sp: Span,\n     tts: TokenStream,\n-) -> PResult<'a, (P<Expr>, Vec<(P<Expr>, FormatArgKind)>)> {\n-    let mut args = Vec::<(P<Expr>, FormatArgKind)>::new();\n+) -> PResult<'a, (P<Expr>, FormatArguments)> {\n+    let mut args = FormatArguments::new();\n \n     let mut p = ecx.new_parser_from_tts(tts);\n \n@@ -81,7 +81,6 @@ fn parse_args<'a>(\n     };\n \n     let mut first = true;\n-    let mut named = false;\n \n     while p.token != token::Eof {\n         if !p.eat(&token::Comma) {\n@@ -113,40 +112,40 @@ fn parse_args<'a>(\n         } // accept trailing commas\n         match p.token.ident() {\n             Some((ident, _)) if p.look_ahead(1, |t| *t == token::Eq) => {\n-                named = true;\n                 p.bump();\n                 p.expect(&token::Eq)?;\n-                let e = p.parse_expr()?;\n-                if let Some(prev) =\n-                    args.iter().rev().map_while(|a| a.1.ident()).find(|n| n.name == ident.name)\n-                {\n+                let expr = p.parse_expr()?;\n+                if let Some((_, prev)) = args.by_name(ident.name) {\n                     ecx.struct_span_err(\n                         ident.span,\n                         &format!(\"duplicate argument named `{}`\", ident),\n                     )\n-                    .span_label(prev.span, \"previously here\")\n+                    .span_label(prev.kind.ident().unwrap().span, \"previously here\")\n                     .span_label(ident.span, \"duplicate argument\")\n                     .emit();\n                     continue;\n                 }\n-                args.push((e, FormatArgKind::Named(ident)));\n+                args.add(FormatArgument { kind: FormatArgumentKind::Named(ident), expr });\n             }\n             _ => {\n-                let e = p.parse_expr()?;\n-                if named {\n+                let expr = p.parse_expr()?;\n+                if !args.named_args().is_empty() {\n                     let mut err = ecx.struct_span_err(\n-                        e.span,\n+                        expr.span,\n                         \"positional arguments cannot follow named arguments\",\n                     );\n-                    err.span_label(e.span, \"positional arguments must be before named arguments\");\n-                    for arg in &args {\n-                        if let Some(name) = arg.1.ident() {\n-                            err.span_label(name.span.to(arg.0.span), \"named argument\");\n+                    err.span_label(\n+                        expr.span,\n+                        \"positional arguments must be before named arguments\",\n+                    );\n+                    for arg in args.named_args() {\n+                        if let Some(name) = arg.kind.ident() {\n+                            err.span_label(name.span.to(arg.expr.span), \"named argument\");\n                         }\n                     }\n                     err.emit();\n                 }\n-                args.push((e, FormatArgKind::Normal));\n+                args.add(FormatArgument { kind: FormatArgumentKind::Normal, expr });\n             }\n         }\n     }\n@@ -156,12 +155,9 @@ fn parse_args<'a>(\n pub fn make_format_args(\n     ecx: &mut ExtCtxt<'_>,\n     efmt: P<Expr>,\n-    mut args: Vec<(P<Expr>, FormatArgKind)>,\n+    mut args: FormatArguments,\n     append_newline: bool,\n ) -> Result<FormatArgs, ()> {\n-    let start_of_named_args =\n-        args.iter().position(|arg| arg.1.ident().is_some()).unwrap_or(args.len());\n-\n     let msg = \"format argument must be a string literal\";\n     let fmt_span = efmt.span;\n     let (fmt_str, fmt_style, fmt_span) = match expr_to_spanned_string(ecx, efmt, msg) {\n@@ -172,9 +168,9 @@ pub fn make_format_args(\n         Ok(fmt) => fmt,\n         Err(err) => {\n             if let Some((mut err, suggested)) = err {\n-                let sugg_fmt = match args.len() {\n+                let sugg_fmt = match args.explicit_args().len() {\n                     0 => \"{}\".to_string(),\n-                    _ => format!(\"{}{{}}\", \"{} \".repeat(args.len())),\n+                    _ => format!(\"{}{{}}\", \"{} \".repeat(args.explicit_args().len())),\n                 };\n                 if !suggested {\n                     err.span_suggestion(\n@@ -243,14 +239,14 @@ pub fn make_format_args(\n             let captured_arg_span =\n                 fmt_span.from_inner(InnerSpan::new(err.span.start, err.span.end));\n             if let Ok(arg) = ecx.source_map().span_to_snippet(captured_arg_span) {\n-                let span = match args[..start_of_named_args].last() {\n-                    Some(arg) => arg.0.span,\n+                let span = match args.unnamed_args().last() {\n+                    Some(arg) => arg.expr.span,\n                     None => fmt_span,\n                 };\n                 e.multipart_suggestion_verbose(\n                     \"consider using a positional formatting argument instead\",\n                     vec![\n-                        (captured_arg_span, start_of_named_args.to_string()),\n+                        (captured_arg_span, args.unnamed_args().len().to_string()),\n                         (span.shrink_to_hi(), format!(\", {}\", arg)),\n                     ],\n                     Applicability::MachineApplicable,\n@@ -267,8 +263,7 @@ pub fn make_format_args(\n         })\n     };\n \n-    let num_explicit_args = args.len();\n-    let mut used = vec![false; num_explicit_args];\n+    let mut used = vec![false; args.explicit_args().len()];\n     let mut invalid_refs = Vec::new();\n     let mut numeric_refences_to_named_arg = Vec::new();\n \n@@ -285,32 +280,24 @@ pub fn make_format_args(\n      -> FormatArgPosition {\n         let index = match arg {\n             Index(index) => {\n-                match args.get(index) {\n-                    Some((_, FormatArgKind::Normal)) => {\n-                        used[index] = true;\n-                        Ok(index)\n-                    }\n-                    Some((_, FormatArgKind::Named(_))) => {\n-                        used[index] = true;\n+                if let Some(arg) = args.by_index(index) {\n+                    used[index] = true;\n+                    if arg.kind.ident().is_some() {\n+                        // This was a named argument, but it was used as a positional argument.\n                         numeric_refences_to_named_arg.push((index, span, used_as));\n-                        Ok(index)\n-                    }\n-                    Some((_, FormatArgKind::Captured(_))) | None => {\n-                        // Doesn't exist as an explicit argument.\n-                        invalid_refs.push((index, span, used_as, kind));\n-                        Err(index)\n                     }\n+                    Ok(index)\n+                } else {\n+                    // Doesn't exist as an explicit argument.\n+                    invalid_refs.push((index, span, used_as, kind));\n+                    Err(index)\n                 }\n             }\n             Name(name, span) => {\n                 let name = Symbol::intern(name);\n-                if let Some(i) = args[start_of_named_args..]\n-                    .iter()\n-                    .position(|arg| arg.1.ident().is_some_and(|id| id.name == name))\n-                {\n-                    // Name found in `args`, so we resolve it to its index in that Vec.\n-                    let index = start_of_named_args + i;\n-                    if !matches!(args[index].1, FormatArgKind::Captured(_)) {\n+                if let Some((index, _)) = args.by_name(name) {\n+                    // Name found in `args`, so we resolve it to its index.\n+                    if index < args.explicit_args().len() {\n                         // Mark it as used, if it was an explicit argument.\n                         used[index] = true;\n                     }\n@@ -319,7 +306,7 @@ pub fn make_format_args(\n                     // Name not found in `args`, so we add it as an implicitly captured argument.\n                     let span = span.unwrap_or(fmt_span);\n                     let ident = Ident::new(name, span);\n-                    let arg = if is_literal {\n+                    let expr = if is_literal {\n                         ecx.expr_ident(span, ident)\n                     } else {\n                         // For the moment capturing variables from format strings expanded from macros is\n@@ -330,8 +317,7 @@ pub fn make_format_args(\n                             .emit();\n                         DummyResult::raw_expr(span, true)\n                     };\n-                    args.push((arg, FormatArgKind::Captured(ident)));\n-                    Ok(args.len() - 1)\n+                    Ok(args.add(FormatArgument { kind: FormatArgumentKind::Captured(ident), expr }))\n                 }\n             }\n         };\n@@ -466,35 +452,27 @@ pub fn make_format_args(\n     }\n \n     if !invalid_refs.is_empty() {\n-        report_invalid_references(\n-            ecx,\n-            &invalid_refs,\n-            &template,\n-            fmt_span,\n-            num_explicit_args,\n-            &args,\n-            parser,\n-        );\n+        report_invalid_references(ecx, &invalid_refs, &template, fmt_span, &args, parser);\n     }\n \n     let unused = used\n         .iter()\n         .enumerate()\n         .filter(|&(_, used)| !used)\n         .map(|(i, _)| {\n-            let msg = if let FormatArgKind::Named(_) = args[i].1 {\n+            let msg = if let FormatArgumentKind::Named(_) = args.explicit_args()[i].kind {\n                 \"named argument never used\"\n             } else {\n                 \"argument never used\"\n             };\n-            (args[i].0.span, msg)\n+            (args.explicit_args()[i].expr.span, msg)\n         })\n         .collect::<Vec<_>>();\n \n     if !unused.is_empty() {\n         // If there's a lot of unused arguments,\n         // let's check if this format arguments looks like another syntax (printf / shell).\n-        let detect_foreign_fmt = unused.len() > num_explicit_args / 2;\n+        let detect_foreign_fmt = unused.len() > args.explicit_args().len() / 2;\n         report_missing_placeholders(ecx, unused, detect_foreign_fmt, str_style, fmt_str, fmt_span);\n     }\n \n@@ -511,7 +489,7 @@ pub fn make_format_args(\n                 }\n                 Width => (span, span),\n             };\n-            let arg_name = args[index].1.ident().unwrap();\n+            let arg_name = args.explicit_args()[index].kind.ident().unwrap();\n             ecx.buffered_early_lint.push(BufferedEarlyLint {\n                 span: arg_name.span.into(),\n                 msg: format!(\"named argument `{}` is not used by name\", arg_name.name).into(),\n@@ -695,11 +673,10 @@ fn report_invalid_references(\n     invalid_refs: &[(usize, Option<Span>, PositionUsedAs, FormatArgPositionKind)],\n     template: &[FormatArgsPiece],\n     fmt_span: Span,\n-    num_explicit_args: usize,\n-    args: &[(P<Expr>, FormatArgKind)],\n+    args: &FormatArguments,\n     parser: parse::Parser<'_>,\n ) {\n-    let num_args_desc = match num_explicit_args {\n+    let num_args_desc = match args.explicit_args().len() {\n         0 => \"no arguments were given\".to_string(),\n         1 => \"there is 1 argument\".to_string(),\n         n => format!(\"there are {} arguments\", n),\n@@ -785,8 +762,8 @@ fn report_invalid_references(\n                 num_args_desc,\n             ),\n         );\n-        for (arg, _) in &args[..num_explicit_args] {\n-            e.span_label(arg.span, \"\");\n+        for arg in args.explicit_args() {\n+            e.span_label(arg.expr.span, \"\");\n         }\n         // Point out `{:.*}` placeholders: those take an extra argument.\n         let mut has_precision_star = false;"}, {"sha": "139645248a1dfe29bffae8a61f181e8ecbc4c57a", "filename": "compiler/rustc_builtin_macros/src/format/ast.rs", "status": "modified", "additions": 84, "deletions": 3, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/cf53fef0d6d4d5d8f6733a3d1e98e3b774342819/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf53fef0d6d4d5d8f6733a3d1e98e3b774342819/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat%2Fast.rs?ref=cf53fef0d6d4d5d8f6733a3d1e98e3b774342819", "patch": "@@ -1,5 +1,6 @@\n use rustc_ast::ptr::P;\n use rustc_ast::Expr;\n+use rustc_data_structures::fx::FxHashMap;\n use rustc_span::symbol::{Ident, Symbol};\n use rustc_span::Span;\n \n@@ -42,17 +43,97 @@ use rustc_span::Span;\n pub struct FormatArgs {\n     pub span: Span,\n     pub template: Vec<FormatArgsPiece>,\n-    pub arguments: Vec<(P<Expr>, FormatArgKind)>,\n+    pub arguments: FormatArguments,\n }\n \n+/// A piece of a format template string.\n+///\n+/// E.g. \"hello\" or \"{name}\".\n #[derive(Clone, Debug)]\n pub enum FormatArgsPiece {\n     Literal(Symbol),\n     Placeholder(FormatPlaceholder),\n }\n \n+/// The arguments to format_args!().\n+///\n+/// E.g. `1, 2, name=\"ferris\", n=3`,\n+/// but also implicit captured arguments like `x` in `format_args!(\"{x}\")`.\n+#[derive(Clone, Debug)]\n+pub struct FormatArguments {\n+    arguments: Vec<FormatArgument>,\n+    num_unnamed_args: usize,\n+    num_explicit_args: usize,\n+    names: FxHashMap<Symbol, usize>,\n+}\n+\n+impl FormatArguments {\n+    pub fn new() -> Self {\n+        Self {\n+            arguments: Vec::new(),\n+            names: FxHashMap::default(),\n+            num_unnamed_args: 0,\n+            num_explicit_args: 0,\n+        }\n+    }\n+\n+    pub fn add(&mut self, arg: FormatArgument) -> usize {\n+        let index = self.arguments.len();\n+        if let Some(name) = arg.kind.ident() {\n+            self.names.insert(name.name, index);\n+        } else if self.names.is_empty() {\n+            // Only count the unnamed args before the first named arg.\n+            // (Any later ones are errors.)\n+            self.num_unnamed_args += 1;\n+        }\n+        if !matches!(arg.kind, FormatArgumentKind::Captured(..)) {\n+            // This is an explicit argument.\n+            // Make sure that all arguments so far are explcit.\n+            assert_eq!(\n+                self.num_explicit_args,\n+                self.arguments.len(),\n+                \"captured arguments must be added last\"\n+            );\n+            self.num_explicit_args += 1;\n+        }\n+        self.arguments.push(arg);\n+        index\n+    }\n+\n+    pub fn by_name(&self, name: Symbol) -> Option<(usize, &FormatArgument)> {\n+        let i = *self.names.get(&name)?;\n+        Some((i, &self.arguments[i]))\n+    }\n+\n+    pub fn by_index(&self, i: usize) -> Option<&FormatArgument> {\n+        (i < self.num_explicit_args).then(|| &self.arguments[i])\n+    }\n+\n+    pub fn unnamed_args(&self) -> &[FormatArgument] {\n+        &self.arguments[..self.num_unnamed_args]\n+    }\n+\n+    pub fn named_args(&self) -> &[FormatArgument] {\n+        &self.arguments[self.num_unnamed_args..self.num_explicit_args]\n+    }\n+\n+    pub fn explicit_args(&self) -> &[FormatArgument] {\n+        &self.arguments[..self.num_explicit_args]\n+    }\n+\n+    pub fn into_vec(self) -> Vec<FormatArgument> {\n+        self.arguments\n+    }\n+}\n+\n+#[derive(Clone, Debug)]\n+pub struct FormatArgument {\n+    pub kind: FormatArgumentKind,\n+    pub expr: P<Expr>,\n+}\n+\n #[derive(Clone, Debug)]\n-pub enum FormatArgKind {\n+pub enum FormatArgumentKind {\n     /// `format_args(\u2026, arg)`\n     Normal,\n     /// `format_args(\u2026, arg = 1)`\n@@ -61,7 +142,7 @@ pub enum FormatArgKind {\n     Captured(Ident),\n }\n \n-impl FormatArgKind {\n+impl FormatArgumentKind {\n     pub fn ident(&self) -> Option<Ident> {\n         match self {\n             &Self::Normal => None,"}, {"sha": "9dde5efcb28b7611c514e8517fc0d769fcb4d126", "filename": "compiler/rustc_builtin_macros/src/format/expand.rs", "status": "modified", "additions": 14, "deletions": 10, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/cf53fef0d6d4d5d8f6733a3d1e98e3b774342819/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf53fef0d6d4d5d8f6733a3d1e98e3b774342819/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat%2Fexpand.rs?ref=cf53fef0d6d4d5d8f6733a3d1e98e3b774342819", "patch": "@@ -201,13 +201,15 @@ pub fn expand_parsed_format_args(ecx: &mut ExtCtxt<'_>, fmt: FormatArgs) -> P<as\n         )\n     });\n \n+    let arguments = fmt.arguments.into_vec();\n+\n     // If the args array contains exactly all the original arguments once,\n     // in order, we can use a simple array instead of a `match` construction.\n     // However, if there's a yield point in any argument except the first one,\n     // we don't do this, because an ArgumentV1 cannot be kept across yield points.\n-    let use_simple_array = argmap.len() == fmt.arguments.len()\n+    let use_simple_array = argmap.len() == arguments.len()\n         && argmap.iter().enumerate().all(|(i, &(j, _))| i == j)\n-        && fmt.arguments.iter().skip(1).all(|(arg, _)| !may_contain_yield_point(arg));\n+        && arguments.iter().skip(1).all(|arg| !may_contain_yield_point(&arg.expr));\n \n     let args = if use_simple_array {\n         // Generate:\n@@ -218,12 +220,12 @@ pub fn expand_parsed_format_args(ecx: &mut ExtCtxt<'_>, fmt: FormatArgs) -> P<as\n         //     ]\n         ecx.expr_array_ref(\n             macsp,\n-            fmt.arguments\n+            arguments\n                 .into_iter()\n                 .zip(argmap)\n-                .map(|((arg, _), (_, ty))| {\n-                    let sp = arg.span.with_ctxt(macsp.ctxt());\n-                    make_argument(ecx, sp, ecx.expr_addr_of(sp, arg), ty)\n+                .map(|(arg, (_, ty))| {\n+                    let sp = arg.expr.span.with_ctxt(macsp.ctxt());\n+                    make_argument(ecx, sp, ecx.expr_addr_of(sp, arg.expr), ty)\n                 })\n                 .collect(),\n         )\n@@ -240,8 +242,8 @@ pub fn expand_parsed_format_args(ecx: &mut ExtCtxt<'_>, fmt: FormatArgs) -> P<as\n         let args = argmap\n             .iter()\n             .map(|&(arg_index, ty)| {\n-                if let Some((arg, _)) = fmt.arguments.get(arg_index) {\n-                    let sp = arg.span.with_ctxt(macsp.ctxt());\n+                if let Some(arg) = arguments.get(arg_index) {\n+                    let sp = arg.expr.span.with_ctxt(macsp.ctxt());\n                     make_argument(\n                         ecx,\n                         sp,\n@@ -263,9 +265,11 @@ pub fn expand_parsed_format_args(ecx: &mut ExtCtxt<'_>, fmt: FormatArgs) -> P<as\n                 macsp,\n                 ecx.expr_tuple(\n                     macsp,\n-                    fmt.arguments\n+                    arguments\n                         .into_iter()\n-                        .map(|(arg, _)| ecx.expr_addr_of(arg.span.with_ctxt(macsp.ctxt()), arg))\n+                        .map(|arg| {\n+                            ecx.expr_addr_of(arg.expr.span.with_ctxt(macsp.ctxt()), arg.expr)\n+                        })\n                         .collect(),\n                 ),\n                 vec![ecx.arm(macsp, ecx.pat_ident(macsp, args_ident), ecx.expr_array(macsp, args))],"}]}