{"sha": "4f576275be8473a17052300aabb811a767ad7b1b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRmNTc2Mjc1YmU4NDczYTE3MDUyMzAwYWFiYjgxMWE3NjdhZDdiMWI=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-04-15T08:07:47Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-04-15T08:43:38Z"}, "message": "syntax: Cleanup attr module. Closes #1545", "tree": {"sha": "bbd4e2cefeedfee9bcf4b78bc694b5a0df4ab2e2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bbd4e2cefeedfee9bcf4b78bc694b5a0df4ab2e2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4f576275be8473a17052300aabb811a767ad7b1b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4f576275be8473a17052300aabb811a767ad7b1b", "html_url": "https://github.com/rust-lang/rust/commit/4f576275be8473a17052300aabb811a767ad7b1b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4f576275be8473a17052300aabb811a767ad7b1b/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4f4a468e84537b38648bc9591e0f5a385be593e0", "url": "https://api.github.com/repos/rust-lang/rust/commits/4f4a468e84537b38648bc9591e0f5a385be593e0", "html_url": "https://github.com/rust-lang/rust/commit/4f4a468e84537b38648bc9591e0f5a385be593e0"}], "stats": {"total": 430, "additions": 237, "deletions": 193}, "files": [{"sha": "db7d753fffd36a06b2853e43fca7b610b29e53ed", "filename": "src/librustsyntax/ast_util.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4f576275be8473a17052300aabb811a767ad7b1b/src%2Flibrustsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f576275be8473a17052300aabb811a767ad7b1b/src%2Flibrustsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustsyntax%2Fast_util.rs?ref=4f576275be8473a17052300aabb811a767ad7b1b", "patch": "@@ -5,6 +5,10 @@ fn respan<T: copy>(sp: span, t: T) -> spanned<T> {\n     ret {node: t, span: sp};\n }\n \n+fn dummy_spanned<T: copy>(t: T) -> spanned<T> {\n+    ret respan(dummy_sp(), t);\n+}\n+\n /* assuming that we're not in macro expansion */\n fn mk_sp(lo: uint, hi: uint) -> span {\n     ret {lo: lo, hi: hi, expn_info: none};"}, {"sha": "81c465c283950918e22c691f57326130d6baea98", "filename": "src/librustsyntax/attr.rs", "status": "modified", "additions": 220, "deletions": 181, "changes": 401, "blob_url": "https://github.com/rust-lang/rust/blob/4f576275be8473a17052300aabb811a767ad7b1b/src%2Flibrustsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f576275be8473a17052300aabb811a767ad7b1b/src%2Flibrustsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustsyntax%2Fattr.rs?ref=4f576275be8473a17052300aabb811a767ad7b1b", "patch": "@@ -4,112 +4,89 @@ import std::map;\n import std::map::hashmap;\n import either::either;\n import diagnostic::span_handler;\n+import ast_util::dummy_spanned;\n \n+// Constructors\n+export mk_name_value_item_str;\n+export mk_name_value_item;\n+export mk_list_item;\n+export mk_word_item;\n+export mk_attr;\n+\n+// Conversion\n export attr_meta;\n export attr_metas;\n-export find_linkage_attrs;\n-export find_linkage_metas;\n-export inline_attr;\n-export find_inline_attr;\n+\n+// Accessors\n+export get_attr_name;\n+export get_meta_item_name;\n+export get_meta_item_value_str;\n+export get_meta_item_list;\n+export get_name_value_str_pair;\n+\n+// Searching\n export find_attrs_by_name;\n-export attrs_contains_name;\n export find_meta_items_by_name;\n export contains;\n export contains_name;\n+export attrs_contains_name;\n+export first_attr_value_str_by_name;\n+export last_meta_item_value_str_by_name;\n+export last_meta_item_list_by_name;\n+\n+// Higher-level applications\n export sort_meta_items;\n export remove_meta_items_by_name;\n-export require_unique_names;\n-export get_attr_name;\n-export get_meta_item_name;\n-export get_meta_item_value_str;\n-export get_meta_item_value_str_by_name;\n-export get_meta_item_list;\n-export meta_item_value_from_list;\n-export meta_item_list_from_list;\n-export name_value_str_pair;\n-export mk_name_value_item_str;\n-export mk_name_value_item;\n-export mk_list_item;\n-export mk_word_item;\n-export mk_attr;\n+export find_linkage_attrs;\n+export find_linkage_metas;\n export native_abi;\n+export inline_attr;\n+export find_inline_attr;\n+export require_unique_names;\n \n-// From a list of crate attributes get only the meta_items that impact crate\n-// linkage\n-fn find_linkage_metas(attrs: [ast::attribute]) -> [@ast::meta_item] {\n-    find_linkage_attrs(attrs).flat_map {|attr|\n-        alt check attr.node.value.node {\n-          ast::meta_list(_, items) { items }\n-        }\n-    }\n+/* Constructors */\n+\n+fn mk_name_value_item_str(name: ast::ident, value: str) -> @ast::meta_item {\n+    let value_lit = dummy_spanned(ast::lit_str(value));\n+    ret mk_name_value_item(name, value_lit);\n }\n \n-fn find_linkage_attrs(attrs: [ast::attribute]) -> [ast::attribute] {\n-    let mut found = [];\n-    for find_attrs_by_name(attrs, \"link\").each {|attr|\n-        alt attr.node.value.node {\n-          ast::meta_list(_, _) { found += [attr] }\n-          _ { #debug(\"ignoring link attribute that has incorrect type\"); }\n-        }\n-    }\n-    ret found;\n+fn mk_name_value_item(name: ast::ident, value: ast::lit) -> @ast::meta_item {\n+    ret @dummy_spanned(ast::meta_name_value(name, value));\n }\n \n-enum inline_attr {\n-    ia_none,\n-    ia_hint,\n-    ia_always\n+fn mk_list_item(name: ast::ident, items: [@ast::meta_item]) ->\n+   @ast::meta_item {\n+    ret @dummy_spanned(ast::meta_list(name, items));\n }\n \n-// True if something like #[inline] is found in the list of attrs.\n-fn find_inline_attr(attrs: [ast::attribute]) -> inline_attr {\n-    // TODO---validate the usage of #[inline] and #[inline(always)]\n-    vec::foldl(ia_none, attrs) {|ia,attr|\n-        alt attr.node.value.node {\n-          ast::meta_word(\"inline\") { ia_hint }\n-          ast::meta_list(\"inline\", items) {\n-            if !vec::is_empty(find_meta_items_by_name(items, \"always\")) {\n-                ia_always\n-            } else {\n-                ia_hint\n-            }\n-          }\n-          _ { ia }\n-        }\n-    }\n+fn mk_word_item(name: ast::ident) -> @ast::meta_item {\n+    ret @dummy_spanned(ast::meta_word(name));\n }\n \n-// Search a list of attributes and return only those with a specific name\n-fn find_attrs_by_name(attrs: [ast::attribute], name: ast::ident) ->\n-   [ast::attribute] {\n-    let filter = (\n-        fn@(a: ast::attribute) -> option<ast::attribute> {\n-            if get_attr_name(a) == name {\n-                option::some(a)\n-            } else { option::none }\n-        }\n-    );\n-    ret vec::filter_map(attrs, filter);\n+fn mk_attr(item: @ast::meta_item) -> ast::attribute {\n+    ret dummy_spanned({style: ast::attr_inner, value: *item});\n }\n \n-fn attrs_contains_name(attrs: [ast::attribute], name: ast::ident) -> bool {\n-    vec::is_not_empty(find_attrs_by_name(attrs, name))\n+\n+/* Conversion */\n+\n+fn attr_meta(attr: ast::attribute) -> @ast::meta_item { @attr.node.value }\n+\n+// Get the meta_items from inside a vector of attributes\n+fn attr_metas(attrs: [ast::attribute]) -> [@ast::meta_item] {\n+    let mut mitems = [];\n+    for attrs.each {|a| mitems += [attr_meta(a)]; }\n+    ret mitems;\n }\n \n+\n+/* Accessors */\n+\n fn get_attr_name(attr: ast::attribute) -> ast::ident {\n     get_meta_item_name(@attr.node.value)\n }\n \n-fn find_meta_items_by_name(metas: [@ast::meta_item], name: ast::ident) ->\n-   [@ast::meta_item] {\n-    let filter = fn@(&&m: @ast::meta_item) -> option<@ast::meta_item> {\n-        if get_meta_item_name(m) == name {\n-            option::some(m)\n-        } else { option::none }\n-    };\n-    ret vec::filter_map(metas, filter);\n-}\n-\n fn get_meta_item_name(meta: @ast::meta_item) -> ast::ident {\n     alt meta.node {\n       ast::meta_word(n) { n }\n@@ -118,8 +95,10 @@ fn get_meta_item_name(meta: @ast::meta_item) -> ast::ident {\n     }\n }\n \n-// Gets the string value if the meta_item is a meta_name_value variant\n-// containing a string, otherwise none\n+#[doc = \"\n+Gets the string value if the meta_item is a meta_name_value variant\n+containing a string, otherwise none\n+\"]\n fn get_meta_item_value_str(meta: @ast::meta_item) -> option<str> {\n     alt meta.node {\n       ast::meta_name_value(_, v) {\n@@ -129,29 +108,75 @@ fn get_meta_item_value_str(meta: @ast::meta_item) -> option<str> {\n     }\n }\n \n-fn get_meta_item_value_str_by_name(attrs: [ast::attribute], name: ast::ident)\n-    -> option<str> {\n-    let mattrs = find_attrs_by_name(attrs, name);\n-    if vec::len(mattrs) > 0u {\n-        ret get_meta_item_value_str(attr_meta(mattrs[0]));\n-    }\n-    ret option::none;\n-}\n-\n+#[doc = \"Gets a list of inner meta items from a list meta_item type\"]\n fn get_meta_item_list(meta: @ast::meta_item) -> option<[@ast::meta_item]> {\n     alt meta.node {\n       ast::meta_list(_, l) { option::some(l) }\n       _ { option::none }\n     }\n }\n \n-fn attr_meta(attr: ast::attribute) -> @ast::meta_item { @attr.node.value }\n+#[doc = \"\n+If the meta item is a nam-value type with a string value then returns\n+a tuple containing the name and string value, otherwise `none`\n+\"]\n+fn get_name_value_str_pair(\n+    item: @ast::meta_item\n+) -> option<(str, str)> {\n+    alt attr::get_meta_item_value_str(item) {\n+      some(value) {\n+        let name = attr::get_meta_item_name(item);\n+        some((name, value))\n+      }\n+      none { none }\n+    }\n+}\n \n-// Get the meta_items from inside a vector of attributes\n-fn attr_metas(attrs: [ast::attribute]) -> [@ast::meta_item] {\n-    let mut mitems = [];\n-    for attrs.each {|a| mitems += [attr_meta(a)]; }\n-    ret mitems;\n+\n+/* Searching */\n+\n+#[doc = \"\n+Search a list of attributes and return only those with a specific name\n+\"]\n+fn find_attrs_by_name(attrs: [ast::attribute], name: ast::ident) ->\n+   [ast::attribute] {\n+    let filter = (\n+        fn@(a: ast::attribute) -> option<ast::attribute> {\n+            if get_attr_name(a) == name {\n+                option::some(a)\n+            } else { option::none }\n+        }\n+    );\n+    ret vec::filter_map(attrs, filter);\n+}\n+\n+#[doc = \"\n+Searcha list of meta items and return only those with a specific name\n+\"]\n+fn find_meta_items_by_name(metas: [@ast::meta_item], name: ast::ident) ->\n+   [@ast::meta_item] {\n+    let filter = fn@(&&m: @ast::meta_item) -> option<@ast::meta_item> {\n+        if get_meta_item_name(m) == name {\n+            option::some(m)\n+        } else { option::none }\n+    };\n+    ret vec::filter_map(metas, filter);\n+}\n+\n+#[doc = \"\n+Returns true if a list of meta items contains another meta item. The\n+comparison is performed structurally.\n+\"]\n+fn contains(haystack: [@ast::meta_item], needle: @ast::meta_item) -> bool {\n+    #debug(\"looking for %s\",\n+           print::pprust::meta_item_to_str(*needle));\n+    for haystack.each {|item|\n+        #debug(\"looking in %s\",\n+               print::pprust::meta_item_to_str(*item));\n+        if eq(item, needle) { #debug(\"found it!\"); ret true; }\n+    }\n+    #debug(\"found it not :(\");\n+    ret false;\n }\n \n fn eq(a: @ast::meta_item, b: @ast::meta_item) -> bool {\n@@ -175,23 +200,62 @@ fn eq(a: @ast::meta_item, b: @ast::meta_item) -> bool {\n         }\n }\n \n-fn contains(haystack: [@ast::meta_item], needle: @ast::meta_item) -> bool {\n-    #debug(\"looking for %s\",\n-           print::pprust::meta_item_to_str(*needle));\n-    for haystack.each {|item|\n-        #debug(\"looking in %s\",\n-               print::pprust::meta_item_to_str(*item));\n-        if eq(item, needle) { #debug(\"found it!\"); ret true; }\n-    }\n-    #debug(\"found it not :(\");\n-    ret false;\n-}\n-\n fn contains_name(metas: [@ast::meta_item], name: ast::ident) -> bool {\n     let matches = find_meta_items_by_name(metas, name);\n     ret vec::len(matches) > 0u;\n }\n \n+fn attrs_contains_name(attrs: [ast::attribute], name: ast::ident) -> bool {\n+    vec::is_not_empty(find_attrs_by_name(attrs, name))\n+}\n+\n+fn first_attr_value_str_by_name(attrs: [ast::attribute], name: ast::ident)\n+    -> option<str> {\n+    let mattrs = find_attrs_by_name(attrs, name);\n+    if vec::len(mattrs) > 0u {\n+        ret get_meta_item_value_str(attr_meta(mattrs[0]));\n+    }\n+    ret option::none;\n+}\n+\n+fn last_meta_item_by_name(\n+    items: [@ast::meta_item],\n+    name: str\n+) -> option<@ast::meta_item> {\n+    let items = attr::find_meta_items_by_name(items, name);\n+    vec::last_opt(items)\n+}\n+\n+fn last_meta_item_value_str_by_name(\n+    items: [@ast::meta_item],\n+    name: str\n+) -> option<str> {\n+    alt last_meta_item_by_name(items, name) {\n+      some(item) {\n+        alt attr::get_meta_item_value_str(item) {\n+          some(value) { some(value) }\n+          none { none }\n+        }\n+      }\n+      none { none }\n+    }\n+}\n+\n+fn last_meta_item_list_by_name(\n+    items: [@ast::meta_item],\n+    name: str\n+) -> option<[@ast::meta_item]> {\n+    alt last_meta_item_by_name(items, name) {\n+      some(item) {\n+        attr::get_meta_item_list(item)\n+      }\n+      none { none }\n+    }\n+}\n+\n+\n+/* Higher-level applications */\n+\n // FIXME: This needs to sort by meta_item variant in addition to the item name\n fn sort_meta_items(items: [@ast::meta_item]) -> [@ast::meta_item] {\n     fn lteq(&&ma: @ast::meta_item, &&mb: @ast::meta_item) -> bool {\n@@ -228,21 +292,31 @@ fn remove_meta_items_by_name(items: [@ast::meta_item], name: str) ->\n     ret vec::filter_map(items, filter);\n }\n \n-fn require_unique_names(diagnostic: span_handler,\n-                        metas: [@ast::meta_item]) {\n-    let map = map::str_hash();\n-    for metas.each {|meta|\n-        let name = get_meta_item_name(meta);\n-        if map.contains_key(name) {\n-            diagnostic.span_fatal(meta.span,\n-                                  #fmt[\"duplicate meta item `%s`\", name]);\n+fn find_linkage_attrs(attrs: [ast::attribute]) -> [ast::attribute] {\n+    let mut found = [];\n+    for find_attrs_by_name(attrs, \"link\").each {|attr|\n+        alt attr.node.value.node {\n+          ast::meta_list(_, _) { found += [attr] }\n+          _ { #debug(\"ignoring link attribute that has incorrect type\"); }\n+        }\n+    }\n+    ret found;\n+}\n+\n+#[doc = \"\n+From a list of crate attributes get only the meta_items that impact crate\n+linkage\n+\"]\n+fn find_linkage_metas(attrs: [ast::attribute]) -> [@ast::meta_item] {\n+    find_linkage_attrs(attrs).flat_map {|attr|\n+        alt check attr.node.value.node {\n+          ast::meta_list(_, items) { items }\n         }\n-        map.insert(name, ());\n     }\n }\n \n fn native_abi(attrs: [ast::attribute]) -> either<str, ast::native_abi> {\n-    ret alt attr::get_meta_item_value_str_by_name(attrs, \"abi\") {\n+    ret alt attr::first_attr_value_str_by_name(attrs, \"abi\") {\n       option::none {\n         either::right(ast::native_abi_cdecl)\n       }\n@@ -261,79 +335,44 @@ fn native_abi(attrs: [ast::attribute]) -> either<str, ast::native_abi> {\n     };\n }\n \n-fn meta_item_from_list(\n-    items: [@ast::meta_item],\n-    name: str\n-) -> option<@ast::meta_item> {\n-    let items = attr::find_meta_items_by_name(items, name);\n-    vec::last_opt(items)\n+enum inline_attr {\n+    ia_none,\n+    ia_hint,\n+    ia_always\n }\n \n-fn meta_item_value_from_list(\n-    items: [@ast::meta_item],\n-    name: str\n-) -> option<str> {\n-    alt meta_item_from_list(items, name) {\n-      some(item) {\n-        alt attr::get_meta_item_value_str(item) {\n-          some(value) { some(value) }\n-          none { none }\n+#[doc = \"True if something like #[inline] is found in the list of attrs.\"]\n+fn find_inline_attr(attrs: [ast::attribute]) -> inline_attr {\n+    // TODO---validate the usage of #[inline] and #[inline(always)]\n+    vec::foldl(ia_none, attrs) {|ia,attr|\n+        alt attr.node.value.node {\n+          ast::meta_word(\"inline\") { ia_hint }\n+          ast::meta_list(\"inline\", items) {\n+            if !vec::is_empty(find_meta_items_by_name(items, \"always\")) {\n+                ia_always\n+            } else {\n+                ia_hint\n+            }\n+          }\n+          _ { ia }\n         }\n-      }\n-      none { none }\n     }\n }\n \n-fn meta_item_list_from_list(\n-    items: [@ast::meta_item],\n-    name: str\n-) -> option<[@ast::meta_item]> {\n-    alt meta_item_from_list(items, name) {\n-      some(item) {\n-        attr::get_meta_item_list(item)\n-      }\n-      none { none }\n-    }\n-}\n \n-fn name_value_str_pair(\n-    item: @ast::meta_item\n-) -> option<(str, str)> {\n-    alt attr::get_meta_item_value_str(item) {\n-      some(value) {\n-        let name = attr::get_meta_item_name(item);\n-        some((name, value))\n-      }\n-      none { none }\n+fn require_unique_names(diagnostic: span_handler,\n+                        metas: [@ast::meta_item]) {\n+    let map = map::str_hash();\n+    for metas.each {|meta|\n+        let name = get_meta_item_name(meta);\n+        if map.contains_key(name) {\n+            diagnostic.span_fatal(meta.span,\n+                                  #fmt[\"duplicate meta item `%s`\", name]);\n+        }\n+        map.insert(name, ());\n     }\n }\n \n-fn span<T: copy>(item: T) -> ast::spanned<T> {\n-    ret {node: item, span: ast_util::dummy_sp()};\n-}\n-\n-fn mk_name_value_item_str(name: ast::ident, value: str) -> @ast::meta_item {\n-    let value_lit = span(ast::lit_str(value));\n-    ret mk_name_value_item(name, value_lit);\n-}\n-\n-fn mk_name_value_item(name: ast::ident, value: ast::lit) -> @ast::meta_item {\n-    ret @span(ast::meta_name_value(name, value));\n-}\n-\n-fn mk_list_item(name: ast::ident, items: [@ast::meta_item]) ->\n-   @ast::meta_item {\n-    ret @span(ast::meta_list(name, items));\n-}\n-\n-fn mk_word_item(name: ast::ident) -> @ast::meta_item {\n-    ret @span(ast::meta_word(name));\n-}\n-\n-fn mk_attr(item: @ast::meta_item) -> ast::attribute {\n-    ret span({style: ast::attr_inner, value: *item});\n-}\n-\n //\n // Local Variables:\n // mode: rust"}, {"sha": "75824152f5d0a2ae1013b5359c4922f00d97778c", "filename": "src/librustsyntax/parse/eval.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4f576275be8473a17052300aabb811a767ad7b1b/src%2Flibrustsyntax%2Fparse%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f576275be8473a17052300aabb811a767ad7b1b/src%2Flibrustsyntax%2Fparse%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustsyntax%2Fparse%2Feval.rs?ref=4f576275be8473a17052300aabb811a767ad7b1b", "patch": "@@ -81,7 +81,7 @@ fn parse_companion_mod(cx: ctx, prefix: str, suffix: option<str>)\n }\n \n fn cdir_path_opt(id: str, attrs: [ast::attribute]) -> str {\n-    alt attr::get_meta_item_value_str_by_name(attrs, \"path\") {\n+    alt attr::first_attr_value_str_by_name(attrs, \"path\") {\n       some(d) {\n         ret d;\n       }"}, {"sha": "f452500d8736e56653d7d60b0e4f6140bcf5ad49", "filename": "src/rustc/driver/session.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4f576275be8473a17052300aabb811a767ad7b1b/src%2Frustc%2Fdriver%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f576275be8473a17052300aabb811a767ad7b1b/src%2Frustc%2Fdriver%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fdriver%2Fsession.rs?ref=4f576275be8473a17052300aabb811a767ad7b1b", "patch": "@@ -129,7 +129,7 @@ fn building_library(req_crate_type: crate_type, crate: @ast::crate,\n         if testing {\n             false\n         } else {\n-            alt syntax::attr::get_meta_item_value_str_by_name(\n+            alt syntax::attr::first_attr_value_str_by_name(\n                 crate.node.attrs,\n                 \"crate_type\") {\n               option::some(\"lib\") { true }"}, {"sha": "11010dade083662f47db15bc9846a44d5f25d6b0", "filename": "src/rustc/front/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4f576275be8473a17052300aabb811a767ad7b1b/src%2Frustc%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f576275be8473a17052300aabb811a767ad7b1b/src%2Frustc%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Ffront%2Ftest.rs?ref=4f576275be8473a17052300aabb811a767ad7b1b", "patch": "@@ -238,7 +238,7 @@ fn mk_path(cx: test_ctxt, path: [ast::ident]) -> [ast::ident] {\n     // the paths with std::\n     let is_std = {\n         let items = attr::find_linkage_metas(cx.crate.node.attrs);\n-        alt attr::meta_item_value_from_list(items, \"name\") {\n+        alt attr::last_meta_item_value_str_by_name(items, \"name\") {\n           some(\"std\") { true }\n           _ { false }\n         }"}, {"sha": "1f4bc2cdcf7d670f5920120c0a868f77c2b0d052", "filename": "src/rustc/metadata/creader.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/4f576275be8473a17052300aabb811a767ad7b1b/src%2Frustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f576275be8473a17052300aabb811a767ad7b1b/src%2Frustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fcreader.rs?ref=4f576275be8473a17052300aabb811a767ad7b1b", "patch": "@@ -115,7 +115,7 @@ fn visit_item(e: env, i: @ast::item) {\n \n         let cstore = e.sess.cstore;\n         let native_name =\n-            alt attr::get_meta_item_value_str_by_name(i.attrs, \"link_name\") {\n+            alt attr::first_attr_value_str_by_name(i.attrs, \"link_name\") {\n               some(nn) {\n                 if nn == \"\" {\n                     e.sess.span_fatal(\n@@ -387,10 +387,11 @@ fn resolve_crate(e: env, ident: ast::ident, metas: [@ast::meta_item],\n         // Now resolve the crates referenced by this crate\n         let cnum_map = resolve_crate_deps(e, cdata);\n \n-        let cname = alt attr::meta_item_value_from_list(metas, \"name\") {\n-          option::some(v) { v }\n-          option::none { ident }\n-        };\n+        let cname =\n+            alt attr::last_meta_item_value_str_by_name(metas, \"name\") {\n+              option::some(v) { v }\n+              option::none { ident }\n+            };\n         let cmeta = @{name: cname, data: cdata,\n                       cnum_map: cnum_map, cnum: cnum};\n "}, {"sha": "ab33355dee2379c121091e5af276c73238a4ceca", "filename": "src/rustc/metadata/decoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4f576275be8473a17052300aabb811a767ad7b1b/src%2Frustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f576275be8473a17052300aabb811a767ad7b1b/src%2Frustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fdecoder.rs?ref=4f576275be8473a17052300aabb811a767ad7b1b", "patch": "@@ -620,7 +620,7 @@ fn get_crate_hash(data: @[u8]) -> str {\n \n fn get_crate_vers(data: @[u8]) -> str {\n     let attrs = decoder::get_crate_attributes(data);\n-    ret alt attr::meta_item_value_from_list(\n+    ret alt attr::last_meta_item_value_str_by_name(\n         attr::find_linkage_metas(attrs), \"vers\") {\n       some(ver) { ver }\n       none { \"0.0\" }"}, {"sha": "5f98915b3c7596c23edee1c537e23f40d50a6091", "filename": "src/rustc/middle/trans/native.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4f576275be8473a17052300aabb811a767ad7b1b/src%2Frustc%2Fmiddle%2Ftrans%2Fnative.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f576275be8473a17052300aabb811a767ad7b1b/src%2Frustc%2Fmiddle%2Ftrans%2Fnative.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fnative.rs?ref=4f576275be8473a17052300aabb811a767ad7b1b", "patch": "@@ -395,7 +395,7 @@ fn decl_x86_64_fn(tys: x86_64_tys,\n }\n \n fn link_name(i: @ast::native_item) -> str {\n-    alt attr::get_meta_item_value_str_by_name(i.attrs, \"link_name\") {\n+    alt attr::first_attr_value_str_by_name(i.attrs, \"link_name\") {\n       none { ret i.ident; }\n       option::some(ln) { ret ln; }\n     }\n@@ -989,7 +989,7 @@ fn register_crust_fn(ccx: @crate_ctxt, sp: span,\n \n fn abi_of_native_fn(ccx: @crate_ctxt, i: @ast::native_item)\n     -> ast::native_abi {\n-    alt attr::get_meta_item_value_str_by_name(i.attrs, \"abi\") {\n+    alt attr::first_attr_value_str_by_name(i.attrs, \"abi\") {\n       none {\n         alt check ccx.tcx.items.get(i.id) {\n           ast_map::node_native_item(_, abi, _) { abi }"}, {"sha": "60da58b83b669635183e12eeca0e1e329fd055d7", "filename": "src/rustdoc/attr_parser.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4f576275be8473a17052300aabb811a767ad7b1b/src%2Frustdoc%2Fattr_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f576275be8473a17052300aabb811a767ad7b1b/src%2Frustdoc%2Fattr_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fattr_parser.rs?ref=4f576275be8473a17052300aabb811a767ad7b1b", "patch": "@@ -65,7 +65,7 @@ fn parse_crate(attrs: [ast::attribute]) -> crate_attrs {\n     let link_metas = attr::find_linkage_metas(attrs);\n \n     {\n-        name: attr::meta_item_value_from_list(link_metas, \"name\")\n+        name: attr::last_meta_item_value_str_by_name(link_metas, \"name\")\n     }\n }\n "}]}