{"sha": "3cd978fbc75a691a144dcafe99a08531a424fcd0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNjZDk3OGZiYzc1YTY5MWExNDRkY2FmZTk5YTA4NTMxYTQyNGZjZDA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-08-20T22:01:55Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-08-20T22:01:55Z"}, "message": "auto merge of #8563 : graydon/rust/2013-08-16-condition-tutorial, r=catamorphism\n\nFirst cut of a tutorial on conditions.\r\n\r\ncc: #6701", "tree": {"sha": "8356d2a75fc7d2784840df899365d02a3d146655", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8356d2a75fc7d2784840df899365d02a3d146655"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3cd978fbc75a691a144dcafe99a08531a424fcd0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3cd978fbc75a691a144dcafe99a08531a424fcd0", "html_url": "https://github.com/rust-lang/rust/commit/3cd978fbc75a691a144dcafe99a08531a424fcd0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3cd978fbc75a691a144dcafe99a08531a424fcd0/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "293660d44347967cbb724d1ff94b90d635c2c64f", "url": "https://api.github.com/repos/rust-lang/rust/commits/293660d44347967cbb724d1ff94b90d635c2c64f", "html_url": "https://github.com/rust-lang/rust/commit/293660d44347967cbb724d1ff94b90d635c2c64f"}, {"sha": "ef5d537010dbc7192b15e44ac01c62af45de4df9", "url": "https://api.github.com/repos/rust-lang/rust/commits/ef5d537010dbc7192b15e44ac01c62af45de4df9", "html_url": "https://github.com/rust-lang/rust/commit/ef5d537010dbc7192b15e44ac01c62af45de4df9"}], "stats": {"total": 890, "additions": 889, "deletions": 1}, "files": [{"sha": "a3291725703ae979d16932a3fa7e0cabe3ce858a", "filename": "configure", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3cd978fbc75a691a144dcafe99a08531a424fcd0/configure", "raw_url": "https://github.com/rust-lang/rust/raw/3cd978fbc75a691a144dcafe99a08531a424fcd0/configure", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/configure?ref=3cd978fbc75a691a144dcafe99a08531a424fcd0", "patch": "@@ -740,6 +740,7 @@ do\n     make_dir $h/test/doc-tutorial-macros\n     make_dir $h/test/doc-tutorial-borrowed-ptr\n     make_dir $h/test/doc-tutorial-tasks\n+    make_dir $h/test/doc-tutorial-conditions\n     make_dir $h/test/doc-rust\n done\n "}, {"sha": "bcee4377f1433c563516b14ab088c3b78d7b26e8", "filename": "doc/tutorial-conditions.md", "status": "added", "additions": 876, "deletions": 0, "changes": 876, "blob_url": "https://github.com/rust-lang/rust/blob/3cd978fbc75a691a144dcafe99a08531a424fcd0/doc%2Ftutorial-conditions.md", "raw_url": "https://github.com/rust-lang/rust/raw/3cd978fbc75a691a144dcafe99a08531a424fcd0/doc%2Ftutorial-conditions.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial-conditions.md?ref=3cd978fbc75a691a144dcafe99a08531a424fcd0", "patch": "@@ -0,0 +1,876 @@\n+% Rust Condition and Error-handling Tutorial\n+\n+# Introduction\n+\n+Rust does not provide exception handling[^why-no-exceptions]\n+in the form most commonly seen in other programming languages such as C++ or Java.\n+Instead, it provides four mechanisms that work together to handle errors or other rare events.\n+The four mechanisms are:\n+\n+  - Options\n+  - Results\n+  - Failure\n+  - Conditions\n+\n+This tutorial will lead you through use of these mechanisms\n+in order to understand the trade-offs of each and relationships between them.\n+\n+# Example program\n+\n+This tutorial will be based around an example program\n+that attempts to read lines from a file\n+consisting of pairs of numbers,\n+and then print them back out with slightly different formatting.\n+The input to the program might look like this:\n+\n+~~~~ {.notrust}\n+$ cat numbers.txt\n+1 2\n+34 56\n+789 123\n+45 67\n+~~~~\n+\n+For which the intended output looks like this:\n+\n+~~~~ {.notrust}\n+$ ./example numbers.txt\n+0001, 0002\n+0034, 0056\n+0789, 0123\n+0045, 0067\n+~~~~\n+\n+An example program that does this task reads like this:\n+\n+~~~~\n+# #[allow(unused_imports)];\n+extern mod extra;\n+use extra::fileinput::FileInput;\n+use std::int;\n+# mod FileInput {\n+#    use std::io::{Reader, BytesReader};\n+#    static s : &'static [u8] = bytes!(\"1 2\\n\\\n+#                                       34 56\\n\\\n+#                                       789 123\\n\\\n+#                                       45 67\\n\\\n+#                                       \");\n+#    pub fn from_args() -> @Reader{\n+#        @BytesReader {\n+#            bytes: s,\n+#            pos: @mut 0\n+#        } as @Reader\n+#    }\n+# }\n+\n+fn main() {\n+    let pairs = read_int_pairs();\n+    for &(a,b) in pairs.iter() {\n+        println(fmt!(\"%4.4d, %4.4d\", a, b));\n+    }\n+}\n+\n+\n+fn read_int_pairs() -> ~[(int,int)] {\n+\n+    let mut pairs = ~[];\n+\n+    let fi = FileInput::from_args();\n+    while ! fi.eof() {\n+\n+        // 1. Read a line of input.\n+        let line = fi.read_line();\n+\n+        // 2. Split the line into fields (\"words\").\n+        let fields = line.word_iter().to_owned_vec();\n+\n+        // 3. Match the vector of fields against a vector pattern.\n+        match fields {\n+\n+            // 4. When the line had two fields:\n+            [a, b] => {\n+\n+                // 5. Try parsing both fields as ints.\n+                match (int::from_str(a), int::from_str(b)) {\n+\n+                    // 6. If parsing succeeded for both, push both.\n+                    (Some(a), Some(b)) => pairs.push((a,b)),\n+\n+                    // 7. Ignore non-int fields.\n+                    _ => ()\n+                }\n+            }\n+\n+            // 8. Ignore lines that don't have 2 fields.\n+            _ => ()\n+        }\n+    }\n+\n+    pairs\n+}\n+~~~~\n+\n+This example shows the use of `Option`,\n+along with some other forms of error-handling (and non-handling).\n+We will look at these mechanisms\n+and then modify parts of the example to perform \"better\" error handling.\n+\n+\n+# Options\n+\n+The simplest and most lightweight mechanism in Rust for indicating an error is the type `std::option::Option<T>`.\n+This type is a general purpose `enum`\n+for conveying a value of type `T`, represented as `Some(T)`\n+_or_ the sentinel `None`, to indicate the absence of a `T` value.\n+For simple APIs, it may be sufficient to encode errors as `Option<T>`,\n+returning `Some(T)` on success and `None` on error.\n+In the example program, the call to `int::from_str` returns `Option<int>`\n+with the understanding that \"all parse errors\" result in `None`.\n+The resulting `Option<int>` values are matched against the pattern `(Some(a), Some(b))`\n+in steps 5 and 6 in the example program,\n+to handle the case in which both fields were parsed successfully.\n+\n+Using `Option` as in this API has some advantages:\n+\n+  - Simple API, users can read it and guess how it works.\n+  - Very efficient, only an extra `enum` tag on return values.\n+  - Caller has flexibility in handling or propagating errors.\n+  - Caller is forced to acknowledge existence of possible-error before using value.\n+\n+However, it has serious disadvantages too:\n+\n+  - Verbose, requires matching results or calling `Option::unwrap` everywhere.\n+  - Infects caller: if caller doesn't know how to handle the error, must propagate (or force).\n+  - Temptation to do just that: force the `Some(T)` case by blindly calling `unwrap`,\n+    which hides the error from the API without providing any way to make the program robust against the error.\n+  - Collapses all errors into one:\n+    - Caller can't handle different errors differently.\n+    - Caller can't even report a very precise error message\n+\n+Note that in order to keep the example code reasonably compact,\n+several unwanted cases are silently ignored:\n+lines that do not contain two fields, as well as fields that do not parse as ints.\n+To propagate these cases to the caller using `Option` would require even more verbose code.\n+\n+\n+# Results\n+\n+Before getting into _trapping_ the error,\n+we will look at a slight refinement on the `Option` type above.\n+This second mechanism for indicating an error is called a `Result`.\n+The type `std::result::Result<T,E>` is another simple `enum` type with two forms, `Ok(T)` and `Err(E)`.\n+The `Result` type is not substantially different from the `Option` type in terms of its ergonomics.\n+Its main advantage is that the error constructor `Err(E)` can convey _more detail_ about the error.\n+For example, the `int::from_str` API could be reformed\n+to return a `Result` carrying an informative description of a parse error,\n+like this:\n+\n+~~~~ {.ignore}\n+enum IntParseErr {\n+     EmptyInput,\n+     Overflow,\n+     BadChar(char)\n+}\n+\n+fn int::from_str(&str) -> Result<int,IntParseErr> {\n+  // ...\n+}\n+~~~~\n+\n+This would give the caller more information for both handling and reporting the error,\n+but would otherwise retain the verbosity problems of using `Option`.\n+In particular, it would still be necessary for the caller to return a further `Result` to _its_ caller if it did not want to handle the error.\n+Manually propagating result values this way can be attractive in certain circumstances\n+-- for example when processing must halt on the very first error, or backtrack --\n+but as we will see later, many cases have simpler options available.\n+\n+# Failure\n+\n+The third and arguably easiest mechanism for handling errors is called \"failure\".\n+In fact it was hinted at earlier by suggesting that one can choose to propagate `Option` or `Result` types _or \"force\" them_.\n+\"Forcing\" them, in this case, means calling a method like `Option<T>::unwrap`,\n+which contains the following code:\n+\n+~~~~ {.ignore}\n+pub fn unwrap(self) -> T {\n+    match self {\n+      Some(x) => return x,\n+      None => fail!(\"option::unwrap `None`\")\n+    }\n+}\n+~~~~\n+\n+That is, it returns `T` when `self` is `Some(T)`, and  _fails_ when `self` is `None`.\n+\n+Every Rust task can _fail_, either indirectly due to a kill signal or other asynchronous event,\n+or directly by failing an `assert!` or calling the `fail!` macro.\n+Failure is an _unrecoverable event_ at the task level:\n+it causes the task to halt normal execution and unwind its control stack,\n+freeing all task-local resources (the local heap as well as any task-owned values from the global heap)\n+and running destructors (the `drop` method of the `Drop` trait)\n+as frames are unwound and heap values destroyed.\n+A failing task is not permitted to \"catch\" the unwinding during failure and recover,\n+it is only allowed to clean up and exit.\n+\n+Failure has advantages:\n+\n+  - Simple and non-verbose. Suitable for programs that can't reasonably continue past an error anyways.\n+  - _All_ errors (except memory-safety errors) can be uniformly trapped in a supervisory task outside the failing task.\n+    For a large program to be robust against a variety of errors,\n+    often some form of task-level partitioning to contain pervasive errors (arithmetic overflow, division by zero,\n+    logic bugs) is necessary anyways.\n+\n+As well as obvious disadvantages:\n+\n+  - A blunt instrument, terminates the containing task entirely.\n+\n+Recall that in the first two approaches to error handling,\n+the example program was only handling success cases, and ignoring error cases.\n+That is, if the input is changed to contain a malformed line:\n+\n+~~~~ {.notrust}\n+$ cat bad.txt\n+1 2\n+34 56\n+ostrich\n+789 123\n+45 67\n+~~~~\n+\n+Then the program would give the same output as if there was no error:\n+\n+~~~~ {.notrust}\n+$ ./example bad.txt\n+0001, 0002\n+0034, 0056\n+0789, 0123\n+0045, 0067\n+~~~~\n+\n+If the example is rewritten to use failure, these error cases can be trapped.\n+In this rewriting, failures are trapped by placing the I/O logic in a sub-task,\n+and trapping its exit status using `task::try`:\n+\n+~~~~ {.xfail-test}\n+# #[allowed(unused_imports)];\n+extern mod extra;\n+use extra::fileinput::FileInput;\n+use std::int;\n+use std::task;\n+# mod FileInput {\n+#    use std::io::{Reader, BytesReader};\n+#    static s : &'static [u8] = bytes!(\"1 2\\n\\\n+#                                       34 56\\n\\\n+#                                       ostrich\\n\\\n+#                                       789 123\\n\\\n+#                                       45 67\\n\\\n+#                                       \");\n+#    pub fn from_args() -> @Reader{\n+#        @BytesReader {\n+#            bytes: s,\n+#            pos: @mut 0\n+#        } as @Reader\n+#    }\n+# }\n+\n+fn main() {\n+\n+    // Isolate failure within a subtask.\n+    let result = do task::try {\n+\n+        // The protected logic.\n+        let pairs = read_int_pairs();\n+        for &(a,b) in pairs.iter() {\n+            println(fmt!(\"%4.4d, %4.4d\", a, b));\n+        }\n+\n+    };\n+    if result.is_err() {\n+            println(\"parsing failed\");\n+    }\n+}\n+\n+fn read_int_pairs() -> ~[(int,int)] {\n+    let mut pairs = ~[];\n+    let fi = FileInput::from_args();\n+    while ! fi.eof() {\n+        let line = fi.read_line();\n+        let fields = line.word_iter().to_owned_vec();\n+        match fields {\n+            [a, b] => pairs.push((int::from_str(a).unwrap(),\n+                                  int::from_str(b).unwrap())),\n+\n+            // Explicitly fail on malformed lines.\n+            _ => fail!()\n+        }\n+    }\n+    pairs\n+}\n+~~~~\n+\n+With these changes in place, running the program on malformed input gives a different answer:\n+\n+~~~~ {.notrust}\n+$ ./example bad.txt\n+rust: task failed at 'explicit failure', ./example.rs:44\n+parsing failed\n+~~~~\n+\n+Note that while failure unwinds the sub-task performing I/O in `read_int_pairs`,\n+control returns to `main` and can easily continue uninterrupted.\n+In this case, control simply prints out `parsing failed` and then exits `main` (successfully).\n+Failure of a (sub-)task is analogous to calling `exit(1)` or `abort()` in a unix C program:\n+all the state of a sub-task is cleanly discarded on exit,\n+and a supervisor task can take appropriate action\n+without worrying about its own state having been corrupted.\n+\n+\n+# Conditions\n+\n+The final mechanism for handling errors is called a \"condition\".\n+Conditions are less blunt than failure, and less cumbersome than the `Option` or `Result` types;\n+indeed they are designed to strike just the right balance between the two.\n+Conditions require some care to use effectively, but give maximum flexibility with minimum verbosity.\n+While conditions use exception-like terminology (\"trap\", \"raise\") they are significantly different:\n+\n+  - Like exceptions and failure, conditions separate the site at which the error is raised from the site where it is trapped.\n+  - Unlike exceptions and unlike failure, when a condition is raised and trapped, _no unwinding occurs_.\n+  - A successfully trapped condition causes execution to continue _at the site of the error_, as though no error occurred.\n+\n+Conditions are declared with the `condition!` macro.\n+Each condition has a name, an input type and an output type, much like a function.\n+In fact, conditions are implemented as dynamically-scoped functions held in task local storage.\n+\n+The `condition!` macro declares a module with the name of the condition;\n+the module contains a single static value called `cond`, of type `std::condition::Condition`.\n+The `cond` value within the module is the rendezvous point\n+between the site of error and the site that handles the error.\n+It has two methods of interest: `raise` and `trap`.\n+\n+The `raise` method maps a value of the condition's input type to its output type.\n+The input type should therefore convey all relevant information to the condition handler.\n+The output type should convey all relevant information _for continuing execution at the site of error_.\n+When the error site raises a condition handler,\n+the `Condition::raise` method searches task-local storage (TLS) for the innermost installed _handler_,\n+and if any such handler is found, calls it with the provided input value.\n+If no handler is found, `Condition::raise` will fail the task with an appropriate error message.\n+\n+Rewriting the example to use a condition in place of ignoring malformed lines makes it slightly longer,\n+but similarly clear as the version that used `fail!` in the logic where the error occurs:\n+\n+~~~~ {.xfail-test}\n+# #[allow(unused_imports)];\n+extern mod extra;\n+use extra::fileinput::FileInput;\n+use std::int;\n+# mod FileInput {\n+#    use std::io::{Reader, BytesReader};\n+#    static s : &'static [u8] = bytes!(\"1 2\\n\\\n+#                                       34 56\\n\\\n+#                                       ostrich\\n\\\n+#                                       789 123\\n\\\n+#                                       45 67\\n\\\n+#                                       \");\n+#    pub fn from_args() -> @Reader{\n+#        @BytesReader {\n+#            bytes: s,\n+#            pos: @mut 0\n+#        } as @Reader\n+#    }\n+# }\n+\n+// Introduce a new condition.\n+condition! {\n+    pub malformed_line : ~str -> (int,int);\n+}\n+\n+fn main() {\n+    let pairs = read_int_pairs();\n+    for &(a,b) in pairs.iter() {\n+        println(fmt!(\"%4.4d, %4.4d\", a, b));\n+    }\n+}\n+\n+fn read_int_pairs() -> ~[(int,int)] {\n+    let mut pairs = ~[];\n+    let fi = FileInput::from_args();\n+    while ! fi.eof() {\n+        let line = fi.read_line();\n+        let fields = line.word_iter().to_owned_vec();\n+        match fields {\n+            [a, b] => pairs.push((int::from_str(a).unwrap(),\n+                                  int::from_str(b).unwrap())),\n+\n+            // On malformed lines, call the condition handler and\n+            // push whatever the condition handler returns.\n+            _ => pairs.push(malformed_line::cond.raise(line.clone()))\n+        }\n+    }\n+    pairs\n+}\n+~~~~\n+\n+When this is run on malformed input, it still fails,\n+but with a slightly different failure message than before:\n+\n+~~~~ {.notrust}\n+$ ./example bad.txt\n+rust: task failed at 'Unhandled condition: malformed_line: ~\"ostrich\"', .../libstd/condition.rs:43\n+~~~~\n+\n+While this superficially resembles the trapped `fail!` call before,\n+it is only because the example did not install a handler for the condition.\n+The different failure message is indicating, among other things,\n+that the condition-handling system is being invoked and failing\n+only due to the absence of a _handler_ that traps the condition.\n+\n+# Trapping a condition\n+\n+To trap a condition, use `Condition::trap` in some caller of the site that calls `Condition::raise`.\n+For example, this version of the program traps the `malformed_line` condition\n+and replaces bad input lines with the pair `(-1,-1)`:\n+\n+~~~~\n+# #[allow(unused_imports)];\n+extern mod extra;\n+use extra::fileinput::FileInput;\n+use std::int;\n+# mod FileInput {\n+#    use std::io::{Reader, BytesReader};\n+#    static s : &'static [u8] = bytes!(\"1 2\\n\\\n+#                                       34 56\\n\\\n+#                                       ostrich\\n\\\n+#                                       789 123\\n\\\n+#                                       45 67\\n\\\n+#                                       \");\n+#    pub fn from_args() -> @Reader{\n+#        @BytesReader {\n+#            bytes: s,\n+#            pos: @mut 0\n+#        } as @Reader\n+#    }\n+# }\n+\n+condition! {\n+    pub malformed_line : ~str -> (int,int);\n+}\n+\n+fn main() {\n+    // Trap the condition:\n+    do malformed_line::cond.trap(|_| (-1,-1)).inside {\n+\n+        // The protected logic.\n+        let pairs = read_int_pairs();\n+        for &(a,b) in pairs.iter() {\n+                println(fmt!(\"%4.4d, %4.4d\", a, b));\n+        }\n+\n+    }\n+}\n+\n+fn read_int_pairs() -> ~[(int,int)] {\n+    let mut pairs = ~[];\n+    let fi = FileInput::from_args();\n+    while ! fi.eof() {\n+        let line = fi.read_line();\n+        let fields = line.word_iter().to_owned_vec();\n+        match fields {\n+            [a, b] => pairs.push((int::from_str(a).unwrap(),\n+                                  int::from_str(b).unwrap())),\n+            _ => pairs.push(malformed_line::cond.raise(line.clone()))\n+        }\n+    }\n+    pairs\n+}\n+~~~~\n+\n+Note that the remainder of the program is _unchanged_ with this trap in place;\n+only the caller that installs the trap changed.\n+Yet when the condition-trapping variant runs on the malformed input,\n+it continues execution past the malformed line, substituting the handler's return value.\n+\n+~~~~ {.notrust}\n+$ ./example bad.txt\n+0001, 0002\n+0034, 0056\n+-0001, -0001\n+0789, 0123\n+0045, 0067\n+~~~~\n+\n+# Refining a condition\n+\n+As you work with a condition, you may find that the original set of options you present for recovery is insufficient.\n+This is no different than any other issue of API design:\n+a condition handler is an API for recovering from the condition, and sometimes APIs need to be enriched.\n+In the example program, the first form of the `malformed_line` API implicitly assumes that recovery involves a substitute value.\n+This assumption may not be correct; some callers may wish to skip malformed lines, for example.\n+Changing the condition's return type from `(int,int)` to `Option<(int,int)>` will suffice to support this type of recovery:\n+\n+~~~~\n+# #[allow(unused_imports)];\n+extern mod extra;\n+use extra::fileinput::FileInput;\n+use std::int;\n+# mod FileInput {\n+#    use std::io::{Reader, BytesReader};\n+#    static s : &'static [u8] = bytes!(\"1 2\\n\\\n+#                                       34 56\\n\\\n+#                                       ostrich\\n\\\n+#                                       789 123\\n\\\n+#                                       45 67\\n\\\n+#                                       \");\n+#    pub fn from_args() -> @Reader{\n+#        @BytesReader {\n+#            bytes: s,\n+#            pos: @mut 0\n+#        } as @Reader\n+#    }\n+# }\n+\n+// Modify the condition signature to return an Option.\n+condition! {\n+    pub malformed_line : ~str -> Option<(int,int)>;\n+}\n+\n+fn main() {\n+    // Trap the condition and return `None`\n+    do malformed_line::cond.trap(|_| None).inside {\n+\n+        // The protected logic.\n+        let pairs = read_int_pairs();\n+        for &(a,b) in pairs.iter() {\n+            println(fmt!(\"%4.4d, %4.4d\", a, b));\n+        }\n+\n+    }\n+}\n+\n+fn read_int_pairs() -> ~[(int,int)] {\n+    let mut pairs = ~[];\n+    let fi = FileInput::from_args();\n+    while ! fi.eof() {\n+        let line = fi.read_line();\n+        let fields = line.word_iter().to_owned_vec();\n+        match fields {\n+            [a, b] => pairs.push((int::from_str(a).unwrap(),\n+                                  int::from_str(b).unwrap())),\n+\n+            // On malformed lines, call the condition handler and\n+            // either ignore the line (if the handler returns `None`)\n+            // or push any `Some(pair)` value returned instead.\n+            _ => {\n+                match malformed_line::cond.raise(line.clone()) {\n+                    Some(pair) => pairs.push(pair),\n+                    None => ()\n+                }\n+            }\n+        }\n+    }\n+    pairs\n+}\n+~~~~\n+\n+Again, note that the remainder of the program is _unchanged_,\n+in particular the signature of `read_int_pairs` is unchanged,\n+even though the innermost part of its reading-loop has a new way of handling a malformed line.\n+When the example is run with the `None` trap in place,\n+the line is ignored as it was in the first example,\n+but the choice of whether to ignore or use a substitute value has been moved to some caller,\n+possibly a distant caller.\n+\n+~~~~ {.notrust}\n+$ ./example bad.txt\n+0001, 0002\n+0034, 0056\n+0789, 0123\n+0045, 0067\n+~~~~\n+\n+# Further refining a condition\n+\n+Like with any API, the process of refining argument and return types of a condition will continue,\n+until all relevant combinations encountered in practice are encoded.\n+In the example, suppose a third possible recovery form arose: reusing the previous value read.\n+This can be encoded in the handler API by introducing a helper type: `enum MalformedLineFix`.\n+\n+~~~~\n+# #[allow(unused_imports)];\n+extern mod extra;\n+use extra::fileinput::FileInput;\n+use std::int;\n+# mod FileInput {\n+#    use std::io::{Reader, BytesReader};\n+#    static s : &'static [u8] = bytes!(\"1 2\\n\\\n+#                                       34 56\\n\\\n+#                                       ostrich\\n\\\n+#                                       789 123\\n\\\n+#                                       45 67\\n\\\n+#                                       \");\n+#    pub fn from_args() -> @Reader{\n+#        @BytesReader {\n+#            bytes: s,\n+#            pos: @mut 0\n+#        } as @Reader\n+#    }\n+# }\n+\n+// Introduce a new enum to convey condition-handling strategy to error site.\n+pub enum MalformedLineFix {\n+     UsePair(int,int),\n+     IgnoreLine,\n+     UsePreviousLine\n+}\n+\n+// Modify the condition signature to return the new enum.\n+// Note: a condition introduces a new module, so the enum must be\n+// named with the `super::` prefix to access it.\n+condition! {\n+    pub malformed_line : ~str -> super::MalformedLineFix;\n+}\n+\n+fn main() {\n+    // Trap the condition and return `UsePreviousLine`\n+    do malformed_line::cond.trap(|_| UsePreviousLine).inside {\n+\n+        // The protected logic.\n+        let pairs = read_int_pairs();\n+        for &(a,b) in pairs.iter() {\n+            println(fmt!(\"%4.4d, %4.4d\", a, b));\n+        }\n+\n+    }\n+}\n+\n+fn read_int_pairs() -> ~[(int,int)] {\n+    let mut pairs = ~[];\n+    let fi = FileInput::from_args();\n+    while ! fi.eof() {\n+        let line = fi.read_line();\n+        let fields = line.word_iter().to_owned_vec();\n+        match fields {\n+            [a, b] => pairs.push((int::from_str(a).unwrap(),\n+                                  int::from_str(b).unwrap())),\n+\n+            // On malformed lines, call the condition handler and\n+            // take action appropriate to the enum value returned.\n+            _ => {\n+                match malformed_line::cond.raise(line.clone()) {\n+                    UsePair(a,b) => pairs.push((a,b)),\n+                    IgnoreLine => (),\n+                    UsePreviousLine => {\n+                        let prev = pairs[pairs.len() - 1];\n+                        pairs.push(prev)\n+                    }\n+                }\n+            }\n+        }\n+    }\n+    pairs\n+}\n+~~~~\n+\n+Running the example with `UsePreviousLine` as the fix code returned from the handler\n+gives the expected result:\n+\n+~~~~ {.notrust}\n+$ ./example bad.txt\n+0001, 0002\n+0034, 0056\n+0034, 0056\n+0789, 0123\n+0045, 0067\n+~~~~\n+\n+At this point the example has a rich variety of recovery options,\n+none of which is visible to casual users of the `read_int_pairs` function.\n+This is intentional: part of the purpose of using a condition\n+is to free intermediate callers from the burden of having to write repetitive error-propagation logic,\n+and/or having to change function call and return types as error-handling strategies are refined.\n+\n+# Multiple conditions, intermediate callers\n+\n+So far the function trapping the condition and the function raising it have been immediately adjacent in the call stack.\n+That is, the caller traps and its immediate callee raises.\n+In most programs, the function that traps may be separated by very many function calls from the function that raises.\n+Again, this is part of the point of using conditions:\n+to support that separation without having to thread multiple error values and recovery strategies all the way through the program's main logic.\n+\n+Careful readers will notice that there is a remaining failure mode in the example program: the call to `.unwrap()` when parsing each integer.\n+For example, when presented with a file that has the correct number of fields on a line,\n+but a non-numeric value in one of them, such as this:\n+\n+~~~~ {.notrust}\n+$ cat bad.txt\n+1 2\n+34 56\n+7 marmot\n+789 123\n+45 67\n+~~~~\n+\n+\n+Then the program fails once more:\n+\n+~~~~ {.notrust}\n+$ ./example bad.txt\n+task <unnamed> failed at 'called `Option::unwrap()` on a `None` value', .../libstd/option.rs:314\n+~~~~\n+\n+To make the program robust -- or at least flexible -- in the face of this potential failure,\n+a second condition and a helper function will suffice:\n+\n+~~~~\n+# #[allow(unused_imports)];\n+extern mod extra;\n+use extra::fileinput::FileInput;\n+use std::int;\n+# mod FileInput {\n+#    use std::io::{Reader, BytesReader};\n+#    static s : &'static [u8] = bytes!(\"1 2\\n\\\n+#                                       34 56\\n\\\n+#                                       7 marmot\\n\\\n+#                                       789 123\\n\\\n+#                                       45 67\\n\\\n+#                                       \");\n+#    pub fn from_args() -> @Reader{\n+#        @BytesReader {\n+#            bytes: s,\n+#            pos: @mut 0\n+#        } as @Reader\n+#    }\n+# }\n+\n+pub enum MalformedLineFix {\n+     UsePair(int,int),\n+     IgnoreLine,\n+     UsePreviousLine\n+}\n+\n+condition! {\n+    pub malformed_line : ~str -> ::MalformedLineFix;\n+}\n+\n+// Introduce a second condition.\n+condition! {\n+    pub malformed_int : ~str -> int;\n+}\n+\n+fn main() {\n+    // Trap the `malformed_int` condition and return -1\n+    do malformed_int::cond.trap(|_| -1).inside {\n+\n+        // Trap the `malformed_line` condition and return `UsePreviousLine`\n+        do malformed_line::cond.trap(|_| UsePreviousLine).inside {\n+\n+            // The protected logic.\n+            let pairs = read_int_pairs();\n+            for &(a,b) in pairs.iter() {\n+                println(fmt!(\"%4.4d, %4.4d\", a, b));\n+            }\n+\n+        }\n+    }\n+}\n+\n+// Parse an int; if parsing fails, call the condition handler and\n+// return whatever it returns.\n+fn parse_int(x: &str) -> int {\n+    match int::from_str(x) {\n+        Some(v) => v,\n+        None => malformed_int::cond.raise(x.to_owned())\n+    }\n+}\n+\n+fn read_int_pairs() -> ~[(int,int)] {\n+    let mut pairs = ~[];\n+    let fi = FileInput::from_args();\n+    while ! fi.eof() {\n+        let line = fi.read_line();\n+        let fields = line.word_iter().to_owned_vec();\n+        match fields {\n+\n+            // Delegate parsing ints to helper function that will\n+            // handle parse errors by calling `malformed_int`.\n+            [a, b] => pairs.push((parse_int(a), parse_int(b))),\n+\n+            _ => {\n+                match malformed_line::cond.raise(line.clone()) {\n+                    UsePair(a,b) => pairs.push((a,b)),\n+                    IgnoreLine => (),\n+                    UsePreviousLine => {\n+                        let prev = pairs[pairs.len() - 1];\n+                        pairs.push(prev)\n+                    }\n+                }\n+            }\n+        }\n+    }\n+    pairs\n+}\n+~~~~\n+\n+Again, note that `read_int_pairs` has not changed signature,\n+nor has any of the machinery for trapping or raising `malformed_line`,\n+but now the program can handle the \"right number of fields, non-integral field\" form of bad input:\n+\n+~~~~ {.notrust}\n+$ ./example bad.txt\n+0001, 0002\n+0034, 0056\n+0007, -0001\n+0789, 0123\n+0045, 0067\n+~~~~\n+\n+There are three other things to note in this variant of the example program:\n+\n+  - It traps multiple conditions simultaneously,\n+    nesting the protected logic of one `trap` call inside the other.\n+\n+  - There is a function in between the `trap` site and `raise` site for the `malformed_int` condition.\n+    There could be any number of calls between them:\n+    so long as the `raise` occurs within a callee (of any depth) of the logic protected by the `trap` call,\n+    it will invoke the handler.\n+\n+  - This variant insulates callers from a design choice in the `int` library:\n+    the `int::from_str` function was designed to return an `Option<int>`,\n+    but this program insulates callers from that choice,\n+    routing all `None` values that arise from parsing integers in this file into the condition.\n+\n+\n+# When to use which technique\n+\n+This tutorial explored several techniques for handling errors.\n+Each is appropriate to different circumstances:\n+\n+  - If an error may be extremely frequent, expected, and very likely dealt with by an immediate caller,\n+    then returning an `Option` or `Result` type is best. These types force the caller to handle the error,\n+    and incur the lowest speed overhead, usually only returning one extra word to tag the return value.\n+    Between `Option` and `Result`: use an `Option` when there is only one kind of error,\n+    otherwise make an `enum FooErr` to represent the possible error codes and use `Result<T,FooErr>`.\n+\n+  - If an error can reasonably be handled at the site it occurs by one of a few strategies -- possibly including failure --\n+    and it is not clear which strategy a caller would want to use, a condition is best.\n+    For many errors, the only reasonable \"non-stop\" recovery strategies are to retry some number of times,\n+    create or substitute an empty or sentinel value, ignore the error, or fail.\n+\n+  - If an error cannot reasonably be handled at the site it occurs,\n+    and the only reasonable response is to abandon a large set of operations in progress,\n+    then directly failing is best.\n+\n+Note that an unhandled condition will cause failure (along with a more-informative-than-usual message),\n+so if there is any possibility that a caller might wish to \"ignore and keep going\",\n+it is usually harmless to use a condition in place of a direct call to `fail!()`.\n+\n+\n+[^why-no-exceptions]: Exceptions in languages like C++ and Java permit unwinding, like Rust's failure system,\n+but with the option to halt unwinding partway through the process and continue execution.\n+This behavior unfortunately means that the _heap_ may be left in an inconsistent but accessible state,\n+if an exception is thrown part way through the process of initializing or modifying memory.\n+To compensate for this risk, correct C++ and Java code must program in an extremely elaborate and difficult \"exception-safe\" style\n+-- effectively transactional style against heap structures --\n+or else risk introducing silent and very difficult-to-debug errors due to control resuming in a corrupted heap after a caught exception.\n+These errors are frequently memory-safety errors, which Rust strives to eliminate,\n+and so Rust unwinding is unrecoverable within a single task:\n+once unwinding starts, the entire local heap of a task is destroyed and the task is terminated.\n\\ No newline at end of file"}, {"sha": "7e3da1c86b11cf4d000c8b27089a04f9c391b8e4", "filename": "mk/docs.mk", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3cd978fbc75a691a144dcafe99a08531a424fcd0/mk%2Fdocs.mk", "raw_url": "https://github.com/rust-lang/rust/raw/3cd978fbc75a691a144dcafe99a08531a424fcd0/mk%2Fdocs.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fdocs.mk?ref=3cd978fbc75a691a144dcafe99a08531a424fcd0", "patch": "@@ -150,6 +150,16 @@ doc/tutorial-tasks.html: tutorial-tasks.md doc/version_info.html doc/rust.css\n \t   --include-before-body=doc/version_info.html \\\n            --output=$@\n \n+DOCS += doc/tutorial-conditions.html\n+doc/tutorial-conditions.html: tutorial-conditions.md doc/version_info.html doc/rust.css\n+\t@$(call E, pandoc: $@)\n+\t$(Q)$(CFG_NODE) $(S)doc/prep.js --highlight $< | \\\n+          $(CFG_PANDOC) --standalone --toc \\\n+           --section-divs --number-sections \\\n+           --from=markdown --to=html --css=rust.css \\\n+           --include-before-body=doc/version_info.html \\\n+           --output=$@\n+\n   ifeq ($(CFG_PDFLATEX),)\n     $(info cfg: no pdflatex found, omitting doc/rust.pdf)\n   else"}, {"sha": "4732f808457f30589fc06accce38103bae0aae3b", "filename": "mk/tests.mk", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3cd978fbc75a691a144dcafe99a08531a424fcd0/mk%2Ftests.mk", "raw_url": "https://github.com/rust-lang/rust/raw/3cd978fbc75a691a144dcafe99a08531a424fcd0/mk%2Ftests.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Ftests.mk?ref=3cd978fbc75a691a144dcafe99a08531a424fcd0", "patch": "@@ -19,7 +19,8 @@ TEST_HOST_CRATES = rust rusti rustpkg rustc rustdoc syntax\n TEST_CRATES = $(TEST_TARGET_CRATES) $(TEST_HOST_CRATES)\n \n # Markdown files under doc/ that should have their code extracted and run\n-DOC_TEST_NAMES = tutorial tutorial-ffi tutorial-macros tutorial-borrowed-ptr tutorial-tasks rust\n+DOC_TEST_NAMES = tutorial tutorial-ffi tutorial-macros tutorial-borrowed-ptr \\\n+                 tutorial-tasks tutorial-conditions rust\n \n ######################################################################\n # Environment configuration"}]}