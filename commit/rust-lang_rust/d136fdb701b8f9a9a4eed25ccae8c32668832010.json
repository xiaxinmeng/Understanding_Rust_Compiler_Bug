{"sha": "d136fdb701b8f9a9a4eed25ccae8c32668832010", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQxMzZmZGI3MDFiOGY5YTlhNGVlZDI1Y2NhZThjMzI2Njg4MzIwMTA=", "commit": {"author": {"name": "Oliver S\u0336c\u0336h\u0336n\u0336e\u0336i\u0336d\u0336e\u0336r Scherer", "email": "github35764891676564198441@oli-obk.de", "date": "2018-11-08T19:22:54Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2018-11-08T19:22:54Z"}, "message": "Merge pull request #513 from RalfJung/new-interior-mut\n\nNew Stacked Borrows, now with better support for interior mutability", "tree": {"sha": "4f68d4042efe1d7096bc7839ac87dadba95243f2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4f68d4042efe1d7096bc7839ac87dadba95243f2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d136fdb701b8f9a9a4eed25ccae8c32668832010", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJb5I0OCRBK7hj4Ov3rIwAAdHIIAD46snkejuXZApVT4eNM393b\nuYNsORIanVcUVHGY+Vl6SiBQG2O0/hgpTdXxQXOenqf8L2WLpUoKnCeL6HXpXKkq\nqvqZ7AYmIo56MRsAzZvjBSYHBmix4NbYjefrEtTFYgGzvJBAwwUUa/m5NKpiReqL\n90+w/FVtkzQvF+MDwykgtyT3y1qaMyM+kbbNJFCNl+MiHJAlOLCQKPEnHiiJCWm4\nTrs/Bq8Lh9xuIYbEFmVYmayU+scfoZDfKdyOUxNeMQ2DydLEaVaA0Hu+m6dmY0cN\n0JBTAUafFTXrTPMoLXNbmkFyGhZ9iIZYLkDPIlxfYMFdyZV/zDkC3nnMDYoCYcE=\n=j86R\n-----END PGP SIGNATURE-----\n", "payload": "tree 4f68d4042efe1d7096bc7839ac87dadba95243f2\nparent d0b79cf53b933bdade1be041b74d9d06a661d84f\nparent d694dc43f4e4c459f908b8ded939fa1fc359ad9a\nauthor Oliver S\u0336c\u0336h\u0336n\u0336e\u0336i\u0336d\u0336e\u0336r Scherer <github35764891676564198441@oli-obk.de> 1541704974 +0100\ncommitter GitHub <noreply@github.com> 1541704974 +0100\n\nMerge pull request #513 from RalfJung/new-interior-mut\n\nNew Stacked Borrows, now with better support for interior mutability"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d136fdb701b8f9a9a4eed25ccae8c32668832010", "html_url": "https://github.com/rust-lang/rust/commit/d136fdb701b8f9a9a4eed25ccae8c32668832010", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d136fdb701b8f9a9a4eed25ccae8c32668832010/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d0b79cf53b933bdade1be041b74d9d06a661d84f", "url": "https://api.github.com/repos/rust-lang/rust/commits/d0b79cf53b933bdade1be041b74d9d06a661d84f", "html_url": "https://github.com/rust-lang/rust/commit/d0b79cf53b933bdade1be041b74d9d06a661d84f"}, {"sha": "d694dc43f4e4c459f908b8ded939fa1fc359ad9a", "url": "https://api.github.com/repos/rust-lang/rust/commits/d694dc43f4e4c459f908b8ded939fa1fc359ad9a", "html_url": "https://github.com/rust-lang/rust/commit/d694dc43f4e4c459f908b8ded939fa1fc359ad9a"}], "stats": {"total": 818, "additions": 472, "deletions": 346}, "files": [{"sha": "f686cc47449dd8f55892d3ca39fe1a04b02c30ae", "filename": "cargo-miri-test/run-test.py", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d136fdb701b8f9a9a4eed25ccae8c32668832010/cargo-miri-test%2Frun-test.py", "raw_url": "https://github.com/rust-lang/rust/raw/d136fdb701b8f9a9a4eed25ccae8c32668832010/cargo-miri-test%2Frun-test.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/cargo-miri-test%2Frun-test.py?ref=d136fdb701b8f9a9a4eed25ccae8c32668832010", "patch": "@@ -10,9 +10,8 @@\n def test_cargo_miri():\n     print(\"==> Testing `cargo miri` <==\")\n     ## Call `cargo miri`, capture all output\n-    # FIXME: Disabling validation, still investigating whether there is UB here\n     p = subprocess.Popen(\n-        [\"cargo\", \"miri\", \"-q\", \"--\", \"-Zmiri-disable-validation\"],\n+        [\"cargo\", \"miri\", \"-q\"],\n         stdout=subprocess.PIPE,\n         stderr=subprocess.PIPE\n     )"}, {"sha": "0ad815872411a3d1c43d690d084a668da29dc705", "filename": "rust-version", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d136fdb701b8f9a9a4eed25ccae8c32668832010/rust-version", "raw_url": "https://github.com/rust-lang/rust/raw/d136fdb701b8f9a9a4eed25ccae8c32668832010/rust-version", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/rust-version?ref=d136fdb701b8f9a9a4eed25ccae8c32668832010", "patch": "@@ -1 +1 @@\n-nightly-2018-11-07\n+nightly-2018-11-08"}, {"sha": "880b18c7d5426c4afa0c3ec320eda75252af8954", "filename": "src/helpers.rs", "status": "modified", "additions": 159, "deletions": 1, "changes": 160, "blob_url": "https://github.com/rust-lang/rust/blob/d136fdb701b8f9a9a4eed25ccae8c32668832010/src%2Fhelpers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d136fdb701b8f9a9a4eed25ccae8c32668832010/src%2Fhelpers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fhelpers.rs?ref=d136fdb701b8f9a9a4eed25ccae8c32668832010", "patch": "@@ -1,6 +1,6 @@\n use std::mem;\n \n-use rustc::ty;\n+use rustc::ty::{self, layout};\n use rustc::hir::def_id::{DefId, CRATE_DEF_INDEX};\n \n use crate::*;\n@@ -32,6 +32,15 @@ impl<Tag> ScalarExt for ScalarMaybeUndef<Tag> {\n \n pub trait EvalContextExt<'tcx> {\n     fn resolve_path(&self, path: &[&str]) -> EvalResult<'tcx, ty::Instance<'tcx>>;\n+\n+    /// Visit the memory covered by `place` that is frozen -- i.e., NOT\n+    /// what is inside an `UnsafeCell`.\n+    fn visit_frozen(\n+        &self,\n+        place: MPlaceTy<'tcx, Borrow>,\n+        size: Size,\n+        action: impl FnMut(Pointer<Borrow>, Size) -> EvalResult<'tcx>,\n+    ) -> EvalResult<'tcx>;\n }\n \n \n@@ -69,4 +78,153 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'mir, 'tcx, super:\n                 EvalErrorKind::PathNotFound(path).into()\n             })\n     }\n+\n+    /// Visit the memory covered by `place` that is frozen -- i.e., NOT\n+    /// what is inside an `UnsafeCell`.\n+    fn visit_frozen(\n+        &self,\n+        place: MPlaceTy<'tcx, Borrow>,\n+        size: Size,\n+        mut frozen_action: impl FnMut(Pointer<Borrow>, Size) -> EvalResult<'tcx>,\n+    ) -> EvalResult<'tcx> {\n+        trace!(\"visit_frozen(place={:?}, size={:?})\", *place, size);\n+        debug_assert_eq!(size,\n+            self.size_and_align_of_mplace(place)?\n+            .map(|(size, _)| size)\n+            .unwrap_or_else(|| place.layout.size)\n+        );\n+        // Store how far we proceeded into the place so far.  Everything to the left of\n+        // this offset has already been handled, in the sense that the frozen parts\n+        // have had `action` called on them.\n+        let mut end_ptr = place.ptr;\n+        // Called when we detected an `UnsafeCell` at the given offset and size.\n+        // Calls `action` and advances `end_ptr`.\n+        let mut unsafe_cell_action = |unsafe_cell_offset, unsafe_cell_size| {\n+            // We assume that we are given the fields in increasing offset order,\n+            // and nothing else changes.\n+            let end_offset = end_ptr.get_ptr_offset(self);\n+            assert!(unsafe_cell_offset >= end_offset);\n+            let frozen_size = unsafe_cell_offset - end_offset;\n+            // Everything between the end_ptr and this `UnsafeCell` is frozen.\n+            if frozen_size != Size::ZERO {\n+                frozen_action(end_ptr.to_ptr()?, frozen_size)?;\n+            }\n+            // Update end end_ptr.\n+            end_ptr = end_ptr.ptr_wrapping_offset(frozen_size+unsafe_cell_size, self);\n+            // Done\n+            Ok(())\n+        };\n+        // Run a visitor\n+        {\n+            let mut visitor = UnsafeCellVisitor {\n+                ecx: self,\n+                unsafe_cell_action: |place| {\n+                    trace!(\"unsafe_cell_action on {:?}\", place.ptr);\n+                    // We need a size to go on.\n+                    let (unsafe_cell_size, _) = self.size_and_align_of_mplace(place)?\n+                        // for extern types, just cover what we can\n+                        .unwrap_or_else(|| place.layout.size_and_align());\n+                    // Now handle this `UnsafeCell`, unless it is empty.\n+                    if unsafe_cell_size != Size::ZERO {\n+                        unsafe_cell_action(place.ptr.get_ptr_offset(self), unsafe_cell_size)\n+                    } else {\n+                        Ok(())\n+                    }\n+                },\n+            };\n+            visitor.visit_value(place)?;\n+        }\n+        // The part between the end_ptr and the end of the place is also frozen.\n+        // So pretend there is a 0-sized `UnsafeCell` at the end.\n+        unsafe_cell_action(place.ptr.get_ptr_offset(self) + size, Size::ZERO)?;\n+        // Done!\n+        return Ok(());\n+\n+        /// Visiting the memory covered by a `MemPlace`, being aware of\n+        /// whether we are inside an `UnsafeCell` or not.\n+        struct UnsafeCellVisitor<'ecx, 'a, 'mir, 'tcx, F>\n+            where F: FnMut(MPlaceTy<'tcx, Borrow>) -> EvalResult<'tcx>\n+        {\n+            ecx: &'ecx MiriEvalContext<'a, 'mir, 'tcx>,\n+            unsafe_cell_action: F,\n+        }\n+\n+        impl<'ecx, 'a, 'mir, 'tcx, F> ValueVisitor<'a, 'mir, 'tcx, Evaluator<'tcx>>\n+        for UnsafeCellVisitor<'ecx, 'a, 'mir, 'tcx, F>\n+        where\n+            F: FnMut(MPlaceTy<'tcx, Borrow>) -> EvalResult<'tcx>\n+        {\n+            type V = MPlaceTy<'tcx, Borrow>;\n+\n+            #[inline(always)]\n+            fn ecx(&self) -> &MiriEvalContext<'a, 'mir, 'tcx> {\n+                &self.ecx\n+            }\n+\n+            // Hook to detect `UnsafeCell`\n+            fn visit_value(&mut self, v: MPlaceTy<'tcx, Borrow>) -> EvalResult<'tcx>\n+            {\n+                trace!(\"UnsafeCellVisitor: {:?} {:?}\", *v, v.layout.ty);\n+                let is_unsafe_cell = match v.layout.ty.sty {\n+                    ty::Adt(adt, _) => Some(adt.did) == self.ecx.tcx.lang_items().unsafe_cell_type(),\n+                    _ => false,\n+                };\n+                if is_unsafe_cell {\n+                    // We do not have to recurse further, this is an `UnsafeCell`.\n+                    (self.unsafe_cell_action)(v)\n+                } else if self.ecx.type_is_freeze(v.layout.ty) {\n+                    // This is `Freeze`, there cannot be an `UnsafeCell`\n+                    Ok(())\n+                } else {\n+                    // Proceed further\n+                    self.walk_value(v)\n+                }\n+            }\n+\n+            // Make sure we visit aggregrates in increasing offset order\n+            fn visit_aggregate(\n+                &mut self,\n+                place: MPlaceTy<'tcx, Borrow>,\n+                fields: impl Iterator<Item=EvalResult<'tcx, MPlaceTy<'tcx, Borrow>>>,\n+            ) -> EvalResult<'tcx> {\n+                match place.layout.fields {\n+                    layout::FieldPlacement::Array { .. } => {\n+                        // For the array layout, we know the iterator will yield sorted elements so\n+                        // we can avoid the allocation.\n+                        self.walk_aggregate(place, fields)\n+                    }\n+                    layout::FieldPlacement::Arbitrary { .. } => {\n+                        // Gather the subplaces and sort them before visiting.\n+                        let mut places = fields.collect::<EvalResult<'tcx, Vec<MPlaceTy<'tcx, Borrow>>>>()?;\n+                        places[..].sort_by_key(|place| place.ptr.get_ptr_offset(self.ecx()));\n+                        self.walk_aggregate(place, places.into_iter().map(Ok))\n+                    }\n+                    layout::FieldPlacement::Union { .. } => {\n+                        // Uh, what?\n+                        bug!(\"A union is not an aggregate we should ever visit\")\n+                    }\n+                }\n+            }\n+\n+            // We have to do *something* for unions\n+            fn visit_union(&mut self, v: MPlaceTy<'tcx, Borrow>) -> EvalResult<'tcx>\n+            {\n+                // With unions, we fall back to whatever the type says, to hopefully be consistent\n+                // with LLVM IR.\n+                // FIXME Are we consistent?  And is this really the behavior we want?\n+                let frozen = self.ecx.type_is_freeze(v.layout.ty);\n+                if frozen {\n+                    Ok(())\n+                } else {\n+                    (self.unsafe_cell_action)(v)\n+                }\n+            }\n+\n+            // We should never get to a primitive, but always short-circuit somewhere above\n+            fn visit_primitive(&mut self, _val: ImmTy<'tcx, Borrow>) -> EvalResult<'tcx>\n+            {\n+                bug!(\"We should always short-circit before coming to a primitive\")\n+            }\n+        }\n+    }\n }"}, {"sha": "134986c814de0c543b1ab7598eb8150fae938c83", "filename": "src/lib.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/d136fdb701b8f9a9a4eed25ccae8c32668832010/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d136fdb701b8f9a9a4eed25ccae8c32668832010/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=d136fdb701b8f9a9a4eed25ccae8c32668832010", "patch": "@@ -17,7 +17,7 @@ use std::collections::HashMap;\n use std::borrow::Cow;\n use std::env;\n \n-use rustc::ty::{self, Ty, TyCtxt, query::TyCtxtAt};\n+use rustc::ty::{self, TyCtxt, query::TyCtxtAt};\n use rustc::ty::layout::{TyLayout, LayoutOf, Size};\n use rustc::hir::{self, def_id::DefId};\n use rustc::mir;\n@@ -48,7 +48,7 @@ use crate::mono_hash_map::MonoHashMap;\n use crate::stacked_borrows::{EvalContextExt as StackedBorEvalContextExt};\n \n // Used by priroda\n-pub use crate::stacked_borrows::{Borrow, Stack, Stacks, Mut as MutBorrow, BorStackItem};\n+pub use crate::stacked_borrows::{Borrow, Stack, Stacks, BorStackItem};\n \n /// Insert rustc arguments at the beginning of the argument list that miri wants to be\n /// set per default, for maximal validation power.\n@@ -476,38 +476,38 @@ impl<'a, 'mir, 'tcx> Machine<'a, 'mir, 'tcx> for Evaluator<'tcx> {\n     #[inline(always)]\n     fn tag_reference(\n         ecx: &mut EvalContext<'a, 'mir, 'tcx, Self>,\n-        place: MemPlace<Borrow>,\n-        ty: Ty<'tcx>,\n-        size: Size,\n+        place: MPlaceTy<'tcx, Borrow>,\n         mutability: Option<hir::Mutability>,\n-    ) -> EvalResult<'tcx, MemPlace<Borrow>> {\n+    ) -> EvalResult<'tcx, Scalar<Borrow>> {\n+        let (size, _) = ecx.size_and_align_of_mplace(place)?\n+            // for extern types, just cover what we can\n+            .unwrap_or_else(|| place.layout.size_and_align());\n         if !ecx.machine.validate || size == Size::ZERO {\n             // No tracking\n-            Ok(place)\n+            Ok(place.ptr)\n         } else {\n             let ptr = place.ptr.to_ptr()?;\n-            let tag = ecx.tag_reference(ptr, ty, size, mutability.into())?;\n-            let ptr = Scalar::Ptr(Pointer::new_with_tag(ptr.alloc_id, ptr.offset, tag));\n-            Ok(MemPlace { ptr, ..place })\n+            let tag = ecx.tag_reference(place, size, mutability.into())?;\n+            Ok(Scalar::Ptr(Pointer::new_with_tag(ptr.alloc_id, ptr.offset, tag)))\n         }\n     }\n \n     #[inline(always)]\n     fn tag_dereference(\n         ecx: &EvalContext<'a, 'mir, 'tcx, Self>,\n-        place: MemPlace<Borrow>,\n-        ty: Ty<'tcx>,\n-        size: Size,\n+        place: MPlaceTy<'tcx, Borrow>,\n         mutability: Option<hir::Mutability>,\n-    ) -> EvalResult<'tcx, MemPlace<Borrow>> {\n+    ) -> EvalResult<'tcx, Scalar<Borrow>> {\n+        let (size, _) = ecx.size_and_align_of_mplace(place)?\n+            // for extern types, just cover what we can\n+            .unwrap_or_else(|| place.layout.size_and_align());\n         if !ecx.machine.validate || size == Size::ZERO {\n             // No tracking\n-            Ok(place)\n+            Ok(place.ptr)\n         } else {\n             let ptr = place.ptr.to_ptr()?;\n-            let tag = ecx.tag_dereference(ptr, ty, size, mutability.into())?;\n-            let ptr = Scalar::Ptr(Pointer::new_with_tag(ptr.alloc_id, ptr.offset, tag));\n-            Ok(MemPlace { ptr, ..place })\n+            let tag = ecx.tag_dereference(place, size, mutability.into())?;\n+            Ok(Scalar::Ptr(Pointer::new_with_tag(ptr.alloc_id, ptr.offset, tag)))\n         }\n     }\n "}, {"sha": "e1abcb20af756ca21e662a23d84ea9b3f2707d7d", "filename": "src/stacked_borrows.rs", "status": "modified", "additions": 260, "deletions": 236, "changes": 496, "blob_url": "https://github.com/rust-lang/rust/blob/d136fdb701b8f9a9a4eed25ccae8c32668832010/src%2Fstacked_borrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d136fdb701b8f9a9a4eed25ccae8c32668832010/src%2Fstacked_borrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstacked_borrows.rs?ref=d136fdb701b8f9a9a4eed25ccae8c32668832010", "patch": "@@ -1,80 +1,63 @@\n use std::cell::RefCell;\n \n-use rustc::ty::{self, Ty, layout::Size};\n+use rustc::ty::{self, layout::Size};\n use rustc::hir;\n \n use crate::{\n-    MemoryKind, MiriMemoryKind, RangeMap, EvalResult, AllocId,\n-    Pointer, PlaceTy,\n+    EvalResult, MiriEvalContext, HelpersEvalContextExt,\n+    MemoryKind, MiriMemoryKind, RangeMap, AllocId,\n+    Pointer, PlaceTy, MPlaceTy,\n };\n \n pub type Timestamp = u64;\n \n-/// Information about a potentially mutable borrow\n-#[derive(Copy, Clone, Debug, Hash, PartialEq, Eq)]\n-pub enum Mut {\n-    /// A unique, mutable reference\n-    Uniq(Timestamp),\n-    /// Any raw pointer, or a shared borrow with interior mutability\n-    Raw,\n-}\n-\n-impl Mut {\n-    #[inline(always)]\n-    pub fn is_raw(self) -> bool {\n-        match self {\n-            Mut::Raw => true,\n-            _ => false,\n-        }\n-    }\n-\n-    #[inline(always)]\n-    pub fn is_uniq(self) -> bool {\n-        match self {\n-            Mut::Uniq(_) => true,\n-            _ => false,\n-        }\n-    }\n-}\n-\n-/// Information about any kind of borrow\n+/// Information about which kind of borrow was used to create the reference this is tagged\n+/// with.\n #[derive(Copy, Clone, Debug, Hash, PartialEq, Eq)]\n pub enum Borrow {\n-    /// A mutable borrow, a raw pointer, or a shared borrow with interior mutability\n-    Mut(Mut),\n-    /// A shared borrow without interior mutability\n-    Frz(Timestamp)\n+    /// A unique (mutable) reference.\n+    Uniq(Timestamp),\n+    /// A shared reference.  This is also used by raw pointers, which do not track details\n+    /// of how or when they were created, hence the timestamp is optional.\n+    /// Shr(Some(_)) does NOT mean that the destination of this reference is frozen;\n+    /// that depends on the type!  Only those parts outside of an `UnsafeCell` are actually\n+    /// frozen.\n+    Shr(Option<Timestamp>),\n }\n \n impl Borrow {\n     #[inline(always)]\n-    pub fn is_uniq(self) -> bool {\n+    pub fn is_shr(self) -> bool {\n         match self {\n-            Borrow::Mut(m) => m.is_uniq(),\n+            Borrow::Shr(_) => true,\n             _ => false,\n         }\n     }\n \n     #[inline(always)]\n-    pub fn is_frz(self) -> bool {\n+    pub fn is_uniq(self) -> bool {\n         match self {\n-            Borrow::Frz(_) => true,\n+            Borrow::Uniq(_) => true,\n             _ => false,\n         }\n     }\n }\n \n impl Default for Borrow {\n     fn default() -> Self {\n-        Borrow::Mut(Mut::Raw)\n+        Borrow::Shr(None)\n     }\n }\n \n-/// An item in the borrow stack\n+/// An item in the per-location borrow stack\n #[derive(Copy, Clone, Debug, Hash, PartialEq, Eq)]\n pub enum BorStackItem {\n-    /// Defines which references are permitted to mutate *if* the location is not frozen\n-    Mut(Mut),\n+    /// Indicates the unique reference that may mutate.\n+    Uniq(Timestamp),\n+    /// Indicates that the location has been shared.  Used for raw pointers, but\n+    /// also for shared references.  The latter *additionally* get frozen\n+    /// when there is no `UnsafeCell`.\n+    Shr,\n     /// A barrier, tracking the function it belongs to by its index on the call stack\n     #[allow(dead_code)] // for future use\n     FnBarrier(usize)\n@@ -90,14 +73,37 @@ impl BorStackItem {\n     }\n }\n \n+/// Extra per-location state\n+#[derive(Clone, Debug)]\n+pub struct Stack {\n+    borrows: Vec<BorStackItem>, // used as a stack; never empty\n+    frozen_since: Option<Timestamp>, // virtual frozen \"item\" on top of the stack\n+}\n+\n+impl Default for Stack {\n+    fn default() -> Self {\n+        Stack {\n+            borrows: vec![BorStackItem::Shr],\n+            frozen_since: None,\n+        }\n+    }\n+}\n+\n+impl Stack {\n+    #[inline(always)]\n+    pub fn is_frozen(&self) -> bool {\n+        self.frozen_since.is_some()\n+    }\n+}\n+\n /// What kind of usage of the pointer are we talking about?\n #[derive(Copy, Clone, Debug, Hash, PartialEq, Eq)]\n pub enum UsageKind {\n     /// Write, or create &mut\n     Write,\n     /// Read, or create &\n     Read,\n-    /// Create *\n+    /// Create * (raw ptr)\n     Raw,\n }\n \n@@ -123,29 +129,6 @@ impl State {\n     }\n }\n \n-/// Extra per-location state\n-#[derive(Clone, Debug)]\n-pub struct Stack {\n-    borrows: Vec<BorStackItem>, // used as a stack\n-    frozen_since: Option<Timestamp>,\n-}\n-\n-impl Default for Stack {\n-    fn default() -> Self {\n-        Stack {\n-            borrows: vec![BorStackItem::Mut(Mut::Raw)],\n-            frozen_since: None,\n-        }\n-    }\n-}\n-\n-impl Stack {\n-    #[inline(always)]\n-    fn is_frozen(&self) -> bool {\n-        self.frozen_since.is_some()\n-    }\n-}\n-\n /// Extra per-allocation state\n #[derive(Clone, Debug, Default)]\n pub struct Stacks {\n@@ -156,124 +139,125 @@ pub struct Stacks {\n /// Core operations\n impl<'tcx> Stack {\n     /// Check if `bor` could be activated by unfreezing and popping.\n-    /// `usage` indicates whether this is being used to read/write (or, equivalently, to\n-    /// borrow as &/&mut), or to borrow as raw.\n-    /// Returns `Err` if the answer is \"no\"; otherwise the data says\n-    /// what needs to happen to activate this: `None` = nothing,\n-    /// `Some(n)` = unfreeze and make item `n` the top item of the stack.\n-    fn reactivatable(&self, bor: Borrow, usage: UsageKind) -> Result<Option<usize>, String> {\n-        let mut_borrow = match bor {\n-            Borrow::Frz(since) =>\n-                // The only way to reactivate a `Frz` is if this is already frozen.\n-                return match self.frozen_since {\n-                    _ if usage == UsageKind::Write =>\n-                        Err(format!(\"Using a shared borrow for mutation\")),\n-                    None =>\n-                        Err(format!(\"Location should be frozen but it is not\")),\n-                    Some(loc) if loc <= since =>\n-                        Ok(None),\n-                    Some(loc) =>\n-                        Err(format!(\"Location should be frozen since {} but it is only frozen \\\n-                                     since {}\", since, loc)),\n-                },\n-            Borrow::Mut(Mut::Raw) if self.is_frozen() && usage != UsageKind::Write =>\n-                // Non-mutating access with a raw from a frozen location is a special case: The\n-                // shared refs do not mind raw reads, and the raw itself does not assume any\n-                // exclusivity. So we do not even require there to be a raw on the stack,\n-                // the raw is instead \"matched\" by the fact that this location is frozen.\n-                // This does not break the assumption that an `&mut` we own is\n-                // exclusive for reads, because there we have the invariant that\n-                // the location is *not* frozen.\n-                return Ok(None),\n-            Borrow::Mut(mut_borrow) => mut_borrow\n-        };\n-        // See if we can get there via popping.\n-        for (idx, &itm) in self.borrows.iter().enumerate().rev() {\n-            match itm {\n-                BorStackItem::FnBarrier(_) =>\n-                    return Err(format!(\"Trying to reactivate a mutable borrow ({:?}) that lives \\\n-                                        behind a barrier\", mut_borrow)),\n-                BorStackItem::Mut(loc) => {\n-                    if loc == mut_borrow {\n-                        // We found it!  This is good to know.\n-                        // Yet, maybe we do not really want to pop?\n-                        if usage == UsageKind::Read && self.is_frozen() {\n-                            // Whoever had exclusive access to this location allowed it\n-                            // to become frozen.  That can only happen if they reborrowed\n-                            // to a shared ref, at which point they gave up on exclusive access.\n-                            // Hence we allow more reads, entirely ignoring everything above\n-                            // on the stack (but still making sure it is on the stack).\n-                            // This does not break the assumption that an `&mut` we own is\n-                            // exclusive for reads, because there we have the invariant that\n-                            // the location is *not* frozen.\n-                            return Ok(None);\n-                        } else {\n-                            return Ok(Some(idx));\n+    /// `is_write` indicates whether this is being used to write (or, equivalently, to\n+    /// borrow as &mut).\n+    /// Returns `Err` if the answer is \"no\"; otherwise the return value indicates what to\n+    /// do: With `Some(n)` you need to unfreeze, and then additionally pop `n` items.\n+    fn reactivatable(&self, bor: Borrow, is_write: bool) -> Result<Option<usize>, String> {\n+        // Check if we can match the frozen \"item\".  Not possible on writes!\n+        if !is_write {\n+            // For now, we do NOT check the timestamp.  That might be surprising, but\n+            // we cannot even notice when a location should be frozen but is not!\n+            // Those checks are both done in `tag_dereference`, where we have type information.\n+            // Either way, it is crucial that the frozen \"item\" matches raw pointers:\n+            // Reading through a raw should not unfreeze.\n+            match (self.frozen_since, bor) {\n+                (Some(_), Borrow::Shr(_)) => {\n+                    return Ok(None)\n+                }\n+                _ => {},\n+            }\n+        }\n+        // See if we can find this borrow.\n+        for (idx, &itm) in self.borrows.iter().rev().enumerate() {\n+            // Check borrow and stack item for compatibility.\n+            match (itm, bor) {\n+                (BorStackItem::FnBarrier(_), _) => {\n+                    return Err(format!(\"Trying to reactivate a borrow ({:?}) that lives \\\n+                                        behind a barrier\", bor))\n+                }\n+                (BorStackItem::Uniq(itm_t), Borrow::Uniq(bor_t)) if itm_t == bor_t => {\n+                    // Found matching unique item.\n+                    if !is_write {\n+                        // As a special case, if we are reading and since we *did* find the `Uniq`,\n+                        // we try to pop less: We are happy with making a `Shr` or `Frz` active;\n+                        // that one will not mind concurrent reads.\n+                        match self.reactivatable(Borrow::default(), is_write) {\n+                            // If we got something better that `idx`, use that\n+                            Ok(None) => return Ok(None),\n+                            Ok(Some(shr_idx)) if shr_idx <= idx => return Ok(Some(shr_idx)),\n+                            // Otherwise just go on.\n+                            _ => {},\n                         }\n                     }\n+                    return Ok(Some(idx))\n+                }\n+                (BorStackItem::Shr, Borrow::Shr(_)) => {\n+                    // Found matching shared/raw item.\n+                    return Ok(Some(idx))\n                 }\n+                // Go on looking.\n+                _ => {}\n             }\n         }\n         // Nothing to be found.\n-        Err(format!(\"Mutable borrow-to-reactivate ({:?}) does not exist on the stack\", mut_borrow))\n+        Err(format!(\"Borrow-to-reactivate {:?} does not exist on the stack\", bor))\n     }\n \n-    /// Reactive `bor` for this stack.  `usage` indicates whether this is being\n-    /// used to read/write (or, equivalently, to borrow as &/&mut), or to borrow as raw.\n-    fn reactivate(&mut self, bor: Borrow, usage: UsageKind) -> EvalResult<'tcx> {\n-        let action = match self.reactivatable(bor, usage) {\n-            Ok(action) => action,\n+    /// Reactive `bor` for this stack.  `is_write` indicates whether this is being\n+    /// used to write (or, equivalently, to borrow as &mut).\n+    fn reactivate(&mut self, bor: Borrow, is_write: bool) -> EvalResult<'tcx> {\n+        let mut pop = match self.reactivatable(bor, is_write) {\n+            Ok(None) => return Ok(()),\n+            Ok(Some(pop)) => pop,\n             Err(err) => return err!(MachineError(err)),\n         };\n-        // Execute what `reactivatable` told us to do.\n-        match action {\n-            None => {}, // nothing to do\n-            Some(top) => {\n-                if self.frozen_since.is_some() {\n-                    trace!(\"reactivate: Unfreezing\");\n-                }\n-                self.frozen_since = None;\n-                for itm in self.borrows.drain(top+1..).rev() {\n-                    trace!(\"reactivate: Popping {:?}\", itm);\n-                }\n-            }\n+        // Pop what `reactivatable` told us to pop. Always unfreeze.\n+        if self.is_frozen() {\n+            trace!(\"reactivate: Unfreezing\");\n+        }\n+        self.frozen_since = None;\n+        while pop > 0 {\n+            let itm = self.borrows.pop().unwrap();\n+            trace!(\"reactivate: Popping {:?}\", itm);\n+            pop -= 1;\n         }\n-\n         Ok(())\n     }\n \n-    /// Initiate `bor`; mostly this means freezing or pushing.\n+    /// Initiate `bor`; mostly this means pushing.\n     /// This operation cannot fail; it is up to the caller to ensure that the precondition\n     /// is met: We cannot push onto frozen stacks.\n     fn initiate(&mut self, bor: Borrow) {\n-        match bor {\n-            Borrow::Frz(t) => {\n-                match self.frozen_since {\n-                    None => {\n-                        trace!(\"initiate: Freezing\");\n-                        self.frozen_since = Some(t);\n-                    }\n-                    Some(since) => {\n-                        trace!(\"initiate: Already frozen\");\n-                        assert!(since <= t);\n-                    }\n-                }\n-            }\n-            Borrow::Mut(m) => {\n-                match self.frozen_since {\n-                    None => {\n-                        trace!(\"initiate: Pushing {:?}\", bor);\n-                        self.borrows.push(BorStackItem::Mut(m))\n-                    }\n-                    Some(_) if m.is_raw() =>\n-                        // We only ever initiate right after activating the ref we come from.\n-                        // If the source ref is fine being frozen, then a raw ref we create\n-                        // from it is fine with this as well.\n-                        trace!(\"initiate: Initiating a raw on a frozen location, not doing a thing\"),\n-                    Some(_) =>\n-                        bug!(\"Trying to mutate frozen location\")\n-                }\n+        if let Some(_) = self.frozen_since {\n+            // \"Pushing\" a Shr or Frz on top is redundant.\n+            match bor {\n+                Borrow::Uniq(_) => bug!(\"Trying to create unique ref to frozen location\"),\n+                Borrow::Shr(_) => trace!(\"initiate: New shared ref to frozen location is a NOP\"),\n             }\n+        } else {\n+            // Just push.\n+            let itm = match bor {\n+                Borrow::Uniq(t) => BorStackItem::Uniq(t),\n+                Borrow::Shr(_) if *self.borrows.last().unwrap() == BorStackItem::Shr => {\n+                    // Optimization: Don't push a Shr onto a Shr.\n+                    trace!(\"initiate: New shared ref to already shared location is a NOP\");\n+                    return\n+                },\n+                Borrow::Shr(_) => BorStackItem::Shr,\n+            };\n+            trace!(\"initiate: Pushing {:?}\", itm);\n+            self.borrows.push(itm)\n+        }\n+    }\n+\n+    /// Check if this location is \"frozen enough\".\n+    fn check_frozen(&self, bor_t: Timestamp) -> EvalResult<'tcx> {\n+        let frozen = self.frozen_since.map_or(false, |itm_t| itm_t <= bor_t);\n+        if !frozen {\n+            err!(MachineError(format!(\"Location is not frozen long enough\")))\n+        } else {\n+            Ok(())\n+        }\n+    }\n+\n+    /// Freeze this location, since `bor_t`.\n+    fn freeze(&mut self, bor_t: Timestamp) {\n+        if let Some(itm_t) = self.frozen_since {\n+            assert!(itm_t <= bor_t, \"Trying to freeze shorter than it was frozen?\");\n+        } else {\n+            trace!(\"Freezing\");\n+            self.frozen_since = Some(bor_t);\n         }\n     }\n }\n@@ -288,7 +272,7 @@ impl State {\n \n /// Higher-level operations\n impl<'tcx> Stacks {\n-    /// The single most operation: Make sure that using `ptr` as `usage` is okay,\n+    /// The single most important operation: Make sure that using `ptr` is okay,\n     /// and if `new_bor` is present then make that the new current borrow.\n     fn use_and_maybe_re_borrow(\n         &self,\n@@ -301,15 +285,65 @@ impl<'tcx> Stacks {\n             ptr.tag, usage, new_bor, ptr, size.bytes());\n         let mut stacks = self.stacks.borrow_mut();\n         for stack in stacks.iter_mut(ptr.offset, size) {\n-            stack.reactivate(ptr.tag, usage)?;\n+            stack.reactivate(ptr.tag, usage == UsageKind::Write)?;\n             if let Some(new_bor) = new_bor {\n                 stack.initiate(new_bor);\n             }\n         }\n+        Ok(())\n+    }\n+\n+    /// Freeze the given memory range.\n+    fn freeze(\n+        &self,\n+        ptr: Pointer<Borrow>,\n+        size: Size,\n+        bor_t: Timestamp\n+    ) -> EvalResult<'tcx> {\n+        let mut stacks = self.stacks.borrow_mut();\n+        for stack in stacks.iter_mut(ptr.offset, size) {\n+            stack.freeze(bor_t);\n+        }\n+        Ok(())\n+    }\n+\n+    /// Check that this stack is fine with being dereferenced\n+    fn check_deref(\n+        &self,\n+        ptr: Pointer<Borrow>,\n+        size: Size,\n+    ) -> EvalResult<'tcx> {\n+        let mut stacks = self.stacks.borrow_mut();\n+        // We need `iter_mut` because `iter` would skip gaps!\n+        for stack in stacks.iter_mut(ptr.offset, size) {\n+            // Conservatively assume we will just read\n+            if let Err(err) = stack.reactivatable(ptr.tag, /*is_write*/false) {\n+                return err!(MachineError(format!(\n+                    \"Encountered reference with non-reactivatable tag: {}\",\n+                    err\n+                )))\n+            }\n+        }\n+        Ok(())\n+    }\n \n+    /// Check that this stack is appropriately frozen\n+    fn check_frozen(\n+        &self,\n+        ptr: Pointer<Borrow>,\n+        size: Size,\n+        bor_t: Timestamp\n+    ) -> EvalResult<'tcx> {\n+        let mut stacks = self.stacks.borrow_mut();\n+        for stack in stacks.iter_mut(ptr.offset, size) {\n+            stack.check_frozen(bor_t)?;\n+        }\n         Ok(())\n     }\n+}\n \n+/// Hooks and glue\n+impl<'tcx> Stacks {\n     #[inline(always)]\n     pub fn memory_read(\n         &self,\n@@ -340,34 +374,34 @@ impl<'tcx> Stacks {\n         // FIXME: Error out of there are any barriers?\n     }\n \n-    /// Pushes the first borrow to the stacks, must be a mutable one.\n-    pub fn first_borrow(\n+    /// Pushes the first item to the stacks.\n+    pub fn first_item(\n         &mut self,\n-        mut_borrow: Mut,\n+        itm: BorStackItem,\n         size: Size\n     ) {\n+        assert!(!itm.is_fn_barrier());\n         for stack in self.stacks.get_mut().iter_mut(Size::ZERO, size) {\n-            assert!(stack.borrows.len() == 1 && stack.frozen_since.is_none());\n-            assert_eq!(stack.borrows.pop().unwrap(), BorStackItem::Mut(Mut::Raw));\n-            stack.borrows.push(BorStackItem::Mut(mut_borrow));\n+            assert!(stack.borrows.len() == 1);\n+            assert_eq!(stack.borrows.pop().unwrap(), BorStackItem::Shr);\n+            stack.borrows.push(itm);\n         }\n     }\n }\n \n+\n+\n pub trait EvalContextExt<'tcx> {\n     fn tag_reference(\n         &mut self,\n-        ptr: Pointer<Borrow>,\n-        pointee_ty: Ty<'tcx>,\n+        place: MPlaceTy<'tcx, Borrow>,\n         size: Size,\n         usage: UsageKind,\n     ) -> EvalResult<'tcx, Borrow>;\n \n-\n     fn tag_dereference(\n         &self,\n-        ptr: Pointer<Borrow>,\n-        pointee_ty: Ty<'tcx>,\n+        place: MPlaceTy<'tcx, Borrow>,\n         size: Size,\n         usage: UsageKind,\n     ) -> EvalResult<'tcx, Borrow>;\n@@ -385,40 +419,36 @@ pub trait EvalContextExt<'tcx> {\n     ) -> EvalResult<'tcx>;\n }\n \n-impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'a, 'mir, 'tcx> {\n+impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for MiriEvalContext<'a, 'mir, 'tcx> {\n     /// Called for place-to-value conversion.\n     fn tag_reference(\n         &mut self,\n-        ptr: Pointer<Borrow>,\n-        pointee_ty: Ty<'tcx>,\n+        place: MPlaceTy<'tcx, Borrow>,\n         size: Size,\n         usage: UsageKind,\n     ) -> EvalResult<'tcx, Borrow> {\n+        let ptr = place.ptr.to_ptr()?;\n         let time = self.machine.stacked_borrows.increment_clock();\n         let new_bor = match usage {\n-            UsageKind::Write => Borrow::Mut(Mut::Uniq(time)),\n-            UsageKind::Read =>\n-                // FIXME This does not do enough checking when only part of the data has\n-                // interior mutability. When the type is `(i32, Cell<i32>)`, we want the\n-                // first field to be frozen but not the second.\n-                if self.type_is_freeze(pointee_ty) {\n-                    Borrow::Frz(time)\n-                } else {\n-                    // Shared reference with interior mutability.\n-                    Borrow::Mut(Mut::Raw)\n-                },\n-            UsageKind::Raw => Borrow::Mut(Mut::Raw),\n+            UsageKind::Write => Borrow::Uniq(time),\n+            UsageKind::Read => Borrow::Shr(Some(time)),\n+            UsageKind::Raw => Borrow::Shr(None),\n         };\n-        trace!(\"tag_reference: Creating new reference ({:?}) for {:?} (pointee {}, size {}): {:?}\",\n-            usage, ptr, pointee_ty, size.bytes(), new_bor);\n+        trace!(\"tag_reference: Creating new reference ({:?}) for {:?} (pointee {}): {:?}\",\n+            usage, ptr, place.layout.ty, new_bor);\n \n-        // Make sure this reference is not dangling or so\n+        // Update the stacks.  First create the new ref as usual, then maybe freeze stuff.\n         self.memory().check_bounds(ptr, size, false)?;\n-\n-        // Update the stacks.  We cannot use `get_mut` becuse this might be immutable\n-        // memory.\n         let alloc = self.memory().get(ptr.alloc_id).expect(\"We checked that the ptr is fine!\");\n         alloc.extra.use_and_maybe_re_borrow(ptr, size, usage, Some(new_bor))?;\n+        // Maybe freeze stuff\n+        if let Borrow::Shr(Some(bor_t)) = new_bor {\n+            self.visit_frozen(place, size, |frz_ptr, size| {\n+                debug_assert_eq!(frz_ptr.alloc_id, ptr.alloc_id);\n+                // Be frozen!\n+                alloc.extra.freeze(frz_ptr, size, bor_t)\n+            })?;\n+        }\n \n         Ok(new_bor)\n     }\n@@ -429,13 +459,13 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'a, 'mir, '\n     /// We could be in the middle of `&(*var).1`.\n     fn tag_dereference(\n         &self,\n-        ptr: Pointer<Borrow>,\n-        pointee_ty: Ty<'tcx>,\n+        place: MPlaceTy<'tcx, Borrow>,\n         size: Size,\n         usage: UsageKind,\n     ) -> EvalResult<'tcx, Borrow> {\n-        trace!(\"tag_reference: Accessing reference ({:?}) for {:?} (pointee {}, size {})\",\n-            usage, ptr, pointee_ty, size.bytes());\n+        let ptr = place.ptr.to_ptr()?;\n+        trace!(\"tag_dereference: Accessing reference ({:?}) for {:?} (pointee {})\",\n+            usage, ptr, place.layout.ty);\n         // In principle we should not have to do anything here.  However, with transmutes involved,\n         // it can happen that the tag of `ptr` does not actually match `usage`, and we\n         // should adjust for that.\n@@ -446,51 +476,46 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'a, 'mir, '\n                 // Don't use the tag, this is a raw access!  Even if there is a tag,\n                 // that means transmute happened and we ignore the tag.\n                 // Also don't do any further validation, this is raw after all.\n-                return Ok(Borrow::Mut(Mut::Raw));\n+                return Ok(Borrow::default());\n             }\n-            (UsageKind::Write, Borrow::Mut(Mut::Uniq(_))) |\n-            (UsageKind::Read, Borrow::Frz(_)) |\n-            (UsageKind::Read, Borrow::Mut(Mut::Raw)) => {\n+            (UsageKind::Write, Borrow::Uniq(_)) |\n+            (UsageKind::Read, Borrow::Shr(_)) => {\n                 // Expected combinations.  Nothing to do.\n-                // FIXME: We probably shouldn't accept this if we got a raw shr without\n-                // interior mutability.\n             }\n-            (UsageKind::Write, Borrow::Mut(Mut::Raw)) => {\n+            (UsageKind::Write, Borrow::Shr(None)) => {\n                 // Raw transmuted to mut ref.  Keep this as raw access.\n                 // We cannot reborrow here; there might be a raw in `&(*var).1` where\n                 // `var` is an `&mut`.  The other field of the struct might be already frozen,\n                 // also using `var`, and that would be okay.\n             }\n-            (UsageKind::Read, Borrow::Mut(Mut::Uniq(_))) => {\n+            (UsageKind::Read, Borrow::Uniq(_)) => {\n                 // A mut got transmuted to shr.  Can happen even from compiler transformations:\n                 // `&*x` gets optimized to `x` even when `x` is a `&mut`.\n             }\n-            (UsageKind::Write, Borrow::Frz(_)) => {\n-                // This is just invalid.\n+            (UsageKind::Write, Borrow::Shr(Some(_))) => {\n+                // This is just invalid: A shr got transmuted to a mut.\n                 // If we ever allow this, we have to consider what we do when a turn a\n                 // `Raw`-tagged `&mut` into a raw pointer pointing to a frozen location.\n                 // We probably do not want to allow that, but we have to allow\n                 // turning a `Raw`-tagged `&` into a raw ptr to a frozen location.\n                 return err!(MachineError(format!(\"Encountered mutable reference with frozen tag {:?}\", ptr.tag)))\n             }\n         }\n-        // Even if we don't touch the tag, this operation is only okay if we *could*\n-        // activate it.  Also it must not be dangling.\n+\n+        // If we got here, we do some checking, *but* we leave the tag unchanged.\n         self.memory().check_bounds(ptr, size, false)?;\n         let alloc = self.memory().get(ptr.alloc_id).expect(\"We checked that the ptr is fine!\");\n-        let mut stacks = alloc.extra.stacks.borrow_mut();\n-        // We need `iter_mut` because `iter` would skip gaps!\n-        for stack in stacks.iter_mut(ptr.offset, size) {\n-            // Conservatively assume that we will only read.\n-            if let Err(err) = stack.reactivatable(ptr.tag, UsageKind::Read) {\n-                return err!(MachineError(format!(\n-                    \"Encountered {} reference with non-reactivatable tag: {}\",\n-                    if usage == UsageKind::Write { \"mutable\" } else { \"shared\" },\n-                    err\n-                )))\n-            }\n+        alloc.extra.check_deref(ptr, size)?;\n+        // Maybe check frozen stuff\n+        if let Borrow::Shr(Some(bor_t)) = ptr.tag {\n+            self.visit_frozen(place, size, |frz_ptr, size| {\n+                debug_assert_eq!(frz_ptr.alloc_id, ptr.alloc_id);\n+                // Are you frozen?\n+                alloc.extra.check_frozen(frz_ptr, size, bor_t)\n+            })?;\n         }\n-        // All is good.\n+\n+        // All is good, and do not change the tag\n         Ok(ptr.tag)\n     }\n \n@@ -499,7 +524,7 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'a, 'mir, '\n         id: AllocId,\n         kind: MemoryKind<MiriMemoryKind>,\n     ) -> Borrow {\n-        let mut_borrow = match kind {\n+        let time = match kind {\n             MemoryKind::Stack => {\n                 // New unique borrow. This `Uniq` is not accessible by the program,\n                 // so it will only ever be used when using the local directly (i.e.,\n@@ -509,19 +534,18 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'a, 'mir, '\n                 // `reset` which the blog post [1] says to perform when accessing a local.\n                 //\n                 // [1] https://www.ralfj.de/blog/2018/08/07/stacked-borrows.html\n-                let time = self.machine.stacked_borrows.increment_clock();\n-                Mut::Uniq(time)\n+                self.machine.stacked_borrows.increment_clock()\n             }\n             _ => {\n-                // Raw for everything else\n-                Mut::Raw\n+                // Nothing to do for everything else\n+                return Borrow::default()\n             }\n         };\n         // Make this the active borrow for this allocation\n         let alloc = self.memory_mut().get_mut(id).expect(\"This is a new allocation, it must still exist\");\n         let size = Size::from_bytes(alloc.bytes.len() as u64);\n-        alloc.extra.first_borrow(mut_borrow, size);\n-        Borrow::Mut(mut_borrow)\n+        alloc.extra.first_item(BorStackItem::Uniq(time), size);\n+        Borrow::Uniq(time)\n     }\n \n     fn retag("}, {"sha": "af1d7b138b8598d6cb0b884c0da6564720aa9569", "filename": "src/tls.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d136fdb701b8f9a9a4eed25ccae8c32668832010/src%2Ftls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d136fdb701b8f9a9a4eed25ccae8c32668832010/src%2Ftls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftls.rs?ref=d136fdb701b8f9a9a4eed25ccae8c32668832010", "patch": "@@ -133,7 +133,7 @@ impl<'tcx> TlsData<'tcx> {\n     }\n }\n \n-impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx> for super::MiriEvalContext<'a, 'mir, 'tcx> {\n+impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'a, 'mir, 'tcx> {\n     fn run_tls_dtors(&mut self) -> EvalResult<'tcx> {\n         let mut dtor = self.machine.tls.fetch_tls_dtor(None, &*self.tcx);\n         // FIXME: replace loop by some structure that works with stepping"}, {"sha": "4857ada7fb2c7f67500a46f8900e2d9e614fda89", "filename": "tests/compile-fail/stacked_borrows/buggy_as_mut_slice.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d136fdb701b8f9a9a4eed25ccae8c32668832010/tests%2Fcompile-fail%2Fstacked_borrows%2Fbuggy_as_mut_slice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d136fdb701b8f9a9a4eed25ccae8c32668832010/tests%2Fcompile-fail%2Fstacked_borrows%2Fbuggy_as_mut_slice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Fbuggy_as_mut_slice.rs?ref=d136fdb701b8f9a9a4eed25ccae8c32668832010", "patch": "@@ -14,6 +14,6 @@ fn main() {\n     let v = vec![0,1,2];\n     let v1 = safe::as_mut_slice(&v);\n     let v2 = safe::as_mut_slice(&v);\n-    v1[1] = 5; //~ ERROR reference with non-reactivatable tag\n+    v1[1] = 5; //~ ERROR does not exist on the stack\n     v1[1] = 6;\n }"}, {"sha": "a6daa5d93d772ddb6dafedfc14539c7480db1ddd", "filename": "tests/compile-fail/stacked_borrows/buggy_split_at_mut.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d136fdb701b8f9a9a4eed25ccae8c32668832010/tests%2Fcompile-fail%2Fstacked_borrows%2Fbuggy_split_at_mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d136fdb701b8f9a9a4eed25ccae8c32668832010/tests%2Fcompile-fail%2Fstacked_borrows%2Fbuggy_split_at_mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Fbuggy_split_at_mut.rs?ref=d136fdb701b8f9a9a4eed25ccae8c32668832010", "patch": "@@ -11,7 +11,7 @@ mod safe {\n             assert!(mid <= len);\n \n             (from_raw_parts_mut(ptr, len - mid), // BUG: should be \"mid\" instead of \"len - mid\"\n-            //~^ ERROR reference with non-reactivatable tag\n+            //~^ ERROR does not exist on the stack\n             from_raw_parts_mut(ptr.offset(mid as isize), len - mid))\n         }\n     }"}, {"sha": "dbaccae8827211b0599a09fcf258c103183a1c36", "filename": "tests/compile-fail/stacked_borrows/illegal_read1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d136fdb701b8f9a9a4eed25ccae8c32668832010/tests%2Fcompile-fail%2Fstacked_borrows%2Fillegal_read1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d136fdb701b8f9a9a4eed25ccae8c32668832010/tests%2Fcompile-fail%2Fstacked_borrows%2Fillegal_read1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Fillegal_read1.rs?ref=d136fdb701b8f9a9a4eed25ccae8c32668832010", "patch": "@@ -7,7 +7,7 @@ fn main() {\n     let xref = unsafe { &mut *xraw }; // derived from raw, so using raw is still okay...\n     callee(xraw);\n     let _val = *xref; // ...but any use of raw will invalidate our ref.\n-    //~^ ERROR: mutable reference with non-reactivatable tag\n+    //~^ ERROR: does not exist on the stack\n }\n \n fn callee(xraw: *mut i32) {"}, {"sha": "2da755d9aabc137206a1cc8eedc4d50a91dbb2e4", "filename": "tests/compile-fail/stacked_borrows/illegal_read2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d136fdb701b8f9a9a4eed25ccae8c32668832010/tests%2Fcompile-fail%2Fstacked_borrows%2Fillegal_read2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d136fdb701b8f9a9a4eed25ccae8c32668832010/tests%2Fcompile-fail%2Fstacked_borrows%2Fillegal_read2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Fillegal_read2.rs?ref=d136fdb701b8f9a9a4eed25ccae8c32668832010", "patch": "@@ -7,7 +7,7 @@ fn main() {\n     let xref = unsafe { &mut *xraw }; // derived from raw, so using raw is still okay...\n     callee(xraw);\n     let _val = *xref; // ...but any use of raw will invalidate our ref.\n-    //~^ ERROR: mutable reference with non-reactivatable tag\n+    //~^ ERROR: does not exist on the stack\n }\n \n fn callee(xraw: *mut i32) {"}, {"sha": "7378907fa7456165b4c07ecee7534b32680d1dc5", "filename": "tests/compile-fail/stacked_borrows/illegal_write1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d136fdb701b8f9a9a4eed25ccae8c32668832010/tests%2Fcompile-fail%2Fstacked_borrows%2Fillegal_write1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d136fdb701b8f9a9a4eed25ccae8c32668832010/tests%2Fcompile-fail%2Fstacked_borrows%2Fillegal_write1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Fillegal_write1.rs?ref=d136fdb701b8f9a9a4eed25ccae8c32668832010", "patch": "@@ -8,5 +8,5 @@ fn main() {\n     let target = Box::new(42); // has an implicit raw\n     let ref_ = &*target;\n     evil(ref_); // invalidates shared ref, activates raw\n-    let _x = *ref_; //~ ERROR reference with non-reactivatable tag\n+    let _x = *ref_; //~ ERROR is not frozen long enough\n }"}, {"sha": "c82da1e9c46771459b8dd370375e23ca601d2921", "filename": "tests/compile-fail/stacked_borrows/illegal_write3.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d136fdb701b8f9a9a4eed25ccae8c32668832010/tests%2Fcompile-fail%2Fstacked_borrows%2Fillegal_write3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d136fdb701b8f9a9a4eed25ccae8c32668832010/tests%2Fcompile-fail%2Fstacked_borrows%2Fillegal_write3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Fillegal_write3.rs?ref=d136fdb701b8f9a9a4eed25ccae8c32668832010", "patch": "@@ -3,6 +3,6 @@ fn main() {\n     // Make sure raw ptr with raw tag cannot mutate frozen location without breaking the shared ref.\n     let r#ref = &target; // freeze\n     let ptr = r#ref as *const _ as *mut _; // raw ptr, with raw tag\n-    unsafe { *ptr = 42; } //~ ERROR does not exist on the stack\n-    let _val = *r#ref;\n+    unsafe { *ptr = 42; }\n+    let _val = *r#ref; //~ ERROR is not frozen long enough\n }"}, {"sha": "49bf9279faa2e0f8e6d97d819304d03db0b9056a", "filename": "tests/compile-fail/stacked_borrows/illegal_write4.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d136fdb701b8f9a9a4eed25ccae8c32668832010/tests%2Fcompile-fail%2Fstacked_borrows%2Fillegal_write4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d136fdb701b8f9a9a4eed25ccae8c32668832010/tests%2Fcompile-fail%2Fstacked_borrows%2Fillegal_write4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Fillegal_write4.rs?ref=d136fdb701b8f9a9a4eed25ccae8c32668832010", "patch": "@@ -9,5 +9,5 @@ fn main() {\n     let ptr = reference as *const _ as *mut i32; // raw ptr, with raw tag\n     let _mut_ref: &mut i32 = unsafe { mem::transmute(ptr) }; // &mut, with raw tag\n     // Now we retag, making our ref top-of-stack -- and, in particular, unfreezing.\n-    let _val = *reference; //~ ERROR Location should be frozen\n+    let _val = *reference; //~ ERROR is not frozen long enough\n }"}, {"sha": "d3db462343e846e02ec5cc774e48c5a7c311678f", "filename": "tests/compile-fail/stacked_borrows/load_invalid_mut.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d136fdb701b8f9a9a4eed25ccae8c32668832010/tests%2Fcompile-fail%2Fstacked_borrows%2Fload_invalid_mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d136fdb701b8f9a9a4eed25ccae8c32668832010/tests%2Fcompile-fail%2Fstacked_borrows%2Fload_invalid_mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Fload_invalid_mut.rs?ref=d136fdb701b8f9a9a4eed25ccae8c32668832010", "patch": "@@ -5,5 +5,5 @@ fn main() {\n     let xref = unsafe { &mut *xraw };\n     let xref_in_mem = Box::new(xref);\n     let _val = *x; // invalidate xraw\n-    let _val = *xref_in_mem; //~ ERROR mutable reference with non-reactivatable tag\n+    let _val = *xref_in_mem; //~ ERROR does not exist on the stack\n }"}, {"sha": "71b578817a7748cef67560d41d280fd85a0c780f", "filename": "tests/compile-fail/stacked_borrows/load_invalid_shr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d136fdb701b8f9a9a4eed25ccae8c32668832010/tests%2Fcompile-fail%2Fstacked_borrows%2Fload_invalid_shr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d136fdb701b8f9a9a4eed25ccae8c32668832010/tests%2Fcompile-fail%2Fstacked_borrows%2Fload_invalid_shr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Fload_invalid_shr.rs?ref=d136fdb701b8f9a9a4eed25ccae8c32668832010", "patch": "@@ -5,5 +5,5 @@ fn main() {\n     let xref = unsafe { &*xraw };\n     let xref_in_mem = Box::new(xref);\n     *x = 42; // invalidate xraw\n-    let _val = *xref_in_mem; //~ ERROR shared reference with non-reactivatable tag: Location should be frozen\n+    let _val = *xref_in_mem; //~ ERROR does not exist on the stack\n }"}, {"sha": "41cf89d874d71d96ebc98f6c0b698748ec823a7f", "filename": "tests/compile-fail/stacked_borrows/pass_invalid_mut.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d136fdb701b8f9a9a4eed25ccae8c32668832010/tests%2Fcompile-fail%2Fstacked_borrows%2Fpass_invalid_mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d136fdb701b8f9a9a4eed25ccae8c32668832010/tests%2Fcompile-fail%2Fstacked_borrows%2Fpass_invalid_mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Fpass_invalid_mut.rs?ref=d136fdb701b8f9a9a4eed25ccae8c32668832010", "patch": "@@ -6,5 +6,5 @@ fn main() {\n     let xraw = x as *mut _;\n     let xref = unsafe { &mut *xraw };\n     let _val = *x; // invalidate xraw\n-    foo(xref); //~ ERROR mutable reference with non-reactivatable tag\n+    foo(xref); //~ ERROR does not exist on the stack\n }"}, {"sha": "0bdb1b4a41e591836cd3b743c8e21967697f9dee", "filename": "tests/compile-fail/stacked_borrows/pass_invalid_shr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d136fdb701b8f9a9a4eed25ccae8c32668832010/tests%2Fcompile-fail%2Fstacked_borrows%2Fpass_invalid_shr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d136fdb701b8f9a9a4eed25ccae8c32668832010/tests%2Fcompile-fail%2Fstacked_borrows%2Fpass_invalid_shr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Fpass_invalid_shr.rs?ref=d136fdb701b8f9a9a4eed25ccae8c32668832010", "patch": "@@ -6,5 +6,5 @@ fn main() {\n     let xraw = &*x as *const _;\n     let xref = unsafe { &*xraw };\n     *x = 42; // invalidate xraw\n-    foo(xref); //~ ERROR shared reference with non-reactivatable tag: Location should be frozen\n+    foo(xref); //~ ERROR does not exist on the stack\n }"}, {"sha": "aef8fafdf5d5991f0405ef6e6cce1d1eda7c52c1", "filename": "tests/compile-fail/stacked_borrows/return_invalid_mut.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d136fdb701b8f9a9a4eed25ccae8c32668832010/tests%2Fcompile-fail%2Fstacked_borrows%2Freturn_invalid_mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d136fdb701b8f9a9a4eed25ccae8c32668832010/tests%2Fcompile-fail%2Fstacked_borrows%2Freturn_invalid_mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Freturn_invalid_mut.rs?ref=d136fdb701b8f9a9a4eed25ccae8c32668832010", "patch": "@@ -3,7 +3,7 @@ fn foo(x: &mut (i32, i32)) -> &mut i32 {\n     let xraw = x as *mut (i32, i32);\n     let ret = unsafe { &mut (*xraw).1 };\n     let _val = *x; // invalidate xraw and its children\n-    ret //~ ERROR mutable reference with non-reactivatable tag\n+    ret //~ ERROR does not exist on the stack\n }\n \n fn main() {"}, {"sha": "074942eb95bcaf787047555dc879372922e80505", "filename": "tests/compile-fail/stacked_borrows/return_invalid_shr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d136fdb701b8f9a9a4eed25ccae8c32668832010/tests%2Fcompile-fail%2Fstacked_borrows%2Freturn_invalid_shr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d136fdb701b8f9a9a4eed25ccae8c32668832010/tests%2Fcompile-fail%2Fstacked_borrows%2Freturn_invalid_shr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Freturn_invalid_shr.rs?ref=d136fdb701b8f9a9a4eed25ccae8c32668832010", "patch": "@@ -3,7 +3,7 @@ fn foo(x: &mut (i32, i32)) -> &i32 {\n     let xraw = x as *mut (i32, i32);\n     let ret = unsafe { &(*xraw).1 };\n     x.1 = 42; // invalidate xraw on the 2nd field\n-    ret //~ ERROR shared reference with non-reactivatable tag: Location should be frozen\n+    ret //~ ERROR does not exist on the stack\n }\n \n fn main() {"}, {"sha": "624587932cb83ac8ff23cd256b0262bd4623d5d1", "filename": "tests/compile-fail/stacked_borrows/shared_confusion.rs", "status": "removed", "additions": 0, "deletions": 29, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/d0b79cf53b933bdade1be041b74d9d06a661d84f/tests%2Fcompile-fail%2Fstacked_borrows%2Fshared_confusion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0b79cf53b933bdade1be041b74d9d06a661d84f/tests%2Fcompile-fail%2Fstacked_borrows%2Fshared_confusion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Fshared_confusion.rs?ref=d0b79cf53b933bdade1be041b74d9d06a661d84f", "patch": "@@ -1,29 +0,0 @@\n-// Optimization kills all the reborrows, enough to make this error go away.  There are\n-// no retags either because we don't retag immediately after a `&[mut]`; we rely on\n-// that creating a fresh reference.\n-// See `shared_confusion_opt.rs` for a variant that is caught even with optimizations.\n-// Keep this test to make sure that without optimizations, we do not have to actually\n-// use the `x_inner_shr`.\n-// compile-flags: -Zmir-opt-level=0\n-\n-#![allow(unused_variables)]\n-use std::cell::RefCell;\n-\n-fn test(r: &mut RefCell<i32>) {\n-    let x = &*r; // not freezing because interior mutability\n-    let mut x_ref = x.borrow_mut();\n-    let x_inner : &mut i32 = &mut *x_ref; // Uniq reference\n-    let x_evil = x_inner as *mut _;\n-    {\n-        let x_inner_shr = &*x_inner; // frozen\n-        let y = &*r; // outer ref, not freezing\n-        let x_inner_shr = &*x_inner; // freezing again\n-    }\n-    // Our old raw should be dead by now\n-    unsafe { *x_evil = 0; } // this falls back to some Raw higher up the stack\n-    *x_inner = 12; //~ ERROR reference with non-reactivatable tag\n-}\n-\n-fn main() {\n-    test(&mut RefCell::new(0));\n-}"}, {"sha": "3030f5dd4001b9f696a226287d96188c42aef0ee", "filename": "tests/compile-fail/stacked_borrows/shared_confusion_opt.rs", "status": "removed", "additions": 0, "deletions": 25, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/d0b79cf53b933bdade1be041b74d9d06a661d84f/tests%2Fcompile-fail%2Fstacked_borrows%2Fshared_confusion_opt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0b79cf53b933bdade1be041b74d9d06a661d84f/tests%2Fcompile-fail%2Fstacked_borrows%2Fshared_confusion_opt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Fshared_confusion_opt.rs?ref=d0b79cf53b933bdade1be041b74d9d06a661d84f", "patch": "@@ -1,25 +0,0 @@\n-// A variant of `shared_confusion.rs` that gets flagged even with optimizations.\n-\n-#![allow(unused_variables)]\n-use std::cell::RefCell;\n-\n-fn test(r: &mut RefCell<i32>) {\n-    let x = &*r; // not freezing because interior mutability\n-    let mut x_ref = x.borrow_mut();\n-    let x_inner : &mut i32 = &mut *x_ref; // Uniq reference\n-    let x_evil = x_inner as *mut _;\n-    {\n-        let x_inner_shr = &*x_inner; // frozen\n-        let _val = *x_inner_shr;\n-        let y = &*r; // outer ref, not freezing\n-        let x_inner_shr = &*x_inner; // freezing again\n-        let _val = *x_inner_shr;\n-    }\n-    // Our old raw should be dead by now\n-    unsafe { *x_evil = 0; } // this falls back to some Raw higher up the stack\n-    *x_inner = 12; //~ ERROR reference with non-reactivatable tag\n-}\n-\n-fn main() {\n-    test(&mut RefCell::new(0));\n-}"}, {"sha": "ce464616195dfd79bc61a6b26d7785d68b50c94d", "filename": "tests/compile-fail/validity/invalid_bool.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d136fdb701b8f9a9a4eed25ccae8c32668832010/tests%2Fcompile-fail%2Fvalidity%2Finvalid_bool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d136fdb701b8f9a9a4eed25ccae8c32668832010/tests%2Fcompile-fail%2Fvalidity%2Finvalid_bool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fvalidity%2Finvalid_bool.rs?ref=d136fdb701b8f9a9a4eed25ccae8c32668832010", "patch": "@@ -1,3 +1,3 @@\n fn main() {\n-    let _b = unsafe { std::mem::transmute::<u8, bool>(2) }; //~ ERROR encountered 2, but expected something in the range 0..=1\n+    let _b = unsafe { std::mem::transmute::<u8, bool>(2) }; //~ ERROR encountered 2, but expected something less or equal to 1\n }"}, {"sha": "0d75ad9d28905d628055c769effa06a99ea75b1b", "filename": "tests/compile-fail/validity/invalid_char.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d136fdb701b8f9a9a4eed25ccae8c32668832010/tests%2Fcompile-fail%2Fvalidity%2Finvalid_char.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d136fdb701b8f9a9a4eed25ccae8c32668832010/tests%2Fcompile-fail%2Fvalidity%2Finvalid_char.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fvalidity%2Finvalid_char.rs?ref=d136fdb701b8f9a9a4eed25ccae8c32668832010", "patch": "@@ -1,6 +1,6 @@\n fn main() {\n     assert!(std::char::from_u32(-1_i32 as u32).is_none());\n-    let _ = match unsafe { std::mem::transmute::<i32, char>(-1) } { //~ ERROR encountered 4294967295, but expected something in the range 0..=1114111\n+    let _ = match unsafe { std::mem::transmute::<i32, char>(-1) } { //~ ERROR encountered 4294967295, but expected something less or equal to 1114111\n         'a' => {true},\n         'b' => {false},\n         _ => {true},"}, {"sha": "13be4e7dcea814b0701efb0e5d003ce2bb743cf0", "filename": "tests/compile-fail/validity/invalid_enum_discriminant.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d136fdb701b8f9a9a4eed25ccae8c32668832010/tests%2Fcompile-fail%2Fvalidity%2Finvalid_enum_discriminant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d136fdb701b8f9a9a4eed25ccae8c32668832010/tests%2Fcompile-fail%2Fvalidity%2Finvalid_enum_discriminant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fvalidity%2Finvalid_enum_discriminant.rs?ref=d136fdb701b8f9a9a4eed25ccae8c32668832010", "patch": "@@ -4,5 +4,5 @@ pub enum Foo {\n }\n \n fn main() {\n-    let _f = unsafe { std::mem::transmute::<i32, Foo>(42) }; //~ ERROR encountered invalid enum discriminant 42\n+    let _f = unsafe { std::mem::transmute::<i32, Foo>(42) }; //~ ERROR encountered 42, but expected a valid enum discriminant\n }"}, {"sha": "d6bc0305e69dc99c356a51c0270d2d97230b9ba7", "filename": "tests/compile-fail/validity/transmute_through_ptr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d136fdb701b8f9a9a4eed25ccae8c32668832010/tests%2Fcompile-fail%2Fvalidity%2Ftransmute_through_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d136fdb701b8f9a9a4eed25ccae8c32668832010/tests%2Fcompile-fail%2Fvalidity%2Ftransmute_through_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fvalidity%2Ftransmute_through_ptr.rs?ref=d136fdb701b8f9a9a4eed25ccae8c32668832010", "patch": "@@ -12,5 +12,5 @@ fn main() {\n     let mut x = Bool::True;\n     evil(&mut x);\n     let _y = x; // reading this ought to be enough to trigger validation\n-    //~^ ERROR invalid enum discriminant 44\n+    //~^ ERROR encountered 44, but expected a valid enum discriminant\n }"}, {"sha": "1b913aed4c89e1317dbe2fe4ad47e087c61b2a3b", "filename": "tests/run-pass-fullmir/send-is-not-static-par-for.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d136fdb701b8f9a9a4eed25ccae8c32668832010/tests%2Frun-pass-fullmir%2Fsend-is-not-static-par-for.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d136fdb701b8f9a9a4eed25ccae8c32668832010/tests%2Frun-pass-fullmir%2Fsend-is-not-static-par-for.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass-fullmir%2Fsend-is-not-static-par-for.rs?ref=d136fdb701b8f9a9a4eed25ccae8c32668832010", "patch": "@@ -8,9 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// FIXME: Still investigating whether there is UB here\n-// compile-flags: -Zmiri-disable-validation\n-\n use std::sync::Mutex;\n \n fn par_for<I, F>(iter: I, f: F)"}, {"sha": "ca33bd5f9e3d8e11845ea1ac71fbb5c4f9e00473", "filename": "tests/run-pass-fullmir/u128.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d136fdb701b8f9a9a4eed25ccae8c32668832010/tests%2Frun-pass-fullmir%2Fu128.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d136fdb701b8f9a9a4eed25ccae8c32668832010/tests%2Frun-pass-fullmir%2Fu128.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass-fullmir%2Fu128.rs?ref=d136fdb701b8f9a9a4eed25ccae8c32668832010", "patch": "@@ -8,9 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// FIXME: Still investigating whether there is UB here\n-// compile-flags: -Zmiri-disable-validation\n-\n fn b<T>(t: T) -> T { t }\n \n fn main() {"}, {"sha": "381169505ec9f50b5bfca110635935372e24ee4a", "filename": "tests/run-pass-fullmir/vecdeque.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d136fdb701b8f9a9a4eed25ccae8c32668832010/tests%2Frun-pass-fullmir%2Fvecdeque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d136fdb701b8f9a9a4eed25ccae8c32668832010/tests%2Frun-pass-fullmir%2Fvecdeque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass-fullmir%2Fvecdeque.rs?ref=d136fdb701b8f9a9a4eed25ccae8c32668832010", "patch": "@@ -1,6 +1,3 @@\n-// FIXME: Still investigating whether there is UB here\n-// compile-flags: -Zmiri-disable-validation\n-\n use std::collections::VecDeque;\n \n fn main() {"}, {"sha": "45a2a74db08dac88752251565a87334fc80cfa35", "filename": "tests/run-pass/slices.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d136fdb701b8f9a9a4eed25ccae8c32668832010/tests%2Frun-pass%2Fslices.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d136fdb701b8f9a9a4eed25ccae8c32668832010/tests%2Frun-pass%2Fslices.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fslices.rs?ref=d136fdb701b8f9a9a4eed25ccae8c32668832010", "patch": "@@ -1,6 +1,3 @@\n-// FIXME: Still investigating whether there is UB here\n-// compile-flags: -Zmiri-disable-validation\n-\n use std::slice;\n \n fn slice_of_zst() {"}, {"sha": "8faa4d65911569f0eb9916e9df795bf81dab899a", "filename": "tests/run-pass/stacked-borrows.rs", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/d136fdb701b8f9a9a4eed25ccae8c32668832010/tests%2Frun-pass%2Fstacked-borrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d136fdb701b8f9a9a4eed25ccae8c32668832010/tests%2Frun-pass%2Fstacked-borrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fstacked-borrows.rs?ref=d136fdb701b8f9a9a4eed25ccae8c32668832010", "patch": "@@ -1,7 +1,8 @@\n // Test various stacked-borrows-related things.\n fn main() {\n     deref_partially_dangling_raw();\n-    read_does_not_invalidate();\n+    read_does_not_invalidate1();\n+    read_does_not_invalidate2();\n }\n \n // Deref a raw ptr to access a field of a large struct, where the field\n@@ -15,13 +16,23 @@ fn deref_partially_dangling_raw() {\n \n // Make sure that reading from an `&mut` does, like reborrowing to `&`,\n // NOT invalidate other reborrows.\n-fn read_does_not_invalidate() {\n+fn read_does_not_invalidate1() {\n     fn foo(x: &mut (i32, i32)) -> &i32 {\n         let xraw = x as *mut (i32, i32);\n         let ret = unsafe { &(*xraw).1 };\n         let _val = x.1; // we just read, this does NOT invalidate the reborrows.\n         ret\n     }\n-\n+    foo(&mut (1, 2));\n+}\n+// Same as above, but this time we first create a raw, then read from `&mut`\n+// and then freeze from the raw.\n+fn read_does_not_invalidate2() {\n+    fn foo(x: &mut (i32, i32)) -> &i32 {\n+        let xraw = x as *mut (i32, i32);\n+        let _val = x.1; // we just read, this does NOT invalidate the raw reborrow.\n+        let ret = unsafe { &(*xraw).1 };\n+        ret\n+    }\n     foo(&mut (1, 2));\n }"}]}