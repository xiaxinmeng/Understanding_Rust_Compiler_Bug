{"sha": "a872a99bfe400f794171a58fc47025133ce08155", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE4NzJhOTliZmU0MDBmNzk0MTcxYTU4ZmM0NzAyNTEzM2NlMDgxNTU=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2012-04-23T11:04:46Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2012-04-23T11:04:46Z"}, "message": "Simplify representation of ast::path", "tree": {"sha": "eb48fbd65467ca9403b3e7ad105088102699cef6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/eb48fbd65467ca9403b3e7ad105088102699cef6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a872a99bfe400f794171a58fc47025133ce08155", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a872a99bfe400f794171a58fc47025133ce08155", "html_url": "https://github.com/rust-lang/rust/commit/a872a99bfe400f794171a58fc47025133ce08155", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a872a99bfe400f794171a58fc47025133ce08155/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "587d8a5d4f503ec07a8b964c04376078d14bf307", "url": "https://api.github.com/repos/rust-lang/rust/commits/587d8a5d4f503ec07a8b964c04376078d14bf307", "html_url": "https://github.com/rust-lang/rust/commit/587d8a5d4f503ec07a8b964c04376078d14bf307"}], "stats": {"total": 381, "additions": 168, "deletions": 213}, "files": [{"sha": "339c897256c18583a4921125d8f9f889401bcf9d", "filename": "src/librustsyntax/ast.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a872a99bfe400f794171a58fc47025133ce08155/src%2Flibrustsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a872a99bfe400f794171a58fc47025133ce08155/src%2Flibrustsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustsyntax%2Fast.rs?ref=a872a99bfe400f794171a58fc47025133ce08155", "patch": "@@ -37,10 +37,7 @@ type ident = str;\n type fn_ident = option<ident>;\n \n #[auto_serialize]\n-type path_ = {global: bool, idents: [ident], types: [@ty]};\n-\n-#[auto_serialize]\n-type path = spanned<path_>;\n+type path = {span: span, global: bool, idents: [ident], types: [@ty]};\n \n #[auto_serialize]\n type crate_num = int;"}, {"sha": "f74f543a71603b1eb8ad86ab71d3d64f90e601eb", "filename": "src/librustsyntax/ast_util.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a872a99bfe400f794171a58fc47025133ce08155/src%2Flibrustsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a872a99bfe400f794171a58fc47025133ce08155/src%2Flibrustsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustsyntax%2Fast_util.rs?ref=a872a99bfe400f794171a58fc47025133ce08155", "patch": "@@ -21,7 +21,7 @@ fn mk_sp(lo: uint, hi: uint) -> span {\n // make this a const, once the compiler supports it\n fn dummy_sp() -> span { ret mk_sp(0u, 0u); }\n \n-fn path_name(p: @path) -> str { path_name_i(p.node.idents) }\n+fn path_name(p: @path) -> str { path_name_i(p.idents) }\n \n fn path_name_i(idents: [ident]) -> str { str::connect(idents, \"::\") }\n \n@@ -183,8 +183,8 @@ fn is_exported(i: ident, m: _mod) -> bool {\n                   }\n \n                   ast::view_path_list(path, ids, _) {\n-                    if vec::len(path.node.idents) == 1u {\n-                        if i == path.node.idents[0] { ret true; }\n+                    if vec::len(path.idents) == 1u {\n+                        if i == path.idents[0] { ret true; }\n                         for ids.each {|id|\n                             if id.node.name == i { ret true; }\n                         }\n@@ -249,7 +249,7 @@ fn default_block(stmts1: [@stmt], expr1: option<@expr>, id1: node_id) ->\n }\n \n fn ident_to_path(s: span, i: ident) -> @path {\n-    @respan(s, {global: false, idents: [i], types: []})\n+    @{span: s, global: false, idents: [i], types: []}\n }\n \n pure fn is_unguarded(&&a: arm) -> bool {"}, {"sha": "0532a2c987b2180b571f08fde23de7a635e829e4", "filename": "src/librustsyntax/ext/auto_serialize.rs", "status": "modified", "additions": 13, "deletions": 18, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/a872a99bfe400f794171a58fc47025133ce08155/src%2Flibrustsyntax%2Fext%2Fauto_serialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a872a99bfe400f794171a58fc47025133ce08155/src%2Flibrustsyntax%2Fext%2Fauto_serialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustsyntax%2Fext%2Fauto_serialize.rs?ref=a872a99bfe400f794171a58fc47025133ce08155", "patch": "@@ -124,19 +124,17 @@ fn expand(cx: ext_ctxt,\n impl helpers for ext_ctxt {\n     fn helper_path(base_path: @ast::path,\n                    helper_name: str) -> @ast::path {\n-        let head = vec::init(base_path.node.idents);\n-        let tail = vec::last(base_path.node.idents);\n+        let head = vec::init(base_path.idents);\n+        let tail = vec::last(base_path.idents);\n         self.path(base_path.span, head + [helper_name + \"_\" + tail])\n     }\n \n     fn path(span: span, strs: [str]) -> @ast::path {\n-        @{node: {global: false, idents: strs, types: []},\n-          span: span}\n+        @{span: span, global: false, idents: strs, types: []}\n     }\n \n     fn path_tps(span: span, strs: [str], tps: [@ast::ty]) -> @ast::path {\n-        @{node: {global: false, idents: strs, types: tps},\n-          span: span}\n+        @{span: span, global: false, idents: strs, types: tps}\n     }\n \n     fn ty_path(span: span, strs: [str], tps: [@ast::ty]) -> @ast::ty {\n@@ -195,10 +193,7 @@ impl helpers for ext_ctxt {\n     }\n \n     fn binder_pat(span: span, nm: str) -> @ast::pat {\n-        let path = @{node: {global: false,\n-                            idents: [nm],\n-                            types: []},\n-                     span: span};\n+        let path = @{span: span, global: false, idents: [nm], types: []};\n         @{id: self.next_id(),\n           node: ast::pat_ident(path, none),\n           span: span}\n@@ -292,7 +287,7 @@ fn ser_path(cx: ext_ctxt, tps: ser_tps_map, path: @ast::path,\n             ast::expr_path(\n                 cx.helper_path(path, \"serialize\")));\n \n-    let ty_args = vec::map(path.node.types) {|ty|\n+    let ty_args = vec::map(path.types) {|ty|\n         let sv_stmts = ser_ty(cx, tps, ty, cx.clone(s), #ast{ __v });\n         let sv = cx.expr(path.span,\n                          ast::expr_block(cx.blk(path.span, sv_stmts)));\n@@ -428,9 +423,9 @@ fn ser_ty(cx: ext_ctxt, tps: ser_tps_map,\n       }\n \n       ast::ty_path(path, _) {\n-        if vec::len(path.node.idents) == 1u &&\n-            vec::is_empty(path.node.types) {\n-            let ident = path.node.idents[0];\n+        if vec::len(path.idents) == 1u &&\n+            vec::is_empty(path.types) {\n+            let ident = path.idents[0];\n \n             alt tps.find(ident) {\n               some(f) { f(v) }\n@@ -566,7 +561,7 @@ fn deser_path(cx: ext_ctxt, tps: deser_tps_map, path: @ast::path,\n             ast::expr_path(\n                 cx.helper_path(path, \"deserialize\")));\n \n-    let ty_args = vec::map(path.node.types) {|ty|\n+    let ty_args = vec::map(path.types) {|ty|\n         let dv_expr = deser_ty(cx, tps, ty, cx.clone(d));\n         cx.lambda(cx.expr_blk(dv_expr))\n     };\n@@ -650,9 +645,9 @@ fn deser_ty(cx: ext_ctxt, tps: deser_tps_map,\n       }\n \n       ast::ty_path(path, _) {\n-        if vec::len(path.node.idents) == 1u &&\n-            vec::is_empty(path.node.types) {\n-            let ident = path.node.idents[0];\n+        if vec::len(path.idents) == 1u &&\n+            vec::is_empty(path.types) {\n+            let ident = path.idents[0];\n \n             alt tps.find(ident) {\n               some(f) { f() }"}, {"sha": "a4ca819d6b63072b07d73182aa0a78820c1ab1a7", "filename": "src/librustsyntax/ext/base.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a872a99bfe400f794171a58fc47025133ce08155/src%2Flibrustsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a872a99bfe400f794171a58fc47025133ce08155/src%2Flibrustsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustsyntax%2Fext%2Fbase.rs?ref=a872a99bfe400f794171a58fc47025133ce08155", "patch": "@@ -137,9 +137,9 @@ fn expr_to_str(cx: ext_ctxt, expr: @ast::expr, error: str) -> str {\n fn expr_to_ident(cx: ext_ctxt, expr: @ast::expr, error: str) -> ast::ident {\n     alt expr.node {\n       ast::expr_path(p) {\n-        if vec::len(p.node.types) > 0u || vec::len(p.node.idents) != 1u {\n+        if vec::len(p.types) > 0u || vec::len(p.idents) != 1u {\n             cx.span_fatal(expr.span, error);\n-        } else { ret p.node.idents[0]; }\n+        } else { ret p.idents[0]; }\n       }\n       _ { cx.span_fatal(expr.span, error); }\n     }"}, {"sha": "ebf57745d9f75f345bdbf8feed6f241ced93fbb0", "filename": "src/librustsyntax/ext/build.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a872a99bfe400f794171a58fc47025133ce08155/src%2Flibrustsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a872a99bfe400f794171a58fc47025133ce08155/src%2Flibrustsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustsyntax%2Fext%2Fbuild.rs?ref=a872a99bfe400f794171a58fc47025133ce08155", "patch": "@@ -30,9 +30,8 @@ fn mk_unary(cx: ext_ctxt, sp: span, op: ast::unop, e: @ast::expr)\n }\n fn mk_path(cx: ext_ctxt, sp: span, idents: [ast::ident]) ->\n     @ast::expr {\n-    let path = {global: false, idents: idents, types: []};\n-    let sp_path = @{node: path, span: sp};\n-    let pathexpr = ast::expr_path(sp_path);\n+    let path = @{span: sp, global: false, idents: idents, types: []};\n+    let pathexpr = ast::expr_path(path);\n     ret @{id: cx.next_id(), node: pathexpr, span: sp};\n }\n fn mk_access_(cx: ext_ctxt, sp: span, p: @ast::expr, m: ast::ident)"}, {"sha": "8d2c89c0d4342f212c9ee27c06179a8db5f1afa6", "filename": "src/librustsyntax/ext/concat_idents.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a872a99bfe400f794171a58fc47025133ce08155/src%2Flibrustsyntax%2Fext%2Fconcat_idents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a872a99bfe400f794171a58fc47025133ce08155/src%2Flibrustsyntax%2Fext%2Fconcat_idents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustsyntax%2Fext%2Fconcat_idents.rs?ref=a872a99bfe400f794171a58fc47025133ce08155", "patch": "@@ -16,8 +16,7 @@ fn expand_syntax_ext(cx: ext_ctxt, sp: codemap::span, arg: ast::mac_arg,\n     }\n \n     ret @{id: cx.next_id(),\n-          node: ast::expr_path(@{node: {global: false, idents: [res],\n-                                        types: []},\n-                                 span: sp}),\n+          node: ast::expr_path(@{span: sp, global: false, idents: [res],\n+                                 types: []}),\n           span: sp};\n }"}, {"sha": "f70a75bd96a008ac4427b9248e3a70fe7df4f3fe", "filename": "src/librustsyntax/ext/expand.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a872a99bfe400f794171a58fc47025133ce08155/src%2Flibrustsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a872a99bfe400f794171a58fc47025133ce08155/src%2Flibrustsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustsyntax%2Fext%2Fexpand.rs?ref=a872a99bfe400f794171a58fc47025133ce08155", "patch": "@@ -19,8 +19,8 @@ fn expand_expr(exts: hashmap<str, syntax_extension>, cx: ext_ctxt,\n           expr_mac(mac) {\n             alt mac.node {\n               mac_invoc(pth, args, body) {\n-                assert (vec::len(pth.node.idents) > 0u);\n-                let extname = pth.node.idents[0];\n+                assert (vec::len(pth.idents) > 0u);\n+                let extname = pth.idents[0];\n                 alt exts.find(extname) {\n                   none {\n                     cx.span_fatal(pth.span,"}, {"sha": "15e61e2da6720f9ce75519132d12c53f3592a0be", "filename": "src/librustsyntax/ext/qquote.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a872a99bfe400f794171a58fc47025133ce08155/src%2Flibrustsyntax%2Fext%2Fqquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a872a99bfe400f794171a58fc47025133ce08155/src%2Flibrustsyntax%2Fext%2Fqquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustsyntax%2Fext%2Fqquote.rs?ref=a872a99bfe400f794171a58fc47025133ce08155", "patch": "@@ -142,7 +142,7 @@ fn expand_ast(ecx: ext_ctxt, _sp: span,\n             ecx.span_fatal(_sp, \"#ast requires exactly one arg\");\n         }\n         alt (args[0].node) {\n-          ast::expr_path(@{node: {idents: id, _},_}) if vec::len(id) == 1u\n+          ast::expr_path(@{idents: id, _}) if vec::len(id) == 1u\n               {what = id[0]}\n           _ {ecx.span_fatal(args[0].span, \"expected an identifier\");}\n         }"}, {"sha": "da2acd333fd63bc5a732cc9edc15a1f81c8c0315", "filename": "src/librustsyntax/ext/simplext.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/a872a99bfe400f794171a58fc47025133ce08155/src%2Flibrustsyntax%2Fext%2Fsimplext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a872a99bfe400f794171a58fc47025133ce08155/src%2Flibrustsyntax%2Fext%2Fsimplext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustsyntax%2Fext%2Fsimplext.rs?ref=a872a99bfe400f794171a58fc47025133ce08155", "patch": "@@ -5,14 +5,14 @@ import base::*;\n \n import fold::*;\n import ast_util::respan;\n-import ast::{ident, path, ty, blk_, expr, path_, expr_path,\n+import ast::{ident, path, ty, blk_, expr, expr_path,\n              expr_vec, expr_mac, mac_invoc, node_id};\n \n export add_new_extension;\n \n fn path_to_ident(pth: @path) -> option<ident> {\n-    if vec::len(pth.node.idents) == 1u && vec::len(pth.node.types) == 0u {\n-        ret some(pth.node.idents[0u]);\n+    if vec::len(pth.idents) == 1u && vec::len(pth.types) == 0u {\n+        ret some(pth.idents[0u]);\n     }\n     ret none;\n }\n@@ -190,7 +190,7 @@ fn transcribe(cx: ext_ctxt, b: bindings, body: @expr) -> @expr {\n     let afp = default_ast_fold();\n     let f_pre =\n         {fold_ident: bind transcribe_ident(cx, b, idx_path, _, _),\n-         fold_path: bind transcribe_path(cx, b, idx_path, _, _, _),\n+         fold_path: bind transcribe_path(cx, b, idx_path, _, _),\n          fold_expr:\n              bind transcribe_expr(cx, b, idx_path, _, _, _, afp.fold_expr),\n          fold_ty: bind transcribe_type(cx, b, idx_path, _, _, _, afp.fold_ty),\n@@ -329,17 +329,17 @@ fn transcribe_ident(cx: ext_ctxt, b: bindings, idx_path: @mut [uint],\n \n \n fn transcribe_path(cx: ext_ctxt, b: bindings, idx_path: @mut [uint],\n-                   p: path_, s:span, _fld: ast_fold) -> (path_, span) {\n+                   p: path, _fld: ast_fold) -> path {\n     // Don't substitute into qualified names.\n-    if vec::len(p.types) > 0u || vec::len(p.idents) != 1u { ret (p, s); }\n-    ret alt follow_for_trans(cx, b.find(p.idents[0]), idx_path) {\n-          some(match_ident(id)) {\n-            ({global: false, idents: [id.node], types: []}, id.span)\n-          }\n-          some(match_path(a_pth)) { (a_pth.node, a_pth.span) }\n-          some(m) { match_error(cx, m, \"a path\") }\n-          none { (p, s) }\n-        }\n+    if vec::len(p.types) > 0u || vec::len(p.idents) != 1u { ret p; }\n+    alt follow_for_trans(cx, b.find(p.idents[0]), idx_path) {\n+      some(match_ident(id)) {\n+        {span: id.span, global: false, idents: [id.node], types: []}\n+      }\n+      some(match_path(a_pth)) { *a_pth }\n+      some(m) { match_error(cx, m, \"a path\") }\n+      none { p }\n+    }\n }\n \n \n@@ -351,15 +351,15 @@ fn transcribe_expr(cx: ext_ctxt, b: bindings, idx_path: @mut [uint],\n     ret alt e {\n           expr_path(p) {\n             // Don't substitute into qualified names.\n-            if vec::len(p.node.types) > 0u || vec::len(p.node.idents) != 1u {\n+            if vec::len(p.types) > 0u || vec::len(p.idents) != 1u {\n                 (e, s);\n             }\n-            alt follow_for_trans(cx, b.find(p.node.idents[0]), idx_path) {\n+            alt follow_for_trans(cx, b.find(p.idents[0]), idx_path) {\n               some(match_ident(id)) {\n-                (expr_path(@respan(id.span,\n-                                   {global: false,\n-                                    idents: [id.node],\n-                                    types: []})), id.span)\n+                (expr_path(@{span: id.span,\n+                             global: false,\n+                             idents: [id.node],\n+                             types: []}), id.span)\n               }\n               some(match_path(a_pth)) { (expr_path(a_pth), s) }\n               some(match_expr(a_exp)) { (a_exp.node, a_exp.span) }"}, {"sha": "b70755a1d2c3a8533fdf677092abb80b7403c77d", "filename": "src/librustsyntax/fold.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a872a99bfe400f794171a58fc47025133ce08155/src%2Flibrustsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a872a99bfe400f794171a58fc47025133ce08155/src%2Flibrustsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustsyntax%2Ffold.rs?ref=a872a99bfe400f794171a58fc47025133ce08155", "patch": "@@ -46,7 +46,7 @@ type ast_fold_precursor =\n      fold_native_mod: fn@(native_mod, ast_fold) -> native_mod,\n      fold_variant: fn@(variant_, span, ast_fold) -> (variant_, span),\n      fold_ident: fn@(&&ident, ast_fold) -> ident,\n-     fold_path: fn@(path_, span, ast_fold) -> (path_, span),\n+     fold_path: fn@(path, ast_fold) -> path,\n      fold_local: fn@(local_, span, ast_fold) -> (local_, span),\n      map_exprs: fn@(fn@(&&@expr) -> @expr, [@expr]) -> [@expr],\n      new_id: fn@(node_id) -> node_id,\n@@ -559,8 +559,8 @@ fn noop_fold_variant(v: variant_, fld: ast_fold) -> variant_ {\n \n fn noop_fold_ident(&&i: ident, _fld: ast_fold) -> ident { ret i; }\n \n-fn noop_fold_path(&&p: path_, fld: ast_fold) -> path_ {\n-    ret {global: p.global,\n+fn noop_fold_path(&&p: path, fld: ast_fold) -> path {\n+    ret {span: fld.new_span(p.span), global: p.global,\n          idents: vec::map(p.idents, fld.fold_ident),\n          types: vec::map(p.types, fld.fold_ty)};\n }\n@@ -613,7 +613,7 @@ fn default_ast_fold() -> @ast_fold_precursor {\n           fold_native_mod: noop_fold_native_mod,\n           fold_variant: wrap(noop_fold_variant),\n           fold_ident: noop_fold_ident,\n-          fold_path: wrap(noop_fold_path),\n+          fold_path: noop_fold_path,\n           fold_local: wrap(noop_fold_local),\n           map_exprs: noop_map_exprs,\n           new_id: noop_id,\n@@ -754,8 +754,7 @@ fn make_fold(afp: ast_fold_precursor) -> ast_fold {\n         ret afp.fold_ident(x, f);\n     }\n     fn f_path(afp: ast_fold_precursor, f: ast_fold, &&x: @path) -> @path {\n-        let (n, s) = afp.fold_path(x.node, x.span, f);\n-        ret @{node: n, span: afp.new_span(s)};\n+        @afp.fold_path(*x, f)\n     }\n     fn f_local(afp: ast_fold_precursor, f: ast_fold, &&x: @local) -> @local {\n         let (n, s) = afp.fold_local(x.node, x.span, f);"}, {"sha": "7ebac4f5c8b20d292271e7c5402b785bee102d75", "filename": "src/librustsyntax/parse/parser.rs", "status": "modified", "additions": 61, "deletions": 77, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/a872a99bfe400f794171a58fc47025133ce08155/src%2Flibrustsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a872a99bfe400f794171a58fc47025133ce08155/src%2Flibrustsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustsyntax%2Fparse%2Fparser.rs?ref=a872a99bfe400f794171a58fc47025133ce08155", "patch": "@@ -67,7 +67,7 @@ impl parser for parser {\n         if vec::len(self.buffer) == 0u {\n             let next = lexer::next_token(self.reader);\n             self.token = next.tok;\n-            self.span = ast_util::mk_sp(next.chpos, self.reader.chpos);\n+            self.span = mk_sp(next.chpos, self.reader.chpos);\n         } else {\n             let next = vec::pop(self.buffer);\n             self.token = next.tok;\n@@ -76,12 +76,12 @@ impl parser for parser {\n     }\n     fn swap(next: token::token, lo: uint, hi: uint) {\n         self.token = next;\n-        self.span = ast_util::mk_sp(lo, hi);\n+        self.span = mk_sp(lo, hi);\n     }\n     fn look_ahead(distance: uint) -> token::token {\n         while vec::len(self.buffer) < distance {\n             let next = lexer::next_token(self.reader);\n-            let sp = ast_util::mk_sp(next.chpos, self.reader.chpos);\n+            let sp = mk_sp(next.chpos, self.reader.chpos);\n             self.buffer = [{tok: next.tok, span: sp}] + self.buffer;\n         }\n         ret self.buffer[distance - 1u].tok;\n@@ -140,7 +140,7 @@ fn parse_ty_methods(p: parser) -> [ast::ty_method] {\n         let d = parse_ty_fn(p), fhi = p.last_span.hi;\n         expect(p, token::SEMI);\n         {ident: ident, attrs: attrs, decl: {purity: pur with d}, tps: tps,\n-         span: ast_util::mk_sp(flo, fhi)}\n+         span: mk_sp(flo, fhi)}\n     }, p).node\n }\n \n@@ -237,7 +237,7 @@ fn parse_ty_postfix(orig_t: ast::ty_, p: parser, colons_before_params: bool,\n     fn mk_ty(p: parser, t: ast::ty_, lo: uint, hi: uint) -> @ast::ty {\n         @{id: p.get_id(),\n           node: t,\n-          span: ast_util::mk_sp(lo, hi)}\n+          span: mk_sp(lo, hi)}\n     }\n \n     if p.token == token::BINOP(token::SLASH) {\n@@ -266,10 +266,10 @@ fn parse_ty_postfix(orig_t: ast::ty_, p: parser, colons_before_params: bool,\n \n     alt orig_t {\n       ast::ty_path(pth, ann) {\n-        ret mk_ty(p, ast::ty_path(@spanned(lo, p.last_span.hi,\n-                                           {global: pth.node.global,\n-                                            idents: pth.node.idents,\n-                                            types: seq}), ann),\n+        ret mk_ty(p, ast::ty_path(@{span: mk_sp(lo, p.last_span.hi),\n+                                    global: pth.global,\n+                                    idents: pth.idents,\n+                                    types: seq}, ann),\n                   lo, p.last_span.hi);\n       }\n       _ { p.fatal(\"type parameter instantiation only allowed for paths\"); }\n@@ -282,15 +282,15 @@ fn parse_ret_ty(p: parser) -> (ast::ret_style, @ast::ty) {\n         if eat(p, token::NOT) {\n             (ast::noreturn, @{id: p.get_id(),\n                               node: ast::ty_bot,\n-                              span: ast_util::mk_sp(lo, p.last_span.hi)})\n+                              span: mk_sp(lo, p.last_span.hi)})\n         } else {\n             (ast::return_val, parse_ty(p, false))\n         }\n     } else {\n         let pos = p.span.lo;\n         (ast::return_val, @{id: p.get_id(),\n                             node: ast::ty_nil,\n-                            span: ast_util::mk_sp(pos, pos)})\n+                            span: mk_sp(pos, pos)})\n     }\n }\n \n@@ -331,7 +331,7 @@ fn parse_ty(p: parser, colons_before_params: bool) -> @ast::ty {\n       some(e) {\n         ret @{id: p.get_id(),\n               node: ast::ty_mac(spanned(lo, p.span.hi, e)),\n-              span: ast_util::mk_sp(lo, p.span.hi)};\n+              span: mk_sp(lo, p.span.hi)};\n       }\n       none {}\n     }\n@@ -373,7 +373,7 @@ fn parse_ty(p: parser, colons_before_params: bool) -> @ast::ty {\n             p.bump();\n             ast::ty_constr(@{id: p.get_id(),\n                              node: t,\n-                             span: ast_util::mk_sp(lo, hi)},\n+                             span: mk_sp(lo, hi)},\n                            parse_type_constraints(p))\n         } else { t }\n     } else if p.token == token::LBRACKET {\n@@ -435,7 +435,7 @@ fn parse_fn_block_arg(p: parser) -> ast::arg {\n             } else {\n                 @{id: p.get_id(),\n                   node: ast::ty_infer,\n-                  span: ast_util::mk_sp(p.span.lo, p.span.hi)}\n+                  span: mk_sp(p.span.lo, p.span.hi)}\n             };\n     ret {mode: m, ty: t, ident: i, id: p.get_id()};\n }\n@@ -455,7 +455,7 @@ fn maybe_parse_dollar_mac(p: parser) -> option<ast::mac_> {\n             let e = parse_expr(p);\n             expect(p, token::RPAREN);\n             let hi = p.last_span.hi;\n-            some(ast::mac_aq(ast_util::mk_sp(lo,hi), e))\n+            some(ast::mac_aq(mk_sp(lo,hi), e))\n           }\n           _ {\n             p.fatal(\"expected `(` or integer literal\");\n@@ -526,7 +526,7 @@ fn parse_lit(p: parser) -> ast::lit {\n         p.bump();\n         lit_from_token(p, tok)\n     };\n-    ret {node: lit, span: ast_util::mk_sp(lo, p.last_span.hi)};\n+    ret {node: lit, span: mk_sp(lo, p.last_span.hi)};\n }\n \n fn parse_path(p: parser) -> @ast::path {\n@@ -536,13 +536,12 @@ fn parse_path(p: parser) -> @ast::path {\n     while p.look_ahead(1u) != token::LT && eat(p, token::MOD_SEP) {\n         ids += [parse_ident(p)];\n     }\n-    ret @spanned(lo, p.last_span.hi,\n-                 {global: global, idents: ids, types: []});\n+    @{span: mk_sp(lo, p.last_span.hi), global: global, idents: ids, types: []}\n }\n \n fn parse_value_path(p: parser) -> @ast::path {\n     let pt = parse_path(p);\n-    let last_word = pt.node.idents[vec::len(pt.node.idents)-1u];\n+    let last_word = vec::last(pt.idents);\n     if p.bad_expr_words.contains_key(last_word) {\n         p.fatal(\"found \" + last_word + \" in expression position\");\n     }\n@@ -552,15 +551,12 @@ fn parse_value_path(p: parser) -> @ast::path {\n fn parse_path_and_ty_param_substs(p: parser, colons: bool) -> @ast::path {\n     let lo = p.span.lo;\n     let path = parse_path(p);\n-    let b = if colons {\n-                eat(p, token::MOD_SEP)\n-            } else {\n-                p.token == token::LT\n-            };\n+    let b = if colons { eat(p, token::MOD_SEP) }\n+            else { p.token == token::LT };\n     if b {\n         let seq = parse_seq_lt_gt(some(token::COMMA),\n                                   {|p| parse_ty(p, false)}, p);\n-        @spanned(lo, seq.span.hi, {types: seq.node with path.node})\n+        @{span: mk_sp(lo, seq.span.hi), types: seq.node with *path}\n     } else { path }\n }\n \n@@ -586,13 +582,13 @@ fn parse_field(p: parser, sep: token::token) -> ast::field {\n }\n \n fn mk_expr(p: parser, lo: uint, hi: uint, node: ast::expr_) -> @ast::expr {\n-    ret @{id: p.get_id(), node: node, span: ast_util::mk_sp(lo, hi)};\n+    ret @{id: p.get_id(), node: node, span: mk_sp(lo, hi)};\n }\n \n fn mk_mac_expr(p: parser, lo: uint, hi: uint, m: ast::mac_) -> @ast::expr {\n     ret @{id: p.get_id(),\n-          node: ast::expr_mac({node: m, span: ast_util::mk_sp(lo, hi)}),\n-          span: ast_util::mk_sp(lo, hi)};\n+          node: ast::expr_mac({node: m, span: mk_sp(lo, hi)}),\n+          span: mk_sp(lo, hi)};\n }\n \n fn mk_lit_u32(p: parser, i: u32) -> @ast::expr {\n@@ -1156,7 +1152,7 @@ fn parse_capture_clause(p: parser) -> @ast::capture_clause {\n             alt p.token {\n               token::IDENT(_, _) {\n                 let id = p.get_id();\n-                let sp = ast_util::mk_sp(p.span.lo, p.span.hi);\n+                let sp = mk_sp(p.span.lo, p.span.hi);\n                 let ident = parse_ident(p);\n                 res += [@{id:id, name:ident, span:sp}];\n                 if !eat(p, token::COMMA) {\n@@ -1364,7 +1360,7 @@ fn parse_pat(p: parser) -> @ast::pat {\n             let lo1 = p.last_span.lo;\n             let fieldname = parse_ident(p);\n             let hi1 = p.last_span.lo;\n-            let fieldpath = ast_util::ident_to_path(ast_util::mk_sp(lo1, hi1),\n+            let fieldpath = ast_util::ident_to_path(mk_sp(lo1, hi1),\n                                           fieldname);\n             let mut subpat;\n             if p.token == token::COLON {\n@@ -1376,7 +1372,7 @@ fn parse_pat(p: parser) -> @ast::pat {\n                 }\n                 subpat = @{id: p.get_id(),\n                            node: ast::pat_ident(fieldpath, none),\n-                           span: ast_util::mk_sp(lo, hi)};\n+                           span: mk_sp(lo, hi)};\n             }\n             fields += [{ident: fieldname, pat: subpat}];\n         }\n@@ -1389,7 +1385,7 @@ fn parse_pat(p: parser) -> @ast::pat {\n         if p.token == token::RPAREN {\n             hi = p.span.hi;\n             p.bump();\n-            let lit = @{node: ast::lit_nil, span: ast_util::mk_sp(lo, hi)};\n+            let lit = @{node: ast::lit_nil, span: mk_sp(lo, hi)};\n             let expr = mk_expr(p, lo, hi, ast::expr_lit(lit));\n             pat = ast::pat_lit(expr);\n         } else {\n@@ -1454,7 +1450,7 @@ fn parse_pat(p: parser) -> @ast::pat {\n                  pat = ast::pat_enum(enum_path, none);\n             }\n             else if vec::is_empty(args) &&\n-               vec::len(enum_path.node.idents) == 1u {\n+               vec::len(enum_path.idents) == 1u {\n                 pat = ast::pat_ident(enum_path, none);\n             }\n             else {\n@@ -1463,7 +1459,7 @@ fn parse_pat(p: parser) -> @ast::pat {\n         }\n       }\n     }\n-    ret @{id: p.get_id(), node: pat, span: ast_util::mk_sp(lo, hi)};\n+    ret @{id: p.get_id(), node: pat, span: mk_sp(lo, hi)};\n }\n \n fn parse_local(p: parser, is_mutbl: bool,\n@@ -1472,7 +1468,7 @@ fn parse_local(p: parser, is_mutbl: bool,\n     let pat = parse_pat(p);\n     let mut ty = @{id: p.get_id(),\n                    node: ast::ty_infer,\n-                   span: ast_util::mk_sp(lo, lo)};\n+                   span: mk_sp(lo, lo)};\n     if eat(p, token::COLON) { ty = parse_ty(p, false); }\n     let init = if allow_init { parse_initializer(p) } else { none };\n     ret @spanned(lo, p.last_span.hi,\n@@ -1504,7 +1500,7 @@ fn parse_instance_var(p:parser, pr: ast::privacy) -> @ast::class_member {\n     expect(p, token::COLON);\n     let ty = parse_ty(p, false);\n     ret @{node: ast::instance_var(name, ty, is_mutbl, p.get_id(), pr),\n-          span: ast_util::mk_sp(lo, p.last_span.hi)};\n+          span: mk_sp(lo, p.last_span.hi)};\n }\n \n fn parse_stmt(p: parser, first_item_attrs: [ast::attribute]) -> @ast::stmt {\n@@ -1739,7 +1735,7 @@ fn mk_item(p: parser, lo: uint, hi: uint, ident: ast::ident, node: ast::item_,\n           attrs: attrs,\n           id: p.get_id(),\n           node: node,\n-          span: ast_util::mk_sp(lo, hi)};\n+          span: mk_sp(lo, hi)};\n }\n \n fn parse_item_fn(p: parser, purity: ast::purity,\n@@ -1775,7 +1771,7 @@ fn parse_method(p: parser, pr: ast::privacy) -> @ast::method {\n     let (inner_attrs, body) = parse_inner_attrs_and_block(p, true);\n     let attrs = attrs + inner_attrs;\n     @{ident: ident, attrs: attrs, tps: tps, decl: decl, body: body,\n-      id: p.get_id(), span: ast_util::mk_sp(lo, body.span.hi),\n+      id: p.get_id(), span: mk_sp(lo, body.span.hi),\n       self_id: p.get_id(), privacy: pr}\n }\n \n@@ -1802,7 +1798,7 @@ fn parse_item_impl(p: parser, attrs: [ast::attribute]) -> @ast::item {\n     let ifce = if eat_word(p, \"of\") {\n         let path = parse_path_and_ty_param_substs(p, false);\n         if option::is_none(ident) {\n-            ident = some(path.node.idents[vec::len(path.node.idents) - 1u]);\n+            ident = some(vec::last(path.idents));\n         }\n         some(wrap_path(p, path))\n     } else { none };\n@@ -1836,7 +1832,7 @@ fn parse_item_res(p: parser, attrs: [ast::attribute]) -> @ast::item {\n                ident: arg_ident, id: p.get_id()}],\n          output: @{id: p.get_id(),\n                    node: ast::ty_nil,\n-                   span: ast_util::mk_sp(lo, lo)},\n+                   span: mk_sp(lo, lo)},\n          purity: ast::impure_fn,\n          cf: ast::return_val,\n          constraints: []};\n@@ -1850,13 +1846,13 @@ fn parse_item_res(p: parser, attrs: [ast::attribute]) -> @ast::item {\n fn ident_to_path_tys(p: parser, i: ast::ident,\n                      typarams: [ast::ty_param]) -> @ast::path {\n     let s = p.last_span;\n-    let p_: ast::path_ = {global: false, idents: [i],\n-          types: vec::map(typarams,\n-            {|tp| @{id: p.get_id(),\n-                   node: ast::ty_path(ident_to_path(s, tp.ident),\n-                                      p.get_id()),\n-                        span: s}})};\n-    @spanned(s.lo, s.hi, p_)\n+    @{span: s, global: false, idents: [i],\n+      types: vec::map(typarams, {|tp|\n+          @{id: p.get_id(),\n+            node: ast::ty_path(ident_to_path(s, tp.ident),\n+                               p.get_id()),\n+            span: s}})\n+     }\n }\n \n fn parse_iface_ref_list(p:parser) -> [ast::iface_ref] {\n@@ -1934,7 +1930,7 @@ fn parse_class_item(p:parser, class_name_with_tps:@ast::path)\n                       span: decl_.output.span}\n                     with decl_};\n         let body = parse_block(p);\n-        ret ctor_decl(decl, body, ast_util::mk_sp(lo, p.last_span.hi));\n+        ret ctor_decl(decl, body, mk_sp(lo, p.last_span.hi));\n     }\n     else if eat_word(p, \"priv\") {\n             expect(p, token::LBRACE);\n@@ -2014,7 +2010,7 @@ fn parse_item_native_fn(p: parser, attrs: [ast::attribute],\n           attrs: attrs,\n           node: ast::native_item_fn(decl, t.tps),\n           id: p.get_id(),\n-          span: ast_util::mk_sp(lo, hi)};\n+          span: mk_sp(lo, hi)};\n }\n \n fn parse_fn_purity(p: parser) -> ast::purity {\n@@ -2236,13 +2232,10 @@ fn parse_view_path(p: parser) -> @ast::view_path {\n             let id = parse_ident(p);\n             path += [id];\n         }\n-        let mut hi = p.span.hi;\n-        ret @spanned(lo, hi,\n-                     ast::view_path_simple(first_ident,\n-                        @spanned(lo, hi,\n-                                 {global: false, idents: path,\n-                                         types: []}),\n-                        p.get_id()));\n+        let path = @{span: mk_sp(lo, p.span.hi), global: false,\n+                     idents: path, types: []};\n+        ret @spanned(lo, p.span.hi,\n+                     ast::view_path_simple(first_ident, path, p.get_id()));\n       }\n \n       token::MOD_SEP {\n@@ -2263,25 +2256,19 @@ fn parse_view_path(p: parser) -> @ast::view_path {\n                     parse_seq(token::LBRACE, token::RBRACE,\n                               seq_sep(token::COMMA),\n                               parse_path_list_ident, p).node;\n-                let mut hi = p.span.hi;\n-                ret @spanned(lo, hi,\n-                             ast::view_path_list(@spanned(lo, hi,\n-                                {global: false,\n-                                 idents: path,\n-                                        types: []}), idents,\n-                             p.get_id()));\n+                let path = @{span: mk_sp(lo, p.span.hi),\n+                             global: false, idents: path, types: []};\n+                ret @spanned(lo, p.span.hi,\n+                             ast::view_path_list(path, idents, p.get_id()));\n               }\n \n               // foo::bar::*\n               token::BINOP(token::STAR) {\n                 p.bump();\n-                let mut hi = p.span.hi;\n-                ret @spanned(lo, hi,\n-                             ast::view_path_glob(@spanned(lo, hi,\n-                               {global: false,\n-                                idents: path,\n-                                types: []}),\n-                               p.get_id()));\n+                let path = @{span: mk_sp(lo, p.span.hi),\n+                             global: false, idents: path, types: []};\n+                ret @spanned(lo, p.span.hi,\n+                             ast::view_path_glob(path, p.get_id()));\n               }\n \n               _ { break; }\n@@ -2290,14 +2277,11 @@ fn parse_view_path(p: parser) -> @ast::view_path {\n       }\n       _ { }\n     }\n-    let mut hi = p.span.hi;\n     let last = path[vec::len(path) - 1u];\n-    ret @spanned(lo, hi,\n-                 ast::view_path_simple(last, @spanned(lo, hi,\n-                                                      {global: false,\n-                                                              idents: path,\n-                                                              types: []}),\n-                                       p.get_id()));\n+    let path = @{span: mk_sp(lo, p.span.hi), global: false,\n+                 idents: path, types: []};\n+    ret @spanned(lo, p.span.hi,\n+                 ast::view_path_simple(last, path, p.get_id()));\n }\n \n fn parse_view_paths(p: parser) -> [@ast::view_path] {"}, {"sha": "b979caab2e2f4137522cd32c07a8898f5a8fed92", "filename": "src/librustsyntax/print/pprust.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a872a99bfe400f794171a58fc47025133ce08155/src%2Flibrustsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a872a99bfe400f794171a58fc47025133ce08155/src%2Flibrustsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustsyntax%2Fprint%2Fpprust.rs?ref=a872a99bfe400f794171a58fc47025133ce08155", "patch": "@@ -1222,16 +1222,16 @@ fn print_for_decl(s: ps, loc: @ast::local, coll: @ast::expr) {\n \n fn print_path(s: ps, &&path: @ast::path, colons_before_params: bool) {\n     maybe_print_comment(s, path.span.lo);\n-    if path.node.global { word(s.s, \"::\"); }\n+    if path.global { word(s.s, \"::\"); }\n     let mut first = true;\n-    for path.node.idents.each {|id|\n+    for path.idents.each {|id|\n         if first { first = false; } else { word(s.s, \"::\"); }\n         word(s.s, id);\n     }\n-    if vec::len(path.node.types) > 0u {\n+    if vec::len(path.types) > 0u {\n         if colons_before_params { word(s.s, \"::\"); }\n         word(s.s, \"<\");\n-        commasep(s, inconsistent, path.node.types, print_type);\n+        commasep(s, inconsistent, path.types, print_type);\n         word(s.s, \">\");\n     }\n }\n@@ -1455,7 +1455,7 @@ fn print_meta_item(s: ps, &&item: @ast::meta_item) {\n fn print_view_path(s: ps, &&vp: @ast::view_path) {\n     alt vp.node {\n       ast::view_path_simple(ident, path, _) {\n-        if path.node.idents[vec::len(path.node.idents)-1u] != ident {\n+        if path.idents[vec::len(path.idents)-1u] != ident {\n             word_space(s, ident);\n             word_space(s, \"=\");\n         }"}, {"sha": "71dd5383e9ae9358aec7ee54eca0c9f0a574d779", "filename": "src/librustsyntax/visit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a872a99bfe400f794171a58fc47025133ce08155/src%2Flibrustsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a872a99bfe400f794171a58fc47025133ce08155/src%2Flibrustsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustsyntax%2Fvisit.rs?ref=a872a99bfe400f794171a58fc47025133ce08155", "patch": "@@ -213,7 +213,7 @@ fn visit_constr<E>(_operator: @path, _sp: span, _id: node_id, _e: E,\n }\n \n fn visit_path<E>(p: @path, e: E, v: vt<E>) {\n-    for p.node.types.each {|tp| v.visit_ty(tp, e, v); }\n+    for p.types.each {|tp| v.visit_ty(tp, e, v); }\n }\n \n fn visit_pat<E>(p: @pat, e: E, v: vt<E>) {"}, {"sha": "270b2a8b7e305a05af1287dd3e70738f59d14282", "filename": "src/rustc/front/test.rs", "status": "modified", "additions": 10, "deletions": 14, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/a872a99bfe400f794171a58fc47025133ce08155/src%2Frustc%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a872a99bfe400f794171a58fc47025133ce08155/src%2Frustc%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Ffront%2Ftest.rs?ref=a872a99bfe400f794171a58fc47025133ce08155", "patch": "@@ -206,6 +206,10 @@ fn nospan<T: copy>(t: T) -> ast::spanned<T> {\n     ret {node: t, span: dummy_sp()};\n }\n \n+fn path_node(ids: [ast::ident]) -> @ast::path {\n+    @{span: dummy_sp(), global: false, idents: ids, types: []}\n+}\n+\n fn mk_tests(cx: test_ctxt) -> @ast::item {\n     let ret_ty = mk_test_desc_vec_ty(cx);\n \n@@ -248,10 +252,7 @@ fn mk_path(cx: test_ctxt, path: [ast::ident]) -> [ast::ident] {\n \n // The ast::ty of [std::test::test_desc]\n fn mk_test_desc_vec_ty(cx: test_ctxt) -> @ast::ty {\n-    let test_desc_ty_path =\n-        @nospan({global: false,\n-                 idents: mk_path(cx, [\"test\", \"test_desc\"]),\n-                 types: []});\n+    let test_desc_ty_path = path_node(mk_path(cx, [\"test\", \"test_desc\"]));\n \n     let test_desc_ty: ast::ty =\n         {id: cx.sess.next_node_id(),\n@@ -294,7 +295,7 @@ fn mk_test_desc_rec(cx: test_ctxt, test: test) -> @ast::expr {\n     let name_field: ast::field =\n         nospan({mutbl: ast::m_imm, ident: \"name\", expr: @name_expr});\n \n-    let fn_path = @nospan({global: false, idents: path, types: []});\n+    let fn_path = path_node(path);\n \n     let fn_expr: ast::expr =\n         {id: cx.sess.next_node_id(),\n@@ -380,7 +381,7 @@ fn mk_test_wrapper(cx: test_ctxt,\n }\n \n fn mk_main(cx: test_ctxt) -> @ast::item {\n-    let str_pt = @nospan({global: false, idents: [\"str\"], types: []});\n+    let str_pt = path_node([\"str\"]);\n     let str_ty = @{id: cx.sess.next_node_id(),\n                    node: ast::ty_path(str_pt, cx.sess.next_node_id()),\n                    span: dummy_sp()};\n@@ -426,17 +427,15 @@ fn mk_main(cx: test_ctxt) -> @ast::item {\n fn mk_test_main_call(cx: test_ctxt) -> @ast::expr {\n \n     // Get the args passed to main so we can pass the to test_main\n-    let args_path =\n-        @nospan({global: false, idents: [\"args\"], types: []});\n+    let args_path = path_node([\"args\"]);\n \n     let args_path_expr_: ast::expr_ = ast::expr_path(args_path);\n \n     let args_path_expr: ast::expr =\n         {id: cx.sess.next_node_id(), node: args_path_expr_, span: dummy_sp()};\n \n     // Call __test::test to generate the vector of test_descs\n-    let test_path =\n-        @nospan({global: false, idents: [\"tests\"], types: []});\n+    let test_path = path_node([\"tests\"]);\n \n     let test_path_expr_: ast::expr_ = ast::expr_path(test_path);\n \n@@ -449,10 +448,7 @@ fn mk_test_main_call(cx: test_ctxt) -> @ast::expr {\n         {id: cx.sess.next_node_id(), node: test_call_expr_, span: dummy_sp()};\n \n     // Call std::test::test_main\n-    let test_main_path =\n-        @nospan({global: false,\n-                 idents: mk_path(cx, [\"test\", \"test_main\"]),\n-                 types: []});\n+    let test_main_path = path_node(mk_path(cx, [\"test\", \"test_main\"]));\n \n     let test_main_path_expr_: ast::expr_ = ast::expr_path(test_main_path);\n "}, {"sha": "0aaf79d3e8f50e2f18c77bd7fced837a5838ce2a", "filename": "src/rustc/metadata/tydecode.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a872a99bfe400f794171a58fc47025133ce08155/src%2Frustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a872a99bfe400f794171a58fc47025133ce08155/src%2Frustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Ftydecode.rs?ref=a872a99bfe400f794171a58fc47025133ce08155", "patch": "@@ -103,8 +103,8 @@ fn parse_path(st: @pstate) -> @ast::path {\n           ':' { next(st); next(st); }\n           c {\n             if c == '(' {\n-                ret @respan(ast_util::dummy_sp(),\n-                            {global: false, idents: idents, types: []});\n+                ret @{span: ast_util::dummy_sp(),\n+                      global: false, idents: idents, types: []};\n             } else { idents += [parse_ident_(st, is_last)]; }\n           }\n         }"}, {"sha": "6ad7f20674ab314d55cc4c4c9cd481eba2b72d19", "filename": "src/rustc/middle/infer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a872a99bfe400f794171a58fc47025133ce08155/src%2Frustc%2Fmiddle%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a872a99bfe400f794171a58fc47025133ce08155/src%2Frustc%2Fmiddle%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Finfer.rs?ref=a872a99bfe400f794171a58fc47025133ce08155", "patch": "@@ -493,7 +493,7 @@ impl unify_methods for infer_ctxt {\n               ast::carg_ident(p) {\n                 alt actual.node {\n                   ast::carg_ident(q) {\n-                    if p.node != q.node { ret err_res; }\n+                    if p.idents != q.idents { ret err_res; }\n                   }\n                   _ { ret err_res; }\n                 }"}, {"sha": "bcbcee5f411be8048973890d86fc360a447a19e7", "filename": "src/rustc/middle/pat_util.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a872a99bfe400f794171a58fc47025133ce08155/src%2Frustc%2Fmiddle%2Fpat_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a872a99bfe400f794171a58fc47025133ce08155/src%2Frustc%2Fmiddle%2Fpat_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fpat_util.rs?ref=a872a99bfe400f794171a58fc47025133ce08155", "patch": "@@ -69,7 +69,4 @@ fn pat_binding_ids(dm: resolve::def_map, pat: @pat) -> [node_id] {\n     ret found;\n }\n \n-fn path_to_ident(p: @path) -> ident {\n-  assert (vec::is_not_empty(p.node.idents)); // should be a constraint on path\n-  vec::last(p.node.idents)\n-}\n+fn path_to_ident(p: @path) -> ident { vec::last(p.idents) }"}, {"sha": "fa9f8e1f63f719f16de34a21373a07b13276aa58", "filename": "src/rustc/middle/resolve.rs", "status": "modified", "additions": 15, "deletions": 17, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/a872a99bfe400f794171a58fc47025133ce08155/src%2Frustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a872a99bfe400f794171a58fc47025133ce08155/src%2Frustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fresolve.rs?ref=a872a99bfe400f794171a58fc47025133ce08155", "patch": "@@ -231,16 +231,16 @@ fn map_crate(e: @env, c: @ast::crate) {\n         iter_effective_import_paths(*i) { |vp|\n             alt vp.node {\n               ast::view_path_simple(name, path, id) {\n-                e.imports.insert(id, todo(name, @path.node.idents, vp.span,\n+                e.imports.insert(id, todo(name, @path.idents, vp.span,\n                                           sc));\n               }\n               ast::view_path_glob(path, id) {\n-                e.imports.insert(id, is_glob(@path.node.idents, sc, vp.span));\n+                e.imports.insert(id, is_glob(@path.idents, sc, vp.span));\n               }\n               ast::view_path_list(mod_path, idents, _) {\n                 for idents.each {|ident|\n                     let t = todo(ident.node.name,\n-                                 @(mod_path.node.idents + [ident.node.name]),\n+                                 @(mod_path.idents + [ident.node.name]),\n                                  ident.span, sc);\n                     e.imports.insert(ident.node.id, t);\n                 }\n@@ -293,7 +293,7 @@ fn map_crate(e: @env, c: @ast::crate) {\n         iter_effective_import_paths(*vi) { |vp|\n             alt vp.node {\n               ast::view_path_glob(path, _) {\n-                alt follow_import(*e, sc, path.node.idents, vp.span) {\n+                alt follow_import(*e, sc, path.idents, vp.span) {\n                   some(imp) {\n                     let glob = {def: imp, path: vp};\n                     alt list::head(sc) {\n@@ -433,8 +433,7 @@ fn resolve_names(e: @env, c: @ast::crate) {\n              /* visit the iface paths... */\n              for ifaces.each {|p|\n                maybe_insert(e, p.id,\n-                 lookup_path_strict(*e, sc, p.path.span, p.path.node,\n-                                    ns_type))};\n+                 lookup_path_strict(*e, sc, p.path.span, p.path, ns_type))};\n            }\n            _ {}\n         }\n@@ -445,8 +444,7 @@ fn resolve_names(e: @env, c: @ast::crate) {\n         alt exp.node {\n           ast::expr_path(p) {\n             maybe_insert(e, exp.id,\n-                         lookup_path_strict(*e, sc, exp.span, p.node,\n-                                            ns_val));\n+                         lookup_path_strict(*e, sc, exp.span, p, ns_val));\n           }\n           ast::expr_fn(_, _, _, cap_clause) {\n             let rci = bind resolve_capture_item(e, sc, _);\n@@ -461,7 +459,7 @@ fn resolve_names(e: @env, c: @ast::crate) {\n         alt t.node {\n           ast::ty_path(p, id) {\n             maybe_insert(e, id,\n-                         lookup_path_strict(*e, sc, t.span, p.node, ns_type));\n+                         lookup_path_strict(*e, sc, t.span, p, ns_type));\n           }\n           _ { }\n         }\n@@ -483,13 +481,13 @@ fn resolve_names(e: @env, c: @ast::crate) {\n     }\n     fn walk_constr(e: @env, p: @ast::path, sp: span, id: node_id, sc: scopes,\n                    _v: vt<scopes>) {\n-        maybe_insert(e, id, lookup_path_strict(*e, sc, sp, p.node, ns_val));\n+        maybe_insert(e, id, lookup_path_strict(*e, sc, sp, p, ns_val));\n     }\n     fn walk_pat(e: @env, pat: @ast::pat, sc: scopes, v: vt<scopes>) {\n         visit::visit_pat(pat, sc, v);\n         alt pat.node {\n           ast::pat_enum(p, _) {\n-            alt lookup_path_strict(*e, sc, p.span, p.node, ns_val) {\n+            alt lookup_path_strict(*e, sc, p.span, p, ns_val) {\n               some(fnd@ast::def_variant(_,_)) {\n                 e.def_map.insert(pat.id, fnd);\n               }\n@@ -709,7 +707,7 @@ fn follow_import(e: env, sc: scopes, path: [ident], sp: span) ->\n }\n \n fn resolve_constr(e: @env, c: @ast::constr, sc: scopes, _v: vt<scopes>) {\n-    alt lookup_path_strict(*e, sc, c.span, c.node.path.node, ns_val) {\n+    alt lookup_path_strict(*e, sc, c.span, c.node.path, ns_val) {\n        some(d@ast::def_fn(_,ast::pure_fn)) {\n          e.def_map.insert(c.node.id, d);\n        }\n@@ -892,7 +890,7 @@ fn mk_unresolved_msg(id: ident, kind: str) -> str {\n }\n \n // Lookup helpers\n-fn lookup_path_strict(e: env, sc: scopes, sp: span, pth: ast::path_,\n+fn lookup_path_strict(e: env, sc: scopes, sp: span, pth: @ast::path,\n                       ns: namespace) -> option<def> {\n     let n_idents = vec::len(pth.idents);\n     let headns = if n_idents == 1u { ns } else { ns_module };\n@@ -2069,8 +2067,8 @@ fn check_exports(e: @env) {\n                         check_export(e, ident, _mod, id, vi);\n                       }\n                       ast::view_path_list(path, ids, node_id) {\n-                        let id = if vec::len(path.node.idents) == 1u {\n-                            path.node.idents[0]\n+                        let id = if vec::len(path.idents) == 1u {\n+                            path.idents[0]\n                         } else {\n                             e.sess.span_fatal(vp.span, \"bad export name-list\")\n                         };\n@@ -2137,12 +2135,12 @@ fn find_impls_in_view_item(e: env, vi: @ast::view_item,\n         alt vp.node {\n           ast::view_path_simple(name, pt, id) {\n             let mut found = [];\n-            if vec::len(pt.node.idents) == 1u {\n+            if vec::len(pt.idents) == 1u {\n                 option::iter(sc) {|sc|\n                     list::iter(sc) {|level|\n                         if vec::len(found) == 0u {\n                             for vec::each(*level) {|imp|\n-                                if imp.ident == pt.node.idents[0] {\n+                                if imp.ident == pt.idents[0] {\n                                     found += [@{ident: name with *imp}];\n                                 }\n                             }"}, {"sha": "fa7bbd6c6d7124220e6e5570102a206f0b99e960", "filename": "src/rustc/middle/tstate/auxiliary.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a872a99bfe400f794171a58fc47025133ce08155/src%2Frustc%2Fmiddle%2Ftstate%2Fauxiliary.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a872a99bfe400f794171a58fc47025133ce08155/src%2Frustc%2Fmiddle%2Ftstate%2Fauxiliary.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftstate%2Fauxiliary.rs?ref=a872a99bfe400f794171a58fc47025133ce08155", "patch": "@@ -594,7 +594,7 @@ fn expr_to_constr_arg(tcx: ty::ctxt, e: @expr) -> @constr_arg_use {\n           some(def_local(nid, _)) | some(def_arg(nid, _)) |\n           some(def_binding(nid)) | some(def_upvar(nid, _, _)) {\n             ret @respan(p.span,\n-                        carg_ident({ident: p.node.idents[0], node: nid}));\n+                        carg_ident({ident: p.idents[0], node: nid}));\n           }\n           some(what) {\n               tcx.sess.span_bug(e.span,"}, {"sha": "f1be864f48ae2f5f69b6dafb128fdbf230928401", "filename": "src/rustc/middle/tstate/bitvectors.rs", "status": "modified", "additions": 6, "deletions": 13, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/a872a99bfe400f794171a58fc47025133ce08155/src%2Frustc%2Fmiddle%2Ftstate%2Fbitvectors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a872a99bfe400f794171a58fc47025133ce08155/src%2Frustc%2Fmiddle%2Ftstate%2Fbitvectors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftstate%2Fbitvectors.rs?ref=a872a99bfe400f794171a58fc47025133ce08155", "patch": "@@ -183,20 +183,13 @@ fn kill_poststate(fcx: fn_ctxt, id: node_id, c: tsconstr) -> bool {\n fn clear_in_poststate_expr(fcx: fn_ctxt, e: @expr, t: poststate) {\n     alt e.node {\n       expr_path(p) {\n-        alt vec::last_opt(p.node.idents) {\n-          some(i) {\n-            alt local_node_id_to_def(fcx, e.id) {\n-              some(def_local(nid, _)) {\n-                clear_in_poststate_(bit_num(fcx, ninit(nid, i)), t);\n-              }\n-              some(_) {/* ignore args (for now...) */ }\n-              _ {\n-                fcx.ccx.tcx.sess.bug(\"clear_in_poststate_expr: \\\n-                                   unbound var\");\n-              }\n-            }\n+        alt local_node_id_to_def(fcx, e.id) {\n+          some(def_local(nid, _)) {\n+            clear_in_poststate_(bit_num(fcx, ninit(nid, vec::last(p.idents))),\n+                                t);\n           }\n-          _ { fcx.ccx.tcx.sess.bug(\"clear_in_poststate_expr\"); }\n+          some(_) {/* ignore args (for now...) */ }\n+          _ { fcx.ccx.tcx.sess.bug(\"clear_in_poststate_expr: unbound var\"); }\n         }\n       }\n       _ {/* do nothing */ }"}, {"sha": "35fa0bed980f02b7659379c5e212f0ea44bdbe51", "filename": "src/rustc/middle/typeck.rs", "status": "modified", "additions": 13, "deletions": 15, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/a872a99bfe400f794171a58fc47025133ce08155/src%2Frustc%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a872a99bfe400f794171a58fc47025133ce08155/src%2Frustc%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck.rs?ref=a872a99bfe400f794171a58fc47025133ce08155", "patch": "@@ -224,7 +224,7 @@ fn instantiate_path(fcx: @fn_ctxt,\n                     sp: span,\n                     id: ast::node_id) {\n     let ty_param_count = vec::len(*tpt.bounds);\n-    let ty_substs_len = vec::len(pth.node.types);\n+    let ty_substs_len = vec::len(pth.types);\n \n     // For now, there is no way to explicitly specify the region bound.\n     // This will have to change eventually.\n@@ -248,7 +248,7 @@ fn instantiate_path(fcx: @fn_ctxt,\n             (sp, \"not enough type parameters provided for this item\");\n         fcx.next_ty_vars(ty_param_count)\n     } else {\n-        pth.node.types.map { |aty| fcx.to_ty(aty) }\n+        pth.types.map { |aty| fcx.to_ty(aty) }\n     };\n \n     let substs = {self_r: self_r, tps: tps};\n@@ -593,7 +593,7 @@ fn ast_ty_to_ty<AC: ast_conv, RS: region_scope copy>(\n           some(d) { d }};\n         alt a_def {\n           ast::def_ty(did) | ast::def_class(did) {\n-            instantiate(self, rscope, ast_ty.span, did, id, path.node.types)\n+            instantiate(self, rscope, ast_ty.span, did, id, path.types)\n           }\n           ast::def_prim_ty(nty) {\n             alt nty {\n@@ -605,7 +605,7 @@ fn ast_ty_to_ty<AC: ast_conv, RS: region_scope copy>(\n             }\n           }\n           ast::def_ty_param(id, n) {\n-            if vec::len(path.node.types) > 0u {\n+            if vec::len(path.types) > 0u {\n                 tcx.sess.span_err(ast_ty.span, \"provided type parameters \\\n                                                 to a type parameter\");\n             }\n@@ -614,12 +614,12 @@ fn ast_ty_to_ty<AC: ast_conv, RS: region_scope copy>(\n           ast::def_self(self_id) {\n             alt check tcx.items.get(self_id) {\n               ast_map::node_item(@{node: ast::item_iface(tps, _), _}, _) {\n-                if vec::len(tps) != vec::len(path.node.types) {\n+                if vec::len(tps) != vec::len(path.types) {\n                     tcx.sess.span_err(ast_ty.span, \"incorrect number of \\\n                                                     type parameters to \\\n                                                     self type\");\n                 }\n-                ty::mk_self(tcx, vec::map(path.node.types, {|ast_ty|\n+                ty::mk_self(tcx, vec::map(path.types, {|ast_ty|\n                     ast_ty_to_ty(self, rscope, ast_ty)\n                 }))\n               }\n@@ -3970,22 +3970,20 @@ fn check_constraints(fcx: @fn_ctxt, cs: [@ast::constr], args: [ast::arg]) {\n                     }\n                     ast::carg_ident(i) {\n                       if i < num_args {\n-                          let p: ast::path_ =\n-                              {global: false,\n-                               idents: [args[i].ident],\n-                               types: []};\n+                          let p = @{span: a.span, global: false,\n+                                    idents: [args[i].ident], types: []};\n                           let arg_occ_node_id =\n                               fcx.ccx.tcx.sess.next_node_id();\n                           fcx.ccx.tcx.def_map.insert\n                               (arg_occ_node_id,\n                                ast::def_arg(args[i].id, args[i].mode));\n                           {id: arg_occ_node_id,\n-                           node: ast::expr_path(@respan(a.span, p)),\n+                           node: ast::expr_path(p),\n                            span: a.span}\n                       } else {\n-                          fcx.ccx.tcx.sess.span_bug(a.span,\n-                                                    \"check_constraints:\\\n-                     carg_ident index out of bounds\");\n+                          fcx.ccx.tcx.sess.span_bug(\n+                              a.span, \"check_constraints:\\\n+                                       carg_ident index out of bounds\");\n                       }\n                     }\n                   }];\n@@ -4181,7 +4179,7 @@ fn check_fn(ccx: @crate_ctxt,\n               if !pat_util::pat_is_variant(fcx.ccx.tcx.def_map, p) {\n                 assign(p.id, none);\n                 #debug[\"Pattern binding %s is assigned to %s\",\n-                       path.node.idents[0],\n+                       path.idents[0],\n                        fcx.locals.get(p.id).to_str()];\n               }\n               _ {}"}]}