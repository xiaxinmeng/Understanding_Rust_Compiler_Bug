{"sha": "36a17e4067d2e67223cd9a172476ee5503d6b44b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM2YTE3ZTQwNjdkMmU2NzIyM2NkOWExNzI0NzZlZTU1MDNkNmI0NGI=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2020-01-30T07:31:31Z"}, "committer": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2020-02-13T09:39:24Z"}, "message": "parser_fn_front_matter: allow `const .. extern`", "tree": {"sha": "27715b8214a734d40f705a0e9f48a0d50d8b6a62", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/27715b8214a734d40f705a0e9f48a0d50d8b6a62"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/36a17e4067d2e67223cd9a172476ee5503d6b44b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/36a17e4067d2e67223cd9a172476ee5503d6b44b", "html_url": "https://github.com/rust-lang/rust/commit/36a17e4067d2e67223cd9a172476ee5503d6b44b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/36a17e4067d2e67223cd9a172476ee5503d6b44b/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c30f068dc8b2ef58678b9846ba834dd6dea3fe44", "url": "https://api.github.com/repos/rust-lang/rust/commits/c30f068dc8b2ef58678b9846ba834dd6dea3fe44", "html_url": "https://github.com/rust-lang/rust/commit/c30f068dc8b2ef58678b9846ba834dd6dea3fe44"}], "stats": {"total": 211, "additions": 104, "deletions": 107}, "files": [{"sha": "d2bcf31cb055199ea8b18d7d5e941d600d7a9bf4", "filename": "src/librustc_parse/parser/item.rs", "status": "modified", "additions": 52, "deletions": 53, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/36a17e4067d2e67223cd9a172476ee5503d6b44b/src%2Flibrustc_parse%2Fparser%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36a17e4067d2e67223cd9a172476ee5503d6b44b/src%2Flibrustc_parse%2Fparser%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fitem.rs?ref=36a17e4067d2e67223cd9a172476ee5503d6b44b", "patch": "@@ -798,12 +798,12 @@ impl<'a> Parser<'a> {\n         let defaultness = self.parse_defaultness();\n         let (name, kind, generics) = if self.eat_keyword(kw::Type) {\n             self.parse_assoc_ty()?\n-        } else if self.is_const_item() {\n-            self.parse_assoc_const()?\n+        } else if self.is_fn_front_matter() {\n+            self.parse_assoc_fn(at_end, &mut attrs, is_name_required)?\n         } else if let Some(mac) = self.parse_assoc_macro_invoc(\"associated\", Some(&vis), at_end)? {\n             (Ident::invalid(), AssocItemKind::Macro(mac), Generics::default())\n         } else {\n-            self.parse_assoc_fn(at_end, &mut attrs, is_name_required)?\n+            self.parse_assoc_const()?\n         };\n \n         Ok(AssocItem {\n@@ -819,12 +819,6 @@ impl<'a> Parser<'a> {\n         })\n     }\n \n-    /// Returns `true` if we are looking at `const ID`\n-    /// (returns `false` for things like `const fn`, etc.).\n-    fn is_const_item(&self) -> bool {\n-        self.token.is_keyword(kw::Const) && !self.is_keyword_ahead(1, &[kw::Fn, kw::Unsafe])\n-    }\n-\n     /// This parses the grammar:\n     ///\n     ///     AssocConst = \"const\" Ident \":\" Ty \"=\" Expr \";\"\n@@ -1034,21 +1028,20 @@ impl<'a> Parser<'a> {\n \n         let attrs = self.parse_outer_attributes()?;\n         let lo = self.token.span;\n-        let visibility = self.parse_visibility(FollowedByType::No)?;\n+        let vis = self.parse_visibility(FollowedByType::No)?;\n \n-        // FOREIGN TYPE ITEM\n         if self.check_keyword(kw::Type) {\n-            return self.parse_item_foreign_type(visibility, lo, attrs);\n-        }\n-\n-        // FOREIGN STATIC ITEM\n-        if self.is_static_global() {\n+            // FOREIGN TYPE ITEM\n+            self.parse_item_foreign_type(vis, lo, attrs)\n+        } else if self.is_fn_front_matter() {\n+            // FOREIGN FUNCTION ITEM\n+            self.parse_item_foreign_fn(vis, lo, attrs)\n+        } else if self.is_static_global() {\n+            // FOREIGN STATIC ITEM\n             self.bump(); // `static`\n-            return self.parse_item_foreign_static(visibility, lo, attrs);\n-        }\n-\n-        // Treat `const` as `static` for error recovery, but don't add it to expected tokens.\n-        if self.is_kw_followed_by_ident(kw::Const) {\n+            self.parse_item_foreign_static(vis, lo, attrs)\n+        } else if self.token.is_keyword(kw::Const) {\n+            // Treat `const` as `static` for error recovery, but don't add it to expected tokens.\n             self.bump(); // `const`\n             self.struct_span_err(self.prev_span, \"extern items cannot be `const`\")\n                 .span_suggestion(\n@@ -1058,32 +1051,17 @@ impl<'a> Parser<'a> {\n                     Applicability::MachineApplicable,\n                 )\n                 .emit();\n-            return self.parse_item_foreign_static(visibility, lo, attrs);\n-        }\n-\n-        // FOREIGN FUNCTION ITEM\n-        const MAY_INTRODUCE_FN: &[Symbol] = &[kw::Const, kw::Async, kw::Unsafe, kw::Extern, kw::Fn];\n-        if MAY_INTRODUCE_FN.iter().any(|&kw| self.check_keyword(kw)) {\n-            return self.parse_item_foreign_fn(visibility, lo, attrs);\n-        }\n-\n-        match self.parse_assoc_macro_invoc(\"extern\", Some(&visibility), &mut false)? {\n-            Some(mac) => Ok(P(ForeignItem {\n-                ident: Ident::invalid(),\n-                span: lo.to(self.prev_span),\n-                id: DUMMY_NODE_ID,\n-                attrs,\n-                vis: visibility,\n-                kind: ForeignItemKind::Macro(mac),\n-                tokens: None,\n-            })),\n-            None => {\n-                if !attrs.is_empty() {\n-                    self.expected_item_err(&attrs)?;\n-                }\n-\n-                self.unexpected()\n+            self.parse_item_foreign_static(vis, lo, attrs)\n+        } else if let Some(mac) = self.parse_assoc_macro_invoc(\"extern\", Some(&vis), &mut false)? {\n+            let kind = ForeignItemKind::Macro(mac);\n+            let span = lo.to(self.prev_span);\n+            let ident = Ident::invalid();\n+            Ok(P(ForeignItem { ident, span, id: DUMMY_NODE_ID, attrs, vis, kind, tokens: None }))\n+        } else {\n+            if !attrs.is_empty() {\n+                self.expected_item_err(&attrs)?;\n             }\n+            self.unexpected()\n         }\n     }\n \n@@ -1752,6 +1730,29 @@ impl<'a> Parser<'a> {\n         Ok(body)\n     }\n \n+    /// Is the current token unambiguously the start of an `FnHeader`?\n+    fn is_fn_front_matter(&mut self) -> bool {\n+        // We use an over-approximation here.\n+        // `const const`, `fn const` won't parse, but we're not stepping over other syntax either.\n+        // This works for `async fn` and similar as `async async` is an invalid\n+        // parse and `async fn` is never a valid parse on previous editions.\n+        const QUALIFIER: [Symbol; 4] = [kw::Const, kw::Async, kw::Unsafe, kw::Extern];\n+\n+        let check_qual_follow = |this: &mut Self, dist| {\n+            this.look_ahead(dist, |t| {\n+                // ...qualified and then `fn`, e.g. `const fn`.\n+                t.is_keyword(kw::Fn)\n+                // Two qualifiers. This is enough.\n+                || QUALIFIER.iter().any(|&kw| t.is_keyword(kw))\n+            })\n+        };\n+        self.check_keyword(kw::Fn) // Definitely an `fn`.\n+            // `$qual fn` or `$qual $qual`:\n+            || QUALIFIER.iter().any(|&kw| self.check_keyword(kw)) && check_qual_follow(self, 1)\n+            // `extern ABI fn` or `extern ABI $qual`; skip 1 for the ABI.\n+            || self.check_keyword(kw::Extern) && check_qual_follow(self, 2)\n+    }\n+\n     /// Parses all the \"front matter\" (or \"qualifiers\") for a `fn` declaration,\n     /// up to and including the `fn` keyword. The formal grammar is:\n     ///\n@@ -1763,16 +1764,13 @@ impl<'a> Parser<'a> {\n     fn parse_fn_front_matter(&mut self) -> PResult<'a, FnHeader> {\n         let constness = self.parse_constness();\n         let asyncness = self.parse_asyncness();\n+        let unsafety = self.parse_unsafety();\n+        let ext = self.parse_extern()?;\n+\n         if let Async::Yes { span, .. } = asyncness {\n             self.ban_async_in_2015(span);\n         }\n-        let unsafety = self.parse_unsafety();\n-        let (constness, unsafety, ext) = if let Const::Yes(_) = constness {\n-            (constness, unsafety, Extern::None)\n-        } else {\n-            let ext = self.parse_extern()?;\n-            (Const::No, unsafety, ext)\n-        };\n+\n         if !self.eat_keyword(kw::Fn) {\n             // It is possible for `expect_one_of` to recover given the contents of\n             // `self.expected_tokens`, therefore, do not use `self.unexpected()` which doesn't\n@@ -1781,6 +1779,7 @@ impl<'a> Parser<'a> {\n                 unreachable!()\n             }\n         }\n+\n         Ok(FnHeader { constness, unsafety, asyncness, ext })\n     }\n "}, {"sha": "e97af0dc00c690774f3ce96f524dc85f69570a48", "filename": "src/librustc_parse/parser/stmt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/36a17e4067d2e67223cd9a172476ee5503d6b44b/src%2Flibrustc_parse%2Fparser%2Fstmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36a17e4067d2e67223cd9a172476ee5503d6b44b/src%2Flibrustc_parse%2Fparser%2Fstmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fstmt.rs?ref=36a17e4067d2e67223cd9a172476ee5503d6b44b", "patch": "@@ -199,7 +199,7 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    pub(super) fn is_kw_followed_by_ident(&self, kw: Symbol) -> bool {\n+    fn is_kw_followed_by_ident(&self, kw: Symbol) -> bool {\n         self.token.is_keyword(kw) && self.look_ahead(1, |t| t.is_ident() && !t.is_reserved_ident())\n     }\n "}, {"sha": "1323f646be893596577912b182e53bda5b6b060a", "filename": "src/test/ui/issues/issue-60075.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/36a17e4067d2e67223cd9a172476ee5503d6b44b/src%2Ftest%2Fui%2Fissues%2Fissue-60075.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36a17e4067d2e67223cd9a172476ee5503d6b44b/src%2Ftest%2Fui%2Fissues%2Fissue-60075.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-60075.rs?ref=36a17e4067d2e67223cd9a172476ee5503d6b44b", "patch": "@@ -6,6 +6,5 @@ trait T {\n         });\n //~^ ERROR expected one of `async`\n //~| ERROR expected one of `.`, `;`, `?`, `else`, or an operator, found `}`\n-//~| ERROR expected identifier, found `;`\n         Some(4)\n     }"}, {"sha": "60eb99b46b79f9ace240d3bdee06fa6c2189a48c", "filename": "src/test/ui/issues/issue-60075.stderr", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/36a17e4067d2e67223cd9a172476ee5503d6b44b/src%2Ftest%2Fui%2Fissues%2Fissue-60075.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/36a17e4067d2e67223cd9a172476ee5503d6b44b/src%2Ftest%2Fui%2Fissues%2Fissue-60075.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-60075.stderr?ref=36a17e4067d2e67223cd9a172476ee5503d6b44b", "patch": "@@ -13,11 +13,5 @@ LL |         let _ = if true {\n LL |         });\n    |           ^ help: `}` may belong here\n \n-error: expected identifier, found `;`\n-  --> $DIR/issue-60075.rs:6:11\n-   |\n-LL |         });\n-   |           ^ expected identifier\n-\n-error: aborting due to 3 previous errors\n+error: aborting due to 2 previous errors\n "}, {"sha": "98ff2b6d2e8b3e346d1fe5da5fb62f7a6c28b708", "filename": "src/test/ui/parser/fn-header-semantic-fail.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/36a17e4067d2e67223cd9a172476ee5503d6b44b/src%2Ftest%2Fui%2Fparser%2Ffn-header-semantic-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36a17e4067d2e67223cd9a172476ee5503d6b44b/src%2Ftest%2Fui%2Fparser%2Ffn-header-semantic-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Ffn-header-semantic-fail.rs?ref=36a17e4067d2e67223cd9a172476ee5503d6b44b", "patch": "@@ -18,9 +18,9 @@ fn main() {\n         unsafe fn ft2(); // OK.\n         const fn ft3(); //~ ERROR trait fns cannot be declared const\n         extern \"C\" fn ft4(); // OK.\n-        /* const */ async unsafe extern \"C\" fn ft5();\n+        const async unsafe extern \"C\" fn ft5();\n         //~^ ERROR trait fns cannot be declared `async`\n-        //^ FIXME(Centril): `const` should be legal syntactically, ensure it's illegal semantically.\n+        //~| ERROR trait fns cannot be declared const\n     }\n \n     struct Y;\n@@ -30,28 +30,25 @@ fn main() {\n         unsafe fn ft2() {} // OK.\n         const fn ft3() {} //~ ERROR trait fns cannot be declared const\n         extern \"C\" fn ft4() {}\n-        /* const */ async unsafe extern \"C\" fn ft5() {}\n+        const async unsafe extern \"C\" fn ft5() {}\n         //~^ ERROR trait fns cannot be declared `async`\n+        //~| ERROR trait fns cannot be declared const\n         //~| ERROR method `ft5` has an incompatible type for trait\n-        //^ FIXME(Centril): `const` should be legal syntactically, ensure it's illegal semantically.\n     }\n \n     impl Y {\n         async fn fi1() {} // OK.\n         unsafe fn fi2() {} // OK.\n         const fn fi3() {} // OK.\n         extern \"C\" fn fi4() {} // OK.\n-        /* const */ async unsafe extern \"C\" fn fi5() {} // OK.\n-        //^ FIXME(Centril): `const` should be legal syntactically, ensure it's illegal semantically.\n+        const async unsafe extern \"C\" fn fi5() {} // OK.\n     }\n \n     extern {\n         async fn fe1(); //~ ERROR functions in `extern` blocks cannot have qualifiers\n         unsafe fn fe2(); //~ ERROR functions in `extern` blocks cannot have qualifiers\n         const fn fe3(); //~ ERROR functions in `extern` blocks cannot have qualifiers\n         extern \"C\" fn fe4(); //~ ERROR functions in `extern` blocks cannot have qualifiers\n-        /* const */ async unsafe extern \"C\" fn fe5();\n-        //~^ ERROR functions in `extern` blocks cannot have qualifiers\n-        //^ FIXME(Centril): `const` should be legal syntactically, ensure it's illegal semantically.\n+        const async unsafe extern \"C\" fn fe5(); //~ ERROR functions in `extern` blocks\n     }\n }"}, {"sha": "1860106b255ab50f4b634537e498a9717be911a7", "filename": "src/test/ui/parser/fn-header-semantic-fail.stderr", "status": "modified", "additions": 40, "deletions": 28, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/36a17e4067d2e67223cd9a172476ee5503d6b44b/src%2Ftest%2Fui%2Fparser%2Ffn-header-semantic-fail.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/36a17e4067d2e67223cd9a172476ee5503d6b44b/src%2Ftest%2Fui%2Fparser%2Ffn-header-semantic-fail.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Ffn-header-semantic-fail.stderr?ref=36a17e4067d2e67223cd9a172476ee5503d6b44b", "patch": "@@ -15,13 +15,19 @@ error[E0379]: trait fns cannot be declared const\n LL |         const fn ft3();\n    |         ^^^^^ trait fns cannot be const\n \n+error[E0379]: trait fns cannot be declared const\n+  --> $DIR/fn-header-semantic-fail.rs:21:9\n+   |\n+LL |         const async unsafe extern \"C\" fn ft5();\n+   |         ^^^^^ trait fns cannot be const\n+\n error[E0706]: trait fns cannot be declared `async`\n-  --> $DIR/fn-header-semantic-fail.rs:21:21\n+  --> $DIR/fn-header-semantic-fail.rs:21:9\n    |\n-LL |         /* const */ async unsafe extern \"C\" fn ft5();\n-   |                     -----^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |                     |\n-   |                     `async` because of this\n+LL |         const async unsafe extern \"C\" fn ft5();\n+   |         ^^^^^^-----^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |               |\n+   |               `async` because of this\n    |\n    = note: `async` trait functions are not currently supported\n    = note: consider using the `async-trait` crate: https://crates.io/crates/async-trait\n@@ -43,19 +49,25 @@ error[E0379]: trait fns cannot be declared const\n LL |         const fn ft3() {}\n    |         ^^^^^ trait fns cannot be const\n \n+error[E0379]: trait fns cannot be declared const\n+  --> $DIR/fn-header-semantic-fail.rs:33:9\n+   |\n+LL |         const async unsafe extern \"C\" fn ft5() {}\n+   |         ^^^^^ trait fns cannot be const\n+\n error[E0706]: trait fns cannot be declared `async`\n-  --> $DIR/fn-header-semantic-fail.rs:33:21\n+  --> $DIR/fn-header-semantic-fail.rs:33:9\n    |\n-LL |         /* const */ async unsafe extern \"C\" fn ft5() {}\n-   |                     -----^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |                     |\n-   |                     `async` because of this\n+LL |         const async unsafe extern \"C\" fn ft5() {}\n+   |         ^^^^^^-----^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |               |\n+   |               `async` because of this\n    |\n    = note: `async` trait functions are not currently supported\n    = note: consider using the `async-trait` crate: https://crates.io/crates/async-trait\n \n error: functions in `extern` blocks cannot have qualifiers\n-  --> $DIR/fn-header-semantic-fail.rs:49:18\n+  --> $DIR/fn-header-semantic-fail.rs:48:18\n    |\n LL |     extern {\n    |     ------ in this `extern` block\n@@ -65,7 +77,7 @@ LL |         async fn fe1();\n    |         help: remove the qualifiers: `fn`\n \n error: functions in `extern` blocks cannot have qualifiers\n-  --> $DIR/fn-header-semantic-fail.rs:50:19\n+  --> $DIR/fn-header-semantic-fail.rs:49:19\n    |\n LL |     extern {\n    |     ------ in this `extern` block\n@@ -76,7 +88,7 @@ LL |         unsafe fn fe2();\n    |         help: remove the qualifiers: `fn`\n \n error: functions in `extern` blocks cannot have qualifiers\n-  --> $DIR/fn-header-semantic-fail.rs:51:18\n+  --> $DIR/fn-header-semantic-fail.rs:50:18\n    |\n LL |     extern {\n    |     ------ in this `extern` block\n@@ -87,7 +99,7 @@ LL |         const fn fe3();\n    |         help: remove the qualifiers: `fn`\n \n error: functions in `extern` blocks cannot have qualifiers\n-  --> $DIR/fn-header-semantic-fail.rs:52:23\n+  --> $DIR/fn-header-semantic-fail.rs:51:23\n    |\n LL |     extern {\n    |     ------ in this `extern` block\n@@ -98,15 +110,15 @@ LL |         extern \"C\" fn fe4();\n    |         help: remove the qualifiers: `fn`\n \n error: functions in `extern` blocks cannot have qualifiers\n-  --> $DIR/fn-header-semantic-fail.rs:53:48\n+  --> $DIR/fn-header-semantic-fail.rs:52:42\n    |\n LL |     extern {\n    |     ------ in this `extern` block\n ...\n-LL |         /* const */ async unsafe extern \"C\" fn fe5();\n-   |                     ---------------------------^^^\n-   |                     |\n-   |                     help: remove the qualifiers: `fn`\n+LL |         const async unsafe extern \"C\" fn fe5();\n+   |         ---------------------------------^^^\n+   |         |\n+   |         help: remove the qualifiers: `fn`\n \n error[E0053]: method `ft1` has an incompatible type for trait\n   --> $DIR/fn-header-semantic-fail.rs:28:24\n@@ -124,21 +136,21 @@ LL |         async fn ft1() {}\n               found fn pointer `fn() -> impl std::future::Future`\n \n error[E0053]: method `ft5` has an incompatible type for trait\n-  --> $DIR/fn-header-semantic-fail.rs:33:54\n+  --> $DIR/fn-header-semantic-fail.rs:33:48\n    |\n-LL |         /* const */ async unsafe extern \"C\" fn ft5();\n-   |                                                     - type in trait\n+LL |         const async unsafe extern \"C\" fn ft5();\n+   |                                               - type in trait\n ...\n-LL |         /* const */ async unsafe extern \"C\" fn ft5() {}\n-   |                                                      ^\n-   |                                                      |\n-   |                                                      the `Output` of this `async fn`'s found opaque type\n-   |                                                      expected `()`, found opaque type\n+LL |         const async unsafe extern \"C\" fn ft5() {}\n+   |                                                ^\n+   |                                                |\n+   |                                                the `Output` of this `async fn`'s found opaque type\n+   |                                                expected `()`, found opaque type\n    |\n    = note: expected fn pointer `unsafe extern \"C\" fn()`\n               found fn pointer `unsafe extern \"C\" fn() -> impl std::future::Future`\n \n-error: aborting due to 13 previous errors\n+error: aborting due to 15 previous errors\n \n Some errors have detailed explanations: E0053, E0379, E0706.\n For more information about an error, try `rustc --explain E0053`."}, {"sha": "0557b9ef6ca23267363fee176c802c84d9bb3de9", "filename": "src/test/ui/parser/fn-header-syntactic-pass.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/36a17e4067d2e67223cd9a172476ee5503d6b44b/src%2Ftest%2Fui%2Fparser%2Ffn-header-syntactic-pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36a17e4067d2e67223cd9a172476ee5503d6b44b/src%2Ftest%2Fui%2Fparser%2Ffn-header-syntactic-pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Ffn-header-syntactic-pass.rs?ref=36a17e4067d2e67223cd9a172476ee5503d6b44b", "patch": "@@ -22,34 +22,30 @@ fn syntax() {\n         unsafe fn f();\n         const fn f();\n         extern \"C\" fn f();\n-        /* const */ async unsafe extern \"C\" fn f();\n-        //^ FIXME(Centril): `const` should be legal syntactically.\n+        const async unsafe extern \"C\" fn f();\n     }\n \n     impl X for Y {\n         async fn f();\n         unsafe fn f();\n         const fn f();\n         extern \"C\" fn f();\n-        /* const */ async unsafe extern \"C\" fn f();\n-        //^ FIXME(Centril): `const` should be legal syntactically.\n+        const async unsafe extern \"C\" fn f();\n     }\n \n     impl Y {\n         async fn f();\n         unsafe fn f();\n         const fn f();\n         extern \"C\" fn f();\n-        /* const */ async unsafe extern \"C\" fn f();\n-        //^ FIXME(Centril): `const` should be legal syntactically.\n+        const async unsafe extern \"C\" fn f();\n     }\n \n     extern {\n         async fn f();\n         unsafe fn f();\n         const fn f();\n         extern \"C\" fn f();\n-        /* const */ async unsafe extern \"C\" fn f();\n-        //^ FIXME(Centril): `const` should be legal syntactically.\n+        const async unsafe extern \"C\" fn f();\n     }\n }"}]}