{"sha": "0ec370670220b712b042ee09aab067ec7e5878d5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBlYzM3MDY3MDIyMGI3MTJiMDQyZWUwOWFhYjA2N2VjN2U1ODc4ZDU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-01-01T21:27:11Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-01-01T21:27:11Z"}, "message": "Auto merge of #67676 - wesleywiser:lint_overflowing_int_casts, r=oli-obk\n\nLint overflowing integer casts in const prop\n\nThis extends the invalid cases we catch in const prop to include\noverflowing integer casts using the same machinery as the overflowing\nbinary and unary operation logic.\n\nr? @oli-obk", "tree": {"sha": "fc3bbd0130e7c81ba177c87450ac8525bcbf2a1d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fc3bbd0130e7c81ba177c87450ac8525bcbf2a1d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0ec370670220b712b042ee09aab067ec7e5878d5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0ec370670220b712b042ee09aab067ec7e5878d5", "html_url": "https://github.com/rust-lang/rust/commit/0ec370670220b712b042ee09aab067ec7e5878d5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0ec370670220b712b042ee09aab067ec7e5878d5/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1ed41b072093fe7cccd232f9a2964c5fb6ab9f60", "url": "https://api.github.com/repos/rust-lang/rust/commits/1ed41b072093fe7cccd232f9a2964c5fb6ab9f60", "html_url": "https://github.com/rust-lang/rust/commit/1ed41b072093fe7cccd232f9a2964c5fb6ab9f60"}, {"sha": "e8c1c4cd5bc0d370f59d0399ae2458e872a51622", "url": "https://api.github.com/repos/rust-lang/rust/commits/e8c1c4cd5bc0d370f59d0399ae2458e872a51622", "html_url": "https://github.com/rust-lang/rust/commit/e8c1c4cd5bc0d370f59d0399ae2458e872a51622"}], "stats": {"total": 282, "additions": 219, "deletions": 63}, "files": [{"sha": "3895cdf71a61c9472196e362ef05b2998d778361", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 135, "deletions": 63, "changes": 198, "blob_url": "https://github.com/rust-lang/rust/blob/0ec370670220b712b042ee09aab067ec7e5878d5/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ec370670220b712b042ee09aab067ec7e5878d5/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=0ec370670220b712b042ee09aab067ec7e5878d5", "patch": "@@ -12,10 +12,10 @@ use rustc::mir::visit::{\n     MutVisitor, MutatingUseContext, NonMutatingUseContext, PlaceContext, Visitor,\n };\n use rustc::mir::{\n-    read_only, AggregateKind, BasicBlock, BinOp, Body, BodyAndCache, ClearCrossCrate, Constant,\n-    Local, LocalDecl, LocalKind, Location, Operand, Place, PlaceBase, ReadOnlyBodyAndCache, Rvalue,\n-    SourceInfo, SourceScope, SourceScopeData, Statement, StatementKind, Terminator, TerminatorKind,\n-    UnOp, RETURN_PLACE,\n+    read_only, AggregateKind, BasicBlock, BinOp, Body, BodyAndCache, CastKind, ClearCrossCrate,\n+    Constant, Local, LocalDecl, LocalKind, Location, Operand, Place, PlaceBase,\n+    ReadOnlyBodyAndCache, Rvalue, SourceInfo, SourceScope, SourceScopeData, Statement,\n+    StatementKind, Terminator, TerminatorKind, UnOp, RETURN_PLACE,\n };\n use rustc::ty::layout::{\n     HasDataLayout, HasTyCtxt, LayoutError, LayoutOf, Size, TargetDataLayout, TyLayout,\n@@ -29,9 +29,9 @@ use syntax::ast::Mutability;\n \n use crate::const_eval::error_to_const_error;\n use crate::interpret::{\n-    self, intern_const_alloc_recursive, AllocId, Allocation, Frame, ImmTy, Immediate, InterpCx,\n-    LocalState, LocalValue, Memory, MemoryKind, OpTy, Operand as InterpOperand, PlaceTy, Pointer,\n-    ScalarMaybeUndef, StackPopCleanup,\n+    self, intern_const_alloc_recursive, truncate, AllocId, Allocation, Frame, ImmTy, Immediate,\n+    InterpCx, LocalState, LocalValue, Memory, MemoryKind, OpTy, Operand as InterpOperand, PlaceTy,\n+    Pointer, ScalarMaybeUndef, StackPopCleanup,\n };\n use crate::rustc::ty::subst::Subst;\n use crate::transform::{MirPass, MirSource};\n@@ -469,15 +469,134 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n         }\n     }\n \n+    fn check_unary_op(&mut self, arg: &Operand<'tcx>, source_info: SourceInfo) -> Option<()> {\n+        self.use_ecx(source_info, |this| {\n+            let ty = arg.ty(&this.local_decls, this.tcx);\n+\n+            if ty.is_integral() {\n+                let arg = this.ecx.eval_operand(arg, None)?;\n+                let prim = this.ecx.read_immediate(arg)?;\n+                // Need to do overflow check here: For actual CTFE, MIR\n+                // generation emits code that does this before calling the op.\n+                if prim.to_bits()? == (1 << (prim.layout.size.bits() - 1)) {\n+                    throw_panic!(OverflowNeg)\n+                }\n+            }\n+\n+            Ok(())\n+        })?;\n+\n+        Some(())\n+    }\n+\n+    fn check_binary_op(\n+        &mut self,\n+        op: BinOp,\n+        left: &Operand<'tcx>,\n+        right: &Operand<'tcx>,\n+        source_info: SourceInfo,\n+        place_layout: TyLayout<'tcx>,\n+        overflow_check: bool,\n+    ) -> Option<()> {\n+        let r = self.use_ecx(source_info, |this| {\n+            this.ecx.read_immediate(this.ecx.eval_operand(right, None)?)\n+        })?;\n+        if op == BinOp::Shr || op == BinOp::Shl {\n+            let left_bits = place_layout.size.bits();\n+            let right_size = r.layout.size;\n+            let r_bits = r.to_scalar().and_then(|r| r.to_bits(right_size));\n+            if r_bits.map_or(false, |b| b >= left_bits as u128) {\n+                let lint_root = self.lint_root(source_info)?;\n+                let dir = if op == BinOp::Shr { \"right\" } else { \"left\" };\n+                self.tcx.lint_hir(\n+                    ::rustc::lint::builtin::EXCEEDING_BITSHIFTS,\n+                    lint_root,\n+                    source_info.span,\n+                    &format!(\"attempt to shift {} with overflow\", dir),\n+                );\n+                return None;\n+            }\n+        }\n+\n+        // If overflow checking is enabled (like in debug mode by default),\n+        // then we'll already catch overflow when we evaluate the `Assert` statement\n+        // in MIR. However, if overflow checking is disabled, then there won't be any\n+        // `Assert` statement and so we have to do additional checking here.\n+        if !overflow_check {\n+            self.use_ecx(source_info, |this| {\n+                let l = this.ecx.read_immediate(this.ecx.eval_operand(left, None)?)?;\n+                let (_, overflow, _ty) = this.ecx.overflowing_binary_op(op, l, r)?;\n+\n+                if overflow {\n+                    let err = err_panic!(Overflow(op)).into();\n+                    return Err(err);\n+                }\n+\n+                Ok(())\n+            })?;\n+        }\n+\n+        Some(())\n+    }\n+\n+    fn check_cast(\n+        &mut self,\n+        op: &Operand<'tcx>,\n+        ty: Ty<'tcx>,\n+        source_info: SourceInfo,\n+        place_layout: TyLayout<'tcx>,\n+    ) -> Option<()> {\n+        if !ty.is_integral() || !op.ty(&self.local_decls, self.tcx).is_integral() {\n+            return Some(());\n+        }\n+\n+        let value = self.use_ecx(source_info, |this| {\n+            this.ecx.read_immediate(this.ecx.eval_operand(op, None)?)\n+        })?;\n+\n+        // Do not try to read bits for ZSTs. This can occur when casting an enum with one variant\n+        // to an integer. Such enums are represented as ZSTs but still have a discriminant value\n+        // which can be casted.\n+        if value.layout.is_zst() {\n+            return Some(());\n+        }\n+\n+        let value_size = value.layout.size;\n+        let value_bits = value.to_scalar().and_then(|r| r.to_bits(value_size));\n+        if let Ok(value_bits) = value_bits {\n+            let truncated = truncate(value_bits, place_layout.size);\n+            if truncated != value_bits {\n+                let scope = source_info.scope;\n+                let lint_root = match &self.source_scopes[scope].local_data {\n+                    ClearCrossCrate::Set(data) => data.lint_root,\n+                    ClearCrossCrate::Clear => return None,\n+                };\n+                self.tcx.lint_hir(\n+                    ::rustc::lint::builtin::CONST_ERR,\n+                    lint_root,\n+                    source_info.span,\n+                    &format!(\n+                        \"truncating cast: the value {} requires {} bits but the target type is \\\n+                                          only {} bits\",\n+                        value_bits,\n+                        value_size.bits(),\n+                        place_layout.size.bits()\n+                    ),\n+                );\n+                return None;\n+            }\n+        }\n+\n+        Some(())\n+    }\n+\n     fn const_prop(\n         &mut self,\n         rvalue: &Rvalue<'tcx>,\n         place_layout: TyLayout<'tcx>,\n         source_info: SourceInfo,\n         place: &Place<'tcx>,\n     ) -> Option<()> {\n-        let span = source_info.span;\n-\n         // #66397: Don't try to eval into large places as that can cause an OOM\n         if place_layout.size >= Size::from_bytes(MAX_ALLOC_LIMIT) {\n             return None;\n@@ -498,66 +617,14 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n             // if an overflow would occur.\n             Rvalue::UnaryOp(UnOp::Neg, arg) if !overflow_check => {\n                 trace!(\"checking UnaryOp(op = Neg, arg = {:?})\", arg);\n-\n-                self.use_ecx(source_info, |this| {\n-                    let ty = arg.ty(&this.local_decls, this.tcx);\n-\n-                    if ty.is_integral() {\n-                        let arg = this.ecx.eval_operand(arg, None)?;\n-                        let prim = this.ecx.read_immediate(arg)?;\n-                        // Need to do overflow check here: For actual CTFE, MIR\n-                        // generation emits code that does this before calling the op.\n-                        if prim.to_bits()? == (1 << (prim.layout.size.bits() - 1)) {\n-                            throw_panic!(OverflowNeg)\n-                        }\n-                    }\n-\n-                    Ok(())\n-                })?;\n+                self.check_unary_op(arg, source_info)?;\n             }\n \n             // Additional checking: check for overflows on integer binary operations and report\n             // them to the user as lints.\n             Rvalue::BinaryOp(op, left, right) => {\n                 trace!(\"checking BinaryOp(op = {:?}, left = {:?}, right = {:?})\", op, left, right);\n-\n-                let r = self.use_ecx(source_info, |this| {\n-                    this.ecx.read_immediate(this.ecx.eval_operand(right, None)?)\n-                })?;\n-                if *op == BinOp::Shr || *op == BinOp::Shl {\n-                    let left_bits = place_layout.size.bits();\n-                    let right_size = r.layout.size;\n-                    let r_bits = r.to_scalar().and_then(|r| r.to_bits(right_size));\n-                    if r_bits.map_or(false, |b| b >= left_bits as u128) {\n-                        let lint_root = self.lint_root(source_info)?;\n-                        let dir = if *op == BinOp::Shr { \"right\" } else { \"left\" };\n-                        self.tcx.lint_hir(\n-                            ::rustc::lint::builtin::EXCEEDING_BITSHIFTS,\n-                            lint_root,\n-                            span,\n-                            &format!(\"attempt to shift {} with overflow\", dir),\n-                        );\n-                        return None;\n-                    }\n-                }\n-\n-                // If overflow checking is enabled (like in debug mode by default),\n-                // then we'll already catch overflow when we evaluate the `Assert` statement\n-                // in MIR. However, if overflow checking is disabled, then there won't be any\n-                // `Assert` statement and so we have to do additional checking here.\n-                if !overflow_check {\n-                    self.use_ecx(source_info, |this| {\n-                        let l = this.ecx.read_immediate(this.ecx.eval_operand(left, None)?)?;\n-                        let (_, overflow, _ty) = this.ecx.overflowing_binary_op(*op, l, r)?;\n-\n-                        if overflow {\n-                            let err = err_panic!(Overflow(*op)).into();\n-                            return Err(err);\n-                        }\n-\n-                        Ok(())\n-                    })?;\n-                }\n+                self.check_binary_op(*op, left, right, source_info, place_layout, overflow_check)?;\n             }\n \n             // Work around: avoid ICE in miri. FIXME(wesleywiser)\n@@ -584,6 +651,11 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n                 }\n             }\n \n+            Rvalue::Cast(CastKind::Misc, op, ty) => {\n+                trace!(\"checking Cast(Misc, {:?}, {:?})\", op, ty);\n+                self.check_cast(op, ty, source_info, place_layout)?;\n+            }\n+\n             _ => {}\n         }\n "}, {"sha": "9cfbfebdcc3dfc82fca6e2b400993ec79e3991eb", "filename": "src/test/mir-opt/const_prop/cast.rs", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/0ec370670220b712b042ee09aab067ec7e5878d5/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ec370670220b712b042ee09aab067ec7e5878d5/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fcast.rs?ref=0ec370670220b712b042ee09aab067ec7e5878d5", "patch": "@@ -0,0 +1,49 @@\n+fn main() {\n+    let x = 42u8 as u32;\n+\n+    let y = 42u32 as u8;\n+}\n+\n+// END RUST SOURCE\n+// START rustc.main.ConstProp.before.mir\n+// let mut _0: ();\n+// let _1: u32;\n+// scope 1 {\n+//   debug x => _1;\n+//   let _2: u8;\n+//   scope 2 {\n+//     debug y => _2;\n+//   }\n+// }\n+// bb0: {\n+//   StorageLive(_1);\n+//   _1 = const 42u8 as u32 (Misc);\n+//   StorageLive(_2);\n+//   _2 = const 42u32 as u8 (Misc);\n+//   _0 = ();\n+//   StorageDead(_2);\n+//   StorageDead(_1);\n+//   return;\n+// }\n+// END rustc.main.ConstProp.before.mir\n+// START rustc.main.ConstProp.after.mir\n+// let mut _0: ();\n+// let _1: u32;\n+// scope 1 {\n+//   debug x => _1;\n+//   let _2: u8;\n+//   scope 2 {\n+//     debug y => _2;\n+//   }\n+// }\n+// bb0: {\n+//   StorageLive(_1);\n+//   _1 = const 42u32;\n+//   StorageLive(_2);\n+//   _2 = const 42u8;\n+//   _0 = ();\n+//   StorageDead(_2);\n+//   StorageDead(_1);\n+//   return;\n+// }\n+// END rustc.main.ConstProp.after.mir"}, {"sha": "11a04611487ba7b7a038c474329e7420b4b73f11", "filename": "src/test/ui/consts/const-prop-overflowing-casts.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0ec370670220b712b042ee09aab067ec7e5878d5/src%2Ftest%2Fui%2Fconsts%2Fconst-prop-overflowing-casts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ec370670220b712b042ee09aab067ec7e5878d5/src%2Ftest%2Fui%2Fconsts%2Fconst-prop-overflowing-casts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-prop-overflowing-casts.rs?ref=0ec370670220b712b042ee09aab067ec7e5878d5", "patch": "@@ -0,0 +1,9 @@\n+// build-fail\n+// ignore-tidy-linelength\n+\n+fn main() {\n+    let _ = 0u8 as u32;\n+    let _ = (1u32 << 31) as u16; //~ ERROR truncating cast: the value 2147483648 requires 32 bits but the target type is only 16 bits\n+    let _ = (1u16 << 15) as u8; //~ ERROR truncating cast: the value 32768 requires 16 bits but the target type is only 8 bits\n+    let _ = (!0u16) as u8; //~ ERROR truncating cast: the value 65535 requires 16 bits but the target type is only 8 bits\n+}"}, {"sha": "af4e2c7005afb7819e8597221c135ad54a8c8402", "filename": "src/test/ui/consts/const-prop-overflowing-casts.stderr", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/0ec370670220b712b042ee09aab067ec7e5878d5/src%2Ftest%2Fui%2Fconsts%2Fconst-prop-overflowing-casts.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0ec370670220b712b042ee09aab067ec7e5878d5/src%2Ftest%2Fui%2Fconsts%2Fconst-prop-overflowing-casts.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-prop-overflowing-casts.stderr?ref=0ec370670220b712b042ee09aab067ec7e5878d5", "patch": "@@ -0,0 +1,22 @@\n+error: truncating cast: the value 2147483648 requires 32 bits but the target type is only 16 bits\n+  --> $DIR/const-prop-overflowing-casts.rs:6:13\n+   |\n+LL |     let _ = (1u32 << 31) as u16;\n+   |             ^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `#[deny(const_err)]` on by default\n+\n+error: truncating cast: the value 32768 requires 16 bits but the target type is only 8 bits\n+  --> $DIR/const-prop-overflowing-casts.rs:7:13\n+   |\n+LL |     let _ = (1u16 << 15) as u8;\n+   |             ^^^^^^^^^^^^^^^^^^\n+\n+error: truncating cast: the value 65535 requires 16 bits but the target type is only 8 bits\n+  --> $DIR/const-prop-overflowing-casts.rs:8:13\n+   |\n+LL |     let _ = (!0u16) as u8;\n+   |             ^^^^^^^^^^^^^\n+\n+error: aborting due to 3 previous errors\n+"}, {"sha": "b81a76851d3c3faa4833ae58ce4e317dba1578e1", "filename": "src/test/ui/simd/simd-intrinsic-generic-cast.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0ec370670220b712b042ee09aab067ec7e5878d5/src%2Ftest%2Fui%2Fsimd%2Fsimd-intrinsic-generic-cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ec370670220b712b042ee09aab067ec7e5878d5/src%2Ftest%2Fui%2Fsimd%2Fsimd-intrinsic-generic-cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsimd%2Fsimd-intrinsic-generic-cast.rs?ref=0ec370670220b712b042ee09aab067ec7e5878d5", "patch": "@@ -4,6 +4,7 @@\n \n #![feature(repr_simd, platform_intrinsics, concat_idents, test)]\n #![allow(non_camel_case_types)]\n+#![allow(const_err)] // the test macro casts i32s to i8 and u8 which causes lots of warnings\n \n extern crate test;\n "}, {"sha": "ecdd742fb4e0885d27fe28b4f512115e806f3bf2", "filename": "src/test/ui/wrapping-int-api.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0ec370670220b712b042ee09aab067ec7e5878d5/src%2Ftest%2Fui%2Fwrapping-int-api.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ec370670220b712b042ee09aab067ec7e5878d5/src%2Ftest%2Fui%2Fwrapping-int-api.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fwrapping-int-api.rs?ref=0ec370670220b712b042ee09aab067ec7e5878d5", "patch": "@@ -1,6 +1,9 @@\n // run-pass\n // Test inherent wrapping_* methods for {i,u}{size,8,16,32,64}.\n \n+// Don't warn about overflowing ops on 32-bit platforms\n+#![cfg_attr(target_pointer_width = \"32\", allow(const_err))]\n+\n use std::{i8, i16, i32, i64, isize};\n use std::{u8, u16, u32, u64, usize};\n "}]}