{"sha": "f6e06a8a365b118937079e3f9c4dfa8f221e7db5", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY2ZTA2YThhMzY1YjExODkzNzA3OWUzZjljNGRmYThmMjIxZTdkYjU=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2016-08-15T18:28:17Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2016-08-17T22:33:18Z"}, "message": "Split `AstBuilder::pat_enum` into `pat_tuple_struct` and `pat_path`", "tree": {"sha": "b96e5026f26ba96edb9eafbdf9a25dab18164914", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b96e5026f26ba96edb9eafbdf9a25dab18164914"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f6e06a8a365b118937079e3f9c4dfa8f221e7db5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f6e06a8a365b118937079e3f9c4dfa8f221e7db5", "html_url": "https://github.com/rust-lang/rust/commit/f6e06a8a365b118937079e3f9c4dfa8f221e7db5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f6e06a8a365b118937079e3f9c4dfa8f221e7db5/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "28ed8b159237a2704f2308a404b3bd81b676ce17", "url": "https://api.github.com/repos/rust-lang/rust/commits/28ed8b159237a2704f2308a404b3bd81b676ce17", "html_url": "https://github.com/rust-lang/rust/commit/28ed8b159237a2704f2308a404b3bd81b676ce17"}], "stats": {"total": 90, "additions": 48, "deletions": 42}, "files": [{"sha": "507e46ea59e9eb20bf2d976b0ddbe88c16b3d38b", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/f6e06a8a365b118937079e3f9c4dfa8f221e7db5/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e06a8a365b118937079e3f9c4dfa8f221e7db5/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=f6e06a8a365b118937079e3f9c4dfa8f221e7db5", "patch": "@@ -171,9 +171,11 @@ pub trait AstBuilder {\n                               span: Span,\n                               ident: ast::Ident,\n                               bm: ast::BindingMode) -> P<ast::Pat>;\n-    fn pat_enum(&self, span: Span, path: ast::Path, subpats: Vec<P<ast::Pat>> ) -> P<ast::Pat>;\n-    fn pat_struct(&self, span: Span,\n-                  path: ast::Path, field_pats: Vec<Spanned<ast::FieldPat>> ) -> P<ast::Pat>;\n+    fn pat_path(&self, span: Span, path: ast::Path) -> P<ast::Pat>;\n+    fn pat_tuple_struct(&self, span: Span, path: ast::Path,\n+                        subpats: Vec<P<ast::Pat>>) -> P<ast::Pat>;\n+    fn pat_struct(&self, span: Span, path: ast::Path,\n+                  field_pats: Vec<Spanned<ast::FieldPat>>) -> P<ast::Pat>;\n     fn pat_tuple(&self, span: Span, pats: Vec<P<ast::Pat>>) -> P<ast::Pat>;\n \n     fn pat_some(&self, span: Span, pat: P<ast::Pat>) -> P<ast::Pat>;\n@@ -802,10 +804,10 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         let binding_expr = self.expr_ident(sp, binding_variable);\n \n         // Ok(__try_var) pattern\n-        let ok_pat = self.pat_enum(sp, ok_path, vec!(binding_pat.clone()));\n+        let ok_pat = self.pat_tuple_struct(sp, ok_path, vec![binding_pat.clone()]);\n \n         // Err(__try_var)  (pattern and expression resp.)\n-        let err_pat = self.pat_enum(sp, err_path.clone(), vec!(binding_pat));\n+        let err_pat = self.pat_tuple_struct(sp, err_path.clone(), vec![binding_pat]);\n         let err_inner_expr = self.expr_call(sp, self.expr_path(err_path),\n                                             vec!(binding_expr.clone()));\n         // return Err(__try_var)\n@@ -842,18 +844,16 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         let pat = PatKind::Ident(bm, Spanned{span: span, node: ident}, None);\n         self.pat(span, pat)\n     }\n-    fn pat_enum(&self, span: Span, path: ast::Path, subpats: Vec<P<ast::Pat>>) -> P<ast::Pat> {\n-        let pat = if subpats.is_empty() {\n-            PatKind::Struct(path, Vec::new(), false)\n-        } else {\n-            PatKind::TupleStruct(path, subpats, None)\n-        };\n-        self.pat(span, pat)\n+    fn pat_path(&self, span: Span, path: ast::Path) -> P<ast::Pat> {\n+        self.pat(span, PatKind::Path(None, path))\n     }\n-    fn pat_struct(&self, span: Span,\n-                  path: ast::Path, field_pats: Vec<Spanned<ast::FieldPat>>) -> P<ast::Pat> {\n-        let pat = PatKind::Struct(path, field_pats, false);\n-        self.pat(span, pat)\n+    fn pat_tuple_struct(&self, span: Span, path: ast::Path,\n+                        subpats: Vec<P<ast::Pat>>) -> P<ast::Pat> {\n+        self.pat(span, PatKind::TupleStruct(path, subpats, None))\n+    }\n+    fn pat_struct(&self, span: Span, path: ast::Path,\n+                  field_pats: Vec<Spanned<ast::FieldPat>>) -> P<ast::Pat> {\n+        self.pat(span, PatKind::Struct(path, field_pats, false))\n     }\n     fn pat_tuple(&self, span: Span, pats: Vec<P<ast::Pat>>) -> P<ast::Pat> {\n         self.pat(span, PatKind::Tuple(pats, None))\n@@ -862,25 +862,25 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n     fn pat_some(&self, span: Span, pat: P<ast::Pat>) -> P<ast::Pat> {\n         let some = self.std_path(&[\"option\", \"Option\", \"Some\"]);\n         let path = self.path_global(span, some);\n-        self.pat_enum(span, path, vec!(pat))\n+        self.pat_tuple_struct(span, path, vec![pat])\n     }\n \n     fn pat_none(&self, span: Span) -> P<ast::Pat> {\n         let some = self.std_path(&[\"option\", \"Option\", \"None\"]);\n         let path = self.path_global(span, some);\n-        self.pat_enum(span, path, vec!())\n+        self.pat_path(span, path)\n     }\n \n     fn pat_ok(&self, span: Span, pat: P<ast::Pat>) -> P<ast::Pat> {\n         let some = self.std_path(&[\"result\", \"Result\", \"Ok\"]);\n         let path = self.path_global(span, some);\n-        self.pat_enum(span, path, vec!(pat))\n+        self.pat_tuple_struct(span, path, vec![pat])\n     }\n \n     fn pat_err(&self, span: Span, pat: P<ast::Pat>) -> P<ast::Pat> {\n         let some = self.std_path(&[\"result\", \"Result\", \"Err\"]);\n         let path = self.path_global(span, some);\n-        self.pat_enum(span, path, vec!(pat))\n+        self.pat_tuple_struct(span, path, vec![pat])\n     }\n \n     fn arm(&self, _span: Span, pats: Vec<P<ast::Pat>>, expr: P<ast::Expr>) -> ast::Arm {"}, {"sha": "31194b04fa6e46c402c9a139ebdd2c6e637510a8", "filename": "src/libsyntax_ext/deriving/cmp/ord.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f6e06a8a365b118937079e3f9c4dfa8f221e7db5/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Ford.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e06a8a365b118937079e3f9c4dfa8f221e7db5/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Ford.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Ford.rs?ref=f6e06a8a365b118937079e3f9c4dfa8f221e7db5", "patch": "@@ -104,7 +104,7 @@ pub fn cs_cmp(cx: &mut ExtCtxt, span: Span, substr: &Substructure) -> P<Expr> {\n         };\n \n         let eq_arm = cx.arm(span,\n-                            vec![cx.pat_enum(span, equals_path.clone(), vec![])],\n+                            vec![cx.pat_path(span, equals_path.clone())],\n                             old);\n         let neq_arm = cx.arm(span,\n                              vec![cx.pat_ident(span, test_id)],"}, {"sha": "9e9b2f020622ff560e294c76b5bc1584394f1804", "filename": "src/libsyntax_ext/deriving/cmp/partial_ord.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f6e06a8a365b118937079e3f9c4dfa8f221e7db5/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Fpartial_ord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e06a8a365b118937079e3f9c4dfa8f221e7db5/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Fpartial_ord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Fpartial_ord.rs?ref=f6e06a8a365b118937079e3f9c4dfa8f221e7db5", "patch": "@@ -165,7 +165,7 @@ pub fn cs_partial_cmp(cx: &mut ExtCtxt, span: Span, substr: &Substructure) -> P<\n         };\n \n         let eq_arm = cx.arm(span,\n-                            vec![cx.pat_some(span, cx.pat_enum(span, ordering.clone(), vec![]))],\n+                            vec![cx.pat_some(span, cx.pat_path(span, ordering.clone()))],\n                             old);\n         let neq_arm = cx.arm(span,\n                              vec![cx.pat_ident(span, test_id)],"}, {"sha": "b2b887c7ef2d4eece11a9f1a97b22167eddfb322", "filename": "src/libsyntax_ext/deriving/generic/mod.rs", "status": "modified", "additions": 26, "deletions": 20, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/f6e06a8a365b118937079e3f9c4dfa8f221e7db5/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e06a8a365b118937079e3f9c4dfa8f221e7db5/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs?ref=f6e06a8a365b118937079e3f9c4dfa8f221e7db5", "patch": "@@ -1510,26 +1510,32 @@ impl<'a> TraitDef<'a> {\n         }\n \n         let subpats = self.create_subpatterns(cx, paths, mutbl);\n-        let pattern = if struct_def.is_struct() {\n-            let field_pats = subpats.into_iter()\n-                .zip(&ident_exprs)\n-                .map(|(pat, &(sp, ident, _, _))| {\n-                    if ident.is_none() {\n-                        cx.span_bug(sp, \"a braced struct with unnamed fields in `derive`\");\n-                    }\n-                    codemap::Spanned {\n-                        span: pat.span,\n-                        node: ast::FieldPat {\n-                            ident: ident.unwrap(),\n-                            pat: pat,\n-                            is_shorthand: false,\n-                        },\n-                    }\n-                })\n-                .collect();\n-            cx.pat_struct(self.span, struct_path, field_pats)\n-        } else {\n-            cx.pat_enum(self.span, struct_path, subpats)\n+        let pattern = match *struct_def {\n+            VariantData::Struct(..) => {\n+                let field_pats = subpats.into_iter()\n+                    .zip(&ident_exprs)\n+                    .map(|(pat, &(sp, ident, _, _))| {\n+                        if ident.is_none() {\n+                            cx.span_bug(sp, \"a braced struct with unnamed fields in `derive`\");\n+                        }\n+                        codemap::Spanned {\n+                            span: pat.span,\n+                            node: ast::FieldPat {\n+                                ident: ident.unwrap(),\n+                                pat: pat,\n+                                is_shorthand: false,\n+                            },\n+                        }\n+                    })\n+                    .collect();\n+                cx.pat_struct(self.span, struct_path, field_pats)\n+            }\n+            VariantData::Tuple(..) => {\n+                cx.pat_tuple_struct(self.span, struct_path, subpats)\n+            }\n+            VariantData::Unit(..) => {\n+                cx.pat_path(self.span, struct_path)\n+            }\n         };\n \n         (pattern, ident_exprs)"}]}