{"sha": "040fc94b4eaeb24b6da297a763a28df66473e34d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA0MGZjOTRiNGVhZWIyNGI2ZGEyOTdhNzYzYTI4ZGY2NjQ3M2UzNGQ=", "commit": {"author": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2016-05-25T18:12:35Z"}, "committer": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2016-05-25T18:12:35Z"}, "message": "catch attempts to leak obligations out of snapshots", "tree": {"sha": "dde0812a59f7e5bea78b60a4a622cc6f06edc19c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dde0812a59f7e5bea78b60a4a622cc6f06edc19c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/040fc94b4eaeb24b6da297a763a28df66473e34d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/040fc94b4eaeb24b6da297a763a28df66473e34d", "html_url": "https://github.com/rust-lang/rust/commit/040fc94b4eaeb24b6da297a763a28df66473e34d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/040fc94b4eaeb24b6da297a763a28df66473e34d/comments", "author": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "committer": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c209d44c342a664bad5428ff988ee1084c13bed7", "url": "https://api.github.com/repos/rust-lang/rust/commits/c209d44c342a664bad5428ff988ee1084c13bed7", "html_url": "https://github.com/rust-lang/rust/commit/c209d44c342a664bad5428ff988ee1084c13bed7"}], "stats": {"total": 243, "additions": 127, "deletions": 116}, "files": [{"sha": "7c9c52baa63e44965632e0ebb8fe34b87af3e22b", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 28, "deletions": 5, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/040fc94b4eaeb24b6da297a763a28df66473e34d/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/040fc94b4eaeb24b6da297a763a28df66473e34d/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=040fc94b4eaeb24b6da297a763a28df66473e34d", "patch": "@@ -163,6 +163,11 @@ pub struct InferCtxt<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     // If the number of errors increases, that's also a sign (line\n     // `tained_by_errors`) to avoid reporting certain kinds of errors.\n     err_count_on_creation: usize,\n+\n+    // This flag is used for debugging, and is set to true if there are\n+    // any obligations set during the current snapshot. In that case, the\n+    // snapshot can't be rolled back.\n+    pub obligations_in_snapshot: Cell<bool>,\n }\n \n /// A map returned by `skolemize_late_bound_regions()` indicating the skolemized\n@@ -476,7 +481,8 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'gcx> {\n             normalize: false,\n             projection_mode: ProjectionMode::AnyFinal,\n             tainted_by_errors_flag: Cell::new(false),\n-            err_count_on_creation: self.sess.err_count()\n+            err_count_on_creation: self.sess.err_count(),\n+            obligations_in_snapshot: Cell::new(false),\n         }\n     }\n }\n@@ -515,7 +521,8 @@ impl<'a, 'gcx, 'tcx> InferCtxtBuilder<'a, 'gcx, 'tcx> {\n             normalize: normalize,\n             projection_mode: projection_mode,\n             tainted_by_errors_flag: Cell::new(false),\n-            err_count_on_creation: tcx.sess.err_count()\n+            err_count_on_creation: tcx.sess.err_count(),\n+            obligations_in_snapshot: Cell::new(false),\n         }))\n     }\n }\n@@ -542,6 +549,7 @@ pub struct CombinedSnapshot {\n     int_snapshot: unify::Snapshot<ty::IntVid>,\n     float_snapshot: unify::Snapshot<ty::FloatVid>,\n     region_vars_snapshot: RegionSnapshot,\n+    obligations_in_snapshot: bool,\n }\n \n /// Helper trait for shortening the lifetimes inside a\n@@ -809,11 +817,15 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     fn start_snapshot(&self) -> CombinedSnapshot {\n+        let obligations_in_snapshot = self.obligations_in_snapshot.get();\n+        self.obligations_in_snapshot.set(false);\n+\n         CombinedSnapshot {\n             type_snapshot: self.type_variables.borrow_mut().snapshot(),\n             int_snapshot: self.int_unification_table.borrow_mut().snapshot(),\n             float_snapshot: self.float_unification_table.borrow_mut().snapshot(),\n             region_vars_snapshot: self.region_vars.start_snapshot(),\n+            obligations_in_snapshot: obligations_in_snapshot,\n         }\n     }\n \n@@ -822,7 +834,11 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         let CombinedSnapshot { type_snapshot,\n                                int_snapshot,\n                                float_snapshot,\n-                               region_vars_snapshot } = snapshot;\n+                               region_vars_snapshot,\n+                               obligations_in_snapshot } = snapshot;\n+\n+        assert!(!self.obligations_in_snapshot.get());\n+        self.obligations_in_snapshot.set(obligations_in_snapshot);\n \n         self.type_variables\n             .borrow_mut()\n@@ -842,7 +858,10 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         let CombinedSnapshot { type_snapshot,\n                                int_snapshot,\n                                float_snapshot,\n-                               region_vars_snapshot } = snapshot;\n+                               region_vars_snapshot,\n+                               obligations_in_snapshot } = snapshot;\n+\n+        self.obligations_in_snapshot.set(obligations_in_snapshot);\n \n         self.type_variables\n             .borrow_mut()\n@@ -904,12 +923,16 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         let CombinedSnapshot { type_snapshot,\n                                int_snapshot,\n                                float_snapshot,\n-                               region_vars_snapshot } = self.start_snapshot();\n+                               region_vars_snapshot,\n+                               obligations_in_snapshot } = self.start_snapshot();\n \n         let r = self.commit_if_ok(|_| f());\n \n         debug!(\"commit_regions_if_ok: rolling back everything but regions\");\n \n+        assert!(!self.obligations_in_snapshot.get());\n+        self.obligations_in_snapshot.set(obligations_in_snapshot);\n+\n         // Roll back any non-region bindings - they should be resolved\n         // inside `f`, with, e.g. `resolve_type_vars_if_possible`.\n         self.type_variables"}, {"sha": "0d7d7afd120d28d9e7080d7cd8830fb5a78e06ad", "filename": "src/librustc/traits/fulfill.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/040fc94b4eaeb24b6da297a763a28df66473e34d/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/040fc94b4eaeb24b6da297a763a28df66473e34d/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ffulfill.rs?ref=040fc94b4eaeb24b6da297a763a28df66473e34d", "patch": "@@ -171,6 +171,8 @@ impl<'a, 'gcx, 'tcx> FulfillmentContext<'tcx> {\n         // debug output much nicer to read and so on.\n         let obligation = infcx.resolve_type_vars_if_possible(&obligation);\n \n+        infcx.obligations_in_snapshot.set(true);\n+\n         if infcx.tcx.fulfilled_predicates.borrow().check_duplicate(&obligation.predicate)\n         {\n             return"}, {"sha": "c7a3637557602d8d2a8c30cad79ef3fff70a7411", "filename": "src/librustc/traits/specialize/mod.rs", "status": "modified", "additions": 40, "deletions": 42, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/040fc94b4eaeb24b6da297a763a28df66473e34d/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/040fc94b4eaeb24b6da297a763a28df66473e34d/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs?ref=040fc94b4eaeb24b6da297a763a28df66473e34d", "patch": "@@ -187,51 +187,49 @@ fn fulfill_implication<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n                                        source_trait_ref: ty::TraitRef<'tcx>,\n                                        target_impl: DefId)\n                                        -> Result<&'tcx Substs<'tcx>, ()> {\n-    infcx.commit_if_ok(|_| {\n-        let selcx = &mut SelectionContext::new(&infcx);\n-        let target_substs = fresh_type_vars_for_impl(&infcx, DUMMY_SP, target_impl);\n-        let (target_trait_ref, obligations) = impl_trait_ref_and_oblig(selcx,\n-                                                                       target_impl,\n-                                                                       &target_substs);\n-\n-        // do the impls unify? If not, no specialization.\n-        if let Err(_) = infcx.eq_trait_refs(true,\n-                                            TypeOrigin::Misc(DUMMY_SP),\n-                                            source_trait_ref,\n-                                            target_trait_ref) {\n-            debug!(\"fulfill_implication: {:?} does not unify with {:?}\",\n-                   source_trait_ref,\n-                   target_trait_ref);\n-            return Err(());\n-        }\n+    let selcx = &mut SelectionContext::new(&infcx);\n+    let target_substs = fresh_type_vars_for_impl(&infcx, DUMMY_SP, target_impl);\n+    let (target_trait_ref, obligations) = impl_trait_ref_and_oblig(selcx,\n+                                                                   target_impl,\n+                                                                   &target_substs);\n+\n+    // do the impls unify? If not, no specialization.\n+    if let Err(_) = infcx.eq_trait_refs(true,\n+                                        TypeOrigin::Misc(DUMMY_SP),\n+                                        source_trait_ref,\n+                                        target_trait_ref) {\n+        debug!(\"fulfill_implication: {:?} does not unify with {:?}\",\n+               source_trait_ref,\n+               target_trait_ref);\n+        return Err(());\n+    }\n \n-        // attempt to prove all of the predicates for impl2 given those for impl1\n-        // (which are packed up in penv)\n+    // attempt to prove all of the predicates for impl2 given those for impl1\n+    // (which are packed up in penv)\n \n-        let mut fulfill_cx = FulfillmentContext::new();\n-        for oblig in obligations.into_iter() {\n-            fulfill_cx.register_predicate_obligation(&infcx, oblig);\n-        }\n+    let mut fulfill_cx = FulfillmentContext::new();\n+    for oblig in obligations.into_iter() {\n+        fulfill_cx.register_predicate_obligation(&infcx, oblig);\n+    }\n \n-        if let Err(errors) = infcx.drain_fulfillment_cx(&mut fulfill_cx, &()) {\n-            // no dice!\n-            debug!(\"fulfill_implication: for impls on {:?} and {:?}, could not fulfill: {:?} given \\\n-                    {:?}\",\n-                   source_trait_ref,\n-                   target_trait_ref,\n-                   errors,\n-                   infcx.parameter_environment.caller_bounds);\n-            Err(())\n-        } else {\n-            debug!(\"fulfill_implication: an impl for {:?} specializes {:?}\",\n-                   source_trait_ref,\n-                   target_trait_ref);\n-\n-            // Now resolve the *substitution* we built for the target earlier, replacing\n-            // the inference variables inside with whatever we got from fulfillment.\n-            Ok(infcx.resolve_type_vars_if_possible(&target_substs))\n-        }\n-    })\n+    if let Err(errors) = infcx.drain_fulfillment_cx(&mut fulfill_cx, &()) {\n+        // no dice!\n+        debug!(\"fulfill_implication: for impls on {:?} and {:?}, could not fulfill: {:?} given \\\n+                {:?}\",\n+               source_trait_ref,\n+               target_trait_ref,\n+               errors,\n+               infcx.parameter_environment.caller_bounds);\n+        Err(())\n+    } else {\n+        debug!(\"fulfill_implication: an impl for {:?} specializes {:?}\",\n+               source_trait_ref,\n+               target_trait_ref);\n+\n+        // Now resolve the *substitution* we built for the target earlier, replacing\n+        // the inference variables inside with whatever we got from fulfillment.\n+        Ok(infcx.resolve_type_vars_if_possible(&target_substs))\n+    }\n }\n \n pub struct SpecializesCache {"}, {"sha": "9dd737f3a6168af9ae99a35b6e081089f7a8aaba", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/040fc94b4eaeb24b6da297a763a28df66473e34d/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/040fc94b4eaeb24b6da297a763a28df66473e34d/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=040fc94b4eaeb24b6da297a763a28df66473e34d", "patch": "@@ -363,6 +363,8 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n             }\n         };\n \n+        // This commits the obligations to the fulfillcx. After this succeeds,\n+        // this snapshot can't be rolled back.\n         autoderef.finalize(LvaluePreference::from_mutbl(mt_b.mutbl), exprs());\n \n         // Now apply the autoref. We have to extract the region out of"}, {"sha": "20f82271b9cd6f60e78ff313e0903a1143caa520", "filename": "src/librustc_typeck/check/compare_method.rs", "status": "modified", "additions": 52, "deletions": 67, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/040fc94b4eaeb24b6da297a763a28df66473e34d/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/040fc94b4eaeb24b6da297a763a28df66473e34d/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs?ref=040fc94b4eaeb24b6da297a763a28df66473e34d", "patch": "@@ -279,78 +279,63 @@ pub fn compare_impl_method<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n         // type.\n \n         // Compute skolemized form of impl and trait method tys.\n-        let impl_fty = tcx.mk_fn_ptr(impl_m.fty);\n-        let impl_fty = impl_fty.subst(tcx, impl_to_skol_substs);\n-        let trait_fty = tcx.mk_fn_ptr(trait_m.fty);\n-        let trait_fty = trait_fty.subst(tcx, &trait_to_skol_substs);\n-\n-        let err = infcx.commit_if_ok(|snapshot| {\n-            let tcx = infcx.tcx;\n-            let origin = TypeOrigin::MethodCompatCheck(impl_m_span);\n-\n-            let (impl_sig, _) =\n-                infcx.replace_late_bound_regions_with_fresh_var(impl_m_span,\n-                                                                infer::HigherRankedType,\n-                                                                &impl_m.fty.sig);\n-            let impl_sig =\n-                impl_sig.subst(tcx, impl_to_skol_substs);\n-            let impl_sig =\n-                assoc::normalize_associated_types_in(&infcx,\n-                                                     &mut fulfillment_cx,\n-                                                     impl_m_span,\n-                                                     impl_m_body_id,\n-                                                     &impl_sig);\n-            let impl_fty = tcx.mk_fn_ptr(tcx.mk_bare_fn(ty::BareFnTy {\n-                unsafety: impl_m.fty.unsafety,\n-                abi: impl_m.fty.abi,\n-                sig: ty::Binder(impl_sig)\n-            }));\n-            debug!(\"compare_impl_method: impl_fty={:?}\",\n-                   impl_fty);\n-\n-            let (trait_sig, skol_map) =\n-                infcx.skolemize_late_bound_regions(&trait_m.fty.sig, snapshot);\n-            let trait_sig =\n-                trait_sig.subst(tcx, &trait_to_skol_substs);\n-            let trait_sig =\n-                assoc::normalize_associated_types_in(&infcx,\n-                                                     &mut fulfillment_cx,\n-                                                     impl_m_span,\n-                                                     impl_m_body_id,\n-                                                     &trait_sig);\n-            let trait_fty = tcx.mk_fn_ptr(tcx.mk_bare_fn(ty::BareFnTy {\n-                unsafety: trait_m.fty.unsafety,\n-                abi: trait_m.fty.abi,\n-                sig: ty::Binder(trait_sig)\n-            }));\n-\n-            debug!(\"compare_impl_method: trait_fty={:?}\",\n+        let tcx = infcx.tcx;\n+        let origin = TypeOrigin::MethodCompatCheck(impl_m_span);\n+\n+        let (impl_sig, _) =\n+            infcx.replace_late_bound_regions_with_fresh_var(impl_m_span,\n+                                                            infer::HigherRankedType,\n+                                                            &impl_m.fty.sig);\n+        let impl_sig =\n+            impl_sig.subst(tcx, impl_to_skol_substs);\n+        let impl_sig =\n+            assoc::normalize_associated_types_in(&infcx,\n+                                                 &mut fulfillment_cx,\n+                                                 impl_m_span,\n+                                                 impl_m_body_id,\n+                                                 &impl_sig);\n+        let impl_fty = tcx.mk_fn_ptr(tcx.mk_bare_fn(ty::BareFnTy {\n+            unsafety: impl_m.fty.unsafety,\n+            abi: impl_m.fty.abi,\n+            sig: ty::Binder(impl_sig)\n+        }));\n+        debug!(\"compare_impl_method: impl_fty={:?}\", impl_fty);\n+\n+        let trait_sig = tcx.liberate_late_bound_regions(\n+            infcx.parameter_environment.free_id_outlive,\n+            &trait_m.fty.sig);\n+        let trait_sig =\n+            trait_sig.subst(tcx, &trait_to_skol_substs);\n+        let trait_sig =\n+            assoc::normalize_associated_types_in(&infcx,\n+                                                 &mut fulfillment_cx,\n+                                                 impl_m_span,\n+                                                 impl_m_body_id,\n+                                                 &trait_sig);\n+        let trait_fty = tcx.mk_fn_ptr(tcx.mk_bare_fn(ty::BareFnTy {\n+            unsafety: trait_m.fty.unsafety,\n+            abi: trait_m.fty.abi,\n+            sig: ty::Binder(trait_sig)\n+        }));\n+\n+        debug!(\"compare_impl_method: trait_fty={:?}\", trait_fty);\n+\n+        if let Err(terr) = infcx.sub_types(false, origin, impl_fty, trait_fty) {\n+            debug!(\"sub_types failed: impl ty {:?}, trait ty {:?}\",\n+                   impl_fty,\n                    trait_fty);\n-\n-            infcx.sub_types(false, origin, impl_fty, trait_fty)?;\n-\n-            infcx.leak_check(false, &skol_map, snapshot)\n-        });\n-\n-        match err {\n-            Ok(()) => { }\n-            Err(terr) => {\n-                debug!(\"checking trait method for compatibility: impl ty {:?}, trait ty {:?}\",\n-                       impl_fty,\n-                       trait_fty);\n-                span_err!(tcx.sess, impl_m_span, E0053,\n-                          \"method `{}` has an incompatible type for trait: {}\",\n-                          trait_m.name,\n-                          terr);\n-                return;\n-            }\n+            span_err!(tcx.sess, impl_m_span, E0053,\n+                      \"method `{}` has an incompatible type for trait: {}\",\n+                      trait_m.name,\n+                      terr);\n+            return\n         }\n \n         // Check that all obligations are satisfied by the implementation's\n         // version.\n-        match fulfillment_cx.select_all_or_error(&infcx) {\n-            Err(ref errors) => { infcx.report_fulfillment_errors(errors) }\n-            Ok(_) => {}\n+        if let Err(ref errors) = fulfillment_cx.select_all_or_error(&infcx) {\n+            infcx.report_fulfillment_errors(errors);\n+            return\n         }\n \n         // Finally, resolve all regions. This catches wily misuses of"}, {"sha": "6e60a373d9b0cecb02fb8bebea804d577a72bac5", "filename": "src/test/compile-fail/regions-bound-missing-bound-in-impl.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/040fc94b4eaeb24b6da297a763a28df66473e34d/src%2Ftest%2Fcompile-fail%2Fregions-bound-missing-bound-in-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/040fc94b4eaeb24b6da297a763a28df66473e34d/src%2Ftest%2Fcompile-fail%2Fregions-bound-missing-bound-in-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-bound-missing-bound-in-impl.rs?ref=040fc94b4eaeb24b6da297a763a28df66473e34d", "patch": "@@ -34,7 +34,8 @@ impl<'a, 't> Foo<'a, 't> for &'a isize {\n     }\n \n     fn wrong_bound1<'b,'c,'d:'a+'c>(self, b: Inv<'b>, c: Inv<'c>, d: Inv<'d>) {\n-        //~^ ERROR method `wrong_bound1` has an incompatible type for trait\n+        //~^ ERROR method not compatible with trait\n+        //~^^ ERROR method not compatible with trait\n         //\n         // Note: This is a terrible error message. It is caused\n         // because, in the trait, 'b is early bound, and in the impl,"}, {"sha": "9cd08656b62c5a71afcdb1cf286f8feb5330ec65", "filename": "src/test/compile-fail/regions-trait-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/040fc94b4eaeb24b6da297a763a28df66473e34d/src%2Ftest%2Fcompile-fail%2Fregions-trait-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/040fc94b4eaeb24b6da297a763a28df66473e34d/src%2Ftest%2Fcompile-fail%2Fregions-trait-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-trait-1.rs?ref=040fc94b4eaeb24b6da297a763a28df66473e34d", "patch": "@@ -23,7 +23,7 @@ impl<'a> get_ctxt for has_ctxt<'a> {\n \n     // Here an error occurs because we used `&self` but\n     // the definition used `&`:\n-    fn get_ctxt(&self) -> &'a ctxt { //~ ERROR method `get_ctxt` has an incompatible type\n+    fn get_ctxt(&self) -> &'a ctxt { //~ ERROR method not compatible with trait\n         self.c\n     }\n "}]}