{"sha": "97b20f8e024096b903b8ec05bd39d0387d9190cb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk3YjIwZjhlMDI0MDk2YjkwM2I4ZWMwNWJkMzlkMDM4N2Q5MTkwY2I=", "commit": {"author": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2013-01-18T22:30:29Z"}, "committer": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2013-01-18T22:30:29Z"}, "message": "rustc: Make type_names and named_types tables in trans use @str instead of ~str\n\nCuts down on bad copies (though there are still a few that can go\naway once there are impls of push / append / + for @str)", "tree": {"sha": "77a0303a2fc6a33d3cac9b2f4eab15460960f149", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/77a0303a2fc6a33d3cac9b2f4eab15460960f149"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/97b20f8e024096b903b8ec05bd39d0387d9190cb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/97b20f8e024096b903b8ec05bd39d0387d9190cb", "html_url": "https://github.com/rust-lang/rust/commit/97b20f8e024096b903b8ec05bd39d0387d9190cb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/97b20f8e024096b903b8ec05bd39d0387d9190cb/comments", "author": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "committer": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9c1476e7a4c148bd04bed06218e606d21bd57084", "url": "https://api.github.com/repos/rust-lang/rust/commits/9c1476e7a4c148bd04bed06218e606d21bd57084", "html_url": "https://github.com/rust-lang/rust/commit/9c1476e7a4c148bd04bed06218e606d21bd57084"}], "stats": {"total": 119, "additions": 61, "deletions": 58}, "files": [{"sha": "20c962d36ff997a82dc205803a7adfb62f874f4f", "filename": "src/librustc/lib/llvm.rs", "status": "modified", "additions": 50, "deletions": 48, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/97b20f8e024096b903b8ec05bd39d0387d9190cb/src%2Flibrustc%2Flib%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97b20f8e024096b903b8ec05bd39d0387d9190cb/src%2Flibrustc%2Flib%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib%2Fllvm.rs?ref=97b20f8e024096b903b8ec05bd39d0387d9190cb", "patch": "@@ -1251,20 +1251,19 @@ fn SetLinkage(Global: ValueRef, Link: Linkage) {\n \n /* Memory-managed object interface to type handles. */\n \n-type type_names = @{type_names: HashMap<TypeRef, ~str>,\n-                    named_types: HashMap<~str, TypeRef>};\n+type type_names = @{type_names: HashMap<TypeRef, @str>,\n+                    named_types: HashMap<@str, TypeRef>};\n \n-fn associate_type(tn: type_names, +s: ~str, t: TypeRef) {\n-    // XXX: Bad copy, use @str instead?\n-    assert tn.type_names.insert(t, copy s);\n+fn associate_type(tn: type_names, s: @str, t: TypeRef) {\n+    assert tn.type_names.insert(t, s);\n     assert tn.named_types.insert(s, t);\n }\n \n-fn type_has_name(tn: type_names, t: TypeRef) -> Option<~str> {\n+fn type_has_name(tn: type_names, t: TypeRef) -> Option<@str> {\n     return tn.type_names.find(t);\n }\n \n-fn name_has_type(tn: type_names, +s: ~str) -> Option<TypeRef> {\n+fn name_has_type(tn: type_names, s: @str) -> Option<TypeRef> {\n     return tn.named_types.find(s);\n }\n \n@@ -1273,101 +1272,104 @@ fn mk_type_names() -> type_names {\n       named_types: HashMap()}\n }\n \n-fn type_to_str(names: type_names, ty: TypeRef) -> ~str {\n+fn type_to_str(names: type_names, ty: TypeRef) -> @str {\n     return type_to_str_inner(names, ~[], ty);\n }\n \n fn type_to_str_inner(names: type_names, +outer0: ~[TypeRef], ty: TypeRef) ->\n-   ~str {\n+   @str {\n     unsafe {\n         match type_has_name(names, ty) {\n-          option::Some(ref n) => return (/*bad*/copy *n),\n+          option::Some(n) => return n,\n           _ => {}\n         }\n \n-        // XXX: Bad copy.\n+        // FIXME #2543: Bad copy.\n         let outer = vec::append_one(copy outer0, ty);\n \n         let kind = llvm::LLVMGetTypeKind(ty);\n \n         fn tys_str(names: type_names, outer: ~[TypeRef],\n-                   tys: ~[TypeRef]) -> ~str {\n-            let mut s: ~str = ~\"\";\n+                   tys: ~[TypeRef]) -> @str {\n+            let mut s = ~\"\";\n             let mut first: bool = true;\n             for tys.each |t| {\n                 if first { first = false; } else { s += ~\", \"; }\n-                s += type_to_str_inner(names, outer, *t);\n+                s += type_to_str_inner(names, outer, *t).to_owned();\n             }\n-            return s;\n+            // [Note at-str] FIXME #2543: Could rewrite this without the copy,\n+            // but need better @str support.\n+            return s.to_managed();\n         }\n \n         match kind {\n-          Void => return ~\"Void\",\n-          Half => return ~\"Half\",\n-          Float => return ~\"Float\",\n-          Double => return ~\"Double\",\n-          X86_FP80 => return ~\"X86_FP80\",\n-          FP128 => return ~\"FP128\",\n-          PPC_FP128 => return ~\"PPC_FP128\",\n-          Label => return ~\"Label\",\n+          Void => return @\"Void\",\n+          Half => return @\"Half\",\n+          Float => return @\"Float\",\n+          Double => return @\"Double\",\n+          X86_FP80 => return @\"X86_FP80\",\n+          FP128 => return @\"FP128\",\n+          PPC_FP128 => return @\"PPC_FP128\",\n+          Label => return @\"Label\",\n           Integer => {\n-            return ~\"i\" + int::str(llvm::LLVMGetIntTypeWidth(ty) as int);\n+            // See [Note at-str]\n+            return fmt!(\"i%d\", llvm::LLVMGetIntTypeWidth(ty)\n+                        as int).to_managed();\n           }\n           Function => {\n-            let mut s = ~\"fn(\";\n             let out_ty: TypeRef = llvm::LLVMGetReturnType(ty);\n             let n_args = llvm::LLVMCountParamTypes(ty) as uint;\n             let args = vec::from_elem(n_args, 0 as TypeRef);\n             unsafe {\n                 llvm::LLVMGetParamTypes(ty, vec::raw::to_ptr(args));\n             }\n-            s += tys_str(names, outer, args);\n-            s += ~\") -> \";\n-            s += type_to_str_inner(names, outer, out_ty);\n-            return s;\n+            // See [Note at-str]\n+            return fmt!(\"fn(%s) -> %s\",\n+                        tys_str(names, outer, args),\n+                        type_to_str_inner(names, outer, out_ty)).to_managed();\n           }\n           Struct => {\n-            let mut s: ~str = ~\"{\";\n             let n_elts = llvm::LLVMCountStructElementTypes(ty) as uint;\n             let mut elts = vec::from_elem(n_elts, 0 as TypeRef);\n-            if elts.len() > 0 {\n+            if elts.is_not_empty() {\n                 llvm::LLVMGetStructElementTypes(\n                     ty, ptr::to_mut_unsafe_ptr(&mut elts[0]));\n             }\n-            s += tys_str(names, outer, elts);\n-            s += ~\"}\";\n-            return s;\n+            // See [Note at-str]\n+            return fmt!(\"{%s}\", tys_str(names, outer, elts)).to_managed();\n           }\n           Array => {\n             let el_ty = llvm::LLVMGetElementType(ty);\n-            return ~\"[\" + type_to_str_inner(names, outer, el_ty) + ~\" x \" +\n-                uint::str(llvm::LLVMGetArrayLength(ty) as uint) + ~\"]\";\n+            // See [Note at-str]\n+            return fmt!(\"[%s@ x %u\", type_to_str_inner(names, outer, el_ty),\n+                llvm::LLVMGetArrayLength(ty) as uint).to_managed();\n           }\n           Pointer => {\n-            let mut i: uint = 0u;\n+            let mut i = 0;\n             for outer0.each |tout| {\n-                i += 1u;\n+                i += 1;\n                 if *tout as int == ty as int {\n-                    let n: uint = vec::len::<TypeRef>(outer0) - i;\n-                    return ~\"*\\\\\" + int::str(n as int);\n+                    let n = outer0.len() - i;\n+                    // See [Note at-str]\n+                    return fmt!(\"*\\\\%d\", n as int).to_managed();\n                 }\n             }\n             let addrstr = {\n                 let addrspace = llvm::LLVMGetPointerAddressSpace(ty) as uint;\n-                if addrspace == 0u {\n+                if addrspace == 0 {\n                     ~\"\"\n                 } else {\n                     fmt!(\"addrspace(%u)\", addrspace)\n                 }\n             };\n-            return addrstr + ~\"*\" +\n-                    type_to_str_inner(names,\n-                                      outer,\n-                                      llvm::LLVMGetElementType(ty));\n+            // See [Note at-str]\n+            return fmt!(\"%s*%s\", addrstr, type_to_str_inner(names,\n+                        outer,\n+                        llvm::LLVMGetElementType(ty))).to_managed();\n           }\n-          Vector => return ~\"Vector\",\n-          Metadata => return ~\"Metadata\",\n-          X86_MMX => return ~\"X86_MMAX\"\n+          Vector => return @\"Vector\",\n+          Metadata => return @\"Metadata\",\n+          X86_MMX => return @\"X86_MMAX\"\n         }\n     }\n }"}, {"sha": "d8597a7af25436532163c2895efa21814595c492", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/97b20f8e024096b903b8ec05bd39d0387d9190cb/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97b20f8e024096b903b8ec05bd39d0387d9190cb/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=97b20f8e024096b903b8ec05bd39d0387d9190cb", "patch": "@@ -2979,9 +2979,9 @@ fn trans_crate(sess: session::Session,\n         let float_type = T_float(targ_cfg);\n         let task_type = T_task(targ_cfg);\n         let taskptr_type = T_ptr(task_type);\n-        lib::llvm::associate_type(tn, ~\"taskptr\", taskptr_type);\n+        lib::llvm::associate_type(tn, @\"taskptr\", taskptr_type);\n         let tydesc_type = T_tydesc(targ_cfg);\n-        lib::llvm::associate_type(tn, ~\"tydesc\", tydesc_type);\n+        lib::llvm::associate_type(tn, @\"tydesc\", tydesc_type);\n         let crate_map = decl_crate_map(sess, link_meta, llmod);\n         let dbg_cx = if sess.opts.debuginfo {\n             Some(debuginfo::mk_ctxt(copy llmod_id, sess.parse_sess.interner))"}, {"sha": "c913643ac99af96af4bb788024f119d1bf73831c", "filename": "src/librustc/middle/trans/build.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/97b20f8e024096b903b8ec05bd39d0387d9190cb/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97b20f8e024096b903b8ec05bd39d0387d9190cb/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs?ref=97b20f8e024096b903b8ec05bd39d0387d9190cb", "patch": "@@ -188,7 +188,8 @@ fn Invoke(cx: block, Fn: ValueRef, Args: ~[ValueRef],\n     terminate(cx, \"Invoke\");\n     debug!(\"Invoke(%s with arguments (%s))\",\n            val_str(cx.ccx().tn, Fn),\n-           str::connect(vec::map(Args, |a| val_str(cx.ccx().tn, *a)),\n+           str::connect(vec::map(Args, |a| val_str(cx.ccx().tn,\n+                                                   *a).to_owned()),\n                         ~\", \"));\n     unsafe {\n         count_insn(cx, \"invoke\");"}, {"sha": "e5f2f25e67c876d3f680d16a360540ff9dc9d28b", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/97b20f8e024096b903b8ec05bd39d0387d9190cb/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97b20f8e024096b903b8ec05bd39d0387d9190cb/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=97b20f8e024096b903b8ec05bd39d0387d9190cb", "patch": "@@ -645,7 +645,7 @@ impl Result {\n     }\n }\n \n-fn ty_str(tn: type_names, t: TypeRef) -> ~str {\n+fn ty_str(tn: type_names, t: TypeRef) -> @str {\n     return lib::llvm::type_to_str(tn, t);\n }\n \n@@ -655,7 +655,7 @@ fn val_ty(v: ValueRef) -> TypeRef {\n     }\n }\n \n-fn val_str(tn: type_names, v: ValueRef) -> ~str {\n+fn val_str(tn: type_names, v: ValueRef) -> @str {\n     return ty_str(tn, val_ty(v));\n }\n \n@@ -729,11 +729,11 @@ impl block {\n         }\n     }\n \n-    fn val_str(val: ValueRef) -> ~str {\n+    fn val_str(val: ValueRef) -> @str {\n         val_str(self.ccx().tn, val)\n     }\n \n-    fn llty_str(llty: TypeRef) -> ~str {\n+    fn llty_str(llty: TypeRef) -> @str {\n         ty_str(self.ccx().tn, llty)\n     }\n \n@@ -924,7 +924,7 @@ fn T_tydesc_field(cx: @crate_ctxt, field: uint) -> TypeRef unsafe {\n }\n \n fn T_generic_glue_fn(cx: @crate_ctxt) -> TypeRef {\n-    let s = ~\"glue_fn\";\n+    let s = @\"glue_fn\";\n     match name_has_type(cx.tn, s) {\n       Some(t) => return t,\n       _ => ()\n@@ -1038,7 +1038,7 @@ fn T_taskptr(cx: @crate_ctxt) -> TypeRef { return T_ptr(cx.task_type); }\n \n // This type must never be used directly; it must always be cast away.\n fn T_typaram(tn: type_names) -> TypeRef {\n-    let s = ~\"typaram\";\n+    let s = @\"typaram\";\n     match name_has_type(tn, s) {\n       Some(t) => return t,\n       _ => ()\n@@ -1061,7 +1061,7 @@ fn T_enum_discrim(cx: @crate_ctxt) -> TypeRef {\n }\n \n fn T_opaque_enum(cx: @crate_ctxt) -> TypeRef {\n-    let s = ~\"opaque_enum\";\n+    let s = @\"opaque_enum\";\n     match name_has_type(cx.tn, s) {\n       Some(t) => return t,\n       _ => ()"}]}