{"sha": "2448e9d9db656ac25e90d70f2bacee318d214025", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI0NDhlOWQ5ZGI2NTZhYzI1ZTkwZDcwZjJiYWNlZTMxOGQyMTQwMjU=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2019-06-08T21:00:46Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-06-08T21:00:46Z"}, "message": "Merge pull request #765 from RalfJung/rustup\n\nrustup for EvalResult rename", "tree": {"sha": "5144554c8d59b3b9efcb9b35fea0d7412b2c8094", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5144554c8d59b3b9efcb9b35fea0d7412b2c8094"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2448e9d9db656ac25e90d70f2bacee318d214025", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJc/CH+CRBK7hj4Ov3rIwAAdHIIAKljTCHAdqbbIH4tZJrI7PLd\n4VIdQ/c2cOt/Sbx7VmbAUP7d0vsPBDCeXGtftji3BGSAW9qaiZf6qaewgSyVCrbM\nW7gWGx3JrWEAXympjzJIx3Mql0t8CPV7Z0LjhLEbgOYhgJ94V4Sm2AMZYo8P7k0d\noPDzkDDrrEg9ERyg6j/K9vPaaB+x3CmB8PAvAHlx03JHt4M5xGGk+fyveJOSMb8J\naOz0/9E6gJZkAdbtava11R/KzZSaBg0esTRZeXsiXeGDr/oNOaRLB7O2g5HJZzu+\nY113xbwQQJyCNn16eRaRfZLronRFUckhCtRZLzCTMNo+4oiOZPhtA/w1VWwzIOY=\n=pm/E\n-----END PGP SIGNATURE-----\n", "payload": "tree 5144554c8d59b3b9efcb9b35fea0d7412b2c8094\nparent 6ab014723a0ec2b382d309f355c10cf99557b55f\nparent d6bcfc58e3afe292cce167e8a419cf412c25e4cd\nauthor Ralf Jung <post@ralfj.de> 1560027646 +0200\ncommitter GitHub <noreply@github.com> 1560027646 +0200\n\nMerge pull request #765 from RalfJung/rustup\n\nrustup for EvalResult rename"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2448e9d9db656ac25e90d70f2bacee318d214025", "html_url": "https://github.com/rust-lang/rust/commit/2448e9d9db656ac25e90d70f2bacee318d214025", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2448e9d9db656ac25e90d70f2bacee318d214025/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6ab014723a0ec2b382d309f355c10cf99557b55f", "url": "https://api.github.com/repos/rust-lang/rust/commits/6ab014723a0ec2b382d309f355c10cf99557b55f", "html_url": "https://github.com/rust-lang/rust/commit/6ab014723a0ec2b382d309f355c10cf99557b55f"}, {"sha": "d6bcfc58e3afe292cce167e8a419cf412c25e4cd", "url": "https://api.github.com/repos/rust-lang/rust/commits/d6bcfc58e3afe292cce167e8a419cf412c25e4cd", "html_url": "https://github.com/rust-lang/rust/commit/d6bcfc58e3afe292cce167e8a419cf412c25e4cd"}], "stats": {"total": 118, "additions": 59, "deletions": 59}, "files": [{"sha": "3e7048ac72cc5615da8abe099fa451c64f8a3fd3", "filename": "rust-version", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2448e9d9db656ac25e90d70f2bacee318d214025/rust-version", "raw_url": "https://github.com/rust-lang/rust/raw/2448e9d9db656ac25e90d70f2bacee318d214025/rust-version", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/rust-version?ref=2448e9d9db656ac25e90d70f2bacee318d214025", "patch": "@@ -1 +1 @@\n-7cdaffd7962c4aae0cadd82baa241901b03f9458\n+5c45343f11fbf93cf4e15568aee3ff3f2f287466"}, {"sha": "5397c048f9f46aeea4689aec1b9349637c4fbc2c", "filename": "src/fn_call.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/2448e9d9db656ac25e90d70f2bacee318d214025/src%2Ffn_call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2448e9d9db656ac25e90d70f2bacee318d214025/src%2Ffn_call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ffn_call.rs?ref=2448e9d9db656ac25e90d70f2bacee318d214025", "patch": "@@ -17,7 +17,7 @@ pub trait EvalContextExt<'a, 'mir, 'tcx: 'a + 'mir>: crate::MiriEvalContextExt<'\n         args: &[OpTy<'tcx, Tag>],\n         dest: Option<PlaceTy<'tcx, Tag>>,\n         ret: Option<mir::BasicBlock>,\n-    ) -> EvalResult<'tcx, Option<&'mir mir::Body<'tcx>>> {\n+    ) -> InterpResult<'tcx, Option<&'mir mir::Body<'tcx>>> {\n         let this = self.eval_context_mut();\n         trace!(\"eval_fn_call: {:#?}, {:?}\", instance, dest.map(|place| *place));\n \n@@ -76,7 +76,7 @@ pub trait EvalContextExt<'a, 'mir, 'tcx: 'a + 'mir>: crate::MiriEvalContextExt<'\n     fn free(\n         &mut self,\n         ptr: Scalar<Tag>,\n-    ) -> EvalResult<'tcx> {\n+    ) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n         if !ptr.is_null_ptr(this) {\n             this.memory_mut().deallocate(\n@@ -92,7 +92,7 @@ pub trait EvalContextExt<'a, 'mir, 'tcx: 'a + 'mir>: crate::MiriEvalContextExt<'\n         &mut self,\n         old_ptr: Scalar<Tag>,\n         new_size: u64,\n-    ) -> EvalResult<'tcx, Scalar<Tag>> {\n+    ) -> InterpResult<'tcx, Scalar<Tag>> {\n         let this = self.eval_context_mut();\n         let align = this.tcx.data_layout.pointer_align.abi;\n         if old_ptr.is_null_ptr(this) {\n@@ -139,7 +139,7 @@ pub trait EvalContextExt<'a, 'mir, 'tcx: 'a + 'mir>: crate::MiriEvalContextExt<'\n         args: &[OpTy<'tcx, Tag>],\n         dest: Option<PlaceTy<'tcx, Tag>>,\n         ret: Option<mir::BasicBlock>,\n-    ) -> EvalResult<'tcx> {\n+    ) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n         let attrs = this.tcx.get_attrs(def_id);\n         let link_name = match attr::first_attr_value_str_by_name(&attrs, sym::link_name) {\n@@ -895,13 +895,13 @@ pub trait EvalContextExt<'a, 'mir, 'tcx: 'a + 'mir>: crate::MiriEvalContextExt<'\n         Ok(())\n     }\n \n-    fn write_null(&mut self, dest: PlaceTy<'tcx, Tag>) -> EvalResult<'tcx> {\n+    fn write_null(&mut self, dest: PlaceTy<'tcx, Tag>) -> InterpResult<'tcx> {\n         self.eval_context_mut().write_scalar(Scalar::from_int(0, dest.layout.size), dest)\n     }\n \n     /// Evaluates the scalar at the specified path. Returns Some(val)\n     /// if the path could be resolved, and None otherwise\n-    fn eval_path_scalar(&mut self, path: &[&str]) -> EvalResult<'tcx, Option<ScalarMaybeUndef<Tag>>> {\n+    fn eval_path_scalar(&mut self, path: &[&str]) -> InterpResult<'tcx, Option<ScalarMaybeUndef<Tag>>> {\n         let this = self.eval_context_mut();\n         if let Ok(instance) = this.resolve_path(path) {\n             let cid = GlobalId {\n@@ -920,7 +920,7 @@ fn gen_random<'a, 'mir, 'tcx>(\n     this: &mut MiriEvalContext<'a, 'mir, 'tcx>,\n     len: usize,\n     dest: Scalar<Tag>,\n-) -> EvalResult<'tcx>  {\n+) -> InterpResult<'tcx>  {\n     if len == 0 {\n         // Nothing to do\n         return Ok(());"}, {"sha": "29bc1def9fda5632c76f2b71f9f9f2cf67c75686", "filename": "src/helpers.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/2448e9d9db656ac25e90d70f2bacee318d214025/src%2Fhelpers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2448e9d9db656ac25e90d70f2bacee318d214025/src%2Fhelpers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fhelpers.rs?ref=2448e9d9db656ac25e90d70f2bacee318d214025", "patch": "@@ -9,7 +9,7 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'a, 'mir, 'tcx> for crate::MiriEvalContext<'\n \n pub trait EvalContextExt<'a, 'mir, 'tcx: 'a + 'mir>: crate::MiriEvalContextExt<'a, 'mir, 'tcx> {\n     /// Gets an instance for a path.\n-    fn resolve_path(&self, path: &[&str]) -> EvalResult<'tcx, ty::Instance<'tcx>> {\n+    fn resolve_path(&self, path: &[&str]) -> InterpResult<'tcx, ty::Instance<'tcx>> {\n         let this = self.eval_context_ref();\n         this.tcx\n             .crates()\n@@ -49,8 +49,8 @@ pub trait EvalContextExt<'a, 'mir, 'tcx: 'a + 'mir>: crate::MiriEvalContextExt<'\n         &self,\n         place: MPlaceTy<'tcx, Tag>,\n         size: Size,\n-        mut action: impl FnMut(Pointer<Tag>, Size, bool) -> EvalResult<'tcx>,\n-    ) -> EvalResult<'tcx> {\n+        mut action: impl FnMut(Pointer<Tag>, Size, bool) -> InterpResult<'tcx>,\n+    ) -> InterpResult<'tcx> {\n         let this = self.eval_context_ref();\n         trace!(\"visit_frozen(place={:?}, size={:?})\", *place, size);\n         debug_assert_eq!(size,\n@@ -120,7 +120,7 @@ pub trait EvalContextExt<'a, 'mir, 'tcx: 'a + 'mir>: crate::MiriEvalContextExt<'\n         /// Visiting the memory covered by a `MemPlace`, being aware of\n         /// whether we are inside an `UnsafeCell` or not.\n         struct UnsafeCellVisitor<'ecx, 'a, 'mir, 'tcx, F>\n-            where F: FnMut(MPlaceTy<'tcx, Tag>) -> EvalResult<'tcx>\n+            where F: FnMut(MPlaceTy<'tcx, Tag>) -> InterpResult<'tcx>\n         {\n             ecx: &'ecx MiriEvalContext<'a, 'mir, 'tcx>,\n             unsafe_cell_action: F,\n@@ -131,7 +131,7 @@ pub trait EvalContextExt<'a, 'mir, 'tcx: 'a + 'mir>: crate::MiriEvalContextExt<'\n         for\n             UnsafeCellVisitor<'ecx, 'a, 'mir, 'tcx, F>\n         where\n-            F: FnMut(MPlaceTy<'tcx, Tag>) -> EvalResult<'tcx>\n+            F: FnMut(MPlaceTy<'tcx, Tag>) -> InterpResult<'tcx>\n         {\n             type V = MPlaceTy<'tcx, Tag>;\n \n@@ -141,7 +141,7 @@ pub trait EvalContextExt<'a, 'mir, 'tcx: 'a + 'mir>: crate::MiriEvalContextExt<'\n             }\n \n             // Hook to detect `UnsafeCell`.\n-            fn visit_value(&mut self, v: MPlaceTy<'tcx, Tag>) -> EvalResult<'tcx>\n+            fn visit_value(&mut self, v: MPlaceTy<'tcx, Tag>) -> InterpResult<'tcx>\n             {\n                 trace!(\"UnsafeCellVisitor: {:?} {:?}\", *v, v.layout.ty);\n                 let is_unsafe_cell = match v.layout.ty.sty {\n@@ -164,8 +164,8 @@ pub trait EvalContextExt<'a, 'mir, 'tcx: 'a + 'mir>: crate::MiriEvalContextExt<'\n             fn visit_aggregate(\n                 &mut self,\n                 place: MPlaceTy<'tcx, Tag>,\n-                fields: impl Iterator<Item=EvalResult<'tcx, MPlaceTy<'tcx, Tag>>>,\n-            ) -> EvalResult<'tcx> {\n+                fields: impl Iterator<Item=InterpResult<'tcx, MPlaceTy<'tcx, Tag>>>,\n+            ) -> InterpResult<'tcx> {\n                 match place.layout.fields {\n                     layout::FieldPlacement::Array { .. } => {\n                         // For the array layout, we know the iterator will yield sorted elements so\n@@ -174,7 +174,7 @@ pub trait EvalContextExt<'a, 'mir, 'tcx: 'a + 'mir>: crate::MiriEvalContextExt<'\n                     }\n                     layout::FieldPlacement::Arbitrary { .. } => {\n                         // Gather the subplaces and sort them before visiting.\n-                        let mut places = fields.collect::<EvalResult<'tcx, Vec<MPlaceTy<'tcx, Tag>>>>()?;\n+                        let mut places = fields.collect::<InterpResult<'tcx, Vec<MPlaceTy<'tcx, Tag>>>>()?;\n                         places.sort_by_key(|place| place.ptr.get_ptr_offset(self.ecx()));\n                         self.walk_aggregate(place, places.into_iter().map(Ok))\n                     }\n@@ -186,7 +186,7 @@ pub trait EvalContextExt<'a, 'mir, 'tcx: 'a + 'mir>: crate::MiriEvalContextExt<'\n             }\n \n             // We have to do *something* for unions.\n-            fn visit_union(&mut self, v: MPlaceTy<'tcx, Tag>) -> EvalResult<'tcx>\n+            fn visit_union(&mut self, v: MPlaceTy<'tcx, Tag>) -> InterpResult<'tcx>\n             {\n                 // With unions, we fall back to whatever the type says, to hopefully be consistent\n                 // with LLVM IR.\n@@ -200,7 +200,7 @@ pub trait EvalContextExt<'a, 'mir, 'tcx: 'a + 'mir>: crate::MiriEvalContextExt<'\n             }\n \n             // We should never get to a primitive, but always short-circuit somewhere above.\n-            fn visit_primitive(&mut self, _v: MPlaceTy<'tcx, Tag>) -> EvalResult<'tcx>\n+            fn visit_primitive(&mut self, _v: MPlaceTy<'tcx, Tag>) -> InterpResult<'tcx>\n             {\n                 bug!(\"we should always short-circuit before coming to a primitive\")\n             }"}, {"sha": "822265bc2112d5ab0ba4e30de8034c14f697607f", "filename": "src/intrinsic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2448e9d9db656ac25e90d70f2bacee318d214025/src%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2448e9d9db656ac25e90d70f2bacee318d214025/src%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintrinsic.rs?ref=2448e9d9db656ac25e90d70f2bacee318d214025", "patch": "@@ -1,5 +1,5 @@\n use rustc::mir;\n-use rustc::mir::interpret::{EvalResult, PointerArithmetic};\n+use rustc::mir::interpret::{InterpResult, PointerArithmetic};\n use rustc::ty::layout::{self, LayoutOf, Size};\n use rustc::ty;\n \n@@ -15,7 +15,7 @@ pub trait EvalContextExt<'a, 'mir, 'tcx: 'a+'mir>: crate::MiriEvalContextExt<'a,\n         instance: ty::Instance<'tcx>,\n         args: &[OpTy<'tcx, Tag>],\n         dest: PlaceTy<'tcx, Tag>,\n-    ) -> EvalResult<'tcx> {\n+    ) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n         if this.emulate_intrinsic(instance, args, dest)? {\n             return Ok(());"}, {"sha": "8577bc4714e5f3205db18c848ac0c30bbd422887", "filename": "src/lib.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/2448e9d9db656ac25e90d70f2bacee318d214025/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2448e9d9db656ac25e90d70f2bacee318d214025/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=2448e9d9db656ac25e90d70f2bacee318d214025", "patch": "@@ -75,7 +75,7 @@ pub fn create_ecx<'a, 'mir: 'a, 'tcx: 'mir>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     main_id: DefId,\n     config: MiriConfig,\n-) -> EvalResult<'tcx, InterpretCx<'a, 'mir, 'tcx, Evaluator<'tcx>>> {\n+) -> InterpResult<'tcx, InterpretCx<'a, 'mir, 'tcx, Evaluator<'tcx>>> {\n     let mut ecx = InterpretCx::new(\n         tcx.at(syntax::source_map::DUMMY_SP),\n         ty::ParamEnv::reveal_all(),\n@@ -225,7 +225,7 @@ pub fn eval_main<'a, 'tcx: 'a>(\n     };\n \n     // Perform the main execution.\n-    let res: EvalResult = (|| {\n+    let res: InterpResult = (|| {\n         ecx.run()?;\n         ecx.run_tls_dtors()\n     })();\n@@ -407,7 +407,7 @@ impl<'a, 'mir, 'tcx> Machine<'a, 'mir, 'tcx> for Evaluator<'tcx> {\n         args: &[OpTy<'tcx, Tag>],\n         dest: Option<PlaceTy<'tcx, Tag>>,\n         ret: Option<mir::BasicBlock>,\n-    ) -> EvalResult<'tcx, Option<&'mir mir::Body<'tcx>>> {\n+    ) -> InterpResult<'tcx, Option<&'mir mir::Body<'tcx>>> {\n         ecx.find_fn(instance, args, dest, ret)\n     }\n \n@@ -417,7 +417,7 @@ impl<'a, 'mir, 'tcx> Machine<'a, 'mir, 'tcx> for Evaluator<'tcx> {\n         instance: ty::Instance<'tcx>,\n         args: &[OpTy<'tcx, Tag>],\n         dest: PlaceTy<'tcx, Tag>,\n-    ) -> EvalResult<'tcx> {\n+    ) -> InterpResult<'tcx> {\n         ecx.call_intrinsic(instance, args, dest)\n     }\n \n@@ -427,14 +427,14 @@ impl<'a, 'mir, 'tcx> Machine<'a, 'mir, 'tcx> for Evaluator<'tcx> {\n         bin_op: mir::BinOp,\n         left: ImmTy<'tcx, Tag>,\n         right: ImmTy<'tcx, Tag>,\n-    ) -> EvalResult<'tcx, (Scalar<Tag>, bool)> {\n+    ) -> InterpResult<'tcx, (Scalar<Tag>, bool)> {\n         ecx.ptr_op(bin_op, left, right)\n     }\n \n     fn box_alloc(\n         ecx: &mut InterpretCx<'a, 'mir, 'tcx, Self>,\n         dest: PlaceTy<'tcx, Tag>,\n-    ) -> EvalResult<'tcx> {\n+    ) -> InterpResult<'tcx> {\n         trace!(\"box_alloc for {:?}\", dest.layout.ty);\n         // Call the `exchange_malloc` lang item.\n         let malloc = ecx.tcx.lang_items().exchange_malloc_fn().unwrap();\n@@ -476,7 +476,7 @@ impl<'a, 'mir, 'tcx> Machine<'a, 'mir, 'tcx> for Evaluator<'tcx> {\n     fn find_foreign_static(\n         def_id: DefId,\n         tcx: TyCtxtAt<'a, 'tcx, 'tcx>,\n-    ) -> EvalResult<'tcx, Cow<'tcx, Allocation>> {\n+    ) -> InterpResult<'tcx, Cow<'tcx, Allocation>> {\n         let attrs = tcx.get_attrs(def_id);\n         let link_name = match attr::first_attr_value_str_by_name(&attrs, sym::link_name) {\n             Some(name) => name.as_str(),\n@@ -498,7 +498,7 @@ impl<'a, 'mir, 'tcx> Machine<'a, 'mir, 'tcx> for Evaluator<'tcx> {\n     }\n \n     #[inline(always)]\n-    fn before_terminator(_ecx: &mut InterpretCx<'a, 'mir, 'tcx, Self>) -> EvalResult<'tcx>\n+    fn before_terminator(_ecx: &mut InterpretCx<'a, 'mir, 'tcx, Self>) -> InterpResult<'tcx>\n     {\n         // We are not interested in detecting loops.\n         Ok(())\n@@ -553,7 +553,7 @@ impl<'a, 'mir, 'tcx> Machine<'a, 'mir, 'tcx> for Evaluator<'tcx> {\n         ecx: &mut InterpretCx<'a, 'mir, 'tcx, Self>,\n         kind: mir::RetagKind,\n         place: PlaceTy<'tcx, Tag>,\n-    ) -> EvalResult<'tcx> {\n+    ) -> InterpResult<'tcx> {\n         if !ecx.tcx.sess.opts.debugging_opts.mir_emit_retag || !Self::enforce_validity(ecx) {\n             // No tracking, or no retagging. The latter is possible because a dependency of ours\n             // might be called with different flags than we are, so there are `Retag`\n@@ -569,15 +569,15 @@ impl<'a, 'mir, 'tcx> Machine<'a, 'mir, 'tcx> for Evaluator<'tcx> {\n     #[inline(always)]\n     fn stack_push(\n         ecx: &mut InterpretCx<'a, 'mir, 'tcx, Self>,\n-    ) -> EvalResult<'tcx, stacked_borrows::CallId> {\n+    ) -> InterpResult<'tcx, stacked_borrows::CallId> {\n         Ok(ecx.memory().extra.borrow_mut().new_call())\n     }\n \n     #[inline(always)]\n     fn stack_pop(\n         ecx: &mut InterpretCx<'a, 'mir, 'tcx, Self>,\n         extra: stacked_borrows::CallId,\n-    ) -> EvalResult<'tcx> {\n+    ) -> InterpResult<'tcx> {\n         Ok(ecx.memory().extra.borrow_mut().end_call(extra))\n     }\n }"}, {"sha": "411df2155de0e1c824eb09bddb35b5374578e529", "filename": "src/operator.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/2448e9d9db656ac25e90d70f2bacee318d214025/src%2Foperator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2448e9d9db656ac25e90d70f2bacee318d214025/src%2Foperator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Foperator.rs?ref=2448e9d9db656ac25e90d70f2bacee318d214025", "patch": "@@ -9,28 +9,28 @@ pub trait EvalContextExt<'tcx> {\n         bin_op: mir::BinOp,\n         left: ImmTy<'tcx, Tag>,\n         right: ImmTy<'tcx, Tag>,\n-    ) -> EvalResult<'tcx, (Scalar<Tag>, bool)>;\n+    ) -> InterpResult<'tcx, (Scalar<Tag>, bool)>;\n \n     fn ptr_int_arithmetic(\n         &self,\n         bin_op: mir::BinOp,\n         left: Pointer<Tag>,\n         right: u128,\n         signed: bool,\n-    ) -> EvalResult<'tcx, (Scalar<Tag>, bool)>;\n+    ) -> InterpResult<'tcx, (Scalar<Tag>, bool)>;\n \n     fn ptr_eq(\n         &self,\n         left: Scalar<Tag>,\n         right: Scalar<Tag>,\n-    ) -> EvalResult<'tcx, bool>;\n+    ) -> InterpResult<'tcx, bool>;\n \n     fn pointer_offset_inbounds(\n         &self,\n         ptr: Scalar<Tag>,\n         pointee_ty: Ty<'tcx>,\n         offset: i64,\n-    ) -> EvalResult<'tcx, Scalar<Tag>>;\n+    ) -> InterpResult<'tcx, Scalar<Tag>>;\n }\n \n impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'a, 'mir, 'tcx> {\n@@ -39,7 +39,7 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'a, 'mir, '\n         bin_op: mir::BinOp,\n         left: ImmTy<'tcx, Tag>,\n         right: ImmTy<'tcx, Tag>,\n-    ) -> EvalResult<'tcx, (Scalar<Tag>, bool)> {\n+    ) -> InterpResult<'tcx, (Scalar<Tag>, bool)> {\n         use rustc::mir::BinOp::*;\n \n         trace!(\"ptr_op: {:?} {:?} {:?}\", *left, bin_op, *right);\n@@ -138,7 +138,7 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'a, 'mir, '\n         &self,\n         left: Scalar<Tag>,\n         right: Scalar<Tag>,\n-    ) -> EvalResult<'tcx, bool> {\n+    ) -> InterpResult<'tcx, bool> {\n         let size = self.pointer_size();\n         Ok(match (left, right) {\n             (Scalar::Raw { .. }, Scalar::Raw { .. }) =>\n@@ -236,7 +236,7 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'a, 'mir, '\n         left: Pointer<Tag>,\n         right: u128,\n         signed: bool,\n-    ) -> EvalResult<'tcx, (Scalar<Tag>, bool)> {\n+    ) -> InterpResult<'tcx, (Scalar<Tag>, bool)> {\n         use rustc::mir::BinOp::*;\n \n         fn map_to_primval((res, over): (Pointer<Tag>, bool)) -> (Scalar<Tag>, bool) {\n@@ -328,7 +328,7 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'a, 'mir, '\n         ptr: Scalar<Tag>,\n         pointee_ty: Ty<'tcx>,\n         offset: i64,\n-    ) -> EvalResult<'tcx, Scalar<Tag>> {\n+    ) -> InterpResult<'tcx, Scalar<Tag>> {\n         // FIXME: assuming here that type size is less than `i64::max_value()`.\n         let pointee_size = self.layout_of(pointee_ty)?.size.bytes() as i64;\n         let offset = offset"}, {"sha": "bd815847901930557fca20cc600de448e5cd3236", "filename": "src/stacked_borrows.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/2448e9d9db656ac25e90d70f2bacee318d214025/src%2Fstacked_borrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2448e9d9db656ac25e90d70f2bacee318d214025/src%2Fstacked_borrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstacked_borrows.rs?ref=2448e9d9db656ac25e90d70f2bacee318d214025", "patch": "@@ -9,7 +9,7 @@ use rustc::hir::{MutMutable, MutImmutable};\n use rustc::mir::RetagKind;\n \n use crate::{\n-    EvalResult, InterpError, MiriEvalContext, HelpersEvalContextExt, Evaluator, MutValueVisitor,\n+    InterpResult, InterpError, MiriEvalContext, HelpersEvalContextExt, Evaluator, MutValueVisitor,\n     MemoryKind, MiriMemoryKind, RangeMap, Allocation, AllocationExtra, AllocId, CheckInAllocMsg,\n     Pointer, Immediate, ImmTy, PlaceTy, MPlaceTy,\n };\n@@ -266,7 +266,7 @@ impl<'tcx> Stack {\n     }\n \n     /// Check if the given item is protected.\n-    fn check_protector(item: &Item, tag: Option<Tag>, global: &GlobalState) -> EvalResult<'tcx> {\n+    fn check_protector(item: &Item, tag: Option<Tag>, global: &GlobalState) -> InterpResult<'tcx> {\n         if let Some(call) = item.protector {\n             if global.is_active(call) {\n                 if let Some(tag) = tag {\n@@ -291,7 +291,7 @@ impl<'tcx> Stack {\n         access: AccessKind,\n         tag: Tag,\n         global: &GlobalState,\n-    ) -> EvalResult<'tcx> {\n+    ) -> InterpResult<'tcx> {\n         // Two main steps: Find granting item, remove incompatible items above.\n \n         // Step 1: Find granting item.\n@@ -340,7 +340,7 @@ impl<'tcx> Stack {\n         &mut self,\n         tag: Tag,\n         global: &GlobalState,\n-    ) -> EvalResult<'tcx> {\n+    ) -> InterpResult<'tcx> {\n         // Step 1: Find granting item.\n         self.find_granting(AccessKind::Write, tag)\n             .ok_or_else(|| InterpError::MachineError(format!(\n@@ -365,7 +365,7 @@ impl<'tcx> Stack {\n         derived_from: Tag,\n         new: Item,\n         global: &GlobalState,\n-    ) -> EvalResult<'tcx> {\n+    ) -> InterpResult<'tcx> {\n         // Figure out which access `perm` corresponds to.\n         let access = if new.perm.grants(AccessKind::Write) {\n             AccessKind::Write\n@@ -440,8 +440,8 @@ impl<'tcx> Stacks {\n         &self,\n         ptr: Pointer<Tag>,\n         size: Size,\n-        f: impl Fn(&mut Stack, &GlobalState) -> EvalResult<'tcx>,\n-    ) -> EvalResult<'tcx> {\n+        f: impl Fn(&mut Stack, &GlobalState) -> InterpResult<'tcx>,\n+    ) -> InterpResult<'tcx> {\n         let global = self.global.borrow();\n         let mut stacks = self.stacks.borrow_mut();\n         for stack in stacks.iter_mut(ptr.offset, size) {\n@@ -483,7 +483,7 @@ impl AllocationExtra<Tag> for Stacks {\n         alloc: &Allocation<Tag, Stacks>,\n         ptr: Pointer<Tag>,\n         size: Size,\n-    ) -> EvalResult<'tcx> {\n+    ) -> InterpResult<'tcx> {\n         trace!(\"read access with tag {:?}: {:?}, size {}\", ptr.tag, ptr.erase_tag(), size.bytes());\n         alloc.extra.for_each(ptr, size, |stack, global| {\n             stack.access(AccessKind::Read, ptr.tag, global)?;\n@@ -496,7 +496,7 @@ impl AllocationExtra<Tag> for Stacks {\n         alloc: &mut Allocation<Tag, Stacks>,\n         ptr: Pointer<Tag>,\n         size: Size,\n-    ) -> EvalResult<'tcx> {\n+    ) -> InterpResult<'tcx> {\n         trace!(\"write access with tag {:?}: {:?}, size {}\", ptr.tag, ptr.erase_tag(), size.bytes());\n         alloc.extra.for_each(ptr, size, |stack, global| {\n             stack.access(AccessKind::Write, ptr.tag, global)?;\n@@ -509,7 +509,7 @@ impl AllocationExtra<Tag> for Stacks {\n         alloc: &mut Allocation<Tag, Stacks>,\n         ptr: Pointer<Tag>,\n         size: Size,\n-    ) -> EvalResult<'tcx> {\n+    ) -> InterpResult<'tcx> {\n         trace!(\"deallocation with tag {:?}: {:?}, size {}\", ptr.tag, ptr.erase_tag(), size.bytes());\n         alloc.extra.for_each(ptr, size, |stack, global| {\n             stack.dealloc(ptr.tag, global)\n@@ -528,7 +528,7 @@ trait EvalContextPrivExt<'a, 'mir, 'tcx: 'a+'mir>: crate::MiriEvalContextExt<'a,\n         kind: RefKind,\n         new_tag: Tag,\n         protect: bool,\n-    ) -> EvalResult<'tcx> {\n+    ) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n         let protector = if protect { Some(this.frame().extra) } else { None };\n         let ptr = place.ptr.to_ptr()?;\n@@ -572,7 +572,7 @@ trait EvalContextPrivExt<'a, 'mir, 'tcx: 'a+'mir>: crate::MiriEvalContextExt<'a,\n         val: ImmTy<'tcx, Tag>,\n         kind: RefKind,\n         protect: bool,\n-    ) -> EvalResult<'tcx, Immediate<Tag>> {\n+    ) -> InterpResult<'tcx, Immediate<Tag>> {\n         let this = self.eval_context_mut();\n         // We want a place for where the ptr *points to*, so we get one.\n         let place = this.ref_to_mplace(val)?;\n@@ -605,7 +605,7 @@ pub trait EvalContextExt<'a, 'mir, 'tcx: 'a+'mir>: crate::MiriEvalContextExt<'a,\n         &mut self,\n         kind: RetagKind,\n         place: PlaceTy<'tcx, Tag>\n-    ) -> EvalResult<'tcx> {\n+    ) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n         // Determine mutability and whether to add a protector.\n         // Cannot use `builtin_deref` because that reports *immutable* for `Box`,\n@@ -660,7 +660,7 @@ pub trait EvalContextExt<'a, 'mir, 'tcx: 'a+'mir>: crate::MiriEvalContextExt<'a,\n             }\n \n             // Primitives of reference type, that is the one thing we are interested in.\n-            fn visit_primitive(&mut self, place: MPlaceTy<'tcx, Tag>) -> EvalResult<'tcx>\n+            fn visit_primitive(&mut self, place: MPlaceTy<'tcx, Tag>) -> InterpResult<'tcx>\n             {\n                 // Cannot use `builtin_deref` because that reports *immutable* for `Box`,\n                 // making it useless."}, {"sha": "b38b15c3e18e4e5f4042d35795dcba82765e4b30", "filename": "src/tls.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2448e9d9db656ac25e90d70f2bacee318d214025/src%2Ftls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2448e9d9db656ac25e90d70f2bacee318d214025/src%2Ftls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftls.rs?ref=2448e9d9db656ac25e90d70f2bacee318d214025", "patch": "@@ -4,7 +4,7 @@ use rustc_target::abi::LayoutOf;\n use rustc::{ty, ty::layout::HasDataLayout, mir};\n \n use crate::{\n-    EvalResult, InterpError, StackPopCleanup,\n+    InterpResult, InterpError, StackPopCleanup,\n     MPlaceTy, Scalar, Tag,\n };\n \n@@ -53,7 +53,7 @@ impl<'tcx> TlsData<'tcx> {\n         new_key\n     }\n \n-    pub fn delete_tls_key(&mut self, key: TlsKey) -> EvalResult<'tcx> {\n+    pub fn delete_tls_key(&mut self, key: TlsKey) -> InterpResult<'tcx> {\n         match self.keys.remove(&key) {\n             Some(_) => {\n                 trace!(\"TLS key {} removed\", key);\n@@ -63,7 +63,7 @@ impl<'tcx> TlsData<'tcx> {\n         }\n     }\n \n-    pub fn load_tls(&mut self, key: TlsKey) -> EvalResult<'tcx, Scalar<Tag>> {\n+    pub fn load_tls(&mut self, key: TlsKey) -> InterpResult<'tcx, Scalar<Tag>> {\n         match self.keys.get(&key) {\n             Some(&TlsEntry { data, .. }) => {\n                 trace!(\"TLS key {} loaded: {:?}\", key, data);\n@@ -73,7 +73,7 @@ impl<'tcx> TlsData<'tcx> {\n         }\n     }\n \n-    pub fn store_tls(&mut self, key: TlsKey, new_data: Scalar<Tag>) -> EvalResult<'tcx> {\n+    pub fn store_tls(&mut self, key: TlsKey, new_data: Scalar<Tag>) -> InterpResult<'tcx> {\n         match self.keys.get_mut(&key) {\n             Some(&mut TlsEntry { ref mut data, .. }) => {\n                 trace!(\"TLS key {} stored: {:?}\", key, new_data);\n@@ -131,7 +131,7 @@ impl<'tcx> TlsData<'tcx> {\n \n impl<'a, 'mir, 'tcx> EvalContextExt<'a, 'mir, 'tcx> for crate::MiriEvalContext<'a, 'mir, 'tcx> {}\n pub trait EvalContextExt<'a, 'mir, 'tcx: 'a+'mir>: crate::MiriEvalContextExt<'a, 'mir, 'tcx> {\n-    fn run_tls_dtors(&mut self) -> EvalResult<'tcx> {\n+    fn run_tls_dtors(&mut self) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n         let mut dtor = this.machine.tls.fetch_tls_dtor(None, &*this.tcx);\n         // FIXME: replace loop by some structure that works with stepping"}]}