{"sha": "c636c6a55b92daef5af4e1c459c0eaf3f5787945", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM2MzZjNmE1NWI5MmRhZWY1YWY0ZTFjNDU5YzBlYWYzZjU3ODc5NDU=", "commit": {"author": {"name": "Krishna Veera Reddy", "email": "veerareddy@email.arizona.edu", "date": "2019-12-14T17:28:11Z"}, "committer": {"name": "Krishna Sai Veera Reddy", "email": "veerareddy@email.arizona.edu", "date": "2020-02-24T06:20:33Z"}, "message": "Add lints to detect inaccurate and inefficient FP operations\n\nAdd lints to detect floating point computations that are either\ninaccurate or inefficient and suggest better alternatives.", "tree": {"sha": "5867860d9ef834770f3dc3f62c22661f003c0e58", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5867860d9ef834770f3dc3f62c22661f003c0e58"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c636c6a55b92daef5af4e1c459c0eaf3f5787945", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c636c6a55b92daef5af4e1c459c0eaf3f5787945", "html_url": "https://github.com/rust-lang/rust/commit/c636c6a55b92daef5af4e1c459c0eaf3f5787945", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c636c6a55b92daef5af4e1c459c0eaf3f5787945/comments", "author": {"login": "krishna-veerareddy", "id": 41484652, "node_id": "MDQ6VXNlcjQxNDg0NjUy", "avatar_url": "https://avatars.githubusercontent.com/u/41484652?v=4", "gravatar_id": "", "url": "https://api.github.com/users/krishna-veerareddy", "html_url": "https://github.com/krishna-veerareddy", "followers_url": "https://api.github.com/users/krishna-veerareddy/followers", "following_url": "https://api.github.com/users/krishna-veerareddy/following{/other_user}", "gists_url": "https://api.github.com/users/krishna-veerareddy/gists{/gist_id}", "starred_url": "https://api.github.com/users/krishna-veerareddy/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/krishna-veerareddy/subscriptions", "organizations_url": "https://api.github.com/users/krishna-veerareddy/orgs", "repos_url": "https://api.github.com/users/krishna-veerareddy/repos", "events_url": "https://api.github.com/users/krishna-veerareddy/events{/privacy}", "received_events_url": "https://api.github.com/users/krishna-veerareddy/received_events", "type": "User", "site_admin": false}, "committer": {"login": "krishna-veerareddy", "id": 41484652, "node_id": "MDQ6VXNlcjQxNDg0NjUy", "avatar_url": "https://avatars.githubusercontent.com/u/41484652?v=4", "gravatar_id": "", "url": "https://api.github.com/users/krishna-veerareddy", "html_url": "https://github.com/krishna-veerareddy", "followers_url": "https://api.github.com/users/krishna-veerareddy/followers", "following_url": "https://api.github.com/users/krishna-veerareddy/following{/other_user}", "gists_url": "https://api.github.com/users/krishna-veerareddy/gists{/gist_id}", "starred_url": "https://api.github.com/users/krishna-veerareddy/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/krishna-veerareddy/subscriptions", "organizations_url": "https://api.github.com/users/krishna-veerareddy/orgs", "repos_url": "https://api.github.com/users/krishna-veerareddy/repos", "events_url": "https://api.github.com/users/krishna-veerareddy/events{/privacy}", "received_events_url": "https://api.github.com/users/krishna-veerareddy/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fc5d0cc583cb1cd35d58fdb7f3e0cfa12dccd6c0", "url": "https://api.github.com/repos/rust-lang/rust/commits/fc5d0cc583cb1cd35d58fdb7f3e0cfa12dccd6c0", "html_url": "https://github.com/rust-lang/rust/commit/fc5d0cc583cb1cd35d58fdb7f3e0cfa12dccd6c0"}], "stats": {"total": 489, "additions": 489, "deletions": 0}, "files": [{"sha": "55e46bf6d20e67f65889c36ad9e4f44b340aedde", "filename": "CHANGELOG.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c636c6a55b92daef5af4e1c459c0eaf3f5787945/CHANGELOG.md", "raw_url": "https://github.com/rust-lang/rust/raw/c636c6a55b92daef5af4e1c459c0eaf3f5787945/CHANGELOG.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CHANGELOG.md?ref=c636c6a55b92daef5af4e1c459c0eaf3f5787945", "patch": "@@ -1169,6 +1169,7 @@ Released 2018-09-13\n [`ifs_same_cond`]: https://rust-lang.github.io/rust-clippy/master/index.html#ifs_same_cond\n [`implicit_hasher`]: https://rust-lang.github.io/rust-clippy/master/index.html#implicit_hasher\n [`implicit_return`]: https://rust-lang.github.io/rust-clippy/master/index.html#implicit_return\n+[`inaccurate_floating_point_computation`]: https://rust-lang.github.io/rust-clippy/master/index.html#inaccurate_floating_point_computation\n [`inconsistent_digit_grouping`]: https://rust-lang.github.io/rust-clippy/master/index.html#inconsistent_digit_grouping\n [`indexing_slicing`]: https://rust-lang.github.io/rust-clippy/master/index.html#indexing_slicing\n [`ineffective_bit_mask`]: https://rust-lang.github.io/rust-clippy/master/index.html#ineffective_bit_mask"}, {"sha": "935d8b5814662a99a28eb0dc9fb3bdaabc4a4732", "filename": "clippy_lints/src/floating_point_arithmetic.rs", "status": "added", "additions": 228, "deletions": 0, "changes": 228, "blob_url": "https://github.com/rust-lang/rust/blob/c636c6a55b92daef5af4e1c459c0eaf3f5787945/clippy_lints%2Fsrc%2Ffloating_point_arithmetic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c636c6a55b92daef5af4e1c459c0eaf3f5787945/clippy_lints%2Fsrc%2Ffloating_point_arithmetic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffloating_point_arithmetic.rs?ref=c636c6a55b92daef5af4e1c459c0eaf3f5787945", "patch": "@@ -0,0 +1,228 @@\n+use crate::consts::{\n+    constant,\n+    Constant::{F32, F64},\n+};\n+use crate::utils::*;\n+use if_chain::if_chain;\n+use rustc::declare_lint_pass;\n+use rustc::hir::*;\n+use rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n+use rustc_errors::Applicability;\n+use rustc_session::declare_tool_lint;\n+use std::f32::consts as f32_consts;\n+use std::f64::consts as f64_consts;\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Looks for numerically unstable floating point\n+    /// computations and suggests better alternatives.\n+    ///\n+    /// **Why is this bad?** Numerically unstable floating point computations\n+    /// cause rounding errors to magnify and distorts the results strongly.\n+    ///\n+    /// **Known problems:** None\n+    ///\n+    /// **Example:**\n+    ///\n+    /// ```rust\n+    /// use std::f32::consts::E;\n+    ///\n+    /// let a = 1f32.log(2.0);\n+    /// let b = 1f32.log(10.0);\n+    /// let c = 1f32.log(E);\n+    /// ```\n+    ///\n+    /// is better expressed as\n+    ///\n+    /// ```rust\n+    /// let a = 1f32.log2();\n+    /// let b = 1f32.log10();\n+    /// let c = 1f32.ln();\n+    /// ```\n+    pub INACCURATE_FLOATING_POINT_COMPUTATION,\n+    nursery,\n+    \"checks for numerically unstable floating point computations\"\n+}\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Looks for inefficient floating point computations\n+    /// and suggests faster alternatives.\n+    ///\n+    /// **Why is this bad?** Lower performance.\n+    ///\n+    /// **Known problems:** None\n+    ///\n+    /// **Example:**\n+    ///\n+    /// ```rust\n+    /// use std::f32::consts::E;\n+    ///\n+    /// let a = (2f32).powf(3.0);\n+    /// let c = E.powf(3.0);\n+    /// ```\n+    ///\n+    /// is better expressed as\n+    ///\n+    /// ```rust\n+    /// let a = (3f32).exp2();\n+    /// let b = (3f32).exp();\n+    /// ```\n+    pub SLOW_FLOATING_POINT_COMPUTATION,\n+    nursery,\n+    \"checks for inefficient floating point computations\"\n+}\n+\n+declare_lint_pass!(FloatingPointArithmetic => [\n+    INACCURATE_FLOATING_POINT_COMPUTATION,\n+    SLOW_FLOATING_POINT_COMPUTATION\n+]);\n+\n+fn check_log_base(cx: &LateContext<'_, '_>, expr: &Expr, args: &HirVec<Expr>) {\n+    let recv = &args[0];\n+    let arg = sugg::Sugg::hir(cx, recv, \"..\").maybe_par();\n+\n+    if let Some((value, _)) = constant(cx, cx.tables, &args[1]) {\n+        let method;\n+\n+        if F32(2.0) == value || F64(2.0) == value {\n+            method = \"log2\";\n+        } else if F32(10.0) == value || F64(10.0) == value {\n+            method = \"log10\";\n+        } else if F32(f32_consts::E) == value || F64(f64_consts::E) == value {\n+            method = \"ln\";\n+        } else {\n+            return;\n+        }\n+\n+        span_lint_and_sugg(\n+            cx,\n+            INACCURATE_FLOATING_POINT_COMPUTATION,\n+            expr.span,\n+            \"logarithm for bases 2, 10 and e can be computed more accurately\",\n+            \"consider using\",\n+            format!(\"{}.{}()\", arg, method),\n+            Applicability::MachineApplicable,\n+        );\n+    }\n+}\n+\n+// TODO: Lint expressions of the form `(x + 1).ln()` and `(x + y).ln()`\n+// where y > 1 and suggest usage of `(x + (y - 1)).ln_1p()` instead\n+fn check_ln1p(cx: &LateContext<'_, '_>, expr: &Expr, args: &HirVec<Expr>) {\n+    if_chain! {\n+        if let ExprKind::Binary(op, ref lhs, ref rhs) = &args[0].kind;\n+        if op.node == BinOpKind::Add;\n+        if let Some((value, _)) = constant(cx, cx.tables, lhs);\n+        if F32(1.0) == value || F64(1.0) == value;\n+        then {\n+            let arg = sugg::Sugg::hir(cx, rhs, \"..\").maybe_par();\n+\n+            span_lint_and_sugg(\n+                cx,\n+                INACCURATE_FLOATING_POINT_COMPUTATION,\n+                expr.span,\n+                \"ln(1 + x) can be computed more accurately\",\n+                \"consider using\",\n+                format!(\"{}.ln_1p()\", arg),\n+                Applicability::MachineApplicable,\n+            );\n+        }\n+    }\n+}\n+\n+fn check_powf(cx: &LateContext<'_, '_>, expr: &Expr, args: &HirVec<Expr>) {\n+    // Check receiver\n+    if let Some((value, _)) = constant(cx, cx.tables, &args[0]) {\n+        let method;\n+\n+        if F32(f32_consts::E) == value || F64(f64_consts::E) == value {\n+            method = \"exp\";\n+        } else if F32(2.0) == value || F64(2.0) == value {\n+            method = \"exp2\";\n+        } else {\n+            return;\n+        }\n+\n+        span_lint_and_sugg(\n+            cx,\n+            SLOW_FLOATING_POINT_COMPUTATION,\n+            expr.span,\n+            \"exponent for bases 2 and e can be computed more efficiently\",\n+            \"consider using\",\n+            format!(\"{}.{}()\", sugg::Sugg::hir(cx, &args[1], \"..\").maybe_par(), method),\n+            Applicability::MachineApplicable,\n+        );\n+    }\n+\n+    // Check argument\n+    if let Some((value, _)) = constant(cx, cx.tables, &args[1]) {\n+        let help;\n+        let method;\n+\n+        if F32(1.0 / 2.0) == value || F64(1.0 / 2.0) == value {\n+            help = \"square-root of a number can be computer more efficiently\";\n+            method = \"sqrt\";\n+        } else if F32(1.0 / 3.0) == value || F64(1.0 / 3.0) == value {\n+            help = \"cube-root of a number can be computer more efficiently\";\n+            method = \"cbrt\";\n+        } else {\n+            return;\n+        }\n+\n+        span_lint_and_sugg(\n+            cx,\n+            SLOW_FLOATING_POINT_COMPUTATION,\n+            expr.span,\n+            help,\n+            \"consider using\",\n+            format!(\"{}.{}()\", sugg::Sugg::hir(cx, &args[0], \"..\"), method),\n+            Applicability::MachineApplicable,\n+        );\n+    }\n+}\n+\n+// TODO: Lint expressions of the form `x.exp() - y` where y > 1\n+// and suggest usage of `x.exp_m1() - (y - 1)` instead\n+fn check_expm1(cx: &LateContext<'_, '_>, expr: &Expr) {\n+    if_chain! {\n+        if let ExprKind::Binary(op, ref lhs, ref rhs) = expr.kind;\n+        if op.node == BinOpKind::Sub;\n+        if cx.tables.expr_ty(lhs).is_floating_point();\n+        if let Some((value, _)) = constant(cx, cx.tables, rhs);\n+        if F32(1.0) == value || F64(1.0) == value;\n+        if let ExprKind::MethodCall(ref path, _, ref method_args) = lhs.kind;\n+        if path.ident.name.as_str() == \"exp\";\n+        then {\n+            span_lint_and_sugg(\n+                cx,\n+                INACCURATE_FLOATING_POINT_COMPUTATION,\n+                expr.span,\n+                \"(e.pow(x) - 1) can be computed more accurately\",\n+                \"consider using\",\n+                format!(\n+                    \"{}.exp_m1()\",\n+                    sugg::Sugg::hir(cx, &method_args[0], \"..\")\n+                ),\n+                Applicability::MachineApplicable,\n+            );\n+        }\n+    }\n+}\n+\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for FloatingPointArithmetic {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n+        if let ExprKind::MethodCall(ref path, _, args) = &expr.kind {\n+            let recv_ty = cx.tables.expr_ty(&args[0]);\n+\n+            if recv_ty.is_floating_point() {\n+                match &*path.ident.name.as_str() {\n+                    \"ln\" => check_ln1p(cx, expr, args),\n+                    \"log\" => check_log_base(cx, expr, args),\n+                    \"powf\" => check_powf(cx, expr, args),\n+                    _ => {},\n+                }\n+            }\n+        } else {\n+            check_expm1(cx, expr);\n+        }\n+    }\n+}"}, {"sha": "9a904141fcf43f52da3ed1260192b66ab2bbb005", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c636c6a55b92daef5af4e1c459c0eaf3f5787945/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c636c6a55b92daef5af4e1c459c0eaf3f5787945/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=c636c6a55b92daef5af4e1c459c0eaf3f5787945", "patch": "@@ -1000,6 +1000,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(|| box to_digit_is_some::ToDigitIsSome);\n     let array_size_threshold = conf.array_size_threshold;\n     store.register_late_pass(move || box large_stack_arrays::LargeStackArrays::new(array_size_threshold));\n+    store.register_late_pass(move || box floating_point_arithmetic::FloatingPointArithmetic);\n     store.register_early_pass(|| box as_conversions::AsConversions);\n     store.register_early_pass(|| box utils::internal_lints::ProduceIce);\n     store.register_late_pass(|| box let_underscore::LetUnderscore);\n@@ -1648,6 +1649,8 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_group(true, \"clippy::nursery\", Some(\"clippy_nursery\"), vec![\n         LintId::of(&attrs::EMPTY_LINE_AFTER_OUTER_ATTR),\n         LintId::of(&fallible_impl_from::FALLIBLE_IMPL_FROM),\n+        LintId::of(&floating_point_arithmetic::INACCURATE_FLOATING_POINT_COMPUTATION),\n+        LintId::of(&floating_point_arithmetic::SLOW_FLOATING_POINT_COMPUTATION),\n         LintId::of(&missing_const_for_fn::MISSING_CONST_FOR_FN),\n         LintId::of(&mul_add::MANUAL_MUL_ADD),\n         LintId::of(&mutable_debug_assertion::DEBUG_ASSERT_WITH_MUT_CALL),"}, {"sha": "fee595074547cc35fde6349181e7dd8fe0ad4b4e", "filename": "src/lintlist/mod.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c636c6a55b92daef5af4e1c459c0eaf3f5787945/src%2Flintlist%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c636c6a55b92daef5af4e1c459c0eaf3f5787945/src%2Flintlist%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flintlist%2Fmod.rs?ref=c636c6a55b92daef5af4e1c459c0eaf3f5787945", "patch": "@@ -749,6 +749,13 @@ pub const ALL_LINTS: [Lint; 357] = [\n         deprecation: None,\n         module: \"implicit_return\",\n     },\n+    Lint {\n+        name: \"inaccurate_floating_point_computation\",\n+        group: \"nursery\",\n+        desc: \"checks for numerically unstable floating point computations\",\n+        deprecation: None,\n+        module: \"floating_point_arithmetic\",\n+    },\n     Lint {\n         name: \"inconsistent_digit_grouping\",\n         group: \"style\","}, {"sha": "5291e5cf0226dcf95aaa54724032268a2adb8fa9", "filename": "tests/ui/floating_point_arithmetic.rs", "status": "added", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/c636c6a55b92daef5af4e1c459c0eaf3f5787945/tests%2Fui%2Ffloating_point_arithmetic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c636c6a55b92daef5af4e1c459c0eaf3f5787945/tests%2Fui%2Ffloating_point_arithmetic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffloating_point_arithmetic.rs?ref=c636c6a55b92daef5af4e1c459c0eaf3f5787945", "patch": "@@ -0,0 +1,76 @@\n+#![allow(dead_code)]\n+#![warn(\n+    clippy::inaccurate_floating_point_computation,\n+    clippy::slow_floating_point_computation\n+)]\n+\n+const TWO: f32 = 2.0;\n+const E: f32 = std::f32::consts::E;\n+\n+fn check_log_base() {\n+    let x = 1f32;\n+    let _ = x.log(2f32);\n+    let _ = x.log(10f32);\n+    let _ = x.log(std::f32::consts::E);\n+    let _ = x.log(TWO);\n+    let _ = x.log(E);\n+\n+    let x = 1f64;\n+    let _ = x.log(2f64);\n+    let _ = x.log(10f64);\n+    let _ = x.log(std::f64::consts::E);\n+}\n+\n+fn check_ln1p() {\n+    let x = 1f32;\n+    let _ = (1.0 + x).ln();\n+    let _ = (1.0 + x * 2.0).ln();\n+    let _ = (1.0 + x.powi(2)).ln();\n+    let _ = (1.0 + x.powi(2) * 2.0).ln();\n+    let _ = (1.0 + (std::f32::consts::E - 1.0)).ln();\n+    // Cases where the lint shouldn't be applied\n+    let _ = (x + 1.0).ln();\n+    let _ = (1.0 + x + 2.0).ln();\n+    let _ = (1.0 + x - 2.0).ln();\n+\n+    let x = 1f64;\n+    let _ = (1.0 + x).ln();\n+    let _ = (1.0 + x * 2.0).ln();\n+    let _ = (1.0 + x.powi(2)).ln();\n+    // Cases where the lint shouldn't be applied\n+    let _ = (x + 1.0).ln();\n+    let _ = (1.0 + x + 2.0).ln();\n+    let _ = (1.0 + x - 2.0).ln();\n+}\n+\n+fn check_powf() {\n+    let x = 3f32;\n+    let _ = 2f32.powf(x);\n+    let _ = std::f32::consts::E.powf(x);\n+    let _ = x.powf(1.0 / 2.0);\n+    let _ = x.powf(1.0 / 3.0);\n+\n+    let x = 3f64;\n+    let _ = 2f64.powf(x);\n+    let _ = std::f64::consts::E.powf(x);\n+    let _ = x.powf(1.0 / 2.0);\n+    let _ = x.powf(1.0 / 3.0);\n+}\n+\n+fn check_expm1() {\n+    let x = 2f32;\n+    let _ = x.exp() - 1.0;\n+    let _ = x.exp() - 1.0 + 2.0;\n+    // Cases where the lint shouldn't be applied\n+    let _ = x.exp() - 2.0;\n+    let _ = x.exp() - 1.0 * 2.0;\n+\n+    let x = 2f64;\n+    let _ = x.exp() - 1.0;\n+    let _ = x.exp() - 1.0 + 2.0;\n+    // Cases where the lint shouldn't be applied\n+    let _ = x.exp() - 2.0;\n+    let _ = x.exp() - 1.0 * 2.0;\n+}\n+\n+fn main() {}"}, {"sha": "a0663e488354208b7ff5238f8e8e3d0d7bfbfec3", "filename": "tests/ui/floating_point_arithmetic.stderr", "status": "added", "additions": 174, "deletions": 0, "changes": 174, "blob_url": "https://github.com/rust-lang/rust/blob/c636c6a55b92daef5af4e1c459c0eaf3f5787945/tests%2Fui%2Ffloating_point_arithmetic.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c636c6a55b92daef5af4e1c459c0eaf3f5787945/tests%2Fui%2Ffloating_point_arithmetic.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffloating_point_arithmetic.stderr?ref=c636c6a55b92daef5af4e1c459c0eaf3f5787945", "patch": "@@ -0,0 +1,174 @@\n+error: logarithm for bases 2, 10 and e can be computed more accurately\n+  --> $DIR/floating_point_arithmetic.rs:12:13\n+   |\n+LL |     let _ = x.log(2f32);\n+   |             ^^^^^^^^^^^ help: consider using: `x.log2()`\n+   |\n+   = note: `-D clippy::inaccurate-floating-point-computation` implied by `-D warnings`\n+\n+error: logarithm for bases 2, 10 and e can be computed more accurately\n+  --> $DIR/floating_point_arithmetic.rs:13:13\n+   |\n+LL |     let _ = x.log(10f32);\n+   |             ^^^^^^^^^^^^ help: consider using: `x.log10()`\n+\n+error: logarithm for bases 2, 10 and e can be computed more accurately\n+  --> $DIR/floating_point_arithmetic.rs:14:13\n+   |\n+LL |     let _ = x.log(std::f32::consts::E);\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using: `x.ln()`\n+\n+error: logarithm for bases 2, 10 and e can be computed more accurately\n+  --> $DIR/floating_point_arithmetic.rs:15:13\n+   |\n+LL |     let _ = x.log(TWO);\n+   |             ^^^^^^^^^^ help: consider using: `x.log2()`\n+\n+error: logarithm for bases 2, 10 and e can be computed more accurately\n+  --> $DIR/floating_point_arithmetic.rs:16:13\n+   |\n+LL |     let _ = x.log(E);\n+   |             ^^^^^^^^ help: consider using: `x.ln()`\n+\n+error: logarithm for bases 2, 10 and e can be computed more accurately\n+  --> $DIR/floating_point_arithmetic.rs:19:13\n+   |\n+LL |     let _ = x.log(2f64);\n+   |             ^^^^^^^^^^^ help: consider using: `x.log2()`\n+\n+error: logarithm for bases 2, 10 and e can be computed more accurately\n+  --> $DIR/floating_point_arithmetic.rs:20:13\n+   |\n+LL |     let _ = x.log(10f64);\n+   |             ^^^^^^^^^^^^ help: consider using: `x.log10()`\n+\n+error: logarithm for bases 2, 10 and e can be computed more accurately\n+  --> $DIR/floating_point_arithmetic.rs:21:13\n+   |\n+LL |     let _ = x.log(std::f64::consts::E);\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using: `x.ln()`\n+\n+error: ln(1 + x) can be computed more accurately\n+  --> $DIR/floating_point_arithmetic.rs:26:13\n+   |\n+LL |     let _ = (1.0 + x).ln();\n+   |             ^^^^^^^^^^^^^^ help: consider using: `x.ln_1p()`\n+\n+error: ln(1 + x) can be computed more accurately\n+  --> $DIR/floating_point_arithmetic.rs:27:13\n+   |\n+LL |     let _ = (1.0 + x * 2.0).ln();\n+   |             ^^^^^^^^^^^^^^^^^^^^ help: consider using: `(x * 2.0).ln_1p()`\n+\n+error: ln(1 + x) can be computed more accurately\n+  --> $DIR/floating_point_arithmetic.rs:28:13\n+   |\n+LL |     let _ = (1.0 + x.powi(2)).ln();\n+   |             ^^^^^^^^^^^^^^^^^^^^^^ help: consider using: `x.powi(2).ln_1p()`\n+\n+error: ln(1 + x) can be computed more accurately\n+  --> $DIR/floating_point_arithmetic.rs:29:13\n+   |\n+LL |     let _ = (1.0 + x.powi(2) * 2.0).ln();\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using: `(x.powi(2) * 2.0).ln_1p()`\n+\n+error: ln(1 + x) can be computed more accurately\n+  --> $DIR/floating_point_arithmetic.rs:30:13\n+   |\n+LL |     let _ = (1.0 + (std::f32::consts::E - 1.0)).ln();\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using: `((std::f32::consts::E - 1.0)).ln_1p()`\n+\n+error: ln(1 + x) can be computed more accurately\n+  --> $DIR/floating_point_arithmetic.rs:37:13\n+   |\n+LL |     let _ = (1.0 + x).ln();\n+   |             ^^^^^^^^^^^^^^ help: consider using: `x.ln_1p()`\n+\n+error: ln(1 + x) can be computed more accurately\n+  --> $DIR/floating_point_arithmetic.rs:38:13\n+   |\n+LL |     let _ = (1.0 + x * 2.0).ln();\n+   |             ^^^^^^^^^^^^^^^^^^^^ help: consider using: `(x * 2.0).ln_1p()`\n+\n+error: ln(1 + x) can be computed more accurately\n+  --> $DIR/floating_point_arithmetic.rs:39:13\n+   |\n+LL |     let _ = (1.0 + x.powi(2)).ln();\n+   |             ^^^^^^^^^^^^^^^^^^^^^^ help: consider using: `x.powi(2).ln_1p()`\n+\n+error: exponent for bases 2 and e can be computed more efficiently\n+  --> $DIR/floating_point_arithmetic.rs:48:13\n+   |\n+LL |     let _ = 2f32.powf(x);\n+   |             ^^^^^^^^^^^^ help: consider using: `x.exp2()`\n+   |\n+   = note: `-D clippy::slow-floating-point-computation` implied by `-D warnings`\n+\n+error: exponent for bases 2 and e can be computed more efficiently\n+  --> $DIR/floating_point_arithmetic.rs:49:13\n+   |\n+LL |     let _ = std::f32::consts::E.powf(x);\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using: `x.exp()`\n+\n+error: square-root of a number can be computer more efficiently\n+  --> $DIR/floating_point_arithmetic.rs:50:13\n+   |\n+LL |     let _ = x.powf(1.0 / 2.0);\n+   |             ^^^^^^^^^^^^^^^^^ help: consider using: `x.sqrt()`\n+\n+error: cube-root of a number can be computer more efficiently\n+  --> $DIR/floating_point_arithmetic.rs:51:13\n+   |\n+LL |     let _ = x.powf(1.0 / 3.0);\n+   |             ^^^^^^^^^^^^^^^^^ help: consider using: `x.cbrt()`\n+\n+error: exponent for bases 2 and e can be computed more efficiently\n+  --> $DIR/floating_point_arithmetic.rs:54:13\n+   |\n+LL |     let _ = 2f64.powf(x);\n+   |             ^^^^^^^^^^^^ help: consider using: `x.exp2()`\n+\n+error: exponent for bases 2 and e can be computed more efficiently\n+  --> $DIR/floating_point_arithmetic.rs:55:13\n+   |\n+LL |     let _ = std::f64::consts::E.powf(x);\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using: `x.exp()`\n+\n+error: square-root of a number can be computer more efficiently\n+  --> $DIR/floating_point_arithmetic.rs:56:13\n+   |\n+LL |     let _ = x.powf(1.0 / 2.0);\n+   |             ^^^^^^^^^^^^^^^^^ help: consider using: `x.sqrt()`\n+\n+error: cube-root of a number can be computer more efficiently\n+  --> $DIR/floating_point_arithmetic.rs:57:13\n+   |\n+LL |     let _ = x.powf(1.0 / 3.0);\n+   |             ^^^^^^^^^^^^^^^^^ help: consider using: `x.cbrt()`\n+\n+error: (e.pow(x) - 1) can be computed more accurately\n+  --> $DIR/floating_point_arithmetic.rs:62:13\n+   |\n+LL |     let _ = x.exp() - 1.0;\n+   |             ^^^^^^^^^^^^^ help: consider using: `x.exp_m1()`\n+\n+error: (e.pow(x) - 1) can be computed more accurately\n+  --> $DIR/floating_point_arithmetic.rs:63:13\n+   |\n+LL |     let _ = x.exp() - 1.0 + 2.0;\n+   |             ^^^^^^^^^^^^^ help: consider using: `x.exp_m1()`\n+\n+error: (e.pow(x) - 1) can be computed more accurately\n+  --> $DIR/floating_point_arithmetic.rs:69:13\n+   |\n+LL |     let _ = x.exp() - 1.0;\n+   |             ^^^^^^^^^^^^^ help: consider using: `x.exp_m1()`\n+\n+error: (e.pow(x) - 1) can be computed more accurately\n+  --> $DIR/floating_point_arithmetic.rs:70:13\n+   |\n+LL |     let _ = x.exp() - 1.0 + 2.0;\n+   |             ^^^^^^^^^^^^^ help: consider using: `x.exp_m1()`\n+\n+error: aborting due to 28 previous errors\n+"}]}