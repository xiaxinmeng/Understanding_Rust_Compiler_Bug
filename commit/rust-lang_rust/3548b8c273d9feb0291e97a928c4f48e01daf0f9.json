{"sha": "3548b8c273d9feb0291e97a928c4f48e01daf0f9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM1NDhiOGMyNzNkOWZlYjAyOTFlOTdhOTI4YzRmNDhlMDFkYWYwZjk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-02-13T00:16:03Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-02-13T00:16:03Z"}, "message": "Auto merge of #31524 - jonas-schievink:autoderef, r=steveklabnik", "tree": {"sha": "8dba43a020e65c4378b431fbf31e227dfdce3f3f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8dba43a020e65c4378b431fbf31e227dfdce3f3f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3548b8c273d9feb0291e97a928c4f48e01daf0f9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3548b8c273d9feb0291e97a928c4f48e01daf0f9", "html_url": "https://github.com/rust-lang/rust/commit/3548b8c273d9feb0291e97a928c4f48e01daf0f9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3548b8c273d9feb0291e97a928c4f48e01daf0f9/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ce4b75f25662cb9facafc4bef368410a2979b936", "url": "https://api.github.com/repos/rust-lang/rust/commits/ce4b75f25662cb9facafc4bef368410a2979b936", "html_url": "https://github.com/rust-lang/rust/commit/ce4b75f25662cb9facafc4bef368410a2979b936"}, {"sha": "559fca0fd306dc1048cc66ca86f8c6fc89f9a055", "url": "https://api.github.com/repos/rust-lang/rust/commits/559fca0fd306dc1048cc66ca86f8c6fc89f9a055", "html_url": "https://github.com/rust-lang/rust/commit/559fca0fd306dc1048cc66ca86f8c6fc89f9a055"}], "stats": {"total": 2414, "additions": 1206, "deletions": 1208}, "files": [{"sha": "752b625f529c084ce3aa077a32bc92b5e1f693a8", "filename": "src/librustc/front/map/blocks.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3548b8c273d9feb0291e97a928c4f48e01daf0f9/src%2Flibrustc%2Ffront%2Fmap%2Fblocks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3548b8c273d9feb0291e97a928c4f48e01daf0f9/src%2Flibrustc%2Ffront%2Fmap%2Fblocks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fmap%2Fblocks.rs?ref=3548b8c273d9feb0291e97a928c4f48e01daf0f9", "patch": "@@ -217,9 +217,9 @@ impl<'a> FnLikeNode<'a> {\n                     item_fn(ItemFnParts {\n                         id: i.id,\n                         name: i.name,\n-                        decl: &**decl,\n+                        decl: &decl,\n                         unsafety: unsafety,\n-                        body: &**block,\n+                        body: &block,\n                         generics: generics,\n                         abi: abi,\n                         vis: i.vis,\n@@ -246,7 +246,7 @@ impl<'a> FnLikeNode<'a> {\n             }\n             map::NodeExpr(e) => match e.node {\n                 ast::ExprClosure(_, ref decl, ref block) =>\n-                    closure(ClosureParts::new(&**decl, &**block, e.id, e.span)),\n+                    closure(ClosureParts::new(&decl, &block, e.id, e.span)),\n                 _ => panic!(\"expr FnLikeNode that is not fn-like\"),\n             },\n             _ => panic!(\"other FnLikeNode that is not fn-like\"),"}, {"sha": "310e341749381e9e7eb4485a274c61067548b245", "filename": "src/librustc/front/map/mod.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/3548b8c273d9feb0291e97a928c4f48e01daf0f9/src%2Flibrustc%2Ffront%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3548b8c273d9feb0291e97a928c4f48e01daf0f9/src%2Flibrustc%2Ffront%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fmap%2Fmod.rs?ref=3548b8c273d9feb0291e97a928c4f48e01daf0f9", "patch": "@@ -795,7 +795,7 @@ impl<'a, 'ast> NodesMatchingSuffix<'a, 'ast> {\n             loop {\n                 match map.find(id) {\n                     None => return None,\n-                    Some(NodeItem(item)) if item_is_mod(&*item) =>\n+                    Some(NodeItem(item)) if item_is_mod(&item) =>\n                         return Some((id, item.name)),\n                     _ => {}\n                 }\n@@ -967,16 +967,16 @@ pub trait NodePrinter {\n impl<'a> NodePrinter for pprust::State<'a> {\n     fn print_node(&mut self, node: &Node) -> io::Result<()> {\n         match *node {\n-            NodeItem(a)        => self.print_item(&*a),\n-            NodeForeignItem(a) => self.print_foreign_item(&*a),\n+            NodeItem(a)        => self.print_item(&a),\n+            NodeForeignItem(a) => self.print_foreign_item(&a),\n             NodeTraitItem(a)   => self.print_trait_item(a),\n             NodeImplItem(a)    => self.print_impl_item(a),\n-            NodeVariant(a)     => self.print_variant(&*a),\n-            NodeExpr(a)        => self.print_expr(&*a),\n-            NodeStmt(a)        => self.print_stmt(&*a),\n-            NodePat(a)         => self.print_pat(&*a),\n-            NodeBlock(a)       => self.print_block(&*a),\n-            NodeLifetime(a)    => self.print_lifetime(&*a),\n+            NodeVariant(a)     => self.print_variant(&a),\n+            NodeExpr(a)        => self.print_expr(&a),\n+            NodeStmt(a)        => self.print_stmt(&a),\n+            NodePat(a)         => self.print_pat(&a),\n+            NodeBlock(a)       => self.print_block(&a),\n+            NodeLifetime(a)    => self.print_lifetime(&a),\n             NodeTyParam(_)     => panic!(\"cannot print TyParam\"),\n             // these cases do not carry enough information in the\n             // ast_map to reconstruct their full structure for pretty\n@@ -1055,26 +1055,26 @@ fn node_id_to_string(map: &Map, id: NodeId, include_id: bool) -> String {\n                     map.path_to_string(id), id_str)\n         }\n         Some(NodeExpr(ref expr)) => {\n-            format!(\"expr {}{}\", pprust::expr_to_string(&**expr), id_str)\n+            format!(\"expr {}{}\", pprust::expr_to_string(&expr), id_str)\n         }\n         Some(NodeStmt(ref stmt)) => {\n-            format!(\"stmt {}{}\", pprust::stmt_to_string(&**stmt), id_str)\n+            format!(\"stmt {}{}\", pprust::stmt_to_string(&stmt), id_str)\n         }\n         Some(NodeLocal(ref pat)) => {\n-            format!(\"local {}{}\", pprust::pat_to_string(&**pat), id_str)\n+            format!(\"local {}{}\", pprust::pat_to_string(&pat), id_str)\n         }\n         Some(NodePat(ref pat)) => {\n-            format!(\"pat {}{}\", pprust::pat_to_string(&**pat), id_str)\n+            format!(\"pat {}{}\", pprust::pat_to_string(&pat), id_str)\n         }\n         Some(NodeBlock(ref block)) => {\n-            format!(\"block {}{}\", pprust::block_to_string(&**block), id_str)\n+            format!(\"block {}{}\", pprust::block_to_string(&block), id_str)\n         }\n         Some(NodeStructCtor(_)) => {\n             format!(\"struct_ctor {}{}\", map.path_to_string(id), id_str)\n         }\n         Some(NodeLifetime(ref l)) => {\n             format!(\"lifetime {}{}\",\n-                    pprust::lifetime_to_string(&**l), id_str)\n+                    pprust::lifetime_to_string(&l), id_str)\n         }\n         Some(NodeTyParam(ref ty_param)) => {\n             format!(\"typaram {:?}{}\", ty_param, id_str)"}, {"sha": "6142f14db3ecce16a6bba1ad05ea33738b91b60d", "filename": "src/librustc/middle/cfg/construct.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/3548b8c273d9feb0291e97a928c4f48e01daf0f9/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3548b8c273d9feb0291e97a928c4f48e01daf0f9/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs?ref=3548b8c273d9feb0291e97a928c4f48e01daf0f9", "patch": "@@ -73,12 +73,12 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n     fn stmt(&mut self, stmt: &hir::Stmt, pred: CFGIndex) -> CFGIndex {\n         match stmt.node {\n             hir::StmtDecl(ref decl, id) => {\n-                let exit = self.decl(&**decl, pred);\n+                let exit = self.decl(&decl, pred);\n                 self.add_ast_node(id, &[exit])\n             }\n \n             hir::StmtExpr(ref expr, id) | hir::StmtSemi(ref expr, id) => {\n-                let exit = self.expr(&**expr, pred);\n+                let exit = self.expr(&expr, pred);\n                 self.add_ast_node(id, &[exit])\n             }\n         }\n@@ -88,7 +88,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n         match decl.node {\n             hir::DeclLocal(ref local) => {\n                 let init_exit = self.opt_expr(&local.init, pred);\n-                self.pat(&*local.pat, init_exit)\n+                self.pat(&local.pat, init_exit)\n             }\n \n             hir::DeclItem(_) => {\n@@ -111,7 +111,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n             hir::PatBox(ref subpat) |\n             hir::PatRegion(ref subpat, _) |\n             hir::PatIdent(_, _, Some(ref subpat)) => {\n-                let subpat_exit = self.pat(&**subpat, pred);\n+                let subpat_exit = self.pat(&subpat, pred);\n                 self.add_ast_node(pat.id, &[subpat_exit])\n             }\n \n@@ -140,13 +140,13 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n                                           pats: I,\n                                           pred: CFGIndex) -> CFGIndex {\n         //! Handles case where all of the patterns must match.\n-        pats.fold(pred, |pred, pat| self.pat(&**pat, pred))\n+        pats.fold(pred, |pred, pat| self.pat(&pat, pred))\n     }\n \n     fn expr(&mut self, expr: &hir::Expr, pred: CFGIndex) -> CFGIndex {\n         match expr.node {\n             hir::ExprBlock(ref blk) => {\n-                let blk_exit = self.block(&**blk, pred);\n+                let blk_exit = self.block(&blk, pred);\n                 self.add_ast_node(expr.id, &[blk_exit])\n             }\n \n@@ -165,8 +165,8 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n                 //    v 3   v 4\n                 //   [..expr..]\n                 //\n-                let cond_exit = self.expr(&**cond, pred);                // 1\n-                let then_exit = self.block(&**then, cond_exit);          // 2\n+                let cond_exit = self.expr(&cond, pred);                // 1\n+                let then_exit = self.block(&then, cond_exit);          // 2\n                 self.add_ast_node(expr.id, &[cond_exit, then_exit])      // 3,4\n             }\n \n@@ -185,9 +185,9 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n                 //    v 4   v 5\n                 //   [..expr..]\n                 //\n-                let cond_exit = self.expr(&**cond, pred);                // 1\n-                let then_exit = self.block(&**then, cond_exit);          // 2\n-                let else_exit = self.expr(&**otherwise, cond_exit);      // 3\n+                let cond_exit = self.expr(&cond, pred);                // 1\n+                let then_exit = self.block(&then, cond_exit);          // 2\n+                let else_exit = self.expr(&otherwise, cond_exit);      // 3\n                 self.add_ast_node(expr.id, &[then_exit, else_exit])      // 4, 5\n             }\n \n@@ -211,14 +211,14 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n \n                 // Is the condition considered part of the loop?\n                 let loopback = self.add_dummy_node(&[pred]);              // 1\n-                let cond_exit = self.expr(&**cond, loopback);             // 2\n+                let cond_exit = self.expr(&cond, loopback);             // 2\n                 let expr_exit = self.add_ast_node(expr.id, &[cond_exit]); // 3\n                 self.loop_scopes.push(LoopScope {\n                     loop_id: expr.id,\n                     continue_index: loopback,\n                     break_index: expr_exit\n                 });\n-                let body_exit = self.block(&**body, cond_exit);          // 4\n+                let body_exit = self.block(&body, cond_exit);          // 4\n                 self.add_contained_edge(body_exit, loopback);            // 5\n                 self.loop_scopes.pop();\n                 expr_exit\n@@ -246,7 +246,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n                     continue_index: loopback,\n                     break_index: expr_exit,\n                 });\n-                let body_exit = self.block(&**body, loopback);           // 3\n+                let body_exit = self.block(&body, loopback);           // 3\n                 self.add_contained_edge(body_exit, loopback);            // 4\n                 self.loop_scopes.pop();\n                 expr_exit\n@@ -271,8 +271,8 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n                 //    v 3  v 4\n                 //   [..exit..]\n                 //\n-                let l_exit = self.expr(&**l, pred);                      // 1\n-                let r_exit = self.expr(&**r, l_exit);                    // 2\n+                let l_exit = self.expr(&l, pred);                      // 1\n+                let r_exit = self.expr(&r, l_exit);                    // 2\n                 self.add_ast_node(expr.id, &[l_exit, r_exit])            // 3,4\n             }\n \n@@ -304,16 +304,16 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n             }\n \n             hir::ExprCall(ref func, ref args) => {\n-                self.call(expr, pred, &**func, args.iter().map(|e| &**e))\n+                self.call(expr, pred, &func, args.iter().map(|e| &**e))\n             }\n \n             hir::ExprMethodCall(_, _, ref args) => {\n-                self.call(expr, pred, &*args[0], args[1..].iter().map(|e| &**e))\n+                self.call(expr, pred, &args[0], args[1..].iter().map(|e| &**e))\n             }\n \n             hir::ExprIndex(ref l, ref r) |\n             hir::ExprBinary(_, ref l, ref r) if self.tcx.is_method_call(expr.id) => {\n-                self.call(expr, pred, &**l, Some(&**r).into_iter())\n+                self.call(expr, pred, &l, Some(&**r).into_iter())\n             }\n \n             hir::ExprRange(ref start, ref end) => {\n@@ -323,7 +323,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n             }\n \n             hir::ExprUnary(_, ref e) if self.tcx.is_method_call(expr.id) => {\n-                self.call(expr, pred, &**e, None::<hir::Expr>.iter())\n+                self.call(expr, pred, &e, None::<hir::Expr>.iter())\n             }\n \n             hir::ExprTup(ref exprs) => {\n@@ -413,7 +413,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n                 opt_expr: &Option<P<hir::Expr>>,\n                 pred: CFGIndex) -> CFGIndex {\n         //! Constructs graph for `opt_expr` evaluated, if Some\n-        opt_expr.iter().fold(pred, |p, e| self.expr(&**e, p))\n+        opt_expr.iter().fold(pred, |p, e| self.expr(&e, p))\n     }\n \n     fn straightline<'b, I: Iterator<Item=&'b hir::Expr>>(&mut self,\n@@ -461,18 +461,18 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n \n             for pat in &arm.pats {\n                 // Visit the pattern, coming from the discriminant exit\n-                let mut pat_exit = self.pat(&**pat, discr_exit);\n+                let mut pat_exit = self.pat(&pat, discr_exit);\n \n                 // If there is a guard expression, handle it here\n                 if let Some(ref guard) = arm.guard {\n                     // Add a dummy node for the previous guard\n                     // expression to target\n                     let guard_start = self.add_dummy_node(&[pat_exit]);\n                     // Visit the guard expression\n-                    let guard_exit = self.expr(&**guard, guard_start);\n+                    let guard_exit = self.expr(&guard, guard_start);\n \n                     let this_has_bindings = pat_util::pat_contains_bindings_or_wild(\n-                        &self.tcx.def_map.borrow(), &**pat);\n+                        &self.tcx.def_map.borrow(), &pat);\n \n                     // If both this pattern and the previous pattern\n                     // were free of bindings, they must consist only"}, {"sha": "a32f5b8797d3e83237503f95a5da897e9df9b2cb", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/3548b8c273d9feb0291e97a928c4f48e01daf0f9/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3548b8c273d9feb0291e97a928c4f48e01daf0f9/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=3548b8c273d9feb0291e97a928c4f48e01daf0f9", "patch": "@@ -72,7 +72,7 @@ impl<'a> fmt::Debug for Matrix<'a> {\n         let &Matrix(ref m) = self;\n         let pretty_printed_matrix: Vec<Vec<String>> = m.iter().map(|row| {\n             row.iter()\n-               .map(|&pat| pat_to_string(&*pat))\n+               .map(|&pat| pat_to_string(&pat))\n                .collect::<Vec<String>>()\n         }).collect();\n \n@@ -175,7 +175,7 @@ fn check_expr(cx: &mut MatchCheckCtxt, ex: &hir::Expr) {\n                 // Second, if there is a guard on each arm, make sure it isn't\n                 // assigning or borrowing anything mutably.\n                 match arm.guard {\n-                    Some(ref guard) => check_for_mutation_in_guard(cx, &**guard),\n+                    Some(ref guard) => check_for_mutation_in_guard(cx, &guard),\n                     None => {}\n                 }\n             }\n@@ -196,14 +196,14 @@ fn check_expr(cx: &mut MatchCheckCtxt, ex: &hir::Expr) {\n                 .iter()\n                 .flat_map(|&(ref pats, _)| pats) {\n                 // Third, check legality of move bindings.\n-                check_legality_of_bindings_in_at_patterns(cx, &**pat);\n+                check_legality_of_bindings_in_at_patterns(cx, &pat);\n \n                 // Fourth, check if there are any references to NaN that we should warn about.\n-                check_for_static_nan(cx, &**pat);\n+                check_for_static_nan(cx, &pat);\n \n                 // Fifth, check if for any of the patterns that match an enumerated type\n                 // are bindings with the same name as one of the variants of said type.\n-                check_for_bindings_named_the_same_as_variants(cx, &**pat);\n+                check_for_bindings_named_the_same_as_variants(cx, &pat);\n             }\n \n             // Fourth, check for unreachable arms.\n@@ -275,7 +275,7 @@ fn check_for_bindings_named_the_same_as_variants(cx: &MatchCheckCtxt, pat: &Pat)\n fn check_for_static_nan(cx: &MatchCheckCtxt, pat: &Pat) {\n     front_util::walk_pat(pat, |p| {\n         if let hir::PatLit(ref expr) = p.node {\n-            match eval_const_expr_partial(cx.tcx, &**expr, ExprTypeChecked, None) {\n+            match eval_const_expr_partial(cx.tcx, &expr, ExprTypeChecked, None) {\n                 Ok(ConstVal::Float(f)) if f.is_nan() => {\n                     span_warn!(cx.tcx.sess, p.span, E0003,\n                                \"unmatchable NaN in pattern, \\\n@@ -360,7 +360,7 @@ fn check_arms(cx: &MatchCheckCtxt,\n \n fn raw_pat<'a>(p: &'a Pat) -> &'a Pat {\n     match p.node {\n-        hir::PatIdent(_, _, Some(ref s)) => raw_pat(&**s),\n+        hir::PatIdent(_, _, Some(ref s)) => raw_pat(&s),\n         _ => p\n     }\n }\n@@ -679,7 +679,7 @@ fn is_useful(cx: &MatchCheckCtxt,\n     let left_ty = if real_pat.id == DUMMY_NODE_ID {\n         cx.tcx.mk_nil()\n     } else {\n-        let left_ty = cx.tcx.pat_ty(&*real_pat);\n+        let left_ty = cx.tcx.pat_ty(&real_pat);\n \n         match real_pat.node {\n             hir::PatIdent(hir::BindByRef(..), _, _) => {\n@@ -798,9 +798,9 @@ fn pat_constructors(cx: &MatchCheckCtxt, p: &Pat,\n                 _ => vec!(Single)\n             },\n         hir::PatLit(ref expr) =>\n-            vec!(ConstantValue(eval_const_expr(cx.tcx, &**expr))),\n+            vec!(ConstantValue(eval_const_expr(cx.tcx, &expr))),\n         hir::PatRange(ref lo, ref hi) =>\n-            vec!(ConstantRange(eval_const_expr(cx.tcx, &**lo), eval_const_expr(cx.tcx, &**hi))),\n+            vec!(ConstantRange(eval_const_expr(cx.tcx, &lo), eval_const_expr(cx.tcx, &hi))),\n         hir::PatVec(ref before, ref slice, ref after) =>\n             match left_ty.sty {\n                 ty::TyArray(_, _) => vec!(Single),\n@@ -941,7 +941,7 @@ pub fn specialize<'a>(cx: &MatchCheckCtxt, r: &[&'a Pat],\n             Some(vec![&**inner]),\n \n         hir::PatLit(ref expr) => {\n-            let expr_value = eval_const_expr(cx.tcx, &**expr);\n+            let expr_value = eval_const_expr(cx.tcx, &expr);\n             match range_covered_by_constructor(constructor, &expr_value, &expr_value) {\n                 Some(true) => Some(vec![]),\n                 Some(false) => None,\n@@ -953,8 +953,8 @@ pub fn specialize<'a>(cx: &MatchCheckCtxt, r: &[&'a Pat],\n         }\n \n         hir::PatRange(ref from, ref to) => {\n-            let from_value = eval_const_expr(cx.tcx, &**from);\n-            let to_value = eval_const_expr(cx.tcx, &**to);\n+            let from_value = eval_const_expr(cx.tcx, &from);\n+            let to_value = eval_const_expr(cx.tcx, &to);\n             match range_covered_by_constructor(constructor, &from_value, &to_value) {\n                 Some(true) => Some(vec![]),\n                 Some(false) => None,\n@@ -1012,7 +1012,7 @@ fn check_local(cx: &mut MatchCheckCtxt, loc: &hir::Local) {\n \n     // Check legality of move bindings and `@` patterns.\n     check_legality_of_move_bindings(cx, false, slice::ref_slice(&loc.pat));\n-    check_legality_of_bindings_in_at_patterns(cx, &*loc.pat);\n+    check_legality_of_bindings_in_at_patterns(cx, &loc.pat);\n }\n \n fn check_fn(cx: &mut MatchCheckCtxt,\n@@ -1031,7 +1031,7 @@ fn check_fn(cx: &mut MatchCheckCtxt,\n     for input in &decl.inputs {\n         check_irrefutable(cx, &input.pat, true);\n         check_legality_of_move_bindings(cx, false, slice::ref_slice(&input.pat));\n-        check_legality_of_bindings_in_at_patterns(cx, &*input.pat);\n+        check_legality_of_bindings_in_at_patterns(cx, &input.pat);\n     }\n }\n \n@@ -1058,7 +1058,7 @@ fn is_refutable<A, F>(cx: &MatchCheckCtxt, pat: &Pat, refutable: F) -> Option<A>\n     match is_useful(cx, &pats, &[DUMMY_WILD_PAT], ConstructWitness) {\n         UsefulWithWitness(pats) => {\n             assert_eq!(pats.len(), 1);\n-            Some(refutable(&*pats[0]))\n+            Some(refutable(&pats[0]))\n         },\n         NotUseful => None,\n         Useful => unreachable!()\n@@ -1073,7 +1073,7 @@ fn check_legality_of_move_bindings(cx: &MatchCheckCtxt,\n     let def_map = &tcx.def_map;\n     let mut by_ref_span = None;\n     for pat in pats {\n-        pat_bindings(def_map, &**pat, |bm, _, span, _path| {\n+        pat_bindings(def_map, &pat, |bm, _, span, _path| {\n             match bm {\n                 hir::BindByRef(_) => {\n                     by_ref_span = Some(span);\n@@ -1088,7 +1088,7 @@ fn check_legality_of_move_bindings(cx: &MatchCheckCtxt,\n         // check legality of moving out of the enum\n \n         // x @ Foo(..) is legal, but x @ Foo(y) isn't.\n-        if sub.map_or(false, |p| pat_contains_bindings(&def_map.borrow(), &*p)) {\n+        if sub.map_or(false, |p| pat_contains_bindings(&def_map.borrow(), &p)) {\n             span_err!(cx.tcx.sess, p.span, E0007, \"cannot bind by-move with sub-bindings\");\n         } else if has_guard {\n             span_err!(cx.tcx.sess, p.span, E0008, \"cannot bind by-move into a pattern guard\");\n@@ -1101,8 +1101,8 @@ fn check_legality_of_move_bindings(cx: &MatchCheckCtxt,\n     };\n \n     for pat in pats {\n-        front_util::walk_pat(&**pat, |p| {\n-            if pat_is_binding(&def_map.borrow(), &*p) {\n+        front_util::walk_pat(&pat, |p| {\n+            if pat_is_binding(&def_map.borrow(), &p) {\n                 match p.node {\n                     hir::PatIdent(hir::BindByValue(_), _, ref sub) => {\n                         let pat_ty = tcx.node_id_to_type(p.id);"}, {"sha": "f9922f725c615f47cd0064375cb0c36f0137367c", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/3548b8c273d9feb0291e97a928c4f48e01daf0f9/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3548b8c273d9feb0291e97a928c4f48e01daf0f9/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=3548b8c273d9feb0291e97a928c4f48e01daf0f9", "patch": "@@ -94,7 +94,7 @@ pub fn lookup_const_by_id<'a, 'tcx: 'a>(tcx: &'a ty::ctxt<'tcx>,\n             None => None,\n             Some(ast_map::NodeItem(it)) => match it.node {\n                 hir::ItemConst(_, ref const_expr) => {\n-                    Some(&*const_expr)\n+                    Some(&const_expr)\n                 }\n                 _ => None\n             },\n@@ -129,7 +129,7 @@ pub fn lookup_const_by_id<'a, 'tcx: 'a>(tcx: &'a ty::ctxt<'tcx>,\n             },\n             Some(ast_map::NodeImplItem(ii)) => match ii.node {\n                 hir::ImplItemKind::Const(_, ref expr) => {\n-                    Some(&*expr)\n+                    Some(&expr)\n                 }\n                 _ => None\n             },\n@@ -325,7 +325,7 @@ impl ConstVal {\n pub fn const_expr_to_pat(tcx: &ty::ctxt, expr: &Expr, span: Span) -> P<hir::Pat> {\n     let pat = match expr.node {\n         hir::ExprTup(ref exprs) =>\n-            hir::PatTup(exprs.iter().map(|expr| const_expr_to_pat(tcx, &**expr, span)).collect()),\n+            hir::PatTup(exprs.iter().map(|expr| const_expr_to_pat(tcx, &expr, span)).collect()),\n \n         hir::ExprCall(ref callee, ref args) => {\n             let def = *tcx.def_map.borrow().get(&callee.id).unwrap();\n@@ -342,7 +342,7 @@ pub fn const_expr_to_pat(tcx: &ty::ctxt, expr: &Expr, span: Span) -> P<hir::Pat>\n                 }),\n                 _ => unreachable!()\n             };\n-            let pats = args.iter().map(|expr| const_expr_to_pat(tcx, &**expr, span)).collect();\n+            let pats = args.iter().map(|expr| const_expr_to_pat(tcx, &expr, span)).collect();\n             hir::PatEnum(path, Some(pats))\n         }\n \n@@ -351,15 +351,15 @@ pub fn const_expr_to_pat(tcx: &ty::ctxt, expr: &Expr, span: Span) -> P<hir::Pat>\n                 span: codemap::DUMMY_SP,\n                 node: hir::FieldPat {\n                     name: field.name.node,\n-                    pat: const_expr_to_pat(tcx, &*field.expr, span),\n+                    pat: const_expr_to_pat(tcx, &field.expr, span),\n                     is_shorthand: false,\n                 },\n             }).collect();\n             hir::PatStruct(path.clone(), field_pats, false)\n         }\n \n         hir::ExprVec(ref exprs) => {\n-            let pats = exprs.iter().map(|expr| const_expr_to_pat(tcx, &**expr, span)).collect();\n+            let pats = exprs.iter().map(|expr| const_expr_to_pat(tcx, &expr, span)).collect();\n             hir::PatVec(pats, None, hir::HirVec::new())\n         }\n \n@@ -850,7 +850,7 @@ pub fn eval_const_expr_partial<'tcx>(tcx: &ty::ctxt<'tcx>,\n \n     let result = match e.node {\n       hir::ExprUnary(hir::UnNeg, ref inner) => {\n-        match try!(eval_const_expr_partial(tcx, &**inner, ty_hint, fn_args)) {\n+        match try!(eval_const_expr_partial(tcx, &inner, ty_hint, fn_args)) {\n           Float(f) => Float(-f),\n           Int(n) =>  try!(const_int_checked_neg(n, e, expr_int_type)),\n           Uint(i) => {\n@@ -860,7 +860,7 @@ pub fn eval_const_expr_partial<'tcx>(tcx: &ty::ctxt<'tcx>,\n         }\n       }\n       hir::ExprUnary(hir::UnNot, ref inner) => {\n-        match try!(eval_const_expr_partial(tcx, &**inner, ty_hint, fn_args)) {\n+        match try!(eval_const_expr_partial(tcx, &inner, ty_hint, fn_args)) {\n           Int(i) => Int(!i),\n           Uint(i) => const_uint_not(i, expr_uint_type),\n           Bool(b) => Bool(!b),\n@@ -872,8 +872,8 @@ pub fn eval_const_expr_partial<'tcx>(tcx: &ty::ctxt<'tcx>,\n             hir::BiShl | hir::BiShr => ty_hint.checked_or(tcx.types.usize),\n             _ => ty_hint\n         };\n-        match (try!(eval_const_expr_partial(tcx, &**a, ty_hint, fn_args)),\n-               try!(eval_const_expr_partial(tcx, &**b, b_ty, fn_args))) {\n+        match (try!(eval_const_expr_partial(tcx, &a, ty_hint, fn_args)),\n+               try!(eval_const_expr_partial(tcx, &b, b_ty, fn_args))) {\n           (Float(a), Float(b)) => {\n             match op.node {\n               hir::BiAdd => Float(a + b),\n@@ -964,7 +964,7 @@ pub fn eval_const_expr_partial<'tcx>(tcx: &ty::ctxt<'tcx>,\n         }\n       }\n       hir::ExprCast(ref base, ref target_ty) => {\n-        let ety = ety.or_else(|| ast_ty_to_prim_ty(tcx, &**target_ty))\n+        let ety = ety.or_else(|| ast_ty_to_prim_ty(tcx, &target_ty))\n                 .unwrap_or_else(|| {\n                     tcx.sess.span_fatal(target_ty.span,\n                                         \"target type not found for const cast\")\n@@ -982,7 +982,7 @@ pub fn eval_const_expr_partial<'tcx>(tcx: &ty::ctxt<'tcx>,\n             }\n         };\n \n-        let val = try!(eval_const_expr_partial(tcx, &**base, base_hint, fn_args));\n+        let val = try!(eval_const_expr_partial(tcx, &base, base_hint, fn_args));\n         match cast_const(tcx, val, ety) {\n             Ok(val) => val,\n             Err(kind) => return Err(ConstEvalErr { span: e.span, kind: kind }),\n@@ -1116,16 +1116,16 @@ pub fn eval_const_expr_partial<'tcx>(tcx: &ty::ctxt<'tcx>,\n               assert!(old.is_none());\n           }\n           debug!(\"const call({:?})\", call_args);\n-          try!(eval_const_expr_partial(tcx, &**result, ty_hint, Some(&call_args)))\n+          try!(eval_const_expr_partial(tcx, &result, ty_hint, Some(&call_args)))\n       },\n-      hir::ExprLit(ref lit) => lit_to_const(tcx.sess, e.span, &**lit, ety),\n+      hir::ExprLit(ref lit) => lit_to_const(tcx.sess, e.span, &lit, ety),\n       hir::ExprBlock(ref block) => {\n         match block.expr {\n-            Some(ref expr) => try!(eval_const_expr_partial(tcx, &**expr, ty_hint, fn_args)),\n+            Some(ref expr) => try!(eval_const_expr_partial(tcx, &expr, ty_hint, fn_args)),\n             None => unreachable!(),\n         }\n       }\n-      hir::ExprType(ref e, _) => try!(eval_const_expr_partial(tcx, &**e, ty_hint, fn_args)),\n+      hir::ExprType(ref e, _) => try!(eval_const_expr_partial(tcx, &e, ty_hint, fn_args)),\n       hir::ExprTup(_) => Tuple(e.id),\n       hir::ExprStruct(..) => Struct(e.id),\n       hir::ExprIndex(ref arr, ref idx) => {\n@@ -1144,15 +1144,15 @@ pub fn eval_const_expr_partial<'tcx>(tcx: &ty::ctxt<'tcx>,\n         match arr {\n             Array(_, n) if idx >= n => signal!(e, IndexOutOfBounds),\n             Array(v, _) => if let hir::ExprVec(ref v) = tcx.map.expect_expr(v).node {\n-                try!(eval_const_expr_partial(tcx, &*v[idx as usize], ty_hint, fn_args))\n+                try!(eval_const_expr_partial(tcx, &v[idx as usize], ty_hint, fn_args))\n             } else {\n                 unreachable!()\n             },\n \n             Repeat(_, n) if idx >= n => signal!(e, IndexOutOfBounds),\n             Repeat(elem, _) => try!(eval_const_expr_partial(\n                 tcx,\n-                &*tcx.map.expect_expr(elem),\n+                &tcx.map.expect_expr(elem),\n                 ty_hint,\n                 fn_args,\n             )),\n@@ -1172,7 +1172,7 @@ pub fn eval_const_expr_partial<'tcx>(tcx: &ty::ctxt<'tcx>,\n           let len_hint = ty_hint.checked_or(tcx.types.usize);\n           Repeat(\n               e.id,\n-              match try!(eval_const_expr_partial(tcx, &**n, len_hint, fn_args)) {\n+              match try!(eval_const_expr_partial(tcx, &n, len_hint, fn_args)) {\n                   Int(i) if i >= 0 => i as u64,\n                   Int(_) => signal!(e, RepeatCountNotNatural),\n                   Uint(i) => i,\n@@ -1207,7 +1207,7 @@ pub fn eval_const_expr_partial<'tcx>(tcx: &ty::ctxt<'tcx>,\n                 // if the idents are compared run-pass/issue-19244 fails\n                 if let Some(f) = fields.iter().find(|f| f.name.node\n                                                      == field_name.node) {\n-                    return eval_const_expr_partial(tcx, &*f.expr, base_hint, fn_args)\n+                    return eval_const_expr_partial(tcx, &f.expr, base_hint, fn_args)\n                 } else {\n                     signal!(e, MissingStructField);\n                 }"}, {"sha": "5de192ca4ebfb0019abcc6856e4f483adb4dbbc9", "filename": "src/librustc/middle/cstore.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3548b8c273d9feb0291e97a928c4f48e01daf0f9/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3548b8c273d9feb0291e97a928c4f48e01daf0f9/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcstore.rs?ref=3548b8c273d9feb0291e97a928c4f48e01daf0f9", "patch": "@@ -254,8 +254,8 @@ impl InlinedItem {\n         where V: Visitor<'ast>\n     {\n         match *self {\n-            InlinedItem::Item(ref i) => visitor.visit_item(&**i),\n-            InlinedItem::Foreign(ref i) => visitor.visit_foreign_item(&**i),\n+            InlinedItem::Item(ref i) => visitor.visit_item(&i),\n+            InlinedItem::Foreign(ref i) => visitor.visit_foreign_item(&i),\n             InlinedItem::TraitItem(_, ref ti) => visitor.visit_trait_item(ti),\n             InlinedItem::ImplItem(_, ref ii) => visitor.visit_impl_item(ii),\n         }"}, {"sha": "ae2252b6df6ca88e33a304c6486fb1d12b6cf2dc", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3548b8c273d9feb0291e97a928c4f48e01daf0f9/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3548b8c273d9feb0291e97a928c4f48e01daf0f9/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=3548b8c273d9feb0291e97a928c4f48e01daf0f9", "patch": "@@ -183,17 +183,17 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n                                 .contains(&attr::ReprExtern)\n                         });\n \n-                        intravisit::walk_item(self, &*item);\n+                        intravisit::walk_item(self, &item);\n                     }\n                     hir::ItemEnum(..) => {\n                         self.inherited_pub_visibility = item.vis == hir::Public;\n-                        intravisit::walk_item(self, &*item);\n+                        intravisit::walk_item(self, &item);\n                     }\n                     hir::ItemFn(..)\n                     | hir::ItemTy(..)\n                     | hir::ItemStatic(..)\n                     | hir::ItemConst(..) => {\n-                        intravisit::walk_item(self, &*item);\n+                        intravisit::walk_item(self, &item);\n                     }\n                     _ => ()\n                 }\n@@ -205,7 +205,7 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n                 intravisit::walk_impl_item(self, impl_item);\n             }\n             ast_map::NodeForeignItem(foreign_item) => {\n-                intravisit::walk_foreign_item(self, &*foreign_item);\n+                intravisit::walk_foreign_item(self, &foreign_item);\n             }\n             _ => ()\n         }\n@@ -237,10 +237,10 @@ impl<'a, 'tcx, 'v> Visitor<'v> for MarkSymbolVisitor<'a, 'tcx> {\n                 self.lookup_and_handle_method(expr.id);\n             }\n             hir::ExprField(ref lhs, ref name) => {\n-                self.handle_field_access(&**lhs, name.node);\n+                self.handle_field_access(&lhs, name.node);\n             }\n             hir::ExprTupField(ref lhs, idx) => {\n-                self.handle_tup_field_access(&**lhs, idx.node);\n+                self.handle_tup_field_access(&lhs, idx.node);\n             }\n             _ => ()\n         }\n@@ -257,7 +257,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for MarkSymbolVisitor<'a, 'tcx> {\n             // necessary for the pattern to match. Those construction sites\n             // can't be reached unless the variant is constructed elsewhere.\n             let len = self.ignore_variant_stack.len();\n-            self.ignore_variant_stack.extend_from_slice(&*variants);\n+            self.ignore_variant_stack.extend_from_slice(&variants);\n             intravisit::walk_arm(self, arm);\n             self.ignore_variant_stack.truncate(len);\n         } else {"}, {"sha": "5bdb553a2fea98708d3eb5bf50eeda3a955206ae", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 55, "deletions": 55, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/3548b8c273d9feb0291e97a928c4f48e01daf0f9/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3548b8c273d9feb0291e97a928c4f48e01daf0f9/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=3548b8c273d9feb0291e97a928c4f48e01daf0f9", "patch": "@@ -303,7 +303,7 @@ impl<'d,'t,'a,'tcx> ExprUseVisitor<'d,'t,'a,'tcx> {\n                 ty::ReScope(fn_body_scope), // Args live only as long as the fn body.\n                 arg_ty);\n \n-            self.walk_irrefutable_pat(arg_cmt, &*arg.pat);\n+            self.walk_irrefutable_pat(arg_cmt, &arg.pat);\n         }\n     }\n \n@@ -324,7 +324,7 @@ impl<'d,'t,'a,'tcx> ExprUseVisitor<'d,'t,'a,'tcx> {\n \n     fn consume_exprs(&mut self, exprs: &[P<hir::Expr>]) {\n         for expr in exprs {\n-            self.consume_expr(&**expr);\n+            self.consume_expr(&expr);\n         }\n     }\n \n@@ -372,40 +372,40 @@ impl<'d,'t,'a,'tcx> ExprUseVisitor<'d,'t,'a,'tcx> {\n             hir::ExprPath(..) => { }\n \n             hir::ExprType(ref subexpr, _) => {\n-                self.walk_expr(&**subexpr)\n+                self.walk_expr(&subexpr)\n             }\n \n             hir::ExprUnary(hir::UnDeref, ref base) => {      // *base\n-                if !self.walk_overloaded_operator(expr, &**base, Vec::new(), PassArgs::ByRef) {\n-                    self.select_from_expr(&**base);\n+                if !self.walk_overloaded_operator(expr, &base, Vec::new(), PassArgs::ByRef) {\n+                    self.select_from_expr(&base);\n                 }\n             }\n \n             hir::ExprField(ref base, _) => {         // base.f\n-                self.select_from_expr(&**base);\n+                self.select_from_expr(&base);\n             }\n \n             hir::ExprTupField(ref base, _) => {         // base.<n>\n-                self.select_from_expr(&**base);\n+                self.select_from_expr(&base);\n             }\n \n             hir::ExprIndex(ref lhs, ref rhs) => {       // lhs[rhs]\n                 if !self.walk_overloaded_operator(expr,\n-                                                  &**lhs,\n-                                                  vec![&**rhs],\n+                                                  &lhs,\n+                                                  vec![&rhs],\n                                                   PassArgs::ByValue) {\n-                    self.select_from_expr(&**lhs);\n-                    self.consume_expr(&**rhs);\n+                    self.select_from_expr(&lhs);\n+                    self.consume_expr(&rhs);\n                 }\n             }\n \n             hir::ExprRange(ref start, ref end) => {\n-                start.as_ref().map(|e| self.consume_expr(&**e));\n-                end.as_ref().map(|e| self.consume_expr(&**e));\n+                start.as_ref().map(|e| self.consume_expr(&e));\n+                end.as_ref().map(|e| self.consume_expr(&e));\n             }\n \n             hir::ExprCall(ref callee, ref args) => {    // callee(args)\n-                self.walk_callee(expr, &**callee);\n+                self.walk_callee(expr, &callee);\n                 self.consume_exprs(args);\n             }\n \n@@ -422,16 +422,16 @@ impl<'d,'t,'a,'tcx> ExprUseVisitor<'d,'t,'a,'tcx> {\n             }\n \n             hir::ExprIf(ref cond_expr, ref then_blk, ref opt_else_expr) => {\n-                self.consume_expr(&**cond_expr);\n-                self.walk_block(&**then_blk);\n+                self.consume_expr(&cond_expr);\n+                self.walk_block(&then_blk);\n                 if let Some(ref else_expr) = *opt_else_expr {\n-                    self.consume_expr(&**else_expr);\n+                    self.consume_expr(&else_expr);\n                 }\n             }\n \n             hir::ExprMatch(ref discr, ref arms, _) => {\n-                let discr_cmt = return_if_err!(self.mc.cat_expr(&**discr));\n-                self.borrow_expr(&**discr, ty::ReEmpty, ty::ImmBorrow, MatchDiscriminant);\n+                let discr_cmt = return_if_err!(self.mc.cat_expr(&discr));\n+                self.borrow_expr(&discr, ty::ReEmpty, ty::ImmBorrow, MatchDiscriminant);\n \n                 // treatment of the discriminant is handled while walking the arms.\n                 for arm in arms {\n@@ -451,20 +451,20 @@ impl<'d,'t,'a,'tcx> ExprUseVisitor<'d,'t,'a,'tcx> {\n                 let expr_ty = return_if_err!(self.typer.node_ty(expr.id));\n                 if let ty::TyRef(&r, _) = expr_ty.sty {\n                     let bk = ty::BorrowKind::from_mutbl(m);\n-                    self.borrow_expr(&**base, r, bk, AddrOf);\n+                    self.borrow_expr(&base, r, bk, AddrOf);\n                 }\n             }\n \n             hir::ExprInlineAsm(ref ia) => {\n                 for &(_, ref input) in &ia.inputs {\n-                    self.consume_expr(&**input);\n+                    self.consume_expr(&input);\n                 }\n \n                 for output in &ia.outputs {\n                     if output.is_indirect {\n-                        self.consume_expr(&*output.expr);\n+                        self.consume_expr(&output.expr);\n                     } else {\n-                        self.mutate_expr(expr, &*output.expr,\n+                        self.mutate_expr(expr, &output.expr,\n                                          if output.is_rw {\n                                              MutateMode::WriteAndRead\n                                          } else {\n@@ -479,12 +479,12 @@ impl<'d,'t,'a,'tcx> ExprUseVisitor<'d,'t,'a,'tcx> {\n             hir::ExprLit(..) => {}\n \n             hir::ExprLoop(ref blk, _) => {\n-                self.walk_block(&**blk);\n+                self.walk_block(&blk);\n             }\n \n             hir::ExprWhile(ref cond_expr, ref blk, _) => {\n-                self.consume_expr(&**cond_expr);\n-                self.walk_block(&**blk);\n+                self.consume_expr(&cond_expr);\n+                self.walk_block(&blk);\n             }\n \n             hir::ExprUnary(op, ref lhs) => {\n@@ -494,8 +494,8 @@ impl<'d,'t,'a,'tcx> ExprUseVisitor<'d,'t,'a,'tcx> {\n                     PassArgs::ByRef\n                 };\n \n-                if !self.walk_overloaded_operator(expr, &**lhs, Vec::new(), pass_args) {\n-                    self.consume_expr(&**lhs);\n+                if !self.walk_overloaded_operator(expr, &lhs, Vec::new(), pass_args) {\n+                    self.consume_expr(&lhs);\n                 }\n             }\n \n@@ -506,52 +506,52 @@ impl<'d,'t,'a,'tcx> ExprUseVisitor<'d,'t,'a,'tcx> {\n                     PassArgs::ByRef\n                 };\n \n-                if !self.walk_overloaded_operator(expr, &**lhs, vec![&**rhs], pass_args) {\n-                    self.consume_expr(&**lhs);\n-                    self.consume_expr(&**rhs);\n+                if !self.walk_overloaded_operator(expr, &lhs, vec![&rhs], pass_args) {\n+                    self.consume_expr(&lhs);\n+                    self.consume_expr(&rhs);\n                 }\n             }\n \n             hir::ExprBlock(ref blk) => {\n-                self.walk_block(&**blk);\n+                self.walk_block(&blk);\n             }\n \n             hir::ExprRet(ref opt_expr) => {\n                 if let Some(ref expr) = *opt_expr {\n-                    self.consume_expr(&**expr);\n+                    self.consume_expr(&expr);\n                 }\n             }\n \n             hir::ExprAssign(ref lhs, ref rhs) => {\n-                self.mutate_expr(expr, &**lhs, MutateMode::JustWrite);\n-                self.consume_expr(&**rhs);\n+                self.mutate_expr(expr, &lhs, MutateMode::JustWrite);\n+                self.consume_expr(&rhs);\n             }\n \n             hir::ExprCast(ref base, _) => {\n-                self.consume_expr(&**base);\n+                self.consume_expr(&base);\n             }\n \n             hir::ExprAssignOp(op, ref lhs, ref rhs) => {\n                 // NB All our assignment operations take the RHS by value\n                 assert!(::rustc_front::util::is_by_value_binop(op.node));\n \n                 if !self.walk_overloaded_operator(expr, lhs, vec![rhs], PassArgs::ByValue) {\n-                    self.mutate_expr(expr, &**lhs, MutateMode::WriteAndRead);\n-                    self.consume_expr(&**rhs);\n+                    self.mutate_expr(expr, &lhs, MutateMode::WriteAndRead);\n+                    self.consume_expr(&rhs);\n                 }\n             }\n \n             hir::ExprRepeat(ref base, ref count) => {\n-                self.consume_expr(&**base);\n-                self.consume_expr(&**count);\n+                self.consume_expr(&base);\n+                self.consume_expr(&count);\n             }\n \n             hir::ExprClosure(..) => {\n                 self.walk_captures(expr)\n             }\n \n             hir::ExprBox(ref base) => {\n-                self.consume_expr(&**base);\n+                self.consume_expr(&base);\n             }\n         }\n     }\n@@ -602,7 +602,7 @@ impl<'d,'t,'a,'tcx> ExprUseVisitor<'d,'t,'a,'tcx> {\n             hir::StmtDecl(ref decl, _) => {\n                 match decl.node {\n                     hir::DeclLocal(ref local) => {\n-                        self.walk_local(&**local);\n+                        self.walk_local(&local);\n                     }\n \n                     hir::DeclItem(_) => {\n@@ -614,7 +614,7 @@ impl<'d,'t,'a,'tcx> ExprUseVisitor<'d,'t,'a,'tcx> {\n \n             hir::StmtExpr(ref expr, _) |\n             hir::StmtSemi(ref expr, _) => {\n-                self.consume_expr(&**expr);\n+                self.consume_expr(&expr);\n             }\n         }\n     }\n@@ -623,7 +623,7 @@ impl<'d,'t,'a,'tcx> ExprUseVisitor<'d,'t,'a,'tcx> {\n         match local.init {\n             None => {\n                 let delegate = &mut self.delegate;\n-                pat_util::pat_bindings(&self.typer.tcx.def_map, &*local.pat,\n+                pat_util::pat_bindings(&self.typer.tcx.def_map, &local.pat,\n                                        |_, id, span, _| {\n                     delegate.decl_without_init(id, span);\n                 })\n@@ -634,9 +634,9 @@ impl<'d,'t,'a,'tcx> ExprUseVisitor<'d,'t,'a,'tcx> {\n                 // initializers are considered\n                 // \"assigns\", which is handled by\n                 // `walk_pat`:\n-                self.walk_expr(&**expr);\n-                let init_cmt = return_if_err!(self.mc.cat_expr(&**expr));\n-                self.walk_irrefutable_pat(init_cmt, &*local.pat);\n+                self.walk_expr(&expr);\n+                let init_cmt = return_if_err!(self.mc.cat_expr(&expr));\n+                self.walk_irrefutable_pat(init_cmt, &local.pat);\n             }\n         }\n     }\n@@ -651,7 +651,7 @@ impl<'d,'t,'a,'tcx> ExprUseVisitor<'d,'t,'a,'tcx> {\n         }\n \n         if let Some(ref tail_expr) = blk.expr {\n-            self.consume_expr(&**tail_expr);\n+            self.consume_expr(&tail_expr);\n         }\n     }\n \n@@ -661,15 +661,15 @@ impl<'d,'t,'a,'tcx> ExprUseVisitor<'d,'t,'a,'tcx> {\n                         opt_with: &Option<P<hir::Expr>>) {\n         // Consume the expressions supplying values for each field.\n         for field in fields {\n-            self.consume_expr(&*field.expr);\n+            self.consume_expr(&field.expr);\n         }\n \n         let with_expr = match *opt_with {\n             Some(ref w) => &**w,\n             None => { return; }\n         };\n \n-        let with_cmt = return_if_err!(self.mc.cat_expr(&*with_expr));\n+        let with_cmt = return_if_err!(self.mc.cat_expr(&with_expr));\n \n         // Select just those fields of the `with`\n         // expression that will actually be used\n@@ -906,21 +906,21 @@ impl<'d,'t,'a,'tcx> ExprUseVisitor<'d,'t,'a,'tcx> {\n     fn arm_move_mode(&mut self, discr_cmt: mc::cmt<'tcx>, arm: &hir::Arm) -> TrackMatchMode {\n         let mut mode = Unknown;\n         for pat in &arm.pats {\n-            self.determine_pat_move_mode(discr_cmt.clone(), &**pat, &mut mode);\n+            self.determine_pat_move_mode(discr_cmt.clone(), &pat, &mut mode);\n         }\n         mode\n     }\n \n     fn walk_arm(&mut self, discr_cmt: mc::cmt<'tcx>, arm: &hir::Arm, mode: MatchMode) {\n         for pat in &arm.pats {\n-            self.walk_pat(discr_cmt.clone(), &**pat, mode);\n+            self.walk_pat(discr_cmt.clone(), &pat, mode);\n         }\n \n         if let Some(ref guard) = arm.guard {\n-            self.consume_expr(&**guard);\n+            self.consume_expr(&guard);\n         }\n \n-        self.consume_expr(&*arm.body);\n+        self.consume_expr(&arm.body);\n     }\n \n     /// Walks a pat that occurs in isolation (i.e. top-level of fn\n@@ -1029,7 +1029,7 @@ impl<'d,'t,'a,'tcx> ExprUseVisitor<'d,'t,'a,'tcx> {\n                         // matched.\n \n                         let (slice_cmt, slice_mutbl, slice_r) =\n-                            return_if_err!(mc.cat_slice_pattern(cmt_pat, &**slice_pat));\n+                            return_if_err!(mc.cat_slice_pattern(cmt_pat, &slice_pat));\n \n                         // Note: We declare here that the borrow\n                         // occurs upon entering the `[...]`"}, {"sha": "8c578bcd3d2aec38d38c2c4e7d6e582326a2eaa3", "filename": "src/librustc/middle/infer/error_reporting.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/3548b8c273d9feb0291e97a928c4f48e01daf0f9/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3548b8c273d9feb0291e97a928c4f48e01daf0f9/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs?ref=3548b8c273d9feb0291e97a928c4f48e01daf0f9", "patch": "@@ -145,7 +145,7 @@ impl<'tcx> ty::ctxt<'tcx> {\n                         _ => \"expression\",\n                     },\n                     Some(ast_map::NodeStmt(_)) => \"statement\",\n-                    Some(ast_map::NodeItem(it)) => item_scope_tag(&*it),\n+                    Some(ast_map::NodeItem(it)) => item_scope_tag(&it),\n                     Some(_) | None => {\n                         err.span_note(span, &unknown_scope());\n                         return;\n@@ -190,7 +190,7 @@ impl<'tcx> ty::ctxt<'tcx> {\n                         (format!(\"{} {}\", prefix, msg), opt_span)\n                     }\n                     Some(ast_map::NodeItem(it)) => {\n-                        let tag = item_scope_tag(&*it);\n+                        let tag = item_scope_tag(&it);\n                         let (msg, opt_span) = explain_span(self, tag, it.span);\n                         (format!(\"{} {}\", prefix, msg), opt_span)\n                     }\n@@ -1333,7 +1333,7 @@ impl<'a, 'tcx> Rebuilder<'a, 'tcx> {\n                        -> hir::HirVec<hir::Arg> {\n         let mut new_inputs = Vec::new();\n         for arg in inputs {\n-            let new_ty = self.rebuild_arg_ty_or_output(&*arg.ty, lifetime,\n+            let new_ty = self.rebuild_arg_ty_or_output(&arg.ty, lifetime,\n                                                        anon_nums, region_names);\n             let possibly_new_arg = hir::Arg {\n                 ty: new_ty,\n@@ -1351,7 +1351,7 @@ impl<'a, 'tcx> Rebuilder<'a, 'tcx> {\n                       region_names: &HashSet<ast::Name>) -> hir::FunctionRetTy {\n         match *ty {\n             hir::Return(ref ret_ty) => hir::Return(\n-                self.rebuild_arg_ty_or_output(&**ret_ty, lifetime, anon_nums, region_names)\n+                self.rebuild_arg_ty_or_output(&ret_ty, lifetime, anon_nums, region_names)\n             ),\n             hir::DefaultReturn(span) => hir::DefaultReturn(span),\n             hir::NoReturn(span) => hir::NoReturn(span)\n@@ -1390,7 +1390,7 @@ impl<'a, 'tcx> Rebuilder<'a, 'tcx> {\n                         };\n                         new_ty = self.rebuild_ty(new_ty, P(to));\n                     }\n-                    ty_queue.push(&*mut_ty.ty);\n+                    ty_queue.push(&mut_ty.ty);\n                 }\n                 hir::TyPath(ref maybe_qself, ref path) => {\n                     let a_def = match self.tcx.def_map.borrow().get(&cur_ty.id) {\n@@ -1455,11 +1455,11 @@ impl<'a, 'tcx> Rebuilder<'a, 'tcx> {\n                 }\n \n                 hir::TyPtr(ref mut_ty) => {\n-                    ty_queue.push(&*mut_ty.ty);\n+                    ty_queue.push(&mut_ty.ty);\n                 }\n                 hir::TyVec(ref ty) |\n                 hir::TyFixedLengthVec(ref ty, _) => {\n-                    ty_queue.push(&**ty);\n+                    ty_queue.push(&ty);\n                 }\n                 hir::TyTup(ref tys) => ty_queue.extend(tys.iter().map(|ty| &**ty)),\n                 _ => {}\n@@ -1554,13 +1554,13 @@ impl<'a, 'tcx> Rebuilder<'a, 'tcx> {\n                     }\n                 }\n                 let new_types = data.types.iter().map(|t| {\n-                    self.rebuild_arg_ty_or_output(&**t, lifetime, anon_nums, region_names)\n+                    self.rebuild_arg_ty_or_output(&t, lifetime, anon_nums, region_names)\n                 }).collect();\n                 let new_bindings = data.bindings.iter().map(|b| {\n                     hir::TypeBinding {\n                         id: b.id,\n                         name: b.name,\n-                        ty: self.rebuild_arg_ty_or_output(&*b.ty,\n+                        ty: self.rebuild_arg_ty_or_output(&b.ty,\n                                                           lifetime,\n                                                           anon_nums,\n                                                           region_names),"}, {"sha": "dafa65c5bdca86663f39a664e1fb963ad92f4644", "filename": "src/librustc/middle/infer/region_inference/graphviz.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3548b8c273d9feb0291e97a928c4f48e01daf0f9/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3548b8c273d9feb0291e97a928c4f48e01daf0f9/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fgraphviz.rs?ref=3548b8c273d9feb0291e97a928c4f48e01daf0f9", "patch": "@@ -76,7 +76,7 @@ pub fn maybe_print_constraints_for<'a, 'tcx>(region_vars: &RegionVarBindings<'a,\n \n     let output_path = {\n         let output_template = match requested_output {\n-            Ok(ref s) if &**s == \"help\" => {\n+            Ok(ref s) if s == \"help\" => {\n                 static PRINTED_YET: AtomicBool = AtomicBool::new(false);\n                 if !PRINTED_YET.load(Ordering::SeqCst) {\n                     print_help_message();"}, {"sha": "a487ddbc2b1c258aa5a3489e158f256a774c1ca2", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 52, "deletions": 52, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/3548b8c273d9feb0291e97a928c4f48e01daf0f9/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3548b8c273d9feb0291e97a928c4f48e01daf0f9/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=3548b8c273d9feb0291e97a928c4f48e01daf0f9", "patch": "@@ -382,7 +382,7 @@ fn visit_fn(ir: &mut IrMaps,\n \n     for arg in &decl.inputs {\n         pat_util::pat_bindings(&ir.tcx.def_map,\n-                               &*arg.pat,\n+                               &arg.pat,\n                                |_bm, arg_id, _x, path1| {\n             debug!(\"adding argument {}\", arg_id);\n             let name = path1.node;\n@@ -416,7 +416,7 @@ fn visit_fn(ir: &mut IrMaps,\n }\n \n fn visit_local(ir: &mut IrMaps, local: &hir::Local) {\n-    pat_util::pat_bindings(&ir.tcx.def_map, &*local.pat, |_, p_id, sp, path1| {\n+    pat_util::pat_bindings(&ir.tcx.def_map, &local.pat, |_, p_id, sp, path1| {\n         debug!(\"adding local variable {}\", p_id);\n         let name = path1.node;\n         ir.add_live_node_for_node(p_id, VarDefNode(sp));\n@@ -430,7 +430,7 @@ fn visit_local(ir: &mut IrMaps, local: &hir::Local) {\n \n fn visit_arm(ir: &mut IrMaps, arm: &hir::Arm) {\n     for pat in &arm.pats {\n-        pat_util::pat_bindings(&ir.tcx.def_map, &**pat, |bm, p_id, sp, path1| {\n+        pat_util::pat_bindings(&ir.tcx.def_map, &pat, |bm, p_id, sp, path1| {\n             debug!(\"adding local variable {} from match with bm {:?}\",\n                    p_id, bm);\n             let name = path1.node;\n@@ -876,11 +876,11 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n                               -> LiveNode {\n         match stmt.node {\n             hir::StmtDecl(ref decl, _) => {\n-                self.propagate_through_decl(&**decl, succ)\n+                self.propagate_through_decl(&decl, succ)\n             }\n \n             hir::StmtExpr(ref expr, _) | hir::StmtSemi(ref expr, _) => {\n-                self.propagate_through_expr(&**expr, succ)\n+                self.propagate_through_expr(&expr, succ)\n             }\n         }\n     }\n@@ -889,7 +889,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n                               -> LiveNode {\n         match decl.node {\n             hir::DeclLocal(ref local) => {\n-                self.propagate_through_local(&**local, succ)\n+                self.propagate_through_local(&local, succ)\n             }\n             hir::DeclItem(_) => succ,\n         }\n@@ -912,13 +912,13 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         // once at the func header but otherwise equivalent.\n \n         let succ = self.propagate_through_opt_expr(local.init.as_ref().map(|e| &**e), succ);\n-        self.define_bindings_in_pat(&*local.pat, succ)\n+        self.define_bindings_in_pat(&local.pat, succ)\n     }\n \n     fn propagate_through_exprs(&mut self, exprs: &[P<Expr>], succ: LiveNode)\n                                -> LiveNode {\n         exprs.iter().rev().fold(succ, |succ, expr| {\n-            self.propagate_through_expr(&**expr, succ)\n+            self.propagate_through_expr(&expr, succ)\n         })\n     }\n \n@@ -941,11 +941,11 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n           }\n \n           hir::ExprField(ref e, _) => {\n-              self.propagate_through_expr(&**e, succ)\n+              self.propagate_through_expr(&e, succ)\n           }\n \n           hir::ExprTupField(ref e, _) => {\n-              self.propagate_through_expr(&**e, succ)\n+              self.propagate_through_expr(&e, succ)\n           }\n \n           hir::ExprClosure(_, _, ref blk) => {\n@@ -991,21 +991,21 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n             //   (  succ  )\n             //\n             let else_ln = self.propagate_through_opt_expr(els.as_ref().map(|e| &**e), succ);\n-            let then_ln = self.propagate_through_block(&**then, succ);\n+            let then_ln = self.propagate_through_block(&then, succ);\n             let ln = self.live_node(expr.id, expr.span);\n             self.init_from_succ(ln, else_ln);\n             self.merge_from_succ(ln, then_ln, false);\n-            self.propagate_through_expr(&**cond, ln)\n+            self.propagate_through_expr(&cond, ln)\n           }\n \n           hir::ExprWhile(ref cond, ref blk, _) => {\n-            self.propagate_through_loop(expr, WhileLoop(&**cond), &**blk, succ)\n+            self.propagate_through_loop(expr, WhileLoop(&cond), &blk, succ)\n           }\n \n           // Note that labels have been resolved, so we don't need to look\n           // at the label ident\n           hir::ExprLoop(ref blk, _) => {\n-            self.propagate_through_loop(expr, LoopLoop, &**blk, succ)\n+            self.propagate_through_loop(expr, LoopLoop, &blk, succ)\n           }\n \n           hir::ExprMatch(ref e, ref arms, _) => {\n@@ -1028,7 +1028,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n             let mut first_merge = true;\n             for arm in arms {\n                 let body_succ =\n-                    self.propagate_through_expr(&*arm.body, succ);\n+                    self.propagate_through_expr(&arm.body, succ);\n                 let guard_succ =\n                     self.propagate_through_opt_expr(arm.guard.as_ref().map(|e| &**e), body_succ);\n                 // only consider the first pattern; any later patterns must have\n@@ -1040,7 +1040,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n                 self.merge_from_succ(ln, arm_succ, first_merge);\n                 first_merge = false;\n             };\n-            self.propagate_through_expr(&**e, ln)\n+            self.propagate_through_expr(&e, ln)\n           }\n \n           hir::ExprRet(ref o_e) => {\n@@ -1080,17 +1080,17 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n           hir::ExprAssign(ref l, ref r) => {\n             // see comment on lvalues in\n             // propagate_through_lvalue_components()\n-            let succ = self.write_lvalue(&**l, succ, ACC_WRITE);\n-            let succ = self.propagate_through_lvalue_components(&**l, succ);\n-            self.propagate_through_expr(&**r, succ)\n+            let succ = self.write_lvalue(&l, succ, ACC_WRITE);\n+            let succ = self.propagate_through_lvalue_components(&l, succ);\n+            self.propagate_through_expr(&r, succ)\n           }\n \n           hir::ExprAssignOp(_, ref l, ref r) => {\n             // see comment on lvalues in\n             // propagate_through_lvalue_components()\n-            let succ = self.write_lvalue(&**l, succ, ACC_WRITE|ACC_READ);\n-            let succ = self.propagate_through_expr(&**r, succ);\n-            self.propagate_through_lvalue_components(&**l, succ)\n+            let succ = self.write_lvalue(&l, succ, ACC_WRITE|ACC_READ);\n+            let succ = self.propagate_through_expr(&r, succ);\n+            self.propagate_through_lvalue_components(&l, succ)\n           }\n \n           // Uninteresting cases: just propagate in rev exec order\n@@ -1100,27 +1100,27 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n           }\n \n           hir::ExprRepeat(ref element, ref count) => {\n-            let succ = self.propagate_through_expr(&**count, succ);\n-            self.propagate_through_expr(&**element, succ)\n+            let succ = self.propagate_through_expr(&count, succ);\n+            self.propagate_through_expr(&element, succ)\n           }\n \n           hir::ExprStruct(_, ref fields, ref with_expr) => {\n             let succ = self.propagate_through_opt_expr(with_expr.as_ref().map(|e| &**e), succ);\n             fields.iter().rev().fold(succ, |succ, field| {\n-                self.propagate_through_expr(&*field.expr, succ)\n+                self.propagate_through_expr(&field.expr, succ)\n             })\n           }\n \n           hir::ExprCall(ref f, ref args) => {\n             let diverges = !self.ir.tcx.is_method_call(expr.id) &&\n-                self.ir.tcx.expr_ty_adjusted(&**f).fn_ret().diverges();\n+                self.ir.tcx.expr_ty_adjusted(&f).fn_ret().diverges();\n             let succ = if diverges {\n                 self.s.exit_ln\n             } else {\n                 succ\n             };\n             let succ = self.propagate_through_exprs(&args[..], succ);\n-            self.propagate_through_expr(&**f, succ)\n+            self.propagate_through_expr(&f, succ)\n           }\n \n           hir::ExprMethodCall(_, _, ref args) => {\n@@ -1139,32 +1139,32 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n           }\n \n           hir::ExprBinary(op, ref l, ref r) if ::rustc_front::util::lazy_binop(op.node) => {\n-            let r_succ = self.propagate_through_expr(&**r, succ);\n+            let r_succ = self.propagate_through_expr(&r, succ);\n \n             let ln = self.live_node(expr.id, expr.span);\n             self.init_from_succ(ln, succ);\n             self.merge_from_succ(ln, r_succ, false);\n \n-            self.propagate_through_expr(&**l, ln)\n+            self.propagate_through_expr(&l, ln)\n           }\n \n           hir::ExprIndex(ref l, ref r) |\n           hir::ExprBinary(_, ref l, ref r) => {\n-            let r_succ = self.propagate_through_expr(&**r, succ);\n-            self.propagate_through_expr(&**l, r_succ)\n+            let r_succ = self.propagate_through_expr(&r, succ);\n+            self.propagate_through_expr(&l, r_succ)\n           }\n \n           hir::ExprRange(ref e1, ref e2) => {\n-            let succ = e2.as_ref().map_or(succ, |e| self.propagate_through_expr(&**e, succ));\n-            e1.as_ref().map_or(succ, |e| self.propagate_through_expr(&**e, succ))\n+            let succ = e2.as_ref().map_or(succ, |e| self.propagate_through_expr(&e, succ));\n+            e1.as_ref().map_or(succ, |e| self.propagate_through_expr(&e, succ))\n           }\n \n           hir::ExprBox(ref e) |\n           hir::ExprAddrOf(_, ref e) |\n           hir::ExprCast(ref e, _) |\n           hir::ExprType(ref e, _) |\n           hir::ExprUnary(_, ref e) => {\n-            self.propagate_through_expr(&**e, succ)\n+            self.propagate_through_expr(&e, succ)\n           }\n \n           hir::ExprInlineAsm(ref ia) => {\n@@ -1174,17 +1174,17 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n                     // see comment on lvalues\n                     // in propagate_through_lvalue_components()\n                     if out.is_indirect {\n-                        self.propagate_through_expr(&*out.expr, succ)\n+                        self.propagate_through_expr(&out.expr, succ)\n                     } else {\n                         let acc = if out.is_rw { ACC_WRITE|ACC_READ } else { ACC_WRITE };\n-                        let succ = self.write_lvalue(&*out.expr, succ, acc);\n-                        self.propagate_through_lvalue_components(&*out.expr, succ)\n+                        let succ = self.write_lvalue(&out.expr, succ, acc);\n+                        self.propagate_through_lvalue_components(&out.expr, succ)\n                     }\n                 }\n             );\n             // Inputs are executed first. Propagate last because of rev order\n             ia.inputs.iter().rev().fold(succ, |succ, &(_, ref expr)| {\n-                self.propagate_through_expr(&**expr, succ)\n+                self.propagate_through_expr(&expr, succ)\n             })\n           }\n \n@@ -1193,7 +1193,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n           }\n \n           hir::ExprBlock(ref blk) => {\n-            self.propagate_through_block(&**blk, succ)\n+            self.propagate_through_block(&blk, succ)\n           }\n         }\n     }\n@@ -1253,8 +1253,8 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n \n         match expr.node {\n             hir::ExprPath(..) => succ,\n-            hir::ExprField(ref e, _) => self.propagate_through_expr(&**e, succ),\n-            hir::ExprTupField(ref e, _) => self.propagate_through_expr(&**e, succ),\n+            hir::ExprField(ref e, _) => self.propagate_through_expr(&e, succ),\n+            hir::ExprTupField(ref e, _) => self.propagate_through_expr(&e, succ),\n             _ => self.propagate_through_expr(expr, succ)\n         }\n     }\n@@ -1336,7 +1336,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n \n         let cond_ln = match kind {\n             LoopLoop => ln,\n-            WhileLoop(ref cond) => self.propagate_through_expr(&**cond, ln),\n+            WhileLoop(ref cond) => self.propagate_through_expr(&cond, ln),\n         };\n         let body_ln = self.with_loop_nodes(expr.id, succ, ln, |this| {\n             this.propagate_through_block(body, cond_ln)\n@@ -1349,7 +1349,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n             let new_cond_ln = match kind {\n                 LoopLoop => ln,\n                 WhileLoop(ref cond) => {\n-                    self.propagate_through_expr(&**cond, ln)\n+                    self.propagate_through_expr(&cond, ln)\n                 }\n             };\n             assert!(cond_ln == new_cond_ln);\n@@ -1384,10 +1384,10 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n fn check_local(this: &mut Liveness, local: &hir::Local) {\n     match local.init {\n         Some(_) => {\n-            this.warn_about_unused_or_dead_vars_in_pat(&*local.pat);\n+            this.warn_about_unused_or_dead_vars_in_pat(&local.pat);\n         },\n         None => {\n-            this.pat_bindings(&*local.pat, |this, ln, var, sp, id| {\n+            this.pat_bindings(&local.pat, |this, ln, var, sp, id| {\n                 this.warn_about_unused(sp, id, ln, var);\n             })\n         }\n@@ -1409,28 +1409,28 @@ fn check_arm(this: &mut Liveness, arm: &hir::Arm) {\n fn check_expr(this: &mut Liveness, expr: &Expr) {\n     match expr.node {\n       hir::ExprAssign(ref l, _) => {\n-        this.check_lvalue(&**l);\n+        this.check_lvalue(&l);\n \n         intravisit::walk_expr(this, expr);\n       }\n \n       hir::ExprAssignOp(_, ref l, _) => {\n-        this.check_lvalue(&**l);\n+        this.check_lvalue(&l);\n \n         intravisit::walk_expr(this, expr);\n       }\n \n       hir::ExprInlineAsm(ref ia) => {\n         for &(_, ref input) in &ia.inputs {\n-          this.visit_expr(&**input);\n+          this.visit_expr(&input);\n         }\n \n         // Output operands must be lvalues\n         for out in &ia.outputs {\n           if !out.is_indirect {\n-            this.check_lvalue(&*out.expr);\n+            this.check_lvalue(&out.expr);\n           }\n-          this.visit_expr(&*out.expr);\n+          this.visit_expr(&out.expr);\n         }\n \n         intravisit::walk_expr(this, expr);\n@@ -1496,7 +1496,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n                         None if !body.stmts.is_empty() =>\n                             match body.stmts.first().unwrap().node {\n                                 hir::StmtSemi(ref e, _) => {\n-                                    self.ir.tcx.expr_ty(&**e) == t_ret\n+                                    self.ir.tcx.expr_ty(&e) == t_ret\n                                 },\n                                 _ => false\n                             },\n@@ -1565,7 +1565,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n     fn warn_about_unused_args(&self, decl: &hir::FnDecl, entry_ln: LiveNode) {\n         for arg in &decl.inputs {\n             pat_util::pat_bindings(&self.ir.tcx.def_map,\n-                                   &*arg.pat,\n+                                   &arg.pat,\n                                    |_bm, p_id, sp, path1| {\n                 let var = self.variable(p_id, sp);\n                 // Ignore unused self."}, {"sha": "71af07c21cf500738d5e6127260b3f3a192ecb82", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/3548b8c273d9feb0291e97a928c4f48e01daf0f9/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3548b8c273d9feb0291e97a928c4f48e01daf0f9/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=3548b8c273d9feb0291e97a928c4f48e01daf0f9", "patch": "@@ -463,12 +463,12 @@ impl<'t, 'a,'tcx> MemCategorizationContext<'t, 'a, 'tcx> {\n         let expr_ty = try!(self.expr_ty(expr));\n         match expr.node {\n           hir::ExprUnary(hir::UnDeref, ref e_base) => {\n-            let base_cmt = try!(self.cat_expr(&**e_base));\n+            let base_cmt = try!(self.cat_expr(&e_base));\n             self.cat_deref(expr, base_cmt, 0, None)\n           }\n \n           hir::ExprField(ref base, f_name) => {\n-            let base_cmt = try!(self.cat_expr(&**base));\n+            let base_cmt = try!(self.cat_expr(&base));\n             debug!(\"cat_expr(cat_field): id={} expr={:?} base={:?}\",\n                    expr.id,\n                    expr,\n@@ -477,7 +477,7 @@ impl<'t, 'a,'tcx> MemCategorizationContext<'t, 'a, 'tcx> {\n           }\n \n           hir::ExprTupField(ref base, idx) => {\n-            let base_cmt = try!(self.cat_expr(&**base));\n+            let base_cmt = try!(self.cat_expr(&base));\n             Ok(self.cat_tup_field(expr, base_cmt, idx.node, expr_ty))\n           }\n \n@@ -508,7 +508,7 @@ impl<'t, 'a,'tcx> MemCategorizationContext<'t, 'a, 'tcx> {\n                     self.cat_deref_common(expr, base_cmt, 1, elem_ty, Some(context), true)\n                 }\n                 None => {\n-                    self.cat_index(expr, try!(self.cat_expr(&**base)), context)\n+                    self.cat_index(expr, try!(self.cat_expr(&base)), context)\n                 }\n             }\n           }\n@@ -519,7 +519,7 @@ impl<'t, 'a,'tcx> MemCategorizationContext<'t, 'a, 'tcx> {\n           }\n \n           hir::ExprType(ref e, _) => {\n-            self.cat_expr(&**e)\n+            self.cat_expr(&e)\n           }\n \n           hir::ExprAddrOf(..) | hir::ExprCall(..) |\n@@ -584,7 +584,7 @@ impl<'t, 'a,'tcx> MemCategorizationContext<'t, 'a, 'tcx> {\n                           None => {\n                               self.tcx().sess.span_bug(\n                                   span,\n-                                  &*format!(\"No closure kind for {:?}\", closure_id));\n+                                  &format!(\"No closure kind for {:?}\", closure_id));\n                           }\n                       }\n                   }\n@@ -1234,29 +1234,29 @@ impl<'t, 'a,'tcx> MemCategorizationContext<'t, 'a, 'tcx> {\n                 Some(Def::Variant(..)) => {\n                     // variant(x, y, z)\n                     for (i, subpat) in subpats.iter().enumerate() {\n-                        let subpat_ty = try!(self.pat_ty(&**subpat)); // see (*2)\n+                        let subpat_ty = try!(self.pat_ty(&subpat)); // see (*2)\n \n                         let subcmt =\n                             self.cat_imm_interior(\n                                 pat, cmt.clone(), subpat_ty,\n                                 InteriorField(PositionalField(i)));\n \n-                        try!(self.cat_pattern_(subcmt, &**subpat, op));\n+                        try!(self.cat_pattern_(subcmt, &subpat, op));\n                     }\n                 }\n                 Some(Def::Struct(..)) => {\n                     for (i, subpat) in subpats.iter().enumerate() {\n-                        let subpat_ty = try!(self.pat_ty(&**subpat)); // see (*2)\n+                        let subpat_ty = try!(self.pat_ty(&subpat)); // see (*2)\n                         let cmt_field =\n                             self.cat_imm_interior(\n                                 pat, cmt.clone(), subpat_ty,\n                                 InteriorField(PositionalField(i)));\n-                        try!(self.cat_pattern_(cmt_field, &**subpat, op));\n+                        try!(self.cat_pattern_(cmt_field, &subpat, op));\n                     }\n                 }\n                 Some(Def::Const(..)) | Some(Def::AssociatedConst(..)) => {\n                     for subpat in subpats {\n-                        try!(self.cat_pattern_(cmt.clone(), &**subpat, op));\n+                        try!(self.cat_pattern_(cmt.clone(), &subpat, op));\n                     }\n                 }\n                 _ => {\n@@ -1272,7 +1272,7 @@ impl<'t, 'a,'tcx> MemCategorizationContext<'t, 'a, 'tcx> {\n           }\n \n           hir::PatIdent(_, _, Some(ref subpat)) => {\n-              try!(self.cat_pattern_(cmt, &**subpat, op));\n+              try!(self.cat_pattern_(cmt, &subpat, op));\n           }\n \n           hir::PatIdent(_, _, None) => {\n@@ -1282,21 +1282,21 @@ impl<'t, 'a,'tcx> MemCategorizationContext<'t, 'a, 'tcx> {\n           hir::PatStruct(_, ref field_pats, _) => {\n             // {f1: p1, ..., fN: pN}\n             for fp in field_pats {\n-                let field_ty = try!(self.pat_ty(&*fp.node.pat)); // see (*2)\n+                let field_ty = try!(self.pat_ty(&fp.node.pat)); // see (*2)\n                 let cmt_field = self.cat_field(pat, cmt.clone(), fp.node.name, field_ty);\n-                try!(self.cat_pattern_(cmt_field, &*fp.node.pat, op));\n+                try!(self.cat_pattern_(cmt_field, &fp.node.pat, op));\n             }\n           }\n \n           hir::PatTup(ref subpats) => {\n             // (p1, ..., pN)\n             for (i, subpat) in subpats.iter().enumerate() {\n-                let subpat_ty = try!(self.pat_ty(&**subpat)); // see (*2)\n+                let subpat_ty = try!(self.pat_ty(&subpat)); // see (*2)\n                 let subcmt =\n                     self.cat_imm_interior(\n                         pat, cmt.clone(), subpat_ty,\n                         InteriorField(PositionalField(i)));\n-                try!(self.cat_pattern_(subcmt, &**subpat, op));\n+                try!(self.cat_pattern_(subcmt, &subpat, op));\n             }\n           }\n \n@@ -1305,23 +1305,23 @@ impl<'t, 'a,'tcx> MemCategorizationContext<'t, 'a, 'tcx> {\n             // PatRegion since that information is already contained\n             // in the type.\n             let subcmt = try!(self.cat_deref(pat, cmt, 0, None));\n-              try!(self.cat_pattern_(subcmt, &**subpat, op));\n+              try!(self.cat_pattern_(subcmt, &subpat, op));\n           }\n \n           hir::PatVec(ref before, ref slice, ref after) => {\n               let context = InteriorOffsetKind::Pattern;\n               let vec_cmt = try!(self.deref_vec(pat, cmt, context));\n               let elt_cmt = try!(self.cat_index(pat, vec_cmt, context));\n               for before_pat in before {\n-                  try!(self.cat_pattern_(elt_cmt.clone(), &**before_pat, op));\n+                  try!(self.cat_pattern_(elt_cmt.clone(), &before_pat, op));\n               }\n               if let Some(ref slice_pat) = *slice {\n-                  let slice_ty = try!(self.pat_ty(&**slice_pat));\n+                  let slice_ty = try!(self.pat_ty(&slice_pat));\n                   let slice_cmt = self.cat_rvalue_node(pat.id(), pat.span(), slice_ty);\n-                  try!(self.cat_pattern_(slice_cmt, &**slice_pat, op));\n+                  try!(self.cat_pattern_(slice_cmt, &slice_pat, op));\n               }\n               for after_pat in after {\n-                  try!(self.cat_pattern_(elt_cmt.clone(), &**after_pat, op));\n+                  try!(self.cat_pattern_(elt_cmt.clone(), &after_pat, op));\n               }\n           }\n "}, {"sha": "614d9be147bd874d27ad4628a87fba03a361eda6", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3548b8c273d9feb0291e97a928c4f48e01daf0f9/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3548b8c273d9feb0291e97a928c4f48e01daf0f9/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=3548b8c273d9feb0291e97a928c4f48e01daf0f9", "patch": "@@ -65,7 +65,7 @@ fn method_might_be_inlined(tcx: &ty::ctxt, sig: &hir::MethodSig,\n     if let Some(impl_node_id) = tcx.map.as_local_node_id(impl_src) {\n         match tcx.map.find(impl_node_id) {\n             Some(ast_map::NodeItem(item)) =>\n-                item_might_be_inlined(&*item),\n+                item_might_be_inlined(&item),\n             Some(..) | None =>\n                 tcx.sess.span_bug(impl_item.span, \"impl did is not an item\")\n         }\n@@ -166,7 +166,7 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n         match self.tcx.map.find(node_id) {\n             Some(ast_map::NodeItem(item)) => {\n                 match item.node {\n-                    hir::ItemFn(..) => item_might_be_inlined(&*item),\n+                    hir::ItemFn(..) => item_might_be_inlined(&item),\n                     _ => false,\n                 }\n             }\n@@ -255,16 +255,16 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n             ast_map::NodeItem(item) => {\n                 match item.node {\n                     hir::ItemFn(_, _, _, _, _, ref search_block) => {\n-                        if item_might_be_inlined(&*item) {\n-                            intravisit::walk_block(self, &**search_block)\n+                        if item_might_be_inlined(&item) {\n+                            intravisit::walk_block(self, &search_block)\n                         }\n                     }\n \n                     // Reachable constants will be inlined into other crates\n                     // unconditionally, so we need to make sure that their\n                     // contents are also reachable.\n                     hir::ItemConst(_, ref init) => {\n-                        self.visit_expr(&**init);\n+                        self.visit_expr(&init);\n                     }\n \n                     // These are normal, nothing reachable about these\n@@ -285,7 +285,7 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n                         // Keep going, nothing to get exported\n                     }\n                     hir::ConstTraitItem(_, Some(ref expr)) => {\n-                        self.visit_expr(&*expr);\n+                        self.visit_expr(&expr);\n                     }\n                     hir::MethodTraitItem(_, Some(ref body)) => {\n                         intravisit::walk_block(self, body);\n@@ -296,7 +296,7 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n             ast_map::NodeImplItem(impl_item) => {\n                 match impl_item.node {\n                     hir::ImplItemKind::Const(_, ref expr) => {\n-                        self.visit_expr(&*expr);\n+                        self.visit_expr(&expr);\n                     }\n                     hir::ImplItemKind::Method(ref sig, ref body) => {\n                         let did = self.tcx.map.get_parent_did(search_item);"}, {"sha": "81d2f37bfd99e2158414f71b970773467f2d13d9", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/3548b8c273d9feb0291e97a928c4f48e01daf0f9/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3548b8c273d9feb0291e97a928c4f48e01daf0f9/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=3548b8c273d9feb0291e97a928c4f48e01daf0f9", "patch": "@@ -933,13 +933,13 @@ fn resolve_local(visitor: &mut RegionResolutionVisitor, local: &hir::Local) {\n \n     match local.init {\n         Some(ref expr) => {\n-            record_rvalue_scope_if_borrow_expr(visitor, &**expr, blk_scope);\n+            record_rvalue_scope_if_borrow_expr(visitor, &expr, blk_scope);\n \n             let is_borrow =\n-                if let Some(ref ty) = local.ty { is_borrowed_ty(&**ty) } else { false };\n+                if let Some(ref ty) = local.ty { is_borrowed_ty(&ty) } else { false };\n \n-            if is_binding_pat(&*local.pat) || is_borrow {\n-                record_rvalue_scope(visitor, &**expr, blk_scope);\n+            if is_binding_pat(&local.pat) || is_borrow {\n+                record_rvalue_scope(visitor, &expr, blk_scope);\n             }\n         }\n \n@@ -961,22 +961,22 @@ fn resolve_local(visitor: &mut RegionResolutionVisitor, local: &hir::Local) {\n             hir::PatIdent(hir::BindByRef(_), _, _) => true,\n \n             hir::PatStruct(_, ref field_pats, _) => {\n-                field_pats.iter().any(|fp| is_binding_pat(&*fp.node.pat))\n+                field_pats.iter().any(|fp| is_binding_pat(&fp.node.pat))\n             }\n \n             hir::PatVec(ref pats1, ref pats2, ref pats3) => {\n-                pats1.iter().any(|p| is_binding_pat(&**p)) ||\n-                pats2.iter().any(|p| is_binding_pat(&**p)) ||\n-                pats3.iter().any(|p| is_binding_pat(&**p))\n+                pats1.iter().any(|p| is_binding_pat(&p)) ||\n+                pats2.iter().any(|p| is_binding_pat(&p)) ||\n+                pats3.iter().any(|p| is_binding_pat(&p))\n             }\n \n             hir::PatEnum(_, Some(ref subpats)) |\n             hir::PatTup(ref subpats) => {\n-                subpats.iter().any(|p| is_binding_pat(&**p))\n+                subpats.iter().any(|p| is_binding_pat(&p))\n             }\n \n             hir::PatBox(ref subpat) => {\n-                is_binding_pat(&**subpat)\n+                is_binding_pat(&subpat)\n             }\n \n             _ => false,\n@@ -1006,30 +1006,30 @@ fn resolve_local(visitor: &mut RegionResolutionVisitor, local: &hir::Local) {\n                                           blk_id: CodeExtent) {\n         match expr.node {\n             hir::ExprAddrOf(_, ref subexpr) => {\n-                record_rvalue_scope_if_borrow_expr(visitor, &**subexpr, blk_id);\n-                record_rvalue_scope(visitor, &**subexpr, blk_id);\n+                record_rvalue_scope_if_borrow_expr(visitor, &subexpr, blk_id);\n+                record_rvalue_scope(visitor, &subexpr, blk_id);\n             }\n             hir::ExprStruct(_, ref fields, _) => {\n                 for field in fields {\n                     record_rvalue_scope_if_borrow_expr(\n-                        visitor, &*field.expr, blk_id);\n+                        visitor, &field.expr, blk_id);\n                 }\n             }\n             hir::ExprVec(ref subexprs) |\n             hir::ExprTup(ref subexprs) => {\n                 for subexpr in subexprs {\n                     record_rvalue_scope_if_borrow_expr(\n-                        visitor, &**subexpr, blk_id);\n+                        visitor, &subexpr, blk_id);\n                 }\n             }\n             hir::ExprCast(ref subexpr, _) => {\n-                record_rvalue_scope_if_borrow_expr(visitor, &**subexpr, blk_id)\n+                record_rvalue_scope_if_borrow_expr(visitor, &subexpr, blk_id)\n             }\n             hir::ExprBlock(ref block) => {\n                 match block.expr {\n                     Some(ref subexpr) => {\n                         record_rvalue_scope_if_borrow_expr(\n-                            visitor, &**subexpr, blk_id);\n+                            visitor, &subexpr, blk_id);\n                     }\n                     None => { }\n                 }\n@@ -1072,7 +1072,7 @@ fn resolve_local(visitor: &mut RegionResolutionVisitor, local: &hir::Local) {\n                 hir::ExprField(ref subexpr, _) |\n                 hir::ExprTupField(ref subexpr, _) |\n                 hir::ExprIndex(ref subexpr, _) => {\n-                    expr = &**subexpr;\n+                    expr = &subexpr;\n                 }\n                 _ => {\n                     return;"}, {"sha": "f29e14f67d73fa7b3407ecd70d2e08b53be9dd80", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3548b8c273d9feb0291e97a928c4f48e01daf0f9/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3548b8c273d9feb0291e97a928c4f48e01daf0f9/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=3548b8c273d9feb0291e97a928c4f48e01daf0f9", "patch": "@@ -256,7 +256,7 @@ impl<'a, 'v> Visitor<'v> for LifetimeContext<'a> {\n         for ty_param in generics.ty_params.iter() {\n             walk_list!(self, visit_ty_param_bound, &ty_param.bounds);\n             match ty_param.default {\n-                Some(ref ty) => self.visit_ty(&**ty),\n+                Some(ref ty) => self.visit_ty(&ty),\n                 None => {}\n             }\n         }\n@@ -271,13 +271,13 @@ impl<'a, 'v> Visitor<'v> for LifetimeContext<'a> {\n                         let result = self.with(LateScope(bound_lifetimes, self.scope),\n                                                |old_scope, this| {\n                             this.check_lifetime_defs(old_scope, bound_lifetimes);\n-                            this.visit_ty(&**bounded_ty);\n+                            this.visit_ty(&bounded_ty);\n                             walk_list!(this, visit_ty_param_bound, bounds);\n                         });\n                         self.trait_ref_hack = false;\n                         result\n                     } else {\n-                        self.visit_ty(&**bounded_ty);\n+                        self.visit_ty(&bounded_ty);\n                         walk_list!(self, visit_ty_param_bound, bounds);\n                     }\n                 }\n@@ -295,7 +295,7 @@ impl<'a, 'v> Visitor<'v> for LifetimeContext<'a> {\n                                                                          ref ty,\n                                                                          .. }) => {\n                     self.visit_path(path, id);\n-                    self.visit_ty(&**ty);\n+                    self.visit_ty(&ty);\n                 }\n             }\n         }\n@@ -810,7 +810,7 @@ fn early_bound_lifetime_names(generics: &hir::Generics) -> Vec<ast::Name> {\n                 &hir::WherePredicate::BoundPredicate(hir::WhereBoundPredicate{ref bounds,\n                                                                               ref bounded_ty,\n                                                                               ..}) => {\n-                    collector.visit_ty(&**bounded_ty);\n+                    collector.visit_ty(&bounded_ty);\n                     walk_list!(&mut collector, visit_ty_param_bound, bounds);\n                 }\n                 &hir::WherePredicate::RegionPredicate(hir::WhereRegionPredicate{ref lifetime,"}, {"sha": "fac53ec140dbcad62fdedcf5a2746e52d8e4d390", "filename": "src/librustc/middle/traits/error_reporting.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3548b8c273d9feb0291e97a928c4f48e01daf0f9/src%2Flibrustc%2Fmiddle%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3548b8c273d9feb0291e97a928c4f48e01daf0f9/src%2Flibrustc%2Fmiddle%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Ferror_reporting.rs?ref=3548b8c273d9feb0291e97a928c4f48e01daf0f9", "patch": "@@ -770,7 +770,7 @@ fn note_obligation_cause_code<'a, 'tcx, T>(infcx: &InferCtxt<'a, 'tcx>,\n                                        err,\n                                        &parent_predicate,\n                                        cause_span,\n-                                       &*data.parent_code);\n+                                       &data.parent_code);\n         }\n         ObligationCauseCode::ImplDerivedObligation(ref data) => {\n             let parent_trait_ref = infcx.resolve_type_vars_if_possible(&data.parent_trait_ref);\n@@ -784,7 +784,7 @@ fn note_obligation_cause_code<'a, 'tcx, T>(infcx: &InferCtxt<'a, 'tcx>,\n                                        err,\n                                        &parent_predicate,\n                                        cause_span,\n-                                       &*data.parent_code);\n+                                       &data.parent_code);\n         }\n         ObligationCauseCode::CompareImplMethodObligation => {\n             err.fileline_note("}, {"sha": "7ffdc3bdef27ad0fe491e07cec809ebf82e2262f", "filename": "src/librustc/middle/traits/object_safety.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3548b8c273d9feb0291e97a928c4f48e01daf0f9/src%2Flibrustc%2Fmiddle%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3548b8c273d9feb0291e97a928c4f48e01daf0f9/src%2Flibrustc%2Fmiddle%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fobject_safety.rs?ref=3548b8c273d9feb0291e97a928c4f48e01daf0f9", "patch": "@@ -116,7 +116,7 @@ fn object_safety_violations_for_trait<'tcx>(tcx: &ty::ctxt<'tcx>,\n         .filter_map(|item| {\n             match *item {\n                 ty::MethodTraitItem(ref m) => {\n-                    object_safety_violation_for_method(tcx, trait_def_id, &**m)\n+                    object_safety_violation_for_method(tcx, trait_def_id, &m)\n                         .map(|code| ObjectSafetyViolation::Method(m.clone(), code))\n                 }\n                 _ => None,"}, {"sha": "888a623b24a83d1960d14ffb14264d396faa09ef", "filename": "src/librustc/util/common.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3548b8c273d9feb0291e97a928c4f48e01daf0f9/src%2Flibrustc%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3548b8c273d9feb0291e97a928c4f48e01daf0f9/src%2Flibrustc%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fcommon.rs?ref=3548b8c273d9feb0291e97a928c4f48e01daf0f9", "patch": "@@ -196,7 +196,7 @@ pub fn block_query<P>(b: &hir::Block, p: P) -> bool where P: FnMut(&hir::Expr) -\n         p: p,\n         flag: false,\n     };\n-    intravisit::walk_block(&mut v, &*b);\n+    intravisit::walk_block(&mut v, &b);\n     return v.flag;\n }\n "}, {"sha": "f19a8658a057b5e1fb0332175f3bac1ccef90604", "filename": "src/librustc_borrowck/borrowck/check_loans.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/3548b8c273d9feb0291e97a928c4f48e01daf0f9/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3548b8c273d9feb0291e97a928c4f48e01daf0f9/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs?ref=3548b8c273d9feb0291e97a928c4f48e01daf0f9", "patch": "@@ -51,13 +51,13 @@ fn owned_ptr_base_path<'a, 'tcx>(loan_path: &'a LoanPath<'tcx>) -> &'a LoanPath<\n         match loan_path.kind {\n             LpVar(_) | LpUpvar(_) => None,\n             LpExtend(ref lp_base, _, LpDeref(mc::Unique)) => {\n-                match helper(&**lp_base) {\n+                match helper(&lp_base) {\n                     v @ Some(_) => v,\n-                    None => Some(&**lp_base)\n+                    None => Some(&lp_base)\n                 }\n             }\n             LpDowncast(ref lp_base, _) |\n-            LpExtend(ref lp_base, _, _) => helper(&**lp_base)\n+            LpExtend(ref lp_base, _, _) => helper(&lp_base)\n         }\n     }\n }\n@@ -319,7 +319,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n                 }\n                 LpDowncast(ref lp_base, _) |\n                 LpExtend(ref lp_base, _, _) => {\n-                    loan_path = &**lp_base;\n+                    loan_path = &lp_base;\n                 }\n             }\n \n@@ -442,21 +442,21 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n             //     borrow prevents subsequent moves, borrows, or modification of `x` until the\n             //     borrow ends\n \n-            let common = new_loan.loan_path.common(&*old_loan.loan_path);\n+            let common = new_loan.loan_path.common(&old_loan.loan_path);\n             let (nl, ol, new_loan_msg, old_loan_msg) =\n-                if new_loan.loan_path.has_fork(&*old_loan.loan_path) && common.is_some() {\n+                if new_loan.loan_path.has_fork(&old_loan.loan_path) && common.is_some() {\n                     let nl = self.bccx.loan_path_to_string(&common.unwrap());\n                     let ol = nl.clone();\n                     let new_loan_msg = format!(\" (here through borrowing `{}`)\",\n                                                self.bccx.loan_path_to_string(\n-                                                   &*new_loan.loan_path));\n+                                                   &new_loan.loan_path));\n                     let old_loan_msg = format!(\" (through borrowing `{}`)\",\n                                                self.bccx.loan_path_to_string(\n-                                                   &*old_loan.loan_path));\n+                                                   &old_loan.loan_path));\n                     (nl, ol, new_loan_msg, old_loan_msg)\n                 } else {\n-                    (self.bccx.loan_path_to_string(&*new_loan.loan_path),\n-                     self.bccx.loan_path_to_string(&*old_loan.loan_path),\n+                    (self.bccx.loan_path_to_string(&new_loan.loan_path),\n+                     self.bccx.loan_path_to_string(&old_loan.loan_path),\n                      String::new(), String::new())\n                 };\n \n@@ -578,7 +578,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n             Some(lp) => {\n                 let moved_value_use_kind = match mode {\n                     euv::Copy => {\n-                        self.check_for_copy_of_frozen_path(id, span, &*lp);\n+                        self.check_for_copy_of_frozen_path(id, span, &lp);\n                         MovedInUse\n                     }\n                     euv::Move(_) => {\n@@ -593,7 +593,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n                             }\n                             Some(move_kind) => {\n                                 self.check_for_move_of_borrowed_path(id, span,\n-                                                                     &*lp, move_kind);\n+                                                                     &lp, move_kind);\n                                 if move_kind == move_data::Captured {\n                                     MovedInCapture\n                                 } else {\n@@ -622,7 +622,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n                                  &self.bccx.loan_path_to_string(copy_path))\n                     .span_note(loan_span,\n                                &format!(\"borrow of `{}` occurs here\",\n-                                       &self.bccx.loan_path_to_string(&*loan_path))\n+                                       &self.bccx.loan_path_to_string(&loan_path))\n                                )\n                     .emit();\n             }\n@@ -656,7 +656,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n                 err.span_note(\n                     loan_span,\n                     &format!(\"borrow of `{}` occurs here\",\n-                            &self.bccx.loan_path_to_string(&*loan_path))\n+                            &self.bccx.loan_path_to_string(&loan_path))\n                     );\n                 err.emit();\n             }\n@@ -706,7 +706,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n             self.bccx.report_use_of_moved_value(\n                 span,\n                 use_kind,\n-                &**lp,\n+                &lp,\n                 the_move,\n                 moved_lp,\n                 self.param_env);\n@@ -760,7 +760,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n                             self.bccx\n                                 .report_partial_reinitialization_of_uninitialized_structure(\n                                     span,\n-                                    &*loan_path);\n+                                    &loan_path);\n                             false\n                         });\n                         return;\n@@ -790,8 +790,8 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n         // Check that we don't invalidate any outstanding loans\n         if let Some(loan_path) = opt_loan_path(&assignee_cmt) {\n             let scope = self.tcx().region_maps.node_extent(assignment_id);\n-            self.each_in_scope_loan_affecting_path(scope, &*loan_path, |loan| {\n-                self.report_illegal_mutation(assignment_span, &*loan_path, loan);\n+            self.each_in_scope_loan_affecting_path(scope, &loan_path, |loan| {\n+                self.report_illegal_mutation(assignment_span, &loan_path, loan);\n                 false\n             });\n         }\n@@ -807,7 +807,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n                 } else {\n                     self.bccx.report_reassigned_immutable_variable(\n                         assignment_span,\n-                        &*lp,\n+                        &lp,\n                         assign);\n                 }\n                 false"}, {"sha": "38157d04a5d6d605f475579eecf6479763a2d76d", "filename": "src/librustc_borrowck/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3548b8c273d9feb0291e97a928c4f48e01daf0f9/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3548b8c273d9feb0291e97a928c4f48e01daf0f9/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=3548b8c273d9feb0291e97a928c4f48e01daf0f9", "patch": "@@ -386,11 +386,11 @@ impl<'a, 'tcx> GatherLoanCtxt<'a, 'tcx> {\n                 let gen_scope = self.compute_gen_scope(borrow_scope, loan_scope);\n                 debug!(\"gen_scope = {:?}\", gen_scope);\n \n-                let kill_scope = self.compute_kill_scope(loan_scope, &*loan_path);\n+                let kill_scope = self.compute_kill_scope(loan_scope, &loan_path);\n                 debug!(\"kill_scope = {:?}\", kill_scope);\n \n                 if req_kind == ty::MutBorrow {\n-                    self.mark_loan_path_as_mutated(&*loan_path);\n+                    self.mark_loan_path_as_mutated(&loan_path);\n                 }\n \n                 Loan {\n@@ -452,7 +452,7 @@ impl<'a, 'tcx> GatherLoanCtxt<'a, 'tcx> {\n             LpDowncast(ref base, _) |\n             LpExtend(ref base, mc::McInherited, _) |\n             LpExtend(ref base, mc::McDeclared, _) => {\n-                self.mark_loan_path_as_mutated(&**base);\n+                self.mark_loan_path_as_mutated(&base);\n             }\n             LpExtend(_, mc::McImmutable, _) => {\n                 // Nothing to do.\n@@ -527,7 +527,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for StaticInitializerCtxt<'a, 'tcx> {\n         if let hir::ExprAddrOf(mutbl, ref base) = ex.node {\n             let infcx = infer::new_infer_ctxt(self.bccx.tcx, &self.bccx.tcx.tables, None);\n             let mc = mc::MemCategorizationContext::new(&infcx);\n-            let base_cmt = mc.cat_expr(&**base).unwrap();\n+            let base_cmt = mc.cat_expr(&base).unwrap();\n             let borrow_kind = ty::BorrowKind::from_mutbl(mutbl);\n             // Check that we don't allow borrows of unsafe static items.\n             if check_aliasability(self.bccx, ex.span,"}, {"sha": "1fa36a98ec5d975f42d211024aca0ceded036cf2", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/3548b8c273d9feb0291e97a928c4f48e01daf0f9/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3548b8c273d9feb0291e97a928c4f48e01daf0f9/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=3548b8c273d9feb0291e97a928c4f48e01daf0f9", "patch": "@@ -85,14 +85,14 @@ impl<'a, 'tcx, 'v> Visitor<'v> for BorrowckCtxt<'a, 'tcx> {\n \n     fn visit_trait_item(&mut self, ti: &hir::TraitItem) {\n         if let hir::ConstTraitItem(_, Some(ref expr)) = ti.node {\n-            gather_loans::gather_loans_in_static_initializer(self, &*expr);\n+            gather_loans::gather_loans_in_static_initializer(self, &expr);\n         }\n         intravisit::walk_trait_item(self, ti);\n     }\n \n     fn visit_impl_item(&mut self, ii: &hir::ImplItem) {\n         if let hir::ImplItemKind::Const(_, ref expr) = ii.node {\n-            gather_loans::gather_loans_in_static_initializer(self, &*expr);\n+            gather_loans::gather_loans_in_static_initializer(self, &expr);\n         }\n         intravisit::walk_impl_item(self, ii);\n     }\n@@ -139,7 +139,7 @@ fn borrowck_item(this: &mut BorrowckCtxt, item: &hir::Item) {\n     match item.node {\n         hir::ItemStatic(_, _, ref ex) |\n         hir::ItemConst(_, ref ex) => {\n-            gather_loans::gather_loans_in_static_initializer(this, &**ex);\n+            gather_loans::gather_loans_in_static_initializer(this, &ex);\n         }\n         _ => { }\n     }\n@@ -251,9 +251,9 @@ pub fn build_borrowck_dataflow_data_for_fn<'a, 'tcx>(\n \n     let dataflow_data = build_borrowck_dataflow_data(&mut bccx,\n                                                      fn_parts.kind,\n-                                                     &*fn_parts.decl,\n+                                                     &fn_parts.decl,\n                                                      cfg,\n-                                                     &*fn_parts.body,\n+                                                     &fn_parts.body,\n                                                      fn_parts.span,\n                                                      fn_parts.id);\n \n@@ -426,12 +426,12 @@ impl<'tcx> LoanPath<'tcx> {\n             (&LpExtend(ref base, _, LpInterior(opt_variant_id, id)),\n              &LpExtend(ref base2, _, LpInterior(opt_variant_id2, id2))) =>\n                 if id == id2 && opt_variant_id == opt_variant_id2 {\n-                    base.has_fork(&**base2)\n+                    base.has_fork(&base2)\n                 } else {\n                     true\n                 },\n             (&LpExtend(ref base, _, LpDeref(_)), _) => base.has_fork(other),\n-            (_, &LpExtend(ref base, _, LpDeref(_))) => self.has_fork(&**base),\n+            (_, &LpExtend(ref base, _, LpDeref(_))) => self.has_fork(&base),\n             _ => false,\n         }\n     }\n@@ -449,7 +449,7 @@ impl<'tcx> LoanPath<'tcx> {\n             (&LpExtend(ref base, a, LpInterior(opt_variant_id, id)),\n              &LpExtend(ref base2, _, LpInterior(opt_variant_id2, id2))) => {\n                 if id == id2 && opt_variant_id == opt_variant_id2 {\n-                    base.common(&**base2).map(|x| {\n+                    base.common(&base2).map(|x| {\n                         let xd = x.depth();\n                         if base.depth() == xd && base2.depth() == xd {\n                             assert_eq!(base.ty, base2.ty);\n@@ -463,11 +463,11 @@ impl<'tcx> LoanPath<'tcx> {\n                         }\n                     })\n                 } else {\n-                    base.common(&**base2)\n+                    base.common(&base2)\n                 }\n             }\n             (&LpExtend(ref base, _, LpDeref(_)), _) => base.common(other),\n-            (_, &LpExtend(ref other, _, LpDeref(_))) => self.common(&**other),\n+            (_, &LpExtend(ref other, _, LpDeref(_))) => self.common(&other),\n             (&LpVar(id), &LpVar(id2)) => {\n                 if id == id2 {\n                     assert_eq!(self.ty, other.ty);\n@@ -673,7 +673,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                                                      .map\n                                                      .find(the_move.id) {\n                     Some(hir_map::NodeExpr(expr)) => {\n-                        (self.tcx.expr_ty_adjusted(&*expr), expr.span)\n+                        (self.tcx.expr_ty_adjusted(&expr), expr.span)\n                     }\n                     r => {\n                         self.tcx.sess.bug(&format!(\"MoveExpr({}) maps to \\\n@@ -735,7 +735,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                                                      .map\n                                                      .find(the_move.id) {\n                     Some(hir_map::NodeExpr(expr)) => {\n-                        (self.tcx.expr_ty_adjusted(&*expr), expr.span)\n+                        (self.tcx.expr_ty_adjusted(&expr), expr.span)\n                     }\n                     r => {\n                         self.tcx.sess.bug(&format!(\"Captured({}) maps to \\\n@@ -833,19 +833,19 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n             err_mutbl => {\n                 let descr = match err.cmt.note {\n                     mc::NoteClosureEnv(_) | mc::NoteUpvarRef(_) => {\n-                        self.cmt_to_string(&*err.cmt)\n+                        self.cmt_to_string(&err.cmt)\n                     }\n                     _ => match opt_loan_path(&err.cmt) {\n                         None => {\n                             format!(\"{} {}\",\n                                     err.cmt.mutbl.to_user_str(),\n-                                    self.cmt_to_string(&*err.cmt))\n+                                    self.cmt_to_string(&err.cmt))\n                         }\n                         Some(lp) => {\n                             format!(\"{} {} `{}`\",\n                                     err.cmt.mutbl.to_user_str(),\n-                                    self.cmt_to_string(&*err.cmt),\n-                                    self.loan_path_to_string(&*lp))\n+                                    self.cmt_to_string(&err.cmt),\n+                                    self.loan_path_to_string(&lp))\n                         }\n                     }\n                 };\n@@ -876,7 +876,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                 let msg = match opt_loan_path(&err.cmt) {\n                     None => \"borrowed value\".to_string(),\n                     Some(lp) => {\n-                        format!(\"`{}`\", self.loan_path_to_string(&*lp))\n+                        format!(\"`{}`\", self.loan_path_to_string(&lp))\n                     }\n                 };\n                 format!(\"{} does not live long enough\", msg)\n@@ -1051,9 +1051,9 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n             err_borrowed_pointer_too_short(loan_scope, ptr_scope) => {\n                 let descr = match opt_loan_path(&err.cmt) {\n                     Some(lp) => {\n-                        format!(\"`{}`\", self.loan_path_to_string(&*lp))\n+                        format!(\"`{}`\", self.loan_path_to_string(&lp))\n                     }\n-                    None => self.cmt_to_string(&*err.cmt),\n+                    None => self.cmt_to_string(&err.cmt),\n                 };\n                 self.tcx.note_and_explain_region(\n                     db,\n@@ -1081,15 +1081,15 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n \n             LpDowncast(ref lp_base, variant_def_id) => {\n                 out.push('(');\n-                self.append_loan_path_to_string(&**lp_base, out);\n+                self.append_loan_path_to_string(&lp_base, out);\n                 out.push_str(DOWNCAST_PRINTED_OPERATOR);\n                 out.push_str(&self.tcx.item_path_str(variant_def_id));\n                 out.push(')');\n             }\n \n \n             LpExtend(ref lp_base, _, LpInterior(_, InteriorField(fname))) => {\n-                self.append_autoderefd_loan_path_to_string(&**lp_base, out);\n+                self.append_autoderefd_loan_path_to_string(&lp_base, out);\n                 match fname {\n                     mc::NamedField(fname) => {\n                         out.push('.');\n@@ -1103,13 +1103,13 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n             }\n \n             LpExtend(ref lp_base, _, LpInterior(_, InteriorElement(..))) => {\n-                self.append_autoderefd_loan_path_to_string(&**lp_base, out);\n+                self.append_autoderefd_loan_path_to_string(&lp_base, out);\n                 out.push_str(\"[..]\");\n             }\n \n             LpExtend(ref lp_base, _, LpDeref(_)) => {\n                 out.push('*');\n-                self.append_loan_path_to_string(&**lp_base, out);\n+                self.append_loan_path_to_string(&lp_base, out);\n             }\n         }\n     }\n@@ -1122,12 +1122,12 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                 // For a path like `(*x).f` or `(*x)[3]`, autoderef\n                 // rules would normally allow users to omit the `*x`.\n                 // So just serialize such paths to `x.f` or x[3]` respectively.\n-                self.append_autoderefd_loan_path_to_string(&**lp_base, out)\n+                self.append_autoderefd_loan_path_to_string(&lp_base, out)\n             }\n \n             LpDowncast(ref lp_base, variant_def_id) => {\n                 out.push('(');\n-                self.append_autoderefd_loan_path_to_string(&**lp_base, out);\n+                self.append_autoderefd_loan_path_to_string(&lp_base, out);\n                 out.push(':');\n                 out.push_str(&self.tcx.item_path_str(variant_def_id));\n                 out.push(')');"}, {"sha": "cbec32e358d81fbad18e71443939b3b3a9c43d15", "filename": "src/librustc_borrowck/borrowck/move_data.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3548b8c273d9feb0291e97a928c4f48e01daf0f9/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3548b8c273d9feb0291e97a928c4f48e01daf0f9/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs?ref=3548b8c273d9feb0291e97a928c4f48e01daf0f9", "patch": "@@ -207,7 +207,7 @@ fn loan_path_is_precise(loan_path: &LoanPath) -> bool {\n         }\n         LpDowncast(ref lp_base, _) |\n         LpExtend(ref lp_base, _, _) => {\n-            loan_path_is_precise(&**lp_base)\n+            loan_path_is_precise(&lp_base)\n         }\n     }\n }\n@@ -587,7 +587,7 @@ impl<'tcx> MoveData<'tcx> {\n         // assignment referring to another location.\n \n         let loan_path = self.path_loan_path(path);\n-        if loan_path_is_precise(&*loan_path) {\n+        if loan_path_is_precise(&loan_path) {\n             self.each_applicable_move(path, |move_index| {\n                 debug!(\"kill_moves add_kill {:?} kill_id={} move_index={}\",\n                        kill_kind, kill_id, move_index.get());\n@@ -700,7 +700,7 @@ impl<'a, 'tcx> FlowedMoveData<'a, 'tcx> {\n             if base_indices.iter().any(|x| x == &moved_path) {\n                 // Scenario 1 or 2: `loan_path` or some base path of\n                 // `loan_path` was moved.\n-                if !f(the_move, &*self.move_data.path_loan_path(moved_path)) {\n+                if !f(the_move, &self.move_data.path_loan_path(moved_path)) {\n                     ret = false;\n                 }\n             } else {\n@@ -710,7 +710,7 @@ impl<'a, 'tcx> FlowedMoveData<'a, 'tcx> {\n                             // Scenario 3: some extension of `loan_path`\n                             // was moved\n                             f(the_move,\n-                              &*self.move_data.path_loan_path(moved_path))\n+                              &self.move_data.path_loan_path(moved_path))\n                         } else {\n                             true\n                         }"}, {"sha": "7a5491cdbe7f3cd612a36456fd95d0090df018fd", "filename": "src/librustc_borrowck/graphviz.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3548b8c273d9feb0291e97a928c4f48e01daf0f9/src%2Flibrustc_borrowck%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3548b8c273d9feb0291e97a928c4f48e01daf0f9/src%2Flibrustc_borrowck%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fgraphviz.rs?ref=3548b8c273d9feb0291e97a928c4f48e01daf0f9", "patch": "@@ -87,7 +87,7 @@ impl<'a, 'tcx> DataflowLabeller<'a, 'tcx> {\n             if saw_some {\n                 set.push_str(\", \");\n             }\n-            let loan_str = self.borrowck_ctxt.loan_path_to_string(&*lp);\n+            let loan_str = self.borrowck_ctxt.loan_path_to_string(&lp);\n             set.push_str(&loan_str[..]);\n             saw_some = true;\n             true"}, {"sha": "6eede3070b27a3bce72ab43a90aef1f2b8e9b7d3", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3548b8c273d9feb0291e97a928c4f48e01daf0f9/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3548b8c273d9feb0291e97a928c4f48e01daf0f9/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=3548b8c273d9feb0291e97a928c4f48e01daf0f9", "patch": "@@ -567,7 +567,7 @@ pub fn phase_2_configure_and_expand(sess: &Session,\n \n     // Lint plugins are registered; now we can process command line flags.\n     if sess.opts.describe_lints {\n-        super::describe_lints(&*sess.lint_store.borrow(), true);\n+        super::describe_lints(&sess.lint_store.borrow(), true);\n         return Err(0);\n     }\n     try!(sess.track_errors(|| sess.lint_store.borrow_mut().process_command_line(sess)));"}, {"sha": "85f4992584c9aa6f08cf90e66f3730f8849cf55b", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3548b8c273d9feb0291e97a928c4f48e01daf0f9/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3548b8c273d9feb0291e97a928c4f48e01daf0f9/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=3548b8c273d9feb0291e97a928c4f48e01daf0f9", "patch": "@@ -1018,7 +1018,7 @@ pub fn diagnostics_registry() -> diagnostics::registry::Registry {\n     all_errors.extend_from_slice(&rustc_privacy::DIAGNOSTICS);\n     all_errors.extend_from_slice(&rustc_trans::DIAGNOSTICS);\n \n-    Registry::new(&*all_errors)\n+    Registry::new(&all_errors)\n }\n \n pub fn main() {"}, {"sha": "4a82aa7282599e2c18c5c65c172492f7e2c0a38f", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3548b8c273d9feb0291e97a928c4f48e01daf0f9/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3548b8c273d9feb0291e97a928c4f48e01daf0f9/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=3548b8c273d9feb0291e97a928c4f48e01daf0f9", "patch": "@@ -870,8 +870,8 @@ fn print_flowgraph<W: Write>(variants: Vec<borrowck_dot::Variant>,\n                              mut out: W)\n                              -> io::Result<()> {\n     let cfg = match code {\n-        blocks::BlockCode(block) => cfg::CFG::new(tcx, &*block),\n-        blocks::FnLikeCode(fn_like) => cfg::CFG::new(tcx, &*fn_like.body()),\n+        blocks::BlockCode(block) => cfg::CFG::new(tcx, &block),\n+        blocks::FnLikeCode(fn_like) => cfg::CFG::new(tcx, &fn_like.body()),\n     };\n     let labelled_edges = mode != PpFlowGraphMode::UnlabelledEdges;\n     let lcfg = LabelledCFG {"}, {"sha": "1425fbe9511a340b2666a14ab10778525a9d8fb6", "filename": "src/librustc_front/print/pprust.rs", "status": "modified", "additions": 100, "deletions": 101, "changes": 201, "blob_url": "https://github.com/rust-lang/rust/blob/3548b8c273d9feb0291e97a928c4f48e01daf0f9/src%2Flibrustc_front%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3548b8c273d9feb0291e97a928c4f48e01daf0f9/src%2Flibrustc_front%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_front%2Fprint%2Fpprust.rs?ref=3548b8c273d9feb0291e97a928c4f48e01daf0f9", "patch": "@@ -456,7 +456,7 @@ impl<'a> State<'a> {\n     }\n \n     pub fn commasep_exprs(&mut self, b: Breaks, exprs: &[P<hir::Expr>]) -> io::Result<()> {\n-        self.commasep_cmnt(b, exprs, |s, e| s.print_expr(&**e), |e| e.span)\n+        self.commasep_cmnt(b, exprs, |s, e| s.print_expr(&e), |e| e.span)\n     }\n \n     pub fn print_mod(&mut self, _mod: &hir::Mod, attrs: &[ast::Attribute]) -> io::Result<()> {\n@@ -492,7 +492,7 @@ impl<'a> State<'a> {\n         match ty.node {\n             hir::TyVec(ref ty) => {\n                 try!(word(&mut self.s, \"[\"));\n-                try!(self.print_type(&**ty));\n+                try!(self.print_type(&ty));\n                 try!(word(&mut self.s, \"]\"));\n             }\n             hir::TyPtr(ref mt) => {\n@@ -501,7 +501,7 @@ impl<'a> State<'a> {\n                     hir::MutMutable => try!(self.word_nbsp(\"mut\")),\n                     hir::MutImmutable => try!(self.word_nbsp(\"const\")),\n                 }\n-                try!(self.print_type(&*mt.ty));\n+                try!(self.print_type(&mt.ty));\n             }\n             hir::TyRptr(ref lifetime, ref mt) => {\n                 try!(word(&mut self.s, \"&\"));\n@@ -510,7 +510,7 @@ impl<'a> State<'a> {\n             }\n             hir::TyTup(ref elts) => {\n                 try!(self.popen());\n-                try!(self.commasep(Inconsistent, &elts[..], |s, ty| s.print_type(&**ty)));\n+                try!(self.commasep(Inconsistent, &elts[..], |s, ty| s.print_type(&ty)));\n                 if elts.len() == 1 {\n                     try!(word(&mut self.s, \",\"));\n                 }\n@@ -525,7 +525,7 @@ impl<'a> State<'a> {\n                         predicates: hir::HirVec::new(),\n                     },\n                 };\n-                try!(self.print_ty_fn(f.abi, f.unsafety, &*f.decl, None, &generics, None));\n+                try!(self.print_ty_fn(f.abi, f.unsafety, &f.decl, None, &generics, None));\n             }\n             hir::TyPath(None, ref path) => {\n                 try!(self.print_path(path, false, 0));\n@@ -534,22 +534,22 @@ impl<'a> State<'a> {\n                 try!(self.print_qpath(path, qself, false))\n             }\n             hir::TyObjectSum(ref ty, ref bounds) => {\n-                try!(self.print_type(&**ty));\n+                try!(self.print_type(&ty));\n                 try!(self.print_bounds(\"+\", &bounds[..]));\n             }\n             hir::TyPolyTraitRef(ref bounds) => {\n                 try!(self.print_bounds(\"\", &bounds[..]));\n             }\n             hir::TyFixedLengthVec(ref ty, ref v) => {\n                 try!(word(&mut self.s, \"[\"));\n-                try!(self.print_type(&**ty));\n+                try!(self.print_type(&ty));\n                 try!(word(&mut self.s, \"; \"));\n-                try!(self.print_expr(&**v));\n+                try!(self.print_expr(&v));\n                 try!(word(&mut self.s, \"]\"));\n             }\n             hir::TyTypeof(ref e) => {\n                 try!(word(&mut self.s, \"typeof(\"));\n-                try!(self.print_expr(&**e));\n+                try!(self.print_expr(&e));\n                 try!(word(&mut self.s, \")\"));\n             }\n             hir::TyInfer => {\n@@ -585,7 +585,7 @@ impl<'a> State<'a> {\n                 }\n                 try!(self.print_name(item.name));\n                 try!(self.word_space(\":\"));\n-                try!(self.print_type(&**t));\n+                try!(self.print_type(&t));\n                 try!(word(&mut self.s, \";\"));\n                 try!(self.end()); // end the head-ibox\n                 self.end() // end the outer cbox\n@@ -667,7 +667,7 @@ impl<'a> State<'a> {\n             }\n             hir::ItemUse(ref vp) => {\n                 try!(self.head(&visibility_qualified(item.vis, \"use\")));\n-                try!(self.print_view_path(&**vp));\n+                try!(self.print_view_path(&vp));\n                 try!(word(&mut self.s, \";\"));\n                 try!(self.end()); // end inner head-block\n                 try!(self.end()); // end outer head-block\n@@ -679,25 +679,25 @@ impl<'a> State<'a> {\n                 }\n                 try!(self.print_name(item.name));\n                 try!(self.word_space(\":\"));\n-                try!(self.print_type(&**ty));\n+                try!(self.print_type(&ty));\n                 try!(space(&mut self.s));\n                 try!(self.end()); // end the head-ibox\n \n                 try!(self.word_space(\"=\"));\n-                try!(self.print_expr(&**expr));\n+                try!(self.print_expr(&expr));\n                 try!(word(&mut self.s, \";\"));\n                 try!(self.end()); // end the outer cbox\n             }\n             hir::ItemConst(ref ty, ref expr) => {\n                 try!(self.head(&visibility_qualified(item.vis, \"const\")));\n                 try!(self.print_name(item.name));\n                 try!(self.word_space(\":\"));\n-                try!(self.print_type(&**ty));\n+                try!(self.print_type(&ty));\n                 try!(space(&mut self.s));\n                 try!(self.end()); // end the head-ibox\n \n                 try!(self.word_space(\"=\"));\n-                try!(self.print_expr(&**expr));\n+                try!(self.print_expr(&expr));\n                 try!(word(&mut self.s, \";\"));\n                 try!(self.end()); // end the outer cbox\n             }\n@@ -712,7 +712,7 @@ impl<'a> State<'a> {\n                                    None,\n                                    item.vis));\n                 try!(word(&mut self.s, \" \"));\n-                try!(self.print_block_with_attrs(&**body, &item.attrs));\n+                try!(self.print_block_with_attrs(&body, &item.attrs));\n             }\n             hir::ItemMod(ref _mod) => {\n                 try!(self.head(&visibility_qualified(item.vis, \"mod\")));\n@@ -740,7 +740,7 @@ impl<'a> State<'a> {\n                 try!(self.print_where_clause(&params.where_clause));\n                 try!(space(&mut self.s));\n                 try!(self.word_space(\"=\"));\n-                try!(self.print_type(&**ty));\n+                try!(self.print_type(&ty));\n                 try!(word(&mut self.s, \";\"));\n                 try!(self.end()); // end the outer ibox\n             }\n@@ -796,7 +796,7 @@ impl<'a> State<'a> {\n                     &None => {}\n                 }\n \n-                try!(self.print_type(&**ty));\n+                try!(self.print_type(&ty));\n                 try!(self.print_where_clause(&generics.where_clause));\n \n                 try!(space(&mut self.s));\n@@ -920,7 +920,7 @@ impl<'a> State<'a> {\n                         hir::UnnamedField(vis) => {\n                             try!(s.print_visibility(vis));\n                             try!(s.maybe_print_comment(field.span.lo));\n-                            s.print_type(&*field.node.ty)\n+                            s.print_type(&field.node.ty)\n                         }\n                     }\n                 }));\n@@ -948,7 +948,7 @@ impl<'a> State<'a> {\n                         try!(self.print_visibility(visibility));\n                         try!(self.print_name(name));\n                         try!(self.word_nbsp(\":\"));\n-                        try!(self.print_type(&*field.node.ty));\n+                        try!(self.print_type(&field.node.ty));\n                         try!(word(&mut self.s, \",\"));\n                     }\n                 }\n@@ -966,12 +966,11 @@ impl<'a> State<'a> {\n             Some(ref d) => {\n                 try!(space(&mut self.s));\n                 try!(self.word_space(\"=\"));\n-                self.print_expr(&**d)\n+                self.print_expr(&d)\n             }\n             _ => Ok(()),\n         }\n     }\n-\n     pub fn print_method_sig(&mut self,\n                             name: ast::Name,\n                             m: &hir::MethodSig,\n@@ -1046,15 +1045,15 @@ impl<'a> State<'a> {\n         try!(self.maybe_print_comment(st.span.lo));\n         match st.node {\n             hir::StmtDecl(ref decl, _) => {\n-                try!(self.print_decl(&**decl));\n+                try!(self.print_decl(&decl));\n             }\n             hir::StmtExpr(ref expr, _) => {\n                 try!(self.space_if_not_bol());\n-                try!(self.print_expr(&**expr));\n+                try!(self.print_expr(&expr));\n             }\n             hir::StmtSemi(ref expr, _) => {\n                 try!(self.space_if_not_bol());\n-                try!(self.print_expr(&**expr));\n+                try!(self.print_expr(&expr));\n                 try!(word(&mut self.s, \";\"));\n             }\n         }\n@@ -1112,7 +1111,7 @@ impl<'a> State<'a> {\n         match blk.expr {\n             Some(ref expr) => {\n                 try!(self.space_if_not_bol());\n-                try!(self.print_expr(&**expr));\n+                try!(self.print_expr(&expr));\n                 try!(self.maybe_print_trailing_comment(expr.span, Some(blk.span.hi)));\n             }\n             _ => (),\n@@ -1130,17 +1129,17 @@ impl<'a> State<'a> {\n                         try!(self.cbox(indent_unit - 1));\n                         try!(self.ibox(0));\n                         try!(word(&mut self.s, \" else if \"));\n-                        try!(self.print_expr(&**i));\n+                        try!(self.print_expr(&i));\n                         try!(space(&mut self.s));\n-                        try!(self.print_block(&**then));\n+                        try!(self.print_block(&then));\n                         self.print_else(e.as_ref().map(|e| &**e))\n                     }\n                     // \"final else\"\n                     hir::ExprBlock(ref b) => {\n                         try!(self.cbox(indent_unit - 1));\n                         try!(self.ibox(0));\n                         try!(word(&mut self.s, \" else \"));\n-                        self.print_block(&**b)\n+                        self.print_block(&b)\n                     }\n                     // BLEAH, constraints would be great here\n                     _ => {\n@@ -1230,7 +1229,7 @@ impl<'a> State<'a> {\n                                     try!(s.ibox(indent_unit));\n                                     try!(s.print_name(field.name.node));\n                                     try!(s.word_space(\":\"));\n-                                    try!(s.print_expr(&*field.expr));\n+                                    try!(s.print_expr(&field.expr));\n                                     s.end()\n                                 },\n                                 |f| f.span));\n@@ -1242,7 +1241,7 @@ impl<'a> State<'a> {\n                     try!(space(&mut self.s));\n                 }\n                 try!(word(&mut self.s, \"..\"));\n-                try!(self.print_expr(&**expr));\n+                try!(self.print_expr(&expr));\n                 try!(self.end());\n             }\n             _ => if !fields.is_empty() {\n@@ -1273,12 +1272,12 @@ impl<'a> State<'a> {\n                               args: &[P<hir::Expr>])\n                               -> io::Result<()> {\n         let base_args = &args[1..];\n-        try!(self.print_expr(&*args[0]));\n+        try!(self.print_expr(&args[0]));\n         try!(word(&mut self.s, \".\"));\n         try!(self.print_name(name.node));\n         if !tys.is_empty() {\n             try!(word(&mut self.s, \"::<\"));\n-            try!(self.commasep(Inconsistent, tys, |s, ty| s.print_type(&**ty)));\n+            try!(self.commasep(Inconsistent, tys, |s, ty| s.print_type(&ty)));\n             try!(word(&mut self.s, \">\"));\n         }\n         self.print_call_post(base_args)\n@@ -1322,7 +1321,7 @@ impl<'a> State<'a> {\n                 try!(self.print_expr_vec(&exprs[..]));\n             }\n             hir::ExprRepeat(ref element, ref count) => {\n-                try!(self.print_expr_repeat(&**element, &**count));\n+                try!(self.print_expr_repeat(&element, &count));\n             }\n             hir::ExprStruct(ref path, ref fields, ref wth) => {\n                 try!(self.print_expr_struct(path, &fields[..], wth));\n@@ -1331,46 +1330,46 @@ impl<'a> State<'a> {\n                 try!(self.print_expr_tup(&exprs[..]));\n             }\n             hir::ExprCall(ref func, ref args) => {\n-                try!(self.print_expr_call(&**func, &args[..]));\n+                try!(self.print_expr_call(&func, &args[..]));\n             }\n             hir::ExprMethodCall(name, ref tys, ref args) => {\n                 try!(self.print_expr_method_call(name, &tys[..], &args[..]));\n             }\n             hir::ExprBinary(op, ref lhs, ref rhs) => {\n-                try!(self.print_expr_binary(op, &**lhs, &**rhs));\n+                try!(self.print_expr_binary(op, &lhs, &rhs));\n             }\n             hir::ExprUnary(op, ref expr) => {\n-                try!(self.print_expr_unary(op, &**expr));\n+                try!(self.print_expr_unary(op, &expr));\n             }\n             hir::ExprAddrOf(m, ref expr) => {\n-                try!(self.print_expr_addr_of(m, &**expr));\n+                try!(self.print_expr_addr_of(m, &expr));\n             }\n             hir::ExprLit(ref lit) => {\n-                try!(self.print_literal(&**lit));\n+                try!(self.print_literal(&lit));\n             }\n             hir::ExprCast(ref expr, ref ty) => {\n-                try!(self.print_expr(&**expr));\n+                try!(self.print_expr(&expr));\n                 try!(space(&mut self.s));\n                 try!(self.word_space(\"as\"));\n-                try!(self.print_type(&**ty));\n+                try!(self.print_type(&ty));\n             }\n             hir::ExprType(ref expr, ref ty) => {\n-                try!(self.print_expr(&**expr));\n+                try!(self.print_expr(&expr));\n                 try!(self.word_space(\":\"));\n-                try!(self.print_type(&**ty));\n+                try!(self.print_type(&ty));\n             }\n             hir::ExprIf(ref test, ref blk, ref elseopt) => {\n-                try!(self.print_if(&**test, &**blk, elseopt.as_ref().map(|e| &**e)));\n+                try!(self.print_if(&test, &blk, elseopt.as_ref().map(|e| &**e)));\n             }\n             hir::ExprWhile(ref test, ref blk, opt_ident) => {\n                 if let Some(ident) = opt_ident {\n                     try!(self.print_name(ident.name));\n                     try!(self.word_space(\":\"));\n                 }\n                 try!(self.head(\"while\"));\n-                try!(self.print_expr(&**test));\n+                try!(self.print_expr(&test));\n                 try!(space(&mut self.s));\n-                try!(self.print_block(&**blk));\n+                try!(self.print_block(&blk));\n             }\n             hir::ExprLoop(ref blk, opt_ident) => {\n                 if let Some(ident) = opt_ident {\n@@ -1379,13 +1378,13 @@ impl<'a> State<'a> {\n                 }\n                 try!(self.head(\"loop\"));\n                 try!(space(&mut self.s));\n-                try!(self.print_block(&**blk));\n+                try!(self.print_block(&blk));\n             }\n             hir::ExprMatch(ref expr, ref arms, _) => {\n                 try!(self.cbox(indent_unit));\n                 try!(self.ibox(4));\n                 try!(self.word_nbsp(\"match\"));\n-                try!(self.print_expr(&**expr));\n+                try!(self.print_expr(&expr));\n                 try!(space(&mut self.s));\n                 try!(self.bopen());\n                 for arm in arms {\n@@ -1396,7 +1395,7 @@ impl<'a> State<'a> {\n             hir::ExprClosure(capture_clause, ref decl, ref body) => {\n                 try!(self.print_capture_clause(capture_clause));\n \n-                try!(self.print_fn_block_args(&**decl));\n+                try!(self.print_fn_block_args(&decl));\n                 try!(space(&mut self.s));\n \n                 let default_return = match decl.output {\n@@ -1405,12 +1404,12 @@ impl<'a> State<'a> {\n                 };\n \n                 if !default_return || !body.stmts.is_empty() || body.expr.is_none() {\n-                    try!(self.print_block_unclosed(&**body));\n+                    try!(self.print_block_unclosed(&body));\n                 } else {\n                     // we extract the block, so as not to create another set of boxes\n                     match body.expr.as_ref().unwrap().node {\n                         hir::ExprBlock(ref blk) => {\n-                            try!(self.print_block_unclosed(&**blk));\n+                            try!(self.print_block_unclosed(&blk));\n                         }\n                         _ => {\n                             // this is a bare expression\n@@ -1429,44 +1428,44 @@ impl<'a> State<'a> {\n                 try!(self.cbox(indent_unit));\n                 // head-box, will be closed by print-block after {\n                 try!(self.ibox(0));\n-                try!(self.print_block(&**blk));\n+                try!(self.print_block(&blk));\n             }\n             hir::ExprAssign(ref lhs, ref rhs) => {\n-                try!(self.print_expr(&**lhs));\n+                try!(self.print_expr(&lhs));\n                 try!(space(&mut self.s));\n                 try!(self.word_space(\"=\"));\n-                try!(self.print_expr(&**rhs));\n+                try!(self.print_expr(&rhs));\n             }\n             hir::ExprAssignOp(op, ref lhs, ref rhs) => {\n-                try!(self.print_expr(&**lhs));\n+                try!(self.print_expr(&lhs));\n                 try!(space(&mut self.s));\n                 try!(word(&mut self.s, ::util::binop_to_string(op.node)));\n                 try!(self.word_space(\"=\"));\n-                try!(self.print_expr(&**rhs));\n+                try!(self.print_expr(&rhs));\n             }\n             hir::ExprField(ref expr, name) => {\n-                try!(self.print_expr(&**expr));\n+                try!(self.print_expr(&expr));\n                 try!(word(&mut self.s, \".\"));\n                 try!(self.print_name(name.node));\n             }\n             hir::ExprTupField(ref expr, id) => {\n-                try!(self.print_expr(&**expr));\n+                try!(self.print_expr(&expr));\n                 try!(word(&mut self.s, \".\"));\n                 try!(self.print_usize(id.node));\n             }\n             hir::ExprIndex(ref expr, ref index) => {\n-                try!(self.print_expr(&**expr));\n+                try!(self.print_expr(&expr));\n                 try!(word(&mut self.s, \"[\"));\n-                try!(self.print_expr(&**index));\n+                try!(self.print_expr(&index));\n                 try!(word(&mut self.s, \"]\"));\n             }\n             hir::ExprRange(ref start, ref end) => {\n                 if let &Some(ref e) = start {\n-                    try!(self.print_expr(&**e));\n+                    try!(self.print_expr(&e));\n                 }\n                 try!(word(&mut self.s, \"..\"));\n                 if let &Some(ref e) = end {\n-                    try!(self.print_expr(&**e));\n+                    try!(self.print_expr(&e));\n                 }\n             }\n             hir::ExprPath(None, ref path) => {\n@@ -1496,7 +1495,7 @@ impl<'a> State<'a> {\n                 match *result {\n                     Some(ref expr) => {\n                         try!(word(&mut self.s, \" \"));\n-                        try!(self.print_expr(&**expr));\n+                        try!(self.print_expr(&expr));\n                     }\n                     _ => (),\n                 }\n@@ -1515,7 +1514,7 @@ impl<'a> State<'a> {\n                         _ => try!(s.print_string(&out.constraint, ast::StrStyle::Cooked)),\n                     }\n                     try!(s.popen());\n-                    try!(s.print_expr(&*out.expr));\n+                    try!(s.print_expr(&out.expr));\n                     try!(s.pclose());\n                     Ok(())\n                 }));\n@@ -1525,7 +1524,7 @@ impl<'a> State<'a> {\n                 try!(self.commasep(Inconsistent, &a.inputs, |s, &(ref co, ref o)| {\n                     try!(s.print_string(&co, ast::StrStyle::Cooked));\n                     try!(s.popen());\n-                    try!(s.print_expr(&**o));\n+                    try!(s.print_expr(&o));\n                     try!(s.pclose());\n                     Ok(())\n                 }));\n@@ -1551,7 +1550,7 @@ impl<'a> State<'a> {\n                 if !options.is_empty() {\n                     try!(space(&mut self.s));\n                     try!(self.word_space(\":\"));\n-                    try!(self.commasep(Inconsistent, &*options, |s, &co| {\n+                    try!(self.commasep(Inconsistent, &options, |s, &co| {\n                         try!(s.print_string(co, ast::StrStyle::Cooked));\n                         Ok(())\n                     }));\n@@ -1565,10 +1564,10 @@ impl<'a> State<'a> {\n     }\n \n     pub fn print_local_decl(&mut self, loc: &hir::Local) -> io::Result<()> {\n-        try!(self.print_pat(&*loc.pat));\n+        try!(self.print_pat(&loc.pat));\n         if let Some(ref ty) = loc.ty {\n             try!(self.word_space(\":\"));\n-            try!(self.print_type(&**ty));\n+            try!(self.print_type(&ty));\n         }\n         Ok(())\n     }\n@@ -1582,12 +1581,12 @@ impl<'a> State<'a> {\n                 try!(self.word_nbsp(\"let\"));\n \n                 try!(self.ibox(indent_unit));\n-                try!(self.print_local_decl(&**loc));\n+                try!(self.print_local_decl(&loc));\n                 try!(self.end());\n                 if let Some(ref init) = loc.init {\n                     try!(self.nbsp());\n                     try!(self.word_space(\"=\"));\n-                    try!(self.print_expr(&**init));\n+                    try!(self.print_expr(&init));\n                 }\n                 self.end()\n             }\n@@ -1685,7 +1684,7 @@ impl<'a> State<'a> {\n                     if comma {\n                         try!(self.word_space(\",\"))\n                     }\n-                    try!(self.commasep(Inconsistent, &data.types, |s, ty| s.print_type(&**ty)));\n+                    try!(self.commasep(Inconsistent, &data.types, |s, ty| s.print_type(&ty)));\n                     comma = true;\n                 }\n \n@@ -1696,7 +1695,7 @@ impl<'a> State<'a> {\n                     try!(self.print_name(binding.name));\n                     try!(space(&mut self.s));\n                     try!(self.word_space(\"=\"));\n-                    try!(self.print_type(&*binding.ty));\n+                    try!(self.print_type(&binding.ty));\n                     comma = true;\n                 }\n \n@@ -1705,15 +1704,15 @@ impl<'a> State<'a> {\n \n             hir::ParenthesizedParameters(ref data) => {\n                 try!(word(&mut self.s, \"(\"));\n-                try!(self.commasep(Inconsistent, &data.inputs, |s, ty| s.print_type(&**ty)));\n+                try!(self.commasep(Inconsistent, &data.inputs, |s, ty| s.print_type(&ty)));\n                 try!(word(&mut self.s, \")\"));\n \n                 match data.output {\n                     None => {}\n                     Some(ref ty) => {\n                         try!(self.space_if_not_bol());\n                         try!(self.word_space(\"->\"));\n-                        try!(self.print_type(&**ty));\n+                        try!(self.print_type(&ty));\n                     }\n                 }\n             }\n@@ -1744,7 +1743,7 @@ impl<'a> State<'a> {\n                 match *sub {\n                     Some(ref p) => {\n                         try!(word(&mut self.s, \"@\"));\n-                        try!(self.print_pat(&**p));\n+                        try!(self.print_pat(&p));\n                     }\n                     None => (),\n                 }\n@@ -1756,7 +1755,7 @@ impl<'a> State<'a> {\n                     Some(ref args) => {\n                         if !args.is_empty() {\n                             try!(self.popen());\n-                            try!(self.commasep(Inconsistent, &args[..], |s, p| s.print_pat(&**p)));\n+                            try!(self.commasep(Inconsistent, &args[..], |s, p| s.print_pat(&p)));\n                             try!(self.pclose());\n                         }\n                     }\n@@ -1777,7 +1776,7 @@ impl<'a> State<'a> {\n                                                 try!(s.print_name(f.node.name));\n                                                 try!(s.word_nbsp(\":\"));\n                                             }\n-                                            try!(s.print_pat(&*f.node.pat));\n+                                            try!(s.print_pat(&f.node.pat));\n                                             s.end()\n                                         },\n                                         |f| f.node.pat.span));\n@@ -1792,46 +1791,46 @@ impl<'a> State<'a> {\n             }\n             hir::PatTup(ref elts) => {\n                 try!(self.popen());\n-                try!(self.commasep(Inconsistent, &elts[..], |s, p| s.print_pat(&**p)));\n+                try!(self.commasep(Inconsistent, &elts[..], |s, p| s.print_pat(&p)));\n                 if elts.len() == 1 {\n                     try!(word(&mut self.s, \",\"));\n                 }\n                 try!(self.pclose());\n             }\n             hir::PatBox(ref inner) => {\n                 try!(word(&mut self.s, \"box \"));\n-                try!(self.print_pat(&**inner));\n+                try!(self.print_pat(&inner));\n             }\n             hir::PatRegion(ref inner, mutbl) => {\n                 try!(word(&mut self.s, \"&\"));\n                 if mutbl == hir::MutMutable {\n                     try!(word(&mut self.s, \"mut \"));\n                 }\n-                try!(self.print_pat(&**inner));\n+                try!(self.print_pat(&inner));\n             }\n-            hir::PatLit(ref e) => try!(self.print_expr(&**e)),\n+            hir::PatLit(ref e) => try!(self.print_expr(&e)),\n             hir::PatRange(ref begin, ref end) => {\n-                try!(self.print_expr(&**begin));\n+                try!(self.print_expr(&begin));\n                 try!(space(&mut self.s));\n                 try!(word(&mut self.s, \"...\"));\n-                try!(self.print_expr(&**end));\n+                try!(self.print_expr(&end));\n             }\n             hir::PatVec(ref before, ref slice, ref after) => {\n                 try!(word(&mut self.s, \"[\"));\n-                try!(self.commasep(Inconsistent, &before[..], |s, p| s.print_pat(&**p)));\n+                try!(self.commasep(Inconsistent, &before[..], |s, p| s.print_pat(&p)));\n                 if let Some(ref p) = *slice {\n                     if !before.is_empty() {\n                         try!(self.word_space(\",\"));\n                     }\n                     if p.node != hir::PatWild {\n-                        try!(self.print_pat(&**p));\n+                        try!(self.print_pat(&p));\n                     }\n                     try!(word(&mut self.s, \"..\"));\n                     if !after.is_empty() {\n                         try!(self.word_space(\",\"));\n                     }\n                 }\n-                try!(self.commasep(Inconsistent, &after[..], |s, p| s.print_pat(&**p)));\n+                try!(self.commasep(Inconsistent, &after[..], |s, p| s.print_pat(&p)));\n                 try!(word(&mut self.s, \"]\"));\n             }\n         }\n@@ -1855,20 +1854,20 @@ impl<'a> State<'a> {\n                 try!(space(&mut self.s));\n                 try!(self.word_space(\"|\"));\n             }\n-            try!(self.print_pat(&**p));\n+            try!(self.print_pat(&p));\n         }\n         try!(space(&mut self.s));\n         if let Some(ref e) = arm.guard {\n             try!(self.word_space(\"if\"));\n-            try!(self.print_expr(&**e));\n+            try!(self.print_expr(&e));\n             try!(space(&mut self.s));\n         }\n         try!(self.word_space(\"=>\"));\n \n         match arm.body.node {\n             hir::ExprBlock(ref blk) => {\n                 // the block will close the pattern's ibox\n-                try!(self.print_block_unclosed_indent(&**blk, indent_unit));\n+                try!(self.print_block_unclosed_indent(&blk, indent_unit));\n \n                 // If it is a user-provided unsafe block, print a comma after it\n                 if let hir::UnsafeBlock(hir::UserProvided) = blk.rules {\n@@ -1877,7 +1876,7 @@ impl<'a> State<'a> {\n             }\n             _ => {\n                 try!(self.end()); // close the ibox for the pattern\n-                try!(self.print_expr(&*arm.body));\n+                try!(self.print_expr(&arm.body));\n                 try!(word(&mut self.s, \",\"));\n             }\n         }\n@@ -1906,7 +1905,7 @@ impl<'a> State<'a> {\n             hir::SelfExplicit(ref typ, _) => {\n                 try!(word(&mut self.s, \"self\"));\n                 try!(self.word_space(\":\"));\n-                try!(self.print_type(&**typ));\n+                try!(self.print_type(&typ));\n             }\n         }\n         return Ok(true);\n@@ -1999,7 +1998,7 @@ impl<'a> State<'a> {\n         try!(self.word_space(\"->\"));\n         match decl.output {\n             hir::Return(ref ty) => {\n-                try!(self.print_type(&**ty));\n+                try!(self.print_type(&ty));\n                 self.maybe_print_comment(ty.span.lo)\n             }\n             hir::DefaultReturn(..) => unreachable!(),\n@@ -2098,7 +2097,7 @@ impl<'a> State<'a> {\n             Some(ref default) => {\n                 try!(space(&mut self.s));\n                 try!(self.word_space(\"=\"));\n-                self.print_type(&**default)\n+                self.print_type(&default)\n             }\n             _ => Ok(()),\n         }\n@@ -2123,7 +2122,7 @@ impl<'a> State<'a> {\n                                                                               ref bounds,\n                                                                               ..}) => {\n                     try!(self.print_formal_lifetime_list(bound_lifetimes));\n-                    try!(self.print_type(&**bounded_ty));\n+                    try!(self.print_type(&bounded_ty));\n                     try!(self.print_bounds(\":\", bounds));\n                 }\n                 &hir::WherePredicate::RegionPredicate(hir::WhereRegionPredicate{ref lifetime,\n@@ -2144,7 +2143,7 @@ impl<'a> State<'a> {\n                     try!(self.print_path(path, false, 0));\n                     try!(space(&mut self.s));\n                     try!(self.word_space(\"=\"));\n-                    try!(self.print_type(&**ty));\n+                    try!(self.print_type(&ty));\n                 }\n             }\n         }\n@@ -2202,13 +2201,13 @@ impl<'a> State<'a> {\n \n     pub fn print_mt(&mut self, mt: &hir::MutTy) -> io::Result<()> {\n         try!(self.print_mutability(mt.mutbl));\n-        self.print_type(&*mt.ty)\n+        self.print_type(&mt.ty)\n     }\n \n     pub fn print_arg(&mut self, input: &hir::Arg, is_closure: bool) -> io::Result<()> {\n         try!(self.ibox(indent_unit));\n         match input.ty.node {\n-            hir::TyInfer if is_closure => try!(self.print_pat(&*input.pat)),\n+            hir::TyInfer if is_closure => try!(self.print_pat(&input.pat)),\n             _ => {\n                 match input.pat.node {\n                     hir::PatIdent(_, ref path1, _) if\n@@ -2217,12 +2216,12 @@ impl<'a> State<'a> {\n                         // Do nothing.\n                     }\n                     _ => {\n-                        try!(self.print_pat(&*input.pat));\n+                        try!(self.print_pat(&input.pat));\n                         try!(word(&mut self.s, \":\"));\n                         try!(space(&mut self.s));\n                     }\n                 }\n-                try!(self.print_type(&*input.ty));\n+                try!(self.print_type(&input.ty));\n             }\n         }\n         self.end()\n@@ -2239,7 +2238,7 @@ impl<'a> State<'a> {\n         match decl.output {\n             hir::NoReturn(_) => try!(self.word_nbsp(\"!\")),\n             hir::DefaultReturn(..) => unreachable!(),\n-            hir::Return(ref ty) => try!(self.print_type(&**ty)),\n+            hir::Return(ref ty) => try!(self.print_type(&ty)),\n         }\n         try!(self.end());\n \n@@ -2414,7 +2413,7 @@ fn stmt_ends_with_semi(stmt: &hir::Stmt_) -> bool {\n             }\n         }\n         hir::StmtExpr(ref e, _) => {\n-            expr_requires_semi_to_be_stmt(&**e)\n+            expr_requires_semi_to_be_stmt(&e)\n         }\n         hir::StmtSemi(..) => {\n             false"}, {"sha": "5d936fae6ec0a6c695cf56cf822ef0628a0de3ae", "filename": "src/librustc_front/util.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/3548b8c273d9feb0291e97a928c4f48e01daf0f9/src%2Flibrustc_front%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3548b8c273d9feb0291e97a928c4f48e01daf0f9/src%2Flibrustc_front%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_front%2Futil.rs?ref=3548b8c273d9feb0291e97a928c4f48e01daf0f9", "patch": "@@ -23,25 +23,25 @@ pub fn walk_pat<F>(pat: &Pat, mut it: F) -> bool\n     fn walk_pat_<G>(pat: &Pat, it: &mut G) -> bool\n         where G: FnMut(&Pat) -> bool\n     {\n-        if !(*it)(pat) {\n+        if !it(pat) {\n             return false;\n         }\n \n         match pat.node {\n-            PatIdent(_, _, Some(ref p)) => walk_pat_(&**p, it),\n+            PatIdent(_, _, Some(ref p)) => walk_pat_(&p, it),\n             PatStruct(_, ref fields, _) => {\n-                fields.iter().all(|field| walk_pat_(&*field.node.pat, it))\n+                fields.iter().all(|field| walk_pat_(&field.node.pat, it))\n             }\n             PatEnum(_, Some(ref s)) | PatTup(ref s) => {\n-                s.iter().all(|p| walk_pat_(&**p, it))\n+                s.iter().all(|p| walk_pat_(&p, it))\n             }\n             PatBox(ref s) | PatRegion(ref s, _) => {\n-                walk_pat_(&**s, it)\n+                walk_pat_(&s, it)\n             }\n             PatVec(ref before, ref slice, ref after) => {\n-                before.iter().all(|p| walk_pat_(&**p, it)) &&\n-                slice.iter().all(|p| walk_pat_(&**p, it)) &&\n-                after.iter().all(|p| walk_pat_(&**p, it))\n+                before.iter().all(|p| walk_pat_(&p, it)) &&\n+                slice.iter().all(|p| walk_pat_(&p, it)) &&\n+                after.iter().all(|p| walk_pat_(&p, it))\n             }\n             PatWild |\n             PatLit(_) |"}, {"sha": "203f6626f51d3acc7791dea505b3ecdbf74ee0ed", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3548b8c273d9feb0291e97a928c4f48e01daf0f9/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3548b8c273d9feb0291e97a928c4f48e01daf0f9/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=3548b8c273d9feb0291e97a928c4f48e01daf0f9", "patch": "@@ -125,7 +125,7 @@ impl LateLintPass for TypeLimits {\n                 }\n             },\n             hir::ExprBinary(binop, ref l, ref r) => {\n-                if is_comparison(binop) && !check_limits(cx.tcx, binop, &**l, &**r) {\n+                if is_comparison(binop) && !check_limits(cx.tcx, binop, &l, &r) {\n                     cx.span_lint(UNUSED_COMPARISONS, e.span,\n                                  \"comparison is useless due to type limits\");\n                 }\n@@ -174,7 +174,7 @@ impl LateLintPass for TypeLimits {\n                                 if (negative && v > max as u64 + 1) ||\n                                    (!negative && v > max as u64) {\n                                     cx.span_lint(OVERFLOWING_LITERALS, e.span,\n-                                                 &*format!(\"literal out of range for {:?}\", t));\n+                                                 &format!(\"literal out of range for {:?}\", t));\n                                     return;\n                                 }\n                             }\n@@ -196,7 +196,7 @@ impl LateLintPass for TypeLimits {\n                         };\n                         if lit_val < min || lit_val > max {\n                             cx.span_lint(OVERFLOWING_LITERALS, e.span,\n-                                         &*format!(\"literal out of range for {:?}\", t));\n+                                         &format!(\"literal out of range for {:?}\", t));\n                         }\n                     },\n                     ty::TyFloat(t) => {\n@@ -213,7 +213,7 @@ impl LateLintPass for TypeLimits {\n                         };\n                         if lit_val < min || lit_val > max {\n                             cx.span_lint(OVERFLOWING_LITERALS, e.span,\n-                                         &*format!(\"literal out of range for {:?}\", t));\n+                                         &format!(\"literal out of range for {:?}\", t));\n                         }\n                     },\n                     _ => ()\n@@ -666,7 +666,7 @@ impl LateLintPass for ImproperCTypes {\n \n         fn check_foreign_fn(cx: &LateContext, decl: &hir::FnDecl) {\n             for input in &decl.inputs {\n-                check_ty(cx, &*input.ty);\n+                check_ty(cx, &input.ty);\n             }\n             if let hir::Return(ref ret_ty) = decl.output {\n                 let tty = ast_ty_to_normalized(cx.tcx, ret_ty.id);\n@@ -680,8 +680,8 @@ impl LateLintPass for ImproperCTypes {\n             if nmod.abi != Abi::RustIntrinsic && nmod.abi != Abi::PlatformIntrinsic {\n                 for ni in &nmod.items {\n                     match ni.node {\n-                        hir::ForeignItemFn(ref decl, _) => check_foreign_fn(cx, &**decl),\n-                        hir::ForeignItemStatic(ref t, _) => check_ty(cx, &**t)\n+                        hir::ForeignItemFn(ref decl, _) => check_foreign_fn(cx, &decl),\n+                        hir::ForeignItemStatic(ref t, _) => check_ty(cx, &t)\n                     }\n                 }\n             }"}, {"sha": "36ed06a6c00b47363c6823d731e6f3640bcf9d07", "filename": "src/librustc_lint/unused.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/3548b8c273d9feb0291e97a928c4f48e01daf0f9/src%2Flibrustc_lint%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3548b8c273d9feb0291e97a928c4f48e01daf0f9/src%2Flibrustc_lint%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Funused.rs?ref=3548b8c273d9feb0291e97a928c4f48e01daf0f9", "patch": "@@ -248,7 +248,7 @@ impl LateLintPass for UnusedAttributes {\n \n         let plugin_attributes = cx.sess().plugin_attributes.borrow_mut();\n         for &(ref name, ty) in plugin_attributes.iter() {\n-            if ty == AttributeType::Whitelisted && attr.check_name(&*name) {\n+            if ty == AttributeType::Whitelisted && attr.check_name(&name) {\n                 break;\n             }\n         }\n@@ -265,7 +265,7 @@ impl LateLintPass for UnusedAttributes {\n             // the crate level?\n             let plugin_crate = plugin_attributes.iter()\n                                                 .find(|&&(ref x, t)| {\n-                                                        &*attr.name() == &*x &&\n+                                                        &*attr.name() == x &&\n                                                         AttributeType::CrateLevel == t\n                                                     }).is_some();\n             if  known_crate || plugin_crate {\n@@ -294,7 +294,7 @@ impl UnusedParens {\n     fn check_unused_parens_core(&self, cx: &EarlyContext, value: &ast::Expr, msg: &str,\n                                 struct_lit_needs_parens: bool) {\n         if let ast::ExprKind::Paren(ref inner) = value.node {\n-            let necessary = struct_lit_needs_parens && contains_exterior_struct_lit(&**inner);\n+            let necessary = struct_lit_needs_parens && contains_exterior_struct_lit(&inner);\n             if !necessary {\n                 cx.span_lint(UNUSED_PARENS, value.span,\n                              &format!(\"unnecessary parentheses around {}\", msg))\n@@ -314,8 +314,8 @@ impl UnusedParens {\n                 ast::ExprKind::AssignOp(_, ref lhs, ref rhs) |\n                 ast::ExprKind::Binary(_, ref lhs, ref rhs) => {\n                     // X { y: 1 } + X { y: 2 }\n-                    contains_exterior_struct_lit(&**lhs) ||\n-                        contains_exterior_struct_lit(&**rhs)\n+                    contains_exterior_struct_lit(&lhs) ||\n+                        contains_exterior_struct_lit(&rhs)\n                 }\n                 ast::ExprKind::Unary(_, ref x) |\n                 ast::ExprKind::Cast(ref x, _) |\n@@ -324,12 +324,12 @@ impl UnusedParens {\n                 ast::ExprKind::TupField(ref x, _) |\n                 ast::ExprKind::Index(ref x, _) => {\n                     // &X { y: 1 }, X { y: 1 }.y\n-                    contains_exterior_struct_lit(&**x)\n+                    contains_exterior_struct_lit(&x)\n                 }\n \n                 ast::ExprKind::MethodCall(_, _, ref exprs) => {\n                     // X { y: 1 }.bar(...)\n-                    contains_exterior_struct_lit(&*exprs[0])\n+                    contains_exterior_struct_lit(&exprs[0])\n                 }\n \n                 _ => false\n@@ -360,7 +360,7 @@ impl EarlyLintPass for UnusedParens {\n             InPlace(_, ref value) => (value, \"emplacement value\", false),\n             _ => return\n         };\n-        self.check_unused_parens_core(cx, &**value, msg, struct_lit_needs_parens);\n+        self.check_unused_parens_core(cx, &value, msg, struct_lit_needs_parens);\n     }\n \n     fn check_stmt(&mut self, cx: &EarlyContext, s: &ast::Stmt) {\n@@ -374,7 +374,7 @@ impl EarlyLintPass for UnusedParens {\n             },\n             _ => return\n         };\n-        self.check_unused_parens_core(cx, &**value, msg, false);\n+        self.check_unused_parens_core(cx, &value, msg, false);\n     }\n }\n "}, {"sha": "3a0bd3aa2059d35c3d7ad2b281c2de96eddd2aad", "filename": "src/librustc_metadata/astencode.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3548b8c273d9feb0291e97a928c4f48e01daf0f9/src%2Flibrustc_metadata%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3548b8c273d9feb0291e97a928c4f48e01daf0f9/src%2Flibrustc_metadata%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fastencode.rs?ref=3548b8c273d9feb0291e97a928c4f48e01daf0f9", "patch": "@@ -173,7 +173,7 @@ pub fn decode_inlined_item<'tcx>(cdata: &cstore::crate_metadata,\n         match *ii {\n           InlinedItem::Item(ref i) => {\n             debug!(\">>> DECODED ITEM >>>\\n{}\\n<<< DECODED ITEM <<<\",\n-                   ::rustc_front::print::pprust::item_to_string(&**i));\n+                   ::rustc_front::print::pprust::item_to_string(&i));\n           }\n           _ => { }\n         }\n@@ -1404,8 +1404,8 @@ fn test_simplification() {\n     ).unwrap())));\n     match (item_out, item_exp) {\n       (InlinedItem::Item(item_out), InlinedItem::Item(item_exp)) => {\n-        assert!(pprust::item_to_string(&*item_out) ==\n-                pprust::item_to_string(&*item_exp));\n+        assert!(pprust::item_to_string(&item_out) ==\n+                pprust::item_to_string(&item_exp));\n       }\n       _ => panic!()\n     }"}, {"sha": "35d7a0d4b9c27640be03ffd9839eecd49a2af58f", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3548b8c273d9feb0291e97a928c4f48e01daf0f9/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3548b8c273d9feb0291e97a928c4f48e01daf0f9/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=3548b8c273d9feb0291e97a928c4f48e01daf0f9", "patch": "@@ -264,7 +264,7 @@ impl<'a> CrateReader<'a> {\n                          incompatible with this version of rustc\",\n                         name,\n                         crate_rustc_version\n-                            .as_ref().map(|s|&**s)\n+                            .as_ref().map(|s| &**s)\n                             .unwrap_or(\"an old version of rustc\")\n             );\n         }\n@@ -494,7 +494,7 @@ impl<'a> CrateReader<'a> {\n         let source_name = format!(\"<{} macros>\", item.ident);\n         let mut macros = vec![];\n         decoder::each_exported_macro(ekrate.metadata.as_slice(),\n-                                     &*self.cstore.intr,\n+                                     &self.cstore.intr,\n             |name, attrs, span, body| {\n                 // NB: Don't use parse::parse_tts_from_source_str because it parses with\n                 // quote_depth > 0."}, {"sha": "9b534df075bef5dc5a1a751fb9680c23ff48642f", "filename": "src/librustc_metadata/csearch.rs", "status": "modified", "additions": 43, "deletions": 43, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/3548b8c273d9feb0291e97a928c4f48e01daf0f9/src%2Flibrustc_metadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3548b8c273d9feb0291e97a928c4f48e01daf0f9/src%2Flibrustc_metadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcsearch.rs?ref=3548b8c273d9feb0291e97a928c4f48e01daf0f9", "patch": "@@ -40,64 +40,64 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n     fn stability(&self, def: DefId) -> Option<attr::Stability>\n     {\n         let cdata = self.get_crate_data(def.krate);\n-        decoder::get_stability(&*cdata, def.index)\n+        decoder::get_stability(&cdata, def.index)\n     }\n \n     fn deprecation(&self, def: DefId) -> Option<attr::Deprecation>\n     {\n         let cdata = self.get_crate_data(def.krate);\n-        decoder::get_deprecation(&*cdata, def.index)\n+        decoder::get_deprecation(&cdata, def.index)\n     }\n \n     fn closure_kind(&self, _tcx: &ty::ctxt<'tcx>, def_id: DefId) -> ty::ClosureKind\n     {\n         assert!(!def_id.is_local());\n         let cdata = self.get_crate_data(def_id.krate);\n-        decoder::closure_kind(&*cdata, def_id.index)\n+        decoder::closure_kind(&cdata, def_id.index)\n     }\n \n     fn closure_ty(&self, tcx: &ty::ctxt<'tcx>, def_id: DefId) -> ty::ClosureTy<'tcx>\n     {\n         assert!(!def_id.is_local());\n         let cdata = self.get_crate_data(def_id.krate);\n-        decoder::closure_ty(&*cdata, def_id.index, tcx)\n+        decoder::closure_ty(&cdata, def_id.index, tcx)\n     }\n \n     fn item_variances(&self, def: DefId) -> ty::ItemVariances {\n         let cdata = self.get_crate_data(def.krate);\n-        decoder::get_item_variances(&*cdata, def.index)\n+        decoder::get_item_variances(&cdata, def.index)\n     }\n \n     fn repr_attrs(&self, def: DefId) -> Vec<attr::ReprAttr> {\n         let cdata = self.get_crate_data(def.krate);\n-        decoder::get_repr_attrs(&*cdata, def.index)\n+        decoder::get_repr_attrs(&cdata, def.index)\n     }\n \n     fn item_type(&self, tcx: &ty::ctxt<'tcx>, def: DefId)\n                  -> ty::TypeScheme<'tcx>\n     {\n         let cdata = self.get_crate_data(def.krate);\n-        decoder::get_type(&*cdata, def.index, tcx)\n+        decoder::get_type(&cdata, def.index, tcx)\n     }\n \n     fn item_predicates(&self, tcx: &ty::ctxt<'tcx>, def: DefId)\n                        -> ty::GenericPredicates<'tcx>\n     {\n         let cdata = self.get_crate_data(def.krate);\n-        decoder::get_predicates(&*cdata, def.index, tcx)\n+        decoder::get_predicates(&cdata, def.index, tcx)\n     }\n \n     fn item_super_predicates(&self, tcx: &ty::ctxt<'tcx>, def: DefId)\n                              -> ty::GenericPredicates<'tcx>\n     {\n         let cdata = self.get_crate_data(def.krate);\n-        decoder::get_super_predicates(&*cdata, def.index, tcx)\n+        decoder::get_super_predicates(&cdata, def.index, tcx)\n     }\n \n     fn item_attrs(&self, def_id: DefId) -> Vec<ast::Attribute>\n     {\n         let cdata = self.get_crate_data(def_id.krate);\n-        decoder::get_item_attrs(&*cdata, def_id.index)\n+        decoder::get_item_attrs(&cdata, def_id.index)\n     }\n \n     fn item_symbol(&self, def: DefId) -> String\n@@ -109,13 +109,13 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n     fn trait_def(&self, tcx: &ty::ctxt<'tcx>, def: DefId) -> ty::TraitDef<'tcx>\n     {\n         let cdata = self.get_crate_data(def.krate);\n-        decoder::get_trait_def(&*cdata, def.index, tcx)\n+        decoder::get_trait_def(&cdata, def.index, tcx)\n     }\n \n     fn adt_def(&self, tcx: &ty::ctxt<'tcx>, def: DefId) -> ty::AdtDefMaster<'tcx>\n     {\n         let cdata = self.get_crate_data(def.krate);\n-        decoder::get_adt_def(&self.intr, &*cdata, def.index, tcx)\n+        decoder::get_adt_def(&self.intr, &cdata, def.index, tcx)\n     }\n \n     fn method_arg_names(&self, did: DefId) -> Vec<String>\n@@ -126,7 +126,7 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n \n     fn item_path(&self, def: DefId) -> Vec<hir_map::PathElem> {\n         let cdata = self.get_crate_data(def.krate);\n-        let path = decoder::get_item_path(&*cdata, def.index);\n+        let path = decoder::get_item_path(&cdata, def.index);\n \n         cdata.with_local_path(|cpath| {\n             let mut r = Vec::with_capacity(cpath.len() + path.len());\n@@ -138,7 +138,7 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n \n     fn extern_item_path(&self, def: DefId) -> Vec<hir_map::PathElem> {\n         let cdata = self.get_crate_data(def.krate);\n-        let path = decoder::get_item_path(&*cdata, def.index);\n+        let path = decoder::get_item_path(&cdata, def.index);\n \n         let mut r = Vec::with_capacity(path.len() + 1);\n         let crate_name = hir_map::PathMod(token::intern(&cdata.name));\n@@ -157,7 +157,7 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n     {\n         let mut result = vec![];\n         let cdata = self.get_crate_data(def_id.krate);\n-        decoder::each_inherent_implementation_for_type(&*cdata, def_id.index,\n+        decoder::each_inherent_implementation_for_type(&cdata, def_id.index,\n                                                        |iid| result.push(iid));\n         result\n     }\n@@ -177,53 +177,53 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n                               -> Vec<Rc<ty::Method<'tcx>>>\n     {\n         let cdata = self.get_crate_data(def.krate);\n-        decoder::get_provided_trait_methods(self.intr.clone(), &*cdata, def.index, tcx)\n+        decoder::get_provided_trait_methods(self.intr.clone(), &cdata, def.index, tcx)\n     }\n \n     fn trait_item_def_ids(&self, def: DefId)\n                           -> Vec<ty::ImplOrTraitItemId>\n     {\n         let cdata = self.get_crate_data(def.krate);\n-        decoder::get_trait_item_def_ids(&*cdata, def.index)\n+        decoder::get_trait_item_def_ids(&cdata, def.index)\n     }\n \n     fn impl_items(&self, impl_def_id: DefId) -> Vec<ty::ImplOrTraitItemId>\n     {\n         let cdata = self.get_crate_data(impl_def_id.krate);\n-        decoder::get_impl_items(&*cdata, impl_def_id.index)\n+        decoder::get_impl_items(&cdata, impl_def_id.index)\n     }\n \n     fn impl_polarity(&self, def: DefId) -> Option<hir::ImplPolarity>\n     {\n         let cdata = self.get_crate_data(def.krate);\n-        decoder::get_impl_polarity(&*cdata, def.index)\n+        decoder::get_impl_polarity(&cdata, def.index)\n     }\n \n     fn impl_trait_ref(&self, tcx: &ty::ctxt<'tcx>, def: DefId)\n                       -> Option<ty::TraitRef<'tcx>>\n     {\n         let cdata = self.get_crate_data(def.krate);\n-        decoder::get_impl_trait(&*cdata, def.index, tcx)\n+        decoder::get_impl_trait(&cdata, def.index, tcx)\n     }\n \n     fn custom_coerce_unsized_kind(&self, def: DefId)\n                                   -> Option<ty::adjustment::CustomCoerceUnsized>\n     {\n         let cdata = self.get_crate_data(def.krate);\n-        decoder::get_custom_coerce_unsized_kind(&*cdata, def.index)\n+        decoder::get_custom_coerce_unsized_kind(&cdata, def.index)\n     }\n \n     // FIXME: killme\n     fn associated_consts(&self, tcx: &ty::ctxt<'tcx>, def: DefId)\n                          -> Vec<Rc<ty::AssociatedConst<'tcx>>> {\n         let cdata = self.get_crate_data(def.krate);\n-        decoder::get_associated_consts(self.intr.clone(), &*cdata, def.index, tcx)\n+        decoder::get_associated_consts(self.intr.clone(), &cdata, def.index, tcx)\n     }\n \n     fn trait_of_item(&self, tcx: &ty::ctxt<'tcx>, def_id: DefId) -> Option<DefId>\n     {\n         let cdata = self.get_crate_data(def_id.krate);\n-        decoder::get_trait_of_item(&*cdata, def_id.index, tcx)\n+        decoder::get_trait_of_item(&cdata, def_id.index, tcx)\n     }\n \n     fn impl_or_trait_item(&self, tcx: &ty::ctxt<'tcx>, def: DefId)\n@@ -232,7 +232,7 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n         let cdata = self.get_crate_data(def.krate);\n         decoder::get_impl_or_trait_item(\n             self.intr.clone(),\n-            &*cdata,\n+            &cdata,\n             def.index,\n             tcx)\n     }\n@@ -246,29 +246,29 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n     fn is_defaulted_trait(&self, trait_def_id: DefId) -> bool\n     {\n         let cdata = self.get_crate_data(trait_def_id.krate);\n-        decoder::is_defaulted_trait(&*cdata, trait_def_id.index)\n+        decoder::is_defaulted_trait(&cdata, trait_def_id.index)\n     }\n \n     fn is_impl(&self, did: DefId) -> bool\n     {\n         let cdata = self.get_crate_data(did.krate);\n-        decoder::is_impl(&*cdata, did.index)\n+        decoder::is_impl(&cdata, did.index)\n     }\n \n     fn is_default_impl(&self, impl_did: DefId) -> bool {\n         let cdata = self.get_crate_data(impl_did.krate);\n-        decoder::is_default_impl(&*cdata, impl_did.index)\n+        decoder::is_default_impl(&cdata, impl_did.index)\n     }\n \n     fn is_extern_item(&self, tcx: &ty::ctxt<'tcx>, did: DefId) -> bool {\n         let cdata = self.get_crate_data(did.krate);\n-        decoder::is_extern_item(&*cdata, did.index, tcx)\n+        decoder::is_extern_item(&cdata, did.index, tcx)\n     }\n \n     fn is_static_method(&self, def: DefId) -> bool\n     {\n         let cdata = self.get_crate_data(def.krate);\n-        decoder::is_static_method(&*cdata, def.index)\n+        decoder::is_static_method(&cdata, def.index)\n     }\n \n     fn is_statically_included_foreign_item(&self, id: ast::NodeId) -> bool\n@@ -278,7 +278,7 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n \n     fn is_typedef(&self, did: DefId) -> bool {\n         let cdata = self.get_crate_data(did.krate);\n-        decoder::is_typedef(&*cdata, did.index)\n+        decoder::is_typedef(&cdata, did.index)\n     }\n \n     fn dylib_dependency_formats(&self, cnum: ast::CrateNum)\n@@ -292,7 +292,7 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n     {\n         let mut result = vec![];\n         let crate_data = self.get_crate_data(cnum);\n-        decoder::each_lang_item(&*crate_data, |did, lid| {\n+        decoder::each_lang_item(&crate_data, |did, lid| {\n             result.push((did, lid)); true\n         });\n         result\n@@ -302,7 +302,7 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n                           -> Vec<lang_items::LangItem>\n     {\n         let cdata = self.get_crate_data(cnum);\n-        decoder::get_missing_lang_items(&*cdata)\n+        decoder::get_missing_lang_items(&cdata)\n     }\n \n     fn is_staged_api(&self, cnum: ast::CrateNum) -> bool\n@@ -339,7 +339,7 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n     fn crate_struct_field_attrs(&self, cnum: ast::CrateNum)\n                                 -> FnvHashMap<DefId, Vec<ast::Attribute>>\n     {\n-        decoder::get_struct_field_attrs(&*self.get_crate_data(cnum))\n+        decoder::get_struct_field_attrs(&self.get_crate_data(cnum))\n     }\n \n     fn plugin_registrar_fn(&self, cnum: ast::CrateNum) -> Option<DefId>\n@@ -354,19 +354,19 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n     fn native_libraries(&self, cnum: ast::CrateNum) -> Vec<(NativeLibraryKind, String)>\n     {\n         let cdata = self.get_crate_data(cnum);\n-        decoder::get_native_libraries(&*cdata)\n+        decoder::get_native_libraries(&cdata)\n     }\n \n     fn reachable_ids(&self, cnum: ast::CrateNum) -> Vec<DefId>\n     {\n         let cdata = self.get_crate_data(cnum);\n-        decoder::get_reachable_ids(&*cdata)\n+        decoder::get_reachable_ids(&cdata)\n     }\n \n     fn def_path(&self, def: DefId) -> hir_map::DefPath\n     {\n         let cdata = self.get_crate_data(def.krate);\n-        let path = decoder::def_path(&*cdata, def.index);\n+        let path = decoder::def_path(&cdata, def.index);\n         let local_path = cdata.local_def_path();\n         local_path.into_iter().chain(path).collect()\n     }\n@@ -385,13 +385,13 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n     fn tuple_struct_definition_if_ctor(&self, did: DefId) -> Option<DefId>\n     {\n         let cdata = self.get_crate_data(did.krate);\n-        decoder::get_tuple_struct_definition_if_ctor(&*cdata, did.index)\n+        decoder::get_tuple_struct_definition_if_ctor(&cdata, did.index)\n     }\n \n     fn struct_field_names(&self, def: DefId) -> Vec<ast::Name>\n     {\n         let cdata = self.get_crate_data(def.krate);\n-        decoder::get_struct_field_names(&self.intr, &*cdata, def.index)\n+        decoder::get_struct_field_names(&self.intr, &cdata, def.index)\n     }\n \n     fn item_children(&self, def_id: DefId) -> Vec<ChildItem>\n@@ -400,7 +400,7 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n         let crate_data = self.get_crate_data(def_id.krate);\n         let get_crate_data = |cnum| self.get_crate_data(cnum);\n         decoder::each_child_of_item(\n-            self.intr.clone(), &*crate_data,\n+            self.intr.clone(), &crate_data,\n             def_id.index, get_crate_data,\n             |def, name, vis| result.push(ChildItem {\n                 def: def,\n@@ -416,7 +416,7 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n         let crate_data = self.get_crate_data(cnum);\n         let get_crate_data = |cnum| self.get_crate_data(cnum);\n         decoder::each_top_level_item_of_crate(\n-            self.intr.clone(), &*crate_data, get_crate_data,\n+            self.intr.clone(), &crate_data, get_crate_data,\n             |def, name, vis| result.push(ChildItem {\n                 def: def,\n                 name: name,\n@@ -430,18 +430,18 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n     {\n         let cdata = self.get_crate_data(def.krate);\n         let decode_inlined_item = Box::new(astencode::decode_inlined_item);\n-        decoder::maybe_get_item_ast(&*cdata, tcx, def.index, decode_inlined_item)\n+        decoder::maybe_get_item_ast(&cdata, tcx, def.index, decode_inlined_item)\n     }\n \n     fn maybe_get_item_mir(&self, tcx: &ty::ctxt<'tcx>, def: DefId)\n                           -> Option<Mir<'tcx>> {\n         let cdata = self.get_crate_data(def.krate);\n-        decoder::maybe_get_item_mir(&*cdata, tcx, def.index)\n+        decoder::maybe_get_item_mir(&cdata, tcx, def.index)\n     }\n \n     fn is_item_mir_available(&self, def: DefId) -> bool {\n         let cdata = self.get_crate_data(def.krate);\n-        decoder::is_item_mir_available(&*cdata, def.index)\n+        decoder::is_item_mir_available(&cdata, def.index)\n     }\n \n     fn crates(&self) -> Vec<ast::CrateNum>"}, {"sha": "a96da6bf4d66aaf85025f0dd98ff15d6f9775c6c", "filename": "src/librustc_metadata/cstore.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3548b8c273d9feb0291e97a928c4f48e01daf0f9/src%2Flibrustc_metadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3548b8c273d9feb0291e97a928c4f48e01daf0f9/src%2Flibrustc_metadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore.rs?ref=3548b8c273d9feb0291e97a928c4f48e01daf0f9", "patch": "@@ -138,7 +138,7 @@ impl CStore {\n         for (&k, v) in self.metas.borrow().iter() {\n             let origin = self.opt_used_crate_source(k);\n             origin.as_ref().map(|cs| { assert!(k == cs.cnum); });\n-            i(k, &**v, origin);\n+            i(k, &v, origin);\n         }\n     }\n "}, {"sha": "8295ffebda3e6508b62bcd20a509064abb2a0871", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3548b8c273d9feb0291e97a928c4f48e01daf0f9/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3548b8c273d9feb0291e97a928c4f48e01daf0f9/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=3548b8c273d9feb0291e97a928c4f48e01daf0f9", "patch": "@@ -655,7 +655,7 @@ fn each_child_of_item_or_crate<F, G>(intr: Rc<IdentInterner>,\n             None => {}\n             Some(child_item_doc) => {\n                 // Hand off the item to the callback.\n-                let child_name = item_name(&*intr, child_item_doc);\n+                let child_name = item_name(&intr, child_item_doc);\n                 let def_like = item_to_def_like(crate_data, child_item_doc, child_def_id);\n                 let visibility = item_visibility(child_item_doc);\n                 callback(def_like, child_name, visibility);\n@@ -677,7 +677,7 @@ fn each_child_of_item_or_crate<F, G>(intr: Rc<IdentInterner>,\n                 if let Some(impl_method_doc) = cdata.get_item(impl_item_def_id.index) {\n                     if let StaticMethod = item_family(impl_method_doc) {\n                         // Hand off the static method to the callback.\n-                        let static_method_name = item_name(&*intr, impl_method_doc);\n+                        let static_method_name = item_name(&intr, impl_method_doc);\n                         let static_method_def_like = item_to_def_like(cdata, impl_method_doc,\n                                                                       impl_item_def_id);\n                         callback(static_method_def_like,\n@@ -938,7 +938,7 @@ pub fn get_trait_name(intr: Rc<IdentInterner>,\n                       id: DefIndex)\n                       -> ast::Name {\n     let doc = cdata.lookup_item(id);\n-    item_name(&*intr, doc)\n+    item_name(&intr, doc)\n }\n \n pub fn is_static_method(cdata: Cmd, id: DefIndex) -> bool {\n@@ -967,7 +967,7 @@ pub fn get_impl_or_trait_item<'tcx>(intr: Rc<IdentInterner>,\n         _ => ImplContainer(container_id),\n     };\n \n-    let name = item_name(&*intr, item_doc);\n+    let name = item_name(&intr, item_doc);\n     let vis = item_visibility(item_doc);\n \n     match item_sort(item_doc) {\n@@ -1622,7 +1622,7 @@ fn doc_generics<'tcx>(base_doc: rbml::Doc,\n     for rp_doc in reader::tagged_docs(doc, tag_region_param_def) {\n         let ident_str_doc = reader::get_doc(rp_doc,\n                                             tag_region_param_def_ident);\n-        let name = item_name(&*token::get_ident_interner(), ident_str_doc);\n+        let name = item_name(&token::get_ident_interner(), ident_str_doc);\n         let def_id_doc = reader::get_doc(rp_doc,\n                                          tag_region_param_def_def_id);\n         let def_id = translated_def_id(cdata, def_id_doc);"}, {"sha": "207a680a13d80a5b48618acd1b48a704a169e1a8", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/3548b8c273d9feb0291e97a928c4f48e01daf0f9/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3548b8c273d9feb0291e97a928c4f48e01daf0f9/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=3548b8c273d9feb0291e97a928c4f48e01daf0f9", "patch": "@@ -964,7 +964,7 @@ fn encode_info_for_item<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n         encode_visibility(rbml_w, vis);\n         encode_stability(rbml_w, stab);\n         encode_deprecation(rbml_w, depr);\n-        encode_method_argument_names(rbml_w, &**decl);\n+        encode_method_argument_names(rbml_w, &decl);\n         rbml_w.end_tag();\n       }\n       hir::ItemMod(ref m) => {\n@@ -1173,7 +1173,7 @@ fn encode_info_for_item<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n                     encode_info_for_associated_const(ecx,\n                                                      rbml_w,\n                                                      index,\n-                                                     &*associated_const,\n+                                                     &associated_const,\n                                                      path.clone(),\n                                                      item.id,\n                                                      ast_item)\n@@ -1182,7 +1182,7 @@ fn encode_info_for_item<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n                     encode_info_for_method(ecx,\n                                            rbml_w,\n                                            index,\n-                                           &**method_type,\n+                                           &method_type,\n                                            path.clone(),\n                                            false,\n                                            item.id,\n@@ -1192,7 +1192,7 @@ fn encode_info_for_item<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n                     encode_info_for_associated_type(ecx,\n                                                     rbml_w,\n                                                     index,\n-                                                    &**associated_type,\n+                                                    &associated_type,\n                                                     path.clone(),\n                                                     item.id,\n                                                     ast_item)\n@@ -1290,7 +1290,7 @@ fn encode_info_for_item<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n                 ty::MethodTraitItem(method_ty) => {\n                     let method_def_id = item_def_id.def_id();\n \n-                    encode_method_ty_fields(ecx, rbml_w, index, &*method_ty);\n+                    encode_method_ty_fields(ecx, rbml_w, index, &method_ty);\n \n                     let elem = ast_map::PathName(method_ty.name);\n                     encode_path(rbml_w,\n@@ -1396,13 +1396,13 @@ fn encode_info_for_foreign_item<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n         if abi == Abi::RustIntrinsic || abi == Abi::PlatformIntrinsic {\n             encode_inlined_item(ecx, rbml_w, InlinedItemRef::Foreign(nitem));\n         }\n-        encode_attributes(rbml_w, &*nitem.attrs);\n+        encode_attributes(rbml_w, &nitem.attrs);\n         let stab = stability::lookup_stability(ecx.tcx, ecx.tcx.map.local_def_id(nitem.id));\n         let depr = stability::lookup_deprecation(ecx.tcx, ecx.tcx.map.local_def_id(nitem.id));\n         encode_stability(rbml_w, stab);\n         encode_deprecation(rbml_w, depr);\n         encode_symbol(ecx, rbml_w, nitem.id);\n-        encode_method_argument_names(rbml_w, &*fndecl);\n+        encode_method_argument_names(rbml_w, &fndecl);\n       }\n       hir::ForeignItemStatic(_, mutbl) => {\n         if mutbl {\n@@ -1411,7 +1411,7 @@ fn encode_info_for_foreign_item<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n             encode_family(rbml_w, 'c');\n         }\n         encode_bounds_and_type_for_item(rbml_w, ecx, index, nitem.id);\n-        encode_attributes(rbml_w, &*nitem.attrs);\n+        encode_attributes(rbml_w, &nitem.attrs);\n         let stab = stability::lookup_stability(ecx.tcx, ecx.tcx.map.local_def_id(nitem.id));\n         let depr = stability::lookup_deprecation(ecx.tcx, ecx.tcx.map.local_def_id(nitem.id));\n         encode_stability(rbml_w, stab);\n@@ -1561,7 +1561,7 @@ fn encode_meta_item(rbml_w: &mut Encoder, mi: &ast::MetaItem) {\n         rbml_w.start_tag(tag_meta_item_list);\n         rbml_w.wr_tagged_str(tag_meta_item_name, name);\n         for inner_item in items {\n-            encode_meta_item(rbml_w, &**inner_item);\n+            encode_meta_item(rbml_w, &inner_item);\n         }\n         rbml_w.end_tag();\n       }\n@@ -1573,7 +1573,7 @@ fn encode_attributes(rbml_w: &mut Encoder, attrs: &[ast::Attribute]) {\n     for attr in attrs {\n         rbml_w.start_tag(tag_attribute);\n         rbml_w.wr_tagged_u8(tag_attribute_is_sugared_doc, attr.node.is_sugared_doc as u8);\n-        encode_meta_item(rbml_w, &*attr.node.value);\n+        encode_meta_item(rbml_w, &attr.node.value);\n         rbml_w.end_tag();\n     }\n     rbml_w.end_tag();"}, {"sha": "3d7c61cd2c1b42835a026085a18b0d3dce366fec", "filename": "src/librustc_mir/build/scope.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3548b8c273d9feb0291e97a928c4f48e01daf0f9/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3548b8c273d9feb0291e97a928c4f48e01daf0f9/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fscope.rs?ref=3548b8c273d9feb0291e97a928c4f48e01daf0f9", "patch": "@@ -488,7 +488,7 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n         let funcdid = match self.hir.tcx().lang_items.require(lang_item) {\n             Ok(d) => d,\n             Err(m) => {\n-                self.hir.tcx().sess.fatal(&*m)\n+                self.hir.tcx().sess.fatal(&m)\n             }\n         };\n         Constant {"}, {"sha": "90d049cdc731a1d7e20552ab376bddd4845c098f", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3548b8c273d9feb0291e97a928c4f48e01daf0f9/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3548b8c273d9feb0291e97a928c4f48e01daf0f9/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=3548b8c273d9feb0291e97a928c4f48e01daf0f9", "patch": "@@ -114,7 +114,7 @@ impl<'tcx> Mirror<'tcx> for &'tcx hir::Expr {\n             }\n \n             hir::ExprBlock(ref blk) => {\n-                ExprKind::Block { body: &**blk }\n+                ExprKind::Block { body: &blk }\n             }\n \n             hir::ExprAssign(ref lhs, ref rhs) => {\n@@ -277,7 +277,7 @@ impl<'tcx> Mirror<'tcx> for &'tcx hir::Expr {\n                 });\n                 ExprKind::Closure {\n                     closure_id: def_id,\n-                    substs: &**substs,\n+                    substs: &substs,\n                     upvars: upvars,\n                 }\n             }"}, {"sha": "5985a88382e2fbb3b38e53424d995e51aa4a99e3", "filename": "src/librustc_mir/hair/cx/pattern.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3548b8c273d9feb0291e97a928c4f48e01daf0f9/src%2Flibrustc_mir%2Fhair%2Fcx%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3548b8c273d9feb0291e97a928c4f48e01daf0f9/src%2Flibrustc_mir%2Fhair%2Fcx%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fpattern.rs?ref=3548b8c273d9feb0291e97a928c4f48e01daf0f9", "patch": "@@ -90,7 +90,7 @@ impl<'patcx, 'cx, 'tcx> PatCx<'patcx, 'cx, 'tcx> {\n                             Some(const_expr) => {\n                                 let pat = const_eval::const_expr_to_pat(self.cx.tcx, const_expr,\n                                                                         pat.span);\n-                                return self.to_pattern(&*pat);\n+                                return self.to_pattern(&pat);\n                             }\n                             None => {\n                                 self.cx.tcx.sess.span_bug("}, {"sha": "50dd33ca993cf42454b737ad7e1294faedf51603", "filename": "src/librustc_passes/consts.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/3548b8c273d9feb0291e97a928c4f48e01daf0f9/src%2Flibrustc_passes%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3548b8c273d9feb0291e97a928c4f48e01daf0f9/src%2Flibrustc_passes%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fconsts.rs?ref=3548b8c273d9feb0291e97a928c4f48e01daf0f9", "patch": "@@ -266,20 +266,20 @@ impl<'a, 'tcx, 'v> Visitor<'v> for CheckCrateVisitor<'a, 'tcx> {\n         assert_eq!(self.mode, Mode::Var);\n         match i.node {\n             hir::ItemStatic(_, hir::MutImmutable, ref expr) => {\n-                self.check_static_type(&**expr);\n-                self.global_expr(Mode::Static, &**expr);\n+                self.check_static_type(&expr);\n+                self.global_expr(Mode::Static, &expr);\n             }\n             hir::ItemStatic(_, hir::MutMutable, ref expr) => {\n-                self.check_static_mut_type(&**expr);\n-                self.global_expr(Mode::StaticMut, &**expr);\n+                self.check_static_mut_type(&expr);\n+                self.global_expr(Mode::StaticMut, &expr);\n             }\n             hir::ItemConst(_, ref expr) => {\n-                self.global_expr(Mode::Const, &**expr);\n+                self.global_expr(Mode::Const, &expr);\n             }\n             hir::ItemEnum(ref enum_definition, _) => {\n                 for var in &enum_definition.variants {\n                     if let Some(ref ex) = var.node.disr_expr {\n-                        self.global_expr(Mode::Const, &**ex);\n+                        self.global_expr(Mode::Const, &ex);\n                     }\n                 }\n             }\n@@ -293,7 +293,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for CheckCrateVisitor<'a, 'tcx> {\n         match t.node {\n             hir::ConstTraitItem(_, ref default) => {\n                 if let Some(ref expr) = *default {\n-                    self.global_expr(Mode::Const, &*expr);\n+                    self.global_expr(Mode::Const, &expr);\n                 } else {\n                     intravisit::walk_trait_item(self, t);\n                 }\n@@ -305,7 +305,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for CheckCrateVisitor<'a, 'tcx> {\n     fn visit_impl_item(&mut self, i: &'v hir::ImplItem) {\n         match i.node {\n             hir::ImplItemKind::Const(_, ref expr) => {\n-                self.global_expr(Mode::Const, &*expr);\n+                self.global_expr(Mode::Const, &expr);\n             }\n             _ => self.with_mode(Mode::Var, |v| intravisit::walk_impl_item(v, i)),\n         }\n@@ -323,11 +323,11 @@ impl<'a, 'tcx, 'v> Visitor<'v> for CheckCrateVisitor<'a, 'tcx> {\n     fn visit_pat(&mut self, p: &hir::Pat) {\n         match p.node {\n             hir::PatLit(ref lit) => {\n-                self.global_expr(Mode::Const, &**lit);\n+                self.global_expr(Mode::Const, &lit);\n             }\n             hir::PatRange(ref start, ref end) => {\n-                self.global_expr(Mode::Const, &**start);\n-                self.global_expr(Mode::Const, &**end);\n+                self.global_expr(Mode::Const, &start);\n+                self.global_expr(Mode::Const, &end);\n \n                 match const_eval::compare_lit_exprs(self.tcx, start, end) {\n                     Some(Ordering::Less) |\n@@ -379,17 +379,17 @@ impl<'a, 'tcx, 'v> Visitor<'v> for CheckCrateVisitor<'a, 'tcx> {\n         match ex.node {\n             hir::ExprCall(ref callee, ref args) => {\n                 for arg in args {\n-                    self.visit_expr(&**arg)\n+                    self.visit_expr(&arg)\n                 }\n \n                 let inner = self.qualif;\n-                self.visit_expr(&**callee);\n+                self.visit_expr(&callee);\n                 // The callee's size doesn't count in the call.\n                 let added = self.qualif - inner;\n                 self.qualif = inner | (added - ConstQualif::NON_ZERO_SIZED);\n             }\n             hir::ExprRepeat(ref element, _) => {\n-                self.visit_expr(&**element);\n+                self.visit_expr(&element);\n                 // The count is checked elsewhere (typeck).\n                 let count = match node_ty.sty {\n                     ty::TyArray(_, n) => n,\n@@ -631,7 +631,7 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>,\n             loop {\n                 callee = match callee.node {\n                     hir::ExprBlock(ref block) => match block.expr {\n-                        Some(ref tail) => &**tail,\n+                        Some(ref tail) => &tail,\n                         None => break\n                     },\n                     _ => break"}, {"sha": "a89627aea82fbc50a46af29c5f5657f0cb85ed5c", "filename": "src/librustc_passes/loops.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3548b8c273d9feb0291e97a928c4f48e01daf0f9/src%2Flibrustc_passes%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3548b8c273d9feb0291e97a928c4f48e01daf0f9/src%2Flibrustc_passes%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Floops.rs?ref=3548b8c273d9feb0291e97a928c4f48e01daf0f9", "patch": "@@ -42,14 +42,14 @@ impl<'a, 'v> Visitor<'v> for CheckLoopVisitor<'a> {\n     fn visit_expr(&mut self, e: &hir::Expr) {\n         match e.node {\n             hir::ExprWhile(ref e, ref b, _) => {\n-                self.visit_expr(&**e);\n-                self.with_context(Loop, |v| v.visit_block(&**b));\n+                self.visit_expr(&e);\n+                self.with_context(Loop, |v| v.visit_block(&b));\n             }\n             hir::ExprLoop(ref b, _) => {\n-                self.with_context(Loop, |v| v.visit_block(&**b));\n+                self.with_context(Loop, |v| v.visit_block(&b));\n             }\n             hir::ExprClosure(_, _, ref b) => {\n-                self.with_context(Closure, |v| v.visit_block(&**b));\n+                self.with_context(Closure, |v| v.visit_block(&b));\n             }\n             hir::ExprBreak(_) => self.require_loop(\"break\", e.span),\n             hir::ExprAgain(_) => self.require_loop(\"continue\", e.span),"}, {"sha": "c2f8d092b08fdb972e9d2f0342fbc4bf200dcd22", "filename": "src/librustc_plugin/load.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3548b8c273d9feb0291e97a928c4f48e01daf0f9/src%2Flibrustc_plugin%2Fload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3548b8c273d9feb0291e97a928c4f48e01daf0f9/src%2Flibrustc_plugin%2Fload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_plugin%2Fload.rs?ref=3548b8c273d9feb0291e97a928c4f48e01daf0f9", "patch": "@@ -68,7 +68,7 @@ pub fn load_plugins(sess: &Session, cstore: &CStore, krate: &ast::Crate,\n             }\n \n             let args = plugin.meta_item_list().map(ToOwned::to_owned).unwrap_or_default();\n-            loader.load_plugin(plugin.span, &*plugin.name(), args);\n+            loader.load_plugin(plugin.span, &plugin.name(), args);\n         }\n     }\n "}, {"sha": "85c2fe0c0a56854ad39f99895a3df8402faf0070", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3548b8c273d9feb0291e97a928c4f48e01daf0f9/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3548b8c273d9feb0291e97a928c4f48e01daf0f9/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=3548b8c273d9feb0291e97a928c4f48e01daf0f9", "patch": "@@ -855,15 +855,15 @@ impl<'a, 'tcx, 'v> Visitor<'v> for PrivacyVisitor<'a, 'tcx> {\n     fn visit_expr(&mut self, expr: &hir::Expr) {\n         match expr.node {\n             hir::ExprField(ref base, name) => {\n-                if let ty::TyStruct(def, _) = self.tcx.expr_ty_adjusted(&**base).sty {\n+                if let ty::TyStruct(def, _) = self.tcx.expr_ty_adjusted(&base).sty {\n                     self.check_field(expr.span,\n                                      def,\n                                      def.struct_variant(),\n                                      NamedField(name.node));\n                 }\n             }\n             hir::ExprTupField(ref base, idx) => {\n-                if let ty::TyStruct(def, _) = self.tcx.expr_ty_adjusted(&**base).sty {\n+                if let ty::TyStruct(def, _) = self.tcx.expr_ty_adjusted(&base).sty {\n                     self.check_field(expr.span,\n                                      def,\n                                      def.struct_variant(),\n@@ -1238,7 +1238,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx>\n                         at_outer_type: true,\n                         outer_type_is_public_path: false,\n                     };\n-                    visitor.visit_ty(&**self_);\n+                    visitor.visit_ty(&self_);\n                     self_contains_private = visitor.contains_private;\n                     self_is_public_path = visitor.outer_type_is_public_path;\n                 }\n@@ -1395,7 +1395,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx>\n                 }\n                 &hir::WherePredicate::RegionPredicate(_) => {}\n                 &hir::WherePredicate::EqPredicate(ref eq_pred) => {\n-                    self.visit_ty(&*eq_pred.ty);\n+                    self.visit_ty(&eq_pred.ty);\n                 }\n             }\n         }"}, {"sha": "f0e4d7578e373e6f4044f0db32a6ff0dadd352a0", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 36, "deletions": 36, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/3548b8c273d9feb0291e97a928c4f48e01daf0f9/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3548b8c273d9feb0291e97a928c4f48e01daf0f9/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=3548b8c273d9feb0291e97a928c4f48e01daf0f9", "patch": "@@ -438,25 +438,25 @@ fn resolve_struct_error<'b, 'a: 'b, 'tcx: 'a>(resolver: &'b Resolver<'a, 'tcx>,\n                                 help_msg = format!(\"To reference an item from the \\\n                                                     `{module}` module, use \\\n                                                     `{module}::{ident}`\",\n-                                                   module = &*path,\n+                                                   module = path,\n                                                    ident = ident.node);\n                             }\n                             ExprMethodCall(ident, _, _) => {\n                                 help_msg = format!(\"To call a function from the \\\n                                                     `{module}` module, use \\\n                                                     `{module}::{ident}(..)`\",\n-                                                   module = &*path,\n+                                                   module = path,\n                                                    ident = ident.node);\n                             }\n                             ExprCall(_, _) => {\n                                 help_msg = format!(\"No function corresponds to `{module}(..)`\",\n-                                                   module = &*path);\n+                                                   module = path);\n                             }\n                             _ => { } // no help available\n                         }\n                     } else {\n                         help_msg = format!(\"Module `{module}` cannot be the value of an expression\",\n-                                           module = &*path);\n+                                           module = path);\n                     }\n \n                     if !help_msg.is_empty() {\n@@ -577,7 +577,7 @@ impl<'a, 'v, 'tcx> Visitor<'v> for Resolver<'a, 'tcx> {\n         self.resolve_expr(expr);\n     }\n     fn visit_local(&mut self, local: &Local) {\n-        execute_callback!(hir_map::Node::NodeLocal(&*local.pat), self);\n+        execute_callback!(hir_map::Node::NodeLocal(&local.pat), self);\n         self.resolve_local(local);\n     }\n     fn visit_ty(&mut self, ty: &Ty) {\n@@ -1331,8 +1331,8 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                         match search_parent_externals(name, &self.current_module) {\n                             Some(module) => {\n                                 let path_str = names_to_string(module_path);\n-                                let target_mod_str = module_to_string(&*module);\n-                                let current_mod_str = module_to_string(&*self.current_module);\n+                                let target_mod_str = module_to_string(&module);\n+                                let current_mod_str = module_to_string(&self.current_module);\n \n                                 let prefix = if target_mod_str == current_mod_str {\n                                     \"self::\".to_string()\n@@ -1400,7 +1400,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n         debug!(\"(resolving module path for import) processing `{}` rooted at `{}`\",\n                names_to_string(module_path),\n-               module_to_string(&*module_));\n+               module_to_string(&module_));\n \n         // Resolve the module prefix, if any.\n         let module_prefix_result = self.resolve_module_prefix(module_, module_path);\n@@ -1494,15 +1494,15 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         debug!(\"(resolving item in lexical scope) resolving `{}` in namespace {:?} in `{}`\",\n                name,\n                namespace,\n-               module_to_string(&*module_));\n+               module_to_string(&module_));\n \n         // Proceed up the scope chain looking for parent modules.\n         let mut search_module = module_;\n         loop {\n             // Resolve the name in the parent module.\n             match self.resolve_name_in_module(search_module, name, namespace, true, record_used) {\n                 Failed(Some((span, msg))) => {\n-                    resolve_error(self, span, ResolutionError::FailedToResolve(&*msg));\n+                    resolve_error(self, span, ResolutionError::FailedToResolve(&msg));\n                 }\n                 Failed(None) => (), // Continue up the search chain.\n                 Indeterminate => {\n@@ -1592,7 +1592,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         // Now loop through all the `super`s we find.\n         while i < module_path.len() && \"super\" == module_path[i].as_str() {\n             debug!(\"(resolving module prefix) resolving `super` at {}\",\n-                   module_to_string(&*containing_module));\n+                   module_to_string(&containing_module));\n             match self.get_nearest_normal_module_parent(containing_module) {\n                 None => return Failed(None),\n                 Some(new_module) => {\n@@ -1603,7 +1603,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         }\n \n         debug!(\"(resolving module prefix) finished resolving prefix at {}\",\n-               module_to_string(&*containing_module));\n+               module_to_string(&containing_module));\n \n         return Success(PrefixFound(containing_module, i));\n     }\n@@ -1770,7 +1770,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             ItemImpl(_, _, ref generics, ref opt_trait_ref, ref self_type, ref impl_items) => {\n                 self.resolve_implementation(generics,\n                                             opt_trait_ref,\n-                                            &**self_type,\n+                                            &self_type,\n                                             item.id,\n                                             impl_items);\n             }\n@@ -1965,9 +1965,9 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         // Add each argument to the rib.\n         let mut bindings_list = HashMap::new();\n         for argument in &declaration.inputs {\n-            self.resolve_pattern(&*argument.pat, ArgumentIrrefutableMode, &mut bindings_list);\n+            self.resolve_pattern(&argument.pat, ArgumentIrrefutableMode, &mut bindings_list);\n \n-            self.visit_ty(&*argument.ty);\n+            self.visit_ty(&argument.ty);\n \n             debug!(\"(resolving function) recorded argument\");\n         }\n@@ -1997,7 +1997,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 let mut err =\n                     resolve_struct_error(self,\n                                   trait_path.span,\n-                                  ResolutionError::IsNotATrait(&*path_names_to_string(trait_path,\n+                                  ResolutionError::IsNotATrait(&path_names_to_string(trait_path,\n                                                                                       path_depth)));\n \n                 // If it's a typedef, give a note\n@@ -2011,7 +2011,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         } else {\n             resolve_error(self,\n                           trait_path.span,\n-                          ResolutionError::UndeclaredTraitName(&*path_names_to_string(trait_path,\n+                          ResolutionError::UndeclaredTraitName(&path_names_to_string(trait_path,\n                                                                                       path_depth)));\n             Err(())\n         }\n@@ -2165,7 +2165,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         if let Some((did, ref trait_ref)) = self.current_trait_ref {\n             if !self.trait_item_map.contains_key(&(name, did)) {\n                 let path_str = path_names_to_string(&trait_ref.path, 0);\n-                resolve_error(self, span, err(name, &*path_str));\n+                resolve_error(self, span, err(name, &path_str));\n             }\n         }\n     }\n@@ -2178,7 +2178,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         walk_list!(self, visit_expr, &local.init);\n \n         // Resolve the pattern.\n-        self.resolve_pattern(&*local.pat, LocalIrrefutableMode, &mut HashMap::new());\n+        self.resolve_pattern(&local.pat, LocalIrrefutableMode, &mut HashMap::new());\n     }\n \n     // build a map from pattern identifiers to binding-info's.\n@@ -2204,9 +2204,9 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         if arm.pats.is_empty() {\n             return;\n         }\n-        let map_0 = self.binding_mode_map(&*arm.pats[0]);\n+        let map_0 = self.binding_mode_map(&arm.pats[0]);\n         for (i, p) in arm.pats.iter().enumerate() {\n-            let map_i = self.binding_mode_map(&**p);\n+            let map_i = self.binding_mode_map(&p);\n \n             for (&key, &binding_0) in &map_0 {\n                 match map_i.get(&key) {\n@@ -2241,15 +2241,15 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n         let mut bindings_list = HashMap::new();\n         for pattern in &arm.pats {\n-            self.resolve_pattern(&**pattern, RefutableMode, &mut bindings_list);\n+            self.resolve_pattern(&pattern, RefutableMode, &mut bindings_list);\n         }\n \n         // This has to happen *after* we determine which\n         // pat_idents are variants\n         self.check_consistent_bindings(arm);\n \n         walk_list!(self, visit_expr, &arm.guard);\n-        self.visit_expr(&*arm.body);\n+        self.visit_expr(&arm.body);\n \n         if !self.resolved {\n             self.value_ribs.pop();\n@@ -2340,7 +2340,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                           ty.span,\n                                           ResolutionError::UseOfUndeclared(\n                                                                     kind,\n-                                                                    &*path_names_to_string(path,\n+                                                                    &path_names_to_string(path,\n                                                                                            0))\n                                          );\n                         }\n@@ -2616,7 +2616,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                 self,\n                                 path.span,\n                                 ResolutionError::DoesNotNameAStruct(\n-                                    &*path_names_to_string(path, 0))\n+                                    &path_names_to_string(path, 0))\n                             );\n                             self.record_def(pattern.id, err_path_resolution());\n                         }\n@@ -2672,7 +2672,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             Failed(err) => {\n                 match err {\n                     Some((span, msg)) => {\n-                        resolve_error(self, span, ResolutionError::FailedToResolve(&*msg));\n+                        resolve_error(self, span, ResolutionError::FailedToResolve(&msg));\n                     }\n                     None => (),\n                 }\n@@ -2804,7 +2804,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         match self.resolve_item_in_lexical_scope(module, name, namespace, record_used) {\n             Success(binding) => binding.def().map(LocalDef::from_def),\n             Failed(Some((span, msg))) => {\n-                resolve_error(self, span, ResolutionError::FailedToResolve(&*msg));\n+                resolve_error(self, span, ResolutionError::FailedToResolve(&msg));\n                 None\n             }\n             _ => None,\n@@ -2927,7 +2927,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     }\n                 };\n \n-                resolve_error(self, span, ResolutionError::FailedToResolve(&*msg));\n+                resolve_error(self, span, ResolutionError::FailedToResolve(&msg));\n                 return None;\n             }\n             Indeterminate => return None,\n@@ -2982,7 +2982,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     }\n                 };\n \n-                resolve_error(self, span, ResolutionError::FailedToResolve(&*msg));\n+                resolve_error(self, span, ResolutionError::FailedToResolve(&msg));\n                 return None;\n             }\n \n@@ -3064,8 +3064,8 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                     -> Option<(Path, NodeId, FallbackChecks)> {\n             match t.node {\n                 TyPath(None, ref path) => Some((path.clone(), t.id, allow)),\n-                TyPtr(ref mut_ty) => extract_path_and_node_id(&*mut_ty.ty, OnlyTraitAndStatics),\n-                TyRptr(_, ref mut_ty) => extract_path_and_node_id(&*mut_ty.ty, allow),\n+                TyPtr(ref mut_ty) => extract_path_and_node_id(&mut_ty.ty, OnlyTraitAndStatics),\n+                TyRptr(_, ref mut_ty) => extract_path_and_node_id(&mut_ty.ty, allow),\n                 // This doesn't handle the remaining `Ty` variants as they are not\n                 // that commonly the self_type, it might be interesting to provide\n                 // support for those in future.\n@@ -3183,7 +3183,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     .flat_map(|rib| rib.bindings.keys());\n \n         if let Some(found) = find_best_match_for_name(names, name, None) {\n-            if name != &*found {\n+            if name != found {\n                 return SuggestionType::Function(found);\n             }\n         } SuggestionType::NotFound\n@@ -3229,7 +3229,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n                         let mut err = resolve_struct_error(self,\n                                         expr.span,\n-                                        ResolutionError::StructVariantUsedAsFunction(&*path_name));\n+                                        ResolutionError::StructVariantUsedAsFunction(&path_name));\n \n                         let msg = format!(\"did you mean to write: `{} {{ /* fields */ }}`?\",\n                                           path_name);\n@@ -3270,7 +3270,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                         Some(Def::Struct(..)) => {\n                             let mut err = resolve_struct_error(self,\n                                 expr.span,\n-                                ResolutionError::StructVariantUsedAsFunction(&*path_name));\n+                                ResolutionError::StructVariantUsedAsFunction(&path_name));\n \n                             let msg = format!(\"did you mean to write: `{} {{ /* fields */ }}`?\",\n                                               path_name);\n@@ -3346,7 +3346,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                 resolve_error(self,\n                                               expr.span,\n                                               ResolutionError::UnresolvedName(\n-                                                  &*path_name, &*msg, context));\n+                                                  &path_name, &msg, context));\n                             }\n                         }\n                     }\n@@ -3367,7 +3367,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                         resolve_error(self,\n                                       path.span,\n                                       ResolutionError::DoesNotNameAStruct(\n-                                                                &*path_names_to_string(path, 0))\n+                                                                &path_names_to_string(path, 0))\n                                      );\n                         self.record_def(expr.id, err_path_resolution());\n                     }"}, {"sha": "f21ffb9b9a16d61d1d42b800e1c405a1044a026d", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3548b8c273d9feb0291e97a928c4f48e01daf0f9/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3548b8c273d9feb0291e97a928c4f48e01daf0f9/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=3548b8c273d9feb0291e97a928c4f48e01daf0f9", "patch": "@@ -238,7 +238,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                                           -> Vec<ImportResolvingError<'b>> {\n         let mut errors = Vec::new();\n         debug!(\"(resolving imports for module subtree) resolving {}\",\n-               module_to_string(&*module_));\n+               module_to_string(&module_));\n         let orig_module = replace(&mut self.resolver.current_module, module_);\n         errors.extend(self.resolve_imports_for_module(module_));\n         self.resolver.current_module = orig_module;\n@@ -268,7 +268,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n \n         if module.all_imports_resolved() {\n             debug!(\"(resolving imports for module) all imports resolved for {}\",\n-                   module_to_string(&*module));\n+                   module_to_string(&module));\n             return errors;\n         }\n \n@@ -320,7 +320,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                                  -> ResolveResult<()> {\n         debug!(\"(resolving import for module) resolving import `{}::...` in `{}`\",\n                names_to_string(&import_directive.module_path),\n-               module_to_string(&*module_));\n+               module_to_string(&module_));\n \n         self.resolver\n             .resolve_module_path(module_,\n@@ -370,7 +370,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n         debug!(\"(resolving single import) resolving `{}` = `{}::{}` from `{}` id {}, last \\\n                 private {:?}\",\n                target,\n-               module_to_string(&*target_module),\n+               module_to_string(&target_module),\n                source,\n                module_to_string(module_),\n                directive.id,"}, {"sha": "69a70cdf144b35eb494df8c8f51ee0878254d30d", "filename": "src/librustc_trans/back/link.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3548b8c273d9feb0291e97a928c4f48e01daf0f9/src%2Flibrustc_trans%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3548b8c273d9feb0291e97a928c4f48e01daf0f9/src%2Flibrustc_trans%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flink.rs?ref=3548b8c273d9feb0291e97a928c4f48e01daf0f9", "patch": "@@ -916,7 +916,7 @@ fn link_natively(sess: &Session, dylib: bool,\n                                          pname,\n                                          prog.status))\n                     .note(&format!(\"{:?}\", &cmd))\n-                    .note(&*escape_string(&output[..]))\n+                    .note(&escape_string(&output[..]))\n                     .emit();\n                 sess.abort_if_errors();\n             }"}, {"sha": "92d8b928ef428bd8673dc25179ff32dc0ddcaa38", "filename": "src/librustc_trans/back/write.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3548b8c273d9feb0291e97a928c4f48e01daf0f9/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3548b8c273d9feb0291e97a928c4f48e01daf0f9/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fwrite.rs?ref=3548b8c273d9feb0291e97a928c4f48e01daf0f9", "patch": "@@ -380,7 +380,7 @@ unsafe extern \"C\" fn diagnostic_handler(info: DiagnosticInfoRef, user: *mut c_vo\n     match llvm::diagnostic::Diagnostic::unpack(info) {\n         llvm::diagnostic::InlineAsm(inline) => {\n             report_inline_asm(cgcx,\n-                              &*llvm::twine_to_string(inline.message),\n+                              &llvm::twine_to_string(inline.message),\n                               inline.cookie);\n         }\n "}, {"sha": "2b3899ac03ecf84c4f91409ec7b2c23b22c4bec5", "filename": "src/librustc_trans/save/dump_csv.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/3548b8c273d9feb0291e97a928c4f48e01daf0f9/src%2Flibrustc_trans%2Fsave%2Fdump_csv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3548b8c273d9feb0291e97a928c4f48e01daf0f9/src%2Flibrustc_trans%2Fsave%2Fdump_csv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fdump_csv.rs?ref=3548b8c273d9feb0291e97a928c4f48e01daf0f9", "patch": "@@ -468,7 +468,7 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n                             &name.as_str(),\n                             &qualname,\n                             &self.span.snippet(expr.span),\n-                            &ty_to_string(&*typ),\n+                            &ty_to_string(&typ),\n                             self.cur_scope);\n \n         // walk type and init value\n@@ -550,7 +550,7 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n \n             for field in variant.node.data.fields() {\n                 self.process_struct_field_def(field, variant.node.data.id());\n-                self.visit_ty(&*field.node.ty);\n+                self.visit_ty(&field.node.ty);\n             }\n         }\n         self.process_generic_params(ty_params, item.span, &enum_data.qualname, enum_data.id);\n@@ -970,7 +970,7 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DumpCsvVisitor<'l, 'tcx> {\n                                           self.cur_scope);\n             }\n             Fn(ref decl, _, _, _, ref ty_params, ref body) =>\n-                self.process_fn(item, &**decl, ty_params, &**body),\n+                self.process_fn(item, &decl, ty_params, &body),\n             Static(ref typ, _, ref expr) =>\n                 self.process_static_or_const_item(item, typ, expr),\n             Const(ref typ, ref expr) =>\n@@ -992,11 +992,11 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DumpCsvVisitor<'l, 'tcx> {\n             }\n             Ty(ref ty, ref ty_params) => {\n                 let qualname = format!(\"::{}\", self.tcx.map.path_to_string(item.id));\n-                let value = ty_to_string(&**ty);\n+                let value = ty_to_string(&ty);\n                 let sub_span = self.span.sub_span_after_keyword(item.span, keywords::Type);\n                 self.fmt.typedef_str(item.span, sub_span, item.id, &qualname, &value);\n \n-                self.visit_ty(&**ty);\n+                self.visit_ty(&ty);\n                 self.process_generic_params(ty_params, item.span, &qualname, item.id);\n             }\n             Mac(_) => (),\n@@ -1012,7 +1012,7 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DumpCsvVisitor<'l, 'tcx> {\n                 }\n             }\n             if let Some(ref ty) = param.default {\n-                self.visit_ty(&**ty);\n+                self.visit_ty(&ty);\n             }\n         }\n     }\n@@ -1024,8 +1024,8 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DumpCsvVisitor<'l, 'tcx> {\n                 self.process_const(trait_item.id,\n                                    trait_item.ident.name,\n                                    trait_item.span,\n-                                   &*ty,\n-                                   &*expr);\n+                                   &ty,\n+                                   &expr);\n             }\n             ast::TraitItemKind::Method(ref sig, ref body) => {\n                 self.process_method(sig,\n@@ -1113,7 +1113,7 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DumpCsvVisitor<'l, 'tcx> {\n                 }\n             }\n             ast::ExprKind::TupField(ref sub_ex, idx) => {\n-                self.visit_expr(&**sub_ex);\n+                self.visit_expr(&sub_ex);\n \n                 let hir_node = lower_expr(self.save_ctxt.lcx, sub_ex);\n                 let ty = &self.tcx.expr_ty_adjusted(&hir_node).sty;\n@@ -1139,15 +1139,15 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DumpCsvVisitor<'l, 'tcx> {\n \n                 // walk arg and return types\n                 for arg in &decl.inputs {\n-                    self.visit_ty(&*arg.ty);\n+                    self.visit_ty(&arg.ty);\n                 }\n \n                 if let ast::FunctionRetTy::Ty(ref ret_ty) = decl.output {\n-                    self.visit_ty(&**ret_ty);\n+                    self.visit_ty(&ret_ty);\n                 }\n \n                 // walk the body\n-                self.nest(ex.id, |v| v.visit_block(&**body));\n+                self.nest(ex.id, |v| v.visit_block(&body));\n             }\n             ast::ExprKind::ForLoop(ref pattern, ref subexpression, ref block, _) |\n             ast::ExprKind::WhileLet(ref pattern, ref subexpression, ref block, _) => {"}, {"sha": "d336ab21962de01506f27490dffb5c98743d6c4c", "filename": "src/librustc_trans/save/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3548b8c273d9feb0291e97a928c4f48e01daf0f9/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3548b8c273d9feb0291e97a928c4f48e01daf0f9/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fmod.rs?ref=3548b8c273d9feb0291e97a928c4f48e01daf0f9", "patch": "@@ -389,7 +389,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                     match item.node {\n                         hir::ItemImpl(_, _, _, _, ref ty, _) => {\n                             let mut result = String::from(\"<\");\n-                            result.push_str(&rustc_front::print::pprust::ty_to_string(&**ty));\n+                            result.push_str(&rustc_front::print::pprust::ty_to_string(&ty));\n \n                             match self.tcx.trait_of_item(self.tcx.map.local_def_id(id)) {\n                                 Some(def_id) => {"}, {"sha": "70f8e268f1745b30d19d005dbf3ed377c40a8cec", "filename": "src/librustc_trans/trans/_match.rs", "status": "modified", "additions": 39, "deletions": 39, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/3548b8c273d9feb0291e97a928c4f48e01daf0f9/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3548b8c273d9feb0291e97a928c4f48e01daf0f9/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2F_match.rs?ref=3548b8c273d9feb0291e97a928c4f48e01daf0f9", "patch": "@@ -284,7 +284,7 @@ impl<'a, 'tcx> Opt<'a, 'tcx> {\n         match *self {\n             ConstantValue(ConstantExpr(lit_expr), _) => {\n                 let lit_ty = bcx.tcx().node_id_to_type(lit_expr.id);\n-                let expr = consts::const_expr(ccx, &*lit_expr, bcx.fcx.param_substs, None, Yes);\n+                let expr = consts::const_expr(ccx, &lit_expr, bcx.fcx.param_substs, None, Yes);\n                 let llval = match expr {\n                     Ok((llval, _)) => llval,\n                     Err(err) => bcx.ccx().sess().span_fatal(lit_expr.span, &err.description()),\n@@ -294,18 +294,18 @@ impl<'a, 'tcx> Opt<'a, 'tcx> {\n                 SingleResult(Result::new(bcx, lit_datum.val))\n             }\n             ConstantRange(ConstantExpr(ref l1), ConstantExpr(ref l2), _) => {\n-                let l1 = match consts::const_expr(ccx, &**l1, bcx.fcx.param_substs, None, Yes) {\n+                let l1 = match consts::const_expr(ccx, &l1, bcx.fcx.param_substs, None, Yes) {\n                     Ok((l1, _)) => l1,\n                     Err(err) => bcx.ccx().sess().span_fatal(l1.span, &err.description()),\n                 };\n-                let l2 = match consts::const_expr(ccx, &**l2, bcx.fcx.param_substs, None, Yes) {\n+                let l2 = match consts::const_expr(ccx, &l2, bcx.fcx.param_substs, None, Yes) {\n                     Ok((l2, _)) => l2,\n                     Err(err) => bcx.ccx().sess().span_fatal(l2.span, &err.description()),\n                 };\n                 RangeResult(Result::new(bcx, l1), Result::new(bcx, l2))\n             }\n             Variant(disr_val, ref repr, _, _) => {\n-                SingleResult(Result::new(bcx, adt::trans_case(bcx, &**repr, disr_val)))\n+                SingleResult(Result::new(bcx, adt::trans_case(bcx, &repr, disr_val)))\n             }\n             SliceLengthEqual(length, _) => {\n                 SingleResult(Result::new(bcx, C_uint(ccx, length)))\n@@ -479,7 +479,7 @@ fn expand_nested_bindings<'a, 'p, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             pat = match pat.node {\n                 hir::PatIdent(_, ref path, Some(ref inner)) => {\n                     bound_ptrs.push((path.node.name, val.val));\n-                    &**inner\n+                    &inner\n                 },\n                 _ => break\n             }\n@@ -489,7 +489,7 @@ fn expand_nested_bindings<'a, 'p, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         pats[col] = pat;\n         Match {\n             pats: pats,\n-            data: &*br.data,\n+            data: &br.data,\n             bound_ptrs: bound_ptrs,\n             pat_renaming_map: br.pat_renaming_map,\n         }\n@@ -518,7 +518,7 @@ fn enter_match<'a, 'b, 'p, 'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n             let mut bound_ptrs = br.bound_ptrs.clone();\n             match this.node {\n                 hir::PatIdent(_, ref path, None) => {\n-                    if pat_is_binding(&dm.borrow(), &*this) {\n+                    if pat_is_binding(&dm.borrow(), &this) {\n                         bound_ptrs.push((path.node.name, val.val));\n                     }\n                 }\n@@ -557,7 +557,7 @@ fn enter_default<'a, 'p, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n     // Collect all of the matches that can match against anything.\n     enter_match(bcx, dm, m, col, val, |pats| {\n-        if pat_is_binding_or_wild(&dm.borrow(), &*pats[col]) {\n+        if pat_is_binding_or_wild(&dm.borrow(), &pats[col]) {\n             let mut r = pats[..col].to_vec();\n             r.extend_from_slice(&pats[col + 1..]);\n             Some(r)\n@@ -615,11 +615,11 @@ fn enter_opt<'a, 'p, 'blk, 'tcx>(\n \n     let ctor = match opt {\n         &ConstantValue(ConstantExpr(expr), _) => check_match::ConstantValue(\n-            const_eval::eval_const_expr(bcx.tcx(), &*expr)\n+            const_eval::eval_const_expr(bcx.tcx(), &expr)\n         ),\n         &ConstantRange(ConstantExpr(lo), ConstantExpr(hi), _) => check_match::ConstantRange(\n-            const_eval::eval_const_expr(bcx.tcx(), &*lo),\n-            const_eval::eval_const_expr(bcx.tcx(), &*hi)\n+            const_eval::eval_const_expr(bcx.tcx(), &lo),\n+            const_eval::eval_const_expr(bcx.tcx(), &hi)\n         ),\n         &SliceLengthEqual(n, _) =>\n             check_match::Slice(n),\n@@ -663,7 +663,7 @@ fn get_branches<'a, 'p, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n         let opt = match cur.node {\n             hir::PatLit(ref l) => {\n-                ConstantValue(ConstantExpr(&**l), debug_loc)\n+                ConstantValue(ConstantExpr(&l), debug_loc)\n             }\n             hir::PatIdent(..) | hir::PatEnum(..) | hir::PatStruct(..) => {\n                 // This is either an enum variant or a variable binding.\n@@ -680,7 +680,7 @@ fn get_branches<'a, 'p, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 }\n             }\n             hir::PatRange(ref l1, ref l2) => {\n-                ConstantRange(ConstantExpr(&**l1), ConstantExpr(&**l2), debug_loc)\n+                ConstantRange(ConstantExpr(&l1), ConstantExpr(&l2), debug_loc)\n             }\n             hir::PatVec(ref before, None, ref after) => {\n                 SliceLengthEqual(before.len() + after.len(), debug_loc)\n@@ -849,7 +849,7 @@ impl FailureHandler {\n fn pick_column_to_specialize(def_map: &RefCell<DefMap>, m: &[Match]) -> Option<usize> {\n     fn pat_score(def_map: &RefCell<DefMap>, pat: &hir::Pat) -> usize {\n         match pat.node {\n-            hir::PatIdent(_, _, Some(ref inner)) => pat_score(def_map, &**inner),\n+            hir::PatIdent(_, _, Some(ref inner)) => pat_score(def_map, &inner),\n             _ if pat_is_refutable(&def_map.borrow(), pat) => 1,\n             _ => 0\n         }\n@@ -1143,7 +1143,7 @@ fn compile_submatch<'a, 'p, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             match data.arm.guard {\n                 Some(ref guard_expr) => {\n                     bcx = compile_guard(bcx,\n-                                        &**guard_expr,\n+                                        &guard_expr,\n                                         m[0].data,\n                                         &m[1..m.len()],\n                                         vals,\n@@ -1190,7 +1190,7 @@ fn compile_submatch_continue<'a, 'p, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n     };\n     let adt_vals = if any_irrefutable_adt_pat(bcx.tcx(), m, col) {\n         let repr = adt::represent_type(bcx.ccx(), left_ty);\n-        let arg_count = adt::num_args(&*repr, Disr(0));\n+        let arg_count = adt::num_args(&repr, Disr(0));\n         let (arg_count, struct_val) = if type_is_sized(bcx.tcx(), left_ty) {\n             (arg_count, val.val)\n         } else {\n@@ -1202,7 +1202,7 @@ fn compile_submatch_continue<'a, 'p, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n         };\n         let mut field_vals: Vec<ValueRef> = (0..arg_count).map(|ix|\n             // By definition, these are all sized\n-            adt::trans_field_ptr(bcx, &*repr, adt::MaybeSizedValue::sized(struct_val), Disr(0), ix)\n+            adt::trans_field_ptr(bcx, &repr, adt::MaybeSizedValue::sized(struct_val), Disr(0), ix)\n         ).collect();\n \n         match left_ty.sty {\n@@ -1218,7 +1218,7 @@ fn compile_submatch_continue<'a, 'p, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                 let meta = Load(bcx, expr::get_meta(bcx, val.val));\n                 let struct_val = adt::MaybeSizedValue::unsized_(struct_val, meta);\n \n-                let data = adt::trans_field_ptr(bcx, &*repr, struct_val, Disr(0), arg_count);\n+                let data = adt::trans_field_ptr(bcx, &repr, struct_val, Disr(0), arg_count);\n                 Store(bcx, data, expr::get_dataptr(bcx, scratch));\n                 Store(bcx, meta, expr::get_meta(bcx, scratch));\n                 field_vals.push(scratch);\n@@ -1385,7 +1385,7 @@ fn compile_submatch_continue<'a, 'p, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n         match *opt {\n             Variant(disr_val, ref repr, _, _) => {\n                 let ExtractedBlock {vals: argvals, bcx: new_bcx} =\n-                    extract_variant_args(opt_cx, &**repr, disr_val, val);\n+                    extract_variant_args(opt_cx, &repr, disr_val, val);\n                 size = argvals.len();\n                 unpacked = argvals;\n                 opt_cx = new_bcx;\n@@ -1534,7 +1534,7 @@ fn create_bindings_map<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, pat: &hir::Pat,\n     let tcx = bcx.tcx();\n     let reassigned = is_discr_reassigned(bcx, discr, body);\n     let mut bindings_map = FnvHashMap();\n-    pat_bindings(&tcx.def_map, &*pat, |bm, p_id, span, path1| {\n+    pat_bindings(&tcx.def_map, &pat, |bm, p_id, span, path1| {\n         let name = path1.node;\n         let variable_ty = node_id_type(bcx, p_id);\n         let llvariable_ty = type_of::type_of(ccx, variable_ty);\n@@ -1604,7 +1604,7 @@ fn trans_match_inner<'blk, 'tcx>(scope_cx: Block<'blk, 'tcx>,\n     let arm_datas: Vec<ArmData> = arms.iter().map(|arm| ArmData {\n         bodycx: fcx.new_id_block(\"case_body\", arm.body.id),\n         arm: arm,\n-        bindings_map: create_bindings_map(bcx, &*arm.pats[0], discr_expr, &*arm.body)\n+        bindings_map: create_bindings_map(bcx, &arm.pats[0], discr_expr, &arm.body)\n     }).collect();\n \n     let mut pat_renaming_map = if scope_cx.sess().opts.debuginfo != NoDebugInfo {\n@@ -1624,7 +1624,7 @@ fn trans_match_inner<'blk, 'tcx>(scope_cx: Block<'blk, 'tcx>,\n     let mut matches = Vec::new();\n     for (arm_data, pats) in arm_datas.iter().zip(&arm_pats) {\n         matches.extend(pats.iter().map(|p| Match {\n-            pats: vec![&**p],\n+            pats: vec![&p],\n             data: arm_data,\n             bound_ptrs: Vec::new(),\n             pat_renaming_map: pat_renaming_map.as_ref()\n@@ -1651,7 +1651,7 @@ fn trans_match_inner<'blk, 'tcx>(scope_cx: Block<'blk, 'tcx>,\n         // insert bindings into the lllocals map and add cleanups\n         let cs = fcx.push_custom_cleanup_scope();\n         bcx = insert_lllocals(bcx, &arm_data.bindings_map, Some(cleanup::CustomScope(cs)));\n-        bcx = expr::trans_into(bcx, &*arm_data.arm.body, dest);\n+        bcx = expr::trans_into(bcx, &arm_data.arm.body, dest);\n         bcx = fcx.pop_and_trans_custom_cleanup_scope(bcx, cs);\n         arm_cxs.push(bcx);\n     }\n@@ -1668,7 +1668,7 @@ pub fn store_local<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let _icx = push_ctxt(\"match::store_local\");\n     let mut bcx = bcx;\n     let tcx = bcx.tcx();\n-    let pat = &*local.pat;\n+    let pat = &local.pat;\n \n     fn create_dummy_locals<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                                        pat: &hir::Pat)\n@@ -1723,7 +1723,7 @@ pub fn store_local<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                     return mk_binding_alloca(\n                         bcx, pat.id, name, var_scope, (),\n                         \"_match::store_local\",\n-                        |(), bcx, Datum { val: v, .. }| expr::trans_into(bcx, &**init_expr,\n+                        |(), bcx, Datum { val: v, .. }| expr::trans_into(bcx, &init_expr,\n                                                                          expr::SaveIn(v)));\n                 }\n \n@@ -1732,7 +1732,7 @@ pub fn store_local<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n             // General path.\n             let init_datum =\n-                unpack_datum!(bcx, expr::trans_to_lvalue(bcx, &**init_expr, \"let\"));\n+                unpack_datum!(bcx, expr::trans_to_lvalue(bcx, &init_expr, \"let\"));\n             if bcx.sess().asm_comments() {\n                 add_comment(bcx, \"creating zeroable ref llval\");\n             }\n@@ -1813,7 +1813,7 @@ pub fn bind_irrefutable_pat<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let ccx = bcx.ccx();\n     match pat.node {\n         hir::PatIdent(pat_binding_mode, ref path1, ref inner) => {\n-            if pat_is_binding(&tcx.def_map.borrow(), &*pat) {\n+            if pat_is_binding(&tcx.def_map.borrow(), &pat) {\n                 // Allocate the stack slot where the value of this\n                 // binding will live and place it into the appropriate\n                 // map.\n@@ -1846,7 +1846,7 @@ pub fn bind_irrefutable_pat<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             }\n \n             if let Some(ref inner_pat) = *inner {\n-                bcx = bind_irrefutable_pat(bcx, &**inner_pat, val, cleanup_scope);\n+                bcx = bind_irrefutable_pat(bcx, &inner_pat, val, cleanup_scope);\n             }\n         }\n         hir::PatEnum(_, ref sub_pats) => {\n@@ -1856,14 +1856,14 @@ pub fn bind_irrefutable_pat<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                     let repr = adt::represent_node(bcx, pat.id);\n                     let vinfo = ccx.tcx().lookup_adt_def(enum_id).variant_with_id(var_id);\n                     let args = extract_variant_args(bcx,\n-                                                    &*repr,\n+                                                    &repr,\n                                                     Disr::from(vinfo.disr_val),\n                                                     val);\n                     if let Some(ref sub_pat) = *sub_pats {\n                         for (i, &argval) in args.vals.iter().enumerate() {\n                             bcx = bind_irrefutable_pat(\n                                 bcx,\n-                                &*sub_pat[i],\n+                                &sub_pat[i],\n                                 MatchInput::from_val(argval),\n                                 cleanup_scope);\n                         }\n@@ -1879,11 +1879,11 @@ pub fn bind_irrefutable_pat<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                             let repr = adt::represent_node(bcx, pat.id);\n                             let val = adt::MaybeSizedValue::sized(val.val);\n                             for (i, elem) in elems.iter().enumerate() {\n-                                let fldptr = adt::trans_field_ptr(bcx, &*repr,\n+                                let fldptr = adt::trans_field_ptr(bcx, &repr,\n                                                                   val, Disr(0), i);\n                                 bcx = bind_irrefutable_pat(\n                                     bcx,\n-                                    &**elem,\n+                                    &elem,\n                                     MatchInput::from_val(fldptr),\n                                     cleanup_scope);\n                             }\n@@ -1914,7 +1914,7 @@ pub fn bind_irrefutable_pat<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 let field_idx = pat_v.field_index(name);\n                 let mut fldptr = adt::trans_field_ptr(\n                     bcx,\n-                    &*pat_repr,\n+                    &pat_repr,\n                     val,\n                     pat_v.discr,\n                     field_idx);\n@@ -1930,7 +1930,7 @@ pub fn bind_irrefutable_pat<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                     fldptr = scratch;\n                 }\n                 bcx = bind_irrefutable_pat(bcx,\n-                                           &*f.node.pat,\n+                                           &f.node.pat,\n                                            MatchInput::from_val(fldptr),\n                                            cleanup_scope);\n             }\n@@ -1939,10 +1939,10 @@ pub fn bind_irrefutable_pat<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             let repr = adt::represent_node(bcx, pat.id);\n             let val = adt::MaybeSizedValue::sized(val.val);\n             for (i, elem) in elems.iter().enumerate() {\n-                let fldptr = adt::trans_field_ptr(bcx, &*repr, val, Disr(0), i);\n+                let fldptr = adt::trans_field_ptr(bcx, &repr, val, Disr(0), i);\n                 bcx = bind_irrefutable_pat(\n                     bcx,\n-                    &**elem,\n+                    &elem,\n                     MatchInput::from_val(fldptr),\n                     cleanup_scope);\n             }\n@@ -1964,7 +1964,7 @@ pub fn bind_irrefutable_pat<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 val.val\n             };\n             bcx = bind_irrefutable_pat(\n-                bcx, &**inner, MatchInput::from_val(val), cleanup_scope);\n+                bcx, &inner, MatchInput::from_val(val), cleanup_scope);\n         }\n         hir::PatRegion(ref inner, _) => {\n             let pat_ty = node_id_type(bcx, inner.id);\n@@ -1984,7 +1984,7 @@ pub fn bind_irrefutable_pat<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             };\n             bcx = bind_irrefutable_pat(\n                 bcx,\n-                &**inner,\n+                &inner,\n                 MatchInput::from_val(val),\n                 cleanup_scope);\n         }\n@@ -2008,7 +2008,7 @@ pub fn bind_irrefutable_pat<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 .fold(bcx, |bcx, (inner, elem)| {\n                     bind_irrefutable_pat(\n                         bcx,\n-                        &**inner,\n+                        &inner,\n                         MatchInput::from_val(elem),\n                         cleanup_scope)\n                 });"}, {"sha": "33370abc3fcc14e9cd4d1a04f9301611802ed8cc", "filename": "src/librustc_trans/trans/asm.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/3548b8c273d9feb0291e97a928c4f48e01daf0f9/src%2Flibrustc_trans%2Ftrans%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3548b8c273d9feb0291e97a928c4f48e01daf0f9/src%2Flibrustc_trans%2Ftrans%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fasm.rs?ref=3548b8c273d9feb0291e97a928c4f48e01daf0f9", "patch": "@@ -44,10 +44,10 @@ pub fn trans_inline_asm<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, ia: &ast::InlineAsm)\n     for (i, out) in ia.outputs.iter().enumerate() {\n         constraints.push(out.constraint.clone());\n \n-        let out_datum = unpack_datum!(bcx, expr::trans(bcx, &*out.expr));\n+        let out_datum = unpack_datum!(bcx, expr::trans(bcx, &out.expr));\n         if out.is_indirect {\n             bcx = callee::trans_arg_datum(bcx,\n-                                          expr_ty(bcx, &*out.expr),\n+                                          expr_ty(bcx, &out.expr),\n                                           out_datum,\n                                           cleanup::CustomScope(temp_scope),\n                                           callee::DontAutorefArg,\n@@ -61,7 +61,7 @@ pub fn trans_inline_asm<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, ia: &ast::InlineAsm)\n             outputs.push(out_datum.val);\n             if out.is_rw {\n                 bcx = callee::trans_arg_datum(bcx,\n-                                              expr_ty(bcx, &*out.expr),\n+                                              expr_ty(bcx, &out.expr),\n                                               out_datum,\n                                               cleanup::CustomScope(temp_scope),\n                                               callee::DontAutorefArg,\n@@ -75,9 +75,9 @@ pub fn trans_inline_asm<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, ia: &ast::InlineAsm)\n     for &(ref c, ref input) in &ia.inputs {\n         constraints.push((*c).clone());\n \n-        let in_datum = unpack_datum!(bcx, expr::trans(bcx, &**input));\n+        let in_datum = unpack_datum!(bcx, expr::trans(bcx, &input));\n         bcx = callee::trans_arg_datum(bcx,\n-                                    expr_ty(bcx, &**input),\n+                                    expr_ty(bcx, &input),\n                                     in_datum,\n                                     cleanup::CustomScope(temp_scope),\n                                     callee::DontAutorefArg,\n@@ -159,4 +159,3 @@ pub fn trans_inline_asm<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, ia: &ast::InlineAsm)\n     return bcx;\n \n }\n-"}, {"sha": "e36905c6d90ea22329419f1cb355540caba45194", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/3548b8c273d9feb0291e97a928c4f48e01daf0f9/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3548b8c273d9feb0291e97a928c4f48e01daf0f9/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=3548b8c273d9feb0291e97a928c4f48e01daf0f9", "patch": "@@ -513,7 +513,7 @@ pub fn iter_structural_ty<'blk, 'tcx, F>(cx: Block<'blk, 'tcx>,\n             let repr = adt::represent_type(cx.ccx(), t);\n             let VariantInfo { fields, discr } = VariantInfo::from_ty(cx.tcx(), t, None);\n             for (i, &Field(_, field_ty)) in fields.iter().enumerate() {\n-                let llfld_a = adt::trans_field_ptr(cx, &*repr, value, Disr::from(discr), i);\n+                let llfld_a = adt::trans_field_ptr(cx, &repr, value, Disr::from(discr), i);\n \n                 let val = if common::type_is_sized(cx.tcx(), field_ty) {\n                     llfld_a\n@@ -529,7 +529,7 @@ pub fn iter_structural_ty<'blk, 'tcx, F>(cx: Block<'blk, 'tcx>,\n         ty::TyClosure(_, ref substs) => {\n             let repr = adt::represent_type(cx.ccx(), t);\n             for (i, upvar_ty) in substs.upvar_tys.iter().enumerate() {\n-                let llupvar = adt::trans_field_ptr(cx, &*repr, value, Disr(0), i);\n+                let llupvar = adt::trans_field_ptr(cx, &repr, value, Disr(0), i);\n                 cx = f(cx, llupvar, upvar_ty);\n             }\n         }\n@@ -545,7 +545,7 @@ pub fn iter_structural_ty<'blk, 'tcx, F>(cx: Block<'blk, 'tcx>,\n         ty::TyTuple(ref args) => {\n             let repr = adt::represent_type(cx.ccx(), t);\n             for (i, arg) in args.iter().enumerate() {\n-                let llfld_a = adt::trans_field_ptr(cx, &*repr, value, Disr(0), i);\n+                let llfld_a = adt::trans_field_ptr(cx, &repr, value, Disr(0), i);\n                 cx = f(cx, llfld_a, *arg);\n             }\n         }\n@@ -559,11 +559,11 @@ pub fn iter_structural_ty<'blk, 'tcx, F>(cx: Block<'blk, 'tcx>,\n             // NB: we must hit the discriminant first so that structural\n             // comparison know not to proceed when the discriminants differ.\n \n-            match adt::trans_switch(cx, &*repr, av, false) {\n+            match adt::trans_switch(cx, &repr, av, false) {\n                 (_match::Single, None) => {\n                     if n_variants != 0 {\n                         assert!(n_variants == 1);\n-                        cx = iter_variant(cx, &*repr, adt::MaybeSizedValue::sized(av),\n+                        cx = iter_variant(cx, &repr, adt::MaybeSizedValue::sized(av),\n                                           &en.variants[0], substs, &mut f);\n                     }\n                 }\n@@ -592,10 +592,10 @@ pub fn iter_structural_ty<'blk, 'tcx, F>(cx: Block<'blk, 'tcx>,\n                         let variant_cx = fcx.new_temp_block(&format!(\"enum-iter-variant-{}\",\n                                                                      &variant.disr_val\n                                                                              .to_string()));\n-                        let case_val = adt::trans_case(cx, &*repr, Disr::from(variant.disr_val));\n+                        let case_val = adt::trans_case(cx, &repr, Disr::from(variant.disr_val));\n                         AddCase(llswitch, case_val, variant_cx.llbb);\n                         let variant_cx = iter_variant(variant_cx,\n-                                                      &*repr,\n+                                                      &repr,\n                                                       value,\n                                                       variant,\n                                                       substs,\n@@ -1530,7 +1530,7 @@ fn has_nested_returns(tcx: &ty::ctxt, cfg: &cfg::CFG, blk_id: ast::NodeId) -> bo\n             Some(hir_map::NodeExpr(ex)) => {\n                 if let hir::ExprRet(Some(ref ret_expr)) = ex.node {\n                     let mut visitor = FindNestedReturn::new();\n-                    intravisit::walk_expr(&mut visitor, &**ret_expr);\n+                    intravisit::walk_expr(&mut visitor, &ret_expr);\n                     if visitor.found {\n                         return true;\n                     }\n@@ -2272,7 +2272,7 @@ fn trans_enum_variant_or_tuple_like_struct<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx\n         let repr = adt::represent_type(ccx, result_ty.unwrap());\n         let mut llarg_idx = fcx.arg_offset() as c_uint;\n         for (i, arg_ty) in arg_tys.into_iter().enumerate() {\n-            let lldestptr = adt::trans_field_ptr(bcx, &*repr, dest_val, Disr::from(disr), i);\n+            let lldestptr = adt::trans_field_ptr(bcx, &repr, dest_val, Disr::from(disr), i);\n             if common::type_is_fat_ptr(bcx.tcx(), arg_ty) {\n                 Store(bcx,\n                       get_param(fcx.llfn, llarg_idx),\n@@ -2292,7 +2292,7 @@ fn trans_enum_variant_or_tuple_like_struct<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx\n                 }\n             }\n         }\n-        adt::trans_set_discr(bcx, &*repr, dest, disr);\n+        adt::trans_set_discr(bcx, &repr, dest, disr);\n     }\n \n     finish_fn(&fcx, bcx, result_ty, DebugLoc::None);\n@@ -2346,14 +2346,14 @@ fn enum_variant_size_lint(ccx: &CrateContext, enum_def: &hir::EnumDef, sp: Span,\n \n         let sess = &ccx.tcx().sess;\n         sess.span_note_without_error(sp,\n-                                     &*format!(\"total size: {} bytes\", llsize_of_real(ccx, llty)));\n+                                     &format!(\"total size: {} bytes\", llsize_of_real(ccx, llty)));\n         match *avar {\n             adt::General(..) => {\n                 for (i, var) in enum_def.variants.iter().enumerate() {\n                     ccx.tcx()\n                        .sess\n                        .span_note_without_error(var.span,\n-                                                &*format!(\"variant data: {} bytes\", sizes[i]));\n+                                                &format!(\"variant data: {} bytes\", sizes[i]));\n                 }\n             }\n             _ => {}\n@@ -2505,17 +2505,17 @@ pub fn trans_item(ccx: &CrateContext, item: &hir::Item) {\n                     let empty_substs = ccx.tcx().mk_substs(Substs::trans_empty());\n                     if abi != Abi::Rust {\n                         foreign::trans_rust_fn_with_foreign_abi(ccx,\n-                                                                &**decl,\n-                                                                &**body,\n+                                                                &decl,\n+                                                                &body,\n                                                                 &item.attrs,\n                                                                 llfn,\n                                                                 empty_substs,\n                                                                 item.id,\n                                                                 None);\n                     } else {\n                         trans_fn(ccx,\n-                                 &**decl,\n-                                 &**body,\n+                                 &decl,\n+                                 &body,\n                                  llfn,\n                                  empty_substs,\n                                  item.id,\n@@ -2837,11 +2837,11 @@ pub fn get_item_val(ccx: &CrateContext, id: ast::NodeId) -> ValueRef {\n                 hir::ForeignItemFn(..) => {\n                     let abi = ccx.tcx().map.get_foreign_abi(id);\n                     let ty = ccx.tcx().node_id_to_type(ni.id);\n-                    let name = foreign::link_name(&*ni);\n+                    let name = foreign::link_name(&ni);\n                     foreign::register_foreign_item_fn(ccx, abi, ty, &name, &ni.attrs)\n                 }\n                 hir::ForeignItemStatic(..) => {\n-                    foreign::register_static(ccx, &*ni)\n+                    foreign::register_static(ccx, &ni)\n                 }\n             }\n         }"}, {"sha": "e8dd9840fc00583da071138ba20906e550bf1105", "filename": "src/librustc_trans/trans/callee.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3548b8c273d9feb0291e97a928c4f48e01daf0f9/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3548b8c273d9feb0291e97a928c4f48e01daf0f9/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs?ref=3548b8c273d9feb0291e97a928c4f48e01daf0f9", "patch": "@@ -755,7 +755,7 @@ pub fn trans_call_inner<'a, 'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n \n         let mut llargs = Vec::new();\n         let arg_tys = match args {\n-            ArgExprs(a) => a.iter().map(|x| common::expr_ty_adjusted(bcx, &**x)).collect(),\n+            ArgExprs(a) => a.iter().map(|x| common::expr_ty_adjusted(bcx, &x)).collect(),\n             _ => panic!(\"expected arg exprs.\")\n         };\n         bcx = trans_args(bcx,\n@@ -835,7 +835,7 @@ fn trans_args_under_call_abi<'blk, 'tcx>(\n \n     // Translate the `self` argument first.\n     if !ignore_self {\n-        let arg_datum = unpack_datum!(bcx, expr::trans(bcx, &*arg_exprs[0]));\n+        let arg_datum = unpack_datum!(bcx, expr::trans(bcx, &arg_exprs[0]));\n         bcx = trans_arg_datum(bcx,\n                               args[0],\n                               arg_datum,\n@@ -851,14 +851,14 @@ fn trans_args_under_call_abi<'blk, 'tcx>(\n     match tuple_type.sty {\n         ty::TyTuple(ref field_types) => {\n             let tuple_datum = unpack_datum!(bcx,\n-                                            expr::trans(bcx, &**tuple_expr));\n+                                            expr::trans(bcx, &tuple_expr));\n             let tuple_lvalue_datum =\n                 unpack_datum!(bcx,\n                               tuple_datum.to_lvalue_datum(bcx,\n                                                           \"args\",\n                                                           tuple_expr.id));\n             let repr = adt::represent_type(bcx.ccx(), tuple_type);\n-            let repr_ptr = &*repr;\n+            let repr_ptr = &repr;\n             for (i, field_type) in field_types.iter().enumerate() {\n                 let arg_datum = tuple_lvalue_datum.get_element(\n                     bcx,\n@@ -971,12 +971,12 @@ pub fn trans_args<'a, 'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n                 }\n                 let arg_ty = if i >= num_formal_args {\n                     assert!(variadic);\n-                    common::expr_ty_adjusted(cx, &**arg_expr)\n+                    common::expr_ty_adjusted(cx, &arg_expr)\n                 } else {\n                     arg_tys[i]\n                 };\n \n-                let arg_datum = unpack_datum!(bcx, expr::trans(bcx, &**arg_expr));\n+                let arg_datum = unpack_datum!(bcx, expr::trans(bcx, &arg_expr));\n                 bcx = trans_arg_datum(bcx, arg_ty, arg_datum,\n                                       arg_cleanup_scope,\n                                       DontAutorefArg,"}, {"sha": "b1db196ecef0c850137deb7e78389b141905c3d4", "filename": "src/librustc_trans/trans/closure.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3548b8c273d9feb0291e97a928c4f48e01daf0f9/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3548b8c273d9feb0291e97a928c4f48e01daf0f9/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs?ref=3548b8c273d9feb0291e97a928c4f48e01daf0f9", "patch": "@@ -243,7 +243,7 @@ pub fn trans_closure_expr<'a, 'tcx>(dest: Dest<'a, 'tcx>,\n     for (i, freevar) in freevars.iter().enumerate() {\n         let datum = expr::trans_local_var(bcx, freevar.def);\n         let upvar_slot_dest = adt::trans_field_ptr(\n-            bcx, &*repr, adt::MaybeSizedValue::sized(dest_addr), Disr(0), i);\n+            bcx, &repr, adt::MaybeSizedValue::sized(dest_addr), Disr(0), i);\n         let upvar_id = ty::UpvarId { var_id: freevar.def.var_id(),\n                                      closure_expr_id: id };\n         match tcx.upvar_capture(upvar_id).unwrap() {\n@@ -255,7 +255,7 @@ pub fn trans_closure_expr<'a, 'tcx>(dest: Dest<'a, 'tcx>,\n             }\n         }\n     }\n-    adt::trans_set_discr(bcx, &*repr, dest_addr, Disr(0));\n+    adt::trans_set_discr(bcx, &repr, dest_addr, Disr(0));\n \n     Some(bcx)\n }"}, {"sha": "21cb082f0660cd8c179f3c2e64596d106521c842", "filename": "src/librustc_trans/trans/collector.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3548b8c273d9feb0291e97a928c4f48e01daf0f9/src%2Flibrustc_trans%2Ftrans%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3548b8c273d9feb0291e97a928c4f48e01daf0f9/src%2Flibrustc_trans%2Ftrans%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcollector.rs?ref=3548b8c273d9feb0291e97a928c4f48e01daf0f9", "patch": "@@ -329,7 +329,7 @@ impl<'mir, 'tcx: 'mir> CachedMir<'mir, 'tcx> {\n     fn get_ref<'a>(&'a self) -> &'a mir::Mir<'tcx> {\n         match *self {\n             CachedMir::Ref(r) => r,\n-            CachedMir::Owned(ref rc) => &**rc,\n+            CachedMir::Owned(ref rc) => &rc,\n         }\n     }\n }"}, {"sha": "4f25091d343c85e9984dce0ce2cc05f3e0cbbdb6", "filename": "src/librustc_trans/trans/consts.rs", "status": "modified", "additions": 29, "deletions": 29, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/3548b8c273d9feb0291e97a928c4f48e01daf0f9/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3548b8c273d9feb0291e97a928c4f48e01daf0f9/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs?ref=3548b8c273d9feb0291e97a928c4f48e01daf0f9", "patch": "@@ -212,7 +212,7 @@ fn const_fn_call<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     let substs = ccx.tcx().mk_substs(node_id_substs(ccx, node, param_substs));\n     match fn_like.body().expr {\n         Some(ref expr) => {\n-            const_expr(ccx, &**expr, substs, Some(&fn_args), trueconst).map(|(res, _)| res)\n+            const_expr(ccx, &expr, substs, Some(&fn_args), trueconst).map(|(res, _)| res)\n         },\n         None => Ok(C_nil(ccx)),\n     }\n@@ -570,27 +570,27 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n     let map_list = |exprs: &[P<hir::Expr>]| -> Result<Vec<ValueRef>, ConstEvalFailure> {\n         exprs.iter()\n-             .map(|e| const_expr(cx, &**e, param_substs, fn_args, trueconst).map(|(l, _)| l))\n+             .map(|e| const_expr(cx, &e, param_substs, fn_args, trueconst).map(|(l, _)| l))\n              .collect::<Vec<Result<ValueRef, ConstEvalFailure>>>()\n              .into_iter()\n              .collect()\n          // this dance is necessary to eagerly run const_expr so all errors are reported\n     };\n     let _icx = push_ctxt(\"const_expr\");\n     Ok(match e.node {\n-        hir::ExprLit(ref lit) => const_lit(cx, e, &**lit),\n+        hir::ExprLit(ref lit) => const_lit(cx, e, &lit),\n         hir::ExprBinary(b, ref e1, ref e2) => {\n             /* Neither type is bottom, and we expect them to be unified\n              * already, so the following is safe. */\n-            let (te1, ty) = try!(const_expr(cx, &**e1, param_substs, fn_args, trueconst));\n+            let (te1, ty) = try!(const_expr(cx, &e1, param_substs, fn_args, trueconst));\n             debug!(\"const_expr_unadjusted: te1={}, ty={:?}\",\n                    cx.tn().val_to_string(te1),\n                    ty);\n             assert!(!ty.is_simd());\n             let is_float = ty.is_fp();\n             let signed = ty.is_signed();\n \n-            let (te2, _) = try!(const_expr(cx, &**e2, param_substs, fn_args, trueconst));\n+            let (te2, _) = try!(const_expr(cx, &e2, param_substs, fn_args, trueconst));\n \n             try!(check_binary_expr_validity(cx, e, ty, te1, te2, trueconst));\n \n@@ -638,7 +638,7 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             } } // unsafe { match b.node {\n         },\n         hir::ExprUnary(u, ref inner_e) => {\n-            let (te, ty) = try!(const_expr(cx, &**inner_e, param_substs, fn_args, trueconst));\n+            let (te, ty) = try!(const_expr(cx, &inner_e, param_substs, fn_args, trueconst));\n \n             try!(check_unary_expr_validity(cx, e, ty, te, trueconst));\n \n@@ -651,20 +651,20 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             } }\n         },\n         hir::ExprField(ref base, field) => {\n-            let (bv, bt) = try!(const_expr(cx, &**base, param_substs, fn_args, trueconst));\n+            let (bv, bt) = try!(const_expr(cx, &base, param_substs, fn_args, trueconst));\n             let brepr = adt::represent_type(cx, bt);\n             let vinfo = VariantInfo::from_ty(cx.tcx(), bt, None);\n             let ix = vinfo.field_index(field.node);\n-            adt::const_get_field(cx, &*brepr, bv, vinfo.discr, ix)\n+            adt::const_get_field(cx, &brepr, bv, vinfo.discr, ix)\n         },\n         hir::ExprTupField(ref base, idx) => {\n-            let (bv, bt) = try!(const_expr(cx, &**base, param_substs, fn_args, trueconst));\n+            let (bv, bt) = try!(const_expr(cx, &base, param_substs, fn_args, trueconst));\n             let brepr = adt::represent_type(cx, bt);\n             let vinfo = VariantInfo::from_ty(cx.tcx(), bt, None);\n-            adt::const_get_field(cx, &*brepr, bv, vinfo.discr, idx.node)\n+            adt::const_get_field(cx, &brepr, bv, vinfo.discr, idx.node)\n         },\n         hir::ExprIndex(ref base, ref index) => {\n-            let (bv, bt) = try!(const_expr(cx, &**base, param_substs, fn_args, trueconst));\n+            let (bv, bt) = try!(const_expr(cx, &base, param_substs, fn_args, trueconst));\n             let iv = match eval_const_expr_partial(cx.tcx(), &index, ExprTypeChecked, None) {\n                 Ok(ConstVal::Int(i)) => i as u64,\n                 Ok(ConstVal::Uint(u)) => u,\n@@ -716,7 +716,7 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         hir::ExprCast(ref base, _) => {\n             let t_cast = ety;\n             let llty = type_of::type_of(cx, t_cast);\n-            let (v, t_expr) = try!(const_expr(cx, &**base, param_substs, fn_args, trueconst));\n+            let (v, t_expr) = try!(const_expr(cx, &base, param_substs, fn_args, trueconst));\n             debug!(\"trans_const_cast({:?} as {:?})\", t_expr, t_cast);\n             if expr::cast_is_noop(cx.tcx(), base, t_expr, t_cast) {\n                 return Ok(v);\n@@ -741,9 +741,9 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             ) {\n                 (CastTy::Int(IntTy::CEnum), CastTy::Int(_)) => {\n                     let repr = adt::represent_type(cx, t_expr);\n-                    let discr = adt::const_get_discrim(cx, &*repr, v);\n+                    let discr = adt::const_get_discrim(cx, &repr, v);\n                     let iv = C_integral(cx.int_type(), discr.0, false);\n-                    let s = adt::is_discr_signed(&*repr) as Bool;\n+                    let s = adt::is_discr_signed(&repr) as Bool;\n                     llvm::LLVMConstIntCast(iv, llty.to_ref(), s)\n                 },\n                 (CastTy::Int(_), CastTy::Int(_)) => {\n@@ -798,26 +798,26 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             } else {\n                 // If this isn't the address of a static, then keep going through\n                 // normal constant evaluation.\n-                let (v, ty) = try!(const_expr(cx, &**sub, param_substs, fn_args, trueconst));\n+                let (v, ty) = try!(const_expr(cx, &sub, param_substs, fn_args, trueconst));\n                 addr_of(cx, v, type_of::align_of(cx, ty), \"ref\")\n             }\n         },\n         hir::ExprAddrOf(hir::MutMutable, ref sub) => {\n-            let (v, ty) = try!(const_expr(cx, &**sub, param_substs, fn_args, trueconst));\n+            let (v, ty) = try!(const_expr(cx, &sub, param_substs, fn_args, trueconst));\n             addr_of_mut(cx, v, type_of::align_of(cx, ty), \"ref_mut_slice\")\n         },\n         hir::ExprTup(ref es) => {\n             let repr = adt::represent_type(cx, ety);\n             let vals = try!(map_list(&es[..]));\n-            adt::trans_const(cx, &*repr, Disr(0), &vals[..])\n+            adt::trans_const(cx, &repr, Disr(0), &vals[..])\n         },\n         hir::ExprStruct(_, ref fs, ref base_opt) => {\n             let repr = adt::represent_type(cx, ety);\n \n             let base_val = match *base_opt {\n                 Some(ref base) => Some(try!(const_expr(\n                     cx,\n-                    &**base,\n+                    &base,\n                     param_substs,\n                     fn_args,\n                     trueconst,\n@@ -829,9 +829,9 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             let cs = fields.iter().enumerate().map(|(ix, &Field(f_name, _))| {\n                 match (fs.iter().find(|f| f_name == f.name.node), base_val) {\n                     (Some(ref f), _) => {\n-                        const_expr(cx, &*f.expr, param_substs, fn_args, trueconst).map(|(l, _)| l)\n+                        const_expr(cx, &f.expr, param_substs, fn_args, trueconst).map(|(l, _)| l)\n                     },\n-                    (_, Some((bv, _))) => Ok(adt::const_get_field(cx, &*repr, bv, discr, ix)),\n+                    (_, Some((bv, _))) => Ok(adt::const_get_field(cx, &repr, bv, discr, ix)),\n                     (_, None) => cx.sess().span_bug(e.span, \"missing struct field\"),\n                 }\n             })\n@@ -842,7 +842,7 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             if ety.is_simd() {\n                 C_vector(&cs[..])\n             } else {\n-                adt::trans_const(cx, &*repr, discr, &cs[..])\n+                adt::trans_const(cx, &repr, discr, &cs[..])\n             }\n         },\n         hir::ExprVec(ref es) => {\n@@ -851,7 +851,7 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             let vs = es.iter()\n                        .map(|e| const_expr(\n                            cx,\n-                           &**e,\n+                           &e,\n                            param_substs,\n                            fn_args,\n                            trueconst,\n@@ -871,7 +871,7 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             let unit_ty = ety.sequence_element_type(cx.tcx());\n             let llunitty = type_of::type_of(cx, unit_ty);\n             let n = cx.tcx().eval_repeat_count(count);\n-            let unit_val = try!(const_expr(cx, &**elem, param_substs, fn_args, trueconst)).0;\n+            let unit_val = try!(const_expr(cx, &elem, param_substs, fn_args, trueconst)).0;\n             let vs = vec![unit_val; n];\n             if val_ty(unit_val) != llunitty {\n                 C_struct(cx, &vs[..], false)\n@@ -900,7 +900,7 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                     match vinfo.kind() {\n                         ty::VariantKind::Unit => {\n                             let repr = adt::represent_type(cx, ety);\n-                            adt::trans_const(cx, &*repr, Disr::from(vinfo.disr_val), &[])\n+                            adt::trans_const(cx, &repr, Disr::from(vinfo.disr_val), &[])\n                         }\n                         ty::VariantKind::Tuple => {\n                             expr::trans_def_fn_unadjusted(cx, e, def, param_substs).val\n@@ -930,7 +930,7 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             loop {\n                 callee = match callee.node {\n                     hir::ExprBlock(ref block) => match block.expr {\n-                        Some(ref tail) => &**tail,\n+                        Some(ref tail) => &tail,\n                         None => break,\n                     },\n                     _ => break,\n@@ -954,14 +954,14 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                         C_vector(&arg_vals[..])\n                     } else {\n                         let repr = adt::represent_type(cx, ety);\n-                        adt::trans_const(cx, &*repr, Disr(0), &arg_vals[..])\n+                        adt::trans_const(cx, &repr, Disr(0), &arg_vals[..])\n                     }\n                 }\n                 Def::Variant(enum_did, variant_did) => {\n                     let repr = adt::represent_type(cx, ety);\n                     let vinfo = cx.tcx().lookup_adt_def(enum_did).variant_with_id(variant_did);\n                     adt::trans_const(cx,\n-                                     &*repr,\n+                                     &repr,\n                                      Disr::from(vinfo.disr_val),\n                                      &arg_vals[..])\n                 }\n@@ -975,12 +975,12 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             try!(const_fn_call(cx, MethodCallKey(method_call),\n                                method_did, &arg_vals, param_substs, trueconst))\n         },\n-        hir::ExprType(ref e, _) => try!(const_expr(cx, &**e, param_substs, fn_args, trueconst)).0,\n+        hir::ExprType(ref e, _) => try!(const_expr(cx, &e, param_substs, fn_args, trueconst)).0,\n         hir::ExprBlock(ref block) => {\n             match block.expr {\n                 Some(ref expr) => try!(const_expr(\n                     cx,\n-                    &**expr,\n+                    &expr,\n                     param_substs,\n                     fn_args,\n                     trueconst,"}, {"sha": "e84e1b45cedcd76dcaddd7fb0d8d538ea2f22810", "filename": "src/librustc_trans/trans/controlflow.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/3548b8c273d9feb0291e97a928c4f48e01daf0f9/src%2Flibrustc_trans%2Ftrans%2Fcontrolflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3548b8c273d9feb0291e97a928c4f48e01daf0f9/src%2Flibrustc_trans%2Ftrans%2Fcontrolflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcontrolflow.rs?ref=3548b8c273d9feb0291e97a928c4f48e01daf0f9", "patch": "@@ -57,13 +57,13 @@ pub fn trans_stmt<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n \n     match s.node {\n         hir::StmtExpr(ref e, _) | hir::StmtSemi(ref e, _) => {\n-            bcx = trans_stmt_semi(bcx, &**e);\n+            bcx = trans_stmt_semi(bcx, &e);\n         }\n         hir::StmtDecl(ref d, _) => {\n             match d.node {\n                 hir::DeclLocal(ref local) => {\n-                    bcx = init_local(bcx, &**local);\n-                    debuginfo::create_local_var_metadata(bcx, &**local);\n+                    bcx = init_local(bcx, &local);\n+                    debuginfo::create_local_var_metadata(bcx, &local);\n                 }\n                 // Inner items are visited by `trans_item`/`trans_meth`.\n                 hir::DeclItem(_) => {},\n@@ -132,7 +132,7 @@ pub fn trans_block<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     match b.expr {\n         Some(ref e) => {\n             if !bcx.unreachable.get() {\n-                bcx = expr::trans_into(bcx, &**e, dest);\n+                bcx = expr::trans_into(bcx, &e, dest);\n             }\n         }\n         None => {\n@@ -169,11 +169,11 @@ pub fn trans_if<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     if let Some(cv) = const_to_opt_uint(cond_val) {\n         if cv == 1 {\n             // if true { .. } [else { .. }]\n-            bcx = trans_block(bcx, &*thn, dest);\n+            bcx = trans_block(bcx, &thn, dest);\n             trans::debuginfo::clear_source_location(bcx.fcx);\n         } else {\n             if let Some(elexpr) = els {\n-                bcx = expr::trans_into(bcx, &*elexpr, dest);\n+                bcx = expr::trans_into(bcx, &elexpr, dest);\n                 trans::debuginfo::clear_source_location(bcx.fcx);\n             }\n         }\n@@ -183,7 +183,7 @@ pub fn trans_if<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n     let name = format!(\"then-block-{}-\", thn.id);\n     let then_bcx_in = bcx.fcx.new_id_block(&name[..], thn.id);\n-    let then_bcx_out = trans_block(then_bcx_in, &*thn, dest);\n+    let then_bcx_out = trans_block(then_bcx_in, &thn, dest);\n     trans::debuginfo::clear_source_location(bcx.fcx);\n \n     let cond_source_loc = cond.debug_loc();\n@@ -192,7 +192,7 @@ pub fn trans_if<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     match els {\n         Some(elexpr) => {\n             let else_bcx_in = bcx.fcx.new_id_block(\"else-block\", elexpr.id);\n-            let else_bcx_out = expr::trans_into(else_bcx_in, &*elexpr, dest);\n+            let else_bcx_out = expr::trans_into(else_bcx_in, &elexpr, dest);\n             next_bcx = bcx.fcx.join_blocks(if_id,\n                                            &[then_bcx_out, else_bcx_out]);\n             CondBr(bcx, cond_val, then_bcx_in.llbb, else_bcx_in.llbb, cond_source_loc);\n@@ -365,13 +365,13 @@ pub fn trans_ret<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let mut bcx = bcx;\n     let dest = match (fcx.llretslotptr.get(), retval_expr) {\n         (Some(_), Some(retval_expr)) => {\n-            let ret_ty = expr_ty_adjusted(bcx, &*retval_expr);\n+            let ret_ty = expr_ty_adjusted(bcx, &retval_expr);\n             expr::SaveIn(fcx.get_ret_slot(bcx, ty::FnConverging(ret_ty), \"ret_slot\"))\n         }\n         _ => expr::Ignore,\n     };\n     if let Some(x) = retval_expr {\n-        bcx = expr::trans_into(bcx, &*x, dest);\n+        bcx = expr::trans_into(bcx, &x, dest);\n         match dest {\n             expr::SaveIn(slot) if fcx.needs_ret_allocas => {\n                 Store(bcx, slot, fcx.llretslotptr.get().unwrap());"}, {"sha": "bbbc9c4eda46842945c36fdba984a465984f341c", "filename": "src/librustc_trans/trans/debuginfo/create_scope_map.rs", "status": "modified", "additions": 48, "deletions": 48, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/3548b8c273d9feb0291e97a928c4f48e01daf0f9/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fcreate_scope_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3548b8c273d9feb0291e97a928c4f48e01daf0f9/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fcreate_scope_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fcreate_scope_map.rs?ref=3548b8c273d9feb0291e97a928c4f48e01daf0f9", "patch": "@@ -47,7 +47,7 @@ pub fn create_scope_map(cx: &CrateContext,\n     // Push argument identifiers onto the stack so arguments integrate nicely\n     // with variable shadowing.\n     for arg in args {\n-        pat_util::pat_bindings_ident(def_map, &*arg.pat, |_, node_id, _, path1| {\n+        pat_util::pat_bindings_ident(def_map, &arg.pat, |_, node_id, _, path1| {\n             scope_stack.push(ScopeStackEntry { scope_metadata: fn_metadata,\n                                                name: Some(path1.node.unhygienic_name) });\n             scope_map.insert(node_id, fn_metadata);\n@@ -122,15 +122,15 @@ fn walk_block(cx: &CrateContext,\n \n         match statement.node {\n             hir::StmtDecl(ref decl, _) =>\n-                walk_decl(cx, &**decl, scope_stack, scope_map),\n+                walk_decl(cx, &decl, scope_stack, scope_map),\n             hir::StmtExpr(ref exp, _) |\n             hir::StmtSemi(ref exp, _) =>\n-                walk_expr(cx, &**exp, scope_stack, scope_map),\n+                walk_expr(cx, &exp, scope_stack, scope_map),\n         }\n     }\n \n     if let Some(ref exp) = block.expr {\n-        walk_expr(cx, &**exp, scope_stack, scope_map);\n+        walk_expr(cx, &exp, scope_stack, scope_map);\n     }\n }\n \n@@ -142,10 +142,10 @@ fn walk_decl(cx: &CrateContext,\n         codemap::Spanned { node: hir::DeclLocal(ref local), .. } => {\n             scope_map.insert(local.id, scope_stack.last().unwrap().scope_metadata);\n \n-            walk_pattern(cx, &*local.pat, scope_stack, scope_map);\n+            walk_pattern(cx, &local.pat, scope_stack, scope_map);\n \n             if let Some(ref exp) = local.init {\n-                walk_expr(cx, &**exp, scope_stack, scope_map);\n+                walk_expr(cx, &exp, scope_stack, scope_map);\n             }\n         }\n         _ => ()\n@@ -167,7 +167,7 @@ fn walk_pattern(cx: &CrateContext,\n \n             // Check if this is a binding. If so we need to put it on the\n             // scope stack and maybe introduce an artificial scope\n-            if pat_util::pat_is_binding(&def_map.borrow(), &*pat) {\n+            if pat_util::pat_is_binding(&def_map.borrow(), &pat) {\n \n                 let name = path1.node.unhygienic_name;\n \n@@ -231,7 +231,7 @@ fn walk_pattern(cx: &CrateContext,\n             scope_map.insert(pat.id, scope_stack.last().unwrap().scope_metadata);\n \n             if let Some(ref sub_pat) = *sub_pat_opt {\n-                walk_pattern(cx, &**sub_pat, scope_stack, scope_map);\n+                walk_pattern(cx, &sub_pat, scope_stack, scope_map);\n             }\n         }\n \n@@ -244,7 +244,7 @@ fn walk_pattern(cx: &CrateContext,\n \n             if let Some(ref sub_pats) = *sub_pats_opt {\n                 for p in sub_pats {\n-                    walk_pattern(cx, &**p, scope_stack, scope_map);\n+                    walk_pattern(cx, &p, scope_stack, scope_map);\n                 }\n             }\n         }\n@@ -260,47 +260,47 @@ fn walk_pattern(cx: &CrateContext,\n                 node: hir::FieldPat { pat: ref sub_pat, .. },\n                 ..\n             } in field_pats {\n-                walk_pattern(cx, &**sub_pat, scope_stack, scope_map);\n+                walk_pattern(cx, &sub_pat, scope_stack, scope_map);\n             }\n         }\n \n         hir::PatTup(ref sub_pats) => {\n             scope_map.insert(pat.id, scope_stack.last().unwrap().scope_metadata);\n \n             for sub_pat in sub_pats {\n-                walk_pattern(cx, &**sub_pat, scope_stack, scope_map);\n+                walk_pattern(cx, &sub_pat, scope_stack, scope_map);\n             }\n         }\n \n         hir::PatBox(ref sub_pat) | hir::PatRegion(ref sub_pat, _) => {\n             scope_map.insert(pat.id, scope_stack.last().unwrap().scope_metadata);\n-            walk_pattern(cx, &**sub_pat, scope_stack, scope_map);\n+            walk_pattern(cx, &sub_pat, scope_stack, scope_map);\n         }\n \n         hir::PatLit(ref exp) => {\n             scope_map.insert(pat.id, scope_stack.last().unwrap().scope_metadata);\n-            walk_expr(cx, &**exp, scope_stack, scope_map);\n+            walk_expr(cx, &exp, scope_stack, scope_map);\n         }\n \n         hir::PatRange(ref exp1, ref exp2) => {\n             scope_map.insert(pat.id, scope_stack.last().unwrap().scope_metadata);\n-            walk_expr(cx, &**exp1, scope_stack, scope_map);\n-            walk_expr(cx, &**exp2, scope_stack, scope_map);\n+            walk_expr(cx, &exp1, scope_stack, scope_map);\n+            walk_expr(cx, &exp2, scope_stack, scope_map);\n         }\n \n         hir::PatVec(ref front_sub_pats, ref middle_sub_pats, ref back_sub_pats) => {\n             scope_map.insert(pat.id, scope_stack.last().unwrap().scope_metadata);\n \n             for sub_pat in front_sub_pats {\n-                walk_pattern(cx, &**sub_pat, scope_stack, scope_map);\n+                walk_pattern(cx, &sub_pat, scope_stack, scope_map);\n             }\n \n             if let Some(ref sub_pat) = *middle_sub_pats {\n-                walk_pattern(cx, &**sub_pat, scope_stack, scope_map);\n+                walk_pattern(cx, &sub_pat, scope_stack, scope_map);\n             }\n \n             for sub_pat in back_sub_pats {\n-                walk_pattern(cx, &**sub_pat, scope_stack, scope_map);\n+                walk_pattern(cx, &sub_pat, scope_stack, scope_map);\n             }\n         }\n     }\n@@ -324,73 +324,73 @@ fn walk_expr(cx: &CrateContext,\n         hir::ExprAddrOf(_, ref sub_exp)  |\n         hir::ExprField(ref sub_exp, _) |\n         hir::ExprTupField(ref sub_exp, _) =>\n-            walk_expr(cx, &**sub_exp, scope_stack, scope_map),\n+            walk_expr(cx, &sub_exp, scope_stack, scope_map),\n \n         hir::ExprBox(ref sub_expr) => {\n-            walk_expr(cx, &**sub_expr, scope_stack, scope_map);\n+            walk_expr(cx, &sub_expr, scope_stack, scope_map);\n         }\n \n         hir::ExprRet(ref exp_opt) => match *exp_opt {\n-            Some(ref sub_exp) => walk_expr(cx, &**sub_exp, scope_stack, scope_map),\n+            Some(ref sub_exp) => walk_expr(cx, &sub_exp, scope_stack, scope_map),\n             None => ()\n         },\n \n         hir::ExprUnary(_, ref sub_exp) => {\n-            walk_expr(cx, &**sub_exp, scope_stack, scope_map);\n+            walk_expr(cx, &sub_exp, scope_stack, scope_map);\n         }\n \n         hir::ExprAssignOp(_, ref lhs, ref rhs) |\n         hir::ExprIndex(ref lhs, ref rhs) |\n         hir::ExprBinary(_, ref lhs, ref rhs)    => {\n-            walk_expr(cx, &**lhs, scope_stack, scope_map);\n-            walk_expr(cx, &**rhs, scope_stack, scope_map);\n+            walk_expr(cx, &lhs, scope_stack, scope_map);\n+            walk_expr(cx, &rhs, scope_stack, scope_map);\n         }\n \n         hir::ExprRange(ref start, ref end) => {\n-            start.as_ref().map(|e| walk_expr(cx, &**e, scope_stack, scope_map));\n-            end.as_ref().map(|e| walk_expr(cx, &**e, scope_stack, scope_map));\n+            start.as_ref().map(|e| walk_expr(cx, &e, scope_stack, scope_map));\n+            end.as_ref().map(|e| walk_expr(cx, &e, scope_stack, scope_map));\n         }\n \n         hir::ExprVec(ref init_expressions) |\n         hir::ExprTup(ref init_expressions) => {\n             for ie in init_expressions {\n-                walk_expr(cx, &**ie, scope_stack, scope_map);\n+                walk_expr(cx, &ie, scope_stack, scope_map);\n             }\n         }\n \n         hir::ExprAssign(ref sub_exp1, ref sub_exp2) |\n         hir::ExprRepeat(ref sub_exp1, ref sub_exp2) => {\n-            walk_expr(cx, &**sub_exp1, scope_stack, scope_map);\n-            walk_expr(cx, &**sub_exp2, scope_stack, scope_map);\n+            walk_expr(cx, &sub_exp1, scope_stack, scope_map);\n+            walk_expr(cx, &sub_exp2, scope_stack, scope_map);\n         }\n \n         hir::ExprIf(ref cond_exp, ref then_block, ref opt_else_exp) => {\n-            walk_expr(cx, &**cond_exp, scope_stack, scope_map);\n+            walk_expr(cx, &cond_exp, scope_stack, scope_map);\n \n             with_new_scope(cx,\n                            then_block.span,\n                            scope_stack,\n                            scope_map,\n                            |cx, scope_stack, scope_map| {\n-                walk_block(cx, &**then_block, scope_stack, scope_map);\n+                walk_block(cx, &then_block, scope_stack, scope_map);\n             });\n \n             match *opt_else_exp {\n                 Some(ref else_exp) =>\n-                    walk_expr(cx, &**else_exp, scope_stack, scope_map),\n+                    walk_expr(cx, &else_exp, scope_stack, scope_map),\n                 _ => ()\n             }\n         }\n \n         hir::ExprWhile(ref cond_exp, ref loop_body, _) => {\n-            walk_expr(cx, &**cond_exp, scope_stack, scope_map);\n+            walk_expr(cx, &cond_exp, scope_stack, scope_map);\n \n             with_new_scope(cx,\n                            loop_body.span,\n                            scope_stack,\n                            scope_map,\n                            |cx, scope_stack, scope_map| {\n-                walk_block(cx, &**loop_body, scope_stack, scope_map);\n+                walk_block(cx, &loop_body, scope_stack, scope_map);\n             })\n         }\n \n@@ -401,7 +401,7 @@ fn walk_expr(cx: &CrateContext,\n                            scope_stack,\n                            scope_map,\n                            |cx, scope_stack, scope_map| {\n-                walk_block(cx, &**block, scope_stack, scope_map);\n+                walk_block(cx, &block, scope_stack, scope_map);\n             })\n         }\n \n@@ -412,29 +412,29 @@ fn walk_expr(cx: &CrateContext,\n                            scope_map,\n                            |cx, scope_stack, scope_map| {\n                 for &hir::Arg { pat: ref pattern, .. } in &decl.inputs {\n-                    walk_pattern(cx, &**pattern, scope_stack, scope_map);\n+                    walk_pattern(cx, &pattern, scope_stack, scope_map);\n                 }\n \n-                walk_block(cx, &**block, scope_stack, scope_map);\n+                walk_block(cx, &block, scope_stack, scope_map);\n             })\n         }\n \n         hir::ExprCall(ref fn_exp, ref args) => {\n-            walk_expr(cx, &**fn_exp, scope_stack, scope_map);\n+            walk_expr(cx, &fn_exp, scope_stack, scope_map);\n \n             for arg_exp in args {\n-                walk_expr(cx, &**arg_exp, scope_stack, scope_map);\n+                walk_expr(cx, &arg_exp, scope_stack, scope_map);\n             }\n         }\n \n         hir::ExprMethodCall(_, _, ref args) => {\n             for arg_exp in args {\n-                walk_expr(cx, &**arg_exp, scope_stack, scope_map);\n+                walk_expr(cx, &arg_exp, scope_stack, scope_map);\n             }\n         }\n \n         hir::ExprMatch(ref discriminant_exp, ref arms, _) => {\n-            walk_expr(cx, &**discriminant_exp, scope_stack, scope_map);\n+            walk_expr(cx, &discriminant_exp, scope_stack, scope_map);\n \n             // For each arm we have to first walk the pattern as these might\n             // introduce new artificial scopes. It should be sufficient to\n@@ -450,25 +450,25 @@ fn walk_expr(cx: &CrateContext,\n                                scope_map,\n                                |cx, scope_stack, scope_map| {\n                     for pat in &arm_ref.pats {\n-                        walk_pattern(cx, &**pat, scope_stack, scope_map);\n+                        walk_pattern(cx, &pat, scope_stack, scope_map);\n                     }\n \n                     if let Some(ref guard_exp) = arm_ref.guard {\n-                        walk_expr(cx, &**guard_exp, scope_stack, scope_map)\n+                        walk_expr(cx, &guard_exp, scope_stack, scope_map)\n                     }\n \n-                    walk_expr(cx, &*arm_ref.body, scope_stack, scope_map);\n+                    walk_expr(cx, &arm_ref.body, scope_stack, scope_map);\n                 })\n             }\n         }\n \n         hir::ExprStruct(_, ref fields, ref base_exp) => {\n             for &hir::Field { expr: ref exp, .. } in fields {\n-                walk_expr(cx, &**exp, scope_stack, scope_map);\n+                walk_expr(cx, &exp, scope_stack, scope_map);\n             }\n \n             match *base_exp {\n-                Some(ref exp) => walk_expr(cx, &**exp, scope_stack, scope_map),\n+                Some(ref exp) => walk_expr(cx, &exp, scope_stack, scope_map),\n                 None => ()\n             }\n         }\n@@ -478,11 +478,11 @@ fn walk_expr(cx: &CrateContext,\n                                             .. }) => {\n             // inputs, outputs: Vec<(String, P<Expr>)>\n             for &(_, ref exp) in inputs {\n-                walk_expr(cx, &**exp, scope_stack, scope_map);\n+                walk_expr(cx, &exp, scope_stack, scope_map);\n             }\n \n             for out in outputs {\n-                walk_expr(cx, &*out.expr, scope_stack, scope_map);\n+                walk_expr(cx, &out.expr, scope_stack, scope_map);\n             }\n         }\n     }"}, {"sha": "843aebc443722c1b6e5e7614a5fe79ad660fceb4", "filename": "src/librustc_trans/trans/debuginfo/metadata.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3548b8c273d9feb0291e97a928c4f48e01daf0f9/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3548b8c273d9feb0291e97a928c4f48e01daf0f9/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmetadata.rs?ref=3548b8c273d9feb0291e97a928c4f48e01daf0f9", "patch": "@@ -1919,7 +1919,7 @@ pub fn create_local_var_metadata(bcx: Block, local: &hir::Local) {\n     let def_map = &cx.tcx().def_map;\n     let locals = bcx.fcx.lllocals.borrow();\n \n-    pat_util::pat_bindings(def_map, &*local.pat, |_, node_id, span, var_name| {\n+    pat_util::pat_bindings(def_map, &local.pat, |_, node_id, span, var_name| {\n         let datum = match locals.get(&node_id) {\n             Some(datum) => datum,\n             None => {\n@@ -2099,7 +2099,7 @@ pub fn create_argument_metadata(bcx: Block, arg: &hir::Arg) {\n                          .fn_metadata;\n     let locals = bcx.fcx.lllocals.borrow();\n \n-    pat_util::pat_bindings(def_map, &*arg.pat, |_, node_id, span, var_name| {\n+    pat_util::pat_bindings(def_map, &arg.pat, |_, node_id, span, var_name| {\n         let datum = match locals.get(&node_id) {\n             Some(v) => v,\n             None => {"}, {"sha": "11dd631bee1fad76dc9e8dda55d86d3fa24abe78", "filename": "src/librustc_trans/trans/debuginfo/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3548b8c273d9feb0291e97a928c4f48e01daf0f9/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3548b8c273d9feb0291e97a928c4f48e01daf0f9/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmod.rs?ref=3548b8c273d9feb0291e97a928c4f48e01daf0f9", "patch": "@@ -399,7 +399,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n     let scope_map = create_scope_map::create_scope_map(cx,\n                                                        &fn_decl.inputs,\n-                                                       &*top_level_block,\n+                                                       &top_level_block,\n                                                        fn_metadata,\n                                                        fn_ast_id);\n "}, {"sha": "0c2c29724a1d72489d8cd82809ec48a7657fd4b0", "filename": "src/librustc_trans/trans/debuginfo/namespace.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3548b8c273d9feb0291e97a928c4f48e01daf0f9/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fnamespace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3548b8c273d9feb0291e97a928c4f48e01daf0f9/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fnamespace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fnamespace.rs?ref=3548b8c273d9feb0291e97a928c4f48e01daf0f9", "patch": "@@ -34,7 +34,7 @@ impl NamespaceTreeNode {\n     pub fn mangled_name_of_contained_item(&self, item_name: &str) -> String {\n         fn fill_nested(node: &NamespaceTreeNode, output: &mut String) {\n             match node.parent {\n-                Some(ref parent) => fill_nested(&*parent.upgrade().unwrap(), output),\n+                Some(ref parent) => fill_nested(&parent.upgrade().unwrap(), output),\n                 None => {}\n             }\n             let string = node.name.as_str();"}, {"sha": "c1d7bb495fafdefe6001097340cb78eeeb9bfcee", "filename": "src/librustc_trans/trans/debuginfo/utils.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3548b8c273d9feb0291e97a928c4f48e01daf0f9/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3548b8c273d9feb0291e97a928c4f48e01daf0f9/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Futils.rs?ref=3548b8c273d9feb0291e97a928c4f48e01daf0f9", "patch": "@@ -46,7 +46,7 @@ pub fn create_DIArray(builder: DIBuilderRef, arr: &[DIDescriptor]) -> DIArray {\n \n pub fn contains_nodebug_attribute(attributes: &[ast::Attribute]) -> bool {\n     attributes.iter().any(|attr| {\n-        let meta_item: &ast::MetaItem = &*attr.node.value;\n+        let meta_item: &ast::MetaItem = &attr.node.value;\n         match meta_item.node {\n             ast::MetaItemKind::Word(ref value) => &value[..] == \"no_debug\",\n             _ => false"}, {"sha": "fac956c1ddd20ea1fd09856220fdde97518508d9", "filename": "src/librustc_trans/trans/expr.rs", "status": "modified", "additions": 51, "deletions": 51, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/3548b8c273d9feb0291e97a928c4f48e01daf0f9/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3548b8c273d9feb0291e97a928c4f48e01daf0f9/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs?ref=3548b8c273d9feb0291e97a928c4f48e01daf0f9", "patch": "@@ -650,39 +650,39 @@ fn trans_datum_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n     match expr.node {\n         hir::ExprType(ref e, _) => {\n-            trans(bcx, &**e)\n+            trans(bcx, &e)\n         }\n         hir::ExprPath(..) => {\n             trans_def(bcx, expr, bcx.def(expr.id))\n         }\n         hir::ExprField(ref base, name) => {\n-            trans_rec_field(bcx, &**base, name.node)\n+            trans_rec_field(bcx, &base, name.node)\n         }\n         hir::ExprTupField(ref base, idx) => {\n-            trans_rec_tup_field(bcx, &**base, idx.node)\n+            trans_rec_tup_field(bcx, &base, idx.node)\n         }\n         hir::ExprIndex(ref base, ref idx) => {\n-            trans_index(bcx, expr, &**base, &**idx, MethodCall::expr(expr.id))\n+            trans_index(bcx, expr, &base, &idx, MethodCall::expr(expr.id))\n         }\n         hir::ExprBox(ref contents) => {\n             // Special case for `Box<T>`\n             let box_ty = expr_ty(bcx, expr);\n-            let contents_ty = expr_ty(bcx, &**contents);\n+            let contents_ty = expr_ty(bcx, &contents);\n             match box_ty.sty {\n                 ty::TyBox(..) => {\n-                    trans_uniq_expr(bcx, expr, box_ty, &**contents, contents_ty)\n+                    trans_uniq_expr(bcx, expr, box_ty, &contents, contents_ty)\n                 }\n                 _ => bcx.sess().span_bug(expr.span,\n                                          \"expected unique box\")\n             }\n \n         }\n-        hir::ExprLit(ref lit) => trans_immediate_lit(bcx, expr, &**lit),\n+        hir::ExprLit(ref lit) => trans_immediate_lit(bcx, expr, &lit),\n         hir::ExprBinary(op, ref lhs, ref rhs) => {\n-            trans_binary(bcx, expr, op, &**lhs, &**rhs)\n+            trans_binary(bcx, expr, op, &lhs, &rhs)\n         }\n         hir::ExprUnary(op, ref x) => {\n-            trans_unary(bcx, expr, op, &**x)\n+            trans_unary(bcx, expr, op, &x)\n         }\n         hir::ExprAddrOf(_, ref x) => {\n             match x.node {\n@@ -695,18 +695,18 @@ fn trans_datum_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                                                       false);\n                     fcx.push_ast_cleanup_scope(cleanup_debug_loc);\n                     let datum = unpack_datum!(\n-                        bcx, tvec::trans_slice_vec(bcx, expr, &**x));\n+                        bcx, tvec::trans_slice_vec(bcx, expr, &x));\n                     bcx = fcx.pop_and_trans_ast_cleanup_scope(bcx, x.id);\n                     DatumBlock::new(bcx, datum)\n                 }\n                 _ => {\n-                    trans_addr_of(bcx, expr, &**x)\n+                    trans_addr_of(bcx, expr, &x)\n                 }\n             }\n         }\n         hir::ExprCast(ref val, _) => {\n             // Datum output mode means this is a scalar cast:\n-            trans_imm_cast(bcx, &**val, expr.id)\n+            trans_imm_cast(bcx, &val, expr.id)\n         }\n         _ => {\n             bcx.tcx().sess.span_bug(\n@@ -737,7 +737,7 @@ fn trans_field<'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n         bcx,\n         vinfo.fields[ix].1,\n         |srcval| {\n-            adt::trans_field_ptr(bcx, &*repr, srcval, vinfo.discr, ix)\n+            adt::trans_field_ptr(bcx, &repr, srcval, vinfo.discr, ix)\n         });\n \n     if type_is_sized(bcx.tcx(), d.ty) {\n@@ -938,7 +938,7 @@ fn trans_rvalue_stmt_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             controlflow::trans_break(bcx, expr, label_opt.map(|l| l.node.name))\n         }\n         hir::ExprType(ref e, _) => {\n-            trans_into(bcx, &**e, Ignore)\n+            trans_into(bcx, &e, Ignore)\n         }\n         hir::ExprAgain(label_opt) => {\n             controlflow::trans_cont(bcx, expr, label_opt.map(|l| l.node.name))\n@@ -959,7 +959,7 @@ fn trans_rvalue_stmt_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 // directly. This avoids having to manage a return slot when\n                 // it won't actually be used anyway.\n                 if let &Some(ref x) = ex {\n-                    bcx = trans_into(bcx, &**x, Ignore);\n+                    bcx = trans_into(bcx, &x, Ignore);\n                 }\n                 // Mark the end of the block as unreachable. Once we get to\n                 // a return expression, there's no more we should be doing\n@@ -969,14 +969,14 @@ fn trans_rvalue_stmt_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             }\n         }\n         hir::ExprWhile(ref cond, ref body, _) => {\n-            controlflow::trans_while(bcx, expr, &**cond, &**body)\n+            controlflow::trans_while(bcx, expr, &cond, &body)\n         }\n         hir::ExprLoop(ref body, _) => {\n-            controlflow::trans_loop(bcx, expr, &**body)\n+            controlflow::trans_loop(bcx, expr, &body)\n         }\n         hir::ExprAssign(ref dst, ref src) => {\n-            let src_datum = unpack_datum!(bcx, trans(bcx, &**src));\n-            let dst_datum = unpack_datum!(bcx, trans_to_lvalue(bcx, &**dst, \"assign\"));\n+            let src_datum = unpack_datum!(bcx, trans(bcx, &src));\n+            let dst_datum = unpack_datum!(bcx, trans_to_lvalue(bcx, &dst, \"assign\"));\n \n             if bcx.fcx.type_needs_drop(dst_datum.ty) {\n                 // If there are destructors involved, make sure we\n@@ -1031,12 +1031,12 @@ fn trans_rvalue_stmt_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                     .contains_key(&MethodCall::expr(expr.id));\n \n             if has_method_map {\n-                let dst = unpack_datum!(bcx, trans(bcx, &**dst));\n-                let src_datum = unpack_datum!(bcx, trans(bcx, &**src));\n+                let dst = unpack_datum!(bcx, trans(bcx, &dst));\n+                let src_datum = unpack_datum!(bcx, trans(bcx, &src));\n                 trans_overloaded_op(bcx, expr, MethodCall::expr(expr.id), dst,\n                                     Some((src_datum, src.id)), None, false).bcx\n             } else {\n-                trans_assign_op(bcx, expr, op, &**dst, &**src)\n+                trans_assign_op(bcx, expr, op, &dst, &src)\n             }\n         }\n         hir::ExprInlineAsm(ref a) => {\n@@ -1064,19 +1064,19 @@ fn trans_rvalue_dps_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n     match expr.node {\n         hir::ExprType(ref e, _) => {\n-            trans_into(bcx, &**e, dest)\n+            trans_into(bcx, &e, dest)\n         }\n         hir::ExprPath(..) => {\n             trans_def_dps_unadjusted(bcx, expr, bcx.def(expr.id), dest)\n         }\n         hir::ExprIf(ref cond, ref thn, ref els) => {\n-            controlflow::trans_if(bcx, expr.id, &**cond, &**thn, els.as_ref().map(|e| &**e), dest)\n+            controlflow::trans_if(bcx, expr.id, &cond, &thn, els.as_ref().map(|e| &**e), dest)\n         }\n         hir::ExprMatch(ref discr, ref arms, _) => {\n-            _match::trans_match(bcx, expr, &**discr, &arms[..], dest)\n+            _match::trans_match(bcx, expr, &discr, &arms[..], dest)\n         }\n         hir::ExprBlock(ref blk) => {\n-            controlflow::trans_block(bcx, &**blk, dest)\n+            controlflow::trans_block(bcx, &blk, dest)\n         }\n         hir::ExprStruct(_, ref fields, ref base) => {\n             trans_struct(bcx,\n@@ -1201,42 +1201,42 @@ fn trans_rvalue_dps_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             if bcx.tcx().is_method_call(expr.id) {\n                 trans_overloaded_call(bcx,\n                                       expr,\n-                                      &**f,\n+                                      &f,\n                                       &args[..],\n                                       Some(dest))\n             } else {\n                 callee::trans_call(bcx,\n                                    expr,\n-                                   &**f,\n+                                   &f,\n                                    callee::ArgExprs(&args[..]),\n                                    dest)\n             }\n         }\n         hir::ExprMethodCall(_, _, ref args) => {\n             callee::trans_method_call(bcx,\n                                       expr,\n-                                      &*args[0],\n+                                      &args[0],\n                                       callee::ArgExprs(&args[..]),\n                                       dest)\n         }\n         hir::ExprBinary(op, ref lhs, ref rhs) => {\n             // if not overloaded, would be RvalueDatumExpr\n-            let lhs = unpack_datum!(bcx, trans(bcx, &**lhs));\n-            let rhs_datum = unpack_datum!(bcx, trans(bcx, &**rhs));\n+            let lhs = unpack_datum!(bcx, trans(bcx, &lhs));\n+            let rhs_datum = unpack_datum!(bcx, trans(bcx, &rhs));\n             trans_overloaded_op(bcx, expr, MethodCall::expr(expr.id), lhs,\n                                 Some((rhs_datum, rhs.id)), Some(dest),\n                                 !rustc_front::util::is_by_value_binop(op.node)).bcx\n         }\n         hir::ExprUnary(op, ref subexpr) => {\n             // if not overloaded, would be RvalueDatumExpr\n-            let arg = unpack_datum!(bcx, trans(bcx, &**subexpr));\n+            let arg = unpack_datum!(bcx, trans(bcx, &subexpr));\n             trans_overloaded_op(bcx, expr, MethodCall::expr(expr.id),\n                                 arg, None, Some(dest), !rustc_front::util::is_by_value_unop(op)).bcx\n         }\n         hir::ExprIndex(ref base, ref idx) => {\n             // if not overloaded, would be RvalueDatumExpr\n-            let base = unpack_datum!(bcx, trans(bcx, &**base));\n-            let idx_datum = unpack_datum!(bcx, trans(bcx, &**idx));\n+            let base = unpack_datum!(bcx, trans(bcx, &base));\n+            let idx_datum = unpack_datum!(bcx, trans(bcx, &idx));\n             trans_overloaded_op(bcx, expr, MethodCall::expr(expr.id), base,\n                                 Some((idx_datum, idx.id)), Some(dest), true).bcx\n         }\n@@ -1286,7 +1286,7 @@ fn trans_def_dps_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 // Nullary variant.\n                 let ty = expr_ty(bcx, ref_expr);\n                 let repr = adt::represent_type(bcx.ccx(), ty);\n-                adt::trans_set_discr(bcx, &*repr, lldest, Disr::from(variant.disr_val));\n+                adt::trans_set_discr(bcx, &repr, lldest, Disr::from(variant.disr_val));\n                 return bcx;\n             }\n         }\n@@ -1295,7 +1295,7 @@ fn trans_def_dps_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             match ty.sty {\n                 ty::TyStruct(def, _) if def.has_dtor() => {\n                     let repr = adt::represent_type(bcx.ccx(), ty);\n-                    adt::trans_set_discr(bcx, &*repr, lldest, Disr(0));\n+                    adt::trans_set_discr(bcx, &repr, lldest, Disr(0));\n                 }\n                 _ => {}\n             }\n@@ -1505,7 +1505,7 @@ pub fn trans_adt<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n         let mut vec_val = C_undef(llty);\n \n         for &(i, ref e) in fields {\n-            let block_datum = trans(bcx, &**e);\n+            let block_datum = trans(bcx, &e);\n             bcx = block_datum.bcx;\n             let position = C_uint(bcx.ccx(), i);\n             let value = block_datum.datum.to_llscalarish(bcx);\n@@ -1518,7 +1518,7 @@ pub fn trans_adt<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n \n         // First, trans field expressions to temporary scratch values.\n         let scratch_vals: Vec<_> = fields.iter().map(|&(i, ref e)| {\n-            let datum = unpack_datum!(bcx, trans(bcx, &**e));\n+            let datum = unpack_datum!(bcx, trans(bcx, &e));\n             (i, datum)\n         }).collect();\n \n@@ -1528,45 +1528,45 @@ pub fn trans_adt<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n         assert_eq!(discr, Disr(0));\n \n         let addr = adt::MaybeSizedValue::sized(addr);\n-        match expr_kind(bcx.tcx(), &*base.expr) {\n+        match expr_kind(bcx.tcx(), &base.expr) {\n             ExprKind::RvalueDps | ExprKind::RvalueDatum if !bcx.fcx.type_needs_drop(ty) => {\n-                bcx = trans_into(bcx, &*base.expr, SaveIn(addr.value));\n+                bcx = trans_into(bcx, &base.expr, SaveIn(addr.value));\n             },\n             ExprKind::RvalueStmt => {\n                 bcx.tcx().sess.bug(\"unexpected expr kind for struct base expr\")\n             }\n             _ => {\n-                let base_datum = unpack_datum!(bcx, trans_to_lvalue(bcx, &*base.expr, \"base\"));\n+                let base_datum = unpack_datum!(bcx, trans_to_lvalue(bcx, &base.expr, \"base\"));\n                 for &(i, t) in &base.fields {\n                     let datum = base_datum.get_element(\n-                            bcx, t, |srcval| adt::trans_field_ptr(bcx, &*repr, srcval, discr, i));\n+                            bcx, t, |srcval| adt::trans_field_ptr(bcx, &repr, srcval, discr, i));\n                     assert!(type_is_sized(bcx.tcx(), datum.ty));\n-                    let dest = adt::trans_field_ptr(bcx, &*repr, addr, discr, i);\n+                    let dest = adt::trans_field_ptr(bcx, &repr, addr, discr, i);\n                     bcx = datum.store_to(bcx, dest);\n                 }\n             }\n         }\n \n         // Finally, move scratch field values into actual field locations\n         for (i, datum) in scratch_vals {\n-            let dest = adt::trans_field_ptr(bcx, &*repr, addr, discr, i);\n+            let dest = adt::trans_field_ptr(bcx, &repr, addr, discr, i);\n             bcx = datum.store_to(bcx, dest);\n         }\n     } else {\n         // No base means we can write all fields directly in place.\n         let addr = adt::MaybeSizedValue::sized(addr);\n         for &(i, ref e) in fields {\n-            let dest = adt::trans_field_ptr(bcx, &*repr, addr, discr, i);\n-            let e_ty = expr_ty_adjusted(bcx, &**e);\n-            bcx = trans_into(bcx, &**e, SaveIn(dest));\n+            let dest = adt::trans_field_ptr(bcx, &repr, addr, discr, i);\n+            let e_ty = expr_ty_adjusted(bcx, &e);\n+            bcx = trans_into(bcx, &e, SaveIn(dest));\n             let scope = cleanup::CustomScope(custom_cleanup_scope);\n             fcx.schedule_lifetime_end(scope, dest);\n             // FIXME: nonzeroing move should generalize to fields\n             fcx.schedule_drop_mem(scope, dest, e_ty, None);\n         }\n     }\n \n-    adt::trans_set_discr(bcx, &*repr, addr, discr);\n+    adt::trans_set_discr(bcx, &repr, addr, discr);\n \n     fcx.pop_custom_cleanup_scope(custom_cleanup_scope);\n \n@@ -2112,10 +2112,10 @@ fn trans_imm_cast<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         let datum = unpack_datum!(\n             bcx, datum.to_lvalue_datum(bcx, \"trans_imm_cast\", expr.id));\n         let llexpr_ptr = datum.to_llref();\n-        let discr = adt::trans_get_discr(bcx, &*repr, llexpr_ptr,\n+        let discr = adt::trans_get_discr(bcx, &repr, llexpr_ptr,\n                                          Some(Type::i64(ccx)), true);\n         ll_t_in = val_ty(discr);\n-        (discr, adt::is_discr_signed(&*repr))\n+        (discr, adt::is_discr_signed(&repr))\n     } else {\n         (datum.to_llscalarish(bcx), t_in.is_signed())\n     };\n@@ -2165,7 +2165,7 @@ fn trans_assign_op<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let lhs = immediate_rvalue(lhs, dst.ty);\n \n     // Evaluate RHS - FIXME(#28160) this sucks\n-    let rhs = unpack_datum!(bcx, trans(bcx, &*src));\n+    let rhs = unpack_datum!(bcx, trans(bcx, &src));\n     let rhs = unpack_datum!(bcx, rhs.to_rvalue_datum(bcx, \"assign_op_rhs\"));\n \n     // Perform computation and store the result"}, {"sha": "b96f2cd45cf95244a174ea5316bedbc301edfb57", "filename": "src/librustc_trans/trans/foreign.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3548b8c273d9feb0291e97a928c4f48e01daf0f9/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3548b8c273d9feb0291e97a928c4f48e01daf0f9/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs?ref=3548b8c273d9feb0291e97a928c4f48e01daf0f9", "patch": "@@ -472,10 +472,10 @@ fn gate_simd_ffi(tcx: &ty::ctxt, decl: &hir::FnDecl, ty: &ty::BareFnTy) {\n         };\n         let sig = &ty.sig.0;\n         for (input, ty) in decl.inputs.iter().zip(&sig.inputs) {\n-            check(&*input.ty, *ty)\n+            check(&input.ty, *ty)\n         }\n         if let hir::Return(ref ty) = decl.output {\n-            check(&**ty, sig.output.unwrap())\n+            check(&ty, sig.output.unwrap())\n         }\n     }\n }\n@@ -491,7 +491,7 @@ pub fn trans_foreign_mod(ccx: &CrateContext, foreign_mod: &hir::ForeignMod) {\n                 abi => {\n                     let ty = ccx.tcx().node_id_to_type(foreign_item.id);\n                     match ty.sty {\n-                        ty::TyBareFn(_, bft) => gate_simd_ffi(ccx.tcx(), &**decl, bft),\n+                        ty::TyBareFn(_, bft) => gate_simd_ffi(ccx.tcx(), &decl, bft),\n                         _ => ccx.tcx().sess.span_bug(foreign_item.span,\n                                                      \"foreign fn's sty isn't a bare_fn_ty?\")\n                     }"}, {"sha": "5cb6a7344f1a12f76af4fe5d8610f9b20a01acbe", "filename": "src/librustc_trans/trans/glue.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3548b8c273d9feb0291e97a928c4f48e01daf0f9/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3548b8c273d9feb0291e97a928c4f48e01daf0f9/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fglue.rs?ref=3548b8c273d9feb0291e97a928c4f48e01daf0f9", "patch": "@@ -298,7 +298,7 @@ fn trans_struct_drop_flag<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n     assert!(type_is_sized(bcx.tcx(), t), \"Precondition: caller must ensure t is sized\");\n \n     let repr = adt::represent_type(bcx.ccx(), t);\n-    let drop_flag = unpack_datum!(bcx, adt::trans_drop_flag_ptr(bcx, &*repr, struct_data));\n+    let drop_flag = unpack_datum!(bcx, adt::trans_drop_flag_ptr(bcx, &repr, struct_data));\n     let loaded = load_ty(bcx, drop_flag.val, bcx.tcx().dtor_type());\n     let drop_flag_llty = type_of(bcx.fcx.ccx, bcx.tcx().dtor_type());\n     let init_val = C_integral(drop_flag_llty, adt::DTOR_NEEDED as u64, false);\n@@ -402,7 +402,7 @@ pub fn size_and_align_of_dst<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, t: Ty<'tcx>, in\n             // Don't use type_of::sizing_type_of because that expects t to be sized.\n             assert!(!t.is_simd());\n             let repr = adt::represent_type(ccx, t);\n-            let sizing_type = adt::sizing_type_context_of(ccx, &*repr, true);\n+            let sizing_type = adt::sizing_type_context_of(ccx, &repr, true);\n             debug!(\"DST {} sizing_type: {}\", t, sizing_type.to_string());\n             let sized_size = llsize_of_alloc(ccx, sizing_type.prefix());\n             let sized_align = llalign_of_min(ccx, sizing_type.prefix());"}, {"sha": "4c647152458f410d62c9d855361be525a7733bf9", "filename": "src/librustc_trans/trans/inline.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3548b8c273d9feb0291e97a928c4f48e01daf0f9/src%2Flibrustc_trans%2Ftrans%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3548b8c273d9feb0291e97a928c4f48e01daf0f9/src%2Flibrustc_trans%2Ftrans%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Finline.rs?ref=3548b8c273d9feb0291e97a928c4f48e01daf0f9", "patch": "@@ -120,7 +120,7 @@ fn instantiate_inline(ccx: &CrateContext, fn_id: DefId) -> Option<DefId> {\n                 _ => ccx.sess().bug(\"instantiate_inline: item has a \\\n                                  non-enum, non-struct parent\")\n             }\n-            trans_item(ccx, &**item);\n+            trans_item(ccx, &item);\n             my_id\n         }\n         FoundAst::FoundParent(_, _) => {"}, {"sha": "188fb7de9dd838fcf3baa5b929cb8f4d8eb9e954", "filename": "src/librustc_trans/trans/intrinsic.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3548b8c273d9feb0291e97a928c4f48e01daf0f9/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3548b8c273d9feb0291e97a928c4f48e01daf0f9/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs?ref=3548b8c273d9feb0291e97a928c4f48e01daf0f9", "patch": "@@ -225,7 +225,7 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                     // efficient (these are done efficiently implicitly in C\n                     // with the `__m128i` type and so this means Rust doesn't\n                     // lose out there).\n-                    let expr = &*arg_exprs[0];\n+                    let expr = &arg_exprs[0];\n                     let datum = unpack_datum!(bcx, expr::trans(bcx, expr));\n                     let datum = unpack_datum!(bcx, datum.to_rvalue_datum(bcx, \"transmute_temp\"));\n                     let val = if datum.kind.is_by_ref() {\n@@ -253,7 +253,7 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                         expr::SaveIn(d) => expr::SaveIn(PointerCast(bcx, d, llintype.ptr_to())),\n                         expr::Ignore => expr::Ignore\n                     };\n-                    bcx = expr::trans_into(bcx, &*arg_exprs[0], dest);\n+                    bcx = expr::trans_into(bcx, &arg_exprs[0], dest);\n                     dest\n                 };\n \n@@ -404,7 +404,7 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n         }\n     };\n \n-    let simple = get_simple_intrinsic(ccx, &*foreign_item);\n+    let simple = get_simple_intrinsic(ccx, &foreign_item);\n     let llval = match (simple, &*name) {\n         (Some(llfn), _) => {\n             Call(bcx, llfn, &llargs, None, call_debug_location)\n@@ -658,7 +658,7 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n             match val_ty.sty {\n                 ty::TyEnum(..) => {\n                     let repr = adt::represent_type(ccx, *val_ty);\n-                    adt::trans_get_discr(bcx, &*repr, llargs[0],\n+                    adt::trans_get_discr(bcx, &repr, llargs[0],\n                                          Some(llret_ty), true)\n                 }\n                 _ => C_null(llret_ty)\n@@ -849,7 +849,7 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                         assert!(!bcx.fcx.type_needs_drop(arg_type));\n \n                         let repr = adt::represent_type(bcx.ccx(), arg_type);\n-                        let repr_ptr = &*repr;\n+                        let repr_ptr = &repr;\n                         let arg = adt::MaybeSizedValue::sized(llarg);\n                         (0..contents.len())\n                             .map(|i| {"}, {"sha": "875f09c02e889a37c5d3a9de8b3221264644430b", "filename": "src/librustc_trans/trans/mir/block.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3548b8c273d9feb0291e97a928c4f48e01daf0f9/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3548b8c273d9feb0291e97a928c4f48e01daf0f9/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fblock.rs?ref=3548b8c273d9feb0291e97a928c4f48e01daf0f9", "patch": "@@ -67,7 +67,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                 assert_eq!(adt_def.variants.len(), targets.len());\n                 for (adt_variant, target) in adt_def.variants.iter().zip(targets) {\n                     let llval = bcx.with_block(|bcx|\n-                        adt::trans_case(bcx, &*repr, Disr::from(adt_variant.disr_val))\n+                        adt::trans_case(bcx, &repr, Disr::from(adt_variant.disr_val))\n                     );\n                     let llbb = self.llblock(*target);\n                     build::AddCase(switch, llval, llbb)"}, {"sha": "2468601afa57a5b83f18a2a93abc83e28af94b97", "filename": "src/librustc_trans/trans/mir/rvalue.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3548b8c273d9feb0291e97a928c4f48e01daf0f9/src%2Flibrustc_trans%2Ftrans%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3548b8c273d9feb0291e97a928c4f48e01daf0f9/src%2Flibrustc_trans%2Ftrans%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmir%2Frvalue.rs?ref=3548b8c273d9feb0291e97a928c4f48e01daf0f9", "patch": "@@ -106,15 +106,15 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                         let repr = adt::represent_type(bcx.ccx(), dest.ty.to_ty(bcx.tcx()));\n                         let disr = Disr::from(adt_def.variants[index].disr_val);\n                         bcx.with_block(|bcx| {\n-                            adt::trans_set_discr(bcx, &*repr, dest.llval, Disr::from(disr));\n+                            adt::trans_set_discr(bcx, &repr, dest.llval, Disr::from(disr));\n                         });\n                         for (i, operand) in operands.iter().enumerate() {\n                             let op = self.trans_operand(&bcx, operand);\n                             // Do not generate stores and GEPis for zero-sized fields.\n                             if !common::type_is_zero_size(bcx.ccx(), op.ty) {\n                                 let val = adt::MaybeSizedValue::sized(dest.llval);\n                                 let lldest_i = bcx.with_block(|bcx| {\n-                                    adt::trans_field_ptr(bcx, &*repr, val, disr, i)\n+                                    adt::trans_field_ptr(bcx, &repr, val, disr, i)\n                                 });\n                                 self.store_operand(&bcx, lldest_i, op);\n                             }\n@@ -234,9 +234,9 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                             let repr = adt::represent_type(bcx.ccx(), operand.ty);\n                             let llval = operand.immediate();\n                             let discr = bcx.with_block(|bcx| {\n-                                adt::trans_get_discr(bcx, &*repr, llval, None, true)\n+                                adt::trans_get_discr(bcx, &repr, llval, None, true)\n                             });\n-                            (discr, common::val_ty(discr), adt::is_discr_signed(&*repr))\n+                            (discr, common::val_ty(discr), adt::is_discr_signed(&repr))\n                         } else {\n                             (operand.immediate(), ll_t_in, operand.ty.is_signed())\n                         };"}, {"sha": "867ac9b8376fbf3d7c578f818093f420aa07945e", "filename": "src/librustc_trans/trans/monomorphize.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3548b8c273d9feb0291e97a928c4f48e01daf0f9/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3548b8c273d9feb0291e97a928c4f48e01daf0f9/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs?ref=3548b8c273d9feb0291e97a928c4f48e01daf0f9", "patch": "@@ -183,12 +183,12 @@ pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                   if needs_body {\n                       if abi != Abi::Rust {\n                           foreign::trans_rust_fn_with_foreign_abi(\n-                              ccx, &**decl, &**body, &[], d, psubsts, fn_node_id,\n+                              ccx, &decl, &body, &[], d, psubsts, fn_node_id,\n                               Some(&hash[..]));\n                       } else {\n                           trans_fn(ccx,\n-                                   &**decl,\n-                                   &**body,\n+                                   &decl,\n+                                   &body,\n                                    d,\n                                    psubsts,\n                                    fn_node_id,"}, {"sha": "d6573e96b02a35ba3ea7f453fd025fca15bb6d91", "filename": "src/librustc_trans/trans/tvec.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/3548b8c273d9feb0291e97a928c4f48e01daf0f9/src%2Flibrustc_trans%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3548b8c273d9feb0291e97a928c4f48e01daf0f9/src%2Flibrustc_trans%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Ftvec.rs?ref=3548b8c273d9feb0291e97a928c4f48e01daf0f9", "patch": "@@ -206,7 +206,7 @@ fn write_content<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             match dest {\n                 Ignore => {\n                     for element in elements {\n-                        bcx = expr::trans_into(bcx, &**element, Ignore);\n+                        bcx = expr::trans_into(bcx, &element, Ignore);\n                     }\n                 }\n \n@@ -216,7 +216,7 @@ fn write_content<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                         let lleltptr = GEPi(bcx, lldest, &[i]);\n                         debug!(\"writing index {} with lleltptr={}\",\n                                i, bcx.val_to_string(lleltptr));\n-                        bcx = expr::trans_into(bcx, &**element,\n+                        bcx = expr::trans_into(bcx, &element,\n                                                SaveIn(lleltptr));\n                         let scope = cleanup::CustomScope(temp_scope);\n                         // Issue #30822: mark memory as dropped after running destructor\n@@ -230,14 +230,14 @@ fn write_content<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         hir::ExprRepeat(ref element, ref count_expr) => {\n             match dest {\n                 Ignore => {\n-                    return expr::trans_into(bcx, &**element, Ignore);\n+                    return expr::trans_into(bcx, &element, Ignore);\n                 }\n                 SaveIn(lldest) => {\n-                    match bcx.tcx().eval_repeat_count(&**count_expr) {\n-                        0 => expr::trans_into(bcx, &**element, Ignore),\n-                        1 => expr::trans_into(bcx, &**element, SaveIn(lldest)),\n+                    match bcx.tcx().eval_repeat_count(&count_expr) {\n+                        0 => expr::trans_into(bcx, &element, Ignore),\n+                        1 => expr::trans_into(bcx, &element, SaveIn(lldest)),\n                         count => {\n-                            let elem = unpack_datum!(bcx, expr::trans(bcx, &**element));\n+                            let elem = unpack_datum!(bcx, expr::trans(bcx, &element));\n                             let bcx = iter_vec_loop(bcx, lldest, vt,\n                                                     C_uint(bcx.ccx(), count),\n                                                     |set_bcx, lleltptr, _| {\n@@ -285,7 +285,7 @@ fn elements_required(bcx: Block, content_expr: &hir::Expr) -> usize {\n         },\n         hir::ExprVec(ref es) => es.len(),\n         hir::ExprRepeat(_, ref count_expr) => {\n-            bcx.tcx().eval_repeat_count(&**count_expr)\n+            bcx.tcx().eval_repeat_count(&count_expr)\n         }\n         _ => bcx.tcx().sess.span_bug(content_expr.span,\n                                      \"unexpected vec content\")"}, {"sha": "0f88269a2c9e95e44f221ff755826ff2347291c8", "filename": "src/librustc_trans/trans/type_of.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3548b8c273d9feb0291e97a928c4f48e01daf0f9/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3548b8c273d9feb0291e97a928c4f48e01daf0f9/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs?ref=3548b8c273d9feb0291e97a928c4f48e01daf0f9", "patch": "@@ -226,7 +226,7 @@ pub fn sizing_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Typ\n \n         ty::TyTuple(..) | ty::TyEnum(..) | ty::TyClosure(..) => {\n             let repr = adt::represent_type(cx, t);\n-            adt::sizing_type_of(cx, &*repr, false)\n+            adt::sizing_type_of(cx, &repr, false)\n         }\n \n         ty::TyStruct(..) => {\n@@ -243,7 +243,7 @@ pub fn sizing_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Typ\n                 Type::vector(&llet, n)\n             } else {\n                 let repr = adt::represent_type(cx, t);\n-                adt::sizing_type_of(cx, &*repr, false)\n+                adt::sizing_type_of(cx, &repr, false)\n             }\n         }\n \n@@ -359,7 +359,7 @@ pub fn in_memory_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) ->\n           let repr = adt::represent_type(cx, t);\n           let tps = substs.types.get_slice(subst::TypeSpace);\n           let name = llvm_type_name(cx, def.did, tps);\n-          adt::incomplete_type_of(cx, &*repr, &name[..])\n+          adt::incomplete_type_of(cx, &repr, &name[..])\n       }\n       ty::TyClosure(..) => {\n           // Only create the named struct, but don't fill it in. We\n@@ -369,7 +369,7 @@ pub fn in_memory_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) ->\n           // inherited from their environment, so we use entire\n           // contents of the VecPerParamSpace to construct the llvm\n           // name\n-          adt::incomplete_type_of(cx, &*repr, \"closure\")\n+          adt::incomplete_type_of(cx, &repr, \"closure\")\n       }\n \n       ty::TyBox(ty) |\n@@ -423,7 +423,7 @@ pub fn in_memory_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) ->\n       ty::TyTuple(ref tys) if tys.is_empty() => Type::nil(cx),\n       ty::TyTuple(..) => {\n           let repr = adt::represent_type(cx, t);\n-          adt::type_of(cx, &*repr)\n+          adt::type_of(cx, &repr)\n       }\n       ty::TyStruct(def, ref substs) => {\n           if t.is_simd() {\n@@ -444,7 +444,7 @@ pub fn in_memory_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) ->\n               let repr = adt::represent_type(cx, t);\n               let tps = substs.types.get_slice(subst::TypeSpace);\n               let name = llvm_type_name(cx, def.did, tps);\n-              adt::incomplete_type_of(cx, &*repr, &name[..])\n+              adt::incomplete_type_of(cx, &repr, &name[..])\n           }\n       }\n \n@@ -465,7 +465,7 @@ pub fn in_memory_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) ->\n         ty::TyEnum(..) | ty::TyStruct(..) | ty::TyClosure(..)\n                 if !t.is_simd() => {\n             let repr = adt::represent_type(cx, t);\n-            adt::finish_type_of(cx, &*repr, &mut llty);\n+            adt::finish_type_of(cx, &repr, &mut llty);\n         }\n         _ => ()\n     }"}, {"sha": "4061d3a2028c77989700dd6f987ed9134304aaee", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/3548b8c273d9feb0291e97a928c4f48e01daf0f9/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3548b8c273d9feb0291e97a928c4f48e01daf0f9/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=3548b8c273d9feb0291e97a928c4f48e01daf0f9", "patch": "@@ -562,7 +562,7 @@ fn convert_angle_bracketed_parameters<'tcx>(this: &AstConv<'tcx>,\n     let assoc_bindings: Vec<_> =\n         data.bindings.iter()\n                      .map(|b| ConvertedBinding { item_name: b.name,\n-                                                 ty: ast_ty_to_ty(this, rscope, &*b.ty),\n+                                                 ty: ast_ty_to_ty(this, rscope, &b.ty),\n                                                  span: b.span })\n                      .collect();\n \n@@ -1064,7 +1064,7 @@ fn ast_ty_to_trait_ref<'tcx>(this: &AstConv<'tcx>,\n                     err.span_suggestion(full_span, \"try adding parentheses (per RFC 438):\",\n                                         format!(\"&{}({} +{})\",\n                                                 mutbl_str,\n-                                                pprust::ty_to_string(&*mut_ty.ty),\n+                                                pprust::ty_to_string(&mut_ty.ty),\n                                                 pprust::bounds_to_string(bounds)));\n                 }\n                 (&hir::TyRptr(Some(ref lt), ref mut_ty), Some(full_span)) => {\n@@ -1073,7 +1073,7 @@ fn ast_ty_to_trait_ref<'tcx>(this: &AstConv<'tcx>,\n                                         format!(\"&{} {}({} +{})\",\n                                                 pprust::lifetime_to_string(lt),\n                                                 mutbl_str,\n-                                                pprust::ty_to_string(&*mut_ty.ty),\n+                                                pprust::ty_to_string(&mut_ty.ty),\n                                                 pprust::bounds_to_string(bounds)));\n                 }\n \n@@ -1596,10 +1596,10 @@ pub fn ast_ty_to_ty<'tcx>(this: &AstConv<'tcx>,\n \n     let typ = match ast_ty.node {\n         hir::TyVec(ref ty) => {\n-            tcx.mk_slice(ast_ty_to_ty(this, rscope, &**ty))\n+            tcx.mk_slice(ast_ty_to_ty(this, rscope, &ty))\n         }\n         hir::TyObjectSum(ref ty, ref bounds) => {\n-            match ast_ty_to_trait_ref(this, rscope, &**ty, bounds) {\n+            match ast_ty_to_trait_ref(this, rscope, &ty, bounds) {\n                 Ok((trait_ref, projection_bounds)) => {\n                     trait_ref_to_object_type(this,\n                                              rscope,\n@@ -1615,7 +1615,7 @@ pub fn ast_ty_to_ty<'tcx>(this: &AstConv<'tcx>,\n         }\n         hir::TyPtr(ref mt) => {\n             tcx.mk_ptr(ty::TypeAndMut {\n-                ty: ast_ty_to_ty(this, rscope, &*mt.ty),\n+                ty: ast_ty_to_ty(this, rscope, &mt.ty),\n                 mutbl: mt.mutbl\n             })\n         }\n@@ -1626,18 +1626,18 @@ pub fn ast_ty_to_ty<'tcx>(this: &AstConv<'tcx>,\n                 &ObjectLifetimeDefaultRscope::new(\n                     rscope,\n                     ty::ObjectLifetimeDefault::Specific(r));\n-            let t = ast_ty_to_ty(this, rscope1, &*mt.ty);\n+            let t = ast_ty_to_ty(this, rscope1, &mt.ty);\n             tcx.mk_ref(tcx.mk_region(r), ty::TypeAndMut {ty: t, mutbl: mt.mutbl})\n         }\n         hir::TyTup(ref fields) => {\n             let flds = fields.iter()\n-                             .map(|t| ast_ty_to_ty(this, rscope, &**t))\n+                             .map(|t| ast_ty_to_ty(this, rscope, &t))\n                              .collect();\n             tcx.mk_tup(flds)\n         }\n         hir::TyBareFn(ref bf) => {\n             require_c_abi_if_variadic(tcx, &bf.decl, bf.abi, ast_ty.span);\n-            let bare_fn = ty_of_bare_fn(this, bf.unsafety, bf.abi, &*bf.decl);\n+            let bare_fn = ty_of_bare_fn(this, bf.unsafety, bf.abi, &bf.decl);\n             tcx.mk_fn(None, tcx.mk_bare_fn(bare_fn))\n         }\n         hir::TyPolyTraitRef(ref bounds) => {\n@@ -1687,10 +1687,10 @@ pub fn ast_ty_to_ty<'tcx>(this: &AstConv<'tcx>,\n                 Ok(r) => {\n                     match r {\n                         ConstVal::Int(i) =>\n-                            tcx.mk_array(ast_ty_to_ty(this, rscope, &**ty),\n+                            tcx.mk_array(ast_ty_to_ty(this, rscope, &ty),\n                                          i as usize),\n                         ConstVal::Uint(i) =>\n-                            tcx.mk_array(ast_ty_to_ty(this, rscope, &**ty),\n+                            tcx.mk_array(ast_ty_to_ty(this, rscope, &ty),\n                                          i as usize),\n                         _ => {\n                             span_err!(tcx.sess, ast_ty.span, E0249,\n@@ -1740,7 +1740,7 @@ pub fn ty_of_arg<'tcx>(this: &AstConv<'tcx>,\n     match a.ty.node {\n         hir::TyInfer if expected_ty.is_some() => expected_ty.unwrap(),\n         hir::TyInfer => this.ty_infer(None, None, None, a.ty.span),\n-        _ => ast_ty_to_ty(this, rscope, &*a.ty),\n+        _ => ast_ty_to_ty(this, rscope, &a.ty),\n     }\n }\n \n@@ -1804,7 +1804,7 @@ fn ty_of_method_or_bare_fn<'a, 'tcx>(this: &AstConv<'tcx>,\n     let arg_tys: Vec<Ty> =\n         arg_params.iter().map(|a| ty_of_arg(this, &rb, a, None)).collect();\n     let arg_pats: Vec<String> =\n-        arg_params.iter().map(|a| pprust::pat_to_string(&*a.pat)).collect();\n+        arg_params.iter().map(|a| pprust::pat_to_string(&a.pat)).collect();\n \n     // Second, if there was exactly one lifetime (either a substitution or a\n     // reference) in the arguments, then any anonymous regions in the output\n@@ -1860,7 +1860,7 @@ fn determine_self_type<'a, 'tcx>(this: &AstConv<'tcx>,\n              Some(ty::ExplicitSelfCategory::ByReference(region, mutability)))\n         }\n         hir::SelfExplicit(ref ast_type, _) => {\n-            let explicit_type = ast_ty_to_ty(this, rscope, &**ast_type);\n+            let explicit_type = ast_ty_to_ty(this, rscope, &ast_type);\n \n             // We wish to (for now) categorize an explicit self\n             // declaration like `self: SomeType` into either `self`,\n@@ -1967,7 +1967,7 @@ pub fn ty_of_closure<'tcx>(\n         _ if is_infer =>\n             ty::FnConverging(this.ty_infer(None, None, None, decl.output.span())),\n         hir::Return(ref output) =>\n-            ty::FnConverging(ast_ty_to_ty(this, &rb, &**output)),\n+            ty::FnConverging(ast_ty_to_ty(this, &rb, &output)),\n         hir::DefaultReturn(..) => unreachable!(),\n         hir::NoReturn(..) => ty::FnDiverging\n     };"}, {"sha": "6ca48f2d8d484c9c0a42573c0a3998ed8e3aa7cb", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/3548b8c273d9feb0291e97a928c4f48e01daf0f9/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3548b8c273d9feb0291e97a928c4f48e01daf0f9/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=3548b8c273d9feb0291e97a928c4f48e01daf0f9", "patch": "@@ -50,8 +50,8 @@ pub fn check_pat<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n             fcx.write_ty(pat.id, expected);\n         }\n         hir::PatLit(ref lt) => {\n-            check_expr(fcx, &**lt);\n-            let expr_ty = fcx.expr_ty(&**lt);\n+            check_expr(fcx, &lt);\n+            let expr_ty = fcx.expr_ty(&lt);\n \n             // Byte string patterns behave the same way as array patterns\n             // They can denote both statically and dynamically sized byte arrays\n@@ -198,7 +198,7 @@ pub fn check_pat<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n                 }\n \n                 if let Some(ref p) = *sub {\n-                    check_pat(pcx, &**p, expected);\n+                    check_pat(pcx, &p, expected);\n                 }\n             }\n         }\n@@ -259,28 +259,28 @@ pub fn check_pat<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n             fcx.write_ty(pat.id, pat_ty);\n             demand::eqtype(fcx, pat.span, expected, pat_ty);\n             for (element_pat, element_ty) in elements.iter().zip(element_tys) {\n-                check_pat(pcx, &**element_pat, element_ty);\n+                check_pat(pcx, &element_pat, element_ty);\n             }\n         }\n         hir::PatBox(ref inner) => {\n             let inner_ty = fcx.infcx().next_ty_var();\n             let uniq_ty = tcx.mk_box(inner_ty);\n \n-            if check_dereferencable(pcx, pat.span, expected, &**inner) {\n+            if check_dereferencable(pcx, pat.span, expected, &inner) {\n                 // Here, `demand::subtype` is good enough, but I don't\n                 // think any errors can be introduced by using\n                 // `demand::eqtype`.\n                 demand::eqtype(fcx, pat.span, expected, uniq_ty);\n                 fcx.write_ty(pat.id, uniq_ty);\n-                check_pat(pcx, &**inner, inner_ty);\n+                check_pat(pcx, &inner, inner_ty);\n             } else {\n                 fcx.write_error(pat.id);\n-                check_pat(pcx, &**inner, tcx.types.err);\n+                check_pat(pcx, &inner, tcx.types.err);\n             }\n         }\n         hir::PatRegion(ref inner, mutbl) => {\n             let expected = fcx.infcx().shallow_resolve(expected);\n-            if check_dereferencable(pcx, pat.span, expected, &**inner) {\n+            if check_dereferencable(pcx, pat.span, expected, &inner) {\n                 // `demand::subtype` would be good enough, but using\n                 // `eqtype` turns out to be equally general. See (*)\n                 // below for details.\n@@ -304,10 +304,10 @@ pub fn check_pat<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n                 };\n \n                 fcx.write_ty(pat.id, rptr_ty);\n-                check_pat(pcx, &**inner, inner_ty);\n+                check_pat(pcx, &inner, inner_ty);\n             } else {\n                 fcx.write_error(pat.id);\n-                check_pat(pcx, &**inner, tcx.types.err);\n+                check_pat(pcx, &inner, tcx.types.err);\n             }\n         }\n         hir::PatVec(ref before, ref slice, ref after) => {\n@@ -339,7 +339,7 @@ pub fn check_pat<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n             demand::eqtype(fcx, pat.span, expected, pat_ty);\n \n             for elt in before {\n-                check_pat(pcx, &**elt, inner_ty);\n+                check_pat(pcx, &elt, inner_ty);\n             }\n             if let Some(ref slice) = *slice {\n                 let region = fcx.infcx().next_region_var(infer::PatternRegion(pat.span));\n@@ -350,10 +350,10 @@ pub fn check_pat<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n                     ty: tcx.mk_slice(inner_ty),\n                     mutbl: mutbl\n                 });\n-                check_pat(pcx, &**slice, slice_ty);\n+                check_pat(pcx, &slice, slice_ty);\n             }\n             for elt in after {\n-                check_pat(pcx, &**elt, inner_ty);\n+                check_pat(pcx, &elt, inner_ty);\n             }\n         }\n     }\n@@ -482,10 +482,10 @@ pub fn check_match<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     for arm in arms {\n         let mut pcx = pat_ctxt {\n             fcx: fcx,\n-            map: pat_id_map(&tcx.def_map, &*arm.pats[0]),\n+            map: pat_id_map(&tcx.def_map, &arm.pats[0]),\n         };\n         for p in &arm.pats {\n-            check_pat(&mut pcx, &**p, discrim_ty);\n+            check_pat(&mut pcx, &p, discrim_ty);\n         }\n     }\n \n@@ -507,17 +507,17 @@ pub fn check_match<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n             // arm for inconsistent arms or to the whole match when a `()` type\n             // is required).\n             Expectation::ExpectHasType(ety) if ety != fcx.tcx().mk_nil() => {\n-                check_expr_coercable_to_type(fcx, &*arm.body, ety);\n+                check_expr_coercable_to_type(fcx, &arm.body, ety);\n                 ety\n             }\n             _ => {\n-                check_expr_with_expectation(fcx, &*arm.body, expected);\n+                check_expr_with_expectation(fcx, &arm.body, expected);\n                 fcx.node_ty(arm.body.id)\n             }\n         };\n \n         if let Some(ref e) = arm.guard {\n-            check_expr_has_type(fcx, &**e, tcx.types.bool);\n+            check_expr_has_type(fcx, &e, tcx.types.bool);\n         }\n \n         if result_ty.references_error() || bty.references_error() {\n@@ -622,7 +622,7 @@ pub fn check_pat_enum<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n \n             if let Some(subpats) = subpats {\n                 for pat in subpats {\n-                    check_pat(pcx, &**pat, tcx.types.err);\n+                    check_pat(pcx, &pat, tcx.types.err);\n                 }\n             }\n \n@@ -670,7 +670,7 @@ pub fn check_pat_enum<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n         fcx.write_error(pat.id);\n         if let Some(subpats) = subpats {\n             for pat in subpats {\n-                check_pat(pcx, &**pat, tcx.types.err);\n+                check_pat(pcx, &pat, tcx.types.err);\n             }\n         }\n     };\n@@ -742,15 +742,15 @@ pub fn check_pat_enum<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n     if let Some(subpats) = subpats {\n         if subpats.len() == arg_tys.len() {\n             for (subpat, arg_ty) in subpats.iter().zip(arg_tys) {\n-                check_pat(pcx, &**subpat, arg_ty);\n+                check_pat(pcx, &subpat, arg_ty);\n             }\n         } else if arg_tys.is_empty() {\n             span_err!(tcx.sess, pat.span, E0024,\n                       \"this pattern has {} field{}, but the corresponding {} has no fields\",\n                       subpats.len(), if subpats.len() == 1 {\"\"} else {\"s\"}, kind_name);\n \n             for pat in subpats {\n-                check_pat(pcx, &**pat, tcx.types.err);\n+                check_pat(pcx, &pat, tcx.types.err);\n             }\n         } else {\n             span_err!(tcx.sess, pat.span, E0023,\n@@ -760,7 +760,7 @@ pub fn check_pat_enum<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n                       arg_tys.len(), if arg_tys.len() == 1 {\"\"} else {\"s\"});\n \n             for pat in subpats {\n-                check_pat(pcx, &**pat, tcx.types.err);\n+                check_pat(pcx, &pat, tcx.types.err);\n             }\n         }\n     }\n@@ -815,7 +815,7 @@ pub fn check_struct_pat_fields<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n             }\n         };\n \n-        check_pat(pcx, &*field.pat, field_ty);\n+        check_pat(pcx, &field.pat, field_ty);\n     }\n \n     // Report an error if not all the fields were specified."}, {"sha": "42ea3cc2aaa7ba1d72537b25badfe7d7f90d4819", "filename": "src/librustc_typeck/check/callee.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3548b8c273d9feb0291e97a928c4f48e01daf0f9/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3548b8c273d9feb0291e97a928c4f48e01daf0f9/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs?ref=3548b8c273d9feb0291e97a928c4f48e01daf0f9", "patch": "@@ -199,7 +199,7 @@ fn try_overloaded_call_traits<'a,'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n \n         match method::lookup_in_trait_adjusted(fcx,\n                                                call_expr.span,\n-                                               Some(&*callee_expr),\n+                                               Some(&callee_expr),\n                                                method_name,\n                                                trait_def_id,\n                                                autoderefs,\n@@ -304,12 +304,12 @@ fn confirm_deferred_closure_call<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>,\n                                    call_expr.span,\n                                    expected,\n                                    fn_sig.output.clone(),\n-                                   &*fn_sig.inputs);\n+                                   &fn_sig.inputs);\n \n     check_argument_types(fcx,\n                          call_expr.span,\n-                         &*fn_sig.inputs,\n-                         &*expected_arg_tys,\n+                         &fn_sig.inputs,\n+                         &expected_arg_tys,\n                          arg_exprs,\n                          fn_sig.variadic,\n                          TupleArgumentsFlag::TupleArguments);"}, {"sha": "d3e66bde4f4c38ce66aa968b367111b39e215fa8", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3548b8c273d9feb0291e97a928c4f48e01daf0f9/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3548b8c273d9feb0291e97a928c4f48e01daf0f9/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=3548b8c273d9feb0291e97a928c4f48e01daf0f9", "patch": "@@ -83,7 +83,7 @@ fn check_closure<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>,\n              &fn_sig,\n              decl,\n              expr.id,\n-             &*body,\n+             &body,\n              fcx.inh);\n \n     // Tuple up the arguments and insert the resulting function type into"}, {"sha": "bf08989bc0a1275654c00309f058212285a38d9b", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/3548b8c273d9feb0291e97a928c4f48e01daf0f9/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3548b8c273d9feb0291e97a928c4f48e01daf0f9/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=3548b8c273d9feb0291e97a928c4f48e01daf0f9", "patch": "@@ -269,7 +269,7 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n             probe::WhereClausePick(ref poly_trait_ref) => {\n                 // Where clauses can have bound regions in them. We need to instantiate\n                 // those to convert from a poly-trait-ref to a trait-ref.\n-                self.replace_late_bound_regions_with_fresh_var(&*poly_trait_ref).substs.clone()\n+                self.replace_late_bound_regions_with_fresh_var(&poly_trait_ref).substs.clone()\n             }\n         }\n     }\n@@ -290,7 +290,7 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n                                               NoPreference,\n                                               |ty, _| {\n             match ty.sty {\n-                ty::TyTrait(ref data) => Some(closure(self, ty, &**data)),\n+                ty::TyTrait(ref data) => Some(closure(self, ty, &data)),\n                 _ => None,\n             }\n         });\n@@ -478,7 +478,7 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n                 hir::ExprField(ref expr, _) |\n                 hir::ExprTupField(ref expr, _) |\n                 hir::ExprIndex(ref expr, _) |\n-                hir::ExprUnary(hir::UnDeref, ref expr) => exprs.push(&**expr),\n+                hir::ExprUnary(hir::UnDeref, ref expr) => exprs.push(&expr),\n                 _ => break,\n             }\n         }\n@@ -570,13 +570,13 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n                                     unsize: None\n                                 }))), false)\n                         };\n-                        let index_expr_ty = self.fcx.expr_ty(&**index_expr);\n+                        let index_expr_ty = self.fcx.expr_ty(&index_expr);\n \n                         let result = check::try_index_step(\n                             self.fcx,\n                             ty::MethodCall::expr(expr.id),\n                             expr,\n-                            &**base_expr,\n+                            &base_expr,\n                             adjusted_base_ty,\n                             autoderefs,\n                             unsize,\n@@ -586,7 +586,7 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n                         if let Some((input_ty, return_ty)) = result {\n                             demand::suptype(self.fcx, index_expr.span, input_ty, index_expr_ty);\n \n-                            let expr_ty = self.fcx.expr_ty(&*expr);\n+                            let expr_ty = self.fcx.expr_ty(&expr);\n                             demand::suptype(self.fcx, expr.span, expr_ty, return_ty);\n                         }\n                     }\n@@ -599,8 +599,8 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n                                 self.fcx,\n                                 expr.span,\n                                 Some(method_call),\n-                                Some(&**base_expr),\n-                                self.fcx.expr_ty(&**base_expr),\n+                                Some(&base_expr),\n+                                self.fcx.expr_ty(&base_expr),\n                                 PreferMutLvalue);\n                         }\n                     }"}, {"sha": "1367db16314e2f53e3cbae16406546d320b5d5af", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3548b8c273d9feb0291e97a928c4f48e01daf0f9/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3548b8c273d9feb0291e97a928c4f48e01daf0f9/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=3548b8c273d9feb0291e97a928c4f48e01daf0f9", "patch": "@@ -271,7 +271,7 @@ fn suggest_traits_to_import<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n \n         for (i, trait_did) in candidates.iter().enumerate() {\n             err.fileline_help(span,\n-                              &*format!(\"candidate #{}: use `{}`\",\n+                              &format!(\"candidate #{}: use `{}`\",\n                                         i + 1,\n                                         fcx.tcx().item_path_str(*trait_did)));\n         }\n@@ -316,7 +316,7 @@ fn suggest_traits_to_import<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n \n         for (i, trait_info) in candidates.iter().enumerate() {\n             err.fileline_help(span,\n-                              &*format!(\"candidate #{}: `{}`\",\n+                              &format!(\"candidate #{}: `{}`\",\n                                         i + 1,\n                                         fcx.tcx().item_path_str(trait_info.def_id)));\n         }"}, {"sha": "e485bdd66fc9f265ca8f27fb9511eedbb480380d", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 100, "deletions": 100, "changes": 200, "blob_url": "https://github.com/rust-lang/rust/blob/3548b8c273d9feb0291e97a928c4f48e01daf0f9/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3548b8c273d9feb0291e97a928c4f48e01daf0f9/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=3548b8c273d9feb0291e97a928c4f48e01daf0f9", "patch": "@@ -368,7 +368,7 @@ impl<'a, 'tcx> Visitor<'tcx> for CheckItemTypesVisitor<'a, 'tcx> {\n     fn visit_ty(&mut self, t: &'tcx hir::Ty) {\n         match t.node {\n             hir::TyFixedLengthVec(_, ref expr) => {\n-                check_const_in_type(self.ccx, &**expr, self.ccx.tcx.types.usize);\n+                check_const_in_type(self.ccx, &expr, self.ccx.tcx.types.usize);\n             }\n             _ => {}\n         }\n@@ -491,7 +491,7 @@ impl<'a, 'tcx> Visitor<'tcx> for GatherLocalsVisitor<'a, 'tcx> {\n     // Add explicitly-declared locals.\n     fn visit_local(&mut self, local: &'tcx hir::Local) {\n         let o_ty = match local.ty {\n-            Some(ref ty) => Some(self.fcx.to_ty(&**ty)),\n+            Some(ref ty) => Some(self.fcx.to_ty(&ty)),\n             None => None\n         };\n         self.assign(local.span, local.id, o_ty);\n@@ -533,8 +533,8 @@ impl<'a, 'tcx> Visitor<'tcx> for GatherLocalsVisitor<'a, 'tcx> {\n     fn visit_ty(&mut self, t: &'tcx hir::Ty) {\n         match t.node {\n             hir::TyFixedLengthVec(ref ty, ref count_expr) => {\n-                self.visit_ty(&**ty);\n-                check_expr_with_hint(self.fcx, &**count_expr, self.fcx.tcx().types.usize);\n+                self.visit_ty(&ty);\n+                check_expr_with_hint(self.fcx, &count_expr, self.fcx.tcx().types.usize);\n             }\n             hir::TyBareFn(ref function_declaration) => {\n                 intravisit::walk_fn_decl_nopat(self, &function_declaration.decl);\n@@ -612,7 +612,7 @@ fn check_fn<'a, 'tcx>(ccx: &'a CrateCtxt<'a, 'tcx>,\n             // Create type variables for each argument.\n             pat_util::pat_bindings(\n                 &tcx.def_map,\n-                &*input.pat,\n+                &input.pat,\n                 |_bm, pat_id, sp, _path| {\n                     let var_ty = visit.assign(sp, pat_id, None);\n                     fcx.require_type_is_sized(var_ty, sp,\n@@ -622,9 +622,9 @@ fn check_fn<'a, 'tcx>(ccx: &'a CrateCtxt<'a, 'tcx>,\n             // Check the pattern.\n             let pcx = pat_ctxt {\n                 fcx: &fcx,\n-                map: pat_id_map(&tcx.def_map, &*input.pat),\n+                map: pat_id_map(&tcx.def_map, &input.pat),\n             };\n-            _match::check_pat(&pcx, &*input.pat, *arg_ty);\n+            _match::check_pat(&pcx, &input.pat, *arg_ty);\n         }\n \n         visit.visit_block(body);\n@@ -660,7 +660,7 @@ pub fn check_item_type<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>, it: &'tcx hir::Item) {\n     match it.node {\n       // Consts can play a role in type-checking, so they are included here.\n       hir::ItemStatic(_, _, ref e) |\n-      hir::ItemConst(_, ref e) => check_const(ccx, it.span, &**e, it.id),\n+      hir::ItemConst(_, ref e) => check_const(ccx, it.span, &e, it.id),\n       hir::ItemEnum(ref enum_definition, _) => {\n         check_enum_variants(ccx,\n                             it.span,\n@@ -730,7 +730,7 @@ pub fn check_item_body<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>, it: &'tcx hir::Item) {\n       hir::ItemFn(ref decl, _, _, _, _, ref body) => {\n         let fn_pty = ccx.tcx.lookup_item_type(ccx.tcx.map.local_def_id(it.id));\n         let param_env = ParameterEnvironment::for_item(ccx.tcx, it.id);\n-        check_bare_fn(ccx, &**decl, &**body, it.id, it.span, fn_pty.ty, param_env);\n+        check_bare_fn(ccx, &decl, &body, it.id, it.span, fn_pty.ty, param_env);\n       }\n       hir::ItemImpl(_, _, _, _, _, ref impl_items) => {\n         debug!(\"ItemImpl {} with id {}\", it.name, it.id);\n@@ -740,7 +740,7 @@ pub fn check_item_body<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>, it: &'tcx hir::Item) {\n         for impl_item in impl_items {\n             match impl_item.node {\n                 hir::ImplItemKind::Const(_, ref expr) => {\n-                    check_const(ccx, impl_item.span, &*expr, impl_item.id)\n+                    check_const(ccx, impl_item.span, &expr, impl_item.id)\n                 }\n                 hir::ImplItemKind::Method(ref sig, ref body) => {\n                     check_method_body(ccx, &impl_pty.generics, sig, body,\n@@ -757,7 +757,7 @@ pub fn check_item_body<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>, it: &'tcx hir::Item) {\n         for trait_item in trait_items {\n             match trait_item.node {\n                 hir::ConstTraitItem(_, Some(ref expr)) => {\n-                    check_const(ccx, trait_item.span, &*expr, trait_item.id)\n+                    check_const(ccx, trait_item.span, &expr, trait_item.id)\n                 }\n                 hir::MethodTraitItem(ref sig, Some(ref body)) => {\n                     check_trait_fn_not_const(ccx, trait_item.span, sig.constness);\n@@ -801,7 +801,7 @@ fn check_trait_on_unimplemented<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     }) {\n         if let Some(ref istring) = attr.value_str() {\n             let parser = Parser::new(&istring);\n-            let types = &*generics.ty_params;\n+            let types = &generics.ty_params;\n             for token in parser {\n                 match token {\n                     Piece::String(_) => (), // Normal string, no need to check it\n@@ -890,7 +890,7 @@ fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                            &impl_const,\n                                            impl_item.span,\n                                            trait_const,\n-                                           &*impl_trait_ref);\n+                                           &impl_trait_ref);\n                     } else {\n                         span_err!(tcx.sess, impl_item.span, E0323,\n                                   \"item `{}` is an associated const, \\\n@@ -2279,7 +2279,7 @@ fn try_index_step<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         (PreferMutLvalue, Some(trait_did)) => {\n             method::lookup_in_trait_adjusted(fcx,\n                                              expr.span,\n-                                             Some(&*base_expr),\n+                                             Some(&base_expr),\n                                              token::intern(\"index_mut\"),\n                                              trait_did,\n                                              autoderefs,\n@@ -2295,7 +2295,7 @@ fn try_index_step<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         (None, Some(trait_did)) => {\n             method::lookup_in_trait_adjusted(fcx,\n                                              expr.span,\n-                                             Some(&*base_expr),\n+                                             Some(&base_expr),\n                                              token::intern(\"index\"),\n                                              trait_did,\n                                              autoderefs,\n@@ -2409,7 +2409,7 @@ fn check_argument_types<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                 } else {\n                     expected_arg_tys = match expected_arg_tys.get(0) {\n                         Some(&ty) => match ty.sty {\n-                            ty::TyTuple(ref tys) => &**tys,\n+                            ty::TyTuple(ref tys) => &tys,\n                             _ => &[]\n                         },\n                         None => &[]\n@@ -2512,14 +2512,14 @@ fn check_argument_types<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                 });\n \n                 check_expr_with_unifier(fcx,\n-                                        &**arg,\n+                                        &arg,\n                                         expected.unwrap_or(ExpectHasType(formal_ty)),\n                                         NoPreference, || {\n                     // 2. Coerce to the most detailed type that could be coerced\n                     //    to, which is `expected_ty` if `rvalue_hint` returns an\n                     //    `ExprHasType(expected_ty)`, or the `formal_ty` otherwise.\n                     let coerce_ty = expected.and_then(|e| e.only_has_type(fcx));\n-                    demand::coerce(fcx, arg.span, coerce_ty.unwrap_or(formal_ty), &**arg);\n+                    demand::coerce(fcx, arg.span, coerce_ty.unwrap_or(formal_ty), &arg);\n \n                     // 3. Relate the expected type and the formal one,\n                     //    if the expected type was used for the coercion.\n@@ -2549,12 +2549,12 @@ fn check_argument_types<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     // arguments which we skipped above.\n     if variadic {\n         for arg in args.iter().skip(expected_arg_count) {\n-            check_expr(fcx, &**arg);\n+            check_expr(fcx, &arg);\n \n             // There are a few types which get autopromoted when passed via varargs\n             // in C but we just error out instead and require explicit casts.\n             let arg_ty = structurally_resolved_type(fcx, arg.span,\n-                                                    fcx.expr_ty(&**arg));\n+                                                    fcx.expr_ty(&arg));\n             match arg_ty.sty {\n                 ty::TyFloat(ast::FloatTy::F32) => {\n                     fcx.type_error_message(arg.span,\n@@ -2816,15 +2816,15 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                                    tps: &[P<hir::Ty>],\n                                    expected: Expectation<'tcx>,\n                                    lvalue_pref: LvaluePreference) {\n-        let rcvr = &*args[0];\n-        check_expr_with_lvalue_pref(fcx, &*rcvr, lvalue_pref);\n+        let rcvr = &args[0];\n+        check_expr_with_lvalue_pref(fcx, &rcvr, lvalue_pref);\n \n         // no need to check for bot/err -- callee does that\n         let expr_t = structurally_resolved_type(fcx,\n                                                 expr.span,\n-                                                fcx.expr_ty(&*rcvr));\n+                                                fcx.expr_ty(&rcvr));\n \n-        let tps = tps.iter().map(|ast_ty| fcx.to_ty(&**ast_ty)).collect::<Vec<_>>();\n+        let tps = tps.iter().map(|ast_ty| fcx.to_ty(&ast_ty)).collect::<Vec<_>>();\n         let fn_ty = match method::lookup(fcx,\n                                          method_name.span,\n                                          method_name.node,\n@@ -2877,8 +2877,8 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n \n         let branches_ty = match opt_else_expr {\n             Some(ref else_expr) => {\n-                check_expr_with_expectation(fcx, &**else_expr, expected);\n-                let else_ty = fcx.expr_ty(&**else_expr);\n+                check_expr_with_expectation(fcx, &else_expr, expected);\n+                let else_ty = fcx.expr_ty(&else_expr);\n                 infer::common_supertype(fcx.infcx(),\n                                         TypeOrigin::IfExpression(sp),\n                                         true,\n@@ -3128,7 +3128,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n \n             // Make sure to give a type to the field even if there's\n             // an error, so we can continue typechecking\n-            check_expr_coercable_to_type(fcx, &*field.expr, expected_field_type);\n+            check_expr_coercable_to_type(fcx, &field.expr, expected_field_type);\n         }\n \n             // Make sure the programmer specified all the fields.\n@@ -3156,10 +3156,10 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n         // otherwise we might ICE\n         fcx.write_error(id);\n         for field in fields {\n-            check_expr(fcx, &*field.expr);\n+            check_expr(fcx, &field.expr);\n         }\n         match *base_expr {\n-            Some(ref base) => check_expr(fcx, &**base),\n+            Some(ref base) => check_expr(fcx, &base),\n             None => {}\n         }\n     }\n@@ -3217,12 +3217,12 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n             }\n         });\n         check_expr_with_expectation(fcx, subexpr, expected_inner);\n-        let referent_ty = fcx.expr_ty(&**subexpr);\n+        let referent_ty = fcx.expr_ty(&subexpr);\n         fcx.write_ty(id, tcx.mk_box(referent_ty));\n       }\n \n       hir::ExprLit(ref lit) => {\n-        let typ = check_lit(fcx, &**lit, expected);\n+        let typ = check_lit(fcx, &lit, expected);\n         fcx.write_ty(id, typ);\n       }\n       hir::ExprBinary(op, ref lhs, ref rhs) => {\n@@ -3245,8 +3245,8 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n             _ => NoPreference\n         };\n         check_expr_with_expectation_and_lvalue_pref(\n-            fcx, &**oprnd, expected_inner, lvalue_pref);\n-        let mut oprnd_t = fcx.expr_ty(&**oprnd);\n+            fcx, &oprnd, expected_inner, lvalue_pref);\n+        let mut oprnd_t = fcx.expr_ty(&oprnd);\n \n         if !oprnd_t.references_error() {\n             match unop {\n@@ -3256,7 +3256,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                         Some(mt) => mt.ty,\n                         None => match try_overloaded_deref(fcx, expr.span,\n                                                            Some(MethodCall::expr(expr.id)),\n-                                                           Some(&**oprnd), oprnd_t, lvalue_pref) {\n+                                                           Some(&oprnd), oprnd_t, lvalue_pref) {\n                             Some(mt) => mt.ty,\n                             None => {\n                                 fcx.type_error_message(expr.span, |actual| {\n@@ -3274,7 +3274,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                     if !(oprnd_t.is_integral() || oprnd_t.sty == ty::TyBool) {\n                         oprnd_t = op::check_user_unop(fcx, \"!\", \"not\",\n                                                       tcx.lang_items.not_trait(),\n-                                                      expr, &**oprnd, oprnd_t, unop);\n+                                                      expr, &oprnd, oprnd_t, unop);\n                     }\n                 }\n                 hir::UnNeg => {\n@@ -3283,7 +3283,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                     if !(oprnd_t.is_integral() || oprnd_t.is_fp()) {\n                         oprnd_t = op::check_user_unop(fcx, \"-\", \"neg\",\n                                                       tcx.lang_items.neg_trait(),\n-                                                      expr, &**oprnd, oprnd_t, unop);\n+                                                      expr, &oprnd, oprnd_t, unop);\n                     }\n                 }\n             }\n@@ -3294,7 +3294,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n         let hint = expected.only_has_type(fcx).map_or(NoExpectation, |ty| {\n             match ty.sty {\n                 ty::TyRef(_, ref mt) | ty::TyRawPtr(ref mt) => {\n-                    if fcx.tcx().expr_is_lval(&**oprnd) {\n+                    if fcx.tcx().expr_is_lval(&oprnd) {\n                         // Lvalues may legitimately have unsized types.\n                         // For example, dereferences of a fat pointer and\n                         // the last field of a struct can be unsized.\n@@ -3308,11 +3308,11 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n         });\n         let lvalue_pref = LvaluePreference::from_mutbl(mutbl);\n         check_expr_with_expectation_and_lvalue_pref(fcx,\n-                                                    &**oprnd,\n+                                                    &oprnd,\n                                                     hint,\n                                                     lvalue_pref);\n \n-        let tm = ty::TypeAndMut { ty: fcx.expr_ty(&**oprnd), mutbl: mutbl };\n+        let tm = ty::TypeAndMut { ty: fcx.expr_ty(&oprnd), mutbl: mutbl };\n         let oprnd_t = if tm.ty.references_error() {\n             tcx.types.err\n         } else {\n@@ -3381,10 +3381,10 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n       }\n       hir::ExprInlineAsm(ref ia) => {\n           for &(_, ref input) in &ia.inputs {\n-              check_expr(fcx, &**input);\n+              check_expr(fcx, &input);\n           }\n           for out in &ia.outputs {\n-              check_expr(fcx, &*out.expr);\n+              check_expr(fcx, &out.expr);\n           }\n           fcx.write_nil(id);\n       }\n@@ -3402,13 +3402,13 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                                  not `()`\");\n                         },\n                     Some(ref e) => {\n-                        check_expr_coercable_to_type(fcx, &**e, result_type);\n+                        check_expr_coercable_to_type(fcx, &e, result_type);\n                     }\n                 }\n             }\n             ty::FnDiverging => {\n                 if let Some(ref e) = *expr_opt {\n-                    check_expr(fcx, &**e);\n+                    check_expr(fcx, &e);\n                 }\n                 span_err!(tcx.sess, expr.span, E0166,\n                     \"`return` in a function declared as diverging\");\n@@ -3417,19 +3417,19 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n         fcx.write_ty(id, fcx.infcx().next_diverging_ty_var());\n       }\n       hir::ExprAssign(ref lhs, ref rhs) => {\n-        check_expr_with_lvalue_pref(fcx, &**lhs, PreferMutLvalue);\n+        check_expr_with_lvalue_pref(fcx, &lhs, PreferMutLvalue);\n \n         let tcx = fcx.tcx();\n-        if !tcx.expr_is_lval(&**lhs) {\n+        if !tcx.expr_is_lval(&lhs) {\n             span_err!(tcx.sess, expr.span, E0070,\n                 \"invalid left-hand side expression\");\n         }\n \n-        let lhs_ty = fcx.expr_ty(&**lhs);\n-        check_expr_coercable_to_type(fcx, &**rhs, lhs_ty);\n-        let rhs_ty = fcx.expr_ty(&**rhs);\n+        let lhs_ty = fcx.expr_ty(&lhs);\n+        check_expr_coercable_to_type(fcx, &rhs, lhs_ty);\n+        let rhs_ty = fcx.expr_ty(&rhs);\n \n-        fcx.require_expr_have_sized_type(&**lhs, traits::AssignmentLhsSized);\n+        fcx.require_expr_have_sized_type(&lhs, traits::AssignmentLhsSized);\n \n         if lhs_ty.references_error() || rhs_ty.references_error() {\n             fcx.write_error(id);\n@@ -3438,13 +3438,13 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n         }\n       }\n       hir::ExprIf(ref cond, ref then_blk, ref opt_else_expr) => {\n-        check_then_else(fcx, &**cond, &**then_blk, opt_else_expr.as_ref().map(|e| &**e),\n+        check_then_else(fcx, &cond, &then_blk, opt_else_expr.as_ref().map(|e| &**e),\n                         id, expr.span, expected);\n       }\n       hir::ExprWhile(ref cond, ref body, _) => {\n-        check_expr_has_type(fcx, &**cond, tcx.types.bool);\n-        check_block_no_value(fcx, &**body);\n-        let cond_ty = fcx.expr_ty(&**cond);\n+        check_expr_has_type(fcx, &cond, tcx.types.bool);\n+        check_block_no_value(fcx, &body);\n+        let cond_ty = fcx.expr_ty(&cond);\n         let body_ty = fcx.node_ty(body.id);\n         if cond_ty.references_error() || body_ty.references_error() {\n             fcx.write_error(id);\n@@ -3454,41 +3454,41 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n         }\n       }\n       hir::ExprLoop(ref body, _) => {\n-        check_block_no_value(fcx, &**body);\n-        if !may_break(tcx, expr.id, &**body) {\n+        check_block_no_value(fcx, &body);\n+        if !may_break(tcx, expr.id, &body) {\n             fcx.write_ty(id, fcx.infcx().next_diverging_ty_var());\n         } else {\n             fcx.write_nil(id);\n         }\n       }\n       hir::ExprMatch(ref discrim, ref arms, match_src) => {\n-        _match::check_match(fcx, expr, &**discrim, arms, expected, match_src);\n+        _match::check_match(fcx, expr, &discrim, arms, expected, match_src);\n       }\n       hir::ExprClosure(capture, ref decl, ref body) => {\n-          closure::check_expr_closure(fcx, expr, capture, &**decl, &**body, expected);\n+          closure::check_expr_closure(fcx, expr, capture, &decl, &body, expected);\n       }\n       hir::ExprBlock(ref b) => {\n-        check_block_with_expected(fcx, &**b, expected);\n+        check_block_with_expected(fcx, &b, expected);\n         fcx.write_ty(id, fcx.node_ty(b.id));\n       }\n       hir::ExprCall(ref callee, ref args) => {\n-          callee::check_call(fcx, expr, &**callee, &args[..], expected);\n+          callee::check_call(fcx, expr, &callee, &args[..], expected);\n \n           // we must check that return type of called functions is WF:\n           let ret_ty = fcx.expr_ty(expr);\n           fcx.register_wf_obligation(ret_ty, expr.span, traits::MiscObligation);\n       }\n       hir::ExprMethodCall(name, ref tps, ref args) => {\n           check_method_call(fcx, expr, name, &args[..], &tps[..], expected, lvalue_pref);\n-          let arg_tys = args.iter().map(|a| fcx.expr_ty(&**a));\n+          let arg_tys = args.iter().map(|a| fcx.expr_ty(&a));\n           let args_err = arg_tys.fold(false, |rest_err, a| rest_err || a.references_error());\n           if args_err {\n               fcx.write_error(id);\n           }\n       }\n       hir::ExprCast(ref e, ref t) => {\n         if let hir::TyFixedLengthVec(_, ref count_expr) = t.node {\n-            check_expr_with_hint(fcx, &**count_expr, tcx.types.usize);\n+            check_expr_with_hint(fcx, &count_expr, tcx.types.usize);\n         }\n \n         // Find the type of `e`. Supply hints based on the type we are casting to,\n@@ -3516,8 +3516,8 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n         }\n       }\n       hir::ExprType(ref e, ref t) => {\n-        let typ = fcx.to_ty(&**t);\n-        check_expr_eq_type(fcx, &**e, typ);\n+        let typ = fcx.to_ty(&t);\n+        check_expr_eq_type(fcx, &e, typ);\n         fcx.write_ty(id, typ);\n       }\n       hir::ExprVec(ref args) => {\n@@ -3531,14 +3531,14 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n         let typ = match uty {\n             Some(uty) => {\n                 for e in args {\n-                    check_expr_coercable_to_type(fcx, &**e, uty);\n+                    check_expr_coercable_to_type(fcx, &e, uty);\n                 }\n                 uty\n             }\n             None => {\n                 let t: Ty = fcx.infcx().next_ty_var();\n                 for e in args {\n-                    check_expr_has_type(fcx, &**e, t);\n+                    check_expr_has_type(fcx, &e, t);\n                 }\n                 t\n             }\n@@ -3547,8 +3547,8 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n         fcx.write_ty(id, typ);\n       }\n       hir::ExprRepeat(ref element, ref count_expr) => {\n-        check_expr_has_type(fcx, &**count_expr, tcx.types.usize);\n-        let count = fcx.tcx().eval_repeat_count(&**count_expr);\n+        check_expr_has_type(fcx, &count_expr, tcx.types.usize);\n+        let count = fcx.tcx().eval_repeat_count(&count_expr);\n \n         let uty = match expected {\n             ExpectHasType(uty) => {\n@@ -3562,13 +3562,13 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n \n         let (element_ty, t) = match uty {\n             Some(uty) => {\n-                check_expr_coercable_to_type(fcx, &**element, uty);\n+                check_expr_coercable_to_type(fcx, &element, uty);\n                 (uty, uty)\n             }\n             None => {\n                 let t: Ty = fcx.infcx().next_ty_var();\n-                check_expr_has_type(fcx, &**element, t);\n-                (fcx.expr_ty(&**element), t)\n+                check_expr_has_type(fcx, &element, t);\n+                (fcx.expr_ty(&element), t)\n             }\n         };\n \n@@ -3602,12 +3602,12 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n             let t = match flds {\n                 Some(ref fs) if i < fs.len() => {\n                     let ety = fs[i];\n-                    check_expr_coercable_to_type(fcx, &**e, ety);\n+                    check_expr_coercable_to_type(fcx, &e, ety);\n                     ety\n                 }\n                 _ => {\n-                    check_expr_with_expectation(fcx, &**e, NoExpectation);\n-                    fcx.expr_ty(&**e)\n+                    check_expr_with_expectation(fcx, &e, NoExpectation);\n+                    fcx.expr_ty(&e)\n                 }\n             };\n             err_field = err_field || t.references_error();\n@@ -3626,17 +3626,17 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n         fcx.require_expr_have_sized_type(expr, traits::StructInitializerSized);\n       }\n       hir::ExprField(ref base, ref field) => {\n-        check_field(fcx, expr, lvalue_pref, &**base, field);\n+        check_field(fcx, expr, lvalue_pref, &base, field);\n       }\n       hir::ExprTupField(ref base, idx) => {\n-        check_tup_field(fcx, expr, lvalue_pref, &**base, idx);\n+        check_tup_field(fcx, expr, lvalue_pref, &base, idx);\n       }\n       hir::ExprIndex(ref base, ref idx) => {\n-          check_expr_with_lvalue_pref(fcx, &**base, lvalue_pref);\n-          check_expr(fcx, &**idx);\n+          check_expr_with_lvalue_pref(fcx, &base, lvalue_pref);\n+          check_expr(fcx, &idx);\n \n-          let base_t = fcx.expr_ty(&**base);\n-          let idx_t = fcx.expr_ty(&**idx);\n+          let base_t = fcx.expr_ty(&base);\n+          let idx_t = fcx.expr_ty(&idx);\n \n           if base_t.references_error() {\n               fcx.write_ty(id, base_t);\n@@ -3651,7 +3651,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                       fcx.write_ty(id, element_ty);\n                   }\n                   None => {\n-                      check_expr_has_type(fcx, &**idx, fcx.tcx().types.err);\n+                      check_expr_has_type(fcx, &idx, fcx.tcx().types.err);\n                       fcx.type_error_message(\n                           expr.span,\n                           |actual| {\n@@ -3667,12 +3667,12 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n        }\n        hir::ExprRange(ref start, ref end) => {\n           let t_start = start.as_ref().map(|e| {\n-            check_expr(fcx, &**e);\n-            fcx.expr_ty(&**e)\n+            check_expr(fcx, &e);\n+            fcx.expr_ty(&e)\n           });\n           let t_end = end.as_ref().map(|e| {\n-            check_expr(fcx, &**e);\n-            fcx.expr_ty(&**e)\n+            check_expr(fcx, &e);\n+            fcx.expr_ty(&e)\n           });\n \n           let idx_type = match (t_start, t_end) {\n@@ -3905,18 +3905,18 @@ pub fn check_decl_local<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>, local: &'tcx hir::Local)\n     fcx.write_ty(local.id, t);\n \n     if let Some(ref init) = local.init {\n-        check_decl_initializer(fcx, local, &**init);\n-        let init_ty = fcx.expr_ty(&**init);\n+        check_decl_initializer(fcx, local, &init);\n+        let init_ty = fcx.expr_ty(&init);\n         if init_ty.references_error() {\n             fcx.write_ty(local.id, init_ty);\n         }\n     }\n \n     let pcx = pat_ctxt {\n         fcx: fcx,\n-        map: pat_id_map(&tcx.def_map, &*local.pat),\n+        map: pat_id_map(&tcx.def_map, &local.pat),\n     };\n-    _match::check_pat(&pcx, &*local.pat, t);\n+    _match::check_pat(&pcx, &local.pat, t);\n     let pat_ty = fcx.node_ty(local.pat.id);\n     if pat_ty.references_error() {\n         fcx.write_ty(local.id, pat_ty);\n@@ -3932,7 +3932,7 @@ pub fn check_stmt<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>, stmt: &'tcx hir::Stmt)  {\n         node_id = id;\n         match decl.node {\n           hir::DeclLocal(ref l) => {\n-              check_decl_local(fcx, &**l);\n+              check_decl_local(fcx, &l);\n               let l_t = fcx.node_ty(l.id);\n               saw_bot = saw_bot || fcx.infcx().type_var_diverges(l_t);\n               saw_err = saw_err || l_t.references_error();\n@@ -3943,15 +3943,15 @@ pub fn check_stmt<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>, stmt: &'tcx hir::Stmt)  {\n       hir::StmtExpr(ref expr, id) => {\n         node_id = id;\n         // Check with expected type of ()\n-        check_expr_has_type(fcx, &**expr, fcx.tcx().mk_nil());\n-        let expr_ty = fcx.expr_ty(&**expr);\n+        check_expr_has_type(fcx, &expr, fcx.tcx().mk_nil());\n+        let expr_ty = fcx.expr_ty(&expr);\n         saw_bot = saw_bot || fcx.infcx().type_var_diverges(expr_ty);\n         saw_err = saw_err || expr_ty.references_error();\n       }\n       hir::StmtSemi(ref expr, id) => {\n         node_id = id;\n-        check_expr(fcx, &**expr);\n-        let expr_ty = fcx.expr_ty(&**expr);\n+        check_expr(fcx, &expr);\n+        let expr_ty = fcx.expr_ty(&expr);\n         saw_bot |= fcx.infcx().type_var_diverges(expr_ty);\n         saw_err |= expr_ty.references_error();\n       }\n@@ -4035,12 +4035,12 @@ fn check_block_with_expected<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n             }\n             let ety = match expected {\n                 ExpectHasType(ety) => {\n-                    check_expr_coercable_to_type(fcx, &**e, ety);\n+                    check_expr_coercable_to_type(fcx, &e, ety);\n                     ety\n                 }\n                 _ => {\n-                    check_expr_with_expectation(fcx, &**e, expected);\n-                    fcx.expr_ty(&**e)\n+                    check_expr_with_expectation(fcx, &e, expected);\n+                    fcx.expr_ty(&e)\n                 }\n             };\n \n@@ -4608,7 +4608,7 @@ pub fn instantiate_path<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n             let type_count = type_defs.len(space);\n             assert_eq!(substs.types.len(space), 0);\n             for (i, typ) in data.types.iter().enumerate() {\n-                let t = fcx.to_ty(&**typ);\n+                let t = fcx.to_ty(&typ);\n                 if i < type_count {\n                     substs.types.push(space, t);\n                 } else if i == type_count {\n@@ -4677,7 +4677,7 @@ pub fn instantiate_path<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         }\n \n         let input_tys: Vec<Ty> =\n-            data.inputs.iter().map(|ty| fcx.to_ty(&**ty)).collect();\n+            data.inputs.iter().map(|ty| fcx.to_ty(&ty)).collect();\n \n         let tuple_ty = fcx.tcx().mk_tup(input_tys);\n \n@@ -4686,7 +4686,7 @@ pub fn instantiate_path<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         }\n \n         let output_ty: Option<Ty> =\n-            data.output.as_ref().map(|ty| fcx.to_ty(&**ty));\n+            data.output.as_ref().map(|ty| fcx.to_ty(&ty));\n \n         let output_ty =\n             output_ty.unwrap_or(fcx.tcx().mk_nil());\n@@ -4848,7 +4848,7 @@ pub fn structurally_resolved_type<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n pub fn may_break(cx: &ty::ctxt, id: ast::NodeId, b: &hir::Block) -> bool {\n     // First: is there an unlabeled break immediately\n     // inside the loop?\n-    (loop_query(&*b, |e| {\n+    (loop_query(&b, |e| {\n         match *e {\n             hir::ExprBreak(None) => true,\n             _ => false"}, {"sha": "1ee0542f633372c405d6e6f1b5b94c70bd868e13", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/3548b8c273d9feb0291e97a928c4f48e01daf0f9/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3548b8c273d9feb0291e97a928c4f48e01daf0f9/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=3548b8c273d9feb0291e97a928c4f48e01daf0f9", "patch": "@@ -489,15 +489,15 @@ fn visit_block(rcx: &mut Rcx, b: &hir::Block) {\n fn visit_arm(rcx: &mut Rcx, arm: &hir::Arm) {\n     // see above\n     for p in &arm.pats {\n-        constrain_bindings_in_pat(&**p, rcx);\n+        constrain_bindings_in_pat(&p, rcx);\n     }\n \n     intravisit::walk_arm(rcx, arm);\n }\n \n fn visit_local(rcx: &mut Rcx, l: &hir::Local) {\n     // see above\n-    constrain_bindings_in_pat(&*l.pat, rcx);\n+    constrain_bindings_in_pat(&l.pat, rcx);\n     link_local(rcx, l);\n     intravisit::walk_local(rcx, l);\n }\n@@ -656,10 +656,10 @@ fn visit_expr(rcx: &mut Rcx, expr: &hir::Expr) {\n \n         hir::ExprCall(ref callee, ref args) => {\n             if has_method_map {\n-                constrain_call(rcx, expr, Some(&**callee),\n+                constrain_call(rcx, expr, Some(&callee),\n                                args.iter().map(|e| &**e), false);\n             } else {\n-                constrain_callee(rcx, callee.id, expr, &**callee);\n+                constrain_callee(rcx, callee.id, expr, &callee);\n                 constrain_call(rcx, expr, None,\n                                args.iter().map(|e| &**e), false);\n             }\n@@ -668,23 +668,23 @@ fn visit_expr(rcx: &mut Rcx, expr: &hir::Expr) {\n         }\n \n         hir::ExprMethodCall(_, _, ref args) => {\n-            constrain_call(rcx, expr, Some(&*args[0]),\n+            constrain_call(rcx, expr, Some(&args[0]),\n                            args[1..].iter().map(|e| &**e), false);\n \n             intravisit::walk_expr(rcx, expr);\n         }\n \n         hir::ExprAssignOp(_, ref lhs, ref rhs) => {\n             if has_method_map {\n-                constrain_call(rcx, expr, Some(&**lhs),\n+                constrain_call(rcx, expr, Some(&lhs),\n                                Some(&**rhs).into_iter(), false);\n             }\n \n             intravisit::walk_expr(rcx, expr);\n         }\n \n         hir::ExprIndex(ref lhs, ref rhs) if has_method_map => {\n-            constrain_call(rcx, expr, Some(&**lhs),\n+            constrain_call(rcx, expr, Some(&lhs),\n                            Some(&**rhs).into_iter(), true);\n \n             intravisit::walk_expr(rcx, expr);\n@@ -697,7 +697,7 @@ fn visit_expr(rcx: &mut Rcx, expr: &hir::Expr) {\n             // overloaded op.  Note that we (sadly) currently use an\n             // implicit \"by ref\" sort of passing style here.  This\n             // should be converted to an adjustment!\n-            constrain_call(rcx, expr, Some(&**lhs),\n+            constrain_call(rcx, expr, Some(&lhs),\n                            Some(&**rhs).into_iter(), implicitly_ref_args);\n \n             intravisit::walk_expr(rcx, expr);\n@@ -706,8 +706,8 @@ fn visit_expr(rcx: &mut Rcx, expr: &hir::Expr) {\n         hir::ExprBinary(_, ref lhs, ref rhs) => {\n             // If you do `x OP y`, then the types of `x` and `y` must\n             // outlive the operation you are performing.\n-            let lhs_ty = rcx.resolve_expr_type_adjusted(&**lhs);\n-            let rhs_ty = rcx.resolve_expr_type_adjusted(&**rhs);\n+            let lhs_ty = rcx.resolve_expr_type_adjusted(&lhs);\n+            let rhs_ty = rcx.resolve_expr_type_adjusted(&rhs);\n             for &ty in &[lhs_ty, rhs_ty] {\n                 type_must_outlive(rcx,\n                                   infer::Operand(expr.span),\n@@ -721,7 +721,7 @@ fn visit_expr(rcx: &mut Rcx, expr: &hir::Expr) {\n             let implicitly_ref_args = !hir_util::is_by_value_unop(op);\n \n             // As above.\n-            constrain_call(rcx, expr, Some(&**lhs),\n+            constrain_call(rcx, expr, Some(&lhs),\n                            None::<hir::Expr>.iter(), implicitly_ref_args);\n \n             intravisit::walk_expr(rcx, expr);\n@@ -732,7 +732,7 @@ fn visit_expr(rcx: &mut Rcx, expr: &hir::Expr) {\n             let method_call = MethodCall::expr(expr.id);\n             let base_ty = match rcx.fcx.inh.tables.borrow().method_map.get(&method_call) {\n                 Some(method) => {\n-                    constrain_call(rcx, expr, Some(&**base),\n+                    constrain_call(rcx, expr, Some(&base),\n                                    None::<hir::Expr>.iter(), true);\n                     let fn_ret = // late-bound regions in overloaded method calls are instantiated\n                         rcx.tcx().no_late_bound_regions(&method.ty.fn_ret()).unwrap();\n@@ -750,7 +750,7 @@ fn visit_expr(rcx: &mut Rcx, expr: &hir::Expr) {\n \n         hir::ExprIndex(ref vec_expr, _) => {\n             // For a[b], the lifetime of a must enclose the deref\n-            let vec_type = rcx.resolve_expr_type_adjusted(&**vec_expr);\n+            let vec_type = rcx.resolve_expr_type_adjusted(&vec_expr);\n             constrain_index(rcx, expr, vec_type);\n \n             intravisit::walk_expr(rcx, expr);\n@@ -760,12 +760,12 @@ fn visit_expr(rcx: &mut Rcx, expr: &hir::Expr) {\n             // Determine if we are casting `source` to a trait\n             // instance.  If so, we have to be sure that the type of\n             // the source obeys the trait's region bound.\n-            constrain_cast(rcx, expr, &**source);\n+            constrain_cast(rcx, expr, &source);\n             intravisit::walk_expr(rcx, expr);\n         }\n \n         hir::ExprAddrOf(m, ref base) => {\n-            link_addr_of(rcx, expr, m, &**base);\n+            link_addr_of(rcx, expr, m, &base);\n \n             // Require that when you write a `&expr` expression, the\n             // resulting pointer has a lifetime that encompasses the\n@@ -780,13 +780,13 @@ fn visit_expr(rcx: &mut Rcx, expr: &hir::Expr) {\n         }\n \n         hir::ExprMatch(ref discr, ref arms, _) => {\n-            link_match(rcx, &**discr, &arms[..]);\n+            link_match(rcx, &discr, &arms[..]);\n \n             intravisit::walk_expr(rcx, expr);\n         }\n \n         hir::ExprClosure(_, _, ref body) => {\n-            check_expr_fn_block(rcx, expr, &**body);\n+            check_expr_fn_block(rcx, expr, &body);\n         }\n \n         hir::ExprLoop(ref body, _) => {\n@@ -797,10 +797,10 @@ fn visit_expr(rcx: &mut Rcx, expr: &hir::Expr) {\n \n         hir::ExprWhile(ref cond, ref body, _) => {\n             let repeating_scope = rcx.set_repeating_scope(cond.id);\n-            rcx.visit_expr(&**cond);\n+            rcx.visit_expr(&cond);\n \n             rcx.set_repeating_scope(body.id);\n-            rcx.visit_block(&**body);\n+            rcx.visit_block(&body);\n \n             rcx.set_repeating_scope(repeating_scope);\n         }\n@@ -945,7 +945,7 @@ fn constrain_call<'a, I: Iterator<Item=&'a hir::Expr>>(rcx: &mut Rcx,\n             rcx, infer::CallRcvr(r.span),\n             r.id, callee_region);\n         if implicitly_ref_args {\n-            link_by_ref(rcx, &*r, callee_scope);\n+            link_by_ref(rcx, &r, callee_scope);\n         }\n     }\n }\n@@ -1143,7 +1143,7 @@ fn link_local(rcx: &Rcx, local: &hir::Local) {\n     };\n     let mc = mc::MemCategorizationContext::new(rcx.fcx.infcx());\n     let discr_cmt = ignore_err!(mc.cat_expr(init_expr));\n-    link_pattern(rcx, mc, discr_cmt, &*local.pat);\n+    link_pattern(rcx, mc, discr_cmt, &local.pat);\n }\n \n /// Computes the guarantors for any ref bindings in a match and\n@@ -1156,7 +1156,7 @@ fn link_match(rcx: &Rcx, discr: &hir::Expr, arms: &[hir::Arm]) {\n     debug!(\"discr_cmt={:?}\", discr_cmt);\n     for arm in arms {\n         for root_pat in &arm.pats {\n-            link_pattern(rcx, mc, discr_cmt.clone(), &**root_pat);\n+            link_pattern(rcx, mc, discr_cmt.clone(), &root_pat);\n         }\n     }\n }\n@@ -1175,7 +1175,7 @@ fn link_fn_args(rcx: &Rcx, body_scope: CodeExtent, args: &[hir::Arg]) {\n                arg_ty,\n                arg_cmt,\n                arg);\n-        link_pattern(rcx, mc, arg_cmt, &*arg.pat);\n+        link_pattern(rcx, mc, arg_cmt, &arg.pat);\n     }\n }\n \n@@ -1199,7 +1199,7 @@ fn link_pattern<'t, 'a, 'tcx>(rcx: &Rcx<'a, 'tcx>,\n \n                 // `[_, ..slice, _]` pattern\n                 hir::PatVec(_, Some(ref slice_pat), _) => {\n-                    match mc.cat_slice_pattern(sub_cmt, &**slice_pat) {\n+                    match mc.cat_slice_pattern(sub_cmt, &slice_pat) {\n                         Ok((slice_cmt, slice_mutbl, slice_r)) => {\n                             link_region(rcx, sub_pat.span, &slice_r,\n                                         ty::BorrowKind::from_mutbl(slice_mutbl),"}, {"sha": "bc4ec3adbc1853b820fccdc429856bb8ba432c80", "filename": "src/librustc_typeck/check/upvar.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3548b8c273d9feb0291e97a928c4f48e01daf0f9/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3548b8c273d9feb0291e97a928c4f48e01daf0f9/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs?ref=3548b8c273d9feb0291e97a928c4f48e01daf0f9", "patch": "@@ -99,7 +99,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for SeedBorrowKind<'a, 'tcx> {\n     fn visit_expr(&mut self, expr: &hir::Expr) {\n         match expr.node {\n             hir::ExprClosure(cc, _, ref body) => {\n-                self.check_closure(expr, cc, &**body);\n+                self.check_closure(expr, cc, &body);\n             }\n \n             _ => { }"}, {"sha": "e663e449cfc4a3cd922e636ed4ef7f3796daa680", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3548b8c273d9feb0291e97a928c4f48e01daf0f9/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3548b8c273d9feb0291e97a928c4f48e01daf0f9/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=3548b8c273d9feb0291e97a928c4f48e01daf0f9", "patch": "@@ -53,10 +53,10 @@ pub fn resolve_type_vars_in_fn(fcx: &FnCtxt,\n     wbcx.visit_block(blk);\n     for arg in &decl.inputs {\n         wbcx.visit_node_id(ResolvingPattern(arg.pat.span), arg.id);\n-        wbcx.visit_pat(&*arg.pat);\n+        wbcx.visit_pat(&arg.pat);\n \n         // Privacy needs the type for the whole pattern, not just each binding\n-        if !pat_util::pat_is_binding(&fcx.tcx().def_map.borrow(), &*arg.pat) {\n+        if !pat_util::pat_is_binding(&fcx.tcx().def_map.borrow(), &arg.pat) {\n             wbcx.visit_node_id(ResolvingPattern(arg.pat.span),\n                                arg.pat.id);\n         }\n@@ -221,7 +221,7 @@ impl<'cx, 'tcx, 'v> Visitor<'v> for WritebackCx<'cx, 'tcx> {\n     fn visit_ty(&mut self, t: &hir::Ty) {\n         match t.node {\n             hir::TyFixedLengthVec(ref ty, ref count_expr) => {\n-                self.visit_ty(&**ty);\n+                self.visit_ty(&ty);\n                 write_ty_to_tcx(self.tcx(), count_expr.id, self.tcx().types.usize);\n             }\n             hir::TyBareFn(ref function_declaration) => {"}, {"sha": "cae2d9d890d7931329ae8b02e87afa25b5a1a1a8", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/3548b8c273d9feb0291e97a928c4f48e01daf0f9/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3548b8c273d9feb0291e97a928c4f48e01daf0f9/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=3548b8c273d9feb0291e97a928c4f48e01daf0f9", "patch": "@@ -273,7 +273,7 @@ impl<'a,'tcx> CrateCtxt<'a,'tcx> {\n                 _ => tcx.sess.bug(&format!(\"get_trait_def({:?}): not an item\", trait_id))\n             };\n \n-            trait_def_of_item(self, &*item)\n+            trait_def_of_item(self, &item)\n         } else {\n             tcx.lookup_trait_def(trait_id)\n         }\n@@ -577,7 +577,7 @@ fn convert_field<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                            v: &hir::StructField,\n                            ty_f: ty::FieldDefMaster<'tcx>)\n {\n-    let tt = ccx.icx(struct_predicates).to_ty(&ExplicitRscope, &*v.node.ty);\n+    let tt = ccx.icx(struct_predicates).to_ty(&ExplicitRscope, &v.node.ty);\n     ty_f.fulfill_ty(tt);\n     write_ty_to_tcx(ccx.tcx, v.node.id, tt);\n \n@@ -709,7 +709,7 @@ fn convert_item(ccx: &CrateCtxt, it: &hir::Item) {\n \n             debug!(\"convert: impl_bounds={:?}\", ty_predicates);\n \n-            let selfty = ccx.icx(&ty_predicates).to_ty(&ExplicitRscope, &**selfty);\n+            let selfty = ccx.icx(&ty_predicates).to_ty(&ExplicitRscope, &selfty);\n             write_ty_to_tcx(tcx, it.id, selfty);\n \n             tcx.register_item_type(def_id,\n@@ -768,7 +768,7 @@ fn convert_item(ccx: &CrateCtxt, it: &hir::Item) {\n \n                 if let hir::ImplItemKind::Const(ref ty, _) = impl_item.node {\n                     let ty = ccx.icx(&ty_predicates)\n-                                .to_ty(&ExplicitRscope, &*ty);\n+                                .to_ty(&ExplicitRscope, &ty);\n                     tcx.register_item_type(ccx.tcx.map.local_def_id(impl_item.id),\n                                            TypeScheme {\n                                                generics: ty_generics.clone(),\n@@ -1399,11 +1399,11 @@ fn type_scheme_of_def_id<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n     if let Some(node_id) = ccx.tcx.map.as_local_node_id(def_id) {\n         match ccx.tcx.map.find(node_id) {\n             Some(hir_map::NodeItem(item)) => {\n-                type_scheme_of_item(ccx, &*item)\n+                type_scheme_of_item(ccx, &item)\n             }\n             Some(hir_map::NodeForeignItem(foreign_item)) => {\n                 let abi = ccx.tcx.map.get_foreign_abi(node_id);\n-                type_scheme_of_foreign_item(ccx, &*foreign_item, abi)\n+                type_scheme_of_foreign_item(ccx, &foreign_item, abi)\n             }\n             x => {\n                 ccx.tcx.sess.bug(&format!(\"unexpected sort of node \\\n@@ -1437,18 +1437,18 @@ fn compute_type_scheme_of_item<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n     let tcx = ccx.tcx;\n     match it.node {\n         hir::ItemStatic(ref t, _, _) | hir::ItemConst(ref t, _) => {\n-            let ty = ccx.icx(&()).to_ty(&ExplicitRscope, &**t);\n+            let ty = ccx.icx(&()).to_ty(&ExplicitRscope, &t);\n             ty::TypeScheme { ty: ty, generics: ty::Generics::empty() }\n         }\n         hir::ItemFn(ref decl, unsafety, _, abi, ref generics, _) => {\n             let ty_generics = ty_generics_for_fn(ccx, generics, &ty::Generics::empty());\n-            let tofd = astconv::ty_of_bare_fn(&ccx.icx(generics), unsafety, abi, &**decl);\n+            let tofd = astconv::ty_of_bare_fn(&ccx.icx(generics), unsafety, abi, &decl);\n             let ty = tcx.mk_fn(Some(ccx.tcx.map.local_def_id(it.id)), tcx.mk_bare_fn(tofd));\n             ty::TypeScheme { ty: ty, generics: ty_generics }\n         }\n         hir::ItemTy(ref t, ref generics) => {\n             let ty_generics = ty_generics_for_type_or_impl(ccx, generics);\n-            let ty = ccx.icx(generics).to_ty(&ExplicitRscope, &**t);\n+            let ty = ccx.icx(generics).to_ty(&ExplicitRscope, &t);\n             ty::TypeScheme { ty: ty, generics: ty_generics }\n         }\n         hir::ItemEnum(ref ei, ref generics) => {\n@@ -1777,7 +1777,7 @@ fn ty_generic_predicates<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n             &hir::WherePredicate::BoundPredicate(ref bound_pred) => {\n                 let ty = ast_ty_to_ty(&ccx.icx(&(base_predicates, ast_generics)),\n                                       &ExplicitRscope,\n-                                      &*bound_pred.bounded_ty);\n+                                      &bound_pred.bounded_ty);\n \n                 for bound in bound_pred.bounds.iter() {\n                     match bound {\n@@ -2120,11 +2120,11 @@ fn compute_type_scheme_of_foreign_fn_decl<'a, 'tcx>(\n     -> ty::TypeScheme<'tcx>\n {\n     for i in &decl.inputs {\n-        match (*i).pat.node {\n+        match i.pat.node {\n             hir::PatIdent(_, _, _) => (),\n             hir::PatWild => (),\n             _ => {\n-                span_err!(ccx.tcx.sess, (*i).pat.span, E0130,\n+                span_err!(ccx.tcx.sess, i.pat.span, E0130,\n                           \"patterns aren't allowed in foreign function declarations\");\n             }\n         }\n@@ -2140,7 +2140,7 @@ fn compute_type_scheme_of_foreign_fn_decl<'a, 'tcx>(\n \n     let output = match decl.output {\n         hir::Return(ref ty) =>\n-            ty::FnConverging(ast_ty_to_ty(&ccx.icx(ast_generics), &rb, &**ty)),\n+            ty::FnConverging(ast_ty_to_ty(&ccx.icx(ast_generics), &rb, &ty)),\n         hir::DefaultReturn(..) =>\n             ty::FnConverging(ccx.tcx.mk_nil()),\n         hir::NoReturn(..) =>"}, {"sha": "dd414c463c7b1c4aea0bab5b160050c6200c0bde", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3548b8c273d9feb0291e97a928c4f48e01daf0f9/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3548b8c273d9feb0291e97a928c4f48e01daf0f9/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=3548b8c273d9feb0291e97a928c4f48e01daf0f9", "patch": "@@ -143,7 +143,7 @@ pub trait AttributeMethods {\n impl AttributeMethods for Attribute {\n     /// Extract the MetaItem from inside this Attribute.\n     fn meta(&self) -> &MetaItem {\n-        &*self.node.value\n+        &self.node.value\n     }\n \n     /// Convert self to a normal #[doc=\"foo\"] comment, if it is a\n@@ -370,17 +370,17 @@ pub fn cfg_matches<T: CfgDiag>(cfgs: &[P<MetaItem>],\n                            diag: &mut T) -> bool {\n     match cfg.node {\n         ast::MetaItemKind::List(ref pred, ref mis) if &pred[..] == \"any\" =>\n-            mis.iter().any(|mi| cfg_matches(cfgs, &**mi, diag)),\n+            mis.iter().any(|mi| cfg_matches(cfgs, &mi, diag)),\n         ast::MetaItemKind::List(ref pred, ref mis) if &pred[..] == \"all\" =>\n-            mis.iter().all(|mi| cfg_matches(cfgs, &**mi, diag)),\n+            mis.iter().all(|mi| cfg_matches(cfgs, &mi, diag)),\n         ast::MetaItemKind::List(ref pred, ref mis) if &pred[..] == \"not\" => {\n             if mis.len() != 1 {\n                 diag.emit_error(|diagnostic| {\n                     diagnostic.span_err(cfg.span, \"expected 1 cfg-pattern\");\n                 });\n                 return false;\n             }\n-            !cfg_matches(cfgs, &*mis[0], diag)\n+            !cfg_matches(cfgs, &mis[0], diag)\n         }\n         ast::MetaItemKind::List(ref pred, _) => {\n             diag.emit_error(|diagnostic| {"}, {"sha": "123a21fb8f0c00690b14eaef5b15292154c64276", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3548b8c273d9feb0291e97a928c4f48e01daf0f9/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3548b8c273d9feb0291e97a928c4f48e01daf0f9/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=3548b8c273d9feb0291e97a928c4f48e01daf0f9", "patch": "@@ -1040,7 +1040,7 @@ fn expand_item_multi_modifier(mut it: Annotatable,\n                             allow_internal_unstable: true,\n                         }\n                     });\n-                    it = mac.expand(fld.cx, attr.span, &*attr.node.value, it);\n+                    it = mac.expand(fld.cx, attr.span, &attr.node.value, it);\n                     fld.cx.bt_pop();\n                 }\n                 _ => unreachable!()"}, {"sha": "5dfec8dafcf3776e10193ff07ddb1dd7f8a1b4c3", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3548b8c273d9feb0291e97a928c4f48e01daf0f9/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3548b8c273d9feb0291e97a928c4f48e01daf0f9/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=3548b8c273d9feb0291e97a928c4f48e01daf0f9", "patch": "@@ -676,7 +676,7 @@ impl<'a> Context<'a> {\n             }\n         }\n         for &(ref n, ref ty) in self.plugin_attributes {\n-            if &*n == name {\n+            if n == name {\n                 // Plugins can't gate attributes, so we don't check for it\n                 // unlike the code above; we only use this loop to\n                 // short-circuit to avoid the checks below"}, {"sha": "6df313177a08cb4b37f8a9007cfd43e78601ea6b", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3548b8c273d9feb0291e97a928c4f48e01daf0f9/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3548b8c273d9feb0291e97a928c4f48e01daf0f9/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=3548b8c273d9feb0291e97a928c4f48e01daf0f9", "patch": "@@ -1071,7 +1071,7 @@ pub fn noop_fold_item_simple<T: Folder>(Item {id, ident, attrs, node, vis, span}\n     let ident = match node {\n         // The node may have changed, recompute the \"pretty\" impl name.\n         ItemKind::Impl(_, _, _, ref maybe_trait, ref ty, _) => {\n-            ast_util::impl_pretty_name(maybe_trait, Some(&**ty))\n+            ast_util::impl_pretty_name(maybe_trait, Some(&ty))\n         }\n         _ => ident\n     };"}, {"sha": "aaa6f79cb188adcd7769e1fdceca72dd18565639", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3548b8c273d9feb0291e97a928c4f48e01daf0f9/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3548b8c273d9feb0291e97a928c4f48e01daf0f9/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=3548b8c273d9feb0291e97a928c4f48e01daf0f9", "patch": "@@ -606,8 +606,8 @@ pub fn integer_lit(s: &str,\n                 2 => sd.span_err(sp, \"binary float literal is not supported\"),\n                 _ => ()\n             }\n-            let ident = token::intern_and_get_ident(&*s);\n-            return filtered_float_lit(ident, Some(&**suf), sd, sp)\n+            let ident = token::intern_and_get_ident(&s);\n+            return filtered_float_lit(ident, Some(&suf), sd, sp)\n         }\n     }\n \n@@ -990,24 +990,24 @@ mod tests {\n     #[test] fn parse_use() {\n         let use_s = \"use foo::bar::baz;\";\n         let vitem = string_to_item(use_s.to_string()).unwrap();\n-        let vitem_s = item_to_string(&*vitem);\n+        let vitem_s = item_to_string(&vitem);\n         assert_eq!(&vitem_s[..], use_s);\n \n         let use_s = \"use foo::bar as baz;\";\n         let vitem = string_to_item(use_s.to_string()).unwrap();\n-        let vitem_s = item_to_string(&*vitem);\n+        let vitem_s = item_to_string(&vitem);\n         assert_eq!(&vitem_s[..], use_s);\n     }\n \n     #[test] fn parse_extern_crate() {\n         let ex_s = \"extern crate foo;\";\n         let vitem = string_to_item(ex_s.to_string()).unwrap();\n-        let vitem_s = item_to_string(&*vitem);\n+        let vitem_s = item_to_string(&vitem);\n         assert_eq!(&vitem_s[..], ex_s);\n \n         let ex_s = \"extern crate foo as bar;\";\n         let vitem = string_to_item(ex_s.to_string()).unwrap();\n-        let vitem_s = item_to_string(&*vitem);\n+        let vitem_s = item_to_string(&vitem);\n         assert_eq!(&vitem_s[..], ex_s);\n     }\n \n@@ -1030,7 +1030,7 @@ mod tests {\n             }\n         }\n         let mut v = PatIdentVisitor { spans: Vec::new() };\n-        ::visit::walk_item(&mut v, &*item);\n+        ::visit::walk_item(&mut v, &item);\n         return v.spans;\n     }\n "}, {"sha": "1e1877ec6ae0ace68d0a984b4d8885aaa1b6e23e", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/3548b8c273d9feb0291e97a928c4f48e01daf0f9/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3548b8c273d9feb0291e97a928c4f48e01daf0f9/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=3548b8c273d9feb0291e97a928c4f48e01daf0f9", "patch": "@@ -444,7 +444,7 @@ impl<'a> Parser<'a> {\n                 } else {\n                     b.push_str(\", \");\n                 }\n-                b.push_str(&*a.to_string());\n+                b.push_str(&a.to_string());\n                 b\n             })\n         }\n@@ -696,7 +696,7 @@ impl<'a> Parser<'a> {\n                 if text.is_empty() {\n                     self.span_bug(sp, \"found empty literal suffix in Some\")\n                 }\n-                self.span_err(sp, &*format!(\"{} with a suffix is invalid\", kind));\n+                self.span_err(sp, &format!(\"{} with a suffix is invalid\", kind));\n             }\n         }\n     }\n@@ -1574,7 +1574,7 @@ impl<'a> Parser<'a> {\n \n                 if suffix_illegal {\n                     let sp = self.last_span;\n-                    self.expect_no_suffix(sp, &*format!(\"{} literal\", lit.short_name()), suf)\n+                    self.expect_no_suffix(sp, &format!(\"{} literal\", lit.short_name()), suf)\n                 }\n \n                 Ok(out)\n@@ -2083,7 +2083,7 @@ impl<'a> Parser<'a> {\n                 let mut trailing_comma = false;\n                 while self.token != token::CloseDelim(token::Paren) {\n                     es.push(try!(self.parse_expr()));\n-                    try!(self.commit_expr(&**es.last().unwrap(), &[],\n+                    try!(self.commit_expr(&es.last().unwrap(), &[],\n                                      &[token::Comma, token::CloseDelim(token::Paren)]));\n                     if self.check(&token::Comma) {\n                         trailing_comma = true;\n@@ -2295,7 +2295,7 @@ impl<'a> Parser<'a> {\n                                 }\n \n                                 fields.push(try!(self.parse_field()));\n-                                try!(self.commit_expr(&*fields.last().unwrap().expr,\n+                                try!(self.commit_expr(&fields.last().unwrap().expr,\n                                                  &[token::Comma],\n                                                  &[token::CloseDelim(token::Brace)]));\n                             }\n@@ -2508,7 +2508,7 @@ impl<'a> Parser<'a> {\n                 }\n                 continue;\n             }\n-            if self.expr_is_complete(&*e) { break; }\n+            if self.expr_is_complete(&e) { break; }\n             match self.token {\n               // expr(...)\n               token::OpenDelim(token::Paren) => {\n@@ -2530,7 +2530,7 @@ impl<'a> Parser<'a> {\n                 self.bump();\n                 let ix = try!(self.parse_expr());\n                 hi = self.span.hi;\n-                try!(self.commit_expr_expecting(&*ix, token::CloseDelim(token::Bracket)));\n+                try!(self.commit_expr_expecting(&ix, token::CloseDelim(token::Bracket)));\n                 let index = self.mk_index(e, ix);\n                 e = self.mk_expr(lo, hi, index, None)\n               }\n@@ -2820,7 +2820,7 @@ impl<'a> Parser<'a> {\n         };\n \n \n-        if self.expr_is_complete(&*lhs) {\n+        if self.expr_is_complete(&lhs) {\n             // Semi-statement forms are odd. See https://github.com/rust-lang/rust/issues/29071\n             return Ok(lhs);\n         }\n@@ -2844,7 +2844,7 @@ impl<'a> Parser<'a> {\n             }\n             self.bump();\n             if op.is_comparison() {\n-                self.check_no_chained_comparison(&*lhs, &op);\n+                self.check_no_chained_comparison(&lhs, &op);\n             }\n             // Special cases:\n             if op == AssocOp::As {\n@@ -3152,7 +3152,7 @@ impl<'a> Parser<'a> {\n         let lo = self.last_span.lo;\n         let discriminant = try!(self.parse_expr_res(\n             Restrictions::RESTRICTION_NO_STRUCT_LITERAL, None));\n-        if let Err(mut e) = self.commit_expr_expecting(&*discriminant,\n+        if let Err(mut e) = self.commit_expr_expecting(&discriminant,\n                                                        token::OpenDelim(token::Brace)) {\n             if self.token == token::Token::Semi {\n                 e.span_note(match_span, \"did you mean to remove this `match` keyword?\");\n@@ -3183,11 +3183,11 @@ impl<'a> Parser<'a> {\n         let expr = try!(self.parse_expr_res(Restrictions::RESTRICTION_STMT_EXPR, None));\n \n         let require_comma =\n-            !classify::expr_is_simple_block(&*expr)\n+            !classify::expr_is_simple_block(&expr)\n             && self.token != token::CloseDelim(token::Brace);\n \n         if require_comma {\n-            try!(self.commit_expr(&*expr, &[token::Comma], &[token::CloseDelim(token::Brace)]));\n+            try!(self.commit_expr(&expr, &[token::Comma], &[token::CloseDelim(token::Brace)]));\n         } else {\n             self.eat(&token::Comma);\n         }\n@@ -3936,7 +3936,7 @@ impl<'a> Parser<'a> {\n             stmts: &mut Vec<Stmt>,\n             last_block_expr: &mut Option<P<Expr>>) -> PResult<'a, ()> {\n         // expression without semicolon\n-        if classify::expr_requires_semi_to_be_stmt(&*e) {\n+        if classify::expr_requires_semi_to_be_stmt(&e) {\n             // Just check for errors and recover; do not eat semicolon yet.\n             try!(self.commit_stmt(&[],\n                              &[token::Semi, token::CloseDelim(token::Brace)]));\n@@ -4861,7 +4861,7 @@ impl<'a> Parser<'a> {\n                 impl_items.push(try!(self.parse_impl_item()));\n             }\n \n-            Ok((ast_util::impl_pretty_name(&opt_trait, Some(&*ty)),\n+            Ok((ast_util::impl_pretty_name(&opt_trait, Some(&ty)),\n              ItemKind::Impl(unsafety, polarity, generics, opt_trait, ty, impl_items),\n              Some(attrs)))\n         }\n@@ -5075,7 +5075,7 @@ impl<'a> Parser<'a> {\n         let ty = try!(self.parse_ty_sum());\n         try!(self.expect(&token::Eq));\n         let e = try!(self.parse_expr());\n-        try!(self.commit_expr_expecting(&*e, token::Semi));\n+        try!(self.commit_expr_expecting(&e, token::Semi));\n         let item = match m {\n             Some(m) => ItemKind::Static(ty, m, e),\n             None => ItemKind::Const(ty, e),"}, {"sha": "accbb54c629b243220c4bdb33caa5f39349af5b4", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3548b8c273d9feb0291e97a928c4f48e01daf0f9/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3548b8c273d9feb0291e97a928c4f48e01daf0f9/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=3548b8c273d9feb0291e97a928c4f48e01daf0f9", "patch": "@@ -666,7 +666,7 @@ impl InternedString {\n impl Deref for InternedString {\n     type Target = str;\n \n-    fn deref(&self) -> &str { &*self.string }\n+    fn deref(&self) -> &str { &self.string }\n }\n \n impl fmt::Debug for InternedString {"}, {"sha": "2eb719627da50dad109bbbaeccb6f2c6263569c4", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 133, "deletions": 133, "changes": 266, "blob_url": "https://github.com/rust-lang/rust/blob/3548b8c273d9feb0291e97a928c4f48e01daf0f9/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3548b8c273d9feb0291e97a928c4f48e01daf0f9/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=3548b8c273d9feb0291e97a928c4f48e01daf0f9", "patch": "@@ -286,22 +286,22 @@ pub fn token_to_string(tok: &Token) -> String {\n         token::SpecialVarNt(var)    => format!(\"${}\", var.as_str()),\n \n         token::Interpolated(ref nt) => match *nt {\n-            token::NtExpr(ref e)        => expr_to_string(&**e),\n-            token::NtMeta(ref e)        => meta_item_to_string(&**e),\n-            token::NtTy(ref e)          => ty_to_string(&**e),\n-            token::NtPath(ref e)        => path_to_string(&**e),\n-            token::NtItem(ref e)        => item_to_string(&**e),\n-            token::NtBlock(ref e)       => block_to_string(&**e),\n-            token::NtStmt(ref e)        => stmt_to_string(&**e),\n-            token::NtPat(ref e)         => pat_to_string(&**e),\n+            token::NtExpr(ref e)        => expr_to_string(&e),\n+            token::NtMeta(ref e)        => meta_item_to_string(&e),\n+            token::NtTy(ref e)          => ty_to_string(&e),\n+            token::NtPath(ref e)        => path_to_string(&e),\n+            token::NtItem(ref e)        => item_to_string(&e),\n+            token::NtBlock(ref e)       => block_to_string(&e),\n+            token::NtStmt(ref e)        => stmt_to_string(&e),\n+            token::NtPat(ref e)         => pat_to_string(&e),\n             token::NtIdent(ref e, _)    => ident_to_string(e.node),\n-            token::NtTT(ref e)          => tt_to_string(&**e),\n-            token::NtArm(ref e)         => arm_to_string(&*e),\n-            token::NtImplItem(ref e)    => impl_item_to_string(&**e),\n-            token::NtTraitItem(ref e)   => trait_item_to_string(&**e),\n-            token::NtGenerics(ref e)    => generics_to_string(&*e),\n-            token::NtWhereClause(ref e) => where_clause_to_string(&*e),\n-            token::NtArg(ref e)         => arg_to_string(&*e),\n+            token::NtTT(ref e)          => tt_to_string(&e),\n+            token::NtArm(ref e)         => arm_to_string(&e),\n+            token::NtImplItem(ref e)    => impl_item_to_string(&e),\n+            token::NtTraitItem(ref e)   => trait_item_to_string(&e),\n+            token::NtGenerics(ref e)    => generics_to_string(&e),\n+            token::NtWhereClause(ref e) => where_clause_to_string(&e),\n+            token::NtArg(ref e)         => arg_to_string(&e),\n         }\n     }\n }\n@@ -758,7 +758,7 @@ pub trait PrintState<'a> {\n                 ast::AttrStyle::Inner => try!(word(self.writer(), \"#![\")),\n                 ast::AttrStyle::Outer => try!(word(self.writer(), \"#[\")),\n             }\n-            try!(self.print_meta_item(&*attr.meta()));\n+            try!(self.print_meta_item(&attr.meta()));\n             word(self.writer(), \"]\")\n         }\n     }\n@@ -779,7 +779,7 @@ pub trait PrintState<'a> {\n                 try!(self.popen());\n                 try!(self.commasep(Consistent,\n                                    &items[..],\n-                                   |s, i| s.print_meta_item(&**i)));\n+                                   |s, i| s.print_meta_item(&i)));\n                 try!(self.pclose());\n             }\n         }\n@@ -923,14 +923,14 @@ impl<'a> State<'a> {\n \n     pub fn commasep_exprs(&mut self, b: Breaks,\n                           exprs: &[P<ast::Expr>]) -> io::Result<()> {\n-        self.commasep_cmnt(b, exprs, |s, e| s.print_expr(&**e), |e| e.span)\n+        self.commasep_cmnt(b, exprs, |s, e| s.print_expr(&e), |e| e.span)\n     }\n \n     pub fn print_mod(&mut self, _mod: &ast::Mod,\n                      attrs: &[ast::Attribute]) -> io::Result<()> {\n         try!(self.print_inner_attributes(attrs));\n         for item in &_mod.items {\n-            try!(self.print_item(&**item));\n+            try!(self.print_item(&item));\n         }\n         Ok(())\n     }\n@@ -959,7 +959,7 @@ impl<'a> State<'a> {\n         match ty.node {\n             ast::TyKind::Vec(ref ty) => {\n                 try!(word(&mut self.s, \"[\"));\n-                try!(self.print_type(&**ty));\n+                try!(self.print_type(&ty));\n                 try!(word(&mut self.s, \"]\"));\n             }\n             ast::TyKind::Ptr(ref mt) => {\n@@ -968,7 +968,7 @@ impl<'a> State<'a> {\n                     ast::Mutability::Mutable => try!(self.word_nbsp(\"mut\")),\n                     ast::Mutability::Immutable => try!(self.word_nbsp(\"const\")),\n                 }\n-                try!(self.print_type(&*mt.ty));\n+                try!(self.print_type(&mt.ty));\n             }\n             ast::TyKind::Rptr(ref lifetime, ref mt) => {\n                 try!(word(&mut self.s, \"&\"));\n@@ -978,15 +978,15 @@ impl<'a> State<'a> {\n             ast::TyKind::Tup(ref elts) => {\n                 try!(self.popen());\n                 try!(self.commasep(Inconsistent, &elts[..],\n-                                   |s, ty| s.print_type(&**ty)));\n+                                   |s, ty| s.print_type(&ty)));\n                 if elts.len() == 1 {\n                     try!(word(&mut self.s, \",\"));\n                 }\n                 try!(self.pclose());\n             }\n             ast::TyKind::Paren(ref typ) => {\n                 try!(self.popen());\n-                try!(self.print_type(&**typ));\n+                try!(self.print_type(&typ));\n                 try!(self.pclose());\n             }\n             ast::TyKind::BareFn(ref f) => {\n@@ -1000,7 +1000,7 @@ impl<'a> State<'a> {\n                 };\n                 try!(self.print_ty_fn(f.abi,\n                                       f.unsafety,\n-                                      &*f.decl,\n+                                      &f.decl,\n                                       None,\n                                       &generics,\n                                       None));\n@@ -1012,22 +1012,22 @@ impl<'a> State<'a> {\n                 try!(self.print_qpath(path, qself, false))\n             }\n             ast::TyKind::ObjectSum(ref ty, ref bounds) => {\n-                try!(self.print_type(&**ty));\n+                try!(self.print_type(&ty));\n                 try!(self.print_bounds(\"+\", &bounds[..]));\n             }\n             ast::TyKind::PolyTraitRef(ref bounds) => {\n                 try!(self.print_bounds(\"\", &bounds[..]));\n             }\n             ast::TyKind::FixedLengthVec(ref ty, ref v) => {\n                 try!(word(&mut self.s, \"[\"));\n-                try!(self.print_type(&**ty));\n+                try!(self.print_type(&ty));\n                 try!(word(&mut self.s, \"; \"));\n-                try!(self.print_expr(&**v));\n+                try!(self.print_expr(&v));\n                 try!(word(&mut self.s, \"]\"));\n             }\n             ast::TyKind::Typeof(ref e) => {\n                 try!(word(&mut self.s, \"typeof(\"));\n-                try!(self.print_expr(&**e));\n+                try!(self.print_expr(&e));\n                 try!(word(&mut self.s, \")\"));\n             }\n             ast::TyKind::Infer => {\n@@ -1064,7 +1064,7 @@ impl<'a> State<'a> {\n                 }\n                 try!(self.print_ident(item.ident));\n                 try!(self.word_space(\":\"));\n-                try!(self.print_type(&**t));\n+                try!(self.print_type(&t));\n                 try!(word(&mut self.s, \";\"));\n                 try!(self.end()); // end the head-ibox\n                 self.end() // end the outer cbox\n@@ -1139,7 +1139,7 @@ impl<'a> State<'a> {\n             ast::ItemKind::Use(ref vp) => {\n                 try!(self.head(&visibility_qualified(item.vis,\n                                                      \"use\")));\n-                try!(self.print_view_path(&**vp));\n+                try!(self.print_view_path(&vp));\n                 try!(word(&mut self.s, \";\"));\n                 try!(self.end()); // end inner head-block\n                 try!(self.end()); // end outer head-block\n@@ -1152,12 +1152,12 @@ impl<'a> State<'a> {\n                 }\n                 try!(self.print_ident(item.ident));\n                 try!(self.word_space(\":\"));\n-                try!(self.print_type(&**ty));\n+                try!(self.print_type(&ty));\n                 try!(space(&mut self.s));\n                 try!(self.end()); // end the head-ibox\n \n                 try!(self.word_space(\"=\"));\n-                try!(self.print_expr(&**expr));\n+                try!(self.print_expr(&expr));\n                 try!(word(&mut self.s, \";\"));\n                 try!(self.end()); // end the outer cbox\n             }\n@@ -1166,12 +1166,12 @@ impl<'a> State<'a> {\n                                                     \"const\")));\n                 try!(self.print_ident(item.ident));\n                 try!(self.word_space(\":\"));\n-                try!(self.print_type(&**ty));\n+                try!(self.print_type(&ty));\n                 try!(space(&mut self.s));\n                 try!(self.end()); // end the head-ibox\n \n                 try!(self.word_space(\"=\"));\n-                try!(self.print_expr(&**expr));\n+                try!(self.print_expr(&expr));\n                 try!(word(&mut self.s, \";\"));\n                 try!(self.end()); // end the outer cbox\n             }\n@@ -1188,7 +1188,7 @@ impl<'a> State<'a> {\n                     item.vis\n                 ));\n                 try!(word(&mut self.s, \" \"));\n-                try!(self.print_block_with_attrs(&**body, &item.attrs));\n+                try!(self.print_block_with_attrs(&body, &item.attrs));\n             }\n             ast::ItemKind::Mod(ref _mod) => {\n                 try!(self.head(&visibility_qualified(item.vis,\n@@ -1217,7 +1217,7 @@ impl<'a> State<'a> {\n                 try!(self.print_where_clause(&params.where_clause));\n                 try!(space(&mut self.s));\n                 try!(self.word_space(\"=\"));\n-                try!(self.print_type(&**ty));\n+                try!(self.print_type(&ty));\n                 try!(word(&mut self.s, \";\"));\n                 try!(self.end()); // end the outer ibox\n             }\n@@ -1279,7 +1279,7 @@ impl<'a> State<'a> {\n                     None => {}\n                 }\n \n-                try!(self.print_type(&**ty));\n+                try!(self.print_type(&ty));\n                 try!(self.print_where_clause(&generics.where_clause));\n \n                 try!(space(&mut self.s));\n@@ -1412,7 +1412,7 @@ impl<'a> State<'a> {\n                             ast::UnnamedField(vis) => {\n                                 try!(s.print_visibility(vis));\n                                 try!(s.maybe_print_comment(field.span.lo));\n-                                s.print_type(&*field.node.ty)\n+                                s.print_type(&field.node.ty)\n                             }\n                         }\n                     }\n@@ -1441,7 +1441,7 @@ impl<'a> State<'a> {\n                         try!(self.print_visibility(visibility));\n                         try!(self.print_ident(ident));\n                         try!(self.word_nbsp(\":\"));\n-                        try!(self.print_type(&*field.node.ty));\n+                        try!(self.print_type(&field.node.ty));\n                         try!(word(&mut self.s, \",\"));\n                     }\n                 }\n@@ -1524,7 +1524,7 @@ impl<'a> State<'a> {\n             Some(ref d) => {\n                 try!(space(&mut self.s));\n                 try!(self.word_space(\"=\"));\n-                self.print_expr(&**d)\n+                self.print_expr(&d)\n             }\n             _ => Ok(())\n         }\n@@ -1614,15 +1614,15 @@ impl<'a> State<'a> {\n         try!(self.maybe_print_comment(st.span.lo));\n         match st.node {\n             ast::StmtKind::Decl(ref decl, _) => {\n-                try!(self.print_decl(&**decl));\n+                try!(self.print_decl(&decl));\n             }\n             ast::StmtKind::Expr(ref expr, _) => {\n                 try!(self.space_if_not_bol());\n-                try!(self.print_expr_outer_attr_style(&**expr, false));\n+                try!(self.print_expr_outer_attr_style(&expr, false));\n             }\n             ast::StmtKind::Semi(ref expr, _) => {\n                 try!(self.space_if_not_bol());\n-                try!(self.print_expr_outer_attr_style(&**expr, false));\n+                try!(self.print_expr_outer_attr_style(&expr, false));\n                 try!(word(&mut self.s, \";\"));\n             }\n             ast::StmtKind::Mac(ref mac, style, ref attrs) => {\n@@ -1632,7 +1632,7 @@ impl<'a> State<'a> {\n                     ast::MacStmtStyle::Braces => token::Brace,\n                     _ => token::Paren\n                 };\n-                try!(self.print_mac(&**mac, delim));\n+                try!(self.print_mac(&mac, delim));\n                 match style {\n                     ast::MacStmtStyle::Braces => {}\n                     _ => try!(word(&mut self.s, \";\")),\n@@ -1691,7 +1691,7 @@ impl<'a> State<'a> {\n         match blk.expr {\n             Some(ref expr) => {\n                 try!(self.space_if_not_bol());\n-                try!(self.print_expr_outer_attr_style(&**expr, false));\n+                try!(self.print_expr_outer_attr_style(&expr, false));\n                 try!(self.maybe_print_trailing_comment(expr.span, Some(blk.span.hi)));\n             }\n             _ => ()\n@@ -1709,30 +1709,30 @@ impl<'a> State<'a> {\n                         try!(self.cbox(INDENT_UNIT - 1));\n                         try!(self.ibox(0));\n                         try!(word(&mut self.s, \" else if \"));\n-                        try!(self.print_expr(&**i));\n+                        try!(self.print_expr(&i));\n                         try!(space(&mut self.s));\n-                        try!(self.print_block(&**then));\n+                        try!(self.print_block(&then));\n                         self.print_else(e.as_ref().map(|e| &**e))\n                     }\n                     // \"another else-if-let\"\n                     ast::ExprKind::IfLet(ref pat, ref expr, ref then, ref e) => {\n                         try!(self.cbox(INDENT_UNIT - 1));\n                         try!(self.ibox(0));\n                         try!(word(&mut self.s, \" else if let \"));\n-                        try!(self.print_pat(&**pat));\n+                        try!(self.print_pat(&pat));\n                         try!(space(&mut self.s));\n                         try!(self.word_space(\"=\"));\n-                        try!(self.print_expr(&**expr));\n+                        try!(self.print_expr(&expr));\n                         try!(space(&mut self.s));\n-                        try!(self.print_block(&**then));\n+                        try!(self.print_block(&then));\n                         self.print_else(e.as_ref().map(|e| &**e))\n                     }\n                     // \"final else\"\n                     ast::ExprKind::Block(ref b) => {\n                         try!(self.cbox(INDENT_UNIT - 1));\n                         try!(self.ibox(0));\n                         try!(word(&mut self.s, \" else \"));\n-                        self.print_block(&**b)\n+                        self.print_block(&b)\n                     }\n                     // BLEAH, constraints would be great here\n                     _ => {\n@@ -1867,7 +1867,7 @@ impl<'a> State<'a> {\n                 try!(s.ibox(INDENT_UNIT));\n                 try!(s.print_ident(field.ident.node));\n                 try!(s.word_space(\":\"));\n-                try!(s.print_expr(&*field.expr));\n+                try!(s.print_expr(&field.expr));\n                 s.end()\n             },\n             |f| f.span));\n@@ -1879,7 +1879,7 @@ impl<'a> State<'a> {\n                     try!(space(&mut self.s));\n                 }\n                 try!(word(&mut self.s, \"..\"));\n-                try!(self.print_expr(&**expr));\n+                try!(self.print_expr(&expr));\n                 try!(self.end());\n             }\n             _ => if !fields.is_empty() {\n@@ -1913,13 +1913,13 @@ impl<'a> State<'a> {\n                               tys: &[P<ast::Ty>],\n                               args: &[P<ast::Expr>]) -> io::Result<()> {\n         let base_args = &args[1..];\n-        try!(self.print_expr(&*args[0]));\n+        try!(self.print_expr(&args[0]));\n         try!(word(&mut self.s, \".\"));\n         try!(self.print_ident(ident.node));\n         if !tys.is_empty() {\n             try!(word(&mut self.s, \"::<\"));\n             try!(self.commasep(Inconsistent, tys,\n-                               |s, ty| s.print_type(&**ty)));\n+                               |s, ty| s.print_type(&ty)));\n             try!(word(&mut self.s, \">\"));\n         }\n         self.print_call_post(base_args)\n@@ -1988,7 +1988,7 @@ impl<'a> State<'a> {\n                 try!(self.print_expr_vec(&exprs[..], attrs));\n             }\n             ast::ExprKind::Repeat(ref element, ref count) => {\n-                try!(self.print_expr_repeat(&**element, &**count, attrs));\n+                try!(self.print_expr_repeat(&element, &count, attrs));\n             }\n             ast::ExprKind::Struct(ref path, ref fields, ref wth) => {\n                 try!(self.print_expr_struct(path, &fields[..], wth, attrs));\n@@ -1997,79 +1997,79 @@ impl<'a> State<'a> {\n                 try!(self.print_expr_tup(&exprs[..], attrs));\n             }\n             ast::ExprKind::Call(ref func, ref args) => {\n-                try!(self.print_expr_call(&**func, &args[..]));\n+                try!(self.print_expr_call(&func, &args[..]));\n             }\n             ast::ExprKind::MethodCall(ident, ref tys, ref args) => {\n                 try!(self.print_expr_method_call(ident, &tys[..], &args[..]));\n             }\n             ast::ExprKind::Binary(op, ref lhs, ref rhs) => {\n-                try!(self.print_expr_binary(op, &**lhs, &**rhs));\n+                try!(self.print_expr_binary(op, &lhs, &rhs));\n             }\n             ast::ExprKind::Unary(op, ref expr) => {\n-                try!(self.print_expr_unary(op, &**expr));\n+                try!(self.print_expr_unary(op, &expr));\n             }\n             ast::ExprKind::AddrOf(m, ref expr) => {\n-                try!(self.print_expr_addr_of(m, &**expr));\n+                try!(self.print_expr_addr_of(m, &expr));\n             }\n             ast::ExprKind::Lit(ref lit) => {\n-                try!(self.print_literal(&**lit));\n+                try!(self.print_literal(&lit));\n             }\n             ast::ExprKind::Cast(ref expr, ref ty) => {\n                 if let ast::ExprKind::Cast(..) = expr.node {\n-                    try!(self.print_expr(&**expr));\n+                    try!(self.print_expr(&expr));\n                 } else {\n-                    try!(self.print_expr_maybe_paren(&**expr));\n+                    try!(self.print_expr_maybe_paren(&expr));\n                 }\n                 try!(space(&mut self.s));\n                 try!(self.word_space(\"as\"));\n-                try!(self.print_type(&**ty));\n+                try!(self.print_type(&ty));\n             }\n             ast::ExprKind::Type(ref expr, ref ty) => {\n-                try!(self.print_expr(&**expr));\n+                try!(self.print_expr(&expr));\n                 try!(self.word_space(\":\"));\n-                try!(self.print_type(&**ty));\n+                try!(self.print_type(&ty));\n             }\n             ast::ExprKind::If(ref test, ref blk, ref elseopt) => {\n-                try!(self.print_if(&**test, &**blk, elseopt.as_ref().map(|e| &**e)));\n+                try!(self.print_if(&test, &blk, elseopt.as_ref().map(|e| &**e)));\n             }\n             ast::ExprKind::IfLet(ref pat, ref expr, ref blk, ref elseopt) => {\n-                try!(self.print_if_let(&**pat, &**expr, &** blk, elseopt.as_ref().map(|e| &**e)));\n+                try!(self.print_if_let(&pat, &expr, &blk, elseopt.as_ref().map(|e| &**e)));\n             }\n             ast::ExprKind::While(ref test, ref blk, opt_ident) => {\n                 if let Some(ident) = opt_ident {\n                     try!(self.print_ident(ident));\n                     try!(self.word_space(\":\"));\n                 }\n                 try!(self.head(\"while\"));\n-                try!(self.print_expr(&**test));\n+                try!(self.print_expr(&test));\n                 try!(space(&mut self.s));\n-                try!(self.print_block_with_attrs(&**blk, attrs));\n+                try!(self.print_block_with_attrs(&blk, attrs));\n             }\n             ast::ExprKind::WhileLet(ref pat, ref expr, ref blk, opt_ident) => {\n                 if let Some(ident) = opt_ident {\n                     try!(self.print_ident(ident));\n                     try!(self.word_space(\":\"));\n                 }\n                 try!(self.head(\"while let\"));\n-                try!(self.print_pat(&**pat));\n+                try!(self.print_pat(&pat));\n                 try!(space(&mut self.s));\n                 try!(self.word_space(\"=\"));\n-                try!(self.print_expr(&**expr));\n+                try!(self.print_expr(&expr));\n                 try!(space(&mut self.s));\n-                try!(self.print_block_with_attrs(&**blk, attrs));\n+                try!(self.print_block_with_attrs(&blk, attrs));\n             }\n             ast::ExprKind::ForLoop(ref pat, ref iter, ref blk, opt_ident) => {\n                 if let Some(ident) = opt_ident {\n                     try!(self.print_ident(ident));\n                     try!(self.word_space(\":\"));\n                 }\n                 try!(self.head(\"for\"));\n-                try!(self.print_pat(&**pat));\n+                try!(self.print_pat(&pat));\n                 try!(space(&mut self.s));\n                 try!(self.word_space(\"in\"));\n-                try!(self.print_expr(&**iter));\n+                try!(self.print_expr(&iter));\n                 try!(space(&mut self.s));\n-                try!(self.print_block_with_attrs(&**blk, attrs));\n+                try!(self.print_block_with_attrs(&blk, attrs));\n             }\n             ast::ExprKind::Loop(ref blk, opt_ident) => {\n                 if let Some(ident) = opt_ident {\n@@ -2078,13 +2078,13 @@ impl<'a> State<'a> {\n                 }\n                 try!(self.head(\"loop\"));\n                 try!(space(&mut self.s));\n-                try!(self.print_block_with_attrs(&**blk, attrs));\n+                try!(self.print_block_with_attrs(&blk, attrs));\n             }\n             ast::ExprKind::Match(ref expr, ref arms) => {\n                 try!(self.cbox(INDENT_UNIT));\n                 try!(self.ibox(4));\n                 try!(self.word_nbsp(\"match\"));\n-                try!(self.print_expr(&**expr));\n+                try!(self.print_expr(&expr));\n                 try!(space(&mut self.s));\n                 try!(self.bopen());\n                 try!(self.print_inner_attributes_no_trailing_hardbreak(attrs));\n@@ -2096,7 +2096,7 @@ impl<'a> State<'a> {\n             ast::ExprKind::Closure(capture_clause, ref decl, ref body) => {\n                 try!(self.print_capture_clause(capture_clause));\n \n-                try!(self.print_fn_block_args(&**decl));\n+                try!(self.print_fn_block_args(&decl));\n                 try!(space(&mut self.s));\n \n                 let default_return = match decl.output {\n@@ -2105,19 +2105,19 @@ impl<'a> State<'a> {\n                 };\n \n                 if !default_return || !body.stmts.is_empty() || body.expr.is_none() {\n-                    try!(self.print_block_unclosed(&**body));\n+                    try!(self.print_block_unclosed(&body));\n                 } else {\n                     // we extract the block, so as not to create another set of boxes\n                     let i_expr = body.expr.as_ref().unwrap();\n                     match i_expr.node {\n                         ast::ExprKind::Block(ref blk) => {\n                             try!(self.print_block_unclosed_with_attrs(\n-                                &**blk,\n+                                &blk,\n                                 i_expr.attrs.as_attr_slice()));\n                         }\n                         _ => {\n                             // this is a bare expression\n-                            try!(self.print_expr(&**i_expr));\n+                            try!(self.print_expr(&i_expr));\n                             try!(self.end()); // need to close a box\n                         }\n                     }\n@@ -2132,44 +2132,44 @@ impl<'a> State<'a> {\n                 try!(self.cbox(INDENT_UNIT));\n                 // head-box, will be closed by print-block after {\n                 try!(self.ibox(0));\n-                try!(self.print_block_with_attrs(&**blk, attrs));\n+                try!(self.print_block_with_attrs(&blk, attrs));\n             }\n             ast::ExprKind::Assign(ref lhs, ref rhs) => {\n-                try!(self.print_expr(&**lhs));\n+                try!(self.print_expr(&lhs));\n                 try!(space(&mut self.s));\n                 try!(self.word_space(\"=\"));\n-                try!(self.print_expr(&**rhs));\n+                try!(self.print_expr(&rhs));\n             }\n             ast::ExprKind::AssignOp(op, ref lhs, ref rhs) => {\n-                try!(self.print_expr(&**lhs));\n+                try!(self.print_expr(&lhs));\n                 try!(space(&mut self.s));\n                 try!(word(&mut self.s, op.node.to_string()));\n                 try!(self.word_space(\"=\"));\n-                try!(self.print_expr(&**rhs));\n+                try!(self.print_expr(&rhs));\n             }\n             ast::ExprKind::Field(ref expr, id) => {\n-                try!(self.print_expr(&**expr));\n+                try!(self.print_expr(&expr));\n                 try!(word(&mut self.s, \".\"));\n                 try!(self.print_ident(id.node));\n             }\n             ast::ExprKind::TupField(ref expr, id) => {\n-                try!(self.print_expr(&**expr));\n+                try!(self.print_expr(&expr));\n                 try!(word(&mut self.s, \".\"));\n                 try!(self.print_usize(id.node));\n             }\n             ast::ExprKind::Index(ref expr, ref index) => {\n-                try!(self.print_expr(&**expr));\n+                try!(self.print_expr(&expr));\n                 try!(word(&mut self.s, \"[\"));\n-                try!(self.print_expr(&**index));\n+                try!(self.print_expr(&index));\n                 try!(word(&mut self.s, \"]\"));\n             }\n             ast::ExprKind::Range(ref start, ref end) => {\n                 if let &Some(ref e) = start {\n-                    try!(self.print_expr(&**e));\n+                    try!(self.print_expr(&e));\n                 }\n                 try!(word(&mut self.s, \"..\"));\n                 if let &Some(ref e) = end {\n-                    try!(self.print_expr(&**e));\n+                    try!(self.print_expr(&e));\n                 }\n             }\n             ast::ExprKind::Path(None, ref path) => {\n@@ -2199,7 +2199,7 @@ impl<'a> State<'a> {\n                 match *result {\n                     Some(ref expr) => {\n                         try!(word(&mut self.s, \" \"));\n-                        try!(self.print_expr(&**expr));\n+                        try!(self.print_expr(&expr));\n                     }\n                     _ => ()\n                 }\n@@ -2220,7 +2220,7 @@ impl<'a> State<'a> {\n                         _ => try!(s.print_string(&out.constraint, ast::StrStyle::Cooked))\n                     }\n                     try!(s.popen());\n-                    try!(s.print_expr(&*out.expr));\n+                    try!(s.print_expr(&out.expr));\n                     try!(s.pclose());\n                     Ok(())\n                 }));\n@@ -2231,7 +2231,7 @@ impl<'a> State<'a> {\n                                    |s, &(ref co, ref o)| {\n                     try!(s.print_string(&co, ast::StrStyle::Cooked));\n                     try!(s.popen());\n-                    try!(s.print_expr(&**o));\n+                    try!(s.print_expr(&o));\n                     try!(s.pclose());\n                     Ok(())\n                 }));\n@@ -2258,7 +2258,7 @@ impl<'a> State<'a> {\n                 if !options.is_empty() {\n                     try!(space(&mut self.s));\n                     try!(self.word_space(\":\"));\n-                    try!(self.commasep(Inconsistent, &*options,\n+                    try!(self.commasep(Inconsistent, &options,\n                                        |s, &co| {\n                         try!(s.print_string(co, ast::StrStyle::Cooked));\n                         Ok(())\n@@ -2271,7 +2271,7 @@ impl<'a> State<'a> {\n             ast::ExprKind::Paren(ref e) => {\n                 try!(self.popen());\n                 try!(self.print_inner_attributes_inline(attrs));\n-                try!(self.print_expr(&**e));\n+                try!(self.print_expr(&e));\n                 try!(self.pclose());\n             }\n         }\n@@ -2280,10 +2280,10 @@ impl<'a> State<'a> {\n     }\n \n     pub fn print_local_decl(&mut self, loc: &ast::Local) -> io::Result<()> {\n-        try!(self.print_pat(&*loc.pat));\n+        try!(self.print_pat(&loc.pat));\n         if let Some(ref ty) = loc.ty {\n             try!(self.word_space(\":\"));\n-            try!(self.print_type(&**ty));\n+            try!(self.print_type(&ty));\n         }\n         Ok(())\n     }\n@@ -2298,16 +2298,16 @@ impl<'a> State<'a> {\n                 try!(self.word_nbsp(\"let\"));\n \n                 try!(self.ibox(INDENT_UNIT));\n-                try!(self.print_local_decl(&**loc));\n+                try!(self.print_local_decl(&loc));\n                 try!(self.end());\n                 if let Some(ref init) = loc.init {\n                     try!(self.nbsp());\n                     try!(self.word_space(\"=\"));\n-                    try!(self.print_expr(&**init));\n+                    try!(self.print_expr(&init));\n                 }\n                 self.end()\n             }\n-            ast::DeclKind::Item(ref item) => self.print_item(&**item)\n+            ast::DeclKind::Item(ref item) => self.print_item(&item)\n         }\n     }\n \n@@ -2411,7 +2411,7 @@ impl<'a> State<'a> {\n                     try!(self.commasep(\n                         Inconsistent,\n                         &data.types,\n-                        |s, ty| s.print_type(&**ty)));\n+                        |s, ty| s.print_type(&ty)));\n                         comma = true;\n                 }\n \n@@ -2422,7 +2422,7 @@ impl<'a> State<'a> {\n                     try!(self.print_ident(binding.ident));\n                     try!(space(&mut self.s));\n                     try!(self.word_space(\"=\"));\n-                    try!(self.print_type(&*binding.ty));\n+                    try!(self.print_type(&binding.ty));\n                     comma = true;\n                 }\n \n@@ -2434,15 +2434,15 @@ impl<'a> State<'a> {\n                 try!(self.commasep(\n                     Inconsistent,\n                     &data.inputs,\n-                    |s, ty| s.print_type(&**ty)));\n+                    |s, ty| s.print_type(&ty)));\n                 try!(word(&mut self.s, \")\"));\n \n                 match data.output {\n                     None => { }\n                     Some(ref ty) => {\n                         try!(self.space_if_not_bol());\n                         try!(self.word_space(\"->\"));\n-                        try!(self.print_type(&**ty));\n+                        try!(self.print_type(&ty));\n                     }\n                 }\n             }\n@@ -2473,7 +2473,7 @@ impl<'a> State<'a> {\n                 match *sub {\n                     Some(ref p) => {\n                         try!(word(&mut self.s, \"@\"));\n-                        try!(self.print_pat(&**p));\n+                        try!(self.print_pat(&p));\n                     }\n                     None => ()\n                 }\n@@ -2486,7 +2486,7 @@ impl<'a> State<'a> {\n                         if !args.is_empty() {\n                             try!(self.popen());\n                             try!(self.commasep(Inconsistent, &args[..],\n-                                              |s, p| s.print_pat(&**p)));\n+                                              |s, p| s.print_pat(&p)));\n                             try!(self.pclose());\n                         }\n                     }\n@@ -2507,7 +2507,7 @@ impl<'a> State<'a> {\n                             try!(s.print_ident(f.node.ident));\n                             try!(s.word_nbsp(\":\"));\n                         }\n-                        try!(s.print_pat(&*f.node.pat));\n+                        try!(s.print_pat(&f.node.pat));\n                         s.end()\n                     },\n                     |f| f.node.pat.span));\n@@ -2522,46 +2522,46 @@ impl<'a> State<'a> {\n                 try!(self.popen());\n                 try!(self.commasep(Inconsistent,\n                                    &elts[..],\n-                                   |s, p| s.print_pat(&**p)));\n+                                   |s, p| s.print_pat(&p)));\n                 if elts.len() == 1 {\n                     try!(word(&mut self.s, \",\"));\n                 }\n                 try!(self.pclose());\n             }\n             ast::PatBox(ref inner) => {\n                 try!(word(&mut self.s, \"box \"));\n-                try!(self.print_pat(&**inner));\n+                try!(self.print_pat(&inner));\n             }\n             ast::PatRegion(ref inner, mutbl) => {\n                 try!(word(&mut self.s, \"&\"));\n                 if mutbl == ast::Mutability::Mutable {\n                     try!(word(&mut self.s, \"mut \"));\n                 }\n-                try!(self.print_pat(&**inner));\n+                try!(self.print_pat(&inner));\n             }\n-            ast::PatLit(ref e) => try!(self.print_expr(&**e)),\n+            ast::PatLit(ref e) => try!(self.print_expr(&e)),\n             ast::PatRange(ref begin, ref end) => {\n-                try!(self.print_expr(&**begin));\n+                try!(self.print_expr(&begin));\n                 try!(space(&mut self.s));\n                 try!(word(&mut self.s, \"...\"));\n-                try!(self.print_expr(&**end));\n+                try!(self.print_expr(&end));\n             }\n             ast::PatVec(ref before, ref slice, ref after) => {\n                 try!(word(&mut self.s, \"[\"));\n                 try!(self.commasep(Inconsistent,\n                                    &before[..],\n-                                   |s, p| s.print_pat(&**p)));\n+                                   |s, p| s.print_pat(&p)));\n                 if let Some(ref p) = *slice {\n                     if !before.is_empty() { try!(self.word_space(\",\")); }\n                     if p.node != ast::PatWild {\n-                        try!(self.print_pat(&**p));\n+                        try!(self.print_pat(&p));\n                     }\n                     try!(word(&mut self.s, \"..\"));\n                     if !after.is_empty() { try!(self.word_space(\",\")); }\n                 }\n                 try!(self.commasep(Inconsistent,\n                                    &after[..],\n-                                   |s, p| s.print_pat(&**p)));\n+                                   |s, p| s.print_pat(&p)));\n                 try!(word(&mut self.s, \"]\"));\n             }\n             ast::PatMac(ref m) => try!(self.print_mac(m, token::Paren)),\n@@ -2586,20 +2586,20 @@ impl<'a> State<'a> {\n                 try!(space(&mut self.s));\n                 try!(self.word_space(\"|\"));\n             }\n-            try!(self.print_pat(&**p));\n+            try!(self.print_pat(&p));\n         }\n         try!(space(&mut self.s));\n         if let Some(ref e) = arm.guard {\n             try!(self.word_space(\"if\"));\n-            try!(self.print_expr(&**e));\n+            try!(self.print_expr(&e));\n             try!(space(&mut self.s));\n         }\n         try!(self.word_space(\"=>\"));\n \n         match arm.body.node {\n             ast::ExprKind::Block(ref blk) => {\n                 // the block will close the pattern's ibox\n-                try!(self.print_block_unclosed_indent(&**blk, INDENT_UNIT));\n+                try!(self.print_block_unclosed_indent(&blk, INDENT_UNIT));\n \n                 // If it is a user-provided unsafe block, print a comma after it\n                 if let BlockCheckMode::Unsafe(ast::UserProvided) = blk.rules {\n@@ -2608,7 +2608,7 @@ impl<'a> State<'a> {\n             }\n             _ => {\n                 try!(self.end()); // close the ibox for the pattern\n-                try!(self.print_expr(&*arm.body));\n+                try!(self.print_expr(&arm.body));\n                 try!(word(&mut self.s, \",\"));\n             }\n         }\n@@ -2634,7 +2634,7 @@ impl<'a> State<'a> {\n             ast::SelfKind::Explicit(ref typ, _) => {\n                 try!(word(&mut self.s, \"self\"));\n                 try!(self.word_space(\":\"));\n-                try!(self.print_type(&**typ));\n+                try!(self.print_type(&typ));\n             }\n         }\n         return Ok(true);\n@@ -2722,7 +2722,7 @@ impl<'a> State<'a> {\n         try!(self.word_space(\"->\"));\n         match decl.output {\n             ast::FunctionRetTy::Ty(ref ty) => {\n-                try!(self.print_type(&**ty));\n+                try!(self.print_type(&ty));\n                 self.maybe_print_comment(ty.span.lo)\n             }\n             ast::FunctionRetTy::Default(..) => unreachable!(),\n@@ -2834,7 +2834,7 @@ impl<'a> State<'a> {\n             Some(ref default) => {\n                 try!(space(&mut self.s));\n                 try!(self.word_space(\"=\"));\n-                self.print_type(&**default)\n+                self.print_type(&default)\n             }\n             _ => Ok(())\n         }\n@@ -2860,7 +2860,7 @@ impl<'a> State<'a> {\n                                                                              ref bounds,\n                                                                              ..}) => {\n                     try!(self.print_formal_lifetime_list(bound_lifetimes));\n-                    try!(self.print_type(&**bounded_ty));\n+                    try!(self.print_type(&bounded_ty));\n                     try!(self.print_bounds(\":\", bounds));\n                 }\n                 ast::WherePredicate::RegionPredicate(ast::WhereRegionPredicate{ref lifetime,\n@@ -2881,7 +2881,7 @@ impl<'a> State<'a> {\n                     try!(self.print_path(path, false, 0));\n                     try!(space(&mut self.s));\n                     try!(self.word_space(\"=\"));\n-                    try!(self.print_type(&**ty));\n+                    try!(self.print_type(&ty));\n                 }\n             }\n         }\n@@ -2953,13 +2953,13 @@ impl<'a> State<'a> {\n \n     pub fn print_mt(&mut self, mt: &ast::MutTy) -> io::Result<()> {\n         try!(self.print_mutability(mt.mutbl));\n-        self.print_type(&*mt.ty)\n+        self.print_type(&mt.ty)\n     }\n \n     pub fn print_arg(&mut self, input: &ast::Arg, is_closure: bool) -> io::Result<()> {\n         try!(self.ibox(INDENT_UNIT));\n         match input.ty.node {\n-            ast::TyKind::Infer if is_closure => try!(self.print_pat(&*input.pat)),\n+            ast::TyKind::Infer if is_closure => try!(self.print_pat(&input.pat)),\n             _ => {\n                 match input.pat.node {\n                     ast::PatIdent(_, ref path1, _) if\n@@ -2968,12 +2968,12 @@ impl<'a> State<'a> {\n                         // Do nothing.\n                     }\n                     _ => {\n-                        try!(self.print_pat(&*input.pat));\n+                        try!(self.print_pat(&input.pat));\n                         try!(word(&mut self.s, \":\"));\n                         try!(space(&mut self.s));\n                     }\n                 }\n-                try!(self.print_type(&*input.ty));\n+                try!(self.print_type(&input.ty));\n             }\n         }\n         self.end()\n@@ -2992,7 +2992,7 @@ impl<'a> State<'a> {\n                 try!(self.word_nbsp(\"!\")),\n             ast::FunctionRetTy::Default(..) => unreachable!(),\n             ast::FunctionRetTy::Ty(ref ty) =>\n-                try!(self.print_type(&**ty))\n+                try!(self.print_type(&ty))\n         }\n         try!(self.end());\n "}, {"sha": "fda9741d35c419285d9ea0961721a2c96983a6c9", "filename": "src/libsyntax/ptr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3548b8c273d9feb0291e97a928c4f48e01daf0f9/src%2Flibsyntax%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3548b8c273d9feb0291e97a928c4f48e01daf0f9/src%2Flibsyntax%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fptr.rs?ref=3548b8c273d9feb0291e97a928c4f48e01daf0f9", "patch": "@@ -87,7 +87,7 @@ impl<T> Deref for P<T> {\n     type Target = T;\n \n     fn deref<'a>(&'a self) -> &'a T {\n-        &*self.ptr\n+        &self.ptr\n     }\n }\n \n@@ -153,7 +153,7 @@ impl<T> P<[T]> {\n     }\n \n     pub fn as_slice<'a>(&'a self) -> &'a [T] {\n-        &*self.ptr\n+        &self.ptr\n     }\n \n     pub fn move_iter(self) -> vec::IntoIter<T> {"}, {"sha": "81b702e794d7737ef08f3652c231ba6f174e577c", "filename": "src/libsyntax/test.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3548b8c273d9feb0291e97a928c4f48e01daf0f9/src%2Flibsyntax%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3548b8c273d9feb0291e97a928c4f48e01daf0f9/src%2Flibsyntax%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftest.rs?ref=3548b8c273d9feb0291e97a928c4f48e01daf0f9", "patch": "@@ -123,7 +123,7 @@ impl<'a> fold::Folder for TestHarnessGenerator<'a> {\n         debug!(\"current path: {}\",\n                ast_util::path_name_i(&self.cx.path));\n \n-        let i = if is_test_fn(&self.cx, &*i) || is_bench_fn(&self.cx, &*i) {\n+        let i = if is_test_fn(&self.cx, &i) || is_bench_fn(&self.cx, &i) {\n             match i.node {\n                 ast::ItemKind::Fn(_, ast::Unsafety::Unsafe, _, _, _, _) => {\n                     let diag = self.cx.span_diagnostic;\n@@ -134,9 +134,9 @@ impl<'a> fold::Folder for TestHarnessGenerator<'a> {\n                     let test = Test {\n                         span: i.span,\n                         path: self.cx.path.clone(),\n-                        bench: is_bench_fn(&self.cx, &*i),\n-                        ignore: is_ignored(&*i),\n-                        should_panic: should_panic(&*i)\n+                        bench: is_bench_fn(&self.cx, &i),\n+                        ignore: is_ignored(&i),\n+                        should_panic: should_panic(&i)\n                     };\n                     self.cx.testfns.push(test);\n                     self.tests.push(i.ident);\n@@ -205,7 +205,7 @@ impl fold::Folder for EntryPointCleaner {\n         // Remove any #[main] or #[start] from the AST so it doesn't\n         // clash with the one we're going to add, but mark it as\n         // #[allow(dead_code)] to avoid printing warnings.\n-        let folded = match entry::entry_point_type(&*folded, self.depth) {\n+        let folded = match entry::entry_point_type(&folded, self.depth) {\n             EntryPointType::MainNamed |\n             EntryPointType::MainAttr |\n             EntryPointType::Start =>\n@@ -556,7 +556,7 @@ fn mk_test_module(cx: &mut TestCtxt) -> (P<ast::Item>, Option<P<ast::Item>>) {\n         })\n     });\n \n-    debug!(\"Synthetic test module:\\n{}\\n\", pprust::item_to_string(&*item));\n+    debug!(\"Synthetic test module:\\n{}\\n\", pprust::item_to_string(&item));\n \n     (item, reexport)\n }"}, {"sha": "6088fdf940ac1c689722869667ea1709c45943c6", "filename": "src/libsyntax_ext/deriving/generic/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3548b8c273d9feb0291e97a928c4f48e01daf0f9/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3548b8c273d9feb0291e97a928c4f48e01daf0f9/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs?ref=3548b8c273d9feb0291e97a928c4f48e01daf0f9", "patch": "@@ -553,7 +553,7 @@ impl<'a> TraitDef<'a> {\n \n             let mut processed_field_types = HashSet::new();\n             for field_ty in field_tys {\n-                let tys = find_type_parameters(&*field_ty, &ty_param_names);\n+                let tys = find_type_parameters(&field_ty, &ty_param_names);\n \n                 for ty in tys {\n                     // if we have already handled this type, skip it\n@@ -617,7 +617,7 @@ impl<'a> TraitDef<'a> {\n         // Just mark it now since we know that it'll end up used downstream\n         attr::mark_used(&attr);\n         let opt_trait_ref = Some(trait_ref);\n-        let ident = ast_util::impl_pretty_name(&opt_trait_ref, Some(&*self_type));\n+        let ident = ast_util::impl_pretty_name(&opt_trait_ref, Some(&self_type));\n         let unused_qual = cx.attribute(\n             self.span,\n             cx.meta_list(self.span,"}]}