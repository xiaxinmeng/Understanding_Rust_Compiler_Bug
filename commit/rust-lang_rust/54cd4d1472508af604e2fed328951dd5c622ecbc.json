{"sha": "54cd4d1472508af604e2fed328951dd5c622ecbc", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU0Y2Q0ZDE0NzI1MDhhZjYwNGUyZmVkMzI4OTUxZGQ1YzYyMmVjYmM=", "commit": {"author": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-03-09T04:21:54Z"}, "committer": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-03-25T22:22:15Z"}, "message": "Add and use `resolve_name_in_lexical_scope` and\nexclude the prelude from `resolve_name(.., allow_private_imports = true)`.", "tree": {"sha": "110d71a5c7068b53325a14311cf469b722738e4a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/110d71a5c7068b53325a14311cf469b722738e4a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/54cd4d1472508af604e2fed328951dd5c622ecbc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/54cd4d1472508af604e2fed328951dd5c622ecbc", "html_url": "https://github.com/rust-lang/rust/commit/54cd4d1472508af604e2fed328951dd5c622ecbc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/54cd4d1472508af604e2fed328951dd5c622ecbc/comments", "author": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "de970b1dff21f3e1913374d0794bf85511668667", "url": "https://api.github.com/repos/rust-lang/rust/commits/de970b1dff21f3e1913374d0794bf85511668667", "html_url": "https://github.com/rust-lang/rust/commit/de970b1dff21f3e1913374d0794bf85511668667"}], "stats": {"total": 27, "additions": 20, "deletions": 7}, "files": [{"sha": "77fdc657b886fa7ec55d8e4086284a01ef1a7bcc", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/54cd4d1472508af604e2fed328951dd5c622ecbc/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54cd4d1472508af604e2fed328951dd5c622ecbc/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=54cd4d1472508af604e2fed328951dd5c622ecbc", "patch": "@@ -349,7 +349,8 @@ fn resolve_struct_error<'b, 'a: 'b, 'tcx: 'a>(resolver: &'b Resolver<'a, 'tcx>,\n             if let Some(sp) = resolver.ast_map.span_if_local(did) {\n                 err.span_note(sp, \"constant defined here\");\n             }\n-            if let Success(binding) = resolver.current_module.resolve_name(name, ValueNS, true) {\n+            if let Some(binding) = resolver.current_module\n+                                           .resolve_name_in_lexical_scope(name, ValueNS) {\n                 if binding.is_import() {\n                     err.span_note(binding.span.unwrap(), \"constant imported here\");\n                 }\n@@ -1536,13 +1537,17 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                               module: Module<'a>,\n                               name: Name,\n                               namespace: Namespace,\n-                              allow_private_imports: bool,\n+                              use_lexical_scope: bool,\n                               record_used: bool)\n                               -> ResolveResult<&'a NameBinding<'a>> {\n         debug!(\"(resolving name in module) resolving `{}` in `{}`\", name, module_to_string(module));\n \n         build_reduced_graph::populate_module_if_necessary(self, module);\n-        module.resolve_name(name, namespace, allow_private_imports).and_then(|binding| {\n+        match use_lexical_scope {\n+            true => module.resolve_name_in_lexical_scope(name, namespace)\n+                          .map(Success).unwrap_or(Failed(None)),\n+            false => module.resolve_name(name, namespace, false),\n+        }.and_then(|binding| {\n             if record_used {\n                 self.record_use(name, namespace, binding);\n             }\n@@ -2961,7 +2966,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             if name_path.len() == 1 {\n                 match this.primitive_type_table.primitive_types.get(last_name) {\n                     Some(_) => None,\n-                    None => this.current_module.resolve_name(*last_name, TypeNS, true).success()\n+                    None => this.current_module.resolve_name_in_lexical_scope(*last_name, TypeNS)\n                                                .and_then(NameBinding::module)\n                 }\n             } else {\n@@ -3018,7 +3023,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n         // Look for a method in the current self type's impl module.\n         if let Some(module) = get_module(self, path.span, &name_path) {\n-            if let Success(binding) = module.resolve_name(name, ValueNS, true) {\n+            if let Some(binding) = module.resolve_name_in_lexical_scope(name, ValueNS) {\n                 if let Some(Def::Method(did)) = binding.def() {\n                     if is_static_method(self, did) {\n                         return StaticMethod(path_names_to_string(&path, 0));"}, {"sha": "3af5031cc47cc3f53ed2302dec8c1f5f423c2197", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/54cd4d1472508af604e2fed328951dd5c622ecbc/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54cd4d1472508af604e2fed328951dd5c622ecbc/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=54cd4d1472508af604e2fed328951dd5c622ecbc", "patch": "@@ -239,8 +239,16 @@ impl<'a> ::ModuleS<'a> {\n             }\n         }\n \n-        self.prelude.borrow().map(|prelude| prelude.resolve_name(name, ns, false))\n-                             .unwrap_or(Failed(None))\n+        Failed(None)\n+    }\n+\n+    // Invariant: this may not be called until import resolution is complete.\n+    pub fn resolve_name_in_lexical_scope(&self, name: Name, ns: Namespace)\n+                                         -> Option<&'a NameBinding<'a>> {\n+        self.resolutions.borrow().get(&(name, ns)).and_then(|resolution| resolution.binding)\n+            .or_else(|| self.prelude.borrow().and_then(|prelude| {\n+                prelude.resolve_name(name, ns, false).success()\n+            }))\n     }\n \n     // Define the name or return the existing binding if there is a collision."}]}