{"sha": "401b6362d7f99a3cebc863cb1b8906d62e9ba79b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQwMWI2MzYyZDdmOTlhM2NlYmM4NjNjYjFiODkwNmQ2MmU5YmE3OWI=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-07-06T00:57:34Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-07-06T22:46:03Z"}, "message": "rustc: Make meta items into interior vectors", "tree": {"sha": "9736c1e95b6d5e7d1492727f4fba5fbe4dfeb34d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9736c1e95b6d5e7d1492727f4fba5fbe4dfeb34d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/401b6362d7f99a3cebc863cb1b8906d62e9ba79b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/401b6362d7f99a3cebc863cb1b8906d62e9ba79b", "html_url": "https://github.com/rust-lang/rust/commit/401b6362d7f99a3cebc863cb1b8906d62e9ba79b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/401b6362d7f99a3cebc863cb1b8906d62e9ba79b/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "479ce4d7836c13b3e75b2d0ac48e9f534ff859e7", "url": "https://api.github.com/repos/rust-lang/rust/commits/479ce4d7836c13b3e75b2d0ac48e9f534ff859e7", "html_url": "https://github.com/rust-lang/rust/commit/479ce4d7836c13b3e75b2d0ac48e9f534ff859e7"}], "stats": {"total": 156, "additions": 90, "deletions": 66}, "files": [{"sha": "a39348fe3c86b688cc60bc076874e1b1299bbd13", "filename": "src/comp/driver/rustc.rs", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/401b6362d7f99a3cebc863cb1b8906d62e9ba79b/src%2Fcomp%2Fdriver%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/401b6362d7f99a3cebc863cb1b8906d62e9ba79b/src%2Fcomp%2Fdriver%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fdriver%2Frustc.rs?ref=401b6362d7f99a3cebc863cb1b8906d62e9ba79b", "patch": "@@ -50,13 +50,13 @@ fn default_configuration(session::session sess, str argv0, str input) ->\n \n     auto mk = attr::mk_name_value_item_str;\n \n-    ret [ // Target bindings.\n-         mk(\"target_os\", std::os::target_os()),\n-         mk(\"target_arch\", \"x86\"),\n-         mk(\"target_libc\", libc),\n-         // Build bindings.\n-         mk(\"build_compiler\", argv0),\n-         mk(\"build_input\", input)];\n+    ret ~[ // Target bindings.\n+          mk(\"target_os\", std::os::target_os()),\n+          mk(\"target_arch\", \"x86\"),\n+          mk(\"target_libc\", libc),\n+          // Build bindings.\n+          mk(\"build_compiler\", argv0),\n+          mk(\"build_input\", input)];\n }\n \n fn build_configuration(session::session sess, str argv0,\n@@ -70,10 +70,9 @@ fn build_configuration(session::session sess, str argv0,\n fn parse_cfgspecs(&vec[str] cfgspecs) -> ast::crate_cfg {\n     // FIXME: It would be nice to use the parser to parse all varieties of\n     // meta_item here. At the moment we just support the meta_word variant.\n-    fn to_meta_word(&str cfgspec) -> @ast::meta_item {\n-        attr::mk_word_item(cfgspec)\n-    }\n-    ret vec::map(to_meta_word, cfgspecs);\n+    auto words = ~[];\n+    for (str s in cfgspecs) { words += ~[attr::mk_word_item(s)]; }\n+    ret words;\n }\n \n fn parse_input(session::session sess, &ast::crate_cfg cfg, str input)"}, {"sha": "23d8db3f8cb9e92d0042c04ffaa2803b2c046ae9", "filename": "src/comp/front/attr.rs", "status": "modified", "additions": 16, "deletions": 18, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/401b6362d7f99a3cebc863cb1b8906d62e9ba79b/src%2Fcomp%2Ffront%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/401b6362d7f99a3cebc863cb1b8906d62e9ba79b/src%2Fcomp%2Ffront%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fattr.rs?ref=401b6362d7f99a3cebc863cb1b8906d62e9ba79b", "patch": "@@ -29,13 +29,11 @@ export mk_attr;\n \n // From a list of crate attributes get only the meta_items that impact crate\n // linkage\n-fn find_linkage_metas(&ast::attribute[] attrs) -> vec[@ast::meta_item] {\n-    let vec[@ast::meta_item] metas = [];\n+fn find_linkage_metas(&ast::attribute[] attrs) -> (@ast::meta_item)[] {\n+    let (@ast::meta_item)[] metas = ~[];\n     for (ast::attribute attr in find_attrs_by_name(attrs, \"link\")) {\n         alt (attr.node.value.node) {\n-            case (ast::meta_list(_, ?items)) {\n-                metas += items;\n-            }\n+            case (ast::meta_list(_, ?items)) { metas += items; }\n             case (_) {\n                 log \"ignoring link attribute that has incorrect type\";\n             }\n@@ -62,8 +60,8 @@ fn get_attr_name(&ast::attribute attr) -> ast::ident {\n     get_meta_item_name(@attr.node.value)\n }\n \n-fn find_meta_items_by_name(vec[@ast::meta_item] metas,\n-                           ast::ident name) -> vec[@ast::meta_item] {\n+fn find_meta_items_by_name(&(@ast::meta_item)[] metas,\n+                           ast::ident name) -> (@ast::meta_item)[] {\n     auto filter = bind fn(&@ast::meta_item m,\n                           ast::ident name) -> option::t[@ast::meta_item] {\n         if (get_meta_item_name(m) == name) {\n@@ -72,7 +70,7 @@ fn find_meta_items_by_name(vec[@ast::meta_item] metas,\n             option::none\n         }\n     } (_, name);\n-    ret vec::filter_map(filter, metas);\n+    ret ivec::filter_map(filter, metas);\n }\n \n fn get_meta_item_name(&@ast::meta_item meta) -> ast::ident {\n@@ -102,9 +100,9 @@ fn get_meta_item_value_str(&@ast::meta_item meta) -> option::t[str] {\n fn attr_meta(&ast::attribute attr) -> @ast::meta_item { @attr.node.value }\n \n // Get the meta_items from inside a vector of attributes\n-fn attr_metas(&ast::attribute[] attrs) -> vec[@ast::meta_item] {\n-    auto mitems = [];\n-    for (ast::attribute a in attrs) { mitems += [attr_meta(a)]; }\n+fn attr_metas(&ast::attribute[] attrs) -> (@ast::meta_item)[] {\n+    auto mitems = ~[];\n+    for (ast::attribute a in attrs) { mitems += ~[attr_meta(a)]; }\n     ret mitems;\n }\n \n@@ -133,7 +131,7 @@ fn eq(@ast::meta_item a, @ast::meta_item b) -> bool {\n     }\n }\n \n-fn contains(&vec[@ast::meta_item] haystack, @ast::meta_item needle) -> bool {\n+fn contains(&(@ast::meta_item)[] haystack, @ast::meta_item needle) -> bool {\n     log #fmt(\"looking for %s\",\n              syntax::print::pprust::meta_item_to_str(*needle));\n     for (@ast::meta_item item in haystack) {\n@@ -182,8 +180,8 @@ fn sort_meta_items(&vec[@ast::meta_item] items) -> vec[@ast::meta_item] {\n     ret v2;\n }\n \n-fn remove_meta_items_by_name(&vec[@ast::meta_item] items,\n-                             str name) -> vec[@ast::meta_item] {\n+fn remove_meta_items_by_name(&(@ast::meta_item)[] items,\n+                             str name) -> (@ast::meta_item)[] {\n \n     auto filter = bind fn(&@ast::meta_item item,\n                           str name) -> option::t[@ast::meta_item] {\n@@ -194,10 +192,10 @@ fn remove_meta_items_by_name(&vec[@ast::meta_item] items,\n         }\n     } (_, name);\n \n-    ret vec::filter_map(filter, items);\n+    ret ivec::filter_map(filter, items);\n }\n \n-fn require_unique_names(&session::session sess, &vec[@ast::meta_item] metas) {\n+fn require_unique_names(&session::session sess, &(@ast::meta_item)[] metas) {\n     auto map = map::mk_hashmap[str, ()](str::hash, str::eq);\n     for (@ast::meta_item meta in metas) {\n         auto name = get_meta_item_name(meta);\n@@ -222,8 +220,8 @@ fn mk_name_value_item(ast::ident name, ast::lit value) -> @ast::meta_item {\n     ret @span(ast::meta_name_value(name, value));\n }\n \n-fn mk_list_item(ast::ident name,\n-                &vec[@ast::meta_item] items) -> @ast::meta_item {\n+fn mk_list_item(ast::ident name, &(@ast::meta_item)[] items)\n+        -> @ast::meta_item {\n     ret @span(ast::meta_list(name, items));\n }\n "}, {"sha": "dd6c6b574f3c3921529d94b2faf1554940dc8ea8", "filename": "src/comp/front/config.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/401b6362d7f99a3cebc863cb1b8906d62e9ba79b/src%2Fcomp%2Ffront%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/401b6362d7f99a3cebc863cb1b8906d62e9ba79b/src%2Fcomp%2Ffront%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fconfig.rs?ref=401b6362d7f99a3cebc863cb1b8906d62e9ba79b", "patch": "@@ -109,9 +109,9 @@ fn in_cfg(&ast::crate_cfg cfg, &ast::attribute[] attrs) -> bool {\n     // so we can match against them. This is the list of configurations for\n     // which the item is valid\n     auto item_cfg_metas = {\n-        fn extract_metas(&vec[@ast::meta_item] inner_items,\n+        fn extract_metas(&(@ast::meta_item)[] inner_items,\n                          &@ast::meta_item cfg_item)\n-        -> vec[@ast::meta_item] {\n+        -> (@ast::meta_item)[] {\n \n             alt (cfg_item.node) {\n                 case (ast::meta_list(?name, ?items)) {\n@@ -122,13 +122,11 @@ fn in_cfg(&ast::crate_cfg cfg, &ast::attribute[] attrs) -> bool {\n             }\n         }\n         auto cfg_metas = attr::attr_metas(item_cfg_attrs);\n-        vec::foldl(extract_metas, [], cfg_metas)\n+        ivec::foldl(extract_metas, ~[], cfg_metas)\n     };\n \n     for (@ast::meta_item cfg_mi in item_cfg_metas) {\n-        if (attr::contains(cfg, cfg_mi)) {\n-            ret true;\n-        }\n+        if (attr::contains(cfg, cfg_mi)) { ret true; }\n     }\n \n     ret false;"}, {"sha": "a59ff3d7d859fac5002dd8744ee223e868dc4ce0", "filename": "src/comp/metadata/creader.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/401b6362d7f99a3cebc863cb1b8906d62e9ba79b/src%2Fcomp%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/401b6362d7f99a3cebc863cb1b8906d62e9ba79b/src%2Fcomp%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fcreader.rs?ref=401b6362d7f99a3cebc863cb1b8906d62e9ba79b", "patch": "@@ -12,6 +12,7 @@ import syntax::walk;\n import syntax::codemap::span;\n import back::x86;\n import util::common;\n+import std::ivec;\n import std::str;\n import std::vec;\n import std::ebml;\n@@ -28,12 +29,12 @@ export read_crates;\n export list_file_metadata;\n \n fn metadata_matches(&vec[u8] crate_data,\n-                    &vec[@ast::meta_item] metas) -> bool {\n+                    &(@ast::meta_item)[] metas) -> bool {\n     auto attrs = decoder::get_crate_attributes(crate_data);\n     auto linkage_metas = attr::find_linkage_metas(attrs);\n \n     log #fmt(\"matching %u metadata requirements against %u items\",\n-             vec::len(metas), vec::len(linkage_metas));\n+             ivec::len(metas), ivec::len(linkage_metas));\n \n     for (@ast::meta_item needed in metas) {\n         if (!attr::contains(linkage_metas, needed)) {\n@@ -54,15 +55,15 @@ fn default_native_lib_naming(session::session sess) ->\n }\n \n fn find_library_crate(&session::session sess, &ast::ident ident,\n-                      &vec[@ast::meta_item] metas,\n+                      &(@ast::meta_item)[] metas,\n                       &vec[str] library_search_paths) ->\n    option::t[tup(str, vec[u8])] {\n \n     attr::require_unique_names(sess, metas);\n \n     auto crate_name = {\n         auto name_items = attr::find_meta_items_by_name(metas, \"name\");\n-        alt (vec::last(name_items)) {\n+        alt (ivec::last(name_items)) {\n             case (some(?i)) {\n                 alt (attr::get_meta_item_value_str(i)) {\n                     case (some(?n)) { n }\n@@ -133,7 +134,7 @@ fn get_metadata_section(str filename) -> option::t[vec[u8]] {\n }\n \n fn load_library_crate(&session::session sess, span span, int cnum,\n-                      &ast::ident ident, vec[@ast::meta_item] metas,\n+                      &ast::ident ident, &(@ast::meta_item)[] metas,\n                       &vec[str] library_search_paths) {\n     alt (find_library_crate(sess, ident, metas, library_search_paths)) {\n         case (some(?t)) {"}, {"sha": "558aacce81aa9d061454ea8e95a197ee249119c6", "filename": "src/comp/metadata/decoder.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/401b6362d7f99a3cebc863cb1b8906d62e9ba79b/src%2Fcomp%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/401b6362d7f99a3cebc863cb1b8906d62e9ba79b/src%2Fcomp%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fdecoder.rs?ref=401b6362d7f99a3cebc863cb1b8906d62e9ba79b", "patch": "@@ -1,6 +1,7 @@\n // Metadata decoding\n \n import std::ebml;\n+import std::ivec;\n import std::option;\n import std::vec;\n import std::str;\n@@ -262,13 +263,13 @@ fn item_kind_to_str(u8 kind) -> str {\n     }\n }\n \n-fn get_meta_items(&ebml::doc md) -> vec[@ast::meta_item] {\n-    let vec[@ast::meta_item] items = [];\n+fn get_meta_items(&ebml::doc md) -> (@ast::meta_item)[] {\n+    let (@ast::meta_item)[] items = ~[];\n     for each (ebml::doc meta_item_doc in\n               ebml::tagged_docs(md, tag_meta_item_word)) {\n         auto nd = ebml::get_doc(meta_item_doc, tag_meta_item_name);\n         auto n = str::unsafe_from_bytes(ebml::doc_data(nd));\n-        items += [attr::mk_word_item(n)];\n+        items += ~[attr::mk_word_item(n)];\n     }\n     for each (ebml::doc meta_item_doc in\n               ebml::tagged_docs(md, tag_meta_item_name_value)) {\n@@ -278,14 +279,14 @@ fn get_meta_items(&ebml::doc md) -> vec[@ast::meta_item] {\n         auto v = str::unsafe_from_bytes(ebml::doc_data(vd));\n         // FIXME (#611): Should be able to decode meta_name_value variants,\n         // but currently they can't be encoded\n-        items += [attr::mk_name_value_item_str(n, v)];\n+        items += ~[attr::mk_name_value_item_str(n, v)];\n     }\n     for each (ebml::doc meta_item_doc in\n               ebml::tagged_docs(md, tag_meta_item_list)) {\n         auto nd = ebml::get_doc(meta_item_doc, tag_meta_item_name);\n         auto n = str::unsafe_from_bytes(ebml::doc_data(nd));\n         auto subitems = get_meta_items(meta_item_doc);\n-        items += [attr::mk_list_item(n, subitems)];\n+        items += ~[attr::mk_list_item(n, subitems)];\n     }\n     ret items;\n }\n@@ -299,7 +300,7 @@ fn get_attributes(&ebml::doc md) -> ast::attribute[] {\n                 auto meta_items = get_meta_items(attr_doc);\n                 // Currently it's only possible to have a single meta item on\n                 // an attribute\n-                assert (vec::len(meta_items) == 1u);\n+                assert (ivec::len(meta_items) == 1u);\n                 auto meta_item = meta_items.(0);\n                 attrs += ~[rec(node=rec(style=ast::attr_outer,\n                                         value=*meta_item),"}, {"sha": "148fb12a13b3d656a851ac36892878b767945a3a", "filename": "src/comp/metadata/encoder.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/401b6362d7f99a3cebc863cb1b8906d62e9ba79b/src%2Fcomp%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/401b6362d7f99a3cebc863cb1b8906d62e9ba79b/src%2Fcomp%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fencoder.rs?ref=401b6362d7f99a3cebc863cb1b8906d62e9ba79b", "patch": "@@ -473,9 +473,8 @@ fn encode_attributes(&ebml::writer ebml_w, &vec[attribute] attrs) {\n fn synthesize_crate_attrs(&@crate_ctxt cx,\n                           &@crate crate) -> vec[attribute] {\n \n-    fn synthesize_link_attr(&@crate_ctxt cx,\n-                            &vec[@meta_item] items)\n-        -> attribute {\n+    fn synthesize_link_attr(&@crate_ctxt cx, &(@meta_item)[] items)\n+            -> attribute {\n \n         assert cx.link_meta.name != \"\";\n         assert cx.link_meta.vers != \"\";\n@@ -490,7 +489,7 @@ fn synthesize_crate_attrs(&@crate_ctxt cx,\n             attr::remove_meta_items_by_name(tmp, \"vers\")\n         };\n \n-        auto meta_items = [name_item] + [vers_item] + other_items;\n+        auto meta_items = ~[name_item, vers_item] + other_items;\n         auto link_item = attr::mk_list_item(\"link\", meta_items);\n \n         ret attr::mk_attr(link_item);\n@@ -513,7 +512,7 @@ fn synthesize_crate_attrs(&@crate_ctxt cx,\n     }\n \n     if (!found_link_attr) {\n-        attrs += [synthesize_link_attr(cx, [])];\n+        attrs += [synthesize_link_attr(cx, ~[])];\n     }\n \n     ret attrs;"}, {"sha": "0258472042ec3ed44ec138c8b0377eebd6761654", "filename": "src/comp/syntax/ast.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/401b6362d7f99a3cebc863cb1b8906d62e9ba79b/src%2Fcomp%2Fsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/401b6362d7f99a3cebc863cb1b8906d62e9ba79b/src%2Fcomp%2Fsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fast.rs?ref=401b6362d7f99a3cebc863cb1b8906d62e9ba79b", "patch": "@@ -81,7 +81,7 @@ fn def_id_of_def(def d) -> def_id {\n \n // The set of meta_items that define the compilation environment of the crate,\n // used to drive conditional compilation\n-type crate_cfg = vec[@meta_item];\n+type crate_cfg = (@meta_item)[];\n \n type crate = spanned[crate_];\n \n@@ -105,7 +105,7 @@ type meta_item = spanned[meta_item_];\n \n tag meta_item_ {\n     meta_word(ident);\n-    meta_list(ident, vec[@meta_item]);\n+    meta_list(ident, (@meta_item)[]);\n     meta_name_value(ident, lit);\n }\n \n@@ -505,7 +505,7 @@ type variant = spanned[variant_];\n type view_item = spanned[view_item_];\n \n tag view_item_ {\n-    view_item_use(ident, vec[@meta_item], node_id);\n+    view_item_use(ident, (@meta_item)[], node_id);\n     view_item_import(ident, vec[ident], node_id);\n     view_item_import_glob(vec[ident], node_id);\n     view_item_export(ident, node_id);"}, {"sha": "09e46d501227f7d84d5745347b00812c1f37f72c", "filename": "src/comp/syntax/fold.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/401b6362d7f99a3cebc863cb1b8906d62e9ba79b/src%2Fcomp%2Fsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/401b6362d7f99a3cebc863cb1b8906d62e9ba79b/src%2Fcomp%2Fsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Ffold.rs?ref=401b6362d7f99a3cebc863cb1b8906d62e9ba79b", "patch": "@@ -104,7 +104,7 @@ fn fold_meta_item_(&@meta_item mi, ast_fold fld) -> @meta_item {\n                  case (meta_word(?id)) { meta_word(fld.fold_ident(id)) }\n                  case (meta_list(?id, ?mis)) {\n                      auto fold_meta_item = bind fold_meta_item_(_,fld);\n-                     meta_list(id, map(fold_meta_item, mis))\n+                     meta_list(id, ivec::map(fold_meta_item, mis))\n                  }\n                  case (meta_name_value(?id,?s)) {\n                      meta_name_value(fld.fold_ident(id),s)\n@@ -135,7 +135,7 @@ fn noop_fold_crate(&crate_ c, ast_fold fld) -> crate_ {\n     ret rec(directives=ivec::map(fld.fold_crate_directive, c.directives),\n             module=fld.fold_mod(c.module),\n             attrs=ivec::map(fold_attribute, c.attrs),\n-            config=vec::map(fold_meta_item, c.config));\n+            config=ivec::map(fold_meta_item, c.config));\n }\n \n fn noop_fold_crate_directive(&crate_directive_ cd, ast_fold fld) "}, {"sha": "8923588dba4a6a397abaca3b7aca1071191cc1ac", "filename": "src/comp/syntax/parse/parser.rs", "status": "modified", "additions": 35, "deletions": 7, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/401b6362d7f99a3cebc863cb1b8906d62e9ba79b/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/401b6362d7f99a3cebc863cb1b8906d62e9ba79b/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs?ref=401b6362d7f99a3cebc863cb1b8906d62e9ba79b", "patch": "@@ -591,6 +591,24 @@ fn parse_seq_to_end[T](token::token ket, option::t[token::token] sep,\n     ret v;\n }\n \n+fn parse_seq_to_end_ivec[T](token::token ket, option::t[token::token] sep,\n+                            fn(&parser)->T  f, &parser p) -> T[] {\n+    let bool first = true;\n+    let T[] v = ~[];\n+    while (p.peek() != ket) {\n+        alt (sep) {\n+            case (some(?t)) {\n+                if (first) { first = false; } else { expect(p, t); }\n+            }\n+            case (_) { }\n+        }\n+        v += ~[f(p)];\n+    }\n+    expect(p, ket);\n+    ret v;\n+}\n+\n+\n fn parse_seq[T](token::token bra, token::token ket,\n                 option::t[token::token] sep, fn(&parser) -> T  f, &parser p)\n    -> ast::spanned[vec[T]] {\n@@ -601,6 +619,17 @@ fn parse_seq[T](token::token bra, token::token ket,\n     ret spanned(lo, hi, result);\n }\n \n+fn parse_seq_ivec[T](token::token bra, token::token ket,\n+                     option::t[token::token] sep,\n+                     fn(&parser)->T  f, &parser p) -> ast::spanned[T[]] {\n+    auto lo = p.get_lo_pos();\n+    expect(p, bra);\n+    auto result = parse_seq_to_end_ivec[T](ket, sep, f, p);\n+    auto hi = p.get_hi_pos();\n+    ret spanned(lo, hi, result);\n+}\n+\n+\n fn parse_lit(&parser p) -> ast::lit {\n     auto sp = p.get_span();\n     let ast::lit_ lit = ast::lit_nil;\n@@ -2185,15 +2214,15 @@ fn parse_meta_item(&parser p) -> @ast::meta_item {\n     }\n }\n \n-fn parse_meta_seq(&parser p) -> vec[@ast::meta_item] {\n-    ret parse_seq(token::LPAREN, token::RPAREN, some(token::COMMA),\n-                  parse_meta_item, p).node;\n+fn parse_meta_seq(&parser p) -> (@ast::meta_item)[] {\n+    ret parse_seq_ivec(token::LPAREN, token::RPAREN, some(token::COMMA),\n+                       parse_meta_item, p).node;\n }\n \n-fn parse_optional_meta(&parser p) -> vec[@ast::meta_item] {\n+fn parse_optional_meta(&parser p) -> (@ast::meta_item)[] {\n     alt (p.peek()) {\n         case (token::LPAREN) { ret parse_meta_seq(p); }\n-        case (_) { let vec[@ast::meta_item] v = []; ret v; }\n+        case (_) { ret ~[]; }\n     }\n }\n \n@@ -2203,8 +2232,7 @@ fn parse_use(&parser p) -> @ast::view_item {\n     auto metadata = parse_optional_meta(p);\n     auto hi = p.get_hi_pos();\n     expect(p, token::SEMI);\n-    auto use_decl =\n-        ast::view_item_use(ident, metadata, p.get_id());\n+    auto use_decl = ast::view_item_use(ident, metadata, p.get_id());\n     ret @spanned(lo, hi, use_decl);\n }\n "}, {"sha": "ec9d6316f72b58893ace0cc7951e2d910f4c81ec", "filename": "src/comp/syntax/print/pprust.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/401b6362d7f99a3cebc863cb1b8906d62e9ba79b/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/401b6362d7f99a3cebc863cb1b8906d62e9ba79b/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs?ref=401b6362d7f99a3cebc863cb1b8906d62e9ba79b", "patch": "@@ -1118,7 +1118,7 @@ fn print_meta_item(&ps s, &@ast::meta_item item) {\n         case (ast::meta_list(?name, ?items)) {\n             word(s.s, name);\n             popen(s);\n-            commasep(s, consistent, items, print_meta_item);\n+            commasep_ivec(s, consistent, items, print_meta_item);\n             pclose(s);\n         }\n     }\n@@ -1132,9 +1132,9 @@ fn print_view_item(&ps s, &@ast::view_item item) {\n         case (ast::view_item_use(?id, ?mta, _)) {\n             head(s, \"use\");\n             word(s.s, id);\n-            if (vec::len(mta) > 0u) {\n+            if (ivec::len(mta) > 0u) {\n                 popen(s);\n-                commasep(s, consistent, mta, print_meta_item);\n+                commasep_ivec(s, consistent, mta, print_meta_item);\n                 pclose(s);\n             }\n         }"}]}