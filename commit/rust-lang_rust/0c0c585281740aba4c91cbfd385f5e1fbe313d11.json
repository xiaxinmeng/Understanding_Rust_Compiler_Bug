{"sha": "0c0c585281740aba4c91cbfd385f5e1fbe313d11", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBjMGM1ODUyODE3NDBhYmE0YzkxY2JmZDM4NWY1ZTFmYmUzMTNkMTE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-01-19T21:21:12Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-01-19T21:21:12Z"}, "message": "Auto merge of #57761 - Centril:rollup, r=Centril\n\nRollup of 4 pull requests\n\nSuccessful merges:\n\n - #57452 (Improve docs for Formatter)\n - #57689 (Redo `hir::Stmt`)\n - #57723 (Point at cause for expectation in return type type error)\n - #57736 (Remove delay_span_bug from qualify_min_const_fn)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "52cb2add0b6d46605a1cd63403428fde95710a66", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/52cb2add0b6d46605a1cd63403428fde95710a66"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0c0c585281740aba4c91cbfd385f5e1fbe313d11", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0c0c585281740aba4c91cbfd385f5e1fbe313d11", "html_url": "https://github.com/rust-lang/rust/commit/0c0c585281740aba4c91cbfd385f5e1fbe313d11", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0c0c585281740aba4c91cbfd385f5e1fbe313d11/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "52fec814db1f5e9c000b8432cc5a4fd57c9df732", "url": "https://api.github.com/repos/rust-lang/rust/commits/52fec814db1f5e9c000b8432cc5a4fd57c9df732", "html_url": "https://github.com/rust-lang/rust/commit/52fec814db1f5e9c000b8432cc5a4fd57c9df732"}, {"sha": "d27224e0d877891ac1ff175bd35f8fd09d3640d9", "url": "https://api.github.com/repos/rust-lang/rust/commits/d27224e0d877891ac1ff175bd35f8fd09d3640d9", "html_url": "https://github.com/rust-lang/rust/commit/d27224e0d877891ac1ff175bd35f8fd09d3640d9"}], "stats": {"total": 806, "additions": 437, "deletions": 369}, "files": [{"sha": "5221d6f17c24732d223fef2e4b706c6aa2891337", "filename": "src/libcore/fmt/mod.rs", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/0c0c585281740aba4c91cbfd385f5e1fbe313d11/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c0c585281740aba4c91cbfd385f5e1fbe313d11/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=0c0c585281740aba4c91cbfd385f5e1fbe313d11", "patch": "@@ -211,9 +211,18 @@ impl<W: Write + ?Sized> Write for &mut W {\n     }\n }\n \n-/// A struct to represent both where to emit formatting strings to and how they\n-/// should be formatted. A mutable version of this is passed to all formatting\n-/// traits.\n+/// Configuration for formatting.\n+///\n+/// A `Formatter` represents various options related to formatting. Users do not\n+/// construct `Formatter`s directly; a mutable reference to one is passed to\n+/// the `fmt` method of all formatting traits, like [`Debug`] and [`Display`].\n+///\n+/// To interact with a `Formatter`, you'll call various methods to change the\n+/// various options related to formatting. For examples, please see the\n+/// documentation of the methods defined on `Formatter` below.\n+///\n+/// [`Debug`]: trait.Debug.html\n+/// [`Display`]: trait.Display.html\n #[allow(missing_debug_implementations)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Formatter<'a> {"}, {"sha": "6122fe6370940cd9d2d89e19e8b86daa7fee58e7", "filename": "src/librustc/cfg/construct.rs", "status": "modified", "additions": 12, "deletions": 21, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/0c0c585281740aba4c91cbfd385f5e1fbe313d11/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c0c585281740aba4c91cbfd385f5e1fbe313d11/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fcfg%2Fconstruct.rs?ref=0c0c585281740aba4c91cbfd385f5e1fbe313d11", "patch": "@@ -99,30 +99,21 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n     }\n \n     fn stmt(&mut self, stmt: &hir::Stmt, pred: CFGIndex) -> CFGIndex {\n-        let hir_id = self.tcx.hir().node_to_hir_id(stmt.node.id());\n-        match stmt.node {\n-            hir::StmtKind::Decl(ref decl, _) => {\n-                let exit = self.decl(&decl, pred);\n-                self.add_ast_node(hir_id.local_id, &[exit])\n-            }\n-\n-            hir::StmtKind::Expr(ref expr, _) |\n-            hir::StmtKind::Semi(ref expr, _) => {\n-                let exit = self.expr(&expr, pred);\n-                self.add_ast_node(hir_id.local_id, &[exit])\n-            }\n-        }\n-    }\n-\n-    fn decl(&mut self, decl: &hir::Decl, pred: CFGIndex) -> CFGIndex {\n-        match decl.node {\n-            hir::DeclKind::Local(ref local) => {\n+        let hir_id = self.tcx.hir().node_to_hir_id(stmt.id);\n+        let exit = match stmt.node {\n+            hir::StmtKind::Local(ref local) => {\n                 let init_exit = self.opt_expr(&local.init, pred);\n                 self.pat(&local.pat, init_exit)\n             }\n-\n-            hir::DeclKind::Item(_) => pred,\n-        }\n+            hir::StmtKind::Item(_) => {\n+                pred\n+            }\n+            hir::StmtKind::Expr(ref expr) |\n+            hir::StmtKind::Semi(ref expr) => {\n+                self.expr(&expr, pred)\n+            }\n+        };\n+        self.add_ast_node(hir_id.local_id, &[exit])\n     }\n \n     fn pat(&mut self, pat: &hir::Pat, pred: CFGIndex) -> CFGIndex {"}, {"sha": "df111b2be319f8bab3e36644215a4cbae44fb1a3", "filename": "src/librustc/hir/check_attr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0c0c585281740aba4c91cbfd385f5e1fbe313d11/src%2Flibrustc%2Fhir%2Fcheck_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c0c585281740aba4c91cbfd385f5e1fbe313d11/src%2Flibrustc%2Fhir%2Fcheck_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fcheck_attr.rs?ref=0c0c585281740aba4c91cbfd385f5e1fbe313d11", "patch": "@@ -283,8 +283,8 @@ impl<'a, 'tcx> CheckAttrVisitor<'a, 'tcx> {\n \n     fn check_stmt_attributes(&self, stmt: &hir::Stmt) {\n         // When checking statements ignore expressions, they will be checked later\n-        if let hir::StmtKind::Decl(_, _) = stmt.node {\n-            for attr in stmt.node.attrs() {\n+        if let hir::StmtKind::Local(ref l) = stmt.node {\n+            for attr in l.attrs.iter() {\n                 if attr.check_name(\"inline\") {\n                     self.check_inline(attr, &stmt.span, Target::Statement);\n                 }"}, {"sha": "592fb7898f3e60a05f35b1a626fc3420ff5e2d44", "filename": "src/librustc/hir/intravisit.rs", "status": "modified", "additions": 5, "deletions": 17, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/0c0c585281740aba4c91cbfd385f5e1fbe313d11/src%2Flibrustc%2Fhir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c0c585281740aba4c91cbfd385f5e1fbe313d11/src%2Flibrustc%2Fhir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fintravisit.rs?ref=0c0c585281740aba4c91cbfd385f5e1fbe313d11", "patch": "@@ -258,9 +258,6 @@ pub trait Visitor<'v> : Sized {\n     fn visit_pat(&mut self, p: &'v Pat) {\n         walk_pat(self, p)\n     }\n-    fn visit_decl(&mut self, d: &'v Decl) {\n-        walk_decl(self, d)\n-    }\n     fn visit_anon_const(&mut self, c: &'v AnonConst) {\n         walk_anon_const(self, c)\n     }\n@@ -951,26 +948,17 @@ pub fn walk_block<'v, V: Visitor<'v>>(visitor: &mut V, block: &'v Block) {\n }\n \n pub fn walk_stmt<'v, V: Visitor<'v>>(visitor: &mut V, statement: &'v Stmt) {\n+    visitor.visit_id(statement.id);\n     match statement.node {\n-        StmtKind::Decl(ref declaration, id) => {\n-            visitor.visit_id(id);\n-            visitor.visit_decl(declaration)\n-        }\n-        StmtKind::Expr(ref expression, id) |\n-        StmtKind::Semi(ref expression, id) => {\n-            visitor.visit_id(id);\n+        StmtKind::Local(ref local) => visitor.visit_local(local),\n+        StmtKind::Item(ref item) => visitor.visit_nested_item(**item),\n+        StmtKind::Expr(ref expression) |\n+        StmtKind::Semi(ref expression) => {\n             visitor.visit_expr(expression)\n         }\n     }\n }\n \n-pub fn walk_decl<'v, V: Visitor<'v>>(visitor: &mut V, declaration: &'v Decl) {\n-    match declaration.node {\n-        DeclKind::Local(ref local) => visitor.visit_local(local),\n-        DeclKind::Item(item) => visitor.visit_nested_item(item),\n-    }\n-}\n-\n pub fn walk_anon_const<'v, V: Visitor<'v>>(visitor: &mut V, constant: &'v AnonConst) {\n     visitor.visit_id(constant.id);\n     visitor.visit_nested_body(constant.body);"}, {"sha": "2f7d8f0984e6f439d2c5d72b2c98e60da1dac999", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 35, "deletions": 43, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/0c0c585281740aba4c91cbfd385f5e1fbe313d11/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c0c585281740aba4c91cbfd385f5e1fbe313d11/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=0c0c585281740aba4c91cbfd385f5e1fbe313d11", "patch": "@@ -1957,7 +1957,7 @@ impl<'a> LoweringContext<'a> {\n         )\n     }\n \n-    fn lower_local(&mut self, l: &Local) -> (P<hir::Local>, SmallVec<[hir::ItemId; 1]>) {\n+    fn lower_local(&mut self, l: &Local) -> (hir::Local, SmallVec<[hir::ItemId; 1]>) {\n         let LoweredNodeId { node_id, hir_id } = self.lower_node_id(l.id);\n         let mut ids = SmallVec::<[hir::ItemId; 1]>::new();\n         if self.sess.features_untracked().impl_trait_in_bindings {\n@@ -1967,7 +1967,7 @@ impl<'a> LoweringContext<'a> {\n             }\n         }\n         let parent_def_id = DefId::local(self.current_hir_id_owner.last().unwrap().0);\n-        (P(hir::Local {\n+        (hir::Local {\n             id: node_id,\n             hir_id,\n             ty: l.ty\n@@ -1984,7 +1984,7 @@ impl<'a> LoweringContext<'a> {\n             span: l.span,\n             attrs: l.attrs.clone(),\n             source: hir::LocalSource::Normal,\n-        }), ids)\n+        }, ids)\n     }\n \n     fn lower_mutability(&mut self, m: Mutability) -> hir::Mutability {\n@@ -4331,10 +4331,11 @@ impl<'a> LoweringContext<'a> {\n                         ThinVec::new(),\n                     ))\n                 };\n-                let match_stmt = respan(\n-                    head_sp,\n-                    hir::StmtKind::Expr(match_expr, self.next_id().node_id)\n-                );\n+                let match_stmt = hir::Stmt {\n+                    id: self.next_id().node_id,\n+                    node: hir::StmtKind::Expr(match_expr),\n+                    span: head_sp,\n+                };\n \n                 let next_expr = P(self.expr_ident(head_sp, next_ident, next_pat.id));\n \n@@ -4357,10 +4358,11 @@ impl<'a> LoweringContext<'a> {\n \n                 let body_block = self.with_loop_scope(e.id, |this| this.lower_block(body, false));\n                 let body_expr = P(self.expr_block(body_block, ThinVec::new()));\n-                let body_stmt = respan(\n-                    body.span,\n-                    hir::StmtKind::Expr(body_expr, self.next_id().node_id)\n-                );\n+                let body_stmt = hir::Stmt {\n+                    id: self.next_id().node_id,\n+                    node: hir::StmtKind::Expr(body_expr),\n+                    span: body.span,\n+                };\n \n                 let loop_block = P(self.block_all(\n                     e.span,\n@@ -4533,25 +4535,15 @@ impl<'a> LoweringContext<'a> {\n                 let (l, item_ids) = self.lower_local(l);\n                 let mut ids: SmallVec<[hir::Stmt; 1]> = item_ids\n                     .into_iter()\n-                    .map(|item_id| Spanned {\n-                        node: hir::StmtKind::Decl(\n-                            P(Spanned {\n-                                node: hir::DeclKind::Item(item_id),\n-                                span: s.span,\n-                            }),\n-                            self.next_id().node_id,\n-                        ),\n+                    .map(|item_id| hir::Stmt {\n+                        id: self.next_id().node_id,\n+                        node: hir::StmtKind::Item(P(item_id)),\n                         span: s.span,\n                     })\n                     .collect();\n-                ids.push(Spanned {\n-                    node: hir::StmtKind::Decl(\n-                        P(Spanned {\n-                            node: hir::DeclKind::Local(l),\n-                            span: s.span,\n-                        }),\n-                        self.lower_node_id(s.id).node_id,\n-                    ),\n+                ids.push(hir::Stmt {\n+                    id: self.lower_node_id(s.id).node_id,\n+                    node: hir::StmtKind::Local(P(l)),\n                     span: s.span,\n                 });\n                 return ids;\n@@ -4561,26 +4553,23 @@ impl<'a> LoweringContext<'a> {\n                 let mut id = Some(s.id);\n                 return self.lower_item_id(it)\n                     .into_iter()\n-                    .map(|item_id| Spanned {\n-                        node: hir::StmtKind::Decl(\n-                            P(Spanned {\n-                                node: hir::DeclKind::Item(item_id),\n-                                span: s.span,\n-                            }),\n-                            id.take()\n+                    .map(|item_id| hir::Stmt {\n+                        id: id.take()\n                               .map(|id| self.lower_node_id(id).node_id)\n                               .unwrap_or_else(|| self.next_id().node_id),\n-                        ),\n+                        node: hir::StmtKind::Item(P(item_id)),\n                         span: s.span,\n                     })\n                     .collect();\n             }\n-            StmtKind::Expr(ref e) => Spanned {\n-                node: hir::StmtKind::Expr(P(self.lower_expr(e)), self.lower_node_id(s.id).node_id),\n+            StmtKind::Expr(ref e) => hir::Stmt {\n+                id: self.lower_node_id(s.id).node_id,\n+                node: hir::StmtKind::Expr(P(self.lower_expr(e))),\n                 span: s.span,\n             },\n-            StmtKind::Semi(ref e) => Spanned {\n-                node: hir::StmtKind::Semi(P(self.lower_expr(e)), self.lower_node_id(s.id).node_id),\n+            StmtKind::Semi(ref e) => hir::Stmt {\n+                id: self.lower_node_id(s.id).node_id,\n+                node: hir::StmtKind::Semi(P(self.lower_expr(e))),\n                 span: s.span,\n             },\n             StmtKind::Mac(..) => panic!(\"Shouldn't exist here\"),\n@@ -4795,7 +4784,7 @@ impl<'a> LoweringContext<'a> {\n     ) -> hir::Stmt {\n         let LoweredNodeId { node_id, hir_id } = self.next_id();\n \n-        let local = P(hir::Local {\n+        let local = hir::Local {\n             pat,\n             ty: None,\n             init: ex,\n@@ -4804,9 +4793,12 @@ impl<'a> LoweringContext<'a> {\n             span: sp,\n             attrs: ThinVec::new(),\n             source,\n-        });\n-        let decl = respan(sp, hir::DeclKind::Local(local));\n-        respan(sp, hir::StmtKind::Decl(P(decl), self.next_id().node_id))\n+        };\n+        hir::Stmt {\n+            id: self.next_id().node_id,\n+            node: hir::StmtKind::Local(P(local)),\n+            span: sp\n+        }\n     }\n \n     fn stmt_let("}, {"sha": "7cc5d756ff311730fc4d3e77af2e84e515b9910e", "filename": "src/librustc/hir/map/collector.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c0c585281740aba4c91cbfd385f5e1fbe313d11/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c0c585281740aba4c91cbfd385f5e1fbe313d11/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs?ref=0c0c585281740aba4c91cbfd385f5e1fbe313d11", "patch": "@@ -426,7 +426,7 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n     }\n \n     fn visit_stmt(&mut self, stmt: &'hir Stmt) {\n-        let id = stmt.node.id();\n+        let id = stmt.id;\n         self.insert(stmt.span, id, Node::Stmt(stmt));\n \n         self.with_parent(id, |this| {"}, {"sha": "65d9d5a4f363f43dc83e1608859688702d1b3d92", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 20, "deletions": 50, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/0c0c585281740aba4c91cbfd385f5e1fbe313d11/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c0c585281740aba4c91cbfd385f5e1fbe313d11/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=0c0c585281740aba4c91cbfd385f5e1fbe313d11", "patch": "@@ -17,7 +17,7 @@ use util::nodemap::{NodeMap, FxHashSet};\n use mir::mono::Linkage;\n \n use syntax_pos::{Span, DUMMY_SP, symbol::InternedString};\n-use syntax::source_map::{self, Spanned};\n+use syntax::source_map::Spanned;\n use rustc_target::spec::abi::Abi;\n use syntax::ast::{self, CrateSugar, Ident, Name, NodeId, DUMMY_NODE_ID, AsmDialect};\n use syntax::ast::{Attribute, Label, Lit, StrStyle, FloatTy, IntTy, UintTy};\n@@ -1134,45 +1134,41 @@ impl UnOp {\n }\n \n /// A statement\n-pub type Stmt = Spanned<StmtKind>;\n+#[derive(Clone, RustcEncodable, RustcDecodable)]\n+pub struct Stmt {\n+    pub id: NodeId,\n+    pub node: StmtKind,\n+    pub span: Span,\n+}\n \n-impl fmt::Debug for StmtKind {\n+impl fmt::Debug for Stmt {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        // Sadness.\n-        let spanned = source_map::dummy_spanned(self.clone());\n-        write!(f,\n-               \"stmt({}: {})\",\n-               spanned.node.id(),\n-               print::to_string(print::NO_ANN, |s| s.print_stmt(&spanned)))\n+        write!(f, \"stmt({}: {})\", self.id,\n+               print::to_string(print::NO_ANN, |s| s.print_stmt(self)))\n     }\n }\n \n #[derive(Clone, RustcEncodable, RustcDecodable)]\n pub enum StmtKind {\n-    /// Could be an item or a local (let) binding:\n-    Decl(P<Decl>, NodeId),\n+    /// A local (let) binding:\n+    Local(P<Local>),\n+    /// An item binding:\n+    Item(P<ItemId>),\n \n     /// Expr without trailing semi-colon (must have unit type):\n-    Expr(P<Expr>, NodeId),\n+    Expr(P<Expr>),\n \n     /// Expr with trailing semi-colon (may have any type):\n-    Semi(P<Expr>, NodeId),\n+    Semi(P<Expr>),\n }\n \n impl StmtKind {\n     pub fn attrs(&self) -> &[Attribute] {\n         match *self {\n-            StmtKind::Decl(ref d, _) => d.node.attrs(),\n-            StmtKind::Expr(ref e, _) |\n-            StmtKind::Semi(ref e, _) => &e.attrs,\n-        }\n-    }\n-\n-    pub fn id(&self) -> NodeId {\n-        match *self {\n-            StmtKind::Decl(_, id) |\n-            StmtKind::Expr(_, id) |\n-            StmtKind::Semi(_, id) => id,\n+            StmtKind::Local(ref l) => &l.attrs,\n+            StmtKind::Item(_) => &[],\n+            StmtKind::Expr(ref e) |\n+            StmtKind::Semi(ref e) => &e.attrs,\n         }\n     }\n }\n@@ -1191,32 +1187,6 @@ pub struct Local {\n     pub source: LocalSource,\n }\n \n-pub type Decl = Spanned<DeclKind>;\n-\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n-pub enum DeclKind {\n-    /// A local (let) binding:\n-    Local(P<Local>),\n-    /// An item binding:\n-    Item(ItemId),\n-}\n-\n-impl DeclKind {\n-    pub fn attrs(&self) -> &[Attribute] {\n-        match *self {\n-            DeclKind::Local(ref l) => &l.attrs,\n-            DeclKind::Item(_) => &[]\n-        }\n-    }\n-\n-    pub fn is_local(&self) -> bool {\n-        match *self {\n-            DeclKind::Local(_) => true,\n-            _ => false,\n-        }\n-    }\n-}\n-\n /// represents one arm of a 'match'\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub struct Arm {"}, {"sha": "e950f25c2ac9ae8697dbc969d91dc54ea30c9625", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 23, "deletions": 40, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/0c0c585281740aba4c91cbfd385f5e1fbe313d11/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c0c585281740aba4c91cbfd385f5e1fbe313d11/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=0c0c585281740aba4c91cbfd385f5e1fbe313d11", "patch": "@@ -992,14 +992,29 @@ impl<'a> State<'a> {\n     pub fn print_stmt(&mut self, st: &hir::Stmt) -> io::Result<()> {\n         self.maybe_print_comment(st.span.lo())?;\n         match st.node {\n-            hir::StmtKind::Decl(ref decl, _) => {\n-                self.print_decl(&decl)?;\n+            hir::StmtKind::Local(ref loc) => {\n+                self.space_if_not_bol()?;\n+                self.ibox(indent_unit)?;\n+                self.word_nbsp(\"let\")?;\n+\n+                self.ibox(indent_unit)?;\n+                self.print_local_decl(&loc)?;\n+                self.end()?;\n+                if let Some(ref init) = loc.init {\n+                    self.nbsp()?;\n+                    self.word_space(\"=\")?;\n+                    self.print_expr(&init)?;\n+                }\n+                self.end()?\n+            }\n+            hir::StmtKind::Item(ref item) => {\n+                self.ann.nested(self, Nested::Item(**item))?\n             }\n-            hir::StmtKind::Expr(ref expr, _) => {\n+            hir::StmtKind::Expr(ref expr) => {\n                 self.space_if_not_bol()?;\n                 self.print_expr(&expr)?;\n             }\n-            hir::StmtKind::Semi(ref expr, _) => {\n+            hir::StmtKind::Semi(ref expr) => {\n                 self.space_if_not_bol()?;\n                 self.print_expr(&expr)?;\n                 self.s.word(\";\")?;\n@@ -1562,30 +1577,6 @@ impl<'a> State<'a> {\n         Ok(())\n     }\n \n-    pub fn print_decl(&mut self, decl: &hir::Decl) -> io::Result<()> {\n-        self.maybe_print_comment(decl.span.lo())?;\n-        match decl.node {\n-            hir::DeclKind::Local(ref loc) => {\n-                self.space_if_not_bol()?;\n-                self.ibox(indent_unit)?;\n-                self.word_nbsp(\"let\")?;\n-\n-                self.ibox(indent_unit)?;\n-                self.print_local_decl(&loc)?;\n-                self.end()?;\n-                if let Some(ref init) = loc.init {\n-                    self.nbsp()?;\n-                    self.word_space(\"=\")?;\n-                    self.print_expr(&init)?;\n-                }\n-                self.end()\n-            }\n-            hir::DeclKind::Item(item) => {\n-                self.ann.nested(self, Nested::Item(item))\n-            }\n-        }\n-    }\n-\n     pub fn print_usize(&mut self, i: usize) -> io::Result<()> {\n         self.s.word(i.to_string())\n     }\n@@ -2401,18 +2392,10 @@ fn expr_requires_semi_to_be_stmt(e: &hir::Expr) -> bool {\n /// seen the semicolon, and thus don't need another.\n fn stmt_ends_with_semi(stmt: &hir::StmtKind) -> bool {\n     match *stmt {\n-        hir::StmtKind::Decl(ref d, _) => {\n-            match d.node {\n-                hir::DeclKind::Local(_) => true,\n-                hir::DeclKind::Item(_) => false,\n-            }\n-        }\n-        hir::StmtKind::Expr(ref e, _) => {\n-            expr_requires_semi_to_be_stmt(&e)\n-        }\n-        hir::StmtKind::Semi(..) => {\n-            false\n-        }\n+        hir::StmtKind::Local(_) => true,\n+        hir::StmtKind::Item(_) => false,\n+        hir::StmtKind::Expr(ref e) => expr_requires_semi_to_be_stmt(&e),\n+        hir::StmtKind::Semi(..) => false,\n     }\n }\n "}, {"sha": "159067663d42e1402e5ee6f77e296c61a2cae8b0", "filename": "src/librustc/ich/impls_hir.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/0c0c585281740aba4c91cbfd385f5e1fbe313d11/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c0c585281740aba4c91cbfd385f5e1fbe313d11/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_hir.rs?ref=0c0c585281740aba4c91cbfd385f5e1fbe313d11", "patch": "@@ -483,7 +483,12 @@ impl_stable_hash_for!(enum hir::UnOp {\n     UnNeg\n });\n \n-impl_stable_hash_for_spanned!(hir::StmtKind);\n+impl_stable_hash_for!(struct hir::Stmt {\n+    id,\n+    node,\n+    span,\n+});\n+\n \n impl_stable_hash_for!(struct hir::Local {\n     pat,\n@@ -496,12 +501,6 @@ impl_stable_hash_for!(struct hir::Local {\n     source\n });\n \n-impl_stable_hash_for_spanned!(hir::DeclKind);\n-impl_stable_hash_for!(enum hir::DeclKind {\n-    Local(local),\n-    Item(item_id)\n-});\n-\n impl_stable_hash_for!(struct hir::Arm {\n     attrs,\n     pats,\n@@ -941,9 +940,10 @@ impl_stable_hash_for!(enum hir::ForeignItemKind {\n });\n \n impl_stable_hash_for!(enum hir::StmtKind {\n-    Decl(decl, id),\n-    Expr(expr, id),\n-    Semi(expr, id)\n+    Local(local),\n+    Item(item_id),\n+    Expr(expr),\n+    Semi(expr)\n });\n \n impl_stable_hash_for!(struct hir::Arg {"}, {"sha": "837a3645d1c94d3c455bcb2c8523e827875ad69e", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0c0c585281740aba4c91cbfd385f5e1fbe313d11/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c0c585281740aba4c91cbfd385f5e1fbe313d11/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=0c0c585281740aba4c91cbfd385f5e1fbe313d11", "patch": "@@ -941,11 +941,6 @@ impl<'a, 'tcx> hir_visit::Visitor<'tcx> for LateContext<'a, 'tcx> {\n         hir_visit::walk_arm(self, a);\n     }\n \n-    fn visit_decl(&mut self, d: &'tcx hir::Decl) {\n-        run_lints!(self, check_decl, d);\n-        hir_visit::walk_decl(self, d);\n-    }\n-\n     fn visit_generic_param(&mut self, p: &'tcx hir::GenericParam) {\n         run_lints!(self, check_generic_param, p);\n         hir_visit::walk_generic_param(self, p);"}, {"sha": "e83ba7402b5791cdbcac62f5853742367e8b8e73", "filename": "src/librustc/lint/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0c0c585281740aba4c91cbfd385f5e1fbe313d11/src%2Flibrustc%2Flint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c0c585281740aba4c91cbfd385f5e1fbe313d11/src%2Flibrustc%2Flint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fmod.rs?ref=0c0c585281740aba4c91cbfd385f5e1fbe313d11", "patch": "@@ -192,7 +192,6 @@ macro_rules! late_lint_methods {\n             fn check_stmt(a: &$hir hir::Stmt);\n             fn check_arm(a: &$hir hir::Arm);\n             fn check_pat(a: &$hir hir::Pat);\n-            fn check_decl(a: &$hir hir::Decl);\n             fn check_expr(a: &$hir hir::Expr);\n             fn check_expr_post(a: &$hir hir::Expr);\n             fn check_ty(a: &$hir hir::Ty);"}, {"sha": "08210c3f075ce453e3a5fc4c06a80e8207ecee6d", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 8, "deletions": 12, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/0c0c585281740aba4c91cbfd385f5e1fbe313d11/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c0c585281740aba4c91cbfd385f5e1fbe313d11/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=0c0c585281740aba4c91cbfd385f5e1fbe313d11", "patch": "@@ -589,21 +589,17 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n \n     fn walk_stmt(&mut self, stmt: &hir::Stmt) {\n         match stmt.node {\n-            hir::StmtKind::Decl(ref decl, _) => {\n-                match decl.node {\n-                    hir::DeclKind::Local(ref local) => {\n-                        self.walk_local(&local);\n-                    }\n+            hir::StmtKind::Local(ref local) => {\n+                self.walk_local(&local);\n+            }\n \n-                    hir::DeclKind::Item(_) => {\n-                        // we don't visit nested items in this visitor,\n-                        // only the fn body we were given.\n-                    }\n-                }\n+            hir::StmtKind::Item(_) => {\n+                // we don't visit nested items in this visitor,\n+                // only the fn body we were given.\n             }\n \n-            hir::StmtKind::Expr(ref expr, _) |\n-            hir::StmtKind::Semi(ref expr, _) => {\n+            hir::StmtKind::Expr(ref expr) |\n+            hir::StmtKind::Semi(ref expr) => {\n                 self.consume_expr(&expr);\n             }\n         }"}, {"sha": "220bec735a47360b828ed4482c24f8d183181717", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 19, "deletions": 34, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/0c0c585281740aba4c91cbfd385f5e1fbe313d11/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c0c585281740aba4c91cbfd385f5e1fbe313d11/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=0c0c585281740aba4c91cbfd385f5e1fbe313d11", "patch": "@@ -962,46 +962,31 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n     fn propagate_through_stmt(&mut self, stmt: &hir::Stmt, succ: LiveNode)\n                               -> LiveNode {\n         match stmt.node {\n-            hir::StmtKind::Decl(ref decl, _) => {\n-                self.propagate_through_decl(&decl, succ)\n-            }\n+            hir::StmtKind::Local(ref local) => {\n+                // Note: we mark the variable as defined regardless of whether\n+                // there is an initializer.  Initially I had thought to only mark\n+                // the live variable as defined if it was initialized, and then we\n+                // could check for uninit variables just by scanning what is live\n+                // at the start of the function. But that doesn't work so well for\n+                // immutable variables defined in a loop:\n+                //     loop { let x; x = 5; }\n+                // because the \"assignment\" loops back around and generates an error.\n+                //\n+                // So now we just check that variables defined w/o an\n+                // initializer are not live at the point of their\n+                // initialization, which is mildly more complex than checking\n+                // once at the func header but otherwise equivalent.\n \n-            hir::StmtKind::Expr(ref expr, _) | hir::StmtKind::Semi(ref expr, _) => {\n-                self.propagate_through_expr(&expr, succ)\n+                let succ = self.propagate_through_opt_expr(local.init.as_ref().map(|e| &**e), succ);\n+                self.define_bindings_in_pat(&local.pat, succ)\n             }\n-        }\n-    }\n-\n-    fn propagate_through_decl(&mut self, decl: &hir::Decl, succ: LiveNode)\n-                              -> LiveNode {\n-        match decl.node {\n-            hir::DeclKind::Local(ref local) => {\n-                self.propagate_through_local(&local, succ)\n+            hir::StmtKind::Item(..) => succ,\n+            hir::StmtKind::Expr(ref expr) | hir::StmtKind::Semi(ref expr) => {\n+                self.propagate_through_expr(&expr, succ)\n             }\n-            hir::DeclKind::Item(_) => succ,\n         }\n     }\n \n-    fn propagate_through_local(&mut self, local: &hir::Local, succ: LiveNode)\n-                               -> LiveNode {\n-        // Note: we mark the variable as defined regardless of whether\n-        // there is an initializer.  Initially I had thought to only mark\n-        // the live variable as defined if it was initialized, and then we\n-        // could check for uninit variables just by scanning what is live\n-        // at the start of the function. But that doesn't work so well for\n-        // immutable variables defined in a loop:\n-        //     loop { let x; x = 5; }\n-        // because the \"assignment\" loops back around and generates an error.\n-        //\n-        // So now we just check that variables defined w/o an\n-        // initializer are not live at the point of their\n-        // initialization, which is mildly more complex than checking\n-        // once at the func header but otherwise equivalent.\n-\n-        let succ = self.propagate_through_opt_expr(local.init.as_ref().map(|e| &**e), succ);\n-        self.define_bindings_in_pat(&local.pat, succ)\n-    }\n-\n     fn propagate_through_exprs(&mut self, exprs: &[Expr], succ: LiveNode)\n                                -> LiveNode {\n         exprs.iter().rev().fold(succ, |succ, expr| {"}, {"sha": "819dd8aa7d53e43f4c1671d561411b6ebb57a744", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 20, "deletions": 15, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/0c0c585281740aba4c91cbfd385f5e1fbe313d11/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c0c585281740aba4c91cbfd385f5e1fbe313d11/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=0c0c585281740aba4c91cbfd385f5e1fbe313d11", "patch": "@@ -784,20 +784,25 @@ fn resolve_block<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>, blk:\n         // index information.)\n \n         for (i, statement) in blk.stmts.iter().enumerate() {\n-            if let hir::StmtKind::Decl(..) = statement.node {\n-                // Each StmtKind::Decl introduces a subscope for bindings\n-                // introduced by the declaration; this subscope covers\n-                // a suffix of the block . Each subscope in a block\n-                // has the previous subscope in the block as a parent,\n-                // except for the first such subscope, which has the\n-                // block itself as a parent.\n-                visitor.enter_scope(\n-                    Scope {\n-                        id: blk.hir_id.local_id,\n-                        data: ScopeData::Remainder(FirstStatementIndex::new(i))\n-                    }\n-                );\n-                visitor.cx.var_parent = visitor.cx.parent;\n+            match statement.node {\n+                hir::StmtKind::Local(..) |\n+                hir::StmtKind::Item(..) => {\n+                    // Each declaration introduces a subscope for bindings\n+                    // introduced by the declaration; this subscope covers a\n+                    // suffix of the block. Each subscope in a block has the\n+                    // previous subscope in the block as a parent, except for\n+                    // the first such subscope, which has the block itself as a\n+                    // parent.\n+                    visitor.enter_scope(\n+                        Scope {\n+                            id: blk.hir_id.local_id,\n+                            data: ScopeData::Remainder(FirstStatementIndex::new(i))\n+                        }\n+                    );\n+                    visitor.cx.var_parent = visitor.cx.parent;\n+                }\n+                hir::StmtKind::Expr(..) |\n+                hir::StmtKind::Semi(..) => {}\n             }\n             visitor.visit_stmt(statement)\n         }\n@@ -835,7 +840,7 @@ fn resolve_pat<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>, pat: &\n }\n \n fn resolve_stmt<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>, stmt: &'tcx hir::Stmt) {\n-    let stmt_id = visitor.tcx.hir().node_to_hir_id(stmt.node.id()).local_id;\n+    let stmt_id = visitor.tcx.hir().node_to_hir_id(stmt.id).local_id;\n     debug!(\"resolve_stmt(stmt.id={:?})\", stmt_id);\n \n     // Every statement will clean up the temporaries created during"}, {"sha": "8a68f1bb9d085e8512ee9a38708ba1da70457376", "filename": "src/librustc_lint/unused.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0c0c585281740aba4c91cbfd385f5e1fbe313d11/src%2Flibrustc_lint%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c0c585281740aba4c91cbfd385f5e1fbe313d11/src%2Flibrustc_lint%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Funused.rs?ref=0c0c585281740aba4c91cbfd385f5e1fbe313d11", "patch": "@@ -41,7 +41,7 @@ impl LintPass for UnusedResults {\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedResults {\n     fn check_stmt(&mut self, cx: &LateContext, s: &hir::Stmt) {\n         let expr = match s.node {\n-            hir::StmtKind::Semi(ref expr, _) => &**expr,\n+            hir::StmtKind::Semi(ref expr) => &**expr,\n             _ => return,\n         };\n \n@@ -205,7 +205,7 @@ impl LintPass for PathStatements {\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for PathStatements {\n     fn check_stmt(&mut self, cx: &LateContext, s: &hir::Stmt) {\n-        if let hir::StmtKind::Semi(ref expr, _) = s.node {\n+        if let hir::StmtKind::Semi(ref expr) = s.node {\n             if let hir::ExprKind::Path(_) = expr.node {\n                 cx.span_lint(PATH_STATEMENTS, s.span, \"path statement with no effect\");\n             }"}, {"sha": "c50d9ddcb152e95a228817ef5fc7bfe54f4e7c96", "filename": "src/librustc_mir/hair/cx/block.rs", "status": "modified", "additions": 42, "deletions": 46, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/0c0c585281740aba4c91cbfd385f5e1fbe313d11/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c0c585281740aba4c91cbfd385f5e1fbe313d11/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs?ref=0c0c585281740aba4c91cbfd385f5e1fbe313d11", "patch": "@@ -46,12 +46,12 @@ fn mirror_stmts<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                                 -> Vec<StmtRef<'tcx>> {\n     let mut result = vec![];\n     for (index, stmt) in stmts.iter().enumerate() {\n-        let hir_id = cx.tcx.hir().node_to_hir_id(stmt.node.id());\n+        let hir_id = cx.tcx.hir().node_to_hir_id(stmt.id);\n         let opt_dxn_ext = cx.region_scope_tree.opt_destruction_scope(hir_id.local_id);\n-        let stmt_span = StatementSpan(cx.tcx.hir().span(stmt.node.id()));\n+        let stmt_span = StatementSpan(cx.tcx.hir().span(stmt.id));\n         match stmt.node {\n-            hir::StmtKind::Expr(ref expr, _) |\n-            hir::StmtKind::Semi(ref expr, _) => {\n+            hir::StmtKind::Expr(ref expr) |\n+            hir::StmtKind::Semi(ref expr) => {\n                 result.push(StmtRef::Mirror(Box::new(Stmt {\n                     kind: StmtKind::Expr {\n                         scope: region::Scope {\n@@ -64,52 +64,48 @@ fn mirror_stmts<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                     span: stmt_span,\n                 })))\n             }\n-            hir::StmtKind::Decl(ref decl, _) => {\n-                match decl.node {\n-                    hir::DeclKind::Item(..) => {\n-                        // ignore for purposes of the MIR\n-                    }\n-                    hir::DeclKind::Local(ref local) => {\n-                        let remainder_scope = region::Scope {\n-                            id: block_id,\n-                            data: region::ScopeData::Remainder(\n-                                region::FirstStatementIndex::new(index)),\n-                        };\n-\n-                        let mut pattern = cx.pattern_from_hir(&local.pat);\n+            hir::StmtKind::Item(..) => {\n+                // ignore for purposes of the MIR\n+            }\n+            hir::StmtKind::Local(ref local) => {\n+                let remainder_scope = region::Scope {\n+                    id: block_id,\n+                    data: region::ScopeData::Remainder(\n+                        region::FirstStatementIndex::new(index)),\n+                };\n \n-                        if let Some(ty) = &local.ty {\n-                            if let Some(&user_ty) = cx.tables.user_provided_types().get(ty.hir_id) {\n-                                debug!(\"mirror_stmts: user_ty={:?}\", user_ty);\n-                                pattern = Pattern {\n-                                    ty: pattern.ty,\n-                                    span: pattern.span,\n-                                    kind: Box::new(PatternKind::AscribeUserType {\n-                                        user_ty: PatternTypeProjection::from_user_type(user_ty),\n-                                        user_ty_span: ty.span,\n-                                        subpattern: pattern,\n-                                        variance: ty::Variance::Covariant,\n-                                    })\n-                                };\n-                            }\n-                        }\n+                let mut pattern = cx.pattern_from_hir(&local.pat);\n \n-                        result.push(StmtRef::Mirror(Box::new(Stmt {\n-                            kind: StmtKind::Let {\n-                                remainder_scope: remainder_scope,\n-                                init_scope: region::Scope {\n-                                    id: hir_id.local_id,\n-                                    data: region::ScopeData::Node\n-                                },\n-                                pattern,\n-                                initializer: local.init.to_ref(),\n-                                lint_level: cx.lint_level_of(local.id),\n-                            },\n-                            opt_destruction_scope: opt_dxn_ext,\n-                            span: stmt_span,\n-                        })));\n+                if let Some(ty) = &local.ty {\n+                    if let Some(&user_ty) = cx.tables.user_provided_types().get(ty.hir_id) {\n+                        debug!(\"mirror_stmts: user_ty={:?}\", user_ty);\n+                        pattern = Pattern {\n+                            ty: pattern.ty,\n+                            span: pattern.span,\n+                            kind: Box::new(PatternKind::AscribeUserType {\n+                                user_ty: PatternTypeProjection::from_user_type(user_ty),\n+                                user_ty_span: ty.span,\n+                                subpattern: pattern,\n+                                variance: ty::Variance::Covariant,\n+                            })\n+                        };\n                     }\n                 }\n+\n+                result.push(StmtRef::Mirror(Box::new(Stmt {\n+                    kind: StmtKind::Let {\n+                        remainder_scope: remainder_scope,\n+                        init_scope: region::Scope {\n+                            id: hir_id.local_id,\n+                            data: region::ScopeData::Node\n+                        },\n+                        pattern,\n+                        initializer: local.init.to_ref(),\n+                        lint_level: cx.lint_level_of(local.id),\n+                    },\n+                    opt_destruction_scope: opt_dxn_ext,\n+                    span: stmt_span,\n+                })));\n             }\n         }\n     }"}, {"sha": "85bf1e70ebf423c6261c1d1145536864e953d0d4", "filename": "src/librustc_mir/transform/qualify_min_const_fn.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0c0c585281740aba4c91cbfd385f5e1fbe313d11/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c0c585281740aba4c91cbfd385f5e1fbe313d11/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs?ref=0c0c585281740aba4c91cbfd385f5e1fbe313d11", "patch": "@@ -21,6 +21,7 @@ pub fn is_min_const_fn(\n                 | Predicate::RegionOutlives(_)\n                 | Predicate::TypeOutlives(_)\n                 | Predicate::WellFormed(_)\n+                | Predicate::Projection(_)\n                 | Predicate::ConstEvaluatable(..) => continue,\n                 | Predicate::ObjectSafe(_) => {\n                     bug!(\"object safe predicate on function: {:#?}\", predicate)\n@@ -29,13 +30,6 @@ pub fn is_min_const_fn(\n                     bug!(\"closure kind predicate on function: {:#?}\", predicate)\n                 }\n                 Predicate::Subtype(_) => bug!(\"subtype predicate on function: {:#?}\", predicate),\n-                Predicate::Projection(_) => {\n-                    let span = tcx.def_span(current);\n-                    // we'll hit a `Predicate::Trait` later which will report an error\n-                    tcx.sess\n-                        .delay_span_bug(span, \"projection without trait bound\");\n-                    continue;\n-                }\n                 Predicate::Trait(pred) => {\n                     if Some(pred.def_id()) == tcx.lang_items().sized_trait() {\n                         continue;"}, {"sha": "74d6d75a7f528ad9ef403b8406af5676aa05cebf", "filename": "src/librustc_passes/hir_stats.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0c0c585281740aba4c91cbfd385f5e1fbe313d11/src%2Flibrustc_passes%2Fhir_stats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c0c585281740aba4c91cbfd385f5e1fbe313d11/src%2Flibrustc_passes%2Fhir_stats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fhir_stats.rs?ref=0c0c585281740aba4c91cbfd385f5e1fbe313d11", "patch": "@@ -144,7 +144,7 @@ impl<'v> hir_visit::Visitor<'v> for StatCollector<'v> {\n     }\n \n     fn visit_stmt(&mut self, s: &'v hir::Stmt) {\n-        self.record(\"Stmt\", Id::Node(s.node.id()), s);\n+        self.record(\"Stmt\", Id::Node(s.id), s);\n         hir_visit::walk_stmt(self, s)\n     }\n \n@@ -158,11 +158,6 @@ impl<'v> hir_visit::Visitor<'v> for StatCollector<'v> {\n         hir_visit::walk_pat(self, p)\n     }\n \n-    fn visit_decl(&mut self, d: &'v hir::Decl) {\n-        self.record(\"Decl\", Id::None, d);\n-        hir_visit::walk_decl(self, d)\n-    }\n-\n     fn visit_expr(&mut self, ex: &'v hir::Expr) {\n         self.record(\"Expr\", Id::Node(ex.id), ex);\n         hir_visit::walk_expr(self, ex)"}, {"sha": "49914dc7078fdbc2159cbbb84b5e05088a289391", "filename": "src/librustc_passes/rvalue_promotion.rs", "status": "modified", "additions": 13, "deletions": 17, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/0c0c585281740aba4c91cbfd385f5e1fbe313d11/src%2Flibrustc_passes%2Frvalue_promotion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c0c585281740aba4c91cbfd385f5e1fbe313d11/src%2Flibrustc_passes%2Frvalue_promotion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Frvalue_promotion.rs?ref=0c0c585281740aba4c91cbfd385f5e1fbe313d11", "patch": "@@ -220,26 +220,22 @@ impl<'a, 'tcx> CheckCrateVisitor<'a, 'tcx> {\n \n     fn check_stmt(&mut self, stmt: &'tcx hir::Stmt) -> Promotability {\n         match stmt.node {\n-            hir::StmtKind::Decl(ref decl, _node_id) => {\n-                match &decl.node {\n-                    hir::DeclKind::Local(local) => {\n-                        if self.remove_mut_rvalue_borrow(&local.pat) {\n-                            if let Some(init) = &local.init {\n-                                self.mut_rvalue_borrows.insert(init.id);\n-                            }\n-                        }\n-\n-                        if let Some(ref expr) = local.init {\n-                            let _ = self.check_expr(&expr);\n-                        }\n-                        NotPromotable\n+            hir::StmtKind::Local(ref local) => {\n+                if self.remove_mut_rvalue_borrow(&local.pat) {\n+                    if let Some(init) = &local.init {\n+                        self.mut_rvalue_borrows.insert(init.id);\n                     }\n-                    // Item statements are allowed\n-                    hir::DeclKind::Item(_) => Promotable\n                 }\n+\n+                if let Some(ref expr) = local.init {\n+                    let _ = self.check_expr(&expr);\n+                }\n+                NotPromotable\n             }\n-            hir::StmtKind::Expr(ref box_expr, _node_id) |\n-            hir::StmtKind::Semi(ref box_expr, _node_id) => {\n+            // Item statements are allowed\n+            hir::StmtKind::Item(..) => Promotable,\n+            hir::StmtKind::Expr(ref box_expr) |\n+            hir::StmtKind::Semi(ref box_expr) => {\n                 let _ = self.check_expr(box_expr);\n                 NotPromotable\n             }"}, {"sha": "dd63b4f20fa55a4f92cfa832d205b52a56072eb1", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 37, "deletions": 5, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/0c0c585281740aba4c91cbfd385f5e1fbe313d11/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c0c585281740aba4c91cbfd385f5e1fbe313d11/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=0c0c585281740aba4c91cbfd385f5e1fbe313d11", "patch": "@@ -1216,28 +1216,60 @@ impl<'gcx, 'tcx, 'exprs, E> CoerceMany<'gcx, 'tcx, 'exprs, E>\n                                       \"supposed to be part of a block tail expression, but the \\\n                                        expression is empty\");\n                         });\n-                        fcx.suggest_mismatched_types_on_tail(\n+                        let pointing_at_return_type = fcx.suggest_mismatched_types_on_tail(\n                             &mut db,\n                             expr,\n                             expected,\n                             found,\n                             cause.span,\n                             blk_id,\n                         );\n-                        if let Some(sp) = fcx.ret_coercion_span.borrow().as_ref() {\n-                            if !sp.overlaps(cause.span) {\n+                        // FIXME: replace with navigating up the chain until hitting an fn or\n+                        // bailing if no \"pass-through\" Node is found, in order to provide a\n+                        // suggestion when encountering something like:\n+                        // ```\n+                        // fn foo(a: bool) -> impl Debug {\n+                        //     if a {\n+                        //         bar()?;\n+                        //     }\n+                        //     {\n+                        //         let x = unsafe { bar() };\n+                        //         x\n+                        //     }\n+                        // }\n+                        // ```\n+                        //\n+                        // Verify that this is a tail expression of a function, otherwise the\n+                        // label pointing out the cause for the type coercion will be wrong\n+                        // as prior return coercions would not be relevant (#57664).\n+                        let parent_id = fcx.tcx.hir().get_parent_node(blk_id);\n+                        let parent = fcx.tcx.hir().get(fcx.tcx.hir().get_parent_node(parent_id));\n+                        if fcx.get_node_fn_decl(parent).is_some() && !pointing_at_return_type {\n+                            if let Some(sp) = fcx.ret_coercion_span.borrow().as_ref() {\n                                 db.span_label(*sp, reason_label);\n                             }\n                         }\n                     }\n-                    _ => {\n+                    ObligationCauseCode::ReturnType(_id) => {\n                         db = fcx.report_mismatched_types(cause, expected, found, err);\n-                        if let Some(sp) = fcx.ret_coercion_span.borrow().as_ref() {\n+                        let _id = fcx.tcx.hir().get_parent_node(_id);\n+                        let mut pointing_at_return_type = false;\n+                        if let Some((fn_decl, can_suggest)) = fcx.get_fn_decl(_id) {\n+                            pointing_at_return_type = fcx.suggest_missing_return_type(\n+                                &mut db, &fn_decl, expected, found, can_suggest);\n+                        }\n+                        if let (Some(sp), false) = (\n+                            fcx.ret_coercion_span.borrow().as_ref(),\n+                            pointing_at_return_type,\n+                        ) {\n                             if !sp.overlaps(cause.span) {\n                                 db.span_label(*sp, reason_label);\n                             }\n                         }\n                     }\n+                    _ => {\n+                        db = fcx.report_mismatched_types(cause, expected, found, err);\n+                    }\n                 }\n \n                 if let Some(augment_error) = augment_error {"}, {"sha": "c9173dfea940cbe0f0ccdedfd3d8d32d60bf5b8e", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 35, "deletions": 29, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/0c0c585281740aba4c91cbfd385f5e1fbe313d11/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c0c585281740aba4c91cbfd385f5e1fbe313d11/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=0c0c585281740aba4c91cbfd385f5e1fbe313d11", "patch": "@@ -4347,11 +4347,15 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     struct_span_err!(self.tcx.sess, expr.span, E0572,\n                                      \"return statement outside of function body\").emit();\n                 } else if let Some(ref e) = *expr_opt {\n-                    *self.ret_coercion_span.borrow_mut() = Some(e.span);\n+                    if self.ret_coercion_span.borrow().is_none() {\n+                        *self.ret_coercion_span.borrow_mut() = Some(e.span);\n+                    }\n                     self.check_return_expr(e);\n                 } else {\n                     let mut coercion = self.ret_coercion.as_ref().unwrap().borrow_mut();\n-                    *self.ret_coercion_span.borrow_mut() = Some(expr.span);\n+                    if self.ret_coercion_span.borrow().is_none() {\n+                        *self.ret_coercion_span.borrow_mut() = Some(expr.span);\n+                    }\n                     let cause = self.cause(expr.span, ObligationCauseCode::ReturnNoExpression);\n                     if let Some((fn_decl, _)) = self.get_fn_decl(expr.id) {\n                         coercion.coerce_forced_unit(\n@@ -4840,15 +4844,11 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     pub fn check_stmt(&self, stmt: &'gcx hir::Stmt) {\n         // Don't do all the complex logic below for `DeclItem`.\n         match stmt.node {\n-            hir::StmtKind::Decl(ref decl, _) => {\n-                if let hir::DeclKind::Item(_) = decl.node {\n-                    return\n-                }\n-            }\n-            hir::StmtKind::Expr(..) | hir::StmtKind::Semi(..) => {}\n+            hir::StmtKind::Item(..) => return,\n+            hir::StmtKind::Local(..) | hir::StmtKind::Expr(..) | hir::StmtKind::Semi(..) => {}\n         }\n \n-        self.warn_if_unreachable(stmt.node.id(), stmt.span, \"statement\");\n+        self.warn_if_unreachable(stmt.id, stmt.span, \"statement\");\n \n         // Hide the outer diverging and `has_errors` flags.\n         let old_diverges = self.diverges.get();\n@@ -4857,20 +4857,16 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         self.has_errors.set(false);\n \n         match stmt.node {\n-            hir::StmtKind::Decl(ref decl, _) => {\n-                match decl.node {\n-                    hir::DeclKind::Local(ref l) => {\n-                        self.check_decl_local(&l);\n-                    }\n-                    // Ignore for now.\n-                    hir::DeclKind::Item(_) => ()\n-                }\n+            hir::StmtKind::Local(ref l) => {\n+                self.check_decl_local(&l);\n             }\n-            hir::StmtKind::Expr(ref expr, _) => {\n+            // Ignore for now.\n+            hir::StmtKind::Item(_) => {}\n+            hir::StmtKind::Expr(ref expr) => {\n                 // Check with expected type of `()`.\n                 self.check_expr_has_type_or_error(&expr, self.tcx.mk_unit());\n             }\n-            hir::StmtKind::Semi(ref expr, _) => {\n+            hir::StmtKind::Semi(ref expr) => {\n                 self.check_expr(&expr);\n             }\n         }\n@@ -5089,12 +5085,15 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         found: Ty<'tcx>,\n         cause_span: Span,\n         blk_id: ast::NodeId,\n-    ) {\n+    ) -> bool {\n         self.suggest_missing_semicolon(err, expression, expected, cause_span);\n+        let mut pointing_at_return_type = false;\n         if let Some((fn_decl, can_suggest)) = self.get_fn_decl(blk_id) {\n-            self.suggest_missing_return_type(err, &fn_decl, expected, found, can_suggest);\n+            pointing_at_return_type = self.suggest_missing_return_type(\n+                err, &fn_decl, expected, found, can_suggest);\n         }\n         self.suggest_ref_or_into(err, expression, expected, found);\n+        pointing_at_return_type\n     }\n \n     pub fn suggest_ref_or_into(\n@@ -5193,12 +5192,14 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     /// This routine checks if the return type is left as default, the method is not part of an\n     /// `impl` block and that it isn't the `main` method. If so, it suggests setting the return\n     /// type.\n-    fn suggest_missing_return_type(&self,\n-                                   err: &mut DiagnosticBuilder<'tcx>,\n-                                   fn_decl: &hir::FnDecl,\n-                                   expected: Ty<'tcx>,\n-                                   found: Ty<'tcx>,\n-                                   can_suggest: bool) {\n+    fn suggest_missing_return_type(\n+        &self,\n+        err: &mut DiagnosticBuilder<'tcx>,\n+        fn_decl: &hir::FnDecl,\n+        expected: Ty<'tcx>,\n+        found: Ty<'tcx>,\n+        can_suggest: bool,\n+    ) -> bool {\n         // Only suggest changing the return type for methods that\n         // haven't set a return type at all (and aren't `fn main()` or an impl).\n         match (&fn_decl.output, found.is_suggestable(), can_suggest, expected.is_unit()) {\n@@ -5208,16 +5209,19 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     \"try adding a return type\",\n                     format!(\"-> {} \", self.resolve_type_vars_with_obligations(found)),\n                     Applicability::MachineApplicable);\n+                true\n             }\n             (&hir::FunctionRetTy::DefaultReturn(span), false, true, true) => {\n                 err.span_label(span, \"possibly return type missing here?\");\n+                true\n             }\n             (&hir::FunctionRetTy::DefaultReturn(span), _, false, true) => {\n                 // `fn main()` must return `()`, do not suggest changing return type\n                 err.span_label(span, \"expected `()` because of default return type\");\n+                true\n             }\n             // expectation was caused by something else, not the default return\n-            (&hir::FunctionRetTy::DefaultReturn(_), _, _, false) => {}\n+            (&hir::FunctionRetTy::DefaultReturn(_), _, _, false) => false,\n             (&hir::FunctionRetTy::Return(ref ty), _, _, _) => {\n                 // Only point to return type if the expected type is the return type, as if they\n                 // are not, the expectation must have been caused by something else.\n@@ -5229,7 +5233,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 if ty.sty == expected.sty {\n                     err.span_label(sp, format!(\"expected `{}` because of return type\",\n                                                expected));\n+                    return true;\n                 }\n+                false\n             }\n         }\n     }\n@@ -5273,7 +5279,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             None => return None,\n         };\n         let last_expr = match last_stmt.node {\n-            hir::StmtKind::Semi(ref e, _) => e,\n+            hir::StmtKind::Semi(ref e) => e,\n             _ => return None,\n         };\n         let last_expr_ty = self.node_ty(last_expr.hir_id);"}, {"sha": "47bb5e475b473e5ee4ff2886e04fcb6dbc39bb74", "filename": "src/test/ui/fully-qualified-type/fully-qualified-type-name2.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c0c585281740aba4c91cbfd385f5e1fbe313d11/src%2Ftest%2Fui%2Ffully-qualified-type%2Ffully-qualified-type-name2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0c0c585281740aba4c91cbfd385f5e1fbe313d11/src%2Ftest%2Fui%2Ffully-qualified-type%2Ffully-qualified-type-name2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffully-qualified-type%2Ffully-qualified-type-name2.stderr?ref=0c0c585281740aba4c91cbfd385f5e1fbe313d11", "patch": "@@ -1,6 +1,8 @@\n error[E0308]: mismatched types\n   --> $DIR/fully-qualified-type-name2.rs:12:12\n    |\n+LL | fn bar(x: x::Foo) -> y::Foo {\n+   |                      ------ expected `y::Foo` because of return type\n LL |     return x;\n    |            ^ expected enum `y::Foo`, found enum `x::Foo`\n    |"}, {"sha": "b341879ab919afaf78070b8058ad81f129da47a8", "filename": "src/test/ui/fully-qualified-type/fully-qualified-type-name4.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c0c585281740aba4c91cbfd385f5e1fbe313d11/src%2Ftest%2Fui%2Ffully-qualified-type%2Ffully-qualified-type-name4.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0c0c585281740aba4c91cbfd385f5e1fbe313d11/src%2Ftest%2Fui%2Ffully-qualified-type%2Ffully-qualified-type-name4.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffully-qualified-type%2Ffully-qualified-type-name4.stderr?ref=0c0c585281740aba4c91cbfd385f5e1fbe313d11", "patch": "@@ -1,6 +1,8 @@\n error[E0308]: mismatched types\n   --> $DIR/fully-qualified-type-name4.rs:6:12\n    |\n+LL | fn bar(x: usize) -> Option<usize> {\n+   |                     ------------- expected `std::option::Option<usize>` because of return type\n LL |     return x;\n    |            ^ expected enum `std::option::Option`, found usize\n    |"}, {"sha": "a970b80fdbbd93e9da12b018c0207f75487675a5", "filename": "src/test/ui/liveness/liveness-forgot-ret.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c0c585281740aba4c91cbfd385f5e1fbe313d11/src%2Ftest%2Fui%2Fliveness%2Fliveness-forgot-ret.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0c0c585281740aba4c91cbfd385f5e1fbe313d11/src%2Ftest%2Fui%2Fliveness%2Fliveness-forgot-ret.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fliveness%2Fliveness-forgot-ret.stderr?ref=0c0c585281740aba4c91cbfd385f5e1fbe313d11", "patch": "@@ -2,7 +2,7 @@ error[E0308]: mismatched types\n   --> $DIR/liveness-forgot-ret.rs:3:19\n    |\n LL | fn f(a: isize) -> isize { if god_exists(a) { return 5; }; }\n-   |    -              ^^^^^ expected isize, found ()    - expected because of this statement\n+   |    -              ^^^^^ expected isize, found ()\n    |    |\n    |    this function's body doesn't return\n    |"}, {"sha": "50f1fe873cb5fa1cd96f0eb31a185c3c161d4299", "filename": "src/test/ui/point-to-type-err-cause-on-impl-trait-return-2.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/0c0c585281740aba4c91cbfd385f5e1fbe313d11/src%2Ftest%2Fui%2Fpoint-to-type-err-cause-on-impl-trait-return-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c0c585281740aba4c91cbfd385f5e1fbe313d11/src%2Ftest%2Fui%2Fpoint-to-type-err-cause-on-impl-trait-return-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpoint-to-type-err-cause-on-impl-trait-return-2.rs?ref=0c0c585281740aba4c91cbfd385f5e1fbe313d11", "patch": "@@ -0,0 +1,17 @@\n+fn unrelated() -> Result<(), std::string::ParseError> {  // #57664\n+    let x = 0;\n+\n+    match x {\n+        1 => {\n+            let property_value_as_string = \"a\".parse()?;\n+        }\n+        2 => {\n+            let value: &bool = unsafe { &42 };\n+            //~^ ERROR mismatched types\n+        }\n+    };\n+\n+    Ok(())\n+}\n+\n+fn main() {}"}, {"sha": "edaa60e5b8d8b84a8cd8025b62ca7321cc85b299", "filename": "src/test/ui/point-to-type-err-cause-on-impl-trait-return-2.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0c0c585281740aba4c91cbfd385f5e1fbe313d11/src%2Ftest%2Fui%2Fpoint-to-type-err-cause-on-impl-trait-return-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0c0c585281740aba4c91cbfd385f5e1fbe313d11/src%2Ftest%2Fui%2Fpoint-to-type-err-cause-on-impl-trait-return-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpoint-to-type-err-cause-on-impl-trait-return-2.stderr?ref=0c0c585281740aba4c91cbfd385f5e1fbe313d11", "patch": "@@ -0,0 +1,12 @@\n+error[E0308]: mismatched types\n+  --> $DIR/point-to-type-err-cause-on-impl-trait-return-2.rs:9:41\n+   |\n+LL |             let value: &bool = unsafe { &42 };\n+   |                                         ^^^ expected bool, found integer\n+   |\n+   = note: expected type `&bool`\n+              found type `&{integer}`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "95b40368143efd6da0d1ec9be7c02153015ba075", "filename": "src/test/ui/point-to-type-err-cause-on-impl-trait-return.rs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/0c0c585281740aba4c91cbfd385f5e1fbe313d11/src%2Ftest%2Fui%2Fpoint-to-type-err-cause-on-impl-trait-return.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c0c585281740aba4c91cbfd385f5e1fbe313d11/src%2Ftest%2Fui%2Fpoint-to-type-err-cause-on-impl-trait-return.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpoint-to-type-err-cause-on-impl-trait-return.rs?ref=0c0c585281740aba4c91cbfd385f5e1fbe313d11", "patch": "@@ -0,0 +1,36 @@\n+fn foo() -> impl std::fmt::Display {\n+    if false {\n+        return 0i32;\n+    }\n+    1u32\n+    //~^ ERROR mismatched types\n+}\n+\n+fn bar() -> impl std::fmt::Display {\n+    if false {\n+        return 0i32;\n+    } else {\n+        return 1u32;\n+        //~^ ERROR mismatched types\n+    }\n+}\n+\n+fn baz() -> impl std::fmt::Display {\n+    if false {\n+    //~^ ERROR mismatched types\n+        return 0i32;\n+    } else {\n+        1u32\n+    }\n+}\n+\n+fn qux() -> impl std::fmt::Display {\n+    if false {\n+        0i32\n+    } else {\n+        1u32\n+        //~^ ERROR if and else have incompatible types\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "62da0787b02a9350dba5b7eaa871076ca0cd6f90", "filename": "src/test/ui/point-to-type-err-cause-on-impl-trait-return.stderr", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/0c0c585281740aba4c91cbfd385f5e1fbe313d11/src%2Ftest%2Fui%2Fpoint-to-type-err-cause-on-impl-trait-return.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0c0c585281740aba4c91cbfd385f5e1fbe313d11/src%2Ftest%2Fui%2Fpoint-to-type-err-cause-on-impl-trait-return.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpoint-to-type-err-cause-on-impl-trait-return.stderr?ref=0c0c585281740aba4c91cbfd385f5e1fbe313d11", "patch": "@@ -0,0 +1,58 @@\n+error[E0308]: mismatched types\n+  --> $DIR/point-to-type-err-cause-on-impl-trait-return.rs:5:5\n+   |\n+LL |         return 0i32;\n+   |                ---- expected because of this statement\n+LL |     }\n+LL |     1u32\n+   |     ^^^^ expected i32, found u32\n+   |\n+   = note: expected type `i32`\n+              found type `u32`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/point-to-type-err-cause-on-impl-trait-return.rs:13:16\n+   |\n+LL |         return 0i32;\n+   |                ---- expected because of this statement\n+LL |     } else {\n+LL |         return 1u32;\n+   |                ^^^^ expected i32, found u32\n+   |\n+   = note: expected type `i32`\n+              found type `u32`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/point-to-type-err-cause-on-impl-trait-return.rs:19:5\n+   |\n+LL | /     if false {\n+LL | |     //~^ ERROR mismatched types\n+LL | |         return 0i32;\n+   | |                ---- expected because of this statement\n+LL | |     } else {\n+LL | |         1u32\n+LL | |     }\n+   | |_____^ expected i32, found u32\n+   |\n+   = note: expected type `i32`\n+              found type `u32`\n+\n+error[E0308]: if and else have incompatible types\n+  --> $DIR/point-to-type-err-cause-on-impl-trait-return.rs:31:9\n+   |\n+LL | /     if false {\n+LL | |         0i32\n+   | |         ---- expected because of this\n+LL | |     } else {\n+LL | |         1u32\n+   | |         ^^^^ expected i32, found u32\n+LL | |         //~^ ERROR if and else have incompatible types\n+LL | |     }\n+   | |_____- if and else have incompatible types\n+   |\n+   = note: expected type `i32`\n+              found type `u32`\n+\n+error: aborting due to 4 previous errors\n+\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "db524907b656f4760625c69c1cd1583bf8b52757", "filename": "src/test/ui/proc-macro/span-preservation.stderr", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0c0c585281740aba4c91cbfd385f5e1fbe313d11/src%2Ftest%2Fui%2Fproc-macro%2Fspan-preservation.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0c0c585281740aba4c91cbfd385f5e1fbe313d11/src%2Ftest%2Fui%2Fproc-macro%2Fspan-preservation.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fspan-preservation.stderr?ref=0c0c585281740aba4c91cbfd385f5e1fbe313d11", "patch": "@@ -15,6 +15,9 @@ LL |     let x: usize = \"hello\";;;;; //~ ERROR mismatched types\n error[E0308]: mismatched types\n   --> $DIR/span-preservation.rs:19:29\n    |\n+LL | fn b(x: Option<isize>) -> usize {\n+   |                           ----- expected `usize` because of return type\n+LL |     match x {\n LL |         Some(x) => { return x }, //~ ERROR mismatched types\n    |                             ^ expected usize, found isize\n "}, {"sha": "2862ae641df15b3341c6700cfd3f786e08a6a687", "filename": "src/test/ui/return/return-from-diverging.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c0c585281740aba4c91cbfd385f5e1fbe313d11/src%2Ftest%2Fui%2Freturn%2Freturn-from-diverging.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0c0c585281740aba4c91cbfd385f5e1fbe313d11/src%2Ftest%2Fui%2Freturn%2Freturn-from-diverging.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Freturn%2Freturn-from-diverging.stderr?ref=0c0c585281740aba4c91cbfd385f5e1fbe313d11", "patch": "@@ -1,6 +1,8 @@\n error[E0308]: mismatched types\n   --> $DIR/return-from-diverging.rs:4:12\n    |\n+LL | fn fail() -> ! {\n+   |              - expected `!` because of return type\n LL |     return \"wow\"; //~ ERROR mismatched types\n    |            ^^^^^ expected !, found reference\n    |"}, {"sha": "1170f5c17c18ab648658a716562dec311259ef48", "filename": "src/test/ui/tail-typeck.stderr", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0c0c585281740aba4c91cbfd385f5e1fbe313d11/src%2Ftest%2Fui%2Ftail-typeck.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0c0c585281740aba4c91cbfd385f5e1fbe313d11/src%2Ftest%2Fui%2Ftail-typeck.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftail-typeck.stderr?ref=0c0c585281740aba4c91cbfd385f5e1fbe313d11", "patch": "@@ -2,7 +2,9 @@ error[E0308]: mismatched types\n   --> $DIR/tail-typeck.rs:3:26\n    |\n LL | fn f() -> isize { return g(); }\n-   |                          ^^^ expected isize, found usize\n+   |           -----          ^^^ expected isize, found usize\n+   |           |\n+   |           expected `isize` because of return type\n \n error: aborting due to previous error\n "}, {"sha": "cf59f42683d721647c54a17bfcf7165d6730b5f0", "filename": "src/test/ui/wrong-ret-type.stderr", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0c0c585281740aba4c91cbfd385f5e1fbe313d11/src%2Ftest%2Fui%2Fwrong-ret-type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0c0c585281740aba4c91cbfd385f5e1fbe313d11/src%2Ftest%2Fui%2Fwrong-ret-type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fwrong-ret-type.stderr?ref=0c0c585281740aba4c91cbfd385f5e1fbe313d11", "patch": "@@ -2,7 +2,9 @@ error[E0308]: mismatched types\n   --> $DIR/wrong-ret-type.rs:2:49\n    |\n LL | fn mk_int() -> usize { let i: isize = 3; return i; }\n-   |                                                 ^ expected usize, found isize\n+   |                -----                            ^ expected usize, found isize\n+   |                |\n+   |                expected `usize` because of return type\n \n error: aborting due to previous error\n "}]}