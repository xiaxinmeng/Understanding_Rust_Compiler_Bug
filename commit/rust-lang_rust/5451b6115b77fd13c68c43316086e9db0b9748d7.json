{"sha": "5451b6115b77fd13c68c43316086e9db0b9748d7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU0NTFiNjExNWI3N2ZkMTNjNjhjNDMzMTYwODZlOWRiMGI5NzQ4ZDc=", "commit": {"author": {"name": "Scott Olson", "email": "scott@solson.me", "date": "2016-03-24T03:40:58Z"}, "committer": {"name": "Scott Olson", "email": "scott@solson.me", "date": "2016-03-24T03:40:58Z"}, "message": "Reorganize memory methods.", "tree": {"sha": "0ee954f72b6b8b378bf3c92f72af361aabde2349", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0ee954f72b6b8b378bf3c92f72af361aabde2349"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5451b6115b77fd13c68c43316086e9db0b9748d7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5451b6115b77fd13c68c43316086e9db0b9748d7", "html_url": "https://github.com/rust-lang/rust/commit/5451b6115b77fd13c68c43316086e9db0b9748d7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5451b6115b77fd13c68c43316086e9db0b9748d7/comments", "author": {"login": "solson", "id": 26806, "node_id": "MDQ6VXNlcjI2ODA2", "avatar_url": "https://avatars.githubusercontent.com/u/26806?v=4", "gravatar_id": "", "url": "https://api.github.com/users/solson", "html_url": "https://github.com/solson", "followers_url": "https://api.github.com/users/solson/followers", "following_url": "https://api.github.com/users/solson/following{/other_user}", "gists_url": "https://api.github.com/users/solson/gists{/gist_id}", "starred_url": "https://api.github.com/users/solson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/solson/subscriptions", "organizations_url": "https://api.github.com/users/solson/orgs", "repos_url": "https://api.github.com/users/solson/repos", "events_url": "https://api.github.com/users/solson/events{/privacy}", "received_events_url": "https://api.github.com/users/solson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "solson", "id": 26806, "node_id": "MDQ6VXNlcjI2ODA2", "avatar_url": "https://avatars.githubusercontent.com/u/26806?v=4", "gravatar_id": "", "url": "https://api.github.com/users/solson", "html_url": "https://github.com/solson", "followers_url": "https://api.github.com/users/solson/followers", "following_url": "https://api.github.com/users/solson/following{/other_user}", "gists_url": "https://api.github.com/users/solson/gists{/gist_id}", "starred_url": "https://api.github.com/users/solson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/solson/subscriptions", "organizations_url": "https://api.github.com/users/solson/orgs", "repos_url": "https://api.github.com/users/solson/repos", "events_url": "https://api.github.com/users/solson/events{/privacy}", "received_events_url": "https://api.github.com/users/solson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "87458955ddf1c819d31b7709298b4ba43aea88ab", "url": "https://api.github.com/repos/rust-lang/rust/commits/87458955ddf1c819d31b7709298b4ba43aea88ab", "html_url": "https://github.com/rust-lang/rust/commit/87458955ddf1c819d31b7709298b4ba43aea88ab"}], "stats": {"total": 122, "additions": 69, "deletions": 53}, "files": [{"sha": "a6d6cae1386d2789d57cf56b51032430df2b6559", "filename": "src/memory.rs", "status": "modified", "additions": 69, "deletions": 53, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/5451b6115b77fd13c68c43316086e9db0b9748d7/src%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5451b6115b77fd13c68c43316086e9db0b9748d7/src%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmemory.rs?ref=5451b6115b77fd13c68c43316086e9db0b9748d7", "patch": "@@ -7,12 +7,6 @@ use std::ptr;\n use error::{EvalError, EvalResult};\n use primval::PrimVal;\n \n-pub struct Memory {\n-    alloc_map: HashMap<u64, Allocation>,\n-    next_id: u64,\n-    pub pointer_size: usize,\n-}\n-\n #[derive(Copy, Clone, Debug, Eq, PartialEq)]\n pub struct AllocId(u64);\n \n@@ -29,6 +23,12 @@ pub struct Pointer {\n     pub offset: usize,\n }\n \n+impl Pointer {\n+    pub fn offset(self, i: isize) -> Self {\n+        Pointer { offset: (self.offset as isize + i) as usize, ..self }\n+    }\n+}\n+\n #[derive(Copy, Clone, Debug, Eq, PartialEq)]\n pub struct FieldRepr {\n     pub offset: usize,\n@@ -63,6 +63,22 @@ pub enum Repr {\n     },\n }\n \n+impl Repr {\n+    pub fn size(&self) -> usize {\n+        match *self {\n+            Repr::Primitive { size } => size,\n+            Repr::Aggregate { size, .. } => size,\n+            Repr::Array { elem_size, length } => elem_size * length,\n+        }\n+    }\n+}\n+\n+pub struct Memory {\n+    alloc_map: HashMap<u64, Allocation>,\n+    next_id: u64,\n+    pub pointer_size: usize,\n+}\n+\n impl Memory {\n     pub fn new() -> Self {\n         Memory {\n@@ -88,6 +104,10 @@ impl Memory {\n         }\n     }\n \n+    ////////////////////////////////////////////////////////////////////////////////\n+    // Allocation accessors\n+    ////////////////////////////////////////////////////////////////////////////////\n+\n     pub fn get(&self, id: AllocId) -> EvalResult<&Allocation> {\n         self.alloc_map.get(&id.0).ok_or(EvalError::DanglingPointerDeref)\n     }\n@@ -96,6 +116,10 @@ impl Memory {\n         self.alloc_map.get_mut(&id.0).ok_or(EvalError::DanglingPointerDeref)\n     }\n \n+    ////////////////////////////////////////////////////////////////////////////////\n+    // Byte accessors\n+    ////////////////////////////////////////////////////////////////////////////////\n+\n     fn get_bytes_unchecked(&self, ptr: Pointer, size: usize) -> EvalResult<&[u8]> {\n         let alloc = try!(self.get(ptr.alloc_id));\n         if ptr.offset + size > alloc.bytes.len() {\n@@ -125,42 +149,9 @@ impl Memory {\n         self.get_bytes_unchecked_mut(ptr, size)\n     }\n \n-    fn relocations(&self, ptr: Pointer, size: usize)\n-        -> EvalResult<btree_map::Range<usize, AllocId>>\n-    {\n-        let start = ptr.offset.saturating_sub(self.pointer_size - 1);\n-        let end = start + size;\n-        Ok(try!(self.get(ptr.alloc_id)).relocations.range(Included(&start), Excluded(&end)))\n-    }\n-\n-    fn clear_relocations(&mut self, ptr: Pointer, size: usize) -> EvalResult<()> {\n-        let keys: Vec<_> = try!(self.relocations(ptr, size)).map(|(&k, _)| k).collect();\n-        let alloc = try!(self.get_mut(ptr.alloc_id));\n-        for k in keys {\n-            alloc.relocations.remove(&k);\n-        }\n-        Ok(())\n-    }\n-\n-    fn check_relocation_edges(&self, ptr: Pointer, size: usize) -> EvalResult<()> {\n-        let overlapping_start = try!(self.relocations(ptr, 0)).count();\n-        let overlapping_end = try!(self.relocations(ptr.offset(size as isize), 0)).count();\n-        if overlapping_start + overlapping_end != 0 {\n-            return Err(EvalError::ReadPointerAsBytes);\n-        }\n-        Ok(())\n-    }\n-\n-    fn copy_relocations(&mut self, src: Pointer, dest: Pointer, size: usize) -> EvalResult<()> {\n-        let relocations: Vec<_> = try!(self.relocations(src, size))\n-            .map(|(&offset, &alloc_id)| {\n-                // Update relocation offsets for the new positions in the destination allocation.\n-                (offset + dest.offset - src.offset, alloc_id)\n-            })\n-            .collect();\n-        try!(self.get_mut(dest.alloc_id)).relocations.extend(relocations);\n-        Ok(())\n-    }\n+    ////////////////////////////////////////////////////////////////////////////////\n+    // Reading and writing\n+    ////////////////////////////////////////////////////////////////////////////////\n \n     pub fn copy(&mut self, src: Pointer, dest: Pointer, size: usize) -> EvalResult<()> {\n         // TODO(tsion): Track and check for undef bytes.\n@@ -271,20 +262,45 @@ impl Memory {\n         let size = self.pointer_size;\n         self.write_uint(ptr, n, size)\n     }\n-}\n \n-impl Pointer {\n-    pub fn offset(self, i: isize) -> Self {\n-        Pointer { offset: (self.offset as isize + i) as usize, ..self }\n+    ////////////////////////////////////////////////////////////////////////////////\n+    // Relocations\n+    ////////////////////////////////////////////////////////////////////////////////\n+\n+    fn relocations(&self, ptr: Pointer, size: usize)\n+        -> EvalResult<btree_map::Range<usize, AllocId>>\n+    {\n+        let start = ptr.offset.saturating_sub(self.pointer_size - 1);\n+        let end = start + size;\n+        Ok(try!(self.get(ptr.alloc_id)).relocations.range(Included(&start), Excluded(&end)))\n     }\n-}\n \n-impl Repr {\n-    pub fn size(&self) -> usize {\n-        match *self {\n-            Repr::Primitive { size } => size,\n-            Repr::Aggregate { size, .. } => size,\n-            Repr::Array { elem_size, length } => elem_size * length,\n+    fn clear_relocations(&mut self, ptr: Pointer, size: usize) -> EvalResult<()> {\n+        let keys: Vec<_> = try!(self.relocations(ptr, size)).map(|(&k, _)| k).collect();\n+        let alloc = try!(self.get_mut(ptr.alloc_id));\n+        for k in keys {\n+            alloc.relocations.remove(&k);\n         }\n+        Ok(())\n+    }\n+\n+    fn check_relocation_edges(&self, ptr: Pointer, size: usize) -> EvalResult<()> {\n+        let overlapping_start = try!(self.relocations(ptr, 0)).count();\n+        let overlapping_end = try!(self.relocations(ptr.offset(size as isize), 0)).count();\n+        if overlapping_start + overlapping_end != 0 {\n+            return Err(EvalError::ReadPointerAsBytes);\n+        }\n+        Ok(())\n+    }\n+\n+    fn copy_relocations(&mut self, src: Pointer, dest: Pointer, size: usize) -> EvalResult<()> {\n+        let relocations: Vec<_> = try!(self.relocations(src, size))\n+            .map(|(&offset, &alloc_id)| {\n+                // Update relocation offsets for the new positions in the destination allocation.\n+                (offset + dest.offset - src.offset, alloc_id)\n+            })\n+            .collect();\n+        try!(self.get_mut(dest.alloc_id)).relocations.extend(relocations);\n+        Ok(())\n     }\n }"}]}