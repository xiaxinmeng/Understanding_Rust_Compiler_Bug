{"sha": "d394e75ef6b6b8ea41e62bcbd3023a3e29eb4ee7", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQzOTRlNzVlZjZiNmI4ZWE0MWU2MmJjYmQzMDIzYTNlMjllYjRlZTc=", "commit": {"author": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2016-11-12T21:20:02Z"}, "committer": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2016-11-12T21:20:25Z"}, "message": "address review comments", "tree": {"sha": "1ce334f25808b9794c3db00d4e5bcea40ac0829a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1ce334f25808b9794c3db00d4e5bcea40ac0829a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d394e75ef6b6b8ea41e62bcbd3023a3e29eb4ee7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d394e75ef6b6b8ea41e62bcbd3023a3e29eb4ee7", "html_url": "https://github.com/rust-lang/rust/commit/d394e75ef6b6b8ea41e62bcbd3023a3e29eb4ee7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d394e75ef6b6b8ea41e62bcbd3023a3e29eb4ee7/comments", "author": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "committer": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "57950982b27c6ab45509c1f2db4a01fa1d2cfebb", "url": "https://api.github.com/repos/rust-lang/rust/commits/57950982b27c6ab45509c1f2db4a01fa1d2cfebb", "html_url": "https://github.com/rust-lang/rust/commit/57950982b27c6ab45509c1f2db4a01fa1d2cfebb"}], "stats": {"total": 153, "additions": 80, "deletions": 73}, "files": [{"sha": "2d4b36ec187603fc7aa442d678477afd0903c498", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d394e75ef6b6b8ea41e62bcbd3023a3e29eb4ee7/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d394e75ef6b6b8ea41e62bcbd3023a3e29eb4ee7/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=d394e75ef6b6b8ea41e62bcbd3023a3e29eb4ee7", "patch": "@@ -1150,10 +1150,6 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         self.tcx.mk_var(self.next_ty_var_id(true))\n     }\n \n-    pub fn next_ty_vars(&self, n: usize) -> Vec<Ty<'tcx>> {\n-        (0..n).map(|_i| self.next_ty_var()).collect()\n-    }\n-\n     pub fn next_int_var_id(&self) -> IntVid {\n         self.int_unification_table\n             .borrow_mut()"}, {"sha": "41fcb09fb2dc7ef2c3eb324e7679900b1122d0fd", "filename": "src/librustc/ty/subst.rs", "status": "modified", "additions": 24, "deletions": 9, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/d394e75ef6b6b8ea41e62bcbd3023a3e29eb4ee7/src%2Flibrustc%2Fty%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d394e75ef6b6b8ea41e62bcbd3023a3e29eb4ee7/src%2Flibrustc%2Fty%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsubst.rs?ref=d394e75ef6b6b8ea41e62bcbd3023a3e29eb4ee7", "patch": "@@ -183,6 +183,22 @@ impl<'a, 'gcx, 'tcx> Substs<'tcx> {\n         tcx.intern_substs(&substs)\n     }\n \n+    pub fn extend_to<FR, FT>(&self,\n+                             tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+                             def_id: DefId,\n+                             mut mk_region: FR,\n+                             mut mk_type: FT)\n+                             -> &'tcx Substs<'tcx>\n+    where FR: FnMut(&ty::RegionParameterDef, &[Kind<'tcx>]) -> &'tcx ty::Region,\n+          FT: FnMut(&ty::TypeParameterDef<'tcx>, &[Kind<'tcx>]) -> Ty<'tcx>\n+    {\n+        let defs = tcx.item_generics(def_id);\n+        let mut result = Vec::with_capacity(defs.count());\n+        result.extend(self[..].iter().cloned());\n+        Substs::fill_single(&mut result, defs, &mut mk_region, &mut mk_type);\n+        tcx.intern_substs(&result)\n+    }\n+\n     fn fill_item<FR, FT>(substs: &mut Vec<Kind<'tcx>>,\n                          tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                          defs: &ty::Generics<'tcx>,\n@@ -195,7 +211,15 @@ impl<'a, 'gcx, 'tcx> Substs<'tcx> {\n             let parent_defs = tcx.item_generics(def_id);\n             Substs::fill_item(substs, tcx, parent_defs, mk_region, mk_type);\n         }\n+        Substs::fill_single(substs, defs, mk_region, mk_type)\n+    }\n \n+    fn fill_single<FR, FT>(substs: &mut Vec<Kind<'tcx>>,\n+                           defs: &ty::Generics<'tcx>,\n+                           mk_region: &mut FR,\n+                           mk_type: &mut FT)\n+    where FR: FnMut(&ty::RegionParameterDef, &[Kind<'tcx>]) -> &'tcx ty::Region,\n+          FT: FnMut(&ty::TypeParameterDef<'tcx>, &[Kind<'tcx>]) -> Ty<'tcx> {\n         // Handle Self first, before all regions.\n         let mut types = defs.types.iter();\n         if defs.parent.is_none() && defs.has_self {\n@@ -275,15 +299,6 @@ impl<'a, 'gcx, 'tcx> Substs<'tcx> {\n         tcx.mk_substs(target_substs.iter().chain(&self[defs.own_count()..]).cloned())\n     }\n \n-    pub fn extend_with_types(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                             types: &[Ty<'tcx>])\n-                             -> &'tcx Substs<'tcx> {\n-        tcx.mk_substs(\n-            self[..].iter().cloned().chain(\n-                types.iter().map(|a| Kind::from(*a)))\n-        )\n-    }\n-\n     pub fn truncate_to(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>, generics: &ty::Generics<'tcx>)\n                        -> &'tcx Substs<'tcx> {\n         tcx.mk_substs(self.iter().take(generics.count()).cloned())"}, {"sha": "75287d4064ae1df607a970ce8a9d1c12292e8df7", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 7, "deletions": 59, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/d394e75ef6b6b8ea41e62bcbd3023a3e29eb4ee7/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d394e75ef6b6b8ea41e62bcbd3023a3e29eb4ee7/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=d394e75ef6b6b8ea41e62bcbd3023a3e29eb4ee7", "patch": "@@ -13,16 +13,11 @@\n use super::{check_fn, Expectation, FnCtxt};\n \n use astconv::AstConv;\n-use rustc::hir::def_id::DefId;\n use rustc::ty::{self, ToPolyTraitRef, Ty};\n-use rustc::ty::subst::Substs;\n-use rustc::util::common::MemoizationMap;\n use std::cmp;\n use syntax::abi::Abi;\n use rustc::hir;\n \n-use syntax::parse::token;\n-\n impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     pub fn check_expr_closure(&self,\n                               expr: &hir::Expr,\n@@ -45,48 +40,6 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         self.check_closure(expr, expected_kind, decl, body, expected_sig)\n     }\n \n-    fn declare_closure(&self, def_id: DefId) {\n-        let tcx = self.tcx.global_tcx();\n-\n-        tcx.generics.memoize(def_id, || {\n-            let node_id = tcx.map.as_local_node_id(def_id).unwrap();\n-            let base_def_id = self.tcx.closure_base_def_id(def_id);\n-            let base_generics = tcx.item_generics(base_def_id);\n-\n-            // provide junk type parameter defs - the only place that\n-            // cares about anything but the length is instantiation,\n-            // and we don't do that for closures.\n-            let upvar_decls : Vec<_> = tcx.with_freevars(node_id, |fv| {\n-                fv.iter().enumerate().map(|(i, _)| ty::TypeParameterDef {\n-                    index: (base_generics.count() as u32) + (i as u32),\n-                    name: token::intern(\"<upvar>\"),\n-                    def_id: def_id,\n-                    default_def_id: base_def_id,\n-                    default: None,\n-                    object_lifetime_default: ty::ObjectLifetimeDefault::BaseDefault,\n-                    pure_wrt_drop: false,\n-                }).collect()\n-            });\n-\n-            tcx.alloc_generics(ty::Generics {\n-                parent: Some(base_def_id),\n-                parent_regions: base_generics.parent_regions +\n-                    (base_generics.regions.len() as u32),\n-                parent_types: base_generics.parent_types +\n-                    (base_generics.types.len() as u32),\n-                regions: vec![],\n-                types: upvar_decls,\n-                has_self: false,\n-            })\n-        });\n-\n-        tcx.item_types.memoize(def_id, || tcx.mk_closure(def_id, Substs::for_item(\n-            tcx, def_id,\n-            |def, _| tcx.mk_region(def.to_early_bound_region()),\n-            |def, _| tcx.mk_param_from_def(def)\n-        )));\n-    }\n-\n     fn check_closure(&self,\n                      expr: &hir::Expr,\n                      opt_kind: Option<ty::ClosureKind>,\n@@ -99,8 +52,6 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                expected_sig);\n \n         let expr_def_id = self.tcx.map.local_def_id(expr.id);\n-        self.declare_closure(expr_def_id);\n-\n         let mut fn_ty = AstConv::ty_of_closure(self,\n                                                hir::Unsafety::Normal,\n                                                decl,\n@@ -110,18 +61,15 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // Create type variables (for now) to represent the transformed\n         // types of upvars. These will be unified during the upvar\n         // inference phase (`upvar.rs`).\n-        let num_upvars = self.tcx.with_freevars(expr.id, |fv| fv.len());\n-        let upvar_tys = self.next_ty_vars(num_upvars);\n-\n-        debug!(\"check_closure: expr.id={:?} upvar_tys={:?}\",\n-               expr.id,\n-               upvar_tys);\n-\n-        let closure_type = self.tcx.mk_closure(\n-            expr_def_id,\n-            self.parameter_environment.free_substs.extend_with_types(self.tcx, &upvar_tys)\n+        let closure_type = self.tcx.mk_closure(expr_def_id,\n+            self.parameter_environment.free_substs.extend_to(self.tcx, expr_def_id,\n+                |_, _| span_bug!(expr.span, \"closure has region param\"),\n+                |_, _| self.infcx.next_ty_var()\n+            )\n         );\n \n+        debug!(\"check_closure: expr.id={:?} closure_type={:?}\", expr.id, closure_type);\n+\n         let fn_sig = self.tcx\n             .liberate_late_bound_regions(self.tcx.region_maps.call_site_extent(expr.id, body.id),\n                                          &fn_ty.sig);"}, {"sha": "816243b3eab47082312578736ac19e650bd6e908", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 49, "deletions": 1, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/d394e75ef6b6b8ea41e62bcbd3023a3e29eb4ee7/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d394e75ef6b6b8ea41e62bcbd3023a3e29eb4ee7/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=d394e75ef6b6b8ea41e62bcbd3023a3e29eb4ee7", "patch": "@@ -80,7 +80,7 @@ use std::cell::RefCell;\n use std::collections::hash_map::Entry::{Occupied, Vacant};\n \n use syntax::{abi, ast, attr};\n-use syntax::parse::token::keywords;\n+use syntax::parse::token::{self, keywords};\n use syntax_pos::Span;\n \n use rustc::hir::{self, intravisit, map as hir_map, print as pprust};\n@@ -134,6 +134,13 @@ impl<'a, 'tcx, 'v> intravisit::Visitor<'v> for CollectItemTypesVisitor<'a, 'tcx>\n         intravisit::walk_item(self, item);\n     }\n \n+    fn visit_expr(&mut self, expr: &hir::Expr) {\n+        if let hir::ExprClosure(..) = expr.node {\n+            convert_closure(self.ccx, expr.id);\n+        }\n+        intravisit::walk_expr(self, expr);\n+    }\n+\n     fn visit_ty(&mut self, ty: &hir::Ty) {\n         if let hir::TyImplTrait(..) = ty.node {\n             let def_id = self.ccx.tcx.map.local_def_id(ty.id);\n@@ -559,6 +566,40 @@ fn convert_field<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     ccx.tcx.predicates.borrow_mut().insert(def_id, struct_predicates.clone());\n }\n \n+fn convert_closure<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n+                             node_id: ast::NodeId)\n+{\n+    let tcx = ccx.tcx;\n+    let def_id = tcx.map.local_def_id(node_id);\n+    let base_def_id = tcx.closure_base_def_id(def_id);\n+    let base_generics = generics_of_def_id(ccx, base_def_id);\n+\n+    // provide junk type parameter defs - the only place that\n+    // cares about anything but the length is instantiation,\n+    // and we don't do that for closures.\n+    let upvar_decls : Vec<_> = tcx.with_freevars(node_id, |fv| {\n+        fv.iter().enumerate().map(|(i, _)| ty::TypeParameterDef {\n+            index: (base_generics.count() as u32) + (i as u32),\n+            name: token::intern(\"<upvar>\"),\n+            def_id: def_id,\n+            default_def_id: base_def_id,\n+            default: None,\n+            object_lifetime_default: ty::ObjectLifetimeDefault::BaseDefault,\n+            pure_wrt_drop: false,\n+        }).collect()\n+    });\n+    tcx.generics.borrow_mut().insert(def_id, tcx.alloc_generics(ty::Generics {\n+        parent: Some(base_def_id),\n+        parent_regions: base_generics.parent_regions + (base_generics.regions.len() as u32),\n+        parent_types: base_generics.parent_types + (base_generics.types.len() as u32),\n+        regions: vec![],\n+        types: upvar_decls,\n+        has_self: base_generics.has_self,\n+    }));\n+\n+    type_of_def_id(ccx, def_id);\n+}\n+\n fn convert_method<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                             container: AssociatedItemContainer,\n                             id: ast::NodeId,\n@@ -1504,6 +1545,13 @@ fn type_of_def_id<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                     }\n                 }\n             }\n+            NodeExpr(&hir::Expr { node: hir::ExprClosure(..), .. }) => {\n+                ccx.tcx.mk_closure(def_id, Substs::for_item(\n+                    ccx.tcx, def_id,\n+                    |def, _| ccx.tcx.mk_region(def.to_early_bound_region()),\n+                    |def, _| ccx.tcx.mk_param_from_def(def)\n+                ))\n+            }\n             x => {\n                 bug!(\"unexpected sort of node in type_of_def_id(): {:?}\", x);\n             }"}]}