{"sha": "3aee654dd1be501c66d3f2c1813c5a6a93f666d0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNhZWU2NTRkZDFiZTUwMWM2NmQzZjJjMTgxM2M1YTZhOTNmNjY2ZDA=", "commit": {"author": {"name": "Oliver Schneider", "email": "github35764891676564198441@oli-obk.de", "date": "2018-06-29T08:20:19Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2018-06-29T08:20:19Z"}, "message": "Merge pull request #2880 from mati865/rustup_hir\n\nRustup", "tree": {"sha": "3eb7e5bc80a5bf6445cc828324d3268c24cab506", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3eb7e5bc80a5bf6445cc828324d3268c24cab506"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3aee654dd1be501c66d3f2c1813c5a6a93f666d0", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJbNevDCRBK7hj4Ov3rIwAAdHIIACm01EwQNYJw8w0mk6VeJ7iJ\nkBgZ/DsBhp5dkJO30AfSHDTBMgtMiJhPWqVe5Tp1Wa2I0iB+GoaymQPfUl1rnWTR\nCCmfwJtBzGJXVvyNui7qGGDjLoolTP1jDgTmYjQM87HpsxV5ZolNiqy5e3l1+9cH\n+p7tW4eKYH1H/h4wXDZsrYLjV0Jx4tGVUchbsjrkc1lphGnHjFdlEdZWt4NIJJpj\nqoTY725k4MObzqQWrvUPAiLBjdt78dLs+Cr2qGFoOnahvLlvWfyYx3KdM+kOmUVa\nx84TxgoTJzGVclVvq4UEyE1at3gHFW3WHeVxcH0d/dS1tvJ5MhRa34MO1N9Sosg=\n=ei+H\n-----END PGP SIGNATURE-----\n", "payload": "tree 3eb7e5bc80a5bf6445cc828324d3268c24cab506\nparent 656b26ea4f2b330ea5b9cb3cb38545587eac8f7f\nparent a24f77f65a60d689f2fde255f680bdf6ee87f065\nauthor Oliver Schneider <github35764891676564198441@oli-obk.de> 1530260419 +0200\ncommitter GitHub <noreply@github.com> 1530260419 +0200\n\nMerge pull request #2880 from mati865/rustup_hir\n\nRustup"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3aee654dd1be501c66d3f2c1813c5a6a93f666d0", "html_url": "https://github.com/rust-lang/rust/commit/3aee654dd1be501c66d3f2c1813c5a6a93f666d0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3aee654dd1be501c66d3f2c1813c5a6a93f666d0/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "656b26ea4f2b330ea5b9cb3cb38545587eac8f7f", "url": "https://api.github.com/repos/rust-lang/rust/commits/656b26ea4f2b330ea5b9cb3cb38545587eac8f7f", "html_url": "https://github.com/rust-lang/rust/commit/656b26ea4f2b330ea5b9cb3cb38545587eac8f7f"}, {"sha": "a24f77f65a60d689f2fde255f680bdf6ee87f065", "url": "https://api.github.com/repos/rust-lang/rust/commits/a24f77f65a60d689f2fde255f680bdf6ee87f065", "html_url": "https://github.com/rust-lang/rust/commit/a24f77f65a60d689f2fde255f680bdf6ee87f065"}], "stats": {"total": 383, "additions": 196, "deletions": 187}, "files": [{"sha": "43e723e51fd44e5238d07b2db9dcd678b8f742b4", "filename": "CHANGELOG.md", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3aee654dd1be501c66d3f2c1813c5a6a93f666d0/CHANGELOG.md", "raw_url": "https://github.com/rust-lang/rust/raw/3aee654dd1be501c66d3f2c1813c5a6a93f666d0/CHANGELOG.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CHANGELOG.md?ref=3aee654dd1be501c66d3f2c1813c5a6a93f666d0", "patch": "@@ -617,6 +617,7 @@ All notable changes to this project will be documented in this file.\n [`block_in_if_condition_expr`]: https://rust-lang-nursery.github.io/rust-clippy/master/index.html#block_in_if_condition_expr\n [`block_in_if_condition_stmt`]: https://rust-lang-nursery.github.io/rust-clippy/master/index.html#block_in_if_condition_stmt\n [`bool_comparison`]: https://rust-lang-nursery.github.io/rust-clippy/master/index.html#bool_comparison\n+[`borrow_interior_mutable_const`]: https://rust-lang-nursery.github.io/rust-clippy/master/index.html#borrow_interior_mutable_const\n [`borrowed_box`]: https://rust-lang-nursery.github.io/rust-clippy/master/index.html#borrowed_box\n [`box_vec`]: https://rust-lang-nursery.github.io/rust-clippy/master/index.html#box_vec\n [`boxed_local`]: https://rust-lang-nursery.github.io/rust-clippy/master/index.html#boxed_local\n@@ -641,6 +642,7 @@ All notable changes to this project will be documented in this file.\n [`crosspointer_transmute`]: https://rust-lang-nursery.github.io/rust-clippy/master/index.html#crosspointer_transmute\n [`cyclomatic_complexity`]: https://rust-lang-nursery.github.io/rust-clippy/master/index.html#cyclomatic_complexity\n [`decimal_literal_representation`]: https://rust-lang-nursery.github.io/rust-clippy/master/index.html#decimal_literal_representation\n+[`declare_interior_mutable_const`]: https://rust-lang-nursery.github.io/rust-clippy/master/index.html#declare_interior_mutable_const\n [`default_trait_access`]: https://rust-lang-nursery.github.io/rust-clippy/master/index.html#default_trait_access\n [`deprecated_semver`]: https://rust-lang-nursery.github.io/rust-clippy/master/index.html#deprecated_semver\n [`deref_addrof`]: https://rust-lang-nursery.github.io/rust-clippy/master/index.html#deref_addrof"}, {"sha": "05496fc1cccc45d0133de394624b0fcd4bfeda76", "filename": "README.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3aee654dd1be501c66d3f2c1813c5a6a93f666d0/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/3aee654dd1be501c66d3f2c1813c5a6a93f666d0/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=3aee654dd1be501c66d3f2c1813c5a6a93f666d0", "patch": "@@ -9,7 +9,7 @@ We are currently in the process of discussing Clippy 1.0 via the RFC process in\n \n A collection of lints to catch common mistakes and improve your [Rust](https://github.com/rust-lang/rust) code.\n \n-[There are 270 lints included in this crate!](https://rust-lang-nursery.github.io/rust-clippy/master/index.html)\n+[There are 272 lints included in this crate!](https://rust-lang-nursery.github.io/rust-clippy/master/index.html)\n \n We have a bunch of lint categories to allow you to choose how much clippy is supposed to ~~annoy~~ help you:\n "}, {"sha": "b9d8976b28b4f0ce72face771ca2f1b5b3021df2", "filename": "clippy_lints/src/attrs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3aee654dd1be501c66d3f2c1813c5a6a93f666d0/clippy_lints%2Fsrc%2Fattrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3aee654dd1be501c66d3f2c1813c5a6a93f666d0/clippy_lints%2Fsrc%2Fattrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fattrs.rs?ref=3aee654dd1be501c66d3f2c1813c5a6a93f666d0", "patch": "@@ -195,13 +195,13 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for AttrPass {\n \n     fn check_impl_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx ImplItem) {\n         if is_relevant_impl(cx.tcx, item) {\n-            check_attrs(cx, item.span, item.name, &item.attrs)\n+            check_attrs(cx, item.span, item.ident.name, &item.attrs)\n         }\n     }\n \n     fn check_trait_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx TraitItem) {\n         if is_relevant_trait(cx.tcx, item) {\n-            check_attrs(cx, item.span, item.name, &item.attrs)\n+            check_attrs(cx, item.span, item.ident.name, &item.attrs)\n         }\n     }\n }"}, {"sha": "29660399233038f7f33fb3bfcd9639329b2c04d4", "filename": "clippy_lints/src/blacklisted_name.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3aee654dd1be501c66d3f2c1813c5a6a93f666d0/clippy_lints%2Fsrc%2Fblacklisted_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3aee654dd1be501c66d3f2c1813c5a6a93f666d0/clippy_lints%2Fsrc%2Fblacklisted_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fblacklisted_name.rs?ref=3aee654dd1be501c66d3f2c1813c5a6a93f666d0", "patch": "@@ -41,13 +41,13 @@ impl LintPass for BlackListedName {\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for BlackListedName {\n     fn check_pat(&mut self, cx: &LateContext<'a, 'tcx>, pat: &'tcx Pat) {\n-        if let PatKind::Binding(_, _, ref ident, _) = pat.node {\n-            if self.blacklist.iter().any(|s| ident.node == *s) {\n+        if let PatKind::Binding(_, _, ident, _) = pat.node {\n+            if self.blacklist.iter().any(|s| ident.name == *s) {\n                 span_lint(\n                     cx,\n                     BLACKLISTED_NAME,\n                     ident.span,\n-                    &format!(\"use of a blacklisted/placeholder name `{}`\", ident.node),\n+                    &format!(\"use of a blacklisted/placeholder name `{}`\", ident.name),\n                 );\n             }\n         }"}, {"sha": "b541bfc6b2fdc2de693e9bd377c0affadc71ab25", "filename": "clippy_lints/src/booleans.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3aee654dd1be501c66d3f2c1813c5a6a93f666d0/clippy_lints%2Fsrc%2Fbooleans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3aee654dd1be501c66d3f2c1813c5a6a93f666d0/clippy_lints%2Fsrc%2Fbooleans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fbooleans.rs?ref=3aee654dd1be501c66d3f2c1813c5a6a93f666d0", "patch": "@@ -203,7 +203,7 @@ impl<'a, 'tcx, 'v> SuggestContext<'a, 'tcx, 'v> {\n                 METHODS_WITH_NEGATION\n                     .iter().cloned()\n                     .flat_map(|(a, b)| vec![(a, b), (b, a)])\n-                    .find(|&(a, _)| a == path.name.as_str())\n+                    .find(|&(a, _)| a == path.ident.as_str())\n                     .and_then(|(_, neg_method)| Some(format!(\"{}.{}()\", self.snip(&args[0])?, neg_method)))\n             },\n             _ => None,"}, {"sha": "6f2ea320f932ec5ef9ea0fd629111d8507d06002", "filename": "clippy_lints/src/bytecount.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3aee654dd1be501c66d3f2c1813c5a6a93f666d0/clippy_lints%2Fsrc%2Fbytecount.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3aee654dd1be501c66d3f2c1813c5a6a93f666d0/clippy_lints%2Fsrc%2Fbytecount.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fbytecount.rs?ref=3aee654dd1be501c66d3f2c1813c5a6a93f666d0", "patch": "@@ -39,10 +39,10 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ByteCount {\n     fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n         if_chain! {\n             if let ExprMethodCall(ref count, _, ref count_args) = expr.node;\n-            if count.name == \"count\";\n+            if count.ident.name == \"count\";\n             if count_args.len() == 1;\n             if let ExprMethodCall(ref filter, _, ref filter_args) = count_args[0].node;\n-            if filter.name == \"filter\";\n+            if filter.ident.name == \"filter\";\n             if filter_args.len() == 2;\n             if let ExprClosure(_, _, body_id, _, _) = filter_args[1].node;\n             then {\n@@ -68,7 +68,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ByteCount {\n                         }\n                         let haystack = if let ExprMethodCall(ref path, _, ref args) =\n                                 filter_args[0].node {\n-                            let p = path.name;\n+                            let p = path.ident.name;\n                             if (p == \"iter\" || p == \"iter_mut\") && args.len() == 1 {\n                                 &args[0]\n                             } else {\n@@ -104,7 +104,7 @@ fn get_path_name(expr: &Expr) -> Option<Name> {\n         } else {\n             None\n         },\n-        ExprPath(ref qpath) => single_segment_path(qpath).map(|ps| ps.name),\n+        ExprPath(ref qpath) => single_segment_path(qpath).map(|ps| ps.ident.name),\n         _ => None,\n     }\n }"}, {"sha": "430ff59cd4d32d8c483fc830b8b55749644044f2", "filename": "clippy_lints/src/copies.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3aee654dd1be501c66d3f2c1813c5a6a93f666d0/clippy_lints%2Fsrc%2Fcopies.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3aee654dd1be501c66d3f2c1813c5a6a93f666d0/clippy_lints%2Fsrc%2Fcopies.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcopies.rs?ref=3aee654dd1be501c66d3f2c1813c5a6a93f666d0", "patch": "@@ -269,8 +269,8 @@ fn bindings<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, pat: &Pat) -> HashMap<LocalInt\n             PatKind::TupleStruct(_, ref pats, _) => for pat in pats {\n                 bindings_impl(cx, pat, map);\n             },\n-            PatKind::Binding(_, _, ref ident, ref as_pat) => {\n-                if let Entry::Vacant(v) = map.entry(ident.node.as_str()) {\n+            PatKind::Binding(_, _, ident, ref as_pat) => {\n+                if let Entry::Vacant(v) = map.entry(ident.as_str()) {\n                     v.insert(cx.tables.pat_ty(pat));\n                 }\n                 if let Some(ref as_pat) = *as_pat {"}, {"sha": "16b94d24b16a471c8a081b8d4d86818f440bb03c", "filename": "clippy_lints/src/duration_subsec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3aee654dd1be501c66d3f2c1813c5a6a93f666d0/clippy_lints%2Fsrc%2Fduration_subsec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3aee654dd1be501c66d3f2c1813c5a6a93f666d0/clippy_lints%2Fsrc%2Fduration_subsec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fduration_subsec.rs?ref=3aee654dd1be501c66d3f2c1813c5a6a93f666d0", "patch": "@@ -43,7 +43,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for DurationSubsec {\n             if match_type(cx, walk_ptrs_ty(cx.tables.expr_ty(&args[0])), &paths::DURATION);\n             if let Some((Constant::Int(divisor), _)) = constant(cx, cx.tables, right);\n             then {\n-                let suggested_fn = match (method_path.name.as_str().as_ref(), divisor) {\n+                let suggested_fn = match (method_path.ident.as_str().as_ref(), divisor) {\n                     (\"subsec_micros\", 1_000) => \"subsec_millis\",\n                     (\"subsec_nanos\", 1_000) => \"subsec_micros\",\n                     (\"subsec_nanos\", 1_000_000) => \"subsec_millis\","}, {"sha": "13c75f39bb8902174c2553c1d12508f2adea2ddb", "filename": "clippy_lints/src/entry.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3aee654dd1be501c66d3f2c1813c5a6a93f666d0/clippy_lints%2Fsrc%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3aee654dd1be501c66d3f2c1813c5a6a93f666d0/clippy_lints%2Fsrc%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fentry.rs?ref=3aee654dd1be501c66d3f2c1813c5a6a93f666d0", "patch": "@@ -90,7 +90,7 @@ fn check_cond<'a, 'tcx, 'b>(\n     if_chain! {\n         if let ExprMethodCall(ref path, _, ref params) = check.node;\n         if params.len() >= 2;\n-        if path.name == \"contains_key\";\n+        if path.ident.name == \"contains_key\";\n         if let ExprAddrOf(_, ref key) = params[1].node;\n         then {\n             let map = &params[0];\n@@ -125,7 +125,7 @@ impl<'a, 'tcx, 'b> Visitor<'tcx> for InsertVisitor<'a, 'tcx, 'b> {\n         if_chain! {\n             if let ExprMethodCall(ref path, _, ref params) = expr.node;\n             if params.len() == 3;\n-            if path.name == \"insert\";\n+            if path.ident.name == \"insert\";\n             if get_item_name(self.cx, self.map) == get_item_name(self.cx, &params[0]);\n             if SpanlessEq::new(self.cx).eq_expr(self.key, &params[1]);\n             then {"}, {"sha": "a200383b41d166debeb2e8170668e3c4e12b0562", "filename": "clippy_lints/src/enum_variants.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3aee654dd1be501c66d3f2c1813c5a6a93f666d0/clippy_lints%2Fsrc%2Fenum_variants.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3aee654dd1be501c66d3f2c1813c5a6a93f666d0/clippy_lints%2Fsrc%2Fenum_variants.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fenum_variants.rs?ref=3aee654dd1be501c66d3f2c1813c5a6a93f666d0", "patch": "@@ -121,7 +121,7 @@ impl LintPass for EnumVariantNames {\n }\n \n fn var2str(var: &Variant) -> LocalInternedString {\n-    var.node.ident.name.as_str()\n+    var.node.ident.as_str()\n }\n \n /// Returns the number of chars that match from the start\n@@ -245,7 +245,7 @@ impl EarlyLintPass for EnumVariantNames {\n     }\n \n     fn check_item(&mut self, cx: &EarlyContext, item: &Item) {\n-        let item_name = item.ident.name.as_str();\n+        let item_name = item.ident.as_str();\n         let item_name_chars = item_name.chars().count();\n         let item_camel = to_camel_case(&item_name);\n         if !in_macro(item.span) {"}, {"sha": "e924ba6bdbb75ff8e2c3cd58f8a097df64731eac", "filename": "clippy_lints/src/eta_reduction.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3aee654dd1be501c66d3f2c1813c5a6a93f666d0/clippy_lints%2Fsrc%2Feta_reduction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3aee654dd1be501c66d3f2c1813c5a6a93f666d0/clippy_lints%2Fsrc%2Feta_reduction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Feta_reduction.rs?ref=3aee654dd1be501c66d3f2c1813c5a6a93f666d0", "patch": "@@ -78,7 +78,7 @@ fn check_closure(cx: &LateContext, expr: &Expr) {\n                             // If it's a proper path, it can't be a local variable\n                             return;\n                         }\n-                        if p.segments[0].name != ident.node {\n+                        if p.segments[0].ident.name != ident.name {\n                             // The two idents should be the same\n                             return;\n                         }"}, {"sha": "7c741100bde317dad57ebc0cc15bdf309dfb8554", "filename": "clippy_lints/src/explicit_write.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3aee654dd1be501c66d3f2c1813c5a6a93f666d0/clippy_lints%2Fsrc%2Fexplicit_write.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3aee654dd1be501c66d3f2c1813c5a6a93f666d0/clippy_lints%2Fsrc%2Fexplicit_write.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fexplicit_write.rs?ref=3aee654dd1be501c66d3f2c1813c5a6a93f666d0", "patch": "@@ -36,12 +36,12 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n         if_chain! {\n             // match call to unwrap\n             if let ExprMethodCall(ref unwrap_fun, _, ref unwrap_args) = expr.node;\n-            if unwrap_fun.name == \"unwrap\";\n+            if unwrap_fun.ident.name == \"unwrap\";\n             // match call to write_fmt\n             if unwrap_args.len() > 0;\n             if let ExprMethodCall(ref write_fun, _, ref write_args) =\n                 unwrap_args[0].node;\n-            if write_fun.name == \"write_fmt\";\n+            if write_fun.ident.name == \"write_fmt\";\n             // match calls to std::io::stdout() / std::io::stderr ()\n             if write_args.len() > 0;\n             if let ExprCall(ref dest_fun, _) = write_args[0].node;"}, {"sha": "64cdc05b44de33fc9e978fb597885878f49de23d", "filename": "clippy_lints/src/fallible_impl_from.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3aee654dd1be501c66d3f2c1813c5a6a93f666d0/clippy_lints%2Fsrc%2Ffallible_impl_from.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3aee654dd1be501c66d3f2c1813c5a6a93f666d0/clippy_lints%2Fsrc%2Ffallible_impl_from.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffallible_impl_from.rs?ref=3aee654dd1be501c66d3f2c1813c5a6a93f666d0", "patch": "@@ -93,7 +93,7 @@ fn lint_impl_body<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, impl_span: Span, impl_it\n \n     for impl_item in impl_items {\n         if_chain! {\n-            if impl_item.name == \"from\";\n+            if impl_item.ident.name == \"from\";\n             if let ImplItemKind::Method(_, body_id) =\n                 cx.tcx.hir.impl_item(impl_item.id).node;\n             then {"}, {"sha": "890fe51819aaf923f11fa89c9e25a78b4edc4477", "filename": "clippy_lints/src/format.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3aee654dd1be501c66d3f2c1813c5a6a93f666d0/clippy_lints%2Fsrc%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3aee654dd1be501c66d3f2c1813c5a6a93f666d0/clippy_lints%2Fsrc%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fformat.rs?ref=3aee654dd1be501c66d3f2c1813c5a6a93f666d0", "patch": "@@ -151,7 +151,7 @@ fn check_unformatted(expr: &Expr) -> bool {\n         if let ExprStruct(_, ref fields, _) = format_field.expr.node;\n         if let Some(align_field) = fields.iter().find(|f| f.ident.name == \"width\");\n         if let ExprPath(ref qpath) = align_field.expr.node;\n-        if last_path_segment(qpath).name == \"Implied\";\n+        if last_path_segment(qpath).ident.name == \"Implied\";\n         then {\n             return true;\n         }"}, {"sha": "2effb8bd8dbc7457a17e118dcee4454e67529981", "filename": "clippy_lints/src/identity_conversion.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3aee654dd1be501c66d3f2c1813c5a6a93f666d0/clippy_lints%2Fsrc%2Fidentity_conversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3aee654dd1be501c66d3f2c1813c5a6a93f666d0/clippy_lints%2Fsrc%2Fidentity_conversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fidentity_conversion.rs?ref=3aee654dd1be501c66d3f2c1813c5a6a93f666d0", "patch": "@@ -56,7 +56,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for IdentityConversion {\n             },\n \n             ExprMethodCall(ref name, .., ref args) => {\n-                if match_trait_method(cx, e, &paths::INTO[..]) && &*name.name.as_str() == \"into\" {\n+                if match_trait_method(cx, e, &paths::INTO[..]) && &*name.ident.as_str() == \"into\" {\n                     let a = cx.tables.expr_ty(e);\n                     let b = cx.tables.expr_ty(&args[0]);\n                     if same_tys(cx, a, b) {"}, {"sha": "8f6d499329f3ea7056e5b1f0964650a79eb57ec4", "filename": "clippy_lints/src/infinite_iter.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3aee654dd1be501c66d3f2c1813c5a6a93f666d0/clippy_lints%2Fsrc%2Finfinite_iter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3aee654dd1be501c66d3f2c1813c5a6a93f666d0/clippy_lints%2Fsrc%2Finfinite_iter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Finfinite_iter.rs?ref=3aee654dd1be501c66d3f2c1813c5a6a93f666d0", "patch": "@@ -143,7 +143,7 @@ fn is_infinite(cx: &LateContext, expr: &Expr) -> Finiteness {\n     match expr.node {\n         ExprMethodCall(ref method, _, ref args) => {\n             for &(name, len, heuristic, cap) in HEURISTICS.iter() {\n-                if method.name == name && args.len() == len {\n+                if method.ident.name == name && args.len() == len {\n                     return (match heuristic {\n                         Always => Infinite,\n                         First => is_infinite(cx, &args[0]),\n@@ -152,7 +152,7 @@ fn is_infinite(cx: &LateContext, expr: &Expr) -> Finiteness {\n                     }).and(cap);\n                 }\n             }\n-            if method.name == \"flat_map\" && args.len() == 2 {\n+            if method.ident.name == \"flat_map\" && args.len() == 2 {\n                 if let ExprClosure(_, _, body_id, _, _) = args[1].node {\n                     let body = cx.tcx.hir.body(body_id);\n                     return is_infinite(cx, &body.value);\n@@ -207,16 +207,16 @@ fn complete_infinite_iter(cx: &LateContext, expr: &Expr) -> Finiteness {\n     match expr.node {\n         ExprMethodCall(ref method, _, ref args) => {\n             for &(name, len) in COMPLETING_METHODS.iter() {\n-                if method.name == name && args.len() == len {\n+                if method.ident.name == name && args.len() == len {\n                     return is_infinite(cx, &args[0]);\n                 }\n             }\n             for &(name, len) in POSSIBLY_COMPLETING_METHODS.iter() {\n-                if method.name == name && args.len() == len {\n+                if method.ident.name == name && args.len() == len {\n                     return MaybeInfinite.and(is_infinite(cx, &args[0]));\n                 }\n             }\n-            if method.name == \"last\" && args.len() == 1 {\n+            if method.ident.name == \"last\" && args.len() == 1 {\n                 let not_double_ended = get_trait_def_id(cx, &paths::DOUBLE_ENDED_ITERATOR)\n                     .map_or(false, |id| !implements_trait(cx, cx.tables.expr_ty(&args[0]), id, &[]));\n                 if not_double_ended {"}, {"sha": "8dab9fbd12f67bc9b0b5105c61e0930f62805aa8", "filename": "clippy_lints/src/inline_fn_without_body.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3aee654dd1be501c66d3f2c1813c5a6a93f666d0/clippy_lints%2Fsrc%2Finline_fn_without_body.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3aee654dd1be501c66d3f2c1813c5a6a93f666d0/clippy_lints%2Fsrc%2Finline_fn_without_body.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Finline_fn_without_body.rs?ref=3aee654dd1be501c66d3f2c1813c5a6a93f666d0", "patch": "@@ -38,7 +38,7 @@ impl LintPass for Pass {\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n     fn check_trait_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx TraitItem) {\n         if let TraitItemKind::Method(_, TraitMethod::Required(_)) = item.node {\n-            check_attrs(cx, item.name, &item.attrs);\n+            check_attrs(cx, item.ident.name, &item.attrs);\n         }\n     }\n }"}, {"sha": "33930ab58db471619f180e3e730c8bdccd6a8ffa", "filename": "clippy_lints/src/len_zero.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3aee654dd1be501c66d3f2c1813c5a6a93f666d0/clippy_lints%2Fsrc%2Flen_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3aee654dd1be501c66d3f2c1813c5a6a93f666d0/clippy_lints%2Fsrc%2Flen_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flen_zero.rs?ref=3aee654dd1be501c66d3f2c1813c5a6a93f666d0", "patch": "@@ -107,7 +107,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for LenZero {\n \n fn check_trait_items(cx: &LateContext, visited_trait: &Item, trait_items: &[TraitItemRef]) {\n     fn is_named_self(cx: &LateContext, item: &TraitItemRef, name: &str) -> bool {\n-        item.name == name && if let AssociatedItemKind::Method { has_self } = item.kind {\n+        item.ident.name == name && if let AssociatedItemKind::Method { has_self } = item.kind {\n             has_self && {\n                 let did = cx.tcx.hir.local_def_id(item.id.node_id);\n                 cx.tcx.fn_sig(did).inputs().skip_binder().len() == 1\n@@ -135,7 +135,7 @@ fn check_trait_items(cx: &LateContext, visited_trait: &Item, trait_items: &[Trai\n             .iter()\n             .flat_map(|&i| cx.tcx.associated_items(i))\n             .any(|i| {\n-                i.kind == ty::AssociatedKind::Method && i.method_has_self_argument && i.name == \"is_empty\"\n+                i.kind == ty::AssociatedKind::Method && i.method_has_self_argument && i.ident.name == \"is_empty\"\n                     && cx.tcx.fn_sig(i.def_id).inputs().skip_binder().len() == 1\n             });\n \n@@ -155,7 +155,7 @@ fn check_trait_items(cx: &LateContext, visited_trait: &Item, trait_items: &[Trai\n \n fn check_impl_items(cx: &LateContext, item: &Item, impl_items: &[ImplItemRef]) {\n     fn is_named_self(cx: &LateContext, item: &ImplItemRef, name: &str) -> bool {\n-        item.name == name && if let AssociatedItemKind::Method { has_self } = item.kind {\n+        item.ident.name == name && if let AssociatedItemKind::Method { has_self } = item.kind {\n             has_self && {\n                 let did = cx.tcx.hir.local_def_id(item.id.node_id);\n                 cx.tcx.fn_sig(did).inputs().skip_binder().len() == 1\n@@ -202,7 +202,7 @@ fn check_cmp(cx: &LateContext, span: Span, method: &Expr, lit: &Expr, op: &str,\n             }\n         }\n \n-        check_len(cx, span, method_path.name, args, lit, op, compare_to)\n+        check_len(cx, span, method_path.ident.name, args, lit, op, compare_to)\n     }\n }\n \n@@ -235,7 +235,7 @@ fn has_is_empty(cx: &LateContext, expr: &Expr) -> bool {\n     /// Get an `AssociatedItem` and return true if it matches `is_empty(self)`.\n     fn is_is_empty(cx: &LateContext, item: &ty::AssociatedItem) -> bool {\n         if let ty::AssociatedKind::Method = item.kind {\n-            if item.name == \"is_empty\" {\n+            if item.ident.name == \"is_empty\" {\n                 let sig = cx.tcx.fn_sig(item.def_id);\n                 let ty = sig.skip_binder();\n                 ty.inputs().len() == 1"}, {"sha": "4e0d3de799e5d1b64197c1188b2145ef370fec99", "filename": "clippy_lints/src/let_if_seq.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3aee654dd1be501c66d3f2c1813c5a6a93f666d0/clippy_lints%2Fsrc%2Flet_if_seq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3aee654dd1be501c66d3f2c1813c5a6a93f666d0/clippy_lints%2Fsrc%2Flet_if_seq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flet_if_seq.rs?ref=3aee654dd1be501c66d3f2c1813c5a6a93f666d0", "patch": "@@ -67,7 +67,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for LetIfSeq {\n                 if let Some(expr) = it.peek();\n                 if let hir::StmtDecl(ref decl, _) = stmt.node;\n                 if let hir::DeclLocal(ref decl) = decl.node;\n-                if let hir::PatKind::Binding(mode, canonical_id, ref name, None) = decl.pat.node;\n+                if let hir::PatKind::Binding(mode, canonical_id, ident, None) = decl.pat.node;\n                 if let hir::StmtExpr(ref if_, _) = expr.node;\n                 if let hir::ExprIf(ref cond, ref then, ref else_) = if_.node;\n                 if !used_in_expr(cx, canonical_id, cond);\n@@ -106,7 +106,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for LetIfSeq {\n                     let sug = format!(\n                         \"let {mut}{name} = if {cond} {{{then} {value} }} else {{{else} {default} }};\",\n                         mut=mutability,\n-                        name=name.node,\n+                        name=ident.name,\n                         cond=snippet(cx, cond.span, \"_\"),\n                         then=if then.stmts.len() > 1 { \" ..;\" } else { \"\" },\n                         else=if default_multi_stmts { \" ..;\" } else { \"\" },"}, {"sha": "28827387b9d5de6a5341e5f2d4f44a93d5690c23", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3aee654dd1be501c66d3f2c1813c5a6a93f666d0/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3aee654dd1be501c66d3f2c1813c5a6a93f666d0/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=3aee654dd1be501c66d3f2c1813c5a6a93f666d0", "patch": "@@ -434,6 +434,7 @@ pub fn register_plugins(reg: &mut rustc_plugin::Registry) {\n     reg.register_lint_group(\"clippy_pedantic\", vec![\n         attrs::INLINE_ALWAYS,\n         copies::MATCH_SAME_ARMS,\n+        default_trait_access::DEFAULT_TRAIT_ACCESS,\n         derive::EXPL_IMPL_CLONE_ON_COPY,\n         doc::DOC_MARKDOWN,\n         empty_enum::EMPTY_ENUM,\n@@ -492,7 +493,6 @@ pub fn register_plugins(reg: &mut rustc_plugin::Registry) {\n         copies::IF_SAME_THEN_ELSE,\n         copies::IFS_SAME_COND,\n         cyclomatic_complexity::CYCLOMATIC_COMPLEXITY,\n-        default_trait_access::DEFAULT_TRAIT_ACCESS,\n         derive::DERIVE_HASH_XOR_EQ,\n         double_comparison::DOUBLE_COMPARISONS,\n         double_parens::DOUBLE_PARENS,\n@@ -694,7 +694,6 @@ pub fn register_plugins(reg: &mut rustc_plugin::Registry) {\n         block_in_if_condition::BLOCK_IN_IF_CONDITION_STMT,\n         collapsible_if::COLLAPSIBLE_IF,\n         const_static_lifetime::CONST_STATIC_LIFETIME,\n-        default_trait_access::DEFAULT_TRAIT_ACCESS,\n         enum_variants::ENUM_VARIANT_NAMES,\n         enum_variants::MODULE_INCEPTION,\n         eq_op::OP_REF,"}, {"sha": "efa50a8f7435d7650a900f9818b0265a4199c345", "filename": "clippy_lints/src/lifetimes.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/3aee654dd1be501c66d3f2c1813c5a6a93f666d0/clippy_lints%2Fsrc%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3aee654dd1be501c66d3f2c1813c5a6a93f666d0/clippy_lints%2Fsrc%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flifetimes.rs?ref=3aee654dd1be501c66d3f2c1813c5a6a93f666d0", "patch": "@@ -126,7 +126,7 @@ fn check_fn_inner<'a, 'tcx>(\n                         GenericArg::Type(_) => None,\n                     });\n                     for bound in lifetimes {\n-                        if bound.name.name() != \"'static\" && !bound.is_elided() {\n+                        if bound.name.ident().name != \"'static\" && !bound.is_elided() {\n                             return;\n                         }\n                         bounds_lts.push(bound);\n@@ -240,7 +240,7 @@ fn allowed_lts_from(named_generics: &[GenericParam]) -> HashSet<RefLt> {\n     for par in named_generics.iter() {\n         if let GenericParamKind::Lifetime { .. } = par.kind {\n             if par.bounds.is_empty() {\n-                allowed_lts.insert(RefLt::Named(par.name.name()));\n+                allowed_lts.insert(RefLt::Named(par.name.ident().name));\n             }\n         }\n     }\n@@ -251,8 +251,8 @@ fn allowed_lts_from(named_generics: &[GenericParam]) -> HashSet<RefLt> {\n \n fn lts_from_bounds<'a, T: Iterator<Item = &'a Lifetime>>(mut vec: Vec<RefLt>, bounds_lts: T) -> Vec<RefLt> {\n     for lt in bounds_lts {\n-        if lt.name.name() != \"'static\" {\n-            vec.push(RefLt::Named(lt.name.name()));\n+        if lt.name.ident().name != \"'static\" {\n+            vec.push(RefLt::Named(lt.name.ident().name));\n         }\n     }\n \n@@ -282,12 +282,12 @@ impl<'v, 't> RefVisitor<'v, 't> {\n \n     fn record(&mut self, lifetime: &Option<Lifetime>) {\n         if let Some(ref lt) = *lifetime {\n-            if lt.name.name() == \"'static\" {\n+            if lt.name.ident().name == \"'static\" {\n                 self.lts.push(RefLt::Static);\n             } else if lt.is_elided() {\n                 self.lts.push(RefLt::Unnamed);\n             } else {\n-                self.lts.push(RefLt::Named(lt.name.name()));\n+                self.lts.push(RefLt::Named(lt.name.ident().name));\n             }\n         } else {\n             self.lts.push(RefLt::Unnamed);\n@@ -421,7 +421,7 @@ struct LifetimeChecker {\n impl<'tcx> Visitor<'tcx> for LifetimeChecker {\n     // for lifetimes as parameters of generics\n     fn visit_lifetime(&mut self, lifetime: &'tcx Lifetime) {\n-        self.map.remove(&lifetime.name.name());\n+        self.map.remove(&lifetime.name.ident().name);\n     }\n \n     fn visit_generic_param(&mut self, param: &'tcx GenericParam) {\n@@ -442,7 +442,7 @@ impl<'tcx> Visitor<'tcx> for LifetimeChecker {\n fn report_extra_lifetimes<'a, 'tcx: 'a>(cx: &LateContext<'a, 'tcx>, func: &'tcx FnDecl, generics: &'tcx Generics) {\n     let hs = generics.params.iter()\n         .filter_map(|par| match par.kind {\n-            GenericParamKind::Lifetime { .. } => Some((par.name.name(), par.span)),\n+            GenericParamKind::Lifetime { .. } => Some((par.name.ident().name, par.span)),\n             _ => None,\n         })\n         .collect();\n@@ -463,7 +463,7 @@ struct BodyLifetimeChecker {\n impl<'tcx> Visitor<'tcx> for BodyLifetimeChecker {\n     // for lifetimes as parameters of generics\n     fn visit_lifetime(&mut self, lifetime: &'tcx Lifetime) {\n-        if lifetime.name.name() != keywords::Invalid.name() && lifetime.name.name() != \"'static\" {\n+        if lifetime.name.ident().name != keywords::Invalid.name() && lifetime.name.ident().name != \"'static\" {\n             self.lifetimes_used_in_body = true;\n         }\n     }"}, {"sha": "8b7032893d88a332f278e5ff05970784df4c1c8a", "filename": "clippy_lints/src/loops.rs", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/3aee654dd1be501c66d3f2c1813c5a6a93f666d0/clippy_lints%2Fsrc%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3aee654dd1be501c66d3f2c1813c5a6a93f666d0/clippy_lints%2Fsrc%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops.rs?ref=3aee654dd1be501c66d3f2c1813c5a6a93f666d0", "patch": "@@ -485,8 +485,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n             {\n                 let iter_expr = &method_args[0];\n                 let lhs_constructor = last_path_segment(qpath);\n-                if method_path.name == \"next\" && match_trait_method(cx, match_expr, &paths::ITERATOR)\n-                    && lhs_constructor.name == \"Some\" && !is_refutable(cx, &pat_args[0])\n+                if method_path.ident.name == \"next\" && match_trait_method(cx, match_expr, &paths::ITERATOR)\n+                    && lhs_constructor.ident.name == \"Some\" && !is_refutable(cx, &pat_args[0])\n                     && !is_iterator_used_after_while_let(cx, iter_expr)\n                     && !is_nested(cx, expr, &method_args[0])\n                 {\n@@ -513,7 +513,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n     fn check_stmt(&mut self, cx: &LateContext<'a, 'tcx>, stmt: &'tcx Stmt) {\n         if let StmtSemi(ref expr, _) = stmt.node {\n             if let ExprMethodCall(ref method, _, ref args) = expr.node {\n-                if args.len() == 1 && method.name == \"collect\" && match_trait_method(cx, expr, &paths::ITERATOR) {\n+                if args.len() == 1 && method.ident.name == \"collect\" && match_trait_method(cx, expr, &paths::ITERATOR) {\n                     span_lint(\n                         cx,\n                         UNUSED_COLLECT,\n@@ -811,7 +811,7 @@ fn fetch_cloned_fixed_offset_var<'a, 'tcx>(\n ) -> Option<FixedOffsetVar> {\n     if_chain! {\n         if let ExprMethodCall(ref method, _, ref args) = expr.node;\n-        if method.name == \"clone\";\n+        if method.ident.name == \"clone\";\n         if args.len() == 1;\n         if let Some(arg) = args.get(0);\n         then {\n@@ -907,7 +907,7 @@ fn detect_manual_memcpy<'a, 'tcx>(\n             let print_limit = |end: &Option<&Expr>, offset: Offset, var_name: &str| if let Some(end) = *end {\n                 if_chain! {\n                     if let ExprMethodCall(ref method, _, ref len_args) = end.node;\n-                    if method.name == \"len\";\n+                    if method.ident.name == \"len\";\n                     if len_args.len() == 1;\n                     if let Some(arg) = len_args.get(0);\n                     if snippet(cx, arg.span, \"??\") == var_name;\n@@ -985,7 +985,7 @@ fn check_for_loop_range<'a, 'tcx>(\n     }) = higher::range(cx, arg)\n     {\n         // the var must be a single name\n-        if let PatKind::Binding(_, canonical_id, ref ident, _) = pat.node {\n+        if let PatKind::Binding(_, canonical_id, ident, _) = pat.node {\n             let mut visitor = VarVisitor {\n                 cx,\n                 var: canonical_id,\n@@ -1058,13 +1058,13 @@ fn check_for_loop_range<'a, 'tcx>(\n                         cx,\n                         NEEDLESS_RANGE_LOOP,\n                         expr.span,\n-                        &format!(\"the loop variable `{}` is used to index `{}`\", ident.node, indexed),\n+                        &format!(\"the loop variable `{}` is used to index `{}`\", ident.name, indexed),\n                         |db| {\n                             multispan_sugg(\n                                 db,\n                                 \"consider using an iterator\".to_string(),\n                                 vec![\n-                                    (pat.span, format!(\"({}, <item>)\", ident.node)),\n+                                    (pat.span, format!(\"({}, <item>)\", ident.name)),\n                                     (arg.span, format!(\"{}.{}().enumerate(){}{}\", indexed, method, take, skip)),\n                                 ],\n                             );\n@@ -1081,7 +1081,7 @@ fn check_for_loop_range<'a, 'tcx>(\n                         cx,\n                         NEEDLESS_RANGE_LOOP,\n                         expr.span,\n-                        &format!(\"the loop variable `{}` is only used to index `{}`.\", ident.node, indexed),\n+                        &format!(\"the loop variable `{}` is only used to index `{}`.\", ident.name, indexed),\n                         |db| {\n                             multispan_sugg(\n                                 db,\n@@ -1100,10 +1100,10 @@ fn is_len_call(expr: &Expr, var: Name) -> bool {\n     if_chain! {\n         if let ExprMethodCall(ref method, _, ref len_args) = expr.node;\n         if len_args.len() == 1;\n-        if method.name == \"len\";\n+        if method.ident.name == \"len\";\n         if let ExprPath(QPath::Resolved(_, ref path)) = len_args[0].node;\n         if path.segments.len() == 1;\n-        if path.segments[0].name == var;\n+        if path.segments[0].ident.name == var;\n         then {\n             return true;\n         }\n@@ -1206,7 +1206,7 @@ fn check_for_loop_arg(cx: &LateContext, pat: &Pat, arg: &Expr, expr: &Expr) {\n     if let ExprMethodCall(ref method, _, ref args) = arg.node {\n         // just the receiver, no arguments\n         if args.len() == 1 {\n-            let method_name = &*method.name.as_str();\n+            let method_name = &*method.ident.as_str();\n             // check for looping over x.iter() or x.iter_mut(), could use &x or &mut x\n             if method_name == \"iter\" || method_name == \"iter_mut\" {\n                 if is_ref_iterable_type(cx, &args[0]) {\n@@ -1520,9 +1520,9 @@ fn check_for_mutation(cx: &LateContext, body: &Expr, bound_ids: &[Option<NodeId>\n fn pat_is_wild<'tcx>(pat: &'tcx PatKind, body: &'tcx Expr) -> bool {\n     match *pat {\n         PatKind::Wild => true,\n-        PatKind::Binding(_, _, ident, None) if ident.node.as_str().starts_with('_') => {\n+        PatKind::Binding(_, _, ident, None) if ident.as_str().starts_with('_') => {\n             let mut visitor = UsedVisitor {\n-                var: ident.node,\n+                var: ident.name,\n                 used: false,\n             };\n             walk_expr(&mut visitor, body);\n@@ -1615,7 +1615,7 @@ impl<'a, 'tcx> VarVisitor<'a, 'tcx> {\n \n                 if indexed_indirectly || index_used_directly {\n                     if self.prefer_mutable {\n-                        self.indexed_mut.insert(seqvar.segments[0].name);\n+                        self.indexed_mut.insert(seqvar.segments[0].ident.name);\n                     }\n                     let def = self.cx.tables.qpath_def(seqpath, seqexpr.hir_id);\n                     match def {\n@@ -1626,19 +1626,19 @@ impl<'a, 'tcx> VarVisitor<'a, 'tcx> {\n                             let parent_def_id = self.cx.tcx.hir.local_def_id(parent_id);\n                             let extent = self.cx.tcx.region_scope_tree(parent_def_id).var_scope(hir_id.local_id);\n                             if indexed_indirectly {\n-                                self.indexed_indirectly.insert(seqvar.segments[0].name, Some(extent));\n+                                self.indexed_indirectly.insert(seqvar.segments[0].ident.name, Some(extent));\n                             }\n                             if index_used_directly {\n-                                self.indexed_directly.insert(seqvar.segments[0].name, Some(extent));\n+                                self.indexed_directly.insert(seqvar.segments[0].ident.name, Some(extent));\n                             }\n                             return false;  // no need to walk further *on the variable*\n                         }\n                         Def::Static(..) | Def::Const(..) => {\n                             if indexed_indirectly {\n-                                self.indexed_indirectly.insert(seqvar.segments[0].name, None);\n+                                self.indexed_indirectly.insert(seqvar.segments[0].ident.name, None);\n                             }\n                             if index_used_directly {\n-                                self.indexed_directly.insert(seqvar.segments[0].name, None);\n+                                self.indexed_directly.insert(seqvar.segments[0].ident.name, None);\n                             }\n                             return false;  // no need to walk further *on the variable*\n                         }\n@@ -1656,8 +1656,8 @@ impl<'a, 'tcx> Visitor<'tcx> for VarVisitor<'a, 'tcx> {\n         if_chain! {\n             // a range index op\n             if let ExprMethodCall(ref meth, _, ref args) = expr.node;\n-            if (meth.name == \"index\" && match_trait_method(self.cx, expr, &paths::INDEX))\n-                || (meth.name == \"index_mut\" && match_trait_method(self.cx, expr, &paths::INDEX_MUT));\n+            if (meth.ident.name == \"index\" && match_trait_method(self.cx, expr, &paths::INDEX))\n+                || (meth.ident.name == \"index_mut\" && match_trait_method(self.cx, expr, &paths::INDEX_MUT));\n             if !self.check(&args[1], &args[0], expr);\n             then { return }\n         }\n@@ -1681,7 +1681,7 @@ impl<'a, 'tcx> Visitor<'tcx> for VarVisitor<'a, 'tcx> {\n                     self.nonindex = true;\n                 } else {\n                     // not the correct variable, but still a variable\n-                    self.referenced.insert(path.segments[0].name);\n+                    self.referenced.insert(path.segments[0].ident.name);\n                 }\n             }\n         }\n@@ -1933,8 +1933,8 @@ impl<'a, 'tcx> Visitor<'tcx> for InitializeVisitor<'a, 'tcx> {\n         // Look for declarations of the variable\n         if let DeclLocal(ref local) = decl.node {\n             if local.pat.id == self.var_id {\n-                if let PatKind::Binding(_, _, ref ident, _) = local.pat.node {\n-                    self.name = Some(ident.node);\n+                if let PatKind::Binding(_, _, ident, _) = local.pat.node {\n+                    self.name = Some(ident.name);\n \n                     self.state = if let Some(ref init) = local.init {\n                         if is_integer_literal(init, 0) {\n@@ -2123,7 +2123,7 @@ impl<'tcx> Visitor<'tcx> for LoopNestVisitor {\n             return;\n         }\n         if let PatKind::Binding(_, _, span_name, _) = pat.node {\n-            if self.iterator == span_name.node {\n+            if self.iterator == span_name.name {\n                 self.nesting = RuledOut;\n                 return;\n             }\n@@ -2140,7 +2140,7 @@ fn path_name(e: &Expr) -> Option<Name> {\n     if let ExprPath(QPath::Resolved(_, ref path)) = e.node {\n         let segments = &path.segments;\n         if segments.len() == 1 {\n-            return Some(segments[0].name);\n+            return Some(segments[0].ident.name);\n         }\n     };\n     None"}, {"sha": "5ea873e31e1313dbbfb430fd5fa2b8fd9794662e", "filename": "clippy_lints/src/map_clone.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3aee654dd1be501c66d3f2c1813c5a6a93f666d0/clippy_lints%2Fsrc%2Fmap_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3aee654dd1be501c66d3f2c1813c5a6a93f666d0/clippy_lints%2Fsrc%2Fmap_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmap_clone.rs?ref=3aee654dd1be501c66d3f2c1813c5a6a93f666d0", "patch": "@@ -2,7 +2,7 @@ use rustc::lint::*;\n use rustc::hir::*;\n use rustc::ty;\n use syntax::ast;\n-use crate::utils::{get_arg_name, is_adjusted, iter_input_pats, match_qpath, match_trait_method, match_type,\n+use crate::utils::{get_arg_ident, is_adjusted, iter_input_pats, match_qpath, match_trait_method, match_type,\n             paths, remove_blocks, snippet, span_help_and_lint, walk_ptrs_ty, walk_ptrs_ty_depth};\n \n /// **What it does:** Checks for mapping `clone()` over an iterator.\n@@ -31,7 +31,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n         // call to .map()\n         if let ExprMethodCall(ref method, _, ref args) = expr.node {\n-            if method.name == \"map\" && args.len() == 2 {\n+            if method.ident.name == \"map\" && args.len() == 2 {\n                 match args[1].node {\n                     ExprClosure(_, ref decl, closure_eid, _, _) => {\n                         let body = cx.tcx.hir.body(closure_eid);\n@@ -40,7 +40,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n                             // nothing special in the argument, besides reference bindings\n                             // (e.g. .map(|&x| x) )\n                             if let Some(first_arg) = iter_input_pats(decl, body).next();\n-                            if let Some(arg_ident) = get_arg_name(&first_arg.pat);\n+                            if let Some(arg_ident) = get_arg_ident(&first_arg.pat);\n                             // the method is being called on a known type (option or iterator)\n                             if let Some(type_name) = get_type_name(cx, expr, &args[0]);\n                             then {\n@@ -63,7 +63,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n                                 }\n                                 // explicit clone() calls ( .map(|x| x.clone()) )\n                                 else if let ExprMethodCall(ref clone_call, _, ref clone_args) = closure_expr.node {\n-                                    if clone_call.name == \"clone\" &&\n+                                    if clone_call.ident.name == \"clone\" &&\n                                         clone_args.len() == 1 &&\n                                         match_trait_method(cx, closure_expr, &paths::CLONE_TRAIT) &&\n                                         expr_eq_name(&clone_args[0], arg_ident)\n@@ -98,12 +98,12 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n     }\n }\n \n-fn expr_eq_name(expr: &Expr, id: ast::Name) -> bool {\n+fn expr_eq_name(expr: &Expr, id: ast::Ident) -> bool {\n     match expr.node {\n         ExprPath(QPath::Resolved(None, ref path)) => {\n             let arg_segment = [\n                 PathSegment {\n-                    name: id,\n+                    ident: id,\n                     args: None,\n                     infer_types: true,\n                 },\n@@ -124,7 +124,7 @@ fn get_type_name(cx: &LateContext, expr: &Expr, arg: &Expr) -> Option<&'static s\n     }\n }\n \n-fn only_derefs(cx: &LateContext, expr: &Expr, id: ast::Name) -> bool {\n+fn only_derefs(cx: &LateContext, expr: &Expr, id: ast::Ident) -> bool {\n     match expr.node {\n         ExprUnary(UnDeref, ref subexpr) if !is_adjusted(cx, subexpr) => only_derefs(cx, subexpr, id),\n         _ => expr_eq_name(expr, id),"}, {"sha": "207343c92c678125cd3208dcfa3f5606e6c9a465", "filename": "clippy_lints/src/matches.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3aee654dd1be501c66d3f2c1813c5a6a93f666d0/clippy_lints%2Fsrc%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3aee654dd1be501c66d3f2c1813c5a6a93f666d0/clippy_lints%2Fsrc%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches.rs?ref=3aee654dd1be501c66d3f2c1813c5a6a93f666d0", "patch": "@@ -270,7 +270,7 @@ fn check_single_match_opt_like(cx: &LateContext, ex: &Expr, arms: &[Arm], expr:\n             }\n             print::to_string(print::NO_ANN, |s| s.print_qpath(path, false))\n         },\n-        PatKind::Binding(BindingAnnotation::Unannotated, _, ident, None) => ident.node.to_string(),\n+        PatKind::Binding(BindingAnnotation::Unannotated, _, ident, None) => ident.to_string(),\n         PatKind::Path(ref path) => print::to_string(print::NO_ANN, |s| s.print_qpath(path, false)),\n         _ => return,\n     };\n@@ -552,14 +552,14 @@ fn is_ref_some_arm(arm: &Arm) -> Option<BindingAnnotation> {\n     if_chain! {\n         if let PatKind::TupleStruct(ref path, ref pats, _) = arm.pats[0].node;\n         if pats.len() == 1 && match_qpath(path, &paths::OPTION_SOME);\n-        if let PatKind::Binding(rb, _, ref ident, _) = pats[0].node;\n+        if let PatKind::Binding(rb, _, ident, _) = pats[0].node;\n         if rb == BindingAnnotation::Ref || rb == BindingAnnotation::RefMut;\n         if let ExprCall(ref e, ref args) = remove_blocks(&arm.body).node;\n         if let ExprPath(ref some_path) = e.node;\n         if match_qpath(some_path, &paths::OPTION_SOME) && args.len() == 1;\n         if let ExprPath(ref qpath) = args[0].node;\n         if let &QPath::Resolved(_, ref path2) = qpath;\n-        if path2.segments.len() == 1 && ident.node == path2.segments[0].name;\n+        if path2.segments.len() == 1 && ident.name == path2.segments[0].ident.name;\n         then {\n             return Some(rb)\n         }"}, {"sha": "71f9dc8e03fb1595d1142b14a7fa7ab274e30a72", "filename": "clippy_lints/src/methods.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/3aee654dd1be501c66d3f2c1813c5a6a93f666d0/clippy_lints%2Fsrc%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3aee654dd1be501c66d3f2c1813c5a6a93f666d0/clippy_lints%2Fsrc%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods.rs?ref=3aee654dd1be501c66d3f2c1813c5a6a93f666d0", "patch": "@@ -771,18 +771,18 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n                     lint_unnecessary_fold(cx, expr, arglists[0]);\n                 }\n \n-                lint_or_fun_call(cx, expr, *method_span, &method_call.name.as_str(), args);\n-                lint_expect_fun_call(cx, expr, *method_span, &method_call.name.as_str(), args);\n+                lint_or_fun_call(cx, expr, *method_span, &method_call.ident.as_str(), args);\n+                lint_expect_fun_call(cx, expr, *method_span, &method_call.ident.as_str(), args);\n \n                 let self_ty = cx.tables.expr_ty_adjusted(&args[0]);\n-                if args.len() == 1 && method_call.name == \"clone\" {\n+                if args.len() == 1 && method_call.ident.name == \"clone\" {\n                     lint_clone_on_copy(cx, expr, &args[0], self_ty);\n                     lint_clone_on_ref_ptr(cx, expr, &args[0]);\n                 }\n \n                 match self_ty.sty {\n                     ty::TyRef(_, ty, _) if ty.sty == ty::TyStr => for &(method, pos) in &PATTERN_METHODS {\n-                        if method_call.name == method && args.len() > pos {\n+                        if method_call.ident.name == method && args.len() > pos {\n                             lint_single_char_pattern(cx, expr, &args[pos]);\n                         }\n                     },\n@@ -806,7 +806,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n         if in_external_macro(cx, implitem.span) {\n             return;\n         }\n-        let name = implitem.name;\n+        let name = implitem.ident.name;\n         let parent = cx.tcx.hir.get_parent(implitem.id);\n         let item = cx.tcx.hir.expect_item(parent);\n         if_chain! {\n@@ -890,7 +890,7 @@ fn lint_or_fun_call(cx: &LateContext, expr: &hir::Expr, method_span: Span, name:\n \n         if name == \"unwrap_or\" {\n             if let hir::ExprPath(ref qpath) = fun.node {\n-                let path = &*last_path_segment(qpath).name.as_str();\n+                let path = &*last_path_segment(qpath).ident.as_str();\n \n                 if [\"default\", \"new\"].contains(&path) {\n                     let arg_ty = cx.tables.expr_ty(arg);\n@@ -1438,7 +1438,7 @@ fn derefs_to_slice(cx: &LateContext, expr: &hir::Expr, ty: Ty) -> Option<sugg::S\n     }\n \n     if let hir::ExprMethodCall(ref path, _, ref args) = expr.node {\n-        if path.name == \"iter\" && may_slice(cx, cx.tables.expr_ty(&args[0])) {\n+        if path.ident.name == \"iter\" && may_slice(cx, cx.tables.expr_ty(&args[0])) {\n             sugg::Sugg::hir_opt(cx, &args[0]).map(|sugg| sugg.addr())\n         } else {\n             None\n@@ -1794,7 +1794,7 @@ fn lint_chars_cmp<'a, 'tcx>(\n         if arg_char.len() == 1;\n         if let hir::ExprPath(ref qpath) = fun.node;\n         if let Some(segment) = single_segment_path(qpath);\n-        if segment.name == \"Some\";\n+        if segment.ident.name == \"Some\";\n         then {\n             let self_ty = walk_ptrs_ty(cx.tables.expr_ty_adjusted(&args[0][0]));\n \n@@ -2093,7 +2093,7 @@ fn is_as_ref_or_mut_trait(ty: &hir::Ty, self_ty: &hir::Ty, generics: &hir::Gener\n     single_segment_ty(ty).map_or(false, |seg| {\n         generics.params.iter().any(|param| match param.kind {\n             hir::GenericParamKind::Type { .. } => {\n-                param.name.name() == seg.name && param.bounds.iter().any(|bound| {\n+                param.name.ident().name == seg.ident.name && param.bounds.iter().any(|bound| {\n                     if let hir::GenericBound::Trait(ref ptr, ..) = *bound {\n                         let path = &ptr.trait_ref.path;\n                         match_path(path, name) && path.segments.last().map_or(false, |s| {\n@@ -2132,8 +2132,8 @@ fn is_ty(ty: &hir::Ty, self_ty: &hir::Ty) -> bool {\n         ) => ty_path\n             .segments\n             .iter()\n-            .map(|seg| seg.name)\n-            .eq(self_ty_path.segments.iter().map(|seg| seg.name)),\n+            .map(|seg| seg.ident.name)\n+            .eq(self_ty_path.segments.iter().map(|seg| seg.ident.name)),\n         _ => false,\n     }\n }"}, {"sha": "697f15bdd1da5dec4189d1585ed24e11651d20a3", "filename": "clippy_lints/src/misc.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3aee654dd1be501c66d3f2c1813c5a6a93f666d0/clippy_lints%2Fsrc%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3aee654dd1be501c66d3f2c1813c5a6a93f666d0/clippy_lints%2Fsrc%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmisc.rs?ref=3aee654dd1be501c66d3f2c1813c5a6a93f666d0", "patch": "@@ -379,7 +379,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n         }\n         let binding = match expr.node {\n             ExprPath(ref qpath) => {\n-                let binding = last_path_segment(qpath).name.as_str();\n+                let binding = last_path_segment(qpath).ident.as_str();\n                 if binding.starts_with('_') &&\n                     !binding.starts_with(\"__\") &&\n                     binding != \"_result\" && // FIXME: #944\n@@ -417,13 +417,13 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n     }\n \n     fn check_pat(&mut self, cx: &LateContext<'a, 'tcx>, pat: &'tcx Pat) {\n-        if let PatKind::Binding(_, _, ref ident, Some(ref right)) = pat.node {\n+        if let PatKind::Binding(_, _, ident, Some(ref right)) = pat.node {\n             if right.node == PatKind::Wild {\n                 span_lint(\n                     cx,\n                     REDUNDANT_PATTERN,\n                     pat.span,\n-                    &format!(\"the `{} @ _` pattern can be written as just `{}`\", ident.node, ident.node),\n+                    &format!(\"the `{} @ _` pattern can be written as just `{}`\", ident.name, ident.name),\n                 );\n             }\n         }\n@@ -433,7 +433,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n fn check_nan(cx: &LateContext, path: &Path, expr: &Expr) {\n     if !in_constant(cx, expr.id) {\n         if let Some(seg) = path.segments.last() {\n-            if seg.name == \"NAN\" {\n+            if seg.ident.name == \"NAN\" {\n                 span_lint(\n                     cx,\n                     CMP_NAN,"}, {"sha": "87e4d343ab45b87f36618c380df77059c3c4c623", "filename": "clippy_lints/src/misc_early.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3aee654dd1be501c66d3f2c1813c5a6a93f666d0/clippy_lints%2Fsrc%2Fmisc_early.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3aee654dd1be501c66d3f2c1813c5a6a93f666d0/clippy_lints%2Fsrc%2Fmisc_early.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmisc_early.rs?ref=3aee654dd1be501c66d3f2c1813c5a6a93f666d0", "patch": "@@ -190,7 +190,7 @@ impl EarlyLintPass for MiscEarly {\n     fn check_generics(&mut self, cx: &EarlyContext, gen: &Generics) {\n         for param in &gen.params {\n             if let GenericParamKind::Type { .. } = param.kind {\n-                let name = param.ident.name.as_str();\n+                let name = param.ident.as_str();\n                 if constants::BUILTIN_TYPES.contains(&&*name) {\n                     span_lint(\n                         cx,\n@@ -268,7 +268,7 @@ impl EarlyLintPass for MiscEarly {\n \n         for arg in &decl.inputs {\n             if let PatKind::Ident(_, ident, None) = arg.pat.node {\n-                let arg_name = ident.name.to_string();\n+                let arg_name = ident.to_string();\n \n                 if arg_name.starts_with('_') {\n                     if let Some(correspondence) = registered_names.get(&arg_name[1..]) {\n@@ -371,8 +371,8 @@ impl MiscEarly {\n                     let mut seen = (false, false);\n                     for ch in src.chars() {\n                         match ch {\n-                            'a' ... 'f' => seen.0 = true,\n-                            'A' ... 'F' => seen.1 = true,\n+                            'a' ..= 'f' => seen.0 = true,\n+                            'A' ..= 'F' => seen.1 = true,\n                             'i' | 'u'   => break,   // start of suffix already\n                             _ => ()\n                         }"}, {"sha": "4e9c5c815cce9da1f8771f02d7f5f4361bcc2f52", "filename": "clippy_lints/src/mut_reference.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3aee654dd1be501c66d3f2c1813c5a6a93f666d0/clippy_lints%2Fsrc%2Fmut_reference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3aee654dd1be501c66d3f2c1813c5a6a93f666d0/clippy_lints%2Fsrc%2Fmut_reference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmut_reference.rs?ref=3aee654dd1be501c66d3f2c1813c5a6a93f666d0", "patch": "@@ -48,7 +48,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnnecessaryMutPassed {\n                 let def_id = cx.tables.type_dependent_defs()[e.hir_id].def_id();\n                 let substs = cx.tables.node_substs(e.hir_id);\n                 let method_type = cx.tcx.type_of(def_id).subst(cx.tcx, substs);\n-                check_arguments(cx, arguments, method_type, &path.name.as_str())\n+                check_arguments(cx, arguments, method_type, &path.ident.as_str())\n             },\n             _ => (),\n         }"}, {"sha": "bdef092b5332c98aa712fe62b44a610ea32111e3", "filename": "clippy_lints/src/needless_pass_by_value.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3aee654dd1be501c66d3f2c1813c5a6a93f666d0/clippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3aee654dd1be501c66d3f2c1813c5a6a93f666d0/clippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_pass_by_value.rs?ref=3aee654dd1be501c66d3f2c1813c5a6a93f666d0", "patch": "@@ -152,8 +152,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NeedlessPassByValue {\n \n             // Ignore `self`s.\n             if idx == 0 {\n-                if let PatKind::Binding(_, _, name, ..) = arg.pat.node {\n-                    if name.node.as_str() == \"self\" {\n+                if let PatKind::Binding(_, _, ident, ..) = arg.pat.node {\n+                    if ident.as_str() == \"self\" {\n                         continue;\n                     }\n                 }\n@@ -217,7 +217,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NeedlessPassByValue {\n                                 get_spans(cx, Some(body.id()), idx, &[(\"clone\", \".to_owned()\")]);\n                             if let TyPath(QPath::Resolved(_, ref path)) = input.node;\n                             if let Some(elem_ty) = path.segments.iter()\n-                                .find(|seg| seg.name == \"Vec\")\n+                                .find(|seg| seg.ident.name == \"Vec\")\n                                 .and_then(|ps| ps.args.as_ref())\n                                 .map(|params| params.args.iter().find_map(|arg| match arg {\n                                     GenericArg::Type(ty) => Some(ty),"}, {"sha": "3f7cbaa6ca1683f6b47f5f98872abf01ad1c64e3", "filename": "clippy_lints/src/new_without_default.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3aee654dd1be501c66d3f2c1813c5a6a93f666d0/clippy_lints%2Fsrc%2Fnew_without_default.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3aee654dd1be501c66d3f2c1813c5a6a93f666d0/clippy_lints%2Fsrc%2Fnew_without_default.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fnew_without_default.rs?ref=3aee654dd1be501c66d3f2c1813c5a6a93f666d0", "patch": "@@ -97,7 +97,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NewWithoutDefault {\n                         return;\n                     }\n                     if let hir::ImplItemKind::Method(ref sig, _) = impl_item.node {\n-                        let name = impl_item.name;\n+                        let name = impl_item.ident.name;\n                         let id = impl_item.id;\n                         if sig.header.constness == hir::Constness::Const {\n                             // can't be implemented by default"}, {"sha": "47c84fec6ae1713d36eaf065099ebffdab58b55a", "filename": "clippy_lints/src/non_copy_const.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3aee654dd1be501c66d3f2c1813c5a6a93f666d0/clippy_lints%2Fsrc%2Fnon_copy_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3aee654dd1be501c66d3f2c1813c5a6a93f666d0/clippy_lints%2Fsrc%2Fnon_copy_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fnon_copy_const.rs?ref=3aee654dd1be501c66d3f2c1813c5a6a93f666d0", "patch": "@@ -5,7 +5,7 @@\n use rustc::lint::{LateContext, LateLintPass, Lint, LintArray, LintPass};\n use rustc::hir::*;\n use rustc::hir::def::Def;\n-use rustc::ty::{self, TyRef, TypeFlags};\n+use rustc::ty::{self, TypeFlags};\n use rustc::ty::adjustment::Adjust;\n use rustc_errors::Applicability;\n use rustc_typeck::hir_ty_to_ty;"}, {"sha": "fbece8226597fde66ef67148b499cf5f9aa75540", "filename": "clippy_lints/src/open_options.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3aee654dd1be501c66d3f2c1813c5a6a93f666d0/clippy_lints%2Fsrc%2Fopen_options.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3aee654dd1be501c66d3f2c1813c5a6a93f666d0/clippy_lints%2Fsrc%2Fopen_options.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fopen_options.rs?ref=3aee654dd1be501c66d3f2c1813c5a6a93f666d0", "patch": "@@ -35,7 +35,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NonSensical {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx Expr) {\n         if let ExprMethodCall(ref path, _, ref arguments) = e.node {\n             let obj_ty = walk_ptrs_ty(cx.tables.expr_ty(&arguments[0]));\n-            if path.name == \"open\" && match_type(cx, obj_ty, &paths::OPEN_OPTIONS) {\n+            if path.ident.name == \"open\" && match_type(cx, obj_ty, &paths::OPEN_OPTIONS) {\n                 let mut options = Vec::new();\n                 get_open_options(cx, &arguments[0], &mut options);\n                 check_open_options(cx, &options, e.span);\n@@ -87,7 +87,7 @@ fn get_open_options(cx: &LateContext, argument: &Expr, options: &mut Vec<(OpenOp\n                 _ => Argument::Unknown,\n             };\n \n-            match &*path.name.as_str() {\n+            match &*path.ident.as_str() {\n                 \"create\" => {\n                     options.push((OpenOption::Create, argument_option));\n                 },"}, {"sha": "1d9260e2aa79216db0db37feffef5869f1ddf947", "filename": "clippy_lints/src/partialeq_ne_impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3aee654dd1be501c66d3f2c1813c5a6a93f666d0/clippy_lints%2Fsrc%2Fpartialeq_ne_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3aee654dd1be501c66d3f2c1813c5a6a93f666d0/clippy_lints%2Fsrc%2Fpartialeq_ne_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fpartialeq_ne_impl.rs?ref=3aee654dd1be501c66d3f2c1813c5a6a93f666d0", "patch": "@@ -44,7 +44,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n             if trait_ref.path.def.def_id() == eq_trait;\n             then {\n                 for impl_item in impl_items {\n-                    if impl_item.name == \"ne\" {\n+                    if impl_item.ident.name == \"ne\" {\n                         span_lint(cx,\n                                   PARTIALEQ_NE_IMPL,\n                                   impl_item.span,"}, {"sha": "d12f6ddd15a4cd600e9c4f48a1a228650499bc9f", "filename": "clippy_lints/src/question_mark.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3aee654dd1be501c66d3f2c1813c5a6a93f666d0/clippy_lints%2Fsrc%2Fquestion_mark.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3aee654dd1be501c66d3f2c1813c5a6a93f666d0/clippy_lints%2Fsrc%2Fquestion_mark.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fquestion_mark.rs?ref=3aee654dd1be501c66d3f2c1813c5a6a93f666d0", "patch": "@@ -54,7 +54,7 @@ impl QuestionMarkPass {\n         if_chain! {\n             if let ExprIf(ref if_expr, ref body, _) = expr.node;\n             if let ExprMethodCall(ref segment, _, ref args) = if_expr.node;\n-            if segment.name == \"is_none\";\n+            if segment.ident.name == \"is_none\";\n             if Self::expression_returns_none(cx, body);\n             if let Some(subject) = args.get(0);\n             if Self::is_option(cx, subject);"}, {"sha": "6ec624d26e9271a10b4e239274565d971f3d6003", "filename": "clippy_lints/src/ranges.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3aee654dd1be501c66d3f2c1813c5a6a93f666d0/clippy_lints%2Fsrc%2Franges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3aee654dd1be501c66d3f2c1813c5a6a93f666d0/clippy_lints%2Fsrc%2Franges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Franges.rs?ref=3aee654dd1be501c66d3f2c1813c5a6a93f666d0", "patch": "@@ -89,7 +89,7 @@ impl LintPass for Pass {\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n         if let ExprMethodCall(ref path, _, ref args) = expr.node {\n-            let name = path.name.as_str();\n+            let name = path.ident.as_str();\n \n             // Range with step_by(0).\n             if name == \"step_by\" && args.len() == 2 && has_step_by(cx, &args[0]) {\n@@ -108,13 +108,13 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n                 if_chain! {\n                     // .iter() call\n                     if let ExprMethodCall(ref iter_path, _, ref iter_args ) = *iter;\n-                    if iter_path.name == \"iter\";\n+                    if iter_path.ident.name == \"iter\";\n                     // range expression in .zip() call: 0..x.len()\n                     if let Some(higher::Range { start: Some(start), end: Some(end), .. }) = higher::range(cx, zip_arg);\n                     if is_integer_literal(start, 0);\n                     // .len() call\n                     if let ExprMethodCall(ref len_path, _, ref len_args) = end.node;\n-                    if len_path.name == \"len\" && len_args.len() == 1;\n+                    if len_path.ident.name == \"len\" && len_args.len() == 1;\n                     // .iter() and .len() called on same Path\n                     if let ExprPath(QPath::Resolved(_, ref iter_path)) = iter_args[0].node;\n                     if let ExprPath(QPath::Resolved(_, ref len_path)) = len_args[0].node;"}, {"sha": "03a5d58a3eecd7f4a170a776cd6d51a3d0b8957c", "filename": "clippy_lints/src/returns.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3aee654dd1be501c66d3f2c1813c5a6a93f666d0/clippy_lints%2Fsrc%2Freturns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3aee654dd1be501c66d3f2c1813c5a6a93f666d0/clippy_lints%2Fsrc%2Freturns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Freturns.rs?ref=3aee654dd1be501c66d3f2c1813c5a6a93f666d0", "patch": "@@ -114,7 +114,7 @@ impl ReturnPass {\n             if let Some(ref initexpr) = local.init;\n             if let ast::PatKind::Ident(_, ident, _) = local.pat.node;\n             if let ast::ExprKind::Path(_, ref path) = retexpr.node;\n-            if match_path_ast(path, &[&ident.name.as_str()]);\n+            if match_path_ast(path, &[&ident.as_str()]);\n             if !in_external_macro(cx, initexpr.span);\n             then {\n                     span_note_and_lint(cx,"}, {"sha": "a4bdd89a0378cc9e93d2a4cdfd90e90835921c50", "filename": "clippy_lints/src/serde_api.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3aee654dd1be501c66d3f2c1813c5a6a93f666d0/clippy_lints%2Fsrc%2Fserde_api.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3aee654dd1be501c66d3f2c1813c5a6a93f666d0/clippy_lints%2Fsrc%2Fserde_api.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fserde_api.rs?ref=3aee654dd1be501c66d3f2c1813c5a6a93f666d0", "patch": "@@ -36,7 +36,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Serde {\n                     let mut seen_str = None;\n                     let mut seen_string = None;\n                     for item in items {\n-                        match &*item.name.as_str() {\n+                        match &*item.ident.as_str() {\n                             \"visit_str\" => seen_str = Some(item.span),\n                             \"visit_string\" => seen_string = Some(item.span),\n                             _ => {},"}, {"sha": "d37023e4f8c817c5177ce4e915013875e79e0752", "filename": "clippy_lints/src/shadow.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3aee654dd1be501c66d3f2c1813c5a6a93f666d0/clippy_lints%2Fsrc%2Fshadow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3aee654dd1be501c66d3f2c1813c5a6a93f666d0/clippy_lints%2Fsrc%2Fshadow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fshadow.rs?ref=3aee654dd1be501c66d3f2c1813c5a6a93f666d0", "patch": "@@ -100,7 +100,7 @@ fn check_fn<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, decl: &'tcx FnDecl, body: &'tc\n     let mut bindings = Vec::new();\n     for arg in iter_input_pats(decl, body) {\n         if let PatKind::Binding(_, _, ident, _) = arg.pat.node {\n-            bindings.push((ident.node, ident.span))\n+            bindings.push((ident.name, ident.span))\n         }\n     }\n     check_expr(cx, &body.value, &mut bindings);\n@@ -164,8 +164,8 @@ fn check_pat<'a, 'tcx>(\n ) {\n     // TODO: match more stuff / destructuring\n     match pat.node {\n-        PatKind::Binding(_, _, ref ident, ref inner) => {\n-            let name = ident.node;\n+        PatKind::Binding(_, _, ident, ref inner) => {\n+            let name = ident.name;\n             if is_binding(cx, pat.hir_id) {\n                 let mut new_binding = true;\n                 for tup in bindings.iter_mut() {\n@@ -378,5 +378,5 @@ fn is_self_shadow(name: Name, expr: &Expr) -> bool {\n }\n \n fn path_eq_name(name: Name, path: &Path) -> bool {\n-    !path.is_global() && path.segments.len() == 1 && path.segments[0].name.as_str() == name.as_str()\n+    !path.is_global() && path.segments.len() == 1 && path.segments[0].ident.as_str() == name.as_str()\n }"}, {"sha": "62cd5de68f063713e6663b85df9904059650b3b4", "filename": "clippy_lints/src/strings.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3aee654dd1be501c66d3f2c1813c5a6a93f666d0/clippy_lints%2Fsrc%2Fstrings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3aee654dd1be501c66d3f2c1813c5a6a93f666d0/clippy_lints%2Fsrc%2Fstrings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fstrings.rs?ref=3aee654dd1be501c66d3f2c1813c5a6a93f666d0", "patch": "@@ -149,7 +149,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for StringLitAsBytes {\n         use crate::utils::{in_macro, snippet};\n \n         if let ExprMethodCall(ref path, _, ref args) = e.node {\n-            if path.name == \"as_bytes\" {\n+            if path.ident.name == \"as_bytes\" {\n                 if let ExprLit(ref lit) = args[0].node {\n                     if let LitKind::Str(ref lit_content, _) = lit.node {\n                         if lit_content.as_str().chars().all(|c| c.is_ascii()) && !in_macro(args[0].span) {"}, {"sha": "1037a1bc632ecc58b75edbccfc24f5f3c024f013", "filename": "clippy_lints/src/swap.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3aee654dd1be501c66d3f2c1813c5a6a93f666d0/clippy_lints%2Fsrc%2Fswap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3aee654dd1be501c66d3f2c1813c5a6a93f666d0/clippy_lints%2Fsrc%2Fswap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fswap.rs?ref=3aee654dd1be501c66d3f2c1813c5a6a93f666d0", "patch": "@@ -64,7 +64,7 @@ fn check_manual_swap(cx: &LateContext, block: &Block) {\n             if let StmtDecl(ref tmp, _) = w[0].node;\n             if let DeclLocal(ref tmp) = tmp.node;\n             if let Some(ref tmp_init) = tmp.init;\n-            if let PatKind::Binding(_, _, ref tmp_name, None) = tmp.pat.node;\n+            if let PatKind::Binding(_, _, ident, None) = tmp.pat.node;\n \n             // foo() = bar();\n             if let StmtSemi(ref first, _) = w[1].node;\n@@ -76,7 +76,7 @@ fn check_manual_swap(cx: &LateContext, block: &Block) {\n             if let ExprPath(QPath::Resolved(None, ref rhs2)) = rhs2.node;\n             if rhs2.segments.len() == 1;\n \n-            if tmp_name.node.as_str() == rhs2.segments[0].name.as_str();\n+            if ident.as_str() == rhs2.segments[0].ident.as_str();\n             if SpanlessEq::new(cx).ignore_fn().eq_expr(tmp_init, lhs1);\n             if SpanlessEq::new(cx).ignore_fn().eq_expr(rhs1, lhs2);\n             then {"}, {"sha": "61d496c1f0d3c00eeb332940f6035950d18949e8", "filename": "clippy_lints/src/types.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3aee654dd1be501c66d3f2c1813c5a6a93f666d0/clippy_lints%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3aee654dd1be501c66d3f2c1813c5a6a93f666d0/clippy_lints%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftypes.rs?ref=3aee654dd1be501c66d3f2c1813c5a6a93f666d0", "patch": "@@ -317,7 +317,7 @@ fn check_ty_rptr(cx: &LateContext, ast_ty: &hir::Ty, is_local: bool, lt: &Lifeti\n                     let ltopt = if lt.is_elided() {\n                         \"\".to_owned()\n                     } else {\n-                        format!(\"{} \", lt.name.name().as_str())\n+                        format!(\"{} \", lt.name.ident().name.as_str())\n                     };\n                     let mutopt = if mut_ty.mutbl == Mutability::MutMutable {\n                         \"mut \"\n@@ -1993,10 +1993,10 @@ impl<'a, 'b, 'tcx: 'a + 'b> Visitor<'tcx> for ImplicitHasherConstructorVisitor<'\n                 }\n \n                 if match_path(ty_path, &paths::HASHMAP) {\n-                    if method.name == \"new\" {\n+                    if method.ident.name == \"new\" {\n                         self.suggestions\n                             .insert(e.span, \"HashMap::default()\".to_string());\n-                    } else if method.name == \"with_capacity\" {\n+                    } else if method.ident.name == \"with_capacity\" {\n                         self.suggestions.insert(\n                             e.span,\n                             format!(\n@@ -2006,10 +2006,10 @@ impl<'a, 'b, 'tcx: 'a + 'b> Visitor<'tcx> for ImplicitHasherConstructorVisitor<'\n                         );\n                     }\n                 } else if match_path(ty_path, &paths::HASHSET) {\n-                    if method.name == \"new\" {\n+                    if method.ident.name == \"new\" {\n                         self.suggestions\n                             .insert(e.span, \"HashSet::default()\".to_string());\n-                    } else if method.name == \"with_capacity\" {\n+                    } else if method.ident.name == \"with_capacity\" {\n                         self.suggestions.insert(\n                             e.span,\n                             format!("}, {"sha": "316415d73ad2a676df1c456571270d8d6033978a", "filename": "clippy_lints/src/unused_io_amount.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3aee654dd1be501c66d3f2c1813c5a6a93f666d0/clippy_lints%2Fsrc%2Funused_io_amount.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3aee654dd1be501c66d3f2c1813c5a6a93f666d0/clippy_lints%2Fsrc%2Funused_io_amount.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funused_io_amount.rs?ref=3aee654dd1be501c66d3f2c1813c5a6a93f666d0", "patch": "@@ -57,7 +57,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedIoAmount {\n                 }\n             },\n \n-            hir::ExprMethodCall(ref path, _, ref args) => match &*path.name.as_str() {\n+            hir::ExprMethodCall(ref path, _, ref args) => match &*path.ident.as_str() {\n                 \"expect\" | \"unwrap\" | \"unwrap_or\" | \"unwrap_or_else\" => {\n                     check_method_call(cx, &args[0], expr);\n                 },\n@@ -71,7 +71,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedIoAmount {\n \n fn check_method_call(cx: &LateContext, call: &hir::Expr, expr: &hir::Expr) {\n     if let hir::ExprMethodCall(ref path, _, _) = call.node {\n-        let symbol = &*path.name.as_str();\n+        let symbol = &*path.ident.as_str();\n         if match_trait_method(cx, call, &paths::IO_READ) && symbol == \"read\" {\n             span_lint(\n                 cx,"}, {"sha": "5c5550ed30fb2e675a3059f6b1d13e941a11ea37", "filename": "clippy_lints/src/unused_label.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3aee654dd1be501c66d3f2c1813c5a6a93f666d0/clippy_lints%2Fsrc%2Funused_label.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3aee654dd1be501c66d3f2c1813c5a6a93f666d0/clippy_lints%2Fsrc%2Funused_label.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funused_label.rs?ref=3aee654dd1be501c66d3f2c1813c5a6a93f666d0", "patch": "@@ -70,10 +70,10 @@ impl<'a, 'tcx: 'a> Visitor<'tcx> for UnusedLabelVisitor<'a, 'tcx> {\n     fn visit_expr(&mut self, expr: &'tcx hir::Expr) {\n         match expr.node {\n             hir::ExprBreak(destination, _) | hir::ExprContinue(destination) => if let Some(label) = destination.label {\n-                self.labels.remove(&label.name.as_str());\n+                self.labels.remove(&label.ident.as_str());\n             },\n             hir::ExprLoop(_, Some(label), _) | hir::ExprWhile(_, _, Some(label)) => {\n-                self.labels.insert(label.name.as_str(), expr.span);\n+                self.labels.insert(label.ident.as_str(), expr.span);\n             },\n             _ => (),\n         }"}, {"sha": "b8e34cc66e16e15d1e68e4b5d025433dab8061ad", "filename": "clippy_lints/src/unwrap.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3aee654dd1be501c66d3f2c1813c5a6a93f666d0/clippy_lints%2Fsrc%2Funwrap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3aee654dd1be501c66d3f2c1813c5a6a93f666d0/clippy_lints%2Fsrc%2Funwrap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funwrap.rs?ref=3aee654dd1be501c66d3f2c1813c5a6a93f666d0", "patch": "@@ -95,7 +95,7 @@ fn collect_unwrap_info<'a, 'tcx: 'a>(\n             if let Expr_::ExprPath(QPath::Resolved(None, path)) = &args[0].node;\n             let ty = cx.tables.expr_ty(&args[0]);\n             if match_type(cx, ty, &paths::OPTION) || match_type(cx, ty, &paths::RESULT);\n-            let name = method_name.name.as_str();\n+            let name = method_name.ident.as_str();\n             if [\"is_some\", \"is_none\", \"is_ok\", \"is_err\"].contains(&&*name);\n             then {\n                 assert!(args.len() == 1);\n@@ -142,8 +142,8 @@ impl<'a, 'tcx: 'a> Visitor<'tcx> for UnwrappableVariablesVisitor<'a, 'tcx> {\n             if_chain! {\n                 if let Expr_::ExprMethodCall(ref method_name, _, ref args) = expr.node;\n                 if let Expr_::ExprPath(QPath::Resolved(None, ref path)) = args[0].node;\n-                if [\"unwrap\", \"unwrap_err\"].contains(&&*method_name.name.as_str());\n-                let call_to_unwrap = method_name.name == \"unwrap\";\n+                if [\"unwrap\", \"unwrap_err\"].contains(&&*method_name.ident.as_str());\n+                let call_to_unwrap = method_name.ident.name == \"unwrap\";\n                 if let Some(unwrappable) = self.unwrappables.iter()\n                     .find(|u| u.ident.def == path.def);\n                 then {\n@@ -154,7 +154,7 @@ impl<'a, 'tcx: 'a> Visitor<'tcx> for UnwrappableVariablesVisitor<'a, 'tcx> {\n                             expr.span,\n                             &format!(\"You checked before that `{}()` cannot fail. \\\n                             Instead of checking and unwrapping, it's better to use `if let` or `match`.\",\n-                            method_name.name),\n+                            method_name.ident.name),\n                             |db| { db.span_label(unwrappable.check.span, \"the check is happening here\"); },\n                         );\n                     } else {\n@@ -163,7 +163,7 @@ impl<'a, 'tcx: 'a> Visitor<'tcx> for UnwrappableVariablesVisitor<'a, 'tcx> {\n                             PANICKING_UNWRAP,\n                             expr.span,\n                             &format!(\"This call to `{}()` will always panic.\",\n-                            method_name.name),\n+                            method_name.ident.name),\n                             |db| { db.span_label(unwrappable.check.span, \"because of this check\"); },\n                         );\n                     }"}, {"sha": "10b69852ba53c54ca42ff52f8f0d1a0fa5fd2d51", "filename": "clippy_lints/src/use_self.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3aee654dd1be501c66d3f2c1813c5a6a93f666d0/clippy_lints%2Fsrc%2Fuse_self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3aee654dd1be501c66d3f2c1813c5a6a93f666d0/clippy_lints%2Fsrc%2Fuse_self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fuse_self.rs?ref=3aee654dd1be501c66d3f2c1813c5a6a93f666d0", "patch": "@@ -88,7 +88,7 @@ struct UseSelfVisitor<'a, 'tcx: 'a> {\n \n impl<'a, 'tcx> Visitor<'tcx> for UseSelfVisitor<'a, 'tcx> {\n     fn visit_path(&mut self, path: &'tcx Path, _id: NodeId) {\n-        if self.item_path.def == path.def && path.segments.last().expect(SEGMENTS_MSG).name != SelfType.name() {\n+        if self.item_path.def == path.def && path.segments.last().expect(SEGMENTS_MSG).ident.name != SelfType.name() {\n             span_lint_and_then(self.cx, USE_SELF, path.span, \"unnecessary structure name repetition\", |db| {\n                 db.span_suggestion(path.span, \"use the applicable keyword\", \"Self\".to_owned());\n             });"}, {"sha": "520c30b03c0fee102737e2387236ffc09d11380d", "filename": "clippy_lints/src/utils/author.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3aee654dd1be501c66d3f2c1813c5a6a93f666d0/clippy_lints%2Fsrc%2Futils%2Fauthor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3aee654dd1be501c66d3f2c1813c5a6a93f666d0/clippy_lints%2Fsrc%2Futils%2Fauthor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fauthor.rs?ref=3aee654dd1be501c66d3f2c1813c5a6a93f666d0", "patch": "@@ -395,7 +395,7 @@ impl<'tcx> Visitor<'tcx> for PrintVisitor {\n                 let obj_pat = self.next(\"object\");\n                 let field_name_pat = self.next(\"field_name\");\n                 println!(\"Field(ref {}, ref {}) = {};\", obj_pat, field_name_pat, current);\n-                println!(\"    if {}.node.as_str() == {:?}\", field_name_pat, field_ident.name.as_str());\n+                println!(\"    if {}.node.as_str() == {:?}\", field_name_pat, field_ident.as_str());\n                 self.current = obj_pat;\n                 self.visit_expr(object);\n             },\n@@ -487,7 +487,7 @@ impl<'tcx> Visitor<'tcx> for PrintVisitor {\n         let current = format!(\"{}.node\", self.current);\n         match pat.node {\n             PatKind::Wild => println!(\"Wild = {};\", current),\n-            PatKind::Binding(anno, _, name, ref sub) => {\n+            PatKind::Binding(anno, _, ident, ref sub) => {\n                 let anno_pat = match anno {\n                     BindingAnnotation::Unannotated => \"BindingAnnotation::Unannotated\",\n                     BindingAnnotation::Mutable => \"BindingAnnotation::Mutable\",\n@@ -503,7 +503,7 @@ impl<'tcx> Visitor<'tcx> for PrintVisitor {\n                 } else {\n                     println!(\"Binding({}, _, {}, None) = {};\", anno_pat, name_pat, current);\n                 }\n-                println!(\"    if {}.node.as_str() == \\\"{}\\\";\", name_pat, name.node.as_str());\n+                println!(\"    if {}.node.as_str() == \\\"{}\\\";\", name_pat, ident.as_str());\n             }\n             PatKind::Struct(ref path, ref fields, ignore) => {\n                 let path_pat = self.next(\"path\");\n@@ -671,7 +671,7 @@ fn print_path(path: &QPath, first: &mut bool) {\n             } else {\n                 print!(\", \");\n             }\n-            print!(\"{:?}\", segment.name.as_str());\n+            print!(\"{:?}\", segment.ident.as_str());\n         },\n         QPath::TypeRelative(ref ty, ref segment) => match ty.node {\n             hir::Ty_::TyPath(ref inner_path) => {\n@@ -681,7 +681,7 @@ fn print_path(path: &QPath, first: &mut bool) {\n                 } else {\n                     print!(\", \");\n                 }\n-                print!(\"{:?}\", segment.name.as_str());\n+                print!(\"{:?}\", segment.ident.as_str());\n             },\n             ref other => print!(\"/* unimplemented: {:?}*/\", other),\n         },"}, {"sha": "f95fb046b4978b15aae1c1db03713da7db19b663", "filename": "clippy_lints/src/utils/hir_utils.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/3aee654dd1be501c66d3f2c1813c5a6a93f666d0/clippy_lints%2Fsrc%2Futils%2Fhir_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3aee654dd1be501c66d3f2c1813c5a6a93f666d0/clippy_lints%2Fsrc%2Futils%2Fhir_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fhir_utils.rs?ref=3aee654dd1be501c66d3f2c1813c5a6a93f666d0", "patch": "@@ -77,7 +77,7 @@ impl<'a, 'tcx: 'a> SpanlessEq<'a, 'tcx> {\n         match (&left.node, &right.node) {\n             (&ExprAddrOf(l_mut, ref le), &ExprAddrOf(r_mut, ref re)) => l_mut == r_mut && self.eq_expr(le, re),\n             (&ExprContinue(li), &ExprContinue(ri)) => {\n-                both(&li.label, &ri.label, |l, r| l.name.as_str() == r.name.as_str())\n+                both(&li.label, &ri.label, |l, r| l.ident.as_str() == r.ident.as_str())\n             },\n             (&ExprAssign(ref ll, ref lr), &ExprAssign(ref rl, ref rr)) => self.eq_expr(ll, rl) && self.eq_expr(lr, rr),\n             (&ExprAssignOp(ref lo, ref ll, ref lr), &ExprAssignOp(ref ro, ref rl, ref rr)) => {\n@@ -91,7 +91,7 @@ impl<'a, 'tcx: 'a> SpanlessEq<'a, 'tcx> {\n                     })\n             },\n             (&ExprBreak(li, ref le), &ExprBreak(ri, ref re)) => {\n-                both(&li.label, &ri.label, |l, r| l.name.as_str() == r.name.as_str())\n+                both(&li.label, &ri.label, |l, r| l.ident.as_str() == r.ident.as_str())\n                     && both(le, re, |l, r| self.eq_expr(l, r))\n             },\n             (&ExprBox(ref l), &ExprBox(ref r)) => self.eq_expr(l, r),\n@@ -109,7 +109,7 @@ impl<'a, 'tcx: 'a> SpanlessEq<'a, 'tcx> {\n             },\n             (&ExprLit(ref l), &ExprLit(ref r)) => l.node == r.node,\n             (&ExprLoop(ref lb, ref ll, ref lls), &ExprLoop(ref rb, ref rl, ref rls)) => {\n-                lls == rls && self.eq_block(lb, rb) && both(ll, rl, |l, r| l.name.as_str() == r.name.as_str())\n+                lls == rls && self.eq_block(lb, rb) && both(ll, rl, |l, r| l.ident.as_str() == r.ident.as_str())\n             },\n             (&ExprMatch(ref le, ref la, ref ls), &ExprMatch(ref re, ref ra, ref rs)) => {\n                 ls == rs && self.eq_expr(le, re) && over(la, ra, |l, r| {\n@@ -138,7 +138,7 @@ impl<'a, 'tcx: 'a> SpanlessEq<'a, 'tcx> {\n             (&ExprUnary(l_op, ref le), &ExprUnary(r_op, ref re)) => l_op == r_op && self.eq_expr(le, re),\n             (&ExprArray(ref l), &ExprArray(ref r)) => self.eq_exprs(l, r),\n             (&ExprWhile(ref lc, ref lb, ref ll), &ExprWhile(ref rc, ref rb, ref rl)) => {\n-                self.eq_expr(lc, rc) && self.eq_block(lb, rb) && both(ll, rl, |l, r| l.name.as_str() == r.name.as_str())\n+                self.eq_expr(lc, rc) && self.eq_block(lb, rb) && both(ll, rl, |l, r| l.ident.as_str() == r.ident.as_str())\n             },\n             _ => false,\n         }\n@@ -172,7 +172,7 @@ impl<'a, 'tcx: 'a> SpanlessEq<'a, 'tcx> {\n                 self.eq_qpath(lp, rp) && over(la, ra, |l, r| self.eq_pat(l, r)) && ls == rs\n             },\n             (&PatKind::Binding(ref lb, _, ref li, ref lp), &PatKind::Binding(ref rb, _, ref ri, ref rp)) => {\n-                lb == rb && li.node.as_str() == ri.node.as_str() && both(lp, rp, |l, r| self.eq_pat(l, r))\n+                lb == rb && li.name.as_str() == ri.name.as_str() && both(lp, rp, |l, r| self.eq_pat(l, r))\n             },\n             (&PatKind::Path(ref l), &PatKind::Path(ref r)) => self.eq_qpath(l, r),\n             (&PatKind::Lit(ref l), &PatKind::Lit(ref r)) => self.eq_expr(l, r),\n@@ -228,7 +228,7 @@ impl<'a, 'tcx: 'a> SpanlessEq<'a, 'tcx> {\n     fn eq_path_segment(&mut self, left: &PathSegment, right: &PathSegment) -> bool {\n         // The == of idents doesn't work with different contexts,\n         // we have to be explicit about hygiene\n-        if left.name.as_str() != right.name.as_str() {\n+        if left.ident.as_str() != right.ident.as_str() {\n             return false;\n         }\n         match (&left.args, &right.args) {\n@@ -268,7 +268,7 @@ impl<'a, 'tcx: 'a> SpanlessEq<'a, 'tcx> {\n     }\n \n     fn eq_type_binding(&mut self, left: &TypeBinding, right: &TypeBinding) -> bool {\n-        left.name == right.name && self.eq_ty(&left.ty, &right.ty)\n+        left.ident.name == right.ident.name && self.eq_ty(&left.ty, &right.ty)\n     }\n }\n \n@@ -356,7 +356,7 @@ impl<'a, 'tcx: 'a> SpanlessHash<'a, 'tcx> {\n                 let c: fn(_) -> _ = ExprContinue;\n                 c.hash(&mut self.s);\n                 if let Some(i) = i.label {\n-                    self.hash_name(i.name);\n+                    self.hash_name(i.ident.name);\n                 }\n             },\n             ExprYield(ref e) => {\n@@ -393,7 +393,7 @@ impl<'a, 'tcx: 'a> SpanlessHash<'a, 'tcx> {\n                 let c: fn(_, _) -> _ = ExprBreak;\n                 c.hash(&mut self.s);\n                 if let Some(i) = i.label {\n-                    self.hash_name(i.name);\n+                    self.hash_name(i.ident.name);\n                 }\n                 if let Some(ref j) = *j {\n                     self.hash_expr(&*j);\n@@ -457,7 +457,7 @@ impl<'a, 'tcx: 'a> SpanlessHash<'a, 'tcx> {\n                 c.hash(&mut self.s);\n                 self.hash_block(b);\n                 if let Some(i) = *i {\n-                    self.hash_name(i.name);\n+                    self.hash_name(i.ident.name);\n                 }\n             },\n             ExprMatch(ref e, ref arms, ref s) => {\n@@ -478,7 +478,7 @@ impl<'a, 'tcx: 'a> SpanlessHash<'a, 'tcx> {\n             ExprMethodCall(ref path, ref _tys, ref args) => {\n                 let c: fn(_, _, _) -> _ = ExprMethodCall;\n                 c.hash(&mut self.s);\n-                self.hash_name(path.name);\n+                self.hash_name(path.ident.name);\n                 self.hash_exprs(args);\n             },\n             ExprRepeat(ref e, ref l_id) => {\n@@ -548,7 +548,7 @@ impl<'a, 'tcx: 'a> SpanlessHash<'a, 'tcx> {\n                 self.hash_expr(cond);\n                 self.hash_block(b);\n                 if let Some(l) = l {\n-                    self.hash_name(l.name);\n+                    self.hash_name(l.ident.name);\n                 }\n             },\n         }\n@@ -570,7 +570,7 @@ impl<'a, 'tcx: 'a> SpanlessHash<'a, 'tcx> {\n                 self.hash_path(path);\n             },\n             QPath::TypeRelative(_, ref path) => {\n-                self.hash_name(path.name);\n+                self.hash_name(path.ident.name);\n             },\n         }\n         // self.cx.tables.qpath_def(p, id).hash(&mut self.s);\n@@ -579,7 +579,7 @@ impl<'a, 'tcx: 'a> SpanlessHash<'a, 'tcx> {\n     pub fn hash_path(&mut self, p: &Path) {\n         p.is_global().hash(&mut self.s);\n         for p in &p.segments {\n-            self.hash_name(p.name);\n+            self.hash_name(p.ident.name);\n         }\n     }\n "}, {"sha": "b23464c80dee17a639bf3d0271e89a56ed8ecb20", "filename": "clippy_lints/src/utils/inspector.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3aee654dd1be501c66d3f2c1813c5a6a93f666d0/clippy_lints%2Fsrc%2Futils%2Finspector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3aee654dd1be501c66d3f2c1813c5a6a93f666d0/clippy_lints%2Fsrc%2Futils%2Finspector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Finspector.rs?ref=3aee654dd1be501c66d3f2c1813c5a6a93f666d0", "patch": "@@ -50,7 +50,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n         if !has_attr(&item.attrs) {\n             return;\n         }\n-        println!(\"impl item `{}`\", item.name);\n+        println!(\"impl item `{}`\", item.ident.name);\n         match item.vis {\n             hir::Visibility::Public => println!(\"public\"),\n             hir::Visibility::Crate(_) => println!(\"visible crate wide\"),\n@@ -181,7 +181,7 @@ fn print_expr(cx: &LateContext, expr: &hir::Expr, indent: usize) {\n         },\n         hir::ExprMethodCall(ref path, _, ref args) => {\n             println!(\"{}MethodCall\", ind);\n-            println!(\"{}method name: {}\", ind, path.name);\n+            println!(\"{}method name: {}\", ind, path.ident.name);\n             for arg in args {\n                 print_expr(cx, arg, indent + 1);\n             }\n@@ -268,7 +268,7 @@ fn print_expr(cx: &LateContext, expr: &hir::Expr, indent: usize) {\n             println!(\"{}rhs:\", ind);\n             print_expr(cx, rhs, indent + 1);\n         },\n-        hir::ExprField(ref e, ref ident) => {\n+        hir::ExprField(ref e, ident) => {\n             println!(\"{}Field\", ind);\n             println!(\"{}field name: {}\", ind, ident.name);\n             println!(\"{}struct expr:\", ind);\n@@ -417,10 +417,10 @@ fn print_pat(cx: &LateContext, pat: &hir::Pat, indent: usize) {\n     println!(\"{}+\", ind);\n     match pat.node {\n         hir::PatKind::Wild => println!(\"{}Wild\", ind),\n-        hir::PatKind::Binding(ref mode, _, ref name, ref inner) => {\n+        hir::PatKind::Binding(ref mode, _, ident, ref inner) => {\n             println!(\"{}Binding\", ind);\n             println!(\"{}mode: {:?}\", ind, mode);\n-            println!(\"{}name: {}\", ind, name.node);\n+            println!(\"{}name: {}\", ind, ident.name);\n             if let Some(ref inner) = *inner {\n                 println!(\"{}inner:\", ind);\n                 print_pat(cx, inner, indent + 1);"}, {"sha": "b1b65698eb9602f8d40deeff2000fc93c2760424", "filename": "clippy_lints/src/utils/internal_lints.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3aee654dd1be501c66d3f2c1813c5a6a93f666d0/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3aee654dd1be501c66d3f2c1813c5a6a93f666d0/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs?ref=3aee654dd1be501c66d3f2c1813c5a6a93f666d0", "patch": "@@ -78,7 +78,7 @@ impl EarlyLintPass for Clippy {\n                     if let ItemKind::Mod(ref paths_mod) = paths.node {\n                         let mut last_name: Option<LocalInternedString> = None;\n                         for item in &paths_mod.items {\n-                            let name = item.ident.name.as_str();\n+                            let name = item.ident.as_str();\n                             if let Some(ref last_name) = last_name {\n                                 if **last_name > *name {\n                                     span_lint(\n@@ -196,7 +196,7 @@ impl<'a, 'tcx: 'a> Visitor<'tcx> for LintCollector<'a, 'tcx> {\n \n     fn visit_path(&mut self, path: &'tcx Path, _: NodeId) {\n         if path.segments.len() == 1 {\n-            self.output.insert(path.segments[0].name);\n+            self.output.insert(path.segments[0].ident.name);\n         }\n     }\n     fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {"}, {"sha": "6765d9afb66d547240f29b6dea433d89e8e4f888", "filename": "clippy_lints/src/utils/mod.rs", "status": "modified", "additions": 20, "deletions": 12, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/3aee654dd1be501c66d3f2c1813c5a6a93f666d0/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3aee654dd1be501c66d3f2c1813c5a6a93f666d0/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fmod.rs?ref=3aee654dd1be501c66d3f2c1813c5a6a93f666d0", "patch": "@@ -175,7 +175,7 @@ pub fn match_trait_method(cx: &LateContext, expr: &Expr, path: &[&str]) -> bool\n /// Check if an expression references a variable of the given name.\n pub fn match_var(expr: &Expr, var: Name) -> bool {\n     if let ExprPath(QPath::Resolved(None, ref path)) = expr.node {\n-        if path.segments.len() == 1 && path.segments[0].name == var {\n+        if path.segments.len() == 1 && path.segments[0].ident.name == var {\n             return true;\n         }\n     }\n@@ -212,7 +212,7 @@ pub fn match_qpath(path: &QPath, segments: &[&str]) -> bool {\n         QPath::TypeRelative(ref ty, ref segment) => match ty.node {\n             TyPath(ref inner_path) => {\n                 !segments.is_empty() && match_qpath(inner_path, &segments[..(segments.len() - 1)])\n-                    && segment.name == segments[segments.len() - 1]\n+                    && segment.ident.name == segments[segments.len() - 1]\n             },\n             _ => false,\n         },\n@@ -224,7 +224,7 @@ pub fn match_path(path: &Path, segments: &[&str]) -> bool {\n         .iter()\n         .rev()\n         .zip(segments.iter().rev())\n-        .all(|(a, b)| a.name == *b)\n+        .all(|(a, b)| a.ident.name == *b)\n }\n \n /// Match a `Path` against a slice of segment string literals, e.g.\n@@ -331,7 +331,7 @@ pub fn method_chain_args<'a>(expr: &'a Expr, methods: &[&str]) -> Option<Vec<&'a\n     for method_name in methods.iter().rev() {\n         // method chains are stored last -> first\n         if let ExprMethodCall(ref path, _, ref args) = current.node {\n-            if path.name == *method_name {\n+            if path.ident.name == *method_name {\n                 if args.iter().any(|e| in_macro(e.span)) {\n                     return None;\n                 }\n@@ -353,18 +353,18 @@ pub fn method_chain_args<'a>(expr: &'a Expr, methods: &[&str]) -> Option<Vec<&'a\n pub fn get_item_name(cx: &LateContext, expr: &Expr) -> Option<Name> {\n     let parent_id = cx.tcx.hir.get_parent(expr.id);\n     match cx.tcx.hir.find(parent_id) {\n-        Some(Node::NodeItem(&Item { ref name, .. })) |\n-        Some(Node::NodeTraitItem(&TraitItem { ref name, .. })) |\n-        Some(Node::NodeImplItem(&ImplItem { ref name, .. })) => Some(*name),\n+        Some(Node::NodeItem(&Item { ref name, .. })) => Some(*name),\n+        Some(Node::NodeTraitItem(&TraitItem { ident, .. })) |\n+        Some(Node::NodeImplItem(&ImplItem { ident, .. })) => Some(ident.name),\n         _ => None,\n     }\n }\n \n /// Get the name of a `Pat`, if any\n pub fn get_pat_name(pat: &Pat) -> Option<Name> {\n     match pat.node {\n-        PatKind::Binding(_, _, ref spname, _) => Some(spname.node),\n-        PatKind::Path(ref qpath) => single_segment_path(qpath).map(|ps| ps.name),\n+        PatKind::Binding(_, _, ref spname, _) => Some(spname.name),\n+        PatKind::Path(ref qpath) => single_segment_path(qpath).map(|ps| ps.ident.name),\n         PatKind::Box(ref p) | PatKind::Ref(ref p, _) => get_pat_name(&*p),\n         _ => None,\n     }\n@@ -431,7 +431,7 @@ pub fn snippet_block<'a, 'b, T: LintContext<'b>>(cx: &T, span: Span, default: &'\n pub fn last_line_of_span<'a, T: LintContext<'a>>(cx: &T, span: Span) -> Span {\n     let file_map_and_line = cx.sess().codemap().lookup_line(span.lo()).unwrap();\n     let line_no = file_map_and_line.line;\n-    let line_start = &file_map_and_line.fm.lines.clone().into_inner()[line_no];\n+    let line_start = &file_map_and_line.fm.lines[line_no];\n     Span::new(*line_start, span.hi(), span.ctxt())\n }\n \n@@ -990,7 +990,7 @@ pub fn opt_def_id(def: Def) -> Option<DefId> {\n \n pub fn is_self(slf: &Arg) -> bool {\n     if let PatKind::Binding(_, _, name, _) = slf.pat.node {\n-        name.node == keywords::SelfValue.name()\n+        name.name == keywords::SelfValue.name()\n     } else {\n         false\n     }\n@@ -1068,12 +1068,20 @@ pub fn is_allowed(cx: &LateContext, lint: &'static Lint, id: NodeId) -> bool {\n \n pub fn get_arg_name(pat: &Pat) -> Option<ast::Name> {\n     match pat.node {\n-        PatKind::Binding(_, _, name, None) => Some(name.node),\n+        PatKind::Binding(_, _, ident, None) => Some(ident.name),\n         PatKind::Ref(ref subpat, _) => get_arg_name(subpat),\n         _ => None,\n     }\n }\n \n+pub fn get_arg_ident(pat: &Pat) -> Option<ast::Ident> {\n+    match pat.node {\n+        PatKind::Binding(_, _, ident, None) => Some(ident),\n+        PatKind::Ref(ref subpat, _) => get_arg_ident(subpat),\n+        _ => None,\n+    }\n+}\n+\n pub fn int_bits(tcx: TyCtxt, ity: ast::IntTy) -> u64 {\n     layout::Integer::from_attr(tcx, attr::IntType::SignedInt(ity)).size().bits()\n }"}, {"sha": "09ec90ac63fcd85b3b7b7889b69f65ea98ca5b2d", "filename": "clippy_lints/src/utils/ptr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3aee654dd1be501c66d3f2c1813c5a6a93f666d0/clippy_lints%2Fsrc%2Futils%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3aee654dd1be501c66d3f2c1813c5a6a93f666d0/clippy_lints%2Fsrc%2Futils%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fptr.rs?ref=3aee654dd1be501c66d3f2c1813c5a6a93f666d0", "patch": "@@ -56,12 +56,12 @@ impl<'a, 'tcx: 'a> Visitor<'tcx> for PtrCloneVisitor<'a, 'tcx> {\n         }\n         if let ExprMethodCall(ref seg, _, ref args) = expr.node {\n             if args.len() == 1 && match_var(&args[0], self.name) {\n-                if seg.name == \"capacity\" {\n+                if seg.ident.name == \"capacity\" {\n                     self.abort = true;\n                     return;\n                 }\n                 for &(fn_name, suffix) in self.replace {\n-                    if seg.name == fn_name {\n+                    if seg.ident.name == fn_name {\n                         self.spans\n                             .push((expr.span, snippet(self.cx, args[0].span, \"_\") + suffix));\n                         return;"}, {"sha": "86c95dbcc56458fba177ed7de8a7b31fe3f390a1", "filename": "clippy_lints/src/write.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3aee654dd1be501c66d3f2c1813c5a6a93f666d0/clippy_lints%2Fsrc%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3aee654dd1be501c66d3f2c1813c5a6a93f666d0/clippy_lints%2Fsrc%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fwrite.rs?ref=3aee654dd1be501c66d3f2c1813c5a6a93f666d0", "patch": "@@ -186,7 +186,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n             },\n             // write!()\n             ExprMethodCall(ref fun, _, ref args) => {\n-                if fun.name == \"write_fmt\" {\n+                if fun.ident.name == \"write_fmt\" {\n                     check_write_variants(cx, expr, args);\n                 }\n             },\n@@ -471,13 +471,13 @@ pub fn check_unformatted(format_field: &Expr) -> bool {\n         if let ExprStruct(_, ref fields, _) = format_field.node;\n         if let Some(width_field) = fields.iter().find(|f| f.ident.name == \"width\");\n         if let ExprPath(ref qpath) = width_field.expr.node;\n-        if last_path_segment(qpath).name == \"Implied\";\n+        if last_path_segment(qpath).ident.name == \"Implied\";\n         if let Some(align_field) = fields.iter().find(|f| f.ident.name == \"align\");\n         if let ExprPath(ref qpath) = align_field.expr.node;\n-        if last_path_segment(qpath).name == \"Unknown\";\n+        if last_path_segment(qpath).ident.name == \"Unknown\";\n         if let Some(precision_field) = fields.iter().find(|f| f.ident.name == \"precision\");\n         if let ExprPath(ref qpath_precision) = precision_field.expr.node;\n-        if last_path_segment(qpath_precision).name == \"Implied\";\n+        if last_path_segment(qpath_precision).ident.name == \"Implied\";\n         then {\n             return true;\n         }"}, {"sha": "bd6a57973fc5a29484ba2305a0575f5bf0dfe498", "filename": "min_version.txt", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3aee654dd1be501c66d3f2c1813c5a6a93f666d0/min_version.txt", "raw_url": "https://github.com/rust-lang/rust/raw/3aee654dd1be501c66d3f2c1813c5a6a93f666d0/min_version.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/min_version.txt?ref=3aee654dd1be501c66d3f2c1813c5a6a93f666d0", "patch": "@@ -1,7 +1,7 @@\n-rustc 1.28.0-nightly (01cc982e9 2018-06-24)\n+rustc 1.28.0-nightly (e3bf634e0 2018-06-28)\n binary: rustc\n-commit-hash: 01cc982e936120acb0424e41de14e42ba2d88c6f\n-commit-date: 2018-06-24\n+commit-hash: e3bf634e060bc2f8665878288bcea02008ca346e\n+commit-date: 2018-06-28\n host: x86_64-unknown-linux-gnu\n release: 1.28.0-nightly\n LLVM version: 6.0"}]}