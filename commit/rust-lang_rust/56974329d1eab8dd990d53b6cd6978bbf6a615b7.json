{"sha": "56974329d1eab8dd990d53b6cd6978bbf6a615b7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU2OTc0MzI5ZDFlYWI4ZGQ5OTBkNTNiNmNkNjk3OGJiZjZhNjE1Yjc=", "commit": {"author": {"name": "Stein Somers", "email": "git@steinsomers.be", "date": "2019-10-08T23:07:57Z"}, "committer": {"name": "Stein Somers", "email": "git@steinsomers.be", "date": "2019-10-17T22:11:32Z"}, "message": "BTreeSet symmetric_difference & union optimized, cleaned", "tree": {"sha": "001609600fc3bf768b780e16c9ba865c1d0b6346", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/001609600fc3bf768b780e16c9ba865c1d0b6346"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/56974329d1eab8dd990d53b6cd6978bbf6a615b7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/56974329d1eab8dd990d53b6cd6978bbf6a615b7", "html_url": "https://github.com/rust-lang/rust/commit/56974329d1eab8dd990d53b6cd6978bbf6a615b7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/56974329d1eab8dd990d53b6cd6978bbf6a615b7/comments", "author": {"login": "ssomers", "id": 10174877, "node_id": "MDQ6VXNlcjEwMTc0ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/10174877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ssomers", "html_url": "https://github.com/ssomers", "followers_url": "https://api.github.com/users/ssomers/followers", "following_url": "https://api.github.com/users/ssomers/following{/other_user}", "gists_url": "https://api.github.com/users/ssomers/gists{/gist_id}", "starred_url": "https://api.github.com/users/ssomers/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ssomers/subscriptions", "organizations_url": "https://api.github.com/users/ssomers/orgs", "repos_url": "https://api.github.com/users/ssomers/repos", "events_url": "https://api.github.com/users/ssomers/events{/privacy}", "received_events_url": "https://api.github.com/users/ssomers/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ssomers", "id": 10174877, "node_id": "MDQ6VXNlcjEwMTc0ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/10174877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ssomers", "html_url": "https://github.com/ssomers", "followers_url": "https://api.github.com/users/ssomers/followers", "following_url": "https://api.github.com/users/ssomers/following{/other_user}", "gists_url": "https://api.github.com/users/ssomers/gists{/gist_id}", "starred_url": "https://api.github.com/users/ssomers/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ssomers/subscriptions", "organizations_url": "https://api.github.com/users/ssomers/orgs", "repos_url": "https://api.github.com/users/ssomers/repos", "events_url": "https://api.github.com/users/ssomers/events{/privacy}", "received_events_url": "https://api.github.com/users/ssomers/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3da6836cc9fd654fa204fe7e113973f7b5b3e5f6", "url": "https://api.github.com/repos/rust-lang/rust/commits/3da6836cc9fd654fa204fe7e113973f7b5b3e5f6", "html_url": "https://github.com/rust-lang/rust/commit/3da6836cc9fd654fa204fe7e113973f7b5b3e5f6"}], "stats": {"total": 265, "additions": 144, "deletions": 121}, "files": [{"sha": "f0796354e00c384076f8a47a59f62b849556cd1e", "filename": "src/liballoc/collections/btree/set.rs", "status": "modified", "additions": 119, "deletions": 120, "changes": 239, "blob_url": "https://github.com/rust-lang/rust/blob/56974329d1eab8dd990d53b6cd6978bbf6a615b7/src%2Fliballoc%2Fcollections%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56974329d1eab8dd990d53b6cd6978bbf6a615b7/src%2Fliballoc%2Fcollections%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fset.rs?ref=56974329d1eab8dd990d53b6cd6978bbf6a615b7", "patch": "@@ -2,7 +2,7 @@\n // to TreeMap\n \n use core::borrow::Borrow;\n-use core::cmp::Ordering::{self, Less, Greater, Equal};\n+use core::cmp::Ordering::{Less, Greater, Equal};\n use core::cmp::{max, min};\n use core::fmt::{self, Debug};\n use core::iter::{Peekable, FromIterator, FusedIterator};\n@@ -109,6 +109,77 @@ pub struct Range<'a, T: 'a> {\n     iter: btree_map::Range<'a, T, ()>,\n }\n \n+/// Core of SymmetricDifference and Union.\n+/// More efficient than btree.map.MergeIter,\n+/// and crucially for SymmetricDifference, nexts() reports on both sides.\n+#[derive(Clone)]\n+struct MergeIterInner<I>\n+    where I: Iterator,\n+          I::Item: Copy,\n+{\n+    a: I,\n+    b: I,\n+    peeked: Option<MergeIterPeeked<I>>,\n+}\n+\n+#[derive(Copy, Clone, Debug)]\n+enum MergeIterPeeked<I: Iterator> {\n+    A(I::Item),\n+    B(I::Item),\n+}\n+\n+impl<I> MergeIterInner<I>\n+    where I: ExactSizeIterator + FusedIterator,\n+          I::Item: Copy + Ord,\n+{\n+    fn new(a: I, b: I) -> Self {\n+        MergeIterInner { a, b, peeked: None }\n+    }\n+\n+    fn nexts(&mut self) -> (Option<I::Item>, Option<I::Item>) {\n+        let mut a_next = match self.peeked {\n+            Some(MergeIterPeeked::A(next)) => Some(next),\n+            _ => self.a.next(),\n+        };\n+        let mut b_next = match self.peeked {\n+            Some(MergeIterPeeked::B(next)) => Some(next),\n+            _ => self.b.next(),\n+        };\n+        let ord = match (a_next, b_next) {\n+            (None, None) => Equal,\n+            (_, None) => Less,\n+            (None, _) => Greater,\n+            (Some(a1), Some(b1)) => a1.cmp(&b1),\n+        };\n+        self.peeked = match ord {\n+            Less => b_next.take().map(MergeIterPeeked::B),\n+            Equal => None,\n+            Greater => a_next.take().map(MergeIterPeeked::A),\n+        };\n+        (a_next, b_next)\n+    }\n+\n+    fn lens(&self) -> (usize, usize) {\n+        match self.peeked {\n+            Some(MergeIterPeeked::A(_)) => (1 + self.a.len(), self.b.len()),\n+            Some(MergeIterPeeked::B(_)) => (self.a.len(), 1 + self.b.len()),\n+            _ => (self.a.len(), self.b.len()),\n+        }\n+    }\n+}\n+\n+impl<I> Debug for MergeIterInner<I>\n+    where I: Iterator + Debug,\n+          I::Item: Copy + Debug,\n+{\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_tuple(\"MergeIterInner\")\n+            .field(&self.a)\n+            .field(&self.b)\n+            .finish()\n+    }\n+}\n+\n /// A lazy iterator producing elements in the difference of `BTreeSet`s.\n ///\n /// This `struct` is created by the [`difference`] method on [`BTreeSet`].\n@@ -120,6 +191,7 @@ pub struct Range<'a, T: 'a> {\n pub struct Difference<'a, T: 'a> {\n     inner: DifferenceInner<'a, T>,\n }\n+#[derive(Debug)]\n enum DifferenceInner<'a, T: 'a> {\n     Stitch {\n         // iterate all of self and some of other, spotting matches along the way\n@@ -137,21 +209,7 @@ enum DifferenceInner<'a, T: 'a> {\n #[stable(feature = \"collection_debug\", since = \"1.17.0\")]\n impl<T: fmt::Debug> fmt::Debug for Difference<'_, T> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        match &self.inner {\n-            DifferenceInner::Stitch {\n-                self_iter,\n-                other_iter,\n-            } => f\n-                .debug_tuple(\"Difference\")\n-                .field(&self_iter)\n-                .field(&other_iter)\n-                .finish(),\n-            DifferenceInner::Search {\n-                self_iter,\n-                other_set: _,\n-            } => f.debug_tuple(\"Difference\").field(&self_iter).finish(),\n-            DifferenceInner::Iterate(iter) => f.debug_tuple(\"Difference\").field(&iter).finish(),\n-        }\n+        f.debug_tuple(\"Difference\").field(&self.inner).finish()\n     }\n }\n \n@@ -163,18 +221,12 @@ impl<T: fmt::Debug> fmt::Debug for Difference<'_, T> {\n /// [`BTreeSet`]: struct.BTreeSet.html\n /// [`symmetric_difference`]: struct.BTreeSet.html#method.symmetric_difference\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct SymmetricDifference<'a, T: 'a> {\n-    a: Peekable<Iter<'a, T>>,\n-    b: Peekable<Iter<'a, T>>,\n-}\n+pub struct SymmetricDifference<'a, T: 'a>(MergeIterInner<Iter<'a, T>>);\n \n #[stable(feature = \"collection_debug\", since = \"1.17.0\")]\n impl<T: fmt::Debug> fmt::Debug for SymmetricDifference<'_, T> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.debug_tuple(\"SymmetricDifference\")\n-         .field(&self.a)\n-         .field(&self.b)\n-         .finish()\n+        f.debug_tuple(\"SymmetricDifference\").field(&self.0).finish()\n     }\n }\n \n@@ -189,6 +241,7 @@ impl<T: fmt::Debug> fmt::Debug for SymmetricDifference<'_, T> {\n pub struct Intersection<'a, T: 'a> {\n     inner: IntersectionInner<'a, T>,\n }\n+#[derive(Debug)]\n enum IntersectionInner<'a, T: 'a> {\n     Stitch {\n         // iterate similarly sized sets jointly, spotting matches along the way\n@@ -206,23 +259,7 @@ enum IntersectionInner<'a, T: 'a> {\n #[stable(feature = \"collection_debug\", since = \"1.17.0\")]\n impl<T: fmt::Debug> fmt::Debug for Intersection<'_, T> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        match &self.inner {\n-            IntersectionInner::Stitch {\n-                a,\n-                b,\n-            } => f\n-                .debug_tuple(\"Intersection\")\n-                .field(&a)\n-                .field(&b)\n-                .finish(),\n-            IntersectionInner::Search {\n-                small_iter,\n-                large_set: _,\n-            } => f.debug_tuple(\"Intersection\").field(&small_iter).finish(),\n-            IntersectionInner::Answer(answer) => {\n-                f.debug_tuple(\"Intersection\").field(&answer).finish()\n-            }\n-        }\n+        f.debug_tuple(\"Intersection\").field(&self.inner).finish()\n     }\n }\n \n@@ -234,18 +271,12 @@ impl<T: fmt::Debug> fmt::Debug for Intersection<'_, T> {\n /// [`BTreeSet`]: struct.BTreeSet.html\n /// [`union`]: struct.BTreeSet.html#method.union\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct Union<'a, T: 'a> {\n-    a: Peekable<Iter<'a, T>>,\n-    b: Peekable<Iter<'a, T>>,\n-}\n+pub struct Union<'a, T: 'a>(MergeIterInner<Iter<'a, T>>);\n \n #[stable(feature = \"collection_debug\", since = \"1.17.0\")]\n impl<T: fmt::Debug> fmt::Debug for Union<'_, T> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.debug_tuple(\"Union\")\n-         .field(&self.a)\n-         .field(&self.b)\n-         .finish()\n+        f.debug_tuple(\"Union\").field(&self.0).finish()\n     }\n }\n \n@@ -355,19 +386,16 @@ impl<T: Ord> BTreeSet<T> {\n                     self_iter.next_back();\n                     DifferenceInner::Iterate(self_iter)\n                 }\n-                _ => {\n-                    if self.len() <= other.len() / ITER_PERFORMANCE_TIPPING_SIZE_DIFF {\n-                        DifferenceInner::Search {\n-                            self_iter: self.iter(),\n-                            other_set: other,\n-                        }\n-                    } else {\n-                        DifferenceInner::Stitch {\n-                            self_iter: self.iter(),\n-                            other_iter: other.iter().peekable(),\n-                        }\n+                _ if self.len() <= other.len() / ITER_PERFORMANCE_TIPPING_SIZE_DIFF => {\n+                    DifferenceInner::Search {\n+                        self_iter: self.iter(),\n+                        other_set: other,\n                     }\n                 }\n+                _ => DifferenceInner::Stitch {\n+                    self_iter: self.iter(),\n+                    other_iter: other.iter().peekable(),\n+                },\n             },\n         }\n     }\n@@ -396,10 +424,7 @@ impl<T: Ord> BTreeSet<T> {\n     pub fn symmetric_difference<'a>(&'a self,\n                                     other: &'a BTreeSet<T>)\n                                     -> SymmetricDifference<'a, T> {\n-        SymmetricDifference {\n-            a: self.iter().peekable(),\n-            b: other.iter().peekable(),\n-        }\n+        SymmetricDifference(MergeIterInner::new(self.iter(), other.iter()))\n     }\n \n     /// Visits the values representing the intersection,\n@@ -447,24 +472,22 @@ impl<T: Ord> BTreeSet<T> {\n                 (Greater, _) | (_, Less) => IntersectionInner::Answer(None),\n                 (Equal, _) => IntersectionInner::Answer(Some(self_min)),\n                 (_, Equal) => IntersectionInner::Answer(Some(self_max)),\n-                _ => {\n-                    if self.len() <= other.len() / ITER_PERFORMANCE_TIPPING_SIZE_DIFF {\n-                        IntersectionInner::Search {\n-                            small_iter: self.iter(),\n-                            large_set: other,\n-                        }\n-                    } else if other.len() <= self.len() / ITER_PERFORMANCE_TIPPING_SIZE_DIFF {\n-                        IntersectionInner::Search {\n-                            small_iter: other.iter(),\n-                            large_set: self,\n-                        }\n-                    } else {\n-                        IntersectionInner::Stitch {\n-                            a: self.iter(),\n-                            b: other.iter(),\n-                        }\n+                _ if self.len() <= other.len() / ITER_PERFORMANCE_TIPPING_SIZE_DIFF => {\n+                    IntersectionInner::Search {\n+                        small_iter: self.iter(),\n+                        large_set: other,\n+                    }\n+                }\n+                _ if other.len() <= self.len() / ITER_PERFORMANCE_TIPPING_SIZE_DIFF => {\n+                    IntersectionInner::Search {\n+                        small_iter: other.iter(),\n+                        large_set: self,\n                     }\n                 }\n+                _ => IntersectionInner::Stitch {\n+                    a: self.iter(),\n+                    b: other.iter(),\n+                },\n             },\n         }\n     }\n@@ -489,10 +512,7 @@ impl<T: Ord> BTreeSet<T> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn union<'a>(&'a self, other: &'a BTreeSet<T>) -> Union<'a, T> {\n-        Union {\n-            a: self.iter().peekable(),\n-            b: other.iter().peekable(),\n-        }\n+        Union(MergeIterInner::new(self.iter(), other.iter()))\n     }\n \n     /// Clears the set, removing all values.\n@@ -1166,15 +1186,6 @@ impl<'a, T> DoubleEndedIterator for Range<'a, T> {\n #[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<T> FusedIterator for Range<'_, T> {}\n \n-/// Compares `x` and `y`, but return `short` if x is None and `long` if y is None\n-fn cmp_opt<T: Ord>(x: Option<&T>, y: Option<&T>, short: Ordering, long: Ordering) -> Ordering {\n-    match (x, y) {\n-        (None, _) => short,\n-        (_, None) => long,\n-        (Some(x1), Some(y1)) => x1.cmp(y1),\n-    }\n-}\n-\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Clone for Difference<'_, T> {\n     fn clone(&self) -> Self {\n@@ -1261,10 +1272,7 @@ impl<T: Ord> FusedIterator for Difference<'_, T> {}\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Clone for SymmetricDifference<'_, T> {\n     fn clone(&self) -> Self {\n-        SymmetricDifference {\n-            a: self.a.clone(),\n-            b: self.b.clone(),\n-        }\n+        SymmetricDifference(self.0.clone())\n     }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1273,19 +1281,19 @@ impl<'a, T: Ord> Iterator for SymmetricDifference<'a, T> {\n \n     fn next(&mut self) -> Option<&'a T> {\n         loop {\n-            match cmp_opt(self.a.peek(), self.b.peek(), Greater, Less) {\n-                Less => return self.a.next(),\n-                Equal => {\n-                    self.a.next();\n-                    self.b.next();\n-                }\n-                Greater => return self.b.next(),\n+            let (a_next, b_next) = self.0.nexts();\n+            if a_next.and(b_next).is_none() {\n+                return a_next.or(b_next);\n             }\n         }\n     }\n \n     fn size_hint(&self) -> (usize, Option<usize>) {\n-        (0, Some(self.a.len() + self.b.len()))\n+        let (a_len, b_len) = self.0.lens();\n+        // No checked_add, because even if a and b refer to the same set,\n+        // and T is an empty type, the storage overhead of sets limits\n+        // the number of elements to less than half the range of usize.\n+        (0, Some(a_len + b_len))\n     }\n }\n \n@@ -1311,7 +1319,7 @@ impl<T> Clone for Intersection<'_, T> {\n                     small_iter: small_iter.clone(),\n                     large_set,\n                 },\n-                IntersectionInner::Answer(answer) => IntersectionInner::Answer(answer.clone()),\n+                IntersectionInner::Answer(answer) => IntersectionInner::Answer(*answer),\n             },\n         }\n     }\n@@ -1365,30 +1373,21 @@ impl<T: Ord> FusedIterator for Intersection<'_, T> {}\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Clone for Union<'_, T> {\n     fn clone(&self) -> Self {\n-        Union {\n-            a: self.a.clone(),\n-            b: self.b.clone(),\n-        }\n+        Union(self.0.clone())\n     }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T: Ord> Iterator for Union<'a, T> {\n     type Item = &'a T;\n \n     fn next(&mut self) -> Option<&'a T> {\n-        match cmp_opt(self.a.peek(), self.b.peek(), Greater, Less) {\n-            Less => self.a.next(),\n-            Equal => {\n-                self.b.next();\n-                self.a.next()\n-            }\n-            Greater => self.b.next(),\n-        }\n+        let (a_next, b_next) = self.0.nexts();\n+        a_next.or(b_next)\n     }\n \n     fn size_hint(&self) -> (usize, Option<usize>) {\n-        let a_len = self.a.len();\n-        let b_len = self.b.len();\n+        let (a_len, b_len) = self.0.lens();\n+        // No checked_add - see SymmetricDifference::size_hint.\n         (max(a_len, b_len), Some(a_len + b_len))\n     }\n }"}, {"sha": "e4883abc8b56c3362d1fd4726f0d73746f430971", "filename": "src/liballoc/tests/btree/set.rs", "status": "modified", "additions": 25, "deletions": 1, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/56974329d1eab8dd990d53b6cd6978bbf6a615b7/src%2Fliballoc%2Ftests%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56974329d1eab8dd990d53b6cd6978bbf6a615b7/src%2Fliballoc%2Ftests%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fbtree%2Fset.rs?ref=56974329d1eab8dd990d53b6cd6978bbf6a615b7", "patch": "@@ -221,6 +221,18 @@ fn test_symmetric_difference() {\n                                &[-2, 1, 5, 11, 14, 22]);\n }\n \n+#[test]\n+fn test_symmetric_difference_size_hint() {\n+    let x: BTreeSet<i32> = [2, 4].iter().copied().collect();\n+    let y: BTreeSet<i32> = [1, 2, 3].iter().copied().collect();\n+    let mut iter = x.symmetric_difference(&y);\n+    assert_eq!(iter.size_hint(), (0, Some(5)));\n+    assert_eq!(iter.next(), Some(&1));\n+    assert_eq!(iter.size_hint(), (0, Some(4)));\n+    assert_eq!(iter.next(), Some(&3));\n+    assert_eq!(iter.size_hint(), (0, Some(1)));\n+}\n+\n #[test]\n fn test_union() {\n     fn check_union(a: &[i32], b: &[i32], expected: &[i32]) {\n@@ -235,6 +247,18 @@ fn test_union() {\n                 &[-2, 1, 3, 5, 9, 11, 13, 16, 19, 24]);\n }\n \n+#[test]\n+fn test_union_size_hint() {\n+    let x: BTreeSet<i32> = [2, 4].iter().copied().collect();\n+    let y: BTreeSet<i32> = [1, 2, 3].iter().copied().collect();\n+    let mut iter = x.union(&y);\n+    assert_eq!(iter.size_hint(), (3, Some(5)));\n+    assert_eq!(iter.next(), Some(&1));\n+    assert_eq!(iter.size_hint(), (2, Some(4)));\n+    assert_eq!(iter.next(), Some(&2));\n+    assert_eq!(iter.size_hint(), (1, Some(2)));\n+}\n+\n #[test]\n // Only tests the simple function definition with respect to intersection\n fn test_is_disjoint() {\n@@ -244,7 +268,7 @@ fn test_is_disjoint() {\n }\n \n #[test]\n-// Also tests the trivial function definition of is_superset\n+// Also implicitly tests the trivial function definition of is_superset\n fn test_is_subset() {\n     fn is_subset(a: &[i32], b: &[i32]) -> bool {\n         let set_a = a.iter().collect::<BTreeSet<_>>();"}]}