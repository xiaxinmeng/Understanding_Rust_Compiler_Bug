{"sha": "536cb90a216a08870fbaac6aad93f77f0681537d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUzNmNiOTBhMjE2YTA4ODcwZmJhYWM2YWFkOTNmNzdmMDY4MTUzN2Q=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2012-08-31T02:01:22Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2012-08-31T02:05:54Z"}, "message": "Migrate core::send_map to random, keyed hashes w/ hash::Hash trait.", "tree": {"sha": "92020449953adee5178ec5c9f10901577691d779", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/92020449953adee5178ec5c9f10901577691d779"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/536cb90a216a08870fbaac6aad93f77f0681537d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/536cb90a216a08870fbaac6aad93f77f0681537d", "html_url": "https://github.com/rust-lang/rust/commit/536cb90a216a08870fbaac6aad93f77f0681537d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/536cb90a216a08870fbaac6aad93f77f0681537d/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3462bb6a462253333758b12a8cb1ee72981329cb", "url": "https://api.github.com/repos/rust-lang/rust/commits/3462bb6a462253333758b12a8cb1ee72981329cb", "html_url": "https://github.com/rust-lang/rust/commit/3462bb6a462253333758b12a8cb1ee72981329cb"}], "stats": {"total": 111, "additions": 56, "deletions": 55}, "files": [{"sha": "1b579e1d49779da5b6fa640c7103d28e802ba579", "filename": "src/libcore/hash.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/536cb90a216a08870fbaac6aad93f77f0681537d/src%2Flibcore%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/536cb90a216a08870fbaac6aad93f77f0681537d/src%2Flibcore%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhash.rs?ref=536cb90a216a08870fbaac6aad93f77f0681537d", "patch": "@@ -17,7 +17,7 @@ import io::Writer;\n import io::WriterUtil;\n import to_bytes::IterBytes;\n \n-export Streaming, State;\n+export Streaming, State, Hash, HashUtil;\n export default_state;\n export hash_bytes_keyed;\n export hash_str_keyed;"}, {"sha": "d5323abe05a609b198e9719680c9a905eaa7e156", "filename": "src/libcore/send_map.rs", "status": "modified", "additions": 33, "deletions": 40, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/536cb90a216a08870fbaac6aad93f77f0681537d/src%2Flibcore%2Fsend_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/536cb90a216a08870fbaac6aad93f77f0681537d/src%2Flibcore%2Fsend_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fsend_map.rs?ref=536cb90a216a08870fbaac6aad93f77f0681537d", "patch": "@@ -4,16 +4,11 @@ Sendable hash maps.  Very much a work in progress.\n \n */\n \n+import cmp::Eq;\n+import hash::Hash;\n+import to_bytes::IterBytes;\n \n-/**\n- * A function that returns a hash of a value\n- *\n- * The hash should concentrate entropy in the lower bits.\n- */\n-type HashFn<K> = pure fn~(K) -> uint;\n-type EqFn<K> = pure fn~(K, K) -> bool;\n-\n-trait SendMap<K, V: copy> {\n+trait SendMap<K:Eq Hash, V: copy> {\n     // FIXME(#3148)  ^^^^ once find_ref() works, we can drop V:copy\n \n     fn insert(&mut self, +k: K, +v: V) -> bool;\n@@ -34,14 +29,14 @@ mod linear {\n     export LinearMap, linear_map, linear_map_with_capacity, public_methods;\n \n     const initial_capacity: uint = 32u; // 2^5\n-    struct Bucket<K,V> {\n+    struct Bucket<K:Eq Hash,V> {\n         hash: uint;\n         key: K;\n         value: V;\n     }\n-    struct LinearMap<K,V> {\n-        hashfn: pure fn~(x: &K) -> uint;\n-        eqfn: pure fn~(x: &K, y: &K) -> bool;\n+    struct LinearMap<K:Eq Hash,V> {\n+        k0: u64;\n+        k1: u64;\n         resize_at: uint;\n         size: uint;\n         buckets: ~[Option<Bucket<K,V>>];\n@@ -58,28 +53,29 @@ mod linear {\n         ((capacity as float) * 3. / 4.) as uint\n     }\n \n-    fn LinearMap<K,V>(\n-        +hashfn: pure fn~(x: &K) -> uint,\n-        +eqfn: pure fn~(x: &K, y: &K) -> bool) -> LinearMap<K,V> {\n-\n-        linear_map_with_capacity(hashfn, eqfn, 32)\n+    fn LinearMap<K:Eq Hash,V>() -> LinearMap<K,V> {\n+        linear_map_with_capacity(32)\n     }\n \n-    fn linear_map_with_capacity<K,V>(\n-        +hashfn: pure fn~(x: &K) -> uint,\n-        +eqfn: pure fn~(x: &K, y: &K) -> bool,\n+    fn linear_map_with_capacity<K:Eq Hash,V>(\n         initial_capacity: uint) -> LinearMap<K,V> {\n+        let r = rand::Rng();\n+        linear_map_with_capacity_and_keys(r.gen_u64(), r.gen_u64(),\n+                                          initial_capacity)\n+    }\n \n+    fn linear_map_with_capacity_and_keys<K:Eq Hash,V> (\n+        k0: u64, k1: u64,\n+        initial_capacity: uint) -> LinearMap<K,V> {\n         LinearMap {\n-            hashfn: hashfn,\n-            eqfn: eqfn,\n+            k0: k0, k1: k1,\n             resize_at: resize_at(initial_capacity),\n             size: 0,\n             buckets: vec::from_fn(initial_capacity, |_i| None)\n         }\n     }\n \n-    priv impl<K, V> LinearMap<K,V> {\n+    priv impl<K:Hash IterBytes Eq, V> LinearMap<K,V> {\n         #[inline(always)]\n         pure fn to_bucket(&const self,\n                           h: uint) -> uint {\n@@ -123,7 +119,7 @@ mod linear {\n         pure fn bucket_for_key(&const self,\n                                buckets: &[Option<Bucket<K,V>>],\n                                k: &K) -> SearchResult {\n-            let hash = self.hashfn(k);\n+            let hash = k.hash_keyed(self.k0, self.k1) as uint;\n             self.bucket_for_key_with_hash(buckets, hash, k)\n         }\n \n@@ -134,7 +130,7 @@ mod linear {\n                                          k: &K) -> SearchResult {\n             let _ = for self.bucket_sequence(hash) |i| {\n                 match buckets[i] {\n-                  Some(bkt) => if bkt.hash == hash && self.eqfn(k, &bkt.key) {\n+                  Some(bkt) => if bkt.hash == hash && *k == bkt.key {\n                     return FoundEntry(i);\n                   },\n                   None => return FoundHole(i)\n@@ -204,7 +200,7 @@ mod linear {\n         }\n     }\n \n-    impl<K,V> LinearMap<K,V> {\n+    impl<K:Hash IterBytes Eq,V> LinearMap<K,V> {\n         fn insert(&mut self, +k: K, +v: V) -> bool {\n             if self.size >= self.resize_at {\n                 // n.b.: We could also do this after searching, so\n@@ -216,7 +212,7 @@ mod linear {\n                 self.expand();\n             }\n \n-            let hash = self.hashfn(&k);\n+            let hash = k.hash_keyed(self.k0, self.k1) as uint;\n             self.insert_internal(hash, k, v)\n         }\n \n@@ -319,7 +315,7 @@ mod linear {\n         }\n     }\n \n-    impl<K,V: copy> LinearMap<K,V> {\n+    impl<K:Hash IterBytes Eq, V: copy> LinearMap<K,V> {\n         fn find(&const self, k: &K) -> Option<V> {\n             match self.bucket_for_key(self.buckets, k) {\n               FoundEntry(idx) => {\n@@ -346,17 +342,17 @@ mod linear {\n \n     }\n \n-    impl<K: copy, V: copy> LinearMap<K,V> {\n+    impl<K: Hash IterBytes Eq copy, V: copy> LinearMap<K,V> {\n         fn each(&self, blk: fn(+K,+V) -> bool) {\n             self.each_ref(|k,v| blk(copy *k, copy *v));\n         }\n     }\n-    impl<K: copy, V> LinearMap<K,V> {\n+    impl<K: Hash IterBytes Eq copy, V> LinearMap<K,V> {\n         fn each_key(&self, blk: fn(+K) -> bool) {\n             self.each_key_ref(|k| blk(copy *k));\n         }\n     }\n-    impl<K, V: copy> LinearMap<K,V> {\n+    impl<K: Hash IterBytes Eq, V: copy> LinearMap<K,V> {\n         fn each_value(&self, blk: fn(+V) -> bool) {\n             self.each_value_ref(|v| blk(copy *v));\n         }\n@@ -368,11 +364,8 @@ mod test {\n \n     import linear::LinearMap;\n \n-    pure fn uint_hash(x: &uint) -> uint { *x }\n-    pure fn uint_eq(x: &uint, y: &uint) -> bool { *x == *y }\n-\n     fn int_linear_map<V>() -> LinearMap<uint,V> {\n-        return LinearMap(uint_hash, uint_eq);\n+        return LinearMap();\n     }\n \n     #[test]\n@@ -395,7 +388,7 @@ mod test {\n \n     #[test]\n     fn conflicts() {\n-        let mut m = ~linear::linear_map_with_capacity(uint_hash, uint_eq, 4);\n+        let mut m = ~linear::linear_map_with_capacity(4);\n         assert m.insert(1, 2);\n         assert m.insert(5, 3);\n         assert m.insert(9, 4);\n@@ -406,7 +399,7 @@ mod test {\n \n     #[test]\n     fn conflict_remove() {\n-        let mut m = ~linear::linear_map_with_capacity(uint_hash, uint_eq, 4);\n+        let mut m = ~linear::linear_map_with_capacity(4);\n         assert m.insert(1, 2);\n         assert m.insert(5, 3);\n         assert m.insert(9, 4);\n@@ -417,7 +410,7 @@ mod test {\n \n     #[test]\n     fn empty() {\n-        let mut m = ~linear::linear_map_with_capacity(uint_hash, uint_eq, 4);\n+        let mut m = ~linear::linear_map_with_capacity(4);\n         assert m.insert(1, 2);\n         assert !m.is_empty();\n         assert m.remove(&1);\n@@ -426,7 +419,7 @@ mod test {\n \n     #[test]\n     fn iterate() {\n-        let mut m = linear::linear_map_with_capacity(uint_hash, uint_eq, 4);\n+        let mut m = linear::linear_map_with_capacity(4);\n         for uint::range(0, 32) |i| {\n             assert (&mut m).insert(i, i*2);\n         }"}, {"sha": "f1c461d5c1ca138b123fb0947551d043efa40737", "filename": "src/libcore/task.rs", "status": "modified", "additions": 1, "deletions": 11, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/536cb90a216a08870fbaac6aad93f77f0681537d/src%2Flibcore%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/536cb90a216a08870fbaac6aad93f77f0681537d/src%2Flibcore%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask.rs?ref=536cb90a216a08870fbaac6aad93f77f0681537d", "patch": "@@ -731,17 +731,7 @@ type rust_closure = libc::c_void;\n type TaskSet = send_map::linear::LinearMap<*rust_task,()>;\n \n fn new_taskset() -> TaskSet {\n-    pure fn task_hash(t: &*rust_task) -> uint {\n-        let task: *rust_task = *t;\n-        hash::hash_uint(task as uint) as uint\n-    }\n-    pure fn task_eq(t1: &*rust_task, t2: &*rust_task) -> bool {\n-        let task1: *rust_task = *t1;\n-        let task2: *rust_task = *t2;\n-        task1 == task2\n-    }\n-\n-    send_map::linear::LinearMap(task_hash, task_eq)\n+    send_map::linear::LinearMap()\n }\n fn taskset_insert(tasks: &mut TaskSet, task: *rust_task) {\n     let didnt_overwrite = tasks.insert(task, ());"}, {"sha": "e379b3dbc688969701e977c2bec3c14dd188345a", "filename": "src/libcore/to_bytes.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/536cb90a216a08870fbaac6aad93f77f0681537d/src%2Flibcore%2Fto_bytes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/536cb90a216a08870fbaac6aad93f77f0681537d/src%2Flibcore%2Fto_bytes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fto_bytes.rs?ref=536cb90a216a08870fbaac6aad93f77f0681537d", "patch": "@@ -290,6 +290,19 @@ impl<A: IterBytes> ~A: IterBytes {\n     }\n }\n \n+// NB: raw-pointer IterBytes does _not_ dereference\n+// to the target; it just gives you the pointer-bytes.\n+impl<A> *A: IterBytes {\n+    #[inline(always)]\n+    fn iter_le_bytes(f: Cb) {\n+        (self as uint).iter_le_bytes(f);\n+    }\n+    #[inline(always)]\n+    fn iter_be_bytes(f: Cb) {\n+        (self as uint).iter_be_bytes(f);\n+    }\n+}\n+\n \n trait ToBytes {\n     fn to_le_bytes() -> ~[u8];"}, {"sha": "2a2e6b5efc697e13ac52637689beaf2d174d2873", "filename": "src/libstd/map.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/536cb90a216a08870fbaac6aad93f77f0681537d/src%2Flibstd%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/536cb90a216a08870fbaac6aad93f77f0681537d/src%2Flibstd%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmap.rs?ref=536cb90a216a08870fbaac6aad93f77f0681537d", "patch": "@@ -7,6 +7,10 @@ import to_str::ToStr;\n import managed::Managed;\n import send_map::linear::LinearMap;\n \n+import core::cmp::Eq;\n+import hash::Hash;\n+import to_bytes::IterBytes;\n+\n export hashmap, hashfn, eqfn, set, map, chained, hashmap, str_hash;\n export box_str_hash;\n export bytes_hash, int_hash, uint_hash, set_add;\n@@ -478,7 +482,8 @@ fn hash_from_uints<V: copy>(items: &[(uint, V)]) -> hashmap<uint, V> {\n }\n \n // XXX Transitionary\n-impl<K: copy, V: copy> Managed<LinearMap<K, V>>: map<K, V> {\n+impl<K: Eq IterBytes Hash copy, V: copy> Managed<LinearMap<K, V>>:\n+    map<K, V> {\n     pure fn size() -> uint {\n         unchecked {\n             do self.borrow_const |p| {"}, {"sha": "63ce09585702928c37b27486128d5012afeff7a3", "filename": "src/test/bench/core-map.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/536cb90a216a08870fbaac6aad93f77f0681537d/src%2Ftest%2Fbench%2Fcore-map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/536cb90a216a08870fbaac6aad93f77f0681537d/src%2Ftest%2Fbench%2Fcore-map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-map.rs?ref=536cb90a216a08870fbaac6aad93f77f0681537d", "patch": "@@ -168,10 +168,10 @@ fn main(args: ~[~str]) {\n         let rng = rand::seeded_rng(copy seed);\n         let mut results = empty_results();\n         int_benchmarks::<Managed<LinearMap<uint, uint>>>(\n-            || Managed(LinearMap(uint::hash, uint::eq)),\n+            || Managed(LinearMap()),\n             rng, num_keys, &mut results);\n         str_benchmarks::<Managed<LinearMap<~str, uint>>>(\n-            || Managed(LinearMap(str::hash, str::eq)),\n+            || Managed(LinearMap()),\n             rng, num_keys, &mut results);\n         write_results(\"libstd::map::hashmap\", &results);\n     }"}]}