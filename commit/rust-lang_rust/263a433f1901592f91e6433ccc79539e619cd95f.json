{"sha": "263a433f1901592f91e6433ccc79539e619cd95f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI2M2E0MzNmMTkwMTU5MmY5MWU2NDMzY2NjNzk1MzllNjE5Y2Q5NWY=", "commit": {"author": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2014-06-13T15:19:29Z"}, "committer": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2014-06-18T14:41:53Z"}, "message": "Ensure dataflow of a proc never looks at blocks from closed-over context.\n\nDetails: in a program like:\n```\ntype T = proc(int) -> int; /* 4 */\n\npub fn outer(captured /* pat 16 */: T) -> T {\n    (proc(x /* pat 23 */) {\n        ((captured /* 29 */).foo((x /* 30 */)) /* 28 */)\n    } /* block 27 */ /* 20 */)\n} /* block 19 */ /* 12 */\n```\nthe `captured` arg is moved from the outer fn into the inner proc (id=20).\n\nThe old dataflow analysis for flowed_move_data_moves, when looking at\nthe inner proc, would attempt to add a kill bit for `captured` at the\nend of its scope; the problem is that it thought the end of the\n`captured` arg's scope was the outer fn (id=12), even though at that\npoint in the analysis, the `captured` arg's scope should now be\nrestricted to the proc itself (id=20).\n\nThis patch fixes handling of upvars so that dataflow of a fn/proc\nshould never attempts to add a gen or kill bit to any NodeId outside\nof the current fn/proc.  It accomplishes this by adding an `LpUpvar`\nvariant to `borrowck::LoanPath`, so for cases like `captured` above\nwill carry both their original `var_id`, as before, as well as the\n`NodeId` for the closure that is capturing them.\n\nAs a drive-by fix to another occurrence of a similar bug that\nnikomatsakis pointed out to me earlier, this also fixes\n`gather_loans::compute_kill_scope` so that it computes the kill scope\nof the `captured` arg to be block 27; that is, the block for the proc\nitself (id=20).\n\n(This is an updated version that generalizes the new loan path variant\nto cover all upvars, and thus renamed the variant from `LpCopiedUpvar`\nto just `LpUpvar`.)", "tree": {"sha": "e46e09955b18fb7bc39c455b600ff743ac7a933f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e46e09955b18fb7bc39c455b600ff743ac7a933f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/263a433f1901592f91e6433ccc79539e619cd95f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/263a433f1901592f91e6433ccc79539e619cd95f", "html_url": "https://github.com/rust-lang/rust/commit/263a433f1901592f91e6433ccc79539e619cd95f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/263a433f1901592f91e6433ccc79539e619cd95f/comments", "author": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4d82456f69d858bb8ebd7bfc508365cf983eea54", "url": "https://api.github.com/repos/rust-lang/rust/commits/4d82456f69d858bb8ebd7bfc508365cf983eea54", "html_url": "https://github.com/rust-lang/rust/commit/4d82456f69d858bb8ebd7bfc508365cf983eea54"}], "stats": {"total": 124, "additions": 82, "deletions": 42}, "files": [{"sha": "df208b9cdc133f85f352a0a3a60dec63e8433968", "filename": "src/librustc/middle/borrowck/check_loans.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/263a433f1901592f91e6433ccc79539e619cd95f/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/263a433f1901592f91e6433ccc79539e619cd95f/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs?ref=263a433f1901592f91e6433ccc79539e619cd95f", "patch": "@@ -242,7 +242,7 @@ impl<'a> CheckLoanCtxt<'a> {\n         let mut loan_path = loan_path;\n         loop {\n             match *loan_path {\n-                LpVar(_) => {\n+                LpVar(_) | LpUpvar(_) => {\n                     break;\n                 }\n                 LpExtend(ref lp_base, _, _) => {\n@@ -632,7 +632,7 @@ impl<'a> CheckLoanCtxt<'a> {\n          */\n \n         match **lp {\n-            LpVar(_) => {\n+            LpVar(_) | LpUpvar(_) => {\n                 // assigning to `x` does not require that `x` is initialized\n             }\n             LpExtend(ref lp_base, _, LpInterior(_)) => {"}, {"sha": "454c3dcd5d3cadd211f996dda5243469ac9a46e6", "filename": "src/librustc/middle/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/263a433f1901592f91e6433ccc79539e619cd95f/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/263a433f1901592f91e6433ccc79539e619cd95f/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=263a433f1901592f91e6433ccc79539e619cd95f", "patch": "@@ -395,7 +395,8 @@ impl<'a> GatherLoanCtxt<'a> {\n         //! from a local variable, mark the mutability decl as necessary.\n \n         match *loan_path {\n-            LpVar(local_id) => {\n+            LpVar(local_id) |\n+            LpUpvar(ty::UpvarId{ var_id: local_id, closure_expr_id: _ }) => {\n                 self.tcx().used_mut_nodes.borrow_mut().insert(local_id);\n             }\n             LpExtend(ref base, mc::McInherited, _) => {\n@@ -445,8 +446,8 @@ impl<'a> GatherLoanCtxt<'a> {\n         //! with immutable `&` pointers, because borrows of such pointers\n         //! do not require restrictions and hence do not cause a loan.\n \n+        let lexical_scope = lp.kill_scope(self.bccx.tcx);\n         let rm = &self.bccx.tcx.region_maps;\n-        let lexical_scope = rm.var_scope(lp.node_id());\n         if rm.is_subscope_of(lexical_scope, loan_scope) {\n             lexical_scope\n         } else {"}, {"sha": "d131b6f7eda29895a49ec774d8705d7bdd9b538a", "filename": "src/librustc/middle/borrowck/gather_loans/restrictions.rs", "status": "modified", "additions": 13, "deletions": 4, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/263a433f1901592f91e6433ccc79539e619cd95f/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Frestrictions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/263a433f1901592f91e6433ccc79539e619cd95f/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Frestrictions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Frestrictions.rs?ref=263a433f1901592f91e6433ccc79539e619cd95f", "patch": "@@ -67,13 +67,23 @@ impl<'a> RestrictionsContext<'a> {\n             }\n \n             mc::cat_local(local_id) |\n-            mc::cat_arg(local_id) |\n-            mc::cat_upvar(ty::UpvarId {var_id: local_id, ..}, _) => {\n-                // R-Variable\n+            mc::cat_arg(local_id) => {\n+                // R-Variable, locally declared\n                 let lp = Rc::new(LpVar(local_id));\n                 SafeIf(lp.clone(), vec!(lp))\n             }\n \n+            mc::cat_upvar(upvar_id, _) => {\n+                // R-Variable, captured into closure\n+                let lp = Rc::new(LpUpvar(upvar_id));\n+                SafeIf(lp.clone(), vec!(lp))\n+            }\n+\n+            mc::cat_copied_upvar(..) => {\n+                // FIXME(#2152) allow mutation of upvars\n+                Safe\n+            }\n+\n             mc::cat_downcast(cmt_base) => {\n                 // When we borrow the interior of an enum, we have to\n                 // ensure the enum itself is not mutated, because that\n@@ -107,7 +117,6 @@ impl<'a> RestrictionsContext<'a> {\n                 self.extend(result, cmt.mutbl, LpDeref(pk))\n             }\n \n-            mc::cat_copied_upvar(..) | // FIXME(#2152) allow mutation of upvars\n             mc::cat_static_item(..) => {\n                 Safe\n             }"}, {"sha": "0c77e637790747f2d37131a6875a1f365a6d691b", "filename": "src/librustc/middle/borrowck/mod.rs", "status": "modified", "additions": 35, "deletions": 7, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/263a433f1901592f91e6433ccc79539e619cd95f/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/263a433f1901592f91e6433ccc79539e619cd95f/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs?ref=263a433f1901592f91e6433ccc79539e619cd95f", "patch": "@@ -201,6 +201,7 @@ pub struct Loan {\n #[deriving(PartialEq, Eq, Hash)]\n pub enum LoanPath {\n     LpVar(ast::NodeId),               // `x` in doc.rs\n+    LpUpvar(ty::UpvarId),             // `x` captured by-value into closure\n     LpExtend(Rc<LoanPath>, mc::MutabilityCategory, LoanPathElem)\n }\n \n@@ -210,11 +211,25 @@ pub enum LoanPathElem {\n     LpInterior(mc::InteriorKind) // `LV.f` in doc.rs\n }\n \n+pub fn closure_to_block(closure_id: ast::NodeId,\n+                    tcx: &ty::ctxt) -> ast::NodeId {\n+    match tcx.map.get(closure_id) {\n+        ast_map::NodeExpr(expr) => match expr.node {\n+            ast::ExprProc(_decl, block) |\n+            ast::ExprFnBlock(_decl, block) => { block.id }\n+            _ => fail!(\"encountered non-closure id: {}\", closure_id)\n+        },\n+        _ => fail!(\"encountered non-expr id: {}\", closure_id)\n+    }\n+}\n+\n impl LoanPath {\n-    pub fn node_id(&self) -> ast::NodeId {\n+    pub fn kill_scope(&self, tcx: &ty::ctxt) -> ast::NodeId {\n         match *self {\n-            LpVar(local_id) => local_id,\n-            LpExtend(ref base, _, _) => base.node_id()\n+            LpVar(local_id) => tcx.region_maps.var_scope(local_id),\n+            LpUpvar(upvar_id) =>\n+                closure_to_block(upvar_id.closure_expr_id, tcx),\n+            LpExtend(ref base, _, _) => base.kill_scope(tcx),\n         }\n     }\n }\n@@ -234,12 +249,18 @@ pub fn opt_loan_path(cmt: &mc::cmt) -> Option<Rc<LoanPath>> {\n         }\n \n         mc::cat_local(id) |\n-        mc::cat_arg(id) |\n-        mc::cat_copied_upvar(mc::CopiedUpvar { upvar_id: id, .. }) |\n-        mc::cat_upvar(ty::UpvarId {var_id: id, ..}, _) => {\n+        mc::cat_arg(id) => {\n             Some(Rc::new(LpVar(id)))\n         }\n \n+        mc::cat_upvar(ty::UpvarId {var_id: id, closure_expr_id: proc_id}, _) |\n+        mc::cat_copied_upvar(mc::CopiedUpvar { upvar_id: id,\n+                                               onceness: _,\n+                                               capturing_proc: proc_id }) => {\n+            let upvar_id = ty::UpvarId{ var_id: id, closure_expr_id: proc_id };\n+            Some(Rc::new(LpUpvar(upvar_id)))\n+        }\n+\n         mc::cat_deref(ref cmt_base, _, pk) => {\n             opt_loan_path(cmt_base).map(|lp| {\n                 Rc::new(LpExtend(lp, cmt.mutbl, LpDeref(pk)))\n@@ -693,6 +714,7 @@ impl<'a> BorrowckCtxt<'a> {\n                                    loan_path: &LoanPath,\n                                    out: &mut String) {\n         match *loan_path {\n+            LpUpvar(ty::UpvarId{ var_id: id, closure_expr_id: _ }) |\n             LpVar(id) => {\n                 out.push_str(ty::local_var_name_str(self.tcx, id).get());\n             }\n@@ -734,7 +756,7 @@ impl<'a> BorrowckCtxt<'a> {\n                 self.append_autoderefd_loan_path_to_str(&**lp_base, out)\n             }\n \n-            LpVar(..) | LpExtend(_, _, LpInterior(..)) => {\n+            LpVar(..) | LpUpvar(..) | LpExtend(_, _, LpInterior(..)) => {\n                 self.append_loan_path_to_str(loan_path, out)\n             }\n         }\n@@ -796,6 +818,12 @@ impl Repr for LoanPath {\n                 (format!(\"$({})\", tcx.map.node_to_str(id))).to_string()\n             }\n \n+            &LpUpvar(ty::UpvarId{ var_id, closure_expr_id }) => {\n+                let s = tcx.map.node_to_str(var_id);\n+                let s = format!(\"$({} captured by id={})\", s, closure_expr_id);\n+                s.to_string()\n+            }\n+\n             &LpExtend(ref lp, _, LpDeref(_)) => {\n                 (format!(\"{}.*\", lp.repr(tcx))).to_string()\n             }"}, {"sha": "bb92043b1ea6a42e7a99dd7725fbd4070a28a922", "filename": "src/librustc/middle/borrowck/move_data.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/263a433f1901592f91e6433ccc79539e619cd95f/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/263a433f1901592f91e6433ccc79539e619cd95f/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs?ref=263a433f1901592f91e6433ccc79539e619cd95f", "patch": "@@ -231,7 +231,7 @@ impl MoveData {\n         }\n \n         let index = match *lp {\n-            LpVar(..) => {\n+            LpVar(..) | LpUpvar(..) => {\n                 let index = MovePathIndex(self.paths.borrow().len());\n \n                 self.paths.borrow_mut().push(MovePath {\n@@ -302,7 +302,7 @@ impl MoveData {\n             }\n             None => {\n                 match **lp {\n-                    LpVar(..) => { }\n+                    LpVar(..) | LpUpvar(..) => { }\n                     LpExtend(ref b, _, _) => {\n                         self.add_existing_base_paths(b, result);\n                     }\n@@ -418,6 +418,11 @@ impl MoveData {\n                     let path = *self.path_map.borrow().get(&path.loan_path);\n                     self.kill_moves(path, kill_id, dfcx_moves);\n                 }\n+                LpUpvar(ty::UpvarId { var_id: _, closure_expr_id }) => {\n+                    let kill_id = closure_to_block(closure_expr_id, tcx);\n+                    let path = *self.path_map.borrow().get(&path.loan_path);\n+                    self.kill_moves(path, kill_id, dfcx_moves);\n+                }\n                 LpExtend(..) => {}\n             }\n         }\n@@ -430,6 +435,10 @@ impl MoveData {\n                     let kill_id = tcx.region_maps.var_scope(id);\n                     dfcx_assign.add_kill(kill_id, assignment_index);\n                 }\n+                LpUpvar(ty::UpvarId { var_id: _, closure_expr_id }) => {\n+                    let kill_id = closure_to_block(closure_expr_id, tcx);\n+                    dfcx_assign.add_kill(kill_id, assignment_index);\n+                }\n                 LpExtend(..) => {\n                     tcx.sess.bug(\"var assignment for non var path\");\n                 }"}, {"sha": "7a26d2104826fe13574ff3123f18ba5190602928", "filename": "src/librustc/middle/dataflow.rs", "status": "modified", "additions": 14, "deletions": 24, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/263a433f1901592f91e6433ccc79539e619cd95f/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/263a433f1901592f91e6433ccc79539e619cd95f/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdataflow.rs?ref=263a433f1901592f91e6433ccc79539e619cd95f", "patch": "@@ -266,34 +266,24 @@ impl<'a, O:DataFlowOperator> DataFlowContext<'a, O> {\n \n     pub fn add_gen(&mut self, id: ast::NodeId, bit: uint) {\n         //! Indicates that `id` generates `bit`\n-        if self.nodeid_to_index.contains_key(&id) {\n-            debug!(\"add_gen(id={:?}, bit={:?})\", id, bit);\n-            let cfgidx = to_cfgidx_or_die(id, &self.nodeid_to_index);\n-            let (start, end) = self.compute_id_range(cfgidx);\n-            {\n-                let gens = self.gens.mut_slice(start, end);\n-                set_bit(gens, bit);\n-            }\n-        } else {\n-            debug!(\"{:s} add_gen skip (id={:?}, bit={:?}); id not in current fn\",\n-                   self.analysis_name, id, bit);\n-        }\n+        debug!(\"{:s} add_gen(id={:?}, bit={:?})\",\n+               self.analysis_name, id, bit);\n+        assert!(self.nodeid_to_index.contains_key(&id));\n+        let cfgidx = to_cfgidx_or_die(id, &self.nodeid_to_index);\n+        let (start, end) = self.compute_id_range(cfgidx);\n+        let gens = self.gens.mut_slice(start, end);\n+        set_bit(gens, bit);\n     }\n \n     pub fn add_kill(&mut self, id: ast::NodeId, bit: uint) {\n         //! Indicates that `id` kills `bit`\n-        if self.nodeid_to_index.contains_key(&id) {\n-            debug!(\"add_kill(id={:?}, bit={:?})\", id, bit);\n-            let cfgidx = to_cfgidx_or_die(id, &self.nodeid_to_index);\n-            let (start, end) = self.compute_id_range(cfgidx);\n-            {\n-                let kills = self.kills.mut_slice(start, end);\n-                set_bit(kills, bit);\n-            }\n-        } else {\n-            debug!(\"{:s} add_kill skip (id={:?}, bit={:?}); id not in current fn\",\n-                   self.analysis_name, id, bit);\n-        }\n+        debug!(\"{:s} add_kill(id={:?}, bit={:?})\",\n+               self.analysis_name, id, bit);\n+        assert!(self.nodeid_to_index.contains_key(&id));\n+        let cfgidx = to_cfgidx_or_die(id, &self.nodeid_to_index);\n+        let (start, end) = self.compute_id_range(cfgidx);\n+        let kills = self.kills.mut_slice(start, end);\n+        set_bit(kills, bit);\n     }\n \n     fn apply_gen_kill(&mut self, cfgidx: CFGIndex, bits: &mut [uint]) {"}, {"sha": "03c9c56c787016ba758f4f8176d0fc70c5acf7e4", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/263a433f1901592f91e6433ccc79539e619cd95f/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/263a433f1901592f91e6433ccc79539e619cd95f/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=263a433f1901592f91e6433ccc79539e619cd95f", "patch": "@@ -97,6 +97,7 @@ pub enum categorization {\n pub struct CopiedUpvar {\n     pub upvar_id: ast::NodeId,\n     pub onceness: ast::Onceness,\n+    pub capturing_proc: ast::NodeId,\n }\n \n // different kinds of pointers:\n@@ -559,7 +560,9 @@ impl<'t,TYPER:Typer> MemCategorizationContext<'t,TYPER> {\n                               span:span,\n                               cat:cat_copied_upvar(CopiedUpvar {\n                                   upvar_id: var_id,\n-                                  onceness: closure_ty.onceness}),\n+                                  onceness: closure_ty.onceness,\n+                                  capturing_proc: fn_node_id,\n+                              }),\n                               mutbl:McImmutable,\n                               ty:expr_ty\n                           }))"}]}