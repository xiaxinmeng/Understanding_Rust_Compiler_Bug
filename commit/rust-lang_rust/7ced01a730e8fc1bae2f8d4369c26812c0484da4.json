{"sha": "7ced01a730e8fc1bae2f8d4369c26812c0484da4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdjZWQwMWE3MzBlOGZjMWJhZTJmOGQ0MzY5YzI2ODEyYzA0ODRkYTQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-04-30T19:01:01Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-04-30T19:01:01Z"}, "message": "Auto merge of #71717 - Dylan-DPC:rollup-av5vjor, r=Dylan-DPC\n\nRollup of 5 pull requests\n\nSuccessful merges:\n\n - #70950 (extend NLL checker to understand `'empty` combined with universes)\n - #71433 (Add help message for missing right operand in condition)\n - #71449 (Move `{Free,}RegionRelations` and `FreeRegionMap` to `rustc_infer`)\n - #71559 (Detect git version before attempting to use --progress)\n - #71597 (Rename Unique::empty() -> Unique::dangling())\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "5f972cddf361a86e359b3a523c5ac68110a151db", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5f972cddf361a86e359b3a523c5ac68110a151db"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7ced01a730e8fc1bae2f8d4369c26812c0484da4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7ced01a730e8fc1bae2f8d4369c26812c0484da4", "html_url": "https://github.com/rust-lang/rust/commit/7ced01a730e8fc1bae2f8d4369c26812c0484da4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7ced01a730e8fc1bae2f8d4369c26812c0484da4/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "be8589fc31162bb71b0f765beba6ce73ec8ba93a", "url": "https://api.github.com/repos/rust-lang/rust/commits/be8589fc31162bb71b0f765beba6ce73ec8ba93a", "html_url": "https://github.com/rust-lang/rust/commit/be8589fc31162bb71b0f765beba6ce73ec8ba93a"}, {"sha": "97a8870022ec819c8b92b4c192242726c77e19f3", "url": "https://api.github.com/repos/rust-lang/rust/commits/97a8870022ec819c8b92b4c192242726c77e19f3", "html_url": "https://github.com/rust-lang/rust/commit/97a8870022ec819c8b92b4c192242726c77e19f3"}], "stats": {"total": 781, "additions": 485, "deletions": 296}, "files": [{"sha": "3decf5846879bb6a67d5cde4d0e20e7a18087f3f", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7ced01a730e8fc1bae2f8d4369c26812c0484da4/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/7ced01a730e8fc1bae2f8d4369c26812c0484da4/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=7ced01a730e8fc1bae2f8d4369c26812c0484da4", "patch": "@@ -3852,6 +3852,7 @@ dependencies = [\n  \"rustc_session\",\n  \"rustc_span\",\n  \"rustc_target\",\n+ \"serialize\",\n  \"smallvec 1.0.0\",\n ]\n "}, {"sha": "2aa3f9c7ec04b3859d5b4a47264a9b36e1ccf874", "filename": "src/bootstrap/bootstrap.py", "status": "modified", "additions": 15, "deletions": 11, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/7ced01a730e8fc1bae2f8d4369c26812c0484da4/src%2Fbootstrap%2Fbootstrap.py", "raw_url": "https://github.com/rust-lang/rust/raw/7ced01a730e8fc1bae2f8d4369c26812c0484da4/src%2Fbootstrap%2Fbootstrap.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbootstrap.py?ref=7ced01a730e8fc1bae2f8d4369c26812c0484da4", "patch": "@@ -2,6 +2,7 @@\n import argparse\n import contextlib\n import datetime\n+import distutils.version\n import hashlib\n import os\n import re\n@@ -331,6 +332,7 @@ def __init__(self):\n         self.use_locked_deps = ''\n         self.use_vendored_sources = ''\n         self.verbose = False\n+        self.git_version = None\n \n     def download_stage0(self):\n         \"\"\"Fetch the build system for Rust, written in Rust\n@@ -743,15 +745,13 @@ def update_submodule(self, module, checked_out, recorded_submodules):\n \n         run([\"git\", \"submodule\", \"-q\", \"sync\", module],\n             cwd=self.rust_root, verbose=self.verbose)\n-        try:\n-            run([\"git\", \"submodule\", \"update\",\n-                 \"--init\", \"--recursive\", \"--progress\", module],\n-                cwd=self.rust_root, verbose=self.verbose, exception=True)\n-        except RuntimeError:\n-            # Some versions of git don't support --progress.\n-            run([\"git\", \"submodule\", \"update\",\n-                 \"--init\", \"--recursive\", module],\n-                cwd=self.rust_root, verbose=self.verbose)\n+\n+        update_args = [\"git\", \"submodule\", \"update\", \"--init\", \"--recursive\"]\n+        if self.git_version >= distutils.version.LooseVersion(\"2.11.0\"):\n+            update_args.append(\"--progress\")\n+        update_args.append(module)\n+        run(update_args, cwd=self.rust_root, verbose=self.verbose, exception=True)\n+\n         run([\"git\", \"reset\", \"-q\", \"--hard\"],\n             cwd=module_path, verbose=self.verbose)\n         run([\"git\", \"clean\", \"-qdfx\"],\n@@ -763,9 +763,13 @@ def update_submodules(self):\n                 self.get_toml('submodules') == \"false\":\n             return\n \n-        # check the existence of 'git' command\n+        default_encoding = sys.getdefaultencoding()\n+\n+        # check the existence and version of 'git' command\n         try:\n-            subprocess.check_output(['git', '--version'])\n+            git_version_output = subprocess.check_output(['git', '--version'])\n+            git_version_str = git_version_output.strip().split()[2].decode(default_encoding)\n+            self.git_version = distutils.version.LooseVersion(git_version_str)\n         except (subprocess.CalledProcessError, OSError):\n             print(\"error: `git` is not found, please make sure it's installed and in the path.\")\n             sys.exit(1)"}, {"sha": "a8e19c9cbaa86152482fe4b49d7446f1604cde3f", "filename": "src/liballoc/raw_vec.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7ced01a730e8fc1bae2f8d4369c26812c0484da4/src%2Fliballoc%2Fraw_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ced01a730e8fc1bae2f8d4369c26812c0484da4/src%2Fliballoc%2Fraw_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fraw_vec.rs?ref=7ced01a730e8fc1bae2f8d4369c26812c0484da4", "patch": "@@ -25,9 +25,9 @@ mod tests;\n /// involved. This type is excellent for building your own data structures like Vec and VecDeque.\n /// In particular:\n ///\n-/// * Produces `Unique::empty()` on zero-sized types.\n-/// * Produces `Unique::empty()` on zero-length allocations.\n-/// * Avoids freeing `Unique::empty()`.\n+/// * Produces `Unique::dangling()` on zero-sized types.\n+/// * Produces `Unique::dangling()` on zero-length allocations.\n+/// * Avoids freeing `Unique::dangling()`.\n /// * Catches all overflows in capacity computations (promotes them to \"capacity overflow\" panics).\n /// * Guards against 32-bit systems allocating more than isize::MAX bytes.\n /// * Guards against overflowing your length.\n@@ -125,7 +125,7 @@ impl<T, A: AllocRef> RawVec<T, A> {\n     /// the returned `RawVec`.\n     pub const fn new_in(alloc: A) -> Self {\n         // `cap: 0` means \"unallocated\". zero-sized types are ignored.\n-        Self { ptr: Unique::empty(), cap: 0, alloc }\n+        Self { ptr: Unique::dangling(), cap: 0, alloc }\n     }\n \n     /// Like `with_capacity`, but parameterized over the choice of\n@@ -172,7 +172,7 @@ impl<T, A: AllocRef> RawVec<T, A> {\n     }\n \n     /// Gets a raw pointer to the start of the allocation. Note that this is\n-    /// `Unique::empty()` if `capacity == 0` or `T` is zero-sized. In the former case, you must\n+    /// `Unique::dangling()` if `capacity == 0` or `T` is zero-sized. In the former case, you must\n     /// be careful.\n     pub fn ptr(&self) -> *mut T {\n         self.ptr.as_ptr()"}, {"sha": "f58d35f06137d4ea870403a42cc7cb41ad21bfd1", "filename": "src/libcore/ptr/unique.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7ced01a730e8fc1bae2f8d4369c26812c0484da4/src%2Flibcore%2Fptr%2Funique.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ced01a730e8fc1bae2f8d4369c26812c0484da4/src%2Flibcore%2Fptr%2Funique.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr%2Funique.rs?ref=7ced01a730e8fc1bae2f8d4369c26812c0484da4", "patch": "@@ -70,9 +70,8 @@ impl<T: Sized> Unique<T> {\n     /// a `T`, which means this must not be used as a \"not yet initialized\"\n     /// sentinel value. Types that lazily allocate must track initialization by\n     /// some other means.\n-    // FIXME: rename to dangling() to match NonNull?\n     #[inline]\n-    pub const fn empty() -> Self {\n+    pub const fn dangling() -> Self {\n         // SAFETY: mem::align_of() returns a valid, non-null pointer. The\n         // conditions to call new_unchecked() are thus respected.\n         unsafe { Unique::new_unchecked(mem::align_of::<T>() as *mut T) }"}, {"sha": "57eaf56f268f86505a86f67ecb7ec0c4cd73d132", "filename": "src/librustc_data_structures/graph/scc/mod.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7ced01a730e8fc1bae2f8d4369c26812c0484da4/src%2Flibrustc_data_structures%2Fgraph%2Fscc%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ced01a730e8fc1bae2f8d4369c26812c0484da4/src%2Flibrustc_data_structures%2Fgraph%2Fscc%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fgraph%2Fscc%2Fmod.rs?ref=7ced01a730e8fc1bae2f8d4369c26812c0484da4", "patch": "@@ -47,6 +47,11 @@ impl<N: Idx, S: Idx> Sccs<N, S> {\n     }\n \n     /// Returns an iterator over the SCCs in the graph.\n+    ///\n+    /// The SCCs will be iterated in **dependency order** (or **post order**),\n+    /// meaning that if `S1 -> S2`, we will visit `S2` first and `S1` after.\n+    /// This is convenient when the edges represent dependencies: when you visit\n+    /// `S1`, the value for `S2` will already have been computed.\n     pub fn all_sccs(&self) -> impl Iterator<Item = S> {\n         (0..self.scc_data.len()).map(S::new)\n     }"}, {"sha": "fa8e5a2ab78b47a439e04b346284c9f535dcaeba", "filename": "src/librustc_infer/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7ced01a730e8fc1bae2f8d4369c26812c0484da4/src%2Flibrustc_infer%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/7ced01a730e8fc1bae2f8d4369c26812c0484da4/src%2Flibrustc_infer%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2FCargo.toml?ref=7ced01a730e8fc1bae2f8d4369c26812c0484da4", "patch": "@@ -19,6 +19,7 @@ rustc_hir = { path = \"../librustc_hir\" }\n rustc_index = { path = \"../librustc_index\" }\n rustc_macros = { path = \"../librustc_macros\" }\n rustc_session = { path = \"../librustc_session\" }\n+rustc_serialize = { path = \"../libserialize\", package = \"serialize\" }\n rustc_span = { path = \"../librustc_span\" }\n rustc_target = { path = \"../librustc_target\" }\n smallvec = { version = \"1.0\", features = [\"union\", \"may_dangle\"] }"}, {"sha": "e31c524c19710886a5925441713e928cffb60b46", "filename": "src/librustc_infer/infer/free_regions.rs", "status": "renamed", "additions": 43, "deletions": 1, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/7ced01a730e8fc1bae2f8d4369c26812c0484da4/src%2Flibrustc_infer%2Finfer%2Ffree_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ced01a730e8fc1bae2f8d4369c26812c0484da4/src%2Flibrustc_infer%2Finfer%2Ffree_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Ffree_regions.rs?ref=7ced01a730e8fc1bae2f8d4369c26812c0484da4", "patch": "@@ -1,5 +1,47 @@\n-use crate::ty::{self, Lift, Region, TyCtxt};\n+//! This module handles the relationships between \"free regions\", i.e., lifetime parameters.\n+//! Ordinarily, free regions are unrelated to one another, but they can be related via implied\n+//! or explicit bounds. In that case, we track the bounds using the `TransitiveRelation` type,\n+//! and use that to decide when one free region outlives another, and so forth.\n+\n use rustc_data_structures::transitive_relation::TransitiveRelation;\n+use rustc_hir::def_id::DefId;\n+use rustc_middle::middle::region;\n+use rustc_middle::ty::{self, Lift, Region, TyCtxt};\n+\n+/// Combines a `region::ScopeTree` (which governs relationships between\n+/// scopes) and a `FreeRegionMap` (which governs relationships between\n+/// free regions) to yield a complete relation between concrete\n+/// regions.\n+///\n+/// This stuff is a bit convoluted and should be refactored, but as we\n+/// transition to NLL, it'll all go away anyhow.\n+pub struct RegionRelations<'a, 'tcx> {\n+    pub tcx: TyCtxt<'tcx>,\n+\n+    /// The context used to fetch the region maps.\n+    pub context: DefId,\n+\n+    /// The region maps for the given context.\n+    pub region_scope_tree: &'a region::ScopeTree,\n+\n+    /// Free-region relationships.\n+    pub free_regions: &'a FreeRegionMap<'tcx>,\n+}\n+\n+impl<'a, 'tcx> RegionRelations<'a, 'tcx> {\n+    pub fn new(\n+        tcx: TyCtxt<'tcx>,\n+        context: DefId,\n+        region_scope_tree: &'a region::ScopeTree,\n+        free_regions: &'a FreeRegionMap<'tcx>,\n+    ) -> Self {\n+        Self { tcx, context, region_scope_tree, free_regions }\n+    }\n+\n+    pub fn lub_free_regions(&self, r_a: Region<'tcx>, r_b: Region<'tcx>) -> Region<'tcx> {\n+        self.free_regions.lub_free_regions(self.tcx, r_a, r_b)\n+    }\n+}\n \n #[derive(Clone, RustcEncodable, RustcDecodable, Debug, Default, HashStable)]\n pub struct FreeRegionMap<'tcx> {", "previous_filename": "src/librustc_middle/ty/free_region_map.rs"}, {"sha": "5d3e8f440d6fd6fd44785b99c6907f6a20f45fd4", "filename": "src/librustc_infer/infer/lexical_region_resolve/graphviz.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7ced01a730e8fc1bae2f8d4369c26812c0484da4/src%2Flibrustc_infer%2Finfer%2Flexical_region_resolve%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ced01a730e8fc1bae2f8d4369c26812c0484da4/src%2Flibrustc_infer%2Finfer%2Flexical_region_resolve%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Flexical_region_resolve%2Fgraphviz.rs?ref=7ced01a730e8fc1bae2f8d4369c26812c0484da4", "patch": "@@ -10,10 +10,10 @@ use graphviz as dot;\n \n use super::Constraint;\n use crate::infer::region_constraints::RegionConstraintData;\n+use crate::infer::RegionRelations;\n use crate::infer::SubregionOrigin;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_hir::def_id::DefIndex;\n-use rustc_middle::middle::free_region::RegionRelations;\n use rustc_middle::middle::region;\n use rustc_middle::ty;\n "}, {"sha": "3ff0e26a4dc38bc31335824a3ebe511445bec926", "filename": "src/librustc_infer/infer/lexical_region_resolve/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7ced01a730e8fc1bae2f8d4369c26812c0484da4/src%2Flibrustc_infer%2Finfer%2Flexical_region_resolve%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ced01a730e8fc1bae2f8d4369c26812c0484da4/src%2Flibrustc_infer%2Finfer%2Flexical_region_resolve%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Flexical_region_resolve%2Fmod.rs?ref=7ced01a730e8fc1bae2f8d4369c26812c0484da4", "patch": "@@ -6,6 +6,7 @@ use crate::infer::region_constraints::MemberConstraint;\n use crate::infer::region_constraints::RegionConstraintData;\n use crate::infer::region_constraints::VarInfos;\n use crate::infer::region_constraints::VerifyBound;\n+use crate::infer::RegionRelations;\n use crate::infer::RegionVariableOrigin;\n use crate::infer::RegionckMode;\n use crate::infer::SubregionOrigin;\n@@ -14,7 +15,6 @@ use rustc_data_structures::graph::implementation::{\n     Direction, Graph, NodeIndex, INCOMING, OUTGOING,\n };\n use rustc_index::vec::{Idx, IndexVec};\n-use rustc_middle::middle::free_region::RegionRelations;\n use rustc_middle::ty::fold::TypeFoldable;\n use rustc_middle::ty::{self, Ty, TyCtxt};\n use rustc_middle::ty::{ReEarlyBound, ReEmpty, ReErased, ReFree, ReStatic};"}, {"sha": "267f1e7e2dc892406049804c7afa95aeee736802", "filename": "src/librustc_infer/infer/mod.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7ced01a730e8fc1bae2f8d4369c26812c0484da4/src%2Flibrustc_infer%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ced01a730e8fc1bae2f8d4369c26812c0484da4/src%2Flibrustc_infer%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fmod.rs?ref=7ced01a730e8fc1bae2f8d4369c26812c0484da4", "patch": "@@ -18,7 +18,6 @@ use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_middle::infer::canonical::{Canonical, CanonicalVarValues};\n use rustc_middle::infer::unify_key::{ConstVarValue, ConstVariableValue};\n use rustc_middle::infer::unify_key::{ConstVariableOrigin, ConstVariableOriginKind, ToType};\n-use rustc_middle::middle::free_region::RegionRelations;\n use rustc_middle::middle::region;\n use rustc_middle::mir;\n use rustc_middle::mir::interpret::ConstEvalResult;\n@@ -39,6 +38,7 @@ use std::collections::BTreeMap;\n use std::fmt;\n \n use self::combine::CombineFields;\n+use self::free_regions::RegionRelations;\n use self::lexical_region_resolve::LexicalRegionResolutions;\n use self::outlives::env::OutlivesEnvironment;\n use self::region_constraints::{GenericKind, RegionConstraintData, VarInfos, VerifyBound};\n@@ -50,6 +50,7 @@ pub mod canonical;\n mod combine;\n mod equate;\n pub mod error_reporting;\n+pub mod free_regions;\n mod freshen;\n mod fudge;\n mod glb;\n@@ -472,6 +473,9 @@ pub enum NLLRegionVariableOrigin {\n     /// from a `for<'a> T` binder). Meant to represent \"any region\".\n     Placeholder(ty::PlaceholderRegion),\n \n+    /// The variable we create to represent `'empty(U0)`.\n+    RootEmptyRegion,\n+\n     Existential {\n         /// If this is true, then this variable was created to represent a lifetime\n         /// bound in a `for` binder. For example, it might have been created to\n@@ -493,6 +497,7 @@ impl NLLRegionVariableOrigin {\n             NLLRegionVariableOrigin::FreeRegion => true,\n             NLLRegionVariableOrigin::Placeholder(..) => true,\n             NLLRegionVariableOrigin::Existential { .. } => false,\n+            NLLRegionVariableOrigin::RootEmptyRegion => false,\n         }\n     }\n "}, {"sha": "1a9e20e79fe1ed0ed9a455138d7d77a145c257c9", "filename": "src/librustc_infer/infer/outlives/env.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7ced01a730e8fc1bae2f8d4369c26812c0484da4/src%2Flibrustc_infer%2Finfer%2Foutlives%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ced01a730e8fc1bae2f8d4369c26812c0484da4/src%2Flibrustc_infer%2Finfer%2Foutlives%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Foutlives%2Fenv.rs?ref=7ced01a730e8fc1bae2f8d4369c26812c0484da4", "patch": "@@ -1,9 +1,9 @@\n+use crate::infer::free_regions::FreeRegionMap;\n use crate::infer::{GenericKind, InferCtxt};\n use crate::traits::query::OutlivesBound;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_hir as hir;\n use rustc_middle::ty;\n-use rustc_middle::ty::free_region_map::FreeRegionMap;\n \n use super::explicit_outlives_bounds;\n "}, {"sha": "62ccd94674488277ac66f6b3a405a8394e3fb50d", "filename": "src/librustc_middle/middle/free_region.rs", "status": "removed", "additions": 0, "deletions": 44, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/be8589fc31162bb71b0f765beba6ce73ec8ba93a/src%2Flibrustc_middle%2Fmiddle%2Ffree_region.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be8589fc31162bb71b0f765beba6ce73ec8ba93a/src%2Flibrustc_middle%2Fmiddle%2Ffree_region.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmiddle%2Ffree_region.rs?ref=be8589fc31162bb71b0f765beba6ce73ec8ba93a", "patch": "@@ -1,44 +0,0 @@\n-//! This module handles the relationships between \"free regions\", i.e., lifetime parameters.\n-//! Ordinarily, free regions are unrelated to one another, but they can be related via implied\n-//! or explicit bounds. In that case, we track the bounds using the `TransitiveRelation` type,\n-//! and use that to decide when one free region outlives another, and so forth.\n-\n-use crate::middle::region;\n-use crate::ty::free_region_map::FreeRegionMap;\n-use crate::ty::{Region, TyCtxt};\n-use rustc_hir::def_id::DefId;\n-\n-/// Combines a `region::ScopeTree` (which governs relationships between\n-/// scopes) and a `FreeRegionMap` (which governs relationships between\n-/// free regions) to yield a complete relation between concrete\n-/// regions.\n-///\n-/// This stuff is a bit convoluted and should be refactored, but as we\n-/// transition to NLL, it'll all go away anyhow.\n-pub struct RegionRelations<'a, 'tcx> {\n-    pub tcx: TyCtxt<'tcx>,\n-\n-    /// The context used to fetch the region maps.\n-    pub context: DefId,\n-\n-    /// The region maps for the given context.\n-    pub region_scope_tree: &'a region::ScopeTree,\n-\n-    /// Free-region relationships.\n-    pub free_regions: &'a FreeRegionMap<'tcx>,\n-}\n-\n-impl<'a, 'tcx> RegionRelations<'a, 'tcx> {\n-    pub fn new(\n-        tcx: TyCtxt<'tcx>,\n-        context: DefId,\n-        region_scope_tree: &'a region::ScopeTree,\n-        free_regions: &'a FreeRegionMap<'tcx>,\n-    ) -> Self {\n-        Self { tcx, context, region_scope_tree, free_regions }\n-    }\n-\n-    pub fn lub_free_regions(&self, r_a: Region<'tcx>, r_b: Region<'tcx>) -> Region<'tcx> {\n-        self.free_regions.lub_free_regions(self.tcx, r_a, r_b)\n-    }\n-}"}, {"sha": "9bc9ca6707afe4d729e34964b1cbe351db9f8f3e", "filename": "src/librustc_middle/middle/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7ced01a730e8fc1bae2f8d4369c26812c0484da4/src%2Flibrustc_middle%2Fmiddle%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ced01a730e8fc1bae2f8d4369c26812c0484da4/src%2Flibrustc_middle%2Fmiddle%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmiddle%2Fmod.rs?ref=7ced01a730e8fc1bae2f8d4369c26812c0484da4", "patch": "@@ -2,7 +2,6 @@ pub mod codegen_fn_attrs;\n pub mod cstore;\n pub mod dependency_format;\n pub mod exported_symbols;\n-pub mod free_region;\n pub mod lang_items;\n pub mod lib_features {\n     use rustc_data_structures::fx::{FxHashMap, FxHashSet};"}, {"sha": "af278f9000ec06007a75c22fe5884177c484aad4", "filename": "src/librustc_middle/ty/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7ced01a730e8fc1bae2f8d4369c26812c0484da4/src%2Flibrustc_middle%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ced01a730e8fc1bae2f8d4369c26812c0484da4/src%2Flibrustc_middle%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fmod.rs?ref=7ced01a730e8fc1bae2f8d4369c26812c0484da4", "patch": "@@ -96,7 +96,6 @@ pub mod error;\n pub mod fast_reject;\n pub mod flags;\n pub mod fold;\n-pub mod free_region_map;\n pub mod inhabitedness;\n pub mod layout;\n pub mod normalize_erasing_regions;"}, {"sha": "fe1138438008685bcd6b83e3642a2be8e32ebef9", "filename": "src/librustc_mir/borrow_check/region_infer/mod.rs", "status": "modified", "additions": 100, "deletions": 43, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/7ced01a730e8fc1bae2f8d4369c26812c0484da4/src%2Flibrustc_mir%2Fborrow_check%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ced01a730e8fc1bae2f8d4369c26812c0484da4/src%2Flibrustc_mir%2Fborrow_check%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fregion_infer%2Fmod.rs?ref=7ced01a730e8fc1bae2f8d4369c26812c0484da4", "patch": "@@ -6,7 +6,6 @@ use rustc_data_structures::frozen::Frozen;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::graph::scc::Sccs;\n use rustc_hir::def_id::DefId;\n-use rustc_index::bit_set::BitSet;\n use rustc_index::vec::IndexVec;\n use rustc_infer::infer::canonical::QueryOutlivesConstraint;\n use rustc_infer::infer::region_constraints::{GenericKind, VarInfos, VerifyBound};\n@@ -315,16 +314,81 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// SCC could have as well. This implies that the SCC must have\n     /// the minimum, or narrowest, universe.\n     fn compute_scc_universes(\n-        constraints_scc: &Sccs<RegionVid, ConstraintSccIndex>,\n+        constraint_sccs: &Sccs<RegionVid, ConstraintSccIndex>,\n         definitions: &IndexVec<RegionVid, RegionDefinition<'tcx>>,\n     ) -> IndexVec<ConstraintSccIndex, ty::UniverseIndex> {\n-        let num_sccs = constraints_scc.num_sccs();\n+        let num_sccs = constraint_sccs.num_sccs();\n         let mut scc_universes = IndexVec::from_elem_n(ty::UniverseIndex::MAX, num_sccs);\n \n+        debug!(\"compute_scc_universes()\");\n+\n+        // For each region R in universe U, ensure that the universe for the SCC\n+        // that contains R is \"no bigger\" than U. This effectively sets the universe\n+        // for each SCC to be the minimum of the regions within.\n         for (region_vid, region_definition) in definitions.iter_enumerated() {\n-            let scc = constraints_scc.scc(region_vid);\n+            let scc = constraint_sccs.scc(region_vid);\n             let scc_universe = &mut scc_universes[scc];\n-            *scc_universe = ::std::cmp::min(*scc_universe, region_definition.universe);\n+            let scc_min = std::cmp::min(region_definition.universe, *scc_universe);\n+            if scc_min != *scc_universe {\n+                *scc_universe = scc_min;\n+                debug!(\n+                    \"compute_scc_universes: lowered universe of {scc:?} to {scc_min:?} \\\n+                    because it contains {region_vid:?} in {region_universe:?}\",\n+                    scc = scc,\n+                    scc_min = scc_min,\n+                    region_vid = region_vid,\n+                    region_universe = region_definition.universe,\n+                );\n+            }\n+        }\n+\n+        // Walk each SCC `A` and `B` such that `A: B`\n+        // and ensure that universe(A) can see universe(B).\n+        //\n+        // This serves to enforce the 'empty/placeholder' hierarchy\n+        // (described in more detail on `RegionKind`):\n+        //\n+        // ```\n+        // static -----+\n+        //   |         |\n+        // empty(U0) placeholder(U1)\n+        //   |      /\n+        // empty(U1)\n+        // ```\n+        //\n+        // In particular, imagine we have variables R0 in U0 and R1\n+        // created in U1, and constraints like this;\n+        //\n+        // ```\n+        // R1: !1 // R1 outlives the placeholder in U1\n+        // R1: R0 // R1 outlives R0\n+        // ```\n+        //\n+        // Here, we wish for R1 to be `'static`, because it\n+        // cannot outlive `placeholder(U1)` and `empty(U0)` any other way.\n+        //\n+        // Thanks to this loop, what happens is that the `R1: R0`\n+        // constraint lowers the universe of `R1` to `U0`, which in turn\n+        // means that the `R1: !1` constraint will (later) cause\n+        // `R1` to become `'static`.\n+        for scc_a in constraint_sccs.all_sccs() {\n+            for &scc_b in constraint_sccs.successors(scc_a) {\n+                let scc_universe_a = scc_universes[scc_a];\n+                let scc_universe_b = scc_universes[scc_b];\n+                let scc_universe_min = std::cmp::min(scc_universe_a, scc_universe_b);\n+                if scc_universe_a != scc_universe_min {\n+                    scc_universes[scc_a] = scc_universe_min;\n+\n+                    debug!(\n+                        \"compute_scc_universes: lowered universe of {scc_a:?} to {scc_universe_min:?} \\\n+                        because {scc_a:?}: {scc_b:?} and {scc_b:?} is in universe {scc_universe_b:?}\",\n+                        scc_a = scc_a,\n+                        scc_b = scc_b,\n+                        scc_universe_min = scc_universe_min,\n+                        scc_universe_b = scc_universe_b\n+                    );\n+                }\n+            }\n         }\n \n         debug!(\"compute_scc_universes: scc_universe = {:#?}\", scc_universes);\n@@ -416,7 +480,8 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                     }\n                 }\n \n-                NLLRegionVariableOrigin::Existential { .. } => {\n+                NLLRegionVariableOrigin::RootEmptyRegion\n+                | NLLRegionVariableOrigin::Existential { .. } => {\n                     // For existential, regions, nothing to do.\n                 }\n             }\n@@ -550,47 +615,27 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         // SCC. For each SCC, we visit its successors and compute\n         // their values, then we union all those values to get our\n         // own.\n-        let visited = &mut BitSet::new_empty(self.constraint_sccs.num_sccs());\n-        for scc_index in self.constraint_sccs.all_sccs() {\n-            self.propagate_constraint_sccs_if_new(scc_index, visited);\n+        let constraint_sccs = self.constraint_sccs.clone();\n+        for scc in constraint_sccs.all_sccs() {\n+            self.compute_value_for_scc(scc);\n         }\n \n         // Sort the applied member constraints so we can binary search\n         // through them later.\n         self.member_constraints_applied.sort_by_key(|applied| applied.member_region_scc);\n     }\n \n-    /// Computes the value of the SCC `scc_a` if it has not already\n-    /// been computed. The `visited` parameter is a bitset\n-    #[inline]\n-    fn propagate_constraint_sccs_if_new(\n-        &mut self,\n-        scc_a: ConstraintSccIndex,\n-        visited: &mut BitSet<ConstraintSccIndex>,\n-    ) {\n-        if visited.insert(scc_a) {\n-            self.propagate_constraint_sccs_new(scc_a, visited);\n-        }\n-    }\n-\n     /// Computes the value of the SCC `scc_a`, which has not yet been\n-    /// computed. This works by first computing all successors of the\n-    /// SCC (if they haven't been computed already) and then unioning\n-    /// together their elements.\n-    fn propagate_constraint_sccs_new(\n-        &mut self,\n-        scc_a: ConstraintSccIndex,\n-        visited: &mut BitSet<ConstraintSccIndex>,\n-    ) {\n+    /// computed, by unioning the values of its successors.\n+    /// Assumes that all successors have been computed already\n+    /// (which is assured by iterating over SCCs in dependency order).\n+    fn compute_value_for_scc(&mut self, scc_a: ConstraintSccIndex) {\n         let constraint_sccs = self.constraint_sccs.clone();\n \n         // Walk each SCC `B` such that `A: B`...\n         for &scc_b in constraint_sccs.successors(scc_a) {\n             debug!(\"propagate_constraint_sccs: scc_a = {:?} scc_b = {:?}\", scc_a, scc_b);\n \n-            // ...compute the value of `B`...\n-            self.propagate_constraint_sccs_if_new(scc_b, visited);\n-\n             // ...and add elements from `B` into `A`. One complication\n             // arises because of universes: If `B` contains something\n             // that `A` cannot name, then `A` can only contain `B` if\n@@ -1258,7 +1303,8 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                     self.check_bound_universal_region(fr, placeholder, errors_buffer);\n                 }\n \n-                NLLRegionVariableOrigin::Existential { .. } => {\n+                NLLRegionVariableOrigin::RootEmptyRegion\n+                | NLLRegionVariableOrigin::Existential { .. } => {\n                     // nothing to check here\n                 }\n             }\n@@ -1360,7 +1406,8 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                     self.check_bound_universal_region(fr, placeholder, errors_buffer);\n                 }\n \n-                NLLRegionVariableOrigin::Existential { .. } => {\n+                NLLRegionVariableOrigin::RootEmptyRegion\n+                | NLLRegionVariableOrigin::Existential { .. } => {\n                     // nothing to check here\n                 }\n             }\n@@ -1633,9 +1680,9 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                 universe1.cannot_name(placeholder.universe)\n             }\n \n-            NLLRegionVariableOrigin::FreeRegion | NLLRegionVariableOrigin::Existential { .. } => {\n-                false\n-            }\n+            NLLRegionVariableOrigin::RootEmptyRegion\n+            | NLLRegionVariableOrigin::FreeRegion\n+            | NLLRegionVariableOrigin::Existential { .. } => false,\n         }\n     }\n \n@@ -1773,6 +1820,12 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// Finds some region R such that `fr1: R` and `R` is live at `elem`.\n     crate fn find_sub_region_live_at(&self, fr1: RegionVid, elem: Location) -> RegionVid {\n         debug!(\"find_sub_region_live_at(fr1={:?}, elem={:?})\", fr1, elem);\n+        debug!(\"find_sub_region_live_at: {:?} is in scc {:?}\", fr1, self.constraint_sccs.scc(fr1));\n+        debug!(\n+            \"find_sub_region_live_at: {:?} is in universe {:?}\",\n+            fr1,\n+            self.scc_universes[self.constraint_sccs.scc(fr1)]\n+        );\n         self.find_constraint_paths_between_regions(fr1, |r| {\n             // First look for some `r` such that `fr1: r` and `r` is live at `elem`\n             debug!(\n@@ -1794,13 +1847,16 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         .or_else(|| {\n             // If we fail to find THAT, it may be that `fr1` is a\n             // placeholder that cannot \"fit\" into its SCC. In that\n-            // case, there should be some `r` where `fr1: r`, both\n-            // `fr1` and `r` are in the same SCC, and `fr1` is a\n+            // case, there should be some `r` where `fr1: r` and `fr1` is a\n             // placeholder that `r` cannot name. We can blame that\n             // edge.\n+            //\n+            // Remember that if `R1: R2`, then the universe of R1\n+            // must be able to name the universe of R2, because R2 will\n+            // be at least `'empty(Universe(R2))`, and `R1` must be at\n+            // larger than that.\n             self.find_constraint_paths_between_regions(fr1, |r| {\n-                self.constraint_sccs.scc(fr1) == self.constraint_sccs.scc(r)\n-                    && self.cannot_name_placeholder(r, fr1)\n+                self.cannot_name_placeholder(r, fr1)\n             })\n         })\n         .map(|(_path, r)| r)\n@@ -1944,7 +2000,8 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         let blame_source = match from_region_origin {\n             NLLRegionVariableOrigin::FreeRegion\n             | NLLRegionVariableOrigin::Existential { from_forall: false } => true,\n-            NLLRegionVariableOrigin::Placeholder(_)\n+            NLLRegionVariableOrigin::RootEmptyRegion\n+            | NLLRegionVariableOrigin::Placeholder(_)\n             | NLLRegionVariableOrigin::Existential { from_forall: true } => false,\n         };\n "}, {"sha": "711271a63fbff2c3cd853b37dc6a555207ebc0b7", "filename": "src/librustc_mir/borrow_check/type_check/constraint_conversion.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7ced01a730e8fc1bae2f8d4369c26812c0484da4/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fconstraint_conversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ced01a730e8fc1bae2f8d4369c26812c0484da4/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fconstraint_conversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fconstraint_conversion.rs?ref=7ced01a730e8fc1bae2f8d4369c26812c0484da4", "patch": "@@ -160,10 +160,6 @@ impl<'a, 'b, 'tcx> TypeOutlivesDelegate<'tcx> for &'a mut ConstraintConversion<'\n         a: ty::Region<'tcx>,\n         b: ty::Region<'tcx>,\n     ) {\n-        // FIXME -- this is not the fix I would prefer\n-        if let ty::ReEmpty(ty::UniverseIndex::ROOT) = a {\n-            return;\n-        }\n         let b = self.to_region_vid(b);\n         let a = self.to_region_vid(a);\n         self.add_outlives(b, a);\n@@ -176,10 +172,6 @@ impl<'a, 'b, 'tcx> TypeOutlivesDelegate<'tcx> for &'a mut ConstraintConversion<'\n         a: ty::Region<'tcx>,\n         bound: VerifyBound<'tcx>,\n     ) {\n-        // FIXME: I'd prefer if NLL had a notion of empty\n-        if let ty::ReEmpty(ty::UniverseIndex::ROOT) = a {\n-            return;\n-        }\n         let type_test = self.verify_to_type_test(kind, a, bound);\n         self.add_type_test(type_test);\n     }"}, {"sha": "f97dff146450c5b68af75bb2381c02f0c5312178", "filename": "src/librustc_mir/borrow_check/type_check/free_region_relations.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7ced01a730e8fc1bae2f8d4369c26812c0484da4/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Ffree_region_relations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ced01a730e8fc1bae2f8d4369c26812c0484da4/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Ffree_region_relations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Ffree_region_relations.rs?ref=7ced01a730e8fc1bae2f8d4369c26812c0484da4", "patch": "@@ -1,12 +1,12 @@\n use rustc_data_structures::frozen::Frozen;\n use rustc_data_structures::transitive_relation::TransitiveRelation;\n use rustc_infer::infer::canonical::QueryRegionConstraints;\n+use rustc_infer::infer::free_regions::FreeRegionRelations;\n use rustc_infer::infer::outlives;\n use rustc_infer::infer::region_constraints::GenericKind;\n use rustc_infer::infer::InferCtxt;\n use rustc_middle::mir::ConstraintCategory;\n use rustc_middle::traits::query::OutlivesBound;\n-use rustc_middle::ty::free_region_map::FreeRegionRelations;\n use rustc_middle::ty::{self, RegionVid, Ty, TyCtxt};\n use rustc_span::DUMMY_SP;\n use rustc_trait_selection::traits::query::type_op::{self, TypeOp};"}, {"sha": "3003f4639d9fa3806d48b2d32f319f9ee6350e07", "filename": "src/librustc_mir/borrow_check/universal_regions.rs", "status": "modified", "additions": 18, "deletions": 1, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/7ced01a730e8fc1bae2f8d4369c26812c0484da4/src%2Flibrustc_mir%2Fborrow_check%2Funiversal_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ced01a730e8fc1bae2f8d4369c26812c0484da4/src%2Flibrustc_mir%2Fborrow_check%2Funiversal_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Funiversal_regions.rs?ref=7ced01a730e8fc1bae2f8d4369c26812c0484da4", "patch": "@@ -54,6 +54,13 @@ pub struct UniversalRegions<'tcx> {\n     /// The total number of universal region variables instantiated.\n     num_universals: usize,\n \n+    /// A special region variable created for the `'empty(U0)` region.\n+    /// Note that this is **not** a \"universal\" region, as it doesn't\n+    /// represent a universally bound placeholder or any such thing.\n+    /// But we do create it here in this type because it's a useful region\n+    /// to have around in a few limited cases.\n+    pub root_empty: RegionVid,\n+\n     /// The \"defining\" type for this function, with all universal\n     /// regions instantiated. For a closure or generator, this is the\n     /// closure type, but for a top-level function it's the `FnDef`.\n@@ -317,7 +324,11 @@ impl<'tcx> UniversalRegions<'tcx> {\n \n     /// See `UniversalRegionIndices::to_region_vid`.\n     pub fn to_region_vid(&self, r: ty::Region<'tcx>) -> RegionVid {\n-        self.indices.to_region_vid(r)\n+        if let ty::ReEmpty(ty::UniverseIndex::ROOT) = r {\n+            self.root_empty\n+        } else {\n+            self.indices.to_region_vid(r)\n+        }\n     }\n \n     /// As part of the NLL unit tests, you can annotate a function with\n@@ -473,10 +484,16 @@ impl<'cx, 'tcx> UniversalRegionsBuilder<'cx, 'tcx> {\n             _ => None,\n         };\n \n+        let root_empty = self\n+            .infcx\n+            .next_nll_region_var(NLLRegionVariableOrigin::RootEmptyRegion)\n+            .to_region_vid();\n+\n         UniversalRegions {\n             indices,\n             fr_static,\n             fr_fn_body,\n+            root_empty,\n             first_extern_index,\n             first_local_index,\n             num_universals,"}, {"sha": "55c9f26999be0ef3015797f42a839acab54728a2", "filename": "src/librustc_parse/parser/expr.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7ced01a730e8fc1bae2f8d4369c26812c0484da4/src%2Flibrustc_parse%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ced01a730e8fc1bae2f8d4369c26812c0484da4/src%2Flibrustc_parse%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fexpr.rs?ref=7ced01a730e8fc1bae2f8d4369c26812c0484da4", "patch": "@@ -1549,6 +1549,11 @@ impl<'a> Parser<'a> {\n             let block = self.parse_block().map_err(|mut err| {\n                 if not_block {\n                     err.span_label(lo, \"this `if` expression has a condition, but no block\");\n+                    if let ExprKind::Binary(_, _, ref right) = cond.kind {\n+                        if let ExprKind::Block(_, _) = right.kind {\n+                            err.help(\"maybe you forgot the right operand of the condition?\");\n+                        }\n+                    }\n                 }\n                 err\n             })?;"}, {"sha": "4f8075b0171d33f32f163ce08a92def4c2126b61", "filename": "src/librustc_trait_selection/opaque_types.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7ced01a730e8fc1bae2f8d4369c26812c0484da4/src%2Flibrustc_trait_selection%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ced01a730e8fc1bae2f8d4369c26812c0484da4/src%2Flibrustc_trait_selection%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Fopaque_types.rs?ref=7ced01a730e8fc1bae2f8d4369c26812c0484da4", "patch": "@@ -6,10 +6,10 @@ use rustc_hir as hir;\n use rustc_hir::def_id::{DefId, DefIdMap, LocalDefId};\n use rustc_hir::Node;\n use rustc_infer::infer::error_reporting::unexpected_hidden_region_diagnostic;\n+use rustc_infer::infer::free_regions::FreeRegionRelations;\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use rustc_infer::infer::{self, InferCtxt, InferOk};\n use rustc_middle::ty::fold::{BottomUpFolder, TypeFoldable, TypeFolder, TypeVisitor};\n-use rustc_middle::ty::free_region_map::FreeRegionRelations;\n use rustc_middle::ty::subst::{GenericArg, GenericArgKind, InternalSubsts, SubstsRef};\n use rustc_middle::ty::{self, GenericParamDefKind, Ty, TyCtxt};\n use rustc_session::config::nightly_options;"}, {"sha": "dcfb069b84aad17a803994a6757006d7f59209c0", "filename": "src/test/mir-opt/nll/named-lifetimes-basic/rustc.use_x.nll.0.mir", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/7ced01a730e8fc1bae2f8d4369c26812c0484da4/src%2Ftest%2Fmir-opt%2Fnll%2Fnamed-lifetimes-basic%2Frustc.use_x.nll.0.mir", "raw_url": "https://github.com/rust-lang/rust/raw/7ced01a730e8fc1bae2f8d4369c26812c0484da4/src%2Ftest%2Fmir-opt%2Fnll%2Fnamed-lifetimes-basic%2Frustc.use_x.nll.0.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fnll%2Fnamed-lifetimes-basic%2Frustc.use_x.nll.0.mir?ref=7ced01a730e8fc1bae2f8d4369c26812c0484da4", "patch": "@@ -13,27 +13,28 @@\n | '_#2r | U0 | {bb0[0..=1], '_#2r}\n | '_#3r | U0 | {bb0[0..=1], '_#3r}\n | '_#4r | U0 | {bb0[0..=1], '_#4r}\n-| '_#5r | U0 | {bb0[0..=1], '_#1r}\n-| '_#6r | U0 | {bb0[0..=1], '_#2r}\n-| '_#7r | U0 | {bb0[0..=1], '_#1r}\n-| '_#8r | U0 | {bb0[0..=1], '_#3r}\n+| '_#5r | U0 | {}\n+| '_#6r | U0 | {bb0[0..=1], '_#1r}\n+| '_#7r | U0 | {bb0[0..=1], '_#2r}\n+| '_#8r | U0 | {bb0[0..=1], '_#1r}\n+| '_#9r | U0 | {bb0[0..=1], '_#3r}\n |\n | Inference Constraints\n | '_#0r live at {bb0[0..=1]}\n | '_#1r live at {bb0[0..=1]}\n | '_#2r live at {bb0[0..=1]}\n | '_#3r live at {bb0[0..=1]}\n | '_#4r live at {bb0[0..=1]}\n-| '_#1r: '_#5r due to BoringNoLocation at All($DIR/named-lifetimes-basic.rs:12:26: 12:27)\n-| '_#1r: '_#7r due to BoringNoLocation at All($DIR/named-lifetimes-basic.rs:12:54: 12:55)\n-| '_#2r: '_#6r due to BoringNoLocation at All($DIR/named-lifetimes-basic.rs:12:42: 12:43)\n-| '_#3r: '_#8r due to BoringNoLocation at All($DIR/named-lifetimes-basic.rs:12:66: 12:67)\n-| '_#5r: '_#1r due to BoringNoLocation at All($DIR/named-lifetimes-basic.rs:12:26: 12:27)\n-| '_#6r: '_#2r due to BoringNoLocation at All($DIR/named-lifetimes-basic.rs:12:42: 12:43)\n-| '_#7r: '_#1r due to BoringNoLocation at All($DIR/named-lifetimes-basic.rs:12:54: 12:55)\n-| '_#8r: '_#3r due to BoringNoLocation at All($DIR/named-lifetimes-basic.rs:12:66: 12:67)\n+| '_#1r: '_#6r due to BoringNoLocation at All($DIR/named-lifetimes-basic.rs:12:26: 12:27)\n+| '_#1r: '_#8r due to BoringNoLocation at All($DIR/named-lifetimes-basic.rs:12:54: 12:55)\n+| '_#2r: '_#7r due to BoringNoLocation at All($DIR/named-lifetimes-basic.rs:12:42: 12:43)\n+| '_#3r: '_#9r due to BoringNoLocation at All($DIR/named-lifetimes-basic.rs:12:66: 12:67)\n+| '_#6r: '_#1r due to BoringNoLocation at All($DIR/named-lifetimes-basic.rs:12:26: 12:27)\n+| '_#7r: '_#2r due to BoringNoLocation at All($DIR/named-lifetimes-basic.rs:12:42: 12:43)\n+| '_#8r: '_#1r due to BoringNoLocation at All($DIR/named-lifetimes-basic.rs:12:54: 12:55)\n+| '_#9r: '_#3r due to BoringNoLocation at All($DIR/named-lifetimes-basic.rs:12:66: 12:67)\n |\n-fn use_x(_1: &'_#5r mut i32, _2: &'_#6r u32, _3: &'_#7r u32, _4: &'_#8r u32) -> bool {\n+fn use_x(_1: &'_#6r mut i32, _2: &'_#7r u32, _3: &'_#8r u32, _4: &'_#9r u32) -> bool {\n     debug w => _1;                       // in scope 0 at $DIR/named-lifetimes-basic.rs:12:26: 12:27\n     debug x => _2;                       // in scope 0 at $DIR/named-lifetimes-basic.rs:12:42: 12:43\n     debug y => _3;                       // in scope 0 at $DIR/named-lifetimes-basic.rs:12:54: 12:55"}, {"sha": "66d7cda2b85a0b885ba9e52da76a05a11742c81d", "filename": "src/test/mir-opt/nll/region-subtyping-basic.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7ced01a730e8fc1bae2f8d4369c26812c0484da4/src%2Ftest%2Fmir-opt%2Fnll%2Fregion-subtyping-basic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ced01a730e8fc1bae2f8d4369c26812c0484da4/src%2Ftest%2Fmir-opt%2Fnll%2Fregion-subtyping-basic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fnll%2Fregion-subtyping-basic.rs?ref=7ced01a730e8fc1bae2f8d4369c26812c0484da4", "patch": "@@ -7,7 +7,9 @@\n \n #![allow(warnings)]\n \n-fn use_x(_: usize) -> bool { true }\n+fn use_x(_: usize) -> bool {\n+    true\n+}\n \n // EMIT_MIR_FOR_EACH_BIT_WIDTH\n // EMIT_MIR rustc.main.nll.0.mir"}, {"sha": "3e0867d9b09d9833c5d9c45ab062b16fc1b5657a", "filename": "src/test/mir-opt/nll/region-subtyping-basic/32bit/rustc.main.nll.0.mir", "status": "modified", "additions": 72, "deletions": 71, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/7ced01a730e8fc1bae2f8d4369c26812c0484da4/src%2Ftest%2Fmir-opt%2Fnll%2Fregion-subtyping-basic%2F32bit%2Frustc.main.nll.0.mir", "raw_url": "https://github.com/rust-lang/rust/raw/7ced01a730e8fc1bae2f8d4369c26812c0484da4/src%2Ftest%2Fmir-opt%2Fnll%2Fregion-subtyping-basic%2F32bit%2Frustc.main.nll.0.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fnll%2Fregion-subtyping-basic%2F32bit%2Frustc.main.nll.0.mir?ref=7ced01a730e8fc1bae2f8d4369c26812c0484da4", "patch": "@@ -7,164 +7,165 @@\n | Inferred Region Values\n | '_#0r | U0 | {bb0[0..=8], bb1[0], bb2[0..=8], bb3[0], bb4[0..=1], bb5[0..=3], bb6[0..=3], bb7[0..=2], bb8[0..=5], '_#0r, '_#1r}\n | '_#1r | U0 | {bb0[0..=8], bb1[0], bb2[0..=8], bb3[0], bb4[0..=1], bb5[0..=3], bb6[0..=3], bb7[0..=2], bb8[0..=5], '_#1r}\n-| '_#2r | U0 | {bb2[0..=8], bb3[0], bb5[0..=2]}\n-| '_#3r | U0 | {bb2[1..=8], bb3[0], bb5[0..=2]}\n-| '_#4r | U0 | {bb2[4..=8], bb3[0], bb5[0..=2]}\n+| '_#2r | U0 | {}\n+| '_#3r | U0 | {bb2[0..=8], bb3[0], bb5[0..=2]}\n+| '_#4r | U0 | {bb2[1..=8], bb3[0], bb5[0..=2]}\n+| '_#5r | U0 | {bb2[4..=8], bb3[0], bb5[0..=2]}\n |\n | Inference Constraints\n | '_#0r live at {bb0[0..=8], bb1[0], bb2[0..=8], bb3[0], bb4[0..=1], bb5[0..=3], bb6[0..=3], bb7[0..=2], bb8[0..=5]}\n | '_#1r live at {bb0[0..=8], bb1[0], bb2[0..=8], bb3[0], bb4[0..=1], bb5[0..=3], bb6[0..=3], bb7[0..=2], bb8[0..=5]}\n-| '_#2r live at {bb2[0]}\n-| '_#3r live at {bb2[1..=3]}\n-| '_#4r live at {bb2[4..=8], bb3[0], bb5[0..=2]}\n-| '_#2r: '_#3r due to Assignment at Single(bb2[0])\n-| '_#3r: '_#4r due to Assignment at Single(bb2[3])\n+| '_#3r live at {bb2[0]}\n+| '_#4r live at {bb2[1..=3]}\n+| '_#5r live at {bb2[4..=8], bb3[0], bb5[0..=2]}\n+| '_#3r: '_#4r due to Assignment at Single(bb2[0])\n+| '_#4r: '_#5r due to Assignment at Single(bb2[3])\n |\n fn main() -> () {\n-    let mut _0: ();                      // return place in scope 0 at $DIR/region-subtyping-basic.rs:14:11: 14:11\n-    let mut _1: [usize; Const { ty: usize, val: Value(Scalar(0x00000003)) }]; // in scope 0 at $DIR/region-subtyping-basic.rs:15:9: 15:14\n-    let _3: usize;                       // in scope 0 at $DIR/region-subtyping-basic.rs:16:16: 16:17\n-    let mut _4: usize;                   // in scope 0 at $DIR/region-subtyping-basic.rs:16:14: 16:18\n-    let mut _5: bool;                    // in scope 0 at $DIR/region-subtyping-basic.rs:16:14: 16:18\n-    let mut _7: bool;                    // in scope 0 at $DIR/region-subtyping-basic.rs:18:8: 18:12\n-    let _8: bool;                        // in scope 0 at $DIR/region-subtyping-basic.rs:19:9: 19:18\n-    let mut _9: usize;                   // in scope 0 at $DIR/region-subtyping-basic.rs:19:15: 19:17\n-    let _10: bool;                       // in scope 0 at $DIR/region-subtyping-basic.rs:21:9: 21:18\n+    let mut _0: ();                      // return place in scope 0 at $DIR/region-subtyping-basic.rs:16:11: 16:11\n+    let mut _1: [usize; Const { ty: usize, val: Value(Scalar(0x00000003)) }]; // in scope 0 at $DIR/region-subtyping-basic.rs:17:9: 17:14\n+    let _3: usize;                       // in scope 0 at $DIR/region-subtyping-basic.rs:18:16: 18:17\n+    let mut _4: usize;                   // in scope 0 at $DIR/region-subtyping-basic.rs:18:14: 18:18\n+    let mut _5: bool;                    // in scope 0 at $DIR/region-subtyping-basic.rs:18:14: 18:18\n+    let mut _7: bool;                    // in scope 0 at $DIR/region-subtyping-basic.rs:20:8: 20:12\n+    let _8: bool;                        // in scope 0 at $DIR/region-subtyping-basic.rs:21:9: 21:18\n+    let mut _9: usize;                   // in scope 0 at $DIR/region-subtyping-basic.rs:21:15: 21:17\n+    let _10: bool;                       // in scope 0 at $DIR/region-subtyping-basic.rs:23:9: 23:18\n     scope 1 {\n-        debug v => _1;                   // in scope 1 at $DIR/region-subtyping-basic.rs:15:9: 15:14\n-        let _2: &'_#3r usize;            // in scope 1 at $DIR/region-subtyping-basic.rs:16:9: 16:10\n+        debug v => _1;                   // in scope 1 at $DIR/region-subtyping-basic.rs:17:9: 17:14\n+        let _2: &'_#4r usize;            // in scope 1 at $DIR/region-subtyping-basic.rs:18:9: 18:10\n         scope 2 {\n-            debug p => _2;               // in scope 2 at $DIR/region-subtyping-basic.rs:16:9: 16:10\n-            let _6: &'_#4r usize;        // in scope 2 at $DIR/region-subtyping-basic.rs:17:9: 17:10\n+            debug p => _2;               // in scope 2 at $DIR/region-subtyping-basic.rs:18:9: 18:10\n+            let _6: &'_#5r usize;        // in scope 2 at $DIR/region-subtyping-basic.rs:19:9: 19:10\n             scope 3 {\n-                debug q => _6;           // in scope 3 at $DIR/region-subtyping-basic.rs:17:9: 17:10\n+                debug q => _6;           // in scope 3 at $DIR/region-subtyping-basic.rs:19:9: 19:10\n             }\n         }\n     }\n \n     bb0: {\n-        StorageLive(_1);                 // bb0[0]: scope 0 at $DIR/region-subtyping-basic.rs:15:9: 15:14\n-        _1 = [const Const(Value(Scalar(0x00000001)): usize), const Const(Value(Scalar(0x00000002)): usize), const Const(Value(Scalar(0x00000003)): usize)]; // bb0[1]: scope 0 at $DIR/region-subtyping-basic.rs:15:17: 15:26\n+        StorageLive(_1);                 // bb0[0]: scope 0 at $DIR/region-subtyping-basic.rs:17:9: 17:14\n+        _1 = [const Const(Value(Scalar(0x00000001)): usize), const Const(Value(Scalar(0x00000002)): usize), const Const(Value(Scalar(0x00000003)): usize)]; // bb0[1]: scope 0 at $DIR/region-subtyping-basic.rs:17:17: 17:26\n                                          // ty::Const\n                                          // + ty: usize\n                                          // + val: Value(Scalar(0x00000001))\n                                          // mir::Constant\n-                                         // + span: $DIR/region-subtyping-basic.rs:15:18: 15:19\n+                                         // + span: $DIR/region-subtyping-basic.rs:17:18: 17:19\n                                          // + literal: Const { ty: usize, val: Value(Scalar(0x00000001)) }\n                                          // ty::Const\n                                          // + ty: usize\n                                          // + val: Value(Scalar(0x00000002))\n                                          // mir::Constant\n-                                         // + span: $DIR/region-subtyping-basic.rs:15:21: 15:22\n+                                         // + span: $DIR/region-subtyping-basic.rs:17:21: 17:22\n                                          // + literal: Const { ty: usize, val: Value(Scalar(0x00000002)) }\n                                          // ty::Const\n                                          // + ty: usize\n                                          // + val: Value(Scalar(0x00000003))\n                                          // mir::Constant\n-                                         // + span: $DIR/region-subtyping-basic.rs:15:24: 15:25\n+                                         // + span: $DIR/region-subtyping-basic.rs:17:24: 17:25\n                                          // + literal: Const { ty: usize, val: Value(Scalar(0x00000003)) }\n-        FakeRead(ForLet, _1);            // bb0[2]: scope 0 at $DIR/region-subtyping-basic.rs:15:9: 15:14\n-        StorageLive(_2);                 // bb0[3]: scope 1 at $DIR/region-subtyping-basic.rs:16:9: 16:10\n-        StorageLive(_3);                 // bb0[4]: scope 1 at $DIR/region-subtyping-basic.rs:16:16: 16:17\n-        _3 = const Const(Value(Scalar(0x00000000)): usize); // bb0[5]: scope 1 at $DIR/region-subtyping-basic.rs:16:16: 16:17\n+        FakeRead(ForLet, _1);            // bb0[2]: scope 0 at $DIR/region-subtyping-basic.rs:17:9: 17:14\n+        StorageLive(_2);                 // bb0[3]: scope 1 at $DIR/region-subtyping-basic.rs:18:9: 18:10\n+        StorageLive(_3);                 // bb0[4]: scope 1 at $DIR/region-subtyping-basic.rs:18:16: 18:17\n+        _3 = const Const(Value(Scalar(0x00000000)): usize); // bb0[5]: scope 1 at $DIR/region-subtyping-basic.rs:18:16: 18:17\n                                          // ty::Const\n                                          // + ty: usize\n                                          // + val: Value(Scalar(0x00000000))\n                                          // mir::Constant\n-                                         // + span: $DIR/region-subtyping-basic.rs:16:16: 16:17\n+                                         // + span: $DIR/region-subtyping-basic.rs:18:16: 18:17\n                                          // + literal: Const { ty: usize, val: Value(Scalar(0x00000000)) }\n-        _4 = Len(_1);                    // bb0[6]: scope 1 at $DIR/region-subtyping-basic.rs:16:14: 16:18\n-        _5 = Lt(_3, _4);                 // bb0[7]: scope 1 at $DIR/region-subtyping-basic.rs:16:14: 16:18\n-        assert(move _5, \"index out of bounds: the len is {} but the index is {}\", move _4, _3) -> [success: bb2, unwind: bb1]; // bb0[8]: scope 1 at $DIR/region-subtyping-basic.rs:16:14: 16:18\n+        _4 = Len(_1);                    // bb0[6]: scope 1 at $DIR/region-subtyping-basic.rs:18:14: 18:18\n+        _5 = Lt(_3, _4);                 // bb0[7]: scope 1 at $DIR/region-subtyping-basic.rs:18:14: 18:18\n+        assert(move _5, \"index out of bounds: the len is {} but the index is {}\", move _4, _3) -> [success: bb2, unwind: bb1]; // bb0[8]: scope 1 at $DIR/region-subtyping-basic.rs:18:14: 18:18\n     }\n \n     bb1 (cleanup): {\n-        resume;                          // bb1[0]: scope 0 at $DIR/region-subtyping-basic.rs:14:1: 23:2\n+        resume;                          // bb1[0]: scope 0 at $DIR/region-subtyping-basic.rs:16:1: 25:2\n     }\n \n     bb2: {\n-        _2 = &'_#2r _1[_3];              // bb2[0]: scope 1 at $DIR/region-subtyping-basic.rs:16:13: 16:18\n-        FakeRead(ForLet, _2);            // bb2[1]: scope 1 at $DIR/region-subtyping-basic.rs:16:9: 16:10\n-        StorageLive(_6);                 // bb2[2]: scope 2 at $DIR/region-subtyping-basic.rs:17:9: 17:10\n-        _6 = _2;                         // bb2[3]: scope 2 at $DIR/region-subtyping-basic.rs:17:13: 17:14\n-        FakeRead(ForLet, _6);            // bb2[4]: scope 2 at $DIR/region-subtyping-basic.rs:17:9: 17:10\n-        StorageLive(_7);                 // bb2[5]: scope 3 at $DIR/region-subtyping-basic.rs:18:8: 18:12\n-        _7 = const Const(Value(Scalar(0x01)): bool); // bb2[6]: scope 3 at $DIR/region-subtyping-basic.rs:18:8: 18:12\n+        _2 = &'_#3r _1[_3];              // bb2[0]: scope 1 at $DIR/region-subtyping-basic.rs:18:13: 18:18\n+        FakeRead(ForLet, _2);            // bb2[1]: scope 1 at $DIR/region-subtyping-basic.rs:18:9: 18:10\n+        StorageLive(_6);                 // bb2[2]: scope 2 at $DIR/region-subtyping-basic.rs:19:9: 19:10\n+        _6 = _2;                         // bb2[3]: scope 2 at $DIR/region-subtyping-basic.rs:19:13: 19:14\n+        FakeRead(ForLet, _6);            // bb2[4]: scope 2 at $DIR/region-subtyping-basic.rs:19:9: 19:10\n+        StorageLive(_7);                 // bb2[5]: scope 3 at $DIR/region-subtyping-basic.rs:20:8: 20:12\n+        _7 = const Const(Value(Scalar(0x01)): bool); // bb2[6]: scope 3 at $DIR/region-subtyping-basic.rs:20:8: 20:12\n                                          // ty::Const\n                                          // + ty: bool\n                                          // + val: Value(Scalar(0x01))\n                                          // mir::Constant\n-                                         // + span: $DIR/region-subtyping-basic.rs:18:8: 18:12\n+                                         // + span: $DIR/region-subtyping-basic.rs:20:8: 20:12\n                                          // + literal: Const { ty: bool, val: Value(Scalar(0x01)) }\n-        FakeRead(ForMatchedPlace, _7);   // bb2[7]: scope 3 at $DIR/region-subtyping-basic.rs:18:8: 18:12\n-        switchInt(_7) -> [Const(Value(Scalar(0x00)): bool): bb4, otherwise: bb3]; // bb2[8]: scope 3 at $DIR/region-subtyping-basic.rs:18:5: 22:6\n+        FakeRead(ForMatchedPlace, _7);   // bb2[7]: scope 3 at $DIR/region-subtyping-basic.rs:20:8: 20:12\n+        switchInt(_7) -> [Const(Value(Scalar(0x00)): bool): bb4, otherwise: bb3]; // bb2[8]: scope 3 at $DIR/region-subtyping-basic.rs:20:5: 24:6\n     }\n \n     bb3: {\n-        falseEdges -> [real: bb5, imaginary: bb4]; // bb3[0]: scope 3 at $DIR/region-subtyping-basic.rs:18:5: 22:6\n+        falseEdges -> [real: bb5, imaginary: bb4]; // bb3[0]: scope 3 at $DIR/region-subtyping-basic.rs:20:5: 24:6\n     }\n \n     bb4: {\n-        StorageLive(_10);                // bb4[0]: scope 3 at $DIR/region-subtyping-basic.rs:21:9: 21:18\n-        _10 = const Const(Value(Scalar(<ZST>)): fn(usize) -> bool {use_x})(const Const(Value(Scalar(0x00000016)): usize)) -> [return: bb7, unwind: bb1]; // bb4[1]: scope 3 at $DIR/region-subtyping-basic.rs:21:9: 21:18\n+        StorageLive(_10);                // bb4[0]: scope 3 at $DIR/region-subtyping-basic.rs:23:9: 23:18\n+        _10 = const Const(Value(Scalar(<ZST>)): fn(usize) -> bool {use_x})(const Const(Value(Scalar(0x00000016)): usize)) -> [return: bb7, unwind: bb1]; // bb4[1]: scope 3 at $DIR/region-subtyping-basic.rs:23:9: 23:18\n                                          // ty::Const\n                                          // + ty: fn(usize) -> bool {use_x}\n                                          // + val: Value(Scalar(<ZST>))\n                                          // mir::Constant\n-                                         // + span: $DIR/region-subtyping-basic.rs:21:9: 21:14\n+                                         // + span: $DIR/region-subtyping-basic.rs:23:9: 23:14\n                                          // + literal: Const { ty: fn(usize) -> bool {use_x}, val: Value(Scalar(<ZST>)) }\n                                          // ty::Const\n                                          // + ty: usize\n                                          // + val: Value(Scalar(0x00000016))\n                                          // mir::Constant\n-                                         // + span: $DIR/region-subtyping-basic.rs:21:15: 21:17\n+                                         // + span: $DIR/region-subtyping-basic.rs:23:15: 23:17\n                                          // + literal: Const { ty: usize, val: Value(Scalar(0x00000016)) }\n     }\n \n     bb5: {\n-        StorageLive(_8);                 // bb5[0]: scope 3 at $DIR/region-subtyping-basic.rs:19:9: 19:18\n-        StorageLive(_9);                 // bb5[1]: scope 3 at $DIR/region-subtyping-basic.rs:19:15: 19:17\n-        _9 = (*_6);                      // bb5[2]: scope 3 at $DIR/region-subtyping-basic.rs:19:15: 19:17\n-        _8 = const Const(Value(Scalar(<ZST>)): fn(usize) -> bool {use_x})(move _9) -> [return: bb6, unwind: bb1]; // bb5[3]: scope 3 at $DIR/region-subtyping-basic.rs:19:9: 19:18\n+        StorageLive(_8);                 // bb5[0]: scope 3 at $DIR/region-subtyping-basic.rs:21:9: 21:18\n+        StorageLive(_9);                 // bb5[1]: scope 3 at $DIR/region-subtyping-basic.rs:21:15: 21:17\n+        _9 = (*_6);                      // bb5[2]: scope 3 at $DIR/region-subtyping-basic.rs:21:15: 21:17\n+        _8 = const Const(Value(Scalar(<ZST>)): fn(usize) -> bool {use_x})(move _9) -> [return: bb6, unwind: bb1]; // bb5[3]: scope 3 at $DIR/region-subtyping-basic.rs:21:9: 21:18\n                                          // ty::Const\n                                          // + ty: fn(usize) -> bool {use_x}\n                                          // + val: Value(Scalar(<ZST>))\n                                          // mir::Constant\n-                                         // + span: $DIR/region-subtyping-basic.rs:19:9: 19:14\n+                                         // + span: $DIR/region-subtyping-basic.rs:21:9: 21:14\n                                          // + literal: Const { ty: fn(usize) -> bool {use_x}, val: Value(Scalar(<ZST>)) }\n     }\n \n     bb6: {\n-        StorageDead(_9);                 // bb6[0]: scope 3 at $DIR/region-subtyping-basic.rs:19:17: 19:18\n-        StorageDead(_8);                 // bb6[1]: scope 3 at $DIR/region-subtyping-basic.rs:19:18: 19:19\n-        _0 = const Const(Value(Scalar(<ZST>)): ()); // bb6[2]: scope 3 at $DIR/region-subtyping-basic.rs:18:13: 20:6\n+        StorageDead(_9);                 // bb6[0]: scope 3 at $DIR/region-subtyping-basic.rs:21:17: 21:18\n+        StorageDead(_8);                 // bb6[1]: scope 3 at $DIR/region-subtyping-basic.rs:21:18: 21:19\n+        _0 = const Const(Value(Scalar(<ZST>)): ()); // bb6[2]: scope 3 at $DIR/region-subtyping-basic.rs:20:13: 22:6\n                                          // ty::Const\n                                          // + ty: ()\n                                          // + val: Value(Scalar(<ZST>))\n                                          // mir::Constant\n-                                         // + span: $DIR/region-subtyping-basic.rs:18:13: 20:6\n+                                         // + span: $DIR/region-subtyping-basic.rs:20:13: 22:6\n                                          // + literal: Const { ty: (), val: Value(Scalar(<ZST>)) }\n-        goto -> bb8;                     // bb6[3]: scope 3 at $DIR/region-subtyping-basic.rs:18:5: 22:6\n+        goto -> bb8;                     // bb6[3]: scope 3 at $DIR/region-subtyping-basic.rs:20:5: 24:6\n     }\n \n     bb7: {\n-        StorageDead(_10);                // bb7[0]: scope 3 at $DIR/region-subtyping-basic.rs:21:18: 21:19\n-        _0 = const Const(Value(Scalar(<ZST>)): ()); // bb7[1]: scope 3 at $DIR/region-subtyping-basic.rs:20:12: 22:6\n+        StorageDead(_10);                // bb7[0]: scope 3 at $DIR/region-subtyping-basic.rs:23:18: 23:19\n+        _0 = const Const(Value(Scalar(<ZST>)): ()); // bb7[1]: scope 3 at $DIR/region-subtyping-basic.rs:22:12: 24:6\n                                          // ty::Const\n                                          // + ty: ()\n                                          // + val: Value(Scalar(<ZST>))\n                                          // mir::Constant\n-                                         // + span: $DIR/region-subtyping-basic.rs:20:12: 22:6\n+                                         // + span: $DIR/region-subtyping-basic.rs:22:12: 24:6\n                                          // + literal: Const { ty: (), val: Value(Scalar(<ZST>)) }\n-        goto -> bb8;                     // bb7[2]: scope 3 at $DIR/region-subtyping-basic.rs:18:5: 22:6\n+        goto -> bb8;                     // bb7[2]: scope 3 at $DIR/region-subtyping-basic.rs:20:5: 24:6\n     }\n \n     bb8: {\n-        StorageDead(_6);                 // bb8[0]: scope 2 at $DIR/region-subtyping-basic.rs:23:1: 23:2\n-        StorageDead(_3);                 // bb8[1]: scope 1 at $DIR/region-subtyping-basic.rs:23:1: 23:2\n-        StorageDead(_2);                 // bb8[2]: scope 1 at $DIR/region-subtyping-basic.rs:23:1: 23:2\n-        StorageDead(_1);                 // bb8[3]: scope 0 at $DIR/region-subtyping-basic.rs:23:1: 23:2\n-        StorageDead(_7);                 // bb8[4]: scope 0 at $DIR/region-subtyping-basic.rs:23:1: 23:2\n-        return;                          // bb8[5]: scope 0 at $DIR/region-subtyping-basic.rs:23:2: 23:2\n+        StorageDead(_6);                 // bb8[0]: scope 2 at $DIR/region-subtyping-basic.rs:25:1: 25:2\n+        StorageDead(_3);                 // bb8[1]: scope 1 at $DIR/region-subtyping-basic.rs:25:1: 25:2\n+        StorageDead(_2);                 // bb8[2]: scope 1 at $DIR/region-subtyping-basic.rs:25:1: 25:2\n+        StorageDead(_1);                 // bb8[3]: scope 0 at $DIR/region-subtyping-basic.rs:25:1: 25:2\n+        StorageDead(_7);                 // bb8[4]: scope 0 at $DIR/region-subtyping-basic.rs:25:1: 25:2\n+        return;                          // bb8[5]: scope 0 at $DIR/region-subtyping-basic.rs:25:2: 25:2\n     }\n }"}, {"sha": "61db4dba5862755a96cb56034295a631fbdd79f9", "filename": "src/test/mir-opt/nll/region-subtyping-basic/64bit/rustc.main.nll.0.mir", "status": "modified", "additions": 72, "deletions": 71, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/7ced01a730e8fc1bae2f8d4369c26812c0484da4/src%2Ftest%2Fmir-opt%2Fnll%2Fregion-subtyping-basic%2F64bit%2Frustc.main.nll.0.mir", "raw_url": "https://github.com/rust-lang/rust/raw/7ced01a730e8fc1bae2f8d4369c26812c0484da4/src%2Ftest%2Fmir-opt%2Fnll%2Fregion-subtyping-basic%2F64bit%2Frustc.main.nll.0.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fnll%2Fregion-subtyping-basic%2F64bit%2Frustc.main.nll.0.mir?ref=7ced01a730e8fc1bae2f8d4369c26812c0484da4", "patch": "@@ -7,164 +7,165 @@\n | Inferred Region Values\n | '_#0r | U0 | {bb0[0..=8], bb1[0], bb2[0..=8], bb3[0], bb4[0..=1], bb5[0..=3], bb6[0..=3], bb7[0..=2], bb8[0..=5], '_#0r, '_#1r}\n | '_#1r | U0 | {bb0[0..=8], bb1[0], bb2[0..=8], bb3[0], bb4[0..=1], bb5[0..=3], bb6[0..=3], bb7[0..=2], bb8[0..=5], '_#1r}\n-| '_#2r | U0 | {bb2[0..=8], bb3[0], bb5[0..=2]}\n-| '_#3r | U0 | {bb2[1..=8], bb3[0], bb5[0..=2]}\n-| '_#4r | U0 | {bb2[4..=8], bb3[0], bb5[0..=2]}\n+| '_#2r | U0 | {}\n+| '_#3r | U0 | {bb2[0..=8], bb3[0], bb5[0..=2]}\n+| '_#4r | U0 | {bb2[1..=8], bb3[0], bb5[0..=2]}\n+| '_#5r | U0 | {bb2[4..=8], bb3[0], bb5[0..=2]}\n |\n | Inference Constraints\n | '_#0r live at {bb0[0..=8], bb1[0], bb2[0..=8], bb3[0], bb4[0..=1], bb5[0..=3], bb6[0..=3], bb7[0..=2], bb8[0..=5]}\n | '_#1r live at {bb0[0..=8], bb1[0], bb2[0..=8], bb3[0], bb4[0..=1], bb5[0..=3], bb6[0..=3], bb7[0..=2], bb8[0..=5]}\n-| '_#2r live at {bb2[0]}\n-| '_#3r live at {bb2[1..=3]}\n-| '_#4r live at {bb2[4..=8], bb3[0], bb5[0..=2]}\n-| '_#2r: '_#3r due to Assignment at Single(bb2[0])\n-| '_#3r: '_#4r due to Assignment at Single(bb2[3])\n+| '_#3r live at {bb2[0]}\n+| '_#4r live at {bb2[1..=3]}\n+| '_#5r live at {bb2[4..=8], bb3[0], bb5[0..=2]}\n+| '_#3r: '_#4r due to Assignment at Single(bb2[0])\n+| '_#4r: '_#5r due to Assignment at Single(bb2[3])\n |\n fn main() -> () {\n-    let mut _0: ();                      // return place in scope 0 at $DIR/region-subtyping-basic.rs:14:11: 14:11\n-    let mut _1: [usize; Const { ty: usize, val: Value(Scalar(0x0000000000000003)) }]; // in scope 0 at $DIR/region-subtyping-basic.rs:15:9: 15:14\n-    let _3: usize;                       // in scope 0 at $DIR/region-subtyping-basic.rs:16:16: 16:17\n-    let mut _4: usize;                   // in scope 0 at $DIR/region-subtyping-basic.rs:16:14: 16:18\n-    let mut _5: bool;                    // in scope 0 at $DIR/region-subtyping-basic.rs:16:14: 16:18\n-    let mut _7: bool;                    // in scope 0 at $DIR/region-subtyping-basic.rs:18:8: 18:12\n-    let _8: bool;                        // in scope 0 at $DIR/region-subtyping-basic.rs:19:9: 19:18\n-    let mut _9: usize;                   // in scope 0 at $DIR/region-subtyping-basic.rs:19:15: 19:17\n-    let _10: bool;                       // in scope 0 at $DIR/region-subtyping-basic.rs:21:9: 21:18\n+    let mut _0: ();                      // return place in scope 0 at $DIR/region-subtyping-basic.rs:16:11: 16:11\n+    let mut _1: [usize; Const { ty: usize, val: Value(Scalar(0x0000000000000003)) }]; // in scope 0 at $DIR/region-subtyping-basic.rs:17:9: 17:14\n+    let _3: usize;                       // in scope 0 at $DIR/region-subtyping-basic.rs:18:16: 18:17\n+    let mut _4: usize;                   // in scope 0 at $DIR/region-subtyping-basic.rs:18:14: 18:18\n+    let mut _5: bool;                    // in scope 0 at $DIR/region-subtyping-basic.rs:18:14: 18:18\n+    let mut _7: bool;                    // in scope 0 at $DIR/region-subtyping-basic.rs:20:8: 20:12\n+    let _8: bool;                        // in scope 0 at $DIR/region-subtyping-basic.rs:21:9: 21:18\n+    let mut _9: usize;                   // in scope 0 at $DIR/region-subtyping-basic.rs:21:15: 21:17\n+    let _10: bool;                       // in scope 0 at $DIR/region-subtyping-basic.rs:23:9: 23:18\n     scope 1 {\n-        debug v => _1;                   // in scope 1 at $DIR/region-subtyping-basic.rs:15:9: 15:14\n-        let _2: &'_#3r usize;            // in scope 1 at $DIR/region-subtyping-basic.rs:16:9: 16:10\n+        debug v => _1;                   // in scope 1 at $DIR/region-subtyping-basic.rs:17:9: 17:14\n+        let _2: &'_#4r usize;            // in scope 1 at $DIR/region-subtyping-basic.rs:18:9: 18:10\n         scope 2 {\n-            debug p => _2;               // in scope 2 at $DIR/region-subtyping-basic.rs:16:9: 16:10\n-            let _6: &'_#4r usize;        // in scope 2 at $DIR/region-subtyping-basic.rs:17:9: 17:10\n+            debug p => _2;               // in scope 2 at $DIR/region-subtyping-basic.rs:18:9: 18:10\n+            let _6: &'_#5r usize;        // in scope 2 at $DIR/region-subtyping-basic.rs:19:9: 19:10\n             scope 3 {\n-                debug q => _6;           // in scope 3 at $DIR/region-subtyping-basic.rs:17:9: 17:10\n+                debug q => _6;           // in scope 3 at $DIR/region-subtyping-basic.rs:19:9: 19:10\n             }\n         }\n     }\n \n     bb0: {\n-        StorageLive(_1);                 // bb0[0]: scope 0 at $DIR/region-subtyping-basic.rs:15:9: 15:14\n-        _1 = [const Const(Value(Scalar(0x0000000000000001)): usize), const Const(Value(Scalar(0x0000000000000002)): usize), const Const(Value(Scalar(0x0000000000000003)): usize)]; // bb0[1]: scope 0 at $DIR/region-subtyping-basic.rs:15:17: 15:26\n+        StorageLive(_1);                 // bb0[0]: scope 0 at $DIR/region-subtyping-basic.rs:17:9: 17:14\n+        _1 = [const Const(Value(Scalar(0x0000000000000001)): usize), const Const(Value(Scalar(0x0000000000000002)): usize), const Const(Value(Scalar(0x0000000000000003)): usize)]; // bb0[1]: scope 0 at $DIR/region-subtyping-basic.rs:17:17: 17:26\n                                          // ty::Const\n                                          // + ty: usize\n                                          // + val: Value(Scalar(0x0000000000000001))\n                                          // mir::Constant\n-                                         // + span: $DIR/region-subtyping-basic.rs:15:18: 15:19\n+                                         // + span: $DIR/region-subtyping-basic.rs:17:18: 17:19\n                                          // + literal: Const { ty: usize, val: Value(Scalar(0x0000000000000001)) }\n                                          // ty::Const\n                                          // + ty: usize\n                                          // + val: Value(Scalar(0x0000000000000002))\n                                          // mir::Constant\n-                                         // + span: $DIR/region-subtyping-basic.rs:15:21: 15:22\n+                                         // + span: $DIR/region-subtyping-basic.rs:17:21: 17:22\n                                          // + literal: Const { ty: usize, val: Value(Scalar(0x0000000000000002)) }\n                                          // ty::Const\n                                          // + ty: usize\n                                          // + val: Value(Scalar(0x0000000000000003))\n                                          // mir::Constant\n-                                         // + span: $DIR/region-subtyping-basic.rs:15:24: 15:25\n+                                         // + span: $DIR/region-subtyping-basic.rs:17:24: 17:25\n                                          // + literal: Const { ty: usize, val: Value(Scalar(0x0000000000000003)) }\n-        FakeRead(ForLet, _1);            // bb0[2]: scope 0 at $DIR/region-subtyping-basic.rs:15:9: 15:14\n-        StorageLive(_2);                 // bb0[3]: scope 1 at $DIR/region-subtyping-basic.rs:16:9: 16:10\n-        StorageLive(_3);                 // bb0[4]: scope 1 at $DIR/region-subtyping-basic.rs:16:16: 16:17\n-        _3 = const Const(Value(Scalar(0x0000000000000000)): usize); // bb0[5]: scope 1 at $DIR/region-subtyping-basic.rs:16:16: 16:17\n+        FakeRead(ForLet, _1);            // bb0[2]: scope 0 at $DIR/region-subtyping-basic.rs:17:9: 17:14\n+        StorageLive(_2);                 // bb0[3]: scope 1 at $DIR/region-subtyping-basic.rs:18:9: 18:10\n+        StorageLive(_3);                 // bb0[4]: scope 1 at $DIR/region-subtyping-basic.rs:18:16: 18:17\n+        _3 = const Const(Value(Scalar(0x0000000000000000)): usize); // bb0[5]: scope 1 at $DIR/region-subtyping-basic.rs:18:16: 18:17\n                                          // ty::Const\n                                          // + ty: usize\n                                          // + val: Value(Scalar(0x0000000000000000))\n                                          // mir::Constant\n-                                         // + span: $DIR/region-subtyping-basic.rs:16:16: 16:17\n+                                         // + span: $DIR/region-subtyping-basic.rs:18:16: 18:17\n                                          // + literal: Const { ty: usize, val: Value(Scalar(0x0000000000000000)) }\n-        _4 = Len(_1);                    // bb0[6]: scope 1 at $DIR/region-subtyping-basic.rs:16:14: 16:18\n-        _5 = Lt(_3, _4);                 // bb0[7]: scope 1 at $DIR/region-subtyping-basic.rs:16:14: 16:18\n-        assert(move _5, \"index out of bounds: the len is {} but the index is {}\", move _4, _3) -> [success: bb2, unwind: bb1]; // bb0[8]: scope 1 at $DIR/region-subtyping-basic.rs:16:14: 16:18\n+        _4 = Len(_1);                    // bb0[6]: scope 1 at $DIR/region-subtyping-basic.rs:18:14: 18:18\n+        _5 = Lt(_3, _4);                 // bb0[7]: scope 1 at $DIR/region-subtyping-basic.rs:18:14: 18:18\n+        assert(move _5, \"index out of bounds: the len is {} but the index is {}\", move _4, _3) -> [success: bb2, unwind: bb1]; // bb0[8]: scope 1 at $DIR/region-subtyping-basic.rs:18:14: 18:18\n     }\n \n     bb1 (cleanup): {\n-        resume;                          // bb1[0]: scope 0 at $DIR/region-subtyping-basic.rs:14:1: 23:2\n+        resume;                          // bb1[0]: scope 0 at $DIR/region-subtyping-basic.rs:16:1: 25:2\n     }\n \n     bb2: {\n-        _2 = &'_#2r _1[_3];              // bb2[0]: scope 1 at $DIR/region-subtyping-basic.rs:16:13: 16:18\n-        FakeRead(ForLet, _2);            // bb2[1]: scope 1 at $DIR/region-subtyping-basic.rs:16:9: 16:10\n-        StorageLive(_6);                 // bb2[2]: scope 2 at $DIR/region-subtyping-basic.rs:17:9: 17:10\n-        _6 = _2;                         // bb2[3]: scope 2 at $DIR/region-subtyping-basic.rs:17:13: 17:14\n-        FakeRead(ForLet, _6);            // bb2[4]: scope 2 at $DIR/region-subtyping-basic.rs:17:9: 17:10\n-        StorageLive(_7);                 // bb2[5]: scope 3 at $DIR/region-subtyping-basic.rs:18:8: 18:12\n-        _7 = const Const(Value(Scalar(0x01)): bool); // bb2[6]: scope 3 at $DIR/region-subtyping-basic.rs:18:8: 18:12\n+        _2 = &'_#3r _1[_3];              // bb2[0]: scope 1 at $DIR/region-subtyping-basic.rs:18:13: 18:18\n+        FakeRead(ForLet, _2);            // bb2[1]: scope 1 at $DIR/region-subtyping-basic.rs:18:9: 18:10\n+        StorageLive(_6);                 // bb2[2]: scope 2 at $DIR/region-subtyping-basic.rs:19:9: 19:10\n+        _6 = _2;                         // bb2[3]: scope 2 at $DIR/region-subtyping-basic.rs:19:13: 19:14\n+        FakeRead(ForLet, _6);            // bb2[4]: scope 2 at $DIR/region-subtyping-basic.rs:19:9: 19:10\n+        StorageLive(_7);                 // bb2[5]: scope 3 at $DIR/region-subtyping-basic.rs:20:8: 20:12\n+        _7 = const Const(Value(Scalar(0x01)): bool); // bb2[6]: scope 3 at $DIR/region-subtyping-basic.rs:20:8: 20:12\n                                          // ty::Const\n                                          // + ty: bool\n                                          // + val: Value(Scalar(0x01))\n                                          // mir::Constant\n-                                         // + span: $DIR/region-subtyping-basic.rs:18:8: 18:12\n+                                         // + span: $DIR/region-subtyping-basic.rs:20:8: 20:12\n                                          // + literal: Const { ty: bool, val: Value(Scalar(0x01)) }\n-        FakeRead(ForMatchedPlace, _7);   // bb2[7]: scope 3 at $DIR/region-subtyping-basic.rs:18:8: 18:12\n-        switchInt(_7) -> [Const(Value(Scalar(0x00)): bool): bb4, otherwise: bb3]; // bb2[8]: scope 3 at $DIR/region-subtyping-basic.rs:18:5: 22:6\n+        FakeRead(ForMatchedPlace, _7);   // bb2[7]: scope 3 at $DIR/region-subtyping-basic.rs:20:8: 20:12\n+        switchInt(_7) -> [Const(Value(Scalar(0x00)): bool): bb4, otherwise: bb3]; // bb2[8]: scope 3 at $DIR/region-subtyping-basic.rs:20:5: 24:6\n     }\n \n     bb3: {\n-        falseEdges -> [real: bb5, imaginary: bb4]; // bb3[0]: scope 3 at $DIR/region-subtyping-basic.rs:18:5: 22:6\n+        falseEdges -> [real: bb5, imaginary: bb4]; // bb3[0]: scope 3 at $DIR/region-subtyping-basic.rs:20:5: 24:6\n     }\n \n     bb4: {\n-        StorageLive(_10);                // bb4[0]: scope 3 at $DIR/region-subtyping-basic.rs:21:9: 21:18\n-        _10 = const Const(Value(Scalar(<ZST>)): fn(usize) -> bool {use_x})(const Const(Value(Scalar(0x0000000000000016)): usize)) -> [return: bb7, unwind: bb1]; // bb4[1]: scope 3 at $DIR/region-subtyping-basic.rs:21:9: 21:18\n+        StorageLive(_10);                // bb4[0]: scope 3 at $DIR/region-subtyping-basic.rs:23:9: 23:18\n+        _10 = const Const(Value(Scalar(<ZST>)): fn(usize) -> bool {use_x})(const Const(Value(Scalar(0x0000000000000016)): usize)) -> [return: bb7, unwind: bb1]; // bb4[1]: scope 3 at $DIR/region-subtyping-basic.rs:23:9: 23:18\n                                          // ty::Const\n                                          // + ty: fn(usize) -> bool {use_x}\n                                          // + val: Value(Scalar(<ZST>))\n                                          // mir::Constant\n-                                         // + span: $DIR/region-subtyping-basic.rs:21:9: 21:14\n+                                         // + span: $DIR/region-subtyping-basic.rs:23:9: 23:14\n                                          // + literal: Const { ty: fn(usize) -> bool {use_x}, val: Value(Scalar(<ZST>)) }\n                                          // ty::Const\n                                          // + ty: usize\n                                          // + val: Value(Scalar(0x0000000000000016))\n                                          // mir::Constant\n-                                         // + span: $DIR/region-subtyping-basic.rs:21:15: 21:17\n+                                         // + span: $DIR/region-subtyping-basic.rs:23:15: 23:17\n                                          // + literal: Const { ty: usize, val: Value(Scalar(0x0000000000000016)) }\n     }\n \n     bb5: {\n-        StorageLive(_8);                 // bb5[0]: scope 3 at $DIR/region-subtyping-basic.rs:19:9: 19:18\n-        StorageLive(_9);                 // bb5[1]: scope 3 at $DIR/region-subtyping-basic.rs:19:15: 19:17\n-        _9 = (*_6);                      // bb5[2]: scope 3 at $DIR/region-subtyping-basic.rs:19:15: 19:17\n-        _8 = const Const(Value(Scalar(<ZST>)): fn(usize) -> bool {use_x})(move _9) -> [return: bb6, unwind: bb1]; // bb5[3]: scope 3 at $DIR/region-subtyping-basic.rs:19:9: 19:18\n+        StorageLive(_8);                 // bb5[0]: scope 3 at $DIR/region-subtyping-basic.rs:21:9: 21:18\n+        StorageLive(_9);                 // bb5[1]: scope 3 at $DIR/region-subtyping-basic.rs:21:15: 21:17\n+        _9 = (*_6);                      // bb5[2]: scope 3 at $DIR/region-subtyping-basic.rs:21:15: 21:17\n+        _8 = const Const(Value(Scalar(<ZST>)): fn(usize) -> bool {use_x})(move _9) -> [return: bb6, unwind: bb1]; // bb5[3]: scope 3 at $DIR/region-subtyping-basic.rs:21:9: 21:18\n                                          // ty::Const\n                                          // + ty: fn(usize) -> bool {use_x}\n                                          // + val: Value(Scalar(<ZST>))\n                                          // mir::Constant\n-                                         // + span: $DIR/region-subtyping-basic.rs:19:9: 19:14\n+                                         // + span: $DIR/region-subtyping-basic.rs:21:9: 21:14\n                                          // + literal: Const { ty: fn(usize) -> bool {use_x}, val: Value(Scalar(<ZST>)) }\n     }\n \n     bb6: {\n-        StorageDead(_9);                 // bb6[0]: scope 3 at $DIR/region-subtyping-basic.rs:19:17: 19:18\n-        StorageDead(_8);                 // bb6[1]: scope 3 at $DIR/region-subtyping-basic.rs:19:18: 19:19\n-        _0 = const Const(Value(Scalar(<ZST>)): ()); // bb6[2]: scope 3 at $DIR/region-subtyping-basic.rs:18:13: 20:6\n+        StorageDead(_9);                 // bb6[0]: scope 3 at $DIR/region-subtyping-basic.rs:21:17: 21:18\n+        StorageDead(_8);                 // bb6[1]: scope 3 at $DIR/region-subtyping-basic.rs:21:18: 21:19\n+        _0 = const Const(Value(Scalar(<ZST>)): ()); // bb6[2]: scope 3 at $DIR/region-subtyping-basic.rs:20:13: 22:6\n                                          // ty::Const\n                                          // + ty: ()\n                                          // + val: Value(Scalar(<ZST>))\n                                          // mir::Constant\n-                                         // + span: $DIR/region-subtyping-basic.rs:18:13: 20:6\n+                                         // + span: $DIR/region-subtyping-basic.rs:20:13: 22:6\n                                          // + literal: Const { ty: (), val: Value(Scalar(<ZST>)) }\n-        goto -> bb8;                     // bb6[3]: scope 3 at $DIR/region-subtyping-basic.rs:18:5: 22:6\n+        goto -> bb8;                     // bb6[3]: scope 3 at $DIR/region-subtyping-basic.rs:20:5: 24:6\n     }\n \n     bb7: {\n-        StorageDead(_10);                // bb7[0]: scope 3 at $DIR/region-subtyping-basic.rs:21:18: 21:19\n-        _0 = const Const(Value(Scalar(<ZST>)): ()); // bb7[1]: scope 3 at $DIR/region-subtyping-basic.rs:20:12: 22:6\n+        StorageDead(_10);                // bb7[0]: scope 3 at $DIR/region-subtyping-basic.rs:23:18: 23:19\n+        _0 = const Const(Value(Scalar(<ZST>)): ()); // bb7[1]: scope 3 at $DIR/region-subtyping-basic.rs:22:12: 24:6\n                                          // ty::Const\n                                          // + ty: ()\n                                          // + val: Value(Scalar(<ZST>))\n                                          // mir::Constant\n-                                         // + span: $DIR/region-subtyping-basic.rs:20:12: 22:6\n+                                         // + span: $DIR/region-subtyping-basic.rs:22:12: 24:6\n                                          // + literal: Const { ty: (), val: Value(Scalar(<ZST>)) }\n-        goto -> bb8;                     // bb7[2]: scope 3 at $DIR/region-subtyping-basic.rs:18:5: 22:6\n+        goto -> bb8;                     // bb7[2]: scope 3 at $DIR/region-subtyping-basic.rs:20:5: 24:6\n     }\n \n     bb8: {\n-        StorageDead(_6);                 // bb8[0]: scope 2 at $DIR/region-subtyping-basic.rs:23:1: 23:2\n-        StorageDead(_3);                 // bb8[1]: scope 1 at $DIR/region-subtyping-basic.rs:23:1: 23:2\n-        StorageDead(_2);                 // bb8[2]: scope 1 at $DIR/region-subtyping-basic.rs:23:1: 23:2\n-        StorageDead(_1);                 // bb8[3]: scope 0 at $DIR/region-subtyping-basic.rs:23:1: 23:2\n-        StorageDead(_7);                 // bb8[4]: scope 0 at $DIR/region-subtyping-basic.rs:23:1: 23:2\n-        return;                          // bb8[5]: scope 0 at $DIR/region-subtyping-basic.rs:23:2: 23:2\n+        StorageDead(_6);                 // bb8[0]: scope 2 at $DIR/region-subtyping-basic.rs:25:1: 25:2\n+        StorageDead(_3);                 // bb8[1]: scope 1 at $DIR/region-subtyping-basic.rs:25:1: 25:2\n+        StorageDead(_2);                 // bb8[2]: scope 1 at $DIR/region-subtyping-basic.rs:25:1: 25:2\n+        StorageDead(_1);                 // bb8[3]: scope 0 at $DIR/region-subtyping-basic.rs:25:1: 25:2\n+        StorageDead(_7);                 // bb8[4]: scope 0 at $DIR/region-subtyping-basic.rs:25:1: 25:2\n+        return;                          // bb8[5]: scope 0 at $DIR/region-subtyping-basic.rs:25:2: 25:2\n     }\n }"}, {"sha": "7799f20d974bcfbb2bf8235b941c8f8c47357262", "filename": "src/test/mir-opt/storage_ranges/rustc.main.nll.0.mir", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7ced01a730e8fc1bae2f8d4369c26812c0484da4/src%2Ftest%2Fmir-opt%2Fstorage_ranges%2Frustc.main.nll.0.mir", "raw_url": "https://github.com/rust-lang/rust/raw/7ced01a730e8fc1bae2f8d4369c26812c0484da4/src%2Ftest%2Fmir-opt%2Fstorage_ranges%2Frustc.main.nll.0.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fstorage_ranges%2Frustc.main.nll.0.mir?ref=7ced01a730e8fc1bae2f8d4369c26812c0484da4", "patch": "@@ -7,15 +7,16 @@\n | Inferred Region Values\n | '_#0r | U0 | {bb0[0..=22], '_#0r, '_#1r}\n | '_#1r | U0 | {bb0[0..=22], '_#1r}\n-| '_#2r | U0 | {bb0[10..=11]}\n-| '_#3r | U0 | {bb0[11]}\n+| '_#2r | U0 | {}\n+| '_#3r | U0 | {bb0[10..=11]}\n+| '_#4r | U0 | {bb0[11]}\n |\n | Inference Constraints\n | '_#0r live at {bb0[0..=22]}\n | '_#1r live at {bb0[0..=22]}\n-| '_#2r live at {bb0[10]}\n-| '_#3r live at {bb0[11]}\n-| '_#2r: '_#3r due to Assignment at Single(bb0[10])\n+| '_#3r live at {bb0[10]}\n+| '_#4r live at {bb0[11]}\n+| '_#3r: '_#4r due to Assignment at Single(bb0[10])\n |\n fn main() -> () {\n     let mut _0: ();                      // return place in scope 0 at $DIR/storage_ranges.rs:3:11: 3:11"}, {"sha": "da584e8ad4e0d2dd1907ca5491fd4158073381c9", "filename": "src/test/ui/async-await/multiple-lifetimes/ret-impl-trait-no-fg.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7ced01a730e8fc1bae2f8d4369c26812c0484da4/src%2Ftest%2Fui%2Fasync-await%2Fmultiple-lifetimes%2Fret-impl-trait-no-fg.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7ced01a730e8fc1bae2f8d4369c26812c0484da4/src%2Ftest%2Fui%2Fasync-await%2Fmultiple-lifetimes%2Fret-impl-trait-no-fg.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fmultiple-lifetimes%2Fret-impl-trait-no-fg.stderr?ref=7ced01a730e8fc1bae2f8d4369c26812c0484da4", "patch": "@@ -34,7 +34,7 @@ LL | |     (a, b)\n LL | | }\n    | |_^\n    |\n-   = note: hidden type `(&u8, &u8)` captures lifetime '_#4r\n+   = note: hidden type `(&u8, &u8)` captures lifetime '_#5r\n \n error[E0700]: hidden type for `impl Trait` captures lifetime that does not appear in bounds\n   --> $DIR/ret-impl-trait-no-fg.rs:9:1\n@@ -48,7 +48,7 @@ LL | |     (a, b)\n LL | | }\n    | |_^\n    |\n-   = note: hidden type `(&u8, &u8)` captures lifetime '_#5r\n+   = note: hidden type `(&u8, &u8)` captures lifetime '_#6r\n \n error: aborting due to 5 previous errors\n "}, {"sha": "fc13bb98bd2c95c1423d9a908ebc7b3a9432152c", "filename": "src/test/ui/consts/const-ptr-unique-rpass.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7ced01a730e8fc1bae2f8d4369c26812c0484da4/src%2Ftest%2Fui%2Fconsts%2Fconst-ptr-unique-rpass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ced01a730e8fc1bae2f8d4369c26812c0484da4/src%2Ftest%2Fui%2Fconsts%2Fconst-ptr-unique-rpass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-ptr-unique-rpass.rs?ref=7ced01a730e8fc1bae2f8d4369c26812c0484da4", "patch": "@@ -8,9 +8,9 @@ use test::black_box as b; // prevent promotion of the argument and const-propaga\n use std::ptr::Unique;\n \n \n-const PTR: *mut u32 = Unique::empty().as_ptr();\n+const PTR: *mut u32 = Unique::dangling().as_ptr();\n \n pub fn main() {\n     // Be super-extra paranoid and cast the fn items to fn pointers before blackboxing them.\n-    assert_eq!(PTR, b::<fn() -> _>(Unique::<u32>::empty)().as_ptr());\n+    assert_eq!(PTR, b::<fn() -> _>(Unique::<u32>::dangling)().as_ptr());\n }"}, {"sha": "90803a0adb01bf8cb1083f1fd396eb2a5aec79d9", "filename": "src/test/ui/hrtb/due-to-where-clause.nll.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7ced01a730e8fc1bae2f8d4369c26812c0484da4/src%2Ftest%2Fui%2Fhrtb%2Fdue-to-where-clause.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7ced01a730e8fc1bae2f8d4369c26812c0484da4/src%2Ftest%2Fui%2Fhrtb%2Fdue-to-where-clause.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhrtb%2Fdue-to-where-clause.nll.stderr?ref=7ced01a730e8fc1bae2f8d4369c26812c0484da4", "patch": "@@ -2,7 +2,7 @@ error: higher-ranked subtype error\n   --> $DIR/due-to-where-clause.rs:2:5\n    |\n LL |     test::<FooS>(&mut 42);\n-   |     ^^^^^^^^^^^^^^^^^^^^^\n+   |     ^^^^^^^^^^^^\n \n error: aborting due to previous error\n "}, {"sha": "ee2bb62e2bb5753877833f84b7479480b9469d84", "filename": "src/test/ui/if/if-without-block.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7ced01a730e8fc1bae2f8d4369c26812c0484da4/src%2Ftest%2Fui%2Fif%2Fif-without-block.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7ced01a730e8fc1bae2f8d4369c26812c0484da4/src%2Ftest%2Fui%2Fif%2Fif-without-block.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fif%2Fif-without-block.stderr?ref=7ced01a730e8fc1bae2f8d4369c26812c0484da4", "patch": "@@ -6,6 +6,8 @@ LL |     if 5 == {\n ...\n LL | }\n    | ^ expected `{`\n+   |\n+   = help: maybe you forgot the right operand of the condition?\n \n error: aborting due to previous error\n "}, {"sha": "129af80ce4a629616ad632650692cdc115701e20", "filename": "src/test/ui/impl-trait/multiple-lifetimes/ordinary-bounds-unrelated.nll.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7ced01a730e8fc1bae2f8d4369c26812c0484da4/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Fordinary-bounds-unrelated.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7ced01a730e8fc1bae2f8d4369c26812c0484da4/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Fordinary-bounds-unrelated.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Fordinary-bounds-unrelated.nll.stderr?ref=7ced01a730e8fc1bae2f8d4369c26812c0484da4", "patch": "@@ -4,7 +4,7 @@ error[E0700]: hidden type for `impl Trait` captures lifetime that does not appea\n LL | fn upper_bounds<'a, 'b, 'c, 'd, 'e>(a: Ordinary<'a>, b: Ordinary<'b>) -> impl Trait<'d, 'e>\n    |                                                                          ^^^^^^^^^^^^^^^^^^\n    |\n-   = note: hidden type `Ordinary<'_>` captures lifetime '_#8r\n+   = note: hidden type `Ordinary<'_>` captures lifetime '_#9r\n \n error: aborting due to previous error\n "}, {"sha": "de6d5edcae511d9ffd631f7c675ca707c6b05b43", "filename": "src/test/ui/impl-trait/multiple-lifetimes/ordinary-bounds-unsuited.nll.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7ced01a730e8fc1bae2f8d4369c26812c0484da4/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Fordinary-bounds-unsuited.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7ced01a730e8fc1bae2f8d4369c26812c0484da4/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Fordinary-bounds-unsuited.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Fordinary-bounds-unsuited.nll.stderr?ref=7ced01a730e8fc1bae2f8d4369c26812c0484da4", "patch": "@@ -4,7 +4,7 @@ error[E0700]: hidden type for `impl Trait` captures lifetime that does not appea\n LL | fn upper_bounds<'a, 'b>(a: Ordinary<'a>, b: Ordinary<'b>) -> impl Trait<'a, 'b>\n    |                                                              ^^^^^^^^^^^^^^^^^^\n    |\n-   = note: hidden type `Ordinary<'_>` captures lifetime '_#5r\n+   = note: hidden type `Ordinary<'_>` captures lifetime '_#6r\n \n error: aborting due to previous error\n "}, {"sha": "6bfd18de18c6ae995e7eff2d76910eb0706df8fc", "filename": "src/test/ui/nll/issue-68550.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/7ced01a730e8fc1bae2f8d4369c26812c0484da4/src%2Ftest%2Fui%2Fnll%2Fissue-68550.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ced01a730e8fc1bae2f8d4369c26812c0484da4/src%2Ftest%2Fui%2Fnll%2Fissue-68550.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fissue-68550.rs?ref=7ced01a730e8fc1bae2f8d4369c26812c0484da4", "patch": "@@ -0,0 +1,15 @@\n+// Regression test for issue #68550.\n+//\n+// The `&'static A:` where clause was triggering\n+// ICEs because it wound up being compiled to reference\n+// the `'empty(U0)` region.\n+\n+fn run<'a, A>(x: A)\n+where\n+    A: 'static,\n+    &'static A: ,\n+{\n+    let _: &'a A = &x; //~ ERROR `x` does not live long enough\n+}\n+\n+fn main() {}"}, {"sha": "e234ebb04e16a5ea874c7482a3cf11da6bc03dd5", "filename": "src/test/ui/nll/issue-68550.stderr", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/7ced01a730e8fc1bae2f8d4369c26812c0484da4/src%2Ftest%2Fui%2Fnll%2Fissue-68550.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7ced01a730e8fc1bae2f8d4369c26812c0484da4/src%2Ftest%2Fui%2Fnll%2Fissue-68550.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fissue-68550.stderr?ref=7ced01a730e8fc1bae2f8d4369c26812c0484da4", "patch": "@@ -0,0 +1,16 @@\n+error[E0597]: `x` does not live long enough\n+  --> $DIR/issue-68550.rs:12:20\n+   |\n+LL | fn run<'a, A>(x: A)\n+   |        -- lifetime `'a` defined here\n+...\n+LL |     let _: &'a A = &x;\n+   |            -----   ^^ borrowed value does not live long enough\n+   |            |\n+   |            type annotation requires that `x` is borrowed for `'a`\n+LL | }\n+   | - `x` dropped here while still borrowed\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0597`."}, {"sha": "d3964a7f515deee842f9d71fa08a2f93a2fe8dcf", "filename": "src/test/ui/nll/relate_tys/impl-fn-ignore-binder-via-bottom.rs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/7ced01a730e8fc1bae2f8d4369c26812c0484da4/src%2Ftest%2Fui%2Fnll%2Frelate_tys%2Fimpl-fn-ignore-binder-via-bottom.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ced01a730e8fc1bae2f8d4369c26812c0484da4/src%2Ftest%2Fui%2Fnll%2Frelate_tys%2Fimpl-fn-ignore-binder-via-bottom.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Frelate_tys%2Fimpl-fn-ignore-binder-via-bottom.rs?ref=7ced01a730e8fc1bae2f8d4369c26812c0484da4", "patch": "@@ -0,0 +1,36 @@\n+// Test that the NLL solver cannot find a solution\n+// for `exists<R1> { forall<R1> { R2: R1 } }`.\n+//\n+// In this test, the impl should match `fn(T)` for some `T`,\n+// but we ask it to match `for<'a> fn(&'a ())`. Due to argument\n+// contravariance, this effectively requires a `T = &'b ()` where\n+// `forall<'a> { 'a: 'b }`. Therefore, we get an error.\n+//\n+// Note the use of `-Zno-leak-check` and `feature(nll)` here. These\n+// are presently required in order to skip the leak-check errors.\n+//\n+// c.f. Issue #57642.\n+//\n+// compile-flags:-Zno-leak-check\n+\n+#![feature(nll)]\n+\n+trait Y {\n+    type F;\n+    fn make_f() -> Self::F;\n+}\n+\n+impl<T> Y for fn(T) {\n+    type F = fn(T);\n+\n+    fn make_f() -> Self::F {\n+        |_| {}\n+    }\n+}\n+\n+fn main() {\n+    let _x = <fn(&())>::make_f();\n+    //~^ higher-ranked subtype error\n+    //~| higher-ranked subtype error\n+    //~| higher-ranked subtype error\n+}"}, {"sha": "70fb877d716899e276f49c13f99fe6f4c8b15bdc", "filename": "src/test/ui/nll/relate_tys/impl-fn-ignore-binder-via-bottom.stderr", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/7ced01a730e8fc1bae2f8d4369c26812c0484da4/src%2Ftest%2Fui%2Fnll%2Frelate_tys%2Fimpl-fn-ignore-binder-via-bottom.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7ced01a730e8fc1bae2f8d4369c26812c0484da4/src%2Ftest%2Fui%2Fnll%2Frelate_tys%2Fimpl-fn-ignore-binder-via-bottom.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Frelate_tys%2Fimpl-fn-ignore-binder-via-bottom.stderr?ref=7ced01a730e8fc1bae2f8d4369c26812c0484da4", "patch": "@@ -0,0 +1,20 @@\n+error: higher-ranked subtype error\n+  --> $DIR/impl-fn-ignore-binder-via-bottom.rs:32:14\n+   |\n+LL |     let _x = <fn(&())>::make_f();\n+   |              ^^^^^^^^^^^^^^^^^^^\n+\n+error: higher-ranked subtype error\n+  --> $DIR/impl-fn-ignore-binder-via-bottom.rs:32:14\n+   |\n+LL |     let _x = <fn(&())>::make_f();\n+   |              ^^^^^^^^^^^^^^^^^^^\n+\n+error: higher-ranked subtype error\n+  --> $DIR/impl-fn-ignore-binder-via-bottom.rs:32:14\n+   |\n+LL |     let _x = <fn(&())>::make_f();\n+   |              ^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 3 previous errors\n+"}, {"sha": "298a6ef7ab3c5b85551b5621b91a7eed9cce79ca", "filename": "src/test/ui/nll/type-check-pointer-comparisons.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7ced01a730e8fc1bae2f8d4369c26812c0484da4/src%2Ftest%2Fui%2Fnll%2Ftype-check-pointer-comparisons.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ced01a730e8fc1bae2f8d4369c26812c0484da4/src%2Ftest%2Fui%2Fnll%2Ftype-check-pointer-comparisons.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Ftype-check-pointer-comparisons.rs?ref=7ced01a730e8fc1bae2f8d4369c26812c0484da4", "patch": "@@ -21,13 +21,13 @@ fn compare_fn_ptr<'a, 'b, 'c>(f: fn(&'c mut &'a i32), g: fn(&'c mut &'b i32)) {\n }\n \n fn compare_hr_fn_ptr<'a>(f: fn(&'a i32), g: fn(&i32)) {\n-    // Ideally this should compile with the operands swapped as well, but HIR\n-    // type checking prevents it (and stops compilation) for now.\n-    f == g; // OK\n+    f == g;\n+    //~^ ERROR higher-ranked subtype error\n }\n \n fn compare_const_fn_ptr<'a>(f: *const fn(&'a i32), g: *const fn(&i32)) {\n-    f == g; // OK\n+    f == g;\n+    //~^ ERROR higher-ranked subtype error\n }\n \n fn main() {}"}, {"sha": "0fc7480260fdb96eb7ee83663f1590debb079ff0", "filename": "src/test/ui/nll/type-check-pointer-comparisons.stderr", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7ced01a730e8fc1bae2f8d4369c26812c0484da4/src%2Ftest%2Fui%2Fnll%2Ftype-check-pointer-comparisons.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7ced01a730e8fc1bae2f8d4369c26812c0484da4/src%2Ftest%2Fui%2Fnll%2Ftype-check-pointer-comparisons.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Ftype-check-pointer-comparisons.stderr?ref=7ced01a730e8fc1bae2f8d4369c26812c0484da4", "patch": "@@ -76,5 +76,17 @@ LL |     f == g;\n \n help: `'a` and `'b` must be the same: replace one with the other\n \n-error: aborting due to 6 previous errors\n+error: higher-ranked subtype error\n+  --> $DIR/type-check-pointer-comparisons.rs:24:5\n+   |\n+LL |     f == g;\n+   |     ^^^^^^\n+\n+error: higher-ranked subtype error\n+  --> $DIR/type-check-pointer-comparisons.rs:29:5\n+   |\n+LL |     f == g;\n+   |     ^^^^^^\n+\n+error: aborting due to 8 previous errors\n "}]}