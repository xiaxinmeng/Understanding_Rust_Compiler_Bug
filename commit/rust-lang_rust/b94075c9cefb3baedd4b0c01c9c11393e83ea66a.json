{"sha": "b94075c9cefb3baedd4b0c01c9c11393e83ea66a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI5NDA3NWM5Y2VmYjNiYWVkZDRiMGMwMWM5YzExMzkzZTgzZWE2NmE=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-09-19T17:00:21Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-09-19T17:00:21Z"}, "message": "rollup merge of #17314 : eddyb/span-no-gc", "tree": {"sha": "a9a3a4450b20356caa2048b03491944560f14df0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a9a3a4450b20356caa2048b03491944560f14df0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b94075c9cefb3baedd4b0c01c9c11393e83ea66a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b94075c9cefb3baedd4b0c01c9c11393e83ea66a", "html_url": "https://github.com/rust-lang/rust/commit/b94075c9cefb3baedd4b0c01c9c11393e83ea66a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b94075c9cefb3baedd4b0c01c9c11393e83ea66a/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "129aff7d97432d326891ef23397e814841cc754a", "url": "https://api.github.com/repos/rust-lang/rust/commits/129aff7d97432d326891ef23397e814841cc754a", "html_url": "https://github.com/rust-lang/rust/commit/129aff7d97432d326891ef23397e814841cc754a"}, {"sha": "f1a8f53cf10c2a68342aac70c5a706a865300bb4", "url": "https://api.github.com/repos/rust-lang/rust/commits/f1a8f53cf10c2a68342aac70c5a706a865300bb4", "html_url": "https://github.com/rust-lang/rust/commit/f1a8f53cf10c2a68342aac70c5a706a865300bb4"}], "stats": {"total": 279, "additions": 145, "deletions": 134}, "files": [{"sha": "a95eeb3c97dc2c4dfff6530d0a4bbf64df251d6c", "filename": "src/grammar/verify.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b94075c9cefb3baedd4b0c01c9c11393e83ea66a/src%2Fgrammar%2Fverify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b94075c9cefb3baedd4b0c01c9c11393e83ea66a/src%2Fgrammar%2Fverify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fgrammar%2Fverify.rs?ref=b94075c9cefb3baedd4b0c01c9c11393e83ea66a", "patch": "@@ -211,7 +211,7 @@ fn parse_antlr_token(s: &str, tokens: &HashMap<String, Token>) -> TokenAndSpan {\n     let sp = syntax::codemap::Span {\n         lo: syntax::codemap::BytePos(from_str::<u32>(start).unwrap() - offset),\n         hi: syntax::codemap::BytePos(from_str::<u32>(end).unwrap() + 1),\n-        expn_info: None\n+        expn_id: syntax::codemap::NO_EXPANSION\n     };\n \n     TokenAndSpan {"}, {"sha": "9df2c635475c02213811af3c6bf581328b267eaa", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b94075c9cefb3baedd4b0c01c9c11393e83ea66a/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b94075c9cefb3baedd4b0c01c9c11393e83ea66a/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=b94075c9cefb3baedd4b0c01c9c11393e83ea66a", "patch": "@@ -42,7 +42,7 @@ use syntax::abi;\n use syntax::ast_map;\n use syntax::attr::AttrMetaMethods;\n use syntax::attr;\n-use syntax::codemap::Span;\n+use syntax::codemap::{Span, NO_EXPANSION};\n use syntax::parse::token;\n use syntax::{ast, ast_util, visit};\n use syntax::ptr::P;\n@@ -1491,7 +1491,7 @@ impl LintPass for Stability {\n \n     fn check_expr(&mut self, cx: &Context, e: &ast::Expr) {\n         // if the expression was produced by a macro expansion,\n-        if e.span.expn_info.is_some() { return }\n+        if e.span.expn_id != NO_EXPANSION { return }\n \n         let id = match e.node {\n             ast::ExprPath(..) | ast::ExprStruct(..) => {"}, {"sha": "8dfb53a396b48d43616eeec087f78d1a29cfa609", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b94075c9cefb3baedd4b0c01c9c11393e83ea66a/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b94075c9cefb3baedd4b0c01c9c11393e83ea66a/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=b94075c9cefb3baedd4b0c01c9c11393e83ea66a", "patch": "@@ -2030,7 +2030,7 @@ impl fake_ext_ctxt for parse::ParseSess {\n         codemap::Span {\n             lo: codemap::BytePos(0),\n             hi: codemap::BytePos(0),\n-            expn_info: None\n+            expn_id: codemap::NO_EXPANSION\n         }\n     }\n     fn ident_of(&self, st: &str) -> ast::Ident {"}, {"sha": "bfc158d9df82689209a9ffc5bac1afe24a08e054", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b94075c9cefb3baedd4b0c01c9c11393e83ea66a/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b94075c9cefb3baedd4b0c01c9c11393e83ea66a/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=b94075c9cefb3baedd4b0c01c9c11393e83ea66a", "patch": "@@ -1509,11 +1509,12 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n                     sp, \"not all control paths return a value\");\n                 if ends_with_stmt {\n                     let last_stmt = body.stmts.last().unwrap();\n-                    let original_span = original_sp(last_stmt.span, sp);\n+                    let original_span = original_sp(self.ir.tcx.sess.codemap(),\n+                                                    last_stmt.span, sp);\n                     let span_semicolon = Span {\n                         lo: original_span.hi - BytePos(1),\n                         hi: original_span.hi,\n-                        expn_info: original_span.expn_info\n+                        expn_id: original_span.expn_id\n                     };\n                     self.ir.tcx.sess.span_note(\n                         span_semicolon, \"consider removing this semicolon:\");"}, {"sha": "91d6569c076496bd4e2cf6babf11fd063c382614", "filename": "src/librustc/middle/save/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b94075c9cefb3baedd4b0c01c9c11393e83ea66a/src%2Flibrustc%2Fmiddle%2Fsave%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b94075c9cefb3baedd4b0c01c9c11393e83ea66a/src%2Flibrustc%2Fmiddle%2Fsave%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fsave%2Fmod.rs?ref=b94075c9cefb3baedd4b0c01c9c11393e83ea66a", "patch": "@@ -71,7 +71,7 @@ fn escape(s: String) -> String {\n \n // If the expression is a macro expansion or other generated code, run screaming and don't index.\n fn generated_code(span: Span) -> bool {\n-    span.expn_info.is_some() || span  == DUMMY_SP\n+    span.expn_id != NO_EXPANSION || span  == DUMMY_SP\n }\n \n struct DxrVisitor<'l, 'tcx: 'l> {"}, {"sha": "1086dc608a352abf163db2a09c223e310b19da55", "filename": "src/librustc/middle/save/span_utils.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b94075c9cefb3baedd4b0c01c9c11393e83ea66a/src%2Flibrustc%2Fmiddle%2Fsave%2Fspan_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b94075c9cefb3baedd4b0c01c9c11393e83ea66a/src%2Flibrustc%2Fmiddle%2Fsave%2Fspan_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fsave%2Fspan_utils.rs?ref=b94075c9cefb3baedd4b0c01c9c11393e83ea66a", "patch": "@@ -57,7 +57,7 @@ impl<'a> SpanUtils<'a> {\n                 Some(Span {\n                     lo: base + self.sess.codemap().lookup_byte_offset(sub.lo).pos,\n                     hi: base + self.sess.codemap().lookup_byte_offset(sub.hi).pos,\n-                    expn_info: None,\n+                    expn_id: NO_EXPANSION,\n                 })\n             }\n         }"}, {"sha": "81f5209ccd90b5b42dd15848ba2a6bd214358a49", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b94075c9cefb3baedd4b0c01c9c11393e83ea66a/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b94075c9cefb3baedd4b0c01c9c11393e83ea66a/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=b94075c9cefb3baedd4b0c01c9c11393e83ea66a", "patch": "@@ -1370,7 +1370,7 @@ mod test {\n                 inner: Span {\n                     lo: BytePos(11),\n                     hi: BytePos(19),\n-                    expn_info: None,\n+                    expn_id: NO_EXPANSION,\n                 },\n                 view_items: Vec::new(),\n                 items: Vec::new(),\n@@ -1380,7 +1380,7 @@ mod test {\n             span: Span {\n                 lo: BytePos(10),\n                 hi: BytePos(20),\n-                expn_info: None,\n+                expn_id: NO_EXPANSION,\n             },\n             exported_macros: Vec::new(),\n         };"}, {"sha": "9072889463cd631cde0e0e170213953ae1bcb203", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 33, "deletions": 12, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/b94075c9cefb3baedd4b0c01c9c11393e83ea66a/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b94075c9cefb3baedd4b0c01c9c11393e83ea66a/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=b94075c9cefb3baedd4b0c01c9c11393e83ea66a", "patch": "@@ -25,7 +25,6 @@ source code snippets, etc.\n \n use serialize::{Encodable, Decodable, Encoder, Decoder};\n use std::cell::RefCell;\n-use std::gc::Gc;\n use std::rc::Rc;\n \n pub trait Pos {\n@@ -93,10 +92,10 @@ pub struct Span {\n     pub hi: BytePos,\n     /// Information about where the macro came from, if this piece of\n     /// code was created by a macro expansion.\n-    pub expn_info: Option<Gc<ExpnInfo>>\n+    pub expn_id: ExpnId\n }\n \n-pub static DUMMY_SP: Span = Span { lo: BytePos(0), hi: BytePos(0), expn_info: None };\n+pub static DUMMY_SP: Span = Span { lo: BytePos(0), hi: BytePos(0), expn_id: NO_EXPANSION };\n \n #[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub struct Spanned<T> {\n@@ -140,17 +139,19 @@ pub fn dummy_spanned<T>(t: T) -> Spanned<T> {\n \n /* assuming that we're not in macro expansion */\n pub fn mk_sp(lo: BytePos, hi: BytePos) -> Span {\n-    Span {lo: lo, hi: hi, expn_info: None}\n+    Span {lo: lo, hi: hi, expn_id: NO_EXPANSION}\n }\n \n /// Return the span itself if it doesn't come from a macro expansion,\n /// otherwise return the call site span up to the `enclosing_sp` by\n /// following the `expn_info` chain.\n-pub fn original_sp(sp: Span, enclosing_sp: Span) -> Span {\n-    match (sp.expn_info, enclosing_sp.expn_info) {\n+pub fn original_sp(cm: &CodeMap, sp: Span, enclosing_sp: Span) -> Span {\n+    let call_site1 = cm.with_expn_info(sp.expn_id, |ei| ei.map(|ei| ei.call_site));\n+    let call_site2 = cm.with_expn_info(enclosing_sp.expn_id, |ei| ei.map(|ei| ei.call_site));\n+    match (call_site1, call_site2) {\n         (None, _) => sp,\n-        (Some(expn1), Some(expn2)) if expn1.call_site == expn2.call_site => sp,\n-        (Some(expn1), _) => original_sp(expn1.call_site, enclosing_sp),\n+        (Some(call_site1), Some(call_site2)) if call_site1 == call_site2 => sp,\n+        (Some(call_site1), _) => original_sp(cm, call_site1, enclosing_sp),\n     }\n }\n \n@@ -222,6 +223,11 @@ pub struct ExpnInfo {\n     pub callee: NameAndSpan\n }\n \n+#[deriving(PartialEq, Eq, Clone, Show, Hash)]\n+pub struct ExpnId(u32);\n+\n+pub static NO_EXPANSION: ExpnId = ExpnId(-1);\n+\n pub type FileName = String;\n \n pub struct FileLines {\n@@ -299,13 +305,15 @@ impl FileMap {\n }\n \n pub struct CodeMap {\n-    pub files: RefCell<Vec<Rc<FileMap>>>\n+    pub files: RefCell<Vec<Rc<FileMap>>>,\n+    expansions: RefCell<Vec<ExpnInfo>>\n }\n \n impl CodeMap {\n     pub fn new() -> CodeMap {\n         CodeMap {\n             files: RefCell::new(Vec::new()),\n+            expansions: RefCell::new(Vec::new()),\n         }\n     }\n \n@@ -527,6 +535,19 @@ impl CodeMap {\n             col: chpos - linechpos\n         }\n     }\n+\n+    pub fn record_expansion(&self, expn_info: ExpnInfo) -> ExpnId {\n+        let mut expansions = self.expansions.borrow_mut();\n+        expansions.push(expn_info);\n+        ExpnId(expansions.len().to_u32().expect(\"too many ExpnInfo's!\") - 1)\n+    }\n+\n+    pub fn with_expn_info<T>(&self, id: ExpnId, f: |Option<&ExpnInfo>| -> T) -> T {\n+        match id {\n+            NO_EXPANSION => f(None),\n+            ExpnId(i) => f(Some(&(*self.expansions.borrow())[i as uint]))\n+        }\n+    }\n }\n \n #[cfg(test)]\n@@ -665,7 +686,7 @@ mod test {\n     fn t7() {\n         // Test span_to_lines for a span ending at the end of filemap\n         let cm = init_code_map();\n-        let span = Span {lo: BytePos(12), hi: BytePos(23), expn_info: None};\n+        let span = Span {lo: BytePos(12), hi: BytePos(23), expn_id: NO_EXPANSION};\n         let file_lines = cm.span_to_lines(span);\n \n         assert_eq!(file_lines.file.name, \"blork.rs\".to_string());\n@@ -677,7 +698,7 @@ mod test {\n     fn t8() {\n         // Test span_to_snippet for a span ending at the end of filemap\n         let cm = init_code_map();\n-        let span = Span {lo: BytePos(12), hi: BytePos(23), expn_info: None};\n+        let span = Span {lo: BytePos(12), hi: BytePos(23), expn_id: NO_EXPANSION};\n         let snippet = cm.span_to_snippet(span);\n \n         assert_eq!(snippet, Some(\"second line\".to_string()));\n@@ -687,7 +708,7 @@ mod test {\n     fn t9() {\n         // Test span_to_str for a span ending at the end of filemap\n         let cm = init_code_map();\n-        let span = Span {lo: BytePos(12), hi: BytePos(23), expn_info: None};\n+        let span = Span {lo: BytePos(12), hi: BytePos(23), expn_id: NO_EXPANSION};\n         let sstr =  cm.span_to_string(span);\n \n         assert_eq!(sstr, \"blork.rs:2:1: 2:12\".to_string());"}, {"sha": "f33c768d647575607a821aad4a6dc364604558bc", "filename": "src/libsyntax/diagnostic.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/b94075c9cefb3baedd4b0c01c9c11393e83ea66a/src%2Flibsyntax%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b94075c9cefb3baedd4b0c01c9c11393e83ea66a/src%2Flibsyntax%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic.rs?ref=b94075c9cefb3baedd4b0c01c9c11393e83ea66a", "patch": "@@ -389,7 +389,7 @@ fn emit(dst: &mut EmitterWriter, cm: &codemap::CodeMap, rsp: RenderSpan,\n         // we want to tell compiletest/runtest to look at the last line of the\n         // span (since `custom_highlight_lines` displays an arrow to the end of\n         // the span)\n-        let span_end = Span { lo: sp.hi, hi: sp.hi, expn_info: sp.expn_info};\n+        let span_end = Span { lo: sp.hi, hi: sp.hi, expn_id: sp.expn_id};\n         let ses = cm.span_to_string(span_end);\n         try!(print_diagnostic(dst, ses.as_slice(), lvl, msg, code));\n         if rsp.is_full_span() {\n@@ -523,24 +523,24 @@ fn print_macro_backtrace(w: &mut EmitterWriter,\n                          cm: &codemap::CodeMap,\n                          sp: Span)\n                          -> io::IoResult<()> {\n-    for ei in sp.expn_info.iter() {\n-        let ss = ei.callee\n-                   .span\n-                   .as_ref()\n-                   .map_or(\"\".to_string(), |span| cm.span_to_string(*span));\n-        let (pre, post) = match ei.callee.format {\n-            codemap::MacroAttribute => (\"#[\", \"]\"),\n-            codemap::MacroBang => (\"\", \"!\")\n-        };\n-        try!(print_diagnostic(w, ss.as_slice(), Note,\n-                              format!(\"in expansion of {}{}{}\", pre,\n-                                      ei.callee.name,\n-                                      post).as_slice(), None));\n-        let ss = cm.span_to_string(ei.call_site);\n-        try!(print_diagnostic(w, ss.as_slice(), Note, \"expansion site\", None));\n-        try!(print_macro_backtrace(w, cm, ei.call_site));\n-    }\n-    Ok(())\n+    let cs = try!(cm.with_expn_info(sp.expn_id, |expn_info| match expn_info {\n+        Some(ei) => {\n+            let ss = ei.callee.span.map_or(String::new(), |span| cm.span_to_string(span));\n+            let (pre, post) = match ei.callee.format {\n+                codemap::MacroAttribute => (\"#[\", \"]\"),\n+                codemap::MacroBang => (\"\", \"!\")\n+            };\n+            try!(print_diagnostic(w, ss.as_slice(), Note,\n+                                  format!(\"in expansion of {}{}{}\", pre,\n+                                          ei.callee.name,\n+                                          post).as_slice(), None));\n+            let ss = cm.span_to_string(ei.call_site);\n+            try!(print_diagnostic(w, ss.as_slice(), Note, \"expansion site\", None));\n+            Ok(Some(ei.call_site))\n+        }\n+        None => Ok(None)\n+    }));\n+    cs.map_or(Ok(()), |call_site| print_macro_backtrace(w, cm, call_site))\n }\n \n pub fn expect<T>(diag: &SpanHandler, opt: Option<T>, msg: || -> String) -> T {"}, {"sha": "3ffe1419c0b7a1255c890a6ed6de8aa044c5e9b3", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 55, "deletions": 20, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/b94075c9cefb3baedd4b0c01c9c11393e83ea66a/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b94075c9cefb3baedd4b0c01c9c11393e83ea66a/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=b94075c9cefb3baedd4b0c01c9c11393e83ea66a", "patch": "@@ -11,7 +11,7 @@\n use ast;\n use ast::Name;\n use codemap;\n-use codemap::{CodeMap, Span, ExpnInfo};\n+use codemap::{CodeMap, Span, ExpnId, ExpnInfo, NO_EXPANSION};\n use ext;\n use ext::expand;\n use parse;\n@@ -24,7 +24,6 @@ use ext::mtwt;\n use fold::Folder;\n \n use std::collections::HashMap;\n-use std::gc::{Gc, GC};\n use std::rc::Rc;\n \n // new-style macro! tt code:\n@@ -452,7 +451,7 @@ fn initial_syntax_expander_table() -> SyntaxEnv {\n pub struct ExtCtxt<'a> {\n     pub parse_sess: &'a parse::ParseSess,\n     pub cfg: ast::CrateConfig,\n-    pub backtrace: Option<Gc<ExpnInfo>>,\n+    pub backtrace: ExpnId,\n     pub ecfg: expand::ExpansionConfig,\n \n     pub mod_path: Vec<ast::Ident> ,\n@@ -468,7 +467,7 @@ impl<'a> ExtCtxt<'a> {\n         ExtCtxt {\n             parse_sess: parse_sess,\n             cfg: cfg,\n-            backtrace: None,\n+            backtrace: NO_EXPANSION,\n             mod_path: Vec::new(),\n             ecfg: ecfg,\n             trace_mac: false,\n@@ -496,13 +495,49 @@ impl<'a> ExtCtxt<'a> {\n     pub fn parse_sess(&self) -> &'a parse::ParseSess { self.parse_sess }\n     pub fn cfg(&self) -> ast::CrateConfig { self.cfg.clone() }\n     pub fn call_site(&self) -> Span {\n-        match self.backtrace {\n+        self.codemap().with_expn_info(self.backtrace, |ei| match ei {\n             Some(expn_info) => expn_info.call_site,\n             None => self.bug(\"missing top span\")\n-        }\n+        })\n     }\n     pub fn print_backtrace(&self) { }\n-    pub fn backtrace(&self) -> Option<Gc<ExpnInfo>> { self.backtrace }\n+    pub fn backtrace(&self) -> ExpnId { self.backtrace }\n+    pub fn original_span(&self) -> Span {\n+        let mut expn_id = self.backtrace;\n+        let mut call_site = None;\n+        loop {\n+            match self.codemap().with_expn_info(expn_id, |ei| ei.map(|ei| ei.call_site)) {\n+                None => break,\n+                Some(cs) => {\n+                    call_site = Some(cs);\n+                    expn_id = cs.expn_id;\n+                }\n+            }\n+        }\n+        call_site.expect(\"missing expansion backtrace\")\n+    }\n+    pub fn original_span_in_file(&self) -> Span {\n+        let mut expn_id = self.backtrace;\n+        let mut call_site = None;\n+        loop {\n+            let expn_info = self.codemap().with_expn_info(expn_id, |ei| {\n+                ei.map(|ei| (ei.call_site, ei.callee.name.as_slice() == \"include\"))\n+            });\n+            match expn_info {\n+                None => break,\n+                Some((cs, is_include)) => {\n+                    if is_include {\n+                        // Don't recurse into file using \"include!\".\n+                        break;\n+                    }\n+                    call_site = Some(cs);\n+                    expn_id = cs.expn_id;\n+                }\n+            }\n+        }\n+        call_site.expect(\"missing expansion backtrace\")\n+    }\n+\n     pub fn mod_push(&mut self, i: ast::Ident) { self.mod_path.push(i); }\n     pub fn mod_pop(&mut self) { self.mod_path.pop().unwrap(); }\n     pub fn mod_path(&self) -> Vec<ast::Ident> {\n@@ -511,22 +546,22 @@ impl<'a> ExtCtxt<'a> {\n         v.extend(self.mod_path.iter().map(|a| *a));\n         return v;\n     }\n-    pub fn bt_push(&mut self, ei: codemap::ExpnInfo) {\n-        match ei {\n-            ExpnInfo {call_site: cs, callee: ref callee} => {\n-                self.backtrace =\n-                    Some(box(GC) ExpnInfo {\n-                        call_site: Span {lo: cs.lo, hi: cs.hi,\n-                                         expn_info: self.backtrace.clone()},\n-                        callee: (*callee).clone()\n-                    });\n-            }\n-        }\n+    pub fn bt_push(&mut self, ei: ExpnInfo) {\n+        let mut call_site = ei.call_site;\n+        call_site.expn_id = self.backtrace;\n+        self.backtrace = self.codemap().record_expansion(ExpnInfo {\n+            call_site: call_site,\n+            callee: ei.callee\n+        });\n     }\n     pub fn bt_pop(&mut self) {\n         match self.backtrace {\n-            Some(expn_info) => self.backtrace = expn_info.call_site.expn_info,\n-            _ => self.bug(\"tried to pop without a push\")\n+            NO_EXPANSION => self.bug(\"tried to pop without a push\"),\n+            expn_id => {\n+                self.backtrace = self.codemap().with_expn_info(expn_id, |expn_info| {\n+                    expn_info.map_or(NO_EXPANSION, |ei| ei.call_site.expn_id)\n+                });\n+            }\n         }\n     }\n     /// Emit `msg` attached to `sp`, and stop compilation immediately."}, {"sha": "16ecd83180ed15826026c66ae41ac79ed0675ac7", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b94075c9cefb3baedd4b0c01c9c11393e83ea66a/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b94075c9cefb3baedd4b0c01c9c11393e83ea66a/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=b94075c9cefb3baedd4b0c01c9c11393e83ea66a", "patch": "@@ -573,7 +573,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         let field_span = Span {\n             lo: sp.lo - Pos::from_uint(field_name.get().len()),\n             hi: sp.hi,\n-            expn_info: sp.expn_info,\n+            expn_id: sp.expn_id,\n         };\n \n         let id = Spanned { node: ident, span: field_span };\n@@ -583,7 +583,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         let field_span = Span {\n             lo: sp.lo - Pos::from_uint(idx.to_string().len()),\n             hi: sp.hi,\n-            expn_info: sp.expn_info,\n+            expn_id: sp.expn_id,\n         };\n \n         let id = Spanned { node: idx, span: field_span };"}, {"sha": "142adc9b721e00d462c8d7e36bb97554b1c76c5c", "filename": "src/libsyntax/ext/deriving/generic/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b94075c9cefb3baedd4b0c01c9c11393e83ea66a/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b94075c9cefb3baedd4b0c01c9c11393e83ea66a/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs?ref=b94075c9cefb3baedd4b0c01c9c11393e83ea66a", "patch": "@@ -181,7 +181,6 @@\n //! ~~~\n \n use std::cell::RefCell;\n-use std::gc::GC;\n use std::vec;\n \n use abi::Abi;\n@@ -1169,7 +1168,7 @@ impl<'a> TraitDef<'a> {\n             None => cx.span_bug(self.span, \"trait with empty path in generic `deriving`\"),\n             Some(name) => *name\n         };\n-        to_set.expn_info = Some(box(GC) codemap::ExpnInfo {\n+        to_set.expn_id = cx.codemap().record_expansion(codemap::ExpnInfo {\n             call_site: to_set,\n             callee: codemap::NameAndSpan {\n                 name: format!(\"deriving({})\", trait_name),"}, {"sha": "f81fc909a745bbbe705e7c2cb55fcf76e1ea6841", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 5, "deletions": 22, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/b94075c9cefb3baedd4b0c01c9c11393e83ea66a/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b94075c9cefb3baedd4b0c01c9c11393e83ea66a/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=b94075c9cefb3baedd4b0c01c9c11393e83ea66a", "patch": "@@ -30,8 +30,6 @@ use util::small_vector::SmallVector;\n use visit;\n use visit::Visitor;\n \n-use std::gc::Gc;\n-\n enum Either<L,R> {\n     Left(L),\n     Right(R)\n@@ -161,11 +159,11 @@ fn expand_mac_invoc<T>(mac: ast::Mac, span: codemap::Span,\n                         // be the root of the call stack. That's the most\n                         // relevant span and it's the actual invocation of\n                         // the macro.\n-                        let mac_span = original_span(fld.cx);\n+                        let mac_span = fld.cx.original_span();\n \n                         let opt_parsed = {\n                             let expanded = expandfun.expand(fld.cx,\n-                                                            mac_span.call_site,\n+                                                            mac_span,\n                                                             marked_before.as_slice());\n                             parse_thunk(expanded)\n                         };\n@@ -759,9 +757,9 @@ fn expand_pat(p: P<ast::Pat>, fld: &mut MacroExpander) -> P<ast::Pat> {\n \n                     let fm = fresh_mark();\n                     let marked_before = mark_tts(tts.as_slice(), fm);\n-                    let mac_span = original_span(fld.cx);\n+                    let mac_span = fld.cx.original_span();\n                     let expanded = match expander.expand(fld.cx,\n-                                        mac_span.call_site,\n+                                        mac_span,\n                                         marked_before.as_slice()).make_pat() {\n                         Some(e) => e,\n                         None => {\n@@ -969,7 +967,7 @@ fn new_span(cx: &ExtCtxt, sp: Span) -> Span {\n     Span {\n         lo: sp.lo,\n         hi: sp.hi,\n-        expn_info: cx.backtrace(),\n+        expn_id: cx.backtrace(),\n     }\n }\n \n@@ -1083,21 +1081,6 @@ fn mark_method(expr: P<ast::Method>, m: Mrk) -> P<ast::Method> {\n         .expect_one(\"marking an item didn't return exactly one method\")\n }\n \n-fn original_span(cx: &ExtCtxt) -> Gc<codemap::ExpnInfo> {\n-    let mut relevant_info = cx.backtrace();\n-    let mut einfo = relevant_info.unwrap();\n-    loop {\n-        match relevant_info {\n-            None => { break }\n-            Some(e) => {\n-                einfo = e;\n-                relevant_info = einfo.call_site.expn_info;\n-            }\n-        }\n-    }\n-    return einfo;\n-}\n-\n /// Check that there are no macro invocations left in the AST:\n pub fn check_for_macros(sess: &parse::ParseSess, krate: &ast::Crate) {\n     visit::walk_crate(&mut MacroExterminator{sess:sess}, krate);"}, {"sha": "41967b0680cffa9684c5c0765e025940a472cb13", "filename": "src/libsyntax/ext/source_util.rs", "status": "modified", "additions": 9, "deletions": 37, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/b94075c9cefb3baedd4b0c01c9c11393e83ea66a/src%2Flibsyntax%2Fext%2Fsource_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b94075c9cefb3baedd4b0c01c9c11393e83ea66a/src%2Flibsyntax%2Fext%2Fsource_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fsource_util.rs?ref=b94075c9cefb3baedd4b0c01c9c11393e83ea66a", "patch": "@@ -11,15 +11,13 @@\n use ast;\n use codemap;\n use codemap::{Pos, Span};\n-use codemap::{ExpnInfo, NameAndSpan};\n use ext::base::*;\n use ext::base;\n use ext::build::AstBuilder;\n use parse;\n use parse::token;\n use print::pprust;\n \n-use std::gc::Gc;\n use std::io::File;\n use std::rc::Rc;\n \n@@ -32,20 +30,20 @@ pub fn expand_line(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n                    -> Box<base::MacResult+'static> {\n     base::check_zero_tts(cx, sp, tts, \"line!\");\n \n-    let topmost = topmost_expn_info(cx.backtrace().unwrap());\n-    let loc = cx.codemap().lookup_char_pos(topmost.call_site.lo);\n+    let topmost = cx.original_span_in_file();\n+    let loc = cx.codemap().lookup_char_pos(topmost.lo);\n \n-    base::MacExpr::new(cx.expr_uint(topmost.call_site, loc.line))\n+    base::MacExpr::new(cx.expr_uint(topmost, loc.line))\n }\n \n /* col!(): expands to the current column number */\n pub fn expand_col(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n                   -> Box<base::MacResult+'static> {\n     base::check_zero_tts(cx, sp, tts, \"col!\");\n \n-    let topmost = topmost_expn_info(cx.backtrace().unwrap());\n-    let loc = cx.codemap().lookup_char_pos(topmost.call_site.lo);\n-    base::MacExpr::new(cx.expr_uint(topmost.call_site, loc.col.to_uint()))\n+    let topmost = cx.original_span_in_file();\n+    let loc = cx.codemap().lookup_char_pos(topmost.lo);\n+    base::MacExpr::new(cx.expr_uint(topmost, loc.col.to_uint()))\n }\n \n /// file!(): expands to the current filename */\n@@ -55,10 +53,10 @@ pub fn expand_file(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n                    -> Box<base::MacResult+'static> {\n     base::check_zero_tts(cx, sp, tts, \"file!\");\n \n-    let topmost = topmost_expn_info(cx.backtrace().unwrap());\n-    let loc = cx.codemap().lookup_char_pos(topmost.call_site.lo);\n+    let topmost = cx.original_span_in_file();\n+    let loc = cx.codemap().lookup_char_pos(topmost.lo);\n     let filename = token::intern_and_get_ident(loc.file.name.as_slice());\n-    base::MacExpr::new(cx.expr_str(topmost.call_site, filename))\n+    base::MacExpr::new(cx.expr_str(topmost, filename))\n }\n \n pub fn expand_stringify(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n@@ -162,32 +160,6 @@ pub fn expand_include_bin(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n     }\n }\n \n-// recur along an ExpnInfo chain to find the original expression\n-fn topmost_expn_info(expn_info: Gc<codemap::ExpnInfo>) -> Gc<codemap::ExpnInfo> {\n-    match *expn_info {\n-        ExpnInfo { call_site: ref call_site, .. } => {\n-            match call_site.expn_info {\n-                Some(next_expn_info) => {\n-                    match *next_expn_info {\n-                        ExpnInfo {\n-                            callee: NameAndSpan { name: ref name, .. },\n-                            ..\n-                        } => {\n-                            // Don't recurse into file using \"include!\"\n-                            if \"include\" == name.as_slice() {\n-                                expn_info\n-                            } else {\n-                                topmost_expn_info(next_expn_info)\n-                            }\n-                        }\n-                    }\n-                },\n-                None => expn_info\n-            }\n-        }\n-    }\n-}\n-\n // resolve a file-system path to an absolute file-system path (if it\n // isn't already)\n fn res_rel_file(cx: &mut ExtCtxt, sp: codemap::Span, arg: &Path) -> Path {"}, {"sha": "153b3cc90d60101f8f9f66d32b5e4c25789cefc0", "filename": "src/libsyntax/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b94075c9cefb3baedd4b0c01c9c11393e83ea66a/src%2Flibsyntax%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b94075c9cefb3baedd4b0c01c9c11393e83ea66a/src%2Flibsyntax%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Flib.rs?ref=b94075c9cefb3baedd4b0c01c9c11393e83ea66a", "patch": "@@ -23,7 +23,7 @@\n        html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n        html_root_url = \"http://doc.rust-lang.org/master/\")]\n \n-#![feature(macro_rules, globs, managed_boxes, default_type_params, phase)]\n+#![feature(macro_rules, globs, default_type_params, phase)]\n #![feature(quote, struct_variant, unsafe_destructor, import_shadowing)]\n #![allow(deprecated)]\n "}, {"sha": "68ddd17dd012b4917e15f9ae810c5e9b08d29156", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b94075c9cefb3baedd4b0c01c9c11393e83ea66a/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b94075c9cefb3baedd4b0c01c9c11393e83ea66a/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=b94075c9cefb3baedd4b0c01c9c11393e83ea66a", "patch": "@@ -1406,7 +1406,7 @@ fn ident_continue(c: Option<char>) -> bool {\n mod test {\n     use super::*;\n \n-    use codemap::{BytePos, CodeMap, Span};\n+    use codemap::{BytePos, CodeMap, Span, NO_EXPANSION};\n     use diagnostic;\n     use parse::token;\n     use parse::token::{str_to_ident};\n@@ -1436,7 +1436,7 @@ mod test {\n         let tok1 = string_reader.next_token();\n         let tok2 = TokenAndSpan{\n             tok:token::IDENT(id, false),\n-            sp:Span {lo:BytePos(21),hi:BytePos(23),expn_info: None}};\n+            sp:Span {lo:BytePos(21),hi:BytePos(23),expn_id: NO_EXPANSION}};\n         assert_eq!(tok1,tok2);\n         assert_eq!(string_reader.next_token().tok, token::WS);\n         // the 'main' id is already read:\n@@ -1445,7 +1445,7 @@ mod test {\n         let tok3 = string_reader.next_token();\n         let tok4 = TokenAndSpan{\n             tok:token::IDENT(str_to_ident(\"main\"), false),\n-            sp:Span {lo:BytePos(24),hi:BytePos(28),expn_info: None}};\n+            sp:Span {lo:BytePos(24),hi:BytePos(28),expn_id: NO_EXPANSION}};\n         assert_eq!(tok3,tok4);\n         // the lparen is already read:\n         assert_eq!(string_reader.last_pos.clone(), BytePos(29))"}, {"sha": "66ecdbfca02d4f774ecb99e711aa7788ced95257", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b94075c9cefb3baedd4b0c01c9c11393e83ea66a/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b94075c9cefb3baedd4b0c01c9c11393e83ea66a/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=b94075c9cefb3baedd4b0c01c9c11393e83ea66a", "patch": "@@ -721,7 +721,7 @@ pub fn integer_lit(s: &str, sd: &SpanHandler, sp: Span) -> ast::Lit_ {\n mod test {\n     use super::*;\n     use serialize::json;\n-    use codemap::{Span, BytePos, Spanned};\n+    use codemap::{Span, BytePos, Spanned, NO_EXPANSION};\n     use owned_slice::OwnedSlice;\n     use ast;\n     use abi;\n@@ -736,7 +736,7 @@ mod test {\n \n     // produce a codemap::span\n     fn sp(a: u32, b: u32) -> Span {\n-        Span{lo:BytePos(a),hi:BytePos(b),expn_info:None}\n+        Span {lo: BytePos(a), hi: BytePos(b), expn_id: NO_EXPANSION}\n     }\n \n     #[test] fn path_exprs_1() {"}, {"sha": "a5a936a97795fb023f590c5dd74dee3b9c6f9312", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b94075c9cefb3baedd4b0c01c9c11393e83ea66a/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b94075c9cefb3baedd4b0c01c9c11393e83ea66a/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=b94075c9cefb3baedd4b0c01c9c11393e83ea66a", "patch": "@@ -3591,7 +3591,7 @@ impl<'a> Parser<'a> {\n                                     let span_with_semi = Span {\n                                         lo: span.lo,\n                                         hi: self.last_span.hi,\n-                                        expn_info: span.expn_info,\n+                                        expn_id: span.expn_id,\n                                     };\n                                     stmts.push(P(Spanned {\n                                         node: StmtSemi(e, stmt_id),"}, {"sha": "06d473baea878403c7d12375fd41129b8cb19de2", "filename": "src/test/compile-fail/qquote-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b94075c9cefb3baedd4b0c01c9c11393e83ea66a/src%2Ftest%2Fcompile-fail%2Fqquote-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b94075c9cefb3baedd4b0c01c9c11393e83ea66a/src%2Ftest%2Fcompile-fail%2Fqquote-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fqquote-1.rs?ref=b94075c9cefb3baedd4b0c01c9c11393e83ea66a", "patch": "@@ -39,7 +39,7 @@ impl fake_ext_ctxt for fake_session {\n         codemap::span {\n             lo: codemap::BytePos(0),\n             hi: codemap::BytePos(0),\n-            expn_info: None\n+            expn_id: NO_EXPANSION\n         }\n     }\n     fn ident_of(st: &str) -> ast::ident {"}, {"sha": "f63dd91eb2bc14465beefa07878d214028736f72", "filename": "src/test/compile-fail/qquote-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b94075c9cefb3baedd4b0c01c9c11393e83ea66a/src%2Ftest%2Fcompile-fail%2Fqquote-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b94075c9cefb3baedd4b0c01c9c11393e83ea66a/src%2Ftest%2Fcompile-fail%2Fqquote-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fqquote-2.rs?ref=b94075c9cefb3baedd4b0c01c9c11393e83ea66a", "patch": "@@ -36,7 +36,7 @@ impl fake_ext_ctxt for fake_session {\n         codemap::span {\n             lo: codemap::BytePos(0),\n             hi: codemap::BytePos(0),\n-            expn_info: None\n+            expn_id: codemap::NO_EXPANSION\n         }\n     }\n     fn ident_of(st: &str) -> ast::ident {"}, {"sha": "252d297d12d3053d44f3be816057c9d146d0e928", "filename": "src/test/run-pass-fulldeps/qquote.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b94075c9cefb3baedd4b0c01c9c11393e83ea66a/src%2Ftest%2Frun-pass-fulldeps%2Fqquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b94075c9cefb3baedd4b0c01c9c11393e83ea66a/src%2Ftest%2Frun-pass-fulldeps%2Fqquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fqquote.rs?ref=b94075c9cefb3baedd4b0c01c9c11393e83ea66a", "patch": "@@ -41,7 +41,7 @@ impl fake_ext_ctxt for fake_session {\n         codemap::span {\n             lo: codemap::BytePos(0),\n             hi: codemap::BytePos(0),\n-            expn_info: None\n+            expn_id: codemap::NO_EXPANSION\n         }\n     }\n     fn ident_of(st: &str) -> ast::ident {"}]}