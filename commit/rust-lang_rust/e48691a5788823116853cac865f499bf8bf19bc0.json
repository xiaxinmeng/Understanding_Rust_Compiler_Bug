{"sha": "e48691a5788823116853cac865f499bf8bf19bc0", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU0ODY5MWE1Nzg4ODIzMTE2ODUzY2FjODY1ZjQ5OWJmOGJmMTliYzA=", "commit": {"author": {"name": "Mikhail Modin", "email": "mikhailm1@gmail.com", "date": "2017-11-08T15:32:08Z"}, "committer": {"name": "Mikhail Modin", "email": "mikhailm1@gmail.com", "date": "2017-11-08T19:04:56Z"}, "message": "restore move out dataflow, add report of move out errors", "tree": {"sha": "af6959c21a116cb64a690086c0171783055eeddd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/af6959c21a116cb64a690086c0171783055eeddd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e48691a5788823116853cac865f499bf8bf19bc0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e48691a5788823116853cac865f499bf8bf19bc0", "html_url": "https://github.com/rust-lang/rust/commit/e48691a5788823116853cac865f499bf8bf19bc0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e48691a5788823116853cac865f499bf8bf19bc0/comments", "author": {"login": "mikhail-m1", "id": 5663581, "node_id": "MDQ6VXNlcjU2NjM1ODE=", "avatar_url": "https://avatars.githubusercontent.com/u/5663581?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mikhail-m1", "html_url": "https://github.com/mikhail-m1", "followers_url": "https://api.github.com/users/mikhail-m1/followers", "following_url": "https://api.github.com/users/mikhail-m1/following{/other_user}", "gists_url": "https://api.github.com/users/mikhail-m1/gists{/gist_id}", "starred_url": "https://api.github.com/users/mikhail-m1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mikhail-m1/subscriptions", "organizations_url": "https://api.github.com/users/mikhail-m1/orgs", "repos_url": "https://api.github.com/users/mikhail-m1/repos", "events_url": "https://api.github.com/users/mikhail-m1/events{/privacy}", "received_events_url": "https://api.github.com/users/mikhail-m1/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mikhail-m1", "id": 5663581, "node_id": "MDQ6VXNlcjU2NjM1ODE=", "avatar_url": "https://avatars.githubusercontent.com/u/5663581?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mikhail-m1", "html_url": "https://github.com/mikhail-m1", "followers_url": "https://api.github.com/users/mikhail-m1/followers", "following_url": "https://api.github.com/users/mikhail-m1/following{/other_user}", "gists_url": "https://api.github.com/users/mikhail-m1/gists{/gist_id}", "starred_url": "https://api.github.com/users/mikhail-m1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mikhail-m1/subscriptions", "organizations_url": "https://api.github.com/users/mikhail-m1/orgs", "repos_url": "https://api.github.com/users/mikhail-m1/repos", "events_url": "https://api.github.com/users/mikhail-m1/events{/privacy}", "received_events_url": "https://api.github.com/users/mikhail-m1/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a17e72462fcf4c4b8699fba086ab5363b0bba3bb", "url": "https://api.github.com/repos/rust-lang/rust/commits/a17e72462fcf4c4b8699fba086ab5363b0bba3bb", "html_url": "https://github.com/rust-lang/rust/commit/a17e72462fcf4c4b8699fba086ab5363b0bba3bb"}], "stats": {"total": 277, "additions": 249, "deletions": 28}, "files": [{"sha": "d2524b306cfed6a22c8b2f1fb6aeacaedcc4b376", "filename": "src/librustc_mir/borrow_check.rs", "status": "modified", "additions": 84, "deletions": 23, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/e48691a5788823116853cac865f499bf8bf19bc0/src%2Flibrustc_mir%2Fborrow_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e48691a5788823116853cac865f499bf8bf19bc0/src%2Flibrustc_mir%2Fborrow_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check.rs?ref=e48691a5788823116853cac865f499bf8bf19bc0", "patch": "@@ -30,9 +30,10 @@ use dataflow::{do_dataflow};\n use dataflow::{MoveDataParamEnv};\n use dataflow::{BitDenotation, BlockSets, DataflowResults, DataflowResultsConsumer};\n use dataflow::{MaybeInitializedLvals, MaybeUninitializedLvals};\n+use dataflow::{MovingOutStatements};\n use dataflow::{Borrows, BorrowData, BorrowIndex};\n use dataflow::move_paths::{MoveError, IllegalMoveOriginKind};\n-use dataflow::move_paths::{HasMoveData, MoveData, MovePathIndex, LookupResult};\n+use dataflow::move_paths::{HasMoveData, MoveData, MovePathIndex, LookupResult, MoveOutIndex};\n use util::borrowck_errors::{BorrowckErrors, Origin};\n \n use self::MutateMode::{JustWrite, WriteAndRead};\n@@ -129,6 +130,9 @@ fn do_mir_borrowck<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n     let flow_uninits = do_dataflow(tcx, mir, id, &attributes, &dead_unwinds,\n                                    MaybeUninitializedLvals::new(tcx, mir, &mdpe),\n                                    |bd, i| &bd.move_data().move_paths[i]);\n+    let flow_move_outs = do_dataflow(tcx, mir, id, &attributes, &dead_unwinds,\n+                                     MovingOutStatements::new(tcx, mir, &mdpe),\n+                                     |bd, i| &bd.move_data().moves[i]);\n \n     let mut mbcx = MirBorrowckCtxt {\n         tcx: tcx,\n@@ -141,7 +145,8 @@ fn do_mir_borrowck<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n \n     let mut state = InProgress::new(flow_borrows,\n                                     flow_inits,\n-                                    flow_uninits);\n+                                    flow_uninits,\n+                                    flow_move_outs);\n \n     mbcx.analyze_results(&mut state); // entry point for DataflowResultsConsumer\n }\n@@ -161,6 +166,7 @@ pub struct InProgress<'b, 'gcx: 'tcx, 'tcx: 'b> {\n     borrows: FlowInProgress<Borrows<'b, 'gcx, 'tcx>>,\n     inits: FlowInProgress<MaybeInitializedLvals<'b, 'gcx, 'tcx>>,\n     uninits: FlowInProgress<MaybeUninitializedLvals<'b, 'gcx, 'tcx>>,\n+    move_outs: FlowInProgress<MovingOutStatements<'b, 'gcx, 'tcx>>,\n }\n \n struct FlowInProgress<BD> where BD: BitDenotation {\n@@ -185,31 +191,35 @@ impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> DataflowResultsConsumer<'b, 'tcx>\n     fn reset_to_entry_of(&mut self, bb: BasicBlock, flow_state: &mut Self::FlowState) {\n         flow_state.each_flow(|b| b.reset_to_entry_of(bb),\n                              |i| i.reset_to_entry_of(bb),\n-                             |u| u.reset_to_entry_of(bb));\n+                             |u| u.reset_to_entry_of(bb),\n+                             |m| m.reset_to_entry_of(bb));\n     }\n \n     fn reconstruct_statement_effect(&mut self,\n                                     location: Location,\n                                     flow_state: &mut Self::FlowState) {\n         flow_state.each_flow(|b| b.reconstruct_statement_effect(location),\n                              |i| i.reconstruct_statement_effect(location),\n-                             |u| u.reconstruct_statement_effect(location));\n+                             |u| u.reconstruct_statement_effect(location),\n+                             |m| m.reconstruct_statement_effect(location));\n     }\n \n     fn apply_local_effect(&mut self,\n                           _location: Location,\n                           flow_state: &mut Self::FlowState) {\n         flow_state.each_flow(|b| b.apply_local_effect(),\n                              |i| i.apply_local_effect(),\n-                             |u| u.apply_local_effect());\n+                             |u| u.apply_local_effect(),\n+                             |m| m.apply_local_effect());\n     }\n \n     fn reconstruct_terminator_effect(&mut self,\n                                      location: Location,\n                                      flow_state: &mut Self::FlowState) {\n         flow_state.each_flow(|b| b.reconstruct_terminator_effect(location),\n                              |i| i.reconstruct_terminator_effect(location),\n-                             |u| u.reconstruct_terminator_effect(location));\n+                             |u| u.reconstruct_terminator_effect(location),\n+                             |m| m.reconstruct_terminator_effect(location));\n     }\n \n     fn visit_block_entry(&mut self,\n@@ -671,6 +681,7 @@ impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx>\n         let lvalue = self.base_path(lvalue_span.0);\n \n         let maybe_uninits = &flow_state.uninits;\n+        let curr_move_outs = &flow_state.move_outs.curr_state;\n \n         // Bad scenarios:\n         //\n@@ -712,7 +723,9 @@ impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx>\n         match self.move_path_closest_to(lvalue) {\n             Ok(mpi) => {\n                 if maybe_uninits.curr_state.contains(&mpi) {\n-                    self.report_use_of_moved(context, desired_action, lvalue_span);\n+                    self.report_use_of_moved_or_uninitialized(context, desired_action,\n+                                                              lvalue_span, mpi,\n+                                                              curr_move_outs);\n                     return; // don't bother finding other problems.\n                 }\n             }\n@@ -737,8 +750,10 @@ impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx>\n \n         debug!(\"check_if_path_is_moved part2 lvalue: {:?}\", lvalue);\n         if let Some(mpi) = self.move_path_for_lvalue(lvalue) {\n-            if let Some(_) = maybe_uninits.has_any_child_of(mpi) {\n-                self.report_use_of_moved(context, desired_action, lvalue_span);\n+            if let Some(child_mpi) = maybe_uninits.has_any_child_of(mpi) {\n+                self.report_use_of_moved_or_uninitialized(context, desired_action,\n+                                                          lvalue_span, child_mpi,\n+                                                          curr_move_outs);\n                 return; // don't bother finding other problems.\n             }\n         }\n@@ -1083,17 +1098,47 @@ mod prefixes {\n }\n \n impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx> {\n-    fn report_use_of_moved(&mut self,\n+    fn report_use_of_moved_or_uninitialized(&mut self,\n                            _context: Context,\n                            desired_action: &str,\n-                           (lvalue, span): (&Lvalue, Span)) {\n-        self.tcx.cannot_act_on_uninitialized_variable(span,\n-                                                      desired_action,\n-                                                      &self.describe_lvalue(lvalue),\n-                                                      Origin::Mir)\n-                .span_label(span, format!(\"use of possibly uninitialized `{}`\",\n-                                          self.describe_lvalue(lvalue)))\n-                .emit();\n+                           (lvalue, span): (&Lvalue, Span),\n+                           mpi: MovePathIndex,\n+                           curr_move_out: &IdxSetBuf<MoveOutIndex>) {\n+\n+        let mois = self.move_data.path_map[mpi].iter().filter(\n+            |moi| curr_move_out.contains(moi)).collect::<Vec<_>>();\n+\n+        if mois.is_empty() {\n+            self.tcx.cannot_act_on_uninitialized_variable(span,\n+                                                          desired_action,\n+                                                          &self.describe_lvalue(lvalue),\n+                                                          Origin::Mir)\n+                    .span_label(span, format!(\"use of possibly uninitialized `{}`\",\n+                                              self.describe_lvalue(lvalue)))\n+                    .emit();\n+        } else {\n+            let msg = \"\"; //FIXME: add \"partially \" or \"collaterally \"\n+\n+            let mut err = self.tcx.cannot_act_on_moved_value(span,\n+                                                             desired_action,\n+                                                             msg,\n+                                                             &self.describe_lvalue(lvalue),\n+                                                             Origin::Mir);\n+            err.span_label(span, format!(\"value {} here after move\", desired_action));\n+            for moi in mois {\n+                let move_msg = \"\"; //FIXME: add \" (into closure)\"\n+                let move_span = self.mir.source_info(self.move_data.moves[*moi].source).span;\n+                if span == move_span {\n+                    err.span_label(span,\n+                                   format!(\"value moved{} here in previous iteration of loop\",\n+                                           move_msg));\n+                } else {\n+                    err.span_label(move_span, format!(\"value moved{} here\", move_msg));\n+                };\n+            }\n+            //FIXME: add note for closure\n+            err.emit();\n+        }\n     }\n \n     fn report_move_out_while_borrowed(&mut self,\n@@ -1396,26 +1441,31 @@ impl ContextKind {\n impl<'b, 'gcx, 'tcx> InProgress<'b, 'gcx, 'tcx> {\n     pub(super) fn new(borrows: DataflowResults<Borrows<'b, 'gcx, 'tcx>>,\n                       inits: DataflowResults<MaybeInitializedLvals<'b, 'gcx, 'tcx>>,\n-                      uninits: DataflowResults<MaybeUninitializedLvals<'b, 'gcx, 'tcx>>)\n+                      uninits: DataflowResults<MaybeUninitializedLvals<'b, 'gcx, 'tcx>>,\n+                      move_out: DataflowResults<MovingOutStatements<'b, 'gcx, 'tcx>>)\n                       -> Self {\n         InProgress {\n             borrows: FlowInProgress::new(borrows),\n             inits: FlowInProgress::new(inits),\n             uninits: FlowInProgress::new(uninits),\n+            move_outs: FlowInProgress::new(move_out)\n         }\n     }\n \n-    fn each_flow<XB, XI, XU>(&mut self,\n-                             mut xform_borrows: XB,\n-                             mut xform_inits: XI,\n-                             mut xform_uninits: XU) where\n+    fn each_flow<XB, XI, XU, XM>(&mut self,\n+                                 mut xform_borrows: XB,\n+                                 mut xform_inits: XI,\n+                                 mut xform_uninits: XU,\n+                                 mut xform_move_outs: XM) where\n         XB: FnMut(&mut FlowInProgress<Borrows<'b, 'gcx, 'tcx>>),\n         XI: FnMut(&mut FlowInProgress<MaybeInitializedLvals<'b, 'gcx, 'tcx>>),\n         XU: FnMut(&mut FlowInProgress<MaybeUninitializedLvals<'b, 'gcx, 'tcx>>),\n+        XM: FnMut(&mut FlowInProgress<MovingOutStatements<'b, 'gcx, 'tcx>>),\n     {\n         xform_borrows(&mut self.borrows);\n         xform_inits(&mut self.inits);\n         xform_uninits(&mut self.uninits);\n+        xform_move_outs(&mut self.move_outs);\n     }\n \n     fn summary(&self) -> String {\n@@ -1461,6 +1511,17 @@ impl<'b, 'gcx, 'tcx> InProgress<'b, 'gcx, 'tcx> {\n                 &self.uninits.base_results.operator().move_data().move_paths[mpi_uninit];\n             s.push_str(&format!(\"{}\", move_path));\n         });\n+        s.push_str(\"] \");\n+\n+        s.push_str(\"move_out: [\");\n+        let mut saw_one = false;\n+        self.move_outs.each_state_bit(|mpi_move_out| {\n+            if saw_one { s.push_str(\", \"); };\n+            saw_one = true;\n+            let move_out =\n+                &self.move_outs.base_results.operator().move_data().moves[mpi_move_out];\n+            s.push_str(&format!(\"{:?}\", move_out));\n+        });\n         s.push_str(\"]\");\n \n         return s;"}, {"sha": "7022b4dffa04885cdf1fbc2bba0a52ccb1a91604", "filename": "src/librustc_mir/dataflow/impls/mod.rs", "status": "modified", "additions": 161, "deletions": 1, "changes": 162, "blob_url": "https://github.com/rust-lang/rust/blob/e48691a5788823116853cac865f499bf8bf19bc0/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e48691a5788823116853cac865f499bf8bf19bc0/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fmod.rs?ref=e48691a5788823116853cac865f499bf8bf19bc0", "patch": "@@ -14,13 +14,16 @@\n \n use rustc::ty::TyCtxt;\n use rustc::mir::{self, Mir, Location};\n+use rustc_data_structures::bitslice::BitSlice; // adds set_bit/get_bit to &[usize] bitvector rep.\n use rustc_data_structures::bitslice::{BitwiseOperator};\n use rustc_data_structures::indexed_set::{IdxSet};\n+use rustc_data_structures::indexed_vec::Idx;\n \n use super::MoveDataParamEnv;\n use util::elaborate_drops::DropFlagState;\n \n-use super::move_paths::{HasMoveData, MoveData, MovePathIndex};\n+use super::move_paths::{HasMoveData, MoveData, MoveOutIndex, MovePathIndex};\n+use super::move_paths::LookupResult;\n use super::{BitDenotation, BlockSets, DataflowOperator};\n \n use super::drop_flag_effects_for_function_entry;\n@@ -205,6 +208,40 @@ impl<'a, 'gcx, 'tcx: 'a> HasMoveData<'tcx> for DefinitelyInitializedLvals<'a, 'g\n     fn move_data(&self) -> &MoveData<'tcx> { &self.mdpe.move_data }\n }\n \n+/// `MovingOutStatements` tracks the statements that perform moves out\n+/// of particular l-values. More precisely, it tracks whether the\n+/// *effect* of such moves (namely, the uninitialization of the\n+/// l-value in question) can reach some point in the control-flow of\n+/// the function, or if that effect is \"killed\" by some intervening\n+/// operation reinitializing that l-value.\n+///\n+/// The resulting dataflow is a more enriched version of\n+/// `MaybeUninitializedLvals`. Both structures on their own only tell\n+/// you if an l-value *might* be uninitialized at a given point in the\n+/// control flow. But `MovingOutStatements` also includes the added\n+/// data of *which* particular statement causing the deinitialization\n+/// that the borrow checker's error message may need to report.\n+#[allow(dead_code)]\n+pub struct MovingOutStatements<'a, 'gcx: 'tcx, 'tcx: 'a> {\n+    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+    mir: &'a Mir<'tcx>,\n+    mdpe: &'a MoveDataParamEnv<'gcx, 'tcx>,\n+}\n+\n+impl<'a, 'gcx: 'tcx, 'tcx: 'a> MovingOutStatements<'a, 'gcx, 'tcx> {\n+    pub fn new(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+               mir: &'a Mir<'tcx>,\n+               mdpe: &'a MoveDataParamEnv<'gcx, 'tcx>)\n+               -> Self\n+    {\n+        MovingOutStatements { tcx: tcx, mir: mir, mdpe: mdpe }\n+    }\n+}\n+\n+impl<'a, 'gcx, 'tcx> HasMoveData<'tcx> for MovingOutStatements<'a, 'gcx, 'tcx> {\n+    fn move_data(&self) -> &MoveData<'tcx> { &self.mdpe.move_data }\n+}\n+\n impl<'a, 'gcx, 'tcx> MaybeInitializedLvals<'a, 'gcx, 'tcx> {\n     fn update_bits(sets: &mut BlockSets<MovePathIndex>, path: MovePathIndex,\n                    state: DropFlagState)\n@@ -399,6 +436,115 @@ impl<'a, 'gcx, 'tcx> BitDenotation for DefinitelyInitializedLvals<'a, 'gcx, 'tcx\n     }\n }\n \n+impl<'a, 'gcx, 'tcx> BitDenotation for MovingOutStatements<'a, 'gcx, 'tcx> {\n+    type Idx = MoveOutIndex;\n+    fn name() -> &'static str { \"moving_out\" }\n+    fn bits_per_block(&self) -> usize {\n+        self.move_data().moves.len()\n+    }\n+\n+    fn start_block_effect(&self, _sets: &mut BlockSets<MoveOutIndex>) {\n+        // no move-statements have been executed prior to function\n+        // execution, so this method has no effect on `_sets`.\n+    }\n+    fn statement_effect(&self,\n+                        sets: &mut BlockSets<MoveOutIndex>,\n+                        location: Location) {\n+        let (tcx, mir, move_data) = (self.tcx, self.mir, self.move_data());\n+        let stmt = &mir[location.block].statements[location.statement_index];\n+        let loc_map = &move_data.loc_map;\n+        let path_map = &move_data.path_map;\n+        let rev_lookup = &move_data.rev_lookup;\n+\n+        debug!(\"stmt {:?} at loc {:?} moves out of move_indexes {:?}\",\n+               stmt, location, &loc_map[location]);\n+        for move_index in &loc_map[location] {\n+            // Every path deinitialized by a *particular move*\n+            // has corresponding bit, \"gen'ed\" (i.e. set)\n+            // here, in dataflow vector\n+            zero_to_one(sets.gen_set.words_mut(), *move_index);\n+        }\n+        let bits_per_block = self.bits_per_block();\n+        match stmt.kind {\n+            mir::StatementKind::SetDiscriminant { .. } => {\n+                span_bug!(stmt.source_info.span, \"SetDiscriminant should not exist in borrowck\");\n+            }\n+            mir::StatementKind::Assign(ref lvalue, ref rvalue) => {\n+                // assigning into this `lvalue` kills all\n+                // MoveOuts from it, and *also* all MoveOuts\n+                // for children and associated fragment sets.\n+                match rvalue.initialization_state() {\n+                    mir::tcx::RvalueInitializationState::Shallow => {\n+                        if let LookupResult::Exact(mpi) = rev_lookup.find(lvalue) {\n+                             for moi in &path_map[mpi] {\n+                                 assert!(moi.index() < bits_per_block);\n+                                 sets.kill_set.add(&moi);\n+                             }\n+                        }\n+                    }\n+                    mir::tcx::RvalueInitializationState::Deep => {\n+                        on_lookup_result_bits(tcx,\n+                                              mir,\n+                                              move_data,\n+                                              rev_lookup.find(lvalue),\n+                                              |mpi| for moi in &path_map[mpi] {\n+                                                  assert!(moi.index() < bits_per_block);\n+                                                  sets.kill_set.add(&moi);\n+                                              });\n+                    }\n+                }\n+            }\n+            mir::StatementKind::StorageLive(_) |\n+            mir::StatementKind::StorageDead(_) |\n+            mir::StatementKind::InlineAsm { .. } |\n+            mir::StatementKind::EndRegion(_) |\n+            mir::StatementKind::Validate(..) |\n+            mir::StatementKind::Nop => {}\n+        }\n+    }\n+\n+    fn terminator_effect(&self,\n+                         sets: &mut BlockSets<MoveOutIndex>,\n+                         location: Location)\n+    {\n+        let (mir, move_data) = (self.mir, self.move_data());\n+        let term = mir[location.block].terminator();\n+        let loc_map = &move_data.loc_map;\n+        debug!(\"terminator {:?} at loc {:?} moves out of move_indexes {:?}\",\n+               term, location, &loc_map[location]);\n+        let bits_per_block = self.bits_per_block();\n+        for move_index in &loc_map[location] {\n+            assert!(move_index.index() < bits_per_block);\n+            zero_to_one(sets.gen_set.words_mut(), *move_index);\n+        }\n+    }\n+\n+    fn propagate_call_return(&self,\n+                             in_out: &mut IdxSet<MoveOutIndex>,\n+                             _call_bb: mir::BasicBlock,\n+                             _dest_bb: mir::BasicBlock,\n+                             dest_lval: &mir::Lvalue) {\n+        let move_data = self.move_data();\n+        let bits_per_block = self.bits_per_block();\n+\n+        let path_map = &move_data.path_map;\n+        on_lookup_result_bits(self.tcx,\n+                              self.mir,\n+                              move_data,\n+                              move_data.rev_lookup.find(dest_lval),\n+                              |mpi| for moi in &path_map[mpi] {\n+                                  assert!(moi.index() < bits_per_block);\n+                                  in_out.remove(&moi);\n+                              });\n+    }\n+}\n+\n+fn zero_to_one(bitvec: &mut [usize], move_index: MoveOutIndex) {\n+    let retval = bitvec.set_bit(move_index.index());\n+    assert!(retval);\n+}\n+\n+\n impl<'a, 'gcx, 'tcx> BitwiseOperator for MaybeInitializedLvals<'a, 'gcx, 'tcx> {\n     #[inline]\n     fn join(&self, pred1: usize, pred2: usize) -> usize {\n@@ -420,6 +566,13 @@ impl<'a, 'gcx, 'tcx> BitwiseOperator for DefinitelyInitializedLvals<'a, 'gcx, 't\n     }\n }\n \n+impl<'a, 'gcx, 'tcx> BitwiseOperator for MovingOutStatements<'a, 'gcx, 'tcx> {\n+    #[inline]\n+    fn join(&self, pred1: usize, pred2: usize) -> usize {\n+        pred1 | pred2 // moves from both preds are in scope\n+    }\n+}\n+\n // The way that dataflow fixed point iteration works, you want to\n // start at bottom and work your way to a fixed point. Control-flow\n // merges will apply the `join` operator to each block entry's current\n@@ -450,3 +603,10 @@ impl<'a, 'gcx, 'tcx> DataflowOperator for DefinitelyInitializedLvals<'a, 'gcx, '\n         true // bottom = initialized (start_block_effect counters this at outset)\n     }\n }\n+\n+impl<'a, 'gcx, 'tcx> DataflowOperator for MovingOutStatements<'a, 'gcx, 'tcx> {\n+    #[inline]\n+    fn bottom_value() -> bool {\n+        false // bottom = no loans in scope by default\n+    }\n+}"}, {"sha": "bca9324d5b0aaaf8df44dc5459f88f91e833b389", "filename": "src/librustc_mir/dataflow/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e48691a5788823116853cac865f499bf8bf19bc0/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e48691a5788823116853cac865f499bf8bf19bc0/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs?ref=e48691a5788823116853cac865f499bf8bf19bc0", "patch": "@@ -26,7 +26,7 @@ use std::usize;\n \n pub use self::impls::{MaybeStorageLive};\n pub use self::impls::{MaybeInitializedLvals, MaybeUninitializedLvals};\n-pub use self::impls::{DefinitelyInitializedLvals};\n+pub use self::impls::{DefinitelyInitializedLvals, MovingOutStatements};\n pub use self::impls::borrows::{Borrows, BorrowData, BorrowIndex};\n pub(crate) use self::drop_flag_effects::*;\n "}, {"sha": "087ced01d8cda162100aea94c64a4b7793827f4c", "filename": "src/test/compile-fail/borrowck/borrowck-drop-from-guard.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e48691a5788823116853cac865f499bf8bf19bc0/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-drop-from-guard.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e48691a5788823116853cac865f499bf8bf19bc0/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-drop-from-guard.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-drop-from-guard.rs?ref=e48691a5788823116853cac865f499bf8bf19bc0", "patch": "@@ -19,6 +19,6 @@ fn main()\n     match Some(42) {\n         Some(_) if { drop(my_str); false } => {}\n         Some(_) => {}\n-        None => { foo(my_str); } //~ ERROR (Mir) [E0381]\n+        None => { foo(my_str); } //~ ERROR (Mir) [E0382]\n     }\n }"}, {"sha": "8f39ae6c04e43818f855f9d25b794c7eae24c482", "filename": "src/test/compile-fail/borrowck/borrowck-uninit-field-access.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e48691a5788823116853cac865f499bf8bf19bc0/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-uninit-field-access.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e48691a5788823116853cac865f499bf8bf19bc0/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-uninit-field-access.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-uninit-field-access.rs?ref=e48691a5788823116853cac865f499bf8bf19bc0", "patch": "@@ -39,11 +39,11 @@ fn main() {\n     let _moved = line1.origin;\n     let _ = line1.origin.x + 1; //[ast]~ ERROR use of collaterally moved value: `line1.origin.x`\n                                 //[mir]~^       [E0382]\n-                                //[mir]~| (Mir) [E0381]\n+                                //[mir]~| (Mir) [E0382]\n \n     let mut line2 = Line::default();\n     let _moved = (line2.origin, line2.middle);\n     line2.consume(); //[ast]~ ERROR use of partially moved value: `line2` [E0382]\n                      //[mir]~^       [E0382]\n-                     //[mir]~| (Mir) [E0381]\n+                     //[mir]~| (Mir) [E0382]\n }"}]}