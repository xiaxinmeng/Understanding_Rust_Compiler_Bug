{"sha": "858fea410d89986669c3613c63b5401abd72b891", "node_id": "C_kwDOAAsO6NoAKDg1OGZlYTQxMGQ4OTk4NjY2OWMzNjEzYzYzYjU0MDFhYmQ3MmI4OTE", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2021-11-10T17:52:27Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-11-10T17:52:27Z"}, "message": "Rollup merge of #88868 - calebzulawski:feature/simd_bitmask, r=workingjubilee\n\nAllow simd_bitmask to return byte arrays\n\ncc `@rust-lang/project-portable-simd` `@workingjubilee`", "tree": {"sha": "baed1dcddd335e21fb29836cd3ef2171a6dc0393", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/baed1dcddd335e21fb29836cd3ef2171a6dc0393"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/858fea410d89986669c3613c63b5401abd72b891", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJhjAbcCRBK7hj4Ov3rIwAAeCYIAGDYvNVMU4VG+O8uyUraXIuN\njPi/zfJbMy8Su4SrY0WbVvTVKwZ/oeZBYl5d4FFXHHNI0c5eeCMNGTTPICY9ODue\nj2/oqpD8WTy6XFfH3TfFSF7UWpujc+t78liK6lutNFiYwLvymi25o/i/V18us6aw\nNg53ldfLhWjI+iB87hGAhSZhvAox9an4r0VWrOeccVpzrAPXUKlulSXCcW+OtUCu\nWefhSBJeGbN7DZ8qt8e2cPmlWGf1XfRbxIEdMYwL95v/IIltJsCb/3MiOZf8L0g8\nQ9a1/L7UNGDYfIlPaXfFuBv95WLSuCvn0akkukjK3x7d0QnIJeOs2E40jHv23+c=\n=y6NL\n-----END PGP SIGNATURE-----\n", "payload": "tree baed1dcddd335e21fb29836cd3ef2171a6dc0393\nparent a8dff349ca0c9fb5283fe221b0b3786cacb8be4e\nparent fe8ae57645f1cd8d99709d7197d1eab55d2e4270\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1636566747 +0100\ncommitter GitHub <noreply@github.com> 1636566747 +0100\n\nRollup merge of #88868 - calebzulawski:feature/simd_bitmask, r=workingjubilee\n\nAllow simd_bitmask to return byte arrays\n\ncc `@rust-lang/project-portable-simd` `@workingjubilee`\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/858fea410d89986669c3613c63b5401abd72b891", "html_url": "https://github.com/rust-lang/rust/commit/858fea410d89986669c3613c63b5401abd72b891", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/858fea410d89986669c3613c63b5401abd72b891/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a8dff349ca0c9fb5283fe221b0b3786cacb8be4e", "url": "https://api.github.com/repos/rust-lang/rust/commits/a8dff349ca0c9fb5283fe221b0b3786cacb8be4e", "html_url": "https://github.com/rust-lang/rust/commit/a8dff349ca0c9fb5283fe221b0b3786cacb8be4e"}, {"sha": "fe8ae57645f1cd8d99709d7197d1eab55d2e4270", "url": "https://api.github.com/repos/rust-lang/rust/commits/fe8ae57645f1cd8d99709d7197d1eab55d2e4270", "html_url": "https://github.com/rust-lang/rust/commit/fe8ae57645f1cd8d99709d7197d1eab55d2e4270"}], "stats": {"total": 206, "additions": 147, "deletions": 59}, "files": [{"sha": "924bb803b368fb850a4c7b1c208cc5f473f6b225", "filename": "compiler/rustc_codegen_llvm/src/intrinsic.rs", "status": "modified", "additions": 69, "deletions": 32, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/858fea410d89986669c3613c63b5401abd72b891/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/858fea410d89986669c3613c63b5401abd72b891/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs?ref=858fea410d89986669c3613c63b5401abd72b891", "patch": "@@ -19,7 +19,7 @@ use rustc_middle::ty::layout::{FnAbiOf, HasTyCtxt, LayoutOf};\n use rustc_middle::ty::{self, Ty};\n use rustc_middle::{bug, span_bug};\n use rustc_span::{sym, symbol::kw, Span, Symbol};\n-use rustc_target::abi::{self, HasDataLayout, Primitive};\n+use rustc_target::abi::{self, Align, HasDataLayout, Primitive};\n use rustc_target::spec::{HasTargetSpec, PanicStrategy};\n \n use std::cmp::Ordering;\n@@ -857,28 +857,39 @@ fn generic_simd_intrinsic(\n     let arg_tys = sig.inputs();\n \n     if name == sym::simd_select_bitmask {\n-        let in_ty = arg_tys[0];\n-        let m_len = match in_ty.kind() {\n-            // Note that this `.unwrap()` crashes for isize/usize, that's sort\n-            // of intentional as there's not currently a use case for that.\n-            ty::Int(i) => i.bit_width().unwrap(),\n-            ty::Uint(i) => i.bit_width().unwrap(),\n-            _ => return_error!(\"`{}` is not an integral type\", in_ty),\n-        };\n         require_simd!(arg_tys[1], \"argument\");\n-        let (v_len, _) = arg_tys[1].simd_size_and_type(bx.tcx());\n-        require!(\n-            // Allow masks for vectors with fewer than 8 elements to be\n-            // represented with a u8 or i8.\n-            m_len == v_len || (m_len == 8 && v_len < 8),\n-            \"mismatched lengths: mask length `{}` != other vector length `{}`\",\n-            m_len,\n-            v_len\n-        );\n+        let (len, _) = arg_tys[1].simd_size_and_type(bx.tcx());\n+\n+        let expected_int_bits = (len.max(8) - 1).next_power_of_two();\n+        let expected_bytes = len / 8 + ((len % 8 > 0) as u64);\n+\n+        let mask_ty = arg_tys[0];\n+        let mask = match mask_ty.kind() {\n+            ty::Int(i) if i.bit_width() == Some(expected_int_bits) => args[0].immediate(),\n+            ty::Uint(i) if i.bit_width() == Some(expected_int_bits) => args[0].immediate(),\n+            ty::Array(elem, len)\n+                if matches!(elem.kind(), ty::Uint(ty::UintTy::U8))\n+                    && len.try_eval_usize(bx.tcx, ty::ParamEnv::reveal_all())\n+                        == Some(expected_bytes) =>\n+            {\n+                let place = PlaceRef::alloca(bx, args[0].layout);\n+                args[0].val.store(bx, place);\n+                let int_ty = bx.type_ix(expected_bytes * 8);\n+                let ptr = bx.pointercast(place.llval, bx.cx.type_ptr_to(int_ty));\n+                bx.load(int_ty, ptr, Align::ONE)\n+            }\n+            _ => return_error!(\n+                \"invalid bitmask `{}`, expected `u{}` or `[u8; {}]`\",\n+                mask_ty,\n+                expected_int_bits,\n+                expected_bytes\n+            ),\n+        };\n+\n         let i1 = bx.type_i1();\n-        let im = bx.type_ix(v_len);\n-        let i1xn = bx.type_vector(i1, v_len);\n-        let m_im = bx.trunc(args[0].immediate(), im);\n+        let im = bx.type_ix(len);\n+        let i1xn = bx.type_vector(i1, len);\n+        let m_im = bx.trunc(mask, im);\n         let m_i1s = bx.bitcast(m_im, i1xn);\n         return Ok(bx.select(m_i1s, args[1].immediate(), args[2].immediate()));\n     }\n@@ -1056,16 +1067,16 @@ fn generic_simd_intrinsic(\n \n     if name == sym::simd_bitmask {\n         // The `fn simd_bitmask(vector) -> unsigned integer` intrinsic takes a\n-        // vector mask and returns an unsigned integer containing the most\n-        // significant bit (MSB) of each lane.\n-\n-        // If the vector has less than 8 lanes, a u8 is returned with zeroed\n-        // trailing bits.\n+        // vector mask and returns the most significant bit (MSB) of each lane in the form\n+        // of either:\n+        // * an unsigned integer\n+        // * an array of `u8`\n+        // If the vector has less than 8 lanes, a u8 is returned with zeroed trailing bits.\n+        //\n+        // The bit order of the result depends on the byte endianness, LSB-first for little\n+        // endian and MSB-first for big endian.\n         let expected_int_bits = in_len.max(8);\n-        match ret_ty.kind() {\n-            ty::Uint(i) if i.bit_width() == Some(expected_int_bits) => (),\n-            _ => return_error!(\"bitmask `{}`, expected `u{}`\", ret_ty, expected_int_bits),\n-        }\n+        let expected_bytes = expected_int_bits / 8 + ((expected_int_bits % 8 > 0) as u64);\n \n         // Integer vector <i{in_bitwidth} x in_len>:\n         let (i_xn, in_elem_bitwidth) = match in_elem.kind() {\n@@ -1095,8 +1106,34 @@ fn generic_simd_intrinsic(\n         let i1xn = bx.trunc(i_xn_msb, bx.type_vector(bx.type_i1(), in_len));\n         // Bitcast <i1 x N> to iN:\n         let i_ = bx.bitcast(i1xn, bx.type_ix(in_len));\n-        // Zero-extend iN to the bitmask type:\n-        return Ok(bx.zext(i_, bx.type_ix(expected_int_bits)));\n+\n+        match ret_ty.kind() {\n+            ty::Uint(i) if i.bit_width() == Some(expected_int_bits) => {\n+                // Zero-extend iN to the bitmask type:\n+                return Ok(bx.zext(i_, bx.type_ix(expected_int_bits)));\n+            }\n+            ty::Array(elem, len)\n+                if matches!(elem.kind(), ty::Uint(ty::UintTy::U8))\n+                    && len.try_eval_usize(bx.tcx, ty::ParamEnv::reveal_all())\n+                        == Some(expected_bytes) =>\n+            {\n+                // Zero-extend iN to the array lengh:\n+                let ze = bx.zext(i_, bx.type_ix(expected_bytes * 8));\n+\n+                // Convert the integer to a byte array\n+                let ptr = bx.alloca(bx.type_ix(expected_bytes * 8), Align::ONE);\n+                bx.store(ze, ptr, Align::ONE);\n+                let array_ty = bx.type_array(bx.type_i8(), expected_bytes);\n+                let ptr = bx.pointercast(ptr, bx.cx.type_ptr_to(array_ty));\n+                return Ok(bx.load(array_ty, ptr, Align::ONE));\n+            }\n+            _ => return_error!(\n+                \"cannot return `{}`, expected `u{}` or `[u8; {}]`\",\n+                ret_ty,\n+                expected_int_bits,\n+                expected_bytes\n+            ),\n+        }\n     }\n \n     fn simd_simple_float_intrinsic("}, {"sha": "9a23dae77b96e572084b590f04cb27b943dbc9f7", "filename": "src/test/ui/simd/intrinsic/generic-bitmask.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/858fea410d89986669c3613c63b5401abd72b891/src%2Ftest%2Fui%2Fsimd%2Fintrinsic%2Fgeneric-bitmask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/858fea410d89986669c3613c63b5401abd72b891/src%2Ftest%2Fui%2Fsimd%2Fintrinsic%2Fgeneric-bitmask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsimd%2Fintrinsic%2Fgeneric-bitmask.rs?ref=858fea410d89986669c3613c63b5401abd72b891", "patch": "@@ -51,19 +51,19 @@ fn main() {\n         let _: u64 = simd_bitmask(m64);\n \n         let _: u16 = simd_bitmask(m2);\n-        //~^ ERROR bitmask `u16`, expected `u8`\n+        //~^ ERROR invalid monomorphization of `simd_bitmask` intrinsic\n \n         let _: u16 = simd_bitmask(m8);\n-        //~^ ERROR bitmask `u16`, expected `u8`\n+        //~^ ERROR invalid monomorphization of `simd_bitmask` intrinsic\n \n         let _: u32 = simd_bitmask(m16);\n-        //~^ ERROR bitmask `u32`, expected `u16`\n+        //~^ ERROR invalid monomorphization of `simd_bitmask` intrinsic\n \n         let _: u64 = simd_bitmask(m32);\n-        //~^ ERROR bitmask `u64`, expected `u32`\n+        //~^ ERROR invalid monomorphization of `simd_bitmask` intrinsic\n \n         let _: u128 = simd_bitmask(m64);\n-        //~^ ERROR bitmask `u128`, expected `u64`\n+        //~^ ERROR invalid monomorphization of `simd_bitmask` intrinsic\n \n    }\n }"}, {"sha": "0de3f8eead86d12bf3fdb18e3e8e1d9ad1a70d4b", "filename": "src/test/ui/simd/intrinsic/generic-bitmask.stderr", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/858fea410d89986669c3613c63b5401abd72b891/src%2Ftest%2Fui%2Fsimd%2Fintrinsic%2Fgeneric-bitmask.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/858fea410d89986669c3613c63b5401abd72b891/src%2Ftest%2Fui%2Fsimd%2Fintrinsic%2Fgeneric-bitmask.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsimd%2Fintrinsic%2Fgeneric-bitmask.stderr?ref=858fea410d89986669c3613c63b5401abd72b891", "patch": "@@ -1,28 +1,28 @@\n-error[E0511]: invalid monomorphization of `simd_bitmask` intrinsic: bitmask `u16`, expected `u8`\n+error[E0511]: invalid monomorphization of `simd_bitmask` intrinsic: cannot return `u16`, expected `u8` or `[u8; 1]`\n   --> $DIR/generic-bitmask.rs:53:22\n    |\n LL |         let _: u16 = simd_bitmask(m2);\n    |                      ^^^^^^^^^^^^^^^^\n \n-error[E0511]: invalid monomorphization of `simd_bitmask` intrinsic: bitmask `u16`, expected `u8`\n+error[E0511]: invalid monomorphization of `simd_bitmask` intrinsic: cannot return `u16`, expected `u8` or `[u8; 1]`\n   --> $DIR/generic-bitmask.rs:56:22\n    |\n LL |         let _: u16 = simd_bitmask(m8);\n    |                      ^^^^^^^^^^^^^^^^\n \n-error[E0511]: invalid monomorphization of `simd_bitmask` intrinsic: bitmask `u32`, expected `u16`\n+error[E0511]: invalid monomorphization of `simd_bitmask` intrinsic: cannot return `u32`, expected `u16` or `[u8; 2]`\n   --> $DIR/generic-bitmask.rs:59:22\n    |\n LL |         let _: u32 = simd_bitmask(m16);\n    |                      ^^^^^^^^^^^^^^^^^\n \n-error[E0511]: invalid monomorphization of `simd_bitmask` intrinsic: bitmask `u64`, expected `u32`\n+error[E0511]: invalid monomorphization of `simd_bitmask` intrinsic: cannot return `u64`, expected `u32` or `[u8; 4]`\n   --> $DIR/generic-bitmask.rs:62:22\n    |\n LL |         let _: u64 = simd_bitmask(m32);\n    |                      ^^^^^^^^^^^^^^^^^\n \n-error[E0511]: invalid monomorphization of `simd_bitmask` intrinsic: bitmask `u128`, expected `u64`\n+error[E0511]: invalid monomorphization of `simd_bitmask` intrinsic: cannot return `u128`, expected `u64` or `[u8; 8]`\n   --> $DIR/generic-bitmask.rs:65:23\n    |\n LL |         let _: u128 = simd_bitmask(m64);"}, {"sha": "248e82ea21cfce6ec8aefcbb44b0ca8c093cfc46", "filename": "src/test/ui/simd/intrinsic/generic-select.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/858fea410d89986669c3613c63b5401abd72b891/src%2Ftest%2Fui%2Fsimd%2Fintrinsic%2Fgeneric-select.rs", "raw_url": "https://github.com/rust-lang/rust/raw/858fea410d89986669c3613c63b5401abd72b891/src%2Ftest%2Fui%2Fsimd%2Fintrinsic%2Fgeneric-select.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsimd%2Fintrinsic%2Fgeneric-select.rs?ref=858fea410d89986669c3613c63b5401abd72b891", "patch": "@@ -20,8 +20,7 @@ struct b8x4(pub i8, pub i8, pub i8, pub i8);\n \n #[repr(simd)]\n #[derive(Copy, Clone, PartialEq)]\n-struct b8x8(pub i8, pub i8, pub i8, pub i8,\n-            pub i8, pub i8, pub i8, pub i8);\n+struct b8x8(pub i8, pub i8, pub i8, pub i8, pub i8, pub i8, pub i8, pub i8);\n \n extern \"platform-intrinsic\" {\n     fn simd_select<T, U>(x: T, a: U, b: U) -> U;\n@@ -50,15 +49,15 @@ fn main() {\n         //~^ ERROR found non-SIMD `u32`\n \n         simd_select_bitmask(0u16, x, x);\n-        //~^ ERROR mask length `16` != other vector length `4`\n-        //\n+        //~^ ERROR invalid bitmask `u16`, expected `u8` or `[u8; 1]`\n+\n         simd_select_bitmask(0u8, 1u32, 2u32);\n         //~^ ERROR found non-SIMD `u32`\n \n         simd_select_bitmask(0.0f32, x, x);\n-        //~^ ERROR `f32` is not an integral type\n+        //~^ ERROR invalid bitmask `f32`, expected `u8` or `[u8; 1]`\n \n         simd_select_bitmask(\"x\", x, x);\n-        //~^ ERROR `&str` is not an integral type\n+        //~^ ERROR invalid bitmask `&str`, expected `u8` or `[u8; 1]`\n     }\n }"}, {"sha": "d576f1bc77473fc2216b3cfe28ffe3a84d75fc15", "filename": "src/test/ui/simd/intrinsic/generic-select.stderr", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/858fea410d89986669c3613c63b5401abd72b891/src%2Ftest%2Fui%2Fsimd%2Fintrinsic%2Fgeneric-select.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/858fea410d89986669c3613c63b5401abd72b891/src%2Ftest%2Fui%2Fsimd%2Fintrinsic%2Fgeneric-select.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsimd%2Fintrinsic%2Fgeneric-select.stderr?ref=858fea410d89986669c3613c63b5401abd72b891", "patch": "@@ -1,47 +1,47 @@\n error[E0511]: invalid monomorphization of `simd_select` intrinsic: mismatched lengths: mask length `8` != other vector length `4`\n-  --> $DIR/generic-select.rs:40:9\n+  --> $DIR/generic-select.rs:39:9\n    |\n LL |         simd_select(m8, x, x);\n    |         ^^^^^^^^^^^^^^^^^^^^^\n \n error[E0511]: invalid monomorphization of `simd_select` intrinsic: mask element type is `u32`, expected `i_`\n-  --> $DIR/generic-select.rs:43:9\n+  --> $DIR/generic-select.rs:42:9\n    |\n LL |         simd_select(x, x, x);\n    |         ^^^^^^^^^^^^^^^^^^^^\n \n error[E0511]: invalid monomorphization of `simd_select` intrinsic: mask element type is `f32`, expected `i_`\n-  --> $DIR/generic-select.rs:46:9\n+  --> $DIR/generic-select.rs:45:9\n    |\n LL |         simd_select(z, z, z);\n    |         ^^^^^^^^^^^^^^^^^^^^\n \n error[E0511]: invalid monomorphization of `simd_select` intrinsic: expected SIMD argument type, found non-SIMD `u32`\n-  --> $DIR/generic-select.rs:49:9\n+  --> $DIR/generic-select.rs:48:9\n    |\n LL |         simd_select(m4, 0u32, 1u32);\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error[E0511]: invalid monomorphization of `simd_select_bitmask` intrinsic: mismatched lengths: mask length `16` != other vector length `4`\n-  --> $DIR/generic-select.rs:52:9\n+error[E0511]: invalid monomorphization of `simd_select_bitmask` intrinsic: invalid bitmask `u16`, expected `u8` or `[u8; 1]`\n+  --> $DIR/generic-select.rs:51:9\n    |\n LL |         simd_select_bitmask(0u16, x, x);\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error[E0511]: invalid monomorphization of `simd_select_bitmask` intrinsic: expected SIMD argument type, found non-SIMD `u32`\n-  --> $DIR/generic-select.rs:55:9\n+  --> $DIR/generic-select.rs:54:9\n    |\n LL |         simd_select_bitmask(0u8, 1u32, 2u32);\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error[E0511]: invalid monomorphization of `simd_select_bitmask` intrinsic: `f32` is not an integral type\n-  --> $DIR/generic-select.rs:58:9\n+error[E0511]: invalid monomorphization of `simd_select_bitmask` intrinsic: invalid bitmask `f32`, expected `u8` or `[u8; 1]`\n+  --> $DIR/generic-select.rs:57:9\n    |\n LL |         simd_select_bitmask(0.0f32, x, x);\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error[E0511]: invalid monomorphization of `simd_select_bitmask` intrinsic: `&str` is not an integral type\n-  --> $DIR/generic-select.rs:61:9\n+error[E0511]: invalid monomorphization of `simd_select_bitmask` intrinsic: invalid bitmask `&str`, expected `u8` or `[u8; 1]`\n+  --> $DIR/generic-select.rs:60:9\n    |\n LL |         simd_select_bitmask(\"x\", x, x);\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"}, {"sha": "14ee2e741bdfdda5e519bda7d740bfac2af64d27", "filename": "src/test/ui/simd/simd-bitmask.rs", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/858fea410d89986669c3613c63b5401abd72b891/src%2Ftest%2Fui%2Fsimd%2Fsimd-bitmask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/858fea410d89986669c3613c63b5401abd72b891/src%2Ftest%2Fui%2Fsimd%2Fsimd-bitmask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsimd%2Fsimd-bitmask.rs?ref=858fea410d89986669c3613c63b5401abd72b891", "patch": "@@ -0,0 +1,52 @@\n+//run-pass\n+//ignore-endian-big behavior of simd_select_bitmask is endian-specific\n+#![feature(repr_simd, platform_intrinsics)]\n+\n+extern \"platform-intrinsic\" {\n+    fn simd_bitmask<T, U>(v: T) -> U;\n+    fn simd_select_bitmask<T, U>(m: T, a: U, b: U) -> U;\n+}\n+\n+#[derive(Copy, Clone)]\n+#[repr(simd)]\n+struct Simd<T, const N: usize>([T; N]);\n+\n+fn main() {\n+    unsafe {\n+        let v = Simd::<i8, 4>([-1, 0, -1, 0]);\n+        let i: u8 = simd_bitmask(v);\n+        let a: [u8; 1] = simd_bitmask(v);\n+\n+        assert_eq!(i, 0b0101);\n+        assert_eq!(a, [0b0101]);\n+\n+        let v = Simd::<i8, 16>([0, 0, -1, -1, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, -1, 0]);\n+        let i: u16 = simd_bitmask(v);\n+        let a: [u8; 2] = simd_bitmask(v);\n+\n+        assert_eq!(i, 0b0101000000001100);\n+        assert_eq!(a, [0b1100, 0b01010000]);\n+    }\n+\n+    unsafe {\n+        let a = Simd::<i32, 8>([0, 1, 2, 3, 4, 5, 6, 7]);\n+        let b = Simd::<i32, 8>([8, 9, 10, 11, 12, 13, 14, 15]);\n+        let e = [0, 9, 2, 11, 12, 13, 14, 15];\n+\n+        let r = simd_select_bitmask(0b0101u8, a, b);\n+        assert_eq!(r.0, e);\n+\n+        let r = simd_select_bitmask([0b0101u8], a, b);\n+        assert_eq!(r.0, e);\n+\n+        let a = Simd::<i32, 16>([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]);\n+        let b = Simd::<i32, 16>([16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31]);\n+        let e = [16, 17, 2, 3, 20, 21, 22, 23, 24, 25, 26, 27, 12, 29, 14, 31];\n+\n+        let r = simd_select_bitmask(0b0101000000001100u16, a, b);\n+        assert_eq!(r.0, e);\n+\n+        let r = simd_select_bitmask([0b1100u8, 0b01010000u8], a, b);\n+        assert_eq!(r.0, e);\n+    }\n+}"}]}