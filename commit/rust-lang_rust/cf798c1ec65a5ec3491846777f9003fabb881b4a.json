{"sha": "cf798c1ec65a5ec3491846777f9003fabb881b4a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNmNzk4YzFlYzY1YTVlYzM0OTE4NDY3NzdmOTAwM2ZhYmI4ODFiNGE=", "commit": {"author": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2020-10-15T12:23:43Z"}, "committer": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2020-10-26T08:52:59Z"}, "message": "Add support for using cg_clif to bootstrap rustc", "tree": {"sha": "7b1729074a6a93415c55000d1b992ed350258474", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7b1729074a6a93415c55000d1b992ed350258474"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cf798c1ec65a5ec3491846777f9003fabb881b4a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cf798c1ec65a5ec3491846777f9003fabb881b4a", "html_url": "https://github.com/rust-lang/rust/commit/cf798c1ec65a5ec3491846777f9003fabb881b4a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cf798c1ec65a5ec3491846777f9003fabb881b4a/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "596b0d5027bfb1b5835e17a25f56b00a1f6ff95f", "url": "https://api.github.com/repos/rust-lang/rust/commits/596b0d5027bfb1b5835e17a25f56b00a1f6ff95f", "html_url": "https://github.com/rust-lang/rust/commit/596b0d5027bfb1b5835e17a25f56b00a1f6ff95f"}], "stats": {"total": 471, "additions": 432, "deletions": 39}, "files": [{"sha": "c27e5c469cf4be5ccd7fe680fccae369af9b1788", "filename": "Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cf798c1ec65a5ec3491846777f9003fabb881b4a/Cargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/cf798c1ec65a5ec3491846777f9003fabb881b4a/Cargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.toml?ref=cf798c1ec65a5ec3491846777f9003fabb881b4a", "patch": "@@ -31,6 +31,7 @@ members = [\n ]\n exclude = [\n   \"build\",\n+  \"compiler/rustc_codegen_cranelift\",\n   # HACK(eddyb) This hardcodes the fact that our CI uses `/checkout/obj`.\n   \"obj\",\n ]"}, {"sha": "a0edf55eeb2983fb369fcf8baa82485a6eb1624a", "filename": "compiler/rustc_driver/src/lib.rs", "status": "modified", "additions": 12, "deletions": 23, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/cf798c1ec65a5ec3491846777f9003fabb881b4a/compiler%2Frustc_driver%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf798c1ec65a5ec3491846777f9003fabb881b4a/compiler%2Frustc_driver%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_driver%2Fsrc%2Flib.rs?ref=cf798c1ec65a5ec3491846777f9003fabb881b4a", "patch": "@@ -22,7 +22,7 @@ use rustc_errors::registry::{InvalidErrorCode, Registry};\n use rustc_errors::{ErrorReported, PResult};\n use rustc_feature::{find_gated_cfg, UnstableFeatures};\n use rustc_hir::def_id::LOCAL_CRATE;\n-use rustc_interface::util::{collect_crate_types, get_builtin_codegen_backend};\n+use rustc_interface::util::{self, collect_crate_types, get_builtin_codegen_backend};\n use rustc_interface::{interface, Queries};\n use rustc_lint::LintStore;\n use rustc_metadata::locator;\n@@ -793,37 +793,24 @@ impl RustcDefaultCalls {\n     }\n }\n \n-/// Returns a version string such as \"0.12.0-dev\".\n-fn release_str() -> Option<&'static str> {\n-    option_env!(\"CFG_RELEASE\")\n-}\n-\n-/// Returns the full SHA1 hash of HEAD of the Git repo from which rustc was built.\n-fn commit_hash_str() -> Option<&'static str> {\n-    option_env!(\"CFG_VER_HASH\")\n-}\n-\n-/// Returns the \"commit date\" of HEAD of the Git repo from which rustc was built as a static string.\n-fn commit_date_str() -> Option<&'static str> {\n-    option_env!(\"CFG_VER_DATE\")\n-}\n-\n /// Prints version information\n pub fn version(binary: &str, matches: &getopts::Matches) {\n     let verbose = matches.opt_present(\"verbose\");\n \n-    println!(\"{} {}\", binary, option_env!(\"CFG_VERSION\").unwrap_or(\"unknown version\"));\n+    println!(\"{} {}\", binary, util::version_str().unwrap_or(\"unknown version\"));\n \n     if verbose {\n         fn unw(x: Option<&str>) -> &str {\n             x.unwrap_or(\"unknown\")\n         }\n         println!(\"binary: {}\", binary);\n-        println!(\"commit-hash: {}\", unw(commit_hash_str()));\n-        println!(\"commit-date: {}\", unw(commit_date_str()));\n+        println!(\"commit-hash: {}\", unw(util::commit_hash_str()));\n+        println!(\"commit-date: {}\", unw(util::commit_date_str()));\n         println!(\"host: {}\", config::host_triple());\n-        println!(\"release: {}\", unw(release_str()));\n-        get_builtin_codegen_backend(\"llvm\")().print_version();\n+        println!(\"release: {}\", unw(util::release_str()));\n+        if cfg!(llvm) {\n+            get_builtin_codegen_backend(\"llvm\")().print_version();\n+        }\n     }\n }\n \n@@ -1109,7 +1096,9 @@ pub fn handle_options(args: &[String]) -> Option<getopts::Matches> {\n     }\n \n     if cg_flags.iter().any(|x| *x == \"passes=list\") {\n-        get_builtin_codegen_backend(\"llvm\")().print_passes();\n+        if cfg!(llvm) {\n+            get_builtin_codegen_backend(\"llvm\")().print_passes();\n+        }\n         return None;\n     }\n \n@@ -1237,7 +1226,7 @@ pub fn report_ice(info: &panic::PanicInfo<'_>, bug_report_url: &str) {\n         format!(\"we would appreciate a bug report: {}\", bug_report_url).into(),\n         format!(\n             \"rustc {} running on {}\",\n-            option_env!(\"CFG_VERSION\").unwrap_or(\"unknown_version\"),\n+            util::version_str().unwrap_or(\"unknown_version\"),\n             config::host_triple()\n         )\n         .into(),"}, {"sha": "7658ffb0e3d9bb16a5ec383492c41994aa101e9b", "filename": "compiler/rustc_interface/src/util.rs", "status": "modified", "additions": 128, "deletions": 7, "changes": 135, "blob_url": "https://github.com/rust-lang/rust/blob/cf798c1ec65a5ec3491846777f9003fabb881b4a/compiler%2Frustc_interface%2Fsrc%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf798c1ec65a5ec3491846777f9003fabb881b4a/compiler%2Frustc_interface%2Fsrc%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Futil.rs?ref=cf798c1ec65a5ec3491846777f9003fabb881b4a", "patch": "@@ -24,11 +24,13 @@ use rustc_span::source_map::FileLoader;\n use rustc_span::symbol::{sym, Symbol};\n use smallvec::SmallVec;\n use std::env;\n+use std::env::consts::{DLL_PREFIX, DLL_SUFFIX};\n use std::io::{self, Write};\n use std::lazy::SyncOnceCell;\n use std::mem;\n use std::ops::DerefMut;\n use std::path::{Path, PathBuf};\n+use std::sync::atomic::{AtomicBool, Ordering};\n use std::sync::{Arc, Mutex, Once};\n #[cfg(not(parallel_compiler))]\n use std::{panic, thread};\n@@ -238,7 +240,19 @@ pub fn get_codegen_backend(sopts: &config::Options) -> Box<dyn CodegenBackend> {\n     static mut LOAD: fn() -> Box<dyn CodegenBackend> = || unreachable!();\n \n     INIT.call_once(|| {\n-        let codegen_name = sopts.debugging_opts.codegen_backend.as_deref().unwrap_or(\"llvm\");\n+        #[cfg(feature = \"llvm\")]\n+        const DEFAULT_CODEGEN_BACKEND: &'static str = \"llvm\";\n+\n+        #[cfg(not(feature = \"llvm\"))]\n+        const DEFAULT_CODEGEN_BACKEND: &'static str = \"cranelift\";\n+\n+        let codegen_name = sopts\n+            .debugging_opts\n+            .codegen_backend\n+            .as_ref()\n+            .map(|name| &name[..])\n+            .unwrap_or(DEFAULT_CODEGEN_BACKEND);\n+\n         let backend = match codegen_name {\n             filename if filename.contains('.') => load_backend_from_dylib(filename.as_ref()),\n             codegen_name => get_builtin_codegen_backend(codegen_name),\n@@ -367,15 +381,102 @@ fn sysroot_candidates() -> Vec<PathBuf> {\n }\n \n pub fn get_builtin_codegen_backend(backend_name: &str) -> fn() -> Box<dyn CodegenBackend> {\n-    #[cfg(feature = \"llvm\")]\n-    {\n-        if backend_name == \"llvm\" {\n-            return rustc_codegen_llvm::LlvmCodegenBackend::new;\n+    match backend_name {\n+        #[cfg(feature = \"llvm\")]\n+        \"llvm\" => rustc_codegen_llvm::LlvmCodegenBackend::new,\n+        _ => get_codegen_sysroot(backend_name),\n+    }\n+}\n+\n+pub fn get_codegen_sysroot(backend_name: &str) -> fn() -> Box<dyn CodegenBackend> {\n+    // For now we only allow this function to be called once as it'll dlopen a\n+    // few things, which seems to work best if we only do that once. In\n+    // general this assertion never trips due to the once guard in `get_codegen_backend`,\n+    // but there's a few manual calls to this function in this file we protect\n+    // against.\n+    static LOADED: AtomicBool = AtomicBool::new(false);\n+    assert!(\n+        !LOADED.fetch_or(true, Ordering::SeqCst),\n+        \"cannot load the default codegen backend twice\"\n+    );\n+\n+    let target = session::config::host_triple();\n+    let sysroot_candidates = sysroot_candidates();\n+\n+    let sysroot = sysroot_candidates\n+        .iter()\n+        .map(|sysroot| {\n+            let libdir = filesearch::relative_target_lib_path(&sysroot, &target);\n+            sysroot.join(libdir).with_file_name(\"codegen-backends\")\n+        })\n+        .filter(|f| {\n+            info!(\"codegen backend candidate: {}\", f.display());\n+            f.exists()\n+        })\n+        .next();\n+    let sysroot = sysroot.unwrap_or_else(|| {\n+        let candidates = sysroot_candidates\n+            .iter()\n+            .map(|p| p.display().to_string())\n+            .collect::<Vec<_>>()\n+            .join(\"\\n* \");\n+        let err = format!(\n+            \"failed to find a `codegen-backends` folder \\\n+                           in the sysroot candidates:\\n* {}\",\n+            candidates\n+        );\n+        early_error(ErrorOutputType::default(), &err);\n+    });\n+    info!(\"probing {} for a codegen backend\", sysroot.display());\n+\n+    let d = sysroot.read_dir().unwrap_or_else(|e| {\n+        let err = format!(\n+            \"failed to load default codegen backend, couldn't \\\n+                           read `{}`: {}\",\n+            sysroot.display(),\n+            e\n+        );\n+        early_error(ErrorOutputType::default(), &err);\n+    });\n+\n+    let mut file: Option<PathBuf> = None;\n+\n+    let expected_name =\n+        format!(\"rustc_codegen_{}-{}\", backend_name, release_str().expect(\"CFG_RELEASE\"));\n+    for entry in d.filter_map(|e| e.ok()) {\n+        let path = entry.path();\n+        let filename = match path.file_name().and_then(|s| s.to_str()) {\n+            Some(s) => s,\n+            None => continue,\n+        };\n+        if !(filename.starts_with(DLL_PREFIX) && filename.ends_with(DLL_SUFFIX)) {\n+            continue;\n         }\n+        let name = &filename[DLL_PREFIX.len()..filename.len() - DLL_SUFFIX.len()];\n+        if name != expected_name {\n+            continue;\n+        }\n+        if let Some(ref prev) = file {\n+            let err = format!(\n+                \"duplicate codegen backends found\\n\\\n+                               first:  {}\\n\\\n+                               second: {}\\n\\\n+            \",\n+                prev.display(),\n+                path.display()\n+            );\n+            early_error(ErrorOutputType::default(), &err);\n+        }\n+        file = Some(path.clone());\n     }\n \n-    let err = format!(\"unsupported builtin codegen backend `{}`\", backend_name);\n-    early_error(ErrorOutputType::default(), &err);\n+    match file {\n+        Some(ref s) => load_backend_from_dylib(s),\n+        None => {\n+            let err = format!(\"unsupported builtin codegen backend `{}`\", backend_name);\n+            early_error(ErrorOutputType::default(), &err);\n+        }\n+    }\n }\n \n pub(crate) fn compute_crate_disambiguator(session: &Session) -> CrateDisambiguator {\n@@ -782,3 +883,23 @@ impl<'a> MutVisitor for ReplaceBodyWithLoop<'a, '_> {\n         noop_visit_mac(mac, self)\n     }\n }\n+\n+/// Returns a version string such as \"rustc 1.46.0 (04488afe3 2020-08-24)\"\n+pub fn version_str() -> Option<&'static str> {\n+    option_env!(\"CFG_VERSION\")\n+}\n+\n+/// Returns a version string such as \"0.12.0-dev\".\n+pub fn release_str() -> Option<&'static str> {\n+    option_env!(\"CFG_RELEASE\")\n+}\n+\n+/// Returns the full SHA1 hash of HEAD of the Git repo from which rustc was built.\n+pub fn commit_hash_str() -> Option<&'static str> {\n+    option_env!(\"CFG_VER_HASH\")\n+}\n+\n+/// Returns the \"commit date\" of HEAD of the Git repo from which rustc was built as a static string.\n+pub fn commit_date_str() -> Option<&'static str> {\n+    option_env!(\"CFG_VER_DATE\")\n+}"}, {"sha": "8027d7a118fb4b2fbf4179ba4cfc91978c13486e", "filename": "config.toml.example", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cf798c1ec65a5ec3491846777f9003fabb881b4a/config.toml.example", "raw_url": "https://github.com/rust-lang/rust/raw/cf798c1ec65a5ec3491846777f9003fabb881b4a/config.toml.example", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/config.toml.example?ref=cf798c1ec65a5ec3491846777f9003fabb881b4a", "patch": "@@ -478,7 +478,7 @@ changelog-seen = 2\n \n # This is an array of the codegen backends that will be compiled for the rustc\n # that's being compiled. The default is to only build the LLVM codegen backend,\n-# and currently the only standard option supported is `\"llvm\"`\n+# and currently the only standard options supported are `\"llvm\"` and `\"cranelift\"`.\n #codegen-backends = [\"llvm\"]\n \n # Indicates whether LLD will be compiled and made available in the sysroot for"}, {"sha": "2b1c516cf7720aa947f5014062ee934eb8031b1c", "filename": "rustfmt.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cf798c1ec65a5ec3491846777f9003fabb881b4a/rustfmt.toml", "raw_url": "https://github.com/rust-lang/rust/raw/cf798c1ec65a5ec3491846777f9003fabb881b4a/rustfmt.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/rustfmt.toml?ref=cf798c1ec65a5ec3491846777f9003fabb881b4a", "patch": "@@ -16,6 +16,7 @@ ignore = [\n     # do not format submodules\n     \"library/backtrace\",\n     \"library/stdarch\",\n+    \"compiler/rustc_codegen_cranelift\",\n     \"src/doc/book\",\n     \"src/doc/edition-guide\",\n     \"src/doc/embedded-book\","}, {"sha": "0e246b652c295a1069cd1ed31af0388092386534", "filename": "src/bootstrap/bootstrap.py", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cf798c1ec65a5ec3491846777f9003fabb881b4a/src%2Fbootstrap%2Fbootstrap.py", "raw_url": "https://github.com/rust-lang/rust/raw/cf798c1ec65a5ec3491846777f9003fabb881b4a/src%2Fbootstrap%2Fbootstrap.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbootstrap.py?ref=cf798c1ec65a5ec3491846777f9003fabb881b4a", "patch": "@@ -962,8 +962,12 @@ def ensure_vendored(self):\n         # the rust git repository is updated. Normal development usually does\n         # not use vendoring, so hopefully this isn't too much of a problem.\n         if self.use_vendored_sources and not os.path.exists(vendor_dir):\n-            run([self.cargo(), \"vendor\", \"--sync=./src/tools/rust-analyzer/Cargo.toml\"],\n-                verbose=self.verbose, cwd=self.rust_root)\n+            run([\n+                self.cargo(),\n+                \"vendor\",\n+                \"--sync=./src/tools/rust-analyzer/Cargo.toml\",\n+                \"--sync=./compiler/rustc_codegen_cranelift/Cargo.toml\",\n+            ], verbose=self.verbose, cwd=self.rust_root)\n \n \n def bootstrap(help_triggered):"}, {"sha": "dc4243a76d5dafd9e3d7e80c2a844332ce723876", "filename": "src/bootstrap/builder.rs", "status": "modified", "additions": 32, "deletions": 5, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/cf798c1ec65a5ec3491846777f9003fabb881b4a/src%2Fbootstrap%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf798c1ec65a5ec3491846777f9003fabb881b4a/src%2Fbootstrap%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder.rs?ref=cf798c1ec65a5ec3491846777f9003fabb881b4a", "patch": "@@ -344,6 +344,7 @@ impl<'a> Builder<'a> {\n             Kind::Build => describe!(\n                 compile::Std,\n                 compile::Rustc,\n+                compile::CodegenBackend,\n                 compile::StartupObjects,\n                 tool::BuildManifest,\n                 tool::Rustbook,\n@@ -370,9 +371,14 @@ impl<'a> Builder<'a> {\n                 tool::CargoMiri,\n                 native::Lld\n             ),\n-            Kind::Check | Kind::Clippy | Kind::Fix | Kind::Format => {\n-                describe!(check::Std, check::Rustc, check::Rustdoc, check::Clippy, check::Bootstrap)\n-            }\n+            Kind::Check | Kind::Clippy | Kind::Fix | Kind::Format => describe!(\n+                check::Std,\n+                check::Rustc,\n+                check::Rustdoc,\n+                check::CodegenBackend,\n+                check::Clippy,\n+                check::Bootstrap\n+            ),\n             Kind::Test => describe!(\n                 crate::toolstate::ToolStateCheck,\n                 test::ExpandYamlAnchors,\n@@ -630,6 +636,10 @@ impl<'a> Builder<'a> {\n         self.ensure(Libdir { compiler, target })\n     }\n \n+    pub fn sysroot_codegen_backends(&self, compiler: Compiler) -> PathBuf {\n+        self.sysroot_libdir(compiler, compiler.host).with_file_name(\"codegen-backends\")\n+    }\n+\n     /// Returns the compiler's libdir where it stores the dynamic libraries that\n     /// it itself links against.\n     ///\n@@ -698,6 +708,15 @@ impl<'a> Builder<'a> {\n         }\n     }\n \n+    /// Gets the paths to all of the compiler's codegen backends.\n+    fn codegen_backends(&self, compiler: Compiler) -> impl Iterator<Item = PathBuf> {\n+        fs::read_dir(self.sysroot_codegen_backends(compiler))\n+            .into_iter()\n+            .flatten()\n+            .filter_map(Result::ok)\n+            .map(|entry| entry.path())\n+    }\n+\n     pub fn rustdoc(&self, compiler: Compiler) -> PathBuf {\n         self.ensure(tool::Rustdoc { compiler })\n     }\n@@ -762,6 +781,12 @@ impl<'a> Builder<'a> {\n         let mut cargo = Command::new(&self.initial_cargo);\n         let out_dir = self.stage_out(compiler, mode);\n \n+        // Codegen backends are not yet tracked by -Zbinary-dep-depinfo,\n+        // so we need to explicitly clear out if they've been updated.\n+        for backend in self.codegen_backends(compiler) {\n+            self.clear_if_dirty(&out_dir, &backend);\n+        }\n+\n         if cmd == \"doc\" || cmd == \"rustdoc\" {\n             let my_out = match mode {\n                 // This is the intended out directory for compiler documentation.\n@@ -843,7 +868,7 @@ impl<'a> Builder<'a> {\n \n         match mode {\n             Mode::Std | Mode::ToolBootstrap | Mode::ToolStd => {}\n-            Mode::Rustc | Mode::ToolRustc => {\n+            Mode::Rustc | Mode::Codegen | Mode::ToolRustc => {\n                 // Build proc macros both for the host and the target\n                 if target != compiler.host && cmd != \"check\" {\n                     cargo.arg(\"-Zdual-proc-macros\");\n@@ -904,6 +929,8 @@ impl<'a> Builder<'a> {\n             // problem, somehow -- not really clear why -- but we know that this\n             // fixes things.\n             Mode::ToolRustc => metadata.push_str(\"tool-rustc\"),\n+            // Same for codegen backends.\n+            Mode::Codegen => metadata.push_str(\"codegen\"),\n             _ => {}\n         }\n         cargo.env(\"__CARGO_DEFAULT_LIB_METADATA\", &metadata);\n@@ -1030,7 +1057,7 @@ impl<'a> Builder<'a> {\n         }\n \n         let debuginfo_level = match mode {\n-            Mode::Rustc => self.config.rust_debuginfo_level_rustc,\n+            Mode::Rustc | Mode::Codegen => self.config.rust_debuginfo_level_rustc,\n             Mode::Std => self.config.rust_debuginfo_level_std,\n             Mode::ToolBootstrap | Mode::ToolStd | Mode::ToolRustc => {\n                 self.config.rust_debuginfo_level_tools"}, {"sha": "443a490e342d5b4fac4a6855083c222807a9b3a1", "filename": "src/bootstrap/check.rs", "status": "modified", "additions": 67, "deletions": 1, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/cf798c1ec65a5ec3491846777f9003fabb881b4a/src%2Fbootstrap%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf798c1ec65a5ec3491846777f9003fabb881b4a/src%2Fbootstrap%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcheck.rs?ref=cf798c1ec65a5ec3491846777f9003fabb881b4a", "patch": "@@ -1,8 +1,10 @@\n //! Implementation of compiling the compiler and standard library, in \"check\"-based modes.\n \n-use crate::compile::{add_to_sysroot, run_cargo, rustc_cargo, std_cargo};\n+use crate::cache::Interned;\n+use crate::compile::{add_to_sysroot, run_cargo, rustc_cargo, rustc_cargo_env, std_cargo};\n use crate::config::TargetSelection;\n use crate::tool::{prepare_tool_cargo, SourceType};\n+use crate::INTERNER;\n use crate::{\n     builder::{Builder, Kind, RunConfig, ShouldRun, Step},\n     Subcommand,\n@@ -175,6 +177,57 @@ impl Step for Rustc {\n     }\n }\n \n+#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n+pub struct CodegenBackend {\n+    pub target: TargetSelection,\n+    pub backend: Interned<String>,\n+}\n+\n+impl Step for CodegenBackend {\n+    type Output = ();\n+    const ONLY_HOSTS: bool = true;\n+    const DEFAULT: bool = true;\n+\n+    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n+        run.paths(&[\"compiler/rustc_codegen_cranelift\", \"rustc_codegen_cranelift\"])\n+    }\n+\n+    fn make_run(run: RunConfig<'_>) {\n+        for &backend in &[INTERNER.intern_str(\"cranelift\")] {\n+            run.builder.ensure(CodegenBackend { target: run.target, backend });\n+        }\n+    }\n+\n+    fn run(self, builder: &Builder<'_>) {\n+        let compiler = builder.compiler(0, builder.config.build);\n+        let target = self.target;\n+        let backend = self.backend;\n+\n+        builder.ensure(Rustc { target });\n+\n+        let mut cargo = builder.cargo(\n+            compiler,\n+            Mode::Codegen,\n+            SourceType::Submodule,\n+            target,\n+            cargo_subcommand(builder.kind),\n+        );\n+        cargo\n+            .arg(\"--manifest-path\")\n+            .arg(builder.src.join(format!(\"compiler/rustc_codegen_{}/Cargo.toml\", backend)));\n+        rustc_cargo_env(builder, &mut cargo, target);\n+\n+        run_cargo(\n+            builder,\n+            cargo,\n+            args(builder.kind),\n+            &codegen_backend_stamp(builder, compiler, target, backend),\n+            vec![],\n+            true,\n+        );\n+    }\n+}\n+\n macro_rules! tool_check_step {\n     ($name:ident, $path:expr, $source_type:expr) => {\n         #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n@@ -281,3 +334,16 @@ fn libstd_test_stamp(\n fn librustc_stamp(builder: &Builder<'_>, compiler: Compiler, target: TargetSelection) -> PathBuf {\n     builder.cargo_out(compiler, Mode::Rustc, target).join(\".librustc-check.stamp\")\n }\n+\n+/// Cargo's output path for librustc_codegen_llvm in a given stage, compiled by a particular\n+/// compiler for the specified target and backend.\n+fn codegen_backend_stamp(\n+    builder: &Builder<'_>,\n+    compiler: Compiler,\n+    target: TargetSelection,\n+    backend: Interned<String>,\n+) -> PathBuf {\n+    builder\n+        .cargo_out(compiler, Mode::Codegen, target)\n+        .join(format!(\".librustc_codegen_{}-check.stamp\", backend))\n+}"}, {"sha": "ed9b91085863f032a470ce9a3268c1b63a32906f", "filename": "src/bootstrap/compile.rs", "status": "modified", "additions": 165, "deletions": 0, "changes": 165, "blob_url": "https://github.com/rust-lang/rust/blob/cf798c1ec65a5ec3491846777f9003fabb881b4a/src%2Fbootstrap%2Fcompile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf798c1ec65a5ec3491846777f9003fabb881b4a/src%2Fbootstrap%2Fcompile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcompile.rs?ref=cf798c1ec65a5ec3491846777f9003fabb881b4a", "patch": "@@ -640,6 +640,144 @@ impl Step for RustcLink {\n     }\n }\n \n+#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n+pub struct CodegenBackend {\n+    pub target: TargetSelection,\n+    pub compiler: Compiler,\n+    pub backend: Interned<String>,\n+}\n+\n+impl Step for CodegenBackend {\n+    type Output = ();\n+    const ONLY_HOSTS: bool = true;\n+    // Only the backends specified in the `codegen-backends` entry of `config.toml` are built.\n+    const DEFAULT: bool = true;\n+\n+    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n+        run.path(\"compiler/rustc_codegen_cranelift\")\n+    }\n+\n+    fn make_run(run: RunConfig<'_>) {\n+        for &backend in &run.builder.config.rust_codegen_backends {\n+            if backend == \"llvm\" {\n+                continue; // Already built as part of rustc\n+            }\n+\n+            run.builder.ensure(CodegenBackend {\n+                target: run.target,\n+                compiler: run.builder.compiler(run.builder.top_stage, run.build_triple()),\n+                backend,\n+            });\n+        }\n+    }\n+\n+    fn run(self, builder: &Builder<'_>) {\n+        let compiler = self.compiler;\n+        let target = self.target;\n+        let backend = self.backend;\n+\n+        builder.ensure(Rustc { compiler, target });\n+\n+        if builder.config.keep_stage.contains(&compiler.stage) {\n+            builder.info(\n+                \"Warning: Using a potentially old codegen backend. \\\n+                This may not behave well.\",\n+            );\n+            // Codegen backends are linked separately from this step today, so we don't do\n+            // anything here.\n+            return;\n+        }\n+\n+        let compiler_to_use = builder.compiler_for(compiler.stage, compiler.host, target);\n+        if compiler_to_use != compiler {\n+            builder.ensure(CodegenBackend { compiler: compiler_to_use, target, backend });\n+            return;\n+        }\n+\n+        let out_dir = builder.cargo_out(compiler, Mode::Codegen, target);\n+\n+        let mut cargo =\n+            builder.cargo(compiler, Mode::Codegen, SourceType::Submodule, target, \"build\");\n+        cargo\n+            .arg(\"--manifest-path\")\n+            .arg(builder.src.join(format!(\"compiler/rustc_codegen_{}/Cargo.toml\", backend)));\n+        rustc_cargo_env(builder, &mut cargo, target);\n+\n+        let tmp_stamp = out_dir.join(\".tmp.stamp\");\n+\n+        let files = run_cargo(builder, cargo, vec![], &tmp_stamp, vec![], false);\n+        if builder.config.dry_run {\n+            return;\n+        }\n+        let mut files = files.into_iter().filter(|f| {\n+            let filename = f.file_name().unwrap().to_str().unwrap();\n+            is_dylib(filename) && filename.contains(\"rustc_codegen_\")\n+        });\n+        let codegen_backend = match files.next() {\n+            Some(f) => f,\n+            None => panic!(\"no dylibs built for codegen backend?\"),\n+        };\n+        if let Some(f) = files.next() {\n+            panic!(\n+                \"codegen backend built two dylibs:\\n{}\\n{}\",\n+                codegen_backend.display(),\n+                f.display()\n+            );\n+        }\n+        let stamp = codegen_backend_stamp(builder, compiler, target, backend);\n+        let codegen_backend = codegen_backend.to_str().unwrap();\n+        t!(fs::write(&stamp, &codegen_backend));\n+    }\n+}\n+\n+/// Creates the `codegen-backends` folder for a compiler that's about to be\n+/// assembled as a complete compiler.\n+///\n+/// This will take the codegen artifacts produced by `compiler` and link them\n+/// into an appropriate location for `target_compiler` to be a functional\n+/// compiler.\n+fn copy_codegen_backends_to_sysroot(\n+    builder: &Builder<'_>,\n+    compiler: Compiler,\n+    target_compiler: Compiler,\n+) {\n+    let target = target_compiler.host;\n+\n+    // Note that this step is different than all the other `*Link` steps in\n+    // that it's not assembling a bunch of libraries but rather is primarily\n+    // moving the codegen backend into place. The codegen backend of rustc is\n+    // not linked into the main compiler by default but is rather dynamically\n+    // selected at runtime for inclusion.\n+    //\n+    // Here we're looking for the output dylib of the `CodegenBackend` step and\n+    // we're copying that into the `codegen-backends` folder.\n+    let dst = builder.sysroot_codegen_backends(target_compiler);\n+    t!(fs::create_dir_all(&dst));\n+\n+    if builder.config.dry_run {\n+        return;\n+    }\n+\n+    for backend in builder.config.rust_codegen_backends.iter() {\n+        if backend == \"llvm\" {\n+            continue; // Already built as part of rustc\n+        }\n+\n+        let stamp = codegen_backend_stamp(builder, compiler, target, *backend);\n+        let dylib = t!(fs::read_to_string(&stamp));\n+        let file = Path::new(&dylib);\n+        let filename = file.file_name().unwrap().to_str().unwrap();\n+        // change `librustc_codegen_cranelift-xxxxxx.so` to\n+        // `librustc_codegen_cranelift-release.so`\n+        let target_filename = {\n+            let dash = filename.find('-').unwrap();\n+            let dot = filename.find('.').unwrap();\n+            format!(\"{}-{}{}\", &filename[..dash], builder.rust_release(), &filename[dot..])\n+        };\n+        builder.copy(&file, &dst.join(target_filename));\n+    }\n+}\n+\n /// Cargo's output path for the standard library in a given stage, compiled\n /// by a particular compiler for the specified target.\n pub fn libstd_stamp(builder: &Builder<'_>, compiler: Compiler, target: TargetSelection) -> PathBuf {\n@@ -656,6 +794,19 @@ pub fn librustc_stamp(\n     builder.cargo_out(compiler, Mode::Rustc, target).join(\".librustc.stamp\")\n }\n \n+/// Cargo's output path for librustc_codegen_llvm in a given stage, compiled by a particular\n+/// compiler for the specified target and backend.\n+fn codegen_backend_stamp(\n+    builder: &Builder<'_>,\n+    compiler: Compiler,\n+    target: TargetSelection,\n+    backend: Interned<String>,\n+) -> PathBuf {\n+    builder\n+        .cargo_out(compiler, Mode::Codegen, target)\n+        .join(format!(\".librustc_codegen_{}.stamp\", backend))\n+}\n+\n pub fn compiler_file(\n     builder: &Builder<'_>,\n     compiler: &Path,\n@@ -782,6 +933,18 @@ impl Step for Assemble {\n         // when not performing a full bootstrap).\n         builder.ensure(Rustc { compiler: build_compiler, target: target_compiler.host });\n \n+        for &backend in builder.config.rust_codegen_backends.iter() {\n+            if backend == \"llvm\" {\n+                continue; // Already built as part of rustc\n+            }\n+\n+            builder.ensure(CodegenBackend {\n+                compiler: build_compiler,\n+                target: target_compiler.host,\n+                backend,\n+            });\n+        }\n+\n         let lld_install = if builder.config.lld_enabled {\n             Some(builder.ensure(native::Lld { target: target_compiler.host }))\n         } else {\n@@ -804,6 +967,8 @@ impl Step for Assemble {\n             }\n         }\n \n+        copy_codegen_backends_to_sysroot(builder, build_compiler, target_compiler);\n+\n         let libdir = builder.sysroot_libdir(target_compiler, target_compiler.host);\n         if let Some(lld_install) = lld_install {\n             let src_exe = exe(\"lld\", target_compiler.host);"}, {"sha": "3b7458351b14e17848421fb6c6c7611eb92d755b", "filename": "src/bootstrap/dist.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/cf798c1ec65a5ec3491846777f9003fabb881b4a/src%2Fbootstrap%2Fdist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf798c1ec65a5ec3491846777f9003fabb881b4a/src%2Fbootstrap%2Fdist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdist.rs?ref=cf798c1ec65a5ec3491846777f9003fabb881b4a", "patch": "@@ -504,6 +504,19 @@ impl Step for Rustc {\n                 }\n             }\n \n+            // Copy over the codegen backends\n+            let backends_src = builder.sysroot_codegen_backends(compiler);\n+            let backends_rel = backends_src\n+                .strip_prefix(&src)\n+                .unwrap()\n+                .strip_prefix(builder.sysroot_libdir_relative(compiler))\n+                .unwrap();\n+            // Don't use custom libdir here because ^lib/ will be resolved again with installer\n+            let backends_dst = image.join(\"lib\").join(&backends_rel);\n+\n+            t!(fs::create_dir_all(&backends_dst));\n+            builder.cp_r(&backends_src, &backends_dst);\n+\n             // Copy libLLVM.so to the lib dir as well, if needed. While not\n             // technically needed by rustc itself it's needed by lots of other\n             // components like the llvm tools and LLD. LLD is included below and\n@@ -1115,6 +1128,7 @@ impl Step for PlainSourceTarball {\n             cmd.arg(\"vendor\")\n                 .arg(\"--sync\")\n                 .arg(builder.src.join(\"./src/tools/rust-analyzer/Cargo.toml\"))\n+                .arg(builder.src.join(\"./compiler/rustc_codegen_cranelift/Cargo.toml\"))\n                 .current_dir(&plain_dst_src);\n             builder.run(&mut cmd);\n         }"}, {"sha": "6880f6e816a4bf6706b3cbcab8c6e47e9569913f", "filename": "src/bootstrap/lib.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cf798c1ec65a5ec3491846777f9003fabb881b4a/src%2Fbootstrap%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf798c1ec65a5ec3491846777f9003fabb881b4a/src%2Fbootstrap%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Flib.rs?ref=cf798c1ec65a5ec3491846777f9003fabb881b4a", "patch": "@@ -307,6 +307,9 @@ pub enum Mode {\n     /// Build librustc, and compiler libraries, placing output in the \"stageN-rustc\" directory.\n     Rustc,\n \n+    /// Build a codegen backend for rustc, placing the output in the \"stageN-codegen\" directory.\n+    Codegen,\n+\n     /// Build a tool, placing output in the \"stage0-bootstrap-tools\"\n     /// directory. This is for miscellaneous sets of tools that are built\n     /// using the bootstrap stage0 compiler in its entirety (target libraries\n@@ -594,6 +597,7 @@ impl Build {\n         let suffix = match mode {\n             Mode::Std => \"-std\",\n             Mode::Rustc => \"-rustc\",\n+            Mode::Codegen => \"-codegen\",\n             Mode::ToolBootstrap => \"-bootstrap-tools\",\n             Mode::ToolStd | Mode::ToolRustc => \"-tools\",\n         };"}, {"sha": "cc4c43f0468ab8ebcdb98cb34cfd12759bc100ea", "filename": "src/tools/tidy/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cf798c1ec65a5ec3491846777f9003fabb881b4a/src%2Ftools%2Ftidy%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf798c1ec65a5ec3491846777f9003fabb881b4a/src%2Ftools%2Ftidy%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Flib.rs?ref=cf798c1ec65a5ec3491846777f9003fabb881b4a", "patch": "@@ -50,6 +50,7 @@ pub mod unstable_book;\n \n fn filter_dirs(path: &Path) -> bool {\n     let skip = [\n+        \"compiler/rustc_codegen_cranelift\",\n         \"src/llvm-project\",\n         \"library/backtrace\",\n         \"library/stdarch\","}]}