{"sha": "4b100a1b58767a4fd5884355072e27a42892babc", "node_id": "C_kwDOAAsO6NoAKDRiMTAwYTFiNTg3NjdhNGZkNTg4NDM1NTA3MmUyN2E0Mjg5MmJhYmM", "commit": {"author": {"name": "Oli Scherer", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2022-05-30T12:17:36Z"}, "committer": {"name": "Oli Scherer", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2022-06-01T11:47:54Z"}, "message": "Check that diagnostics happen in the line that they are annotated for", "tree": {"sha": "72ecab0c8eb26bb535c7f828b63a475e6d775f63", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/72ecab0c8eb26bb535c7f828b63a475e6d775f63"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4b100a1b58767a4fd5884355072e27a42892babc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4b100a1b58767a4fd5884355072e27a42892babc", "html_url": "https://github.com/rust-lang/rust/commit/4b100a1b58767a4fd5884355072e27a42892babc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4b100a1b58767a4fd5884355072e27a42892babc/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "47771d6b786e3f33b307c34e0d88a6a89e5da14c", "url": "https://api.github.com/repos/rust-lang/rust/commits/47771d6b786e3f33b307c34e0d88a6a89e5da14c", "html_url": "https://github.com/rust-lang/rust/commit/47771d6b786e3f33b307c34e0d88a6a89e5da14c"}], "stats": {"total": 808, "additions": 734, "deletions": 74}, "files": [{"sha": "29b7e0bec26ad1ee6db5d087756ca0230365899f", "filename": "Cargo.lock", "status": "modified", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/4b100a1b58767a4fd5884355072e27a42892babc/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/4b100a1b58767a4fd5884355072e27a42892babc/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=4b100a1b58767a4fd5884355072e27a42892babc", "patch": "@@ -193,6 +193,12 @@ dependencies = [\n  \"cfg-if\",\n ]\n \n+[[package]]\n+name = \"itoa\"\n+version = \"1.0.2\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"112c678d4050afce233f4f2852bb2eb519230b3cf12f33585275537d7e41578d\"\n+\n [[package]]\n name = \"lazy_static\"\n version = \"1.4.0\"\n@@ -446,6 +452,12 @@ dependencies = [\n  \"semver\",\n ]\n \n+[[package]]\n+name = \"ryu\"\n+version = \"1.0.10\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"f3f6f92acf49d1b98f7a81226834412ada05458b7364277387724a237f062695\"\n+\n [[package]]\n name = \"scopeguard\"\n version = \"1.1.0\"\n@@ -458,6 +470,37 @@ version = \"1.0.9\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"8cb243bdfdb5936c8dc3c45762a19d12ab4550cdc753bc247637d4ec35a040fd\"\n \n+[[package]]\n+name = \"serde\"\n+version = \"1.0.137\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"61ea8d54c77f8315140a05f4c7237403bf38b72704d031543aa1d16abbf517d1\"\n+dependencies = [\n+ \"serde_derive\",\n+]\n+\n+[[package]]\n+name = \"serde_derive\"\n+version = \"1.0.137\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"1f26faba0c3959972377d3b2d306ee9f71faee9714294e41bb777f83f88578be\"\n+dependencies = [\n+ \"proc-macro2\",\n+ \"quote\",\n+ \"syn\",\n+]\n+\n+[[package]]\n+name = \"serde_json\"\n+version = \"1.0.81\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"9b7ce2b32a1aed03c558dc61a5cd328f15aff2dbc17daad8fb8af04d2100e15c\"\n+dependencies = [\n+ \"itoa\",\n+ \"ryu\",\n+ \"serde\",\n+]\n+\n [[package]]\n name = \"shell-escape\"\n version = \"0.1.5\"\n@@ -500,6 +543,8 @@ dependencies = [\n  \"pretty_assertions\",\n  \"regex\",\n  \"rustc_version\",\n+ \"serde\",\n+ \"serde_json\",\n ]\n \n [[package]]"}, {"sha": "2cf5bc644dbff47d83730ae79da96afacb08f8fd", "filename": "src/bin/miri.rs", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/4b100a1b58767a4fd5884355072e27a42892babc/src%2Fbin%2Fmiri.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b100a1b58767a4fd5884355072e27a42892babc/src%2Fbin%2Fmiri.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbin%2Fmiri.rs?ref=4b100a1b58767a4fd5884355072e27a42892babc", "patch": "@@ -19,7 +19,6 @@ use log::debug;\n \n use rustc_data_structures::sync::Lrc;\n use rustc_driver::Compilation;\n-use rustc_errors::emitter::{ColorConfig, HumanReadableErrorType};\n use rustc_hir::{self as hir, def_id::LOCAL_CRATE, Node};\n use rustc_interface::interface::Config;\n use rustc_middle::{\n@@ -28,7 +27,7 @@ use rustc_middle::{\n     },\n     ty::{query::ExternProviders, TyCtxt},\n };\n-use rustc_session::{config::ErrorOutputType, search_paths::PathKind, CtfeBacktrace};\n+use rustc_session::{search_paths::PathKind, CtfeBacktrace};\n \n use miri::{BacktraceStyle, ProvenanceMode};\n \n@@ -64,13 +63,7 @@ impl rustc_driver::Callbacks for MiriCompilerCalls {\n             let (entry_def_id, entry_type) = if let Some(entry_def) = tcx.entry_fn(()) {\n                 entry_def\n             } else {\n-                let output_ty = ErrorOutputType::HumanReadable(HumanReadableErrorType::Default(\n-                    ColorConfig::Auto,\n-                ));\n-                rustc_session::early_error(\n-                    output_ty,\n-                    \"miri can only run programs that have a main function\",\n-                );\n+                tcx.sess.fatal(\"miri can only run programs that have a main function\");\n             };\n             let mut config = self.miri_config.clone();\n "}, {"sha": "ad193d84991811a2882651f7be2a90531a0abe78", "filename": "tests/compile-fail/intrinsics/assume.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4b100a1b58767a4fd5884355072e27a42892babc/tests%2Fcompile-fail%2Fintrinsics%2Fassume.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b100a1b58767a4fd5884355072e27a42892babc/tests%2Fcompile-fail%2Fintrinsics%2Fassume.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fintrinsics%2Fassume.rs?ref=4b100a1b58767a4fd5884355072e27a42892babc", "patch": "@@ -5,6 +5,6 @@ fn main() {\n     unsafe {\n         std::intrinsics::assume(x < 10);\n         std::intrinsics::assume(x > 1);\n-        std::intrinsics::assume(x > 42); //~ `assume` intrinsic called with `false`\n+        std::intrinsics::assume(x > 42); //~ ERROR `assume` intrinsic called with `false`\n     }\n }"}, {"sha": "88bdfb4e387cf821eaee78f40a314090e7c17f5f", "filename": "tests/compile-fail/no_main.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4b100a1b58767a4fd5884355072e27a42892babc/tests%2Fcompile-fail%2Fno_main.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4b100a1b58767a4fd5884355072e27a42892babc/tests%2Fcompile-fail%2Fno_main.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fno_main.stderr?ref=4b100a1b58767a4fd5884355072e27a42892babc", "patch": "@@ -1,2 +1,4 @@\n error: miri can only run programs that have a main function\n \n+error: aborting due to previous error\n+"}, {"sha": "18be75b308cf0b0f41bab502cd8b01d05e2d56df", "filename": "tests/compile-fail/sync/libc_pthread_cond_double_destroy.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4b100a1b58767a4fd5884355072e27a42892babc/tests%2Fcompile-fail%2Fsync%2Flibc_pthread_cond_double_destroy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b100a1b58767a4fd5884355072e27a42892babc/tests%2Fcompile-fail%2Fsync%2Flibc_pthread_cond_double_destroy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fsync%2Flibc_pthread_cond_double_destroy.rs?ref=4b100a1b58767a4fd5884355072e27a42892babc", "patch": "@@ -17,6 +17,6 @@ fn main() {\n         libc::pthread_cond_destroy(cond.as_mut_ptr());\n \n         libc::pthread_cond_destroy(cond.as_mut_ptr());\n-        //~^ Undefined Behavior: using uninitialized data, but this operation requires initialized memory\n+        //~^ ERROR Undefined Behavior: using uninitialized data, but this operation requires initialized memory\n     }\n }"}, {"sha": "1543a5841ad284d3d5e7c660aad07fb2c0a056a6", "filename": "tests/compile-fail/sync/libc_pthread_condattr_double_destroy.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4b100a1b58767a4fd5884355072e27a42892babc/tests%2Fcompile-fail%2Fsync%2Flibc_pthread_condattr_double_destroy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b100a1b58767a4fd5884355072e27a42892babc/tests%2Fcompile-fail%2Fsync%2Flibc_pthread_condattr_double_destroy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fsync%2Flibc_pthread_condattr_double_destroy.rs?ref=4b100a1b58767a4fd5884355072e27a42892babc", "patch": "@@ -14,6 +14,6 @@ fn main() {\n         libc::pthread_condattr_destroy(attr.as_mut_ptr());\n \n         libc::pthread_condattr_destroy(attr.as_mut_ptr());\n-        //~^ Undefined Behavior: using uninitialized data, but this operation requires initialized memory\n+        //~^ ERROR Undefined Behavior: using uninitialized data, but this operation requires initialized memory\n     }\n }"}, {"sha": "3710810cd2c3352d7e31ecd514068f05df8d3a28", "filename": "tests/compile-fail/sync/libc_pthread_mutex_double_destroy.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4b100a1b58767a4fd5884355072e27a42892babc/tests%2Fcompile-fail%2Fsync%2Flibc_pthread_mutex_double_destroy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b100a1b58767a4fd5884355072e27a42892babc/tests%2Fcompile-fail%2Fsync%2Flibc_pthread_mutex_double_destroy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fsync%2Flibc_pthread_mutex_double_destroy.rs?ref=4b100a1b58767a4fd5884355072e27a42892babc", "patch": "@@ -18,6 +18,6 @@ fn main() {\n         libc::pthread_mutex_destroy(mutex.as_mut_ptr());\n \n         libc::pthread_mutex_destroy(mutex.as_mut_ptr());\n-        //~^ Undefined Behavior: using uninitialized data, but this operation requires initialized memory\n+        //~^ ERROR Undefined Behavior: using uninitialized data, but this operation requires initialized memory\n     }\n }"}, {"sha": "c232780ee2ea394bf7ab777da6d12c45a850340f", "filename": "tests/compile-fail/sync/libc_pthread_mutexattr_double_destroy.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4b100a1b58767a4fd5884355072e27a42892babc/tests%2Fcompile-fail%2Fsync%2Flibc_pthread_mutexattr_double_destroy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b100a1b58767a4fd5884355072e27a42892babc/tests%2Fcompile-fail%2Fsync%2Flibc_pthread_mutexattr_double_destroy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fsync%2Flibc_pthread_mutexattr_double_destroy.rs?ref=4b100a1b58767a4fd5884355072e27a42892babc", "patch": "@@ -14,6 +14,6 @@ fn main() {\n         libc::pthread_mutexattr_destroy(attr.as_mut_ptr());\n \n         libc::pthread_mutexattr_destroy(attr.as_mut_ptr());\n-        //~^ Undefined Behavior: using uninitialized data, but this operation requires initialized memory\n+        //~^ ERROR Undefined Behavior: using uninitialized data, but this operation requires initialized memory\n     }\n }"}, {"sha": "055bb1af489f4966c86473a1f80500f177da59d3", "filename": "tests/compile-fail/sync/libc_pthread_rwlock_double_destroy.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4b100a1b58767a4fd5884355072e27a42892babc/tests%2Fcompile-fail%2Fsync%2Flibc_pthread_rwlock_double_destroy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b100a1b58767a4fd5884355072e27a42892babc/tests%2Fcompile-fail%2Fsync%2Flibc_pthread_rwlock_double_destroy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fsync%2Flibc_pthread_rwlock_double_destroy.rs?ref=4b100a1b58767a4fd5884355072e27a42892babc", "patch": "@@ -11,6 +11,6 @@ fn main() {\n         libc::pthread_rwlock_destroy(&mut lock);\n \n         libc::pthread_rwlock_destroy(&mut lock);\n-        //~^ Undefined Behavior: using uninitialized data, but this operation requires initialized memory\n+        //~^ ERROR Undefined Behavior: using uninitialized data, but this operation requires initialized memory\n     }\n }"}, {"sha": "5a4cdb892713e8e1e7aa2a581c03d2c650b7c3b2", "filename": "ui_test/Cargo.lock", "status": "modified", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/4b100a1b58767a4fd5884355072e27a42892babc/ui_test%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/4b100a1b58767a4fd5884355072e27a42892babc/ui_test%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/ui_test%2FCargo.lock?ref=4b100a1b58767a4fd5884355072e27a42892babc", "patch": "@@ -148,6 +148,12 @@ dependencies = [\n  \"libc\",\n ]\n \n+[[package]]\n+name = \"itoa\"\n+version = \"1.0.2\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"112c678d4050afce233f4f2852bb2eb519230b3cf12f33585275537d7e41578d\"\n+\n [[package]]\n name = \"lazy_static\"\n version = \"1.4.0\"\n@@ -240,6 +246,12 @@ dependencies = [\n  \"semver\",\n ]\n \n+[[package]]\n+name = \"ryu\"\n+version = \"1.0.10\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"f3f6f92acf49d1b98f7a81226834412ada05458b7364277387724a237f062695\"\n+\n [[package]]\n name = \"scopeguard\"\n version = \"1.1.0\"\n@@ -252,6 +264,37 @@ version = \"1.0.9\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"8cb243bdfdb5936c8dc3c45762a19d12ab4550cdc753bc247637d4ec35a040fd\"\n \n+[[package]]\n+name = \"serde\"\n+version = \"1.0.137\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"61ea8d54c77f8315140a05f4c7237403bf38b72704d031543aa1d16abbf517d1\"\n+dependencies = [\n+ \"serde_derive\",\n+]\n+\n+[[package]]\n+name = \"serde_derive\"\n+version = \"1.0.137\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"1f26faba0c3959972377d3b2d306ee9f71faee9714294e41bb777f83f88578be\"\n+dependencies = [\n+ \"proc-macro2\",\n+ \"quote\",\n+ \"syn\",\n+]\n+\n+[[package]]\n+name = \"serde_json\"\n+version = \"1.0.81\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"9b7ce2b32a1aed03c558dc61a5cd328f15aff2dbc17daad8fb8af04d2100e15c\"\n+dependencies = [\n+ \"itoa\",\n+ \"ryu\",\n+ \"serde\",\n+]\n+\n [[package]]\n name = \"syn\"\n version = \"1.0.95\"\n@@ -273,6 +316,8 @@ dependencies = [\n  \"pretty_assertions\",\n  \"regex\",\n  \"rustc_version\",\n+ \"serde\",\n+ \"serde_json\",\n ]\n \n [[package]]"}, {"sha": "92c00915cbfeb87138dfb0a59bf099bd8943ec05", "filename": "ui_test/Cargo.toml", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4b100a1b58767a4fd5884355072e27a42892babc/ui_test%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/4b100a1b58767a4fd5884355072e27a42892babc/ui_test%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/ui_test%2FCargo.toml?ref=4b100a1b58767a4fd5884355072e27a42892babc", "patch": "@@ -12,3 +12,5 @@ regex = \"1.5.5\"\n pretty_assertions = \"1.2.1\"\n crossbeam = \"0.8.1\"\n lazy_static = \"1.4.0\"\n+serde = { version = \"1.0\", features = [\"derive\"] }\n+serde_json = \"1.0\""}, {"sha": "b3c9a3378cf30d9d13cb118148f087f992e8cb79", "filename": "ui_test/README.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4b100a1b58767a4fd5884355072e27a42892babc/ui_test%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/4b100a1b58767a4fd5884355072e27a42892babc/ui_test%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/ui_test%2FREADME.md?ref=4b100a1b58767a4fd5884355072e27a42892babc", "patch": "@@ -11,9 +11,9 @@ Note that the space after `//`, when it is present, is *not* optional -- it must\n * `// stderr-per-bitwidth` produces one stderr file per bitwidth, as they may differ significantly sometimes\n * `// error-pattern: XXX` make sure the stderr output contains `XXX`\n * `//~ ERROR: XXX` make sure the stderr output contains `XXX` for an error in the line where this comment is written\n-    * NOTE: it is not checked at present that it is actually in the line where the error occurred, or that it is truly an ERROR/WARNING/HELP/NOTE, but you should treat it as such until that becomes true.\n-    * Also supports `HELP` or `WARN` for different kind of message\n-    * if the all caps note is left out, any message is matched\n+    * Also supports `HELP`, `WARN` or `NOTE` for different kind of message\n+        * if one of those levels is specified explicitly, *all* diagnostics of this level or higher need an annotation. If you want to avoid this, just leave out the all caps level note entirely.\n+    * If the all caps note is left out, a message of any level is matched. Leaving it out is not allowed for `ERROR` levels.\n     * This checks the output *before* normalization, so you can check things that get normalized away, but need to\n       be careful not to accidentally have a pattern that differs between platforms.\n * `// revisions: XXX YYY` runs the test once for each space separated name in the list"}, {"sha": "cc9870a63be4b2346c80f2cc8225d7a6621b8d0f", "filename": "ui_test/src/comments.rs", "status": "modified", "additions": 34, "deletions": 2, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/4b100a1b58767a4fd5884355072e27a42892babc/ui_test%2Fsrc%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b100a1b58767a4fd5884355072e27a42892babc/ui_test%2Fsrc%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/ui_test%2Fsrc%2Fcomments.rs?ref=4b100a1b58767a4fd5884355072e27a42892babc", "patch": "@@ -2,6 +2,8 @@ use std::path::Path;\n \n use regex::Regex;\n \n+use crate::rustc_stderr::Level;\n+\n #[cfg(test)]\n mod tests;\n \n@@ -33,7 +35,11 @@ pub(crate) struct Comments {\n pub(crate) struct ErrorMatch {\n     pub matched: String,\n     pub revision: Option<String>,\n+    pub level: Option<Level>,\n+    /// The line where the message was defined, for reporting issues with it (e.g. in case it wasn't found).\n     pub definition_line: usize,\n+    /// The line this pattern is expecting to find a message in.\n+    pub line: usize,\n }\n \n impl Comments {\n@@ -47,9 +53,13 @@ impl Comments {\n     pub(crate) fn parse(path: &Path, content: &str) -> Self {\n         let mut this = Self::default();\n         let error_pattern_regex =\n-            Regex::new(r\"//(\\[(?P<revision>[^\\]]+)\\])?~[|^]*\\s*(ERROR|HELP|WARN)?:?(?P<text>.*)\")\n+            Regex::new(r\"//(\\[(?P<revision>[^\\]]+)\\])?~(?P<offset>\\||[\\^]+)?\\s*(?P<level>ERROR|HELP|WARN|NOTE)?:?(?P<text>.*)\")\n                 .unwrap();\n+\n+        // The line that a `|` will refer to\n+        let mut fallthrough_to = None;\n         for (l, line) in content.lines().enumerate() {\n+            let l = l + 1; // enumerate starts at 0, but line numbers start at 1\n             if let Some(revisions) = line.strip_prefix(\"// revisions:\") {\n                 assert_eq!(\n                     this.revisions,\n@@ -113,7 +123,29 @@ impl Comments {\n                 let matched = captures[\"text\"].trim().to_string();\n \n                 let revision = captures.name(\"revision\").map(|rev| rev.as_str().to_string());\n-                this.error_matches.push(ErrorMatch { matched, revision, definition_line: l });\n+\n+                let level = captures.name(\"level\").map(|rev| rev.as_str().parse().unwrap());\n+\n+                let match_line = match captures.name(\"offset\").map(|rev| rev.as_str()) {\n+                    Some(\"|\") => fallthrough_to.expect(\"`//~|` pattern without preceding line\"),\n+                    Some(pat) => {\n+                        debug_assert!(pat.chars().all(|c| c == '^'));\n+                        l - pat.len()\n+                    }\n+                    None => l,\n+                };\n+\n+                fallthrough_to = Some(match_line);\n+\n+                this.error_matches.push(ErrorMatch {\n+                    matched,\n+                    revision,\n+                    level,\n+                    definition_line: l,\n+                    line: match_line,\n+                });\n+            } else {\n+                fallthrough_to = None;\n             }\n         }\n         this"}, {"sha": "ef9662241424add9179dfe8d2a2a54f80b6b6a67", "filename": "ui_test/src/comments/tests.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4b100a1b58767a4fd5884355072e27a42892babc/ui_test%2Fsrc%2Fcomments%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b100a1b58767a4fd5884355072e27a42892babc/ui_test%2Fsrc%2Fcomments%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/ui_test%2Fsrc%2Fcomments%2Ftests.rs?ref=4b100a1b58767a4fd5884355072e27a42892babc", "patch": "@@ -13,7 +13,7 @@ fn main() {\n     \";\n     let comments = Comments::parse(Path::new(\"<dummy>\"), s);\n     println!(\"parsed comments: {:#?}\", comments);\n-    assert_eq!(comments.error_matches[0].definition_line, 4);\n+    assert_eq!(comments.error_matches[0].definition_line, 5);\n     assert_eq!(comments.error_matches[0].revision, None);\n     assert_eq!(\n         comments.error_matches[0].matched,"}, {"sha": "4a9cdd386ac27a68e8754a7d209c8689225f80d0", "filename": "ui_test/src/lib.rs", "status": "modified", "additions": 154, "deletions": 35, "changes": 189, "blob_url": "https://github.com/rust-lang/rust/blob/4b100a1b58767a4fd5884355072e27a42892babc/ui_test%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b100a1b58767a4fd5884355072e27a42892babc/ui_test%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/ui_test%2Fsrc%2Flib.rs?ref=4b100a1b58767a4fd5884355072e27a42892babc", "patch": "@@ -8,10 +8,12 @@ use colored::*;\n use comments::ErrorMatch;\n use crossbeam::queue::SegQueue;\n use regex::Regex;\n+use rustc_stderr::{Level, Message};\n \n use crate::comments::Comments;\n \n mod comments;\n+mod rustc_stderr;\n #[cfg(test)]\n mod tests;\n \n@@ -100,7 +102,8 @@ pub fn run_tests(config: Config) {\n                     for revision in\n                         comments.revisions.clone().unwrap_or_else(|| vec![String::new()])\n                     {\n-                        let (m, errors) = run_test(&path, &config, &target, &revision, &comments);\n+                        let (m, errors, stderr) =\n+                            run_test(&path, &config, &target, &revision, &comments);\n \n                         // Using a single `eprintln!` to prevent messages from threads from getting intermingled.\n                         let mut msg = format!(\"{} \", path.display());\n@@ -113,7 +116,13 @@ pub fn run_tests(config: Config) {\n                             succeeded.fetch_add(1, Ordering::Relaxed);\n                         } else {\n                             eprintln!(\"{msg}{}\", \"FAILED\".red().bold());\n-                            failures.lock().unwrap().push((path.clone(), m, revision, errors));\n+                            failures.lock().unwrap().push((\n+                                path.clone(),\n+                                m,\n+                                revision,\n+                                errors,\n+                                stderr,\n+                            ));\n                         }\n                     }\n                 }\n@@ -128,7 +137,7 @@ pub fn run_tests(config: Config) {\n     let ignored = ignored.load(Ordering::Relaxed);\n     let filtered = filtered.load(Ordering::Relaxed);\n     if !failures.is_empty() {\n-        for (path, miri, revision, errors) in &failures {\n+        for (path, miri, revision, errors, stderr) in &failures {\n             eprintln!();\n             eprint!(\"{}\", path.display().to_string().underline());\n             if !revision.is_empty() {\n@@ -138,32 +147,63 @@ pub fn run_tests(config: Config) {\n             eprintln!();\n             eprintln!(\"command: {:?}\", miri);\n             eprintln!();\n-            let mut dump_stderr = None;\n+            // `None` means never dump, as we already dumped it for an `OutputDiffers`\n+            // `Some(false)` means there's no reason to dump, as all errors are independent of the stderr\n+            // `Some(true)` means that there was a pattern in the .rs file that was not found in the output.\n+            let mut dump_stderr = Some(false);\n             for error in errors {\n                 match error {\n                     Error::ExitStatus(mode, exit_status) => eprintln!(\"{mode:?} got {exit_status}\"),\n-                    Error::PatternNotFound { stderr, pattern, definition_line } => {\n+                    Error::PatternNotFound { pattern, definition_line } => {\n                         eprintln!(\"`{pattern}` {} in stderr output\", \"not found\".red());\n                         eprintln!(\n                             \"expected because of pattern here: {}:{definition_line}\",\n                             path.display().to_string().bold()\n                         );\n-                        dump_stderr = Some(stderr.clone())\n+                        dump_stderr = dump_stderr.map(|_| true);\n+                    }\n+                    Error::NoPatternsFound => {\n+                        eprintln!(\"{}\", \"no error patterns found in failure test\".red());\n                     }\n-                    Error::NoPatternsFound =>\n-                        eprintln!(\"{}\", \"no error patterns found in failure test\".red()),\n                     Error::PatternFoundInPassTest =>\n                         eprintln!(\"{}\", \"error pattern found in success test\".red()),\n                     Error::OutputDiffers { path, actual, expected } => {\n-                        dump_stderr = None;\n+                        if path.extension().unwrap() == \"stderr\" {\n+                            dump_stderr = None;\n+                        }\n                         eprintln!(\"actual output differed from expected {}\", path.display());\n                         eprintln!(\"{}\", pretty_assertions::StrComparison::new(expected, actual));\n                         eprintln!()\n                     }\n+                    Error::ErrorsWithoutPattern { path: None, msgs } => {\n+                        eprintln!(\n+                            \"There were {} unmatched diagnostics that occurred outside the testfile and had not pattern\",\n+                            msgs.len(),\n+                        );\n+                        for Message { level, message } in msgs {\n+                            eprintln!(\"    {level:?}: {message}\")\n+                        }\n+                    }\n+                    Error::ErrorsWithoutPattern { path: Some((path, line)), msgs } => {\n+                        eprintln!(\n+                            \"There were {} unmatched diagnostics at {}:{line}\",\n+                            msgs.len(),\n+                            path.display()\n+                        );\n+                        for Message { level, message } in msgs {\n+                            eprintln!(\"    {level:?}: {message}\")\n+                        }\n+                    }\n+                    Error::ErrorPatternWithoutErrorAnnotation(path, line) => {\n+                        eprintln!(\n+                            \"Annotation at {}:{line} matched an error diagnostic but did not have `ERROR` before its message\",\n+                            path.display()\n+                        );\n+                    }\n                 }\n                 eprintln!();\n             }\n-            if let Some(stderr) = dump_stderr {\n+            if let Some(true) = dump_stderr {\n                 eprintln!(\"actual stderr:\");\n                 eprintln!(\"{}\", stderr);\n                 eprintln!();\n@@ -195,7 +235,6 @@ enum Error {\n     /// Got an invalid exit status for the given mode.\n     ExitStatus(Mode, ExitStatus),\n     PatternNotFound {\n-        stderr: String,\n         pattern: String,\n         definition_line: usize,\n     },\n@@ -209,6 +248,11 @@ enum Error {\n         actual: String,\n         expected: String,\n     },\n+    ErrorsWithoutPattern {\n+        msgs: Vec<Message>,\n+        path: Option<(PathBuf, usize)>,\n+    },\n+    ErrorPatternWithoutErrorAnnotation(PathBuf, usize),\n }\n \n type Errors = Vec<Error>;\n@@ -219,14 +263,15 @@ fn run_test(\n     target: &str,\n     revision: &str,\n     comments: &Comments,\n-) -> (Command, Errors) {\n+) -> (Command, Errors, String) {\n     // Run miri\n     let mut miri = Command::new(&config.program);\n     miri.args(config.args.iter());\n     miri.arg(path);\n     if !revision.is_empty() {\n         miri.arg(format!(\"--cfg={revision}\"));\n     }\n+    miri.arg(\"--error-format=json\");\n     for arg in &comments.compile_flags {\n         miri.arg(arg);\n     }\n@@ -235,7 +280,7 @@ fn run_test(\n     }\n     let output = miri.output().expect(\"could not execute miri\");\n     let mut errors = config.mode.ok(output.status);\n-    check_test_result(\n+    let stderr = check_test_result(\n         path,\n         config,\n         target,\n@@ -245,7 +290,7 @@ fn run_test(\n         &output.stdout,\n         &output.stderr,\n     );\n-    (miri, errors)\n+    (miri, errors, stderr)\n }\n \n fn check_test_result(\n@@ -257,11 +302,9 @@ fn check_test_result(\n     errors: &mut Errors,\n     stdout: &[u8],\n     stderr: &[u8],\n-) {\n+) -> String {\n     // Always remove annotation comments from stderr.\n-    let annotations = Regex::new(r\"\\s*//~.*\").unwrap();\n-    let stderr = std::str::from_utf8(stderr).unwrap();\n-    let stderr = annotations.replace_all(stderr, \"\");\n+    let diagnostics = rustc_stderr::process(path, stderr);\n     let stdout = std::str::from_utf8(stdout).unwrap();\n     // Check output files (if any)\n     let revised = |extension: &str| {\n@@ -273,7 +316,7 @@ fn check_test_result(\n     };\n     // Check output files against actual output\n     check_output(\n-        &stderr,\n+        &diagnostics.rendered,\n         path,\n         errors,\n         revised(\"stderr\"),\n@@ -293,50 +336,126 @@ fn check_test_result(\n         comments,\n     );\n     // Check error annotations in the source against output\n-    check_annotations(&stderr, errors, config, revision, comments);\n+    check_annotations(\n+        diagnostics.messages,\n+        diagnostics.messages_from_unknown_file_or_line,\n+        path,\n+        errors,\n+        config,\n+        revision,\n+        comments,\n+    );\n+    diagnostics.rendered\n }\n \n fn check_annotations(\n-    unnormalized_stderr: &str,\n+    mut messages: Vec<Vec<Message>>,\n+    mut messages_from_unknown_file_or_line: Vec<Message>,\n+    path: &Path,\n     errors: &mut Errors,\n     config: &Config,\n     revision: &str,\n     comments: &Comments,\n ) {\n-    let mut found_annotation = false;\n     if let Some((ref error_pattern, definition_line)) = comments.error_pattern {\n-        if !unnormalized_stderr.contains(error_pattern) {\n+        let mut found = false;\n+\n+        // first check the diagnostics messages outside of our file. We check this first, so that\n+        // you can mix in-file annotations with // error-pattern annotations, even if there is overlap\n+        // in the messages.\n+        if let Some(i) = messages_from_unknown_file_or_line\n+            .iter()\n+            .position(|msg| msg.message.contains(error_pattern))\n+        {\n+            messages_from_unknown_file_or_line.remove(i);\n+            found = true;\n+        }\n+\n+        // if nothing was found, check the ones inside our file. We permit this because some tests may have\n+        // flaky line numbers for their messages.\n+        if !found {\n+            for line in &mut messages {\n+                if let Some(i) = line.iter().position(|msg| msg.message.contains(error_pattern)) {\n+                    line.remove(i);\n+                    found = true;\n+                    break;\n+                }\n+            }\n+        }\n+\n+        if !found {\n             errors.push(Error::PatternNotFound {\n-                stderr: unnormalized_stderr.to_string(),\n                 pattern: error_pattern.to_string(),\n                 definition_line,\n             });\n         }\n-        found_annotation = true;\n     }\n-    for &ErrorMatch { ref matched, revision: ref rev, definition_line } in &comments.error_matches {\n-        // FIXME: check that the error happens on the marked line\n \n+    // The order on `Level` is such that `Error` is the highest level.\n+    // We will ensure that *all* diagnostics of level at least `lowest_annotation_level`\n+    // are matched.\n+    let mut lowest_annotation_level = Level::Error;\n+    for &ErrorMatch { ref matched, revision: ref rev, definition_line, line, level } in\n+        &comments.error_matches\n+    {\n         if let Some(rev) = rev {\n             if rev != revision {\n                 continue;\n             }\n         }\n+        if let Some(level) = level {\n+            // If we found a diagnostic with a level annotation, make sure that all\n+            // diagnostics of that level have annotations, even if we don't end up finding a matching diagnostic\n+            // for this pattern.\n+            lowest_annotation_level = std::cmp::min(lowest_annotation_level, level);\n+        }\n \n-        if !unnormalized_stderr.contains(matched) {\n-            errors.push(Error::PatternNotFound {\n-                stderr: unnormalized_stderr.to_string(),\n-                pattern: matched.to_string(),\n-                definition_line,\n+        if let Some(msgs) = messages.get_mut(line) {\n+            let found = msgs.iter().position(|msg| {\n+                msg.message.contains(matched)\n+                    // in case there is no level on the annotation, match any level.\n+                    && level.map_or(true, |level| {\n+                        msg.level == level\n+                    })\n             });\n+            if let Some(found) = found {\n+                let msg = msgs.remove(found);\n+                if msg.level == Level::Error && level.is_none() {\n+                    errors\n+                        .push(Error::ErrorPatternWithoutErrorAnnotation(path.to_path_buf(), line));\n+                }\n+                continue;\n+            }\n         }\n-        found_annotation = true;\n+\n+        errors.push(Error::PatternNotFound { pattern: matched.to_string(), definition_line });\n+    }\n+\n+    let filter = |msgs: Vec<Message>| -> Vec<_> {\n+        msgs.into_iter().filter(|msg| msg.level >= lowest_annotation_level).collect()\n+    };\n+\n+    let messages_from_unknown_file_or_line = filter(messages_from_unknown_file_or_line);\n+    if !messages_from_unknown_file_or_line.is_empty() {\n+        errors.push(Error::ErrorsWithoutPattern {\n+            path: None,\n+            msgs: messages_from_unknown_file_or_line,\n+        });\n     }\n-    match (config.mode, found_annotation) {\n+\n+    for (line, msgs) in messages.into_iter().enumerate() {\n+        let msgs = filter(msgs);\n+        if !msgs.is_empty() {\n+            errors\n+                .push(Error::ErrorsWithoutPattern { path: Some((path.to_path_buf(), line)), msgs });\n+        }\n+    }\n+\n+    match (config.mode, comments.error_pattern.is_some() || !comments.error_matches.is_empty()) {\n         (Mode::Pass, true) | (Mode::Panic, true) => errors.push(Error::PatternFoundInPassTest),\n         (Mode::Fail, false) => errors.push(Error::NoPatternsFound),\n         _ => {}\n-    };\n+    }\n }\n \n fn check_output("}, {"sha": "ac76a78a3cbcbecc6e933f820d5443ee2de4c4d6", "filename": "ui_test/src/rustc_stderr.rs", "status": "added", "additions": 152, "deletions": 0, "changes": 152, "blob_url": "https://github.com/rust-lang/rust/blob/4b100a1b58767a4fd5884355072e27a42892babc/ui_test%2Fsrc%2Frustc_stderr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b100a1b58767a4fd5884355072e27a42892babc/ui_test%2Fsrc%2Frustc_stderr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/ui_test%2Fsrc%2Frustc_stderr.rs?ref=4b100a1b58767a4fd5884355072e27a42892babc", "patch": "@@ -0,0 +1,152 @@\n+use std::{\n+    fmt::Write,\n+    path::{Path, PathBuf},\n+};\n+\n+use regex::Regex;\n+\n+#[derive(serde::Deserialize, Debug)]\n+struct RustcMessage {\n+    rendered: Option<String>,\n+    spans: Vec<Span>,\n+    level: String,\n+    message: String,\n+    children: Vec<RustcMessage>,\n+}\n+\n+#[derive(Copy, Clone, Debug, PartialOrd, Ord, PartialEq, Eq)]\n+pub(crate) enum Level {\n+    Error = 4,\n+    Warn = 3,\n+    Help = 2,\n+    Note = 1,\n+    /// Only used for \"For more information about this error, try `rustc --explain EXXXX`\".\n+    FailureNote = 0,\n+}\n+\n+#[derive(Debug)]\n+pub(crate) struct Message {\n+    pub(crate) level: Level,\n+    pub(crate) message: String,\n+}\n+\n+/// Information about macro expansion.\n+#[derive(serde::Deserialize, Debug)]\n+struct Expansion {\n+    span: Span,\n+}\n+\n+#[derive(serde::Deserialize, Debug)]\n+struct Span {\n+    line_start: usize,\n+    file_name: PathBuf,\n+    expansion: Option<Box<Expansion>>,\n+}\n+\n+impl std::str::FromStr for Level {\n+    type Err = String;\n+    fn from_str(s: &str) -> Result<Self, Self::Err> {\n+        match s {\n+            \"ERROR\" | \"error\" => Ok(Self::Error),\n+            \"WARN\" | \"warning\" => Ok(Self::Warn),\n+            \"HELP\" | \"help\" => Ok(Self::Help),\n+            \"NOTE\" | \"note\" => Ok(Self::Note),\n+            \"failure-note\" => Ok(Self::FailureNote),\n+            _ => Err(format!(\"unknown level `{s}`\")),\n+        }\n+    }\n+}\n+\n+#[derive(Debug)]\n+pub(crate) struct Diagnostics {\n+    /// Rendered and concatenated version of all diagnostics.\n+    /// This is equivalent to non-json diagnostics.\n+    pub rendered: String,\n+    /// Per line, a list of messages for that line.\n+    pub messages: Vec<Vec<Message>>,\n+    /// Messages not on any line (usually because they are from libstd)\n+    pub messages_from_unknown_file_or_line: Vec<Message>,\n+}\n+\n+impl RustcMessage {\n+    fn line(&self, file: &Path) -> Option<usize> {\n+        self.spans.iter().find_map(|span| span.line(file))\n+    }\n+\n+    /// Put the message and its children into the line-indexed list.\n+    fn insert_recursive(\n+        self,\n+        file: &Path,\n+        messages: &mut Vec<Vec<Message>>,\n+        messages_from_unknown_file_or_line: &mut Vec<Message>,\n+        line: Option<usize>,\n+    ) {\n+        let line = self.line(file).or(line);\n+        let msg = Message { level: self.level.parse().unwrap(), message: self.message };\n+        if let Some(line) = line {\n+            if messages.len() <= line {\n+                messages.resize_with(line + 1, Vec::new);\n+            }\n+            messages[line].push(msg);\n+        // All other messages go into the general bin, unless they are specifically of the\n+        // \"aborting due to X previous errors\" variety, as we never want to match those. They\n+        // only count the number of errors and provide no useful information about the tests.\n+        } else if !(msg.message.starts_with(\"aborting due to\")\n+            && msg.message.contains(\"previous error\"))\n+        {\n+            messages_from_unknown_file_or_line.push(msg);\n+        }\n+        for child in self.children {\n+            child.insert_recursive(file, messages, messages_from_unknown_file_or_line, line)\n+        }\n+    }\n+}\n+\n+impl Span {\n+    /// Returns a line number *in the given file*, if possible.\n+    fn line(&self, file: &Path) -> Option<usize> {\n+        if self.file_name == file {\n+            Some(self.line_start)\n+        } else {\n+            self.expansion.as_ref()?.span.line(file)\n+        }\n+    }\n+}\n+\n+pub(crate) fn filter_annotations_from_rendered(rendered: &str) -> std::borrow::Cow<'_, str> {\n+    let annotations = Regex::new(r\"\\s*//~.*\").unwrap();\n+    annotations.replace_all(&rendered, \"\")\n+}\n+\n+pub(crate) fn process(file: &Path, stderr: &[u8]) -> Diagnostics {\n+    let stderr = std::str::from_utf8(&stderr).unwrap();\n+    let mut rendered = String::new();\n+    let mut messages = vec![];\n+    let mut messages_from_unknown_file_or_line = vec![];\n+    for line in stderr.lines() {\n+        if line.starts_with(\"{\") {\n+            match serde_json::from_str::<RustcMessage>(line) {\n+                Ok(msg) => {\n+                    write!(\n+                        rendered,\n+                        \"{}\",\n+                        filter_annotations_from_rendered(msg.rendered.as_ref().unwrap())\n+                    )\n+                    .unwrap();\n+                    msg.insert_recursive(\n+                        file,\n+                        &mut messages,\n+                        &mut messages_from_unknown_file_or_line,\n+                        None,\n+                    );\n+                }\n+                Err(err) =>\n+                    panic!(\"failed to parse rustc JSON output at line: {}\\nerr:{}\", line, err),\n+            }\n+        } else {\n+            // FIXME: do we want to throw interpreter stderr into a separate file?\n+            writeln!(rendered, \"{}\", line).unwrap();\n+        }\n+    }\n+    Diagnostics { rendered, messages, messages_from_unknown_file_or_line }\n+}"}, {"sha": "7e08a68be7b9a1bd784b728200fd10dd061edb44", "filename": "ui_test/src/tests.rs", "status": "modified", "additions": 288, "deletions": 18, "changes": 306, "blob_url": "https://github.com/rust-lang/rust/blob/4b100a1b58767a4fd5884355072e27a42892babc/ui_test%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b100a1b58767a4fd5884355072e27a42892babc/ui_test%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/ui_test%2Fsrc%2Ftests.rs?ref=4b100a1b58767a4fd5884355072e27a42892babc", "patch": "@@ -1,5 +1,8 @@\n use std::path::{Path, PathBuf};\n \n+use crate::rustc_stderr::Level;\n+use crate::rustc_stderr::Message;\n+\n use super::*;\n \n fn config() -> Config {\n@@ -29,25 +32,292 @@ fn main() {\n     let comments = Comments::parse(&path, s);\n     let mut errors = vec![];\n     let config = config();\n-    // Crucially, the intended error string *does* appear in this output, as a quote of the comment itself.\n-    let stderr = br\"\n-error: Undefined Behavior: type validation failed: encountered a dangling reference (address 0x10 is unallocated)\n-  --> tests/compile-fail/validity/dangling_ref1.rs:6:29\n-   |\n-LL |     let _x: &i32 = unsafe { mem::transmute(16usize) }; //~ ERROR encountered a dangling reference (address $HEX is unallocated)\n-   |                             ^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a dangling reference (address 0x10 is unallocated)\n-   |\n-   = help: this indicates a bug in the program: it performed an invalid operation, and caused Undefined Behavior\n-   = help: see https://doc.rust-lang.org/nightly/reference/behavior-considered-undefined.html for further information\n-           \n-   = note: inside `main` at tests/compile-fail/validity/dangling_ref1.rs:6:29\n-note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace\n-error: aborting due to previous error\n+    let messages = vec![\n+        vec![], vec![], vec![], vec![], vec![],\n+        vec![\n+            Message {\n+                message:\"Undefined Behavior: type validation failed: encountered a dangling reference (address 0x10 is unallocated)\".to_string(),\n+                level: Level::Error,\n+            }\n+        ]\n+    ];\n+    check_annotations(messages, vec![], Path::new(\"moobar\"), &mut errors, &config, \"\", &comments);\n+    match &errors[..] {\n+        [\n+            Error::PatternNotFound { definition_line: 5, .. },\n+            Error::ErrorsWithoutPattern { path: Some((_, 5)), .. },\n+        ] => {}\n+        _ => panic!(\"{:#?}\", errors),\n+    }\n+}\n+\n+#[test]\n+fn find_pattern() {\n+    let s = r\"\n+use std::mem;\n+\n+fn main() {\n+    let _x: &i32 = unsafe { mem::transmute(16usize) }; //~ ERROR encountered a dangling reference (address 0x10 is unallocated)\n+}\n+    \";\n+    let comments = Comments::parse(Path::new(\"<dummy>\"), s);\n+    let config = config();\n+    {\n+        let messages = vec![vec![], vec![], vec![], vec![], vec![], vec![\n+                Message {\n+                    message: \"Undefined Behavior: type validation failed: encountered a dangling reference (address 0x10 is unallocated)\".to_string(),\n+                    level: Level::Error,\n+                }\n+            ]\n+        ];\n+        let mut errors = vec![];\n+        check_annotations(\n+            messages,\n+            vec![],\n+            Path::new(\"moobar\"),\n+            &mut errors,\n+            &config,\n+            \"\",\n+            &comments,\n+        );\n+        match &errors[..] {\n+            [] => {}\n+            _ => panic!(\"{:#?}\", errors),\n+        }\n+    }\n+\n+    // only difference to above is a wrong line number\n+    {\n+        let messages = vec![vec![], vec![], vec![], vec![], vec![\n+                Message {\n+                    message: \"Undefined Behavior: type validation failed: encountered a dangling reference (address 0x10 is unallocated)\".to_string(),\n+                    level: Level::Error,\n+                }\n+            ]\n+        ];\n+        let mut errors = vec![];\n+        check_annotations(\n+            messages,\n+            vec![],\n+            Path::new(\"moobar\"),\n+            &mut errors,\n+            &config,\n+            \"\",\n+            &comments,\n+        );\n+        match &errors[..] {\n+            [\n+                Error::PatternNotFound { definition_line: 5, .. },\n+                Error::ErrorsWithoutPattern { path: Some((_, 4)), .. },\n+            ] => {}\n+            _ => panic!(\"not the expected error: {:#?}\", errors),\n+        }\n+    }\n+\n+    // only difference to first is a wrong level\n+    {\n+        let messages = vec![\n+            vec![], vec![], vec![], vec![], vec![],\n+            vec![\n+                Message {\n+                    message: \"Undefined Behavior: type validation failed: encountered a dangling reference (address 0x10 is unallocated)\".to_string(),\n+                    level: Level::Note,\n+                }\n+            ]\n+        ];\n+        let mut errors = vec![];\n+        check_annotations(\n+            messages,\n+            vec![],\n+            Path::new(\"moobar\"),\n+            &mut errors,\n+            &config,\n+            \"\",\n+            &comments,\n+        );\n+        match &errors[..] {\n+            // Note no `ErrorsWithoutPattern`, because there are no `//~NOTE` in the test file, so we ignore them\n+            [Error::PatternNotFound { definition_line: 5, .. }] => {}\n+            _ => panic!(\"not the expected error: {:#?}\", errors),\n+        }\n+    }\n+}\n+\n+#[test]\n+fn duplicate_pattern() {\n+    let s = r\"\n+use std::mem;\n+\n+fn main() {\n+    let _x: &i32 = unsafe { mem::transmute(16usize) }; //~ ERROR encountered a dangling reference (address 0x10 is unallocated)\n+    //~^ ERROR encountered a dangling reference (address 0x10 is unallocated)\n+}\n+    \";\n+    let comments = Comments::parse(Path::new(\"<dummy>\"), s);\n+    let config = config();\n+    let messages = vec![\n+        vec![], vec![], vec![], vec![], vec![],\n+        vec![\n+            Message {\n+                message: \"Undefined Behavior: type validation failed: encountered a dangling reference (address 0x10 is unallocated)\".to_string(),\n+                level: Level::Error,\n+            }\n+        ]\n+    ];\n+    let mut errors = vec![];\n+    check_annotations(messages, vec![], Path::new(\"moobar\"), &mut errors, &config, \"\", &comments);\n+    match &errors[..] {\n+        [Error::PatternNotFound { definition_line: 6, .. }] => {}\n+        _ => panic!(\"{:#?}\", errors),\n+    }\n+}\n+\n+#[test]\n+fn missing_pattern() {\n+    let s = r\"\n+use std::mem;\n+\n+fn main() {\n+    let _x: &i32 = unsafe { mem::transmute(16usize) }; //~ ERROR encountered a dangling reference (address 0x10 is unallocated)\n+}\n+    \";\n+    let comments = Comments::parse(Path::new(\"<dummy>\"), s);\n+    let config = config();\n+    let messages = vec![\n+        vec![], vec![], vec![], vec![], vec![],\n+        vec![\n+            Message {\n+                message: \"Undefined Behavior: type validation failed: encountered a dangling reference (address 0x10 is unallocated)\".to_string(),\n+                level: Level::Error,\n+            },\n+            Message {\n+                message: \"Undefined Behavior: type validation failed: encountered a dangling reference (address 0x10 is unallocated)\".to_string(),\n+                level: Level::Error,\n+            }\n+        ]\n+    ];\n+    let mut errors = vec![];\n+    check_annotations(messages, vec![], Path::new(\"moobar\"), &mut errors, &config, \"\", &comments);\n+    match &errors[..] {\n+        [Error::ErrorsWithoutPattern { path: Some((_, 5)), .. }] => {}\n+        _ => panic!(\"{:#?}\", errors),\n+    }\n+}\n+\n+#[test]\n+fn missing_warn_pattern() {\n+    let s = r\"\n+use std::mem;\n+\n+fn main() {\n+    let _x: &i32 = unsafe { mem::transmute(16usize) }; //~ ERROR encountered a dangling reference (address 0x10 is unallocated)\n+    //~^ WARN cake\n+}\n+    \";\n+    let comments = Comments::parse(Path::new(\"<dummy>\"), s);\n+    let config = config();\n+    let messages= vec![\n+        vec![],\n+        vec![],\n+        vec![],\n+        vec![],\n+        vec![],\n+        vec![\n+            Message {\n+                message: \"Undefined Behavior: type validation failed: encountered a dangling reference (address 0x10 is unallocated)\".to_string(),\n+                level: Level::Error,\n+            },\n+            Message {\n+                message: \"kaboom\".to_string(),\n+                level: Level::Warn,\n+            },\n+            Message {\n+                message: \"cake\".to_string(),\n+                level: Level::Warn,\n+            },\n+        ],\n+    ];\n+    let mut errors = vec![];\n+    check_annotations(messages, vec![], Path::new(\"moobar\"), &mut errors, &config, \"\", &comments);\n+    match &errors[..] {\n+        [Error::ErrorsWithoutPattern { path: Some((_, 5)), msgs, .. }] =>\n+            match &msgs[..] {\n+                [Message { message, level: Level::Warn }] if message == \"kaboom\" => {}\n+                _ => panic!(\"{:#?}\", msgs),\n+            },\n+        _ => panic!(\"{:#?}\", errors),\n+    }\n+}\n+\n+#[test]\n+fn missing_implicit_warn_pattern() {\n+    let s = r\"\n+use std::mem;\n+\n+fn main() {\n+    let _x: &i32 = unsafe { mem::transmute(16usize) }; //~ ERROR encountered a dangling reference (address 0x10 is unallocated)\n+    //~^ cake\n+}\n+    \";\n+    let comments = Comments::parse(Path::new(\"<dummy>\"), s);\n+    let config = config();\n+    let messages = vec![\n+        vec![],\n+        vec![],\n+        vec![],\n+        vec![],\n+        vec![],\n+        vec![\n+            Message {\n+                message: \"Undefined Behavior: type validation failed: encountered a dangling reference (address 0x10 is unallocated)\".to_string(),\n+                level: Level::Error,\n+            },\n+            Message {\n+                message: \"kaboom\".to_string(),\n+                level: Level::Warn,\n+            },\n+            Message {\n+                message: \"cake\".to_string(),\n+                level: Level::Warn,\n+            },\n+        ],\n+    ];\n+    let mut errors = vec![];\n+    check_annotations(messages, vec![], Path::new(\"moobar\"), &mut errors, &config, \"\", &comments);\n+    match &errors[..] {\n+        [] => {}\n+        _ => panic!(\"{:#?}\", errors),\n+    }\n+}\n+\n+#[test]\n+fn implicit_err_pattern() {\n+    let s = r\"\n+use std::mem;\n+\n+fn main() {\n+    let _x: &i32 = unsafe { mem::transmute(16usize) }; //~ encountered a dangling reference (address 0x10 is unallocated)\n+}\n     \";\n-    check_test_result(&path, &config, \"\", \"\", &comments, &mut errors, /*stdout*/ br\"\", stderr);\n-    // The \"OutputDiffers\" is because we cannot open the .rs file\n+    let comments = Comments::parse(Path::new(\"<dummy>\"), s);\n+    let config = config();\n+    let messages = vec![\n+        vec![],\n+        vec![],\n+        vec![],\n+        vec![],\n+        vec![],\n+        vec![\n+            Message {\n+                message: \"Undefined Behavior: type validation failed: encountered a dangling reference (address 0x10 is unallocated)\".to_string(),\n+                level: Level::Error,\n+            },\n+        ],\n+    ];\n+    let mut errors = vec![];\n+    check_annotations(messages, vec![], Path::new(\"moobar\"), &mut errors, &config, \"\", &comments);\n     match &errors[..] {\n-        [Error::OutputDiffers { .. }, Error::PatternNotFound { .. }] => {}\n-        _ => panic!(\"not the expected error: {:#?}\", errors),\n+        [Error::ErrorPatternWithoutErrorAnnotation(_, 5)] => {}\n+        _ => panic!(\"{:#?}\", errors),\n     }\n }"}]}