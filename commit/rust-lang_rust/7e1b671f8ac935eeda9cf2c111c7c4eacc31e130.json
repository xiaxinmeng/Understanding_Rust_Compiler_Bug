{"sha": "7e1b671f8ac935eeda9cf2c111c7c4eacc31e130", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdlMWI2NzFmOGFjOTM1ZWVkYTljZjJjMTExYzdjNGVhY2MzMWUxMzA=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-07-09T08:34:53Z"}, "committer": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-07-28T04:53:38Z"}, "message": "Cleanup using the new parse_*_seq methods.", "tree": {"sha": "2fc312525855258a7ce9feece35217830a084895", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2fc312525855258a7ce9feece35217830a084895"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7e1b671f8ac935eeda9cf2c111c7c4eacc31e130", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7e1b671f8ac935eeda9cf2c111c7c4eacc31e130", "html_url": "https://github.com/rust-lang/rust/commit/7e1b671f8ac935eeda9cf2c111c7c4eacc31e130", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7e1b671f8ac935eeda9cf2c111c7c4eacc31e130/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7aeb4b732796449237d3098f5cbe44f468fe6ef1", "url": "https://api.github.com/repos/rust-lang/rust/commits/7aeb4b732796449237d3098f5cbe44f468fe6ef1", "html_url": "https://github.com/rust-lang/rust/commit/7aeb4b732796449237d3098f5cbe44f468fe6ef1"}], "stats": {"total": 156, "additions": 60, "deletions": 96}, "files": [{"sha": "ec55c52745327136571f920dafad5f750dcd0300", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 60, "deletions": 96, "changes": 156, "blob_url": "https://github.com/rust-lang/rust/blob/7e1b671f8ac935eeda9cf2c111c7c4eacc31e130/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e1b671f8ac935eeda9cf2c111c7c4eacc31e130/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=7e1b671f8ac935eeda9cf2c111c7c4eacc31e130", "patch": "@@ -1817,15 +1817,7 @@ impl<'a> Parser<'a> {\n                 AngleBracketedArgs { args, constraints, span }.into()\n             } else {\n                 // `(T, U) -> R`\n-                self.bump(); // `(`\n-                let (inputs, recovered) = self.parse_seq_to_before_tokens(\n-                    &[&token::CloseDelim(token::Paren)],\n-                    SeqSep::trailing_allowed(token::Comma),\n-                    TokenExpectType::Expect,\n-                    |p| p.parse_ty())?;\n-                if !recovered {\n-                    self.bump(); // `)`\n-                }\n+                let (inputs, _) = self.parse_paren_comma_seq(|p| p.parse_ty())?;\n                 let span = lo.to(self.prev_span);\n                 let output = if self.eat(&token::RArrow) {\n                     Some(self.parse_ty_common(false, false, false)?)\n@@ -2529,12 +2521,7 @@ impl<'a> Parser<'a> {\n         Ok(match self.token.kind {\n             token::OpenDelim(token::Paren) => {\n                 // Method call `expr.f()`\n-                let mut args = self.parse_unspanned_seq(\n-                    &token::OpenDelim(token::Paren),\n-                    &token::CloseDelim(token::Paren),\n-                    SeqSep::trailing_allowed(token::Comma),\n-                    |p| Ok(p.parse_expr()?)\n-                )?;\n+                let mut args = self.parse_paren_expr_seq()?;\n                 args.insert(0, self_arg);\n \n                 let span = lo.to(self.prev_span);\n@@ -2619,12 +2606,7 @@ impl<'a> Parser<'a> {\n             match self.token.kind {\n                 // expr(...)\n                 token::OpenDelim(token::Paren) => {\n-                    let seq = self.parse_unspanned_seq(\n-                        &token::OpenDelim(token::Paren),\n-                        &token::CloseDelim(token::Paren),\n-                        SeqSep::trailing_allowed(token::Comma),\n-                        |p| Ok(p.parse_expr()?)\n-                    ).map(|es| {\n+                    let seq = self.parse_paren_expr_seq().map(|es| {\n                         let nd = self.mk_call(e, es);\n                         let hi = self.prev_span;\n                         self.mk_expr(lo.to(hi), nd, ThinVec::new())\n@@ -5376,59 +5358,48 @@ impl<'a> Parser<'a> {\n \n     fn parse_fn_args(&mut self, named_args: bool, allow_c_variadic: bool)\n                      -> PResult<'a, (Vec<Arg> , bool)> {\n-        self.expect(&token::OpenDelim(token::Paren))?;\n-\n         let sp = self.token.span;\n         let mut c_variadic = false;\n-        let (args, recovered): (Vec<Option<Arg>>, bool) =\n-            self.parse_seq_to_before_end(\n-                &token::CloseDelim(token::Paren),\n-                SeqSep::trailing_allowed(token::Comma),\n-                |p| {\n-                    let do_not_enforce_named_arguments_for_c_variadic =\n-                        |token: &token::Token| -> bool {\n-                            if token == &token::DotDotDot {\n-                                false\n-                            } else {\n-                                named_args\n-                            }\n-                        };\n-                    match p.parse_arg_general(\n-                        false,\n-                        allow_c_variadic,\n-                        do_not_enforce_named_arguments_for_c_variadic\n-                    ) {\n-                        Ok(arg) => {\n-                            if let TyKind::CVarArgs = arg.ty.node {\n-                                c_variadic = true;\n-                                if p.token != token::CloseDelim(token::Paren) {\n-                                    let span = p.token.span;\n-                                    p.span_err(span,\n-                                        \"`...` must be the last argument of a C-variadic function\");\n-                                    Ok(None)\n-                                } else {\n-                                    Ok(Some(arg))\n-                                }\n-                            } else {\n-                                Ok(Some(arg))\n-                            }\n-                        },\n-                        Err(mut e) => {\n-                            e.emit();\n-                            let lo = p.prev_span;\n-                            // Skip every token until next possible arg or end.\n-                            p.eat_to_tokens(&[&token::Comma, &token::CloseDelim(token::Paren)]);\n-                            // Create a placeholder argument for proper arg count (issue #34264).\n-                            let span = lo.to(p.prev_span);\n-                            Ok(Some(dummy_arg(Ident::new(kw::Invalid, span))))\n+        let (args, _): (Vec<Option<Arg>>, _) = self.parse_paren_comma_seq(|p| {\n+            let do_not_enforce_named_arguments_for_c_variadic =\n+                |token: &token::Token| -> bool {\n+                    if token == &token::DotDotDot {\n+                        false\n+                    } else {\n+                        named_args\n+                    }\n+                };\n+            match p.parse_arg_general(\n+                false,\n+                allow_c_variadic,\n+                do_not_enforce_named_arguments_for_c_variadic\n+            ) {\n+                Ok(arg) => {\n+                    if let TyKind::CVarArgs = arg.ty.node {\n+                        c_variadic = true;\n+                        if p.token != token::CloseDelim(token::Paren) {\n+                            let span = p.token.span;\n+                            p.span_err(span,\n+                                \"`...` must be the last argument of a C-variadic function\");\n+                            Ok(None)\n+                        } else {\n+                            Ok(Some(arg))\n                         }\n+                    } else {\n+                        Ok(Some(arg))\n                     }\n+                },\n+                Err(mut e) => {\n+                    e.emit();\n+                    let lo = p.prev_span;\n+                    // Skip every token until next possible arg or end.\n+                    p.eat_to_tokens(&[&token::Comma, &token::CloseDelim(token::Paren)]);\n+                    // Create a placeholder argument for proper arg count (issue #34264).\n+                    let span = lo.to(p.prev_span);\n+                    Ok(Some(dummy_arg(Ident::new(kw::Invalid, span))))\n                 }\n-            )?;\n-\n-        if !recovered {\n-            self.eat(&token::CloseDelim(token::Paren));\n-        }\n+            }\n+        })?;\n \n         let args: Vec<_> = args.into_iter().filter_map(|x| x).collect();\n \n@@ -5590,7 +5561,7 @@ impl<'a> Parser<'a> {\n                 (vec![self_arg], false)\n             } else if self.eat(&token::Comma) {\n                 let mut fn_inputs = vec![self_arg];\n-                let (mut input, recovered) = self.parse_seq_to_before_end(\n+                let (mut input, _, recovered) = self.parse_seq_to_before_end(\n                     &token::CloseDelim(token::Paren), sep, parse_arg_fn)?;\n                 fn_inputs.append(&mut input);\n                 (fn_inputs, recovered)\n@@ -5601,7 +5572,9 @@ impl<'a> Parser<'a> {\n                 }\n             }\n         } else {\n-            self.parse_seq_to_before_end(&token::CloseDelim(token::Paren), sep, parse_arg_fn)?\n+            let (input, _, recovered) =\n+                self.parse_seq_to_before_end(&token::CloseDelim(token::Paren), sep, parse_arg_fn)?;\n+            (input, recovered)\n         };\n \n         if !recovered {\n@@ -6202,26 +6175,20 @@ impl<'a> Parser<'a> {\n     fn parse_tuple_struct_body(&mut self) -> PResult<'a, Vec<StructField>> {\n         // This is the case where we find `struct Foo<T>(T) where T: Copy;`\n         // Unit like structs are handled in parse_item_struct function\n-        let fields = self.parse_unspanned_seq(\n-            &token::OpenDelim(token::Paren),\n-            &token::CloseDelim(token::Paren),\n-            SeqSep::trailing_allowed(token::Comma),\n-            |p| {\n-                let attrs = p.parse_outer_attributes()?;\n-                let lo = p.token.span;\n-                let vis = p.parse_visibility(true)?;\n-                let ty = p.parse_ty()?;\n-                Ok(StructField {\n-                    span: lo.to(ty.span),\n-                    vis,\n-                    ident: None,\n-                    id: ast::DUMMY_NODE_ID,\n-                    ty,\n-                    attrs,\n-                })\n-            })?;\n-\n-        Ok(fields)\n+        self.parse_paren_comma_seq(|p| {\n+            let attrs = p.parse_outer_attributes()?;\n+            let lo = p.token.span;\n+            let vis = p.parse_visibility(true)?;\n+            let ty = p.parse_ty()?;\n+            Ok(StructField {\n+                span: lo.to(ty.span),\n+                vis,\n+                ident: None,\n+                id: ast::DUMMY_NODE_ID,\n+                ty,\n+                attrs,\n+            })\n+        }).map(|(r, _)| r)\n     }\n \n     /// Parses a structure field declaration.\n@@ -7803,11 +7770,8 @@ impl<'a> Parser<'a> {\n     /// USE_TREE_LIST = \u00d8 | (USE_TREE `,`)* USE_TREE [`,`]\n     /// ```\n     fn parse_use_tree_list(&mut self) -> PResult<'a, Vec<(UseTree, ast::NodeId)>> {\n-        self.parse_unspanned_seq(&token::OpenDelim(token::Brace),\n-                                 &token::CloseDelim(token::Brace),\n-                                 SeqSep::trailing_allowed(token::Comma), |this| {\n-            Ok((this.parse_use_tree()?, ast::DUMMY_NODE_ID))\n-        })\n+        self.parse_delim_comma_seq(token::Brace, |p| Ok((p.parse_use_tree()?, ast::DUMMY_NODE_ID)))\n+            .map(|(r, _)| r)\n     }\n \n     fn parse_rename(&mut self) -> PResult<'a, Option<Ident>> {"}]}