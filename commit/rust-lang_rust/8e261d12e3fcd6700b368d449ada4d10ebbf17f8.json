{"sha": "8e261d12e3fcd6700b368d449ada4d10ebbf17f8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhlMjYxZDEyZTNmY2Q2NzAwYjM2OGQ0NDlhZGE0ZDEwZWJiZjE3Zjg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-03-04T04:19:30Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-03-04T04:19:30Z"}, "message": "Auto merge of #31945 - sfackler:net2, r=alexcrichton\n\nI have these tagged as stable in 1.9, so this shouldn't merge until the 1.8 beta's cut.", "tree": {"sha": "074a84dfc15f10da393c3eb3e876dc4ad1dadd83", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/074a84dfc15f10da393c3eb3e876dc4ad1dadd83"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8e261d12e3fcd6700b368d449ada4d10ebbf17f8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8e261d12e3fcd6700b368d449ada4d10ebbf17f8", "html_url": "https://github.com/rust-lang/rust/commit/8e261d12e3fcd6700b368d449ada4d10ebbf17f8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8e261d12e3fcd6700b368d449ada4d10ebbf17f8/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e91f889ed3a7ced584e90cf7b05e2c0ac476f900", "url": "https://api.github.com/repos/rust-lang/rust/commits/e91f889ed3a7ced584e90cf7b05e2c0ac476f900", "html_url": "https://github.com/rust-lang/rust/commit/e91f889ed3a7ced584e90cf7b05e2c0ac476f900"}, {"sha": "e4aa513139cd1d25a42f9827ad677c045df3618d", "url": "https://api.github.com/repos/rust-lang/rust/commits/e4aa513139cd1d25a42f9827ad677c045df3618d", "html_url": "https://github.com/rust-lang/rust/commit/e4aa513139cd1d25a42f9827ad677c045df3618d"}], "stats": {"total": 737, "additions": 733, "deletions": 4}, "files": [{"sha": "f8e3b58bb3e9565f994faca1790966a9fb3e87b0", "filename": "src/libstd/net/tcp.rs", "status": "modified", "additions": 195, "deletions": 0, "changes": 195, "blob_url": "https://github.com/rust-lang/rust/blob/8e261d12e3fcd6700b368d449ada4d10ebbf17f8/src%2Flibstd%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e261d12e3fcd6700b368d449ada4d10ebbf17f8/src%2Flibstd%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Ftcp.rs?ref=8e261d12e3fcd6700b368d449ada4d10ebbf17f8", "patch": "@@ -180,6 +180,89 @@ impl TcpStream {\n     pub fn write_timeout(&self) -> io::Result<Option<Duration>> {\n         self.0.write_timeout()\n     }\n+\n+    /// Sets the value of the `TCP_NODELAY` option on this socket.\n+    ///\n+    /// If set, this option disables the Nagle algorithm. This means that\n+    /// segments are always sent as soon as possible, even if there is only a\n+    /// small amount of data. When not set, data is buffered until there is a\n+    /// sufficient amount to send out, thereby avoiding the frequent sending of\n+    /// small packets.\n+    #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n+    pub fn set_nodelay(&self, nodelay: bool) -> io::Result<()> {\n+        self.0.set_nodelay(nodelay)\n+    }\n+\n+    /// Gets the value of the `TCP_NODELAY` option on this socket.\n+    ///\n+    /// For more information about this option, see [`set_nodelay`][link].\n+    ///\n+    /// [link]: #tymethod.set_nodelay\n+    #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n+    pub fn nodelay(&self) -> io::Result<bool> {\n+        self.0.nodelay()\n+    }\n+\n+    /// Sets the value for the `IP_TTL` option on this socket.\n+    ///\n+    /// This value sets the time-to-live field that is used in every packet sent\n+    /// from this socket.\n+    #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n+    pub fn set_ttl(&self, ttl: u32) -> io::Result<()> {\n+        self.0.set_ttl(ttl)\n+    }\n+\n+    /// Gets the value of the `IP_TTL` option for this socket.\n+    ///\n+    /// For more information about this option, see [`set_ttl`][link].\n+    ///\n+    /// [link]: #tymethod.set_ttl\n+    #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n+    pub fn ttl(&self) -> io::Result<u32> {\n+        self.0.ttl()\n+    }\n+\n+    /// Sets the value for the `IPV6_V6ONLY` option on this socket.\n+    ///\n+    /// If this is set to `true` then the socket is restricted to sending and\n+    /// receiving IPv6 packets only. If this is the case, an IPv4 and an IPv6\n+    /// application can each bind the same port at the same time.\n+    ///\n+    /// If this is set to `false` then the socket can be used to send and\n+    /// receive packets from an IPv4-mapped IPv6 address.\n+    #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n+    pub fn set_only_v6(&self, only_v6: bool) -> io::Result<()> {\n+        self.0.set_only_v6(only_v6)\n+    }\n+\n+    /// Gets the value of the `IPV6_V6ONLY` option for this socket.\n+    ///\n+    /// For more information about this option, see [`set_only_v6`][link].\n+    ///\n+    /// [link]: #tymethod.set_only_v6\n+    #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n+    pub fn only_v6(&self) -> io::Result<bool> {\n+        self.0.only_v6()\n+    }\n+\n+    /// Get the value of the `SO_ERROR` option on this socket.\n+    ///\n+    /// This will retrieve the stored error in the underlying socket, clearing\n+    /// the field in the process. This can be useful for checking errors between\n+    /// calls.\n+    #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n+    pub fn take_error(&self) -> io::Result<Option<io::Error>> {\n+        self.0.take_error()\n+    }\n+\n+    /// Moves this TCP stream into or out of nonblocking mode.\n+    ///\n+    /// On Unix this corresponds to calling fcntl, and on Windows this\n+    /// corresponds to calling ioctlsocket.\n+    #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n+    pub fn set_nonblocking(&self, nonblocking: bool) -> io::Result<()> {\n+        self.0.set_nonblocking(nonblocking)\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -278,6 +361,67 @@ impl TcpListener {\n     pub fn incoming(&self) -> Incoming {\n         Incoming { listener: self }\n     }\n+\n+    /// Sets the value for the `IP_TTL` option on this socket.\n+    ///\n+    /// This value sets the time-to-live field that is used in every packet sent\n+    /// from this socket.\n+    #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n+    pub fn set_ttl(&self, ttl: u32) -> io::Result<()> {\n+        self.0.set_ttl(ttl)\n+    }\n+\n+    /// Gets the value of the `IP_TTL` option for this socket.\n+    ///\n+    /// For more information about this option, see [`set_ttl`][link].\n+    ///\n+    /// [link]: #tymethod.set_ttl\n+    #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n+    pub fn ttl(&self) -> io::Result<u32> {\n+        self.0.ttl()\n+    }\n+\n+    /// Sets the value for the `IPV6_V6ONLY` option on this socket.\n+    ///\n+    /// If this is set to `true` then the socket is restricted to sending and\n+    /// receiving IPv6 packets only. In this case two IPv4 and IPv6 applications\n+    /// can bind the same port at the same time.\n+    ///\n+    /// If this is set to `false` then the socket can be used to send and\n+    /// receive packets from an IPv4-mapped IPv6 address.\n+    #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n+    pub fn set_only_v6(&self, only_v6: bool) -> io::Result<()> {\n+        self.0.set_only_v6(only_v6)\n+    }\n+\n+    /// Gets the value of the `IPV6_V6ONLY` option for this socket.\n+    ///\n+    /// For more information about this option, see [`set_only_v6`][link].\n+    ///\n+    /// [link]: #tymethod.set_only_v6\n+    #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n+    pub fn only_v6(&self) -> io::Result<bool> {\n+        self.0.only_v6()\n+    }\n+\n+    /// Get the value of the `SO_ERROR` option on this socket.\n+    ///\n+    /// This will retrieve the stored error in the underlying socket, clearing\n+    /// the field in the process. This can be useful for checking errors between\n+    /// calls.\n+    #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n+    pub fn take_error(&self) -> io::Result<Option<io::Error>> {\n+        self.0.take_error()\n+    }\n+\n+    /// Moves this TCP stream into or out of nonblocking mode.\n+    ///\n+    /// On Unix this corresponds to calling fcntl, and on Windows this\n+    /// corresponds to calling ioctlsocket.\n+    #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n+    pub fn set_nonblocking(&self, nonblocking: bool) -> io::Result<()> {\n+        self.0.set_nonblocking(nonblocking)\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -969,4 +1113,55 @@ mod tests {\n         assert!(start.elapsed() > Duration::from_millis(400));\n         drop(listener);\n     }\n+\n+    #[test]\n+    fn nodelay() {\n+        let addr = next_test_ip4();\n+        let _listener = t!(TcpListener::bind(&addr));\n+\n+        let stream = t!(TcpStream::connect(&(\"localhost\", addr.port())));\n+\n+        assert_eq!(false, t!(stream.nodelay()));\n+        t!(stream.set_nodelay(true));\n+        assert_eq!(true, t!(stream.nodelay()));\n+        t!(stream.set_nodelay(false));\n+        assert_eq!(false, t!(stream.nodelay()));\n+    }\n+\n+    #[test]\n+    fn ttl() {\n+        let ttl = 100;\n+\n+        let addr = next_test_ip4();\n+        let listener = t!(TcpListener::bind(&addr));\n+\n+        t!(listener.set_ttl(ttl));\n+        assert_eq!(ttl, t!(listener.ttl()));\n+\n+        let stream = t!(TcpStream::connect(&(\"localhost\", addr.port())));\n+\n+        t!(stream.set_ttl(ttl));\n+        assert_eq!(ttl, t!(stream.ttl()));\n+    }\n+\n+    #[test]\n+    fn set_nonblocking() {\n+        let addr = next_test_ip4();\n+        let listener = t!(TcpListener::bind(&addr));\n+\n+        t!(listener.set_nonblocking(true));\n+        t!(listener.set_nonblocking(false));\n+\n+        let mut stream = t!(TcpStream::connect(&(\"localhost\", addr.port())));\n+\n+        t!(stream.set_nonblocking(false));\n+        t!(stream.set_nonblocking(true));\n+\n+        let mut buf = [0];\n+        match stream.read(&mut buf) {\n+            Ok(_) => panic!(\"expected error\"),\n+            Err(ref e) if e.kind() == ErrorKind::WouldBlock => {}\n+            Err(e) => panic!(\"unexpected error {}\", e),\n+        }\n+    }\n }"}, {"sha": "bce82565fdf4c55bc75b9a8fba06e21f69fb98b7", "filename": "src/libstd/net/udp.rs", "status": "modified", "additions": 252, "deletions": 1, "changes": 253, "blob_url": "https://github.com/rust-lang/rust/blob/8e261d12e3fcd6700b368d449ada4d10ebbf17f8/src%2Flibstd%2Fnet%2Fudp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e261d12e3fcd6700b368d449ada4d10ebbf17f8/src%2Flibstd%2Fnet%2Fudp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Fudp.rs?ref=8e261d12e3fcd6700b368d449ada4d10ebbf17f8", "patch": "@@ -10,7 +10,7 @@\n \n use fmt;\n use io::{self, Error, ErrorKind};\n-use net::{ToSocketAddrs, SocketAddr};\n+use net::{ToSocketAddrs, SocketAddr, Ipv4Addr, Ipv6Addr};\n use sys_common::net as net_imp;\n use sys_common::{AsInner, FromInner, IntoInner};\n use time::Duration;\n@@ -140,6 +140,221 @@ impl UdpSocket {\n     pub fn write_timeout(&self) -> io::Result<Option<Duration>> {\n         self.0.write_timeout()\n     }\n+\n+    /// Sets the value of the `SO_BROADCAST` option for this socket.\n+    ///\n+    /// When enabled, this socket is allowed to send packets to a broadcast\n+    /// address.\n+    #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n+    pub fn set_broadcast(&self, broadcast: bool) -> io::Result<()> {\n+        self.0.set_broadcast(broadcast)\n+    }\n+\n+    /// Gets the value of the `SO_BROADCAST` option for this socket.\n+    ///\n+    /// For more information about this option, see\n+    /// [`set_broadcast`][link].\n+    ///\n+    /// [link]: #tymethod.set_broadcast\n+    #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n+    pub fn broadcast(&self) -> io::Result<bool> {\n+        self.0.broadcast()\n+    }\n+\n+    /// Sets the value of the `IP_MULTICAST_LOOP` option for this socket.\n+    ///\n+    /// If enabled, multicast packets will be looped back to the local socket.\n+    /// Note that this may not have any affect on IPv6 sockets.\n+    #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n+    pub fn set_multicast_loop_v4(&self, multicast_loop_v4: bool) -> io::Result<()> {\n+        self.0.set_multicast_loop_v4(multicast_loop_v4)\n+    }\n+\n+    /// Gets the value of the `IP_MULTICAST_LOOP` option for this socket.\n+    ///\n+    /// For more information about this option, see\n+    /// [`set_multicast_loop_v4`][link].\n+    ///\n+    /// [link]: #tymethod.set_multicast_loop_v4\n+    #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n+    pub fn multicast_loop_v4(&self) -> io::Result<bool> {\n+        self.0.multicast_loop_v4()\n+    }\n+\n+    /// Sets the value of the `IP_MULTICAST_TTL` option for this socket.\n+    ///\n+    /// Indicates the time-to-live value of outgoing multicast packets for\n+    /// this socket. The default value is 1 which means that multicast packets\n+    /// don't leave the local network unless explicitly requested.\n+    ///\n+    /// Note that this may not have any affect on IPv6 sockets.\n+    #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n+    pub fn set_multicast_ttl_v4(&self, multicast_ttl_v4: u32) -> io::Result<()> {\n+        self.0.set_multicast_ttl_v4(multicast_ttl_v4)\n+    }\n+\n+    /// Gets the value of the `IP_MULTICAST_TTL` option for this socket.\n+    ///\n+    /// For more information about this option, see\n+    /// [`set_multicast_ttl_v4`][link].\n+    ///\n+    /// [link]: #tymethod.set_multicast_ttl_v4\n+    #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n+    pub fn multicast_ttl_v4(&self) -> io::Result<u32> {\n+        self.0.multicast_ttl_v4()\n+    }\n+\n+    /// Sets the value of the `IPV6_MULTICAST_LOOP` option for this socket.\n+    ///\n+    /// Controls whether this socket sees the multicast packets it sends itself.\n+    /// Note that this may not have any affect on IPv4 sockets.\n+    #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n+    pub fn set_multicast_loop_v6(&self, multicast_loop_v6: bool) -> io::Result<()> {\n+        self.0.set_multicast_loop_v6(multicast_loop_v6)\n+    }\n+\n+    /// Gets the value of the `IPV6_MULTICAST_LOOP` option for this socket.\n+    ///\n+    /// For more information about this option, see\n+    /// [`set_multicast_loop_v6`][link].\n+    ///\n+    /// [link]: #tymethod.set_multicast_loop_v6\n+    #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n+    pub fn multicast_loop_v6(&self) -> io::Result<bool> {\n+        self.0.multicast_loop_v6()\n+    }\n+\n+    /// Sets the value for the `IP_TTL` option on this socket.\n+    ///\n+    /// This value sets the time-to-live field that is used in every packet sent\n+    /// from this socket.\n+    #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n+    pub fn set_ttl(&self, ttl: u32) -> io::Result<()> {\n+        self.0.set_ttl(ttl)\n+    }\n+\n+    /// Gets the value of the `IP_TTL` option for this socket.\n+    ///\n+    /// For more information about this option, see [`set_ttl`][link].\n+    ///\n+    /// [link]: #tymethod.set_ttl\n+    #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n+    pub fn ttl(&self) -> io::Result<u32> {\n+        self.0.ttl()\n+    }\n+\n+    /// Sets the value for the `IPV6_V6ONLY` option on this socket.\n+    ///\n+    /// If this is set to `true` then the socket is restricted to sending and\n+    /// receiving IPv6 packets only. If this is the case, an IPv4 and an IPv6\n+    /// application can each bind the same port at the same time.\n+    ///\n+    /// If this is set to `false` then the socket can be used to send and\n+    /// receive packets from an IPv4-mapped IPv6 address.\n+    #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n+    pub fn set_only_v6(&self, only_v6: bool) -> io::Result<()> {\n+        self.0.set_only_v6(only_v6)\n+    }\n+\n+    /// Gets the value of the `IPV6_V6ONLY` option for this socket.\n+    ///\n+    /// For more information about this option, see [`set_only_v6`][link].\n+    ///\n+    /// [link]: #tymethod.set_only_v6\n+    #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n+    pub fn only_v6(&self) -> io::Result<bool> {\n+        self.0.only_v6()\n+    }\n+\n+    /// Executes an operation of the `IP_ADD_MEMBERSHIP` type.\n+    ///\n+    /// This function specifies a new multicast group for this socket to join.\n+    /// The address must be a valid multicast address, and `interface` is the\n+    /// address of the local interface with which the system should join the\n+    /// multicast group. If it's equal to `INADDR_ANY` then an appropriate\n+    /// interface is chosen by the system.\n+    #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n+    pub fn join_multicast_v4(&self, multiaddr: &Ipv4Addr, interface: &Ipv4Addr) -> io::Result<()> {\n+        self.0.join_multicast_v4(multiaddr, interface)\n+    }\n+\n+    /// Executes an operation of the `IPV6_ADD_MEMBERSHIP` type.\n+    ///\n+    /// This function specifies a new multicast group for this socket to join.\n+    /// The address must be a valid multicast address, and `interface` is the\n+    /// index of the interface to join/leave (or 0 to indicate any interface).\n+    #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n+    pub fn join_multicast_v6(&self, multiaddr: &Ipv6Addr, interface: u32) -> io::Result<()> {\n+        self.0.join_multicast_v6(multiaddr, interface)\n+    }\n+\n+    /// Executes an operation of the `IP_DROP_MEMBERSHIP` type.\n+    ///\n+    /// For more information about this option, see\n+    /// [`join_multicast_v4`][link].\n+    ///\n+    /// [link]: #tymethod.join_multicast_v4\n+    #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n+    pub fn leave_multicast_v4(&self, multiaddr: &Ipv4Addr, interface: &Ipv4Addr) -> io::Result<()> {\n+        self.0.leave_multicast_v4(multiaddr, interface)\n+    }\n+\n+    /// Executes an operation of the `IPV6_DROP_MEMBERSHIP` type.\n+    ///\n+    /// For more information about this option, see\n+    /// [`join_multicast_v6`][link].\n+    ///\n+    /// [link]: #tymethod.join_multicast_v6\n+    #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n+    pub fn leave_multicast_v6(&self, multiaddr: &Ipv6Addr, interface: u32) -> io::Result<()> {\n+        self.0.leave_multicast_v6(multiaddr, interface)\n+    }\n+\n+    /// Get the value of the `SO_ERROR` option on this socket.\n+    ///\n+    /// This will retrieve the stored error in the underlying socket, clearing\n+    /// the field in the process. This can be useful for checking errors between\n+    /// calls.\n+    #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n+    pub fn take_error(&self) -> io::Result<Option<io::Error>> {\n+        self.0.take_error()\n+    }\n+\n+    /// Connects this UDP socket to a remote address, allowing the `send` and\n+    /// `recv` syscalls to be used to send data and also applies filters to only\n+    /// receive data from the specified address.\n+    #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n+    pub fn connect<A: ToSocketAddrs>(&self, addr: A) -> io::Result<()> {\n+        super::each_addr(addr, |addr| self.0.connect(addr))\n+    }\n+\n+    /// Sends data on the socket to the remote address to which it is connected.\n+    ///\n+    /// The `connect` method will connect this socket to a remote address. This\n+    /// method will fail if the socket is not connected.\n+    #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n+    pub fn send(&self, buf: &[u8]) -> io::Result<usize> {\n+        self.0.send(buf)\n+    }\n+\n+    /// Receives data on the socket from the remote address to which it is\n+    /// connected.\n+    ///\n+    /// The `connect` method will connect this socket to a remote address. This\n+    /// method will fail if the socket is not connected.\n+    #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n+    pub fn recv(&self, buf: &mut [u8]) -> io::Result<usize> {\n+        self.0.recv(buf)\n+    }\n+\n+    /// Moves this TCP stream into or out of nonblocking mode.\n+    ///\n+    /// On Unix this corresponds to calling fcntl, and on Windows this\n+    /// corresponds to calling ioctlsocket.\n+    #[stable(feature = \"net2_mutators\", since = \"1.9.0\")]\n+    pub fn set_nonblocking(&self, nonblocking: bool) -> io::Result<()> {\n+        self.0.set_nonblocking(nonblocking)\n+    }\n }\n \n impl AsInner<net_imp::UdpSocket> for UdpSocket {\n@@ -400,4 +615,40 @@ mod tests {\n         assert!(kind == ErrorKind::WouldBlock || kind == ErrorKind::TimedOut);\n         assert!(start.elapsed() > Duration::from_millis(400));\n     }\n+\n+    #[test]\n+    fn connect_send_recv() {\n+        let addr = next_test_ip4();\n+\n+        let socket = t!(UdpSocket::bind(&addr));\n+        t!(socket.connect(addr));\n+\n+        t!(socket.send(b\"hello world\"));\n+\n+        let mut buf = [0; 11];\n+        t!(socket.recv(&mut buf));\n+        assert_eq!(b\"hello world\", &buf[..]);\n+    }\n+\n+    #[test]\n+    fn ttl() {\n+        let ttl = 100;\n+\n+        let addr = next_test_ip4();\n+\n+        let stream = t!(UdpSocket::bind(&addr));\n+\n+        t!(stream.set_ttl(ttl));\n+        assert_eq!(ttl, t!(stream.ttl()));\n+    }\n+\n+    #[test]\n+    fn set_nonblocking() {\n+        let addr = next_test_ip4();\n+\n+        let stream = t!(UdpSocket::bind(&addr));\n+\n+        t!(stream.set_nonblocking(true));\n+        t!(stream.set_nonblocking(false));\n+    }\n }"}, {"sha": "ca4f6e19882b69e0913b63fd1ab9dba441d2cd81", "filename": "src/libstd/sys/common/net.rs", "status": "modified", "additions": 221, "deletions": 1, "changes": 222, "blob_url": "https://github.com/rust-lang/rust/blob/8e261d12e3fcd6700b368d449ada4d10ebbf17f8/src%2Flibstd%2Fsys%2Fcommon%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e261d12e3fcd6700b368d449ada4d10ebbf17f8/src%2Flibstd%2Fsys%2Fcommon%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fnet.rs?ref=8e261d12e3fcd6700b368d449ada4d10ebbf17f8", "patch": "@@ -17,14 +17,31 @@ use io::{self, Error, ErrorKind};\n use libc::{c_int, c_char, c_void};\n use mem;\n #[allow(deprecated)]\n-use net::{SocketAddr, Shutdown, IpAddr};\n+use net::{SocketAddr, Shutdown, IpAddr, Ipv4Addr, Ipv6Addr};\n use ptr;\n use str::from_utf8;\n use sys::net::{cvt, cvt_r, cvt_gai, Socket, init, wrlen_t};\n use sys::net::netc as c;\n use sys_common::{AsInner, FromInner, IntoInner};\n use time::Duration;\n \n+#[cfg(any(target_os = \"dragonfly\", target_os = \"freebsd\",\n+          target_os = \"ios\", target_os = \"macos\",\n+          target_os = \"openbsd\", target_os = \"netbsd\"))]\n+use sys::net::netc::IPV6_JOIN_GROUP as IPV6_ADD_MEMBERSHIP;\n+#[cfg(not(any(target_os = \"dragonfly\", target_os = \"freebsd\",\n+              target_os = \"ios\", target_os = \"macos\",\n+          target_os = \"openbsd\", target_os = \"netbsd\")))]\n+use sys::net::netc::IPV6_ADD_MEMBERSHIP;\n+#[cfg(any(target_os = \"dragonfly\", target_os = \"freebsd\",\n+          target_os = \"ios\", target_os = \"macos\",\n+          target_os = \"openbsd\", target_os = \"netbsd\"))]\n+use sys::net::netc::IPV6_LEAVE_GROUP as IPV6_DROP_MEMBERSHIP;\n+#[cfg(not(any(target_os = \"dragonfly\", target_os = \"freebsd\",\n+              target_os = \"ios\", target_os = \"macos\",\n+          target_os = \"openbsd\", target_os = \"netbsd\")))]\n+use sys::net::netc::IPV6_DROP_MEMBERSHIP;\n+\n ////////////////////////////////////////////////////////////////////////////////\n // sockaddr and misc bindings\n ////////////////////////////////////////////////////////////////////////////////\n@@ -84,6 +101,16 @@ fn sockaddr_to_addr(storage: &c::sockaddr_storage,\n     }\n }\n \n+#[cfg(target_os = \"android\")]\n+fn to_ipv6mr_interface(value: u32) -> c_int {\n+    value as c_int\n+}\n+\n+#[cfg(not(target_os = \"android\"))]\n+fn to_ipv6mr_interface(value: u32) -> ::libc::c_uint {\n+    value as ::libc::c_uint\n+}\n+\n ////////////////////////////////////////////////////////////////////////////////\n // get_host_addresses\n ////////////////////////////////////////////////////////////////////////////////\n@@ -228,6 +255,45 @@ impl TcpStream {\n     pub fn duplicate(&self) -> io::Result<TcpStream> {\n         self.inner.duplicate().map(|s| TcpStream { inner: s })\n     }\n+\n+    pub fn set_nodelay(&self, nodelay: bool) -> io::Result<()> {\n+        self.inner.set_nodelay(nodelay)\n+    }\n+\n+    pub fn nodelay(&self) -> io::Result<bool> {\n+        self.inner.nodelay()\n+    }\n+\n+    pub fn set_ttl(&self, ttl: u32) -> io::Result<()> {\n+        setsockopt(&self.inner, c::IPPROTO_IP, c::IP_TTL, ttl as c_int)\n+    }\n+\n+    pub fn ttl(&self) -> io::Result<u32> {\n+        let raw: c_int = try!(getsockopt(&self.inner, c::IPPROTO_IP, c::IP_TTL));\n+        Ok(raw as u32)\n+    }\n+\n+    pub fn set_only_v6(&self, only_v6: bool) -> io::Result<()> {\n+        setsockopt(&self.inner, c::IPPROTO_IPV6, c::IPV6_V6ONLY, only_v6 as c_int)\n+    }\n+\n+    pub fn only_v6(&self) -> io::Result<bool> {\n+        let raw: c_int = try!(getsockopt(&self.inner, c::IPPROTO_IPV6, c::IPV6_V6ONLY));\n+        Ok(raw != 0)\n+    }\n+\n+    pub fn take_error(&self) -> io::Result<Option<io::Error>> {\n+        let raw: c_int = try!(getsockopt(&self.inner, c::SOL_SOCKET, c::SO_ERROR));\n+        if raw == 0 {\n+            Ok(None)\n+        } else {\n+            Ok(Some(io::Error::from_raw_os_error(raw as i32)))\n+        }\n+    }\n+\n+    pub fn set_nonblocking(&self, nonblocking: bool) -> io::Result<()> {\n+        self.inner.set_nonblocking(nonblocking)\n+    }\n }\n \n impl FromInner<Socket> for TcpStream {\n@@ -307,6 +373,37 @@ impl TcpListener {\n     pub fn duplicate(&self) -> io::Result<TcpListener> {\n         self.inner.duplicate().map(|s| TcpListener { inner: s })\n     }\n+\n+    pub fn set_ttl(&self, ttl: u32) -> io::Result<()> {\n+        setsockopt(&self.inner, c::IPPROTO_IP, c::IP_TTL, ttl as c_int)\n+    }\n+\n+    pub fn ttl(&self) -> io::Result<u32> {\n+        let raw: c_int = try!(getsockopt(&self.inner, c::IPPROTO_IP, c::IP_TTL));\n+        Ok(raw as u32)\n+    }\n+\n+    pub fn set_only_v6(&self, only_v6: bool) -> io::Result<()> {\n+        setsockopt(&self.inner, c::IPPROTO_IPV6, c::IPV6_V6ONLY, only_v6 as c_int)\n+    }\n+\n+    pub fn only_v6(&self) -> io::Result<bool> {\n+        let raw: c_int = try!(getsockopt(&self.inner, c::IPPROTO_IPV6, c::IPV6_V6ONLY));\n+        Ok(raw != 0)\n+    }\n+\n+    pub fn take_error(&self) -> io::Result<Option<io::Error>> {\n+        let raw: c_int = try!(getsockopt(&self.inner, c::SOL_SOCKET, c::SO_ERROR));\n+        if raw == 0 {\n+            Ok(None)\n+        } else {\n+            Ok(Some(io::Error::from_raw_os_error(raw as i32)))\n+        }\n+    }\n+\n+    pub fn set_nonblocking(&self, nonblocking: bool) -> io::Result<()> {\n+        self.inner.set_nonblocking(nonblocking)\n+    }\n }\n \n impl FromInner<Socket> for TcpListener {\n@@ -401,6 +498,129 @@ impl UdpSocket {\n     pub fn write_timeout(&self) -> io::Result<Option<Duration>> {\n         self.inner.timeout(c::SO_SNDTIMEO)\n     }\n+\n+    pub fn set_broadcast(&self, broadcast: bool) -> io::Result<()> {\n+        setsockopt(&self.inner, c::SOL_SOCKET, c::SO_BROADCAST, broadcast as c_int)\n+    }\n+\n+    pub fn broadcast(&self) -> io::Result<bool> {\n+        let raw: c_int = try!(getsockopt(&self.inner, c::SOL_SOCKET, c::SO_BROADCAST));\n+        Ok(raw != 0)\n+    }\n+\n+    pub fn set_multicast_loop_v4(&self, multicast_loop_v4: bool) -> io::Result<()> {\n+        setsockopt(&self.inner, c::IPPROTO_IP, c::IP_MULTICAST_LOOP, multicast_loop_v4 as c_int)\n+    }\n+\n+    pub fn multicast_loop_v4(&self) -> io::Result<bool> {\n+        let raw: c_int = try!(getsockopt(&self.inner, c::IPPROTO_IP, c::IP_MULTICAST_LOOP));\n+        Ok(raw != 0)\n+    }\n+\n+    pub fn set_multicast_ttl_v4(&self, multicast_ttl_v4: u32) -> io::Result<()> {\n+        setsockopt(&self.inner, c::IPPROTO_IP, c::IP_MULTICAST_TTL, multicast_ttl_v4 as c_int)\n+    }\n+\n+    pub fn multicast_ttl_v4(&self) -> io::Result<u32> {\n+        let raw: c_int = try!(getsockopt(&self.inner, c::IPPROTO_IP, c::IP_MULTICAST_TTL));\n+        Ok(raw as u32)\n+    }\n+\n+    pub fn set_multicast_loop_v6(&self, multicast_loop_v6: bool) -> io::Result<()> {\n+        setsockopt(&self.inner, c::IPPROTO_IPV6, c::IPV6_MULTICAST_LOOP, multicast_loop_v6 as c_int)\n+    }\n+\n+    pub fn multicast_loop_v6(&self) -> io::Result<bool> {\n+        let raw: c_int = try!(getsockopt(&self.inner, c::IPPROTO_IPV6, c::IPV6_MULTICAST_LOOP));\n+        Ok(raw != 0)\n+    }\n+\n+    pub fn join_multicast_v4(&self, multiaddr: &Ipv4Addr, interface: &Ipv4Addr)\n+                         -> io::Result<()> {\n+        let mreq = c::ip_mreq {\n+            imr_multiaddr: *multiaddr.as_inner(),\n+            imr_interface: *interface.as_inner(),\n+        };\n+        setsockopt(&self.inner, c::IPPROTO_IP, c::IP_ADD_MEMBERSHIP, mreq)\n+    }\n+\n+    pub fn join_multicast_v6(&self, multiaddr: &Ipv6Addr, interface: u32)\n+                         -> io::Result<()> {\n+        let mreq = c::ipv6_mreq {\n+            ipv6mr_multiaddr: *multiaddr.as_inner(),\n+            ipv6mr_interface: to_ipv6mr_interface(interface),\n+        };\n+        setsockopt(&self.inner, c::IPPROTO_IPV6, IPV6_ADD_MEMBERSHIP, mreq)\n+    }\n+\n+    pub fn leave_multicast_v4(&self, multiaddr: &Ipv4Addr, interface: &Ipv4Addr)\n+                          -> io::Result<()> {\n+        let mreq = c::ip_mreq {\n+            imr_multiaddr: *multiaddr.as_inner(),\n+            imr_interface: *interface.as_inner(),\n+        };\n+        setsockopt(&self.inner, c::IPPROTO_IP, c::IP_DROP_MEMBERSHIP, mreq)\n+    }\n+\n+    pub fn leave_multicast_v6(&self, multiaddr: &Ipv6Addr, interface: u32)\n+                          -> io::Result<()> {\n+        let mreq = c::ipv6_mreq {\n+            ipv6mr_multiaddr: *multiaddr.as_inner(),\n+            ipv6mr_interface: to_ipv6mr_interface(interface),\n+        };\n+        setsockopt(&self.inner, c::IPPROTO_IPV6, IPV6_DROP_MEMBERSHIP, mreq)\n+    }\n+\n+    pub fn set_ttl(&self, ttl: u32) -> io::Result<()> {\n+        setsockopt(&self.inner, c::IPPROTO_IP, c::IP_TTL, ttl as c_int)\n+    }\n+\n+    pub fn ttl(&self) -> io::Result<u32> {\n+        let raw: c_int = try!(getsockopt(&self.inner, c::IPPROTO_IP, c::IP_TTL));\n+        Ok(raw as u32)\n+    }\n+\n+    pub fn set_only_v6(&self, only_v6: bool) -> io::Result<()> {\n+        setsockopt(&self.inner, c::IPPROTO_IPV6, c::IPV6_V6ONLY, only_v6 as c_int)\n+    }\n+\n+    pub fn only_v6(&self) -> io::Result<bool> {\n+        let raw: c_int = try!(getsockopt(&self.inner, c::IPPROTO_IPV6, c::IPV6_V6ONLY));\n+        Ok(raw != 0)\n+    }\n+\n+    pub fn take_error(&self) -> io::Result<Option<io::Error>> {\n+        let raw: c_int = try!(getsockopt(&self.inner, c::SOL_SOCKET, c::SO_ERROR));\n+        if raw == 0 {\n+            Ok(None)\n+        } else {\n+            Ok(Some(io::Error::from_raw_os_error(raw as i32)))\n+        }\n+    }\n+\n+    pub fn set_nonblocking(&self, nonblocking: bool) -> io::Result<()> {\n+        self.inner.set_nonblocking(nonblocking)\n+    }\n+\n+    pub fn recv(&self, buf: &mut [u8]) -> io::Result<usize> {\n+        self.inner.read(buf)\n+    }\n+\n+    pub fn send(&self, buf: &[u8]) -> io::Result<usize> {\n+        let len = cmp::min(buf.len(), <wrlen_t>::max_value() as usize) as wrlen_t;\n+        let ret = try!(cvt(unsafe {\n+            c::send(*self.inner.as_inner(),\n+                    buf.as_ptr() as *const c_void,\n+                    len,\n+                    0)\n+        }));\n+        Ok(ret as usize)\n+    }\n+\n+    pub fn connect(&self, addr: &SocketAddr) -> io::Result<()> {\n+        let (addrp, len) = addr.into_inner();\n+        cvt_r(|| unsafe { c::connect(*self.inner.as_inner(), addrp, len) }).map(|_| ())\n+    }\n }\n \n impl FromInner<Socket> for UdpSocket {"}, {"sha": "8785da51986dbe1192e3aa8046968c03ba093d80", "filename": "src/libstd/sys/unix/net.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8e261d12e3fcd6700b368d449ada4d10ebbf17f8/src%2Flibstd%2Fsys%2Funix%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e261d12e3fcd6700b368d449ada4d10ebbf17f8/src%2Flibstd%2Fsys%2Funix%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fnet.rs?ref=8e261d12e3fcd6700b368d449ada4d10ebbf17f8", "patch": "@@ -168,6 +168,20 @@ impl Socket {\n         try!(cvt(unsafe { libc::shutdown(self.0.raw(), how) }));\n         Ok(())\n     }\n+\n+    pub fn set_nodelay(&self, nodelay: bool) -> io::Result<()> {\n+        setsockopt(self, libc::IPPROTO_TCP, libc::TCP_NODELAY, nodelay as c_int)\n+    }\n+\n+    pub fn nodelay(&self) -> io::Result<bool> {\n+        let raw: c_int = try!(getsockopt(self, libc::IPPROTO_TCP, libc::TCP_NODELAY));\n+        Ok(raw != 0)\n+    }\n+\n+    pub fn set_nonblocking(&self, nonblocking: bool) -> io::Result<()> {\n+        let mut nonblocking = nonblocking as libc::c_ulong;\n+        cvt(unsafe { libc::ioctl(*self.as_inner(), libc::FIONBIO, &mut nonblocking) }).map(|_| ())\n+    }\n }\n \n impl AsInner<c_int> for Socket {"}, {"sha": "472ffdf9e1d93d20a95e942951843bafcc4013bb", "filename": "src/libstd/sys/windows/c.rs", "status": "modified", "additions": 31, "deletions": 1, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/8e261d12e3fcd6700b368d449ada4d10ebbf17f8/src%2Flibstd%2Fsys%2Fwindows%2Fc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e261d12e3fcd6700b368d449ada4d10ebbf17f8/src%2Flibstd%2Fsys%2Fwindows%2Fc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fc.rs?ref=8e261d12e3fcd6700b368d449ada4d10ebbf17f8", "patch": "@@ -13,7 +13,7 @@\n #![allow(bad_style)]\n #![cfg_attr(test, allow(dead_code))]\n \n-use os::raw::{c_int, c_uint, c_ulong, c_long, c_longlong, c_ushort};\n+use os::raw::{c_int, c_uint, c_ulong, c_long, c_longlong, c_ushort,};\n use os::raw::{c_char, c_ulonglong};\n use libc::{wchar_t, size_t, c_void};\n use ptr;\n@@ -114,6 +114,8 @@ pub const FILE_FLAG_OPEN_REPARSE_POINT: DWORD = 0x00200000;\n pub const FILE_FLAG_BACKUP_SEMANTICS: DWORD = 0x02000000;\n pub const SECURITY_SQOS_PRESENT: DWORD = 0x00100000;\n \n+pub const FIONBIO: c_ulong = 0x8004667e;\n+\n #[repr(C)]\n #[derive(Copy)]\n pub struct WIN32_FIND_DATAW {\n@@ -223,6 +225,33 @@ pub const SOL_SOCKET: c_int = 0xffff;\n pub const SO_RCVTIMEO: c_int = 0x1006;\n pub const SO_SNDTIMEO: c_int = 0x1005;\n pub const SO_REUSEADDR: c_int = 0x0004;\n+pub const IPPROTO_IP: c_int = 0;\n+pub const IPPROTO_TCP: c_int = 6;\n+pub const IPPROTO_IPV6: c_int = 41;\n+pub const TCP_NODELAY: c_int = 0x0001;\n+pub const IP_TTL: c_int = 4;\n+pub const IPV6_V6ONLY: c_int = 27;\n+pub const SO_ERROR: c_int = 0x1007;\n+pub const SO_BROADCAST: c_int = 0x0020;\n+pub const IP_MULTICAST_LOOP: c_int = 11;\n+pub const IPV6_MULTICAST_LOOP: c_int = 11;\n+pub const IP_MULTICAST_TTL: c_int = 10;\n+pub const IP_ADD_MEMBERSHIP: c_int = 12;\n+pub const IP_DROP_MEMBERSHIP: c_int = 13;\n+pub const IPV6_ADD_MEMBERSHIP: c_int = 12;\n+pub const IPV6_DROP_MEMBERSHIP: c_int = 13;\n+\n+#[repr(C)]\n+pub struct ip_mreq {\n+    pub imr_multiaddr: in_addr,\n+    pub imr_interface: in_addr,\n+}\n+\n+#[repr(C)]\n+pub struct ipv6_mreq {\n+    pub ipv6mr_multiaddr: in6_addr,\n+    pub ipv6mr_interface: c_uint,\n+}\n \n pub const VOLUME_NAME_DOS: DWORD = 0x0;\n pub const MOVEFILE_REPLACE_EXISTING: DWORD = 1;\n@@ -833,6 +862,7 @@ extern \"system\" {\n                       lpProtocolInfo: LPWSAPROTOCOL_INFO,\n                       g: GROUP,\n                       dwFlags: DWORD) -> SOCKET;\n+    pub fn ioctlsocket(s: SOCKET, cmd: c_long, argp: *mut c_ulong) -> c_int;\n     pub fn InitializeCriticalSection(CriticalSection: *mut CRITICAL_SECTION);\n     pub fn EnterCriticalSection(CriticalSection: *mut CRITICAL_SECTION);\n     pub fn TryEnterCriticalSection(CriticalSection: *mut CRITICAL_SECTION) -> BOOLEAN;"}, {"sha": "dfa44a651e61ccabea96f1101c3897c3f4a7e96d", "filename": "src/libstd/sys/windows/net.rs", "status": "modified", "additions": 20, "deletions": 1, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/8e261d12e3fcd6700b368d449ada4d10ebbf17f8/src%2Flibstd%2Fsys%2Fwindows%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e261d12e3fcd6700b368d449ada4d10ebbf17f8/src%2Flibstd%2Fsys%2Fwindows%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fnet.rs?ref=8e261d12e3fcd6700b368d449ada4d10ebbf17f8", "patch": "@@ -10,7 +10,7 @@\n \n use cmp;\n use io;\n-use libc::{c_int, c_void};\n+use libc::{c_int, c_void, c_ulong};\n use mem;\n use net::{SocketAddr, Shutdown};\n use num::One;\n@@ -185,6 +185,25 @@ impl Socket {\n         try!(cvt(unsafe { c::shutdown(self.0, how) }));\n         Ok(())\n     }\n+\n+    pub fn set_nonblocking(&self, nonblocking: bool) -> io::Result<()> {\n+        let mut nonblocking = nonblocking as c_ulong;\n+        let r = unsafe { c::ioctlsocket(self.0, c::FIONBIO as c_int, &mut nonblocking) };\n+        if r == 0 {\n+            Ok(())\n+        } else {\n+            Err(io::Error::last_os_error())\n+        }\n+    }\n+\n+    pub fn set_nodelay(&self, nodelay: bool) -> io::Result<()> {\n+        net::setsockopt(self, c::IPPROTO_TCP, c::TCP_NODELAY, nodelay as c::BYTE)\n+    }\n+\n+    pub fn nodelay(&self) -> io::Result<bool> {\n+        let raw: c::BYTE = try!(net::getsockopt(self, c::IPPROTO_TCP, c::TCP_NODELAY));\n+        Ok(raw != 0)\n+    }\n }\n \n impl Drop for Socket {"}]}