{"sha": "6aad3bf944da209d1852c51144ba584de400a10c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZhYWQzYmY5NDRkYTIwOWQxODUyYzUxMTQ0YmE1ODRkZTQwMGExMGM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-02-05T20:56:34Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-02-05T20:56:34Z"}, "message": "auto merge of #11894 : alexcrichton/rust/io-clone, r=brson\n\nThis is part of the overall strategy I would like to take when approaching\r\nissue #11165. The only two I/O objects that reasonably want to be \"split\" are\r\nthe network stream objects. Everything else can be \"split\" by just creating\r\nanother version.\r\n\r\nThe initial idea I had was the literally split the object into a reader and a\r\nwriter half, but that would just introduce lots of clutter with extra interfaces\r\nthat were a little unnnecssary, or it would return a ~Reader and a ~Writer which\r\nmeans you couldn't access things like the remote peer name or local socket name.\r\n\r\nThe solution I found to be nicer was to just clone the stream itself. The clone\r\nis just a clone of the handle, nothing fancy going on at the kernel level.\r\nConceptually I found this very easy to wrap my head around (everything else\r\nsupports clone()), and it solved the \"split\" problem at the same time.\r\n\r\nThe cloning support is pretty specific per platform/lib combination:\r\n\r\n* native/win32 - uses some specific WSA apis to clone the SOCKET handle\r\n* native/unix - uses dup() to get another file descriptor\r\n* green/all - This is where things get interesting. When we support full clones\r\n              of a handle, this implies that we're allowing simultaneous writes\r\n              and reads to happen. It turns out that libuv doesn't support two\r\n              simultaneous reads or writes of the same object. It does support\r\n              *one* read and *one* write at the same time, however. Some extra\r\n              infrastructure was added to just block concurrent writers/readers\r\n              until the previous read/write operation was completed.\r\n\r\nI've added tests to the tcp/unix modules to make sure that this functionality is\r\nsupported everywhere.", "tree": {"sha": "e1ecbc062f03006192f35d084ed0ab996ad3ff20", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e1ecbc062f03006192f35d084ed0ab996ad3ff20"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6aad3bf944da209d1852c51144ba584de400a10c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6aad3bf944da209d1852c51144ba584de400a10c", "html_url": "https://github.com/rust-lang/rust/commit/6aad3bf944da209d1852c51144ba584de400a10c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6aad3bf944da209d1852c51144ba584de400a10c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "55684ba13fb97b8658108fd18baecc3c4c51beb0", "url": "https://api.github.com/repos/rust-lang/rust/commits/55684ba13fb97b8658108fd18baecc3c4c51beb0", "html_url": "https://github.com/rust-lang/rust/commit/55684ba13fb97b8658108fd18baecc3c4c51beb0"}, {"sha": "56080c476712e478ffe4ef8d6d727c0e3d21cfd0", "url": "https://api.github.com/repos/rust-lang/rust/commits/56080c476712e478ffe4ef8d6d727c0e3d21cfd0", "html_url": "https://github.com/rust-lang/rust/commit/56080c476712e478ffe4ef8d6d727c0e3d21cfd0"}], "stats": {"total": 894, "additions": 812, "deletions": 82}, "files": [{"sha": "25fb2809e764a63658d16743dfa06b9b6a58edb3", "filename": "src/libnative/io/file.rs", "status": "modified", "additions": 31, "deletions": 16, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/6aad3bf944da209d1852c51144ba584de400a10c/src%2Flibnative%2Fio%2Ffile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6aad3bf944da209d1852c51144ba584de400a10c/src%2Flibnative%2Fio%2Ffile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Ffile.rs?ref=6aad3bf944da209d1852c51144ba584de400a10c", "patch": "@@ -10,6 +10,7 @@\n \n //! Blocking posix-based file I/O\n \n+use std::sync::arc::UnsafeArc;\n use std::c_str::CString;\n use std::io::IoError;\n use std::io;\n@@ -55,9 +56,13 @@ pub fn keep_going(data: &[u8], f: |*u8, uint| -> i64) -> i64 {\n \n pub type fd_t = libc::c_int;\n \n+struct Inner {\n+    fd: fd_t,\n+    close_on_drop: bool,\n+}\n+\n pub struct FileDesc {\n-    priv fd: fd_t,\n-    priv close_on_drop: bool,\n+    priv inner: UnsafeArc<Inner>\n }\n \n impl FileDesc {\n@@ -70,7 +75,10 @@ impl FileDesc {\n     /// Note that all I/O operations done on this object will be *blocking*, but\n     /// they do not require the runtime to be active.\n     pub fn new(fd: fd_t, close_on_drop: bool) -> FileDesc {\n-        FileDesc { fd: fd, close_on_drop: close_on_drop }\n+        FileDesc { inner: UnsafeArc::new(Inner {\n+            fd: fd,\n+            close_on_drop: close_on_drop\n+        }) }\n     }\n \n     // FIXME(#10465) these functions should not be public, but anything in\n@@ -80,7 +88,7 @@ impl FileDesc {\n         #[cfg(windows)] type rlen = libc::c_uint;\n         #[cfg(not(windows))] type rlen = libc::size_t;\n         let ret = retry(|| unsafe {\n-            libc::read(self.fd,\n+            libc::read(self.fd(),\n                        buf.as_ptr() as *mut libc::c_void,\n                        buf.len() as rlen) as libc::c_int\n         });\n@@ -97,7 +105,7 @@ impl FileDesc {\n         #[cfg(not(windows))] type wlen = libc::size_t;\n         let ret = keep_going(buf, |buf, len| {\n             unsafe {\n-                libc::write(self.fd, buf as *libc::c_void, len as wlen) as i64\n+                libc::write(self.fd(), buf as *libc::c_void, len as wlen) as i64\n             }\n         });\n         if ret < 0 {\n@@ -107,7 +115,11 @@ impl FileDesc {\n         }\n     }\n \n-    pub fn fd(&self) -> fd_t { self.fd }\n+    pub fn fd(&self) -> fd_t {\n+        // This unsafety is fine because we're just reading off the file\n+        // descriptor, no one is modifying this.\n+        unsafe { (*self.inner.get()).fd }\n+    }\n }\n \n impl io::Reader for FileDesc {\n@@ -130,7 +142,7 @@ impl rtio::RtioFileStream for FileDesc {\n         self.inner_write(buf)\n     }\n     fn pread(&mut self, buf: &mut [u8], offset: u64) -> Result<int, IoError> {\n-        return os_pread(self.fd, buf.as_ptr(), buf.len(), offset);\n+        return os_pread(self.fd(), buf.as_ptr(), buf.len(), offset);\n \n         #[cfg(windows)]\n         fn os_pread(fd: c_int, buf: *u8, amt: uint, offset: u64) -> IoResult<int> {\n@@ -162,7 +174,7 @@ impl rtio::RtioFileStream for FileDesc {\n         }\n     }\n     fn pwrite(&mut self, buf: &[u8], offset: u64) -> Result<(), IoError> {\n-        return os_pwrite(self.fd, buf.as_ptr(), buf.len(), offset);\n+        return os_pwrite(self.fd(), buf.as_ptr(), buf.len(), offset);\n \n         #[cfg(windows)]\n         fn os_pwrite(fd: c_int, buf: *u8, amt: uint, offset: u64) -> IoResult<()> {\n@@ -197,7 +209,7 @@ impl rtio::RtioFileStream for FileDesc {\n             io::SeekCur => libc::FILE_CURRENT,\n         };\n         unsafe {\n-            let handle = libc::get_osfhandle(self.fd) as libc::HANDLE;\n+            let handle = libc::get_osfhandle(self.fd()) as libc::HANDLE;\n             let mut newpos = 0;\n             match libc::SetFilePointerEx(handle, pos, &mut newpos, whence) {\n                 0 => Err(super::last_error()),\n@@ -212,23 +224,23 @@ impl rtio::RtioFileStream for FileDesc {\n             io::SeekEnd => libc::SEEK_END,\n             io::SeekCur => libc::SEEK_CUR,\n         };\n-        let n = unsafe { libc::lseek(self.fd, pos as libc::off_t, whence) };\n+        let n = unsafe { libc::lseek(self.fd(), pos as libc::off_t, whence) };\n         if n < 0 {\n             Err(super::last_error())\n         } else {\n             Ok(n as u64)\n         }\n     }\n     fn tell(&self) -> Result<u64, IoError> {\n-        let n = unsafe { libc::lseek(self.fd, 0, libc::SEEK_CUR) };\n+        let n = unsafe { libc::lseek(self.fd(), 0, libc::SEEK_CUR) };\n         if n < 0 {\n             Err(super::last_error())\n         } else {\n             Ok(n as u64)\n         }\n     }\n     fn fsync(&mut self) -> Result<(), IoError> {\n-        return os_fsync(self.fd);\n+        return os_fsync(self.fd());\n \n         #[cfg(windows)]\n         fn os_fsync(fd: c_int) -> IoResult<()> {\n@@ -247,7 +259,7 @@ impl rtio::RtioFileStream for FileDesc {\n \n     #[cfg(not(windows))]\n     fn datasync(&mut self) -> Result<(), IoError> {\n-        return super::mkerr_libc(os_datasync(self.fd));\n+        return super::mkerr_libc(os_datasync(self.fd()));\n \n         #[cfg(target_os = \"macos\")]\n         fn os_datasync(fd: c_int) -> c_int {\n@@ -270,7 +282,7 @@ impl rtio::RtioFileStream for FileDesc {\n             Ok(_) => {}, Err(e) => return Err(e),\n         };\n         let ret = unsafe {\n-            let handle = libc::get_osfhandle(self.fd) as libc::HANDLE;\n+            let handle = libc::get_osfhandle(self.fd()) as libc::HANDLE;\n             match libc::SetEndOfFile(handle) {\n                 0 => Err(super::last_error()),\n                 _ => Ok(())\n@@ -282,7 +294,7 @@ impl rtio::RtioFileStream for FileDesc {\n     #[cfg(unix)]\n     fn truncate(&mut self, offset: i64) -> Result<(), IoError> {\n         super::mkerr_libc(retry(|| unsafe {\n-            libc::ftruncate(self.fd, offset as libc::off_t)\n+            libc::ftruncate(self.fd(), offset as libc::off_t)\n         }))\n     }\n }\n@@ -294,6 +306,9 @@ impl rtio::RtioPipe for FileDesc {\n     fn write(&mut self, buf: &[u8]) -> Result<(), IoError> {\n         self.inner_write(buf)\n     }\n+    fn clone(&self) -> ~rtio::RtioPipe {\n+        ~FileDesc { inner: self.inner.clone() } as ~rtio::RtioPipe\n+    }\n }\n \n impl rtio::RtioTTY for FileDesc {\n@@ -312,7 +327,7 @@ impl rtio::RtioTTY for FileDesc {\n     fn isatty(&self) -> bool { false }\n }\n \n-impl Drop for FileDesc {\n+impl Drop for Inner {\n     fn drop(&mut self) {\n         // closing stdio file handles makes no sense, so never do it. Also, note\n         // that errors are ignored when closing a file descriptor. The reason"}, {"sha": "32cd6337f993d312dcded17d2e34d289f9cfbdbc", "filename": "src/libnative/io/net.rs", "status": "modified", "additions": 82, "deletions": 48, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/6aad3bf944da209d1852c51144ba584de400a10c/src%2Flibnative%2Fio%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6aad3bf944da209d1852c51144ba584de400a10c/src%2Flibnative%2Fio%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fnet.rs?ref=6aad3bf944da209d1852c51144ba584de400a10c", "patch": "@@ -14,6 +14,7 @@ use std::io;\n use std::libc;\n use std::mem;\n use std::rt::rtio;\n+use std::sync::arc::UnsafeArc;\n use std::unstable::intrinsics;\n \n use super::{IoResult, retry};\n@@ -108,10 +109,27 @@ fn setsockopt<T>(fd: sock_t, opt: libc::c_int, val: libc::c_int,\n         let ret = libc::setsockopt(fd, opt, val,\n                                    payload,\n                                    mem::size_of::<T>() as libc::socklen_t);\n-        super::mkerr_libc(ret)\n+        if ret != 0 {\n+            Err(last_error())\n+        } else {\n+            Ok(())\n+        }\n     }\n }\n \n+#[cfg(windows)]\n+fn last_error() -> io::IoError {\n+    extern \"system\" {\n+        fn WSAGetLastError() -> libc::c_int;\n+    }\n+    super::translate_error(unsafe { WSAGetLastError() }, true)\n+}\n+\n+#[cfg(not(windows))]\n+fn last_error() -> io::IoError {\n+    super::last_error()\n+}\n+\n #[cfg(windows)] unsafe fn close(sock: sock_t) { let _ = libc::closesocket(sock); }\n #[cfg(unix)]    unsafe fn close(sock: sock_t) { let _ = libc::close(sock); }\n \n@@ -128,7 +146,7 @@ fn sockname(fd: sock_t,\n                     storage as *mut libc::sockaddr,\n                     &mut len as *mut libc::socklen_t);\n         if ret != 0 {\n-            return Err(super::last_error())\n+            return Err(last_error())\n         }\n     }\n     return sockaddr_to_addr(&storage, len as uint);\n@@ -222,7 +240,11 @@ pub fn init() {\n ////////////////////////////////////////////////////////////////////////////////\n \n pub struct TcpStream {\n-    priv fd: sock_t,\n+    priv inner: UnsafeArc<Inner>,\n+}\n+\n+struct Inner {\n+    fd: sock_t,\n }\n \n impl TcpStream {\n@@ -231,27 +253,31 @@ impl TcpStream {\n             socket(addr, libc::SOCK_STREAM).and_then(|fd| {\n                 let (addr, len) = addr_to_sockaddr(addr);\n                 let addrp = &addr as *libc::sockaddr_storage;\n-                let ret = TcpStream { fd: fd };\n+                let inner = Inner { fd: fd };\n+                let ret = TcpStream { inner: UnsafeArc::new(inner) };\n                 match retry(|| {\n                     libc::connect(fd, addrp as *libc::sockaddr,\n                                   len as libc::socklen_t)\n                 }) {\n-                    -1 => Err(super::last_error()),\n+                    -1 => Err(last_error()),\n                     _ => Ok(ret),\n                 }\n             })\n         }\n     }\n \n-    pub fn fd(&self) -> sock_t { self.fd }\n+    pub fn fd(&self) -> sock_t {\n+        // This unsafety is fine because it's just a read-only arc\n+        unsafe { (*self.inner.get()).fd }\n+    }\n \n     fn set_nodelay(&mut self, nodelay: bool) -> IoResult<()> {\n-        setsockopt(self.fd, libc::IPPROTO_TCP, libc::TCP_NODELAY,\n+        setsockopt(self.fd(), libc::IPPROTO_TCP, libc::TCP_NODELAY,\n                    nodelay as libc::c_int)\n     }\n \n     fn set_keepalive(&mut self, seconds: Option<uint>) -> IoResult<()> {\n-        let ret = setsockopt(self.fd, libc::SOL_SOCKET, libc::SO_KEEPALIVE,\n+        let ret = setsockopt(self.fd(), libc::SOL_SOCKET, libc::SO_KEEPALIVE,\n                              seconds.is_some() as libc::c_int);\n         match seconds {\n             Some(n) => ret.and_then(|()| self.set_tcp_keepalive(n)),\n@@ -261,12 +287,12 @@ impl TcpStream {\n \n     #[cfg(target_os = \"macos\")]\n     fn set_tcp_keepalive(&mut self, seconds: uint) -> IoResult<()> {\n-        setsockopt(self.fd, libc::IPPROTO_TCP, libc::TCP_KEEPALIVE,\n+        setsockopt(self.fd(), libc::IPPROTO_TCP, libc::TCP_KEEPALIVE,\n                    seconds as libc::c_int)\n     }\n     #[cfg(target_os = \"freebsd\")]\n     fn set_tcp_keepalive(&mut self, seconds: uint) -> IoResult<()> {\n-        setsockopt(self.fd, libc::IPPROTO_TCP, libc::TCP_KEEPIDLE,\n+        setsockopt(self.fd(), libc::IPPROTO_TCP, libc::TCP_KEEPIDLE,\n                    seconds as libc::c_int)\n     }\n     #[cfg(not(target_os = \"macos\"), not(target_os = \"freebsd\"))]\n@@ -282,7 +308,7 @@ impl rtio::RtioTcpStream for TcpStream {\n     fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> {\n         let ret = retry(|| {\n             unsafe {\n-                libc::recv(self.fd,\n+                libc::recv(self.fd(),\n                            buf.as_ptr() as *mut libc::c_void,\n                            buf.len() as wrlen,\n                            0) as libc::c_int\n@@ -291,28 +317,28 @@ impl rtio::RtioTcpStream for TcpStream {\n         if ret == 0 {\n             Err(io::standard_error(io::EndOfFile))\n         } else if ret < 0 {\n-            Err(super::last_error())\n+            Err(last_error())\n         } else {\n             Ok(ret as uint)\n         }\n     }\n     fn write(&mut self, buf: &[u8]) -> IoResult<()> {\n         let ret = keep_going(buf, |buf, len| {\n             unsafe {\n-                libc::send(self.fd,\n+                libc::send(self.fd(),\n                            buf as *mut libc::c_void,\n                            len as wrlen,\n                            0) as i64\n             }\n         });\n         if ret < 0 {\n-            Err(super::last_error())\n+            Err(last_error())\n         } else {\n             Ok(())\n         }\n     }\n     fn peer_name(&mut self) -> IoResult<ip::SocketAddr> {\n-        sockname(self.fd, libc::getpeername)\n+        sockname(self.fd(), libc::getpeername)\n     }\n     fn control_congestion(&mut self) -> IoResult<()> {\n         self.set_nodelay(false)\n@@ -326,15 +352,19 @@ impl rtio::RtioTcpStream for TcpStream {\n     fn letdie(&mut self) -> IoResult<()> {\n         self.set_keepalive(None)\n     }\n+\n+    fn clone(&self) -> ~rtio::RtioTcpStream {\n+        ~TcpStream { inner: self.inner.clone() } as ~rtio::RtioTcpStream\n+    }\n }\n \n impl rtio::RtioSocket for TcpStream {\n     fn socket_name(&mut self) -> IoResult<ip::SocketAddr> {\n-        sockname(self.fd, libc::getsockname)\n+        sockname(self.fd(), libc::getsockname)\n     }\n }\n \n-impl Drop for TcpStream {\n+impl Drop for Inner {\n     fn drop(&mut self) { unsafe { close(self.fd); } }\n }\n \n@@ -343,7 +373,7 @@ impl Drop for TcpStream {\n ////////////////////////////////////////////////////////////////////////////////\n \n pub struct TcpListener {\n-    priv fd: sock_t,\n+    priv inner: UnsafeArc<Inner>,\n }\n \n impl TcpListener {\n@@ -352,7 +382,8 @@ impl TcpListener {\n             socket(addr, libc::SOCK_STREAM).and_then(|fd| {\n                 let (addr, len) = addr_to_sockaddr(addr);\n                 let addrp = &addr as *libc::sockaddr_storage;\n-                let ret = TcpListener { fd: fd };\n+                let inner = Inner { fd: fd };\n+                let ret = TcpListener { inner: UnsafeArc::new(inner) };\n                 // On platforms with Berkeley-derived sockets, this allows\n                 // to quickly rebind a socket, without needing to wait for\n                 // the OS to clean up the previous one.\n@@ -366,18 +397,21 @@ impl TcpListener {\n                 }\n                 match libc::bind(fd, addrp as *libc::sockaddr,\n                                  len as libc::socklen_t) {\n-                    -1 => Err(super::last_error()),\n+                    -1 => Err(last_error()),\n                     _ => Ok(ret),\n                 }\n             })\n         }\n     }\n \n-    pub fn fd(&self) -> sock_t { self.fd }\n+    pub fn fd(&self) -> sock_t {\n+        // This is just a read-only arc so the unsafety is fine\n+        unsafe { (*self.inner.get()).fd }\n+    }\n \n     pub fn native_listen(self, backlog: int) -> IoResult<TcpAcceptor> {\n-        match unsafe { libc::listen(self.fd, backlog as libc::c_int) } {\n-            -1 => Err(super::last_error()),\n+        match unsafe { libc::listen(self.fd(), backlog as libc::c_int) } {\n+            -1 => Err(last_error()),\n             _ => Ok(TcpAcceptor { listener: self })\n         }\n     }\n@@ -391,20 +425,16 @@ impl rtio::RtioTcpListener for TcpListener {\n \n impl rtio::RtioSocket for TcpListener {\n     fn socket_name(&mut self) -> IoResult<ip::SocketAddr> {\n-        sockname(self.fd, libc::getsockname)\n+        sockname(self.fd(), libc::getsockname)\n     }\n }\n \n-impl Drop for TcpListener {\n-    fn drop(&mut self) { unsafe { close(self.fd); } }\n-}\n-\n pub struct TcpAcceptor {\n     priv listener: TcpListener,\n }\n \n impl TcpAcceptor {\n-    pub fn fd(&self) -> sock_t { self.listener.fd }\n+    pub fn fd(&self) -> sock_t { self.listener.fd() }\n \n     pub fn native_accept(&mut self) -> IoResult<TcpStream> {\n         unsafe {\n@@ -417,8 +447,8 @@ impl TcpAcceptor {\n                              storagep as *mut libc::sockaddr,\n                              &mut size as *mut libc::socklen_t) as libc::c_int\n             }) as sock_t {\n-                -1 => Err(super::last_error()),\n-                fd => Ok(TcpStream { fd: fd })\n+                -1 => Err(last_error()),\n+                fd => Ok(TcpStream { inner: UnsafeArc::new(Inner { fd: fd })})\n             }\n         }\n     }\n@@ -444,7 +474,7 @@ impl rtio::RtioTcpAcceptor for TcpAcceptor {\n ////////////////////////////////////////////////////////////////////////////////\n \n pub struct UdpSocket {\n-    priv fd: sock_t,\n+    priv inner: UnsafeArc<Inner>,\n }\n \n impl UdpSocket {\n@@ -453,25 +483,29 @@ impl UdpSocket {\n             socket(addr, libc::SOCK_DGRAM).and_then(|fd| {\n                 let (addr, len) = addr_to_sockaddr(addr);\n                 let addrp = &addr as *libc::sockaddr_storage;\n-                let ret = UdpSocket { fd: fd };\n+                let inner = Inner { fd: fd };\n+                let ret = UdpSocket { inner: UnsafeArc::new(inner) };\n                 match libc::bind(fd, addrp as *libc::sockaddr,\n                                  len as libc::socklen_t) {\n-                    -1 => Err(super::last_error()),\n+                    -1 => Err(last_error()),\n                     _ => Ok(ret),\n                 }\n             })\n         }\n     }\n \n-    pub fn fd(&self) -> sock_t { self.fd }\n+    pub fn fd(&self) -> sock_t {\n+        // unsafety is fine because it's just a read-only arc\n+        unsafe { (*self.inner.get()).fd }\n+    }\n \n     pub fn set_broadcast(&mut self, on: bool) -> IoResult<()> {\n-        setsockopt(self.fd, libc::SOL_SOCKET, libc::SO_BROADCAST,\n+        setsockopt(self.fd(), libc::SOL_SOCKET, libc::SO_BROADCAST,\n                    on as libc::c_int)\n     }\n \n     pub fn set_multicast_loop(&mut self, on: bool) -> IoResult<()> {\n-        setsockopt(self.fd, libc::IPPROTO_IP, libc::IP_MULTICAST_LOOP,\n+        setsockopt(self.fd(), libc::IPPROTO_IP, libc::IP_MULTICAST_LOOP,\n                    on as libc::c_int)\n     }\n \n@@ -484,14 +518,14 @@ impl UdpSocket {\n                     // interface == INADDR_ANY\n                     imr_interface: libc::in_addr { s_addr: 0x0 },\n                 };\n-                setsockopt(self.fd, libc::IPPROTO_IP, opt, mreq)\n+                setsockopt(self.fd(), libc::IPPROTO_IP, opt, mreq)\n             }\n             In6Addr(addr) => {\n                 let mreq = libc::ip6_mreq {\n                     ipv6mr_multiaddr: addr,\n                     ipv6mr_interface: 0,\n                 };\n-                setsockopt(self.fd, libc::IPPROTO_IPV6, opt, mreq)\n+                setsockopt(self.fd(), libc::IPPROTO_IPV6, opt, mreq)\n             }\n         }\n     }\n@@ -514,14 +548,14 @@ impl rtio::RtioUdpSocket for UdpSocket {\n             let mut addrlen: libc::socklen_t =\n                     mem::size_of::<libc::sockaddr_storage>() as libc::socklen_t;\n             let ret = retry(|| {\n-                libc::recvfrom(self.fd,\n+                libc::recvfrom(self.fd(),\n                                buf.as_ptr() as *mut libc::c_void,\n                                buf.len() as msglen_t,\n                                0,\n                                storagep as *mut libc::sockaddr,\n                                &mut addrlen) as libc::c_int\n             });\n-            if ret < 0 { return Err(super::last_error()) }\n+            if ret < 0 { return Err(last_error()) }\n             sockaddr_to_addr(&storage, addrlen as uint).and_then(|addr| {\n                 Ok((ret as uint, addr))\n             })\n@@ -532,15 +566,15 @@ impl rtio::RtioUdpSocket for UdpSocket {\n         let dstp = &dst as *libc::sockaddr_storage;\n         unsafe {\n             let ret = retry(|| {\n-                libc::sendto(self.fd,\n+                libc::sendto(self.fd(),\n                              buf.as_ptr() as *libc::c_void,\n                              buf.len() as msglen_t,\n                              0,\n                              dstp as *libc::sockaddr,\n                              len as libc::socklen_t) as libc::c_int\n             });\n             match ret {\n-                -1 => Err(super::last_error()),\n+                -1 => Err(last_error()),\n                 n if n as uint != buf.len() => {\n                     Err(io::IoError {\n                         kind: io::OtherIoError,\n@@ -582,11 +616,11 @@ impl rtio::RtioUdpSocket for UdpSocket {\n     }\n \n     fn multicast_time_to_live(&mut self, ttl: int) -> IoResult<()> {\n-        setsockopt(self.fd, libc::IPPROTO_IP, libc::IP_MULTICAST_TTL,\n+        setsockopt(self.fd(), libc::IPPROTO_IP, libc::IP_MULTICAST_TTL,\n                    ttl as libc::c_int)\n     }\n     fn time_to_live(&mut self, ttl: int) -> IoResult<()> {\n-        setsockopt(self.fd, libc::IPPROTO_IP, libc::IP_TTL, ttl as libc::c_int)\n+        setsockopt(self.fd(), libc::IPPROTO_IP, libc::IP_TTL, ttl as libc::c_int)\n     }\n \n     fn hear_broadcasts(&mut self) -> IoResult<()> {\n@@ -595,8 +629,8 @@ impl rtio::RtioUdpSocket for UdpSocket {\n     fn ignore_broadcasts(&mut self) -> IoResult<()> {\n         self.set_broadcast(false)\n     }\n-}\n \n-impl Drop for UdpSocket {\n-    fn drop(&mut self) { unsafe { close(self.fd) } }\n+    fn clone(&self) -> ~rtio::RtioUdpSocket {\n+        ~UdpSocket { inner: self.inner.clone() } as ~rtio::RtioUdpSocket\n+    }\n }"}, {"sha": "9d06593a6eafd323208074f770eef7eac55369f8", "filename": "src/librustuv/access.rs", "status": "added", "additions": 109, "deletions": 0, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/6aad3bf944da209d1852c51144ba584de400a10c/src%2Flibrustuv%2Faccess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6aad3bf944da209d1852c51144ba584de400a10c/src%2Flibrustuv%2Faccess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Faccess.rs?ref=6aad3bf944da209d1852c51144ba584de400a10c", "patch": "@@ -0,0 +1,109 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+/// An exclusive access primitive\n+///\n+/// This primitive is used to gain exclusive access to read() and write() in uv.\n+/// It is assumed that all invocations of this struct happen on the same thread\n+/// (the uv event loop).\n+\n+use std::cast;\n+use std::sync::arc::UnsafeArc;\n+use std::rt::task::{BlockedTask, Task};\n+use std::rt::local::Local;\n+\n+use homing::HomingMissile;\n+\n+pub struct Access {\n+    priv inner: UnsafeArc<Inner>,\n+}\n+\n+pub struct Guard<'a> {\n+    priv access: &'a mut Access,\n+    priv missile: Option<HomingMissile>,\n+}\n+\n+struct Inner {\n+    queue: ~[BlockedTask],\n+    held: bool,\n+}\n+\n+impl Access {\n+    pub fn new() -> Access {\n+        Access {\n+            inner: UnsafeArc::new(Inner {\n+                queue: ~[],\n+                held: false,\n+            })\n+        }\n+    }\n+\n+    pub fn grant<'a>(&'a mut self, missile: HomingMissile) -> Guard<'a> {\n+        // This unsafety is actually OK because the homing missile argument\n+        // guarantees that we're on the same event loop as all the other objects\n+        // attempting to get access granted.\n+        let inner: &mut Inner = unsafe { cast::transmute(self.inner.get()) };\n+\n+        if inner.held {\n+            let t: ~Task = Local::take();\n+            t.deschedule(1, |task| {\n+                inner.queue.push(task);\n+                Ok(())\n+            });\n+            assert!(inner.held);\n+        } else {\n+            inner.held = true;\n+        }\n+\n+        Guard { access: self, missile: Some(missile) }\n+    }\n+}\n+\n+impl Clone for Access {\n+    fn clone(&self) -> Access {\n+        Access { inner: self.inner.clone() }\n+    }\n+}\n+\n+#[unsafe_destructor]\n+impl<'a> Drop for Guard<'a> {\n+    fn drop(&mut self) {\n+        // This guard's homing missile is still armed, so we're guaranteed to be\n+        // on the same I/O event loop, so this unsafety should be ok.\n+        assert!(self.missile.is_some());\n+        let inner: &mut Inner = unsafe {\n+            cast::transmute(self.access.inner.get())\n+        };\n+\n+        match inner.queue.shift() {\n+            // Here we have found a task that was waiting for access, and we\n+            // current have the \"access lock\" we need to relinquish access to\n+            // this sleeping task.\n+            //\n+            // To do so, we first drop out homing missile and we then reawaken\n+            // the task. In reawakening the task, it will be immediately\n+            // scheduled on this scheduler. Because we might be woken up on some\n+            // other scheduler, we drop our homing missile before we reawaken\n+            // the task.\n+            Some(task) => {\n+                drop(self.missile.take());\n+                let _ = task.wake().map(|t| t.reawaken());\n+            }\n+            None => { inner.held = false; }\n+        }\n+    }\n+}\n+\n+impl Drop for Inner {\n+    fn drop(&mut self) {\n+        assert!(!self.held);\n+        assert_eq!(self.queue.len(), 0);\n+    }\n+}"}, {"sha": "25c929c995de7402a92e661cd7bfba821e4d6cde", "filename": "src/librustuv/homing.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6aad3bf944da209d1852c51144ba584de400a10c/src%2Flibrustuv%2Fhoming.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6aad3bf944da209d1852c51144ba584de400a10c/src%2Flibrustuv%2Fhoming.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fhoming.rs?ref=6aad3bf944da209d1852c51144ba584de400a10c", "patch": "@@ -125,8 +125,8 @@ pub trait HomingIO {\n /// After a homing operation has been completed, this will return the current\n /// task back to its appropriate home (if applicable). The field is used to\n /// assert that we are where we think we are.\n-struct HomingMissile {\n-    io_home: uint,\n+pub struct HomingMissile {\n+    priv io_home: uint,\n }\n \n impl HomingMissile {"}, {"sha": "b463bb7fd733db129ad429414e67b33bcdc9bb30", "filename": "src/librustuv/lib.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6aad3bf944da209d1852c51144ba584de400a10c/src%2Flibrustuv%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6aad3bf944da209d1852c51144ba584de400a10c/src%2Flibrustuv%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Flib.rs?ref=6aad3bf944da209d1852c51144ba584de400a10c", "patch": "@@ -68,8 +68,10 @@ pub use self::tty::TtyWatcher;\n \n mod macros;\n \n-mod queue;\n+mod access;\n mod homing;\n+mod queue;\n+mod rc;\n \n /// The implementation of `rtio` for libuv\n pub mod uvio;"}, {"sha": "7660d2c4f2b3ef5143c9cbaeaac7ca1252cedd9a", "filename": "src/librustuv/net.rs", "status": "modified", "additions": 56, "deletions": 6, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/6aad3bf944da209d1852c51144ba584de400a10c/src%2Flibrustuv%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6aad3bf944da209d1852c51144ba584de400a10c/src%2Flibrustuv%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fnet.rs?ref=6aad3bf944da209d1852c51144ba584de400a10c", "patch": "@@ -19,7 +19,9 @@ use std::rt::rtio;\n use std::rt::task::BlockedTask;\n use std::unstable::intrinsics;\n \n+use access::Access;\n use homing::{HomingIO, HomeHandle};\n+use rc::Refcount;\n use stream::StreamWatcher;\n use super::{Loop, Request, UvError, Buf, status_to_io_result,\n             uv_error_to_io_error, UvHandle, slice_to_uv_buf,\n@@ -152,6 +154,14 @@ pub struct TcpWatcher {\n     handle: *uvll::uv_tcp_t,\n     stream: StreamWatcher,\n     home: HomeHandle,\n+    priv refcount: Refcount,\n+\n+    // libuv can't support concurrent reads and concurrent writes of the same\n+    // stream object, so we use these access guards in order to arbitrate among\n+    // multiple concurrent reads and writes. Note that libuv *can* read and\n+    // write simultaneously, it just can't read and read simultaneously.\n+    priv read_access: Access,\n+    priv write_access: Access,\n }\n \n pub struct TcpListener {\n@@ -183,6 +193,9 @@ impl TcpWatcher {\n             home: home,\n             handle: handle,\n             stream: StreamWatcher::new(handle),\n+            refcount: Refcount::new(),\n+            read_access: Access::new(),\n+            write_access: Access::new(),\n         }\n     }\n \n@@ -238,12 +251,14 @@ impl rtio::RtioSocket for TcpWatcher {\n \n impl rtio::RtioTcpStream for TcpWatcher {\n     fn read(&mut self, buf: &mut [u8]) -> Result<uint, IoError> {\n-        let _m = self.fire_homing_missile();\n+        let m = self.fire_homing_missile();\n+        let _g = self.read_access.grant(m);\n         self.stream.read(buf).map_err(uv_error_to_io_error)\n     }\n \n     fn write(&mut self, buf: &[u8]) -> Result<(), IoError> {\n-        let _m = self.fire_homing_missile();\n+        let m = self.fire_homing_missile();\n+        let _g = self.write_access.grant(m);\n         self.stream.write(buf).map_err(uv_error_to_io_error)\n     }\n \n@@ -280,6 +295,17 @@ impl rtio::RtioTcpStream for TcpWatcher {\n             uvll::uv_tcp_keepalive(self.handle, 0 as c_int, 0 as c_uint)\n         })\n     }\n+\n+    fn clone(&self) -> ~rtio::RtioTcpStream {\n+        ~TcpWatcher {\n+            handle: self.handle,\n+            stream: StreamWatcher::new(self.handle),\n+            home: self.home.clone(),\n+            refcount: self.refcount.clone(),\n+            write_access: self.write_access.clone(),\n+            read_access: self.read_access.clone(),\n+        } as ~rtio::RtioTcpStream\n+    }\n }\n \n impl UvHandle<uvll::uv_tcp_t> for TcpWatcher {\n@@ -289,7 +315,9 @@ impl UvHandle<uvll::uv_tcp_t> for TcpWatcher {\n impl Drop for TcpWatcher {\n     fn drop(&mut self) {\n         let _m = self.fire_homing_missile();\n-        self.close();\n+        if self.refcount.decrement() {\n+            self.close();\n+        }\n     }\n }\n \n@@ -415,6 +443,11 @@ impl rtio::RtioTcpAcceptor for TcpAcceptor {\n pub struct UdpWatcher {\n     handle: *uvll::uv_udp_t,\n     home: HomeHandle,\n+\n+    // See above for what these fields are\n+    priv refcount: Refcount,\n+    priv read_access: Access,\n+    priv write_access: Access,\n }\n \n impl UdpWatcher {\n@@ -423,6 +456,9 @@ impl UdpWatcher {\n         let udp = UdpWatcher {\n             handle: unsafe { uvll::malloc_handle(uvll::UV_UDP) },\n             home: io.make_handle(),\n+            refcount: Refcount::new(),\n+            read_access: Access::new(),\n+            write_access: Access::new(),\n         };\n         assert_eq!(unsafe {\n             uvll::uv_udp_init(io.uv_loop(), udp.handle)\n@@ -463,7 +499,8 @@ impl rtio::RtioUdpSocket for UdpWatcher {\n             buf: Option<Buf>,\n             result: Option<(ssize_t, Option<ip::SocketAddr>)>,\n         }\n-        let _m = self.fire_homing_missile();\n+        let m = self.fire_homing_missile();\n+        let _g = self.read_access.grant(m);\n \n         let a = match unsafe {\n             uvll::uv_udp_recv_start(self.handle, alloc_cb, recv_cb)\n@@ -533,7 +570,8 @@ impl rtio::RtioUdpSocket for UdpWatcher {\n     fn sendto(&mut self, buf: &[u8], dst: ip::SocketAddr) -> Result<(), IoError> {\n         struct Ctx { task: Option<BlockedTask>, result: c_int }\n \n-        let _m = self.fire_homing_missile();\n+        let m = self.fire_homing_missile();\n+        let _g = self.write_access.grant(m);\n \n         let mut req = Request::new(uvll::UV_UDP_SEND);\n         let buf = slice_to_uv_buf(buf);\n@@ -636,13 +674,25 @@ impl rtio::RtioUdpSocket for UdpWatcher {\n                                        0 as c_int)\n         })\n     }\n+\n+    fn clone(&self) -> ~rtio::RtioUdpSocket {\n+        ~UdpWatcher {\n+            handle: self.handle,\n+            home: self.home.clone(),\n+            refcount: self.refcount.clone(),\n+            write_access: self.write_access.clone(),\n+            read_access: self.read_access.clone(),\n+        } as ~rtio::RtioUdpSocket\n+    }\n }\n \n impl Drop for UdpWatcher {\n     fn drop(&mut self) {\n         // Send ourselves home to close this handle (blocking while doing so).\n         let _m = self.fire_homing_missile();\n-        self.close();\n+        if self.refcount.decrement() {\n+            self.close();\n+        }\n     }\n }\n "}, {"sha": "c312f112d28b4caeb975d0fcd582ad32b48e8905", "filename": "src/librustuv/pipe.rs", "status": "modified", "additions": 27, "deletions": 4, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/6aad3bf944da209d1852c51144ba584de400a10c/src%2Flibrustuv%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6aad3bf944da209d1852c51144ba584de400a10c/src%2Flibrustuv%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fpipe.rs?ref=6aad3bf944da209d1852c51144ba584de400a10c", "patch": "@@ -14,7 +14,9 @@ use std::libc;\n use std::rt::rtio::{RtioPipe, RtioUnixListener, RtioUnixAcceptor};\n use std::rt::task::BlockedTask;\n \n+use access::Access;\n use homing::{HomingIO, HomeHandle};\n+use rc::Refcount;\n use stream::StreamWatcher;\n use super::{Loop, UvError, UvHandle, Request, uv_error_to_io_error,\n             wait_until_woken_after, wakeup};\n@@ -25,6 +27,11 @@ pub struct PipeWatcher {\n     stream: StreamWatcher,\n     home: HomeHandle,\n     priv defused: bool,\n+    priv refcount: Refcount,\n+\n+    // see comments in TcpWatcher for why these exist\n+    priv write_access: Access,\n+    priv read_access: Access,\n }\n \n pub struct PipeListener {\n@@ -61,6 +68,9 @@ impl PipeWatcher {\n             stream: StreamWatcher::new(handle),\n             home: home,\n             defused: false,\n+            refcount: Refcount::new(),\n+            read_access: Access::new(),\n+            write_access: Access::new(),\n         }\n     }\n \n@@ -118,14 +128,27 @@ impl PipeWatcher {\n \n impl RtioPipe for PipeWatcher {\n     fn read(&mut self, buf: &mut [u8]) -> Result<uint, IoError> {\n-        let _m = self.fire_homing_missile();\n+        let m = self.fire_homing_missile();\n+        let _g = self.read_access.grant(m);\n         self.stream.read(buf).map_err(uv_error_to_io_error)\n     }\n \n     fn write(&mut self, buf: &[u8]) -> Result<(), IoError> {\n-        let _m = self.fire_homing_missile();\n+        let m = self.fire_homing_missile();\n+        let _g = self.write_access.grant(m);\n         self.stream.write(buf).map_err(uv_error_to_io_error)\n     }\n+\n+    fn clone(&self) -> ~RtioPipe {\n+        ~PipeWatcher {\n+            stream: StreamWatcher::new(self.stream.handle),\n+            defused: false,\n+            home: self.home.clone(),\n+            refcount: self.refcount.clone(),\n+            read_access: self.read_access.clone(),\n+            write_access: self.write_access.clone(),\n+        } as ~RtioPipe\n+    }\n }\n \n impl HomingIO for PipeWatcher {\n@@ -138,8 +161,8 @@ impl UvHandle<uvll::uv_pipe_t> for PipeWatcher {\n \n impl Drop for PipeWatcher {\n     fn drop(&mut self) {\n-        if !self.defused {\n-            let _m = self.fire_homing_missile();\n+        let _m = self.fire_homing_missile();\n+        if !self.defused && self.refcount.decrement() {\n             self.close();\n         }\n     }"}, {"sha": "f43cf72236109a82072ef58c12ceba3943cd8d2a", "filename": "src/librustuv/rc.rs", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/6aad3bf944da209d1852c51144ba584de400a10c/src%2Flibrustuv%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6aad3bf944da209d1852c51144ba584de400a10c/src%2Flibrustuv%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Frc.rs?ref=6aad3bf944da209d1852c51144ba584de400a10c", "patch": "@@ -0,0 +1,49 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+/// Simple refcount structure for cloning handles\n+///\n+/// This is meant to be an unintrusive solution to cloning handles in rustuv.\n+/// The handles themselves shouldn't be sharing memory because there are bits of\n+/// state in the rust objects which shouldn't be shared across multiple users of\n+/// the same underlying uv object, hence Rc is not used and this simple counter\n+/// should suffice.\n+\n+use std::sync::arc::UnsafeArc;\n+\n+pub struct Refcount {\n+    priv rc: UnsafeArc<uint>,\n+}\n+\n+impl Refcount {\n+    /// Creates a new refcount of 1\n+    pub fn new() -> Refcount {\n+        Refcount { rc: UnsafeArc::new(1) }\n+    }\n+\n+    fn increment(&self) {\n+        unsafe { *self.rc.get() += 1; }\n+    }\n+\n+    /// Returns whether the refcount just hit 0 or not\n+    pub fn decrement(&self) -> bool {\n+        unsafe {\n+            *self.rc.get() -= 1;\n+            *self.rc.get() == 0\n+        }\n+    }\n+}\n+\n+impl Clone for Refcount {\n+    fn clone(&self) -> Refcount {\n+        self.increment();\n+        Refcount { rc: self.rc.clone() }\n+    }\n+}"}, {"sha": "66ceb03082f4bb04a0c878b918a5bd4a7327ad2e", "filename": "src/libstd/io/net/tcp.rs", "status": "modified", "additions": 180, "deletions": 1, "changes": 181, "blob_url": "https://github.com/rust-lang/rust/blob/6aad3bf944da209d1852c51144ba584de400a10c/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6aad3bf944da209d1852c51144ba584de400a10c/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs?ref=6aad3bf944da209d1852c51144ba584de400a10c", "patch": "@@ -8,11 +8,42 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+//! TCP network connections\n+//!\n+//! This module contains the ability to open a TCP stream to a socket address,\n+//! as well as creating a socket server to accept incoming connections. The\n+//! destination and binding addresses can either be an IPv4 or IPv6 address.\n+//!\n+//! A TCP connection implements the `Reader` and `Writer` traits, while the TCP\n+//! listener (socket server) implements the `Listener` and `Acceptor` traits.\n+\n+#[deny(missing_doc)];\n+\n+use clone::Clone;\n use io::net::ip::SocketAddr;\n-use io::{Reader, Writer, Listener, Acceptor, IoResult};\n+use io::{Reader, Writer, Listener, Acceptor};\n+use io::IoResult;\n use rt::rtio::{IoFactory, LocalIo, RtioSocket, RtioTcpListener};\n use rt::rtio::{RtioTcpAcceptor, RtioTcpStream};\n \n+/// A structure which represents a TCP stream between a local socket and a\n+/// remote socket.\n+///\n+/// # Example\n+///\n+/// ```rust\n+/// # #[allow(unused_must_use)];\n+/// use std::io::net::tcp::TcpStream;\n+/// use std::io::net::ip::{Ipv4Addr, SocketAddr};\n+///\n+/// let addr = SocketAddr { ip: Ipv4Addr(127, 0, 0, 1), port: 34254 };\n+/// let mut stream = TcpStream::connect(addr);\n+///\n+/// stream.write([1]);\n+/// let mut buf = [0];\n+/// stream.read(buf);\n+/// drop(stream); // close the connection\n+/// ```\n pub struct TcpStream {\n     priv obj: ~RtioTcpStream\n }\n@@ -22,21 +53,40 @@ impl TcpStream {\n         TcpStream { obj: s }\n     }\n \n+    /// Creates a TCP connection to a remote socket address.\n+    ///\n+    /// If no error is encountered, then `Ok(stream)` is returned.\n     pub fn connect(addr: SocketAddr) -> IoResult<TcpStream> {\n         LocalIo::maybe_raise(|io| {\n             io.tcp_connect(addr).map(TcpStream::new)\n         })\n     }\n \n+    /// Returns the socket address of the remote peer of this TCP connection.\n     pub fn peer_name(&mut self) -> IoResult<SocketAddr> {\n         self.obj.peer_name()\n     }\n \n+    /// Returns the socket address of the local half of this TCP connection.\n     pub fn socket_name(&mut self) -> IoResult<SocketAddr> {\n         self.obj.socket_name()\n     }\n }\n \n+impl Clone for TcpStream {\n+    /// Creates a new handle to this TCP stream, allowing for simultaneous reads\n+    /// and writes of this connection.\n+    ///\n+    /// The underlying TCP stream will not be closed until all handles to the\n+    /// stream have been deallocated. All handles will also follow the same\n+    /// stream, but two concurrent reads will not receive the same data.\n+    /// Instead, the first read will receive the first packet received, and the\n+    /// second read will receive the second packet.\n+    fn clone(&self) -> TcpStream {\n+        TcpStream { obj: self.obj.clone() }\n+    }\n+}\n+\n impl Reader for TcpStream {\n     fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> { self.obj.read(buf) }\n }\n@@ -45,17 +95,56 @@ impl Writer for TcpStream {\n     fn write(&mut self, buf: &[u8]) -> IoResult<()> { self.obj.write(buf) }\n }\n \n+/// A structure representing a socket server. This listener is used to create a\n+/// `TcpAcceptor` which can be used to accept sockets on a local port.\n+///\n+/// # Example\n+///\n+/// ```rust\n+/// # fn main() {}\n+/// # fn foo() {\n+/// # #[allow(unused_must_use, dead_code)];\n+/// use std::io::net::tcp::TcpListener;\n+/// use std::io::net::ip::{Ipv4Addr, SocketAddr};\n+/// use std::io::{Acceptor, Listener};\n+///\n+/// let addr = SocketAddr { ip: Ipv4Addr(127, 0, 0, 1), port: 80 };\n+/// let listener = TcpListener::bind(addr);\n+///\n+/// // bind the listener to the specified address\n+/// let mut acceptor = listener.listen();\n+///\n+/// // accept connections and process them\n+/// # fn handle_client<T>(_: T) {}\n+/// for stream in acceptor.incoming() {\n+///     spawn(proc() {\n+///         handle_client(stream);\n+///     });\n+/// }\n+///\n+/// // close the socket server\n+/// drop(acceptor);\n+/// # }\n+/// ```\n pub struct TcpListener {\n     priv obj: ~RtioTcpListener\n }\n \n impl TcpListener {\n+    /// Creates a new `TcpListener` which will be bound to the specified local\n+    /// socket address. This listener is not ready for accepting connections,\n+    /// `listen` must be called on it before that's possible.\n+    ///\n+    /// Binding with a port number of 0 will request that the OS assigns a port\n+    /// to this listener. The port allocated can be queried via the\n+    /// `socket_name` function.\n     pub fn bind(addr: SocketAddr) -> IoResult<TcpListener> {\n         LocalIo::maybe_raise(|io| {\n             io.tcp_bind(addr).map(|l| TcpListener { obj: l })\n         })\n     }\n \n+    /// Returns the local socket address of this listener.\n     pub fn socket_name(&mut self) -> IoResult<SocketAddr> {\n         self.obj.socket_name()\n     }\n@@ -67,6 +156,9 @@ impl Listener<TcpStream, TcpAcceptor> for TcpListener {\n     }\n }\n \n+/// The accepting half of a TCP socket server. This structure is created through\n+/// a `TcpListener`'s `listen` method, and this object can be used to accept new\n+/// `TcpStream` instances.\n pub struct TcpAcceptor {\n     priv obj: ~RtioTcpAcceptor\n }\n@@ -573,4 +665,91 @@ mod test {\n         }\n         let _listener = TcpListener::bind(addr);\n     })\n+\n+    iotest!(fn tcp_clone_smoke() {\n+        let addr = next_test_ip4();\n+        let mut acceptor = TcpListener::bind(addr).listen();\n+\n+        spawn(proc() {\n+            let mut s = TcpStream::connect(addr);\n+            let mut buf = [0, 0];\n+            assert_eq!(s.read(buf), Ok(1));\n+            assert_eq!(buf[0], 1);\n+            s.write([2]).unwrap();\n+        });\n+\n+        let mut s1 = acceptor.accept().unwrap();\n+        let s2 = s1.clone();\n+\n+        let (p1, c1) = Chan::new();\n+        let (p2, c2) = Chan::new();\n+        spawn(proc() {\n+            let mut s2 = s2;\n+            p1.recv();\n+            s2.write([1]).unwrap();\n+            c2.send(());\n+        });\n+        c1.send(());\n+        let mut buf = [0, 0];\n+        assert_eq!(s1.read(buf), Ok(1));\n+        p2.recv();\n+    })\n+\n+    iotest!(fn tcp_clone_two_read() {\n+        let addr = next_test_ip6();\n+        let mut acceptor = TcpListener::bind(addr).listen();\n+        let (p, c) = SharedChan::new();\n+        let c2 = c.clone();\n+\n+        spawn(proc() {\n+            let mut s = TcpStream::connect(addr);\n+            s.write([1]).unwrap();\n+            p.recv();\n+            s.write([2]).unwrap();\n+            p.recv();\n+        });\n+\n+        let mut s1 = acceptor.accept().unwrap();\n+        let s2 = s1.clone();\n+\n+        let (p, done) = Chan::new();\n+        spawn(proc() {\n+            let mut s2 = s2;\n+            let mut buf = [0, 0];\n+            s2.read(buf).unwrap();\n+            c2.send(());\n+            done.send(());\n+        });\n+        let mut buf = [0, 0];\n+        s1.read(buf).unwrap();\n+        c.send(());\n+\n+        p.recv();\n+    })\n+\n+    iotest!(fn tcp_clone_two_write() {\n+        let addr = next_test_ip4();\n+        let mut acceptor = TcpListener::bind(addr).listen();\n+\n+        spawn(proc() {\n+            let mut s = TcpStream::connect(addr);\n+            let mut buf = [0, 1];\n+            s.read(buf).unwrap();\n+            s.read(buf).unwrap();\n+        });\n+\n+        let mut s1 = acceptor.accept().unwrap();\n+        let s2 = s1.clone();\n+\n+        let (p, done) = Chan::new();\n+        spawn(proc() {\n+            let mut s2 = s2;\n+            s2.write([1]).unwrap();\n+            done.send(());\n+        });\n+        s1.write([2]).unwrap();\n+\n+        p.recv();\n+    })\n }\n+"}, {"sha": "3c02f56384792deeb9197687d026aa9c8068deb8", "filename": "src/libstd/io/net/udp.rs", "status": "modified", "additions": 117, "deletions": 0, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/6aad3bf944da209d1852c51144ba584de400a10c/src%2Flibstd%2Fio%2Fnet%2Fudp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6aad3bf944da209d1852c51144ba584de400a10c/src%2Flibstd%2Fio%2Fnet%2Fudp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Fudp.rs?ref=6aad3bf944da209d1852c51144ba584de400a10c", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use clone::Clone;\n use result::{Ok, Err};\n use io::net::ip::SocketAddr;\n use io::{Reader, Writer, IoResult};\n@@ -41,6 +42,19 @@ impl UdpSocket {\n     }\n }\n \n+impl Clone for UdpSocket {\n+    /// Creates a new handle to this UDP socket, allowing for simultaneous reads\n+    /// and writes of the socket.\n+    ///\n+    /// The underlying UDP socket will not be closed until all handles to the\n+    /// socket have been deallocated. Two concurrent reads will not receive the\n+    /// same data.  Instead, the first read will receive the first packet\n+    /// received, and the second read will receive the second packet.\n+    fn clone(&self) -> UdpSocket {\n+        UdpSocket { obj: self.obj.clone() }\n+    }\n+}\n+\n pub struct UdpStream {\n     priv socket: UdpSocket,\n     priv connectedTo: SocketAddr\n@@ -250,4 +264,107 @@ mod test {\n     iotest!(fn socket_name_ip6() {\n         socket_name(next_test_ip6());\n     })\n+\n+    iotest!(fn udp_clone_smoke() {\n+        let addr1 = next_test_ip4();\n+        let addr2 = next_test_ip4();\n+        let mut sock1 = UdpSocket::bind(addr1).unwrap();\n+        let sock2 = UdpSocket::bind(addr2).unwrap();\n+\n+        spawn(proc() {\n+            let mut sock2 = sock2;\n+            let mut buf = [0, 0];\n+            assert_eq!(sock2.recvfrom(buf), Ok((1, addr1)));\n+            assert_eq!(buf[0], 1);\n+            sock2.sendto([2], addr1).unwrap();\n+        });\n+\n+        let sock3 = sock1.clone();\n+\n+        let (p1, c1) = Chan::new();\n+        let (p2, c2) = Chan::new();\n+        spawn(proc() {\n+            let mut sock3 = sock3;\n+            p1.recv();\n+            sock3.sendto([1], addr2).unwrap();\n+            c2.send(());\n+        });\n+        c1.send(());\n+        let mut buf = [0, 0];\n+        assert_eq!(sock1.recvfrom(buf), Ok((1, addr2)));\n+        p2.recv();\n+    })\n+\n+    iotest!(fn udp_clone_two_read() {\n+        let addr1 = next_test_ip4();\n+        let addr2 = next_test_ip4();\n+        let mut sock1 = UdpSocket::bind(addr1).unwrap();\n+        let sock2 = UdpSocket::bind(addr2).unwrap();\n+        let (p, c) = SharedChan::new();\n+        let c2 = c.clone();\n+\n+        spawn(proc() {\n+            let mut sock2 = sock2;\n+            sock2.sendto([1], addr1).unwrap();\n+            p.recv();\n+            sock2.sendto([2], addr1).unwrap();\n+            p.recv();\n+        });\n+\n+        let sock3 = sock1.clone();\n+\n+        let (p, done) = Chan::new();\n+        spawn(proc() {\n+            let mut sock3 = sock3;\n+            let mut buf = [0, 0];\n+            sock3.recvfrom(buf).unwrap();\n+            c2.send(());\n+            done.send(());\n+        });\n+        let mut buf = [0, 0];\n+        sock1.recvfrom(buf).unwrap();\n+        c.send(());\n+\n+        p.recv();\n+    })\n+\n+    iotest!(fn udp_clone_two_write() {\n+        let addr1 = next_test_ip4();\n+        let addr2 = next_test_ip4();\n+        let mut sock1 = UdpSocket::bind(addr1).unwrap();\n+        let sock2 = UdpSocket::bind(addr2).unwrap();\n+\n+        let (p, c) = SharedChan::new();\n+\n+        spawn(proc() {\n+            let mut sock2 = sock2;\n+            let mut buf = [0, 1];\n+\n+            for _ in p.iter() {\n+                match sock2.recvfrom(buf) {\n+                    Ok(..) => {}\n+                    Err(e) => fail!(\"failed receive: {}\", e),\n+                }\n+            }\n+        });\n+\n+        let sock3 = sock1.clone();\n+\n+        let (p, done) = Chan::new();\n+        let c2 = c.clone();\n+        spawn(proc() {\n+            let mut sock3 = sock3;\n+            match sock3.sendto([1], addr2) {\n+                Ok(..) => c2.send(()),\n+                Err(..) => {}\n+            }\n+            done.send(());\n+        });\n+        match sock1.sendto([2], addr2) {\n+            Ok(..) => c.send(()),\n+            Err(..) => {}\n+        }\n+\n+        p.recv();\n+    })\n }"}, {"sha": "3c7db9c86861897a3f6265554c86f7a2bd8e4a74", "filename": "src/libstd/io/net/unix.rs", "status": "modified", "additions": 96, "deletions": 0, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/6aad3bf944da209d1852c51144ba584de400a10c/src%2Flibstd%2Fio%2Fnet%2Funix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6aad3bf944da209d1852c51144ba584de400a10c/src%2Flibstd%2Fio%2Fnet%2Funix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Funix.rs?ref=6aad3bf944da209d1852c51144ba584de400a10c", "patch": "@@ -25,6 +25,7 @@ instances as clients.\n use prelude::*;\n \n use c_str::ToCStr;\n+use clone::Clone;\n use rt::rtio::{IoFactory, LocalIo, RtioUnixListener};\n use rt::rtio::{RtioUnixAcceptor, RtioPipe};\n use io::pipe::PipeStream;\n@@ -62,6 +63,12 @@ impl UnixStream {\n     }\n }\n \n+impl Clone for UnixStream {\n+    fn clone(&self) -> UnixStream {\n+        UnixStream { obj: self.obj.clone() }\n+    }\n+}\n+\n impl Reader for UnixStream {\n     fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> { self.obj.read(buf) }\n }\n@@ -228,4 +235,93 @@ mod tests {\n         let _acceptor = UnixListener::bind(&path).listen();\n         assert!(path.exists());\n     }\n+\n+    #[test]\n+    fn unix_clone_smoke() {\n+        let addr = next_test_unix();\n+        let mut acceptor = UnixListener::bind(&addr).listen();\n+\n+        spawn(proc() {\n+            let mut s = UnixStream::connect(&addr);\n+            let mut buf = [0, 0];\n+            assert_eq!(s.read(buf), Ok(1));\n+            assert_eq!(buf[0], 1);\n+            s.write([2]).unwrap();\n+        });\n+\n+        let mut s1 = acceptor.accept().unwrap();\n+        let s2 = s1.clone();\n+\n+        let (p1, c1) = Chan::new();\n+        let (p2, c2) = Chan::new();\n+        spawn(proc() {\n+            let mut s2 = s2;\n+            p1.recv();\n+            s2.write([1]).unwrap();\n+            c2.send(());\n+        });\n+        c1.send(());\n+        let mut buf = [0, 0];\n+        assert_eq!(s1.read(buf), Ok(1));\n+        p2.recv();\n+    }\n+\n+    #[test]\n+    fn unix_clone_two_read() {\n+        let addr = next_test_unix();\n+        let mut acceptor = UnixListener::bind(&addr).listen();\n+        let (p, c) = SharedChan::new();\n+        let c2 = c.clone();\n+\n+        spawn(proc() {\n+            let mut s = UnixStream::connect(&addr);\n+            s.write([1]).unwrap();\n+            p.recv();\n+            s.write([2]).unwrap();\n+            p.recv();\n+        });\n+\n+        let mut s1 = acceptor.accept().unwrap();\n+        let s2 = s1.clone();\n+\n+        let (p, done) = Chan::new();\n+        spawn(proc() {\n+            let mut s2 = s2;\n+            let mut buf = [0, 0];\n+            s2.read(buf).unwrap();\n+            c2.send(());\n+            done.send(());\n+        });\n+        let mut buf = [0, 0];\n+        s1.read(buf).unwrap();\n+        c.send(());\n+\n+        p.recv();\n+    }\n+\n+    #[test]\n+    fn unix_clone_two_write() {\n+        let addr = next_test_unix();\n+        let mut acceptor = UnixListener::bind(&addr).listen();\n+\n+        spawn(proc() {\n+            let mut s = UnixStream::connect(&addr);\n+            let mut buf = [0, 1];\n+            s.read(buf).unwrap();\n+            s.read(buf).unwrap();\n+        });\n+\n+        let mut s1 = acceptor.accept().unwrap();\n+        let s2 = s1.clone();\n+\n+        let (p, done) = Chan::new();\n+        spawn(proc() {\n+            let mut s2 = s2;\n+            s2.write([1]).unwrap();\n+            done.send(());\n+        });\n+        s1.write([2]).unwrap();\n+\n+        p.recv();\n+    }\n }"}, {"sha": "83250bdae7361fd81055f25338db994565f820ae", "filename": "src/libstd/io/pipe.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6aad3bf944da209d1852c51144ba584de400a10c/src%2Flibstd%2Fio%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6aad3bf944da209d1852c51144ba584de400a10c/src%2Flibstd%2Fio%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fpipe.rs?ref=6aad3bf944da209d1852c51144ba584de400a10c", "patch": "@@ -51,6 +51,12 @@ impl PipeStream {\n     }\n }\n \n+impl Clone for PipeStream {\n+    fn clone(&self) -> PipeStream {\n+        PipeStream { obj: self.obj.clone() }\n+    }\n+}\n+\n impl Reader for PipeStream {\n     fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> { self.obj.read(buf) }\n }"}, {"sha": "057d618f44490c66130e6504d0d0c919b3e76eeb", "filename": "src/libstd/libc.rs", "status": "modified", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/6aad3bf944da209d1852c51144ba584de400a10c/src%2Flibstd%2Flibc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6aad3bf944da209d1852c51144ba584de400a10c/src%2Flibstd%2Flibc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flibc.rs?ref=6aad3bf944da209d1852c51144ba584de400a10c", "patch": "@@ -960,6 +960,8 @@ pub mod types {\n             }\n             pub mod extra {\n                 use ptr;\n+                use libc::consts::os::extra::{MAX_PROTOCOL_CHAIN,\n+                                              WSAPROTOCOL_LEN};\n                 use libc::types::common::c95::c_void;\n                 use libc::types::os::arch::c95::{c_char, c_int, c_uint, size_t};\n                 use libc::types::os::arch::c95::{c_long, c_ulong};\n@@ -1106,6 +1108,47 @@ pub mod types {\n                 }\n \n                 pub type LPFILETIME = *mut FILETIME;\n+\n+                pub struct GUID {\n+                    Data1: DWORD,\n+                    Data2: DWORD,\n+                    Data3: DWORD,\n+                    Data4: [BYTE, ..8],\n+                }\n+\n+                struct WSAPROTOCOLCHAIN {\n+                    ChainLen: c_int,\n+                    ChainEntries: [DWORD, ..MAX_PROTOCOL_CHAIN],\n+                }\n+\n+                pub type LPWSAPROTOCOLCHAIN = *mut WSAPROTOCOLCHAIN;\n+\n+                pub struct WSAPROTOCOL_INFO {\n+                    dwServiceFlags1: DWORD,\n+                    dwServiceFlags2: DWORD,\n+                    dwServiceFlags3: DWORD,\n+                    dwServiceFlags4: DWORD,\n+                    dwProviderFlags: DWORD,\n+                    ProviderId: GUID,\n+                    dwCatalogEntryId: DWORD,\n+                    ProtocolChain: WSAPROTOCOLCHAIN,\n+                    iVersion: c_int,\n+                    iAddressFamily: c_int,\n+                    iMaxSockAddr: c_int,\n+                    iMinSockAddr: c_int,\n+                    iSocketType: c_int,\n+                    iProtocol: c_int,\n+                    iProtocolMaxOffset: c_int,\n+                    iNetworkByteOrder: c_int,\n+                    iSecurityScheme: c_int,\n+                    dwMessageSize: DWORD,\n+                    dwProviderReserved: DWORD,\n+                    szProtocol: [u8, ..WSAPROTOCOL_LEN+1],\n+                }\n+\n+                pub type LPWSAPROTOCOL_INFO = *mut WSAPROTOCOL_INFO;\n+\n+                pub type GROUP = c_uint;\n             }\n         }\n     }\n@@ -1721,6 +1764,10 @@ pub mod consts {\n             pub static FILE_BEGIN: DWORD = 0;\n             pub static FILE_CURRENT: DWORD = 1;\n             pub static FILE_END: DWORD = 2;\n+\n+            pub static MAX_PROTOCOL_CHAIN: DWORD = 7;\n+            pub static WSAPROTOCOL_LEN: DWORD = 255;\n+            pub static INVALID_SOCKET: DWORD = !0;\n         }\n         pub mod sysconf {\n         }\n@@ -4098,6 +4145,8 @@ pub mod funcs {\n                             lpFrequency: *mut LARGE_INTEGER) -> BOOL;\n                 pub fn QueryPerformanceCounter(\n                             lpPerformanceCount: *mut LARGE_INTEGER) -> BOOL;\n+\n+                pub fn GetCurrentProcessId() -> DWORD;\n             }\n         }\n "}, {"sha": "7bb29fdfacf65177d7fdef5b15f4e71a92366d21", "filename": "src/libstd/option.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6aad3bf944da209d1852c51144ba584de400a10c/src%2Flibstd%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6aad3bf944da209d1852c51144ba584de400a10c/src%2Flibstd%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Foption.rs?ref=6aad3bf944da209d1852c51144ba584de400a10c", "patch": "@@ -480,7 +480,6 @@ mod tests {\n \n     use iter::range;\n     use str::StrSlice;\n-    use util;\n     use kinds::marker;\n     use vec::ImmutableVector;\n "}, {"sha": "8d02048d55cf0584d483f563dcf3fe00f64c3fb7", "filename": "src/libstd/rt/rtio.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6aad3bf944da209d1852c51144ba584de400a10c/src%2Flibstd%2Frt%2Frtio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6aad3bf944da209d1852c51144ba584de400a10c/src%2Flibstd%2Frt%2Frtio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Frtio.rs?ref=6aad3bf944da209d1852c51144ba584de400a10c", "patch": "@@ -203,6 +203,7 @@ pub trait RtioTcpStream : RtioSocket {\n     fn nodelay(&mut self) -> Result<(), IoError>;\n     fn keepalive(&mut self, delay_in_seconds: uint) -> Result<(), IoError>;\n     fn letdie(&mut self) -> Result<(), IoError>;\n+    fn clone(&self) -> ~RtioTcpStream;\n }\n \n pub trait RtioSocket {\n@@ -224,6 +225,8 @@ pub trait RtioUdpSocket : RtioSocket {\n \n     fn hear_broadcasts(&mut self) -> Result<(), IoError>;\n     fn ignore_broadcasts(&mut self) -> Result<(), IoError>;\n+\n+    fn clone(&self) -> ~RtioUdpSocket;\n }\n \n pub trait RtioTimer {\n@@ -253,6 +256,7 @@ pub trait RtioProcess {\n pub trait RtioPipe {\n     fn read(&mut self, buf: &mut [u8]) -> Result<uint, IoError>;\n     fn write(&mut self, buf: &[u8]) -> Result<(), IoError>;\n+    fn clone(&self) -> ~RtioPipe;\n }\n \n pub trait RtioUnixListener {"}, {"sha": "82957cd93ceb8772242535fe961b6a09940254af", "filename": "src/libstd/unstable/mutex.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6aad3bf944da209d1852c51144ba584de400a10c/src%2Flibstd%2Funstable%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6aad3bf944da209d1852c51144ba584de400a10c/src%2Flibstd%2Funstable%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fmutex.rs?ref=6aad3bf944da209d1852c51144ba584de400a10c", "patch": "@@ -380,7 +380,6 @@ mod test {\n \n     use super::{Mutex, MUTEX_INIT};\n     use rt::thread::Thread;\n-    use task;\n \n     #[test]\n     fn somke_lock() {"}, {"sha": "715a10b9112f975b3fe1f632cb8a63fb81cb22bc", "filename": "src/libstd/util.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6aad3bf944da209d1852c51144ba584de400a10c/src%2Flibstd%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6aad3bf944da209d1852c51144ba584de400a10c/src%2Flibstd%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Futil.rs?ref=6aad3bf944da209d1852c51144ba584de400a10c", "patch": "@@ -69,7 +69,6 @@ impl Void {\n mod tests {\n     use super::*;\n     use prelude::*;\n-    use mem::size_of;\n \n     #[test]\n     fn identity_crisis() {"}, {"sha": "d53c2dceba248262db3bad642d9262d39b1cbc18", "filename": "src/libstd/vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6aad3bf944da209d1852c51144ba584de400a10c/src%2Flibstd%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6aad3bf944da209d1852c51144ba584de400a10c/src%2Flibstd%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fvec.rs?ref=6aad3bf944da209d1852c51144ba584de400a10c", "patch": "@@ -4253,7 +4253,7 @@ mod tests {\n         let h = x.mut_last();\n         assert_eq!(*h.unwrap(), 5);\n \n-        let mut y: &mut [int] = [];\n+        let y: &mut [int] = [];\n         assert!(y.mut_last().is_none());\n     }\n }"}]}