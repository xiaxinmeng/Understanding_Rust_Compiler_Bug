{"sha": "2168c0b9791d55361177efa3bb7e79f7b944a423", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIxNjhjMGI5NzkxZDU1MzYxMTc3ZWZhM2JiN2U3OWY3Yjk0NGE0MjM=", "commit": {"author": {"name": "Janusz Marcinkiewicz", "email": "virrages@gmail.com", "date": "2019-12-23T10:56:34Z"}, "committer": {"name": "Janusz Marcinkiewicz", "email": "virrages@gmail.com", "date": "2019-12-23T11:06:17Z"}, "message": "Extract checking for self arg to separate method", "tree": {"sha": "b584bedef9d805f87f8277e3c396896bed654620", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b584bedef9d805f87f8277e3c396896bed654620"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2168c0b9791d55361177efa3bb7e79f7b944a423", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2168c0b9791d55361177efa3bb7e79f7b944a423", "html_url": "https://github.com/rust-lang/rust/commit/2168c0b9791d55361177efa3bb7e79f7b944a423", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2168c0b9791d55361177efa3bb7e79f7b944a423/comments", "author": {"login": "VirrageS", "id": 3855799, "node_id": "MDQ6VXNlcjM4NTU3OTk=", "avatar_url": "https://avatars.githubusercontent.com/u/3855799?v=4", "gravatar_id": "", "url": "https://api.github.com/users/VirrageS", "html_url": "https://github.com/VirrageS", "followers_url": "https://api.github.com/users/VirrageS/followers", "following_url": "https://api.github.com/users/VirrageS/following{/other_user}", "gists_url": "https://api.github.com/users/VirrageS/gists{/gist_id}", "starred_url": "https://api.github.com/users/VirrageS/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/VirrageS/subscriptions", "organizations_url": "https://api.github.com/users/VirrageS/orgs", "repos_url": "https://api.github.com/users/VirrageS/repos", "events_url": "https://api.github.com/users/VirrageS/events{/privacy}", "received_events_url": "https://api.github.com/users/VirrageS/received_events", "type": "User", "site_admin": false}, "committer": {"login": "VirrageS", "id": 3855799, "node_id": "MDQ6VXNlcjM4NTU3OTk=", "avatar_url": "https://avatars.githubusercontent.com/u/3855799?v=4", "gravatar_id": "", "url": "https://api.github.com/users/VirrageS", "html_url": "https://github.com/VirrageS", "followers_url": "https://api.github.com/users/VirrageS/followers", "following_url": "https://api.github.com/users/VirrageS/following{/other_user}", "gists_url": "https://api.github.com/users/VirrageS/gists{/gist_id}", "starred_url": "https://api.github.com/users/VirrageS/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/VirrageS/subscriptions", "organizations_url": "https://api.github.com/users/VirrageS/orgs", "repos_url": "https://api.github.com/users/VirrageS/repos", "events_url": "https://api.github.com/users/VirrageS/events{/privacy}", "received_events_url": "https://api.github.com/users/VirrageS/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7353afdfd9b992a0254b8c23592e91cde792d514", "url": "https://api.github.com/repos/rust-lang/rust/commits/7353afdfd9b992a0254b8c23592e91cde792d514", "html_url": "https://github.com/rust-lang/rust/commit/7353afdfd9b992a0254b8c23592e91cde792d514"}], "stats": {"total": 75, "additions": 40, "deletions": 35}, "files": [{"sha": "904a4125f2f72b5595f9b96765220760f2e84e1a", "filename": "src/librustc_resolve/late/diagnostics.rs", "status": "modified", "additions": 40, "deletions": 35, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/2168c0b9791d55361177efa3bb7e79f7b944a423/src%2Flibrustc_resolve%2Flate%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2168c0b9791d55361177efa3bb7e79f7b944a423/src%2Flibrustc_resolve%2Flate%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flate%2Fdiagnostics.rs?ref=2168c0b9791d55361177efa3bb7e79f7b944a423", "patch": "@@ -260,41 +260,9 @@ impl<'a> LateResolutionVisitor<'a, '_> {\n                 return (err, candidates);\n             }\n \n-            // Check if the first argument is `self` and suggest calling a method.\n-            let mut has_self_arg = None;\n-            if let PathSource::Expr(parent) = source {\n-                match &parent.map(|p| &p.kind) {\n-                    Some(ExprKind::Call(_, args)) if args.len() > 0 => {\n-                        let mut expr_kind = &args[0].kind;\n-                        loop {\n-                            match expr_kind {\n-                                ExprKind::Path(_, arg_name) if arg_name.segments.len() == 1 => {\n-                                    if arg_name.segments[0].ident.name == kw::SelfLower {\n-                                        let call_span = parent.unwrap().span;\n-                                        let args_span = if args.len() > 1 {\n-                                            Some(Span::new(\n-                                                args[1].span.lo(),\n-                                                args.last().unwrap().span.hi(),\n-                                                call_span.ctxt(),\n-                                            ))\n-                                        } else {\n-                                            None\n-                                        };\n-                                        has_self_arg = Some((call_span, args_span));\n-                                    }\n-                                    break;\n-                                },\n-                                ExprKind::AddrOf(_, _, expr) => expr_kind = &expr.kind,\n-                                _ => break,\n-                            }\n-                        }\n-                    }\n-                    _ => (),\n-                }\n-            };\n-\n-            if let Some((call_span, args_span)) = has_self_arg {\n-                let mut args_snippet: String = String::from(\"\");\n+            // If the first argument in call is `self` suggest calling a method.\n+            if let Some((call_span, args_span)) = self.call_has_self_arg(source) {\n+                let mut args_snippet = String::new();\n                 if let Some(args_span) = args_span {\n                     if let Ok(snippet) = self.r.session.source_map().span_to_snippet(args_span) {\n                         args_snippet = snippet;\n@@ -348,6 +316,43 @@ impl<'a> LateResolutionVisitor<'a, '_> {\n         (err, candidates)\n     }\n \n+    /// Check if the source is call expression and the first argument is `self`. If true,\n+    /// return the span of whole call and the span for all arguments expect the first one (`self`).\n+    fn call_has_self_arg(&self, source: PathSource<'_>) -> Option<(Span, Option<Span>)> {\n+        let mut has_self_arg = None;\n+        if let PathSource::Expr(parent) = source {\n+            match &parent.map(|p| &p.kind) {\n+                Some(ExprKind::Call(_, args)) if args.len() > 0 => {\n+                    let mut expr_kind = &args[0].kind;\n+                    loop {\n+                        match expr_kind {\n+                            ExprKind::Path(_, arg_name) if arg_name.segments.len() == 1 => {\n+                                if arg_name.segments[0].ident.name == kw::SelfLower {\n+                                    let call_span = parent.unwrap().span;\n+                                    let tail_args_span = if args.len() > 1 {\n+                                        Some(Span::new(\n+                                            args[1].span.lo(),\n+                                            args.last().unwrap().span.hi(),\n+                                            call_span.ctxt(),\n+                                        ))\n+                                    } else {\n+                                        None\n+                                    };\n+                                    has_self_arg = Some((call_span, tail_args_span));\n+                                }\n+                                break;\n+                            }\n+                            ExprKind::AddrOf(_, _, expr) => expr_kind = &expr.kind,\n+                            _ => break,\n+                        }\n+                    }\n+                }\n+                _ => (),\n+            }\n+        };\n+        return has_self_arg;\n+    }\n+\n     fn followed_by_brace(&self, span: Span) -> (bool, Option<(Span, String)>) {\n         // HACK(estebank): find a better way to figure out that this was a\n         // parser issue where a struct literal is being used on an expression"}]}