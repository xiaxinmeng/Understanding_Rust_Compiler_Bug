{"sha": "27fad2ad751bc813a98db18d8c31ea3cb178d228", "node_id": "C_kwDOAAsO6NoAKDI3ZmFkMmFkNzUxYmM4MTNhOThkYjE4ZDhjMzFlYTNjYjE3OGQyMjg", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2023-03-05T14:42:40Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2023-03-05T14:42:40Z"}, "message": "Lift segment check out of the loop in resolve_path_in_value_ns", "tree": {"sha": "07689d1ff184753b11ca8d0925f856f543766494", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/07689d1ff184753b11ca8d0925f856f543766494"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/27fad2ad751bc813a98db18d8c31ea3cb178d228", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/27fad2ad751bc813a98db18d8c31ea3cb178d228", "html_url": "https://github.com/rust-lang/rust/commit/27fad2ad751bc813a98db18d8c31ea3cb178d228", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/27fad2ad751bc813a98db18d8c31ea3cb178d228/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a51267c5e0f00f050378892d671317d912ff8257", "url": "https://api.github.com/repos/rust-lang/rust/commits/a51267c5e0f00f050378892d671317d912ff8257", "html_url": "https://github.com/rust-lang/rust/commit/a51267c5e0f00f050378892d671317d912ff8257"}], "stats": {"total": 102, "additions": 57, "deletions": 45}, "files": [{"sha": "eea837ddd23a40994bd4c42efceefe15d30947df", "filename": "crates/hir-def/src/resolver.rs", "status": "modified", "additions": 57, "deletions": 45, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/27fad2ad751bc813a98db18d8c31ea3cb178d228/crates%2Fhir-def%2Fsrc%2Fresolver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27fad2ad751bc813a98db18d8c31ea3cb178d228/crates%2Fhir-def%2Fsrc%2Fresolver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fresolver.rs?ref=27fad2ad751bc813a98db18d8c31ea3cb178d228", "patch": "@@ -255,55 +255,67 @@ impl Resolver {\n             return self.module_scope.resolve_path_in_value_ns(db, path);\n         }\n \n-        for scope in self.scopes() {\n-            match scope {\n-                Scope::ExprScope(_) if n_segments > 1 => continue,\n-                Scope::ExprScope(scope) => {\n-                    let entry = scope\n-                        .expr_scopes\n-                        .entries(scope.scope_id)\n-                        .iter()\n-                        .find(|entry| entry.name() == first_name);\n-\n-                    if let Some(e) = entry {\n-                        return Some(ResolveValueResult::ValueNs(ValueNs::LocalBinding(e.pat())));\n+        if n_segments <= 1 {\n+            for scope in self.scopes() {\n+                match scope {\n+                    Scope::ExprScope(scope) => {\n+                        let entry = scope\n+                            .expr_scopes\n+                            .entries(scope.scope_id)\n+                            .iter()\n+                            .find(|entry| entry.name() == first_name);\n+\n+                        if let Some(e) = entry {\n+                            return Some(ResolveValueResult::ValueNs(ValueNs::LocalBinding(\n+                                e.pat(),\n+                            )));\n+                        }\n                     }\n-                }\n-                Scope::GenericParams { params, def } if n_segments > 1 => {\n-                    if let Some(id) = params.find_type_by_name(first_name, *def) {\n-                        let ty = TypeNs::GenericParam(id);\n-                        return Some(ResolveValueResult::Partial(ty, 1));\n+                    Scope::GenericParams { params, def } => {\n+                        if let Some(id) = params.find_const_by_name(first_name, *def) {\n+                            let val = ValueNs::GenericParam(id);\n+                            return Some(ResolveValueResult::ValueNs(val));\n+                        }\n                     }\n-                }\n-                Scope::GenericParams { .. } if n_segments != 1 => continue,\n-                Scope::GenericParams { params, def } => {\n-                    if let Some(id) = params.find_const_by_name(first_name, *def) {\n-                        let val = ValueNs::GenericParam(id);\n-                        return Some(ResolveValueResult::ValueNs(val));\n+                    &Scope::ImplDefScope(impl_) => {\n+                        if first_name == &name![Self] {\n+                            return Some(ResolveValueResult::ValueNs(ValueNs::ImplSelf(impl_)));\n+                        }\n                     }\n-                }\n-\n-                &Scope::ImplDefScope(impl_) => {\n-                    if first_name == &name![Self] {\n-                        return Some(if n_segments > 1 {\n-                            ResolveValueResult::Partial(TypeNs::SelfType(impl_), 1)\n-                        } else {\n-                            ResolveValueResult::ValueNs(ValueNs::ImplSelf(impl_))\n-                        });\n+                    // bare `Self` doesn't work in the value namespace in a struct/enum definition\n+                    Scope::AdtScope(_) => continue,\n+                    Scope::BlockScope(m) => {\n+                        if let Some(def) = m.resolve_path_in_value_ns(db, path) {\n+                            return Some(def);\n+                        }\n                     }\n                 }\n-                // bare `Self` doesn't work in the value namespace in a struct/enum definition\n-                Scope::AdtScope(_) if n_segments == 1 => continue,\n-                Scope::AdtScope(adt) => {\n-                    if first_name == &name![Self] {\n-                        let ty = TypeNs::AdtSelfType(*adt);\n-                        return Some(ResolveValueResult::Partial(ty, 1));\n+            }\n+        } else {\n+            for scope in self.scopes() {\n+                match scope {\n+                    Scope::ExprScope(_) => continue,\n+                    Scope::GenericParams { params, def } => {\n+                        if let Some(id) = params.find_type_by_name(first_name, *def) {\n+                            let ty = TypeNs::GenericParam(id);\n+                            return Some(ResolveValueResult::Partial(ty, 1));\n+                        }\n                     }\n-                }\n-\n-                Scope::BlockScope(m) => {\n-                    if let Some(def) = m.resolve_path_in_value_ns(db, path) {\n-                        return Some(def);\n+                    &Scope::ImplDefScope(impl_) => {\n+                        if first_name == &name![Self] {\n+                            return Some(ResolveValueResult::Partial(TypeNs::SelfType(impl_), 1));\n+                        }\n+                    }\n+                    Scope::AdtScope(adt) => {\n+                        if first_name == &name![Self] {\n+                            let ty = TypeNs::AdtSelfType(*adt);\n+                            return Some(ResolveValueResult::Partial(ty, 1));\n+                        }\n+                    }\n+                    Scope::BlockScope(m) => {\n+                        if let Some(def) = m.resolve_path_in_value_ns(db, path) {\n+                            return Some(def);\n+                        }\n                     }\n                 }\n             }\n@@ -316,8 +328,8 @@ impl Resolver {\n         // If a path of the shape `u16::from_le_bytes` failed to resolve at all, then we fall back\n         // to resolving to the primitive type, to allow this to still work in the presence of\n         // `use core::u16;`.\n-        if path.kind == PathKind::Plain && path.segments().len() > 1 {\n-            if let Some(builtin) = BuiltinType::by_name(&path.segments()[0]) {\n+        if path.kind == PathKind::Plain && n_segments > 1 {\n+            if let Some(builtin) = BuiltinType::by_name(first_name) {\n                 return Some(ResolveValueResult::Partial(TypeNs::BuiltinType(builtin), 1));\n             }\n         }"}]}