{"sha": "826d8f3850b37a23481dfcf4a899b5dfc82d22e3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgyNmQ4ZjM4NTBiMzdhMjM0ODFkZmNmNGE4OTliNWRmYzgyZDIyZTM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-05-13T17:56:09Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-05-13T17:56:09Z"}, "message": "Auto merge of #41914 - eddyb:region-refactor, r=nikomatsakis\n\nrustc: simpler ParameterEnvironment and free regions.\n\nThe commits describe the slow transformation but the highlights are:\n* `ReEarlyBound` is considered free, with a scope based on the item that defined the lifetime parameter, and the root body of the `RegionMaps` in use, removing the need for `free_substs`\n* `liberate_late_bound_regions` and `implicit_region_bound` moved to typeck\n* `CodeExtent` not interned at all now - ideally it would be 2 `u32` but it's small anyway\n\nFuture work building up on this could include:\n* `ParameterEnvironment` becoming just the result of `predicates_of`\n  * interning makes my \"parent chain\" scheme unnecessary\n* `implicit_region_bound` could be retrieved from `RegionMaps`\n* renaming `CodeExtent` to `Scope`\n  * generalizing \"call site\" to \"use site\" or something better to include constants\n* renaming `RegionMaps` to `ScopeTree` and its API to talk about \"parents\" explicitly", "tree": {"sha": "a560fcb5a4b63710295641b6d187087560d22104", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a560fcb5a4b63710295641b6d187087560d22104"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/826d8f3850b37a23481dfcf4a899b5dfc82d22e3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/826d8f3850b37a23481dfcf4a899b5dfc82d22e3", "html_url": "https://github.com/rust-lang/rust/commit/826d8f3850b37a23481dfcf4a899b5dfc82d22e3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/826d8f3850b37a23481dfcf4a899b5dfc82d22e3/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "77f1bec6f5eb9ed632c973b97b12701294e6d3a5", "url": "https://api.github.com/repos/rust-lang/rust/commits/77f1bec6f5eb9ed632c973b97b12701294e6d3a5", "html_url": "https://github.com/rust-lang/rust/commit/77f1bec6f5eb9ed632c973b97b12701294e6d3a5"}, {"sha": "6da4123f5f819608fce49258bfa4f74fe195806b", "url": "https://api.github.com/repos/rust-lang/rust/commits/6da4123f5f819608fce49258bfa4f74fe195806b", "html_url": "https://github.com/rust-lang/rust/commit/6da4123f5f819608fce49258bfa4f74fe195806b"}], "stats": {"total": 1807, "additions": 707, "deletions": 1100}, "files": [{"sha": "c1c195852f9492bddfe2406446ce1a4b78698b22", "filename": "src/librustc/cfg/construct.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/826d8f3850b37a23481dfcf4a899b5dfc82d22e3/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/826d8f3850b37a23481dfcf4a899b5dfc82d22e3/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fcfg%2Fconstruct.rs?ref=826d8f3850b37a23481dfcf4a899b5dfc82d22e3", "patch": "@@ -10,6 +10,7 @@\n \n use rustc_data_structures::graph;\n use cfg::*;\n+use middle::region::CodeExtent;\n use ty::{self, TyCtxt};\n use syntax::ast;\n use syntax::ptr::P;\n@@ -586,8 +587,8 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n                         scope_id: ast::NodeId,\n                         to_index: CFGIndex) {\n         let mut data = CFGEdgeData { exiting_scopes: vec![] };\n-        let mut scope = self.tcx.node_extent(from_expr.id);\n-        let target_scope = self.tcx.node_extent(scope_id);\n+        let mut scope = CodeExtent::Misc(from_expr.id);\n+        let target_scope = CodeExtent::Misc(scope_id);\n         let region_maps = self.tcx.region_maps(self.owner_def_id);\n         while scope != target_scope {\n             data.exiting_scopes.push(scope.node_id());"}, {"sha": "3bbac8d6a64259ec513d70afbccb2dd5cc27c0b6", "filename": "src/librustc/ich/impls_ty.rs", "status": "modified", "additions": 11, "deletions": 16, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/826d8f3850b37a23481dfcf4a899b5dfc82d22e3/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/826d8f3850b37a23481dfcf4a899b5dfc82d22e3/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_ty.rs?ref=826d8f3850b37a23481dfcf4a899b5dfc82d22e3", "patch": "@@ -39,7 +39,7 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for ty::subst::Kind<'t\n     }\n }\n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for ty::RegionKind<'tcx> {\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for ty::RegionKind {\n     fn hash_stable<W: StableHasherResult>(&self,\n                                           hcx: &mut StableHashingContext<'a, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n@@ -54,7 +54,8 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for ty::RegionKind<'tc\n                 db.depth.hash_stable(hcx, hasher);\n                 i.hash_stable(hcx, hasher);\n             }\n-            ty::ReEarlyBound(ty::EarlyBoundRegion { index, name }) => {\n+            ty::ReEarlyBound(ty::EarlyBoundRegion { def_id, index, name }) => {\n+                def_id.hash_stable(hcx, hasher);\n                 index.hash_stable(hcx, hasher);\n                 name.hash_stable(hcx, hasher);\n             }\n@@ -409,11 +410,6 @@ impl_stable_hash_for!(enum ::middle::resolve_lifetime::Region {\n     Free(call_site_scope_data, decl)\n });\n \n-impl_stable_hash_for!(struct ::middle::region::CallSiteScopeData {\n-    fn_id,\n-    body_id\n-});\n-\n impl_stable_hash_for!(struct ty::DebruijnIndex {\n     depth\n });\n@@ -432,25 +428,24 @@ impl_stable_hash_for!(enum ty::cast::CastKind {\n     FnPtrAddrCast\n });\n \n-impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for ::middle::region::CodeExtentData\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for ::middle::region::CodeExtent\n {\n     fn hash_stable<W: StableHasherResult>(&self,\n                                           hcx: &mut StableHashingContext<'a, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n-        use middle::region::CodeExtentData;\n+        use middle::region::CodeExtent;\n \n         mem::discriminant(self).hash_stable(hcx, hasher);\n         match *self {\n-            CodeExtentData::Misc(node_id) |\n-            CodeExtentData::DestructionScope(node_id) => {\n+            CodeExtent::Misc(node_id) |\n+            CodeExtent::DestructionScope(node_id) => {\n                 node_id.hash_stable(hcx, hasher);\n             }\n-            CodeExtentData::CallSiteScope { fn_id, body_id } |\n-            CodeExtentData::ParameterScope { fn_id, body_id } => {\n-                fn_id.hash_stable(hcx, hasher);\n+            CodeExtent::CallSiteScope(body_id) |\n+            CodeExtent::ParameterScope(body_id) => {\n                 body_id.hash_stable(hcx, hasher);\n             }\n-            CodeExtentData::Remainder(block_remainder) => {\n+            CodeExtent::Remainder(block_remainder) => {\n                 block_remainder.hash_stable(hcx, hasher);\n             }\n         }\n@@ -466,7 +461,7 @@ impl_stable_hash_for!(struct ty::adjustment::CoerceUnsizedInfo {\n     custom_kind\n });\n \n-impl_stable_hash_for!(struct ty::FreeRegion<'tcx> {\n+impl_stable_hash_for!(struct ty::FreeRegion {\n     scope,\n     bound_region\n });"}, {"sha": "18909a784d6106298aec4d8ad3b7b5e3b5250bd2", "filename": "src/librustc/infer/combine.rs", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/826d8f3850b37a23481dfcf4a899b5dfc82d22e3/src%2Flibrustc%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/826d8f3850b37a23481dfcf4a899b5dfc82d22e3/src%2Flibrustc%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcombine.rs?ref=826d8f3850b37a23481dfcf4a899b5dfc82d22e3", "patch": "@@ -423,15 +423,6 @@ impl<'cx, 'gcx, 'tcx> TypeRelation<'cx, 'gcx, 'tcx> for Generalizer<'cx, 'gcx, '\n                 return Ok(r);\n             }\n \n-            // Early-bound regions should really have been substituted away before\n-            // we get to this point.\n-            ty::ReEarlyBound(..) => {\n-                span_bug!(\n-                    self.span,\n-                    \"Encountered early bound region when generalizing: {:?}\",\n-                    r);\n-            }\n-\n             // Always make a fresh region variable for skolemized regions;\n             // the higher-ranked decision procedures rely on this.\n             ty::ReSkolemized(..) => { }\n@@ -442,6 +433,7 @@ impl<'cx, 'gcx, 'tcx> TypeRelation<'cx, 'gcx, 'tcx> for Generalizer<'cx, 'gcx, '\n             ty::ReStatic |\n             ty::ReScope(..) |\n             ty::ReVar(..) |\n+            ty::ReEarlyBound(..) |\n             ty::ReFree(..) => {\n                 match self.ambient_variance {\n                     ty::Invariant => return Ok(r),"}, {"sha": "c07b3b3c4be90bd445a407d1d901ef1289ce843b", "filename": "src/librustc/infer/error_reporting/mod.rs", "status": "modified", "additions": 34, "deletions": 19, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/826d8f3850b37a23481dfcf4a899b5dfc82d22e3/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/826d8f3850b37a23481dfcf4a899b5dfc82d22e3/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=826d8f3850b37a23481dfcf4a899b5dfc82d22e3", "patch": "@@ -151,19 +151,19 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                         return;\n                     }\n                 };\n-                let scope_decorated_tag = match *scope {\n-                    region::CodeExtentData::Misc(_) => tag,\n-                    region::CodeExtentData::CallSiteScope { .. } => {\n+                let scope_decorated_tag = match scope {\n+                    region::CodeExtent::Misc(_) => tag,\n+                    region::CodeExtent::CallSiteScope(_) => {\n                         \"scope of call-site for function\"\n                     }\n-                    region::CodeExtentData::ParameterScope { .. } => {\n+                    region::CodeExtent::ParameterScope(_) => {\n                         \"scope of function body\"\n                     }\n-                    region::CodeExtentData::DestructionScope(_) => {\n+                    region::CodeExtent::DestructionScope(_) => {\n                         new_string = format!(\"destruction scope surrounding {}\", tag);\n                         &new_string[..]\n                     }\n-                    region::CodeExtentData::Remainder(r) => {\n+                    region::CodeExtent::Remainder(r) => {\n                         new_string = format!(\"block suffix following statement {}\",\n                                              r.first_statement_index);\n                         &new_string[..]\n@@ -172,19 +172,35 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                 explain_span(self, scope_decorated_tag, span)\n             }\n \n-            ty::ReFree(ref fr) => {\n-                let prefix = match fr.bound_region {\n-                    ty::BrAnon(idx) => {\n-                        format!(\"the anonymous lifetime #{} defined on\", idx + 1)\n+            ty::ReEarlyBound(_) |\n+            ty::ReFree(_) => {\n+                let scope = match *region {\n+                    ty::ReEarlyBound(ref br) => {\n+                        self.parent_def_id(br.def_id).unwrap()\n                     }\n-                    ty::BrFresh(_) => \"an anonymous lifetime defined on\".to_owned(),\n-                    _ => {\n-                        format!(\"the lifetime {} as defined on\",\n-                                fr.bound_region)\n+                    ty::ReFree(ref fr) => fr.scope,\n+                    _ => bug!()\n+                };\n+                let prefix = match *region {\n+                    ty::ReEarlyBound(ref br) => {\n+                        format!(\"the lifetime {} as defined on\", br.name)\n+                    }\n+                    ty::ReFree(ref fr) => {\n+                        match fr.bound_region {\n+                            ty::BrAnon(idx) => {\n+                                format!(\"the anonymous lifetime #{} defined on\", idx + 1)\n+                            }\n+                            ty::BrFresh(_) => \"an anonymous lifetime defined on\".to_owned(),\n+                            _ => {\n+                                format!(\"the lifetime {} as defined on\",\n+                                        fr.bound_region)\n+                            }\n+                        }\n                     }\n+                    _ => bug!()\n                 };\n \n-                let node = fr.scope.map(|s| s.node_id())\n+                let node = self.hir.as_local_node_id(scope)\n                                    .unwrap_or(DUMMY_NODE_ID);\n                 let unknown;\n                 let tag = match self.hir.find(node) {\n@@ -199,12 +215,12 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                     Some(_) => {\n                         unknown = format!(\"unexpected node ({}) for scope {:?}.  \\\n                                            Please report a bug.\",\n-                                          self.hir.node_to_string(node), fr.scope);\n+                                          self.hir.node_to_string(node), scope);\n                         &unknown\n                     }\n                     None => {\n                         unknown = format!(\"unknown node for scope {:?}.  \\\n-                                           Please report a bug.\", fr.scope);\n+                                           Please report a bug.\", scope);\n                         &unknown\n                     }\n                 };\n@@ -216,8 +232,6 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n \n             ty::ReEmpty => (\"the empty lifetime\".to_owned(), None),\n \n-            ty::ReEarlyBound(ref data) => (data.name.to_string(), None),\n-\n             // FIXME(#13998) ReSkolemized should probably print like\n             // ReFree rather than dumping Debug output on the user.\n             //\n@@ -797,6 +811,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         }\n \n         let mut err = match *sub {\n+            ty::ReEarlyBound(_) |\n             ty::ReFree(ty::FreeRegion {bound_region: ty::BrNamed(..), ..}) => {\n                 // Does the required lifetime have a nice name we can print?\n                 let mut err = struct_span_err!(self.tcx.sess,"}, {"sha": "a0ef1f65f52eac661ca0000eaed6e99251194426", "filename": "src/librustc/infer/freshen.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/826d8f3850b37a23481dfcf4a899b5dfc82d22e3/src%2Flibrustc%2Finfer%2Ffreshen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/826d8f3850b37a23481dfcf4a899b5dfc82d22e3/src%2Flibrustc%2Finfer%2Ffreshen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ffreshen.rs?ref=826d8f3850b37a23481dfcf4a899b5dfc82d22e3", "patch": "@@ -85,13 +85,13 @@ impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for TypeFreshener<'a, 'gcx, 'tcx> {\n \n     fn fold_region(&mut self, r: ty::Region<'tcx>) -> ty::Region<'tcx> {\n         match *r {\n-            ty::ReEarlyBound(..) |\n             ty::ReLateBound(..) => {\n                 // leave bound regions alone\n                 r\n             }\n \n             ty::ReStatic |\n+            ty::ReEarlyBound(..) |\n             ty::ReFree(_) |\n             ty::ReScope(_) |\n             ty::ReVar(_) |"}, {"sha": "dbbcc6cfbec6b0048cce15c8af31a37110873133", "filename": "src/librustc/infer/higher_ranked/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/826d8f3850b37a23481dfcf4a899b5dfc82d22e3/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/826d8f3850b37a23481dfcf4a899b5dfc82d22e3/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs?ref=826d8f3850b37a23481dfcf4a899b5dfc82d22e3", "patch": "@@ -274,7 +274,7 @@ impl<'a, 'gcx, 'tcx> CombineFields<'a, 'gcx, 'tcx> {\n                                              -> ty::Region<'tcx> {\n             // Regions that pre-dated the LUB computation stay as they are.\n             if !is_var_in_set(new_vars, r0) {\n-                assert!(!r0.is_bound());\n+                assert!(!r0.is_late_bound());\n                 debug!(\"generalize_region(r0={:?}): not new variable\", r0);\n                 return r0;\n             }\n@@ -288,7 +288,7 @@ impl<'a, 'gcx, 'tcx> CombineFields<'a, 'gcx, 'tcx> {\n                 debug!(\"generalize_region(r0={:?}): \\\n                         non-new-variables found in {:?}\",\n                        r0, tainted);\n-                assert!(!r0.is_bound());\n+                assert!(!r0.is_late_bound());\n                 return r0;\n             }\n \n@@ -371,7 +371,7 @@ impl<'a, 'gcx, 'tcx> CombineFields<'a, 'gcx, 'tcx> {\n                                              r0: ty::Region<'tcx>)\n                                              -> ty::Region<'tcx> {\n             if !is_var_in_set(new_vars, r0) {\n-                assert!(!r0.is_bound());\n+                assert!(!r0.is_late_bound());\n                 return r0;\n             }\n \n@@ -424,7 +424,7 @@ impl<'a, 'gcx, 'tcx> CombineFields<'a, 'gcx, 'tcx> {\n                 return rev_lookup(infcx, span, a_map, a_r.unwrap());\n             } else if a_r.is_none() && b_r.is_none() {\n                 // Not related to bound variables from either fn:\n-                assert!(!r0.is_bound());\n+                assert!(!r0.is_late_bound());\n                 return r0;\n             } else {\n                 // Other:"}, {"sha": "1ecc277c7ca4d27dd407cfc9ff39b1f910c5ecdb", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/826d8f3850b37a23481dfcf4a899b5dfc82d22e3/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/826d8f3850b37a23481dfcf4a899b5dfc82d22e3/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=826d8f3850b37a23481dfcf4a899b5dfc82d22e3", "patch": "@@ -450,10 +450,10 @@ impl<'a, 'tcx> InferEnv<'a, 'tcx> for hir::BodyId {\n                 -> (Option<&'a ty::TypeckTables<'tcx>>,\n                     Option<ty::TypeckTables<'tcx>>,\n                     Option<ty::ParameterEnvironment<'tcx>>) {\n-        let item_id = tcx.hir.body_owner(self);\n-        (Some(tcx.typeck_tables_of(tcx.hir.local_def_id(item_id))),\n+        let def_id = tcx.hir.body_owner_def_id(self);\n+        (Some(tcx.typeck_tables_of(def_id)),\n          None,\n-         Some(ty::ParameterEnvironment::for_item(tcx, item_id)))\n+         Some(tcx.parameter_environment(def_id)))\n     }\n }\n \n@@ -1009,7 +1009,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn add_given(&self,\n-                     sub: ty::FreeRegion<'tcx>,\n+                     sub: ty::Region<'tcx>,\n                      sup: ty::RegionVid)\n     {\n         self.region_vars.add_given(sub, sup);\n@@ -1324,7 +1324,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n \n     pub fn resolve_regions_and_report_errors(&self,\n                                              region_context: DefId,\n-                                             region_map: &RegionMaps<'tcx>,\n+                                             region_map: &RegionMaps,\n                                              free_regions: &FreeRegionMap<'tcx>) {\n         let region_rels = RegionRelations::new(self.tcx,\n                                                region_context,"}, {"sha": "cce253c1a1a43b8e77b73e5d5e66bf02e005d25b", "filename": "src/librustc/infer/region_inference/graphviz.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/826d8f3850b37a23481dfcf4a899b5dfc82d22e3/src%2Flibrustc%2Finfer%2Fregion_inference%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/826d8f3850b37a23481dfcf4a899b5dfc82d22e3/src%2Flibrustc%2Finfer%2Fregion_inference%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fregion_inference%2Fgraphviz.rs?ref=826d8f3850b37a23481dfcf4a899b5dfc82d22e3", "patch": "@@ -124,20 +124,20 @@ struct ConstraintGraph<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     graph_name: String,\n     region_rels: &'a RegionRelations<'a, 'gcx, 'tcx>,\n     map: &'a FxHashMap<Constraint<'tcx>, SubregionOrigin<'tcx>>,\n-    node_ids: FxHashMap<Node<'tcx>, usize>,\n+    node_ids: FxHashMap<Node, usize>,\n }\n \n #[derive(Clone, Hash, PartialEq, Eq, Debug, Copy)]\n-enum Node<'tcx> {\n+enum Node {\n     RegionVid(ty::RegionVid),\n-    Region(ty::RegionKind<'tcx>),\n+    Region(ty::RegionKind),\n }\n \n // type Edge = Constraint;\n #[derive(Clone, PartialEq, Eq, Debug, Copy)]\n enum Edge<'tcx> {\n     Constraint(Constraint<'tcx>),\n-    EnclScope(CodeExtent<'tcx>, CodeExtent<'tcx>),\n+    EnclScope(CodeExtent, CodeExtent),\n }\n \n impl<'a, 'gcx, 'tcx> ConstraintGraph<'a, 'gcx, 'tcx> {\n@@ -176,7 +176,7 @@ impl<'a, 'gcx, 'tcx> ConstraintGraph<'a, 'gcx, 'tcx> {\n }\n \n impl<'a, 'gcx, 'tcx> dot::Labeller<'a> for ConstraintGraph<'a, 'gcx, 'tcx> {\n-    type Node = Node<'tcx>;\n+    type Node = Node;\n     type Edge = Edge<'tcx>;\n     fn graph_id(&self) -> dot::Id {\n         dot::Id::new(&*self.graph_name).unwrap()\n@@ -209,7 +209,7 @@ impl<'a, 'gcx, 'tcx> dot::Labeller<'a> for ConstraintGraph<'a, 'gcx, 'tcx> {\n     }\n }\n \n-fn constraint_to_nodes<'tcx>(c: &Constraint<'tcx>) -> (Node<'tcx>, Node<'tcx>) {\n+fn constraint_to_nodes(c: &Constraint) -> (Node, Node) {\n     match *c {\n         Constraint::ConstrainVarSubVar(rv_1, rv_2) =>\n             (Node::RegionVid(rv_1), Node::RegionVid(rv_2)),\n@@ -222,7 +222,7 @@ fn constraint_to_nodes<'tcx>(c: &Constraint<'tcx>) -> (Node<'tcx>, Node<'tcx>) {\n     }\n }\n \n-fn edge_to_nodes<'tcx>(e: &Edge<'tcx>) -> (Node<'tcx>, Node<'tcx>) {\n+fn edge_to_nodes(e: &Edge) -> (Node, Node) {\n     match *e {\n         Edge::Constraint(ref c) => constraint_to_nodes(c),\n         Edge::EnclScope(sub, sup) => {\n@@ -233,9 +233,9 @@ fn edge_to_nodes<'tcx>(e: &Edge<'tcx>) -> (Node<'tcx>, Node<'tcx>) {\n }\n \n impl<'a, 'gcx, 'tcx> dot::GraphWalk<'a> for ConstraintGraph<'a, 'gcx, 'tcx> {\n-    type Node = Node<'tcx>;\n+    type Node = Node;\n     type Edge = Edge<'tcx>;\n-    fn nodes(&self) -> dot::Nodes<Node<'tcx>> {\n+    fn nodes(&self) -> dot::Nodes<Node> {\n         let mut set = FxHashSet();\n         for node in self.node_ids.keys() {\n             set.insert(*node);\n@@ -250,12 +250,12 @@ impl<'a, 'gcx, 'tcx> dot::GraphWalk<'a> for ConstraintGraph<'a, 'gcx, 'tcx> {\n         debug!(\"region graph has {} edges\", v.len());\n         Cow::Owned(v)\n     }\n-    fn source(&self, edge: &Edge<'tcx>) -> Node<'tcx> {\n+    fn source(&self, edge: &Edge<'tcx>) -> Node {\n         let (n1, _) = edge_to_nodes(edge);\n         debug!(\"edge {:?} has source {:?}\", edge, n1);\n         n1\n     }\n-    fn target(&self, edge: &Edge<'tcx>) -> Node<'tcx> {\n+    fn target(&self, edge: &Edge<'tcx>) -> Node {\n         let (_, n2) = edge_to_nodes(edge);\n         debug!(\"edge {:?} has target {:?}\", edge, n2);\n         n2"}, {"sha": "2e3c2443544f649601743c9174465d7d2a1e5a54", "filename": "src/librustc/infer/region_inference/mod.rs", "status": "modified", "additions": 42, "deletions": 32, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/826d8f3850b37a23481dfcf4a899b5dfc82d22e3/src%2Flibrustc%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/826d8f3850b37a23481dfcf4a899b5dfc82d22e3/src%2Flibrustc%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fregion_inference%2Fmod.rs?ref=826d8f3850b37a23481dfcf4a899b5dfc82d22e3", "patch": "@@ -29,7 +29,6 @@ use ty::{ReEmpty, ReStatic, ReFree, ReEarlyBound, ReErased};\n use ty::{ReLateBound, ReScope, ReVar, ReSkolemized, BrFresh};\n \n use std::cell::{Cell, RefCell};\n-use std::cmp::Ordering::{self, Less, Greater, Equal};\n use std::fmt;\n use std::mem;\n use std::u32;\n@@ -127,7 +126,7 @@ pub enum UndoLogEntry<'tcx> {\n     AddVerify(usize),\n \n     /// We added the given `given`\n-    AddGiven(ty::FreeRegion<'tcx>, ty::RegionVid),\n+    AddGiven(Region<'tcx>, ty::RegionVid),\n \n     /// We added a GLB/LUB \"combinaton variable\"\n     AddCombination(CombineMapType, TwoRegions<'tcx>),\n@@ -213,7 +212,7 @@ pub struct RegionVarBindings<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     // record the fact that `'a <= 'b` is implied by the fn signature,\n     // and then ignore the constraint when solving equations. This is\n     // a bit of a hack but seems to work.\n-    givens: RefCell<FxHashSet<(ty::FreeRegion<'tcx>, ty::RegionVid)>>,\n+    givens: RefCell<FxHashSet<(Region<'tcx>, ty::RegionVid)>>,\n \n     lubs: RefCell<CombineMap<'tcx>>,\n     glbs: RefCell<CombineMap<'tcx>>,\n@@ -309,8 +308,7 @@ impl<'a, 'gcx, 'tcx> TaintSet<'tcx> {\n                         self.add_edge(a, b);\n                     }\n                     &AddGiven(a, b) => {\n-                        self.add_edge(tcx.mk_region(ReFree(a)),\n-                                      tcx.mk_region(ReVar(b)));\n+                        self.add_edge(a, tcx.mk_region(ReVar(b)));\n                     }\n                     &AddVerify(i) => {\n                         verifys[i].bound.for_each_region(&mut |b| {\n@@ -661,7 +659,7 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    pub fn add_given(&self, sub: ty::FreeRegion<'tcx>, sup: ty::RegionVid) {\n+    pub fn add_given(&self, sub: Region<'tcx>, sup: ty::RegionVid) {\n         // cannot add givens once regions are resolved\n         assert!(self.values_are_none());\n \n@@ -702,9 +700,7 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n                origin);\n \n         match (sub, sup) {\n-            (&ReEarlyBound(..), _) |\n             (&ReLateBound(..), _) |\n-            (_, &ReEarlyBound(..)) |\n             (_, &ReLateBound(..)) => {\n                 span_bug!(origin.span(),\n                           \"cannot relate bound region: {:?} <= {:?}\",\n@@ -908,8 +904,6 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n         match (a, b) {\n             (&ReLateBound(..), _) |\n             (_, &ReLateBound(..)) |\n-            (&ReEarlyBound(..), _) |\n-            (_, &ReEarlyBound(..)) |\n             (&ReErased, _) |\n             (_, &ReErased) => {\n                 bug!(\"cannot relate region: LUB({:?}, {:?})\", a, b);\n@@ -931,18 +925,31 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n                           b);\n             }\n \n-            (&ReFree(fr), &ReScope(s_id)) |\n-            (&ReScope(s_id), &ReFree(fr)) => {\n+            (&ReEarlyBound(_), &ReScope(s_id)) |\n+            (&ReScope(s_id), &ReEarlyBound(_)) |\n+            (&ReFree(_), &ReScope(s_id)) |\n+            (&ReScope(s_id), &ReFree(_)) => {\n                 // A \"free\" region can be interpreted as \"some region\n-                // at least as big as the block fr.scope_id\".  So, we can\n+                // at least as big as fr.scope\".  So, we can\n                 // reasonably compare free regions and scopes:\n-                if let Some(fr_scope) = fr.scope {\n-                    let r_id = region_rels.region_maps.nearest_common_ancestor(fr_scope, s_id);\n-                    if r_id == fr_scope {\n-                        // if the free region's scope `fr.scope_id` is bigger than\n-                        // the scope region `s_id`, then the LUB is the free\n-                        // region itself:\n-                        return self.tcx.mk_region(ReFree(fr));\n+                let fr_scope = match (a, b) {\n+                    (&ReEarlyBound(ref br), _) | (_, &ReEarlyBound(ref br)) => {\n+                        region_rels.region_maps.early_free_extent(self.tcx, br)\n+                    }\n+                    (&ReFree(ref fr), _) | (_, &ReFree(ref fr)) => {\n+                        region_rels.region_maps.free_extent(self.tcx, fr)\n+                    }\n+                    _ => bug!()\n+                };\n+                let r_id = region_rels.region_maps.nearest_common_ancestor(fr_scope, s_id);\n+                if r_id == fr_scope {\n+                    // if the free region's scope `fr.scope` is bigger than\n+                    // the scope region `s_id`, then the LUB is the free\n+                    // region itself:\n+                    match (a, b) {\n+                        (_, &ReScope(_)) => return a,\n+                        (&ReScope(_), _) => return b,\n+                        _ => bug!()\n                     }\n                 }\n \n@@ -959,6 +966,9 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n                 self.tcx.mk_region(ReScope(lub))\n             }\n \n+            (&ReEarlyBound(_), &ReEarlyBound(_)) |\n+            (&ReFree(_), &ReEarlyBound(_)) |\n+            (&ReEarlyBound(_), &ReFree(_)) |\n             (&ReFree(_), &ReFree(_)) => {\n                 region_rels.lub_free_regions(a, b)\n             }\n@@ -1041,13 +1051,13 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n \n         let mut givens = self.givens.borrow_mut();\n         let seeds: Vec<_> = givens.iter().cloned().collect();\n-        for (fr, vid) in seeds {\n+        for (r, vid) in seeds {\n             let seed_index = NodeIndex(vid.index as usize);\n             for succ_index in graph.depth_traverse(seed_index, OUTGOING) {\n                 let succ_index = succ_index.0 as u32;\n                 if succ_index < self.num_vars() {\n                     let succ_vid = RegionVid { index: succ_index };\n-                    givens.insert((fr, succ_vid));\n+                    givens.insert((r, succ_vid));\n                 }\n             }\n         }\n@@ -1096,8 +1106,9 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n \n         // Check if this relationship is implied by a given.\n         match *a_region {\n-            ty::ReFree(fr) => {\n-                if self.givens.borrow().contains(&(fr, b_vid)) {\n+            ty::ReEarlyBound(_) |\n+            ty::ReFree(_) => {\n+                if self.givens.borrow().contains(&(a_region, b_vid)) {\n                     debug!(\"given\");\n                     return false;\n                 }\n@@ -1333,16 +1344,15 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n         // We place free regions first because we are special casing\n         // SubSupConflict(ReFree, ReFree) when reporting error, and so\n         // the user will more likely get a specific suggestion.\n-        fn free_regions_first(a: &RegionAndOrigin, b: &RegionAndOrigin) -> Ordering {\n-            match (a.region, b.region) {\n-                (&ReFree(..), &ReFree(..)) => Equal,\n-                (&ReFree(..), _) => Less,\n-                (_, &ReFree(..)) => Greater,\n-                (..) => Equal,\n+        fn region_order_key(x: &RegionAndOrigin) -> u8 {\n+            match *x.region {\n+                ReEarlyBound(_) => 0,\n+                ReFree(_) => 1,\n+                _ => 2\n             }\n         }\n-        lower_bounds.sort_by(|a, b| free_regions_first(a, b));\n-        upper_bounds.sort_by(|a, b| free_regions_first(a, b));\n+        lower_bounds.sort_by_key(region_order_key);\n+        upper_bounds.sort_by_key(region_order_key);\n \n         for lower_bound in &lower_bounds {\n             for upper_bound in &upper_bounds {"}, {"sha": "99b140f690a4848cda6ee003634a45f7cb321ed9", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/826d8f3850b37a23481dfcf4a899b5dfc82d22e3/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/826d8f3850b37a23481dfcf4a899b5dfc82d22e3/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=826d8f3850b37a23481dfcf4a899b5dfc82d22e3", "patch": "@@ -271,7 +271,7 @@ enum PassArgs {\n \n impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n     pub fn new(delegate: &'a mut (Delegate<'tcx>+'a),\n-               region_maps: &'a RegionMaps<'tcx>,\n+               region_maps: &'a RegionMaps,\n                infcx: &'a InferCtxt<'a, 'gcx, 'tcx>)\n                -> Self\n     {\n@@ -283,7 +283,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n \n     pub fn with_options(delegate: &'a mut (Delegate<'tcx>+'a),\n                         infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n-                        region_maps: &'a RegionMaps<'tcx>,\n+                        region_maps: &'a RegionMaps,\n                         options: mc::MemCategorizationOptions)\n                -> Self\n     {"}, {"sha": "6a21bdc19e0915b2ade6bf1ebb69e59a0e9a8d92", "filename": "src/librustc/middle/free_region.rs", "status": "modified", "additions": 33, "deletions": 41, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/826d8f3850b37a23481dfcf4a899b5dfc82d22e3/src%2Flibrustc%2Fmiddle%2Ffree_region.rs", "raw_url": "https://github.com/rust-lang/rust/raw/826d8f3850b37a23481dfcf4a899b5dfc82d22e3/src%2Flibrustc%2Fmiddle%2Ffree_region.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ffree_region.rs?ref=826d8f3850b37a23481dfcf4a899b5dfc82d22e3", "patch": "@@ -35,7 +35,7 @@ pub struct RegionRelations<'a, 'gcx: 'tcx, 'tcx: 'a> {\n     pub context: DefId,\n \n     /// region maps for the given context\n-    pub region_maps: &'a RegionMaps<'tcx>,\n+    pub region_maps: &'a RegionMaps,\n \n     /// free-region relationships\n     pub free_regions: &'a FreeRegionMap<'tcx>,\n@@ -45,7 +45,7 @@ impl<'a, 'gcx, 'tcx> RegionRelations<'a, 'gcx, 'tcx> {\n     pub fn new(\n         tcx: TyCtxt<'a, 'gcx, 'tcx>,\n         context: DefId,\n-        region_maps: &'a RegionMaps<'tcx>,\n+        region_maps: &'a RegionMaps,\n         free_regions: &'a FreeRegionMap<'tcx>,\n     ) -> Self {\n         Self {\n@@ -71,26 +71,27 @@ impl<'a, 'gcx, 'tcx> RegionRelations<'a, 'gcx, 'tcx> {\n                 (&ty::ReScope(sub_scope), &ty::ReScope(super_scope)) =>\n                     self.region_maps.is_subscope_of(sub_scope, super_scope),\n \n-                (&ty::ReScope(sub_scope), &ty::ReFree(fr)) => {\n-                    // 1. It is safe to unwrap `fr.scope` because we\n-                    // should only ever wind up comparing against\n-                    // `ReScope` in the context of a method or\n-                    // body, where `fr.scope` should be `Some`.\n-                    self.region_maps.is_subscope_of(sub_scope, fr.scope.unwrap() /*1*/) ||\n-                        self.is_static(super_region)\n+                (&ty::ReScope(sub_scope), &ty::ReEarlyBound(ref br)) => {\n+                    let fr_scope = self.region_maps.early_free_extent(self.tcx, br);\n+                    self.region_maps.is_subscope_of(sub_scope, fr_scope)\n                 }\n \n-                (&ty::ReFree(_), &ty::ReFree(_)) =>\n-                    self.free_regions.relation.contains(&sub_region, &super_region) ||\n-                        self.is_static(super_region),\n+                (&ty::ReScope(sub_scope), &ty::ReFree(ref fr)) => {\n+                    let fr_scope = self.region_maps.free_extent(self.tcx, fr);\n+                    self.region_maps.is_subscope_of(sub_scope, fr_scope)\n+                }\n \n-                (&ty::ReStatic, &ty::ReFree(_)) =>\n-                    self.is_static(super_region),\n+                (&ty::ReEarlyBound(_), &ty::ReEarlyBound(_)) |\n+                (&ty::ReFree(_), &ty::ReEarlyBound(_)) |\n+                (&ty::ReEarlyBound(_), &ty::ReFree(_)) |\n+                (&ty::ReFree(_), &ty::ReFree(_)) =>\n+                    self.free_regions.relation.contains(&sub_region, &super_region),\n \n                 _ =>\n                     false,\n             }\n         };\n+        let result = result || self.is_static(super_region);\n         debug!(\"is_subregion_of(sub_region={:?}, super_region={:?}) = {:?}\",\n                sub_region, super_region, result);\n         result\n@@ -101,11 +102,11 @@ impl<'a, 'gcx, 'tcx> RegionRelations<'a, 'gcx, 'tcx> {\n         debug!(\"is_static(super_region={:?})\", super_region);\n         match *super_region {\n             ty::ReStatic => true,\n-            ty::ReFree(_) => {\n+            ty::ReEarlyBound(_) | ty::ReFree(_) => {\n                 let re_static = self.tcx.mk_region(ty::ReStatic);\n                 self.free_regions.relation.contains(&re_static, &super_region)\n             }\n-            _ => bug!(\"only free regions should be given to `is_static`\")\n+            _ => false\n         }\n     }\n \n@@ -142,11 +143,9 @@ impl<'tcx> FreeRegionMap<'tcx> {\n         for implied_bound in implied_bounds {\n             debug!(\"implied bound: {:?}\", implied_bound);\n             match *implied_bound {\n-                ImpliedBound::RegionSubRegion(a @ &ty::ReFree(_), b @ &ty::ReFree(_)) |\n-                ImpliedBound::RegionSubRegion(a @ &ty::ReStatic, b @ &ty::ReFree(_)) => {\n+                ImpliedBound::RegionSubRegion(a, b) => {\n                     self.relate_regions(a, b);\n                 }\n-                ImpliedBound::RegionSubRegion(..) |\n                 ImpliedBound::RegionSubParam(..) |\n                 ImpliedBound::RegionSubProjection(..) => {\n                 }\n@@ -170,41 +169,27 @@ impl<'tcx> FreeRegionMap<'tcx> {\n                     // No region bounds here\n                 }\n                 ty::Predicate::RegionOutlives(ty::Binder(ty::OutlivesPredicate(r_a, r_b))) => {\n-                    match (r_a, r_b) {\n-                        // `'static: 'x` is not notable\n-                        (&ty::ReStatic, &ty::ReFree(_)) => {},\n-\n-                        (&ty::ReFree(_), &ty::ReStatic) |\n-                        (&ty::ReFree(_), &ty::ReFree(_)) => {\n-                            // Record that `'a:'b`. Or, put another way, `'b <= 'a`.\n-                            self.relate_regions(r_b, r_a);\n-                        }\n-\n-                        _ => {\n-                            // All named regions are instantiated with free regions.\n-                            bug!(\"record_region_bounds: non free region: {:?} / {:?}\",\n-                                 r_a,\n-                                 r_b);\n-                        }\n-                    }\n+                    self.relate_regions(r_b, r_a);\n                 }\n             }\n         }\n     }\n \n+    // Record that `'sup:'sub`. Or, put another way, `'sub <= 'sup`.\n+    // (with the exception that `'static: 'x` is not notable)\n     fn relate_regions(&mut self, sub: Region<'tcx>, sup: Region<'tcx>) {\n-        assert!(match *sub { ty::ReFree(_) | ty::ReStatic => true, _ => false });\n-        assert!(match *sup { ty::ReFree(_) | ty::ReStatic => true, _ => false });\n-        self.relation.add(sub, sup)\n+        if (is_free(sub) || *sub == ty::ReStatic) && is_free(sup) {\n+            self.relation.add(sub, sup)\n+        }\n     }\n \n     pub fn lub_free_regions<'a, 'gcx>(&self,\n                                       tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                                       r_a: Region<'tcx>,\n                                       r_b: Region<'tcx>)\n                                       -> Region<'tcx> {\n-        assert!(match *r_a { ty::ReFree(_) => true, _ => false });\n-        assert!(match *r_b { ty::ReFree(_) => true, _ => false });\n+        assert!(is_free(r_a));\n+        assert!(is_free(r_b));\n         let result = if r_a == r_b { r_a } else {\n             match self.relation.postdom_upper_bound(&r_a, &r_b) {\n                 None => tcx.mk_region(ty::ReStatic),\n@@ -216,6 +201,13 @@ impl<'tcx> FreeRegionMap<'tcx> {\n     }\n }\n \n+fn is_free(r: Region) -> bool {\n+    match *r {\n+        ty::ReEarlyBound(_) | ty::ReFree(_) => true,\n+        _ => false\n+    }\n+}\n+\n impl_stable_hash_for!(struct FreeRegionMap<'tcx> {\n     relation\n });"}, {"sha": "ecd350d12736897799a3a78d6cfbbf01274db79a", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 2, "deletions": 51, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/826d8f3850b37a23481dfcf4a899b5dfc82d22e3/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/826d8f3850b37a23481dfcf4a899b5dfc82d22e3/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=826d8f3850b37a23481dfcf4a899b5dfc82d22e3", "patch": "@@ -96,9 +96,6 @@\n //!\n //! - `fallthrough_ln`: a live node that represents a fallthrough\n //!\n-//! - `no_ret_var`: a synthetic variable that is only 'read' from, the\n-//!   fallthrough node.  This allows us to detect functions where we fail\n-//!   to return explicitly.\n //! - `clean_exit_var`: a synthetic variable that is only 'read' from the\n //!   fallthrough node.  It is only live if the function could converge\n //!   via means other than an explicit `return` expression. That is, it is\n@@ -110,9 +107,7 @@ use self::LiveNodeKind::*;\n use self::VarKind::*;\n \n use hir::def::*;\n-use ty::{self, TyCtxt, ParameterEnvironment};\n-use traits::{self, Reveal};\n-use ty::subst::Subst;\n+use ty::{self, TyCtxt};\n use lint;\n use util::nodemap::NodeMap;\n \n@@ -256,7 +251,6 @@ struct LocalInfo {\n enum VarKind {\n     Arg(NodeId, ast::Name),\n     Local(LocalInfo),\n-    ImplicitRet,\n     CleanExit\n }\n \n@@ -313,7 +307,7 @@ impl<'a, 'tcx> IrMaps<'a, 'tcx> {\n             Local(LocalInfo { id: node_id, .. }) | Arg(node_id, _) => {\n                 self.variable_map.insert(node_id, v);\n             },\n-            ImplicitRet | CleanExit => {}\n+            CleanExit => {}\n         }\n \n         debug!(\"{:?} is {:?}\", v, vk);\n@@ -335,7 +329,6 @@ impl<'a, 'tcx> IrMaps<'a, 'tcx> {\n             Local(LocalInfo { name, .. }) | Arg(_, name) => {\n                 name.to_string()\n             },\n-            ImplicitRet => \"<implicit-ret>\".to_string(),\n             CleanExit => \"<clean-exit>\".to_string()\n         }\n     }\n@@ -382,7 +375,6 @@ fn visit_fn<'a, 'tcx: 'a>(ir: &mut IrMaps<'a, 'tcx>,\n \n     // check for various error conditions\n     lsets.visit_body(body);\n-    lsets.check_ret(id, sp, entry_ln, body);\n     lsets.warn_about_unused_args(body, entry_ln);\n }\n \n@@ -500,7 +492,6 @@ fn invalid_users() -> Users {\n struct Specials {\n     exit_ln: LiveNode,\n     fallthrough_ln: LiveNode,\n-    no_ret_var: Variable,\n     clean_exit_var: Variable\n }\n \n@@ -534,7 +525,6 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         let specials = Specials {\n             exit_ln: ir.add_live_node(ExitNode),\n             fallthrough_ln: ir.add_live_node(ExitNode),\n-            no_ret_var: ir.add_variable(ImplicitRet),\n             clean_exit_var: ir.add_variable(CleanExit)\n         };\n \n@@ -1420,45 +1410,6 @@ fn check_expr<'a, 'tcx>(this: &mut Liveness<'a, 'tcx>, expr: &'tcx Expr) {\n }\n \n impl<'a, 'tcx> Liveness<'a, 'tcx> {\n-    fn check_ret(&self,\n-                 id: NodeId,\n-                 sp: Span,\n-                 entry_ln: LiveNode,\n-                 body: &hir::Body)\n-    {\n-        let fn_ty = self.ir.tcx.type_of(self.ir.tcx.hir.local_def_id(id));\n-        let fn_sig = match fn_ty.sty {\n-            ty::TyClosure(closure_def_id, substs) => {\n-                self.ir.tcx.closure_type(closure_def_id)\n-                    .subst(self.ir.tcx, substs.substs)\n-            }\n-            _ => fn_ty.fn_sig()\n-        };\n-\n-        let fn_ret = fn_sig.output();\n-\n-        // within the fn body, late-bound regions are liberated\n-        // and must outlive the *call-site* of the function.\n-        let fn_ret =\n-            self.ir.tcx.liberate_late_bound_regions(\n-                Some(self.ir.tcx.call_site_extent(id, body.value.id)),\n-                &fn_ret);\n-\n-        if !fn_ret.is_never() && self.live_on_entry(entry_ln, self.s.no_ret_var).is_some() {\n-            let param_env = ParameterEnvironment::for_item(self.ir.tcx, id);\n-            let t_ret_subst = fn_ret.subst(self.ir.tcx, &param_env.free_substs);\n-            let is_nil = self.ir.tcx.infer_ctxt(param_env, Reveal::All).enter(|infcx| {\n-                let cause = traits::ObligationCause::dummy();\n-                traits::fully_normalize(&infcx, cause, &t_ret_subst).unwrap().is_nil()\n-            });\n-\n-            // for nil return types, it is ok to not return a value expl.\n-            if !is_nil {\n-                span_bug!(sp, \"not all control paths return a value\");\n-            }\n-        }\n-    }\n-\n     fn check_lvalue(&mut self, expr: &'tcx Expr) {\n         match expr.node {\n             hir::ExprPath(hir::QPath::Resolved(_, ref path)) => {"}, {"sha": "d0adf51d79e68675a59672003c9c96b4d31a54f6", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 5, "deletions": 19, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/826d8f3850b37a23481dfcf4a899b5dfc82d22e3/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/826d8f3850b37a23481dfcf4a899b5dfc82d22e3/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=826d8f3850b37a23481dfcf4a899b5dfc82d22e3", "patch": "@@ -290,7 +290,7 @@ impl ast_node for hir::Pat {\n #[derive(Clone)]\n pub struct MemCategorizationContext<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     pub infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n-    pub region_maps: &'a RegionMaps<'tcx>,\n+    pub region_maps: &'a RegionMaps,\n     options: MemCategorizationOptions,\n }\n \n@@ -406,15 +406,15 @@ impl MutabilityCategory {\n impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n     /// Context should be the `DefId` we use to fetch region-maps.\n     pub fn new(infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n-               region_maps: &'a RegionMaps<'tcx>)\n+               region_maps: &'a RegionMaps)\n                -> MemCategorizationContext<'a, 'gcx, 'tcx> {\n         MemCategorizationContext::with_options(infcx,\n                                                region_maps,\n                                                MemCategorizationOptions::default())\n     }\n \n     pub fn with_options(infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n-                        region_maps: &'a RegionMaps<'tcx>,\n+                        region_maps: &'a RegionMaps,\n                         options: MemCategorizationOptions)\n                         -> MemCategorizationContext<'a, 'gcx, 'tcx> {\n         MemCategorizationContext {\n@@ -785,26 +785,12 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n                  cmt_result: cmt_<'tcx>)\n                  -> cmt_<'tcx>\n     {\n-        // Look up the node ID of the closure body so we can construct\n-        // a free region within it\n-        let fn_body_id = {\n-            let fn_expr = match self.tcx().hir.find(upvar_id.closure_expr_id) {\n-                Some(hir_map::NodeExpr(e)) => e,\n-                _ => bug!()\n-            };\n-\n-            match fn_expr.node {\n-                hir::ExprClosure(.., body_id, _) => body_id,\n-                _ => bug!()\n-            }\n-        };\n-\n         // Region of environment pointer\n         let env_region = self.tcx().mk_region(ty::ReFree(ty::FreeRegion {\n             // The environment of a closure is guaranteed to\n             // outlive any bindings introduced in the body of the\n             // closure itself.\n-            scope: Some(self.tcx().item_extent(fn_body_id.node_id)),\n+            scope: self.tcx().hir.local_def_id(upvar_id.closure_expr_id),\n             bound_region: ty::BrEnv\n         }));\n \n@@ -853,7 +839,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n     pub fn temporary_scope(&self, id: ast::NodeId) -> (ty::Region<'tcx>, ty::Region<'tcx>)\n     {\n         let (scope, old_scope) =\n-            self.region_maps.old_and_new_temporary_scope(self.tcx(), id);\n+            self.region_maps.old_and_new_temporary_scope(id);\n         (self.tcx().mk_region(match scope {\n             Some(scope) => ty::ReScope(scope),\n             None => ty::ReStatic"}, {"sha": "2d632e3feb5457de6b463f62e84160cb362f19ce", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 169, "deletions": 159, "changes": 328, "blob_url": "https://github.com/rust-lang/rust/blob/826d8f3850b37a23481dfcf4a899b5dfc82d22e3/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/826d8f3850b37a23481dfcf4a899b5dfc82d22e3/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=826d8f3850b37a23481dfcf4a899b5dfc82d22e3", "patch": "@@ -22,7 +22,6 @@ use ty;\n \n use std::mem;\n use std::rc::Rc;\n-use serialize;\n use syntax::codemap;\n use syntax::ast;\n use syntax_pos::Span;\n@@ -35,11 +34,6 @@ use hir::intravisit::{self, Visitor, NestedVisitorMap};\n use hir::{Block, Arm, Pat, PatKind, Stmt, Expr, Local};\n use mir::transform::MirSource;\n \n-pub type CodeExtent<'tcx> = &'tcx CodeExtentData;\n-\n-impl<'tcx> serialize::UseSpecializedEncodable for CodeExtent<'tcx> {}\n-impl<'tcx> serialize::UseSpecializedDecodable for CodeExtent<'tcx> {}\n-\n /// CodeExtent represents a statically-describable extent that can be\n /// used to bound the lifetime/region for values.\n ///\n@@ -102,16 +96,16 @@ impl<'tcx> serialize::UseSpecializedDecodable for CodeExtent<'tcx> {}\n /// actually attach a more meaningful ordering to scopes than the one\n /// generated via deriving here.\n #[derive(Clone, PartialEq, PartialOrd, Eq, Ord, Hash, Debug, Copy, RustcEncodable, RustcDecodable)]\n-pub enum CodeExtentData {\n+pub enum CodeExtent {\n     Misc(ast::NodeId),\n \n     // extent of the call-site for a function or closure (outlives\n     // the parameters as well as the body).\n-    CallSiteScope { fn_id: ast::NodeId, body_id: ast::NodeId },\n+    CallSiteScope(hir::BodyId),\n \n     // extent of parameters passed to a function or closure (they\n     // outlive its body)\n-    ParameterScope { fn_id: ast::NodeId, body_id: ast::NodeId },\n+    ParameterScope(hir::BodyId),\n \n     // extent of destructors for temporaries of node-id\n     DestructionScope(ast::NodeId),\n@@ -120,23 +114,6 @@ pub enum CodeExtentData {\n     Remainder(BlockRemainder)\n }\n \n-/// extent of call-site for a function/method.\n-#[derive(Clone, PartialEq, PartialOrd, Eq, Ord, Hash, RustcEncodable,\n-           RustcDecodable, Debug, Copy)]\n-pub struct CallSiteScopeData {\n-    pub fn_id: ast::NodeId, pub body_id: ast::NodeId,\n-}\n-\n-impl CallSiteScopeData {\n-    pub fn to_code_extent<'a, 'tcx, 'gcx>(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> CodeExtent<'tcx> {\n-        tcx.intern_code_extent(\n-            match *self {\n-                CallSiteScopeData { fn_id, body_id } =>\n-                    CodeExtentData::CallSiteScope { fn_id: fn_id, body_id: body_id },\n-            })\n-    }\n-}\n-\n /// Represents a subscope of `block` for a binding that is introduced\n /// by `block.stmts[first_statement_index]`. Such subscopes represent\n /// a suffix of the block. Note that each subscope does not include\n@@ -148,9 +125,9 @@ impl CallSiteScopeData {\n /// * the subscope with `first_statement_index == 0` is scope of both\n ///   `a` and `b`; it does not include EXPR_1, but does include\n ///   everything after that first `let`. (If you want a scope that\n-///   includes EXPR_1 as well, then do not use `CodeExtentData::Remainder`,\n+///   includes EXPR_1 as well, then do not use `CodeExtent::Remainder`,\n ///   but instead another `CodeExtent` that encompasses the whole block,\n-///   e.g. `CodeExtentData::Misc`.\n+///   e.g. `CodeExtent::Misc`.\n ///\n /// * the subscope with `first_statement_index == 1` is scope of `c`,\n ///   and thus does not include EXPR_2, but covers the `...`.\n@@ -161,21 +138,21 @@ pub struct BlockRemainder {\n     pub first_statement_index: u32,\n }\n \n-impl CodeExtentData {\n+impl CodeExtent {\n     /// Returns a node id associated with this scope.\n     ///\n     /// NB: likely to be replaced as API is refined; e.g. pnkfelix\n     /// anticipates `fn entry_node_id` and `fn each_exit_node_id`.\n     pub fn node_id(&self) -> ast::NodeId {\n         match *self {\n-            CodeExtentData::Misc(node_id) => node_id,\n+            CodeExtent::Misc(node_id) => node_id,\n \n             // These cases all return rough approximations to the\n             // precise extent denoted by `self`.\n-            CodeExtentData::Remainder(br) => br.block,\n-            CodeExtentData::DestructionScope(node_id) => node_id,\n-            CodeExtentData::CallSiteScope { fn_id: _, body_id } |\n-            CodeExtentData::ParameterScope { fn_id: _, body_id } => body_id,\n+            CodeExtent::Remainder(br) => br.block,\n+            CodeExtent::DestructionScope(node_id) => node_id,\n+            CodeExtent::CallSiteScope(body_id) |\n+            CodeExtent::ParameterScope(body_id) => body_id.node_id,\n         }\n     }\n \n@@ -186,12 +163,12 @@ impl CodeExtentData {\n         match hir_map.find(self.node_id()) {\n             Some(hir_map::NodeBlock(ref blk)) => {\n                 match *self {\n-                    CodeExtentData::CallSiteScope { .. } |\n-                    CodeExtentData::ParameterScope { .. } |\n-                    CodeExtentData::Misc(_) |\n-                    CodeExtentData::DestructionScope(_) => Some(blk.span),\n+                    CodeExtent::CallSiteScope(_) |\n+                    CodeExtent::ParameterScope(_) |\n+                    CodeExtent::Misc(_) |\n+                    CodeExtent::DestructionScope(_) => Some(blk.span),\n \n-                    CodeExtentData::Remainder(r) => {\n+                    CodeExtent::Remainder(r) => {\n                         assert_eq!(r.block, blk.id);\n                         // Want span for extent starting after the\n                         // indexed statement and ending at end of\n@@ -214,36 +191,44 @@ impl CodeExtentData {\n }\n \n /// The region maps encode information about region relationships.\n-pub struct RegionMaps<'tcx> {\n+pub struct RegionMaps {\n+    /// If not empty, this body is the root of this region hierarchy.\n+    root_body: Option<hir::BodyId>,\n+\n+    /// The parent of the root body owner, if the latter is an\n+    /// an associated const or method, as impls/traits can also\n+    /// have lifetime parameters free in this body.\n+    root_parent: Option<ast::NodeId>,\n+\n     /// `scope_map` maps from a scope id to the enclosing scope id;\n     /// this is usually corresponding to the lexical nesting, though\n     /// in the case of closures the parent scope is the innermost\n     /// conditional expression or repeating block. (Note that the\n     /// enclosing scope id for the block associated with a closure is\n     /// the closure itself.)\n-    scope_map: FxHashMap<CodeExtent<'tcx>, CodeExtent<'tcx>>,\n+    scope_map: FxHashMap<CodeExtent, CodeExtent>,\n \n     /// `var_map` maps from a variable or binding id to the block in\n     /// which that variable is declared.\n-    var_map: NodeMap<CodeExtent<'tcx>>,\n+    var_map: NodeMap<CodeExtent>,\n \n     /// maps from a node-id to the associated destruction scope (if any)\n-    destruction_scopes: NodeMap<CodeExtent<'tcx>>,\n+    destruction_scopes: NodeMap<CodeExtent>,\n \n     /// `rvalue_scopes` includes entries for those expressions whose cleanup scope is\n     /// larger than the default. The map goes from the expression id\n     /// to the cleanup scope id. For rvalues not present in this\n     /// table, the appropriate cleanup scope is the innermost\n     /// enclosing statement, conditional expression, or repeating\n     /// block (see `terminating_scopes`).\n-    rvalue_scopes: NodeMap<CodeExtent<'tcx>>,\n+    rvalue_scopes: NodeMap<CodeExtent>,\n \n     /// Records the value of rvalue scopes before they were shrunk by\n     /// #36082, for error reporting.\n     ///\n     /// FIXME: this should be temporary. Remove this by 1.18.0 or\n     /// so.\n-    shrunk_rvalue_scopes: NodeMap<CodeExtent<'tcx>>,\n+    shrunk_rvalue_scopes: NodeMap<CodeExtent>,\n \n     /// Encodes the hierarchy of fn bodies. Every fn body (including\n     /// closures) forms its own distinct region hierarchy, rooted in\n@@ -259,7 +244,7 @@ pub struct RegionMaps<'tcx> {\n }\n \n #[derive(Debug, Copy, Clone)]\n-pub struct Context<'tcx> {\n+pub struct Context {\n     /// the root of the current region tree. This is typically the id\n     /// of the innermost fn body. Each fn forms its own disjoint tree\n     /// in the region hierarchy. These fn bodies are themselves\n@@ -269,21 +254,19 @@ pub struct Context<'tcx> {\n     root_id: Option<ast::NodeId>,\n \n     /// the scope that contains any new variables declared\n-    var_parent: Option<CodeExtent<'tcx>>,\n+    var_parent: Option<CodeExtent>,\n \n     /// region parent of expressions etc\n-    parent: Option<CodeExtent<'tcx>>,\n+    parent: Option<CodeExtent>,\n }\n \n struct RegionResolutionVisitor<'a, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     // Generated maps:\n-    region_maps: &'a mut RegionMaps<'tcx>,\n-\n-    cx: Context<'tcx>,\n+    region_maps: RegionMaps,\n \n-    map: &'a hir_map::Map<'tcx>,\n+    cx: Context,\n \n     /// `terminating_scopes` is a set containing the ids of each\n     /// statement, or conditional/repeating expression. These scopes\n@@ -309,9 +292,11 @@ struct RegionResolutionVisitor<'a, 'tcx: 'a> {\n }\n \n \n-impl<'tcx> RegionMaps<'tcx> {\n+impl<'tcx> RegionMaps {\n     pub fn new() -> Self {\n         RegionMaps {\n+            root_body: None,\n+            root_parent: None,\n             scope_map: FxHashMap(),\n             destruction_scopes: FxHashMap(),\n             var_map: NodeMap(),\n@@ -322,8 +307,8 @@ impl<'tcx> RegionMaps<'tcx> {\n     }\n \n     pub fn record_code_extent(&mut self,\n-                              child: CodeExtent<'tcx>,\n-                              parent: Option<CodeExtent<'tcx>>) {\n+                              child: CodeExtent,\n+                              parent: Option<CodeExtent>) {\n         debug!(\"{:?}.parent = {:?}\", child, parent);\n \n         if let Some(p) = parent {\n@@ -332,24 +317,24 @@ impl<'tcx> RegionMaps<'tcx> {\n         }\n \n         // record the destruction scopes for later so we can query them\n-        if let &CodeExtentData::DestructionScope(n) = child {\n+        if let CodeExtent::DestructionScope(n) = child {\n             self.destruction_scopes.insert(n, child);\n         }\n     }\n \n-    pub fn each_encl_scope<E>(&self, mut e:E) where E: FnMut(CodeExtent<'tcx>, CodeExtent<'tcx>) {\n+    pub fn each_encl_scope<E>(&self, mut e:E) where E: FnMut(CodeExtent, CodeExtent) {\n         for (&child, &parent) in &self.scope_map {\n             e(child, parent)\n         }\n     }\n \n-    pub fn each_var_scope<E>(&self, mut e:E) where E: FnMut(&ast::NodeId, CodeExtent<'tcx>) {\n-        for (child, parent) in self.var_map.iter() {\n+    pub fn each_var_scope<E>(&self, mut e:E) where E: FnMut(&ast::NodeId, CodeExtent) {\n+        for (child, &parent) in self.var_map.iter() {\n             e(child, parent)\n         }\n     }\n \n-    pub fn opt_destruction_extent(&self, n: ast::NodeId) -> Option<CodeExtent<'tcx>> {\n+    pub fn opt_destruction_extent(&self, n: ast::NodeId) -> Option<CodeExtent> {\n         self.destruction_scopes.get(&n).cloned()\n     }\n \n@@ -373,48 +358,46 @@ impl<'tcx> RegionMaps<'tcx> {\n         }\n     }\n \n-    fn record_var_scope(&mut self, var: ast::NodeId, lifetime: CodeExtent<'tcx>) {\n+    fn record_var_scope(&mut self, var: ast::NodeId, lifetime: CodeExtent) {\n         debug!(\"record_var_scope(sub={:?}, sup={:?})\", var, lifetime);\n         assert!(var != lifetime.node_id());\n         self.var_map.insert(var, lifetime);\n     }\n \n-    fn record_rvalue_scope(&mut self, var: ast::NodeId, lifetime: CodeExtent<'tcx>) {\n+    fn record_rvalue_scope(&mut self, var: ast::NodeId, lifetime: CodeExtent) {\n         debug!(\"record_rvalue_scope(sub={:?}, sup={:?})\", var, lifetime);\n         assert!(var != lifetime.node_id());\n         self.rvalue_scopes.insert(var, lifetime);\n     }\n \n-    fn record_shrunk_rvalue_scope(&mut self, var: ast::NodeId, lifetime: CodeExtent<'tcx>) {\n+    fn record_shrunk_rvalue_scope(&mut self, var: ast::NodeId, lifetime: CodeExtent) {\n         debug!(\"record_rvalue_scope(sub={:?}, sup={:?})\", var, lifetime);\n         assert!(var != lifetime.node_id());\n         self.shrunk_rvalue_scopes.insert(var, lifetime);\n     }\n \n-    pub fn opt_encl_scope(&self, id: CodeExtent<'tcx>) -> Option<CodeExtent<'tcx>> {\n+    pub fn opt_encl_scope(&self, id: CodeExtent) -> Option<CodeExtent> {\n         //! Returns the narrowest scope that encloses `id`, if any.\n         self.scope_map.get(&id).cloned()\n     }\n \n     #[allow(dead_code)] // used in cfg\n-    pub fn encl_scope(&self, id: CodeExtent<'tcx>) -> CodeExtent<'tcx> {\n+    pub fn encl_scope(&self, id: CodeExtent) -> CodeExtent {\n         //! Returns the narrowest scope that encloses `id`, if any.\n         self.opt_encl_scope(id).unwrap()\n     }\n \n     /// Returns the lifetime of the local variable `var_id`\n-    pub fn var_scope(&self, var_id: ast::NodeId) -> CodeExtent<'tcx> {\n+    pub fn var_scope(&self, var_id: ast::NodeId) -> CodeExtent {\n         match self.var_map.get(&var_id) {\n             Some(&r) => r,\n             None => { bug!(\"no enclosing scope for id {:?}\", var_id); }\n         }\n     }\n \n-    pub fn temporary_scope2<'a, 'gcx: 'tcx>(&self,\n-                                            tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                                            expr_id: ast::NodeId)\n-                                            -> (Option<CodeExtent<'tcx>>, bool) {\n-        let temporary_scope = self.temporary_scope(tcx, expr_id);\n+    pub fn temporary_scope2(&self, expr_id: ast::NodeId)\n+                            -> (Option<CodeExtent>, bool) {\n+        let temporary_scope = self.temporary_scope(expr_id);\n         let was_shrunk = match self.shrunk_rvalue_scopes.get(&expr_id) {\n             Some(&s) => {\n                 info!(\"temporary_scope2({:?}, scope={:?}, shrunk={:?})\",\n@@ -427,23 +410,18 @@ impl<'tcx> RegionMaps<'tcx> {\n         (temporary_scope, was_shrunk)\n     }\n \n-    pub fn old_and_new_temporary_scope<'a, 'gcx: 'tcx>(&self,\n-                                                       tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                                                       expr_id: ast::NodeId)\n-                                                       -> (Option<CodeExtent<'tcx>>,\n-                                                           Option<CodeExtent<'tcx>>)\n+    pub fn old_and_new_temporary_scope(&self, expr_id: ast::NodeId)\n+                                       -> (Option<CodeExtent>,\n+                                           Option<CodeExtent>)\n     {\n-        let temporary_scope = self.temporary_scope(tcx, expr_id);\n+        let temporary_scope = self.temporary_scope(expr_id);\n         (temporary_scope,\n          self.shrunk_rvalue_scopes\n              .get(&expr_id).cloned()\n              .or(temporary_scope))\n     }\n \n-    pub fn temporary_scope<'a, 'gcx: 'tcx>(&self,\n-                                           tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                                           expr_id: ast::NodeId)\n-                                           -> Option<CodeExtent<'tcx>> {\n+    pub fn temporary_scope(&self, expr_id: ast::NodeId) -> Option<CodeExtent> {\n         //! Returns the scope when temp created by expr_id will be cleaned up\n \n         // check for a designated rvalue scope\n@@ -456,11 +434,11 @@ impl<'tcx> RegionMaps<'tcx> {\n         // if there's one. Static items, for instance, won't\n         // have an enclosing scope, hence no scope will be\n         // returned.\n-        let mut id = tcx.node_extent(expr_id);\n+        let mut id = CodeExtent::Misc(expr_id);\n \n-        while let Some(&p) = self.scope_map.get(id) {\n-            match *p {\n-                CodeExtentData::DestructionScope(..) => {\n+        while let Some(&p) = self.scope_map.get(&id) {\n+            match p {\n+                CodeExtent::DestructionScope(..) => {\n                     debug!(\"temporary_scope({:?}) = {:?} [enclosing]\",\n                            expr_id, id);\n                     return Some(id);\n@@ -473,7 +451,7 @@ impl<'tcx> RegionMaps<'tcx> {\n         return None;\n     }\n \n-    pub fn var_region(&self, id: ast::NodeId) -> ty::RegionKind<'tcx> {\n+    pub fn var_region(&self, id: ast::NodeId) -> ty::RegionKind {\n         //! Returns the lifetime of the variable `id`.\n \n         let scope = ty::ReScope(self.var_scope(id));\n@@ -515,19 +493,19 @@ impl<'tcx> RegionMaps<'tcx> {\n     /// Finds the nearest common ancestor (if any) of two scopes.  That is, finds the smallest\n     /// scope which is greater than or equal to both `scope_a` and `scope_b`.\n     pub fn nearest_common_ancestor(&self,\n-                                   scope_a: CodeExtent<'tcx>,\n-                                   scope_b: CodeExtent<'tcx>)\n-                                   -> CodeExtent<'tcx> {\n+                                   scope_a: CodeExtent,\n+                                   scope_b: CodeExtent)\n+                                   -> CodeExtent {\n         if scope_a == scope_b { return scope_a; }\n \n         /// [1] The initial values for `a_buf` and `b_buf` are not used.\n         /// The `ancestors_of` function will return some prefix that\n         /// is re-initialized with new values (or else fallback to a\n         /// heap-allocated vector).\n         let mut a_buf: [CodeExtent; 32] = [scope_a /* [1] */; 32];\n-        let mut a_vec: Vec<CodeExtent<'tcx>> = vec![];\n+        let mut a_vec: Vec<CodeExtent> = vec![];\n         let mut b_buf: [CodeExtent; 32] = [scope_b /* [1] */; 32];\n-        let mut b_vec: Vec<CodeExtent<'tcx>> = vec![];\n+        let mut b_vec: Vec<CodeExtent> = vec![];\n         let scope_map = &self.scope_map;\n         let a_ancestors = ancestors_of(scope_map, scope_a, &mut a_buf, &mut a_vec);\n         let b_ancestors = ancestors_of(scope_map, scope_b, &mut b_buf, &mut b_vec);\n@@ -551,8 +529,8 @@ impl<'tcx> RegionMaps<'tcx> {\n             let a_root_scope = a_ancestors[a_index];\n             let b_root_scope = a_ancestors[a_index];\n             return match (a_root_scope, b_root_scope) {\n-                (&CodeExtentData::DestructionScope(a_root_id),\n-                 &CodeExtentData::DestructionScope(b_root_id)) => {\n+                (CodeExtent::DestructionScope(a_root_id),\n+                 CodeExtent::DestructionScope(b_root_id)) => {\n                     if self.fn_is_enclosed_by(a_root_id, b_root_id) {\n                         // `a` is enclosed by `b`, hence `b` is the ancestor of everything in `a`\n                         scope_b\n@@ -583,19 +561,19 @@ impl<'tcx> RegionMaps<'tcx> {\n             }\n         }\n \n-        fn ancestors_of<'a, 'tcx>(scope_map: &FxHashMap<CodeExtent<'tcx>, CodeExtent<'tcx>>,\n-                                  scope: CodeExtent<'tcx>,\n-                                  buf: &'a mut [CodeExtent<'tcx>; 32],\n-                                  vec: &'a mut Vec<CodeExtent<'tcx>>)\n-                                  -> &'a [CodeExtent<'tcx>] {\n+        fn ancestors_of<'a, 'tcx>(scope_map: &FxHashMap<CodeExtent, CodeExtent>,\n+                                  scope: CodeExtent,\n+                                  buf: &'a mut [CodeExtent; 32],\n+                                  vec: &'a mut Vec<CodeExtent>)\n+                                  -> &'a [CodeExtent] {\n             // debug!(\"ancestors_of(scope={:?})\", scope);\n             let mut scope = scope;\n \n             let mut i = 0;\n             while i < 32 {\n                 buf[i] = scope;\n                 match scope_map.get(&scope) {\n-                    Some(superscope) => scope = superscope,\n+                    Some(&superscope) => scope = superscope,\n                     _ => return &buf[..i+1]\n                 }\n                 i += 1;\n@@ -606,12 +584,55 @@ impl<'tcx> RegionMaps<'tcx> {\n             loop {\n                 vec.push(scope);\n                 match scope_map.get(&scope) {\n-                    Some(superscope) => scope = superscope,\n+                    Some(&superscope) => scope = superscope,\n                     _ => return &*vec\n                 }\n             }\n         }\n     }\n+\n+    /// Assuming that the provided region was defined within this `RegionMaps`,\n+    /// returns the outermost `CodeExtent` that the region outlives.\n+    pub fn early_free_extent<'a, 'gcx>(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+                                       br: &ty::EarlyBoundRegion)\n+                                       -> CodeExtent {\n+        let param_owner = tcx.parent_def_id(br.def_id).unwrap();\n+\n+        let param_owner_id = tcx.hir.as_local_node_id(param_owner).unwrap();\n+        let body_id = tcx.hir.maybe_body_owned_by(param_owner_id).unwrap_or_else(|| {\n+            // The lifetime was defined on node that doesn't own a body,\n+            // which in practice can only mean a trait or an impl, that\n+            // is the parent of a method, and that is enforced below.\n+            assert_eq!(Some(param_owner_id), self.root_parent,\n+                       \"free_extent: {:?} not recognized by the region maps for {:?}\",\n+                       param_owner,\n+                       self.root_body.map(|body| tcx.hir.body_owner_def_id(body)));\n+\n+            // The trait/impl lifetime is in scope for the method's body.\n+            self.root_body.unwrap()\n+        });\n+\n+        CodeExtent::CallSiteScope(body_id)\n+    }\n+\n+    /// Assuming that the provided region was defined within this `RegionMaps`,\n+    /// returns the outermost `CodeExtent` that the region outlives.\n+    pub fn free_extent<'a, 'gcx>(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>, fr: &ty::FreeRegion)\n+                                 -> CodeExtent {\n+        let param_owner = match fr.bound_region {\n+            ty::BoundRegion::BrNamed(def_id, _) => {\n+                tcx.parent_def_id(def_id).unwrap()\n+            }\n+            _ => fr.scope\n+        };\n+\n+        // Ensure that the named late-bound lifetimes were defined\n+        // on the same function that they ended up being freed in.\n+        assert_eq!(param_owner, fr.scope);\n+\n+        let param_owner_id = tcx.hir.as_local_node_id(param_owner).unwrap();\n+        CodeExtent::CallSiteScope(tcx.hir.body_owned_by(param_owner_id))\n+    }\n }\n \n /// Records the lifetime of a local variable as `cx.var_parent`\n@@ -633,7 +654,6 @@ fn resolve_block<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>, blk:\n     debug!(\"resolve_block(blk.id={:?})\", blk.id);\n \n     let prev_cx = visitor.cx;\n-    let block_extent = visitor.new_node_extent_with_dtor(blk.id);\n \n     // We treat the tail expression in the block (if any) somewhat\n     // differently from the statements. The issue has to do with\n@@ -660,11 +680,8 @@ fn resolve_block<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>, blk:\n     // `other_argument()` has run and also the call to `quux(..)`\n     // itself has returned.\n \n-    visitor.cx = Context {\n-        root_id: prev_cx.root_id,\n-        var_parent: Some(block_extent),\n-        parent: Some(block_extent),\n-    };\n+    visitor.enter_node_extent_with_dtor(blk.id);\n+    visitor.cx.var_parent = visitor.cx.parent;\n \n     {\n         // This block should be kept approximately in sync with\n@@ -680,17 +697,13 @@ fn resolve_block<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>, blk:\n                 // has the previous subscope in the block as a parent,\n                 // except for the first such subscope, which has the\n                 // block itself as a parent.\n-                let stmt_extent = visitor.new_code_extent(\n-                    CodeExtentData::Remainder(BlockRemainder {\n+                visitor.enter_code_extent(\n+                    CodeExtent::Remainder(BlockRemainder {\n                         block: blk.id,\n                         first_statement_index: i as u32\n                     })\n                 );\n-                visitor.cx = Context {\n-                    root_id: prev_cx.root_id,\n-                    var_parent: Some(stmt_extent),\n-                    parent: Some(stmt_extent),\n-                };\n+                visitor.cx.var_parent = visitor.cx.parent;\n             }\n             visitor.visit_stmt(statement)\n         }\n@@ -711,7 +724,7 @@ fn resolve_arm<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>, arm: &\n }\n \n fn resolve_pat<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>, pat: &'tcx hir::Pat) {\n-    visitor.new_node_extent(pat.id);\n+    visitor.record_code_extent(CodeExtent::Misc(pat.id));\n \n     // If this is a binding then record the lifetime of that binding.\n     if let PatKind::Binding(..) = pat.node {\n@@ -731,20 +744,20 @@ fn resolve_stmt<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>, stmt:\n     // statement plus its destructors, and thus the extent for which\n     // regions referenced by the destructors need to survive.\n     visitor.terminating_scopes.insert(stmt_id);\n-    let stmt_extent = visitor.new_node_extent_with_dtor(stmt_id);\n \n     let prev_parent = visitor.cx.parent;\n-    visitor.cx.parent = Some(stmt_extent);\n+    visitor.enter_node_extent_with_dtor(stmt_id);\n+\n     intravisit::walk_stmt(visitor, stmt);\n+\n     visitor.cx.parent = prev_parent;\n }\n \n fn resolve_expr<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>, expr: &'tcx hir::Expr) {\n     debug!(\"resolve_expr(expr.id={:?})\", expr.id);\n \n-    let expr_extent = visitor.new_node_extent_with_dtor(expr.id);\n     let prev_cx = visitor.cx;\n-    visitor.cx.parent = Some(expr_extent);\n+    visitor.enter_node_extent_with_dtor(expr.id);\n \n     {\n         let terminating_scopes = &mut visitor.terminating_scopes;\n@@ -784,7 +797,7 @@ fn resolve_expr<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>, expr:\n             }\n \n             hir::ExprMatch(..) => {\n-                visitor.cx.var_parent = Some(expr_extent);\n+                visitor.cx.var_parent = visitor.cx.parent;\n             }\n \n             hir::ExprAssignOp(..) | hir::ExprIndex(..) |\n@@ -971,7 +984,7 @@ fn resolve_local<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>,\n     fn record_rvalue_scope_if_borrow_expr<'a, 'tcx>(\n         visitor: &mut RegionResolutionVisitor<'a, 'tcx>,\n         expr: &hir::Expr,\n-        blk_id: CodeExtent<'tcx>)\n+        blk_id: CodeExtent)\n     {\n         match expr.node {\n             hir::ExprAddrOf(_, ref subexpr) => {\n@@ -1021,7 +1034,7 @@ fn resolve_local<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>,\n     /// Note: ET is intended to match \"rvalues or lvalues based on rvalues\".\n     fn record_rvalue_scope<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>,\n                                      expr: &hir::Expr,\n-                                     blk_scope: CodeExtent<'tcx>,\n+                                     blk_scope: CodeExtent,\n                                      is_shrunk: bool) {\n         let mut expr = expr;\n         loop {\n@@ -1054,43 +1067,28 @@ fn resolve_local<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>,\n }\n \n impl<'a, 'tcx> RegionResolutionVisitor<'a, 'tcx> {\n-    pub fn intern_code_extent(&mut self,\n-                              data: CodeExtentData,\n-                              parent: Option<CodeExtent<'tcx>>)\n-                              -> CodeExtent<'tcx> {\n-        let code_extent = self.tcx.intern_code_extent(data);\n-        self.region_maps.record_code_extent(code_extent, parent);\n-        code_extent\n-    }\n-\n-    pub fn intern_node(&mut self,\n-                       n: ast::NodeId,\n-                       parent: Option<CodeExtent<'tcx>>) -> CodeExtent<'tcx> {\n-        self.intern_code_extent(CodeExtentData::Misc(n), parent)\n-    }\n-\n     /// Records the current parent (if any) as the parent of `child_scope`.\n-    fn new_code_extent(&mut self, child_scope: CodeExtentData) -> CodeExtent<'tcx> {\n+    fn record_code_extent(&mut self, child_scope: CodeExtent) {\n         let parent = self.cx.parent;\n-        self.intern_code_extent(child_scope, parent)\n+        self.region_maps.record_code_extent(child_scope, parent);\n     }\n \n-    fn new_node_extent(&mut self, child_scope: ast::NodeId) -> CodeExtent<'tcx> {\n-        self.new_code_extent(CodeExtentData::Misc(child_scope))\n+    /// Records the current parent (if any) as the parent of `child_scope`,\n+    /// and sets `child_scope` as the new current parent.\n+    fn enter_code_extent(&mut self, child_scope: CodeExtent) {\n+        self.record_code_extent(child_scope);\n+        self.cx.parent = Some(child_scope);\n     }\n \n-    fn new_node_extent_with_dtor(&mut self, id: ast::NodeId) -> CodeExtent<'tcx> {\n+    fn enter_node_extent_with_dtor(&mut self, id: ast::NodeId) {\n         // If node was previously marked as a terminating scope during the\n         // recursive visit of its parent node in the AST, then we need to\n         // account for the destruction scope representing the extent of\n         // the destructors that run immediately after it completes.\n         if self.terminating_scopes.contains(&id) {\n-            let ds = self.new_code_extent(\n-                CodeExtentData::DestructionScope(id));\n-            self.intern_node(id, Some(ds))\n-        } else {\n-            self.new_node_extent(id)\n+            self.enter_code_extent(CodeExtent::DestructionScope(id));\n         }\n+        self.enter_code_extent(CodeExtent::Misc(id));\n     }\n }\n \n@@ -1105,7 +1103,7 @@ impl<'a, 'tcx> Visitor<'tcx> for RegionResolutionVisitor<'a, 'tcx> {\n \n     fn visit_body(&mut self, body: &'tcx hir::Body) {\n         let body_id = body.id();\n-        let owner_id = self.map.body_owner(body_id);\n+        let owner_id = self.tcx.hir.body_owner(body_id);\n \n         debug!(\"visit_body(id={:?}, span={:?}, body.id={:?}, cx.parent={:?})\",\n                owner_id,\n@@ -1127,10 +1125,8 @@ impl<'a, 'tcx> Visitor<'tcx> for RegionResolutionVisitor<'a, 'tcx> {\n         }\n         self.cx.root_id = Some(body_id.node_id);\n \n-        self.cx.parent = Some(self.new_code_extent(\n-            CodeExtentData::CallSiteScope { fn_id: owner_id, body_id: body_id.node_id }));\n-        self.cx.parent = Some(self.new_code_extent(\n-            CodeExtentData::ParameterScope { fn_id: owner_id, body_id: body_id.node_id }));\n+        self.enter_code_extent(CodeExtent::CallSiteScope(body_id));\n+        self.enter_code_extent(CodeExtent::ParameterScope(body_id));\n \n         // The arguments and `self` are parented to the fn.\n         self.cx.var_parent = self.cx.parent.take();\n@@ -1165,21 +1161,18 @@ impl<'a, 'tcx> Visitor<'tcx> for RegionResolutionVisitor<'a, 'tcx> {\n }\n \n fn region_maps<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId)\n-    -> Rc<RegionMaps<'tcx>>\n+    -> Rc<RegionMaps>\n {\n     let closure_base_def_id = tcx.closure_base_def_id(def_id);\n     if closure_base_def_id != def_id {\n         return tcx.region_maps(closure_base_def_id);\n     }\n \n-    let mut maps = RegionMaps::new();\n-\n     let id = tcx.hir.as_local_node_id(def_id).unwrap();\n-    if let Some(body) = tcx.hir.maybe_body_owned_by(id) {\n+    let maps = if let Some(body) = tcx.hir.maybe_body_owned_by(id) {\n         let mut visitor = RegionResolutionVisitor {\n-            tcx: tcx,\n-            region_maps: &mut maps,\n-            map: &tcx.hir,\n+            tcx,\n+            region_maps: RegionMaps::new(),\n             cx: Context {\n                 root_id: None,\n                 parent: None,\n@@ -1188,8 +1181,25 @@ fn region_maps<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId)\n             terminating_scopes: NodeSet(),\n         };\n \n+        visitor.region_maps.root_body = Some(body);\n+\n+        // If the item is an associated const or a method,\n+        // record its impl/trait parent, as it can also have\n+        // lifetime parameters free in this body.\n+        match tcx.hir.get(id) {\n+            hir::map::NodeImplItem(_) |\n+            hir::map::NodeTraitItem(_) => {\n+                visitor.region_maps.root_parent = Some(tcx.hir.get_parent(id));\n+            }\n+            _ => {}\n+        }\n+\n         visitor.visit_body(tcx.hir.body(body));\n-    }\n+\n+        visitor.region_maps\n+    } else {\n+        RegionMaps::new()\n+    };\n \n     Rc::new(maps)\n }"}, {"sha": "7d7308d73bb048a2b5ed81d8e1166d4606e1788b", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/826d8f3850b37a23481dfcf4a899b5dfc82d22e3/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/826d8f3850b37a23481dfcf4a899b5dfc82d22e3/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=826d8f3850b37a23481dfcf4a899b5dfc82d22e3", "patch": "@@ -19,7 +19,6 @@ use hir::map::Map;\n use session::Session;\n use hir::def::Def;\n use hir::def_id::DefId;\n-use middle::region;\n use ty;\n \n use std::cell::Cell;\n@@ -42,7 +41,7 @@ pub enum Region {\n     EarlyBound(/* index */ u32, /* lifetime decl */ ast::NodeId),\n     LateBound(ty::DebruijnIndex, /* lifetime decl */ ast::NodeId),\n     LateBoundAnon(ty::DebruijnIndex, /* anon index */ u32),\n-    Free(region::CallSiteScopeData, /* lifetime decl */ ast::NodeId),\n+    Free(DefId, /* lifetime decl */ ast::NodeId),\n }\n \n impl Region {\n@@ -895,11 +894,10 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         };\n \n         if let Some(mut def) = result {\n-            if let Some(body_id) = outermost_body {\n+            if let Region::EarlyBound(..) = def {\n+                // Do not free early-bound regions, only late-bound ones.\n+            } else if let Some(body_id) = outermost_body {\n                 let fn_id = self.hir_map.body_owner(body_id);\n-                let scope_data = region::CallSiteScopeData {\n-                    fn_id: fn_id, body_id: body_id.node_id\n-                };\n                 match self.hir_map.get(fn_id) {\n                     hir::map::NodeItem(&hir::Item {\n                         node: hir::ItemFn(..), ..\n@@ -910,7 +908,8 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                     hir::map::NodeImplItem(&hir::ImplItem {\n                         node: hir::ImplItemKind::Method(..), ..\n                     }) => {\n-                        def = Region::Free(scope_data, def.id().unwrap());\n+                        let scope = self.hir_map.local_def_id(fn_id);\n+                        def = Region::Free(scope, def.id().unwrap());\n                     }\n                     _ => {}\n                 }"}, {"sha": "66e8e503be40ba462f79fccab07a76268bf8ccba", "filename": "src/librustc/traits/object_safety.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/826d8f3850b37a23481dfcf4a899b5dfc82d22e3/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/826d8f3850b37a23481dfcf4a899b5dfc82d22e3/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fobject_safety.rs?ref=826d8f3850b37a23481dfcf4a899b5dfc82d22e3", "patch": "@@ -206,9 +206,8 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         };\n \n         // Search for a predicate like `Self : Sized` amongst the trait bounds.\n-        let free_substs = self.construct_free_substs(def_id, None);\n         let predicates = self.predicates_of(def_id);\n-        let predicates = predicates.instantiate(self, free_substs).predicates;\n+        let predicates = predicates.instantiate_identity(self).predicates;\n         elaborate_predicates(self, predicates)\n             .any(|predicate| {\n                 match predicate {"}, {"sha": "3882e218241646127edbc6be623c13062bc0699c", "filename": "src/librustc/traits/specialize/mod.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/826d8f3850b37a23481dfcf4a899b5dfc82d22e3/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/826d8f3850b37a23481dfcf4a899b5dfc82d22e3/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs?ref=826d8f3850b37a23481dfcf4a899b5dfc82d22e3", "patch": "@@ -179,12 +179,8 @@ pub fn specializes<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     }\n \n     // create a parameter environment corresponding to a (skolemized) instantiation of impl1\n-    let penv = tcx.construct_parameter_environment(DUMMY_SP,\n-                                                   impl1_def_id,\n-                                                   None);\n-    let impl1_trait_ref = tcx.impl_trait_ref(impl1_def_id)\n-                             .unwrap()\n-                             .subst(tcx, &penv.free_substs);\n+    let penv = tcx.parameter_environment(impl1_def_id);\n+    let impl1_trait_ref = tcx.impl_trait_ref(impl1_def_id).unwrap();\n \n     // Create a infcx, taking the predicates of impl1 as assumptions:\n     let result = tcx.infer_ctxt(penv, Reveal::UserFacing).enter(|infcx| {"}, {"sha": "3f5cf7eca53077bd48c8900e3093d33b3b9799b2", "filename": "src/librustc/traits/util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/826d8f3850b37a23481dfcf4a899b5dfc82d22e3/src%2Flibrustc%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/826d8f3850b37a23481dfcf4a899b5dfc82d22e3/src%2Flibrustc%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Futil.rs?ref=826d8f3850b37a23481dfcf4a899b5dfc82d22e3", "patch": "@@ -197,7 +197,7 @@ impl<'cx, 'gcx, 'tcx> Elaborator<'cx, 'gcx, 'tcx> {\n                 // I want to be conservative. --nmatsakis\n                 let ty_max = data.skip_binder().0;\n                 let r_min = data.skip_binder().1;\n-                if r_min.is_bound() {\n+                if r_min.is_late_bound() {\n                     return;\n                 }\n \n@@ -206,7 +206,7 @@ impl<'cx, 'gcx, 'tcx> Elaborator<'cx, 'gcx, 'tcx> {\n                     tcx.outlives_components(ty_max)\n                        .into_iter()\n                        .filter_map(|component| match component {\n-                           Component::Region(r) => if r.is_bound() {\n+                           Component::Region(r) => if r.is_late_bound() {\n                                None\n                            } else {\n                                Some(ty::Predicate::RegionOutlives("}, {"sha": "b9355c264b3ef49d85c7f1d392645d7b3c6ef3ee", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 4, "deletions": 43, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/826d8f3850b37a23481dfcf4a899b5dfc82d22e3/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/826d8f3850b37a23481dfcf4a899b5dfc82d22e3/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=826d8f3850b37a23481dfcf4a899b5dfc82d22e3", "patch": "@@ -21,7 +21,6 @@ use hir::map as hir_map;\n use hir::map::DisambiguatedDefPathData;\n use middle::free_region::FreeRegionMap;\n use middle::lang_items;\n-use middle::region::{CodeExtent, CodeExtentData};\n use middle::resolve_lifetime;\n use middle::stability;\n use mir::Mir;\n@@ -99,7 +98,7 @@ pub struct CtxtInterners<'tcx> {\n     type_: RefCell<FxHashSet<Interned<'tcx, TyS<'tcx>>>>,\n     type_list: RefCell<FxHashSet<Interned<'tcx, Slice<Ty<'tcx>>>>>,\n     substs: RefCell<FxHashSet<Interned<'tcx, Substs<'tcx>>>>,\n-    region: RefCell<FxHashSet<Interned<'tcx, RegionKind<'tcx>>>>,\n+    region: RefCell<FxHashSet<Interned<'tcx, RegionKind>>>,\n     existential_predicates: RefCell<FxHashSet<Interned<'tcx, Slice<ExistentialPredicate<'tcx>>>>>,\n     predicates: RefCell<FxHashSet<Interned<'tcx, Slice<Predicate<'tcx>>>>>,\n }\n@@ -548,8 +547,6 @@ pub struct GlobalCtxt<'tcx> {\n \n     layout_interner: RefCell<FxHashSet<&'tcx Layout>>,\n \n-    code_extent_interner: RefCell<FxHashSet<CodeExtent<'tcx>>>,\n-\n     /// A vector of every trait accessible in the whole crate\n     /// (i.e. including those from subcrates). This is used only for\n     /// error reporting, and so is lazily initialised and generally\n@@ -651,32 +648,6 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         interned\n     }\n \n-    pub fn node_extent(self, n: ast::NodeId) -> CodeExtent<'gcx> {\n-        self.intern_code_extent(CodeExtentData::Misc(n))\n-    }\n-\n-    // Returns the code extent for an item - the destruction scope.\n-    pub fn item_extent(self, n: ast::NodeId) -> CodeExtent<'gcx> {\n-        self.intern_code_extent(CodeExtentData::DestructionScope(n))\n-    }\n-\n-    pub fn call_site_extent(self, fn_id: ast::NodeId, body_id: ast::NodeId) -> CodeExtent<'gcx> {\n-        assert!(fn_id != body_id);\n-        self.intern_code_extent(CodeExtentData::CallSiteScope { fn_id: fn_id, body_id: body_id })\n-    }\n-\n-    pub fn intern_code_extent(self, data: CodeExtentData) -> CodeExtent<'gcx> {\n-        if let Some(st) = self.code_extent_interner.borrow().get(&data) {\n-            return st;\n-        }\n-\n-        let interned = self.global_interners.arena.alloc(data);\n-        if let Some(prev) = self.code_extent_interner.borrow_mut().replace(interned) {\n-            bug!(\"Tried to overwrite interned code-extent: {:?}\", prev)\n-        }\n-        interned\n-    }\n-\n     pub fn intern_layout(self, layout: Layout) -> &'gcx Layout {\n         if let Some(layout) = self.layout_interner.borrow().get(&layout) {\n             return layout;\n@@ -764,7 +735,6 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             data_layout: data_layout,\n             layout_cache: RefCell::new(FxHashMap()),\n             layout_interner: RefCell::new(FxHashSet()),\n-            code_extent_interner: RefCell::new(FxHashSet()),\n             layout_depth: Cell::new(0),\n             derive_macros: RefCell::new(NodeMap()),\n             stability_interner: RefCell::new(FxHashSet()),\n@@ -843,15 +813,6 @@ impl<'a, 'tcx> Lift<'tcx> for &'a Substs<'a> {\n     }\n }\n \n-impl<'a, 'tcx> Lift<'tcx> for ty::FreeRegion<'a> {\n-    type Lifted = ty::FreeRegion<'tcx>;\n-    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n-        let scope = self.scope.map(|code_extent| tcx.intern_code_extent(*code_extent));\n-        let bound_region = self.bound_region;\n-        Some(ty::FreeRegion { scope, bound_region })\n-    }\n-}\n-\n impl<'a, 'tcx> Lift<'tcx> for Region<'a> {\n     type Lifted = Region<'tcx>;\n     fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Region<'tcx>> {\n@@ -1115,8 +1076,8 @@ impl<'tcx: 'lcx, 'lcx> Borrow<[Kind<'lcx>]> for Interned<'tcx, Substs<'tcx>> {\n     }\n }\n \n-impl<'tcx> Borrow<RegionKind<'tcx>> for Interned<'tcx, RegionKind<'tcx>> {\n-    fn borrow<'a>(&'a self) -> &'a RegionKind<'tcx> {\n+impl<'tcx> Borrow<RegionKind> for Interned<'tcx, RegionKind> {\n+    fn borrow<'a>(&'a self) -> &'a RegionKind {\n         &self.0\n     }\n }\n@@ -1215,7 +1176,7 @@ direct_interners!('tcx,\n             &ty::ReVar(_) | &ty::ReSkolemized(..) => true,\n             _ => false\n         }\n-    }) -> RegionKind<'tcx>\n+    }) -> RegionKind\n );\n \n macro_rules! slice_interners {"}, {"sha": "6de3c018bda0ebe8223760d6d7eb282553712540", "filename": "src/librustc/ty/fold.rs", "status": "modified", "additions": 1, "deletions": 19, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/826d8f3850b37a23481dfcf4a899b5dfc82d22e3/src%2Flibrustc%2Fty%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/826d8f3850b37a23481dfcf4a899b5dfc82d22e3/src%2Flibrustc%2Fty%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ffold.rs?ref=826d8f3850b37a23481dfcf4a899b5dfc82d22e3", "patch": "@@ -39,7 +39,6 @@\n //! These methods return true to indicate that the visitor has found what it is looking for\n //! and does not need to visit anything else.\n \n-use middle::region;\n use ty::subst::Substs;\n use ty::adjustment;\n use ty::{self, Binder, Ty, TyCtxt, TypeFlags};\n@@ -326,23 +325,6 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         (result, replacer.map)\n     }\n \n-\n-    /// Replace any late-bound regions bound in `value` with free variants attached to scope-id\n-    /// `scope_id`.\n-    pub fn liberate_late_bound_regions<T>(self,\n-        all_outlive_scope: Option<region::CodeExtent<'tcx>>,\n-        value: &Binder<T>)\n-        -> T\n-        where T : TypeFoldable<'tcx>\n-    {\n-        self.replace_late_bound_regions(value, |br| {\n-            self.mk_region(ty::ReFree(ty::FreeRegion {\n-                scope: all_outlive_scope,\n-                bound_region: br\n-            }))\n-        }).0\n-    }\n-\n     /// Flattens two binding levels into one. So `for<'a> for<'b> Foo`\n     /// becomes `for<'a,'b> Foo`.\n     pub fn flatten_late_bound_regions<T>(self, bound2_value: &Binder<Binder<T>>)\n@@ -554,7 +536,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n // regions. See comment on `shift_regions_through_binders` method in\n // `subst.rs` for more details.\n \n-pub fn shift_region<'tcx>(region: ty::RegionKind<'tcx>, amount: u32) -> ty::RegionKind<'tcx> {\n+pub fn shift_region(region: ty::RegionKind, amount: u32) -> ty::RegionKind {\n     match region {\n         ty::ReLateBound(debruijn, br) => {\n             ty::ReLateBound(debruijn.shifted(amount), br)"}, {"sha": "bd38a6c3fd39a6edad843f3053b95fe8b4325ea4", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/826d8f3850b37a23481dfcf4a899b5dfc82d22e3/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/826d8f3850b37a23481dfcf4a899b5dfc82d22e3/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=826d8f3850b37a23481dfcf4a899b5dfc82d22e3", "patch": "@@ -1268,11 +1268,10 @@ impl<'a, 'gcx, 'tcx> Layout {\n                     let kind = if def.is_enum() || def.variants[0].fields.len() == 0{\n                         StructKind::AlwaysSizedUnivariant\n                     } else {\n-                        let param_env = tcx.construct_parameter_environment(DUMMY_SP,\n-                          def.did, None);\n+                        let param_env = tcx.parameter_environment(def.did);\n                         let fields = &def.variants[0].fields;\n                         let last_field = &fields[fields.len()-1];\n-                        let always_sized = last_field.ty(tcx, param_env.free_substs)\n+                        let always_sized = tcx.type_of(last_field.did)\n                           .is_sized(tcx, &param_env, DUMMY_SP);\n                         if !always_sized { StructKind::MaybeUnsizedUnivariant }\n                         else { StructKind::AlwaysSizedUnivariant }"}, {"sha": "1fd9e8f73756e830ca1d0f238107770f03464348", "filename": "src/librustc/ty/maps.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/826d8f3850b37a23481dfcf4a899b5dfc82d22e3/src%2Flibrustc%2Fty%2Fmaps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/826d8f3850b37a23481dfcf4a899b5dfc82d22e3/src%2Flibrustc%2Fty%2Fmaps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps.rs?ref=826d8f3850b37a23481dfcf4a899b5dfc82d22e3", "patch": "@@ -801,7 +801,7 @@ define_maps! { <'tcx>\n     /// Per-function `RegionMaps`. The `DefId` should be the owner-def-id for the fn body;\n     /// in the case of closures or \"inline\" expressions, this will be redirected to the enclosing\n     /// fn item.\n-    [] region_maps: RegionMaps(DefId) -> Rc<RegionMaps<'tcx>>,\n+    [] region_maps: RegionMaps(DefId) -> Rc<RegionMaps>,\n \n     [] mir_shims: mir_shim_dep_node(ty::InstanceDef<'tcx>) -> &'tcx mir::Mir<'tcx>,\n "}, {"sha": "6ca401d27ac72c13937b1795e4b90e09603fa259", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 30, "deletions": 181, "changes": 211, "blob_url": "https://github.com/rust-lang/rust/blob/826d8f3850b37a23481dfcf4a899b5dfc82d22e3/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/826d8f3850b37a23481dfcf4a899b5dfc82d22e3/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=826d8f3850b37a23481dfcf4a899b5dfc82d22e3", "patch": "@@ -23,8 +23,8 @@ use ich::StableHashingContext;\n use middle::const_val::ConstVal;\n use middle::lang_items::{FnTraitLangItem, FnMutTraitLangItem, FnOnceTraitLangItem};\n use middle::privacy::AccessLevels;\n-use middle::region::CodeExtent;\n use middle::resolve_lifetime::ObjectLifetimeDefault;\n+use middle::region::CodeExtent;\n use mir::Mir;\n use traits;\n use ty;\n@@ -732,11 +732,18 @@ pub struct RegionParameterDef {\n impl RegionParameterDef {\n     pub fn to_early_bound_region_data(&self) -> ty::EarlyBoundRegion {\n         ty::EarlyBoundRegion {\n+            def_id: self.def_id,\n             index: self.index,\n             name: self.name,\n         }\n     }\n \n+    pub fn to_bound_region(&self) -> ty::BoundRegion {\n+        self.to_early_bound_region_data().to_bound_region()\n+    }\n+}\n+\n+impl ty::EarlyBoundRegion {\n     pub fn to_bound_region(&self) -> ty::BoundRegion {\n         ty::BoundRegion::BrNamed(self.def_id, self.name)\n     }\n@@ -816,6 +823,21 @@ impl<'a, 'gcx, 'tcx> GenericPredicates<'tcx> {\n         instantiated.predicates.extend(self.predicates.iter().map(|p| p.subst(tcx, substs)))\n     }\n \n+    pub fn instantiate_identity(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>)\n+                                -> InstantiatedPredicates<'tcx> {\n+        let mut instantiated = InstantiatedPredicates::empty();\n+        self.instantiate_identity_into(tcx, &mut instantiated);\n+        instantiated\n+    }\n+\n+    fn instantiate_identity_into(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+                                 instantiated: &mut InstantiatedPredicates<'tcx>) {\n+        if let Some(def_id) = self.parent {\n+            tcx.predicates_of(def_id).instantiate_identity_into(tcx, instantiated);\n+        }\n+        instantiated.predicates.extend(&self.predicates)\n+    }\n+\n     pub fn instantiate_supertrait(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                                   poly_trait_ref: &ty::PolyTraitRef<'tcx>)\n                                   -> InstantiatedPredicates<'tcx>\n@@ -1241,31 +1263,11 @@ impl<'tcx> InstantiatedPredicates<'tcx> {\n /// more distinctions clearer.\n #[derive(Clone)]\n pub struct ParameterEnvironment<'tcx> {\n-    /// See `construct_free_substs` for details.\n-    pub free_substs: &'tcx Substs<'tcx>,\n-\n-    /// Each type parameter has an implicit region bound that\n-    /// indicates it must outlive at least the function body (the user\n-    /// may specify stronger requirements). This field indicates the\n-    /// region of the callee. If it is `None`, then the parameter\n-    /// environment is for an item or something where the \"callee\" is\n-    /// not clear.\n-    pub implicit_region_bound: Option<ty::Region<'tcx>>,\n-\n     /// Obligations that the caller must satisfy. This is basically\n     /// the set of bounds on the in-scope type parameters, translated\n     /// into Obligations, and elaborated and normalized.\n     pub caller_bounds: &'tcx [ty::Predicate<'tcx>],\n \n-    /// Scope that is attached to free regions for this scope. This is\n-    /// usually the id of the fn body, but for more abstract scopes\n-    /// like structs we use None or the item extent.\n-    ///\n-    /// FIXME(#3696). It would be nice to refactor so that free\n-    /// regions don't have this implicit scope and instead introduce\n-    /// relationships in the environment.\n-    pub free_id_outlive: Option<CodeExtent<'tcx>>,\n-\n     /// A cache for `moves_by_default`.\n     pub is_copy_cache: RefCell<FxHashMap<Ty<'tcx>, bool>>,\n \n@@ -1282,120 +1284,12 @@ impl<'a, 'tcx> ParameterEnvironment<'tcx> {\n                               -> ParameterEnvironment<'tcx>\n     {\n         ParameterEnvironment {\n-            free_substs: self.free_substs,\n-            implicit_region_bound: self.implicit_region_bound,\n             caller_bounds: caller_bounds,\n-            free_id_outlive: self.free_id_outlive,\n             is_copy_cache: RefCell::new(FxHashMap()),\n             is_sized_cache: RefCell::new(FxHashMap()),\n             is_freeze_cache: RefCell::new(FxHashMap()),\n         }\n     }\n-\n-    /// Construct a parameter environment given an item, impl item, or trait item\n-    pub fn for_item(tcx: TyCtxt<'a, 'tcx, 'tcx>, id: NodeId)\n-                    -> ParameterEnvironment<'tcx> {\n-        match tcx.hir.find(id) {\n-            Some(hir_map::NodeImplItem(ref impl_item)) => {\n-                match impl_item.node {\n-                    hir::ImplItemKind::Type(_) => {\n-                        // associated types don't have their own entry (for some reason),\n-                        // so for now just grab environment for the impl\n-                        let impl_id = tcx.hir.get_parent(id);\n-                        let impl_def_id = tcx.hir.local_def_id(impl_id);\n-                        tcx.construct_parameter_environment(impl_item.span,\n-                                                            impl_def_id,\n-                                                            Some(tcx.item_extent(id)))\n-                    }\n-                    hir::ImplItemKind::Const(_, body) |\n-                    hir::ImplItemKind::Method(_, body) => {\n-                        tcx.construct_parameter_environment(\n-                            impl_item.span,\n-                            tcx.hir.local_def_id(id),\n-                            Some(tcx.call_site_extent(id, body.node_id)))\n-                    }\n-                }\n-            }\n-            Some(hir_map::NodeTraitItem(trait_item)) => {\n-                match trait_item.node {\n-                    hir::TraitItemKind::Type(..) |\n-                    hir::TraitItemKind::Const(_, None) |\n-                    hir::TraitItemKind::Method(_, hir::TraitMethod::Required(_))=> {\n-                        tcx.construct_parameter_environment(trait_item.span,\n-                                                            tcx.hir.local_def_id(id),\n-                                                            Some(tcx.item_extent(id)))\n-                    }\n-                    hir::TraitItemKind::Const(_, Some(body)) |\n-                    hir::TraitItemKind::Method(_, hir::TraitMethod::Provided(body)) => {\n-                        tcx.construct_parameter_environment(\n-                            trait_item.span,\n-                            tcx.hir.local_def_id(id),\n-                            Some(tcx.call_site_extent(id, body.node_id)))\n-                    }\n-                }\n-            }\n-            Some(hir_map::NodeItem(item)) => {\n-                match item.node {\n-                    hir::ItemConst(_, body) |\n-                    hir::ItemStatic(.., body) |\n-                    hir::ItemFn(.., body) => {\n-                        tcx.construct_parameter_environment(\n-                            item.span,\n-                            tcx.hir.local_def_id(id),\n-                            Some(tcx.call_site_extent(id, body.node_id)))\n-                    }\n-                    hir::ItemEnum(..) |\n-                    hir::ItemStruct(..) |\n-                    hir::ItemUnion(..) |\n-                    hir::ItemTy(..) |\n-                    hir::ItemImpl(..) |\n-                    hir::ItemTrait(..) => {\n-                        let def_id = tcx.hir.local_def_id(id);\n-                        tcx.construct_parameter_environment(item.span,\n-                                                            def_id,\n-                                                            Some(tcx.item_extent(id)))\n-                    }\n-                    _ => {\n-                        span_bug!(item.span,\n-                                  \"ParameterEnvironment::for_item():\n-                                   can't create a parameter \\\n-                                   environment for this kind of item\")\n-                    }\n-                }\n-            }\n-            Some(hir_map::NodeExpr(expr)) => {\n-                // This is a convenience to allow closures to work.\n-                if let hir::ExprClosure(.., body, _) = expr.node {\n-                    let def_id = tcx.hir.local_def_id(id);\n-                    let base_def_id = tcx.closure_base_def_id(def_id);\n-                    tcx.construct_parameter_environment(\n-                        expr.span,\n-                        base_def_id,\n-                        Some(tcx.call_site_extent(id, body.node_id)))\n-                } else {\n-                    tcx.empty_parameter_environment()\n-                }\n-            }\n-            Some(hir_map::NodeForeignItem(item)) => {\n-                let def_id = tcx.hir.local_def_id(id);\n-                tcx.construct_parameter_environment(item.span,\n-                                                    def_id,\n-                                                    None)\n-            }\n-            Some(hir_map::NodeStructCtor(..)) |\n-            Some(hir_map::NodeVariant(..)) => {\n-                let def_id = tcx.hir.local_def_id(id);\n-                tcx.construct_parameter_environment(tcx.hir.span(id),\n-                                                    def_id,\n-                                                    None)\n-            }\n-            it => {\n-                bug!(\"ParameterEnvironment::from_item(): \\\n-                      `{}` = {:?} is unsupported\",\n-                     tcx.hir.node_to_string(id), it)\n-            }\n-        }\n-    }\n }\n \n #[derive(Copy, Clone, Debug)]\n@@ -2497,64 +2391,21 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     /// are no free type/lifetime parameters in scope.\n     pub fn empty_parameter_environment(self) -> ParameterEnvironment<'tcx> {\n         ty::ParameterEnvironment {\n-            free_substs: self.intern_substs(&[]),\n             caller_bounds: Slice::empty(),\n-            implicit_region_bound: None,\n-            free_id_outlive: None,\n             is_copy_cache: RefCell::new(FxHashMap()),\n             is_sized_cache: RefCell::new(FxHashMap()),\n             is_freeze_cache: RefCell::new(FxHashMap()),\n         }\n     }\n \n-    /// Constructs and returns a substitution that can be applied to move from\n-    /// the \"outer\" view of a type or method to the \"inner\" view.\n-    /// In general, this means converting from bound parameters to\n-    /// free parameters. Since we currently represent bound/free type\n-    /// parameters in the same way, this only has an effect on regions.\n-    pub fn construct_free_substs(self,\n-                                 def_id: DefId,\n-                                 free_id_outlive: Option<CodeExtent<'gcx>>)\n-                                 -> &'gcx Substs<'gcx> {\n-\n-        let substs = Substs::for_item(self.global_tcx(), def_id, |def, _| {\n-            // map bound 'a => free 'a\n-            self.global_tcx().mk_region(ReFree(FreeRegion {\n-                scope: free_id_outlive,\n-                bound_region: def.to_bound_region()\n-            }))\n-        }, |def, _| {\n-            // map T => T\n-            self.global_tcx().mk_param_from_def(def)\n-        });\n-\n-        debug!(\"construct_parameter_environment: {:?}\", substs);\n-        substs\n-    }\n-\n     /// See `ParameterEnvironment` struct def'n for details.\n-    /// If you were using `free_id: NodeId`, you might try `self.region_maps().item_extent(free_id)`\n-    /// for the `free_id_outlive` parameter. (But note that this is not always quite right.)\n-    pub fn construct_parameter_environment(self,\n-                                           span: Span,\n-                                           def_id: DefId,\n-                                           free_id_outlive: Option<CodeExtent<'gcx>>)\n-                                           -> ParameterEnvironment<'gcx>\n-    {\n-        //\n-        // Construct the free substs.\n-        //\n-\n-        let free_substs = self.construct_free_substs(def_id, free_id_outlive);\n-\n+    pub fn parameter_environment(self, def_id: DefId) -> ParameterEnvironment<'gcx> {\n         //\n         // Compute the bounds on Self and the type parameters.\n         //\n \n         let tcx = self.global_tcx();\n-        let generic_predicates = tcx.predicates_of(def_id);\n-        let bounds = generic_predicates.instantiate(tcx, free_substs);\n-        let bounds = tcx.liberate_late_bound_regions(free_id_outlive, &ty::Binder(bounds));\n+        let bounds = tcx.predicates_of(def_id).instantiate_identity(tcx);\n         let predicates = bounds.predicates;\n \n         // Finally, we have to normalize the bounds in the environment, in\n@@ -2571,23 +2422,21 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         //\n \n         let unnormalized_env = ty::ParameterEnvironment {\n-            free_substs: free_substs,\n-            implicit_region_bound: free_id_outlive.map(|f| tcx.mk_region(ty::ReScope(f))),\n             caller_bounds: tcx.intern_predicates(&predicates),\n-            free_id_outlive: free_id_outlive,\n             is_copy_cache: RefCell::new(FxHashMap()),\n             is_sized_cache: RefCell::new(FxHashMap()),\n             is_freeze_cache: RefCell::new(FxHashMap()),\n         };\n \n-        let body_id = free_id_outlive.map(|f| f.node_id())\n-                                     .unwrap_or(DUMMY_NODE_ID);\n-        let cause = traits::ObligationCause::misc(span, body_id);\n+        let body_id = self.hir.as_local_node_id(def_id).map_or(DUMMY_NODE_ID, |id| {\n+            self.hir.maybe_body_owned_by(id).map_or(id, |body| body.node_id)\n+        });\n+        let cause = traits::ObligationCause::misc(tcx.def_span(def_id), body_id);\n         traits::normalize_param_env_or_error(tcx, def_id, unnormalized_env, cause)\n     }\n \n     pub fn node_scope_region(self, id: NodeId) -> Region<'tcx> {\n-        self.mk_region(ty::ReScope(self.node_extent(id)))\n+        self.mk_region(ty::ReScope(CodeExtent::Misc(id)))\n     }\n \n     /// Looks up the span of `impl_did` if the impl is local; otherwise returns `Err`"}, {"sha": "ab1b1b3857d0035c81695027d48a439a2cc86813", "filename": "src/librustc/ty/outlives.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/826d8f3850b37a23481dfcf4a899b5dfc82d22e3/src%2Flibrustc%2Fty%2Foutlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/826d8f3850b37a23481dfcf4a899b5dfc82d22e3/src%2Flibrustc%2Fty%2Foutlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Foutlives.rs?ref=826d8f3850b37a23481dfcf4a899b5dfc82d22e3", "patch": "@@ -204,7 +204,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n \n fn push_region_constraints<'tcx>(out: &mut Vec<Component<'tcx>>, regions: Vec<ty::Region<'tcx>>) {\n     for r in regions {\n-        if !r.is_bound() {\n+        if !r.is_late_bound() {\n             out.push(Component::Region(r));\n         }\n     }"}, {"sha": "cfbf1244db3ad70202effe2891a277185b44150f", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 10, "deletions": 14, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/826d8f3850b37a23481dfcf4a899b5dfc82d22e3/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/826d8f3850b37a23481dfcf4a899b5dfc82d22e3/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=826d8f3850b37a23481dfcf4a899b5dfc82d22e3", "patch": "@@ -43,12 +43,8 @@ pub struct TypeAndMut<'tcx> {\n          RustcEncodable, RustcDecodable, Copy)]\n /// A \"free\" region `fr` can be interpreted as \"some region\n /// at least as big as the scope `fr.scope`\".\n-///\n-/// If `fr.scope` is None, then this is in some context (e.g., an\n-/// impl) where lifetimes are more abstract and the notion of the\n-/// caller/callee stack frames are not applicable.\n-pub struct FreeRegion<'tcx> {\n-    pub scope: Option<region::CodeExtent<'tcx>>,\n+pub struct FreeRegion {\n+    pub scope: DefId,\n     pub bound_region: BoundRegion,\n }\n \n@@ -688,7 +684,7 @@ pub struct DebruijnIndex {\n     pub depth: u32,\n }\n \n-pub type Region<'tcx> = &'tcx RegionKind<'tcx>;\n+pub type Region<'tcx> = &'tcx RegionKind;\n \n /// Representation of regions.\n ///\n@@ -747,7 +743,7 @@ pub type Region<'tcx> = &'tcx RegionKind<'tcx>;\n /// [1] http://smallcultfollowing.com/babysteps/blog/2013/10/29/intermingled-parameter-lists/\n /// [2] http://smallcultfollowing.com/babysteps/blog/2013/11/04/intermingled-parameter-lists/\n #[derive(Clone, PartialEq, Eq, Hash, Copy, RustcEncodable, RustcDecodable)]\n-pub enum RegionKind<'tcx> {\n+pub enum RegionKind {\n     // Region bound in a type or fn declaration which will be\n     // substituted 'early' -- that is, at the same time when type\n     // parameters are substituted.\n@@ -760,12 +756,12 @@ pub enum RegionKind<'tcx> {\n     /// When checking a function body, the types of all arguments and so forth\n     /// that refer to bound region parameters are modified to refer to free\n     /// region parameters.\n-    ReFree(FreeRegion<'tcx>),\n+    ReFree(FreeRegion),\n \n     /// A concrete region naming some statically determined extent\n     /// (e.g. an expression or sequence of statements) within the\n     /// current function.\n-    ReScope(region::CodeExtent<'tcx>),\n+    ReScope(region::CodeExtent),\n \n     /// Static data that has an \"infinite\" lifetime. Top in the region lattice.\n     ReStatic,\n@@ -794,6 +790,7 @@ impl<'tcx> serialize::UseSpecializedDecodable for Region<'tcx> {}\n \n #[derive(Copy, Clone, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable, Debug)]\n pub struct EarlyBoundRegion {\n+    pub def_id: DefId,\n     pub index: u32,\n     pub name: Name,\n }\n@@ -909,10 +906,9 @@ impl DebruijnIndex {\n }\n \n /// Region utilities\n-impl<'tcx> RegionKind<'tcx> {\n-    pub fn is_bound(&self) -> bool {\n+impl RegionKind {\n+    pub fn is_late_bound(&self) -> bool {\n         match *self {\n-            ty::ReEarlyBound(..) => true,\n             ty::ReLateBound(..) => true,\n             _ => false,\n         }\n@@ -933,7 +929,7 @@ impl<'tcx> RegionKind<'tcx> {\n     }\n \n     /// Returns the depth of `self` from the (1-based) binding level `depth`\n-    pub fn from_depth(&self, depth: u32) -> RegionKind<'tcx> {\n+    pub fn from_depth(&self, depth: u32) -> RegionKind {\n         match *self {\n             ty::ReLateBound(debruijn, r) => ty::ReLateBound(DebruijnIndex {\n                 depth: debruijn.depth - (depth - 1)"}, {"sha": "c6c6a0e47003dbb40777d056b2ade638c6259eb7", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/826d8f3850b37a23481dfcf4a899b5dfc82d22e3/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/826d8f3850b37a23481dfcf4a899b5dfc82d22e3/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=826d8f3850b37a23481dfcf4a899b5dfc82d22e3", "patch": "@@ -688,9 +688,8 @@ impl<'a, 'gcx, 'tcx, W> TypeVisitor<'tcx> for TypeIdHasher<'a, 'gcx, 'tcx, W>\n                 self.hash(db.depth);\n                 self.hash(i);\n             }\n-            ty::ReEarlyBound(ty::EarlyBoundRegion { index, name }) => {\n-                self.hash(index);\n-                self.hash(name.as_str());\n+            ty::ReEarlyBound(ty::EarlyBoundRegion { def_id, .. }) => {\n+                self.def_id(def_id);\n             }\n             ty::ReLateBound(..) |\n             ty::ReFree(..) |"}, {"sha": "8ca699339d36ecedca7a92a3e785b51fffb248bf", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 4, "deletions": 10, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/826d8f3850b37a23481dfcf4a899b5dfc82d22e3/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/826d8f3850b37a23481dfcf4a899b5dfc82d22e3/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=826d8f3850b37a23481dfcf4a899b5dfc82d22e3", "patch": "@@ -458,7 +458,7 @@ impl fmt::Debug for ty::BoundRegion {\n     }\n }\n \n-impl<'tcx> fmt::Debug for ty::RegionKind<'tcx> {\n+impl fmt::Debug for ty::RegionKind {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match *self {\n             ty::ReEarlyBound(ref data) => {\n@@ -506,17 +506,11 @@ impl<'tcx> fmt::Debug for ty::ClosureUpvar<'tcx> {\n \n impl<'tcx> fmt::Debug for ty::ParameterEnvironment<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"ParameterEnvironment(\\\n-            free_substs={:?}, \\\n-            implicit_region_bound={:?}, \\\n-            caller_bounds={:?})\",\n-            self.free_substs,\n-            self.implicit_region_bound,\n-            self.caller_bounds)\n+        write!(f, \"ParameterEnvironment({:?})\", self.caller_bounds)\n     }\n }\n \n-impl<'tcx> fmt::Display for ty::RegionKind<'tcx> {\n+impl<'tcx> fmt::Display for ty::RegionKind {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         if verbose() {\n             return write!(f, \"{:?}\", *self);\n@@ -544,7 +538,7 @@ impl<'tcx> fmt::Display for ty::RegionKind<'tcx> {\n     }\n }\n \n-impl<'tcx> fmt::Debug for ty::FreeRegion<'tcx> {\n+impl fmt::Debug for ty::FreeRegion {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         write!(f, \"ReFree({:?}, {:?})\",\n                self.scope, self.bound_region)"}, {"sha": "eeb5a3fb957fa481f7a2ad4dc15f80b77f529950", "filename": "src/librustc_borrowck/borrowck/check_loans.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/826d8f3850b37a23481dfcf4a899b5dfc82d22e3/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/826d8f3850b37a23481dfcf4a899b5dfc82d22e3/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs?ref=826d8f3850b37a23481dfcf4a899b5dfc82d22e3", "patch": "@@ -232,7 +232,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n         })\n     }\n \n-    pub fn each_in_scope_loan<F>(&self, scope: region::CodeExtent<'tcx>, mut op: F) -> bool where\n+    pub fn each_in_scope_loan<F>(&self, scope: region::CodeExtent, mut op: F) -> bool where\n         F: FnMut(&Loan<'tcx>) -> bool,\n     {\n         //! Like `each_issued_loan()`, but only considers loans that are\n@@ -248,7 +248,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n     }\n \n     fn each_in_scope_loan_affecting_path<F>(&self,\n-                                            scope: region::CodeExtent<'tcx>,\n+                                            scope: region::CodeExtent,\n                                             loan_path: &LoanPath<'tcx>,\n                                             mut op: F)\n                                             -> bool where\n@@ -708,7 +708,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n         let mut ret = UseOk;\n \n         self.each_in_scope_loan_affecting_path(\n-            self.tcx().node_extent(expr_id), use_path, |loan| {\n+            region::CodeExtent::Misc(expr_id), use_path, |loan| {\n             if !compatible_borrow_kinds(loan.kind, borrow_kind) {\n                 ret = UseWhileBorrowed(loan.loan_path.clone(), loan.span);\n                 false\n@@ -822,7 +822,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n \n         // Check that we don't invalidate any outstanding loans\n         if let Some(loan_path) = opt_loan_path(&assignee_cmt) {\n-            let scope = self.tcx().node_extent(assignment_id);\n+            let scope = region::CodeExtent::Misc(assignment_id);\n             self.each_in_scope_loan_affecting_path(scope, &loan_path, |loan| {\n                 self.report_illegal_mutation(assignment_span, &loan_path, loan);\n                 false"}, {"sha": "5fc5682a60b456c38ba9f22e5745839b3e3cd6b5", "filename": "src/librustc_borrowck/borrowck/gather_loans/lifetime.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/826d8f3850b37a23481dfcf4a899b5dfc82d22e3/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Flifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/826d8f3850b37a23481dfcf4a899b5dfc82d22e3/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Flifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Flifetime.rs?ref=826d8f3850b37a23481dfcf4a899b5dfc82d22e3", "patch": "@@ -24,7 +24,7 @@ use syntax_pos::Span;\n type R = Result<(),()>;\n \n pub fn guarantee_lifetime<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n-                                    item_scope: region::CodeExtent<'tcx>,\n+                                    item_scope: region::CodeExtent,\n                                     span: Span,\n                                     cause: euv::LoanCause,\n                                     cmt: mc::cmt<'tcx>,\n@@ -52,7 +52,7 @@ struct GuaranteeLifetimeContext<'a, 'tcx: 'a> {\n     bccx: &'a BorrowckCtxt<'a, 'tcx>,\n \n     // the scope of the function body for the enclosing item\n-    item_scope: region::CodeExtent<'tcx>,\n+    item_scope: region::CodeExtent,\n \n     span: Span,\n     cause: euv::LoanCause,"}, {"sha": "4cfee36359cd7576522dc4a871cbf339741b5d24", "filename": "src/librustc_borrowck/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 15, "deletions": 10, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/826d8f3850b37a23481dfcf4a899b5dfc82d22e3/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/826d8f3850b37a23481dfcf4a899b5dfc82d22e3/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=826d8f3850b37a23481dfcf4a899b5dfc82d22e3", "patch": "@@ -45,7 +45,7 @@ pub fn gather_loans_in_fn<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n         bccx: bccx,\n         infcx: &infcx,\n         all_loans: Vec::new(),\n-        item_ub: bccx.tcx.node_extent(body.node_id),\n+        item_ub: region::CodeExtent::Misc(body.node_id),\n         move_data: MoveData::new(),\n         move_error_collector: move_error::MoveErrorCollector::new(),\n     };\n@@ -66,7 +66,7 @@ struct GatherLoanCtxt<'a, 'tcx: 'a> {\n     all_loans: Vec<Loan<'tcx>>,\n     /// `item_ub` is used as an upper-bound on the lifetime whenever we\n     /// ask for the scope of an expression categorized as an upvar.\n-    item_ub: region::CodeExtent<'tcx>,\n+    item_ub: region::CodeExtent,\n }\n \n impl<'a, 'tcx> euv::Delegate<'tcx> for GatherLoanCtxt<'a, 'tcx> {\n@@ -353,13 +353,18 @@ impl<'a, 'tcx> GatherLoanCtxt<'a, 'tcx> {\n                 let loan_scope = match *loan_region {\n                     ty::ReScope(scope) => scope,\n \n-                    ty::ReFree(ref fr) => fr.scope.unwrap_or(self.item_ub),\n+                    ty::ReEarlyBound(ref br) => {\n+                        self.bccx.region_maps.early_free_extent(self.tcx(), br)\n+                    }\n+\n+                    ty::ReFree(ref fr) => {\n+                        self.bccx.region_maps.free_extent(self.tcx(), fr)\n+                    }\n \n                     ty::ReStatic => self.item_ub,\n \n                     ty::ReEmpty |\n                     ty::ReLateBound(..) |\n-                    ty::ReEarlyBound(..) |\n                     ty::ReVar(..) |\n                     ty::ReSkolemized(..) |\n                     ty::ReErased => {\n@@ -371,7 +376,7 @@ impl<'a, 'tcx> GatherLoanCtxt<'a, 'tcx> {\n                 };\n                 debug!(\"loan_scope = {:?}\", loan_scope);\n \n-                let borrow_scope = self.tcx().node_extent(borrow_id);\n+                let borrow_scope = region::CodeExtent::Misc(borrow_id);\n                 let gen_scope = self.compute_gen_scope(borrow_scope, loan_scope);\n                 debug!(\"gen_scope = {:?}\", gen_scope);\n \n@@ -450,9 +455,9 @@ impl<'a, 'tcx> GatherLoanCtxt<'a, 'tcx> {\n     }\n \n     pub fn compute_gen_scope(&self,\n-                             borrow_scope: region::CodeExtent<'tcx>,\n-                             loan_scope: region::CodeExtent<'tcx>)\n-                             -> region::CodeExtent<'tcx> {\n+                             borrow_scope: region::CodeExtent,\n+                             loan_scope: region::CodeExtent)\n+                             -> region::CodeExtent {\n         //! Determine when to introduce the loan. Typically the loan\n         //! is introduced at the point of the borrow, but in some cases,\n         //! notably method arguments, the loan may be introduced only\n@@ -465,8 +470,8 @@ impl<'a, 'tcx> GatherLoanCtxt<'a, 'tcx> {\n         }\n     }\n \n-    pub fn compute_kill_scope(&self, loan_scope: region::CodeExtent<'tcx>, lp: &LoanPath<'tcx>)\n-                              -> region::CodeExtent<'tcx> {\n+    pub fn compute_kill_scope(&self, loan_scope: region::CodeExtent, lp: &LoanPath<'tcx>)\n+                              -> region::CodeExtent {\n         //! Determine when the loan restrictions go out of scope.\n         //! This is either when the lifetime expires or when the\n         //! local variable which roots the loan-path goes out of scope,"}, {"sha": "520a90d940b3912d292448891e569244063cefef", "filename": "src/librustc_borrowck/borrowck/mir/elaborate_drops.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/826d8f3850b37a23481dfcf4a899b5dfc82d22e3/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/826d8f3850b37a23481dfcf4a899b5dfc82d22e3/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Felaborate_drops.rs?ref=826d8f3850b37a23481dfcf4a899b5dfc82d22e3", "patch": "@@ -44,7 +44,7 @@ impl MirPass for ElaborateDrops {\n             _ => return\n         }\n         let id = src.item_id();\n-        let param_env = ty::ParameterEnvironment::for_item(tcx, id);\n+        let param_env = tcx.parameter_environment(tcx.hir.local_def_id(id));\n         let move_data = MoveData::gather_moves(mir, tcx, &param_env);\n         let elaborate_patch = {\n             let mir = &*mir;"}, {"sha": "fbaa60f84450b26f4596bb99728af967f47344ba", "filename": "src/librustc_borrowck/borrowck/mir/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/826d8f3850b37a23481dfcf4a899b5dfc82d22e3/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/826d8f3850b37a23481dfcf4a899b5dfc82d22e3/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fmod.rs?ref=826d8f3850b37a23481dfcf4a899b5dfc82d22e3", "patch": "@@ -65,7 +65,7 @@ pub fn borrowck_mir(bcx: &mut BorrowckCtxt,\n     // steals it, but it forces the `borrowck` query.\n     let mir = &tcx.mir_validated(def_id).borrow();\n \n-    let param_env = ty::ParameterEnvironment::for_item(tcx, id);\n+    let param_env = tcx.parameter_environment(def_id);\n     let move_data = MoveData::gather_moves(mir, tcx, &param_env);\n     let mdpe = MoveDataParamEnv { move_data: move_data, param_env: param_env };\n     let dead_unwinds = IdxSetBuf::new_empty(mir.basic_blocks().len());"}, {"sha": "99df1431265084b80f8307a2c3734f1f28b922dd", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/826d8f3850b37a23481dfcf4a899b5dfc82d22e3/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/826d8f3850b37a23481dfcf4a899b5dfc82d22e3/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=826d8f3850b37a23481dfcf4a899b5dfc82d22e3", "patch": "@@ -208,7 +208,7 @@ pub struct BorrowckCtxt<'a, 'tcx: 'a> {\n     // Some in `borrowck_fn` and cleared later\n     tables: &'a ty::TypeckTables<'tcx>,\n \n-    region_maps: Rc<RegionMaps<'tcx>>,\n+    region_maps: Rc<RegionMaps>,\n \n     owner_def_id: DefId,\n }\n@@ -228,13 +228,13 @@ pub struct Loan<'tcx> {\n     /// cases, notably method arguments, the loan may be introduced\n     /// only later, once it comes into scope.  See also\n     /// `GatherLoanCtxt::compute_gen_scope`.\n-    gen_scope: region::CodeExtent<'tcx>,\n+    gen_scope: region::CodeExtent,\n \n     /// kill_scope indicates when the loan goes out of scope.  This is\n     /// either when the lifetime expires or when the local variable\n     /// which roots the loan-path goes out of scope, whichever happens\n     /// faster. See also `GatherLoanCtxt::compute_kill_scope`.\n-    kill_scope: region::CodeExtent<'tcx>,\n+    kill_scope: region::CodeExtent,\n     span: Span,\n     cause: euv::LoanCause,\n }\n@@ -334,12 +334,12 @@ pub fn closure_to_block(closure_id: ast::NodeId,\n }\n \n impl<'a, 'tcx> LoanPath<'tcx> {\n-    pub fn kill_scope(&self, bccx: &BorrowckCtxt<'a, 'tcx>) -> region::CodeExtent<'tcx> {\n+    pub fn kill_scope(&self, bccx: &BorrowckCtxt<'a, 'tcx>) -> region::CodeExtent {\n         match self.kind {\n             LpVar(local_id) => bccx.region_maps.var_scope(local_id),\n             LpUpvar(upvar_id) => {\n                 let block_id = closure_to_block(upvar_id.closure_expr_id, bccx.tcx);\n-                bccx.tcx.node_extent(block_id)\n+                region::CodeExtent::Misc(block_id)\n             }\n             LpDowncast(ref base, _) |\n             LpExtend(ref base, ..) => base.kill_scope(bccx),\n@@ -513,6 +513,8 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n         match (&err.code, &err.cause) {\n             (&err_out_of_scope(&ty::ReScope(_), &ty::ReStatic, _),\n              &BorrowViolation(euv::ClosureCapture(span))) |\n+            (&err_out_of_scope(&ty::ReScope(_), &ty::ReEarlyBound(..), _),\n+             &BorrowViolation(euv::ClosureCapture(span))) |\n             (&err_out_of_scope(&ty::ReScope(_), &ty::ReFree(..), _),\n              &BorrowViolation(euv::ClosureCapture(span))) => {\n                 return self.report_out_of_scope_escaping_closure_capture(&err, span);"}, {"sha": "a18f91a9ee391408f069981f119d09ead357e618", "filename": "src/librustc_const_eval/check_match.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/826d8f3850b37a23481dfcf4a899b5dfc82d22e3/src%2Flibrustc_const_eval%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/826d8f3850b37a23481dfcf4a899b5dfc82d22e3/src%2Flibrustc_const_eval%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fcheck_match.rs?ref=826d8f3850b37a23481dfcf4a899b5dfc82d22e3", "patch": "@@ -46,14 +46,13 @@ impl<'a, 'tcx> Visitor<'tcx> for OuterVisitor<'a, 'tcx> {\n                 b: hir::BodyId, s: Span, id: ast::NodeId) {\n         intravisit::walk_fn(self, fk, fd, b, s, id);\n \n-        let region_context = self.tcx.hir.local_def_id(id);\n-        let region_maps = self.tcx.region_maps(region_context);\n+        let def_id = self.tcx.hir.local_def_id(id);\n \n         MatchVisitor {\n             tcx: self.tcx,\n             tables: self.tcx.body_tables(b),\n-            region_maps: &region_maps,\n-            param_env: &ty::ParameterEnvironment::for_item(self.tcx, id)\n+            region_maps: &self.tcx.region_maps(def_id),\n+            param_env: &self.tcx.parameter_environment(def_id)\n         }.visit_body(self.tcx.hir.body(b));\n     }\n }\n@@ -71,7 +70,7 @@ struct MatchVisitor<'a, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     tables: &'a ty::TypeckTables<'tcx>,\n     param_env: &'a ty::ParameterEnvironment<'tcx>,\n-    region_maps: &'a RegionMaps<'tcx>,\n+    region_maps: &'a RegionMaps,\n }\n \n impl<'a, 'tcx> Visitor<'tcx> for MatchVisitor<'a, 'tcx> {"}, {"sha": "e2cbc480715fb66d590be7a5311b9a52e9bf3277", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/826d8f3850b37a23481dfcf4a899b5dfc82d22e3/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/826d8f3850b37a23481dfcf4a899b5dfc82d22e3/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=826d8f3850b37a23481dfcf4a899b5dfc82d22e3", "patch": "@@ -17,7 +17,6 @@ use rustc_resolve::MakeGlobMap;\n use rustc::middle::lang_items;\n use rustc::middle::free_region::FreeRegionMap;\n use rustc::middle::region::{CodeExtent, RegionMaps};\n-use rustc::middle::region::CodeExtentData;\n use rustc::middle::resolve_lifetime;\n use rustc::middle::stability;\n use rustc::ty::subst::{Kind, Subst};\n@@ -45,7 +44,7 @@ use rustc::hir;\n \n struct Env<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n     infcx: &'a infer::InferCtxt<'a, 'gcx, 'tcx>,\n-    region_maps: &'a mut RegionMaps<'tcx>,\n+    region_maps: &'a mut RegionMaps,\n }\n \n struct RH<'a> {\n@@ -168,8 +167,8 @@ impl<'a, 'gcx, 'tcx> Env<'a, 'gcx, 'tcx> {\n         self.infcx.tcx\n     }\n \n-    pub fn create_region_hierarchy(&mut self, rh: &RH, parent: CodeExtent<'tcx>) {\n-        let me = self.tcx().intern_code_extent(CodeExtentData::Misc(rh.id));\n+    pub fn create_region_hierarchy(&mut self, rh: &RH, parent: CodeExtent) {\n+        let me = CodeExtent::Misc(rh.id);\n         self.region_maps.record_code_extent(me, Some(parent));\n         for child_rh in rh.sub {\n             self.create_region_hierarchy(child_rh, me);\n@@ -181,7 +180,7 @@ impl<'a, 'gcx, 'tcx> Env<'a, 'gcx, 'tcx> {\n         // children of 1, etc\n \n         let node = ast::NodeId::from_u32;\n-        let dscope = self.tcx().intern_code_extent(CodeExtentData::DestructionScope(node(1)));\n+        let dscope = CodeExtent::DestructionScope(node(1));\n         self.region_maps.record_code_extent(dscope, None);\n         self.create_region_hierarchy(&RH {\n                                          id: node(1),\n@@ -296,8 +295,9 @@ impl<'a, 'gcx, 'tcx> Env<'a, 'gcx, 'tcx> {\n     pub fn re_early_bound(&self, index: u32, name: &'static str) -> ty::Region<'tcx> {\n         let name = Symbol::intern(name);\n         self.infcx.tcx.mk_region(ty::ReEarlyBound(ty::EarlyBoundRegion {\n-            index: index,\n-            name: name,\n+            def_id: self.infcx.tcx.hir.local_def_id(ast::CRATE_NODE_ID),\n+            index,\n+            name,\n         }))\n     }\n \n@@ -326,19 +326,19 @@ impl<'a, 'gcx, 'tcx> Env<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn t_rptr_scope(&self, id: u32) -> Ty<'tcx> {\n-        let r = ty::ReScope(self.tcx().node_extent(ast::NodeId::from_u32(id)));\n+        let r = ty::ReScope(CodeExtent::Misc(ast::NodeId::from_u32(id)));\n         self.infcx.tcx.mk_imm_ref(self.infcx.tcx.mk_region(r), self.tcx().types.isize)\n     }\n \n-    pub fn re_free(&self, nid: ast::NodeId, id: u32) -> ty::Region<'tcx> {\n+    pub fn re_free(&self, id: u32) -> ty::Region<'tcx> {\n         self.infcx.tcx.mk_region(ty::ReFree(ty::FreeRegion {\n-            scope: Some(self.tcx().node_extent(nid)),\n+            scope: self.infcx.tcx.hir.local_def_id(ast::CRATE_NODE_ID),\n             bound_region: ty::BrAnon(id),\n         }))\n     }\n \n-    pub fn t_rptr_free(&self, nid: u32, id: u32) -> Ty<'tcx> {\n-        let r = self.re_free(ast::NodeId::from_u32(nid), id);\n+    pub fn t_rptr_free(&self, id: u32) -> Ty<'tcx> {\n+        let r = self.re_free(id);\n         self.infcx.tcx.mk_imm_ref(r, self.tcx().types.isize)\n     }\n \n@@ -464,7 +464,7 @@ fn sub_free_bound_false() {\n \n     test_env(EMPTY_SOURCE_STR, errors(&[]), |mut env| {\n         env.create_simple_region_hierarchy();\n-        let t_rptr_free1 = env.t_rptr_free(1, 1);\n+        let t_rptr_free1 = env.t_rptr_free(1);\n         let t_rptr_bound1 = env.t_rptr_late_bound(1);\n         env.check_not_sub(env.t_fn(&[t_rptr_free1], env.tcx().types.isize),\n                           env.t_fn(&[t_rptr_bound1], env.tcx().types.isize));\n@@ -482,7 +482,7 @@ fn sub_bound_free_true() {\n     test_env(EMPTY_SOURCE_STR, errors(&[]), |mut env| {\n         env.create_simple_region_hierarchy();\n         let t_rptr_bound1 = env.t_rptr_late_bound(1);\n-        let t_rptr_free1 = env.t_rptr_free(1, 1);\n+        let t_rptr_free1 = env.t_rptr_free(1);\n         env.check_sub(env.t_fn(&[t_rptr_bound1], env.tcx().types.isize),\n                       env.t_fn(&[t_rptr_free1], env.tcx().types.isize));\n     })\n@@ -518,7 +518,7 @@ fn lub_free_bound_infer() {\n         env.create_simple_region_hierarchy();\n         let t_infer1 = env.infcx.next_ty_var(TypeVariableOrigin::MiscVariable(DUMMY_SP));\n         let t_rptr_bound1 = env.t_rptr_late_bound(1);\n-        let t_rptr_free1 = env.t_rptr_free(1, 1);\n+        let t_rptr_free1 = env.t_rptr_free(1);\n         env.check_lub(env.t_fn(&[t_infer1], env.tcx().types.isize),\n                       env.t_fn(&[t_rptr_bound1], env.tcx().types.isize),\n                       env.t_fn(&[t_rptr_free1], env.tcx().types.isize));\n@@ -541,7 +541,7 @@ fn lub_bound_free() {\n     test_env(EMPTY_SOURCE_STR, errors(&[]), |mut env| {\n         env.create_simple_region_hierarchy();\n         let t_rptr_bound1 = env.t_rptr_late_bound(1);\n-        let t_rptr_free1 = env.t_rptr_free(1, 1);\n+        let t_rptr_free1 = env.t_rptr_free(1);\n         env.check_lub(env.t_fn(&[t_rptr_bound1], env.tcx().types.isize),\n                       env.t_fn(&[t_rptr_free1], env.tcx().types.isize),\n                       env.t_fn(&[t_rptr_free1], env.tcx().types.isize));\n@@ -574,8 +574,8 @@ fn lub_bound_bound_inverse_order() {\n fn lub_free_free() {\n     test_env(EMPTY_SOURCE_STR, errors(&[]), |mut env| {\n         env.create_simple_region_hierarchy();\n-        let t_rptr_free1 = env.t_rptr_free(1, 1);\n-        let t_rptr_free2 = env.t_rptr_free(1, 2);\n+        let t_rptr_free1 = env.t_rptr_free(1);\n+        let t_rptr_free2 = env.t_rptr_free(2);\n         let t_rptr_static = env.t_rptr_static();\n         env.check_lub(env.t_fn(&[t_rptr_free1], env.tcx().types.isize),\n                       env.t_fn(&[t_rptr_free2], env.tcx().types.isize),\n@@ -600,8 +600,8 @@ fn lub_returning_scope() {\n fn glb_free_free_with_common_scope() {\n     test_env(EMPTY_SOURCE_STR, errors(&[]), |mut env| {\n         env.create_simple_region_hierarchy();\n-        let t_rptr_free1 = env.t_rptr_free(1, 1);\n-        let t_rptr_free2 = env.t_rptr_free(1, 2);\n+        let t_rptr_free1 = env.t_rptr_free(1);\n+        let t_rptr_free2 = env.t_rptr_free(2);\n         let t_rptr_scope = env.t_rptr_scope(1);\n         env.check_glb(env.t_fn(&[t_rptr_free1], env.tcx().types.isize),\n                       env.t_fn(&[t_rptr_free2], env.tcx().types.isize),\n@@ -625,7 +625,7 @@ fn glb_bound_free() {\n     test_env(EMPTY_SOURCE_STR, errors(&[]), |mut env| {\n         env.create_simple_region_hierarchy();\n         let t_rptr_bound1 = env.t_rptr_late_bound(1);\n-        let t_rptr_free1 = env.t_rptr_free(1, 1);\n+        let t_rptr_free1 = env.t_rptr_free(1);\n         env.check_glb(env.t_fn(&[t_rptr_bound1], env.tcx().types.isize),\n                       env.t_fn(&[t_rptr_free1], env.tcx().types.isize),\n                       env.t_fn(&[t_rptr_bound1], env.tcx().types.isize));\n@@ -751,7 +751,7 @@ fn escaping() {\n \n         assert!(!env.t_nil().has_escaping_regions());\n \n-        let t_rptr_free1 = env.t_rptr_free(1, 1);\n+        let t_rptr_free1 = env.t_rptr_free(1);\n         assert!(!t_rptr_free1.has_escaping_regions());\n \n         let t_rptr_bound1 = env.t_rptr_late_bound_with_debruijn(1, ty::DebruijnIndex::new(1));"}, {"sha": "6423d65a4c23fc7175ee598ef365ae7ed90c3ce1", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/826d8f3850b37a23481dfcf4a899b5dfc82d22e3/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/826d8f3850b37a23481dfcf4a899b5dfc82d22e3/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=826d8f3850b37a23481dfcf4a899b5dfc82d22e3", "patch": "@@ -990,12 +990,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnconditionalRecursion {\n                         traits::Obligation::new(traits::ObligationCause::misc(span, expr_id),\n                                                 trait_ref.to_poly_trait_predicate());\n \n-                    // unwrap() is ok here b/c `method` is the method\n-                    // defined in this crate whose body we are\n-                    // checking, so it's always local\n-                    let node_id = tcx.hir.as_local_node_id(method.def_id).unwrap();\n-\n-                    let param_env = ty::ParameterEnvironment::for_item(tcx, node_id);\n+                    let param_env = tcx.parameter_environment(method.def_id);\n                     tcx.infer_ctxt(param_env, Reveal::UserFacing).enter(|infcx| {\n                         let mut selcx = traits::SelectionContext::new(&infcx);\n                         match selcx.select(&obligation) {\n@@ -1263,7 +1258,7 @@ impl LintPass for UnionsWithDropFields {\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnionsWithDropFields {\n     fn check_item(&mut self, ctx: &LateContext, item: &hir::Item) {\n         if let hir::ItemUnion(ref vdata, _) = item.node {\n-            let param_env = &ty::ParameterEnvironment::for_item(ctx.tcx, item.id);\n+            let param_env = &ctx.tcx.parameter_environment(ctx.tcx.hir.local_def_id(item.id));\n             for field in vdata.fields() {\n                 let field_ty = ctx.tcx.type_of(ctx.tcx.hir.local_def_id(field.id));\n                 if field_ty.needs_drop(ctx.tcx, param_env) {"}, {"sha": "819095e262832b207b9f689014c2e805cbc455b4", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/826d8f3850b37a23481dfcf4a899b5dfc82d22e3/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/826d8f3850b37a23481dfcf4a899b5dfc82d22e3/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=826d8f3850b37a23481dfcf4a899b5dfc82d22e3", "patch": "@@ -21,7 +21,6 @@ use rustc::middle::cstore::LinkagePreference;\n use rustc::hir::def::{self, Def, CtorKind};\n use rustc::hir::def_id::{CrateNum, DefId, DefIndex, CRATE_DEF_INDEX, LOCAL_CRATE};\n use rustc::middle::lang_items;\n-use rustc::middle::region;\n use rustc::session::Session;\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::ty::subst::Substs;\n@@ -360,12 +359,6 @@ impl<'a, 'tcx> SpecializedDecoder<ty::Region<'tcx>> for DecodeContext<'a, 'tcx>\n     }\n }\n \n-impl<'a, 'tcx> SpecializedDecoder<region::CodeExtent<'tcx>> for DecodeContext<'a, 'tcx> {\n-    fn specialized_decode(&mut self) -> Result<region::CodeExtent<'tcx>, Self::Error> {\n-        Ok(self.tcx().intern_code_extent(Decodable::decode(self)?))\n-    }\n-}\n-\n impl<'a, 'tcx> SpecializedDecoder<&'tcx ty::Slice<Ty<'tcx>>> for DecodeContext<'a, 'tcx> {\n     fn specialized_decode(&mut self) -> Result<&'tcx ty::Slice<Ty<'tcx>>, Self::Error> {\n         Ok(self.tcx().mk_type_list((0..self.read_usize()?).map(|_| Decodable::decode(self)))?)"}, {"sha": "a368021443292b36a844039ab75b37333721c6c5", "filename": "src/librustc_mir/build/expr/as_operand.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/826d8f3850b37a23481dfcf4a899b5dfc82d22e3/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_operand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/826d8f3850b37a23481dfcf4a899b5dfc82d22e3/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_operand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_operand.rs?ref=826d8f3850b37a23481dfcf4a899b5dfc82d22e3", "patch": "@@ -39,7 +39,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     /// The operand is known to be live until the end of `scope`.\n     pub fn as_operand<M>(&mut self,\n                          block: BasicBlock,\n-                         scope: Option<CodeExtent<'tcx>>,\n+                         scope: Option<CodeExtent>,\n                          expr: M) -> BlockAnd<Operand<'tcx>>\n         where M: Mirror<'tcx, Output = Expr<'tcx>>\n     {\n@@ -49,7 +49,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n \n     fn expr_as_operand(&mut self,\n                        mut block: BasicBlock,\n-                       scope: Option<CodeExtent<'tcx>>,\n+                       scope: Option<CodeExtent>,\n                        expr: Expr<'tcx>)\n                        -> BlockAnd<Operand<'tcx>> {\n         debug!(\"expr_as_operand(block={:?}, expr={:?})\", block, expr);"}, {"sha": "7b29cd970d7d4447c852d0feaa39542afc77d0a6", "filename": "src/librustc_mir/build/expr/as_rvalue.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/826d8f3850b37a23481dfcf4a899b5dfc82d22e3/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/826d8f3850b37a23481dfcf4a899b5dfc82d22e3/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=826d8f3850b37a23481dfcf4a899b5dfc82d22e3", "patch": "@@ -38,7 +38,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     }\n \n     /// Compile `expr`, yielding an rvalue.\n-    pub fn as_rvalue<M>(&mut self, block: BasicBlock, scope: Option<CodeExtent<'tcx>>, expr: M)\n+    pub fn as_rvalue<M>(&mut self, block: BasicBlock, scope: Option<CodeExtent>, expr: M)\n                         -> BlockAnd<Rvalue<'tcx>>\n         where M: Mirror<'tcx, Output = Expr<'tcx>>\n     {\n@@ -48,7 +48,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n \n     fn expr_as_rvalue(&mut self,\n                       mut block: BasicBlock,\n-                      scope: Option<CodeExtent<'tcx>>,\n+                      scope: Option<CodeExtent>,\n                       expr: Expr<'tcx>)\n                       -> BlockAnd<Rvalue<'tcx>> {\n         debug!(\"expr_as_rvalue(block={:?}, expr={:?})\", block, expr);"}, {"sha": "a334923546fb2df76a8c4ccb73cd242bf11ae6ab", "filename": "src/librustc_mir/build/expr/as_temp.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/826d8f3850b37a23481dfcf4a899b5dfc82d22e3/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_temp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/826d8f3850b37a23481dfcf4a899b5dfc82d22e3/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_temp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_temp.rs?ref=826d8f3850b37a23481dfcf4a899b5dfc82d22e3", "patch": "@@ -21,7 +21,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     /// up rvalues so as to freeze the value that will be consumed.\n     pub fn as_temp<M>(&mut self,\n                       block: BasicBlock,\n-                      temp_lifetime: Option<CodeExtent<'tcx>>,\n+                      temp_lifetime: Option<CodeExtent>,\n                       expr: M)\n                       -> BlockAnd<Lvalue<'tcx>>\n         where M: Mirror<'tcx, Output = Expr<'tcx>>\n@@ -32,7 +32,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n \n     fn expr_as_temp(&mut self,\n                     mut block: BasicBlock,\n-                    temp_lifetime: Option<CodeExtent<'tcx>>,\n+                    temp_lifetime: Option<CodeExtent>,\n                     expr: Expr<'tcx>)\n                     -> BlockAnd<Lvalue<'tcx>> {\n         debug!(\"expr_as_temp(block={:?}, expr={:?})\", block, expr);"}, {"sha": "fb173e2487bff0c5091fb68566f4a5975f16b9f3", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 14, "deletions": 24, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/826d8f3850b37a23481dfcf4a899b5dfc82d22e3/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/826d8f3850b37a23481dfcf4a899b5dfc82d22e3/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=826d8f3850b37a23481dfcf4a899b5dfc82d22e3", "patch": "@@ -14,7 +14,7 @@ use hair::cx::Cx;\n use hair::Pattern;\n use rustc::hir;\n use rustc::hir::def_id::DefId;\n-use rustc::middle::region::{CodeExtent, CodeExtentData};\n+use rustc::middle::region::CodeExtent;\n use rustc::mir::*;\n use rustc::mir::transform::MirSource;\n use rustc::mir::visit::MutVisitor;\n@@ -172,7 +172,7 @@ fn create_constructor_shim<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n {\n     let span = tcx.hir.span(ctor_id);\n     if let hir::VariantData::Tuple(ref fields, ctor_id) = *v {\n-        let pe = ty::ParameterEnvironment::for_item(tcx, ctor_id);\n+        let pe = tcx.parameter_environment(tcx.hir.local_def_id(ctor_id));\n         tcx.infer_ctxt(pe, Reveal::UserFacing).enter(|infcx| {\n             let (mut mir, src) =\n                 shim::build_adt_ctor(&infcx, ctor_id, fields, span);\n@@ -206,13 +206,14 @@ fn closure_self_ty<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                              -> Ty<'tcx> {\n     let closure_ty = tcx.body_tables(body_id).node_id_to_type(closure_expr_id);\n \n+    let closure_def_id = tcx.hir.local_def_id(closure_expr_id);\n     let region = ty::ReFree(ty::FreeRegion {\n-        scope: Some(tcx.item_extent(body_id.node_id)),\n+        scope: closure_def_id,\n         bound_region: ty::BoundRegion::BrEnv,\n     });\n     let region = tcx.mk_region(region);\n \n-    match tcx.closure_kind(tcx.hir.local_def_id(closure_expr_id)) {\n+    match tcx.closure_kind(closure_def_id) {\n         ty::ClosureKind::Fn =>\n             tcx.mk_ref(region,\n                        ty::TypeAndMut { ty: closure_ty,\n@@ -337,12 +338,8 @@ fn construct_fn<'a, 'gcx, 'tcx, A>(hir: Cx<'a, 'gcx, 'tcx>,\n     let span = tcx.hir.span(fn_id);\n     let mut builder = Builder::new(hir.clone(), span, arguments.len(), return_ty);\n \n-    let call_site_extent =\n-        tcx.intern_code_extent(\n-            CodeExtentData::CallSiteScope { fn_id: fn_id, body_id: body.value.id });\n-    let arg_extent =\n-        tcx.intern_code_extent(\n-            CodeExtentData::ParameterScope { fn_id: fn_id, body_id: body.value.id });\n+    let call_site_extent = CodeExtent::CallSiteScope(body.id());\n+    let arg_extent = CodeExtent::ParameterScope(body.id());\n     let mut block = START_BLOCK;\n     unpack!(block = builder.in_scope(call_site_extent, block, |builder| {\n         unpack!(block = builder.in_scope(arg_extent, block, |builder| {\n@@ -405,22 +402,15 @@ pub fn construct_const<'a, 'gcx, 'tcx>(hir: Cx<'a, 'gcx, 'tcx>,\n     let span = tcx.hir.span(owner_id);\n     let mut builder = Builder::new(hir.clone(), span, 0, ty);\n \n-    let extent = hir.region_maps.temporary_scope(tcx, ast_expr.id)\n-                                .unwrap_or(tcx.item_extent(owner_id));\n     let mut block = START_BLOCK;\n-    let _ = builder.in_scope(extent, block, |builder| {\n-        let expr = builder.hir.mirror(ast_expr);\n-        unpack!(block = builder.into(&Lvalue::Local(RETURN_POINTER), block, expr));\n+    let expr = builder.hir.mirror(ast_expr);\n+    unpack!(block = builder.into_expr(&Lvalue::Local(RETURN_POINTER), block, expr));\n \n-        let source_info = builder.source_info(span);\n-        let return_block = builder.return_block();\n-        builder.cfg.terminate(block, source_info,\n-                              TerminatorKind::Goto { target: return_block });\n-        builder.cfg.terminate(return_block, source_info,\n-                              TerminatorKind::Return);\n+    let source_info = builder.source_info(span);\n+    builder.cfg.terminate(block, source_info, TerminatorKind::Return);\n \n-        return_block.unit()\n-    });\n+    // Constants can't `return` so a return block should not be created.\n+    assert_eq!(builder.cached_return_block, None);\n \n     builder.finish(vec![], ty)\n }\n@@ -490,7 +480,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     fn args_and_body(&mut self,\n                      mut block: BasicBlock,\n                      arguments: &[(Ty<'gcx>, Option<&'gcx hir::Pat>)],\n-                     argument_extent: CodeExtent<'tcx>,\n+                     argument_extent: CodeExtent,\n                      ast_body: &'gcx hir::Expr)\n                      -> BlockAnd<()>\n     {"}, {"sha": "ae47f4c42442041fe47241444d4c796fb5a91c39", "filename": "src/librustc_mir/build/scope.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/826d8f3850b37a23481dfcf4a899b5dfc82d22e3/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/826d8f3850b37a23481dfcf4a899b5dfc82d22e3/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fscope.rs?ref=826d8f3850b37a23481dfcf4a899b5dfc82d22e3", "patch": "@@ -87,7 +87,7 @@ should go to.\n */\n \n use build::{BlockAnd, BlockAndExtension, Builder, CFG};\n-use rustc::middle::region::{CodeExtent, CodeExtentData};\n+use rustc::middle::region::CodeExtent;\n use rustc::middle::lang_items;\n use rustc::middle::const_val::ConstVal;\n use rustc::ty::subst::{Kind, Subst};\n@@ -102,7 +102,7 @@ pub struct Scope<'tcx> {\n     visibility_scope: VisibilityScope,\n \n     /// the extent of this scope within source code.\n-    extent: CodeExtent<'tcx>,\n+    extent: CodeExtent,\n \n     /// Whether there's anything to do for the cleanup path, that is,\n     /// when unwinding through this scope. This includes destructors,\n@@ -137,7 +137,7 @@ pub struct Scope<'tcx> {\n     free: Option<FreeData<'tcx>>,\n \n     /// The cache for drop chain on \u201cnormal\u201d exit into a particular BasicBlock.\n-    cached_exits: FxHashMap<(BasicBlock, CodeExtent<'tcx>), BasicBlock>,\n+    cached_exits: FxHashMap<(BasicBlock, CodeExtent), BasicBlock>,\n }\n \n struct DropData<'tcx> {\n@@ -180,7 +180,7 @@ struct FreeData<'tcx> {\n #[derive(Clone, Debug)]\n pub struct BreakableScope<'tcx> {\n     /// Extent of the loop\n-    pub extent: CodeExtent<'tcx>,\n+    pub extent: CodeExtent,\n     /// Where the body of the loop begins. `None` if block\n     pub continue_block: Option<BasicBlock>,\n     /// Block to branch into when the loop or block terminates (either by being `break`-en out\n@@ -271,7 +271,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     /// Convenience wrapper that pushes a scope and then executes `f`\n     /// to build its contents, popping the scope afterwards.\n     pub fn in_scope<F, R>(&mut self,\n-                          extent: CodeExtent<'tcx>,\n+                          extent: CodeExtent,\n                           mut block: BasicBlock,\n                           f: F)\n                           -> BlockAnd<R>\n@@ -289,7 +289,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     /// scope and call `pop_scope` afterwards. Note that these two\n     /// calls must be paired; using `in_scope` as a convenience\n     /// wrapper maybe preferable.\n-    pub fn push_scope(&mut self, extent: CodeExtent<'tcx>) {\n+    pub fn push_scope(&mut self, extent: CodeExtent) {\n         debug!(\"push_scope({:?})\", extent);\n         let vis_scope = self.visibility_scope;\n         self.scopes.push(Scope {\n@@ -306,7 +306,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     /// drops onto the end of `block` that are needed.  This must\n     /// match 1-to-1 with `push_scope`.\n     pub fn pop_scope(&mut self,\n-                     extent: CodeExtent<'tcx>,\n+                     extent: CodeExtent,\n                      mut block: BasicBlock)\n                      -> BlockAnd<()> {\n         debug!(\"pop_scope({:?}, {:?})\", extent, block);\n@@ -330,7 +330,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     /// module comment for details.\n     pub fn exit_scope(&mut self,\n                       span: Span,\n-                      extent: CodeExtent<'tcx>,\n+                      extent: CodeExtent,\n                       mut block: BasicBlock,\n                       target: BasicBlock) {\n         debug!(\"exit_scope(extent={:?}, block={:?}, target={:?})\", extent, block, target);\n@@ -391,7 +391,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     /// resolving `break` and `continue`.\n     pub fn find_breakable_scope(&mut self,\n                            span: Span,\n-                           label: CodeExtent<'tcx>)\n+                           label: CodeExtent)\n                            -> &mut BreakableScope<'tcx> {\n         // find the loop-scope with the correct id\n         self.breakable_scopes.iter_mut()\n@@ -411,20 +411,20 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n \n     /// Returns the extent of the scope which should be exited by a\n     /// return.\n-    pub fn extent_of_return_scope(&self) -> CodeExtent<'tcx> {\n+    pub fn extent_of_return_scope(&self) -> CodeExtent {\n         // The outermost scope (`scopes[0]`) will be the `CallSiteScope`.\n         // We want `scopes[1]`, which is the `ParameterScope`.\n         assert!(self.scopes.len() >= 2);\n-        assert!(match *self.scopes[1].extent {\n-            CodeExtentData::ParameterScope { .. } => true,\n+        assert!(match self.scopes[1].extent {\n+            CodeExtent::ParameterScope(_) => true,\n             _ => false,\n         });\n         self.scopes[1].extent\n     }\n \n     /// Returns the topmost active scope, which is known to be alive until\n     /// the next scope expression.\n-    pub fn topmost_scope(&self) -> CodeExtent<'tcx> {\n+    pub fn topmost_scope(&self) -> CodeExtent {\n         self.scopes.last().expect(\"topmost_scope: no scopes present\").extent\n     }\n \n@@ -434,7 +434,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     /// `extent`.\n     pub fn schedule_drop(&mut self,\n                          span: Span,\n-                         extent: CodeExtent<'tcx>,\n+                         extent: CodeExtent,\n                          lvalue: &Lvalue<'tcx>,\n                          lvalue_ty: Ty<'tcx>) {\n         let needs_drop = self.hir.needs_drop(lvalue_ty);\n@@ -524,7 +524,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     /// There may only be one \u201cfree\u201d scheduled in any given scope.\n     pub fn schedule_box_free(&mut self,\n                              span: Span,\n-                             extent: CodeExtent<'tcx>,\n+                             extent: CodeExtent,\n                              value: &Lvalue<'tcx>,\n                              item_ty: Ty<'tcx>) {\n         for scope in self.scopes.iter_mut().rev() {"}, {"sha": "920da30611633d64d66bd5ef18f3003f18d04adf", "filename": "src/librustc_mir/hair/cx/block.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/826d8f3850b37a23481dfcf4a899b5dfc82d22e3/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/826d8f3850b37a23481dfcf4a899b5dfc82d22e3/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs?ref=826d8f3850b37a23481dfcf4a899b5dfc82d22e3", "patch": "@@ -11,7 +11,7 @@\n use hair::*;\n use hair::cx::Cx;\n use hair::cx::to_ref::ToRef;\n-use rustc::middle::region::{BlockRemainder, CodeExtentData};\n+use rustc::middle::region::{BlockRemainder, CodeExtent};\n use rustc::hir;\n use syntax::ast;\n \n@@ -24,7 +24,7 @@ impl<'tcx> Mirror<'tcx> for &'tcx hir::Block {\n         let stmts = mirror_stmts(cx, self.id, &*self.stmts);\n         Block {\n             targeted_by_break: self.targeted_by_break,\n-            extent: cx.tcx.node_extent(self.id),\n+            extent: CodeExtent::Misc(self.id),\n             span: self.span,\n             stmts: stmts,\n             expr: self.expr.to_ref(),\n@@ -44,7 +44,7 @@ fn mirror_stmts<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                 result.push(StmtRef::Mirror(Box::new(Stmt {\n                     span: stmt.span,\n                     kind: StmtKind::Expr {\n-                        scope: cx.tcx.node_extent(id),\n+                        scope: CodeExtent::Misc(id),\n                         expr: expr.to_ref(),\n                     },\n                 })))\n@@ -55,19 +55,17 @@ fn mirror_stmts<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                         // ignore for purposes of the MIR\n                     }\n                     hir::DeclLocal(ref local) => {\n-                        let remainder_extent = CodeExtentData::Remainder(BlockRemainder {\n+                        let remainder_extent = CodeExtent::Remainder(BlockRemainder {\n                             block: block_id,\n                             first_statement_index: index as u32,\n                         });\n-                        let remainder_extent =\n-                            cx.tcx.intern_code_extent(remainder_extent);\n \n                         let pattern = Pattern::from_hir(cx.tcx, cx.tables(), &local.pat);\n                         result.push(StmtRef::Mirror(Box::new(Stmt {\n                             span: stmt.span,\n                             kind: StmtKind::Let {\n                                 remainder_scope: remainder_extent,\n-                                init_scope: cx.tcx.node_extent(id),\n+                                init_scope: CodeExtent::Misc(id),\n                                 pattern: pattern,\n                                 initializer: local.init.to_ref(),\n                             },\n@@ -84,7 +82,7 @@ pub fn to_expr_ref<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                                    block: &'tcx hir::Block)\n                                    -> ExprRef<'tcx> {\n     let block_ty = cx.tables().node_id_to_type(block.id);\n-    let (temp_lifetime, was_shrunk) = cx.region_maps.temporary_scope2(cx.tcx, block.id);\n+    let (temp_lifetime, was_shrunk) = cx.region_maps.temporary_scope2(block.id);\n     let expr = Expr {\n         ty: block_ty,\n         temp_lifetime: temp_lifetime,"}, {"sha": "b180d982e86b669c9be4c517efa98d2a7503e454", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 14, "deletions": 28, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/826d8f3850b37a23481dfcf4a899b5dfc82d22e3/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/826d8f3850b37a23481dfcf4a899b5dfc82d22e3/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=826d8f3850b37a23481dfcf4a899b5dfc82d22e3", "patch": "@@ -14,7 +14,6 @@ use rustc_const_math::ConstInt;\n use hair::cx::Cx;\n use hair::cx::block;\n use hair::cx::to_ref::ToRef;\n-use rustc::hir::map;\n use rustc::hir::def::{Def, CtorKind};\n use rustc::middle::const_val::ConstVal;\n use rustc::ty::{self, AdtKind, VariantDef, Ty};\n@@ -26,8 +25,8 @@ impl<'tcx> Mirror<'tcx> for &'tcx hir::Expr {\n     type Output = Expr<'tcx>;\n \n     fn make_mirror<'a, 'gcx>(self, cx: &mut Cx<'a, 'gcx, 'tcx>) -> Expr<'tcx> {\n-        let (temp_lifetime, was_shrunk) = cx.region_maps.temporary_scope2(cx.tcx, self.id);\n-        let expr_extent = cx.tcx.node_extent(self.id);\n+        let (temp_lifetime, was_shrunk) = cx.region_maps.temporary_scope2(self.id);\n+        let expr_extent = CodeExtent::Misc(self.id);\n \n         debug!(\"Expr::make_mirror(): id={}, span={:?}\", self.id, self.span);\n \n@@ -238,7 +237,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                                           expr: &'tcx hir::Expr)\n                                           -> Expr<'tcx> {\n     let expr_ty = cx.tables().expr_ty(expr);\n-    let (temp_lifetime, was_shrunk) = cx.region_maps.temporary_scope2(cx.tcx, expr.id);\n+    let (temp_lifetime, was_shrunk) = cx.region_maps.temporary_scope2(expr.id);\n \n     let kind = match expr.node {\n         // Here comes the interesting stuff:\n@@ -610,7 +609,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n             match dest.target_id {\n                 hir::ScopeTarget::Block(target_id) |\n                 hir::ScopeTarget::Loop(hir::LoopIdResult::Ok(target_id)) => ExprKind::Break {\n-                    label: cx.tcx.node_extent(target_id),\n+                    label: CodeExtent::Misc(target_id),\n                     value: value.to_ref(),\n                 },\n                 hir::ScopeTarget::Loop(hir::LoopIdResult::Err(err)) =>\n@@ -621,7 +620,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n             match dest.target_id {\n                 hir::ScopeTarget::Block(_) => bug!(\"cannot continue to blocks\"),\n                 hir::ScopeTarget::Loop(hir::LoopIdResult::Ok(loop_id)) => ExprKind::Continue {\n-                    label: cx.tcx.node_extent(loop_id),\n+                    label: CodeExtent::Misc(loop_id),\n                 },\n                 hir::ScopeTarget::Loop(hir::LoopIdResult::Err(err)) =>\n                     bug!(\"invalid loop id for continue: {}\", err)\n@@ -686,7 +685,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n         hir::ExprBox(ref value) => {\n             ExprKind::Box {\n                 value: value.to_ref(),\n-                value_extents: cx.tcx.node_extent(value.id),\n+                value_extents: CodeExtent::Misc(value.id),\n             }\n         }\n         hir::ExprArray(ref fields) => ExprKind::Array { fields: fields.to_ref() },\n@@ -707,7 +706,7 @@ fn method_callee<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                                  method_call: ty::MethodCall)\n                                  -> Expr<'tcx> {\n     let callee = cx.tables().method_map[&method_call];\n-    let (temp_lifetime, was_shrunk) = cx.region_maps.temporary_scope2(cx.tcx, expr.id);\n+    let (temp_lifetime, was_shrunk) = cx.region_maps.temporary_scope2(expr.id);\n     Expr {\n         temp_lifetime: temp_lifetime,\n         temp_lifetime_was_shrunk: was_shrunk,\n@@ -791,7 +790,7 @@ fn convert_var<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                                expr: &'tcx hir::Expr,\n                                def: Def)\n                                -> ExprKind<'tcx> {\n-    let (temp_lifetime, was_shrunk) = cx.region_maps.temporary_scope2(cx.tcx, expr.id);\n+    let (temp_lifetime, was_shrunk) = cx.region_maps.temporary_scope2(expr.id);\n \n     match def {\n         Def::Local(def_id) => {\n@@ -807,33 +806,20 @@ fn convert_var<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                    closure_expr_id);\n             let var_ty = cx.tables().node_id_to_type(id_var);\n \n-            let body_id = match cx.tcx.hir.find(closure_expr_id) {\n-                Some(map::NodeExpr(expr)) => {\n-                    match expr.node {\n-                        hir::ExprClosure(.., body, _) => body.node_id,\n-                        _ => {\n-                            span_bug!(expr.span, \"closure expr is not a closure expr\");\n-                        }\n-                    }\n-                }\n-                _ => {\n-                    span_bug!(expr.span, \"ast-map has garbage for closure expr\");\n-                }\n-            };\n-\n             // FIXME free regions in closures are not right\n             let closure_ty = cx.tables().node_id_to_type(closure_expr_id);\n \n             // FIXME we're just hard-coding the idea that the\n             // signature will be &self or &mut self and hence will\n             // have a bound region with number 0\n+            let closure_def_id = cx.tcx.hir.local_def_id(closure_expr_id);\n             let region = ty::ReFree(ty::FreeRegion {\n-                scope: Some(cx.tcx.node_extent(body_id)),\n+                scope: closure_def_id,\n                 bound_region: ty::BoundRegion::BrAnon(0),\n             });\n             let region = cx.tcx.mk_region(region);\n \n-            let self_expr = match cx.tcx.closure_kind(cx.tcx.hir.local_def_id(closure_expr_id)) {\n+            let self_expr = match cx.tcx.closure_kind(closure_def_id) {\n                 ty::ClosureKind::Fn => {\n                     let ref_closure_ty = cx.tcx.mk_ref(region,\n                                                        ty::TypeAndMut {\n@@ -979,7 +965,7 @@ fn overloaded_operator<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n         PassArgs::ByRef => {\n             let region = cx.tcx.node_scope_region(expr.id);\n             let (temp_lifetime, was_shrunk) =\n-                cx.region_maps.temporary_scope2(cx.tcx, expr.id);\n+                cx.region_maps.temporary_scope2(expr.id);\n             argrefs.extend(args.iter()\n                 .map(|arg| {\n                     let arg_ty = cx.tables().expr_ty_adjusted(arg);\n@@ -1031,7 +1017,7 @@ fn overloaded_lvalue<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n \n     // construct the complete expression `foo()` for the overloaded call,\n     // which will yield the &T type\n-    let (temp_lifetime, was_shrunk) = cx.region_maps.temporary_scope2(cx.tcx, expr.id);\n+    let (temp_lifetime, was_shrunk) = cx.region_maps.temporary_scope2(expr.id);\n     let ref_kind = overloaded_operator(cx, expr, method_call, pass_args, receiver, args);\n     let ref_expr = Expr {\n         temp_lifetime: temp_lifetime,\n@@ -1056,7 +1042,7 @@ fn capture_freevar<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n         closure_expr_id: closure_expr.id,\n     };\n     let upvar_capture = cx.tables().upvar_capture(upvar_id).unwrap();\n-    let (temp_lifetime, was_shrunk) = cx.region_maps.temporary_scope2(cx.tcx, closure_expr.id);\n+    let (temp_lifetime, was_shrunk) = cx.region_maps.temporary_scope2(closure_expr.id);\n     let var_ty = cx.tables().node_id_to_type(id_var);\n     let captured_var = Expr {\n         temp_lifetime: temp_lifetime,"}, {"sha": "9ffce18fe150e0c8b52ac54df9164910d5631345", "filename": "src/librustc_mir/hair/cx/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/826d8f3850b37a23481dfcf4a899b5dfc82d22e3/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/826d8f3850b37a23481dfcf4a899b5dfc82d22e3/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs?ref=826d8f3850b37a23481dfcf4a899b5dfc82d22e3", "patch": "@@ -35,7 +35,7 @@ use std::rc::Rc;\n pub struct Cx<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'gcx, 'tcx>,\n     infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n-    pub region_maps: Rc<RegionMaps<'tcx>>,\n+    pub region_maps: Rc<RegionMaps>,\n     constness: hir::Constness,\n \n     /// True if this constant/function needs overflow checks."}, {"sha": "1af9d722599e6e7663e035aa47659a31969d8415", "filename": "src/librustc_mir/hair/mod.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/826d8f3850b37a23481dfcf4a899b5dfc82d22e3/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/826d8f3850b37a23481dfcf4a899b5dfc82d22e3/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fmod.rs?ref=826d8f3850b37a23481dfcf4a899b5dfc82d22e3", "patch": "@@ -32,7 +32,7 @@ pub use rustc_const_eval::pattern::{BindingMode, Pattern, PatternKind, FieldPatt\n #[derive(Clone, Debug)]\n pub struct Block<'tcx> {\n     pub targeted_by_break: bool,\n-    pub extent: CodeExtent<'tcx>,\n+    pub extent: CodeExtent,\n     pub span: Span,\n     pub stmts: Vec<StmtRef<'tcx>>,\n     pub expr: Option<ExprRef<'tcx>>,\n@@ -53,7 +53,7 @@ pub struct Stmt<'tcx> {\n pub enum StmtKind<'tcx> {\n     Expr {\n         /// scope for this statement; may be used as lifetime of temporaries\n-        scope: CodeExtent<'tcx>,\n+        scope: CodeExtent,\n \n         /// expression being evaluated in this statement\n         expr: ExprRef<'tcx>,\n@@ -62,11 +62,11 @@ pub enum StmtKind<'tcx> {\n     Let {\n         /// scope for variables bound in this let; covers this and\n         /// remaining statements in block\n-        remainder_scope: CodeExtent<'tcx>,\n+        remainder_scope: CodeExtent,\n \n         /// scope for the initialization itself; might be used as\n         /// lifetime of temporaries\n-        init_scope: CodeExtent<'tcx>,\n+        init_scope: CodeExtent,\n \n         /// let <PAT> = ...\n         pattern: Pattern<'tcx>,\n@@ -97,7 +97,7 @@ pub struct Expr<'tcx> {\n \n     /// lifetime of this expression if it should be spilled into a\n     /// temporary; should be None only if in a constant context\n-    pub temp_lifetime: Option<CodeExtent<'tcx>>,\n+    pub temp_lifetime: Option<CodeExtent>,\n \n     /// whether this temp lifetime was shrunk by #36082.\n     pub temp_lifetime_was_shrunk: bool,\n@@ -112,12 +112,12 @@ pub struct Expr<'tcx> {\n #[derive(Clone, Debug)]\n pub enum ExprKind<'tcx> {\n     Scope {\n-        extent: CodeExtent<'tcx>,\n+        extent: CodeExtent,\n         value: ExprRef<'tcx>,\n     },\n     Box {\n         value: ExprRef<'tcx>,\n-        value_extents: CodeExtent<'tcx>,\n+        value_extents: CodeExtent,\n     },\n     Call {\n         ty: ty::Ty<'tcx>,\n@@ -210,11 +210,11 @@ pub enum ExprKind<'tcx> {\n         arg: ExprRef<'tcx>,\n     },\n     Break {\n-        label: CodeExtent<'tcx>,\n+        label: CodeExtent,\n         value: Option<ExprRef<'tcx>>,\n     },\n     Continue {\n-        label: CodeExtent<'tcx>,\n+        label: CodeExtent,\n     },\n     Return {\n         value: Option<ExprRef<'tcx>>,"}, {"sha": "6f4480bf6dd16d525bdb54dc8ba02a9f66b2ffa7", "filename": "src/librustc_mir/shim.rs", "status": "modified", "additions": 7, "deletions": 11, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/826d8f3850b37a23481dfcf4a899b5dfc82d22e3/src%2Flibrustc_mir%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/826d8f3850b37a23481dfcf4a899b5dfc82d22e3/src%2Flibrustc_mir%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fshim.rs?ref=826d8f3850b37a23481dfcf4a899b5dfc82d22e3", "patch": "@@ -15,7 +15,7 @@ use rustc::middle::const_val::ConstVal;\n use rustc::mir::*;\n use rustc::mir::transform::MirSource;\n use rustc::ty::{self, Ty};\n-use rustc::ty::subst::{Kind, Subst};\n+use rustc::ty::subst::{Kind, Subst, Substs};\n use rustc::ty::maps::Providers;\n \n use rustc_data_structures::indexed_vec::{IndexVec, Idx};\n@@ -41,8 +41,7 @@ fn make_shim<'a, 'tcx>(tcx: ty::TyCtxt<'a, 'tcx, 'tcx>,\n {\n     debug!(\"make_shim({:?})\", instance);\n     let did = instance.def_id();\n-    let span = tcx.def_span(did);\n-    let param_env = tcx.construct_parameter_environment(span, did, None);\n+    let param_env = tcx.parameter_environment(did);\n \n     let mut result = match instance {\n         ty::InstanceDef::Item(..) =>\n@@ -66,7 +65,6 @@ fn make_shim<'a, 'tcx>(tcx: ty::TyCtxt<'a, 'tcx, 'tcx>,\n \n             build_call_shim(\n                 tcx,\n-                &param_env,\n                 def_id,\n                 adjustment,\n                 CallKind::Indirect,\n@@ -78,7 +76,6 @@ fn make_shim<'a, 'tcx>(tcx: ty::TyCtxt<'a, 'tcx, 'tcx>,\n             // trans::mir knows to turn to an actual virtual call.\n             build_call_shim(\n                 tcx,\n-                &param_env,\n                 def_id,\n                 Adjustment::Identity,\n                 CallKind::Direct(def_id),\n@@ -94,7 +91,6 @@ fn make_shim<'a, 'tcx>(tcx: ty::TyCtxt<'a, 'tcx, 'tcx>,\n \n             build_call_shim(\n                 tcx,\n-                &param_env,\n                 call_once,\n                 Adjustment::RefMut,\n                 CallKind::Direct(call_mut),\n@@ -158,7 +154,7 @@ fn build_drop_shim<'a, 'tcx>(tcx: ty::TyCtxt<'a, 'tcx, 'tcx>,\n     let substs = if let Some(ty) = ty {\n         tcx.mk_substs(iter::once(Kind::from(ty)))\n     } else {\n-        param_env.free_substs\n+        Substs::identity_for_item(tcx, def_id)\n     };\n     let fn_ty = tcx.type_of(def_id).subst(tcx, substs);\n     let sig = tcx.erase_late_bound_regions(&fn_ty.fn_sig());\n@@ -272,7 +268,6 @@ impl<'a, 'tcx> DropElaborator<'a, 'tcx> for DropShimElaborator<'a, 'tcx> {\n /// If `untuple_args` is a vec of types, the second argument of the\n /// function will be untupled as these types.\n fn build_call_shim<'a, 'tcx>(tcx: ty::TyCtxt<'a, 'tcx, 'tcx>,\n-                             param_env: &ty::ParameterEnvironment<'tcx>,\n                              def_id: DefId,\n                              rcvr_adjustment: Adjustment,\n                              call_kind: CallKind,\n@@ -283,7 +278,7 @@ fn build_call_shim<'a, 'tcx>(tcx: ty::TyCtxt<'a, 'tcx, 'tcx>,\n             call_kind={:?}, untuple_args={:?})\",\n            def_id, rcvr_adjustment, call_kind, untuple_args);\n \n-    let fn_ty = tcx.type_of(def_id).subst(tcx, param_env.free_substs);\n+    let fn_ty = tcx.type_of(def_id);\n     let sig = tcx.erase_late_bound_regions(&fn_ty.fn_sig());\n     let span = tcx.def_span(def_id);\n \n@@ -325,9 +320,10 @@ fn build_call_shim<'a, 'tcx>(tcx: ty::TyCtxt<'a, 'tcx, 'tcx>,\n         CallKind::Direct(def_id) => (\n             Operand::Constant(box Constant {\n                 span: span,\n-                ty: tcx.type_of(def_id).subst(tcx, param_env.free_substs),\n+                ty: tcx.type_of(def_id),\n                 literal: Literal::Value {\n-                    value: ConstVal::Function(def_id, param_env.free_substs),\n+                    value: ConstVal::Function(def_id,\n+                        Substs::identity_for_item(tcx, def_id)),\n                 },\n             }),\n             vec![rcvr]"}, {"sha": "e6d62dc6460726365dc560edb3492f74964f5f44", "filename": "src/librustc_mir/transform/inline.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/826d8f3850b37a23481dfcf4a899b5dfc82d22e3/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/826d8f3850b37a23481dfcf4a899b5dfc82d22e3/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Finline.rs?ref=826d8f3850b37a23481dfcf4a899b5dfc82d22e3", "patch": "@@ -219,7 +219,8 @@ impl<'a, 'tcx> Inliner<'a, 'tcx> {\n \n         // FIXME: Give a bonus to functions with only a single caller\n \n-        let param_env = ty::ParameterEnvironment::for_item(tcx, self.source.item_id());\n+        let def_id = tcx.hir.local_def_id(self.source.item_id());\n+        let param_env = tcx.parameter_environment(def_id);\n \n         let mut first_block = true;\n         let mut cost = 0;"}, {"sha": "72edf68f4034c47121332cf54b57d7647115ed56", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/826d8f3850b37a23481dfcf4a899b5dfc82d22e3/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/826d8f3850b37a23481dfcf4a899b5dfc82d22e3/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=826d8f3850b37a23481dfcf4a899b5dfc82d22e3", "patch": "@@ -937,8 +937,7 @@ fn mir_const_qualif<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         return Qualif::NOT_CONST.bits();\n     }\n \n-    let node_id = tcx.hir.as_local_node_id(def_id).unwrap();\n-    let param_env = ty::ParameterEnvironment::for_item(tcx, node_id);\n+    let param_env = tcx.parameter_environment(def_id);\n \n     let mut qualifier = Qualifier::new(tcx, param_env, def_id, mir, Mode::Const);\n     qualifier.qualify_const().bits()\n@@ -966,7 +965,7 @@ impl MirPass for QualifyAndPromoteConstants {\n             MirSource::Const(_) |\n             MirSource::Promoted(..) => return\n         };\n-        let param_env = ty::ParameterEnvironment::for_item(tcx, id);\n+        let param_env = tcx.parameter_environment(def_id);\n \n         if mode == Mode::Fn || mode == Mode::ConstFn {\n             // This is ugly because Qualifier holds onto mir,"}, {"sha": "82c0d2c1b01c6ab3f52f688538c4e87b9d7476f1", "filename": "src/librustc_mir/transform/type_check.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/826d8f3850b37a23481dfcf4a899b5dfc82d22e3/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/826d8f3850b37a23481dfcf4a899b5dfc82d22e3/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs?ref=826d8f3850b37a23481dfcf4a899b5dfc82d22e3", "patch": "@@ -751,7 +751,7 @@ impl MirPass for TypeckMir {\n             // broken MIR, so try not to report duplicate errors.\n             return;\n         }\n-        let param_env = ty::ParameterEnvironment::for_item(tcx, item_id);\n+        let param_env = tcx.parameter_environment(def_id);\n         tcx.infer_ctxt(param_env, Reveal::UserFacing).enter(|infcx| {\n             let mut checker = TypeChecker::new(&infcx, item_id);\n             {"}, {"sha": "9e8352fde80617f1d7fb084e66b5ba1811897a15", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 3, "deletions": 19, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/826d8f3850b37a23481dfcf4a899b5dfc82d22e3/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/826d8f3850b37a23481dfcf4a899b5dfc82d22e3/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=826d8f3850b37a23481dfcf4a899b5dfc82d22e3", "patch": "@@ -41,12 +41,6 @@ pub trait AstConv<'gcx, 'tcx> {\n     fn get_type_parameter_bounds(&self, span: Span, def_id: DefId)\n                                  -> ty::GenericPredicates<'tcx>;\n \n-    /// Return an (optional) substitution to convert bound type parameters that\n-    /// are in scope into free ones. This function should only return Some\n-    /// within a fn body.\n-    /// See ParameterEnvironment::free_substs for more information.\n-    fn get_free_substs(&self) -> Option<&Substs<'tcx>>;\n-\n     /// What lifetime should we use when a lifetime is omitted (and not elided)?\n     fn re_infer(&self, span: Span, _def: Option<&ty::RegionParameterDef>)\n                 -> Option<ty::Region<'tcx>>;\n@@ -121,6 +115,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n             Some(&rl::Region::EarlyBound(index, id)) => {\n                 let name = tcx.hir.name(id);\n                 tcx.mk_region(ty::ReEarlyBound(ty::EarlyBoundRegion {\n+                    def_id: tcx.hir.local_def_id(id),\n                     index: index,\n                     name: name\n                 }))\n@@ -129,7 +124,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n             Some(&rl::Region::Free(scope, id)) => {\n                 let name = tcx.hir.name(id);\n                 tcx.mk_region(ty::ReFree(ty::FreeRegion {\n-                    scope: Some(scope.to_code_extent(tcx)),\n+                    scope,\n                     bound_region: ty::BrNamed(tcx.hir.local_def_id(id), name)\n                 }))\n \n@@ -857,12 +852,6 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                     }\n                 };\n \n-                let trait_ref = if let Some(free_substs) = self.get_free_substs() {\n-                    trait_ref.subst(tcx, free_substs)\n-                } else {\n-                    trait_ref\n-                };\n-\n                 let candidates =\n                     traits::supertraits(tcx, ty::Binder(trait_ref))\n                     .filter(|r| self.trait_defines_associated_type_named(r.def_id(),\n@@ -1020,12 +1009,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                 assert_eq!(opt_self_ty, None);\n                 self.prohibit_type_params(&path.segments);\n \n-                let ty = tcx.at(span).type_of(def_id);\n-                if let Some(free_substs) = self.get_free_substs() {\n-                    ty.subst(tcx, free_substs)\n-                } else {\n-                    ty\n-                }\n+                tcx.at(span).type_of(def_id)\n             }\n             Def::SelfTy(Some(_), None) => {\n                 // Self in trait."}, {"sha": "4c3d5c8aaca7fdffc54382d53bb5e65a59eb965c", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/826d8f3850b37a23481dfcf4a899b5dfc82d22e3/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/826d8f3850b37a23481dfcf4a899b5dfc82d22e3/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=826d8f3850b37a23481dfcf4a899b5dfc82d22e3", "patch": "@@ -15,6 +15,7 @@ use super::{check_fn, Expectation, FnCtxt};\n use astconv::AstConv;\n use rustc::infer::type_variable::TypeVariableOrigin;\n use rustc::ty::{self, ToPolyTraitRef, Ty};\n+use rustc::ty::subst::Substs;\n use std::cmp;\n use std::iter;\n use syntax::abi::Abi;\n@@ -60,21 +61,25 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                          decl,\n                                          Abi::RustCall,\n                                          expected_sig);\n+        // `deduce_expectations_from_expected_type` introduces late-bound\n+        // lifetimes defined elsewhere, which we need to anonymize away.\n+        let sig = self.tcx.anonymize_late_bound_regions(&sig);\n \n         // Create type variables (for now) to represent the transformed\n         // types of upvars. These will be unified during the upvar\n         // inference phase (`upvar.rs`).\n+        let base_substs = Substs::identity_for_item(self.tcx,\n+            self.tcx.closure_base_def_id(expr_def_id));\n         let closure_type = self.tcx.mk_closure(expr_def_id,\n-            self.parameter_environment.free_substs.extend_to(self.tcx, expr_def_id,\n+            base_substs.extend_to(self.tcx, expr_def_id,\n                 |_, _| span_bug!(expr.span, \"closure has region param\"),\n                 |_, _| self.infcx.next_ty_var(TypeVariableOrigin::TransformedUpvar(expr.span))\n             )\n         );\n \n         debug!(\"check_closure: expr.id={:?} closure_type={:?}\", expr.id, closure_type);\n \n-        let extent = self.tcx.call_site_extent(expr.id, body.value.id);\n-        let fn_sig = self.tcx.liberate_late_bound_regions(Some(extent), &sig);\n+        let fn_sig = self.liberate_late_bound_regions(expr_def_id, &sig);\n         let fn_sig = self.inh.normalize_associated_types_in(body.value.span,\n                                                             body.value.id, &fn_sig);\n "}, {"sha": "d9f77e8f04f1ccbfa595b19195f286a8a942b34a", "filename": "src/librustc_typeck/check/compare_method.rs", "status": "modified", "additions": 14, "deletions": 33, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/826d8f3850b37a23481dfcf4a899b5dfc82d22e3/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/826d8f3850b37a23481dfcf4a899b5dfc82d22e3/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs?ref=826d8f3850b37a23481dfcf4a899b5dfc82d22e3", "patch": "@@ -167,16 +167,15 @@ fn compare_predicate_entailment<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     // Create a parameter environment that represents the implementation's\n     // method.\n-    let impl_param_env = ty::ParameterEnvironment::for_item(tcx, impl_m_node_id);\n+    let impl_param_env = tcx.parameter_environment(impl_m.def_id);\n \n     // Create mapping from impl to skolemized.\n-    let impl_to_skol_substs = &impl_param_env.free_substs;\n+    let impl_to_skol_substs = Substs::identity_for_item(tcx, impl_m.def_id);\n \n     // Create mapping from trait to skolemized.\n     let trait_to_skol_substs = impl_to_skol_substs.rebase_onto(tcx,\n                                                                impl_m.container.id(),\n-                                                               trait_to_impl_substs.subst(tcx,\n-                                                                          impl_to_skol_substs));\n+                                                               trait_to_impl_substs);\n     debug!(\"compare_impl_method: trait_to_skol_substs={:?}\",\n            trait_to_skol_substs);\n \n@@ -191,16 +190,15 @@ fn compare_predicate_entailment<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                        impl_m,\n                                        &trait_m_generics,\n                                        &impl_m_generics,\n-                                       trait_to_skol_substs,\n-                                       impl_to_skol_substs)?;\n+                                       trait_to_skol_substs)?;\n \n     // Create obligations for each predicate declared by the impl\n     // definition in the context of the trait's parameter\n     // environment. We can't just use `impl_env.caller_bounds`,\n     // however, because we want to replace all late-bound regions with\n     // region variables.\n     let impl_predicates = tcx.predicates_of(impl_m_predicates.parent.unwrap());\n-    let mut hybrid_preds = impl_predicates.instantiate(tcx, impl_to_skol_substs);\n+    let mut hybrid_preds = impl_predicates.instantiate_identity(tcx);\n \n     debug!(\"compare_impl_method: impl_bounds={:?}\", hybrid_preds);\n \n@@ -226,7 +224,7 @@ fn compare_predicate_entailment<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                                                normalize_cause.clone());\n \n     tcx.infer_ctxt(trait_param_env, Reveal::UserFacing).enter(|infcx| {\n-        let inh = Inherited::new(infcx);\n+        let inh = Inherited::new(infcx, impl_m.def_id);\n         let infcx = &inh.infcx;\n \n         debug!(\"compare_impl_method: caller_bounds={:?}\",\n@@ -273,17 +271,15 @@ fn compare_predicate_entailment<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             infcx.replace_late_bound_regions_with_fresh_var(impl_m_span,\n                                                             infer::HigherRankedType,\n                                                             &m_sig(impl_m));\n-        let impl_sig =\n-            impl_sig.subst(tcx, impl_to_skol_substs);\n         let impl_sig =\n             inh.normalize_associated_types_in(impl_m_span,\n                                               impl_m_node_id,\n                                               &impl_sig);\n         let impl_fty = tcx.mk_fn_ptr(ty::Binder(impl_sig));\n         debug!(\"compare_impl_method: impl_fty={:?}\", impl_fty);\n \n-        let trait_sig = tcx.liberate_late_bound_regions(\n-            infcx.parameter_environment.free_id_outlive,\n+        let trait_sig = inh.liberate_late_bound_regions(\n+            impl_m.def_id,\n             &m_sig(trait_m));\n         let trait_sig =\n             trait_sig.subst(tcx, trait_to_skol_substs);\n@@ -370,21 +366,18 @@ fn check_region_bounds_on_impl_method<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                                 impl_m: &ty::AssociatedItem,\n                                                 trait_generics: &ty::Generics,\n                                                 impl_generics: &ty::Generics,\n-                                                trait_to_skol_substs: &Substs<'tcx>,\n-                                                impl_to_skol_substs: &Substs<'tcx>)\n+                                                trait_to_skol_substs: &Substs<'tcx>)\n                                                 -> Result<(), ErrorReported> {\n     let trait_params = &trait_generics.regions[..];\n     let impl_params = &impl_generics.regions[..];\n \n     debug!(\"check_region_bounds_on_impl_method: \\\n             trait_generics={:?} \\\n             impl_generics={:?} \\\n-            trait_to_skol_substs={:?} \\\n-            impl_to_skol_substs={:?}\",\n+            trait_to_skol_substs={:?}\",\n            trait_generics,\n            impl_generics,\n-           trait_to_skol_substs,\n-           impl_to_skol_substs);\n+           trait_to_skol_substs);\n \n     // Must have same number of early-bound lifetime parameters.\n     // Unfortunately, if the user screws up the bounds, then this\n@@ -726,7 +719,7 @@ pub fn compare_const_impl<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     debug!(\"compare_const_impl(impl_trait_ref={:?})\", impl_trait_ref);\n \n     tcx.infer_ctxt((), Reveal::UserFacing).enter(|infcx| {\n-        let inh = Inherited::new(infcx);\n+        let inh = Inherited::new(infcx, impl_c.def_id);\n         let infcx = &inh.infcx;\n \n         // The below is for the most part highly similar to the procedure\n@@ -739,22 +732,10 @@ pub fn compare_const_impl<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         // Create a parameter environment that represents the implementation's\n         // method.\n         let impl_c_node_id = tcx.hir.as_local_node_id(impl_c.def_id).unwrap();\n-        let impl_param_env = ty::ParameterEnvironment::for_item(tcx, impl_c_node_id);\n-\n-        // Create mapping from impl to skolemized.\n-        let impl_to_skol_substs = &impl_param_env.free_substs;\n-\n-        // Create mapping from trait to skolemized.\n-        let trait_to_skol_substs = impl_to_skol_substs.rebase_onto(tcx,\n-                                                                   impl_c.container.id(),\n-                                                                   trait_to_impl_substs.subst(tcx,\n-                                                                              impl_to_skol_substs));\n-        debug!(\"compare_const_impl: trait_to_skol_substs={:?}\",\n-               trait_to_skol_substs);\n \n         // Compute skolemized form of impl and trait const tys.\n-        let impl_ty = tcx.type_of(impl_c.def_id).subst(tcx, impl_to_skol_substs);\n-        let trait_ty = tcx.type_of(trait_c.def_id).subst(tcx, trait_to_skol_substs);\n+        let impl_ty = tcx.type_of(impl_c.def_id);\n+        let trait_ty = tcx.type_of(trait_c.def_id).subst(tcx, trait_to_impl_substs);\n         let mut cause = ObligationCause::misc(impl_c_span, impl_c_node_id);\n \n         // There is no \"body\" here, so just pass dummy id."}, {"sha": "e029332559635663b46b12b696e9a466aa25dea2", "filename": "src/librustc_typeck/check/dropck.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/826d8f3850b37a23481dfcf4a899b5dfc82d22e3/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/826d8f3850b37a23481dfcf4a899b5dfc82d22e3/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs?ref=826d8f3850b37a23481dfcf4a899b5dfc82d22e3", "patch": "@@ -76,17 +76,15 @@ fn ensure_drop_params_and_item_params_correspond<'a, 'tcx>(\n     -> Result<(), ErrorReported>\n {\n     let drop_impl_node_id = tcx.hir.as_local_node_id(drop_impl_did).unwrap();\n-    let self_type_node_id = tcx.hir.as_local_node_id(self_type_did).unwrap();\n \n     // check that the impl type can be made to match the trait type.\n \n-    let impl_param_env = ty::ParameterEnvironment::for_item(tcx, self_type_node_id);\n+    let impl_param_env = tcx.parameter_environment(self_type_did);\n     tcx.infer_ctxt(impl_param_env, Reveal::UserFacing).enter(|ref infcx| {\n         let tcx = infcx.tcx;\n         let mut fulfillment_cx = traits::FulfillmentContext::new();\n \n         let named_type = tcx.type_of(self_type_did);\n-        let named_type = named_type.subst(tcx, &infcx.parameter_environment.free_substs);\n \n         let drop_impl_span = tcx.def_span(drop_impl_did);\n         let fresh_impl_substs =\n@@ -99,7 +97,7 @@ fn ensure_drop_params_and_item_params_correspond<'a, 'tcx>(\n                 fulfillment_cx.register_predicate_obligations(infcx, obligations);\n             }\n             Err(_) => {\n-                let item_span = tcx.hir.span(self_type_node_id);\n+                let item_span = tcx.def_span(self_type_did);\n                 struct_span_err!(tcx.sess, drop_impl_span, E0366,\n                                  \"Implementations of Drop cannot be specialized\")\n                     .span_note(item_span,\n@@ -272,7 +270,7 @@ pub fn check_safety_of_destructor_if_necessary<'a, 'gcx, 'tcx>(\n     rcx: &mut RegionCtxt<'a, 'gcx, 'tcx>,\n     ty: ty::Ty<'tcx>,\n     span: Span,\n-    scope: region::CodeExtent<'tcx>)\n+    scope: region::CodeExtent)\n     -> Result<(), ErrorReported>\n {\n     debug!(\"check_safety_of_destructor_if_necessary typ: {:?} scope: {:?}\","}, {"sha": "70d2867c08ce624df82e9b7e068b07e7b2476e4d", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 45, "deletions": 17, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/826d8f3850b37a23481dfcf4a899b5dfc82d22e3/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/826d8f3850b37a23481dfcf4a899b5dfc82d22e3/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=826d8f3850b37a23481dfcf4a899b5dfc82d22e3", "patch": "@@ -88,10 +88,10 @@ use hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n use rustc_back::slice::ref_slice;\n use rustc::infer::{self, InferCtxt, InferOk, RegionVariableOrigin};\n use rustc::infer::type_variable::{TypeVariableOrigin};\n+use rustc::middle::region::CodeExtent;\n use rustc::ty::subst::{Kind, Subst, Substs};\n use rustc::traits::{self, FulfillmentContext, ObligationCause, ObligationCauseCode, Reveal};\n-use rustc::ty::{ParamTy, ParameterEnvironment};\n-use rustc::ty::{LvaluePreference, NoPreference, PreferMutLvalue};\n+use rustc::ty::{ParamTy, LvaluePreference, NoPreference, PreferMutLvalue};\n use rustc::ty::{self, Ty, TyCtxt, Visibility};\n use rustc::ty::{MethodCall, MethodCallee};\n use rustc::ty::adjustment::{Adjust, Adjustment, AutoBorrow};\n@@ -177,6 +177,14 @@ pub struct Inherited<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     // variables to get the concrete type, which can be used to\n     // deanonymize TyAnon, after typeck is done with all functions.\n     anon_types: RefCell<NodeMap<Ty<'tcx>>>,\n+\n+    /// Each type parameter has an implicit region bound that\n+    /// indicates it must outlive at least the function body (the user\n+    /// may specify stronger requirements). This field indicates the\n+    /// region of the callee. If it is `None`, then the parameter\n+    /// environment is for an item or something where the \"callee\" is\n+    /// not clear.\n+    implicit_region_bound: Option<ty::Region<'tcx>>,\n }\n \n impl<'a, 'gcx, 'tcx> Deref for Inherited<'a, 'gcx, 'tcx> {\n@@ -523,16 +531,18 @@ impl<'a, 'gcx, 'tcx> Deref for FnCtxt<'a, 'gcx, 'tcx> {\n /// Necessary because we can't write the following bound:\n /// F: for<'b, 'tcx> where 'gcx: 'tcx FnOnce(Inherited<'b, 'gcx, 'tcx>).\n pub struct InheritedBuilder<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n-    infcx: infer::InferCtxtBuilder<'a, 'gcx, 'tcx>\n+    infcx: infer::InferCtxtBuilder<'a, 'gcx, 'tcx>,\n+    def_id: DefId,\n }\n \n impl<'a, 'gcx, 'tcx> Inherited<'a, 'gcx, 'tcx> {\n-    pub fn build(tcx: TyCtxt<'a, 'gcx, 'gcx>, id: ast::NodeId)\n+    pub fn build(tcx: TyCtxt<'a, 'gcx, 'gcx>, def_id: DefId)\n                  -> InheritedBuilder<'a, 'gcx, 'tcx> {\n         let tables = ty::TypeckTables::empty();\n-        let param_env = ParameterEnvironment::for_item(tcx, id);\n+        let param_env = tcx.parameter_environment(def_id);\n         InheritedBuilder {\n-            infcx: tcx.infer_ctxt((tables, param_env), Reveal::UserFacing)\n+            infcx: tcx.infer_ctxt((tables, param_env), Reveal::UserFacing),\n+            def_id,\n         }\n     }\n }\n@@ -541,19 +551,28 @@ impl<'a, 'gcx, 'tcx> InheritedBuilder<'a, 'gcx, 'tcx> {\n     fn enter<F, R>(&'tcx mut self, f: F) -> R\n         where F: for<'b> FnOnce(Inherited<'b, 'gcx, 'tcx>) -> R\n     {\n-        self.infcx.enter(|infcx| f(Inherited::new(infcx)))\n+        let def_id = self.def_id;\n+        self.infcx.enter(|infcx| f(Inherited::new(infcx, def_id)))\n     }\n }\n \n impl<'a, 'gcx, 'tcx> Inherited<'a, 'gcx, 'tcx> {\n-    fn new(infcx: InferCtxt<'a, 'gcx, 'tcx>) -> Self {\n+    fn new(infcx: InferCtxt<'a, 'gcx, 'tcx>, def_id: DefId) -> Self {\n+        let tcx = infcx.tcx;\n+        let item_id = tcx.hir.as_local_node_id(def_id);\n+        let body_id = item_id.and_then(|id| tcx.hir.maybe_body_owned_by(id));\n+        let implicit_region_bound = body_id.map(|body| {\n+            tcx.mk_region(ty::ReScope(CodeExtent::CallSiteScope(body)))\n+        });\n+\n         Inherited {\n             infcx: infcx,\n             fulfillment_cx: RefCell::new(traits::FulfillmentContext::new()),\n             locals: RefCell::new(NodeMap()),\n             deferred_call_resolutions: RefCell::new(DefIdMap()),\n             deferred_cast_checks: RefCell::new(Vec::new()),\n             anon_types: RefCell::new(NodeMap()),\n+            implicit_region_bound,\n         }\n     }\n \n@@ -606,6 +625,22 @@ impl<'a, 'gcx, 'tcx> Inherited<'a, 'gcx, 'tcx> {\n             obligations);\n         InferOk { value, obligations }\n     }\n+\n+    /// Replace any late-bound regions bound in `value` with\n+    /// free variants attached to `all_outlive_scope`.\n+    fn liberate_late_bound_regions<T>(&self,\n+        all_outlive_scope: DefId,\n+        value: &ty::Binder<T>)\n+        -> T\n+        where T: TypeFoldable<'tcx>\n+    {\n+        self.tcx.replace_late_bound_regions(value, |br| {\n+            self.tcx.mk_region(ty::ReFree(ty::FreeRegion {\n+                scope: all_outlive_scope,\n+                bound_region: br\n+            }))\n+        }).0\n+    }\n }\n \n struct CheckItemTypesVisitor<'a, 'tcx: 'a> { tcx: TyCtxt<'a, 'tcx, 'tcx> }\n@@ -772,18 +807,15 @@ fn typeck_tables_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     });\n     let body = tcx.hir.body(body_id);\n \n-    Inherited::build(tcx, id).enter(|inh| {\n+    Inherited::build(tcx, def_id).enter(|inh| {\n         let fcx = if let Some(decl) = fn_decl {\n             let fn_sig = tcx.type_of(def_id).fn_sig();\n \n             check_abi(tcx, span, fn_sig.abi());\n \n             // Compute the fty from point of view of inside fn.\n-            let fn_scope = inh.tcx.call_site_extent(id, body_id.node_id);\n-            let fn_sig =\n-                fn_sig.subst(inh.tcx, &inh.parameter_environment.free_substs);\n             let fn_sig =\n-                inh.tcx.liberate_late_bound_regions(Some(fn_scope), &fn_sig);\n+                inh.liberate_late_bound_regions(def_id, &fn_sig);\n             let fn_sig =\n                 inh.normalize_associated_types_in(body.value.span, body_id.node_id, &fn_sig);\n \n@@ -1518,10 +1550,6 @@ pub fn check_enum<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n impl<'a, 'gcx, 'tcx> AstConv<'gcx, 'tcx> for FnCtxt<'a, 'gcx, 'tcx> {\n     fn tcx<'b>(&'b self) -> TyCtxt<'b, 'gcx, 'tcx> { self.tcx }\n \n-    fn get_free_substs(&self) -> Option<&Substs<'tcx>> {\n-        Some(&self.parameter_environment.free_substs)\n-    }\n-\n     fn get_type_parameter_bounds(&self, _: Span, def_id: DefId)\n                                  -> ty::GenericPredicates<'tcx>\n     {"}, {"sha": "754bd288bfaa70c995624c1358dbc3ffcd7e284f", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 17, "deletions": 18, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/826d8f3850b37a23481dfcf4a899b5dfc82d22e3/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/826d8f3850b37a23481dfcf4a899b5dfc82d22e3/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=826d8f3850b37a23481dfcf4a899b5dfc82d22e3", "patch": "@@ -87,7 +87,7 @@ use check::FnCtxt;\n use middle::free_region::FreeRegionMap;\n use middle::mem_categorization as mc;\n use middle::mem_categorization::Categorization;\n-use middle::region::{self, CodeExtent, RegionMaps};\n+use middle::region::{CodeExtent, RegionMaps};\n use rustc::hir::def_id::DefId;\n use rustc::ty::subst::Substs;\n use rustc::traits;\n@@ -178,15 +178,15 @@ pub struct RegionCtxt<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n \n     region_bound_pairs: Vec<(ty::Region<'tcx>, GenericKind<'tcx>)>,\n \n-    pub region_maps: Rc<RegionMaps<'tcx>>,\n+    pub region_maps: Rc<RegionMaps>,\n \n     free_region_map: FreeRegionMap<'tcx>,\n \n     // id of innermost fn body id\n     body_id: ast::NodeId,\n \n     // call_site scope of innermost fn\n-    call_site_scope: Option<CodeExtent<'tcx>>,\n+    call_site_scope: Option<CodeExtent>,\n \n     // id of innermost fn or loop\n     repeating_scope: ast::NodeId,\n@@ -224,8 +224,8 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    fn set_call_site_scope(&mut self, call_site_scope: Option<CodeExtent<'tcx>>)\n-                           -> Option<CodeExtent<'tcx>> {\n+    fn set_call_site_scope(&mut self, call_site_scope: Option<CodeExtent>)\n+                           -> Option<CodeExtent> {\n         mem::replace(&mut self.call_site_scope, call_site_scope)\n     }\n \n@@ -286,8 +286,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n \n         let body_id = body.id();\n \n-        let call_site = self.tcx.intern_code_extent(\n-            region::CodeExtentData::CallSiteScope { fn_id: id, body_id: body_id.node_id });\n+        let call_site = CodeExtent::CallSiteScope(body_id);\n         let old_call_site_scope = self.set_call_site_scope(Some(call_site));\n \n         let fn_sig = {\n@@ -312,7 +311,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n \n         let old_body_id = self.set_body_id(body_id.node_id);\n         self.relate_free_regions(&fn_sig_tys[..], body_id.node_id, span);\n-        self.link_fn_args(self.tcx.node_extent(body_id.node_id), &body.arguments);\n+        self.link_fn_args(CodeExtent::Misc(body_id.node_id), &body.arguments);\n         self.visit_body(body);\n         self.visit_region_obligations(body_id.node_id);\n \n@@ -398,9 +397,11 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n             for implication in implied_bounds {\n                 debug!(\"implication: {:?}\", implication);\n                 match implication {\n-                    ImpliedBound::RegionSubRegion(&ty::ReFree(free_a),\n+                    ImpliedBound::RegionSubRegion(r_a @ &ty::ReEarlyBound(_),\n+                                                  &ty::ReVar(vid_b)) |\n+                    ImpliedBound::RegionSubRegion(r_a @ &ty::ReFree(_),\n                                                   &ty::ReVar(vid_b)) => {\n-                        self.add_given(free_a, vid_b);\n+                        self.add_given(r_a, vid_b);\n                     }\n                     ImpliedBound::RegionSubParam(r_a, param_b) => {\n                         self.region_bound_pairs.push((r_a, GenericKind::Param(param_b)));\n@@ -876,7 +877,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n         // call occurs.\n         //\n         // FIXME(#6268) to support nested method calls, should be callee_id\n-        let callee_scope = self.tcx.node_extent(call_expr.id);\n+        let callee_scope = CodeExtent::Misc(call_expr.id);\n         let callee_region = self.tcx.mk_region(ty::ReScope(callee_scope));\n \n         debug!(\"callee_region={:?}\", callee_region);\n@@ -1029,7 +1030,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n         debug!(\"constrain_index(index_expr=?, indexed_ty={}\",\n                self.ty_to_string(indexed_ty));\n \n-        let r_index_expr = ty::ReScope(self.tcx.node_extent(index_expr.id));\n+        let r_index_expr = ty::ReScope(CodeExtent::Misc(index_expr.id));\n         if let ty::TyRef(r_ptr, mt) = indexed_ty.sty {\n             match mt.ty.sty {\n                 ty::TySlice(_) | ty::TyStr => {\n@@ -1109,7 +1110,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n     /// Computes the guarantors for any ref bindings in a match and\n     /// then ensures that the lifetime of the resulting pointer is\n     /// linked to the lifetime of its guarantor (if any).\n-    fn link_fn_args(&self, body_scope: CodeExtent<'tcx>, args: &[hir::Arg]) {\n+    fn link_fn_args(&self, body_scope: CodeExtent, args: &[hir::Arg]) {\n         debug!(\"regionck::link_fn_args(body_scope={:?})\", body_scope);\n         let mc = &mc::MemCategorizationContext::new(self, &self.region_maps);\n         for arg in args {\n@@ -1175,7 +1176,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n     /// must outlive `callee_scope`.\n     fn link_by_ref(&self,\n                    expr: &hir::Expr,\n-                   callee_scope: CodeExtent<'tcx>) {\n+                   callee_scope: CodeExtent) {\n         debug!(\"link_by_ref(expr={:?}, callee_scope={:?})\",\n                expr, callee_scope);\n         let mc = mc::MemCategorizationContext::new(self, &self.region_maps);\n@@ -1613,16 +1614,14 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     fn param_bound(&self, param_ty: ty::ParamTy) -> VerifyBound<'tcx> {\n-        let param_env = &self.parameter_environment;\n-\n         debug!(\"param_bound(param_ty={:?})\",\n                param_ty);\n \n         let mut param_bounds = self.declared_generic_bounds_from_env(GenericKind::Param(param_ty));\n \n         // Add in the default bound of fn body that applies to all in\n         // scope type parameters:\n-        param_bounds.extend(param_env.implicit_region_bound);\n+        param_bounds.extend(self.implicit_region_bound);\n \n         VerifyBound::AnyRegion(param_bounds)\n     }\n@@ -1667,7 +1666,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n         }\n \n         let mut regions = ty.regions();\n-        regions.retain(|r| !r.is_bound()); // ignore late-bound regions\n+        regions.retain(|r| !r.is_late_bound()); // ignore late-bound regions\n         bounds.push(VerifyBound::AllRegions(regions));\n \n         // remove bounds that must hold, since they are not interesting"}, {"sha": "6895d7386256247d96527d88fa6bb42902c5ea13", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 38, "deletions": 54, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/826d8f3850b37a23481dfcf4a899b5dfc82d22e3/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/826d8f3850b37a23481dfcf4a899b5dfc82d22e3/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=826d8f3850b37a23481dfcf4a899b5dfc82d22e3", "patch": "@@ -13,7 +13,6 @@ use check::{Inherited, FnCtxt};\n use constrained_type_params::{identify_constrained_type_params, Parameter};\n \n use hir::def_id::DefId;\n-use middle::region::{CodeExtent};\n use rustc::traits::{self, ObligationCauseCode};\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::util::nodemap::{FxHashSet, FxHashMap};\n@@ -117,8 +116,8 @@ impl<'a, 'gcx> CheckTypeWellFormedVisitor<'a, 'gcx> {\n                     error_192(tcx, item.span);\n                 }\n             }\n-            hir::ItemFn(.., body_id) => {\n-                self.check_item_fn(item, body_id);\n+            hir::ItemFn(..) => {\n+                self.check_item_fn(item);\n             }\n             hir::ItemStatic(..) => {\n                 self.check_item_type(item);\n@@ -160,9 +159,6 @@ impl<'a, 'gcx> CheckTypeWellFormedVisitor<'a, 'gcx> {\n                              sig_if_method: Option<&hir::MethodSig>) {\n         let code = self.code.clone();\n         self.for_id(item_id, span).with_fcx(|fcx, this| {\n-            let free_substs = &fcx.parameter_environment.free_substs;\n-            let free_id_outlive = fcx.parameter_environment.free_id_outlive;\n-\n             let item = fcx.tcx.associated_item(fcx.tcx.hir.local_def_id(item_id));\n \n             let (mut implied_bounds, self_ty) = match item.container {\n@@ -174,25 +170,26 @@ impl<'a, 'gcx> CheckTypeWellFormedVisitor<'a, 'gcx> {\n             match item.kind {\n                 ty::AssociatedKind::Const => {\n                     let ty = fcx.tcx.type_of(item.def_id);\n-                    let ty = fcx.instantiate_type_scheme(span, free_substs, &ty);\n+                    let ty = fcx.normalize_associated_types_in(span, &ty);\n                     fcx.register_wf_obligation(ty, span, code.clone());\n                 }\n                 ty::AssociatedKind::Method => {\n                     reject_shadowing_type_parameters(fcx.tcx, item.def_id);\n                     let method_ty = fcx.tcx.type_of(item.def_id);\n-                    let method_ty = fcx.instantiate_type_scheme(span, free_substs, &method_ty);\n-                    let predicates = fcx.instantiate_bounds(span, item.def_id, free_substs);\n+                    let method_ty = fcx.normalize_associated_types_in(span, &method_ty);\n+                    let predicates = fcx.tcx.predicates_of(item.def_id)\n+                        .instantiate_identity(fcx.tcx);\n+                    let predicates = fcx.normalize_associated_types_in(span, &predicates);\n                     let sig = method_ty.fn_sig();\n                     this.check_fn_or_method(fcx, span, sig, &predicates,\n-                                            free_id_outlive, &mut implied_bounds);\n+                                            item.def_id, &mut implied_bounds);\n                     let sig_if_method = sig_if_method.expect(\"bad signature for method\");\n-                    this.check_method_receiver(fcx, sig_if_method, &item,\n-                                               free_id_outlive, self_ty);\n+                    this.check_method_receiver(fcx, sig_if_method, &item, self_ty);\n                 }\n                 ty::AssociatedKind::Type => {\n                     if item.defaultness.has_value() {\n                         let ty = fcx.tcx.type_of(item.def_id);\n-                        let ty = fcx.instantiate_type_scheme(span, free_substs, &ty);\n+                        let ty = fcx.normalize_associated_types_in(span, &ty);\n                         fcx.register_wf_obligation(ty, span, code.clone());\n                     }\n                 }\n@@ -210,7 +207,7 @@ impl<'a, 'gcx> CheckTypeWellFormedVisitor<'a, 'gcx> {\n     fn for_id<'tcx>(&self, id: ast::NodeId, span: Span)\n                     -> CheckWfFcxBuilder<'a, 'gcx, 'tcx> {\n         CheckWfFcxBuilder {\n-            inherited: Inherited::build(self.tcx, id),\n+            inherited: Inherited::build(self.tcx, self.tcx.hir.local_def_id(id)),\n             code: self.code.clone(),\n             id: id,\n             span: span\n@@ -242,9 +239,9 @@ impl<'a, 'gcx> CheckTypeWellFormedVisitor<'a, 'gcx> {\n                 }\n             }\n \n-            let free_substs = &fcx.parameter_environment.free_substs;\n             let def_id = fcx.tcx.hir.local_def_id(item.id);\n-            let predicates = fcx.instantiate_bounds(item.span, def_id, free_substs);\n+            let predicates = fcx.tcx.predicates_of(def_id).instantiate_identity(fcx.tcx);\n+            let predicates = fcx.normalize_associated_types_in(item.span, &predicates);\n             this.check_where_clauses(fcx, item.span, &predicates);\n \n             vec![] // no implied bounds in a struct def'n\n@@ -320,30 +317,26 @@ impl<'a, 'gcx> CheckTypeWellFormedVisitor<'a, 'gcx> {\n         }\n \n         self.for_item(item).with_fcx(|fcx, this| {\n-            let free_substs = &fcx.parameter_environment.free_substs;\n-            let predicates = fcx.instantiate_bounds(item.span, trait_def_id, free_substs);\n+            let predicates = fcx.tcx.predicates_of(trait_def_id).instantiate_identity(fcx.tcx);\n+            let predicates = fcx.normalize_associated_types_in(item.span, &predicates);\n             this.check_where_clauses(fcx, item.span, &predicates);\n             vec![]\n         });\n     }\n \n-    fn check_item_fn(&mut self,\n-                     item: &hir::Item,\n-                     body_id: hir::BodyId)\n-    {\n+    fn check_item_fn(&mut self, item: &hir::Item) {\n         self.for_item(item).with_fcx(|fcx, this| {\n-            let free_substs = &fcx.parameter_environment.free_substs;\n             let def_id = fcx.tcx.hir.local_def_id(item.id);\n             let ty = fcx.tcx.type_of(def_id);\n-            let item_ty = fcx.instantiate_type_scheme(item.span, free_substs, &ty);\n+            let item_ty = fcx.normalize_associated_types_in(item.span, &ty);\n             let sig = item_ty.fn_sig();\n \n-            let predicates = fcx.instantiate_bounds(item.span, def_id, free_substs);\n+            let predicates = fcx.tcx.predicates_of(def_id).instantiate_identity(fcx.tcx);\n+            let predicates = fcx.normalize_associated_types_in(item.span, &predicates);\n \n             let mut implied_bounds = vec![];\n-            let free_id_outlive = fcx.tcx.call_site_extent(item.id, body_id.node_id);\n             this.check_fn_or_method(fcx, item.span, sig, &predicates,\n-                                    Some(free_id_outlive), &mut implied_bounds);\n+                                    def_id, &mut implied_bounds);\n             implied_bounds\n         })\n     }\n@@ -355,10 +348,7 @@ impl<'a, 'gcx> CheckTypeWellFormedVisitor<'a, 'gcx> {\n \n         self.for_item(item).with_fcx(|fcx, this| {\n             let ty = fcx.tcx.type_of(fcx.tcx.hir.local_def_id(item.id));\n-            let item_ty = fcx.instantiate_type_scheme(item.span,\n-                                                      &fcx.parameter_environment\n-                                                          .free_substs,\n-                                                      &ty);\n+            let item_ty = fcx.normalize_associated_types_in(item.span, &ty);\n \n             fcx.register_wf_obligation(item_ty, item.span, this.code.clone());\n \n@@ -374,15 +364,14 @@ impl<'a, 'gcx> CheckTypeWellFormedVisitor<'a, 'gcx> {\n         debug!(\"check_impl: {:?}\", item);\n \n         self.for_item(item).with_fcx(|fcx, this| {\n-            let free_substs = &fcx.parameter_environment.free_substs;\n             let item_def_id = fcx.tcx.hir.local_def_id(item.id);\n \n             match *ast_trait_ref {\n                 Some(ref ast_trait_ref) => {\n                     let trait_ref = fcx.tcx.impl_trait_ref(item_def_id).unwrap();\n                     let trait_ref =\n-                        fcx.instantiate_type_scheme(\n-                            ast_trait_ref.path.span, free_substs, &trait_ref);\n+                        fcx.normalize_associated_types_in(\n+                            ast_trait_ref.path.span, &trait_ref);\n                     let obligations =\n                         ty::wf::trait_obligations(fcx,\n                                                   fcx.body_id,\n@@ -394,12 +383,13 @@ impl<'a, 'gcx> CheckTypeWellFormedVisitor<'a, 'gcx> {\n                 }\n                 None => {\n                     let self_ty = fcx.tcx.type_of(item_def_id);\n-                    let self_ty = fcx.instantiate_type_scheme(item.span, free_substs, &self_ty);\n+                    let self_ty = fcx.normalize_associated_types_in(item.span, &self_ty);\n                     fcx.register_wf_obligation(self_ty, ast_self_ty.span, this.code.clone());\n                 }\n             }\n \n-            let predicates = fcx.instantiate_bounds(item.span, item_def_id, free_substs);\n+            let predicates = fcx.tcx.predicates_of(item_def_id).instantiate_identity(fcx.tcx);\n+            let predicates = fcx.normalize_associated_types_in(item.span, &predicates);\n             this.check_where_clauses(fcx, item.span, &predicates);\n \n             fcx.impl_implied_bounds(item_def_id, item.span)\n@@ -429,12 +419,11 @@ impl<'a, 'gcx> CheckTypeWellFormedVisitor<'a, 'gcx> {\n                                       span: Span,\n                                       sig: ty::PolyFnSig<'tcx>,\n                                       predicates: &ty::InstantiatedPredicates<'tcx>,\n-                                      free_id_outlive: Option<CodeExtent<'tcx>>,\n+                                      def_id: DefId,\n                                       implied_bounds: &mut Vec<Ty<'tcx>>)\n     {\n-        let free_substs = &fcx.parameter_environment.free_substs;\n-        let sig = fcx.instantiate_type_scheme(span, free_substs, &sig);\n-        let sig = fcx.tcx.liberate_late_bound_regions(free_id_outlive, &sig);\n+        let sig = fcx.normalize_associated_types_in(span, &sig);\n+        let sig = fcx.liberate_late_bound_regions(def_id, &sig);\n \n         for input_ty in sig.inputs() {\n             fcx.register_wf_obligation(&input_ty, span, self.code.clone());\n@@ -453,7 +442,6 @@ impl<'a, 'gcx> CheckTypeWellFormedVisitor<'a, 'gcx> {\n                                          fcx: &FnCtxt<'fcx, 'gcx, 'tcx>,\n                                          method_sig: &hir::MethodSig,\n                                          method: &ty::AssociatedItem,\n-                                         free_id_outlive: Option<CodeExtent<'tcx>>,\n                                          self_ty: ty::Ty<'tcx>)\n     {\n         // check that the type of the method's receiver matches the\n@@ -467,10 +455,9 @@ impl<'a, 'gcx> CheckTypeWellFormedVisitor<'a, 'gcx> {\n \n         let span = method_sig.decl.inputs[0].span;\n \n-        let free_substs = &fcx.parameter_environment.free_substs;\n         let method_ty = fcx.tcx.type_of(method.def_id);\n-        let fty = fcx.instantiate_type_scheme(span, free_substs, &method_ty);\n-        let sig = fcx.tcx.liberate_late_bound_regions(free_id_outlive, &fty.fn_sig());\n+        let fty = fcx.normalize_associated_types_in(span, &method_ty);\n+        let sig = fcx.liberate_late_bound_regions(method.def_id, &fty.fn_sig());\n \n         debug!(\"check_method_receiver: sig={:?}\", sig);\n \n@@ -485,9 +472,9 @@ impl<'a, 'gcx> CheckTypeWellFormedVisitor<'a, 'gcx> {\n             }\n             ExplicitSelf::ByBox => fcx.tcx.mk_box(self_ty)\n         };\n-        let rcvr_ty = fcx.instantiate_type_scheme(span, free_substs, &rcvr_ty);\n-        let rcvr_ty = fcx.tcx.liberate_late_bound_regions(free_id_outlive,\n-                                                          &ty::Binder(rcvr_ty));\n+        let rcvr_ty = fcx.normalize_associated_types_in(span, &rcvr_ty);\n+        let rcvr_ty = fcx.liberate_late_bound_regions(method.def_id,\n+                                                      &ty::Binder(rcvr_ty));\n \n         debug!(\"check_method_receiver: receiver ty = {:?}\", rcvr_ty);\n \n@@ -632,10 +619,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             struct_def.fields().iter()\n             .map(|field| {\n                 let field_ty = self.tcx.type_of(self.tcx.hir.local_def_id(field.id));\n-                let field_ty = self.instantiate_type_scheme(field.span,\n-                                                            &self.parameter_environment\n-                                                                 .free_substs,\n-                                                            &field_ty);\n+                let field_ty = self.normalize_associated_types_in(field.span,\n+                                                                  &field_ty);\n                 AdtField { ty: field_ty, span: field.span }\n             })\n             .collect();\n@@ -649,19 +634,18 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     fn impl_implied_bounds(&self, impl_def_id: DefId, span: Span) -> Vec<Ty<'tcx>> {\n-        let free_substs = &self.parameter_environment.free_substs;\n         match self.tcx.impl_trait_ref(impl_def_id) {\n             Some(ref trait_ref) => {\n                 // Trait impl: take implied bounds from all types that\n                 // appear in the trait reference.\n-                let trait_ref = self.instantiate_type_scheme(span, free_substs, trait_ref);\n+                let trait_ref = self.normalize_associated_types_in(span, trait_ref);\n                 trait_ref.substs.types().collect()\n             }\n \n             None => {\n                 // Inherent impl: take implied bounds from the self type.\n                 let self_ty = self.tcx.type_of(impl_def_id);\n-                let self_ty = self.instantiate_type_scheme(span, free_substs, &self_ty);\n+                let self_ty = self.normalize_associated_types_in(span, &self_ty);\n                 vec![self_ty]\n             }\n         }"}, {"sha": "b43e2423757d1faef9df751445363881339760d5", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 8, "deletions": 52, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/826d8f3850b37a23481dfcf4a899b5dfc82d22e3/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/826d8f3850b37a23481dfcf4a899b5dfc82d22e3/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=826d8f3850b37a23481dfcf4a899b5dfc82d22e3", "patch": "@@ -19,7 +19,7 @@ use rustc::infer::{InferCtxt};\n use rustc::ty::{self, Ty, TyCtxt, MethodCall, MethodCallee};\n use rustc::ty::adjustment;\n use rustc::ty::fold::{TypeFolder,TypeFoldable};\n-use rustc::util::nodemap::{DefIdMap, DefIdSet};\n+use rustc::util::nodemap::DefIdSet;\n use syntax::ast;\n use syntax_pos::Span;\n use std::mem;\n@@ -71,55 +71,17 @@ struct WritebackCx<'cx, 'gcx: 'cx+'tcx, 'tcx: 'cx> {\n \n     tables: ty::TypeckTables<'gcx>,\n \n-    // Mapping from free regions of the function to the\n-    // early-bound versions of them, visible from the\n-    // outside of the function. This is needed by, and\n-    // only populated if there are any `impl Trait`.\n-    free_to_bound_regions: DefIdMap<ty::Region<'gcx>>,\n-\n     body: &'gcx hir::Body,\n }\n \n impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n     fn new(fcx: &'cx FnCtxt<'cx, 'gcx, 'tcx>, body: &'gcx hir::Body)\n         -> WritebackCx<'cx, 'gcx, 'tcx> {\n-        let mut wbcx = WritebackCx {\n+        WritebackCx {\n             fcx: fcx,\n             tables: ty::TypeckTables::empty(),\n-            free_to_bound_regions: DefIdMap(),\n             body: body\n-        };\n-\n-        // Only build the reverse mapping if `impl Trait` is used.\n-        if fcx.anon_types.borrow().is_empty() {\n-            return wbcx;\n         }\n-\n-        let gcx = fcx.tcx.global_tcx();\n-        let free_substs = fcx.parameter_environment.free_substs;\n-        for (i, k) in free_substs.iter().enumerate() {\n-            let r = if let Some(r) = k.as_region() {\n-                r\n-            } else {\n-                continue;\n-            };\n-            match *r {\n-                ty::ReFree(ty::FreeRegion {\n-                    bound_region: ty::BoundRegion::BrNamed(def_id, name), ..\n-                }) => {\n-                    let bound_region = gcx.mk_region(ty::ReEarlyBound(ty::EarlyBoundRegion {\n-                        index: i as u32,\n-                        name: name,\n-                    }));\n-                    wbcx.free_to_bound_regions.insert(def_id, bound_region);\n-                }\n-                _ => {\n-                    bug!(\"{:?} is not a free region for an early-bound lifetime\", r);\n-                }\n-            }\n-        }\n-\n-        wbcx\n     }\n \n     fn tcx(&self) -> TyCtxt<'cx, 'gcx, 'tcx> {\n@@ -285,22 +247,16 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n             let inside_ty = self.resolve(&concrete_ty, &node_id);\n \n             // Convert the type from the function into a type valid outside\n-            // the function, by replacing free regions with early-bound ones.\n+            // the function, by replacing invalid regions with 'static,\n+            // after producing an error for each of them.\n             let outside_ty = gcx.fold_regions(&inside_ty, &mut false, |r, _| {\n                 match *r {\n-                    // 'static is valid everywhere.\n-                    ty::ReStatic => gcx.types.re_static,\n-                    ty::ReEmpty => gcx.types.re_empty,\n-\n-                    // Free regions that come from early-bound regions are valid.\n-                    ty::ReFree(ty::FreeRegion {\n-                        bound_region: ty::BoundRegion::BrNamed(def_id, ..), ..\n-                    }) if self.free_to_bound_regions.contains_key(&def_id) => {\n-                        self.free_to_bound_regions[&def_id]\n-                    }\n+                    // 'static and early-bound regions are valid.\n+                    ty::ReStatic |\n+                    ty::ReEarlyBound(_) |\n+                    ty::ReEmpty => r,\n \n                     ty::ReFree(_) |\n-                    ty::ReEarlyBound(_) |\n                     ty::ReLateBound(..) |\n                     ty::ReScope(_) |\n                     ty::ReSkolemized(..) => {"}, {"sha": "d40a68e605690d880e34c4bd24a73dafd7004ff1", "filename": "src/librustc_typeck/coherence/builtin.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/826d8f3850b37a23481dfcf4a899b5dfc82d22e3/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/826d8f3850b37a23481dfcf4a899b5dfc82d22e3/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs?ref=826d8f3850b37a23481dfcf4a899b5dfc82d22e3", "patch": "@@ -17,10 +17,8 @@ use rustc::middle::lang_items::UnsizeTraitLangItem;\n \n use rustc::traits::{self, ObligationCause, Reveal};\n use rustc::ty::{self, Ty, TyCtxt};\n-use rustc::ty::ParameterEnvironment;\n use rustc::ty::TypeFoldable;\n use rustc::ty::adjustment::CoerceUnsizedInfo;\n-use rustc::ty::subst::Subst;\n use rustc::ty::util::CopyImplementationError;\n use rustc::infer;\n \n@@ -107,8 +105,7 @@ fn visit_implementation_of_copy<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n            self_type);\n \n     let span = tcx.hir.span(impl_node_id);\n-    let param_env = ParameterEnvironment::for_item(tcx, impl_node_id);\n-    let self_type = self_type.subst(tcx, &param_env.free_substs);\n+    let param_env = tcx.parameter_environment(impl_did);\n     assert!(!self_type.has_escaping_regions());\n \n     debug!(\"visit_implementation_of_copy: self_type={:?} (free)\",\n@@ -202,9 +199,7 @@ pub fn coerce_unsized_info<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n            target);\n \n     let span = tcx.hir.span(impl_node_id);\n-    let param_env = ParameterEnvironment::for_item(tcx, impl_node_id);\n-    let source = source.subst(tcx, &param_env.free_substs);\n-    let target = target.subst(tcx, &param_env.free_substs);\n+    let param_env = tcx.parameter_environment(impl_did);\n     assert!(!source.has_escaping_regions());\n \n     let err_info = CoerceUnsizedInfo { custom_kind: None };"}, {"sha": "7c6c70024ce9e2453131fa7c4856e16e33e6fd09", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/826d8f3850b37a23481dfcf4a899b5dfc82d22e3/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/826d8f3850b37a23481dfcf4a899b5dfc82d22e3/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=826d8f3850b37a23481dfcf4a899b5dfc82d22e3", "patch": "@@ -205,10 +205,6 @@ impl<'a, 'tcx> AstConv<'tcx, 'tcx> for ItemCtxt<'a, 'tcx> {\n         self.tcx.at(span).type_param_predicates((self.item_def_id, def_id))\n     }\n \n-    fn get_free_substs(&self) -> Option<&Substs<'tcx>> {\n-        None\n-    }\n-\n     fn re_infer(&self, _span: Span, _def: Option<&ty::RegionParameterDef>)\n                 -> Option<ty::Region<'tcx>> {\n         None\n@@ -1299,6 +1295,7 @@ fn predicates_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let mut index = parent_count + has_own_self as u32;\n     for param in early_bound_lifetimes_from_generics(tcx, ast_generics) {\n         let region = tcx.mk_region(ty::ReEarlyBound(ty::EarlyBoundRegion {\n+            def_id: tcx.hir.local_def_id(param.lifetime.id),\n             index: index,\n             name: param.lifetime.name\n         }));"}, {"sha": "61f941e57b2d8c6a61481e6ba7c819d0ded0604d", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/826d8f3850b37a23481dfcf4a899b5dfc82d22e3/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/826d8f3850b37a23481dfcf4a899b5dfc82d22e3/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=826d8f3850b37a23481dfcf4a899b5dfc82d22e3", "patch": "@@ -820,7 +820,7 @@ impl Clean<Lifetime> for ty::RegionParameterDef {\n     }\n }\n \n-impl<'tcx> Clean<Option<Lifetime>> for ty::RegionKind<'tcx> {\n+impl Clean<Option<Lifetime>> for ty::RegionKind {\n     fn clean(&self, cx: &DocContext) -> Option<Lifetime> {\n         match *self {\n             ty::ReStatic => Some(Lifetime::statik()),"}, {"sha": "22e7de3838dc153a89f3bde569ef2ebcb45eb2c6", "filename": "src/test/compile-fail/issue-27942.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/826d8f3850b37a23481dfcf4a899b5dfc82d22e3/src%2Ftest%2Fcompile-fail%2Fissue-27942.rs", "raw_url": "https://github.com/rust-lang/rust/raw/826d8f3850b37a23481dfcf4a899b5dfc82d22e3/src%2Ftest%2Fcompile-fail%2Fissue-27942.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-27942.rs?ref=826d8f3850b37a23481dfcf4a899b5dfc82d22e3", "patch": "@@ -11,17 +11,18 @@\n pub trait Resources<'a> {}\n \n pub trait Buffer<'a, R: Resources<'a>> {\n+    //~^ NOTE the lifetime 'a as defined on the trait at 13:0...\n+    //~| NOTE ...does not necessarily outlive the lifetime 'a as defined on the trait\n+\n     fn select(&self) -> BufferViewHandle<R>;\n     //~^ ERROR mismatched types\n     //~| lifetime mismatch\n     //~| NOTE expected type `Resources<'_>`\n-    //~| NOTE the lifetime 'a as defined on the method body at 14:4...\n     //~| NOTE ...does not necessarily outlive the anonymous lifetime #1 defined on the method body\n     //~| ERROR mismatched types\n     //~| lifetime mismatch\n     //~| NOTE expected type `Resources<'_>`\n-    //~| NOTE the anonymous lifetime #1 defined on the method body at 14:4...\n-    //~| NOTE ...does not necessarily outlive the lifetime 'a as defined on the method body\n+    //~| NOTE the anonymous lifetime #1 defined on the method body at 17:4...\n }\n \n pub struct BufferViewHandle<'a, R: 'a+Resources<'a>>(&'a R);"}, {"sha": "6313293bf2b6aae8e42fdcb9ba8cadb45c71e2a7", "filename": "src/test/compile-fail/issue-37884.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/826d8f3850b37a23481dfcf4a899b5dfc82d22e3/src%2Ftest%2Fcompile-fail%2Fissue-37884.rs", "raw_url": "https://github.com/rust-lang/rust/raw/826d8f3850b37a23481dfcf4a899b5dfc82d22e3/src%2Ftest%2Fcompile-fail%2Fissue-37884.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-37884.rs?ref=826d8f3850b37a23481dfcf4a899b5dfc82d22e3", "patch": "@@ -11,14 +11,15 @@\n struct RepeatMut<'a, T>(T, &'a ());\n \n impl<'a, T: 'a> Iterator for RepeatMut<'a, T> {\n+    //~^ NOTE ...does not necessarily outlive the lifetime 'a as defined on the impl\n+\n     type Item = &'a mut T;\n     fn next(&'a mut self) -> Option<Self::Item>\n     //~^ ERROR method not compatible with trait\n     //~| lifetime mismatch\n     //~| NOTE expected type `fn(&mut RepeatMut<'a, T>) -> std::option::Option<&mut T>`\n+    //~| NOTE the anonymous lifetime #1 defined on the method body\n     {\n-    //~^ NOTE the anonymous lifetime #1 defined on the body\n-    //~| NOTE ...does not necessarily outlive the lifetime 'a as defined on the body\n         Some(&mut self.0)\n     }\n }"}, {"sha": "55723ee8cd96416c7bcc572eff46b387c77519a4", "filename": "src/test/ui/lifetime-errors/ex1-return-one-existing-name-if-else.stderr", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/826d8f3850b37a23481dfcf4a899b5dfc82d22e3/src%2Ftest%2Fui%2Flifetime-errors%2Fex1-return-one-existing-name-if-else.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/826d8f3850b37a23481dfcf4a899b5dfc82d22e3/src%2Ftest%2Fui%2Flifetime-errors%2Fex1-return-one-existing-name-if-else.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetime-errors%2Fex1-return-one-existing-name-if-else.stderr?ref=826d8f3850b37a23481dfcf4a899b5dfc82d22e3", "patch": "@@ -4,19 +4,17 @@ error[E0312]: lifetime of reference outlives lifetime of borrowed content...\n 12 |     if x > y { x } else { y }\n    |                           ^\n    |\n-note: ...the reference is valid for the lifetime 'a as defined on the body at 11:43...\n-  --> $DIR/ex1-return-one-existing-name-if-else.rs:11:44\n+note: ...the reference is valid for the lifetime 'a as defined on the function body at 11:0...\n+  --> $DIR/ex1-return-one-existing-name-if-else.rs:11:1\n    |\n-11 |   fn foo<'a>(x: &'a i32, y: &i32) -> &'a i32 {\n-   |  ____________________________________________^\n+11 | / fn foo<'a>(x: &'a i32, y: &i32) -> &'a i32 {\n 12 | |     if x > y { x } else { y }\n 13 | | }\n    | |_^\n-note: ...but the borrowed content is only valid for the anonymous lifetime #1 defined on the body at 11:43\n-  --> $DIR/ex1-return-one-existing-name-if-else.rs:11:44\n+note: ...but the borrowed content is only valid for the anonymous lifetime #1 defined on the function body at 11:0\n+  --> $DIR/ex1-return-one-existing-name-if-else.rs:11:1\n    |\n-11 |   fn foo<'a>(x: &'a i32, y: &i32) -> &'a i32 {\n-   |  ____________________________________________^\n+11 | / fn foo<'a>(x: &'a i32, y: &i32) -> &'a i32 {\n 12 | |     if x > y { x } else { y }\n 13 | | }\n    | |_^"}, {"sha": "b7d985feca9f27dfd29ebd6556b4d2184677976d", "filename": "src/test/ui/lifetime-errors/ex2a-push-one-existing-name.stderr", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/826d8f3850b37a23481dfcf4a899b5dfc82d22e3/src%2Ftest%2Fui%2Flifetime-errors%2Fex2a-push-one-existing-name.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/826d8f3850b37a23481dfcf4a899b5dfc82d22e3/src%2Ftest%2Fui%2Flifetime-errors%2Fex2a-push-one-existing-name.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetime-errors%2Fex2a-push-one-existing-name.stderr?ref=826d8f3850b37a23481dfcf4a899b5dfc82d22e3", "patch": "@@ -6,19 +6,17 @@ error[E0308]: mismatched types\n    |\n    = note: expected type `Ref<'a, _>`\n               found type `Ref<'_, _>`\n-note: the anonymous lifetime #2 defined on the body at 15:51...\n-  --> $DIR/ex2a-push-one-existing-name.rs:15:52\n+note: the anonymous lifetime #2 defined on the function body at 15:0...\n+  --> $DIR/ex2a-push-one-existing-name.rs:15:1\n    |\n-15 |   fn foo<'a>(x: &mut Vec<Ref<'a, i32>>, y: Ref<i32>) {\n-   |  ____________________________________________________^\n+15 | / fn foo<'a>(x: &mut Vec<Ref<'a, i32>>, y: Ref<i32>) {\n 16 | |     x.push(y);\n 17 | | }\n    | |_^\n-note: ...does not necessarily outlive the lifetime 'a as defined on the body at 15:51\n-  --> $DIR/ex2a-push-one-existing-name.rs:15:52\n+note: ...does not necessarily outlive the lifetime 'a as defined on the function body at 15:0\n+  --> $DIR/ex2a-push-one-existing-name.rs:15:1\n    |\n-15 |   fn foo<'a>(x: &mut Vec<Ref<'a, i32>>, y: Ref<i32>) {\n-   |  ____________________________________________________^\n+15 | / fn foo<'a>(x: &mut Vec<Ref<'a, i32>>, y: Ref<i32>) {\n 16 | |     x.push(y);\n 17 | | }\n    | |_^"}, {"sha": "3a6e94f2b1c2e2da70127c5a631a22516b19a026", "filename": "src/test/ui/lifetime-errors/ex2b-push-no-existing-names.stderr", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/826d8f3850b37a23481dfcf4a899b5dfc82d22e3/src%2Ftest%2Fui%2Flifetime-errors%2Fex2b-push-no-existing-names.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/826d8f3850b37a23481dfcf4a899b5dfc82d22e3/src%2Ftest%2Fui%2Flifetime-errors%2Fex2b-push-no-existing-names.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetime-errors%2Fex2b-push-no-existing-names.stderr?ref=826d8f3850b37a23481dfcf4a899b5dfc82d22e3", "patch": "@@ -6,19 +6,17 @@ error[E0308]: mismatched types\n    |\n    = note: expected type `Ref<'_, _>`\n               found type `Ref<'_, _>`\n-note: the anonymous lifetime #3 defined on the body at 15:43...\n-  --> $DIR/ex2b-push-no-existing-names.rs:15:44\n+note: the anonymous lifetime #3 defined on the function body at 15:0...\n+  --> $DIR/ex2b-push-no-existing-names.rs:15:1\n    |\n-15 |   fn foo(x: &mut Vec<Ref<i32>>, y: Ref<i32>) {\n-   |  ____________________________________________^\n+15 | / fn foo(x: &mut Vec<Ref<i32>>, y: Ref<i32>) {\n 16 | |     x.push(y);\n 17 | | }\n    | |_^\n-note: ...does not necessarily outlive the anonymous lifetime #2 defined on the body at 15:43\n-  --> $DIR/ex2b-push-no-existing-names.rs:15:44\n+note: ...does not necessarily outlive the anonymous lifetime #2 defined on the function body at 15:0\n+  --> $DIR/ex2b-push-no-existing-names.rs:15:1\n    |\n-15 |   fn foo(x: &mut Vec<Ref<i32>>, y: Ref<i32>) {\n-   |  ____________________________________________^\n+15 | / fn foo(x: &mut Vec<Ref<i32>>, y: Ref<i32>) {\n 16 | |     x.push(y);\n 17 | | }\n    | |_^"}, {"sha": "3d7064a4f71a3b45423590caebeabea3619316ae", "filename": "src/test/ui/lifetime-errors/ex2c-push-inference-variable.stderr", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/826d8f3850b37a23481dfcf4a899b5dfc82d22e3/src%2Ftest%2Fui%2Flifetime-errors%2Fex2c-push-inference-variable.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/826d8f3850b37a23481dfcf4a899b5dfc82d22e3/src%2Ftest%2Fui%2Flifetime-errors%2Fex2c-push-inference-variable.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetime-errors%2Fex2c-push-inference-variable.stderr?ref=826d8f3850b37a23481dfcf4a899b5dfc82d22e3", "patch": "@@ -4,11 +4,10 @@ error[E0495]: cannot infer an appropriate lifetime for lifetime parameter `'a` d\n 16 |     let z = Ref { data: y.data };\n    |             ^^^\n    |\n-note: first, the lifetime cannot outlive the lifetime 'c as defined on the body at 15:66...\n-  --> $DIR/ex2c-push-inference-variable.rs:15:67\n+note: first, the lifetime cannot outlive the lifetime 'c as defined on the function body at 15:0...\n+  --> $DIR/ex2c-push-inference-variable.rs:15:1\n    |\n-15 |   fn foo<'a, 'b, 'c>(x: &'a mut Vec<Ref<'b, i32>>, y: Ref<'c, i32>) {\n-   |  ___________________________________________________________________^\n+15 | / fn foo<'a, 'b, 'c>(x: &'a mut Vec<Ref<'b, i32>>, y: Ref<'c, i32>) {\n 16 | |     let z = Ref { data: y.data };\n 17 | |     x.push(z);\n 18 | | }\n@@ -18,11 +17,10 @@ note: ...so that reference does not outlive borrowed content\n    |\n 16 |     let z = Ref { data: y.data };\n    |                         ^^^^^^\n-note: but, the lifetime must be valid for the lifetime 'b as defined on the body at 15:66...\n-  --> $DIR/ex2c-push-inference-variable.rs:15:67\n+note: but, the lifetime must be valid for the lifetime 'b as defined on the function body at 15:0...\n+  --> $DIR/ex2c-push-inference-variable.rs:15:1\n    |\n-15 |   fn foo<'a, 'b, 'c>(x: &'a mut Vec<Ref<'b, i32>>, y: Ref<'c, i32>) {\n-   |  ___________________________________________________________________^\n+15 | / fn foo<'a, 'b, 'c>(x: &'a mut Vec<Ref<'b, i32>>, y: Ref<'c, i32>) {\n 16 | |     let z = Ref { data: y.data };\n 17 | |     x.push(z);\n 18 | | }"}, {"sha": "aced855bf669bdca7e839fe0bdebb45f939827cb", "filename": "src/test/ui/lifetime-errors/ex2d-push-inference-variable-2.stderr", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/826d8f3850b37a23481dfcf4a899b5dfc82d22e3/src%2Ftest%2Fui%2Flifetime-errors%2Fex2d-push-inference-variable-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/826d8f3850b37a23481dfcf4a899b5dfc82d22e3/src%2Ftest%2Fui%2Flifetime-errors%2Fex2d-push-inference-variable-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetime-errors%2Fex2d-push-inference-variable-2.stderr?ref=826d8f3850b37a23481dfcf4a899b5dfc82d22e3", "patch": "@@ -4,11 +4,10 @@ error[E0495]: cannot infer an appropriate lifetime for lifetime parameter `'a` d\n 17 |     let b = Ref { data: y.data };\n    |             ^^^\n    |\n-note: first, the lifetime cannot outlive the lifetime 'c as defined on the body at 15:66...\n-  --> $DIR/ex2d-push-inference-variable-2.rs:15:67\n+note: first, the lifetime cannot outlive the lifetime 'c as defined on the function body at 15:0...\n+  --> $DIR/ex2d-push-inference-variable-2.rs:15:1\n    |\n-15 |   fn foo<'a, 'b, 'c>(x: &'a mut Vec<Ref<'b, i32>>, y: Ref<'c, i32>) {\n-   |  ___________________________________________________________________^\n+15 | / fn foo<'a, 'b, 'c>(x: &'a mut Vec<Ref<'b, i32>>, y: Ref<'c, i32>) {\n 16 | |     let a: &mut Vec<Ref<i32>> = x;\n 17 | |     let b = Ref { data: y.data };\n 18 | |     a.push(b);\n@@ -19,11 +18,10 @@ note: ...so that reference does not outlive borrowed content\n    |\n 17 |     let b = Ref { data: y.data };\n    |                         ^^^^^^\n-note: but, the lifetime must be valid for the lifetime 'b as defined on the body at 15:66...\n-  --> $DIR/ex2d-push-inference-variable-2.rs:15:67\n+note: but, the lifetime must be valid for the lifetime 'b as defined on the function body at 15:0...\n+  --> $DIR/ex2d-push-inference-variable-2.rs:15:1\n    |\n-15 |   fn foo<'a, 'b, 'c>(x: &'a mut Vec<Ref<'b, i32>>, y: Ref<'c, i32>) {\n-   |  ___________________________________________________________________^\n+15 | / fn foo<'a, 'b, 'c>(x: &'a mut Vec<Ref<'b, i32>>, y: Ref<'c, i32>) {\n 16 | |     let a: &mut Vec<Ref<i32>> = x;\n 17 | |     let b = Ref { data: y.data };\n 18 | |     a.push(b);"}, {"sha": "07e2316b63d8c61a8a1ed90b9cf59cbcd9cbe345", "filename": "src/test/ui/lifetime-errors/ex2e-push-inference-variable-3.stderr", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/826d8f3850b37a23481dfcf4a899b5dfc82d22e3/src%2Ftest%2Fui%2Flifetime-errors%2Fex2e-push-inference-variable-3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/826d8f3850b37a23481dfcf4a899b5dfc82d22e3/src%2Ftest%2Fui%2Flifetime-errors%2Fex2e-push-inference-variable-3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetime-errors%2Fex2e-push-inference-variable-3.stderr?ref=826d8f3850b37a23481dfcf4a899b5dfc82d22e3", "patch": "@@ -4,11 +4,10 @@ error[E0495]: cannot infer an appropriate lifetime for lifetime parameter `'a` d\n 17 |     let b = Ref { data: y.data };\n    |             ^^^\n    |\n-note: first, the lifetime cannot outlive the lifetime 'c as defined on the body at 15:66...\n-  --> $DIR/ex2e-push-inference-variable-3.rs:15:67\n+note: first, the lifetime cannot outlive the lifetime 'c as defined on the function body at 15:0...\n+  --> $DIR/ex2e-push-inference-variable-3.rs:15:1\n    |\n-15 |   fn foo<'a, 'b, 'c>(x: &'a mut Vec<Ref<'b, i32>>, y: Ref<'c, i32>) {\n-   |  ___________________________________________________________________^\n+15 | / fn foo<'a, 'b, 'c>(x: &'a mut Vec<Ref<'b, i32>>, y: Ref<'c, i32>) {\n 16 | |     let a: &mut Vec<Ref<i32>> = x;\n 17 | |     let b = Ref { data: y.data };\n 18 | |     Vec::push(a, b);\n@@ -19,11 +18,10 @@ note: ...so that reference does not outlive borrowed content\n    |\n 17 |     let b = Ref { data: y.data };\n    |                         ^^^^^^\n-note: but, the lifetime must be valid for the lifetime 'b as defined on the body at 15:66...\n-  --> $DIR/ex2e-push-inference-variable-3.rs:15:67\n+note: but, the lifetime must be valid for the lifetime 'b as defined on the function body at 15:0...\n+  --> $DIR/ex2e-push-inference-variable-3.rs:15:1\n    |\n-15 |   fn foo<'a, 'b, 'c>(x: &'a mut Vec<Ref<'b, i32>>, y: Ref<'c, i32>) {\n-   |  ___________________________________________________________________^\n+15 | / fn foo<'a, 'b, 'c>(x: &'a mut Vec<Ref<'b, i32>>, y: Ref<'c, i32>) {\n 16 | |     let a: &mut Vec<Ref<i32>> = x;\n 17 | |     let b = Ref { data: y.data };\n 18 | |     Vec::push(a, b);"}]}