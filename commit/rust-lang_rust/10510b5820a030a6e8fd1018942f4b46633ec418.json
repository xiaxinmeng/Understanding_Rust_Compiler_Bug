{"sha": "10510b5820a030a6e8fd1018942f4b46633ec418", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEwNTEwYjU4MjBhMDMwYTZlOGZkMTAxODk0MmY0YjQ2NjMzZWM0MTg=", "commit": {"author": {"name": "Amanieu d'Antras", "email": "amanieu@gmail.com", "date": "2020-02-13T11:00:55Z"}, "committer": {"name": "Amanieu d'Antras", "email": "amanieu@gmail.com", "date": "2020-05-18T13:41:31Z"}, "message": "HIR passes for asm!", "tree": {"sha": "bda9951f577491fe4605053fa277cf68960a1461", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bda9951f577491fe4605053fa277cf68960a1461"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/10510b5820a030a6e8fd1018942f4b46633ec418", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/10510b5820a030a6e8fd1018942f4b46633ec418", "html_url": "https://github.com/rust-lang/rust/commit/10510b5820a030a6e8fd1018942f4b46633ec418", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/10510b5820a030a6e8fd1018942f4b46633ec418/comments", "author": {"login": "Amanieu", "id": 278509, "node_id": "MDQ6VXNlcjI3ODUwOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/278509?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Amanieu", "html_url": "https://github.com/Amanieu", "followers_url": "https://api.github.com/users/Amanieu/followers", "following_url": "https://api.github.com/users/Amanieu/following{/other_user}", "gists_url": "https://api.github.com/users/Amanieu/gists{/gist_id}", "starred_url": "https://api.github.com/users/Amanieu/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Amanieu/subscriptions", "organizations_url": "https://api.github.com/users/Amanieu/orgs", "repos_url": "https://api.github.com/users/Amanieu/repos", "events_url": "https://api.github.com/users/Amanieu/events{/privacy}", "received_events_url": "https://api.github.com/users/Amanieu/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Amanieu", "id": 278509, "node_id": "MDQ6VXNlcjI3ODUwOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/278509?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Amanieu", "html_url": "https://github.com/Amanieu", "followers_url": "https://api.github.com/users/Amanieu/followers", "following_url": "https://api.github.com/users/Amanieu/following{/other_user}", "gists_url": "https://api.github.com/users/Amanieu/gists{/gist_id}", "starred_url": "https://api.github.com/users/Amanieu/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Amanieu/subscriptions", "organizations_url": "https://api.github.com/users/Amanieu/orgs", "repos_url": "https://api.github.com/users/Amanieu/repos", "events_url": "https://api.github.com/users/Amanieu/events{/privacy}", "received_events_url": "https://api.github.com/users/Amanieu/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ec1ad61f8877dcb5916b07708dd35bc8651a1541", "url": "https://api.github.com/repos/rust-lang/rust/commits/ec1ad61f8877dcb5916b07708dd35bc8651a1541", "html_url": "https://github.com/rust-lang/rust/commit/ec1ad61f8877dcb5916b07708dd35bc8651a1541"}], "stats": {"total": 482, "additions": 469, "deletions": 13}, "files": [{"sha": "adbeac29bdd75d785557cac3d0c6641a49df5928", "filename": "src/librustc_middle/traits/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10510b5820a030a6e8fd1018942f4b46633ec418/src%2Flibrustc_middle%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10510b5820a030a6e8fd1018942f4b46633ec418/src%2Flibrustc_middle%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Ftraits%2Fmod.rs?ref=10510b5820a030a6e8fd1018942f4b46633ec418", "patch": "@@ -180,6 +180,8 @@ pub enum ObligationCauseCode<'tcx> {\n     SizedReturnType,\n     /// Yield type must be `Sized`.\n     SizedYieldType,\n+    /// Inline asm operand type must be `Sized`.\n+    InlineAsmSized,\n     /// `[T, ..n]` implies that `T` must be `Copy`.\n     /// If `true`, suggest `const_in_array_repeat_expressions` feature flag.\n     RepeatVec(bool),"}, {"sha": "56744283b0c4743abe0eef995f0866bc4d53c0ab", "filename": "src/librustc_middle/traits/structural_impls.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/10510b5820a030a6e8fd1018942f4b46633ec418/src%2Flibrustc_middle%2Ftraits%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10510b5820a030a6e8fd1018942f4b46633ec418/src%2Flibrustc_middle%2Ftraits%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Ftraits%2Fstructural_impls.rs?ref=10510b5820a030a6e8fd1018942f4b46633ec418", "patch": "@@ -152,6 +152,7 @@ impl<'a, 'tcx> Lift<'tcx> for traits::ObligationCauseCode<'a> {\n             super::SizedArgumentType => Some(super::SizedArgumentType),\n             super::SizedReturnType => Some(super::SizedReturnType),\n             super::SizedYieldType => Some(super::SizedYieldType),\n+            super::InlineAsmSized => Some(super::InlineAsmSized),\n             super::RepeatVec(suggest_flag) => Some(super::RepeatVec(suggest_flag)),\n             super::FieldSized { adt_kind, last } => Some(super::FieldSized { adt_kind, last }),\n             super::ConstSized => Some(super::ConstSized),"}, {"sha": "1a9fd30bba01b69041dbbb62190405ab7d30a151", "filename": "src/librustc_passes/intrinsicck.rs", "status": "modified", "additions": 276, "deletions": 13, "changes": 289, "blob_url": "https://github.com/rust-lang/rust/blob/10510b5820a030a6e8fd1018942f4b46633ec418/src%2Flibrustc_passes%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10510b5820a030a6e8fd1018942f4b46633ec418/src%2Flibrustc_passes%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fintrinsicck.rs?ref=10510b5820a030a6e8fd1018942f4b46633ec418", "patch": "@@ -1,3 +1,4 @@\n+use rustc_ast::ast::{FloatTy, IntTy, UintTy};\n use rustc_errors::struct_span_err;\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n@@ -7,8 +8,10 @@ use rustc_index::vec::Idx;\n use rustc_middle::ty::layout::{LayoutError, SizeSkeleton};\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::{self, Ty, TyCtxt};\n-use rustc_span::{sym, Span};\n+use rustc_session::lint;\n+use rustc_span::{sym, Span, Symbol, DUMMY_SP};\n use rustc_target::abi::{Pointer, VariantIdx};\n+use rustc_target::asm::{InlineAsmRegOrRegClass, InlineAsmTemplatePiece, InlineAsmType};\n use rustc_target::spec::abi::Abi::RustIntrinsic;\n \n fn check_mod_intrinsics(tcx: TyCtxt<'_>, module_def_id: DefId) {\n@@ -119,6 +122,262 @@ impl ExprVisitor<'tcx> {\n         }\n         err.emit()\n     }\n+\n+    fn is_thin_ptr_ty(&self, ty: Ty<'tcx>) -> bool {\n+        if ty.is_sized(self.tcx.at(DUMMY_SP), self.param_env) {\n+            return true;\n+        }\n+        if let ty::Foreign(..) = ty.kind {\n+            return true;\n+        }\n+        false\n+    }\n+\n+    fn check_asm_operand_type(\n+        &self,\n+        idx: usize,\n+        reg: InlineAsmRegOrRegClass,\n+        expr: &hir::Expr<'tcx>,\n+        template: &[InlineAsmTemplatePiece],\n+        tied_input: Option<(&hir::Expr<'tcx>, Option<InlineAsmType>)>,\n+    ) -> Option<InlineAsmType> {\n+        // Check the type against the allowed types for inline asm.\n+        let ty = self.tables.expr_ty_adjusted(expr);\n+        let asm_ty_isize = match self.tcx.sess.target.ptr_width {\n+            16 => InlineAsmType::I16,\n+            32 => InlineAsmType::I32,\n+            64 => InlineAsmType::I64,\n+            _ => unreachable!(),\n+        };\n+        let asm_ty = match ty.kind {\n+            ty::Never | ty::Error => return None,\n+            ty::Int(IntTy::I8) | ty::Uint(UintTy::U8) => Some(InlineAsmType::I8),\n+            ty::Int(IntTy::I16) | ty::Uint(UintTy::U16) => Some(InlineAsmType::I16),\n+            ty::Int(IntTy::I32) | ty::Uint(UintTy::U32) => Some(InlineAsmType::I32),\n+            ty::Int(IntTy::I64) | ty::Uint(UintTy::U64) => Some(InlineAsmType::I64),\n+            ty::Int(IntTy::I128) | ty::Uint(UintTy::U128) => Some(InlineAsmType::I128),\n+            ty::Int(IntTy::Isize) | ty::Uint(UintTy::Usize) => Some(asm_ty_isize),\n+            ty::Float(FloatTy::F32) => Some(InlineAsmType::F32),\n+            ty::Float(FloatTy::F64) => Some(InlineAsmType::F64),\n+            ty::FnPtr(_) => Some(asm_ty_isize),\n+            ty::RawPtr(ty::TypeAndMut { ty, mutbl: _ }) if self.is_thin_ptr_ty(ty) => {\n+                Some(asm_ty_isize)\n+            }\n+            ty::Adt(adt, substs) if adt.repr.simd() => {\n+                let fields = &adt.non_enum_variant().fields;\n+                let elem_ty = fields[0].ty(self.tcx, substs);\n+                match elem_ty.kind {\n+                    ty::Never | ty::Error => return None,\n+                    ty::Int(IntTy::I8) | ty::Uint(UintTy::U8) => {\n+                        Some(InlineAsmType::VecI8(fields.len() as u64))\n+                    }\n+                    ty::Int(IntTy::I16) | ty::Uint(UintTy::U16) => {\n+                        Some(InlineAsmType::VecI16(fields.len() as u64))\n+                    }\n+                    ty::Int(IntTy::I32) | ty::Uint(UintTy::U32) => {\n+                        Some(InlineAsmType::VecI32(fields.len() as u64))\n+                    }\n+                    ty::Int(IntTy::I64) | ty::Uint(UintTy::U64) => {\n+                        Some(InlineAsmType::VecI64(fields.len() as u64))\n+                    }\n+                    ty::Int(IntTy::I128) | ty::Uint(UintTy::U128) => {\n+                        Some(InlineAsmType::VecI128(fields.len() as u64))\n+                    }\n+                    ty::Int(IntTy::Isize) | ty::Uint(UintTy::Usize) => {\n+                        Some(match self.tcx.sess.target.ptr_width {\n+                            16 => InlineAsmType::VecI16(fields.len() as u64),\n+                            32 => InlineAsmType::VecI32(fields.len() as u64),\n+                            64 => InlineAsmType::VecI64(fields.len() as u64),\n+                            _ => unreachable!(),\n+                        })\n+                    }\n+                    ty::Float(FloatTy::F32) => Some(InlineAsmType::VecF32(fields.len() as u64)),\n+                    ty::Float(FloatTy::F64) => Some(InlineAsmType::VecF64(fields.len() as u64)),\n+                    _ => None,\n+                }\n+            }\n+            _ => None,\n+        };\n+        let asm_ty = match asm_ty {\n+            Some(asm_ty) => asm_ty,\n+            None => {\n+                let msg = &format!(\"cannot use value of type `{}` for inline assembly\", ty);\n+                let mut err = self.tcx.sess.struct_span_err(expr.span, msg);\n+                err.note(\n+                    \"only integers, floats, SIMD vectors, pointers and function pointers \\\n+                     can be used as arguments for inline assembly\",\n+                );\n+                err.emit();\n+                return None;\n+            }\n+        };\n+\n+        // Check that the type implements Copy. The only case where this can\n+        // possibly fail is for SIMD types which don't #[derive(Copy)].\n+        if !ty.is_copy_modulo_regions(self.tcx, self.param_env, DUMMY_SP) {\n+            let msg = \"arguments for inline assembly must be copyable\";\n+            let mut err = self.tcx.sess.struct_span_err(expr.span, msg);\n+            err.note(&format!(\"`{}` does not implement the Copy trait\", ty));\n+            err.emit();\n+        }\n+\n+        // Ideally we wouldn't need to do this, but LLVM's register allocator\n+        // really doesn't like it when tied operands have different types.\n+        //\n+        // This is purely an LLVM limitation, but we have to live with it since\n+        // there is no way to hide this with implicit conversions.\n+        //\n+        // For the purposes of this check we only look at the `InlineAsmType`,\n+        // which means that pointers and integers are treated as identical (modulo\n+        // size).\n+        if let Some((in_expr, Some(in_asm_ty))) = tied_input {\n+            if in_asm_ty != asm_ty {\n+                let msg = &format!(\"incompatible types for asm inout argument\");\n+                let mut err = self.tcx.sess.struct_span_err(vec![in_expr.span, expr.span], msg);\n+                err.span_label(\n+                    in_expr.span,\n+                    &format!(\"type `{}`\", self.tables.expr_ty_adjusted(in_expr)),\n+                );\n+                err.span_label(expr.span, &format!(\"type `{}`\", ty));\n+                err.note(\"asm inout arguments must have the same type\");\n+                err.note(\"unless they are both pointers or integers of the same size\");\n+                err.emit();\n+            }\n+\n+            // All of the later checks have already been done on the input, so\n+            // let's not emit errors and warnings twice.\n+            return Some(asm_ty);\n+        }\n+\n+        // Check the type against the list of types supported by the selected\n+        // register class.\n+        let asm_arch = self.tcx.sess.asm_arch.unwrap();\n+        let reg_class = reg.reg_class();\n+        let supported_tys = reg_class.supported_types(asm_arch);\n+        let feature = match supported_tys.iter().find(|&&(t, _)| t == asm_ty) {\n+            Some((_, feature)) => feature,\n+            None => {\n+                let msg = &format!(\"type `{}` cannot be used with this register class\", ty);\n+                let mut err = self.tcx.sess.struct_span_err(expr.span, msg);\n+                let supported_tys: Vec<_> =\n+                    supported_tys.iter().map(|(t, _)| t.to_string()).collect();\n+                err.note(&format!(\n+                    \"register class `{}` supports these types: {}\",\n+                    reg_class.name(),\n+                    supported_tys.join(\", \"),\n+                ));\n+                err.emit();\n+                return Some(asm_ty);\n+            }\n+        };\n+\n+        // Check whether the selected type requires a target feature.\n+        if let Some(feature) = feature {\n+            if !self.tcx.sess.target_features.contains(&Symbol::intern(feature)) {\n+                let msg = &format!(\"`{}` target feature is not enabled\", feature);\n+                let mut err = self.tcx.sess.struct_span_err(expr.span, msg);\n+                err.note(&format!(\n+                    \"this is required to use type `{}` with register class `{}`\",\n+                    ty,\n+                    reg_class.name(),\n+                ));\n+                err.emit();\n+                return Some(asm_ty);\n+            }\n+        }\n+\n+        // Check whether a modifier is suggested for using this type.\n+        if let Some((suggested_modifier, suggested_result, switch_reg_class)) =\n+            reg_class.suggest_modifier(asm_arch, asm_ty)\n+        {\n+            // Search for any use of this operand without a modifier and emit\n+            // the suggestion for them.\n+            let mut spans = vec![];\n+            for piece in template {\n+                if let &InlineAsmTemplatePiece::Placeholder { operand_idx, modifier, span } = piece\n+                {\n+                    if operand_idx == idx && modifier.is_none() {\n+                        spans.push(span);\n+                    }\n+                }\n+            }\n+            if !spans.is_empty() {\n+                let (default_modifier, default_result) =\n+                    reg_class.default_modifier(asm_arch).unwrap();\n+                self.tcx.struct_span_lint_hir(\n+                    lint::builtin::ASM_SUB_REGISTER,\n+                    expr.hir_id,\n+                    spans,\n+                    |lint| {\n+                        let msg = \"formatting may not be suitable for sub-register argument\";\n+                        let mut err = lint.build(msg);\n+                        err.span_label(expr.span, \"for this argument\");\n+                        if let Some(switch_reg_class) = switch_reg_class {\n+                            err.help(&format!(\n+                                \"use the `{}` modifier with the `{}` register class \\\n+                                 to have the register formatted as `{}`\",\n+                                suggested_modifier, switch_reg_class, suggested_result,\n+                            ));\n+                        } else {\n+                            err.help(&format!(\n+                                \"use the `{}` modifier to have the register formatted as `{}`\",\n+                                suggested_modifier, suggested_result,\n+                            ));\n+                        }\n+                        err.help(&format!(\n+                            \"or use the `{}` modifier to keep the default formatting of `{}`\",\n+                            default_modifier, default_result,\n+                        ));\n+                        err.emit();\n+                    },\n+                );\n+            }\n+        }\n+\n+        Some(asm_ty)\n+    }\n+\n+    fn check_asm(&self, asm: &hir::InlineAsm<'tcx>) {\n+        for (idx, op) in asm.operands.iter().enumerate() {\n+            match *op {\n+                hir::InlineAsmOperand::In { reg, ref expr } => {\n+                    self.check_asm_operand_type(idx, reg, expr, asm.template, None);\n+                }\n+                hir::InlineAsmOperand::Out { reg, late: _, ref expr } => {\n+                    if let Some(expr) = expr {\n+                        self.check_asm_operand_type(idx, reg, expr, asm.template, None);\n+                    }\n+                }\n+                hir::InlineAsmOperand::InOut { reg, late: _, ref expr } => {\n+                    self.check_asm_operand_type(idx, reg, expr, asm.template, None);\n+                }\n+                hir::InlineAsmOperand::SplitInOut { reg, late: _, ref in_expr, ref out_expr } => {\n+                    let in_ty = self.check_asm_operand_type(idx, reg, in_expr, asm.template, None);\n+                    if let Some(out_expr) = out_expr {\n+                        self.check_asm_operand_type(\n+                            idx,\n+                            reg,\n+                            out_expr,\n+                            asm.template,\n+                            Some((in_expr, in_ty)),\n+                        );\n+                    }\n+                }\n+                hir::InlineAsmOperand::Const { ref expr } => {\n+                    let ty = self.tables.expr_ty_adjusted(expr);\n+                    match ty.kind {\n+                        ty::Int(_) | ty::Uint(_) | ty::Float(_) => {}\n+                        _ => {\n+                            let msg =\n+                                \"asm `const` arguments must be integer or floating-point values\";\n+                            self.tcx.sess.span_err(expr.span, msg);\n+                        }\n+                    }\n+                }\n+                hir::InlineAsmOperand::Sym { .. } => {}\n+            }\n+        }\n+    }\n }\n \n impl Visitor<'tcx> for ItemVisitor<'tcx> {\n@@ -146,19 +405,23 @@ impl Visitor<'tcx> for ExprVisitor<'tcx> {\n     }\n \n     fn visit_expr(&mut self, expr: &'tcx hir::Expr<'tcx>) {\n-        let res = if let hir::ExprKind::Path(ref qpath) = expr.kind {\n-            self.tables.qpath_res(qpath, expr.hir_id)\n-        } else {\n-            Res::Err\n-        };\n-        if let Res::Def(DefKind::Fn, did) = res {\n-            if self.def_id_is_transmute(did) {\n-                let typ = self.tables.node_type(expr.hir_id);\n-                let sig = typ.fn_sig(self.tcx);\n-                let from = sig.inputs().skip_binder()[0];\n-                let to = *sig.output().skip_binder();\n-                self.check_transmute(expr.span, from, to);\n+        match expr.kind {\n+            hir::ExprKind::Path(ref qpath) => {\n+                let res = self.tables.qpath_res(qpath, expr.hir_id);\n+                if let Res::Def(DefKind::Fn, did) = res {\n+                    if self.def_id_is_transmute(did) {\n+                        let typ = self.tables.node_type(expr.hir_id);\n+                        let sig = typ.fn_sig(self.tcx);\n+                        let from = sig.inputs().skip_binder()[0];\n+                        let to = *sig.output().skip_binder();\n+                        self.check_transmute(expr.span, from, to);\n+                    }\n+                }\n             }\n+\n+            hir::ExprKind::InlineAsm(asm) => self.check_asm(asm),\n+\n+            _ => {}\n         }\n \n         intravisit::walk_expr(self, expr);"}, {"sha": "57d14220c2b0be6fc91170ceee8081b5bd91ffe8", "filename": "src/librustc_passes/liveness.rs", "status": "modified", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/10510b5820a030a6e8fd1018942f4b46633ec418/src%2Flibrustc_passes%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10510b5820a030a6e8fd1018942f4b46633ec418/src%2Flibrustc_passes%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fliveness.rs?ref=10510b5820a030a6e8fd1018942f4b46633ec418", "patch": "@@ -109,6 +109,7 @@ use rustc_middle::ty::{self, TyCtxt};\n use rustc_session::lint;\n use rustc_span::symbol::{sym, Symbol};\n use rustc_span::Span;\n+use rustc_target::asm::InlineAsmOptions;\n \n use std::collections::VecDeque;\n use std::fmt;\n@@ -531,6 +532,7 @@ fn visit_expr<'tcx>(ir: &mut IrMaps<'tcx>, expr: &'tcx Expr<'tcx>) {\n         | hir::ExprKind::AssignOp(..)\n         | hir::ExprKind::Struct(..)\n         | hir::ExprKind::Repeat(..)\n+        | hir::ExprKind::InlineAsm(..)\n         | hir::ExprKind::LlvmInlineAsm(..)\n         | hir::ExprKind::Box(..)\n         | hir::ExprKind::Yield(..)\n@@ -1176,6 +1178,64 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n             | hir::ExprKind::Yield(ref e, _)\n             | hir::ExprKind::Repeat(ref e, _) => self.propagate_through_expr(&e, succ),\n \n+            hir::ExprKind::InlineAsm(ref asm) => {\n+                // Handle non-returning asm\n+                let mut succ = if asm.options.contains(InlineAsmOptions::NORETURN) {\n+                    self.s.exit_ln\n+                } else {\n+                    succ\n+                };\n+\n+                // Do a first pass for writing outputs only\n+                for op in asm.operands.iter().rev() {\n+                    match op {\n+                        hir::InlineAsmOperand::In { .. }\n+                        | hir::InlineAsmOperand::Const { .. }\n+                        | hir::InlineAsmOperand::Sym { .. } => {}\n+                        hir::InlineAsmOperand::Out { expr, .. } => {\n+                            if let Some(expr) = expr {\n+                                succ = self.write_place(expr, succ, ACC_WRITE);\n+                            }\n+                        }\n+                        hir::InlineAsmOperand::InOut { expr, .. } => {\n+                            succ = self.write_place(expr, succ, ACC_READ | ACC_WRITE);\n+                        }\n+                        hir::InlineAsmOperand::SplitInOut { out_expr, .. } => {\n+                            if let Some(expr) = out_expr {\n+                                succ = self.write_place(expr, succ, ACC_WRITE);\n+                            }\n+                        }\n+                    }\n+                }\n+\n+                // Then do a second pass for inputs\n+                let mut succ = succ;\n+                for op in asm.operands.iter().rev() {\n+                    match op {\n+                        hir::InlineAsmOperand::In { expr, .. }\n+                        | hir::InlineAsmOperand::Const { expr, .. }\n+                        | hir::InlineAsmOperand::Sym { expr, .. } => {\n+                            succ = self.propagate_through_expr(expr, succ)\n+                        }\n+                        hir::InlineAsmOperand::Out { expr, .. } => {\n+                            if let Some(expr) = expr {\n+                                succ = self.propagate_through_place_components(expr, succ);\n+                            }\n+                        }\n+                        hir::InlineAsmOperand::InOut { expr, .. } => {\n+                            succ = self.propagate_through_place_components(expr, succ);\n+                        }\n+                        hir::InlineAsmOperand::SplitInOut { in_expr, out_expr, .. } => {\n+                            if let Some(expr) = out_expr {\n+                                succ = self.propagate_through_place_components(expr, succ);\n+                            }\n+                            succ = self.propagate_through_expr(in_expr, succ);\n+                        }\n+                    }\n+                }\n+                succ\n+            }\n+\n             hir::ExprKind::LlvmInlineAsm(ref asm) => {\n                 let ia = &asm.inner;\n                 let outputs = asm.outputs_exprs;\n@@ -1397,6 +1457,33 @@ fn check_expr<'tcx>(this: &mut Liveness<'_, 'tcx>, expr: &'tcx Expr<'tcx>) {\n             }\n         }\n \n+        hir::ExprKind::InlineAsm(ref asm) => {\n+            for op in asm.operands {\n+                match op {\n+                    hir::InlineAsmOperand::In { expr, .. }\n+                    | hir::InlineAsmOperand::Const { expr, .. }\n+                    | hir::InlineAsmOperand::Sym { expr, .. } => this.visit_expr(expr),\n+                    hir::InlineAsmOperand::Out { expr, .. } => {\n+                        if let Some(expr) = expr {\n+                            this.check_place(expr);\n+                            this.visit_expr(expr);\n+                        }\n+                    }\n+                    hir::InlineAsmOperand::InOut { expr, .. } => {\n+                        this.check_place(expr);\n+                        this.visit_expr(expr);\n+                    }\n+                    hir::InlineAsmOperand::SplitInOut { in_expr, out_expr, .. } => {\n+                        this.visit_expr(in_expr);\n+                        if let Some(out_expr) = out_expr {\n+                            this.check_place(out_expr);\n+                            this.visit_expr(out_expr);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n         hir::ExprKind::LlvmInlineAsm(ref asm) => {\n             for input in asm.inputs_exprs {\n                 this.visit_expr(input);"}, {"sha": "3d03e46683ed5a138c61196ae236404df7eea561", "filename": "src/librustc_session/lint/builtin.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/10510b5820a030a6e8fd1018942f4b46633ec418/src%2Flibrustc_session%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10510b5820a030a6e8fd1018942f4b46633ec418/src%2Flibrustc_session%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_session%2Flint%2Fbuiltin.rs?ref=10510b5820a030a6e8fd1018942f4b46633ec418", "patch": "@@ -508,6 +508,12 @@ declare_lint! {\n     \"detects incompatible use of `#[inline(always)]` and `#[no_sanitize(...)]`\",\n }\n \n+declare_lint! {\n+    pub ASM_SUB_REGISTER,\n+    Warn,\n+    \"using only a subset of a register for inline asm inputs\",\n+}\n+\n declare_lint_pass! {\n     /// Does nothing as a lint pass, but registers some `Lint`s\n     /// that are used by other parts of the compiler.\n@@ -576,6 +582,7 @@ declare_lint_pass! {\n         INDIRECT_STRUCTURAL_MATCH,\n         SOFT_UNSTABLE,\n         INLINE_NO_SANITIZE,\n+        ASM_SUB_REGISTER,\n     ]\n }\n "}, {"sha": "bd58e86988a00a3eaebec1bc95f3ba90ae55a4d1", "filename": "src/librustc_trait_selection/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/10510b5820a030a6e8fd1018942f4b46633ec418/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10510b5820a030a6e8fd1018942f4b46633ec418/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=10510b5820a030a6e8fd1018942f4b46633ec418", "patch": "@@ -1746,6 +1746,9 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n             ObligationCauseCode::ConstSized => {\n                 err.note(\"constant expressions must have a statically known size\");\n             }\n+            ObligationCauseCode::InlineAsmSized => {\n+                err.note(\"all inline asm arguments must have a statically known size\");\n+            }\n             ObligationCauseCode::ConstPatternStructural => {\n                 err.note(\"constants used for pattern-matching must derive `PartialEq` and `Eq`\");\n             }"}, {"sha": "0ec2d438c2858d3d3cb4329d252bfb19830563b4", "filename": "src/librustc_typeck/check/expr.rs", "status": "modified", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/10510b5820a030a6e8fd1018942f4b46633ec418/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10510b5820a030a6e8fd1018942f4b46633ec418/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs?ref=10510b5820a030a6e8fd1018942f4b46633ec418", "patch": "@@ -38,6 +38,7 @@ use rustc_middle::ty::{AdtKind, Visibility};\n use rustc_span::hygiene::DesugaringKind;\n use rustc_span::source_map::Span;\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n+use rustc_target::asm::InlineAsmOptions;\n use rustc_trait_selection::traits::{self, ObligationCauseCode};\n \n use std::fmt::Display;\n@@ -232,6 +233,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 self.check_expr_addr_of(kind, mutbl, oprnd, expected, expr)\n             }\n             ExprKind::Path(ref qpath) => self.check_expr_path(qpath, expr),\n+            ExprKind::InlineAsm(asm) => self.check_expr_asm(asm),\n             ExprKind::LlvmInlineAsm(ref asm) => {\n                 for expr in asm.outputs_exprs.iter().chain(asm.inputs_exprs.iter()) {\n                     self.check_expr(expr);\n@@ -1811,6 +1813,72 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             }\n         }\n     }\n+\n+    fn check_expr_asm_operand(&self, expr: &'tcx hir::Expr<'tcx>, is_input: bool) {\n+        let needs = if is_input { Needs::None } else { Needs::MutPlace };\n+        let ty = self.check_expr_with_needs(expr, needs);\n+        self.require_type_is_sized(ty, expr.span, traits::InlineAsmSized);\n+\n+        if !is_input && !expr.is_syntactic_place_expr() {\n+            let mut err = self.tcx.sess.struct_span_err(expr.span, \"invalid asm output\");\n+            err.span_label(expr.span, \"cannot assign to this expression\");\n+            err.emit();\n+        }\n+\n+        // If this is an input value, we require its type to be fully resolved\n+        // at this point. This allows us to provide helpful coercions which help\n+        // pass the type whitelist in a later pass.\n+        //\n+        // We don't require output types to be resolved at this point, which\n+        // allows them to be inferred based on how they are used later in the\n+        // function.\n+        if is_input {\n+            let ty = self.structurally_resolved_type(expr.span, &ty);\n+            match ty.kind {\n+                ty::FnDef(..) => {\n+                    let fnptr_ty = self.tcx.mk_fn_ptr(ty.fn_sig(self.tcx));\n+                    self.demand_coerce(expr, ty, fnptr_ty, AllowTwoPhase::No);\n+                }\n+                ty::Ref(_, base_ty, mutbl) => {\n+                    let ptr_ty = self.tcx.mk_ptr(ty::TypeAndMut { ty: base_ty, mutbl });\n+                    self.demand_coerce(expr, ty, ptr_ty, AllowTwoPhase::No);\n+                }\n+                _ => {}\n+            }\n+        }\n+    }\n+\n+    fn check_expr_asm(&self, asm: &'tcx hir::InlineAsm<'tcx>) -> Ty<'tcx> {\n+        for op in asm.operands {\n+            match op {\n+                hir::InlineAsmOperand::In { expr, .. } | hir::InlineAsmOperand::Const { expr } => {\n+                    self.check_expr_asm_operand(expr, true);\n+                }\n+                hir::InlineAsmOperand::Out { expr, .. } => {\n+                    if let Some(expr) = expr {\n+                        self.check_expr_asm_operand(expr, false);\n+                    }\n+                }\n+                hir::InlineAsmOperand::InOut { expr, .. } => {\n+                    self.check_expr_asm_operand(expr, false);\n+                }\n+                hir::InlineAsmOperand::SplitInOut { in_expr, out_expr, .. } => {\n+                    self.check_expr_asm_operand(in_expr, true);\n+                    if let Some(out_expr) = out_expr {\n+                        self.check_expr_asm_operand(out_expr, false);\n+                    }\n+                }\n+                hir::InlineAsmOperand::Sym { expr } => {\n+                    self.check_expr(expr);\n+                }\n+            }\n+        }\n+        if asm.options.contains(InlineAsmOptions::NORETURN) {\n+            self.tcx.types.never\n+        } else {\n+            self.tcx.mk_unit()\n+        }\n+    }\n }\n \n pub(super) fn ty_kind_suggestion(ty: Ty<'_>) -> Option<&'static str> {"}, {"sha": "9ba00faec4978ea47246e6719a670eb763310e12", "filename": "src/librustc_typeck/expr_use_visitor.rs", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/10510b5820a030a6e8fd1018942f4b46633ec418/src%2Flibrustc_typeck%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10510b5820a030a6e8fd1018942f4b46633ec418/src%2Flibrustc_typeck%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fexpr_use_visitor.rs?ref=10510b5820a030a6e8fd1018942f4b46633ec418", "patch": "@@ -220,6 +220,30 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n                 self.borrow_expr(&base, bk);\n             }\n \n+            hir::ExprKind::InlineAsm(ref asm) => {\n+                for op in asm.operands {\n+                    match op {\n+                        hir::InlineAsmOperand::In { expr, .. }\n+                        | hir::InlineAsmOperand::Const { expr, .. }\n+                        | hir::InlineAsmOperand::Sym { expr, .. } => self.consume_expr(expr),\n+                        hir::InlineAsmOperand::Out { expr, .. } => {\n+                            if let Some(expr) = expr {\n+                                self.mutate_expr(expr);\n+                            }\n+                        }\n+                        hir::InlineAsmOperand::InOut { expr, .. } => {\n+                            self.mutate_expr(expr);\n+                        }\n+                        hir::InlineAsmOperand::SplitInOut { in_expr, out_expr, .. } => {\n+                            self.consume_expr(in_expr);\n+                            if let Some(out_expr) = out_expr {\n+                                self.mutate_expr(out_expr);\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+\n             hir::ExprKind::LlvmInlineAsm(ref ia) => {\n                 for (o, output) in ia.inner.outputs.iter().zip(ia.outputs_exprs) {\n                     if o.is_indirect {"}, {"sha": "71f3e2d03c9ff79f6b6076746d70ba82a6dfb5af", "filename": "src/librustc_typeck/mem_categorization.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/10510b5820a030a6e8fd1018942f4b46633ec418/src%2Flibrustc_typeck%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10510b5820a030a6e8fd1018942f4b46633ec418/src%2Flibrustc_typeck%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fmem_categorization.rs?ref=10510b5820a030a6e8fd1018942f4b46633ec418", "patch": "@@ -405,6 +405,7 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n             | hir::ExprKind::Continue(..)\n             | hir::ExprKind::Struct(..)\n             | hir::ExprKind::Repeat(..)\n+            | hir::ExprKind::InlineAsm(..)\n             | hir::ExprKind::LlvmInlineAsm(..)\n             | hir::ExprKind::Box(..)\n             | hir::ExprKind::Err => Ok(self.cat_rvalue(expr.hir_id, expr.span, expr_ty)),"}]}