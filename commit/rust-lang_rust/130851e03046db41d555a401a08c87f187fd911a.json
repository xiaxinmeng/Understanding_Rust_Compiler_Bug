{"sha": "130851e03046db41d555a401a08c87f187fd911a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEzMDg1MWUwMzA0NmRiNDFkNTU1YTQwMWEwOGM4N2YxODdmZDkxMWE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-10-03T22:07:37Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-10-03T22:07:37Z"}, "message": "Auto merge of #28669 - arielb1:well-formed-methods, r=nikomatsakis\n\nBy RFC1214:\r\n>    Before calling a fn, we check that its argument and return types are WF.\r\n    \r\nThe previous code only checked the trait-ref, which was not enough\r\nin several cases.\r\n    \r\nAs this is a soundness fix, it is a [breaking-change]. Some new annotations are needed, which I think are because of #18653 and the imperfection of `projection_must_outlive` (that can probably be worked around by moving the wf obligation later).\r\n    \r\nFixes #28609\r\n\r\nr? @nikomatsakis", "tree": {"sha": "ab75c12944a019af64249e5efcd5ef287081048e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ab75c12944a019af64249e5efcd5ef287081048e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/130851e03046db41d555a401a08c87f187fd911a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/130851e03046db41d555a401a08c87f187fd911a", "html_url": "https://github.com/rust-lang/rust/commit/130851e03046db41d555a401a08c87f187fd911a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/130851e03046db41d555a401a08c87f187fd911a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6d11a81c71c0d51980df5bd2d8c56cd295e3f2df", "url": "https://api.github.com/repos/rust-lang/rust/commits/6d11a81c71c0d51980df5bd2d8c56cd295e3f2df", "html_url": "https://github.com/rust-lang/rust/commit/6d11a81c71c0d51980df5bd2d8c56cd295e3f2df"}, {"sha": "2f23e171cb51b0f8b3658d0149217bde8e730059", "url": "https://api.github.com/repos/rust-lang/rust/commits/2f23e171cb51b0f8b3658d0149217bde8e730059", "html_url": "https://github.com/rust-lang/rust/commit/2f23e171cb51b0f8b3658d0149217bde8e730059"}], "stats": {"total": 216, "additions": 206, "deletions": 10}, "files": [{"sha": "176dc5a743d05a15e87f3f00c8b883221c9a70e1", "filename": "src/librustc/middle/ty/structural_impls.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/130851e03046db41d555a401a08c87f187fd911a/src%2Flibrustc%2Fmiddle%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/130851e03046db41d555a401a08c87f187fd911a/src%2Flibrustc%2Fmiddle%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty%2Fstructural_impls.rs?ref=130851e03046db41d555a401a08c87f187fd911a", "patch": "@@ -417,7 +417,9 @@ impl<'tcx, A: Lift<'tcx>, B: Lift<'tcx>> Lift<'tcx> for (A, B) {\n impl<'tcx, T: Lift<'tcx>> Lift<'tcx> for [T] {\n     type Lifted = Vec<T::Lifted>;\n     fn lift_to_tcx(&self, tcx: &ty::ctxt<'tcx>) -> Option<Self::Lifted> {\n-        let mut result = Vec::with_capacity(self.len());\n+        // type annotation needed to inform `projection_must_outlive`\n+        let mut result : Vec<<T as Lift<'tcx>>::Lifted>\n+            = Vec::with_capacity(self.len());\n         for x in self {\n             if let Some(value) = tcx.lift(x) {\n                 result.push(value);"}, {"sha": "72131627aa5d4dd3303d2ba5a7b307d8de50174e", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 14, "deletions": 8, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/130851e03046db41d555a401a08c87f187fd911a/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/130851e03046db41d555a401a08c87f187fd911a/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=130851e03046db41d555a401a08c87f187fd911a", "patch": "@@ -103,22 +103,23 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n         // Unify the (adjusted) self type with what the method expects.\n         self.unify_receivers(self_ty, method_self_ty);\n \n-        // Add any trait/regions obligations specified on the method's type parameters.\n-        self.add_obligations(&pick, &all_substs, &method_predicates);\n-\n-        // Create the final `MethodCallee`.\n+        // Create the method type\n         let method_ty = pick.item.as_opt_method().unwrap();\n         let fty = self.tcx().mk_fn(None, self.tcx().mk_bare_fn(ty::BareFnTy {\n             sig: ty::Binder(method_sig),\n             unsafety: method_ty.fty.unsafety,\n             abi: method_ty.fty.abi.clone(),\n         }));\n+\n+        // Add any trait/regions obligations specified on the method's type parameters.\n+        self.add_obligations(fty, &all_substs, &method_predicates);\n+\n+        // Create the final `MethodCallee`.\n         let callee = ty::MethodCallee {\n             def_id: pick.item.def_id(),\n             ty: fty,\n             substs: self.tcx().mk_substs(all_substs)\n         };\n-\n         // If this is an `&mut self` method, bias the receiver\n         // expression towards mutability (this will switch\n         // e.g. `Deref` to `DerefMut` in overloaded derefs and so on).\n@@ -422,11 +423,11 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n     }\n \n     fn add_obligations(&mut self,\n-                       pick: &probe::Pick<'tcx>,\n+                       fty: Ty<'tcx>,\n                        all_substs: &subst::Substs<'tcx>,\n                        method_predicates: &ty::InstantiatedPredicates<'tcx>) {\n-        debug!(\"add_obligations: pick={:?} all_substs={:?} method_predicates={:?}\",\n-               pick,\n+        debug!(\"add_obligations: fty={:?} all_substs={:?} method_predicates={:?}\",\n+               fty,\n                all_substs,\n                method_predicates);\n \n@@ -439,6 +440,11 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n         self.fcx.add_wf_bounds(\n             all_substs,\n             self.call_expr);\n+\n+        // the function type must also be well-formed (this is not\n+        // implied by the substs being well-formed because of inherent\n+        // impls and late-bound regions - see issue #28609).\n+        self.fcx.register_wf_obligation(fty, self.span, traits::MiscObligation);\n     }\n \n     ///////////////////////////////////////////////////////////////////////////"}, {"sha": "e0ad51b4ea1b54532dd56d0fe0d763d7aa5ab9ed", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/130851e03046db41d555a401a08c87f187fd911a/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/130851e03046db41d555a401a08c87f187fd911a/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=130851e03046db41d555a401a08c87f187fd911a", "patch": "@@ -255,6 +255,9 @@ pub fn lookup_in_trait_adjusted<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         traits::ObligationCause::misc(span, fcx.body_id),\n         &method_bounds);\n \n+    // Also register an obligation for the method type being well-formed.\n+    fcx.register_wf_obligation(fty, span, traits::MiscObligation);\n+\n     // FIXME(#18653) -- Try to resolve obligations, giving us more\n     // typing information, which can sometimes be needed to avoid\n     // pathological region inference failures."}, {"sha": "134b1ce16e2b62a1914302950911fc5d60b8b37d", "filename": "src/libstd/thread/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/130851e03046db41d555a401a08c87f187fd911a/src%2Flibstd%2Fthread%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/130851e03046db41d555a401a08c87f187fd911a/src%2Flibstd%2Fthread%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread%2Fmod.rs?ref=130851e03046db41d555a401a08c87f187fd911a", "patch": "@@ -266,7 +266,8 @@ impl Builder {\n         let my_thread = Thread::new(name);\n         let their_thread = my_thread.clone();\n \n-        let my_packet = Arc::new(UnsafeCell::new(None));\n+        let my_packet : Arc<UnsafeCell<Option<Result<T>>>>\n+            = Arc::new(UnsafeCell::new(None));\n         let their_packet = my_packet.clone();\n \n         let main = move || {"}, {"sha": "5f6216a898a0b0351da1eedee6977fc948a58234", "filename": "src/test/compile-fail/issue-18959.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/130851e03046db41d555a401a08c87f187fd911a/src%2Ftest%2Fcompile-fail%2Fissue-18959.rs", "raw_url": "https://github.com/rust-lang/rust/raw/130851e03046db41d555a401a08c87f187fd911a/src%2Ftest%2Fcompile-fail%2Fissue-18959.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-18959.rs?ref=130851e03046db41d555a401a08c87f187fd911a", "patch": "@@ -22,6 +22,7 @@ fn foo(b: &Bar) {\n     b.foo(&0)\n     //~^ ERROR the trait `Foo` is not implemented for the type `Bar`\n     //~| ERROR E0038\n+    //~| WARNING E0038\n }\n \n fn main() {"}, {"sha": "06d2441d3c0245b1b9a2aa6bdc4a1dc769f037aa", "filename": "src/test/compile-fail/object-safety-issue-22040.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/130851e03046db41d555a401a08c87f187fd911a/src%2Ftest%2Fcompile-fail%2Fobject-safety-issue-22040.rs", "raw_url": "https://github.com/rust-lang/rust/raw/130851e03046db41d555a401a08c87f187fd911a/src%2Ftest%2Fcompile-fail%2Fobject-safety-issue-22040.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fobject-safety-issue-22040.rs?ref=130851e03046db41d555a401a08c87f187fd911a", "patch": "@@ -26,6 +26,7 @@ struct SExpr<'x> {\n impl<'x> PartialEq for SExpr<'x> {\n     fn eq(&self, other:&SExpr<'x>) -> bool {\n         println!(\"L1: {} L2: {}\", self.elements.len(), other.elements.len());\n+\n         let result = self.elements.len() == other.elements.len();\n \n         println!(\"Got compare {}\", result);"}, {"sha": "13fe314fbcdd1cb5c9ab333ddb8c2f91ca0f1a36", "filename": "src/test/compile-fail/trait-test-2.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/130851e03046db41d555a401a08c87f187fd911a/src%2Ftest%2Fcompile-fail%2Ftrait-test-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/130851e03046db41d555a401a08c87f187fd911a/src%2Ftest%2Fcompile-fail%2Ftrait-test-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftrait-test-2.rs?ref=130851e03046db41d555a401a08c87f187fd911a", "patch": "@@ -21,4 +21,5 @@ fn main() {\n     //~^ ERROR E0038\n     //~| ERROR E0038\n     //~| ERROR E0277\n+    //~| WARNING E0038\n }"}, {"sha": "b9d292fd1568552dcea5450360e00cbc213283c7", "filename": "src/test/compile-fail/wf-method-late-bound-regions.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/130851e03046db41d555a401a08c87f187fd911a/src%2Ftest%2Fcompile-fail%2Fwf-method-late-bound-regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/130851e03046db41d555a401a08c87f187fd911a/src%2Ftest%2Fcompile-fail%2Fwf-method-late-bound-regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fwf-method-late-bound-regions.rs?ref=130851e03046db41d555a401a08c87f187fd911a", "patch": "@@ -0,0 +1,33 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// A method's receiver must be well-formed, even if it has late-bound regions.\n+// Because of this, a method's substs being well-formed does not imply that\n+// the method's implied bounds are met.\n+\n+struct Foo<'b>(Option<&'b ()>);\n+\n+trait Bar<'b> {\n+    fn xmute<'a>(&'a self, u: &'b u32) -> &'a u32;\n+}\n+\n+impl<'b> Bar<'b> for Foo<'b> {\n+    fn xmute<'a>(&'a self, u: &'b u32) -> &'a u32 { u }\n+}\n+\n+fn main() {\n+    let f = Foo(None);\n+    let f2 = f;\n+    let dangling = {\n+        let pointer = Box::new(42);\n+        f2.xmute(&pointer) //~ ERROR `pointer` does not live long enough\n+    };\n+    println!(\"{}\", dangling);\n+}"}, {"sha": "055c86a03a7e65faaef3a2239fefe230daa42426", "filename": "src/test/compile-fail/wf-misc-methods-issue-28609.rs", "status": "added", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/130851e03046db41d555a401a08c87f187fd911a/src%2Ftest%2Fcompile-fail%2Fwf-misc-methods-issue-28609.rs", "raw_url": "https://github.com/rust-lang/rust/raw/130851e03046db41d555a401a08c87f187fd911a/src%2Ftest%2Fcompile-fail%2Fwf-misc-methods-issue-28609.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fwf-misc-methods-issue-28609.rs?ref=130851e03046db41d555a401a08c87f187fd911a", "patch": "@@ -0,0 +1,84 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// check that misc. method calls are well-formed\n+\n+use std::marker::PhantomData;\n+use std::ops::{Deref, Shl};\n+\n+#[derive(Copy, Clone)]\n+struct S<'a, 'b: 'a> {\n+    marker: PhantomData<&'a &'b ()>,\n+    bomb: Option<&'b u32>\n+}\n+\n+type S2<'a> = S<'a, 'a>;\n+\n+impl<'a, 'b> S<'a, 'b> {\n+    fn transmute_inherent(&self, a: &'b u32) -> &'a u32 {\n+        a\n+    }\n+}\n+\n+fn return_dangling_pointer_inherent(s: S2) -> &u32 {\n+    let s = s;\n+    s.transmute_inherent(&mut 42) //~ ERROR does not live long enough\n+}\n+\n+impl<'a, 'b> Deref for S<'a, 'b> {\n+    type Target = &'a u32;\n+    fn deref(&self) -> &&'a u32 {\n+        self.bomb.as_ref().unwrap()\n+    }\n+}\n+\n+fn return_dangling_pointer_coerce(s: S2) -> &u32 {\n+    let four = 4;\n+    let mut s = s;\n+    s.bomb = Some(&four); //~ ERROR does not live long enough\n+    &s\n+}\n+\n+fn return_dangling_pointer_unary_op(s: S2) -> &u32 {\n+    let four = 4;\n+    let mut s = s;\n+    s.bomb = Some(&four); //~ ERROR does not live long enough\n+    &*s\n+}\n+\n+impl<'a, 'b> Shl<&'b u32> for S<'a, 'b> {\n+    type Output = &'a u32;\n+    fn shl(self, t: &'b u32) -> &'a u32 { t }\n+}\n+\n+fn return_dangling_pointer_binary_op(s: S2) -> &u32 {\n+    let s = s;\n+    s << &mut 3 //~ ERROR does not live long enough\n+}\n+\n+fn return_dangling_pointer_method(s: S2) -> &u32 {\n+    let s = s;\n+    s.shl(&mut 3) //~ ERROR does not live long enough\n+}\n+\n+fn return_dangling_pointer_ufcs(s: S2) -> &u32 {\n+    let s = s;\n+    S2::shl(s, &mut 3) //~ ERROR does not live long enough\n+}\n+\n+fn main() {\n+    let s = S { marker: PhantomData, bomb: None };\n+    let _inherent_dp = return_dangling_pointer_inherent(s);\n+    let _coerce_dp = return_dangling_pointer_coerce(s);\n+    let _unary_dp = return_dangling_pointer_unary_op(s);\n+    let _binary_dp = return_dangling_pointer_binary_op(s);\n+    let _method_dp = return_dangling_pointer_method(s);\n+    let _ufcs_dp = return_dangling_pointer_ufcs(s);\n+}"}, {"sha": "6c6522fe658d23ec0053b575e32db7f33026a993", "filename": "src/test/compile-fail/wf-static-method.rs", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/130851e03046db41d555a401a08c87f187fd911a/src%2Ftest%2Fcompile-fail%2Fwf-static-method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/130851e03046db41d555a401a08c87f187fd911a/src%2Ftest%2Fcompile-fail%2Fwf-static-method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fwf-static-method.rs?ref=130851e03046db41d555a401a08c87f187fd911a", "patch": "@@ -0,0 +1,64 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// check that static methods don't get to assume their trait-ref\n+// is well-formed.\n+// FIXME(#27579): this is just a bug. However, our checking with\n+// static inherent methods isn't quite working - need to\n+// fix that before removing the check.\n+\n+trait Foo<'a, 'b, T>: Sized {\n+    fn make_me() -> Self { loop {} }\n+    fn static_evil(u: &'b u32) -> &'a u32;\n+}\n+\n+struct Evil<'a, 'b: 'a>(Option<&'a &'b ()>);\n+\n+impl<'a, 'b> Foo<'a, 'b, Evil<'a, 'b>> for () {\n+    fn make_me() -> Self { }\n+    fn static_evil(u: &'b u32) -> &'a u32 {\n+        u //~ ERROR cannot infer an appropriate lifetime\n+    }\n+}\n+\n+struct IndirectEvil<'a, 'b: 'a>(Option<&'a &'b ()>);\n+\n+impl<'a, 'b> Foo<'a, 'b, ()> for IndirectEvil<'a, 'b> {\n+    fn make_me() -> Self { IndirectEvil(None) }\n+    fn static_evil(u: &'b u32) -> &'a u32 {\n+        let me = Self::make_me(); //~ ERROR lifetime bound not satisfied\n+        loop {} // (`me` could be used for the lifetime transmute).\n+    }\n+}\n+\n+impl<'a, 'b> Evil<'a, 'b> {\n+    fn inherent_evil(u: &'b u32) -> &'a u32 {\n+        u //~ ERROR cannot infer an appropriate lifetime\n+    }\n+}\n+\n+// while static methods don't get to *assume* this, we still\n+// *check* that they hold.\n+\n+fn evil<'a, 'b>(b: &'b u32) -> &'a u32 {\n+    <()>::static_evil(b) //~ ERROR cannot infer an appropriate lifetime\n+}\n+\n+fn indirect_evil<'a, 'b>(b: &'b u32) -> &'a u32 {\n+    <IndirectEvil>::static_evil(b)\n+    //~^ ERROR cannot infer an appropriate lifetime\n+}\n+\n+fn inherent_evil<'a, 'b>(b: &'b u32) -> &'a u32 {\n+    <Evil>::inherent_evil(b) // bug? shouldn't this be an error\n+}\n+\n+\n+fn main() {}"}]}