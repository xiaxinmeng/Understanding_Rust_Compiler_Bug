{"sha": "419069d984e3f4cf33768003fa5eaccae51fec10", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQxOTA2OWQ5ODRlM2Y0Y2YzMzc2ODAwM2ZhNWVhY2NhZTUxZmVjMTA=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2017-09-16T13:45:49Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2017-09-22T21:50:46Z"}, "message": "Use recorded types in rustc_privacy", "tree": {"sha": "8e07cff4368285166639354c223df0337b3439d5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8e07cff4368285166639354c223df0337b3439d5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/419069d984e3f4cf33768003fa5eaccae51fec10", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/419069d984e3f4cf33768003fa5eaccae51fec10", "html_url": "https://github.com/rust-lang/rust/commit/419069d984e3f4cf33768003fa5eaccae51fec10", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/419069d984e3f4cf33768003fa5eaccae51fec10/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "505ff71ac1c427f1777805bfced50c8938029bcb", "url": "https://api.github.com/repos/rust-lang/rust/commits/505ff71ac1c427f1777805bfced50c8938029bcb", "html_url": "https://github.com/rust-lang/rust/commit/505ff71ac1c427f1777805bfced50c8938029bcb"}], "stats": {"total": 164, "additions": 43, "deletions": 121}, "files": [{"sha": "807375e00afdbe58a9fac223154c477aaab35317", "filename": "src/Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/419069d984e3f4cf33768003fa5eaccae51fec10/src%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/419069d984e3f4cf33768003fa5eaccae51fec10/src%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FCargo.lock?ref=419069d984e3f4cf33768003fa5eaccae51fec10", "patch": "@@ -1715,6 +1715,7 @@ name = \"rustc_privacy\"\n version = \"0.0.0\"\n dependencies = [\n  \"rustc 0.0.0\",\n+ \"rustc_typeck 0.0.0\",\n  \"syntax 0.0.0\",\n  \"syntax_pos 0.0.0\",\n ]"}, {"sha": "c65312e9a8337e8fd48f3d290d91926bb97956d6", "filename": "src/librustc_privacy/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/419069d984e3f4cf33768003fa5eaccae51fec10/src%2Flibrustc_privacy%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/419069d984e3f4cf33768003fa5eaccae51fec10/src%2Flibrustc_privacy%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2FCargo.toml?ref=419069d984e3f4cf33768003fa5eaccae51fec10", "patch": "@@ -10,5 +10,6 @@ crate-type = [\"dylib\"]\n \n [dependencies]\n rustc = { path = \"../librustc\" }\n+rustc_typeck = { path = \"../librustc_typeck\" }\n syntax = { path = \"../libsyntax\" }\n syntax_pos = { path = \"../libsyntax_pos\" }"}, {"sha": "e7a1dd6b043b173b51022a94877f785c0a301d35", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 37, "deletions": 118, "changes": 155, "blob_url": "https://github.com/rust-lang/rust/blob/419069d984e3f4cf33768003fa5eaccae51fec10/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/419069d984e3f4cf33768003fa5eaccae51fec10/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=419069d984e3f4cf33768003fa5eaccae51fec10", "patch": "@@ -17,6 +17,7 @@\n \n #[macro_use] extern crate rustc;\n #[macro_use] extern crate syntax;\n+extern crate rustc_typeck;\n extern crate syntax_pos;\n \n use rustc::hir::{self, PatKind};\n@@ -658,65 +659,6 @@ impl<'a, 'tcx> TypePrivacyVisitor<'a, 'tcx> {\n         }\n         false\n     }\n-\n-    fn check_item(&mut self, item_id: ast::NodeId) -> &mut Self {\n-        self.current_item = self.tcx.hir.local_def_id(item_id);\n-        self.span = self.tcx.hir.span(item_id);\n-        self\n-    }\n-\n-    // Convenience methods for checking item interfaces\n-    fn ty(&mut self) -> &mut Self {\n-        self.tcx.type_of(self.current_item).visit_with(self);\n-        self\n-    }\n-\n-    fn generics(&mut self) -> &mut Self {\n-        for def in &self.tcx.generics_of(self.current_item).types {\n-            if def.has_default {\n-                self.tcx.type_of(def.def_id).visit_with(self);\n-            }\n-        }\n-        self\n-    }\n-\n-    fn predicates(&mut self) -> &mut Self {\n-        let predicates = self.tcx.predicates_of(self.current_item);\n-        for predicate in &predicates.predicates {\n-            predicate.visit_with(self);\n-            match predicate {\n-                &ty::Predicate::Trait(poly_predicate) => {\n-                    self.check_trait_ref(poly_predicate.skip_binder().trait_ref);\n-                },\n-                &ty::Predicate::Projection(poly_predicate) => {\n-                    let tcx = self.tcx;\n-                    self.check_trait_ref(\n-                        poly_predicate.skip_binder().projection_ty.trait_ref(tcx)\n-                    );\n-                },\n-                _ => (),\n-            };\n-        }\n-        self\n-    }\n-\n-    fn impl_trait_ref(&mut self) -> &mut Self {\n-        if let Some(impl_trait_ref) = self.tcx.impl_trait_ref(self.current_item) {\n-            self.check_trait_ref(impl_trait_ref);\n-        }\n-        self.tcx.predicates_of(self.current_item).visit_with(self);\n-        self\n-    }\n-\n-    fn check_trait_ref(&mut self, trait_ref: ty::TraitRef<'tcx>) -> bool {\n-        if !self.item_is_accessible(trait_ref.def_id) {\n-            let msg = format!(\"trait `{}` is private\", trait_ref);\n-            self.tcx.sess.span_err(self.span, &msg);\n-            return true;\n-        }\n-\n-        trait_ref.super_visit_with(self)\n-    }\n }\n \n impl<'a, 'tcx> Visitor<'tcx> for TypePrivacyVisitor<'a, 'tcx> {\n@@ -733,6 +675,35 @@ impl<'a, 'tcx> Visitor<'tcx> for TypePrivacyVisitor<'a, 'tcx> {\n         self.tables = orig_tables;\n     }\n \n+    fn visit_ty(&mut self, hir_ty: &'tcx hir::Ty) {\n+        self.span = hir_ty.span;\n+        if let Some(ty) = self.tables.node_id_to_type_opt(hir_ty.hir_id) {\n+            // Types in bodies.\n+            if ty.visit_with(self) {\n+                return;\n+            }\n+        } else {\n+            // Types in signatures.\n+            // FIXME: This is very ineffective. Ideally each HIR type should be converted\n+            // into a semantic type only once and the result should be cached somehow.\n+            if rustc_typeck::hir_ty_to_ty(self.tcx, hir_ty).visit_with(self) {\n+                return;\n+            }\n+        }\n+\n+        intravisit::walk_ty(self, hir_ty);\n+    }\n+\n+    fn visit_trait_ref(&mut self, trait_ref: &'tcx hir::TraitRef) {\n+        if !self.item_is_accessible(trait_ref.path.def.def_id()) {\n+            let msg = format!(\"trait `{:?}` is private\", trait_ref.path);\n+            self.tcx.sess.span_err(self.span, &msg);\n+            return;\n+        }\n+\n+        intravisit::walk_trait_ref(self, trait_ref);\n+    }\n+\n     // Check types of expressions\n     fn visit_expr(&mut self, expr: &'tcx hir::Expr) {\n         if self.check_expr_pat_type(expr.hir_id, expr.span) {\n@@ -807,63 +778,6 @@ impl<'a, 'tcx> Visitor<'tcx> for TypePrivacyVisitor<'a, 'tcx> {\n                                         item.id,\n                                         &mut self.tables,\n                                         self.empty_tables);\n-\n-        match item.node {\n-            hir::ItemExternCrate(..) | hir::ItemMod(..) |\n-            hir::ItemUse(..) | hir::ItemGlobalAsm(..) => {}\n-            hir::ItemConst(..) | hir::ItemStatic(..) |\n-            hir::ItemTy(..) | hir::ItemFn(..) => {\n-                self.check_item(item.id).generics().predicates().ty();\n-            }\n-            hir::ItemTrait(.., ref trait_item_refs) => {\n-                self.check_item(item.id).generics().predicates();\n-                for trait_item_ref in trait_item_refs {\n-                    let check = self.check_item(trait_item_ref.id.node_id);\n-                    check.generics().predicates();\n-                    if trait_item_ref.kind != hir::AssociatedItemKind::Type ||\n-                       trait_item_ref.defaultness.has_value() {\n-                        check.ty();\n-                    }\n-                }\n-            }\n-            hir::ItemEnum(ref def, _) => {\n-                self.check_item(item.id).generics().predicates();\n-                for variant in &def.variants {\n-                    for field in variant.node.data.fields() {\n-                        self.check_item(field.id).ty();\n-                    }\n-                }\n-            }\n-            hir::ItemForeignMod(ref foreign_mod) => {\n-                for foreign_item in &foreign_mod.items {\n-                    self.check_item(foreign_item.id).generics().predicates().ty();\n-                }\n-            }\n-            hir::ItemStruct(ref struct_def, _) |\n-            hir::ItemUnion(ref struct_def, _) => {\n-                self.check_item(item.id).generics().predicates();\n-                for field in struct_def.fields() {\n-                    self.check_item(field.id).ty();\n-                }\n-            }\n-            hir::ItemDefaultImpl(..) => {\n-                self.check_item(item.id).impl_trait_ref();\n-            }\n-            hir::ItemImpl(.., ref trait_ref, _, ref impl_item_refs) => {\n-                {\n-                    let check = self.check_item(item.id);\n-                    check.ty().generics().predicates();\n-                    if trait_ref.is_some() {\n-                        check.impl_trait_ref();\n-                    }\n-                }\n-                for impl_item_ref in impl_item_refs {\n-                    let impl_item = self.tcx.hir.impl_item(impl_item_ref.id);\n-                    self.check_item(impl_item.id).generics().predicates().ty();\n-                }\n-            }\n-        }\n-\n         self.current_item = self.tcx.hir.local_def_id(item.id);\n         intravisit::walk_item(self, item);\n         self.tables = orig_tables;\n@@ -924,8 +838,13 @@ impl<'a, 'tcx> TypeVisitor<'tcx> for TypePrivacyVisitor<'a, 'tcx> {\n                 }\n             }\n             ty::TyProjection(ref proj) => {\n-                let tcx = self.tcx;\n-                if self.check_trait_ref(proj.trait_ref(tcx)) {\n+                let trait_ref = proj.trait_ref(self.tcx);\n+                if !self.item_is_accessible(trait_ref.def_id) {\n+                    let msg = format!(\"trait `{}` is private\", trait_ref);\n+                    self.tcx.sess.span_err(self.span, &msg);\n+                    return true;\n+                }\n+                if trait_ref.super_visit_with(self) {\n                     return true;\n                 }\n             }"}, {"sha": "de455afbd6629d73b4cc9fa265dc43528b800d07", "filename": "src/test/compile-fail/lint-stability-deprecated.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/419069d984e3f4cf33768003fa5eaccae51fec10/src%2Ftest%2Fcompile-fail%2Flint-stability-deprecated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/419069d984e3f4cf33768003fa5eaccae51fec10/src%2Ftest%2Fcompile-fail%2Flint-stability-deprecated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-stability-deprecated.rs?ref=419069d984e3f4cf33768003fa5eaccae51fec10", "patch": "@@ -107,6 +107,7 @@ mod cross_crate {\n         struct S1<T: TraitWithAssociatedTypes>(T::TypeUnstable);\n         struct S2<T: TraitWithAssociatedTypes>(T::TypeDeprecated);\n         //~^ WARN use of deprecated item\n+        //~| WARN use of deprecated item\n \n         let _ = DeprecatedStruct { //~ WARN use of deprecated item\n             i: 0 //~ WARN use of deprecated item"}, {"sha": "973d467b1122670184cbee8cf5e345b6ac899b22", "filename": "src/test/compile-fail/private-inferred-type.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/419069d984e3f4cf33768003fa5eaccae51fec10/src%2Ftest%2Fcompile-fail%2Fprivate-inferred-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/419069d984e3f4cf33768003fa5eaccae51fec10/src%2Ftest%2Fcompile-fail%2Fprivate-inferred-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fprivate-inferred-type.rs?ref=419069d984e3f4cf33768003fa5eaccae51fec10", "patch": "@@ -103,10 +103,11 @@ mod adjust {\n \n fn main() {\n     let _: m::Alias; //~ ERROR type `m::Priv` is private\n-    let _: <m::Alias as m::TraitWithAssocTy>::AssocTy; // FIXME\n+                     //~^ ERROR type `m::Priv` is private\n+    let _: <m::Alias as m::TraitWithAssocTy>::AssocTy; //~ ERROR type `m::Priv` is private\n     m::Alias {}; //~ ERROR type `m::Priv` is private\n     m::Pub { 0: m::Alias {} }; //~ ERROR type `m::Priv` is private\n-    m::Pub { 0: loop {} }; // FIXME\n+    m::Pub { 0: loop {} }; // OK, `m::Pub` is in value context, so it means Pub<_>, not Pub<Priv>\n     m::Pub::static_method; //~ ERROR type `m::Priv` is private\n     m::Pub::INHERENT_ASSOC_CONST; //~ ERROR type `m::Priv` is private\n     m::Pub(0u8).method_with_substs::<m::Alias>(); //~ ERROR type `m::Priv` is private"}, {"sha": "eb8c40a7dd5e821b0436334be6a073b900dfd1b6", "filename": "src/test/compile-fail/private-type-in-interface.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/419069d984e3f4cf33768003fa5eaccae51fec10/src%2Ftest%2Fcompile-fail%2Fprivate-type-in-interface.rs", "raw_url": "https://github.com/rust-lang/rust/raw/419069d984e3f4cf33768003fa5eaccae51fec10/src%2Ftest%2Fcompile-fail%2Fprivate-type-in-interface.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fprivate-type-in-interface.rs?ref=419069d984e3f4cf33768003fa5eaccae51fec10", "patch": "@@ -31,7 +31,6 @@ fn f_ext(_: ext::Alias) {} //~ ERROR type `ext::Priv` is private\n trait Tr1 {}\n impl m::Alias {} //~ ERROR type `m::Priv` is private\n impl Tr1 for ext::Alias {} //~ ERROR type `ext::Priv` is private\n-                           //~^ ERROR type `ext::Priv` is private\n type A = <m::Alias as m::Trait>::X; //~ ERROR type `m::Priv` is private\n \n trait Tr2<T> {}"}]}