{"sha": "01f8e25b15f4ab157c8e7c9c56054df7595ec0e1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAxZjhlMjViMTVmNGFiMTU3YzhlN2M5YzU2MDU0ZGY3NTk1ZWMwZTE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-01-24T15:48:46Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-01-24T15:48:46Z"}, "message": "Auto merge of #51285 - Mark-Simulacrum:remove-quote_apis, r=Manishearth\n\nRemove quote_*! macros\n\nThis deletes a considerable amount of test cases, some of which we may want to keep. I'm not entirely certain what the primary intent of many of them was; if we should keep them I can attempt to edit each case to continue compiling without the quote_*! macros involved.\n\nFixes #46849.\nFixes #12265.\nFixes #12266.\nFixes #26994.\n\nr? @Manishearth", "tree": {"sha": "5c4eeb98011f8ae07b45521ea85759e8a168bc22", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5c4eeb98011f8ae07b45521ea85759e8a168bc22"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/01f8e25b15f4ab157c8e7c9c56054df7595ec0e1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/01f8e25b15f4ab157c8e7c9c56054df7595ec0e1", "html_url": "https://github.com/rust-lang/rust/commit/01f8e25b15f4ab157c8e7c9c56054df7595ec0e1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/01f8e25b15f4ab157c8e7c9c56054df7595ec0e1/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "095b44c83b540bb4dbf74be1cae604f4bae87989", "url": "https://api.github.com/repos/rust-lang/rust/commits/095b44c83b540bb4dbf74be1cae604f4bae87989", "html_url": "https://github.com/rust-lang/rust/commit/095b44c83b540bb4dbf74be1cae604f4bae87989"}, {"sha": "db97c48ad6e7f36468b152e9b08efc6f2f7da691", "url": "https://api.github.com/repos/rust-lang/rust/commits/db97c48ad6e7f36468b152e9b08efc6f2f7da691", "html_url": "https://github.com/rust-lang/rust/commit/db97c48ad6e7f36468b152e9b08efc6f2f7da691"}], "stats": {"total": 2276, "additions": 57, "deletions": 2219}, "files": [{"sha": "c3dc9458839e45dc7589d751efee6b3b13c3803a", "filename": "src/bootstrap/builder.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/01f8e25b15f4ab157c8e7c9c56054df7595ec0e1/src%2Fbootstrap%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01f8e25b15f4ab157c8e7c9c56054df7595ec0e1/src%2Fbootstrap%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder.rs?ref=01f8e25b15f4ab157c8e7c9c56054df7595ec0e1", "patch": "@@ -378,14 +378,11 @@ impl<'a> Builder<'a> {\n                 test::Debuginfo,\n                 test::UiFullDeps,\n                 test::RunPassFullDeps,\n-                test::RunFailFullDeps,\n                 test::Rustdoc,\n                 test::Pretty,\n                 test::RunPassPretty,\n                 test::RunFailPretty,\n                 test::RunPassValgrindPretty,\n-                test::RunPassFullDepsPretty,\n-                test::RunFailFullDepsPretty,\n                 test::Crate,\n                 test::CrateLibrustc,\n                 test::CrateRustdoc,"}, {"sha": "1c27cf3909b1af806184f743e9343cde12656b11", "filename": "src/bootstrap/mk/Makefile.in", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/01f8e25b15f4ab157c8e7c9c56054df7595ec0e1/src%2Fbootstrap%2Fmk%2FMakefile.in", "raw_url": "https://github.com/rust-lang/rust/raw/01f8e25b15f4ab157c8e7c9c56054df7595ec0e1/src%2Fbootstrap%2Fmk%2FMakefile.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fmk%2FMakefile.in?ref=01f8e25b15f4ab157c8e7c9c56054df7595ec0e1", "patch": "@@ -53,7 +53,6 @@ check-aux:\n \t\tsrc/test/run-fail/pretty \\\n \t\tsrc/test/run-pass-valgrind/pretty \\\n \t\tsrc/test/run-pass-fulldeps/pretty \\\n-\t\tsrc/test/run-fail-fulldeps/pretty \\\n \t\t$(AUX_ARGS) \\\n \t\t$(BOOTSTRAP_ARGS)\n check-bootstrap:"}, {"sha": "216649808e2a4a8fa39ce1b634312e9c1b1e6d0d", "filename": "src/bootstrap/test.rs", "status": "modified", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/01f8e25b15f4ab157c8e7c9c56054df7595ec0e1/src%2Fbootstrap%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01f8e25b15f4ab157c8e7c9c56054df7595ec0e1/src%2Fbootstrap%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftest.rs?ref=01f8e25b15f4ab157c8e7c9c56054df7595ec0e1", "patch": "@@ -848,12 +848,6 @@ host_test!(RunPassFullDeps {\n     suite: \"run-pass-fulldeps\"\n });\n \n-host_test!(RunFailFullDeps {\n-    path: \"src/test/run-fail-fulldeps\",\n-    mode: \"run-fail\",\n-    suite: \"run-fail-fulldeps\"\n-});\n-\n host_test!(Rustdoc {\n     path: \"src/test/rustdoc\",\n     mode: \"rustdoc\",\n@@ -888,20 +882,6 @@ test!(RunPassValgrindPretty {\n     default: false,\n     host: true\n });\n-test!(RunPassFullDepsPretty {\n-    path: \"src/test/run-pass-fulldeps/pretty\",\n-    mode: \"pretty\",\n-    suite: \"run-pass-fulldeps\",\n-    default: false,\n-    host: true\n-});\n-test!(RunFailFullDepsPretty {\n-    path: \"src/test/run-fail-fulldeps/pretty\",\n-    mode: \"pretty\",\n-    suite: \"run-fail-fulldeps\",\n-    default: false,\n-    host: true\n-});\n \n default_test!(RunMake {\n     path: \"src/test/run-make\","}, {"sha": "cab350381d2bd3029d422b71b9ea4d8e320b83c4", "filename": "src/doc/unstable-book/src/language-features/plugin.md", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/01f8e25b15f4ab157c8e7c9c56054df7595ec0e1/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fplugin.md", "raw_url": "https://github.com/rust-lang/rust/raw/01f8e25b15f4ab157c8e7c9c56054df7595ec0e1/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fplugin.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fplugin.md?ref=01f8e25b15f4ab157c8e7c9c56054df7595ec0e1", "patch": "@@ -52,14 +52,15 @@ that implements Roman numeral integer literals.\n #![feature(plugin_registrar, rustc_private)]\n \n extern crate syntax;\n+extern crate syntax_pos;\n extern crate rustc;\n extern crate rustc_plugin;\n \n use syntax::parse::token;\n use syntax::tokenstream::TokenTree;\n use syntax::ext::base::{ExtCtxt, MacResult, DummyResult, MacEager};\n use syntax::ext::build::AstBuilder;  // A trait for expr_usize.\n-use syntax::ext::quote::rt::Span;\n+use syntax_pos::Span;\n use rustc_plugin::Registry;\n \n fn expand_rn(cx: &mut ExtCtxt, sp: Span, args: &[TokenTree])"}, {"sha": "7ecec0b9a69acc724e4d27c3712c56ff1dac1dad", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/01f8e25b15f4ab157c8e7c9c56054df7595ec0e1/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01f8e25b15f4ab157c8e7c9c56054df7595ec0e1/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=01f8e25b15f4ab157c8e7c9c56054df7595ec0e1", "patch": "@@ -41,7 +41,6 @@\n #![feature(nll)]\n #![feature(non_exhaustive)]\n #![feature(proc_macro_internals)]\n-#![feature(quote)]\n #![feature(optin_builtin_traits)]\n #![feature(refcell_replace_swap)]\n #![feature(rustc_diagnostic_macros)]"}, {"sha": "8bdc4e1d5c1ea888338681a7d92f7a47d2851595", "filename": "src/librustc_borrowck/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/01f8e25b15f4ab157c8e7c9c56054df7595ec0e1/src%2Flibrustc_borrowck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01f8e25b15f4ab157c8e7c9c56054df7595ec0e1/src%2Flibrustc_borrowck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Flib.rs?ref=01f8e25b15f4ab157c8e7c9c56054df7595ec0e1", "patch": "@@ -5,7 +5,6 @@\n #![allow(non_camel_case_types)]\n \n #![feature(nll)]\n-#![feature(quote)]\n \n #![recursion_limit=\"256\"]\n "}, {"sha": "a88b1a8f52e96a9a9d89c7d417b19cf135b8cd71", "filename": "src/librustc_codegen_llvm/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/01f8e25b15f4ab157c8e7c9c56054df7595ec0e1/src%2Flibrustc_codegen_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01f8e25b15f4ab157c8e7c9c56054df7595ec0e1/src%2Flibrustc_codegen_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Flib.rs?ref=01f8e25b15f4ab157c8e7c9c56054df7595ec0e1", "patch": "@@ -17,7 +17,6 @@\n #![allow(unused_attributes)]\n #![feature(libc)]\n #![feature(nll)]\n-#![feature(quote)]\n #![feature(range_contains)]\n #![feature(rustc_diagnostic_macros)]\n #![feature(slice_sort_by_cached_key)]"}, {"sha": "1accbeb2aa822d2af3cd8ba1cc5adb018a18507c", "filename": "src/librustc_codegen_ssa/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/01f8e25b15f4ab157c8e7c9c56054df7595ec0e1/src%2Flibrustc_codegen_ssa%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01f8e25b15f4ab157c8e7c9c56054df7595ec0e1/src%2Flibrustc_codegen_ssa%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Flib.rs?ref=01f8e25b15f4ab157c8e7c9c56054df7595ec0e1", "patch": "@@ -12,7 +12,6 @@\n #![feature(nll)]\n #![allow(unused_attributes)]\n #![allow(dead_code)]\n-#![feature(quote)]\n \n #![recursion_limit=\"256\"]\n "}, {"sha": "1f590d46ed8c657bb18b48b173ce8c2b06a75366", "filename": "src/librustc_codegen_utils/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/01f8e25b15f4ab157c8e7c9c56054df7595ec0e1/src%2Flibrustc_codegen_utils%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01f8e25b15f4ab157c8e7c9c56054df7595ec0e1/src%2Flibrustc_codegen_utils%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_utils%2Flib.rs?ref=01f8e25b15f4ab157c8e7c9c56054df7595ec0e1", "patch": "@@ -11,7 +11,6 @@\n #![feature(custom_attribute)]\n #![feature(nll)]\n #![allow(unused_attributes)]\n-#![feature(quote)]\n #![feature(rustc_diagnostic_macros)]\n \n #![recursion_limit=\"256\"]"}, {"sha": "142d60c8d00b290bc1222c2794af7a60e81849a6", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/01f8e25b15f4ab157c8e7c9c56054df7595ec0e1/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01f8e25b15f4ab157c8e7c9c56054df7595ec0e1/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=01f8e25b15f4ab157c8e7c9c56054df7595ec0e1", "patch": "@@ -916,7 +916,7 @@ where\n         crate_loader,\n         &resolver_arenas,\n     );\n-    syntax_ext::register_builtins(&mut resolver, syntax_exts, sess.features_untracked().quote);\n+    syntax_ext::register_builtins(&mut resolver, syntax_exts);\n \n     // Expand all macros\n     sess.profiler(|p| p.start_activity(ProfileCategory::Expansion));"}, {"sha": "abcdf175ada996c73e3175480d36c20f38b78f41", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/01f8e25b15f4ab157c8e7c9c56054df7595ec0e1/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01f8e25b15f4ab157c8e7c9c56054df7595ec0e1/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=01f8e25b15f4ab157c8e7c9c56054df7595ec0e1", "patch": "@@ -11,7 +11,6 @@\n #![feature(box_syntax)]\n #![cfg_attr(unix, feature(libc))]\n #![feature(nll)]\n-#![feature(quote)]\n #![feature(rustc_diagnostic_macros)]\n #![feature(slice_sort_by_cached_key)]\n #![feature(set_stdio)]"}, {"sha": "d3d17184a01815527f1dc632d4b193ca20d49cb5", "filename": "src/librustc_lint/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/01f8e25b15f4ab157c8e7c9c56054df7595ec0e1/src%2Flibrustc_lint%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01f8e25b15f4ab157c8e7c9c56054df7595ec0e1/src%2Flibrustc_lint%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Flib.rs?ref=01f8e25b15f4ab157c8e7c9c56054df7595ec0e1", "patch": "@@ -17,7 +17,6 @@\n #![feature(box_patterns)]\n #![feature(box_syntax)]\n #![feature(nll)]\n-#![feature(quote)]\n #![feature(rustc_diagnostic_macros)]\n \n #![recursion_limit=\"256\"]"}, {"sha": "1a6614212407d4b5ffd7e3441832a0048623f484", "filename": "src/librustc_metadata/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/01f8e25b15f4ab157c8e7c9c56054df7595ec0e1/src%2Flibrustc_metadata%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01f8e25b15f4ab157c8e7c9c56054df7595ec0e1/src%2Flibrustc_metadata%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Flib.rs?ref=01f8e25b15f4ab157c8e7c9c56054df7595ec0e1", "patch": "@@ -7,7 +7,6 @@\n #![feature(nll)]\n #![feature(proc_macro_internals)]\n #![feature(proc_macro_quote)]\n-#![feature(quote)]\n #![feature(rustc_diagnostic_macros)]\n #![feature(slice_sort_by_cached_key)]\n #![feature(crate_visibility_modifier)]"}, {"sha": "5149f460baca0a21ea24dbb3e9a52839cacc320b", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/01f8e25b15f4ab157c8e7c9c56054df7595ec0e1/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01f8e25b15f4ab157c8e7c9c56054df7595ec0e1/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=01f8e25b15f4ab157c8e7c9c56054df7595ec0e1", "patch": "@@ -66,7 +66,6 @@ This API is completely unstable and subject to change.\n #![feature(crate_visibility_modifier)]\n #![feature(exhaustive_patterns)]\n #![feature(nll)]\n-#![feature(quote)]\n #![feature(refcell_replace_swap)]\n #![feature(rustc_diagnostic_macros)]\n #![feature(slice_patterns)]"}, {"sha": "df3b49cf6ed73b8970db0ce951df1da0011761f2", "filename": "src/libsyntax/ext/quote.rs", "status": "removed", "additions": 0, "deletions": 893, "changes": 893, "blob_url": "https://github.com/rust-lang/rust/blob/095b44c83b540bb4dbf74be1cae604f4bae87989/src%2Flibsyntax%2Fext%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/095b44c83b540bb4dbf74be1cae604f4bae87989/src%2Flibsyntax%2Fext%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fquote.rs?ref=095b44c83b540bb4dbf74be1cae604f4bae87989", "patch": "@@ -1,893 +0,0 @@\n-use ast::{self, Arg, Arm, Block, Expr, Item, Pat, Stmt, Ty};\n-use source_map::respan;\n-use syntax_pos::{Span, DUMMY_SP};\n-use ext::base::ExtCtxt;\n-use ext::base;\n-use ext::build::AstBuilder;\n-use parse::parser::{Parser, PathStyle};\n-use parse::token;\n-use ptr::P;\n-use tokenstream::{DelimSpan, TokenStream, TokenTree};\n-\n-/// Quasiquoting works via token trees.\n-///\n-/// This is registered as a set of expression syntax extension called quote!\n-/// that lifts its argument token-tree to an AST representing the\n-/// construction of the same token tree, with `token::SubstNt` interpreted\n-/// as antiquotes (splices).\n-\n-pub mod rt {\n-    use ast;\n-    use source_map::Spanned;\n-    use ext::base::ExtCtxt;\n-    use parse::{self, classify};\n-    use parse::token::{self, Token};\n-    use ptr::P;\n-    use symbol::Symbol;\n-    use ThinVec;\n-\n-    use tokenstream::{DelimSpan, TokenTree, TokenStream};\n-\n-    pub use parse::new_parser_from_tts;\n-    pub use syntax_pos::{BytePos, Span, DUMMY_SP, FileName};\n-    pub use source_map::{dummy_spanned};\n-\n-    pub trait ToTokens {\n-        fn to_tokens(&self, _cx: &ExtCtxt) -> Vec<TokenTree>;\n-    }\n-\n-    impl ToTokens for TokenTree {\n-        fn to_tokens(&self, _cx: &ExtCtxt) -> Vec<TokenTree> {\n-            vec![self.clone()]\n-        }\n-    }\n-\n-    impl<T: ToTokens> ToTokens for Vec<T> {\n-        fn to_tokens(&self, cx: &ExtCtxt) -> Vec<TokenTree> {\n-            self.iter().flat_map(|t| t.to_tokens(cx)).collect()\n-        }\n-    }\n-\n-    impl<T: ToTokens> ToTokens for Spanned<T> {\n-        fn to_tokens(&self, cx: &ExtCtxt) -> Vec<TokenTree> {\n-            // FIXME: use the span?\n-            self.node.to_tokens(cx)\n-        }\n-    }\n-\n-    impl<T: ToTokens> ToTokens for Option<T> {\n-        fn to_tokens(&self, cx: &ExtCtxt) -> Vec<TokenTree> {\n-            match *self {\n-                Some(ref t) => t.to_tokens(cx),\n-                None => Vec::new(),\n-            }\n-        }\n-    }\n-\n-    impl ToTokens for ast::Ident {\n-        fn to_tokens(&self, _cx: &ExtCtxt) -> Vec<TokenTree> {\n-            vec![TokenTree::Token(self.span, Token::from_ast_ident(*self))]\n-        }\n-    }\n-\n-    impl ToTokens for ast::Path {\n-        fn to_tokens(&self, _cx: &ExtCtxt) -> Vec<TokenTree> {\n-            let nt = token::NtPath(self.clone());\n-            vec![TokenTree::Token(DUMMY_SP, Token::interpolated(nt))]\n-        }\n-    }\n-\n-    impl ToTokens for ast::Ty {\n-        fn to_tokens(&self, _cx: &ExtCtxt) -> Vec<TokenTree> {\n-            let nt = token::NtTy(P(self.clone()));\n-            vec![TokenTree::Token(self.span, Token::interpolated(nt))]\n-        }\n-    }\n-\n-    impl ToTokens for ast::Block {\n-        fn to_tokens(&self, _cx: &ExtCtxt) -> Vec<TokenTree> {\n-            let nt = token::NtBlock(P(self.clone()));\n-            vec![TokenTree::Token(self.span, Token::interpolated(nt))]\n-        }\n-    }\n-\n-    impl ToTokens for ast::Generics {\n-        fn to_tokens(&self, _cx: &ExtCtxt) -> Vec<TokenTree> {\n-            let nt = token::NtGenerics(self.clone());\n-            vec![TokenTree::Token(DUMMY_SP, Token::interpolated(nt))]\n-        }\n-    }\n-\n-    impl ToTokens for ast::WhereClause {\n-        fn to_tokens(&self, _cx: &ExtCtxt) -> Vec<TokenTree> {\n-            let nt = token::NtWhereClause(self.clone());\n-            vec![TokenTree::Token(DUMMY_SP, Token::interpolated(nt))]\n-        }\n-    }\n-\n-    impl ToTokens for P<ast::Item> {\n-        fn to_tokens(&self, _cx: &ExtCtxt) -> Vec<TokenTree> {\n-            let nt = token::NtItem(self.clone());\n-            vec![TokenTree::Token(self.span, Token::interpolated(nt))]\n-        }\n-    }\n-\n-    impl ToTokens for ast::ImplItem {\n-        fn to_tokens(&self, _cx: &ExtCtxt) -> Vec<TokenTree> {\n-            let nt = token::NtImplItem(self.clone());\n-            vec![TokenTree::Token(self.span, Token::interpolated(nt))]\n-        }\n-    }\n-\n-    impl ToTokens for P<ast::ImplItem> {\n-        fn to_tokens(&self, _cx: &ExtCtxt) -> Vec<TokenTree> {\n-            let nt = token::NtImplItem((**self).clone());\n-            vec![TokenTree::Token(self.span, Token::interpolated(nt))]\n-        }\n-    }\n-\n-    impl ToTokens for ast::TraitItem {\n-        fn to_tokens(&self, _cx: &ExtCtxt) -> Vec<TokenTree> {\n-            let nt = token::NtTraitItem(self.clone());\n-            vec![TokenTree::Token(self.span, Token::interpolated(nt))]\n-        }\n-    }\n-\n-    impl ToTokens for ast::Stmt {\n-        fn to_tokens(&self, _cx: &ExtCtxt) -> Vec<TokenTree> {\n-            let nt = token::NtStmt(self.clone());\n-            let mut tts = vec![TokenTree::Token(self.span, Token::interpolated(nt))];\n-\n-            // Some statements require a trailing semicolon.\n-            if classify::stmt_ends_with_semi(&self.node) {\n-                tts.push(TokenTree::Token(self.span, token::Semi));\n-            }\n-\n-            tts\n-        }\n-    }\n-\n-    impl ToTokens for P<ast::Expr> {\n-        fn to_tokens(&self, _cx: &ExtCtxt) -> Vec<TokenTree> {\n-            let nt = token::NtExpr(self.clone());\n-            vec![TokenTree::Token(self.span, Token::interpolated(nt))]\n-        }\n-    }\n-\n-    impl ToTokens for P<ast::Pat> {\n-        fn to_tokens(&self, _cx: &ExtCtxt) -> Vec<TokenTree> {\n-            let nt = token::NtPat(self.clone());\n-            vec![TokenTree::Token(self.span, Token::interpolated(nt))]\n-        }\n-    }\n-\n-    impl ToTokens for ast::Arm {\n-        fn to_tokens(&self, _cx: &ExtCtxt) -> Vec<TokenTree> {\n-            let nt = token::NtArm(self.clone());\n-            vec![TokenTree::Token(DUMMY_SP, Token::interpolated(nt))]\n-        }\n-    }\n-\n-    impl ToTokens for ast::Arg {\n-        fn to_tokens(&self, _cx: &ExtCtxt) -> Vec<TokenTree> {\n-            let nt = token::NtArg(self.clone());\n-            vec![TokenTree::Token(DUMMY_SP, Token::interpolated(nt))]\n-        }\n-    }\n-\n-    impl ToTokens for P<ast::Block> {\n-        fn to_tokens(&self, _cx: &ExtCtxt) -> Vec<TokenTree> {\n-            let nt = token::NtBlock(self.clone());\n-            vec![TokenTree::Token(DUMMY_SP, Token::interpolated(nt))]\n-        }\n-    }\n-\n-    impl ToTokens for ast::Lifetime {\n-        fn to_tokens(&self, _cx: &ExtCtxt) -> Vec<TokenTree> {\n-            vec![TokenTree::Token(self.ident.span, token::Lifetime(self.ident))]\n-        }\n-    }\n-\n-    macro_rules! impl_to_tokens_slice {\n-        ($t: ty, $sep: expr) => {\n-            impl ToTokens for [$t] {\n-                fn to_tokens(&self, cx: &ExtCtxt) -> Vec<TokenTree> {\n-                    let mut v = vec![];\n-                    for (i, x) in self.iter().enumerate() {\n-                        if i > 0 {\n-                            v.extend_from_slice(&$sep);\n-                        }\n-                        v.extend(x.to_tokens(cx));\n-                    }\n-                    v\n-                }\n-            }\n-        };\n-    }\n-\n-    impl_to_tokens_slice! { ast::Ty, [TokenTree::Token(DUMMY_SP, token::Comma)] }\n-    impl_to_tokens_slice! { P<ast::Item>, [] }\n-    impl_to_tokens_slice! { ast::Arg, [TokenTree::Token(DUMMY_SP, token::Comma)] }\n-\n-    impl ToTokens for ast::MetaItem {\n-        fn to_tokens(&self, _cx: &ExtCtxt) -> Vec<TokenTree> {\n-            let nt = token::NtMeta(self.clone());\n-            vec![TokenTree::Token(DUMMY_SP, Token::interpolated(nt))]\n-        }\n-    }\n-\n-    impl ToTokens for ast::Attribute {\n-        fn to_tokens(&self, _cx: &ExtCtxt) -> Vec<TokenTree> {\n-            let mut r = vec![];\n-            // FIXME: The spans could be better\n-            r.push(TokenTree::Token(self.span, token::Pound));\n-            if self.style == ast::AttrStyle::Inner {\n-                r.push(TokenTree::Token(self.span, token::Not));\n-            }\n-            let mut inner = Vec::new();\n-            for (i, segment) in self.path.segments.iter().enumerate() {\n-                if i > 0 {\n-                    inner.push(TokenTree::Token(self.span, token::Colon).into());\n-                }\n-                inner.push(TokenTree::Token(\n-                    self.span, token::Token::from_ast_ident(segment.ident)\n-                ).into());\n-            }\n-            self.tokens.clone().append_to_tree_and_joint_vec(&mut inner);\n-\n-            let delim_span = DelimSpan::from_single(self.span);\n-            r.push(TokenTree::Delimited(\n-                delim_span, token::Bracket, TokenStream::new(inner).into()\n-            ));\n-            r\n-        }\n-    }\n-\n-    impl ToTokens for str {\n-        fn to_tokens(&self, cx: &ExtCtxt) -> Vec<TokenTree> {\n-            let lit = ast::LitKind::Str(Symbol::intern(self), ast::StrStyle::Cooked);\n-            dummy_spanned(lit).to_tokens(cx)\n-        }\n-    }\n-\n-    impl ToTokens for () {\n-        fn to_tokens(&self, _cx: &ExtCtxt) -> Vec<TokenTree> {\n-            vec![\n-                TokenTree::Delimited(DelimSpan::dummy(), token::Paren, TokenStream::empty().into())\n-            ]\n-        }\n-    }\n-\n-    impl ToTokens for ast::Lit {\n-        fn to_tokens(&self, cx: &ExtCtxt) -> Vec<TokenTree> {\n-            // FIXME: This is wrong\n-            P(ast::Expr {\n-                id: ast::DUMMY_NODE_ID,\n-                node: ast::ExprKind::Lit(self.clone()),\n-                span: DUMMY_SP,\n-                attrs: ThinVec::new(),\n-            }).to_tokens(cx)\n-        }\n-    }\n-\n-    impl ToTokens for bool {\n-        fn to_tokens(&self, cx: &ExtCtxt) -> Vec<TokenTree> {\n-            dummy_spanned(ast::LitKind::Bool(*self)).to_tokens(cx)\n-        }\n-    }\n-\n-    impl ToTokens for char {\n-        fn to_tokens(&self, cx: &ExtCtxt) -> Vec<TokenTree> {\n-            dummy_spanned(ast::LitKind::Char(*self)).to_tokens(cx)\n-        }\n-    }\n-\n-    macro_rules! impl_to_tokens_int {\n-        (signed, $t:ty, $tag:expr) => (\n-            impl ToTokens for $t {\n-                fn to_tokens(&self, cx: &ExtCtxt) -> Vec<TokenTree> {\n-                    let val = if *self < 0 {\n-                        -self\n-                    } else {\n-                        *self\n-                    };\n-                    let lit = ast::LitKind::Int(val as u128, ast::LitIntType::Signed($tag));\n-                    let lit = P(ast::Expr {\n-                        id: ast::DUMMY_NODE_ID,\n-                        node: ast::ExprKind::Lit(dummy_spanned(lit)),\n-                        span: DUMMY_SP,\n-                        attrs: ThinVec::new(),\n-                    });\n-                    if *self >= 0 {\n-                        return lit.to_tokens(cx);\n-                    }\n-                    P(ast::Expr {\n-                        id: ast::DUMMY_NODE_ID,\n-                        node: ast::ExprKind::Unary(ast::UnOp::Neg, lit),\n-                        span: DUMMY_SP,\n-                        attrs: ThinVec::new(),\n-                    }).to_tokens(cx)\n-                }\n-            }\n-        );\n-        (unsigned, $t:ty, $tag:expr) => (\n-            impl ToTokens for $t {\n-                fn to_tokens(&self, cx: &ExtCtxt) -> Vec<TokenTree> {\n-                    let lit = ast::LitKind::Int(*self as u128, ast::LitIntType::Unsigned($tag));\n-                    dummy_spanned(lit).to_tokens(cx)\n-                }\n-            }\n-        );\n-    }\n-\n-    impl_to_tokens_int! { signed, isize, ast::IntTy::Isize }\n-    impl_to_tokens_int! { signed, i8,  ast::IntTy::I8 }\n-    impl_to_tokens_int! { signed, i16, ast::IntTy::I16 }\n-    impl_to_tokens_int! { signed, i32, ast::IntTy::I32 }\n-    impl_to_tokens_int! { signed, i64, ast::IntTy::I64 }\n-\n-    impl_to_tokens_int! { unsigned, usize, ast::UintTy::Usize }\n-    impl_to_tokens_int! { unsigned, u8,   ast::UintTy::U8 }\n-    impl_to_tokens_int! { unsigned, u16,  ast::UintTy::U16 }\n-    impl_to_tokens_int! { unsigned, u32,  ast::UintTy::U32 }\n-    impl_to_tokens_int! { unsigned, u64,  ast::UintTy::U64 }\n-\n-    pub trait ExtParseUtils {\n-        fn parse_item(&self, s: String) -> P<ast::Item>;\n-        fn parse_expr(&self, s: String) -> P<ast::Expr>;\n-        fn parse_stmt(&self, s: String) -> ast::Stmt;\n-        fn parse_tts(&self, s: String) -> Vec<TokenTree>;\n-    }\n-\n-    impl<'a> ExtParseUtils for ExtCtxt<'a> {\n-        fn parse_item(&self, s: String) -> P<ast::Item> {\n-            panictry!(parse::parse_item_from_source_str(\n-                FileName::quote_expansion_source_code(&s),\n-                s,\n-                self.parse_sess())).expect(\"parse error\")\n-        }\n-\n-        fn parse_stmt(&self, s: String) -> ast::Stmt {\n-            panictry!(parse::parse_stmt_from_source_str(\n-                FileName::quote_expansion_source_code(&s),\n-                s,\n-                self.parse_sess())).expect(\"parse error\")\n-        }\n-\n-        fn parse_expr(&self, s: String) -> P<ast::Expr> {\n-            panictry!(parse::parse_expr_from_source_str(\n-                FileName::quote_expansion_source_code(&s),\n-                s,\n-                self.parse_sess()))\n-        }\n-\n-        fn parse_tts(&self, s: String) -> Vec<TokenTree> {\n-            let source_name = FileName::quote_expansion_source_code(&s);\n-            parse::parse_stream_from_source_str(source_name, s, self.parse_sess(), None)\n-                .into_trees().collect()\n-        }\n-    }\n-}\n-\n-// Replaces `Token::OpenDelim .. Token::CloseDelim` with `TokenTree::Delimited(..)`.\n-pub fn unflatten(tts: Vec<TokenTree>) -> Vec<TokenTree> {\n-    let mut results = Vec::new();\n-    let mut result = Vec::new();\n-    let mut open_span = DUMMY_SP;\n-    for tree in tts {\n-        match tree {\n-            TokenTree::Token(span, token::OpenDelim(..)) => {\n-                open_span = span;\n-                results.push(::std::mem::replace(&mut result, Vec::new()));\n-            }\n-            TokenTree::Token(span, token::CloseDelim(delim)) => {\n-                let delim_span = DelimSpan::from_pair(open_span, span);\n-                let tree = TokenTree::Delimited(\n-                    delim_span,\n-                    delim,\n-                    result.into_iter().map(TokenStream::from).collect::<TokenStream>().into(),\n-                );\n-                result = results.pop().unwrap();\n-                result.push(tree);\n-            }\n-            tree => result.push(tree),\n-        }\n-    }\n-    result\n-}\n-\n-// These panicking parsing functions are used by the quote_*!() syntax extensions,\n-// but shouldn't be used otherwise.\n-pub fn parse_expr_panic(parser: &mut Parser) -> P<Expr> {\n-    panictry!(parser.parse_expr())\n-}\n-\n-pub fn parse_item_panic(parser: &mut Parser) -> Option<P<Item>> {\n-    panictry!(parser.parse_item())\n-}\n-\n-pub fn parse_pat_panic(parser: &mut Parser) -> P<Pat> {\n-    panictry!(parser.parse_pat(None))\n-}\n-\n-pub fn parse_arm_panic(parser: &mut Parser) -> Arm {\n-    panictry!(parser.parse_arm())\n-}\n-\n-pub fn parse_ty_panic(parser: &mut Parser) -> P<Ty> {\n-    panictry!(parser.parse_ty())\n-}\n-\n-pub fn parse_stmt_panic(parser: &mut Parser) -> Option<Stmt> {\n-    panictry!(parser.parse_stmt())\n-}\n-\n-pub fn parse_attribute_panic(parser: &mut Parser, permit_inner: bool) -> ast::Attribute {\n-    panictry!(parser.parse_attribute(permit_inner))\n-}\n-\n-pub fn parse_arg_panic(parser: &mut Parser) -> Arg {\n-    panictry!(parser.parse_arg())\n-}\n-\n-pub fn parse_block_panic(parser: &mut Parser) -> P<Block> {\n-    panictry!(parser.parse_block())\n-}\n-\n-pub fn parse_meta_item_panic(parser: &mut Parser) -> ast::MetaItem {\n-    panictry!(parser.parse_meta_item())\n-}\n-\n-pub fn parse_path_panic(parser: &mut Parser, mode: PathStyle) -> ast::Path {\n-    panictry!(parser.parse_path(mode))\n-}\n-\n-pub fn expand_quote_tokens<'cx>(cx: &'cx mut ExtCtxt,\n-                                sp: Span,\n-                                tts: &[TokenTree])\n-                                -> Box<dyn base::MacResult+'cx> {\n-    let (cx_expr, expr) = expand_tts(cx, sp, tts);\n-    let expanded = expand_wrapper(cx, sp, cx_expr, expr, &[&[\"syntax\", \"ext\", \"quote\", \"rt\"]]);\n-    base::MacEager::expr(expanded)\n-}\n-\n-pub fn expand_quote_expr<'cx>(cx: &'cx mut ExtCtxt,\n-                              sp: Span,\n-                              tts: &[TokenTree])\n-                              -> Box<dyn base::MacResult+'cx> {\n-    let expanded = expand_parse_call(cx, sp, \"parse_expr_panic\", vec![], tts);\n-    base::MacEager::expr(expanded)\n-}\n-\n-pub fn expand_quote_item<'cx>(cx: &'cx mut ExtCtxt,\n-                              sp: Span,\n-                              tts: &[TokenTree])\n-                              -> Box<dyn base::MacResult+'cx> {\n-    let expanded = expand_parse_call(cx, sp, \"parse_item_panic\", vec![], tts);\n-    base::MacEager::expr(expanded)\n-}\n-\n-pub fn expand_quote_pat<'cx>(cx: &'cx mut ExtCtxt,\n-                             sp: Span,\n-                             tts: &[TokenTree])\n-                             -> Box<dyn base::MacResult+'cx> {\n-    let expanded = expand_parse_call(cx, sp, \"parse_pat_panic\", vec![], tts);\n-    base::MacEager::expr(expanded)\n-}\n-\n-pub fn expand_quote_arm(cx: &mut ExtCtxt,\n-                        sp: Span,\n-                        tts: &[TokenTree])\n-                        -> Box<dyn base::MacResult+'static> {\n-    let expanded = expand_parse_call(cx, sp, \"parse_arm_panic\", vec![], tts);\n-    base::MacEager::expr(expanded)\n-}\n-\n-pub fn expand_quote_ty(cx: &mut ExtCtxt,\n-                       sp: Span,\n-                       tts: &[TokenTree])\n-                       -> Box<dyn base::MacResult+'static> {\n-    let expanded = expand_parse_call(cx, sp, \"parse_ty_panic\", vec![], tts);\n-    base::MacEager::expr(expanded)\n-}\n-\n-pub fn expand_quote_stmt(cx: &mut ExtCtxt,\n-                         sp: Span,\n-                         tts: &[TokenTree])\n-                         -> Box<dyn base::MacResult+'static> {\n-    let expanded = expand_parse_call(cx, sp, \"parse_stmt_panic\", vec![], tts);\n-    base::MacEager::expr(expanded)\n-}\n-\n-pub fn expand_quote_attr(cx: &mut ExtCtxt,\n-                         sp: Span,\n-                         tts: &[TokenTree])\n-                         -> Box<dyn base::MacResult+'static> {\n-    let expanded = expand_parse_call(cx, sp, \"parse_attribute_panic\",\n-                                    vec![cx.expr_bool(sp, true)], tts);\n-\n-    base::MacEager::expr(expanded)\n-}\n-\n-pub fn expand_quote_arg(cx: &mut ExtCtxt,\n-                        sp: Span,\n-                        tts: &[TokenTree])\n-                        -> Box<dyn base::MacResult+'static> {\n-    let expanded = expand_parse_call(cx, sp, \"parse_arg_panic\", vec![], tts);\n-    base::MacEager::expr(expanded)\n-}\n-\n-pub fn expand_quote_block(cx: &mut ExtCtxt,\n-                        sp: Span,\n-                        tts: &[TokenTree])\n-                        -> Box<dyn base::MacResult+'static> {\n-    let expanded = expand_parse_call(cx, sp, \"parse_block_panic\", vec![], tts);\n-    base::MacEager::expr(expanded)\n-}\n-\n-pub fn expand_quote_meta_item(cx: &mut ExtCtxt,\n-                        sp: Span,\n-                        tts: &[TokenTree])\n-                        -> Box<dyn base::MacResult+'static> {\n-    let expanded = expand_parse_call(cx, sp, \"parse_meta_item_panic\", vec![], tts);\n-    base::MacEager::expr(expanded)\n-}\n-\n-pub fn expand_quote_path(cx: &mut ExtCtxt,\n-                        sp: Span,\n-                        tts: &[TokenTree])\n-                        -> Box<dyn base::MacResult+'static> {\n-    let mode = mk_parser_path(cx, sp, &[\"PathStyle\", \"Type\"]);\n-    let expanded = expand_parse_call(cx, sp, \"parse_path_panic\", vec![mode], tts);\n-    base::MacEager::expr(expanded)\n-}\n-\n-fn ids_ext(strs: Vec<String>) -> Vec<ast::Ident> {\n-    strs.iter().map(|s| ast::Ident::from_str(s)).collect()\n-}\n-\n-fn id_ext(s: &str) -> ast::Ident {\n-    ast::Ident::from_str(s)\n-}\n-\n-// Lift an ident to the expr that evaluates to that ident.\n-fn mk_ident(cx: &ExtCtxt, sp: Span, ident: ast::Ident) -> P<ast::Expr> {\n-    let e_str = cx.expr_str(sp, ident.name);\n-    cx.expr_method_call(sp,\n-                        cx.expr_ident(sp, id_ext(\"ext_cx\")),\n-                        id_ext(\"ident_of\"),\n-                        vec![e_str])\n-}\n-\n-// Lift a name to the expr that evaluates to that name\n-fn mk_name(cx: &ExtCtxt, sp: Span, ident: ast::Ident) -> P<ast::Expr> {\n-    let e_str = cx.expr_str(sp, ident.name);\n-    cx.expr_method_call(sp,\n-                        cx.expr_ident(sp, id_ext(\"ext_cx\")),\n-                        id_ext(\"name_of\"),\n-                        vec![e_str])\n-}\n-\n-fn mk_tt_path(cx: &ExtCtxt, sp: Span, name: &str) -> P<ast::Expr> {\n-    let idents = vec![id_ext(\"syntax\"), id_ext(\"tokenstream\"), id_ext(\"TokenTree\"), id_ext(name)];\n-    cx.expr_path(cx.path_global(sp, idents))\n-}\n-\n-fn mk_token_path(cx: &ExtCtxt, sp: Span, name: &str) -> P<ast::Expr> {\n-    let idents = vec![id_ext(\"syntax\"), id_ext(\"parse\"), id_ext(\"token\"), id_ext(name)];\n-    cx.expr_path(cx.path_global(sp, idents))\n-}\n-\n-fn mk_parser_path(cx: &ExtCtxt, sp: Span, names: &[&str]) -> P<ast::Expr> {\n-    let mut idents = vec![id_ext(\"syntax\"), id_ext(\"parse\"), id_ext(\"parser\")];\n-    idents.extend(names.iter().cloned().map(id_ext));\n-    cx.expr_path(cx.path_global(sp, idents))\n-}\n-\n-fn mk_binop(cx: &ExtCtxt, sp: Span, bop: token::BinOpToken) -> P<ast::Expr> {\n-    let name = match bop {\n-        token::Plus     => \"Plus\",\n-        token::Minus    => \"Minus\",\n-        token::Star     => \"Star\",\n-        token::Slash    => \"Slash\",\n-        token::Percent  => \"Percent\",\n-        token::Caret    => \"Caret\",\n-        token::And      => \"And\",\n-        token::Or       => \"Or\",\n-        token::Shl      => \"Shl\",\n-        token::Shr      => \"Shr\"\n-    };\n-    mk_token_path(cx, sp, name)\n-}\n-\n-fn mk_delim(cx: &ExtCtxt, sp: Span, delim: token::DelimToken) -> P<ast::Expr> {\n-    let name = match delim {\n-        token::Paren   => \"Paren\",\n-        token::Bracket => \"Bracket\",\n-        token::Brace   => \"Brace\",\n-        token::NoDelim => \"NoDelim\",\n-    };\n-    mk_token_path(cx, sp, name)\n-}\n-\n-#[allow(non_upper_case_globals)]\n-fn expr_mk_token(cx: &ExtCtxt, sp: Span, tok: &token::Token) -> P<ast::Expr> {\n-    macro_rules! mk_lit {\n-        ($name: expr, $suffix: expr, $content: expr $(, $count: expr)*) => {{\n-            let name = mk_name(cx, sp, ast::Ident::with_empty_ctxt($content));\n-            let inner = cx.expr_call(sp, mk_token_path(cx, sp, $name), vec![\n-                name $(, cx.expr_u16(sp, $count))*\n-            ]);\n-            let suffix = match $suffix {\n-                Some(name) => cx.expr_some(sp, mk_name(cx, sp, ast::Ident::with_empty_ctxt(name))),\n-                None => cx.expr_none(sp)\n-            };\n-            cx.expr_call(sp, mk_token_path(cx, sp, \"Literal\"), vec![inner, suffix])\n-        }}\n-    }\n-\n-    let name = match *tok {\n-        token::BinOp(binop) => {\n-            return cx.expr_call(sp, mk_token_path(cx, sp, \"BinOp\"), vec![mk_binop(cx, sp, binop)]);\n-        }\n-        token::BinOpEq(binop) => {\n-            return cx.expr_call(sp, mk_token_path(cx, sp, \"BinOpEq\"),\n-                                vec![mk_binop(cx, sp, binop)]);\n-        }\n-\n-        token::OpenDelim(delim) => {\n-            return cx.expr_call(sp, mk_token_path(cx, sp, \"OpenDelim\"),\n-                                vec![mk_delim(cx, sp, delim)]);\n-        }\n-        token::CloseDelim(delim) => {\n-            return cx.expr_call(sp, mk_token_path(cx, sp, \"CloseDelim\"),\n-                                vec![mk_delim(cx, sp, delim)]);\n-        }\n-\n-        token::Literal(token::Byte(i), suf) => return mk_lit!(\"Byte\", suf, i),\n-        token::Literal(token::Char(i), suf) => return mk_lit!(\"Char\", suf, i),\n-        token::Literal(token::Err(_i), _suf) => return cx.expr(sp, ast::ExprKind::Err),\n-        token::Literal(token::Integer(i), suf) => return mk_lit!(\"Integer\", suf, i),\n-        token::Literal(token::Float(i), suf) => return mk_lit!(\"Float\", suf, i),\n-        token::Literal(token::Str_(i), suf) => return mk_lit!(\"Str_\", suf, i),\n-        token::Literal(token::StrRaw(i, n), suf) => return mk_lit!(\"StrRaw\", suf, i, n),\n-        token::Literal(token::ByteStr(i), suf) => return mk_lit!(\"ByteStr\", suf, i),\n-        token::Literal(token::ByteStrRaw(i, n), suf) => return mk_lit!(\"ByteStrRaw\", suf, i, n),\n-\n-        token::Ident(ident, is_raw) => {\n-            return cx.expr_call(sp,\n-                                mk_token_path(cx, sp, \"Ident\"),\n-                                vec![mk_ident(cx, sp, ident), cx.expr_bool(sp, is_raw)]);\n-        }\n-\n-        token::Lifetime(ident) => {\n-            return cx.expr_call(sp,\n-                                mk_token_path(cx, sp, \"Lifetime\"),\n-                                vec![mk_ident(cx, sp, ident)]);\n-        }\n-\n-        token::DocComment(ident) => {\n-            return cx.expr_call(sp,\n-                                mk_token_path(cx, sp, \"DocComment\"),\n-                                vec![mk_name(cx, sp, ast::Ident::with_empty_ctxt(ident))]);\n-        }\n-\n-        token::Interpolated(_) => {\n-            cx.span_err(sp, \"quote! with interpolated token\");\n-            // Use dummy name.\n-            \"Interpolated\"\n-        }\n-\n-        token::Eq           => \"Eq\",\n-        token::Lt           => \"Lt\",\n-        token::Le           => \"Le\",\n-        token::EqEq         => \"EqEq\",\n-        token::Ne           => \"Ne\",\n-        token::Ge           => \"Ge\",\n-        token::Gt           => \"Gt\",\n-        token::AndAnd       => \"AndAnd\",\n-        token::OrOr         => \"OrOr\",\n-        token::Not          => \"Not\",\n-        token::Tilde        => \"Tilde\",\n-        token::At           => \"At\",\n-        token::Dot          => \"Dot\",\n-        token::DotDot       => \"DotDot\",\n-        token::DotDotDot    => \"DotDotDot\",\n-        token::DotDotEq     => \"DotDotEq\",\n-        token::Comma        => \"Comma\",\n-        token::Semi         => \"Semi\",\n-        token::Colon        => \"Colon\",\n-        token::ModSep       => \"ModSep\",\n-        token::RArrow       => \"RArrow\",\n-        token::LArrow       => \"LArrow\",\n-        token::FatArrow     => \"FatArrow\",\n-        token::Pound        => \"Pound\",\n-        token::Dollar       => \"Dollar\",\n-        token::Question     => \"Question\",\n-        token::SingleQuote  => \"SingleQuote\",\n-        token::Eof          => \"Eof\",\n-\n-        token::Whitespace | token::Comment | token::Shebang(_) => {\n-            panic!(\"unhandled token in quote!\");\n-        }\n-    };\n-    mk_token_path(cx, sp, name)\n-}\n-\n-fn statements_mk_tt(cx: &ExtCtxt, tt: &TokenTree, quoted: bool) -> Vec<ast::Stmt> {\n-    match *tt {\n-        TokenTree::Token(sp, token::Ident(ident, _)) if quoted => {\n-            // tt.extend($ident.to_tokens(ext_cx))\n-\n-            let e_to_toks =\n-                cx.expr_method_call(sp,\n-                                    cx.expr_ident(sp, ident),\n-                                    id_ext(\"to_tokens\"),\n-                                    vec![cx.expr_ident(sp, id_ext(\"ext_cx\"))]);\n-            let e_to_toks =\n-                cx.expr_method_call(sp, e_to_toks, id_ext(\"into_iter\"), vec![]);\n-\n-            let e_push =\n-                cx.expr_method_call(sp,\n-                                    cx.expr_ident(sp, id_ext(\"tt\")),\n-                                    id_ext(\"extend\"),\n-                                    vec![e_to_toks]);\n-\n-            vec![cx.stmt_expr(e_push)]\n-        }\n-        TokenTree::Token(sp, ref tok) => {\n-            let e_sp = cx.expr_ident(sp, id_ext(\"_sp\"));\n-            let e_tok = cx.expr_call(sp,\n-                                     mk_tt_path(cx, sp, \"Token\"),\n-                                     vec![e_sp, expr_mk_token(cx, sp, tok)]);\n-            let e_push =\n-                cx.expr_method_call(sp,\n-                                    cx.expr_ident(sp, id_ext(\"tt\")),\n-                                    id_ext(\"push\"),\n-                                    vec![e_tok]);\n-            vec![cx.stmt_expr(e_push)]\n-        },\n-        TokenTree::Delimited(span, delim, ref tts) => {\n-            let mut stmts = statements_mk_tt(cx, &TokenTree::open_tt(span.open, delim), false);\n-            stmts.extend(statements_mk_tts(cx, tts.clone()));\n-            stmts.extend(statements_mk_tt(cx, &TokenTree::close_tt(span.close, delim), false));\n-            stmts\n-        }\n-    }\n-}\n-\n-fn parse_arguments_to_quote(cx: &ExtCtxt, tts: &[TokenTree])\n-                            -> (P<ast::Expr>, Vec<TokenTree>) {\n-    let mut p = cx.new_parser_from_tts(tts);\n-\n-    let cx_expr = panictry!(p.parse_expr());\n-    if !p.eat(&token::Comma) {\n-        let _ = p.diagnostic().fatal(\"expected token `,`\");\n-    }\n-\n-    let tts = panictry!(p.parse_all_token_trees());\n-    p.abort_if_errors();\n-\n-    (cx_expr, tts)\n-}\n-\n-fn mk_stmts_let(cx: &ExtCtxt, sp: Span) -> Vec<ast::Stmt> {\n-    // We also bind a single value, sp, to ext_cx.call_site()\n-    //\n-    // This causes every span in a token-tree quote to be attributed to the\n-    // call site of the extension using the quote. We can't really do much\n-    // better since the source of the quote may well be in a library that\n-    // was not even parsed by this compilation run, that the user has no\n-    // source code for (eg. in libsyntax, which they're just _using_).\n-    //\n-    // The old quasiquoter had an elaborate mechanism for denoting input\n-    // file locations from which quotes originated; unfortunately this\n-    // relied on feeding the source string of the quote back into the\n-    // compiler (which we don't really want to do) and, in any case, only\n-    // pushed the problem a very small step further back: an error\n-    // resulting from a parse of the resulting quote is still attributed to\n-    // the site the string literal occurred, which was in a source file\n-    // _other_ than the one the user has control over. For example, an\n-    // error in a quote from the protocol compiler, invoked in user code\n-    // using macro_rules! for example, will be attributed to the macro_rules.rs\n-    // file in libsyntax, which the user might not even have source to (unless\n-    // they happen to have a compiler on hand). Over all, the phase distinction\n-    // just makes quotes \"hard to attribute\". Possibly this could be fixed\n-    // by recreating some of the original qq machinery in the tt regime\n-    // (pushing fake SourceFiles onto the parser to account for original sites\n-    // of quotes, for example) but at this point it seems not likely to be\n-    // worth the hassle.\n-\n-    let e_sp = cx.expr_method_call(sp,\n-                                   cx.expr_ident(sp, id_ext(\"ext_cx\")),\n-                                   id_ext(\"call_site\"),\n-                                   Vec::new());\n-\n-    let stmt_let_sp = cx.stmt_let(sp, false,\n-                                  id_ext(\"_sp\"),\n-                                  e_sp);\n-\n-    let stmt_let_tt = cx.stmt_let(sp, true, id_ext(\"tt\"), cx.expr_vec_ng(sp));\n-\n-    vec![stmt_let_sp, stmt_let_tt]\n-}\n-\n-fn statements_mk_tts(cx: &ExtCtxt, tts: TokenStream) -> Vec<ast::Stmt> {\n-    let mut ss = Vec::new();\n-    let mut quoted = false;\n-    for tt in tts.into_trees() {\n-        quoted = match tt {\n-            TokenTree::Token(_, token::Dollar) if !quoted => true,\n-            _ => {\n-                ss.extend(statements_mk_tt(cx, &tt, quoted));\n-                false\n-            }\n-        }\n-    }\n-    ss\n-}\n-\n-fn expand_tts(cx: &ExtCtxt, sp: Span, tts: &[TokenTree]) -> (P<ast::Expr>, P<ast::Expr>) {\n-    let (cx_expr, tts) = parse_arguments_to_quote(cx, tts);\n-\n-    let mut vector = mk_stmts_let(cx, sp);\n-    vector.extend(statements_mk_tts(cx, tts.iter().cloned().collect()));\n-    vector.push(cx.stmt_expr(cx.expr_ident(sp, id_ext(\"tt\"))));\n-    let block = cx.expr_block(cx.block(sp, vector));\n-    let unflatten = vec![id_ext(\"syntax\"), id_ext(\"ext\"), id_ext(\"quote\"), id_ext(\"unflatten\")];\n-\n-    (cx_expr, cx.expr_call_global(sp, unflatten, vec![block]))\n-}\n-\n-fn expand_wrapper(cx: &ExtCtxt,\n-                  sp: Span,\n-                  cx_expr: P<ast::Expr>,\n-                  expr: P<ast::Expr>,\n-                  imports: &[&[&str]]) -> P<ast::Expr> {\n-    // Explicitly borrow to avoid moving from the invoker (#16992)\n-    let cx_expr_borrow = cx.expr_addr_of(sp, cx.expr_deref(sp, cx_expr));\n-    let stmt_let_ext_cx = cx.stmt_let(sp, false, id_ext(\"ext_cx\"), cx_expr_borrow);\n-\n-    let mut stmts = imports.iter().map(|path| {\n-        // make item: `use ...;`\n-        let path = path.iter().map(|s| s.to_string()).collect();\n-        let use_item = cx.item_use_glob(\n-            sp,\n-            respan(sp.shrink_to_lo(), ast::VisibilityKind::Inherited),\n-            ids_ext(path),\n-        );\n-        cx.stmt_item(sp, use_item)\n-    }).chain(Some(stmt_let_ext_cx)).collect::<Vec<_>>();\n-    stmts.push(cx.stmt_expr(expr));\n-\n-    cx.expr_block(cx.block(sp, stmts))\n-}\n-\n-fn expand_parse_call(cx: &ExtCtxt,\n-                     sp: Span,\n-                     parse_method: &str,\n-                     arg_exprs: Vec<P<ast::Expr>> ,\n-                     tts: &[TokenTree]) -> P<ast::Expr> {\n-    let (cx_expr, tts_expr) = expand_tts(cx, sp, tts);\n-\n-    let parse_sess_call = || cx.expr_method_call(\n-        sp, cx.expr_ident(sp, id_ext(\"ext_cx\")),\n-        id_ext(\"parse_sess\"), Vec::new());\n-\n-    let new_parser_call =\n-        cx.expr_call(sp,\n-                     cx.expr_ident(sp, id_ext(\"new_parser_from_tts\")),\n-                     vec![parse_sess_call(), tts_expr]);\n-\n-    let path = vec![id_ext(\"syntax\"), id_ext(\"ext\"), id_ext(\"quote\"), id_ext(parse_method)];\n-    let mut args = vec![cx.expr_mut_addr_of(sp, new_parser_call)];\n-    args.extend(arg_exprs);\n-    let expr = cx.expr_call_global(sp, path, args);\n-\n-    if parse_method == \"parse_attribute\" {\n-        expand_wrapper(cx, sp, cx_expr, expr, &[&[\"syntax\", \"ext\", \"quote\", \"rt\"],\n-                                                &[\"syntax\", \"parse\", \"attr\"]])\n-    } else {\n-        expand_wrapper(cx, sp, cx_expr, expr, &[&[\"syntax\", \"ext\", \"quote\", \"rt\"]])\n-    }\n-}"}, {"sha": "9e107fee5bad31549859cfed97b75fe1cec5665d", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/01f8e25b15f4ab157c8e7c9c56054df7595ec0e1/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01f8e25b15f4ab157c8e7c9c56054df7595ec0e1/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=01f8e25b15f4ab157c8e7c9c56054df7595ec0e1", "patch": "@@ -124,7 +124,6 @@ declare_features! (\n \n     (active, link_llvm_intrinsics, \"1.0.0\", Some(29602), None),\n     (active, linkage, \"1.0.0\", Some(29603), None),\n-    (active, quote, \"1.0.0\", Some(29601), None),\n \n     // rustc internal\n     (active, rustc_diagnostic_macros, \"1.0.0\", None, None),\n@@ -504,6 +503,7 @@ declare_features! (\n     // Paths of the form: `extern::foo::bar`\n     (removed, extern_in_paths, \"1.33.0\", Some(55600), None,\n      Some(\"subsumed by `::foo::bar` paths\")),\n+    (removed, quote, \"1.0.0\", Some(29601), None, None),\n );\n \n declare_features! ("}, {"sha": "b2a3ae7f9d9755bfe0115e76cd40695ca53a9378", "filename": "src/libsyntax/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/01f8e25b15f4ab157c8e7c9c56054df7595ec0e1/src%2Flibsyntax%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01f8e25b15f4ab157c8e7c9c56054df7595ec0e1/src%2Flibsyntax%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Flib.rs?ref=01f8e25b15f4ab157c8e7c9c56054df7595ec0e1", "patch": "@@ -174,7 +174,6 @@ pub mod ext {\n     pub mod derive;\n     pub mod expand;\n     pub mod placeholders;\n-    pub mod quote;\n     pub mod source_util;\n \n     pub mod tt {"}, {"sha": "c7330004d6ded280a1c443ffbd678873efae68b0", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 17, "deletions": 22, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/01f8e25b15f4ab157c8e7c9c56054df7595ec0e1/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01f8e25b15f4ab157c8e7c9c56054df7595ec0e1/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=01f8e25b15f4ab157c8e7c9c56054df7595ec0e1", "patch": "@@ -8,7 +8,6 @@ use syntax_pos::{Span, SourceFile, FileName, MultiSpan};\n use errors::{FatalError, Level, Handler, ColorConfig, Diagnostic, DiagnosticBuilder};\n use feature_gate::UnstableFeatures;\n use parse::parser::Parser;\n-use ptr::P;\n use symbol::Symbol;\n use tokenstream::{TokenStream, TokenTree};\n use diagnostics::plugin::ErrorMap;\n@@ -135,25 +134,6 @@ pub fn parse_crate_attrs_from_source_str(name: FileName, source: String, sess: &\n     new_parser_from_source_str(sess, name, source).parse_inner_attributes()\n }\n \n-crate fn parse_expr_from_source_str(name: FileName, source: String, sess: &ParseSess)\n-                                      -> PResult<P<ast::Expr>> {\n-    new_parser_from_source_str(sess, name, source).parse_expr()\n-}\n-\n-/// Parses an item.\n-///\n-/// Returns `Ok(Some(item))` when successful, `Ok(None)` when no item was found, and `Err`\n-/// when a syntax error occurred.\n-crate fn parse_item_from_source_str(name: FileName, source: String, sess: &ParseSess)\n-                                      -> PResult<Option<P<ast::Item>>> {\n-    new_parser_from_source_str(sess, name, source).parse_item()\n-}\n-\n-crate fn parse_stmt_from_source_str(name: FileName, source: String, sess: &ParseSess)\n-                                      -> PResult<Option<ast::Stmt>> {\n-    new_parser_from_source_str(sess, name, source).parse_stmt()\n-}\n-\n pub fn parse_stream_from_source_str(name: FileName, source: String, sess: &ParseSess,\n                                     override_span: Option<Span>)\n                                     -> TokenStream {\n@@ -781,13 +761,22 @@ mod tests {\n     use syntax_pos::{Span, BytePos, Pos, NO_EXPANSION};\n     use ast::{self, Ident, PatKind};\n     use attr::first_attr_value_str_by_name;\n-    use parse;\n+    use ptr::P;\n     use print::pprust::item_to_string;\n     use tokenstream::{DelimSpan, TokenTree};\n     use util::parser_testing::string_to_stream;\n     use util::parser_testing::{string_to_expr, string_to_item};\n     use with_globals;\n \n+    /// Parses an item.\n+    ///\n+    /// Returns `Ok(Some(item))` when successful, `Ok(None)` when no item was found, and `Err`\n+    /// when a syntax error occurred.\n+    fn parse_item_from_source_str(name: FileName, source: String, sess: &ParseSess)\n+                                        -> PResult<Option<P<ast::Item>>> {\n+        new_parser_from_source_str(sess, name, source).parse_item()\n+    }\n+\n     // produce a syntax_pos::span\n     fn sp(a: u32, b: u32) -> Span {\n         Span::new(BytePos(a), BytePos(b), NO_EXPANSION)\n@@ -1016,9 +1005,15 @@ mod tests {\n \n     #[test]\n     fn ttdelim_span() {\n+        fn parse_expr_from_source_str(\n+            name: FileName, source: String, sess: &ParseSess\n+        ) -> PResult<P<ast::Expr>> {\n+            new_parser_from_source_str(sess, name, source).parse_expr()\n+        }\n+\n         with_globals(|| {\n             let sess = ParseSess::new(FilePathMapping::empty());\n-            let expr = parse::parse_expr_from_source_str(PathBuf::from(\"foo\").into(),\n+            let expr = parse_expr_from_source_str(PathBuf::from(\"foo\").into(),\n                 \"foo!( fn main() { body } )\".to_string(), &sess).unwrap();\n \n             let tts: Vec<_> = match expr.node {"}, {"sha": "e4950d1b5a1b41f2f99c849745d248a79099feb7", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/01f8e25b15f4ab157c8e7c9c56054df7595ec0e1/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01f8e25b15f4ab157c8e7c9c56054df7595ec0e1/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=01f8e25b15f4ab157c8e7c9c56054df7595ec0e1", "patch": "@@ -1286,9 +1286,6 @@ impl<'a> Parser<'a> {\n     crate fn span_bug<S: Into<MultiSpan>>(&self, sp: S, m: &str) -> ! {\n         self.sess.span_diagnostic.span_bug(sp, m)\n     }\n-    crate fn abort_if_errors(&self) {\n-        self.sess.span_diagnostic.abort_if_errors();\n-    }\n \n     fn cancel(&self, err: &mut DiagnosticBuilder) {\n         self.sess.span_diagnostic.cancel(err)"}, {"sha": "d0b3cd865ce6e211fb682c2f2f58ca549bdf258d", "filename": "src/libsyntax/util/parser_testing.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/01f8e25b15f4ab157c8e7c9c56054df7595ec0e1/src%2Flibsyntax%2Futil%2Fparser_testing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01f8e25b15f4ab157c8e7c9c56054df7595ec0e1/src%2Flibsyntax%2Futil%2Fparser_testing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Fparser_testing.rs?ref=01f8e25b15f4ab157c8e7c9c56054df7595ec0e1", "patch": "@@ -25,7 +25,7 @@ fn with_error_checking_parse<'a, T, F>(s: String, ps: &'a ParseSess, f: F) -> T\n {\n     let mut p = string_to_parser(&ps, s);\n     let x = panictry!(f(&mut p));\n-    p.abort_if_errors();\n+    p.sess.span_diagnostic.abort_if_errors();\n     x\n }\n "}, {"sha": "5e767d237cc0ea7562e8c5479b66c1385cf090c8", "filename": "src/libsyntax_ext/lib.rs", "status": "modified", "additions": 1, "deletions": 21, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/01f8e25b15f4ab157c8e7c9c56054df7595ec0e1/src%2Flibsyntax_ext%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01f8e25b15f4ab157c8e7c9c56054df7595ec0e1/src%2Flibsyntax_ext%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Flib.rs?ref=01f8e25b15f4ab157c8e7c9c56054df7595ec0e1", "patch": "@@ -11,7 +11,6 @@\n #![feature(decl_macro)]\n #![feature(nll)]\n #![feature(str_escape)]\n-#![feature(quote)]\n #![feature(rustc_diagnostic_macros)]\n \n #![recursion_limit=\"256\"]\n@@ -58,8 +57,7 @@ use syntax::ext::hygiene;\n use syntax::symbol::Symbol;\n \n pub fn register_builtins(resolver: &mut dyn syntax::ext::base::Resolver,\n-                         user_exts: Vec<NamedSyntaxExtension>,\n-                         enable_quotes: bool) {\n+                         user_exts: Vec<NamedSyntaxExtension>) {\n     deriving::register_builtin_derives(resolver);\n \n     let mut register = |name, ext| {\n@@ -81,24 +79,6 @@ pub fn register_builtins(resolver: &mut dyn syntax::ext::base::Resolver,\n         )* }\n     }\n \n-    if enable_quotes {\n-        use syntax::ext::quote::*;\n-        register! {\n-            quote_tokens: expand_quote_tokens,\n-            quote_expr: expand_quote_expr,\n-            quote_ty: expand_quote_ty,\n-            quote_item: expand_quote_item,\n-            quote_pat: expand_quote_pat,\n-            quote_arm: expand_quote_arm,\n-            quote_stmt: expand_quote_stmt,\n-            quote_attr: expand_quote_attr,\n-            quote_arg: expand_quote_arg,\n-            quote_block: expand_quote_block,\n-            quote_meta_item: expand_quote_meta_item,\n-            quote_path: expand_quote_path,\n-        }\n-    }\n-\n     use syntax::ext::source_util::*;\n     register! {\n         line: expand_line,"}, {"sha": "d0e052167287898af0d56a9a89846d7bbc955903", "filename": "src/test/run-fail-fulldeps/qquote.rs", "status": "removed", "additions": 0, "deletions": 35, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/095b44c83b540bb4dbf74be1cae604f4bae87989/src%2Ftest%2Frun-fail-fulldeps%2Fqquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/095b44c83b540bb4dbf74be1cae604f4bae87989/src%2Ftest%2Frun-fail-fulldeps%2Fqquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail-fulldeps%2Fqquote.rs?ref=095b44c83b540bb4dbf74be1cae604f4bae87989", "patch": "@@ -1,35 +0,0 @@\n-// ignore-cross-compile\n-\n-// error-pattern:expected expression, found statement (`let`)\n-\n-#![feature(quote, rustc_private)]\n-\n-extern crate syntax;\n-extern crate syntax_pos;\n-\n-use syntax::ast;\n-use syntax::source_map;\n-use syntax::print::pprust;\n-use syntax::symbol::Symbol;\n-use syntax_pos::DUMMY_SP;\n-\n-fn main() {\n-    syntax::with_globals(|| run());\n-}\n-\n-fn run() {\n-    let ps = syntax::parse::ParseSess::new(source_map::FilePathMapping::empty());\n-    let mut resolver = syntax::ext::base::DummyResolver;\n-    let mut cx = syntax::ext::base::ExtCtxt::new(\n-        &ps,\n-        syntax::ext::expand::ExpansionConfig::default(\"qquote\".to_string()),\n-        &mut resolver);\n-    let cx = &mut cx;\n-\n-    println!(\"{}\", pprust::expr_to_string(&*quote_expr!(&cx, 23)));\n-    assert_eq!(pprust::expr_to_string(&*quote_expr!(&cx, 23)), \"23\");\n-\n-    let expr = quote_expr!(&cx, let x isize = 20;);\n-    println!(\"{}\", pprust::expr_to_string(&*expr));\n-    assert_eq!(pprust::expr_to_string(&*expr), \"let x isize = 20;\");\n-}"}, {"sha": "76680f5dda2405c4026d4dcd6ac5c60243975f0f", "filename": "src/test/run-pass-fulldeps/auxiliary/issue-16723.rs", "status": "removed", "additions": 0, "deletions": 29, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/095b44c83b540bb4dbf74be1cae604f4bae87989/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fissue-16723.rs", "raw_url": "https://github.com/rust-lang/rust/raw/095b44c83b540bb4dbf74be1cae604f4bae87989/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fissue-16723.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fissue-16723.rs?ref=095b44c83b540bb4dbf74be1cae604f4bae87989", "patch": "@@ -1,29 +0,0 @@\n-// force-host\n-\n-#![feature(plugin_registrar, quote, rustc_private)]\n-#![crate_type = \"dylib\"]\n-\n-extern crate syntax;\n-extern crate rustc;\n-extern crate rustc_data_structures;\n-extern crate rustc_plugin;\n-#[macro_use] extern crate smallvec;\n-extern crate syntax_pos;\n-\n-use smallvec::SmallVec;\n-use syntax::ext::base::{ExtCtxt, MacResult, MacEager};\n-use syntax::tokenstream;\n-use rustc_plugin::Registry;\n-\n-#[plugin_registrar]\n-pub fn plugin_registrar(reg: &mut Registry) {\n-    reg.register_macro(\"multiple_items\", expand)\n-}\n-\n-fn expand(cx: &mut ExtCtxt, _: syntax_pos::Span, _: &[tokenstream::TokenTree])\n-          -> Box<MacResult+'static> {\n-    MacEager::items(smallvec![\n-        quote_item!(cx, struct Struct1;).unwrap(),\n-        quote_item!(cx, struct Struct2;).unwrap()\n-    ])\n-}"}, {"sha": "a2b1d6976d0eb7e0db2c0ca96712b6fff5c4cfea", "filename": "src/test/run-pass-fulldeps/auxiliary/macro_crate_test.rs", "status": "modified", "additions": 26, "deletions": 201, "changes": 227, "blob_url": "https://github.com/rust-lang/rust/blob/01f8e25b15f4ab157c8e7c9c56054df7595ec0e1/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fmacro_crate_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01f8e25b15f4ab157c8e7c9c56054df7595ec0e1/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fmacro_crate_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fmacro_crate_test.rs?ref=01f8e25b15f4ab157c8e7c9c56054df7595ec0e1", "patch": "@@ -1,209 +1,34 @@\n // force-host\n+// no-prefer-dynamic\n \n-#![feature(plugin_registrar, quote, rustc_private)]\n+#![crate_type = \"proc-macro\"]\n+#![feature(rustc_private)]\n \n extern crate syntax;\n extern crate rustc;\n extern crate rustc_plugin;\n extern crate syntax_pos;\n-\n-use syntax::ast::{self, Item, MetaItem, ItemKind};\n-use syntax::source_map::DUMMY_SP;\n-use syntax::ext::base::*;\n-use syntax::ext::quote::rt::ToTokens;\n-use syntax::parse::{self, token};\n-use syntax::ptr::P;\n-use syntax::symbol::Symbol;\n-use syntax::tokenstream::TokenTree;\n-use syntax_pos::Span;\n-use rustc_plugin::Registry;\n-\n-#[macro_export]\n-macro_rules! exported_macro { () => (2) }\n-macro_rules! unexported_macro { () => (3) }\n-\n-#[plugin_registrar]\n-pub fn plugin_registrar(reg: &mut Registry) {\n-    reg.register_macro(\"make_a_1\", expand_make_a_1);\n-    reg.register_macro(\"identity\", expand_identity);\n-    reg.register_syntax_extension(\n-        Symbol::intern(\"rustc_into_multi_foo\"),\n-        MultiModifier(Box::new(expand_into_foo_multi)));\n-    reg.register_syntax_extension(\n-        Symbol::intern(\"rustc_duplicate\"),\n-        MultiDecorator(Box::new(expand_duplicate)));\n-    reg.register_syntax_extension(\n-        Symbol::intern(\"rustc_caller\"),\n-        MultiDecorator(Box::new(expand_caller)));\n-}\n-\n-fn expand_make_a_1(cx: &mut ExtCtxt, sp: Span, tts: &[TokenTree]) -> Box<MacResult + 'static> {\n-    if !tts.is_empty() {\n-        cx.span_fatal(sp, \"make_a_1 takes no arguments\");\n-    }\n-    MacEager::expr(quote_expr!(cx, 1))\n-}\n-\n-// See Issue #15750\n-fn expand_identity(cx: &mut ExtCtxt, _span: Span, tts: &[TokenTree]) -> Box<MacResult + 'static> {\n-    // Parse an expression and emit it unchanged.\n-    let mut parser = parse::new_parser_from_tts(cx.parse_sess(), tts.to_vec());\n-    let expr = parser.parse_expr().unwrap();\n-    MacEager::expr(quote_expr!(&mut *cx, $expr))\n-}\n-\n-fn expand_into_foo_multi(cx: &mut ExtCtxt,\n-                         _sp: Span,\n-                         _attr: &MetaItem,\n-                         it: Annotatable)\n-                         -> Vec<Annotatable> {\n-    match it {\n-        Annotatable::Item(it) => vec![\n-            Annotatable::Item(P(Item {\n-                attrs: it.attrs.clone(),\n-                ..(*quote_item!(cx, enum Foo2 { Bar2, Baz2 }).unwrap()).clone()\n-            })),\n-            Annotatable::Item(quote_item!(cx, enum Foo3 { Bar }).unwrap()),\n-            Annotatable::Item(quote_item!(cx, #[cfg(any())] fn foo2() {}).unwrap()),\n-        ],\n-        Annotatable::ImplItem(_it) => vec![\n-            quote_item!(cx, impl X { fn foo(&self) -> i32 { 42 } }).unwrap().and_then(|i| {\n-                match i.node {\n-                    ItemKind::Impl(.., mut items) => {\n-                        Annotatable::ImplItem(P(items.pop().expect(\"impl method not found\")))\n-                    }\n-                    _ => unreachable!(\"impl parsed to something other than impl\")\n-                }\n-            })\n-        ],\n-        Annotatable::TraitItem(_it) => vec![\n-            quote_item!(cx, trait X { fn foo(&self) -> i32 { 0 } }).unwrap().and_then(|i| {\n-                match i.node {\n-                    ItemKind::Trait(.., mut items) => {\n-                        Annotatable::TraitItem(P(items.pop().expect(\"trait method not found\")))\n-                    }\n-                    _ => unreachable!(\"trait parsed to something other than trait\")\n-                }\n-            })\n-        ],\n-        // covered in proc_macro/macros-in-extern.rs\n-        Annotatable::ForeignItem(..) => unimplemented!(),\n-        // covered in proc_macro/attr-stmt-expr.rs\n-        Annotatable::Stmt(_) | Annotatable::Expr(_) => panic!(\"expected item\"),\n-    }\n+extern crate proc_macro;\n+\n+use proc_macro::{TokenTree, TokenStream};\n+\n+#[proc_macro_attribute]\n+pub fn rustc_duplicate(attr: TokenStream, item: TokenStream) -> TokenStream {\n+    let mut new_name = Some(attr.into_iter().nth(0).unwrap());\n+    let mut encountered_idents = 0;\n+    let input = item.to_string();\n+    let ret = item.into_iter().map(move |token| match token {\n+        TokenTree::Ident(_) if encountered_idents == 1 => {\n+            encountered_idents += 1;\n+            new_name.take().unwrap()\n+        }\n+        TokenTree::Ident(_) => {\n+            encountered_idents += 1;\n+            token\n+        }\n+        _ => token\n+    }).collect::<TokenStream>();\n+    let mut input_again = input.parse::<TokenStream>().unwrap();\n+    input_again.extend(ret);\n+    input_again\n }\n-\n-// Create a duplicate of the annotatable, based on the MetaItem\n-fn expand_duplicate(cx: &mut ExtCtxt,\n-                    _sp: Span,\n-                    mi: &MetaItem,\n-                    it: &Annotatable,\n-                    push: &mut FnMut(Annotatable)) {\n-    let copy_name = match mi.node {\n-        ast::MetaItemKind::List(ref xs) => {\n-            if let Some(word) = xs[0].word() {\n-                word.ident.segments.last().unwrap().ident\n-            } else {\n-                cx.span_err(mi.span, \"Expected word\");\n-                return;\n-            }\n-        }\n-        _ => {\n-            cx.span_err(mi.span, \"Expected list\");\n-            return;\n-        }\n-    };\n-\n-    // Duplicate the item but replace its ident by the MetaItem\n-    match it.clone() {\n-        Annotatable::Item(it) => {\n-            let mut new_it = (*it).clone();\n-            new_it.attrs.clear();\n-            new_it.ident = copy_name;\n-            push(Annotatable::Item(P(new_it)));\n-        }\n-        Annotatable::ImplItem(it) => {\n-            let mut new_it = (*it).clone();\n-            new_it.attrs.clear();\n-            new_it.ident = copy_name;\n-            push(Annotatable::ImplItem(P(new_it)));\n-        }\n-        Annotatable::TraitItem(tt) => {\n-            let mut new_it = (*tt).clone();\n-            new_it.attrs.clear();\n-            new_it.ident = copy_name;\n-            push(Annotatable::TraitItem(P(new_it)));\n-        }\n-        // covered in proc_macro/macros-in-extern.rs\n-        Annotatable::ForeignItem(..) => unimplemented!(),\n-        // covered in proc_macro/attr-stmt-expr.rs\n-        Annotatable::Stmt(_) | Annotatable::Expr(_) => panic!(\"expected item\")\n-    }\n-}\n-\n-pub fn token_separate<T: ToTokens>(ecx: &ExtCtxt, things: &[T],\n-                                   token: token::Token) -> Vec<TokenTree> {\n-    let mut output: Vec<TokenTree> = vec![];\n-    for (i, thing) in things.iter().enumerate() {\n-        output.extend(thing.to_tokens(ecx));\n-        if i < things.len() - 1 {\n-            output.push(TokenTree::Token(DUMMY_SP, token.clone()));\n-        }\n-    }\n-\n-    output\n-}\n-\n-fn expand_caller(cx: &mut ExtCtxt,\n-                 sp: Span,\n-                 mi: &MetaItem,\n-                 it: &Annotatable,\n-                 push: &mut FnMut(Annotatable)) {\n-    let (orig_fn_name, ret_type) = match *it {\n-        Annotatable::Item(ref item) => match item.node {\n-            ItemKind::Fn(ref decl, ..) => {\n-                (item.ident, &decl.output)\n-            }\n-            _ => cx.span_fatal(item.span, \"Only functions with return types can be annotated.\")\n-        },\n-        _ => cx.span_fatal(sp, \"Only functions can be annotated.\")\n-    };\n-\n-    let (caller_name, arguments) = if let Some(list) = mi.meta_item_list() {\n-        if list.len() < 2 {\n-            cx.span_fatal(mi.span(), \"Need a function name and at least one parameter.\");\n-        }\n-\n-        let fn_name = match list[0].name() {\n-            Some(name) => ast::Ident::with_empty_ctxt(name),\n-            None => cx.span_fatal(list[0].span(), \"First parameter must be an ident.\")\n-        };\n-\n-        (fn_name, &list[1..])\n-    } else {\n-        cx.span_fatal(mi.span, \"Expected list.\");\n-    };\n-\n-    let literals: Vec<ast::Lit> = arguments.iter().map(|arg| {\n-        if let Some(lit) = arg.literal() {\n-            lit.clone()\n-        } else {\n-            cx.span_fatal(arg.span(), \"Expected literal.\");\n-        }\n-    }).collect();\n-\n-    let arguments = token_separate(cx, literals.as_slice(), token::Comma);\n-    if let ast::FunctionRetTy::Ty(ref rt) = *ret_type {\n-        push(Annotatable::Item(quote_item!(cx,\n-                                           fn $caller_name() -> $rt {\n-                                               $orig_fn_name($arguments)\n-                                           }).unwrap()))\n-    } else {\n-        push(Annotatable::Item(quote_item!(cx,\n-                                           fn $caller_name() {\n-                                               $orig_fn_name($arguments)\n-                                           }).unwrap()))\n-    }\n-}\n-\n-pub fn foo() {}"}, {"sha": "320b77e8ea8e1d0b37735689f4df79f84eca6a03", "filename": "src/test/run-pass-fulldeps/auxiliary/plugin_with_plugin_lib.rs", "status": "removed", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/095b44c83b540bb4dbf74be1cae604f4bae87989/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fplugin_with_plugin_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/095b44c83b540bb4dbf74be1cae604f4bae87989/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fplugin_with_plugin_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fplugin_with_plugin_lib.rs?ref=095b44c83b540bb4dbf74be1cae604f4bae87989", "patch": "@@ -1,13 +0,0 @@\n-// force-host\n-\n-#![feature(plugin_registrar, rustc_private)]\n-#![deny(plugin_as_library)] // should have no effect in a plugin crate\n-\n-extern crate macro_crate_test;\n-extern crate rustc;\n-extern crate rustc_plugin;\n-\n-use rustc_plugin::Registry;\n-\n-#[plugin_registrar]\n-pub fn plugin_registrar(_: &mut Registry) { }"}, {"sha": "e2fa3744ad8febc3ec5d65490a0de945034330c4", "filename": "src/test/run-pass-fulldeps/auxiliary/procedural_mbe_matching.rs", "status": "removed", "additions": 0, "deletions": 82, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/095b44c83b540bb4dbf74be1cae604f4bae87989/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fprocedural_mbe_matching.rs", "raw_url": "https://github.com/rust-lang/rust/raw/095b44c83b540bb4dbf74be1cae604f4bae87989/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fprocedural_mbe_matching.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fprocedural_mbe_matching.rs?ref=095b44c83b540bb4dbf74be1cae604f4bae87989", "patch": "@@ -1,82 +0,0 @@\n-// force-host\n-\n-#![crate_type=\"dylib\"]\n-#![feature(plugin_registrar, quote, rustc_private)]\n-\n-extern crate syntax;\n-extern crate syntax_pos;\n-extern crate rustc;\n-extern crate rustc_plugin;\n-\n-use syntax::feature_gate::Features;\n-use syntax::parse::token::{NtExpr, NtPat};\n-use syntax::ast::{Ident, Pat, NodeId};\n-use syntax::tokenstream::{TokenTree};\n-use syntax::ext::base::{ExtCtxt, MacResult, MacEager};\n-use syntax::ext::build::AstBuilder;\n-use syntax::ext::tt::quoted;\n-use syntax::ext::tt::macro_parser::{MatchedSeq, MatchedNonterminal};\n-use syntax::ext::tt::macro_parser::{Success, Failure, Error};\n-use syntax::ext::tt::macro_parser::parse_failure_msg;\n-use syntax::ptr::P;\n-use syntax_pos::{Span, edition::Edition};\n-use rustc_plugin::Registry;\n-\n-fn expand_mbe_matches(cx: &mut ExtCtxt, _: Span, args: &[TokenTree])\n-        -> Box<MacResult + 'static> {\n-\n-    let mbe_matcher = quote_tokens!(cx, $$matched:expr, $$($$pat:pat)|+);\n-    let mbe_matcher = quoted::parse(mbe_matcher.into_iter().collect(),\n-                                    true,\n-                                    cx.parse_sess,\n-                                    &Features::new(),\n-                                    &[],\n-                                    Edition::Edition2015,\n-                                    // not used...\n-                                    NodeId::from_u32(0));\n-    let map = match TokenTree::parse(cx, &mbe_matcher, args.iter().cloned().collect()) {\n-        Success(map) => map,\n-        Failure(_, tok, msg) => {\n-            panic!(\"expected Success, but got Failure: {} - {}\", parse_failure_msg(tok), msg);\n-        }\n-        Error(_, s) => {\n-            panic!(\"expected Success, but got Error: {}\", s);\n-        }\n-    };\n-\n-    let matched_nt = match *map[&Ident::from_str(\"matched\")] {\n-        MatchedNonterminal(ref nt) => nt.clone(),\n-        _ => unreachable!(),\n-    };\n-\n-    let mac_expr = match (&*matched_nt, &*map[&Ident::from_str(\"pat\")]) {\n-        (&NtExpr(ref matched_expr), &MatchedSeq(ref pats, seq_sp)) => {\n-            let pats: Vec<P<Pat>> = pats.iter().map(|pat_nt| {\n-                match *pat_nt {\n-                    MatchedNonterminal(ref nt) => match **nt {\n-                        NtPat(ref pat) => pat.clone(),\n-                        _ => unreachable!(),\n-                    },\n-                    _ => unreachable!(),\n-                }\n-            }).collect();\n-            let span = seq_sp.entire();\n-            let arm = cx.arm(span, pats, cx.expr_bool(span, true));\n-\n-            quote_expr!(cx,\n-                match $matched_expr {\n-                    $arm\n-                    _ => false\n-                }\n-            )\n-        }\n-        _ => unreachable!()\n-    };\n-\n-    MacEager::expr(mac_expr)\n-}\n-\n-#[plugin_registrar]\n-pub fn plugin_registrar(reg: &mut Registry) {\n-    reg.register_macro(\"matches\", expand_mbe_matches);\n-}"}, {"sha": "a356df55b3562baa7e7e0944c9df6ae354dd363a", "filename": "src/test/run-pass-fulldeps/auxiliary/syntax_extension_with_dll_deps_2.rs", "status": "removed", "additions": 0, "deletions": 27, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/095b44c83b540bb4dbf74be1cae604f4bae87989/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fsyntax_extension_with_dll_deps_2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/095b44c83b540bb4dbf74be1cae604f4bae87989/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fsyntax_extension_with_dll_deps_2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fsyntax_extension_with_dll_deps_2.rs?ref=095b44c83b540bb4dbf74be1cae604f4bae87989", "patch": "@@ -1,27 +0,0 @@\n-// force-host\n-\n-#![crate_type = \"dylib\"]\n-#![feature(plugin_registrar, quote, rustc_private)]\n-\n-extern crate syntax_extension_with_dll_deps_1 as other;\n-extern crate syntax;\n-extern crate syntax_pos;\n-extern crate rustc;\n-extern crate rustc_plugin;\n-\n-use syntax::ast::{Item, MetaItem};\n-use syntax::ext::base::*;\n-use syntax::tokenstream::TokenTree;\n-use syntax_pos::Span;\n-use rustc_plugin::Registry;\n-\n-#[plugin_registrar]\n-pub fn plugin_registrar(reg: &mut Registry) {\n-    reg.register_macro(\"foo\", expand_foo);\n-}\n-\n-fn expand_foo(cx: &mut ExtCtxt, sp: Span, tts: &[TokenTree])\n-              -> Box<MacResult+'static> {\n-    let answer = other::the_answer();\n-    MacEager::expr(quote_expr!(cx, $answer))\n-}"}, {"sha": "a3965f98927f9d61acbc6a04d9351ef232c8b085", "filename": "src/test/run-pass-fulldeps/issue-16723.rs", "status": "removed", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/095b44c83b540bb4dbf74be1cae604f4bae87989/src%2Ftest%2Frun-pass-fulldeps%2Fissue-16723.rs", "raw_url": "https://github.com/rust-lang/rust/raw/095b44c83b540bb4dbf74be1cae604f4bae87989/src%2Ftest%2Frun-pass-fulldeps%2Fissue-16723.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fissue-16723.rs?ref=095b44c83b540bb4dbf74be1cae604f4bae87989", "patch": "@@ -1,19 +0,0 @@\n-// ignore-stage1\n-// aux-build:issue-16723.rs\n-#![feature(plugin)]\n-#![plugin(issue_16723)]\n-\n-multiple_items!();\n-\n-impl Struct1 {\n-    fn foo() {}\n-}\n-impl Struct2 {\n-    fn foo() {}\n-}\n-\n-fn main() {\n-    Struct1::foo();\n-    Struct2::foo();\n-    println!(\"hallo\");\n-}"}, {"sha": "e5945b679f3825ba73b2b62e0c231f0975ba8323", "filename": "src/test/run-pass-fulldeps/issue-16992.rs", "status": "removed", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/095b44c83b540bb4dbf74be1cae604f4bae87989/src%2Ftest%2Frun-pass-fulldeps%2Fissue-16992.rs", "raw_url": "https://github.com/rust-lang/rust/raw/095b44c83b540bb4dbf74be1cae604f4bae87989/src%2Ftest%2Frun-pass-fulldeps%2Fissue-16992.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fissue-16992.rs?ref=095b44c83b540bb4dbf74be1cae604f4bae87989", "patch": "@@ -1,15 +0,0 @@\n-// ignore-cross-compile\n-\n-#![feature(quote, rustc_private)]\n-\n-extern crate syntax;\n-\n-use syntax::ext::base::ExtCtxt;\n-\n-#[allow(dead_code)]\n-fn foobar(cx: &mut ExtCtxt) {\n-    quote_expr!(cx, 1);\n-    quote_expr!(cx, 2);\n-}\n-\n-fn main() { }"}, {"sha": "9fa3d3de8f22e8e18499915da99ff8b6957e9fb3", "filename": "src/test/run-pass-fulldeps/issue-18763-quote-token-tree.rs", "status": "removed", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/095b44c83b540bb4dbf74be1cae604f4bae87989/src%2Ftest%2Frun-pass-fulldeps%2Fissue-18763-quote-token-tree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/095b44c83b540bb4dbf74be1cae604f4bae87989/src%2Ftest%2Frun-pass-fulldeps%2Fissue-18763-quote-token-tree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fissue-18763-quote-token-tree.rs?ref=095b44c83b540bb4dbf74be1cae604f4bae87989", "patch": "@@ -1,22 +0,0 @@\n-#![allow(dead_code)]\n-#![allow(unused_imports)]\n-// ignore-cross-compile\n-#![feature(quote, rustc_private)]\n-\n-extern crate syntax;\n-\n-use syntax::ext::base::ExtCtxt;\n-\n-fn syntax_extension(cx: &ExtCtxt) {\n-    let _toks_1 = vec![quote_tokens!(cx, /** comment */ fn foo() {})];\n-    let name = quote_tokens!(cx, bar);\n-    let _toks_2 = vec![quote_item!(cx, static $name:isize = 2;)];\n-    let _toks_4 = quote_tokens!(cx, $name:static $name:sizeof);\n-    let _toks_3 = vec![quote_item!(cx,\n-        /// comment\n-        fn foo() { let $name:isize = 3; }\n-    )];\n-}\n-\n-fn main() {\n-}"}, {"sha": "3c251cc0f553a376971877ceedbb4c1fc0da4cd7", "filename": "src/test/run-pass-fulldeps/macro-crate-does-hygiene-work.rs", "status": "removed", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/095b44c83b540bb4dbf74be1cae604f4bae87989/src%2Ftest%2Frun-pass-fulldeps%2Fmacro-crate-does-hygiene-work.rs", "raw_url": "https://github.com/rust-lang/rust/raw/095b44c83b540bb4dbf74be1cae604f4bae87989/src%2Ftest%2Frun-pass-fulldeps%2Fmacro-crate-does-hygiene-work.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fmacro-crate-does-hygiene-work.rs?ref=095b44c83b540bb4dbf74be1cae604f4bae87989", "patch": "@@ -1,16 +0,0 @@\n-// aux-build:macro_crate_test.rs\n-// ignore-stage1\n-\n-// Issue #15750: a macro that internally parses its input and then\n-// uses `quote_expr!` to rearrange it should be hygiene-preserving.\n-\n-#![feature(plugin)]\n-#![plugin(macro_crate_test)]\n-\n-fn main() {\n-    let x = 3;\n-    assert_eq!(3, identity!(x));\n-    assert_eq!(6, identity!(x+x));\n-    let x = 4;\n-    assert_eq!(4, identity!(x));\n-}"}, {"sha": "eb7ab139d647f29e4025c8b7bc19e6e771915fa3", "filename": "src/test/run-pass-fulldeps/macro-crate-multi-decorator-literals.rs", "status": "removed", "additions": 0, "deletions": 50, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/095b44c83b540bb4dbf74be1cae604f4bae87989/src%2Ftest%2Frun-pass-fulldeps%2Fmacro-crate-multi-decorator-literals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/095b44c83b540bb4dbf74be1cae604f4bae87989/src%2Ftest%2Frun-pass-fulldeps%2Fmacro-crate-multi-decorator-literals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fmacro-crate-multi-decorator-literals.rs?ref=095b44c83b540bb4dbf74be1cae604f4bae87989", "patch": "@@ -1,50 +0,0 @@\n-#![allow(plugin_as_library)]\n-#![allow(unused_imports)]\n-// aux-build:macro_crate_test.rs\n-// ignore-stage1\n-\n-#![feature(plugin, rustc_attrs)]\n-#![plugin(macro_crate_test)]\n-\n-#[macro_use]\n-#[no_link]\n-extern crate macro_crate_test;\n-\n-// The `caller(name, args...)` attribute emits a new nullary function named\n-// `name` that calls the annotated function with `args`. As an example, consider\n-// the following:\n-//\n-//     #[caller(simple, 1, \"hello\", 3.14)]\n-//     fn f(num: isize, string: &'static str, float: f32) -> (isize, &'static str, float) {\n-//         (num, string, float)\n-//     }\n-//\n-// This results in a function named `simple` that calls `f(1, \"hello\", 3.14)`.\n-// As a result, the expression `simple()` evaluates to `(1, \"helllo\", 3.14)`.\n-\n-#[rustc_caller(simple, 1, \"hello\", 3.14)]\n-#[rustc_caller(simple1, 2, \"bye\", 6.28)]\n-#[rustc_caller(simple2, 3, \"hi\", 1.01)]\n-fn f(num: isize, string: &'static str, float: f32) -> (isize, &'static str, f32) {\n-    (num, string, float)\n-}\n-\n-#[rustc_caller(complex, true, 10)]\n-#[rustc_caller(complex1, false, 15)]\n-#[rustc_caller(complex2, true, 20)]\n-fn g(emit: bool, num: i32) -> Option<i32> {\n-    match emit {\n-        true => Some(num),\n-        false => None\n-    }\n-}\n-\n-fn main() {\n-    assert_eq!(simple(), (1, \"hello\", 3.14));\n-    assert_eq!(simple1(), (2, \"bye\", 6.28));\n-    assert_eq!(simple2(), (3, \"hi\", 1.01));\n-\n-    assert_eq!(complex(), Some(10));\n-    assert_eq!(complex1(), None);\n-    assert_eq!(complex2(), Some(20));\n-}"}, {"sha": "dcac160c4c9745df9a83e143c618749473f492d3", "filename": "src/test/run-pass-fulldeps/macro-crate-multi-decorator.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/01f8e25b15f4ab157c8e7c9c56054df7595ec0e1/src%2Ftest%2Frun-pass-fulldeps%2Fmacro-crate-multi-decorator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01f8e25b15f4ab157c8e7c9c56054df7595ec0e1/src%2Ftest%2Frun-pass-fulldeps%2Fmacro-crate-multi-decorator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fmacro-crate-multi-decorator.rs?ref=01f8e25b15f4ab157c8e7c9c56054df7595ec0e1", "patch": "@@ -5,11 +5,9 @@\n // aux-build:macro_crate_test.rs\n // ignore-stage1\n \n-#![feature(plugin, rustc_attrs)]\n-#![plugin(macro_crate_test)]\n+#![feature(rustc_attrs)]\n \n #[macro_use]\n-#[no_link]\n extern crate macro_crate_test;\n \n // The duplicate macro will create a copy of the item with the given identifier."}, {"sha": "62838c2c0839d73b258f02b1bb319e00be81b392", "filename": "src/test/run-pass-fulldeps/macro-crate.rs", "status": "removed", "additions": 0, "deletions": 46, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/095b44c83b540bb4dbf74be1cae604f4bae87989/src%2Ftest%2Frun-pass-fulldeps%2Fmacro-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/095b44c83b540bb4dbf74be1cae604f4bae87989/src%2Ftest%2Frun-pass-fulldeps%2Fmacro-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fmacro-crate.rs?ref=095b44c83b540bb4dbf74be1cae604f4bae87989", "patch": "@@ -1,46 +0,0 @@\n-#![allow(plugin_as_library)]\n-#![allow(dead_code)]\n-// aux-build:macro_crate_test.rs\n-// ignore-stage1\n-\n-#![feature(plugin, rustc_attrs)]\n-#![plugin(macro_crate_test)]\n-\n-#[macro_use] #[no_link]\n-extern crate macro_crate_test;\n-\n-#[rustc_into_multi_foo]\n-#[derive(PartialEq, Clone, Debug)]\n-fn foo() -> AnotherFakeTypeThatHadBetterGoAway {}\n-\n-// Check that the `#[into_multi_foo]`-generated `foo2` is configured away\n-fn foo2() {}\n-\n-trait Qux {\n-    #[rustc_into_multi_foo]\n-    fn bar();\n-}\n-\n-impl Qux for i32 {\n-    #[rustc_into_multi_foo]\n-    fn bar() {}\n-}\n-\n-impl Qux for u8 {}\n-\n-pub fn main() {\n-    assert_eq!(1, make_a_1!());\n-    assert_eq!(2, exported_macro!());\n-\n-    assert_eq!(Foo2::Bar2, Foo2::Bar2);\n-    test(None::<Foo2>);\n-\n-    let _ = Foo3::Bar;\n-\n-    let x = 10i32;\n-    assert_eq!(x.foo(), 42);\n-    let x = 10u8;\n-    assert_eq!(x.foo(), 0);\n-}\n-\n-fn test<T: PartialEq+Clone>(_: Option<T>) {}"}, {"sha": "c672081edf48c40f8698df1d416f221b512362dd", "filename": "src/test/run-pass-fulldeps/mbe_matching_test_macro.rs", "status": "removed", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/095b44c83b540bb4dbf74be1cae604f4bae87989/src%2Ftest%2Frun-pass-fulldeps%2Fmbe_matching_test_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/095b44c83b540bb4dbf74be1cae604f4bae87989/src%2Ftest%2Frun-pass-fulldeps%2Fmbe_matching_test_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fmbe_matching_test_macro.rs?ref=095b44c83b540bb4dbf74be1cae604f4bae87989", "patch": "@@ -1,11 +0,0 @@\n-// aux-build:procedural_mbe_matching.rs\n-// ignore-stage1\n-\n-#![feature(plugin)]\n-#![plugin(procedural_mbe_matching)]\n-\n-pub fn main() {\n-    assert_eq!(matches!(Some(123), None | Some(0)), false);\n-    assert_eq!(matches!(Some(123), None | Some(123)), true);\n-    assert_eq!(matches!(true, true), true);\n-}"}, {"sha": "e9f234f7f545e619fc293262f8e6e2425da861c4", "filename": "src/test/run-pass-fulldeps/plugin-lib-ok-in-plugin.rs", "status": "removed", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/095b44c83b540bb4dbf74be1cae604f4bae87989/src%2Ftest%2Frun-pass-fulldeps%2Fplugin-lib-ok-in-plugin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/095b44c83b540bb4dbf74be1cae604f4bae87989/src%2Ftest%2Frun-pass-fulldeps%2Fplugin-lib-ok-in-plugin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fplugin-lib-ok-in-plugin.rs?ref=095b44c83b540bb4dbf74be1cae604f4bae87989", "patch": "@@ -1,16 +0,0 @@\n-// aux-build:macro_crate_test.rs\n-// aux-build:plugin_with_plugin_lib.rs\n-// ignore-stage1\n-// ignore-cross-compile\n-//\n-// macro_crate_test will not compile on a cross-compiled target because\n-// libsyntax is not compiled for it.\n-\n-#![deny(plugin_as_library)]\n-#![feature(plugin)]\n-#![plugin(macro_crate_test)]\n-#![plugin(plugin_with_plugin_lib)]\n-\n-fn main() {\n-    assert_eq!(1, make_a_1!());\n-}"}, {"sha": "e45a7f59c1bdc0186643d3a7c443d1c8749aa40d", "filename": "src/test/run-pass-fulldeps/plugin-plus-extern-crate.rs", "status": "removed", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/095b44c83b540bb4dbf74be1cae604f4bae87989/src%2Ftest%2Frun-pass-fulldeps%2Fplugin-plus-extern-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/095b44c83b540bb4dbf74be1cae604f4bae87989/src%2Ftest%2Frun-pass-fulldeps%2Fplugin-plus-extern-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fplugin-plus-extern-crate.rs?ref=095b44c83b540bb4dbf74be1cae604f4bae87989", "patch": "@@ -1,17 +0,0 @@\n-// aux-build:macro_crate_test.rs\n-// ignore-stage1\n-// ignore-cross-compile\n-//\n-// macro_crate_test will not compile on a cross-compiled target because\n-// libsyntax is not compiled for it.\n-\n-#![allow(plugin_as_library)]\n-#![feature(plugin)]\n-#![plugin(macro_crate_test)]\n-\n-extern crate macro_crate_test;\n-\n-fn main() {\n-    assert_eq!(1, make_a_1!());\n-    macro_crate_test::foo();\n-}"}, {"sha": "33063fc74bfb39fedc4bc8b8bf697aa12ef442ad", "filename": "src/test/run-pass-fulldeps/qquote.rs", "status": "removed", "additions": 0, "deletions": 92, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/095b44c83b540bb4dbf74be1cae604f4bae87989/src%2Ftest%2Frun-pass-fulldeps%2Fqquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/095b44c83b540bb4dbf74be1cae604f4bae87989/src%2Ftest%2Frun-pass-fulldeps%2Fqquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fqquote.rs?ref=095b44c83b540bb4dbf74be1cae604f4bae87989", "patch": "@@ -1,92 +0,0 @@\n-#![allow(unused_imports)]\n-// ignore-cross-compile\n-\n-#![feature(quote, rustc_private)]\n-\n-extern crate syntax;\n-extern crate syntax_pos;\n-\n-use syntax::source_map::FilePathMapping;\n-use syntax::print::pprust::*;\n-use syntax::symbol::Symbol;\n-use syntax_pos::DUMMY_SP;\n-\n-fn main() {\n-    syntax::with_globals(|| run());\n-}\n-\n-fn run() {\n-    let ps = syntax::parse::ParseSess::new(FilePathMapping::empty());\n-    let mut resolver = syntax::ext::base::DummyResolver;\n-    let mut cx = syntax::ext::base::ExtCtxt::new(\n-        &ps,\n-        syntax::ext::expand::ExpansionConfig::default(\"qquote\".to_string()),\n-        &mut resolver);\n-    let cx = &mut cx;\n-\n-    macro_rules! check {\n-        ($f: ident, $($e: expr),+; $expect: expr) => ({\n-            $(assert_eq!($f(&$e), $expect);)+\n-        });\n-    }\n-\n-    let abc = quote_expr!(cx, 23);\n-    check!(expr_to_string, abc, *quote_expr!(cx, $abc); \"23\");\n-\n-    let ty = quote_ty!(cx, isize);\n-    check!(ty_to_string, ty, *quote_ty!(cx, $ty); \"isize\");\n-\n-    let item = quote_item!(cx, static x: $ty = 10;).unwrap();\n-    check!(item_to_string, item, quote_item!(cx, $item).unwrap(); \"static x: isize = 10;\");\n-\n-    let twenty: u16 = 20;\n-    let stmt = quote_stmt!(cx, let x = $twenty;).unwrap();\n-    check!(stmt_to_string, stmt, quote_stmt!(cx, $stmt).unwrap(); \"let x = 20u16;\");\n-\n-    let pat = quote_pat!(cx, Some(_));\n-    check!(pat_to_string, pat, *quote_pat!(cx, $pat); \"Some(_)\");\n-\n-    let expr = quote_expr!(cx, (x, y));\n-    let arm = quote_arm!(cx, (ref x, ref y) => $expr,);\n-    check!(arm_to_string, arm, quote_arm!(cx, $arm); \" (ref x, ref y) => (x, y),\");\n-\n-    let attr = quote_attr!(cx, #![cfg(foo = \"bar\")]);\n-    check!(attribute_to_string, attr, quote_attr!(cx, $attr); r#\"#![cfg(foo = \"bar\")]\"#);\n-\n-    // quote_arg!\n-\n-    let arg = quote_arg!(cx, foo: i32);\n-    check!(arg_to_string, arg, quote_arg!(cx, $arg); \"foo: i32\");\n-\n-    let function = quote_item!(cx, fn f($arg) { }).unwrap();\n-    check!(item_to_string, function; \"fn f(foo: i32) { }\");\n-\n-    let args = vec![arg, quote_arg!(cx, bar: u32)];\n-    let args = &args[..];\n-    let function = quote_item!(cx, fn f($args) { }).unwrap();\n-    check!(item_to_string, function; \"fn f(foo: i32, bar: u32) { }\");\n-\n-    // quote_block!\n-\n-    let block = quote_block!(cx, { $stmt let y = 40u32; });\n-    check!(block_to_string, block, *quote_block!(cx, $block); \"{ let x = 20u16; let y = 40u32; }\");\n-\n-    let function = quote_item!(cx, fn f() $block).unwrap();\n-    check!(item_to_string, function; \"fn f() { let x = 20u16; let y = 40u32; }\");\n-\n-    // quote_path!\n-\n-    let path = quote_path!(cx, ::syntax::ptr::P<MetaItem>);\n-    check!(path_to_string, path, quote_path!(cx, $path); \"::syntax::ptr::P<MetaItem>\");\n-\n-    let ty = quote_ty!(cx, $path);\n-    check!(ty_to_string, ty; \"::syntax::ptr::P<MetaItem>\");\n-\n-    // quote_meta_item!\n-\n-    let meta = quote_meta_item!(cx, cfg(foo = \"bar\"));\n-    check!(meta_item_to_string, meta, quote_meta_item!(cx, $meta); r#\"cfg(foo = \"bar\")\"#);\n-\n-    let attr = quote_attr!(cx, #![$meta]);\n-    check!(attribute_to_string, attr; r#\"#![cfg(foo = \"bar\")]\"#);\n-}"}, {"sha": "04a4c442e0025675dff060d4127bc669b2bab1f2", "filename": "src/test/run-pass-fulldeps/quote-tokens.rs", "status": "removed", "additions": 0, "deletions": 45, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/095b44c83b540bb4dbf74be1cae604f4bae87989/src%2Ftest%2Frun-pass-fulldeps%2Fquote-tokens.rs", "raw_url": "https://github.com/rust-lang/rust/raw/095b44c83b540bb4dbf74be1cae604f4bae87989/src%2Ftest%2Frun-pass-fulldeps%2Fquote-tokens.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fquote-tokens.rs?ref=095b44c83b540bb4dbf74be1cae604f4bae87989", "patch": "@@ -1,45 +0,0 @@\n-#![allow(dead_code)]\n-#![allow(unused_variables)]\n-#![allow(unused_imports)]\n-// ignore-cross-compile\n-#![feature(quote, rustc_private)]\n-\n-extern crate syntax;\n-\n-use syntax::ext::base::ExtCtxt;\n-use syntax::ptr::P;\n-use syntax::parse::PResult;\n-\n-fn syntax_extension(cx: &ExtCtxt) {\n-    let e_toks : Vec<syntax::tokenstream::TokenTree> = quote_tokens!(cx, 1 + 2);\n-    let p_toks : Vec<syntax::tokenstream::TokenTree> = quote_tokens!(cx, (x, 1 .. 4, *));\n-\n-    let a: P<syntax::ast::Expr> = quote_expr!(cx, 1 + 2);\n-    let _b: Option<P<syntax::ast::Item>> = quote_item!(cx, static foo : isize = $e_toks; );\n-    let _c: P<syntax::ast::Pat> = quote_pat!(cx, (x, 1 .. 4, *) );\n-    let _d: Option<syntax::ast::Stmt> = quote_stmt!(cx, let x = $a; );\n-    let _d: syntax::ast::Arm = quote_arm!(cx, (ref x, ref y) = (x, y) );\n-    let _e: P<syntax::ast::Expr> = quote_expr!(cx, match foo { $p_toks => 10 } );\n-\n-    let _f: P<syntax::ast::Expr> = quote_expr!(cx, ());\n-    let _g: P<syntax::ast::Expr> = quote_expr!(cx, true);\n-    let _h: P<syntax::ast::Expr> = quote_expr!(cx, 'a');\n-\n-    let i: Option<P<syntax::ast::Item>> = quote_item!(cx, #[derive(Eq)] struct Foo; );\n-    assert!(i.is_some());\n-\n-    let _l: P<syntax::ast::Ty> = quote_ty!(cx, &isize);\n-\n-    let _n: syntax::ast::Attribute = quote_attr!(cx, #![cfg(foo, bar = \"baz\")]);\n-\n-    let _o: Option<P<syntax::ast::Item>> = quote_item!(cx, fn foo<T: ?Sized>() {});\n-\n-    let stmts = vec![\n-        quote_stmt!(cx, let x = 1;).unwrap(),\n-        quote_stmt!(cx, let y = 2;).unwrap(),\n-    ];\n-    let expr: P<syntax::ast::Expr> = quote_expr!(cx, x + y);\n-}\n-\n-fn main() {\n-}"}, {"sha": "1568bf260398634bd0a08e91f2c6a87437dc3875", "filename": "src/test/run-pass-fulldeps/quote-unused-sp-no-warning.rs", "status": "removed", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/095b44c83b540bb4dbf74be1cae604f4bae87989/src%2Ftest%2Frun-pass-fulldeps%2Fquote-unused-sp-no-warning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/095b44c83b540bb4dbf74be1cae604f4bae87989/src%2Ftest%2Frun-pass-fulldeps%2Fquote-unused-sp-no-warning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fquote-unused-sp-no-warning.rs?ref=095b44c83b540bb4dbf74be1cae604f4bae87989", "patch": "@@ -1,15 +0,0 @@\n-#![allow(dead_code)]\n-// ignore-cross-compile\n-#![feature(quote, rustc_private)]\n-#![deny(unused_variables)]\n-\n-extern crate syntax;\n-\n-use syntax::ext::base::ExtCtxt;\n-\n-fn test(cx: &mut ExtCtxt) {\n-    let foo = 10;\n-    let _e = quote_expr!(cx, $foo);\n-}\n-\n-pub fn main() { }"}, {"sha": "7c236fd69eae63f8c73c0758e0ecf616f9611aac", "filename": "src/test/run-pass-fulldeps/syntax-extension-with-dll-deps.rs", "status": "removed", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/095b44c83b540bb4dbf74be1cae604f4bae87989/src%2Ftest%2Frun-pass-fulldeps%2Fsyntax-extension-with-dll-deps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/095b44c83b540bb4dbf74be1cae604f4bae87989/src%2Ftest%2Frun-pass-fulldeps%2Fsyntax-extension-with-dll-deps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fsyntax-extension-with-dll-deps.rs?ref=095b44c83b540bb4dbf74be1cae604f4bae87989", "patch": "@@ -1,10 +0,0 @@\n-// aux-build:syntax_extension_with_dll_deps_1.rs\n-// aux-build:syntax_extension_with_dll_deps_2.rs\n-// ignore-stage1\n-\n-#![feature(plugin, rustc_private)]\n-#![plugin(syntax_extension_with_dll_deps_2)]\n-\n-fn main() {\n-    foo!();\n-}"}, {"sha": "a364aa0422deb406989bc3d1396507684b2c0059", "filename": "src/test/ui-fulldeps/auxiliary/macro_crate_test.rs", "status": "removed", "additions": 0, "deletions": 149, "changes": 149, "blob_url": "https://github.com/rust-lang/rust/blob/095b44c83b540bb4dbf74be1cae604f4bae87989/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Fmacro_crate_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/095b44c83b540bb4dbf74be1cae604f4bae87989/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Fmacro_crate_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Fmacro_crate_test.rs?ref=095b44c83b540bb4dbf74be1cae604f4bae87989", "patch": "@@ -1,149 +0,0 @@\n-// force-host\n-\n-#![feature(plugin_registrar, quote, rustc_private)]\n-\n-extern crate syntax;\n-extern crate syntax_pos;\n-extern crate rustc;\n-extern crate rustc_plugin;\n-\n-use syntax::ast::{self, Item, MetaItem, ItemKind};\n-use syntax::ext::base::*;\n-use syntax::parse;\n-use syntax::ptr::P;\n-use syntax::symbol::Symbol;\n-use syntax::tokenstream::TokenTree;\n-use syntax_pos::Span;\n-use rustc_plugin::Registry;\n-\n-#[macro_export]\n-macro_rules! exported_macro { () => (2) }\n-macro_rules! unexported_macro { () => (3) }\n-\n-#[plugin_registrar]\n-pub fn plugin_registrar(reg: &mut Registry) {\n-    reg.register_macro(\"make_a_1\", expand_make_a_1);\n-    reg.register_macro(\"identity\", expand_identity);\n-    reg.register_syntax_extension(\n-        Symbol::intern(\"into_multi_foo\"),\n-        MultiModifier(Box::new(expand_into_foo_multi)));\n-    reg.register_syntax_extension(\n-        Symbol::intern(\"noop_attribute\"),\n-        MultiModifier(Box::new(expand_noop_attribute)));\n-    reg.register_syntax_extension(\n-        Symbol::intern(\"duplicate\"),\n-        MultiDecorator(Box::new(expand_duplicate)));\n-}\n-\n-fn expand_make_a_1(cx: &mut ExtCtxt, sp: Span, tts: &[TokenTree])\n-                   -> Box<MacResult+'static> {\n-    if !tts.is_empty() {\n-        cx.span_fatal(sp, \"make_a_1 takes no arguments\");\n-    }\n-    MacEager::expr(quote_expr!(cx, 1))\n-}\n-\n-// See Issue #15750\n-fn expand_identity(cx: &mut ExtCtxt, _span: Span, tts: &[TokenTree])\n-                   -> Box<MacResult+'static> {\n-    // Parse an expression and emit it unchanged.\n-    let mut parser = parse::new_parser_from_tts(cx.parse_sess(), tts.to_vec());\n-    let expr = parser.parse_expr().unwrap();\n-    MacEager::expr(quote_expr!(&mut *cx, $expr))\n-}\n-\n-fn expand_into_foo_multi(cx: &mut ExtCtxt,\n-                         _sp: Span,\n-                         _attr: &MetaItem,\n-                         it: Annotatable) -> Annotatable {\n-    match it {\n-        Annotatable::Item(it) => {\n-            Annotatable::Item(P(Item {\n-                attrs: it.attrs.clone(),\n-                ..(*quote_item!(cx, enum Foo2 { Bar2, Baz2 }).unwrap()).clone()\n-            }))\n-        }\n-        Annotatable::ImplItem(_) => {\n-            quote_item!(cx, impl X { fn foo(&self) -> i32 { 42 } }).unwrap().and_then(|i| {\n-                match i.node {\n-                    ItemKind::Impl(.., mut items) => {\n-                        Annotatable::ImplItem(P(items.pop().expect(\"impl method not found\")))\n-                    }\n-                    _ => unreachable!(\"impl parsed to something other than impl\")\n-                }\n-            })\n-        }\n-        Annotatable::TraitItem(_) => {\n-            quote_item!(cx, trait X { fn foo(&self) -> i32 { 0 } }).unwrap().and_then(|i| {\n-                match i.node {\n-                    ItemKind::Trait(.., mut items) => {\n-                        Annotatable::TraitItem(P(items.pop().expect(\"trait method not found\")))\n-                    }\n-                    _ => unreachable!(\"trait parsed to something other than trait\")\n-                }\n-            })\n-        }\n-        // covered in proc_macro/macros-in-extern.rs\n-        Annotatable::ForeignItem(_) => unimplemented!(),\n-        // covered in proc_macro/attr-stmt-expr.rs\n-        Annotatable::Stmt(_) | Annotatable::Expr(_) => panic!(\"expected item\")\n-    }\n-}\n-\n-fn expand_noop_attribute(_cx: &mut ExtCtxt,\n-                         _sp: Span,\n-                         _attr: &MetaItem,\n-                         it: Annotatable) -> Annotatable {\n-    it\n-}\n-\n-// Create a duplicate of the annotatable, based on the MetaItem\n-fn expand_duplicate(cx: &mut ExtCtxt,\n-                    _sp: Span,\n-                    mi: &MetaItem,\n-                    it: &Annotatable,\n-                    push: &mut FnMut(Annotatable))\n-{\n-    let copy_name = match mi.node {\n-        ast::MetaItemKind::List(ref xs) => {\n-            if let Some(word) = xs[0].word() {\n-                word.ident.segments.last().unwrap().ident\n-            } else {\n-                cx.span_err(mi.span, \"Expected word\");\n-                return;\n-            }\n-        }\n-        _ => {\n-            cx.span_err(mi.span, \"Expected list\");\n-            return;\n-        }\n-    };\n-\n-    // Duplicate the item but replace its ident by the MetaItem\n-    match it.clone() {\n-        Annotatable::Item(it) => {\n-            let mut new_it = (*it).clone();\n-            new_it.attrs.clear();\n-            new_it.ident = copy_name;\n-            push(Annotatable::Item(P(new_it)));\n-        }\n-        Annotatable::ImplItem(it) => {\n-            let mut new_it = (*it).clone();\n-            new_it.attrs.clear();\n-            new_it.ident = copy_name;\n-            push(Annotatable::ImplItem(P(new_it)));\n-        }\n-        Annotatable::TraitItem(tt) => {\n-            let mut new_it = (*tt).clone();\n-            new_it.attrs.clear();\n-            new_it.ident = copy_name;\n-            push(Annotatable::TraitItem(P(new_it)));\n-        }\n-        // covered in proc_macro/macros-in-extern.rs\n-        Annotatable::ForeignItem(_) => unimplemented!(),\n-        // covered in proc_macro/attr-stmt-expr.rs\n-        Annotatable::Stmt(_) | Annotatable::Expr(_) => panic!(\"expected item\")\n-    }\n-}\n-\n-pub fn foo() {}"}, {"sha": "a647585e621fe5df0745283484340319bd016db4", "filename": "src/test/ui-fulldeps/gated-plugin.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/01f8e25b15f4ab157c8e7c9c56054df7595ec0e1/src%2Ftest%2Fui-fulldeps%2Fgated-plugin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01f8e25b15f4ab157c8e7c9c56054df7595ec0e1/src%2Ftest%2Fui-fulldeps%2Fgated-plugin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fgated-plugin.rs?ref=01f8e25b15f4ab157c8e7c9c56054df7595ec0e1", "patch": "@@ -1,6 +1,6 @@\n-// aux-build:macro_crate_test.rs\n+// aux-build:attr_plugin_test.rs\n \n-#![plugin(macro_crate_test)]\n+#![plugin(attr_plugin_test)]\n //~^ ERROR compiler plugins are experimental and possibly buggy\n \n fn main() {}"}, {"sha": "37c2b4432470d881f0891d9458e4f98e591c8ad5", "filename": "src/test/ui-fulldeps/gated-plugin.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/01f8e25b15f4ab157c8e7c9c56054df7595ec0e1/src%2Ftest%2Fui-fulldeps%2Fgated-plugin.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/01f8e25b15f4ab157c8e7c9c56054df7595ec0e1/src%2Ftest%2Fui-fulldeps%2Fgated-plugin.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fgated-plugin.stderr?ref=01f8e25b15f4ab157c8e7c9c56054df7595ec0e1", "patch": "@@ -1,7 +1,7 @@\n error[E0658]: compiler plugins are experimental and possibly buggy (see issue #29597)\n   --> $DIR/gated-plugin.rs:3:1\n    |\n-LL | #![plugin(macro_crate_test)]\n+LL | #![plugin(attr_plugin_test)]\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: add #![feature(plugin)] to the crate attributes to enable"}, {"sha": "86848e3156fbdf832d00f8474461ccdd750433d8", "filename": "src/test/ui-fulldeps/gated-quote.rs", "status": "removed", "additions": 0, "deletions": 57, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/095b44c83b540bb4dbf74be1cae604f4bae87989/src%2Ftest%2Fui-fulldeps%2Fgated-quote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/095b44c83b540bb4dbf74be1cae604f4bae87989/src%2Ftest%2Fui-fulldeps%2Fgated-quote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fgated-quote.rs?ref=095b44c83b540bb4dbf74be1cae604f4bae87989", "patch": "@@ -1,57 +0,0 @@\n-// Test that `quote`-related macro are gated by `quote` feature gate.\n-\n-// (To sanity-check the code, uncomment this.)\n-// #![feature(quote)]\n-\n-// FIXME the error message that is current emitted seems pretty bad.\n-\n-// gate-test-quote\n-\n-#![feature(rustc_private)]\n-#![allow(dead_code, unused_imports, unused_variables)]\n-\n-#[macro_use]\n-extern crate syntax;\n-\n-use syntax::ast;\n-use syntax::parse;\n-\n-struct ParseSess;\n-\n-impl ParseSess {\n-    fn cfg(&self) -> ast::CrateConfig { loop { } }\n-    fn parse_sess<'a>(&'a self) -> &'a parse::ParseSess { loop { } }\n-    fn call_site(&self) -> () { loop { } }\n-    fn ident_of(&self, st: &str) -> ast::Ident { loop { } }\n-    fn name_of(&self, st: &str) -> ast::Name { loop { } }\n-}\n-\n-pub fn main() {\n-    let ecx = &ParseSess;\n-    let x = quote_tokens!(ecx, 3);\n-    //~^ ERROR cannot find macro `quote_tokens!` in this scope\n-    let x = quote_expr!(ecx, 3);\n-    //~^ ERROR cannot find macro `quote_expr!` in this scope\n-    let x = quote_ty!(ecx, 3);\n-    //~^ ERROR cannot find macro `quote_ty!` in this scope\n-    let x = quote_method!(ecx, 3);\n-    //~^ ERROR cannot find macro `quote_method!` in this scope\n-    let x = quote_item!(ecx, 3);\n-    //~^ ERROR cannot find macro `quote_item!` in this scope\n-    let x = quote_pat!(ecx, 3);\n-    //~^ ERROR cannot find macro `quote_pat!` in this scope\n-    let x = quote_arm!(ecx, 3);\n-    //~^ ERROR cannot find macro `quote_arm!` in this scope\n-    let x = quote_stmt!(ecx, 3);\n-    //~^ ERROR cannot find macro `quote_stmt!` in this scope\n-    let x = quote_attr!(ecx, 3);\n-    //~^ ERROR cannot find macro `quote_attr!` in this scope\n-    let x = quote_arg!(ecx, 3);\n-    //~^ ERROR cannot find macro `quote_arg!` in this scope\n-    let x = quote_block!(ecx, 3);\n-    //~^ ERROR cannot find macro `quote_block!` in this scope\n-    let x = quote_meta_item!(ecx, 3);\n-    //~^ ERROR cannot find macro `quote_meta_item!` in this scope\n-    let x = quote_path!(ecx, 3);\n-    //~^ ERROR cannot find macro `quote_path!` in this scope\n-}"}, {"sha": "897e97b7eb1eeda889990d09218f453096c25566", "filename": "src/test/ui-fulldeps/gated-quote.stderr", "status": "removed", "additions": 0, "deletions": 80, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/095b44c83b540bb4dbf74be1cae604f4bae87989/src%2Ftest%2Fui-fulldeps%2Fgated-quote.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/095b44c83b540bb4dbf74be1cae604f4bae87989/src%2Ftest%2Fui-fulldeps%2Fgated-quote.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fgated-quote.stderr?ref=095b44c83b540bb4dbf74be1cae604f4bae87989", "patch": "@@ -1,80 +0,0 @@\n-error: cannot find macro `quote_path!` in this scope\n-  --> $DIR/gated-quote.rs:55:13\n-   |\n-LL |     let x = quote_path!(ecx, 3);\n-   |             ^^^^^^^^^^\n-\n-error: cannot find macro `quote_meta_item!` in this scope\n-  --> $DIR/gated-quote.rs:53:13\n-   |\n-LL |     let x = quote_meta_item!(ecx, 3);\n-   |             ^^^^^^^^^^^^^^^\n-\n-error: cannot find macro `quote_block!` in this scope\n-  --> $DIR/gated-quote.rs:51:13\n-   |\n-LL |     let x = quote_block!(ecx, 3);\n-   |             ^^^^^^^^^^^\n-\n-error: cannot find macro `quote_arg!` in this scope\n-  --> $DIR/gated-quote.rs:49:13\n-   |\n-LL |     let x = quote_arg!(ecx, 3);\n-   |             ^^^^^^^^^\n-\n-error: cannot find macro `quote_attr!` in this scope\n-  --> $DIR/gated-quote.rs:47:13\n-   |\n-LL |     let x = quote_attr!(ecx, 3);\n-   |             ^^^^^^^^^^\n-\n-error: cannot find macro `quote_stmt!` in this scope\n-  --> $DIR/gated-quote.rs:45:13\n-   |\n-LL |     let x = quote_stmt!(ecx, 3);\n-   |             ^^^^^^^^^^\n-\n-error: cannot find macro `quote_arm!` in this scope\n-  --> $DIR/gated-quote.rs:43:13\n-   |\n-LL |     let x = quote_arm!(ecx, 3);\n-   |             ^^^^^^^^^\n-\n-error: cannot find macro `quote_pat!` in this scope\n-  --> $DIR/gated-quote.rs:41:13\n-   |\n-LL |     let x = quote_pat!(ecx, 3);\n-   |             ^^^^^^^^^\n-\n-error: cannot find macro `quote_item!` in this scope\n-  --> $DIR/gated-quote.rs:39:13\n-   |\n-LL |     let x = quote_item!(ecx, 3);\n-   |             ^^^^^^^^^^\n-\n-error: cannot find macro `quote_method!` in this scope\n-  --> $DIR/gated-quote.rs:37:13\n-   |\n-LL |     let x = quote_method!(ecx, 3);\n-   |             ^^^^^^^^^^^^\n-\n-error: cannot find macro `quote_ty!` in this scope\n-  --> $DIR/gated-quote.rs:35:13\n-   |\n-LL |     let x = quote_ty!(ecx, 3);\n-   |             ^^^^^^^^\n-\n-error: cannot find macro `quote_expr!` in this scope\n-  --> $DIR/gated-quote.rs:33:13\n-   |\n-LL |     let x = quote_expr!(ecx, 3);\n-   |             ^^^^^^^^^^\n-\n-error: cannot find macro `quote_tokens!` in this scope\n-  --> $DIR/gated-quote.rs:31:13\n-   |\n-LL |     let x = quote_tokens!(ecx, 3);\n-   |             ^^^^^^^^^^^^\n-\n-error: aborting due to 13 previous errors\n-"}, {"sha": "8c4c2445670b8fab7880845076d02c140ab9154f", "filename": "src/test/ui-fulldeps/issue-48941.rs", "status": "removed", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/095b44c83b540bb4dbf74be1cae604f4bae87989/src%2Ftest%2Fui-fulldeps%2Fissue-48941.rs", "raw_url": "https://github.com/rust-lang/rust/raw/095b44c83b540bb4dbf74be1cae604f4bae87989/src%2Ftest%2Fui-fulldeps%2Fissue-48941.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fissue-48941.rs?ref=095b44c83b540bb4dbf74be1cae604f4bae87989", "patch": "@@ -1,16 +0,0 @@\n-// This is a regression test against an ICE that used to occur\n-// on malformed attributes for a custom MultiModifier.\n-\n-// aux-build:macro_crate_test.rs\n-// ignore-stage1\n-\n-#![feature(plugin)]\n-#![plugin(macro_crate_test)]\n-\n-#[noop_attribute(\"hi\", rank = a)] //~ ERROR expected unsuffixed literal or identifier, found a\n-fn knight() { }\n-\n-#[noop_attribute(\"/user\", data= = \"<user\")] //~ ERROR literal or identifier\n-fn nite() { }\n-\n-fn main() {}"}, {"sha": "6ccea4330493d227aa6ecb3bf1221a1293331397", "filename": "src/test/ui-fulldeps/issue-48941.stderr", "status": "removed", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/095b44c83b540bb4dbf74be1cae604f4bae87989/src%2Ftest%2Fui-fulldeps%2Fissue-48941.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/095b44c83b540bb4dbf74be1cae604f4bae87989/src%2Ftest%2Fui-fulldeps%2Fissue-48941.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fissue-48941.stderr?ref=095b44c83b540bb4dbf74be1cae604f4bae87989", "patch": "@@ -1,14 +0,0 @@\n-error: expected unsuffixed literal or identifier, found a\n-  --> $DIR/issue-48941.rs:10:24\n-   |\n-LL | #[noop_attribute(\"hi\", rank = a)] //~ ERROR expected unsuffixed literal or identifier, found a\n-   |                        ^^^^\n-\n-error: expected unsuffixed literal or identifier, found =\n-  --> $DIR/issue-48941.rs:13:27\n-   |\n-LL | #[noop_attribute(\"/user\", data= = \"<user\")] //~ ERROR literal or identifier\n-   |                           ^^^^\n-\n-error: aborting due to 2 previous errors\n-"}, {"sha": "1e8de1282a0828bd95cf552f5c12996475363f20", "filename": "src/test/ui-fulldeps/macro-crate-doesnt-resolve.rs", "status": "removed", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/095b44c83b540bb4dbf74be1cae604f4bae87989/src%2Ftest%2Fui-fulldeps%2Fmacro-crate-doesnt-resolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/095b44c83b540bb4dbf74be1cae604f4bae87989/src%2Ftest%2Fui-fulldeps%2Fmacro-crate-doesnt-resolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fmacro-crate-doesnt-resolve.rs?ref=095b44c83b540bb4dbf74be1cae604f4bae87989", "patch": "@@ -1,8 +0,0 @@\n-// aux-build:macro_crate_test.rs\n-\n-#[macro_use] #[no_link]\n-extern crate macro_crate_test;\n-\n-fn main() {\n-    macro_crate_test::foo(); //~ ERROR cannot find function `foo` in module `macro_crate_test`\n-}"}, {"sha": "510cedb0c20293013075a13edb3fe2cfb5ac1483", "filename": "src/test/ui-fulldeps/macro-crate-doesnt-resolve.stderr", "status": "removed", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/095b44c83b540bb4dbf74be1cae604f4bae87989/src%2Ftest%2Fui-fulldeps%2Fmacro-crate-doesnt-resolve.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/095b44c83b540bb4dbf74be1cae604f4bae87989/src%2Ftest%2Fui-fulldeps%2Fmacro-crate-doesnt-resolve.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fmacro-crate-doesnt-resolve.stderr?ref=095b44c83b540bb4dbf74be1cae604f4bae87989", "patch": "@@ -1,9 +0,0 @@\n-error[E0425]: cannot find function `foo` in module `macro_crate_test`\n-  --> $DIR/macro-crate-doesnt-resolve.rs:7:23\n-   |\n-LL |     macro_crate_test::foo(); //~ ERROR cannot find function `foo` in module `macro_crate_test`\n-   |                       ^^^ not found in `macro_crate_test`\n-\n-error: aborting due to previous error\n-\n-For more information about this error, try `rustc --explain E0425`."}, {"sha": "8cf0cc4e4f38523ba194d2b3247144379c17df0c", "filename": "src/test/ui-fulldeps/macro-crate-unexported-macro.rs", "status": "removed", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/095b44c83b540bb4dbf74be1cae604f4bae87989/src%2Ftest%2Fui-fulldeps%2Fmacro-crate-unexported-macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/095b44c83b540bb4dbf74be1cae604f4bae87989/src%2Ftest%2Fui-fulldeps%2Fmacro-crate-unexported-macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fmacro-crate-unexported-macro.rs?ref=095b44c83b540bb4dbf74be1cae604f4bae87989", "patch": "@@ -1,9 +0,0 @@\n-// aux-build:macro_crate_test.rs\n-\n-#[macro_use] #[no_link]\n-extern crate macro_crate_test;\n-\n-fn main() {\n-    unexported_macro!();\n-    //~^ ERROR cannot find macro `unexported_macro!` in this scope\n-}"}, {"sha": "0d1b4b64fc5eeb1f3c629a768b13b257ef687500", "filename": "src/test/ui-fulldeps/macro-crate-unexported-macro.stderr", "status": "removed", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/095b44c83b540bb4dbf74be1cae604f4bae87989/src%2Ftest%2Fui-fulldeps%2Fmacro-crate-unexported-macro.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/095b44c83b540bb4dbf74be1cae604f4bae87989/src%2Ftest%2Fui-fulldeps%2Fmacro-crate-unexported-macro.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fmacro-crate-unexported-macro.stderr?ref=095b44c83b540bb4dbf74be1cae604f4bae87989", "patch": "@@ -1,8 +0,0 @@\n-error: cannot find macro `unexported_macro!` in this scope\n-  --> $DIR/macro-crate-unexported-macro.rs:7:5\n-   |\n-LL |     unexported_macro!();\n-   |     ^^^^^^^^^^^^^^^^ help: you could try the macro: `exported_macro`\n-\n-error: aborting due to previous error\n-"}, {"sha": "37ac8dfa391013a67a6544d23ac1029a38aec4d8", "filename": "src/test/ui-fulldeps/plugin-as-extern-crate.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/01f8e25b15f4ab157c8e7c9c56054df7595ec0e1/src%2Ftest%2Fui-fulldeps%2Fplugin-as-extern-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01f8e25b15f4ab157c8e7c9c56054df7595ec0e1/src%2Ftest%2Fui-fulldeps%2Fplugin-as-extern-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fplugin-as-extern-crate.rs?ref=01f8e25b15f4ab157c8e7c9c56054df7595ec0e1", "patch": "@@ -1,12 +1,12 @@\n-// aux-build:macro_crate_test.rs\n+// aux-build:attr_plugin_test.rs\n // ignore-cross-compile\n //\n-// macro_crate_test will not compile on a cross-compiled target because\n+// attr_plugin_test will not compile on a cross-compiled target because\n // libsyntax is not compiled for it.\n \n #![deny(plugin_as_library)]\n #![allow(unused_extern_crates)]\n \n-extern crate macro_crate_test; //~ ERROR compiler plugin used as an ordinary library\n+extern crate attr_plugin_test; //~ ERROR compiler plugin used as an ordinary library\n \n fn main() { }"}, {"sha": "4a5a53980eb8a00a1c02419ec2a4f1e02893dc45", "filename": "src/test/ui-fulldeps/plugin-as-extern-crate.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/01f8e25b15f4ab157c8e7c9c56054df7595ec0e1/src%2Ftest%2Fui-fulldeps%2Fplugin-as-extern-crate.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/01f8e25b15f4ab157c8e7c9c56054df7595ec0e1/src%2Ftest%2Fui-fulldeps%2Fplugin-as-extern-crate.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fplugin-as-extern-crate.stderr?ref=01f8e25b15f4ab157c8e7c9c56054df7595ec0e1", "patch": "@@ -1,7 +1,7 @@\n error: compiler plugin used as an ordinary library\n   --> $DIR/plugin-as-extern-crate.rs:10:1\n    |\n-LL | extern crate macro_crate_test; //~ ERROR compiler plugin used as an ordinary library\n+LL | extern crate attr_plugin_test; //~ ERROR compiler plugin used as an ordinary library\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n note: lint level defined here"}, {"sha": "db13954f8eda9bcff8980c0cfd31adc5b6dbe45d", "filename": "src/test/ui-fulldeps/plugin-plus-extern-crate.rs", "status": "removed", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/095b44c83b540bb4dbf74be1cae604f4bae87989/src%2Ftest%2Fui-fulldeps%2Fplugin-plus-extern-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/095b44c83b540bb4dbf74be1cae604f4bae87989/src%2Ftest%2Fui-fulldeps%2Fplugin-plus-extern-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fplugin-plus-extern-crate.rs?ref=095b44c83b540bb4dbf74be1cae604f4bae87989", "patch": "@@ -1,17 +0,0 @@\n-// aux-build:macro_crate_test.rs\n-// ignore-stage1\n-// ignore-cross-compile\n-//\n-// macro_crate_test will not compile on a cross-compiled target because\n-// libsyntax is not compiled for it.\n-\n-#![deny(plugin_as_library)]\n-#![feature(plugin)]\n-#![plugin(macro_crate_test)]\n-\n-extern crate macro_crate_test; //~ ERROR compiler plugin used as an ordinary library\n-\n-fn main() {\n-    assert_eq!(1, make_a_1!());\n-    macro_crate_test::foo();\n-}"}, {"sha": "284d76b6132633178d11cbad07318ef180cd730f", "filename": "src/test/ui-fulldeps/plugin-plus-extern-crate.stderr", "status": "removed", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/095b44c83b540bb4dbf74be1cae604f4bae87989/src%2Ftest%2Fui-fulldeps%2Fplugin-plus-extern-crate.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/095b44c83b540bb4dbf74be1cae604f4bae87989/src%2Ftest%2Fui-fulldeps%2Fplugin-plus-extern-crate.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fplugin-plus-extern-crate.stderr?ref=095b44c83b540bb4dbf74be1cae604f4bae87989", "patch": "@@ -1,14 +0,0 @@\n-error: compiler plugin used as an ordinary library\n-  --> $DIR/plugin-plus-extern-crate.rs:12:1\n-   |\n-LL | extern crate macro_crate_test; //~ ERROR compiler plugin used as an ordinary library\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-note: lint level defined here\n-  --> $DIR/plugin-plus-extern-crate.rs:8:9\n-   |\n-LL | #![deny(plugin_as_library)]\n-   |         ^^^^^^^^^^^^^^^^^\n-\n-error: aborting due to previous error\n-"}, {"sha": "99e365d21ff9491b0e822db7af2df9919e2cd1ea", "filename": "src/test/ui-fulldeps/qquote.rs", "status": "removed", "additions": 0, "deletions": 27, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/095b44c83b540bb4dbf74be1cae604f4bae87989/src%2Ftest%2Fui-fulldeps%2Fqquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/095b44c83b540bb4dbf74be1cae604f4bae87989/src%2Ftest%2Fui-fulldeps%2Fqquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fqquote.rs?ref=095b44c83b540bb4dbf74be1cae604f4bae87989", "patch": "@@ -1,27 +0,0 @@\n-// ignore-cross-compile\n-\n-#![feature(quote, rustc_private)]\n-\n-extern crate syntax;\n-extern crate syntax_pos;\n-\n-use syntax::ast;\n-use syntax::source_map::FilePathMapping;\n-use syntax::print::pprust;\n-use syntax::symbol::Symbol;\n-use syntax_pos::DUMMY_SP;\n-\n-fn main() {\n-    let ps = syntax::parse::ParseSess::new(FilePathMapping::empty());\n-    let mut resolver = syntax::ext::base::DummyResolver;\n-    let mut cx = syntax::ext::base::ExtCtxt::new(\n-        &ps,\n-        syntax::ext::expand::ExpansionConfig::default(\"qquote\".to_string()),\n-        &mut resolver);\n-    let cx = &mut cx;\n-\n-    assert_eq!(pprust::expr_to_string(&*quote_expr!(&cx, 23)), \"23\");\n-\n-    let expr = quote_expr!(&cx, 2 - $abcd + 7); //~ ERROR cannot find value `abcd` in this scope\n-    assert_eq!(pprust::expr_to_string(&*expr), \"2 - $abcd + 7\");\n-}"}, {"sha": "a51318b0edc98c5fecb5e57ed65ada73cd4b12d9", "filename": "src/test/ui-fulldeps/qquote.stderr", "status": "removed", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/095b44c83b540bb4dbf74be1cae604f4bae87989/src%2Ftest%2Fui-fulldeps%2Fqquote.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/095b44c83b540bb4dbf74be1cae604f4bae87989/src%2Ftest%2Fui-fulldeps%2Fqquote.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fqquote.stderr?ref=095b44c83b540bb4dbf74be1cae604f4bae87989", "patch": "@@ -1,9 +0,0 @@\n-error[E0425]: cannot find value `abcd` in this scope\n-  --> $DIR/qquote.rs:25:38\n-   |\n-LL |     let expr = quote_expr!(&cx, 2 - $abcd + 7); //~ ERROR cannot find value `abcd` in this scope\n-   |                                      ^^^^ not found in this scope\n-\n-error: aborting due to previous error\n-\n-For more information about this error, try `rustc --explain E0425`."}, {"sha": "b948226652b45fbca46b0d6c0394f8be685218c8", "filename": "src/test/ui/quote-with-interpolated.rs", "status": "removed", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/095b44c83b540bb4dbf74be1cae604f4bae87989/src%2Ftest%2Fui%2Fquote-with-interpolated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/095b44c83b540bb4dbf74be1cae604f4bae87989/src%2Ftest%2Fui%2Fquote-with-interpolated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fquote-with-interpolated.rs?ref=095b44c83b540bb4dbf74be1cae604f4bae87989", "patch": "@@ -1,14 +0,0 @@\n-#![feature(quote)]\n-fn main() {\n-    macro_rules! foo {\n-        ($bar:expr)  => {\n-            quote_expr!(cx, $bar)\n-            //~^ ERROR quote! with interpolated token\n-            //~| ERROR failed to resolve: maybe a missing `extern crate syntax;`?\n-            //~| ERROR failed to resolve: maybe a missing `extern crate syntax;`?\n-            //~| ERROR cannot find value `cx` in this scope\n-            //~| ERROR cannot find function `new_parser_from_tts` in this scope\n-        }\n-    }\n-    foo!(bar);\n-}"}, {"sha": "96feff949bfc936f51653e7d91fda261741240fd", "filename": "src/test/ui/quote-with-interpolated.stderr", "status": "removed", "additions": 0, "deletions": 40, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/095b44c83b540bb4dbf74be1cae604f4bae87989/src%2Ftest%2Fui%2Fquote-with-interpolated.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/095b44c83b540bb4dbf74be1cae604f4bae87989/src%2Ftest%2Fui%2Fquote-with-interpolated.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fquote-with-interpolated.stderr?ref=095b44c83b540bb4dbf74be1cae604f4bae87989", "patch": "@@ -1,40 +0,0 @@\n-error: quote! with interpolated token\n-  --> $DIR/quote-with-interpolated.rs:5:29\n-   |\n-LL |             quote_expr!(cx, $bar)\n-   |                             ^^^^\n-...\n-LL |     foo!(bar);\n-   |     ---------- in this macro invocation\n-\n-error[E0433]: failed to resolve: maybe a missing `extern crate syntax;`?\n-  --> $DIR/quote-with-interpolated.rs:5:13\n-   |\n-LL |             quote_expr!(cx, $bar)\n-   |             ^^^^^^^^^^^^^^^^^^^^^ maybe a missing `extern crate syntax;`?\n-\n-error[E0433]: failed to resolve: maybe a missing `extern crate syntax;`?\n-  --> $DIR/quote-with-interpolated.rs:5:29\n-   |\n-LL |             quote_expr!(cx, $bar)\n-   |                             ^^^^ maybe a missing `extern crate syntax;`?\n-\n-error[E0425]: cannot find value `cx` in this scope\n-  --> $DIR/quote-with-interpolated.rs:5:25\n-   |\n-LL |             quote_expr!(cx, $bar)\n-   |                         ^^ not found in this scope\n-...\n-LL |     foo!(bar);\n-   |     ---------- in this macro invocation\n-\n-error[E0425]: cannot find function `new_parser_from_tts` in this scope\n-  --> $DIR/quote-with-interpolated.rs:5:13\n-   |\n-LL |             quote_expr!(cx, $bar)\n-   |             ^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n-\n-error: aborting due to 5 previous errors\n-\n-Some errors occurred: E0425, E0433.\n-For more information about an error, try `rustc --explain E0425`."}]}