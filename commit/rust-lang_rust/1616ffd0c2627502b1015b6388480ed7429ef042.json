{"sha": "1616ffd0c2627502b1015b6388480ed7429ef042", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE2MTZmZmQwYzI2Mjc1MDJiMTAxNWI2Mzg4NDgwZWQ3NDI5ZWYwNDI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-03-22T16:24:53Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-03-22T16:24:53Z"}, "message": "auto merge of #5398 : dbaupp/rust/core-readlines, r=graydon\n\nThe `each_line` function in `ReaderUtil` acts very differently to equivalent functions in Python, Ruby, Clojure etc. E.g. given a file `t` with contents `trailing\\nnew line\\n` and `n` containing `no trailing\\nnew line`:\r\n\r\nRust:\r\n```Rust\r\nt: ~[~\"trailing\", ~\"new line\", ~\"\"]\r\nn: ~[~\"no trailing\", ~\"new line\"]\r\n```\r\n\r\nPython:\r\n```Python\r\n>>> open('t').readlines()\r\n['trailing\\n', 'new line\\n']\r\n>>> open('n').readlines()\r\n['no trailing\\n', 'new line']\r\n```\r\n\r\nRuby:\r\n```Ruby\r\nirb(main):001:0> File.readlines('t')\r\n=> [\"trailing\\n\", \"new line\\n\"]\r\nirb(main):002:0> File.readlines('n')\r\n=> [\"no trailing\\n\", \"new line\"]\r\n```\r\n\r\nClojure\r\n```Clojure\r\nuser=> (read-lines \"t\")\r\n(\"trailing\" \"new line\")\r\nuser=> (read-lines \"n\")\r\n(\"no trailing\" \"new line\")\r\n```\r\n\r\nThe extra string that rust includes at the end is inconsistent, and means that it is impossible to distinguish between the \"real\" empty line a file that ends `...\\n\\n`, and the \"fake\" one after the last `\\n`.\r\n\r\nThe code attached makes Rust's `each_line` act like Clojure (and PHP, i.e. not including the `\\n`), as well as adjusting `str::lines` to fix the trailing empty line problem.\r\n\r\nAlso, add a convenience `read_lines` method to read all the lines in a file into a vector.", "tree": {"sha": "100e54420b065e55248161fc127d4f00f7af4767", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/100e54420b065e55248161fc127d4f00f7af4767"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1616ffd0c2627502b1015b6388480ed7429ef042", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1616ffd0c2627502b1015b6388480ed7429ef042", "html_url": "https://github.com/rust-lang/rust/commit/1616ffd0c2627502b1015b6388480ed7429ef042", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1616ffd0c2627502b1015b6388480ed7429ef042/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d700500d0cc506f34dccdb8379cc1102becfd24f", "url": "https://api.github.com/repos/rust-lang/rust/commits/d700500d0cc506f34dccdb8379cc1102becfd24f", "html_url": "https://github.com/rust-lang/rust/commit/d700500d0cc506f34dccdb8379cc1102becfd24f"}, {"sha": "f8323397aa3c7358d3c2d3fb62038768b26bfdad", "url": "https://api.github.com/repos/rust-lang/rust/commits/f8323397aa3c7358d3c2d3fb62038768b26bfdad", "html_url": "https://github.com/rust-lang/rust/commit/f8323397aa3c7358d3c2d3fb62038768b26bfdad"}], "stats": {"total": 195, "additions": 152, "deletions": 43}, "files": [{"sha": "a6f4f1ce86281b2d8b9500e0f9cc36aa2a84eed5", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/1616ffd0c2627502b1015b6388480ed7429ef042/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1616ffd0c2627502b1015b6388480ed7429ef042/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=1616ffd0c2627502b1015b6388480ed7429ef042", "patch": "@@ -267,7 +267,7 @@ fn run_debuginfo_test(config: config, props: TestProps, testfile: &Path) {\n         // check if each line in props.check_lines appears in the\n         // output (in order)\n         let mut i = 0u;\n-        for str::lines(ProcRes.stdout).each |line| {\n+        for str::lines_each(ProcRes.stdout) |line| {\n             if props.check_lines[i].trim() == line.trim() {\n                 i += 1u;\n             }\n@@ -297,8 +297,8 @@ fn check_error_patterns(props: TestProps,\n     let mut next_err_idx = 0u;\n     let mut next_err_pat = props.error_patterns[next_err_idx];\n     let mut done = false;\n-    for str::split_char(ProcRes.stderr, '\\n').each |line| {\n-        if str::contains(*line, next_err_pat) {\n+    for str::lines_each(ProcRes.stderr) |line| {\n+        if str::contains(line, next_err_pat) {\n             debug!(\"found error pattern %s\", next_err_pat);\n             next_err_idx += 1u;\n             if next_err_idx == vec::len(props.error_patterns) {\n@@ -347,15 +347,15 @@ fn check_expected_errors(expected_errors: ~[errors::ExpectedError],\n     //    filename:line1:col1: line2:col2: *warning:* msg\n     // where line1:col1: is the starting point, line2:col2:\n     // is the ending point, and * represents ANSI color codes.\n-    for str::split_char(ProcRes.stderr, '\\n').each |line| {\n+    for str::lines_each(ProcRes.stderr) |line| {\n         let mut was_expected = false;\n         for vec::eachi(expected_errors) |i, ee| {\n             if !found_flags[i] {\n                 debug!(\"prefix=%s ee.kind=%s ee.msg=%s line=%s\",\n-                       prefixes[i], ee.kind, ee.msg, *line);\n-                if (str::starts_with(*line, prefixes[i]) &&\n-                    str::contains(*line, ee.kind) &&\n-                    str::contains(*line, ee.msg)) {\n+                       prefixes[i], ee.kind, ee.msg, line);\n+                if (str::starts_with(line, prefixes[i]) &&\n+                    str::contains(line, ee.kind) &&\n+                    str::contains(line, ee.msg)) {\n                     found_flags[i] = true;\n                     was_expected = true;\n                     break;\n@@ -364,13 +364,13 @@ fn check_expected_errors(expected_errors: ~[errors::ExpectedError],\n         }\n \n         // ignore this msg which gets printed at the end\n-        if str::contains(*line, ~\"aborting due to\") {\n+        if str::contains(line, ~\"aborting due to\") {\n             was_expected = true;\n         }\n \n-        if !was_expected && is_compiler_error_or_warning(*line) {\n+        if !was_expected && is_compiler_error_or_warning(str::from_slice(line)) {\n             fatal_ProcRes(fmt!(\"unexpected compiler error or warning: '%s'\",\n-                               *line),\n+                               line),\n                           ProcRes);\n         }\n     }"}, {"sha": "833eb7d2c77d7aee481b421bd7f3f5ea1811b706", "filename": "src/libcore/io.rs", "status": "modified", "additions": 49, "deletions": 6, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/1616ffd0c2627502b1015b6388480ed7429ef042/src%2Flibcore%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1616ffd0c2627502b1015b6388480ed7429ef042/src%2Flibcore%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fio.rs?ref=1616ffd0c2627502b1015b6388480ed7429ef042", "patch": "@@ -99,8 +99,8 @@ pub trait ReaderUtil {\n     /// Read len bytes into a new vec.\n     fn read_bytes(&self, len: uint) -> ~[u8];\n \n-    /// Read up until a specified character (which is not returned) or EOF.\n-    fn read_until(&self, c: char) -> ~str;\n+    /// Read up until a specified character (which is optionally included) or EOF.\n+    fn read_until(&self, c: char, include: bool) -> ~str;\n \n     /// Read up until the first '\\n' char (which is not returned), or EOF.\n     fn read_line(&self) -> ~str;\n@@ -126,6 +126,9 @@ pub trait ReaderUtil {\n     /// Iterate over every line until the iterator breaks or EOF.\n     fn each_line(&self, it: &fn(&str) -> bool);\n \n+    /// Read all the lines of the file into a vector.\n+    fn read_lines(&self) -> ~[~str];\n+\n     /// Read n (between 1 and 8) little-endian unsigned integer bytes.\n     fn read_le_uint_n(&self, nbytes: uint) -> u64;\n \n@@ -219,11 +222,14 @@ impl<T:Reader> ReaderUtil for T {\n         bytes\n     }\n \n-    fn read_until(&self, c: char) -> ~str {\n+    fn read_until(&self, c: char, include: bool) -> ~str {\n         let mut bytes = ~[];\n         loop {\n             let ch = self.read_byte();\n             if ch == -1 || ch == c as int {\n+                if include && ch == c as int {\n+                    bytes.push(ch as u8);\n+                }\n                 break;\n             }\n             bytes.push(ch as u8);\n@@ -232,7 +238,7 @@ impl<T:Reader> ReaderUtil for T {\n     }\n \n     fn read_line(&self) -> ~str {\n-        self.read_until('\\n')\n+        self.read_until('\\n', false)\n     }\n \n     fn read_chars(&self, n: uint) -> ~[char] {\n@@ -306,7 +312,7 @@ impl<T:Reader> ReaderUtil for T {\n     }\n \n     fn read_c_str(&self) -> ~str {\n-        self.read_until(0 as char)\n+        self.read_until(0 as char, false)\n     }\n \n     fn read_whole_stream(&self) -> ~[u8] {\n@@ -329,7 +335,29 @@ impl<T:Reader> ReaderUtil for T {\n \n     fn each_line(&self, it: &fn(s: &str) -> bool) {\n         while !self.eof() {\n-            if !it(self.read_line()) { break; }\n+            // include the \\n, so that we can distinguish an entirely empty\n+            // line read after \"...\\n\", and the trailing empty line in\n+            // \"...\\n\\n\".\n+            let mut line = self.read_until('\\n', true);\n+\n+            // blank line at the end of the reader is ignored\n+            if self.eof() && line.is_empty() { break; }\n+\n+            // trim the \\n, so that each_line is consistent with read_line\n+            let n = str::len(line);\n+            if line[n-1] == '\\n' as u8 {\n+                unsafe { str::raw::set_len(&mut line, n-1); }\n+            }\n+\n+            if !it(line) { break; }\n+        }\n+    }\n+\n+    fn read_lines(&self) -> ~[~str] {\n+        do vec::build |push| {\n+            for self.each_line |line| {\n+                push(str::from_slice(line));\n+            }\n         }\n     }\n \n@@ -1335,6 +1363,21 @@ mod tests {\n         }\n     }\n \n+    #[test]\n+    fn test_read_lines() {\n+        do io::with_str_reader(~\"a\\nb\\nc\\n\") |inp| {\n+            fail_unless!(inp.read_lines() == ~[~\"a\", ~\"b\", ~\"c\"]);\n+        }\n+\n+        do io::with_str_reader(~\"a\\nb\\nc\") |inp| {\n+            fail_unless!(inp.read_lines() == ~[~\"a\", ~\"b\", ~\"c\"]);\n+        }\n+\n+        do io::with_str_reader(~\"\") |inp| {\n+            fail_unless!(inp.read_lines().is_empty());\n+        }\n+    }\n+\n     #[test]\n     fn test_readchars_wide() {\n         let wide_test = ~\"\u751f\u9508\u7684\u6c64\u5319\u5207\u8089\u6c64hello\u751f\u9508\u7684\u6c64\u5319\u5207\u8089\u6c64\";"}, {"sha": "4cfdfabb0e712ffeceb554e2b0be70345abe9b02", "filename": "src/libcore/str.rs", "status": "modified", "additions": 92, "deletions": 26, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/1616ffd0c2627502b1015b6388480ed7429ef042/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1616ffd0c2627502b1015b6388480ed7429ef042/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=1616ffd0c2627502b1015b6388480ed7429ef042", "patch": "@@ -437,28 +437,37 @@ pub pure fn slice(s: &'a str, begin: uint, end: uint) -> &'a str {\n     unsafe { raw::slice_bytes(s, begin, end) }\n }\n \n-/// Splits a string into substrings at each occurrence of a given character\n+/// Splits a string into substrings at each occurrence of a given\n+/// character.\n pub pure fn split_char(s: &str, sep: char) -> ~[~str] {\n-    split_char_inner(s, sep, len(s), true)\n+    split_char_inner(s, sep, len(s), true, true)\n }\n \n /**\n  * Splits a string into substrings at each occurrence of a given\n- * character up to 'count' times\n+ * character up to 'count' times.\n  *\n  * The byte must be a valid UTF-8/ASCII byte\n  */\n pub pure fn splitn_char(s: &str, sep: char, count: uint) -> ~[~str] {\n-    split_char_inner(s, sep, count, true)\n+    split_char_inner(s, sep, count, true, true)\n }\n \n /// Like `split_char`, but omits empty strings from the returned vector\n pub pure fn split_char_nonempty(s: &str, sep: char) -> ~[~str] {\n-    split_char_inner(s, sep, len(s), false)\n+    split_char_inner(s, sep, len(s), false, false)\n }\n \n-pure fn split_char_inner(s: &str, sep: char, count: uint, allow_empty: bool)\n-    -> ~[~str] {\n+/**\n+ * Like `split_char`, but a trailing empty string is omitted\n+ * (e.g. `split_char_no_trailing(\"A B \",' ') == ~[~\"A\",~\"B\"]`)\n+ */\n+pub pure fn split_char_no_trailing(s: &str, sep: char) -> ~[~str] {\n+    split_char_inner(s, sep, len(s), true, false)\n+}\n+\n+pure fn split_char_inner(s: &str, sep: char, count: uint, allow_empty: bool,\n+                         allow_trailing_empty: bool) -> ~[~str] {\n     if sep < 128u as char {\n         let b = sep as u8, l = len(s);\n         let mut result = ~[], done = 0u;\n@@ -475,19 +484,20 @@ pure fn split_char_inner(s: &str, sep: char, count: uint, allow_empty: bool)\n             }\n             i += 1u;\n         }\n-        if allow_empty || start < l {\n+        // only push a non-empty trailing substring\n+        if allow_trailing_empty || start < l {\n             unsafe { result.push(raw::slice_bytes_unique(s, start, l) ) };\n         }\n         result\n     } else {\n-        splitn(s, |cur| cur == sep, count)\n+        split_inner(s, |cur| cur == sep, count, allow_empty, allow_trailing_empty)\n     }\n }\n \n \n /// Splits a string into substrings using a character function\n pub pure fn split(s: &str, sepfn: &fn(char) -> bool) -> ~[~str] {\n-    split_inner(s, sepfn, len(s), true)\n+    split_inner(s, sepfn, len(s), true, true)\n }\n \n /**\n@@ -498,16 +508,25 @@ pub pure fn splitn(s: &str,\n                    sepfn: &fn(char) -> bool,\n                    count: uint)\n                 -> ~[~str] {\n-    split_inner(s, sepfn, count, true)\n+    split_inner(s, sepfn, count, true, true)\n }\n \n /// Like `split`, but omits empty strings from the returned vector\n pub pure fn split_nonempty(s: &str, sepfn: &fn(char) -> bool) -> ~[~str] {\n-    split_inner(s, sepfn, len(s), false)\n+    split_inner(s, sepfn, len(s), false, false)\n+}\n+\n+\n+/**\n+ * Like `split`, but a trailing empty string is omitted\n+ * (e.g. `split_no_trailing(\"A B \",' ') == ~[~\"A\",~\"B\"]`)\n+ */\n+pub pure fn split_no_trailing(s: &str, sepfn: &fn(char) -> bool) -> ~[~str] {\n+    split_inner(s, sepfn, len(s), true, false)\n }\n \n pure fn split_inner(s: &str, sepfn: &fn(cc: char) -> bool, count: uint,\n-               allow_empty: bool) -> ~[~str] {\n+               allow_empty: bool, allow_trailing_empty: bool) -> ~[~str] {\n     let l = len(s);\n     let mut result = ~[], i = 0u, start = 0u, done = 0u;\n     while i < l && done < count {\n@@ -523,7 +542,7 @@ pure fn split_inner(s: &str, sepfn: &fn(cc: char) -> bool, count: uint,\n         }\n         i = next;\n     }\n-    if allow_empty || start < l {\n+    if allow_trailing_empty || start < l {\n         unsafe {\n             result.push(raw::slice_bytes_unique(s, start, l));\n         }\n@@ -630,9 +649,11 @@ pub fn levdistance(s: &str, t: &str) -> uint {\n }\n \n /**\n- * Splits a string into a vector of the substrings separated by LF ('\\n')\n+ * Splits a string into a vector of the substrings separated by LF ('\\n').\n  */\n-pub pure fn lines(s: &str) -> ~[~str] { split_char(s, '\\n') }\n+pub pure fn lines(s: &str) -> ~[~str] {\n+    split_char_no_trailing(s, '\\n')\n+}\n \n /**\n  * Splits a string into a vector of the substrings separated by LF ('\\n')\n@@ -651,7 +672,7 @@ pub pure fn lines_any(s: &str) -> ~[~str] {\n \n /// Splits a string into a vector of the substrings separated by whitespace\n pub pure fn words(s: &str) -> ~[~str] {\n-    split_nonempty(s, |c| char::is_whitespace(c))\n+    split_nonempty(s, char::is_whitespace)\n }\n \n /** Split a string into a vector of substrings,\n@@ -2669,6 +2690,35 @@ mod tests {\n \n     }\n \n+    #[test]\n+    fn test_split_char_no_trailing() {\n+     fn t(s: &str, c: char, u: &[~str]) {\n+            debug!(~\"split_byte: \" + s);\n+            let v = split_char_no_trailing(s, c);\n+            debug!(\"split_byte to: %?\", v);\n+            fail_unless!(vec::all2(v, u, |a,b| a == b));\n+        }\n+        t(~\"abc.hello.there\", '.', ~[~\"abc\", ~\"hello\", ~\"there\"]);\n+        t(~\".hello.there\", '.', ~[~\"\", ~\"hello\", ~\"there\"]);\n+        t(~\"...hello.there.\", '.', ~[~\"\", ~\"\", ~\"\", ~\"hello\", ~\"there\"]);\n+\n+        fail_unless!(~[~\"\", ~\"\", ~\"\", ~\"hello\", ~\"there\"]\n+                     == split_char_no_trailing(~\"...hello.there.\", '.'));\n+\n+        fail_unless!(~[] == split_char_no_trailing(~\"\", 'z'));\n+        fail_unless!(~[~\"\"] == split_char_no_trailing(~\"z\", 'z'));\n+        fail_unless!(~[~\"ok\"] == split_char_no_trailing(~\"ok\", 'z'));\n+    }\n+\n+    #[test]\n+    fn test_split_char_no_trailing_2() {\n+        let data = ~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n+        fail_unless!(~[~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534e\", ~\"i\u1ec7t Nam\"]\n+                     == split_char_no_trailing(data, 'V'));\n+        fail_unless!(~[~\"\u0e1b\u0e23\u0e30\u0e40\", ~\"\u0e28\u0e44\", ~\"\u0e22\u4e2d\u534eVi\u1ec7t Nam\"]\n+                     == split_char_no_trailing(data, '\u0e17'));\n+    }\n+\n     #[test]\n     fn test_split_str() {\n         fn t(s: &str, sep: &'a str, i: int, k: &str) {\n@@ -2722,28 +2772,45 @@ mod tests {\n         fail_unless!(~[~\"ok\"] == split(~\"ok\", |cc| cc == 'z'));\n     }\n \n+    #[test]\n+    fn test_split_no_trailing() {\n+        let data = ~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n+        fail_unless!(~[~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\", ~\"Vi\u1ec7t Nam\"]\n+                     == split_no_trailing (data, |cc| cc == '\u534e'));\n+\n+        fail_unless!(~[~\"\", ~\"\", ~\"XXX\", ~\"YYY\"]\n+                     == split_no_trailing(~\"zzXXXzYYYz\", char::is_lowercase));\n+\n+        fail_unless!(~[~\"zz\", ~\"\", ~\"\", ~\"z\", ~\"\", ~\"\", ~\"z\"]\n+                     == split_no_trailing(~\"zzXXXzYYYz\", char::is_uppercase));\n+\n+        fail_unless!(~[~\"\"] == split_no_trailing(~\"z\", |cc| cc == 'z'));\n+        fail_unless!(~[] == split_no_trailing(~\"\", |cc| cc == 'z'));\n+        fail_unless!(~[~\"ok\"] == split_no_trailing(~\"ok\", |cc| cc == 'z'));\n+    }\n+\n     #[test]\n     fn test_lines() {\n         let lf = ~\"\\nMary had a little lamb\\nLittle lamb\\n\";\n         let crlf = ~\"\\r\\nMary had a little lamb\\r\\nLittle lamb\\r\\n\";\n \n-        fail_unless!(~[~\"\", ~\"Mary had a little lamb\", ~\"Little lamb\", ~\"\"]\n+        fail_unless!(~[~\"\", ~\"Mary had a little lamb\", ~\"Little lamb\"]\n                      == lines(lf));\n \n-        fail_unless!(~[~\"\", ~\"Mary had a little lamb\", ~\"Little lamb\", ~\"\"]\n+        fail_unless!(~[~\"\", ~\"Mary had a little lamb\", ~\"Little lamb\"]\n                      == lines_any(lf));\n \n         fail_unless!(~[~\"\\r\", ~\"Mary had a little lamb\\r\",\n-                       ~\"Little lamb\\r\", ~\"\"]\n+                       ~\"Little lamb\\r\"]\n             == lines(crlf));\n \n-        fail_unless!(~[~\"\", ~\"Mary had a little lamb\", ~\"Little lamb\", ~\"\"]\n+        fail_unless!(~[~\"\", ~\"Mary had a little lamb\", ~\"Little lamb\"]\n             == lines_any(crlf));\n \n-        fail_unless!(~[~\"\"] == lines    (~\"\"));\n-        fail_unless!(~[~\"\"] == lines_any(~\"\"));\n-        fail_unless!(~[~\"\",~\"\"] == lines    (~\"\\n\"));\n-        fail_unless!(~[~\"\",~\"\"] == lines_any(~\"\\n\"));\n+        fail_unless!(~[] == lines    (~\"\"));\n+        fail_unless!(~[] == lines_any(~\"\"));\n+        fail_unless!(~[~\"\"] == lines    (~\"\\n\"));\n+        fail_unless!(~[~\"\"] == lines_any(~\"\\n\"));\n         fail_unless!(~[~\"banana\"] == lines    (~\"banana\"));\n         fail_unless!(~[~\"banana\"] == lines_any(~\"banana\"));\n     }\n@@ -3359,7 +3426,6 @@ mod tests {\n                 0 => fail_unless!(\"\" == x),\n                 1 => fail_unless!(\"Mary had a little lamb\" == x),\n                 2 => fail_unless!(\"Little lamb\" == x),\n-                3 => fail_unless!(\"\" == x),\n                 _ => ()\n             }\n             ii += 1;"}]}