{"sha": "63d658d87c97cecbd72b9c9cf1d96f936a8a1a06", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYzZDY1OGQ4N2M5N2NlY2JkNzJiOWM5Y2YxZDk2ZjkzNmE4YTFhMDY=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-11-05T11:07:22Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-11-16T10:57:42Z"}, "message": "extract the `tcx` out from `RegionVarBindings`", "tree": {"sha": "de1bfd55751d049e69125834a69047b55f31bb22", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/de1bfd55751d049e69125834a69047b55f31bb22"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/63d658d87c97cecbd72b9c9cf1d96f936a8a1a06", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/63d658d87c97cecbd72b9c9cf1d96f936a8a1a06", "html_url": "https://github.com/rust-lang/rust/commit/63d658d87c97cecbd72b9c9cf1d96f936a8a1a06", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/63d658d87c97cecbd72b9c9cf1d96f936a8a1a06/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "daceedf314f882f07f040a78dde173c3b12ad6bd", "url": "https://api.github.com/repos/rust-lang/rust/commits/daceedf314f882f07f040a78dde173c3b12ad6bd", "html_url": "https://github.com/rust-lang/rust/commit/daceedf314f882f07f040a78dde173c3b12ad6bd"}], "stats": {"total": 169, "additions": 89, "deletions": 80}, "files": [{"sha": "9b32c1ff385bd92cd57bbc3b5462c6a044e4a104", "filename": "src/librustc/infer/glb.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/63d658d87c97cecbd72b9c9cf1d96f936a8a1a06/src%2Flibrustc%2Finfer%2Fglb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63d658d87c97cecbd72b9c9cf1d96f936a8a1a06/src%2Flibrustc%2Finfer%2Fglb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fglb.rs?ref=63d658d87c97cecbd72b9c9cf1d96f936a8a1a06", "patch": "@@ -67,7 +67,7 @@ impl<'combine, 'infcx, 'gcx, 'tcx> TypeRelation<'infcx, 'gcx, 'tcx>\n                b);\n \n         let origin = Subtype(self.fields.trace.clone());\n-        Ok(self.fields.infcx.region_vars.glb_regions(origin, a, b))\n+        Ok(self.fields.infcx.region_vars.glb_regions(self.tcx(), origin, a, b))\n     }\n \n     fn binders<T>(&mut self, a: &ty::Binder<T>, b: &ty::Binder<T>)"}, {"sha": "bf0694976ca984135e29576f10f9d16647f62387", "filename": "src/librustc/infer/higher_ranked/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/63d658d87c97cecbd72b9c9cf1d96f936a8a1a06/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63d658d87c97cecbd72b9c9cf1d96f936a8a1a06/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs?ref=63d658d87c97cecbd72b9c9cf1d96f936a8a1a06", "patch": "@@ -427,7 +427,7 @@ impl<'a, 'gcx, 'tcx> CombineFields<'a, 'gcx, 'tcx> {\n         fn fresh_bound_variable<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n                                                 debruijn: ty::DebruijnIndex)\n                                                 -> ty::Region<'tcx> {\n-            infcx.region_vars.new_bound(debruijn)\n+            infcx.region_vars.new_bound(infcx.tcx, debruijn)\n         }\n     }\n }\n@@ -481,7 +481,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                        r: ty::Region<'tcx>,\n                        directions: TaintDirections)\n                        -> FxHashSet<ty::Region<'tcx>> {\n-        self.region_vars.tainted(&snapshot.region_vars_snapshot, r, directions)\n+        self.region_vars.tainted(self.tcx, &snapshot.region_vars_snapshot, r, directions)\n     }\n \n     fn region_vars_confined_to_snapshot(&self,\n@@ -581,7 +581,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         where T : TypeFoldable<'tcx>\n     {\n         let (result, map) = self.tcx.replace_late_bound_regions(binder, |br| {\n-            self.region_vars.push_skolemized(br, &snapshot.region_vars_snapshot)\n+            self.region_vars.push_skolemized(self.tcx, br, &snapshot.region_vars_snapshot)\n         });\n \n         debug!(\"skolemize_bound_regions(binder={:?}, result={:?}, map={:?})\",\n@@ -766,7 +766,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     {\n         debug!(\"pop_skolemized({:?})\", skol_map);\n         let skol_regions: FxHashSet<_> = skol_map.values().cloned().collect();\n-        self.region_vars.pop_skolemized(&skol_regions, &snapshot.region_vars_snapshot);\n+        self.region_vars.pop_skolemized(self.tcx, &skol_regions, &snapshot.region_vars_snapshot);\n         if !skol_map.is_empty() {\n             self.projection_cache.borrow_mut().rollback_skolemized(\n                 &snapshot.projection_cache_snapshot);"}, {"sha": "af8a2fcfc3bfb62ef509286a16c0320194ba1bb0", "filename": "src/librustc/infer/lexical_region_resolve/graphviz.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/63d658d87c97cecbd72b9c9cf1d96f936a8a1a06/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63d658d87c97cecbd72b9c9cf1d96f936a8a1a06/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fgraphviz.rs?ref=63d658d87c97cecbd72b9c9cf1d96f936a8a1a06", "patch": "@@ -57,12 +57,13 @@ graphs will be printed.                                                     \\n\\\n }\n \n pub fn maybe_print_constraints_for<'a, 'gcx, 'tcx>(\n-    region_vars: &RegionVarBindings<'a, 'gcx, 'tcx>,\n+    region_vars: &RegionVarBindings<'tcx>,\n     region_rels: &RegionRelations<'a, 'gcx, 'tcx>)\n {\n+    let tcx = region_rels.tcx;\n     let context = region_rels.context;\n \n-    if !region_vars.tcx.sess.opts.debugging_opts.print_region_graph {\n+    if !tcx.sess.opts.debugging_opts.print_region_graph {\n         return;\n     }\n \n@@ -117,7 +118,7 @@ pub fn maybe_print_constraints_for<'a, 'gcx, 'tcx>(\n         Ok(()) => {}\n         Err(e) => {\n             let msg = format!(\"io error dumping region constraints: {}\", e);\n-            region_vars.tcx.sess.err(&msg)\n+            tcx.sess.err(&msg)\n         }\n     }\n }"}, {"sha": "f15d4785da9c7f4031843fc5f9274642c2e2bd9b", "filename": "src/librustc/infer/lexical_region_resolve/mod.rs", "status": "modified", "additions": 27, "deletions": 24, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/63d658d87c97cecbd72b9c9cf1d96f936a8a1a06/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63d658d87c97cecbd72b9c9cf1d96f936a8a1a06/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fmod.rs?ref=63d658d87c97cecbd72b9c9cf1d96f936a8a1a06", "patch": "@@ -21,7 +21,7 @@ use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::graph::{self, Direction, NodeIndex, OUTGOING};\n use std::fmt;\n use std::u32;\n-use ty;\n+use ty::{self, TyCtxt};\n use ty::{Region, RegionVid};\n use ty::{ReEarlyBound, ReEmpty, ReErased, ReFree, ReStatic};\n use ty::{ReLateBound, ReScope, ReSkolemized, ReVar};\n@@ -73,15 +73,15 @@ struct RegionAndOrigin<'tcx> {\n \n type RegionGraph<'tcx> = graph::Graph<(), Constraint<'tcx>>;\n \n-impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n+impl<'tcx> RegionVarBindings<'tcx> {\n     /// This function performs the actual region resolution.  It must be\n     /// called after all constraints have been added.  It performs a\n     /// fixed-point iteration to find region values which satisfy all\n     /// constraints, assuming such values can be found; if they cannot,\n     /// errors are reported.\n     pub fn resolve_regions(\n         &self,\n-        region_rels: &RegionRelations<'a, 'gcx, 'tcx>,\n+        region_rels: &RegionRelations<'_, '_, 'tcx>,\n     ) -> (\n         LexicalRegionResolutions<'tcx>,\n         Vec<RegionResolutionError<'tcx>>,\n@@ -94,10 +94,11 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n \n     fn lub_concrete_regions(\n         &self,\n-        region_rels: &RegionRelations<'a, 'gcx, 'tcx>,\n+        region_rels: &RegionRelations<'_, '_, 'tcx>,\n         a: Region<'tcx>,\n         b: Region<'tcx>,\n     ) -> Region<'tcx> {\n+        let tcx = region_rels.tcx;\n         match (a, b) {\n             (&ReLateBound(..), _) | (_, &ReLateBound(..)) | (&ReErased, _) | (_, &ReErased) => {\n                 bug!(\"cannot relate region: LUB({:?}, {:?})\", a, b);\n@@ -130,10 +131,10 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n                 // reasonably compare free regions and scopes:\n                 let fr_scope = match (a, b) {\n                     (&ReEarlyBound(ref br), _) | (_, &ReEarlyBound(ref br)) => {\n-                        region_rels.region_scope_tree.early_free_scope(self.tcx, br)\n+                        region_rels.region_scope_tree.early_free_scope(region_rels.tcx, br)\n                     }\n                     (&ReFree(ref fr), _) | (_, &ReFree(ref fr)) => {\n-                        region_rels.region_scope_tree.free_scope(self.tcx, fr)\n+                        region_rels.region_scope_tree.free_scope(region_rels.tcx, fr)\n                     }\n                     _ => bug!(),\n                 };\n@@ -153,7 +154,7 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n \n                 // otherwise, we don't know what the free region is,\n                 // so we must conservatively say the LUB is static:\n-                self.tcx.types.re_static\n+                tcx.types.re_static\n             }\n \n             (&ReScope(a_id), &ReScope(b_id)) => {\n@@ -163,7 +164,7 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n                 let lub = region_rels\n                     .region_scope_tree\n                     .nearest_common_ancestor(a_id, b_id);\n-                self.tcx.mk_region(ReScope(lub))\n+                tcx.mk_region(ReScope(lub))\n             }\n \n             (&ReEarlyBound(_), &ReEarlyBound(_)) |\n@@ -176,17 +177,17 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n             (&ReSkolemized(..), _) | (_, &ReSkolemized(..)) => if a == b {\n                 a\n             } else {\n-                self.tcx.types.re_static\n+                tcx.types.re_static\n             },\n         }\n     }\n \n     fn infer_variable_values(\n         &self,\n-        region_rels: &RegionRelations<'a, 'gcx, 'tcx>,\n+        region_rels: &RegionRelations<'_, '_, 'tcx>,\n         errors: &mut Vec<RegionResolutionError<'tcx>>,\n     ) -> LexicalRegionResolutions<'tcx> {\n-        let mut var_data = self.construct_var_data();\n+        let mut var_data = self.construct_var_data(region_rels.tcx);\n \n         // Dorky hack to cause `dump_constraints` to only get called\n         // if debug mode is enabled:\n@@ -205,16 +206,18 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n         var_data\n     }\n \n-    fn construct_var_data(&self) -> LexicalRegionResolutions<'tcx> {\n+    /// Initially, the value for all variables is set to `'empty`, the\n+    /// empty region. The `expansion` phase will grow this larger.\n+    fn construct_var_data(&self, tcx: TyCtxt<'_, '_, 'tcx>) -> LexicalRegionResolutions<'tcx> {\n         LexicalRegionResolutions {\n-            error_region: self.tcx.types.re_static,\n+            error_region: tcx.types.re_static,\n             values: (0..self.num_vars() as usize)\n-                .map(|_| VarValue::Value(self.tcx.types.re_empty))\n+                .map(|_| VarValue::Value(tcx.types.re_empty))\n                 .collect(),\n         }\n     }\n \n-    fn dump_constraints(&self, free_regions: &RegionRelations<'a, 'gcx, 'tcx>) {\n+    fn dump_constraints(&self, free_regions: &RegionRelations<'_, '_, 'tcx>) {\n         debug!(\n             \"----() Start constraint listing (context={:?}) ()----\",\n             free_regions.context\n@@ -251,7 +254,7 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n \n     fn expansion(\n         &self,\n-        region_rels: &RegionRelations<'a, 'gcx, 'tcx>,\n+        region_rels: &RegionRelations<'_, '_, 'tcx>,\n         var_values: &mut LexicalRegionResolutions<'tcx>,\n     ) {\n         self.iterate_until_fixed_point(\"Expansion\", |constraint, origin| {\n@@ -279,7 +282,7 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n \n     fn expand_node(\n         &self,\n-        region_rels: &RegionRelations<'a, 'gcx, 'tcx>,\n+        region_rels: &RegionRelations<'_, '_, 'tcx>,\n         a_region: Region<'tcx>,\n         b_vid: RegionVid,\n         b_data: &mut VarValue<'tcx>,\n@@ -326,7 +329,7 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n     /// and check that they are satisfied.\n     fn collect_errors(\n         &self,\n-        region_rels: &RegionRelations<'a, 'gcx, 'tcx>,\n+        region_rels: &RegionRelations<'_, '_, 'tcx>,\n         var_data: &mut LexicalRegionResolutions<'tcx>,\n         errors: &mut Vec<RegionResolutionError<'tcx>>,\n     ) {\n@@ -423,7 +426,7 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n     /// and create a `RegionResolutionError` for each of them.\n     fn collect_var_errors(\n         &self,\n-        region_rels: &RegionRelations<'a, 'gcx, 'tcx>,\n+        region_rels: &RegionRelations<'_, '_, 'tcx>,\n         var_data: &LexicalRegionResolutions<'tcx>,\n         graph: &RegionGraph<'tcx>,\n         errors: &mut Vec<RegionResolutionError<'tcx>>,\n@@ -528,7 +531,7 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n \n     fn collect_error_for_expanding_node(\n         &self,\n-        region_rels: &RegionRelations<'a, 'gcx, 'tcx>,\n+        region_rels: &RegionRelations<'_, '_, 'tcx>,\n         graph: &RegionGraph<'tcx>,\n         dup_vec: &mut [u32],\n         node_idx: RegionVid,\n@@ -642,8 +645,8 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n         } = state;\n         return (result, dup_found);\n \n-        fn process_edges<'a, 'gcx, 'tcx>(\n-            this: &RegionVarBindings<'a, 'gcx, 'tcx>,\n+        fn process_edges<'tcx>(\n+            this: &RegionVarBindings<'tcx>,\n             state: &mut WalkState<'tcx>,\n             graph: &RegionGraph<'tcx>,\n             source_vid: RegionVid,\n@@ -710,10 +713,10 @@ impl<'tcx> fmt::Debug for RegionAndOrigin<'tcx> {\n }\n \n \n-impl<'a, 'gcx, 'tcx> VerifyBound<'tcx> {\n+impl<'tcx> VerifyBound<'tcx> {\n     fn is_met(\n         &self,\n-        region_rels: &RegionRelations<'a, 'gcx, 'tcx>,\n+        region_rels: &RegionRelations<'_, '_, 'tcx>,\n         var_values: &LexicalRegionResolutions<'tcx>,\n         min: ty::Region<'tcx>,\n     ) -> bool {"}, {"sha": "68cecf216d8a7334963791a01a85f976525db0cd", "filename": "src/librustc/infer/lub.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/63d658d87c97cecbd72b9c9cf1d96f936a8a1a06/src%2Flibrustc%2Finfer%2Flub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63d658d87c97cecbd72b9c9cf1d96f936a8a1a06/src%2Flibrustc%2Finfer%2Flub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Flub.rs?ref=63d658d87c97cecbd72b9c9cf1d96f936a8a1a06", "patch": "@@ -67,7 +67,7 @@ impl<'combine, 'infcx, 'gcx, 'tcx> TypeRelation<'infcx, 'gcx, 'tcx>\n                b);\n \n         let origin = Subtype(self.fields.trace.clone());\n-        Ok(self.fields.infcx.region_vars.lub_regions(origin, a, b))\n+        Ok(self.fields.infcx.region_vars.lub_regions(self.tcx(), origin, a, b))\n     }\n \n     fn binders<T>(&mut self, a: &ty::Binder<T>, b: &ty::Binder<T>)"}, {"sha": "b176646ac5fb32c003afc3b3bd4c3b25a5cb04b4", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/63d658d87c97cecbd72b9c9cf1d96f936a8a1a06/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63d658d87c97cecbd72b9c9cf1d96f936a8a1a06/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=63d658d87c97cecbd72b9c9cf1d96f936a8a1a06", "patch": "@@ -104,7 +104,7 @@ pub struct InferCtxt<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     float_unification_table: RefCell<UnificationTable<ty::FloatVid>>,\n \n     // For region variables.\n-    region_vars: RegionVarBindings<'a, 'gcx, 'tcx>,\n+    region_vars: RegionVarBindings<'tcx>,\n \n     // Once region inference is done, the values for each variable.\n     lexical_region_resolutions: RefCell<Option<LexicalRegionResolutions<'tcx>>>,\n@@ -424,7 +424,7 @@ impl<'a, 'gcx, 'tcx> InferCtxtBuilder<'a, 'gcx, 'tcx> {\n             type_variables: RefCell::new(type_variable::TypeVariableTable::new()),\n             int_unification_table: RefCell::new(UnificationTable::new()),\n             float_unification_table: RefCell::new(UnificationTable::new()),\n-            region_vars: RegionVarBindings::new(tcx),\n+            region_vars: RegionVarBindings::new(),\n             lexical_region_resolutions: RefCell::new(None),\n             selection_cache: traits::SelectionCache::new(),\n             evaluation_cache: traits::EvaluationCache::new(),\n@@ -1087,10 +1087,6 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         })\n     }\n \n-    pub fn fresh_bound_region(&self, debruijn: ty::DebruijnIndex) -> ty::Region<'tcx> {\n-        self.region_vars.new_bound(debruijn)\n-    }\n-\n     /// True if errors have been reported since this infcx was\n     /// created.  This is sometimes used as a heuristic to skip\n     /// reporting errors that often occur as a result of earlier"}, {"sha": "93360706149b03ae18067ce0bbbde54ba0c7e8f0", "filename": "src/librustc/infer/region_inference/mod.rs", "status": "modified", "additions": 46, "deletions": 38, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/63d658d87c97cecbd72b9c9cf1d96f936a8a1a06/src%2Flibrustc%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63d658d87c97cecbd72b9c9cf1d96f936a8a1a06/src%2Flibrustc%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fregion_inference%2Fmod.rs?ref=63d658d87c97cecbd72b9c9cf1d96f936a8a1a06", "patch": "@@ -144,8 +144,7 @@ enum CombineMapType {\n \n type CombineMap<'tcx> = FxHashMap<TwoRegions<'tcx>, RegionVid>;\n \n-pub struct RegionVarBindings<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n-    pub(in infer) tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+pub struct RegionVarBindings<'tcx> {\n     pub(in infer) var_origins: RefCell<Vec<RegionVariableOrigin>>,\n \n     /// Constraints of the form `A <= B` introduced by the region\n@@ -244,10 +243,9 @@ impl TaintDirections {\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n-    pub fn new(tcx: TyCtxt<'a, 'gcx, 'tcx>) -> RegionVarBindings<'a, 'gcx, 'tcx> {\n+impl<'tcx> RegionVarBindings<'tcx> {\n+    pub fn new() -> RegionVarBindings<'tcx> {\n         RegionVarBindings {\n-            tcx,\n             var_origins: RefCell::new(Vec::new()),\n             constraints: RefCell::new(BTreeMap::new()),\n             verifys: RefCell::new(Vec::new()),\n@@ -397,21 +395,30 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n     /// The `snapshot` argument to this function is not really used;\n     /// it's just there to make it explicit which snapshot bounds the\n     /// skolemized region that results. It should always be the top-most snapshot.\n-    pub fn push_skolemized(&self, br: ty::BoundRegion, snapshot: &RegionSnapshot) -> Region<'tcx> {\n+    pub fn push_skolemized(\n+        &self,\n+        tcx: TyCtxt<'_, '_, 'tcx>,\n+        br: ty::BoundRegion,\n+        snapshot: &RegionSnapshot,\n+    ) -> Region<'tcx> {\n         assert!(self.in_snapshot());\n         assert!(self.undo_log.borrow()[snapshot.length] == OpenSnapshot);\n \n         let sc = self.skolemization_count.get();\n         self.skolemization_count.set(sc + 1);\n-        self.tcx\n-            .mk_region(ReSkolemized(ty::SkolemizedRegionVid { index: sc }, br))\n+        tcx.mk_region(ReSkolemized(ty::SkolemizedRegionVid { index: sc }, br))\n     }\n \n     /// Removes all the edges to/from the skolemized regions that are\n     /// in `skols`. This is used after a higher-ranked operation\n     /// completes to remove all trace of the skolemized regions\n     /// created in that time.\n-    pub fn pop_skolemized(&self, skols: &FxHashSet<ty::Region<'tcx>>, snapshot: &RegionSnapshot) {\n+    pub fn pop_skolemized(\n+        &self,\n+        _tcx: TyCtxt<'_, '_, 'tcx>,\n+        skols: &FxHashSet<ty::Region<'tcx>>,\n+        snapshot: &RegionSnapshot,\n+    ) {\n         debug!(\"pop_skolemized_regions(skols={:?})\", skols);\n \n         assert!(self.in_snapshot());\n@@ -489,7 +496,11 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    pub fn new_bound(&self, debruijn: ty::DebruijnIndex) -> Region<'tcx> {\n+    pub fn new_bound(\n+        &self,\n+        tcx: TyCtxt<'_, '_, 'tcx>,\n+        debruijn: ty::DebruijnIndex,\n+    ) -> Region<'tcx> {\n         // Creates a fresh bound variable for use in GLB computations.\n         // See discussion of GLB computation in the large comment at\n         // the top of this file for more details.\n@@ -515,7 +526,7 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n             bug!(\"rollover in RegionInference new_bound()\");\n         }\n \n-        self.tcx.mk_region(ReLateBound(debruijn, BrFresh(sc)))\n+        tcx.mk_region(ReLateBound(debruijn, BrFresh(sc)))\n     }\n \n     fn add_constraint(&self, constraint: Constraint<'tcx>, origin: SubregionOrigin<'tcx>) {\n@@ -643,6 +654,7 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n \n     pub fn lub_regions(\n         &self,\n+        tcx: TyCtxt<'_, '_, 'tcx>,\n         origin: SubregionOrigin<'tcx>,\n         a: Region<'tcx>,\n         b: Region<'tcx>,\n@@ -658,18 +670,13 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n                 a // LUB(a,a) = a\n             }\n \n-            _ => self.combine_vars(\n-                Lub,\n-                a,\n-                b,\n-                origin.clone(),\n-                |this, old_r, new_r| this.make_subregion(origin.clone(), old_r, new_r),\n-            ),\n+            _ => self.combine_vars(tcx, Lub, a, b, origin.clone()),\n         }\n     }\n \n     pub fn glb_regions(\n         &self,\n+        tcx: TyCtxt<'_, '_, 'tcx>,\n         origin: SubregionOrigin<'tcx>,\n         a: Region<'tcx>,\n         b: Region<'tcx>,\n@@ -685,19 +692,17 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n                 a // GLB(a,a) = a\n             }\n \n-            _ => self.combine_vars(\n-                Glb,\n-                a,\n-                b,\n-                origin.clone(),\n-                |this, old_r, new_r| this.make_subregion(origin.clone(), new_r, old_r),\n-            ),\n+            _ => self.combine_vars(tcx, Glb, a, b, origin.clone()),\n         }\n     }\n \n-    pub fn opportunistic_resolve_var(&self, rid: RegionVid) -> ty::Region<'tcx> {\n+    pub fn opportunistic_resolve_var(\n+        &self,\n+        tcx: TyCtxt<'_, '_, 'tcx>,\n+        rid: RegionVid,\n+    ) -> ty::Region<'tcx> {\n         let vid = self.unification_table.borrow_mut().find_value(rid).min_vid;\n-        self.tcx.mk_region(ty::ReVar(vid))\n+        tcx.mk_region(ty::ReVar(vid))\n     }\n \n     fn combine_map(&self, t: CombineMapType) -> &RefCell<CombineMap<'tcx>> {\n@@ -707,30 +712,32 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    fn combine_vars<F>(\n+    fn combine_vars(\n         &self,\n+        tcx: TyCtxt<'_, '_, 'tcx>,\n         t: CombineMapType,\n         a: Region<'tcx>,\n         b: Region<'tcx>,\n         origin: SubregionOrigin<'tcx>,\n-        mut relate: F,\n-    ) -> Region<'tcx>\n-    where\n-        F: FnMut(&RegionVarBindings<'a, 'gcx, 'tcx>, Region<'tcx>, Region<'tcx>),\n-    {\n+    ) -> Region<'tcx> {\n         let vars = TwoRegions { a: a, b: b };\n         if let Some(&c) = self.combine_map(t).borrow().get(&vars) {\n-            return self.tcx.mk_region(ReVar(c));\n+            return tcx.mk_region(ReVar(c));\n         }\n         let c = self.new_region_var(MiscVariable(origin.span()));\n         self.combine_map(t).borrow_mut().insert(vars, c);\n         if self.in_snapshot() {\n             self.undo_log.borrow_mut().push(AddCombination(t, vars));\n         }\n-        relate(self, a, self.tcx.mk_region(ReVar(c)));\n-        relate(self, b, self.tcx.mk_region(ReVar(c)));\n+        let new_r = tcx.mk_region(ReVar(c));\n+        for &old_r in &[a, b] {\n+            match t {\n+                Glb => self.make_subregion(origin.clone(), new_r, old_r),\n+                Lub => self.make_subregion(origin.clone(), old_r, new_r),\n+            }\n+        }\n         debug!(\"combine_vars() c={:?}\", c);\n-        self.tcx.mk_region(ReVar(c))\n+        new_r\n     }\n \n     pub fn vars_created_since_snapshot(&self, mark: &RegionSnapshot) -> Vec<RegionVid> {\n@@ -753,6 +760,7 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n     /// related to other regions.\n     pub fn tainted(\n         &self,\n+        tcx: TyCtxt<'_, '_, 'tcx>,\n         mark: &RegionSnapshot,\n         r0: Region<'tcx>,\n         directions: TaintDirections,\n@@ -769,7 +777,7 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n         // is not a terribly efficient implementation.\n         let mut taint_set = taint::TaintSet::new(directions, r0);\n         taint_set.fixed_point(\n-            self.tcx,\n+            tcx,\n             &self.undo_log.borrow()[mark.length..],\n             &self.verifys.borrow(),\n         );"}, {"sha": "ee45f7bd82801afcebbb0298476458881b0c6a8d", "filename": "src/librustc/infer/region_inference/taint.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/63d658d87c97cecbd72b9c9cf1d96f936a8a1a06/src%2Flibrustc%2Finfer%2Fregion_inference%2Ftaint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63d658d87c97cecbd72b9c9cf1d96f936a8a1a06/src%2Flibrustc%2Finfer%2Fregion_inference%2Ftaint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fregion_inference%2Ftaint.rs?ref=63d658d87c97cecbd72b9c9cf1d96f936a8a1a06", "patch": "@@ -16,7 +16,7 @@ pub(super) struct TaintSet<'tcx> {\n     regions: FxHashSet<ty::Region<'tcx>>\n }\n \n-impl<'a, 'gcx, 'tcx> TaintSet<'tcx> {\n+impl<'tcx> TaintSet<'tcx> {\n     pub(super) fn new(directions: TaintDirections,\n                       initial_region: ty::Region<'tcx>)\n                       -> Self {\n@@ -26,7 +26,7 @@ impl<'a, 'gcx, 'tcx> TaintSet<'tcx> {\n     }\n \n     pub(super) fn fixed_point(&mut self,\n-                              tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+                              tcx: TyCtxt<'_, '_, 'tcx>,\n                               undo_log: &[UndoLogEntry<'tcx>],\n                               verifys: &[Verify<'tcx>]) {\n         let mut prev_len = 0;"}, {"sha": "b9501773e02b9ceafb3b732db031b6f5c44a4350", "filename": "src/librustc/infer/resolve.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/63d658d87c97cecbd72b9c9cf1d96f936a8a1a06/src%2Flibrustc%2Finfer%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63d658d87c97cecbd72b9c9cf1d96f936a8a1a06/src%2Flibrustc%2Finfer%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fresolve.rs?ref=63d658d87c97cecbd72b9c9cf1d96f936a8a1a06", "patch": "@@ -74,7 +74,7 @@ impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for OpportunisticTypeAndRegionResolv\n \n     fn fold_region(&mut self, r: ty::Region<'tcx>) -> ty::Region<'tcx> {\n         match *r {\n-            ty::ReVar(rid) => self.infcx.region_vars.opportunistic_resolve_var(rid),\n+            ty::ReVar(rid) => self.infcx.region_vars.opportunistic_resolve_var(self.tcx(), rid),\n             _ => r,\n         }\n     }"}, {"sha": "66113ffef3d65b751ceb886504d703d9d2792653", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/63d658d87c97cecbd72b9c9cf1d96f936a8a1a06/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63d658d87c97cecbd72b9c9cf1d96f936a8a1a06/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=63d658d87c97cecbd72b9c9cf1d96f936a8a1a06", "patch": "@@ -58,6 +58,7 @@\n #![feature(slice_patterns)]\n #![feature(specialization)]\n #![feature(unboxed_closures)]\n+#![feature(underscore_lifetimes)]\n #![feature(trace_macros)]\n #![feature(test)]\n #![feature(const_atomic_bool_new)]"}]}