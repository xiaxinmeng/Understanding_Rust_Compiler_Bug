{"sha": "4779d2b392bf1d721eccbcac00d1ab1708a8faa1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ3NzlkMmIzOTJiZjFkNzIxZWNjYmNhYzAwZDFhYjE3MDhhOGZhYTE=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2012-08-03T00:17:31Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2012-08-03T01:06:33Z"}, "message": "De-duplicate core::hash some, refactor the traits.", "tree": {"sha": "4a0ce2e208ab2f7d6e18575cb6d129c250e4f451", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4a0ce2e208ab2f7d6e18575cb6d129c250e4f451"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4779d2b392bf1d721eccbcac00d1ab1708a8faa1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4779d2b392bf1d721eccbcac00d1ab1708a8faa1", "html_url": "https://github.com/rust-lang/rust/commit/4779d2b392bf1d721eccbcac00d1ab1708a8faa1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4779d2b392bf1d721eccbcac00d1ab1708a8faa1/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "009352101d129fe782d2abc18a61d064ebc245a1", "url": "https://api.github.com/repos/rust-lang/rust/commits/009352101d129fe782d2abc18a61d064ebc245a1", "html_url": "https://github.com/rust-lang/rust/commit/009352101d129fe782d2abc18a61d064ebc245a1"}], "stats": {"total": 425, "additions": 216, "deletions": 209}, "files": [{"sha": "d261d537235d39523d3acce17f92d64541feecd6", "filename": "src/libcore/hash.rs", "status": "modified", "additions": 198, "deletions": 190, "changes": 388, "blob_url": "https://github.com/rust-lang/rust/blob/4779d2b392bf1d721eccbcac00d1ab1708a8faa1/src%2Flibcore%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4779d2b392bf1d721eccbcac00d1ab1708a8faa1/src%2Flibcore%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhash.rs?ref=4779d2b392bf1d721eccbcac00d1ab1708a8faa1", "patch": "@@ -9,172 +9,178 @@\n  * CPRNG like rand::rng.\n  */\n \n-pure fn hash_bytes(buf: &[const u8]) -> u64 {\n-    return hash_bytes_keyed(buf, 0u64, 0u64);\n+import io::writer;\n+import io::writer_util;\n+\n+export Streaming, State;\n+export default_state;\n+export hash_bytes_keyed;\n+export hash_str_keyed;\n+export hash_u64_keyed;\n+export hash_u32_keyed;\n+export hash_u16_keyed;\n+export hash_u8_keyed;\n+export hash_uint_keyed;\n+export hash_bytes;\n+export hash_str;\n+export hash_u64;\n+export hash_u32;\n+export hash_u16;\n+export hash_u8;\n+export hash_uint;\n+\n+/// Streaming hash-functions should implement this.\n+trait Streaming {\n+    fn input((&[const u8]));\n+    // These can be refactored some when we have default methods.\n+    fn result_bytes() -> ~[u8];\n+    fn result_str() -> ~str;\n+    fn result_u64() -> u64;\n+    fn reset();\n }\n \n-pure fn hash_u64(val: u64) -> u64 {\n-    let bytes: [u8]/8 = // Explicitly say 8 bytes to be mistaken-change-proof.\n-        [(val >> 00) as u8,\n-         (val >> 08) as u8,\n-         (val >> 16) as u8,\n-         (val >> 24) as u8,\n-         (val >> 32) as u8,\n-         (val >> 40) as u8,\n-         (val >> 48) as u8,\n-         (val >> 56) as u8];\n-    hash_bytes(bytes)\n+fn keyed(k0: u64, k1: u64, f: fn(s: &State)) -> u64 {\n+    let s = &State(k0, k1);\n+    f(s);\n+    s.result_u64()\n }\n \n-pure fn hash_u32(val: u32) -> u64 {\n-    let bytes: [u8]/4 = // Explicitly say 4 bytes to be mistaken-change-proof.\n-        [(val >> 00) as u8,\n-         (val >> 08) as u8,\n-         (val >> 16) as u8,\n-         (val >> 24) as u8];\n-    hash_bytes(bytes)\n+pure fn hash_bytes_keyed(buf: &[const u8], k0: u64, k1: u64) -> u64 {\n+    unchecked { keyed(k0, k1, |s| s.input(buf)) }\n }\n-\n-#[cfg(target_arch = \"arm\")]\n-pure fn hash_uint(val: uint) -> u64 {\n-    assert sys::size_of::<uint>() == sys::size_of::<u32>();\n-    hash_u32(val as u32)\n+pure fn hash_str_keyed(s: &str, k0: u64, k1: u64) -> u64 {\n+    unsafe {\n+        do str::as_buf(s) |buf, len| {\n+            do vec::unsafe::form_slice(buf, len) |slice| {\n+                hash_bytes_keyed(slice, k0, k1)\n+            }\n+        }\n+    }\n }\n-#[cfg(target_arch = \"x86_64\")]\n-pure fn hash_uint(val: uint) -> u64 {\n-    assert sys::size_of::<uint>() == sys::size_of::<u64>();\n-    hash_u64(val as u64)\n+pure fn hash_u64_keyed(val: u64, k0: u64, k1: u64) -> u64 {\n+    unchecked { keyed(k0, k1, |s| s.write_le_u64(val)) }\n }\n-#[cfg(target_arch = \"x86\")]\n-pure fn hash_uint(val: uint) -> u64 {\n-    assert sys::size_of::<uint>() == sys::size_of::<u32>();\n-    hash_u32(val as u32)\n+pure fn hash_u32_keyed(val: u32, k0: u64, k1: u64) -> u64 {\n+    unchecked { keyed(k0, k1, |s| s.write_le_u32(val)) }\n+}\n+pure fn hash_u16_keyed(val: u16, k0: u64, k1: u64) -> u64 {\n+    unchecked { keyed(k0, k1, |s| s.write_le_u16(val)) }\n+}\n+pure fn hash_u8_keyed(val: u8, k0: u64, k1: u64) -> u64 {\n+    unchecked { keyed(k0, k1, |s| s.write_u8(val)) }\n+}\n+pure fn hash_uint_keyed(val: uint, k0: u64, k1: u64) -> u64 {\n+    unchecked { keyed(k0, k1, |s| s.write_le_uint(val)) }\n }\n \n-pure fn hash_bytes_keyed(buf: &[const u8], k0: u64, k1: u64) -> u64 {\n-\n-    let mut v0 : u64 = k0 ^ 0x736f_6d65_7073_6575;\n-    let mut v1 : u64 = k1 ^ 0x646f_7261_6e64_6f6d;\n-    let mut v2 : u64 = k0 ^ 0x6c79_6765_6e65_7261;\n-    let mut v3 : u64 = k1 ^ 0x7465_6462_7974_6573;\n-\n-    #macro[[#u8to64_le(buf,i),\n-            (buf[0+i] as u64 |\n-             buf[1+i] as u64 << 8 |\n-             buf[2+i] as u64 << 16 |\n-             buf[3+i] as u64 << 24 |\n-             buf[4+i] as u64 << 32 |\n-             buf[5+i] as u64 << 40 |\n-             buf[6+i] as u64 << 48 |\n-             buf[7+i] as u64 << 56)]];\n-\n-    #macro[[#rotl(x,b), (x << b) | (x >> (64 - b))]];\n-\n-    #macro[[#compress(v0,v1,v2,v3), {\n-        v0 += v1; v1 = #rotl(v1, 13); v1 ^= v0; v0 = #rotl(v0, 32);\n-        v2 += v3; v3 = #rotl(v3, 16); v3 ^= v2;\n-        v0 += v3; v3 = #rotl(v3, 21); v3 ^= v0;\n-        v2 += v1; v1 = #rotl(v1, 17); v1 ^= v2; v2 = #rotl(v2, 32);\n-    }]];\n-\n-    let len = vec::len(buf);\n-    let end = len & (!0x7);\n-    let left = len & 0x7;\n-\n-    let mut i = 0;\n-    while i < end {\n-        let m = u8to64_le!{buf, i};\n-        v3 ^= m;\n-        compress!{v0,v1,v2,v3};\n-        compress!{v0,v1,v2,v3};\n-        v0 ^= m;\n-        i += 8;\n-    }\n+pure fn hash_bytes(val: &[const u8]) -> u64 { hash_bytes_keyed(val, 0, 0) }\n+pure fn hash_str(val: &str) -> u64 { hash_str_keyed(val, 0, 0) }\n+pure fn hash_u64(val: u64) -> u64 { hash_u64_keyed(val, 0, 0) }\n+pure fn hash_u32(val: u32) -> u64 { hash_u32_keyed(val, 0, 0) }\n+pure fn hash_u16(val: u16) -> u64 { hash_u16_keyed(val, 0, 0) }\n+pure fn hash_u8(val: u8) -> u64 { hash_u8_keyed(val, 0, 0) }\n+pure fn hash_uint(val: uint) -> u64 { hash_uint_keyed(val, 0, 0) }\n \n-    let mut b : u64 = (len as u64 & 0xff) << 56;\n \n-    if left > 0 { b |= buf[i] as u64; }\n-    if left > 1 { b |= buf[i + 1] as u64 << 8; }\n-    if left > 2 { b |= buf[i + 2] as u64 << 16; }\n-    if left > 3 { b |= buf[i + 3] as u64 << 24; }\n-    if left > 4 { b |= buf[i + 4] as u64 << 32; }\n-    if left > 5 { b |= buf[i + 5] as u64 << 40; }\n-    if left > 6 { b |= buf[i + 6] as u64 << 48; }\n+// Implement State as SipState\n \n-    v3 ^= b;\n-    compress!{v0,v1,v2,v3};\n-    compress!{v0,v1,v2,v3};\n-    v0 ^= b;\n+type State = SipState;\n+fn State(k0: u64, k1: u64) -> State {\n+    SipState(k0, k1)\n+}\n \n-    v2 ^= 0xff;\n+fn default_state() -> State {\n+    State(0,0)\n+}\n \n-    compress!{v0,v1,v2,v3};\n-    compress!{v0,v1,v2,v3};\n-    compress!{v0,v1,v2,v3};\n-    compress!{v0,v1,v2,v3};\n+struct SipState {\n+    k0: u64;\n+    k1: u64;\n+    mut length: uint; // how many bytes we've processed\n+    mut v0: u64;      // hash state\n+    mut v1: u64;\n+    mut v2: u64;\n+    mut v3: u64;\n+    tail: [mut u8]/8; // unprocessed bytes\n+    mut ntail: uint;  // how many bytes in tail are valid\n+}\n \n-    return v0 ^ v1 ^ v2 ^ v3;\n+fn SipState(key0: u64, key1: u64) -> SipState {\n+    let state = SipState {\n+        k0 : key0,\n+        k1 : key1,\n+        mut length : 0u,\n+        mut v0 : 0u64,\n+        mut v1 : 0u64,\n+        mut v2 : 0u64,\n+        mut v3 : 0u64,\n+        tail : [mut 0u8,0,0,0,0,0,0,0],\n+        mut ntail : 0u,\n+    };\n+    (&state).reset();\n+    return state;\n }\n \n \n-trait streaming {\n-    fn input(~[u8]);\n-    fn input_str(~str);\n-    fn result() -> ~[u8];\n-    fn result_str() -> ~str;\n-    fn reset();\n-}\n+impl &SipState : io::writer {\n \n-fn siphash(key0 : u64, key1 : u64) -> streaming {\n-    type sipstate = {\n-        k0 : u64,\n-        k1 : u64,\n-        mut length : uint, // how many bytes we've processed\n-        mut v0 : u64,      // hash state\n-        mut v1 : u64,\n-        mut v2 : u64,\n-        mut v3 : u64,\n-        tail : ~[mut u8]/8, // unprocessed bytes\n-        mut ntail : uint,   //  how many bytes in tail are valid\n-    };\n+    // Methods for io::writer\n+    fn write(msg: &[const u8]) {\n+\n+        #macro[[#u8to64_le(buf,i),\n+                (buf[0+i] as u64 |\n+                 buf[1+i] as u64 << 8 |\n+                 buf[2+i] as u64 << 16 |\n+                 buf[3+i] as u64 << 24 |\n+                 buf[4+i] as u64 << 32 |\n+                 buf[5+i] as u64 << 40 |\n+                 buf[6+i] as u64 << 48 |\n+                 buf[7+i] as u64 << 56)]];\n+\n+        #macro[[#rotl(x,b), (x << b) | (x >> (64 - b))]];\n \n-    fn add_input(st : sipstate, msg : ~[u8]) {\n-        let length = vec::len(msg);\n-        st.length += length;\n+        #macro[[#compress(v0,v1,v2,v3), {\n+            v0 += v1; v1 = #rotl(v1, 13); v1 ^= v0; v0 = #rotl(v0, 32);\n+            v2 += v3; v3 = #rotl(v3, 16); v3 ^= v2;\n+            v0 += v3; v3 = #rotl(v3, 21); v3 ^= v0;\n+            v2 += v1; v1 = #rotl(v1, 17); v1 ^= v2; v2 = #rotl(v2, 32);\n+        }]];\n+\n+        let length = msg.len();\n+        self.length += length;\n \n         let mut needed = 0u;\n \n-        if st.ntail != 0 {\n-            needed = 8 - st.ntail;\n+        if self.ntail != 0 {\n+            needed = 8 - self.ntail;\n \n             if length < needed {\n-\n                 let mut t = 0;\n                 while t < length {\n-                    st.tail[st.ntail+t] = msg[t];\n+                    self.tail[self.ntail+t] = msg[t];\n                     t += 1;\n                 }\n-                st.ntail += length;\n-\n+                self.ntail += length;\n                 return;\n             }\n \n             let mut t = 0;\n             while t < needed {\n-                st.tail[st.ntail+t] = msg[t];\n+                self.tail[self.ntail+t] = msg[t];\n                 t += 1;\n             }\n \n-            let m = u8to64_le!{st.tail, 0};\n+            let m = u8to64_le!{self.tail, 0};\n \n-            st.v3 ^= m;\n-            compress!{st.v0, st.v1, st.v2, st.v3};\n-            compress!{st.v0, st.v1, st.v2, st.v3};\n-            st.v0 ^= m;\n+            self.v3 ^= m;\n+            compress!{self.v0, self.v1, self.v2, self.v3};\n+            compress!{self.v0, self.v1, self.v2, self.v3};\n+            self.v0 ^= m;\n \n-            st.ntail = 0;\n+            self.ntail = 0;\n         }\n \n+        // Buffered tail is now flushed, process new input.\n         let len = length - needed;\n         let end = len & (!0x7);\n         let left = len & 0x7;\n@@ -183,38 +189,57 @@ fn siphash(key0 : u64, key1 : u64) -> streaming {\n         while i < end {\n             let mi = u8to64_le!{msg, i};\n \n-            st.v3 ^= mi;\n-            compress!{st.v0, st.v1, st.v2, st.v3};\n-            compress!{st.v0, st.v1, st.v2, st.v3};\n-            st.v0 ^= mi;\n+            self.v3 ^= mi;\n+            compress!{self.v0, self.v1, self.v2, self.v3};\n+            compress!{self.v0, self.v1, self.v2, self.v3};\n+            self.v0 ^= mi;\n \n             i += 8;\n         }\n \n         let mut t = 0u;\n         while t < left {\n-            st.tail[t] = msg[i+t];\n+            self.tail[t] = msg[i+t];\n             t += 1\n         }\n-        st.ntail = left;\n+        self.ntail = left;\n     }\n \n-    fn mk_result(st : sipstate) -> ~[u8] {\n+    fn seek(_x: int, _s: io::seek_style) {\n+        fail;\n+    }\n+    fn tell() -> uint {\n+        self.length\n+    }\n+    fn flush() -> int {\n+        0\n+    }\n+    fn get_type() -> io::writer_type {\n+        io::file\n+    }\n+}\n+\n+impl &SipState : Streaming {\n+\n+    fn input(buf: &[const u8]) {\n+        self.write(buf);\n+    }\n \n-        let mut v0 = st.v0;\n-        let mut v1 = st.v1;\n-        let mut v2 = st.v2;\n-        let mut v3 = st.v3;\n+    fn result_u64() -> u64 {\n+        let mut v0 = self.v0;\n+        let mut v1 = self.v1;\n+        let mut v2 = self.v2;\n+        let mut v3 = self.v3;\n \n-        let mut b : u64 = (st.length as u64 & 0xff) << 56;\n+        let mut b : u64 = (self.length as u64 & 0xff) << 56;\n \n-        if st.ntail > 0 { b |= st.tail[0] as u64 <<  0; }\n-        if st.ntail > 1 { b |= st.tail[1] as u64 <<  8; }\n-        if st.ntail > 2 { b |= st.tail[2] as u64 << 16; }\n-        if st.ntail > 3 { b |= st.tail[3] as u64 << 24; }\n-        if st.ntail > 4 { b |= st.tail[4] as u64 << 32; }\n-        if st.ntail > 5 { b |= st.tail[5] as u64 << 40; }\n-        if st.ntail > 6 { b |= st.tail[6] as u64 << 48; }\n+        if self.ntail > 0 { b |= self.tail[0] as u64 <<  0; }\n+        if self.ntail > 1 { b |= self.tail[1] as u64 <<  8; }\n+        if self.ntail > 2 { b |= self.tail[2] as u64 << 16; }\n+        if self.ntail > 3 { b |= self.tail[3] as u64 << 24; }\n+        if self.ntail > 4 { b |= self.tail[4] as u64 << 32; }\n+        if self.ntail > 5 { b |= self.tail[5] as u64 << 40; }\n+        if self.ntail > 6 { b |= self.tail[6] as u64 << 48; }\n \n         v3 ^= b;\n         compress!{v0, v1, v2, v3};\n@@ -227,55 +252,38 @@ fn siphash(key0 : u64, key1 : u64) -> streaming {\n         compress!{v0, v1, v2, v3};\n         compress!{v0, v1, v2, v3};\n \n-        let h = v0 ^ v1 ^ v2 ^ v3;\n-\n-        return ~[\n-            (h >> 0) as u8,\n-            (h >> 8) as u8,\n-            (h >> 16) as u8,\n-            (h >> 24) as u8,\n-            (h >> 32) as u8,\n-            (h >> 40) as u8,\n-            (h >> 48) as u8,\n-            (h >> 56) as u8,\n-        ];\n+        return (v0 ^ v1 ^ v2 ^ v3);\n     }\n \n-   impl of streaming for sipstate {\n-        fn reset() {\n-            self.length = 0;\n-            self.v0 = self.k0 ^ 0x736f6d6570736575;\n-            self.v1 = self.k1 ^ 0x646f72616e646f6d;\n-            self.v2 = self.k0 ^ 0x6c7967656e657261;\n-            self.v3 = self.k1 ^ 0x7465646279746573;\n-            self.ntail = 0;\n-        }\n-        fn input(msg: ~[u8]) { add_input(self, msg); }\n-        fn input_str(msg: ~str) { add_input(self, str::bytes(msg)); }\n-        fn result() -> ~[u8] { return mk_result(self); }\n-        fn result_str() -> ~str {\n-            let r = mk_result(self);\n-            let mut s = ~\"\";\n-            for vec::each(r) |b| { s += uint::to_str(b as uint, 16u); }\n-            return s;\n-        }\n+\n+    fn result_bytes() -> ~[u8] {\n+        let h = self.result_u64();\n+        ~[(h >> 0) as u8,\n+          (h >> 8) as u8,\n+          (h >> 16) as u8,\n+          (h >> 24) as u8,\n+          (h >> 32) as u8,\n+          (h >> 40) as u8,\n+          (h >> 48) as u8,\n+          (h >> 56) as u8,\n+        ]\n     }\n \n-    let st = {\n-        k0 : key0,\n-        k1 : key1,\n-        mut length : 0u,\n-        mut v0 : 0u64,\n-        mut v1 : 0u64,\n-        mut v2 : 0u64,\n-        mut v3 : 0u64,\n-        tail : ~[mut 0u8,0,0,0,0,0,0,0]/8,\n-        mut ntail : 0u,\n-    };\n+    fn result_str() -> ~str {\n+        let r = self.result_bytes();\n+        let mut s = ~\"\";\n+        for vec::each(r) |b| { s += uint::to_str(b as uint, 16u); }\n+        return s;\n+    }\n \n-    let sh = st as streaming;\n-    sh.reset();\n-    return sh;\n+    fn reset() {\n+        self.length = 0;\n+        self.v0 = self.k0 ^ 0x736f6d6570736575;\n+        self.v1 = self.k1 ^ 0x646f72616e646f6d;\n+        self.v2 = self.k0 ^ 0x6c7967656e657261;\n+        self.v3 = self.k1 ^ 0x7465646279746573;\n+        self.ntail = 0;\n+    }\n }\n \n #[test]\n@@ -351,8 +359,8 @@ fn test_siphash() {\n     let k1 = 0x_0f_0e_0d_0c_0b_0a_09_08_u64;\n     let mut buf : ~[u8] = ~[];\n     let mut t = 0;\n-    let stream_inc = siphash(k0,k1);\n-    let stream_full = siphash(k0,k1);\n+    let stream_inc = &State(k0,k1);\n+    let stream_full = &State(k0,k1);\n \n     fn to_hex_str(r:[u8]/8) -> ~str {\n         let mut s = ~\"\";"}, {"sha": "0c58f425d7d94f03108d42b9858bd5a4b14b97c6", "filename": "src/libcore/str.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4779d2b392bf1d721eccbcac00d1ab1708a8faa1/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4779d2b392bf1d721eccbcac00d1ab1708a8faa1/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=4779d2b392bf1d721eccbcac00d1ab1708a8faa1", "patch": "@@ -8,6 +8,7 @@\n  */\n \n import libc::size_t;\n+import io::writer_util;\n \n export\n    // Creating a string\n@@ -665,10 +666,7 @@ pure fn le(a: &~str, b: &~str) -> bool { *a <= *b }\n \n /// String hash function\n pure fn hash(s: &~str) -> uint {\n-    let x = do as_bytes(*s) |bytes| {\n-        hash::hash_bytes(bytes)\n-    };\n-    return x as uint;\n+    hash::hash_str(*s) as uint\n }\n \n /*"}, {"sha": "c92653c8ba686d25b09a23e22d7e029356fd36cc", "filename": "src/rustc/back/link.rs", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/4779d2b392bf1d721eccbcac00d1ab1708a8faa1/src%2Frustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4779d2b392bf1d721eccbcac00d1ab1708a8faa1/src%2Frustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fback%2Flink.rs?ref=4779d2b392bf1d721eccbcac00d1ab1708a8faa1", "patch": "@@ -15,6 +15,7 @@ import lib::llvm::{ModuleRef, mk_pass_manager, mk_target_data, True, False,\n         FileType};\n import metadata::filesearch;\n import syntax::ast_map::{path, path_mod, path_name};\n+import io::{writer, writer_util};\n \n enum output_type {\n     output_type_none,\n@@ -307,7 +308,7 @@ mod write {\n  */\n \n fn build_link_meta(sess: session, c: ast::crate, output: ~str,\n-                   symbol_hasher: hash::streaming) -> link_meta {\n+                   symbol_hasher: &hash::State) -> link_meta {\n \n     type provided_metas =\n         {name: option<@~str>,\n@@ -338,7 +339,7 @@ fn build_link_meta(sess: session, c: ast::crate, output: ~str,\n     }\n \n     // This calculates CMH as defined above\n-    fn crate_meta_extras_hash(symbol_hasher: hash::streaming,\n+    fn crate_meta_extras_hash(symbol_hasher: &hash::State,\n                               _crate: ast::crate,\n                               metas: provided_metas,\n                               dep_hashes: ~[@~str]) -> ~str {\n@@ -357,11 +358,11 @@ fn build_link_meta(sess: session, c: ast::crate, output: ~str,\n             let m = m_;\n             alt m.node {\n               ast::meta_name_value(key, value) {\n-                symbol_hasher.input_str(len_and_str(*key));\n-                symbol_hasher.input_str(len_and_str_lit(value));\n+                symbol_hasher.write_str(len_and_str(*key));\n+                symbol_hasher.write_str(len_and_str_lit(value));\n               }\n               ast::meta_word(name) {\n-                symbol_hasher.input_str(len_and_str(*name));\n+                symbol_hasher.write_str(len_and_str(*name));\n               }\n               ast::meta_list(_, _) {\n                 // FIXME (#607): Implement this\n@@ -371,7 +372,7 @@ fn build_link_meta(sess: session, c: ast::crate, output: ~str,\n         }\n \n         for dep_hashes.each |dh| {\n-            symbol_hasher.input_str(len_and_str(*dh));\n+            symbol_hasher.write_str(len_and_str(*dh));\n         }\n \n         return truncated_hash_result(symbol_hasher);\n@@ -427,23 +428,23 @@ fn build_link_meta(sess: session, c: ast::crate, output: ~str,\n     return {name: name, vers: vers, extras_hash: extras_hash};\n }\n \n-fn truncated_hash_result(symbol_hasher: hash::streaming) -> ~str unsafe {\n+fn truncated_hash_result(symbol_hasher: &hash::State) -> ~str unsafe {\n     symbol_hasher.result_str()\n }\n \n \n // This calculates STH for a symbol, as defined above\n-fn symbol_hash(tcx: ty::ctxt, symbol_hasher: hash::streaming, t: ty::t,\n+fn symbol_hash(tcx: ty::ctxt, symbol_hasher: &hash::State, t: ty::t,\n                link_meta: link_meta) -> ~str {\n     // NB: do *not* use abbrevs here as we want the symbol names\n     // to be independent of one another in the crate.\n \n     symbol_hasher.reset();\n-    symbol_hasher.input_str(*link_meta.name);\n-    symbol_hasher.input_str(~\"-\");\n-    symbol_hasher.input_str(link_meta.extras_hash);\n-    symbol_hasher.input_str(~\"-\");\n-    symbol_hasher.input_str(encoder::encoded_ty(tcx, t));\n+    symbol_hasher.write_str(*link_meta.name);\n+    symbol_hasher.write_str(~\"-\");\n+    symbol_hasher.write_str(link_meta.extras_hash);\n+    symbol_hasher.write_str(~\"-\");\n+    symbol_hasher.write_str(encoder::encoded_ty(tcx, t));\n     let hash = truncated_hash_result(symbol_hasher);\n     // Prefix with _ so that it never blends into adjacent digits\n "}, {"sha": "ea0661f3510f8448bfb33b33dab722fbc9ae0f5f", "filename": "src/rustc/middle/trans/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4779d2b392bf1d721eccbcac00d1ab1708a8faa1/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4779d2b392bf1d721eccbcac00d1ab1708a8faa1/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=4779d2b392bf1d721eccbcac00d1ab1708a8faa1", "patch": "@@ -5493,7 +5493,7 @@ fn trans_crate(sess: session::session, crate: @ast::crate, tcx: ty::ctxt,\n                output: ~str, emap: resolve3::ExportMap,\n                maps: astencode::maps)\n     -> (ModuleRef, link_meta) {\n-    let symbol_hasher = hash::siphash(0,0);\n+    let symbol_hasher = @hash::default_state();\n     let link_meta =\n         link::build_link_meta(sess, *crate, output, symbol_hasher);\n     let reachable = reachable::find_reachable(crate.node.module, emap, tcx,"}, {"sha": "df585bb757bc79c5ecbc3f14531060083cbd9dd5", "filename": "src/rustc/middle/trans/common.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4779d2b392bf1d721eccbcac00d1ab1708a8faa1/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4779d2b392bf1d721eccbcac00d1ab1708a8faa1/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=4779d2b392bf1d721eccbcac00d1ab1708a8faa1", "patch": "@@ -110,7 +110,7 @@ type crate_ctxt = {\n      module_data: hashmap<~str, ValueRef>,\n      lltypes: hashmap<ty::t, TypeRef>,\n      names: namegen,\n-     symbol_hasher: hash::streaming,\n+     symbol_hasher: @hash::State,\n      type_hashcodes: hashmap<ty::t, ~str>,\n      type_short_names: hashmap<ty::t, ~str>,\n      all_llvm_symbols: set<~str>,"}]}