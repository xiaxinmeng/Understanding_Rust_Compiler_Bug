{"sha": "b1565c5c4c43e65eb42919848f600b6d02c18828", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIxNTY1YzVjNGM0M2U2NWViNDI5MTk4NDhmNjAwYjZkMDJjMTg4Mjg=", "commit": {"author": {"name": "Alex HotShot Newman", "email": "posix4e@gmail.com", "date": "2015-09-01T02:42:58Z"}, "committer": {"name": "Alex HotShot Newman", "email": "posix4e@gmail.com", "date": "2015-09-01T04:02:19Z"}, "message": "Readme cleanup", "tree": {"sha": "5bfe7188ca9fb60a433389ed68dddde45974e1dd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5bfe7188ca9fb60a433389ed68dddde45974e1dd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b1565c5c4c43e65eb42919848f600b6d02c18828", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b1565c5c4c43e65eb42919848f600b6d02c18828", "html_url": "https://github.com/rust-lang/rust/commit/b1565c5c4c43e65eb42919848f600b6d02c18828", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b1565c5c4c43e65eb42919848f600b6d02c18828/comments", "author": {"login": "posix4e", "id": 806363, "node_id": "MDQ6VXNlcjgwNjM2Mw==", "avatar_url": "https://avatars.githubusercontent.com/u/806363?v=4", "gravatar_id": "", "url": "https://api.github.com/users/posix4e", "html_url": "https://github.com/posix4e", "followers_url": "https://api.github.com/users/posix4e/followers", "following_url": "https://api.github.com/users/posix4e/following{/other_user}", "gists_url": "https://api.github.com/users/posix4e/gists{/gist_id}", "starred_url": "https://api.github.com/users/posix4e/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/posix4e/subscriptions", "organizations_url": "https://api.github.com/users/posix4e/orgs", "repos_url": "https://api.github.com/users/posix4e/repos", "events_url": "https://api.github.com/users/posix4e/events{/privacy}", "received_events_url": "https://api.github.com/users/posix4e/received_events", "type": "User", "site_admin": false}, "committer": {"login": "posix4e", "id": 806363, "node_id": "MDQ6VXNlcjgwNjM2Mw==", "avatar_url": "https://avatars.githubusercontent.com/u/806363?v=4", "gravatar_id": "", "url": "https://api.github.com/users/posix4e", "html_url": "https://github.com/posix4e", "followers_url": "https://api.github.com/users/posix4e/followers", "following_url": "https://api.github.com/users/posix4e/following{/other_user}", "gists_url": "https://api.github.com/users/posix4e/gists{/gist_id}", "starred_url": "https://api.github.com/users/posix4e/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/posix4e/subscriptions", "organizations_url": "https://api.github.com/users/posix4e/orgs", "repos_url": "https://api.github.com/users/posix4e/repos", "events_url": "https://api.github.com/users/posix4e/events{/privacy}", "received_events_url": "https://api.github.com/users/posix4e/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2bf4d74832395506445aa356ed7ed5e2678658f4", "url": "https://api.github.com/repos/rust-lang/rust/commits/2bf4d74832395506445aa356ed7ed5e2678658f4", "html_url": "https://github.com/rust-lang/rust/commit/2bf4d74832395506445aa356ed7ed5e2678658f4"}], "stats": {"total": 415, "additions": 209, "deletions": 206}, "files": [{"sha": "0cf3e0b92230ef994e1697318388e123576dbbc3", "filename": "Contributing.md", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/b1565c5c4c43e65eb42919848f600b6d02c18828/Contributing.md", "raw_url": "https://github.com/rust-lang/rust/raw/b1565c5c4c43e65eb42919848f600b6d02c18828/Contributing.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Contributing.md?ref=b1565c5c4c43e65eb42919848f600b6d02c18828", "patch": "@@ -0,0 +1,24 @@\n+## Contributing\n+\n+### Test and file issues\n+\n+It would be really useful to have people use rustfmt on their projects and file\n+issues where it does something you don't expect.\n+\n+A really useful thing to do that on a crate from the Rust repo. If it does\n+something unexpected, file an issue; if not, make a PR to the Rust repo with the reformatted code. I hope to get the whole repo consistently rustfmt'ed and to\n+replace `make tidy` with rustfmt as a medium-term goal.\n+\n+### Create test cases\n+\n+Having a strong test suite for a tool like this is essential. It is very easy\n+to create regressions. Any tests you can add are very much appreciated.\n+\n+### Hack!\n+\n+Here are some [good starting issues](https://github.com/nrc/rustfmt/issues?q=is%3Aopen+is%3Aissue+label%3Aeasy).\n+Note than some of those issues tagged 'easy' are not that easy and might be better\n+second issues, rather than good first issues to fix.\n+\n+If you've found areas which need polish and don't have issues, please submit a\n+PR, don't feel there needs to be an issue."}, {"sha": "6aa28b89f0d33f0ece54bd8fb9d58d1db060e98c", "filename": "Design.md", "status": "added", "additions": 175, "deletions": 0, "changes": 175, "blob_url": "https://github.com/rust-lang/rust/blob/b1565c5c4c43e65eb42919848f600b6d02c18828/Design.md", "raw_url": "https://github.com/rust-lang/rust/raw/b1565c5c4c43e65eb42919848f600b6d02c18828/Design.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Design.md?ref=b1565c5c4c43e65eb42919848f600b6d02c18828", "patch": "@@ -0,0 +1,175 @@\n+# Some thoughts on the design of rustfmt\n+\n+## Use cases\n+\n+A formatting tool can be used in different ways and the different use cases can\n+affect the design of the tool. The use cases I'm particularly concerned with are:\n+\n+* running on a whole repo before check-in\n+  - in particular, to replace the `make tidy` pass on the Rust distro\n+* running on code from another project that you are adding to your own\n+* using for mass changes in code style over a project\n+\n+Some valid use cases for a formatting tool which I am explicitly not trying to\n+address (although it would be nice, if possible):\n+\n+* running 'as you type' in an IDE\n+* running on arbitrary snippets of code\n+* running on Rust-like code, specifically code which doesn't parse\n+* use as a pretty printer inside the compiler\n+* refactoring\n+* formatting totally unformatted source code\n+\n+\n+## Scope and vision\n+\n+I do not subscribe to the notion that a formatting tool should only change\n+whitespace. I believe that we should semantics preserving, but not necessarily\n+syntax preserving, i.e., we can change the AST of a program.\n+\n+I.e., we might change glob imports to list or single imports, re-order imports,\n+move bounds to where clauses, combine multiple impls into a single impl, etc.\n+\n+However, we will not change the names of variables or make any changes which\n+*could* change the semantics. To be ever so slightly formal, we might imagine\n+a compilers high level intermediate representation, we should strive to only\n+make changes which do not change the HIR, even if they do change the AST.\n+\n+I would like to be able to output refactoring scripts for making deeper changes\n+though. (E.g., renaming variables to satisfy our style guidelines).\n+\n+My long term goal is that all style lints can be moved from the compiler to\n+rustfmt and, as well as warning, can either fix problems or emit refactoring\n+scripts to do so.\n+\n+### Configurability\n+\n+I believe reformatting should be configurable to some extent. We should read in\n+options from a configuration file and reformat accordingly. We should supply at\n+least a config file which matches the Rust style guidelines.\n+\n+There should be multiple modes for running the tool. As well as simply replacing\n+each file, we should be able to show the user a list of the changes we would\n+make, or show a list of violations without corrections (the difference being\n+that there are multiple ways to satisfy a given set of style guidelines, and we\n+should distinguish violations from deviations from our own model).\n+\n+\n+## Implementation philosophy\n+\n+Some details of the philosophy behind the implementation.\n+\n+\n+### Operate on the AST\n+\n+A reformatting tool can be based on either the AST or a token stream (in Rust\n+this is actually a stream of token trees, but its not a fundamental difference).\n+There are pros and cons to the two approaches. I have chosen to use the AST\n+approach. The primary reasons are that it allows us to do more sophisticated\n+manipulations, rather than just change whitespace, and it gives us more context\n+when making those changes.\n+\n+The advantage of the tokens approach are that you can operate on non-parsable\n+code. I don't care too much about that, it would be nice, but I think being able\n+to perform sophisticated transformations is more important. In the future I hope to\n+(optionally) be able to use type information for informing reformatting too. One\n+specific case of unparsable code is macros. Using tokens is certainly easier\n+here, but I believe it is perfectly solvable with the AST approach. At the limit,\n+we can operate on just tokens in the macro case.\n+\n+I believe that there is not in fact that much difference between the two\n+approaches. Due to imperfect span information, under the AST approach, we\n+sometimes are reduced to examining tokens or do some re-lexing of our own. Under\n+the tokens approach you need to implement your own (much simpler) parser. I\n+believe that as the tool gets more sophisticated, you end up doing more at the\n+token-level, or having an increasingly sophisticated parser, until at the limit\n+you have the same tool.\n+\n+However, I believe starting from the AST gets you more quickly to a usable and\n+useful tool.\n+\n+\n+### Heuristic rather than algorithmic\n+\n+Many formatting tools use a very general algorithmic or even algebraic tool for\n+pretty printing. This results in very elegant code, but I believe does not give\n+the best results. I prefer a more ad hoc approach where each expression/item is\n+formatted using custom rules. We hopefully don't end up with too much code due\n+to good old fashioned abstraction and code sharing. This will give a bigger code\n+base, but hopefully a better result.\n+\n+It also means that there will be some cases we can't format and we have to give\n+up. I think that is OK. Hopefully they are rare enough that manually fixing them\n+is not painful. Better to have a tool that gives great code in 99% of cases and\n+fails in 1% than a tool which gives 50% great code and 50% ugly code, but never\n+fails.\n+\n+\n+### Incremental development\n+\n+I want rustfmt to be useful as soon as possible and to always be useful. I\n+specifically don't want to have to wait for a feature (or worse, the whole tool)\n+to be perfect before it is useful. The main ways this is achieved is to output\n+the source code where we can't yet reformat, be able to turn off new features\n+until they are ready, and the 'do no harm' principle (see next section).\n+\n+\n+### First, do no harm\n+\n+Until rustfmt it perfect, there will always be a trade-off between doing more and\n+doing existing things well. I want to err on the side of the latter.\n+Specifically, rustfmt should never take OK code and make it look worse. If we\n+can't make it better, we should leave it as is. That might mean being less\n+aggressive than we like or using configurability.\n+\n+\n+### Use the source code as guidance\n+\n+There are often multiple ways to format code and satisfy standards. Where this\n+is the case, we should use the source code as a hint for reformatting.\n+Furthermore, where the code has been formatted in a particular way that satisfies\n+the coding standard, it should not be changed (this is sometimes not possible or\n+not worthwhile due to uniformity being desirable, but it is a useful goal).\n+\n+\n+### Architecture details\n+\n+We use the AST from libsyntax. We use libsyntax's visit module to walk the AST\n+to find starting points for reformatting. Eventually, we should reformat everything\n+and we shouldn't need the visit module. We keep track of the last formatted\n+position in the code, and when we reformat the next piece of code we make sure\n+to output the span for all the code in between (handled by missed_spans.rs).\n+\n+Our visitor keeps track of the desired current indent due to blocks (\n+`block_indent`). Each `visit_*` method reformats code according to this indent\n+and `IDEAL_WIDTH` and `MAX_WIDTH` (which should one day be supplied from a\n+config file). Most reformatting done in the `visit_*` methods is a bit hackey\n+and is meant to be temporary until it can be done properly.\n+\n+There are a bunch of methods called `rewrite_*`. There do the bulk of the\n+reformatting. These take the AST node to be reformatted (this may not literally\n+be an AST node from libsyntax, there might be multiple parameters describing a\n+logical node), the current indent, and the current width budget. They return a\n+`String` (or sometimes an `Option<String>`) which formats the code in the box\n+given by the indent and width budget. If the method fails, it returns `None` and\n+the calling method then has to fallback in some way to give the callee more space.\n+\n+So, in summary to format a node, we calculate the width budget and then walk down\n+the tree from the node. At a leaf, we generate an actual string and then unwind,\n+combining these strings as we go back up the tree.\n+\n+For example, consider a method definition:\n+\n+```\n+    fn foo(a: A, b: B) {\n+        ...\n+    }\n+```\n+\n+We start at indent 4, the rewrite function for the whole function knows it must\n+write `fn foo(` before the arguments and `) {` after them, assuming the max width\n+is 100, it thus asks the rewrite argument list function to rewrite with an indent\n+of 11 and in a width of 86. Assuming that is possible (obviously in this case),\n+it returns a string for the arguments and it can make a string for the function\n+header. If the arguments couldn't be fitted in that space, we might try to\n+fallback to a hanging indent, so we try again with indent 8 and width 89."}, {"sha": "8ae1b0bc91714029db6368091058855a6be8b46d", "filename": "README.md", "status": "modified", "additions": 10, "deletions": 206, "changes": 216, "blob_url": "https://github.com/rust-lang/rust/blob/b1565c5c4c43e65eb42919848f600b6d02c18828/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/b1565c5c4c43e65eb42919848f600b6d02c18828/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=b1565c5c4c43e65eb42919848f600b6d02c18828", "patch": "@@ -2,20 +2,24 @@\n \n A tool for formatting Rust code according to style guidelines.\n \n+## Gotchas\n+* For things you do not want rustfmt to mangle, use\n+```rust\n+ #[rustfmt_skip]\n+ ```\n+* When you run rustfmt use a file called rustfmt.toml to override the settings in default.toml\n+* We create a functioning executable called rustfmt in the target directory\n \n-## How to use\n-\n-You'll need a pretty up to date version of the **nightly** version of Rust. \n-You will need a default.toml file in the current working directory when you run\n-the rustfmt command. You can look at this repo for an example default.toml file.\n+## How to build and test\n+You'll need a pretty up to date version of the **nightly** version of Rust.\n \n `cargo build` to build.\n \n `cargo test` to run all tests.\n \n `cargo run -- filename` to run on a file, if the file includes out of line modules,\n then we reformat those too. So to run on a whole module or crate, you just need\n-to run on the top file. \n+to run on the top file.\n \n You'll probably want to specify the write mode. Currently, there are the replace,\n overwrite and display mode. The replace mode is the default and overwrites the\n@@ -25,203 +29,3 @@ mode can be set by passing the `--write-mode` flag on the command line.\n \n `cargo run -- filename --write-mode=display` prints the output of rustfmt to the\n screen, for example.\n-\n-## Use cases\n-\n-A formatting tool can be used in different ways and the different use cases can\n-affect the design of the tool. The use cases I'm particularly concerned with are:\n-\n-* running on a whole repo before check-in\n-  - in particular, to replace the `make tidy` pass on the Rust distro\n-* running on code from another project that you are adding to your own\n-* using for mass changes in code style over a project\n-\n-Some valid use cases for a formatting tool which I am explicitly not trying to\n-address (although it would be nice, if possible):\n-\n-* running 'as you type' in an IDE\n-* running on arbitrary snippets of code\n-* running on Rust-like code, specifically code which doesn't parse\n-* use as a pretty printer inside the compiler\n-* refactoring\n-* formatting totally unformatted source code\n-\n-\n-## Scope and vision\n-\n-I do not subscribe to the notion that a formatting tool should only change\n-whitespace. I believe that we should semantics preserving, but not necessarily\n-syntax preserving, i.e., we can change the AST of a program.\n-\n-I.e., we might change glob imports to list or single imports, re-order imports,\n-move bounds to where clauses, combine multiple impls into a single impl, etc.\n-\n-However, we will not change the names of variables or make any changes which\n-*could* change the semantics. To be ever so slightly formal, we might imagine\n-a compilers high level intermediate representation, we should strive to only\n-make changes which do not change the HIR, even if they do change the AST.\n-\n-I would like to be able to output refactoring scripts for making deeper changes\n-though. (E.g., renaming variables to satisfy our style guidelines).\n-\n-My long term goal is that all style lints can be moved from the compiler to\n-rustfmt and, as well as warning, can either fix problems or emit refactoring\n-scripts to do so.\n-\n-### Configurability\n-\n-I believe reformatting should be configurable to some extent. We should read in\n-options from a configuration file and reformat accordingly. We should supply at\n-least a config file which matches the Rust style guidelines.\n-\n-There should be multiple modes for running the tool. As well as simply replacing\n-each file, we should be able to show the user a list of the changes we would\n-make, or show a list of violations without corrections (the difference being\n-that there are multiple ways to satisfy a given set of style guidelines, and we\n-should distinguish violations from deviations from our own model).\n-\n-\n-## Implementation philosophy\n-\n-Some details of the philosophy behind the implementation.\n-\n-\n-### Operate on the AST\n-\n-A reformatting tool can be based on either the AST or a token stream (in Rust\n-this is actually a stream of token trees, but its not a fundamental difference).\n-There are pros and cons to the two approaches. I have chosen to use the AST\n-approach. The primary reasons are that it allows us to do more sophisticated\n-manipulations, rather than just change whitespace, and it gives us more context\n-when making those changes.\n-\n-The advantage of the tokens approach are that you can operate on non-parsable\n-code. I don't care too much about that, it would be nice, but I think being able\n-to perform sophisticated transformations is more important. In the future I hope to\n-(optionally) be able to use type information for informing reformatting too. One\n-specific case of unparsable code is macros. Using tokens is certainly easier\n-here, but I believe it is perfectly solvable with the AST approach. At the limit,\n-we can operate on just tokens in the macro case.\n-\n-I believe that there is not in fact that much difference between the two\n-approaches. Due to imperfect span information, under the AST approach, we\n-sometimes are reduced to examining tokens or do some re-lexing of our own. Under\n-the tokens approach you need to implement your own (much simpler) parser. I\n-believe that as the tool gets more sophisticated, you end up doing more at the\n-token-level, or having an increasingly sophisticated parser, until at the limit\n-you have the same tool.\n-\n-However, I believe starting from the AST gets you more quickly to a usable and\n-useful tool.\n-\n-\n-### Heuristic rather than algorithmic\n-\n-Many formatting tools use a very general algorithmic or even algebraic tool for\n-pretty printing. This results in very elegant code, but I believe does not give\n-the best results. I prefer a more ad hoc approach where each expression/item is\n-formatted using custom rules. We hopefully don't end up with too much code due\n-to good old fashioned abstraction and code sharing. This will give a bigger code\n-base, but hopefully a better result.\n-\n-It also means that there will be some cases we can't format and we have to give\n-up. I think that is OK. Hopefully they are rare enough that manually fixing them\n-is not painful. Better to have a tool that gives great code in 99% of cases and\n-fails in 1% than a tool which gives 50% great code and 50% ugly code, but never\n-fails.\n-\n-\n-### Incremental development\n-\n-I want rustfmt to be useful as soon as possible and to always be useful. I\n-specifically don't want to have to wait for a feature (or worse, the whole tool)\n-to be perfect before it is useful. The main ways this is achieved is to output\n-the source code where we can't yet reformat, be able to turn off new features\n-until they are ready, and the 'do no harm' principle (see next section).\n-\n-\n-### First, do no harm\n-\n-Until rustfmt it perfect, there will always be a trade-off between doing more and\n-doing existing things well. I want to err on the side of the latter.\n-Specifically, rustfmt should never take OK code and make it look worse. If we\n-can't make it better, we should leave it as is. That might mean being less\n-aggressive than we like or using configurability.\n-\n-\n-### Use the source code as guidance\n-\n-There are often multiple ways to format code and satisfy standards. Where this\n-is the case, we should use the source code as a hint for reformatting.\n-Furthermore, where the code has been formatted in a particular way that satisfies\n-the coding standard, it should not be changed (this is sometimes not possible or\n-not worthwhile due to uniformity being desirable, but it is a useful goal).\n-\n-\n-### Architecture details\n-\n-We use the AST from libsyntax. We use libsyntax's visit module to walk the AST\n-to find starting points for reformatting. Eventually, we should reformat everything\n-and we shouldn't need the visit module. We keep track of the last formatted\n-position in the code, and when we reformat the next piece of code we make sure\n-to output the span for all the code in between (handled by missed_spans.rs).\n-\n-Our visitor keeps track of the desired current indent due to blocks (\n-`block_indent`). Each `visit_*` method reformats code according to this indent\n-and `IDEAL_WIDTH` and `MAX_WIDTH` (which should one day be supplied from a \n-config file). Most reformatting done in the `visit_*` methods is a bit hackey\n-and is meant to be temporary until it can be done properly.\n-\n-There are a bunch of methods called `rewrite_*`. There do the bulk of the\n-reformatting. These take the AST node to be reformatted (this may not literally\n-be an AST node from libsyntax, there might be multiple parameters describing a\n-logical node), the current indent, and the current width budget. They return a\n-`String` (or sometimes an `Option<String>`) which formats the code in the box\n-given by the indent and width budget. If the method fails, it returns `None` and\n-the calling method then has to fallback in some way to give the callee more space.\n-\n-So, in summary to format a node, we calculate the width budget and then walk down\n-the tree from the node. At a leaf, we generate an actual string and then unwind,\n-combining these strings as we go back up the tree.\n-\n-For example, consider a method definition:\n-\n-```\n-    fn foo(a: A, b: B) {\n-        ...\n-    }\n-```\n-\n-We start at indent 4, the rewrite function for the whole function knows it must\n-write `fn foo(` before the arguments and `) {` after them, assuming the max width\n-is 100, it thus asks the rewrite argument list function to rewrite with an indent\n-of 11 and in a width of 86. Assuming that is possible (obviously in this case),\n-it returns a string for the arguments and it can make a string for the function\n-header. If the arguments couldn't be fitted in that space, we might try to\n-fallback to a hanging indent, so we try again with indent 8 and width 89.\n-\n-\n-## Contributing\n-\n-### Test and file issues\n-\n-It would be really useful to have people use rustfmt on their projects and file\n-issues where it does something you don't expect.\n-\n-A really useful thing to do that on a crate from the Rust repo. If it does\n-something unexpected, file an issue; if not, make a PR to the Rust repo with the reformatted code. I hope to get the whole repo consistently rustfmt'ed and to\n-replace `make tidy` with rustfmt as a medium-term goal.\n-\n-### Create test cases\n-\n-Having a strong test suite for a tool like this is essential. It is very easy\n-to create regressions. Any tests you can add are very much appreciated.\n-\n-### Hack!\n-\n-Here are some [good starting issues](https://github.com/nrc/rustfmt/issues?q=is%3Aopen+is%3Aissue+label%3Aeasy).\n-Note than some of those issues tagged 'easy' are not that easy and might be better\n-second issues, rather than good first issues to fix.\n-\n-If you've found areas which need polish and don't have issues, please submit a\n-PR, don't feel there needs to be an issue."}]}