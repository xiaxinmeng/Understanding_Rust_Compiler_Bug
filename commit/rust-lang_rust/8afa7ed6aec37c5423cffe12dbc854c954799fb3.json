{"sha": "8afa7ed6aec37c5423cffe12dbc854c954799fb3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhhZmE3ZWQ2YWVjMzdjNTQyM2NmZmUxMmRiYzg1NGM5NTQ3OTlmYjM=", "commit": {"author": {"name": "Eduardo Broto", "email": "ebroto@tutanota.com", "date": "2020-09-06T21:32:48Z"}, "committer": {"name": "Eduardo Broto", "email": "ebroto@tutanota.com", "date": "2020-09-15T08:29:53Z"}, "message": "Add internal lint MatchTypeOnDiagItem", "tree": {"sha": "92abc0c349ce6324c83d8bb05b8c173991ae814d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/92abc0c349ce6324c83d8bb05b8c173991ae814d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8afa7ed6aec37c5423cffe12dbc854c954799fb3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8afa7ed6aec37c5423cffe12dbc854c954799fb3", "html_url": "https://github.com/rust-lang/rust/commit/8afa7ed6aec37c5423cffe12dbc854c954799fb3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8afa7ed6aec37c5423cffe12dbc854c954799fb3/comments", "author": {"login": "ebroto", "id": 816908, "node_id": "MDQ6VXNlcjgxNjkwOA==", "avatar_url": "https://avatars.githubusercontent.com/u/816908?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ebroto", "html_url": "https://github.com/ebroto", "followers_url": "https://api.github.com/users/ebroto/followers", "following_url": "https://api.github.com/users/ebroto/following{/other_user}", "gists_url": "https://api.github.com/users/ebroto/gists{/gist_id}", "starred_url": "https://api.github.com/users/ebroto/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ebroto/subscriptions", "organizations_url": "https://api.github.com/users/ebroto/orgs", "repos_url": "https://api.github.com/users/ebroto/repos", "events_url": "https://api.github.com/users/ebroto/events{/privacy}", "received_events_url": "https://api.github.com/users/ebroto/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ebroto", "id": 816908, "node_id": "MDQ6VXNlcjgxNjkwOA==", "avatar_url": "https://avatars.githubusercontent.com/u/816908?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ebroto", "html_url": "https://github.com/ebroto", "followers_url": "https://api.github.com/users/ebroto/followers", "following_url": "https://api.github.com/users/ebroto/following{/other_user}", "gists_url": "https://api.github.com/users/ebroto/gists{/gist_id}", "starred_url": "https://api.github.com/users/ebroto/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ebroto/subscriptions", "organizations_url": "https://api.github.com/users/ebroto/orgs", "repos_url": "https://api.github.com/users/ebroto/repos", "events_url": "https://api.github.com/users/ebroto/events{/privacy}", "received_events_url": "https://api.github.com/users/ebroto/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f82e84c8943e70300ad1f4de46d8d7bd889c6bde", "url": "https://api.github.com/repos/rust-lang/rust/commits/f82e84c8943e70300ad1f4de46d8d7bd889c6bde", "html_url": "https://github.com/rust-lang/rust/commit/f82e84c8943e70300ad1f4de46d8d7bd889c6bde"}], "stats": {"total": 206, "additions": 203, "deletions": 3}, "files": [{"sha": "b60a80e07d70852d282bf9a22f73e5bef55d5765", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8afa7ed6aec37c5423cffe12dbc854c954799fb3/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8afa7ed6aec37c5423cffe12dbc854c954799fb3/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=8afa7ed6aec37c5423cffe12dbc854c954799fb3", "patch": "@@ -867,6 +867,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         &utils::internal_lints::COMPILER_LINT_FUNCTIONS,\n         &utils::internal_lints::DEFAULT_LINT,\n         &utils::internal_lints::LINT_WITHOUT_LINT_PASS,\n+        &utils::internal_lints::MATCH_TYPE_ON_DIAGNOSTIC_ITEM,\n         &utils::internal_lints::OUTER_EXPN_EXPN_DATA,\n         &utils::internal_lints::PRODUCE_ICE,\n         &vec::USELESS_VEC,\n@@ -1112,6 +1113,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(|| box self_assignment::SelfAssignment);\n     store.register_late_pass(|| box float_equality_without_abs::FloatEqualityWithoutAbs);\n     store.register_late_pass(|| box async_yields_async::AsyncYieldsAsync);\n+    store.register_late_pass(|| box utils::internal_lints::MatchTypeOnDiagItem);\n \n     store.register_group(true, \"clippy::restriction\", Some(\"clippy_restriction\"), vec![\n         LintId::of(&arithmetic::FLOAT_ARITHMETIC),\n@@ -1240,6 +1242,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&utils::internal_lints::COMPILER_LINT_FUNCTIONS),\n         LintId::of(&utils::internal_lints::DEFAULT_LINT),\n         LintId::of(&utils::internal_lints::LINT_WITHOUT_LINT_PASS),\n+        LintId::of(&utils::internal_lints::MATCH_TYPE_ON_DIAGNOSTIC_ITEM),\n         LintId::of(&utils::internal_lints::OUTER_EXPN_EXPN_DATA),\n         LintId::of(&utils::internal_lints::PRODUCE_ICE),\n     ]);"}, {"sha": "5beb4be5b29241857d88cc9718211f0c4c9add68", "filename": "clippy_lints/src/utils/internal_lints.rs", "status": "modified", "additions": 112, "deletions": 3, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/8afa7ed6aec37c5423cffe12dbc854c954799fb3/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8afa7ed6aec37c5423cffe12dbc854c954799fb3/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs?ref=8afa7ed6aec37c5423cffe12dbc854c954799fb3", "patch": "@@ -1,6 +1,6 @@\n use crate::utils::{\n-    is_expn_of, match_def_path, match_qpath, match_type, method_calls, paths, run_lints, snippet, span_lint,\n-    span_lint_and_help, span_lint_and_sugg, walk_ptrs_ty, SpanlessEq,\n+    is_expn_of, match_def_path, match_qpath, match_type, method_calls, path_to_res, paths, qpath_res, run_lints,\n+    snippet, span_lint, span_lint_and_help, span_lint_and_sugg, walk_ptrs_ty, SpanlessEq,\n };\n use if_chain::if_chain;\n use rustc_ast::ast::{Crate as AstCrate, ItemKind, LitKind, NodeId};\n@@ -11,7 +11,7 @@ use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n use rustc_hir::hir_id::CRATE_HIR_ID;\n use rustc_hir::intravisit::{NestedVisitorMap, Visitor};\n-use rustc_hir::{Crate, Expr, ExprKind, HirId, Item, MutTy, Mutability, Path, StmtKind, Ty, TyKind};\n+use rustc_hir::{Crate, Expr, ExprKind, HirId, Item, MutTy, Mutability, Node, Path, StmtKind, Ty, TyKind};\n use rustc_lint::{EarlyContext, EarlyLintPass, LateContext, LateLintPass};\n use rustc_middle::hir::map::Map;\n use rustc_session::{declare_lint_pass, declare_tool_lint, impl_lint_pass};\n@@ -206,6 +206,29 @@ declare_clippy_lint! {\n     \"found collapsible `span_lint_and_then` calls\"\n }\n \n+declare_clippy_lint! {\n+    /// **What it does:** Checks for calls to `utils::match_type()` on a type diagnostic item\n+    /// and suggests to use `utils::is_type_diagnostic_item()` instead.\n+    ///\n+    /// **Why is this bad?** `utils::is_type_diagnostic_item()` does not require hardcoded paths.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// Bad:\n+    /// ```rust,ignore\n+    /// utils::match_type(cx, ty, &paths::VEC)\n+    /// ```\n+    ///\n+    /// Good:\n+    /// ```rust,ignore\n+    /// utils::is_type_diagnostic_item(cx, ty, sym!(vec_type))\n+    /// ```\n+    pub MATCH_TYPE_ON_DIAGNOSTIC_ITEM,\n+    internal,\n+    \"using `utils::match_type()` instead of `utils::is_type_diagnostic_item()`\"\n+}\n+\n declare_lint_pass!(ClippyLintsInternal => [CLIPPY_LINTS_INTERNAL]);\n \n impl EarlyLintPass for ClippyLintsInternal {\n@@ -652,3 +675,89 @@ fn suggest_note(\n         Applicability::MachineApplicable,\n     );\n }\n+\n+declare_lint_pass!(MatchTypeOnDiagItem => [MATCH_TYPE_ON_DIAGNOSTIC_ITEM]);\n+\n+impl<'tcx> LateLintPass<'tcx> for MatchTypeOnDiagItem {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>) {\n+        if !run_lints(cx, &[MATCH_TYPE_ON_DIAGNOSTIC_ITEM], expr.hir_id) {\n+            return;\n+        }\n+\n+        if_chain! {\n+            // Check if this is a call to utils::match_type()\n+            if let ExprKind::Call(fn_path, [context, ty, ty_path]) = expr.kind;\n+            if let ExprKind::Path(fn_qpath) = &fn_path.kind;\n+            if match_qpath(&fn_qpath, &[\"utils\", \"match_type\"]);\n+            // Extract the path to the matched type\n+            if let Some(segments) = path_to_matched_type(cx, ty_path);\n+            let segments: Vec<&str> = segments.iter().map(|sym| &**sym).collect();\n+            if let Some(ty_did) = path_to_res(cx, &segments[..]).and_then(|res| res.opt_def_id());\n+            // Check if the matched type is a diagnostic item\n+            let diag_items = cx.tcx.diagnostic_items(ty_did.krate);\n+            if let Some(item_name) = diag_items.iter().find_map(|(k, v)| if *v == ty_did { Some(k) } else { None });\n+            then {\n+                let cx_snippet = snippet(cx, context.span, \"_\");\n+                let ty_snippet = snippet(cx, ty.span, \"_\");\n+\n+                span_lint_and_sugg(\n+                    cx,\n+                    MATCH_TYPE_ON_DIAGNOSTIC_ITEM,\n+                    expr.span,\n+                    \"usage of `utils::match_type() on a type diagnostic item`\",\n+                    \"try\",\n+                    format!(\"utils::is_type_diagnostic_item({}, {}, sym!({}))\", cx_snippet, ty_snippet, item_name),\n+                    Applicability::MaybeIncorrect,\n+                );\n+            }\n+        }\n+    }\n+}\n+\n+fn path_to_matched_type(cx: &LateContext<'_>, expr: &hir::Expr<'_>) -> Option<Vec<SymbolStr>> {\n+    use rustc_hir::ItemKind;\n+\n+    match &expr.kind {\n+        ExprKind::AddrOf(.., expr) => return path_to_matched_type(cx, expr),\n+        ExprKind::Path(qpath) => match qpath_res(cx, qpath, expr.hir_id) {\n+            Res::Local(hir_id) => {\n+                let parent_id = cx.tcx.hir().get_parent_node(hir_id);\n+                if let Some(Node::Local(local)) = cx.tcx.hir().find(parent_id) {\n+                    if let Some(init) = local.init {\n+                        return path_to_matched_type(cx, init);\n+                    }\n+                }\n+            },\n+            Res::Def(DefKind::Const | DefKind::Static, def_id) => {\n+                if let Some(Node::Item(item)) = cx.tcx.hir().get_if_local(def_id) {\n+                    if let ItemKind::Const(.., body_id) | ItemKind::Static(.., body_id) = item.kind {\n+                        let body = cx.tcx.hir().body(body_id);\n+                        return path_to_matched_type(cx, &body.value);\n+                    }\n+                }\n+            },\n+            _ => {},\n+        },\n+        ExprKind::Array(exprs) => {\n+            let segments: Vec<SymbolStr> = exprs\n+                .iter()\n+                .filter_map(|expr| {\n+                    if let ExprKind::Lit(lit) = &expr.kind {\n+                        if let LitKind::Str(sym, _) = lit.node {\n+                            return Some(sym.as_str());\n+                        }\n+                    }\n+\n+                    None\n+                })\n+                .collect();\n+\n+            if segments.len() == exprs.len() {\n+                return Some(segments);\n+            }\n+        },\n+        _ => {},\n+    }\n+\n+    None\n+}"}, {"sha": "8db7e693e62617eb55f65d32f576c27336bbaa2f", "filename": "clippy_lints/src/utils/mod.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8afa7ed6aec37c5423cffe12dbc854c954799fb3/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8afa7ed6aec37c5423cffe12dbc854c954799fb3/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fmod.rs?ref=8afa7ed6aec37c5423cffe12dbc854c954799fb3", "patch": "@@ -130,6 +130,9 @@ pub fn is_wild<'tcx>(pat: &impl std::ops::Deref<Target = Pat<'tcx>>) -> bool {\n }\n \n /// Checks if type is struct, enum or union type with the given def path.\n+///\n+/// If the type is a diagnostic item, use `is_type_diagnostic_item` instead.\n+/// If you change the signature, remember to update the internal lint `MatchTypeOnDiagItem`\n pub fn match_type(cx: &LateContext<'_>, ty: Ty<'_>, path: &[&str]) -> bool {\n     match ty.kind() {\n         ty::Adt(adt, _) => match_def_path(cx, adt.did, path),\n@@ -138,6 +141,8 @@ pub fn match_type(cx: &LateContext<'_>, ty: Ty<'_>, path: &[&str]) -> bool {\n }\n \n /// Checks if the type is equal to a diagnostic item\n+///\n+/// If you change the signature, remember to update the internal lint `MatchTypeOnDiagItem`\n pub fn is_type_diagnostic_item(cx: &LateContext<'_>, ty: Ty<'_>, diag_item: Symbol) -> bool {\n     match ty.kind() {\n         ty::Adt(adt, _) => cx.tcx.is_diagnostic_item(diag_item, adt.did),"}, {"sha": "fe950b0aa7c7004c729c33cc7b6dab3392d1260a", "filename": "tests/ui/match_type_on_diag_item.rs", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/8afa7ed6aec37c5423cffe12dbc854c954799fb3/tests%2Fui%2Fmatch_type_on_diag_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8afa7ed6aec37c5423cffe12dbc854c954799fb3/tests%2Fui%2Fmatch_type_on_diag_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmatch_type_on_diag_item.rs?ref=8afa7ed6aec37c5423cffe12dbc854c954799fb3", "patch": "@@ -0,0 +1,50 @@\n+#![deny(clippy::internal)]\n+#![feature(rustc_private)]\n+\n+extern crate rustc_hir;\n+extern crate rustc_lint;\n+extern crate rustc_middle;\n+#[macro_use]\n+extern crate rustc_session;\n+use rustc_hir::Expr;\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_middle::ty::Ty;\n+\n+mod paths {\n+    pub const VEC: [&str; 3] = [\"alloc\", \"vec\", \"Vec\"];\n+}\n+\n+mod utils {\n+    use super::*;\n+\n+    pub fn match_type(_cx: &LateContext<'_>, _ty: Ty<'_>, _path: &[&str]) -> bool {\n+        false\n+    }\n+}\n+\n+use utils::match_type;\n+\n+declare_lint! {\n+    pub TEST_LINT,\n+    Warn,\n+    \"\"\n+}\n+\n+declare_lint_pass!(Pass => [TEST_LINT]);\n+\n+static OPTION: [&str; 3] = [\"core\", \"option\", \"Option\"];\n+\n+impl<'tcx> LateLintPass<'tcx> for Pass {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr) {\n+        let ty = cx.typeck_results().expr_ty(expr);\n+\n+        let _ = match_type(cx, ty, &paths::VEC);\n+        let _ = match_type(cx, ty, &OPTION);\n+        let _ = match_type(cx, ty, &[\"core\", \"result\", \"Result\"]);\n+\n+        let rc_path = &[\"alloc\", \"rc\", \"Rc\"];\n+        let _ = utils::match_type(cx, ty, rc_path);\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "c89137eb758f04b2b0de686c08995546ddb3e7e4", "filename": "tests/ui/match_type_on_diag_item.stderr", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/8afa7ed6aec37c5423cffe12dbc854c954799fb3/tests%2Fui%2Fmatch_type_on_diag_item.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8afa7ed6aec37c5423cffe12dbc854c954799fb3/tests%2Fui%2Fmatch_type_on_diag_item.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmatch_type_on_diag_item.stderr?ref=8afa7ed6aec37c5423cffe12dbc854c954799fb3", "patch": "@@ -0,0 +1,33 @@\n+error: usage of `utils::match_type() on a type diagnostic item`\n+  --> $DIR/match_type_on_diag_item.rs:41:17\n+   |\n+LL |         let _ = match_type(cx, ty, &paths::VEC);\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `utils::is_type_diagnostic_item(cx, ty, sym!(vec_type))`\n+   |\n+note: the lint level is defined here\n+  --> $DIR/match_type_on_diag_item.rs:1:9\n+   |\n+LL | #![deny(clippy::internal)]\n+   |         ^^^^^^^^^^^^^^^^\n+   = note: `#[deny(clippy::match_type_on_diagnostic_item)]` implied by `#[deny(clippy::internal)]`\n+\n+error: usage of `utils::match_type() on a type diagnostic item`\n+  --> $DIR/match_type_on_diag_item.rs:42:17\n+   |\n+LL |         let _ = match_type(cx, ty, &OPTION);\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `utils::is_type_diagnostic_item(cx, ty, sym!(option_type))`\n+\n+error: usage of `utils::match_type() on a type diagnostic item`\n+  --> $DIR/match_type_on_diag_item.rs:43:17\n+   |\n+LL |         let _ = match_type(cx, ty, &[\"core\", \"result\", \"Result\"]);\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `utils::is_type_diagnostic_item(cx, ty, sym!(result_type))`\n+\n+error: usage of `utils::match_type() on a type diagnostic item`\n+  --> $DIR/match_type_on_diag_item.rs:46:17\n+   |\n+LL |         let _ = utils::match_type(cx, ty, rc_path);\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `utils::is_type_diagnostic_item(cx, ty, sym!(Rc))`\n+\n+error: aborting due to 4 previous errors\n+"}]}