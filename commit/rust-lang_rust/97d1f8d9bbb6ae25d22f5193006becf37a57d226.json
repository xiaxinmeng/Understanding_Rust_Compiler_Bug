{"sha": "97d1f8d9bbb6ae25d22f5193006becf37a57d226", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk3ZDFmOGQ5YmJiNmFlMjVkMjJmNTE5MzAwNmJlY2YzN2E1N2QyMjY=", "commit": {"author": {"name": "Tim Diekmann", "email": "tim.diekmann@3dvision.de", "date": "2020-02-10T16:00:59Z"}, "committer": {"name": "Tim Diekmann", "email": "tim.diekmann@3dvision.de", "date": "2020-02-10T18:44:29Z"}, "message": "Add missing `_zeroed` varants to `AllocRef`", "tree": {"sha": "d798d2b2cbfae6300c62f416cde2e00ab837669c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d798d2b2cbfae6300c62f416cde2e00ab837669c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/97d1f8d9bbb6ae25d22f5193006becf37a57d226", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/97d1f8d9bbb6ae25d22f5193006becf37a57d226", "html_url": "https://github.com/rust-lang/rust/commit/97d1f8d9bbb6ae25d22f5193006becf37a57d226", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/97d1f8d9bbb6ae25d22f5193006becf37a57d226/comments", "author": {"login": "TimDiekmann", "id": 21277928, "node_id": "MDQ6VXNlcjIxMjc3OTI4", "avatar_url": "https://avatars.githubusercontent.com/u/21277928?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TimDiekmann", "html_url": "https://github.com/TimDiekmann", "followers_url": "https://api.github.com/users/TimDiekmann/followers", "following_url": "https://api.github.com/users/TimDiekmann/following{/other_user}", "gists_url": "https://api.github.com/users/TimDiekmann/gists{/gist_id}", "starred_url": "https://api.github.com/users/TimDiekmann/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TimDiekmann/subscriptions", "organizations_url": "https://api.github.com/users/TimDiekmann/orgs", "repos_url": "https://api.github.com/users/TimDiekmann/repos", "events_url": "https://api.github.com/users/TimDiekmann/events{/privacy}", "received_events_url": "https://api.github.com/users/TimDiekmann/received_events", "type": "User", "site_admin": false}, "committer": {"login": "TimDiekmann", "id": 21277928, "node_id": "MDQ6VXNlcjIxMjc3OTI4", "avatar_url": "https://avatars.githubusercontent.com/u/21277928?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TimDiekmann", "html_url": "https://github.com/TimDiekmann", "followers_url": "https://api.github.com/users/TimDiekmann/followers", "following_url": "https://api.github.com/users/TimDiekmann/following{/other_user}", "gists_url": "https://api.github.com/users/TimDiekmann/gists{/gist_id}", "starred_url": "https://api.github.com/users/TimDiekmann/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TimDiekmann/subscriptions", "organizations_url": "https://api.github.com/users/TimDiekmann/orgs", "repos_url": "https://api.github.com/users/TimDiekmann/repos", "events_url": "https://api.github.com/users/TimDiekmann/events{/privacy}", "received_events_url": "https://api.github.com/users/TimDiekmann/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4d1241f5158ffd66730e094d8f199ed654ed52ae", "url": "https://api.github.com/repos/rust-lang/rust/commits/4d1241f5158ffd66730e094d8f199ed654ed52ae", "html_url": "https://github.com/rust-lang/rust/commit/4d1241f5158ffd66730e094d8f199ed654ed52ae"}], "stats": {"total": 137, "additions": 137, "deletions": 0}, "files": [{"sha": "425deadeace0a92afbe226541f3fdced9d88d55c", "filename": "src/libcore/alloc.rs", "status": "modified", "additions": 137, "deletions": 0, "changes": 137, "blob_url": "https://github.com/rust-lang/rust/blob/97d1f8d9bbb6ae25d22f5193006becf37a57d226/src%2Flibcore%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/97d1f8d9bbb6ae25d22f5193006becf37a57d226/src%2Flibcore%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Falloc.rs?ref=97d1f8d9bbb6ae25d22f5193006becf37a57d226", "patch": "@@ -853,6 +853,59 @@ pub unsafe trait AllocRef {\n         result\n     }\n \n+    /// Behaves like `realloc`, but also ensures that the new contents\n+    /// are set to zero before being returned.\n+    ///\n+    /// # Safety\n+    ///\n+    /// This function is unsafe for the same reasons that `realloc` is.\n+    ///\n+    /// # Errors\n+    ///\n+    /// Returns `Err` only if the new layout\n+    /// does not meet the allocator's size\n+    /// and alignment constraints of the allocator, or if reallocation\n+    /// otherwise fails.\n+    ///\n+    /// Implementations are encouraged to return `Err` on memory\n+    /// exhaustion rather than panicking or aborting, but this is not\n+    /// a strict requirement. (Specifically: it is *legal* to\n+    /// implement this trait atop an underlying native allocation\n+    /// library that aborts on memory exhaustion.)\n+    ///\n+    /// Clients wishing to abort computation in response to a\n+    /// reallocation error are encouraged to call the [`handle_alloc_error`] function,\n+    /// rather than directly invoking `panic!` or similar.\n+    ///\n+    /// [`handle_alloc_error`]: ../../alloc/alloc/fn.handle_alloc_error.html\n+    unsafe fn realloc_zeroed(\n+        &mut self,\n+        ptr: NonNull<u8>,\n+        layout: Layout,\n+        new_size: usize,\n+    ) -> Result<NonNull<u8>, AllocErr> {\n+        let old_size = layout.size();\n+\n+        if new_size >= old_size {\n+            if let Ok(()) = self.grow_in_place_zeroed(ptr, layout, new_size) {\n+                return Ok(ptr);\n+            }\n+        } else if new_size < old_size {\n+            if let Ok(()) = self.shrink_in_place(ptr, layout, new_size) {\n+                return Ok(ptr);\n+            }\n+        }\n+\n+        // otherwise, fall back on alloc + copy + dealloc.\n+        let new_layout = Layout::from_size_align_unchecked(new_size, layout.align());\n+        let result = self.alloc_zeroed(new_layout);\n+        if let Ok(new_ptr) = result {\n+            ptr::copy_nonoverlapping(ptr.as_ptr(), new_ptr.as_ptr(), cmp::min(old_size, new_size));\n+            self.dealloc(ptr, layout);\n+        }\n+        result\n+    }\n+\n     /// Behaves like `alloc`, but also ensures that the contents\n     /// are set to zero before being returned.\n     ///\n@@ -904,6 +957,31 @@ pub unsafe trait AllocRef {\n         self.alloc(layout).map(|p| Excess(p, usable_size.1))\n     }\n \n+    /// Behaves like `alloc`, but also returns the whole size of\n+    /// the returned block. For some `layout` inputs, like arrays, this\n+    /// may include extra storage usable for additional data.\n+    /// Also it ensures that the contents are set to zero before being returned.\n+    ///\n+    /// # Safety\n+    ///\n+    /// This function is unsafe for the same reasons that `alloc` is.\n+    ///\n+    /// # Errors\n+    ///\n+    /// Returning `Err` indicates that either memory is exhausted or\n+    /// `layout` does not meet allocator's size or alignment\n+    /// constraints, just as in `alloc`.\n+    ///\n+    /// Clients wishing to abort computation in response to an\n+    /// allocation error are encouraged to call the [`handle_alloc_error`] function,\n+    /// rather than directly invoking `panic!` or similar.\n+    ///\n+    /// [`handle_alloc_error`]: ../../alloc/alloc/fn.handle_alloc_error.html\n+    unsafe fn alloc_excess_zeroed(&mut self, layout: Layout) -> Result<Excess, AllocErr> {\n+        let usable_size = self.usable_size(&layout);\n+        self.alloc_zeroed(layout).map(|p| Excess(p, usable_size.1))\n+    }\n+\n     /// Behaves like `realloc`, but also returns the whole size of\n     /// the returned block. For some `layout` inputs, like arrays, this\n     /// may include extra storage usable for additional data.\n@@ -934,6 +1012,37 @@ pub unsafe trait AllocRef {\n         self.realloc(ptr, layout, new_size).map(|p| Excess(p, usable_size.1))\n     }\n \n+    /// Behaves like `realloc`, but also returns the whole size of\n+    /// the returned block. For some `layout` inputs, like arrays, this\n+    /// may include extra storage usable for additional data.\n+    /// Also it ensures that the contents are set to zero before being returned.\n+    ///\n+    /// # Safety\n+    ///\n+    /// This function is unsafe for the same reasons that `realloc` is.\n+    ///\n+    /// # Errors\n+    ///\n+    /// Returning `Err` indicates that either memory is exhausted or\n+    /// `layout` does not meet allocator's size or alignment\n+    /// constraints, just as in `realloc`.\n+    ///\n+    /// Clients wishing to abort computation in response to a\n+    /// reallocation error are encouraged to call the [`handle_alloc_error`] function,\n+    /// rather than directly invoking `panic!` or similar.\n+    ///\n+    /// [`handle_alloc_error`]: ../../alloc/alloc/fn.handle_alloc_error.html\n+    unsafe fn realloc_excess_zeroed(\n+        &mut self,\n+        ptr: NonNull<u8>,\n+        layout: Layout,\n+        new_size: usize,\n+    ) -> Result<Excess, AllocErr> {\n+        let new_layout = Layout::from_size_align_unchecked(new_size, layout.align());\n+        let usable_size = self.usable_size(&new_layout);\n+        self.realloc_zeroed(ptr, layout, new_size).map(|p| Excess(p, usable_size.1))\n+    }\n+\n     /// Attempts to extend the allocation referenced by `ptr` to fit `new_size`.\n     ///\n     /// If this returns `Ok`, then the allocator has asserted that the\n@@ -983,6 +1092,34 @@ pub unsafe trait AllocRef {\n         if new_size <= u { Ok(()) } else { Err(CannotReallocInPlace) }\n     }\n \n+    /// Behaves like `grow_in_place`, but also ensures that the new\n+    /// contents are set to zero before being returned.\n+    ///\n+    /// # Safety\n+    ///\n+    /// This function is unsafe for the same reasons that `grow_in_place` is.\n+    ///\n+    /// # Errors\n+    ///\n+    /// Returns `Err(CannotReallocInPlace)` when the allocator is\n+    /// unable to assert that the memory block referenced by `ptr`\n+    /// could fit `layout`.\n+    ///\n+    /// Note that one cannot pass `CannotReallocInPlace` to the `handle_alloc_error`\n+    /// function; clients are expected either to be able to recover from\n+    /// `grow_in_place` failures without aborting, or to fall back on\n+    /// another reallocation method before resorting to an abort.\n+    unsafe fn grow_in_place_zeroed(\n+        &mut self,\n+        ptr: NonNull<u8>,\n+        layout: Layout,\n+        new_size: usize,\n+    ) -> Result<(), CannotReallocInPlace> {\n+        self.grow_in_place(ptr, layout, new_size)?;\n+        ptr.as_ptr().add(layout.size()).write_bytes(0, new_size - layout.size());\n+        Ok(())\n+    }\n+\n     /// Attempts to shrink the allocation referenced by `ptr` to fit `new_size`.\n     ///\n     /// If this returns `Ok`, then the allocator has asserted that the"}]}