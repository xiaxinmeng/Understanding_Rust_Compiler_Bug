{"sha": "b139669f374eb5024a50eb13f116ff763b1c5935", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIxMzk2NjlmMzc0ZWI1MDI0YTUwZWIxM2YxMTZmZjc2M2IxYzU5MzU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-02-06T08:42:46Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-02-06T08:42:46Z"}, "message": "Auto merge of #56123 - oli-obk:import_miri_from_future, r=eddyb\n\nAdd a forever unstable opt-out of const qualification checks\n\nr? @eddyb\n\ncc @RalfJung @Centril\n\nbasically a forever unstable way to screw with const things in horribly unsafe, unsound and incoherent ways.\n\nNote that this does *not* affect miri except by maybe violating assumptions that miri makes. But there's no change in how miri evaluates things.", "tree": {"sha": "12152acd76da8949f63ece352d6fe83718516f79", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/12152acd76da8949f63ece352d6fe83718516f79"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b139669f374eb5024a50eb13f116ff763b1c5935", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b139669f374eb5024a50eb13f116ff763b1c5935", "html_url": "https://github.com/rust-lang/rust/commit/b139669f374eb5024a50eb13f116ff763b1c5935", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b139669f374eb5024a50eb13f116ff763b1c5935/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2596bc1368d1e3d34c9a7841ad87a3100f01cbad", "url": "https://api.github.com/repos/rust-lang/rust/commits/2596bc1368d1e3d34c9a7841ad87a3100f01cbad", "html_url": "https://github.com/rust-lang/rust/commit/2596bc1368d1e3d34c9a7841ad87a3100f01cbad"}, {"sha": "d0129a613c3bd4581826bb838eea1ab96c2cd5c7", "url": "https://api.github.com/repos/rust-lang/rust/commits/d0129a613c3bd4581826bb838eea1ab96c2cd5c7", "html_url": "https://github.com/rust-lang/rust/commit/d0129a613c3bd4581826bb838eea1ab96c2cd5c7"}], "stats": {"total": 157, "additions": 155, "deletions": 2}, "files": [{"sha": "3c2f454eefec71640437d580a3724792879c4384", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b139669f374eb5024a50eb13f116ff763b1c5935/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b139669f374eb5024a50eb13f116ff763b1c5935/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=b139669f374eb5024a50eb13f116ff763b1c5935", "patch": "@@ -1305,6 +1305,8 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n         \"print some statistics about AST and HIR\"),\n     always_encode_mir: bool = (false, parse_bool, [TRACKED],\n         \"encode MIR of all functions into the crate metadata\"),\n+    unleash_the_miri_inside_of_you: bool = (false, parse_bool, [TRACKED],\n+        \"take the breaks off const evaluation. NOTE: this is unsound\"),\n     osx_rpath_install_name: bool = (false, parse_bool, [TRACKED],\n         \"pass `-install_name @rpath/...` to the macOS linker\"),\n     sanitizer: Option<Sanitizer> = (None, parse_sanitizer, [TRACKED],"}, {"sha": "7d1943e21b90d71185dea6eb9c5c44221348c80b", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 27, "deletions": 2, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/b139669f374eb5024a50eb13f116ff763b1c5935/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b139669f374eb5024a50eb13f116ff763b1c5935/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=b139669f374eb5024a50eb13f116ff763b1c5935", "patch": "@@ -108,6 +108,15 @@ struct Qualifier<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     promotion_candidates: Vec<Candidate>\n }\n \n+macro_rules! unleash_miri {\n+    ($this:expr) => {{\n+        if $this.tcx.sess.opts.debugging_opts.unleash_the_miri_inside_of_you {\n+            $this.tcx.sess.span_warn($this.span, \"skipping const checks\");\n+            return;\n+        }\n+    }}\n+}\n+\n impl<'a, 'tcx> Qualifier<'a, 'tcx, 'tcx> {\n     fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n            def_id: DefId,\n@@ -147,6 +156,7 @@ impl<'a, 'tcx> Qualifier<'a, 'tcx, 'tcx> {\n     // categories, but enabling full miri would make that\n     // slightly pointless (even with feature-gating).\n     fn not_const(&mut self) {\n+        unleash_miri!(self);\n         self.add(Qualif::NOT_CONST);\n         if self.mode != Mode::Fn {\n             let mut err = struct_span_err!(\n@@ -419,6 +429,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n                     }\n                     return;\n                 }\n+                unleash_miri!(self);\n                 self.add(Qualif::NOT_CONST);\n \n                 if self.mode != Mode::Fn {\n@@ -618,6 +629,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n                     }\n \n                     if forbidden_mut {\n+                        unleash_miri!(self);\n                         self.add(Qualif::NOT_CONST);\n                         if self.mode != Mode::Fn {\n                             let mut err = struct_span_err!(self.tcx.sess,  self.span, E0017,\n@@ -660,6 +672,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n \n                 debug!(\"visit_rvalue: forbidden_mut={:?}\", forbidden_mut);\n                 if forbidden_mut {\n+                    unleash_miri!(self);\n                     self.add(Qualif::NOT_CONST);\n                 } else {\n                     // We might have a candidate for promotion.\n@@ -700,6 +713,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n                 match (cast_in, cast_out) {\n                     (CastTy::Ptr(_), CastTy::Int(_)) |\n                     (CastTy::FnPtr, CastTy::Int(_)) => {\n+                        unleash_miri!(self);\n                         if let Mode::Fn = self.mode {\n                             // in normal functions, mark such casts as not promotable\n                             self.add(Qualif::NOT_CONST);\n@@ -727,6 +741,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n                             op == BinOp::Ge || op == BinOp::Gt ||\n                             op == BinOp::Offset);\n \n+                    unleash_miri!(self);\n                     if let Mode::Fn = self.mode {\n                         // raw pointer operations are not allowed inside promoteds\n                         self.add(Qualif::NOT_CONST);\n@@ -745,6 +760,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n             }\n \n             Rvalue::NullaryOp(NullOp::Box, _) => {\n+                unleash_miri!(self);\n                 self.add(Qualif::NOT_CONST);\n                 if self.mode != Mode::Fn {\n                     let mut err = struct_span_err!(self.tcx.sess, self.span, E0010,\n@@ -861,7 +877,13 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n                             } else {\n                                 // stable const fns or unstable const fns with their feature gate\n                                 // active\n-                                if self.tcx.is_const_fn(def_id) {\n+                                let unleash_miri = self\n+                                    .tcx\n+                                    .sess\n+                                    .opts\n+                                    .debugging_opts\n+                                    .unleash_the_miri_inside_of_you;\n+                                if self.tcx.is_const_fn(def_id) || unleash_miri {\n                                     is_const_fn = true;\n                                 } else if self.is_const_panic_fn(def_id) {\n                                     // Check the const_panic feature gate.\n@@ -1030,6 +1052,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n \n             // Deny *any* live drops anywhere other than functions.\n             if self.mode != Mode::Fn {\n+                unleash_miri!(self);\n                 // HACK(eddyb): emulate a bit of dataflow analysis,\n                 // conservatively, that drop elaboration will do.\n                 let needs_drop = if let Place::Local(local) = *place {\n@@ -1175,7 +1198,9 @@ impl MirPass for QualifyAndPromoteConstants {\n             let (temps, candidates) = {\n                 let mut qualifier = Qualifier::new(tcx, def_id, mir, mode);\n                 if mode == Mode::ConstFn {\n-                    if tcx.is_min_const_fn(def_id) {\n+                    if tcx.sess.opts.debugging_opts.unleash_the_miri_inside_of_you {\n+                        qualifier.qualify_const();\n+                    } else if tcx.is_min_const_fn(def_id) {\n                         // enforce `min_const_fn` for stable const fns\n                         use super::qualify_min_const_fn::is_min_const_fn;\n                         if let Err((span, err)) = is_min_const_fn(tcx, def_id, mir) {"}, {"sha": "b8959667cc215bb9eabdfe55a0d3a11c959c44d0", "filename": "src/test/ui/consts/miri_unleashed/assoc_const.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/b139669f374eb5024a50eb13f116ff763b1c5935/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fassoc_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b139669f374eb5024a50eb13f116ff763b1c5935/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fassoc_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fassoc_const.rs?ref=b139669f374eb5024a50eb13f116ff763b1c5935", "patch": "@@ -0,0 +1,30 @@\n+// compile-flags: -Zunleash-the-miri-inside-of-you\n+#![allow(const_err)]\n+\n+// a test demonstrating why we do need to run static const qualification on associated constants\n+// instead of just checking the final constant\n+\n+trait Foo<T> {\n+    const X: T;\n+}\n+\n+trait Bar<T, U: Foo<T>> {\n+    const F: u32 = (U::X, 42).1; //~ WARN skipping const checks\n+}\n+\n+impl Foo<u32> for () {\n+    const X: u32 = 42;\n+}\n+impl Foo<Vec<u32>> for String {\n+    const X: Vec<u32> = Vec::new();\n+}\n+\n+impl Bar<u32, ()> for () {}\n+impl Bar<Vec<u32>, String> for String {}\n+\n+fn main() {\n+    // this is fine, but would have been forbidden by the static checks on `F`\n+    let x = <() as Bar<u32, ()>>::F;\n+    // this test only causes errors due to the line below, so post-monomorphization\n+    let y = <String as Bar<Vec<u32>, String>>::F; //~ ERROR erroneous constant\n+}"}, {"sha": "a40f8d46d0aa7881bab9d8ee273b8e48105e4fc4", "filename": "src/test/ui/consts/miri_unleashed/assoc_const.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/b139669f374eb5024a50eb13f116ff763b1c5935/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fassoc_const.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b139669f374eb5024a50eb13f116ff763b1c5935/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fassoc_const.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fassoc_const.stderr?ref=b139669f374eb5024a50eb13f116ff763b1c5935", "patch": "@@ -0,0 +1,15 @@\n+warning: skipping const checks\n+  --> $DIR/assoc_const.rs:12:31\n+   |\n+LL |     const F: u32 = (U::X, 42).1; //~ WARN skipping const checks\n+   |                               ^\n+\n+error[E0080]: erroneous constant used\n+  --> $DIR/assoc_const.rs:29:13\n+   |\n+LL |     let y = <String as Bar<Vec<u32>, String>>::F; //~ ERROR erroneous constant\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ referenced constant has errors\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0080`."}, {"sha": "c87b6389848f41bc05d39fd4668c35c5cfb7499b", "filename": "src/test/ui/consts/miri_unleashed/assoc_const_2.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/b139669f374eb5024a50eb13f116ff763b1c5935/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fassoc_const_2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b139669f374eb5024a50eb13f116ff763b1c5935/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fassoc_const_2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fassoc_const_2.rs?ref=b139669f374eb5024a50eb13f116ff763b1c5935", "patch": "@@ -0,0 +1,28 @@\n+#![allow(const_err)]\n+\n+// a test demonstrating that const qualification cannot prevent monomorphization time errors\n+\n+trait Foo {\n+    const X: u32;\n+}\n+\n+trait Bar<U: Foo> {\n+    const F: u32 = 100 / U::X;\n+}\n+\n+impl Foo for () {\n+    const X: u32 = 42;\n+}\n+\n+impl Foo for String {\n+    const X: u32 = 0;\n+}\n+\n+impl Bar<()> for () {}\n+impl Bar<String> for String {}\n+\n+fn main() {\n+    let x = <() as Bar<()>>::F;\n+    // this test only causes errors due to the line below, so post-monomorphization\n+    let y = <String as Bar<String>>::F; //~ ERROR erroneous constant\n+}"}, {"sha": "77aab31d26ec3b8b2500cfd536158c9f19f8beac", "filename": "src/test/ui/consts/miri_unleashed/assoc_const_2.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b139669f374eb5024a50eb13f116ff763b1c5935/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fassoc_const_2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b139669f374eb5024a50eb13f116ff763b1c5935/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fassoc_const_2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fassoc_const_2.stderr?ref=b139669f374eb5024a50eb13f116ff763b1c5935", "patch": "@@ -0,0 +1,9 @@\n+error[E0080]: erroneous constant used\n+  --> $DIR/assoc_const_2.rs:27:13\n+   |\n+LL |     let y = <String as Bar<String>>::F; //~ ERROR erroneous constant\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^ referenced constant has errors\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0080`."}, {"sha": "5fb92535502a58fb2a98167b5d2fb522b3b8b8a5", "filename": "src/test/ui/consts/miri_unleashed/feature-gate-unleash_the_miri_inside_of_you.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/b139669f374eb5024a50eb13f116ff763b1c5935/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Ffeature-gate-unleash_the_miri_inside_of_you.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b139669f374eb5024a50eb13f116ff763b1c5935/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Ffeature-gate-unleash_the_miri_inside_of_you.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Ffeature-gate-unleash_the_miri_inside_of_you.rs?ref=b139669f374eb5024a50eb13f116ff763b1c5935", "patch": "@@ -0,0 +1,27 @@\n+#![allow(const_err)]\n+\n+// a test demonstrating why we do need to run static const qualification on associated constants\n+// instead of just checking the final constant\n+\n+trait Foo<T> {\n+    const X: T;\n+}\n+\n+trait Bar<T, U: Foo<T>> {\n+    const F: u32 = (U::X, 42).1; //~ ERROR destructors cannot be evaluated at compile-time\n+}\n+\n+impl Foo<u32> for () {\n+    const X: u32 = 42;\n+}\n+impl Foo<Vec<u32>> for String {\n+    const X: Vec<u32> = Vec::new(); //~ ERROR not yet stable as a const fn\n+}\n+\n+impl Bar<u32, ()> for () {}\n+impl Bar<Vec<u32>, String> for String {}\n+\n+fn main() {\n+    let x = <() as Bar<u32, ()>>::F;\n+    let y = <String as Bar<Vec<u32>, String>>::F;\n+}"}, {"sha": "e23ed1c6206399a21e24787fd5cb3c68e2e26180", "filename": "src/test/ui/consts/miri_unleashed/feature-gate-unleash_the_miri_inside_of_you.stderr", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/b139669f374eb5024a50eb13f116ff763b1c5935/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Ffeature-gate-unleash_the_miri_inside_of_you.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b139669f374eb5024a50eb13f116ff763b1c5935/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Ffeature-gate-unleash_the_miri_inside_of_you.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Ffeature-gate-unleash_the_miri_inside_of_you.stderr?ref=b139669f374eb5024a50eb13f116ff763b1c5935", "patch": "@@ -0,0 +1,17 @@\n+error[E0493]: destructors cannot be evaluated at compile-time\n+  --> $DIR/feature-gate-unleash_the_miri_inside_of_you.rs:11:20\n+   |\n+LL |     const F: u32 = (U::X, 42).1; //~ ERROR destructors cannot be evaluated at compile-time\n+   |                    ^^^^^^^^^^ constants cannot evaluate destructors\n+\n+error: `<std::vec::Vec<T>>::new` is not yet stable as a const fn\n+  --> $DIR/feature-gate-unleash_the_miri_inside_of_you.rs:18:25\n+   |\n+LL |     const X: Vec<u32> = Vec::new(); //~ ERROR not yet stable as a const fn\n+   |                         ^^^^^^^^^^\n+   |\n+   = help: add `#![feature(const_vec_new)]` to the crate attributes to enable\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0493`."}]}