{"sha": "7e277d96feffdab52faef3fe5198a550d126db6d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdlMjc3ZDk2ZmVmZmRhYjUyZmFlZjNmZTUxOThhNTUwZDEyNmRiNmQ=", "commit": {"author": {"name": "ljedrz", "email": "ljedrz@gmail.com", "date": "2019-02-27T14:56:24Z"}, "committer": {"name": "ljedrz", "email": "ljedrz@gmail.com", "date": "2019-03-02T06:48:52Z"}, "message": "middle & privacy: partially HirIdify", "tree": {"sha": "22c2c3102239605ce3502ace597b0d0252b005a6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/22c2c3102239605ce3502ace597b0d0252b005a6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7e277d96feffdab52faef3fe5198a550d126db6d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7e277d96feffdab52faef3fe5198a550d126db6d", "html_url": "https://github.com/rust-lang/rust/commit/7e277d96feffdab52faef3fe5198a550d126db6d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7e277d96feffdab52faef3fe5198a550d126db6d/comments", "author": {"login": "ljedrz", "id": 3750347, "node_id": "MDQ6VXNlcjM3NTAzNDc=", "avatar_url": "https://avatars.githubusercontent.com/u/3750347?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ljedrz", "html_url": "https://github.com/ljedrz", "followers_url": "https://api.github.com/users/ljedrz/followers", "following_url": "https://api.github.com/users/ljedrz/following{/other_user}", "gists_url": "https://api.github.com/users/ljedrz/gists{/gist_id}", "starred_url": "https://api.github.com/users/ljedrz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ljedrz/subscriptions", "organizations_url": "https://api.github.com/users/ljedrz/orgs", "repos_url": "https://api.github.com/users/ljedrz/repos", "events_url": "https://api.github.com/users/ljedrz/events{/privacy}", "received_events_url": "https://api.github.com/users/ljedrz/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ljedrz", "id": 3750347, "node_id": "MDQ6VXNlcjM3NTAzNDc=", "avatar_url": "https://avatars.githubusercontent.com/u/3750347?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ljedrz", "html_url": "https://github.com/ljedrz", "followers_url": "https://api.github.com/users/ljedrz/followers", "following_url": "https://api.github.com/users/ljedrz/following{/other_user}", "gists_url": "https://api.github.com/users/ljedrz/gists{/gist_id}", "starred_url": "https://api.github.com/users/ljedrz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ljedrz/subscriptions", "organizations_url": "https://api.github.com/users/ljedrz/orgs", "repos_url": "https://api.github.com/users/ljedrz/repos", "events_url": "https://api.github.com/users/ljedrz/events{/privacy}", "received_events_url": "https://api.github.com/users/ljedrz/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d987b46bd7e81eb761a06252efb35b6d932a62f5", "url": "https://api.github.com/repos/rust-lang/rust/commits/d987b46bd7e81eb761a06252efb35b6d932a62f5", "html_url": "https://github.com/rust-lang/rust/commit/d987b46bd7e81eb761a06252efb35b6d932a62f5"}], "stats": {"total": 226, "additions": 120, "deletions": 106}, "files": [{"sha": "55a9b2477cfa485a2351a0338a7168b396d0972a", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 35, "deletions": 29, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/7e277d96feffdab52faef3fe5198a550d126db6d/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e277d96feffdab52faef3fe5198a550d126db6d/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=7e277d96feffdab52faef3fe5198a550d126db6d", "patch": "@@ -14,10 +14,9 @@ use crate::ty::{self, TyCtxt};\n use crate::ty::query::Providers;\n use crate::middle::privacy;\n use crate::session::config;\n-use crate::util::nodemap::{NodeSet, FxHashSet};\n+use crate::util::nodemap::{HirIdSet, FxHashSet};\n \n use rustc_target::spec::abi::Abi;\n-use syntax::ast;\n use crate::hir;\n use crate::hir::def_id::LOCAL_CRATE;\n use crate::hir::intravisit::{Visitor, NestedVisitorMap};\n@@ -70,10 +69,10 @@ struct ReachableContext<'a, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     tables: &'a ty::TypeckTables<'tcx>,\n     // The set of items which must be exported in the linkage sense.\n-    reachable_symbols: NodeSet,\n+    reachable_symbols: HirIdSet,\n     // A worklist of item IDs. Each item ID in this worklist will be inlined\n     // and will be scanned for further references.\n-    worklist: Vec<ast::NodeId>,\n+    worklist: Vec<hir::HirId>,\n     // Whether any output of this compilation is a library\n     any_library: bool,\n }\n@@ -104,27 +103,28 @@ impl<'a, 'tcx> Visitor<'tcx> for ReachableContext<'a, 'tcx> {\n \n         match def {\n             Some(Def::Local(node_id)) | Some(Def::Upvar(node_id, ..)) => {\n-                self.reachable_symbols.insert(node_id);\n+                let hir_id = self.tcx.hir().node_to_hir_id(node_id);\n+                self.reachable_symbols.insert(hir_id);\n             }\n             Some(def) => {\n-                if let Some((node_id, def_id)) = def.opt_def_id().and_then(|def_id| {\n-                    self.tcx.hir().as_local_node_id(def_id).map(|node_id| (node_id, def_id))\n+                if let Some((hir_id, def_id)) = def.opt_def_id().and_then(|def_id| {\n+                    self.tcx.hir().as_local_hir_id(def_id).map(|hir_id| (hir_id, def_id))\n                 }) {\n                     if self.def_id_represents_local_inlined_item(def_id) {\n-                        self.worklist.push(node_id);\n+                        self.worklist.push(hir_id);\n                     } else {\n                         match def {\n                             // If this path leads to a constant, then we need to\n                             // recurse into the constant to continue finding\n                             // items that are reachable.\n                             Def::Const(..) | Def::AssociatedConst(..) => {\n-                                self.worklist.push(node_id);\n+                                self.worklist.push(hir_id);\n                             }\n \n                             // If this wasn't a static, then the destination is\n                             // surely reachable.\n                             _ => {\n-                                self.reachable_symbols.insert(node_id);\n+                                self.reachable_symbols.insert(hir_id);\n                             }\n                         }\n                     }\n@@ -204,14 +204,14 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n                 continue\n             }\n \n-            if let Some(ref item) = self.tcx.hir().find(search_item) {\n+            if let Some(ref item) = self.tcx.hir().find_by_hir_id(search_item) {\n                 self.propagate_node(item, search_item);\n             }\n         }\n     }\n \n     fn propagate_node(&mut self, node: &Node<'tcx>,\n-                      search_item: ast::NodeId) {\n+                      search_item: hir::HirId) {\n         if !self.any_library {\n             // If we are building an executable, only explicitly extern\n             // types need to be exported.\n@@ -221,7 +221,7 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n                 } else {\n                     false\n                 };\n-                let def_id = self.tcx.hir().local_def_id(item.id);\n+                let def_id = self.tcx.hir().local_def_id_from_hir_id(item.hir_id);\n                 let codegen_attrs = self.tcx.codegen_fn_attrs(def_id);\n                 let is_extern = codegen_attrs.contains_extern_indicator();\n                 let std_internal = codegen_attrs.flags.contains(\n@@ -242,7 +242,7 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n             Node::Item(item) => {\n                 match item.node {\n                     hir::ItemKind::Fn(.., body) => {\n-                        let def_id = self.tcx.hir().local_def_id(item.id);\n+                        let def_id = self.tcx.hir().local_def_id_from_hir_id(item.hir_id);\n                         if item_might_be_inlined(self.tcx,\n                                                  &item,\n                                                  self.tcx.codegen_fn_attrs(def_id)) {\n@@ -295,7 +295,7 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n                         self.visit_nested_body(body);\n                     }\n                     hir::ImplItemKind::Method(_, body) => {\n-                        let did = self.tcx.hir().get_parent_did(search_item);\n+                        let did = self.tcx.hir().get_parent_did_by_hir_id(search_item);\n                         if method_might_be_inlined(self.tcx, impl_item, did) {\n                             self.visit_nested_body(body)\n                         }\n@@ -317,7 +317,7 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n             _ => {\n                 bug!(\n                     \"found unexpected node kind in worklist: {} ({:?})\",\n-                    self.tcx.hir().node_to_string(search_item),\n+                    self.tcx.hir().hir_to_string(search_item),\n                     node,\n                 );\n             }\n@@ -336,7 +336,7 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n struct CollectPrivateImplItemsVisitor<'a, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     access_levels: &'a privacy::AccessLevels,\n-    worklist: &'a mut Vec<ast::NodeId>,\n+    worklist: &'a mut Vec<hir::HirId>,\n }\n \n impl<'a, 'tcx: 'a> ItemLikeVisitor<'tcx> for CollectPrivateImplItemsVisitor<'a, 'tcx> {\n@@ -348,13 +348,18 @@ impl<'a, 'tcx: 'a> ItemLikeVisitor<'tcx> for CollectPrivateImplItemsVisitor<'a,\n         let codegen_attrs = self.tcx.codegen_fn_attrs(def_id);\n         if codegen_attrs.contains_extern_indicator() ||\n             codegen_attrs.flags.contains(CodegenFnAttrFlags::RUSTC_STD_INTERNAL_SYMBOL) {\n-            self.worklist.push(item.id);\n+            self.worklist.push(item.hir_id);\n         }\n \n         // We need only trait impls here, not inherent impls, and only non-exported ones\n         if let hir::ItemKind::Impl(.., Some(ref trait_ref), _, ref impl_item_refs) = item.node {\n-            if !self.access_levels.is_reachable(item.id) {\n-                self.worklist.extend(impl_item_refs.iter().map(|r| r.id.node_id));\n+            let node_id = self.tcx.hir().hir_to_node_id(item.hir_id);\n+            if !self.access_levels.is_reachable(node_id) {\n+                // FIXME(@ljedrz): rework back to a nice extend when item Ids contain HirId\n+                for impl_item_ref in impl_item_refs {\n+                    let hir_id = self.tcx.hir().node_to_hir_id(impl_item_ref.id.node_id);\n+                    self.worklist.push(hir_id);\n+                }\n \n                 let trait_def_id = match trait_ref.path.def {\n                     Def::Trait(def_id) => def_id,\n@@ -368,11 +373,11 @@ impl<'a, 'tcx: 'a> ItemLikeVisitor<'tcx> for CollectPrivateImplItemsVisitor<'a,\n                 let provided_trait_methods = self.tcx.provided_trait_methods(trait_def_id);\n                 self.worklist.reserve(provided_trait_methods.len());\n                 for default_method in provided_trait_methods {\n-                    let node_id = self.tcx\n-                                      .hir()\n-                                      .as_local_node_id(default_method.def_id)\n-                                      .unwrap();\n-                    self.worklist.push(node_id);\n+                    let hir_id = self.tcx\n+                                     .hir()\n+                                     .as_local_hir_id(default_method.def_id)\n+                                     .unwrap();\n+                    self.worklist.push(hir_id);\n                 }\n             }\n         }\n@@ -388,7 +393,7 @@ impl<'a, 'tcx: 'a> ItemLikeVisitor<'tcx> for CollectPrivateImplItemsVisitor<'a,\n // We introduce a new-type here, so we can have a specialized HashStable\n // implementation for it.\n #[derive(Clone)]\n-pub struct ReachableSet(pub Lrc<NodeSet>);\n+pub struct ReachableSet(pub Lrc<HirIdSet>);\n \n fn reachable_set<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, crate_num: CrateNum) -> ReachableSet {\n     debug_assert!(crate_num == LOCAL_CRATE);\n@@ -412,11 +417,12 @@ fn reachable_set<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, crate_num: CrateNum) ->\n     //         If other crates link to us, they're going to expect to be able to\n     //         use the lang items, so we need to be sure to mark them as\n     //         exported.\n-    reachable_context.worklist.extend(access_levels.map.iter().map(|(id, _)| *id));\n+    reachable_context.worklist.extend(\n+        access_levels.map.iter().map(|(id, _)| tcx.hir().node_to_hir_id(*id)));\n     for item in tcx.lang_items().items().iter() {\n         if let Some(did) = *item {\n-            if let Some(node_id) = tcx.hir().as_local_node_id(did) {\n-                reachable_context.worklist.push(node_id);\n+            if let Some(hir_id) = tcx.hir().as_local_hir_id(did) {\n+                reachable_context.worklist.push(hir_id);\n             }\n         }\n     }"}, {"sha": "7bd0d746bcb61ba5ddd8ff4e50e22b1247541d82", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 85, "deletions": 77, "changes": 162, "blob_url": "https://github.com/rust-lang/rust/blob/7e277d96feffdab52faef3fe5198a550d126db6d/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e277d96feffdab52faef3fe5198a550d126db6d/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=7e277d96feffdab52faef3fe5198a550d126db6d", "patch": "@@ -24,7 +24,7 @@ use rustc::ty::subst::InternalSubsts;\n use rustc::util::nodemap::HirIdSet;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::sync::Lrc;\n-use syntax::ast::{self, DUMMY_NODE_ID, Ident};\n+use syntax::ast::Ident;\n use syntax::attr;\n use syntax::symbol::keywords;\n use syntax_pos::Span;\n@@ -349,10 +349,10 @@ trait VisibilityLike: Sized {\n \n     // Returns an over-approximation (`skip_assoc_tys` = true) of visibility due to\n     // associated types for which we can't determine visibility precisely.\n-    fn of_impl<'a, 'tcx>(node_id: ast::NodeId, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    fn of_impl<'a, 'tcx>(hir_id: hir::HirId, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                          access_levels: &'a AccessLevels) -> Self {\n         let mut find = FindMin { tcx, access_levels, min: Self::MAX };\n-        let def_id = tcx.hir().local_def_id(node_id);\n+        let def_id = tcx.hir().local_def_id_from_hir_id(hir_id);\n         find.visit(tcx.type_of(def_id));\n         if let Some(trait_ref) = tcx.impl_trait_ref(def_id) {\n             find.visit_trait(trait_ref);\n@@ -409,28 +409,30 @@ struct ReachEverythingInTheInterfaceVisitor<'b, 'a: 'b, 'tcx: 'a> {\n }\n \n impl<'a, 'tcx> EmbargoVisitor<'a, 'tcx> {\n-    fn get(&self, id: ast::NodeId) -> Option<AccessLevel> {\n-        self.access_levels.map.get(&id).cloned()\n+    fn get(&self, id: hir::HirId) -> Option<AccessLevel> {\n+        let node_id = self.tcx.hir().hir_to_node_id(id);\n+        self.access_levels.map.get(&node_id).cloned()\n     }\n \n     // Updates node level and returns the updated level.\n-    fn update(&mut self, id: ast::NodeId, level: Option<AccessLevel>) -> Option<AccessLevel> {\n+    fn update(&mut self, id: hir::HirId, level: Option<AccessLevel>) -> Option<AccessLevel> {\n         let old_level = self.get(id);\n         // Accessibility levels can only grow.\n         if level > old_level {\n-            self.access_levels.map.insert(id, level.unwrap());\n+            let node_id = self.tcx.hir().hir_to_node_id(id);\n+            self.access_levels.map.insert(node_id, level.unwrap());\n             self.changed = true;\n             level\n         } else {\n             old_level\n         }\n     }\n \n-    fn reach(&mut self, item_id: ast::NodeId, access_level: Option<AccessLevel>)\n+    fn reach(&mut self, item_id: hir::HirId, access_level: Option<AccessLevel>)\n              -> ReachEverythingInTheInterfaceVisitor<'_, 'a, 'tcx> {\n         ReachEverythingInTheInterfaceVisitor {\n             access_level: cmp::min(access_level, Some(AccessLevel::Reachable)),\n-            item_def_id: self.tcx.hir().local_def_id(item_id),\n+            item_def_id: self.tcx.hir().local_def_id_from_hir_id(item_id),\n             ev: self,\n         }\n     }\n@@ -464,7 +466,7 @@ impl<'a, 'tcx> EmbargoVisitor<'a, 'tcx> {\n                         let def_id = self.tcx.hir().local_def_id(item_id.id);\n                         if !self.tcx.hygienic_eq(segment.ident, item.ident, def_id) { continue; }\n                         if let hir::ItemKind::Use(..) = item.node {\n-                            self.update(item.id, Some(AccessLevel::Exported));\n+                            self.update(item.hir_id, Some(AccessLevel::Exported));\n                         }\n                     }\n                 }\n@@ -483,7 +485,7 @@ impl<'a, 'tcx> Visitor<'tcx> for EmbargoVisitor<'a, 'tcx> {\n     fn visit_item(&mut self, item: &'tcx hir::Item) {\n         let inherited_item_level = match item.node {\n             hir::ItemKind::Impl(..) =>\n-                Option::<AccessLevel>::of_impl(item.id, self.tcx, &self.access_levels),\n+                Option::<AccessLevel>::of_impl(item.hir_id, self.tcx, &self.access_levels),\n             // Foreign modules inherit level from parents.\n             hir::ItemKind::ForeignMod(..) => self.prev_level,\n             // Other `pub` items inherit levels from parents.\n@@ -498,44 +500,46 @@ impl<'a, 'tcx> Visitor<'tcx> for EmbargoVisitor<'a, 'tcx> {\n         };\n \n         // Update level of the item itself.\n-        let item_level = self.update(item.id, inherited_item_level);\n+        let item_level = self.update(item.hir_id, inherited_item_level);\n \n         // Update levels of nested things.\n         match item.node {\n             hir::ItemKind::Enum(ref def, _) => {\n                 for variant in &def.variants {\n-                    let variant_level = self.update(variant.node.data.id(), item_level);\n+                    let variant_level = self.update(variant.node.data.hir_id(), item_level);\n                     for field in variant.node.data.fields() {\n-                        self.update(field.id, variant_level);\n+                        self.update(field.hir_id, variant_level);\n                     }\n                 }\n             }\n             hir::ItemKind::Impl(.., ref trait_ref, _, ref impl_item_refs) => {\n                 for impl_item_ref in impl_item_refs {\n                     if trait_ref.is_some() || impl_item_ref.vis.node.is_pub() {\n-                        self.update(impl_item_ref.id.node_id, item_level);\n+                        let hir_id = self.tcx.hir().node_to_hir_id(impl_item_ref.id.node_id);\n+                        self.update(hir_id, item_level);\n                     }\n                 }\n             }\n             hir::ItemKind::Trait(.., ref trait_item_refs) => {\n                 for trait_item_ref in trait_item_refs {\n-                    self.update(trait_item_ref.id.node_id, item_level);\n+                    let hir_id = self.tcx.hir().node_to_hir_id(trait_item_ref.id.node_id);\n+                    self.update(hir_id, item_level);\n                 }\n             }\n             hir::ItemKind::Struct(ref def, _) | hir::ItemKind::Union(ref def, _) => {\n                 if !def.is_struct() {\n-                    self.update(def.id(), item_level);\n+                    self.update(def.hir_id(), item_level);\n                 }\n                 for field in def.fields() {\n                     if field.vis.node.is_pub() {\n-                        self.update(field.id, item_level);\n+                        self.update(field.hir_id, item_level);\n                     }\n                 }\n             }\n             hir::ItemKind::ForeignMod(ref foreign_mod) => {\n                 for foreign_item in &foreign_mod.items {\n                     if foreign_item.vis.node.is_pub() {\n-                        self.update(foreign_item.id, item_level);\n+                        self.update(foreign_item.hir_id, item_level);\n                     }\n                 }\n             }\n@@ -572,21 +576,22 @@ impl<'a, 'tcx> Visitor<'tcx> for EmbargoVisitor<'a, 'tcx> {\n                 // in the reachability pass (`middle/reachable.rs`). Types are marked as link-time\n                 // reachable if they are returned via `impl Trait`, even from private functions.\n                 let exist_level = cmp::max(item_level, Some(AccessLevel::ReachableFromImplTrait));\n-                self.reach(item.id, exist_level).generics().predicates().ty();\n+                self.reach(item.hir_id, exist_level).generics().predicates().ty();\n             }\n             // Visit everything.\n             hir::ItemKind::Const(..) | hir::ItemKind::Static(..) |\n             hir::ItemKind::Fn(..) | hir::ItemKind::Ty(..) => {\n                 if item_level.is_some() {\n-                    self.reach(item.id, item_level).generics().predicates().ty();\n+                    self.reach(item.hir_id, item_level).generics().predicates().ty();\n                 }\n             }\n             hir::ItemKind::Trait(.., ref trait_item_refs) => {\n                 if item_level.is_some() {\n-                    self.reach(item.id, item_level).generics().predicates();\n+                    self.reach(item.hir_id, item_level).generics().predicates();\n \n                     for trait_item_ref in trait_item_refs {\n-                        let mut reach = self.reach(trait_item_ref.id.node_id, item_level);\n+                        let hir_id = self.tcx.hir().node_to_hir_id(trait_item_ref.id.node_id);\n+                        let mut reach = self.reach(hir_id, item_level);\n                         reach.generics().predicates();\n \n                         if trait_item_ref.kind == AssociatedItemKind::Type &&\n@@ -600,18 +605,19 @@ impl<'a, 'tcx> Visitor<'tcx> for EmbargoVisitor<'a, 'tcx> {\n             }\n             hir::ItemKind::TraitAlias(..) => {\n                 if item_level.is_some() {\n-                    self.reach(item.id, item_level).generics().predicates();\n+                    self.reach(item.hir_id, item_level).generics().predicates();\n                 }\n             }\n             // Visit everything except for private impl items.\n             hir::ItemKind::Impl(.., ref impl_item_refs) => {\n                 if item_level.is_some() {\n-                    self.reach(item.id, item_level).generics().predicates().ty().trait_ref();\n+                    self.reach(item.hir_id, item_level).generics().predicates().ty().trait_ref();\n \n                     for impl_item_ref in impl_item_refs {\n-                        let impl_item_level = self.get(impl_item_ref.id.node_id);\n+                        let hir_id = self.tcx.hir().node_to_hir_id(impl_item_ref.id.node_id);\n+                        let impl_item_level = self.get(hir_id);\n                         if impl_item_level.is_some() {\n-                            self.reach(impl_item_ref.id.node_id, impl_item_level)\n+                            self.reach(hir_id, impl_item_level)\n                                 .generics().predicates().ty();\n                         }\n                     }\n@@ -621,26 +627,26 @@ impl<'a, 'tcx> Visitor<'tcx> for EmbargoVisitor<'a, 'tcx> {\n             // Visit everything, but enum variants have their own levels.\n             hir::ItemKind::Enum(ref def, _) => {\n                 if item_level.is_some() {\n-                    self.reach(item.id, item_level).generics().predicates();\n+                    self.reach(item.hir_id, item_level).generics().predicates();\n                 }\n                 for variant in &def.variants {\n-                    let variant_level = self.get(variant.node.data.id());\n+                    let variant_level = self.get(variant.node.data.hir_id());\n                     if variant_level.is_some() {\n                         for field in variant.node.data.fields() {\n-                            self.reach(field.id, variant_level).ty();\n+                            self.reach(field.hir_id, variant_level).ty();\n                         }\n                         // Corner case: if the variant is reachable, but its\n                         // enum is not, make the enum reachable as well.\n-                        self.update(item.id, variant_level);\n+                        self.update(item.hir_id, variant_level);\n                     }\n                 }\n             }\n             // Visit everything, but foreign items have their own levels.\n             hir::ItemKind::ForeignMod(ref foreign_mod) => {\n                 for foreign_item in &foreign_mod.items {\n-                    let foreign_item_level = self.get(foreign_item.id);\n+                    let foreign_item_level = self.get(foreign_item.hir_id);\n                     if foreign_item_level.is_some() {\n-                        self.reach(foreign_item.id, foreign_item_level)\n+                        self.reach(foreign_item.hir_id, foreign_item_level)\n                             .generics().predicates().ty();\n                     }\n                 }\n@@ -649,11 +655,11 @@ impl<'a, 'tcx> Visitor<'tcx> for EmbargoVisitor<'a, 'tcx> {\n             hir::ItemKind::Struct(ref struct_def, _) |\n             hir::ItemKind::Union(ref struct_def, _) => {\n                 if item_level.is_some() {\n-                    self.reach(item.id, item_level).generics().predicates();\n+                    self.reach(item.hir_id, item_level).generics().predicates();\n                     for field in struct_def.fields() {\n-                        let field_level = self.get(field.id);\n+                        let field_level = self.get(field.hir_id);\n                         if field_level.is_some() {\n-                            self.reach(field.id, field_level).ty();\n+                            self.reach(field.hir_id, field_level).ty();\n                         }\n                     }\n                 }\n@@ -683,8 +689,8 @@ impl<'a, 'tcx> Visitor<'tcx> for EmbargoVisitor<'a, 'tcx> {\n                 for export in exports.iter() {\n                     if export.vis == ty::Visibility::Public {\n                         if let Some(def_id) = export.def.opt_def_id() {\n-                            if let Some(node_id) = self.tcx.hir().as_local_node_id(def_id) {\n-                                self.update(node_id, Some(AccessLevel::Exported));\n+                            if let Some(hir_id) = self.tcx.hir().as_local_hir_id(def_id) {\n+                                self.update(hir_id, Some(AccessLevel::Exported));\n                             }\n                         }\n                     }\n@@ -696,49 +702,48 @@ impl<'a, 'tcx> Visitor<'tcx> for EmbargoVisitor<'a, 'tcx> {\n     }\n \n     fn visit_macro_def(&mut self, md: &'tcx hir::MacroDef) {\n-        let node_id = self.tcx.hir().hir_to_node_id(md.hir_id);\n-\n         if md.legacy {\n-            self.update(node_id, Some(AccessLevel::Public));\n+            self.update(md.hir_id, Some(AccessLevel::Public));\n             return\n         }\n \n         let module_did = ty::DefIdTree::parent(\n             self.tcx,\n             self.tcx.hir().local_def_id_from_hir_id(md.hir_id)\n         ).unwrap();\n-        let mut module_id = self.tcx.hir().as_local_node_id(module_did).unwrap();\n+        let mut module_id = self.tcx.hir().as_local_hir_id(module_did).unwrap();\n         let level = if md.vis.node.is_pub() { self.get(module_id) } else { None };\n-        let level = self.update(node_id, level);\n+        let level = self.update(md.hir_id, level);\n         if level.is_none() {\n             return\n         }\n \n         loop {\n-            let module = if module_id == ast::CRATE_NODE_ID {\n+            let module = if module_id == hir::CRATE_HIR_ID {\n                 &self.tcx.hir().krate().module\n             } else if let hir::ItemKind::Mod(ref module) =\n-                          self.tcx.hir().expect_item(module_id).node {\n+                          self.tcx.hir().expect_item_by_hir_id(module_id).node {\n                 module\n             } else {\n                 unreachable!()\n             };\n             for id in &module.item_ids {\n-                self.update(id.id, level);\n+                let hir_id = self.tcx.hir().node_to_hir_id(id.id);\n+                self.update(hir_id, level);\n             }\n-            let def_id = self.tcx.hir().local_def_id(module_id);\n+            let def_id = self.tcx.hir().local_def_id_from_hir_id(module_id);\n             if let Some(exports) = self.tcx.module_exports(def_id) {\n                 for export in exports.iter() {\n-                    if let Some(node_id) = self.tcx.hir().as_local_node_id(export.def.def_id()) {\n-                        self.update(node_id, level);\n+                    if let Some(hir_id) = self.tcx.hir().as_local_hir_id(export.def.def_id()) {\n+                        self.update(hir_id, level);\n                     }\n                 }\n             }\n \n-            if module_id == ast::CRATE_NODE_ID {\n+            if module_id == hir::CRATE_HIR_ID {\n                 break\n             }\n-            module_id = self.tcx.hir().get_parent_node(module_id);\n+            module_id = self.tcx.hir().get_parent_node_by_hir_id(module_id);\n         }\n     }\n }\n@@ -779,8 +784,8 @@ impl<'a, 'tcx> ReachEverythingInTheInterfaceVisitor<'_, 'a, 'tcx> {\n impl<'a, 'tcx> DefIdVisitor<'a, 'tcx> for ReachEverythingInTheInterfaceVisitor<'_, 'a, 'tcx> {\n     fn tcx(&self) -> TyCtxt<'a, 'tcx, 'tcx> { self.ev.tcx }\n     fn visit_def_id(&mut self, def_id: DefId, _kind: &str, _descr: &dyn fmt::Display) -> bool {\n-        if let Some(node_id) = self.ev.tcx.hir().as_local_node_id(def_id) {\n-            self.ev.update(node_id, self.access_level);\n+        if let Some(hir_id) = self.ev.tcx.hir().as_local_hir_id(def_id) {\n+            self.ev.update(hir_id, self.access_level);\n         }\n         false\n     }\n@@ -796,7 +801,7 @@ impl<'a, 'tcx> DefIdVisitor<'a, 'tcx> for ReachEverythingInTheInterfaceVisitor<'\n struct NamePrivacyVisitor<'a, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     tables: &'a ty::TypeckTables<'tcx>,\n-    current_item: ast::NodeId,\n+    current_item: hir::HirId,\n     empty_tables: &'a ty::TypeckTables<'tcx>,\n }\n \n@@ -808,7 +813,7 @@ impl<'a, 'tcx> NamePrivacyVisitor<'a, 'tcx> {\n                    def: &'tcx ty::AdtDef, // definition of the struct or enum\n                    field: &'tcx ty::FieldDef) { // definition of the field\n         let ident = Ident::new(keywords::Invalid.name(), use_ctxt);\n-        let current_hir = self.tcx.hir().node_to_hir_id(self.current_item);\n+        let current_hir = self.current_item;\n         let def_id = self.tcx.adjust_ident(ident, def.did, current_hir).1;\n         if !def.is_enum() && !field.vis.is_accessible_from(def_id, self.tcx) {\n             struct_span_err!(self.tcx.sess, span, E0451, \"field `{}` of {} `{}` is private\",\n@@ -839,7 +844,7 @@ impl<'a, 'tcx> Visitor<'tcx> for NamePrivacyVisitor<'a, 'tcx> {\n     }\n \n     fn visit_item(&mut self, item: &'tcx hir::Item) {\n-        let orig_current_item = mem::replace(&mut self.current_item, item.id);\n+        let orig_current_item = mem::replace(&mut self.current_item, item.hir_id);\n         let orig_tables =\n             mem::replace(&mut self.tables, item_tables(self.tcx, item.hir_id, self.empty_tables));\n         intravisit::walk_item(self, item);\n@@ -1110,8 +1115,8 @@ impl<'a, 'tcx> Visitor<'tcx> for TypePrivacyVisitor<'a, 'tcx> {\n \n     // Check types in item interfaces.\n     fn visit_item(&mut self, item: &'tcx hir::Item) {\n-        let orig_current_item =\n-            mem::replace(&mut self.current_item, self.tcx.hir().local_def_id(item.id));\n+        let orig_current_item = mem::replace(&mut self.current_item,\n+            self.tcx.hir().local_def_id_from_hir_id(item.hir_id));\n         let orig_in_body = mem::replace(&mut self.in_body, false);\n         let orig_tables =\n             mem::replace(&mut self.tables, item_tables(self.tcx, item.hir_id, self.empty_tables));\n@@ -1190,10 +1195,11 @@ impl<'a, 'tcx> ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n         }\n     }\n \n-    fn trait_is_public(&self, trait_id: ast::NodeId) -> bool {\n+    fn trait_is_public(&self, trait_id: hir::HirId) -> bool {\n         // FIXME: this would preferably be using `exported_items`, but all\n         // traits are exported currently (see `EmbargoVisitor.exported_trait`).\n-        self.access_levels.is_public(trait_id)\n+        let node_id = self.tcx.hir().hir_to_node_id(trait_id);\n+        self.access_levels.is_public(node_id)\n     }\n \n     fn check_generic_bound(&mut self, bound: &hir::GenericBound) {\n@@ -1204,8 +1210,9 @@ impl<'a, 'tcx> ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n         }\n     }\n \n-    fn item_is_public(&self, id: &ast::NodeId, vis: &hir::Visibility) -> bool {\n-        self.access_levels.is_reachable(*id) || vis.node.is_pub()\n+    fn item_is_public(&self, id: &hir::HirId, vis: &hir::Visibility) -> bool {\n+        let node_id = self.tcx.hir().hir_to_node_id(*id);\n+        self.access_levels.is_reachable(node_id) || vis.node.is_pub()\n     }\n }\n \n@@ -1253,7 +1260,7 @@ impl<'a, 'tcx> Visitor<'tcx> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n             hir::ItemKind::ForeignMod(_) => {}\n \n             hir::ItemKind::Trait(.., ref bounds, _) => {\n-                if !self.trait_is_public(item.id) {\n+                if !self.trait_is_public(item.hir_id) {\n                     return\n                 }\n \n@@ -1295,8 +1302,8 @@ impl<'a, 'tcx> Visitor<'tcx> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n                                               |tr| {\n                         let did = tr.path.def.def_id();\n \n-                        if let Some(node_id) = self.tcx.hir().as_local_node_id(did) {\n-                            self.trait_is_public(node_id)\n+                        if let Some(hir_id) = self.tcx.hir().as_local_hir_id(did) {\n+                            self.trait_is_public(hir_id)\n                         } else {\n                             true // external traits must be public\n                         }\n@@ -1318,9 +1325,8 @@ impl<'a, 'tcx> Visitor<'tcx> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n                                      match impl_item.node {\n                                          hir::ImplItemKind::Const(..) |\n                                          hir::ImplItemKind::Method(..) => {\n-                                             let node_id = self.tcx.hir().hir_to_node_id(\n-                                                impl_item.hir_id);\n-                                             self.access_levels.is_reachable(node_id)\n+                                             self.access_levels.is_reachable(\n+                                                impl_item_ref.id.node_id)\n                                          }\n                                          hir::ImplItemKind::Existential(..) |\n                                          hir::ImplItemKind::Type(_) => false,\n@@ -1342,11 +1348,10 @@ impl<'a, 'tcx> Visitor<'tcx> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n                                 // don't erroneously report errors for private\n                                 // types in private items.\n                                 let impl_item = self.tcx.hir().impl_item(impl_item_ref.id);\n-                                let node_id = self.tcx.hir().hir_to_node_id(impl_item.hir_id);\n                                 match impl_item.node {\n                                     hir::ImplItemKind::Const(..) |\n                                     hir::ImplItemKind::Method(..)\n-                                        if self.item_is_public(&node_id, &impl_item.vis) =>\n+                                        if self.item_is_public(&impl_item.hir_id, &impl_item.vis) =>\n                                     {\n                                         intravisit::walk_impl_item(self, impl_item)\n                                     }\n@@ -1387,7 +1392,8 @@ impl<'a, 'tcx> Visitor<'tcx> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n                     // methods will be visible as `Public::foo`.\n                     let mut found_pub_static = false;\n                     for impl_item_ref in impl_item_refs {\n-                        if self.item_is_public(&impl_item_ref.id.node_id, &impl_item_ref.vis) {\n+                        let hir_id = self.tcx.hir().node_to_hir_id(impl_item_ref.id.node_id);\n+                        if self.item_is_public(&hir_id, &impl_item_ref.vis) {\n                             let impl_item = self.tcx.hir().impl_item(impl_item_ref.id);\n                             match impl_item_ref.kind {\n                                 AssociatedItemKind::Const => {\n@@ -1414,7 +1420,7 @@ impl<'a, 'tcx> Visitor<'tcx> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n             hir::ItemKind::Ty(..) => return,\n \n             // Not at all public, so we don't care.\n-            _ if !self.item_is_public(&item.id, &item.vis) => {\n+            _ if !self.item_is_public(&item.hir_id, &item.vis) => {\n                 return;\n             }\n \n@@ -1450,7 +1456,8 @@ impl<'a, 'tcx> Visitor<'tcx> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n     }\n \n     fn visit_foreign_item(&mut self, item: &'tcx hir::ForeignItem) {\n-        if self.access_levels.is_reachable(item.id) {\n+        let node_id = self.tcx.hir().hir_to_node_id(item.hir_id);\n+        if self.access_levels.is_reachable(node_id) {\n             intravisit::walk_foreign_item(self, item)\n         }\n     }\n@@ -1468,7 +1475,8 @@ impl<'a, 'tcx> Visitor<'tcx> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n                      v: &'tcx hir::Variant,\n                      g: &'tcx hir::Generics,\n                      item_id: hir::HirId) {\n-        if self.access_levels.is_reachable(v.node.data.id()) {\n+        let node_id = self.tcx.hir().hir_to_node_id(v.node.data.hir_id());\n+        if self.access_levels.is_reachable(node_id) {\n             self.in_variant = true;\n             intravisit::walk_variant(self, v, g, item_id);\n             self.in_variant = false;\n@@ -1735,7 +1743,7 @@ impl<'a, 'tcx> Visitor<'tcx> for PrivateItemsInPublicInterfacesVisitor<'a, 'tcx>\n             // A trait impl is public when both its type and its trait are public\n             // Subitems of trait impls have inherited publicity.\n             hir::ItemKind::Impl(.., ref trait_ref, _, ref impl_item_refs) => {\n-                let impl_vis = ty::Visibility::of_impl(item.id, tcx, &Default::default());\n+                let impl_vis = ty::Visibility::of_impl(item.hir_id, tcx, &Default::default());\n                 self.check(item.hir_id, impl_vis).generics().predicates();\n                 for impl_item_ref in impl_item_refs {\n                     let impl_item = tcx.hir().impl_item(impl_item_ref.id);\n@@ -1773,7 +1781,7 @@ fn check_mod_privacy<'tcx>(tcx: TyCtxt<'_, 'tcx, 'tcx>, module_def_id: DefId) {\n     let mut visitor = NamePrivacyVisitor {\n         tcx,\n         tables: &empty_tables,\n-        current_item: DUMMY_NODE_ID,\n+        current_item: hir::DUMMY_HIR_ID,\n         empty_tables: &empty_tables,\n     };\n     let (module, span, node_id) = tcx.hir().get_module(module_def_id);\n@@ -1827,7 +1835,7 @@ fn privacy_access_levels<'tcx>(\n             break\n         }\n     }\n-    visitor.update(ast::CRATE_NODE_ID, Some(AccessLevel::Public));\n+    visitor.update(hir::CRATE_HIR_ID, Some(AccessLevel::Public));\n \n     {\n         let mut visitor = ObsoleteVisiblePrivateTypesVisitor {"}]}