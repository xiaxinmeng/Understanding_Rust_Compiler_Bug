{"sha": "26f16e85ffcc3ebcaf12029865dee257760901b5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI2ZjE2ZTg1ZmZjYzNlYmNhZjEyMDI5ODY1ZGVlMjU3NzYwOTAxYjU=", "commit": {"author": {"name": "John K\u00e5re Alsaker", "email": "john.kare.alsaker@gmail.com", "date": "2018-04-01T10:14:19Z"}, "committer": {"name": "John K\u00e5re Alsaker", "email": "john.kare.alsaker@gmail.com", "date": "2018-04-10T12:39:33Z"}, "message": "Add a Once type for values which are only written once", "tree": {"sha": "9a747e3a88f0266e284dedaffe8d0693c5d8c44c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9a747e3a88f0266e284dedaffe8d0693c5d8c44c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/26f16e85ffcc3ebcaf12029865dee257760901b5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/26f16e85ffcc3ebcaf12029865dee257760901b5", "html_url": "https://github.com/rust-lang/rust/commit/26f16e85ffcc3ebcaf12029865dee257760901b5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/26f16e85ffcc3ebcaf12029865dee257760901b5/comments", "author": {"login": "Zoxc", "id": 25784, "node_id": "MDQ6VXNlcjI1Nzg0", "avatar_url": "https://avatars.githubusercontent.com/u/25784?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Zoxc", "html_url": "https://github.com/Zoxc", "followers_url": "https://api.github.com/users/Zoxc/followers", "following_url": "https://api.github.com/users/Zoxc/following{/other_user}", "gists_url": "https://api.github.com/users/Zoxc/gists{/gist_id}", "starred_url": "https://api.github.com/users/Zoxc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Zoxc/subscriptions", "organizations_url": "https://api.github.com/users/Zoxc/orgs", "repos_url": "https://api.github.com/users/Zoxc/repos", "events_url": "https://api.github.com/users/Zoxc/events{/privacy}", "received_events_url": "https://api.github.com/users/Zoxc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Zoxc", "id": 25784, "node_id": "MDQ6VXNlcjI1Nzg0", "avatar_url": "https://avatars.githubusercontent.com/u/25784?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Zoxc", "html_url": "https://github.com/Zoxc", "followers_url": "https://api.github.com/users/Zoxc/followers", "following_url": "https://api.github.com/users/Zoxc/following{/other_user}", "gists_url": "https://api.github.com/users/Zoxc/gists{/gist_id}", "starred_url": "https://api.github.com/users/Zoxc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Zoxc/subscriptions", "organizations_url": "https://api.github.com/users/Zoxc/orgs", "repos_url": "https://api.github.com/users/Zoxc/repos", "events_url": "https://api.github.com/users/Zoxc/events{/privacy}", "received_events_url": "https://api.github.com/users/Zoxc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "60d0cbe532eba39dba75d84b1eb98abf7cd12a48", "url": "https://api.github.com/repos/rust-lang/rust/commits/60d0cbe532eba39dba75d84b1eb98abf7cd12a48", "html_url": "https://github.com/rust-lang/rust/commit/60d0cbe532eba39dba75d84b1eb98abf7cd12a48"}], "stats": {"total": 129, "additions": 129, "deletions": 0}, "files": [{"sha": "3b7d6efbdae1e760694fced946ac9031bd2db2ec", "filename": "src/librustc_data_structures/sync.rs", "status": "modified", "additions": 129, "deletions": 0, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/26f16e85ffcc3ebcaf12029865dee257760901b5/src%2Flibrustc_data_structures%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26f16e85ffcc3ebcaf12029865dee257760901b5/src%2Flibrustc_data_structures%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fsync.rs?ref=26f16e85ffcc3ebcaf12029865dee257760901b5", "patch": "@@ -32,6 +32,7 @@\n use std::collections::HashMap;\n use std::hash::{Hash, BuildHasher};\n use std::cmp::Ordering;\n+use std::marker::PhantomData;\n use std::fmt::Debug;\n use std::fmt::Formatter;\n use std::fmt;\n@@ -241,6 +242,134 @@ impl<K: Eq + Hash, V: Eq, S: BuildHasher> HashMapExt<K, V> for HashMap<K, V, S>\n     }\n }\n \n+/// A type whose inner value can be written once and then will stay read-only\n+// This contains a PhantomData<T> since this type conceptually owns a T outside the Mutex once\n+// initialized. This ensures that Once<T> is Sync only if T is. If we did not have PhantomData<T>\n+// we could send a &Once<Cell<bool>> to multiple threads and call `get` on it to get access\n+// to &Cell<bool> on those threads.\n+pub struct Once<T>(Lock<Option<T>>, PhantomData<T>);\n+\n+impl<T> Once<T> {\n+    /// Creates an Once value which is uninitialized\n+    #[inline(always)]\n+    pub fn new() -> Self {\n+        Once(Lock::new(None), PhantomData)\n+    }\n+\n+    /// Consumes the value and returns Some(T) if it was initialized\n+    #[inline(always)]\n+    pub fn into_inner(self) -> Option<T> {\n+        self.0.into_inner()\n+    }\n+\n+    /// Tries to initialize the inner value to `value`.\n+    /// Returns `None` if the inner value was uninitialized and `value` was consumed setting it\n+    /// otherwise if the inner value was already set it returns `value` back to the caller\n+    #[inline]\n+    pub fn try_set(&self, value: T) -> Option<T> {\n+        let mut lock = self.0.lock();\n+        if lock.is_some() {\n+            return Some(value);\n+        }\n+        *lock = Some(value);\n+        None\n+    }\n+\n+    /// Tries to initialize the inner value to `value`.\n+    /// Returns `None` if the inner value was uninitialized and `value` was consumed setting it\n+    /// otherwise if the inner value was already set it asserts that `value` is equal to the inner\n+    /// value and then returns `value` back to the caller\n+    #[inline]\n+    pub fn try_set_same(&self, value: T) -> Option<T> where T: Eq {\n+        let mut lock = self.0.lock();\n+        if let Some(ref inner) = *lock {\n+            assert!(*inner == value);\n+            return Some(value);\n+        }\n+        *lock = Some(value);\n+        None\n+    }\n+\n+    /// Tries to initialize the inner value to `value` and panics if it was already initialized\n+    #[inline]\n+    pub fn set(&self, value: T) {\n+        assert!(self.try_set(value).is_none());\n+    }\n+\n+    /// Tries to initialize the inner value by calling the closure while ensuring that no-one else\n+    /// can access the value in the mean time by holding a lock for the duration of the closure.\n+    /// If the value was already initialized the closure is not called and `false` is returned,\n+    /// otherwise if the value from the closure initializes the inner value, `true` is returned\n+    #[inline]\n+    pub fn init_locking<F: FnOnce() -> T>(&self, f: F) -> bool {\n+        let mut lock = self.0.lock();\n+        if lock.is_some() {\n+            return false;\n+        }\n+        *lock = Some(f());\n+        true\n+    }\n+\n+    /// Tries to initialize the inner value by calling the closure without ensuring that no-one\n+    /// else can access it. This mean when this is called from multiple threads, multiple\n+    /// closures may concurrently be computing a value which the inner value should take.\n+    /// Only one of these closures are used to actually initialize the value.\n+    /// If some other closure already set the value,\n+    /// we return the value our closure computed wrapped in a `Option`.\n+    /// If our closure set the value, `None` is returned.\n+    /// If the value is already initialized, the closure is not called and `None` is returned.\n+    #[inline]\n+    pub fn init_nonlocking<F: FnOnce() -> T>(&self, f: F) -> Option<T> {\n+        if self.0.lock().is_some() {\n+            None\n+        } else {\n+            self.try_set(f())\n+        }\n+    }\n+\n+    /// Tries to initialize the inner value by calling the closure without ensuring that no-one\n+    /// else can access it. This mean when this is called from multiple threads, multiple\n+    /// closures may concurrently be computing a value which the inner value should take.\n+    /// Only one of these closures are used to actually initialize the value.\n+    /// If some other closure already set the value, we assert that it our closure computed\n+    /// a value equal to the value aready set and then\n+    /// we return the value our closure computed wrapped in a `Option`.\n+    /// If our closure set the value, `None` is returned.\n+    /// If the value is already initialized, the closure is not called and `None` is returned.\n+    #[inline]\n+    pub fn init_nonlocking_same<F: FnOnce() -> T>(&self, f: F) -> Option<T> where T: Eq {\n+        if self.0.lock().is_some() {\n+            None\n+        } else {\n+            self.try_set_same(f())\n+        }\n+    }\n+\n+    /// Tries to get a reference to the inner value, returns `None` if it is not yet initialized\n+    #[inline(always)]\n+    pub fn try_get(&self) -> Option<&T> {\n+        let lock = &*self.0.lock();\n+        if let Some(ref inner) = *lock {\n+            // This is safe since we won't mutate the inner value\n+            unsafe { Some(&*(inner as *const T)) }\n+        } else {\n+            None\n+        }\n+    }\n+\n+    /// Gets reference to the inner value, panics if it is not yet initialized\n+    #[inline(always)]\n+    pub fn get(&self) -> &T {\n+        self.try_get().expect(\"value was not set\")\n+    }\n+\n+    /// Gets reference to the inner value, panics if it is not yet initialized\n+    #[inline(always)]\n+    pub fn borrow(&self) -> &T {\n+        self.get()\n+    }\n+}\n+\n impl<T: Copy + Debug> Debug for LockCell<T> {\n     fn fmt(&self, f: &mut Formatter) -> fmt::Result {\n         f.debug_struct(\"LockCell\")"}]}