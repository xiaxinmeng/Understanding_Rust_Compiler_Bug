{"sha": "154726cf7d92e72e3386e056cf0ec61902f342cd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE1NDcyNmNmN2Q5MmU3MmUzMzg2ZTA1NmNmMGVjNjE5MDJmMzQyY2Q=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-07-06T20:14:36Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-07-06T20:14:36Z"}, "message": "Rollup merge of #62243 - petrochenkov:macrodoc, r=eddyb\n\nImprove documentation for built-in macros\n\nThis is the `libcore` part of https://github.com/rust-lang/rust/pull/62086.\nRight now the only effect is improved documentation.\n\nThe changes in the last few commits are required to make the `libcore` change compile successfully.", "tree": {"sha": "ca6f86597bba6e1af5d32b07a2fbc525a8cf88ac", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ca6f86597bba6e1af5d32b07a2fbc525a8cf88ac"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/154726cf7d92e72e3386e056cf0ec61902f342cd", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdIQEtCRBK7hj4Ov3rIwAAdHIIABTamKetU+Y6Y9i77uyC9H8B\nwz+jVk4I2/DJBbvpvoYH9vmyFkjekufVNhKD9T+j59R1lDpyY91wDrKHbySHQjl9\nd2cqEqXXx87rWrYFz9ytVCZMJQixkKOyTdTxJ0MUZR199TNpyQi45lrqVTYQz1rM\nirRiAFgbgY5qUIckH70evFFOB8ErDshPLTX+dH0hapIFd8v2u2RXjJFBLmlIvKMh\ny6ebnA8gNYkgC7OCD8VHk0jf8FTaKIdlzd/fdYSeb0P/ERknHotkAcPJ9pdLXC04\nmq6AVmfLQEg8kRqTMJuZnuC6czjeI+Z4vOykpE+qDpg4ZNjo2d1p2ZIgB20kUyQ=\n=1TMC\n-----END PGP SIGNATURE-----\n", "payload": "tree ca6f86597bba6e1af5d32b07a2fbc525a8cf88ac\nparent 296e825afab8665dfc5527aa8f72dfe5f5894224\nparent 327450797d460ae011eaaba68fae356117ab883d\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1562444076 +0200\ncommitter GitHub <noreply@github.com> 1562444076 +0200\n\nRollup merge of #62243 - petrochenkov:macrodoc, r=eddyb\n\nImprove documentation for built-in macros\n\nThis is the `libcore` part of https://github.com/rust-lang/rust/pull/62086.\nRight now the only effect is improved documentation.\n\nThe changes in the last few commits are required to make the `libcore` change compile successfully.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/154726cf7d92e72e3386e056cf0ec61902f342cd", "html_url": "https://github.com/rust-lang/rust/commit/154726cf7d92e72e3386e056cf0ec61902f342cd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/154726cf7d92e72e3386e056cf0ec61902f342cd/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "296e825afab8665dfc5527aa8f72dfe5f5894224", "url": "https://api.github.com/repos/rust-lang/rust/commits/296e825afab8665dfc5527aa8f72dfe5f5894224", "html_url": "https://github.com/rust-lang/rust/commit/296e825afab8665dfc5527aa8f72dfe5f5894224"}, {"sha": "327450797d460ae011eaaba68fae356117ab883d", "url": "https://api.github.com/repos/rust-lang/rust/commits/327450797d460ae011eaaba68fae356117ab883d", "html_url": "https://github.com/rust-lang/rust/commit/327450797d460ae011eaaba68fae356117ab883d"}], "stats": {"total": 987, "additions": 811, "deletions": 176}, "files": [{"sha": "782627431cb567dc4058e205f4e4374ae76c11e0", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/154726cf7d92e72e3386e056cf0ec61902f342cd/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/154726cf7d92e72e3386e056cf0ec61902f342cd/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=154726cf7d92e72e3386e056cf0ec61902f342cd", "patch": "@@ -75,6 +75,7 @@\n #![feature(const_fn)]\n #![feature(const_fn_union)]\n #![feature(custom_inner_attributes)]\n+#![feature(decl_macro)]\n #![feature(doc_cfg)]\n #![feature(doc_spotlight)]\n #![feature(extern_types)]"}, {"sha": "33ffd84e521f297acfac98449c41aad78cde1b3b", "filename": "src/libcore/macros.rs", "status": "modified", "additions": 628, "deletions": 91, "changes": 719, "blob_url": "https://github.com/rust-lang/rust/blob/154726cf7d92e72e3386e056cf0ec61902f342cd/src%2Flibcore%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/154726cf7d92e72e3386e056cf0ec61902f342cd/src%2Flibcore%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmacros.rs?ref=154726cf7d92e72e3386e056cf0ec61902f342cd", "patch": "@@ -642,183 +642,720 @@ macro_rules! uninitialized_array {\n /// These macros do not have any corresponding definition with a `macro_rules!`\n /// macro, but are documented here. Their implementations can be found hardcoded\n /// into libsyntax itself.\n-///\n-/// For more information, see documentation for `std`'s macros.\n #[cfg(rustdoc)]\n mod builtin {\n \n     /// Causes compilation to fail with the given error message when encountered.\n     ///\n-    /// For more information, see the documentation for [`std::compile_error!`].\n+    /// This macro should be used when a crate uses a conditional compilation strategy to provide\n+    /// better error messages for erroneous conditions. It's the compiler-level form of [`panic!`],\n+    /// which emits an error at *runtime*, rather than during compilation.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Two such examples are macros and `#[cfg]` environments.\n+    ///\n+    /// Emit better compiler error if a macro is passed invalid values. Without the final branch,\n+    /// the compiler would still emit an error, but the error's message would not mention the two\n+    /// valid values.\n+    ///\n+    /// ```compile_fail\n+    /// macro_rules! give_me_foo_or_bar {\n+    ///     (foo) => {};\n+    ///     (bar) => {};\n+    ///     ($x:ident) => {\n+    ///         compile_error!(\"This macro only accepts `foo` or `bar`\");\n+    ///     }\n+    /// }\n+    ///\n+    /// give_me_foo_or_bar!(neither);\n+    /// // ^ will fail at compile time with message \"This macro only accepts `foo` or `bar`\"\n+    /// ```\n+    ///\n+    /// Emit compiler error if one of a number of features isn't available.\n+    ///\n+    /// ```compile_fail\n+    /// #[cfg(not(any(feature = \"foo\", feature = \"bar\")))]\n+    /// compile_error!(\"Either feature \\\"foo\\\" or \\\"bar\\\" must be enabled for this crate.\");\n+    /// ```\n     ///\n-    /// [`std::compile_error!`]: ../std/macro.compile_error.html\n+    /// [`panic!`]: ../std/macro.panic.html\n     #[stable(feature = \"compile_error_macro\", since = \"1.20.0\")]\n-    #[rustc_doc_only_macro]\n-    macro_rules! compile_error {\n-        ($msg:expr) => ({ /* compiler built-in */ });\n-        ($msg:expr,) => ({ /* compiler built-in */ });\n+    #[rustc_builtin_macro]\n+    #[rustc_macro_transparency = \"semitransparent\"]\n+    pub macro compile_error {\n+        ($msg:expr) => ({ /* compiler built-in */ }),\n+        ($msg:expr,) => ({ /* compiler built-in */ })\n     }\n \n     /// Constructs parameters for the other string-formatting macros.\n     ///\n-    /// For more information, see the documentation for [`std::format_args!`].\n+    /// This macro functions by taking a formatting string literal containing\n+    /// `{}` for each additional argument passed. `format_args!` prepares the\n+    /// additional parameters to ensure the output can be interpreted as a string\n+    /// and canonicalizes the arguments into a single type. Any value that implements\n+    /// the [`Display`] trait can be passed to `format_args!`, as can any\n+    /// [`Debug`] implementation be passed to a `{:?}` within the formatting string.\n+    ///\n+    /// This macro produces a value of type [`fmt::Arguments`]. This value can be\n+    /// passed to the macros within [`std::fmt`] for performing useful redirection.\n+    /// All other formatting macros ([`format!`], [`write!`], [`println!`], etc) are\n+    /// proxied through this one. `format_args!`, unlike its derived macros, avoids\n+    /// heap allocations.\n+    ///\n+    /// You can use the [`fmt::Arguments`] value that `format_args!` returns\n+    /// in `Debug` and `Display` contexts as seen below. The example also shows\n+    /// that `Debug` and `Display` format to the same thing: the interpolated\n+    /// format string in `format_args!`.\n+    ///\n+    /// ```rust\n+    /// let debug = format!(\"{:?}\", format_args!(\"{} foo {:?}\", 1, 2));\n+    /// let display = format!(\"{}\", format_args!(\"{} foo {:?}\", 1, 2));\n+    /// assert_eq!(\"1 foo 2\", display);\n+    /// assert_eq!(display, debug);\n+    /// ```\n+    ///\n+    /// For more information, see the documentation in [`std::fmt`].\n+    ///\n+    /// [`Display`]: ../std/fmt/trait.Display.html\n+    /// [`Debug`]: ../std/fmt/trait.Debug.html\n+    /// [`fmt::Arguments`]: ../std/fmt/struct.Arguments.html\n+    /// [`std::fmt`]: ../std/fmt/index.html\n+    /// [`format!`]: ../std/macro.format.html\n+    /// [`write!`]: ../std/macro.write.html\n+    /// [`println!`]: ../std/macro.println.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::fmt;\n     ///\n-    /// [`std::format_args!`]: ../std/macro.format_args.html\n+    /// let s = fmt::format(format_args!(\"hello {}\", \"world\"));\n+    /// assert_eq!(s, format!(\"hello {}\", \"world\"));\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[rustc_doc_only_macro]\n-    macro_rules! format_args {\n-        ($fmt:expr) => ({ /* compiler built-in */ });\n-        ($fmt:expr, $($args:tt)*) => ({ /* compiler built-in */ });\n+    #[allow_internal_unstable(fmt_internals)]\n+    #[rustc_builtin_macro]\n+    #[rustc_macro_transparency = \"semitransparent\"]\n+    pub macro format_args {\n+        ($fmt:expr) => ({ /* compiler built-in */ }),\n+        ($fmt:expr, $($args:tt)*) => ({ /* compiler built-in */ })\n+    }\n+\n+    /// Same as `format_args`, but adds a newline in the end.\n+    #[unstable(feature = \"format_args_nl\", issue = \"0\",\n+               reason = \"`format_args_nl` is only for internal \\\n+                         language use and is subject to change\")]\n+    #[allow_internal_unstable(fmt_internals)]\n+    #[rustc_builtin_macro]\n+    #[rustc_macro_transparency = \"semitransparent\"]\n+    pub macro format_args_nl {\n+        ($fmt:expr) => ({ /* compiler built-in */ }),\n+        ($fmt:expr, $($args:tt)*) => ({ /* compiler built-in */ })\n     }\n \n     /// Inspects an environment variable at compile time.\n     ///\n-    /// For more information, see the documentation for [`std::env!`].\n+    /// This macro will expand to the value of the named environment variable at\n+    /// compile time, yielding an expression of type `&'static str`.\n+    ///\n+    /// If the environment variable is not defined, then a compilation error\n+    /// will be emitted. To not emit a compile error, use the [`option_env!`]\n+    /// macro instead.\n+    ///\n+    /// [`option_env!`]: ../std/macro.option_env.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let path: &'static str = env!(\"PATH\");\n+    /// println!(\"the $PATH variable at the time of compiling was: {}\", path);\n+    /// ```\n+    ///\n+    /// You can customize the error message by passing a string as the second\n+    /// parameter:\n+    ///\n+    /// ```compile_fail\n+    /// let doc: &'static str = env!(\"documentation\", \"what's that?!\");\n+    /// ```\n     ///\n-    /// [`std::env!`]: ../std/macro.env.html\n+    /// If the `documentation` environment variable is not defined, you'll get\n+    /// the following error:\n+    ///\n+    /// ```text\n+    /// error: what's that?!\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[rustc_doc_only_macro]\n-    macro_rules! env {\n-        ($name:expr) => ({ /* compiler built-in */ });\n-        ($name:expr,) => ({ /* compiler built-in */ });\n+    #[rustc_builtin_macro]\n+    #[rustc_macro_transparency = \"semitransparent\"]\n+    pub macro env {\n+        ($name:expr) => ({ /* compiler built-in */ }),\n+        ($name:expr,) => ({ /* compiler built-in */ })\n     }\n \n     /// Optionally inspects an environment variable at compile time.\n     ///\n-    /// For more information, see the documentation for [`std::option_env!`].\n+    /// If the named environment variable is present at compile time, this will\n+    /// expand into an expression of type `Option<&'static str>` whose value is\n+    /// `Some` of the value of the environment variable. If the environment\n+    /// variable is not present, then this will expand to `None`. See\n+    /// [`Option<T>`][option] for more information on this type.\n+    ///\n+    /// A compile time error is never emitted when using this macro regardless\n+    /// of whether the environment variable is present or not.\n+    ///\n+    /// [option]: ../std/option/enum.Option.html\n+    ///\n+    /// # Examples\n     ///\n-    /// [`std::option_env!`]: ../std/macro.option_env.html\n+    /// ```\n+    /// let key: Option<&'static str> = option_env!(\"SECRET_KEY\");\n+    /// println!(\"the secret key might be: {:?}\", key);\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[rustc_doc_only_macro]\n-    macro_rules! option_env {\n-        ($name:expr) => ({ /* compiler built-in */ });\n-        ($name:expr,) => ({ /* compiler built-in */ });\n+    #[rustc_builtin_macro]\n+    #[rustc_macro_transparency = \"semitransparent\"]\n+    pub macro option_env {\n+        ($name:expr) => ({ /* compiler built-in */ }),\n+        ($name:expr,) => ({ /* compiler built-in */ })\n     }\n \n     /// Concatenates identifiers into one identifier.\n     ///\n-    /// For more information, see the documentation for [`std::concat_idents!`].\n+    /// This macro takes any number of comma-separated identifiers, and\n+    /// concatenates them all into one, yielding an expression which is a new\n+    /// identifier. Note that hygiene makes it such that this macro cannot\n+    /// capture local variables. Also, as a general rule, macros are only\n+    /// allowed in item, statement or expression position. That means while\n+    /// you may use this macro for referring to existing variables, functions or\n+    /// modules etc, you cannot define a new one with it.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(concat_idents)]\n+    ///\n+    /// # fn main() {\n+    /// fn foobar() -> u32 { 23 }\n     ///\n-    /// [`std::concat_idents!`]: ../std/macro.concat_idents.html\n-    #[unstable(feature = \"concat_idents_macro\", issue = \"29599\")]\n-    #[rustc_doc_only_macro]\n-    macro_rules! concat_idents {\n-        ($($e:ident),+) => ({ /* compiler built-in */ });\n-        ($($e:ident,)+) => ({ /* compiler built-in */ });\n+    /// let f = concat_idents!(foo, bar);\n+    /// println!(\"{}\", f());\n+    ///\n+    /// // fn concat_idents!(new, fun, name) { } // not usable in this way!\n+    /// # }\n+    /// ```\n+    #[unstable(feature = \"concat_idents\", issue = \"29599\",\n+               reason = \"`concat_idents` is not stable enough for use and is subject to change\")]\n+    #[rustc_builtin_macro]\n+    #[rustc_macro_transparency = \"semitransparent\"]\n+    pub macro concat_idents {\n+        ($($e:ident),+) => ({ /* compiler built-in */ }),\n+        ($($e:ident,)+) => ({ /* compiler built-in */ })\n     }\n \n     /// Concatenates literals into a static string slice.\n     ///\n-    /// For more information, see the documentation for [`std::concat!`].\n+    /// This macro takes any number of comma-separated literals, yielding an\n+    /// expression of type `&'static str` which represents all of the literals\n+    /// concatenated left-to-right.\n+    ///\n+    /// Integer and floating point literals are stringified in order to be\n+    /// concatenated.\n     ///\n-    /// [`std::concat!`]: ../std/macro.concat.html\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let s = concat!(\"test\", 10, 'b', true);\n+    /// assert_eq!(s, \"test10btrue\");\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[rustc_doc_only_macro]\n-    macro_rules! concat {\n-        ($($e:expr),*) => ({ /* compiler built-in */ });\n-        ($($e:expr,)*) => ({ /* compiler built-in */ });\n+    #[rustc_builtin_macro]\n+    #[rustc_macro_transparency = \"semitransparent\"]\n+    pub macro concat {\n+        ($($e:expr),*) => ({ /* compiler built-in */ }),\n+        ($($e:expr,)*) => ({ /* compiler built-in */ })\n     }\n \n     /// Expands to the line number on which it was invoked.\n     ///\n-    /// For more information, see the documentation for [`std::line!`].\n+    /// With [`column!`] and [`file!`], these macros provide debugging information for\n+    /// developers about the location within the source.\n+    ///\n+    /// The expanded expression has type `u32` and is 1-based, so the first line\n+    /// in each file evaluates to 1, the second to 2, etc. This is consistent\n+    /// with error messages by common compilers or popular editors.\n+    /// The returned line is *not necessarily* the line of the `line!` invocation itself,\n+    /// but rather the first macro invocation leading up to the invocation\n+    /// of the `line!` macro.\n     ///\n-    /// [`std::line!`]: ../std/macro.line.html\n+    /// [`column!`]: macro.column.html\n+    /// [`file!`]: macro.file.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let current_line = line!();\n+    /// println!(\"defined on line: {}\", current_line);\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[rustc_doc_only_macro]\n-    macro_rules! line { () => ({ /* compiler built-in */ }) }\n+    #[rustc_builtin_macro]\n+    #[rustc_macro_transparency = \"semitransparent\"]\n+    pub macro line() { /* compiler built-in */ }\n \n-    /// Expands to the column number on which it was invoked.\n+    /// Expands to the column number at which it was invoked.\n+    ///\n+    /// With [`line!`] and [`file!`], these macros provide debugging information for\n+    /// developers about the location within the source.\n+    ///\n+    /// The expanded expression has type `u32` and is 1-based, so the first column\n+    /// in each line evaluates to 1, the second to 2, etc. This is consistent\n+    /// with error messages by common compilers or popular editors.\n+    /// The returned column is *not necessarily* the line of the `column!` invocation itself,\n+    /// but rather the first macro invocation leading up to the invocation\n+    /// of the `column!` macro.\n     ///\n-    /// For more information, see the documentation for [`std::column!`].\n+    /// [`line!`]: macro.line.html\n+    /// [`file!`]: macro.file.html\n     ///\n-    /// [`std::column!`]: ../std/macro.column.html\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let current_col = column!();\n+    /// println!(\"defined on column: {}\", current_col);\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[rustc_doc_only_macro]\n-    macro_rules! column { () => ({ /* compiler built-in */ }) }\n+    #[rustc_builtin_macro]\n+    #[rustc_macro_transparency = \"semitransparent\"]\n+    pub macro column() { /* compiler built-in */ }\n+\n+    /// Same as `column`, but less likely to be shadowed.\n+    #[unstable(feature = \"__rust_unstable_column\", issue = \"0\",\n+               reason = \"internal implementation detail of the `column` macro\")]\n+    #[rustc_builtin_macro]\n+    #[rustc_macro_transparency = \"semitransparent\"]\n+    pub macro __rust_unstable_column() { /* compiler built-in */ }\n \n-    /// Expands to the file name from which it was invoked.\n+    /// Expands to the file name in which it was invoked.\n+    ///\n+    /// With [`line!`] and [`column!`], these macros provide debugging information for\n+    /// developers about the location within the source.\n+    ///\n     ///\n-    /// For more information, see the documentation for [`std::file!`].\n+    /// The expanded expression has type `&'static str`, and the returned file\n+    /// is not the invocation of the `file!` macro itself, but rather the\n+    /// first macro invocation leading up to the invocation of the `file!`\n+    /// macro.\n     ///\n-    /// [`std::file!`]: ../std/macro.file.html\n+    /// [`line!`]: macro.line.html\n+    /// [`column!`]: macro.column.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let this_file = file!();\n+    /// println!(\"defined in file: {}\", this_file);\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[rustc_doc_only_macro]\n-    macro_rules! file { () => ({ /* compiler built-in */ }) }\n+    #[rustc_builtin_macro]\n+    #[rustc_macro_transparency = \"semitransparent\"]\n+    pub macro file() { /* compiler built-in */ }\n \n     /// Stringifies its arguments.\n     ///\n-    /// For more information, see the documentation for [`std::stringify!`].\n+    /// This macro will yield an expression of type `&'static str` which is the\n+    /// stringification of all the tokens passed to the macro. No restrictions\n+    /// are placed on the syntax of the macro invocation itself.\n+    ///\n+    /// Note that the expanded results of the input tokens may change in the\n+    /// future. You should be careful if you rely on the output.\n     ///\n-    /// [`std::stringify!`]: ../std/macro.stringify.html\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let one_plus_one = stringify!(1 + 1);\n+    /// assert_eq!(one_plus_one, \"1 + 1\");\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[rustc_doc_only_macro]\n-    macro_rules! stringify { ($($t:tt)*) => ({ /* compiler built-in */ }) }\n+    #[rustc_builtin_macro]\n+    #[rustc_macro_transparency = \"semitransparent\"]\n+    pub macro stringify($($t:tt)*) { /* compiler built-in */ }\n \n     /// Includes a utf8-encoded file as a string.\n     ///\n-    /// For more information, see the documentation for [`std::include_str!`].\n+    /// The file is located relative to the current file. (similarly to how\n+    /// modules are found)\n+    ///\n+    /// This macro will yield an expression of type `&'static str` which is the\n+    /// contents of the file.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Assume there are two files in the same directory with the following\n+    /// contents:\n+    ///\n+    /// File 'spanish.in':\n+    ///\n+    /// ```text\n+    /// adi\u00f3s\n+    /// ```\n+    ///\n+    /// File 'main.rs':\n+    ///\n+    /// ```ignore (cannot-doctest-external-file-dependency)\n+    /// fn main() {\n+    ///     let my_str = include_str!(\"spanish.in\");\n+    ///     assert_eq!(my_str, \"adi\u00f3s\\n\");\n+    ///     print!(\"{}\", my_str);\n+    /// }\n+    /// ```\n     ///\n-    /// [`std::include_str!`]: ../std/macro.include_str.html\n+    /// Compiling 'main.rs' and running the resulting binary will print \"adi\u00f3s\".\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[rustc_doc_only_macro]\n-    macro_rules! include_str {\n-        ($file:expr) => ({ /* compiler built-in */ });\n-        ($file:expr,) => ({ /* compiler built-in */ });\n+    #[rustc_builtin_macro]\n+    #[rustc_macro_transparency = \"semitransparent\"]\n+    pub macro include_str {\n+        ($file:expr) => ({ /* compiler built-in */ }),\n+        ($file:expr,) => ({ /* compiler built-in */ })\n     }\n \n     /// Includes a file as a reference to a byte array.\n     ///\n-    /// For more information, see the documentation for [`std::include_bytes!`].\n+    /// The file is located relative to the current file. (similarly to how\n+    /// modules are found)\n+    ///\n+    /// This macro will yield an expression of type `&'static [u8; N]` which is\n+    /// the contents of the file.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Assume there are two files in the same directory with the following\n+    /// contents:\n+    ///\n+    /// File 'spanish.in':\n+    ///\n+    /// ```text\n+    /// adi\u00f3s\n+    /// ```\n+    ///\n+    /// File 'main.rs':\n+    ///\n+    /// ```ignore (cannot-doctest-external-file-dependency)\n+    /// fn main() {\n+    ///     let bytes = include_bytes!(\"spanish.in\");\n+    ///     assert_eq!(bytes, b\"adi\\xc3\\xb3s\\n\");\n+    ///     print!(\"{}\", String::from_utf8_lossy(bytes));\n+    /// }\n+    /// ```\n     ///\n-    /// [`std::include_bytes!`]: ../std/macro.include_bytes.html\n+    /// Compiling 'main.rs' and running the resulting binary will print \"adi\u00f3s\".\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[rustc_doc_only_macro]\n-    macro_rules! include_bytes {\n-        ($file:expr) => ({ /* compiler built-in */ });\n-        ($file:expr,) => ({ /* compiler built-in */ });\n+    #[rustc_builtin_macro]\n+    #[rustc_macro_transparency = \"semitransparent\"]\n+    pub macro include_bytes {\n+        ($file:expr) => ({ /* compiler built-in */ }),\n+        ($file:expr,) => ({ /* compiler built-in */ })\n     }\n \n     /// Expands to a string that represents the current module path.\n     ///\n-    /// For more information, see the documentation for [`std::module_path!`].\n+    /// The current module path can be thought of as the hierarchy of modules\n+    /// leading back up to the crate root. The first component of the path\n+    /// returned is the name of the crate currently being compiled.\n     ///\n-    /// [`std::module_path!`]: ../std/macro.module_path.html\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// mod test {\n+    ///     pub fn foo() {\n+    ///         assert!(module_path!().ends_with(\"test\"));\n+    ///     }\n+    /// }\n+    ///\n+    /// test::foo();\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[rustc_doc_only_macro]\n-    macro_rules! module_path { () => ({ /* compiler built-in */ }) }\n+    #[rustc_builtin_macro]\n+    #[rustc_macro_transparency = \"semitransparent\"]\n+    pub macro module_path() { /* compiler built-in */ }\n \n-    /// Evaluates boolean combinations of configuration flags, at compile-time.\n+    /// Evaluates boolean combinations of configuration flags at compile-time.\n+    ///\n+    /// In addition to the `#[cfg]` attribute, this macro is provided to allow\n+    /// boolean expression evaluation of configuration flags. This frequently\n+    /// leads to less duplicated code.\n+    ///\n+    /// The syntax given to this macro is the same syntax as the [`cfg`]\n+    /// attribute.\n     ///\n-    /// For more information, see the documentation for [`std::cfg!`].\n+    /// [`cfg`]: ../reference/conditional-compilation.html#the-cfg-attribute\n     ///\n-    /// [`std::cfg!`]: ../std/macro.cfg.html\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let my_directory = if cfg!(windows) {\n+    ///     \"windows-specific-directory\"\n+    /// } else {\n+    ///     \"unix-directory\"\n+    /// };\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[rustc_doc_only_macro]\n-    macro_rules! cfg { ($($cfg:tt)*) => ({ /* compiler built-in */ }) }\n+    #[rustc_builtin_macro]\n+    #[rustc_macro_transparency = \"semitransparent\"]\n+    pub macro cfg($($cfg:tt)*) { /* compiler built-in */ }\n \n     /// Parses a file as an expression or an item according to the context.\n     ///\n-    /// For more information, see the documentation for [`std::include!`].\n+    /// The file is located relative to the current file (similarly to how\n+    /// modules are found).\n+    ///\n+    /// Using this macro is often a bad idea, because if the file is\n+    /// parsed as an expression, it is going to be placed in the\n+    /// surrounding code unhygienically. This could result in variables\n+    /// or functions being different from what the file expected if\n+    /// there are variables or functions that have the same name in\n+    /// the current file.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Assume there are two files in the same directory with the following\n+    /// contents:\n     ///\n-    /// [`std::include!`]: ../std/macro.include.html\n+    /// File 'monkeys.in':\n+    ///\n+    /// ```ignore (only-for-syntax-highlight)\n+    /// ['\ud83d\ude48', '\ud83d\ude4a', '\ud83d\ude49']\n+    ///     .iter()\n+    ///     .cycle()\n+    ///     .take(6)\n+    ///     .collect::<String>()\n+    /// ```\n+    ///\n+    /// File 'main.rs':\n+    ///\n+    /// ```ignore (cannot-doctest-external-file-dependency)\n+    /// fn main() {\n+    ///     let my_string = include!(\"monkeys.in\");\n+    ///     assert_eq!(\"\ud83d\ude48\ud83d\ude4a\ud83d\ude49\ud83d\ude48\ud83d\ude4a\ud83d\ude49\", my_string);\n+    ///     println!(\"{}\", my_string);\n+    /// }\n+    /// ```\n+    ///\n+    /// Compiling 'main.rs' and running the resulting binary will print\n+    /// \"\ud83d\ude48\ud83d\ude4a\ud83d\ude49\ud83d\ude48\ud83d\ude4a\ud83d\ude49\".\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[rustc_doc_only_macro]\n-    macro_rules! include {\n-        ($file:expr) => ({ /* compiler built-in */ });\n-        ($file:expr,) => ({ /* compiler built-in */ });\n+    #[rustc_builtin_macro]\n+    #[rustc_macro_transparency = \"semitransparent\"]\n+    pub macro include {\n+        ($file:expr) => ({ /* compiler built-in */ }),\n+        ($file:expr,) => ({ /* compiler built-in */ })\n     }\n \n     /// Asserts that a boolean expression is `true` at runtime.\n     ///\n-    /// For more information, see the documentation for [`std::assert!`].\n+    /// This will invoke the [`panic!`] macro if the provided expression cannot be\n+    /// evaluated to `true` at runtime.\n+    ///\n+    /// # Uses\n+    ///\n+    /// Assertions are always checked in both debug and release builds, and cannot\n+    /// be disabled. See [`debug_assert!`] for assertions that are not enabled in\n+    /// release builds by default.\n+    ///\n+    /// Unsafe code relies on `assert!` to enforce run-time invariants that, if\n+    /// violated could lead to unsafety.\n     ///\n-    /// [`std::assert!`]: ../std/macro.assert.html\n-    #[rustc_doc_only_macro]\n+    /// Other use-cases of `assert!` include testing and enforcing run-time\n+    /// invariants in safe code (whose violation cannot result in unsafety).\n+    ///\n+    /// # Custom Messages\n+    ///\n+    /// This macro has a second form, where a custom panic message can\n+    /// be provided with or without arguments for formatting. See [`std::fmt`]\n+    /// for syntax for this form.\n+    ///\n+    /// [`panic!`]: macro.panic.html\n+    /// [`debug_assert!`]: macro.debug_assert.html\n+    /// [`std::fmt`]: ../std/fmt/index.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// // the panic message for these assertions is the stringified value of the\n+    /// // expression given.\n+    /// assert!(true);\n+    ///\n+    /// fn some_computation() -> bool { true } // a very simple function\n+    ///\n+    /// assert!(some_computation());\n+    ///\n+    /// // assert with a custom message\n+    /// let x = true;\n+    /// assert!(x, \"x wasn't true!\");\n+    ///\n+    /// let a = 3; let b = 27;\n+    /// assert!(a + b == 30, \"a = {}, b = {}\", a, b);\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    macro_rules! assert {\n-        ($cond:expr) => ({ /* compiler built-in */ });\n-        ($cond:expr,) => ({ /* compiler built-in */ });\n-        ($cond:expr, $($arg:tt)+) => ({ /* compiler built-in */ });\n+    #[rustc_builtin_macro]\n+    #[rustc_macro_transparency = \"semitransparent\"]\n+    pub macro assert {\n+        ($cond:expr) => ({ /* compiler built-in */ }),\n+        ($cond:expr,) => ({ /* compiler built-in */ }),\n+        ($cond:expr, $($arg:tt)+) => ({ /* compiler built-in */ })\n     }\n+\n+    /// Inline assembly.\n+    #[unstable(feature = \"asm\", issue = \"29722\",\n+               reason = \"inline assembly is not stable enough for use and is subject to change\")]\n+    #[rustc_builtin_macro]\n+    #[rustc_macro_transparency = \"semitransparent\"]\n+    pub macro asm(\"assembly template\"\n+                  : $(\"output\"(operand),)*\n+                  : $(\"input\"(operand),)*\n+                  : $(\"clobbers\",)*\n+                  : $(\"options\",)*) { /* compiler built-in */ }\n+\n+    /// Module-level inline assembly.\n+    #[unstable(feature = \"global_asm\", issue = \"35119\",\n+               reason = \"`global_asm!` is not stable enough for use and is subject to change\")]\n+    #[rustc_builtin_macro]\n+    #[rustc_macro_transparency = \"semitransparent\"]\n+    pub macro global_asm(\"assembly\") { /* compiler built-in */ }\n+\n+    /// Prints passed tokens into the standard output.\n+    #[unstable(feature = \"log_syntax\", issue = \"29598\",\n+               reason = \"`log_syntax!` is not stable enough for use and is subject to change\")]\n+    #[rustc_builtin_macro]\n+    #[rustc_macro_transparency = \"semitransparent\"]\n+    pub macro log_syntax($($arg:tt)*) { /* compiler built-in */ }\n+\n+    /// Enables or disables tracing functionality used for debugging other macros.\n+    #[unstable(feature = \"trace_macros\", issue = \"29598\",\n+               reason = \"`trace_macros` is not stable enough for use and is subject to change\")]\n+    #[rustc_builtin_macro]\n+    #[rustc_macro_transparency = \"semitransparent\"]\n+    pub macro trace_macros {\n+        (true) => ({ /* compiler built-in */ }),\n+        (false) => ({ /* compiler built-in */ })\n+    }\n+\n+    /// Attribute macro applied to a function to turn it into a unit test.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[rustc_builtin_macro]\n+    #[rustc_macro_transparency = \"semitransparent\"]\n+    pub macro test($item:item) { /* compiler built-in */ }\n+\n+    /// Attribute macro applied to a function to turn it into a benchmark test.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[rustc_builtin_macro]\n+    #[rustc_macro_transparency = \"semitransparent\"]\n+    pub macro bench($item:item) { /* compiler built-in */ }\n+\n+    /// An implementation detail of the `#[test]` and `#[bench]` macros.\n+    #[unstable(feature = \"custom_test_frameworks\", issue = \"50297\",\n+               reason = \"custom test frameworks are an unstable feature\")]\n+    #[rustc_builtin_macro]\n+    #[rustc_macro_transparency = \"semitransparent\"]\n+    pub macro test_case($item:item) { /* compiler built-in */ }\n+\n+    /// Derive macro generating an impl of the trait `Clone`.\n+    #[rustc_builtin_macro]\n+    #[rustc_macro_transparency = \"semitransparent\"]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[allow_internal_unstable(core_intrinsics, derive_clone_copy)]\n+    pub macro Clone($item:item) { /* compiler built-in */ }\n+\n+    /// Derive macro generating an impl of the trait `Copy`.\n+    #[rustc_builtin_macro]\n+    #[rustc_macro_transparency = \"semitransparent\"]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[allow_internal_unstable(core_intrinsics, derive_clone_copy)]\n+    pub macro Copy($item:item) { /* compiler built-in */ }\n+\n+    /// Derive macro generating an impl of the trait `Debug`.\n+    #[rustc_builtin_macro]\n+    #[rustc_macro_transparency = \"semitransparent\"]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[allow_internal_unstable(core_intrinsics)]\n+    pub macro Debug($item:item) { /* compiler built-in */ }\n+\n+    /// Unstable implementation detail of the `rustc` compiler, do not use.\n+    #[rustc_builtin_macro]\n+    #[rustc_macro_transparency = \"semitransparent\"]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[rustc_deprecated(\n+        since = \"1.0.0\",\n+        reason = \"derive(Decodable) is deprecated in favor of derive(RustcDecodable)\",\n+        suggestion = \"RustcDecodable\",\n+    )]\n+    #[allow_internal_unstable(core_intrinsics, libstd_sys_internals)]\n+    pub macro Decodable($item:item) { /* compiler built-in */ }\n+\n+    /// Derive macro generating an impl of the trait `Default`.\n+    #[rustc_builtin_macro]\n+    #[rustc_macro_transparency = \"semitransparent\"]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[allow_internal_unstable(core_intrinsics)]\n+    pub macro Default($item:item) { /* compiler built-in */ }\n+\n+    /// Unstable implementation detail of the `rustc` compiler, do not use.\n+    #[rustc_builtin_macro]\n+    #[rustc_macro_transparency = \"semitransparent\"]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[rustc_deprecated(\n+        since = \"1.0.0\",\n+        reason = \"derive(Encodable) is deprecated in favor of derive(RustcEncodable)\",\n+        suggestion = \"RustcEncodable\",\n+    )]\n+    #[allow_internal_unstable(core_intrinsics)]\n+    pub macro Encodable($item:item) { /* compiler built-in */ }\n+\n+    /// Derive macro generating an impl of the trait `Eq`.\n+    #[rustc_builtin_macro]\n+    #[rustc_macro_transparency = \"semitransparent\"]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[allow_internal_unstable(core_intrinsics, derive_eq)]\n+    pub macro Eq($item:item) { /* compiler built-in */ }\n+\n+    /// Derive macro generating an impl of the trait `Hash`.\n+    #[rustc_builtin_macro]\n+    #[rustc_macro_transparency = \"semitransparent\"]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[allow_internal_unstable(core_intrinsics)]\n+    pub macro Hash($item:item) { /* compiler built-in */ }\n+\n+    /// Derive macro generating an impl of the trait `Ord`.\n+    #[rustc_builtin_macro]\n+    #[rustc_macro_transparency = \"semitransparent\"]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[allow_internal_unstable(core_intrinsics)]\n+    pub macro Ord($item:item) { /* compiler built-in */ }\n+\n+    /// Derive macro generating an impl of the trait `PartialEq`.\n+    #[rustc_builtin_macro]\n+    #[rustc_macro_transparency = \"semitransparent\"]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[allow_internal_unstable(core_intrinsics)]\n+    pub macro PartialEq($item:item) { /* compiler built-in */ }\n+\n+    /// Derive macro generating an impl of the trait `PartialOrd`.\n+    #[rustc_builtin_macro]\n+    #[rustc_macro_transparency = \"semitransparent\"]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[allow_internal_unstable(core_intrinsics)]\n+    pub macro PartialOrd($item:item) { /* compiler built-in */ }\n+\n+    /// Unstable implementation detail of the `rustc` compiler, do not use.\n+    #[rustc_builtin_macro]\n+    #[rustc_macro_transparency = \"semitransparent\"]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[allow_internal_unstable(core_intrinsics, libstd_sys_internals)]\n+    pub macro RustcDecodable($item:item) { /* compiler built-in */ }\n+\n+    /// Unstable implementation detail of the `rustc` compiler, do not use.\n+    #[rustc_builtin_macro]\n+    #[rustc_macro_transparency = \"semitransparent\"]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[allow_internal_unstable(core_intrinsics)]\n+    pub macro RustcEncodable($item:item) { /* compiler built-in */ }\n }"}, {"sha": "271fac544a4d253892889203e3c37e4a9cb04443", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/154726cf7d92e72e3386e056cf0ec61902f342cd/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/154726cf7d92e72e3386e056cf0ec61902f342cd/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=154726cf7d92e72e3386e056cf0ec61902f342cd", "patch": "@@ -4010,7 +4010,7 @@ impl<'a> LoweringContext<'a> {\n         let attrs = self.lower_attrs(&i.attrs);\n         if let ItemKind::MacroDef(ref def) = i.node {\n             if !def.legacy || attr::contains_name(&i.attrs, sym::macro_export) ||\n-                              attr::contains_name(&i.attrs, sym::rustc_doc_only_macro) {\n+                              attr::contains_name(&i.attrs, sym::rustc_builtin_macro) {\n                 let body = self.lower_token_stream(def.stream());\n                 let hir_id = self.lower_node_id(i.id);\n                 self.exported_macros.push(hir::MacroDef {"}, {"sha": "05df3a6f6bc2eeba279a37fb4c84a517b491b6cd", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/154726cf7d92e72e3386e056cf0ec61902f342cd/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/154726cf7d92e72e3386e056cf0ec61902f342cd/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=154726cf7d92e72e3386e056cf0ec61902f342cd", "patch": "@@ -28,6 +28,7 @@ use rustc_data_structures::fx::FxHashSet;\n use syntax::ast::Ident;\n use syntax::attr;\n use syntax::symbol::{kw, sym};\n+use syntax_pos::hygiene::Transparency;\n use syntax_pos::Span;\n \n use std::{cmp, fmt, mem};\n@@ -743,7 +744,7 @@ impl Visitor<'tcx> for EmbargoVisitor<'tcx> {\n     }\n \n     fn visit_macro_def(&mut self, md: &'tcx hir::MacroDef) {\n-        if md.legacy {\n+        if attr::find_transparency(&md.attrs, md.legacy).0 != Transparency::Opaque {\n             self.update(md.hir_id, Some(AccessLevel::Public));\n             return\n         }"}, {"sha": "3921bd30df25ce5caae147597b52dfa13830dc83", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/154726cf7d92e72e3386e056cf0ec61902f342cd/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/154726cf7d92e72e3386e056cf0ec61902f342cd/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=154726cf7d92e72e3386e056cf0ec61902f342cd", "patch": "@@ -770,27 +770,33 @@ impl<'a> Resolver<'a> {\n     }\n \n     pub fn get_macro(&mut self, res: Res) -> Lrc<SyntaxExtension> {\n+        self.opt_get_macro(res).expect(\"expected `DefKind::Macro` or `Res::NonMacroAttr`\")\n+    }\n+\n+    crate fn opt_get_macro(&mut self, res: Res) -> Option<Lrc<SyntaxExtension>> {\n         let def_id = match res {\n+            Res::Def(DefKind::Macro(MacroKind::ProcMacroStub), _) =>\n+                return Some(self.non_macro_attr(true)), // some dummy extension\n             Res::Def(DefKind::Macro(..), def_id) => def_id,\n             Res::NonMacroAttr(attr_kind) =>\n-                return self.non_macro_attr(attr_kind == NonMacroAttrKind::Tool),\n-            _ => panic!(\"expected `DefKind::Macro` or `Res::NonMacroAttr`\"),\n+                return Some(self.non_macro_attr(attr_kind == NonMacroAttrKind::Tool)),\n+            _ => return None,\n         };\n         if let Some(ext) = self.macro_map.get(&def_id) {\n-            return ext.clone();\n+            return Some(ext.clone());\n         }\n \n         let macro_def = match self.cstore.load_macro_untracked(def_id, &self.session) {\n             LoadedMacro::MacroDef(macro_def) => macro_def,\n-            LoadedMacro::ProcMacro(ext) => return ext,\n+            LoadedMacro::ProcMacro(ext) => return Some(ext),\n         };\n \n         let ext = Lrc::new(macro_rules::compile(&self.session.parse_sess,\n                                                &self.session.features_untracked(),\n                                                &macro_def,\n                                                self.cstore.crate_edition_untracked(def_id.krate)));\n         self.macro_map.insert(def_id, ext.clone());\n-        ext\n+        Some(ext)\n     }\n \n     /// Ensures that the reduced graph rooted at the given external module"}, {"sha": "0955c425f2f7da821a0e37752c257702bbcc31a1", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 16, "deletions": 5, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/154726cf7d92e72e3386e056cf0ec61902f342cd/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/154726cf7d92e72e3386e056cf0ec61902f342cd/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=154726cf7d92e72e3386e056cf0ec61902f342cd", "patch": "@@ -1106,6 +1106,19 @@ impl<'a> Resolver<'a> {\n         });\n     }\n \n+    crate fn check_reserved_macro_name(&mut self, ident: Ident, res: Res) {\n+        // Reserve some names that are not quite covered by the general check\n+        // performed on `Resolver::builtin_attrs`.\n+        if ident.name == sym::cfg || ident.name == sym::cfg_attr || ident.name == sym::derive {\n+            let macro_kind = self.opt_get_macro(res).map(|ext| ext.macro_kind());\n+            if macro_kind.is_some() && sub_namespace_match(macro_kind, Some(MacroKind::Attr)) {\n+                self.session.span_err(\n+                    ident.span, &format!(\"name `{}` is reserved in attribute namespace\", ident)\n+                );\n+            }\n+        }\n+    }\n+\n     pub fn define_macro(&mut self,\n                         item: &ast::Item,\n                         expansion: Mark,\n@@ -1117,13 +1130,14 @@ impl<'a> Resolver<'a> {\n         let ext = Lrc::new(macro_rules::compile(&self.session.parse_sess,\n                                                &self.session.features_untracked(),\n                                                item, self.session.edition()));\n+        let macro_kind = ext.macro_kind();\n+        let res = Res::Def(DefKind::Macro(macro_kind), def_id);\n         self.macro_map.insert(def_id, ext);\n \n         let def = match item.node { ast::ItemKind::MacroDef(ref def) => def, _ => unreachable!() };\n         if def.legacy {\n             let ident = ident.modern();\n             self.macro_names.insert(ident);\n-            let res = Res::Def(DefKind::Macro(MacroKind::Bang), def_id);\n             let is_macro_export = attr::contains_name(&item.attrs, sym::macro_export);\n             let vis = if is_macro_export {\n                 ty::Visibility::Public\n@@ -1142,14 +1156,11 @@ impl<'a> Resolver<'a> {\n                 self.define(module, ident, MacroNS,\n                             (res, vis, item.span, expansion, IsMacroExport));\n             } else {\n-                if !attr::contains_name(&item.attrs, sym::rustc_doc_only_macro) {\n-                    self.check_reserved_macro_name(ident, MacroNS);\n-                }\n+                self.check_reserved_macro_name(ident, res);\n                 self.unused_macros.insert(def_id);\n             }\n         } else {\n             let module = self.current_module;\n-            let res = Res::Def(DefKind::Macro(MacroKind::Bang), def_id);\n             let vis = self.resolve_visibility(&item.vis);\n             if vis != ty::Visibility::Public {\n                 self.unused_macros.insert(def_id);"}, {"sha": "7de1cd29a9ca84aea1a00764c0f4dc65baba8163", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 5, "deletions": 15, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/154726cf7d92e72e3386e056cf0ec61902f342cd/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/154726cf7d92e72e3386e056cf0ec61902f342cd/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=154726cf7d92e72e3386e056cf0ec61902f342cd", "patch": "@@ -29,7 +29,7 @@ use rustc::{bug, span_bug};\n use syntax::ast::{self, Ident, Name, NodeId, CRATE_NODE_ID};\n use syntax::ext::base::Determinacy::{self, Determined, Undetermined};\n use syntax::ext::hygiene::Mark;\n-use syntax::symbol::{kw, sym};\n+use syntax::symbol::kw;\n use syntax::util::lev_distance::find_best_match_for_name;\n use syntax::{struct_span_err, unwrap_or};\n use syntax_pos::{MultiSpan, Span};\n@@ -492,35 +492,25 @@ impl<'a> Resolver<'a> {\n         })\n     }\n \n-    crate fn check_reserved_macro_name(&self, ident: Ident, ns: Namespace) {\n-        // Reserve some names that are not quite covered by the general check\n-        // performed on `Resolver::builtin_attrs`.\n-        if ns == MacroNS &&\n-           (ident.name == sym::cfg || ident.name == sym::cfg_attr ||\n-            ident.name == sym::derive) {\n-            self.session.span_err(ident.span,\n-                                  &format!(\"name `{}` is reserved in macro namespace\", ident));\n-        }\n-    }\n-\n     // Define the name or return the existing binding if there is a collision.\n     pub fn try_define(&mut self,\n                       module: Module<'a>,\n                       ident: Ident,\n                       ns: Namespace,\n                       binding: &'a NameBinding<'a>)\n                       -> Result<(), &'a NameBinding<'a>> {\n-        self.check_reserved_macro_name(ident, ns);\n+        let res = binding.res();\n+        self.check_reserved_macro_name(ident, res);\n         self.set_binding_parent_module(binding, module);\n         self.update_resolution(module, ident, ns, |this, resolution| {\n             if let Some(old_binding) = resolution.binding {\n-                if binding.res() == Res::Err {\n+                if res == Res::Err {\n                     // Do not override real bindings with `Res::Err`s from error recovery.\n                     return Ok(());\n                 }\n                 match (old_binding.is_glob_import(), binding.is_glob_import()) {\n                     (true, true) => {\n-                        if binding.res() != old_binding.res() {\n+                        if res != old_binding.res() {\n                             resolution.binding = Some(this.ambiguity(AmbiguityKind::GlobVsGlob,\n                                                                      old_binding, binding));\n                         } else if !old_binding.vis.is_at_least(binding.vis, &*this) {"}, {"sha": "b3e09d6974229d7108bdd0af4b4678f0f282154b", "filename": "src/libstd/macros.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/154726cf7d92e72e3386e056cf0ec61902f342cd/src%2Flibstd%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/154726cf7d92e72e3386e056cf0ec61902f342cd/src%2Flibstd%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmacros.rs?ref=154726cf7d92e72e3386e056cf0ec61902f342cd", "patch": "@@ -410,7 +410,7 @@ mod builtin {\n     ///\n     /// [`panic!`]: ../std/macro.panic.html\n     #[stable(feature = \"compile_error_macro\", since = \"1.20.0\")]\n-    #[rustc_doc_only_macro]\n+    #[rustc_builtin_macro]\n     macro_rules! compile_error {\n         ($msg:expr) => ({ /* compiler built-in */ });\n         ($msg:expr,) => ({ /* compiler built-in */ });\n@@ -462,7 +462,7 @@ mod builtin {\n     /// assert_eq!(s, format!(\"hello {}\", \"world\"));\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[rustc_doc_only_macro]\n+    #[rustc_builtin_macro]\n     macro_rules! format_args {\n         ($fmt:expr) => ({ /* compiler built-in */ });\n         ($fmt:expr, $($args:tt)*) => ({ /* compiler built-in */ });\n@@ -500,7 +500,7 @@ mod builtin {\n     /// error: what's that?!\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[rustc_doc_only_macro]\n+    #[rustc_builtin_macro]\n     macro_rules! env {\n         ($name:expr) => ({ /* compiler built-in */ });\n         ($name:expr,) => ({ /* compiler built-in */ });\n@@ -526,7 +526,7 @@ mod builtin {\n     /// println!(\"the secret key might be: {:?}\", key);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[rustc_doc_only_macro]\n+    #[rustc_builtin_macro]\n     macro_rules! option_env {\n         ($name:expr) => ({ /* compiler built-in */ });\n         ($name:expr,) => ({ /* compiler built-in */ });\n@@ -557,7 +557,7 @@ mod builtin {\n     /// # }\n     /// ```\n     #[unstable(feature = \"concat_idents_macro\", issue = \"29599\")]\n-    #[rustc_doc_only_macro]\n+    #[rustc_builtin_macro]\n     macro_rules! concat_idents {\n         ($($e:ident),+) => ({ /* compiler built-in */ });\n         ($($e:ident,)+) => ({ /* compiler built-in */ });\n@@ -579,7 +579,7 @@ mod builtin {\n     /// assert_eq!(s, \"test10btrue\");\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[rustc_doc_only_macro]\n+    #[rustc_builtin_macro]\n     macro_rules! concat {\n         ($($e:expr),*) => ({ /* compiler built-in */ });\n         ($($e:expr,)*) => ({ /* compiler built-in */ });\n@@ -607,7 +607,7 @@ mod builtin {\n     /// println!(\"defined on line: {}\", current_line);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[rustc_doc_only_macro]\n+    #[rustc_builtin_macro]\n     macro_rules! line { () => ({ /* compiler built-in */ }) }\n \n     /// Expands to the column number at which it was invoked.\n@@ -632,7 +632,7 @@ mod builtin {\n     /// println!(\"defined on column: {}\", current_col);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[rustc_doc_only_macro]\n+    #[rustc_builtin_macro]\n     macro_rules! column { () => ({ /* compiler built-in */ }) }\n \n     /// Expands to the file name in which it was invoked.\n@@ -656,7 +656,7 @@ mod builtin {\n     /// println!(\"defined in file: {}\", this_file);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[rustc_doc_only_macro]\n+    #[rustc_builtin_macro]\n     macro_rules! file { () => ({ /* compiler built-in */ }) }\n \n     /// Stringifies its arguments.\n@@ -675,7 +675,7 @@ mod builtin {\n     /// assert_eq!(one_plus_one, \"1 + 1\");\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[rustc_doc_only_macro]\n+    #[rustc_builtin_macro]\n     macro_rules! stringify { ($($t:tt)*) => ({ /* compiler built-in */ }) }\n \n     /// Includes a utf8-encoded file as a string.\n@@ -709,7 +709,7 @@ mod builtin {\n     ///\n     /// Compiling 'main.rs' and running the resulting binary will print \"adi\u00f3s\".\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[rustc_doc_only_macro]\n+    #[rustc_builtin_macro]\n     macro_rules! include_str {\n         ($file:expr) => ({ /* compiler built-in */ });\n         ($file:expr,) => ({ /* compiler built-in */ });\n@@ -746,7 +746,7 @@ mod builtin {\n     ///\n     /// Compiling 'main.rs' and running the resulting binary will print \"adi\u00f3s\".\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[rustc_doc_only_macro]\n+    #[rustc_builtin_macro]\n     macro_rules! include_bytes {\n         ($file:expr) => ({ /* compiler built-in */ });\n         ($file:expr,) => ({ /* compiler built-in */ });\n@@ -770,7 +770,7 @@ mod builtin {\n     /// test::foo();\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[rustc_doc_only_macro]\n+    #[rustc_builtin_macro]\n     macro_rules! module_path { () => ({ /* compiler built-in */ }) }\n \n     /// Evaluates boolean combinations of configuration flags at compile-time.\n@@ -794,7 +794,7 @@ mod builtin {\n     /// };\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[rustc_doc_only_macro]\n+    #[rustc_builtin_macro]\n     macro_rules! cfg { ($($cfg:tt)*) => ({ /* compiler built-in */ }) }\n \n     /// Parses a file as an expression or an item according to the context.\n@@ -837,7 +837,7 @@ mod builtin {\n     /// Compiling 'main.rs' and running the resulting binary will print\n     /// \"\ud83d\ude48\ud83d\ude4a\ud83d\ude49\ud83d\ude48\ud83d\ude4a\ud83d\ude49\".\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[rustc_doc_only_macro]\n+    #[rustc_builtin_macro]\n     macro_rules! include {\n         ($file:expr) => ({ /* compiler built-in */ });\n         ($file:expr,) => ({ /* compiler built-in */ });\n@@ -889,7 +889,7 @@ mod builtin {\n     /// assert!(a + b == 30, \"a = {}, b = {}\", a, b);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[rustc_doc_only_macro]\n+    #[rustc_builtin_macro]\n     macro_rules! assert {\n         ($cond:expr) => ({ /* compiler built-in */ });\n         ($cond:expr,) => ({ /* compiler built-in */ });"}, {"sha": "752ab5d474dffe55042d8054c45ef4d07fcffb6a", "filename": "src/libsyntax/attr/builtin.rs", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/154726cf7d92e72e3386e056cf0ec61902f342cd/src%2Flibsyntax%2Fattr%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/154726cf7d92e72e3386e056cf0ec61902f342cd/src%2Flibsyntax%2Fattr%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr%2Fbuiltin.rs?ref=154726cf7d92e72e3386e056cf0ec61902f342cd", "patch": "@@ -5,6 +5,7 @@ use crate::feature_gate::{Features, GatedCfg};\n use crate::parse::ParseSess;\n \n use errors::{Applicability, Handler};\n+use syntax_pos::hygiene::Transparency;\n use syntax_pos::{symbol::Symbol, symbol::sym, Span};\n \n use super::{mark_used, MetaItemKind};\n@@ -854,3 +855,35 @@ fn int_type_of_word(s: Symbol) -> Option<IntType> {\n         _ => None\n     }\n }\n+\n+pub enum TransparencyError {\n+    UnknownTransparency(Symbol, Span),\n+    MultipleTransparencyAttrs(Span, Span),\n+}\n+\n+pub fn find_transparency(\n+    attrs: &[Attribute], is_legacy: bool\n+) -> (Transparency, Option<TransparencyError>) {\n+    let mut transparency = None;\n+    let mut error = None;\n+    for attr in attrs {\n+        if attr.check_name(sym::rustc_macro_transparency) {\n+            if let Some((_, old_span)) = transparency {\n+                error = Some(TransparencyError::MultipleTransparencyAttrs(old_span, attr.span));\n+                break;\n+            } else if let Some(value) = attr.value_str() {\n+                transparency = Some((match &*value.as_str() {\n+                    \"transparent\" => Transparency::Transparent,\n+                    \"semitransparent\" => Transparency::SemiTransparent,\n+                    \"opaque\" => Transparency::Opaque,\n+                    _ => {\n+                        error = Some(TransparencyError::UnknownTransparency(value, attr.span));\n+                        continue;\n+                    }\n+                }, attr.span));\n+            }\n+        }\n+    }\n+    let fallback = if is_legacy { Transparency::SemiTransparent } else { Transparency::Opaque };\n+    (transparency.map_or(fallback, |t| t.0), error)\n+}"}, {"sha": "a9f2429560ad288ff68901812df07c5ad3e04737", "filename": "src/libsyntax/attr/mod.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/154726cf7d92e72e3386e056cf0ec61902f342cd/src%2Flibsyntax%2Fattr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/154726cf7d92e72e3386e056cf0ec61902f342cd/src%2Flibsyntax%2Fattr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr%2Fmod.rs?ref=154726cf7d92e72e3386e056cf0ec61902f342cd", "patch": "@@ -2,11 +2,7 @@\n \n mod builtin;\n \n-pub use builtin::{\n-    cfg_matches, contains_feature_attr, eval_condition, find_crate_name, find_deprecation,\n-    find_repr_attrs, find_stability, find_unwind_attr, Deprecation, InlineAttr, OptimizeAttr,\n-    IntType, ReprAttr, RustcDeprecation, Stability, StabilityLevel, UnwindAttr,\n-};\n+pub use builtin::*;\n pub use IntType::*;\n pub use ReprAttr::*;\n pub use StabilityLevel::*;"}, {"sha": "cf3c748cd8206f39f2f08fd27ddb6b36ad8d292c", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 14, "deletions": 9, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/154726cf7d92e72e3386e056cf0ec61902f342cd/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/154726cf7d92e72e3386e056cf0ec61902f342cd/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=154726cf7d92e72e3386e056cf0ec61902f342cd", "patch": "@@ -2,7 +2,6 @@ use crate::edition::Edition;\n use crate::ext::base::{DummyResult, ExtCtxt, MacResult, TTMacroExpander};\n use crate::ext::base::{SyntaxExtension, SyntaxExtensionKind};\n use crate::ext::expand::{AstFragment, AstFragmentKind};\n-use crate::ext::hygiene::Transparency;\n use crate::ext::tt::macro_parser::{parse, parse_failure_msg};\n use crate::ext::tt::macro_parser::{Error, Failure, Success};\n use crate::ext::tt::macro_parser::{MatchedNonterminal, MatchedSeq};\n@@ -15,7 +14,7 @@ use crate::parse::token::{self, NtTT, Token};\n use crate::parse::{Directory, ParseSess};\n use crate::symbol::{kw, sym, Symbol};\n use crate::tokenstream::{DelimSpan, TokenStream, TokenTree};\n-use crate::{ast, attr};\n+use crate::{ast, attr, attr::TransparencyError};\n \n use errors::FatalError;\n use log::debug;\n@@ -380,13 +379,19 @@ pub fn compile(\n     let expander: Box<_> =\n         Box::new(MacroRulesMacroExpander { name: def.ident, lhses, rhses, valid });\n \n-    let default_transparency = if attr::contains_name(&def.attrs, sym::rustc_transparent_macro) {\n-        Transparency::Transparent\n-    } else if body.legacy {\n-        Transparency::SemiTransparent\n-    } else {\n-        Transparency::Opaque\n-    };\n+    let (default_transparency, transparency_error) =\n+        attr::find_transparency(&def.attrs, body.legacy);\n+    match transparency_error {\n+        Some(TransparencyError::UnknownTransparency(value, span)) =>\n+            sess.span_diagnostic.span_err(\n+                span, &format!(\"unknown macro transparency: `{}`\", value)\n+            ),\n+        Some(TransparencyError::MultipleTransparencyAttrs(old_span, new_span)) =>\n+            sess.span_diagnostic.span_err(\n+                vec![old_span, new_span], \"multiple macro transparency attributes\"\n+            ),\n+        None => {}\n+    }\n \n     let allow_internal_unstable =\n         attr::find_by_name(&def.attrs, sym::allow_internal_unstable).map(|attr| {"}, {"sha": "2b242a71ad4ccae9bcb0cb001ef8ced9d64da6d5", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/154726cf7d92e72e3386e056cf0ec61902f342cd/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/154726cf7d92e72e3386e056cf0ec61902f342cd/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=154726cf7d92e72e3386e056cf0ec61902f342cd", "patch": "@@ -245,7 +245,7 @@ declare_features! (\n     (active, allocator_internals, \"1.20.0\", None, None),\n \n     // Allows using the `format_args_nl` macro.\n-    (active, format_args_nl, \"1.29.0\", None, None),\n+    (active, format_args_nl, \"1.29.0\", Some(0), None),\n \n     // no-tracking-issue-end\n \n@@ -1313,7 +1313,9 @@ pub const BUILTIN_ATTRIBUTES: &[BuiltinAttribute] = &[\n                                     \"the `#[rustc_test_marker]` attribute \\\n                                     is used internally to track tests\",\n                                     cfg_fn!(rustc_attrs))),\n-    (sym::rustc_transparent_macro, Whitelisted, template!(Word), Gated(Stability::Unstable,\n+    (sym::rustc_macro_transparency, Whitelisted, template!(NameValueStr:\n+                                                           \"transparent|semitransparent|opaque\"),\n+                                                Gated(Stability::Unstable,\n                                                 sym::rustc_attrs,\n                                                 \"used internally for testing macro hygiene\",\n                                                     cfg_fn!(rustc_attrs))),\n@@ -1374,7 +1376,7 @@ pub const BUILTIN_ATTRIBUTES: &[BuiltinAttribute] = &[\n                                                 \"internal implementation detail\",\n                                                 cfg_fn!(rustc_attrs))),\n \n-    (sym::rustc_doc_only_macro, Whitelisted, template!(Word), Gated(Stability::Unstable,\n+    (sym::rustc_builtin_macro, Whitelisted, template!(Word), Gated(Stability::Unstable,\n                                                 sym::rustc_attrs,\n                                                 \"internal implementation detail\",\n                                                 cfg_fn!(rustc_attrs))),"}, {"sha": "410f4b36b67f29c1976ddf890df586237873a40e", "filename": "src/libsyntax_pos/symbol.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/154726cf7d92e72e3386e056cf0ec61902f342cd/src%2Flibsyntax_pos%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/154726cf7d92e72e3386e056cf0ec61902f342cd/src%2Flibsyntax_pos%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fsymbol.rs?ref=154726cf7d92e72e3386e056cf0ec61902f342cd", "patch": "@@ -537,6 +537,7 @@ symbols! {\n         rustc_allow_const_fn_ptr,\n         rustc_args_required_const,\n         rustc_attrs,\n+        rustc_builtin_macro,\n         rustc_clean,\n         rustc_const_unstable,\n         rustc_conversion_suggestion,\n@@ -545,7 +546,6 @@ symbols! {\n         rustc_deprecated,\n         rustc_diagnostic_macros,\n         rustc_dirty,\n-        rustc_doc_only_macro,\n         rustc_dummy,\n         rustc_dump_env_program_clauses,\n         rustc_dump_program_clauses,\n@@ -557,6 +557,7 @@ symbols! {\n         rustc_layout,\n         rustc_layout_scalar_valid_range_end,\n         rustc_layout_scalar_valid_range_start,\n+        rustc_macro_transparency,\n         rustc_mir,\n         rustc_nonnull_optimization_guaranteed,\n         rustc_object_lifetime_default,\n@@ -579,7 +580,6 @@ symbols! {\n         rustc_synthetic,\n         rustc_test_marker,\n         rustc_then_this_would_need,\n-        rustc_transparent_macro,\n         rustc_variance,\n         rustdoc,\n         rust_eh_personality,"}, {"sha": "37de27ee8005da3a26f9b59cbb3ddeec4e338f7d", "filename": "src/test/ui/hygiene/auxiliary/transparent-basic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/154726cf7d92e72e3386e056cf0ec61902f342cd/src%2Ftest%2Fui%2Fhygiene%2Fauxiliary%2Ftransparent-basic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/154726cf7d92e72e3386e056cf0ec61902f342cd/src%2Ftest%2Fui%2Fhygiene%2Fauxiliary%2Ftransparent-basic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhygiene%2Fauxiliary%2Ftransparent-basic.rs?ref=154726cf7d92e72e3386e056cf0ec61902f342cd", "patch": "@@ -1,6 +1,6 @@\n #![feature(decl_macro, rustc_attrs)]\n \n-#[rustc_transparent_macro]\n+#[rustc_macro_transparency = \"transparent\"]\n pub macro dollar_crate() {\n     let s = $crate::S;\n }"}, {"sha": "8826293542c9736e0b5944885ee56a2eb58b623a", "filename": "src/test/ui/hygiene/generate-mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/154726cf7d92e72e3386e056cf0ec61902f342cd/src%2Ftest%2Fui%2Fhygiene%2Fgenerate-mod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/154726cf7d92e72e3386e056cf0ec61902f342cd/src%2Ftest%2Fui%2Fhygiene%2Fgenerate-mod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhygiene%2Fgenerate-mod.rs?ref=154726cf7d92e72e3386e056cf0ec61902f342cd", "patch": "@@ -11,7 +11,7 @@ macro genmod($FromOutside: ident, $Outer: ident) {\n     }\n }\n \n-#[rustc_transparent_macro]\n+#[rustc_macro_transparency = \"transparent\"]\n macro genmod_transparent() {\n     type A = FromOutside;\n     struct Outer;"}, {"sha": "a0a3d411d28b26b55907281b18e93f261fbb76d6", "filename": "src/test/ui/hygiene/rustc-macro-transparency.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/154726cf7d92e72e3386e056cf0ec61902f342cd/src%2Ftest%2Fui%2Fhygiene%2Frustc-macro-transparency.rs", "raw_url": "https://github.com/rust-lang/rust/raw/154726cf7d92e72e3386e056cf0ec61902f342cd/src%2Ftest%2Fui%2Fhygiene%2Frustc-macro-transparency.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhygiene%2Frustc-macro-transparency.rs?ref=154726cf7d92e72e3386e056cf0ec61902f342cd", "patch": "@@ -0,0 +1,31 @@\n+#![feature(decl_macro, rustc_attrs)]\n+\n+#[rustc_macro_transparency = \"transparent\"]\n+macro transparent() {\n+    struct Transparent;\n+    let transparent = 0;\n+}\n+#[rustc_macro_transparency = \"semitransparent\"]\n+macro semitransparent() {\n+    struct SemiTransparent;\n+    let semitransparent = 0;\n+}\n+#[rustc_macro_transparency = \"opaque\"]\n+macro opaque() {\n+    struct Opaque;\n+    let opaque = 0;\n+}\n+\n+fn main() {\n+    transparent!();\n+    semitransparent!();\n+    opaque!();\n+\n+    Transparent; // OK\n+    SemiTransparent; // OK\n+    Opaque; //~ ERROR cannot find value `Opaque` in this scope\n+\n+    transparent; // OK\n+    semitransparent; //~ ERROR cannot find value `semitransparent` in this scope\n+    opaque; //~ ERROR cannot find value `opaque` in this scope\n+}"}, {"sha": "2a9df221e2c87e115190dd23b25c265ba1f615a7", "filename": "src/test/ui/hygiene/rustc-macro-transparency.stderr", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/154726cf7d92e72e3386e056cf0ec61902f342cd/src%2Ftest%2Fui%2Fhygiene%2Frustc-macro-transparency.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/154726cf7d92e72e3386e056cf0ec61902f342cd/src%2Ftest%2Fui%2Fhygiene%2Frustc-macro-transparency.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhygiene%2Frustc-macro-transparency.stderr?ref=154726cf7d92e72e3386e056cf0ec61902f342cd", "patch": "@@ -0,0 +1,21 @@\n+error[E0425]: cannot find value `Opaque` in this scope\n+  --> $DIR/rustc-macro-transparency.rs:26:5\n+   |\n+LL |     Opaque;\n+   |     ^^^^^^ help: a local variable with a similar name exists: `opaque`\n+\n+error[E0425]: cannot find value `semitransparent` in this scope\n+  --> $DIR/rustc-macro-transparency.rs:29:5\n+   |\n+LL |     semitransparent;\n+   |     ^^^^^^^^^^^^^^^ not found in this scope\n+\n+error[E0425]: cannot find value `opaque` in this scope\n+  --> $DIR/rustc-macro-transparency.rs:30:5\n+   |\n+LL |     opaque;\n+   |     ^^^^^^ not found in this scope\n+\n+error: aborting due to 3 previous errors\n+\n+For more information about this error, try `rustc --explain E0425`."}, {"sha": "69dfc524989a44c98c50a5f3f33ecb18a1262dd0", "filename": "src/test/ui/hygiene/transparent-basic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/154726cf7d92e72e3386e056cf0ec61902f342cd/src%2Ftest%2Fui%2Fhygiene%2Ftransparent-basic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/154726cf7d92e72e3386e056cf0ec61902f342cd/src%2Ftest%2Fui%2Fhygiene%2Ftransparent-basic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhygiene%2Ftransparent-basic.rs?ref=154726cf7d92e72e3386e056cf0ec61902f342cd", "patch": "@@ -5,12 +5,12 @@\n \n extern crate transparent_basic;\n \n-#[rustc_transparent_macro]\n+#[rustc_macro_transparency = \"transparent\"]\n macro binding() {\n     let x = 10;\n }\n \n-#[rustc_transparent_macro]\n+#[rustc_macro_transparency = \"transparent\"]\n macro label() {\n     break 'label\n }"}, {"sha": "a8818507d75d21cf07737c97410b5cdb7e6fd0ca", "filename": "src/test/ui/macros/restricted-shadowing-modern.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/154726cf7d92e72e3386e056cf0ec61902f342cd/src%2Ftest%2Fui%2Fmacros%2Frestricted-shadowing-modern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/154726cf7d92e72e3386e056cf0ec61902f342cd/src%2Ftest%2Fui%2Fmacros%2Frestricted-shadowing-modern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Frestricted-shadowing-modern.rs?ref=154726cf7d92e72e3386e056cf0ec61902f342cd", "patch": "@@ -80,17 +80,17 @@\n struct Right;\n // struct Wrong; // not defined\n \n-#[rustc_transparent_macro]\n+#[rustc_macro_transparency = \"transparent\"]\n macro include() {\n-    #[rustc_transparent_macro]\n+    #[rustc_macro_transparency = \"transparent\"]\n     macro gen_outer() {\n         macro m() { Wrong }\n     }\n-    #[rustc_transparent_macro]\n+    #[rustc_macro_transparency = \"transparent\"]\n     macro gen_inner() {\n         macro m() { Right }\n     }\n-    #[rustc_transparent_macro]\n+    #[rustc_macro_transparency = \"transparent\"]\n     macro gen_invoc() {\n         m!()\n     }\n@@ -100,7 +100,7 @@ macro include() {\n     fn check1() {\n         macro m() {}\n         {\n-            #[rustc_transparent_macro]\n+            #[rustc_macro_transparency = \"transparent\"]\n             macro gen_gen_inner_invoc() {\n                 gen_inner!();\n                 m!(); //~ ERROR `m` is ambiguous\n@@ -112,7 +112,7 @@ macro include() {\n     fn check5() {\n         macro m() { Wrong }\n         {\n-            #[rustc_transparent_macro]\n+            #[rustc_macro_transparency = \"transparent\"]\n             macro gen_inner_invoc() {\n                 macro m() { Right }\n                 m!(); // OK\n@@ -124,7 +124,7 @@ macro include() {\n     fn check9() {\n         macro m() { Wrong }\n         {\n-            #[rustc_transparent_macro]\n+            #[rustc_macro_transparency = \"transparent\"]\n             macro gen_inner_gen_invoc() {\n                 macro m() { Right }\n                 gen_invoc!(); // OK\n@@ -145,7 +145,7 @@ macro include() {\n         macro m() {}\n         {\n             gen_inner!();\n-            #[rustc_transparent_macro]\n+            #[rustc_macro_transparency = \"transparent\"]\n             macro gen_invoc() { m!() } //~ ERROR `m` is ambiguous\n             gen_invoc!();\n         }\n@@ -186,7 +186,7 @@ macro include() {\n     fn check52() {\n         gen_outer!();\n         {\n-            #[rustc_transparent_macro]\n+            #[rustc_macro_transparency = \"transparent\"]\n             macro gen_gen_inner_invoc() {\n                 gen_inner!();\n                 m!(); //~ ERROR `m` is ambiguous\n@@ -198,7 +198,7 @@ macro include() {\n     fn check56() {\n         gen_outer!();\n         {\n-            #[rustc_transparent_macro]\n+            #[rustc_macro_transparency = \"transparent\"]\n             macro gen_inner_invoc() {\n                 macro m() { Right }\n                 m!(); // OK\n@@ -218,7 +218,7 @@ macro include() {\n     fn check60() {\n         gen_outer!();\n         {\n-            #[rustc_transparent_macro]\n+            #[rustc_macro_transparency = \"transparent\"]\n             macro gen_inner_gen_invoc() {\n                 macro m() { Right }\n                 gen_invoc!(); // OK\n@@ -231,7 +231,7 @@ macro include() {\n         gen_outer!();\n         {\n             gen_inner!();\n-            #[rustc_transparent_macro]\n+            #[rustc_macro_transparency = \"transparent\"]\n             macro gen_invoc() { m!() } //~ ERROR `m` is ambiguous\n             gen_invoc!();\n         }"}, {"sha": "9f56eccb7a61c1f26d7ab059cf71f01796a1c781", "filename": "src/test/ui/proc-macro/reserved-macro-names.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/154726cf7d92e72e3386e056cf0ec61902f342cd/src%2Ftest%2Fui%2Fproc-macro%2Freserved-macro-names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/154726cf7d92e72e3386e056cf0ec61902f342cd/src%2Ftest%2Fui%2Fproc-macro%2Freserved-macro-names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Freserved-macro-names.rs?ref=154726cf7d92e72e3386e056cf0ec61902f342cd", "patch": "@@ -8,18 +8,18 @@ use proc_macro::*;\n \n #[proc_macro_attribute]\n pub fn cfg(_: TokenStream, input: TokenStream) -> TokenStream {\n-    //~^ ERROR name `cfg` is reserved in macro namespace\n+    //~^ ERROR name `cfg` is reserved in attribute namespace\n     input\n }\n \n #[proc_macro_attribute]\n pub fn cfg_attr(_: TokenStream, input: TokenStream) -> TokenStream {\n-    //~^ ERROR name `cfg_attr` is reserved in macro namespace\n+    //~^ ERROR name `cfg_attr` is reserved in attribute namespace\n     input\n }\n \n #[proc_macro_attribute]\n pub fn derive(_: TokenStream, input: TokenStream) -> TokenStream {\n-    //~^ ERROR name `derive` is reserved in macro namespace\n+    //~^ ERROR name `derive` is reserved in attribute namespace\n     input\n }"}, {"sha": "f871e43ce51df80b25eca0c6dfdd55bb54dfc10d", "filename": "src/test/ui/proc-macro/reserved-macro-names.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/154726cf7d92e72e3386e056cf0ec61902f342cd/src%2Ftest%2Fui%2Fproc-macro%2Freserved-macro-names.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/154726cf7d92e72e3386e056cf0ec61902f342cd/src%2Ftest%2Fui%2Fproc-macro%2Freserved-macro-names.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Freserved-macro-names.stderr?ref=154726cf7d92e72e3386e056cf0ec61902f342cd", "patch": "@@ -1,16 +1,16 @@\n-error: name `cfg` is reserved in macro namespace\n+error: name `cfg` is reserved in attribute namespace\n   --> $DIR/reserved-macro-names.rs:10:8\n    |\n LL | pub fn cfg(_: TokenStream, input: TokenStream) -> TokenStream {\n    |        ^^^\n \n-error: name `cfg_attr` is reserved in macro namespace\n+error: name `cfg_attr` is reserved in attribute namespace\n   --> $DIR/reserved-macro-names.rs:16:8\n    |\n LL | pub fn cfg_attr(_: TokenStream, input: TokenStream) -> TokenStream {\n    |        ^^^^^^^^\n \n-error: name `derive` is reserved in macro namespace\n+error: name `derive` is reserved in attribute namespace\n   --> $DIR/reserved-macro-names.rs:22:8\n    |\n LL | pub fn derive(_: TokenStream, input: TokenStream) -> TokenStream {"}, {"sha": "58c6aa12dc48db2580e1dbdb4b45d778f8e9d920", "filename": "src/tools/tidy/src/libcoretest.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/154726cf7d92e72e3386e056cf0ec61902f342cd/src%2Ftools%2Ftidy%2Fsrc%2Flibcoretest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/154726cf7d92e72e3386e056cf0ec61902f342cd/src%2Ftools%2Ftidy%2Fsrc%2Flibcoretest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Flibcoretest.rs?ref=154726cf7d92e72e3386e056cf0ec61902f342cd", "patch": "@@ -13,7 +13,8 @@ pub fn check(path: &Path, bad: &mut bool) {\n         &mut |entry, contents| {\n             let subpath = entry.path();\n             if let Some(\"rs\") = subpath.extension().and_then(|e| e.to_str()) {\n-                if contents.contains(\"#[test]\") {\n+                let contents = contents.trim();\n+                if !contents.starts_with(\"//\") && contents.contains(\"#[test]\") {\n                     tidy_error!(\n                         bad,\n                         \"{} contains #[test]; libcore tests must be placed inside \\"}]}