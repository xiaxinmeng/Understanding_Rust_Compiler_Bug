{"sha": "b12af86a776364f01f65e3bd551e2641b4fac4ec", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIxMmFmODZhNzc2MzY0ZjAxZjY1ZTNiZDU1MWUyNjQxYjRmYWM0ZWM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-04-03T09:11:35Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-04-03T09:11:35Z"}, "message": "Auto merge of #49348 - bobtwinkles:extend_2pb, r=nikomatsakis\n\nExtend two-phase borrows to apply to method receiver autorefs\n\nFixes #48598 by permitting two-phase borrows on the autorefs created when functions and methods.", "tree": {"sha": "193b8f2cf8fdbf99d3652f00aca47d451799fb60", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/193b8f2cf8fdbf99d3652f00aca47d451799fb60"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b12af86a776364f01f65e3bd551e2641b4fac4ec", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b12af86a776364f01f65e3bd551e2641b4fac4ec", "html_url": "https://github.com/rust-lang/rust/commit/b12af86a776364f01f65e3bd551e2641b4fac4ec", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b12af86a776364f01f65e3bd551e2641b4fac4ec/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "577d29c10aed2d6e024fb2a532898be904abd115", "url": "https://api.github.com/repos/rust-lang/rust/commits/577d29c10aed2d6e024fb2a532898be904abd115", "html_url": "https://github.com/rust-lang/rust/commit/577d29c10aed2d6e024fb2a532898be904abd115"}, {"sha": "d8352af934ef751bb75d9ca310ed5b02ea0753cb", "url": "https://api.github.com/repos/rust-lang/rust/commits/d8352af934ef751bb75d9ca310ed5b02ea0753cb", "html_url": "https://github.com/rust-lang/rust/commit/d8352af934ef751bb75d9ca310ed5b02ea0753cb"}], "stats": {"total": 212, "additions": 155, "deletions": 57}, "files": [{"sha": "340dd32a237c01fa29240d207cd700435e35ebc6", "filename": "src/librustc/ich/impls_ty.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b12af86a776364f01f65e3bd551e2641b4fac4ec/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b12af86a776364f01f65e3bd551e2641b4fac4ec/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_ty.rs?ref=b12af86a776364f01f65e3bd551e2641b4fac4ec", "patch": "@@ -188,6 +188,10 @@ for ty::adjustment::Adjust<'gcx> {\n impl_stable_hash_for!(struct ty::adjustment::Adjustment<'tcx> { kind, target });\n impl_stable_hash_for!(struct ty::adjustment::OverloadedDeref<'tcx> { region, mutbl });\n impl_stable_hash_for!(struct ty::UpvarBorrow<'tcx> { kind, region });\n+impl_stable_hash_for!(enum ty::adjustment::AllowTwoPhase {\n+    Yes,\n+    No\n+});\n \n impl<'gcx> HashStable<StableHashingContext<'gcx>> for ty::adjustment::AutoBorrowMutability {\n     fn hash_stable<W: StableHasherResult>(&self,"}, {"sha": "a0c31e8b509239230c7b909d180bf3f86f9f224a", "filename": "src/librustc/ty/adjustment.rs", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/b12af86a776364f01f65e3bd551e2641b4fac4ec/src%2Flibrustc%2Fty%2Fadjustment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b12af86a776364f01f65e3bd551e2641b4fac4ec/src%2Flibrustc%2Fty%2Fadjustment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fadjustment.rs?ref=b12af86a776364f01f65e3bd551e2641b4fac4ec", "patch": "@@ -119,9 +119,27 @@ impl<'a, 'gcx, 'tcx> OverloadedDeref<'tcx> {\n     }\n }\n \n+/// At least for initial deployment, we want to limit two-phase borrows to\n+/// only a few specific cases. Right now, those mostly \"things that desugar\"\n+/// into method calls\n+///     - using x.some_method() syntax, where some_method takes &mut self\n+///     - using Foo::some_method(&mut x, ...) syntax\n+///     - binary assignment operators (+=, -=, *=, etc.)\n+/// Anything else should be rejected until generalized two phase borrow support\n+/// is implemented. Right now, dataflow can't handle the general case where there\n+/// is more than one use of a mutable borrow, and we don't want to accept too much\n+/// new code via two-phase borrows, so we try to limit where we create two-phase\n+/// capable mutable borrows.\n+/// See #49434 for tracking.\n+#[derive(Copy, Clone, PartialEq, Debug, RustcEncodable, RustcDecodable)]\n+pub enum AllowTwoPhase {\n+    Yes,\n+    No\n+}\n+\n #[derive(Copy, Clone, PartialEq, Debug, RustcEncodable, RustcDecodable)]\n pub enum AutoBorrowMutability {\n-    Mutable { allow_two_phase_borrow: bool },\n+    Mutable { allow_two_phase_borrow: AllowTwoPhase },\n     Immutable,\n }\n "}, {"sha": "5b3739084801f093e80d25013dfc1228ae36bac4", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b12af86a776364f01f65e3bd551e2641b4fac4ec/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b12af86a776364f01f65e3bd551e2641b4fac4ec/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=b12af86a776364f01f65e3bd551e2641b4fac4ec", "patch": "@@ -662,9 +662,13 @@ trait ToBorrowKind { fn to_borrow_kind(&self) -> BorrowKind; }\n \n impl ToBorrowKind for AutoBorrowMutability {\n     fn to_borrow_kind(&self) -> BorrowKind {\n+        use rustc::ty::adjustment::AllowTwoPhase;\n         match *self {\n             AutoBorrowMutability::Mutable { allow_two_phase_borrow } =>\n-                BorrowKind::Mut { allow_two_phase_borrow },\n+                BorrowKind::Mut { allow_two_phase_borrow: match allow_two_phase_borrow {\n+                    AllowTwoPhase::Yes => true,\n+                    AllowTwoPhase::No => false\n+                }},\n             AutoBorrowMutability::Immutable =>\n                 BorrowKind::Shared,\n         }"}, {"sha": "b1fb0938698cbe3f5899fd750d9bae38c1245052", "filename": "src/librustc_typeck/check/callee.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b12af86a776364f01f65e3bd551e2641b4fac4ec/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b12af86a776364f01f65e3bd551e2641b4fac4ec/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs?ref=b12af86a776364f01f65e3bd551e2641b4fac4ec", "patch": "@@ -16,7 +16,7 @@ use hir::def::Def;\n use hir::def_id::{DefId, LOCAL_CRATE};\n use rustc::{infer, traits};\n use rustc::ty::{self, TyCtxt, TypeFoldable, Ty};\n-use rustc::ty::adjustment::{Adjustment, Adjust, AutoBorrow, AutoBorrowMutability};\n+use rustc::ty::adjustment::{Adjustment, Adjust, AllowTwoPhase, AutoBorrow, AutoBorrowMutability};\n use syntax::abi;\n use syntax::symbol::Symbol;\n use syntax_pos::Span;\n@@ -182,7 +182,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                     // For initial two-phase borrow\n                                     // deployment, conservatively omit\n                                     // overloaded function call ops.\n-                                    allow_two_phase_borrow: false,\n+                                    allow_two_phase_borrow: AllowTwoPhase::No,\n                                 }\n                             };\n                             autoref = Some(Adjustment {"}, {"sha": "8db8e52b10d4ab4dc048f64e6bb356663163673d", "filename": "src/librustc_typeck/check/cast.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b12af86a776364f01f65e3bd551e2641b4fac4ec/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b12af86a776364f01f65e3bd551e2641b4fac4ec/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs?ref=b12af86a776364f01f65e3bd551e2641b4fac4ec", "patch": "@@ -47,6 +47,7 @@ use rustc::hir;\n use rustc::session::Session;\n use rustc::traits;\n use rustc::ty::{self, Ty, TypeFoldable};\n+use rustc::ty::adjustment::AllowTwoPhase;\n use rustc::ty::cast::{CastKind, CastTy};\n use rustc::ty::subst::Substs;\n use rustc::middle::lang_items;\n@@ -434,7 +435,8 @@ impl<'a, 'gcx, 'tcx> CastCheck<'tcx> {\n                     let f = self.expr_ty.fn_sig(fcx.tcx);\n                     let res = fcx.try_coerce(self.expr,\n                                              self.expr_ty,\n-                                             fcx.tcx.mk_fn_ptr(f));\n+                                             fcx.tcx.mk_fn_ptr(f),\n+                                             AllowTwoPhase::No);\n                     if !res.is_ok() {\n                         return Err(CastError::NonScalar);\n                     }\n@@ -616,7 +618,7 @@ impl<'a, 'gcx, 'tcx> CastCheck<'tcx> {\n     }\n \n     fn try_coercion_cast(&self, fcx: &FnCtxt<'a, 'gcx, 'tcx>) -> bool {\n-        fcx.try_coerce(self.expr, self.expr_ty, self.cast_ty).is_ok()\n+        fcx.try_coerce(self.expr, self.expr_ty, self.cast_ty, AllowTwoPhase::No).is_ok()\n     }\n }\n "}, {"sha": "a8d1f69dfe84b1cdd3006570a22482f93e298ff4", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 30, "deletions": 12, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/b12af86a776364f01f65e3bd551e2641b4fac4ec/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b12af86a776364f01f65e3bd551e2641b4fac4ec/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=b12af86a776364f01f65e3bd551e2641b4fac4ec", "patch": "@@ -67,7 +67,7 @@ use rustc::hir::def_id::DefId;\n use rustc::infer::{Coercion, InferResult, InferOk};\n use rustc::infer::type_variable::TypeVariableOrigin;\n use rustc::traits::{self, ObligationCause, ObligationCauseCode};\n-use rustc::ty::adjustment::{Adjustment, Adjust, AutoBorrow, AutoBorrowMutability};\n+use rustc::ty::adjustment::{Adjustment, Adjust, AllowTwoPhase, AutoBorrow, AutoBorrowMutability};\n use rustc::ty::{self, TypeAndMut, Ty, ClosureSubsts};\n use rustc::ty::fold::TypeFoldable;\n use rustc::ty::error::TypeError;\n@@ -84,6 +84,13 @@ struct Coerce<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n     fcx: &'a FnCtxt<'a, 'gcx, 'tcx>,\n     cause: ObligationCause<'tcx>,\n     use_lub: bool,\n+    /// Determines whether or not allow_two_phase_borrow is set on any\n+    /// autoref adjustments we create while coercing. We don't want to\n+    /// allow deref coercions to create two-phase borrows, at least initially,\n+    /// but we do need two-phase borrows for function argument reborrows.\n+    /// See #47489 and #48598\n+    /// See docs on the \"AllowTwoPhase\" type for a more detailed discussion\n+    allow_two_phase: AllowTwoPhase,\n }\n \n impl<'a, 'gcx, 'tcx> Deref for Coerce<'a, 'gcx, 'tcx> {\n@@ -123,10 +130,13 @@ fn success<'tcx>(adj: Vec<Adjustment<'tcx>>,\n }\n \n impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n-    fn new(fcx: &'f FnCtxt<'f, 'gcx, 'tcx>, cause: ObligationCause<'tcx>) -> Self {\n+    fn new(fcx: &'f FnCtxt<'f, 'gcx, 'tcx>,\n+           cause: ObligationCause<'tcx>,\n+           allow_two_phase: AllowTwoPhase) -> Self {\n         Coerce {\n             fcx,\n             cause,\n+            allow_two_phase,\n             use_lub: false,\n         }\n     }\n@@ -423,10 +433,7 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n         let mutbl = match mt_b.mutbl {\n             hir::MutImmutable => AutoBorrowMutability::Immutable,\n             hir::MutMutable => AutoBorrowMutability::Mutable {\n-                // Deref-coercion is a case where we deliberately\n-                // disallow two-phase borrows in its initial\n-                // deployment; see discussion on PR #47489.\n-                allow_two_phase_borrow: false,\n+                allow_two_phase_borrow: self.allow_two_phase,\n             }\n         };\n         adjustments.push(Adjustment {\n@@ -472,7 +479,10 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n                 let mutbl = match mt_b.mutbl {\n                     hir::MutImmutable => AutoBorrowMutability::Immutable,\n                     hir::MutMutable => AutoBorrowMutability::Mutable {\n-                        allow_two_phase_borrow: false,\n+                        // We don't allow two-phase borrows here, at least for initial\n+                        // implementation. If it happens that this coercion is a function argument,\n+                        // the reborrow in coerce_borrowed_ptr will pick it up.\n+                        allow_two_phase_borrow: AllowTwoPhase::No,\n                     }\n                 };\n                 Some((Adjustment {\n@@ -750,13 +760,14 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     pub fn try_coerce(&self,\n                       expr: &hir::Expr,\n                       expr_ty: Ty<'tcx>,\n-                      target: Ty<'tcx>)\n+                      target: Ty<'tcx>,\n+                      allow_two_phase: AllowTwoPhase)\n                       -> RelateResult<'tcx, Ty<'tcx>> {\n         let source = self.resolve_type_vars_with_obligations(expr_ty);\n         debug!(\"coercion::try({:?}: {:?} -> {:?})\", expr, source, target);\n \n         let cause = self.cause(expr.span, ObligationCauseCode::ExprAssignable);\n-        let coerce = Coerce::new(self, cause);\n+        let coerce = Coerce::new(self, cause, allow_two_phase);\n         let ok = self.commit_if_ok(|_| coerce.coerce(source, target))?;\n \n         let (adjustments, _) = self.register_infer_ok_obligations(ok);\n@@ -770,7 +781,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         debug!(\"coercion::can({:?} -> {:?})\", source, target);\n \n         let cause = self.cause(syntax_pos::DUMMY_SP, ObligationCauseCode::ExprAssignable);\n-        let coerce = Coerce::new(self, cause);\n+        // We don't ever need two-phase here since we throw out the result of the coercion\n+        let coerce = Coerce::new(self, cause, AllowTwoPhase::No);\n         self.probe(|_| coerce.coerce(source, target)).is_ok()\n     }\n \n@@ -839,7 +851,12 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             return Ok(fn_ptr);\n         }\n \n-        let mut coerce = Coerce::new(self, cause.clone());\n+        // Configure a Coerce instance to compute the LUB.\n+        // We don't allow two-phase borrows on any autorefs this creates since we\n+        // probably aren't processing function arguments here and even if we were,\n+        // they're going to get autorefed again anyway and we can apply 2-phase borrows\n+        // at that time.\n+        let mut coerce = Coerce::new(self, cause.clone(), AllowTwoPhase::No);\n         coerce.use_lub = true;\n \n         // First try to coerce the new expression to the type of the previous ones,\n@@ -1105,7 +1122,8 @@ impl<'gcx, 'tcx, 'exprs, E> CoerceMany<'gcx, 'tcx, 'exprs, E>\n             if self.pushed == 0 {\n                 // Special-case the first expression we are coercing.\n                 // To be honest, I'm not entirely sure why we do this.\n-                fcx.try_coerce(expression, expression_ty, self.expected_ty)\n+                // We don't allow two-phase borrows, see comment in try_find_coercion_lub for why\n+                fcx.try_coerce(expression, expression_ty, self.expected_ty, AllowTwoPhase::No)\n             } else {\n                 match self.expressions {\n                     Expressions::Dynamic(ref exprs) =>"}, {"sha": "ecfe1416050290b3277aa6fbf3da5b97de944fca", "filename": "src/librustc_typeck/check/demand.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/b12af86a776364f01f65e3bd551e2641b4fac4ec/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b12af86a776364f01f65e3bd551e2641b4fac4ec/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs?ref=b12af86a776364f01f65e3bd551e2641b4fac4ec", "patch": "@@ -22,6 +22,7 @@ use rustc::hir::def::Def;\n use rustc::hir::map::NodeItem;\n use rustc::hir::{Item, ItemConst, print};\n use rustc::ty::{self, Ty, AssociatedItem};\n+use rustc::ty::adjustment::AllowTwoPhase;\n use errors::{DiagnosticBuilder, CodeMapper};\n \n use super::method::probe;\n@@ -80,9 +81,10 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     pub fn demand_coerce(&self,\n                          expr: &hir::Expr,\n                          checked_ty: Ty<'tcx>,\n-                         expected: Ty<'tcx>)\n+                         expected: Ty<'tcx>,\n+                         allow_two_phase: AllowTwoPhase)\n                          -> Ty<'tcx> {\n-        let (ty, err) = self.demand_coerce_diag(expr, checked_ty, expected);\n+        let (ty, err) = self.demand_coerce_diag(expr, checked_ty, expected, allow_two_phase);\n         if let Some(mut err) = err {\n             err.emit();\n         }\n@@ -97,11 +99,12 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     pub fn demand_coerce_diag(&self,\n                               expr: &hir::Expr,\n                               checked_ty: Ty<'tcx>,\n-                              expected: Ty<'tcx>)\n+                              expected: Ty<'tcx>,\n+                              allow_two_phase: AllowTwoPhase)\n                               -> (Ty<'tcx>, Option<DiagnosticBuilder<'tcx>>) {\n         let expected = self.resolve_type_vars_with_obligations(expected);\n \n-        let e = match self.try_coerce(expr, checked_ty, expected) {\n+        let e = match self.try_coerce(expr, checked_ty, expected, allow_two_phase) {\n             Ok(ty) => return (ty, None),\n             Err(e) => e\n         };"}, {"sha": "19a1efc991d2bff5d968cf76545d2ce8438a4774", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b12af86a776364f01f65e3bd551e2641b4fac4ec/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b12af86a776364f01f65e3bd551e2641b4fac4ec/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=b12af86a776364f01f65e3bd551e2641b4fac4ec", "patch": "@@ -17,7 +17,8 @@ use rustc::ty::subst::Substs;\n use rustc::traits;\n use rustc::ty::{self, Ty};\n use rustc::ty::subst::Subst;\n-use rustc::ty::adjustment::{Adjustment, Adjust, AutoBorrow, AutoBorrowMutability, OverloadedDeref};\n+use rustc::ty::adjustment::{Adjustment, Adjust, OverloadedDeref};\n+use rustc::ty::adjustment::{AllowTwoPhase, AutoBorrow, AutoBorrowMutability};\n use rustc::ty::fold::TypeFoldable;\n use rustc::infer::{self, InferOk};\n use syntax_pos::Span;\n@@ -170,7 +171,7 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n                 hir::MutMutable => AutoBorrowMutability::Mutable {\n                     // Method call receivers are the primary use case\n                     // for two-phase borrows.\n-                    allow_two_phase_borrow: true,\n+                    allow_two_phase_borrow: AllowTwoPhase::Yes,\n                 }\n             };\n             adjustments.push(Adjustment {\n@@ -544,7 +545,7 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n                             // For initial two-phase borrow\n                             // deployment, conservatively omit\n                             // overloaded operators.\n-                            allow_two_phase_borrow: false,\n+                            allow_two_phase_borrow: AllowTwoPhase::No,\n                         }\n                     };\n                     adjustment.kind = Adjust::Borrow(AutoBorrow::Ref(region, mutbl));"}, {"sha": "f1896be000f630c22d819aef0d6112699da50871", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 17, "deletions": 11, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/b12af86a776364f01f65e3bd551e2641b4fac4ec/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b12af86a776364f01f65e3bd551e2641b4fac4ec/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=b12af86a776364f01f65e3bd551e2641b4fac4ec", "patch": "@@ -97,7 +97,7 @@ use rustc::mir::interpret::{GlobalId};\n use rustc::ty::subst::{Kind, Subst, Substs};\n use rustc::traits::{self, ObligationCause, ObligationCauseCode, TraitEngine};\n use rustc::ty::{self, Ty, TyCtxt, Visibility, ToPredicate};\n-use rustc::ty::adjustment::{Adjust, Adjustment, AutoBorrow, AutoBorrowMutability};\n+use rustc::ty::adjustment::{Adjust, Adjustment, AllowTwoPhase, AutoBorrow, AutoBorrowMutability};\n use rustc::ty::fold::TypeFoldable;\n use rustc::ty::maps::Providers;\n use rustc::ty::util::{Representability, IntTypeExt, Discr};\n@@ -2377,12 +2377,11 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     let mutbl = match mt.mutbl {\n                         hir::MutImmutable => AutoBorrowMutability::Immutable,\n                         hir::MutMutable => AutoBorrowMutability::Mutable {\n-                            // FIXME (#46747): arguably indexing is\n-                            // \"just another kind of call\"; perhaps it\n-                            // would be more consistent to allow\n-                            // two-phase borrows for .index()\n-                            // receivers here.\n-                            allow_two_phase_borrow: false,\n+                            // Indexing can be desugared to a method call,\n+                            // so maybe we could use two-phase here.\n+                            // See the documentation of AllowTwoPhase for why that's\n+                            // not the case today.\n+                            allow_two_phase_borrow: AllowTwoPhase::No,\n                         }\n                     };\n                     adjustments.push(Adjustment {\n@@ -2685,7 +2684,12 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 //    to, which is `expected_ty` if `rvalue_hint` returns an\n                 //    `ExpectHasType(expected_ty)`, or the `formal_ty` otherwise.\n                 let coerce_ty = expected.and_then(|e| e.only_has_type(self));\n-                self.demand_coerce(&arg, checked_ty, coerce_ty.unwrap_or(formal_ty));\n+                // We're processing function arguments so we definitely want to use\n+                // two-phase borrows.\n+                self.demand_coerce(&arg,\n+                                   checked_ty,\n+                                   coerce_ty.unwrap_or(formal_ty),\n+                                   AllowTwoPhase::Yes);\n \n                 // 3. Relate the expected type and the formal one,\n                 //    if the expected type was used for the coercion.\n@@ -2847,7 +2851,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             expr,\n             ExpectHasType(expected),\n             needs);\n-        self.demand_coerce(expr, ty, expected)\n+        // checks don't need two phase\n+        self.demand_coerce(expr, ty, expected, AllowTwoPhase::No)\n     }\n \n     fn check_expr_with_hint(&self, expr: &'gcx hir::Expr,\n@@ -3674,7 +3679,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                         // (It shouldn't actually matter for unary ops whether\n                                         // we enable two-phase borrows or not, since a unary\n                                         // op has no additional operands.)\n-                                        allow_two_phase_borrow: false,\n+                                        allow_two_phase_borrow: AllowTwoPhase::No,\n                                     }\n                                 };\n                                 self.apply_adjustments(oprnd, vec![Adjustment {\n@@ -4138,7 +4143,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                   let base_t = self.structurally_resolved_type(expr.span, base_t);\n                   match self.lookup_indexing(expr, base, base_t, idx_t, needs) {\n                       Some((index_ty, element_ty)) => {\n-                          self.demand_coerce(idx, idx_t, index_ty);\n+                          // two-phase not needed because index_ty is never mutable\n+                          self.demand_coerce(idx, idx_t, index_ty, AllowTwoPhase::No);\n                           element_ty\n                       }\n                       None => {"}, {"sha": "efc1e2a80cebef6062806fb667d407a750c1da59", "filename": "src/librustc_typeck/check/op.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b12af86a776364f01f65e3bd551e2641b4fac4ec/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b12af86a776364f01f65e3bd551e2641b4fac4ec/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fop.rs?ref=b12af86a776364f01f65e3bd551e2641b4fac4ec", "patch": "@@ -14,7 +14,7 @@ use super::{FnCtxt, Needs};\n use super::method::MethodCallee;\n use rustc::ty::{self, Ty, TypeFoldable, TypeVariants};\n use rustc::ty::TypeVariants::{TyStr, TyRef, TyAdt};\n-use rustc::ty::adjustment::{Adjustment, Adjust, AutoBorrow, AutoBorrowMutability};\n+use rustc::ty::adjustment::{Adjustment, Adjust, AllowTwoPhase, AutoBorrow, AutoBorrowMutability};\n use rustc::infer::type_variable::TypeVariableOrigin;\n use errors;\n use syntax_pos::Span;\n@@ -203,7 +203,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                             hir::MutMutable => AutoBorrowMutability::Mutable {\n                                 // Allow two-phase borrows for binops in initial deployment\n                                 // since they desugar to methods\n-                                allow_two_phase_borrow: true,\n+                                allow_two_phase_borrow: AllowTwoPhase::Yes,\n                             }\n                         };\n                         let autoref = Adjustment {\n@@ -220,7 +220,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                             hir::MutMutable => AutoBorrowMutability::Mutable {\n                                 // Allow two-phase borrows for binops in initial deployment\n                                 // since they desugar to methods\n-                                allow_two_phase_borrow: true,\n+                                allow_two_phase_borrow: AllowTwoPhase::Yes,\n                             }\n                         };\n                         let autoref = Adjustment {"}, {"sha": "ef39fabda10e62f744b4eb186615c49c036f86da", "filename": "src/test/compile-fail/borrowck/two-phase-nonrecv-autoref.rs", "status": "modified", "additions": 31, "deletions": 18, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/b12af86a776364f01f65e3bd551e2641b4fac4ec/src%2Ftest%2Fcompile-fail%2Fborrowck%2Ftwo-phase-nonrecv-autoref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b12af86a776364f01f65e3bd551e2641b4fac4ec/src%2Ftest%2Fcompile-fail%2Fborrowck%2Ftwo-phase-nonrecv-autoref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck%2Ftwo-phase-nonrecv-autoref.rs?ref=b12af86a776364f01f65e3bd551e2641b4fac4ec", "patch": "@@ -8,7 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// revisions: lxl nll\n+// revisions: ast lxl nll\n+//[ast]compile-flags:\n //[lxl]compile-flags: -Z borrowck=mir -Z two-phase-borrows\n //[nll]compile-flags: -Z borrowck=mir -Z two-phase-borrows -Z nll\n \n@@ -33,17 +34,14 @@\n \n use std::ops::{Index, IndexMut};\n \n-// This is case outlined by Niko that we want to ensure we reject\n-// (at least initially).\n-\n fn foo(x: &mut u32, y: u32) {\n     *x += y;\n }\n \n fn deref_coercion(x: &mut u32) {\n     foo(x, *x);\n-    //[lxl]~^ ERROR cannot use `*x` because it was mutably borrowed [E0503]\n-    //[nll]~^^ ERROR cannot use `*x` because it was mutably borrowed [E0503]\n+    //[ast]~^ ERROR cannot use `*x` because it was mutably borrowed [E0503]\n+    // Above error is a known limitation of AST borrowck\n }\n \n // While adding a flag to adjustments (indicating whether they\n@@ -74,22 +72,25 @@ fn overloaded_call_traits() {\n         //[lxl]~^     ERROR cannot borrow `*f` as mutable more than once at a time\n         //[nll]~^^   ERROR cannot borrow `*f` as mutable more than once at a time\n         //[g2p]~^^^ ERROR cannot borrow `*f` as mutable more than once at a time\n+        //[ast]~^^^^ ERROR cannot borrow `*f` as mutable more than once at a time\n     }\n     fn twice_ten_si<F: Fn(i32) -> i32>(f: &mut F) {\n         f(f(10));\n     }\n     fn twice_ten_so<F: FnOnce(i32) -> i32>(f: Box<F>) {\n         f(f(10));\n-        //[lxl]~^   ERROR use of moved value: `*f`\n-        //[nll]~^^  ERROR use of moved value: `*f`\n-        //[g2p]~^^^ ERROR use of moved value: `*f`\n+        //[lxl]~^    ERROR use of moved value: `*f`\n+        //[nll]~^^   ERROR use of moved value: `*f`\n+        //[g2p]~^^^  ERROR use of moved value: `*f`\n+        //[ast]~^^^^ ERROR use of moved value: `*f`\n     }\n \n     fn twice_ten_om(f: &mut FnMut(i32) -> i32) {\n         f(f(10));\n-        //[lxl]~^     ERROR cannot borrow `*f` as mutable more than once at a time\n+        //[lxl]~^    ERROR cannot borrow `*f` as mutable more than once at a time\n         //[nll]~^^   ERROR cannot borrow `*f` as mutable more than once at a time\n-        //[g2p]~^^^ ERROR cannot borrow `*f` as mutable more than once at a time\n+        //[g2p]~^^^  ERROR cannot borrow `*f` as mutable more than once at a time\n+        //[ast]~^^^^ ERROR cannot borrow `*f` as mutable more than once at a time\n     }\n     fn twice_ten_oi(f: &mut Fn(i32) -> i32) {\n         f(f(10));\n@@ -105,6 +106,7 @@ fn overloaded_call_traits() {\n         //[g2p]~^^^^^^^       ERROR cannot move a value of type\n         //[g2p]~^^^^^^^^      ERROR cannot move a value of type\n         //[g2p]~^^^^^^^^^     ERROR use of moved value: `*f`\n+        //[ast]~^^^^^^^^^^    ERROR use of moved value: `*f`\n     }\n \n     twice_ten_sm(&mut |x| x + 1);\n@@ -142,12 +144,15 @@ fn coerce_unsized() {\n \n     // This is not okay.\n     double_access(&mut a, &a);\n-    //[lxl]~^   ERROR cannot borrow `a` as immutable because it is also borrowed as mutable [E0502]\n-    //[nll]~^^  ERROR cannot borrow `a` as immutable because it is also borrowed as mutable [E0502]\n-    //[g2p]~^^^ ERROR cannot borrow `a` as immutable because it is also borrowed as mutable [E0502]\n+    //[lxl]~^    ERROR cannot borrow `a` as immutable because it is also borrowed as mutable [E0502]\n+    //[nll]~^^   ERROR cannot borrow `a` as immutable because it is also borrowed as mutable [E0502]\n+    //[g2p]~^^^  ERROR cannot borrow `a` as immutable because it is also borrowed as mutable [E0502]\n+    //[ast]~^^^^ ERROR cannot borrow `a` as immutable because it is also borrowed as mutable [E0502]\n \n     // But this is okay.\n     a.m(a.i(10));\n+    //[ast]~^ ERROR cannot borrow `a` as immutable because it is also borrowed as mutable [E0502]\n+    // Above error is an expected limitation of AST borrowck\n }\n \n struct I(i32);\n@@ -168,21 +173,25 @@ impl IndexMut<i32> for I {\n fn coerce_index_op() {\n     let mut i = I(10);\n     i[i[3]] = 4;\n-    //[lxl]~^  ERROR cannot borrow `i` as immutable because it is also borrowed as mutable [E0502]\n-    //[nll]~^^ ERROR cannot borrow `i` as immutable because it is also borrowed as mutable [E0502]\n+    //[lxl]~^   ERROR cannot borrow `i` as immutable because it is also borrowed as mutable [E0502]\n+    //[nll]~^^  ERROR cannot borrow `i` as immutable because it is also borrowed as mutable [E0502]\n+    //[ast]~^^^ ERROR cannot borrow `i` as immutable because it is also borrowed as mutable [E0502]\n \n     i[3] = i[4];\n \n     i[i[3]] = i[4];\n-    //[lxl]~^  ERROR cannot borrow `i` as immutable because it is also borrowed as mutable [E0502]\n-    //[nll]~^^ ERROR cannot borrow `i` as immutable because it is also borrowed as mutable [E0502]\n+    //[lxl]~^   ERROR cannot borrow `i` as immutable because it is also borrowed as mutable [E0502]\n+    //[nll]~^^  ERROR cannot borrow `i` as immutable because it is also borrowed as mutable [E0502]\n+    //[ast]~^^^ ERROR cannot borrow `i` as immutable because it is also borrowed as mutable [E0502]\n }\n \n fn main() {\n \n     // As a reminder, this is the basic case we want to ensure we handle.\n     let mut v = vec![1, 2, 3];\n     v.push(v.len());\n+    //[ast]~^ ERROR cannot borrow `v` as immutable because it is also borrowed as mutable [E0502]\n+    // Error above is an expected limitation of AST borrowck\n \n     // (as a rule, pnkfelix does not like to write tests with dead code.)\n \n@@ -192,9 +201,13 @@ fn main() {\n \n     let mut s = S;\n     s.m(s.i(10));\n+    //[ast]~^ ERROR cannot borrow `s` as immutable because it is also borrowed as mutable [E0502]\n+    // Error above is an expected limitation of AST borrowck\n \n     let mut t = T;\n     t.m(t.i(10));\n+    //[ast]~^ ERROR cannot borrow `t` as immutable because it is also borrowed as mutable [E0502]\n+    // Error above is an expected limitation of AST borrowck\n \n     coerce_unsized();\n     coerce_index_op();"}, {"sha": "e690263a916f3cf5f42750f229a1fb8f424b25eb", "filename": "src/test/ui/borrowck/two-phase-method-receivers.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/b12af86a776364f01f65e3bd551e2641b4fac4ec/src%2Ftest%2Fui%2Fborrowck%2Ftwo-phase-method-receivers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b12af86a776364f01f65e3bd551e2641b4fac4ec/src%2Ftest%2Fui%2Fborrowck%2Ftwo-phase-method-receivers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Ftwo-phase-method-receivers.rs?ref=b12af86a776364f01f65e3bd551e2641b4fac4ec", "patch": "@@ -0,0 +1,29 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// revisions: lxl nll\n+//[lxl]compile-flags: -Z borrowck=mir -Z two-phase-borrows\n+//[nll]compile-flags: -Z borrowck=mir -Z two-phase-borrows -Z nll\n+\n+// run-pass\n+\n+struct Foo<'a> {\n+    x: &'a i32\n+}\n+\n+impl<'a> Foo<'a> {\n+    fn method(&mut self, _: &i32) {\n+    }\n+}\n+\n+fn main() {\n+    let a = &mut Foo { x: &22 };\n+    Foo::method(a, a.x);\n+}"}]}