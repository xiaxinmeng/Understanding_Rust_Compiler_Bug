{"sha": "a264acaf1a0cbc4f0e5b654da15cbf5614901824", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEyNjRhY2FmMWEwY2JjNGYwZTViNjU0ZGExNWNiZjU2MTQ5MDE4MjQ=", "commit": {"author": {"name": "Dylan DPC", "email": "dylan.dpc@gmail.com", "date": "2020-05-14T23:57:07Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-05-14T23:57:07Z"}, "message": "Rollup merge of #71809 - marmeladema:fix-issue-71104, r=eddyb\n\nUse `LocalDefId` in `DumpVisitor::nest_tables`\n\nThis is a partial fix for #71104", "tree": {"sha": "22f663059cc9d7eda0954619c0e6a6ed4b7a6522", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/22f663059cc9d7eda0954619c0e6a6ed4b7a6522"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a264acaf1a0cbc4f0e5b654da15cbf5614901824", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJevdrVCRBK7hj4Ov3rIwAAdHIIAAhkgSZhQZWjlaq0bTVdCsdU\niEsA4wKwZ2RoPTLEhe9mcmEWZPJGjLs5hAW4vJomdh/rLS/cnVD57zzR9NT/DMKv\nMjKRqUqyvn/3Pv787TUP6GtB+acD3CBvlmQxJeZ3ZYtlwIURPsupFvVxFzL5jDdi\nDtdcDSVXVymdv/T9eYVxRpX2zFVyHQtonNpIXlIvBMlR1yQOhyMi00hO1cIIPjH2\nrAzbtkR0abxPjxcuOlYehZhPN3oFNRg274lWjXOSio47GLbdD54askWHPraTO3on\nZVDMrKnmz2mgfH1ul8f1PVXn89eqPvLbsgwG1DbUsGuEqCNhfK6UhknZqesUeEg=\n=bmMS\n-----END PGP SIGNATURE-----\n", "payload": "tree 22f663059cc9d7eda0954619c0e6a6ed4b7a6522\nparent a74d1862d4d87a56244958416fd05976c58ca1a8\nparent e5a1be8597c21c7b547a02231e5cf072dd3a0179\nauthor Dylan DPC <dylan.dpc@gmail.com> 1589500627 +0200\ncommitter GitHub <noreply@github.com> 1589500627 +0200\n\nRollup merge of #71809 - marmeladema:fix-issue-71104, r=eddyb\n\nUse `LocalDefId` in `DumpVisitor::nest_tables`\n\nThis is a partial fix for #71104\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a264acaf1a0cbc4f0e5b654da15cbf5614901824", "html_url": "https://github.com/rust-lang/rust/commit/a264acaf1a0cbc4f0e5b654da15cbf5614901824", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a264acaf1a0cbc4f0e5b654da15cbf5614901824/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a74d1862d4d87a56244958416fd05976c58ca1a8", "url": "https://api.github.com/repos/rust-lang/rust/commits/a74d1862d4d87a56244958416fd05976c58ca1a8", "html_url": "https://github.com/rust-lang/rust/commit/a74d1862d4d87a56244958416fd05976c58ca1a8"}, {"sha": "e5a1be8597c21c7b547a02231e5cf072dd3a0179", "url": "https://api.github.com/repos/rust-lang/rust/commits/e5a1be8597c21c7b547a02231e5cf072dd3a0179", "html_url": "https://github.com/rust-lang/rust/commit/e5a1be8597c21c7b547a02231e5cf072dd3a0179"}], "stats": {"total": 77, "additions": 41, "deletions": 36}, "files": [{"sha": "3dd715f9e3df6773fb8a4bbed31ac92059901729", "filename": "src/librustc_save_analysis/dump_visitor.rs", "status": "modified", "additions": 41, "deletions": 29, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/a264acaf1a0cbc4f0e5b654da15cbf5614901824/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a264acaf1a0cbc4f0e5b654da15cbf5614901824/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdump_visitor.rs?ref=a264acaf1a0cbc4f0e5b654da15cbf5614901824", "patch": "@@ -21,7 +21,7 @@ use rustc_ast::walk_list;\n use rustc_ast_pretty::pprust::{bounds_to_string, generic_params_to_string, ty_to_string};\n use rustc_data_structures::fx::FxHashSet;\n use rustc_hir::def::{DefKind as HirDefKind, Res};\n-use rustc_hir::def_id::DefId;\n+use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_middle::span_bug;\n use rustc_middle::ty::{self, DefIdTree, TyCtxt};\n use rustc_session::config::Input;\n@@ -104,12 +104,10 @@ impl<'l, 'tcx> DumpVisitor<'l, 'tcx> {\n         self.dumper.analysis()\n     }\n \n-    fn nest_tables<F>(&mut self, item_id: NodeId, f: F)\n+    fn nest_tables<F>(&mut self, item_def_id: LocalDefId, f: F)\n     where\n         F: FnOnce(&mut Self),\n     {\n-        let item_def_id = self.tcx.hir().local_def_id_from_node_id(item_id);\n-\n         let tables = if self.tcx.has_typeck_tables(item_def_id) {\n             self.tcx.typeck_tables_of(item_def_id)\n         } else {\n@@ -272,8 +270,9 @@ impl<'l, 'tcx> DumpVisitor<'l, 'tcx> {\n     ) {\n         debug!(\"process_method: {}:{}\", id, ident);\n \n-        let hir_id = self.tcx.hir().node_id_to_hir_id(id);\n-        self.nest_tables(id, |v| {\n+        let map = &self.tcx.hir();\n+        let hir_id = map.node_id_to_hir_id(id);\n+        self.nest_tables(map.local_def_id(hir_id), |v| {\n             if let Some(mut method_data) = v.save_ctxt.get_method_data(id, ident, span) {\n                 v.process_formals(&sig.decl.inputs, &method_data.qualname);\n                 v.process_generic_params(&generics, &method_data.qualname, id);\n@@ -296,7 +295,8 @@ impl<'l, 'tcx> DumpVisitor<'l, 'tcx> {\n                 // start walking from the newly-created definition.\n                 match sig.header.asyncness {\n                     ast::Async::Yes { return_impl_trait_id, .. } => {\n-                        v.nest_tables(return_impl_trait_id, |v| v.visit_ty(ret_ty))\n+                        let hir_id = map.node_id_to_hir_id(return_impl_trait_id);\n+                        v.nest_tables(map.local_def_id(hir_id), |v| v.visit_ty(ret_ty))\n                     }\n                     _ => v.visit_ty(ret_ty),\n                 }\n@@ -364,8 +364,9 @@ impl<'l, 'tcx> DumpVisitor<'l, 'tcx> {\n         ty_params: &'l ast::Generics,\n         body: Option<&'l ast::Block>,\n     ) {\n-        let hir_id = self.tcx.hir().node_id_to_hir_id(item.id);\n-        self.nest_tables(item.id, |v| {\n+        let map = &self.tcx.hir();\n+        let hir_id = map.node_id_to_hir_id(item.id);\n+        self.nest_tables(map.local_def_id(hir_id), |v| {\n             if let Some(fn_data) = v.save_ctxt.get_item_data(item) {\n                 down_cast_data!(fn_data, DefData, item.span);\n                 v.process_formals(&decl.inputs, &fn_data.qualname);\n@@ -389,7 +390,8 @@ impl<'l, 'tcx> DumpVisitor<'l, 'tcx> {\n                     // start walking from the newly-created definition.\n                     match header.asyncness {\n                         ast::Async::Yes { return_impl_trait_id, .. } => {\n-                            v.nest_tables(return_impl_trait_id, |v| v.visit_ty(ret_ty))\n+                            let hir_id = map.node_id_to_hir_id(return_impl_trait_id);\n+                            v.nest_tables(map.local_def_id(hir_id), |v| v.visit_ty(ret_ty))\n                         }\n                         _ => v.visit_ty(ret_ty),\n                     }\n@@ -407,7 +409,7 @@ impl<'l, 'tcx> DumpVisitor<'l, 'tcx> {\n         expr: Option<&'l ast::Expr>,\n     ) {\n         let hir_id = self.tcx.hir().node_id_to_hir_id(item.id);\n-        self.nest_tables(item.id, |v| {\n+        self.nest_tables(self.tcx.hir().local_def_id(hir_id), |v| {\n             if let Some(var_data) = v.save_ctxt.get_item_data(item) {\n                 down_cast_data!(var_data, DefData, item.span);\n                 v.dumper.dump_def(&access_from!(v.save_ctxt, item, hir_id), var_data);\n@@ -427,15 +429,13 @@ impl<'l, 'tcx> DumpVisitor<'l, 'tcx> {\n         vis: ast::Visibility,\n         attrs: &'l [Attribute],\n     ) {\n-        let qualname = format!(\n-            \"::{}\",\n-            self.tcx.def_path_str(self.tcx.hir().local_def_id_from_node_id(id).to_def_id())\n-        );\n+        let hir_id = self.tcx.hir().node_id_to_hir_id(id);\n+        let qualname =\n+            format!(\"::{}\", self.tcx.def_path_str(self.tcx.hir().local_def_id(hir_id).to_def_id()));\n \n         if !self.span.filter_generated(ident.span) {\n             let sig = sig::assoc_const_signature(id, ident.name, typ, expr, &self.save_ctxt);\n             let span = self.span_from_span(ident.span);\n-            let hir_id = self.tcx.hir().node_id_to_hir_id(id);\n \n             self.dumper.dump_def(\n                 &access_from_vis!(self.save_ctxt, vis, hir_id),\n@@ -457,7 +457,7 @@ impl<'l, 'tcx> DumpVisitor<'l, 'tcx> {\n         }\n \n         // walk type and init value\n-        self.nest_tables(id, |v| {\n+        self.nest_tables(self.tcx.hir().local_def_id(hir_id), |v| {\n             v.visit_ty(typ);\n             if let Some(expr) = expr {\n                 v.visit_expr(expr);\n@@ -474,10 +474,9 @@ impl<'l, 'tcx> DumpVisitor<'l, 'tcx> {\n     ) {\n         debug!(\"process_struct {:?} {:?}\", item, item.span);\n         let name = item.ident.to_string();\n-        let qualname = format!(\n-            \"::{}\",\n-            self.tcx.def_path_str(self.tcx.hir().local_def_id_from_node_id(item.id).to_def_id())\n-        );\n+        let hir_id = self.tcx.hir().node_id_to_hir_id(item.id);\n+        let qualname =\n+            format!(\"::{}\", self.tcx.def_path_str(self.tcx.hir().local_def_id(hir_id).to_def_id()));\n \n         let kind = match item.kind {\n             ast::ItemKind::Struct(_, _) => DefKind::Struct,\n@@ -509,7 +508,6 @@ impl<'l, 'tcx> DumpVisitor<'l, 'tcx> {\n \n         if !self.span.filter_generated(item.ident.span) {\n             let span = self.span_from_span(item.ident.span);\n-            let hir_id = self.tcx.hir().node_id_to_hir_id(item.id);\n             self.dumper.dump_def(\n                 &access_from!(self.save_ctxt, item, hir_id),\n                 Def {\n@@ -529,7 +527,7 @@ impl<'l, 'tcx> DumpVisitor<'l, 'tcx> {\n             );\n         }\n \n-        self.nest_tables(item.id, |v| {\n+        self.nest_tables(self.tcx.hir().local_def_id(hir_id), |v| {\n             for field in def.fields() {\n                 v.process_struct_field_def(field, item.id);\n                 v.visit_ty(&field.ty);\n@@ -669,14 +667,15 @@ impl<'l, 'tcx> DumpVisitor<'l, 'tcx> {\n         }\n \n         let map = &self.tcx.hir();\n-        self.nest_tables(item.id, |v| {\n+        let hir_id = map.node_id_to_hir_id(item.id);\n+        self.nest_tables(map.local_def_id(hir_id), |v| {\n             v.visit_ty(&typ);\n             if let &Some(ref trait_ref) = trait_ref {\n                 v.process_path(trait_ref.ref_id, &trait_ref.path);\n             }\n             v.process_generic_params(generics, \"\", item.id);\n             for impl_item in impl_items {\n-                v.process_impl_item(impl_item, map.local_def_id_from_node_id(item.id).to_def_id());\n+                v.process_impl_item(impl_item, map.local_def_id(hir_id).to_def_id());\n             }\n         });\n     }\n@@ -1411,7 +1410,10 @@ impl<'l, 'tcx> Visitor<'l> for DumpVisitor<'l, 'tcx> {\n             }\n             ast::TyKind::Array(ref element, ref length) => {\n                 self.visit_ty(element);\n-                self.nest_tables(length.id, |v| v.visit_expr(&length.value));\n+                let hir_id = self.tcx.hir().node_id_to_hir_id(length.id);\n+                self.nest_tables(self.tcx.hir().local_def_id(hir_id), |v| {\n+                    v.visit_expr(&length.value)\n+                });\n             }\n             ast::TyKind::ImplTrait(id, ref bounds) => {\n                 // FIXME: As of writing, the opaque type lowering introduces\n@@ -1423,7 +1425,13 @@ impl<'l, 'tcx> Visitor<'l> for DumpVisitor<'l, 'tcx> {\n                 // bounds...\n                 // This will panic if called on return type `impl Trait`, which\n                 // we guard against in `process_fn`.\n-                self.nest_tables(id, |v| v.process_bounds(bounds));\n+                // FIXME(#71104) Should really be using just `node_id_to_hir_id` but\n+                // some `NodeId` do not seem to have a corresponding HirId.\n+                if let Some(hir_id) = self.tcx.hir().opt_node_id_to_hir_id(id) {\n+                    self.nest_tables(self.tcx.hir().local_def_id(hir_id), |v| {\n+                        v.process_bounds(bounds)\n+                    });\n+                }\n             }\n             _ => visit::walk_ty(self, t),\n         }\n@@ -1471,7 +1479,8 @@ impl<'l, 'tcx> Visitor<'l> for DumpVisitor<'l, 'tcx> {\n                 }\n \n                 // walk the body\n-                self.nest_tables(ex.id, |v| {\n+                let hir_id = self.tcx.hir().node_id_to_hir_id(ex.id);\n+                self.nest_tables(self.tcx.hir().local_def_id(hir_id), |v| {\n                     v.process_formals(&decl.inputs, &id);\n                     v.visit_expr(body)\n                 });\n@@ -1488,7 +1497,10 @@ impl<'l, 'tcx> Visitor<'l> for DumpVisitor<'l, 'tcx> {\n             }\n             ast::ExprKind::Repeat(ref element, ref count) => {\n                 self.visit_expr(element);\n-                self.nest_tables(count.id, |v| v.visit_expr(&count.value));\n+                let hir_id = self.tcx.hir().node_id_to_hir_id(count.id);\n+                self.nest_tables(self.tcx.hir().local_def_id(hir_id), |v| {\n+                    v.visit_expr(&count.value)\n+                });\n             }\n             // In particular, we take this branch for call and path expressions,\n             // where we'll index the idents involved just by continuing to walk."}, {"sha": "79dde84b8b1bce844fb93b4c78137126505c455b", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a264acaf1a0cbc4f0e5b654da15cbf5614901824/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a264acaf1a0cbc4f0e5b654da15cbf5614901824/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=a264acaf1a0cbc4f0e5b654da15cbf5614901824", "patch": "@@ -831,13 +831,6 @@ fn primary_body_of(\n }\n \n fn has_typeck_tables(tcx: TyCtxt<'_>, def_id: DefId) -> bool {\n-    // FIXME(#71104) some `LocalDefId` do not seem to have a corresponding `HirId`.\n-    if let Some(def_id) = def_id.as_local() {\n-        if tcx.hir().opt_local_def_id_to_hir_id(def_id).is_none() {\n-            return false;\n-        }\n-    }\n-\n     // Closures' tables come from their outermost function,\n     // as they are part of the same \"inference environment\".\n     let outer_def_id = tcx.closure_base_def_id(def_id);"}]}